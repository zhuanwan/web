"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[2708],{412:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar colorAll = ['#37A2DA', '#32C5E9', '#67E0E3', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#E062AE', '#E690D1', '#e7bcf3', '#9d96f5', '#8378EA', '#96BFFF'];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  color: colorAll,\n  colorLayer: [['#37A2DA', '#ffd85c', '#fd7b5f'], ['#37A2DA', '#67E0E3', '#FFDB5C', '#ff9f7f', '#E062AE', '#9d96f5'], ['#37A2DA', '#32C5E9', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#e7bcf3', '#8378EA', '#96BFFF'], colorAll]\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEyLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi90aGVtZS9saWdodC5qcz9kOTRmIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xudmFyIGNvbG9yQWxsID0gWycjMzdBMkRBJywgJyMzMkM1RTknLCAnIzY3RTBFMycsICcjOUZFNkI4JywgJyNGRkRCNUMnLCAnI2ZmOWY3ZicsICcjZmI3MjkzJywgJyNFMDYyQUUnLCAnI0U2OTBEMScsICcjZTdiY2YzJywgJyM5ZDk2ZjUnLCAnIzgzNzhFQScsICcjOTZCRkZGJ107XG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbG9yOiBjb2xvckFsbCxcbiAgY29sb3JMYXllcjogW1snIzM3QTJEQScsICcjZmZkODVjJywgJyNmZDdiNWYnXSwgWycjMzdBMkRBJywgJyM2N0UwRTMnLCAnI0ZGREI1QycsICcjZmY5ZjdmJywgJyNFMDYyQUUnLCAnIzlkOTZmNSddLCBbJyMzN0EyREEnLCAnIzMyQzVFOScsICcjOUZFNkI4JywgJyNGRkRCNUMnLCAnI2ZmOWY3ZicsICcjZmI3MjkzJywgJyNlN2JjZjMnLCAnIzgzNzhFQScsICcjOTZCRkZGJ10sIGNvbG9yQWxsXVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///412\n")},7213:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ dataStack)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24326);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n// (1) [Caution]: the logic is correct based on the premises:\n//     data processing stage is blocked in stream.\n//     See <module:echarts/stream/Scheduler#performDataProcessorTasks>\n// (2) Only register once when import repeatedly.\n//     Should be executed after series is filtered and before stack calculation.\nfunction dataStack(ecModel) {\n  var stackInfoMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();\n  ecModel.eachSeries(function (seriesModel) {\n    var stack = seriesModel.get('stack');\n    // Compatible: when `stack` is set as '', do not stack.\n    if (stack) {\n      var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);\n      var data = seriesModel.getData();\n      var stackInfo = {\n        // Used for calculate axis extent automatically.\n        // TODO: Type getCalculationInfo return more specific type?\n        stackResultDimension: data.getCalculationInfo('stackResultDimension'),\n        stackedOverDimension: data.getCalculationInfo('stackedOverDimension'),\n        stackedDimension: data.getCalculationInfo('stackedDimension'),\n        stackedByDimension: data.getCalculationInfo('stackedByDimension'),\n        isStackedByIndex: data.getCalculationInfo('isStackedByIndex'),\n        data: data,\n        seriesModel: seriesModel\n      };\n      // If stacked on axis that do not support data stack.\n      if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {\n        return;\n      }\n      stackInfoList.length && data.setCalculationInfo('stackedOnSeries', stackInfoList[stackInfoList.length - 1].seriesModel);\n      stackInfoList.push(stackInfo);\n    }\n  });\n  stackInfoMap.each(calculateStack);\n}\nfunction calculateStack(stackInfoList) {\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(stackInfoList, function (targetStackInfo, idxInStack) {\n    var resultVal = [];\n    var resultNaN = [NaN, NaN];\n    var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];\n    var targetData = targetStackInfo.data;\n    var isStackedByIndex = targetStackInfo.isStackedByIndex;\n    var stackStrategy = targetStackInfo.seriesModel.get('stackStrategy') || 'samesign';\n    // Should not write on raw data, because stack series model list changes\n    // depending on legend selection.\n    targetData.modify(dims, function (v0, v1, dataIndex) {\n      var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex);\n      // Consider `connectNulls` of line area, if value is NaN, stackedOver\n      // should also be NaN, to draw a appropriate belt area.\n      if (isNaN(sum)) {\n        return resultNaN;\n      }\n      var byValue;\n      var stackedDataRawIndex;\n      if (isStackedByIndex) {\n        stackedDataRawIndex = targetData.getRawIndex(dataIndex);\n      } else {\n        byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);\n      }\n      // If stackOver is NaN, chart view will render point on value start.\n      var stackedOver = NaN;\n      for (var j = idxInStack - 1; j >= 0; j--) {\n        var stackInfo = stackInfoList[j];\n        // Has been optimized by inverted indices on `stackedByDimension`.\n        if (!isStackedByIndex) {\n          stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);\n        }\n        if (stackedDataRawIndex >= 0) {\n          var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);\n          // Considering positive stack, negative stack and empty data\n          if (stackStrategy === 'all' // single stack group\n          || stackStrategy === 'positive' && val > 0 || stackStrategy === 'negative' && val < 0 || stackStrategy === 'samesign' && sum >= 0 && val > 0 // All positive stack\n          || stackStrategy === 'samesign' && sum <= 0 && val < 0 // All negative stack\n          ) {\n            // The sum has to be very small to be affected by the\n            // floating arithmetic problem. An incorrect result will probably\n            // cause axis min/max to be filtered incorrectly.\n            sum = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .addSafe */ .Tr)(sum, val);\n            stackedOver = val;\n            break;\n          }\n        }\n      }\n      resultVal[0] = sum;\n      resultVal[1] = stackedOver;\n      return resultVal;\n    });\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIxMy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhU3RhY2suanM/ZDkyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGNyZWF0ZUhhc2hNYXAsIGVhY2ggfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgYWRkU2FmZSB9IGZyb20gJy4uL3V0aWwvbnVtYmVyLmpzJztcbi8vICgxKSBbQ2F1dGlvbl06IHRoZSBsb2dpYyBpcyBjb3JyZWN0IGJhc2VkIG9uIHRoZSBwcmVtaXNlczpcbi8vICAgICBkYXRhIHByb2Nlc3Npbmcgc3RhZ2UgaXMgYmxvY2tlZCBpbiBzdHJlYW0uXG4vLyAgICAgU2VlIDxtb2R1bGU6ZWNoYXJ0cy9zdHJlYW0vU2NoZWR1bGVyI3BlcmZvcm1EYXRhUHJvY2Vzc29yVGFza3M+XG4vLyAoMikgT25seSByZWdpc3RlciBvbmNlIHdoZW4gaW1wb3J0IHJlcGVhdGVkbHkuXG4vLyAgICAgU2hvdWxkIGJlIGV4ZWN1dGVkIGFmdGVyIHNlcmllcyBpcyBmaWx0ZXJlZCBhbmQgYmVmb3JlIHN0YWNrIGNhbGN1bGF0aW9uLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGF0YVN0YWNrKGVjTW9kZWwpIHtcbiAgdmFyIHN0YWNrSW5mb01hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBzdGFjayA9IHNlcmllc01vZGVsLmdldCgnc3RhY2snKTtcbiAgICAvLyBDb21wYXRpYmxlOiB3aGVuIGBzdGFja2AgaXMgc2V0IGFzICcnLCBkbyBub3Qgc3RhY2suXG4gICAgaWYgKHN0YWNrKSB7XG4gICAgICB2YXIgc3RhY2tJbmZvTGlzdCA9IHN0YWNrSW5mb01hcC5nZXQoc3RhY2spIHx8IHN0YWNrSW5mb01hcC5zZXQoc3RhY2ssIFtdKTtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgdmFyIHN0YWNrSW5mbyA9IHtcbiAgICAgICAgLy8gVXNlZCBmb3IgY2FsY3VsYXRlIGF4aXMgZXh0ZW50IGF1dG9tYXRpY2FsbHkuXG4gICAgICAgIC8vIFRPRE86IFR5cGUgZ2V0Q2FsY3VsYXRpb25JbmZvIHJldHVybiBtb3JlIHNwZWNpZmljIHR5cGU/XG4gICAgICAgIHN0YWNrUmVzdWx0RGltZW5zaW9uOiBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tSZXN1bHREaW1lbnNpb24nKSxcbiAgICAgICAgc3RhY2tlZE92ZXJEaW1lbnNpb246IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja2VkT3ZlckRpbWVuc2lvbicpLFxuICAgICAgICBzdGFja2VkRGltZW5zaW9uOiBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZERpbWVuc2lvbicpLFxuICAgICAgICBzdGFja2VkQnlEaW1lbnNpb246IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja2VkQnlEaW1lbnNpb24nKSxcbiAgICAgICAgaXNTdGFja2VkQnlJbmRleDogZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ2lzU3RhY2tlZEJ5SW5kZXgnKSxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgc2VyaWVzTW9kZWw6IHNlcmllc01vZGVsXG4gICAgICB9O1xuICAgICAgLy8gSWYgc3RhY2tlZCBvbiBheGlzIHRoYXQgZG8gbm90IHN1cHBvcnQgZGF0YSBzdGFjay5cbiAgICAgIGlmICghc3RhY2tJbmZvLnN0YWNrZWREaW1lbnNpb24gfHwgIShzdGFja0luZm8uaXNTdGFja2VkQnlJbmRleCB8fCBzdGFja0luZm8uc3RhY2tlZEJ5RGltZW5zaW9uKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdGFja0luZm9MaXN0Lmxlbmd0aCAmJiBkYXRhLnNldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZE9uU2VyaWVzJywgc3RhY2tJbmZvTGlzdFtzdGFja0luZm9MaXN0Lmxlbmd0aCAtIDFdLnNlcmllc01vZGVsKTtcbiAgICAgIHN0YWNrSW5mb0xpc3QucHVzaChzdGFja0luZm8pO1xuICAgIH1cbiAgfSk7XG4gIHN0YWNrSW5mb01hcC5lYWNoKGNhbGN1bGF0ZVN0YWNrKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVN0YWNrKHN0YWNrSW5mb0xpc3QpIHtcbiAgZWFjaChzdGFja0luZm9MaXN0LCBmdW5jdGlvbiAodGFyZ2V0U3RhY2tJbmZvLCBpZHhJblN0YWNrKSB7XG4gICAgdmFyIHJlc3VsdFZhbCA9IFtdO1xuICAgIHZhciByZXN1bHROYU4gPSBbTmFOLCBOYU5dO1xuICAgIHZhciBkaW1zID0gW3RhcmdldFN0YWNrSW5mby5zdGFja1Jlc3VsdERpbWVuc2lvbiwgdGFyZ2V0U3RhY2tJbmZvLnN0YWNrZWRPdmVyRGltZW5zaW9uXTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldFN0YWNrSW5mby5kYXRhO1xuICAgIHZhciBpc1N0YWNrZWRCeUluZGV4ID0gdGFyZ2V0U3RhY2tJbmZvLmlzU3RhY2tlZEJ5SW5kZXg7XG4gICAgdmFyIHN0YWNrU3RyYXRlZ3kgPSB0YXJnZXRTdGFja0luZm8uc2VyaWVzTW9kZWwuZ2V0KCdzdGFja1N0cmF0ZWd5JykgfHwgJ3NhbWVzaWduJztcbiAgICAvLyBTaG91bGQgbm90IHdyaXRlIG9uIHJhdyBkYXRhLCBiZWNhdXNlIHN0YWNrIHNlcmllcyBtb2RlbCBsaXN0IGNoYW5nZXNcbiAgICAvLyBkZXBlbmRpbmcgb24gbGVnZW5kIHNlbGVjdGlvbi5cbiAgICB0YXJnZXREYXRhLm1vZGlmeShkaW1zLCBmdW5jdGlvbiAodjAsIHYxLCBkYXRhSW5kZXgpIHtcbiAgICAgIHZhciBzdW0gPSB0YXJnZXREYXRhLmdldCh0YXJnZXRTdGFja0luZm8uc3RhY2tlZERpbWVuc2lvbiwgZGF0YUluZGV4KTtcbiAgICAgIC8vIENvbnNpZGVyIGBjb25uZWN0TnVsbHNgIG9mIGxpbmUgYXJlYSwgaWYgdmFsdWUgaXMgTmFOLCBzdGFja2VkT3ZlclxuICAgICAgLy8gc2hvdWxkIGFsc28gYmUgTmFOLCB0byBkcmF3IGEgYXBwcm9wcmlhdGUgYmVsdCBhcmVhLlxuICAgICAgaWYgKGlzTmFOKHN1bSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdE5hTjtcbiAgICAgIH1cbiAgICAgIHZhciBieVZhbHVlO1xuICAgICAgdmFyIHN0YWNrZWREYXRhUmF3SW5kZXg7XG4gICAgICBpZiAoaXNTdGFja2VkQnlJbmRleCkge1xuICAgICAgICBzdGFja2VkRGF0YVJhd0luZGV4ID0gdGFyZ2V0RGF0YS5nZXRSYXdJbmRleChkYXRhSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnlWYWx1ZSA9IHRhcmdldERhdGEuZ2V0KHRhcmdldFN0YWNrSW5mby5zdGFja2VkQnlEaW1lbnNpb24sIGRhdGFJbmRleCk7XG4gICAgICB9XG4gICAgICAvLyBJZiBzdGFja092ZXIgaXMgTmFOLCBjaGFydCB2aWV3IHdpbGwgcmVuZGVyIHBvaW50IG9uIHZhbHVlIHN0YXJ0LlxuICAgICAgdmFyIHN0YWNrZWRPdmVyID0gTmFOO1xuICAgICAgZm9yICh2YXIgaiA9IGlkeEluU3RhY2sgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICB2YXIgc3RhY2tJbmZvID0gc3RhY2tJbmZvTGlzdFtqXTtcbiAgICAgICAgLy8gSGFzIGJlZW4gb3B0aW1pemVkIGJ5IGludmVydGVkIGluZGljZXMgb24gYHN0YWNrZWRCeURpbWVuc2lvbmAuXG4gICAgICAgIGlmICghaXNTdGFja2VkQnlJbmRleCkge1xuICAgICAgICAgIHN0YWNrZWREYXRhUmF3SW5kZXggPSBzdGFja0luZm8uZGF0YS5yYXdJbmRleE9mKHN0YWNrSW5mby5zdGFja2VkQnlEaW1lbnNpb24sIGJ5VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFja2VkRGF0YVJhd0luZGV4ID49IDApIHtcbiAgICAgICAgICB2YXIgdmFsID0gc3RhY2tJbmZvLmRhdGEuZ2V0QnlSYXdJbmRleChzdGFja0luZm8uc3RhY2tSZXN1bHREaW1lbnNpb24sIHN0YWNrZWREYXRhUmF3SW5kZXgpO1xuICAgICAgICAgIC8vIENvbnNpZGVyaW5nIHBvc2l0aXZlIHN0YWNrLCBuZWdhdGl2ZSBzdGFjayBhbmQgZW1wdHkgZGF0YVxuICAgICAgICAgIGlmIChzdGFja1N0cmF0ZWd5ID09PSAnYWxsJyAvLyBzaW5nbGUgc3RhY2sgZ3JvdXBcbiAgICAgICAgICB8fCBzdGFja1N0cmF0ZWd5ID09PSAncG9zaXRpdmUnICYmIHZhbCA+IDAgfHwgc3RhY2tTdHJhdGVneSA9PT0gJ25lZ2F0aXZlJyAmJiB2YWwgPCAwIHx8IHN0YWNrU3RyYXRlZ3kgPT09ICdzYW1lc2lnbicgJiYgc3VtID49IDAgJiYgdmFsID4gMCAvLyBBbGwgcG9zaXRpdmUgc3RhY2tcbiAgICAgICAgICB8fCBzdGFja1N0cmF0ZWd5ID09PSAnc2FtZXNpZ24nICYmIHN1bSA8PSAwICYmIHZhbCA8IDAgLy8gQWxsIG5lZ2F0aXZlIHN0YWNrXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBUaGUgc3VtIGhhcyB0byBiZSB2ZXJ5IHNtYWxsIHRvIGJlIGFmZmVjdGVkIGJ5IHRoZVxuICAgICAgICAgICAgLy8gZmxvYXRpbmcgYXJpdGhtZXRpYyBwcm9ibGVtLiBBbiBpbmNvcnJlY3QgcmVzdWx0IHdpbGwgcHJvYmFibHlcbiAgICAgICAgICAgIC8vIGNhdXNlIGF4aXMgbWluL21heCB0byBiZSBmaWx0ZXJlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICAgIHN1bSA9IGFkZFNhZmUoc3VtLCB2YWwpO1xuICAgICAgICAgICAgc3RhY2tlZE92ZXIgPSB2YWw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdFZhbFswXSA9IHN1bTtcbiAgICAgIHJlc3VsdFZhbFsxXSA9IHN0YWNrZWRPdmVyO1xuICAgICAgcmV0dXJuIHJlc3VsdFZhbDtcbiAgICB9KTtcbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7213\n")},7442:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ registerInternalOptionCreator),\n/* harmony export */   a: () => (/* binding */ concatInternalOptions)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar internalOptionCreatorMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();\nfunction registerInternalOptionCreator(mainType, creator) {\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(internalOptionCreatorMap.get(mainType) == null && creator);\n  internalOptionCreatorMap.set(mainType, creator);\n}\nfunction concatInternalOptions(ecModel, mainType, newCmptOptionList) {\n  var internalOptionCreator = internalOptionCreatorMap.get(mainType);\n  if (!internalOptionCreator) {\n    return newCmptOptionList;\n  }\n  var internalOptions = internalOptionCreator(ecModel);\n  if (!internalOptions) {\n    return newCmptOptionList;\n  }\n  if (false) { var i; }\n  return newCmptOptionList.concat(internalOptions);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ0Mi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvaW50ZXJuYWxDb21wb25lbnRDcmVhdG9yLmpzPzQ0NWMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBjcmVhdGVIYXNoTWFwLCBhc3NlcnQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgaXNDb21wb25lbnRJZEludGVybmFsIH0gZnJvbSAnLi4vdXRpbC9tb2RlbC5qcyc7XG52YXIgaW50ZXJuYWxPcHRpb25DcmVhdG9yTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVySW50ZXJuYWxPcHRpb25DcmVhdG9yKG1haW5UeXBlLCBjcmVhdG9yKSB7XG4gIGFzc2VydChpbnRlcm5hbE9wdGlvbkNyZWF0b3JNYXAuZ2V0KG1haW5UeXBlKSA9PSBudWxsICYmIGNyZWF0b3IpO1xuICBpbnRlcm5hbE9wdGlvbkNyZWF0b3JNYXAuc2V0KG1haW5UeXBlLCBjcmVhdG9yKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRJbnRlcm5hbE9wdGlvbnMoZWNNb2RlbCwgbWFpblR5cGUsIG5ld0NtcHRPcHRpb25MaXN0KSB7XG4gIHZhciBpbnRlcm5hbE9wdGlvbkNyZWF0b3IgPSBpbnRlcm5hbE9wdGlvbkNyZWF0b3JNYXAuZ2V0KG1haW5UeXBlKTtcbiAgaWYgKCFpbnRlcm5hbE9wdGlvbkNyZWF0b3IpIHtcbiAgICByZXR1cm4gbmV3Q21wdE9wdGlvbkxpc3Q7XG4gIH1cbiAgdmFyIGludGVybmFsT3B0aW9ucyA9IGludGVybmFsT3B0aW9uQ3JlYXRvcihlY01vZGVsKTtcbiAgaWYgKCFpbnRlcm5hbE9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3Q21wdE9wdGlvbkxpc3Q7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVybmFsT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgYXNzZXJ0KGlzQ29tcG9uZW50SWRJbnRlcm5hbChpbnRlcm5hbE9wdGlvbnNbaV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0NtcHRPcHRpb25MaXN0LmNvbmNhdChpbnRlcm5hbE9wdGlvbnMpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7442\n')},8317:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   J: () => (/* binding */ LineStyleMixin),\n/* harmony export */   m: () => (/* binding */ LINE_STYLE_KEY_MAP)\n/* harmony export */ });\n/* harmony import */ var _makeStyleMapper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32944);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar LINE_STYLE_KEY_MAP = [['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['lineDash', 'type'], ['lineDashOffset', 'dashOffset'], ['lineCap', 'cap'], ['lineJoin', 'join'], ['miterLimit']\n// Option decal is in `DecalObject` but style.decal is in `PatternObject`.\n// So do not transfer decal directly.\n];\nvar getLineStyle = (0,_makeStyleMapper_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A)(LINE_STYLE_KEY_MAP);\nvar LineStyleMixin = /** @class */function () {\n  function LineStyleMixin() {}\n  LineStyleMixin.prototype.getLineStyle = function (excludes) {\n    return getLineStyle(this, excludes);\n  };\n  return LineStyleMixin;\n}();\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMxNy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9saW5lU3R5bGUuanM/YTkyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBtYWtlU3R5bGVNYXBwZXIgZnJvbSAnLi9tYWtlU3R5bGVNYXBwZXIuanMnO1xuZXhwb3J0IHZhciBMSU5FX1NUWUxFX0tFWV9NQVAgPSBbWydsaW5lV2lkdGgnLCAnd2lkdGgnXSwgWydzdHJva2UnLCAnY29sb3InXSwgWydvcGFjaXR5J10sIFsnc2hhZG93Qmx1ciddLCBbJ3NoYWRvd09mZnNldFgnXSwgWydzaGFkb3dPZmZzZXRZJ10sIFsnc2hhZG93Q29sb3InXSwgWydsaW5lRGFzaCcsICd0eXBlJ10sIFsnbGluZURhc2hPZmZzZXQnLCAnZGFzaE9mZnNldCddLCBbJ2xpbmVDYXAnLCAnY2FwJ10sIFsnbGluZUpvaW4nLCAnam9pbiddLCBbJ21pdGVyTGltaXQnXVxuLy8gT3B0aW9uIGRlY2FsIGlzIGluIGBEZWNhbE9iamVjdGAgYnV0IHN0eWxlLmRlY2FsIGlzIGluIGBQYXR0ZXJuT2JqZWN0YC5cbi8vIFNvIGRvIG5vdCB0cmFuc2ZlciBkZWNhbCBkaXJlY3RseS5cbl07XG52YXIgZ2V0TGluZVN0eWxlID0gbWFrZVN0eWxlTWFwcGVyKExJTkVfU1RZTEVfS0VZX01BUCk7XG52YXIgTGluZVN0eWxlTWl4aW4gPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaW5lU3R5bGVNaXhpbigpIHt9XG4gIExpbmVTdHlsZU1peGluLnByb3RvdHlwZS5nZXRMaW5lU3R5bGUgPSBmdW5jdGlvbiAoZXhjbHVkZXMpIHtcbiAgICByZXR1cm4gZ2V0TGluZVN0eWxlKHRoaXMsIGV4Y2x1ZGVzKTtcbiAgfTtcbiAgcmV0dXJuIExpbmVTdHlsZU1peGluO1xufSgpO1xuO1xuZXhwb3J0IHsgTGluZVN0eWxlTWl4aW4gfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8317\n")},8348:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48170);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar QUERY_REG = /^(min|max)?(.+)$/;\n// Key: mainType\n// type FakeComponentsMap = HashMap<(MappingExistingItem & { subType: string })[]>;\n/**\r\n * TERM EXPLANATIONS:\r\n * See `ECOption` and `ECUnitOption` in `src/util/types.ts`.\r\n */\nvar OptionManager = /** @class */function () {\n  // timeline.notMerge is not supported in ec3. Firstly there is rearly\n  // case that notMerge is needed. Secondly supporting \'notMerge\' requires\n  // rawOption cloned and backuped when timeline changed, which does no\n  // good to performance. What\'s more, that both timeline and setOption\n  // method supply \'notMerge\' brings complex and some problems.\n  // Consider this case:\n  // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n  // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n  function OptionManager(api) {\n    this._timelineOptions = [];\n    this._mediaList = [];\n    /**\r\n     * -1, means default.\r\n     * empty means no media.\r\n     */\n    this._currentMediaIndices = [];\n    this._api = api;\n  }\n  OptionManager.prototype.setOption = function (rawOption, optionPreprocessorFuncs, opt) {\n    if (rawOption) {\n      // That set dat primitive is dangerous if user reuse the data when setOption again.\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)((0,_util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .normalizeToArray */ .qB)(rawOption.series), function (series) {\n        series && series.data && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isTypedArray)(series.data) && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.setAsPrimitive)(series.data);\n      });\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)((0,_util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .normalizeToArray */ .qB)(rawOption.dataset), function (dataset) {\n        dataset && dataset.source && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isTypedArray)(dataset.source) && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.setAsPrimitive)(dataset.source);\n      });\n    }\n    // Caution: some series modify option data, if do not clone,\n    // it should ensure that the repeat modify correctly\n    // (create a new object when modify itself).\n    rawOption = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.clone)(rawOption);\n    // FIXME\n    // If some property is set in timeline options or media option but\n    // not set in baseOption, a warning should be given.\n    var optionBackup = this._optionBackup;\n    var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs, !optionBackup);\n    this._newBaseOption = newParsedOption.baseOption;\n    // For setOption at second time (using merge mode);\n    if (optionBackup) {\n      // FIXME\n      // the restore merge solution is essentially incorrect.\n      // the mapping can not be 100% consistent with ecModel, which probably brings\n      // potential bug!\n      // The first merge is delayed, because in most cases, users do not call `setOption` twice.\n      // let fakeCmptsMap = this._fakeCmptsMap;\n      // if (!fakeCmptsMap) {\n      //     fakeCmptsMap = this._fakeCmptsMap = createHashMap();\n      //     mergeToBackupOption(fakeCmptsMap, null, optionBackup.baseOption, null);\n      // }\n      // mergeToBackupOption(\n      //     fakeCmptsMap, optionBackup.baseOption, newParsedOption.baseOption, opt\n      // );\n      // For simplicity, timeline options and media options do not support merge,\n      // that is, if you `setOption` twice and both has timeline options, the latter\n      // timeline options will not be merged to the former, but just substitute them.\n      if (newParsedOption.timelineOptions.length) {\n        optionBackup.timelineOptions = newParsedOption.timelineOptions;\n      }\n      if (newParsedOption.mediaList.length) {\n        optionBackup.mediaList = newParsedOption.mediaList;\n      }\n      if (newParsedOption.mediaDefault) {\n        optionBackup.mediaDefault = newParsedOption.mediaDefault;\n      }\n    } else {\n      this._optionBackup = newParsedOption;\n    }\n  };\n  OptionManager.prototype.mountOption = function (isRecreate) {\n    var optionBackup = this._optionBackup;\n    this._timelineOptions = optionBackup.timelineOptions;\n    this._mediaList = optionBackup.mediaList;\n    this._mediaDefault = optionBackup.mediaDefault;\n    this._currentMediaIndices = [];\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.clone)(isRecreate\n    // this._optionBackup.baseOption, which is created at the first `setOption`\n    // called, and is merged into every new option by inner method `mergeToBackupOption`\n    // each time `setOption` called, can be only used in `isRecreate`, because\n    // its reliability is under suspicion. In other cases option merge is\n    // performed by `model.mergeOption`.\n    ? optionBackup.baseOption : this._newBaseOption);\n  };\n  OptionManager.prototype.getTimelineOption = function (ecModel) {\n    var option;\n    var timelineOptions = this._timelineOptions;\n    if (timelineOptions.length) {\n      // getTimelineOption can only be called after ecModel inited,\n      // so we can get currentIndex from timelineModel.\n      var timelineModel = ecModel.getComponent(\'timeline\');\n      if (timelineModel) {\n        option = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.clone)(\n        // FIXME:TS as TimelineModel or quivlant interface\n        timelineOptions[timelineModel.getCurrentIndex()]);\n      }\n    }\n    return option;\n  };\n  OptionManager.prototype.getMediaOption = function (ecModel) {\n    var ecWidth = this._api.getWidth();\n    var ecHeight = this._api.getHeight();\n    var mediaList = this._mediaList;\n    var mediaDefault = this._mediaDefault;\n    var indices = [];\n    var result = [];\n    // No media defined.\n    if (!mediaList.length && !mediaDefault) {\n      return result;\n    }\n    // Multi media may be applied, the latter defined media has higher priority.\n    for (var i = 0, len = mediaList.length; i < len; i++) {\n      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n        indices.push(i);\n      }\n    }\n    // FIXME\n    // Whether mediaDefault should force users to provide? Otherwise\n    // the change by media query can not be recorvered.\n    if (!indices.length && mediaDefault) {\n      indices = [-1];\n    }\n    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n      result = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)(indices, function (index) {\n        return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.clone)(index === -1 ? mediaDefault.option : mediaList[index].option);\n      });\n    }\n    // Otherwise return nothing.\n    this._currentMediaIndices = indices;\n    return result;\n  };\n  return OptionManager;\n}();\n/**\r\n * [RAW_OPTION_PATTERNS]\r\n * (Note: "series: []" represents all other props in `ECUnitOption`)\r\n *\r\n * (1) No prop "baseOption" declared:\r\n * Root option is used as "baseOption" (except prop "options" and "media").\r\n * ```js\r\n * option = {\r\n *     series: [],\r\n *     timeline: {},\r\n *     options: [],\r\n * };\r\n * option = {\r\n *     series: [],\r\n *     media: {},\r\n * };\r\n * option = {\r\n *     series: [],\r\n *     timeline: {},\r\n *     options: [],\r\n *     media: {},\r\n * }\r\n * ```\r\n *\r\n * (2) Prop "baseOption" declared:\r\n * If "baseOption" declared, `ECUnitOption` props can only be declared\r\n * inside "baseOption" except prop "timeline" (compat ec2).\r\n * ```js\r\n * option = {\r\n *     baseOption: {\r\n *         timeline: {},\r\n *         series: [],\r\n *     },\r\n *     options: []\r\n * };\r\n * option = {\r\n *     baseOption: {\r\n *         series: [],\r\n *     },\r\n *     media: []\r\n * };\r\n * option = {\r\n *     baseOption: {\r\n *         timeline: {},\r\n *         series: [],\r\n *     },\r\n *     options: []\r\n *     media: []\r\n * };\r\n * option = {\r\n *     // ec3 compat ec2: allow (only) `timeline` declared\r\n *     // outside baseOption. Keep this setting for compat.\r\n *     timeline: {},\r\n *     baseOption: {\r\n *         series: [],\r\n *     },\r\n *     options: [],\r\n *     media: []\r\n * };\r\n * ```\r\n */\nfunction parseRawOption(\n// `rawOption` May be modified\nrawOption, optionPreprocessorFuncs, isNew) {\n  var mediaList = [];\n  var mediaDefault;\n  var baseOption;\n  var declaredBaseOption = rawOption.baseOption;\n  // Compatible with ec2, [RAW_OPTION_PATTERNS] above.\n  var timelineOnRoot = rawOption.timeline;\n  var timelineOptionsOnRoot = rawOption.options;\n  var mediaOnRoot = rawOption.media;\n  var hasMedia = !!rawOption.media;\n  var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);\n  if (declaredBaseOption) {\n    baseOption = declaredBaseOption;\n    // For merge option.\n    if (!baseOption.timeline) {\n      baseOption.timeline = timelineOnRoot;\n    }\n  }\n  // For convenience, enable to use the root option as the `baseOption`:\n  // `{ ...normalOptionProps, media: [{ ... }, { ... }] }`\n  else {\n    if (hasTimeline || hasMedia) {\n      rawOption.options = rawOption.media = null;\n    }\n    baseOption = rawOption;\n  }\n  if (hasMedia) {\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(mediaOnRoot)) {\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(mediaOnRoot, function (singleMedia) {\n        if (false) {}\n        if (singleMedia && singleMedia.option) {\n          if (singleMedia.query) {\n            mediaList.push(singleMedia);\n          } else if (!mediaDefault) {\n            // Use the first media default.\n            mediaDefault = singleMedia;\n          }\n        }\n      });\n    } else {\n      if (false) {}\n    }\n  }\n  doPreprocess(baseOption);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(timelineOptionsOnRoot, function (option) {\n    return doPreprocess(option);\n  });\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(mediaList, function (media) {\n    return doPreprocess(media.option);\n  });\n  function doPreprocess(option) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(optionPreprocessorFuncs, function (preProcess) {\n      preProcess(option, isNew);\n    });\n  }\n  return {\n    baseOption: baseOption,\n    timelineOptions: timelineOptionsOnRoot || [],\n    mediaDefault: mediaDefault,\n    mediaList: mediaList\n  };\n}\n/**\r\n * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\r\n * Support: width, height, aspectRatio\r\n * Can use max or min as prefix.\r\n */\nfunction applyMediaQuery(query, ecWidth, ecHeight) {\n  var realMap = {\n    width: ecWidth,\n    height: ecHeight,\n    aspectratio: ecWidth / ecHeight // lower case for convenience.\n  };\n  var applicable = true;\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(query, function (value, attr) {\n    var matched = attr.match(QUERY_REG);\n    if (!matched || !matched[1] || !matched[2]) {\n      return;\n    }\n    var operator = matched[1];\n    var realAttr = matched[2].toLowerCase();\n    if (!compare(realMap[realAttr], value, operator)) {\n      applicable = false;\n    }\n  });\n  return applicable;\n}\nfunction compare(real, expect, operator) {\n  if (operator === \'min\') {\n    return real >= expect;\n  } else if (operator === \'max\') {\n    return real <= expect;\n  } else {\n    // Equals\n    return real === expect;\n  }\n}\nfunction indicesEquals(indices1, indices2) {\n  // indices is always order by asc and has only finite number.\n  return indices1.join(\',\') === indices2.join(\',\');\n}\n/**\r\n * Consider case:\r\n * `chart.setOption(opt1);`\r\n * Then user do some interaction like dataZoom, dataView changing.\r\n * `chart.setOption(opt2);`\r\n * Then user press \'reset button\' in toolbox.\r\n *\r\n * After doing that all of the interaction effects should be reset, the\r\n * chart should be the same as the result of invoke\r\n * `chart.setOption(opt1); chart.setOption(opt2);`.\r\n *\r\n * Although it is not able ensure that\r\n * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\r\n * `chart.setOption(merge(opt1, opt2));` exactly,\r\n * this might be the only simple way to implement that feature.\r\n *\r\n * MEMO: We\'ve considered some other approaches:\r\n * 1. Each model handles its self restoration but not uniform treatment.\r\n *     (Too complex in logic and error-prone)\r\n * 2. Use a shadow ecModel. (Performance expensive)\r\n *\r\n * FIXME: A possible solution:\r\n * Add a extra level of model for each component model. The inheritance chain would be:\r\n * ecModel <- componentModel <- componentActionModel <- dataItemModel\r\n * And all of the actions can only modify the `componentActionModel` rather than\r\n * `componentModel`. `setOption` will only modify the `ecModel` and `componentModel`.\r\n * When "resotre" action triggered, model from `componentActionModel` will be discarded\r\n * instead of recreating the "ecModel" from the "_optionBackup".\r\n */\n// function mergeToBackupOption(\n//     fakeCmptsMap: FakeComponentsMap,\n//     // `tarOption` Can be null/undefined, means init\n//     tarOption: ECUnitOption,\n//     newOption: ECUnitOption,\n//     // Can be null/undefined\n//     opt: InnerSetOptionOpts\n// ): void {\n//     newOption = newOption || {} as ECUnitOption;\n//     const notInit = !!tarOption;\n//     each(newOption, function (newOptsInMainType, mainType) {\n//         if (newOptsInMainType == null) {\n//             return;\n//         }\n//         if (!ComponentModel.hasClass(mainType)) {\n//             if (tarOption) {\n//                 tarOption[mainType] = merge(tarOption[mainType], newOptsInMainType, true);\n//             }\n//         }\n//         else {\n//             const oldTarOptsInMainType = notInit ? normalizeToArray(tarOption[mainType]) : null;\n//             const oldFakeCmptsInMainType = fakeCmptsMap.get(mainType) || [];\n//             const resultTarOptsInMainType = notInit ? (tarOption[mainType] = [] as ComponentOption[]) : null;\n//             const resultFakeCmptsInMainType = fakeCmptsMap.set(mainType, []);\n//             const mappingResult = mappingToExists(\n//                 oldFakeCmptsInMainType,\n//                 normalizeToArray(newOptsInMainType),\n//                 (opt && opt.replaceMergeMainTypeMap.get(mainType)) ? \'replaceMerge\' : \'normalMerge\'\n//             );\n//             setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel as ComponentModelConstructor);\n//             each(mappingResult, function (resultItem, index) {\n//                 // The same logic as `Global.ts#_mergeOption`.\n//                 let fakeCmpt = resultItem.existing;\n//                 const newOption = resultItem.newOption;\n//                 const keyInfo = resultItem.keyInfo;\n//                 let fakeCmptOpt;\n//                 if (!newOption) {\n//                     fakeCmptOpt = oldTarOptsInMainType[index];\n//                 }\n//                 else {\n//                     if (fakeCmpt && fakeCmpt.subType === keyInfo.subType) {\n//                         fakeCmpt.name = keyInfo.name;\n//                         if (notInit) {\n//                             fakeCmptOpt = merge(oldTarOptsInMainType[index], newOption, true);\n//                         }\n//                     }\n//                     else {\n//                         fakeCmpt = extend({}, keyInfo);\n//                         if (notInit) {\n//                             fakeCmptOpt = clone(newOption);\n//                         }\n//                     }\n//                 }\n//                 if (fakeCmpt) {\n//                     notInit && resultTarOptsInMainType.push(fakeCmptOpt);\n//                     resultFakeCmptsInMainType.push(fakeCmpt);\n//                 }\n//                 else {\n//                     notInit && resultTarOptsInMainType.push(void 0);\n//                     resultFakeCmptsInMainType.push(void 0);\n//                 }\n//             });\n//         }\n//     });\n// }\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OptionManager);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODM0OC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL09wdGlvbk1hbmFnZXIuanM/NjRhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IG5vcm1hbGl6ZVRvQXJyYXlcbi8vICwgTWFwcGluZ0V4aXN0aW5nSXRlbSwgc2V0Q29tcG9uZW50VHlwZVRvS2V5SW5mbywgbWFwcGluZ1RvRXhpc3RzXG59IGZyb20gJy4uL3V0aWwvbW9kZWwuanMnO1xuaW1wb3J0IHsgZWFjaCwgY2xvbmUsIG1hcCwgaXNUeXBlZEFycmF5LCBzZXRBc1ByaW1pdGl2ZSwgaXNBcnJheSwgaXNPYmplY3Rcbi8vICwgSGFzaE1hcCAsIGNyZWF0ZUhhc2hNYXAsIGV4dGVuZCwgbWVyZ2UsXG59IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBlcnJvciB9IGZyb20gJy4uL3V0aWwvbG9nLmpzJztcbnZhciBRVUVSWV9SRUcgPSAvXihtaW58bWF4KT8oLispJC87XG4vLyBLZXk6IG1haW5UeXBlXG4vLyB0eXBlIEZha2VDb21wb25lbnRzTWFwID0gSGFzaE1hcDwoTWFwcGluZ0V4aXN0aW5nSXRlbSAmIHsgc3ViVHlwZTogc3RyaW5nIH0pW10+O1xuLyoqXHJcbiAqIFRFUk0gRVhQTEFOQVRJT05TOlxyXG4gKiBTZWUgYEVDT3B0aW9uYCBhbmQgYEVDVW5pdE9wdGlvbmAgaW4gYHNyYy91dGlsL3R5cGVzLnRzYC5cclxuICovXG52YXIgT3B0aW9uTWFuYWdlciA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIC8vIHRpbWVsaW5lLm5vdE1lcmdlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZWMzLiBGaXJzdGx5IHRoZXJlIGlzIHJlYXJseVxuICAvLyBjYXNlIHRoYXQgbm90TWVyZ2UgaXMgbmVlZGVkLiBTZWNvbmRseSBzdXBwb3J0aW5nICdub3RNZXJnZScgcmVxdWlyZXNcbiAgLy8gcmF3T3B0aW9uIGNsb25lZCBhbmQgYmFja3VwZWQgd2hlbiB0aW1lbGluZSBjaGFuZ2VkLCB3aGljaCBkb2VzIG5vXG4gIC8vIGdvb2QgdG8gcGVyZm9ybWFuY2UuIFdoYXQncyBtb3JlLCB0aGF0IGJvdGggdGltZWxpbmUgYW5kIHNldE9wdGlvblxuICAvLyBtZXRob2Qgc3VwcGx5ICdub3RNZXJnZScgYnJpbmdzIGNvbXBsZXggYW5kIHNvbWUgcHJvYmxlbXMuXG4gIC8vIENvbnNpZGVyIHRoaXMgY2FzZTpcbiAgLy8gKHN0ZXAxKSBjaGFydC5zZXRPcHRpb24oe3RpbWVsaW5lOiB7bm90TWVyZ2U6IGZhbHNlfSwgLi4ufSwgZmFsc2UpO1xuICAvLyAoc3RlcDIpIGNoYXJ0LnNldE9wdGlvbih7dGltZWxpbmU6IHtub3RNZXJnZTogdHJ1ZX0sIC4uLn0sIGZhbHNlKTtcbiAgZnVuY3Rpb24gT3B0aW9uTWFuYWdlcihhcGkpIHtcbiAgICB0aGlzLl90aW1lbGluZU9wdGlvbnMgPSBbXTtcbiAgICB0aGlzLl9tZWRpYUxpc3QgPSBbXTtcbiAgICAvKipcclxuICAgICAqIC0xLCBtZWFucyBkZWZhdWx0LlxyXG4gICAgICogZW1wdHkgbWVhbnMgbm8gbWVkaWEuXHJcbiAgICAgKi9cbiAgICB0aGlzLl9jdXJyZW50TWVkaWFJbmRpY2VzID0gW107XG4gICAgdGhpcy5fYXBpID0gYXBpO1xuICB9XG4gIE9wdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChyYXdPcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLCBvcHQpIHtcbiAgICBpZiAocmF3T3B0aW9uKSB7XG4gICAgICAvLyBUaGF0IHNldCBkYXQgcHJpbWl0aXZlIGlzIGRhbmdlcm91cyBpZiB1c2VyIHJldXNlIHRoZSBkYXRhIHdoZW4gc2V0T3B0aW9uIGFnYWluLlxuICAgICAgZWFjaChub3JtYWxpemVUb0FycmF5KHJhd09wdGlvbi5zZXJpZXMpLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgIHNlcmllcyAmJiBzZXJpZXMuZGF0YSAmJiBpc1R5cGVkQXJyYXkoc2VyaWVzLmRhdGEpICYmIHNldEFzUHJpbWl0aXZlKHNlcmllcy5kYXRhKTtcbiAgICAgIH0pO1xuICAgICAgZWFjaChub3JtYWxpemVUb0FycmF5KHJhd09wdGlvbi5kYXRhc2V0KSwgZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgICAgICAgZGF0YXNldCAmJiBkYXRhc2V0LnNvdXJjZSAmJiBpc1R5cGVkQXJyYXkoZGF0YXNldC5zb3VyY2UpICYmIHNldEFzUHJpbWl0aXZlKGRhdGFzZXQuc291cmNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDYXV0aW9uOiBzb21lIHNlcmllcyBtb2RpZnkgb3B0aW9uIGRhdGEsIGlmIGRvIG5vdCBjbG9uZSxcbiAgICAvLyBpdCBzaG91bGQgZW5zdXJlIHRoYXQgdGhlIHJlcGVhdCBtb2RpZnkgY29ycmVjdGx5XG4gICAgLy8gKGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2hlbiBtb2RpZnkgaXRzZWxmKS5cbiAgICByYXdPcHRpb24gPSBjbG9uZShyYXdPcHRpb24pO1xuICAgIC8vIEZJWE1FXG4gICAgLy8gSWYgc29tZSBwcm9wZXJ0eSBpcyBzZXQgaW4gdGltZWxpbmUgb3B0aW9ucyBvciBtZWRpYSBvcHRpb24gYnV0XG4gICAgLy8gbm90IHNldCBpbiBiYXNlT3B0aW9uLCBhIHdhcm5pbmcgc2hvdWxkIGJlIGdpdmVuLlxuICAgIHZhciBvcHRpb25CYWNrdXAgPSB0aGlzLl9vcHRpb25CYWNrdXA7XG4gICAgdmFyIG5ld1BhcnNlZE9wdGlvbiA9IHBhcnNlUmF3T3B0aW9uKHJhd09wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MsICFvcHRpb25CYWNrdXApO1xuICAgIHRoaXMuX25ld0Jhc2VPcHRpb24gPSBuZXdQYXJzZWRPcHRpb24uYmFzZU9wdGlvbjtcbiAgICAvLyBGb3Igc2V0T3B0aW9uIGF0IHNlY29uZCB0aW1lICh1c2luZyBtZXJnZSBtb2RlKTtcbiAgICBpZiAob3B0aW9uQmFja3VwKSB7XG4gICAgICAvLyBGSVhNRVxuICAgICAgLy8gdGhlIHJlc3RvcmUgbWVyZ2Ugc29sdXRpb24gaXMgZXNzZW50aWFsbHkgaW5jb3JyZWN0LlxuICAgICAgLy8gdGhlIG1hcHBpbmcgY2FuIG5vdCBiZSAxMDAlIGNvbnNpc3RlbnQgd2l0aCBlY01vZGVsLCB3aGljaCBwcm9iYWJseSBicmluZ3NcbiAgICAgIC8vIHBvdGVudGlhbCBidWchXG4gICAgICAvLyBUaGUgZmlyc3QgbWVyZ2UgaXMgZGVsYXllZCwgYmVjYXVzZSBpbiBtb3N0IGNhc2VzLCB1c2VycyBkbyBub3QgY2FsbCBgc2V0T3B0aW9uYCB0d2ljZS5cbiAgICAgIC8vIGxldCBmYWtlQ21wdHNNYXAgPSB0aGlzLl9mYWtlQ21wdHNNYXA7XG4gICAgICAvLyBpZiAoIWZha2VDbXB0c01hcCkge1xuICAgICAgLy8gICAgIGZha2VDbXB0c01hcCA9IHRoaXMuX2Zha2VDbXB0c01hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgICAgIC8vICAgICBtZXJnZVRvQmFja3VwT3B0aW9uKGZha2VDbXB0c01hcCwgbnVsbCwgb3B0aW9uQmFja3VwLmJhc2VPcHRpb24sIG51bGwpO1xuICAgICAgLy8gfVxuICAgICAgLy8gbWVyZ2VUb0JhY2t1cE9wdGlvbihcbiAgICAgIC8vICAgICBmYWtlQ21wdHNNYXAsIG9wdGlvbkJhY2t1cC5iYXNlT3B0aW9uLCBuZXdQYXJzZWRPcHRpb24uYmFzZU9wdGlvbiwgb3B0XG4gICAgICAvLyApO1xuICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHRpbWVsaW5lIG9wdGlvbnMgYW5kIG1lZGlhIG9wdGlvbnMgZG8gbm90IHN1cHBvcnQgbWVyZ2UsXG4gICAgICAvLyB0aGF0IGlzLCBpZiB5b3UgYHNldE9wdGlvbmAgdHdpY2UgYW5kIGJvdGggaGFzIHRpbWVsaW5lIG9wdGlvbnMsIHRoZSBsYXR0ZXJcbiAgICAgIC8vIHRpbWVsaW5lIG9wdGlvbnMgd2lsbCBub3QgYmUgbWVyZ2VkIHRvIHRoZSBmb3JtZXIsIGJ1dCBqdXN0IHN1YnN0aXR1dGUgdGhlbS5cbiAgICAgIGlmIChuZXdQYXJzZWRPcHRpb24udGltZWxpbmVPcHRpb25zLmxlbmd0aCkge1xuICAgICAgICBvcHRpb25CYWNrdXAudGltZWxpbmVPcHRpb25zID0gbmV3UGFyc2VkT3B0aW9uLnRpbWVsaW5lT3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGlmIChuZXdQYXJzZWRPcHRpb24ubWVkaWFMaXN0Lmxlbmd0aCkge1xuICAgICAgICBvcHRpb25CYWNrdXAubWVkaWFMaXN0ID0gbmV3UGFyc2VkT3B0aW9uLm1lZGlhTGlzdDtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdQYXJzZWRPcHRpb24ubWVkaWFEZWZhdWx0KSB7XG4gICAgICAgIG9wdGlvbkJhY2t1cC5tZWRpYURlZmF1bHQgPSBuZXdQYXJzZWRPcHRpb24ubWVkaWFEZWZhdWx0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vcHRpb25CYWNrdXAgPSBuZXdQYXJzZWRPcHRpb247XG4gICAgfVxuICB9O1xuICBPcHRpb25NYW5hZ2VyLnByb3RvdHlwZS5tb3VudE9wdGlvbiA9IGZ1bmN0aW9uIChpc1JlY3JlYXRlKSB7XG4gICAgdmFyIG9wdGlvbkJhY2t1cCA9IHRoaXMuX29wdGlvbkJhY2t1cDtcbiAgICB0aGlzLl90aW1lbGluZU9wdGlvbnMgPSBvcHRpb25CYWNrdXAudGltZWxpbmVPcHRpb25zO1xuICAgIHRoaXMuX21lZGlhTGlzdCA9IG9wdGlvbkJhY2t1cC5tZWRpYUxpc3Q7XG4gICAgdGhpcy5fbWVkaWFEZWZhdWx0ID0gb3B0aW9uQmFja3VwLm1lZGlhRGVmYXVsdDtcbiAgICB0aGlzLl9jdXJyZW50TWVkaWFJbmRpY2VzID0gW107XG4gICAgcmV0dXJuIGNsb25lKGlzUmVjcmVhdGVcbiAgICAvLyB0aGlzLl9vcHRpb25CYWNrdXAuYmFzZU9wdGlvbiwgd2hpY2ggaXMgY3JlYXRlZCBhdCB0aGUgZmlyc3QgYHNldE9wdGlvbmBcbiAgICAvLyBjYWxsZWQsIGFuZCBpcyBtZXJnZWQgaW50byBldmVyeSBuZXcgb3B0aW9uIGJ5IGlubmVyIG1ldGhvZCBgbWVyZ2VUb0JhY2t1cE9wdGlvbmBcbiAgICAvLyBlYWNoIHRpbWUgYHNldE9wdGlvbmAgY2FsbGVkLCBjYW4gYmUgb25seSB1c2VkIGluIGBpc1JlY3JlYXRlYCwgYmVjYXVzZVxuICAgIC8vIGl0cyByZWxpYWJpbGl0eSBpcyB1bmRlciBzdXNwaWNpb24uIEluIG90aGVyIGNhc2VzIG9wdGlvbiBtZXJnZSBpc1xuICAgIC8vIHBlcmZvcm1lZCBieSBgbW9kZWwubWVyZ2VPcHRpb25gLlxuICAgID8gb3B0aW9uQmFja3VwLmJhc2VPcHRpb24gOiB0aGlzLl9uZXdCYXNlT3B0aW9uKTtcbiAgfTtcbiAgT3B0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VGltZWxpbmVPcHRpb24gPSBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHZhciBvcHRpb247XG4gICAgdmFyIHRpbWVsaW5lT3B0aW9ucyA9IHRoaXMuX3RpbWVsaW5lT3B0aW9ucztcbiAgICBpZiAodGltZWxpbmVPcHRpb25zLmxlbmd0aCkge1xuICAgICAgLy8gZ2V0VGltZWxpbmVPcHRpb24gY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGVjTW9kZWwgaW5pdGVkLFxuICAgICAgLy8gc28gd2UgY2FuIGdldCBjdXJyZW50SW5kZXggZnJvbSB0aW1lbGluZU1vZGVsLlxuICAgICAgdmFyIHRpbWVsaW5lTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgndGltZWxpbmUnKTtcbiAgICAgIGlmICh0aW1lbGluZU1vZGVsKSB7XG4gICAgICAgIG9wdGlvbiA9IGNsb25lKFxuICAgICAgICAvLyBGSVhNRTpUUyBhcyBUaW1lbGluZU1vZGVsIG9yIHF1aXZsYW50IGludGVyZmFjZVxuICAgICAgICB0aW1lbGluZU9wdGlvbnNbdGltZWxpbmVNb2RlbC5nZXRDdXJyZW50SW5kZXgoKV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uO1xuICB9O1xuICBPcHRpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRNZWRpYU9wdGlvbiA9IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIGVjV2lkdGggPSB0aGlzLl9hcGkuZ2V0V2lkdGgoKTtcbiAgICB2YXIgZWNIZWlnaHQgPSB0aGlzLl9hcGkuZ2V0SGVpZ2h0KCk7XG4gICAgdmFyIG1lZGlhTGlzdCA9IHRoaXMuX21lZGlhTGlzdDtcbiAgICB2YXIgbWVkaWFEZWZhdWx0ID0gdGhpcy5fbWVkaWFEZWZhdWx0O1xuICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIC8vIE5vIG1lZGlhIGRlZmluZWQuXG4gICAgaWYgKCFtZWRpYUxpc3QubGVuZ3RoICYmICFtZWRpYURlZmF1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIE11bHRpIG1lZGlhIG1heSBiZSBhcHBsaWVkLCB0aGUgbGF0dGVyIGRlZmluZWQgbWVkaWEgaGFzIGhpZ2hlciBwcmlvcml0eS5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWVkaWFMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXBwbHlNZWRpYVF1ZXJ5KG1lZGlhTGlzdFtpXS5xdWVyeSwgZWNXaWR0aCwgZWNIZWlnaHQpKSB7XG4gICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRklYTUVcbiAgICAvLyBXaGV0aGVyIG1lZGlhRGVmYXVsdCBzaG91bGQgZm9yY2UgdXNlcnMgdG8gcHJvdmlkZT8gT3RoZXJ3aXNlXG4gICAgLy8gdGhlIGNoYW5nZSBieSBtZWRpYSBxdWVyeSBjYW4gbm90IGJlIHJlY29ydmVyZWQuXG4gICAgaWYgKCFpbmRpY2VzLmxlbmd0aCAmJiBtZWRpYURlZmF1bHQpIHtcbiAgICAgIGluZGljZXMgPSBbLTFdO1xuICAgIH1cbiAgICBpZiAoaW5kaWNlcy5sZW5ndGggJiYgIWluZGljZXNFcXVhbHMoaW5kaWNlcywgdGhpcy5fY3VycmVudE1lZGlhSW5kaWNlcykpIHtcbiAgICAgIHJlc3VsdCA9IG1hcChpbmRpY2VzLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lKGluZGV4ID09PSAtMSA/IG1lZGlhRGVmYXVsdC5vcHRpb24gOiBtZWRpYUxpc3RbaW5kZXhdLm9wdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlIHJldHVybiBub3RoaW5nLlxuICAgIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMgPSBpbmRpY2VzO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiBPcHRpb25NYW5hZ2VyO1xufSgpO1xuLyoqXHJcbiAqIFtSQVdfT1BUSU9OX1BBVFRFUk5TXVxyXG4gKiAoTm90ZTogXCJzZXJpZXM6IFtdXCIgcmVwcmVzZW50cyBhbGwgb3RoZXIgcHJvcHMgaW4gYEVDVW5pdE9wdGlvbmApXHJcbiAqXHJcbiAqICgxKSBObyBwcm9wIFwiYmFzZU9wdGlvblwiIGRlY2xhcmVkOlxyXG4gKiBSb290IG9wdGlvbiBpcyB1c2VkIGFzIFwiYmFzZU9wdGlvblwiIChleGNlcHQgcHJvcCBcIm9wdGlvbnNcIiBhbmQgXCJtZWRpYVwiKS5cclxuICogYGBganNcclxuICogb3B0aW9uID0ge1xyXG4gKiAgICAgc2VyaWVzOiBbXSxcclxuICogICAgIHRpbWVsaW5lOiB7fSxcclxuICogICAgIG9wdGlvbnM6IFtdLFxyXG4gKiB9O1xyXG4gKiBvcHRpb24gPSB7XHJcbiAqICAgICBzZXJpZXM6IFtdLFxyXG4gKiAgICAgbWVkaWE6IHt9LFxyXG4gKiB9O1xyXG4gKiBvcHRpb24gPSB7XHJcbiAqICAgICBzZXJpZXM6IFtdLFxyXG4gKiAgICAgdGltZWxpbmU6IHt9LFxyXG4gKiAgICAgb3B0aW9uczogW10sXHJcbiAqICAgICBtZWRpYToge30sXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqICgyKSBQcm9wIFwiYmFzZU9wdGlvblwiIGRlY2xhcmVkOlxyXG4gKiBJZiBcImJhc2VPcHRpb25cIiBkZWNsYXJlZCwgYEVDVW5pdE9wdGlvbmAgcHJvcHMgY2FuIG9ubHkgYmUgZGVjbGFyZWRcclxuICogaW5zaWRlIFwiYmFzZU9wdGlvblwiIGV4Y2VwdCBwcm9wIFwidGltZWxpbmVcIiAoY29tcGF0IGVjMikuXHJcbiAqIGBgYGpzXHJcbiAqIG9wdGlvbiA9IHtcclxuICogICAgIGJhc2VPcHRpb246IHtcclxuICogICAgICAgICB0aW1lbGluZToge30sXHJcbiAqICAgICAgICAgc2VyaWVzOiBbXSxcclxuICogICAgIH0sXHJcbiAqICAgICBvcHRpb25zOiBbXVxyXG4gKiB9O1xyXG4gKiBvcHRpb24gPSB7XHJcbiAqICAgICBiYXNlT3B0aW9uOiB7XHJcbiAqICAgICAgICAgc2VyaWVzOiBbXSxcclxuICogICAgIH0sXHJcbiAqICAgICBtZWRpYTogW11cclxuICogfTtcclxuICogb3B0aW9uID0ge1xyXG4gKiAgICAgYmFzZU9wdGlvbjoge1xyXG4gKiAgICAgICAgIHRpbWVsaW5lOiB7fSxcclxuICogICAgICAgICBzZXJpZXM6IFtdLFxyXG4gKiAgICAgfSxcclxuICogICAgIG9wdGlvbnM6IFtdXHJcbiAqICAgICBtZWRpYTogW11cclxuICogfTtcclxuICogb3B0aW9uID0ge1xyXG4gKiAgICAgLy8gZWMzIGNvbXBhdCBlYzI6IGFsbG93IChvbmx5KSBgdGltZWxpbmVgIGRlY2xhcmVkXHJcbiAqICAgICAvLyBvdXRzaWRlIGJhc2VPcHRpb24uIEtlZXAgdGhpcyBzZXR0aW5nIGZvciBjb21wYXQuXHJcbiAqICAgICB0aW1lbGluZToge30sXHJcbiAqICAgICBiYXNlT3B0aW9uOiB7XHJcbiAqICAgICAgICAgc2VyaWVzOiBbXSxcclxuICogICAgIH0sXHJcbiAqICAgICBvcHRpb25zOiBbXSxcclxuICogICAgIG1lZGlhOiBbXVxyXG4gKiB9O1xyXG4gKiBgYGBcclxuICovXG5mdW5jdGlvbiBwYXJzZVJhd09wdGlvbihcbi8vIGByYXdPcHRpb25gIE1heSBiZSBtb2RpZmllZFxucmF3T3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcywgaXNOZXcpIHtcbiAgdmFyIG1lZGlhTGlzdCA9IFtdO1xuICB2YXIgbWVkaWFEZWZhdWx0O1xuICB2YXIgYmFzZU9wdGlvbjtcbiAgdmFyIGRlY2xhcmVkQmFzZU9wdGlvbiA9IHJhd09wdGlvbi5iYXNlT3B0aW9uO1xuICAvLyBDb21wYXRpYmxlIHdpdGggZWMyLCBbUkFXX09QVElPTl9QQVRURVJOU10gYWJvdmUuXG4gIHZhciB0aW1lbGluZU9uUm9vdCA9IHJhd09wdGlvbi50aW1lbGluZTtcbiAgdmFyIHRpbWVsaW5lT3B0aW9uc09uUm9vdCA9IHJhd09wdGlvbi5vcHRpb25zO1xuICB2YXIgbWVkaWFPblJvb3QgPSByYXdPcHRpb24ubWVkaWE7XG4gIHZhciBoYXNNZWRpYSA9ICEhcmF3T3B0aW9uLm1lZGlhO1xuICB2YXIgaGFzVGltZWxpbmUgPSAhISh0aW1lbGluZU9wdGlvbnNPblJvb3QgfHwgdGltZWxpbmVPblJvb3QgfHwgZGVjbGFyZWRCYXNlT3B0aW9uICYmIGRlY2xhcmVkQmFzZU9wdGlvbi50aW1lbGluZSk7XG4gIGlmIChkZWNsYXJlZEJhc2VPcHRpb24pIHtcbiAgICBiYXNlT3B0aW9uID0gZGVjbGFyZWRCYXNlT3B0aW9uO1xuICAgIC8vIEZvciBtZXJnZSBvcHRpb24uXG4gICAgaWYgKCFiYXNlT3B0aW9uLnRpbWVsaW5lKSB7XG4gICAgICBiYXNlT3B0aW9uLnRpbWVsaW5lID0gdGltZWxpbmVPblJvb3Q7XG4gICAgfVxuICB9XG4gIC8vIEZvciBjb252ZW5pZW5jZSwgZW5hYmxlIHRvIHVzZSB0aGUgcm9vdCBvcHRpb24gYXMgdGhlIGBiYXNlT3B0aW9uYDpcbiAgLy8gYHsgLi4ubm9ybWFsT3B0aW9uUHJvcHMsIG1lZGlhOiBbeyAuLi4gfSwgeyAuLi4gfV0gfWBcbiAgZWxzZSB7XG4gICAgaWYgKGhhc1RpbWVsaW5lIHx8IGhhc01lZGlhKSB7XG4gICAgICByYXdPcHRpb24ub3B0aW9ucyA9IHJhd09wdGlvbi5tZWRpYSA9IG51bGw7XG4gICAgfVxuICAgIGJhc2VPcHRpb24gPSByYXdPcHRpb247XG4gIH1cbiAgaWYgKGhhc01lZGlhKSB7XG4gICAgaWYgKGlzQXJyYXkobWVkaWFPblJvb3QpKSB7XG4gICAgICBlYWNoKG1lZGlhT25Sb290LCBmdW5jdGlvbiAoc2luZ2xlTWVkaWEpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAvLyBSZWFsIGNhc2Ugb2Ygd3JvbmcgY29uZmlnLlxuICAgICAgICAgIGlmIChzaW5nbGVNZWRpYSAmJiAhc2luZ2xlTWVkaWEub3B0aW9uICYmIGlzT2JqZWN0KHNpbmdsZU1lZGlhLnF1ZXJ5KSAmJiBpc09iamVjdChzaW5nbGVNZWRpYS5xdWVyeS5vcHRpb24pKSB7XG4gICAgICAgICAgICBlcnJvcignSWxsZWdhbCBtZWRpYSBvcHRpb24uIE11c3QgYmUgbGlrZSB7IG1lZGlhOiBbIHsgcXVlcnk6IHt9LCBvcHRpb246IHt9IH0gXSB9Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaW5nbGVNZWRpYSAmJiBzaW5nbGVNZWRpYS5vcHRpb24pIHtcbiAgICAgICAgICBpZiAoc2luZ2xlTWVkaWEucXVlcnkpIHtcbiAgICAgICAgICAgIG1lZGlhTGlzdC5wdXNoKHNpbmdsZU1lZGlhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFtZWRpYURlZmF1bHQpIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgZmlyc3QgbWVkaWEgZGVmYXVsdC5cbiAgICAgICAgICAgIG1lZGlhRGVmYXVsdCA9IHNpbmdsZU1lZGlhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIFJlYWwgY2FzZSBvZiB3cm9uZyBjb25maWcuXG4gICAgICAgIGVycm9yKCdJbGxlZ2FsIG1lZGlhIG9wdGlvbi4gTXVzdCBiZSBhbiBhcnJheS4gTGlrZSB7IG1lZGlhOiBbIHsuLi59LCB7Li4ufSBdIH0nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZG9QcmVwcm9jZXNzKGJhc2VPcHRpb24pO1xuICBlYWNoKHRpbWVsaW5lT3B0aW9uc09uUm9vdCwgZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIHJldHVybiBkb1ByZXByb2Nlc3Mob3B0aW9uKTtcbiAgfSk7XG4gIGVhY2gobWVkaWFMaXN0LCBmdW5jdGlvbiAobWVkaWEpIHtcbiAgICByZXR1cm4gZG9QcmVwcm9jZXNzKG1lZGlhLm9wdGlvbik7XG4gIH0pO1xuICBmdW5jdGlvbiBkb1ByZXByb2Nlc3Mob3B0aW9uKSB7XG4gICAgZWFjaChvcHRpb25QcmVwcm9jZXNzb3JGdW5jcywgZnVuY3Rpb24gKHByZVByb2Nlc3MpIHtcbiAgICAgIHByZVByb2Nlc3Mob3B0aW9uLCBpc05ldyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiYXNlT3B0aW9uOiBiYXNlT3B0aW9uLFxuICAgIHRpbWVsaW5lT3B0aW9uczogdGltZWxpbmVPcHRpb25zT25Sb290IHx8IFtdLFxuICAgIG1lZGlhRGVmYXVsdDogbWVkaWFEZWZhdWx0LFxuICAgIG1lZGlhTGlzdDogbWVkaWFMaXN0XG4gIH07XG59XG4vKipcclxuICogQHNlZSA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1tZWRpYXF1ZXJpZXMvI21lZGlhMT5cclxuICogU3VwcG9ydDogd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW9cclxuICogQ2FuIHVzZSBtYXggb3IgbWluIGFzIHByZWZpeC5cclxuICovXG5mdW5jdGlvbiBhcHBseU1lZGlhUXVlcnkocXVlcnksIGVjV2lkdGgsIGVjSGVpZ2h0KSB7XG4gIHZhciByZWFsTWFwID0ge1xuICAgIHdpZHRoOiBlY1dpZHRoLFxuICAgIGhlaWdodDogZWNIZWlnaHQsXG4gICAgYXNwZWN0cmF0aW86IGVjV2lkdGggLyBlY0hlaWdodCAvLyBsb3dlciBjYXNlIGZvciBjb252ZW5pZW5jZS5cbiAgfTtcbiAgdmFyIGFwcGxpY2FibGUgPSB0cnVlO1xuICBlYWNoKHF1ZXJ5LCBmdW5jdGlvbiAodmFsdWUsIGF0dHIpIHtcbiAgICB2YXIgbWF0Y2hlZCA9IGF0dHIubWF0Y2goUVVFUllfUkVHKTtcbiAgICBpZiAoIW1hdGNoZWQgfHwgIW1hdGNoZWRbMV0gfHwgIW1hdGNoZWRbMl0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9wZXJhdG9yID0gbWF0Y2hlZFsxXTtcbiAgICB2YXIgcmVhbEF0dHIgPSBtYXRjaGVkWzJdLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFjb21wYXJlKHJlYWxNYXBbcmVhbEF0dHJdLCB2YWx1ZSwgb3BlcmF0b3IpKSB7XG4gICAgICBhcHBsaWNhYmxlID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFwcGxpY2FibGU7XG59XG5mdW5jdGlvbiBjb21wYXJlKHJlYWwsIGV4cGVjdCwgb3BlcmF0b3IpIHtcbiAgaWYgKG9wZXJhdG9yID09PSAnbWluJykge1xuICAgIHJldHVybiByZWFsID49IGV4cGVjdDtcbiAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ21heCcpIHtcbiAgICByZXR1cm4gcmVhbCA8PSBleHBlY3Q7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXF1YWxzXG4gICAgcmV0dXJuIHJlYWwgPT09IGV4cGVjdDtcbiAgfVxufVxuZnVuY3Rpb24gaW5kaWNlc0VxdWFscyhpbmRpY2VzMSwgaW5kaWNlczIpIHtcbiAgLy8gaW5kaWNlcyBpcyBhbHdheXMgb3JkZXIgYnkgYXNjIGFuZCBoYXMgb25seSBmaW5pdGUgbnVtYmVyLlxuICByZXR1cm4gaW5kaWNlczEuam9pbignLCcpID09PSBpbmRpY2VzMi5qb2luKCcsJyk7XG59XG4vKipcclxuICogQ29uc2lkZXIgY2FzZTpcclxuICogYGNoYXJ0LnNldE9wdGlvbihvcHQxKTtgXHJcbiAqIFRoZW4gdXNlciBkbyBzb21lIGludGVyYWN0aW9uIGxpa2UgZGF0YVpvb20sIGRhdGFWaWV3IGNoYW5naW5nLlxyXG4gKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDIpO2BcclxuICogVGhlbiB1c2VyIHByZXNzICdyZXNldCBidXR0b24nIGluIHRvb2xib3guXHJcbiAqXHJcbiAqIEFmdGVyIGRvaW5nIHRoYXQgYWxsIG9mIHRoZSBpbnRlcmFjdGlvbiBlZmZlY3RzIHNob3VsZCBiZSByZXNldCwgdGhlXHJcbiAqIGNoYXJ0IHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGUgcmVzdWx0IG9mIGludm9rZVxyXG4gKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDEpOyBjaGFydC5zZXRPcHRpb24ob3B0Mik7YC5cclxuICpcclxuICogQWx0aG91Z2ggaXQgaXMgbm90IGFibGUgZW5zdXJlIHRoYXRcclxuICogYGNoYXJ0LnNldE9wdGlvbihvcHQxKTsgY2hhcnQuc2V0T3B0aW9uKG9wdDIpO2AgaXMgZXF1aXZhbGVudHMgdG9cclxuICogYGNoYXJ0LnNldE9wdGlvbihtZXJnZShvcHQxLCBvcHQyKSk7YCBleGFjdGx5LFxyXG4gKiB0aGlzIG1pZ2h0IGJlIHRoZSBvbmx5IHNpbXBsZSB3YXkgdG8gaW1wbGVtZW50IHRoYXQgZmVhdHVyZS5cclxuICpcclxuICogTUVNTzogV2UndmUgY29uc2lkZXJlZCBzb21lIG90aGVyIGFwcHJvYWNoZXM6XHJcbiAqIDEuIEVhY2ggbW9kZWwgaGFuZGxlcyBpdHMgc2VsZiByZXN0b3JhdGlvbiBidXQgbm90IHVuaWZvcm0gdHJlYXRtZW50LlxyXG4gKiAgICAgKFRvbyBjb21wbGV4IGluIGxvZ2ljIGFuZCBlcnJvci1wcm9uZSlcclxuICogMi4gVXNlIGEgc2hhZG93IGVjTW9kZWwuIChQZXJmb3JtYW5jZSBleHBlbnNpdmUpXHJcbiAqXHJcbiAqIEZJWE1FOiBBIHBvc3NpYmxlIHNvbHV0aW9uOlxyXG4gKiBBZGQgYSBleHRyYSBsZXZlbCBvZiBtb2RlbCBmb3IgZWFjaCBjb21wb25lbnQgbW9kZWwuIFRoZSBpbmhlcml0YW5jZSBjaGFpbiB3b3VsZCBiZTpcclxuICogZWNNb2RlbCA8LSBjb21wb25lbnRNb2RlbCA8LSBjb21wb25lbnRBY3Rpb25Nb2RlbCA8LSBkYXRhSXRlbU1vZGVsXHJcbiAqIEFuZCBhbGwgb2YgdGhlIGFjdGlvbnMgY2FuIG9ubHkgbW9kaWZ5IHRoZSBgY29tcG9uZW50QWN0aW9uTW9kZWxgIHJhdGhlciB0aGFuXHJcbiAqIGBjb21wb25lbnRNb2RlbGAuIGBzZXRPcHRpb25gIHdpbGwgb25seSBtb2RpZnkgdGhlIGBlY01vZGVsYCBhbmQgYGNvbXBvbmVudE1vZGVsYC5cclxuICogV2hlbiBcInJlc290cmVcIiBhY3Rpb24gdHJpZ2dlcmVkLCBtb2RlbCBmcm9tIGBjb21wb25lbnRBY3Rpb25Nb2RlbGAgd2lsbCBiZSBkaXNjYXJkZWRcclxuICogaW5zdGVhZCBvZiByZWNyZWF0aW5nIHRoZSBcImVjTW9kZWxcIiBmcm9tIHRoZSBcIl9vcHRpb25CYWNrdXBcIi5cclxuICovXG4vLyBmdW5jdGlvbiBtZXJnZVRvQmFja3VwT3B0aW9uKFxuLy8gICAgIGZha2VDbXB0c01hcDogRmFrZUNvbXBvbmVudHNNYXAsXG4vLyAgICAgLy8gYHRhck9wdGlvbmAgQ2FuIGJlIG51bGwvdW5kZWZpbmVkLCBtZWFucyBpbml0XG4vLyAgICAgdGFyT3B0aW9uOiBFQ1VuaXRPcHRpb24sXG4vLyAgICAgbmV3T3B0aW9uOiBFQ1VuaXRPcHRpb24sXG4vLyAgICAgLy8gQ2FuIGJlIG51bGwvdW5kZWZpbmVkXG4vLyAgICAgb3B0OiBJbm5lclNldE9wdGlvbk9wdHNcbi8vICk6IHZvaWQge1xuLy8gICAgIG5ld09wdGlvbiA9IG5ld09wdGlvbiB8fCB7fSBhcyBFQ1VuaXRPcHRpb247XG4vLyAgICAgY29uc3Qgbm90SW5pdCA9ICEhdGFyT3B0aW9uO1xuLy8gICAgIGVhY2gobmV3T3B0aW9uLCBmdW5jdGlvbiAobmV3T3B0c0luTWFpblR5cGUsIG1haW5UeXBlKSB7XG4vLyAgICAgICAgIGlmIChuZXdPcHRzSW5NYWluVHlwZSA9PSBudWxsKSB7XG4vLyAgICAgICAgICAgICByZXR1cm47XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgaWYgKCFDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhtYWluVHlwZSkpIHtcbi8vICAgICAgICAgICAgIGlmICh0YXJPcHRpb24pIHtcbi8vICAgICAgICAgICAgICAgICB0YXJPcHRpb25bbWFpblR5cGVdID0gbWVyZ2UodGFyT3B0aW9uW21haW5UeXBlXSwgbmV3T3B0c0luTWFpblR5cGUsIHRydWUpO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgY29uc3Qgb2xkVGFyT3B0c0luTWFpblR5cGUgPSBub3RJbml0ID8gbm9ybWFsaXplVG9BcnJheSh0YXJPcHRpb25bbWFpblR5cGVdKSA6IG51bGw7XG4vLyAgICAgICAgICAgICBjb25zdCBvbGRGYWtlQ21wdHNJbk1haW5UeXBlID0gZmFrZUNtcHRzTWFwLmdldChtYWluVHlwZSkgfHwgW107XG4vLyAgICAgICAgICAgICBjb25zdCByZXN1bHRUYXJPcHRzSW5NYWluVHlwZSA9IG5vdEluaXQgPyAodGFyT3B0aW9uW21haW5UeXBlXSA9IFtdIGFzIENvbXBvbmVudE9wdGlvbltdKSA6IG51bGw7XG4vLyAgICAgICAgICAgICBjb25zdCByZXN1bHRGYWtlQ21wdHNJbk1haW5UeXBlID0gZmFrZUNtcHRzTWFwLnNldChtYWluVHlwZSwgW10pO1xuLy8gICAgICAgICAgICAgY29uc3QgbWFwcGluZ1Jlc3VsdCA9IG1hcHBpbmdUb0V4aXN0cyhcbi8vICAgICAgICAgICAgICAgICBvbGRGYWtlQ21wdHNJbk1haW5UeXBlLFxuLy8gICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVRvQXJyYXkobmV3T3B0c0luTWFpblR5cGUpLFxuLy8gICAgICAgICAgICAgICAgIChvcHQgJiYgb3B0LnJlcGxhY2VNZXJnZU1haW5UeXBlTWFwLmdldChtYWluVHlwZSkpID8gJ3JlcGxhY2VNZXJnZScgOiAnbm9ybWFsTWVyZ2UnXG4vLyAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgc2V0Q29tcG9uZW50VHlwZVRvS2V5SW5mbyhtYXBwaW5nUmVzdWx0LCBtYWluVHlwZSwgQ29tcG9uZW50TW9kZWwgYXMgQ29tcG9uZW50TW9kZWxDb25zdHJ1Y3Rvcik7XG4vLyAgICAgICAgICAgICBlYWNoKG1hcHBpbmdSZXN1bHQsIGZ1bmN0aW9uIChyZXN1bHRJdGVtLCBpbmRleCkge1xuLy8gICAgICAgICAgICAgICAgIC8vIFRoZSBzYW1lIGxvZ2ljIGFzIGBHbG9iYWwudHMjX21lcmdlT3B0aW9uYC5cbi8vICAgICAgICAgICAgICAgICBsZXQgZmFrZUNtcHQgPSByZXN1bHRJdGVtLmV4aXN0aW5nO1xuLy8gICAgICAgICAgICAgICAgIGNvbnN0IG5ld09wdGlvbiA9IHJlc3VsdEl0ZW0ubmV3T3B0aW9uO1xuLy8gICAgICAgICAgICAgICAgIGNvbnN0IGtleUluZm8gPSByZXN1bHRJdGVtLmtleUluZm87XG4vLyAgICAgICAgICAgICAgICAgbGV0IGZha2VDbXB0T3B0O1xuLy8gICAgICAgICAgICAgICAgIGlmICghbmV3T3B0aW9uKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGZha2VDbXB0T3B0ID0gb2xkVGFyT3B0c0luTWFpblR5cGVbaW5kZXhdO1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWYgKGZha2VDbXB0ICYmIGZha2VDbXB0LnN1YlR5cGUgPT09IGtleUluZm8uc3ViVHlwZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZmFrZUNtcHQubmFtZSA9IGtleUluZm8ubmFtZTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RJbml0KSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFrZUNtcHRPcHQgPSBtZXJnZShvbGRUYXJPcHRzSW5NYWluVHlwZVtpbmRleF0sIG5ld09wdGlvbiwgdHJ1ZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBmYWtlQ21wdCA9IGV4dGVuZCh7fSwga2V5SW5mbyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90SW5pdCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZha2VDbXB0T3B0ID0gY2xvbmUobmV3T3B0aW9uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICBpZiAoZmFrZUNtcHQpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgbm90SW5pdCAmJiByZXN1bHRUYXJPcHRzSW5NYWluVHlwZS5wdXNoKGZha2VDbXB0T3B0KTtcbi8vICAgICAgICAgICAgICAgICAgICAgcmVzdWx0RmFrZUNtcHRzSW5NYWluVHlwZS5wdXNoKGZha2VDbXB0KTtcbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIG5vdEluaXQgJiYgcmVzdWx0VGFyT3B0c0luTWFpblR5cGUucHVzaCh2b2lkIDApO1xuLy8gICAgICAgICAgICAgICAgICAgICByZXN1bHRGYWtlQ21wdHNJbk1haW5UeXBlLnB1c2godm9pZCAwKTtcbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfVxuLy8gICAgIH0pO1xuLy8gfVxuZXhwb3J0IGRlZmF1bHQgT3B0aW9uTWFuYWdlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8348\n')},9427:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   J: () => (/* binding */ DataFormatMixin),\n/* harmony export */   L: () => (/* binding */ normalizeTooltipFormatResult)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _data_helper_dataProvider_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58267);\n/* harmony import */ var _util_format_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83412);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar DIMENSION_LABEL_REG = /\\{@(.+?)\\}/g;\nvar DataFormatMixin = /** @class */function () {\n  function DataFormatMixin() {}\n  /**\r\n   * Get params for formatter\r\n   */\n  DataFormatMixin.prototype.getDataParams = function (dataIndex, dataType) {\n    var data = this.getData(dataType);\n    var rawValue = this.getRawValue(dataIndex, dataType);\n    var rawDataIndex = data.getRawIndex(dataIndex);\n    var name = data.getName(dataIndex);\n    var itemOpt = data.getRawDataItem(dataIndex);\n    var style = data.getItemVisual(dataIndex, 'style');\n    var color = style && style[data.getItemVisual(dataIndex, 'drawType') || 'fill'];\n    var borderColor = style && style.stroke;\n    var mainType = this.mainType;\n    var isSeries = mainType === 'series';\n    var userOutput = data.userOutput && data.userOutput.get();\n    return {\n      componentType: mainType,\n      componentSubType: this.subType,\n      componentIndex: this.componentIndex,\n      seriesType: isSeries ? this.subType : null,\n      seriesIndex: this.seriesIndex,\n      seriesId: isSeries ? this.id : null,\n      seriesName: isSeries ? this.name : null,\n      name: name,\n      dataIndex: rawDataIndex,\n      data: itemOpt,\n      dataType: dataType,\n      value: rawValue,\n      color: color,\n      borderColor: borderColor,\n      dimensionNames: userOutput ? userOutput.fullDimensions : null,\n      encode: userOutput ? userOutput.encode : null,\n      // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n      $vars: ['seriesName', 'name', 'value']\n    };\n  };\n  /**\r\n   * Format label\r\n   * @param dataIndex\r\n   * @param status 'normal' by default\r\n   * @param dataType\r\n   * @param labelDimIndex Only used in some chart that\r\n   *        use formatter in different dimensions, like radar.\r\n   * @param formatter Formatter given outside.\r\n   * @return return null/undefined if no formatter\r\n   */\n  DataFormatMixin.prototype.getFormattedLabel = function (dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {\n    status = status || 'normal';\n    var data = this.getData(dataType);\n    var params = this.getDataParams(dataIndex, dataType);\n    if (extendParams) {\n      params.value = extendParams.interpolatedValue;\n    }\n    if (labelDimIndex != null && zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray(params.value)) {\n      params.value = params.value[labelDimIndex];\n    }\n    if (!formatter) {\n      var itemModel = data.getItemModel(dataIndex);\n      // @ts-ignore\n      formatter = itemModel.get(status === 'normal' ? ['label', 'formatter'] : [status, 'label', 'formatter']);\n    }\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isFunction(formatter)) {\n      params.status = status;\n      params.dimensionIndex = labelDimIndex;\n      return formatter(params);\n    } else if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString(formatter)) {\n      var str = (0,_util_format_js__WEBPACK_IMPORTED_MODULE_1__/* .formatTpl */ .YK)(formatter, params);\n      // Support 'aaa{@[3]}bbb{@product}ccc'.\n      // Do not support '}' in dim name util have to.\n      return str.replace(DIMENSION_LABEL_REG, function (origin, dimStr) {\n        var len = dimStr.length;\n        var dimLoose = dimStr;\n        if (dimLoose.charAt(0) === '[' && dimLoose.charAt(len - 1) === ']') {\n          dimLoose = +dimLoose.slice(1, len - 1); // Also support: '[]' => 0\n          if (false) {}\n        }\n        var val = (0,_data_helper_dataProvider_js__WEBPACK_IMPORTED_MODULE_2__/* .retrieveRawValue */ .QE)(data, dataIndex, dimLoose);\n        if (extendParams && zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray(extendParams.interpolatedValue)) {\n          var dimIndex = data.getDimensionIndex(dimLoose);\n          if (dimIndex >= 0) {\n            val = extendParams.interpolatedValue[dimIndex];\n          }\n        }\n        return val != null ? val + '' : '';\n      });\n    }\n  };\n  /**\r\n   * Get raw value in option\r\n   */\n  DataFormatMixin.prototype.getRawValue = function (idx, dataType) {\n    return (0,_data_helper_dataProvider_js__WEBPACK_IMPORTED_MODULE_2__/* .retrieveRawValue */ .QE)(this.getData(dataType), idx);\n  };\n  /**\r\n   * Should be implemented.\r\n   * @param {number} dataIndex\r\n   * @param {boolean} [multipleSeries=false]\r\n   * @param {string} [dataType]\r\n   */\n  DataFormatMixin.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n    // Empty function\n    return;\n  };\n  return DataFormatMixin;\n}();\n\n;\n// PENDING: previously we accept this type when calling `formatTooltip`,\n// but guess little chance has been used outside. Do we need to backward\n// compat it?\n// type TooltipFormatResultLegacyObject = {\n//     // `html` means the markup language text, either in 'html' or 'richText'.\n//     // The name `html` is not appropriate because in 'richText' it is not a HTML\n//     // string. But still support it for backward compatibility.\n//     html: string;\n//     markers: Dictionary<ColorString>;\n// };\n/**\r\n * For backward compat, normalize the return from `formatTooltip`.\r\n */\nfunction normalizeTooltipFormatResult(result) {\n  var markupText;\n  // let markers: Dictionary<ColorString>;\n  var markupFragment;\n  if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject(result)) {\n    if (result.type) {\n      markupFragment = result;\n    } else {\n      if (false) {}\n    }\n    // else {\n    //     markupText = (result as TooltipFormatResultLegacyObject).html;\n    //     markers = (result as TooltipFormatResultLegacyObject).markers;\n    //     if (markersExisting) {\n    //         markers = zrUtil.merge(markersExisting, markers);\n    //     }\n    // }\n  } else {\n    markupText = result;\n  }\n  return {\n    text: markupText,\n    // markers: markers || markersExisting,\n    frag: markupFragment\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQyNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vZGF0YUZvcm1hdC5qcz8zYjRlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyByZXRyaWV2ZVJhd1ZhbHVlIH0gZnJvbSAnLi4vLi4vZGF0YS9oZWxwZXIvZGF0YVByb3ZpZGVyLmpzJztcbmltcG9ydCB7IGZvcm1hdFRwbCB9IGZyb20gJy4uLy4uL3V0aWwvZm9ybWF0LmpzJztcbmltcG9ydCB7IGVycm9yLCBtYWtlUHJpbnRhYmxlIH0gZnJvbSAnLi4vLi4vdXRpbC9sb2cuanMnO1xudmFyIERJTUVOU0lPTl9MQUJFTF9SRUcgPSAvXFx7QCguKz8pXFx9L2c7XG52YXIgRGF0YUZvcm1hdE1peGluID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGF0YUZvcm1hdE1peGluKCkge31cbiAgLyoqXHJcbiAgICogR2V0IHBhcmFtcyBmb3IgZm9ybWF0dGVyXHJcbiAgICovXG4gIERhdGFGb3JtYXRNaXhpbi5wcm90b3R5cGUuZ2V0RGF0YVBhcmFtcyA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIGRhdGFUeXBlKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZGF0YVR5cGUpO1xuICAgIHZhciByYXdWYWx1ZSA9IHRoaXMuZ2V0UmF3VmFsdWUoZGF0YUluZGV4LCBkYXRhVHlwZSk7XG4gICAgdmFyIHJhd0RhdGFJbmRleCA9IGRhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KTtcbiAgICB2YXIgbmFtZSA9IGRhdGEuZ2V0TmFtZShkYXRhSW5kZXgpO1xuICAgIHZhciBpdGVtT3B0ID0gZGF0YS5nZXRSYXdEYXRhSXRlbShkYXRhSW5kZXgpO1xuICAgIHZhciBzdHlsZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdzdHlsZScpO1xuICAgIHZhciBjb2xvciA9IHN0eWxlICYmIHN0eWxlW2RhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdkcmF3VHlwZScpIHx8ICdmaWxsJ107XG4gICAgdmFyIGJvcmRlckNvbG9yID0gc3R5bGUgJiYgc3R5bGUuc3Ryb2tlO1xuICAgIHZhciBtYWluVHlwZSA9IHRoaXMubWFpblR5cGU7XG4gICAgdmFyIGlzU2VyaWVzID0gbWFpblR5cGUgPT09ICdzZXJpZXMnO1xuICAgIHZhciB1c2VyT3V0cHV0ID0gZGF0YS51c2VyT3V0cHV0ICYmIGRhdGEudXNlck91dHB1dC5nZXQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcG9uZW50VHlwZTogbWFpblR5cGUsXG4gICAgICBjb21wb25lbnRTdWJUeXBlOiB0aGlzLnN1YlR5cGUsXG4gICAgICBjb21wb25lbnRJbmRleDogdGhpcy5jb21wb25lbnRJbmRleCxcbiAgICAgIHNlcmllc1R5cGU6IGlzU2VyaWVzID8gdGhpcy5zdWJUeXBlIDogbnVsbCxcbiAgICAgIHNlcmllc0luZGV4OiB0aGlzLnNlcmllc0luZGV4LFxuICAgICAgc2VyaWVzSWQ6IGlzU2VyaWVzID8gdGhpcy5pZCA6IG51bGwsXG4gICAgICBzZXJpZXNOYW1lOiBpc1NlcmllcyA/IHRoaXMubmFtZSA6IG51bGwsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGF0YUluZGV4OiByYXdEYXRhSW5kZXgsXG4gICAgICBkYXRhOiBpdGVtT3B0LFxuICAgICAgZGF0YVR5cGU6IGRhdGFUeXBlLFxuICAgICAgdmFsdWU6IHJhd1ZhbHVlLFxuICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgYm9yZGVyQ29sb3I6IGJvcmRlckNvbG9yLFxuICAgICAgZGltZW5zaW9uTmFtZXM6IHVzZXJPdXRwdXQgPyB1c2VyT3V0cHV0LmZ1bGxEaW1lbnNpb25zIDogbnVsbCxcbiAgICAgIGVuY29kZTogdXNlck91dHB1dCA/IHVzZXJPdXRwdXQuZW5jb2RlIDogbnVsbCxcbiAgICAgIC8vIFBhcmFtIG5hbWUgbGlzdCBmb3IgbWFwcGluZyBgYWAsIGBiYCwgYGNgLCBgZGAsIGBlYFxuICAgICAgJHZhcnM6IFsnc2VyaWVzTmFtZScsICduYW1lJywgJ3ZhbHVlJ11cbiAgICB9O1xuICB9O1xuICAvKipcclxuICAgKiBGb3JtYXQgbGFiZWxcclxuICAgKiBAcGFyYW0gZGF0YUluZGV4XHJcbiAgICogQHBhcmFtIHN0YXR1cyAnbm9ybWFsJyBieSBkZWZhdWx0XHJcbiAgICogQHBhcmFtIGRhdGFUeXBlXHJcbiAgICogQHBhcmFtIGxhYmVsRGltSW5kZXggT25seSB1c2VkIGluIHNvbWUgY2hhcnQgdGhhdFxyXG4gICAqICAgICAgICB1c2UgZm9ybWF0dGVyIGluIGRpZmZlcmVudCBkaW1lbnNpb25zLCBsaWtlIHJhZGFyLlxyXG4gICAqIEBwYXJhbSBmb3JtYXR0ZXIgRm9ybWF0dGVyIGdpdmVuIG91dHNpZGUuXHJcbiAgICogQHJldHVybiByZXR1cm4gbnVsbC91bmRlZmluZWQgaWYgbm8gZm9ybWF0dGVyXHJcbiAgICovXG4gIERhdGFGb3JtYXRNaXhpbi5wcm90b3R5cGUuZ2V0Rm9ybWF0dGVkTGFiZWwgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBzdGF0dXMsIGRhdGFUeXBlLCBsYWJlbERpbUluZGV4LCBmb3JtYXR0ZXIsIGV4dGVuZFBhcmFtcykge1xuICAgIHN0YXR1cyA9IHN0YXR1cyB8fCAnbm9ybWFsJztcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShkYXRhVHlwZSk7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgsIGRhdGFUeXBlKTtcbiAgICBpZiAoZXh0ZW5kUGFyYW1zKSB7XG4gICAgICBwYXJhbXMudmFsdWUgPSBleHRlbmRQYXJhbXMuaW50ZXJwb2xhdGVkVmFsdWU7XG4gICAgfVxuICAgIGlmIChsYWJlbERpbUluZGV4ICE9IG51bGwgJiYgenJVdGlsLmlzQXJyYXkocGFyYW1zLnZhbHVlKSkge1xuICAgICAgcGFyYW1zLnZhbHVlID0gcGFyYW1zLnZhbHVlW2xhYmVsRGltSW5kZXhdO1xuICAgIH1cbiAgICBpZiAoIWZvcm1hdHRlcikge1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBmb3JtYXR0ZXIgPSBpdGVtTW9kZWwuZ2V0KHN0YXR1cyA9PT0gJ25vcm1hbCcgPyBbJ2xhYmVsJywgJ2Zvcm1hdHRlciddIDogW3N0YXR1cywgJ2xhYmVsJywgJ2Zvcm1hdHRlciddKTtcbiAgICB9XG4gICAgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKGZvcm1hdHRlcikpIHtcbiAgICAgIHBhcmFtcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICBwYXJhbXMuZGltZW5zaW9uSW5kZXggPSBsYWJlbERpbUluZGV4O1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcihwYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoenJVdGlsLmlzU3RyaW5nKGZvcm1hdHRlcikpIHtcbiAgICAgIHZhciBzdHIgPSBmb3JtYXRUcGwoZm9ybWF0dGVyLCBwYXJhbXMpO1xuICAgICAgLy8gU3VwcG9ydCAnYWFhe0BbM119YmJie0Bwcm9kdWN0fWNjYycuXG4gICAgICAvLyBEbyBub3Qgc3VwcG9ydCAnfScgaW4gZGltIG5hbWUgdXRpbCBoYXZlIHRvLlxuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKERJTUVOU0lPTl9MQUJFTF9SRUcsIGZ1bmN0aW9uIChvcmlnaW4sIGRpbVN0cikge1xuICAgICAgICB2YXIgbGVuID0gZGltU3RyLmxlbmd0aDtcbiAgICAgICAgdmFyIGRpbUxvb3NlID0gZGltU3RyO1xuICAgICAgICBpZiAoZGltTG9vc2UuY2hhckF0KDApID09PSAnWycgJiYgZGltTG9vc2UuY2hhckF0KGxlbiAtIDEpID09PSAnXScpIHtcbiAgICAgICAgICBkaW1Mb29zZSA9ICtkaW1Mb29zZS5zbGljZSgxLCBsZW4gLSAxKTsgLy8gQWxzbyBzdXBwb3J0OiAnW10nID0+IDBcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGlzTmFOKGRpbUxvb3NlKSkge1xuICAgICAgICAgICAgICBlcnJvcihcIkludmFsaWRlIGxhYmVsIGZvcm1hdHRlcjogQFwiICsgZGltU3RyICsgXCIsIG9ubHkgc3VwcG9ydCBAWzBdLCBAWzFdLCBAWzJdLCAuLi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB2YWwgPSByZXRyaWV2ZVJhd1ZhbHVlKGRhdGEsIGRhdGFJbmRleCwgZGltTG9vc2UpO1xuICAgICAgICBpZiAoZXh0ZW5kUGFyYW1zICYmIHpyVXRpbC5pc0FycmF5KGV4dGVuZFBhcmFtcy5pbnRlcnBvbGF0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICB2YXIgZGltSW5kZXggPSBkYXRhLmdldERpbWVuc2lvbkluZGV4KGRpbUxvb3NlKTtcbiAgICAgICAgICBpZiAoZGltSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdmFsID0gZXh0ZW5kUGFyYW1zLmludGVycG9sYXRlZFZhbHVlW2RpbUluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbCAhPSBudWxsID8gdmFsICsgJycgOiAnJztcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IHJhdyB2YWx1ZSBpbiBvcHRpb25cclxuICAgKi9cbiAgRGF0YUZvcm1hdE1peGluLnByb3RvdHlwZS5nZXRSYXdWYWx1ZSA9IGZ1bmN0aW9uIChpZHgsIGRhdGFUeXBlKSB7XG4gICAgcmV0dXJuIHJldHJpZXZlUmF3VmFsdWUodGhpcy5nZXREYXRhKGRhdGFUeXBlKSwgaWR4KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU2hvdWxkIGJlIGltcGxlbWVudGVkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttdWx0aXBsZVNlcmllcz1mYWxzZV1cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGFUeXBlXVxyXG4gICAqL1xuICBEYXRhRm9ybWF0TWl4aW4ucHJvdG90eXBlLmZvcm1hdFRvb2x0aXAgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBtdWx0aXBsZVNlcmllcywgZGF0YVR5cGUpIHtcbiAgICAvLyBFbXB0eSBmdW5jdGlvblxuICAgIHJldHVybjtcbiAgfTtcbiAgcmV0dXJuIERhdGFGb3JtYXRNaXhpbjtcbn0oKTtcbmV4cG9ydCB7IERhdGFGb3JtYXRNaXhpbiB9O1xuO1xuLy8gUEVORElORzogcHJldmlvdXNseSB3ZSBhY2NlcHQgdGhpcyB0eXBlIHdoZW4gY2FsbGluZyBgZm9ybWF0VG9vbHRpcGAsXG4vLyBidXQgZ3Vlc3MgbGl0dGxlIGNoYW5jZSBoYXMgYmVlbiB1c2VkIG91dHNpZGUuIERvIHdlIG5lZWQgdG8gYmFja3dhcmRcbi8vIGNvbXBhdCBpdD9cbi8vIHR5cGUgVG9vbHRpcEZvcm1hdFJlc3VsdExlZ2FjeU9iamVjdCA9IHtcbi8vICAgICAvLyBgaHRtbGAgbWVhbnMgdGhlIG1hcmt1cCBsYW5ndWFnZSB0ZXh0LCBlaXRoZXIgaW4gJ2h0bWwnIG9yICdyaWNoVGV4dCcuXG4vLyAgICAgLy8gVGhlIG5hbWUgYGh0bWxgIGlzIG5vdCBhcHByb3ByaWF0ZSBiZWNhdXNlIGluICdyaWNoVGV4dCcgaXQgaXMgbm90IGEgSFRNTFxuLy8gICAgIC8vIHN0cmluZy4gQnV0IHN0aWxsIHN1cHBvcnQgaXQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4vLyAgICAgaHRtbDogc3RyaW5nO1xuLy8gICAgIG1hcmtlcnM6IERpY3Rpb25hcnk8Q29sb3JTdHJpbmc+O1xuLy8gfTtcbi8qKlxyXG4gKiBGb3IgYmFja3dhcmQgY29tcGF0LCBub3JtYWxpemUgdGhlIHJldHVybiBmcm9tIGBmb3JtYXRUb29sdGlwYC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplVG9vbHRpcEZvcm1hdFJlc3VsdChyZXN1bHQpIHtcbiAgdmFyIG1hcmt1cFRleHQ7XG4gIC8vIGxldCBtYXJrZXJzOiBEaWN0aW9uYXJ5PENvbG9yU3RyaW5nPjtcbiAgdmFyIG1hcmt1cEZyYWdtZW50O1xuICBpZiAoenJVdGlsLmlzT2JqZWN0KHJlc3VsdCkpIHtcbiAgICBpZiAocmVzdWx0LnR5cGUpIHtcbiAgICAgIG1hcmt1cEZyYWdtZW50ID0gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSByZXR1cm4gdHlwZSBvZiBgZm9ybWF0VG9vbHRpcGAgaXMgbm90IHN1cHBvcnRlZDogJyArIG1ha2VQcmludGFibGUocmVzdWx0KSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGVsc2Uge1xuICAgIC8vICAgICBtYXJrdXBUZXh0ID0gKHJlc3VsdCBhcyBUb29sdGlwRm9ybWF0UmVzdWx0TGVnYWN5T2JqZWN0KS5odG1sO1xuICAgIC8vICAgICBtYXJrZXJzID0gKHJlc3VsdCBhcyBUb29sdGlwRm9ybWF0UmVzdWx0TGVnYWN5T2JqZWN0KS5tYXJrZXJzO1xuICAgIC8vICAgICBpZiAobWFya2Vyc0V4aXN0aW5nKSB7XG4gICAgLy8gICAgICAgICBtYXJrZXJzID0genJVdGlsLm1lcmdlKG1hcmtlcnNFeGlzdGluZywgbWFya2Vycyk7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gIH0gZWxzZSB7XG4gICAgbWFya3VwVGV4dCA9IHJlc3VsdDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRleHQ6IG1hcmt1cFRleHQsXG4gICAgLy8gbWFya2VyczogbWFya2VycyB8fCBtYXJrZXJzRXhpc3RpbmcsXG4gICAgZnJhZzogbWFya3VwRnJhZ21lbnRcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9427\n")},12706:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24326);\n/* harmony import */ var _util_time_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55854);\n/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(67071);\n/* harmony import */ var _Interval_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(74562);\n/* harmony import */ var _Scale_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(28613);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/*\r\n* A third-party license is embedded for some of the code in this file:\r\n* The \"scaleLevels\" was originally copied from \"d3.js\" with some\r\n* modifications made for this project.\r\n* (See more details in the comment on the definition of \"scaleLevels\" below.)\r\n* The use of the source code of this file is also subject to the terms\r\n* and consitions of the license of \"d3.js\" (BSD-3Clause, see\r\n* </licenses/LICENSE-d3>).\r\n*/\n// [About UTC and local time zone]:\n// In most cases, `number.parseDate` will treat input data string as local time\n// (except time zone is specified in time string). And `format.formateTime` returns\n// local time by default. option.useUTC is false by default. This design has\n// considered these common cases:\n// (1) Time that is persistent in server is in UTC, but it is needed to be displayed\n// in local time by default.\n// (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n// as its original time, without any time difference.\n\n\n\n\n\n\n\n// FIXME 公用？\nvar bisect = function (a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid][1] < x) {\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n  return lo;\n};\nvar TimeScale = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(TimeScale, _super);\n  function TimeScale(settings) {\n    var _this = _super.call(this, settings) || this;\n    _this.type = 'time';\n    return _this;\n  }\n  /**\r\n   * Get label is mainly for other components like dataZoom, tooltip.\r\n   */\n  TimeScale.prototype.getLabel = function (tick) {\n    var useUTC = this.getSetting('useUTC');\n    return (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .format */ .GP)(tick.value, _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .fullLeveledFormatter */ .Lm[(0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .getDefaultFormatPrecisionOfInterval */ .$9)((0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .getPrimaryTimeUnit */ .ym)(this._minLevelUnit))] || _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .fullLeveledFormatter */ .Lm.second, useUTC, this.getSetting('locale'));\n  };\n  TimeScale.prototype.getFormattedLabel = function (tick, idx, labelFormatter) {\n    var isUTC = this.getSetting('useUTC');\n    var lang = this.getSetting('locale');\n    return (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .leveledFormat */ .X_)(tick, idx, labelFormatter, lang, isUTC);\n  };\n  /**\r\n   * @override\r\n   */\n  TimeScale.prototype.getTicks = function () {\n    var interval = this._interval;\n    var extent = this._extent;\n    var ticks = [];\n    // If interval is 0, return [];\n    if (!interval) {\n      return ticks;\n    }\n    ticks.push({\n      value: extent[0],\n      level: 0\n    });\n    var useUTC = this.getSetting('useUTC');\n    var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent);\n    ticks = ticks.concat(innerTicks);\n    ticks.push({\n      value: extent[1],\n      level: 0\n    });\n    return ticks;\n  };\n  TimeScale.prototype.calcNiceExtent = function (opt) {\n    var extent = this._extent;\n    // If extent start and end are same, expand them\n    if (extent[0] === extent[1]) {\n      // Expand extent\n      extent[0] -= _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_DAY */ .CZ;\n      extent[1] += _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_DAY */ .CZ;\n    }\n    // If there are no data and extent are [Infinity, -Infinity]\n    if (extent[1] === -Infinity && extent[0] === Infinity) {\n      var d = new Date();\n      extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());\n      extent[0] = extent[1] - _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_DAY */ .CZ;\n    }\n    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);\n  };\n  TimeScale.prototype.calcNiceTicks = function (approxTickNum, minInterval, maxInterval) {\n    approxTickNum = approxTickNum || 10;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n    this._approxInterval = span / approxTickNum;\n    if (minInterval != null && this._approxInterval < minInterval) {\n      this._approxInterval = minInterval;\n    }\n    if (maxInterval != null && this._approxInterval > maxInterval) {\n      this._approxInterval = maxInterval;\n    }\n    var scaleIntervalsLen = scaleIntervals.length;\n    var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);\n    // Interval that can be used to calculate ticks\n    this._interval = scaleIntervals[idx][1];\n    // Min level used when picking ticks from top down.\n    // We check one more level to avoid the ticks are to sparse in some case.\n    this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];\n  };\n  TimeScale.prototype.parse = function (val) {\n    // val might be float.\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isNumber)(val) ? val : +_util_number_js__WEBPACK_IMPORTED_MODULE_3__/* .parseDate */ ._U(val);\n  };\n  TimeScale.prototype.contain = function (val) {\n    return _helper_js__WEBPACK_IMPORTED_MODULE_4__/* .contain */ .lP(this.parse(val), this._extent);\n  };\n  TimeScale.prototype.normalize = function (val) {\n    return _helper_js__WEBPACK_IMPORTED_MODULE_4__/* .normalize */ .S8(this.parse(val), this._extent);\n  };\n  TimeScale.prototype.scale = function (val) {\n    return _helper_js__WEBPACK_IMPORTED_MODULE_4__/* .scale */ .hs(val, this._extent);\n  };\n  TimeScale.type = 'time';\n  return TimeScale;\n}(_Interval_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A);\n/**\r\n * This implementation was originally copied from \"d3.js\"\r\n * <https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/time/scale.js>\r\n * with some modifications made for this program.\r\n * See the license statement at the head of this file.\r\n */\nvar scaleIntervals = [\n// Format                           interval\n['second', _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_SECOND */ .OY], ['minute', _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_MINUTE */ .iW], ['hour', _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_HOUR */ .MA], ['quarter-day', _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_HOUR */ .MA * 6], ['half-day', _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_HOUR */ .MA * 12], ['day', _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_DAY */ .CZ * 1.2], ['half-week', _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_DAY */ .CZ * 3.5], ['week', _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_DAY */ .CZ * 7], ['month', _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_DAY */ .CZ * 31], ['quarter', _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_DAY */ .CZ * 95], ['half-year', _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_YEAR */ .$H / 2], ['year', _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_YEAR */ .$H] // 1Y\n];\nfunction isUnitValueSame(unit, valueA, valueB, isUTC) {\n  var dateA = _util_number_js__WEBPACK_IMPORTED_MODULE_3__/* .parseDate */ ._U(valueA);\n  var dateB = _util_number_js__WEBPACK_IMPORTED_MODULE_3__/* .parseDate */ ._U(valueB);\n  var isSame = function (unit) {\n    return (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .getUnitValue */ .g0)(dateA, unit, isUTC) === (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .getUnitValue */ .g0)(dateB, unit, isUTC);\n  };\n  var isSameYear = function () {\n    return isSame('year');\n  };\n  // const isSameHalfYear = () => isSameYear() && isSame('half-year');\n  // const isSameQuater = () => isSameYear() && isSame('quarter');\n  var isSameMonth = function () {\n    return isSameYear() && isSame('month');\n  };\n  var isSameDay = function () {\n    return isSameMonth() && isSame('day');\n  };\n  // const isSameHalfDay = () => isSameDay() && isSame('half-day');\n  var isSameHour = function () {\n    return isSameDay() && isSame('hour');\n  };\n  var isSameMinute = function () {\n    return isSameHour() && isSame('minute');\n  };\n  var isSameSecond = function () {\n    return isSameMinute() && isSame('second');\n  };\n  var isSameMilliSecond = function () {\n    return isSameSecond() && isSame('millisecond');\n  };\n  switch (unit) {\n    case 'year':\n      return isSameYear();\n    case 'month':\n      return isSameMonth();\n    case 'day':\n      return isSameDay();\n    case 'hour':\n      return isSameHour();\n    case 'minute':\n      return isSameMinute();\n    case 'second':\n      return isSameSecond();\n    case 'millisecond':\n      return isSameMilliSecond();\n  }\n}\n// const primaryUnitGetters = {\n//     year: fullYearGetterName(),\n//     month: monthGetterName(),\n//     day: dateGetterName(),\n//     hour: hoursGetterName(),\n//     minute: minutesGetterName(),\n//     second: secondsGetterName(),\n//     millisecond: millisecondsGetterName()\n// };\n// const primaryUnitUTCGetters = {\n//     year: fullYearGetterName(true),\n//     month: monthGetterName(true),\n//     day: dateGetterName(true),\n//     hour: hoursGetterName(true),\n//     minute: minutesGetterName(true),\n//     second: secondsGetterName(true),\n//     millisecond: millisecondsGetterName(true)\n// };\n// function moveTick(date: Date, unitName: TimeUnit, step: number, isUTC: boolean) {\n//     step = step || 1;\n//     switch (getPrimaryTimeUnit(unitName)) {\n//         case 'year':\n//             date[fullYearSetterName(isUTC)](date[fullYearGetterName(isUTC)]() + step);\n//             break;\n//         case 'month':\n//             date[monthSetterName(isUTC)](date[monthGetterName(isUTC)]() + step);\n//             break;\n//         case 'day':\n//             date[dateSetterName(isUTC)](date[dateGetterName(isUTC)]() + step);\n//             break;\n//         case 'hour':\n//             date[hoursSetterName(isUTC)](date[hoursGetterName(isUTC)]() + step);\n//             break;\n//         case 'minute':\n//             date[minutesSetterName(isUTC)](date[minutesGetterName(isUTC)]() + step);\n//             break;\n//         case 'second':\n//             date[secondsSetterName(isUTC)](date[secondsGetterName(isUTC)]() + step);\n//             break;\n//         case 'millisecond':\n//             date[millisecondsSetterName(isUTC)](date[millisecondsGetterName(isUTC)]() + step);\n//             break;\n//     }\n//     return date.getTime();\n// }\n// const DATE_INTERVALS = [[8, 7.5], [4, 3.5], [2, 1.5]];\n// const MONTH_INTERVALS = [[6, 5.5], [3, 2.5], [2, 1.5]];\n// const MINUTES_SECONDS_INTERVALS = [[30, 30], [20, 20], [15, 15], [10, 10], [5, 5], [2, 2]];\nfunction getDateInterval(approxInterval, daysInMonth) {\n  approxInterval /= _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_DAY */ .CZ;\n  return approxInterval > 16 ? 16\n  // Math.floor(daysInMonth / 2) + 1  // In this case we only want one tick between two months.\n  : approxInterval > 7.5 ? 7 // TODO week 7 or day 8?\n  : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;\n}\nfunction getMonthInterval(approxInterval) {\n  var APPROX_ONE_MONTH = 30 * _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_DAY */ .CZ;\n  approxInterval /= APPROX_ONE_MONTH;\n  return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;\n}\nfunction getHourInterval(approxInterval) {\n  approxInterval /= _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_HOUR */ .MA;\n  return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;\n}\nfunction getMinutesAndSecondsInterval(approxInterval, isMinutes) {\n  approxInterval /= isMinutes ? _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_MINUTE */ .iW : _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_SECOND */ .OY;\n  return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;\n}\nfunction getMillisecondsInterval(approxInterval) {\n  return _util_number_js__WEBPACK_IMPORTED_MODULE_3__/* .nice */ .Cm(approxInterval, true);\n}\nfunction getFirstTimestampOfUnit(date, unitName, isUTC) {\n  var outDate = new Date(date);\n  switch ((0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .getPrimaryTimeUnit */ .ym)(unitName)) {\n    case 'year':\n    case 'month':\n      outDate[(0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .monthSetterName */ .xu)(isUTC)](0);\n    case 'day':\n      outDate[(0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .dateSetterName */ .ti)(isUTC)](1);\n    case 'hour':\n      outDate[(0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .hoursSetterName */ .Yd)(isUTC)](0);\n    case 'minute':\n      outDate[(0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .minutesSetterName */ .KF)(isUTC)](0);\n    case 'second':\n      outDate[(0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .secondsSetterName */ .ww)(isUTC)](0);\n      outDate[(0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .millisecondsSetterName */ .FP)(isUTC)](0);\n  }\n  return outDate.getTime();\n}\nfunction getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent) {\n  var safeLimit = 10000;\n  var unitNames = _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .timeUnits */ .F7;\n  var iter = 0;\n  function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate, out) {\n    var date = new Date(minTimestamp);\n    var dateTime = minTimestamp;\n    var d = date[getMethodName]();\n    // if (isDate) {\n    //     d -= 1; // Starts with 0;   PENDING\n    // }\n    while (dateTime < maxTimestamp && dateTime <= extent[1]) {\n      out.push({\n        value: dateTime\n      });\n      d += interval;\n      date[setMethodName](d);\n      dateTime = date.getTime();\n    }\n    // This extra tick is for calcuating ticks of next level. Will not been added to the final result\n    out.push({\n      value: dateTime,\n      notAdd: true\n    });\n  }\n  function addLevelTicks(unitName, lastLevelTicks, levelTicks) {\n    var newAddedTicks = [];\n    var isFirstLevel = !lastLevelTicks.length;\n    if (isUnitValueSame((0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .getPrimaryTimeUnit */ .ym)(unitName), extent[0], extent[1], isUTC)) {\n      return;\n    }\n    if (isFirstLevel) {\n      lastLevelTicks = [{\n        // TODO Optimize. Not include so may ticks.\n        value: getFirstTimestampOfUnit(new Date(extent[0]), unitName, isUTC)\n      }, {\n        value: extent[1]\n      }];\n    }\n    for (var i = 0; i < lastLevelTicks.length - 1; i++) {\n      var startTick = lastLevelTicks[i].value;\n      var endTick = lastLevelTicks[i + 1].value;\n      if (startTick === endTick) {\n        continue;\n      }\n      var interval = void 0;\n      var getterName = void 0;\n      var setterName = void 0;\n      var isDate = false;\n      switch (unitName) {\n        case 'year':\n          interval = Math.max(1, Math.round(approxInterval / _util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .ONE_DAY */ .CZ / 365));\n          getterName = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .fullYearGetterName */ .hY)(isUTC);\n          setterName = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .fullYearSetterName */ .tM)(isUTC);\n          break;\n        case 'half-year':\n        case 'quarter':\n        case 'month':\n          interval = getMonthInterval(approxInterval);\n          getterName = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .monthGetterName */ .jJ)(isUTC);\n          setterName = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .monthSetterName */ .xu)(isUTC);\n          break;\n        case 'week': // PENDING If week is added. Ignore day.\n        case 'half-week':\n        case 'day':\n          interval = getDateInterval(approxInterval, 31); // Use 32 days and let interval been 16\n          getterName = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .dateGetterName */ .bP)(isUTC);\n          setterName = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .dateSetterName */ .ti)(isUTC);\n          isDate = true;\n          break;\n        case 'half-day':\n        case 'quarter-day':\n        case 'hour':\n          interval = getHourInterval(approxInterval);\n          getterName = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .hoursGetterName */ .iC)(isUTC);\n          setterName = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .hoursSetterName */ .Yd)(isUTC);\n          break;\n        case 'minute':\n          interval = getMinutesAndSecondsInterval(approxInterval, true);\n          getterName = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .minutesGetterName */ .yB)(isUTC);\n          setterName = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .minutesSetterName */ .KF)(isUTC);\n          break;\n        case 'second':\n          interval = getMinutesAndSecondsInterval(approxInterval, false);\n          getterName = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .secondsGetterName */ .Wf)(isUTC);\n          setterName = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .secondsSetterName */ .ww)(isUTC);\n          break;\n        case 'millisecond':\n          interval = getMillisecondsInterval(approxInterval);\n          getterName = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .millisecondsGetterName */ .Zz)(isUTC);\n          setterName = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .millisecondsSetterName */ .FP)(isUTC);\n          break;\n      }\n      addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate, newAddedTicks);\n      if (unitName === 'year' && levelTicks.length > 1 && i === 0) {\n        // Add nearest years to the left extent.\n        levelTicks.unshift({\n          value: levelTicks[0].value - interval\n        });\n      }\n    }\n    for (var i = 0; i < newAddedTicks.length; i++) {\n      levelTicks.push(newAddedTicks[i]);\n    }\n    // newAddedTicks.length && console.log(unitName, newAddedTicks);\n    return newAddedTicks;\n  }\n  var levelsTicks = [];\n  var currentLevelTicks = [];\n  var tickCount = 0;\n  var lastLevelTickCount = 0;\n  for (var i = 0; i < unitNames.length && iter++ < safeLimit; ++i) {\n    var primaryTimeUnit = (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .getPrimaryTimeUnit */ .ym)(unitNames[i]);\n    if (!(0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .isPrimaryTimeUnit */ .ce)(unitNames[i])) {\n      // TODO\n      continue;\n    }\n    addLevelTicks(unitNames[i], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);\n    var nextPrimaryTimeUnit = unitNames[i + 1] ? (0,_util_time_js__WEBPACK_IMPORTED_MODULE_1__/* .getPrimaryTimeUnit */ .ym)(unitNames[i + 1]) : null;\n    if (primaryTimeUnit !== nextPrimaryTimeUnit) {\n      if (currentLevelTicks.length) {\n        lastLevelTickCount = tickCount;\n        // Remove the duplicate so the tick count can be precisely.\n        currentLevelTicks.sort(function (a, b) {\n          return a.value - b.value;\n        });\n        var levelTicksRemoveDuplicated = [];\n        for (var i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {\n          var tickValue = currentLevelTicks[i_1].value;\n          if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {\n            levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);\n            if (tickValue >= extent[0] && tickValue <= extent[1]) {\n              tickCount++;\n            }\n          }\n        }\n        var targetTickNum = (extent[1] - extent[0]) / approxInterval;\n        // Added too much in this level and not too less in last level\n        if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {\n          break;\n        }\n        // Only treat primary time unit as one level.\n        levelsTicks.push(levelTicksRemoveDuplicated);\n        if (tickCount > targetTickNum || bottomUnitName === unitNames[i]) {\n          break;\n        }\n      }\n      // Reset if next unitName is primary\n      currentLevelTicks = [];\n    }\n  }\n  if (false) {}\n  var levelsTicksInExtent = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.filter)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(levelsTicks, function (levelTicks) {\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.filter)(levelTicks, function (tick) {\n      return tick.value >= extent[0] && tick.value <= extent[1] && !tick.notAdd;\n    });\n  }), function (levelTicks) {\n    return levelTicks.length > 0;\n  });\n  var ticks = [];\n  var maxLevel = levelsTicksInExtent.length - 1;\n  for (var i = 0; i < levelsTicksInExtent.length; ++i) {\n    var levelTicks = levelsTicksInExtent[i];\n    for (var k = 0; k < levelTicks.length; ++k) {\n      ticks.push({\n        value: levelTicks[k].value,\n        level: maxLevel - i\n      });\n    }\n  }\n  ticks.sort(function (a, b) {\n    return a.value - b.value;\n  });\n  // Remove duplicates\n  var result = [];\n  for (var i = 0; i < ticks.length; ++i) {\n    if (i === 0 || ticks[i].value !== ticks[i - 1].value) {\n      result.push(ticks[i]);\n    }\n  }\n  return result;\n}\n_Scale_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A.registerClass(TimeScale);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TimeScale);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3MDYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL1RpbWUuanM/NWIxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuLypcclxuKiBBIHRoaXJkLXBhcnR5IGxpY2Vuc2UgaXMgZW1iZWRkZWQgZm9yIHNvbWUgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlOlxyXG4qIFRoZSBcInNjYWxlTGV2ZWxzXCIgd2FzIG9yaWdpbmFsbHkgY29waWVkIGZyb20gXCJkMy5qc1wiIHdpdGggc29tZVxyXG4qIG1vZGlmaWNhdGlvbnMgbWFkZSBmb3IgdGhpcyBwcm9qZWN0LlxyXG4qIChTZWUgbW9yZSBkZXRhaWxzIGluIHRoZSBjb21tZW50IG9uIHRoZSBkZWZpbml0aW9uIG9mIFwic2NhbGVMZXZlbHNcIiBiZWxvdy4pXHJcbiogVGhlIHVzZSBvZiB0aGUgc291cmNlIGNvZGUgb2YgdGhpcyBmaWxlIGlzIGFsc28gc3ViamVjdCB0byB0aGUgdGVybXNcclxuKiBhbmQgY29uc2l0aW9ucyBvZiB0aGUgbGljZW5zZSBvZiBcImQzLmpzXCIgKEJTRC0zQ2xhdXNlLCBzZWVcclxuKiA8L2xpY2Vuc2VzL0xJQ0VOU0UtZDM+KS5cclxuKi9cbi8vIFtBYm91dCBVVEMgYW5kIGxvY2FsIHRpbWUgem9uZV06XG4vLyBJbiBtb3N0IGNhc2VzLCBgbnVtYmVyLnBhcnNlRGF0ZWAgd2lsbCB0cmVhdCBpbnB1dCBkYXRhIHN0cmluZyBhcyBsb2NhbCB0aW1lXG4vLyAoZXhjZXB0IHRpbWUgem9uZSBpcyBzcGVjaWZpZWQgaW4gdGltZSBzdHJpbmcpLiBBbmQgYGZvcm1hdC5mb3JtYXRlVGltZWAgcmV0dXJuc1xuLy8gbG9jYWwgdGltZSBieSBkZWZhdWx0LiBvcHRpb24udXNlVVRDIGlzIGZhbHNlIGJ5IGRlZmF1bHQuIFRoaXMgZGVzaWduIGhhc1xuLy8gY29uc2lkZXJlZCB0aGVzZSBjb21tb24gY2FzZXM6XG4vLyAoMSkgVGltZSB0aGF0IGlzIHBlcnNpc3RlbnQgaW4gc2VydmVyIGlzIGluIFVUQywgYnV0IGl0IGlzIG5lZWRlZCB0byBiZSBkaXNwbGF5ZWRcbi8vIGluIGxvY2FsIHRpbWUgYnkgZGVmYXVsdC5cbi8vICgyKSBCeSBkZWZhdWx0LCB0aGUgaW5wdXQgZGF0YSBzdHJpbmcgKGUuZy4sICcyMDExLTAxLTAyJykgc2hvdWxkIGJlIGRpc3BsYXllZFxuLy8gYXMgaXRzIG9yaWdpbmFsIHRpbWUsIHdpdGhvdXQgYW55IHRpbWUgZGlmZmVyZW5jZS5cbmltcG9ydCAqIGFzIG51bWJlclV0aWwgZnJvbSAnLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IHsgT05FX1NFQ09ORCwgT05FX01JTlVURSwgT05FX0hPVVIsIE9ORV9EQVksIE9ORV9ZRUFSLCBmb3JtYXQsIGxldmVsZWRGb3JtYXQsIGdldFVuaXRWYWx1ZSwgdGltZVVuaXRzLCBmdWxsTGV2ZWxlZEZvcm1hdHRlciwgZ2V0UHJpbWFyeVRpbWVVbml0LCBpc1ByaW1hcnlUaW1lVW5pdCwgZ2V0RGVmYXVsdEZvcm1hdFByZWNpc2lvbk9mSW50ZXJ2YWwsIGZ1bGxZZWFyR2V0dGVyTmFtZSwgbW9udGhTZXR0ZXJOYW1lLCBmdWxsWWVhclNldHRlck5hbWUsIGRhdGVTZXR0ZXJOYW1lLCBob3Vyc0dldHRlck5hbWUsIGhvdXJzU2V0dGVyTmFtZSwgbWludXRlc1NldHRlck5hbWUsIHNlY29uZHNTZXR0ZXJOYW1lLCBtaWxsaXNlY29uZHNTZXR0ZXJOYW1lLCBtb250aEdldHRlck5hbWUsIGRhdGVHZXR0ZXJOYW1lLCBtaW51dGVzR2V0dGVyTmFtZSwgc2Vjb25kc0dldHRlck5hbWUsIG1pbGxpc2Vjb25kc0dldHRlck5hbWUgfSBmcm9tICcuLi91dGlsL3RpbWUuanMnO1xuaW1wb3J0ICogYXMgc2NhbGVIZWxwZXIgZnJvbSAnLi9oZWxwZXIuanMnO1xuaW1wb3J0IEludGVydmFsU2NhbGUgZnJvbSAnLi9JbnRlcnZhbC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi9TY2FsZS5qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vdXRpbC9sb2cuanMnO1xuaW1wb3J0IHsgZmlsdGVyLCBpc051bWJlciwgbWFwIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbi8vIEZJWE1FIOWFrOeUqO+8n1xudmFyIGJpc2VjdCA9IGZ1bmN0aW9uIChhLCB4LCBsbywgaGkpIHtcbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICBpZiAoYVttaWRdWzFdIDwgeCkge1xuICAgICAgbG8gPSBtaWQgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaSA9IG1pZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvO1xufTtcbnZhciBUaW1lU2NhbGUgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVGltZVNjYWxlLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBUaW1lU2NhbGUoc2V0dGluZ3MpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzZXR0aW5ncykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gJ3RpbWUnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBHZXQgbGFiZWwgaXMgbWFpbmx5IGZvciBvdGhlciBjb21wb25lbnRzIGxpa2UgZGF0YVpvb20sIHRvb2x0aXAuXHJcbiAgICovXG4gIFRpbWVTY2FsZS5wcm90b3R5cGUuZ2V0TGFiZWwgPSBmdW5jdGlvbiAodGljaykge1xuICAgIHZhciB1c2VVVEMgPSB0aGlzLmdldFNldHRpbmcoJ3VzZVVUQycpO1xuICAgIHJldHVybiBmb3JtYXQodGljay52YWx1ZSwgZnVsbExldmVsZWRGb3JtYXR0ZXJbZ2V0RGVmYXVsdEZvcm1hdFByZWNpc2lvbk9mSW50ZXJ2YWwoZ2V0UHJpbWFyeVRpbWVVbml0KHRoaXMuX21pbkxldmVsVW5pdCkpXSB8fCBmdWxsTGV2ZWxlZEZvcm1hdHRlci5zZWNvbmQsIHVzZVVUQywgdGhpcy5nZXRTZXR0aW5nKCdsb2NhbGUnKSk7XG4gIH07XG4gIFRpbWVTY2FsZS5wcm90b3R5cGUuZ2V0Rm9ybWF0dGVkTGFiZWwgPSBmdW5jdGlvbiAodGljaywgaWR4LCBsYWJlbEZvcm1hdHRlcikge1xuICAgIHZhciBpc1VUQyA9IHRoaXMuZ2V0U2V0dGluZygndXNlVVRDJyk7XG4gICAgdmFyIGxhbmcgPSB0aGlzLmdldFNldHRpbmcoJ2xvY2FsZScpO1xuICAgIHJldHVybiBsZXZlbGVkRm9ybWF0KHRpY2ssIGlkeCwgbGFiZWxGb3JtYXR0ZXIsIGxhbmcsIGlzVVRDKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXG4gIFRpbWVTY2FsZS5wcm90b3R5cGUuZ2V0VGlja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGludGVydmFsID0gdGhpcy5faW50ZXJ2YWw7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgdGlja3MgPSBbXTtcbiAgICAvLyBJZiBpbnRlcnZhbCBpcyAwLCByZXR1cm4gW107XG4gICAgaWYgKCFpbnRlcnZhbCkge1xuICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH1cbiAgICB0aWNrcy5wdXNoKHtcbiAgICAgIHZhbHVlOiBleHRlbnRbMF0sXG4gICAgICBsZXZlbDogMFxuICAgIH0pO1xuICAgIHZhciB1c2VVVEMgPSB0aGlzLmdldFNldHRpbmcoJ3VzZVVUQycpO1xuICAgIHZhciBpbm5lclRpY2tzID0gZ2V0SW50ZXJ2YWxUaWNrcyh0aGlzLl9taW5MZXZlbFVuaXQsIHRoaXMuX2FwcHJveEludGVydmFsLCB1c2VVVEMsIGV4dGVudCk7XG4gICAgdGlja3MgPSB0aWNrcy5jb25jYXQoaW5uZXJUaWNrcyk7XG4gICAgdGlja3MucHVzaCh7XG4gICAgICB2YWx1ZTogZXh0ZW50WzFdLFxuICAgICAgbGV2ZWw6IDBcbiAgICB9KTtcbiAgICByZXR1cm4gdGlja3M7XG4gIH07XG4gIFRpbWVTY2FsZS5wcm90b3R5cGUuY2FsY05pY2VFeHRlbnQgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAvLyBJZiBleHRlbnQgc3RhcnQgYW5kIGVuZCBhcmUgc2FtZSwgZXhwYW5kIHRoZW1cbiAgICBpZiAoZXh0ZW50WzBdID09PSBleHRlbnRbMV0pIHtcbiAgICAgIC8vIEV4cGFuZCBleHRlbnRcbiAgICAgIGV4dGVudFswXSAtPSBPTkVfREFZO1xuICAgICAgZXh0ZW50WzFdICs9IE9ORV9EQVk7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBkYXRhIGFuZCBleHRlbnQgYXJlIFtJbmZpbml0eSwgLUluZmluaXR5XVxuICAgIGlmIChleHRlbnRbMV0gPT09IC1JbmZpbml0eSAmJiBleHRlbnRbMF0gPT09IEluZmluaXR5KSB7XG4gICAgICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gICAgICBleHRlbnRbMV0gPSArbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpKTtcbiAgICAgIGV4dGVudFswXSA9IGV4dGVudFsxXSAtIE9ORV9EQVk7XG4gICAgfVxuICAgIHRoaXMuY2FsY05pY2VUaWNrcyhvcHQuc3BsaXROdW1iZXIsIG9wdC5taW5JbnRlcnZhbCwgb3B0Lm1heEludGVydmFsKTtcbiAgfTtcbiAgVGltZVNjYWxlLnByb3RvdHlwZS5jYWxjTmljZVRpY2tzID0gZnVuY3Rpb24gKGFwcHJveFRpY2tOdW0sIG1pbkludGVydmFsLCBtYXhJbnRlcnZhbCkge1xuICAgIGFwcHJveFRpY2tOdW0gPSBhcHByb3hUaWNrTnVtIHx8IDEwO1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgdGhpcy5fYXBwcm94SW50ZXJ2YWwgPSBzcGFuIC8gYXBwcm94VGlja051bTtcbiAgICBpZiAobWluSW50ZXJ2YWwgIT0gbnVsbCAmJiB0aGlzLl9hcHByb3hJbnRlcnZhbCA8IG1pbkludGVydmFsKSB7XG4gICAgICB0aGlzLl9hcHByb3hJbnRlcnZhbCA9IG1pbkludGVydmFsO1xuICAgIH1cbiAgICBpZiAobWF4SW50ZXJ2YWwgIT0gbnVsbCAmJiB0aGlzLl9hcHByb3hJbnRlcnZhbCA+IG1heEludGVydmFsKSB7XG4gICAgICB0aGlzLl9hcHByb3hJbnRlcnZhbCA9IG1heEludGVydmFsO1xuICAgIH1cbiAgICB2YXIgc2NhbGVJbnRlcnZhbHNMZW4gPSBzY2FsZUludGVydmFscy5sZW5ndGg7XG4gICAgdmFyIGlkeCA9IE1hdGgubWluKGJpc2VjdChzY2FsZUludGVydmFscywgdGhpcy5fYXBwcm94SW50ZXJ2YWwsIDAsIHNjYWxlSW50ZXJ2YWxzTGVuKSwgc2NhbGVJbnRlcnZhbHNMZW4gLSAxKTtcbiAgICAvLyBJbnRlcnZhbCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0aWNrc1xuICAgIHRoaXMuX2ludGVydmFsID0gc2NhbGVJbnRlcnZhbHNbaWR4XVsxXTtcbiAgICAvLyBNaW4gbGV2ZWwgdXNlZCB3aGVuIHBpY2tpbmcgdGlja3MgZnJvbSB0b3AgZG93bi5cbiAgICAvLyBXZSBjaGVjayBvbmUgbW9yZSBsZXZlbCB0byBhdm9pZCB0aGUgdGlja3MgYXJlIHRvIHNwYXJzZSBpbiBzb21lIGNhc2UuXG4gICAgdGhpcy5fbWluTGV2ZWxVbml0ID0gc2NhbGVJbnRlcnZhbHNbTWF0aC5tYXgoaWR4IC0gMSwgMCldWzBdO1xuICB9O1xuICBUaW1lU2NhbGUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIC8vIHZhbCBtaWdodCBiZSBmbG9hdC5cbiAgICByZXR1cm4gaXNOdW1iZXIodmFsKSA/IHZhbCA6ICtudW1iZXJVdGlsLnBhcnNlRGF0ZSh2YWwpO1xuICB9O1xuICBUaW1lU2NhbGUucHJvdG90eXBlLmNvbnRhaW4gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHNjYWxlSGVscGVyLmNvbnRhaW4odGhpcy5wYXJzZSh2YWwpLCB0aGlzLl9leHRlbnQpO1xuICB9O1xuICBUaW1lU2NhbGUucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gc2NhbGVIZWxwZXIubm9ybWFsaXplKHRoaXMucGFyc2UodmFsKSwgdGhpcy5fZXh0ZW50KTtcbiAgfTtcbiAgVGltZVNjYWxlLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gc2NhbGVIZWxwZXIuc2NhbGUodmFsLCB0aGlzLl9leHRlbnQpO1xuICB9O1xuICBUaW1lU2NhbGUudHlwZSA9ICd0aW1lJztcbiAgcmV0dXJuIFRpbWVTY2FsZTtcbn0oSW50ZXJ2YWxTY2FsZSk7XG4vKipcclxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiB3YXMgb3JpZ2luYWxseSBjb3BpZWQgZnJvbSBcImQzLmpzXCJcclxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy9ibG9iL2I1MTZkNzdmYjg1NjZiNTc2MDg4ZTczNDEwNDM3NDk0NzE3YWRhMjYvc3JjL3RpbWUvc2NhbGUuanM+XHJcbiAqIHdpdGggc29tZSBtb2RpZmljYXRpb25zIG1hZGUgZm9yIHRoaXMgcHJvZ3JhbS5cclxuICogU2VlIHRoZSBsaWNlbnNlIHN0YXRlbWVudCBhdCB0aGUgaGVhZCBvZiB0aGlzIGZpbGUuXHJcbiAqL1xudmFyIHNjYWxlSW50ZXJ2YWxzID0gW1xuLy8gRm9ybWF0ICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxcblsnc2Vjb25kJywgT05FX1NFQ09ORF0sIFsnbWludXRlJywgT05FX01JTlVURV0sIFsnaG91cicsIE9ORV9IT1VSXSwgWydxdWFydGVyLWRheScsIE9ORV9IT1VSICogNl0sIFsnaGFsZi1kYXknLCBPTkVfSE9VUiAqIDEyXSwgWydkYXknLCBPTkVfREFZICogMS4yXSwgWydoYWxmLXdlZWsnLCBPTkVfREFZICogMy41XSwgWyd3ZWVrJywgT05FX0RBWSAqIDddLCBbJ21vbnRoJywgT05FX0RBWSAqIDMxXSwgWydxdWFydGVyJywgT05FX0RBWSAqIDk1XSwgWydoYWxmLXllYXInLCBPTkVfWUVBUiAvIDJdLCBbJ3llYXInLCBPTkVfWUVBUl0gLy8gMVlcbl07XG5mdW5jdGlvbiBpc1VuaXRWYWx1ZVNhbWUodW5pdCwgdmFsdWVBLCB2YWx1ZUIsIGlzVVRDKSB7XG4gIHZhciBkYXRlQSA9IG51bWJlclV0aWwucGFyc2VEYXRlKHZhbHVlQSk7XG4gIHZhciBkYXRlQiA9IG51bWJlclV0aWwucGFyc2VEYXRlKHZhbHVlQik7XG4gIHZhciBpc1NhbWUgPSBmdW5jdGlvbiAodW5pdCkge1xuICAgIHJldHVybiBnZXRVbml0VmFsdWUoZGF0ZUEsIHVuaXQsIGlzVVRDKSA9PT0gZ2V0VW5pdFZhbHVlKGRhdGVCLCB1bml0LCBpc1VUQyk7XG4gIH07XG4gIHZhciBpc1NhbWVZZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc1NhbWUoJ3llYXInKTtcbiAgfTtcbiAgLy8gY29uc3QgaXNTYW1lSGFsZlllYXIgPSAoKSA9PiBpc1NhbWVZZWFyKCkgJiYgaXNTYW1lKCdoYWxmLXllYXInKTtcbiAgLy8gY29uc3QgaXNTYW1lUXVhdGVyID0gKCkgPT4gaXNTYW1lWWVhcigpICYmIGlzU2FtZSgncXVhcnRlcicpO1xuICB2YXIgaXNTYW1lTW9udGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzU2FtZVllYXIoKSAmJiBpc1NhbWUoJ21vbnRoJyk7XG4gIH07XG4gIHZhciBpc1NhbWVEYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzU2FtZU1vbnRoKCkgJiYgaXNTYW1lKCdkYXknKTtcbiAgfTtcbiAgLy8gY29uc3QgaXNTYW1lSGFsZkRheSA9ICgpID0+IGlzU2FtZURheSgpICYmIGlzU2FtZSgnaGFsZi1kYXknKTtcbiAgdmFyIGlzU2FtZUhvdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzU2FtZURheSgpICYmIGlzU2FtZSgnaG91cicpO1xuICB9O1xuICB2YXIgaXNTYW1lTWludXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc1NhbWVIb3VyKCkgJiYgaXNTYW1lKCdtaW51dGUnKTtcbiAgfTtcbiAgdmFyIGlzU2FtZVNlY29uZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNTYW1lTWludXRlKCkgJiYgaXNTYW1lKCdzZWNvbmQnKTtcbiAgfTtcbiAgdmFyIGlzU2FtZU1pbGxpU2Vjb25kID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc1NhbWVTZWNvbmQoKSAmJiBpc1NhbWUoJ21pbGxpc2Vjb25kJyk7XG4gIH07XG4gIHN3aXRjaCAodW5pdCkge1xuICAgIGNhc2UgJ3llYXInOlxuICAgICAgcmV0dXJuIGlzU2FtZVllYXIoKTtcbiAgICBjYXNlICdtb250aCc6XG4gICAgICByZXR1cm4gaXNTYW1lTW9udGgoKTtcbiAgICBjYXNlICdkYXknOlxuICAgICAgcmV0dXJuIGlzU2FtZURheSgpO1xuICAgIGNhc2UgJ2hvdXInOlxuICAgICAgcmV0dXJuIGlzU2FtZUhvdXIoKTtcbiAgICBjYXNlICdtaW51dGUnOlxuICAgICAgcmV0dXJuIGlzU2FtZU1pbnV0ZSgpO1xuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICByZXR1cm4gaXNTYW1lU2Vjb25kKCk7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgcmV0dXJuIGlzU2FtZU1pbGxpU2Vjb25kKCk7XG4gIH1cbn1cbi8vIGNvbnN0IHByaW1hcnlVbml0R2V0dGVycyA9IHtcbi8vICAgICB5ZWFyOiBmdWxsWWVhckdldHRlck5hbWUoKSxcbi8vICAgICBtb250aDogbW9udGhHZXR0ZXJOYW1lKCksXG4vLyAgICAgZGF5OiBkYXRlR2V0dGVyTmFtZSgpLFxuLy8gICAgIGhvdXI6IGhvdXJzR2V0dGVyTmFtZSgpLFxuLy8gICAgIG1pbnV0ZTogbWludXRlc0dldHRlck5hbWUoKSxcbi8vICAgICBzZWNvbmQ6IHNlY29uZHNHZXR0ZXJOYW1lKCksXG4vLyAgICAgbWlsbGlzZWNvbmQ6IG1pbGxpc2Vjb25kc0dldHRlck5hbWUoKVxuLy8gfTtcbi8vIGNvbnN0IHByaW1hcnlVbml0VVRDR2V0dGVycyA9IHtcbi8vICAgICB5ZWFyOiBmdWxsWWVhckdldHRlck5hbWUodHJ1ZSksXG4vLyAgICAgbW9udGg6IG1vbnRoR2V0dGVyTmFtZSh0cnVlKSxcbi8vICAgICBkYXk6IGRhdGVHZXR0ZXJOYW1lKHRydWUpLFxuLy8gICAgIGhvdXI6IGhvdXJzR2V0dGVyTmFtZSh0cnVlKSxcbi8vICAgICBtaW51dGU6IG1pbnV0ZXNHZXR0ZXJOYW1lKHRydWUpLFxuLy8gICAgIHNlY29uZDogc2Vjb25kc0dldHRlck5hbWUodHJ1ZSksXG4vLyAgICAgbWlsbGlzZWNvbmQ6IG1pbGxpc2Vjb25kc0dldHRlck5hbWUodHJ1ZSlcbi8vIH07XG4vLyBmdW5jdGlvbiBtb3ZlVGljayhkYXRlOiBEYXRlLCB1bml0TmFtZTogVGltZVVuaXQsIHN0ZXA6IG51bWJlciwgaXNVVEM6IGJvb2xlYW4pIHtcbi8vICAgICBzdGVwID0gc3RlcCB8fCAxO1xuLy8gICAgIHN3aXRjaCAoZ2V0UHJpbWFyeVRpbWVVbml0KHVuaXROYW1lKSkge1xuLy8gICAgICAgICBjYXNlICd5ZWFyJzpcbi8vICAgICAgICAgICAgIGRhdGVbZnVsbFllYXJTZXR0ZXJOYW1lKGlzVVRDKV0oZGF0ZVtmdWxsWWVhckdldHRlck5hbWUoaXNVVEMpXSgpICsgc3RlcCk7XG4vLyAgICAgICAgICAgICBicmVhaztcbi8vICAgICAgICAgY2FzZSAnbW9udGgnOlxuLy8gICAgICAgICAgICAgZGF0ZVttb250aFNldHRlck5hbWUoaXNVVEMpXShkYXRlW21vbnRoR2V0dGVyTmFtZShpc1VUQyldKCkgKyBzdGVwKTtcbi8vICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICBjYXNlICdkYXknOlxuLy8gICAgICAgICAgICAgZGF0ZVtkYXRlU2V0dGVyTmFtZShpc1VUQyldKGRhdGVbZGF0ZUdldHRlck5hbWUoaXNVVEMpXSgpICsgc3RlcCk7XG4vLyAgICAgICAgICAgICBicmVhaztcbi8vICAgICAgICAgY2FzZSAnaG91cic6XG4vLyAgICAgICAgICAgICBkYXRlW2hvdXJzU2V0dGVyTmFtZShpc1VUQyldKGRhdGVbaG91cnNHZXR0ZXJOYW1lKGlzVVRDKV0oKSArIHN0ZXApO1xuLy8gICAgICAgICAgICAgYnJlYWs7XG4vLyAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4vLyAgICAgICAgICAgICBkYXRlW21pbnV0ZXNTZXR0ZXJOYW1lKGlzVVRDKV0oZGF0ZVttaW51dGVzR2V0dGVyTmFtZShpc1VUQyldKCkgKyBzdGVwKTtcbi8vICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICBjYXNlICdzZWNvbmQnOlxuLy8gICAgICAgICAgICAgZGF0ZVtzZWNvbmRzU2V0dGVyTmFtZShpc1VUQyldKGRhdGVbc2Vjb25kc0dldHRlck5hbWUoaXNVVEMpXSgpICsgc3RlcCk7XG4vLyAgICAgICAgICAgICBicmVhaztcbi8vICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuLy8gICAgICAgICAgICAgZGF0ZVttaWxsaXNlY29uZHNTZXR0ZXJOYW1lKGlzVVRDKV0oZGF0ZVttaWxsaXNlY29uZHNHZXR0ZXJOYW1lKGlzVVRDKV0oKSArIHN0ZXApO1xuLy8gICAgICAgICAgICAgYnJlYWs7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBkYXRlLmdldFRpbWUoKTtcbi8vIH1cbi8vIGNvbnN0IERBVEVfSU5URVJWQUxTID0gW1s4LCA3LjVdLCBbNCwgMy41XSwgWzIsIDEuNV1dO1xuLy8gY29uc3QgTU9OVEhfSU5URVJWQUxTID0gW1s2LCA1LjVdLCBbMywgMi41XSwgWzIsIDEuNV1dO1xuLy8gY29uc3QgTUlOVVRFU19TRUNPTkRTX0lOVEVSVkFMUyA9IFtbMzAsIDMwXSwgWzIwLCAyMF0sIFsxNSwgMTVdLCBbMTAsIDEwXSwgWzUsIDVdLCBbMiwgMl1dO1xuZnVuY3Rpb24gZ2V0RGF0ZUludGVydmFsKGFwcHJveEludGVydmFsLCBkYXlzSW5Nb250aCkge1xuICBhcHByb3hJbnRlcnZhbCAvPSBPTkVfREFZO1xuICByZXR1cm4gYXBwcm94SW50ZXJ2YWwgPiAxNiA/IDE2XG4gIC8vIE1hdGguZmxvb3IoZGF5c0luTW9udGggLyAyKSArIDEgIC8vIEluIHRoaXMgY2FzZSB3ZSBvbmx5IHdhbnQgb25lIHRpY2sgYmV0d2VlbiB0d28gbW9udGhzLlxuICA6IGFwcHJveEludGVydmFsID4gNy41ID8gNyAvLyBUT0RPIHdlZWsgNyBvciBkYXkgOD9cbiAgOiBhcHByb3hJbnRlcnZhbCA+IDMuNSA/IDQgOiBhcHByb3hJbnRlcnZhbCA+IDEuNSA/IDIgOiAxO1xufVxuZnVuY3Rpb24gZ2V0TW9udGhJbnRlcnZhbChhcHByb3hJbnRlcnZhbCkge1xuICB2YXIgQVBQUk9YX09ORV9NT05USCA9IDMwICogT05FX0RBWTtcbiAgYXBwcm94SW50ZXJ2YWwgLz0gQVBQUk9YX09ORV9NT05USDtcbiAgcmV0dXJuIGFwcHJveEludGVydmFsID4gNiA/IDYgOiBhcHByb3hJbnRlcnZhbCA+IDMgPyAzIDogYXBwcm94SW50ZXJ2YWwgPiAyID8gMiA6IDE7XG59XG5mdW5jdGlvbiBnZXRIb3VySW50ZXJ2YWwoYXBwcm94SW50ZXJ2YWwpIHtcbiAgYXBwcm94SW50ZXJ2YWwgLz0gT05FX0hPVVI7XG4gIHJldHVybiBhcHByb3hJbnRlcnZhbCA+IDEyID8gMTIgOiBhcHByb3hJbnRlcnZhbCA+IDYgPyA2IDogYXBwcm94SW50ZXJ2YWwgPiAzLjUgPyA0IDogYXBwcm94SW50ZXJ2YWwgPiAyID8gMiA6IDE7XG59XG5mdW5jdGlvbiBnZXRNaW51dGVzQW5kU2Vjb25kc0ludGVydmFsKGFwcHJveEludGVydmFsLCBpc01pbnV0ZXMpIHtcbiAgYXBwcm94SW50ZXJ2YWwgLz0gaXNNaW51dGVzID8gT05FX01JTlVURSA6IE9ORV9TRUNPTkQ7XG4gIHJldHVybiBhcHByb3hJbnRlcnZhbCA+IDMwID8gMzAgOiBhcHByb3hJbnRlcnZhbCA+IDIwID8gMjAgOiBhcHByb3hJbnRlcnZhbCA+IDE1ID8gMTUgOiBhcHByb3hJbnRlcnZhbCA+IDEwID8gMTAgOiBhcHByb3hJbnRlcnZhbCA+IDUgPyA1IDogYXBwcm94SW50ZXJ2YWwgPiAyID8gMiA6IDE7XG59XG5mdW5jdGlvbiBnZXRNaWxsaXNlY29uZHNJbnRlcnZhbChhcHByb3hJbnRlcnZhbCkge1xuICByZXR1cm4gbnVtYmVyVXRpbC5uaWNlKGFwcHJveEludGVydmFsLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0VGltZXN0YW1wT2ZVbml0KGRhdGUsIHVuaXROYW1lLCBpc1VUQykge1xuICB2YXIgb3V0RGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICBzd2l0Y2ggKGdldFByaW1hcnlUaW1lVW5pdCh1bml0TmFtZSkpIHtcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgICBvdXREYXRlW21vbnRoU2V0dGVyTmFtZShpc1VUQyldKDApO1xuICAgIGNhc2UgJ2RheSc6XG4gICAgICBvdXREYXRlW2RhdGVTZXR0ZXJOYW1lKGlzVVRDKV0oMSk7XG4gICAgY2FzZSAnaG91cic6XG4gICAgICBvdXREYXRlW2hvdXJzU2V0dGVyTmFtZShpc1VUQyldKDApO1xuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICBvdXREYXRlW21pbnV0ZXNTZXR0ZXJOYW1lKGlzVVRDKV0oMCk7XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgIG91dERhdGVbc2Vjb25kc1NldHRlck5hbWUoaXNVVEMpXSgwKTtcbiAgICAgIG91dERhdGVbbWlsbGlzZWNvbmRzU2V0dGVyTmFtZShpc1VUQyldKDApO1xuICB9XG4gIHJldHVybiBvdXREYXRlLmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIGdldEludGVydmFsVGlja3MoYm90dG9tVW5pdE5hbWUsIGFwcHJveEludGVydmFsLCBpc1VUQywgZXh0ZW50KSB7XG4gIHZhciBzYWZlTGltaXQgPSAxMDAwMDtcbiAgdmFyIHVuaXROYW1lcyA9IHRpbWVVbml0cztcbiAgdmFyIGl0ZXIgPSAwO1xuICBmdW5jdGlvbiBhZGRUaWNrc0luU3BhbihpbnRlcnZhbCwgbWluVGltZXN0YW1wLCBtYXhUaW1lc3RhbXAsIGdldE1ldGhvZE5hbWUsIHNldE1ldGhvZE5hbWUsIGlzRGF0ZSwgb3V0KSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShtaW5UaW1lc3RhbXApO1xuICAgIHZhciBkYXRlVGltZSA9IG1pblRpbWVzdGFtcDtcbiAgICB2YXIgZCA9IGRhdGVbZ2V0TWV0aG9kTmFtZV0oKTtcbiAgICAvLyBpZiAoaXNEYXRlKSB7XG4gICAgLy8gICAgIGQgLT0gMTsgLy8gU3RhcnRzIHdpdGggMDsgICBQRU5ESU5HXG4gICAgLy8gfVxuICAgIHdoaWxlIChkYXRlVGltZSA8IG1heFRpbWVzdGFtcCAmJiBkYXRlVGltZSA8PSBleHRlbnRbMV0pIHtcbiAgICAgIG91dC5wdXNoKHtcbiAgICAgICAgdmFsdWU6IGRhdGVUaW1lXG4gICAgICB9KTtcbiAgICAgIGQgKz0gaW50ZXJ2YWw7XG4gICAgICBkYXRlW3NldE1ldGhvZE5hbWVdKGQpO1xuICAgICAgZGF0ZVRpbWUgPSBkYXRlLmdldFRpbWUoKTtcbiAgICB9XG4gICAgLy8gVGhpcyBleHRyYSB0aWNrIGlzIGZvciBjYWxjdWF0aW5nIHRpY2tzIG9mIG5leHQgbGV2ZWwuIFdpbGwgbm90IGJlZW4gYWRkZWQgdG8gdGhlIGZpbmFsIHJlc3VsdFxuICAgIG91dC5wdXNoKHtcbiAgICAgIHZhbHVlOiBkYXRlVGltZSxcbiAgICAgIG5vdEFkZDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFkZExldmVsVGlja3ModW5pdE5hbWUsIGxhc3RMZXZlbFRpY2tzLCBsZXZlbFRpY2tzKSB7XG4gICAgdmFyIG5ld0FkZGVkVGlja3MgPSBbXTtcbiAgICB2YXIgaXNGaXJzdExldmVsID0gIWxhc3RMZXZlbFRpY2tzLmxlbmd0aDtcbiAgICBpZiAoaXNVbml0VmFsdWVTYW1lKGdldFByaW1hcnlUaW1lVW5pdCh1bml0TmFtZSksIGV4dGVudFswXSwgZXh0ZW50WzFdLCBpc1VUQykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRmlyc3RMZXZlbCkge1xuICAgICAgbGFzdExldmVsVGlja3MgPSBbe1xuICAgICAgICAvLyBUT0RPIE9wdGltaXplLiBOb3QgaW5jbHVkZSBzbyBtYXkgdGlja3MuXG4gICAgICAgIHZhbHVlOiBnZXRGaXJzdFRpbWVzdGFtcE9mVW5pdChuZXcgRGF0ZShleHRlbnRbMF0pLCB1bml0TmFtZSwgaXNVVEMpXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBleHRlbnRbMV1cbiAgICAgIH1dO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RMZXZlbFRpY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0VGljayA9IGxhc3RMZXZlbFRpY2tzW2ldLnZhbHVlO1xuICAgICAgdmFyIGVuZFRpY2sgPSBsYXN0TGV2ZWxUaWNrc1tpICsgMV0udmFsdWU7XG4gICAgICBpZiAoc3RhcnRUaWNrID09PSBlbmRUaWNrKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGludGVydmFsID0gdm9pZCAwO1xuICAgICAgdmFyIGdldHRlck5hbWUgPSB2b2lkIDA7XG4gICAgICB2YXIgc2V0dGVyTmFtZSA9IHZvaWQgMDtcbiAgICAgIHZhciBpc0RhdGUgPSBmYWxzZTtcbiAgICAgIHN3aXRjaCAodW5pdE5hbWUpIHtcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgaW50ZXJ2YWwgPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKGFwcHJveEludGVydmFsIC8gT05FX0RBWSAvIDM2NSkpO1xuICAgICAgICAgIGdldHRlck5hbWUgPSBmdWxsWWVhckdldHRlck5hbWUoaXNVVEMpO1xuICAgICAgICAgIHNldHRlck5hbWUgPSBmdWxsWWVhclNldHRlck5hbWUoaXNVVEMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdoYWxmLXllYXInOlxuICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgIGludGVydmFsID0gZ2V0TW9udGhJbnRlcnZhbChhcHByb3hJbnRlcnZhbCk7XG4gICAgICAgICAgZ2V0dGVyTmFtZSA9IG1vbnRoR2V0dGVyTmFtZShpc1VUQyk7XG4gICAgICAgICAgc2V0dGVyTmFtZSA9IG1vbnRoU2V0dGVyTmFtZShpc1VUQyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3dlZWsnOiAvLyBQRU5ESU5HIElmIHdlZWsgaXMgYWRkZWQuIElnbm9yZSBkYXkuXG4gICAgICAgIGNhc2UgJ2hhbGYtd2Vlayc6XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgaW50ZXJ2YWwgPSBnZXREYXRlSW50ZXJ2YWwoYXBwcm94SW50ZXJ2YWwsIDMxKTsgLy8gVXNlIDMyIGRheXMgYW5kIGxldCBpbnRlcnZhbCBiZWVuIDE2XG4gICAgICAgICAgZ2V0dGVyTmFtZSA9IGRhdGVHZXR0ZXJOYW1lKGlzVVRDKTtcbiAgICAgICAgICBzZXR0ZXJOYW1lID0gZGF0ZVNldHRlck5hbWUoaXNVVEMpO1xuICAgICAgICAgIGlzRGF0ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2hhbGYtZGF5JzpcbiAgICAgICAgY2FzZSAncXVhcnRlci1kYXknOlxuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICBpbnRlcnZhbCA9IGdldEhvdXJJbnRlcnZhbChhcHByb3hJbnRlcnZhbCk7XG4gICAgICAgICAgZ2V0dGVyTmFtZSA9IGhvdXJzR2V0dGVyTmFtZShpc1VUQyk7XG4gICAgICAgICAgc2V0dGVyTmFtZSA9IGhvdXJzU2V0dGVyTmFtZShpc1VUQyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgaW50ZXJ2YWwgPSBnZXRNaW51dGVzQW5kU2Vjb25kc0ludGVydmFsKGFwcHJveEludGVydmFsLCB0cnVlKTtcbiAgICAgICAgICBnZXR0ZXJOYW1lID0gbWludXRlc0dldHRlck5hbWUoaXNVVEMpO1xuICAgICAgICAgIHNldHRlck5hbWUgPSBtaW51dGVzU2V0dGVyTmFtZShpc1VUQyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgaW50ZXJ2YWwgPSBnZXRNaW51dGVzQW5kU2Vjb25kc0ludGVydmFsKGFwcHJveEludGVydmFsLCBmYWxzZSk7XG4gICAgICAgICAgZ2V0dGVyTmFtZSA9IHNlY29uZHNHZXR0ZXJOYW1lKGlzVVRDKTtcbiAgICAgICAgICBzZXR0ZXJOYW1lID0gc2Vjb25kc1NldHRlck5hbWUoaXNVVEMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgICAgaW50ZXJ2YWwgPSBnZXRNaWxsaXNlY29uZHNJbnRlcnZhbChhcHByb3hJbnRlcnZhbCk7XG4gICAgICAgICAgZ2V0dGVyTmFtZSA9IG1pbGxpc2Vjb25kc0dldHRlck5hbWUoaXNVVEMpO1xuICAgICAgICAgIHNldHRlck5hbWUgPSBtaWxsaXNlY29uZHNTZXR0ZXJOYW1lKGlzVVRDKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGFkZFRpY2tzSW5TcGFuKGludGVydmFsLCBzdGFydFRpY2ssIGVuZFRpY2ssIGdldHRlck5hbWUsIHNldHRlck5hbWUsIGlzRGF0ZSwgbmV3QWRkZWRUaWNrcyk7XG4gICAgICBpZiAodW5pdE5hbWUgPT09ICd5ZWFyJyAmJiBsZXZlbFRpY2tzLmxlbmd0aCA+IDEgJiYgaSA9PT0gMCkge1xuICAgICAgICAvLyBBZGQgbmVhcmVzdCB5ZWFycyB0byB0aGUgbGVmdCBleHRlbnQuXG4gICAgICAgIGxldmVsVGlja3MudW5zaGlmdCh7XG4gICAgICAgICAgdmFsdWU6IGxldmVsVGlja3NbMF0udmFsdWUgLSBpbnRlcnZhbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdBZGRlZFRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXZlbFRpY2tzLnB1c2gobmV3QWRkZWRUaWNrc1tpXSk7XG4gICAgfVxuICAgIC8vIG5ld0FkZGVkVGlja3MubGVuZ3RoICYmIGNvbnNvbGUubG9nKHVuaXROYW1lLCBuZXdBZGRlZFRpY2tzKTtcbiAgICByZXR1cm4gbmV3QWRkZWRUaWNrcztcbiAgfVxuICB2YXIgbGV2ZWxzVGlja3MgPSBbXTtcbiAgdmFyIGN1cnJlbnRMZXZlbFRpY2tzID0gW107XG4gIHZhciB0aWNrQ291bnQgPSAwO1xuICB2YXIgbGFzdExldmVsVGlja0NvdW50ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bml0TmFtZXMubGVuZ3RoICYmIGl0ZXIrKyA8IHNhZmVMaW1pdDsgKytpKSB7XG4gICAgdmFyIHByaW1hcnlUaW1lVW5pdCA9IGdldFByaW1hcnlUaW1lVW5pdCh1bml0TmFtZXNbaV0pO1xuICAgIGlmICghaXNQcmltYXJ5VGltZVVuaXQodW5pdE5hbWVzW2ldKSkge1xuICAgICAgLy8gVE9ET1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGFkZExldmVsVGlja3ModW5pdE5hbWVzW2ldLCBsZXZlbHNUaWNrc1tsZXZlbHNUaWNrcy5sZW5ndGggLSAxXSB8fCBbXSwgY3VycmVudExldmVsVGlja3MpO1xuICAgIHZhciBuZXh0UHJpbWFyeVRpbWVVbml0ID0gdW5pdE5hbWVzW2kgKyAxXSA/IGdldFByaW1hcnlUaW1lVW5pdCh1bml0TmFtZXNbaSArIDFdKSA6IG51bGw7XG4gICAgaWYgKHByaW1hcnlUaW1lVW5pdCAhPT0gbmV4dFByaW1hcnlUaW1lVW5pdCkge1xuICAgICAgaWYgKGN1cnJlbnRMZXZlbFRpY2tzLmxlbmd0aCkge1xuICAgICAgICBsYXN0TGV2ZWxUaWNrQ291bnQgPSB0aWNrQ291bnQ7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZHVwbGljYXRlIHNvIHRoZSB0aWNrIGNvdW50IGNhbiBiZSBwcmVjaXNlbHkuXG4gICAgICAgIGN1cnJlbnRMZXZlbFRpY2tzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS52YWx1ZSAtIGIudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbGV2ZWxUaWNrc1JlbW92ZUR1cGxpY2F0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgY3VycmVudExldmVsVGlja3MubGVuZ3RoOyArK2lfMSkge1xuICAgICAgICAgIHZhciB0aWNrVmFsdWUgPSBjdXJyZW50TGV2ZWxUaWNrc1tpXzFdLnZhbHVlO1xuICAgICAgICAgIGlmIChpXzEgPT09IDAgfHwgY3VycmVudExldmVsVGlja3NbaV8xIC0gMV0udmFsdWUgIT09IHRpY2tWYWx1ZSkge1xuICAgICAgICAgICAgbGV2ZWxUaWNrc1JlbW92ZUR1cGxpY2F0ZWQucHVzaChjdXJyZW50TGV2ZWxUaWNrc1tpXzFdKTtcbiAgICAgICAgICAgIGlmICh0aWNrVmFsdWUgPj0gZXh0ZW50WzBdICYmIHRpY2tWYWx1ZSA8PSBleHRlbnRbMV0pIHtcbiAgICAgICAgICAgICAgdGlja0NvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnZXRUaWNrTnVtID0gKGV4dGVudFsxXSAtIGV4dGVudFswXSkgLyBhcHByb3hJbnRlcnZhbDtcbiAgICAgICAgLy8gQWRkZWQgdG9vIG11Y2ggaW4gdGhpcyBsZXZlbCBhbmQgbm90IHRvbyBsZXNzIGluIGxhc3QgbGV2ZWxcbiAgICAgICAgaWYgKHRpY2tDb3VudCA+IHRhcmdldFRpY2tOdW0gKiAxLjUgJiYgbGFzdExldmVsVGlja0NvdW50ID4gdGFyZ2V0VGlja051bSAvIDEuNSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgdHJlYXQgcHJpbWFyeSB0aW1lIHVuaXQgYXMgb25lIGxldmVsLlxuICAgICAgICBsZXZlbHNUaWNrcy5wdXNoKGxldmVsVGlja3NSZW1vdmVEdXBsaWNhdGVkKTtcbiAgICAgICAgaWYgKHRpY2tDb3VudCA+IHRhcmdldFRpY2tOdW0gfHwgYm90dG9tVW5pdE5hbWUgPT09IHVuaXROYW1lc1tpXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZXNldCBpZiBuZXh0IHVuaXROYW1lIGlzIHByaW1hcnlcbiAgICAgIGN1cnJlbnRMZXZlbFRpY2tzID0gW107XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGl0ZXIgPj0gc2FmZUxpbWl0KSB7XG4gICAgICB3YXJuKCdFeGNlZWQgc2FmZSBsaW1pdC4nKTtcbiAgICB9XG4gIH1cbiAgdmFyIGxldmVsc1RpY2tzSW5FeHRlbnQgPSBmaWx0ZXIobWFwKGxldmVsc1RpY2tzLCBmdW5jdGlvbiAobGV2ZWxUaWNrcykge1xuICAgIHJldHVybiBmaWx0ZXIobGV2ZWxUaWNrcywgZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgIHJldHVybiB0aWNrLnZhbHVlID49IGV4dGVudFswXSAmJiB0aWNrLnZhbHVlIDw9IGV4dGVudFsxXSAmJiAhdGljay5ub3RBZGQ7XG4gICAgfSk7XG4gIH0pLCBmdW5jdGlvbiAobGV2ZWxUaWNrcykge1xuICAgIHJldHVybiBsZXZlbFRpY2tzLmxlbmd0aCA+IDA7XG4gIH0pO1xuICB2YXIgdGlja3MgPSBbXTtcbiAgdmFyIG1heExldmVsID0gbGV2ZWxzVGlja3NJbkV4dGVudC5sZW5ndGggLSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVsc1RpY2tzSW5FeHRlbnQubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbGV2ZWxUaWNrcyA9IGxldmVsc1RpY2tzSW5FeHRlbnRbaV07XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBsZXZlbFRpY2tzLmxlbmd0aDsgKytrKSB7XG4gICAgICB0aWNrcy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IGxldmVsVGlja3Nba10udmFsdWUsXG4gICAgICAgIGxldmVsOiBtYXhMZXZlbCAtIGlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB0aWNrcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEudmFsdWUgLSBiLnZhbHVlO1xuICB9KTtcbiAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGkgPT09IDAgfHwgdGlja3NbaV0udmFsdWUgIT09IHRpY2tzW2kgLSAxXS52YWx1ZSkge1xuICAgICAgcmVzdWx0LnB1c2godGlja3NbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuU2NhbGUucmVnaXN0ZXJDbGFzcyhUaW1lU2NhbGUpO1xuZXhwb3J0IGRlZmF1bHQgVGltZVNjYWxlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12706\n")},14716:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ defaultLoading)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43870);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30010);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32322);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43471);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar PI = Math.PI;\n/**\r\n * @param {module:echarts/ExtensionAPI} api\r\n * @param {Object} [opts]\r\n * @param {string} [opts.text]\r\n * @param {string} [opts.color]\r\n * @param {string} [opts.textColor]\r\n * @return {module:zrender/Element}\r\n */\nfunction defaultLoading(api, opts) {\n  opts = opts || {};\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.defaults(opts, {\n    text: 'loading',\n    textColor: '#000',\n    fontSize: 12,\n    fontWeight: 'normal',\n    fontStyle: 'normal',\n    fontFamily: 'sans-serif',\n    maskColor: 'rgba(255, 255, 255, 0.8)',\n    showSpinner: true,\n    color: '#5470c6',\n    spinnerRadius: 10,\n    lineWidth: 5,\n    zlevel: 0\n  });\n  var group = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A();\n  var mask = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A({\n    style: {\n      fill: opts.maskColor\n    },\n    zlevel: opts.zlevel,\n    z: 10000\n  });\n  group.add(mask);\n  var textContent = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .Ay({\n    style: {\n      text: opts.text,\n      fill: opts.textColor,\n      fontSize: opts.fontSize,\n      fontWeight: opts.fontWeight,\n      fontStyle: opts.fontStyle,\n      fontFamily: opts.fontFamily\n    },\n    zlevel: opts.zlevel,\n    z: 10001\n  });\n  var labelRect = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A({\n    style: {\n      fill: 'none'\n    },\n    textContent: textContent,\n    textConfig: {\n      position: 'right',\n      distance: 10\n    },\n    zlevel: opts.zlevel,\n    z: 10001\n  });\n  group.add(labelRect);\n  var arc;\n  if (opts.showSpinner) {\n    arc = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A({\n      shape: {\n        startAngle: -PI / 2,\n        endAngle: -PI / 2 + 0.1,\n        r: opts.spinnerRadius\n      },\n      style: {\n        stroke: opts.color,\n        lineCap: 'round',\n        lineWidth: opts.lineWidth\n      },\n      zlevel: opts.zlevel,\n      z: 10001\n    });\n    arc.animateShape(true).when(1000, {\n      endAngle: PI * 3 / 2\n    }).start('circularInOut');\n    arc.animateShape(true).when(1000, {\n      startAngle: PI * 3 / 2\n    }).delay(300).start('circularInOut');\n    group.add(arc);\n  }\n  // Inject resize\n  group.resize = function () {\n    var textWidth = textContent.getBoundingRect().width;\n    var r = opts.showSpinner ? opts.spinnerRadius : 0;\n    // cx = (containerWidth - arcDiameter - textDistance - textWidth) / 2\n    // textDistance needs to be calculated when both animation and text exist\n    var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2)\n    // only show the text\n    + (opts.showSpinner ? 0 : textWidth / 2)\n    // only show the spinner\n    + (textWidth ? 0 : r);\n    var cy = api.getHeight() / 2;\n    opts.showSpinner && arc.setShape({\n      cx: cx,\n      cy: cy\n    });\n    labelRect.setShape({\n      x: cx - r,\n      y: cy - r,\n      width: r * 2,\n      height: r * 2\n    });\n    mask.setShape({\n      x: 0,\n      y: 0,\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n  };\n  group.resize();\n  return group;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ3MTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sb2FkaW5nL2RlZmF1bHQuanM/NDZkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi91dGlsL2dyYXBoaWMuanMnO1xudmFyIFBJID0gTWF0aC5QSTtcbi8qKlxyXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnRleHRdXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb2xvcl1cclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnRleHRDb2xvcl1cclxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWZhdWx0TG9hZGluZyhhcGksIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHpyVXRpbC5kZWZhdWx0cyhvcHRzLCB7XG4gICAgdGV4dDogJ2xvYWRpbmcnLFxuICAgIHRleHRDb2xvcjogJyMwMDAnLFxuICAgIGZvbnRTaXplOiAxMixcbiAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICBmb250U3R5bGU6ICdub3JtYWwnLFxuICAgIGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcbiAgICBtYXNrQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCknLFxuICAgIHNob3dTcGlubmVyOiB0cnVlLFxuICAgIGNvbG9yOiAnIzU0NzBjNicsXG4gICAgc3Bpbm5lclJhZGl1czogMTAsXG4gICAgbGluZVdpZHRoOiA1LFxuICAgIHpsZXZlbDogMFxuICB9KTtcbiAgdmFyIGdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgdmFyIG1hc2sgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICBzdHlsZToge1xuICAgICAgZmlsbDogb3B0cy5tYXNrQ29sb3JcbiAgICB9LFxuICAgIHpsZXZlbDogb3B0cy56bGV2ZWwsXG4gICAgejogMTAwMDBcbiAgfSk7XG4gIGdyb3VwLmFkZChtYXNrKTtcbiAgdmFyIHRleHRDb250ZW50ID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgc3R5bGU6IHtcbiAgICAgIHRleHQ6IG9wdHMudGV4dCxcbiAgICAgIGZpbGw6IG9wdHMudGV4dENvbG9yLFxuICAgICAgZm9udFNpemU6IG9wdHMuZm9udFNpemUsXG4gICAgICBmb250V2VpZ2h0OiBvcHRzLmZvbnRXZWlnaHQsXG4gICAgICBmb250U3R5bGU6IG9wdHMuZm9udFN0eWxlLFxuICAgICAgZm9udEZhbWlseTogb3B0cy5mb250RmFtaWx5XG4gICAgfSxcbiAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgIHo6IDEwMDAxXG4gIH0pO1xuICB2YXIgbGFiZWxSZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgc3R5bGU6IHtcbiAgICAgIGZpbGw6ICdub25lJ1xuICAgIH0sXG4gICAgdGV4dENvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgIHRleHRDb25maWc6IHtcbiAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgZGlzdGFuY2U6IDEwXG4gICAgfSxcbiAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgIHo6IDEwMDAxXG4gIH0pO1xuICBncm91cC5hZGQobGFiZWxSZWN0KTtcbiAgdmFyIGFyYztcbiAgaWYgKG9wdHMuc2hvd1NwaW5uZXIpIHtcbiAgICBhcmMgPSBuZXcgZ3JhcGhpYy5BcmMoe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgc3RhcnRBbmdsZTogLVBJIC8gMixcbiAgICAgICAgZW5kQW5nbGU6IC1QSSAvIDIgKyAwLjEsXG4gICAgICAgIHI6IG9wdHMuc3Bpbm5lclJhZGl1c1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHN0cm9rZTogb3B0cy5jb2xvcixcbiAgICAgICAgbGluZUNhcDogJ3JvdW5kJyxcbiAgICAgICAgbGluZVdpZHRoOiBvcHRzLmxpbmVXaWR0aFxuICAgICAgfSxcbiAgICAgIHpsZXZlbDogb3B0cy56bGV2ZWwsXG4gICAgICB6OiAxMDAwMVxuICAgIH0pO1xuICAgIGFyYy5hbmltYXRlU2hhcGUodHJ1ZSkud2hlbigxMDAwLCB7XG4gICAgICBlbmRBbmdsZTogUEkgKiAzIC8gMlxuICAgIH0pLnN0YXJ0KCdjaXJjdWxhckluT3V0Jyk7XG4gICAgYXJjLmFuaW1hdGVTaGFwZSh0cnVlKS53aGVuKDEwMDAsIHtcbiAgICAgIHN0YXJ0QW5nbGU6IFBJICogMyAvIDJcbiAgICB9KS5kZWxheSgzMDApLnN0YXJ0KCdjaXJjdWxhckluT3V0Jyk7XG4gICAgZ3JvdXAuYWRkKGFyYyk7XG4gIH1cbiAgLy8gSW5qZWN0IHJlc2l6ZVxuICBncm91cC5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRleHRXaWR0aCA9IHRleHRDb250ZW50LmdldEJvdW5kaW5nUmVjdCgpLndpZHRoO1xuICAgIHZhciByID0gb3B0cy5zaG93U3Bpbm5lciA/IG9wdHMuc3Bpbm5lclJhZGl1cyA6IDA7XG4gICAgLy8gY3ggPSAoY29udGFpbmVyV2lkdGggLSBhcmNEaWFtZXRlciAtIHRleHREaXN0YW5jZSAtIHRleHRXaWR0aCkgLyAyXG4gICAgLy8gdGV4dERpc3RhbmNlIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgd2hlbiBib3RoIGFuaW1hdGlvbiBhbmQgdGV4dCBleGlzdFxuICAgIHZhciBjeCA9IChhcGkuZ2V0V2lkdGgoKSAtIHIgKiAyIC0gKG9wdHMuc2hvd1NwaW5uZXIgJiYgdGV4dFdpZHRoID8gMTAgOiAwKSAtIHRleHRXaWR0aCkgLyAyIC0gKG9wdHMuc2hvd1NwaW5uZXIgJiYgdGV4dFdpZHRoID8gMCA6IDUgKyB0ZXh0V2lkdGggLyAyKVxuICAgIC8vIG9ubHkgc2hvdyB0aGUgdGV4dFxuICAgICsgKG9wdHMuc2hvd1NwaW5uZXIgPyAwIDogdGV4dFdpZHRoIC8gMilcbiAgICAvLyBvbmx5IHNob3cgdGhlIHNwaW5uZXJcbiAgICArICh0ZXh0V2lkdGggPyAwIDogcik7XG4gICAgdmFyIGN5ID0gYXBpLmdldEhlaWdodCgpIC8gMjtcbiAgICBvcHRzLnNob3dTcGlubmVyICYmIGFyYy5zZXRTaGFwZSh7XG4gICAgICBjeDogY3gsXG4gICAgICBjeTogY3lcbiAgICB9KTtcbiAgICBsYWJlbFJlY3Quc2V0U2hhcGUoe1xuICAgICAgeDogY3ggLSByLFxuICAgICAgeTogY3kgLSByLFxuICAgICAgd2lkdGg6IHIgKiAyLFxuICAgICAgaGVpZ2h0OiByICogMlxuICAgIH0pO1xuICAgIG1hc2suc2V0U2hhcGUoe1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgIH0pO1xuICB9O1xuICBncm91cC5yZXNpemUoKTtcbiAgcmV0dXJuIGdyb3VwO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14716\n")},14962:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   L: () => (/* binding */ ITEM_STYLE_KEY_MAP),\n/* harmony export */   s: () => (/* binding */ ItemStyleMixin)\n/* harmony export */ });\n/* harmony import */ var _makeStyleMapper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32944);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar ITEM_STYLE_KEY_MAP = [['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['lineDash', 'borderType'], ['lineDashOffset', 'borderDashOffset'], ['lineCap', 'borderCap'], ['lineJoin', 'borderJoin'], ['miterLimit', 'borderMiterLimit']\n// Option decal is in `DecalObject` but style.decal is in `PatternObject`.\n// So do not transfer decal directly.\n];\nvar getItemStyle = (0,_makeStyleMapper_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A)(ITEM_STYLE_KEY_MAP);\nvar ItemStyleMixin = /** @class */function () {\n  function ItemStyleMixin() {}\n  ItemStyleMixin.prototype.getItemStyle = function (excludes, includes) {\n    return getItemStyle(this, excludes, includes);\n  };\n  return ItemStyleMixin;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ5NjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2l0ZW1TdHlsZS5qcz9mZDk3Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IG1ha2VTdHlsZU1hcHBlciBmcm9tICcuL21ha2VTdHlsZU1hcHBlci5qcyc7XG5leHBvcnQgdmFyIElURU1fU1RZTEVfS0VZX01BUCA9IFtbJ2ZpbGwnLCAnY29sb3InXSwgWydzdHJva2UnLCAnYm9yZGVyQ29sb3InXSwgWydsaW5lV2lkdGgnLCAnYm9yZGVyV2lkdGgnXSwgWydvcGFjaXR5J10sIFsnc2hhZG93Qmx1ciddLCBbJ3NoYWRvd09mZnNldFgnXSwgWydzaGFkb3dPZmZzZXRZJ10sIFsnc2hhZG93Q29sb3InXSwgWydsaW5lRGFzaCcsICdib3JkZXJUeXBlJ10sIFsnbGluZURhc2hPZmZzZXQnLCAnYm9yZGVyRGFzaE9mZnNldCddLCBbJ2xpbmVDYXAnLCAnYm9yZGVyQ2FwJ10sIFsnbGluZUpvaW4nLCAnYm9yZGVySm9pbiddLCBbJ21pdGVyTGltaXQnLCAnYm9yZGVyTWl0ZXJMaW1pdCddXG4vLyBPcHRpb24gZGVjYWwgaXMgaW4gYERlY2FsT2JqZWN0YCBidXQgc3R5bGUuZGVjYWwgaXMgaW4gYFBhdHRlcm5PYmplY3RgLlxuLy8gU28gZG8gbm90IHRyYW5zZmVyIGRlY2FsIGRpcmVjdGx5LlxuXTtcbnZhciBnZXRJdGVtU3R5bGUgPSBtYWtlU3R5bGVNYXBwZXIoSVRFTV9TVFlMRV9LRVlfTUFQKTtcbnZhciBJdGVtU3R5bGVNaXhpbiA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEl0ZW1TdHlsZU1peGluKCkge31cbiAgSXRlbVN0eWxlTWl4aW4ucHJvdG90eXBlLmdldEl0ZW1TdHlsZSA9IGZ1bmN0aW9uIChleGNsdWRlcywgaW5jbHVkZXMpIHtcbiAgICByZXR1cm4gZ2V0SXRlbVN0eWxlKHRoaXMsIGV4Y2x1ZGVzLCBpbmNsdWRlcyk7XG4gIH07XG4gIHJldHVybiBJdGVtU3R5bGVNaXhpbjtcbn0oKTtcbmV4cG9ydCB7IEl0ZW1TdHlsZU1peGluIH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14962\n")},15915:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98026);\n/* harmony import */ var _Model_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(43172);\n/* harmony import */ var _util_component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12616);\n/* harmony import */ var _util_clazz_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(30693);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n/* harmony import */ var _util_layout_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(34253);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar inner = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nvar ComponentModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .C6)(ComponentModel, _super);\n  function ComponentModel(option, parentModel, ecModel) {\n    var _this = _super.call(this, option, parentModel, ecModel) || this;\n    _this.uid = _util_component_js__WEBPACK_IMPORTED_MODULE_2__/* .getUID */ .$Q('ec_cpt_model');\n    return _this;\n  }\n  ComponentModel.prototype.init = function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n  };\n  ComponentModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {\n    var layoutMode = _util_layout_js__WEBPACK_IMPORTED_MODULE_3__/* .fetchLayoutMode */ .ad(this);\n    var inputPositionParams = layoutMode ? _util_layout_js__WEBPACK_IMPORTED_MODULE_3__/* .getLayoutParams */ .vs(option) : {};\n    var themeModel = ecModel.getTheme();\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.merge(option, themeModel.get(this.mainType));\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.merge(option, this.getDefaultOption());\n    if (layoutMode) {\n      _util_layout_js__WEBPACK_IMPORTED_MODULE_3__/* .mergeLayoutParam */ .YA(option, inputPositionParams, layoutMode);\n    }\n  };\n  ComponentModel.prototype.mergeOption = function (option, ecModel) {\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.merge(this.option, option, true);\n    var layoutMode = _util_layout_js__WEBPACK_IMPORTED_MODULE_3__/* .fetchLayoutMode */ .ad(this);\n    if (layoutMode) {\n      _util_layout_js__WEBPACK_IMPORTED_MODULE_3__/* .mergeLayoutParam */ .YA(this.option, option, layoutMode);\n    }\n  };\n  /**\r\n   * Called immediately after `init` or `mergeOption` of this instance called.\r\n   */\n  ComponentModel.prototype.optionUpdated = function (newCptOption, isInit) {};\n  /**\r\n   * [How to declare defaultOption]:\r\n   *\r\n   * (A) If using class declaration in typescript (since echarts 5):\r\n   * ```ts\r\n   * import {ComponentOption} from '../model/option.js';\r\n   * export interface XxxOption extends ComponentOption {\r\n   *     aaa: number\r\n   * }\r\n   * export class XxxModel extends Component {\r\n   *     static type = 'xxx';\r\n   *     static defaultOption: XxxOption = {\r\n   *         aaa: 123\r\n   *     }\r\n   * }\r\n   * Component.registerClass(XxxModel);\r\n   * ```\r\n   * ```ts\r\n   * import {inheritDefaultOption} from '../util/component.js';\r\n   * import {XxxModel, XxxOption} from './XxxModel.js';\r\n   * export interface XxxSubOption extends XxxOption {\r\n   *     bbb: number\r\n   * }\r\n   * class XxxSubModel extends XxxModel {\r\n   *     static defaultOption: XxxSubOption = inheritDefaultOption(XxxModel.defaultOption, {\r\n   *         bbb: 456\r\n   *     })\r\n   *     fn() {\r\n   *         let opt = this.getDefaultOption();\r\n   *         // opt is {aaa: 123, bbb: 456}\r\n   *     }\r\n   * }\r\n   * ```\r\n   *\r\n   * (B) If using class extend (previous approach in echarts 3 & 4):\r\n   * ```js\r\n   * let XxxComponent = Component.extend({\r\n   *     defaultOption: {\r\n   *         xx: 123\r\n   *     }\r\n   * })\r\n   * ```\r\n   * ```js\r\n   * let XxxSubComponent = XxxComponent.extend({\r\n   *     defaultOption: {\r\n   *         yy: 456\r\n   *     },\r\n   *     fn: function () {\r\n   *         let opt = this.getDefaultOption();\r\n   *         // opt is {xx: 123, yy: 456}\r\n   *     }\r\n   * })\r\n   * ```\r\n   */\n  ComponentModel.prototype.getDefaultOption = function () {\n    var ctor = this.constructor;\n    // If using class declaration, it is different to travel super class\n    // in legacy env and auto merge defaultOption. So if using class\n    // declaration, defaultOption should be merged manually.\n    if (!(0,_util_clazz_js__WEBPACK_IMPORTED_MODULE_5__/* .isExtendedClass */ ._E)(ctor)) {\n      // When using ts class, defaultOption must be declared as static.\n      return ctor.defaultOption;\n    }\n    // FIXME: remove this approach?\n    var fields = inner(this);\n    if (!fields.defaultOption) {\n      var optList = [];\n      var clz = ctor;\n      while (clz) {\n        var opt = clz.prototype.defaultOption;\n        opt && optList.push(opt);\n        clz = clz.superClass;\n      }\n      var defaultOption = {};\n      for (var i = optList.length - 1; i >= 0; i--) {\n        defaultOption = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.merge(defaultOption, optList[i], true);\n      }\n      fields.defaultOption = defaultOption;\n    }\n    return fields.defaultOption;\n  };\n  /**\r\n   * Notice: always force to input param `useDefault` in case that forget to consider it.\r\n   * The same behavior as `modelUtil.parseFinder`.\r\n   *\r\n   * @param useDefault In many cases like series refer axis and axis refer grid,\r\n   *        If axis index / axis id not specified, use the first target as default.\r\n   *        In other cases like dataZoom refer axis, if not specified, measn no refer.\r\n   */\n  ComponentModel.prototype.getReferringComponents = function (mainType, opt) {\n    var indexKey = mainType + 'Index';\n    var idKey = mainType + 'Id';\n    return (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .queryReferringComponents */ .JO)(this.ecModel, mainType, {\n      index: this.get(indexKey, true),\n      id: this.get(idKey, true)\n    }, opt);\n  };\n  ComponentModel.prototype.getBoxLayoutParams = function () {\n    // Consider itself having box layout configs.\n    var boxLayoutModel = this;\n    return {\n      left: boxLayoutModel.get('left'),\n      top: boxLayoutModel.get('top'),\n      right: boxLayoutModel.get('right'),\n      bottom: boxLayoutModel.get('bottom'),\n      width: boxLayoutModel.get('width'),\n      height: boxLayoutModel.get('height')\n    };\n  };\n  /**\r\n   * Get key for zlevel.\r\n   * If developers don't configure zlevel. We will assign zlevel to series based on the key.\r\n   * For example, lines with trail effect and progressive series will in an individual zlevel.\r\n   */\n  ComponentModel.prototype.getZLevelKey = function () {\n    return '';\n  };\n  ComponentModel.prototype.setZLevel = function (zlevel) {\n    this.option.zlevel = zlevel;\n  };\n  ComponentModel.protoInitialize = function () {\n    var proto = ComponentModel.prototype;\n    proto.type = 'component';\n    proto.id = '';\n    proto.name = '';\n    proto.mainType = '';\n    proto.subType = '';\n    proto.componentIndex = 0;\n  }();\n  return ComponentModel;\n}(_Model_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A);\n(0,_util_clazz_js__WEBPACK_IMPORTED_MODULE_5__/* .mountExtend */ .q7)(ComponentModel, _Model_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A);\n(0,_util_clazz_js__WEBPACK_IMPORTED_MODULE_5__/* .enableClassManagement */ .tQ)(ComponentModel);\n_util_component_js__WEBPACK_IMPORTED_MODULE_2__/* .enableSubTypeDefaulter */ .A6(ComponentModel);\n_util_component_js__WEBPACK_IMPORTED_MODULE_2__/* .enableTopologicalTravel */ .vf(ComponentModel, getDependencies);\nfunction getDependencies(componentType) {\n  var deps = [];\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.each(ComponentModel.getClassesByMainType(componentType), function (clz) {\n    deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);\n  });\n  // Ensure main type.\n  deps = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.map(deps, function (type) {\n    return (0,_util_clazz_js__WEBPACK_IMPORTED_MODULE_5__/* .parseClassType */ .CC)(type).main;\n  });\n  // Hack dataset for convenience.\n  if (componentType !== 'dataset' && zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.indexOf(deps, 'dataset') <= 0) {\n    deps.unshift('dataset');\n  }\n  return deps;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ComponentModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU5MTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvQ29tcG9uZW50LmpzPzYyMzkiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IE1vZGVsIGZyb20gJy4vTW9kZWwuanMnO1xuaW1wb3J0ICogYXMgY29tcG9uZW50VXRpbCBmcm9tICcuLi91dGlsL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgeyBlbmFibGVDbGFzc01hbmFnZW1lbnQsIHBhcnNlQ2xhc3NUeXBlLCBpc0V4dGVuZGVkQ2xhc3MsIG1vdW50RXh0ZW5kIH0gZnJvbSAnLi4vdXRpbC9jbGF6ei5qcyc7XG5pbXBvcnQgeyBtYWtlSW5uZXIsIHF1ZXJ5UmVmZXJyaW5nQ29tcG9uZW50cyB9IGZyb20gJy4uL3V0aWwvbW9kZWwuanMnO1xuaW1wb3J0ICogYXMgbGF5b3V0IGZyb20gJy4uL3V0aWwvbGF5b3V0LmpzJztcbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xudmFyIENvbXBvbmVudE1vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKENvbXBvbmVudE1vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBDb21wb25lbnRNb2RlbChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCkgfHwgdGhpcztcbiAgICBfdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgnZWNfY3B0X21vZGVsJyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIENvbXBvbmVudE1vZGVsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpIHtcbiAgICB0aGlzLm1lcmdlRGVmYXVsdEFuZFRoZW1lKG9wdGlvbiwgZWNNb2RlbCk7XG4gIH07XG4gIENvbXBvbmVudE1vZGVsLnByb3RvdHlwZS5tZXJnZURlZmF1bHRBbmRUaGVtZSA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICB2YXIgbGF5b3V0TW9kZSA9IGxheW91dC5mZXRjaExheW91dE1vZGUodGhpcyk7XG4gICAgdmFyIGlucHV0UG9zaXRpb25QYXJhbXMgPSBsYXlvdXRNb2RlID8gbGF5b3V0LmdldExheW91dFBhcmFtcyhvcHRpb24pIDoge307XG4gICAgdmFyIHRoZW1lTW9kZWwgPSBlY01vZGVsLmdldFRoZW1lKCk7XG4gICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhlbWVNb2RlbC5nZXQodGhpcy5tYWluVHlwZSkpO1xuICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTtcbiAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW0ob3B0aW9uLCBpbnB1dFBvc2l0aW9uUGFyYW1zLCBsYXlvdXRNb2RlKTtcbiAgICB9XG4gIH07XG4gIENvbXBvbmVudE1vZGVsLnByb3RvdHlwZS5tZXJnZU9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICB6clV0aWwubWVyZ2UodGhpcy5vcHRpb24sIG9wdGlvbiwgdHJ1ZSk7XG4gICAgdmFyIGxheW91dE1vZGUgPSBsYXlvdXQuZmV0Y2hMYXlvdXRNb2RlKHRoaXMpO1xuICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbSh0aGlzLm9wdGlvbiwgb3B0aW9uLCBsYXlvdXRNb2RlKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIENhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBgaW5pdGAgb3IgYG1lcmdlT3B0aW9uYCBvZiB0aGlzIGluc3RhbmNlIGNhbGxlZC5cclxuICAgKi9cbiAgQ29tcG9uZW50TW9kZWwucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQgPSBmdW5jdGlvbiAobmV3Q3B0T3B0aW9uLCBpc0luaXQpIHt9O1xuICAvKipcclxuICAgKiBbSG93IHRvIGRlY2xhcmUgZGVmYXVsdE9wdGlvbl06XHJcbiAgICpcclxuICAgKiAoQSkgSWYgdXNpbmcgY2xhc3MgZGVjbGFyYXRpb24gaW4gdHlwZXNjcmlwdCAoc2luY2UgZWNoYXJ0cyA1KTpcclxuICAgKiBgYGB0c1xyXG4gICAqIGltcG9ydCB7Q29tcG9uZW50T3B0aW9ufSBmcm9tICcuLi9tb2RlbC9vcHRpb24uanMnO1xyXG4gICAqIGV4cG9ydCBpbnRlcmZhY2UgWHh4T3B0aW9uIGV4dGVuZHMgQ29tcG9uZW50T3B0aW9uIHtcclxuICAgKiAgICAgYWFhOiBudW1iZXJcclxuICAgKiB9XHJcbiAgICogZXhwb3J0IGNsYXNzIFh4eE1vZGVsIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgKiAgICAgc3RhdGljIHR5cGUgPSAneHh4JztcclxuICAgKiAgICAgc3RhdGljIGRlZmF1bHRPcHRpb246IFh4eE9wdGlvbiA9IHtcclxuICAgKiAgICAgICAgIGFhYTogMTIzXHJcbiAgICogICAgIH1cclxuICAgKiB9XHJcbiAgICogQ29tcG9uZW50LnJlZ2lzdGVyQ2xhc3MoWHh4TW9kZWwpO1xyXG4gICAqIGBgYFxyXG4gICAqIGBgYHRzXHJcbiAgICogaW1wb3J0IHtpbmhlcml0RGVmYXVsdE9wdGlvbn0gZnJvbSAnLi4vdXRpbC9jb21wb25lbnQuanMnO1xyXG4gICAqIGltcG9ydCB7WHh4TW9kZWwsIFh4eE9wdGlvbn0gZnJvbSAnLi9YeHhNb2RlbC5qcyc7XHJcbiAgICogZXhwb3J0IGludGVyZmFjZSBYeHhTdWJPcHRpb24gZXh0ZW5kcyBYeHhPcHRpb24ge1xyXG4gICAqICAgICBiYmI6IG51bWJlclxyXG4gICAqIH1cclxuICAgKiBjbGFzcyBYeHhTdWJNb2RlbCBleHRlbmRzIFh4eE1vZGVsIHtcclxuICAgKiAgICAgc3RhdGljIGRlZmF1bHRPcHRpb246IFh4eFN1Yk9wdGlvbiA9IGluaGVyaXREZWZhdWx0T3B0aW9uKFh4eE1vZGVsLmRlZmF1bHRPcHRpb24sIHtcclxuICAgKiAgICAgICAgIGJiYjogNDU2XHJcbiAgICogICAgIH0pXHJcbiAgICogICAgIGZuKCkge1xyXG4gICAqICAgICAgICAgbGV0IG9wdCA9IHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpO1xyXG4gICAqICAgICAgICAgLy8gb3B0IGlzIHthYWE6IDEyMywgYmJiOiA0NTZ9XHJcbiAgICogICAgIH1cclxuICAgKiB9XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiAoQikgSWYgdXNpbmcgY2xhc3MgZXh0ZW5kIChwcmV2aW91cyBhcHByb2FjaCBpbiBlY2hhcnRzIDMgJiA0KTpcclxuICAgKiBgYGBqc1xyXG4gICAqIGxldCBYeHhDb21wb25lbnQgPSBDb21wb25lbnQuZXh0ZW5kKHtcclxuICAgKiAgICAgZGVmYXVsdE9wdGlvbjoge1xyXG4gICAqICAgICAgICAgeHg6IDEyM1xyXG4gICAqICAgICB9XHJcbiAgICogfSlcclxuICAgKiBgYGBcclxuICAgKiBgYGBqc1xyXG4gICAqIGxldCBYeHhTdWJDb21wb25lbnQgPSBYeHhDb21wb25lbnQuZXh0ZW5kKHtcclxuICAgKiAgICAgZGVmYXVsdE9wdGlvbjoge1xyXG4gICAqICAgICAgICAgeXk6IDQ1NlxyXG4gICAqICAgICB9LFxyXG4gICAqICAgICBmbjogZnVuY3Rpb24gKCkge1xyXG4gICAqICAgICAgICAgbGV0IG9wdCA9IHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpO1xyXG4gICAqICAgICAgICAgLy8gb3B0IGlzIHt4eDogMTIzLCB5eTogNDU2fVxyXG4gICAqICAgICB9XHJcbiAgICogfSlcclxuICAgKiBgYGBcclxuICAgKi9cbiAgQ29tcG9uZW50TW9kZWwucHJvdG90eXBlLmdldERlZmF1bHRPcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIC8vIElmIHVzaW5nIGNsYXNzIGRlY2xhcmF0aW9uLCBpdCBpcyBkaWZmZXJlbnQgdG8gdHJhdmVsIHN1cGVyIGNsYXNzXG4gICAgLy8gaW4gbGVnYWN5IGVudiBhbmQgYXV0byBtZXJnZSBkZWZhdWx0T3B0aW9uLiBTbyBpZiB1c2luZyBjbGFzc1xuICAgIC8vIGRlY2xhcmF0aW9uLCBkZWZhdWx0T3B0aW9uIHNob3VsZCBiZSBtZXJnZWQgbWFudWFsbHkuXG4gICAgaWYgKCFpc0V4dGVuZGVkQ2xhc3MoY3RvcikpIHtcbiAgICAgIC8vIFdoZW4gdXNpbmcgdHMgY2xhc3MsIGRlZmF1bHRPcHRpb24gbXVzdCBiZSBkZWNsYXJlZCBhcyBzdGF0aWMuXG4gICAgICByZXR1cm4gY3Rvci5kZWZhdWx0T3B0aW9uO1xuICAgIH1cbiAgICAvLyBGSVhNRTogcmVtb3ZlIHRoaXMgYXBwcm9hY2g/XG4gICAgdmFyIGZpZWxkcyA9IGlubmVyKHRoaXMpO1xuICAgIGlmICghZmllbGRzLmRlZmF1bHRPcHRpb24pIHtcbiAgICAgIHZhciBvcHRMaXN0ID0gW107XG4gICAgICB2YXIgY2x6ID0gY3RvcjtcbiAgICAgIHdoaWxlIChjbHopIHtcbiAgICAgICAgdmFyIG9wdCA9IGNsei5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbjtcbiAgICAgICAgb3B0ICYmIG9wdExpc3QucHVzaChvcHQpO1xuICAgICAgICBjbHogPSBjbHouc3VwZXJDbGFzcztcbiAgICAgIH1cbiAgICAgIHZhciBkZWZhdWx0T3B0aW9uID0ge307XG4gICAgICBmb3IgKHZhciBpID0gb3B0TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBkZWZhdWx0T3B0aW9uID0genJVdGlsLm1lcmdlKGRlZmF1bHRPcHRpb24sIG9wdExpc3RbaV0sIHRydWUpO1xuICAgICAgfVxuICAgICAgZmllbGRzLmRlZmF1bHRPcHRpb24gPSBkZWZhdWx0T3B0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzLmRlZmF1bHRPcHRpb247XG4gIH07XG4gIC8qKlxyXG4gICAqIE5vdGljZTogYWx3YXlzIGZvcmNlIHRvIGlucHV0IHBhcmFtIGB1c2VEZWZhdWx0YCBpbiBjYXNlIHRoYXQgZm9yZ2V0IHRvIGNvbnNpZGVyIGl0LlxyXG4gICAqIFRoZSBzYW1lIGJlaGF2aW9yIGFzIGBtb2RlbFV0aWwucGFyc2VGaW5kZXJgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHVzZURlZmF1bHQgSW4gbWFueSBjYXNlcyBsaWtlIHNlcmllcyByZWZlciBheGlzIGFuZCBheGlzIHJlZmVyIGdyaWQsXHJcbiAgICogICAgICAgIElmIGF4aXMgaW5kZXggLyBheGlzIGlkIG5vdCBzcGVjaWZpZWQsIHVzZSB0aGUgZmlyc3QgdGFyZ2V0IGFzIGRlZmF1bHQuXHJcbiAgICogICAgICAgIEluIG90aGVyIGNhc2VzIGxpa2UgZGF0YVpvb20gcmVmZXIgYXhpcywgaWYgbm90IHNwZWNpZmllZCwgbWVhc24gbm8gcmVmZXIuXHJcbiAgICovXG4gIENvbXBvbmVudE1vZGVsLnByb3RvdHlwZS5nZXRSZWZlcnJpbmdDb21wb25lbnRzID0gZnVuY3Rpb24gKG1haW5UeXBlLCBvcHQpIHtcbiAgICB2YXIgaW5kZXhLZXkgPSBtYWluVHlwZSArICdJbmRleCc7XG4gICAgdmFyIGlkS2V5ID0gbWFpblR5cGUgKyAnSWQnO1xuICAgIHJldHVybiBxdWVyeVJlZmVycmluZ0NvbXBvbmVudHModGhpcy5lY01vZGVsLCBtYWluVHlwZSwge1xuICAgICAgaW5kZXg6IHRoaXMuZ2V0KGluZGV4S2V5LCB0cnVlKSxcbiAgICAgIGlkOiB0aGlzLmdldChpZEtleSwgdHJ1ZSlcbiAgICB9LCBvcHQpO1xuICB9O1xuICBDb21wb25lbnRNb2RlbC5wcm90b3R5cGUuZ2V0Qm94TGF5b3V0UGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIENvbnNpZGVyIGl0c2VsZiBoYXZpbmcgYm94IGxheW91dCBjb25maWdzLlxuICAgIHZhciBib3hMYXlvdXRNb2RlbCA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGJveExheW91dE1vZGVsLmdldCgnbGVmdCcpLFxuICAgICAgdG9wOiBib3hMYXlvdXRNb2RlbC5nZXQoJ3RvcCcpLFxuICAgICAgcmlnaHQ6IGJveExheW91dE1vZGVsLmdldCgncmlnaHQnKSxcbiAgICAgIGJvdHRvbTogYm94TGF5b3V0TW9kZWwuZ2V0KCdib3R0b20nKSxcbiAgICAgIHdpZHRoOiBib3hMYXlvdXRNb2RlbC5nZXQoJ3dpZHRoJyksXG4gICAgICBoZWlnaHQ6IGJveExheW91dE1vZGVsLmdldCgnaGVpZ2h0JylcbiAgICB9O1xuICB9O1xuICAvKipcclxuICAgKiBHZXQga2V5IGZvciB6bGV2ZWwuXHJcbiAgICogSWYgZGV2ZWxvcGVycyBkb24ndCBjb25maWd1cmUgemxldmVsLiBXZSB3aWxsIGFzc2lnbiB6bGV2ZWwgdG8gc2VyaWVzIGJhc2VkIG9uIHRoZSBrZXkuXHJcbiAgICogRm9yIGV4YW1wbGUsIGxpbmVzIHdpdGggdHJhaWwgZWZmZWN0IGFuZCBwcm9ncmVzc2l2ZSBzZXJpZXMgd2lsbCBpbiBhbiBpbmRpdmlkdWFsIHpsZXZlbC5cclxuICAgKi9cbiAgQ29tcG9uZW50TW9kZWwucHJvdG90eXBlLmdldFpMZXZlbEtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH07XG4gIENvbXBvbmVudE1vZGVsLnByb3RvdHlwZS5zZXRaTGV2ZWwgPSBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgdGhpcy5vcHRpb24uemxldmVsID0gemxldmVsO1xuICB9O1xuICBDb21wb25lbnRNb2RlbC5wcm90b0luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3RvID0gQ29tcG9uZW50TW9kZWwucHJvdG90eXBlO1xuICAgIHByb3RvLnR5cGUgPSAnY29tcG9uZW50JztcbiAgICBwcm90by5pZCA9ICcnO1xuICAgIHByb3RvLm5hbWUgPSAnJztcbiAgICBwcm90by5tYWluVHlwZSA9ICcnO1xuICAgIHByb3RvLnN1YlR5cGUgPSAnJztcbiAgICBwcm90by5jb21wb25lbnRJbmRleCA9IDA7XG4gIH0oKTtcbiAgcmV0dXJuIENvbXBvbmVudE1vZGVsO1xufShNb2RlbCk7XG5tb3VudEV4dGVuZChDb21wb25lbnRNb2RlbCwgTW9kZWwpO1xuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KENvbXBvbmVudE1vZGVsKTtcbmNvbXBvbmVudFV0aWwuZW5hYmxlU3ViVHlwZURlZmF1bHRlcihDb21wb25lbnRNb2RlbCk7XG5jb21wb25lbnRVdGlsLmVuYWJsZVRvcG9sb2dpY2FsVHJhdmVsKENvbXBvbmVudE1vZGVsLCBnZXREZXBlbmRlbmNpZXMpO1xuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKGNvbXBvbmVudFR5cGUpIHtcbiAgdmFyIGRlcHMgPSBbXTtcbiAgenJVdGlsLmVhY2goQ29tcG9uZW50TW9kZWwuZ2V0Q2xhc3Nlc0J5TWFpblR5cGUoY29tcG9uZW50VHlwZSksIGZ1bmN0aW9uIChjbHopIHtcbiAgICBkZXBzID0gZGVwcy5jb25jYXQoY2x6LmRlcGVuZGVuY2llcyB8fCBjbHoucHJvdG90eXBlLmRlcGVuZGVuY2llcyB8fCBbXSk7XG4gIH0pO1xuICAvLyBFbnN1cmUgbWFpbiB0eXBlLlxuICBkZXBzID0genJVdGlsLm1hcChkZXBzLCBmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiBwYXJzZUNsYXNzVHlwZSh0eXBlKS5tYWluO1xuICB9KTtcbiAgLy8gSGFjayBkYXRhc2V0IGZvciBjb252ZW5pZW5jZS5cbiAgaWYgKGNvbXBvbmVudFR5cGUgIT09ICdkYXRhc2V0JyAmJiB6clV0aWwuaW5kZXhPZihkZXBzLCAnZGF0YXNldCcpIDw9IDApIHtcbiAgICBkZXBzLnVuc2hpZnQoJ2RhdGFzZXQnKTtcbiAgfVxuICByZXR1cm4gZGVwcztcbn1cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudE1vZGVsOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15915\n")},16884:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ createLegacyDataSelectAction),\n/* harmony export */   l: () => (/* binding */ handleLegacySelectEvents)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n// Legacy data selection action.\n// Includes: pieSelect, pieUnSelect, pieToggleSelect, mapSelect, mapUnSelect, mapToggleSelect\nfunction createLegacyDataSelectAction(seriesType, ecRegisterAction) {\n  function getSeriesIndices(ecModel, payload) {\n    var seriesIndices = [];\n    ecModel.eachComponent({\n      mainType: 'series',\n      subType: seriesType,\n      query: payload\n    }, function (seriesModel) {\n      seriesIndices.push(seriesModel.seriesIndex);\n    });\n    return seriesIndices;\n  }\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)([[seriesType + 'ToggleSelect', 'toggleSelect'], [seriesType + 'Select', 'select'], [seriesType + 'UnSelect', 'unselect']], function (eventsMap) {\n    ecRegisterAction(eventsMap[0], function (payload, ecModel, api) {\n      payload = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend)({}, payload);\n      if (false) {}\n      api.dispatchAction((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend)(payload, {\n        type: eventsMap[1],\n        seriesIndex: getSeriesIndices(ecModel, payload)\n      }));\n    });\n  });\n}\nfunction handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {\n  var legacyEventName = type + eventPostfix;\n  if (!ecIns.isSilent(legacyEventName)) {\n    if (false) {}\n    ecModel.eachComponent({\n      mainType: 'series',\n      subType: 'pie'\n    }, function (seriesModel) {\n      var seriesIndex = seriesModel.seriesIndex;\n      var selectedMap = seriesModel.option.selectedMap;\n      var selected = payload.selected;\n      for (var i = 0; i < selected.length; i++) {\n        if (selected[i].seriesIndex === seriesIndex) {\n          var data = seriesModel.getData();\n          var dataIndex = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .queryDataIndex */ .le)(data, payload.fromActionPayload);\n          ecIns.trigger(legacyEventName, {\n            type: legacyEventName,\n            seriesId: seriesModel.id,\n            name: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),\n            selected: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString)(selectedMap) ? selectedMap : (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend)({}, selectedMap)\n          });\n        }\n      }\n    });\n  }\n}\nfunction handleLegacySelectEvents(messageCenter, ecIns, api) {\n  messageCenter.on('selectchanged', function (params) {\n    var ecModel = api.getModel();\n    if (params.isFromClick) {\n      handleSeriesLegacySelectEvents('map', 'selectchanged', ecIns, ecModel, params);\n      handleSeriesLegacySelectEvents('pie', 'selectchanged', ecIns, ecModel, params);\n    } else if (params.fromAction === 'select') {\n      handleSeriesLegacySelectEvents('map', 'selected', ecIns, ecModel, params);\n      handleSeriesLegacySelectEvents('pie', 'selected', ecIns, ecModel, params);\n    } else if (params.fromAction === 'unselect') {\n      handleSeriesLegacySelectEvents('map', 'unselected', ecIns, ecModel, params);\n      handleSeriesLegacySelectEvents('pie', 'unselected', ecIns, ecModel, params);\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY4ODQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbGVnYWN5L2RhdGFTZWxlY3RBY3Rpb24uanM/YWMyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGV4dGVuZCwgZWFjaCwgaXNBcnJheSwgaXNTdHJpbmcgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRlUmVwbGFjZUxvZywgZGVwcmVjYXRlTG9nIH0gZnJvbSAnLi4vdXRpbC9sb2cuanMnO1xuaW1wb3J0IHsgcXVlcnlEYXRhSW5kZXggfSBmcm9tICcuLi91dGlsL21vZGVsLmpzJztcbi8vIExlZ2FjeSBkYXRhIHNlbGVjdGlvbiBhY3Rpb24uXG4vLyBJbmNsdWRlczogcGllU2VsZWN0LCBwaWVVblNlbGVjdCwgcGllVG9nZ2xlU2VsZWN0LCBtYXBTZWxlY3QsIG1hcFVuU2VsZWN0LCBtYXBUb2dnbGVTZWxlY3RcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMZWdhY3lEYXRhU2VsZWN0QWN0aW9uKHNlcmllc1R5cGUsIGVjUmVnaXN0ZXJBY3Rpb24pIHtcbiAgZnVuY3Rpb24gZ2V0U2VyaWVzSW5kaWNlcyhlY01vZGVsLCBwYXlsb2FkKSB7XG4gICAgdmFyIHNlcmllc0luZGljZXMgPSBbXTtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6ICdzZXJpZXMnLFxuICAgICAgc3ViVHlwZTogc2VyaWVzVHlwZSxcbiAgICAgIHF1ZXJ5OiBwYXlsb2FkXG4gICAgfSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICBzZXJpZXNJbmRpY2VzLnB1c2goc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXgpO1xuICAgIH0pO1xuICAgIHJldHVybiBzZXJpZXNJbmRpY2VzO1xuICB9XG4gIGVhY2goW1tzZXJpZXNUeXBlICsgJ1RvZ2dsZVNlbGVjdCcsICd0b2dnbGVTZWxlY3QnXSwgW3Nlcmllc1R5cGUgKyAnU2VsZWN0JywgJ3NlbGVjdCddLCBbc2VyaWVzVHlwZSArICdVblNlbGVjdCcsICd1bnNlbGVjdCddXSwgZnVuY3Rpb24gKGV2ZW50c01hcCkge1xuICAgIGVjUmVnaXN0ZXJBY3Rpb24oZXZlbnRzTWFwWzBdLCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICBwYXlsb2FkID0gZXh0ZW5kKHt9LCBwYXlsb2FkKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGRlcHJlY2F0ZVJlcGxhY2VMb2cocGF5bG9hZC50eXBlLCBldmVudHNNYXBbMV0pO1xuICAgICAgfVxuICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKGV4dGVuZChwYXlsb2FkLCB7XG4gICAgICAgIHR5cGU6IGV2ZW50c01hcFsxXSxcbiAgICAgICAgc2VyaWVzSW5kZXg6IGdldFNlcmllc0luZGljZXMoZWNNb2RlbCwgcGF5bG9hZClcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVTZXJpZXNMZWdhY3lTZWxlY3RFdmVudHModHlwZSwgZXZlbnRQb3N0Zml4LCBlY0lucywgZWNNb2RlbCwgcGF5bG9hZCkge1xuICB2YXIgbGVnYWN5RXZlbnROYW1lID0gdHlwZSArIGV2ZW50UG9zdGZpeDtcbiAgaWYgKCFlY0lucy5pc1NpbGVudChsZWdhY3lFdmVudE5hbWUpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlcHJlY2F0ZUxvZyhcImV2ZW50IFwiICsgbGVnYWN5RXZlbnROYW1lICsgXCIgaXMgZGVwcmVjYXRlZC5cIik7XG4gICAgfVxuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICBtYWluVHlwZTogJ3NlcmllcycsXG4gICAgICBzdWJUeXBlOiAncGllJ1xuICAgIH0sIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIHNlcmllc0luZGV4ID0gc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXg7XG4gICAgICB2YXIgc2VsZWN0ZWRNYXAgPSBzZXJpZXNNb2RlbC5vcHRpb24uc2VsZWN0ZWRNYXA7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBwYXlsb2FkLnNlbGVjdGVkO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZWN0ZWRbaV0uc2VyaWVzSW5kZXggPT09IHNlcmllc0luZGV4KSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgdmFyIGRhdGFJbmRleCA9IHF1ZXJ5RGF0YUluZGV4KGRhdGEsIHBheWxvYWQuZnJvbUFjdGlvblBheWxvYWQpO1xuICAgICAgICAgIGVjSW5zLnRyaWdnZXIobGVnYWN5RXZlbnROYW1lLCB7XG4gICAgICAgICAgICB0eXBlOiBsZWdhY3lFdmVudE5hbWUsXG4gICAgICAgICAgICBzZXJpZXNJZDogc2VyaWVzTW9kZWwuaWQsXG4gICAgICAgICAgICBuYW1lOiBpc0FycmF5KGRhdGFJbmRleCkgPyBkYXRhLmdldE5hbWUoZGF0YUluZGV4WzBdKSA6IGRhdGEuZ2V0TmFtZShkYXRhSW5kZXgpLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IGlzU3RyaW5nKHNlbGVjdGVkTWFwKSA/IHNlbGVjdGVkTWFwIDogZXh0ZW5kKHt9LCBzZWxlY3RlZE1hcClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlTGVnYWN5U2VsZWN0RXZlbnRzKG1lc3NhZ2VDZW50ZXIsIGVjSW5zLCBhcGkpIHtcbiAgbWVzc2FnZUNlbnRlci5vbignc2VsZWN0Y2hhbmdlZCcsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgZWNNb2RlbCA9IGFwaS5nZXRNb2RlbCgpO1xuICAgIGlmIChwYXJhbXMuaXNGcm9tQ2xpY2spIHtcbiAgICAgIGhhbmRsZVNlcmllc0xlZ2FjeVNlbGVjdEV2ZW50cygnbWFwJywgJ3NlbGVjdGNoYW5nZWQnLCBlY0lucywgZWNNb2RlbCwgcGFyYW1zKTtcbiAgICAgIGhhbmRsZVNlcmllc0xlZ2FjeVNlbGVjdEV2ZW50cygncGllJywgJ3NlbGVjdGNoYW5nZWQnLCBlY0lucywgZWNNb2RlbCwgcGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5mcm9tQWN0aW9uID09PSAnc2VsZWN0Jykge1xuICAgICAgaGFuZGxlU2VyaWVzTGVnYWN5U2VsZWN0RXZlbnRzKCdtYXAnLCAnc2VsZWN0ZWQnLCBlY0lucywgZWNNb2RlbCwgcGFyYW1zKTtcbiAgICAgIGhhbmRsZVNlcmllc0xlZ2FjeVNlbGVjdEV2ZW50cygncGllJywgJ3NlbGVjdGVkJywgZWNJbnMsIGVjTW9kZWwsIHBhcmFtcyk7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMuZnJvbUFjdGlvbiA9PT0gJ3Vuc2VsZWN0Jykge1xuICAgICAgaGFuZGxlU2VyaWVzTGVnYWN5U2VsZWN0RXZlbnRzKCdtYXAnLCAndW5zZWxlY3RlZCcsIGVjSW5zLCBlY01vZGVsLCBwYXJhbXMpO1xuICAgICAgaGFuZGxlU2VyaWVzTGVnYWN5U2VsZWN0RXZlbnRzKCdwaWUnLCAndW5zZWxlY3RlZCcsIGVjSW5zLCBlY01vZGVsLCBwYXJhbXMpO1xuICAgIH1cbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16884\n")},18550:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _Scale_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(28613);\n/* harmony import */ var _data_OrdinalMeta_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15135);\n/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(67071);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * Linear continuous scale\r\n * http://en.wikipedia.org/wiki/Level_of_measurement\r\n */\n// FIXME only one data\n\n\n\n\nvar OrdinalScale = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(OrdinalScale, _super);\n  function OrdinalScale(setting) {\n    var _this = _super.call(this, setting) || this;\n    _this.type = \'ordinal\';\n    var ordinalMeta = _this.getSetting(\'ordinalMeta\');\n    // Caution: Should not use instanceof, consider ec-extensions using\n    // import approach to get OrdinalMeta class.\n    if (!ordinalMeta) {\n      ordinalMeta = new _data_OrdinalMeta_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A({});\n    }\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(ordinalMeta)) {\n      ordinalMeta = new _data_OrdinalMeta_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A({\n        categories: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(ordinalMeta, function (item) {\n          return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(item) ? item.value : item;\n        })\n      });\n    }\n    _this._ordinalMeta = ordinalMeta;\n    _this._extent = _this.getSetting(\'extent\') || [0, ordinalMeta.categories.length - 1];\n    return _this;\n  }\n  OrdinalScale.prototype.parse = function (val) {\n    // Caution: Math.round(null) will return `0` rather than `NaN`\n    if (val == null) {\n      return NaN;\n    }\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isString)(val) ? this._ordinalMeta.getOrdinal(val)\n    // val might be float.\n    : Math.round(val);\n  };\n  OrdinalScale.prototype.contain = function (rank) {\n    rank = this.parse(rank);\n    return _helper_js__WEBPACK_IMPORTED_MODULE_3__/* .contain */ .lP(rank, this._extent) && this._ordinalMeta.categories[rank] != null;\n  };\n  /**\r\n   * Normalize given rank or name to linear [0, 1]\r\n   * @param val raw ordinal number.\r\n   * @return normalized value in [0, 1].\r\n   */\n  OrdinalScale.prototype.normalize = function (val) {\n    val = this._getTickNumber(this.parse(val));\n    return _helper_js__WEBPACK_IMPORTED_MODULE_3__/* .normalize */ .S8(val, this._extent);\n  };\n  /**\r\n   * @param val normalized value in [0, 1].\r\n   * @return raw ordinal number.\r\n   */\n  OrdinalScale.prototype.scale = function (val) {\n    val = Math.round(_helper_js__WEBPACK_IMPORTED_MODULE_3__/* .scale */ .hs(val, this._extent));\n    return this.getRawOrdinalNumber(val);\n  };\n  OrdinalScale.prototype.getTicks = function () {\n    var ticks = [];\n    var extent = this._extent;\n    var rank = extent[0];\n    while (rank <= extent[1]) {\n      ticks.push({\n        value: rank\n      });\n      rank++;\n    }\n    return ticks;\n  };\n  OrdinalScale.prototype.getMinorTicks = function (splitNumber) {\n    // Not support.\n    return;\n  };\n  /**\r\n   * @see `Ordinal[\'_ordinalNumbersByTick\']`\r\n   */\n  OrdinalScale.prototype.setSortInfo = function (info) {\n    if (info == null) {\n      this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;\n      return;\n    }\n    var infoOrdinalNumbers = info.ordinalNumbers;\n    var ordinalsByTick = this._ordinalNumbersByTick = [];\n    var ticksByOrdinal = this._ticksByOrdinalNumber = [];\n    // Unnecessary support negative tick in `realtimeSort`.\n    var tickNum = 0;\n    var allCategoryLen = this._ordinalMeta.categories.length;\n    for (var len = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len; ++tickNum) {\n      var ordinalNumber = infoOrdinalNumbers[tickNum];\n      ordinalsByTick[tickNum] = ordinalNumber;\n      ticksByOrdinal[ordinalNumber] = tickNum;\n    }\n    // Handle that `series.data` only covers part of the `axis.category.data`.\n    var unusedOrdinal = 0;\n    for (; tickNum < allCategoryLen; ++tickNum) {\n      while (ticksByOrdinal[unusedOrdinal] != null) {\n        unusedOrdinal++;\n      }\n      ;\n      ordinalsByTick.push(unusedOrdinal);\n      ticksByOrdinal[unusedOrdinal] = tickNum;\n    }\n  };\n  OrdinalScale.prototype._getTickNumber = function (ordinal) {\n    var ticksByOrdinalNumber = this._ticksByOrdinalNumber;\n    // also support ordinal out of range of `ordinalMeta.categories.length`,\n    // where ordinal numbers are used as tick value directly.\n    return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;\n  };\n  /**\r\n   * @usage\r\n   * ```js\r\n   * const ordinalNumber = ordinalScale.getRawOrdinalNumber(tickVal);\r\n   *\r\n   * // case0\r\n   * const rawOrdinalValue = axisModel.getCategories()[ordinalNumber];\r\n   * // case1\r\n   * const rawOrdinalValue = this._ordinalMeta.categories[ordinalNumber];\r\n   * // case2\r\n   * const coord = axis.dataToCoord(ordinalNumber);\r\n   * ```\r\n   *\r\n   * @param {OrdinalNumber} tickNumber index of display\r\n   */\n  OrdinalScale.prototype.getRawOrdinalNumber = function (tickNumber) {\n    var ordinalNumbersByTick = this._ordinalNumbersByTick;\n    // tickNumber may be out of range, e.g., when axis max is larger than `ordinalMeta.categories.length`.,\n    // where ordinal numbers are used as tick value directly.\n    return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;\n  };\n  /**\r\n   * Get item on tick\r\n   */\n  OrdinalScale.prototype.getLabel = function (tick) {\n    if (!this.isBlank()) {\n      var ordinalNumber = this.getRawOrdinalNumber(tick.value);\n      var cateogry = this._ordinalMeta.categories[ordinalNumber];\n      // Note that if no data, ordinalMeta.categories is an empty array.\n      // Return empty if it\'s not exist.\n      return cateogry == null ? \'\' : cateogry + \'\';\n    }\n  };\n  OrdinalScale.prototype.count = function () {\n    return this._extent[1] - this._extent[0] + 1;\n  };\n  OrdinalScale.prototype.unionExtentFromData = function (data, dim) {\n    this.unionExtent(data.getApproximateExtent(dim));\n  };\n  /**\r\n   * @override\r\n   * If value is in extent range\r\n   */\n  OrdinalScale.prototype.isInExtentRange = function (value) {\n    value = this._getTickNumber(value);\n    return this._extent[0] <= value && this._extent[1] >= value;\n  };\n  OrdinalScale.prototype.getOrdinalMeta = function () {\n    return this._ordinalMeta;\n  };\n  OrdinalScale.prototype.calcNiceTicks = function () {};\n  OrdinalScale.prototype.calcNiceExtent = function () {};\n  OrdinalScale.type = \'ordinal\';\n  return OrdinalScale;\n}(_Scale_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A);\n_Scale_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.registerClass(OrdinalScale);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrdinalScale);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg1NTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9PcmRpbmFsLmpzPzEzNmIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbi8qKlxyXG4gKiBMaW5lYXIgY29udGludW91cyBzY2FsZVxyXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldmVsX29mX21lYXN1cmVtZW50XHJcbiAqL1xuLy8gRklYTUUgb25seSBvbmUgZGF0YVxuaW1wb3J0IFNjYWxlIGZyb20gJy4vU2NhbGUuanMnO1xuaW1wb3J0IE9yZGluYWxNZXRhIGZyb20gJy4uL2RhdGEvT3JkaW5hbE1ldGEuanMnO1xuaW1wb3J0ICogYXMgc2NhbGVIZWxwZXIgZnJvbSAnLi9oZWxwZXIuanMnO1xuaW1wb3J0IHsgaXNBcnJheSwgbWFwLCBpc09iamVjdCwgaXNTdHJpbmcgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xudmFyIE9yZGluYWxTY2FsZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhPcmRpbmFsU2NhbGUsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIE9yZGluYWxTY2FsZShzZXR0aW5nKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2V0dGluZykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gJ29yZGluYWwnO1xuICAgIHZhciBvcmRpbmFsTWV0YSA9IF90aGlzLmdldFNldHRpbmcoJ29yZGluYWxNZXRhJyk7XG4gICAgLy8gQ2F1dGlvbjogU2hvdWxkIG5vdCB1c2UgaW5zdGFuY2VvZiwgY29uc2lkZXIgZWMtZXh0ZW5zaW9ucyB1c2luZ1xuICAgIC8vIGltcG9ydCBhcHByb2FjaCB0byBnZXQgT3JkaW5hbE1ldGEgY2xhc3MuXG4gICAgaWYgKCFvcmRpbmFsTWV0YSkge1xuICAgICAgb3JkaW5hbE1ldGEgPSBuZXcgT3JkaW5hbE1ldGEoe30pO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheShvcmRpbmFsTWV0YSkpIHtcbiAgICAgIG9yZGluYWxNZXRhID0gbmV3IE9yZGluYWxNZXRhKHtcbiAgICAgICAgY2F0ZWdvcmllczogbWFwKG9yZGluYWxNZXRhLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpc09iamVjdChpdGVtKSA/IGl0ZW0udmFsdWUgOiBpdGVtO1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICAgIF90aGlzLl9vcmRpbmFsTWV0YSA9IG9yZGluYWxNZXRhO1xuICAgIF90aGlzLl9leHRlbnQgPSBfdGhpcy5nZXRTZXR0aW5nKCdleHRlbnQnKSB8fCBbMCwgb3JkaW5hbE1ldGEuY2F0ZWdvcmllcy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgT3JkaW5hbFNjYWxlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyBDYXV0aW9uOiBNYXRoLnJvdW5kKG51bGwpIHdpbGwgcmV0dXJuIGAwYCByYXRoZXIgdGhhbiBgTmFOYFxuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIGlzU3RyaW5nKHZhbCkgPyB0aGlzLl9vcmRpbmFsTWV0YS5nZXRPcmRpbmFsKHZhbClcbiAgICAvLyB2YWwgbWlnaHQgYmUgZmxvYXQuXG4gICAgOiBNYXRoLnJvdW5kKHZhbCk7XG4gIH07XG4gIE9yZGluYWxTY2FsZS5wcm90b3R5cGUuY29udGFpbiA9IGZ1bmN0aW9uIChyYW5rKSB7XG4gICAgcmFuayA9IHRoaXMucGFyc2UocmFuayk7XG4gICAgcmV0dXJuIHNjYWxlSGVscGVyLmNvbnRhaW4ocmFuaywgdGhpcy5fZXh0ZW50KSAmJiB0aGlzLl9vcmRpbmFsTWV0YS5jYXRlZ29yaWVzW3JhbmtdICE9IG51bGw7XG4gIH07XG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZSBnaXZlbiByYW5rIG9yIG5hbWUgdG8gbGluZWFyIFswLCAxXVxyXG4gICAqIEBwYXJhbSB2YWwgcmF3IG9yZGluYWwgbnVtYmVyLlxyXG4gICAqIEByZXR1cm4gbm9ybWFsaXplZCB2YWx1ZSBpbiBbMCwgMV0uXHJcbiAgICovXG4gIE9yZGluYWxTY2FsZS5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhbCA9IHRoaXMuX2dldFRpY2tOdW1iZXIodGhpcy5wYXJzZSh2YWwpKTtcbiAgICByZXR1cm4gc2NhbGVIZWxwZXIubm9ybWFsaXplKHZhbCwgdGhpcy5fZXh0ZW50KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHZhbCBub3JtYWxpemVkIHZhbHVlIGluIFswLCAxXS5cclxuICAgKiBAcmV0dXJuIHJhdyBvcmRpbmFsIG51bWJlci5cclxuICAgKi9cbiAgT3JkaW5hbFNjYWxlLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWwgPSBNYXRoLnJvdW5kKHNjYWxlSGVscGVyLnNjYWxlKHZhbCwgdGhpcy5fZXh0ZW50KSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmF3T3JkaW5hbE51bWJlcih2YWwpO1xuICB9O1xuICBPcmRpbmFsU2NhbGUucHJvdG90eXBlLmdldFRpY2tzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aWNrcyA9IFtdO1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgdmFyIHJhbmsgPSBleHRlbnRbMF07XG4gICAgd2hpbGUgKHJhbmsgPD0gZXh0ZW50WzFdKSB7XG4gICAgICB0aWNrcy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IHJhbmtcbiAgICAgIH0pO1xuICAgICAgcmFuaysrO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH07XG4gIE9yZGluYWxTY2FsZS5wcm90b3R5cGUuZ2V0TWlub3JUaWNrcyA9IGZ1bmN0aW9uIChzcGxpdE51bWJlcikge1xuICAgIC8vIE5vdCBzdXBwb3J0LlxuICAgIHJldHVybjtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHNlZSBgT3JkaW5hbFsnX29yZGluYWxOdW1iZXJzQnlUaWNrJ11gXHJcbiAgICovXG4gIE9yZGluYWxTY2FsZS5wcm90b3R5cGUuc2V0U29ydEluZm8gPSBmdW5jdGlvbiAoaW5mbykge1xuICAgIGlmIChpbmZvID09IG51bGwpIHtcbiAgICAgIHRoaXMuX29yZGluYWxOdW1iZXJzQnlUaWNrID0gdGhpcy5fdGlja3NCeU9yZGluYWxOdW1iZXIgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaW5mb09yZGluYWxOdW1iZXJzID0gaW5mby5vcmRpbmFsTnVtYmVycztcbiAgICB2YXIgb3JkaW5hbHNCeVRpY2sgPSB0aGlzLl9vcmRpbmFsTnVtYmVyc0J5VGljayA9IFtdO1xuICAgIHZhciB0aWNrc0J5T3JkaW5hbCA9IHRoaXMuX3RpY2tzQnlPcmRpbmFsTnVtYmVyID0gW107XG4gICAgLy8gVW5uZWNlc3Nhcnkgc3VwcG9ydCBuZWdhdGl2ZSB0aWNrIGluIGByZWFsdGltZVNvcnRgLlxuICAgIHZhciB0aWNrTnVtID0gMDtcbiAgICB2YXIgYWxsQ2F0ZWdvcnlMZW4gPSB0aGlzLl9vcmRpbmFsTWV0YS5jYXRlZ29yaWVzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBsZW4gPSBNYXRoLm1pbihhbGxDYXRlZ29yeUxlbiwgaW5mb09yZGluYWxOdW1iZXJzLmxlbmd0aCk7IHRpY2tOdW0gPCBsZW47ICsrdGlja051bSkge1xuICAgICAgdmFyIG9yZGluYWxOdW1iZXIgPSBpbmZvT3JkaW5hbE51bWJlcnNbdGlja051bV07XG4gICAgICBvcmRpbmFsc0J5VGlja1t0aWNrTnVtXSA9IG9yZGluYWxOdW1iZXI7XG4gICAgICB0aWNrc0J5T3JkaW5hbFtvcmRpbmFsTnVtYmVyXSA9IHRpY2tOdW07XG4gICAgfVxuICAgIC8vIEhhbmRsZSB0aGF0IGBzZXJpZXMuZGF0YWAgb25seSBjb3ZlcnMgcGFydCBvZiB0aGUgYGF4aXMuY2F0ZWdvcnkuZGF0YWAuXG4gICAgdmFyIHVudXNlZE9yZGluYWwgPSAwO1xuICAgIGZvciAoOyB0aWNrTnVtIDwgYWxsQ2F0ZWdvcnlMZW47ICsrdGlja051bSkge1xuICAgICAgd2hpbGUgKHRpY2tzQnlPcmRpbmFsW3VudXNlZE9yZGluYWxdICE9IG51bGwpIHtcbiAgICAgICAgdW51c2VkT3JkaW5hbCsrO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgb3JkaW5hbHNCeVRpY2sucHVzaCh1bnVzZWRPcmRpbmFsKTtcbiAgICAgIHRpY2tzQnlPcmRpbmFsW3VudXNlZE9yZGluYWxdID0gdGlja051bTtcbiAgICB9XG4gIH07XG4gIE9yZGluYWxTY2FsZS5wcm90b3R5cGUuX2dldFRpY2tOdW1iZXIgPSBmdW5jdGlvbiAob3JkaW5hbCkge1xuICAgIHZhciB0aWNrc0J5T3JkaW5hbE51bWJlciA9IHRoaXMuX3RpY2tzQnlPcmRpbmFsTnVtYmVyO1xuICAgIC8vIGFsc28gc3VwcG9ydCBvcmRpbmFsIG91dCBvZiByYW5nZSBvZiBgb3JkaW5hbE1ldGEuY2F0ZWdvcmllcy5sZW5ndGhgLFxuICAgIC8vIHdoZXJlIG9yZGluYWwgbnVtYmVycyBhcmUgdXNlZCBhcyB0aWNrIHZhbHVlIGRpcmVjdGx5LlxuICAgIHJldHVybiB0aWNrc0J5T3JkaW5hbE51bWJlciAmJiBvcmRpbmFsID49IDAgJiYgb3JkaW5hbCA8IHRpY2tzQnlPcmRpbmFsTnVtYmVyLmxlbmd0aCA/IHRpY2tzQnlPcmRpbmFsTnVtYmVyW29yZGluYWxdIDogb3JkaW5hbDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHVzYWdlXHJcbiAgICogYGBganNcclxuICAgKiBjb25zdCBvcmRpbmFsTnVtYmVyID0gb3JkaW5hbFNjYWxlLmdldFJhd09yZGluYWxOdW1iZXIodGlja1ZhbCk7XHJcbiAgICpcclxuICAgKiAvLyBjYXNlMFxyXG4gICAqIGNvbnN0IHJhd09yZGluYWxWYWx1ZSA9IGF4aXNNb2RlbC5nZXRDYXRlZ29yaWVzKClbb3JkaW5hbE51bWJlcl07XHJcbiAgICogLy8gY2FzZTFcclxuICAgKiBjb25zdCByYXdPcmRpbmFsVmFsdWUgPSB0aGlzLl9vcmRpbmFsTWV0YS5jYXRlZ29yaWVzW29yZGluYWxOdW1iZXJdO1xyXG4gICAqIC8vIGNhc2UyXHJcbiAgICogY29uc3QgY29vcmQgPSBheGlzLmRhdGFUb0Nvb3JkKG9yZGluYWxOdW1iZXIpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPcmRpbmFsTnVtYmVyfSB0aWNrTnVtYmVyIGluZGV4IG9mIGRpc3BsYXlcclxuICAgKi9cbiAgT3JkaW5hbFNjYWxlLnByb3RvdHlwZS5nZXRSYXdPcmRpbmFsTnVtYmVyID0gZnVuY3Rpb24gKHRpY2tOdW1iZXIpIHtcbiAgICB2YXIgb3JkaW5hbE51bWJlcnNCeVRpY2sgPSB0aGlzLl9vcmRpbmFsTnVtYmVyc0J5VGljaztcbiAgICAvLyB0aWNrTnVtYmVyIG1heSBiZSBvdXQgb2YgcmFuZ2UsIGUuZy4sIHdoZW4gYXhpcyBtYXggaXMgbGFyZ2VyIHRoYW4gYG9yZGluYWxNZXRhLmNhdGVnb3JpZXMubGVuZ3RoYC4sXG4gICAgLy8gd2hlcmUgb3JkaW5hbCBudW1iZXJzIGFyZSB1c2VkIGFzIHRpY2sgdmFsdWUgZGlyZWN0bHkuXG4gICAgcmV0dXJuIG9yZGluYWxOdW1iZXJzQnlUaWNrICYmIHRpY2tOdW1iZXIgPj0gMCAmJiB0aWNrTnVtYmVyIDwgb3JkaW5hbE51bWJlcnNCeVRpY2subGVuZ3RoID8gb3JkaW5hbE51bWJlcnNCeVRpY2tbdGlja051bWJlcl0gOiB0aWNrTnVtYmVyO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgaXRlbSBvbiB0aWNrXHJcbiAgICovXG4gIE9yZGluYWxTY2FsZS5wcm90b3R5cGUuZ2V0TGFiZWwgPSBmdW5jdGlvbiAodGljaykge1xuICAgIGlmICghdGhpcy5pc0JsYW5rKCkpIHtcbiAgICAgIHZhciBvcmRpbmFsTnVtYmVyID0gdGhpcy5nZXRSYXdPcmRpbmFsTnVtYmVyKHRpY2sudmFsdWUpO1xuICAgICAgdmFyIGNhdGVvZ3J5ID0gdGhpcy5fb3JkaW5hbE1ldGEuY2F0ZWdvcmllc1tvcmRpbmFsTnVtYmVyXTtcbiAgICAgIC8vIE5vdGUgdGhhdCBpZiBubyBkYXRhLCBvcmRpbmFsTWV0YS5jYXRlZ29yaWVzIGlzIGFuIGVtcHR5IGFycmF5LlxuICAgICAgLy8gUmV0dXJuIGVtcHR5IGlmIGl0J3Mgbm90IGV4aXN0LlxuICAgICAgcmV0dXJuIGNhdGVvZ3J5ID09IG51bGwgPyAnJyA6IGNhdGVvZ3J5ICsgJyc7XG4gICAgfVxuICB9O1xuICBPcmRpbmFsU2NhbGUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9leHRlbnRbMV0gLSB0aGlzLl9leHRlbnRbMF0gKyAxO1xuICB9O1xuICBPcmRpbmFsU2NhbGUucHJvdG90eXBlLnVuaW9uRXh0ZW50RnJvbURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgZGltKSB7XG4gICAgdGhpcy51bmlvbkV4dGVudChkYXRhLmdldEFwcHJveGltYXRlRXh0ZW50KGRpbSkpO1xuICB9O1xuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBJZiB2YWx1ZSBpcyBpbiBleHRlbnQgcmFuZ2VcclxuICAgKi9cbiAgT3JkaW5hbFNjYWxlLnByb3RvdHlwZS5pc0luRXh0ZW50UmFuZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHRoaXMuX2dldFRpY2tOdW1iZXIodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9leHRlbnRbMF0gPD0gdmFsdWUgJiYgdGhpcy5fZXh0ZW50WzFdID49IHZhbHVlO1xuICB9O1xuICBPcmRpbmFsU2NhbGUucHJvdG90eXBlLmdldE9yZGluYWxNZXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmRpbmFsTWV0YTtcbiAgfTtcbiAgT3JkaW5hbFNjYWxlLnByb3RvdHlwZS5jYWxjTmljZVRpY2tzID0gZnVuY3Rpb24gKCkge307XG4gIE9yZGluYWxTY2FsZS5wcm90b3R5cGUuY2FsY05pY2VFeHRlbnQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgT3JkaW5hbFNjYWxlLnR5cGUgPSAnb3JkaW5hbCc7XG4gIHJldHVybiBPcmRpbmFsU2NhbGU7XG59KFNjYWxlKTtcblNjYWxlLnJlZ2lzdGVyQ2xhc3MoT3JkaW5hbFNjYWxlKTtcbmV4cG9ydCBkZWZhdWx0IE9yZGluYWxTY2FsZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18550\n')},28613:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_clazz_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30693);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar Scale = /** @class */function () {\n  function Scale(setting) {\n    this._setting = setting || {};\n    this._extent = [Infinity, -Infinity];\n  }\n  Scale.prototype.getSetting = function (name) {\n    return this._setting[name];\n  };\n  /**\r\n   * Set extent from data\r\n   */\n  Scale.prototype.unionExtent = function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]);\n    // not setExtent because in log axis it may transformed to power\n    // this.setExtent(extent[0], extent[1]);\n  };\n  /**\r\n   * Set extent from data\r\n   */\n  Scale.prototype.unionExtentFromData = function (data, dim) {\n    this.unionExtent(data.getApproximateExtent(dim));\n  };\n  /**\r\n   * Get extent\r\n   *\r\n   * Extent is always in increase order.\r\n   */\n  Scale.prototype.getExtent = function () {\n    return this._extent.slice();\n  };\n  /**\r\n   * Set extent\r\n   */\n  Scale.prototype.setExtent = function (start, end) {\n    var thisExtent = this._extent;\n    if (!isNaN(start)) {\n      thisExtent[0] = start;\n    }\n    if (!isNaN(end)) {\n      thisExtent[1] = end;\n    }\n  };\n  /**\r\n   * If value is in extent range\r\n   */\n  Scale.prototype.isInExtentRange = function (value) {\n    return this._extent[0] <= value && this._extent[1] >= value;\n  };\n  /**\r\n   * When axis extent depends on data and no data exists,\r\n   * axis ticks should not be drawn, which is named \'blank\'.\r\n   */\n  Scale.prototype.isBlank = function () {\n    return this._isBlank;\n  };\n  /**\r\n   * When axis extent depends on data and no data exists,\r\n   * axis ticks should not be drawn, which is named \'blank\'.\r\n   */\n  Scale.prototype.setBlank = function (isBlank) {\n    this._isBlank = isBlank;\n  };\n  return Scale;\n}();\n_util_clazz_js__WEBPACK_IMPORTED_MODULE_0__/* .enableClassManagement */ .tQ(Scale);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Scale);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg2MTMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL1NjYWxlLmpzPzUwMzQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyBjbGF6elV0aWwgZnJvbSAnLi4vdXRpbC9jbGF6ei5qcyc7XG52YXIgU2NhbGUgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY2FsZShzZXR0aW5nKSB7XG4gICAgdGhpcy5fc2V0dGluZyA9IHNldHRpbmcgfHwge307XG4gICAgdGhpcy5fZXh0ZW50ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICB9XG4gIFNjYWxlLnByb3RvdHlwZS5nZXRTZXR0aW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0dGluZ1tuYW1lXTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU2V0IGV4dGVudCBmcm9tIGRhdGFcclxuICAgKi9cbiAgU2NhbGUucHJvdG90eXBlLnVuaW9uRXh0ZW50ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICBvdGhlclswXSA8IGV4dGVudFswXSAmJiAoZXh0ZW50WzBdID0gb3RoZXJbMF0pO1xuICAgIG90aGVyWzFdID4gZXh0ZW50WzFdICYmIChleHRlbnRbMV0gPSBvdGhlclsxXSk7XG4gICAgLy8gbm90IHNldEV4dGVudCBiZWNhdXNlIGluIGxvZyBheGlzIGl0IG1heSB0cmFuc2Zvcm1lZCB0byBwb3dlclxuICAgIC8vIHRoaXMuc2V0RXh0ZW50KGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU2V0IGV4dGVudCBmcm9tIGRhdGFcclxuICAgKi9cbiAgU2NhbGUucHJvdG90eXBlLnVuaW9uRXh0ZW50RnJvbURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgZGltKSB7XG4gICAgdGhpcy51bmlvbkV4dGVudChkYXRhLmdldEFwcHJveGltYXRlRXh0ZW50KGRpbSkpO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgZXh0ZW50XHJcbiAgICpcclxuICAgKiBFeHRlbnQgaXMgYWx3YXlzIGluIGluY3JlYXNlIG9yZGVyLlxyXG4gICAqL1xuICBTY2FsZS5wcm90b3R5cGUuZ2V0RXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9leHRlbnQuc2xpY2UoKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU2V0IGV4dGVudFxyXG4gICAqL1xuICBTY2FsZS5wcm90b3R5cGUuc2V0RXh0ZW50ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgdGhpc0V4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICBpZiAoIWlzTmFOKHN0YXJ0KSkge1xuICAgICAgdGhpc0V4dGVudFswXSA9IHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGVuZCkpIHtcbiAgICAgIHRoaXNFeHRlbnRbMV0gPSBlbmQ7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBJZiB2YWx1ZSBpcyBpbiBleHRlbnQgcmFuZ2VcclxuICAgKi9cbiAgU2NhbGUucHJvdG90eXBlLmlzSW5FeHRlbnRSYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9leHRlbnRbMF0gPD0gdmFsdWUgJiYgdGhpcy5fZXh0ZW50WzFdID49IHZhbHVlO1xuICB9O1xuICAvKipcclxuICAgKiBXaGVuIGF4aXMgZXh0ZW50IGRlcGVuZHMgb24gZGF0YSBhbmQgbm8gZGF0YSBleGlzdHMsXHJcbiAgICogYXhpcyB0aWNrcyBzaG91bGQgbm90IGJlIGRyYXduLCB3aGljaCBpcyBuYW1lZCAnYmxhbmsnLlxyXG4gICAqL1xuICBTY2FsZS5wcm90b3R5cGUuaXNCbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNCbGFuaztcbiAgfTtcbiAgLyoqXHJcbiAgICogV2hlbiBheGlzIGV4dGVudCBkZXBlbmRzIG9uIGRhdGEgYW5kIG5vIGRhdGEgZXhpc3RzLFxyXG4gICAqIGF4aXMgdGlja3Mgc2hvdWxkIG5vdCBiZSBkcmF3biwgd2hpY2ggaXMgbmFtZWQgJ2JsYW5rJy5cclxuICAgKi9cbiAgU2NhbGUucHJvdG90eXBlLnNldEJsYW5rID0gZnVuY3Rpb24gKGlzQmxhbmspIHtcbiAgICB0aGlzLl9pc0JsYW5rID0gaXNCbGFuaztcbiAgfTtcbiAgcmV0dXJuIFNjYWxlO1xufSgpO1xuY2xhenpVdGlsLmVuYWJsZUNsYXNzTWFuYWdlbWVudChTY2FsZSk7XG5leHBvcnQgZGVmYXVsdCBTY2FsZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///28613\n')},32944:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ makeStyleMapper)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// TODO Parse shadow style\n// TODO Only shallow path support\n\nfunction makeStyleMapper(properties, ignoreParent) {\n  // Normalize\n  for (var i = 0; i < properties.length; i++) {\n    if (!properties[i][1]) {\n      properties[i][1] = properties[i][0];\n    }\n  }\n  ignoreParent = ignoreParent || false;\n  return function (model, excludes, includes) {\n    var style = {};\n    for (var i = 0; i < properties.length; i++) {\n      var propName = properties[i][1];\n      if (excludes && zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf(excludes, propName) >= 0 || includes && zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf(includes, propName) < 0) {\n        continue;\n      }\n      var val = model.getShallow(propName, ignoreParent);\n      if (val != null) {\n        style[properties[i][0]] = val;\n      }\n    }\n    // TODO Text or image?\n    return style;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI5NDQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL21ha2VTdHlsZU1hcHBlci5qcz82NWI2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLy8gVE9ETyBQYXJzZSBzaGFkb3cgc3R5bGVcbi8vIFRPRE8gT25seSBzaGFsbG93IHBhdGggc3VwcG9ydFxuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYWtlU3R5bGVNYXBwZXIocHJvcGVydGllcywgaWdub3JlUGFyZW50KSB7XG4gIC8vIE5vcm1hbGl6ZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXByb3BlcnRpZXNbaV1bMV0pIHtcbiAgICAgIHByb3BlcnRpZXNbaV1bMV0gPSBwcm9wZXJ0aWVzW2ldWzBdO1xuICAgIH1cbiAgfVxuICBpZ25vcmVQYXJlbnQgPSBpZ25vcmVQYXJlbnQgfHwgZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAobW9kZWwsIGV4Y2x1ZGVzLCBpbmNsdWRlcykge1xuICAgIHZhciBzdHlsZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydGllc1tpXVsxXTtcbiAgICAgIGlmIChleGNsdWRlcyAmJiB6clV0aWwuaW5kZXhPZihleGNsdWRlcywgcHJvcE5hbWUpID49IDAgfHwgaW5jbHVkZXMgJiYgenJVdGlsLmluZGV4T2YoaW5jbHVkZXMsIHByb3BOYW1lKSA8IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgdmFsID0gbW9kZWwuZ2V0U2hhbGxvdyhwcm9wTmFtZSwgaWdub3JlUGFyZW50KTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0aWVzW2ldWzBdXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVE9ETyBUZXh0IG9yIGltYWdlP1xuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///32944\n')},37959:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ dataSample)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    }\n    // Return NaN if count is 0\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n    // NaN will cause illegal axis extent.\n    return isFinite(max) ? max : NaN;\n  },\n  min: function (frame) {\n    var min = Infinity;\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n    // NaN will cause illegal axis extent.\n    return isFinite(min) ? min : NaN;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\nvar indexSampler = function (frame) {\n  return Math.round(frame.length / 2);\n};\nfunction dataSample(seriesType) {\n  return {\n    seriesType: seriesType,\n    // FIXME:TS never used, so comment it\n    // modifyOutputEnd: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem;\n      var count = data.count();\n      // Only cartesian2d support down sampling. Disable it when there is few data.\n      if (count > 10 && coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent();\n        var dpr = api.getDevicePixelRatio();\n        // Coordinste system has been resized\n        var size = Math.abs(extent[1] - extent[0]) * (dpr || 1);\n        var rate = Math.round(count / size);\n        if (isFinite(rate) && rate > 1) {\n          if (sampling === 'lttb') {\n            seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis.dim), 1 / rate));\n          } else if (sampling === 'minmax') {\n            seriesModel.setData(data.minmaxDownSample(data.mapDimension(valueAxis.dim), 1 / rate));\n          }\n          var sampler = void 0;\n          if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString)(sampling)) {\n            sampler = samplers[sampling];\n          } else if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(sampling)) {\n            sampler = sampling;\n          }\n          if (sampler) {\n            // Only support sample the first dim mapped from value axis.\n            seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc5NTkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhU2FtcGxlLmpzP2M2ODAiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc1N0cmluZyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG52YXIgc2FtcGxlcnMgPSB7XG4gIGF2ZXJhZ2U6IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFpc05hTihmcmFtZVtpXSkpIHtcbiAgICAgICAgc3VtICs9IGZyYW1lW2ldO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm4gTmFOIGlmIGNvdW50IGlzIDBcbiAgICByZXR1cm4gY291bnQgPT09IDAgPyBOYU4gOiBzdW0gLyBjb3VudDtcbiAgfSxcbiAgc3VtOiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBJZ25vcmUgTmFOXG4gICAgICBzdW0gKz0gZnJhbWVbaV0gfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbiAgfSxcbiAgbWF4OiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyYW1lW2ldID4gbWF4ICYmIChtYXggPSBmcmFtZVtpXSk7XG4gICAgfVxuICAgIC8vIE5hTiB3aWxsIGNhdXNlIGlsbGVnYWwgYXhpcyBleHRlbnQuXG4gICAgcmV0dXJuIGlzRmluaXRlKG1heCkgPyBtYXggOiBOYU47XG4gIH0sXG4gIG1pbjogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyYW1lW2ldIDwgbWluICYmIChtaW4gPSBmcmFtZVtpXSk7XG4gICAgfVxuICAgIC8vIE5hTiB3aWxsIGNhdXNlIGlsbGVnYWwgYXhpcyBleHRlbnQuXG4gICAgcmV0dXJuIGlzRmluaXRlKG1pbikgPyBtaW4gOiBOYU47XG4gIH0sXG4gIC8vIFRPRE9cbiAgLy8gTWVkaWFuXG4gIG5lYXJlc3Q6IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgIHJldHVybiBmcmFtZVswXTtcbiAgfVxufTtcbnZhciBpbmRleFNhbXBsZXIgPSBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoZnJhbWUubGVuZ3RoIC8gMik7XG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGF0YVNhbXBsZShzZXJpZXNUeXBlKSB7XG4gIHJldHVybiB7XG4gICAgc2VyaWVzVHlwZTogc2VyaWVzVHlwZSxcbiAgICAvLyBGSVhNRTpUUyBuZXZlciB1c2VkLCBzbyBjb21tZW50IGl0XG4gICAgLy8gbW9kaWZ5T3V0cHV0RW5kOiB0cnVlLFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgc2FtcGxpbmcgPSBzZXJpZXNNb2RlbC5nZXQoJ3NhbXBsaW5nJyk7XG4gICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdmFyIGNvdW50ID0gZGF0YS5jb3VudCgpO1xuICAgICAgLy8gT25seSBjYXJ0ZXNpYW4yZCBzdXBwb3J0IGRvd24gc2FtcGxpbmcuIERpc2FibGUgaXQgd2hlbiB0aGVyZSBpcyBmZXcgZGF0YS5cbiAgICAgIGlmIChjb3VudCA+IDEwICYmIGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgJiYgc2FtcGxpbmcpIHtcbiAgICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgdmFyIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgICAgIHZhciBleHRlbnQgPSBiYXNlQXhpcy5nZXRFeHRlbnQoKTtcbiAgICAgICAgdmFyIGRwciA9IGFwaS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgICAgIC8vIENvb3JkaW5zdGUgc3lzdGVtIGhhcyBiZWVuIHJlc2l6ZWRcbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLmFicyhleHRlbnRbMV0gLSBleHRlbnRbMF0pICogKGRwciB8fCAxKTtcbiAgICAgICAgdmFyIHJhdGUgPSBNYXRoLnJvdW5kKGNvdW50IC8gc2l6ZSk7XG4gICAgICAgIGlmIChpc0Zpbml0ZShyYXRlKSAmJiByYXRlID4gMSkge1xuICAgICAgICAgIGlmIChzYW1wbGluZyA9PT0gJ2x0dGInKSB7XG4gICAgICAgICAgICBzZXJpZXNNb2RlbC5zZXREYXRhKGRhdGEubHR0YkRvd25TYW1wbGUoZGF0YS5tYXBEaW1lbnNpb24odmFsdWVBeGlzLmRpbSksIDEgLyByYXRlKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzYW1wbGluZyA9PT0gJ21pbm1heCcpIHtcbiAgICAgICAgICAgIHNlcmllc01vZGVsLnNldERhdGEoZGF0YS5taW5tYXhEb3duU2FtcGxlKGRhdGEubWFwRGltZW5zaW9uKHZhbHVlQXhpcy5kaW0pLCAxIC8gcmF0ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc2FtcGxlciA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoaXNTdHJpbmcoc2FtcGxpbmcpKSB7XG4gICAgICAgICAgICBzYW1wbGVyID0gc2FtcGxlcnNbc2FtcGxpbmddO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzYW1wbGluZykpIHtcbiAgICAgICAgICAgIHNhbXBsZXIgPSBzYW1wbGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbXBsZXIpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgc3VwcG9ydCBzYW1wbGUgdGhlIGZpcnN0IGRpbSBtYXBwZWQgZnJvbSB2YWx1ZSBheGlzLlxuICAgICAgICAgICAgc2VyaWVzTW9kZWwuc2V0RGF0YShkYXRhLmRvd25TYW1wbGUoZGF0YS5tYXBEaW1lbnNpb24odmFsdWVBeGlzLmRpbSksIDEgLyByYXRlLCBzYW1wbGVyLCBpbmRleFNhbXBsZXIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///37959\n")},43172:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ model_Model)\n});\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/env.js\nvar env = __webpack_require__(38123);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/clazz.js\nvar clazz = __webpack_require__(30693);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/mixin/makeStyleMapper.js\nvar makeStyleMapper = __webpack_require__(32944);\n;// ./node_modules/echarts/lib/model/mixin/areaStyle.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar AREA_STYLE_KEY_MAP = [['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']\n// Option decal is in `DecalObject` but style.decal is in `PatternObject`.\n// So do not transfer decal directly.\n];\nvar getAreaStyle = (0,makeStyleMapper/* default */.A)(AREA_STYLE_KEY_MAP);\nvar AreaStyleMixin = /** @class */function () {\n  function AreaStyleMixin() {}\n  AreaStyleMixin.prototype.getAreaStyle = function (excludes, includes) {\n    return getAreaStyle(this, excludes, includes);\n  };\n  return AreaStyleMixin;\n}();\n;\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n;// ./node_modules/echarts/lib/model/mixin/textStyle.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar PATH_COLOR = ['textStyle', 'color'];\nvar textStyleParams = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'padding', 'lineHeight', 'rich', 'width', 'height', 'overflow'];\n// TODO Performance improvement?\nvar tmpText = new Text/* default */.Ay();\nvar TextStyleMixin = /** @class */function () {\n  function TextStyleMixin() {}\n  /**\r\n   * Get color property or get color from option.textStyle.color\r\n   */\n  // TODO Callback\n  TextStyleMixin.prototype.getTextColor = function (isEmphasis) {\n    var ecModel = this.ecModel;\n    return this.getShallow('color') || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);\n  };\n  /**\r\n   * Create font string from fontStyle, fontWeight, fontSize, fontFamily\r\n   * @return {string}\r\n   */\n  TextStyleMixin.prototype.getFont = function () {\n    return (0,labelStyle/* getFont */.c8)({\n      fontStyle: this.getShallow('fontStyle'),\n      fontWeight: this.getShallow('fontWeight'),\n      fontSize: this.getShallow('fontSize'),\n      fontFamily: this.getShallow('fontFamily')\n    }, this.ecModel);\n  };\n  TextStyleMixin.prototype.getTextRect = function (text) {\n    var style = {\n      text: text,\n      verticalAlign: this.getShallow('verticalAlign') || this.getShallow('baseline')\n    };\n    for (var i = 0; i < textStyleParams.length; i++) {\n      style[textStyleParams[i]] = this.getShallow(textStyleParams[i]);\n    }\n    tmpText.useStyle(style);\n    tmpText.update();\n    return tmpText.getBoundingRect();\n  };\n  return TextStyleMixin;\n}();\n;\n/* harmony default export */ const textStyle = (TextStyleMixin);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/mixin/lineStyle.js\nvar lineStyle = __webpack_require__(8317);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/mixin/itemStyle.js\nvar itemStyle = __webpack_require__(14962);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n;// ./node_modules/echarts/lib/model/Model.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar Model = /** @class */function () {\n  function Model(option, parentModel, ecModel) {\n    this.parentModel = parentModel;\n    this.ecModel = ecModel;\n    this.option = option;\n    // Simple optimization\n    // if (this.init) {\n    //     if (arguments.length <= 4) {\n    //         this.init(option, parentModel, ecModel, extraOpt);\n    //     }\n    //     else {\n    //         this.init.apply(this, arguments);\n    //     }\n    // }\n  }\n  Model.prototype.init = function (option, parentModel, ecModel) {\n    var rest = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n      rest[_i - 3] = arguments[_i];\n    }\n  };\n  /**\r\n   * Merge the input option to me.\r\n   */\n  Model.prototype.mergeOption = function (option, ecModel) {\n    (0,util.merge)(this.option, option, true);\n  };\n  // `path` can be 'a.b.c', so the return value type have to be `ModelOption`\n  // TODO: TYPE strict key check?\n  // get(path: string | string[], ignoreParent?: boolean): ModelOption;\n  Model.prototype.get = function (path, ignoreParent) {\n    if (path == null) {\n      return this.option;\n    }\n    return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);\n  };\n  Model.prototype.getShallow = function (key, ignoreParent) {\n    var option = this.option;\n    var val = option == null ? option : option[key];\n    if (val == null && !ignoreParent) {\n      var parentModel = this.parentModel;\n      if (parentModel) {\n        // FIXME:TS do not know how to make it works\n        val = parentModel.getShallow(key);\n      }\n    }\n    return val;\n  };\n  // `path` can be 'a.b.c', so the return value type have to be `Model<ModelOption>`\n  // getModel(path: string | string[], parentModel?: Model): Model;\n  // TODO 'a.b.c' is deprecated\n  Model.prototype.getModel = function (path, parentModel) {\n    var hasPath = path != null;\n    var pathFinal = hasPath ? this.parsePath(path) : null;\n    var obj = hasPath ? this._doGet(pathFinal) : this.option;\n    parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));\n    return new Model(obj, parentModel, this.ecModel);\n  };\n  /**\r\n   * If model has option\r\n   */\n  Model.prototype.isEmpty = function () {\n    return this.option == null;\n  };\n  Model.prototype.restoreData = function () {};\n  // Pending\n  Model.prototype.clone = function () {\n    var Ctor = this.constructor;\n    return new Ctor((0,util.clone)(this.option));\n  };\n  // setReadOnly(properties): void {\n  // clazzUtil.setReadOnly(this, properties);\n  // }\n  // If path is null/undefined, return null/undefined.\n  Model.prototype.parsePath = function (path) {\n    if (typeof path === 'string') {\n      return path.split('.');\n    }\n    return path;\n  };\n  // Resolve path for parent. Perhaps useful when parent use a different property.\n  // Default to be a identity resolver.\n  // Can be modified to a different resolver.\n  Model.prototype.resolveParentPath = function (path) {\n    return path;\n  };\n  // FIXME:TS check whether put this method here\n  Model.prototype.isAnimationEnabled = function () {\n    if (!env/* default */.A.node && this.option) {\n      if (this.option.animation != null) {\n        return !!this.option.animation;\n      } else if (this.parentModel) {\n        return this.parentModel.isAnimationEnabled();\n      }\n    }\n  };\n  Model.prototype._doGet = function (pathArr, parentModel) {\n    var obj = this.option;\n    if (!pathArr) {\n      return obj;\n    }\n    for (var i = 0; i < pathArr.length; i++) {\n      // Ignore empty\n      if (!pathArr[i]) {\n        continue;\n      }\n      // obj could be number/string/... (like 0)\n      obj = obj && typeof obj === 'object' ? obj[pathArr[i]] : null;\n      if (obj == null) {\n        break;\n      }\n    }\n    if (obj == null && parentModel) {\n      obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);\n    }\n    return obj;\n  };\n  return Model;\n}();\n;\n// Enable Model.extend.\n(0,clazz/* enableClassExtend */.gq)(Model);\n(0,clazz/* enableClassCheck */.Od)(Model);\n(0,util.mixin)(Model, lineStyle/* LineStyleMixin */.J);\n(0,util.mixin)(Model, itemStyle/* ItemStyleMixin */.s);\n(0,util.mixin)(Model, AreaStyleMixin);\n(0,util.mixin)(Model, textStyle);\n/* harmony default export */ const model_Model = (Model);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMxNzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2FyZWFTdHlsZS5qcz83NTYyIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi90ZXh0U3R5bGUuanM/YTZmYSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvTW9kZWwuanM/ZGIyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBtYWtlU3R5bGVNYXBwZXIgZnJvbSAnLi9tYWtlU3R5bGVNYXBwZXIuanMnO1xuZXhwb3J0IHZhciBBUkVBX1NUWUxFX0tFWV9NQVAgPSBbWydmaWxsJywgJ2NvbG9yJ10sIFsnc2hhZG93Qmx1ciddLCBbJ3NoYWRvd09mZnNldFgnXSwgWydzaGFkb3dPZmZzZXRZJ10sIFsnb3BhY2l0eSddLCBbJ3NoYWRvd0NvbG9yJ11cbi8vIE9wdGlvbiBkZWNhbCBpcyBpbiBgRGVjYWxPYmplY3RgIGJ1dCBzdHlsZS5kZWNhbCBpcyBpbiBgUGF0dGVybk9iamVjdGAuXG4vLyBTbyBkbyBub3QgdHJhbnNmZXIgZGVjYWwgZGlyZWN0bHkuXG5dO1xudmFyIGdldEFyZWFTdHlsZSA9IG1ha2VTdHlsZU1hcHBlcihBUkVBX1NUWUxFX0tFWV9NQVApO1xudmFyIEFyZWFTdHlsZU1peGluID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXJlYVN0eWxlTWl4aW4oKSB7fVxuICBBcmVhU3R5bGVNaXhpbi5wcm90b3R5cGUuZ2V0QXJlYVN0eWxlID0gZnVuY3Rpb24gKGV4Y2x1ZGVzLCBpbmNsdWRlcykge1xuICAgIHJldHVybiBnZXRBcmVhU3R5bGUodGhpcywgZXhjbHVkZXMsIGluY2x1ZGVzKTtcbiAgfTtcbiAgcmV0dXJuIEFyZWFTdHlsZU1peGluO1xufSgpO1xuO1xuZXhwb3J0IHsgQXJlYVN0eWxlTWl4aW4gfTsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGdldEZvbnQgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlLmpzJztcbmltcG9ydCBaUlRleHQgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0LmpzJztcbnZhciBQQVRIX0NPTE9SID0gWyd0ZXh0U3R5bGUnLCAnY29sb3InXTtcbnZhciB0ZXh0U3R5bGVQYXJhbXMgPSBbJ2ZvbnRTdHlsZScsICdmb250V2VpZ2h0JywgJ2ZvbnRTaXplJywgJ2ZvbnRGYW1pbHknLCAncGFkZGluZycsICdsaW5lSGVpZ2h0JywgJ3JpY2gnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ292ZXJmbG93J107XG4vLyBUT0RPIFBlcmZvcm1hbmNlIGltcHJvdmVtZW50P1xudmFyIHRtcFRleHQgPSBuZXcgWlJUZXh0KCk7XG52YXIgVGV4dFN0eWxlTWl4aW4gPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZXh0U3R5bGVNaXhpbigpIHt9XG4gIC8qKlxyXG4gICAqIEdldCBjb2xvciBwcm9wZXJ0eSBvciBnZXQgY29sb3IgZnJvbSBvcHRpb24udGV4dFN0eWxlLmNvbG9yXHJcbiAgICovXG4gIC8vIFRPRE8gQ2FsbGJhY2tcbiAgVGV4dFN0eWxlTWl4aW4ucHJvdG90eXBlLmdldFRleHRDb2xvciA9IGZ1bmN0aW9uIChpc0VtcGhhc2lzKSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2hhbGxvdygnY29sb3InKSB8fCAoIWlzRW1waGFzaXMgJiYgZWNNb2RlbCA/IGVjTW9kZWwuZ2V0KFBBVEhfQ09MT1IpIDogbnVsbCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBmb250IHN0cmluZyBmcm9tIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHlcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICovXG4gIFRleHRTdHlsZU1peGluLnByb3RvdHlwZS5nZXRGb250ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRGb250KHtcbiAgICAgIGZvbnRTdHlsZTogdGhpcy5nZXRTaGFsbG93KCdmb250U3R5bGUnKSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuZ2V0U2hhbGxvdygnZm9udFdlaWdodCcpLFxuICAgICAgZm9udFNpemU6IHRoaXMuZ2V0U2hhbGxvdygnZm9udFNpemUnKSxcbiAgICAgIGZvbnRGYW1pbHk6IHRoaXMuZ2V0U2hhbGxvdygnZm9udEZhbWlseScpXG4gICAgfSwgdGhpcy5lY01vZGVsKTtcbiAgfTtcbiAgVGV4dFN0eWxlTWl4aW4ucHJvdG90eXBlLmdldFRleHRSZWN0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB2YXIgc3R5bGUgPSB7XG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgdmVydGljYWxBbGlnbjogdGhpcy5nZXRTaGFsbG93KCd2ZXJ0aWNhbEFsaWduJykgfHwgdGhpcy5nZXRTaGFsbG93KCdiYXNlbGluZScpXG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRTdHlsZVBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3R5bGVbdGV4dFN0eWxlUGFyYW1zW2ldXSA9IHRoaXMuZ2V0U2hhbGxvdyh0ZXh0U3R5bGVQYXJhbXNbaV0pO1xuICAgIH1cbiAgICB0bXBUZXh0LnVzZVN0eWxlKHN0eWxlKTtcbiAgICB0bXBUZXh0LnVwZGF0ZSgpO1xuICAgIHJldHVybiB0bXBUZXh0LmdldEJvdW5kaW5nUmVjdCgpO1xuICB9O1xuICByZXR1cm4gVGV4dFN0eWxlTWl4aW47XG59KCk7XG47XG5leHBvcnQgZGVmYXVsdCBUZXh0U3R5bGVNaXhpbjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBlbnYgZnJvbSAnenJlbmRlci9saWIvY29yZS9lbnYuanMnO1xuaW1wb3J0IHsgZW5hYmxlQ2xhc3NFeHRlbmQsIGVuYWJsZUNsYXNzQ2hlY2sgfSBmcm9tICcuLi91dGlsL2NsYXp6LmpzJztcbmltcG9ydCB7IEFyZWFTdHlsZU1peGluIH0gZnJvbSAnLi9taXhpbi9hcmVhU3R5bGUuanMnO1xuaW1wb3J0IFRleHRTdHlsZU1peGluIGZyb20gJy4vbWl4aW4vdGV4dFN0eWxlLmpzJztcbmltcG9ydCB7IExpbmVTdHlsZU1peGluIH0gZnJvbSAnLi9taXhpbi9saW5lU3R5bGUuanMnO1xuaW1wb3J0IHsgSXRlbVN0eWxlTWl4aW4gfSBmcm9tICcuL21peGluL2l0ZW1TdHlsZS5qcyc7XG5pbXBvcnQgeyBtaXhpbiwgY2xvbmUsIG1lcmdlIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbnZhciBNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1vZGVsKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpIHtcbiAgICB0aGlzLnBhcmVudE1vZGVsID0gcGFyZW50TW9kZWw7XG4gICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgICB0aGlzLm9wdGlvbiA9IG9wdGlvbjtcbiAgICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG4gICAgLy8gaWYgKHRoaXMuaW5pdCkge1xuICAgIC8vICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSA0KSB7XG4gICAgLy8gICAgICAgICB0aGlzLmluaXQob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGVsc2Uge1xuICAgIC8vICAgICAgICAgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gIH1cbiAgTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCkge1xuICAgIHZhciByZXN0ID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHJlc3RbX2kgLSAzXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBNZXJnZSB0aGUgaW5wdXQgb3B0aW9uIHRvIG1lLlxyXG4gICAqL1xuICBNb2RlbC5wcm90b3R5cGUubWVyZ2VPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgbWVyZ2UodGhpcy5vcHRpb24sIG9wdGlvbiwgdHJ1ZSk7XG4gIH07XG4gIC8vIGBwYXRoYCBjYW4gYmUgJ2EuYi5jJywgc28gdGhlIHJldHVybiB2YWx1ZSB0eXBlIGhhdmUgdG8gYmUgYE1vZGVsT3B0aW9uYFxuICAvLyBUT0RPOiBUWVBFIHN0cmljdCBrZXkgY2hlY2s/XG4gIC8vIGdldChwYXRoOiBzdHJpbmcgfCBzdHJpbmdbXSwgaWdub3JlUGFyZW50PzogYm9vbGVhbik6IE1vZGVsT3B0aW9uO1xuICBNb2RlbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhdGgsIGlnbm9yZVBhcmVudCkge1xuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RvR2V0KHRoaXMucGFyc2VQYXRoKHBhdGgpLCAhaWdub3JlUGFyZW50ICYmIHRoaXMucGFyZW50TW9kZWwpO1xuICB9O1xuICBNb2RlbC5wcm90b3R5cGUuZ2V0U2hhbGxvdyA9IGZ1bmN0aW9uIChrZXksIGlnbm9yZVBhcmVudCkge1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgdmFsID0gb3B0aW9uID09IG51bGwgPyBvcHRpb24gOiBvcHRpb25ba2V5XTtcbiAgICBpZiAodmFsID09IG51bGwgJiYgIWlnbm9yZVBhcmVudCkge1xuICAgICAgdmFyIHBhcmVudE1vZGVsID0gdGhpcy5wYXJlbnRNb2RlbDtcbiAgICAgIGlmIChwYXJlbnRNb2RlbCkge1xuICAgICAgICAvLyBGSVhNRTpUUyBkbyBub3Qga25vdyBob3cgdG8gbWFrZSBpdCB3b3Jrc1xuICAgICAgICB2YWwgPSBwYXJlbnRNb2RlbC5nZXRTaGFsbG93KGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH07XG4gIC8vIGBwYXRoYCBjYW4gYmUgJ2EuYi5jJywgc28gdGhlIHJldHVybiB2YWx1ZSB0eXBlIGhhdmUgdG8gYmUgYE1vZGVsPE1vZGVsT3B0aW9uPmBcbiAgLy8gZ2V0TW9kZWwocGF0aDogc3RyaW5nIHwgc3RyaW5nW10sIHBhcmVudE1vZGVsPzogTW9kZWwpOiBNb2RlbDtcbiAgLy8gVE9ETyAnYS5iLmMnIGlzIGRlcHJlY2F0ZWRcbiAgTW9kZWwucHJvdG90eXBlLmdldE1vZGVsID0gZnVuY3Rpb24gKHBhdGgsIHBhcmVudE1vZGVsKSB7XG4gICAgdmFyIGhhc1BhdGggPSBwYXRoICE9IG51bGw7XG4gICAgdmFyIHBhdGhGaW5hbCA9IGhhc1BhdGggPyB0aGlzLnBhcnNlUGF0aChwYXRoKSA6IG51bGw7XG4gICAgdmFyIG9iaiA9IGhhc1BhdGggPyB0aGlzLl9kb0dldChwYXRoRmluYWwpIDogdGhpcy5vcHRpb247XG4gICAgcGFyZW50TW9kZWwgPSBwYXJlbnRNb2RlbCB8fCB0aGlzLnBhcmVudE1vZGVsICYmIHRoaXMucGFyZW50TW9kZWwuZ2V0TW9kZWwodGhpcy5yZXNvbHZlUGFyZW50UGF0aChwYXRoRmluYWwpKTtcbiAgICByZXR1cm4gbmV3IE1vZGVsKG9iaiwgcGFyZW50TW9kZWwsIHRoaXMuZWNNb2RlbCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIElmIG1vZGVsIGhhcyBvcHRpb25cclxuICAgKi9cbiAgTW9kZWwucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uID09IG51bGw7XG4gIH07XG4gIE1vZGVsLnByb3RvdHlwZS5yZXN0b3JlRGF0YSA9IGZ1bmN0aW9uICgpIHt9O1xuICAvLyBQZW5kaW5nXG4gIE1vZGVsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgQ3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIG5ldyBDdG9yKGNsb25lKHRoaXMub3B0aW9uKSk7XG4gIH07XG4gIC8vIHNldFJlYWRPbmx5KHByb3BlcnRpZXMpOiB2b2lkIHtcbiAgLy8gY2xhenpVdGlsLnNldFJlYWRPbmx5KHRoaXMsIHByb3BlcnRpZXMpO1xuICAvLyB9XG4gIC8vIElmIHBhdGggaXMgbnVsbC91bmRlZmluZWQsIHJldHVybiBudWxsL3VuZGVmaW5lZC5cbiAgTW9kZWwucHJvdG90eXBlLnBhcnNlUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHBhdGguc3BsaXQoJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG4gIC8vIFJlc29sdmUgcGF0aCBmb3IgcGFyZW50LiBQZXJoYXBzIHVzZWZ1bCB3aGVuIHBhcmVudCB1c2UgYSBkaWZmZXJlbnQgcHJvcGVydHkuXG4gIC8vIERlZmF1bHQgdG8gYmUgYSBpZGVudGl0eSByZXNvbHZlci5cbiAgLy8gQ2FuIGJlIG1vZGlmaWVkIHRvIGEgZGlmZmVyZW50IHJlc29sdmVyLlxuICBNb2RlbC5wcm90b3R5cGUucmVzb2x2ZVBhcmVudFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuICAvLyBGSVhNRTpUUyBjaGVjayB3aGV0aGVyIHB1dCB0aGlzIG1ldGhvZCBoZXJlXG4gIE1vZGVsLnByb3RvdHlwZS5pc0FuaW1hdGlvbkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFlbnYubm9kZSAmJiB0aGlzLm9wdGlvbikge1xuICAgICAgaWYgKHRoaXMub3B0aW9uLmFuaW1hdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMub3B0aW9uLmFuaW1hdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnRNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIE1vZGVsLnByb3RvdHlwZS5fZG9HZXQgPSBmdW5jdGlvbiAocGF0aEFyciwgcGFyZW50TW9kZWwpIHtcbiAgICB2YXIgb2JqID0gdGhpcy5vcHRpb247XG4gICAgaWYgKCFwYXRoQXJyKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIElnbm9yZSBlbXB0eVxuICAgICAgaWYgKCFwYXRoQXJyW2ldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gb2JqIGNvdWxkIGJlIG51bWJlci9zdHJpbmcvLi4uIChsaWtlIDApXG4gICAgICBvYmogPSBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgPyBvYmpbcGF0aEFycltpXV0gOiBudWxsO1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqID09IG51bGwgJiYgcGFyZW50TW9kZWwpIHtcbiAgICAgIG9iaiA9IHBhcmVudE1vZGVsLl9kb0dldCh0aGlzLnJlc29sdmVQYXJlbnRQYXRoKHBhdGhBcnIpLCBwYXJlbnRNb2RlbC5wYXJlbnRNb2RlbCk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG4gIHJldHVybiBNb2RlbDtcbn0oKTtcbjtcbi8vIEVuYWJsZSBNb2RlbC5leHRlbmQuXG5lbmFibGVDbGFzc0V4dGVuZChNb2RlbCk7XG5lbmFibGVDbGFzc0NoZWNrKE1vZGVsKTtcbm1peGluKE1vZGVsLCBMaW5lU3R5bGVNaXhpbik7XG5taXhpbihNb2RlbCwgSXRlbVN0eWxlTWl4aW4pO1xubWl4aW4oTW9kZWwsIEFyZWFTdHlsZU1peGluKTtcbm1peGluKE1vZGVsLCBUZXh0U3R5bGVNaXhpbik7XG5leHBvcnQgZGVmYXVsdCBNb2RlbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///43172\n")},43353:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   k: () => (/* binding */ getTextRect)\n/* harmony export */ });\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32322);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction getTextRect(text, font, align, verticalAlign, padding, rich, truncate, lineHeight) {\n  var textEl = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay({\n    style: {\n      text: text,\n      font: font,\n      align: align,\n      verticalAlign: verticalAlign,\n      padding: padding,\n      rich: rich,\n      overflow: truncate ? \'truncate\' : null,\n      lineHeight: lineHeight\n    }\n  });\n  return textEl.getBoundingRect();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMzNTMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbGVnYWN5L2dldFRleHRSZWN0LmpzPzZjNGIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBUZXh0IH0gZnJvbSAnLi4vdXRpbC9ncmFwaGljLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0UmVjdCh0ZXh0LCBmb250LCBhbGlnbiwgdmVydGljYWxBbGlnbiwgcGFkZGluZywgcmljaCwgdHJ1bmNhdGUsIGxpbmVIZWlnaHQpIHtcbiAgdmFyIHRleHRFbCA9IG5ldyBUZXh0KHtcbiAgICBzdHlsZToge1xuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICBhbGlnbjogYWxpZ24sXG4gICAgICB2ZXJ0aWNhbEFsaWduOiB2ZXJ0aWNhbEFsaWduLFxuICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgIHJpY2g6IHJpY2gsXG4gICAgICBvdmVyZmxvdzogdHJ1bmNhdGUgPyAndHJ1bmNhdGUnIDogbnVsbCxcbiAgICAgIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHRcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGV4dEVsLmdldEJvdW5kaW5nUmVjdCgpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///43353\n')},47006:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar contrastColor = '#B9B8CE';\nvar backgroundColor = '#100C2A';\nvar axisCommon = function () {\n  return {\n    axisLine: {\n      lineStyle: {\n        color: contrastColor\n      }\n    },\n    splitLine: {\n      lineStyle: {\n        color: '#484753'\n      }\n    },\n    splitArea: {\n      areaStyle: {\n        color: ['rgba(255,255,255,0.02)', 'rgba(255,255,255,0.05)']\n      }\n    },\n    minorSplitLine: {\n      lineStyle: {\n        color: '#20203B'\n      }\n    }\n  };\n};\nvar colorPalette = ['#4992ff', '#7cffb2', '#fddd60', '#ff6e76', '#58d9f9', '#05c091', '#ff8a45', '#8d48e3', '#dd79ff'];\nvar theme = {\n  darkMode: true,\n  color: colorPalette,\n  backgroundColor: backgroundColor,\n  axisPointer: {\n    lineStyle: {\n      color: '#817f91'\n    },\n    crossStyle: {\n      color: '#817f91'\n    },\n    label: {\n      // TODO Contrast of label backgorundColor\n      color: '#fff'\n    }\n  },\n  legend: {\n    textStyle: {\n      color: contrastColor\n    },\n    pageTextStyle: {\n      color: contrastColor\n    }\n  },\n  textStyle: {\n    color: contrastColor\n  },\n  title: {\n    textStyle: {\n      color: '#EEF1FA'\n    },\n    subtextStyle: {\n      color: '#B9B8CE'\n    }\n  },\n  toolbox: {\n    iconStyle: {\n      borderColor: contrastColor\n    }\n  },\n  dataZoom: {\n    borderColor: '#71708A',\n    textStyle: {\n      color: contrastColor\n    },\n    brushStyle: {\n      color: 'rgba(135,163,206,0.3)'\n    },\n    handleStyle: {\n      color: '#353450',\n      borderColor: '#C5CBE3'\n    },\n    moveHandleStyle: {\n      color: '#B0B6C3',\n      opacity: 0.3\n    },\n    fillerColor: 'rgba(135,163,206,0.2)',\n    emphasis: {\n      handleStyle: {\n        borderColor: '#91B7F2',\n        color: '#4D587D'\n      },\n      moveHandleStyle: {\n        color: '#636D9A',\n        opacity: 0.7\n      }\n    },\n    dataBackground: {\n      lineStyle: {\n        color: '#71708A',\n        width: 1\n      },\n      areaStyle: {\n        color: '#71708A'\n      }\n    },\n    selectedDataBackground: {\n      lineStyle: {\n        color: '#87A3CE'\n      },\n      areaStyle: {\n        color: '#87A3CE'\n      }\n    }\n  },\n  visualMap: {\n    textStyle: {\n      color: contrastColor\n    }\n  },\n  timeline: {\n    lineStyle: {\n      color: contrastColor\n    },\n    label: {\n      color: contrastColor\n    },\n    controlStyle: {\n      color: contrastColor,\n      borderColor: contrastColor\n    }\n  },\n  calendar: {\n    itemStyle: {\n      color: backgroundColor\n    },\n    dayLabel: {\n      color: contrastColor\n    },\n    monthLabel: {\n      color: contrastColor\n    },\n    yearLabel: {\n      color: contrastColor\n    }\n  },\n  timeAxis: axisCommon(),\n  logAxis: axisCommon(),\n  valueAxis: axisCommon(),\n  categoryAxis: axisCommon(),\n  line: {\n    symbol: 'circle'\n  },\n  graph: {\n    color: colorPalette\n  },\n  gauge: {\n    title: {\n      color: contrastColor\n    },\n    axisLine: {\n      lineStyle: {\n        color: [[1, 'rgba(207,212,219,0.2)']]\n      }\n    },\n    axisLabel: {\n      color: contrastColor\n    },\n    detail: {\n      color: '#EEF1FA'\n    }\n  },\n  candlestick: {\n    itemStyle: {\n      color: '#f64e56',\n      color0: '#54ea92',\n      borderColor: '#f64e56',\n      borderColor0: '#54ea92'\n      // borderColor: '#ca2824',\n      // borderColor0: '#09a443'\n    }\n  }\n};\ntheme.categoryAxis.splitLine.show = false;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (theme);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcwMDYuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3RoZW1lL2RhcmsuanM/N2ZlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbnZhciBjb250cmFzdENvbG9yID0gJyNCOUI4Q0UnO1xudmFyIGJhY2tncm91bmRDb2xvciA9ICcjMTAwQzJBJztcbnZhciBheGlzQ29tbW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIGF4aXNMaW5lOiB7XG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgY29sb3I6IGNvbnRyYXN0Q29sb3JcbiAgICAgIH1cbiAgICB9LFxuICAgIHNwbGl0TGluZToge1xuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzQ4NDc1MydcbiAgICAgIH1cbiAgICB9LFxuICAgIHNwbGl0QXJlYToge1xuICAgICAgYXJlYVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiBbJ3JnYmEoMjU1LDI1NSwyNTUsMC4wMiknLCAncmdiYSgyNTUsMjU1LDI1NSwwLjA1KSddXG4gICAgICB9XG4gICAgfSxcbiAgICBtaW5vclNwbGl0TGluZToge1xuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzIwMjAzQidcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xudmFyIGNvbG9yUGFsZXR0ZSA9IFsnIzQ5OTJmZicsICcjN2NmZmIyJywgJyNmZGRkNjAnLCAnI2ZmNmU3NicsICcjNThkOWY5JywgJyMwNWMwOTEnLCAnI2ZmOGE0NScsICcjOGQ0OGUzJywgJyNkZDc5ZmYnXTtcbnZhciB0aGVtZSA9IHtcbiAgZGFya01vZGU6IHRydWUsXG4gIGNvbG9yOiBjb2xvclBhbGV0dGUsXG4gIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yLFxuICBheGlzUG9pbnRlcjoge1xuICAgIGxpbmVTdHlsZToge1xuICAgICAgY29sb3I6ICcjODE3ZjkxJ1xuICAgIH0sXG4gICAgY3Jvc3NTdHlsZToge1xuICAgICAgY29sb3I6ICcjODE3ZjkxJ1xuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgIC8vIFRPRE8gQ29udHJhc3Qgb2YgbGFiZWwgYmFja2dvcnVuZENvbG9yXG4gICAgICBjb2xvcjogJyNmZmYnXG4gICAgfVxuICB9LFxuICBsZWdlbmQ6IHtcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGNvbG9yOiBjb250cmFzdENvbG9yXG4gICAgfSxcbiAgICBwYWdlVGV4dFN0eWxlOiB7XG4gICAgICBjb2xvcjogY29udHJhc3RDb2xvclxuICAgIH1cbiAgfSxcbiAgdGV4dFN0eWxlOiB7XG4gICAgY29sb3I6IGNvbnRyYXN0Q29sb3JcbiAgfSxcbiAgdGl0bGU6IHtcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnI0VFRjFGQSdcbiAgICB9LFxuICAgIHN1YnRleHRTdHlsZToge1xuICAgICAgY29sb3I6ICcjQjlCOENFJ1xuICAgIH1cbiAgfSxcbiAgdG9vbGJveDoge1xuICAgIGljb25TdHlsZToge1xuICAgICAgYm9yZGVyQ29sb3I6IGNvbnRyYXN0Q29sb3JcbiAgICB9XG4gIH0sXG4gIGRhdGFab29tOiB7XG4gICAgYm9yZGVyQ29sb3I6ICcjNzE3MDhBJyxcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGNvbG9yOiBjb250cmFzdENvbG9yXG4gICAgfSxcbiAgICBicnVzaFN0eWxlOiB7XG4gICAgICBjb2xvcjogJ3JnYmEoMTM1LDE2MywyMDYsMC4zKSdcbiAgICB9LFxuICAgIGhhbmRsZVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyMzNTM0NTAnLFxuICAgICAgYm9yZGVyQ29sb3I6ICcjQzVDQkUzJ1xuICAgIH0sXG4gICAgbW92ZUhhbmRsZVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNCMEI2QzMnLFxuICAgICAgb3BhY2l0eTogMC4zXG4gICAgfSxcbiAgICBmaWxsZXJDb2xvcjogJ3JnYmEoMTM1LDE2MywyMDYsMC4yKScsXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIGhhbmRsZVN0eWxlOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzkxQjdGMicsXG4gICAgICAgIGNvbG9yOiAnIzRENTg3RCdcbiAgICAgIH0sXG4gICAgICBtb3ZlSGFuZGxlU3R5bGU6IHtcbiAgICAgICAgY29sb3I6ICcjNjM2RDlBJyxcbiAgICAgICAgb3BhY2l0eTogMC43XG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhQmFja2dyb3VuZDoge1xuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzcxNzA4QScsXG4gICAgICAgIHdpZHRoOiAxXG4gICAgICB9LFxuICAgICAgYXJlYVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzcxNzA4QSdcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdGVkRGF0YUJhY2tncm91bmQ6IHtcbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBjb2xvcjogJyM4N0EzQ0UnXG4gICAgICB9LFxuICAgICAgYXJlYVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzg3QTNDRSdcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHZpc3VhbE1hcDoge1xuICAgIHRleHRTdHlsZToge1xuICAgICAgY29sb3I6IGNvbnRyYXN0Q29sb3JcbiAgICB9XG4gIH0sXG4gIHRpbWVsaW5lOiB7XG4gICAgbGluZVN0eWxlOiB7XG4gICAgICBjb2xvcjogY29udHJhc3RDb2xvclxuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgIGNvbG9yOiBjb250cmFzdENvbG9yXG4gICAgfSxcbiAgICBjb250cm9sU3R5bGU6IHtcbiAgICAgIGNvbG9yOiBjb250cmFzdENvbG9yLFxuICAgICAgYm9yZGVyQ29sb3I6IGNvbnRyYXN0Q29sb3JcbiAgICB9XG4gIH0sXG4gIGNhbGVuZGFyOiB7XG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICBjb2xvcjogYmFja2dyb3VuZENvbG9yXG4gICAgfSxcbiAgICBkYXlMYWJlbDoge1xuICAgICAgY29sb3I6IGNvbnRyYXN0Q29sb3JcbiAgICB9LFxuICAgIG1vbnRoTGFiZWw6IHtcbiAgICAgIGNvbG9yOiBjb250cmFzdENvbG9yXG4gICAgfSxcbiAgICB5ZWFyTGFiZWw6IHtcbiAgICAgIGNvbG9yOiBjb250cmFzdENvbG9yXG4gICAgfVxuICB9LFxuICB0aW1lQXhpczogYXhpc0NvbW1vbigpLFxuICBsb2dBeGlzOiBheGlzQ29tbW9uKCksXG4gIHZhbHVlQXhpczogYXhpc0NvbW1vbigpLFxuICBjYXRlZ29yeUF4aXM6IGF4aXNDb21tb24oKSxcbiAgbGluZToge1xuICAgIHN5bWJvbDogJ2NpcmNsZSdcbiAgfSxcbiAgZ3JhcGg6IHtcbiAgICBjb2xvcjogY29sb3JQYWxldHRlXG4gIH0sXG4gIGdhdWdlOiB7XG4gICAgdGl0bGU6IHtcbiAgICAgIGNvbG9yOiBjb250cmFzdENvbG9yXG4gICAgfSxcbiAgICBheGlzTGluZToge1xuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiBbWzEsICdyZ2JhKDIwNywyMTIsMjE5LDAuMiknXV1cbiAgICAgIH1cbiAgICB9LFxuICAgIGF4aXNMYWJlbDoge1xuICAgICAgY29sb3I6IGNvbnRyYXN0Q29sb3JcbiAgICB9LFxuICAgIGRldGFpbDoge1xuICAgICAgY29sb3I6ICcjRUVGMUZBJ1xuICAgIH1cbiAgfSxcbiAgY2FuZGxlc3RpY2s6IHtcbiAgICBpdGVtU3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnI2Y2NGU1NicsXG4gICAgICBjb2xvcjA6ICcjNTRlYTkyJyxcbiAgICAgIGJvcmRlckNvbG9yOiAnI2Y2NGU1NicsXG4gICAgICBib3JkZXJDb2xvcjA6ICcjNTRlYTkyJ1xuICAgICAgLy8gYm9yZGVyQ29sb3I6ICcjY2EyODI0JyxcbiAgICAgIC8vIGJvcmRlckNvbG9yMDogJyMwOWE0NDMnXG4gICAgfVxuICB9XG59O1xudGhlbWUuY2F0ZWdvcnlBeGlzLnNwbGl0TGluZS5zaG93ID0gZmFsc2U7XG5leHBvcnQgZGVmYXVsdCB0aGVtZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///47006\n")},47355:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   U: () => (/* binding */ SERIES_UNIVERSAL_TRANSITION_PROP)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(98026);\n/* harmony import */ var zrender_lib_core_env_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(38123);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n/* harmony import */ var _Component_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(15915);\n/* harmony import */ var _mixin_palette_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(96501);\n/* harmony import */ var _model_mixin_dataFormat_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(9427);\n/* harmony import */ var _util_layout_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34253);\n/* harmony import */ var _core_task_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49431);\n/* harmony import */ var _util_clazz_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(30693);\n/* harmony import */ var _data_helper_sourceManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40972);\n/* harmony import */ var _component_tooltip_seriesFormatTooltip_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(4235);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\nvar inner = _util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r();\nfunction getSelectionKey(data, dataIndex) {\n  return data.getName(dataIndex) || data.getId(dataIndex);\n}\nvar SERIES_UNIVERSAL_TRANSITION_PROP = '__universalTransitionEnabled';\nvar SeriesModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .C6)(SeriesModel, _super);\n  function SeriesModel() {\n    // [Caution]: Because this class or desecendants can be used as `XXX.extend(subProto)`,\n    // the class members must not be initialized in constructor or declaration place.\n    // Otherwise there is bad case:\n    //   class A {xxx = 1;}\n    //   enableClassExtend(A);\n    //   class B extends A {}\n    //   var C = B.extend({xxx: 5});\n    //   var c = new C();\n    //   console.log(c.xxx); // expect 5 but always 1.\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    // ---------------------------------------\n    // Props about data selection\n    // ---------------------------------------\n    _this._selectedDataIndicesMap = {};\n    return _this;\n  }\n  SeriesModel.prototype.init = function (option, parentModel, ecModel) {\n    this.seriesIndex = this.componentIndex;\n    this.dataTask = (0,_core_task_js__WEBPACK_IMPORTED_MODULE_2__/* .createTask */ .U)({\n      count: dataTaskCount,\n      reset: dataTaskReset\n    });\n    this.dataTask.context = {\n      model: this\n    };\n    this.mergeDefaultAndTheme(option, ecModel);\n    var sourceManager = inner(this).sourceManager = new _data_helper_sourceManager_js__WEBPACK_IMPORTED_MODULE_3__/* .SourceManager */ .R(this);\n    sourceManager.prepareSource();\n    var data = this.getInitialData(option, ecModel);\n    wrapData(data, this);\n    this.dataTask.context.data = data;\n    if (false) {}\n    inner(this).dataBeforeProcessed = data;\n    // If we reverse the order (make data firstly, and then make\n    // dataBeforeProcessed by cloneShallow), cloneShallow will\n    // cause data.graph.data !== data when using\n    // module:echarts/data/Graph or module:echarts/data/Tree.\n    // See module:echarts/data/helper/linkSeriesData\n    // Theoretically, it is unreasonable to call `seriesModel.getData()` in the model\n    // init or merge stage, because the data can be restored. So we do not `restoreData`\n    // and `setData` here, which forbids calling `seriesModel.getData()` in this stage.\n    // Call `seriesModel.getRawData()` instead.\n    // this.restoreData();\n    autoSeriesName(this);\n    this._initSelectedMapFromData(data);\n  };\n  /**\r\n   * Util for merge default and theme to option\r\n   */\n  SeriesModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {\n    var layoutMode = (0,_util_layout_js__WEBPACK_IMPORTED_MODULE_4__/* .fetchLayoutMode */ .ad)(this);\n    var inputPositionParams = layoutMode ? (0,_util_layout_js__WEBPACK_IMPORTED_MODULE_4__/* .getLayoutParams */ .vs)(option) : {};\n    // Backward compat: using subType on theme.\n    // But if name duplicate between series subType\n    // (for example: parallel) add component mainType,\n    // add suffix 'Series'.\n    var themeSubType = this.subType;\n    if (_Component_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A.hasClass(themeSubType)) {\n      themeSubType += 'Series';\n    }\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.merge(option, ecModel.getTheme().get(this.subType));\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.merge(option, this.getDefaultOption());\n    // Default label emphasis `show`\n    _util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .defaultEmphasis */ .M5(option, 'label', ['show']);\n    this.fillDataTextStyle(option.data);\n    if (layoutMode) {\n      (0,_util_layout_js__WEBPACK_IMPORTED_MODULE_4__/* .mergeLayoutParam */ .YA)(option, inputPositionParams, layoutMode);\n    }\n  };\n  SeriesModel.prototype.mergeOption = function (newSeriesOption, ecModel) {\n    // this.settingTask.dirty();\n    newSeriesOption = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.merge(this.option, newSeriesOption, true);\n    this.fillDataTextStyle(newSeriesOption.data);\n    var layoutMode = (0,_util_layout_js__WEBPACK_IMPORTED_MODULE_4__/* .fetchLayoutMode */ .ad)(this);\n    if (layoutMode) {\n      (0,_util_layout_js__WEBPACK_IMPORTED_MODULE_4__/* .mergeLayoutParam */ .YA)(this.option, newSeriesOption, layoutMode);\n    }\n    var sourceManager = inner(this).sourceManager;\n    sourceManager.dirty();\n    sourceManager.prepareSource();\n    var data = this.getInitialData(newSeriesOption, ecModel);\n    wrapData(data, this);\n    this.dataTask.dirty();\n    this.dataTask.context.data = data;\n    inner(this).dataBeforeProcessed = data;\n    autoSeriesName(this);\n    this._initSelectedMapFromData(data);\n  };\n  SeriesModel.prototype.fillDataTextStyle = function (data) {\n    // Default data label emphasis `show`\n    // FIXME Tree structure data ?\n    // FIXME Performance ?\n    if (data && !zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.isTypedArray(data)) {\n      var props = ['show'];\n      for (var i = 0; i < data.length; i++) {\n        if (data[i] && data[i].label) {\n          _util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .defaultEmphasis */ .M5(data[i], 'label', props);\n        }\n      }\n    }\n  };\n  /**\r\n   * Init a data structure from data related option in series\r\n   * Must be overridden.\r\n   */\n  SeriesModel.prototype.getInitialData = function (option, ecModel) {\n    return;\n  };\n  /**\r\n   * Append data to list\r\n   */\n  SeriesModel.prototype.appendData = function (params) {\n    // FIXME ???\n    // (1) If data from dataset, forbidden append.\n    // (2) support append data of dataset.\n    var data = this.getRawData();\n    data.appendData(params.data);\n  };\n  /**\r\n   * Consider some method like `filter`, `map` need make new data,\r\n   * We should make sure that `seriesModel.getData()` get correct\r\n   * data in the stream procedure. So we fetch data from upstream\r\n   * each time `task.perform` called.\r\n   */\n  SeriesModel.prototype.getData = function (dataType) {\n    var task = getCurrentTask(this);\n    if (task) {\n      var data = task.context.data;\n      return dataType == null || !data.getLinkedData ? data : data.getLinkedData(dataType);\n    } else {\n      // When series is not alive (that may happen when click toolbox\n      // restore or setOption with not merge mode), series data may\n      // be still need to judge animation or something when graphic\n      // elements want to know whether fade out.\n      return inner(this).data;\n    }\n  };\n  SeriesModel.prototype.getAllData = function () {\n    var mainData = this.getData();\n    return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{\n      data: mainData\n    }];\n  };\n  SeriesModel.prototype.setData = function (data) {\n    var task = getCurrentTask(this);\n    if (task) {\n      var context = task.context;\n      // Consider case: filter, data sample.\n      // FIXME:TS never used, so comment it\n      // if (context.data !== data && task.modifyOutputEnd) {\n      //     task.setOutputEnd(data.count());\n      // }\n      context.outputData = data;\n      // Caution: setData should update context.data,\n      // Because getData may be called multiply in a\n      // single stage and expect to get the data just\n      // set. (For example, AxisProxy, x y both call\n      // getData and setDate sequentially).\n      // So the context.data should be fetched from\n      // upstream each time when a stage starts to be\n      // performed.\n      if (task !== this.dataTask) {\n        context.data = data;\n      }\n    }\n    inner(this).data = data;\n  };\n  SeriesModel.prototype.getEncode = function () {\n    var encode = this.get('encode', true);\n    if (encode) {\n      return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.createHashMap(encode);\n    }\n  };\n  SeriesModel.prototype.getSourceManager = function () {\n    return inner(this).sourceManager;\n  };\n  SeriesModel.prototype.getSource = function () {\n    return this.getSourceManager().getSource();\n  };\n  /**\r\n   * Get data before processed\r\n   */\n  SeriesModel.prototype.getRawData = function () {\n    return inner(this).dataBeforeProcessed;\n  };\n  SeriesModel.prototype.getColorBy = function () {\n    var colorBy = this.get('colorBy');\n    return colorBy || 'series';\n  };\n  SeriesModel.prototype.isColorBySeries = function () {\n    return this.getColorBy() === 'series';\n  };\n  /**\r\n   * Get base axis if has coordinate system and has axis.\r\n   * By default use coordSys.getBaseAxis();\r\n   * Can be overridden for some chart.\r\n   * @return {type} description\r\n   */\n  SeriesModel.prototype.getBaseAxis = function () {\n    var coordSys = this.coordinateSystem;\n    // @ts-ignore\n    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n  };\n  /**\r\n   * Default tooltip formatter\r\n   *\r\n   * @param dataIndex\r\n   * @param multipleSeries\r\n   * @param dataType\r\n   * @param renderMode valid values: 'html'(by default) and 'richText'.\r\n   *        'html' is used for rendering tooltip in extra DOM form, and the result\r\n   *        string is used as DOM HTML content.\r\n   *        'richText' is used for rendering tooltip in rich text form, for those where\r\n   *        DOM operation is not supported.\r\n   * @return formatted tooltip with `html` and `markers`\r\n   *        Notice: The override method can also return string\r\n   */\n  SeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n    return (0,_component_tooltip_seriesFormatTooltip_js__WEBPACK_IMPORTED_MODULE_7__/* .defaultSeriesFormatTooltip */ .J)({\n      series: this,\n      dataIndex: dataIndex,\n      multipleSeries: multipleSeries\n    });\n  };\n  SeriesModel.prototype.isAnimationEnabled = function () {\n    var ecModel = this.ecModel;\n    // Disable animation if using echarts in node but not give ssr flag.\n    // In ssr mode, renderToString will generate svg with css animation.\n    if (zrender_lib_core_env_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .A.node && !(ecModel && ecModel.ssr)) {\n      return false;\n    }\n    var animationEnabled = this.getShallow('animation');\n    if (animationEnabled) {\n      if (this.getData().count() > this.getShallow('animationThreshold')) {\n        animationEnabled = false;\n      }\n    }\n    return !!animationEnabled;\n  };\n  SeriesModel.prototype.restoreData = function () {\n    this.dataTask.dirty();\n  };\n  SeriesModel.prototype.getColorFromPalette = function (name, scope, requestColorNum) {\n    var ecModel = this.ecModel;\n    // PENDING\n    var color = _mixin_palette_js__WEBPACK_IMPORTED_MODULE_9__/* .PaletteMixin */ .X.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);\n    if (!color) {\n      color = ecModel.getColorFromPalette(name, scope, requestColorNum);\n    }\n    return color;\n  };\n  /**\r\n   * Use `data.mapDimensionsAll(coordDim)` instead.\r\n   * @deprecated\r\n   */\n  SeriesModel.prototype.coordDimToDataDim = function (coordDim) {\n    return this.getRawData().mapDimensionsAll(coordDim);\n  };\n  /**\r\n   * Get progressive rendering count each step\r\n   */\n  SeriesModel.prototype.getProgressive = function () {\n    return this.get('progressive');\n  };\n  /**\r\n   * Get progressive rendering count each step\r\n   */\n  SeriesModel.prototype.getProgressiveThreshold = function () {\n    return this.get('progressiveThreshold');\n  };\n  // PENGING If selectedMode is null ?\n  SeriesModel.prototype.select = function (innerDataIndices, dataType) {\n    this._innerSelect(this.getData(dataType), innerDataIndices);\n  };\n  SeriesModel.prototype.unselect = function (innerDataIndices, dataType) {\n    var selectedMap = this.option.selectedMap;\n    if (!selectedMap) {\n      return;\n    }\n    var selectedMode = this.option.selectedMode;\n    var data = this.getData(dataType);\n    if (selectedMode === 'series' || selectedMap === 'all') {\n      this.option.selectedMap = {};\n      this._selectedDataIndicesMap = {};\n      return;\n    }\n    for (var i = 0; i < innerDataIndices.length; i++) {\n      var dataIndex = innerDataIndices[i];\n      var nameOrId = getSelectionKey(data, dataIndex);\n      selectedMap[nameOrId] = false;\n      this._selectedDataIndicesMap[nameOrId] = -1;\n    }\n  };\n  SeriesModel.prototype.toggleSelect = function (innerDataIndices, dataType) {\n    var tmpArr = [];\n    for (var i = 0; i < innerDataIndices.length; i++) {\n      tmpArr[0] = innerDataIndices[i];\n      this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr, dataType) : this.select(tmpArr, dataType);\n    }\n  };\n  SeriesModel.prototype.getSelectedDataIndices = function () {\n    if (this.option.selectedMap === 'all') {\n      return [].slice.call(this.getData().getIndices());\n    }\n    var selectedDataIndicesMap = this._selectedDataIndicesMap;\n    var nameOrIds = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.keys(selectedDataIndicesMap);\n    var dataIndices = [];\n    for (var i = 0; i < nameOrIds.length; i++) {\n      var dataIndex = selectedDataIndicesMap[nameOrIds[i]];\n      if (dataIndex >= 0) {\n        dataIndices.push(dataIndex);\n      }\n    }\n    return dataIndices;\n  };\n  SeriesModel.prototype.isSelected = function (dataIndex, dataType) {\n    var selectedMap = this.option.selectedMap;\n    if (!selectedMap) {\n      return false;\n    }\n    var data = this.getData(dataType);\n    return (selectedMap === 'all' || selectedMap[getSelectionKey(data, dataIndex)]) && !data.getItemModel(dataIndex).get(['select', 'disabled']);\n  };\n  SeriesModel.prototype.isUniversalTransitionEnabled = function () {\n    if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) {\n      return true;\n    }\n    var universalTransitionOpt = this.option.universalTransition;\n    // Quick reject\n    if (!universalTransitionOpt) {\n      return false;\n    }\n    if (universalTransitionOpt === true) {\n      return true;\n    }\n    // Can be simply 'universalTransition: true'\n    return universalTransitionOpt && universalTransitionOpt.enabled;\n  };\n  SeriesModel.prototype._innerSelect = function (data, innerDataIndices) {\n    var _a, _b;\n    var option = this.option;\n    var selectedMode = option.selectedMode;\n    var len = innerDataIndices.length;\n    if (!selectedMode || !len) {\n      return;\n    }\n    if (selectedMode === 'series') {\n      option.selectedMap = 'all';\n    } else if (selectedMode === 'multiple') {\n      if (!zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.isObject(option.selectedMap)) {\n        option.selectedMap = {};\n      }\n      var selectedMap = option.selectedMap;\n      for (var i = 0; i < len; i++) {\n        var dataIndex = innerDataIndices[i];\n        // TODO different types of data share same object.\n        var nameOrId = getSelectionKey(data, dataIndex);\n        selectedMap[nameOrId] = true;\n        this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);\n      }\n    } else if (selectedMode === 'single' || selectedMode === true) {\n      var lastDataIndex = innerDataIndices[len - 1];\n      var nameOrId = getSelectionKey(data, lastDataIndex);\n      option.selectedMap = (_a = {}, _a[nameOrId] = true, _a);\n      this._selectedDataIndicesMap = (_b = {}, _b[nameOrId] = data.getRawIndex(lastDataIndex), _b);\n    }\n  };\n  SeriesModel.prototype._initSelectedMapFromData = function (data) {\n    // Ignore select info in data if selectedMap exists.\n    // NOTE It's only for legacy usage. edge data is not supported.\n    if (this.option.selectedMap) {\n      return;\n    }\n    var dataIndices = [];\n    if (data.hasItemOption) {\n      data.each(function (idx) {\n        var rawItem = data.getRawDataItem(idx);\n        if (rawItem && rawItem.selected) {\n          dataIndices.push(idx);\n        }\n      });\n    }\n    if (dataIndices.length > 0) {\n      this._innerSelect(data, dataIndices);\n    }\n  };\n  // /**\n  //  * @see {module:echarts/stream/Scheduler}\n  //  */\n  // abstract pipeTask: null\n  SeriesModel.registerClass = function (clz) {\n    return _Component_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A.registerClass(clz);\n  };\n  SeriesModel.protoInitialize = function () {\n    var proto = SeriesModel.prototype;\n    proto.type = 'series.__base__';\n    proto.seriesIndex = 0;\n    proto.ignoreStyleOnData = false;\n    proto.hasSymbolVisual = false;\n    proto.defaultSymbol = 'circle';\n    // Make sure the values can be accessed!\n    proto.visualStyleAccessPath = 'itemStyle';\n    proto.visualDrawType = 'fill';\n  }();\n  return SeriesModel;\n}(_Component_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A);\nzrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.mixin(SeriesModel, _model_mixin_dataFormat_js__WEBPACK_IMPORTED_MODULE_10__/* .DataFormatMixin */ .J);\nzrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.mixin(SeriesModel, _mixin_palette_js__WEBPACK_IMPORTED_MODULE_9__/* .PaletteMixin */ .X);\n(0,_util_clazz_js__WEBPACK_IMPORTED_MODULE_11__/* .mountExtend */ .q7)(SeriesModel, _Component_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A);\n/**\r\n * MUST be called after `prepareSource` called\r\n * Here we need to make auto series, especially for auto legend. But we\r\n * do not modify series.name in option to avoid side effects.\r\n */\nfunction autoSeriesName(seriesModel) {\n  // User specified name has higher priority, otherwise it may cause\n  // series can not be queried unexpectedly.\n  var name = seriesModel.name;\n  if (!_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .isNameSpecified */ .O0(seriesModel)) {\n    seriesModel.name = getSeriesAutoName(seriesModel) || name;\n  }\n}\nfunction getSeriesAutoName(seriesModel) {\n  var data = seriesModel.getRawData();\n  var dataDims = data.mapDimensionsAll('seriesName');\n  var nameArr = [];\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.each(dataDims, function (dataDim) {\n    var dimInfo = data.getDimensionInfo(dataDim);\n    dimInfo.displayName && nameArr.push(dimInfo.displayName);\n  });\n  return nameArr.join(' ');\n}\nfunction dataTaskCount(context) {\n  return context.model.getRawData().count();\n}\nfunction dataTaskReset(context) {\n  var seriesModel = context.model;\n  seriesModel.setData(seriesModel.getRawData().cloneShallow());\n  return dataTaskProgress;\n}\nfunction dataTaskProgress(param, context) {\n  // Avoid repeat cloneShallow when data just created in reset.\n  if (context.outputData && param.end > context.outputData.count()) {\n    context.model.getRawData().cloneShallow(context.outputData);\n  }\n}\n// TODO refactor\nfunction wrapData(data, seriesModel) {\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.each(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.concatArray(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function (methodName) {\n    data.wrapMethod(methodName, zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.curry(onDataChange, seriesModel));\n  });\n}\nfunction onDataChange(seriesModel, newList) {\n  var task = getCurrentTask(seriesModel);\n  if (task) {\n    // Consider case: filter, selectRange\n    task.setOutputEnd((newList || this).count());\n  }\n  return newList;\n}\nfunction getCurrentTask(seriesModel) {\n  var scheduler = (seriesModel.ecModel || {}).scheduler;\n  var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);\n  if (pipeline) {\n    // When pipline finished, the currrentTask keep the last\n    // task (renderTask).\n    var task = pipeline.currentTask;\n    if (task) {\n      var agentStubMap = task.agentStubMap;\n      if (agentStubMap) {\n        task = agentStubMap.get(seriesModel.uid);\n      }\n    }\n    return task;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SeriesModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDczNTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9TZXJpZXMuanM/NmZhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgZW52IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvZW52LmpzJztcbmltcG9ydCAqIGFzIG1vZGVsVXRpbCBmcm9tICcuLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCBDb21wb25lbnRNb2RlbCBmcm9tICcuL0NvbXBvbmVudC5qcyc7XG5pbXBvcnQgeyBQYWxldHRlTWl4aW4gfSBmcm9tICcuL21peGluL3BhbGV0dGUuanMnO1xuaW1wb3J0IHsgRGF0YUZvcm1hdE1peGluIH0gZnJvbSAnLi4vbW9kZWwvbWl4aW4vZGF0YUZvcm1hdC5qcyc7XG5pbXBvcnQgeyBnZXRMYXlvdXRQYXJhbXMsIG1lcmdlTGF5b3V0UGFyYW0sIGZldGNoTGF5b3V0TW9kZSB9IGZyb20gJy4uL3V0aWwvbGF5b3V0LmpzJztcbmltcG9ydCB7IGNyZWF0ZVRhc2sgfSBmcm9tICcuLi9jb3JlL3Rhc2suanMnO1xuaW1wb3J0IHsgbW91bnRFeHRlbmQgfSBmcm9tICcuLi91dGlsL2NsYXp6LmpzJztcbmltcG9ydCB7IFNvdXJjZU1hbmFnZXIgfSBmcm9tICcuLi9kYXRhL2hlbHBlci9zb3VyY2VNYW5hZ2VyLmpzJztcbmltcG9ydCB7IGRlZmF1bHRTZXJpZXNGb3JtYXRUb29sdGlwIH0gZnJvbSAnLi4vY29tcG9uZW50L3Rvb2x0aXAvc2VyaWVzRm9ybWF0VG9vbHRpcC5qcyc7XG52YXIgaW5uZXIgPSBtb2RlbFV0aWwubWFrZUlubmVyKCk7XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25LZXkoZGF0YSwgZGF0YUluZGV4KSB7XG4gIHJldHVybiBkYXRhLmdldE5hbWUoZGF0YUluZGV4KSB8fCBkYXRhLmdldElkKGRhdGFJbmRleCk7XG59XG5leHBvcnQgdmFyIFNFUklFU19VTklWRVJTQUxfVFJBTlNJVElPTl9QUk9QID0gJ19fdW5pdmVyc2FsVHJhbnNpdGlvbkVuYWJsZWQnO1xudmFyIFNlcmllc01vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNlcmllc01vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBTZXJpZXNNb2RlbCgpIHtcbiAgICAvLyBbQ2F1dGlvbl06IEJlY2F1c2UgdGhpcyBjbGFzcyBvciBkZXNlY2VuZGFudHMgY2FuIGJlIHVzZWQgYXMgYFhYWC5leHRlbmQoc3ViUHJvdG8pYCxcbiAgICAvLyB0aGUgY2xhc3MgbWVtYmVycyBtdXN0IG5vdCBiZSBpbml0aWFsaXplZCBpbiBjb25zdHJ1Y3RvciBvciBkZWNsYXJhdGlvbiBwbGFjZS5cbiAgICAvLyBPdGhlcndpc2UgdGhlcmUgaXMgYmFkIGNhc2U6XG4gICAgLy8gICBjbGFzcyBBIHt4eHggPSAxO31cbiAgICAvLyAgIGVuYWJsZUNsYXNzRXh0ZW5kKEEpO1xuICAgIC8vICAgY2xhc3MgQiBleHRlbmRzIEEge31cbiAgICAvLyAgIHZhciBDID0gQi5leHRlbmQoe3h4eDogNX0pO1xuICAgIC8vICAgdmFyIGMgPSBuZXcgQygpO1xuICAgIC8vICAgY29uc29sZS5sb2coYy54eHgpOyAvLyBleHBlY3QgNSBidXQgYWx3YXlzIDEuXG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUHJvcHMgYWJvdXQgZGF0YSBzZWxlY3Rpb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBfdGhpcy5fc2VsZWN0ZWREYXRhSW5kaWNlc01hcCA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBTZXJpZXNNb2RlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgdGhpcy5zZXJpZXNJbmRleCA9IHRoaXMuY29tcG9uZW50SW5kZXg7XG4gICAgdGhpcy5kYXRhVGFzayA9IGNyZWF0ZVRhc2soe1xuICAgICAgY291bnQ6IGRhdGFUYXNrQ291bnQsXG4gICAgICByZXNldDogZGF0YVRhc2tSZXNldFxuICAgIH0pO1xuICAgIHRoaXMuZGF0YVRhc2suY29udGV4dCA9IHtcbiAgICAgIG1vZGVsOiB0aGlzXG4gICAgfTtcbiAgICB0aGlzLm1lcmdlRGVmYXVsdEFuZFRoZW1lKG9wdGlvbiwgZWNNb2RlbCk7XG4gICAgdmFyIHNvdXJjZU1hbmFnZXIgPSBpbm5lcih0aGlzKS5zb3VyY2VNYW5hZ2VyID0gbmV3IFNvdXJjZU1hbmFnZXIodGhpcyk7XG4gICAgc291cmNlTWFuYWdlci5wcmVwYXJlU291cmNlKCk7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldEluaXRpYWxEYXRhKG9wdGlvbiwgZWNNb2RlbCk7XG4gICAgd3JhcERhdGEoZGF0YSwgdGhpcyk7XG4gICAgdGhpcy5kYXRhVGFzay5jb250ZXh0LmRhdGEgPSBkYXRhO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB6clV0aWwuYXNzZXJ0KGRhdGEsICdnZXRJbml0aWFsRGF0YSByZXR1cm5lZCBpbnZhbGlkIGRhdGEuJyk7XG4gICAgfVxuICAgIGlubmVyKHRoaXMpLmRhdGFCZWZvcmVQcm9jZXNzZWQgPSBkYXRhO1xuICAgIC8vIElmIHdlIHJldmVyc2UgdGhlIG9yZGVyIChtYWtlIGRhdGEgZmlyc3RseSwgYW5kIHRoZW4gbWFrZVxuICAgIC8vIGRhdGFCZWZvcmVQcm9jZXNzZWQgYnkgY2xvbmVTaGFsbG93KSwgY2xvbmVTaGFsbG93IHdpbGxcbiAgICAvLyBjYXVzZSBkYXRhLmdyYXBoLmRhdGEgIT09IGRhdGEgd2hlbiB1c2luZ1xuICAgIC8vIG1vZHVsZTplY2hhcnRzL2RhdGEvR3JhcGggb3IgbW9kdWxlOmVjaGFydHMvZGF0YS9UcmVlLlxuICAgIC8vIFNlZSBtb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9saW5rU2VyaWVzRGF0YVxuICAgIC8vIFRoZW9yZXRpY2FsbHksIGl0IGlzIHVucmVhc29uYWJsZSB0byBjYWxsIGBzZXJpZXNNb2RlbC5nZXREYXRhKClgIGluIHRoZSBtb2RlbFxuICAgIC8vIGluaXQgb3IgbWVyZ2Ugc3RhZ2UsIGJlY2F1c2UgdGhlIGRhdGEgY2FuIGJlIHJlc3RvcmVkLiBTbyB3ZSBkbyBub3QgYHJlc3RvcmVEYXRhYFxuICAgIC8vIGFuZCBgc2V0RGF0YWAgaGVyZSwgd2hpY2ggZm9yYmlkcyBjYWxsaW5nIGBzZXJpZXNNb2RlbC5nZXREYXRhKClgIGluIHRoaXMgc3RhZ2UuXG4gICAgLy8gQ2FsbCBgc2VyaWVzTW9kZWwuZ2V0UmF3RGF0YSgpYCBpbnN0ZWFkLlxuICAgIC8vIHRoaXMucmVzdG9yZURhdGEoKTtcbiAgICBhdXRvU2VyaWVzTmFtZSh0aGlzKTtcbiAgICB0aGlzLl9pbml0U2VsZWN0ZWRNYXBGcm9tRGF0YShkYXRhKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVXRpbCBmb3IgbWVyZ2UgZGVmYXVsdCBhbmQgdGhlbWUgdG8gb3B0aW9uXHJcbiAgICovXG4gIFNlcmllc01vZGVsLnByb3RvdHlwZS5tZXJnZURlZmF1bHRBbmRUaGVtZSA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICB2YXIgbGF5b3V0TW9kZSA9IGZldGNoTGF5b3V0TW9kZSh0aGlzKTtcbiAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGxheW91dE1vZGUgPyBnZXRMYXlvdXRQYXJhbXMob3B0aW9uKSA6IHt9O1xuICAgIC8vIEJhY2t3YXJkIGNvbXBhdDogdXNpbmcgc3ViVHlwZSBvbiB0aGVtZS5cbiAgICAvLyBCdXQgaWYgbmFtZSBkdXBsaWNhdGUgYmV0d2VlbiBzZXJpZXMgc3ViVHlwZVxuICAgIC8vIChmb3IgZXhhbXBsZTogcGFyYWxsZWwpIGFkZCBjb21wb25lbnQgbWFpblR5cGUsXG4gICAgLy8gYWRkIHN1ZmZpeCAnU2VyaWVzJy5cbiAgICB2YXIgdGhlbWVTdWJUeXBlID0gdGhpcy5zdWJUeXBlO1xuICAgIGlmIChDb21wb25lbnRNb2RlbC5oYXNDbGFzcyh0aGVtZVN1YlR5cGUpKSB7XG4gICAgICB0aGVtZVN1YlR5cGUgKz0gJ1Nlcmllcyc7XG4gICAgfVxuICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIGVjTW9kZWwuZ2V0VGhlbWUoKS5nZXQodGhpcy5zdWJUeXBlKSk7XG4gICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhpcy5nZXREZWZhdWx0T3B0aW9uKCkpO1xuICAgIC8vIERlZmF1bHQgbGFiZWwgZW1waGFzaXMgYHNob3dgXG4gICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyhvcHRpb24sICdsYWJlbCcsIFsnc2hvdyddKTtcbiAgICB0aGlzLmZpbGxEYXRhVGV4dFN0eWxlKG9wdGlvbi5kYXRhKTtcbiAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgbWVyZ2VMYXlvdXRQYXJhbShvcHRpb24sIGlucHV0UG9zaXRpb25QYXJhbXMsIGxheW91dE1vZGUpO1xuICAgIH1cbiAgfTtcbiAgU2VyaWVzTW9kZWwucHJvdG90eXBlLm1lcmdlT3B0aW9uID0gZnVuY3Rpb24gKG5ld1Nlcmllc09wdGlvbiwgZWNNb2RlbCkge1xuICAgIC8vIHRoaXMuc2V0dGluZ1Rhc2suZGlydHkoKTtcbiAgICBuZXdTZXJpZXNPcHRpb24gPSB6clV0aWwubWVyZ2UodGhpcy5vcHRpb24sIG5ld1Nlcmllc09wdGlvbiwgdHJ1ZSk7XG4gICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShuZXdTZXJpZXNPcHRpb24uZGF0YSk7XG4gICAgdmFyIGxheW91dE1vZGUgPSBmZXRjaExheW91dE1vZGUodGhpcyk7XG4gICAgaWYgKGxheW91dE1vZGUpIHtcbiAgICAgIG1lcmdlTGF5b3V0UGFyYW0odGhpcy5vcHRpb24sIG5ld1Nlcmllc09wdGlvbiwgbGF5b3V0TW9kZSk7XG4gICAgfVxuICAgIHZhciBzb3VyY2VNYW5hZ2VyID0gaW5uZXIodGhpcykuc291cmNlTWFuYWdlcjtcbiAgICBzb3VyY2VNYW5hZ2VyLmRpcnR5KCk7XG4gICAgc291cmNlTWFuYWdlci5wcmVwYXJlU291cmNlKCk7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldEluaXRpYWxEYXRhKG5ld1Nlcmllc09wdGlvbiwgZWNNb2RlbCk7XG4gICAgd3JhcERhdGEoZGF0YSwgdGhpcyk7XG4gICAgdGhpcy5kYXRhVGFzay5kaXJ0eSgpO1xuICAgIHRoaXMuZGF0YVRhc2suY29udGV4dC5kYXRhID0gZGF0YTtcbiAgICBpbm5lcih0aGlzKS5kYXRhQmVmb3JlUHJvY2Vzc2VkID0gZGF0YTtcbiAgICBhdXRvU2VyaWVzTmFtZSh0aGlzKTtcbiAgICB0aGlzLl9pbml0U2VsZWN0ZWRNYXBGcm9tRGF0YShkYXRhKTtcbiAgfTtcbiAgU2VyaWVzTW9kZWwucHJvdG90eXBlLmZpbGxEYXRhVGV4dFN0eWxlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAvLyBEZWZhdWx0IGRhdGEgbGFiZWwgZW1waGFzaXMgYHNob3dgXG4gICAgLy8gRklYTUUgVHJlZSBzdHJ1Y3R1cmUgZGF0YSA/XG4gICAgLy8gRklYTUUgUGVyZm9ybWFuY2UgP1xuICAgIGlmIChkYXRhICYmICF6clV0aWwuaXNUeXBlZEFycmF5KGRhdGEpKSB7XG4gICAgICB2YXIgcHJvcHMgPSBbJ3Nob3cnXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGF0YVtpXSAmJiBkYXRhW2ldLmxhYmVsKSB7XG4gICAgICAgICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyhkYXRhW2ldLCAnbGFiZWwnLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEluaXQgYSBkYXRhIHN0cnVjdHVyZSBmcm9tIGRhdGEgcmVsYXRlZCBvcHRpb24gaW4gc2VyaWVzXHJcbiAgICogTXVzdCBiZSBvdmVycmlkZGVuLlxyXG4gICAqL1xuICBTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGEgPSBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgcmV0dXJuO1xuICB9O1xuICAvKipcclxuICAgKiBBcHBlbmQgZGF0YSB0byBsaXN0XHJcbiAgICovXG4gIFNlcmllc01vZGVsLnByb3RvdHlwZS5hcHBlbmREYXRhID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIC8vIEZJWE1FID8/P1xuICAgIC8vICgxKSBJZiBkYXRhIGZyb20gZGF0YXNldCwgZm9yYmlkZGVuIGFwcGVuZC5cbiAgICAvLyAoMikgc3VwcG9ydCBhcHBlbmQgZGF0YSBvZiBkYXRhc2V0LlxuICAgIHZhciBkYXRhID0gdGhpcy5nZXRSYXdEYXRhKCk7XG4gICAgZGF0YS5hcHBlbmREYXRhKHBhcmFtcy5kYXRhKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ29uc2lkZXIgc29tZSBtZXRob2QgbGlrZSBgZmlsdGVyYCwgYG1hcGAgbmVlZCBtYWtlIG5ldyBkYXRhLFxyXG4gICAqIFdlIHNob3VsZCBtYWtlIHN1cmUgdGhhdCBgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpYCBnZXQgY29ycmVjdFxyXG4gICAqIGRhdGEgaW4gdGhlIHN0cmVhbSBwcm9jZWR1cmUuIFNvIHdlIGZldGNoIGRhdGEgZnJvbSB1cHN0cmVhbVxyXG4gICAqIGVhY2ggdGltZSBgdGFzay5wZXJmb3JtYCBjYWxsZWQuXHJcbiAgICovXG4gIFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKGRhdGFUeXBlKSB7XG4gICAgdmFyIHRhc2sgPSBnZXRDdXJyZW50VGFzayh0aGlzKTtcbiAgICBpZiAodGFzaykge1xuICAgICAgdmFyIGRhdGEgPSB0YXNrLmNvbnRleHQuZGF0YTtcbiAgICAgIHJldHVybiBkYXRhVHlwZSA9PSBudWxsIHx8ICFkYXRhLmdldExpbmtlZERhdGEgPyBkYXRhIDogZGF0YS5nZXRMaW5rZWREYXRhKGRhdGFUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2hlbiBzZXJpZXMgaXMgbm90IGFsaXZlICh0aGF0IG1heSBoYXBwZW4gd2hlbiBjbGljayB0b29sYm94XG4gICAgICAvLyByZXN0b3JlIG9yIHNldE9wdGlvbiB3aXRoIG5vdCBtZXJnZSBtb2RlKSwgc2VyaWVzIGRhdGEgbWF5XG4gICAgICAvLyBiZSBzdGlsbCBuZWVkIHRvIGp1ZGdlIGFuaW1hdGlvbiBvciBzb21ldGhpbmcgd2hlbiBncmFwaGljXG4gICAgICAvLyBlbGVtZW50cyB3YW50IHRvIGtub3cgd2hldGhlciBmYWRlIG91dC5cbiAgICAgIHJldHVybiBpbm5lcih0aGlzKS5kYXRhO1xuICAgIH1cbiAgfTtcbiAgU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEFsbERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1haW5EYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgcmV0dXJuIG1haW5EYXRhICYmIG1haW5EYXRhLmdldExpbmtlZERhdGFBbGwgPyBtYWluRGF0YS5nZXRMaW5rZWREYXRhQWxsKCkgOiBbe1xuICAgICAgZGF0YTogbWFpbkRhdGFcbiAgICB9XTtcbiAgfTtcbiAgU2VyaWVzTW9kZWwucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciB0YXNrID0gZ2V0Q3VycmVudFRhc2sodGhpcyk7XG4gICAgaWYgKHRhc2spIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGFzay5jb250ZXh0O1xuICAgICAgLy8gQ29uc2lkZXIgY2FzZTogZmlsdGVyLCBkYXRhIHNhbXBsZS5cbiAgICAgIC8vIEZJWE1FOlRTIG5ldmVyIHVzZWQsIHNvIGNvbW1lbnQgaXRcbiAgICAgIC8vIGlmIChjb250ZXh0LmRhdGEgIT09IGRhdGEgJiYgdGFzay5tb2RpZnlPdXRwdXRFbmQpIHtcbiAgICAgIC8vICAgICB0YXNrLnNldE91dHB1dEVuZChkYXRhLmNvdW50KCkpO1xuICAgICAgLy8gfVxuICAgICAgY29udGV4dC5vdXRwdXREYXRhID0gZGF0YTtcbiAgICAgIC8vIENhdXRpb246IHNldERhdGEgc2hvdWxkIHVwZGF0ZSBjb250ZXh0LmRhdGEsXG4gICAgICAvLyBCZWNhdXNlIGdldERhdGEgbWF5IGJlIGNhbGxlZCBtdWx0aXBseSBpbiBhXG4gICAgICAvLyBzaW5nbGUgc3RhZ2UgYW5kIGV4cGVjdCB0byBnZXQgdGhlIGRhdGEganVzdFxuICAgICAgLy8gc2V0LiAoRm9yIGV4YW1wbGUsIEF4aXNQcm94eSwgeCB5IGJvdGggY2FsbFxuICAgICAgLy8gZ2V0RGF0YSBhbmQgc2V0RGF0ZSBzZXF1ZW50aWFsbHkpLlxuICAgICAgLy8gU28gdGhlIGNvbnRleHQuZGF0YSBzaG91bGQgYmUgZmV0Y2hlZCBmcm9tXG4gICAgICAvLyB1cHN0cmVhbSBlYWNoIHRpbWUgd2hlbiBhIHN0YWdlIHN0YXJ0cyB0byBiZVxuICAgICAgLy8gcGVyZm9ybWVkLlxuICAgICAgaWYgKHRhc2sgIT09IHRoaXMuZGF0YVRhc2spIHtcbiAgICAgICAgY29udGV4dC5kYXRhID0gZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5uZXIodGhpcykuZGF0YSA9IGRhdGE7XG4gIH07XG4gIFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRFbmNvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVuY29kZSA9IHRoaXMuZ2V0KCdlbmNvZGUnLCB0cnVlKTtcbiAgICBpZiAoZW5jb2RlKSB7XG4gICAgICByZXR1cm4genJVdGlsLmNyZWF0ZUhhc2hNYXAoZW5jb2RlKTtcbiAgICB9XG4gIH07XG4gIFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRTb3VyY2VNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpbm5lcih0aGlzKS5zb3VyY2VNYW5hZ2VyO1xuICB9O1xuICBTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvdXJjZU1hbmFnZXIoKS5nZXRTb3VyY2UoKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IGRhdGEgYmVmb3JlIHByb2Nlc3NlZFxyXG4gICAqL1xuICBTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0UmF3RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaW5uZXIodGhpcykuZGF0YUJlZm9yZVByb2Nlc3NlZDtcbiAgfTtcbiAgU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldENvbG9yQnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbG9yQnkgPSB0aGlzLmdldCgnY29sb3JCeScpO1xuICAgIHJldHVybiBjb2xvckJ5IHx8ICdzZXJpZXMnO1xuICB9O1xuICBTZXJpZXNNb2RlbC5wcm90b3R5cGUuaXNDb2xvckJ5U2VyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldENvbG9yQnkoKSA9PT0gJ3Nlcmllcyc7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCBiYXNlIGF4aXMgaWYgaGFzIGNvb3JkaW5hdGUgc3lzdGVtIGFuZCBoYXMgYXhpcy5cclxuICAgKiBCeSBkZWZhdWx0IHVzZSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xyXG4gICAqIENhbiBiZSBvdmVycmlkZGVuIGZvciBzb21lIGNoYXJ0LlxyXG4gICAqIEByZXR1cm4ge3R5cGV9IGRlc2NyaXB0aW9uXHJcbiAgICovXG4gIFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRCYXNlQXhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29vcmRTeXMgPSB0aGlzLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBjb29yZFN5cyAmJiBjb29yZFN5cy5nZXRCYXNlQXhpcyAmJiBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICB9O1xuICAvKipcclxuICAgKiBEZWZhdWx0IHRvb2x0aXAgZm9ybWF0dGVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGF0YUluZGV4XHJcbiAgICogQHBhcmFtIG11bHRpcGxlU2VyaWVzXHJcbiAgICogQHBhcmFtIGRhdGFUeXBlXHJcbiAgICogQHBhcmFtIHJlbmRlck1vZGUgdmFsaWQgdmFsdWVzOiAnaHRtbCcoYnkgZGVmYXVsdCkgYW5kICdyaWNoVGV4dCcuXHJcbiAgICogICAgICAgICdodG1sJyBpcyB1c2VkIGZvciByZW5kZXJpbmcgdG9vbHRpcCBpbiBleHRyYSBET00gZm9ybSwgYW5kIHRoZSByZXN1bHRcclxuICAgKiAgICAgICAgc3RyaW5nIGlzIHVzZWQgYXMgRE9NIEhUTUwgY29udGVudC5cclxuICAgKiAgICAgICAgJ3JpY2hUZXh0JyBpcyB1c2VkIGZvciByZW5kZXJpbmcgdG9vbHRpcCBpbiByaWNoIHRleHQgZm9ybSwgZm9yIHRob3NlIHdoZXJlXHJcbiAgICogICAgICAgIERPTSBvcGVyYXRpb24gaXMgbm90IHN1cHBvcnRlZC5cclxuICAgKiBAcmV0dXJuIGZvcm1hdHRlZCB0b29sdGlwIHdpdGggYGh0bWxgIGFuZCBgbWFya2Vyc2BcclxuICAgKiAgICAgICAgTm90aWNlOiBUaGUgb3ZlcnJpZGUgbWV0aG9kIGNhbiBhbHNvIHJldHVybiBzdHJpbmdcclxuICAgKi9cbiAgU2VyaWVzTW9kZWwucHJvdG90eXBlLmZvcm1hdFRvb2x0aXAgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBtdWx0aXBsZVNlcmllcywgZGF0YVR5cGUpIHtcbiAgICByZXR1cm4gZGVmYXVsdFNlcmllc0Zvcm1hdFRvb2x0aXAoe1xuICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgZGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgICBtdWx0aXBsZVNlcmllczogbXVsdGlwbGVTZXJpZXNcbiAgICB9KTtcbiAgfTtcbiAgU2VyaWVzTW9kZWwucHJvdG90eXBlLmlzQW5pbWF0aW9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICAvLyBEaXNhYmxlIGFuaW1hdGlvbiBpZiB1c2luZyBlY2hhcnRzIGluIG5vZGUgYnV0IG5vdCBnaXZlIHNzciBmbGFnLlxuICAgIC8vIEluIHNzciBtb2RlLCByZW5kZXJUb1N0cmluZyB3aWxsIGdlbmVyYXRlIHN2ZyB3aXRoIGNzcyBhbmltYXRpb24uXG4gICAgaWYgKGVudi5ub2RlICYmICEoZWNNb2RlbCAmJiBlY01vZGVsLnNzcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGFuaW1hdGlvbkVuYWJsZWQgPSB0aGlzLmdldFNoYWxsb3coJ2FuaW1hdGlvbicpO1xuICAgIGlmIChhbmltYXRpb25FbmFibGVkKSB7XG4gICAgICBpZiAodGhpcy5nZXREYXRhKCkuY291bnQoKSA+IHRoaXMuZ2V0U2hhbGxvdygnYW5pbWF0aW9uVGhyZXNob2xkJykpIHtcbiAgICAgICAgYW5pbWF0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gISFhbmltYXRpb25FbmFibGVkO1xuICB9O1xuICBTZXJpZXNNb2RlbC5wcm90b3R5cGUucmVzdG9yZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kYXRhVGFzay5kaXJ0eSgpO1xuICB9O1xuICBTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0Q29sb3JGcm9tUGFsZXR0ZSA9IGZ1bmN0aW9uIChuYW1lLCBzY29wZSwgcmVxdWVzdENvbG9yTnVtKSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgLy8gUEVORElOR1xuICAgIHZhciBjb2xvciA9IFBhbGV0dGVNaXhpbi5wcm90b3R5cGUuZ2V0Q29sb3JGcm9tUGFsZXR0ZS5jYWxsKHRoaXMsIG5hbWUsIHNjb3BlLCByZXF1ZXN0Q29sb3JOdW0pO1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgIGNvbG9yID0gZWNNb2RlbC5nZXRDb2xvckZyb21QYWxldHRlKG5hbWUsIHNjb3BlLCByZXF1ZXN0Q29sb3JOdW0pO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3I7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVzZSBgZGF0YS5tYXBEaW1lbnNpb25zQWxsKGNvb3JkRGltKWAgaW5zdGVhZC5cclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqL1xuICBTZXJpZXNNb2RlbC5wcm90b3R5cGUuY29vcmREaW1Ub0RhdGFEaW0gPSBmdW5jdGlvbiAoY29vcmREaW0pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSYXdEYXRhKCkubWFwRGltZW5zaW9uc0FsbChjb29yZERpbSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgY291bnQgZWFjaCBzdGVwXHJcbiAgICovXG4gIFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRQcm9ncmVzc2l2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3Byb2dyZXNzaXZlJyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgY291bnQgZWFjaCBzdGVwXHJcbiAgICovXG4gIFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRQcm9ncmVzc2l2ZVRocmVzaG9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3Byb2dyZXNzaXZlVGhyZXNob2xkJyk7XG4gIH07XG4gIC8vIFBFTkdJTkcgSWYgc2VsZWN0ZWRNb2RlIGlzIG51bGwgP1xuICBTZXJpZXNNb2RlbC5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGlubmVyRGF0YUluZGljZXMsIGRhdGFUeXBlKSB7XG4gICAgdGhpcy5faW5uZXJTZWxlY3QodGhpcy5nZXREYXRhKGRhdGFUeXBlKSwgaW5uZXJEYXRhSW5kaWNlcyk7XG4gIH07XG4gIFNlcmllc01vZGVsLnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uIChpbm5lckRhdGFJbmRpY2VzLCBkYXRhVHlwZSkge1xuICAgIHZhciBzZWxlY3RlZE1hcCA9IHRoaXMub3B0aW9uLnNlbGVjdGVkTWFwO1xuICAgIGlmICghc2VsZWN0ZWRNYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNlbGVjdGVkTW9kZSA9IHRoaXMub3B0aW9uLnNlbGVjdGVkTW9kZTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShkYXRhVHlwZSk7XG4gICAgaWYgKHNlbGVjdGVkTW9kZSA9PT0gJ3NlcmllcycgfHwgc2VsZWN0ZWRNYXAgPT09ICdhbGwnKSB7XG4gICAgICB0aGlzLm9wdGlvbi5zZWxlY3RlZE1hcCA9IHt9O1xuICAgICAgdGhpcy5fc2VsZWN0ZWREYXRhSW5kaWNlc01hcCA9IHt9O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyRGF0YUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkYXRhSW5kZXggPSBpbm5lckRhdGFJbmRpY2VzW2ldO1xuICAgICAgdmFyIG5hbWVPcklkID0gZ2V0U2VsZWN0aW9uS2V5KGRhdGEsIGRhdGFJbmRleCk7XG4gICAgICBzZWxlY3RlZE1hcFtuYW1lT3JJZF0gPSBmYWxzZTtcbiAgICAgIHRoaXMuX3NlbGVjdGVkRGF0YUluZGljZXNNYXBbbmFtZU9ySWRdID0gLTE7XG4gICAgfVxuICB9O1xuICBTZXJpZXNNb2RlbC5wcm90b3R5cGUudG9nZ2xlU2VsZWN0ID0gZnVuY3Rpb24gKGlubmVyRGF0YUluZGljZXMsIGRhdGFUeXBlKSB7XG4gICAgdmFyIHRtcEFyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5uZXJEYXRhSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdG1wQXJyWzBdID0gaW5uZXJEYXRhSW5kaWNlc1tpXTtcbiAgICAgIHRoaXMuaXNTZWxlY3RlZChpbm5lckRhdGFJbmRpY2VzW2ldLCBkYXRhVHlwZSkgPyB0aGlzLnVuc2VsZWN0KHRtcEFyciwgZGF0YVR5cGUpIDogdGhpcy5zZWxlY3QodG1wQXJyLCBkYXRhVHlwZSk7XG4gICAgfVxuICB9O1xuICBTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0U2VsZWN0ZWREYXRhSW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcHRpb24uc2VsZWN0ZWRNYXAgPT09ICdhbGwnKSB7XG4gICAgICByZXR1cm4gW10uc2xpY2UuY2FsbCh0aGlzLmdldERhdGEoKS5nZXRJbmRpY2VzKCkpO1xuICAgIH1cbiAgICB2YXIgc2VsZWN0ZWREYXRhSW5kaWNlc01hcCA9IHRoaXMuX3NlbGVjdGVkRGF0YUluZGljZXNNYXA7XG4gICAgdmFyIG5hbWVPcklkcyA9IHpyVXRpbC5rZXlzKHNlbGVjdGVkRGF0YUluZGljZXNNYXApO1xuICAgIHZhciBkYXRhSW5kaWNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZU9ySWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGF0YUluZGV4ID0gc2VsZWN0ZWREYXRhSW5kaWNlc01hcFtuYW1lT3JJZHNbaV1dO1xuICAgICAgaWYgKGRhdGFJbmRleCA+PSAwKSB7XG4gICAgICAgIGRhdGFJbmRpY2VzLnB1c2goZGF0YUluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGFJbmRpY2VzO1xuICB9O1xuICBTZXJpZXNNb2RlbC5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIGRhdGFUeXBlKSB7XG4gICAgdmFyIHNlbGVjdGVkTWFwID0gdGhpcy5vcHRpb24uc2VsZWN0ZWRNYXA7XG4gICAgaWYgKCFzZWxlY3RlZE1hcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShkYXRhVHlwZSk7XG4gICAgcmV0dXJuIChzZWxlY3RlZE1hcCA9PT0gJ2FsbCcgfHwgc2VsZWN0ZWRNYXBbZ2V0U2VsZWN0aW9uS2V5KGRhdGEsIGRhdGFJbmRleCldKSAmJiAhZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KS5nZXQoWydzZWxlY3QnLCAnZGlzYWJsZWQnXSk7XG4gIH07XG4gIFNlcmllc01vZGVsLnByb3RvdHlwZS5pc1VuaXZlcnNhbFRyYW5zaXRpb25FbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzW1NFUklFU19VTklWRVJTQUxfVFJBTlNJVElPTl9QUk9QXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciB1bml2ZXJzYWxUcmFuc2l0aW9uT3B0ID0gdGhpcy5vcHRpb24udW5pdmVyc2FsVHJhbnNpdGlvbjtcbiAgICAvLyBRdWljayByZWplY3RcbiAgICBpZiAoIXVuaXZlcnNhbFRyYW5zaXRpb25PcHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHVuaXZlcnNhbFRyYW5zaXRpb25PcHQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBDYW4gYmUgc2ltcGx5ICd1bml2ZXJzYWxUcmFuc2l0aW9uOiB0cnVlJ1xuICAgIHJldHVybiB1bml2ZXJzYWxUcmFuc2l0aW9uT3B0ICYmIHVuaXZlcnNhbFRyYW5zaXRpb25PcHQuZW5hYmxlZDtcbiAgfTtcbiAgU2VyaWVzTW9kZWwucHJvdG90eXBlLl9pbm5lclNlbGVjdCA9IGZ1bmN0aW9uIChkYXRhLCBpbm5lckRhdGFJbmRpY2VzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIHNlbGVjdGVkTW9kZSA9IG9wdGlvbi5zZWxlY3RlZE1vZGU7XG4gICAgdmFyIGxlbiA9IGlubmVyRGF0YUluZGljZXMubGVuZ3RoO1xuICAgIGlmICghc2VsZWN0ZWRNb2RlIHx8ICFsZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbGVjdGVkTW9kZSA9PT0gJ3NlcmllcycpIHtcbiAgICAgIG9wdGlvbi5zZWxlY3RlZE1hcCA9ICdhbGwnO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRNb2RlID09PSAnbXVsdGlwbGUnKSB7XG4gICAgICBpZiAoIXpyVXRpbC5pc09iamVjdChvcHRpb24uc2VsZWN0ZWRNYXApKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZE1hcCA9IHt9O1xuICAgICAgfVxuICAgICAgdmFyIHNlbGVjdGVkTWFwID0gb3B0aW9uLnNlbGVjdGVkTWFwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZGF0YUluZGV4ID0gaW5uZXJEYXRhSW5kaWNlc1tpXTtcbiAgICAgICAgLy8gVE9ETyBkaWZmZXJlbnQgdHlwZXMgb2YgZGF0YSBzaGFyZSBzYW1lIG9iamVjdC5cbiAgICAgICAgdmFyIG5hbWVPcklkID0gZ2V0U2VsZWN0aW9uS2V5KGRhdGEsIGRhdGFJbmRleCk7XG4gICAgICAgIHNlbGVjdGVkTWFwW25hbWVPcklkXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkRGF0YUluZGljZXNNYXBbbmFtZU9ySWRdID0gZGF0YS5nZXRSYXdJbmRleChkYXRhSW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRNb2RlID09PSAnc2luZ2xlJyB8fCBzZWxlY3RlZE1vZGUgPT09IHRydWUpIHtcbiAgICAgIHZhciBsYXN0RGF0YUluZGV4ID0gaW5uZXJEYXRhSW5kaWNlc1tsZW4gLSAxXTtcbiAgICAgIHZhciBuYW1lT3JJZCA9IGdldFNlbGVjdGlvbktleShkYXRhLCBsYXN0RGF0YUluZGV4KTtcbiAgICAgIG9wdGlvbi5zZWxlY3RlZE1hcCA9IChfYSA9IHt9LCBfYVtuYW1lT3JJZF0gPSB0cnVlLCBfYSk7XG4gICAgICB0aGlzLl9zZWxlY3RlZERhdGFJbmRpY2VzTWFwID0gKF9iID0ge30sIF9iW25hbWVPcklkXSA9IGRhdGEuZ2V0UmF3SW5kZXgobGFzdERhdGFJbmRleCksIF9iKTtcbiAgICB9XG4gIH07XG4gIFNlcmllc01vZGVsLnByb3RvdHlwZS5faW5pdFNlbGVjdGVkTWFwRnJvbURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIC8vIElnbm9yZSBzZWxlY3QgaW5mbyBpbiBkYXRhIGlmIHNlbGVjdGVkTWFwIGV4aXN0cy5cbiAgICAvLyBOT1RFIEl0J3Mgb25seSBmb3IgbGVnYWN5IHVzYWdlLiBlZGdlIGRhdGEgaXMgbm90IHN1cHBvcnRlZC5cbiAgICBpZiAodGhpcy5vcHRpb24uc2VsZWN0ZWRNYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRhdGFJbmRpY2VzID0gW107XG4gICAgaWYgKGRhdGEuaGFzSXRlbU9wdGlvbikge1xuICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIHJhd0l0ZW0gPSBkYXRhLmdldFJhd0RhdGFJdGVtKGlkeCk7XG4gICAgICAgIGlmIChyYXdJdGVtICYmIHJhd0l0ZW0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICBkYXRhSW5kaWNlcy5wdXNoKGlkeCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGF0YUluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5faW5uZXJTZWxlY3QoZGF0YSwgZGF0YUluZGljZXMpO1xuICAgIH1cbiAgfTtcbiAgLy8gLyoqXG4gIC8vICAqIEBzZWUge21vZHVsZTplY2hhcnRzL3N0cmVhbS9TY2hlZHVsZXJ9XG4gIC8vICAqL1xuICAvLyBhYnN0cmFjdCBwaXBlVGFzazogbnVsbFxuICBTZXJpZXNNb2RlbC5yZWdpc3RlckNsYXNzID0gZnVuY3Rpb24gKGNseikge1xuICAgIHJldHVybiBDb21wb25lbnRNb2RlbC5yZWdpc3RlckNsYXNzKGNseik7XG4gIH07XG4gIFNlcmllc01vZGVsLnByb3RvSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvdG8gPSBTZXJpZXNNb2RlbC5wcm90b3R5cGU7XG4gICAgcHJvdG8udHlwZSA9ICdzZXJpZXMuX19iYXNlX18nO1xuICAgIHByb3RvLnNlcmllc0luZGV4ID0gMDtcbiAgICBwcm90by5pZ25vcmVTdHlsZU9uRGF0YSA9IGZhbHNlO1xuICAgIHByb3RvLmhhc1N5bWJvbFZpc3VhbCA9IGZhbHNlO1xuICAgIHByb3RvLmRlZmF1bHRTeW1ib2wgPSAnY2lyY2xlJztcbiAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlcyBjYW4gYmUgYWNjZXNzZWQhXG4gICAgcHJvdG8udmlzdWFsU3R5bGVBY2Nlc3NQYXRoID0gJ2l0ZW1TdHlsZSc7XG4gICAgcHJvdG8udmlzdWFsRHJhd1R5cGUgPSAnZmlsbCc7XG4gIH0oKTtcbiAgcmV0dXJuIFNlcmllc01vZGVsO1xufShDb21wb25lbnRNb2RlbCk7XG56clV0aWwubWl4aW4oU2VyaWVzTW9kZWwsIERhdGFGb3JtYXRNaXhpbik7XG56clV0aWwubWl4aW4oU2VyaWVzTW9kZWwsIFBhbGV0dGVNaXhpbik7XG5tb3VudEV4dGVuZChTZXJpZXNNb2RlbCwgQ29tcG9uZW50TW9kZWwpO1xuLyoqXHJcbiAqIE1VU1QgYmUgY2FsbGVkIGFmdGVyIGBwcmVwYXJlU291cmNlYCBjYWxsZWRcclxuICogSGVyZSB3ZSBuZWVkIHRvIG1ha2UgYXV0byBzZXJpZXMsIGVzcGVjaWFsbHkgZm9yIGF1dG8gbGVnZW5kLiBCdXQgd2VcclxuICogZG8gbm90IG1vZGlmeSBzZXJpZXMubmFtZSBpbiBvcHRpb24gdG8gYXZvaWQgc2lkZSBlZmZlY3RzLlxyXG4gKi9cbmZ1bmN0aW9uIGF1dG9TZXJpZXNOYW1lKHNlcmllc01vZGVsKSB7XG4gIC8vIFVzZXIgc3BlY2lmaWVkIG5hbWUgaGFzIGhpZ2hlciBwcmlvcml0eSwgb3RoZXJ3aXNlIGl0IG1heSBjYXVzZVxuICAvLyBzZXJpZXMgY2FuIG5vdCBiZSBxdWVyaWVkIHVuZXhwZWN0ZWRseS5cbiAgdmFyIG5hbWUgPSBzZXJpZXNNb2RlbC5uYW1lO1xuICBpZiAoIW1vZGVsVXRpbC5pc05hbWVTcGVjaWZpZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgc2VyaWVzTW9kZWwubmFtZSA9IGdldFNlcmllc0F1dG9OYW1lKHNlcmllc01vZGVsKSB8fCBuYW1lO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTZXJpZXNBdXRvTmFtZShzZXJpZXNNb2RlbCkge1xuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldFJhd0RhdGEoKTtcbiAgdmFyIGRhdGFEaW1zID0gZGF0YS5tYXBEaW1lbnNpb25zQWxsKCdzZXJpZXNOYW1lJyk7XG4gIHZhciBuYW1lQXJyID0gW107XG4gIHpyVXRpbC5lYWNoKGRhdGFEaW1zLCBmdW5jdGlvbiAoZGF0YURpbSkge1xuICAgIHZhciBkaW1JbmZvID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRhdGFEaW0pO1xuICAgIGRpbUluZm8uZGlzcGxheU5hbWUgJiYgbmFtZUFyci5wdXNoKGRpbUluZm8uZGlzcGxheU5hbWUpO1xuICB9KTtcbiAgcmV0dXJuIG5hbWVBcnIuam9pbignICcpO1xufVxuZnVuY3Rpb24gZGF0YVRhc2tDb3VudChjb250ZXh0KSB7XG4gIHJldHVybiBjb250ZXh0Lm1vZGVsLmdldFJhd0RhdGEoKS5jb3VudCgpO1xufVxuZnVuY3Rpb24gZGF0YVRhc2tSZXNldChjb250ZXh0KSB7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGNvbnRleHQubW9kZWw7XG4gIHNlcmllc01vZGVsLnNldERhdGEoc2VyaWVzTW9kZWwuZ2V0UmF3RGF0YSgpLmNsb25lU2hhbGxvdygpKTtcbiAgcmV0dXJuIGRhdGFUYXNrUHJvZ3Jlc3M7XG59XG5mdW5jdGlvbiBkYXRhVGFza1Byb2dyZXNzKHBhcmFtLCBjb250ZXh0KSB7XG4gIC8vIEF2b2lkIHJlcGVhdCBjbG9uZVNoYWxsb3cgd2hlbiBkYXRhIGp1c3QgY3JlYXRlZCBpbiByZXNldC5cbiAgaWYgKGNvbnRleHQub3V0cHV0RGF0YSAmJiBwYXJhbS5lbmQgPiBjb250ZXh0Lm91dHB1dERhdGEuY291bnQoKSkge1xuICAgIGNvbnRleHQubW9kZWwuZ2V0UmF3RGF0YSgpLmNsb25lU2hhbGxvdyhjb250ZXh0Lm91dHB1dERhdGEpO1xuICB9XG59XG4vLyBUT0RPIHJlZmFjdG9yXG5mdW5jdGlvbiB3cmFwRGF0YShkYXRhLCBzZXJpZXNNb2RlbCkge1xuICB6clV0aWwuZWFjaCh6clV0aWwuY29uY2F0QXJyYXkoZGF0YS5DSEFOR0FCTEVfTUVUSE9EUywgZGF0YS5ET1dOU0FNUExFX01FVEhPRFMpLCBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIGRhdGEud3JhcE1ldGhvZChtZXRob2ROYW1lLCB6clV0aWwuY3Vycnkob25EYXRhQ2hhbmdlLCBzZXJpZXNNb2RlbCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG9uRGF0YUNoYW5nZShzZXJpZXNNb2RlbCwgbmV3TGlzdCkge1xuICB2YXIgdGFzayA9IGdldEN1cnJlbnRUYXNrKHNlcmllc01vZGVsKTtcbiAgaWYgKHRhc2spIHtcbiAgICAvLyBDb25zaWRlciBjYXNlOiBmaWx0ZXIsIHNlbGVjdFJhbmdlXG4gICAgdGFzay5zZXRPdXRwdXRFbmQoKG5ld0xpc3QgfHwgdGhpcykuY291bnQoKSk7XG4gIH1cbiAgcmV0dXJuIG5ld0xpc3Q7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VGFzayhzZXJpZXNNb2RlbCkge1xuICB2YXIgc2NoZWR1bGVyID0gKHNlcmllc01vZGVsLmVjTW9kZWwgfHwge30pLnNjaGVkdWxlcjtcbiAgdmFyIHBpcGVsaW5lID0gc2NoZWR1bGVyICYmIHNjaGVkdWxlci5nZXRQaXBlbGluZShzZXJpZXNNb2RlbC51aWQpO1xuICBpZiAocGlwZWxpbmUpIHtcbiAgICAvLyBXaGVuIHBpcGxpbmUgZmluaXNoZWQsIHRoZSBjdXJycmVudFRhc2sga2VlcCB0aGUgbGFzdFxuICAgIC8vIHRhc2sgKHJlbmRlclRhc2spLlxuICAgIHZhciB0YXNrID0gcGlwZWxpbmUuY3VycmVudFRhc2s7XG4gICAgaWYgKHRhc2spIHtcbiAgICAgIHZhciBhZ2VudFN0dWJNYXAgPSB0YXNrLmFnZW50U3R1Yk1hcDtcbiAgICAgIGlmIChhZ2VudFN0dWJNYXApIHtcbiAgICAgICAgdGFzayA9IGFnZW50U3R1Yk1hcC5nZXQoc2VyaWVzTW9kZWwudWlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhc2s7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFNlcmllc01vZGVsOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///47355\n")},48605:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98026);\n/* harmony import */ var _Scale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28613);\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24326);\n/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(67071);\n/* harmony import */ var _Interval_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74562);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n// Use some method of IntervalScale\n\nvar scaleProto = _Scale_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.prototype;\n// FIXME:TS refactor: not good to call it directly with `this`?\nvar intervalScaleProto = _Interval_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.prototype;\nvar roundingErrorFix = _util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .round */ .LI;\nvar mathFloor = Math.floor;\nvar mathCeil = Math.ceil;\nvar mathPow = Math.pow;\nvar mathLog = Math.log;\nvar LogScale = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__extends */ .C6)(LogScale, _super);\n  function LogScale() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = \'log\';\n    _this.base = 10;\n    _this._originalScale = new _Interval_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A();\n    // FIXME:TS actually used by `IntervalScale`\n    _this._interval = 0;\n    return _this;\n  }\n  /**\r\n   * @param Whether expand the ticks to niced extent.\r\n   */\n  LogScale.prototype.getTicks = function (expandToNicedExtent) {\n    var originalScale = this._originalScale;\n    var extent = this._extent;\n    var originalExtent = originalScale.getExtent();\n    var ticks = intervalScaleProto.getTicks.call(this, expandToNicedExtent);\n    return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.map(ticks, function (tick) {\n      var val = tick.value;\n      var powVal = _util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .round */ .LI(mathPow(this.base, val));\n      // Fix #4158\n      powVal = val === extent[0] && this._fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;\n      powVal = val === extent[1] && this._fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;\n      return {\n        value: powVal\n      };\n    }, this);\n  };\n  LogScale.prototype.setExtent = function (start, end) {\n    var base = mathLog(this.base);\n    // log(-Infinity) is NaN, so safe guard here\n    start = mathLog(Math.max(0, start)) / base;\n    end = mathLog(Math.max(0, end)) / base;\n    intervalScaleProto.setExtent.call(this, start, end);\n  };\n  /**\r\n   * @return {number} end\r\n   */\n  LogScale.prototype.getExtent = function () {\n    var base = this.base;\n    var extent = scaleProto.getExtent.call(this);\n    extent[0] = mathPow(base, extent[0]);\n    extent[1] = mathPow(base, extent[1]);\n    // Fix #4158\n    var originalScale = this._originalScale;\n    var originalExtent = originalScale.getExtent();\n    this._fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n    this._fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n    return extent;\n  };\n  LogScale.prototype.unionExtent = function (extent) {\n    this._originalScale.unionExtent(extent);\n    var base = this.base;\n    extent[0] = mathLog(extent[0]) / mathLog(base);\n    extent[1] = mathLog(extent[1]) / mathLog(base);\n    scaleProto.unionExtent.call(this, extent);\n  };\n  LogScale.prototype.unionExtentFromData = function (data, dim) {\n    // TODO\n    // filter value that <= 0\n    this.unionExtent(data.getApproximateExtent(dim));\n  };\n  /**\r\n   * Update interval and extent of intervals for nice ticks\r\n   * @param approxTickNum default 10 Given approx tick number\r\n   */\n  LogScale.prototype.calcNiceTicks = function (approxTickNum) {\n    approxTickNum = approxTickNum || 10;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n    if (span === Infinity || span <= 0) {\n      return;\n    }\n    var interval = _util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .quantity */ .au(span);\n    var err = approxTickNum / span * interval;\n    // Filter ticks to get closer to the desired count.\n    if (err <= 0.5) {\n      interval *= 10;\n    }\n    // Interval should be integer\n    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n      interval *= 10;\n    }\n    var niceExtent = [_util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .round */ .LI(mathCeil(extent[0] / interval) * interval), _util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .round */ .LI(mathFloor(extent[1] / interval) * interval)];\n    this._interval = interval;\n    this._niceExtent = niceExtent;\n  };\n  LogScale.prototype.calcNiceExtent = function (opt) {\n    intervalScaleProto.calcNiceExtent.call(this, opt);\n    this._fixMin = opt.fixMin;\n    this._fixMax = opt.fixMax;\n  };\n  LogScale.prototype.parse = function (val) {\n    return val;\n  };\n  LogScale.prototype.contain = function (val) {\n    val = mathLog(val) / mathLog(this.base);\n    return _helper_js__WEBPACK_IMPORTED_MODULE_5__/* .contain */ .lP(val, this._extent);\n  };\n  LogScale.prototype.normalize = function (val) {\n    val = mathLog(val) / mathLog(this.base);\n    return _helper_js__WEBPACK_IMPORTED_MODULE_5__/* .normalize */ .S8(val, this._extent);\n  };\n  LogScale.prototype.scale = function (val) {\n    val = _helper_js__WEBPACK_IMPORTED_MODULE_5__/* .scale */ .hs(val, this._extent);\n    return mathPow(this.base, val);\n  };\n  LogScale.type = \'log\';\n  return LogScale;\n}(_Scale_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A);\nvar proto = LogScale.prototype;\nproto.getMinorTicks = intervalScaleProto.getMinorTicks;\nproto.getLabel = intervalScaleProto.getLabel;\nfunction fixRoundingError(val, originalVal) {\n  return roundingErrorFix(val, _util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .getPrecision */ .XV(originalVal));\n}\n_Scale_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.registerClass(LogScale);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LogScale);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg2MDUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvTG9nLmpzP2ZkMTkiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4vU2NhbGUuanMnO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi91dGlsL251bWJlci5qcyc7XG5pbXBvcnQgKiBhcyBzY2FsZUhlbHBlciBmcm9tICcuL2hlbHBlci5qcyc7XG4vLyBVc2Ugc29tZSBtZXRob2Qgb2YgSW50ZXJ2YWxTY2FsZVxuaW1wb3J0IEludGVydmFsU2NhbGUgZnJvbSAnLi9JbnRlcnZhbC5qcyc7XG52YXIgc2NhbGVQcm90byA9IFNjYWxlLnByb3RvdHlwZTtcbi8vIEZJWE1FOlRTIHJlZmFjdG9yOiBub3QgZ29vZCB0byBjYWxsIGl0IGRpcmVjdGx5IHdpdGggYHRoaXNgP1xudmFyIGludGVydmFsU2NhbGVQcm90byA9IEludGVydmFsU2NhbGUucHJvdG90eXBlO1xudmFyIHJvdW5kaW5nRXJyb3JGaXggPSBudW1iZXJVdGlsLnJvdW5kO1xudmFyIG1hdGhGbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbWF0aENlaWwgPSBNYXRoLmNlaWw7XG52YXIgbWF0aFBvdyA9IE1hdGgucG93O1xudmFyIG1hdGhMb2cgPSBNYXRoLmxvZztcbnZhciBMb2dTY2FsZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhMb2dTY2FsZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gTG9nU2NhbGUoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9ICdsb2cnO1xuICAgIF90aGlzLmJhc2UgPSAxMDtcbiAgICBfdGhpcy5fb3JpZ2luYWxTY2FsZSA9IG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gICAgLy8gRklYTUU6VFMgYWN0dWFsbHkgdXNlZCBieSBgSW50ZXJ2YWxTY2FsZWBcbiAgICBfdGhpcy5faW50ZXJ2YWwgPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0gV2hldGhlciBleHBhbmQgdGhlIHRpY2tzIHRvIG5pY2VkIGV4dGVudC5cclxuICAgKi9cbiAgTG9nU2NhbGUucHJvdG90eXBlLmdldFRpY2tzID0gZnVuY3Rpb24gKGV4cGFuZFRvTmljZWRFeHRlbnQpIHtcbiAgICB2YXIgb3JpZ2luYWxTY2FsZSA9IHRoaXMuX29yaWdpbmFsU2NhbGU7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgb3JpZ2luYWxFeHRlbnQgPSBvcmlnaW5hbFNjYWxlLmdldEV4dGVudCgpO1xuICAgIHZhciB0aWNrcyA9IGludGVydmFsU2NhbGVQcm90by5nZXRUaWNrcy5jYWxsKHRoaXMsIGV4cGFuZFRvTmljZWRFeHRlbnQpO1xuICAgIHJldHVybiB6clV0aWwubWFwKHRpY2tzLCBmdW5jdGlvbiAodGljaykge1xuICAgICAgdmFyIHZhbCA9IHRpY2sudmFsdWU7XG4gICAgICB2YXIgcG93VmFsID0gbnVtYmVyVXRpbC5yb3VuZChtYXRoUG93KHRoaXMuYmFzZSwgdmFsKSk7XG4gICAgICAvLyBGaXggIzQxNThcbiAgICAgIHBvd1ZhbCA9IHZhbCA9PT0gZXh0ZW50WzBdICYmIHRoaXMuX2ZpeE1pbiA/IGZpeFJvdW5kaW5nRXJyb3IocG93VmFsLCBvcmlnaW5hbEV4dGVudFswXSkgOiBwb3dWYWw7XG4gICAgICBwb3dWYWwgPSB2YWwgPT09IGV4dGVudFsxXSAmJiB0aGlzLl9maXhNYXggPyBmaXhSb3VuZGluZ0Vycm9yKHBvd1ZhbCwgb3JpZ2luYWxFeHRlbnRbMV0pIDogcG93VmFsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHBvd1ZhbFxuICAgICAgfTtcbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgTG9nU2NhbGUucHJvdG90eXBlLnNldEV4dGVudCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgdmFyIGJhc2UgPSBtYXRoTG9nKHRoaXMuYmFzZSk7XG4gICAgLy8gbG9nKC1JbmZpbml0eSkgaXMgTmFOLCBzbyBzYWZlIGd1YXJkIGhlcmVcbiAgICBzdGFydCA9IG1hdGhMb2coTWF0aC5tYXgoMCwgc3RhcnQpKSAvIGJhc2U7XG4gICAgZW5kID0gbWF0aExvZyhNYXRoLm1heCgwLCBlbmQpKSAvIGJhc2U7XG4gICAgaW50ZXJ2YWxTY2FsZVByb3RvLnNldEV4dGVudC5jYWxsKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICB9O1xuICAvKipcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGVuZFxyXG4gICAqL1xuICBMb2dTY2FsZS5wcm90b3R5cGUuZ2V0RXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgIHZhciBleHRlbnQgPSBzY2FsZVByb3RvLmdldEV4dGVudC5jYWxsKHRoaXMpO1xuICAgIGV4dGVudFswXSA9IG1hdGhQb3coYmFzZSwgZXh0ZW50WzBdKTtcbiAgICBleHRlbnRbMV0gPSBtYXRoUG93KGJhc2UsIGV4dGVudFsxXSk7XG4gICAgLy8gRml4ICM0MTU4XG4gICAgdmFyIG9yaWdpbmFsU2NhbGUgPSB0aGlzLl9vcmlnaW5hbFNjYWxlO1xuICAgIHZhciBvcmlnaW5hbEV4dGVudCA9IG9yaWdpbmFsU2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgdGhpcy5fZml4TWluICYmIChleHRlbnRbMF0gPSBmaXhSb3VuZGluZ0Vycm9yKGV4dGVudFswXSwgb3JpZ2luYWxFeHRlbnRbMF0pKTtcbiAgICB0aGlzLl9maXhNYXggJiYgKGV4dGVudFsxXSA9IGZpeFJvdW5kaW5nRXJyb3IoZXh0ZW50WzFdLCBvcmlnaW5hbEV4dGVudFsxXSkpO1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH07XG4gIExvZ1NjYWxlLnByb3RvdHlwZS51bmlvbkV4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQpIHtcbiAgICB0aGlzLl9vcmlnaW5hbFNjYWxlLnVuaW9uRXh0ZW50KGV4dGVudCk7XG4gICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgZXh0ZW50WzBdID0gbWF0aExvZyhleHRlbnRbMF0pIC8gbWF0aExvZyhiYXNlKTtcbiAgICBleHRlbnRbMV0gPSBtYXRoTG9nKGV4dGVudFsxXSkgLyBtYXRoTG9nKGJhc2UpO1xuICAgIHNjYWxlUHJvdG8udW5pb25FeHRlbnQuY2FsbCh0aGlzLCBleHRlbnQpO1xuICB9O1xuICBMb2dTY2FsZS5wcm90b3R5cGUudW5pb25FeHRlbnRGcm9tRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBkaW0pIHtcbiAgICAvLyBUT0RPXG4gICAgLy8gZmlsdGVyIHZhbHVlIHRoYXQgPD0gMFxuICAgIHRoaXMudW5pb25FeHRlbnQoZGF0YS5nZXRBcHByb3hpbWF0ZUV4dGVudChkaW0pKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIGludGVydmFsIGFuZCBleHRlbnQgb2YgaW50ZXJ2YWxzIGZvciBuaWNlIHRpY2tzXHJcbiAgICogQHBhcmFtIGFwcHJveFRpY2tOdW0gZGVmYXVsdCAxMCBHaXZlbiBhcHByb3ggdGljayBudW1iZXJcclxuICAgKi9cbiAgTG9nU2NhbGUucHJvdG90eXBlLmNhbGNOaWNlVGlja3MgPSBmdW5jdGlvbiAoYXBwcm94VGlja051bSkge1xuICAgIGFwcHJveFRpY2tOdW0gPSBhcHByb3hUaWNrTnVtIHx8IDEwO1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgaWYgKHNwYW4gPT09IEluZmluaXR5IHx8IHNwYW4gPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaW50ZXJ2YWwgPSBudW1iZXJVdGlsLnF1YW50aXR5KHNwYW4pO1xuICAgIHZhciBlcnIgPSBhcHByb3hUaWNrTnVtIC8gc3BhbiAqIGludGVydmFsO1xuICAgIC8vIEZpbHRlciB0aWNrcyB0byBnZXQgY2xvc2VyIHRvIHRoZSBkZXNpcmVkIGNvdW50LlxuICAgIGlmIChlcnIgPD0gMC41KSB7XG4gICAgICBpbnRlcnZhbCAqPSAxMDtcbiAgICB9XG4gICAgLy8gSW50ZXJ2YWwgc2hvdWxkIGJlIGludGVnZXJcbiAgICB3aGlsZSAoIWlzTmFOKGludGVydmFsKSAmJiBNYXRoLmFicyhpbnRlcnZhbCkgPCAxICYmIE1hdGguYWJzKGludGVydmFsKSA+IDApIHtcbiAgICAgIGludGVydmFsICo9IDEwO1xuICAgIH1cbiAgICB2YXIgbmljZUV4dGVudCA9IFtudW1iZXJVdGlsLnJvdW5kKG1hdGhDZWlsKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsKSwgbnVtYmVyVXRpbC5yb3VuZChtYXRoRmxvb3IoZXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpXTtcbiAgICB0aGlzLl9pbnRlcnZhbCA9IGludGVydmFsO1xuICAgIHRoaXMuX25pY2VFeHRlbnQgPSBuaWNlRXh0ZW50O1xuICB9O1xuICBMb2dTY2FsZS5wcm90b3R5cGUuY2FsY05pY2VFeHRlbnQgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgaW50ZXJ2YWxTY2FsZVByb3RvLmNhbGNOaWNlRXh0ZW50LmNhbGwodGhpcywgb3B0KTtcbiAgICB0aGlzLl9maXhNaW4gPSBvcHQuZml4TWluO1xuICAgIHRoaXMuX2ZpeE1heCA9IG9wdC5maXhNYXg7XG4gIH07XG4gIExvZ1NjYWxlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9O1xuICBMb2dTY2FsZS5wcm90b3R5cGUuY29udGFpbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWwgPSBtYXRoTG9nKHZhbCkgLyBtYXRoTG9nKHRoaXMuYmFzZSk7XG4gICAgcmV0dXJuIHNjYWxlSGVscGVyLmNvbnRhaW4odmFsLCB0aGlzLl9leHRlbnQpO1xuICB9O1xuICBMb2dTY2FsZS5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhbCA9IG1hdGhMb2codmFsKSAvIG1hdGhMb2codGhpcy5iYXNlKTtcbiAgICByZXR1cm4gc2NhbGVIZWxwZXIubm9ybWFsaXplKHZhbCwgdGhpcy5fZXh0ZW50KTtcbiAgfTtcbiAgTG9nU2NhbGUucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhbCA9IHNjYWxlSGVscGVyLnNjYWxlKHZhbCwgdGhpcy5fZXh0ZW50KTtcbiAgICByZXR1cm4gbWF0aFBvdyh0aGlzLmJhc2UsIHZhbCk7XG4gIH07XG4gIExvZ1NjYWxlLnR5cGUgPSAnbG9nJztcbiAgcmV0dXJuIExvZ1NjYWxlO1xufShTY2FsZSk7XG52YXIgcHJvdG8gPSBMb2dTY2FsZS5wcm90b3R5cGU7XG5wcm90by5nZXRNaW5vclRpY2tzID0gaW50ZXJ2YWxTY2FsZVByb3RvLmdldE1pbm9yVGlja3M7XG5wcm90by5nZXRMYWJlbCA9IGludGVydmFsU2NhbGVQcm90by5nZXRMYWJlbDtcbmZ1bmN0aW9uIGZpeFJvdW5kaW5nRXJyb3IodmFsLCBvcmlnaW5hbFZhbCkge1xuICByZXR1cm4gcm91bmRpbmdFcnJvckZpeCh2YWwsIG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uKG9yaWdpbmFsVmFsKSk7XG59XG5TY2FsZS5yZWdpc3RlckNsYXNzKExvZ1NjYWxlKTtcbmV4cG9ydCBkZWZhdWx0IExvZ1NjYWxlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///48605\n')},67071:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S8: () => (/* binding */ normalize),\n/* harmony export */   hs: () => (/* binding */ scale),\n/* harmony export */   kH: () => (/* binding */ increaseInterval),\n/* harmony export */   lP: () => (/* binding */ contain),\n/* harmony export */   rf: () => (/* binding */ isIntervalOrLogScale),\n/* harmony export */   u$: () => (/* binding */ getIntervalPrecision),\n/* harmony export */   xh: () => (/* binding */ intervalScaleNiceTicks)\n/* harmony export */ });\n/* unused harmony exports isValueNice, fixExtent */\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24326);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction isValueNice(val) {\n  var exp10 = Math.pow(10, quantityExponent(Math.abs(val)));\n  var f = Math.abs(val / exp10);\n  return f === 0 || f === 1 || f === 2 || f === 3 || f === 5;\n}\nfunction isIntervalOrLogScale(scale) {\n  return scale.type === \'interval\' || scale.type === \'log\';\n}\n/**\r\n * @param extent Both extent[0] and extent[1] should be valid number.\r\n *               Should be extent[0] < extent[1].\r\n * @param splitNumber splitNumber should be >= 1.\r\n */\nfunction intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {\n  var result = {};\n  var span = extent[1] - extent[0];\n  var interval = result.interval = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_0__/* .nice */ .Cm)(span / splitNumber, true);\n  if (minInterval != null && interval < minInterval) {\n    interval = result.interval = minInterval;\n  }\n  if (maxInterval != null && interval > maxInterval) {\n    interval = result.interval = maxInterval;\n  }\n  // Tow more digital for tick.\n  var precision = result.intervalPrecision = getIntervalPrecision(interval);\n  // Niced extent inside original extent\n  var niceTickExtent = result.niceTickExtent = [(0,_util_number_js__WEBPACK_IMPORTED_MODULE_0__/* .round */ .LI)(Math.ceil(extent[0] / interval) * interval, precision), (0,_util_number_js__WEBPACK_IMPORTED_MODULE_0__/* .round */ .LI)(Math.floor(extent[1] / interval) * interval, precision)];\n  fixExtent(niceTickExtent, extent);\n  return result;\n}\nfunction increaseInterval(interval) {\n  var exp10 = Math.pow(10, (0,_util_number_js__WEBPACK_IMPORTED_MODULE_0__/* .quantityExponent */ .NX)(interval));\n  // Increase interval\n  var f = interval / exp10;\n  if (!f) {\n    f = 1;\n  } else if (f === 2) {\n    f = 3;\n  } else if (f === 3) {\n    f = 5;\n  } else {\n    // f is 1 or 5\n    f *= 2;\n  }\n  return (0,_util_number_js__WEBPACK_IMPORTED_MODULE_0__/* .round */ .LI)(f * exp10);\n}\n/**\r\n * @return interval precision\r\n */\nfunction getIntervalPrecision(interval) {\n  // Tow more digital for tick.\n  return (0,_util_number_js__WEBPACK_IMPORTED_MODULE_0__/* .getPrecision */ .XV)(interval) + 2;\n}\nfunction clamp(niceTickExtent, idx, extent) {\n  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n}\n// In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\nfunction fixExtent(niceTickExtent, extent) {\n  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n  clamp(niceTickExtent, 0, extent);\n  clamp(niceTickExtent, 1, extent);\n  if (niceTickExtent[0] > niceTickExtent[1]) {\n    niceTickExtent[0] = niceTickExtent[1];\n  }\n}\nfunction contain(val, extent) {\n  return val >= extent[0] && val <= extent[1];\n}\nfunction normalize(val, extent) {\n  if (extent[1] === extent[0]) {\n    return 0.5;\n  }\n  return (val - extent[0]) / (extent[1] - extent[0]);\n}\nfunction scale(val, extent) {\n  return val * (extent[1] - extent[0]) + extent[0];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjcwNzEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3NjYWxlL2hlbHBlci5qcz9iMWQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgZ2V0UHJlY2lzaW9uLCByb3VuZCwgbmljZSwgcXVhbnRpdHlFeHBvbmVudCB9IGZyb20gJy4uL3V0aWwvbnVtYmVyLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbHVlTmljZSh2YWwpIHtcbiAgdmFyIGV4cDEwID0gTWF0aC5wb3coMTAsIHF1YW50aXR5RXhwb25lbnQoTWF0aC5hYnModmFsKSkpO1xuICB2YXIgZiA9IE1hdGguYWJzKHZhbCAvIGV4cDEwKTtcbiAgcmV0dXJuIGYgPT09IDAgfHwgZiA9PT0gMSB8fCBmID09PSAyIHx8IGYgPT09IDMgfHwgZiA9PT0gNTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVydmFsT3JMb2dTY2FsZShzY2FsZSkge1xuICByZXR1cm4gc2NhbGUudHlwZSA9PT0gJ2ludGVydmFsJyB8fCBzY2FsZS50eXBlID09PSAnbG9nJztcbn1cbi8qKlxyXG4gKiBAcGFyYW0gZXh0ZW50IEJvdGggZXh0ZW50WzBdIGFuZCBleHRlbnRbMV0gc2hvdWxkIGJlIHZhbGlkIG51bWJlci5cclxuICogICAgICAgICAgICAgICBTaG91bGQgYmUgZXh0ZW50WzBdIDwgZXh0ZW50WzFdLlxyXG4gKiBAcGFyYW0gc3BsaXROdW1iZXIgc3BsaXROdW1iZXIgc2hvdWxkIGJlID49IDEuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVydmFsU2NhbGVOaWNlVGlja3MoZXh0ZW50LCBzcGxpdE51bWJlciwgbWluSW50ZXJ2YWwsIG1heEludGVydmFsKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gIHZhciBpbnRlcnZhbCA9IHJlc3VsdC5pbnRlcnZhbCA9IG5pY2Uoc3BhbiAvIHNwbGl0TnVtYmVyLCB0cnVlKTtcbiAgaWYgKG1pbkludGVydmFsICE9IG51bGwgJiYgaW50ZXJ2YWwgPCBtaW5JbnRlcnZhbCkge1xuICAgIGludGVydmFsID0gcmVzdWx0LmludGVydmFsID0gbWluSW50ZXJ2YWw7XG4gIH1cbiAgaWYgKG1heEludGVydmFsICE9IG51bGwgJiYgaW50ZXJ2YWwgPiBtYXhJbnRlcnZhbCkge1xuICAgIGludGVydmFsID0gcmVzdWx0LmludGVydmFsID0gbWF4SW50ZXJ2YWw7XG4gIH1cbiAgLy8gVG93IG1vcmUgZGlnaXRhbCBmb3IgdGljay5cbiAgdmFyIHByZWNpc2lvbiA9IHJlc3VsdC5pbnRlcnZhbFByZWNpc2lvbiA9IGdldEludGVydmFsUHJlY2lzaW9uKGludGVydmFsKTtcbiAgLy8gTmljZWQgZXh0ZW50IGluc2lkZSBvcmlnaW5hbCBleHRlbnRcbiAgdmFyIG5pY2VUaWNrRXh0ZW50ID0gcmVzdWx0Lm5pY2VUaWNrRXh0ZW50ID0gW3JvdW5kKE1hdGguY2VpbChleHRlbnRbMF0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCwgcHJlY2lzaW9uKSwgcm91bmQoTWF0aC5mbG9vcihleHRlbnRbMV0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCwgcHJlY2lzaW9uKV07XG4gIGZpeEV4dGVudChuaWNlVGlja0V4dGVudCwgZXh0ZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbmNyZWFzZUludGVydmFsKGludGVydmFsKSB7XG4gIHZhciBleHAxMCA9IE1hdGgucG93KDEwLCBxdWFudGl0eUV4cG9uZW50KGludGVydmFsKSk7XG4gIC8vIEluY3JlYXNlIGludGVydmFsXG4gIHZhciBmID0gaW50ZXJ2YWwgLyBleHAxMDtcbiAgaWYgKCFmKSB7XG4gICAgZiA9IDE7XG4gIH0gZWxzZSBpZiAoZiA9PT0gMikge1xuICAgIGYgPSAzO1xuICB9IGVsc2UgaWYgKGYgPT09IDMpIHtcbiAgICBmID0gNTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmIGlzIDEgb3IgNVxuICAgIGYgKj0gMjtcbiAgfVxuICByZXR1cm4gcm91bmQoZiAqIGV4cDEwKTtcbn1cbi8qKlxyXG4gKiBAcmV0dXJuIGludGVydmFsIHByZWNpc2lvblxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcnZhbFByZWNpc2lvbihpbnRlcnZhbCkge1xuICAvLyBUb3cgbW9yZSBkaWdpdGFsIGZvciB0aWNrLlxuICByZXR1cm4gZ2V0UHJlY2lzaW9uKGludGVydmFsKSArIDI7XG59XG5mdW5jdGlvbiBjbGFtcChuaWNlVGlja0V4dGVudCwgaWR4LCBleHRlbnQpIHtcbiAgbmljZVRpY2tFeHRlbnRbaWR4XSA9IE1hdGgubWF4KE1hdGgubWluKG5pY2VUaWNrRXh0ZW50W2lkeF0sIGV4dGVudFsxXSksIGV4dGVudFswXSk7XG59XG4vLyBJbiBzb21lIGNhc2VzIChlLmcuLCBzcGxpdE51bWJlciBpcyAxKSwgbmljZVRpY2tFeHRlbnQgbWF5IGJlIG91dCBvZiBleHRlbnQuXG5leHBvcnQgZnVuY3Rpb24gZml4RXh0ZW50KG5pY2VUaWNrRXh0ZW50LCBleHRlbnQpIHtcbiAgIWlzRmluaXRlKG5pY2VUaWNrRXh0ZW50WzBdKSAmJiAobmljZVRpY2tFeHRlbnRbMF0gPSBleHRlbnRbMF0pO1xuICAhaXNGaW5pdGUobmljZVRpY2tFeHRlbnRbMV0pICYmIChuaWNlVGlja0V4dGVudFsxXSA9IGV4dGVudFsxXSk7XG4gIGNsYW1wKG5pY2VUaWNrRXh0ZW50LCAwLCBleHRlbnQpO1xuICBjbGFtcChuaWNlVGlja0V4dGVudCwgMSwgZXh0ZW50KTtcbiAgaWYgKG5pY2VUaWNrRXh0ZW50WzBdID4gbmljZVRpY2tFeHRlbnRbMV0pIHtcbiAgICBuaWNlVGlja0V4dGVudFswXSA9IG5pY2VUaWNrRXh0ZW50WzFdO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY29udGFpbih2YWwsIGV4dGVudCkge1xuICByZXR1cm4gdmFsID49IGV4dGVudFswXSAmJiB2YWwgPD0gZXh0ZW50WzFdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZSh2YWwsIGV4dGVudCkge1xuICBpZiAoZXh0ZW50WzFdID09PSBleHRlbnRbMF0pIHtcbiAgICByZXR1cm4gMC41O1xuICB9XG4gIHJldHVybiAodmFsIC0gZXh0ZW50WzBdKSAvIChleHRlbnRbMV0gLSBleHRlbnRbMF0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKHZhbCwgZXh0ZW50KSB7XG4gIHJldHVybiB2YWwgKiAoZXh0ZW50WzFdIC0gZXh0ZW50WzBdKSArIGV4dGVudFswXTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///67071\n')},73100:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ Global)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Model.js + 2 modules\nvar Model = __webpack_require__(43172);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Component.js\nvar Component = __webpack_require__(15915);\n;// ./node_modules/echarts/lib/model/globalDefault.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar platform = '';\n// Navigator not exists in node\nif (typeof navigator !== 'undefined') {\n  /* global navigator */\n  platform = navigator.platform || '';\n}\nvar decalColor = 'rgba(0, 0, 0, 0.2)';\n/* harmony default export */ const globalDefault = ({\n  darkMode: 'auto',\n  // backgroundColor: 'rgba(0,0,0,0)',\n  colorBy: 'series',\n  color: ['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc'],\n  gradientColor: ['#f6efa6', '#d88273', '#bf444c'],\n  aria: {\n    decal: {\n      decals: [{\n        color: decalColor,\n        dashArrayX: [1, 0],\n        dashArrayY: [2, 5],\n        symbolSize: 1,\n        rotation: Math.PI / 6\n      }, {\n        color: decalColor,\n        symbol: 'circle',\n        dashArrayX: [[8, 8], [0, 8, 8, 0]],\n        dashArrayY: [6, 0],\n        symbolSize: 0.8\n      }, {\n        color: decalColor,\n        dashArrayX: [1, 0],\n        dashArrayY: [4, 3],\n        rotation: -Math.PI / 4\n      }, {\n        color: decalColor,\n        dashArrayX: [[6, 6], [0, 6, 6, 0]],\n        dashArrayY: [6, 0]\n      }, {\n        color: decalColor,\n        dashArrayX: [[1, 0], [1, 6]],\n        dashArrayY: [1, 0, 6, 0],\n        rotation: Math.PI / 4\n      }, {\n        color: decalColor,\n        symbol: 'triangle',\n        dashArrayX: [[9, 9], [0, 9, 9, 0]],\n        dashArrayY: [7, 2],\n        symbolSize: 0.75\n      }]\n    }\n  },\n  // If xAxis and yAxis declared, grid is created by default.\n  // grid: {},\n  textStyle: {\n    // color: '#000',\n    // decoration: 'none',\n    // PENDING\n    fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n    // fontFamily: 'Arial, Verdana, sans-serif',\n    fontSize: 12,\n    fontStyle: 'normal',\n    fontWeight: 'normal'\n  },\n  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n  // Default is source-over\n  blendMode: null,\n  stateAnimation: {\n    duration: 300,\n    easing: 'cubicOut'\n  },\n  animation: 'auto',\n  animationDuration: 1000,\n  animationDurationUpdate: 500,\n  animationEasing: 'cubicInOut',\n  animationEasingUpdate: 'cubicInOut',\n  animationThreshold: 2000,\n  // Configuration for progressive/incremental rendering\n  progressiveThreshold: 3000,\n  progressive: 400,\n  // Threshold of if use single hover layer to optimize.\n  // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n  // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n  // which is unexpected.\n  // see example <echarts/test/heatmap-large.html>.\n  hoverLayerThreshold: 3000,\n  // See: module:echarts/scale/Time\n  useUTC: false\n});\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/sourceHelper.js\nvar sourceHelper = __webpack_require__(23071);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/internalComponentCreator.js\nvar internalComponentCreator = __webpack_require__(7442);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/mixin/palette.js\nvar palette = __webpack_require__(96501);\n;// ./node_modules/echarts/lib/model/Global.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * Caution: If the mechanism should be changed some day, these cases\r\n * should be considered:\r\n *\r\n * (1) In `merge option` mode, if using the same option to call `setOption`\r\n * many times, the result should be the same (try our best to ensure that).\r\n * (2) In `merge option` mode, if a component has no id/name specified, it\r\n * will be merged by index, and the result sequence of the components is\r\n * consistent to the original sequence.\r\n * (3) In `replaceMerge` mode, keep the result sequence of the components is\r\n * consistent to the original sequence, even though there might result in \"hole\".\r\n * (4) `reset` feature (in toolbox). Find detailed info in comments about\r\n * `mergeOption` in module:echarts/model/OptionManager.\r\n */\n\n\n\n\n\n\n\n\n\n// -----------------------\n// Internal method names:\n// -----------------------\nvar reCreateSeriesIndices;\nvar assertSeriesInitialized;\nvar initBase;\nvar OPTION_INNER_KEY = '\\0_ec_inner';\nvar OPTION_INNER_VALUE = 1;\nvar BUITIN_COMPONENTS_MAP = {\n  grid: 'GridComponent',\n  polar: 'PolarComponent',\n  geo: 'GeoComponent',\n  singleAxis: 'SingleAxisComponent',\n  parallel: 'ParallelComponent',\n  calendar: 'CalendarComponent',\n  graphic: 'GraphicComponent',\n  toolbox: 'ToolboxComponent',\n  tooltip: 'TooltipComponent',\n  axisPointer: 'AxisPointerComponent',\n  brush: 'BrushComponent',\n  title: 'TitleComponent',\n  timeline: 'TimelineComponent',\n  markPoint: 'MarkPointComponent',\n  markLine: 'MarkLineComponent',\n  markArea: 'MarkAreaComponent',\n  legend: 'LegendComponent',\n  dataZoom: 'DataZoomComponent',\n  visualMap: 'VisualMapComponent',\n  // aria: 'AriaComponent',\n  // dataset: 'DatasetComponent',\n  // Dependencies\n  xAxis: 'GridComponent',\n  yAxis: 'GridComponent',\n  angleAxis: 'PolarComponent',\n  radiusAxis: 'PolarComponent'\n};\nvar BUILTIN_CHARTS_MAP = {\n  line: 'LineChart',\n  bar: 'BarChart',\n  pie: 'PieChart',\n  scatter: 'ScatterChart',\n  radar: 'RadarChart',\n  map: 'MapChart',\n  tree: 'TreeChart',\n  treemap: 'TreemapChart',\n  graph: 'GraphChart',\n  gauge: 'GaugeChart',\n  funnel: 'FunnelChart',\n  parallel: 'ParallelChart',\n  sankey: 'SankeyChart',\n  boxplot: 'BoxplotChart',\n  candlestick: 'CandlestickChart',\n  effectScatter: 'EffectScatterChart',\n  lines: 'LinesChart',\n  heatmap: 'HeatmapChart',\n  pictorialBar: 'PictorialBarChart',\n  themeRiver: 'ThemeRiverChart',\n  sunburst: 'SunburstChart',\n  custom: 'CustomChart'\n};\nvar componetsMissingLogPrinted = {};\nfunction checkMissingComponents(option) {\n  each(option, function (componentOption, mainType) {\n    if (!ComponentModel.hasClass(mainType)) {\n      var componentImportName = BUITIN_COMPONENTS_MAP[mainType];\n      if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {\n        error(\"Component \" + mainType + \" is used but not imported.\\nimport { \" + componentImportName + \" } from 'echarts/components';\\necharts.use([\" + componentImportName + \"]);\");\n        componetsMissingLogPrinted[componentImportName] = true;\n      }\n    }\n  });\n}\nvar GlobalModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(GlobalModel, _super);\n  function GlobalModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  GlobalModel.prototype.init = function (option, parentModel, ecModel, theme, locale, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n    this._theme = new Model/* default */.A(theme);\n    this._locale = new Model/* default */.A(locale);\n    this._optionManager = optionManager;\n  };\n  GlobalModel.prototype.setOption = function (option, opts, optionPreprocessorFuncs) {\n    if (false) {}\n    var innerOpt = normalizeSetOptionInput(opts);\n    this._optionManager.setOption(option, optionPreprocessorFuncs, innerOpt);\n    this._resetOption(null, innerOpt);\n  };\n  /**\r\n   * @param type null/undefined: reset all.\r\n   *        'recreate': force recreate all.\r\n   *        'timeline': only reset timeline option\r\n   *        'media': only reset media query option\r\n   * @return Whether option changed.\r\n   */\n  GlobalModel.prototype.resetOption = function (type, opt) {\n    return this._resetOption(type, normalizeSetOptionInput(opt));\n  };\n  GlobalModel.prototype._resetOption = function (type, opt) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n      if (false) {}\n      if (!this.option || type === 'recreate') {\n        initBase(this, baseOption);\n      } else {\n        this.restoreData();\n        this._mergeOption(baseOption, opt);\n      }\n      optionChanged = true;\n    }\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    }\n    // By design, if `setOption(option2)` at the second time, and `option2` is a `ECUnitOption`,\n    // it should better not have the same props with `MediaUnit['option']`.\n    // Because either `option2` or `MediaUnit['option']` will be always merged to \"current option\"\n    // rather than original \"baseOption\". If they both override a prop, the result might be\n    // unexpected when media state changed after `setOption` called.\n    // If we really need to modify a props in each `MediaUnit['option']`, use the full version\n    // (`{baseOption, media}`) in `setOption`.\n    // For `timeline`, the case is the same.\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n      if (timelineOption) {\n        optionChanged = true;\n        this._mergeOption(timelineOption, opt);\n      }\n    }\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this);\n      if (mediaOptions.length) {\n        (0,util.each)(mediaOptions, function (mediaOption) {\n          optionChanged = true;\n          this._mergeOption(mediaOption, opt);\n        }, this);\n      }\n    }\n    return optionChanged;\n  };\n  GlobalModel.prototype.mergeOption = function (option) {\n    this._mergeOption(option, null);\n  };\n  GlobalModel.prototype._mergeOption = function (newOption, opt) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var componentsCount = this._componentsCount;\n    var newCmptTypes = [];\n    var newCmptTypeMap = (0,util.createHashMap)();\n    var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;\n    (0,sourceHelper/* resetSourceDefaulter */.ps)(this);\n    // If no component class, merge directly.\n    // For example: color, animaiton options, etc.\n    (0,util.each)(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n      if (!Component/* default */.A.hasClass(mainType)) {\n        // globalSettingTask.dirty();\n        option[mainType] = option[mainType] == null ? (0,util.clone)(componentOption) : (0,util.merge)(option[mainType], componentOption, true);\n      } else if (mainType) {\n        newCmptTypes.push(mainType);\n        newCmptTypeMap.set(mainType, true);\n      }\n    });\n    if (replaceMergeMainTypeMap) {\n      // If there is a mainType `xxx` in `replaceMerge` but not declared in option,\n      // we trade it as it is declared in option as `{xxx: []}`. Because:\n      // (1) for normal merge, `{xxx: null/undefined}` are the same meaning as `{xxx: []}`.\n      // (2) some preprocessor may convert some of `{xxx: null/undefined}` to `{xxx: []}`.\n      replaceMergeMainTypeMap.each(function (val, mainTypeInReplaceMerge) {\n        if (Component/* default */.A.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {\n          newCmptTypes.push(mainTypeInReplaceMerge);\n          newCmptTypeMap.set(mainTypeInReplaceMerge, true);\n        }\n      });\n    }\n    Component/* default */.A.topologicalTravel(newCmptTypes, Component/* default */.A.getAllClassMainTypes(), visitComponent, this);\n    function visitComponent(mainType) {\n      var newCmptOptionList = (0,internalComponentCreator/* concatInternalOptions */.a)(this, mainType, model/* normalizeToArray */.qB(newOption[mainType]));\n      var oldCmptList = componentsMap.get(mainType);\n      var mergeMode =\n      // `!oldCmptList` means init. See the comment in `mappingToExists`\n      !oldCmptList ? 'replaceAll' : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? 'replaceMerge' : 'normalMerge';\n      var mappingResult = model/* mappingToExists */.O2(oldCmptList, newCmptOptionList, mergeMode);\n      // Set mainType and complete subType.\n      model/* setComponentTypeToKeyInfo */.GX(mappingResult, mainType, Component/* default */.A);\n      // Empty it before the travel, in order to prevent `this._componentsMap`\n      // from being used in the `init`/`mergeOption`/`optionUpdated` of some\n      // components, which is probably incorrect logic.\n      option[mainType] = null;\n      componentsMap.set(mainType, null);\n      componentsCount.set(mainType, 0);\n      var optionsByMainType = [];\n      var cmptsByMainType = [];\n      var cmptsCountByMainType = 0;\n      var tooltipExists;\n      var tooltipWarningLogged;\n      (0,util.each)(mappingResult, function (resultItem, index) {\n        var componentModel = resultItem.existing;\n        var newCmptOption = resultItem.newOption;\n        if (!newCmptOption) {\n          if (componentModel) {\n            // Consider where is no new option and should be merged using {},\n            // see removeEdgeAndAdd in topologicalTravel and\n            // ComponentModel.getAllClassMainTypes.\n            componentModel.mergeOption({}, this);\n            componentModel.optionUpdated({}, false);\n          }\n          // If no both `resultItem.exist` and `resultItem.option`,\n          // either it is in `replaceMerge` and not matched by any id,\n          // or it has been removed in previous `replaceMerge` and left a \"hole\" in this component index.\n        } else {\n          var isSeriesType = mainType === 'series';\n          var ComponentModelClass = Component/* default */.A.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType // Give a more detailed warn later if series don't exists\n          );\n          if (!ComponentModelClass) {\n            if (false) { var seriesImportName, subType; }\n            return;\n          }\n          // TODO Before multiple tooltips get supported, we do this check to avoid unexpected exception.\n          if (mainType === 'tooltip') {\n            if (tooltipExists) {\n              if (false) {}\n              return;\n            }\n            tooltipExists = true;\n          }\n          if (componentModel && componentModel.constructor === ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name;\n            // componentModel.settingTask && componentModel.settingTask.dirty();\n            componentModel.mergeOption(newCmptOption, this);\n            componentModel.optionUpdated(newCmptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = (0,util.extend)({\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);\n            // Assign `keyInfo`\n            (0,util.extend)(componentModel, extraOpt);\n            if (resultItem.brandNew) {\n              componentModel.__requireNewView = true;\n            }\n            componentModel.init(newCmptOption, this, this);\n            // Call optionUpdated after init.\n            // newCmptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n            componentModel.optionUpdated(null, true);\n          }\n        }\n        if (componentModel) {\n          optionsByMainType.push(componentModel.option);\n          cmptsByMainType.push(componentModel);\n          cmptsCountByMainType++;\n        } else {\n          // Always do assign to avoid elided item in array.\n          optionsByMainType.push(void 0);\n          cmptsByMainType.push(void 0);\n        }\n      }, this);\n      option[mainType] = optionsByMainType;\n      componentsMap.set(mainType, cmptsByMainType);\n      componentsCount.set(mainType, cmptsCountByMainType);\n      // Backup series for filtering.\n      if (mainType === 'series') {\n        reCreateSeriesIndices(this);\n      }\n    }\n    // If no series declared, ensure `_seriesIndices` initialized.\n    if (!this._seriesIndices) {\n      reCreateSeriesIndices(this);\n    }\n  };\n  /**\r\n   * Get option for output (cloned option and inner info removed)\r\n   */\n  GlobalModel.prototype.getOption = function () {\n    var option = (0,util.clone)(this.option);\n    (0,util.each)(option, function (optInMainType, mainType) {\n      if (Component/* default */.A.hasClass(mainType)) {\n        var opts = model/* normalizeToArray */.qB(optInMainType);\n        // Inner cmpts need to be removed.\n        // Inner cmpts might not be at last since ec5.0, but still\n        // compatible for users: if inner cmpt at last, splice the returned array.\n        var realLen = opts.length;\n        var metNonInner = false;\n        for (var i = realLen - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (opts[i] && !model/* isComponentIdInternal */.oh(opts[i])) {\n            metNonInner = true;\n          } else {\n            opts[i] = null;\n            !metNonInner && realLen--;\n          }\n        }\n        opts.length = realLen;\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  };\n  GlobalModel.prototype.getTheme = function () {\n    return this._theme;\n  };\n  GlobalModel.prototype.getLocaleModel = function () {\n    return this._locale;\n  };\n  GlobalModel.prototype.setUpdatePayload = function (payload) {\n    this._payload = payload;\n  };\n  GlobalModel.prototype.getUpdatePayload = function () {\n    return this._payload;\n  };\n  /**\r\n   * @param idx If not specified, return the first one.\r\n   */\n  GlobalModel.prototype.getComponent = function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n    if (list) {\n      var cmpt = list[idx || 0];\n      if (cmpt) {\n        return cmpt;\n      } else if (idx == null) {\n        for (var i = 0; i < list.length; i++) {\n          if (list[i]) {\n            return list[i];\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * @return Never be null/undefined.\r\n   */\n  GlobalModel.prototype.queryComponents = function (condition) {\n    var mainType = condition.mainType;\n    if (!mainType) {\n      return [];\n    }\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n    var cmpts = this._componentsMap.get(mainType);\n    if (!cmpts || !cmpts.length) {\n      return [];\n    }\n    var result;\n    if (index != null) {\n      result = [];\n      (0,util.each)(model/* normalizeToArray */.qB(index), function (idx) {\n        cmpts[idx] && result.push(cmpts[idx]);\n      });\n    } else if (id != null) {\n      result = queryByIdOrName('id', id, cmpts);\n    } else if (name != null) {\n      result = queryByIdOrName('name', name, cmpts);\n    } else {\n      // Return all non-empty components in that mainType\n      result = (0,util.filter)(cmpts, function (cmpt) {\n        return !!cmpt;\n      });\n    }\n    return filterBySubType(result, condition);\n  };\n  /**\r\n   * The interface is different from queryComponents,\r\n   * which is convenient for inner usage.\r\n   *\r\n   * @usage\r\n   * let result = findComponents(\r\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\r\n   * );\r\n   * let result = findComponents(\r\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\r\n   * );\r\n   * let result = findComponents(\r\n   *     {mainType: 'series',\r\n   *     filter: function (model, index) {...}}\r\n   * );\r\n   * // result like [component0, componnet1, ...]\r\n   */\n  GlobalModel.prototype.findComponents = function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond)\n    // Retrieve all non-empty components.\n    : (0,util.filter)(this._componentsMap.get(mainType), function (cmpt) {\n      return !!cmpt;\n    });\n    return doFilter(filterBySubType(result, condition));\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n    function doFilter(res) {\n      return condition.filter ? (0,util.filter)(res, condition.filter) : res;\n    }\n  };\n  GlobalModel.prototype.eachComponent = function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n    if ((0,util.isFunction)(mainType)) {\n      var ctxForAll_1 = cb;\n      var cbForAll_1 = mainType;\n      componentsMap.each(function (cmpts, componentType) {\n        for (var i = 0; cmpts && i < cmpts.length; i++) {\n          var cmpt = cmpts[i];\n          cmpt && cbForAll_1.call(ctxForAll_1, componentType, cmpt, cmpt.componentIndex);\n        }\n      });\n    } else {\n      var cmpts = (0,util.isString)(mainType) ? componentsMap.get(mainType) : (0,util.isObject)(mainType) ? this.findComponents(mainType) : null;\n      for (var i = 0; cmpts && i < cmpts.length; i++) {\n        var cmpt = cmpts[i];\n        cmpt && cb.call(context, cmpt, cmpt.componentIndex);\n      }\n    }\n  };\n  /**\r\n   * Get series list before filtered by name.\r\n   */\n  GlobalModel.prototype.getSeriesByName = function (name) {\n    var nameStr = model/* convertOptionIdName */.vS(name, null);\n    return (0,util.filter)(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries && nameStr != null && oneSeries.name === nameStr;\n    });\n  };\n  /**\r\n   * Get series list before filtered by index.\r\n   */\n  GlobalModel.prototype.getSeriesByIndex = function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  };\n  /**\r\n   * Get series list before filtered by type.\r\n   * FIXME: rename to getRawSeriesByType?\r\n   */\n  GlobalModel.prototype.getSeriesByType = function (subType) {\n    return (0,util.filter)(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries && oneSeries.subType === subType;\n    });\n  };\n  /**\r\n   * Get all series before filtered.\r\n   */\n  GlobalModel.prototype.getSeries = function () {\n    return (0,util.filter)(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries;\n    });\n  };\n  /**\r\n   * Count series before filtered.\r\n   */\n  GlobalModel.prototype.getSeriesCount = function () {\n    return this._componentsCount.get('series');\n  };\n  /**\r\n   * After filtering, series may be different\r\n   * from raw series.\r\n   */\n  GlobalModel.prototype.eachSeries = function (cb, context) {\n    assertSeriesInitialized(this);\n    (0,util.each)(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  };\n  /**\r\n   * Iterate raw series before filtered.\r\n   *\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\n  GlobalModel.prototype.eachRawSeries = function (cb, context) {\n    (0,util.each)(this._componentsMap.get('series'), function (series) {\n      series && cb.call(context, series, series.componentIndex);\n    });\n  };\n  /**\r\n   * After filtering, series may be different.\r\n   * from raw series.\r\n   */\n  GlobalModel.prototype.eachSeriesByType = function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    (0,util.each)(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  };\n  /**\r\n   * Iterate raw series before filtered of given type.\r\n   */\n  GlobalModel.prototype.eachRawSeriesByType = function (subType, cb, context) {\n    return (0,util.each)(this.getSeriesByType(subType), cb, context);\n  };\n  GlobalModel.prototype.isSeriesFiltered = function (seriesModel) {\n    assertSeriesInitialized(this);\n    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;\n  };\n  GlobalModel.prototype.getCurrentSeriesIndices = function () {\n    return (this._seriesIndices || []).slice();\n  };\n  GlobalModel.prototype.filterSeries = function (cb, context) {\n    assertSeriesInitialized(this);\n    var newSeriesIndices = [];\n    (0,util.each)(this._seriesIndices, function (seriesRawIdx) {\n      var series = this._componentsMap.get('series')[seriesRawIdx];\n      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);\n    }, this);\n    this._seriesIndices = newSeriesIndices;\n    this._seriesIndicesMap = (0,util.createHashMap)(newSeriesIndices);\n  };\n  GlobalModel.prototype.restoreData = function (payload) {\n    reCreateSeriesIndices(this);\n    var componentsMap = this._componentsMap;\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      if (Component/* default */.A.hasClass(componentType)) {\n        componentTypes.push(componentType);\n      }\n    });\n    Component/* default */.A.topologicalTravel(componentTypes, Component/* default */.A.getAllClassMainTypes(), function (componentType) {\n      (0,util.each)(componentsMap.get(componentType), function (component) {\n        if (component && (componentType !== 'series' || !isNotTargetSeries(component, payload))) {\n          component.restoreData();\n        }\n      });\n    });\n  };\n  GlobalModel.internalField = function () {\n    reCreateSeriesIndices = function (ecModel) {\n      var seriesIndices = ecModel._seriesIndices = [];\n      (0,util.each)(ecModel._componentsMap.get('series'), function (series) {\n        // series may have been removed by `replaceMerge`.\n        series && seriesIndices.push(series.componentIndex);\n      });\n      ecModel._seriesIndicesMap = (0,util.createHashMap)(seriesIndices);\n    };\n    assertSeriesInitialized = function (ecModel) {\n      // Components that use _seriesIndices should depends on series component,\n      // which make sure that their initialization is after series.\n      if (false) {}\n    };\n    initBase = function (ecModel, baseOption) {\n      // Using OPTION_INNER_KEY to mark that this option cannot be used outside,\n      // i.e. `chart.setOption(chart.getModel().option);` is forbidden.\n      ecModel.option = {};\n      ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE;\n      // Init with series: [], in case of calling findSeries method\n      // before series initialized.\n      ecModel._componentsMap = (0,util.createHashMap)({\n        series: []\n      });\n      ecModel._componentsCount = (0,util.createHashMap)();\n      // If user spefied `option.aria`, aria will be enable. This detection should be\n      // performed before theme and globalDefault merge.\n      var airaOption = baseOption.aria;\n      if ((0,util.isObject)(airaOption) && airaOption.enabled == null) {\n        airaOption.enabled = true;\n      }\n      mergeTheme(baseOption, ecModel._theme.option);\n      // TODO Needs clone when merging to the unexisted property\n      (0,util.merge)(baseOption, globalDefault, false);\n      ecModel._mergeOption(baseOption, null);\n    };\n  }();\n  return GlobalModel;\n}(Model/* default */.A);\nfunction isNotTargetSeries(seriesModel, payload) {\n  if (payload) {\n    var index = payload.seriesIndex;\n    var id = payload.seriesId;\n    var name_1 = payload.seriesName;\n    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;\n  }\n}\nfunction mergeTheme(option, theme) {\n  // PENDING\n  // NOT use `colorLayer` in theme if option has `color`\n  var notMergeColorLayer = option.color && !option.colorLayer;\n  (0,util.each)(theme, function (themeItem, name) {\n    if (name === 'colorLayer' && notMergeColorLayer) {\n      return;\n    }\n    // If it is component model mainType, the model handles that merge later.\n    // otherwise, merge them here.\n    if (!Component/* default */.A.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? (0,util.clone)(themeItem) : (0,util.merge)(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\nfunction queryByIdOrName(attr, idOrName, cmpts) {\n  // Here is a break from echarts4: string and number are\n  // treated as equal.\n  if ((0,util.isArray)(idOrName)) {\n    var keyMap_1 = (0,util.createHashMap)();\n    (0,util.each)(idOrName, function (idOrNameItem) {\n      if (idOrNameItem != null) {\n        var idName = model/* convertOptionIdName */.vS(idOrNameItem, null);\n        idName != null && keyMap_1.set(idOrNameItem, true);\n      }\n    });\n    return (0,util.filter)(cmpts, function (cmpt) {\n      return cmpt && keyMap_1.get(cmpt[attr]);\n    });\n  } else {\n    var idName_1 = model/* convertOptionIdName */.vS(idOrName, null);\n    return (0,util.filter)(cmpts, function (cmpt) {\n      return cmpt && idName_1 != null && cmpt[attr] === idName_1;\n    });\n  }\n}\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? (0,util.filter)(components, function (cmpt) {\n    return cmpt && cmpt.subType === condition.subType;\n  }) : components;\n}\nfunction normalizeSetOptionInput(opts) {\n  var replaceMergeMainTypeMap = (0,util.createHashMap)();\n  opts && (0,util.each)(model/* normalizeToArray */.qB(opts.replaceMerge), function (mainType) {\n    if (false) {}\n    replaceMergeMainTypeMap.set(mainType, true);\n  });\n  return {\n    replaceMergeMainTypeMap: replaceMergeMainTypeMap\n  };\n}\n(0,util.mixin)(GlobalModel, palette/* PaletteMixin */.X);\n/* harmony default export */ const Global = (GlobalModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMxMDAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvZ2xvYmFsRGVmYXVsdC5qcz81M2JmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9HbG9iYWwuanM/ZDNkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbnZhciBwbGF0Zm9ybSA9ICcnO1xuLy8gTmF2aWdhdG9yIG5vdCBleGlzdHMgaW4gbm9kZVxuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8qIGdsb2JhbCBuYXZpZ2F0b3IgKi9cbiAgcGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm0gfHwgJyc7XG59XG52YXIgZGVjYWxDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDAuMiknO1xuZXhwb3J0IGRlZmF1bHQge1xuICBkYXJrTW9kZTogJ2F1dG8nLFxuICAvLyBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgY29sb3JCeTogJ3NlcmllcycsXG4gIGNvbG9yOiBbJyM1NDcwYzYnLCAnIzkxY2M3NScsICcjZmFjODU4JywgJyNlZTY2NjYnLCAnIzczYzBkZScsICcjM2JhMjcyJywgJyNmYzg0NTInLCAnIzlhNjBiNCcsICcjZWE3Y2NjJ10sXG4gIGdyYWRpZW50Q29sb3I6IFsnI2Y2ZWZhNicsICcjZDg4MjczJywgJyNiZjQ0NGMnXSxcbiAgYXJpYToge1xuICAgIGRlY2FsOiB7XG4gICAgICBkZWNhbHM6IFt7XG4gICAgICAgIGNvbG9yOiBkZWNhbENvbG9yLFxuICAgICAgICBkYXNoQXJyYXlYOiBbMSwgMF0sXG4gICAgICAgIGRhc2hBcnJheVk6IFsyLCA1XSxcbiAgICAgICAgc3ltYm9sU2l6ZTogMSxcbiAgICAgICAgcm90YXRpb246IE1hdGguUEkgLyA2XG4gICAgICB9LCB7XG4gICAgICAgIGNvbG9yOiBkZWNhbENvbG9yLFxuICAgICAgICBzeW1ib2w6ICdjaXJjbGUnLFxuICAgICAgICBkYXNoQXJyYXlYOiBbWzgsIDhdLCBbMCwgOCwgOCwgMF1dLFxuICAgICAgICBkYXNoQXJyYXlZOiBbNiwgMF0sXG4gICAgICAgIHN5bWJvbFNpemU6IDAuOFxuICAgICAgfSwge1xuICAgICAgICBjb2xvcjogZGVjYWxDb2xvcixcbiAgICAgICAgZGFzaEFycmF5WDogWzEsIDBdLFxuICAgICAgICBkYXNoQXJyYXlZOiBbNCwgM10sXG4gICAgICAgIHJvdGF0aW9uOiAtTWF0aC5QSSAvIDRcbiAgICAgIH0sIHtcbiAgICAgICAgY29sb3I6IGRlY2FsQ29sb3IsXG4gICAgICAgIGRhc2hBcnJheVg6IFtbNiwgNl0sIFswLCA2LCA2LCAwXV0sXG4gICAgICAgIGRhc2hBcnJheVk6IFs2LCAwXVxuICAgICAgfSwge1xuICAgICAgICBjb2xvcjogZGVjYWxDb2xvcixcbiAgICAgICAgZGFzaEFycmF5WDogW1sxLCAwXSwgWzEsIDZdXSxcbiAgICAgICAgZGFzaEFycmF5WTogWzEsIDAsIDYsIDBdLFxuICAgICAgICByb3RhdGlvbjogTWF0aC5QSSAvIDRcbiAgICAgIH0sIHtcbiAgICAgICAgY29sb3I6IGRlY2FsQ29sb3IsXG4gICAgICAgIHN5bWJvbDogJ3RyaWFuZ2xlJyxcbiAgICAgICAgZGFzaEFycmF5WDogW1s5LCA5XSwgWzAsIDksIDksIDBdXSxcbiAgICAgICAgZGFzaEFycmF5WTogWzcsIDJdLFxuICAgICAgICBzeW1ib2xTaXplOiAwLjc1XG4gICAgICB9XVxuICAgIH1cbiAgfSxcbiAgLy8gSWYgeEF4aXMgYW5kIHlBeGlzIGRlY2xhcmVkLCBncmlkIGlzIGNyZWF0ZWQgYnkgZGVmYXVsdC5cbiAgLy8gZ3JpZDoge30sXG4gIHRleHRTdHlsZToge1xuICAgIC8vIGNvbG9yOiAnIzAwMCcsXG4gICAgLy8gZGVjb3JhdGlvbjogJ25vbmUnLFxuICAgIC8vIFBFTkRJTkdcbiAgICBmb250RmFtaWx5OiBwbGF0Zm9ybS5tYXRjaCgvXldpbi8pID8gJ01pY3Jvc29mdCBZYUhlaScgOiAnc2Fucy1zZXJpZicsXG4gICAgLy8gZm9udEZhbWlseTogJ0FyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJyxcbiAgICBmb250U2l6ZTogMTIsXG4gICAgZm9udFN0eWxlOiAnbm9ybWFsJyxcbiAgICBmb250V2VpZ2h0OiAnbm9ybWFsJ1xuICB9LFxuICAvLyBodHRwOi8vYmxvZ3MuYWRvYmUuY29tL3dlYnBsYXRmb3JtLzIwMTQvMDIvMjQvdXNpbmctYmxlbmQtbW9kZXMtaW4taHRtbC1jYW52YXMvXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gIC8vIERlZmF1bHQgaXMgc291cmNlLW92ZXJcbiAgYmxlbmRNb2RlOiBudWxsLFxuICBzdGF0ZUFuaW1hdGlvbjoge1xuICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgZWFzaW5nOiAnY3ViaWNPdXQnXG4gIH0sXG4gIGFuaW1hdGlvbjogJ2F1dG8nLFxuICBhbmltYXRpb25EdXJhdGlvbjogMTAwMCxcbiAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDUwMCxcbiAgYW5pbWF0aW9uRWFzaW5nOiAnY3ViaWNJbk91dCcsXG4gIGFuaW1hdGlvbkVhc2luZ1VwZGF0ZTogJ2N1YmljSW5PdXQnLFxuICBhbmltYXRpb25UaHJlc2hvbGQ6IDIwMDAsXG4gIC8vIENvbmZpZ3VyYXRpb24gZm9yIHByb2dyZXNzaXZlL2luY3JlbWVudGFsIHJlbmRlcmluZ1xuICBwcm9ncmVzc2l2ZVRocmVzaG9sZDogMzAwMCxcbiAgcHJvZ3Jlc3NpdmU6IDQwMCxcbiAgLy8gVGhyZXNob2xkIG9mIGlmIHVzZSBzaW5nbGUgaG92ZXIgbGF5ZXIgdG8gb3B0aW1pemUuXG4gIC8vIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgYGhvdmVyTGF5ZXJUaHJlc2hvbGRgIGlzIGVxdWl2YWxlbnQgdG8gb3IgbGVzcyB0aGFuXG4gIC8vIGBwcm9ncmVzc2l2ZVRocmVzaG9sZGAsIG90aGVyd2lzZSBob3ZlciB3aWxsIGNhdXNlIHJlc3RhcnQgb2YgcHJvZ3Jlc3NpdmUsXG4gIC8vIHdoaWNoIGlzIHVuZXhwZWN0ZWQuXG4gIC8vIHNlZSBleGFtcGxlIDxlY2hhcnRzL3Rlc3QvaGVhdG1hcC1sYXJnZS5odG1sPi5cbiAgaG92ZXJMYXllclRocmVzaG9sZDogMzAwMCxcbiAgLy8gU2VlOiBtb2R1bGU6ZWNoYXJ0cy9zY2FsZS9UaW1lXG4gIHVzZVVUQzogZmFsc2Vcbn07IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbi8qKlxyXG4gKiBDYXV0aW9uOiBJZiB0aGUgbWVjaGFuaXNtIHNob3VsZCBiZSBjaGFuZ2VkIHNvbWUgZGF5LCB0aGVzZSBjYXNlc1xyXG4gKiBzaG91bGQgYmUgY29uc2lkZXJlZDpcclxuICpcclxuICogKDEpIEluIGBtZXJnZSBvcHRpb25gIG1vZGUsIGlmIHVzaW5nIHRoZSBzYW1lIG9wdGlvbiB0byBjYWxsIGBzZXRPcHRpb25gXHJcbiAqIG1hbnkgdGltZXMsIHRoZSByZXN1bHQgc2hvdWxkIGJlIHRoZSBzYW1lICh0cnkgb3VyIGJlc3QgdG8gZW5zdXJlIHRoYXQpLlxyXG4gKiAoMikgSW4gYG1lcmdlIG9wdGlvbmAgbW9kZSwgaWYgYSBjb21wb25lbnQgaGFzIG5vIGlkL25hbWUgc3BlY2lmaWVkLCBpdFxyXG4gKiB3aWxsIGJlIG1lcmdlZCBieSBpbmRleCwgYW5kIHRoZSByZXN1bHQgc2VxdWVuY2Ugb2YgdGhlIGNvbXBvbmVudHMgaXNcclxuICogY29uc2lzdGVudCB0byB0aGUgb3JpZ2luYWwgc2VxdWVuY2UuXHJcbiAqICgzKSBJbiBgcmVwbGFjZU1lcmdlYCBtb2RlLCBrZWVwIHRoZSByZXN1bHQgc2VxdWVuY2Ugb2YgdGhlIGNvbXBvbmVudHMgaXNcclxuICogY29uc2lzdGVudCB0byB0aGUgb3JpZ2luYWwgc2VxdWVuY2UsIGV2ZW4gdGhvdWdoIHRoZXJlIG1pZ2h0IHJlc3VsdCBpbiBcImhvbGVcIi5cclxuICogKDQpIGByZXNldGAgZmVhdHVyZSAoaW4gdG9vbGJveCkuIEZpbmQgZGV0YWlsZWQgaW5mbyBpbiBjb21tZW50cyBhYm91dFxyXG4gKiBgbWVyZ2VPcHRpb25gIGluIG1vZHVsZTplY2hhcnRzL21vZGVsL09wdGlvbk1hbmFnZXIuXHJcbiAqL1xuaW1wb3J0IHsgZWFjaCwgZmlsdGVyLCBpc0FycmF5LCBpc09iamVjdCwgaXNTdHJpbmcsIGNyZWF0ZUhhc2hNYXAsIGFzc2VydCwgY2xvbmUsIG1lcmdlLCBleHRlbmQsIG1peGluLCBpc0Z1bmN0aW9uIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIG1vZGVsVXRpbCBmcm9tICcuLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCBNb2RlbCBmcm9tICcuL01vZGVsLmpzJztcbmltcG9ydCBDb21wb25lbnRNb2RlbCBmcm9tICcuL0NvbXBvbmVudC5qcyc7XG5pbXBvcnQgZ2xvYmFsRGVmYXVsdCBmcm9tICcuL2dsb2JhbERlZmF1bHQuanMnO1xuaW1wb3J0IHsgcmVzZXRTb3VyY2VEZWZhdWx0ZXIgfSBmcm9tICcuLi9kYXRhL2hlbHBlci9zb3VyY2VIZWxwZXIuanMnO1xuaW1wb3J0IHsgY29uY2F0SW50ZXJuYWxPcHRpb25zIH0gZnJvbSAnLi9pbnRlcm5hbENvbXBvbmVudENyZWF0b3IuanMnO1xuaW1wb3J0IHsgUGFsZXR0ZU1peGluIH0gZnJvbSAnLi9taXhpbi9wYWxldHRlLmpzJztcbmltcG9ydCB7IGVycm9yLCB3YXJuIH0gZnJvbSAnLi4vdXRpbC9sb2cuanMnO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEludGVybmFsIG1ldGhvZCBuYW1lczpcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgcmVDcmVhdGVTZXJpZXNJbmRpY2VzO1xudmFyIGFzc2VydFNlcmllc0luaXRpYWxpemVkO1xudmFyIGluaXRCYXNlO1xudmFyIE9QVElPTl9JTk5FUl9LRVkgPSAnXFwwX2VjX2lubmVyJztcbnZhciBPUFRJT05fSU5ORVJfVkFMVUUgPSAxO1xudmFyIEJVSVRJTl9DT01QT05FTlRTX01BUCA9IHtcbiAgZ3JpZDogJ0dyaWRDb21wb25lbnQnLFxuICBwb2xhcjogJ1BvbGFyQ29tcG9uZW50JyxcbiAgZ2VvOiAnR2VvQ29tcG9uZW50JyxcbiAgc2luZ2xlQXhpczogJ1NpbmdsZUF4aXNDb21wb25lbnQnLFxuICBwYXJhbGxlbDogJ1BhcmFsbGVsQ29tcG9uZW50JyxcbiAgY2FsZW5kYXI6ICdDYWxlbmRhckNvbXBvbmVudCcsXG4gIGdyYXBoaWM6ICdHcmFwaGljQ29tcG9uZW50JyxcbiAgdG9vbGJveDogJ1Rvb2xib3hDb21wb25lbnQnLFxuICB0b29sdGlwOiAnVG9vbHRpcENvbXBvbmVudCcsXG4gIGF4aXNQb2ludGVyOiAnQXhpc1BvaW50ZXJDb21wb25lbnQnLFxuICBicnVzaDogJ0JydXNoQ29tcG9uZW50JyxcbiAgdGl0bGU6ICdUaXRsZUNvbXBvbmVudCcsXG4gIHRpbWVsaW5lOiAnVGltZWxpbmVDb21wb25lbnQnLFxuICBtYXJrUG9pbnQ6ICdNYXJrUG9pbnRDb21wb25lbnQnLFxuICBtYXJrTGluZTogJ01hcmtMaW5lQ29tcG9uZW50JyxcbiAgbWFya0FyZWE6ICdNYXJrQXJlYUNvbXBvbmVudCcsXG4gIGxlZ2VuZDogJ0xlZ2VuZENvbXBvbmVudCcsXG4gIGRhdGFab29tOiAnRGF0YVpvb21Db21wb25lbnQnLFxuICB2aXN1YWxNYXA6ICdWaXN1YWxNYXBDb21wb25lbnQnLFxuICAvLyBhcmlhOiAnQXJpYUNvbXBvbmVudCcsXG4gIC8vIGRhdGFzZXQ6ICdEYXRhc2V0Q29tcG9uZW50JyxcbiAgLy8gRGVwZW5kZW5jaWVzXG4gIHhBeGlzOiAnR3JpZENvbXBvbmVudCcsXG4gIHlBeGlzOiAnR3JpZENvbXBvbmVudCcsXG4gIGFuZ2xlQXhpczogJ1BvbGFyQ29tcG9uZW50JyxcbiAgcmFkaXVzQXhpczogJ1BvbGFyQ29tcG9uZW50J1xufTtcbnZhciBCVUlMVElOX0NIQVJUU19NQVAgPSB7XG4gIGxpbmU6ICdMaW5lQ2hhcnQnLFxuICBiYXI6ICdCYXJDaGFydCcsXG4gIHBpZTogJ1BpZUNoYXJ0JyxcbiAgc2NhdHRlcjogJ1NjYXR0ZXJDaGFydCcsXG4gIHJhZGFyOiAnUmFkYXJDaGFydCcsXG4gIG1hcDogJ01hcENoYXJ0JyxcbiAgdHJlZTogJ1RyZWVDaGFydCcsXG4gIHRyZWVtYXA6ICdUcmVlbWFwQ2hhcnQnLFxuICBncmFwaDogJ0dyYXBoQ2hhcnQnLFxuICBnYXVnZTogJ0dhdWdlQ2hhcnQnLFxuICBmdW5uZWw6ICdGdW5uZWxDaGFydCcsXG4gIHBhcmFsbGVsOiAnUGFyYWxsZWxDaGFydCcsXG4gIHNhbmtleTogJ1NhbmtleUNoYXJ0JyxcbiAgYm94cGxvdDogJ0JveHBsb3RDaGFydCcsXG4gIGNhbmRsZXN0aWNrOiAnQ2FuZGxlc3RpY2tDaGFydCcsXG4gIGVmZmVjdFNjYXR0ZXI6ICdFZmZlY3RTY2F0dGVyQ2hhcnQnLFxuICBsaW5lczogJ0xpbmVzQ2hhcnQnLFxuICBoZWF0bWFwOiAnSGVhdG1hcENoYXJ0JyxcbiAgcGljdG9yaWFsQmFyOiAnUGljdG9yaWFsQmFyQ2hhcnQnLFxuICB0aGVtZVJpdmVyOiAnVGhlbWVSaXZlckNoYXJ0JyxcbiAgc3VuYnVyc3Q6ICdTdW5idXJzdENoYXJ0JyxcbiAgY3VzdG9tOiAnQ3VzdG9tQ2hhcnQnXG59O1xudmFyIGNvbXBvbmV0c01pc3NpbmdMb2dQcmludGVkID0ge307XG5mdW5jdGlvbiBjaGVja01pc3NpbmdDb21wb25lbnRzKG9wdGlvbikge1xuICBlYWNoKG9wdGlvbiwgZnVuY3Rpb24gKGNvbXBvbmVudE9wdGlvbiwgbWFpblR5cGUpIHtcbiAgICBpZiAoIUNvbXBvbmVudE1vZGVsLmhhc0NsYXNzKG1haW5UeXBlKSkge1xuICAgICAgdmFyIGNvbXBvbmVudEltcG9ydE5hbWUgPSBCVUlUSU5fQ09NUE9ORU5UU19NQVBbbWFpblR5cGVdO1xuICAgICAgaWYgKGNvbXBvbmVudEltcG9ydE5hbWUgJiYgIWNvbXBvbmV0c01pc3NpbmdMb2dQcmludGVkW2NvbXBvbmVudEltcG9ydE5hbWVdKSB7XG4gICAgICAgIGVycm9yKFwiQ29tcG9uZW50IFwiICsgbWFpblR5cGUgKyBcIiBpcyB1c2VkIGJ1dCBub3QgaW1wb3J0ZWQuXFxuaW1wb3J0IHsgXCIgKyBjb21wb25lbnRJbXBvcnROYW1lICsgXCIgfSBmcm9tICdlY2hhcnRzL2NvbXBvbmVudHMnO1xcbmVjaGFydHMudXNlKFtcIiArIGNvbXBvbmVudEltcG9ydE5hbWUgKyBcIl0pO1wiKTtcbiAgICAgICAgY29tcG9uZXRzTWlzc2luZ0xvZ1ByaW50ZWRbY29tcG9uZW50SW1wb3J0TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG52YXIgR2xvYmFsTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoR2xvYmFsTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEdsb2JhbE1vZGVsKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICBHbG9iYWxNb2RlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCB0aGVtZSwgbG9jYWxlLCBvcHRpb25NYW5hZ2VyKSB7XG4gICAgdGhlbWUgPSB0aGVtZSB8fCB7fTtcbiAgICB0aGlzLm9wdGlvbiA9IG51bGw7IC8vIE1hcmsgYXMgbm90IGluaXRpYWxpemVkLlxuICAgIHRoaXMuX3RoZW1lID0gbmV3IE1vZGVsKHRoZW1lKTtcbiAgICB0aGlzLl9sb2NhbGUgPSBuZXcgTW9kZWwobG9jYWxlKTtcbiAgICB0aGlzLl9vcHRpb25NYW5hZ2VyID0gb3B0aW9uTWFuYWdlcjtcbiAgfTtcbiAgR2xvYmFsTW9kZWwucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24sIG9wdHMsIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChvcHRpb24gIT0gbnVsbCwgJ29wdGlvbiBpcyBudWxsL3VuZGVmaW5lZCcpO1xuICAgICAgYXNzZXJ0KG9wdGlvbltPUFRJT05fSU5ORVJfS0VZXSAhPT0gT1BUSU9OX0lOTkVSX1ZBTFVFLCAncGxlYXNlIHVzZSBjaGFydC5nZXRPcHRpb24oKScpO1xuICAgIH1cbiAgICB2YXIgaW5uZXJPcHQgPSBub3JtYWxpemVTZXRPcHRpb25JbnB1dChvcHRzKTtcbiAgICB0aGlzLl9vcHRpb25NYW5hZ2VyLnNldE9wdGlvbihvcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLCBpbm5lck9wdCk7XG4gICAgdGhpcy5fcmVzZXRPcHRpb24obnVsbCwgaW5uZXJPcHQpO1xuICB9O1xuICAvKipcclxuICAgKiBAcGFyYW0gdHlwZSBudWxsL3VuZGVmaW5lZDogcmVzZXQgYWxsLlxyXG4gICAqICAgICAgICAncmVjcmVhdGUnOiBmb3JjZSByZWNyZWF0ZSBhbGwuXHJcbiAgICogICAgICAgICd0aW1lbGluZSc6IG9ubHkgcmVzZXQgdGltZWxpbmUgb3B0aW9uXHJcbiAgICogICAgICAgICdtZWRpYSc6IG9ubHkgcmVzZXQgbWVkaWEgcXVlcnkgb3B0aW9uXHJcbiAgICogQHJldHVybiBXaGV0aGVyIG9wdGlvbiBjaGFuZ2VkLlxyXG4gICAqL1xuICBHbG9iYWxNb2RlbC5wcm90b3R5cGUucmVzZXRPcHRpb24gPSBmdW5jdGlvbiAodHlwZSwgb3B0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc2V0T3B0aW9uKHR5cGUsIG5vcm1hbGl6ZVNldE9wdGlvbklucHV0KG9wdCkpO1xuICB9O1xuICBHbG9iYWxNb2RlbC5wcm90b3R5cGUuX3Jlc2V0T3B0aW9uID0gZnVuY3Rpb24gKHR5cGUsIG9wdCkge1xuICAgIHZhciBvcHRpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG9wdGlvbk1hbmFnZXIgPSB0aGlzLl9vcHRpb25NYW5hZ2VyO1xuICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAncmVjcmVhdGUnKSB7XG4gICAgICB2YXIgYmFzZU9wdGlvbiA9IG9wdGlvbk1hbmFnZXIubW91bnRPcHRpb24odHlwZSA9PT0gJ3JlY3JlYXRlJyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja01pc3NpbmdDb21wb25lbnRzKGJhc2VPcHRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLm9wdGlvbiB8fCB0eXBlID09PSAncmVjcmVhdGUnKSB7XG4gICAgICAgIGluaXRCYXNlKHRoaXMsIGJhc2VPcHRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXN0b3JlRGF0YSgpO1xuICAgICAgICB0aGlzLl9tZXJnZU9wdGlvbihiYXNlT3B0aW9uLCBvcHQpO1xuICAgICAgfVxuICAgICAgb3B0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAndGltZWxpbmUnIHx8IHR5cGUgPT09ICdtZWRpYScpIHtcbiAgICAgIHRoaXMucmVzdG9yZURhdGEoKTtcbiAgICB9XG4gICAgLy8gQnkgZGVzaWduLCBpZiBgc2V0T3B0aW9uKG9wdGlvbjIpYCBhdCB0aGUgc2Vjb25kIHRpbWUsIGFuZCBgb3B0aW9uMmAgaXMgYSBgRUNVbml0T3B0aW9uYCxcbiAgICAvLyBpdCBzaG91bGQgYmV0dGVyIG5vdCBoYXZlIHRoZSBzYW1lIHByb3BzIHdpdGggYE1lZGlhVW5pdFsnb3B0aW9uJ11gLlxuICAgIC8vIEJlY2F1c2UgZWl0aGVyIGBvcHRpb24yYCBvciBgTWVkaWFVbml0WydvcHRpb24nXWAgd2lsbCBiZSBhbHdheXMgbWVyZ2VkIHRvIFwiY3VycmVudCBvcHRpb25cIlxuICAgIC8vIHJhdGhlciB0aGFuIG9yaWdpbmFsIFwiYmFzZU9wdGlvblwiLiBJZiB0aGV5IGJvdGggb3ZlcnJpZGUgYSBwcm9wLCB0aGUgcmVzdWx0IG1pZ2h0IGJlXG4gICAgLy8gdW5leHBlY3RlZCB3aGVuIG1lZGlhIHN0YXRlIGNoYW5nZWQgYWZ0ZXIgYHNldE9wdGlvbmAgY2FsbGVkLlxuICAgIC8vIElmIHdlIHJlYWxseSBuZWVkIHRvIG1vZGlmeSBhIHByb3BzIGluIGVhY2ggYE1lZGlhVW5pdFsnb3B0aW9uJ11gLCB1c2UgdGhlIGZ1bGwgdmVyc2lvblxuICAgIC8vIChge2Jhc2VPcHRpb24sIG1lZGlhfWApIGluIGBzZXRPcHRpb25gLlxuICAgIC8vIEZvciBgdGltZWxpbmVgLCB0aGUgY2FzZSBpcyB0aGUgc2FtZS5cbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3JlY3JlYXRlJyB8fCB0eXBlID09PSAndGltZWxpbmUnKSB7XG4gICAgICB2YXIgdGltZWxpbmVPcHRpb24gPSBvcHRpb25NYW5hZ2VyLmdldFRpbWVsaW5lT3B0aW9uKHRoaXMpO1xuICAgICAgaWYgKHRpbWVsaW5lT3B0aW9uKSB7XG4gICAgICAgIG9wdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9tZXJnZU9wdGlvbih0aW1lbGluZU9wdGlvbiwgb3B0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICdyZWNyZWF0ZScgfHwgdHlwZSA9PT0gJ21lZGlhJykge1xuICAgICAgdmFyIG1lZGlhT3B0aW9ucyA9IG9wdGlvbk1hbmFnZXIuZ2V0TWVkaWFPcHRpb24odGhpcyk7XG4gICAgICBpZiAobWVkaWFPcHRpb25zLmxlbmd0aCkge1xuICAgICAgICBlYWNoKG1lZGlhT3B0aW9ucywgZnVuY3Rpb24gKG1lZGlhT3B0aW9uKSB7XG4gICAgICAgICAgb3B0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fbWVyZ2VPcHRpb24obWVkaWFPcHRpb24sIG9wdCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uQ2hhbmdlZDtcbiAgfTtcbiAgR2xvYmFsTW9kZWwucHJvdG90eXBlLm1lcmdlT3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIHRoaXMuX21lcmdlT3B0aW9uKG9wdGlvbiwgbnVsbCk7XG4gIH07XG4gIEdsb2JhbE1vZGVsLnByb3RvdHlwZS5fbWVyZ2VPcHRpb24gPSBmdW5jdGlvbiAobmV3T3B0aW9uLCBvcHQpIHtcbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIGNvbXBvbmVudHNNYXAgPSB0aGlzLl9jb21wb25lbnRzTWFwO1xuICAgIHZhciBjb21wb25lbnRzQ291bnQgPSB0aGlzLl9jb21wb25lbnRzQ291bnQ7XG4gICAgdmFyIG5ld0NtcHRUeXBlcyA9IFtdO1xuICAgIHZhciBuZXdDbXB0VHlwZU1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgICB2YXIgcmVwbGFjZU1lcmdlTWFpblR5cGVNYXAgPSBvcHQgJiYgb3B0LnJlcGxhY2VNZXJnZU1haW5UeXBlTWFwO1xuICAgIHJlc2V0U291cmNlRGVmYXVsdGVyKHRoaXMpO1xuICAgIC8vIElmIG5vIGNvbXBvbmVudCBjbGFzcywgbWVyZ2UgZGlyZWN0bHkuXG4gICAgLy8gRm9yIGV4YW1wbGU6IGNvbG9yLCBhbmltYWl0b24gb3B0aW9ucywgZXRjLlxuICAgIGVhY2gobmV3T3B0aW9uLCBmdW5jdGlvbiAoY29tcG9uZW50T3B0aW9uLCBtYWluVHlwZSkge1xuICAgICAgaWYgKGNvbXBvbmVudE9wdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3MobWFpblR5cGUpKSB7XG4gICAgICAgIC8vIGdsb2JhbFNldHRpbmdUYXNrLmRpcnR5KCk7XG4gICAgICAgIG9wdGlvblttYWluVHlwZV0gPSBvcHRpb25bbWFpblR5cGVdID09IG51bGwgPyBjbG9uZShjb21wb25lbnRPcHRpb24pIDogbWVyZ2Uob3B0aW9uW21haW5UeXBlXSwgY29tcG9uZW50T3B0aW9uLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAobWFpblR5cGUpIHtcbiAgICAgICAgbmV3Q21wdFR5cGVzLnB1c2gobWFpblR5cGUpO1xuICAgICAgICBuZXdDbXB0VHlwZU1hcC5zZXQobWFpblR5cGUsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyZXBsYWNlTWVyZ2VNYWluVHlwZU1hcCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBtYWluVHlwZSBgeHh4YCBpbiBgcmVwbGFjZU1lcmdlYCBidXQgbm90IGRlY2xhcmVkIGluIG9wdGlvbixcbiAgICAgIC8vIHdlIHRyYWRlIGl0IGFzIGl0IGlzIGRlY2xhcmVkIGluIG9wdGlvbiBhcyBge3h4eDogW119YC4gQmVjYXVzZTpcbiAgICAgIC8vICgxKSBmb3Igbm9ybWFsIG1lcmdlLCBge3h4eDogbnVsbC91bmRlZmluZWR9YCBhcmUgdGhlIHNhbWUgbWVhbmluZyBhcyBge3h4eDogW119YC5cbiAgICAgIC8vICgyKSBzb21lIHByZXByb2Nlc3NvciBtYXkgY29udmVydCBzb21lIG9mIGB7eHh4OiBudWxsL3VuZGVmaW5lZH1gIHRvIGB7eHh4OiBbXX1gLlxuICAgICAgcmVwbGFjZU1lcmdlTWFpblR5cGVNYXAuZWFjaChmdW5jdGlvbiAodmFsLCBtYWluVHlwZUluUmVwbGFjZU1lcmdlKSB7XG4gICAgICAgIGlmIChDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhtYWluVHlwZUluUmVwbGFjZU1lcmdlKSAmJiAhbmV3Q21wdFR5cGVNYXAuZ2V0KG1haW5UeXBlSW5SZXBsYWNlTWVyZ2UpKSB7XG4gICAgICAgICAgbmV3Q21wdFR5cGVzLnB1c2gobWFpblR5cGVJblJlcGxhY2VNZXJnZSk7XG4gICAgICAgICAgbmV3Q21wdFR5cGVNYXAuc2V0KG1haW5UeXBlSW5SZXBsYWNlTWVyZ2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgQ29tcG9uZW50TW9kZWwudG9wb2xvZ2ljYWxUcmF2ZWwobmV3Q21wdFR5cGVzLCBDb21wb25lbnRNb2RlbC5nZXRBbGxDbGFzc01haW5UeXBlcygpLCB2aXNpdENvbXBvbmVudCwgdGhpcyk7XG4gICAgZnVuY3Rpb24gdmlzaXRDb21wb25lbnQobWFpblR5cGUpIHtcbiAgICAgIHZhciBuZXdDbXB0T3B0aW9uTGlzdCA9IGNvbmNhdEludGVybmFsT3B0aW9ucyh0aGlzLCBtYWluVHlwZSwgbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkobmV3T3B0aW9uW21haW5UeXBlXSkpO1xuICAgICAgdmFyIG9sZENtcHRMaXN0ID0gY29tcG9uZW50c01hcC5nZXQobWFpblR5cGUpO1xuICAgICAgdmFyIG1lcmdlTW9kZSA9XG4gICAgICAvLyBgIW9sZENtcHRMaXN0YCBtZWFucyBpbml0LiBTZWUgdGhlIGNvbW1lbnQgaW4gYG1hcHBpbmdUb0V4aXN0c2BcbiAgICAgICFvbGRDbXB0TGlzdCA/ICdyZXBsYWNlQWxsJyA6IHJlcGxhY2VNZXJnZU1haW5UeXBlTWFwICYmIHJlcGxhY2VNZXJnZU1haW5UeXBlTWFwLmdldChtYWluVHlwZSkgPyAncmVwbGFjZU1lcmdlJyA6ICdub3JtYWxNZXJnZSc7XG4gICAgICB2YXIgbWFwcGluZ1Jlc3VsdCA9IG1vZGVsVXRpbC5tYXBwaW5nVG9FeGlzdHMob2xkQ21wdExpc3QsIG5ld0NtcHRPcHRpb25MaXN0LCBtZXJnZU1vZGUpO1xuICAgICAgLy8gU2V0IG1haW5UeXBlIGFuZCBjb21wbGV0ZSBzdWJUeXBlLlxuICAgICAgbW9kZWxVdGlsLnNldENvbXBvbmVudFR5cGVUb0tleUluZm8obWFwcGluZ1Jlc3VsdCwgbWFpblR5cGUsIENvbXBvbmVudE1vZGVsKTtcbiAgICAgIC8vIEVtcHR5IGl0IGJlZm9yZSB0aGUgdHJhdmVsLCBpbiBvcmRlciB0byBwcmV2ZW50IGB0aGlzLl9jb21wb25lbnRzTWFwYFxuICAgICAgLy8gZnJvbSBiZWluZyB1c2VkIGluIHRoZSBgaW5pdGAvYG1lcmdlT3B0aW9uYC9gb3B0aW9uVXBkYXRlZGAgb2Ygc29tZVxuICAgICAgLy8gY29tcG9uZW50cywgd2hpY2ggaXMgcHJvYmFibHkgaW5jb3JyZWN0IGxvZ2ljLlxuICAgICAgb3B0aW9uW21haW5UeXBlXSA9IG51bGw7XG4gICAgICBjb21wb25lbnRzTWFwLnNldChtYWluVHlwZSwgbnVsbCk7XG4gICAgICBjb21wb25lbnRzQ291bnQuc2V0KG1haW5UeXBlLCAwKTtcbiAgICAgIHZhciBvcHRpb25zQnlNYWluVHlwZSA9IFtdO1xuICAgICAgdmFyIGNtcHRzQnlNYWluVHlwZSA9IFtdO1xuICAgICAgdmFyIGNtcHRzQ291bnRCeU1haW5UeXBlID0gMDtcbiAgICAgIHZhciB0b29sdGlwRXhpc3RzO1xuICAgICAgdmFyIHRvb2x0aXBXYXJuaW5nTG9nZ2VkO1xuICAgICAgZWFjaChtYXBwaW5nUmVzdWx0LCBmdW5jdGlvbiAocmVzdWx0SXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE1vZGVsID0gcmVzdWx0SXRlbS5leGlzdGluZztcbiAgICAgICAgdmFyIG5ld0NtcHRPcHRpb24gPSByZXN1bHRJdGVtLm5ld09wdGlvbjtcbiAgICAgICAgaWYgKCFuZXdDbXB0T3B0aW9uKSB7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudE1vZGVsKSB7XG4gICAgICAgICAgICAvLyBDb25zaWRlciB3aGVyZSBpcyBubyBuZXcgb3B0aW9uIGFuZCBzaG91bGQgYmUgbWVyZ2VkIHVzaW5nIHt9LFxuICAgICAgICAgICAgLy8gc2VlIHJlbW92ZUVkZ2VBbmRBZGQgaW4gdG9wb2xvZ2ljYWxUcmF2ZWwgYW5kXG4gICAgICAgICAgICAvLyBDb21wb25lbnRNb2RlbC5nZXRBbGxDbGFzc01haW5UeXBlcy5cbiAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm1lcmdlT3B0aW9uKHt9LCB0aGlzKTtcbiAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm9wdGlvblVwZGF0ZWQoe30sIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgbm8gYm90aCBgcmVzdWx0SXRlbS5leGlzdGAgYW5kIGByZXN1bHRJdGVtLm9wdGlvbmAsXG4gICAgICAgICAgLy8gZWl0aGVyIGl0IGlzIGluIGByZXBsYWNlTWVyZ2VgIGFuZCBub3QgbWF0Y2hlZCBieSBhbnkgaWQsXG4gICAgICAgICAgLy8gb3IgaXQgaGFzIGJlZW4gcmVtb3ZlZCBpbiBwcmV2aW91cyBgcmVwbGFjZU1lcmdlYCBhbmQgbGVmdCBhIFwiaG9sZVwiIGluIHRoaXMgY29tcG9uZW50IGluZGV4LlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpc1Nlcmllc1R5cGUgPSBtYWluVHlwZSA9PT0gJ3Nlcmllcyc7XG4gICAgICAgICAgdmFyIENvbXBvbmVudE1vZGVsQ2xhc3MgPSBDb21wb25lbnRNb2RlbC5nZXRDbGFzcyhtYWluVHlwZSwgcmVzdWx0SXRlbS5rZXlJbmZvLnN1YlR5cGUsICFpc1Nlcmllc1R5cGUgLy8gR2l2ZSBhIG1vcmUgZGV0YWlsZWQgd2FybiBsYXRlciBpZiBzZXJpZXMgZG9uJ3QgZXhpc3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIUNvbXBvbmVudE1vZGVsQ2xhc3MpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhciBzdWJUeXBlID0gcmVzdWx0SXRlbS5rZXlJbmZvLnN1YlR5cGU7XG4gICAgICAgICAgICAgIHZhciBzZXJpZXNJbXBvcnROYW1lID0gQlVJTFRJTl9DSEFSVFNfTUFQW3N1YlR5cGVdO1xuICAgICAgICAgICAgICBpZiAoIWNvbXBvbmV0c01pc3NpbmdMb2dQcmludGVkW3N1YlR5cGVdKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZXRzTWlzc2luZ0xvZ1ByaW50ZWRbc3ViVHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNJbXBvcnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcihcIlNlcmllcyBcIiArIHN1YlR5cGUgKyBcIiBpcyB1c2VkIGJ1dCBub3QgaW1wb3J0ZWQuXFxuaW1wb3J0IHsgXCIgKyBzZXJpZXNJbXBvcnROYW1lICsgXCIgfSBmcm9tICdlY2hhcnRzL2NoYXJ0cyc7XFxuZWNoYXJ0cy51c2UoW1wiICsgc2VyaWVzSW1wb3J0TmFtZSArIFwiXSk7XCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcihcIlVua25vd24gc2VyaWVzIFwiICsgc3ViVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8gQmVmb3JlIG11bHRpcGxlIHRvb2x0aXBzIGdldCBzdXBwb3J0ZWQsIHdlIGRvIHRoaXMgY2hlY2sgdG8gYXZvaWQgdW5leHBlY3RlZCBleGNlcHRpb24uXG4gICAgICAgICAgaWYgKG1haW5UeXBlID09PSAndG9vbHRpcCcpIHtcbiAgICAgICAgICAgIGlmICh0b29sdGlwRXhpc3RzKSB7XG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0b29sdGlwV2FybmluZ0xvZ2dlZCkge1xuICAgICAgICAgICAgICAgICAgd2FybignQ3VycmVudGx5IG9ubHkgb25lIHRvb2x0aXAgY29tcG9uZW50IGlzIGFsbG93ZWQuJyk7XG4gICAgICAgICAgICAgICAgICB0b29sdGlwV2FybmluZ0xvZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvb2x0aXBFeGlzdHMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tcG9uZW50TW9kZWwgJiYgY29tcG9uZW50TW9kZWwuY29uc3RydWN0b3IgPT09IENvbXBvbmVudE1vZGVsQ2xhc3MpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm5hbWUgPSByZXN1bHRJdGVtLmtleUluZm8ubmFtZTtcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudE1vZGVsLnNldHRpbmdUYXNrICYmIGNvbXBvbmVudE1vZGVsLnNldHRpbmdUYXNrLmRpcnR5KCk7XG4gICAgICAgICAgICBjb21wb25lbnRNb2RlbC5tZXJnZU9wdGlvbihuZXdDbXB0T3B0aW9uLCB0aGlzKTtcbiAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm9wdGlvblVwZGF0ZWQobmV3Q21wdE9wdGlvbiwgZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQRU5ESU5HIEdsb2JhbCBhcyBwYXJlbnQgP1xuICAgICAgICAgICAgdmFyIGV4dHJhT3B0ID0gZXh0ZW5kKHtcbiAgICAgICAgICAgICAgY29tcG9uZW50SW5kZXg6IGluZGV4XG4gICAgICAgICAgICB9LCByZXN1bHRJdGVtLmtleUluZm8pO1xuICAgICAgICAgICAgY29tcG9uZW50TW9kZWwgPSBuZXcgQ29tcG9uZW50TW9kZWxDbGFzcyhuZXdDbXB0T3B0aW9uLCB0aGlzLCB0aGlzLCBleHRyYU9wdCk7XG4gICAgICAgICAgICAvLyBBc3NpZ24gYGtleUluZm9gXG4gICAgICAgICAgICBleHRlbmQoY29tcG9uZW50TW9kZWwsIGV4dHJhT3B0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRJdGVtLmJyYW5kTmV3KSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLl9fcmVxdWlyZU5ld1ZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50TW9kZWwuaW5pdChuZXdDbXB0T3B0aW9uLCB0aGlzLCB0aGlzKTtcbiAgICAgICAgICAgIC8vIENhbGwgb3B0aW9uVXBkYXRlZCBhZnRlciBpbml0LlxuICAgICAgICAgICAgLy8gbmV3Q21wdE9wdGlvbiBoYXMgYmVlbiB1c2VkIGFzIGNvbXBvbmVudE1vZGVsLm9wdGlvblxuICAgICAgICAgICAgLy8gYW5kIG1heSBiZSBtZXJnZWQgd2l0aCB0aGVtZSBhbmQgZGVmYXVsdCwgc28gcGFzcyBudWxsXG4gICAgICAgICAgICAvLyB0byBhdm9pZCBjb25mdXNpb24uXG4gICAgICAgICAgICBjb21wb25lbnRNb2RlbC5vcHRpb25VcGRhdGVkKG51bGwsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50TW9kZWwpIHtcbiAgICAgICAgICBvcHRpb25zQnlNYWluVHlwZS5wdXNoKGNvbXBvbmVudE1vZGVsLm9wdGlvbik7XG4gICAgICAgICAgY21wdHNCeU1haW5UeXBlLnB1c2goY29tcG9uZW50TW9kZWwpO1xuICAgICAgICAgIGNtcHRzQ291bnRCeU1haW5UeXBlKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWx3YXlzIGRvIGFzc2lnbiB0byBhdm9pZCBlbGlkZWQgaXRlbSBpbiBhcnJheS5cbiAgICAgICAgICBvcHRpb25zQnlNYWluVHlwZS5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgY21wdHNCeU1haW5UeXBlLnB1c2godm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgICBvcHRpb25bbWFpblR5cGVdID0gb3B0aW9uc0J5TWFpblR5cGU7XG4gICAgICBjb21wb25lbnRzTWFwLnNldChtYWluVHlwZSwgY21wdHNCeU1haW5UeXBlKTtcbiAgICAgIGNvbXBvbmVudHNDb3VudC5zZXQobWFpblR5cGUsIGNtcHRzQ291bnRCeU1haW5UeXBlKTtcbiAgICAgIC8vIEJhY2t1cCBzZXJpZXMgZm9yIGZpbHRlcmluZy5cbiAgICAgIGlmIChtYWluVHlwZSA9PT0gJ3NlcmllcycpIHtcbiAgICAgICAgcmVDcmVhdGVTZXJpZXNJbmRpY2VzKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiBubyBzZXJpZXMgZGVjbGFyZWQsIGVuc3VyZSBgX3Nlcmllc0luZGljZXNgIGluaXRpYWxpemVkLlxuICAgIGlmICghdGhpcy5fc2VyaWVzSW5kaWNlcykge1xuICAgICAgcmVDcmVhdGVTZXJpZXNJbmRpY2VzKHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IG9wdGlvbiBmb3Igb3V0cHV0IChjbG9uZWQgb3B0aW9uIGFuZCBpbm5lciBpbmZvIHJlbW92ZWQpXHJcbiAgICovXG4gIEdsb2JhbE1vZGVsLnByb3RvdHlwZS5nZXRPcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbiA9IGNsb25lKHRoaXMub3B0aW9uKTtcbiAgICBlYWNoKG9wdGlvbiwgZnVuY3Rpb24gKG9wdEluTWFpblR5cGUsIG1haW5UeXBlKSB7XG4gICAgICBpZiAoQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3MobWFpblR5cGUpKSB7XG4gICAgICAgIHZhciBvcHRzID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkob3B0SW5NYWluVHlwZSk7XG4gICAgICAgIC8vIElubmVyIGNtcHRzIG5lZWQgdG8gYmUgcmVtb3ZlZC5cbiAgICAgICAgLy8gSW5uZXIgY21wdHMgbWlnaHQgbm90IGJlIGF0IGxhc3Qgc2luY2UgZWM1LjAsIGJ1dCBzdGlsbFxuICAgICAgICAvLyBjb21wYXRpYmxlIGZvciB1c2VyczogaWYgaW5uZXIgY21wdCBhdCBsYXN0LCBzcGxpY2UgdGhlIHJldHVybmVkIGFycmF5LlxuICAgICAgICB2YXIgcmVhbExlbiA9IG9wdHMubGVuZ3RoO1xuICAgICAgICB2YXIgbWV0Tm9uSW5uZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHJlYWxMZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIC8vIFJlbW92ZSBvcHRpb25zIHdpdGggaW5uZXIgaWQuXG4gICAgICAgICAgaWYgKG9wdHNbaV0gJiYgIW1vZGVsVXRpbC5pc0NvbXBvbmVudElkSW50ZXJuYWwob3B0c1tpXSkpIHtcbiAgICAgICAgICAgIG1ldE5vbklubmVyID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0c1tpXSA9IG51bGw7XG4gICAgICAgICAgICAhbWV0Tm9uSW5uZXIgJiYgcmVhbExlbi0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcHRzLmxlbmd0aCA9IHJlYWxMZW47XG4gICAgICAgIG9wdGlvblttYWluVHlwZV0gPSBvcHRzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlbGV0ZSBvcHRpb25bT1BUSU9OX0lOTkVSX0tFWV07XG4gICAgcmV0dXJuIG9wdGlvbjtcbiAgfTtcbiAgR2xvYmFsTW9kZWwucHJvdG90eXBlLmdldFRoZW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90aGVtZTtcbiAgfTtcbiAgR2xvYmFsTW9kZWwucHJvdG90eXBlLmdldExvY2FsZU1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gIH07XG4gIEdsb2JhbE1vZGVsLnByb3RvdHlwZS5zZXRVcGRhdGVQYXlsb2FkID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICB0aGlzLl9wYXlsb2FkID0gcGF5bG9hZDtcbiAgfTtcbiAgR2xvYmFsTW9kZWwucHJvdG90eXBlLmdldFVwZGF0ZVBheWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BheWxvYWQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwYXJhbSBpZHggSWYgbm90IHNwZWNpZmllZCwgcmV0dXJuIHRoZSBmaXJzdCBvbmUuXHJcbiAgICovXG4gIEdsb2JhbE1vZGVsLnByb3RvdHlwZS5nZXRDb21wb25lbnQgPSBmdW5jdGlvbiAobWFpblR5cGUsIGlkeCkge1xuICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQobWFpblR5cGUpO1xuICAgIGlmIChsaXN0KSB7XG4gICAgICB2YXIgY21wdCA9IGxpc3RbaWR4IHx8IDBdO1xuICAgICAgaWYgKGNtcHQpIHtcbiAgICAgICAgcmV0dXJuIGNtcHQ7XG4gICAgICB9IGVsc2UgaWYgKGlkeCA9PSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChsaXN0W2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEByZXR1cm4gTmV2ZXIgYmUgbnVsbC91bmRlZmluZWQuXHJcbiAgICovXG4gIEdsb2JhbE1vZGVsLnByb3RvdHlwZS5xdWVyeUNvbXBvbmVudHMgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgdmFyIG1haW5UeXBlID0gY29uZGl0aW9uLm1haW5UeXBlO1xuICAgIGlmICghbWFpblR5cGUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gY29uZGl0aW9uLmluZGV4O1xuICAgIHZhciBpZCA9IGNvbmRpdGlvbi5pZDtcbiAgICB2YXIgbmFtZSA9IGNvbmRpdGlvbi5uYW1lO1xuICAgIHZhciBjbXB0cyA9IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKTtcbiAgICBpZiAoIWNtcHRzIHx8ICFjbXB0cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gW107XG4gICAgICBlYWNoKG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KGluZGV4KSwgZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICBjbXB0c1tpZHhdICYmIHJlc3VsdC5wdXNoKGNtcHRzW2lkeF0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBxdWVyeUJ5SWRPck5hbWUoJ2lkJywgaWQsIGNtcHRzKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gcXVlcnlCeUlkT3JOYW1lKCduYW1lJywgbmFtZSwgY21wdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXR1cm4gYWxsIG5vbi1lbXB0eSBjb21wb25lbnRzIGluIHRoYXQgbWFpblR5cGVcbiAgICAgIHJlc3VsdCA9IGZpbHRlcihjbXB0cywgZnVuY3Rpb24gKGNtcHQpIHtcbiAgICAgICAgcmV0dXJuICEhY21wdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyQnlTdWJUeXBlKHJlc3VsdCwgY29uZGl0aW9uKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVGhlIGludGVyZmFjZSBpcyBkaWZmZXJlbnQgZnJvbSBxdWVyeUNvbXBvbmVudHMsXHJcbiAgICogd2hpY2ggaXMgY29udmVuaWVudCBmb3IgaW5uZXIgdXNhZ2UuXHJcbiAgICpcclxuICAgKiBAdXNhZ2VcclxuICAgKiBsZXQgcmVzdWx0ID0gZmluZENvbXBvbmVudHMoXHJcbiAgICogICAgIHttYWluVHlwZTogJ2RhdGFab29tJywgcXVlcnk6IHtkYXRhWm9vbUlkOiAnYWJjJ319XHJcbiAgICogKTtcclxuICAgKiBsZXQgcmVzdWx0ID0gZmluZENvbXBvbmVudHMoXHJcbiAgICogICAgIHttYWluVHlwZTogJ3NlcmllcycsIHN1YlR5cGU6ICdwaWUnLCBxdWVyeToge3Nlcmllc05hbWU6ICd1aW8nfX1cclxuICAgKiApO1xyXG4gICAqIGxldCByZXN1bHQgPSBmaW5kQ29tcG9uZW50cyhcclxuICAgKiAgICAge21haW5UeXBlOiAnc2VyaWVzJyxcclxuICAgKiAgICAgZmlsdGVyOiBmdW5jdGlvbiAobW9kZWwsIGluZGV4KSB7Li4ufX1cclxuICAgKiApO1xyXG4gICAqIC8vIHJlc3VsdCBsaWtlIFtjb21wb25lbnQwLCBjb21wb25uZXQxLCAuLi5dXHJcbiAgICovXG4gIEdsb2JhbE1vZGVsLnByb3RvdHlwZS5maW5kQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICB2YXIgcXVlcnkgPSBjb25kaXRpb24ucXVlcnk7XG4gICAgdmFyIG1haW5UeXBlID0gY29uZGl0aW9uLm1haW5UeXBlO1xuICAgIHZhciBxdWVyeUNvbmQgPSBnZXRRdWVyeUNvbmQocXVlcnkpO1xuICAgIHZhciByZXN1bHQgPSBxdWVyeUNvbmQgPyB0aGlzLnF1ZXJ5Q29tcG9uZW50cyhxdWVyeUNvbmQpXG4gICAgLy8gUmV0cmlldmUgYWxsIG5vbi1lbXB0eSBjb21wb25lbnRzLlxuICAgIDogZmlsdGVyKHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKSwgZnVuY3Rpb24gKGNtcHQpIHtcbiAgICAgIHJldHVybiAhIWNtcHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRvRmlsdGVyKGZpbHRlckJ5U3ViVHlwZShyZXN1bHQsIGNvbmRpdGlvbikpO1xuICAgIGZ1bmN0aW9uIGdldFF1ZXJ5Q29uZChxKSB7XG4gICAgICB2YXIgaW5kZXhBdHRyID0gbWFpblR5cGUgKyAnSW5kZXgnO1xuICAgICAgdmFyIGlkQXR0ciA9IG1haW5UeXBlICsgJ0lkJztcbiAgICAgIHZhciBuYW1lQXR0ciA9IG1haW5UeXBlICsgJ05hbWUnO1xuICAgICAgcmV0dXJuIHEgJiYgKHFbaW5kZXhBdHRyXSAhPSBudWxsIHx8IHFbaWRBdHRyXSAhPSBudWxsIHx8IHFbbmFtZUF0dHJdICE9IG51bGwpID8ge1xuICAgICAgICBtYWluVHlwZTogbWFpblR5cGUsXG4gICAgICAgIC8vIHN1YlR5cGUgd2lsbCBiZSBmaWx0ZXJlZCBmaW5hbGx5LlxuICAgICAgICBpbmRleDogcVtpbmRleEF0dHJdLFxuICAgICAgICBpZDogcVtpZEF0dHJdLFxuICAgICAgICBuYW1lOiBxW25hbWVBdHRyXVxuICAgICAgfSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvRmlsdGVyKHJlcykge1xuICAgICAgcmV0dXJuIGNvbmRpdGlvbi5maWx0ZXIgPyBmaWx0ZXIocmVzLCBjb25kaXRpb24uZmlsdGVyKSA6IHJlcztcbiAgICB9XG4gIH07XG4gIEdsb2JhbE1vZGVsLnByb3RvdHlwZS5lYWNoQ29tcG9uZW50ID0gZnVuY3Rpb24gKG1haW5UeXBlLCBjYiwgY29udGV4dCkge1xuICAgIHZhciBjb21wb25lbnRzTWFwID0gdGhpcy5fY29tcG9uZW50c01hcDtcbiAgICBpZiAoaXNGdW5jdGlvbihtYWluVHlwZSkpIHtcbiAgICAgIHZhciBjdHhGb3JBbGxfMSA9IGNiO1xuICAgICAgdmFyIGNiRm9yQWxsXzEgPSBtYWluVHlwZTtcbiAgICAgIGNvbXBvbmVudHNNYXAuZWFjaChmdW5jdGlvbiAoY21wdHMsIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGNtcHRzICYmIGkgPCBjbXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjbXB0ID0gY21wdHNbaV07XG4gICAgICAgICAgY21wdCAmJiBjYkZvckFsbF8xLmNhbGwoY3R4Rm9yQWxsXzEsIGNvbXBvbmVudFR5cGUsIGNtcHQsIGNtcHQuY29tcG9uZW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNtcHRzID0gaXNTdHJpbmcobWFpblR5cGUpID8gY29tcG9uZW50c01hcC5nZXQobWFpblR5cGUpIDogaXNPYmplY3QobWFpblR5cGUpID8gdGhpcy5maW5kQ29tcG9uZW50cyhtYWluVHlwZSkgOiBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGNtcHRzICYmIGkgPCBjbXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY21wdCA9IGNtcHRzW2ldO1xuICAgICAgICBjbXB0ICYmIGNiLmNhbGwoY29udGV4dCwgY21wdCwgY21wdC5jb21wb25lbnRJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBHZXQgc2VyaWVzIGxpc3QgYmVmb3JlIGZpbHRlcmVkIGJ5IG5hbWUuXHJcbiAgICovXG4gIEdsb2JhbE1vZGVsLnByb3RvdHlwZS5nZXRTZXJpZXNCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBuYW1lU3RyID0gbW9kZWxVdGlsLmNvbnZlcnRPcHRpb25JZE5hbWUobmFtZSwgbnVsbCk7XG4gICAgcmV0dXJuIGZpbHRlcih0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJyksIGZ1bmN0aW9uIChvbmVTZXJpZXMpIHtcbiAgICAgIHJldHVybiAhIW9uZVNlcmllcyAmJiBuYW1lU3RyICE9IG51bGwgJiYgb25lU2VyaWVzLm5hbWUgPT09IG5hbWVTdHI7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCBzZXJpZXMgbGlzdCBiZWZvcmUgZmlsdGVyZWQgYnkgaW5kZXguXHJcbiAgICovXG4gIEdsb2JhbE1vZGVsLnByb3RvdHlwZS5nZXRTZXJpZXNCeUluZGV4ID0gZnVuY3Rpb24gKHNlcmllc0luZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKVtzZXJpZXNJbmRleF07XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCBzZXJpZXMgbGlzdCBiZWZvcmUgZmlsdGVyZWQgYnkgdHlwZS5cclxuICAgKiBGSVhNRTogcmVuYW1lIHRvIGdldFJhd1Nlcmllc0J5VHlwZT9cclxuICAgKi9cbiAgR2xvYmFsTW9kZWwucHJvdG90eXBlLmdldFNlcmllc0J5VHlwZSA9IGZ1bmN0aW9uIChzdWJUeXBlKSB7XG4gICAgcmV0dXJuIGZpbHRlcih0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJyksIGZ1bmN0aW9uIChvbmVTZXJpZXMpIHtcbiAgICAgIHJldHVybiAhIW9uZVNlcmllcyAmJiBvbmVTZXJpZXMuc3ViVHlwZSA9PT0gc3ViVHlwZTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IGFsbCBzZXJpZXMgYmVmb3JlIGZpbHRlcmVkLlxyXG4gICAqL1xuICBHbG9iYWxNb2RlbC5wcm90b3R5cGUuZ2V0U2VyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmaWx0ZXIodGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpLCBmdW5jdGlvbiAob25lU2VyaWVzKSB7XG4gICAgICByZXR1cm4gISFvbmVTZXJpZXM7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENvdW50IHNlcmllcyBiZWZvcmUgZmlsdGVyZWQuXHJcbiAgICovXG4gIEdsb2JhbE1vZGVsLnByb3RvdHlwZS5nZXRTZXJpZXNDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c0NvdW50LmdldCgnc2VyaWVzJyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEFmdGVyIGZpbHRlcmluZywgc2VyaWVzIG1heSBiZSBkaWZmZXJlbnRcclxuICAgKiBmcm9tIHJhdyBzZXJpZXMuXHJcbiAgICovXG4gIEdsb2JhbE1vZGVsLnByb3RvdHlwZS5lYWNoU2VyaWVzID0gZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQodGhpcyk7XG4gICAgZWFjaCh0aGlzLl9zZXJpZXNJbmRpY2VzLCBmdW5jdGlvbiAocmF3U2VyaWVzSW5kZXgpIHtcbiAgICAgIHZhciBzZXJpZXMgPSB0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJylbcmF3U2VyaWVzSW5kZXhdO1xuICAgICAgY2IuY2FsbChjb250ZXh0LCBzZXJpZXMsIHJhd1Nlcmllc0luZGV4KTtcbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogSXRlcmF0ZSByYXcgc2VyaWVzIGJlZm9yZSBmaWx0ZXJlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXHJcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0XHJcbiAgICovXG4gIEdsb2JhbE1vZGVsLnByb3RvdHlwZS5lYWNoUmF3U2VyaWVzID0gZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgZWFjaCh0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJyksIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgIHNlcmllcyAmJiBjYi5jYWxsKGNvbnRleHQsIHNlcmllcywgc2VyaWVzLmNvbXBvbmVudEluZGV4KTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQWZ0ZXIgZmlsdGVyaW5nLCBzZXJpZXMgbWF5IGJlIGRpZmZlcmVudC5cclxuICAgKiBmcm9tIHJhdyBzZXJpZXMuXHJcbiAgICovXG4gIEdsb2JhbE1vZGVsLnByb3RvdHlwZS5lYWNoU2VyaWVzQnlUeXBlID0gZnVuY3Rpb24gKHN1YlR5cGUsIGNiLCBjb250ZXh0KSB7XG4gICAgYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQodGhpcyk7XG4gICAgZWFjaCh0aGlzLl9zZXJpZXNJbmRpY2VzLCBmdW5jdGlvbiAocmF3U2VyaWVzSW5kZXgpIHtcbiAgICAgIHZhciBzZXJpZXMgPSB0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJylbcmF3U2VyaWVzSW5kZXhdO1xuICAgICAgaWYgKHNlcmllcy5zdWJUeXBlID09PSBzdWJUeXBlKSB7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgc2VyaWVzLCByYXdTZXJpZXNJbmRleCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEl0ZXJhdGUgcmF3IHNlcmllcyBiZWZvcmUgZmlsdGVyZWQgb2YgZ2l2ZW4gdHlwZS5cclxuICAgKi9cbiAgR2xvYmFsTW9kZWwucHJvdG90eXBlLmVhY2hSYXdTZXJpZXNCeVR5cGUgPSBmdW5jdGlvbiAoc3ViVHlwZSwgY2IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZWFjaCh0aGlzLmdldFNlcmllc0J5VHlwZShzdWJUeXBlKSwgY2IsIGNvbnRleHQpO1xuICB9O1xuICBHbG9iYWxNb2RlbC5wcm90b3R5cGUuaXNTZXJpZXNGaWx0ZXJlZCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIGFzc2VydFNlcmllc0luaXRpYWxpemVkKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9zZXJpZXNJbmRpY2VzTWFwLmdldChzZXJpZXNNb2RlbC5jb21wb25lbnRJbmRleCkgPT0gbnVsbDtcbiAgfTtcbiAgR2xvYmFsTW9kZWwucHJvdG90eXBlLmdldEN1cnJlbnRTZXJpZXNJbmRpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fc2VyaWVzSW5kaWNlcyB8fCBbXSkuc2xpY2UoKTtcbiAgfTtcbiAgR2xvYmFsTW9kZWwucHJvdG90eXBlLmZpbHRlclNlcmllcyA9IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGFzc2VydFNlcmllc0luaXRpYWxpemVkKHRoaXMpO1xuICAgIHZhciBuZXdTZXJpZXNJbmRpY2VzID0gW107XG4gICAgZWFjaCh0aGlzLl9zZXJpZXNJbmRpY2VzLCBmdW5jdGlvbiAoc2VyaWVzUmF3SWR4KSB7XG4gICAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpW3Nlcmllc1Jhd0lkeF07XG4gICAgICBjYi5jYWxsKGNvbnRleHQsIHNlcmllcywgc2VyaWVzUmF3SWR4KSAmJiBuZXdTZXJpZXNJbmRpY2VzLnB1c2goc2VyaWVzUmF3SWR4KTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9zZXJpZXNJbmRpY2VzID0gbmV3U2VyaWVzSW5kaWNlcztcbiAgICB0aGlzLl9zZXJpZXNJbmRpY2VzTWFwID0gY3JlYXRlSGFzaE1hcChuZXdTZXJpZXNJbmRpY2VzKTtcbiAgfTtcbiAgR2xvYmFsTW9kZWwucHJvdG90eXBlLnJlc3RvcmVEYXRhID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICByZUNyZWF0ZVNlcmllc0luZGljZXModGhpcyk7XG4gICAgdmFyIGNvbXBvbmVudHNNYXAgPSB0aGlzLl9jb21wb25lbnRzTWFwO1xuICAgIHZhciBjb21wb25lbnRUeXBlcyA9IFtdO1xuICAgIGNvbXBvbmVudHNNYXAuZWFjaChmdW5jdGlvbiAoY29tcG9uZW50cywgY29tcG9uZW50VHlwZSkge1xuICAgICAgaWYgKENvbXBvbmVudE1vZGVsLmhhc0NsYXNzKGNvbXBvbmVudFR5cGUpKSB7XG4gICAgICAgIGNvbXBvbmVudFR5cGVzLnB1c2goY29tcG9uZW50VHlwZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgQ29tcG9uZW50TW9kZWwudG9wb2xvZ2ljYWxUcmF2ZWwoY29tcG9uZW50VHlwZXMsIENvbXBvbmVudE1vZGVsLmdldEFsbENsYXNzTWFpblR5cGVzKCksIGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgICBlYWNoKGNvbXBvbmVudHNNYXAuZ2V0KGNvbXBvbmVudFR5cGUpLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIGlmIChjb21wb25lbnQgJiYgKGNvbXBvbmVudFR5cGUgIT09ICdzZXJpZXMnIHx8ICFpc05vdFRhcmdldFNlcmllcyhjb21wb25lbnQsIHBheWxvYWQpKSkge1xuICAgICAgICAgIGNvbXBvbmVudC5yZXN0b3JlRGF0YSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgR2xvYmFsTW9kZWwuaW50ZXJuYWxGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZUNyZWF0ZVNlcmllc0luZGljZXMgPSBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgdmFyIHNlcmllc0luZGljZXMgPSBlY01vZGVsLl9zZXJpZXNJbmRpY2VzID0gW107XG4gICAgICBlYWNoKGVjTW9kZWwuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKSwgZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgICAvLyBzZXJpZXMgbWF5IGhhdmUgYmVlbiByZW1vdmVkIGJ5IGByZXBsYWNlTWVyZ2VgLlxuICAgICAgICBzZXJpZXMgJiYgc2VyaWVzSW5kaWNlcy5wdXNoKHNlcmllcy5jb21wb25lbnRJbmRleCk7XG4gICAgICB9KTtcbiAgICAgIGVjTW9kZWwuX3Nlcmllc0luZGljZXNNYXAgPSBjcmVhdGVIYXNoTWFwKHNlcmllc0luZGljZXMpO1xuICAgIH07XG4gICAgYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQgPSBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgLy8gQ29tcG9uZW50cyB0aGF0IHVzZSBfc2VyaWVzSW5kaWNlcyBzaG91bGQgZGVwZW5kcyBvbiBzZXJpZXMgY29tcG9uZW50LFxuICAgICAgLy8gd2hpY2ggbWFrZSBzdXJlIHRoYXQgdGhlaXIgaW5pdGlhbGl6YXRpb24gaXMgYWZ0ZXIgc2VyaWVzLlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKCFlY01vZGVsLl9zZXJpZXNJbmRpY2VzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gc2hvdWxkIGNvbnRhaW5zIHNlcmllcy4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaW5pdEJhc2UgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYmFzZU9wdGlvbikge1xuICAgICAgLy8gVXNpbmcgT1BUSU9OX0lOTkVSX0tFWSB0byBtYXJrIHRoYXQgdGhpcyBvcHRpb24gY2Fubm90IGJlIHVzZWQgb3V0c2lkZSxcbiAgICAgIC8vIGkuZS4gYGNoYXJ0LnNldE9wdGlvbihjaGFydC5nZXRNb2RlbCgpLm9wdGlvbik7YCBpcyBmb3JiaWRkZW4uXG4gICAgICBlY01vZGVsLm9wdGlvbiA9IHt9O1xuICAgICAgZWNNb2RlbC5vcHRpb25bT1BUSU9OX0lOTkVSX0tFWV0gPSBPUFRJT05fSU5ORVJfVkFMVUU7XG4gICAgICAvLyBJbml0IHdpdGggc2VyaWVzOiBbXSwgaW4gY2FzZSBvZiBjYWxsaW5nIGZpbmRTZXJpZXMgbWV0aG9kXG4gICAgICAvLyBiZWZvcmUgc2VyaWVzIGluaXRpYWxpemVkLlxuICAgICAgZWNNb2RlbC5fY29tcG9uZW50c01hcCA9IGNyZWF0ZUhhc2hNYXAoe1xuICAgICAgICBzZXJpZXM6IFtdXG4gICAgICB9KTtcbiAgICAgIGVjTW9kZWwuX2NvbXBvbmVudHNDb3VudCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgICAgIC8vIElmIHVzZXIgc3BlZmllZCBgb3B0aW9uLmFyaWFgLCBhcmlhIHdpbGwgYmUgZW5hYmxlLiBUaGlzIGRldGVjdGlvbiBzaG91bGQgYmVcbiAgICAgIC8vIHBlcmZvcm1lZCBiZWZvcmUgdGhlbWUgYW5kIGdsb2JhbERlZmF1bHQgbWVyZ2UuXG4gICAgICB2YXIgYWlyYU9wdGlvbiA9IGJhc2VPcHRpb24uYXJpYTtcbiAgICAgIGlmIChpc09iamVjdChhaXJhT3B0aW9uKSAmJiBhaXJhT3B0aW9uLmVuYWJsZWQgPT0gbnVsbCkge1xuICAgICAgICBhaXJhT3B0aW9uLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbWVyZ2VUaGVtZShiYXNlT3B0aW9uLCBlY01vZGVsLl90aGVtZS5vcHRpb24pO1xuICAgICAgLy8gVE9ETyBOZWVkcyBjbG9uZSB3aGVuIG1lcmdpbmcgdG8gdGhlIHVuZXhpc3RlZCBwcm9wZXJ0eVxuICAgICAgbWVyZ2UoYmFzZU9wdGlvbiwgZ2xvYmFsRGVmYXVsdCwgZmFsc2UpO1xuICAgICAgZWNNb2RlbC5fbWVyZ2VPcHRpb24oYmFzZU9wdGlvbiwgbnVsbCk7XG4gICAgfTtcbiAgfSgpO1xuICByZXR1cm4gR2xvYmFsTW9kZWw7XG59KE1vZGVsKTtcbmZ1bmN0aW9uIGlzTm90VGFyZ2V0U2VyaWVzKHNlcmllc01vZGVsLCBwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkKSB7XG4gICAgdmFyIGluZGV4ID0gcGF5bG9hZC5zZXJpZXNJbmRleDtcbiAgICB2YXIgaWQgPSBwYXlsb2FkLnNlcmllc0lkO1xuICAgIHZhciBuYW1lXzEgPSBwYXlsb2FkLnNlcmllc05hbWU7XG4gICAgcmV0dXJuIGluZGV4ICE9IG51bGwgJiYgc2VyaWVzTW9kZWwuY29tcG9uZW50SW5kZXggIT09IGluZGV4IHx8IGlkICE9IG51bGwgJiYgc2VyaWVzTW9kZWwuaWQgIT09IGlkIHx8IG5hbWVfMSAhPSBudWxsICYmIHNlcmllc01vZGVsLm5hbWUgIT09IG5hbWVfMTtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VUaGVtZShvcHRpb24sIHRoZW1lKSB7XG4gIC8vIFBFTkRJTkdcbiAgLy8gTk9UIHVzZSBgY29sb3JMYXllcmAgaW4gdGhlbWUgaWYgb3B0aW9uIGhhcyBgY29sb3JgXG4gIHZhciBub3RNZXJnZUNvbG9yTGF5ZXIgPSBvcHRpb24uY29sb3IgJiYgIW9wdGlvbi5jb2xvckxheWVyO1xuICBlYWNoKHRoZW1lLCBmdW5jdGlvbiAodGhlbWVJdGVtLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09ICdjb2xvckxheWVyJyAmJiBub3RNZXJnZUNvbG9yTGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgaXQgaXMgY29tcG9uZW50IG1vZGVsIG1haW5UeXBlLCB0aGUgbW9kZWwgaGFuZGxlcyB0aGF0IG1lcmdlIGxhdGVyLlxuICAgIC8vIG90aGVyd2lzZSwgbWVyZ2UgdGhlbSBoZXJlLlxuICAgIGlmICghQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3MobmFtZSkpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhlbWVJdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25bbmFtZV0gPSAhb3B0aW9uW25hbWVdID8gY2xvbmUodGhlbWVJdGVtKSA6IG1lcmdlKG9wdGlvbltuYW1lXSwgdGhlbWVJdGVtLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9uW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25bbmFtZV0gPSB0aGVtZUl0ZW07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcXVlcnlCeUlkT3JOYW1lKGF0dHIsIGlkT3JOYW1lLCBjbXB0cykge1xuICAvLyBIZXJlIGlzIGEgYnJlYWsgZnJvbSBlY2hhcnRzNDogc3RyaW5nIGFuZCBudW1iZXIgYXJlXG4gIC8vIHRyZWF0ZWQgYXMgZXF1YWwuXG4gIGlmIChpc0FycmF5KGlkT3JOYW1lKSkge1xuICAgIHZhciBrZXlNYXBfMSA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgICBlYWNoKGlkT3JOYW1lLCBmdW5jdGlvbiAoaWRPck5hbWVJdGVtKSB7XG4gICAgICBpZiAoaWRPck5hbWVJdGVtICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGlkTmFtZSA9IG1vZGVsVXRpbC5jb252ZXJ0T3B0aW9uSWROYW1lKGlkT3JOYW1lSXRlbSwgbnVsbCk7XG4gICAgICAgIGlkTmFtZSAhPSBudWxsICYmIGtleU1hcF8xLnNldChpZE9yTmFtZUl0ZW0sIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaWx0ZXIoY21wdHMsIGZ1bmN0aW9uIChjbXB0KSB7XG4gICAgICByZXR1cm4gY21wdCAmJiBrZXlNYXBfMS5nZXQoY21wdFthdHRyXSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkTmFtZV8xID0gbW9kZWxVdGlsLmNvbnZlcnRPcHRpb25JZE5hbWUoaWRPck5hbWUsIG51bGwpO1xuICAgIHJldHVybiBmaWx0ZXIoY21wdHMsIGZ1bmN0aW9uIChjbXB0KSB7XG4gICAgICByZXR1cm4gY21wdCAmJiBpZE5hbWVfMSAhPSBudWxsICYmIGNtcHRbYXR0cl0gPT09IGlkTmFtZV8xO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBmaWx0ZXJCeVN1YlR5cGUoY29tcG9uZW50cywgY29uZGl0aW9uKSB7XG4gIC8vIFVzaW5nIGhhc093blByb3BlcnR5IGZvciByZXN0cmljdC4gQ29uc2lkZXJcbiAgLy8gc3ViVHlwZSBpcyB1bmRlZmluZWQgaW4gdXNlciBwYXlsb2FkLlxuICByZXR1cm4gY29uZGl0aW9uLmhhc093blByb3BlcnR5KCdzdWJUeXBlJykgPyBmaWx0ZXIoY29tcG9uZW50cywgZnVuY3Rpb24gKGNtcHQpIHtcbiAgICByZXR1cm4gY21wdCAmJiBjbXB0LnN1YlR5cGUgPT09IGNvbmRpdGlvbi5zdWJUeXBlO1xuICB9KSA6IGNvbXBvbmVudHM7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTZXRPcHRpb25JbnB1dChvcHRzKSB7XG4gIHZhciByZXBsYWNlTWVyZ2VNYWluVHlwZU1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgb3B0cyAmJiBlYWNoKG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG9wdHMucmVwbGFjZU1lcmdlKSwgZnVuY3Rpb24gKG1haW5UeXBlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhtYWluVHlwZSksICdcIicgKyBtYWluVHlwZSArICdcIiBpcyBub3QgdmFsaWQgY29tcG9uZW50IG1haW4gdHlwZSBpbiBcInJlcGxhY2VNZXJnZVwiJyk7XG4gICAgfVxuICAgIHJlcGxhY2VNZXJnZU1haW5UeXBlTWFwLnNldChtYWluVHlwZSwgdHJ1ZSk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHJlcGxhY2VNZXJnZU1haW5UeXBlTWFwOiByZXBsYWNlTWVyZ2VNYWluVHlwZU1hcFxuICB9O1xufVxubWl4aW4oR2xvYmFsTW9kZWwsIFBhbGV0dGVNaXhpbik7XG5leHBvcnQgZGVmYXVsdCBHbG9iYWxNb2RlbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///73100\n")},74065:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ globalBackwardCompat)\n});\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n;// ./node_modules/echarts/lib/preprocessor/helper/compatStyle.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar each = util.each;\nvar isObject = util.isObject;\nvar POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];\nfunction compatEC2ItemStyle(opt) {\n  var itemStyleOpt = opt && opt.itemStyle;\n  if (!itemStyleOpt) {\n    return;\n  }\n  for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {\n    var styleName = POSSIBLE_STYLES[i];\n    var normalItemStyleOpt = itemStyleOpt.normal;\n    var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n      if (false) {}\n      opt[styleName] = opt[styleName] || {};\n      if (!opt[styleName].normal) {\n        opt[styleName].normal = normalItemStyleOpt[styleName];\n      } else {\n        util.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n      }\n      normalItemStyleOpt[styleName] = null;\n    }\n    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n      if (false) {}\n      opt[styleName] = opt[styleName] || {};\n      if (!opt[styleName].emphasis) {\n        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n      } else {\n        util.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n      }\n      emphasisItemStyleOpt[styleName] = null;\n    }\n  }\n}\nfunction convertNormalEmphasis(opt, optType, useExtend) {\n  if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {\n    var normalOpt = opt[optType].normal;\n    var emphasisOpt = opt[optType].emphasis;\n    if (normalOpt) {\n      if (false) {}\n      // Timeline controlStyle has other properties besides normal and emphasis\n      if (useExtend) {\n        opt[optType].normal = opt[optType].emphasis = null;\n        util.defaults(opt[optType], normalOpt);\n      } else {\n        opt[optType] = normalOpt;\n      }\n    }\n    if (emphasisOpt) {\n      if (false) {}\n      opt.emphasis = opt.emphasis || {};\n      opt.emphasis[optType] = emphasisOpt;\n      // Also compat the case user mix the style and focus together in ec3 style\n      // for example: { itemStyle: { normal: {}, emphasis: {focus, shadowBlur} } }\n      if (emphasisOpt.focus) {\n        opt.emphasis.focus = emphasisOpt.focus;\n      }\n      if (emphasisOpt.blurScope) {\n        opt.emphasis.blurScope = emphasisOpt.blurScope;\n      }\n    }\n  }\n}\nfunction removeEC3NormalStatus(opt) {\n  convertNormalEmphasis(opt, 'itemStyle');\n  convertNormalEmphasis(opt, 'lineStyle');\n  convertNormalEmphasis(opt, 'areaStyle');\n  convertNormalEmphasis(opt, 'label');\n  convertNormalEmphasis(opt, 'labelLine');\n  // treemap\n  convertNormalEmphasis(opt, 'upperLabel');\n  // graph\n  convertNormalEmphasis(opt, 'edgeLabel');\n}\nfunction compatTextStyle(opt, propName) {\n  // Check whether is not object (string\\null\\undefined ...)\n  var labelOptSingle = isObject(opt) && opt[propName];\n  var textStyle = isObject(labelOptSingle) && labelOptSingle.textStyle;\n  if (textStyle) {\n    if (false) {}\n    for (var i = 0, len = model/* TEXT_STYLE_OPTIONS */.JS.length; i < len; i++) {\n      var textPropName = model/* TEXT_STYLE_OPTIONS */.JS[i];\n      if (textStyle.hasOwnProperty(textPropName)) {\n        labelOptSingle[textPropName] = textStyle[textPropName];\n      }\n    }\n  }\n}\nfunction compatEC3CommonStyles(opt) {\n  if (opt) {\n    removeEC3NormalStatus(opt);\n    compatTextStyle(opt, 'label');\n    opt.emphasis && compatTextStyle(opt.emphasis, 'label');\n  }\n}\nfunction processSeries(seriesOpt) {\n  if (!isObject(seriesOpt)) {\n    return;\n  }\n  compatEC2ItemStyle(seriesOpt);\n  removeEC3NormalStatus(seriesOpt);\n  compatTextStyle(seriesOpt, 'label');\n  // treemap\n  compatTextStyle(seriesOpt, 'upperLabel');\n  // graph\n  compatTextStyle(seriesOpt, 'edgeLabel');\n  if (seriesOpt.emphasis) {\n    compatTextStyle(seriesOpt.emphasis, 'label');\n    // treemap\n    compatTextStyle(seriesOpt.emphasis, 'upperLabel');\n    // graph\n    compatTextStyle(seriesOpt.emphasis, 'edgeLabel');\n  }\n  var markPoint = seriesOpt.markPoint;\n  if (markPoint) {\n    compatEC2ItemStyle(markPoint);\n    compatEC3CommonStyles(markPoint);\n  }\n  var markLine = seriesOpt.markLine;\n  if (markLine) {\n    compatEC2ItemStyle(markLine);\n    compatEC3CommonStyles(markLine);\n  }\n  var markArea = seriesOpt.markArea;\n  if (markArea) {\n    compatEC3CommonStyles(markArea);\n  }\n  var data = seriesOpt.data;\n  // Break with ec3: if `setOption` again, there may be no `type` in option,\n  // then the backward compat based on option type will not be performed.\n  if (seriesOpt.type === 'graph') {\n    data = data || seriesOpt.nodes;\n    var edgeData = seriesOpt.links || seriesOpt.edges;\n    if (edgeData && !util.isTypedArray(edgeData)) {\n      for (var i = 0; i < edgeData.length; i++) {\n        compatEC3CommonStyles(edgeData[i]);\n      }\n    }\n    util.each(seriesOpt.categories, function (opt) {\n      removeEC3NormalStatus(opt);\n    });\n  }\n  if (data && !util.isTypedArray(data)) {\n    for (var i = 0; i < data.length; i++) {\n      compatEC3CommonStyles(data[i]);\n    }\n  }\n  // mark point data\n  markPoint = seriesOpt.markPoint;\n  if (markPoint && markPoint.data) {\n    var mpData = markPoint.data;\n    for (var i = 0; i < mpData.length; i++) {\n      compatEC3CommonStyles(mpData[i]);\n    }\n  }\n  // mark line data\n  markLine = seriesOpt.markLine;\n  if (markLine && markLine.data) {\n    var mlData = markLine.data;\n    for (var i = 0; i < mlData.length; i++) {\n      if (util.isArray(mlData[i])) {\n        compatEC3CommonStyles(mlData[i][0]);\n        compatEC3CommonStyles(mlData[i][1]);\n      } else {\n        compatEC3CommonStyles(mlData[i]);\n      }\n    }\n  }\n  // Series\n  if (seriesOpt.type === 'gauge') {\n    compatTextStyle(seriesOpt, 'axisLabel');\n    compatTextStyle(seriesOpt, 'title');\n    compatTextStyle(seriesOpt, 'detail');\n  } else if (seriesOpt.type === 'treemap') {\n    convertNormalEmphasis(seriesOpt.breadcrumb, 'itemStyle');\n    util.each(seriesOpt.levels, function (opt) {\n      removeEC3NormalStatus(opt);\n    });\n  } else if (seriesOpt.type === 'tree') {\n    removeEC3NormalStatus(seriesOpt.leaves);\n  }\n  // sunburst starts from ec4, so it does not need to compat levels.\n}\nfunction toArr(o) {\n  return util.isArray(o) ? o : o ? [o] : [];\n}\nfunction toObj(o) {\n  return (util.isArray(o) ? o[0] : o) || {};\n}\nfunction globalCompatStyle(option, isTheme) {\n  each(toArr(option.series), function (seriesOpt) {\n    isObject(seriesOpt) && processSeries(seriesOpt);\n  });\n  var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];\n  isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');\n  each(axes, function (axisName) {\n    each(toArr(option[axisName]), function (axisOpt) {\n      if (axisOpt) {\n        compatTextStyle(axisOpt, 'axisLabel');\n        compatTextStyle(axisOpt.axisPointer, 'label');\n      }\n    });\n  });\n  each(toArr(option.parallel), function (parallelOpt) {\n    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;\n    compatTextStyle(parallelAxisDefault, 'axisLabel');\n    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');\n  });\n  each(toArr(option.calendar), function (calendarOpt) {\n    convertNormalEmphasis(calendarOpt, 'itemStyle');\n    compatTextStyle(calendarOpt, 'dayLabel');\n    compatTextStyle(calendarOpt, 'monthLabel');\n    compatTextStyle(calendarOpt, 'yearLabel');\n  });\n  // radar.name.textStyle\n  each(toArr(option.radar), function (radarOpt) {\n    compatTextStyle(radarOpt, 'name');\n    // Use axisName instead of name because component has name property\n    if (radarOpt.name && radarOpt.axisName == null) {\n      radarOpt.axisName = radarOpt.name;\n      delete radarOpt.name;\n      if (false) {}\n    }\n    if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {\n      radarOpt.axisNameGap = radarOpt.nameGap;\n      delete radarOpt.nameGap;\n      if (false) {}\n    }\n    if (false) {}\n  });\n  each(toArr(option.geo), function (geoOpt) {\n    if (isObject(geoOpt)) {\n      compatEC3CommonStyles(geoOpt);\n      each(toArr(geoOpt.regions), function (regionObj) {\n        compatEC3CommonStyles(regionObj);\n      });\n    }\n  });\n  each(toArr(option.timeline), function (timelineOpt) {\n    compatEC3CommonStyles(timelineOpt);\n    convertNormalEmphasis(timelineOpt, 'label');\n    convertNormalEmphasis(timelineOpt, 'itemStyle');\n    convertNormalEmphasis(timelineOpt, 'controlStyle', true);\n    var data = timelineOpt.data;\n    util.isArray(data) && util.each(data, function (item) {\n      if (util.isObject(item)) {\n        convertNormalEmphasis(item, 'label');\n        convertNormalEmphasis(item, 'itemStyle');\n      }\n    });\n  });\n  each(toArr(option.toolbox), function (toolboxOpt) {\n    convertNormalEmphasis(toolboxOpt, 'iconStyle');\n    each(toolboxOpt.feature, function (featureOpt) {\n      convertNormalEmphasis(featureOpt, 'iconStyle');\n    });\n  });\n  compatTextStyle(toObj(option.axisPointer), 'label');\n  compatTextStyle(toObj(option.tooltip).axisPointer, 'label');\n  // Clean logs\n  // storedLogs = {};\n}\n;// ./node_modules/echarts/lib/preprocessor/backwardCompat.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nfunction get(opt, path) {\n  var pathArr = path.split(',');\n  var obj = opt;\n  for (var i = 0; i < pathArr.length; i++) {\n    obj = obj && obj[pathArr[i]];\n    if (obj == null) {\n      break;\n    }\n  }\n  return obj;\n}\nfunction set(opt, path, val, overwrite) {\n  var pathArr = path.split(',');\n  var obj = opt;\n  var key;\n  var i = 0;\n  for (; i < pathArr.length - 1; i++) {\n    key = pathArr[i];\n    if (obj[key] == null) {\n      obj[key] = {};\n    }\n    obj = obj[key];\n  }\n  if (overwrite || obj[pathArr[i]] == null) {\n    obj[pathArr[i]] = val;\n  }\n}\nfunction compatLayoutProperties(option) {\n  option && (0,util.each)(LAYOUT_PROPERTIES, function (prop) {\n    if (prop[0] in option && !(prop[1] in option)) {\n      option[prop[1]] = option[prop[0]];\n    }\n  });\n}\nvar LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']];\nvar COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'];\nvar BAR_ITEM_STYLE_MAP = [['borderRadius', 'barBorderRadius'], ['borderColor', 'barBorderColor'], ['borderWidth', 'barBorderWidth']];\nfunction compatBarItemStyle(option) {\n  var itemStyle = option && option.itemStyle;\n  if (itemStyle) {\n    for (var i = 0; i < BAR_ITEM_STYLE_MAP.length; i++) {\n      var oldName = BAR_ITEM_STYLE_MAP[i][1];\n      var newName = BAR_ITEM_STYLE_MAP[i][0];\n      if (itemStyle[oldName] != null) {\n        itemStyle[newName] = itemStyle[oldName];\n        if (false) {}\n      }\n    }\n  }\n}\nfunction compatPieLabel(option) {\n  if (!option) {\n    return;\n  }\n  if (option.alignTo === 'edge' && option.margin != null && option.edgeDistance == null) {\n    if (false) {}\n    option.edgeDistance = option.margin;\n  }\n}\nfunction compatSunburstState(option) {\n  if (!option) {\n    return;\n  }\n  if (option.downplay && !option.blur) {\n    option.blur = option.downplay;\n    if (false) {}\n  }\n}\nfunction compatGraphFocus(option) {\n  if (!option) {\n    return;\n  }\n  if (option.focusNodeAdjacency != null) {\n    option.emphasis = option.emphasis || {};\n    if (option.emphasis.focus == null) {\n      if (false) {}\n      option.emphasis.focus = 'adjacency';\n    }\n  }\n}\nfunction traverseTree(data, cb) {\n  if (data) {\n    for (var i = 0; i < data.length; i++) {\n      cb(data[i]);\n      data[i] && traverseTree(data[i].children, cb);\n    }\n  }\n}\nfunction globalBackwardCompat(option, isTheme) {\n  globalCompatStyle(option, isTheme);\n  // Make sure series array for model initialization.\n  option.series = (0,model/* normalizeToArray */.qB)(option.series);\n  (0,util.each)(option.series, function (seriesOpt) {\n    if (!(0,util.isObject)(seriesOpt)) {\n      return;\n    }\n    var seriesType = seriesOpt.type;\n    if (seriesType === 'line') {\n      if (seriesOpt.clipOverflow != null) {\n        seriesOpt.clip = seriesOpt.clipOverflow;\n        if (false) {}\n      }\n    } else if (seriesType === 'pie' || seriesType === 'gauge') {\n      if (seriesOpt.clockWise != null) {\n        seriesOpt.clockwise = seriesOpt.clockWise;\n        if (false) {}\n      }\n      compatPieLabel(seriesOpt.label);\n      var data = seriesOpt.data;\n      if (data && !(0,util.isTypedArray)(data)) {\n        for (var i = 0; i < data.length; i++) {\n          compatPieLabel(data[i]);\n        }\n      }\n      if (seriesOpt.hoverOffset != null) {\n        seriesOpt.emphasis = seriesOpt.emphasis || {};\n        if (seriesOpt.emphasis.scaleSize = null) {\n          if (false) {}\n          seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;\n        }\n      }\n    } else if (seriesType === 'gauge') {\n      var pointerColor = get(seriesOpt, 'pointer.color');\n      pointerColor != null && set(seriesOpt, 'itemStyle.color', pointerColor);\n    } else if (seriesType === 'bar') {\n      compatBarItemStyle(seriesOpt);\n      compatBarItemStyle(seriesOpt.backgroundStyle);\n      compatBarItemStyle(seriesOpt.emphasis);\n      var data = seriesOpt.data;\n      if (data && !(0,util.isTypedArray)(data)) {\n        for (var i = 0; i < data.length; i++) {\n          if (typeof data[i] === 'object') {\n            compatBarItemStyle(data[i]);\n            compatBarItemStyle(data[i] && data[i].emphasis);\n          }\n        }\n      }\n    } else if (seriesType === 'sunburst') {\n      var highlightPolicy = seriesOpt.highlightPolicy;\n      if (highlightPolicy) {\n        seriesOpt.emphasis = seriesOpt.emphasis || {};\n        if (!seriesOpt.emphasis.focus) {\n          seriesOpt.emphasis.focus = highlightPolicy;\n          if (false) {}\n        }\n      }\n      compatSunburstState(seriesOpt);\n      traverseTree(seriesOpt.data, compatSunburstState);\n    } else if (seriesType === 'graph' || seriesType === 'sankey') {\n      compatGraphFocus(seriesOpt);\n      // TODO nodes, edges?\n    } else if (seriesType === 'map') {\n      if (seriesOpt.mapType && !seriesOpt.map) {\n        if (false) {}\n        seriesOpt.map = seriesOpt.mapType;\n      }\n      if (seriesOpt.mapLocation) {\n        if (false) {}\n        (0,util.defaults)(seriesOpt, seriesOpt.mapLocation);\n      }\n    }\n    if (seriesOpt.hoverAnimation != null) {\n      seriesOpt.emphasis = seriesOpt.emphasis || {};\n      if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {\n        if (false) {}\n        seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;\n      }\n    }\n    compatLayoutProperties(seriesOpt);\n  });\n  // dataRange has changed to visualMap\n  if (option.dataRange) {\n    option.visualMap = option.dataRange;\n  }\n  (0,util.each)(COMPATITABLE_COMPONENTS, function (componentName) {\n    var options = option[componentName];\n    if (options) {\n      if (!(0,util.isArray)(options)) {\n        options = [options];\n      }\n      (0,util.each)(options, function (option) {\n        compatLayoutProperties(option);\n      });\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQwNjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3ByZXByb2Nlc3Nvci9oZWxwZXIvY29tcGF0U3R5bGUuanM/ZGExNiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvcHJlcHJvY2Vzc29yL2JhY2t3YXJkQ29tcGF0LmpzP2I2OGEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIG1vZGVsVXRpbCBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCB7IGRlcHJlY2F0ZUxvZywgZGVwcmVjYXRlUmVwbGFjZUxvZyB9IGZyb20gJy4uLy4uL3V0aWwvbG9nLmpzJztcbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgaXNPYmplY3QgPSB6clV0aWwuaXNPYmplY3Q7XG52YXIgUE9TU0lCTEVfU1RZTEVTID0gWydhcmVhU3R5bGUnLCAnbGluZVN0eWxlJywgJ25vZGVTdHlsZScsICdsaW5rU3R5bGUnLCAnY2hvcmRTdHlsZScsICdsYWJlbCcsICdsYWJlbExpbmUnXTtcbmZ1bmN0aW9uIGNvbXBhdEVDMkl0ZW1TdHlsZShvcHQpIHtcbiAgdmFyIGl0ZW1TdHlsZU9wdCA9IG9wdCAmJiBvcHQuaXRlbVN0eWxlO1xuICBpZiAoIWl0ZW1TdHlsZU9wdCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gUE9TU0lCTEVfU1RZTEVTLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHN0eWxlTmFtZSA9IFBPU1NJQkxFX1NUWUxFU1tpXTtcbiAgICB2YXIgbm9ybWFsSXRlbVN0eWxlT3B0ID0gaXRlbVN0eWxlT3B0Lm5vcm1hbDtcbiAgICB2YXIgZW1waGFzaXNJdGVtU3R5bGVPcHQgPSBpdGVtU3R5bGVPcHQuZW1waGFzaXM7XG4gICAgaWYgKG5vcm1hbEl0ZW1TdHlsZU9wdCAmJiBub3JtYWxJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVwcmVjYXRlUmVwbGFjZUxvZyhcIml0ZW1TdHlsZS5ub3JtYWwuXCIgKyBzdHlsZU5hbWUsIHN0eWxlTmFtZSk7XG4gICAgICB9XG4gICAgICBvcHRbc3R5bGVOYW1lXSA9IG9wdFtzdHlsZU5hbWVdIHx8IHt9O1xuICAgICAgaWYgKCFvcHRbc3R5bGVOYW1lXS5ub3JtYWwpIHtcbiAgICAgICAgb3B0W3N0eWxlTmFtZV0ubm9ybWFsID0gbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB6clV0aWwubWVyZ2Uob3B0W3N0eWxlTmFtZV0ubm9ybWFsLCBub3JtYWxJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSk7XG4gICAgICB9XG4gICAgICBub3JtYWxJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChlbXBoYXNpc0l0ZW1TdHlsZU9wdCAmJiBlbXBoYXNpc0l0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZXByZWNhdGVSZXBsYWNlTG9nKFwiaXRlbVN0eWxlLmVtcGhhc2lzLlwiICsgc3R5bGVOYW1lLCBcImVtcGhhc2lzLlwiICsgc3R5bGVOYW1lKTtcbiAgICAgIH1cbiAgICAgIG9wdFtzdHlsZU5hbWVdID0gb3B0W3N0eWxlTmFtZV0gfHwge307XG4gICAgICBpZiAoIW9wdFtzdHlsZU5hbWVdLmVtcGhhc2lzKSB7XG4gICAgICAgIG9wdFtzdHlsZU5hbWVdLmVtcGhhc2lzID0gZW1waGFzaXNJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHpyVXRpbC5tZXJnZShvcHRbc3R5bGVOYW1lXS5lbXBoYXNpcywgZW1waGFzaXNJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSk7XG4gICAgICB9XG4gICAgICBlbXBoYXNpc0l0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnROb3JtYWxFbXBoYXNpcyhvcHQsIG9wdFR5cGUsIHVzZUV4dGVuZCkge1xuICBpZiAob3B0ICYmIG9wdFtvcHRUeXBlXSAmJiAob3B0W29wdFR5cGVdLm5vcm1hbCB8fCBvcHRbb3B0VHlwZV0uZW1waGFzaXMpKSB7XG4gICAgdmFyIG5vcm1hbE9wdCA9IG9wdFtvcHRUeXBlXS5ub3JtYWw7XG4gICAgdmFyIGVtcGhhc2lzT3B0ID0gb3B0W29wdFR5cGVdLmVtcGhhc2lzO1xuICAgIGlmIChub3JtYWxPcHQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICAgIGRlcHJlY2F0ZUxvZyhcIidub3JtYWwnIGhpZXJhcmNoeSBpbiBcIiArIG9wdFR5cGUgKyBcIiBoYXMgYmVlbiByZW1vdmVkIHNpbmNlIDQuMC4gQWxsIHN0eWxlIHByb3BlcnRpZXMgYXJlIGNvbmZpZ3VyZWQgaW4gXCIgKyBvcHRUeXBlICsgXCIgZGlyZWN0bHkgbm93LlwiKTtcbiAgICAgIH1cbiAgICAgIC8vIFRpbWVsaW5lIGNvbnRyb2xTdHlsZSBoYXMgb3RoZXIgcHJvcGVydGllcyBiZXNpZGVzIG5vcm1hbCBhbmQgZW1waGFzaXNcbiAgICAgIGlmICh1c2VFeHRlbmQpIHtcbiAgICAgICAgb3B0W29wdFR5cGVdLm5vcm1hbCA9IG9wdFtvcHRUeXBlXS5lbXBoYXNpcyA9IG51bGw7XG4gICAgICAgIHpyVXRpbC5kZWZhdWx0cyhvcHRbb3B0VHlwZV0sIG5vcm1hbE9wdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRbb3B0VHlwZV0gPSBub3JtYWxPcHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbXBoYXNpc09wdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVwcmVjYXRlTG9nKG9wdFR5cGUgKyBcIi5lbXBoYXNpcyBoYXMgYmVlbiBjaGFuZ2VkIHRvIGVtcGhhc2lzLlwiICsgb3B0VHlwZSArIFwiIHNpbmNlIDQuMFwiKTtcbiAgICAgIH1cbiAgICAgIG9wdC5lbXBoYXNpcyA9IG9wdC5lbXBoYXNpcyB8fCB7fTtcbiAgICAgIG9wdC5lbXBoYXNpc1tvcHRUeXBlXSA9IGVtcGhhc2lzT3B0O1xuICAgICAgLy8gQWxzbyBjb21wYXQgdGhlIGNhc2UgdXNlciBtaXggdGhlIHN0eWxlIGFuZCBmb2N1cyB0b2dldGhlciBpbiBlYzMgc3R5bGVcbiAgICAgIC8vIGZvciBleGFtcGxlOiB7IGl0ZW1TdHlsZTogeyBub3JtYWw6IHt9LCBlbXBoYXNpczoge2ZvY3VzLCBzaGFkb3dCbHVyfSB9IH1cbiAgICAgIGlmIChlbXBoYXNpc09wdC5mb2N1cykge1xuICAgICAgICBvcHQuZW1waGFzaXMuZm9jdXMgPSBlbXBoYXNpc09wdC5mb2N1cztcbiAgICAgIH1cbiAgICAgIGlmIChlbXBoYXNpc09wdC5ibHVyU2NvcGUpIHtcbiAgICAgICAgb3B0LmVtcGhhc2lzLmJsdXJTY29wZSA9IGVtcGhhc2lzT3B0LmJsdXJTY29wZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUVDM05vcm1hbFN0YXR1cyhvcHQpIHtcbiAgY29udmVydE5vcm1hbEVtcGhhc2lzKG9wdCwgJ2l0ZW1TdHlsZScpO1xuICBjb252ZXJ0Tm9ybWFsRW1waGFzaXMob3B0LCAnbGluZVN0eWxlJyk7XG4gIGNvbnZlcnROb3JtYWxFbXBoYXNpcyhvcHQsICdhcmVhU3R5bGUnKTtcbiAgY29udmVydE5vcm1hbEVtcGhhc2lzKG9wdCwgJ2xhYmVsJyk7XG4gIGNvbnZlcnROb3JtYWxFbXBoYXNpcyhvcHQsICdsYWJlbExpbmUnKTtcbiAgLy8gdHJlZW1hcFxuICBjb252ZXJ0Tm9ybWFsRW1waGFzaXMob3B0LCAndXBwZXJMYWJlbCcpO1xuICAvLyBncmFwaFxuICBjb252ZXJ0Tm9ybWFsRW1waGFzaXMob3B0LCAnZWRnZUxhYmVsJyk7XG59XG5mdW5jdGlvbiBjb21wYXRUZXh0U3R5bGUob3B0LCBwcm9wTmFtZSkge1xuICAvLyBDaGVjayB3aGV0aGVyIGlzIG5vdCBvYmplY3QgKHN0cmluZ1xcbnVsbFxcdW5kZWZpbmVkIC4uLilcbiAgdmFyIGxhYmVsT3B0U2luZ2xlID0gaXNPYmplY3Qob3B0KSAmJiBvcHRbcHJvcE5hbWVdO1xuICB2YXIgdGV4dFN0eWxlID0gaXNPYmplY3QobGFiZWxPcHRTaW5nbGUpICYmIGxhYmVsT3B0U2luZ2xlLnRleHRTdHlsZTtcbiAgaWYgKHRleHRTdHlsZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgZGVwcmVjYXRlTG9nKFwidGV4dFN0eWxlIGhpZXJhcmNoeSBpbiBcIiArIHByb3BOYW1lICsgXCIgaGFzIGJlZW4gcmVtb3ZlZCBzaW5jZSA0LjAuIEFsbCB0ZXh0U3R5bGUgcHJvcGVydGllcyBhcmUgY29uZmlndXJlZCBpbiBcIiArIHByb3BOYW1lICsgXCIgZGlyZWN0bHkgbm93LlwiKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1vZGVsVXRpbC5URVhUX1NUWUxFX09QVElPTlMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB0ZXh0UHJvcE5hbWUgPSBtb2RlbFV0aWwuVEVYVF9TVFlMRV9PUFRJT05TW2ldO1xuICAgICAgaWYgKHRleHRTdHlsZS5oYXNPd25Qcm9wZXJ0eSh0ZXh0UHJvcE5hbWUpKSB7XG4gICAgICAgIGxhYmVsT3B0U2luZ2xlW3RleHRQcm9wTmFtZV0gPSB0ZXh0U3R5bGVbdGV4dFByb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBhdEVDM0NvbW1vblN0eWxlcyhvcHQpIHtcbiAgaWYgKG9wdCkge1xuICAgIHJlbW92ZUVDM05vcm1hbFN0YXR1cyhvcHQpO1xuICAgIGNvbXBhdFRleHRTdHlsZShvcHQsICdsYWJlbCcpO1xuICAgIG9wdC5lbXBoYXNpcyAmJiBjb21wYXRUZXh0U3R5bGUob3B0LmVtcGhhc2lzLCAnbGFiZWwnKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1NlcmllcyhzZXJpZXNPcHQpIHtcbiAgaWYgKCFpc09iamVjdChzZXJpZXNPcHQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbXBhdEVDMkl0ZW1TdHlsZShzZXJpZXNPcHQpO1xuICByZW1vdmVFQzNOb3JtYWxTdGF0dXMoc2VyaWVzT3B0KTtcbiAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdCwgJ2xhYmVsJyk7XG4gIC8vIHRyZWVtYXBcbiAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdCwgJ3VwcGVyTGFiZWwnKTtcbiAgLy8gZ3JhcGhcbiAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdCwgJ2VkZ2VMYWJlbCcpO1xuICBpZiAoc2VyaWVzT3B0LmVtcGhhc2lzKSB7XG4gICAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdC5lbXBoYXNpcywgJ2xhYmVsJyk7XG4gICAgLy8gdHJlZW1hcFxuICAgIGNvbXBhdFRleHRTdHlsZShzZXJpZXNPcHQuZW1waGFzaXMsICd1cHBlckxhYmVsJyk7XG4gICAgLy8gZ3JhcGhcbiAgICBjb21wYXRUZXh0U3R5bGUoc2VyaWVzT3B0LmVtcGhhc2lzLCAnZWRnZUxhYmVsJyk7XG4gIH1cbiAgdmFyIG1hcmtQb2ludCA9IHNlcmllc09wdC5tYXJrUG9pbnQ7XG4gIGlmIChtYXJrUG9pbnQpIHtcbiAgICBjb21wYXRFQzJJdGVtU3R5bGUobWFya1BvaW50KTtcbiAgICBjb21wYXRFQzNDb21tb25TdHlsZXMobWFya1BvaW50KTtcbiAgfVxuICB2YXIgbWFya0xpbmUgPSBzZXJpZXNPcHQubWFya0xpbmU7XG4gIGlmIChtYXJrTGluZSkge1xuICAgIGNvbXBhdEVDMkl0ZW1TdHlsZShtYXJrTGluZSk7XG4gICAgY29tcGF0RUMzQ29tbW9uU3R5bGVzKG1hcmtMaW5lKTtcbiAgfVxuICB2YXIgbWFya0FyZWEgPSBzZXJpZXNPcHQubWFya0FyZWE7XG4gIGlmIChtYXJrQXJlYSkge1xuICAgIGNvbXBhdEVDM0NvbW1vblN0eWxlcyhtYXJrQXJlYSk7XG4gIH1cbiAgdmFyIGRhdGEgPSBzZXJpZXNPcHQuZGF0YTtcbiAgLy8gQnJlYWsgd2l0aCBlYzM6IGlmIGBzZXRPcHRpb25gIGFnYWluLCB0aGVyZSBtYXkgYmUgbm8gYHR5cGVgIGluIG9wdGlvbixcbiAgLy8gdGhlbiB0aGUgYmFja3dhcmQgY29tcGF0IGJhc2VkIG9uIG9wdGlvbiB0eXBlIHdpbGwgbm90IGJlIHBlcmZvcm1lZC5cbiAgaWYgKHNlcmllc09wdC50eXBlID09PSAnZ3JhcGgnKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwgc2VyaWVzT3B0Lm5vZGVzO1xuICAgIHZhciBlZGdlRGF0YSA9IHNlcmllc09wdC5saW5rcyB8fCBzZXJpZXNPcHQuZWRnZXM7XG4gICAgaWYgKGVkZ2VEYXRhICYmICF6clV0aWwuaXNUeXBlZEFycmF5KGVkZ2VEYXRhKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb21wYXRFQzNDb21tb25TdHlsZXMoZWRnZURhdGFbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB6clV0aWwuZWFjaChzZXJpZXNPcHQuY2F0ZWdvcmllcywgZnVuY3Rpb24gKG9wdCkge1xuICAgICAgcmVtb3ZlRUMzTm9ybWFsU3RhdHVzKG9wdCk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGRhdGEgJiYgIXpyVXRpbC5pc1R5cGVkQXJyYXkoZGF0YSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbXBhdEVDM0NvbW1vblN0eWxlcyhkYXRhW2ldKTtcbiAgICB9XG4gIH1cbiAgLy8gbWFyayBwb2ludCBkYXRhXG4gIG1hcmtQb2ludCA9IHNlcmllc09wdC5tYXJrUG9pbnQ7XG4gIGlmIChtYXJrUG9pbnQgJiYgbWFya1BvaW50LmRhdGEpIHtcbiAgICB2YXIgbXBEYXRhID0gbWFya1BvaW50LmRhdGE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtcERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbXBhdEVDM0NvbW1vblN0eWxlcyhtcERhdGFbaV0pO1xuICAgIH1cbiAgfVxuICAvLyBtYXJrIGxpbmUgZGF0YVxuICBtYXJrTGluZSA9IHNlcmllc09wdC5tYXJrTGluZTtcbiAgaWYgKG1hcmtMaW5lICYmIG1hcmtMaW5lLmRhdGEpIHtcbiAgICB2YXIgbWxEYXRhID0gbWFya0xpbmUuZGF0YTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KG1sRGF0YVtpXSkpIHtcbiAgICAgICAgY29tcGF0RUMzQ29tbW9uU3R5bGVzKG1sRGF0YVtpXVswXSk7XG4gICAgICAgIGNvbXBhdEVDM0NvbW1vblN0eWxlcyhtbERhdGFbaV1bMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGF0RUMzQ29tbW9uU3R5bGVzKG1sRGF0YVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFNlcmllc1xuICBpZiAoc2VyaWVzT3B0LnR5cGUgPT09ICdnYXVnZScpIHtcbiAgICBjb21wYXRUZXh0U3R5bGUoc2VyaWVzT3B0LCAnYXhpc0xhYmVsJyk7XG4gICAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdCwgJ3RpdGxlJyk7XG4gICAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdCwgJ2RldGFpbCcpO1xuICB9IGVsc2UgaWYgKHNlcmllc09wdC50eXBlID09PSAndHJlZW1hcCcpIHtcbiAgICBjb252ZXJ0Tm9ybWFsRW1waGFzaXMoc2VyaWVzT3B0LmJyZWFkY3J1bWIsICdpdGVtU3R5bGUnKTtcbiAgICB6clV0aWwuZWFjaChzZXJpZXNPcHQubGV2ZWxzLCBmdW5jdGlvbiAob3B0KSB7XG4gICAgICByZW1vdmVFQzNOb3JtYWxTdGF0dXMob3B0KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzZXJpZXNPcHQudHlwZSA9PT0gJ3RyZWUnKSB7XG4gICAgcmVtb3ZlRUMzTm9ybWFsU3RhdHVzKHNlcmllc09wdC5sZWF2ZXMpO1xuICB9XG4gIC8vIHN1bmJ1cnN0IHN0YXJ0cyBmcm9tIGVjNCwgc28gaXQgZG9lcyBub3QgbmVlZCB0byBjb21wYXQgbGV2ZWxzLlxufVxuZnVuY3Rpb24gdG9BcnIobykge1xuICByZXR1cm4genJVdGlsLmlzQXJyYXkobykgPyBvIDogbyA/IFtvXSA6IFtdO1xufVxuZnVuY3Rpb24gdG9PYmoobykge1xuICByZXR1cm4gKHpyVXRpbC5pc0FycmF5KG8pID8gb1swXSA6IG8pIHx8IHt9O1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2xvYmFsQ29tcGF0U3R5bGUob3B0aW9uLCBpc1RoZW1lKSB7XG4gIGVhY2godG9BcnIob3B0aW9uLnNlcmllcyksIGZ1bmN0aW9uIChzZXJpZXNPcHQpIHtcbiAgICBpc09iamVjdChzZXJpZXNPcHQpICYmIHByb2Nlc3NTZXJpZXMoc2VyaWVzT3B0KTtcbiAgfSk7XG4gIHZhciBheGVzID0gWyd4QXhpcycsICd5QXhpcycsICdyYWRpdXNBeGlzJywgJ2FuZ2xlQXhpcycsICdzaW5nbGVBeGlzJywgJ3BhcmFsbGVsQXhpcycsICdyYWRhciddO1xuICBpc1RoZW1lICYmIGF4ZXMucHVzaCgndmFsdWVBeGlzJywgJ2NhdGVnb3J5QXhpcycsICdsb2dBeGlzJywgJ3RpbWVBeGlzJyk7XG4gIGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXNOYW1lKSB7XG4gICAgZWFjaCh0b0FycihvcHRpb25bYXhpc05hbWVdKSwgZnVuY3Rpb24gKGF4aXNPcHQpIHtcbiAgICAgIGlmIChheGlzT3B0KSB7XG4gICAgICAgIGNvbXBhdFRleHRTdHlsZShheGlzT3B0LCAnYXhpc0xhYmVsJyk7XG4gICAgICAgIGNvbXBhdFRleHRTdHlsZShheGlzT3B0LmF4aXNQb2ludGVyLCAnbGFiZWwnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIGVhY2godG9BcnIob3B0aW9uLnBhcmFsbGVsKSwgZnVuY3Rpb24gKHBhcmFsbGVsT3B0KSB7XG4gICAgdmFyIHBhcmFsbGVsQXhpc0RlZmF1bHQgPSBwYXJhbGxlbE9wdCAmJiBwYXJhbGxlbE9wdC5wYXJhbGxlbEF4aXNEZWZhdWx0O1xuICAgIGNvbXBhdFRleHRTdHlsZShwYXJhbGxlbEF4aXNEZWZhdWx0LCAnYXhpc0xhYmVsJyk7XG4gICAgY29tcGF0VGV4dFN0eWxlKHBhcmFsbGVsQXhpc0RlZmF1bHQgJiYgcGFyYWxsZWxBeGlzRGVmYXVsdC5heGlzUG9pbnRlciwgJ2xhYmVsJyk7XG4gIH0pO1xuICBlYWNoKHRvQXJyKG9wdGlvbi5jYWxlbmRhciksIGZ1bmN0aW9uIChjYWxlbmRhck9wdCkge1xuICAgIGNvbnZlcnROb3JtYWxFbXBoYXNpcyhjYWxlbmRhck9wdCwgJ2l0ZW1TdHlsZScpO1xuICAgIGNvbXBhdFRleHRTdHlsZShjYWxlbmRhck9wdCwgJ2RheUxhYmVsJyk7XG4gICAgY29tcGF0VGV4dFN0eWxlKGNhbGVuZGFyT3B0LCAnbW9udGhMYWJlbCcpO1xuICAgIGNvbXBhdFRleHRTdHlsZShjYWxlbmRhck9wdCwgJ3llYXJMYWJlbCcpO1xuICB9KTtcbiAgLy8gcmFkYXIubmFtZS50ZXh0U3R5bGVcbiAgZWFjaCh0b0FycihvcHRpb24ucmFkYXIpLCBmdW5jdGlvbiAocmFkYXJPcHQpIHtcbiAgICBjb21wYXRUZXh0U3R5bGUocmFkYXJPcHQsICduYW1lJyk7XG4gICAgLy8gVXNlIGF4aXNOYW1lIGluc3RlYWQgb2YgbmFtZSBiZWNhdXNlIGNvbXBvbmVudCBoYXMgbmFtZSBwcm9wZXJ0eVxuICAgIGlmIChyYWRhck9wdC5uYW1lICYmIHJhZGFyT3B0LmF4aXNOYW1lID09IG51bGwpIHtcbiAgICAgIHJhZGFyT3B0LmF4aXNOYW1lID0gcmFkYXJPcHQubmFtZTtcbiAgICAgIGRlbGV0ZSByYWRhck9wdC5uYW1lO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVwcmVjYXRlTG9nKCduYW1lIHByb3BlcnR5IGluIHJhZGFyIGNvbXBvbmVudCBoYXMgYmVlbiBjaGFuZ2VkIHRvIGF4aXNOYW1lJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyYWRhck9wdC5uYW1lR2FwICE9IG51bGwgJiYgcmFkYXJPcHQuYXhpc05hbWVHYXAgPT0gbnVsbCkge1xuICAgICAgcmFkYXJPcHQuYXhpc05hbWVHYXAgPSByYWRhck9wdC5uYW1lR2FwO1xuICAgICAgZGVsZXRlIHJhZGFyT3B0Lm5hbWVHYXA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZXByZWNhdGVMb2coJ25hbWVHYXAgcHJvcGVydHkgaW4gcmFkYXIgY29tcG9uZW50IGhhcyBiZWVuIGNoYW5nZWQgdG8gYXhpc05hbWVHYXAnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGVhY2gocmFkYXJPcHQuaW5kaWNhdG9yLCBmdW5jdGlvbiAoaW5kaWNhdG9yT3B0KSB7XG4gICAgICAgIGlmIChpbmRpY2F0b3JPcHQudGV4dCkge1xuICAgICAgICAgIGRlcHJlY2F0ZVJlcGxhY2VMb2coJ3RleHQnLCAnbmFtZScsICdyYWRhci5pbmRpY2F0b3InKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgZWFjaCh0b0FycihvcHRpb24uZ2VvKSwgZnVuY3Rpb24gKGdlb09wdCkge1xuICAgIGlmIChpc09iamVjdChnZW9PcHQpKSB7XG4gICAgICBjb21wYXRFQzNDb21tb25TdHlsZXMoZ2VvT3B0KTtcbiAgICAgIGVhY2godG9BcnIoZ2VvT3B0LnJlZ2lvbnMpLCBmdW5jdGlvbiAocmVnaW9uT2JqKSB7XG4gICAgICAgIGNvbXBhdEVDM0NvbW1vblN0eWxlcyhyZWdpb25PYmopO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgZWFjaCh0b0FycihvcHRpb24udGltZWxpbmUpLCBmdW5jdGlvbiAodGltZWxpbmVPcHQpIHtcbiAgICBjb21wYXRFQzNDb21tb25TdHlsZXModGltZWxpbmVPcHQpO1xuICAgIGNvbnZlcnROb3JtYWxFbXBoYXNpcyh0aW1lbGluZU9wdCwgJ2xhYmVsJyk7XG4gICAgY29udmVydE5vcm1hbEVtcGhhc2lzKHRpbWVsaW5lT3B0LCAnaXRlbVN0eWxlJyk7XG4gICAgY29udmVydE5vcm1hbEVtcGhhc2lzKHRpbWVsaW5lT3B0LCAnY29udHJvbFN0eWxlJywgdHJ1ZSk7XG4gICAgdmFyIGRhdGEgPSB0aW1lbGluZU9wdC5kYXRhO1xuICAgIHpyVXRpbC5pc0FycmF5KGRhdGEpICYmIHpyVXRpbC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIGNvbnZlcnROb3JtYWxFbXBoYXNpcyhpdGVtLCAnbGFiZWwnKTtcbiAgICAgICAgY29udmVydE5vcm1hbEVtcGhhc2lzKGl0ZW0sICdpdGVtU3R5bGUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIGVhY2godG9BcnIob3B0aW9uLnRvb2xib3gpLCBmdW5jdGlvbiAodG9vbGJveE9wdCkge1xuICAgIGNvbnZlcnROb3JtYWxFbXBoYXNpcyh0b29sYm94T3B0LCAnaWNvblN0eWxlJyk7XG4gICAgZWFjaCh0b29sYm94T3B0LmZlYXR1cmUsIGZ1bmN0aW9uIChmZWF0dXJlT3B0KSB7XG4gICAgICBjb252ZXJ0Tm9ybWFsRW1waGFzaXMoZmVhdHVyZU9wdCwgJ2ljb25TdHlsZScpO1xuICAgIH0pO1xuICB9KTtcbiAgY29tcGF0VGV4dFN0eWxlKHRvT2JqKG9wdGlvbi5heGlzUG9pbnRlciksICdsYWJlbCcpO1xuICBjb21wYXRUZXh0U3R5bGUodG9PYmoob3B0aW9uLnRvb2x0aXApLmF4aXNQb2ludGVyLCAnbGFiZWwnKTtcbiAgLy8gQ2xlYW4gbG9nc1xuICAvLyBzdG9yZWRMb2dzID0ge307XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBlYWNoLCBpc0FycmF5LCBpc09iamVjdCwgaXNUeXBlZEFycmF5LCBkZWZhdWx0cyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgY29tcGF0U3R5bGUgZnJvbSAnLi9oZWxwZXIvY29tcGF0U3R5bGUuanMnO1xuaW1wb3J0IHsgbm9ybWFsaXplVG9BcnJheSB9IGZyb20gJy4uL3V0aWwvbW9kZWwuanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRlTG9nLCBkZXByZWNhdGVSZXBsYWNlTG9nIH0gZnJvbSAnLi4vdXRpbC9sb2cuanMnO1xuZnVuY3Rpb24gZ2V0KG9wdCwgcGF0aCkge1xuICB2YXIgcGF0aEFyciA9IHBhdGguc3BsaXQoJywnKTtcbiAgdmFyIG9iaiA9IG9wdDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgb2JqID0gb2JqICYmIG9ialtwYXRoQXJyW2ldXTtcbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gc2V0KG9wdCwgcGF0aCwgdmFsLCBvdmVyd3JpdGUpIHtcbiAgdmFyIHBhdGhBcnIgPSBwYXRoLnNwbGl0KCcsJyk7XG4gIHZhciBvYmogPSBvcHQ7XG4gIHZhciBrZXk7XG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCBwYXRoQXJyLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGtleSA9IHBhdGhBcnJbaV07XG4gICAgaWYgKG9ialtrZXldID09IG51bGwpIHtcbiAgICAgIG9ialtrZXldID0ge307XG4gICAgfVxuICAgIG9iaiA9IG9ialtrZXldO1xuICB9XG4gIGlmIChvdmVyd3JpdGUgfHwgb2JqW3BhdGhBcnJbaV1dID09IG51bGwpIHtcbiAgICBvYmpbcGF0aEFycltpXV0gPSB2YWw7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBhdExheW91dFByb3BlcnRpZXMob3B0aW9uKSB7XG4gIG9wdGlvbiAmJiBlYWNoKExBWU9VVF9QUk9QRVJUSUVTLCBmdW5jdGlvbiAocHJvcCkge1xuICAgIGlmIChwcm9wWzBdIGluIG9wdGlvbiAmJiAhKHByb3BbMV0gaW4gb3B0aW9uKSkge1xuICAgICAgb3B0aW9uW3Byb3BbMV1dID0gb3B0aW9uW3Byb3BbMF1dO1xuICAgIH1cbiAgfSk7XG59XG52YXIgTEFZT1VUX1BST1BFUlRJRVMgPSBbWyd4JywgJ2xlZnQnXSwgWyd5JywgJ3RvcCddLCBbJ3gyJywgJ3JpZ2h0J10sIFsneTInLCAnYm90dG9tJ11dO1xudmFyIENPTVBBVElUQUJMRV9DT01QT05FTlRTID0gWydncmlkJywgJ2dlbycsICdwYXJhbGxlbCcsICdsZWdlbmQnLCAndG9vbGJveCcsICd0aXRsZScsICd2aXN1YWxNYXAnLCAnZGF0YVpvb20nLCAndGltZWxpbmUnXTtcbnZhciBCQVJfSVRFTV9TVFlMRV9NQVAgPSBbWydib3JkZXJSYWRpdXMnLCAnYmFyQm9yZGVyUmFkaXVzJ10sIFsnYm9yZGVyQ29sb3InLCAnYmFyQm9yZGVyQ29sb3InXSwgWydib3JkZXJXaWR0aCcsICdiYXJCb3JkZXJXaWR0aCddXTtcbmZ1bmN0aW9uIGNvbXBhdEJhckl0ZW1TdHlsZShvcHRpb24pIHtcbiAgdmFyIGl0ZW1TdHlsZSA9IG9wdGlvbiAmJiBvcHRpb24uaXRlbVN0eWxlO1xuICBpZiAoaXRlbVN0eWxlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBCQVJfSVRFTV9TVFlMRV9NQVAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvbGROYW1lID0gQkFSX0lURU1fU1RZTEVfTUFQW2ldWzFdO1xuICAgICAgdmFyIG5ld05hbWUgPSBCQVJfSVRFTV9TVFlMRV9NQVBbaV1bMF07XG4gICAgICBpZiAoaXRlbVN0eWxlW29sZE5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgaXRlbVN0eWxlW25ld05hbWVdID0gaXRlbVN0eWxlW29sZE5hbWVdO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGRlcHJlY2F0ZVJlcGxhY2VMb2cob2xkTmFtZSwgbmV3TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBhdFBpZUxhYmVsKG9wdGlvbikge1xuICBpZiAoIW9wdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0aW9uLmFsaWduVG8gPT09ICdlZGdlJyAmJiBvcHRpb24ubWFyZ2luICE9IG51bGwgJiYgb3B0aW9uLmVkZ2VEaXN0YW5jZSA9PSBudWxsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlcHJlY2F0ZVJlcGxhY2VMb2coJ2xhYmVsLm1hcmdpbicsICdsYWJlbC5lZGdlRGlzdGFuY2UnLCAncGllJyk7XG4gICAgfVxuICAgIG9wdGlvbi5lZGdlRGlzdGFuY2UgPSBvcHRpb24ubWFyZ2luO1xuICB9XG59XG5mdW5jdGlvbiBjb21wYXRTdW5idXJzdFN0YXRlKG9wdGlvbikge1xuICBpZiAoIW9wdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0aW9uLmRvd25wbGF5ICYmICFvcHRpb24uYmx1cikge1xuICAgIG9wdGlvbi5ibHVyID0gb3B0aW9uLmRvd25wbGF5O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZXByZWNhdGVSZXBsYWNlTG9nKCdkb3ducGxheScsICdibHVyJywgJ3N1bmJ1cnN0Jyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21wYXRHcmFwaEZvY3VzKG9wdGlvbikge1xuICBpZiAoIW9wdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0aW9uLmZvY3VzTm9kZUFkamFjZW5jeSAhPSBudWxsKSB7XG4gICAgb3B0aW9uLmVtcGhhc2lzID0gb3B0aW9uLmVtcGhhc2lzIHx8IHt9O1xuICAgIGlmIChvcHRpb24uZW1waGFzaXMuZm9jdXMgPT0gbnVsbCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVwcmVjYXRlUmVwbGFjZUxvZygnZm9jdXNOb2RlQWRqYWNlbmN5JywgJ2VtcGhhc2lzOiB7IGZvY3VzOiBcXCdhZGphY2VuY3lcXCd9JywgJ2dyYXBoL3NhbmtleScpO1xuICAgICAgfVxuICAgICAgb3B0aW9uLmVtcGhhc2lzLmZvY3VzID0gJ2FkamFjZW5jeSc7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVRyZWUoZGF0YSwgY2IpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNiKGRhdGFbaV0pO1xuICAgICAgZGF0YVtpXSAmJiB0cmF2ZXJzZVRyZWUoZGF0YVtpXS5jaGlsZHJlbiwgY2IpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2xvYmFsQmFja3dhcmRDb21wYXQob3B0aW9uLCBpc1RoZW1lKSB7XG4gIGNvbXBhdFN0eWxlKG9wdGlvbiwgaXNUaGVtZSk7XG4gIC8vIE1ha2Ugc3VyZSBzZXJpZXMgYXJyYXkgZm9yIG1vZGVsIGluaXRpYWxpemF0aW9uLlxuICBvcHRpb24uc2VyaWVzID0gbm9ybWFsaXplVG9BcnJheShvcHRpb24uc2VyaWVzKTtcbiAgZWFjaChvcHRpb24uc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzT3B0KSB7XG4gICAgaWYgKCFpc09iamVjdChzZXJpZXNPcHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZXJpZXNUeXBlID0gc2VyaWVzT3B0LnR5cGU7XG4gICAgaWYgKHNlcmllc1R5cGUgPT09ICdsaW5lJykge1xuICAgICAgaWYgKHNlcmllc09wdC5jbGlwT3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICBzZXJpZXNPcHQuY2xpcCA9IHNlcmllc09wdC5jbGlwT3ZlcmZsb3c7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgZGVwcmVjYXRlUmVwbGFjZUxvZygnY2xpcE92ZXJmbG93JywgJ2NsaXAnLCAnbGluZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzZXJpZXNUeXBlID09PSAncGllJyB8fCBzZXJpZXNUeXBlID09PSAnZ2F1Z2UnKSB7XG4gICAgICBpZiAoc2VyaWVzT3B0LmNsb2NrV2lzZSAhPSBudWxsKSB7XG4gICAgICAgIHNlcmllc09wdC5jbG9ja3dpc2UgPSBzZXJpZXNPcHQuY2xvY2tXaXNlO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGRlcHJlY2F0ZVJlcGxhY2VMb2coJ2Nsb2NrV2lzZScsICdjbG9ja3dpc2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29tcGF0UGllTGFiZWwoc2VyaWVzT3B0LmxhYmVsKTtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzT3B0LmRhdGE7XG4gICAgICBpZiAoZGF0YSAmJiAhaXNUeXBlZEFycmF5KGRhdGEpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbXBhdFBpZUxhYmVsKGRhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VyaWVzT3B0LmhvdmVyT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2VyaWVzT3B0LmVtcGhhc2lzID0gc2VyaWVzT3B0LmVtcGhhc2lzIHx8IHt9O1xuICAgICAgICBpZiAoc2VyaWVzT3B0LmVtcGhhc2lzLnNjYWxlU2l6ZSA9IG51bGwpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZGVwcmVjYXRlUmVwbGFjZUxvZygnaG92ZXJPZmZzZXQnLCAnZW1waGFzaXMuc2NhbGVTaXplJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcmllc09wdC5lbXBoYXNpcy5zY2FsZVNpemUgPSBzZXJpZXNPcHQuaG92ZXJPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNlcmllc1R5cGUgPT09ICdnYXVnZScpIHtcbiAgICAgIHZhciBwb2ludGVyQ29sb3IgPSBnZXQoc2VyaWVzT3B0LCAncG9pbnRlci5jb2xvcicpO1xuICAgICAgcG9pbnRlckNvbG9yICE9IG51bGwgJiYgc2V0KHNlcmllc09wdCwgJ2l0ZW1TdHlsZS5jb2xvcicsIHBvaW50ZXJDb2xvcik7XG4gICAgfSBlbHNlIGlmIChzZXJpZXNUeXBlID09PSAnYmFyJykge1xuICAgICAgY29tcGF0QmFySXRlbVN0eWxlKHNlcmllc09wdCk7XG4gICAgICBjb21wYXRCYXJJdGVtU3R5bGUoc2VyaWVzT3B0LmJhY2tncm91bmRTdHlsZSk7XG4gICAgICBjb21wYXRCYXJJdGVtU3R5bGUoc2VyaWVzT3B0LmVtcGhhc2lzKTtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzT3B0LmRhdGE7XG4gICAgICBpZiAoZGF0YSAmJiAhaXNUeXBlZEFycmF5KGRhdGEpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbXBhdEJhckl0ZW1TdHlsZShkYXRhW2ldKTtcbiAgICAgICAgICAgIGNvbXBhdEJhckl0ZW1TdHlsZShkYXRhW2ldICYmIGRhdGFbaV0uZW1waGFzaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VyaWVzVHlwZSA9PT0gJ3N1bmJ1cnN0Jykge1xuICAgICAgdmFyIGhpZ2hsaWdodFBvbGljeSA9IHNlcmllc09wdC5oaWdobGlnaHRQb2xpY3k7XG4gICAgICBpZiAoaGlnaGxpZ2h0UG9saWN5KSB7XG4gICAgICAgIHNlcmllc09wdC5lbXBoYXNpcyA9IHNlcmllc09wdC5lbXBoYXNpcyB8fCB7fTtcbiAgICAgICAgaWYgKCFzZXJpZXNPcHQuZW1waGFzaXMuZm9jdXMpIHtcbiAgICAgICAgICBzZXJpZXNPcHQuZW1waGFzaXMuZm9jdXMgPSBoaWdobGlnaHRQb2xpY3k7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZVJlcGxhY2VMb2coJ2hpZ2hsaWdodFBvbGljeScsICdlbXBoYXNpcy5mb2N1cycsICdzdW5idXJzdCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29tcGF0U3VuYnVyc3RTdGF0ZShzZXJpZXNPcHQpO1xuICAgICAgdHJhdmVyc2VUcmVlKHNlcmllc09wdC5kYXRhLCBjb21wYXRTdW5idXJzdFN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHNlcmllc1R5cGUgPT09ICdncmFwaCcgfHwgc2VyaWVzVHlwZSA9PT0gJ3NhbmtleScpIHtcbiAgICAgIGNvbXBhdEdyYXBoRm9jdXMoc2VyaWVzT3B0KTtcbiAgICAgIC8vIFRPRE8gbm9kZXMsIGVkZ2VzP1xuICAgIH0gZWxzZSBpZiAoc2VyaWVzVHlwZSA9PT0gJ21hcCcpIHtcbiAgICAgIGlmIChzZXJpZXNPcHQubWFwVHlwZSAmJiAhc2VyaWVzT3B0Lm1hcCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGRlcHJlY2F0ZVJlcGxhY2VMb2coJ21hcFR5cGUnLCAnbWFwJywgJ21hcCcpO1xuICAgICAgICB9XG4gICAgICAgIHNlcmllc09wdC5tYXAgPSBzZXJpZXNPcHQubWFwVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXJpZXNPcHQubWFwTG9jYXRpb24pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBkZXByZWNhdGVMb2coJ2BtYXBMb2NhdGlvbmAgaXMgbm90IHVzZWQgYW55bW9yZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0cyhzZXJpZXNPcHQsIHNlcmllc09wdC5tYXBMb2NhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZXJpZXNPcHQuaG92ZXJBbmltYXRpb24gIT0gbnVsbCkge1xuICAgICAgc2VyaWVzT3B0LmVtcGhhc2lzID0gc2VyaWVzT3B0LmVtcGhhc2lzIHx8IHt9O1xuICAgICAgaWYgKHNlcmllc09wdC5lbXBoYXNpcyAmJiBzZXJpZXNPcHQuZW1waGFzaXMuc2NhbGUgPT0gbnVsbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGRlcHJlY2F0ZVJlcGxhY2VMb2coJ2hvdmVyQW5pbWF0aW9uJywgJ2VtcGhhc2lzLnNjYWxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VyaWVzT3B0LmVtcGhhc2lzLnNjYWxlID0gc2VyaWVzT3B0LmhvdmVyQW5pbWF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBjb21wYXRMYXlvdXRQcm9wZXJ0aWVzKHNlcmllc09wdCk7XG4gIH0pO1xuICAvLyBkYXRhUmFuZ2UgaGFzIGNoYW5nZWQgdG8gdmlzdWFsTWFwXG4gIGlmIChvcHRpb24uZGF0YVJhbmdlKSB7XG4gICAgb3B0aW9uLnZpc3VhbE1hcCA9IG9wdGlvbi5kYXRhUmFuZ2U7XG4gIH1cbiAgZWFjaChDT01QQVRJVEFCTEVfQ09NUE9ORU5UUywgZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbltjb21wb25lbnROYW1lXTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgaWYgKCFpc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBbb3B0aW9uc107XG4gICAgICB9XG4gICAgICBlYWNoKG9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgY29tcGF0TGF5b3V0UHJvcGVydGllcyhvcHRpb24pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///74065\n")},74562:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74179);\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24326);\n/* harmony import */ var _util_format_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(83412);\n/* harmony import */ var _Scale_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(28613);\n/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(67071);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar roundNumber = _util_number_js__WEBPACK_IMPORTED_MODULE_0__/* .round */ .LI;\nvar IntervalScale = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .C6)(IntervalScale, _super);\n  function IntervalScale() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = 'interval';\n    // Step is calculated in adjustExtent.\n    _this._interval = 0;\n    _this._intervalPrecision = 2;\n    return _this;\n  }\n  IntervalScale.prototype.parse = function (val) {\n    return val;\n  };\n  IntervalScale.prototype.contain = function (val) {\n    return _helper_js__WEBPACK_IMPORTED_MODULE_2__/* .contain */ .lP(val, this._extent);\n  };\n  IntervalScale.prototype.normalize = function (val) {\n    return _helper_js__WEBPACK_IMPORTED_MODULE_2__/* .normalize */ .S8(val, this._extent);\n  };\n  IntervalScale.prototype.scale = function (val) {\n    return _helper_js__WEBPACK_IMPORTED_MODULE_2__/* .scale */ .hs(val, this._extent);\n  };\n  IntervalScale.prototype.setExtent = function (start, end) {\n    var thisExtent = this._extent;\n    // start,end may be a Number like '25',so...\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  };\n  IntervalScale.prototype.unionExtent = function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]);\n    // unionExtent may called by it's sub classes\n    this.setExtent(extent[0], extent[1]);\n  };\n  IntervalScale.prototype.getInterval = function () {\n    return this._interval;\n  };\n  IntervalScale.prototype.setInterval = function (interval) {\n    this._interval = interval;\n    // Dropped auto calculated niceExtent and use user-set extent.\n    // We assume user wants to set both interval, min, max to get a better result.\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = _helper_js__WEBPACK_IMPORTED_MODULE_2__/* .getIntervalPrecision */ .u$(interval);\n  };\n  /**\r\n   * @param expandToNicedExtent Whether expand the ticks to niced extent.\r\n   */\n  IntervalScale.prototype.getTicks = function (expandToNicedExtent) {\n    var interval = this._interval;\n    var extent = this._extent;\n    var niceTickExtent = this._niceExtent;\n    var intervalPrecision = this._intervalPrecision;\n    var ticks = [];\n    // If interval is 0, return [];\n    if (!interval) {\n      return ticks;\n    }\n    // Consider this case: using dataZoom toolbox, zoom and zoom.\n    var safeLimit = 10000;\n    if (extent[0] < niceTickExtent[0]) {\n      if (expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[0]\n        });\n      }\n    }\n    var tick = niceTickExtent[0];\n    while (tick <= niceTickExtent[1]) {\n      ticks.push({\n        value: tick\n      });\n      // Avoid rounding error\n      tick = roundNumber(tick + interval, intervalPrecision);\n      if (tick === ticks[ticks.length - 1].value) {\n        // Consider out of safe float point, e.g.,\n        // -3711126.9907707 + 2e-10 === -3711126.9907707\n        break;\n      }\n      if (ticks.length > safeLimit) {\n        return [];\n      }\n    }\n    // Consider this case: the last item of ticks is smaller\n    // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];\n    if (extent[1] > lastNiceTick) {\n      if (expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(lastNiceTick + interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[1]\n        });\n      }\n    }\n    return ticks;\n  };\n  IntervalScale.prototype.getMinorTicks = function (splitNumber) {\n    var ticks = this.getTicks(true);\n    var minorTicks = [];\n    var extent = this.getExtent();\n    for (var i = 1; i < ticks.length; i++) {\n      var nextTick = ticks[i];\n      var prevTick = ticks[i - 1];\n      var count = 0;\n      var minorTicksGroup = [];\n      var interval = nextTick.value - prevTick.value;\n      var minorInterval = interval / splitNumber;\n      while (count < splitNumber - 1) {\n        var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval);\n        // For the first and last interval. The count may be less than splitNumber.\n        if (minorTick > extent[0] && minorTick < extent[1]) {\n          minorTicksGroup.push(minorTick);\n        }\n        count++;\n      }\n      minorTicks.push(minorTicksGroup);\n    }\n    return minorTicks;\n  };\n  /**\r\n   * @param opt.precision If 'auto', use nice presision.\r\n   * @param opt.pad returns 1.50 but not 1.5 if precision is 2.\r\n   */\n  IntervalScale.prototype.getLabel = function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n    var precision = opt && opt.precision;\n    if (precision == null) {\n      precision = _util_number_js__WEBPACK_IMPORTED_MODULE_0__/* .getPrecision */ .XV(data.value) || 0;\n    } else if (precision === 'auto') {\n      // Should be more precise then tick.\n      precision = this._intervalPrecision;\n    }\n    // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n    var dataNum = roundNumber(data.value, precision, true);\n    return _util_format_js__WEBPACK_IMPORTED_MODULE_3__/* .addCommas */ .ob(dataNum);\n  };\n  /**\r\n   * @param splitNumber By default `5`.\r\n   */\n  IntervalScale.prototype.calcNiceTicks = function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n    if (!isFinite(span)) {\n      return;\n    }\n    // User may set axis min 0 and data are all negative\n    // FIXME If it needs to reverse ?\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n    var result = _helper_js__WEBPACK_IMPORTED_MODULE_2__/* .intervalScaleNiceTicks */ .xh(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  };\n  IntervalScale.prototype.calcNiceExtent = function (opt) {\n    var extent = this._extent;\n    // If extent start and end are same, expand them\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        // Expand extent\n        // Note that extents can be both negative. See #13154\n        var expandSize = Math.abs(extent[0]);\n        // In the fowllowing case\n        //      Axis has been fixed max 100\n        //      Plus data are all 100 and axis extent are [100, 100].\n        // Extend to the both side will cause expanded max is larger than fixed max.\n        // So only expand to the smaller side.\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n    var span = extent[1] - extent[0];\n    // If there are no data and extent are [Infinity, -Infinity]\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);\n    // let extent = this._extent;\n    var interval = this._interval;\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  };\n  IntervalScale.prototype.setNiceExtent = function (min, max) {\n    this._niceExtent = [min, max];\n  };\n  IntervalScale.type = 'interval';\n  return IntervalScale;\n}(_Scale_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A);\n_Scale_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A.registerClass(IntervalScale);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IntervalScale);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ1NjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvSW50ZXJ2YWwuanM/OGYxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi91dGlsL251bWJlci5qcyc7XG5pbXBvcnQgKiBhcyBmb3JtYXRVdGlsIGZyb20gJy4uL3V0aWwvZm9ybWF0LmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuL1NjYWxlLmpzJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuL2hlbHBlci5qcyc7XG52YXIgcm91bmROdW1iZXIgPSBudW1iZXJVdGlsLnJvdW5kO1xudmFyIEludGVydmFsU2NhbGUgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoSW50ZXJ2YWxTY2FsZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gSW50ZXJ2YWxTY2FsZSgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gJ2ludGVydmFsJztcbiAgICAvLyBTdGVwIGlzIGNhbGN1bGF0ZWQgaW4gYWRqdXN0RXh0ZW50LlxuICAgIF90aGlzLl9pbnRlcnZhbCA9IDA7XG4gICAgX3RoaXMuX2ludGVydmFsUHJlY2lzaW9uID0gMjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbiAgSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGUuY29udGFpbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gaGVscGVyLmNvbnRhaW4odmFsLCB0aGlzLl9leHRlbnQpO1xuICB9O1xuICBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIGhlbHBlci5ub3JtYWxpemUodmFsLCB0aGlzLl9leHRlbnQpO1xuICB9O1xuICBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gaGVscGVyLnNjYWxlKHZhbCwgdGhpcy5fZXh0ZW50KTtcbiAgfTtcbiAgSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGUuc2V0RXh0ZW50ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgdGhpc0V4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAvLyBzdGFydCxlbmQgbWF5IGJlIGEgTnVtYmVyIGxpa2UgJzI1Jyxzby4uLlxuICAgIGlmICghaXNOYU4oc3RhcnQpKSB7XG4gICAgICB0aGlzRXh0ZW50WzBdID0gcGFyc2VGbG9hdChzdGFydCk7XG4gICAgfVxuICAgIGlmICghaXNOYU4oZW5kKSkge1xuICAgICAgdGhpc0V4dGVudFsxXSA9IHBhcnNlRmxvYXQoZW5kKTtcbiAgICB9XG4gIH07XG4gIEludGVydmFsU2NhbGUucHJvdG90eXBlLnVuaW9uRXh0ZW50ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICBvdGhlclswXSA8IGV4dGVudFswXSAmJiAoZXh0ZW50WzBdID0gb3RoZXJbMF0pO1xuICAgIG90aGVyWzFdID4gZXh0ZW50WzFdICYmIChleHRlbnRbMV0gPSBvdGhlclsxXSk7XG4gICAgLy8gdW5pb25FeHRlbnQgbWF5IGNhbGxlZCBieSBpdCdzIHN1YiBjbGFzc2VzXG4gICAgdGhpcy5zZXRFeHRlbnQoZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICB9O1xuICBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZS5nZXRJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJ2YWw7XG4gIH07XG4gIEludGVydmFsU2NhbGUucHJvdG90eXBlLnNldEludGVydmFsID0gZnVuY3Rpb24gKGludGVydmFsKSB7XG4gICAgdGhpcy5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICAvLyBEcm9wcGVkIGF1dG8gY2FsY3VsYXRlZCBuaWNlRXh0ZW50IGFuZCB1c2UgdXNlci1zZXQgZXh0ZW50LlxuICAgIC8vIFdlIGFzc3VtZSB1c2VyIHdhbnRzIHRvIHNldCBib3RoIGludGVydmFsLCBtaW4sIG1heCB0byBnZXQgYSBiZXR0ZXIgcmVzdWx0LlxuICAgIHRoaXMuX25pY2VFeHRlbnQgPSB0aGlzLl9leHRlbnQuc2xpY2UoKTtcbiAgICB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbiA9IGhlbHBlci5nZXRJbnRlcnZhbFByZWNpc2lvbihpbnRlcnZhbCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwYXJhbSBleHBhbmRUb05pY2VkRXh0ZW50IFdoZXRoZXIgZXhwYW5kIHRoZSB0aWNrcyB0byBuaWNlZCBleHRlbnQuXHJcbiAgICovXG4gIEludGVydmFsU2NhbGUucHJvdG90eXBlLmdldFRpY2tzID0gZnVuY3Rpb24gKGV4cGFuZFRvTmljZWRFeHRlbnQpIHtcbiAgICB2YXIgaW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbDtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBuaWNlVGlja0V4dGVudCA9IHRoaXMuX25pY2VFeHRlbnQ7XG4gICAgdmFyIGludGVydmFsUHJlY2lzaW9uID0gdGhpcy5faW50ZXJ2YWxQcmVjaXNpb247XG4gICAgdmFyIHRpY2tzID0gW107XG4gICAgLy8gSWYgaW50ZXJ2YWwgaXMgMCwgcmV0dXJuIFtdO1xuICAgIGlmICghaW50ZXJ2YWwpIHtcbiAgICAgIHJldHVybiB0aWNrcztcbiAgICB9XG4gICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiB1c2luZyBkYXRhWm9vbSB0b29sYm94LCB6b29tIGFuZCB6b29tLlxuICAgIHZhciBzYWZlTGltaXQgPSAxMDAwMDtcbiAgICBpZiAoZXh0ZW50WzBdIDwgbmljZVRpY2tFeHRlbnRbMF0pIHtcbiAgICAgIGlmIChleHBhbmRUb05pY2VkRXh0ZW50KSB7XG4gICAgICAgIHRpY2tzLnB1c2goe1xuICAgICAgICAgIHZhbHVlOiByb3VuZE51bWJlcihuaWNlVGlja0V4dGVudFswXSAtIGludGVydmFsLCBpbnRlcnZhbFByZWNpc2lvbilcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWNrcy5wdXNoKHtcbiAgICAgICAgICB2YWx1ZTogZXh0ZW50WzBdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdGljayA9IG5pY2VUaWNrRXh0ZW50WzBdO1xuICAgIHdoaWxlICh0aWNrIDw9IG5pY2VUaWNrRXh0ZW50WzFdKSB7XG4gICAgICB0aWNrcy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IHRpY2tcbiAgICAgIH0pO1xuICAgICAgLy8gQXZvaWQgcm91bmRpbmcgZXJyb3JcbiAgICAgIHRpY2sgPSByb3VuZE51bWJlcih0aWNrICsgaW50ZXJ2YWwsIGludGVydmFsUHJlY2lzaW9uKTtcbiAgICAgIGlmICh0aWNrID09PSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSkge1xuICAgICAgICAvLyBDb25zaWRlciBvdXQgb2Ygc2FmZSBmbG9hdCBwb2ludCwgZS5nLixcbiAgICAgICAgLy8gLTM3MTExMjYuOTkwNzcwNyArIDJlLTEwID09PSAtMzcxMTEyNi45OTA3NzA3XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRpY2tzLmxlbmd0aCA+IHNhZmVMaW1pdCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENvbnNpZGVyIHRoaXMgY2FzZTogdGhlIGxhc3QgaXRlbSBvZiB0aWNrcyBpcyBzbWFsbGVyXG4gICAgLy8gdGhhbiBuaWNlVGlja0V4dGVudFsxXSBhbmQgbmljZVRpY2tFeHRlbnRbMV0gPT09IGV4dGVudFsxXS5cbiAgICB2YXIgbGFzdE5pY2VUaWNrID0gdGlja3MubGVuZ3RoID8gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUgOiBuaWNlVGlja0V4dGVudFsxXTtcbiAgICBpZiAoZXh0ZW50WzFdID4gbGFzdE5pY2VUaWNrKSB7XG4gICAgICBpZiAoZXhwYW5kVG9OaWNlZEV4dGVudCkge1xuICAgICAgICB0aWNrcy5wdXNoKHtcbiAgICAgICAgICB2YWx1ZTogcm91bmROdW1iZXIobGFzdE5pY2VUaWNrICsgaW50ZXJ2YWwsIGludGVydmFsUHJlY2lzaW9uKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpY2tzLnB1c2goe1xuICAgICAgICAgIHZhbHVlOiBleHRlbnRbMV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfTtcbiAgSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGUuZ2V0TWlub3JUaWNrcyA9IGZ1bmN0aW9uIChzcGxpdE51bWJlcikge1xuICAgIHZhciB0aWNrcyA9IHRoaXMuZ2V0VGlja3ModHJ1ZSk7XG4gICAgdmFyIG1pbm9yVGlja3MgPSBbXTtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dFRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHZhciBwcmV2VGljayA9IHRpY2tzW2kgLSAxXTtcbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICB2YXIgbWlub3JUaWNrc0dyb3VwID0gW107XG4gICAgICB2YXIgaW50ZXJ2YWwgPSBuZXh0VGljay52YWx1ZSAtIHByZXZUaWNrLnZhbHVlO1xuICAgICAgdmFyIG1pbm9ySW50ZXJ2YWwgPSBpbnRlcnZhbCAvIHNwbGl0TnVtYmVyO1xuICAgICAgd2hpbGUgKGNvdW50IDwgc3BsaXROdW1iZXIgLSAxKSB7XG4gICAgICAgIHZhciBtaW5vclRpY2sgPSByb3VuZE51bWJlcihwcmV2VGljay52YWx1ZSArIChjb3VudCArIDEpICogbWlub3JJbnRlcnZhbCk7XG4gICAgICAgIC8vIEZvciB0aGUgZmlyc3QgYW5kIGxhc3QgaW50ZXJ2YWwuIFRoZSBjb3VudCBtYXkgYmUgbGVzcyB0aGFuIHNwbGl0TnVtYmVyLlxuICAgICAgICBpZiAobWlub3JUaWNrID4gZXh0ZW50WzBdICYmIG1pbm9yVGljayA8IGV4dGVudFsxXSkge1xuICAgICAgICAgIG1pbm9yVGlja3NHcm91cC5wdXNoKG1pbm9yVGljayk7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICAgIG1pbm9yVGlja3MucHVzaChtaW5vclRpY2tzR3JvdXApO1xuICAgIH1cbiAgICByZXR1cm4gbWlub3JUaWNrcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQHBhcmFtIG9wdC5wcmVjaXNpb24gSWYgJ2F1dG8nLCB1c2UgbmljZSBwcmVzaXNpb24uXHJcbiAgICogQHBhcmFtIG9wdC5wYWQgcmV0dXJucyAxLjUwIGJ1dCBub3QgMS41IGlmIHByZWNpc2lvbiBpcyAyLlxyXG4gICAqL1xuICBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZS5nZXRMYWJlbCA9IGZ1bmN0aW9uIChkYXRhLCBvcHQpIHtcbiAgICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBwcmVjaXNpb24gPSBvcHQgJiYgb3B0LnByZWNpc2lvbjtcbiAgICBpZiAocHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgIHByZWNpc2lvbiA9IG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uKGRhdGEudmFsdWUpIHx8IDA7XG4gICAgfSBlbHNlIGlmIChwcmVjaXNpb24gPT09ICdhdXRvJykge1xuICAgICAgLy8gU2hvdWxkIGJlIG1vcmUgcHJlY2lzZSB0aGVuIHRpY2suXG4gICAgICBwcmVjaXNpb24gPSB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbjtcbiAgICB9XG4gICAgLy8gKDEpIElmIGBwcmVjaXNpb25gIGlzIHNldCwgMTIuMDA1IHNob3VsZCBiZSBkaXNwbGF5IGFzICcxMi4wMDUwMCcuXG4gICAgLy8gKDIpIFVzZSByb3VuZE51bWJlciAodG9GaXhlZCkgdG8gYXZvaWQgc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlICczLjVlLTcnLlxuICAgIHZhciBkYXRhTnVtID0gcm91bmROdW1iZXIoZGF0YS52YWx1ZSwgcHJlY2lzaW9uLCB0cnVlKTtcbiAgICByZXR1cm4gZm9ybWF0VXRpbC5hZGRDb21tYXMoZGF0YU51bSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwYXJhbSBzcGxpdE51bWJlciBCeSBkZWZhdWx0IGA1YC5cclxuICAgKi9cbiAgSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGUuY2FsY05pY2VUaWNrcyA9IGZ1bmN0aW9uIChzcGxpdE51bWJlciwgbWluSW50ZXJ2YWwsIG1heEludGVydmFsKSB7XG4gICAgc3BsaXROdW1iZXIgPSBzcGxpdE51bWJlciB8fCA1O1xuICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgaWYgKCFpc0Zpbml0ZShzcGFuKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBVc2VyIG1heSBzZXQgYXhpcyBtaW4gMCBhbmQgZGF0YSBhcmUgYWxsIG5lZ2F0aXZlXG4gICAgLy8gRklYTUUgSWYgaXQgbmVlZHMgdG8gcmV2ZXJzZSA/XG4gICAgaWYgKHNwYW4gPCAwKSB7XG4gICAgICBzcGFuID0gLXNwYW47XG4gICAgICBleHRlbnQucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gaGVscGVyLmludGVydmFsU2NhbGVOaWNlVGlja3MoZXh0ZW50LCBzcGxpdE51bWJlciwgbWluSW50ZXJ2YWwsIG1heEludGVydmFsKTtcbiAgICB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbiA9IHJlc3VsdC5pbnRlcnZhbFByZWNpc2lvbjtcbiAgICB0aGlzLl9pbnRlcnZhbCA9IHJlc3VsdC5pbnRlcnZhbDtcbiAgICB0aGlzLl9uaWNlRXh0ZW50ID0gcmVzdWx0Lm5pY2VUaWNrRXh0ZW50O1xuICB9O1xuICBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZS5jYWxjTmljZUV4dGVudCA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIC8vIElmIGV4dGVudCBzdGFydCBhbmQgZW5kIGFyZSBzYW1lLCBleHBhbmQgdGhlbVxuICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgaWYgKGV4dGVudFswXSAhPT0gMCkge1xuICAgICAgICAvLyBFeHBhbmQgZXh0ZW50XG4gICAgICAgIC8vIE5vdGUgdGhhdCBleHRlbnRzIGNhbiBiZSBib3RoIG5lZ2F0aXZlLiBTZWUgIzEzMTU0XG4gICAgICAgIHZhciBleHBhbmRTaXplID0gTWF0aC5hYnMoZXh0ZW50WzBdKTtcbiAgICAgICAgLy8gSW4gdGhlIGZvd2xsb3dpbmcgY2FzZVxuICAgICAgICAvLyAgICAgIEF4aXMgaGFzIGJlZW4gZml4ZWQgbWF4IDEwMFxuICAgICAgICAvLyAgICAgIFBsdXMgZGF0YSBhcmUgYWxsIDEwMCBhbmQgYXhpcyBleHRlbnQgYXJlIFsxMDAsIDEwMF0uXG4gICAgICAgIC8vIEV4dGVuZCB0byB0aGUgYm90aCBzaWRlIHdpbGwgY2F1c2UgZXhwYW5kZWQgbWF4IGlzIGxhcmdlciB0aGFuIGZpeGVkIG1heC5cbiAgICAgICAgLy8gU28gb25seSBleHBhbmQgdG8gdGhlIHNtYWxsZXIgc2lkZS5cbiAgICAgICAgaWYgKCFvcHQuZml4TWF4KSB7XG4gICAgICAgICAgZXh0ZW50WzFdICs9IGV4cGFuZFNpemUgLyAyO1xuICAgICAgICAgIGV4dGVudFswXSAtPSBleHBhbmRTaXplIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRlbnRbMF0gLT0gZXhwYW5kU2l6ZSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dGVudFsxXSA9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyBkYXRhIGFuZCBleHRlbnQgYXJlIFtJbmZpbml0eSwgLUluZmluaXR5XVxuICAgIGlmICghaXNGaW5pdGUoc3BhbikpIHtcbiAgICAgIGV4dGVudFswXSA9IDA7XG4gICAgICBleHRlbnRbMV0gPSAxO1xuICAgIH1cbiAgICB0aGlzLmNhbGNOaWNlVGlja3Mob3B0LnNwbGl0TnVtYmVyLCBvcHQubWluSW50ZXJ2YWwsIG9wdC5tYXhJbnRlcnZhbCk7XG4gICAgLy8gbGV0IGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgaW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbDtcbiAgICBpZiAoIW9wdC5maXhNaW4pIHtcbiAgICAgIGV4dGVudFswXSA9IHJvdW5kTnVtYmVyKE1hdGguZmxvb3IoZXh0ZW50WzBdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBpZiAoIW9wdC5maXhNYXgpIHtcbiAgICAgIGV4dGVudFsxXSA9IHJvdW5kTnVtYmVyKE1hdGguY2VpbChleHRlbnRbMV0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCk7XG4gICAgfVxuICB9O1xuICBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZS5zZXROaWNlRXh0ZW50ID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgdGhpcy5fbmljZUV4dGVudCA9IFttaW4sIG1heF07XG4gIH07XG4gIEludGVydmFsU2NhbGUudHlwZSA9ICdpbnRlcnZhbCc7XG4gIHJldHVybiBJbnRlcnZhbFNjYWxlO1xufShTY2FsZSk7XG5TY2FsZS5yZWdpc3RlckNsYXNzKEludGVydmFsU2NhbGUpO1xuZXhwb3J0IGRlZmF1bHQgSW50ZXJ2YWxTY2FsZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///74562\n")},78587:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ dataFilter)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nfunction dataFilter(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: \'legend\'\n      });\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx);\n        // If in any legend component the status is not selected.\n        for (var i = 0; i < legendModels.length; i++) {\n          // @ts-ignore FIXME: LegendModel\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n        return true;\n      });\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg1ODcuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcm9jZXNzb3IvZGF0YUZpbHRlci5qcz82YjZkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGF0YUZpbHRlcihzZXJpZXNUeXBlKSB7XG4gIHJldHVybiB7XG4gICAgc2VyaWVzVHlwZTogc2VyaWVzVHlwZSxcbiAgICByZXNldDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsKSB7XG4gICAgICB2YXIgbGVnZW5kTW9kZWxzID0gZWNNb2RlbC5maW5kQ29tcG9uZW50cyh7XG4gICAgICAgIG1haW5UeXBlOiAnbGVnZW5kJ1xuICAgICAgfSk7XG4gICAgICBpZiAoIWxlZ2VuZE1vZGVscyB8fCAhbGVnZW5kTW9kZWxzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgIGRhdGEuZmlsdGVyU2VsZihmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGlkeCk7XG4gICAgICAgIC8vIElmIGluIGFueSBsZWdlbmQgY29tcG9uZW50IHRoZSBzdGF0dXMgaXMgbm90IHNlbGVjdGVkLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZE1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU6IExlZ2VuZE1vZGVsXG4gICAgICAgICAgaWYgKCFsZWdlbmRNb2RlbHNbaV0uaXNTZWxlY3RlZChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///78587\n')},82796:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ negativeDataFilter)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction negativeDataFilter(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        // handle negative value condition\n        var valueDim = data.mapDimension(\'value\');\n        var curValue = data.get(valueDim, idx);\n        if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(curValue) && !isNaN(curValue) && curValue < 0) {\n          return false;\n        }\n        return true;\n      });\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI3OTYuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Byb2Nlc3Nvci9uZWdhdGl2ZURhdGFGaWx0ZXIuanM/YTVjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGlzTnVtYmVyIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5lZ2F0aXZlRGF0YUZpbHRlcihzZXJpZXNUeXBlKSB7XG4gIHJldHVybiB7XG4gICAgc2VyaWVzVHlwZTogc2VyaWVzVHlwZSxcbiAgICByZXNldDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsKSB7XG4gICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgIGRhdGEuZmlsdGVyU2VsZihmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSB2YWx1ZSBjb25kaXRpb25cbiAgICAgICAgdmFyIHZhbHVlRGltID0gZGF0YS5tYXBEaW1lbnNpb24oJ3ZhbHVlJyk7XG4gICAgICAgIHZhciBjdXJWYWx1ZSA9IGRhdGEuZ2V0KHZhbHVlRGltLCBpZHgpO1xuICAgICAgICBpZiAoaXNOdW1iZXIoY3VyVmFsdWUpICYmICFpc05hTihjdXJWYWx1ZSkgJiYgY3VyVmFsdWUgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///82796\n')},83806:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ install)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_svg_Painter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18409);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction install(registers) {\n  registers.registerPainter(\'svg\', zrender_lib_svg_Painter_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODM4MDYuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvcmVuZGVyZXIvaW5zdGFsbFNWR1JlbmRlcmVyLmpzP2ExOTYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgU1ZHUGFpbnRlciBmcm9tICd6cmVuZGVyL2xpYi9zdmcvUGFpbnRlci5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUGFpbnRlcignc3ZnJywgU1ZHUGFpbnRlcik7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///83806\n')},89952:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ install)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_canvas_Painter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30536);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction install(registers) {\n  registers.registerPainter(\'canvas\', zrender_lib_canvas_Painter_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk5NTIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvcmVuZGVyZXIvaW5zdGFsbENhbnZhc1JlbmRlcmVyLmpzPzM3OTAiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgQ2FudmFzUGFpbnRlciBmcm9tICd6cmVuZGVyL2xpYi9jYW52YXMvUGFpbnRlci5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUGFpbnRlcignY2FudmFzJywgQ2FudmFzUGFpbnRlcik7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///89952\n')},90106:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   X: () => (/* binding */ getCoordSysInfoBySeries)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * Helper for model references.\r\n * There are many manners to refer axis/coordSys.\r\n */\n// TODO\n// merge relevant logic to this file?\n// check: \"modelHelper\" of tooltip and \"BrushTargetManager\".\n\n\n/**\r\n * @class\r\n * For example:\r\n * {\r\n *     coordSysName: 'cartesian2d',\r\n *     coordSysDims: ['x', 'y', ...],\r\n *     axisMap: HashMap({\r\n *         x: xAxisModel,\r\n *         y: yAxisModel\r\n *     }),\r\n *     categoryAxisMap: HashMap({\r\n *         x: xAxisModel,\r\n *         y: undefined\r\n *     }),\r\n *     // The index of the first category axis in `coordSysDims`.\r\n *     // `null/undefined` means no category axis exists.\r\n *     firstCategoryDimIndex: 1,\r\n *     // To replace user specified encode.\r\n * }\r\n */\nvar CoordSysInfo = /** @class */function () {\n  function CoordSysInfo(coordSysName) {\n    this.coordSysDims = [];\n    this.axisMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();\n    this.categoryAxisMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();\n    this.coordSysName = coordSysName;\n  }\n  return CoordSysInfo;\n}();\nfunction getCoordSysInfoBySeries(seriesModel) {\n  var coordSysName = seriesModel.get('coordinateSystem');\n  var result = new CoordSysInfo(coordSysName);\n  var fetch = fetchers[coordSysName];\n  if (fetch) {\n    fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);\n    return result;\n  }\n}\nvar fetchers = {\n  cartesian2d: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var xAxisModel = seriesModel.getReferringComponents('xAxis', _util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .SINGLE_REFERRING */ .US).models[0];\n    var yAxisModel = seriesModel.getReferringComponents('yAxis', _util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .SINGLE_REFERRING */ .US).models[0];\n    if (false) {}\n    result.coordSysDims = ['x', 'y'];\n    axisMap.set('x', xAxisModel);\n    axisMap.set('y', yAxisModel);\n    if (isCategory(xAxisModel)) {\n      categoryAxisMap.set('x', xAxisModel);\n      result.firstCategoryDimIndex = 0;\n    }\n    if (isCategory(yAxisModel)) {\n      categoryAxisMap.set('y', yAxisModel);\n      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);\n    }\n  },\n  singleAxis: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var singleAxisModel = seriesModel.getReferringComponents('singleAxis', _util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .SINGLE_REFERRING */ .US).models[0];\n    if (false) {}\n    result.coordSysDims = ['single'];\n    axisMap.set('single', singleAxisModel);\n    if (isCategory(singleAxisModel)) {\n      categoryAxisMap.set('single', singleAxisModel);\n      result.firstCategoryDimIndex = 0;\n    }\n  },\n  polar: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var polarModel = seriesModel.getReferringComponents('polar', _util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .SINGLE_REFERRING */ .US).models[0];\n    var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n    var angleAxisModel = polarModel.findAxisModel('angleAxis');\n    if (false) {}\n    result.coordSysDims = ['radius', 'angle'];\n    axisMap.set('radius', radiusAxisModel);\n    axisMap.set('angle', angleAxisModel);\n    if (isCategory(radiusAxisModel)) {\n      categoryAxisMap.set('radius', radiusAxisModel);\n      result.firstCategoryDimIndex = 0;\n    }\n    if (isCategory(angleAxisModel)) {\n      categoryAxisMap.set('angle', angleAxisModel);\n      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);\n    }\n  },\n  geo: function (seriesModel, result, axisMap, categoryAxisMap) {\n    result.coordSysDims = ['lng', 'lat'];\n  },\n  parallel: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var ecModel = seriesModel.ecModel;\n    var parallelModel = ecModel.getComponent('parallel', seriesModel.get('parallelIndex'));\n    var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(parallelModel.parallelAxisIndex, function (axisIndex, index) {\n      var axisModel = ecModel.getComponent('parallelAxis', axisIndex);\n      var axisDim = coordSysDims[index];\n      axisMap.set(axisDim, axisModel);\n      if (isCategory(axisModel)) {\n        categoryAxisMap.set(axisDim, axisModel);\n        if (result.firstCategoryDimIndex == null) {\n          result.firstCategoryDimIndex = index;\n        }\n      }\n    });\n  }\n};\nfunction isCategory(axisModel) {\n  return axisModel.get('type') === 'category';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAxMDYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9yZWZlckhlbHBlci5qcz82MWVlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLyoqXHJcbiAqIEhlbHBlciBmb3IgbW9kZWwgcmVmZXJlbmNlcy5cclxuICogVGhlcmUgYXJlIG1hbnkgbWFubmVycyB0byByZWZlciBheGlzL2Nvb3JkU3lzLlxyXG4gKi9cbi8vIFRPRE9cbi8vIG1lcmdlIHJlbGV2YW50IGxvZ2ljIHRvIHRoaXMgZmlsZT9cbi8vIGNoZWNrOiBcIm1vZGVsSGVscGVyXCIgb2YgdG9vbHRpcCBhbmQgXCJCcnVzaFRhcmdldE1hbmFnZXJcIi5cbmltcG9ydCB7IGNyZWF0ZUhhc2hNYXAsIHJldHJpZXZlLCBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IFNJTkdMRV9SRUZFUlJJTkcgfSBmcm9tICcuLi91dGlsL21vZGVsLmpzJztcbi8qKlxyXG4gKiBAY2xhc3NcclxuICogRm9yIGV4YW1wbGU6XHJcbiAqIHtcclxuICogICAgIGNvb3JkU3lzTmFtZTogJ2NhcnRlc2lhbjJkJyxcclxuICogICAgIGNvb3JkU3lzRGltczogWyd4JywgJ3knLCAuLi5dLFxyXG4gKiAgICAgYXhpc01hcDogSGFzaE1hcCh7XHJcbiAqICAgICAgICAgeDogeEF4aXNNb2RlbCxcclxuICogICAgICAgICB5OiB5QXhpc01vZGVsXHJcbiAqICAgICB9KSxcclxuICogICAgIGNhdGVnb3J5QXhpc01hcDogSGFzaE1hcCh7XHJcbiAqICAgICAgICAgeDogeEF4aXNNb2RlbCxcclxuICogICAgICAgICB5OiB1bmRlZmluZWRcclxuICogICAgIH0pLFxyXG4gKiAgICAgLy8gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjYXRlZ29yeSBheGlzIGluIGBjb29yZFN5c0RpbXNgLlxyXG4gKiAgICAgLy8gYG51bGwvdW5kZWZpbmVkYCBtZWFucyBubyBjYXRlZ29yeSBheGlzIGV4aXN0cy5cclxuICogICAgIGZpcnN0Q2F0ZWdvcnlEaW1JbmRleDogMSxcclxuICogICAgIC8vIFRvIHJlcGxhY2UgdXNlciBzcGVjaWZpZWQgZW5jb2RlLlxyXG4gKiB9XHJcbiAqL1xudmFyIENvb3JkU3lzSW5mbyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvb3JkU3lzSW5mbyhjb29yZFN5c05hbWUpIHtcbiAgICB0aGlzLmNvb3JkU3lzRGltcyA9IFtdO1xuICAgIHRoaXMuYXhpc01hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgICB0aGlzLmNhdGVnb3J5QXhpc01hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgICB0aGlzLmNvb3JkU3lzTmFtZSA9IGNvb3JkU3lzTmFtZTtcbiAgfVxuICByZXR1cm4gQ29vcmRTeXNJbmZvO1xufSgpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvb3JkU3lzSW5mb0J5U2VyaWVzKHNlcmllc01vZGVsKSB7XG4gIHZhciBjb29yZFN5c05hbWUgPSBzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBDb29yZFN5c0luZm8oY29vcmRTeXNOYW1lKTtcbiAgdmFyIGZldGNoID0gZmV0Y2hlcnNbY29vcmRTeXNOYW1lXTtcbiAgaWYgKGZldGNoKSB7XG4gICAgZmV0Y2goc2VyaWVzTW9kZWwsIHJlc3VsdCwgcmVzdWx0LmF4aXNNYXAsIHJlc3VsdC5jYXRlZ29yeUF4aXNNYXApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbnZhciBmZXRjaGVycyA9IHtcbiAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgcmVzdWx0LCBheGlzTWFwLCBjYXRlZ29yeUF4aXNNYXApIHtcbiAgICB2YXIgeEF4aXNNb2RlbCA9IHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3hBeGlzJywgU0lOR0xFX1JFRkVSUklORykubW9kZWxzWzBdO1xuICAgIHZhciB5QXhpc01vZGVsID0gc2VyaWVzTW9kZWwuZ2V0UmVmZXJyaW5nQ29tcG9uZW50cygneUF4aXMnLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICgheEF4aXNNb2RlbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3hBeGlzIFwiJyArIHJldHJpZXZlKHNlcmllc01vZGVsLmdldCgneEF4aXNJbmRleCcpLCBzZXJpZXNNb2RlbC5nZXQoJ3hBeGlzSWQnKSwgMCkgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXlBeGlzTW9kZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5QXhpcyBcIicgKyByZXRyaWV2ZShzZXJpZXNNb2RlbC5nZXQoJ3hBeGlzSW5kZXgnKSwgc2VyaWVzTW9kZWwuZ2V0KCd5QXhpc0lkJyksIDApICsgJ1wiIG5vdCBmb3VuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuY29vcmRTeXNEaW1zID0gWyd4JywgJ3knXTtcbiAgICBheGlzTWFwLnNldCgneCcsIHhBeGlzTW9kZWwpO1xuICAgIGF4aXNNYXAuc2V0KCd5JywgeUF4aXNNb2RlbCk7XG4gICAgaWYgKGlzQ2F0ZWdvcnkoeEF4aXNNb2RlbCkpIHtcbiAgICAgIGNhdGVnb3J5QXhpc01hcC5zZXQoJ3gnLCB4QXhpc01vZGVsKTtcbiAgICAgIHJlc3VsdC5maXJzdENhdGVnb3J5RGltSW5kZXggPSAwO1xuICAgIH1cbiAgICBpZiAoaXNDYXRlZ29yeSh5QXhpc01vZGVsKSkge1xuICAgICAgY2F0ZWdvcnlBeGlzTWFwLnNldCgneScsIHlBeGlzTW9kZWwpO1xuICAgICAgcmVzdWx0LmZpcnN0Q2F0ZWdvcnlEaW1JbmRleCA9PSBudWxsICYmIChyZXN1bHQuZmlyc3RDYXRlZ29yeURpbUluZGV4ID0gMSk7XG4gICAgfVxuICB9LFxuICBzaW5nbGVBeGlzOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIHJlc3VsdCwgYXhpc01hcCwgY2F0ZWdvcnlBeGlzTWFwKSB7XG4gICAgdmFyIHNpbmdsZUF4aXNNb2RlbCA9IHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3NpbmdsZUF4aXMnLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghc2luZ2xlQXhpc01vZGVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2luZ2xlQXhpcyBzaG91bGQgYmUgc3BlY2lmaWVkLicpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuY29vcmRTeXNEaW1zID0gWydzaW5nbGUnXTtcbiAgICBheGlzTWFwLnNldCgnc2luZ2xlJywgc2luZ2xlQXhpc01vZGVsKTtcbiAgICBpZiAoaXNDYXRlZ29yeShzaW5nbGVBeGlzTW9kZWwpKSB7XG4gICAgICBjYXRlZ29yeUF4aXNNYXAuc2V0KCdzaW5nbGUnLCBzaW5nbGVBeGlzTW9kZWwpO1xuICAgICAgcmVzdWx0LmZpcnN0Q2F0ZWdvcnlEaW1JbmRleCA9IDA7XG4gICAgfVxuICB9LFxuICBwb2xhcjogZnVuY3Rpb24gKHNlcmllc01vZGVsLCByZXN1bHQsIGF4aXNNYXAsIGNhdGVnb3J5QXhpc01hcCkge1xuICAgIHZhciBwb2xhck1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0UmVmZXJyaW5nQ29tcG9uZW50cygncG9sYXInLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG4gICAgdmFyIHJhZGl1c0F4aXNNb2RlbCA9IHBvbGFyTW9kZWwuZmluZEF4aXNNb2RlbCgncmFkaXVzQXhpcycpO1xuICAgIHZhciBhbmdsZUF4aXNNb2RlbCA9IHBvbGFyTW9kZWwuZmluZEF4aXNNb2RlbCgnYW5nbGVBeGlzJyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYW5nbGVBeGlzTW9kZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbmdsZUF4aXMgb3B0aW9uIG5vdCBmb3VuZCcpO1xuICAgICAgfVxuICAgICAgaWYgKCFyYWRpdXNBeGlzTW9kZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpdXNBeGlzIG9wdGlvbiBub3QgZm91bmQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LmNvb3JkU3lzRGltcyA9IFsncmFkaXVzJywgJ2FuZ2xlJ107XG4gICAgYXhpc01hcC5zZXQoJ3JhZGl1cycsIHJhZGl1c0F4aXNNb2RlbCk7XG4gICAgYXhpc01hcC5zZXQoJ2FuZ2xlJywgYW5nbGVBeGlzTW9kZWwpO1xuICAgIGlmIChpc0NhdGVnb3J5KHJhZGl1c0F4aXNNb2RlbCkpIHtcbiAgICAgIGNhdGVnb3J5QXhpc01hcC5zZXQoJ3JhZGl1cycsIHJhZGl1c0F4aXNNb2RlbCk7XG4gICAgICByZXN1bHQuZmlyc3RDYXRlZ29yeURpbUluZGV4ID0gMDtcbiAgICB9XG4gICAgaWYgKGlzQ2F0ZWdvcnkoYW5nbGVBeGlzTW9kZWwpKSB7XG4gICAgICBjYXRlZ29yeUF4aXNNYXAuc2V0KCdhbmdsZScsIGFuZ2xlQXhpc01vZGVsKTtcbiAgICAgIHJlc3VsdC5maXJzdENhdGVnb3J5RGltSW5kZXggPT0gbnVsbCAmJiAocmVzdWx0LmZpcnN0Q2F0ZWdvcnlEaW1JbmRleCA9IDEpO1xuICAgIH1cbiAgfSxcbiAgZ2VvOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIHJlc3VsdCwgYXhpc01hcCwgY2F0ZWdvcnlBeGlzTWFwKSB7XG4gICAgcmVzdWx0LmNvb3JkU3lzRGltcyA9IFsnbG5nJywgJ2xhdCddO1xuICB9LFxuICBwYXJhbGxlbDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCByZXN1bHQsIGF4aXNNYXAsIGNhdGVnb3J5QXhpc01hcCkge1xuICAgIHZhciBlY01vZGVsID0gc2VyaWVzTW9kZWwuZWNNb2RlbDtcbiAgICB2YXIgcGFyYWxsZWxNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdwYXJhbGxlbCcsIHNlcmllc01vZGVsLmdldCgncGFyYWxsZWxJbmRleCcpKTtcbiAgICB2YXIgY29vcmRTeXNEaW1zID0gcmVzdWx0LmNvb3JkU3lzRGltcyA9IHBhcmFsbGVsTW9kZWwuZGltZW5zaW9ucy5zbGljZSgpO1xuICAgIGVhY2gocGFyYWxsZWxNb2RlbC5wYXJhbGxlbEF4aXNJbmRleCwgZnVuY3Rpb24gKGF4aXNJbmRleCwgaW5kZXgpIHtcbiAgICAgIHZhciBheGlzTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgncGFyYWxsZWxBeGlzJywgYXhpc0luZGV4KTtcbiAgICAgIHZhciBheGlzRGltID0gY29vcmRTeXNEaW1zW2luZGV4XTtcbiAgICAgIGF4aXNNYXAuc2V0KGF4aXNEaW0sIGF4aXNNb2RlbCk7XG4gICAgICBpZiAoaXNDYXRlZ29yeShheGlzTW9kZWwpKSB7XG4gICAgICAgIGNhdGVnb3J5QXhpc01hcC5zZXQoYXhpc0RpbSwgYXhpc01vZGVsKTtcbiAgICAgICAgaWYgKHJlc3VsdC5maXJzdENhdGVnb3J5RGltSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdC5maXJzdENhdGVnb3J5RGltSW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gaXNDYXRlZ29yeShheGlzTW9kZWwpIHtcbiAgcmV0dXJuIGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSA9PT0gJ2NhdGVnb3J5Jztcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///90106\n")},96501:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   X: () => (/* binding */ PaletteMixin),\n/* harmony export */   x: () => (/* binding */ getDecalFromPalette)\n/* harmony export */ });\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar innerColor = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nvar innerDecal = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nvar PaletteMixin = /** @class */function () {\n  function PaletteMixin() {}\n  PaletteMixin.prototype.getColorFromPalette = function (name, scope, requestNum) {\n    var defaultPalette = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .normalizeToArray */ .qB)(this.get('color', true));\n    var layeredPalette = this.get('colorLayer', true);\n    return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum);\n  };\n  PaletteMixin.prototype.clearColorPalette = function () {\n    clearPalette(this, innerColor);\n  };\n  return PaletteMixin;\n}();\nfunction getDecalFromPalette(ecModel, name, scope, requestNum) {\n  var defaultDecals = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .normalizeToArray */ .qB)(ecModel.get(['aria', 'decal', 'decals']));\n  return getFromPalette(ecModel, innerDecal, defaultDecals, null, name, scope, requestNum);\n}\nfunction getNearestPalette(palettes, requestColorNum) {\n  var paletteNum = palettes.length;\n  // TODO palettes must be in order\n  for (var i = 0; i < paletteNum; i++) {\n    if (palettes[i].length > requestColorNum) {\n      return palettes[i];\n    }\n  }\n  return palettes[paletteNum - 1];\n}\n/**\r\n * @param name MUST NOT be null/undefined. Otherwise call this function\r\n *             twise with the same parameters will get different result.\r\n * @param scope default this.\r\n * @return Can be null/undefined\r\n */\nfunction getFromPalette(that, inner, defaultPalette, layeredPalette, name, scope, requestNum) {\n  scope = scope || that;\n  var scopeFields = inner(scope);\n  var paletteIdx = scopeFields.paletteIdx || 0;\n  var paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};\n  // Use `hasOwnProperty` to avoid conflict with Object.prototype.\n  if (paletteNameMap.hasOwnProperty(name)) {\n    return paletteNameMap[name];\n  }\n  var palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);\n  // In case can't find in layered color palette.\n  palette = palette || defaultPalette;\n  if (!palette || !palette.length) {\n    return;\n  }\n  var pickedPaletteItem = palette[paletteIdx];\n  if (name) {\n    paletteNameMap[name] = pickedPaletteItem;\n  }\n  scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;\n  return pickedPaletteItem;\n}\nfunction clearPalette(that, inner) {\n  inner(that).paletteIdx = 0;\n  inner(that).paletteNameMap = {};\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY1MDEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL3BhbGV0dGUuanM/NWYwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IG1ha2VJbm5lciwgbm9ybWFsaXplVG9BcnJheSB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xudmFyIGlubmVyQ29sb3IgPSBtYWtlSW5uZXIoKTtcbnZhciBpbm5lckRlY2FsID0gbWFrZUlubmVyKCk7XG52YXIgUGFsZXR0ZU1peGluID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGFsZXR0ZU1peGluKCkge31cbiAgUGFsZXR0ZU1peGluLnByb3RvdHlwZS5nZXRDb2xvckZyb21QYWxldHRlID0gZnVuY3Rpb24gKG5hbWUsIHNjb3BlLCByZXF1ZXN0TnVtKSB7XG4gICAgdmFyIGRlZmF1bHRQYWxldHRlID0gbm9ybWFsaXplVG9BcnJheSh0aGlzLmdldCgnY29sb3InLCB0cnVlKSk7XG4gICAgdmFyIGxheWVyZWRQYWxldHRlID0gdGhpcy5nZXQoJ2NvbG9yTGF5ZXInLCB0cnVlKTtcbiAgICByZXR1cm4gZ2V0RnJvbVBhbGV0dGUodGhpcywgaW5uZXJDb2xvciwgZGVmYXVsdFBhbGV0dGUsIGxheWVyZWRQYWxldHRlLCBuYW1lLCBzY29wZSwgcmVxdWVzdE51bSk7XG4gIH07XG4gIFBhbGV0dGVNaXhpbi5wcm90b3R5cGUuY2xlYXJDb2xvclBhbGV0dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJQYWxldHRlKHRoaXMsIGlubmVyQ29sb3IpO1xuICB9O1xuICByZXR1cm4gUGFsZXR0ZU1peGluO1xufSgpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlY2FsRnJvbVBhbGV0dGUoZWNNb2RlbCwgbmFtZSwgc2NvcGUsIHJlcXVlc3ROdW0pIHtcbiAgdmFyIGRlZmF1bHREZWNhbHMgPSBub3JtYWxpemVUb0FycmF5KGVjTW9kZWwuZ2V0KFsnYXJpYScsICdkZWNhbCcsICdkZWNhbHMnXSkpO1xuICByZXR1cm4gZ2V0RnJvbVBhbGV0dGUoZWNNb2RlbCwgaW5uZXJEZWNhbCwgZGVmYXVsdERlY2FscywgbnVsbCwgbmFtZSwgc2NvcGUsIHJlcXVlc3ROdW0pO1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdFBhbGV0dGUocGFsZXR0ZXMsIHJlcXVlc3RDb2xvck51bSkge1xuICB2YXIgcGFsZXR0ZU51bSA9IHBhbGV0dGVzLmxlbmd0aDtcbiAgLy8gVE9ETyBwYWxldHRlcyBtdXN0IGJlIGluIG9yZGVyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFsZXR0ZU51bTsgaSsrKSB7XG4gICAgaWYgKHBhbGV0dGVzW2ldLmxlbmd0aCA+IHJlcXVlc3RDb2xvck51bSkge1xuICAgICAgcmV0dXJuIHBhbGV0dGVzW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFsZXR0ZXNbcGFsZXR0ZU51bSAtIDFdO1xufVxuLyoqXHJcbiAqIEBwYXJhbSBuYW1lIE1VU1QgTk9UIGJlIG51bGwvdW5kZWZpbmVkLiBPdGhlcndpc2UgY2FsbCB0aGlzIGZ1bmN0aW9uXHJcbiAqICAgICAgICAgICAgIHR3aXNlIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycyB3aWxsIGdldCBkaWZmZXJlbnQgcmVzdWx0LlxyXG4gKiBAcGFyYW0gc2NvcGUgZGVmYXVsdCB0aGlzLlxyXG4gKiBAcmV0dXJuIENhbiBiZSBudWxsL3VuZGVmaW5lZFxyXG4gKi9cbmZ1bmN0aW9uIGdldEZyb21QYWxldHRlKHRoYXQsIGlubmVyLCBkZWZhdWx0UGFsZXR0ZSwgbGF5ZXJlZFBhbGV0dGUsIG5hbWUsIHNjb3BlLCByZXF1ZXN0TnVtKSB7XG4gIHNjb3BlID0gc2NvcGUgfHwgdGhhdDtcbiAgdmFyIHNjb3BlRmllbGRzID0gaW5uZXIoc2NvcGUpO1xuICB2YXIgcGFsZXR0ZUlkeCA9IHNjb3BlRmllbGRzLnBhbGV0dGVJZHggfHwgMDtcbiAgdmFyIHBhbGV0dGVOYW1lTWFwID0gc2NvcGVGaWVsZHMucGFsZXR0ZU5hbWVNYXAgPSBzY29wZUZpZWxkcy5wYWxldHRlTmFtZU1hcCB8fCB7fTtcbiAgLy8gVXNlIGBoYXNPd25Qcm9wZXJ0eWAgdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlLlxuICBpZiAocGFsZXR0ZU5hbWVNYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gcGFsZXR0ZU5hbWVNYXBbbmFtZV07XG4gIH1cbiAgdmFyIHBhbGV0dGUgPSByZXF1ZXN0TnVtID09IG51bGwgfHwgIWxheWVyZWRQYWxldHRlID8gZGVmYXVsdFBhbGV0dGUgOiBnZXROZWFyZXN0UGFsZXR0ZShsYXllcmVkUGFsZXR0ZSwgcmVxdWVzdE51bSk7XG4gIC8vIEluIGNhc2UgY2FuJ3QgZmluZCBpbiBsYXllcmVkIGNvbG9yIHBhbGV0dGUuXG4gIHBhbGV0dGUgPSBwYWxldHRlIHx8IGRlZmF1bHRQYWxldHRlO1xuICBpZiAoIXBhbGV0dGUgfHwgIXBhbGV0dGUubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwaWNrZWRQYWxldHRlSXRlbSA9IHBhbGV0dGVbcGFsZXR0ZUlkeF07XG4gIGlmIChuYW1lKSB7XG4gICAgcGFsZXR0ZU5hbWVNYXBbbmFtZV0gPSBwaWNrZWRQYWxldHRlSXRlbTtcbiAgfVxuICBzY29wZUZpZWxkcy5wYWxldHRlSWR4ID0gKHBhbGV0dGVJZHggKyAxKSAlIHBhbGV0dGUubGVuZ3RoO1xuICByZXR1cm4gcGlja2VkUGFsZXR0ZUl0ZW07XG59XG5mdW5jdGlvbiBjbGVhclBhbGV0dGUodGhhdCwgaW5uZXIpIHtcbiAgaW5uZXIodGhhdCkucGFsZXR0ZUlkeCA9IDA7XG4gIGlubmVyKHRoYXQpLnBhbGV0dGVOYW1lTWFwID0ge307XG59XG5leHBvcnQgeyBQYWxldHRlTWl4aW4gfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///96501\n")}}]);