"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[6482],{10128:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _util_symbol_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62103);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5638);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(43870);\n/* harmony import */ var _util_innerStore_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(69622);\n/* harmony import */ var _util_states_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(34833);\n/* harmony import */ var _labelHelper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(44532);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(98026);\n/* harmony import */ var _label_labelStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89632);\n/* harmony import */ var zrender_lib_graphic_Image_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(90540);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\nvar Symbol = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(Symbol, _super);\n  function Symbol(data, idx, seriesScope, opts) {\n    var _this = _super.call(this) || this;\n    _this.updateData(data, idx, seriesScope, opts);\n    return _this;\n  }\n  Symbol.prototype._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {\n    // Remove paths created before\n    this.removeAll();\n    // let symbolPath = createSymbol(\n    //     symbolType, -0.5, -0.5, 1, 1, color\n    // );\n    // If width/height are set too small (e.g., set to 1) on ios10\n    // and macOS Sierra, a circle stroke become a rect, no matter what\n    // the scale is set. So we set width/height as 2. See #4150.\n    var symbolPath = (0,_util_symbol_js__WEBPACK_IMPORTED_MODULE_1__/* .createSymbol */ .v5)(symbolType, -1, -1, 2, 2, null, keepAspect);\n    symbolPath.attr({\n      z2: 100,\n      culling: true,\n      scaleX: symbolSize[0] / 2,\n      scaleY: symbolSize[1] / 2\n    });\n    // Rewrite drift method\n    symbolPath.drift = driftSymbol;\n    this._symbolType = symbolType;\n    this.add(symbolPath);\n  };\n  /**\r\n   * Stop animation\r\n   * @param {boolean} toLastFrame\r\n   */\n  Symbol.prototype.stopSymbolAnimation = function (toLastFrame) {\n    this.childAt(0).stopAnimation(null, toLastFrame);\n  };\n  Symbol.prototype.getSymbolType = function () {\n    return this._symbolType;\n  };\n  /**\r\n   * FIXME:\r\n   * Caution: This method breaks the encapsulation of this module,\r\n   * but it indeed brings convenience. So do not use the method\r\n   * unless you detailedly know all the implements of `Symbol`,\r\n   * especially animation.\r\n   *\r\n   * Get symbol path element.\r\n   */\n  Symbol.prototype.getSymbolPath = function () {\n    return this.childAt(0);\n  };\n  /**\r\n   * Highlight symbol\r\n   */\n  Symbol.prototype.highlight = function () {\n    (0,_util_states_js__WEBPACK_IMPORTED_MODULE_2__/* .enterEmphasis */ .HY)(this.childAt(0));\n  };\n  /**\r\n   * Downplay symbol\r\n   */\n  Symbol.prototype.downplay = function () {\n    (0,_util_states_js__WEBPACK_IMPORTED_MODULE_2__/* .leaveEmphasis */ .SD)(this.childAt(0));\n  };\n  /**\r\n   * @param {number} zlevel\r\n   * @param {number} z\r\n   */\n  Symbol.prototype.setZ = function (zlevel, z) {\n    var symbolPath = this.childAt(0);\n    symbolPath.zlevel = zlevel;\n    symbolPath.z = z;\n  };\n  Symbol.prototype.setDraggable = function (draggable, hasCursorOption) {\n    var symbolPath = this.childAt(0);\n    symbolPath.draggable = draggable;\n    symbolPath.cursor = !hasCursorOption && draggable ? 'move' : symbolPath.cursor;\n  };\n  /**\r\n   * Update symbol properties\r\n   */\n  Symbol.prototype.updateData = function (data, idx, seriesScope, opts) {\n    this.silent = false;\n    var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n    var seriesModel = data.hostModel;\n    var symbolSize = Symbol.getSymbolSize(data, idx);\n    var isInit = symbolType !== this._symbolType;\n    var disableAnimation = opts && opts.disableAnimation;\n    if (isInit) {\n      var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');\n      this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);\n    } else {\n      var symbolPath = this.childAt(0);\n      symbolPath.silent = false;\n      var target = {\n        scaleX: symbolSize[0] / 2,\n        scaleY: symbolSize[1] / 2\n      };\n      disableAnimation ? symbolPath.attr(target) : _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .updateProps */ .oi(symbolPath, target, seriesModel, idx);\n      (0,_util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .saveOldStyle */ .ap)(symbolPath);\n    }\n    this._updateCommon(data, idx, symbolSize, seriesScope, opts);\n    if (isInit) {\n      var symbolPath = this.childAt(0);\n      if (!disableAnimation) {\n        var target = {\n          scaleX: this._sizeX,\n          scaleY: this._sizeY,\n          style: {\n            // Always fadeIn. Because it has fadeOut animation when symbol is removed..\n            opacity: symbolPath.style.opacity\n          }\n        };\n        symbolPath.scaleX = symbolPath.scaleY = 0;\n        symbolPath.style.opacity = 0;\n        _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .initProps */ .LW(symbolPath, target, seriesModel, idx);\n      }\n    }\n    if (disableAnimation) {\n      // Must stop leave transition manually if don't call initProps or updateProps.\n      this.childAt(0).stopAnimation('leave');\n    }\n  };\n  Symbol.prototype._updateCommon = function (data, idx, symbolSize, seriesScope, opts) {\n    var symbolPath = this.childAt(0);\n    var seriesModel = data.hostModel;\n    var emphasisItemStyle;\n    var blurItemStyle;\n    var selectItemStyle;\n    var focus;\n    var blurScope;\n    var emphasisDisabled;\n    var labelStatesModels;\n    var hoverScale;\n    var cursorStyle;\n    if (seriesScope) {\n      emphasisItemStyle = seriesScope.emphasisItemStyle;\n      blurItemStyle = seriesScope.blurItemStyle;\n      selectItemStyle = seriesScope.selectItemStyle;\n      focus = seriesScope.focus;\n      blurScope = seriesScope.blurScope;\n      labelStatesModels = seriesScope.labelStatesModels;\n      hoverScale = seriesScope.hoverScale;\n      cursorStyle = seriesScope.cursorStyle;\n      emphasisDisabled = seriesScope.emphasisDisabled;\n    }\n    if (!seriesScope || data.hasItemOption) {\n      var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);\n      var emphasisModel = itemModel.getModel('emphasis');\n      emphasisItemStyle = emphasisModel.getModel('itemStyle').getItemStyle();\n      selectItemStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle();\n      blurItemStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();\n      focus = emphasisModel.get('focus');\n      blurScope = emphasisModel.get('blurScope');\n      emphasisDisabled = emphasisModel.get('disabled');\n      labelStatesModels = (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_4__/* .getLabelStatesModels */ .lx)(itemModel);\n      hoverScale = emphasisModel.getShallow('scale');\n      cursorStyle = itemModel.getShallow('cursor');\n    }\n    var symbolRotate = data.getItemVisual(idx, 'symbolRotate');\n    symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n    var symbolOffset = (0,_util_symbol_js__WEBPACK_IMPORTED_MODULE_1__/* .normalizeSymbolOffset */ .hV)(data.getItemVisual(idx, 'symbolOffset'), symbolSize);\n    if (symbolOffset) {\n      symbolPath.x = symbolOffset[0];\n      symbolPath.y = symbolOffset[1];\n    }\n    cursorStyle && symbolPath.attr('cursor', cursorStyle);\n    var symbolStyle = data.getItemVisual(idx, 'style');\n    var visualColor = symbolStyle.fill;\n    if (symbolPath instanceof zrender_lib_graphic_Image_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .Ay) {\n      var pathStyle = symbolPath.style;\n      symbolPath.useStyle((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.extend)({\n        // TODO other properties like x, y ?\n        image: pathStyle.image,\n        x: pathStyle.x,\n        y: pathStyle.y,\n        width: pathStyle.width,\n        height: pathStyle.height\n      }, symbolStyle));\n    } else {\n      if (symbolPath.__isEmptyBrush) {\n        // fill and stroke will be swapped if it's empty.\n        // So we cloned a new style to avoid it affecting the original style in visual storage.\n        // TODO Better implementation. No empty logic!\n        symbolPath.useStyle((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.extend)({}, symbolStyle));\n      } else {\n        symbolPath.useStyle(symbolStyle);\n      }\n      // Disable decal because symbol scale will been applied on the decal.\n      symbolPath.style.decal = null;\n      symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);\n      symbolPath.style.strokeNoScale = true;\n    }\n    var liftZ = data.getItemVisual(idx, 'liftZ');\n    var z2Origin = this._z2;\n    if (liftZ != null) {\n      if (z2Origin == null) {\n        this._z2 = symbolPath.z2;\n        symbolPath.z2 += liftZ;\n      }\n    } else if (z2Origin != null) {\n      symbolPath.z2 = z2Origin;\n      this._z2 = null;\n    }\n    var useNameLabel = opts && opts.useNameLabel;\n    (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_4__/* .setLabelStyle */ .qM)(symbolPath, labelStatesModels, {\n      labelFetcher: seriesModel,\n      labelDataIndex: idx,\n      defaultText: getLabelDefaultText,\n      inheritColor: visualColor,\n      defaultOpacity: symbolStyle.opacity\n    });\n    // Do not execute util needed.\n    function getLabelDefaultText(idx) {\n      return useNameLabel ? data.getName(idx) : (0,_labelHelper_js__WEBPACK_IMPORTED_MODULE_7__/* .getDefaultLabel */ .i)(data, idx);\n    }\n    this._sizeX = symbolSize[0] / 2;\n    this._sizeY = symbolSize[1] / 2;\n    var emphasisState = symbolPath.ensureState('emphasis');\n    emphasisState.style = emphasisItemStyle;\n    symbolPath.ensureState('select').style = selectItemStyle;\n    symbolPath.ensureState('blur').style = blurItemStyle;\n    // null / undefined / true means to use default strategy.\n    // 0 / false / negative number / NaN / Infinity means no scale.\n    var scaleRatio = hoverScale == null || hoverScale === true ? Math.max(1.1, 3 / this._sizeY)\n    // PENDING: restrict hoverScale > 1? It seems unreasonable to scale down\n    : isFinite(hoverScale) && hoverScale > 0 ? +hoverScale : 1;\n    // always set scale to allow resetting\n    emphasisState.scaleX = this._sizeX * scaleRatio;\n    emphasisState.scaleY = this._sizeY * scaleRatio;\n    this.setSymbolScale(1);\n    (0,_util_states_js__WEBPACK_IMPORTED_MODULE_2__/* .toggleHoverEmphasis */ .Lm)(this, focus, blurScope, emphasisDisabled);\n  };\n  Symbol.prototype.setSymbolScale = function (scale) {\n    this.scaleX = this.scaleY = scale;\n  };\n  Symbol.prototype.fadeOut = function (cb, seriesModel, opt) {\n    var symbolPath = this.childAt(0);\n    var dataIndex = (0,_util_innerStore_js__WEBPACK_IMPORTED_MODULE_8__/* .getECData */ .z)(this).dataIndex;\n    var animationOpt = opt && opt.animation;\n    // Avoid mistaken hover when fading out\n    this.silent = symbolPath.silent = true;\n    // Not show text when animating\n    if (opt && opt.fadeLabel) {\n      var textContent = symbolPath.getTextContent();\n      if (textContent) {\n        _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .removeElement */ .Nz(textContent, {\n          style: {\n            opacity: 0\n          }\n        }, seriesModel, {\n          dataIndex: dataIndex,\n          removeOpt: animationOpt,\n          cb: function () {\n            symbolPath.removeTextContent();\n          }\n        });\n      }\n    } else {\n      symbolPath.removeTextContent();\n    }\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .removeElement */ .Nz(symbolPath, {\n      style: {\n        opacity: 0\n      },\n      scaleX: 0,\n      scaleY: 0\n    }, seriesModel, {\n      dataIndex: dataIndex,\n      cb: cb,\n      removeOpt: animationOpt\n    });\n  };\n  Symbol.getSymbolSize = function (data, idx) {\n    return (0,_util_symbol_js__WEBPACK_IMPORTED_MODULE_1__/* .normalizeSymbolSize */ .xU)(data.getItemVisual(idx, 'symbolSize'));\n  };\n  return Symbol;\n}(_util_graphic_js__WEBPACK_IMPORTED_MODULE_9__/* [\"default\"] */ .A);\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Symbol);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAxMjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvU3ltYm9sLmpzPzY1ODQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGNyZWF0ZVN5bWJvbCwgbm9ybWFsaXplU3ltYm9sT2Zmc2V0LCBub3JtYWxpemVTeW1ib2xTaXplIH0gZnJvbSAnLi4vLi4vdXRpbC9zeW1ib2wuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlLmpzJztcbmltcG9ydCB7IGVudGVyRW1waGFzaXMsIGxlYXZlRW1waGFzaXMsIHRvZ2dsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgeyBnZXREZWZhdWx0TGFiZWwgfSBmcm9tICcuL2xhYmVsSGVscGVyLmpzJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBzZXRMYWJlbFN0eWxlLCBnZXRMYWJlbFN0YXRlc01vZGVscyB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUuanMnO1xuaW1wb3J0IFpSSW1hZ2UgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZS5qcyc7XG5pbXBvcnQgeyBzYXZlT2xkU3R5bGUgfSBmcm9tICcuLi8uLi9hbmltYXRpb24vYmFzaWNUcmFuc2l0aW9uLmpzJztcbnZhciBTeW1ib2wgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU3ltYm9sLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBTeW1ib2woZGF0YSwgaWR4LCBzZXJpZXNTY29wZSwgb3B0cykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMudXBkYXRlRGF0YShkYXRhLCBpZHgsIHNlcmllc1Njb3BlLCBvcHRzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgU3ltYm9sLnByb3RvdHlwZS5fY3JlYXRlU3ltYm9sID0gZnVuY3Rpb24gKHN5bWJvbFR5cGUsIGRhdGEsIGlkeCwgc3ltYm9sU2l6ZSwga2VlcEFzcGVjdCkge1xuICAgIC8vIFJlbW92ZSBwYXRocyBjcmVhdGVkIGJlZm9yZVxuICAgIHRoaXMucmVtb3ZlQWxsKCk7XG4gICAgLy8gbGV0IHN5bWJvbFBhdGggPSBjcmVhdGVTeW1ib2woXG4gICAgLy8gICAgIHN5bWJvbFR5cGUsIC0wLjUsIC0wLjUsIDEsIDEsIGNvbG9yXG4gICAgLy8gKTtcbiAgICAvLyBJZiB3aWR0aC9oZWlnaHQgYXJlIHNldCB0b28gc21hbGwgKGUuZy4sIHNldCB0byAxKSBvbiBpb3MxMFxuICAgIC8vIGFuZCBtYWNPUyBTaWVycmEsIGEgY2lyY2xlIHN0cm9rZSBiZWNvbWUgYSByZWN0LCBubyBtYXR0ZXIgd2hhdFxuICAgIC8vIHRoZSBzY2FsZSBpcyBzZXQuIFNvIHdlIHNldCB3aWR0aC9oZWlnaHQgYXMgMi4gU2VlICM0MTUwLlxuICAgIHZhciBzeW1ib2xQYXRoID0gY3JlYXRlU3ltYm9sKHN5bWJvbFR5cGUsIC0xLCAtMSwgMiwgMiwgbnVsbCwga2VlcEFzcGVjdCk7XG4gICAgc3ltYm9sUGF0aC5hdHRyKHtcbiAgICAgIHoyOiAxMDAsXG4gICAgICBjdWxsaW5nOiB0cnVlLFxuICAgICAgc2NhbGVYOiBzeW1ib2xTaXplWzBdIC8gMixcbiAgICAgIHNjYWxlWTogc3ltYm9sU2l6ZVsxXSAvIDJcbiAgICB9KTtcbiAgICAvLyBSZXdyaXRlIGRyaWZ0IG1ldGhvZFxuICAgIHN5bWJvbFBhdGguZHJpZnQgPSBkcmlmdFN5bWJvbDtcbiAgICB0aGlzLl9zeW1ib2xUeXBlID0gc3ltYm9sVHlwZTtcbiAgICB0aGlzLmFkZChzeW1ib2xQYXRoKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU3RvcCBhbmltYXRpb25cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRvTGFzdEZyYW1lXHJcbiAgICovXG4gIFN5bWJvbC5wcm90b3R5cGUuc3RvcFN5bWJvbEFuaW1hdGlvbiA9IGZ1bmN0aW9uICh0b0xhc3RGcmFtZSkge1xuICAgIHRoaXMuY2hpbGRBdCgwKS5zdG9wQW5pbWF0aW9uKG51bGwsIHRvTGFzdEZyYW1lKTtcbiAgfTtcbiAgU3ltYm9sLnByb3RvdHlwZS5nZXRTeW1ib2xUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zeW1ib2xUeXBlO1xuICB9O1xuICAvKipcclxuICAgKiBGSVhNRTpcclxuICAgKiBDYXV0aW9uOiBUaGlzIG1ldGhvZCBicmVha3MgdGhlIGVuY2Fwc3VsYXRpb24gb2YgdGhpcyBtb2R1bGUsXHJcbiAgICogYnV0IGl0IGluZGVlZCBicmluZ3MgY29udmVuaWVuY2UuIFNvIGRvIG5vdCB1c2UgdGhlIG1ldGhvZFxyXG4gICAqIHVubGVzcyB5b3UgZGV0YWlsZWRseSBrbm93IGFsbCB0aGUgaW1wbGVtZW50cyBvZiBgU3ltYm9sYCxcclxuICAgKiBlc3BlY2lhbGx5IGFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEdldCBzeW1ib2wgcGF0aCBlbGVtZW50LlxyXG4gICAqL1xuICBTeW1ib2wucHJvdG90eXBlLmdldFN5bWJvbFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRBdCgwKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogSGlnaGxpZ2h0IHN5bWJvbFxyXG4gICAqL1xuICBTeW1ib2wucHJvdG90eXBlLmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbnRlckVtcGhhc2lzKHRoaXMuY2hpbGRBdCgwKSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIERvd25wbGF5IHN5bWJvbFxyXG4gICAqL1xuICBTeW1ib2wucHJvdG90eXBlLmRvd25wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIGxlYXZlRW1waGFzaXModGhpcy5jaGlsZEF0KDApKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6XHJcbiAgICovXG4gIFN5bWJvbC5wcm90b3R5cGUuc2V0WiA9IGZ1bmN0aW9uICh6bGV2ZWwsIHopIHtcbiAgICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICBzeW1ib2xQYXRoLnpsZXZlbCA9IHpsZXZlbDtcbiAgICBzeW1ib2xQYXRoLnogPSB6O1xuICB9O1xuICBTeW1ib2wucHJvdG90eXBlLnNldERyYWdnYWJsZSA9IGZ1bmN0aW9uIChkcmFnZ2FibGUsIGhhc0N1cnNvck9wdGlvbikge1xuICAgIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICAgIHN5bWJvbFBhdGguZHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xuICAgIHN5bWJvbFBhdGguY3Vyc29yID0gIWhhc0N1cnNvck9wdGlvbiAmJiBkcmFnZ2FibGUgPyAnbW92ZScgOiBzeW1ib2xQYXRoLmN1cnNvcjtcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIHN5bWJvbCBwcm9wZXJ0aWVzXHJcbiAgICovXG4gIFN5bWJvbC5wcm90b3R5cGUudXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBpZHgsIHNlcmllc1Njb3BlLCBvcHRzKSB7XG4gICAgdGhpcy5zaWxlbnQgPSBmYWxzZTtcbiAgICB2YXIgc3ltYm9sVHlwZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSB8fCAnY2lyY2xlJztcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICB2YXIgc3ltYm9sU2l6ZSA9IFN5bWJvbC5nZXRTeW1ib2xTaXplKGRhdGEsIGlkeCk7XG4gICAgdmFyIGlzSW5pdCA9IHN5bWJvbFR5cGUgIT09IHRoaXMuX3N5bWJvbFR5cGU7XG4gICAgdmFyIGRpc2FibGVBbmltYXRpb24gPSBvcHRzICYmIG9wdHMuZGlzYWJsZUFuaW1hdGlvbjtcbiAgICBpZiAoaXNJbml0KSB7XG4gICAgICB2YXIga2VlcEFzcGVjdCA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xLZWVwQXNwZWN0Jyk7XG4gICAgICB0aGlzLl9jcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgZGF0YSwgaWR4LCBzeW1ib2xTaXplLCBrZWVwQXNwZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gICAgICBzeW1ib2xQYXRoLnNpbGVudCA9IGZhbHNlO1xuICAgICAgdmFyIHRhcmdldCA9IHtcbiAgICAgICAgc2NhbGVYOiBzeW1ib2xTaXplWzBdIC8gMixcbiAgICAgICAgc2NhbGVZOiBzeW1ib2xTaXplWzFdIC8gMlxuICAgICAgfTtcbiAgICAgIGRpc2FibGVBbmltYXRpb24gPyBzeW1ib2xQYXRoLmF0dHIodGFyZ2V0KSA6IGdyYXBoaWMudXBkYXRlUHJvcHMoc3ltYm9sUGF0aCwgdGFyZ2V0LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgIHNhdmVPbGRTdHlsZShzeW1ib2xQYXRoKTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlQ29tbW9uKGRhdGEsIGlkeCwgc3ltYm9sU2l6ZSwgc2VyaWVzU2NvcGUsIG9wdHMpO1xuICAgIGlmIChpc0luaXQpIHtcbiAgICAgIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICAgICAgaWYgKCFkaXNhYmxlQW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICAgICAgc2NhbGVYOiB0aGlzLl9zaXplWCxcbiAgICAgICAgICBzY2FsZVk6IHRoaXMuX3NpemVZLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAvLyBBbHdheXMgZmFkZUluLiBCZWNhdXNlIGl0IGhhcyBmYWRlT3V0IGFuaW1hdGlvbiB3aGVuIHN5bWJvbCBpcyByZW1vdmVkLi5cbiAgICAgICAgICAgIG9wYWNpdHk6IHN5bWJvbFBhdGguc3R5bGUub3BhY2l0eVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc3ltYm9sUGF0aC5zY2FsZVggPSBzeW1ib2xQYXRoLnNjYWxlWSA9IDA7XG4gICAgICAgIHN5bWJvbFBhdGguc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKHN5bWJvbFBhdGgsIHRhcmdldCwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaXNhYmxlQW5pbWF0aW9uKSB7XG4gICAgICAvLyBNdXN0IHN0b3AgbGVhdmUgdHJhbnNpdGlvbiBtYW51YWxseSBpZiBkb24ndCBjYWxsIGluaXRQcm9wcyBvciB1cGRhdGVQcm9wcy5cbiAgICAgIHRoaXMuY2hpbGRBdCgwKS5zdG9wQW5pbWF0aW9uKCdsZWF2ZScpO1xuICAgIH1cbiAgfTtcbiAgU3ltYm9sLnByb3RvdHlwZS5fdXBkYXRlQ29tbW9uID0gZnVuY3Rpb24gKGRhdGEsIGlkeCwgc3ltYm9sU2l6ZSwgc2VyaWVzU2NvcGUsIG9wdHMpIHtcbiAgICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICB2YXIgZW1waGFzaXNJdGVtU3R5bGU7XG4gICAgdmFyIGJsdXJJdGVtU3R5bGU7XG4gICAgdmFyIHNlbGVjdEl0ZW1TdHlsZTtcbiAgICB2YXIgZm9jdXM7XG4gICAgdmFyIGJsdXJTY29wZTtcbiAgICB2YXIgZW1waGFzaXNEaXNhYmxlZDtcbiAgICB2YXIgbGFiZWxTdGF0ZXNNb2RlbHM7XG4gICAgdmFyIGhvdmVyU2NhbGU7XG4gICAgdmFyIGN1cnNvclN0eWxlO1xuICAgIGlmIChzZXJpZXNTY29wZSkge1xuICAgICAgZW1waGFzaXNJdGVtU3R5bGUgPSBzZXJpZXNTY29wZS5lbXBoYXNpc0l0ZW1TdHlsZTtcbiAgICAgIGJsdXJJdGVtU3R5bGUgPSBzZXJpZXNTY29wZS5ibHVySXRlbVN0eWxlO1xuICAgICAgc2VsZWN0SXRlbVN0eWxlID0gc2VyaWVzU2NvcGUuc2VsZWN0SXRlbVN0eWxlO1xuICAgICAgZm9jdXMgPSBzZXJpZXNTY29wZS5mb2N1cztcbiAgICAgIGJsdXJTY29wZSA9IHNlcmllc1Njb3BlLmJsdXJTY29wZTtcbiAgICAgIGxhYmVsU3RhdGVzTW9kZWxzID0gc2VyaWVzU2NvcGUubGFiZWxTdGF0ZXNNb2RlbHM7XG4gICAgICBob3ZlclNjYWxlID0gc2VyaWVzU2NvcGUuaG92ZXJTY2FsZTtcbiAgICAgIGN1cnNvclN0eWxlID0gc2VyaWVzU2NvcGUuY3Vyc29yU3R5bGU7XG4gICAgICBlbXBoYXNpc0Rpc2FibGVkID0gc2VyaWVzU2NvcGUuZW1waGFzaXNEaXNhYmxlZDtcbiAgICB9XG4gICAgaWYgKCFzZXJpZXNTY29wZSB8fCBkYXRhLmhhc0l0ZW1PcHRpb24pIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5pdGVtTW9kZWwgPyBzZXJpZXNTY29wZS5pdGVtTW9kZWwgOiBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgdmFyIGVtcGhhc2lzTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJyk7XG4gICAgICBlbXBoYXNpc0l0ZW1TdHlsZSA9IGVtcGhhc2lzTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgc2VsZWN0SXRlbVN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKFsnc2VsZWN0JywgJ2l0ZW1TdHlsZSddKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgIGJsdXJJdGVtU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoWydibHVyJywgJ2l0ZW1TdHlsZSddKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgIGZvY3VzID0gZW1waGFzaXNNb2RlbC5nZXQoJ2ZvY3VzJyk7XG4gICAgICBibHVyU2NvcGUgPSBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJyk7XG4gICAgICBlbXBoYXNpc0Rpc2FibGVkID0gZW1waGFzaXNNb2RlbC5nZXQoJ2Rpc2FibGVkJyk7XG4gICAgICBsYWJlbFN0YXRlc01vZGVscyA9IGdldExhYmVsU3RhdGVzTW9kZWxzKGl0ZW1Nb2RlbCk7XG4gICAgICBob3ZlclNjYWxlID0gZW1waGFzaXNNb2RlbC5nZXRTaGFsbG93KCdzY2FsZScpO1xuICAgICAgY3Vyc29yU3R5bGUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnY3Vyc29yJyk7XG4gICAgfVxuICAgIHZhciBzeW1ib2xSb3RhdGUgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sUm90YXRlJyk7XG4gICAgc3ltYm9sUGF0aC5hdHRyKCdyb3RhdGlvbicsIChzeW1ib2xSb3RhdGUgfHwgMCkgKiBNYXRoLlBJIC8gMTgwIHx8IDApO1xuICAgIHZhciBzeW1ib2xPZmZzZXQgPSBub3JtYWxpemVTeW1ib2xPZmZzZXQoZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbE9mZnNldCcpLCBzeW1ib2xTaXplKTtcbiAgICBpZiAoc3ltYm9sT2Zmc2V0KSB7XG4gICAgICBzeW1ib2xQYXRoLnggPSBzeW1ib2xPZmZzZXRbMF07XG4gICAgICBzeW1ib2xQYXRoLnkgPSBzeW1ib2xPZmZzZXRbMV07XG4gICAgfVxuICAgIGN1cnNvclN0eWxlICYmIHN5bWJvbFBhdGguYXR0cignY3Vyc29yJywgY3Vyc29yU3R5bGUpO1xuICAgIHZhciBzeW1ib2xTdHlsZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzdHlsZScpO1xuICAgIHZhciB2aXN1YWxDb2xvciA9IHN5bWJvbFN0eWxlLmZpbGw7XG4gICAgaWYgKHN5bWJvbFBhdGggaW5zdGFuY2VvZiBaUkltYWdlKSB7XG4gICAgICB2YXIgcGF0aFN0eWxlID0gc3ltYm9sUGF0aC5zdHlsZTtcbiAgICAgIHN5bWJvbFBhdGgudXNlU3R5bGUoZXh0ZW5kKHtcbiAgICAgICAgLy8gVE9ETyBvdGhlciBwcm9wZXJ0aWVzIGxpa2UgeCwgeSA/XG4gICAgICAgIGltYWdlOiBwYXRoU3R5bGUuaW1hZ2UsXG4gICAgICAgIHg6IHBhdGhTdHlsZS54LFxuICAgICAgICB5OiBwYXRoU3R5bGUueSxcbiAgICAgICAgd2lkdGg6IHBhdGhTdHlsZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBwYXRoU3R5bGUuaGVpZ2h0XG4gICAgICB9LCBzeW1ib2xTdHlsZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3ltYm9sUGF0aC5fX2lzRW1wdHlCcnVzaCkge1xuICAgICAgICAvLyBmaWxsIGFuZCBzdHJva2Ugd2lsbCBiZSBzd2FwcGVkIGlmIGl0J3MgZW1wdHkuXG4gICAgICAgIC8vIFNvIHdlIGNsb25lZCBhIG5ldyBzdHlsZSB0byBhdm9pZCBpdCBhZmZlY3RpbmcgdGhlIG9yaWdpbmFsIHN0eWxlIGluIHZpc3VhbCBzdG9yYWdlLlxuICAgICAgICAvLyBUT0RPIEJldHRlciBpbXBsZW1lbnRhdGlvbi4gTm8gZW1wdHkgbG9naWMhXG4gICAgICAgIHN5bWJvbFBhdGgudXNlU3R5bGUoZXh0ZW5kKHt9LCBzeW1ib2xTdHlsZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ltYm9sUGF0aC51c2VTdHlsZShzeW1ib2xTdHlsZSk7XG4gICAgICB9XG4gICAgICAvLyBEaXNhYmxlIGRlY2FsIGJlY2F1c2Ugc3ltYm9sIHNjYWxlIHdpbGwgYmVlbiBhcHBsaWVkIG9uIHRoZSBkZWNhbC5cbiAgICAgIHN5bWJvbFBhdGguc3R5bGUuZGVjYWwgPSBudWxsO1xuICAgICAgc3ltYm9sUGF0aC5zZXRDb2xvcih2aXN1YWxDb2xvciwgb3B0cyAmJiBvcHRzLnN5bWJvbElubmVyQ29sb3IpO1xuICAgICAgc3ltYm9sUGF0aC5zdHlsZS5zdHJva2VOb1NjYWxlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGxpZnRaID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2xpZnRaJyk7XG4gICAgdmFyIHoyT3JpZ2luID0gdGhpcy5fejI7XG4gICAgaWYgKGxpZnRaICE9IG51bGwpIHtcbiAgICAgIGlmICh6Mk9yaWdpbiA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3oyID0gc3ltYm9sUGF0aC56MjtcbiAgICAgICAgc3ltYm9sUGF0aC56MiArPSBsaWZ0WjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHoyT3JpZ2luICE9IG51bGwpIHtcbiAgICAgIHN5bWJvbFBhdGguejIgPSB6Mk9yaWdpbjtcbiAgICAgIHRoaXMuX3oyID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHVzZU5hbWVMYWJlbCA9IG9wdHMgJiYgb3B0cy51c2VOYW1lTGFiZWw7XG4gICAgc2V0TGFiZWxTdHlsZShzeW1ib2xQYXRoLCBsYWJlbFN0YXRlc01vZGVscywge1xuICAgICAgbGFiZWxGZXRjaGVyOiBzZXJpZXNNb2RlbCxcbiAgICAgIGxhYmVsRGF0YUluZGV4OiBpZHgsXG4gICAgICBkZWZhdWx0VGV4dDogZ2V0TGFiZWxEZWZhdWx0VGV4dCxcbiAgICAgIGluaGVyaXRDb2xvcjogdmlzdWFsQ29sb3IsXG4gICAgICBkZWZhdWx0T3BhY2l0eTogc3ltYm9sU3R5bGUub3BhY2l0eVxuICAgIH0pO1xuICAgIC8vIERvIG5vdCBleGVjdXRlIHV0aWwgbmVlZGVkLlxuICAgIGZ1bmN0aW9uIGdldExhYmVsRGVmYXVsdFRleHQoaWR4KSB7XG4gICAgICByZXR1cm4gdXNlTmFtZUxhYmVsID8gZGF0YS5nZXROYW1lKGlkeCkgOiBnZXREZWZhdWx0TGFiZWwoZGF0YSwgaWR4KTtcbiAgICB9XG4gICAgdGhpcy5fc2l6ZVggPSBzeW1ib2xTaXplWzBdIC8gMjtcbiAgICB0aGlzLl9zaXplWSA9IHN5bWJvbFNpemVbMV0gLyAyO1xuICAgIHZhciBlbXBoYXNpc1N0YXRlID0gc3ltYm9sUGF0aC5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKTtcbiAgICBlbXBoYXNpc1N0YXRlLnN0eWxlID0gZW1waGFzaXNJdGVtU3R5bGU7XG4gICAgc3ltYm9sUGF0aC5lbnN1cmVTdGF0ZSgnc2VsZWN0Jykuc3R5bGUgPSBzZWxlY3RJdGVtU3R5bGU7XG4gICAgc3ltYm9sUGF0aC5lbnN1cmVTdGF0ZSgnYmx1cicpLnN0eWxlID0gYmx1ckl0ZW1TdHlsZTtcbiAgICAvLyBudWxsIC8gdW5kZWZpbmVkIC8gdHJ1ZSBtZWFucyB0byB1c2UgZGVmYXVsdCBzdHJhdGVneS5cbiAgICAvLyAwIC8gZmFsc2UgLyBuZWdhdGl2ZSBudW1iZXIgLyBOYU4gLyBJbmZpbml0eSBtZWFucyBubyBzY2FsZS5cbiAgICB2YXIgc2NhbGVSYXRpbyA9IGhvdmVyU2NhbGUgPT0gbnVsbCB8fCBob3ZlclNjYWxlID09PSB0cnVlID8gTWF0aC5tYXgoMS4xLCAzIC8gdGhpcy5fc2l6ZVkpXG4gICAgLy8gUEVORElORzogcmVzdHJpY3QgaG92ZXJTY2FsZSA+IDE/IEl0IHNlZW1zIHVucmVhc29uYWJsZSB0byBzY2FsZSBkb3duXG4gICAgOiBpc0Zpbml0ZShob3ZlclNjYWxlKSAmJiBob3ZlclNjYWxlID4gMCA/ICtob3ZlclNjYWxlIDogMTtcbiAgICAvLyBhbHdheXMgc2V0IHNjYWxlIHRvIGFsbG93IHJlc2V0dGluZ1xuICAgIGVtcGhhc2lzU3RhdGUuc2NhbGVYID0gdGhpcy5fc2l6ZVggKiBzY2FsZVJhdGlvO1xuICAgIGVtcGhhc2lzU3RhdGUuc2NhbGVZID0gdGhpcy5fc2l6ZVkgKiBzY2FsZVJhdGlvO1xuICAgIHRoaXMuc2V0U3ltYm9sU2NhbGUoMSk7XG4gICAgdG9nZ2xlSG92ZXJFbXBoYXNpcyh0aGlzLCBmb2N1cywgYmx1clNjb3BlLCBlbXBoYXNpc0Rpc2FibGVkKTtcbiAgfTtcbiAgU3ltYm9sLnByb3RvdHlwZS5zZXRTeW1ib2xTY2FsZSA9IGZ1bmN0aW9uIChzY2FsZSkge1xuICAgIHRoaXMuc2NhbGVYID0gdGhpcy5zY2FsZVkgPSBzY2FsZTtcbiAgfTtcbiAgU3ltYm9sLnByb3RvdHlwZS5mYWRlT3V0ID0gZnVuY3Rpb24gKGNiLCBzZXJpZXNNb2RlbCwgb3B0KSB7XG4gICAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gICAgdmFyIGRhdGFJbmRleCA9IGdldEVDRGF0YSh0aGlzKS5kYXRhSW5kZXg7XG4gICAgdmFyIGFuaW1hdGlvbk9wdCA9IG9wdCAmJiBvcHQuYW5pbWF0aW9uO1xuICAgIC8vIEF2b2lkIG1pc3Rha2VuIGhvdmVyIHdoZW4gZmFkaW5nIG91dFxuICAgIHRoaXMuc2lsZW50ID0gc3ltYm9sUGF0aC5zaWxlbnQgPSB0cnVlO1xuICAgIC8vIE5vdCBzaG93IHRleHQgd2hlbiBhbmltYXRpbmdcbiAgICBpZiAob3B0ICYmIG9wdC5mYWRlTGFiZWwpIHtcbiAgICAgIHZhciB0ZXh0Q29udGVudCA9IHN5bWJvbFBhdGguZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgIGlmICh0ZXh0Q29udGVudCkge1xuICAgICAgICBncmFwaGljLnJlbW92ZUVsZW1lbnQodGV4dENvbnRlbnQsIHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSwgc2VyaWVzTW9kZWwsIHtcbiAgICAgICAgICBkYXRhSW5kZXg6IGRhdGFJbmRleCxcbiAgICAgICAgICByZW1vdmVPcHQ6IGFuaW1hdGlvbk9wdCxcbiAgICAgICAgICBjYjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3ltYm9sUGF0aC5yZW1vdmVUZXh0Q29udGVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN5bWJvbFBhdGgucmVtb3ZlVGV4dENvbnRlbnQoKTtcbiAgICB9XG4gICAgZ3JhcGhpYy5yZW1vdmVFbGVtZW50KHN5bWJvbFBhdGgsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0sXG4gICAgICBzY2FsZVg6IDAsXG4gICAgICBzY2FsZVk6IDBcbiAgICB9LCBzZXJpZXNNb2RlbCwge1xuICAgICAgZGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgICBjYjogY2IsXG4gICAgICByZW1vdmVPcHQ6IGFuaW1hdGlvbk9wdFxuICAgIH0pO1xuICB9O1xuICBTeW1ib2wuZ2V0U3ltYm9sU2l6ZSA9IGZ1bmN0aW9uIChkYXRhLCBpZHgpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplU3ltYm9sU2l6ZShkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScpKTtcbiAgfTtcbiAgcmV0dXJuIFN5bWJvbDtcbn0oZ3JhcGhpYy5Hcm91cCk7XG5mdW5jdGlvbiBkcmlmdFN5bWJvbChkeCwgZHkpIHtcbiAgdGhpcy5wYXJlbnQuZHJpZnQoZHgsIGR5KTtcbn1cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10128\n")},13269:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _Polyline_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46448);\n/* harmony import */ var _EffectLine_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31331);\n/* harmony import */ var zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83509);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar EffectPolyline = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(EffectPolyline, _super);\n  function EffectPolyline() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this._lastFrame = 0;\n    _this._lastFramePercent = 0;\n    return _this;\n  }\n  // Override\n  EffectPolyline.prototype.createLine = function (lineData, idx, seriesScope) {\n    return new _Polyline_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A(lineData, idx, seriesScope);\n  };\n  ;\n  // Override\n  EffectPolyline.prototype._updateAnimationPoints = function (symbol, points) {\n    this._points = points;\n    var accLenArr = [0];\n    var len = 0;\n    for (var i = 1; i < points.length; i++) {\n      var p1 = points[i - 1];\n      var p2 = points[i];\n      len += zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_2__.dist(p1, p2);\n      accLenArr.push(len);\n    }\n    if (len === 0) {\n      this._length = 0;\n      return;\n    }\n    for (var i = 0; i < accLenArr.length; i++) {\n      accLenArr[i] /= len;\n    }\n    this._offsets = accLenArr;\n    this._length = len;\n  };\n  ;\n  // Override\n  EffectPolyline.prototype._getLineLength = function () {\n    return this._length;\n  };\n  ;\n  // Override\n  EffectPolyline.prototype._updateSymbolPosition = function (symbol) {\n    var t = symbol.__t < 1 ? symbol.__t : 2 - symbol.__t;\n    var points = this._points;\n    var offsets = this._offsets;\n    var len = points.length;\n    if (!offsets) {\n      // Has length 0\n      return;\n    }\n    var lastFrame = this._lastFrame;\n    var frame;\n    if (t < this._lastFramePercent) {\n      // Start from the next frame\n      // PENDING start from lastFrame ?\n      var start = Math.min(lastFrame + 1, len - 1);\n      for (frame = start; frame >= 0; frame--) {\n        if (offsets[frame] <= t) {\n          break;\n        }\n      }\n      // PENDING really need to do this ?\n      frame = Math.min(frame, len - 2);\n    } else {\n      for (frame = lastFrame; frame < len; frame++) {\n        if (offsets[frame] > t) {\n          break;\n        }\n      }\n      frame = Math.min(frame - 1, len - 2);\n    }\n    var p = (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame]);\n    var p0 = points[frame];\n    var p1 = points[frame + 1];\n    symbol.x = p0[0] * (1 - p) + p * p1[0];\n    symbol.y = p0[1] * (1 - p) + p * p1[1];\n    var tx = symbol.__t < 1 ? p1[0] - p0[0] : p0[0] - p1[0];\n    var ty = symbol.__t < 1 ? p1[1] - p0[1] : p0[1] - p1[1];\n    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\n    this._lastFrame = frame;\n    this._lastFramePercent = t;\n    symbol.ignore = false;\n  };\n  ;\n  return EffectPolyline;\n}(_EffectLine_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EffectPolyline);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMyNjkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL0VmZmVjdFBvbHlsaW5lLmpzPzM5MDMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBQb2x5bGluZSBmcm9tICcuL1BvbHlsaW5lLmpzJztcbmltcG9ydCBFZmZlY3RMaW5lIGZyb20gJy4vRWZmZWN0TGluZS5qcyc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzJztcbnZhciBFZmZlY3RQb2x5bGluZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhFZmZlY3RQb2x5bGluZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRWZmZWN0UG9seWxpbmUoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX2xhc3RGcmFtZSA9IDA7XG4gICAgX3RoaXMuX2xhc3RGcmFtZVBlcmNlbnQgPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvLyBPdmVycmlkZVxuICBFZmZlY3RQb2x5bGluZS5wcm90b3R5cGUuY3JlYXRlTGluZSA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgIHJldHVybiBuZXcgUG9seWxpbmUobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpO1xuICB9O1xuICA7XG4gIC8vIE92ZXJyaWRlXG4gIEVmZmVjdFBvbHlsaW5lLnByb3RvdHlwZS5fdXBkYXRlQW5pbWF0aW9uUG9pbnRzID0gZnVuY3Rpb24gKHN5bWJvbCwgcG9pbnRzKSB7XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgIHZhciBhY2NMZW5BcnIgPSBbMF07XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwMSA9IHBvaW50c1tpIC0gMV07XG4gICAgICB2YXIgcDIgPSBwb2ludHNbaV07XG4gICAgICBsZW4gKz0gdmVjMi5kaXN0KHAxLCBwMik7XG4gICAgICBhY2NMZW5BcnIucHVzaChsZW4pO1xuICAgIH1cbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjY0xlbkFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYWNjTGVuQXJyW2ldIC89IGxlbjtcbiAgICB9XG4gICAgdGhpcy5fb2Zmc2V0cyA9IGFjY0xlbkFycjtcbiAgICB0aGlzLl9sZW5ndGggPSBsZW47XG4gIH07XG4gIDtcbiAgLy8gT3ZlcnJpZGVcbiAgRWZmZWN0UG9seWxpbmUucHJvdG90eXBlLl9nZXRMaW5lTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gIH07XG4gIDtcbiAgLy8gT3ZlcnJpZGVcbiAgRWZmZWN0UG9seWxpbmUucHJvdG90eXBlLl91cGRhdGVTeW1ib2xQb3NpdGlvbiA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICB2YXIgdCA9IHN5bWJvbC5fX3QgPCAxID8gc3ltYm9sLl9fdCA6IDIgLSBzeW1ib2wuX190O1xuICAgIHZhciBwb2ludHMgPSB0aGlzLl9wb2ludHM7XG4gICAgdmFyIG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIGlmICghb2Zmc2V0cykge1xuICAgICAgLy8gSGFzIGxlbmd0aCAwXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsYXN0RnJhbWUgPSB0aGlzLl9sYXN0RnJhbWU7XG4gICAgdmFyIGZyYW1lO1xuICAgIGlmICh0IDwgdGhpcy5fbGFzdEZyYW1lUGVyY2VudCkge1xuICAgICAgLy8gU3RhcnQgZnJvbSB0aGUgbmV4dCBmcmFtZVxuICAgICAgLy8gUEVORElORyBzdGFydCBmcm9tIGxhc3RGcmFtZSA/XG4gICAgICB2YXIgc3RhcnQgPSBNYXRoLm1pbihsYXN0RnJhbWUgKyAxLCBsZW4gLSAxKTtcbiAgICAgIGZvciAoZnJhbWUgPSBzdGFydDsgZnJhbWUgPj0gMDsgZnJhbWUtLSkge1xuICAgICAgICBpZiAob2Zmc2V0c1tmcmFtZV0gPD0gdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBQRU5ESU5HIHJlYWxseSBuZWVkIHRvIGRvIHRoaXMgP1xuICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSwgbGVuIC0gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgbGVuOyBmcmFtZSsrKSB7XG4gICAgICAgIGlmIChvZmZzZXRzW2ZyYW1lXSA+IHQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSAtIDEsIGxlbiAtIDIpO1xuICAgIH1cbiAgICB2YXIgcCA9ICh0IC0gb2Zmc2V0c1tmcmFtZV0pIC8gKG9mZnNldHNbZnJhbWUgKyAxXSAtIG9mZnNldHNbZnJhbWVdKTtcbiAgICB2YXIgcDAgPSBwb2ludHNbZnJhbWVdO1xuICAgIHZhciBwMSA9IHBvaW50c1tmcmFtZSArIDFdO1xuICAgIHN5bWJvbC54ID0gcDBbMF0gKiAoMSAtIHApICsgcCAqIHAxWzBdO1xuICAgIHN5bWJvbC55ID0gcDBbMV0gKiAoMSAtIHApICsgcCAqIHAxWzFdO1xuICAgIHZhciB0eCA9IHN5bWJvbC5fX3QgPCAxID8gcDFbMF0gLSBwMFswXSA6IHAwWzBdIC0gcDFbMF07XG4gICAgdmFyIHR5ID0gc3ltYm9sLl9fdCA8IDEgPyBwMVsxXSAtIHAwWzFdIDogcDBbMV0gLSBwMVsxXTtcbiAgICBzeW1ib2wucm90YXRpb24gPSAtTWF0aC5hdGFuMih0eSwgdHgpIC0gTWF0aC5QSSAvIDI7XG4gICAgdGhpcy5fbGFzdEZyYW1lID0gZnJhbWU7XG4gICAgdGhpcy5fbGFzdEZyYW1lUGVyY2VudCA9IHQ7XG4gICAgc3ltYm9sLmlnbm9yZSA9IGZhbHNlO1xuICB9O1xuICA7XG4gIHJldHVybiBFZmZlY3RQb2x5bGluZTtcbn0oRWZmZWN0TGluZSk7XG5leHBvcnQgZGVmYXVsdCBFZmZlY3RQb2x5bGluZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13269\n')},13637:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _data_SeriesData_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(6006);\n/* harmony import */ var _data_helper_createDimensions_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(97351);\n/* harmony import */ var _data_helper_dimensionHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29756);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(48170);\n/* harmony import */ var _core_CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89737);\n/* harmony import */ var _model_referHelper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(90106);\n/* harmony import */ var _data_Source_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(34310);\n/* harmony import */ var _data_helper_dataStackHelper_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(65008);\n/* harmony import */ var _data_helper_sourceHelper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(23071);\n/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(13430);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\nfunction getCoordSysDimDefs(seriesModel, coordSysInfo) {\n  var coordSysName = seriesModel.get(\'coordinateSystem\');\n  var registeredCoordSys = _core_CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.get(coordSysName);\n  var coordSysDimDefs;\n  if (coordSysInfo && coordSysInfo.coordSysDims) {\n    coordSysDimDefs = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map(coordSysInfo.coordSysDims, function (dim) {\n      var dimInfo = {\n        name: dim\n      };\n      var axisModel = coordSysInfo.axisMap.get(dim);\n      if (axisModel) {\n        var axisType = axisModel.get(\'type\');\n        dimInfo.type = (0,_data_helper_dimensionHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .getDimensionTypeByAxis */ .B)(axisType);\n      }\n      return dimInfo;\n    });\n  }\n  if (!coordSysDimDefs) {\n    // Get dimensions from registered coordinate system\n    coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || [\'x\', \'y\'];\n  }\n  return coordSysDimDefs;\n}\nfunction injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {\n  var firstCategoryDimIndex;\n  var hasNameEncode;\n  coordSysInfo && zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(dimInfoList, function (dimInfo, dimIndex) {\n    var coordDim = dimInfo.coordDim;\n    var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);\n    if (categoryAxisModel) {\n      if (firstCategoryDimIndex == null) {\n        firstCategoryDimIndex = dimIndex;\n      }\n      dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();\n      if (createInvertedIndices) {\n        dimInfo.createInvertedIndices = true;\n      }\n    }\n    if (dimInfo.otherDims.itemName != null) {\n      hasNameEncode = true;\n    }\n  });\n  if (!hasNameEncode && firstCategoryDimIndex != null) {\n    dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;\n  }\n  return firstCategoryDimIndex;\n}\n/**\r\n * Caution: there are side effects to `sourceManager` in this method.\r\n * Should better only be called in `Series[\'getInitialData\']`.\r\n */\nfunction createSeriesData(sourceRaw, seriesModel, opt) {\n  opt = opt || {};\n  var sourceManager = seriesModel.getSourceManager();\n  var source;\n  var isOriginalSource = false;\n  if (sourceRaw) {\n    isOriginalSource = true;\n    source = (0,_data_Source_js__WEBPACK_IMPORTED_MODULE_3__/* .createSourceFromSeriesDataOption */ .AF)(sourceRaw);\n  } else {\n    source = sourceManager.getSource();\n    // Is series.data. not dataset.\n    isOriginalSource = source.sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_4__/* .SOURCE_FORMAT_ORIGINAL */ .mK;\n  }\n  var coordSysInfo = (0,_model_referHelper_js__WEBPACK_IMPORTED_MODULE_5__/* .getCoordSysInfoBySeries */ .X)(seriesModel);\n  var coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);\n  var useEncodeDefaulter = opt.useEncodeDefaulter;\n  var encodeDefaulter = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.curry(_data_helper_sourceHelper_js__WEBPACK_IMPORTED_MODULE_6__/* .makeSeriesEncodeForAxisCoordSys */ .OC, coordSysDimDefs, seriesModel) : null;\n  var createDimensionOptions = {\n    coordDimensions: coordSysDimDefs,\n    generateCoord: opt.generateCoord,\n    encodeDefine: seriesModel.getEncode(),\n    encodeDefaulter: encodeDefaulter,\n    canOmitUnusedDimensions: !isOriginalSource\n  };\n  var schema = (0,_data_helper_createDimensions_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(source, createDimensionOptions);\n  var firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);\n  var store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;\n  var stackCalculationInfo = (0,_data_helper_dataStackHelper_js__WEBPACK_IMPORTED_MODULE_8__/* .enableDataStack */ .iJ)(seriesModel, {\n    schema: schema,\n    store: store\n  });\n  var data = new _data_SeriesData_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A(schema, seriesModel);\n  data.setCalculationInfo(stackCalculationInfo);\n  var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n    // Use dataIndex as ordinal value in categoryAxis\n    return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);\n  } : null;\n  data.hasItemOption = false;\n  data.initData(\n  // Try to reuse the data store in sourceManager if using dataset.\n  isOriginalSource ? source : store, null, dimValueGetter);\n  return data;\n}\nfunction isNeedCompleteOrdinalData(source) {\n  if (source.sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_4__/* .SOURCE_FORMAT_ORIGINAL */ .mK) {\n    var sampleItem = firstDataNotNull(source.data || []);\n    return !zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray((0,_util_model_js__WEBPACK_IMPORTED_MODULE_10__/* .getDataItemValue */ .vj)(sampleItem));\n  }\n}\nfunction firstDataNotNull(arr) {\n  var i = 0;\n  while (i < arr.length && arr[i] == null) {\n    i++;\n  }\n  return arr[i];\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createSeriesData);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM2MzcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL2NyZWF0ZVNlcmllc0RhdGEuanM/ODY1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IFNlcmllc0RhdGEgZnJvbSAnLi4vLi4vZGF0YS9TZXJpZXNEYXRhLmpzJztcbmltcG9ydCBwcmVwYXJlU2VyaWVzRGF0YVNjaGVtYSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9jcmVhdGVEaW1lbnNpb25zLmpzJztcbmltcG9ydCB7IGdldERpbWVuc2lvblR5cGVCeUF4aXMgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9kaW1lbnNpb25IZWxwZXIuanMnO1xuaW1wb3J0IHsgZ2V0RGF0YUl0ZW1WYWx1ZSB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xuaW1wb3J0IENvb3JkaW5hdGVTeXN0ZW0gZnJvbSAnLi4vLi4vY29yZS9Db29yZGluYXRlU3lzdGVtLmpzJztcbmltcG9ydCB7IGdldENvb3JkU3lzSW5mb0J5U2VyaWVzIH0gZnJvbSAnLi4vLi4vbW9kZWwvcmVmZXJIZWxwZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlU291cmNlRnJvbVNlcmllc0RhdGFPcHRpb24gfSBmcm9tICcuLi8uLi9kYXRhL1NvdXJjZS5qcyc7XG5pbXBvcnQgeyBlbmFibGVEYXRhU3RhY2sgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9kYXRhU3RhY2tIZWxwZXIuanMnO1xuaW1wb3J0IHsgbWFrZVNlcmllc0VuY29kZUZvckF4aXNDb29yZFN5cyB9IGZyb20gJy4uLy4uL2RhdGEvaGVscGVyL3NvdXJjZUhlbHBlci5qcyc7XG5pbXBvcnQgeyBTT1VSQ0VfRk9STUFUX09SSUdJTkFMIH0gZnJvbSAnLi4vLi4vdXRpbC90eXBlcy5qcyc7XG5mdW5jdGlvbiBnZXRDb29yZFN5c0RpbURlZnMoc2VyaWVzTW9kZWwsIGNvb3JkU3lzSW5mbykge1xuICB2YXIgY29vcmRTeXNOYW1lID0gc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJyk7XG4gIHZhciByZWdpc3RlcmVkQ29vcmRTeXMgPSBDb29yZGluYXRlU3lzdGVtLmdldChjb29yZFN5c05hbWUpO1xuICB2YXIgY29vcmRTeXNEaW1EZWZzO1xuICBpZiAoY29vcmRTeXNJbmZvICYmIGNvb3JkU3lzSW5mby5jb29yZFN5c0RpbXMpIHtcbiAgICBjb29yZFN5c0RpbURlZnMgPSB6clV0aWwubWFwKGNvb3JkU3lzSW5mby5jb29yZFN5c0RpbXMsIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgIHZhciBkaW1JbmZvID0ge1xuICAgICAgICBuYW1lOiBkaW1cbiAgICAgIH07XG4gICAgICB2YXIgYXhpc01vZGVsID0gY29vcmRTeXNJbmZvLmF4aXNNYXAuZ2V0KGRpbSk7XG4gICAgICBpZiAoYXhpc01vZGVsKSB7XG4gICAgICAgIHZhciBheGlzVHlwZSA9IGF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgZGltSW5mby50eXBlID0gZ2V0RGltZW5zaW9uVHlwZUJ5QXhpcyhheGlzVHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGltSW5mbztcbiAgICB9KTtcbiAgfVxuICBpZiAoIWNvb3JkU3lzRGltRGVmcykge1xuICAgIC8vIEdldCBkaW1lbnNpb25zIGZyb20gcmVnaXN0ZXJlZCBjb29yZGluYXRlIHN5c3RlbVxuICAgIGNvb3JkU3lzRGltRGVmcyA9IHJlZ2lzdGVyZWRDb29yZFN5cyAmJiAocmVnaXN0ZXJlZENvb3JkU3lzLmdldERpbWVuc2lvbnNJbmZvID8gcmVnaXN0ZXJlZENvb3JkU3lzLmdldERpbWVuc2lvbnNJbmZvKCkgOiByZWdpc3RlcmVkQ29vcmRTeXMuZGltZW5zaW9ucy5zbGljZSgpKSB8fCBbJ3gnLCAneSddO1xuICB9XG4gIHJldHVybiBjb29yZFN5c0RpbURlZnM7XG59XG5mdW5jdGlvbiBpbmplY3RPcmRpbmFsTWV0YShkaW1JbmZvTGlzdCwgY3JlYXRlSW52ZXJ0ZWRJbmRpY2VzLCBjb29yZFN5c0luZm8pIHtcbiAgdmFyIGZpcnN0Q2F0ZWdvcnlEaW1JbmRleDtcbiAgdmFyIGhhc05hbWVFbmNvZGU7XG4gIGNvb3JkU3lzSW5mbyAmJiB6clV0aWwuZWFjaChkaW1JbmZvTGlzdCwgZnVuY3Rpb24gKGRpbUluZm8sIGRpbUluZGV4KSB7XG4gICAgdmFyIGNvb3JkRGltID0gZGltSW5mby5jb29yZERpbTtcbiAgICB2YXIgY2F0ZWdvcnlBeGlzTW9kZWwgPSBjb29yZFN5c0luZm8uY2F0ZWdvcnlBeGlzTWFwLmdldChjb29yZERpbSk7XG4gICAgaWYgKGNhdGVnb3J5QXhpc01vZGVsKSB7XG4gICAgICBpZiAoZmlyc3RDYXRlZ29yeURpbUluZGV4ID09IG51bGwpIHtcbiAgICAgICAgZmlyc3RDYXRlZ29yeURpbUluZGV4ID0gZGltSW5kZXg7XG4gICAgICB9XG4gICAgICBkaW1JbmZvLm9yZGluYWxNZXRhID0gY2F0ZWdvcnlBeGlzTW9kZWwuZ2V0T3JkaW5hbE1ldGEoKTtcbiAgICAgIGlmIChjcmVhdGVJbnZlcnRlZEluZGljZXMpIHtcbiAgICAgICAgZGltSW5mby5jcmVhdGVJbnZlcnRlZEluZGljZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGltSW5mby5vdGhlckRpbXMuaXRlbU5hbWUgIT0gbnVsbCkge1xuICAgICAgaGFzTmFtZUVuY29kZSA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFoYXNOYW1lRW5jb2RlICYmIGZpcnN0Q2F0ZWdvcnlEaW1JbmRleCAhPSBudWxsKSB7XG4gICAgZGltSW5mb0xpc3RbZmlyc3RDYXRlZ29yeURpbUluZGV4XS5vdGhlckRpbXMuaXRlbU5hbWUgPSAwO1xuICB9XG4gIHJldHVybiBmaXJzdENhdGVnb3J5RGltSW5kZXg7XG59XG4vKipcclxuICogQ2F1dGlvbjogdGhlcmUgYXJlIHNpZGUgZWZmZWN0cyB0byBgc291cmNlTWFuYWdlcmAgaW4gdGhpcyBtZXRob2QuXHJcbiAqIFNob3VsZCBiZXR0ZXIgb25seSBiZSBjYWxsZWQgaW4gYFNlcmllc1snZ2V0SW5pdGlhbERhdGEnXWAuXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2VyaWVzRGF0YShzb3VyY2VSYXcsIHNlcmllc01vZGVsLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICB2YXIgc291cmNlTWFuYWdlciA9IHNlcmllc01vZGVsLmdldFNvdXJjZU1hbmFnZXIoKTtcbiAgdmFyIHNvdXJjZTtcbiAgdmFyIGlzT3JpZ2luYWxTb3VyY2UgPSBmYWxzZTtcbiAgaWYgKHNvdXJjZVJhdykge1xuICAgIGlzT3JpZ2luYWxTb3VyY2UgPSB0cnVlO1xuICAgIHNvdXJjZSA9IGNyZWF0ZVNvdXJjZUZyb21TZXJpZXNEYXRhT3B0aW9uKHNvdXJjZVJhdyk7XG4gIH0gZWxzZSB7XG4gICAgc291cmNlID0gc291cmNlTWFuYWdlci5nZXRTb3VyY2UoKTtcbiAgICAvLyBJcyBzZXJpZXMuZGF0YS4gbm90IGRhdGFzZXQuXG4gICAgaXNPcmlnaW5hbFNvdXJjZSA9IHNvdXJjZS5zb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfT1JJR0lOQUw7XG4gIH1cbiAgdmFyIGNvb3JkU3lzSW5mbyA9IGdldENvb3JkU3lzSW5mb0J5U2VyaWVzKHNlcmllc01vZGVsKTtcbiAgdmFyIGNvb3JkU3lzRGltRGVmcyA9IGdldENvb3JkU3lzRGltRGVmcyhzZXJpZXNNb2RlbCwgY29vcmRTeXNJbmZvKTtcbiAgdmFyIHVzZUVuY29kZURlZmF1bHRlciA9IG9wdC51c2VFbmNvZGVEZWZhdWx0ZXI7XG4gIHZhciBlbmNvZGVEZWZhdWx0ZXIgPSB6clV0aWwuaXNGdW5jdGlvbih1c2VFbmNvZGVEZWZhdWx0ZXIpID8gdXNlRW5jb2RlRGVmYXVsdGVyIDogdXNlRW5jb2RlRGVmYXVsdGVyID8genJVdGlsLmN1cnJ5KG1ha2VTZXJpZXNFbmNvZGVGb3JBeGlzQ29vcmRTeXMsIGNvb3JkU3lzRGltRGVmcywgc2VyaWVzTW9kZWwpIDogbnVsbDtcbiAgdmFyIGNyZWF0ZURpbWVuc2lvbk9wdGlvbnMgPSB7XG4gICAgY29vcmREaW1lbnNpb25zOiBjb29yZFN5c0RpbURlZnMsXG4gICAgZ2VuZXJhdGVDb29yZDogb3B0LmdlbmVyYXRlQ29vcmQsXG4gICAgZW5jb2RlRGVmaW5lOiBzZXJpZXNNb2RlbC5nZXRFbmNvZGUoKSxcbiAgICBlbmNvZGVEZWZhdWx0ZXI6IGVuY29kZURlZmF1bHRlcixcbiAgICBjYW5PbWl0VW51c2VkRGltZW5zaW9uczogIWlzT3JpZ2luYWxTb3VyY2VcbiAgfTtcbiAgdmFyIHNjaGVtYSA9IHByZXBhcmVTZXJpZXNEYXRhU2NoZW1hKHNvdXJjZSwgY3JlYXRlRGltZW5zaW9uT3B0aW9ucyk7XG4gIHZhciBmaXJzdENhdGVnb3J5RGltSW5kZXggPSBpbmplY3RPcmRpbmFsTWV0YShzY2hlbWEuZGltZW5zaW9ucywgb3B0LmNyZWF0ZUludmVydGVkSW5kaWNlcywgY29vcmRTeXNJbmZvKTtcbiAgdmFyIHN0b3JlID0gIWlzT3JpZ2luYWxTb3VyY2UgPyBzb3VyY2VNYW5hZ2VyLmdldFNoYXJlZERhdGFTdG9yZShzY2hlbWEpIDogbnVsbDtcbiAgdmFyIHN0YWNrQ2FsY3VsYXRpb25JbmZvID0gZW5hYmxlRGF0YVN0YWNrKHNlcmllc01vZGVsLCB7XG4gICAgc2NoZW1hOiBzY2hlbWEsXG4gICAgc3RvcmU6IHN0b3JlXG4gIH0pO1xuICB2YXIgZGF0YSA9IG5ldyBTZXJpZXNEYXRhKHNjaGVtYSwgc2VyaWVzTW9kZWwpO1xuICBkYXRhLnNldENhbGN1bGF0aW9uSW5mbyhzdGFja0NhbGN1bGF0aW9uSW5mbyk7XG4gIHZhciBkaW1WYWx1ZUdldHRlciA9IGZpcnN0Q2F0ZWdvcnlEaW1JbmRleCAhPSBudWxsICYmIGlzTmVlZENvbXBsZXRlT3JkaW5hbERhdGEoc291cmNlKSA/IGZ1bmN0aW9uIChpdGVtT3B0LCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgLy8gVXNlIGRhdGFJbmRleCBhcyBvcmRpbmFsIHZhbHVlIGluIGNhdGVnb3J5QXhpc1xuICAgIHJldHVybiBkaW1JbmRleCA9PT0gZmlyc3RDYXRlZ29yeURpbUluZGV4ID8gZGF0YUluZGV4IDogdGhpcy5kZWZhdWx0RGltVmFsdWVHZXR0ZXIoaXRlbU9wdCwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCk7XG4gIH0gOiBudWxsO1xuICBkYXRhLmhhc0l0ZW1PcHRpb24gPSBmYWxzZTtcbiAgZGF0YS5pbml0RGF0YShcbiAgLy8gVHJ5IHRvIHJldXNlIHRoZSBkYXRhIHN0b3JlIGluIHNvdXJjZU1hbmFnZXIgaWYgdXNpbmcgZGF0YXNldC5cbiAgaXNPcmlnaW5hbFNvdXJjZSA/IHNvdXJjZSA6IHN0b3JlLCBudWxsLCBkaW1WYWx1ZUdldHRlcik7XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gaXNOZWVkQ29tcGxldGVPcmRpbmFsRGF0YShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZS5zb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfT1JJR0lOQUwpIHtcbiAgICB2YXIgc2FtcGxlSXRlbSA9IGZpcnN0RGF0YU5vdE51bGwoc291cmNlLmRhdGEgfHwgW10pO1xuICAgIHJldHVybiAhenJVdGlsLmlzQXJyYXkoZ2V0RGF0YUl0ZW1WYWx1ZShzYW1wbGVJdGVtKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpcnN0RGF0YU5vdE51bGwoYXJyKSB7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBhcnIubGVuZ3RoICYmIGFycltpXSA9PSBudWxsKSB7XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBhcnJbaV07XG59XG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTZXJpZXNEYXRhOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13637\n')},15501:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   n: () => (/* binding */ WhiskerBoxCommonMixin)\n/* harmony export */ });\n/* harmony import */ var _createSeriesDataSimply_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72731);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _data_helper_dimensionHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29756);\n/* harmony import */ var _data_helper_sourceHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23071);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar WhiskerBoxCommonMixin = /** @class */function () {\n  function WhiskerBoxCommonMixin() {}\n  /**\r\n   * @private\r\n   */\n  WhiskerBoxCommonMixin.prototype._hasEncodeRule = function (key) {\n    var encodeRules = this.getEncode();\n    return encodeRules && encodeRules.get(key) != null;\n  };\n  /**\r\n   * @override\r\n   */\n  WhiskerBoxCommonMixin.prototype.getInitialData = function (option, ecModel) {\n    // When both types of xAxis and yAxis are 'value', layout is\n    // needed to be specified by user. Otherwise, layout can be\n    // judged by which axis is category.\n    var ordinalMeta;\n    var xAxisModel = ecModel.getComponent('xAxis', this.get('xAxisIndex'));\n    var yAxisModel = ecModel.getComponent('yAxis', this.get('yAxisIndex'));\n    var xAxisType = xAxisModel.get('type');\n    var yAxisType = yAxisModel.get('type');\n    var addOrdinal;\n    // FIXME\n    // Consider time axis.\n    if (xAxisType === 'category') {\n      option.layout = 'horizontal';\n      ordinalMeta = xAxisModel.getOrdinalMeta();\n      addOrdinal = !this._hasEncodeRule('x');\n    } else if (yAxisType === 'category') {\n      option.layout = 'vertical';\n      ordinalMeta = yAxisModel.getOrdinalMeta();\n      addOrdinal = !this._hasEncodeRule('y');\n    } else {\n      option.layout = option.layout || 'horizontal';\n    }\n    var coordDims = ['x', 'y'];\n    var baseAxisDimIndex = option.layout === 'horizontal' ? 0 : 1;\n    var baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];\n    var otherAxisDim = coordDims[1 - baseAxisDimIndex];\n    var axisModels = [xAxisModel, yAxisModel];\n    var baseAxisType = axisModels[baseAxisDimIndex].get('type');\n    var otherAxisType = axisModels[1 - baseAxisDimIndex].get('type');\n    var data = option.data;\n    // Clone a new data for next setOption({}) usage.\n    // Avoid modifying current data will affect further update.\n    if (data && addOrdinal) {\n      var newOptionData_1 = [];\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(data, function (item, index) {\n        var newItem;\n        if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray(item)) {\n          newItem = item.slice();\n          // Modify current using data.\n          item.unshift(index);\n        } else if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray(item.value)) {\n          newItem = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend({}, item);\n          newItem.value = newItem.value.slice();\n          // Modify current using data.\n          item.value.unshift(index);\n        } else {\n          newItem = item;\n        }\n        newOptionData_1.push(newItem);\n      });\n      option.data = newOptionData_1;\n    }\n    var defaultValueDimensions = this.defaultValueDimensions;\n    var coordDimensions = [{\n      name: baseAxisDim,\n      type: (0,_data_helper_dimensionHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .getDimensionTypeByAxis */ .B)(baseAxisType),\n      ordinalMeta: ordinalMeta,\n      otherDims: {\n        tooltip: false,\n        itemName: 0\n      },\n      dimsDef: ['base']\n    }, {\n      name: otherAxisDim,\n      type: (0,_data_helper_dimensionHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .getDimensionTypeByAxis */ .B)(otherAxisType),\n      dimsDef: defaultValueDimensions.slice()\n    }];\n    return (0,_createSeriesDataSimply_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A)(this, {\n      coordDimensions: coordDimensions,\n      dimensionsCount: defaultValueDimensions.length + 1,\n      encodeDefaulter: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.curry(_data_helper_sourceHelper_js__WEBPACK_IMPORTED_MODULE_3__/* .makeSeriesEncodeForAxisCoordSys */ .OC, coordDimensions, this)\n    });\n  };\n  /**\r\n   * If horizontal, base axis is x, otherwise y.\r\n   * @override\r\n   */\n  WhiskerBoxCommonMixin.prototype.getBaseAxis = function () {\n    var dim = this._baseAxisDim;\n    return this.ecModel.getComponent(dim + 'Axis', this.get(dim + 'AxisIndex')).axis;\n  };\n  return WhiskerBoxCommonMixin;\n}();\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU1MDEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvd2hpc2tlckJveENvbW1vbi5qcz9lNGQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IGNyZWF0ZVNlcmllc0RhdGFTaW1wbHkgZnJvbSAnLi9jcmVhdGVTZXJpZXNEYXRhU2ltcGx5LmpzJztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgZ2V0RGltZW5zaW9uVHlwZUJ5QXhpcyB9IGZyb20gJy4uLy4uL2RhdGEvaGVscGVyL2RpbWVuc2lvbkhlbHBlci5qcyc7XG5pbXBvcnQgeyBtYWtlU2VyaWVzRW5jb2RlRm9yQXhpc0Nvb3JkU3lzIH0gZnJvbSAnLi4vLi4vZGF0YS9oZWxwZXIvc291cmNlSGVscGVyLmpzJztcbnZhciBXaGlza2VyQm94Q29tbW9uTWl4aW4gPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXaGlza2VyQm94Q29tbW9uTWl4aW4oKSB7fVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBXaGlza2VyQm94Q29tbW9uTWl4aW4ucHJvdG90eXBlLl9oYXNFbmNvZGVSdWxlID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbmNvZGVSdWxlcyA9IHRoaXMuZ2V0RW5jb2RlKCk7XG4gICAgcmV0dXJuIGVuY29kZVJ1bGVzICYmIGVuY29kZVJ1bGVzLmdldChrZXkpICE9IG51bGw7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBXaGlza2VyQm94Q29tbW9uTWl4aW4ucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIC8vIFdoZW4gYm90aCB0eXBlcyBvZiB4QXhpcyBhbmQgeUF4aXMgYXJlICd2YWx1ZScsIGxheW91dCBpc1xuICAgIC8vIG5lZWRlZCB0byBiZSBzcGVjaWZpZWQgYnkgdXNlci4gT3RoZXJ3aXNlLCBsYXlvdXQgY2FuIGJlXG4gICAgLy8ganVkZ2VkIGJ5IHdoaWNoIGF4aXMgaXMgY2F0ZWdvcnkuXG4gICAgdmFyIG9yZGluYWxNZXRhO1xuICAgIHZhciB4QXhpc01vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3hBeGlzJywgdGhpcy5nZXQoJ3hBeGlzSW5kZXgnKSk7XG4gICAgdmFyIHlBeGlzTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgneUF4aXMnLCB0aGlzLmdldCgneUF4aXNJbmRleCcpKTtcbiAgICB2YXIgeEF4aXNUeXBlID0geEF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgeUF4aXNUeXBlID0geUF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgYWRkT3JkaW5hbDtcbiAgICAvLyBGSVhNRVxuICAgIC8vIENvbnNpZGVyIHRpbWUgYXhpcy5cbiAgICBpZiAoeEF4aXNUeXBlID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICBvcHRpb24ubGF5b3V0ID0gJ2hvcml6b250YWwnO1xuICAgICAgb3JkaW5hbE1ldGEgPSB4QXhpc01vZGVsLmdldE9yZGluYWxNZXRhKCk7XG4gICAgICBhZGRPcmRpbmFsID0gIXRoaXMuX2hhc0VuY29kZVJ1bGUoJ3gnKTtcbiAgICB9IGVsc2UgaWYgKHlBeGlzVHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgb3B0aW9uLmxheW91dCA9ICd2ZXJ0aWNhbCc7XG4gICAgICBvcmRpbmFsTWV0YSA9IHlBeGlzTW9kZWwuZ2V0T3JkaW5hbE1ldGEoKTtcbiAgICAgIGFkZE9yZGluYWwgPSAhdGhpcy5faGFzRW5jb2RlUnVsZSgneScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb24ubGF5b3V0ID0gb3B0aW9uLmxheW91dCB8fCAnaG9yaXpvbnRhbCc7XG4gICAgfVxuICAgIHZhciBjb29yZERpbXMgPSBbJ3gnLCAneSddO1xuICAgIHZhciBiYXNlQXhpc0RpbUluZGV4ID0gb3B0aW9uLmxheW91dCA9PT0gJ2hvcml6b250YWwnID8gMCA6IDE7XG4gICAgdmFyIGJhc2VBeGlzRGltID0gdGhpcy5fYmFzZUF4aXNEaW0gPSBjb29yZERpbXNbYmFzZUF4aXNEaW1JbmRleF07XG4gICAgdmFyIG90aGVyQXhpc0RpbSA9IGNvb3JkRGltc1sxIC0gYmFzZUF4aXNEaW1JbmRleF07XG4gICAgdmFyIGF4aXNNb2RlbHMgPSBbeEF4aXNNb2RlbCwgeUF4aXNNb2RlbF07XG4gICAgdmFyIGJhc2VBeGlzVHlwZSA9IGF4aXNNb2RlbHNbYmFzZUF4aXNEaW1JbmRleF0uZ2V0KCd0eXBlJyk7XG4gICAgdmFyIG90aGVyQXhpc1R5cGUgPSBheGlzTW9kZWxzWzEgLSBiYXNlQXhpc0RpbUluZGV4XS5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgZGF0YSA9IG9wdGlvbi5kYXRhO1xuICAgIC8vIENsb25lIGEgbmV3IGRhdGEgZm9yIG5leHQgc2V0T3B0aW9uKHt9KSB1c2FnZS5cbiAgICAvLyBBdm9pZCBtb2RpZnlpbmcgY3VycmVudCBkYXRhIHdpbGwgYWZmZWN0IGZ1cnRoZXIgdXBkYXRlLlxuICAgIGlmIChkYXRhICYmIGFkZE9yZGluYWwpIHtcbiAgICAgIHZhciBuZXdPcHRpb25EYXRhXzEgPSBbXTtcbiAgICAgIHpyVXRpbC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICB2YXIgbmV3SXRlbTtcbiAgICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgbmV3SXRlbSA9IGl0ZW0uc2xpY2UoKTtcbiAgICAgICAgICAvLyBNb2RpZnkgY3VycmVudCB1c2luZyBkYXRhLlxuICAgICAgICAgIGl0ZW0udW5zaGlmdChpbmRleCk7XG4gICAgICAgIH0gZWxzZSBpZiAoenJVdGlsLmlzQXJyYXkoaXRlbS52YWx1ZSkpIHtcbiAgICAgICAgICBuZXdJdGVtID0genJVdGlsLmV4dGVuZCh7fSwgaXRlbSk7XG4gICAgICAgICAgbmV3SXRlbS52YWx1ZSA9IG5ld0l0ZW0udmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAvLyBNb2RpZnkgY3VycmVudCB1c2luZyBkYXRhLlxuICAgICAgICAgIGl0ZW0udmFsdWUudW5zaGlmdChpbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3SXRlbSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgbmV3T3B0aW9uRGF0YV8xLnB1c2gobmV3SXRlbSk7XG4gICAgICB9KTtcbiAgICAgIG9wdGlvbi5kYXRhID0gbmV3T3B0aW9uRGF0YV8xO1xuICAgIH1cbiAgICB2YXIgZGVmYXVsdFZhbHVlRGltZW5zaW9ucyA9IHRoaXMuZGVmYXVsdFZhbHVlRGltZW5zaW9ucztcbiAgICB2YXIgY29vcmREaW1lbnNpb25zID0gW3tcbiAgICAgIG5hbWU6IGJhc2VBeGlzRGltLFxuICAgICAgdHlwZTogZ2V0RGltZW5zaW9uVHlwZUJ5QXhpcyhiYXNlQXhpc1R5cGUpLFxuICAgICAgb3JkaW5hbE1ldGE6IG9yZGluYWxNZXRhLFxuICAgICAgb3RoZXJEaW1zOiB7XG4gICAgICAgIHRvb2x0aXA6IGZhbHNlLFxuICAgICAgICBpdGVtTmFtZTogMFxuICAgICAgfSxcbiAgICAgIGRpbXNEZWY6IFsnYmFzZSddXG4gICAgfSwge1xuICAgICAgbmFtZTogb3RoZXJBeGlzRGltLFxuICAgICAgdHlwZTogZ2V0RGltZW5zaW9uVHlwZUJ5QXhpcyhvdGhlckF4aXNUeXBlKSxcbiAgICAgIGRpbXNEZWY6IGRlZmF1bHRWYWx1ZURpbWVuc2lvbnMuc2xpY2UoKVxuICAgIH1dO1xuICAgIHJldHVybiBjcmVhdGVTZXJpZXNEYXRhU2ltcGx5KHRoaXMsIHtcbiAgICAgIGNvb3JkRGltZW5zaW9uczogY29vcmREaW1lbnNpb25zLFxuICAgICAgZGltZW5zaW9uc0NvdW50OiBkZWZhdWx0VmFsdWVEaW1lbnNpb25zLmxlbmd0aCArIDEsXG4gICAgICBlbmNvZGVEZWZhdWx0ZXI6IHpyVXRpbC5jdXJyeShtYWtlU2VyaWVzRW5jb2RlRm9yQXhpc0Nvb3JkU3lzLCBjb29yZERpbWVuc2lvbnMsIHRoaXMpXG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIElmIGhvcml6b250YWwsIGJhc2UgYXhpcyBpcyB4LCBvdGhlcndpc2UgeS5cclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgV2hpc2tlckJveENvbW1vbk1peGluLnByb3RvdHlwZS5nZXRCYXNlQXhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGltID0gdGhpcy5fYmFzZUF4aXNEaW07XG4gICAgcmV0dXJuIHRoaXMuZWNNb2RlbC5nZXRDb21wb25lbnQoZGltICsgJ0F4aXMnLCB0aGlzLmdldChkaW0gKyAnQXhpc0luZGV4JykpLmF4aXM7XG4gIH07XG4gIHJldHVybiBXaGlza2VyQm94Q29tbW9uTWl4aW47XG59KCk7XG47XG5leHBvcnQgeyBXaGlza2VyQm94Q29tbW9uTWl4aW4gfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15501\n")},18386:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43870);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5638);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(43199);\n/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10128);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _label_labelStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89632);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx))\n  // We do not set clipShape on group, because it will cut part of\n  // the symbol element shape. We use the same clip shape here as\n  // the line clip.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n  return opt || {};\n}\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  var emphasisModel = seriesModel.getModel('emphasis');\n  return {\n    emphasisItemStyle: emphasisModel.getModel('itemStyle').getItemStyle(),\n    blurItemStyle: seriesModel.getModel(['blur', 'itemStyle']).getItemStyle(),\n    selectItemStyle: seriesModel.getModel(['select', 'itemStyle']).getItemStyle(),\n    focus: emphasisModel.get('focus'),\n    blurScope: emphasisModel.get('blurScope'),\n    emphasisDisabled: emphasisModel.get('disabled'),\n    hoverScale: emphasisModel.get('scale'),\n    labelStatesModels: (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_1__/* .getLabelStatesModels */ .lx)(seriesModel),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\nvar SymbolDraw = /** @class */function () {\n  function SymbolDraw(SymbolCtor) {\n    this.group = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A();\n    this._SymbolCtor = SymbolCtor || _Symbol_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A;\n  }\n  /**\r\n   * Update symbols draw by new data\r\n   */\n  SymbolDraw.prototype.updateData = function (data, opt) {\n    // Remove progressive els.\n    this._progressiveEls = null;\n    opt = normalizeUpdateOpt(opt);\n    var group = this.group;\n    var seriesModel = data.hostModel;\n    var oldData = this._data;\n    var SymbolCtor = this._SymbolCtor;\n    var disableAnimation = opt.disableAnimation;\n    var seriesScope = makeSeriesScope(data);\n    var symbolUpdateOpt = {\n      disableAnimation: disableAnimation\n    };\n    var getSymbolPoint = opt.getSymbolPoint || function (idx) {\n      return data.getItemLayout(idx);\n    };\n    // There is no oldLineData only when first rendering or switching from\n    // stream mode to normal mode, where previous elements should be removed.\n    if (!oldData) {\n      group.removeAll();\n    }\n    data.diff(oldData).add(function (newIdx) {\n      var point = getSymbolPoint(newIdx);\n      if (symbolNeedsDraw(data, point, newIdx, opt)) {\n        var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);\n        symbolEl.setPosition(point);\n        data.setItemGraphicEl(newIdx, symbolEl);\n        group.add(symbolEl);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var symbolEl = oldData.getItemGraphicEl(oldIdx);\n      var point = getSymbolPoint(newIdx);\n      if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n        group.remove(symbolEl);\n        return;\n      }\n      var newSymbolType = data.getItemVisual(newIdx, 'symbol') || 'circle';\n      var oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType();\n      if (!symbolEl\n      // Create a new if symbol type changed.\n      || oldSymbolType && oldSymbolType !== newSymbolType) {\n        group.remove(symbolEl);\n        symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);\n        symbolEl.setPosition(point);\n      } else {\n        symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);\n        var target = {\n          x: point[0],\n          y: point[1]\n        };\n        disableAnimation ? symbolEl.attr(target) : _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__/* .updateProps */ .oi(symbolEl, target, seriesModel);\n      }\n      // Add back\n      group.add(symbolEl);\n      data.setItemGraphicEl(newIdx, symbolEl);\n    }).remove(function (oldIdx) {\n      var el = oldData.getItemGraphicEl(oldIdx);\n      el && el.fadeOut(function () {\n        group.remove(el);\n      }, seriesModel);\n    }).execute();\n    this._getSymbolPoint = getSymbolPoint;\n    this._data = data;\n  };\n  ;\n  SymbolDraw.prototype.updateLayout = function () {\n    var _this = this;\n    var data = this._data;\n    if (data) {\n      // Not use animation\n      data.eachItemGraphicEl(function (el, idx) {\n        var point = _this._getSymbolPoint(idx);\n        el.setPosition(point);\n        el.markRedraw();\n      });\n    }\n  };\n  ;\n  SymbolDraw.prototype.incrementalPrepareUpdate = function (data) {\n    this._seriesScope = makeSeriesScope(data);\n    this._data = null;\n    this.group.removeAll();\n  };\n  ;\n  /**\r\n   * Update symbols draw by new data\r\n   */\n  SymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {\n    // Clear\n    this._progressiveEls = [];\n    opt = normalizeUpdateOpt(opt);\n    function updateIncrementalAndHover(el) {\n      if (!el.isGroup) {\n        el.incremental = true;\n        el.ensureState('emphasis').hoverLayer = true;\n      }\n    }\n    for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n      var point = data.getItemLayout(idx);\n      if (symbolNeedsDraw(data, point, idx, opt)) {\n        var el = new this._SymbolCtor(data, idx, this._seriesScope);\n        el.traverse(updateIncrementalAndHover);\n        el.setPosition(point);\n        this.group.add(el);\n        data.setItemGraphicEl(idx, el);\n        this._progressiveEls.push(el);\n      }\n    }\n  };\n  ;\n  SymbolDraw.prototype.eachRendered = function (cb) {\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__.traverseElements(this._progressiveEls || this.group, cb);\n  };\n  SymbolDraw.prototype.remove = function (enableAnimation) {\n    var group = this.group;\n    var data = this._data;\n    // Incremental model do not have this._data.\n    if (data && enableAnimation) {\n      data.eachItemGraphicEl(function (el) {\n        el.fadeOut(function () {\n          group.remove(el);\n        }, data.hostModel);\n      });\n    } else {\n      group.removeAll();\n    }\n  };\n  ;\n  return SymbolDraw;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SymbolDraw);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgzODYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3LmpzP2MzZjQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgU3ltYm9sQ2x6IGZyb20gJy4vU3ltYm9sLmpzJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGdldExhYmVsU3RhdGVzTW9kZWxzIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG5mdW5jdGlvbiBzeW1ib2xOZWVkc0RyYXcoZGF0YSwgcG9pbnQsIGlkeCwgb3B0KSB7XG4gIHJldHVybiBwb2ludCAmJiAhaXNOYU4ocG9pbnRbMF0pICYmICFpc05hTihwb2ludFsxXSkgJiYgIShvcHQuaXNJZ25vcmUgJiYgb3B0LmlzSWdub3JlKGlkeCkpXG4gIC8vIFdlIGRvIG5vdCBzZXQgY2xpcFNoYXBlIG9uIGdyb3VwLCBiZWNhdXNlIGl0IHdpbGwgY3V0IHBhcnQgb2ZcbiAgLy8gdGhlIHN5bWJvbCBlbGVtZW50IHNoYXBlLiBXZSB1c2UgdGhlIHNhbWUgY2xpcCBzaGFwZSBoZXJlIGFzXG4gIC8vIHRoZSBsaW5lIGNsaXAuXG4gICYmICEob3B0LmNsaXBTaGFwZSAmJiAhb3B0LmNsaXBTaGFwZS5jb250YWluKHBvaW50WzBdLCBwb2ludFsxXSkpICYmIGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSAhPT0gJ25vbmUnO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVXBkYXRlT3B0KG9wdCkge1xuICBpZiAob3B0ICE9IG51bGwgJiYgIWlzT2JqZWN0KG9wdCkpIHtcbiAgICBvcHQgPSB7XG4gICAgICBpc0lnbm9yZTogb3B0XG4gICAgfTtcbiAgfVxuICByZXR1cm4gb3B0IHx8IHt9O1xufVxuZnVuY3Rpb24gbWFrZVNlcmllc1Njb3BlKGRhdGEpIHtcbiAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gIHZhciBlbXBoYXNpc01vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJyk7XG4gIHJldHVybiB7XG4gICAgZW1waGFzaXNJdGVtU3R5bGU6IGVtcGhhc2lzTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZSgpLFxuICAgIGJsdXJJdGVtU3R5bGU6IHNlcmllc01vZGVsLmdldE1vZGVsKFsnYmx1cicsICdpdGVtU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCksXG4gICAgc2VsZWN0SXRlbVN0eWxlOiBzZXJpZXNNb2RlbC5nZXRNb2RlbChbJ3NlbGVjdCcsICdpdGVtU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCksXG4gICAgZm9jdXM6IGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpLFxuICAgIGJsdXJTY29wZTogZW1waGFzaXNNb2RlbC5nZXQoJ2JsdXJTY29wZScpLFxuICAgIGVtcGhhc2lzRGlzYWJsZWQ6IGVtcGhhc2lzTW9kZWwuZ2V0KCdkaXNhYmxlZCcpLFxuICAgIGhvdmVyU2NhbGU6IGVtcGhhc2lzTW9kZWwuZ2V0KCdzY2FsZScpLFxuICAgIGxhYmVsU3RhdGVzTW9kZWxzOiBnZXRMYWJlbFN0YXRlc01vZGVscyhzZXJpZXNNb2RlbCksXG4gICAgY3Vyc29yU3R5bGU6IHNlcmllc01vZGVsLmdldCgnY3Vyc29yJylcbiAgfTtcbn1cbnZhciBTeW1ib2xEcmF3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3ltYm9sRHJhdyhTeW1ib2xDdG9yKSB7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgdGhpcy5fU3ltYm9sQ3RvciA9IFN5bWJvbEN0b3IgfHwgU3ltYm9sQ2x6O1xuICB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBzeW1ib2xzIGRyYXcgYnkgbmV3IGRhdGFcclxuICAgKi9cbiAgU3ltYm9sRHJhdy5wcm90b3R5cGUudXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBvcHQpIHtcbiAgICAvLyBSZW1vdmUgcHJvZ3Jlc3NpdmUgZWxzLlxuICAgIHRoaXMuX3Byb2dyZXNzaXZlRWxzID0gbnVsbDtcbiAgICBvcHQgPSBub3JtYWxpemVVcGRhdGVPcHQob3B0KTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgU3ltYm9sQ3RvciA9IHRoaXMuX1N5bWJvbEN0b3I7XG4gICAgdmFyIGRpc2FibGVBbmltYXRpb24gPSBvcHQuZGlzYWJsZUFuaW1hdGlvbjtcbiAgICB2YXIgc2VyaWVzU2NvcGUgPSBtYWtlU2VyaWVzU2NvcGUoZGF0YSk7XG4gICAgdmFyIHN5bWJvbFVwZGF0ZU9wdCA9IHtcbiAgICAgIGRpc2FibGVBbmltYXRpb246IGRpc2FibGVBbmltYXRpb25cbiAgICB9O1xuICAgIHZhciBnZXRTeW1ib2xQb2ludCA9IG9wdC5nZXRTeW1ib2xQb2ludCB8fCBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICByZXR1cm4gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgfTtcbiAgICAvLyBUaGVyZSBpcyBubyBvbGRMaW5lRGF0YSBvbmx5IHdoZW4gZmlyc3QgcmVuZGVyaW5nIG9yIHN3aXRjaGluZyBmcm9tXG4gICAgLy8gc3RyZWFtIG1vZGUgdG8gbm9ybWFsIG1vZGUsIHdoZXJlIHByZXZpb3VzIGVsZW1lbnRzIHNob3VsZCBiZSByZW1vdmVkLlxuICAgIGlmICghb2xkRGF0YSkge1xuICAgICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgfVxuICAgIGRhdGEuZGlmZihvbGREYXRhKS5hZGQoZnVuY3Rpb24gKG5ld0lkeCkge1xuICAgICAgdmFyIHBvaW50ID0gZ2V0U3ltYm9sUG9pbnQobmV3SWR4KTtcbiAgICAgIGlmIChzeW1ib2xOZWVkc0RyYXcoZGF0YSwgcG9pbnQsIG5ld0lkeCwgb3B0KSkge1xuICAgICAgICB2YXIgc3ltYm9sRWwgPSBuZXcgU3ltYm9sQ3RvcihkYXRhLCBuZXdJZHgsIHNlcmllc1Njb3BlLCBzeW1ib2xVcGRhdGVPcHQpO1xuICAgICAgICBzeW1ib2xFbC5zZXRQb3NpdGlvbihwb2ludCk7XG4gICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIHN5bWJvbEVsKTtcbiAgICAgICAgZ3JvdXAuYWRkKHN5bWJvbEVsKTtcbiAgICAgIH1cbiAgICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICB2YXIgc3ltYm9sRWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICAgIHZhciBwb2ludCA9IGdldFN5bWJvbFBvaW50KG5ld0lkeCk7XG4gICAgICBpZiAoIXN5bWJvbE5lZWRzRHJhdyhkYXRhLCBwb2ludCwgbmV3SWR4LCBvcHQpKSB7XG4gICAgICAgIGdyb3VwLnJlbW92ZShzeW1ib2xFbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTeW1ib2xUeXBlID0gZGF0YS5nZXRJdGVtVmlzdWFsKG5ld0lkeCwgJ3N5bWJvbCcpIHx8ICdjaXJjbGUnO1xuICAgICAgdmFyIG9sZFN5bWJvbFR5cGUgPSBzeW1ib2xFbCAmJiBzeW1ib2xFbC5nZXRTeW1ib2xUeXBlICYmIHN5bWJvbEVsLmdldFN5bWJvbFR5cGUoKTtcbiAgICAgIGlmICghc3ltYm9sRWxcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBpZiBzeW1ib2wgdHlwZSBjaGFuZ2VkLlxuICAgICAgfHwgb2xkU3ltYm9sVHlwZSAmJiBvbGRTeW1ib2xUeXBlICE9PSBuZXdTeW1ib2xUeXBlKSB7XG4gICAgICAgIGdyb3VwLnJlbW92ZShzeW1ib2xFbCk7XG4gICAgICAgIHN5bWJvbEVsID0gbmV3IFN5bWJvbEN0b3IoZGF0YSwgbmV3SWR4LCBzZXJpZXNTY29wZSwgc3ltYm9sVXBkYXRlT3B0KTtcbiAgICAgICAgc3ltYm9sRWwuc2V0UG9zaXRpb24ocG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ltYm9sRWwudXBkYXRlRGF0YShkYXRhLCBuZXdJZHgsIHNlcmllc1Njb3BlLCBzeW1ib2xVcGRhdGVPcHQpO1xuICAgICAgICB2YXIgdGFyZ2V0ID0ge1xuICAgICAgICAgIHg6IHBvaW50WzBdLFxuICAgICAgICAgIHk6IHBvaW50WzFdXG4gICAgICAgIH07XG4gICAgICAgIGRpc2FibGVBbmltYXRpb24gPyBzeW1ib2xFbC5hdHRyKHRhcmdldCkgOiBncmFwaGljLnVwZGF0ZVByb3BzKHN5bWJvbEVsLCB0YXJnZXQsIHNlcmllc01vZGVsKTtcbiAgICAgIH1cbiAgICAgIC8vIEFkZCBiYWNrXG4gICAgICBncm91cC5hZGQoc3ltYm9sRWwpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgc3ltYm9sRWwpO1xuICAgIH0pLnJlbW92ZShmdW5jdGlvbiAob2xkSWR4KSB7XG4gICAgICB2YXIgZWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICAgIGVsICYmIGVsLmZhZGVPdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuICAgIH0pLmV4ZWN1dGUoKTtcbiAgICB0aGlzLl9nZXRTeW1ib2xQb2ludCA9IGdldFN5bWJvbFBvaW50O1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9O1xuICA7XG4gIFN5bWJvbERyYXcucHJvdG90eXBlLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgLy8gTm90IHVzZSBhbmltYXRpb25cbiAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gX3RoaXMuX2dldFN5bWJvbFBvaW50KGlkeCk7XG4gICAgICAgIGVsLnNldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgICAgZWwubWFya1JlZHJhdygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICA7XG4gIFN5bWJvbERyYXcucHJvdG90eXBlLmluY3JlbWVudGFsUHJlcGFyZVVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdGhpcy5fc2VyaWVzU2NvcGUgPSBtYWtlU2VyaWVzU2NvcGUoZGF0YSk7XG4gICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgfTtcbiAgO1xuICAvKipcclxuICAgKiBVcGRhdGUgc3ltYm9scyBkcmF3IGJ5IG5ldyBkYXRhXHJcbiAgICovXG4gIFN5bWJvbERyYXcucHJvdG90eXBlLmluY3JlbWVudGFsVXBkYXRlID0gZnVuY3Rpb24gKHRhc2tQYXJhbXMsIGRhdGEsIG9wdCkge1xuICAgIC8vIENsZWFyXG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVFbHMgPSBbXTtcbiAgICBvcHQgPSBub3JtYWxpemVVcGRhdGVPcHQob3B0KTtcbiAgICBmdW5jdGlvbiB1cGRhdGVJbmNyZW1lbnRhbEFuZEhvdmVyKGVsKSB7XG4gICAgICBpZiAoIWVsLmlzR3JvdXApIHtcbiAgICAgICAgZWwuaW5jcmVtZW50YWwgPSB0cnVlO1xuICAgICAgICBlbC5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKS5ob3ZlckxheWVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaWR4ID0gdGFza1BhcmFtcy5zdGFydDsgaWR4IDwgdGFza1BhcmFtcy5lbmQ7IGlkeCsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICAgIGlmIChzeW1ib2xOZWVkc0RyYXcoZGF0YSwgcG9pbnQsIGlkeCwgb3B0KSkge1xuICAgICAgICB2YXIgZWwgPSBuZXcgdGhpcy5fU3ltYm9sQ3RvcihkYXRhLCBpZHgsIHRoaXMuX3Nlcmllc1Njb3BlKTtcbiAgICAgICAgZWwudHJhdmVyc2UodXBkYXRlSW5jcmVtZW50YWxBbmRIb3Zlcik7XG4gICAgICAgIGVsLnNldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgICAgdGhpcy5ncm91cC5hZGQoZWwpO1xuICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBlbCk7XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzaXZlRWxzLnB1c2goZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgO1xuICBTeW1ib2xEcmF3LnByb3RvdHlwZS5lYWNoUmVuZGVyZWQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICBncmFwaGljLnRyYXZlcnNlRWxlbWVudHModGhpcy5fcHJvZ3Jlc3NpdmVFbHMgfHwgdGhpcy5ncm91cCwgY2IpO1xuICB9O1xuICBTeW1ib2xEcmF3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZW5hYmxlQW5pbWF0aW9uKSB7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgLy8gSW5jcmVtZW50YWwgbW9kZWwgZG8gbm90IGhhdmUgdGhpcy5fZGF0YS5cbiAgICBpZiAoZGF0YSAmJiBlbmFibGVBbmltYXRpb24pIHtcbiAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmZhZGVPdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgIH0sIGRhdGEuaG9zdE1vZGVsKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgICB9XG4gIH07XG4gIDtcbiAgcmV0dXJuIFN5bWJvbERyYXc7XG59KCk7XG5leHBvcnQgZGVmYXVsdCBTeW1ib2xEcmF3OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18386\n")},31331:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(43870);\n/* harmony import */ var _Line_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32182);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _util_symbol_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62103);\n/* harmony import */ var zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(83509);\n/* harmony import */ var zrender_lib_core_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(89259);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * Provide effect for line\r\n */\n\n\n\n\n\n\nvar EffectLine = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(EffectLine, _super);\n  function EffectLine(lineData, idx, seriesScope) {\n    var _this = _super.call(this) || this;\n    _this.add(_this.createLine(lineData, idx, seriesScope));\n    _this._updateEffectSymbol(lineData, idx);\n    return _this;\n  }\n  EffectLine.prototype.createLine = function (lineData, idx, seriesScope) {\n    return new _Line_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A(lineData, idx, seriesScope);\n  };\n  EffectLine.prototype._updateEffectSymbol = function (lineData, idx) {\n    var itemModel = lineData.getItemModel(idx);\n    var effectModel = itemModel.getModel('effect');\n    var size = effectModel.get('symbolSize');\n    var symbolType = effectModel.get('symbol');\n    if (!zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isArray(size)) {\n      size = [size, size];\n    }\n    var lineStyle = lineData.getItemVisual(idx, 'style');\n    var color = effectModel.get('color') || lineStyle && lineStyle.stroke;\n    var symbol = this.childAt(1);\n    if (this._symbolType !== symbolType) {\n      // Remove previous\n      this.remove(symbol);\n      symbol = (0,_util_symbol_js__WEBPACK_IMPORTED_MODULE_3__/* .createSymbol */ .v5)(symbolType, -0.5, -0.5, 1, 1, color);\n      symbol.z2 = 100;\n      symbol.culling = true;\n      this.add(symbol);\n    }\n    // Symbol may be removed if loop is false\n    if (!symbol) {\n      return;\n    }\n    // Shadow color is same with color in default\n    symbol.setStyle('shadowColor', color);\n    symbol.setStyle(effectModel.getItemStyle(['color']));\n    symbol.scaleX = size[0];\n    symbol.scaleY = size[1];\n    symbol.setColor(color);\n    this._symbolType = symbolType;\n    this._symbolScale = size;\n    this._updateEffectAnimation(lineData, effectModel, idx);\n  };\n  EffectLine.prototype._updateEffectAnimation = function (lineData, effectModel, idx) {\n    var symbol = this.childAt(1);\n    if (!symbol) {\n      return;\n    }\n    var points = lineData.getItemLayout(idx);\n    var period = effectModel.get('period') * 1000;\n    var loop = effectModel.get('loop');\n    var roundTrip = effectModel.get('roundTrip');\n    var constantSpeed = effectModel.get('constantSpeed');\n    var delayExpr = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.retrieve(effectModel.get('delay'), function (idx) {\n      return idx / lineData.count() * period / 3;\n    });\n    // Ignore when updating\n    symbol.ignore = true;\n    this._updateAnimationPoints(symbol, points);\n    if (constantSpeed > 0) {\n      period = this._getLineLength(symbol) / constantSpeed * 1000;\n    }\n    if (period !== this._period || loop !== this._loop || roundTrip !== this._roundTrip) {\n      symbol.stopAnimation();\n      var delayNum = void 0;\n      if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isFunction(delayExpr)) {\n        delayNum = delayExpr(idx);\n      } else {\n        delayNum = delayExpr;\n      }\n      if (symbol.__t > 0) {\n        delayNum = -period * symbol.__t;\n      }\n      this._animateSymbol(symbol, period, delayNum, loop, roundTrip);\n    }\n    this._period = period;\n    this._loop = loop;\n    this._roundTrip = roundTrip;\n  };\n  EffectLine.prototype._animateSymbol = function (symbol, period, delayNum, loop, roundTrip) {\n    if (period > 0) {\n      symbol.__t = 0;\n      var self_1 = this;\n      var animator = symbol.animate('', loop).when(roundTrip ? period * 2 : period, {\n        __t: roundTrip ? 2 : 1\n      }).delay(delayNum).during(function () {\n        self_1._updateSymbolPosition(symbol);\n      });\n      if (!loop) {\n        animator.done(function () {\n          self_1.remove(symbol);\n        });\n      }\n      animator.start();\n    }\n  };\n  EffectLine.prototype._getLineLength = function (symbol) {\n    // Not so accurate\n    return zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_4__.dist(symbol.__p1, symbol.__cp1) + zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_4__.dist(symbol.__cp1, symbol.__p2);\n  };\n  EffectLine.prototype._updateAnimationPoints = function (symbol, points) {\n    symbol.__p1 = points[0];\n    symbol.__p2 = points[1];\n    symbol.__cp1 = points[2] || [(points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2];\n  };\n  EffectLine.prototype.updateData = function (lineData, idx, seriesScope) {\n    this.childAt(0).updateData(lineData, idx, seriesScope);\n    this._updateEffectSymbol(lineData, idx);\n  };\n  EffectLine.prototype._updateSymbolPosition = function (symbol) {\n    var p1 = symbol.__p1;\n    var p2 = symbol.__p2;\n    var cp1 = symbol.__cp1;\n    var t = symbol.__t < 1 ? symbol.__t : 2 - symbol.__t;\n    var pos = [symbol.x, symbol.y];\n    var lastPos = pos.slice();\n    var quadraticAt = zrender_lib_core_curve_js__WEBPACK_IMPORTED_MODULE_5__/* .quadraticAt */ .k3;\n    var quadraticDerivativeAt = zrender_lib_core_curve_js__WEBPACK_IMPORTED_MODULE_5__/* .quadraticDerivativeAt */ .z7;\n    pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);\n    pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);\n    // Tangent\n    var tx = symbol.__t < 1 ? quadraticDerivativeAt(p1[0], cp1[0], p2[0], t) : quadraticDerivativeAt(p2[0], cp1[0], p1[0], 1 - t);\n    var ty = symbol.__t < 1 ? quadraticDerivativeAt(p1[1], cp1[1], p2[1], t) : quadraticDerivativeAt(p2[1], cp1[1], p1[1], 1 - t);\n    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\n    // enable continuity trail for 'line', 'rect', 'roundRect' symbolType\n    if (this._symbolType === 'line' || this._symbolType === 'rect' || this._symbolType === 'roundRect') {\n      if (symbol.__lastT !== undefined && symbol.__lastT < symbol.__t) {\n        symbol.scaleY = zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_4__.dist(lastPos, pos) * 1.05;\n        // make sure the last segment render within endPoint\n        if (t === 1) {\n          pos[0] = lastPos[0] + (pos[0] - lastPos[0]) / 2;\n          pos[1] = lastPos[1] + (pos[1] - lastPos[1]) / 2;\n        }\n      } else if (symbol.__lastT === 1) {\n        // After first loop, symbol.__t does NOT start with 0, so connect p1 to pos directly.\n        symbol.scaleY = 2 * zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_4__.dist(p1, pos);\n      } else {\n        symbol.scaleY = this._symbolScale[1];\n      }\n    }\n    symbol.__lastT = symbol.__t;\n    symbol.ignore = false;\n    symbol.x = pos[0];\n    symbol.y = pos[1];\n  };\n  EffectLine.prototype.updateLayout = function (lineData, idx) {\n    this.childAt(0).updateLayout(lineData, idx);\n    var effectModel = lineData.getItemModel(idx).getModel('effect');\n    this._updateEffectAnimation(lineData, effectModel, idx);\n  };\n  return EffectLine;\n}(_util_graphic_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EffectLine);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEzMzEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvRWZmZWN0TGluZS5qcz85MTgyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG4vKipcclxuICogUHJvdmlkZSBlZmZlY3QgZm9yIGxpbmVcclxuICovXG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgTGluZSBmcm9tICcuL0xpbmUuanMnO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTeW1ib2wgfSBmcm9tICcuLi8uLi91dGlsL3N5bWJvbC5qcyc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzJztcbmltcG9ydCAqIGFzIGN1cnZlVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzJztcbnZhciBFZmZlY3RMaW5lID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEVmZmVjdExpbmUsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEVmZmVjdExpbmUobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLmFkZChfdGhpcy5jcmVhdGVMaW5lKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSk7XG4gICAgX3RoaXMuX3VwZGF0ZUVmZmVjdFN5bWJvbChsaW5lRGF0YSwgaWR4KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgRWZmZWN0TGluZS5wcm90b3R5cGUuY3JlYXRlTGluZSA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgIHJldHVybiBuZXcgTGluZShsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG4gIH07XG4gIEVmZmVjdExpbmUucHJvdG90eXBlLl91cGRhdGVFZmZlY3RTeW1ib2wgPSBmdW5jdGlvbiAobGluZURhdGEsIGlkeCkge1xuICAgIHZhciBpdGVtTW9kZWwgPSBsaW5lRGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICB2YXIgZWZmZWN0TW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2VmZmVjdCcpO1xuICAgIHZhciBzaXplID0gZWZmZWN0TW9kZWwuZ2V0KCdzeW1ib2xTaXplJyk7XG4gICAgdmFyIHN5bWJvbFR5cGUgPSBlZmZlY3RNb2RlbC5nZXQoJ3N5bWJvbCcpO1xuICAgIGlmICghenJVdGlsLmlzQXJyYXkoc2l6ZSkpIHtcbiAgICAgIHNpemUgPSBbc2l6ZSwgc2l6ZV07XG4gICAgfVxuICAgIHZhciBsaW5lU3R5bGUgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJyk7XG4gICAgdmFyIGNvbG9yID0gZWZmZWN0TW9kZWwuZ2V0KCdjb2xvcicpIHx8IGxpbmVTdHlsZSAmJiBsaW5lU3R5bGUuc3Ryb2tlO1xuICAgIHZhciBzeW1ib2wgPSB0aGlzLmNoaWxkQXQoMSk7XG4gICAgaWYgKHRoaXMuX3N5bWJvbFR5cGUgIT09IHN5bWJvbFR5cGUpIHtcbiAgICAgIC8vIFJlbW92ZSBwcmV2aW91c1xuICAgICAgdGhpcy5yZW1vdmUoc3ltYm9sKTtcbiAgICAgIHN5bWJvbCA9IGNyZWF0ZVN5bWJvbChzeW1ib2xUeXBlLCAtMC41LCAtMC41LCAxLCAxLCBjb2xvcik7XG4gICAgICBzeW1ib2wuejIgPSAxMDA7XG4gICAgICBzeW1ib2wuY3VsbGluZyA9IHRydWU7XG4gICAgICB0aGlzLmFkZChzeW1ib2wpO1xuICAgIH1cbiAgICAvLyBTeW1ib2wgbWF5IGJlIHJlbW92ZWQgaWYgbG9vcCBpcyBmYWxzZVxuICAgIGlmICghc3ltYm9sKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFNoYWRvdyBjb2xvciBpcyBzYW1lIHdpdGggY29sb3IgaW4gZGVmYXVsdFxuICAgIHN5bWJvbC5zZXRTdHlsZSgnc2hhZG93Q29sb3InLCBjb2xvcik7XG4gICAgc3ltYm9sLnNldFN0eWxlKGVmZmVjdE1vZGVsLmdldEl0ZW1TdHlsZShbJ2NvbG9yJ10pKTtcbiAgICBzeW1ib2wuc2NhbGVYID0gc2l6ZVswXTtcbiAgICBzeW1ib2wuc2NhbGVZID0gc2l6ZVsxXTtcbiAgICBzeW1ib2wuc2V0Q29sb3IoY29sb3IpO1xuICAgIHRoaXMuX3N5bWJvbFR5cGUgPSBzeW1ib2xUeXBlO1xuICAgIHRoaXMuX3N5bWJvbFNjYWxlID0gc2l6ZTtcbiAgICB0aGlzLl91cGRhdGVFZmZlY3RBbmltYXRpb24obGluZURhdGEsIGVmZmVjdE1vZGVsLCBpZHgpO1xuICB9O1xuICBFZmZlY3RMaW5lLnByb3RvdHlwZS5fdXBkYXRlRWZmZWN0QW5pbWF0aW9uID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBlZmZlY3RNb2RlbCwgaWR4KSB7XG4gICAgdmFyIHN5bWJvbCA9IHRoaXMuY2hpbGRBdCgxKTtcbiAgICBpZiAoIXN5bWJvbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcG9pbnRzID0gbGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgIHZhciBwZXJpb2QgPSBlZmZlY3RNb2RlbC5nZXQoJ3BlcmlvZCcpICogMTAwMDtcbiAgICB2YXIgbG9vcCA9IGVmZmVjdE1vZGVsLmdldCgnbG9vcCcpO1xuICAgIHZhciByb3VuZFRyaXAgPSBlZmZlY3RNb2RlbC5nZXQoJ3JvdW5kVHJpcCcpO1xuICAgIHZhciBjb25zdGFudFNwZWVkID0gZWZmZWN0TW9kZWwuZ2V0KCdjb25zdGFudFNwZWVkJyk7XG4gICAgdmFyIGRlbGF5RXhwciA9IHpyVXRpbC5yZXRyaWV2ZShlZmZlY3RNb2RlbC5nZXQoJ2RlbGF5JyksIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHJldHVybiBpZHggLyBsaW5lRGF0YS5jb3VudCgpICogcGVyaW9kIC8gMztcbiAgICB9KTtcbiAgICAvLyBJZ25vcmUgd2hlbiB1cGRhdGluZ1xuICAgIHN5bWJvbC5pZ25vcmUgPSB0cnVlO1xuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdGlvblBvaW50cyhzeW1ib2wsIHBvaW50cyk7XG4gICAgaWYgKGNvbnN0YW50U3BlZWQgPiAwKSB7XG4gICAgICBwZXJpb2QgPSB0aGlzLl9nZXRMaW5lTGVuZ3RoKHN5bWJvbCkgLyBjb25zdGFudFNwZWVkICogMTAwMDtcbiAgICB9XG4gICAgaWYgKHBlcmlvZCAhPT0gdGhpcy5fcGVyaW9kIHx8IGxvb3AgIT09IHRoaXMuX2xvb3AgfHwgcm91bmRUcmlwICE9PSB0aGlzLl9yb3VuZFRyaXApIHtcbiAgICAgIHN5bWJvbC5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICB2YXIgZGVsYXlOdW0gPSB2b2lkIDA7XG4gICAgICBpZiAoenJVdGlsLmlzRnVuY3Rpb24oZGVsYXlFeHByKSkge1xuICAgICAgICBkZWxheU51bSA9IGRlbGF5RXhwcihpZHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsYXlOdW0gPSBkZWxheUV4cHI7XG4gICAgICB9XG4gICAgICBpZiAoc3ltYm9sLl9fdCA+IDApIHtcbiAgICAgICAgZGVsYXlOdW0gPSAtcGVyaW9kICogc3ltYm9sLl9fdDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FuaW1hdGVTeW1ib2woc3ltYm9sLCBwZXJpb2QsIGRlbGF5TnVtLCBsb29wLCByb3VuZFRyaXApO1xuICAgIH1cbiAgICB0aGlzLl9wZXJpb2QgPSBwZXJpb2Q7XG4gICAgdGhpcy5fbG9vcCA9IGxvb3A7XG4gICAgdGhpcy5fcm91bmRUcmlwID0gcm91bmRUcmlwO1xuICB9O1xuICBFZmZlY3RMaW5lLnByb3RvdHlwZS5fYW5pbWF0ZVN5bWJvbCA9IGZ1bmN0aW9uIChzeW1ib2wsIHBlcmlvZCwgZGVsYXlOdW0sIGxvb3AsIHJvdW5kVHJpcCkge1xuICAgIGlmIChwZXJpb2QgPiAwKSB7XG4gICAgICBzeW1ib2wuX190ID0gMDtcbiAgICAgIHZhciBzZWxmXzEgPSB0aGlzO1xuICAgICAgdmFyIGFuaW1hdG9yID0gc3ltYm9sLmFuaW1hdGUoJycsIGxvb3ApLndoZW4ocm91bmRUcmlwID8gcGVyaW9kICogMiA6IHBlcmlvZCwge1xuICAgICAgICBfX3Q6IHJvdW5kVHJpcCA/IDIgOiAxXG4gICAgICB9KS5kZWxheShkZWxheU51bSkuZHVyaW5nKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZl8xLl91cGRhdGVTeW1ib2xQb3NpdGlvbihzeW1ib2wpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWxvb3ApIHtcbiAgICAgICAgYW5pbWF0b3IuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZl8xLnJlbW92ZShzeW1ib2wpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFuaW1hdG9yLnN0YXJ0KCk7XG4gICAgfVxuICB9O1xuICBFZmZlY3RMaW5lLnByb3RvdHlwZS5fZ2V0TGluZUxlbmd0aCA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAvLyBOb3Qgc28gYWNjdXJhdGVcbiAgICByZXR1cm4gdmVjMi5kaXN0KHN5bWJvbC5fX3AxLCBzeW1ib2wuX19jcDEpICsgdmVjMi5kaXN0KHN5bWJvbC5fX2NwMSwgc3ltYm9sLl9fcDIpO1xuICB9O1xuICBFZmZlY3RMaW5lLnByb3RvdHlwZS5fdXBkYXRlQW5pbWF0aW9uUG9pbnRzID0gZnVuY3Rpb24gKHN5bWJvbCwgcG9pbnRzKSB7XG4gICAgc3ltYm9sLl9fcDEgPSBwb2ludHNbMF07XG4gICAgc3ltYm9sLl9fcDIgPSBwb2ludHNbMV07XG4gICAgc3ltYm9sLl9fY3AxID0gcG9pbnRzWzJdIHx8IFsocG9pbnRzWzBdWzBdICsgcG9pbnRzWzFdWzBdKSAvIDIsIChwb2ludHNbMF1bMV0gKyBwb2ludHNbMV1bMV0pIC8gMl07XG4gIH07XG4gIEVmZmVjdExpbmUucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgICB0aGlzLmNoaWxkQXQoMCkudXBkYXRlRGF0YShsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG4gICAgdGhpcy5fdXBkYXRlRWZmZWN0U3ltYm9sKGxpbmVEYXRhLCBpZHgpO1xuICB9O1xuICBFZmZlY3RMaW5lLnByb3RvdHlwZS5fdXBkYXRlU3ltYm9sUG9zaXRpb24gPSBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgdmFyIHAxID0gc3ltYm9sLl9fcDE7XG4gICAgdmFyIHAyID0gc3ltYm9sLl9fcDI7XG4gICAgdmFyIGNwMSA9IHN5bWJvbC5fX2NwMTtcbiAgICB2YXIgdCA9IHN5bWJvbC5fX3QgPCAxID8gc3ltYm9sLl9fdCA6IDIgLSBzeW1ib2wuX190O1xuICAgIHZhciBwb3MgPSBbc3ltYm9sLngsIHN5bWJvbC55XTtcbiAgICB2YXIgbGFzdFBvcyA9IHBvcy5zbGljZSgpO1xuICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlVXRpbC5xdWFkcmF0aWNBdDtcbiAgICB2YXIgcXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gY3VydmVVdGlsLnF1YWRyYXRpY0Rlcml2YXRpdmVBdDtcbiAgICBwb3NbMF0gPSBxdWFkcmF0aWNBdChwMVswXSwgY3AxWzBdLCBwMlswXSwgdCk7XG4gICAgcG9zWzFdID0gcXVhZHJhdGljQXQocDFbMV0sIGNwMVsxXSwgcDJbMV0sIHQpO1xuICAgIC8vIFRhbmdlbnRcbiAgICB2YXIgdHggPSBzeW1ib2wuX190IDwgMSA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMVswXSwgY3AxWzBdLCBwMlswXSwgdCkgOiBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDJbMF0sIGNwMVswXSwgcDFbMF0sIDEgLSB0KTtcbiAgICB2YXIgdHkgPSBzeW1ib2wuX190IDwgMSA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMVsxXSwgY3AxWzFdLCBwMlsxXSwgdCkgOiBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDJbMV0sIGNwMVsxXSwgcDFbMV0sIDEgLSB0KTtcbiAgICBzeW1ib2wucm90YXRpb24gPSAtTWF0aC5hdGFuMih0eSwgdHgpIC0gTWF0aC5QSSAvIDI7XG4gICAgLy8gZW5hYmxlIGNvbnRpbnVpdHkgdHJhaWwgZm9yICdsaW5lJywgJ3JlY3QnLCAncm91bmRSZWN0JyBzeW1ib2xUeXBlXG4gICAgaWYgKHRoaXMuX3N5bWJvbFR5cGUgPT09ICdsaW5lJyB8fCB0aGlzLl9zeW1ib2xUeXBlID09PSAncmVjdCcgfHwgdGhpcy5fc3ltYm9sVHlwZSA9PT0gJ3JvdW5kUmVjdCcpIHtcbiAgICAgIGlmIChzeW1ib2wuX19sYXN0VCAhPT0gdW5kZWZpbmVkICYmIHN5bWJvbC5fX2xhc3RUIDwgc3ltYm9sLl9fdCkge1xuICAgICAgICBzeW1ib2wuc2NhbGVZID0gdmVjMi5kaXN0KGxhc3RQb3MsIHBvcykgKiAxLjA1O1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGxhc3Qgc2VnbWVudCByZW5kZXIgd2l0aGluIGVuZFBvaW50XG4gICAgICAgIGlmICh0ID09PSAxKSB7XG4gICAgICAgICAgcG9zWzBdID0gbGFzdFBvc1swXSArIChwb3NbMF0gLSBsYXN0UG9zWzBdKSAvIDI7XG4gICAgICAgICAgcG9zWzFdID0gbGFzdFBvc1sxXSArIChwb3NbMV0gLSBsYXN0UG9zWzFdKSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3ltYm9sLl9fbGFzdFQgPT09IDEpIHtcbiAgICAgICAgLy8gQWZ0ZXIgZmlyc3QgbG9vcCwgc3ltYm9sLl9fdCBkb2VzIE5PVCBzdGFydCB3aXRoIDAsIHNvIGNvbm5lY3QgcDEgdG8gcG9zIGRpcmVjdGx5LlxuICAgICAgICBzeW1ib2wuc2NhbGVZID0gMiAqIHZlYzIuZGlzdChwMSwgcG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN5bWJvbC5zY2FsZVkgPSB0aGlzLl9zeW1ib2xTY2FsZVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3ltYm9sLl9fbGFzdFQgPSBzeW1ib2wuX190O1xuICAgIHN5bWJvbC5pZ25vcmUgPSBmYWxzZTtcbiAgICBzeW1ib2wueCA9IHBvc1swXTtcbiAgICBzeW1ib2wueSA9IHBvc1sxXTtcbiAgfTtcbiAgRWZmZWN0TGluZS5wcm90b3R5cGUudXBkYXRlTGF5b3V0ID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgpIHtcbiAgICB0aGlzLmNoaWxkQXQoMCkudXBkYXRlTGF5b3V0KGxpbmVEYXRhLCBpZHgpO1xuICAgIHZhciBlZmZlY3RNb2RlbCA9IGxpbmVEYXRhLmdldEl0ZW1Nb2RlbChpZHgpLmdldE1vZGVsKCdlZmZlY3QnKTtcbiAgICB0aGlzLl91cGRhdGVFZmZlY3RBbmltYXRpb24obGluZURhdGEsIGVmZmVjdE1vZGVsLCBpZHgpO1xuICB9O1xuICByZXR1cm4gRWZmZWN0TGluZTtcbn0oZ3JhcGhpYy5Hcm91cCk7XG5leHBvcnQgZGVmYXVsdCBFZmZlY3RMaW5lOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///31331\n")},32182:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ helper_Line)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/vector.js\nvar vector = __webpack_require__(83509);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/symbol.js\nvar symbol = __webpack_require__(62103);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Line.js\nvar Line = __webpack_require__(82861);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/BezierCurve.js\nvar BezierCurve = __webpack_require__(53849);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Path.js\nvar Path = __webpack_require__(59482);\n;// ./node_modules/echarts/lib/chart/helper/LinePath.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * Line path for bezier and straight line draw\r\n */\n\n\nvar straightLineProto = Line/* default */.A.prototype;\nvar bezierCurveProto = BezierCurve/* default */.A.prototype;\nvar StraightLineShape = /** @class */function () {\n  function StraightLineShape() {\n    // Start point\n    this.x1 = 0;\n    this.y1 = 0;\n    // End point\n    this.x2 = 0;\n    this.y2 = 0;\n    this.percent = 1;\n  }\n  return StraightLineShape;\n}();\nvar CurveShape = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(CurveShape, _super);\n  function CurveShape() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  return CurveShape;\n}(StraightLineShape);\nfunction isStraightLine(shape) {\n  return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);\n}\nvar ECLinePath = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ECLinePath, _super);\n  function ECLinePath(opts) {\n    var _this = _super.call(this, opts) || this;\n    _this.type = 'ec-line';\n    return _this;\n  }\n  ECLinePath.prototype.getDefaultStyle = function () {\n    return {\n      stroke: '#000',\n      fill: null\n    };\n  };\n  ECLinePath.prototype.getDefaultShape = function () {\n    return new StraightLineShape();\n  };\n  ECLinePath.prototype.buildPath = function (ctx, shape) {\n    if (isStraightLine(shape)) {\n      straightLineProto.buildPath.call(this, ctx, shape);\n    } else {\n      bezierCurveProto.buildPath.call(this, ctx, shape);\n    }\n  };\n  ECLinePath.prototype.pointAt = function (t) {\n    if (isStraightLine(this.shape)) {\n      return straightLineProto.pointAt.call(this, t);\n    } else {\n      return bezierCurveProto.pointAt.call(this, t);\n    }\n  };\n  ECLinePath.prototype.tangentAt = function (t) {\n    var shape = this.shape;\n    var p = isStraightLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);\n    return vector.normalize(p, p);\n  };\n  return ECLinePath;\n}(Path/* default */.Ay);\n/* harmony default export */ const LinePath = (ECLinePath);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n;// ./node_modules/echarts/lib/chart/helper/Line.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\nvar SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];\nfunction makeSymbolTypeKey(symbolCategory) {\n  return '_' + symbolCategory + 'Type';\n}\nfunction makeSymbolTypeValue(name, lineData, idx) {\n  var symbolType = lineData.getItemVisual(idx, name);\n  if (!symbolType || symbolType === 'none') {\n    return symbolType;\n  }\n  var symbolSize = lineData.getItemVisual(idx, name + 'Size');\n  var symbolRotate = lineData.getItemVisual(idx, name + 'Rotate');\n  var symbolOffset = lineData.getItemVisual(idx, name + 'Offset');\n  var symbolKeepAspect = lineData.getItemVisual(idx, name + 'KeepAspect');\n  var symbolSizeArr = symbol/* normalizeSymbolSize */.xU(symbolSize);\n  var symbolOffsetArr = symbol/* normalizeSymbolOffset */.hV(symbolOffset || 0, symbolSizeArr);\n  return symbolType + symbolSizeArr + symbolOffsetArr + (symbolRotate || '') + (symbolKeepAspect || '');\n}\n/**\r\n * @inner\r\n */\nfunction createSymbol(name, lineData, idx) {\n  var symbolType = lineData.getItemVisual(idx, name);\n  if (!symbolType || symbolType === 'none') {\n    return;\n  }\n  var symbolSize = lineData.getItemVisual(idx, name + 'Size');\n  var symbolRotate = lineData.getItemVisual(idx, name + 'Rotate');\n  var symbolOffset = lineData.getItemVisual(idx, name + 'Offset');\n  var symbolKeepAspect = lineData.getItemVisual(idx, name + 'KeepAspect');\n  var symbolSizeArr = symbol/* normalizeSymbolSize */.xU(symbolSize);\n  var symbolOffsetArr = symbol/* normalizeSymbolOffset */.hV(symbolOffset || 0, symbolSizeArr);\n  var symbolPath = symbol/* createSymbol */.v5(symbolType, -symbolSizeArr[0] / 2 + symbolOffsetArr[0], -symbolSizeArr[1] / 2 + symbolOffsetArr[1], symbolSizeArr[0], symbolSizeArr[1], null, symbolKeepAspect);\n  symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;\n  symbolPath.name = name;\n  return symbolPath;\n}\nfunction createLine(points) {\n  var line = new LinePath({\n    name: 'line',\n    subPixelOptimize: true\n  });\n  setLinePoints(line.shape, points);\n  return line;\n}\nfunction setLinePoints(targetShape, points) {\n  targetShape.x1 = points[0][0];\n  targetShape.y1 = points[0][1];\n  targetShape.x2 = points[1][0];\n  targetShape.y2 = points[1][1];\n  targetShape.percent = 1;\n  var cp1 = points[2];\n  if (cp1) {\n    targetShape.cpx1 = cp1[0];\n    targetShape.cpy1 = cp1[1];\n  } else {\n    targetShape.cpx1 = NaN;\n    targetShape.cpy1 = NaN;\n  }\n}\nvar Line_Line = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(Line, _super);\n  function Line(lineData, idx, seriesScope) {\n    var _this = _super.call(this) || this;\n    _this._createLine(lineData, idx, seriesScope);\n    return _this;\n  }\n  Line.prototype._createLine = function (lineData, idx, seriesScope) {\n    var seriesModel = lineData.hostModel;\n    var linePoints = lineData.getItemLayout(idx);\n    var line = createLine(linePoints);\n    line.shape.percent = 0;\n    basicTransition/* initProps */.LW(line, {\n      shape: {\n        percent: 1\n      }\n    }, seriesModel, idx);\n    this.add(line);\n    (0,util.each)(SYMBOL_CATEGORIES, function (symbolCategory) {\n      var symbol = createSymbol(symbolCategory, lineData, idx);\n      // symbols must added after line to make sure\n      // it will be updated after line#update.\n      // Or symbol position and rotation update in line#beforeUpdate will be one frame slow\n      this.add(symbol);\n      this[makeSymbolTypeKey(symbolCategory)] = makeSymbolTypeValue(symbolCategory, lineData, idx);\n    }, this);\n    this._updateCommonStl(lineData, idx, seriesScope);\n  };\n  // TODO More strict on the List type in parameters?\n  Line.prototype.updateData = function (lineData, idx, seriesScope) {\n    var seriesModel = lineData.hostModel;\n    var line = this.childOfName('line');\n    var linePoints = lineData.getItemLayout(idx);\n    var target = {\n      shape: {}\n    };\n    setLinePoints(target.shape, linePoints);\n    basicTransition/* updateProps */.oi(line, target, seriesModel, idx);\n    (0,util.each)(SYMBOL_CATEGORIES, function (symbolCategory) {\n      var symbolType = makeSymbolTypeValue(symbolCategory, lineData, idx);\n      var key = makeSymbolTypeKey(symbolCategory);\n      // Symbol changed\n      if (this[key] !== symbolType) {\n        this.remove(this.childOfName(symbolCategory));\n        var symbol = createSymbol(symbolCategory, lineData, idx);\n        this.add(symbol);\n      }\n      this[key] = symbolType;\n    }, this);\n    this._updateCommonStl(lineData, idx, seriesScope);\n  };\n  ;\n  Line.prototype.getLinePath = function () {\n    return this.childAt(0);\n  };\n  Line.prototype._updateCommonStl = function (lineData, idx, seriesScope) {\n    var seriesModel = lineData.hostModel;\n    var line = this.childOfName('line');\n    var emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;\n    var blurLineStyle = seriesScope && seriesScope.blurLineStyle;\n    var selectLineStyle = seriesScope && seriesScope.selectLineStyle;\n    var labelStatesModels = seriesScope && seriesScope.labelStatesModels;\n    var emphasisDisabled = seriesScope && seriesScope.emphasisDisabled;\n    var focus = seriesScope && seriesScope.focus;\n    var blurScope = seriesScope && seriesScope.blurScope;\n    // Optimization for large dataset\n    if (!seriesScope || lineData.hasItemOption) {\n      var itemModel = lineData.getItemModel(idx);\n      var emphasisModel = itemModel.getModel('emphasis');\n      emphasisLineStyle = emphasisModel.getModel('lineStyle').getLineStyle();\n      blurLineStyle = itemModel.getModel(['blur', 'lineStyle']).getLineStyle();\n      selectLineStyle = itemModel.getModel(['select', 'lineStyle']).getLineStyle();\n      emphasisDisabled = emphasisModel.get('disabled');\n      focus = emphasisModel.get('focus');\n      blurScope = emphasisModel.get('blurScope');\n      labelStatesModels = (0,labelStyle/* getLabelStatesModels */.lx)(itemModel);\n    }\n    var lineStyle = lineData.getItemVisual(idx, 'style');\n    var visualColor = lineStyle.stroke;\n    line.useStyle(lineStyle);\n    line.style.fill = null;\n    line.style.strokeNoScale = true;\n    line.ensureState('emphasis').style = emphasisLineStyle;\n    line.ensureState('blur').style = blurLineStyle;\n    line.ensureState('select').style = selectLineStyle;\n    // Update symbol\n    (0,util.each)(SYMBOL_CATEGORIES, function (symbolCategory) {\n      var symbol = this.childOfName(symbolCategory);\n      if (symbol) {\n        // Share opacity and color with line.\n        symbol.setColor(visualColor);\n        symbol.style.opacity = lineStyle.opacity;\n        for (var i = 0; i < states/* SPECIAL_STATES */.BV.length; i++) {\n          var stateName = states/* SPECIAL_STATES */.BV[i];\n          var lineState = line.getState(stateName);\n          if (lineState) {\n            var lineStateStyle = lineState.style || {};\n            var state = symbol.ensureState(stateName);\n            var stateStyle = state.style || (state.style = {});\n            if (lineStateStyle.stroke != null) {\n              stateStyle[symbol.__isEmptyBrush ? 'stroke' : 'fill'] = lineStateStyle.stroke;\n            }\n            if (lineStateStyle.opacity != null) {\n              stateStyle.opacity = lineStateStyle.opacity;\n            }\n          }\n        }\n        symbol.markRedraw();\n      }\n    }, this);\n    var rawVal = seriesModel.getRawValue(idx);\n    (0,labelStyle/* setLabelStyle */.qM)(this, labelStatesModels, {\n      labelDataIndex: idx,\n      labelFetcher: {\n        getFormattedLabel: function (dataIndex, stateName) {\n          return seriesModel.getFormattedLabel(dataIndex, stateName, lineData.dataType);\n        }\n      },\n      inheritColor: visualColor || '#000',\n      defaultOpacity: lineStyle.opacity,\n      defaultText: (rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? (0,number/* round */.LI)(rawVal) : rawVal) + ''\n    });\n    var label = this.getTextContent();\n    // Always set `textStyle` even if `normalStyle.text` is null, because default\n    // values have to be set on `normalStyle`.\n    if (label) {\n      var labelNormalModel = labelStatesModels.normal;\n      label.__align = label.style.align;\n      label.__verticalAlign = label.style.verticalAlign;\n      // 'start', 'middle', 'end'\n      label.__position = labelNormalModel.get('position') || 'middle';\n      var distance = labelNormalModel.get('distance');\n      if (!(0,util.isArray)(distance)) {\n        distance = [distance, distance];\n      }\n      label.__labelDistance = distance;\n    }\n    this.setTextConfig({\n      position: null,\n      local: true,\n      inside: false // Can't be inside for stroke element.\n    });\n    (0,states/* toggleHoverEmphasis */.Lm)(this, focus, blurScope, emphasisDisabled);\n  };\n  Line.prototype.highlight = function () {\n    (0,states/* enterEmphasis */.HY)(this);\n  };\n  Line.prototype.downplay = function () {\n    (0,states/* leaveEmphasis */.SD)(this);\n  };\n  Line.prototype.updateLayout = function (lineData, idx) {\n    this.setLinePoints(lineData.getItemLayout(idx));\n  };\n  Line.prototype.setLinePoints = function (points) {\n    var linePath = this.childOfName('line');\n    setLinePoints(linePath.shape, points);\n    linePath.dirty();\n  };\n  Line.prototype.beforeUpdate = function () {\n    var lineGroup = this;\n    var symbolFrom = lineGroup.childOfName('fromSymbol');\n    var symbolTo = lineGroup.childOfName('toSymbol');\n    var label = lineGroup.getTextContent();\n    // Quick reject\n    if (!symbolFrom && !symbolTo && (!label || label.ignore)) {\n      return;\n    }\n    var invScale = 1;\n    var parentNode = this.parent;\n    while (parentNode) {\n      if (parentNode.scaleX) {\n        invScale /= parentNode.scaleX;\n      }\n      parentNode = parentNode.parent;\n    }\n    var line = lineGroup.childOfName('line');\n    // If line not changed\n    // FIXME Parent scale changed\n    if (!this.__dirty && !line.__dirty) {\n      return;\n    }\n    var percent = line.shape.percent;\n    var fromPos = line.pointAt(0);\n    var toPos = line.pointAt(percent);\n    var d = vector.sub([], toPos, fromPos);\n    vector.normalize(d, d);\n    function setSymbolRotation(symbol, percent) {\n      // Fix #12388\n      // when symbol is set to be 'arrow' in markLine,\n      // symbolRotate value will be ignored, and compulsively use tangent angle.\n      // rotate by default if symbol rotation is not specified\n      var specifiedRotation = symbol.__specifiedRotation;\n      if (specifiedRotation == null) {\n        var tangent = line.tangentAt(percent);\n        symbol.attr('rotation', (percent === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));\n      } else {\n        symbol.attr('rotation', specifiedRotation);\n      }\n    }\n    if (symbolFrom) {\n      symbolFrom.setPosition(fromPos);\n      setSymbolRotation(symbolFrom, 0);\n      symbolFrom.scaleX = symbolFrom.scaleY = invScale * percent;\n      symbolFrom.markRedraw();\n    }\n    if (symbolTo) {\n      symbolTo.setPosition(toPos);\n      setSymbolRotation(symbolTo, 1);\n      symbolTo.scaleX = symbolTo.scaleY = invScale * percent;\n      symbolTo.markRedraw();\n    }\n    if (label && !label.ignore) {\n      label.x = label.y = 0;\n      label.originX = label.originY = 0;\n      var textAlign = void 0;\n      var textVerticalAlign = void 0;\n      var distance = label.__labelDistance;\n      var distanceX = distance[0] * invScale;\n      var distanceY = distance[1] * invScale;\n      var halfPercent = percent / 2;\n      var tangent = line.tangentAt(halfPercent);\n      var n = [tangent[1], -tangent[0]];\n      var cp = line.pointAt(halfPercent);\n      if (n[1] > 0) {\n        n[0] = -n[0];\n        n[1] = -n[1];\n      }\n      var dir = tangent[0] < 0 ? -1 : 1;\n      if (label.__position !== 'start' && label.__position !== 'end') {\n        var rotation = -Math.atan2(tangent[1], tangent[0]);\n        if (toPos[0] < fromPos[0]) {\n          rotation = Math.PI + rotation;\n        }\n        label.rotation = rotation;\n      }\n      var dy = void 0;\n      switch (label.__position) {\n        case 'insideStartTop':\n        case 'insideMiddleTop':\n        case 'insideEndTop':\n        case 'middle':\n          dy = -distanceY;\n          textVerticalAlign = 'bottom';\n          break;\n        case 'insideStartBottom':\n        case 'insideMiddleBottom':\n        case 'insideEndBottom':\n          dy = distanceY;\n          textVerticalAlign = 'top';\n          break;\n        default:\n          dy = 0;\n          textVerticalAlign = 'middle';\n      }\n      switch (label.__position) {\n        case 'end':\n          label.x = d[0] * distanceX + toPos[0];\n          label.y = d[1] * distanceY + toPos[1];\n          textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';\n          textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';\n          break;\n        case 'start':\n          label.x = -d[0] * distanceX + fromPos[0];\n          label.y = -d[1] * distanceY + fromPos[1];\n          textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';\n          textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';\n          break;\n        case 'insideStartTop':\n        case 'insideStart':\n        case 'insideStartBottom':\n          label.x = distanceX * dir + fromPos[0];\n          label.y = fromPos[1] + dy;\n          textAlign = tangent[0] < 0 ? 'right' : 'left';\n          label.originX = -distanceX * dir;\n          label.originY = -dy;\n          break;\n        case 'insideMiddleTop':\n        case 'insideMiddle':\n        case 'insideMiddleBottom':\n        case 'middle':\n          label.x = cp[0];\n          label.y = cp[1] + dy;\n          textAlign = 'center';\n          label.originY = -dy;\n          break;\n        case 'insideEndTop':\n        case 'insideEnd':\n        case 'insideEndBottom':\n          label.x = -distanceX * dir + toPos[0];\n          label.y = toPos[1] + dy;\n          textAlign = tangent[0] >= 0 ? 'right' : 'left';\n          label.originX = distanceX * dir;\n          label.originY = -dy;\n          break;\n      }\n      label.scaleX = label.scaleY = invScale;\n      label.setStyle({\n        // Use the user specified text align and baseline first\n        verticalAlign: label.__verticalAlign || textVerticalAlign,\n        align: label.__align || textAlign\n      });\n    }\n  };\n  return Line;\n}(Group/* default */.A);\n/* harmony default export */ const helper_Line = (Line_Line);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIxODIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9MaW5lUGF0aC5qcz9hMjI1Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZS5qcz8zNTlmIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG4vKipcclxuICogTGluZSBwYXRoIGZvciBiZXppZXIgYW5kIHN0cmFpZ2h0IGxpbmUgZHJhd1xyXG4gKi9cbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnenJlbmRlci9saWIvY29yZS92ZWN0b3IuanMnO1xudmFyIHN0cmFpZ2h0TGluZVByb3RvID0gZ3JhcGhpYy5MaW5lLnByb3RvdHlwZTtcbnZhciBiZXppZXJDdXJ2ZVByb3RvID0gZ3JhcGhpYy5CZXppZXJDdXJ2ZS5wcm90b3R5cGU7XG52YXIgU3RyYWlnaHRMaW5lU2hhcGUgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHJhaWdodExpbmVTaGFwZSgpIHtcbiAgICAvLyBTdGFydCBwb2ludFxuICAgIHRoaXMueDEgPSAwO1xuICAgIHRoaXMueTEgPSAwO1xuICAgIC8vIEVuZCBwb2ludFxuICAgIHRoaXMueDIgPSAwO1xuICAgIHRoaXMueTIgPSAwO1xuICAgIHRoaXMucGVyY2VudCA9IDE7XG4gIH1cbiAgcmV0dXJuIFN0cmFpZ2h0TGluZVNoYXBlO1xufSgpO1xudmFyIEN1cnZlU2hhcGUgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ3VydmVTaGFwZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gQ3VydmVTaGFwZSgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgcmV0dXJuIEN1cnZlU2hhcGU7XG59KFN0cmFpZ2h0TGluZVNoYXBlKTtcbmZ1bmN0aW9uIGlzU3RyYWlnaHRMaW5lKHNoYXBlKSB7XG4gIHJldHVybiBpc05hTigrc2hhcGUuY3B4MSkgfHwgaXNOYU4oK3NoYXBlLmNweTEpO1xufVxudmFyIEVDTGluZVBhdGggPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRUNMaW5lUGF0aCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRUNMaW5lUGF0aChvcHRzKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gJ2VjLWxpbmUnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBFQ0xpbmVQYXRoLnByb3RvdHlwZS5nZXREZWZhdWx0U3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgZmlsbDogbnVsbFxuICAgIH07XG4gIH07XG4gIEVDTGluZVBhdGgucHJvdG90eXBlLmdldERlZmF1bHRTaGFwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFN0cmFpZ2h0TGluZVNoYXBlKCk7XG4gIH07XG4gIEVDTGluZVBhdGgucHJvdG90eXBlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgaWYgKGlzU3RyYWlnaHRMaW5lKHNoYXBlKSkge1xuICAgICAgc3RyYWlnaHRMaW5lUHJvdG8uYnVpbGRQYXRoLmNhbGwodGhpcywgY3R4LCBzaGFwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJlemllckN1cnZlUHJvdG8uYnVpbGRQYXRoLmNhbGwodGhpcywgY3R4LCBzaGFwZSk7XG4gICAgfVxuICB9O1xuICBFQ0xpbmVQYXRoLnByb3RvdHlwZS5wb2ludEF0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICBpZiAoaXNTdHJhaWdodExpbmUodGhpcy5zaGFwZSkpIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVQcm90by5wb2ludEF0LmNhbGwodGhpcywgdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiZXppZXJDdXJ2ZVByb3RvLnBvaW50QXQuY2FsbCh0aGlzLCB0KTtcbiAgICB9XG4gIH07XG4gIEVDTGluZVBhdGgucHJvdG90eXBlLnRhbmdlbnRBdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICB2YXIgcCA9IGlzU3RyYWlnaHRMaW5lKHNoYXBlKSA/IFtzaGFwZS54MiAtIHNoYXBlLngxLCBzaGFwZS55MiAtIHNoYXBlLnkxXSA6IGJlemllckN1cnZlUHJvdG8udGFuZ2VudEF0LmNhbGwodGhpcywgdCk7XG4gICAgcmV0dXJuIHZlYzIubm9ybWFsaXplKHAsIHApO1xuICB9O1xuICByZXR1cm4gRUNMaW5lUGF0aDtcbn0oZ3JhcGhpYy5QYXRoKTtcbmV4cG9ydCBkZWZhdWx0IEVDTGluZVBhdGg7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGlzQXJyYXksIGVhY2ggfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgdmVjdG9yIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzJztcbmltcG9ydCAqIGFzIHN5bWJvbFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9zeW1ib2wuanMnO1xuaW1wb3J0IEVDTGluZVBhdGggZnJvbSAnLi9MaW5lUGF0aC5qcyc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyB0b2dnbGVIb3ZlckVtcGhhc2lzLCBlbnRlckVtcGhhc2lzLCBsZWF2ZUVtcGhhc2lzLCBTUEVDSUFMX1NUQVRFUyB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdGVzLmpzJztcbmltcG9ydCB7IGdldExhYmVsU3RhdGVzTW9kZWxzLCBzZXRMYWJlbFN0eWxlIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyLmpzJztcbnZhciBTWU1CT0xfQ0FURUdPUklFUyA9IFsnZnJvbVN5bWJvbCcsICd0b1N5bWJvbCddO1xuZnVuY3Rpb24gbWFrZVN5bWJvbFR5cGVLZXkoc3ltYm9sQ2F0ZWdvcnkpIHtcbiAgcmV0dXJuICdfJyArIHN5bWJvbENhdGVnb3J5ICsgJ1R5cGUnO1xufVxuZnVuY3Rpb24gbWFrZVN5bWJvbFR5cGVWYWx1ZShuYW1lLCBsaW5lRGF0YSwgaWR4KSB7XG4gIHZhciBzeW1ib2xUeXBlID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsIG5hbWUpO1xuICBpZiAoIXN5bWJvbFR5cGUgfHwgc3ltYm9sVHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIHN5bWJvbFR5cGU7XG4gIH1cbiAgdmFyIHN5bWJvbFNpemUgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgbmFtZSArICdTaXplJyk7XG4gIHZhciBzeW1ib2xSb3RhdGUgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgbmFtZSArICdSb3RhdGUnKTtcbiAgdmFyIHN5bWJvbE9mZnNldCA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCBuYW1lICsgJ09mZnNldCcpO1xuICB2YXIgc3ltYm9sS2VlcEFzcGVjdCA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCBuYW1lICsgJ0tlZXBBc3BlY3QnKTtcbiAgdmFyIHN5bWJvbFNpemVBcnIgPSBzeW1ib2xVdGlsLm5vcm1hbGl6ZVN5bWJvbFNpemUoc3ltYm9sU2l6ZSk7XG4gIHZhciBzeW1ib2xPZmZzZXRBcnIgPSBzeW1ib2xVdGlsLm5vcm1hbGl6ZVN5bWJvbE9mZnNldChzeW1ib2xPZmZzZXQgfHwgMCwgc3ltYm9sU2l6ZUFycik7XG4gIHJldHVybiBzeW1ib2xUeXBlICsgc3ltYm9sU2l6ZUFyciArIHN5bWJvbE9mZnNldEFyciArIChzeW1ib2xSb3RhdGUgfHwgJycpICsgKHN5bWJvbEtlZXBBc3BlY3QgfHwgJycpO1xufVxuLyoqXHJcbiAqIEBpbm5lclxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN5bWJvbChuYW1lLCBsaW5lRGF0YSwgaWR4KSB7XG4gIHZhciBzeW1ib2xUeXBlID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsIG5hbWUpO1xuICBpZiAoIXN5bWJvbFR5cGUgfHwgc3ltYm9sVHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzeW1ib2xTaXplID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsIG5hbWUgKyAnU2l6ZScpO1xuICB2YXIgc3ltYm9sUm90YXRlID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsIG5hbWUgKyAnUm90YXRlJyk7XG4gIHZhciBzeW1ib2xPZmZzZXQgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgbmFtZSArICdPZmZzZXQnKTtcbiAgdmFyIHN5bWJvbEtlZXBBc3BlY3QgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgbmFtZSArICdLZWVwQXNwZWN0Jyk7XG4gIHZhciBzeW1ib2xTaXplQXJyID0gc3ltYm9sVXRpbC5ub3JtYWxpemVTeW1ib2xTaXplKHN5bWJvbFNpemUpO1xuICB2YXIgc3ltYm9sT2Zmc2V0QXJyID0gc3ltYm9sVXRpbC5ub3JtYWxpemVTeW1ib2xPZmZzZXQoc3ltYm9sT2Zmc2V0IHx8IDAsIHN5bWJvbFNpemVBcnIpO1xuICB2YXIgc3ltYm9sUGF0aCA9IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sKHN5bWJvbFR5cGUsIC1zeW1ib2xTaXplQXJyWzBdIC8gMiArIHN5bWJvbE9mZnNldEFyclswXSwgLXN5bWJvbFNpemVBcnJbMV0gLyAyICsgc3ltYm9sT2Zmc2V0QXJyWzFdLCBzeW1ib2xTaXplQXJyWzBdLCBzeW1ib2xTaXplQXJyWzFdLCBudWxsLCBzeW1ib2xLZWVwQXNwZWN0KTtcbiAgc3ltYm9sUGF0aC5fX3NwZWNpZmllZFJvdGF0aW9uID0gc3ltYm9sUm90YXRlID09IG51bGwgfHwgaXNOYU4oc3ltYm9sUm90YXRlKSA/IHZvaWQgMCA6ICtzeW1ib2xSb3RhdGUgKiBNYXRoLlBJIC8gMTgwIHx8IDA7XG4gIHN5bWJvbFBhdGgubmFtZSA9IG5hbWU7XG4gIHJldHVybiBzeW1ib2xQYXRoO1xufVxuZnVuY3Rpb24gY3JlYXRlTGluZShwb2ludHMpIHtcbiAgdmFyIGxpbmUgPSBuZXcgRUNMaW5lUGF0aCh7XG4gICAgbmFtZTogJ2xpbmUnLFxuICAgIHN1YlBpeGVsT3B0aW1pemU6IHRydWVcbiAgfSk7XG4gIHNldExpbmVQb2ludHMobGluZS5zaGFwZSwgcG9pbnRzKTtcbiAgcmV0dXJuIGxpbmU7XG59XG5mdW5jdGlvbiBzZXRMaW5lUG9pbnRzKHRhcmdldFNoYXBlLCBwb2ludHMpIHtcbiAgdGFyZ2V0U2hhcGUueDEgPSBwb2ludHNbMF1bMF07XG4gIHRhcmdldFNoYXBlLnkxID0gcG9pbnRzWzBdWzFdO1xuICB0YXJnZXRTaGFwZS54MiA9IHBvaW50c1sxXVswXTtcbiAgdGFyZ2V0U2hhcGUueTIgPSBwb2ludHNbMV1bMV07XG4gIHRhcmdldFNoYXBlLnBlcmNlbnQgPSAxO1xuICB2YXIgY3AxID0gcG9pbnRzWzJdO1xuICBpZiAoY3AxKSB7XG4gICAgdGFyZ2V0U2hhcGUuY3B4MSA9IGNwMVswXTtcbiAgICB0YXJnZXRTaGFwZS5jcHkxID0gY3AxWzFdO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFNoYXBlLmNweDEgPSBOYU47XG4gICAgdGFyZ2V0U2hhcGUuY3B5MSA9IE5hTjtcbiAgfVxufVxudmFyIExpbmUgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTGluZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gTGluZShsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX2NyZWF0ZUxpbmUobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBMaW5lLnByb3RvdHlwZS5fY3JlYXRlTGluZSA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGxpbmVEYXRhLmhvc3RNb2RlbDtcbiAgICB2YXIgbGluZVBvaW50cyA9IGxpbmVEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICB2YXIgbGluZSA9IGNyZWF0ZUxpbmUobGluZVBvaW50cyk7XG4gICAgbGluZS5zaGFwZS5wZXJjZW50ID0gMDtcbiAgICBncmFwaGljLmluaXRQcm9wcyhsaW5lLCB7XG4gICAgICBzaGFwZToge1xuICAgICAgICBwZXJjZW50OiAxXG4gICAgICB9XG4gICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgdGhpcy5hZGQobGluZSk7XG4gICAgZWFjaChTWU1CT0xfQ0FURUdPUklFUywgZnVuY3Rpb24gKHN5bWJvbENhdGVnb3J5KSB7XG4gICAgICB2YXIgc3ltYm9sID0gY3JlYXRlU3ltYm9sKHN5bWJvbENhdGVnb3J5LCBsaW5lRGF0YSwgaWR4KTtcbiAgICAgIC8vIHN5bWJvbHMgbXVzdCBhZGRlZCBhZnRlciBsaW5lIHRvIG1ha2Ugc3VyZVxuICAgICAgLy8gaXQgd2lsbCBiZSB1cGRhdGVkIGFmdGVyIGxpbmUjdXBkYXRlLlxuICAgICAgLy8gT3Igc3ltYm9sIHBvc2l0aW9uIGFuZCByb3RhdGlvbiB1cGRhdGUgaW4gbGluZSNiZWZvcmVVcGRhdGUgd2lsbCBiZSBvbmUgZnJhbWUgc2xvd1xuICAgICAgdGhpcy5hZGQoc3ltYm9sKTtcbiAgICAgIHRoaXNbbWFrZVN5bWJvbFR5cGVLZXkoc3ltYm9sQ2F0ZWdvcnkpXSA9IG1ha2VTeW1ib2xUeXBlVmFsdWUoc3ltYm9sQ2F0ZWdvcnksIGxpbmVEYXRhLCBpZHgpO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX3VwZGF0ZUNvbW1vblN0bChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG4gIH07XG4gIC8vIFRPRE8gTW9yZSBzdHJpY3Qgb24gdGhlIExpc3QgdHlwZSBpbiBwYXJhbWV0ZXJzP1xuICBMaW5lLnByb3RvdHlwZS51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgdmFyIHNlcmllc01vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuICAgIHZhciBsaW5lID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZScpO1xuICAgIHZhciBsaW5lUG9pbnRzID0gbGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICBzaGFwZToge31cbiAgICB9O1xuICAgIHNldExpbmVQb2ludHModGFyZ2V0LnNoYXBlLCBsaW5lUG9pbnRzKTtcbiAgICBncmFwaGljLnVwZGF0ZVByb3BzKGxpbmUsIHRhcmdldCwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgZWFjaChTWU1CT0xfQ0FURUdPUklFUywgZnVuY3Rpb24gKHN5bWJvbENhdGVnb3J5KSB7XG4gICAgICB2YXIgc3ltYm9sVHlwZSA9IG1ha2VTeW1ib2xUeXBlVmFsdWUoc3ltYm9sQ2F0ZWdvcnksIGxpbmVEYXRhLCBpZHgpO1xuICAgICAgdmFyIGtleSA9IG1ha2VTeW1ib2xUeXBlS2V5KHN5bWJvbENhdGVnb3J5KTtcbiAgICAgIC8vIFN5bWJvbCBjaGFuZ2VkXG4gICAgICBpZiAodGhpc1trZXldICE9PSBzeW1ib2xUeXBlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKHRoaXMuY2hpbGRPZk5hbWUoc3ltYm9sQ2F0ZWdvcnkpKTtcbiAgICAgICAgdmFyIHN5bWJvbCA9IGNyZWF0ZVN5bWJvbChzeW1ib2xDYXRlZ29yeSwgbGluZURhdGEsIGlkeCk7XG4gICAgICAgIHRoaXMuYWRkKHN5bWJvbCk7XG4gICAgICB9XG4gICAgICB0aGlzW2tleV0gPSBzeW1ib2xUeXBlO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX3VwZGF0ZUNvbW1vblN0bChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG4gIH07XG4gIDtcbiAgTGluZS5wcm90b3R5cGUuZ2V0TGluZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRBdCgwKTtcbiAgfTtcbiAgTGluZS5wcm90b3R5cGUuX3VwZGF0ZUNvbW1vblN0bCA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGxpbmVEYXRhLmhvc3RNb2RlbDtcbiAgICB2YXIgbGluZSA9IHRoaXMuY2hpbGRPZk5hbWUoJ2xpbmUnKTtcbiAgICB2YXIgZW1waGFzaXNMaW5lU3R5bGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5lbXBoYXNpc0xpbmVTdHlsZTtcbiAgICB2YXIgYmx1ckxpbmVTdHlsZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmJsdXJMaW5lU3R5bGU7XG4gICAgdmFyIHNlbGVjdExpbmVTdHlsZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLnNlbGVjdExpbmVTdHlsZTtcbiAgICB2YXIgbGFiZWxTdGF0ZXNNb2RlbHMgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5sYWJlbFN0YXRlc01vZGVscztcbiAgICB2YXIgZW1waGFzaXNEaXNhYmxlZCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmVtcGhhc2lzRGlzYWJsZWQ7XG4gICAgdmFyIGZvY3VzID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuZm9jdXM7XG4gICAgdmFyIGJsdXJTY29wZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmJsdXJTY29wZTtcbiAgICAvLyBPcHRpbWl6YXRpb24gZm9yIGxhcmdlIGRhdGFzZXRcbiAgICBpZiAoIXNlcmllc1Njb3BlIHx8IGxpbmVEYXRhLmhhc0l0ZW1PcHRpb24pIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBsaW5lRGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgIHZhciBlbXBoYXNpc01vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdlbXBoYXNpcycpO1xuICAgICAgZW1waGFzaXNMaW5lU3R5bGUgPSBlbXBoYXNpc01vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKTtcbiAgICAgIGJsdXJMaW5lU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoWydibHVyJywgJ2xpbmVTdHlsZSddKS5nZXRMaW5lU3R5bGUoKTtcbiAgICAgIHNlbGVjdExpbmVTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChbJ3NlbGVjdCcsICdsaW5lU3R5bGUnXSkuZ2V0TGluZVN0eWxlKCk7XG4gICAgICBlbXBoYXNpc0Rpc2FibGVkID0gZW1waGFzaXNNb2RlbC5nZXQoJ2Rpc2FibGVkJyk7XG4gICAgICBmb2N1cyA9IGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpO1xuICAgICAgYmx1clNjb3BlID0gZW1waGFzaXNNb2RlbC5nZXQoJ2JsdXJTY29wZScpO1xuICAgICAgbGFiZWxTdGF0ZXNNb2RlbHMgPSBnZXRMYWJlbFN0YXRlc01vZGVscyhpdGVtTW9kZWwpO1xuICAgIH1cbiAgICB2YXIgbGluZVN0eWxlID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzdHlsZScpO1xuICAgIHZhciB2aXN1YWxDb2xvciA9IGxpbmVTdHlsZS5zdHJva2U7XG4gICAgbGluZS51c2VTdHlsZShsaW5lU3R5bGUpO1xuICAgIGxpbmUuc3R5bGUuZmlsbCA9IG51bGw7XG4gICAgbGluZS5zdHlsZS5zdHJva2VOb1NjYWxlID0gdHJ1ZTtcbiAgICBsaW5lLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpLnN0eWxlID0gZW1waGFzaXNMaW5lU3R5bGU7XG4gICAgbGluZS5lbnN1cmVTdGF0ZSgnYmx1cicpLnN0eWxlID0gYmx1ckxpbmVTdHlsZTtcbiAgICBsaW5lLmVuc3VyZVN0YXRlKCdzZWxlY3QnKS5zdHlsZSA9IHNlbGVjdExpbmVTdHlsZTtcbiAgICAvLyBVcGRhdGUgc3ltYm9sXG4gICAgZWFjaChTWU1CT0xfQ0FURUdPUklFUywgZnVuY3Rpb24gKHN5bWJvbENhdGVnb3J5KSB7XG4gICAgICB2YXIgc3ltYm9sID0gdGhpcy5jaGlsZE9mTmFtZShzeW1ib2xDYXRlZ29yeSk7XG4gICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgIC8vIFNoYXJlIG9wYWNpdHkgYW5kIGNvbG9yIHdpdGggbGluZS5cbiAgICAgICAgc3ltYm9sLnNldENvbG9yKHZpc3VhbENvbG9yKTtcbiAgICAgICAgc3ltYm9sLnN0eWxlLm9wYWNpdHkgPSBsaW5lU3R5bGUub3BhY2l0eTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTUEVDSUFMX1NUQVRFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzdGF0ZU5hbWUgPSBTUEVDSUFMX1NUQVRFU1tpXTtcbiAgICAgICAgICB2YXIgbGluZVN0YXRlID0gbGluZS5nZXRTdGF0ZShzdGF0ZU5hbWUpO1xuICAgICAgICAgIGlmIChsaW5lU3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lU3RhdGVTdHlsZSA9IGxpbmVTdGF0ZS5zdHlsZSB8fCB7fTtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN5bWJvbC5lbnN1cmVTdGF0ZShzdGF0ZU5hbWUpO1xuICAgICAgICAgICAgdmFyIHN0YXRlU3R5bGUgPSBzdGF0ZS5zdHlsZSB8fCAoc3RhdGUuc3R5bGUgPSB7fSk7XG4gICAgICAgICAgICBpZiAobGluZVN0YXRlU3R5bGUuc3Ryb2tlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc3RhdGVTdHlsZVtzeW1ib2wuX19pc0VtcHR5QnJ1c2ggPyAnc3Ryb2tlJyA6ICdmaWxsJ10gPSBsaW5lU3RhdGVTdHlsZS5zdHJva2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGluZVN0YXRlU3R5bGUub3BhY2l0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHN0YXRlU3R5bGUub3BhY2l0eSA9IGxpbmVTdGF0ZVN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN5bWJvbC5tYXJrUmVkcmF3KCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdmFyIHJhd1ZhbCA9IHNlcmllc01vZGVsLmdldFJhd1ZhbHVlKGlkeCk7XG4gICAgc2V0TGFiZWxTdHlsZSh0aGlzLCBsYWJlbFN0YXRlc01vZGVscywge1xuICAgICAgbGFiZWxEYXRhSW5kZXg6IGlkeCxcbiAgICAgIGxhYmVsRmV0Y2hlcjoge1xuICAgICAgICBnZXRGb3JtYXR0ZWRMYWJlbDogZnVuY3Rpb24gKGRhdGFJbmRleCwgc3RhdGVOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHNlcmllc01vZGVsLmdldEZvcm1hdHRlZExhYmVsKGRhdGFJbmRleCwgc3RhdGVOYW1lLCBsaW5lRGF0YS5kYXRhVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbmhlcml0Q29sb3I6IHZpc3VhbENvbG9yIHx8ICcjMDAwJyxcbiAgICAgIGRlZmF1bHRPcGFjaXR5OiBsaW5lU3R5bGUub3BhY2l0eSxcbiAgICAgIGRlZmF1bHRUZXh0OiAocmF3VmFsID09IG51bGwgPyBsaW5lRGF0YS5nZXROYW1lKGlkeCkgOiBpc0Zpbml0ZShyYXdWYWwpID8gcm91bmQocmF3VmFsKSA6IHJhd1ZhbCkgKyAnJ1xuICAgIH0pO1xuICAgIHZhciBsYWJlbCA9IHRoaXMuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAvLyBBbHdheXMgc2V0IGB0ZXh0U3R5bGVgIGV2ZW4gaWYgYG5vcm1hbFN0eWxlLnRleHRgIGlzIG51bGwsIGJlY2F1c2UgZGVmYXVsdFxuICAgIC8vIHZhbHVlcyBoYXZlIHRvIGJlIHNldCBvbiBgbm9ybWFsU3R5bGVgLlxuICAgIGlmIChsYWJlbCkge1xuICAgICAgdmFyIGxhYmVsTm9ybWFsTW9kZWwgPSBsYWJlbFN0YXRlc01vZGVscy5ub3JtYWw7XG4gICAgICBsYWJlbC5fX2FsaWduID0gbGFiZWwuc3R5bGUuYWxpZ247XG4gICAgICBsYWJlbC5fX3ZlcnRpY2FsQWxpZ24gPSBsYWJlbC5zdHlsZS52ZXJ0aWNhbEFsaWduO1xuICAgICAgLy8gJ3N0YXJ0JywgJ21pZGRsZScsICdlbmQnXG4gICAgICBsYWJlbC5fX3Bvc2l0aW9uID0gbGFiZWxOb3JtYWxNb2RlbC5nZXQoJ3Bvc2l0aW9uJykgfHwgJ21pZGRsZSc7XG4gICAgICB2YXIgZGlzdGFuY2UgPSBsYWJlbE5vcm1hbE1vZGVsLmdldCgnZGlzdGFuY2UnKTtcbiAgICAgIGlmICghaXNBcnJheShkaXN0YW5jZSkpIHtcbiAgICAgICAgZGlzdGFuY2UgPSBbZGlzdGFuY2UsIGRpc3RhbmNlXTtcbiAgICAgIH1cbiAgICAgIGxhYmVsLl9fbGFiZWxEaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH1cbiAgICB0aGlzLnNldFRleHRDb25maWcoe1xuICAgICAgcG9zaXRpb246IG51bGwsXG4gICAgICBsb2NhbDogdHJ1ZSxcbiAgICAgIGluc2lkZTogZmFsc2UgLy8gQ2FuJ3QgYmUgaW5zaWRlIGZvciBzdHJva2UgZWxlbWVudC5cbiAgICB9KTtcbiAgICB0b2dnbGVIb3ZlckVtcGhhc2lzKHRoaXMsIGZvY3VzLCBibHVyU2NvcGUsIGVtcGhhc2lzRGlzYWJsZWQpO1xuICB9O1xuICBMaW5lLnByb3RvdHlwZS5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZW50ZXJFbXBoYXNpcyh0aGlzKTtcbiAgfTtcbiAgTGluZS5wcm90b3R5cGUuZG93bnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGVhdmVFbXBoYXNpcyh0aGlzKTtcbiAgfTtcbiAgTGluZS5wcm90b3R5cGUudXBkYXRlTGF5b3V0ID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgpIHtcbiAgICB0aGlzLnNldExpbmVQb2ludHMobGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpKTtcbiAgfTtcbiAgTGluZS5wcm90b3R5cGUuc2V0TGluZVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICB2YXIgbGluZVBhdGggPSB0aGlzLmNoaWxkT2ZOYW1lKCdsaW5lJyk7XG4gICAgc2V0TGluZVBvaW50cyhsaW5lUGF0aC5zaGFwZSwgcG9pbnRzKTtcbiAgICBsaW5lUGF0aC5kaXJ0eSgpO1xuICB9O1xuICBMaW5lLnByb3RvdHlwZS5iZWZvcmVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpbmVHcm91cCA9IHRoaXM7XG4gICAgdmFyIHN5bWJvbEZyb20gPSBsaW5lR3JvdXAuY2hpbGRPZk5hbWUoJ2Zyb21TeW1ib2wnKTtcbiAgICB2YXIgc3ltYm9sVG8gPSBsaW5lR3JvdXAuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XG4gICAgdmFyIGxhYmVsID0gbGluZUdyb3VwLmdldFRleHRDb250ZW50KCk7XG4gICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgaWYgKCFzeW1ib2xGcm9tICYmICFzeW1ib2xUbyAmJiAoIWxhYmVsIHx8IGxhYmVsLmlnbm9yZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGludlNjYWxlID0gMTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnROb2RlKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS5zY2FsZVgpIHtcbiAgICAgICAgaW52U2NhbGUgLz0gcGFyZW50Tm9kZS5zY2FsZVg7XG4gICAgICB9XG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHZhciBsaW5lID0gbGluZUdyb3VwLmNoaWxkT2ZOYW1lKCdsaW5lJyk7XG4gICAgLy8gSWYgbGluZSBub3QgY2hhbmdlZFxuICAgIC8vIEZJWE1FIFBhcmVudCBzY2FsZSBjaGFuZ2VkXG4gICAgaWYgKCF0aGlzLl9fZGlydHkgJiYgIWxpbmUuX19kaXJ0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGVyY2VudCA9IGxpbmUuc2hhcGUucGVyY2VudDtcbiAgICB2YXIgZnJvbVBvcyA9IGxpbmUucG9pbnRBdCgwKTtcbiAgICB2YXIgdG9Qb3MgPSBsaW5lLnBvaW50QXQocGVyY2VudCk7XG4gICAgdmFyIGQgPSB2ZWN0b3Iuc3ViKFtdLCB0b1BvcywgZnJvbVBvcyk7XG4gICAgdmVjdG9yLm5vcm1hbGl6ZShkLCBkKTtcbiAgICBmdW5jdGlvbiBzZXRTeW1ib2xSb3RhdGlvbihzeW1ib2wsIHBlcmNlbnQpIHtcbiAgICAgIC8vIEZpeCAjMTIzODhcbiAgICAgIC8vIHdoZW4gc3ltYm9sIGlzIHNldCB0byBiZSAnYXJyb3cnIGluIG1hcmtMaW5lLFxuICAgICAgLy8gc3ltYm9sUm90YXRlIHZhbHVlIHdpbGwgYmUgaWdub3JlZCwgYW5kIGNvbXB1bHNpdmVseSB1c2UgdGFuZ2VudCBhbmdsZS5cbiAgICAgIC8vIHJvdGF0ZSBieSBkZWZhdWx0IGlmIHN5bWJvbCByb3RhdGlvbiBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICB2YXIgc3BlY2lmaWVkUm90YXRpb24gPSBzeW1ib2wuX19zcGVjaWZpZWRSb3RhdGlvbjtcbiAgICAgIGlmIChzcGVjaWZpZWRSb3RhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHZhciB0YW5nZW50ID0gbGluZS50YW5nZW50QXQocGVyY2VudCk7XG4gICAgICAgIHN5bWJvbC5hdHRyKCdyb3RhdGlvbicsIChwZXJjZW50ID09PSAxID8gLTEgOiAxKSAqIE1hdGguUEkgLyAyIC0gTWF0aC5hdGFuMih0YW5nZW50WzFdLCB0YW5nZW50WzBdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzeW1ib2wuYXR0cigncm90YXRpb24nLCBzcGVjaWZpZWRSb3RhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzeW1ib2xGcm9tKSB7XG4gICAgICBzeW1ib2xGcm9tLnNldFBvc2l0aW9uKGZyb21Qb3MpO1xuICAgICAgc2V0U3ltYm9sUm90YXRpb24oc3ltYm9sRnJvbSwgMCk7XG4gICAgICBzeW1ib2xGcm9tLnNjYWxlWCA9IHN5bWJvbEZyb20uc2NhbGVZID0gaW52U2NhbGUgKiBwZXJjZW50O1xuICAgICAgc3ltYm9sRnJvbS5tYXJrUmVkcmF3KCk7XG4gICAgfVxuICAgIGlmIChzeW1ib2xUbykge1xuICAgICAgc3ltYm9sVG8uc2V0UG9zaXRpb24odG9Qb3MpO1xuICAgICAgc2V0U3ltYm9sUm90YXRpb24oc3ltYm9sVG8sIDEpO1xuICAgICAgc3ltYm9sVG8uc2NhbGVYID0gc3ltYm9sVG8uc2NhbGVZID0gaW52U2NhbGUgKiBwZXJjZW50O1xuICAgICAgc3ltYm9sVG8ubWFya1JlZHJhdygpO1xuICAgIH1cbiAgICBpZiAobGFiZWwgJiYgIWxhYmVsLmlnbm9yZSkge1xuICAgICAgbGFiZWwueCA9IGxhYmVsLnkgPSAwO1xuICAgICAgbGFiZWwub3JpZ2luWCA9IGxhYmVsLm9yaWdpblkgPSAwO1xuICAgICAgdmFyIHRleHRBbGlnbiA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHZvaWQgMDtcbiAgICAgIHZhciBkaXN0YW5jZSA9IGxhYmVsLl9fbGFiZWxEaXN0YW5jZTtcbiAgICAgIHZhciBkaXN0YW5jZVggPSBkaXN0YW5jZVswXSAqIGludlNjYWxlO1xuICAgICAgdmFyIGRpc3RhbmNlWSA9IGRpc3RhbmNlWzFdICogaW52U2NhbGU7XG4gICAgICB2YXIgaGFsZlBlcmNlbnQgPSBwZXJjZW50IC8gMjtcbiAgICAgIHZhciB0YW5nZW50ID0gbGluZS50YW5nZW50QXQoaGFsZlBlcmNlbnQpO1xuICAgICAgdmFyIG4gPSBbdGFuZ2VudFsxXSwgLXRhbmdlbnRbMF1dO1xuICAgICAgdmFyIGNwID0gbGluZS5wb2ludEF0KGhhbGZQZXJjZW50KTtcbiAgICAgIGlmIChuWzFdID4gMCkge1xuICAgICAgICBuWzBdID0gLW5bMF07XG4gICAgICAgIG5bMV0gPSAtblsxXTtcbiAgICAgIH1cbiAgICAgIHZhciBkaXIgPSB0YW5nZW50WzBdIDwgMCA/IC0xIDogMTtcbiAgICAgIGlmIChsYWJlbC5fX3Bvc2l0aW9uICE9PSAnc3RhcnQnICYmIGxhYmVsLl9fcG9zaXRpb24gIT09ICdlbmQnKSB7XG4gICAgICAgIHZhciByb3RhdGlvbiA9IC1NYXRoLmF0YW4yKHRhbmdlbnRbMV0sIHRhbmdlbnRbMF0pO1xuICAgICAgICBpZiAodG9Qb3NbMF0gPCBmcm9tUG9zWzBdKSB7XG4gICAgICAgICAgcm90YXRpb24gPSBNYXRoLlBJICsgcm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbGFiZWwucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICAgIH1cbiAgICAgIHZhciBkeSA9IHZvaWQgMDtcbiAgICAgIHN3aXRjaCAobGFiZWwuX19wb3NpdGlvbikge1xuICAgICAgICBjYXNlICdpbnNpZGVTdGFydFRvcCc6XG4gICAgICAgIGNhc2UgJ2luc2lkZU1pZGRsZVRvcCc6XG4gICAgICAgIGNhc2UgJ2luc2lkZUVuZFRvcCc6XG4gICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgZHkgPSAtZGlzdGFuY2VZO1xuICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luc2lkZVN0YXJ0Qm90dG9tJzpcbiAgICAgICAgY2FzZSAnaW5zaWRlTWlkZGxlQm90dG9tJzpcbiAgICAgICAgY2FzZSAnaW5zaWRlRW5kQm90dG9tJzpcbiAgICAgICAgICBkeSA9IGRpc3RhbmNlWTtcbiAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICd0b3AnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGR5ID0gMDtcbiAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChsYWJlbC5fX3Bvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgbGFiZWwueCA9IGRbMF0gKiBkaXN0YW5jZVggKyB0b1Bvc1swXTtcbiAgICAgICAgICBsYWJlbC55ID0gZFsxXSAqIGRpc3RhbmNlWSArIHRvUG9zWzFdO1xuICAgICAgICAgIHRleHRBbGlnbiA9IGRbMF0gPiAwLjggPyAnbGVmdCcgOiBkWzBdIDwgLTAuOCA/ICdyaWdodCcgOiAnY2VudGVyJztcbiAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IGRbMV0gPiAwLjggPyAndG9wJyA6IGRbMV0gPCAtMC44ID8gJ2JvdHRvbScgOiAnbWlkZGxlJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgIGxhYmVsLnggPSAtZFswXSAqIGRpc3RhbmNlWCArIGZyb21Qb3NbMF07XG4gICAgICAgICAgbGFiZWwueSA9IC1kWzFdICogZGlzdGFuY2VZICsgZnJvbVBvc1sxXTtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSBkWzBdID4gMC44ID8gJ3JpZ2h0JyA6IGRbMF0gPCAtMC44ID8gJ2xlZnQnIDogJ2NlbnRlcic7XG4gICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSBkWzFdID4gMC44ID8gJ2JvdHRvbScgOiBkWzFdIDwgLTAuOCA/ICd0b3AnIDogJ21pZGRsZSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luc2lkZVN0YXJ0VG9wJzpcbiAgICAgICAgY2FzZSAnaW5zaWRlU3RhcnQnOlxuICAgICAgICBjYXNlICdpbnNpZGVTdGFydEJvdHRvbSc6XG4gICAgICAgICAgbGFiZWwueCA9IGRpc3RhbmNlWCAqIGRpciArIGZyb21Qb3NbMF07XG4gICAgICAgICAgbGFiZWwueSA9IGZyb21Qb3NbMV0gKyBkeTtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSB0YW5nZW50WzBdIDwgMCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgbGFiZWwub3JpZ2luWCA9IC1kaXN0YW5jZVggKiBkaXI7XG4gICAgICAgICAgbGFiZWwub3JpZ2luWSA9IC1keTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5zaWRlTWlkZGxlVG9wJzpcbiAgICAgICAgY2FzZSAnaW5zaWRlTWlkZGxlJzpcbiAgICAgICAgY2FzZSAnaW5zaWRlTWlkZGxlQm90dG9tJzpcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICBsYWJlbC54ID0gY3BbMF07XG4gICAgICAgICAgbGFiZWwueSA9IGNwWzFdICsgZHk7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgbGFiZWwub3JpZ2luWSA9IC1keTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5zaWRlRW5kVG9wJzpcbiAgICAgICAgY2FzZSAnaW5zaWRlRW5kJzpcbiAgICAgICAgY2FzZSAnaW5zaWRlRW5kQm90dG9tJzpcbiAgICAgICAgICBsYWJlbC54ID0gLWRpc3RhbmNlWCAqIGRpciArIHRvUG9zWzBdO1xuICAgICAgICAgIGxhYmVsLnkgPSB0b1Bvc1sxXSArIGR5O1xuICAgICAgICAgIHRleHRBbGlnbiA9IHRhbmdlbnRbMF0gPj0gMCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgbGFiZWwub3JpZ2luWCA9IGRpc3RhbmNlWCAqIGRpcjtcbiAgICAgICAgICBsYWJlbC5vcmlnaW5ZID0gLWR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGFiZWwuc2NhbGVYID0gbGFiZWwuc2NhbGVZID0gaW52U2NhbGU7XG4gICAgICBsYWJlbC5zZXRTdHlsZSh7XG4gICAgICAgIC8vIFVzZSB0aGUgdXNlciBzcGVjaWZpZWQgdGV4dCBhbGlnbiBhbmQgYmFzZWxpbmUgZmlyc3RcbiAgICAgICAgdmVydGljYWxBbGlnbjogbGFiZWwuX192ZXJ0aWNhbEFsaWduIHx8IHRleHRWZXJ0aWNhbEFsaWduLFxuICAgICAgICBhbGlnbjogbGFiZWwuX19hbGlnbiB8fCB0ZXh0QWxpZ25cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIExpbmU7XG59KGdyYXBoaWMuR3JvdXApO1xuZXhwb3J0IGRlZmF1bHQgTGluZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///32182\n")},34747:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $M: () => (/* binding */ createEdgeMapForCurveness),\n/* harmony export */   PH: () => (/* binding */ initCurvenessList),\n/* harmony export */   bj: () => (/* binding */ getCurvenessForEdge)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// @ts-nocheck\n\nvar KEY_DELIMITER = '--\x3e';\n/**\r\n * params handler\r\n * @param {module:echarts/model/SeriesModel} seriesModel\r\n * @returns {*}\r\n */\nvar getAutoCurvenessParams = function (seriesModel) {\n  return seriesModel.get('autoCurveness') || null;\n};\n/**\r\n * Generate a list of edge curvatures, 20 is the default\r\n * @param {module:echarts/model/SeriesModel} seriesModel\r\n * @param {number} appendLength\r\n * @return  20 => [0, -0.2, 0.2, -0.4, 0.4, -0.6, 0.6, -0.8, 0.8, -1, 1, -1.2, 1.2, -1.4, 1.4, -1.6, 1.6, -1.8, 1.8, -2]\r\n */\nvar createCurveness = function (seriesModel, appendLength) {\n  var autoCurvenessParmas = getAutoCurvenessParams(seriesModel);\n  var length = 20;\n  var curvenessList = [];\n  // handler the function set\n  if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(autoCurvenessParmas)) {\n    length = autoCurvenessParmas;\n  } else if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray(autoCurvenessParmas)) {\n    seriesModel.__curvenessList = autoCurvenessParmas;\n    return;\n  }\n  // append length\n  if (appendLength > length) {\n    length = appendLength;\n  }\n  // make sure the length is even\n  var len = length % 2 ? length + 2 : length + 3;\n  curvenessList = [];\n  for (var i = 0; i < len; i++) {\n    curvenessList.push((i % 2 ? i + 1 : i) / 10 * (i % 2 ? -1 : 1));\n  }\n  seriesModel.__curvenessList = curvenessList;\n};\n/**\r\n * Create different cache key data in the positive and negative directions, in order to set the curvature later\r\n * @param {number|string|module:echarts/data/Graph.Node} n1\r\n * @param {number|string|module:echarts/data/Graph.Node} n2\r\n * @param {module:echarts/model/SeriesModel} seriesModel\r\n * @returns {string} key\r\n */\nvar getKeyOfEdges = function (n1, n2, seriesModel) {\n  var source = [n1.id, n1.dataIndex].join('.');\n  var target = [n2.id, n2.dataIndex].join('.');\n  return [seriesModel.uid, source, target].join(KEY_DELIMITER);\n};\n/**\r\n * get opposite key\r\n * @param {string} key\r\n * @returns {string}\r\n */\nvar getOppositeKey = function (key) {\n  var keys = key.split(KEY_DELIMITER);\n  return [keys[0], keys[2], keys[1]].join(KEY_DELIMITER);\n};\n/**\r\n * get edgeMap with key\r\n * @param edge\r\n * @param {module:echarts/model/SeriesModel} seriesModel\r\n */\nvar getEdgeFromMap = function (edge, seriesModel) {\n  var key = getKeyOfEdges(edge.node1, edge.node2, seriesModel);\n  return seriesModel.__edgeMap[key];\n};\n/**\r\n * calculate all cases total length\r\n * @param edge\r\n * @param seriesModel\r\n * @returns {number}\r\n */\nvar getTotalLengthBetweenNodes = function (edge, seriesModel) {\n  var len = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel);\n  var lenV = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel);\n  return len + lenV;\n};\n/**\r\n *\r\n * @param key\r\n */\nvar getEdgeMapLengthWithKey = function (key, seriesModel) {\n  var edgeMap = seriesModel.__edgeMap;\n  return edgeMap[key] ? edgeMap[key].length : 0;\n};\n/**\r\n * Count the number of edges between the same two points, used to obtain the curvature table and the parity of the edge\r\n * @see /graph/GraphSeries.js@getInitialData\r\n * @param {module:echarts/model/SeriesModel} seriesModel\r\n */\nfunction initCurvenessList(seriesModel) {\n  if (!getAutoCurvenessParams(seriesModel)) {\n    return;\n  }\n  seriesModel.__curvenessList = [];\n  seriesModel.__edgeMap = {};\n  // calc the array of curveness List\n  createCurveness(seriesModel);\n}\n/**\r\n * set edgeMap with key\r\n * @param {number|string|module:echarts/data/Graph.Node} n1\r\n * @param {number|string|module:echarts/data/Graph.Node} n2\r\n * @param {module:echarts/model/SeriesModel} seriesModel\r\n * @param {number} index\r\n */\nfunction createEdgeMapForCurveness(n1, n2, seriesModel, index) {\n  if (!getAutoCurvenessParams(seriesModel)) {\n    return;\n  }\n  var key = getKeyOfEdges(n1, n2, seriesModel);\n  var edgeMap = seriesModel.__edgeMap;\n  var oppositeEdges = edgeMap[getOppositeKey(key)];\n  // set direction\n  if (edgeMap[key] && !oppositeEdges) {\n    edgeMap[key].isForward = true;\n  } else if (oppositeEdges && edgeMap[key]) {\n    oppositeEdges.isForward = true;\n    edgeMap[key].isForward = false;\n  }\n  edgeMap[key] = edgeMap[key] || [];\n  edgeMap[key].push(index);\n}\n/**\r\n * get curvature for edge\r\n * @param edge\r\n * @param {module:echarts/model/SeriesModel} seriesModel\r\n * @param index\r\n */\nfunction getCurvenessForEdge(edge, seriesModel, index, needReverse) {\n  var autoCurvenessParams = getAutoCurvenessParams(seriesModel);\n  var isArrayParam = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray(autoCurvenessParams);\n  if (!autoCurvenessParams) {\n    return null;\n  }\n  var edgeArray = getEdgeFromMap(edge, seriesModel);\n  if (!edgeArray) {\n    return null;\n  }\n  var edgeIndex = -1;\n  for (var i = 0; i < edgeArray.length; i++) {\n    if (edgeArray[i] === index) {\n      edgeIndex = i;\n      break;\n    }\n  }\n  // if totalLen is Longer createCurveness\n  var totalLen = getTotalLengthBetweenNodes(edge, seriesModel);\n  createCurveness(seriesModel, totalLen);\n  edge.lineStyle = edge.lineStyle || {};\n  // if is opposite edge, must set curvenss to opposite number\n  var curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel);\n  var curvenessList = seriesModel.__curvenessList;\n  // if pass array no need parity\n  var parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1;\n  if (!edgeArray.isForward) {\n    // the opposite edge show outside\n    var oppositeKey = getOppositeKey(curKey);\n    var len = getEdgeMapLengthWithKey(oppositeKey, seriesModel);\n    var resValue = curvenessList[edgeIndex + len + parityCorrection];\n    // isNeedReverse, simple, force type need reverse the curveness in the junction of the forword and the opposite\n    if (needReverse) {\n      // set as array may make the parity handle with the len of opposite\n      if (isArrayParam) {\n        if (autoCurvenessParams && autoCurvenessParams[0] === 0) {\n          return (len + parityCorrection) % 2 ? resValue : -resValue;\n        } else {\n          return ((len % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue;\n        }\n      } else {\n        return (len + parityCorrection) % 2 ? resValue : -resValue;\n      }\n    } else {\n      return curvenessList[edgeIndex + len + parityCorrection];\n    }\n  } else {\n    return curvenessList[parityCorrection + edgeIndex];\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ3NDcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL211bHRpcGxlR3JhcGhFZGdlSGVscGVyLmpzPzE3NjIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG4vLyBAdHMtbm9jaGVja1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG52YXIgS0VZX0RFTElNSVRFUiA9ICctLT4nO1xuLyoqXHJcbiAqIHBhcmFtcyBoYW5kbGVyXHJcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzTW9kZWx9IHNlcmllc01vZGVsXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cbnZhciBnZXRBdXRvQ3VydmVuZXNzUGFyYW1zID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gIHJldHVybiBzZXJpZXNNb2RlbC5nZXQoJ2F1dG9DdXJ2ZW5lc3MnKSB8fCBudWxsO1xufTtcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIGxpc3Qgb2YgZWRnZSBjdXJ2YXR1cmVzLCAyMCBpcyB0aGUgZGVmYXVsdFxyXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc01vZGVsfSBzZXJpZXNNb2RlbFxyXG4gKiBAcGFyYW0ge251bWJlcn0gYXBwZW5kTGVuZ3RoXHJcbiAqIEByZXR1cm4gIDIwID0+IFswLCAtMC4yLCAwLjIsIC0wLjQsIDAuNCwgLTAuNiwgMC42LCAtMC44LCAwLjgsIC0xLCAxLCAtMS4yLCAxLjIsIC0xLjQsIDEuNCwgLTEuNiwgMS42LCAtMS44LCAxLjgsIC0yXVxyXG4gKi9cbnZhciBjcmVhdGVDdXJ2ZW5lc3MgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGFwcGVuZExlbmd0aCkge1xuICB2YXIgYXV0b0N1cnZlbmVzc1Bhcm1hcyA9IGdldEF1dG9DdXJ2ZW5lc3NQYXJhbXMoc2VyaWVzTW9kZWwpO1xuICB2YXIgbGVuZ3RoID0gMjA7XG4gIHZhciBjdXJ2ZW5lc3NMaXN0ID0gW107XG4gIC8vIGhhbmRsZXIgdGhlIGZ1bmN0aW9uIHNldFxuICBpZiAoenJVdGlsLmlzTnVtYmVyKGF1dG9DdXJ2ZW5lc3NQYXJtYXMpKSB7XG4gICAgbGVuZ3RoID0gYXV0b0N1cnZlbmVzc1Bhcm1hcztcbiAgfSBlbHNlIGlmICh6clV0aWwuaXNBcnJheShhdXRvQ3VydmVuZXNzUGFybWFzKSkge1xuICAgIHNlcmllc01vZGVsLl9fY3VydmVuZXNzTGlzdCA9IGF1dG9DdXJ2ZW5lc3NQYXJtYXM7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGFwcGVuZCBsZW5ndGhcbiAgaWYgKGFwcGVuZExlbmd0aCA+IGxlbmd0aCkge1xuICAgIGxlbmd0aCA9IGFwcGVuZExlbmd0aDtcbiAgfVxuICAvLyBtYWtlIHN1cmUgdGhlIGxlbmd0aCBpcyBldmVuXG4gIHZhciBsZW4gPSBsZW5ndGggJSAyID8gbGVuZ3RoICsgMiA6IGxlbmd0aCArIDM7XG4gIGN1cnZlbmVzc0xpc3QgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGN1cnZlbmVzc0xpc3QucHVzaCgoaSAlIDIgPyBpICsgMSA6IGkpIC8gMTAgKiAoaSAlIDIgPyAtMSA6IDEpKTtcbiAgfVxuICBzZXJpZXNNb2RlbC5fX2N1cnZlbmVzc0xpc3QgPSBjdXJ2ZW5lc3NMaXN0O1xufTtcbi8qKlxyXG4gKiBDcmVhdGUgZGlmZmVyZW50IGNhY2hlIGtleSBkYXRhIGluIHRoZSBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgZGlyZWN0aW9ucywgaW4gb3JkZXIgdG8gc2V0IHRoZSBjdXJ2YXR1cmUgbGF0ZXJcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfG1vZHVsZTplY2hhcnRzL2RhdGEvR3JhcGguTm9kZX0gbjFcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfG1vZHVsZTplY2hhcnRzL2RhdGEvR3JhcGguTm9kZX0gbjJcclxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXNNb2RlbH0gc2VyaWVzTW9kZWxcclxuICogQHJldHVybnMge3N0cmluZ30ga2V5XHJcbiAqL1xudmFyIGdldEtleU9mRWRnZXMgPSBmdW5jdGlvbiAobjEsIG4yLCBzZXJpZXNNb2RlbCkge1xuICB2YXIgc291cmNlID0gW24xLmlkLCBuMS5kYXRhSW5kZXhdLmpvaW4oJy4nKTtcbiAgdmFyIHRhcmdldCA9IFtuMi5pZCwgbjIuZGF0YUluZGV4XS5qb2luKCcuJyk7XG4gIHJldHVybiBbc2VyaWVzTW9kZWwudWlkLCBzb3VyY2UsIHRhcmdldF0uam9pbihLRVlfREVMSU1JVEVSKTtcbn07XG4vKipcclxuICogZ2V0IG9wcG9zaXRlIGtleVxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xudmFyIGdldE9wcG9zaXRlS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICB2YXIga2V5cyA9IGtleS5zcGxpdChLRVlfREVMSU1JVEVSKTtcbiAgcmV0dXJuIFtrZXlzWzBdLCBrZXlzWzJdLCBrZXlzWzFdXS5qb2luKEtFWV9ERUxJTUlURVIpO1xufTtcbi8qKlxyXG4gKiBnZXQgZWRnZU1hcCB3aXRoIGtleVxyXG4gKiBAcGFyYW0gZWRnZVxyXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc01vZGVsfSBzZXJpZXNNb2RlbFxyXG4gKi9cbnZhciBnZXRFZGdlRnJvbU1hcCA9IGZ1bmN0aW9uIChlZGdlLCBzZXJpZXNNb2RlbCkge1xuICB2YXIga2V5ID0gZ2V0S2V5T2ZFZGdlcyhlZGdlLm5vZGUxLCBlZGdlLm5vZGUyLCBzZXJpZXNNb2RlbCk7XG4gIHJldHVybiBzZXJpZXNNb2RlbC5fX2VkZ2VNYXBba2V5XTtcbn07XG4vKipcclxuICogY2FsY3VsYXRlIGFsbCBjYXNlcyB0b3RhbCBsZW5ndGhcclxuICogQHBhcmFtIGVkZ2VcclxuICogQHBhcmFtIHNlcmllc01vZGVsXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xudmFyIGdldFRvdGFsTGVuZ3RoQmV0d2Vlbk5vZGVzID0gZnVuY3Rpb24gKGVkZ2UsIHNlcmllc01vZGVsKSB7XG4gIHZhciBsZW4gPSBnZXRFZGdlTWFwTGVuZ3RoV2l0aEtleShnZXRLZXlPZkVkZ2VzKGVkZ2Uubm9kZTEsIGVkZ2Uubm9kZTIsIHNlcmllc01vZGVsKSwgc2VyaWVzTW9kZWwpO1xuICB2YXIgbGVuViA9IGdldEVkZ2VNYXBMZW5ndGhXaXRoS2V5KGdldEtleU9mRWRnZXMoZWRnZS5ub2RlMiwgZWRnZS5ub2RlMSwgc2VyaWVzTW9kZWwpLCBzZXJpZXNNb2RlbCk7XG4gIHJldHVybiBsZW4gKyBsZW5WO1xufTtcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ga2V5XHJcbiAqL1xudmFyIGdldEVkZ2VNYXBMZW5ndGhXaXRoS2V5ID0gZnVuY3Rpb24gKGtleSwgc2VyaWVzTW9kZWwpIHtcbiAgdmFyIGVkZ2VNYXAgPSBzZXJpZXNNb2RlbC5fX2VkZ2VNYXA7XG4gIHJldHVybiBlZGdlTWFwW2tleV0gPyBlZGdlTWFwW2tleV0ubGVuZ3RoIDogMDtcbn07XG4vKipcclxuICogQ291bnQgdGhlIG51bWJlciBvZiBlZGdlcyBiZXR3ZWVuIHRoZSBzYW1lIHR3byBwb2ludHMsIHVzZWQgdG8gb2J0YWluIHRoZSBjdXJ2YXR1cmUgdGFibGUgYW5kIHRoZSBwYXJpdHkgb2YgdGhlIGVkZ2VcclxuICogQHNlZSAvZ3JhcGgvR3JhcGhTZXJpZXMuanNAZ2V0SW5pdGlhbERhdGFcclxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXNNb2RlbH0gc2VyaWVzTW9kZWxcclxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdEN1cnZlbmVzc0xpc3Qoc2VyaWVzTW9kZWwpIHtcbiAgaWYgKCFnZXRBdXRvQ3VydmVuZXNzUGFyYW1zKHNlcmllc01vZGVsKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzZXJpZXNNb2RlbC5fX2N1cnZlbmVzc0xpc3QgPSBbXTtcbiAgc2VyaWVzTW9kZWwuX19lZGdlTWFwID0ge307XG4gIC8vIGNhbGMgdGhlIGFycmF5IG9mIGN1cnZlbmVzcyBMaXN0XG4gIGNyZWF0ZUN1cnZlbmVzcyhzZXJpZXNNb2RlbCk7XG59XG4vKipcclxuICogc2V0IGVkZ2VNYXAgd2l0aCBrZXlcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfG1vZHVsZTplY2hhcnRzL2RhdGEvR3JhcGguTm9kZX0gbjFcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfG1vZHVsZTplY2hhcnRzL2RhdGEvR3JhcGguTm9kZX0gbjJcclxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXNNb2RlbH0gc2VyaWVzTW9kZWxcclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVkZ2VNYXBGb3JDdXJ2ZW5lc3MobjEsIG4yLCBzZXJpZXNNb2RlbCwgaW5kZXgpIHtcbiAgaWYgKCFnZXRBdXRvQ3VydmVuZXNzUGFyYW1zKHNlcmllc01vZGVsKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIga2V5ID0gZ2V0S2V5T2ZFZGdlcyhuMSwgbjIsIHNlcmllc01vZGVsKTtcbiAgdmFyIGVkZ2VNYXAgPSBzZXJpZXNNb2RlbC5fX2VkZ2VNYXA7XG4gIHZhciBvcHBvc2l0ZUVkZ2VzID0gZWRnZU1hcFtnZXRPcHBvc2l0ZUtleShrZXkpXTtcbiAgLy8gc2V0IGRpcmVjdGlvblxuICBpZiAoZWRnZU1hcFtrZXldICYmICFvcHBvc2l0ZUVkZ2VzKSB7XG4gICAgZWRnZU1hcFtrZXldLmlzRm9yd2FyZCA9IHRydWU7XG4gIH0gZWxzZSBpZiAob3Bwb3NpdGVFZGdlcyAmJiBlZGdlTWFwW2tleV0pIHtcbiAgICBvcHBvc2l0ZUVkZ2VzLmlzRm9yd2FyZCA9IHRydWU7XG4gICAgZWRnZU1hcFtrZXldLmlzRm9yd2FyZCA9IGZhbHNlO1xuICB9XG4gIGVkZ2VNYXBba2V5XSA9IGVkZ2VNYXBba2V5XSB8fCBbXTtcbiAgZWRnZU1hcFtrZXldLnB1c2goaW5kZXgpO1xufVxuLyoqXHJcbiAqIGdldCBjdXJ2YXR1cmUgZm9yIGVkZ2VcclxuICogQHBhcmFtIGVkZ2VcclxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXNNb2RlbH0gc2VyaWVzTW9kZWxcclxuICogQHBhcmFtIGluZGV4XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnZlbmVzc0ZvckVkZ2UoZWRnZSwgc2VyaWVzTW9kZWwsIGluZGV4LCBuZWVkUmV2ZXJzZSkge1xuICB2YXIgYXV0b0N1cnZlbmVzc1BhcmFtcyA9IGdldEF1dG9DdXJ2ZW5lc3NQYXJhbXMoc2VyaWVzTW9kZWwpO1xuICB2YXIgaXNBcnJheVBhcmFtID0genJVdGlsLmlzQXJyYXkoYXV0b0N1cnZlbmVzc1BhcmFtcyk7XG4gIGlmICghYXV0b0N1cnZlbmVzc1BhcmFtcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBlZGdlQXJyYXkgPSBnZXRFZGdlRnJvbU1hcChlZGdlLCBzZXJpZXNNb2RlbCk7XG4gIGlmICghZWRnZUFycmF5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGVkZ2VJbmRleCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlZGdlQXJyYXlbaV0gPT09IGluZGV4KSB7XG4gICAgICBlZGdlSW5kZXggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8vIGlmIHRvdGFsTGVuIGlzIExvbmdlciBjcmVhdGVDdXJ2ZW5lc3NcbiAgdmFyIHRvdGFsTGVuID0gZ2V0VG90YWxMZW5ndGhCZXR3ZWVuTm9kZXMoZWRnZSwgc2VyaWVzTW9kZWwpO1xuICBjcmVhdGVDdXJ2ZW5lc3Moc2VyaWVzTW9kZWwsIHRvdGFsTGVuKTtcbiAgZWRnZS5saW5lU3R5bGUgPSBlZGdlLmxpbmVTdHlsZSB8fCB7fTtcbiAgLy8gaWYgaXMgb3Bwb3NpdGUgZWRnZSwgbXVzdCBzZXQgY3VydmVuc3MgdG8gb3Bwb3NpdGUgbnVtYmVyXG4gIHZhciBjdXJLZXkgPSBnZXRLZXlPZkVkZ2VzKGVkZ2Uubm9kZTEsIGVkZ2Uubm9kZTIsIHNlcmllc01vZGVsKTtcbiAgdmFyIGN1cnZlbmVzc0xpc3QgPSBzZXJpZXNNb2RlbC5fX2N1cnZlbmVzc0xpc3Q7XG4gIC8vIGlmIHBhc3MgYXJyYXkgbm8gbmVlZCBwYXJpdHlcbiAgdmFyIHBhcml0eUNvcnJlY3Rpb24gPSBpc0FycmF5UGFyYW0gPyAwIDogdG90YWxMZW4gJSAyID8gMCA6IDE7XG4gIGlmICghZWRnZUFycmF5LmlzRm9yd2FyZCkge1xuICAgIC8vIHRoZSBvcHBvc2l0ZSBlZGdlIHNob3cgb3V0c2lkZVxuICAgIHZhciBvcHBvc2l0ZUtleSA9IGdldE9wcG9zaXRlS2V5KGN1cktleSk7XG4gICAgdmFyIGxlbiA9IGdldEVkZ2VNYXBMZW5ndGhXaXRoS2V5KG9wcG9zaXRlS2V5LCBzZXJpZXNNb2RlbCk7XG4gICAgdmFyIHJlc1ZhbHVlID0gY3VydmVuZXNzTGlzdFtlZGdlSW5kZXggKyBsZW4gKyBwYXJpdHlDb3JyZWN0aW9uXTtcbiAgICAvLyBpc05lZWRSZXZlcnNlLCBzaW1wbGUsIGZvcmNlIHR5cGUgbmVlZCByZXZlcnNlIHRoZSBjdXJ2ZW5lc3MgaW4gdGhlIGp1bmN0aW9uIG9mIHRoZSBmb3J3b3JkIGFuZCB0aGUgb3Bwb3NpdGVcbiAgICBpZiAobmVlZFJldmVyc2UpIHtcbiAgICAgIC8vIHNldCBhcyBhcnJheSBtYXkgbWFrZSB0aGUgcGFyaXR5IGhhbmRsZSB3aXRoIHRoZSBsZW4gb2Ygb3Bwb3NpdGVcbiAgICAgIGlmIChpc0FycmF5UGFyYW0pIHtcbiAgICAgICAgaWYgKGF1dG9DdXJ2ZW5lc3NQYXJhbXMgJiYgYXV0b0N1cnZlbmVzc1BhcmFtc1swXSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAobGVuICsgcGFyaXR5Q29ycmVjdGlvbikgJSAyID8gcmVzVmFsdWUgOiAtcmVzVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICgobGVuICUgMiA/IDAgOiAxKSArIHBhcml0eUNvcnJlY3Rpb24pICUgMiA/IHJlc1ZhbHVlIDogLXJlc1ZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKGxlbiArIHBhcml0eUNvcnJlY3Rpb24pICUgMiA/IHJlc1ZhbHVlIDogLXJlc1ZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3VydmVuZXNzTGlzdFtlZGdlSW5kZXggKyBsZW4gKyBwYXJpdHlDb3JyZWN0aW9uXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGN1cnZlbmVzc0xpc3RbcGFyaXR5Q29ycmVjdGlvbiArIGVkZ2VJbmRleF07XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///34747\n")},41616:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bl: () => (/* binding */ getPathToRoot),\n/* harmony export */   ev: () => (/* binding */ wrapTreePathInfo),\n/* harmony export */   mw: () => (/* binding */ retrieveTargetInfo),\n/* harmony export */   x5: () => (/* binding */ aboveViewRoot)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction retrieveTargetInfo(payload, validPayloadTypes, seriesModel) {\n  if (payload && zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf(validPayloadTypes, payload.type) >= 0) {\n    var root = seriesModel.getData().tree.root;\n    var targetNode = payload.targetNode;\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString(targetNode)) {\n      targetNode = root.getNodeById(targetNode);\n    }\n    if (targetNode && root.contains(targetNode)) {\n      return {\n        node: targetNode\n      };\n    }\n    var targetNodeId = payload.targetNodeId;\n    if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {\n      return {\n        node: targetNode\n      };\n    }\n  }\n}\n// Not includes the given node at the last item.\nfunction getPathToRoot(node) {\n  var path = [];\n  while (node) {\n    node = node.parentNode;\n    node && path.push(node);\n  }\n  return path.reverse();\n}\nfunction aboveViewRoot(viewRoot, node) {\n  var viewPath = getPathToRoot(viewRoot);\n  return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf(viewPath, node) >= 0;\n}\n// From root to the input node (the input node will be included).\nfunction wrapTreePathInfo(node, seriesModel) {\n  var treePathInfo = [];\n  while (node) {\n    var nodeDataIndex = node.dataIndex;\n    treePathInfo.push({\n      name: node.name,\n      dataIndex: nodeDataIndex,\n      value: seriesModel.getRawValue(nodeDataIndex)\n    });\n    node = node.parentNode;\n  }\n  treePathInfo.reverse();\n  return treePathInfo;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE2MTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL3RyZWVIZWxwZXIuanM/MjdlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHJldHJpZXZlVGFyZ2V0SW5mbyhwYXlsb2FkLCB2YWxpZFBheWxvYWRUeXBlcywgc2VyaWVzTW9kZWwpIHtcbiAgaWYgKHBheWxvYWQgJiYgenJVdGlsLmluZGV4T2YodmFsaWRQYXlsb2FkVHlwZXMsIHBheWxvYWQudHlwZSkgPj0gMCkge1xuICAgIHZhciByb290ID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLnRyZWUucm9vdDtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHBheWxvYWQudGFyZ2V0Tm9kZTtcbiAgICBpZiAoenJVdGlsLmlzU3RyaW5nKHRhcmdldE5vZGUpKSB7XG4gICAgICB0YXJnZXROb2RlID0gcm9vdC5nZXROb2RlQnlJZCh0YXJnZXROb2RlKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldE5vZGUgJiYgcm9vdC5jb250YWlucyh0YXJnZXROb2RlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogdGFyZ2V0Tm9kZVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHRhcmdldE5vZGVJZCA9IHBheWxvYWQudGFyZ2V0Tm9kZUlkO1xuICAgIGlmICh0YXJnZXROb2RlSWQgIT0gbnVsbCAmJiAodGFyZ2V0Tm9kZSA9IHJvb3QuZ2V0Tm9kZUJ5SWQodGFyZ2V0Tm9kZUlkKSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGU6IHRhcmdldE5vZGVcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG4vLyBOb3QgaW5jbHVkZXMgdGhlIGdpdmVuIG5vZGUgYXQgdGhlIGxhc3QgaXRlbS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXRoVG9Sb290KG5vZGUpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIG5vZGUgJiYgcGF0aC5wdXNoKG5vZGUpO1xuICB9XG4gIHJldHVybiBwYXRoLnJldmVyc2UoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhYm92ZVZpZXdSb290KHZpZXdSb290LCBub2RlKSB7XG4gIHZhciB2aWV3UGF0aCA9IGdldFBhdGhUb1Jvb3Qodmlld1Jvb3QpO1xuICByZXR1cm4genJVdGlsLmluZGV4T2Yodmlld1BhdGgsIG5vZGUpID49IDA7XG59XG4vLyBGcm9tIHJvb3QgdG8gdGhlIGlucHV0IG5vZGUgKHRoZSBpbnB1dCBub2RlIHdpbGwgYmUgaW5jbHVkZWQpLlxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBUcmVlUGF0aEluZm8obm9kZSwgc2VyaWVzTW9kZWwpIHtcbiAgdmFyIHRyZWVQYXRoSW5mbyA9IFtdO1xuICB3aGlsZSAobm9kZSkge1xuICAgIHZhciBub2RlRGF0YUluZGV4ID0gbm9kZS5kYXRhSW5kZXg7XG4gICAgdHJlZVBhdGhJbmZvLnB1c2goe1xuICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgZGF0YUluZGV4OiBub2RlRGF0YUluZGV4LFxuICAgICAgdmFsdWU6IHNlcmllc01vZGVsLmdldFJhd1ZhbHVlKG5vZGVEYXRhSW5kZXgpXG4gICAgfSk7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICB0cmVlUGF0aEluZm8ucmV2ZXJzZSgpO1xuICByZXR1cm4gdHJlZVBhdGhJbmZvO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///41616\n')},44532:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   T: () => (/* binding */ getDefaultInterpolatedLabel),\n/* harmony export */   i: () => (/* binding */ getDefaultLabel)\n/* harmony export */ });\n/* harmony import */ var _data_helper_dataProvider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58267);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n/**\r\n * @return label string. Not null/undefined\r\n */\nfunction getDefaultLabel(data, dataIndex) {\n  var labelDims = data.mapDimensionsAll('defaultedLabel');\n  var len = labelDims.length;\n  // Simple optimization (in lots of cases, label dims length is 1)\n  if (len === 1) {\n    var rawVal = (0,_data_helper_dataProvider_js__WEBPACK_IMPORTED_MODULE_0__/* .retrieveRawValue */ .QE)(data, dataIndex, labelDims[0]);\n    return rawVal != null ? rawVal + '' : null;\n  } else if (len) {\n    var vals = [];\n    for (var i = 0; i < labelDims.length; i++) {\n      vals.push((0,_data_helper_dataProvider_js__WEBPACK_IMPORTED_MODULE_0__/* .retrieveRawValue */ .QE)(data, dataIndex, labelDims[i]));\n    }\n    return vals.join(' ');\n  }\n}\nfunction getDefaultInterpolatedLabel(data, interpolatedValue) {\n  var labelDims = data.mapDimensionsAll('defaultedLabel');\n  if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(interpolatedValue)) {\n    return interpolatedValue + '';\n  }\n  var vals = [];\n  for (var i = 0; i < labelDims.length; i++) {\n    var dimIndex = data.getDimensionIndex(labelDims[i]);\n    if (dimIndex >= 0) {\n      vals.push(interpolatedValue[dimIndex]);\n    }\n  }\n  return vals.join(' ');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ1MzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvbGFiZWxIZWxwZXIuanM/ZTJiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IHJldHJpZXZlUmF3VmFsdWUgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9kYXRhUHJvdmlkZXIuanMnO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG4vKipcclxuICogQHJldHVybiBsYWJlbCBzdHJpbmcuIE5vdCBudWxsL3VuZGVmaW5lZFxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0TGFiZWwoZGF0YSwgZGF0YUluZGV4KSB7XG4gIHZhciBsYWJlbERpbXMgPSBkYXRhLm1hcERpbWVuc2lvbnNBbGwoJ2RlZmF1bHRlZExhYmVsJyk7XG4gIHZhciBsZW4gPSBsYWJlbERpbXMubGVuZ3RoO1xuICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uIChpbiBsb3RzIG9mIGNhc2VzLCBsYWJlbCBkaW1zIGxlbmd0aCBpcyAxKVxuICBpZiAobGVuID09PSAxKSB7XG4gICAgdmFyIHJhd1ZhbCA9IHJldHJpZXZlUmF3VmFsdWUoZGF0YSwgZGF0YUluZGV4LCBsYWJlbERpbXNbMF0pO1xuICAgIHJldHVybiByYXdWYWwgIT0gbnVsbCA/IHJhd1ZhbCArICcnIDogbnVsbDtcbiAgfSBlbHNlIGlmIChsZW4pIHtcbiAgICB2YXIgdmFscyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxEaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxzLnB1c2gocmV0cmlldmVSYXdWYWx1ZShkYXRhLCBkYXRhSW5kZXgsIGxhYmVsRGltc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFscy5qb2luKCcgJyk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0SW50ZXJwb2xhdGVkTGFiZWwoZGF0YSwgaW50ZXJwb2xhdGVkVmFsdWUpIHtcbiAgdmFyIGxhYmVsRGltcyA9IGRhdGEubWFwRGltZW5zaW9uc0FsbCgnZGVmYXVsdGVkTGFiZWwnKTtcbiAgaWYgKCFpc0FycmF5KGludGVycG9sYXRlZFZhbHVlKSkge1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZWRWYWx1ZSArICcnO1xuICB9XG4gIHZhciB2YWxzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxEaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpbUluZGV4ID0gZGF0YS5nZXREaW1lbnNpb25JbmRleChsYWJlbERpbXNbaV0pO1xuICAgIGlmIChkaW1JbmRleCA+PSAwKSB7XG4gICAgICB2YWxzLnB1c2goaW50ZXJwb2xhdGVkVmFsdWVbZGltSW5kZXhdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHMuam9pbignICcpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44532\n")},46448:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39195);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5638);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43870);\n/* harmony import */ var _util_states_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(34833);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar Polyline = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(Polyline, _super);\n  function Polyline(lineData, idx, seriesScope) {\n    var _this = _super.call(this) || this;\n    _this._createPolyline(lineData, idx, seriesScope);\n    return _this;\n  }\n  Polyline.prototype._createPolyline = function (lineData, idx, seriesScope) {\n    // let seriesModel = lineData.hostModel;\n    var points = lineData.getItemLayout(idx);\n    var line = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A({\n      shape: {\n        points: points\n      }\n    });\n    this.add(line);\n    this._updateCommonStl(lineData, idx, seriesScope);\n  };\n  ;\n  Polyline.prototype.updateData = function (lineData, idx, seriesScope) {\n    var seriesModel = lineData.hostModel;\n    var line = this.childAt(0);\n    var target = {\n      shape: {\n        points: lineData.getItemLayout(idx)\n      }\n    };\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* .updateProps */ .oi(line, target, seriesModel, idx);\n    this._updateCommonStl(lineData, idx, seriesScope);\n  };\n  ;\n  Polyline.prototype._updateCommonStl = function (lineData, idx, seriesScope) {\n    var line = this.childAt(0);\n    var itemModel = lineData.getItemModel(idx);\n    var emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;\n    var focus = seriesScope && seriesScope.focus;\n    var blurScope = seriesScope && seriesScope.blurScope;\n    var emphasisDisabled = seriesScope && seriesScope.emphasisDisabled;\n    if (!seriesScope || lineData.hasItemOption) {\n      var emphasisModel = itemModel.getModel('emphasis');\n      emphasisLineStyle = emphasisModel.getModel('lineStyle').getLineStyle();\n      emphasisDisabled = emphasisModel.get('disabled');\n      focus = emphasisModel.get('focus');\n      blurScope = emphasisModel.get('blurScope');\n    }\n    line.useStyle(lineData.getItemVisual(idx, 'style'));\n    line.style.fill = null;\n    line.style.strokeNoScale = true;\n    var lineEmphasisState = line.ensureState('emphasis');\n    lineEmphasisState.style = emphasisLineStyle;\n    (0,_util_states_js__WEBPACK_IMPORTED_MODULE_3__/* .toggleHoverEmphasis */ .Lm)(this, focus, blurScope, emphasisDisabled);\n  };\n  ;\n  Polyline.prototype.updateLayout = function (lineData, idx) {\n    var polyline = this.childAt(0);\n    polyline.setShape('points', lineData.getItemLayout(idx));\n  };\n  ;\n  return Polyline;\n}(_util_graphic_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Polyline);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDY0NDguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9Qb2x5bGluZS5qcz9lZDhhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyB0b2dnbGVIb3ZlckVtcGhhc2lzIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMuanMnO1xudmFyIFBvbHlsaW5lID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBvbHlsaW5lLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBQb2x5bGluZShsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX2NyZWF0ZVBvbHlsaW5lKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgUG9seWxpbmUucHJvdG90eXBlLl9jcmVhdGVQb2x5bGluZSA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgIC8vIGxldCBzZXJpZXNNb2RlbCA9IGxpbmVEYXRhLmhvc3RNb2RlbDtcbiAgICB2YXIgcG9pbnRzID0gbGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgIHZhciBsaW5lID0gbmV3IGdyYXBoaWMuUG9seWxpbmUoe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmFkZChsaW5lKTtcbiAgICB0aGlzLl91cGRhdGVDb21tb25TdGwobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpO1xuICB9O1xuICA7XG4gIFBvbHlsaW5lLnByb3RvdHlwZS51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgdmFyIHNlcmllc01vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuICAgIHZhciBsaW5lID0gdGhpcy5jaGlsZEF0KDApO1xuICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICBzaGFwZToge1xuICAgICAgICBwb2ludHM6IGxpbmVEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KVxuICAgICAgfVxuICAgIH07XG4gICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhsaW5lLCB0YXJnZXQsIHNlcmllc01vZGVsLCBpZHgpO1xuICAgIHRoaXMuX3VwZGF0ZUNvbW1vblN0bChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG4gIH07XG4gIDtcbiAgUG9seWxpbmUucHJvdG90eXBlLl91cGRhdGVDb21tb25TdGwgPSBmdW5jdGlvbiAobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgICB2YXIgbGluZSA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICB2YXIgaXRlbU1vZGVsID0gbGluZURhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgdmFyIGVtcGhhc2lzTGluZVN0eWxlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuZW1waGFzaXNMaW5lU3R5bGU7XG4gICAgdmFyIGZvY3VzID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuZm9jdXM7XG4gICAgdmFyIGJsdXJTY29wZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmJsdXJTY29wZTtcbiAgICB2YXIgZW1waGFzaXNEaXNhYmxlZCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmVtcGhhc2lzRGlzYWJsZWQ7XG4gICAgaWYgKCFzZXJpZXNTY29wZSB8fCBsaW5lRGF0YS5oYXNJdGVtT3B0aW9uKSB7XG4gICAgICB2YXIgZW1waGFzaXNNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKTtcbiAgICAgIGVtcGhhc2lzTGluZVN0eWxlID0gZW1waGFzaXNNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCk7XG4gICAgICBlbXBoYXNpc0Rpc2FibGVkID0gZW1waGFzaXNNb2RlbC5nZXQoJ2Rpc2FibGVkJyk7XG4gICAgICBmb2N1cyA9IGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpO1xuICAgICAgYmx1clNjb3BlID0gZW1waGFzaXNNb2RlbC5nZXQoJ2JsdXJTY29wZScpO1xuICAgIH1cbiAgICBsaW5lLnVzZVN0eWxlKGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3R5bGUnKSk7XG4gICAgbGluZS5zdHlsZS5maWxsID0gbnVsbDtcbiAgICBsaW5lLnN0eWxlLnN0cm9rZU5vU2NhbGUgPSB0cnVlO1xuICAgIHZhciBsaW5lRW1waGFzaXNTdGF0ZSA9IGxpbmUuZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJyk7XG4gICAgbGluZUVtcGhhc2lzU3RhdGUuc3R5bGUgPSBlbXBoYXNpc0xpbmVTdHlsZTtcbiAgICB0b2dnbGVIb3ZlckVtcGhhc2lzKHRoaXMsIGZvY3VzLCBibHVyU2NvcGUsIGVtcGhhc2lzRGlzYWJsZWQpO1xuICB9O1xuICA7XG4gIFBvbHlsaW5lLnByb3RvdHlwZS51cGRhdGVMYXlvdXQgPSBmdW5jdGlvbiAobGluZURhdGEsIGlkeCkge1xuICAgIHZhciBwb2x5bGluZSA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICBwb2x5bGluZS5zZXRTaGFwZSgncG9pbnRzJywgbGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpKTtcbiAgfTtcbiAgO1xuICByZXR1cm4gUG9seWxpbmU7XG59KGdyYXBoaWMuR3JvdXApO1xuZXhwb3J0IGRlZmF1bHQgUG9seWxpbmU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///46448\n")},62695:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ createGraphFromNodeEdge)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _data_SeriesData_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6006);\n/* harmony import */ var _data_Graph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50451);\n/* harmony import */ var _data_helper_linkSeriesData_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(76827);\n/* harmony import */ var _data_helper_createDimensions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(97351);\n/* harmony import */ var _core_CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89737);\n/* harmony import */ var _createSeriesData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13637);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nfunction createGraphFromNodeEdge(nodes, edges, seriesModel, directed, beforeLink) {\n  // ??? TODO\n  // support dataset?\n  var graph = new _data_Graph_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay(directed);\n  for (var i = 0; i < nodes.length; i++) {\n    graph.addNode(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve(\n    // Id, name, dataIndex\n    nodes[i].id, nodes[i].name, i), i);\n  }\n  var linkNameList = [];\n  var validEdges = [];\n  var linkCount = 0;\n  for (var i = 0; i < edges.length; i++) {\n    var link = edges[i];\n    var source = link.source;\n    var target = link.target;\n    // addEdge may fail when source or target not exists\n    if (graph.addEdge(source, target, linkCount)) {\n      validEdges.push(link);\n      linkNameList.push(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve((0,_util_model_js__WEBPACK_IMPORTED_MODULE_2__/* .convertOptionIdName */ .vS)(link.id, null), source + \' > \' + target));\n      linkCount++;\n    }\n  }\n  var coordSys = seriesModel.get(\'coordinateSystem\');\n  var nodeData;\n  if (coordSys === \'cartesian2d\' || coordSys === \'polar\') {\n    nodeData = (0,_createSeriesData_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(nodes, seriesModel);\n  } else {\n    var coordSysCtor = _core_CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.get(coordSys);\n    var coordDimensions = coordSysCtor ? coordSysCtor.dimensions || [] : [];\n    // FIXME: Some geo do not need `value` dimenson, whereas `calendar` needs\n    // `value` dimension, but graph need `value` dimension. It\'s better to\n    // uniform this behavior.\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.indexOf(coordDimensions, \'value\') < 0) {\n      coordDimensions.concat([\'value\']);\n    }\n    var dimensions = (0,_data_helper_createDimensions_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(nodes, {\n      coordDimensions: coordDimensions,\n      encodeDefine: seriesModel.getEncode()\n    }).dimensions;\n    nodeData = new _data_SeriesData_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A(dimensions, seriesModel);\n    nodeData.initData(nodes);\n  }\n  var edgeData = new _data_SeriesData_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A([\'value\'], seriesModel);\n  edgeData.initData(validEdges, linkNameList);\n  beforeLink && beforeLink(nodeData, edgeData);\n  (0,_data_helper_linkSeriesData_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)({\n    mainData: nodeData,\n    struct: graph,\n    structAttr: \'graph\',\n    datas: {\n      node: nodeData,\n      edge: edgeData\n    },\n    datasAttr: {\n      node: \'data\',\n      edge: \'edgeData\'\n    }\n  });\n  // Update dataIndex of nodes and edges because invalid edge may be removed\n  graph.update();\n  return graph;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI2OTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL2NyZWF0ZUdyYXBoRnJvbU5vZGVFZGdlLmpzPzBkNWUiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBTZXJpZXNEYXRhIGZyb20gJy4uLy4uL2RhdGEvU2VyaWVzRGF0YS5qcyc7XG5pbXBvcnQgR3JhcGggZnJvbSAnLi4vLi4vZGF0YS9HcmFwaC5qcyc7XG5pbXBvcnQgbGlua1Nlcmllc0RhdGEgZnJvbSAnLi4vLi4vZGF0YS9oZWxwZXIvbGlua1Nlcmllc0RhdGEuanMnO1xuaW1wb3J0IHByZXBhcmVTZXJpZXNEYXRhU2NoZW1hIGZyb20gJy4uLy4uL2RhdGEvaGVscGVyL2NyZWF0ZURpbWVuc2lvbnMuanMnO1xuaW1wb3J0IENvb3JkaW5hdGVTeXN0ZW0gZnJvbSAnLi4vLi4vY29yZS9Db29yZGluYXRlU3lzdGVtLmpzJztcbmltcG9ydCBjcmVhdGVTZXJpZXNEYXRhIGZyb20gJy4vY3JlYXRlU2VyaWVzRGF0YS5qcyc7XG5pbXBvcnQgeyBjb252ZXJ0T3B0aW9uSWROYW1lIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVHcmFwaEZyb21Ob2RlRWRnZShub2RlcywgZWRnZXMsIHNlcmllc01vZGVsLCBkaXJlY3RlZCwgYmVmb3JlTGluaykge1xuICAvLyA/Pz8gVE9ET1xuICAvLyBzdXBwb3J0IGRhdGFzZXQ/XG4gIHZhciBncmFwaCA9IG5ldyBHcmFwaChkaXJlY3RlZCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBncmFwaC5hZGROb2RlKHpyVXRpbC5yZXRyaWV2ZShcbiAgICAvLyBJZCwgbmFtZSwgZGF0YUluZGV4XG4gICAgbm9kZXNbaV0uaWQsIG5vZGVzW2ldLm5hbWUsIGkpLCBpKTtcbiAgfVxuICB2YXIgbGlua05hbWVMaXN0ID0gW107XG4gIHZhciB2YWxpZEVkZ2VzID0gW107XG4gIHZhciBsaW5rQ291bnQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmsgPSBlZGdlc1tpXTtcbiAgICB2YXIgc291cmNlID0gbGluay5zb3VyY2U7XG4gICAgdmFyIHRhcmdldCA9IGxpbmsudGFyZ2V0O1xuICAgIC8vIGFkZEVkZ2UgbWF5IGZhaWwgd2hlbiBzb3VyY2Ugb3IgdGFyZ2V0IG5vdCBleGlzdHNcbiAgICBpZiAoZ3JhcGguYWRkRWRnZShzb3VyY2UsIHRhcmdldCwgbGlua0NvdW50KSkge1xuICAgICAgdmFsaWRFZGdlcy5wdXNoKGxpbmspO1xuICAgICAgbGlua05hbWVMaXN0LnB1c2goenJVdGlsLnJldHJpZXZlKGNvbnZlcnRPcHRpb25JZE5hbWUobGluay5pZCwgbnVsbCksIHNvdXJjZSArICcgPiAnICsgdGFyZ2V0KSk7XG4gICAgICBsaW5rQ291bnQrKztcbiAgICB9XG4gIH1cbiAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJyk7XG4gIHZhciBub2RlRGF0YTtcbiAgaWYgKGNvb3JkU3lzID09PSAnY2FydGVzaWFuMmQnIHx8IGNvb3JkU3lzID09PSAncG9sYXInKSB7XG4gICAgbm9kZURhdGEgPSBjcmVhdGVTZXJpZXNEYXRhKG5vZGVzLCBzZXJpZXNNb2RlbCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvb3JkU3lzQ3RvciA9IENvb3JkaW5hdGVTeXN0ZW0uZ2V0KGNvb3JkU3lzKTtcbiAgICB2YXIgY29vcmREaW1lbnNpb25zID0gY29vcmRTeXNDdG9yID8gY29vcmRTeXNDdG9yLmRpbWVuc2lvbnMgfHwgW10gOiBbXTtcbiAgICAvLyBGSVhNRTogU29tZSBnZW8gZG8gbm90IG5lZWQgYHZhbHVlYCBkaW1lbnNvbiwgd2hlcmVhcyBgY2FsZW5kYXJgIG5lZWRzXG4gICAgLy8gYHZhbHVlYCBkaW1lbnNpb24sIGJ1dCBncmFwaCBuZWVkIGB2YWx1ZWAgZGltZW5zaW9uLiBJdCdzIGJldHRlciB0b1xuICAgIC8vIHVuaWZvcm0gdGhpcyBiZWhhdmlvci5cbiAgICBpZiAoenJVdGlsLmluZGV4T2YoY29vcmREaW1lbnNpb25zLCAndmFsdWUnKSA8IDApIHtcbiAgICAgIGNvb3JkRGltZW5zaW9ucy5jb25jYXQoWyd2YWx1ZSddKTtcbiAgICB9XG4gICAgdmFyIGRpbWVuc2lvbnMgPSBwcmVwYXJlU2VyaWVzRGF0YVNjaGVtYShub2Rlcywge1xuICAgICAgY29vcmREaW1lbnNpb25zOiBjb29yZERpbWVuc2lvbnMsXG4gICAgICBlbmNvZGVEZWZpbmU6IHNlcmllc01vZGVsLmdldEVuY29kZSgpXG4gICAgfSkuZGltZW5zaW9ucztcbiAgICBub2RlRGF0YSA9IG5ldyBTZXJpZXNEYXRhKGRpbWVuc2lvbnMsIHNlcmllc01vZGVsKTtcbiAgICBub2RlRGF0YS5pbml0RGF0YShub2Rlcyk7XG4gIH1cbiAgdmFyIGVkZ2VEYXRhID0gbmV3IFNlcmllc0RhdGEoWyd2YWx1ZSddLCBzZXJpZXNNb2RlbCk7XG4gIGVkZ2VEYXRhLmluaXREYXRhKHZhbGlkRWRnZXMsIGxpbmtOYW1lTGlzdCk7XG4gIGJlZm9yZUxpbmsgJiYgYmVmb3JlTGluayhub2RlRGF0YSwgZWRnZURhdGEpO1xuICBsaW5rU2VyaWVzRGF0YSh7XG4gICAgbWFpbkRhdGE6IG5vZGVEYXRhLFxuICAgIHN0cnVjdDogZ3JhcGgsXG4gICAgc3RydWN0QXR0cjogJ2dyYXBoJyxcbiAgICBkYXRhczoge1xuICAgICAgbm9kZTogbm9kZURhdGEsXG4gICAgICBlZGdlOiBlZGdlRGF0YVxuICAgIH0sXG4gICAgZGF0YXNBdHRyOiB7XG4gICAgICBub2RlOiAnZGF0YScsXG4gICAgICBlZGdlOiAnZWRnZURhdGEnXG4gICAgfVxuICB9KTtcbiAgLy8gVXBkYXRlIGRhdGFJbmRleCBvZiBub2RlcyBhbmQgZWRnZXMgYmVjYXVzZSBpbnZhbGlkIGVkZ2UgbWF5IGJlIHJlbW92ZWRcbiAgZ3JhcGgudXBkYXRlKCk7XG4gIHJldHVybiBncmFwaDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///62695\n')},64380:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43870);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43199);\n/* harmony import */ var _Line_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32182);\n/* harmony import */ var _label_labelStyle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89632);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar LineDraw = /** @class */function () {\n  function LineDraw(LineCtor) {\n    this.group = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A();\n    this._LineCtor = LineCtor || _Line_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A;\n  }\n  LineDraw.prototype.updateData = function (lineData) {\n    var _this = this;\n    // Remove progressive els.\n    this._progressiveEls = null;\n    var lineDraw = this;\n    var group = lineDraw.group;\n    var oldLineData = lineDraw._lineData;\n    lineDraw._lineData = lineData;\n    // There is no oldLineData only when first rendering or switching from\n    // stream mode to normal mode, where previous elements should be removed.\n    if (!oldLineData) {\n      group.removeAll();\n    }\n    var seriesScope = makeSeriesScope(lineData);\n    lineData.diff(oldLineData).add(function (idx) {\n      _this._doAdd(lineData, idx, seriesScope);\n    }).update(function (newIdx, oldIdx) {\n      _this._doUpdate(oldLineData, lineData, oldIdx, newIdx, seriesScope);\n    }).remove(function (idx) {\n      group.remove(oldLineData.getItemGraphicEl(idx));\n    }).execute();\n  };\n  ;\n  LineDraw.prototype.updateLayout = function () {\n    var lineData = this._lineData;\n    // Do not support update layout in incremental mode.\n    if (!lineData) {\n      return;\n    }\n    lineData.eachItemGraphicEl(function (el, idx) {\n      el.updateLayout(lineData, idx);\n    }, this);\n  };\n  ;\n  LineDraw.prototype.incrementalPrepareUpdate = function (lineData) {\n    this._seriesScope = makeSeriesScope(lineData);\n    this._lineData = null;\n    this.group.removeAll();\n  };\n  ;\n  LineDraw.prototype.incrementalUpdate = function (taskParams, lineData) {\n    this._progressiveEls = [];\n    function updateIncrementalAndHover(el) {\n      if (!el.isGroup && !isEffectObject(el)) {\n        el.incremental = true;\n        el.ensureState('emphasis').hoverLayer = true;\n      }\n    }\n    for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n      var itemLayout = lineData.getItemLayout(idx);\n      if (lineNeedsDraw(itemLayout)) {\n        var el = new this._LineCtor(lineData, idx, this._seriesScope);\n        el.traverse(updateIncrementalAndHover);\n        this.group.add(el);\n        lineData.setItemGraphicEl(idx, el);\n        this._progressiveEls.push(el);\n      }\n    }\n  };\n  ;\n  LineDraw.prototype.remove = function () {\n    this.group.removeAll();\n  };\n  ;\n  LineDraw.prototype.eachRendered = function (cb) {\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__.traverseElements(this._progressiveEls || this.group, cb);\n  };\n  LineDraw.prototype._doAdd = function (lineData, idx, seriesScope) {\n    var itemLayout = lineData.getItemLayout(idx);\n    if (!lineNeedsDraw(itemLayout)) {\n      return;\n    }\n    var el = new this._LineCtor(lineData, idx, seriesScope);\n    lineData.setItemGraphicEl(idx, el);\n    this.group.add(el);\n  };\n  LineDraw.prototype._doUpdate = function (oldLineData, newLineData, oldIdx, newIdx, seriesScope) {\n    var itemEl = oldLineData.getItemGraphicEl(oldIdx);\n    if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {\n      this.group.remove(itemEl);\n      return;\n    }\n    if (!itemEl) {\n      itemEl = new this._LineCtor(newLineData, newIdx, seriesScope);\n    } else {\n      itemEl.updateData(newLineData, newIdx, seriesScope);\n    }\n    newLineData.setItemGraphicEl(newIdx, itemEl);\n    this.group.add(itemEl);\n  };\n  return LineDraw;\n}();\nfunction isEffectObject(el) {\n  return el.animators && el.animators.length > 0;\n}\nfunction makeSeriesScope(lineData) {\n  var hostModel = lineData.hostModel;\n  var emphasisModel = hostModel.getModel('emphasis');\n  return {\n    lineStyle: hostModel.getModel('lineStyle').getLineStyle(),\n    emphasisLineStyle: emphasisModel.getModel(['lineStyle']).getLineStyle(),\n    blurLineStyle: hostModel.getModel(['blur', 'lineStyle']).getLineStyle(),\n    selectLineStyle: hostModel.getModel(['select', 'lineStyle']).getLineStyle(),\n    emphasisDisabled: emphasisModel.get('disabled'),\n    blurScope: emphasisModel.get('blurScope'),\n    focus: emphasisModel.get('focus'),\n    labelStatesModels: (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_3__/* .getLabelStatesModels */ .lx)(hostModel)\n  };\n}\nfunction isPointNaN(pt) {\n  return isNaN(pt[0]) || isNaN(pt[1]);\n}\nfunction lineNeedsDraw(pts) {\n  return pts && !isPointNaN(pts[0]) && !isPointNaN(pts[1]);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LineDraw);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQzODAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL0xpbmVEcmF3LmpzPzU0NDEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgTGluZUdyb3VwIGZyb20gJy4vTGluZS5qcyc7XG5pbXBvcnQgeyBnZXRMYWJlbFN0YXRlc01vZGVscyB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUuanMnO1xudmFyIExpbmVEcmF3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGluZURyYXcoTGluZUN0b3IpIHtcbiAgICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICB0aGlzLl9MaW5lQ3RvciA9IExpbmVDdG9yIHx8IExpbmVHcm91cDtcbiAgfVxuICBMaW5lRHJhdy5wcm90b3R5cGUudXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChsaW5lRGF0YSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gUmVtb3ZlIHByb2dyZXNzaXZlIGVscy5cbiAgICB0aGlzLl9wcm9ncmVzc2l2ZUVscyA9IG51bGw7XG4gICAgdmFyIGxpbmVEcmF3ID0gdGhpcztcbiAgICB2YXIgZ3JvdXAgPSBsaW5lRHJhdy5ncm91cDtcbiAgICB2YXIgb2xkTGluZURhdGEgPSBsaW5lRHJhdy5fbGluZURhdGE7XG4gICAgbGluZURyYXcuX2xpbmVEYXRhID0gbGluZURhdGE7XG4gICAgLy8gVGhlcmUgaXMgbm8gb2xkTGluZURhdGEgb25seSB3aGVuIGZpcnN0IHJlbmRlcmluZyBvciBzd2l0Y2hpbmcgZnJvbVxuICAgIC8vIHN0cmVhbSBtb2RlIHRvIG5vcm1hbCBtb2RlLCB3aGVyZSBwcmV2aW91cyBlbGVtZW50cyBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICBpZiAoIW9sZExpbmVEYXRhKSB7XG4gICAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgICB9XG4gICAgdmFyIHNlcmllc1Njb3BlID0gbWFrZVNlcmllc1Njb3BlKGxpbmVEYXRhKTtcbiAgICBsaW5lRGF0YS5kaWZmKG9sZExpbmVEYXRhKS5hZGQoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgX3RoaXMuX2RvQWRkKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbiAgICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICBfdGhpcy5fZG9VcGRhdGUob2xkTGluZURhdGEsIGxpbmVEYXRhLCBvbGRJZHgsIG5ld0lkeCwgc2VyaWVzU2NvcGUpO1xuICAgIH0pLnJlbW92ZShmdW5jdGlvbiAoaWR4KSB7XG4gICAgICBncm91cC5yZW1vdmUob2xkTGluZURhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpKTtcbiAgICB9KS5leGVjdXRlKCk7XG4gIH07XG4gIDtcbiAgTGluZURyYXcucHJvdG90eXBlLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGluZURhdGEgPSB0aGlzLl9saW5lRGF0YTtcbiAgICAvLyBEbyBub3Qgc3VwcG9ydCB1cGRhdGUgbGF5b3V0IGluIGluY3JlbWVudGFsIG1vZGUuXG4gICAgaWYgKCFsaW5lRGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsaW5lRGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgZWwudXBkYXRlTGF5b3V0KGxpbmVEYXRhLCBpZHgpO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuICA7XG4gIExpbmVEcmF3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFByZXBhcmVVcGRhdGUgPSBmdW5jdGlvbiAobGluZURhdGEpIHtcbiAgICB0aGlzLl9zZXJpZXNTY29wZSA9IG1ha2VTZXJpZXNTY29wZShsaW5lRGF0YSk7XG4gICAgdGhpcy5fbGluZURhdGEgPSBudWxsO1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gIH07XG4gIDtcbiAgTGluZURyYXcucHJvdG90eXBlLmluY3JlbWVudGFsVXBkYXRlID0gZnVuY3Rpb24gKHRhc2tQYXJhbXMsIGxpbmVEYXRhKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVFbHMgPSBbXTtcbiAgICBmdW5jdGlvbiB1cGRhdGVJbmNyZW1lbnRhbEFuZEhvdmVyKGVsKSB7XG4gICAgICBpZiAoIWVsLmlzR3JvdXAgJiYgIWlzRWZmZWN0T2JqZWN0KGVsKSkge1xuICAgICAgICBlbC5pbmNyZW1lbnRhbCA9IHRydWU7XG4gICAgICAgIGVsLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpLmhvdmVyTGF5ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpZHggPSB0YXNrUGFyYW1zLnN0YXJ0OyBpZHggPCB0YXNrUGFyYW1zLmVuZDsgaWR4KyspIHtcbiAgICAgIHZhciBpdGVtTGF5b3V0ID0gbGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgaWYgKGxpbmVOZWVkc0RyYXcoaXRlbUxheW91dCkpIHtcbiAgICAgICAgdmFyIGVsID0gbmV3IHRoaXMuX0xpbmVDdG9yKGxpbmVEYXRhLCBpZHgsIHRoaXMuX3Nlcmllc1Njb3BlKTtcbiAgICAgICAgZWwudHJhdmVyc2UodXBkYXRlSW5jcmVtZW50YWxBbmRIb3Zlcik7XG4gICAgICAgIHRoaXMuZ3JvdXAuYWRkKGVsKTtcbiAgICAgICAgbGluZURhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIGVsKTtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVFbHMucHVzaChlbCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICA7XG4gIExpbmVEcmF3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgfTtcbiAgO1xuICBMaW5lRHJhdy5wcm90b3R5cGUuZWFjaFJlbmRlcmVkID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgZ3JhcGhpYy50cmF2ZXJzZUVsZW1lbnRzKHRoaXMuX3Byb2dyZXNzaXZlRWxzIHx8IHRoaXMuZ3JvdXAsIGNiKTtcbiAgfTtcbiAgTGluZURyYXcucHJvdG90eXBlLl9kb0FkZCA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgIHZhciBpdGVtTGF5b3V0ID0gbGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgIGlmICghbGluZU5lZWRzRHJhdyhpdGVtTGF5b3V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZWwgPSBuZXcgdGhpcy5fTGluZUN0b3IobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpO1xuICAgIGxpbmVEYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBlbCk7XG4gICAgdGhpcy5ncm91cC5hZGQoZWwpO1xuICB9O1xuICBMaW5lRHJhdy5wcm90b3R5cGUuX2RvVXBkYXRlID0gZnVuY3Rpb24gKG9sZExpbmVEYXRhLCBuZXdMaW5lRGF0YSwgb2xkSWR4LCBuZXdJZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgdmFyIGl0ZW1FbCA9IG9sZExpbmVEYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICBpZiAoIWxpbmVOZWVkc0RyYXcobmV3TGluZURhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpKSkge1xuICAgICAgdGhpcy5ncm91cC5yZW1vdmUoaXRlbUVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpdGVtRWwpIHtcbiAgICAgIGl0ZW1FbCA9IG5ldyB0aGlzLl9MaW5lQ3RvcihuZXdMaW5lRGF0YSwgbmV3SWR4LCBzZXJpZXNTY29wZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW1FbC51cGRhdGVEYXRhKG5ld0xpbmVEYXRhLCBuZXdJZHgsIHNlcmllc1Njb3BlKTtcbiAgICB9XG4gICAgbmV3TGluZURhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIGl0ZW1FbCk7XG4gICAgdGhpcy5ncm91cC5hZGQoaXRlbUVsKTtcbiAgfTtcbiAgcmV0dXJuIExpbmVEcmF3O1xufSgpO1xuZnVuY3Rpb24gaXNFZmZlY3RPYmplY3QoZWwpIHtcbiAgcmV0dXJuIGVsLmFuaW1hdG9ycyAmJiBlbC5hbmltYXRvcnMubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIG1ha2VTZXJpZXNTY29wZShsaW5lRGF0YSkge1xuICB2YXIgaG9zdE1vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuICB2YXIgZW1waGFzaXNNb2RlbCA9IGhvc3RNb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKTtcbiAgcmV0dXJuIHtcbiAgICBsaW5lU3R5bGU6IGhvc3RNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCksXG4gICAgZW1waGFzaXNMaW5lU3R5bGU6IGVtcGhhc2lzTW9kZWwuZ2V0TW9kZWwoWydsaW5lU3R5bGUnXSkuZ2V0TGluZVN0eWxlKCksXG4gICAgYmx1ckxpbmVTdHlsZTogaG9zdE1vZGVsLmdldE1vZGVsKFsnYmx1cicsICdsaW5lU3R5bGUnXSkuZ2V0TGluZVN0eWxlKCksXG4gICAgc2VsZWN0TGluZVN0eWxlOiBob3N0TW9kZWwuZ2V0TW9kZWwoWydzZWxlY3QnLCAnbGluZVN0eWxlJ10pLmdldExpbmVTdHlsZSgpLFxuICAgIGVtcGhhc2lzRGlzYWJsZWQ6IGVtcGhhc2lzTW9kZWwuZ2V0KCdkaXNhYmxlZCcpLFxuICAgIGJsdXJTY29wZTogZW1waGFzaXNNb2RlbC5nZXQoJ2JsdXJTY29wZScpLFxuICAgIGZvY3VzOiBlbXBoYXNpc01vZGVsLmdldCgnZm9jdXMnKSxcbiAgICBsYWJlbFN0YXRlc01vZGVsczogZ2V0TGFiZWxTdGF0ZXNNb2RlbHMoaG9zdE1vZGVsKVxuICB9O1xufVxuZnVuY3Rpb24gaXNQb2ludE5hTihwdCkge1xuICByZXR1cm4gaXNOYU4ocHRbMF0pIHx8IGlzTmFOKHB0WzFdKTtcbn1cbmZ1bmN0aW9uIGxpbmVOZWVkc0RyYXcocHRzKSB7XG4gIHJldHVybiBwdHMgJiYgIWlzUG9pbnROYU4ocHRzWzBdKSAmJiAhaXNQb2ludE5hTihwdHNbMV0pO1xufVxuZXhwb3J0IGRlZmF1bHQgTGluZURyYXc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///64380\n")},68866:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ enableAriaDecalForTree)\n/* harmony export */ });\n/* harmony import */ var _model_mixin_palette_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96501);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction enableAriaDecalForTree(seriesModel) {\n  var data = seriesModel.getData();\n  var tree = data.tree;\n  var decalPaletteScope = {};\n  tree.eachNode(function (node) {\n    // Use decal of level 1 node\n    var current = node;\n    while (current && current.depth > 1) {\n      current = current.parentNode;\n    }\n    var decal = (0,_model_mixin_palette_js__WEBPACK_IMPORTED_MODULE_0__/* .getDecalFromPalette */ .x)(seriesModel.ecModel, current.name || current.dataIndex + \'\', decalPaletteScope);\n    node.setVisual(\'decal\', decal);\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg4NjYuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9lbmFibGVBcmlhRGVjYWxGb3JUcmVlLmpzP2JiNmQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBnZXREZWNhbEZyb21QYWxldHRlIH0gZnJvbSAnLi4vLi4vbW9kZWwvbWl4aW4vcGFsZXR0ZS5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlbmFibGVBcmlhRGVjYWxGb3JUcmVlKHNlcmllc01vZGVsKSB7XG4gIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICB2YXIgdHJlZSA9IGRhdGEudHJlZTtcbiAgdmFyIGRlY2FsUGFsZXR0ZVNjb3BlID0ge307XG4gIHRyZWUuZWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyBVc2UgZGVjYWwgb2YgbGV2ZWwgMSBub2RlXG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQuZGVwdGggPiAxKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB2YXIgZGVjYWwgPSBnZXREZWNhbEZyb21QYWxldHRlKHNlcmllc01vZGVsLmVjTW9kZWwsIGN1cnJlbnQubmFtZSB8fCBjdXJyZW50LmRhdGFJbmRleCArICcnLCBkZWNhbFBhbGV0dGVTY29wZSk7XG4gICAgbm9kZS5zZXRWaXN1YWwoJ2RlY2FsJywgZGVjYWwpO1xuICB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///68866\n')},71465:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _util_symbol_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62103);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43870);\n/* harmony import */ var _util_states_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34833);\n/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10128);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nfunction updateRipplePath(rippleGroup, effectCfg) {\n  var color = effectCfg.rippleEffectColor || effectCfg.color;\n  rippleGroup.eachChild(function (ripplePath) {\n    ripplePath.attr({\n      z: effectCfg.z,\n      zlevel: effectCfg.zlevel,\n      style: {\n        stroke: effectCfg.brushType === 'stroke' ? color : null,\n        fill: effectCfg.brushType === 'fill' ? color : null\n      }\n    });\n  });\n}\nvar EffectSymbol = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(EffectSymbol, _super);\n  function EffectSymbol(data, idx) {\n    var _this = _super.call(this) || this;\n    var symbol = new _Symbol_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A(data, idx);\n    var rippleGroup = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A();\n    _this.add(symbol);\n    _this.add(rippleGroup);\n    _this.updateData(data, idx);\n    return _this;\n  }\n  EffectSymbol.prototype.stopEffectAnimation = function () {\n    this.childAt(1).removeAll();\n  };\n  EffectSymbol.prototype.startEffectAnimation = function (effectCfg) {\n    var symbolType = effectCfg.symbolType;\n    var color = effectCfg.color;\n    var rippleNumber = effectCfg.rippleNumber;\n    var rippleGroup = this.childAt(1);\n    for (var i = 0; i < rippleNumber; i++) {\n      // If width/height are set too small (e.g., set to 1) on ios10\n      // and macOS Sierra, a circle stroke become a rect, no matter what\n      // the scale is set. So we set width/height as 2. See #4136.\n      var ripplePath = (0,_util_symbol_js__WEBPACK_IMPORTED_MODULE_3__/* .createSymbol */ .v5)(symbolType, -1, -1, 2, 2, color);\n      ripplePath.attr({\n        style: {\n          strokeNoScale: true\n        },\n        z2: 99,\n        silent: true,\n        scaleX: 0.5,\n        scaleY: 0.5\n      });\n      var delay = -i / rippleNumber * effectCfg.period + effectCfg.effectOffset;\n      ripplePath.animate('', true).when(effectCfg.period, {\n        scaleX: effectCfg.rippleScale / 2,\n        scaleY: effectCfg.rippleScale / 2\n      }).delay(delay).start();\n      ripplePath.animateStyle(true).when(effectCfg.period, {\n        opacity: 0\n      }).delay(delay).start();\n      rippleGroup.add(ripplePath);\n    }\n    updateRipplePath(rippleGroup, effectCfg);\n  };\n  /**\r\n   * Update effect symbol\r\n   */\n  EffectSymbol.prototype.updateEffectAnimation = function (effectCfg) {\n    var oldEffectCfg = this._effectCfg;\n    var rippleGroup = this.childAt(1);\n    // Must reinitialize effect if following configuration changed\n    var DIFFICULT_PROPS = ['symbolType', 'period', 'rippleScale', 'rippleNumber'];\n    for (var i = 0; i < DIFFICULT_PROPS.length; i++) {\n      var propName = DIFFICULT_PROPS[i];\n      if (oldEffectCfg[propName] !== effectCfg[propName]) {\n        this.stopEffectAnimation();\n        this.startEffectAnimation(effectCfg);\n        return;\n      }\n    }\n    updateRipplePath(rippleGroup, effectCfg);\n  };\n  /**\r\n   * Highlight symbol\r\n   */\n  EffectSymbol.prototype.highlight = function () {\n    (0,_util_states_js__WEBPACK_IMPORTED_MODULE_4__/* .enterEmphasis */ .HY)(this);\n  };\n  /**\r\n   * Downplay symbol\r\n   */\n  EffectSymbol.prototype.downplay = function () {\n    (0,_util_states_js__WEBPACK_IMPORTED_MODULE_4__/* .leaveEmphasis */ .SD)(this);\n  };\n  EffectSymbol.prototype.getSymbolType = function () {\n    var symbol = this.childAt(0);\n    return symbol && symbol.getSymbolType();\n  };\n  /**\r\n   * Update symbol properties\r\n   */\n  EffectSymbol.prototype.updateData = function (data, idx) {\n    var _this = this;\n    var seriesModel = data.hostModel;\n    this.childAt(0).updateData(data, idx);\n    var rippleGroup = this.childAt(1);\n    var itemModel = data.getItemModel(idx);\n    var symbolType = data.getItemVisual(idx, 'symbol');\n    var symbolSize = (0,_util_symbol_js__WEBPACK_IMPORTED_MODULE_3__/* .normalizeSymbolSize */ .xU)(data.getItemVisual(idx, 'symbolSize'));\n    var symbolStyle = data.getItemVisual(idx, 'style');\n    var color = symbolStyle && symbolStyle.fill;\n    var emphasisModel = itemModel.getModel('emphasis');\n    rippleGroup.setScale(symbolSize);\n    rippleGroup.traverse(function (ripplePath) {\n      ripplePath.setStyle('fill', color);\n    });\n    var symbolOffset = (0,_util_symbol_js__WEBPACK_IMPORTED_MODULE_3__/* .normalizeSymbolOffset */ .hV)(data.getItemVisual(idx, 'symbolOffset'), symbolSize);\n    if (symbolOffset) {\n      rippleGroup.x = symbolOffset[0];\n      rippleGroup.y = symbolOffset[1];\n    }\n    var symbolRotate = data.getItemVisual(idx, 'symbolRotate');\n    rippleGroup.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n    var effectCfg = {};\n    effectCfg.showEffectOn = seriesModel.get('showEffectOn');\n    effectCfg.rippleScale = itemModel.get(['rippleEffect', 'scale']);\n    effectCfg.brushType = itemModel.get(['rippleEffect', 'brushType']);\n    effectCfg.period = itemModel.get(['rippleEffect', 'period']) * 1000;\n    effectCfg.effectOffset = idx / data.count();\n    effectCfg.z = seriesModel.getShallow('z') || 0;\n    effectCfg.zlevel = seriesModel.getShallow('zlevel') || 0;\n    effectCfg.symbolType = symbolType;\n    effectCfg.color = color;\n    effectCfg.rippleEffectColor = itemModel.get(['rippleEffect', 'color']);\n    effectCfg.rippleNumber = itemModel.get(['rippleEffect', 'number']);\n    if (effectCfg.showEffectOn === 'render') {\n      this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg);\n      this._effectCfg = effectCfg;\n    } else {\n      // Not keep old effect config\n      this._effectCfg = null;\n      this.stopEffectAnimation();\n      this.onHoverStateChange = function (toState) {\n        if (toState === 'emphasis') {\n          if (effectCfg.showEffectOn !== 'render') {\n            _this.startEffectAnimation(effectCfg);\n          }\n        } else if (toState === 'normal') {\n          if (effectCfg.showEffectOn !== 'render') {\n            _this.stopEffectAnimation();\n          }\n        }\n      };\n    }\n    this._effectCfg = effectCfg;\n    (0,_util_states_js__WEBPACK_IMPORTED_MODULE_4__/* .toggleHoverEmphasis */ .Lm)(this, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n  };\n  ;\n  EffectSymbol.prototype.fadeOut = function (cb) {\n    cb && cb();\n  };\n  ;\n  return EffectSymbol;\n}(_util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EffectSymbol);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE0NjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL0VmZmVjdFN5bWJvbC5qcz81MTA0Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBjcmVhdGVTeW1ib2wsIG5vcm1hbGl6ZVN5bWJvbE9mZnNldCwgbm9ybWFsaXplU3ltYm9sU2l6ZSB9IGZyb20gJy4uLy4uL3V0aWwvc3ltYm9sLmpzJztcbmltcG9ydCB7IEdyb3VwIH0gZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCB7IGVudGVyRW1waGFzaXMsIGxlYXZlRW1waGFzaXMsIHRvZ2dsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgU3ltYm9sQ2x6IGZyb20gJy4vU3ltYm9sLmpzJztcbmZ1bmN0aW9uIHVwZGF0ZVJpcHBsZVBhdGgocmlwcGxlR3JvdXAsIGVmZmVjdENmZykge1xuICB2YXIgY29sb3IgPSBlZmZlY3RDZmcucmlwcGxlRWZmZWN0Q29sb3IgfHwgZWZmZWN0Q2ZnLmNvbG9yO1xuICByaXBwbGVHcm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKHJpcHBsZVBhdGgpIHtcbiAgICByaXBwbGVQYXRoLmF0dHIoe1xuICAgICAgejogZWZmZWN0Q2ZnLnosXG4gICAgICB6bGV2ZWw6IGVmZmVjdENmZy56bGV2ZWwsXG4gICAgICBzdHlsZToge1xuICAgICAgICBzdHJva2U6IGVmZmVjdENmZy5icnVzaFR5cGUgPT09ICdzdHJva2UnID8gY29sb3IgOiBudWxsLFxuICAgICAgICBmaWxsOiBlZmZlY3RDZmcuYnJ1c2hUeXBlID09PSAnZmlsbCcgPyBjb2xvciA6IG51bGxcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG52YXIgRWZmZWN0U3ltYm9sID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEVmZmVjdFN5bWJvbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRWZmZWN0U3ltYm9sKGRhdGEsIGlkeCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgdmFyIHN5bWJvbCA9IG5ldyBTeW1ib2xDbHooZGF0YSwgaWR4KTtcbiAgICB2YXIgcmlwcGxlR3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgICBfdGhpcy5hZGQoc3ltYm9sKTtcbiAgICBfdGhpcy5hZGQocmlwcGxlR3JvdXApO1xuICAgIF90aGlzLnVwZGF0ZURhdGEoZGF0YSwgaWR4KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgRWZmZWN0U3ltYm9sLnByb3RvdHlwZS5zdG9wRWZmZWN0QW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2hpbGRBdCgxKS5yZW1vdmVBbGwoKTtcbiAgfTtcbiAgRWZmZWN0U3ltYm9sLnByb3RvdHlwZS5zdGFydEVmZmVjdEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChlZmZlY3RDZmcpIHtcbiAgICB2YXIgc3ltYm9sVHlwZSA9IGVmZmVjdENmZy5zeW1ib2xUeXBlO1xuICAgIHZhciBjb2xvciA9IGVmZmVjdENmZy5jb2xvcjtcbiAgICB2YXIgcmlwcGxlTnVtYmVyID0gZWZmZWN0Q2ZnLnJpcHBsZU51bWJlcjtcbiAgICB2YXIgcmlwcGxlR3JvdXAgPSB0aGlzLmNoaWxkQXQoMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaXBwbGVOdW1iZXI7IGkrKykge1xuICAgICAgLy8gSWYgd2lkdGgvaGVpZ2h0IGFyZSBzZXQgdG9vIHNtYWxsIChlLmcuLCBzZXQgdG8gMSkgb24gaW9zMTBcbiAgICAgIC8vIGFuZCBtYWNPUyBTaWVycmEsIGEgY2lyY2xlIHN0cm9rZSBiZWNvbWUgYSByZWN0LCBubyBtYXR0ZXIgd2hhdFxuICAgICAgLy8gdGhlIHNjYWxlIGlzIHNldC4gU28gd2Ugc2V0IHdpZHRoL2hlaWdodCBhcyAyLiBTZWUgIzQxMzYuXG4gICAgICB2YXIgcmlwcGxlUGF0aCA9IGNyZWF0ZVN5bWJvbChzeW1ib2xUeXBlLCAtMSwgLTEsIDIsIDIsIGNvbG9yKTtcbiAgICAgIHJpcHBsZVBhdGguYXR0cih7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgc3Ryb2tlTm9TY2FsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB6MjogOTksXG4gICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgc2NhbGVYOiAwLjUsXG4gICAgICAgIHNjYWxlWTogMC41XG4gICAgICB9KTtcbiAgICAgIHZhciBkZWxheSA9IC1pIC8gcmlwcGxlTnVtYmVyICogZWZmZWN0Q2ZnLnBlcmlvZCArIGVmZmVjdENmZy5lZmZlY3RPZmZzZXQ7XG4gICAgICByaXBwbGVQYXRoLmFuaW1hdGUoJycsIHRydWUpLndoZW4oZWZmZWN0Q2ZnLnBlcmlvZCwge1xuICAgICAgICBzY2FsZVg6IGVmZmVjdENmZy5yaXBwbGVTY2FsZSAvIDIsXG4gICAgICAgIHNjYWxlWTogZWZmZWN0Q2ZnLnJpcHBsZVNjYWxlIC8gMlxuICAgICAgfSkuZGVsYXkoZGVsYXkpLnN0YXJ0KCk7XG4gICAgICByaXBwbGVQYXRoLmFuaW1hdGVTdHlsZSh0cnVlKS53aGVuKGVmZmVjdENmZy5wZXJpb2QsIHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSkuZGVsYXkoZGVsYXkpLnN0YXJ0KCk7XG4gICAgICByaXBwbGVHcm91cC5hZGQocmlwcGxlUGF0aCk7XG4gICAgfVxuICAgIHVwZGF0ZVJpcHBsZVBhdGgocmlwcGxlR3JvdXAsIGVmZmVjdENmZyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBlZmZlY3Qgc3ltYm9sXHJcbiAgICovXG4gIEVmZmVjdFN5bWJvbC5wcm90b3R5cGUudXBkYXRlRWZmZWN0QW5pbWF0aW9uID0gZnVuY3Rpb24gKGVmZmVjdENmZykge1xuICAgIHZhciBvbGRFZmZlY3RDZmcgPSB0aGlzLl9lZmZlY3RDZmc7XG4gICAgdmFyIHJpcHBsZUdyb3VwID0gdGhpcy5jaGlsZEF0KDEpO1xuICAgIC8vIE11c3QgcmVpbml0aWFsaXplIGVmZmVjdCBpZiBmb2xsb3dpbmcgY29uZmlndXJhdGlvbiBjaGFuZ2VkXG4gICAgdmFyIERJRkZJQ1VMVF9QUk9QUyA9IFsnc3ltYm9sVHlwZScsICdwZXJpb2QnLCAncmlwcGxlU2NhbGUnLCAncmlwcGxlTnVtYmVyJ107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBESUZGSUNVTFRfUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wTmFtZSA9IERJRkZJQ1VMVF9QUk9QU1tpXTtcbiAgICAgIGlmIChvbGRFZmZlY3RDZmdbcHJvcE5hbWVdICE9PSBlZmZlY3RDZmdbcHJvcE5hbWVdKSB7XG4gICAgICAgIHRoaXMuc3RvcEVmZmVjdEFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLnN0YXJ0RWZmZWN0QW5pbWF0aW9uKGVmZmVjdENmZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlUmlwcGxlUGF0aChyaXBwbGVHcm91cCwgZWZmZWN0Q2ZnKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogSGlnaGxpZ2h0IHN5bWJvbFxyXG4gICAqL1xuICBFZmZlY3RTeW1ib2wucHJvdG90eXBlLmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbnRlckVtcGhhc2lzKHRoaXMpO1xuICB9O1xuICAvKipcclxuICAgKiBEb3ducGxheSBzeW1ib2xcclxuICAgKi9cbiAgRWZmZWN0U3ltYm9sLnByb3RvdHlwZS5kb3ducGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZWF2ZUVtcGhhc2lzKHRoaXMpO1xuICB9O1xuICBFZmZlY3RTeW1ib2wucHJvdG90eXBlLmdldFN5bWJvbFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN5bWJvbCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICByZXR1cm4gc3ltYm9sICYmIHN5bWJvbC5nZXRTeW1ib2xUeXBlKCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBzeW1ib2wgcHJvcGVydGllc1xyXG4gICAqL1xuICBFZmZlY3RTeW1ib2wucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgaWR4KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICB0aGlzLmNoaWxkQXQoMCkudXBkYXRlRGF0YShkYXRhLCBpZHgpO1xuICAgIHZhciByaXBwbGVHcm91cCA9IHRoaXMuY2hpbGRBdCgxKTtcbiAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICB2YXIgc3ltYm9sVHlwZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKTtcbiAgICB2YXIgc3ltYm9sU2l6ZSA9IG5vcm1hbGl6ZVN5bWJvbFNpemUoZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFNpemUnKSk7XG4gICAgdmFyIHN5bWJvbFN0eWxlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJyk7XG4gICAgdmFyIGNvbG9yID0gc3ltYm9sU3R5bGUgJiYgc3ltYm9sU3R5bGUuZmlsbDtcbiAgICB2YXIgZW1waGFzaXNNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKTtcbiAgICByaXBwbGVHcm91cC5zZXRTY2FsZShzeW1ib2xTaXplKTtcbiAgICByaXBwbGVHcm91cC50cmF2ZXJzZShmdW5jdGlvbiAocmlwcGxlUGF0aCkge1xuICAgICAgcmlwcGxlUGF0aC5zZXRTdHlsZSgnZmlsbCcsIGNvbG9yKTtcbiAgICB9KTtcbiAgICB2YXIgc3ltYm9sT2Zmc2V0ID0gbm9ybWFsaXplU3ltYm9sT2Zmc2V0KGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xPZmZzZXQnKSwgc3ltYm9sU2l6ZSk7XG4gICAgaWYgKHN5bWJvbE9mZnNldCkge1xuICAgICAgcmlwcGxlR3JvdXAueCA9IHN5bWJvbE9mZnNldFswXTtcbiAgICAgIHJpcHBsZUdyb3VwLnkgPSBzeW1ib2xPZmZzZXRbMV07XG4gICAgfVxuICAgIHZhciBzeW1ib2xSb3RhdGUgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sUm90YXRlJyk7XG4gICAgcmlwcGxlR3JvdXAucm90YXRpb24gPSAoc3ltYm9sUm90YXRlIHx8IDApICogTWF0aC5QSSAvIDE4MCB8fCAwO1xuICAgIHZhciBlZmZlY3RDZmcgPSB7fTtcbiAgICBlZmZlY3RDZmcuc2hvd0VmZmVjdE9uID0gc2VyaWVzTW9kZWwuZ2V0KCdzaG93RWZmZWN0T24nKTtcbiAgICBlZmZlY3RDZmcucmlwcGxlU2NhbGUgPSBpdGVtTW9kZWwuZ2V0KFsncmlwcGxlRWZmZWN0JywgJ3NjYWxlJ10pO1xuICAgIGVmZmVjdENmZy5icnVzaFR5cGUgPSBpdGVtTW9kZWwuZ2V0KFsncmlwcGxlRWZmZWN0JywgJ2JydXNoVHlwZSddKTtcbiAgICBlZmZlY3RDZmcucGVyaW9kID0gaXRlbU1vZGVsLmdldChbJ3JpcHBsZUVmZmVjdCcsICdwZXJpb2QnXSkgKiAxMDAwO1xuICAgIGVmZmVjdENmZy5lZmZlY3RPZmZzZXQgPSBpZHggLyBkYXRhLmNvdW50KCk7XG4gICAgZWZmZWN0Q2ZnLnogPSBzZXJpZXNNb2RlbC5nZXRTaGFsbG93KCd6JykgfHwgMDtcbiAgICBlZmZlY3RDZmcuemxldmVsID0gc2VyaWVzTW9kZWwuZ2V0U2hhbGxvdygnemxldmVsJykgfHwgMDtcbiAgICBlZmZlY3RDZmcuc3ltYm9sVHlwZSA9IHN5bWJvbFR5cGU7XG4gICAgZWZmZWN0Q2ZnLmNvbG9yID0gY29sb3I7XG4gICAgZWZmZWN0Q2ZnLnJpcHBsZUVmZmVjdENvbG9yID0gaXRlbU1vZGVsLmdldChbJ3JpcHBsZUVmZmVjdCcsICdjb2xvciddKTtcbiAgICBlZmZlY3RDZmcucmlwcGxlTnVtYmVyID0gaXRlbU1vZGVsLmdldChbJ3JpcHBsZUVmZmVjdCcsICdudW1iZXInXSk7XG4gICAgaWYgKGVmZmVjdENmZy5zaG93RWZmZWN0T24gPT09ICdyZW5kZXInKSB7XG4gICAgICB0aGlzLl9lZmZlY3RDZmcgPyB0aGlzLnVwZGF0ZUVmZmVjdEFuaW1hdGlvbihlZmZlY3RDZmcpIDogdGhpcy5zdGFydEVmZmVjdEFuaW1hdGlvbihlZmZlY3RDZmcpO1xuICAgICAgdGhpcy5fZWZmZWN0Q2ZnID0gZWZmZWN0Q2ZnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb3Qga2VlcCBvbGQgZWZmZWN0IGNvbmZpZ1xuICAgICAgdGhpcy5fZWZmZWN0Q2ZnID0gbnVsbDtcbiAgICAgIHRoaXMuc3RvcEVmZmVjdEFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5vbkhvdmVyU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAodG9TdGF0ZSkge1xuICAgICAgICBpZiAodG9TdGF0ZSA9PT0gJ2VtcGhhc2lzJykge1xuICAgICAgICAgIGlmIChlZmZlY3RDZmcuc2hvd0VmZmVjdE9uICE9PSAncmVuZGVyJykge1xuICAgICAgICAgICAgX3RoaXMuc3RhcnRFZmZlY3RBbmltYXRpb24oZWZmZWN0Q2ZnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodG9TdGF0ZSA9PT0gJ25vcm1hbCcpIHtcbiAgICAgICAgICBpZiAoZWZmZWN0Q2ZnLnNob3dFZmZlY3RPbiAhPT0gJ3JlbmRlcicpIHtcbiAgICAgICAgICAgIF90aGlzLnN0b3BFZmZlY3RBbmltYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2VmZmVjdENmZyA9IGVmZmVjdENmZztcbiAgICB0b2dnbGVIb3ZlckVtcGhhc2lzKHRoaXMsIGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpLCBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJyksIGVtcGhhc2lzTW9kZWwuZ2V0KCdkaXNhYmxlZCcpKTtcbiAgfTtcbiAgO1xuICBFZmZlY3RTeW1ib2wucHJvdG90eXBlLmZhZGVPdXQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICBjYiAmJiBjYigpO1xuICB9O1xuICA7XG4gIHJldHVybiBFZmZlY3RTeW1ib2w7XG59KEdyb3VwKTtcbmV4cG9ydCBkZWZhdWx0IEVmZmVjdFN5bWJvbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///71465\n")},72731:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ createSeriesDataSimply)\n/* harmony export */ });\n/* harmony import */ var _data_helper_createDimensions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97351);\n/* harmony import */ var _data_SeriesData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6006);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n/**\r\n * [Usage]:\r\n * (1)\r\n * createListSimply(seriesModel, [\'value\']);\r\n * (2)\r\n * createListSimply(seriesModel, {\r\n *     coordDimensions: [\'value\'],\r\n *     dimensionsCount: 5\r\n * });\r\n */\nfunction createSeriesDataSimply(seriesModel, opt, nameList) {\n  opt = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(opt) && {\n    coordDimensions: opt\n  } || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend)({\n    encodeDefine: seriesModel.getEncode()\n  }, opt);\n  var source = seriesModel.getSource();\n  var dimensions = (0,_data_helper_createDimensions_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(source, opt).dimensions;\n  var list = new _data_SeriesData_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A(dimensions, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI3MzEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvY3JlYXRlU2VyaWVzRGF0YVNpbXBseS5qcz84MGI2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHByZXBhcmVTZXJpZXNEYXRhU2NoZW1hIGZyb20gJy4uLy4uL2RhdGEvaGVscGVyL2NyZWF0ZURpbWVuc2lvbnMuanMnO1xuaW1wb3J0IFNlcmllc0RhdGEgZnJvbSAnLi4vLi4vZGF0YS9TZXJpZXNEYXRhLmpzJztcbmltcG9ydCB7IGV4dGVuZCwgaXNBcnJheSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG4vKipcclxuICogW1VzYWdlXTpcclxuICogKDEpXHJcbiAqIGNyZWF0ZUxpc3RTaW1wbHkoc2VyaWVzTW9kZWwsIFsndmFsdWUnXSk7XHJcbiAqICgyKVxyXG4gKiBjcmVhdGVMaXN0U2ltcGx5KHNlcmllc01vZGVsLCB7XHJcbiAqICAgICBjb29yZERpbWVuc2lvbnM6IFsndmFsdWUnXSxcclxuICogICAgIGRpbWVuc2lvbnNDb3VudDogNVxyXG4gKiB9KTtcclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVTZXJpZXNEYXRhU2ltcGx5KHNlcmllc01vZGVsLCBvcHQsIG5hbWVMaXN0KSB7XG4gIG9wdCA9IGlzQXJyYXkob3B0KSAmJiB7XG4gICAgY29vcmREaW1lbnNpb25zOiBvcHRcbiAgfSB8fCBleHRlbmQoe1xuICAgIGVuY29kZURlZmluZTogc2VyaWVzTW9kZWwuZ2V0RW5jb2RlKClcbiAgfSwgb3B0KTtcbiAgdmFyIHNvdXJjZSA9IHNlcmllc01vZGVsLmdldFNvdXJjZSgpO1xuICB2YXIgZGltZW5zaW9ucyA9IHByZXBhcmVTZXJpZXNEYXRhU2NoZW1hKHNvdXJjZSwgb3B0KS5kaW1lbnNpb25zO1xuICB2YXIgbGlzdCA9IG5ldyBTZXJpZXNEYXRhKGRpbWVuc2lvbnMsIHNlcmllc01vZGVsKTtcbiAgbGlzdC5pbml0RGF0YShzb3VyY2UsIG5hbWVMaXN0KTtcbiAgcmV0dXJuIGxpc3Q7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///72731\n')},79446:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   i: () => (/* binding */ getSectorCornerRadius)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var zrender_lib_contain_text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45558);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction getSectorCornerRadius(model, shape, zeroIfNull) {\n  var cornerRadius = model.get(\'borderRadius\');\n  if (cornerRadius == null) {\n    return zeroIfNull ? {\n      cornerRadius: 0\n    } : null;\n  }\n  if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(cornerRadius)) {\n    cornerRadius = [cornerRadius, cornerRadius, cornerRadius, cornerRadius];\n  }\n  var dr = Math.abs(shape.r || 0 - shape.r0 || 0);\n  return {\n    cornerRadius: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)(cornerRadius, function (cr) {\n      return (0,zrender_lib_contain_text_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(cr, dr);\n    })\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk0NDYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9zZWN0b3JIZWxwZXIuanM/MTcxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGlzQXJyYXksIG1hcCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBwYXJzZVBlcmNlbnQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb250YWluL3RleHQuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNlY3RvckNvcm5lclJhZGl1cyhtb2RlbCwgc2hhcGUsIHplcm9JZk51bGwpIHtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IG1vZGVsLmdldCgnYm9yZGVyUmFkaXVzJyk7XG4gIGlmIChjb3JuZXJSYWRpdXMgPT0gbnVsbCkge1xuICAgIHJldHVybiB6ZXJvSWZOdWxsID8ge1xuICAgICAgY29ybmVyUmFkaXVzOiAwXG4gICAgfSA6IG51bGw7XG4gIH1cbiAgaWYgKCFpc0FycmF5KGNvcm5lclJhZGl1cykpIHtcbiAgICBjb3JuZXJSYWRpdXMgPSBbY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzXTtcbiAgfVxuICB2YXIgZHIgPSBNYXRoLmFicyhzaGFwZS5yIHx8IDAgLSBzaGFwZS5yMCB8fCAwKTtcbiAgcmV0dXJuIHtcbiAgICBjb3JuZXJSYWRpdXM6IG1hcChjb3JuZXJSYWRpdXMsIGZ1bmN0aW9uIChjcikge1xuICAgICAgcmV0dXJuIHBhcnNlUGVyY2VudChjciwgZHIpO1xuICAgIH0pXG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///79446\n')},82681:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29308);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(59482);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(43870);\n/* harmony import */ var zrender_lib_contain_line_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57043);\n/* harmony import */ var zrender_lib_contain_quadratic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14423);\n/* harmony import */ var _util_innerStore_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(69622);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n// TODO Batch by color\n\n\n\n\nvar LargeLinesPathShape = /** @class */function () {\n  function LargeLinesPathShape() {\n    this.polyline = false;\n    this.curveness = 0;\n    this.segs = [];\n  }\n  return LargeLinesPathShape;\n}();\nvar LargeLinesPath = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(LargeLinesPath, _super);\n  function LargeLinesPath(opts) {\n    var _this = _super.call(this, opts) || this;\n    _this._off = 0;\n    _this.hoverDataIdx = -1;\n    return _this;\n  }\n  LargeLinesPath.prototype.reset = function () {\n    this.notClear = false;\n    this._off = 0;\n  };\n  LargeLinesPath.prototype.getDefaultStyle = function () {\n    return {\n      stroke: '#000',\n      fill: null\n    };\n  };\n  LargeLinesPath.prototype.getDefaultShape = function () {\n    return new LargeLinesPathShape();\n  };\n  LargeLinesPath.prototype.buildPath = function (ctx, shape) {\n    var segs = shape.segs;\n    var curveness = shape.curveness;\n    var i;\n    if (shape.polyline) {\n      for (i = this._off; i < segs.length;) {\n        var count = segs[i++];\n        if (count > 0) {\n          ctx.moveTo(segs[i++], segs[i++]);\n          for (var k = 1; k < count; k++) {\n            ctx.lineTo(segs[i++], segs[i++]);\n          }\n        }\n      }\n    } else {\n      for (i = this._off; i < segs.length;) {\n        var x0 = segs[i++];\n        var y0 = segs[i++];\n        var x1 = segs[i++];\n        var y1 = segs[i++];\n        ctx.moveTo(x0, y0);\n        if (curveness > 0) {\n          var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;\n          var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;\n          ctx.quadraticCurveTo(x2, y2, x1, y1);\n        } else {\n          ctx.lineTo(x1, y1);\n        }\n      }\n    }\n    if (this.incremental) {\n      this._off = i;\n      this.notClear = true;\n    }\n  };\n  LargeLinesPath.prototype.findDataIndex = function (x, y) {\n    var shape = this.shape;\n    var segs = shape.segs;\n    var curveness = shape.curveness;\n    var lineWidth = this.style.lineWidth;\n    if (shape.polyline) {\n      var dataIndex = 0;\n      for (var i = 0; i < segs.length;) {\n        var count = segs[i++];\n        if (count > 0) {\n          var x0 = segs[i++];\n          var y0 = segs[i++];\n          for (var k = 1; k < count; k++) {\n            var x1 = segs[i++];\n            var y1 = segs[i++];\n            if (zrender_lib_contain_line_js__WEBPACK_IMPORTED_MODULE_1__/* .containStroke */ .l(x0, y0, x1, y1, lineWidth, x, y)) {\n              return dataIndex;\n            }\n          }\n        }\n        dataIndex++;\n      }\n    } else {\n      var dataIndex = 0;\n      for (var i = 0; i < segs.length;) {\n        var x0 = segs[i++];\n        var y0 = segs[i++];\n        var x1 = segs[i++];\n        var y1 = segs[i++];\n        if (curveness > 0) {\n          var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;\n          var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;\n          if (zrender_lib_contain_quadratic_js__WEBPACK_IMPORTED_MODULE_2__/* .containStroke */ .l(x0, y0, x2, y2, x1, y1, lineWidth, x, y)) {\n            return dataIndex;\n          }\n        } else {\n          if (zrender_lib_contain_line_js__WEBPACK_IMPORTED_MODULE_1__/* .containStroke */ .l(x0, y0, x1, y1, lineWidth, x, y)) {\n            return dataIndex;\n          }\n        }\n        dataIndex++;\n      }\n    }\n    return -1;\n  };\n  LargeLinesPath.prototype.contain = function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    x = localPos[0];\n    y = localPos[1];\n    if (rect.contain(x, y)) {\n      // Cache found data index.\n      var dataIdx = this.hoverDataIdx = this.findDataIndex(x, y);\n      return dataIdx >= 0;\n    }\n    this.hoverDataIdx = -1;\n    return false;\n  };\n  LargeLinesPath.prototype.getBoundingRect = function () {\n    // Ignore stroke for large symbol draw.\n    var rect = this._rect;\n    if (!rect) {\n      var shape = this.shape;\n      var points = shape.segs;\n      var minX = Infinity;\n      var minY = Infinity;\n      var maxX = -Infinity;\n      var maxY = -Infinity;\n      for (var i = 0; i < points.length;) {\n        var x = points[i++];\n        var y = points[i++];\n        minX = Math.min(x, minX);\n        maxX = Math.max(x, maxX);\n        minY = Math.min(y, minY);\n        maxY = Math.max(y, maxY);\n      }\n      rect = this._rect = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A(minX, minY, maxX, maxY);\n    }\n    return rect;\n  };\n  return LargeLinesPath;\n}(_util_graphic_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .Ay);\nvar LargeLineDraw = /** @class */function () {\n  function LargeLineDraw() {\n    this.group = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A();\n  }\n  /**\r\n   * Update symbols draw by new data\r\n   */\n  LargeLineDraw.prototype.updateData = function (data) {\n    this._clear();\n    var lineEl = this._create();\n    lineEl.setShape({\n      segs: data.getLayout('linesPoints')\n    });\n    this._setCommon(lineEl, data);\n  };\n  ;\n  /**\r\n   * @override\r\n   */\n  LargeLineDraw.prototype.incrementalPrepareUpdate = function (data) {\n    this.group.removeAll();\n    this._clear();\n  };\n  ;\n  /**\r\n   * @override\r\n   */\n  LargeLineDraw.prototype.incrementalUpdate = function (taskParams, data) {\n    var lastAdded = this._newAdded[0];\n    var linePoints = data.getLayout('linesPoints');\n    var oldSegs = lastAdded && lastAdded.shape.segs;\n    // Merging the exists. Each element has 1e4 points.\n    // Consider the performance balance between too much elements and too much points in one shape(may affect hover optimization)\n    if (oldSegs && oldSegs.length < 2e4) {\n      var oldLen = oldSegs.length;\n      var newSegs = new Float32Array(oldLen + linePoints.length);\n      // Concat two array\n      newSegs.set(oldSegs);\n      newSegs.set(linePoints, oldLen);\n      lastAdded.setShape({\n        segs: newSegs\n      });\n    } else {\n      // Clear\n      this._newAdded = [];\n      var lineEl = this._create();\n      lineEl.incremental = true;\n      lineEl.setShape({\n        segs: linePoints\n      });\n      this._setCommon(lineEl, data);\n      lineEl.__startIndex = taskParams.start;\n    }\n  };\n  /**\r\n   * @override\r\n   */\n  LargeLineDraw.prototype.remove = function () {\n    this._clear();\n  };\n  LargeLineDraw.prototype.eachRendered = function (cb) {\n    this._newAdded[0] && cb(this._newAdded[0]);\n  };\n  LargeLineDraw.prototype._create = function () {\n    var lineEl = new LargeLinesPath({\n      cursor: 'default',\n      ignoreCoarsePointer: true\n    });\n    this._newAdded.push(lineEl);\n    this.group.add(lineEl);\n    return lineEl;\n  };\n  LargeLineDraw.prototype._setCommon = function (lineEl, data, isIncremental) {\n    var hostModel = data.hostModel;\n    lineEl.setShape({\n      polyline: hostModel.get('polyline'),\n      curveness: hostModel.get(['lineStyle', 'curveness'])\n    });\n    lineEl.useStyle(hostModel.getModel('lineStyle').getLineStyle());\n    lineEl.style.strokeNoScale = true;\n    var style = data.getVisual('style');\n    if (style && style.stroke) {\n      lineEl.setStyle('stroke', style.stroke);\n    }\n    lineEl.setStyle('fill', null);\n    var ecData = (0,_util_innerStore_js__WEBPACK_IMPORTED_MODULE_6__/* .getECData */ .z)(lineEl);\n    // Enable tooltip\n    // PENDING May have performance issue when path is extremely large\n    ecData.seriesIndex = hostModel.seriesIndex;\n    lineEl.on('mousemove', function (e) {\n      ecData.dataIndex = null;\n      var dataIndex = lineEl.hoverDataIdx;\n      if (dataIndex > 0) {\n        // Provide dataIndex for tooltip\n        ecData.dataIndex = dataIndex + lineEl.__startIndex;\n      }\n    });\n  };\n  ;\n  LargeLineDraw.prototype._clear = function () {\n    this._newAdded = [];\n    this.group.removeAll();\n  };\n  ;\n  return LargeLineDraw;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LargeLineDraw);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI2ODEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL0xhcmdlTGluZURyYXcuanM/N2NmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuLy8gVE9ETyBCYXRjaCBieSBjb2xvclxuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0ICogYXMgbGluZUNvbnRhaW4gZnJvbSAnenJlbmRlci9saWIvY29udGFpbi9saW5lLmpzJztcbmltcG9ydCAqIGFzIHF1YWRyYXRpY0NvbnRhaW4gZnJvbSAnenJlbmRlci9saWIvY29udGFpbi9xdWFkcmF0aWMuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlLmpzJztcbnZhciBMYXJnZUxpbmVzUGF0aFNoYXBlID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGFyZ2VMaW5lc1BhdGhTaGFwZSgpIHtcbiAgICB0aGlzLnBvbHlsaW5lID0gZmFsc2U7XG4gICAgdGhpcy5jdXJ2ZW5lc3MgPSAwO1xuICAgIHRoaXMuc2VncyA9IFtdO1xuICB9XG4gIHJldHVybiBMYXJnZUxpbmVzUGF0aFNoYXBlO1xufSgpO1xudmFyIExhcmdlTGluZXNQYXRoID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKExhcmdlTGluZXNQYXRoLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBMYXJnZUxpbmVzUGF0aChvcHRzKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgICBfdGhpcy5fb2ZmID0gMDtcbiAgICBfdGhpcy5ob3ZlckRhdGFJZHggPSAtMTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgTGFyZ2VMaW5lc1BhdGgucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubm90Q2xlYXIgPSBmYWxzZTtcbiAgICB0aGlzLl9vZmYgPSAwO1xuICB9O1xuICBMYXJnZUxpbmVzUGF0aC5wcm90b3R5cGUuZ2V0RGVmYXVsdFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgIGZpbGw6IG51bGxcbiAgICB9O1xuICB9O1xuICBMYXJnZUxpbmVzUGF0aC5wcm90b3R5cGUuZ2V0RGVmYXVsdFNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgTGFyZ2VMaW5lc1BhdGhTaGFwZSgpO1xuICB9O1xuICBMYXJnZUxpbmVzUGF0aC5wcm90b3R5cGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgc2VncyA9IHNoYXBlLnNlZ3M7XG4gICAgdmFyIGN1cnZlbmVzcyA9IHNoYXBlLmN1cnZlbmVzcztcbiAgICB2YXIgaTtcbiAgICBpZiAoc2hhcGUucG9seWxpbmUpIHtcbiAgICAgIGZvciAoaSA9IHRoaXMuX29mZjsgaSA8IHNlZ3MubGVuZ3RoOykge1xuICAgICAgICB2YXIgY291bnQgPSBzZWdzW2krK107XG4gICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICBjdHgubW92ZVRvKHNlZ3NbaSsrXSwgc2Vnc1tpKytdKTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gMTsgayA8IGNvdW50OyBrKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oc2Vnc1tpKytdLCBzZWdzW2krK10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSB0aGlzLl9vZmY7IGkgPCBzZWdzLmxlbmd0aDspIHtcbiAgICAgICAgdmFyIHgwID0gc2Vnc1tpKytdO1xuICAgICAgICB2YXIgeTAgPSBzZWdzW2krK107XG4gICAgICAgIHZhciB4MSA9IHNlZ3NbaSsrXTtcbiAgICAgICAgdmFyIHkxID0gc2Vnc1tpKytdO1xuICAgICAgICBjdHgubW92ZVRvKHgwLCB5MCk7XG4gICAgICAgIGlmIChjdXJ2ZW5lc3MgPiAwKSB7XG4gICAgICAgICAgdmFyIHgyID0gKHgwICsgeDEpIC8gMiAtICh5MCAtIHkxKSAqIGN1cnZlbmVzcztcbiAgICAgICAgICB2YXIgeTIgPSAoeTAgKyB5MSkgLyAyIC0gKHgxIC0geDApICogY3VydmVuZXNzO1xuICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgyLCB5MiwgeDEsIHkxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgubGluZVRvKHgxLCB5MSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaW5jcmVtZW50YWwpIHtcbiAgICAgIHRoaXMuX29mZiA9IGk7XG4gICAgICB0aGlzLm5vdENsZWFyID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIExhcmdlTGluZXNQYXRoLnByb3RvdHlwZS5maW5kRGF0YUluZGV4ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgIHZhciBzZWdzID0gc2hhcGUuc2VncztcbiAgICB2YXIgY3VydmVuZXNzID0gc2hhcGUuY3VydmVuZXNzO1xuICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLnN0eWxlLmxpbmVXaWR0aDtcbiAgICBpZiAoc2hhcGUucG9seWxpbmUpIHtcbiAgICAgIHZhciBkYXRhSW5kZXggPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDspIHtcbiAgICAgICAgdmFyIGNvdW50ID0gc2Vnc1tpKytdO1xuICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgdmFyIHgwID0gc2Vnc1tpKytdO1xuICAgICAgICAgIHZhciB5MCA9IHNlZ3NbaSsrXTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gMTsgayA8IGNvdW50OyBrKyspIHtcbiAgICAgICAgICAgIHZhciB4MSA9IHNlZ3NbaSsrXTtcbiAgICAgICAgICAgIHZhciB5MSA9IHNlZ3NbaSsrXTtcbiAgICAgICAgICAgIGlmIChsaW5lQ29udGFpbi5jb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRhSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRhdGFJbmRleCsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YUluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7KSB7XG4gICAgICAgIHZhciB4MCA9IHNlZ3NbaSsrXTtcbiAgICAgICAgdmFyIHkwID0gc2Vnc1tpKytdO1xuICAgICAgICB2YXIgeDEgPSBzZWdzW2krK107XG4gICAgICAgIHZhciB5MSA9IHNlZ3NbaSsrXTtcbiAgICAgICAgaWYgKGN1cnZlbmVzcyA+IDApIHtcbiAgICAgICAgICB2YXIgeDIgPSAoeDAgKyB4MSkgLyAyIC0gKHkwIC0geTEpICogY3VydmVuZXNzO1xuICAgICAgICAgIHZhciB5MiA9ICh5MCArIHkxKSAvIDIgLSAoeDEgLSB4MCkgKiBjdXJ2ZW5lc3M7XG4gICAgICAgICAgaWYgKHF1YWRyYXRpY0NvbnRhaW4uY29udGFpblN0cm9rZSh4MCwgeTAsIHgyLCB5MiwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YUluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobGluZUNvbnRhaW4uY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YUluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfTtcbiAgTGFyZ2VMaW5lc1BhdGgucHJvdG90eXBlLmNvbnRhaW4gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciBsb2NhbFBvcyA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB4ID0gbG9jYWxQb3NbMF07XG4gICAgeSA9IGxvY2FsUG9zWzFdO1xuICAgIGlmIChyZWN0LmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgIC8vIENhY2hlIGZvdW5kIGRhdGEgaW5kZXguXG4gICAgICB2YXIgZGF0YUlkeCA9IHRoaXMuaG92ZXJEYXRhSWR4ID0gdGhpcy5maW5kRGF0YUluZGV4KHgsIHkpO1xuICAgICAgcmV0dXJuIGRhdGFJZHggPj0gMDtcbiAgICB9XG4gICAgdGhpcy5ob3ZlckRhdGFJZHggPSAtMTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIExhcmdlTGluZXNQYXRoLnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gSWdub3JlIHN0cm9rZSBmb3IgbGFyZ2Ugc3ltYm9sIGRyYXcuXG4gICAgdmFyIHJlY3QgPSB0aGlzLl9yZWN0O1xuICAgIGlmICghcmVjdCkge1xuICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgIHZhciBwb2ludHMgPSBzaGFwZS5zZWdzO1xuICAgICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOykge1xuICAgICAgICB2YXIgeCA9IHBvaW50c1tpKytdO1xuICAgICAgICB2YXIgeSA9IHBvaW50c1tpKytdO1xuICAgICAgICBtaW5YID0gTWF0aC5taW4oeCwgbWluWCk7XG4gICAgICAgIG1heFggPSBNYXRoLm1heCh4LCBtYXhYKTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKHksIG1pblkpO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgoeSwgbWF4WSk7XG4gICAgICB9XG4gICAgICByZWN0ID0gdGhpcy5fcmVjdCA9IG5ldyBncmFwaGljLkJvdW5kaW5nUmVjdChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH07XG4gIHJldHVybiBMYXJnZUxpbmVzUGF0aDtcbn0oZ3JhcGhpYy5QYXRoKTtcbnZhciBMYXJnZUxpbmVEcmF3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGFyZ2VMaW5lRHJhdygpIHtcbiAgICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGUgc3ltYm9scyBkcmF3IGJ5IG5ldyBkYXRhXHJcbiAgICovXG4gIExhcmdlTGluZURyYXcucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgdmFyIGxpbmVFbCA9IHRoaXMuX2NyZWF0ZSgpO1xuICAgIGxpbmVFbC5zZXRTaGFwZSh7XG4gICAgICBzZWdzOiBkYXRhLmdldExheW91dCgnbGluZXNQb2ludHMnKVxuICAgIH0pO1xuICAgIHRoaXMuX3NldENvbW1vbihsaW5lRWwsIGRhdGEpO1xuICB9O1xuICA7XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBMYXJnZUxpbmVEcmF3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFByZXBhcmVVcGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5fY2xlYXIoKTtcbiAgfTtcbiAgO1xuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgTGFyZ2VMaW5lRHJhdy5wcm90b3R5cGUuaW5jcmVtZW50YWxVcGRhdGUgPSBmdW5jdGlvbiAodGFza1BhcmFtcywgZGF0YSkge1xuICAgIHZhciBsYXN0QWRkZWQgPSB0aGlzLl9uZXdBZGRlZFswXTtcbiAgICB2YXIgbGluZVBvaW50cyA9IGRhdGEuZ2V0TGF5b3V0KCdsaW5lc1BvaW50cycpO1xuICAgIHZhciBvbGRTZWdzID0gbGFzdEFkZGVkICYmIGxhc3RBZGRlZC5zaGFwZS5zZWdzO1xuICAgIC8vIE1lcmdpbmcgdGhlIGV4aXN0cy4gRWFjaCBlbGVtZW50IGhhcyAxZTQgcG9pbnRzLlxuICAgIC8vIENvbnNpZGVyIHRoZSBwZXJmb3JtYW5jZSBiYWxhbmNlIGJldHdlZW4gdG9vIG11Y2ggZWxlbWVudHMgYW5kIHRvbyBtdWNoIHBvaW50cyBpbiBvbmUgc2hhcGUobWF5IGFmZmVjdCBob3ZlciBvcHRpbWl6YXRpb24pXG4gICAgaWYgKG9sZFNlZ3MgJiYgb2xkU2Vncy5sZW5ndGggPCAyZTQpIHtcbiAgICAgIHZhciBvbGRMZW4gPSBvbGRTZWdzLmxlbmd0aDtcbiAgICAgIHZhciBuZXdTZWdzID0gbmV3IEZsb2F0MzJBcnJheShvbGRMZW4gKyBsaW5lUG9pbnRzLmxlbmd0aCk7XG4gICAgICAvLyBDb25jYXQgdHdvIGFycmF5XG4gICAgICBuZXdTZWdzLnNldChvbGRTZWdzKTtcbiAgICAgIG5ld1NlZ3Muc2V0KGxpbmVQb2ludHMsIG9sZExlbik7XG4gICAgICBsYXN0QWRkZWQuc2V0U2hhcGUoe1xuICAgICAgICBzZWdzOiBuZXdTZWdzXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2xlYXJcbiAgICAgIHRoaXMuX25ld0FkZGVkID0gW107XG4gICAgICB2YXIgbGluZUVsID0gdGhpcy5fY3JlYXRlKCk7XG4gICAgICBsaW5lRWwuaW5jcmVtZW50YWwgPSB0cnVlO1xuICAgICAgbGluZUVsLnNldFNoYXBlKHtcbiAgICAgICAgc2VnczogbGluZVBvaW50c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRDb21tb24obGluZUVsLCBkYXRhKTtcbiAgICAgIGxpbmVFbC5fX3N0YXJ0SW5kZXggPSB0YXNrUGFyYW1zLnN0YXJ0O1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXG4gIExhcmdlTGluZURyYXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jbGVhcigpO1xuICB9O1xuICBMYXJnZUxpbmVEcmF3LnByb3RvdHlwZS5lYWNoUmVuZGVyZWQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB0aGlzLl9uZXdBZGRlZFswXSAmJiBjYih0aGlzLl9uZXdBZGRlZFswXSk7XG4gIH07XG4gIExhcmdlTGluZURyYXcucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpbmVFbCA9IG5ldyBMYXJnZUxpbmVzUGF0aCh7XG4gICAgICBjdXJzb3I6ICdkZWZhdWx0JyxcbiAgICAgIGlnbm9yZUNvYXJzZVBvaW50ZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9uZXdBZGRlZC5wdXNoKGxpbmVFbCk7XG4gICAgdGhpcy5ncm91cC5hZGQobGluZUVsKTtcbiAgICByZXR1cm4gbGluZUVsO1xuICB9O1xuICBMYXJnZUxpbmVEcmF3LnByb3RvdHlwZS5fc2V0Q29tbW9uID0gZnVuY3Rpb24gKGxpbmVFbCwgZGF0YSwgaXNJbmNyZW1lbnRhbCkge1xuICAgIHZhciBob3N0TW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICBsaW5lRWwuc2V0U2hhcGUoe1xuICAgICAgcG9seWxpbmU6IGhvc3RNb2RlbC5nZXQoJ3BvbHlsaW5lJyksXG4gICAgICBjdXJ2ZW5lc3M6IGhvc3RNb2RlbC5nZXQoWydsaW5lU3R5bGUnLCAnY3VydmVuZXNzJ10pXG4gICAgfSk7XG4gICAgbGluZUVsLnVzZVN0eWxlKGhvc3RNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCkpO1xuICAgIGxpbmVFbC5zdHlsZS5zdHJva2VOb1NjYWxlID0gdHJ1ZTtcbiAgICB2YXIgc3R5bGUgPSBkYXRhLmdldFZpc3VhbCgnc3R5bGUnKTtcbiAgICBpZiAoc3R5bGUgJiYgc3R5bGUuc3Ryb2tlKSB7XG4gICAgICBsaW5lRWwuc2V0U3R5bGUoJ3N0cm9rZScsIHN0eWxlLnN0cm9rZSk7XG4gICAgfVxuICAgIGxpbmVFbC5zZXRTdHlsZSgnZmlsbCcsIG51bGwpO1xuICAgIHZhciBlY0RhdGEgPSBnZXRFQ0RhdGEobGluZUVsKTtcbiAgICAvLyBFbmFibGUgdG9vbHRpcFxuICAgIC8vIFBFTkRJTkcgTWF5IGhhdmUgcGVyZm9ybWFuY2UgaXNzdWUgd2hlbiBwYXRoIGlzIGV4dHJlbWVseSBsYXJnZVxuICAgIGVjRGF0YS5zZXJpZXNJbmRleCA9IGhvc3RNb2RlbC5zZXJpZXNJbmRleDtcbiAgICBsaW5lRWwub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlY0RhdGEuZGF0YUluZGV4ID0gbnVsbDtcbiAgICAgIHZhciBkYXRhSW5kZXggPSBsaW5lRWwuaG92ZXJEYXRhSWR4O1xuICAgICAgaWYgKGRhdGFJbmRleCA+IDApIHtcbiAgICAgICAgLy8gUHJvdmlkZSBkYXRhSW5kZXggZm9yIHRvb2x0aXBcbiAgICAgICAgZWNEYXRhLmRhdGFJbmRleCA9IGRhdGFJbmRleCArIGxpbmVFbC5fX3N0YXJ0SW5kZXg7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIDtcbiAgTGFyZ2VMaW5lRHJhdy5wcm90b3R5cGUuX2NsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25ld0FkZGVkID0gW107XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgfTtcbiAgO1xuICByZXR1cm4gTGFyZ2VMaW5lRHJhdztcbn0oKTtcbmV4cG9ydCBkZWZhdWx0IExhcmdlTGluZURyYXc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///82681\n")},87582:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ createRenderPlanner)\n/* harmony export */ });\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * @return {string} If large mode changed, return string \'reset\';\r\n */\nfunction createRenderPlanner() {\n  var inner = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\n  return function (seriesModel) {\n    var fields = inner(seriesModel);\n    var pipelineContext = seriesModel.pipelineContext;\n    var originalLarge = !!fields.large;\n    var originalProgressive = !!fields.progressiveRender;\n    // FIXME: if the planner works on a filtered series, `pipelineContext` does not\n    // exists. See #11611 . Probably we need to modify this structure, see the comment\n    // on `performRawSeries` in `Schedular.js`.\n    var large = fields.large = !!(pipelineContext && pipelineContext.large);\n    var progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);\n    return !!(originalLarge !== large || originalProgressive !== progressive) && \'reset\';\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODc1ODIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL2NyZWF0ZVJlbmRlclBsYW5uZXIuanM/M2MzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IG1ha2VJbm5lciB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xuLyoqXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gSWYgbGFyZ2UgbW9kZSBjaGFuZ2VkLCByZXR1cm4gc3RyaW5nICdyZXNldCc7XHJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlUmVuZGVyUGxhbm5lcigpIHtcbiAgdmFyIGlubmVyID0gbWFrZUlubmVyKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgZmllbGRzID0gaW5uZXIoc2VyaWVzTW9kZWwpO1xuICAgIHZhciBwaXBlbGluZUNvbnRleHQgPSBzZXJpZXNNb2RlbC5waXBlbGluZUNvbnRleHQ7XG4gICAgdmFyIG9yaWdpbmFsTGFyZ2UgPSAhIWZpZWxkcy5sYXJnZTtcbiAgICB2YXIgb3JpZ2luYWxQcm9ncmVzc2l2ZSA9ICEhZmllbGRzLnByb2dyZXNzaXZlUmVuZGVyO1xuICAgIC8vIEZJWE1FOiBpZiB0aGUgcGxhbm5lciB3b3JrcyBvbiBhIGZpbHRlcmVkIHNlcmllcywgYHBpcGVsaW5lQ29udGV4dGAgZG9lcyBub3RcbiAgICAvLyBleGlzdHMuIFNlZSAjMTE2MTEgLiBQcm9iYWJseSB3ZSBuZWVkIHRvIG1vZGlmeSB0aGlzIHN0cnVjdHVyZSwgc2VlIHRoZSBjb21tZW50XG4gICAgLy8gb24gYHBlcmZvcm1SYXdTZXJpZXNgIGluIGBTY2hlZHVsYXIuanNgLlxuICAgIHZhciBsYXJnZSA9IGZpZWxkcy5sYXJnZSA9ICEhKHBpcGVsaW5lQ29udGV4dCAmJiBwaXBlbGluZUNvbnRleHQubGFyZ2UpO1xuICAgIHZhciBwcm9ncmVzc2l2ZSA9IGZpZWxkcy5wcm9ncmVzc2l2ZVJlbmRlciA9ICEhKHBpcGVsaW5lQ29udGV4dCAmJiBwaXBlbGluZUNvbnRleHQucHJvZ3Jlc3NpdmVSZW5kZXIpO1xuICAgIHJldHVybiAhIShvcmlnaW5hbExhcmdlICE9PSBsYXJnZSB8fCBvcmlnaW5hbFByb2dyZXNzaXZlICE9PSBwcm9ncmVzc2l2ZSkgJiYgJ3Jlc2V0JztcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///87582\n')},94583:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29308);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(59482);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43870);\n/* harmony import */ var _util_symbol_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(62103);\n/* harmony import */ var _util_innerStore_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(69622);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/* global Float32Array */\n// TODO Batch by color\n\n\n\nvar BOOST_SIZE_THRESHOLD = 4;\nvar LargeSymbolPathShape = /** @class */function () {\n  function LargeSymbolPathShape() {}\n  return LargeSymbolPathShape;\n}();\nvar LargeSymbolPath = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(LargeSymbolPath, _super);\n  function LargeSymbolPath(opts) {\n    var _this = _super.call(this, opts) || this;\n    _this._off = 0;\n    _this.hoverDataIdx = -1;\n    return _this;\n  }\n  LargeSymbolPath.prototype.getDefaultShape = function () {\n    return new LargeSymbolPathShape();\n  };\n  LargeSymbolPath.prototype.reset = function () {\n    this.notClear = false;\n    this._off = 0;\n  };\n  LargeSymbolPath.prototype.buildPath = function (path, shape) {\n    var points = shape.points;\n    var size = shape.size;\n    var symbolProxy = this.symbolProxy;\n    var symbolProxyShape = symbolProxy.shape;\n    var ctx = path.getContext ? path.getContext() : path;\n    var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD;\n    var softClipShape = this.softClipShape;\n    var i;\n    // Do draw in afterBrush.\n    if (canBoost) {\n      this._ctx = ctx;\n      return;\n    }\n    this._ctx = null;\n    for (i = this._off; i < points.length;) {\n      var x = points[i++];\n      var y = points[i++];\n      if (isNaN(x) || isNaN(y)) {\n        continue;\n      }\n      if (softClipShape && !softClipShape.contain(x, y)) {\n        continue;\n      }\n      symbolProxyShape.x = x - size[0] / 2;\n      symbolProxyShape.y = y - size[1] / 2;\n      symbolProxyShape.width = size[0];\n      symbolProxyShape.height = size[1];\n      symbolProxy.buildPath(path, symbolProxyShape, true);\n    }\n    if (this.incremental) {\n      this._off = i;\n      this.notClear = true;\n    }\n  };\n  LargeSymbolPath.prototype.afterBrush = function () {\n    var shape = this.shape;\n    var points = shape.points;\n    var size = shape.size;\n    var ctx = this._ctx;\n    var softClipShape = this.softClipShape;\n    var i;\n    if (!ctx) {\n      return;\n    }\n    // PENDING If style or other canvas status changed?\n    for (i = this._off; i < points.length;) {\n      var x = points[i++];\n      var y = points[i++];\n      if (isNaN(x) || isNaN(y)) {\n        continue;\n      }\n      if (softClipShape && !softClipShape.contain(x, y)) {\n        continue;\n      }\n      // fillRect is faster than building a rect path and draw.\n      // And it support light globalCompositeOperation.\n      ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);\n    }\n    if (this.incremental) {\n      this._off = i;\n      this.notClear = true;\n    }\n  };\n  LargeSymbolPath.prototype.findDataIndex = function (x, y) {\n    // TODO ???\n    // Consider transform\n    var shape = this.shape;\n    var points = shape.points;\n    var size = shape.size;\n    var w = Math.max(size[0], 4);\n    var h = Math.max(size[1], 4);\n    // Not consider transform\n    // Treat each element as a rect\n    // top down traverse\n    for (var idx = points.length / 2 - 1; idx >= 0; idx--) {\n      var i = idx * 2;\n      var x0 = points[i] - w / 2;\n      var y0 = points[i + 1] - h / 2;\n      if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {\n        return idx;\n      }\n    }\n    return -1;\n  };\n  LargeSymbolPath.prototype.contain = function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    x = localPos[0];\n    y = localPos[1];\n    if (rect.contain(x, y)) {\n      // Cache found data index.\n      var dataIdx = this.hoverDataIdx = this.findDataIndex(x, y);\n      return dataIdx >= 0;\n    }\n    this.hoverDataIdx = -1;\n    return false;\n  };\n  LargeSymbolPath.prototype.getBoundingRect = function () {\n    // Ignore stroke for large symbol draw.\n    var rect = this._rect;\n    if (!rect) {\n      var shape = this.shape;\n      var points = shape.points;\n      var size = shape.size;\n      var w = size[0];\n      var h = size[1];\n      var minX = Infinity;\n      var minY = Infinity;\n      var maxX = -Infinity;\n      var maxY = -Infinity;\n      for (var i = 0; i < points.length;) {\n        var x = points[i++];\n        var y = points[i++];\n        minX = Math.min(x, minX);\n        maxX = Math.max(x, maxX);\n        minY = Math.min(y, minY);\n        maxY = Math.max(y, maxY);\n      }\n      rect = this._rect = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A(minX - w / 2, minY - h / 2, maxX - minX + w, maxY - minY + h);\n    }\n    return rect;\n  };\n  return LargeSymbolPath;\n}(_util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .Ay);\nvar LargeSymbolDraw = /** @class */function () {\n  function LargeSymbolDraw() {\n    this.group = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A();\n  }\n  /**\r\n   * Update symbols draw by new data\r\n   */\n  LargeSymbolDraw.prototype.updateData = function (data, opt) {\n    this._clear();\n    var symbolEl = this._create();\n    symbolEl.setShape({\n      points: data.getLayout('points')\n    });\n    this._setCommon(symbolEl, data, opt);\n  };\n  LargeSymbolDraw.prototype.updateLayout = function (data) {\n    var points = data.getLayout('points');\n    this.group.eachChild(function (child) {\n      if (child.startIndex != null) {\n        var len = (child.endIndex - child.startIndex) * 2;\n        var byteOffset = child.startIndex * 4 * 2;\n        points = new Float32Array(points.buffer, byteOffset, len);\n      }\n      child.setShape('points', points);\n      // Reset draw cursor.\n      child.reset();\n    });\n  };\n  LargeSymbolDraw.prototype.incrementalPrepareUpdate = function (data) {\n    this._clear();\n  };\n  LargeSymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {\n    var lastAdded = this._newAdded[0];\n    var points = data.getLayout('points');\n    var oldPoints = lastAdded && lastAdded.shape.points;\n    // Merging the exists. Each element has 1e4 points.\n    // Consider the performance balance between too much elements and too much points in one shape(may affect hover optimization)\n    if (oldPoints && oldPoints.length < 2e4) {\n      var oldLen = oldPoints.length;\n      var newPoints = new Float32Array(oldLen + points.length);\n      // Concat two array\n      newPoints.set(oldPoints);\n      newPoints.set(points, oldLen);\n      // Update endIndex\n      lastAdded.endIndex = taskParams.end;\n      lastAdded.setShape({\n        points: newPoints\n      });\n    } else {\n      // Clear\n      this._newAdded = [];\n      var symbolEl = this._create();\n      symbolEl.startIndex = taskParams.start;\n      symbolEl.endIndex = taskParams.end;\n      symbolEl.incremental = true;\n      symbolEl.setShape({\n        points: points\n      });\n      this._setCommon(symbolEl, data, opt);\n    }\n  };\n  LargeSymbolDraw.prototype.eachRendered = function (cb) {\n    this._newAdded[0] && cb(this._newAdded[0]);\n  };\n  LargeSymbolDraw.prototype._create = function () {\n    var symbolEl = new LargeSymbolPath({\n      cursor: 'default'\n    });\n    symbolEl.ignoreCoarsePointer = true;\n    this.group.add(symbolEl);\n    this._newAdded.push(symbolEl);\n    return symbolEl;\n  };\n  LargeSymbolDraw.prototype._setCommon = function (symbolEl, data, opt) {\n    var hostModel = data.hostModel;\n    opt = opt || {};\n    var size = data.getVisual('symbolSize');\n    symbolEl.setShape('size', size instanceof Array ? size : [size, size]);\n    symbolEl.softClipShape = opt.clipShape || null;\n    // Create symbolProxy to build path for each data\n    symbolEl.symbolProxy = (0,_util_symbol_js__WEBPACK_IMPORTED_MODULE_4__/* .createSymbol */ .v5)(data.getVisual('symbol'), 0, 0, 0, 0);\n    // Use symbolProxy setColor method\n    symbolEl.setColor = symbolEl.symbolProxy.setColor;\n    var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;\n    symbolEl.useStyle(\n    // Draw shadow when doing fillRect is extremely slow.\n    hostModel.getModel('itemStyle').getItemStyle(extrudeShadow ? ['color', 'shadowBlur', 'shadowColor'] : ['color']));\n    var globalStyle = data.getVisual('style');\n    var visualColor = globalStyle && globalStyle.fill;\n    if (visualColor) {\n      symbolEl.setColor(visualColor);\n    }\n    var ecData = (0,_util_innerStore_js__WEBPACK_IMPORTED_MODULE_5__/* .getECData */ .z)(symbolEl);\n    // Enable tooltip\n    // PENDING May have performance issue when path is extremely large\n    ecData.seriesIndex = hostModel.seriesIndex;\n    symbolEl.on('mousemove', function (e) {\n      ecData.dataIndex = null;\n      var dataIndex = symbolEl.hoverDataIdx;\n      if (dataIndex >= 0) {\n        // Provide dataIndex for tooltip\n        ecData.dataIndex = dataIndex + (symbolEl.startIndex || 0);\n      }\n    });\n  };\n  LargeSymbolDraw.prototype.remove = function () {\n    this._clear();\n  };\n  LargeSymbolDraw.prototype._clear = function () {\n    this._newAdded = [];\n    this.group.removeAll();\n  };\n  return LargeSymbolDraw;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LargeSymbolDraw);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ1ODMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9MYXJnZVN5bWJvbERyYXcuanM/OTZkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuLyogZ2xvYmFsIEZsb2F0MzJBcnJheSAqL1xuLy8gVE9ETyBCYXRjaCBieSBjb2xvclxuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3ltYm9sIH0gZnJvbSAnLi4vLi4vdXRpbC9zeW1ib2wuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlLmpzJztcbnZhciBCT09TVF9TSVpFX1RIUkVTSE9MRCA9IDQ7XG52YXIgTGFyZ2VTeW1ib2xQYXRoU2hhcGUgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYXJnZVN5bWJvbFBhdGhTaGFwZSgpIHt9XG4gIHJldHVybiBMYXJnZVN5bWJvbFBhdGhTaGFwZTtcbn0oKTtcbnZhciBMYXJnZVN5bWJvbFBhdGggPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTGFyZ2VTeW1ib2xQYXRoLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBMYXJnZVN5bWJvbFBhdGgob3B0cykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX29mZiA9IDA7XG4gICAgX3RoaXMuaG92ZXJEYXRhSWR4ID0gLTE7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIExhcmdlU3ltYm9sUGF0aC5wcm90b3R5cGUuZ2V0RGVmYXVsdFNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgTGFyZ2VTeW1ib2xQYXRoU2hhcGUoKTtcbiAgfTtcbiAgTGFyZ2VTeW1ib2xQYXRoLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm5vdENsZWFyID0gZmFsc2U7XG4gICAgdGhpcy5fb2ZmID0gMDtcbiAgfTtcbiAgTGFyZ2VTeW1ib2xQYXRoLnByb3RvdHlwZS5idWlsZFBhdGggPSBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcbiAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgIHZhciBzaXplID0gc2hhcGUuc2l6ZTtcbiAgICB2YXIgc3ltYm9sUHJveHkgPSB0aGlzLnN5bWJvbFByb3h5O1xuICAgIHZhciBzeW1ib2xQcm94eVNoYXBlID0gc3ltYm9sUHJveHkuc2hhcGU7XG4gICAgdmFyIGN0eCA9IHBhdGguZ2V0Q29udGV4dCA/IHBhdGguZ2V0Q29udGV4dCgpIDogcGF0aDtcbiAgICB2YXIgY2FuQm9vc3QgPSBjdHggJiYgc2l6ZVswXSA8IEJPT1NUX1NJWkVfVEhSRVNIT0xEO1xuICAgIHZhciBzb2Z0Q2xpcFNoYXBlID0gdGhpcy5zb2Z0Q2xpcFNoYXBlO1xuICAgIHZhciBpO1xuICAgIC8vIERvIGRyYXcgaW4gYWZ0ZXJCcnVzaC5cbiAgICBpZiAoY2FuQm9vc3QpIHtcbiAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3R4ID0gbnVsbDtcbiAgICBmb3IgKGkgPSB0aGlzLl9vZmY7IGkgPCBwb2ludHMubGVuZ3RoOykge1xuICAgICAgdmFyIHggPSBwb2ludHNbaSsrXTtcbiAgICAgIHZhciB5ID0gcG9pbnRzW2krK107XG4gICAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoc29mdENsaXBTaGFwZSAmJiAhc29mdENsaXBTaGFwZS5jb250YWluKHgsIHkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3ltYm9sUHJveHlTaGFwZS54ID0geCAtIHNpemVbMF0gLyAyO1xuICAgICAgc3ltYm9sUHJveHlTaGFwZS55ID0geSAtIHNpemVbMV0gLyAyO1xuICAgICAgc3ltYm9sUHJveHlTaGFwZS53aWR0aCA9IHNpemVbMF07XG4gICAgICBzeW1ib2xQcm94eVNoYXBlLmhlaWdodCA9IHNpemVbMV07XG4gICAgICBzeW1ib2xQcm94eS5idWlsZFBhdGgocGF0aCwgc3ltYm9sUHJveHlTaGFwZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluY3JlbWVudGFsKSB7XG4gICAgICB0aGlzLl9vZmYgPSBpO1xuICAgICAgdGhpcy5ub3RDbGVhciA9IHRydWU7XG4gICAgfVxuICB9O1xuICBMYXJnZVN5bWJvbFBhdGgucHJvdG90eXBlLmFmdGVyQnJ1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgIHZhciBzaXplID0gc2hhcGUuc2l6ZTtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHZhciBzb2Z0Q2xpcFNoYXBlID0gdGhpcy5zb2Z0Q2xpcFNoYXBlO1xuICAgIHZhciBpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFBFTkRJTkcgSWYgc3R5bGUgb3Igb3RoZXIgY2FudmFzIHN0YXR1cyBjaGFuZ2VkP1xuICAgIGZvciAoaSA9IHRoaXMuX29mZjsgaSA8IHBvaW50cy5sZW5ndGg7KSB7XG4gICAgICB2YXIgeCA9IHBvaW50c1tpKytdO1xuICAgICAgdmFyIHkgPSBwb2ludHNbaSsrXTtcbiAgICAgIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzb2Z0Q2xpcFNoYXBlICYmICFzb2Z0Q2xpcFNoYXBlLmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBmaWxsUmVjdCBpcyBmYXN0ZXIgdGhhbiBidWlsZGluZyBhIHJlY3QgcGF0aCBhbmQgZHJhdy5cbiAgICAgIC8vIEFuZCBpdCBzdXBwb3J0IGxpZ2h0IGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbi5cbiAgICAgIGN0eC5maWxsUmVjdCh4IC0gc2l6ZVswXSAvIDIsIHkgLSBzaXplWzFdIC8gMiwgc2l6ZVswXSwgc2l6ZVsxXSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluY3JlbWVudGFsKSB7XG4gICAgICB0aGlzLl9vZmYgPSBpO1xuICAgICAgdGhpcy5ub3RDbGVhciA9IHRydWU7XG4gICAgfVxuICB9O1xuICBMYXJnZVN5bWJvbFBhdGgucHJvdG90eXBlLmZpbmREYXRhSW5kZXggPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIC8vIFRPRE8gPz8/XG4gICAgLy8gQ29uc2lkZXIgdHJhbnNmb3JtXG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgIHZhciBzaXplID0gc2hhcGUuc2l6ZTtcbiAgICB2YXIgdyA9IE1hdGgubWF4KHNpemVbMF0sIDQpO1xuICAgIHZhciBoID0gTWF0aC5tYXgoc2l6ZVsxXSwgNCk7XG4gICAgLy8gTm90IGNvbnNpZGVyIHRyYW5zZm9ybVxuICAgIC8vIFRyZWF0IGVhY2ggZWxlbWVudCBhcyBhIHJlY3RcbiAgICAvLyB0b3AgZG93biB0cmF2ZXJzZVxuICAgIGZvciAodmFyIGlkeCA9IHBvaW50cy5sZW5ndGggLyAyIC0gMTsgaWR4ID49IDA7IGlkeC0tKSB7XG4gICAgICB2YXIgaSA9IGlkeCAqIDI7XG4gICAgICB2YXIgeDAgPSBwb2ludHNbaV0gLSB3IC8gMjtcbiAgICAgIHZhciB5MCA9IHBvaW50c1tpICsgMV0gLSBoIC8gMjtcbiAgICAgIGlmICh4ID49IHgwICYmIHkgPj0geTAgJiYgeCA8PSB4MCArIHcgJiYgeSA8PSB5MCArIGgpIHtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuICBMYXJnZVN5bWJvbFBhdGgucHJvdG90eXBlLmNvbnRhaW4gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciBsb2NhbFBvcyA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB4ID0gbG9jYWxQb3NbMF07XG4gICAgeSA9IGxvY2FsUG9zWzFdO1xuICAgIGlmIChyZWN0LmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgIC8vIENhY2hlIGZvdW5kIGRhdGEgaW5kZXguXG4gICAgICB2YXIgZGF0YUlkeCA9IHRoaXMuaG92ZXJEYXRhSWR4ID0gdGhpcy5maW5kRGF0YUluZGV4KHgsIHkpO1xuICAgICAgcmV0dXJuIGRhdGFJZHggPj0gMDtcbiAgICB9XG4gICAgdGhpcy5ob3ZlckRhdGFJZHggPSAtMTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIExhcmdlU3ltYm9sUGF0aC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIElnbm9yZSBzdHJva2UgZm9yIGxhcmdlIHN5bWJvbCBkcmF3LlxuICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdDtcbiAgICBpZiAoIXJlY3QpIHtcbiAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgICAgdmFyIHNpemUgPSBzaGFwZS5zaXplO1xuICAgICAgdmFyIHcgPSBzaXplWzBdO1xuICAgICAgdmFyIGggPSBzaXplWzFdO1xuICAgICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOykge1xuICAgICAgICB2YXIgeCA9IHBvaW50c1tpKytdO1xuICAgICAgICB2YXIgeSA9IHBvaW50c1tpKytdO1xuICAgICAgICBtaW5YID0gTWF0aC5taW4oeCwgbWluWCk7XG4gICAgICAgIG1heFggPSBNYXRoLm1heCh4LCBtYXhYKTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKHksIG1pblkpO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgoeSwgbWF4WSk7XG4gICAgICB9XG4gICAgICByZWN0ID0gdGhpcy5fcmVjdCA9IG5ldyBncmFwaGljLkJvdW5kaW5nUmVjdChtaW5YIC0gdyAvIDIsIG1pblkgLSBoIC8gMiwgbWF4WCAtIG1pblggKyB3LCBtYXhZIC0gbWluWSArIGgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVjdDtcbiAgfTtcbiAgcmV0dXJuIExhcmdlU3ltYm9sUGF0aDtcbn0oZ3JhcGhpYy5QYXRoKTtcbnZhciBMYXJnZVN5bWJvbERyYXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYXJnZVN5bWJvbERyYXcoKSB7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIHN5bWJvbHMgZHJhdyBieSBuZXcgZGF0YVxyXG4gICAqL1xuICBMYXJnZVN5bWJvbERyYXcucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgb3B0KSB7XG4gICAgdGhpcy5fY2xlYXIoKTtcbiAgICB2YXIgc3ltYm9sRWwgPSB0aGlzLl9jcmVhdGUoKTtcbiAgICBzeW1ib2xFbC5zZXRTaGFwZSh7XG4gICAgICBwb2ludHM6IGRhdGEuZ2V0TGF5b3V0KCdwb2ludHMnKVxuICAgIH0pO1xuICAgIHRoaXMuX3NldENvbW1vbihzeW1ib2xFbCwgZGF0YSwgb3B0KTtcbiAgfTtcbiAgTGFyZ2VTeW1ib2xEcmF3LnByb3RvdHlwZS51cGRhdGVMYXlvdXQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBwb2ludHMgPSBkYXRhLmdldExheW91dCgncG9pbnRzJyk7XG4gICAgdGhpcy5ncm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuc3RhcnRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBsZW4gPSAoY2hpbGQuZW5kSW5kZXggLSBjaGlsZC5zdGFydEluZGV4KSAqIDI7XG4gICAgICAgIHZhciBieXRlT2Zmc2V0ID0gY2hpbGQuc3RhcnRJbmRleCAqIDQgKiAyO1xuICAgICAgICBwb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5idWZmZXIsIGJ5dGVPZmZzZXQsIGxlbik7XG4gICAgICB9XG4gICAgICBjaGlsZC5zZXRTaGFwZSgncG9pbnRzJywgcG9pbnRzKTtcbiAgICAgIC8vIFJlc2V0IGRyYXcgY3Vyc29yLlxuICAgICAgY2hpbGQucmVzZXQoKTtcbiAgICB9KTtcbiAgfTtcbiAgTGFyZ2VTeW1ib2xEcmF3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFByZXBhcmVVcGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuX2NsZWFyKCk7XG4gIH07XG4gIExhcmdlU3ltYm9sRHJhdy5wcm90b3R5cGUuaW5jcmVtZW50YWxVcGRhdGUgPSBmdW5jdGlvbiAodGFza1BhcmFtcywgZGF0YSwgb3B0KSB7XG4gICAgdmFyIGxhc3RBZGRlZCA9IHRoaXMuX25ld0FkZGVkWzBdO1xuICAgIHZhciBwb2ludHMgPSBkYXRhLmdldExheW91dCgncG9pbnRzJyk7XG4gICAgdmFyIG9sZFBvaW50cyA9IGxhc3RBZGRlZCAmJiBsYXN0QWRkZWQuc2hhcGUucG9pbnRzO1xuICAgIC8vIE1lcmdpbmcgdGhlIGV4aXN0cy4gRWFjaCBlbGVtZW50IGhhcyAxZTQgcG9pbnRzLlxuICAgIC8vIENvbnNpZGVyIHRoZSBwZXJmb3JtYW5jZSBiYWxhbmNlIGJldHdlZW4gdG9vIG11Y2ggZWxlbWVudHMgYW5kIHRvbyBtdWNoIHBvaW50cyBpbiBvbmUgc2hhcGUobWF5IGFmZmVjdCBob3ZlciBvcHRpbWl6YXRpb24pXG4gICAgaWYgKG9sZFBvaW50cyAmJiBvbGRQb2ludHMubGVuZ3RoIDwgMmU0KSB7XG4gICAgICB2YXIgb2xkTGVuID0gb2xkUG9pbnRzLmxlbmd0aDtcbiAgICAgIHZhciBuZXdQb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KG9sZExlbiArIHBvaW50cy5sZW5ndGgpO1xuICAgICAgLy8gQ29uY2F0IHR3byBhcnJheVxuICAgICAgbmV3UG9pbnRzLnNldChvbGRQb2ludHMpO1xuICAgICAgbmV3UG9pbnRzLnNldChwb2ludHMsIG9sZExlbik7XG4gICAgICAvLyBVcGRhdGUgZW5kSW5kZXhcbiAgICAgIGxhc3RBZGRlZC5lbmRJbmRleCA9IHRhc2tQYXJhbXMuZW5kO1xuICAgICAgbGFzdEFkZGVkLnNldFNoYXBlKHtcbiAgICAgICAgcG9pbnRzOiBuZXdQb2ludHNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDbGVhclxuICAgICAgdGhpcy5fbmV3QWRkZWQgPSBbXTtcbiAgICAgIHZhciBzeW1ib2xFbCA9IHRoaXMuX2NyZWF0ZSgpO1xuICAgICAgc3ltYm9sRWwuc3RhcnRJbmRleCA9IHRhc2tQYXJhbXMuc3RhcnQ7XG4gICAgICBzeW1ib2xFbC5lbmRJbmRleCA9IHRhc2tQYXJhbXMuZW5kO1xuICAgICAgc3ltYm9sRWwuaW5jcmVtZW50YWwgPSB0cnVlO1xuICAgICAgc3ltYm9sRWwuc2V0U2hhcGUoe1xuICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRDb21tb24oc3ltYm9sRWwsIGRhdGEsIG9wdCk7XG4gICAgfVxuICB9O1xuICBMYXJnZVN5bWJvbERyYXcucHJvdG90eXBlLmVhY2hSZW5kZXJlZCA9IGZ1bmN0aW9uIChjYikge1xuICAgIHRoaXMuX25ld0FkZGVkWzBdICYmIGNiKHRoaXMuX25ld0FkZGVkWzBdKTtcbiAgfTtcbiAgTGFyZ2VTeW1ib2xEcmF3LnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzeW1ib2xFbCA9IG5ldyBMYXJnZVN5bWJvbFBhdGgoe1xuICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcbiAgICB9KTtcbiAgICBzeW1ib2xFbC5pZ25vcmVDb2Fyc2VQb2ludGVyID0gdHJ1ZTtcbiAgICB0aGlzLmdyb3VwLmFkZChzeW1ib2xFbCk7XG4gICAgdGhpcy5fbmV3QWRkZWQucHVzaChzeW1ib2xFbCk7XG4gICAgcmV0dXJuIHN5bWJvbEVsO1xuICB9O1xuICBMYXJnZVN5bWJvbERyYXcucHJvdG90eXBlLl9zZXRDb21tb24gPSBmdW5jdGlvbiAoc3ltYm9sRWwsIGRhdGEsIG9wdCkge1xuICAgIHZhciBob3N0TW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgdmFyIHNpemUgPSBkYXRhLmdldFZpc3VhbCgnc3ltYm9sU2l6ZScpO1xuICAgIHN5bWJvbEVsLnNldFNoYXBlKCdzaXplJywgc2l6ZSBpbnN0YW5jZW9mIEFycmF5ID8gc2l6ZSA6IFtzaXplLCBzaXplXSk7XG4gICAgc3ltYm9sRWwuc29mdENsaXBTaGFwZSA9IG9wdC5jbGlwU2hhcGUgfHwgbnVsbDtcbiAgICAvLyBDcmVhdGUgc3ltYm9sUHJveHkgdG8gYnVpbGQgcGF0aCBmb3IgZWFjaCBkYXRhXG4gICAgc3ltYm9sRWwuc3ltYm9sUHJveHkgPSBjcmVhdGVTeW1ib2woZGF0YS5nZXRWaXN1YWwoJ3N5bWJvbCcpLCAwLCAwLCAwLCAwKTtcbiAgICAvLyBVc2Ugc3ltYm9sUHJveHkgc2V0Q29sb3IgbWV0aG9kXG4gICAgc3ltYm9sRWwuc2V0Q29sb3IgPSBzeW1ib2xFbC5zeW1ib2xQcm94eS5zZXRDb2xvcjtcbiAgICB2YXIgZXh0cnVkZVNoYWRvdyA9IHN5bWJvbEVsLnNoYXBlLnNpemVbMF0gPCBCT09TVF9TSVpFX1RIUkVTSE9MRDtcbiAgICBzeW1ib2xFbC51c2VTdHlsZShcbiAgICAvLyBEcmF3IHNoYWRvdyB3aGVuIGRvaW5nIGZpbGxSZWN0IGlzIGV4dHJlbWVseSBzbG93LlxuICAgIGhvc3RNb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJykuZ2V0SXRlbVN0eWxlKGV4dHJ1ZGVTaGFkb3cgPyBbJ2NvbG9yJywgJ3NoYWRvd0JsdXInLCAnc2hhZG93Q29sb3InXSA6IFsnY29sb3InXSkpO1xuICAgIHZhciBnbG9iYWxTdHlsZSA9IGRhdGEuZ2V0VmlzdWFsKCdzdHlsZScpO1xuICAgIHZhciB2aXN1YWxDb2xvciA9IGdsb2JhbFN0eWxlICYmIGdsb2JhbFN0eWxlLmZpbGw7XG4gICAgaWYgKHZpc3VhbENvbG9yKSB7XG4gICAgICBzeW1ib2xFbC5zZXRDb2xvcih2aXN1YWxDb2xvcik7XG4gICAgfVxuICAgIHZhciBlY0RhdGEgPSBnZXRFQ0RhdGEoc3ltYm9sRWwpO1xuICAgIC8vIEVuYWJsZSB0b29sdGlwXG4gICAgLy8gUEVORElORyBNYXkgaGF2ZSBwZXJmb3JtYW5jZSBpc3N1ZSB3aGVuIHBhdGggaXMgZXh0cmVtZWx5IGxhcmdlXG4gICAgZWNEYXRhLnNlcmllc0luZGV4ID0gaG9zdE1vZGVsLnNlcmllc0luZGV4O1xuICAgIHN5bWJvbEVsLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZWNEYXRhLmRhdGFJbmRleCA9IG51bGw7XG4gICAgICB2YXIgZGF0YUluZGV4ID0gc3ltYm9sRWwuaG92ZXJEYXRhSWR4O1xuICAgICAgaWYgKGRhdGFJbmRleCA+PSAwKSB7XG4gICAgICAgIC8vIFByb3ZpZGUgZGF0YUluZGV4IGZvciB0b29sdGlwXG4gICAgICAgIGVjRGF0YS5kYXRhSW5kZXggPSBkYXRhSW5kZXggKyAoc3ltYm9sRWwuc3RhcnRJbmRleCB8fCAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgTGFyZ2VTeW1ib2xEcmF3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xlYXIoKTtcbiAgfTtcbiAgTGFyZ2VTeW1ib2xEcmF3LnByb3RvdHlwZS5fY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbmV3QWRkZWQgPSBbXTtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICB9O1xuICByZXR1cm4gTGFyZ2VTeW1ib2xEcmF3O1xufSgpO1xuZXhwb3J0IGRlZmF1bHQgTGFyZ2VTeW1ib2xEcmF3OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///94583\n")},95235:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ip: () => (/* binding */ createClipPath),\n/* harmony export */   Mi: () => (/* binding */ createPolarClipPath),\n/* harmony export */   SM: () => (/* binding */ createGridClipPath)\n/* harmony export */ });\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30010);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5638);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25014);\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24326);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {\n  var rect = cartesian.getArea();\n  var x = rect.x;\n  var y = rect.y;\n  var width = rect.width;\n  var height = rect.height;\n  var lineWidth = seriesModel.get([\'lineStyle\', \'width\']) || 0;\n  // Expand the clip path a bit to avoid the border is clipped and looks thinner\n  x -= lineWidth / 2;\n  y -= lineWidth / 2;\n  width += lineWidth;\n  height += lineWidth;\n  // fix: https://github.com/apache/incubator-echarts/issues/11369\n  width = Math.ceil(width);\n  if (x !== Math.floor(x)) {\n    x = Math.floor(x);\n    // if no extra 1px on `width`, it will still be clipped since `x` is floored\n    width++;\n  }\n  var clipPath = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n  if (hasAnimation) {\n    var baseAxis = cartesian.getBaseAxis();\n    var isHorizontal = baseAxis.isHorizontal();\n    var isAxisInversed = baseAxis.inverse;\n    if (isHorizontal) {\n      if (isAxisInversed) {\n        clipPath.shape.x += width;\n      }\n      clipPath.shape.width = 0;\n    } else {\n      if (!isAxisInversed) {\n        clipPath.shape.y += height;\n      }\n      clipPath.shape.height = 0;\n    }\n    var duringCb = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(during) ? function (percent) {\n      during(percent, clipPath);\n    } : null;\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* .initProps */ .LW(clipPath, {\n      shape: {\n        width: width,\n        height: height,\n        x: x,\n        y: y\n      }\n    }, seriesModel, null, done, duringCb);\n  }\n  return clipPath;\n}\nfunction createPolarClipPath(polar, hasAnimation, seriesModel) {\n  var sectorArea = polar.getArea();\n  // Avoid float number rounding error for symbol on the edge of axis extent.\n  var r0 = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_3__/* .round */ .LI)(sectorArea.r0, 1);\n  var r = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_3__/* .round */ .LI)(sectorArea.r, 1);\n  var clipPath = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A({\n    shape: {\n      cx: (0,_util_number_js__WEBPACK_IMPORTED_MODULE_3__/* .round */ .LI)(polar.cx, 1),\n      cy: (0,_util_number_js__WEBPACK_IMPORTED_MODULE_3__/* .round */ .LI)(polar.cy, 1),\n      r0: r0,\n      r: r,\n      startAngle: sectorArea.startAngle,\n      endAngle: sectorArea.endAngle,\n      clockwise: sectorArea.clockwise\n    }\n  });\n  if (hasAnimation) {\n    var isRadial = polar.getBaseAxis().dim === \'angle\';\n    if (isRadial) {\n      clipPath.shape.endAngle = sectorArea.startAngle;\n    } else {\n      clipPath.shape.r = r0;\n    }\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* .initProps */ .LW(clipPath, {\n      shape: {\n        endAngle: sectorArea.endAngle,\n        r: r\n      }\n    }, seriesModel);\n  }\n  return clipPath;\n}\nfunction createClipPath(coordSys, hasAnimation, seriesModel, done, during) {\n  if (!coordSys) {\n    return null;\n  } else if (coordSys.type === \'polar\') {\n    return createPolarClipPath(coordSys, hasAnimation, seriesModel);\n  } else if (coordSys.type === \'cartesian2d\') {\n    return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);\n  }\n  return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUyMzUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvY3JlYXRlQ2xpcFBhdGhGcm9tQ29vcmRTeXMuanM/ZDM0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5mdW5jdGlvbiBjcmVhdGVHcmlkQ2xpcFBhdGgoY2FydGVzaWFuLCBoYXNBbmltYXRpb24sIHNlcmllc01vZGVsLCBkb25lLCBkdXJpbmcpIHtcbiAgdmFyIHJlY3QgPSBjYXJ0ZXNpYW4uZ2V0QXJlYSgpO1xuICB2YXIgeCA9IHJlY3QueDtcbiAgdmFyIHkgPSByZWN0Lnk7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgdmFyIGxpbmVXaWR0aCA9IHNlcmllc01vZGVsLmdldChbJ2xpbmVTdHlsZScsICd3aWR0aCddKSB8fCAwO1xuICAvLyBFeHBhbmQgdGhlIGNsaXAgcGF0aCBhIGJpdCB0byBhdm9pZCB0aGUgYm9yZGVyIGlzIGNsaXBwZWQgYW5kIGxvb2tzIHRoaW5uZXJcbiAgeCAtPSBsaW5lV2lkdGggLyAyO1xuICB5IC09IGxpbmVXaWR0aCAvIDI7XG4gIHdpZHRoICs9IGxpbmVXaWR0aDtcbiAgaGVpZ2h0ICs9IGxpbmVXaWR0aDtcbiAgLy8gZml4OiBodHRwczovL2dpdGh1Yi5jb20vYXBhY2hlL2luY3ViYXRvci1lY2hhcnRzL2lzc3Vlcy8xMTM2OVxuICB3aWR0aCA9IE1hdGguY2VpbCh3aWR0aCk7XG4gIGlmICh4ICE9PSBNYXRoLmZsb29yKHgpKSB7XG4gICAgeCA9IE1hdGguZmxvb3IoeCk7XG4gICAgLy8gaWYgbm8gZXh0cmEgMXB4IG9uIGB3aWR0aGAsIGl0IHdpbGwgc3RpbGwgYmUgY2xpcHBlZCBzaW5jZSBgeGAgaXMgZmxvb3JlZFxuICAgIHdpZHRoKys7XG4gIH1cbiAgdmFyIGNsaXBQYXRoID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgc2hhcGU6IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9XG4gIH0pO1xuICBpZiAoaGFzQW5pbWF0aW9uKSB7XG4gICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgdmFyIGlzSG9yaXpvbnRhbCA9IGJhc2VBeGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIHZhciBpc0F4aXNJbnZlcnNlZCA9IGJhc2VBeGlzLmludmVyc2U7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgaWYgKGlzQXhpc0ludmVyc2VkKSB7XG4gICAgICAgIGNsaXBQYXRoLnNoYXBlLnggKz0gd2lkdGg7XG4gICAgICB9XG4gICAgICBjbGlwUGF0aC5zaGFwZS53aWR0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaXNBeGlzSW52ZXJzZWQpIHtcbiAgICAgICAgY2xpcFBhdGguc2hhcGUueSArPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgICBjbGlwUGF0aC5zaGFwZS5oZWlnaHQgPSAwO1xuICAgIH1cbiAgICB2YXIgZHVyaW5nQ2IgPSBpc0Z1bmN0aW9uKGR1cmluZykgPyBmdW5jdGlvbiAocGVyY2VudCkge1xuICAgICAgZHVyaW5nKHBlcmNlbnQsIGNsaXBQYXRoKTtcbiAgICB9IDogbnVsbDtcbiAgICBncmFwaGljLmluaXRQcm9wcyhjbGlwUGF0aCwge1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfVxuICAgIH0sIHNlcmllc01vZGVsLCBudWxsLCBkb25lLCBkdXJpbmdDYik7XG4gIH1cbiAgcmV0dXJuIGNsaXBQYXRoO1xufVxuZnVuY3Rpb24gY3JlYXRlUG9sYXJDbGlwUGF0aChwb2xhciwgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCkge1xuICB2YXIgc2VjdG9yQXJlYSA9IHBvbGFyLmdldEFyZWEoKTtcbiAgLy8gQXZvaWQgZmxvYXQgbnVtYmVyIHJvdW5kaW5nIGVycm9yIGZvciBzeW1ib2wgb24gdGhlIGVkZ2Ugb2YgYXhpcyBleHRlbnQuXG4gIHZhciByMCA9IHJvdW5kKHNlY3RvckFyZWEucjAsIDEpO1xuICB2YXIgciA9IHJvdW5kKHNlY3RvckFyZWEuciwgMSk7XG4gIHZhciBjbGlwUGF0aCA9IG5ldyBncmFwaGljLlNlY3Rvcih7XG4gICAgc2hhcGU6IHtcbiAgICAgIGN4OiByb3VuZChwb2xhci5jeCwgMSksXG4gICAgICBjeTogcm91bmQocG9sYXIuY3ksIDEpLFxuICAgICAgcjA6IHIwLFxuICAgICAgcjogcixcbiAgICAgIHN0YXJ0QW5nbGU6IHNlY3RvckFyZWEuc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlOiBzZWN0b3JBcmVhLmVuZEFuZ2xlLFxuICAgICAgY2xvY2t3aXNlOiBzZWN0b3JBcmVhLmNsb2Nrd2lzZVxuICAgIH1cbiAgfSk7XG4gIGlmIChoYXNBbmltYXRpb24pIHtcbiAgICB2YXIgaXNSYWRpYWwgPSBwb2xhci5nZXRCYXNlQXhpcygpLmRpbSA9PT0gJ2FuZ2xlJztcbiAgICBpZiAoaXNSYWRpYWwpIHtcbiAgICAgIGNsaXBQYXRoLnNoYXBlLmVuZEFuZ2xlID0gc2VjdG9yQXJlYS5zdGFydEFuZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGlwUGF0aC5zaGFwZS5yID0gcjA7XG4gICAgfVxuICAgIGdyYXBoaWMuaW5pdFByb3BzKGNsaXBQYXRoLCB7XG4gICAgICBzaGFwZToge1xuICAgICAgICBlbmRBbmdsZTogc2VjdG9yQXJlYS5lbmRBbmdsZSxcbiAgICAgICAgcjogclxuICAgICAgfVxuICAgIH0sIHNlcmllc01vZGVsKTtcbiAgfVxuICByZXR1cm4gY2xpcFBhdGg7XG59XG5mdW5jdGlvbiBjcmVhdGVDbGlwUGF0aChjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCwgZG9uZSwgZHVyaW5nKSB7XG4gIGlmICghY29vcmRTeXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChjb29yZFN5cy50eXBlID09PSAncG9sYXInKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBvbGFyQ2xpcFBhdGgoY29vcmRTeXMsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpO1xuICB9IGVsc2UgaWYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICByZXR1cm4gY3JlYXRlR3JpZENsaXBQYXRoKGNvb3JkU3lzLCBoYXNBbmltYXRpb24sIHNlcmllc01vZGVsLCBkb25lLCBkdXJpbmcpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZXhwb3J0IHsgY3JlYXRlR3JpZENsaXBQYXRoLCBjcmVhdGVQb2xhckNsaXBQYXRoLCBjcmVhdGVDbGlwUGF0aCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///95235\n')}}]);