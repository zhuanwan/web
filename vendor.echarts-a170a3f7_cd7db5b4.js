"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[4536],{49714:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Image.js\nvar Image = __webpack_require__(90540);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/platform.js\nvar platform = __webpack_require__(59741);\n;// ./node_modules/echarts/lib/chart/heatmap/HeatmapLayer.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/* global Uint8ClampedArray */\n\nvar GRADIENT_LEVELS = 256;\nvar HeatmapLayer = /** @class */function () {\n  function HeatmapLayer() {\n    this.blurSize = 30;\n    this.pointSize = 20;\n    this.maxOpacity = 1;\n    this.minOpacity = 0;\n    this._gradientPixels = {\n      inRange: null,\n      outOfRange: null\n    };\n    var canvas = platform/* platformApi */.yh.createCanvas();\n    this.canvas = canvas;\n  }\n  /**\r\n   * Renders Heatmap and returns the rendered canvas\r\n   * @param data array of data, each has x, y, value\r\n   * @param width canvas width\r\n   * @param height canvas height\r\n   */\n  HeatmapLayer.prototype.update = function (data, width, height, normalize, colorFunc, isInRange) {\n    var brush = this._getBrush();\n    var gradientInRange = this._getGradient(colorFunc, 'inRange');\n    var gradientOutOfRange = this._getGradient(colorFunc, 'outOfRange');\n    var r = this.pointSize + this.blurSize;\n    var canvas = this.canvas;\n    var ctx = canvas.getContext('2d');\n    var len = data.length;\n    canvas.width = width;\n    canvas.height = height;\n    for (var i = 0; i < len; ++i) {\n      var p = data[i];\n      var x = p[0];\n      var y = p[1];\n      var value = p[2];\n      // calculate alpha using value\n      var alpha = normalize(value);\n      // draw with the circle brush with alpha\n      ctx.globalAlpha = alpha;\n      ctx.drawImage(brush, x - r, y - r);\n    }\n    if (!canvas.width || !canvas.height) {\n      // Avoid \"Uncaught DOMException: Failed to execute 'getImageData' on\n      // 'CanvasRenderingContext2D': The source height is 0.\"\n      return canvas;\n    }\n    // colorize the canvas using alpha value and set with gradient\n    var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    var pixels = imageData.data;\n    var offset = 0;\n    var pixelLen = pixels.length;\n    var minOpacity = this.minOpacity;\n    var maxOpacity = this.maxOpacity;\n    var diffOpacity = maxOpacity - minOpacity;\n    while (offset < pixelLen) {\n      var alpha = pixels[offset + 3] / 256;\n      var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4;\n      // Simple optimize to ignore the empty data\n      if (alpha > 0) {\n        var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange;\n        // Any alpha > 0 will be mapped to [minOpacity, maxOpacity]\n        alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);\n        pixels[offset++] = gradient[gradientOffset];\n        pixels[offset++] = gradient[gradientOffset + 1];\n        pixels[offset++] = gradient[gradientOffset + 2];\n        pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;\n      } else {\n        offset += 4;\n      }\n    }\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  };\n  /**\r\n   * get canvas of a black circle brush used for canvas to draw later\r\n   */\n  HeatmapLayer.prototype._getBrush = function () {\n    var brushCanvas = this._brushCanvas || (this._brushCanvas = platform/* platformApi */.yh.createCanvas());\n    // set brush size\n    var r = this.pointSize + this.blurSize;\n    var d = r * 2;\n    brushCanvas.width = d;\n    brushCanvas.height = d;\n    var ctx = brushCanvas.getContext('2d');\n    ctx.clearRect(0, 0, d, d);\n    // in order to render shadow without the distinct circle,\n    // draw the distinct circle in an invisible place,\n    // and use shadowOffset to draw shadow in the center of the canvas\n    ctx.shadowOffsetX = d;\n    ctx.shadowBlur = this.blurSize;\n    // draw the shadow in black, and use alpha and shadow blur to generate\n    // color in color map\n    ctx.shadowColor = '#000';\n    // draw circle in the left to the canvas\n    ctx.beginPath();\n    ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fill();\n    return brushCanvas;\n  };\n  /**\r\n   * get gradient color map\r\n   * @private\r\n   */\n  HeatmapLayer.prototype._getGradient = function (colorFunc, state) {\n    var gradientPixels = this._gradientPixels;\n    var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));\n    var color = [0, 0, 0, 0];\n    var off = 0;\n    for (var i = 0; i < 256; i++) {\n      colorFunc[state](i / 255, true, color);\n      pixelsSingleState[off++] = color[0];\n      pixelsSingleState[off++] = color[1];\n      pixelsSingleState[off++] = color[2];\n      pixelsSingleState[off++] = color[3];\n    }\n    return pixelsSingleState;\n  };\n  return HeatmapLayer;\n}();\n/* harmony default export */ const heatmap_HeatmapLayer = (HeatmapLayer);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/CoordinateSystem.js\nvar CoordinateSystem = __webpack_require__(41849);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n;// ./node_modules/echarts/lib/chart/heatmap/HeatmapView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nfunction getIsInPiecewiseRange(dataExtent, pieceList, selected) {\n  var dataSpan = dataExtent[1] - dataExtent[0];\n  pieceList = util.map(pieceList, function (piece) {\n    return {\n      interval: [(piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan]\n    };\n  });\n  var len = pieceList.length;\n  var lastIndex = 0;\n  return function (val) {\n    var i;\n    // Try to find in the location of the last found\n    for (i = lastIndex; i < len; i++) {\n      var interval = pieceList[i].interval;\n      if (interval[0] <= val && val <= interval[1]) {\n        lastIndex = i;\n        break;\n      }\n    }\n    if (i === len) {\n      // Not found, back interation\n      for (i = lastIndex - 1; i >= 0; i--) {\n        var interval = pieceList[i].interval;\n        if (interval[0] <= val && val <= interval[1]) {\n          lastIndex = i;\n          break;\n        }\n      }\n    }\n    return i >= 0 && i < len && selected[i];\n  };\n}\nfunction getIsInContinuousRange(dataExtent, range) {\n  var dataSpan = dataExtent[1] - dataExtent[0];\n  range = [(range[0] - dataExtent[0]) / dataSpan, (range[1] - dataExtent[0]) / dataSpan];\n  return function (val) {\n    return val >= range[0] && val <= range[1];\n  };\n}\nfunction isGeoCoordSys(coordSys) {\n  var dimensions = coordSys.dimensions;\n  // Not use coordSys.type === 'geo' because coordSys maybe extended\n  return dimensions[0] === 'lng' && dimensions[1] === 'lat';\n}\nvar HeatmapView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(HeatmapView, _super);\n  function HeatmapView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = HeatmapView.type;\n    return _this;\n  }\n  HeatmapView.prototype.render = function (seriesModel, ecModel, api) {\n    var visualMapOfThisSeries;\n    ecModel.eachComponent('visualMap', function (visualMap) {\n      visualMap.eachTargetSeries(function (targetSeries) {\n        if (targetSeries === seriesModel) {\n          visualMapOfThisSeries = visualMap;\n        }\n      });\n    });\n    if (false) {}\n    // Clear previously rendered progressive elements.\n    this._progressiveEls = null;\n    this.group.removeAll();\n    var coordSys = seriesModel.coordinateSystem;\n    if (coordSys.type === 'cartesian2d' || coordSys.type === 'calendar') {\n      this._renderOnCartesianAndCalendar(seriesModel, api, 0, seriesModel.getData().count());\n    } else if (isGeoCoordSys(coordSys)) {\n      this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api);\n    }\n  };\n  HeatmapView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {\n    this.group.removeAll();\n  };\n  HeatmapView.prototype.incrementalRender = function (params, seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    if (coordSys) {\n      // geo does not support incremental rendering?\n      if (isGeoCoordSys(coordSys)) {\n        this.render(seriesModel, ecModel, api);\n      } else {\n        this._progressiveEls = [];\n        this._renderOnCartesianAndCalendar(seriesModel, api, params.start, params.end, true);\n      }\n    }\n  };\n  HeatmapView.prototype.eachRendered = function (cb) {\n    graphic.traverseElements(this._progressiveEls || this.group, cb);\n  };\n  HeatmapView.prototype._renderOnCartesianAndCalendar = function (seriesModel, api, start, end, incremental) {\n    var coordSys = seriesModel.coordinateSystem;\n    var isCartesian2d = (0,CoordinateSystem/* isCoordinateSystemType */.g)(coordSys, 'cartesian2d');\n    var width;\n    var height;\n    var xAxisExtent;\n    var yAxisExtent;\n    if (isCartesian2d) {\n      var xAxis = coordSys.getAxis('x');\n      var yAxis = coordSys.getAxis('y');\n      if (false) {}\n      // add 0.5px to avoid the gaps\n      width = xAxis.getBandWidth() + .5;\n      height = yAxis.getBandWidth() + .5;\n      xAxisExtent = xAxis.scale.getExtent();\n      yAxisExtent = yAxis.scale.getExtent();\n    }\n    var group = this.group;\n    var data = seriesModel.getData();\n    var emphasisStyle = seriesModel.getModel(['emphasis', 'itemStyle']).getItemStyle();\n    var blurStyle = seriesModel.getModel(['blur', 'itemStyle']).getItemStyle();\n    var selectStyle = seriesModel.getModel(['select', 'itemStyle']).getItemStyle();\n    var borderRadius = seriesModel.get(['itemStyle', 'borderRadius']);\n    var labelStatesModels = (0,labelStyle/* getLabelStatesModels */.lx)(seriesModel);\n    var emphasisModel = seriesModel.getModel('emphasis');\n    var focus = emphasisModel.get('focus');\n    var blurScope = emphasisModel.get('blurScope');\n    var emphasisDisabled = emphasisModel.get('disabled');\n    var dataDims = isCartesian2d ? [data.mapDimension('x'), data.mapDimension('y'), data.mapDimension('value')] : [data.mapDimension('time'), data.mapDimension('value')];\n    for (var idx = start; idx < end; idx++) {\n      var rect = void 0;\n      var style = data.getItemVisual(idx, 'style');\n      if (isCartesian2d) {\n        var dataDimX = data.get(dataDims[0], idx);\n        var dataDimY = data.get(dataDims[1], idx);\n        // Ignore empty data and out of extent data\n        if (isNaN(data.get(dataDims[2], idx)) || isNaN(dataDimX) || isNaN(dataDimY) || dataDimX < xAxisExtent[0] || dataDimX > xAxisExtent[1] || dataDimY < yAxisExtent[0] || dataDimY > yAxisExtent[1]) {\n          continue;\n        }\n        var point = coordSys.dataToPoint([dataDimX, dataDimY]);\n        rect = new Rect/* default */.A({\n          shape: {\n            x: point[0] - width / 2,\n            y: point[1] - height / 2,\n            width: width,\n            height: height\n          },\n          style: style\n        });\n      } else {\n        // Ignore empty data\n        if (isNaN(data.get(dataDims[1], idx))) {\n          continue;\n        }\n        rect = new Rect/* default */.A({\n          z2: 1,\n          shape: coordSys.dataToRect([data.get(dataDims[0], idx)]).contentShape,\n          style: style\n        });\n      }\n      // Optimization for large dataset\n      if (data.hasItemOption) {\n        var itemModel = data.getItemModel(idx);\n        var emphasisModel_1 = itemModel.getModel('emphasis');\n        emphasisStyle = emphasisModel_1.getModel('itemStyle').getItemStyle();\n        blurStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();\n        selectStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle();\n        // Each item value struct in the data would be firstly\n        // {\n        //     itemStyle: { borderRadius: [30, 30] },\n        //     value: [2022, 02, 22]\n        // }\n        borderRadius = itemModel.get(['itemStyle', 'borderRadius']);\n        focus = emphasisModel_1.get('focus');\n        blurScope = emphasisModel_1.get('blurScope');\n        emphasisDisabled = emphasisModel_1.get('disabled');\n        labelStatesModels = (0,labelStyle/* getLabelStatesModels */.lx)(itemModel);\n      }\n      rect.shape.r = borderRadius;\n      var rawValue = seriesModel.getRawValue(idx);\n      var defaultText = '-';\n      if (rawValue && rawValue[2] != null) {\n        defaultText = rawValue[2] + '';\n      }\n      (0,labelStyle/* setLabelStyle */.qM)(rect, labelStatesModels, {\n        labelFetcher: seriesModel,\n        labelDataIndex: idx,\n        defaultOpacity: style.opacity,\n        defaultText: defaultText\n      });\n      rect.ensureState('emphasis').style = emphasisStyle;\n      rect.ensureState('blur').style = blurStyle;\n      rect.ensureState('select').style = selectStyle;\n      (0,states/* toggleHoverEmphasis */.Lm)(rect, focus, blurScope, emphasisDisabled);\n      rect.incremental = incremental;\n      // PENDING\n      if (incremental) {\n        // Rect must use hover layer if it's incremental.\n        rect.states.emphasis.hoverLayer = true;\n      }\n      group.add(rect);\n      data.setItemGraphicEl(idx, rect);\n      if (this._progressiveEls) {\n        this._progressiveEls.push(rect);\n      }\n    }\n  };\n  HeatmapView.prototype._renderOnGeo = function (geo, seriesModel, visualMapModel, api) {\n    var inRangeVisuals = visualMapModel.targetVisuals.inRange;\n    var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange;\n    // if (!visualMapping) {\n    //     throw new Error('Data range must have color visuals');\n    // }\n    var data = seriesModel.getData();\n    var hmLayer = this._hmLayer || this._hmLayer || new heatmap_HeatmapLayer();\n    hmLayer.blurSize = seriesModel.get('blurSize');\n    hmLayer.pointSize = seriesModel.get('pointSize');\n    hmLayer.minOpacity = seriesModel.get('minOpacity');\n    hmLayer.maxOpacity = seriesModel.get('maxOpacity');\n    var rect = geo.getViewRect().clone();\n    var roamTransform = geo.getRoamTransform();\n    rect.applyTransform(roamTransform);\n    // Clamp on viewport\n    var x = Math.max(rect.x, 0);\n    var y = Math.max(rect.y, 0);\n    var x2 = Math.min(rect.width + rect.x, api.getWidth());\n    var y2 = Math.min(rect.height + rect.y, api.getHeight());\n    var width = x2 - x;\n    var height = y2 - y;\n    var dims = [data.mapDimension('lng'), data.mapDimension('lat'), data.mapDimension('value')];\n    var points = data.mapArray(dims, function (lng, lat, value) {\n      var pt = geo.dataToPoint([lng, lat]);\n      pt[0] -= x;\n      pt[1] -= y;\n      pt.push(value);\n      return pt;\n    });\n    var dataExtent = visualMapModel.getExtent();\n    var isInRange = visualMapModel.type === 'visualMap.continuous' ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);\n    hmLayer.update(points, width, height, inRangeVisuals.color.getNormalizer(), {\n      inRange: inRangeVisuals.color.getColorMapper(),\n      outOfRange: outOfRangeVisuals.color.getColorMapper()\n    }, isInRange);\n    var img = new Image/* default */.Ay({\n      style: {\n        width: width,\n        height: height,\n        x: x,\n        y: y,\n        image: hmLayer.canvas\n      },\n      silent: true\n    });\n    this.group.add(img);\n  };\n  HeatmapView.type = 'heatmap';\n  return HeatmapView;\n}(Chart/* default */.A);\n/* harmony default export */ const heatmap_HeatmapView = (HeatmapView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createSeriesData.js\nvar createSeriesData = __webpack_require__(13637);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/core/CoordinateSystem.js\nvar core_CoordinateSystem = __webpack_require__(89737);\n;// ./node_modules/echarts/lib/chart/heatmap/HeatmapSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar HeatmapSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(HeatmapSeriesModel, _super);\n  function HeatmapSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = HeatmapSeriesModel.type;\n    return _this;\n  }\n  HeatmapSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    return (0,createSeriesData/* default */.A)(null, this, {\n      generateCoord: 'value'\n    });\n  };\n  HeatmapSeriesModel.prototype.preventIncremental = function () {\n    var coordSysCreator = core_CoordinateSystem/* default */.A.get(this.get('coordinateSystem'));\n    if (coordSysCreator && coordSysCreator.dimensions) {\n      return coordSysCreator.dimensions[0] === 'lng' && coordSysCreator.dimensions[1] === 'lat';\n    }\n  };\n  HeatmapSeriesModel.type = 'series.heatmap';\n  HeatmapSeriesModel.dependencies = ['grid', 'geo', 'calendar'];\n  HeatmapSeriesModel.defaultOption = {\n    coordinateSystem: 'cartesian2d',\n    // zlevel: 0,\n    z: 2,\n    // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // Geo coordinate system\n    geoIndex: 0,\n    blurSize: 30,\n    pointSize: 20,\n    maxOpacity: 1,\n    minOpacity: 0,\n    select: {\n      itemStyle: {\n        borderColor: '#212121'\n      }\n    }\n  };\n  return HeatmapSeriesModel;\n}(Series/* default */.A);\n/* harmony default export */ const HeatmapSeries = (HeatmapSeriesModel);\n;// ./node_modules/echarts/lib/chart/heatmap/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction install(registers) {\n  registers.registerChartView(heatmap_HeatmapView);\n  registers.registerSeriesModel(HeatmapSeries);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk3MTQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDclRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlYXRtYXAvSGVhdG1hcExheWVyLmpzPzlkOTYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlYXRtYXAvSGVhdG1hcFZpZXcuanM/MjQwNCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVhdG1hcC9IZWF0bWFwU2VyaWVzLmpzP2UwZmUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlYXRtYXAvaW5zdGFsbC5qcz9kMzgwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLyogZ2xvYmFsIFVpbnQ4Q2xhbXBlZEFycmF5ICovXG5pbXBvcnQgeyBwbGF0Zm9ybUFwaSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvcGxhdGZvcm0uanMnO1xudmFyIEdSQURJRU5UX0xFVkVMUyA9IDI1NjtcbnZhciBIZWF0bWFwTGF5ZXIgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIZWF0bWFwTGF5ZXIoKSB7XG4gICAgdGhpcy5ibHVyU2l6ZSA9IDMwO1xuICAgIHRoaXMucG9pbnRTaXplID0gMjA7XG4gICAgdGhpcy5tYXhPcGFjaXR5ID0gMTtcbiAgICB0aGlzLm1pbk9wYWNpdHkgPSAwO1xuICAgIHRoaXMuX2dyYWRpZW50UGl4ZWxzID0ge1xuICAgICAgaW5SYW5nZTogbnVsbCxcbiAgICAgIG91dE9mUmFuZ2U6IG51bGxcbiAgICB9O1xuICAgIHZhciBjYW52YXMgPSBwbGF0Zm9ybUFwaS5jcmVhdGVDYW52YXMoKTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgfVxuICAvKipcclxuICAgKiBSZW5kZXJzIEhlYXRtYXAgYW5kIHJldHVybnMgdGhlIHJlbmRlcmVkIGNhbnZhc1xyXG4gICAqIEBwYXJhbSBkYXRhIGFycmF5IG9mIGRhdGEsIGVhY2ggaGFzIHgsIHksIHZhbHVlXHJcbiAgICogQHBhcmFtIHdpZHRoIGNhbnZhcyB3aWR0aFxyXG4gICAqIEBwYXJhbSBoZWlnaHQgY2FudmFzIGhlaWdodFxyXG4gICAqL1xuICBIZWF0bWFwTGF5ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCB3aWR0aCwgaGVpZ2h0LCBub3JtYWxpemUsIGNvbG9yRnVuYywgaXNJblJhbmdlKSB7XG4gICAgdmFyIGJydXNoID0gdGhpcy5fZ2V0QnJ1c2goKTtcbiAgICB2YXIgZ3JhZGllbnRJblJhbmdlID0gdGhpcy5fZ2V0R3JhZGllbnQoY29sb3JGdW5jLCAnaW5SYW5nZScpO1xuICAgIHZhciBncmFkaWVudE91dE9mUmFuZ2UgPSB0aGlzLl9nZXRHcmFkaWVudChjb2xvckZ1bmMsICdvdXRPZlJhbmdlJyk7XG4gICAgdmFyIHIgPSB0aGlzLnBvaW50U2l6ZSArIHRoaXMuYmx1clNpemU7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB2YXIgcCA9IGRhdGFbaV07XG4gICAgICB2YXIgeCA9IHBbMF07XG4gICAgICB2YXIgeSA9IHBbMV07XG4gICAgICB2YXIgdmFsdWUgPSBwWzJdO1xuICAgICAgLy8gY2FsY3VsYXRlIGFscGhhIHVzaW5nIHZhbHVlXG4gICAgICB2YXIgYWxwaGEgPSBub3JtYWxpemUodmFsdWUpO1xuICAgICAgLy8gZHJhdyB3aXRoIHRoZSBjaXJjbGUgYnJ1c2ggd2l0aCBhbHBoYVxuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgICBjdHguZHJhd0ltYWdlKGJydXNoLCB4IC0gciwgeSAtIHIpO1xuICAgIH1cbiAgICBpZiAoIWNhbnZhcy53aWR0aCB8fCAhY2FudmFzLmhlaWdodCkge1xuICAgICAgLy8gQXZvaWQgXCJVbmNhdWdodCBET01FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdnZXRJbWFnZURhdGEnIG9uXG4gICAgICAvLyAnQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEJzogVGhlIHNvdXJjZSBoZWlnaHQgaXMgMC5cIlxuICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG4gICAgLy8gY29sb3JpemUgdGhlIGNhbnZhcyB1c2luZyBhbHBoYSB2YWx1ZSBhbmQgc2V0IHdpdGggZ3JhZGllbnRcbiAgICB2YXIgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIHZhciBwaXhlbHMgPSBpbWFnZURhdGEuZGF0YTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgcGl4ZWxMZW4gPSBwaXhlbHMubGVuZ3RoO1xuICAgIHZhciBtaW5PcGFjaXR5ID0gdGhpcy5taW5PcGFjaXR5O1xuICAgIHZhciBtYXhPcGFjaXR5ID0gdGhpcy5tYXhPcGFjaXR5O1xuICAgIHZhciBkaWZmT3BhY2l0eSA9IG1heE9wYWNpdHkgLSBtaW5PcGFjaXR5O1xuICAgIHdoaWxlIChvZmZzZXQgPCBwaXhlbExlbikge1xuICAgICAgdmFyIGFscGhhID0gcGl4ZWxzW29mZnNldCArIDNdIC8gMjU2O1xuICAgICAgdmFyIGdyYWRpZW50T2Zmc2V0ID0gTWF0aC5mbG9vcihhbHBoYSAqIChHUkFESUVOVF9MRVZFTFMgLSAxKSkgKiA0O1xuICAgICAgLy8gU2ltcGxlIG9wdGltaXplIHRvIGlnbm9yZSB0aGUgZW1wdHkgZGF0YVxuICAgICAgaWYgKGFscGhhID4gMCkge1xuICAgICAgICB2YXIgZ3JhZGllbnQgPSBpc0luUmFuZ2UoYWxwaGEpID8gZ3JhZGllbnRJblJhbmdlIDogZ3JhZGllbnRPdXRPZlJhbmdlO1xuICAgICAgICAvLyBBbnkgYWxwaGEgPiAwIHdpbGwgYmUgbWFwcGVkIHRvIFttaW5PcGFjaXR5LCBtYXhPcGFjaXR5XVxuICAgICAgICBhbHBoYSA+IDAgJiYgKGFscGhhID0gYWxwaGEgKiBkaWZmT3BhY2l0eSArIG1pbk9wYWNpdHkpO1xuICAgICAgICBwaXhlbHNbb2Zmc2V0KytdID0gZ3JhZGllbnRbZ3JhZGllbnRPZmZzZXRdO1xuICAgICAgICBwaXhlbHNbb2Zmc2V0KytdID0gZ3JhZGllbnRbZ3JhZGllbnRPZmZzZXQgKyAxXTtcbiAgICAgICAgcGl4ZWxzW29mZnNldCsrXSA9IGdyYWRpZW50W2dyYWRpZW50T2Zmc2V0ICsgMl07XG4gICAgICAgIHBpeGVsc1tvZmZzZXQrK10gPSBncmFkaWVudFtncmFkaWVudE9mZnNldCArIDNdICogYWxwaGEgKiAyNTY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIHJldHVybiBjYW52YXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIGdldCBjYW52YXMgb2YgYSBibGFjayBjaXJjbGUgYnJ1c2ggdXNlZCBmb3IgY2FudmFzIHRvIGRyYXcgbGF0ZXJcclxuICAgKi9cbiAgSGVhdG1hcExheWVyLnByb3RvdHlwZS5fZ2V0QnJ1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJydXNoQ2FudmFzID0gdGhpcy5fYnJ1c2hDYW52YXMgfHwgKHRoaXMuX2JydXNoQ2FudmFzID0gcGxhdGZvcm1BcGkuY3JlYXRlQ2FudmFzKCkpO1xuICAgIC8vIHNldCBicnVzaCBzaXplXG4gICAgdmFyIHIgPSB0aGlzLnBvaW50U2l6ZSArIHRoaXMuYmx1clNpemU7XG4gICAgdmFyIGQgPSByICogMjtcbiAgICBicnVzaENhbnZhcy53aWR0aCA9IGQ7XG4gICAgYnJ1c2hDYW52YXMuaGVpZ2h0ID0gZDtcbiAgICB2YXIgY3R4ID0gYnJ1c2hDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGQsIGQpO1xuICAgIC8vIGluIG9yZGVyIHRvIHJlbmRlciBzaGFkb3cgd2l0aG91dCB0aGUgZGlzdGluY3QgY2lyY2xlLFxuICAgIC8vIGRyYXcgdGhlIGRpc3RpbmN0IGNpcmNsZSBpbiBhbiBpbnZpc2libGUgcGxhY2UsXG4gICAgLy8gYW5kIHVzZSBzaGFkb3dPZmZzZXQgdG8gZHJhdyBzaGFkb3cgaW4gdGhlIGNlbnRlciBvZiB0aGUgY2FudmFzXG4gICAgY3R4LnNoYWRvd09mZnNldFggPSBkO1xuICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5ibHVyU2l6ZTtcbiAgICAvLyBkcmF3IHRoZSBzaGFkb3cgaW4gYmxhY2ssIGFuZCB1c2UgYWxwaGEgYW5kIHNoYWRvdyBibHVyIHRvIGdlbmVyYXRlXG4gICAgLy8gY29sb3IgaW4gY29sb3IgbWFwXG4gICAgY3R4LnNoYWRvd0NvbG9yID0gJyMwMDAnO1xuICAgIC8vIGRyYXcgY2lyY2xlIGluIHRoZSBsZWZ0IHRvIHRoZSBjYW52YXNcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYygtciwgciwgdGhpcy5wb2ludFNpemUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwoKTtcbiAgICByZXR1cm4gYnJ1c2hDYW52YXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIGdldCBncmFkaWVudCBjb2xvciBtYXBcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBIZWF0bWFwTGF5ZXIucHJvdG90eXBlLl9nZXRHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvckZ1bmMsIHN0YXRlKSB7XG4gICAgdmFyIGdyYWRpZW50UGl4ZWxzID0gdGhpcy5fZ3JhZGllbnRQaXhlbHM7XG4gICAgdmFyIHBpeGVsc1NpbmdsZVN0YXRlID0gZ3JhZGllbnRQaXhlbHNbc3RhdGVdIHx8IChncmFkaWVudFBpeGVsc1tzdGF0ZV0gPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoMjU2ICogNCkpO1xuICAgIHZhciBjb2xvciA9IFswLCAwLCAwLCAwXTtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBjb2xvckZ1bmNbc3RhdGVdKGkgLyAyNTUsIHRydWUsIGNvbG9yKTtcbiAgICAgIHBpeGVsc1NpbmdsZVN0YXRlW29mZisrXSA9IGNvbG9yWzBdO1xuICAgICAgcGl4ZWxzU2luZ2xlU3RhdGVbb2ZmKytdID0gY29sb3JbMV07XG4gICAgICBwaXhlbHNTaW5nbGVTdGF0ZVtvZmYrK10gPSBjb2xvclsyXTtcbiAgICAgIHBpeGVsc1NpbmdsZVN0YXRlW29mZisrXSA9IGNvbG9yWzNdO1xuICAgIH1cbiAgICByZXR1cm4gcGl4ZWxzU2luZ2xlU3RhdGU7XG4gIH07XG4gIHJldHVybiBIZWF0bWFwTGF5ZXI7XG59KCk7XG5leHBvcnQgZGVmYXVsdCBIZWF0bWFwTGF5ZXI7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCB7IHRvZ2dsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgSGVhdG1hcExheWVyIGZyb20gJy4vSGVhdG1hcExheWVyLmpzJztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0LmpzJztcbmltcG9ydCB7IGlzQ29vcmRpbmF0ZVN5c3RlbVR5cGUgfSBmcm9tICcuLi8uLi9jb29yZC9Db29yZGluYXRlU3lzdGVtLmpzJztcbmltcG9ydCB7IHNldExhYmVsU3R5bGUsIGdldExhYmVsU3RhdGVzTW9kZWxzIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG5mdW5jdGlvbiBnZXRJc0luUGllY2V3aXNlUmFuZ2UoZGF0YUV4dGVudCwgcGllY2VMaXN0LCBzZWxlY3RlZCkge1xuICB2YXIgZGF0YVNwYW4gPSBkYXRhRXh0ZW50WzFdIC0gZGF0YUV4dGVudFswXTtcbiAgcGllY2VMaXN0ID0genJVdGlsLm1hcChwaWVjZUxpc3QsIGZ1bmN0aW9uIChwaWVjZSkge1xuICAgIHJldHVybiB7XG4gICAgICBpbnRlcnZhbDogWyhwaWVjZS5pbnRlcnZhbFswXSAtIGRhdGFFeHRlbnRbMF0pIC8gZGF0YVNwYW4sIChwaWVjZS5pbnRlcnZhbFsxXSAtIGRhdGFFeHRlbnRbMF0pIC8gZGF0YVNwYW5dXG4gICAgfTtcbiAgfSk7XG4gIHZhciBsZW4gPSBwaWVjZUxpc3QubGVuZ3RoO1xuICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YXIgaTtcbiAgICAvLyBUcnkgdG8gZmluZCBpbiB0aGUgbG9jYXRpb24gb2YgdGhlIGxhc3QgZm91bmRcbiAgICBmb3IgKGkgPSBsYXN0SW5kZXg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGludGVydmFsID0gcGllY2VMaXN0W2ldLmludGVydmFsO1xuICAgICAgaWYgKGludGVydmFsWzBdIDw9IHZhbCAmJiB2YWwgPD0gaW50ZXJ2YWxbMV0pIHtcbiAgICAgICAgbGFzdEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSBsZW4pIHtcbiAgICAgIC8vIE5vdCBmb3VuZCwgYmFjayBpbnRlcmF0aW9uXG4gICAgICBmb3IgKGkgPSBsYXN0SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBwaWVjZUxpc3RbaV0uaW50ZXJ2YWw7XG4gICAgICAgIGlmIChpbnRlcnZhbFswXSA8PSB2YWwgJiYgdmFsIDw9IGludGVydmFsWzFdKSB7XG4gICAgICAgICAgbGFzdEluZGV4ID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaSA+PSAwICYmIGkgPCBsZW4gJiYgc2VsZWN0ZWRbaV07XG4gIH07XG59XG5mdW5jdGlvbiBnZXRJc0luQ29udGludW91c1JhbmdlKGRhdGFFeHRlbnQsIHJhbmdlKSB7XG4gIHZhciBkYXRhU3BhbiA9IGRhdGFFeHRlbnRbMV0gLSBkYXRhRXh0ZW50WzBdO1xuICByYW5nZSA9IFsocmFuZ2VbMF0gLSBkYXRhRXh0ZW50WzBdKSAvIGRhdGFTcGFuLCAocmFuZ2VbMV0gLSBkYXRhRXh0ZW50WzBdKSAvIGRhdGFTcGFuXTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsID49IHJhbmdlWzBdICYmIHZhbCA8PSByYW5nZVsxXTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzR2VvQ29vcmRTeXMoY29vcmRTeXMpIHtcbiAgdmFyIGRpbWVuc2lvbnMgPSBjb29yZFN5cy5kaW1lbnNpb25zO1xuICAvLyBOb3QgdXNlIGNvb3JkU3lzLnR5cGUgPT09ICdnZW8nIGJlY2F1c2UgY29vcmRTeXMgbWF5YmUgZXh0ZW5kZWRcbiAgcmV0dXJuIGRpbWVuc2lvbnNbMF0gPT09ICdsbmcnICYmIGRpbWVuc2lvbnNbMV0gPT09ICdsYXQnO1xufVxudmFyIEhlYXRtYXBWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEhlYXRtYXBWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBIZWF0bWFwVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gSGVhdG1hcFZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgSGVhdG1hcFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIHZpc3VhbE1hcE9mVGhpc1NlcmllcztcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ3Zpc3VhbE1hcCcsIGZ1bmN0aW9uICh2aXN1YWxNYXApIHtcbiAgICAgIHZpc3VhbE1hcC5lYWNoVGFyZ2V0U2VyaWVzKGZ1bmN0aW9uICh0YXJnZXRTZXJpZXMpIHtcbiAgICAgICAgaWYgKHRhcmdldFNlcmllcyA9PT0gc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICB2aXN1YWxNYXBPZlRoaXNTZXJpZXMgPSB2aXN1YWxNYXA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIXZpc3VhbE1hcE9mVGhpc1Nlcmllcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hlYXRtYXAgbXVzdCB1c2Ugd2l0aCB2aXN1YWxNYXAnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2xlYXIgcHJldmlvdXNseSByZW5kZXJlZCBwcm9ncmVzc2l2ZSBlbGVtZW50cy5cbiAgICB0aGlzLl9wcm9ncmVzc2l2ZUVscyA9IG51bGw7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIGlmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnIHx8IGNvb3JkU3lzLnR5cGUgPT09ICdjYWxlbmRhcicpIHtcbiAgICAgIHRoaXMuX3JlbmRlck9uQ2FydGVzaWFuQW5kQ2FsZW5kYXIoc2VyaWVzTW9kZWwsIGFwaSwgMCwgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmNvdW50KCkpO1xuICAgIH0gZWxzZSBpZiAoaXNHZW9Db29yZFN5cyhjb29yZFN5cykpIHtcbiAgICAgIHRoaXMuX3JlbmRlck9uR2VvKGNvb3JkU3lzLCBzZXJpZXNNb2RlbCwgdmlzdWFsTWFwT2ZUaGlzU2VyaWVzLCBhcGkpO1xuICAgIH1cbiAgfTtcbiAgSGVhdG1hcFZpZXcucHJvdG90eXBlLmluY3JlbWVudGFsUHJlcGFyZVJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgfTtcbiAgSGVhdG1hcFZpZXcucHJvdG90eXBlLmluY3JlbWVudGFsUmVuZGVyID0gZnVuY3Rpb24gKHBhcmFtcywgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgaWYgKGNvb3JkU3lzKSB7XG4gICAgICAvLyBnZW8gZG9lcyBub3Qgc3VwcG9ydCBpbmNyZW1lbnRhbCByZW5kZXJpbmc/XG4gICAgICBpZiAoaXNHZW9Db29yZFN5cyhjb29yZFN5cykpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wcm9ncmVzc2l2ZUVscyA9IFtdO1xuICAgICAgICB0aGlzLl9yZW5kZXJPbkNhcnRlc2lhbkFuZENhbGVuZGFyKHNlcmllc01vZGVsLCBhcGksIHBhcmFtcy5zdGFydCwgcGFyYW1zLmVuZCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBIZWF0bWFwVmlldy5wcm90b3R5cGUuZWFjaFJlbmRlcmVkID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgZ3JhcGhpYy50cmF2ZXJzZUVsZW1lbnRzKHRoaXMuX3Byb2dyZXNzaXZlRWxzIHx8IHRoaXMuZ3JvdXAsIGNiKTtcbiAgfTtcbiAgSGVhdG1hcFZpZXcucHJvdG90eXBlLl9yZW5kZXJPbkNhcnRlc2lhbkFuZENhbGVuZGFyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBhcGksIHN0YXJ0LCBlbmQsIGluY3JlbWVudGFsKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgaXNDYXJ0ZXNpYW4yZCA9IGlzQ29vcmRpbmF0ZVN5c3RlbVR5cGUoY29vcmRTeXMsICdjYXJ0ZXNpYW4yZCcpO1xuICAgIHZhciB3aWR0aDtcbiAgICB2YXIgaGVpZ2h0O1xuICAgIHZhciB4QXhpc0V4dGVudDtcbiAgICB2YXIgeUF4aXNFeHRlbnQ7XG4gICAgaWYgKGlzQ2FydGVzaWFuMmQpIHtcbiAgICAgIHZhciB4QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3gnKTtcbiAgICAgIHZhciB5QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3knKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICghKHhBeGlzLnR5cGUgPT09ICdjYXRlZ29yeScgJiYgeUF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hlYXRtYXAgb24gY2FydGVzaWFuIG11c3QgaGF2ZSB0d28gY2F0ZWdvcnkgYXhlcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHhBeGlzLm9uQmFuZCAmJiB5QXhpcy5vbkJhbmQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIZWF0bWFwIG9uIGNhcnRlc2lhbiBtdXN0IGhhdmUgdHdvIGF4ZXMgd2l0aCBib3VuZGFyeUdhcCB0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFkZCAwLjVweCB0byBhdm9pZCB0aGUgZ2Fwc1xuICAgICAgd2lkdGggPSB4QXhpcy5nZXRCYW5kV2lkdGgoKSArIC41O1xuICAgICAgaGVpZ2h0ID0geUF4aXMuZ2V0QmFuZFdpZHRoKCkgKyAuNTtcbiAgICAgIHhBeGlzRXh0ZW50ID0geEF4aXMuc2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgICB5QXhpc0V4dGVudCA9IHlBeGlzLnNjYWxlLmdldEV4dGVudCgpO1xuICAgIH1cbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBlbXBoYXNpc1N0eWxlID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoWydlbXBoYXNpcycsICdpdGVtU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCk7XG4gICAgdmFyIGJsdXJTdHlsZSA9IHNlcmllc01vZGVsLmdldE1vZGVsKFsnYmx1cicsICdpdGVtU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCk7XG4gICAgdmFyIHNlbGVjdFN0eWxlID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoWydzZWxlY3QnLCAnaXRlbVN0eWxlJ10pLmdldEl0ZW1TdHlsZSgpO1xuICAgIHZhciBib3JkZXJSYWRpdXMgPSBzZXJpZXNNb2RlbC5nZXQoWydpdGVtU3R5bGUnLCAnYm9yZGVyUmFkaXVzJ10pO1xuICAgIHZhciBsYWJlbFN0YXRlc01vZGVscyA9IGdldExhYmVsU3RhdGVzTW9kZWxzKHNlcmllc01vZGVsKTtcbiAgICB2YXIgZW1waGFzaXNNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdlbXBoYXNpcycpO1xuICAgIHZhciBmb2N1cyA9IGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpO1xuICAgIHZhciBibHVyU2NvcGUgPSBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJyk7XG4gICAgdmFyIGVtcGhhc2lzRGlzYWJsZWQgPSBlbXBoYXNpc01vZGVsLmdldCgnZGlzYWJsZWQnKTtcbiAgICB2YXIgZGF0YURpbXMgPSBpc0NhcnRlc2lhbjJkID8gW2RhdGEubWFwRGltZW5zaW9uKCd4JyksIGRhdGEubWFwRGltZW5zaW9uKCd5JyksIGRhdGEubWFwRGltZW5zaW9uKCd2YWx1ZScpXSA6IFtkYXRhLm1hcERpbWVuc2lvbigndGltZScpLCBkYXRhLm1hcERpbWVuc2lvbigndmFsdWUnKV07XG4gICAgZm9yICh2YXIgaWR4ID0gc3RhcnQ7IGlkeCA8IGVuZDsgaWR4KyspIHtcbiAgICAgIHZhciByZWN0ID0gdm9pZCAwO1xuICAgICAgdmFyIHN0eWxlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJyk7XG4gICAgICBpZiAoaXNDYXJ0ZXNpYW4yZCkge1xuICAgICAgICB2YXIgZGF0YURpbVggPSBkYXRhLmdldChkYXRhRGltc1swXSwgaWR4KTtcbiAgICAgICAgdmFyIGRhdGFEaW1ZID0gZGF0YS5nZXQoZGF0YURpbXNbMV0sIGlkeCk7XG4gICAgICAgIC8vIElnbm9yZSBlbXB0eSBkYXRhIGFuZCBvdXQgb2YgZXh0ZW50IGRhdGFcbiAgICAgICAgaWYgKGlzTmFOKGRhdGEuZ2V0KGRhdGFEaW1zWzJdLCBpZHgpKSB8fCBpc05hTihkYXRhRGltWCkgfHwgaXNOYU4oZGF0YURpbVkpIHx8IGRhdGFEaW1YIDwgeEF4aXNFeHRlbnRbMF0gfHwgZGF0YURpbVggPiB4QXhpc0V4dGVudFsxXSB8fCBkYXRhRGltWSA8IHlBeGlzRXh0ZW50WzBdIHx8IGRhdGFEaW1ZID4geUF4aXNFeHRlbnRbMV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9pbnQgPSBjb29yZFN5cy5kYXRhVG9Qb2ludChbZGF0YURpbVgsIGRhdGFEaW1ZXSk7XG4gICAgICAgIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgeDogcG9pbnRbMF0gLSB3aWR0aCAvIDIsXG4gICAgICAgICAgICB5OiBwb2ludFsxXSAtIGhlaWdodCAvIDIsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGU6IHN0eWxlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWdub3JlIGVtcHR5IGRhdGFcbiAgICAgICAgaWYgKGlzTmFOKGRhdGEuZ2V0KGRhdGFEaW1zWzFdLCBpZHgpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICB6MjogMSxcbiAgICAgICAgICBzaGFwZTogY29vcmRTeXMuZGF0YVRvUmVjdChbZGF0YS5nZXQoZGF0YURpbXNbMF0sIGlkeCldKS5jb250ZW50U2hhcGUsXG4gICAgICAgICAgc3R5bGU6IHN0eWxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gT3B0aW1pemF0aW9uIGZvciBsYXJnZSBkYXRhc2V0XG4gICAgICBpZiAoZGF0YS5oYXNJdGVtT3B0aW9uKSB7XG4gICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgICB2YXIgZW1waGFzaXNNb2RlbF8xID0gaXRlbU1vZGVsLmdldE1vZGVsKCdlbXBoYXNpcycpO1xuICAgICAgICBlbXBoYXNpc1N0eWxlID0gZW1waGFzaXNNb2RlbF8xLmdldE1vZGVsKCdpdGVtU3R5bGUnKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgICAgYmx1clN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKFsnYmx1cicsICdpdGVtU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCk7XG4gICAgICAgIHNlbGVjdFN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKFsnc2VsZWN0JywgJ2l0ZW1TdHlsZSddKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgICAgLy8gRWFjaCBpdGVtIHZhbHVlIHN0cnVjdCBpbiB0aGUgZGF0YSB3b3VsZCBiZSBmaXJzdGx5XG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIGl0ZW1TdHlsZTogeyBib3JkZXJSYWRpdXM6IFszMCwgMzBdIH0sXG4gICAgICAgIC8vICAgICB2YWx1ZTogWzIwMjIsIDAyLCAyMl1cbiAgICAgICAgLy8gfVxuICAgICAgICBib3JkZXJSYWRpdXMgPSBpdGVtTW9kZWwuZ2V0KFsnaXRlbVN0eWxlJywgJ2JvcmRlclJhZGl1cyddKTtcbiAgICAgICAgZm9jdXMgPSBlbXBoYXNpc01vZGVsXzEuZ2V0KCdmb2N1cycpO1xuICAgICAgICBibHVyU2NvcGUgPSBlbXBoYXNpc01vZGVsXzEuZ2V0KCdibHVyU2NvcGUnKTtcbiAgICAgICAgZW1waGFzaXNEaXNhYmxlZCA9IGVtcGhhc2lzTW9kZWxfMS5nZXQoJ2Rpc2FibGVkJyk7XG4gICAgICAgIGxhYmVsU3RhdGVzTW9kZWxzID0gZ2V0TGFiZWxTdGF0ZXNNb2RlbHMoaXRlbU1vZGVsKTtcbiAgICAgIH1cbiAgICAgIHJlY3Quc2hhcGUuciA9IGJvcmRlclJhZGl1cztcbiAgICAgIHZhciByYXdWYWx1ZSA9IHNlcmllc01vZGVsLmdldFJhd1ZhbHVlKGlkeCk7XG4gICAgICB2YXIgZGVmYXVsdFRleHQgPSAnLSc7XG4gICAgICBpZiAocmF3VmFsdWUgJiYgcmF3VmFsdWVbMl0gIT0gbnVsbCkge1xuICAgICAgICBkZWZhdWx0VGV4dCA9IHJhd1ZhbHVlWzJdICsgJyc7XG4gICAgICB9XG4gICAgICBzZXRMYWJlbFN0eWxlKHJlY3QsIGxhYmVsU3RhdGVzTW9kZWxzLCB7XG4gICAgICAgIGxhYmVsRmV0Y2hlcjogc2VyaWVzTW9kZWwsXG4gICAgICAgIGxhYmVsRGF0YUluZGV4OiBpZHgsXG4gICAgICAgIGRlZmF1bHRPcGFjaXR5OiBzdHlsZS5vcGFjaXR5LFxuICAgICAgICBkZWZhdWx0VGV4dDogZGVmYXVsdFRleHRcbiAgICAgIH0pO1xuICAgICAgcmVjdC5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKS5zdHlsZSA9IGVtcGhhc2lzU3R5bGU7XG4gICAgICByZWN0LmVuc3VyZVN0YXRlKCdibHVyJykuc3R5bGUgPSBibHVyU3R5bGU7XG4gICAgICByZWN0LmVuc3VyZVN0YXRlKCdzZWxlY3QnKS5zdHlsZSA9IHNlbGVjdFN0eWxlO1xuICAgICAgdG9nZ2xlSG92ZXJFbXBoYXNpcyhyZWN0LCBmb2N1cywgYmx1clNjb3BlLCBlbXBoYXNpc0Rpc2FibGVkKTtcbiAgICAgIHJlY3QuaW5jcmVtZW50YWwgPSBpbmNyZW1lbnRhbDtcbiAgICAgIC8vIFBFTkRJTkdcbiAgICAgIGlmIChpbmNyZW1lbnRhbCkge1xuICAgICAgICAvLyBSZWN0IG11c3QgdXNlIGhvdmVyIGxheWVyIGlmIGl0J3MgaW5jcmVtZW50YWwuXG4gICAgICAgIHJlY3Quc3RhdGVzLmVtcGhhc2lzLmhvdmVyTGF5ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZ3JvdXAuYWRkKHJlY3QpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgcmVjdCk7XG4gICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NpdmVFbHMpIHtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVFbHMucHVzaChyZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIEhlYXRtYXBWaWV3LnByb3RvdHlwZS5fcmVuZGVyT25HZW8gPSBmdW5jdGlvbiAoZ2VvLCBzZXJpZXNNb2RlbCwgdmlzdWFsTWFwTW9kZWwsIGFwaSkge1xuICAgIHZhciBpblJhbmdlVmlzdWFscyA9IHZpc3VhbE1hcE1vZGVsLnRhcmdldFZpc3VhbHMuaW5SYW5nZTtcbiAgICB2YXIgb3V0T2ZSYW5nZVZpc3VhbHMgPSB2aXN1YWxNYXBNb2RlbC50YXJnZXRWaXN1YWxzLm91dE9mUmFuZ2U7XG4gICAgLy8gaWYgKCF2aXN1YWxNYXBwaW5nKSB7XG4gICAgLy8gICAgIHRocm93IG5ldyBFcnJvcignRGF0YSByYW5nZSBtdXN0IGhhdmUgY29sb3IgdmlzdWFscycpO1xuICAgIC8vIH1cbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgaG1MYXllciA9IHRoaXMuX2htTGF5ZXIgfHwgdGhpcy5faG1MYXllciB8fCBuZXcgSGVhdG1hcExheWVyKCk7XG4gICAgaG1MYXllci5ibHVyU2l6ZSA9IHNlcmllc01vZGVsLmdldCgnYmx1clNpemUnKTtcbiAgICBobUxheWVyLnBvaW50U2l6ZSA9IHNlcmllc01vZGVsLmdldCgncG9pbnRTaXplJyk7XG4gICAgaG1MYXllci5taW5PcGFjaXR5ID0gc2VyaWVzTW9kZWwuZ2V0KCdtaW5PcGFjaXR5Jyk7XG4gICAgaG1MYXllci5tYXhPcGFjaXR5ID0gc2VyaWVzTW9kZWwuZ2V0KCdtYXhPcGFjaXR5Jyk7XG4gICAgdmFyIHJlY3QgPSBnZW8uZ2V0Vmlld1JlY3QoKS5jbG9uZSgpO1xuICAgIHZhciByb2FtVHJhbnNmb3JtID0gZ2VvLmdldFJvYW1UcmFuc2Zvcm0oKTtcbiAgICByZWN0LmFwcGx5VHJhbnNmb3JtKHJvYW1UcmFuc2Zvcm0pO1xuICAgIC8vIENsYW1wIG9uIHZpZXdwb3J0XG4gICAgdmFyIHggPSBNYXRoLm1heChyZWN0LngsIDApO1xuICAgIHZhciB5ID0gTWF0aC5tYXgocmVjdC55LCAwKTtcbiAgICB2YXIgeDIgPSBNYXRoLm1pbihyZWN0LndpZHRoICsgcmVjdC54LCBhcGkuZ2V0V2lkdGgoKSk7XG4gICAgdmFyIHkyID0gTWF0aC5taW4ocmVjdC5oZWlnaHQgKyByZWN0LnksIGFwaS5nZXRIZWlnaHQoKSk7XG4gICAgdmFyIHdpZHRoID0geDIgLSB4O1xuICAgIHZhciBoZWlnaHQgPSB5MiAtIHk7XG4gICAgdmFyIGRpbXMgPSBbZGF0YS5tYXBEaW1lbnNpb24oJ2xuZycpLCBkYXRhLm1hcERpbWVuc2lvbignbGF0JyksIGRhdGEubWFwRGltZW5zaW9uKCd2YWx1ZScpXTtcbiAgICB2YXIgcG9pbnRzID0gZGF0YS5tYXBBcnJheShkaW1zLCBmdW5jdGlvbiAobG5nLCBsYXQsIHZhbHVlKSB7XG4gICAgICB2YXIgcHQgPSBnZW8uZGF0YVRvUG9pbnQoW2xuZywgbGF0XSk7XG4gICAgICBwdFswXSAtPSB4O1xuICAgICAgcHRbMV0gLT0geTtcbiAgICAgIHB0LnB1c2godmFsdWUpO1xuICAgICAgcmV0dXJuIHB0O1xuICAgIH0pO1xuICAgIHZhciBkYXRhRXh0ZW50ID0gdmlzdWFsTWFwTW9kZWwuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIGlzSW5SYW5nZSA9IHZpc3VhbE1hcE1vZGVsLnR5cGUgPT09ICd2aXN1YWxNYXAuY29udGludW91cycgPyBnZXRJc0luQ29udGludW91c1JhbmdlKGRhdGFFeHRlbnQsIHZpc3VhbE1hcE1vZGVsLm9wdGlvbi5yYW5nZSkgOiBnZXRJc0luUGllY2V3aXNlUmFuZ2UoZGF0YUV4dGVudCwgdmlzdWFsTWFwTW9kZWwuZ2V0UGllY2VMaXN0KCksIHZpc3VhbE1hcE1vZGVsLm9wdGlvbi5zZWxlY3RlZCk7XG4gICAgaG1MYXllci51cGRhdGUocG9pbnRzLCB3aWR0aCwgaGVpZ2h0LCBpblJhbmdlVmlzdWFscy5jb2xvci5nZXROb3JtYWxpemVyKCksIHtcbiAgICAgIGluUmFuZ2U6IGluUmFuZ2VWaXN1YWxzLmNvbG9yLmdldENvbG9yTWFwcGVyKCksXG4gICAgICBvdXRPZlJhbmdlOiBvdXRPZlJhbmdlVmlzdWFscy5jb2xvci5nZXRDb2xvck1hcHBlcigpXG4gICAgfSwgaXNJblJhbmdlKTtcbiAgICB2YXIgaW1nID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgaW1hZ2U6IGhtTGF5ZXIuY2FudmFzXG4gICAgICB9LFxuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5ncm91cC5hZGQoaW1nKTtcbiAgfTtcbiAgSGVhdG1hcFZpZXcudHlwZSA9ICdoZWF0bWFwJztcbiAgcmV0dXJuIEhlYXRtYXBWaWV3O1xufShDaGFydFZpZXcpO1xuZXhwb3J0IGRlZmF1bHQgSGVhdG1hcFZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMuanMnO1xuaW1wb3J0IGNyZWF0ZVNlcmllc0RhdGEgZnJvbSAnLi4vaGVscGVyL2NyZWF0ZVNlcmllc0RhdGEuanMnO1xuaW1wb3J0IENvb3JkaW5hdGVTeXN0ZW0gZnJvbSAnLi4vLi4vY29yZS9Db29yZGluYXRlU3lzdGVtLmpzJztcbnZhciBIZWF0bWFwU2VyaWVzTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoSGVhdG1hcFNlcmllc01vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBIZWF0bWFwU2VyaWVzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IEhlYXRtYXBTZXJpZXNNb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBIZWF0bWFwU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIHJldHVybiBjcmVhdGVTZXJpZXNEYXRhKG51bGwsIHRoaXMsIHtcbiAgICAgIGdlbmVyYXRlQ29vcmQ6ICd2YWx1ZSdcbiAgICB9KTtcbiAgfTtcbiAgSGVhdG1hcFNlcmllc01vZGVsLnByb3RvdHlwZS5wcmV2ZW50SW5jcmVtZW50YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvb3JkU3lzQ3JlYXRvciA9IENvb3JkaW5hdGVTeXN0ZW0uZ2V0KHRoaXMuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykpO1xuICAgIGlmIChjb29yZFN5c0NyZWF0b3IgJiYgY29vcmRTeXNDcmVhdG9yLmRpbWVuc2lvbnMpIHtcbiAgICAgIHJldHVybiBjb29yZFN5c0NyZWF0b3IuZGltZW5zaW9uc1swXSA9PT0gJ2xuZycgJiYgY29vcmRTeXNDcmVhdG9yLmRpbWVuc2lvbnNbMV0gPT09ICdsYXQnO1xuICAgIH1cbiAgfTtcbiAgSGVhdG1hcFNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLmhlYXRtYXAnO1xuICBIZWF0bWFwU2VyaWVzTW9kZWwuZGVwZW5kZW5jaWVzID0gWydncmlkJywgJ2dlbycsICdjYWxlbmRhciddO1xuICBIZWF0bWFwU2VyaWVzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICBjb29yZGluYXRlU3lzdGVtOiAnY2FydGVzaWFuMmQnLFxuICAgIC8vIHpsZXZlbDogMCxcbiAgICB6OiAyLFxuICAgIC8vIENhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbVxuICAgIC8vIHhBeGlzSW5kZXg6IDAsXG4gICAgLy8geUF4aXNJbmRleDogMCxcbiAgICAvLyBHZW8gY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICBnZW9JbmRleDogMCxcbiAgICBibHVyU2l6ZTogMzAsXG4gICAgcG9pbnRTaXplOiAyMCxcbiAgICBtYXhPcGFjaXR5OiAxLFxuICAgIG1pbk9wYWNpdHk6IDAsXG4gICAgc2VsZWN0OiB7XG4gICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMjEyMTIxJ1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEhlYXRtYXBTZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuZXhwb3J0IGRlZmF1bHQgSGVhdG1hcFNlcmllc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IEhlYXRtYXBWaWV3IGZyb20gJy4vSGVhdG1hcFZpZXcuanMnO1xuaW1wb3J0IEhlYXRtYXBTZXJpZXNNb2RlbCBmcm9tICcuL0hlYXRtYXBTZXJpZXMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhIZWF0bWFwVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclNlcmllc01vZGVsKEhlYXRtYXBTZXJpZXNNb2RlbCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///49714\n")},50032:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/SymbolDraw.js\nvar SymbolDraw = __webpack_require__(18386);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/EffectSymbol.js\nvar EffectSymbol = __webpack_require__(71465);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/matrix.js\nvar matrix = __webpack_require__(45587);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/layout/points.js\nvar points = __webpack_require__(30682);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n;// ./node_modules/echarts/lib/chart/effectScatter/EffectScatterView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\nvar EffectScatterView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(EffectScatterView, _super);\n  function EffectScatterView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = EffectScatterView.type;\n    return _this;\n  }\n  EffectScatterView.prototype.init = function () {\n    this._symbolDraw = new SymbolDraw/* default */.A(EffectSymbol/* default */.A);\n  };\n  EffectScatterView.prototype.render = function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    var effectSymbolDraw = this._symbolDraw;\n    effectSymbolDraw.updateData(data, {\n      clipShape: this._getClipShape(seriesModel)\n    });\n    this.group.add(effectSymbolDraw.group);\n  };\n  EffectScatterView.prototype._getClipShape = function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n    var clipArea = coordSys && coordSys.getArea && coordSys.getArea();\n    return seriesModel.get('clip', true) ? clipArea : null;\n  };\n  EffectScatterView.prototype.updateTransform = function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    this.group.dirty();\n    var res = (0,points/* default */.A)('').reset(seriesModel, ecModel, api);\n    if (res.progress) {\n      res.progress({\n        start: 0,\n        end: data.count(),\n        count: data.count()\n      }, data);\n    }\n    this._symbolDraw.updateLayout();\n  };\n  EffectScatterView.prototype._updateGroupTransform = function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n    if (coordSys && coordSys.getRoamTransform) {\n      this.group.transform = matrix.clone(coordSys.getRoamTransform());\n      this.group.decomposeTransform();\n    }\n  };\n  EffectScatterView.prototype.remove = function (ecModel, api) {\n    this._symbolDraw && this._symbolDraw.remove(true);\n  };\n  EffectScatterView.type = 'effectScatter';\n  return EffectScatterView;\n}(Chart/* default */.A);\n/* harmony default export */ const effectScatter_EffectScatterView = (EffectScatterView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createSeriesData.js\nvar createSeriesData = __webpack_require__(13637);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n;// ./node_modules/echarts/lib/chart/effectScatter/EffectScatterSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar EffectScatterSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(EffectScatterSeriesModel, _super);\n  function EffectScatterSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = EffectScatterSeriesModel.type;\n    _this.hasSymbolVisual = true;\n    return _this;\n  }\n  EffectScatterSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    return (0,createSeriesData/* default */.A)(null, this, {\n      useEncodeDefaulter: true\n    });\n  };\n  EffectScatterSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {\n    return selectors.point(data.getItemLayout(dataIndex));\n  };\n  EffectScatterSeriesModel.type = 'series.effectScatter';\n  EffectScatterSeriesModel.dependencies = ['grid', 'polar'];\n  EffectScatterSeriesModel.defaultOption = {\n    coordinateSystem: 'cartesian2d',\n    // zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    effectType: 'ripple',\n    progressive: 0,\n    // When to show the effect, option: 'render'|'emphasis'\n    showEffectOn: 'render',\n    clip: true,\n    // Ripple effect config\n    rippleEffect: {\n      period: 4,\n      // Scale of ripple\n      scale: 2.5,\n      // Brush type can be fill or stroke\n      brushType: 'fill',\n      // Ripple number\n      number: 3\n    },\n    universalTransition: {\n      divideShape: 'clone'\n    },\n    // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // Polar coordinate system\n    // polarIndex: 0,\n    // Geo coordinate system\n    // geoIndex: 0,\n    // symbol: null,        // 图形类型\n    symbolSize: 10 // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\n    // symbolRotate: null,  // 图形旋转控制\n    // itemStyle: {\n    //     opacity: 1\n    // }\n  };\n  return EffectScatterSeriesModel;\n}(Series/* default */.A);\n/* harmony default export */ const EffectScatterSeries = (EffectScatterSeriesModel);\n;// ./node_modules/echarts/lib/chart/effectScatter/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction install(registers) {\n  registers.registerChartView(effectScatter_EffectScatterView);\n  registers.registerSeriesModel(EffectScatterSeries);\n  registers.registerLayout((0,points/* default */.A)('effectScatter'));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAwMzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9lZmZlY3RTY2F0dGVyL0VmZmVjdFNjYXR0ZXJWaWV3LmpzPzgyMzkiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2VmZmVjdFNjYXR0ZXIvRWZmZWN0U2NhdHRlclNlcmllcy5qcz81MjlhIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9lZmZlY3RTY2F0dGVyL2luc3RhbGwuanM/MTZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFN5bWJvbERyYXcgZnJvbSAnLi4vaGVscGVyL1N5bWJvbERyYXcuanMnO1xuaW1wb3J0IEVmZmVjdFN5bWJvbCBmcm9tICcuLi9oZWxwZXIvRWZmZWN0U3ltYm9sLmpzJztcbmltcG9ydCAqIGFzIG1hdHJpeCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qcyc7XG5pbXBvcnQgcG9pbnRzTGF5b3V0IGZyb20gJy4uLy4uL2xheW91dC9wb2ludHMuanMnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0LmpzJztcbnZhciBFZmZlY3RTY2F0dGVyVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhFZmZlY3RTY2F0dGVyVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRWZmZWN0U2NhdHRlclZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IEVmZmVjdFNjYXR0ZXJWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEVmZmVjdFNjYXR0ZXJWaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3N5bWJvbERyYXcgPSBuZXcgU3ltYm9sRHJhdyhFZmZlY3RTeW1ib2wpO1xuICB9O1xuICBFZmZlY3RTY2F0dGVyVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgZWZmZWN0U3ltYm9sRHJhdyA9IHRoaXMuX3N5bWJvbERyYXc7XG4gICAgZWZmZWN0U3ltYm9sRHJhdy51cGRhdGVEYXRhKGRhdGEsIHtcbiAgICAgIGNsaXBTaGFwZTogdGhpcy5fZ2V0Q2xpcFNoYXBlKHNlcmllc01vZGVsKVxuICAgIH0pO1xuICAgIHRoaXMuZ3JvdXAuYWRkKGVmZmVjdFN5bWJvbERyYXcuZ3JvdXApO1xuICB9O1xuICBFZmZlY3RTY2F0dGVyVmlldy5wcm90b3R5cGUuX2dldENsaXBTaGFwZSA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGNsaXBBcmVhID0gY29vcmRTeXMgJiYgY29vcmRTeXMuZ2V0QXJlYSAmJiBjb29yZFN5cy5nZXRBcmVhKCk7XG4gICAgcmV0dXJuIHNlcmllc01vZGVsLmdldCgnY2xpcCcsIHRydWUpID8gY2xpcEFyZWEgOiBudWxsO1xuICB9O1xuICBFZmZlY3RTY2F0dGVyVmlldy5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB0aGlzLmdyb3VwLmRpcnR5KCk7XG4gICAgdmFyIHJlcyA9IHBvaW50c0xheW91dCgnJykucmVzZXQoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgaWYgKHJlcy5wcm9ncmVzcykge1xuICAgICAgcmVzLnByb2dyZXNzKHtcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGVuZDogZGF0YS5jb3VudCgpLFxuICAgICAgICBjb3VudDogZGF0YS5jb3VudCgpXG4gICAgICB9LCBkYXRhKTtcbiAgICB9XG4gICAgdGhpcy5fc3ltYm9sRHJhdy51cGRhdGVMYXlvdXQoKTtcbiAgfTtcbiAgRWZmZWN0U2NhdHRlclZpZXcucHJvdG90eXBlLl91cGRhdGVHcm91cFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgaWYgKGNvb3JkU3lzICYmIGNvb3JkU3lzLmdldFJvYW1UcmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuZ3JvdXAudHJhbnNmb3JtID0gbWF0cml4LmNsb25lKGNvb3JkU3lzLmdldFJvYW1UcmFuc2Zvcm0oKSk7XG4gICAgICB0aGlzLmdyb3VwLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICAgIH1cbiAgfTtcbiAgRWZmZWN0U2NhdHRlclZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLl9zeW1ib2xEcmF3ICYmIHRoaXMuX3N5bWJvbERyYXcucmVtb3ZlKHRydWUpO1xuICB9O1xuICBFZmZlY3RTY2F0dGVyVmlldy50eXBlID0gJ2VmZmVjdFNjYXR0ZXInO1xuICByZXR1cm4gRWZmZWN0U2NhdHRlclZpZXc7XG59KENoYXJ0Vmlldyk7XG5leHBvcnQgZGVmYXVsdCBFZmZlY3RTY2F0dGVyVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IGNyZWF0ZVNlcmllc0RhdGEgZnJvbSAnLi4vaGVscGVyL2NyZWF0ZVNlcmllc0RhdGEuanMnO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcy5qcyc7XG52YXIgRWZmZWN0U2NhdHRlclNlcmllc01vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEVmZmVjdFNjYXR0ZXJTZXJpZXNNb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRWZmZWN0U2NhdHRlclNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBFZmZlY3RTY2F0dGVyU2VyaWVzTW9kZWwudHlwZTtcbiAgICBfdGhpcy5oYXNTeW1ib2xWaXN1YWwgPSB0cnVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBFZmZlY3RTY2F0dGVyU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIHJldHVybiBjcmVhdGVTZXJpZXNEYXRhKG51bGwsIHRoaXMsIHtcbiAgICAgIHVzZUVuY29kZURlZmF1bHRlcjogdHJ1ZVxuICAgIH0pO1xuICB9O1xuICBFZmZlY3RTY2F0dGVyU2VyaWVzTW9kZWwucHJvdG90eXBlLmJydXNoU2VsZWN0b3IgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBkYXRhLCBzZWxlY3RvcnMpIHtcbiAgICByZXR1cm4gc2VsZWN0b3JzLnBvaW50KGRhdGEuZ2V0SXRlbUxheW91dChkYXRhSW5kZXgpKTtcbiAgfTtcbiAgRWZmZWN0U2NhdHRlclNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLmVmZmVjdFNjYXR0ZXInO1xuICBFZmZlY3RTY2F0dGVyU2VyaWVzTW9kZWwuZGVwZW5kZW5jaWVzID0gWydncmlkJywgJ3BvbGFyJ107XG4gIEVmZmVjdFNjYXR0ZXJTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdjYXJ0ZXNpYW4yZCcsXG4gICAgLy8gemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIGVmZmVjdFR5cGU6ICdyaXBwbGUnLFxuICAgIHByb2dyZXNzaXZlOiAwLFxuICAgIC8vIFdoZW4gdG8gc2hvdyB0aGUgZWZmZWN0LCBvcHRpb246ICdyZW5kZXInfCdlbXBoYXNpcydcbiAgICBzaG93RWZmZWN0T246ICdyZW5kZXInLFxuICAgIGNsaXA6IHRydWUsXG4gICAgLy8gUmlwcGxlIGVmZmVjdCBjb25maWdcbiAgICByaXBwbGVFZmZlY3Q6IHtcbiAgICAgIHBlcmlvZDogNCxcbiAgICAgIC8vIFNjYWxlIG9mIHJpcHBsZVxuICAgICAgc2NhbGU6IDIuNSxcbiAgICAgIC8vIEJydXNoIHR5cGUgY2FuIGJlIGZpbGwgb3Igc3Ryb2tlXG4gICAgICBicnVzaFR5cGU6ICdmaWxsJyxcbiAgICAgIC8vIFJpcHBsZSBudW1iZXJcbiAgICAgIG51bWJlcjogM1xuICAgIH0sXG4gICAgdW5pdmVyc2FsVHJhbnNpdGlvbjoge1xuICAgICAgZGl2aWRlU2hhcGU6ICdjbG9uZSdcbiAgICB9LFxuICAgIC8vIENhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbVxuICAgIC8vIHhBeGlzSW5kZXg6IDAsXG4gICAgLy8geUF4aXNJbmRleDogMCxcbiAgICAvLyBQb2xhciBjb29yZGluYXRlIHN5c3RlbVxuICAgIC8vIHBvbGFySW5kZXg6IDAsXG4gICAgLy8gR2VvIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgLy8gZ2VvSW5kZXg6IDAsXG4gICAgLy8gc3ltYm9sOiBudWxsLCAgICAgICAgLy8g5Zu+5b2i57G75Z6LXG4gICAgc3ltYm9sU2l6ZTogMTAgLy8g5Zu+5b2i5aSn5bCP77yM5Y2K5a6977yI5Y2K5b6E77yJ5Y+C5pWw77yM5b2T5Zu+5b2i5Li65pa55ZCR5oiW6I+x5b2i5YiZ5oC75a695bqm5Li6c3ltYm9sU2l6ZSAqIDJcbiAgICAvLyBzeW1ib2xSb3RhdGU6IG51bGwsICAvLyDlm77lvaLml4vovazmjqfliLZcbiAgICAvLyBpdGVtU3R5bGU6IHtcbiAgICAvLyAgICAgb3BhY2l0eTogMVxuICAgIC8vIH1cbiAgfTtcbiAgcmV0dXJuIEVmZmVjdFNjYXR0ZXJTZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuZXhwb3J0IGRlZmF1bHQgRWZmZWN0U2NhdHRlclNlcmllc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IEVmZmVjdFNjYXR0ZXJWaWV3IGZyb20gJy4vRWZmZWN0U2NhdHRlclZpZXcuanMnO1xuaW1wb3J0IEVmZmVjdFNjYXR0ZXJTZXJpZXNNb2RlbCBmcm9tICcuL0VmZmVjdFNjYXR0ZXJTZXJpZXMuanMnO1xuaW1wb3J0IGxheW91dFBvaW50cyBmcm9tICcuLi8uLi9sYXlvdXQvcG9pbnRzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDaGFydFZpZXcoRWZmZWN0U2NhdHRlclZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChFZmZlY3RTY2F0dGVyU2VyaWVzTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQobGF5b3V0UG9pbnRzKCdlZmZlY3RTY2F0dGVyJykpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///50032\n")},61030:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Path.js\nvar Path = __webpack_require__(59482);\n;// ./node_modules/echarts/lib/chart/gauge/PointerPath.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar PointerShape = /** @class */function () {\n  function PointerShape() {\n    this.angle = 0;\n    this.width = 10;\n    this.r = 10;\n    this.x = 0;\n    this.y = 0;\n  }\n  return PointerShape;\n}();\nvar PointerPath = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(PointerPath, _super);\n  function PointerPath(opts) {\n    var _this = _super.call(this, opts) || this;\n    _this.type = 'pointer';\n    return _this;\n  }\n  PointerPath.prototype.getDefaultShape = function () {\n    return new PointerShape();\n  };\n  PointerPath.prototype.buildPath = function (ctx, shape) {\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var r = shape.r;\n    var width = shape.width;\n    var angle = shape.angle;\n    var x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2);\n    var y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2);\n    angle = shape.angle - Math.PI / 2;\n    ctx.moveTo(x, y);\n    ctx.lineTo(shape.x + mathCos(angle) * width, shape.y + mathSin(angle) * width);\n    ctx.lineTo(shape.x + mathCos(shape.angle) * r, shape.y + mathSin(shape.angle) * r);\n    ctx.lineTo(shape.x - mathCos(angle) * width, shape.y - mathSin(angle) * width);\n    ctx.lineTo(x, y);\n  };\n  return PointerPath;\n}(Path/* default */.Ay);\n/* harmony default export */ const gauge_PointerPath = (PointerPath);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Sector.js + 1 modules\nvar Sector = __webpack_require__(25014);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Line.js\nvar Line = __webpack_require__(82861);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/shape/sausage.js\nvar sausage = __webpack_require__(84618);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/symbol.js\nvar symbol = __webpack_require__(62103);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Image.js\nvar Image = __webpack_require__(90540);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/PathProxy.js\nvar PathProxy = __webpack_require__(68717);\n;// ./node_modules/echarts/lib/chart/gauge/GaugeView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction parsePosition(seriesModel, api) {\n  var center = seriesModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var size = Math.min(width, height);\n  var cx = (0,number/* parsePercent */.lo)(center[0], api.getWidth());\n  var cy = (0,number/* parsePercent */.lo)(center[1], api.getHeight());\n  var r = (0,number/* parsePercent */.lo)(seriesModel.get('radius'), size / 2);\n  return {\n    cx: cx,\n    cy: cy,\n    r: r\n  };\n}\nfunction formatLabel(value, labelFormatter) {\n  var label = value == null ? '' : value + '';\n  if (labelFormatter) {\n    if ((0,util.isString)(labelFormatter)) {\n      label = labelFormatter.replace('{value}', label);\n    } else if ((0,util.isFunction)(labelFormatter)) {\n      label = labelFormatter(value);\n    }\n  }\n  return label;\n}\nvar GaugeView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(GaugeView, _super);\n  function GaugeView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = GaugeView.type;\n    return _this;\n  }\n  GaugeView.prototype.render = function (seriesModel, ecModel, api) {\n    this.group.removeAll();\n    var colorList = seriesModel.get(['axisLine', 'lineStyle', 'color']);\n    var posInfo = parsePosition(seriesModel, api);\n    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);\n    this._data = seriesModel.getData();\n  };\n  GaugeView.prototype.dispose = function () {};\n  GaugeView.prototype._renderMain = function (seriesModel, ecModel, api, colorList, posInfo) {\n    var group = this.group;\n    var clockwise = seriesModel.get('clockwise');\n    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n    var axisLineModel = seriesModel.getModel('axisLine');\n    var roundCap = axisLineModel.get('roundCap');\n    var MainPath = roundCap ? sausage/* default */.A : Sector/* default */.A;\n    var showAxis = axisLineModel.get('show');\n    var lineStyleModel = axisLineModel.getModel('lineStyle');\n    var axisLineWidth = lineStyleModel.get('width');\n    var angles = [startAngle, endAngle];\n    (0,PathProxy/* normalizeArcAngles */.q)(angles, !clockwise);\n    startAngle = angles[0];\n    endAngle = angles[1];\n    var angleRangeSpan = endAngle - startAngle;\n    var prevEndAngle = startAngle;\n    var sectors = [];\n    for (var i = 0; showAxis && i < colorList.length; i++) {\n      // Clamp\n      var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n      endAngle = startAngle + angleRangeSpan * percent;\n      var sector = new MainPath({\n        shape: {\n          startAngle: prevEndAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: posInfo.r - axisLineWidth,\n          r: posInfo.r\n        },\n        silent: true\n      });\n      sector.setStyle({\n        fill: colorList[i][1]\n      });\n      sector.setStyle(lineStyleModel.getLineStyle(\n      // Because we use sector to simulate arc\n      // so the properties for stroking are useless\n      ['color', 'width']));\n      sectors.push(sector);\n      prevEndAngle = endAngle;\n    }\n    sectors.reverse();\n    (0,util.each)(sectors, function (sector) {\n      return group.add(sector);\n    });\n    var getColor = function (percent) {\n      // Less than 0\n      if (percent <= 0) {\n        return colorList[0][1];\n      }\n      var i;\n      for (i = 0; i < colorList.length; i++) {\n        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {\n          return colorList[i][1];\n        }\n      }\n      // More than 1\n      return colorList[i - 1][1];\n    };\n    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n    this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);\n    this._renderAnchor(seriesModel, posInfo);\n    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n  };\n  GaugeView.prototype._renderTicks = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var cx = posInfo.cx;\n    var cy = posInfo.cy;\n    var r = posInfo.r;\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var splitLineModel = seriesModel.getModel('splitLine');\n    var tickModel = seriesModel.getModel('axisTick');\n    var labelModel = seriesModel.getModel('axisLabel');\n    var splitNumber = seriesModel.get('splitNumber');\n    var subSplitNumber = tickModel.get('splitNumber');\n    var splitLineLen = (0,number/* parsePercent */.lo)(splitLineModel.get('length'), r);\n    var tickLen = (0,number/* parsePercent */.lo)(tickModel.get('length'), r);\n    var angle = startAngle;\n    var step = (endAngle - startAngle) / splitNumber;\n    var subStep = step / subSplitNumber;\n    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n    var splitLineDistance = splitLineModel.get('distance');\n    var unitX;\n    var unitY;\n    for (var i = 0; i <= splitNumber; i++) {\n      unitX = Math.cos(angle);\n      unitY = Math.sin(angle);\n      // Split line\n      if (splitLineModel.get('show')) {\n        var distance = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;\n        var splitLine = new Line/* default */.A({\n          shape: {\n            x1: unitX * (r - distance) + cx,\n            y1: unitY * (r - distance) + cy,\n            x2: unitX * (r - splitLineLen - distance) + cx,\n            y2: unitY * (r - splitLineLen - distance) + cy\n          },\n          style: splitLineStyle,\n          silent: true\n        });\n        if (splitLineStyle.stroke === 'auto') {\n          splitLine.setStyle({\n            stroke: getColor(i / splitNumber)\n          });\n        }\n        group.add(splitLine);\n      }\n      // Label\n      if (labelModel.get('show')) {\n        var distance = labelModel.get('distance') + splitLineDistance;\n        var label = formatLabel((0,number/* round */.LI)(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));\n        var autoColor = getColor(i / splitNumber);\n        var textStyleX = unitX * (r - splitLineLen - distance) + cx;\n        var textStyleY = unitY * (r - splitLineLen - distance) + cy;\n        var rotateType = labelModel.get('rotate');\n        var rotate = 0;\n        if (rotateType === 'radial') {\n          rotate = -angle + 2 * Math.PI;\n          if (rotate > Math.PI / 2) {\n            rotate += Math.PI;\n          }\n        } else if (rotateType === 'tangential') {\n          rotate = -angle - Math.PI / 2;\n        } else if ((0,util.isNumber)(rotateType)) {\n          rotate = rotateType * Math.PI / 180;\n        }\n        if (rotate === 0) {\n          group.add(new Text/* default */.Ay({\n            style: (0,labelStyle/* createTextStyle */.VB)(labelModel, {\n              text: label,\n              x: textStyleX,\n              y: textStyleY,\n              verticalAlign: unitY < -0.8 ? 'top' : unitY > 0.8 ? 'bottom' : 'middle',\n              align: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'\n            }, {\n              inheritColor: autoColor\n            }),\n            silent: true\n          }));\n        } else {\n          group.add(new Text/* default */.Ay({\n            style: (0,labelStyle/* createTextStyle */.VB)(labelModel, {\n              text: label,\n              x: textStyleX,\n              y: textStyleY,\n              verticalAlign: 'middle',\n              align: 'center'\n            }, {\n              inheritColor: autoColor\n            }),\n            silent: true,\n            originX: textStyleX,\n            originY: textStyleY,\n            rotation: rotate\n          }));\n        }\n      }\n      // Axis tick\n      if (tickModel.get('show') && i !== splitNumber) {\n        var distance = tickModel.get('distance');\n        distance = distance ? distance + axisLineWidth : axisLineWidth;\n        for (var j = 0; j <= subSplitNumber; j++) {\n          unitX = Math.cos(angle);\n          unitY = Math.sin(angle);\n          var tickLine = new Line/* default */.A({\n            shape: {\n              x1: unitX * (r - distance) + cx,\n              y1: unitY * (r - distance) + cy,\n              x2: unitX * (r - tickLen - distance) + cx,\n              y2: unitY * (r - tickLen - distance) + cy\n            },\n            silent: true,\n            style: tickLineStyle\n          });\n          if (tickLineStyle.stroke === 'auto') {\n            tickLine.setStyle({\n              stroke: getColor((i + j / subSplitNumber) / splitNumber)\n            });\n          }\n          group.add(tickLine);\n          angle += subStep;\n        }\n        angle -= subStep;\n      } else {\n        angle += step;\n      }\n    }\n  };\n  GaugeView.prototype._renderPointer = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var oldData = this._data;\n    var oldProgressData = this._progressEls;\n    var progressList = [];\n    var showPointer = seriesModel.get(['pointer', 'show']);\n    var progressModel = seriesModel.getModel('progress');\n    var showProgress = progressModel.get('show');\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var valueExtent = [minVal, maxVal];\n    var angleExtent = [startAngle, endAngle];\n    function createPointer(idx, angle) {\n      var itemModel = data.getItemModel(idx);\n      var pointerModel = itemModel.getModel('pointer');\n      var pointerWidth = (0,number/* parsePercent */.lo)(pointerModel.get('width'), posInfo.r);\n      var pointerLength = (0,number/* parsePercent */.lo)(pointerModel.get('length'), posInfo.r);\n      var pointerStr = seriesModel.get(['pointer', 'icon']);\n      var pointerOffset = pointerModel.get('offsetCenter');\n      var pointerOffsetX = (0,number/* parsePercent */.lo)(pointerOffset[0], posInfo.r);\n      var pointerOffsetY = (0,number/* parsePercent */.lo)(pointerOffset[1], posInfo.r);\n      var pointerKeepAspect = pointerModel.get('keepAspect');\n      var pointer;\n      // not exist icon type will be set 'rect'\n      if (pointerStr) {\n        pointer = (0,symbol/* createSymbol */.v5)(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);\n      } else {\n        pointer = new gauge_PointerPath({\n          shape: {\n            angle: -Math.PI / 2,\n            width: pointerWidth,\n            r: pointerLength,\n            x: pointerOffsetX,\n            y: pointerOffsetY\n          }\n        });\n      }\n      pointer.rotation = -(angle + Math.PI / 2);\n      pointer.x = posInfo.cx;\n      pointer.y = posInfo.cy;\n      return pointer;\n    }\n    function createProgress(idx, endAngle) {\n      var roundCap = progressModel.get('roundCap');\n      var ProgressPath = roundCap ? sausage/* default */.A : Sector/* default */.A;\n      var isOverlap = progressModel.get('overlap');\n      var progressWidth = isOverlap ? progressModel.get('width') : axisLineWidth / data.count();\n      var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;\n      var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;\n      var progress = new ProgressPath({\n        shape: {\n          startAngle: startAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: r0,\n          r: r\n        }\n      });\n      isOverlap && (progress.z2 = (0,number/* linearMap */.Cb)(data.get(valueDim, idx), [minVal, maxVal], [100, 0], true));\n      return progress;\n    }\n    if (showProgress || showPointer) {\n      data.diff(oldData).add(function (idx) {\n        var val = data.get(valueDim, idx);\n        if (showPointer) {\n          var pointer = createPointer(idx, startAngle);\n          // TODO hide pointer on NaN value?\n          basicTransition/* initProps */.LW(pointer, {\n            rotation: -((isNaN(+val) ? angleExtent[0] : (0,number/* linearMap */.Cb)(val, valueExtent, angleExtent, true)) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(idx, pointer);\n        }\n        if (showProgress) {\n          var progress = createProgress(idx, startAngle);\n          var isClip = progressModel.get('clip');\n          basicTransition/* initProps */.LW(progress, {\n            shape: {\n              endAngle: (0,number/* linearMap */.Cb)(val, valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress);\n          // Add data index and series index for indexing the data by element\n          // Useful in tooltip\n          (0,innerStore/* setCommonECData */.a)(seriesModel.seriesIndex, data.dataType, idx, progress);\n          progressList[idx] = progress;\n        }\n      }).update(function (newIdx, oldIdx) {\n        var val = data.get(valueDim, newIdx);\n        if (showPointer) {\n          var previousPointer = oldData.getItemGraphicEl(oldIdx);\n          var previousRotate = previousPointer ? previousPointer.rotation : startAngle;\n          var pointer = createPointer(newIdx, previousRotate);\n          pointer.rotation = previousRotate;\n          basicTransition/* updateProps */.oi(pointer, {\n            rotation: -((isNaN(+val) ? angleExtent[0] : (0,number/* linearMap */.Cb)(val, valueExtent, angleExtent, true)) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(newIdx, pointer);\n        }\n        if (showProgress) {\n          var previousProgress = oldProgressData[oldIdx];\n          var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;\n          var progress = createProgress(newIdx, previousEndAngle);\n          var isClip = progressModel.get('clip');\n          basicTransition/* updateProps */.oi(progress, {\n            shape: {\n              endAngle: (0,number/* linearMap */.Cb)(val, valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress);\n          // Add data index and series index for indexing the data by element\n          // Useful in tooltip\n          (0,innerStore/* setCommonECData */.a)(seriesModel.seriesIndex, data.dataType, newIdx, progress);\n          progressList[newIdx] = progress;\n        }\n      }).execute();\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var emphasisModel = itemModel.getModel('emphasis');\n        var focus = emphasisModel.get('focus');\n        var blurScope = emphasisModel.get('blurScope');\n        var emphasisDisabled = emphasisModel.get('disabled');\n        if (showPointer) {\n          var pointer = data.getItemGraphicEl(idx);\n          var symbolStyle = data.getItemVisual(idx, 'style');\n          var visualColor = symbolStyle.fill;\n          if (pointer instanceof Image/* default */.Ay) {\n            var pathStyle = pointer.style;\n            pointer.useStyle((0,util.extend)({\n              image: pathStyle.image,\n              x: pathStyle.x,\n              y: pathStyle.y,\n              width: pathStyle.width,\n              height: pathStyle.height\n            }, symbolStyle));\n          } else {\n            pointer.useStyle(symbolStyle);\n            pointer.type !== 'pointer' && pointer.setColor(visualColor);\n          }\n          pointer.setStyle(itemModel.getModel(['pointer', 'itemStyle']).getItemStyle());\n          if (pointer.style.fill === 'auto') {\n            pointer.setStyle('fill', getColor((0,number/* linearMap */.Cb)(data.get(valueDim, idx), valueExtent, [0, 1], true)));\n          }\n          pointer.z2EmphasisLift = 0;\n          (0,states/* setStatesStylesFromModel */.Mx)(pointer, itemModel);\n          (0,states/* toggleHoverEmphasis */.Lm)(pointer, focus, blurScope, emphasisDisabled);\n        }\n        if (showProgress) {\n          var progress = progressList[idx];\n          progress.useStyle(data.getItemVisual(idx, 'style'));\n          progress.setStyle(itemModel.getModel(['progress', 'itemStyle']).getItemStyle());\n          progress.z2EmphasisLift = 0;\n          (0,states/* setStatesStylesFromModel */.Mx)(progress, itemModel);\n          (0,states/* toggleHoverEmphasis */.Lm)(progress, focus, blurScope, emphasisDisabled);\n        }\n      });\n      this._progressEls = progressList;\n    }\n  };\n  GaugeView.prototype._renderAnchor = function (seriesModel, posInfo) {\n    var anchorModel = seriesModel.getModel('anchor');\n    var showAnchor = anchorModel.get('show');\n    if (showAnchor) {\n      var anchorSize = anchorModel.get('size');\n      var anchorType = anchorModel.get('icon');\n      var offsetCenter = anchorModel.get('offsetCenter');\n      var anchorKeepAspect = anchorModel.get('keepAspect');\n      var anchor = (0,symbol/* createSymbol */.v5)(anchorType, posInfo.cx - anchorSize / 2 + (0,number/* parsePercent */.lo)(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + (0,number/* parsePercent */.lo)(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);\n      anchor.z2 = anchorModel.get('showAbove') ? 1 : 0;\n      anchor.setStyle(anchorModel.getModel('itemStyle').getItemStyle());\n      this.group.add(anchor);\n    }\n  };\n  GaugeView.prototype._renderTitleAndDetail = function (seriesModel, ecModel, api, getColor, posInfo) {\n    var _this = this;\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var contentGroup = new Group/* default */.A();\n    var newTitleEls = [];\n    var newDetailEls = [];\n    var hasAnimation = seriesModel.isAnimationEnabled();\n    var showPointerAbove = seriesModel.get(['pointer', 'showAbove']);\n    data.diff(this._data).add(function (idx) {\n      newTitleEls[idx] = new Text/* default */.Ay({\n        silent: true\n      });\n      newDetailEls[idx] = new Text/* default */.Ay({\n        silent: true\n      });\n    }).update(function (idx, oldIdx) {\n      newTitleEls[idx] = _this._titleEls[oldIdx];\n      newDetailEls[idx] = _this._detailEls[oldIdx];\n    }).execute();\n    data.each(function (idx) {\n      var itemModel = data.getItemModel(idx);\n      var value = data.get(valueDim, idx);\n      var itemGroup = new Group/* default */.A();\n      var autoColor = getColor((0,number/* linearMap */.Cb)(value, [minVal, maxVal], [0, 1], true));\n      var itemTitleModel = itemModel.getModel('title');\n      if (itemTitleModel.get('show')) {\n        var titleOffsetCenter = itemTitleModel.get('offsetCenter');\n        var titleX = posInfo.cx + (0,number/* parsePercent */.lo)(titleOffsetCenter[0], posInfo.r);\n        var titleY = posInfo.cy + (0,number/* parsePercent */.lo)(titleOffsetCenter[1], posInfo.r);\n        var labelEl = newTitleEls[idx];\n        labelEl.attr({\n          z2: showPointerAbove ? 0 : 2,\n          style: (0,labelStyle/* createTextStyle */.VB)(itemTitleModel, {\n            x: titleX,\n            y: titleY,\n            text: data.getName(idx),\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: autoColor\n          })\n        });\n        itemGroup.add(labelEl);\n      }\n      var itemDetailModel = itemModel.getModel('detail');\n      if (itemDetailModel.get('show')) {\n        var detailOffsetCenter = itemDetailModel.get('offsetCenter');\n        var detailX = posInfo.cx + (0,number/* parsePercent */.lo)(detailOffsetCenter[0], posInfo.r);\n        var detailY = posInfo.cy + (0,number/* parsePercent */.lo)(detailOffsetCenter[1], posInfo.r);\n        var width = (0,number/* parsePercent */.lo)(itemDetailModel.get('width'), posInfo.r);\n        var height = (0,number/* parsePercent */.lo)(itemDetailModel.get('height'), posInfo.r);\n        var detailColor = seriesModel.get(['progress', 'show']) ? data.getItemVisual(idx, 'style').fill : autoColor;\n        var labelEl = newDetailEls[idx];\n        var formatter_1 = itemDetailModel.get('formatter');\n        labelEl.attr({\n          z2: showPointerAbove ? 0 : 2,\n          style: (0,labelStyle/* createTextStyle */.VB)(itemDetailModel, {\n            x: detailX,\n            y: detailY,\n            text: formatLabel(value, formatter_1),\n            width: isNaN(width) ? null : width,\n            height: isNaN(height) ? null : height,\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: detailColor\n          })\n        });\n        (0,labelStyle/* setLabelValueAnimation */.Oh)(labelEl, {\n          normal: itemDetailModel\n        }, value, function (value) {\n          return formatLabel(value, formatter_1);\n        });\n        hasAnimation && (0,labelStyle/* animateLabelValue */.xb)(labelEl, idx, data, seriesModel, {\n          getFormattedLabel: function (labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {\n            return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1);\n          }\n        });\n        itemGroup.add(labelEl);\n      }\n      contentGroup.add(itemGroup);\n    });\n    this.group.add(contentGroup);\n    this._titleEls = newTitleEls;\n    this._detailEls = newDetailEls;\n  };\n  GaugeView.type = 'gauge';\n  return GaugeView;\n}(Chart/* default */.A);\n/* harmony default export */ const gauge_GaugeView = (GaugeView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createSeriesDataSimply.js\nvar createSeriesDataSimply = __webpack_require__(72731);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n;// ./node_modules/echarts/lib/chart/gauge/GaugeSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar GaugeSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(GaugeSeriesModel, _super);\n  function GaugeSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = GaugeSeriesModel.type;\n    _this.visualStyleAccessPath = 'itemStyle';\n    return _this;\n  }\n  GaugeSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    return (0,createSeriesDataSimply/* default */.A)(this, ['value']);\n  };\n  GaugeSeriesModel.type = 'series.gauge';\n  GaugeSeriesModel.defaultOption = {\n    // zlevel: 0,\n    z: 2,\n    colorBy: 'data',\n    // 默认全局居中\n    center: ['50%', '50%'],\n    legendHoverLink: true,\n    radius: '75%',\n    startAngle: 225,\n    endAngle: -45,\n    clockwise: true,\n    // 最小值\n    min: 0,\n    // 最大值\n    max: 100,\n    // 分割段数，默认为10\n    splitNumber: 10,\n    // 坐标轴线\n    axisLine: {\n      // 默认显示，属性show控制显示与否\n      show: true,\n      roundCap: false,\n      lineStyle: {\n        color: [[1, '#E6EBF8']],\n        width: 10\n      }\n    },\n    // 坐标轴线\n    progress: {\n      // 默认显示，属性show控制显示与否\n      show: false,\n      overlap: true,\n      width: 10,\n      roundCap: false,\n      clip: true\n    },\n    // 分隔线\n    splitLine: {\n      // 默认显示，属性show控制显示与否\n      show: true,\n      // 属性length控制线长\n      length: 10,\n      distance: 10,\n      // 属性lineStyle（详见lineStyle）控制线条样式\n      lineStyle: {\n        color: '#63677A',\n        width: 3,\n        type: 'solid'\n      }\n    },\n    // 坐标轴小标记\n    axisTick: {\n      // 属性show控制显示与否，默认不显示\n      show: true,\n      // 每份split细分多少段\n      splitNumber: 5,\n      // 属性length控制线长\n      length: 6,\n      distance: 10,\n      // 属性lineStyle控制线条样式\n      lineStyle: {\n        color: '#63677A',\n        width: 1,\n        type: 'solid'\n      }\n    },\n    axisLabel: {\n      show: true,\n      distance: 15,\n      // formatter: null,\n      color: '#464646',\n      fontSize: 12,\n      rotate: 0\n    },\n    pointer: {\n      icon: null,\n      offsetCenter: [0, 0],\n      show: true,\n      showAbove: true,\n      length: '60%',\n      width: 6,\n      keepAspect: false\n    },\n    anchor: {\n      show: false,\n      showAbove: false,\n      size: 6,\n      icon: 'circle',\n      offsetCenter: [0, 0],\n      keepAspect: false,\n      itemStyle: {\n        color: '#fff',\n        borderWidth: 0,\n        borderColor: '#5470c6'\n      }\n    },\n    title: {\n      show: true,\n      // x, y，单位px\n      offsetCenter: [0, '20%'],\n      // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n      color: '#464646',\n      fontSize: 16,\n      valueAnimation: false\n    },\n    detail: {\n      show: true,\n      backgroundColor: 'rgba(0,0,0,0)',\n      borderWidth: 0,\n      borderColor: '#ccc',\n      width: 100,\n      height: null,\n      padding: [5, 10],\n      // x, y，单位px\n      offsetCenter: [0, '40%'],\n      // formatter: null,\n      // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n      color: '#464646',\n      fontSize: 30,\n      fontWeight: 'bold',\n      lineHeight: 30,\n      valueAnimation: false\n    }\n  };\n  return GaugeSeriesModel;\n}(Series/* default */.A);\n/* harmony default export */ const GaugeSeries = (GaugeSeriesModel);\n;// ./node_modules/echarts/lib/chart/gauge/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction install(registers) {\n  registers.registerChartView(gauge_GaugeView);\n  registers.registerSeriesModel(GaugeSeries);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEwMzAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMvaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dhdWdlL1BvaW50ZXJQYXRoLmpzP2M3MzMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dhdWdlL0dhdWdlVmlldy5qcz8xY2Y3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9nYXVnZS9HYXVnZVNlcmllcy5qcz8yZjY3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9nYXVnZS9pbnN0YWxsLmpzPzA5MDAiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBQYXRoIGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qcyc7XG52YXIgUG9pbnRlclNoYXBlID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9pbnRlclNoYXBlKCkge1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIHRoaXMud2lkdGggPSAxMDtcbiAgICB0aGlzLnIgPSAxMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gIH1cbiAgcmV0dXJuIFBvaW50ZXJTaGFwZTtcbn0oKTtcbnZhciBQb2ludGVyUGF0aCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQb2ludGVyUGF0aCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gUG9pbnRlclBhdGgob3B0cykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9ICdwb2ludGVyJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgUG9pbnRlclBhdGgucHJvdG90eXBlLmdldERlZmF1bHRTaGFwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50ZXJTaGFwZSgpO1xuICB9O1xuICBQb2ludGVyUGF0aC5wcm90b3R5cGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuICAgIHZhciBtYXRoU2luID0gTWF0aC5zaW47XG4gICAgdmFyIHIgPSBzaGFwZS5yO1xuICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgIHZhciBhbmdsZSA9IHNoYXBlLmFuZ2xlO1xuICAgIHZhciB4ID0gc2hhcGUueCAtIG1hdGhDb3MoYW5nbGUpICogd2lkdGggKiAod2lkdGggPj0gciAvIDMgPyAxIDogMik7XG4gICAgdmFyIHkgPSBzaGFwZS55IC0gbWF0aFNpbihhbmdsZSkgKiB3aWR0aCAqICh3aWR0aCA+PSByIC8gMyA/IDEgOiAyKTtcbiAgICBhbmdsZSA9IHNoYXBlLmFuZ2xlIC0gTWF0aC5QSSAvIDI7XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICBjdHgubGluZVRvKHNoYXBlLnggKyBtYXRoQ29zKGFuZ2xlKSAqIHdpZHRoLCBzaGFwZS55ICsgbWF0aFNpbihhbmdsZSkgKiB3aWR0aCk7XG4gICAgY3R4LmxpbmVUbyhzaGFwZS54ICsgbWF0aENvcyhzaGFwZS5hbmdsZSkgKiByLCBzaGFwZS55ICsgbWF0aFNpbihzaGFwZS5hbmdsZSkgKiByKTtcbiAgICBjdHgubGluZVRvKHNoYXBlLnggLSBtYXRoQ29zKGFuZ2xlKSAqIHdpZHRoLCBzaGFwZS55IC0gbWF0aFNpbihhbmdsZSkgKiB3aWR0aCk7XG4gICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgfTtcbiAgcmV0dXJuIFBvaW50ZXJQYXRoO1xufShQYXRoKTtcbmV4cG9ydCBkZWZhdWx0IFBvaW50ZXJQYXRoOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgUG9pbnRlclBhdGggZnJvbSAnLi9Qb2ludGVyUGF0aC5qcyc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwsIHRvZ2dsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVUZXh0U3R5bGUsIHNldExhYmVsVmFsdWVBbmltYXRpb24sIGFuaW1hdGVMYWJlbFZhbHVlIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQuanMnO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50LCByb3VuZCwgbGluZWFyTWFwIH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IFNhdXNhZ2UgZnJvbSAnLi4vLi4vdXRpbC9zaGFwZS9zYXVzYWdlLmpzJztcbmltcG9ydCB7IGNyZWF0ZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvc3ltYm9sLmpzJztcbmltcG9ydCBaUkltYWdlIGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanMnO1xuaW1wb3J0IHsgZXh0ZW5kLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGVhY2ggfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgc2V0Q29tbW9uRUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZUFyY0FuZ2xlcyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzJztcbmZ1bmN0aW9uIHBhcnNlUG9zaXRpb24oc2VyaWVzTW9kZWwsIGFwaSkge1xuICB2YXIgY2VudGVyID0gc2VyaWVzTW9kZWwuZ2V0KCdjZW50ZXInKTtcbiAgdmFyIHdpZHRoID0gYXBpLmdldFdpZHRoKCk7XG4gIHZhciBoZWlnaHQgPSBhcGkuZ2V0SGVpZ2h0KCk7XG4gIHZhciBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gIHZhciBjeCA9IHBhcnNlUGVyY2VudChjZW50ZXJbMF0sIGFwaS5nZXRXaWR0aCgpKTtcbiAgdmFyIGN5ID0gcGFyc2VQZXJjZW50KGNlbnRlclsxXSwgYXBpLmdldEhlaWdodCgpKTtcbiAgdmFyIHIgPSBwYXJzZVBlcmNlbnQoc2VyaWVzTW9kZWwuZ2V0KCdyYWRpdXMnKSwgc2l6ZSAvIDIpO1xuICByZXR1cm4ge1xuICAgIGN4OiBjeCxcbiAgICBjeTogY3ksXG4gICAgcjogclxuICB9O1xufVxuZnVuY3Rpb24gZm9ybWF0TGFiZWwodmFsdWUsIGxhYmVsRm9ybWF0dGVyKSB7XG4gIHZhciBsYWJlbCA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlICsgJyc7XG4gIGlmIChsYWJlbEZvcm1hdHRlcikge1xuICAgIGlmIChpc1N0cmluZyhsYWJlbEZvcm1hdHRlcikpIHtcbiAgICAgIGxhYmVsID0gbGFiZWxGb3JtYXR0ZXIucmVwbGFjZSgne3ZhbHVlfScsIGxhYmVsKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24obGFiZWxGb3JtYXR0ZXIpKSB7XG4gICAgICBsYWJlbCA9IGxhYmVsRm9ybWF0dGVyKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxhYmVsO1xufVxudmFyIEdhdWdlVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhHYXVnZVZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEdhdWdlVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gR2F1Z2VWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEdhdWdlVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHZhciBjb2xvckxpc3QgPSBzZXJpZXNNb2RlbC5nZXQoWydheGlzTGluZScsICdsaW5lU3R5bGUnLCAnY29sb3InXSk7XG4gICAgdmFyIHBvc0luZm8gPSBwYXJzZVBvc2l0aW9uKHNlcmllc01vZGVsLCBhcGkpO1xuICAgIHRoaXMuX3JlbmRlck1haW4oc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgY29sb3JMaXN0LCBwb3NJbmZvKTtcbiAgICB0aGlzLl9kYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICB9O1xuICBHYXVnZVZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcbiAgR2F1Z2VWaWV3LnByb3RvdHlwZS5fcmVuZGVyTWFpbiA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBjb2xvckxpc3QsIHBvc0luZm8pIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBjbG9ja3dpc2UgPSBzZXJpZXNNb2RlbC5nZXQoJ2Nsb2Nrd2lzZScpO1xuICAgIHZhciBzdGFydEFuZ2xlID0gLXNlcmllc01vZGVsLmdldCgnc3RhcnRBbmdsZScpIC8gMTgwICogTWF0aC5QSTtcbiAgICB2YXIgZW5kQW5nbGUgPSAtc2VyaWVzTW9kZWwuZ2V0KCdlbmRBbmdsZScpIC8gMTgwICogTWF0aC5QSTtcbiAgICB2YXIgYXhpc0xpbmVNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdheGlzTGluZScpO1xuICAgIHZhciByb3VuZENhcCA9IGF4aXNMaW5lTW9kZWwuZ2V0KCdyb3VuZENhcCcpO1xuICAgIHZhciBNYWluUGF0aCA9IHJvdW5kQ2FwID8gU2F1c2FnZSA6IGdyYXBoaWMuU2VjdG9yO1xuICAgIHZhciBzaG93QXhpcyA9IGF4aXNMaW5lTW9kZWwuZ2V0KCdzaG93Jyk7XG4gICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gYXhpc0xpbmVNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJyk7XG4gICAgdmFyIGF4aXNMaW5lV2lkdGggPSBsaW5lU3R5bGVNb2RlbC5nZXQoJ3dpZHRoJyk7XG4gICAgdmFyIGFuZ2xlcyA9IFtzdGFydEFuZ2xlLCBlbmRBbmdsZV07XG4gICAgbm9ybWFsaXplQXJjQW5nbGVzKGFuZ2xlcywgIWNsb2Nrd2lzZSk7XG4gICAgc3RhcnRBbmdsZSA9IGFuZ2xlc1swXTtcbiAgICBlbmRBbmdsZSA9IGFuZ2xlc1sxXTtcbiAgICB2YXIgYW5nbGVSYW5nZVNwYW4gPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gICAgdmFyIHByZXZFbmRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgdmFyIHNlY3RvcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgc2hvd0F4aXMgJiYgaSA8IGNvbG9yTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gQ2xhbXBcbiAgICAgIHZhciBwZXJjZW50ID0gTWF0aC5taW4oTWF0aC5tYXgoY29sb3JMaXN0W2ldWzBdLCAwKSwgMSk7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBhbmdsZVJhbmdlU3BhbiAqIHBlcmNlbnQ7XG4gICAgICB2YXIgc2VjdG9yID0gbmV3IE1haW5QYXRoKHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICBzdGFydEFuZ2xlOiBwcmV2RW5kQW5nbGUsXG4gICAgICAgICAgZW5kQW5nbGU6IGVuZEFuZ2xlLFxuICAgICAgICAgIGN4OiBwb3NJbmZvLmN4LFxuICAgICAgICAgIGN5OiBwb3NJbmZvLmN5LFxuICAgICAgICAgIGNsb2Nrd2lzZTogY2xvY2t3aXNlLFxuICAgICAgICAgIHIwOiBwb3NJbmZvLnIgLSBheGlzTGluZVdpZHRoLFxuICAgICAgICAgIHI6IHBvc0luZm8uclxuICAgICAgICB9LFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgc2VjdG9yLnNldFN0eWxlKHtcbiAgICAgICAgZmlsbDogY29sb3JMaXN0W2ldWzFdXG4gICAgICB9KTtcbiAgICAgIHNlY3Rvci5zZXRTdHlsZShsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoXG4gICAgICAvLyBCZWNhdXNlIHdlIHVzZSBzZWN0b3IgdG8gc2ltdWxhdGUgYXJjXG4gICAgICAvLyBzbyB0aGUgcHJvcGVydGllcyBmb3Igc3Ryb2tpbmcgYXJlIHVzZWxlc3NcbiAgICAgIFsnY29sb3InLCAnd2lkdGgnXSkpO1xuICAgICAgc2VjdG9ycy5wdXNoKHNlY3Rvcik7XG4gICAgICBwcmV2RW5kQW5nbGUgPSBlbmRBbmdsZTtcbiAgICB9XG4gICAgc2VjdG9ycy5yZXZlcnNlKCk7XG4gICAgZWFjaChzZWN0b3JzLCBmdW5jdGlvbiAoc2VjdG9yKSB7XG4gICAgICByZXR1cm4gZ3JvdXAuYWRkKHNlY3Rvcik7XG4gICAgfSk7XG4gICAgdmFyIGdldENvbG9yID0gZnVuY3Rpb24gKHBlcmNlbnQpIHtcbiAgICAgIC8vIExlc3MgdGhhbiAwXG4gICAgICBpZiAocGVyY2VudCA8PSAwKSB7XG4gICAgICAgIHJldHVybiBjb2xvckxpc3RbMF1bMV07XG4gICAgICB9XG4gICAgICB2YXIgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xvckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNvbG9yTGlzdFtpXVswXSA+PSBwZXJjZW50ICYmIChpID09PSAwID8gMCA6IGNvbG9yTGlzdFtpIC0gMV1bMF0pIDwgcGVyY2VudCkge1xuICAgICAgICAgIHJldHVybiBjb2xvckxpc3RbaV1bMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE1vcmUgdGhhbiAxXG4gICAgICByZXR1cm4gY29sb3JMaXN0W2kgLSAxXVsxXTtcbiAgICB9O1xuICAgIHRoaXMuX3JlbmRlclRpY2tzKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIGdldENvbG9yLCBwb3NJbmZvLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2xvY2t3aXNlLCBheGlzTGluZVdpZHRoKTtcbiAgICB0aGlzLl9yZW5kZXJUaXRsZUFuZERldGFpbChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBnZXRDb2xvciwgcG9zSW5mbyk7XG4gICAgdGhpcy5fcmVuZGVyQW5jaG9yKHNlcmllc01vZGVsLCBwb3NJbmZvKTtcbiAgICB0aGlzLl9yZW5kZXJQb2ludGVyKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIGdldENvbG9yLCBwb3NJbmZvLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2xvY2t3aXNlLCBheGlzTGluZVdpZHRoKTtcbiAgfTtcbiAgR2F1Z2VWaWV3LnByb3RvdHlwZS5fcmVuZGVyVGlja3MgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgZ2V0Q29sb3IsIHBvc0luZm8sIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2UsIGF4aXNMaW5lV2lkdGgpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBjeCA9IHBvc0luZm8uY3g7XG4gICAgdmFyIGN5ID0gcG9zSW5mby5jeTtcbiAgICB2YXIgciA9IHBvc0luZm8ucjtcbiAgICB2YXIgbWluVmFsID0gK3Nlcmllc01vZGVsLmdldCgnbWluJyk7XG4gICAgdmFyIG1heFZhbCA9ICtzZXJpZXNNb2RlbC5nZXQoJ21heCcpO1xuICAgIHZhciBzcGxpdExpbmVNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdzcGxpdExpbmUnKTtcbiAgICB2YXIgdGlja01vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNUaWNrJyk7XG4gICAgdmFyIGxhYmVsTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnYXhpc0xhYmVsJyk7XG4gICAgdmFyIHNwbGl0TnVtYmVyID0gc2VyaWVzTW9kZWwuZ2V0KCdzcGxpdE51bWJlcicpO1xuICAgIHZhciBzdWJTcGxpdE51bWJlciA9IHRpY2tNb2RlbC5nZXQoJ3NwbGl0TnVtYmVyJyk7XG4gICAgdmFyIHNwbGl0TGluZUxlbiA9IHBhcnNlUGVyY2VudChzcGxpdExpbmVNb2RlbC5nZXQoJ2xlbmd0aCcpLCByKTtcbiAgICB2YXIgdGlja0xlbiA9IHBhcnNlUGVyY2VudCh0aWNrTW9kZWwuZ2V0KCdsZW5ndGgnKSwgcik7XG4gICAgdmFyIGFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICB2YXIgc3RlcCA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpIC8gc3BsaXROdW1iZXI7XG4gICAgdmFyIHN1YlN0ZXAgPSBzdGVwIC8gc3ViU3BsaXROdW1iZXI7XG4gICAgdmFyIHNwbGl0TGluZVN0eWxlID0gc3BsaXRMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpO1xuICAgIHZhciB0aWNrTGluZVN0eWxlID0gdGlja01vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKTtcbiAgICB2YXIgc3BsaXRMaW5lRGlzdGFuY2UgPSBzcGxpdExpbmVNb2RlbC5nZXQoJ2Rpc3RhbmNlJyk7XG4gICAgdmFyIHVuaXRYO1xuICAgIHZhciB1bml0WTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBzcGxpdE51bWJlcjsgaSsrKSB7XG4gICAgICB1bml0WCA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHVuaXRZID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgLy8gU3BsaXQgbGluZVxuICAgICAgaWYgKHNwbGl0TGluZU1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHNwbGl0TGluZURpc3RhbmNlID8gc3BsaXRMaW5lRGlzdGFuY2UgKyBheGlzTGluZVdpZHRoIDogYXhpc0xpbmVXaWR0aDtcbiAgICAgICAgdmFyIHNwbGl0TGluZSA9IG5ldyBncmFwaGljLkxpbmUoe1xuICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICB4MTogdW5pdFggKiAociAtIGRpc3RhbmNlKSArIGN4LFxuICAgICAgICAgICAgeTE6IHVuaXRZICogKHIgLSBkaXN0YW5jZSkgKyBjeSxcbiAgICAgICAgICAgIHgyOiB1bml0WCAqIChyIC0gc3BsaXRMaW5lTGVuIC0gZGlzdGFuY2UpICsgY3gsXG4gICAgICAgICAgICB5MjogdW5pdFkgKiAociAtIHNwbGl0TGluZUxlbiAtIGRpc3RhbmNlKSArIGN5XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHlsZTogc3BsaXRMaW5lU3R5bGUsXG4gICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3BsaXRMaW5lU3R5bGUuc3Ryb2tlID09PSAnYXV0bycpIHtcbiAgICAgICAgICBzcGxpdExpbmUuc2V0U3R5bGUoe1xuICAgICAgICAgICAgc3Ryb2tlOiBnZXRDb2xvcihpIC8gc3BsaXROdW1iZXIpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXAuYWRkKHNwbGl0TGluZSk7XG4gICAgICB9XG4gICAgICAvLyBMYWJlbFxuICAgICAgaWYgKGxhYmVsTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gbGFiZWxNb2RlbC5nZXQoJ2Rpc3RhbmNlJykgKyBzcGxpdExpbmVEaXN0YW5jZTtcbiAgICAgICAgdmFyIGxhYmVsID0gZm9ybWF0TGFiZWwocm91bmQoaSAvIHNwbGl0TnVtYmVyICogKG1heFZhbCAtIG1pblZhbCkgKyBtaW5WYWwpLCBsYWJlbE1vZGVsLmdldCgnZm9ybWF0dGVyJykpO1xuICAgICAgICB2YXIgYXV0b0NvbG9yID0gZ2V0Q29sb3IoaSAvIHNwbGl0TnVtYmVyKTtcbiAgICAgICAgdmFyIHRleHRTdHlsZVggPSB1bml0WCAqIChyIC0gc3BsaXRMaW5lTGVuIC0gZGlzdGFuY2UpICsgY3g7XG4gICAgICAgIHZhciB0ZXh0U3R5bGVZID0gdW5pdFkgKiAociAtIHNwbGl0TGluZUxlbiAtIGRpc3RhbmNlKSArIGN5O1xuICAgICAgICB2YXIgcm90YXRlVHlwZSA9IGxhYmVsTW9kZWwuZ2V0KCdyb3RhdGUnKTtcbiAgICAgICAgdmFyIHJvdGF0ZSA9IDA7XG4gICAgICAgIGlmIChyb3RhdGVUeXBlID09PSAncmFkaWFsJykge1xuICAgICAgICAgIHJvdGF0ZSA9IC1hbmdsZSArIDIgKiBNYXRoLlBJO1xuICAgICAgICAgIGlmIChyb3RhdGUgPiBNYXRoLlBJIC8gMikge1xuICAgICAgICAgICAgcm90YXRlICs9IE1hdGguUEk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJvdGF0ZVR5cGUgPT09ICd0YW5nZW50aWFsJykge1xuICAgICAgICAgIHJvdGF0ZSA9IC1hbmdsZSAtIE1hdGguUEkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHJvdGF0ZVR5cGUpKSB7XG4gICAgICAgICAgcm90YXRlID0gcm90YXRlVHlwZSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdGF0ZSA9PT0gMCkge1xuICAgICAgICAgIGdyb3VwLmFkZChuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUobGFiZWxNb2RlbCwge1xuICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgeDogdGV4dFN0eWxlWCxcbiAgICAgICAgICAgICAgeTogdGV4dFN0eWxlWSxcbiAgICAgICAgICAgICAgdmVydGljYWxBbGlnbjogdW5pdFkgPCAtMC44ID8gJ3RvcCcgOiB1bml0WSA+IDAuOCA/ICdib3R0b20nIDogJ21pZGRsZScsXG4gICAgICAgICAgICAgIGFsaWduOiB1bml0WCA8IC0wLjQgPyAnbGVmdCcgOiB1bml0WCA+IDAuNCA/ICdyaWdodCcgOiAnY2VudGVyJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBpbmhlcml0Q29sb3I6IGF1dG9Db2xvclxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JvdXAuYWRkKG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgICAgICAgc3R5bGU6IGNyZWF0ZVRleHRTdHlsZShsYWJlbE1vZGVsLCB7XG4gICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICB4OiB0ZXh0U3R5bGVYLFxuICAgICAgICAgICAgICB5OiB0ZXh0U3R5bGVZLFxuICAgICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgYWxpZ246ICdjZW50ZXInXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGluaGVyaXRDb2xvcjogYXV0b0NvbG9yXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgIG9yaWdpblg6IHRleHRTdHlsZVgsXG4gICAgICAgICAgICBvcmlnaW5ZOiB0ZXh0U3R5bGVZLFxuICAgICAgICAgICAgcm90YXRpb246IHJvdGF0ZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQXhpcyB0aWNrXG4gICAgICBpZiAodGlja01vZGVsLmdldCgnc2hvdycpICYmIGkgIT09IHNwbGl0TnVtYmVyKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHRpY2tNb2RlbC5nZXQoJ2Rpc3RhbmNlJyk7XG4gICAgICAgIGRpc3RhbmNlID0gZGlzdGFuY2UgPyBkaXN0YW5jZSArIGF4aXNMaW5lV2lkdGggOiBheGlzTGluZVdpZHRoO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBzdWJTcGxpdE51bWJlcjsgaisrKSB7XG4gICAgICAgICAgdW5pdFggPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgdW5pdFkgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgdmFyIHRpY2tMaW5lID0gbmV3IGdyYXBoaWMuTGluZSh7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICB4MTogdW5pdFggKiAociAtIGRpc3RhbmNlKSArIGN4LFxuICAgICAgICAgICAgICB5MTogdW5pdFkgKiAociAtIGRpc3RhbmNlKSArIGN5LFxuICAgICAgICAgICAgICB4MjogdW5pdFggKiAociAtIHRpY2tMZW4gLSBkaXN0YW5jZSkgKyBjeCxcbiAgICAgICAgICAgICAgeTI6IHVuaXRZICogKHIgLSB0aWNrTGVuIC0gZGlzdGFuY2UpICsgY3lcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICBzdHlsZTogdGlja0xpbmVTdHlsZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0aWNrTGluZVN0eWxlLnN0cm9rZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aWNrTGluZS5zZXRTdHlsZSh7XG4gICAgICAgICAgICAgIHN0cm9rZTogZ2V0Q29sb3IoKGkgKyBqIC8gc3ViU3BsaXROdW1iZXIpIC8gc3BsaXROdW1iZXIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ3JvdXAuYWRkKHRpY2tMaW5lKTtcbiAgICAgICAgICBhbmdsZSArPSBzdWJTdGVwO1xuICAgICAgICB9XG4gICAgICAgIGFuZ2xlIC09IHN1YlN0ZXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmdsZSArPSBzdGVwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgR2F1Z2VWaWV3LnByb3RvdHlwZS5fcmVuZGVyUG9pbnRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBnZXRDb2xvciwgcG9zSW5mbywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSwgYXhpc0xpbmVXaWR0aCkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBvbGRQcm9ncmVzc0RhdGEgPSB0aGlzLl9wcm9ncmVzc0VscztcbiAgICB2YXIgcHJvZ3Jlc3NMaXN0ID0gW107XG4gICAgdmFyIHNob3dQb2ludGVyID0gc2VyaWVzTW9kZWwuZ2V0KFsncG9pbnRlcicsICdzaG93J10pO1xuICAgIHZhciBwcm9ncmVzc01vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ3Byb2dyZXNzJyk7XG4gICAgdmFyIHNob3dQcm9ncmVzcyA9IHByb2dyZXNzTW9kZWwuZ2V0KCdzaG93Jyk7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHZhbHVlRGltID0gZGF0YS5tYXBEaW1lbnNpb24oJ3ZhbHVlJyk7XG4gICAgdmFyIG1pblZhbCA9ICtzZXJpZXNNb2RlbC5nZXQoJ21pbicpO1xuICAgIHZhciBtYXhWYWwgPSArc2VyaWVzTW9kZWwuZ2V0KCdtYXgnKTtcbiAgICB2YXIgdmFsdWVFeHRlbnQgPSBbbWluVmFsLCBtYXhWYWxdO1xuICAgIHZhciBhbmdsZUV4dGVudCA9IFtzdGFydEFuZ2xlLCBlbmRBbmdsZV07XG4gICAgZnVuY3Rpb24gY3JlYXRlUG9pbnRlcihpZHgsIGFuZ2xlKSB7XG4gICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgIHZhciBwb2ludGVyTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ3BvaW50ZXInKTtcbiAgICAgIHZhciBwb2ludGVyV2lkdGggPSBwYXJzZVBlcmNlbnQocG9pbnRlck1vZGVsLmdldCgnd2lkdGgnKSwgcG9zSW5mby5yKTtcbiAgICAgIHZhciBwb2ludGVyTGVuZ3RoID0gcGFyc2VQZXJjZW50KHBvaW50ZXJNb2RlbC5nZXQoJ2xlbmd0aCcpLCBwb3NJbmZvLnIpO1xuICAgICAgdmFyIHBvaW50ZXJTdHIgPSBzZXJpZXNNb2RlbC5nZXQoWydwb2ludGVyJywgJ2ljb24nXSk7XG4gICAgICB2YXIgcG9pbnRlck9mZnNldCA9IHBvaW50ZXJNb2RlbC5nZXQoJ29mZnNldENlbnRlcicpO1xuICAgICAgdmFyIHBvaW50ZXJPZmZzZXRYID0gcGFyc2VQZXJjZW50KHBvaW50ZXJPZmZzZXRbMF0sIHBvc0luZm8ucik7XG4gICAgICB2YXIgcG9pbnRlck9mZnNldFkgPSBwYXJzZVBlcmNlbnQocG9pbnRlck9mZnNldFsxXSwgcG9zSW5mby5yKTtcbiAgICAgIHZhciBwb2ludGVyS2VlcEFzcGVjdCA9IHBvaW50ZXJNb2RlbC5nZXQoJ2tlZXBBc3BlY3QnKTtcbiAgICAgIHZhciBwb2ludGVyO1xuICAgICAgLy8gbm90IGV4aXN0IGljb24gdHlwZSB3aWxsIGJlIHNldCAncmVjdCdcbiAgICAgIGlmIChwb2ludGVyU3RyKSB7XG4gICAgICAgIHBvaW50ZXIgPSBjcmVhdGVTeW1ib2wocG9pbnRlclN0ciwgcG9pbnRlck9mZnNldFggLSBwb2ludGVyV2lkdGggLyAyLCBwb2ludGVyT2Zmc2V0WSAtIHBvaW50ZXJMZW5ndGgsIHBvaW50ZXJXaWR0aCwgcG9pbnRlckxlbmd0aCwgbnVsbCwgcG9pbnRlcktlZXBBc3BlY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnRlciA9IG5ldyBQb2ludGVyUGF0aCh7XG4gICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIGFuZ2xlOiAtTWF0aC5QSSAvIDIsXG4gICAgICAgICAgICB3aWR0aDogcG9pbnRlcldpZHRoLFxuICAgICAgICAgICAgcjogcG9pbnRlckxlbmd0aCxcbiAgICAgICAgICAgIHg6IHBvaW50ZXJPZmZzZXRYLFxuICAgICAgICAgICAgeTogcG9pbnRlck9mZnNldFlcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcG9pbnRlci5yb3RhdGlvbiA9IC0oYW5nbGUgKyBNYXRoLlBJIC8gMik7XG4gICAgICBwb2ludGVyLnggPSBwb3NJbmZvLmN4O1xuICAgICAgcG9pbnRlci55ID0gcG9zSW5mby5jeTtcbiAgICAgIHJldHVybiBwb2ludGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9ncmVzcyhpZHgsIGVuZEFuZ2xlKSB7XG4gICAgICB2YXIgcm91bmRDYXAgPSBwcm9ncmVzc01vZGVsLmdldCgncm91bmRDYXAnKTtcbiAgICAgIHZhciBQcm9ncmVzc1BhdGggPSByb3VuZENhcCA/IFNhdXNhZ2UgOiBncmFwaGljLlNlY3RvcjtcbiAgICAgIHZhciBpc092ZXJsYXAgPSBwcm9ncmVzc01vZGVsLmdldCgnb3ZlcmxhcCcpO1xuICAgICAgdmFyIHByb2dyZXNzV2lkdGggPSBpc092ZXJsYXAgPyBwcm9ncmVzc01vZGVsLmdldCgnd2lkdGgnKSA6IGF4aXNMaW5lV2lkdGggLyBkYXRhLmNvdW50KCk7XG4gICAgICB2YXIgcjAgPSBpc092ZXJsYXAgPyBwb3NJbmZvLnIgLSBwcm9ncmVzc1dpZHRoIDogcG9zSW5mby5yIC0gKGlkeCArIDEpICogcHJvZ3Jlc3NXaWR0aDtcbiAgICAgIHZhciByID0gaXNPdmVybGFwID8gcG9zSW5mby5yIDogcG9zSW5mby5yIC0gaWR4ICogcHJvZ3Jlc3NXaWR0aDtcbiAgICAgIHZhciBwcm9ncmVzcyA9IG5ldyBQcm9ncmVzc1BhdGgoe1xuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgZW5kQW5nbGU6IGVuZEFuZ2xlLFxuICAgICAgICAgIGN4OiBwb3NJbmZvLmN4LFxuICAgICAgICAgIGN5OiBwb3NJbmZvLmN5LFxuICAgICAgICAgIGNsb2Nrd2lzZTogY2xvY2t3aXNlLFxuICAgICAgICAgIHIwOiByMCxcbiAgICAgICAgICByOiByXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaXNPdmVybGFwICYmIChwcm9ncmVzcy56MiA9IGxpbmVhck1hcChkYXRhLmdldCh2YWx1ZURpbSwgaWR4KSwgW21pblZhbCwgbWF4VmFsXSwgWzEwMCwgMF0sIHRydWUpKTtcbiAgICAgIHJldHVybiBwcm9ncmVzcztcbiAgICB9XG4gICAgaWYgKHNob3dQcm9ncmVzcyB8fCBzaG93UG9pbnRlcikge1xuICAgICAgZGF0YS5kaWZmKG9sZERhdGEpLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHZhciB2YWwgPSBkYXRhLmdldCh2YWx1ZURpbSwgaWR4KTtcbiAgICAgICAgaWYgKHNob3dQb2ludGVyKSB7XG4gICAgICAgICAgdmFyIHBvaW50ZXIgPSBjcmVhdGVQb2ludGVyKGlkeCwgc3RhcnRBbmdsZSk7XG4gICAgICAgICAgLy8gVE9ETyBoaWRlIHBvaW50ZXIgb24gTmFOIHZhbHVlP1xuICAgICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKHBvaW50ZXIsIHtcbiAgICAgICAgICAgIHJvdGF0aW9uOiAtKChpc05hTigrdmFsKSA/IGFuZ2xlRXh0ZW50WzBdIDogbGluZWFyTWFwKHZhbCwgdmFsdWVFeHRlbnQsIGFuZ2xlRXh0ZW50LCB0cnVlKSkgKyBNYXRoLlBJIC8gMilcbiAgICAgICAgICB9LCBzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgZ3JvdXAuYWRkKHBvaW50ZXIpO1xuICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIHBvaW50ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG93UHJvZ3Jlc3MpIHtcbiAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBjcmVhdGVQcm9ncmVzcyhpZHgsIHN0YXJ0QW5nbGUpO1xuICAgICAgICAgIHZhciBpc0NsaXAgPSBwcm9ncmVzc01vZGVsLmdldCgnY2xpcCcpO1xuICAgICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKHByb2dyZXNzLCB7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICBlbmRBbmdsZTogbGluZWFyTWFwKHZhbCwgdmFsdWVFeHRlbnQsIGFuZ2xlRXh0ZW50LCBpc0NsaXApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuICAgICAgICAgIGdyb3VwLmFkZChwcm9ncmVzcyk7XG4gICAgICAgICAgLy8gQWRkIGRhdGEgaW5kZXggYW5kIHNlcmllcyBpbmRleCBmb3IgaW5kZXhpbmcgdGhlIGRhdGEgYnkgZWxlbWVudFxuICAgICAgICAgIC8vIFVzZWZ1bCBpbiB0b29sdGlwXG4gICAgICAgICAgc2V0Q29tbW9uRUNEYXRhKHNlcmllc01vZGVsLnNlcmllc0luZGV4LCBkYXRhLmRhdGFUeXBlLCBpZHgsIHByb2dyZXNzKTtcbiAgICAgICAgICBwcm9ncmVzc0xpc3RbaWR4XSA9IHByb2dyZXNzO1xuICAgICAgICB9XG4gICAgICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICAgIHZhciB2YWwgPSBkYXRhLmdldCh2YWx1ZURpbSwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHNob3dQb2ludGVyKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzUG9pbnRlciA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuICAgICAgICAgIHZhciBwcmV2aW91c1JvdGF0ZSA9IHByZXZpb3VzUG9pbnRlciA/IHByZXZpb3VzUG9pbnRlci5yb3RhdGlvbiA6IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgdmFyIHBvaW50ZXIgPSBjcmVhdGVQb2ludGVyKG5ld0lkeCwgcHJldmlvdXNSb3RhdGUpO1xuICAgICAgICAgIHBvaW50ZXIucm90YXRpb24gPSBwcmV2aW91c1JvdGF0ZTtcbiAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvaW50ZXIsIHtcbiAgICAgICAgICAgIHJvdGF0aW9uOiAtKChpc05hTigrdmFsKSA/IGFuZ2xlRXh0ZW50WzBdIDogbGluZWFyTWFwKHZhbCwgdmFsdWVFeHRlbnQsIGFuZ2xlRXh0ZW50LCB0cnVlKSkgKyBNYXRoLlBJIC8gMilcbiAgICAgICAgICB9LCBzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgZ3JvdXAuYWRkKHBvaW50ZXIpO1xuICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIHBvaW50ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG93UHJvZ3Jlc3MpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNQcm9ncmVzcyA9IG9sZFByb2dyZXNzRGF0YVtvbGRJZHhdO1xuICAgICAgICAgIHZhciBwcmV2aW91c0VuZEFuZ2xlID0gcHJldmlvdXNQcm9ncmVzcyA/IHByZXZpb3VzUHJvZ3Jlc3Muc2hhcGUuZW5kQW5nbGUgOiBzdGFydEFuZ2xlO1xuICAgICAgICAgIHZhciBwcm9ncmVzcyA9IGNyZWF0ZVByb2dyZXNzKG5ld0lkeCwgcHJldmlvdXNFbmRBbmdsZSk7XG4gICAgICAgICAgdmFyIGlzQ2xpcCA9IHByb2dyZXNzTW9kZWwuZ2V0KCdjbGlwJyk7XG4gICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhwcm9ncmVzcywge1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgZW5kQW5nbGU6IGxpbmVhck1hcCh2YWwsIHZhbHVlRXh0ZW50LCBhbmdsZUV4dGVudCwgaXNDbGlwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgICAgICBncm91cC5hZGQocHJvZ3Jlc3MpO1xuICAgICAgICAgIC8vIEFkZCBkYXRhIGluZGV4IGFuZCBzZXJpZXMgaW5kZXggZm9yIGluZGV4aW5nIHRoZSBkYXRhIGJ5IGVsZW1lbnRcbiAgICAgICAgICAvLyBVc2VmdWwgaW4gdG9vbHRpcFxuICAgICAgICAgIHNldENvbW1vbkVDRGF0YShzZXJpZXNNb2RlbC5zZXJpZXNJbmRleCwgZGF0YS5kYXRhVHlwZSwgbmV3SWR4LCBwcm9ncmVzcyk7XG4gICAgICAgICAgcHJvZ3Jlc3NMaXN0W25ld0lkeF0gPSBwcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgfSkuZXhlY3V0ZSgpO1xuICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgIHZhciBlbXBoYXNpc01vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdlbXBoYXNpcycpO1xuICAgICAgICB2YXIgZm9jdXMgPSBlbXBoYXNpc01vZGVsLmdldCgnZm9jdXMnKTtcbiAgICAgICAgdmFyIGJsdXJTY29wZSA9IGVtcGhhc2lzTW9kZWwuZ2V0KCdibHVyU2NvcGUnKTtcbiAgICAgICAgdmFyIGVtcGhhc2lzRGlzYWJsZWQgPSBlbXBoYXNpc01vZGVsLmdldCgnZGlzYWJsZWQnKTtcbiAgICAgICAgaWYgKHNob3dQb2ludGVyKSB7XG4gICAgICAgICAgdmFyIHBvaW50ZXIgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoaWR4KTtcbiAgICAgICAgICB2YXIgc3ltYm9sU3R5bGUgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3R5bGUnKTtcbiAgICAgICAgICB2YXIgdmlzdWFsQ29sb3IgPSBzeW1ib2xTdHlsZS5maWxsO1xuICAgICAgICAgIGlmIChwb2ludGVyIGluc3RhbmNlb2YgWlJJbWFnZSkge1xuICAgICAgICAgICAgdmFyIHBhdGhTdHlsZSA9IHBvaW50ZXIuc3R5bGU7XG4gICAgICAgICAgICBwb2ludGVyLnVzZVN0eWxlKGV4dGVuZCh7XG4gICAgICAgICAgICAgIGltYWdlOiBwYXRoU3R5bGUuaW1hZ2UsXG4gICAgICAgICAgICAgIHg6IHBhdGhTdHlsZS54LFxuICAgICAgICAgICAgICB5OiBwYXRoU3R5bGUueSxcbiAgICAgICAgICAgICAgd2lkdGg6IHBhdGhTdHlsZS53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBwYXRoU3R5bGUuaGVpZ2h0XG4gICAgICAgICAgICB9LCBzeW1ib2xTdHlsZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2ludGVyLnVzZVN0eWxlKHN5bWJvbFN0eWxlKTtcbiAgICAgICAgICAgIHBvaW50ZXIudHlwZSAhPT0gJ3BvaW50ZXInICYmIHBvaW50ZXIuc2V0Q29sb3IodmlzdWFsQ29sb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludGVyLnNldFN0eWxlKGl0ZW1Nb2RlbC5nZXRNb2RlbChbJ3BvaW50ZXInLCAnaXRlbVN0eWxlJ10pLmdldEl0ZW1TdHlsZSgpKTtcbiAgICAgICAgICBpZiAocG9pbnRlci5zdHlsZS5maWxsID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHBvaW50ZXIuc2V0U3R5bGUoJ2ZpbGwnLCBnZXRDb2xvcihsaW5lYXJNYXAoZGF0YS5nZXQodmFsdWVEaW0sIGlkeCksIHZhbHVlRXh0ZW50LCBbMCwgMV0sIHRydWUpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50ZXIuejJFbXBoYXNpc0xpZnQgPSAwO1xuICAgICAgICAgIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChwb2ludGVyLCBpdGVtTW9kZWwpO1xuICAgICAgICAgIHRvZ2dsZUhvdmVyRW1waGFzaXMocG9pbnRlciwgZm9jdXMsIGJsdXJTY29wZSwgZW1waGFzaXNEaXNhYmxlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3dQcm9ncmVzcykge1xuICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHByb2dyZXNzTGlzdFtpZHhdO1xuICAgICAgICAgIHByb2dyZXNzLnVzZVN0eWxlKGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzdHlsZScpKTtcbiAgICAgICAgICBwcm9ncmVzcy5zZXRTdHlsZShpdGVtTW9kZWwuZ2V0TW9kZWwoWydwcm9ncmVzcycsICdpdGVtU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCkpO1xuICAgICAgICAgIHByb2dyZXNzLnoyRW1waGFzaXNMaWZ0ID0gMDtcbiAgICAgICAgICBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwocHJvZ3Jlc3MsIGl0ZW1Nb2RlbCk7XG4gICAgICAgICAgdG9nZ2xlSG92ZXJFbXBoYXNpcyhwcm9ncmVzcywgZm9jdXMsIGJsdXJTY29wZSwgZW1waGFzaXNEaXNhYmxlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fcHJvZ3Jlc3NFbHMgPSBwcm9ncmVzc0xpc3Q7XG4gICAgfVxuICB9O1xuICBHYXVnZVZpZXcucHJvdG90eXBlLl9yZW5kZXJBbmNob3IgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIHBvc0luZm8pIHtcbiAgICB2YXIgYW5jaG9yTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnYW5jaG9yJyk7XG4gICAgdmFyIHNob3dBbmNob3IgPSBhbmNob3JNb2RlbC5nZXQoJ3Nob3cnKTtcbiAgICBpZiAoc2hvd0FuY2hvcikge1xuICAgICAgdmFyIGFuY2hvclNpemUgPSBhbmNob3JNb2RlbC5nZXQoJ3NpemUnKTtcbiAgICAgIHZhciBhbmNob3JUeXBlID0gYW5jaG9yTW9kZWwuZ2V0KCdpY29uJyk7XG4gICAgICB2YXIgb2Zmc2V0Q2VudGVyID0gYW5jaG9yTW9kZWwuZ2V0KCdvZmZzZXRDZW50ZXInKTtcbiAgICAgIHZhciBhbmNob3JLZWVwQXNwZWN0ID0gYW5jaG9yTW9kZWwuZ2V0KCdrZWVwQXNwZWN0Jyk7XG4gICAgICB2YXIgYW5jaG9yID0gY3JlYXRlU3ltYm9sKGFuY2hvclR5cGUsIHBvc0luZm8uY3ggLSBhbmNob3JTaXplIC8gMiArIHBhcnNlUGVyY2VudChvZmZzZXRDZW50ZXJbMF0sIHBvc0luZm8uciksIHBvc0luZm8uY3kgLSBhbmNob3JTaXplIC8gMiArIHBhcnNlUGVyY2VudChvZmZzZXRDZW50ZXJbMV0sIHBvc0luZm8uciksIGFuY2hvclNpemUsIGFuY2hvclNpemUsIG51bGwsIGFuY2hvcktlZXBBc3BlY3QpO1xuICAgICAgYW5jaG9yLnoyID0gYW5jaG9yTW9kZWwuZ2V0KCdzaG93QWJvdmUnKSA/IDEgOiAwO1xuICAgICAgYW5jaG9yLnNldFN0eWxlKGFuY2hvck1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKS5nZXRJdGVtU3R5bGUoKSk7XG4gICAgICB0aGlzLmdyb3VwLmFkZChhbmNob3IpO1xuICAgIH1cbiAgfTtcbiAgR2F1Z2VWaWV3LnByb3RvdHlwZS5fcmVuZGVyVGl0bGVBbmREZXRhaWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgZ2V0Q29sb3IsIHBvc0luZm8pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciB2YWx1ZURpbSA9IGRhdGEubWFwRGltZW5zaW9uKCd2YWx1ZScpO1xuICAgIHZhciBtaW5WYWwgPSArc2VyaWVzTW9kZWwuZ2V0KCdtaW4nKTtcbiAgICB2YXIgbWF4VmFsID0gK3Nlcmllc01vZGVsLmdldCgnbWF4Jyk7XG4gICAgdmFyIGNvbnRlbnRHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgdmFyIG5ld1RpdGxlRWxzID0gW107XG4gICAgdmFyIG5ld0RldGFpbEVscyA9IFtdO1xuICAgIHZhciBoYXNBbmltYXRpb24gPSBzZXJpZXNNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKTtcbiAgICB2YXIgc2hvd1BvaW50ZXJBYm92ZSA9IHNlcmllc01vZGVsLmdldChbJ3BvaW50ZXInLCAnc2hvd0Fib3ZlJ10pO1xuICAgIGRhdGEuZGlmZih0aGlzLl9kYXRhKS5hZGQoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgbmV3VGl0bGVFbHNbaWR4XSA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgbmV3RGV0YWlsRWxzW2lkeF0gPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICB9KS51cGRhdGUoZnVuY3Rpb24gKGlkeCwgb2xkSWR4KSB7XG4gICAgICBuZXdUaXRsZUVsc1tpZHhdID0gX3RoaXMuX3RpdGxlRWxzW29sZElkeF07XG4gICAgICBuZXdEZXRhaWxFbHNbaWR4XSA9IF90aGlzLl9kZXRhaWxFbHNbb2xkSWR4XTtcbiAgICB9KS5leGVjdXRlKCk7XG4gICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgdmFyIHZhbHVlID0gZGF0YS5nZXQodmFsdWVEaW0sIGlkeCk7XG4gICAgICB2YXIgaXRlbUdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICAgIHZhciBhdXRvQ29sb3IgPSBnZXRDb2xvcihsaW5lYXJNYXAodmFsdWUsIFttaW5WYWwsIG1heFZhbF0sIFswLCAxXSwgdHJ1ZSkpO1xuICAgICAgdmFyIGl0ZW1UaXRsZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCd0aXRsZScpO1xuICAgICAgaWYgKGl0ZW1UaXRsZU1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgIHZhciB0aXRsZU9mZnNldENlbnRlciA9IGl0ZW1UaXRsZU1vZGVsLmdldCgnb2Zmc2V0Q2VudGVyJyk7XG4gICAgICAgIHZhciB0aXRsZVggPSBwb3NJbmZvLmN4ICsgcGFyc2VQZXJjZW50KHRpdGxlT2Zmc2V0Q2VudGVyWzBdLCBwb3NJbmZvLnIpO1xuICAgICAgICB2YXIgdGl0bGVZID0gcG9zSW5mby5jeSArIHBhcnNlUGVyY2VudCh0aXRsZU9mZnNldENlbnRlclsxXSwgcG9zSW5mby5yKTtcbiAgICAgICAgdmFyIGxhYmVsRWwgPSBuZXdUaXRsZUVsc1tpZHhdO1xuICAgICAgICBsYWJlbEVsLmF0dHIoe1xuICAgICAgICAgIHoyOiBzaG93UG9pbnRlckFib3ZlID8gMCA6IDIsXG4gICAgICAgICAgc3R5bGU6IGNyZWF0ZVRleHRTdHlsZShpdGVtVGl0bGVNb2RlbCwge1xuICAgICAgICAgICAgeDogdGl0bGVYLFxuICAgICAgICAgICAgeTogdGl0bGVZLFxuICAgICAgICAgICAgdGV4dDogZGF0YS5nZXROYW1lKGlkeCksXG4gICAgICAgICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJ1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGluaGVyaXRDb2xvcjogYXV0b0NvbG9yXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGl0ZW1Hcm91cC5hZGQobGFiZWxFbCk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlbURldGFpbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdkZXRhaWwnKTtcbiAgICAgIGlmIChpdGVtRGV0YWlsTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgdmFyIGRldGFpbE9mZnNldENlbnRlciA9IGl0ZW1EZXRhaWxNb2RlbC5nZXQoJ29mZnNldENlbnRlcicpO1xuICAgICAgICB2YXIgZGV0YWlsWCA9IHBvc0luZm8uY3ggKyBwYXJzZVBlcmNlbnQoZGV0YWlsT2Zmc2V0Q2VudGVyWzBdLCBwb3NJbmZvLnIpO1xuICAgICAgICB2YXIgZGV0YWlsWSA9IHBvc0luZm8uY3kgKyBwYXJzZVBlcmNlbnQoZGV0YWlsT2Zmc2V0Q2VudGVyWzFdLCBwb3NJbmZvLnIpO1xuICAgICAgICB2YXIgd2lkdGggPSBwYXJzZVBlcmNlbnQoaXRlbURldGFpbE1vZGVsLmdldCgnd2lkdGgnKSwgcG9zSW5mby5yKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlUGVyY2VudChpdGVtRGV0YWlsTW9kZWwuZ2V0KCdoZWlnaHQnKSwgcG9zSW5mby5yKTtcbiAgICAgICAgdmFyIGRldGFpbENvbG9yID0gc2VyaWVzTW9kZWwuZ2V0KFsncHJvZ3Jlc3MnLCAnc2hvdyddKSA/IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzdHlsZScpLmZpbGwgOiBhdXRvQ29sb3I7XG4gICAgICAgIHZhciBsYWJlbEVsID0gbmV3RGV0YWlsRWxzW2lkeF07XG4gICAgICAgIHZhciBmb3JtYXR0ZXJfMSA9IGl0ZW1EZXRhaWxNb2RlbC5nZXQoJ2Zvcm1hdHRlcicpO1xuICAgICAgICBsYWJlbEVsLmF0dHIoe1xuICAgICAgICAgIHoyOiBzaG93UG9pbnRlckFib3ZlID8gMCA6IDIsXG4gICAgICAgICAgc3R5bGU6IGNyZWF0ZVRleHRTdHlsZShpdGVtRGV0YWlsTW9kZWwsIHtcbiAgICAgICAgICAgIHg6IGRldGFpbFgsXG4gICAgICAgICAgICB5OiBkZXRhaWxZLFxuICAgICAgICAgICAgdGV4dDogZm9ybWF0TGFiZWwodmFsdWUsIGZvcm1hdHRlcl8xKSxcbiAgICAgICAgICAgIHdpZHRoOiBpc05hTih3aWR0aCkgPyBudWxsIDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGlzTmFOKGhlaWdodCkgPyBudWxsIDogaGVpZ2h0LFxuICAgICAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBpbmhlcml0Q29sb3I6IGRldGFpbENvbG9yXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHNldExhYmVsVmFsdWVBbmltYXRpb24obGFiZWxFbCwge1xuICAgICAgICAgIG5vcm1hbDogaXRlbURldGFpbE1vZGVsXG4gICAgICAgIH0sIHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZm9ybWF0TGFiZWwodmFsdWUsIGZvcm1hdHRlcl8xKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGhhc0FuaW1hdGlvbiAmJiBhbmltYXRlTGFiZWxWYWx1ZShsYWJlbEVsLCBpZHgsIGRhdGEsIHNlcmllc01vZGVsLCB7XG4gICAgICAgICAgZ2V0Rm9ybWF0dGVkTGFiZWw6IGZ1bmN0aW9uIChsYWJlbERhdGFJbmRleCwgc3RhdHVzLCBkYXRhVHlwZSwgbGFiZWxEaW1JbmRleCwgZm10LCBleHRlbmRQYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRMYWJlbChleHRlbmRQYXJhbXMgPyBleHRlbmRQYXJhbXMuaW50ZXJwb2xhdGVkVmFsdWUgOiB2YWx1ZSwgZm9ybWF0dGVyXzEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGl0ZW1Hcm91cC5hZGQobGFiZWxFbCk7XG4gICAgICB9XG4gICAgICBjb250ZW50R3JvdXAuYWRkKGl0ZW1Hcm91cCk7XG4gICAgfSk7XG4gICAgdGhpcy5ncm91cC5hZGQoY29udGVudEdyb3VwKTtcbiAgICB0aGlzLl90aXRsZUVscyA9IG5ld1RpdGxlRWxzO1xuICAgIHRoaXMuX2RldGFpbEVscyA9IG5ld0RldGFpbEVscztcbiAgfTtcbiAgR2F1Z2VWaWV3LnR5cGUgPSAnZ2F1Z2UnO1xuICByZXR1cm4gR2F1Z2VWaWV3O1xufShDaGFydFZpZXcpO1xuZXhwb3J0IGRlZmF1bHQgR2F1Z2VWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgY3JlYXRlU2VyaWVzRGF0YVNpbXBseSBmcm9tICcuLi9oZWxwZXIvY3JlYXRlU2VyaWVzRGF0YVNpbXBseS5qcyc7XG5pbXBvcnQgU2VyaWVzTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvU2VyaWVzLmpzJztcbnZhciBHYXVnZVNlcmllc01vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEdhdWdlU2VyaWVzTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEdhdWdlU2VyaWVzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IEdhdWdlU2VyaWVzTW9kZWwudHlwZTtcbiAgICBfdGhpcy52aXN1YWxTdHlsZUFjY2Vzc1BhdGggPSAnaXRlbVN0eWxlJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgR2F1Z2VTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGEgPSBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVNlcmllc0RhdGFTaW1wbHkodGhpcywgWyd2YWx1ZSddKTtcbiAgfTtcbiAgR2F1Z2VTZXJpZXNNb2RlbC50eXBlID0gJ3Nlcmllcy5nYXVnZSc7XG4gIEdhdWdlU2VyaWVzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAvLyB6bGV2ZWw6IDAsXG4gICAgejogMixcbiAgICBjb2xvckJ5OiAnZGF0YScsXG4gICAgLy8g6buY6K6k5YWo5bGA5bGF5LitXG4gICAgY2VudGVyOiBbJzUwJScsICc1MCUnXSxcbiAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG4gICAgcmFkaXVzOiAnNzUlJyxcbiAgICBzdGFydEFuZ2xlOiAyMjUsXG4gICAgZW5kQW5nbGU6IC00NSxcbiAgICBjbG9ja3dpc2U6IHRydWUsXG4gICAgLy8g5pyA5bCP5YC8XG4gICAgbWluOiAwLFxuICAgIC8vIOacgOWkp+WAvFxuICAgIG1heDogMTAwLFxuICAgIC8vIOWIhuWJsuauteaVsO+8jOm7mOiupOS4ujEwXG4gICAgc3BsaXROdW1iZXI6IDEwLFxuICAgIC8vIOWdkOagh+i9tOe6v1xuICAgIGF4aXNMaW5lOiB7XG4gICAgICAvLyDpu5jorqTmmL7npLrvvIzlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCmXG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgcm91bmRDYXA6IGZhbHNlLFxuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiBbWzEsICcjRTZFQkY4J11dLFxuICAgICAgICB3aWR0aDogMTBcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIOWdkOagh+i9tOe6v1xuICAgIHByb2dyZXNzOiB7XG4gICAgICAvLyDpu5jorqTmmL7npLrvvIzlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCmXG4gICAgICBzaG93OiBmYWxzZSxcbiAgICAgIG92ZXJsYXA6IHRydWUsXG4gICAgICB3aWR0aDogMTAsXG4gICAgICByb3VuZENhcDogZmFsc2UsXG4gICAgICBjbGlwOiB0cnVlXG4gICAgfSxcbiAgICAvLyDliIbpmpTnur9cbiAgICBzcGxpdExpbmU6IHtcbiAgICAgIC8vIOm7mOiupOaYvuekuu+8jOWxnuaAp3Nob3fmjqfliLbmmL7npLrkuI7lkKZcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICAvLyDlsZ7mgKdsZW5ndGjmjqfliLbnur/plb9cbiAgICAgIGxlbmd0aDogMTAsXG4gICAgICBkaXN0YW5jZTogMTAsXG4gICAgICAvLyDlsZ7mgKdsaW5lU3R5bGXvvIjor6bop4FsaW5lU3R5bGXvvInmjqfliLbnur/mnaHmoLflvI9cbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBjb2xvcjogJyM2MzY3N0EnLFxuICAgICAgICB3aWR0aDogMyxcbiAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8g5Z2Q5qCH6L205bCP5qCH6K6wXG4gICAgYXhpc1RpY2s6IHtcbiAgICAgIC8vIOWxnuaAp3Nob3fmjqfliLbmmL7npLrkuI7lkKbvvIzpu5jorqTkuI3mmL7npLpcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICAvLyDmr4/ku71zcGxpdOe7huWIhuWkmuWwkeautVxuICAgICAgc3BsaXROdW1iZXI6IDUsXG4gICAgICAvLyDlsZ7mgKdsZW5ndGjmjqfliLbnur/plb9cbiAgICAgIGxlbmd0aDogNixcbiAgICAgIGRpc3RhbmNlOiAxMCxcbiAgICAgIC8vIOWxnuaAp2xpbmVTdHlsZeaOp+WItue6v+adoeagt+W8j1xuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzYzNjc3QScsXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICB0eXBlOiAnc29saWQnXG4gICAgICB9XG4gICAgfSxcbiAgICBheGlzTGFiZWw6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBkaXN0YW5jZTogMTUsXG4gICAgICAvLyBmb3JtYXR0ZXI6IG51bGwsXG4gICAgICBjb2xvcjogJyM0NjQ2NDYnLFxuICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgcm90YXRlOiAwXG4gICAgfSxcbiAgICBwb2ludGVyOiB7XG4gICAgICBpY29uOiBudWxsLFxuICAgICAgb2Zmc2V0Q2VudGVyOiBbMCwgMF0sXG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgc2hvd0Fib3ZlOiB0cnVlLFxuICAgICAgbGVuZ3RoOiAnNjAlJyxcbiAgICAgIHdpZHRoOiA2LFxuICAgICAga2VlcEFzcGVjdDogZmFsc2VcbiAgICB9LFxuICAgIGFuY2hvcjoge1xuICAgICAgc2hvdzogZmFsc2UsXG4gICAgICBzaG93QWJvdmU6IGZhbHNlLFxuICAgICAgc2l6ZTogNixcbiAgICAgIGljb246ICdjaXJjbGUnLFxuICAgICAgb2Zmc2V0Q2VudGVyOiBbMCwgMF0sXG4gICAgICBrZWVwQXNwZWN0OiBmYWxzZSxcbiAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjNTQ3MGM2J1xuICAgICAgfVxuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICAvLyB4LCB577yM5Y2V5L2NcHhcbiAgICAgIG9mZnNldENlbnRlcjogWzAsICcyMCUnXSxcbiAgICAgIC8vIOWFtuS9meWxnuaAp+m7mOiupOS9v+eUqOWFqOWxgOaWh+acrOagt+W8j++8jOivpuingVRFWFRTVFlMRVxuICAgICAgY29sb3I6ICcjNDY0NjQ2JyxcbiAgICAgIGZvbnRTaXplOiAxNixcbiAgICAgIHZhbHVlQW5pbWF0aW9uOiBmYWxzZVxuICAgIH0sXG4gICAgZGV0YWlsOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgICB3aWR0aDogMTAwLFxuICAgICAgaGVpZ2h0OiBudWxsLFxuICAgICAgcGFkZGluZzogWzUsIDEwXSxcbiAgICAgIC8vIHgsIHnvvIzljZXkvY1weFxuICAgICAgb2Zmc2V0Q2VudGVyOiBbMCwgJzQwJSddLFxuICAgICAgLy8gZm9ybWF0dGVyOiBudWxsLFxuICAgICAgLy8g5YW25L2Z5bGe5oCn6buY6K6k5L2/55So5YWo5bGA5paH5pys5qC35byP77yM6K+m6KeBVEVYVFNUWUxFXG4gICAgICBjb2xvcjogJyM0NjQ2NDYnLFxuICAgICAgZm9udFNpemU6IDMwLFxuICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgbGluZUhlaWdodDogMzAsXG4gICAgICB2YWx1ZUFuaW1hdGlvbjogZmFsc2VcbiAgICB9XG4gIH07XG4gIHJldHVybiBHYXVnZVNlcmllc01vZGVsO1xufShTZXJpZXNNb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBHYXVnZVNlcmllc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IEdhdWdlVmlldyBmcm9tICcuL0dhdWdlVmlldy5qcyc7XG5pbXBvcnQgR2F1Z2VTZXJpZXNNb2RlbCBmcm9tICcuL0dhdWdlU2VyaWVzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDaGFydFZpZXcoR2F1Z2VWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU2VyaWVzTW9kZWwoR2F1Z2VTZXJpZXNNb2RlbCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///61030\n")},74508:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polyline.js\nvar Polyline = __webpack_require__(39195);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/Point.js\nvar Point = __webpack_require__(26346);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polygon.js\nvar Polygon = __webpack_require__(52505);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelGuideHelper.js\nvar labelGuideHelper = __webpack_require__(92621);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n;// ./node_modules/echarts/lib/chart/funnel/FunnelView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar opacityAccessPath = ['itemStyle', 'opacity'];\n/**\r\n * Piece of pie including Sector, Label, LabelLine\r\n */\nvar FunnelPiece = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(FunnelPiece, _super);\n  function FunnelPiece(data, idx) {\n    var _this = _super.call(this) || this;\n    var polygon = _this;\n    var labelLine = new Polyline/* default */.A();\n    var text = new Text/* default */.Ay();\n    polygon.setTextContent(text);\n    _this.setTextGuideLine(labelLine);\n    _this.updateData(data, idx, true);\n    return _this;\n  }\n  FunnelPiece.prototype.updateData = function (data, idx, firstCreate) {\n    var polygon = this;\n    var seriesModel = data.hostModel;\n    var itemModel = data.getItemModel(idx);\n    var layout = data.getItemLayout(idx);\n    var emphasisModel = itemModel.getModel('emphasis');\n    var opacity = itemModel.get(opacityAccessPath);\n    opacity = opacity == null ? 1 : opacity;\n    if (!firstCreate) {\n      (0,basicTransition/* saveOldStyle */.ap)(polygon);\n    }\n    // Update common style\n    polygon.useStyle(data.getItemVisual(idx, 'style'));\n    polygon.style.lineJoin = 'round';\n    if (firstCreate) {\n      polygon.setShape({\n        points: layout.points\n      });\n      polygon.style.opacity = 0;\n      basicTransition/* initProps */.LW(polygon, {\n        style: {\n          opacity: opacity\n        }\n      }, seriesModel, idx);\n    } else {\n      basicTransition/* updateProps */.oi(polygon, {\n        style: {\n          opacity: opacity\n        },\n        shape: {\n          points: layout.points\n        }\n      }, seriesModel, idx);\n    }\n    (0,states/* setStatesStylesFromModel */.Mx)(polygon, itemModel);\n    this._updateLabel(data, idx);\n    (0,states/* toggleHoverEmphasis */.Lm)(this, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n  };\n  FunnelPiece.prototype._updateLabel = function (data, idx) {\n    var polygon = this;\n    var labelLine = this.getTextGuideLine();\n    var labelText = polygon.getTextContent();\n    var seriesModel = data.hostModel;\n    var itemModel = data.getItemModel(idx);\n    var layout = data.getItemLayout(idx);\n    var labelLayout = layout.label;\n    var style = data.getItemVisual(idx, 'style');\n    var visualColor = style.fill;\n    (0,labelStyle/* setLabelStyle */.qM)(\n    // position will not be used in setLabelStyle\n    labelText, (0,labelStyle/* getLabelStatesModels */.lx)(itemModel), {\n      labelFetcher: data.hostModel,\n      labelDataIndex: idx,\n      defaultOpacity: style.opacity,\n      defaultText: data.getName(idx)\n    }, {\n      normal: {\n        align: labelLayout.textAlign,\n        verticalAlign: labelLayout.verticalAlign\n      }\n    });\n    polygon.setTextConfig({\n      local: true,\n      inside: !!labelLayout.inside,\n      insideStroke: visualColor,\n      // insideFill: 'auto',\n      outsideFill: visualColor\n    });\n    var linePoints = labelLayout.linePoints;\n    labelLine.setShape({\n      points: linePoints\n    });\n    polygon.textGuideLineConfig = {\n      anchor: linePoints ? new Point/* default */.A(linePoints[0][0], linePoints[0][1]) : null\n    };\n    // Make sure update style on labelText after setLabelStyle.\n    // Because setLabelStyle will replace a new style on it.\n    basicTransition/* updateProps */.oi(labelText, {\n      style: {\n        x: labelLayout.x,\n        y: labelLayout.y\n      }\n    }, seriesModel, idx);\n    labelText.attr({\n      rotation: labelLayout.rotation,\n      originX: labelLayout.x,\n      originY: labelLayout.y,\n      z2: 10\n    });\n    (0,labelGuideHelper/* setLabelLineStyle */.eR)(polygon, (0,labelGuideHelper/* getLabelLineStatesModels */.rv)(itemModel), {\n      // Default use item visual color\n      stroke: visualColor\n    });\n  };\n  return FunnelPiece;\n}(Polygon/* default */.A);\nvar FunnelView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(FunnelView, _super);\n  function FunnelView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = FunnelView.type;\n    _this.ignoreLabelLineUpdate = true;\n    return _this;\n  }\n  FunnelView.prototype.render = function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    data.diff(oldData).add(function (idx) {\n      var funnelPiece = new FunnelPiece(data, idx);\n      data.setItemGraphicEl(idx, funnelPiece);\n      group.add(funnelPiece);\n    }).update(function (newIdx, oldIdx) {\n      var piece = oldData.getItemGraphicEl(oldIdx);\n      piece.updateData(data, newIdx);\n      group.add(piece);\n      data.setItemGraphicEl(newIdx, piece);\n    }).remove(function (idx) {\n      var piece = oldData.getItemGraphicEl(idx);\n      basicTransition/* removeElementWithFadeOut */.t5(piece, seriesModel, idx);\n    }).execute();\n    this._data = data;\n  };\n  FunnelView.prototype.remove = function () {\n    this.group.removeAll();\n    this._data = null;\n  };\n  FunnelView.prototype.dispose = function () {};\n  FunnelView.type = 'funnel';\n  return FunnelView;\n}(Chart/* default */.A);\n/* harmony default export */ const funnel_FunnelView = (FunnelView);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createSeriesDataSimply.js\nvar createSeriesDataSimply = __webpack_require__(72731);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/sourceHelper.js\nvar sourceHelper = __webpack_require__(23071);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/LegendVisualProvider.js\nvar LegendVisualProvider = __webpack_require__(58239);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n;// ./node_modules/echarts/lib/chart/funnel/FunnelSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar FunnelSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(FunnelSeriesModel, _super);\n  function FunnelSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = FunnelSeriesModel.type;\n    return _this;\n  }\n  FunnelSeriesModel.prototype.init = function (option) {\n    _super.prototype.init.apply(this, arguments);\n    // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n    this.legendVisualProvider = new LegendVisualProvider/* default */.A(util.bind(this.getData, this), util.bind(this.getRawData, this));\n    // Extend labelLine emphasis\n    this._defaultLabelLine(option);\n  };\n  FunnelSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    return (0,createSeriesDataSimply/* default */.A)(this, {\n      coordDimensions: ['value'],\n      encodeDefaulter: util.curry(sourceHelper/* makeSeriesEncodeForNameBased */.ln, this)\n    });\n  };\n  FunnelSeriesModel.prototype._defaultLabelLine = function (option) {\n    // Extend labelLine emphasis\n    (0,model/* defaultEmphasis */.M5)(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine;\n    // Not show label line if `label.normal.show = false`\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  };\n  // Overwrite\n  FunnelSeriesModel.prototype.getDataParams = function (dataIndex) {\n    var data = this.getData();\n    var params = _super.prototype.getDataParams.call(this, dataIndex);\n    var valueDim = data.mapDimension('value');\n    var sum = data.getSum(valueDim);\n    // Percent is 0 if sum is 0\n    params.percent = !sum ? 0 : +(data.get(valueDim, dataIndex) / sum * 100).toFixed(2);\n    params.$vars.push('percent');\n    return params;\n  };\n  FunnelSeriesModel.type = 'series.funnel';\n  FunnelSeriesModel.defaultOption = {\n    // zlevel: 0,                  // 一级层叠\n    z: 2,\n    legendHoverLink: true,\n    colorBy: 'data',\n    left: 80,\n    top: 60,\n    right: 80,\n    bottom: 60,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    // 默认取数据最小最大值\n    // min: 0,\n    // max: 100,\n    minSize: '0%',\n    maxSize: '100%',\n    sort: 'descending',\n    orient: 'vertical',\n    gap: 0,\n    funnelAlign: 'center',\n    label: {\n      show: true,\n      position: 'outer'\n      // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n    },\n    labelLine: {\n      show: true,\n      length: 20,\n      lineStyle: {\n        // color: 各异,\n        width: 1\n      }\n    },\n    itemStyle: {\n      // color: 各异,\n      borderColor: '#fff',\n      borderWidth: 1\n    },\n    emphasis: {\n      label: {\n        show: true\n      }\n    },\n    select: {\n      itemStyle: {\n        borderColor: '#212121'\n      }\n    }\n  };\n  return FunnelSeriesModel;\n}(Series/* default */.A);\n/* harmony default export */ const FunnelSeries = (FunnelSeriesModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n;// ./node_modules/echarts/lib/chart/funnel/funnelLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction getViewRect(seriesModel, api) {\n  return layout/* getLayoutRect */.dV(seriesModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n}\nfunction getSortedIndices(data, sort) {\n  var valueDim = data.mapDimension('value');\n  var valueArr = data.mapArray(valueDim, function (val) {\n    return val;\n  });\n  var indices = [];\n  var isAscending = sort === 'ascending';\n  for (var i = 0, len = data.count(); i < len; i++) {\n    indices[i] = i;\n  }\n  // Add custom sortable function & none sortable opetion by \"options.sort\"\n  if ((0,util.isFunction)(sort)) {\n    indices.sort(sort);\n  } else if (sort !== 'none') {\n    indices.sort(function (a, b) {\n      return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];\n    });\n  }\n  return indices;\n}\nfunction labelLayout(data) {\n  var seriesModel = data.hostModel;\n  var orient = seriesModel.get('orient');\n  data.each(function (idx) {\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label');\n    var labelPosition = labelModel.get('position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var layout = data.getItemLayout(idx);\n    var points = layout.points;\n    var isLabelInside = labelPosition === 'inner' || labelPosition === 'inside' || labelPosition === 'center' || labelPosition === 'insideLeft' || labelPosition === 'insideRight';\n    var textAlign;\n    var textX;\n    var textY;\n    var linePoints;\n    if (isLabelInside) {\n      if (labelPosition === 'insideLeft') {\n        textX = (points[0][0] + points[3][0]) / 2 + 5;\n        textY = (points[0][1] + points[3][1]) / 2;\n        textAlign = 'left';\n      } else if (labelPosition === 'insideRight') {\n        textX = (points[1][0] + points[2][0]) / 2 - 5;\n        textY = (points[1][1] + points[2][1]) / 2;\n        textAlign = 'right';\n      } else {\n        textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;\n        textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;\n        textAlign = 'center';\n      }\n      linePoints = [[textX, textY], [textX, textY]];\n    } else {\n      var x1 = void 0;\n      var y1 = void 0;\n      var x2 = void 0;\n      var y2 = void 0;\n      var labelLineLen = labelLineModel.get('length');\n      if (false) {}\n      if (labelPosition === 'left') {\n        // Left side\n        x1 = (points[3][0] + points[0][0]) / 2;\n        y1 = (points[3][1] + points[0][1]) / 2;\n        x2 = x1 - labelLineLen;\n        textX = x2 - 5;\n        textAlign = 'right';\n      } else if (labelPosition === 'right') {\n        // Right side\n        x1 = (points[1][0] + points[2][0]) / 2;\n        y1 = (points[1][1] + points[2][1]) / 2;\n        x2 = x1 + labelLineLen;\n        textX = x2 + 5;\n        textAlign = 'left';\n      } else if (labelPosition === 'top') {\n        // Top side\n        x1 = (points[3][0] + points[0][0]) / 2;\n        y1 = (points[3][1] + points[0][1]) / 2;\n        y2 = y1 - labelLineLen;\n        textY = y2 - 5;\n        textAlign = 'center';\n      } else if (labelPosition === 'bottom') {\n        // Bottom side\n        x1 = (points[1][0] + points[2][0]) / 2;\n        y1 = (points[1][1] + points[2][1]) / 2;\n        y2 = y1 + labelLineLen;\n        textY = y2 + 5;\n        textAlign = 'center';\n      } else if (labelPosition === 'rightTop') {\n        // RightTop side\n        x1 = orient === 'horizontal' ? points[3][0] : points[1][0];\n        y1 = orient === 'horizontal' ? points[3][1] : points[1][1];\n        if (orient === 'horizontal') {\n          y2 = y1 - labelLineLen;\n          textY = y2 - 5;\n          textAlign = 'center';\n        } else {\n          x2 = x1 + labelLineLen;\n          textX = x2 + 5;\n          textAlign = 'top';\n        }\n      } else if (labelPosition === 'rightBottom') {\n        // RightBottom side\n        x1 = points[2][0];\n        y1 = points[2][1];\n        if (orient === 'horizontal') {\n          y2 = y1 + labelLineLen;\n          textY = y2 + 5;\n          textAlign = 'center';\n        } else {\n          x2 = x1 + labelLineLen;\n          textX = x2 + 5;\n          textAlign = 'bottom';\n        }\n      } else if (labelPosition === 'leftTop') {\n        // LeftTop side\n        x1 = points[0][0];\n        y1 = orient === 'horizontal' ? points[0][1] : points[1][1];\n        if (orient === 'horizontal') {\n          y2 = y1 - labelLineLen;\n          textY = y2 - 5;\n          textAlign = 'center';\n        } else {\n          x2 = x1 - labelLineLen;\n          textX = x2 - 5;\n          textAlign = 'right';\n        }\n      } else if (labelPosition === 'leftBottom') {\n        // LeftBottom side\n        x1 = orient === 'horizontal' ? points[1][0] : points[3][0];\n        y1 = orient === 'horizontal' ? points[1][1] : points[2][1];\n        if (orient === 'horizontal') {\n          y2 = y1 + labelLineLen;\n          textY = y2 + 5;\n          textAlign = 'center';\n        } else {\n          x2 = x1 - labelLineLen;\n          textX = x2 - 5;\n          textAlign = 'right';\n        }\n      } else {\n        // Right side or Bottom side\n        x1 = (points[1][0] + points[2][0]) / 2;\n        y1 = (points[1][1] + points[2][1]) / 2;\n        if (orient === 'horizontal') {\n          y2 = y1 + labelLineLen;\n          textY = y2 + 5;\n          textAlign = 'center';\n        } else {\n          x2 = x1 + labelLineLen;\n          textX = x2 + 5;\n          textAlign = 'left';\n        }\n      }\n      if (orient === 'horizontal') {\n        x2 = x1;\n        textX = x2;\n      } else {\n        y2 = y1;\n        textY = y2;\n      }\n      linePoints = [[x1, y1], [x2, y2]];\n    }\n    layout.label = {\n      linePoints: linePoints,\n      x: textX,\n      y: textY,\n      verticalAlign: 'middle',\n      textAlign: textAlign,\n      inside: isLabelInside\n    };\n  });\n}\nfunction funnelLayout(ecModel, api) {\n  ecModel.eachSeriesByType('funnel', function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var sort = seriesModel.get('sort');\n    var viewRect = getViewRect(seriesModel, api);\n    var orient = seriesModel.get('orient');\n    var viewWidth = viewRect.width;\n    var viewHeight = viewRect.height;\n    var indices = getSortedIndices(data, sort);\n    var x = viewRect.x;\n    var y = viewRect.y;\n    var sizeExtent = orient === 'horizontal' ? [(0,number/* parsePercent */.lo)(seriesModel.get('minSize'), viewHeight), (0,number/* parsePercent */.lo)(seriesModel.get('maxSize'), viewHeight)] : [(0,number/* parsePercent */.lo)(seriesModel.get('minSize'), viewWidth), (0,number/* parsePercent */.lo)(seriesModel.get('maxSize'), viewWidth)];\n    var dataExtent = data.getDataExtent(valueDim);\n    var min = seriesModel.get('min');\n    var max = seriesModel.get('max');\n    if (min == null) {\n      min = Math.min(dataExtent[0], 0);\n    }\n    if (max == null) {\n      max = dataExtent[1];\n    }\n    var funnelAlign = seriesModel.get('funnelAlign');\n    var gap = seriesModel.get('gap');\n    var viewSize = orient === 'horizontal' ? viewWidth : viewHeight;\n    var itemSize = (viewSize - gap * (data.count() - 1)) / data.count();\n    var getLinePoints = function (idx, offset) {\n      // End point index is data.count() and we assign it 0\n      if (orient === 'horizontal') {\n        var val_1 = data.get(valueDim, idx) || 0;\n        var itemHeight = (0,number/* linearMap */.Cb)(val_1, [min, max], sizeExtent, true);\n        var y0 = void 0;\n        switch (funnelAlign) {\n          case 'top':\n            y0 = y;\n            break;\n          case 'center':\n            y0 = y + (viewHeight - itemHeight) / 2;\n            break;\n          case 'bottom':\n            y0 = y + (viewHeight - itemHeight);\n            break;\n        }\n        return [[offset, y0], [offset, y0 + itemHeight]];\n      }\n      var val = data.get(valueDim, idx) || 0;\n      var itemWidth = (0,number/* linearMap */.Cb)(val, [min, max], sizeExtent, true);\n      var x0;\n      switch (funnelAlign) {\n        case 'left':\n          x0 = x;\n          break;\n        case 'center':\n          x0 = x + (viewWidth - itemWidth) / 2;\n          break;\n        case 'right':\n          x0 = x + viewWidth - itemWidth;\n          break;\n      }\n      return [[x0, offset], [x0 + itemWidth, offset]];\n    };\n    if (sort === 'ascending') {\n      // From bottom to top\n      itemSize = -itemSize;\n      gap = -gap;\n      if (orient === 'horizontal') {\n        x += viewWidth;\n      } else {\n        y += viewHeight;\n      }\n      indices = indices.reverse();\n    }\n    for (var i = 0; i < indices.length; i++) {\n      var idx = indices[i];\n      var nextIdx = indices[i + 1];\n      var itemModel = data.getItemModel(idx);\n      if (orient === 'horizontal') {\n        var width = itemModel.get(['itemStyle', 'width']);\n        if (width == null) {\n          width = itemSize;\n        } else {\n          width = (0,number/* parsePercent */.lo)(width, viewWidth);\n          if (sort === 'ascending') {\n            width = -width;\n          }\n        }\n        var start = getLinePoints(idx, x);\n        var end = getLinePoints(nextIdx, x + width);\n        x += width + gap;\n        data.setItemLayout(idx, {\n          points: start.concat(end.slice().reverse())\n        });\n      } else {\n        var height = itemModel.get(['itemStyle', 'height']);\n        if (height == null) {\n          height = itemSize;\n        } else {\n          height = (0,number/* parsePercent */.lo)(height, viewHeight);\n          if (sort === 'ascending') {\n            height = -height;\n          }\n        }\n        var start = getLinePoints(idx, y);\n        var end = getLinePoints(nextIdx, y + height);\n        y += height + gap;\n        data.setItemLayout(idx, {\n          points: start.concat(end.slice().reverse())\n        });\n      }\n    }\n    labelLayout(data);\n  });\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/processor/dataFilter.js\nvar dataFilter = __webpack_require__(78587);\n;// ./node_modules/echarts/lib/chart/funnel/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nfunction install(registers) {\n  registers.registerChartView(funnel_FunnelView);\n  registers.registerSeriesModel(FunnelSeries);\n  registers.registerLayout(funnelLayout);\n  registers.registerProcessor((0,dataFilter/* default */.A)('funnel'));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ1MDguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvZnVubmVsL0Z1bm5lbFZpZXcuanM/YTE2ZiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvZnVubmVsL0Z1bm5lbFNlcmllcy5qcz8xMjkyIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9mdW5uZWwvZnVubmVsTGF5b3V0LmpzPzk1YWEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Z1bm5lbC9pbnN0YWxsLmpzPzQwYWQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCB7IHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbCwgdG9nZ2xlSG92ZXJFbXBoYXNpcyB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdGVzLmpzJztcbmltcG9ydCBDaGFydFZpZXcgZnJvbSAnLi4vLi4vdmlldy9DaGFydC5qcyc7XG5pbXBvcnQgeyBzZXRMYWJlbExpbmVTdHlsZSwgZ2V0TGFiZWxMaW5lU3RhdGVzTW9kZWxzIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxHdWlkZUhlbHBlci5qcyc7XG5pbXBvcnQgeyBzZXRMYWJlbFN0eWxlLCBnZXRMYWJlbFN0YXRlc01vZGVscyB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUuanMnO1xuaW1wb3J0IHsgc2F2ZU9sZFN0eWxlIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL2Jhc2ljVHJhbnNpdGlvbi5qcyc7XG52YXIgb3BhY2l0eUFjY2Vzc1BhdGggPSBbJ2l0ZW1TdHlsZScsICdvcGFjaXR5J107XG4vKipcclxuICogUGllY2Ugb2YgcGllIGluY2x1ZGluZyBTZWN0b3IsIExhYmVsLCBMYWJlbExpbmVcclxuICovXG52YXIgRnVubmVsUGllY2UgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRnVubmVsUGllY2UsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEZ1bm5lbFBpZWNlKGRhdGEsIGlkeCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgdmFyIHBvbHlnb24gPSBfdGhpcztcbiAgICB2YXIgbGFiZWxMaW5lID0gbmV3IGdyYXBoaWMuUG9seWxpbmUoKTtcbiAgICB2YXIgdGV4dCA9IG5ldyBncmFwaGljLlRleHQoKTtcbiAgICBwb2x5Z29uLnNldFRleHRDb250ZW50KHRleHQpO1xuICAgIF90aGlzLnNldFRleHRHdWlkZUxpbmUobGFiZWxMaW5lKTtcbiAgICBfdGhpcy51cGRhdGVEYXRhKGRhdGEsIGlkeCwgdHJ1ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEZ1bm5lbFBpZWNlLnByb3RvdHlwZS51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIGlkeCwgZmlyc3RDcmVhdGUpIHtcbiAgICB2YXIgcG9seWdvbiA9IHRoaXM7XG4gICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgIHZhciBlbXBoYXNpc01vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdlbXBoYXNpcycpO1xuICAgIHZhciBvcGFjaXR5ID0gaXRlbU1vZGVsLmdldChvcGFjaXR5QWNjZXNzUGF0aCk7XG4gICAgb3BhY2l0eSA9IG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5O1xuICAgIGlmICghZmlyc3RDcmVhdGUpIHtcbiAgICAgIHNhdmVPbGRTdHlsZShwb2x5Z29uKTtcbiAgICB9XG4gICAgLy8gVXBkYXRlIGNvbW1vbiBzdHlsZVxuICAgIHBvbHlnb24udXNlU3R5bGUoZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJykpO1xuICAgIHBvbHlnb24uc3R5bGUubGluZUpvaW4gPSAncm91bmQnO1xuICAgIGlmIChmaXJzdENyZWF0ZSkge1xuICAgICAgcG9seWdvbi5zZXRTaGFwZSh7XG4gICAgICAgIHBvaW50czogbGF5b3V0LnBvaW50c1xuICAgICAgfSk7XG4gICAgICBwb2x5Z29uLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgZ3JhcGhpYy5pbml0UHJvcHMocG9seWdvbiwge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgICAgfVxuICAgICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocG9seWdvbiwge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgICAgfSxcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICBwb2ludHM6IGxheW91dC5wb2ludHNcbiAgICAgICAgfVxuICAgICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgfVxuICAgIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChwb2x5Z29uLCBpdGVtTW9kZWwpO1xuICAgIHRoaXMuX3VwZGF0ZUxhYmVsKGRhdGEsIGlkeCk7XG4gICAgdG9nZ2xlSG92ZXJFbXBoYXNpcyh0aGlzLCBlbXBoYXNpc01vZGVsLmdldCgnZm9jdXMnKSwgZW1waGFzaXNNb2RlbC5nZXQoJ2JsdXJTY29wZScpLCBlbXBoYXNpc01vZGVsLmdldCgnZGlzYWJsZWQnKSk7XG4gIH07XG4gIEZ1bm5lbFBpZWNlLnByb3RvdHlwZS5fdXBkYXRlTGFiZWwgPSBmdW5jdGlvbiAoZGF0YSwgaWR4KSB7XG4gICAgdmFyIHBvbHlnb24gPSB0aGlzO1xuICAgIHZhciBsYWJlbExpbmUgPSB0aGlzLmdldFRleHRHdWlkZUxpbmUoKTtcbiAgICB2YXIgbGFiZWxUZXh0ID0gcG9seWdvbi5nZXRUZXh0Q29udGVudCgpO1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICB2YXIgbGFiZWxMYXlvdXQgPSBsYXlvdXQubGFiZWw7XG4gICAgdmFyIHN0eWxlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJyk7XG4gICAgdmFyIHZpc3VhbENvbG9yID0gc3R5bGUuZmlsbDtcbiAgICBzZXRMYWJlbFN0eWxlKFxuICAgIC8vIHBvc2l0aW9uIHdpbGwgbm90IGJlIHVzZWQgaW4gc2V0TGFiZWxTdHlsZVxuICAgIGxhYmVsVGV4dCwgZ2V0TGFiZWxTdGF0ZXNNb2RlbHMoaXRlbU1vZGVsKSwge1xuICAgICAgbGFiZWxGZXRjaGVyOiBkYXRhLmhvc3RNb2RlbCxcbiAgICAgIGxhYmVsRGF0YUluZGV4OiBpZHgsXG4gICAgICBkZWZhdWx0T3BhY2l0eTogc3R5bGUub3BhY2l0eSxcbiAgICAgIGRlZmF1bHRUZXh0OiBkYXRhLmdldE5hbWUoaWR4KVxuICAgIH0sIHtcbiAgICAgIG5vcm1hbDoge1xuICAgICAgICBhbGlnbjogbGFiZWxMYXlvdXQudGV4dEFsaWduLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBsYWJlbExheW91dC52ZXJ0aWNhbEFsaWduXG4gICAgICB9XG4gICAgfSk7XG4gICAgcG9seWdvbi5zZXRUZXh0Q29uZmlnKHtcbiAgICAgIGxvY2FsOiB0cnVlLFxuICAgICAgaW5zaWRlOiAhIWxhYmVsTGF5b3V0Lmluc2lkZSxcbiAgICAgIGluc2lkZVN0cm9rZTogdmlzdWFsQ29sb3IsXG4gICAgICAvLyBpbnNpZGVGaWxsOiAnYXV0bycsXG4gICAgICBvdXRzaWRlRmlsbDogdmlzdWFsQ29sb3JcbiAgICB9KTtcbiAgICB2YXIgbGluZVBvaW50cyA9IGxhYmVsTGF5b3V0LmxpbmVQb2ludHM7XG4gICAgbGFiZWxMaW5lLnNldFNoYXBlKHtcbiAgICAgIHBvaW50czogbGluZVBvaW50c1xuICAgIH0pO1xuICAgIHBvbHlnb24udGV4dEd1aWRlTGluZUNvbmZpZyA9IHtcbiAgICAgIGFuY2hvcjogbGluZVBvaW50cyA/IG5ldyBncmFwaGljLlBvaW50KGxpbmVQb2ludHNbMF1bMF0sIGxpbmVQb2ludHNbMF1bMV0pIDogbnVsbFxuICAgIH07XG4gICAgLy8gTWFrZSBzdXJlIHVwZGF0ZSBzdHlsZSBvbiBsYWJlbFRleHQgYWZ0ZXIgc2V0TGFiZWxTdHlsZS5cbiAgICAvLyBCZWNhdXNlIHNldExhYmVsU3R5bGUgd2lsbCByZXBsYWNlIGEgbmV3IHN0eWxlIG9uIGl0LlxuICAgIGdyYXBoaWMudXBkYXRlUHJvcHMobGFiZWxUZXh0LCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICB4OiBsYWJlbExheW91dC54LFxuICAgICAgICB5OiBsYWJlbExheW91dC55XG4gICAgICB9XG4gICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgbGFiZWxUZXh0LmF0dHIoe1xuICAgICAgcm90YXRpb246IGxhYmVsTGF5b3V0LnJvdGF0aW9uLFxuICAgICAgb3JpZ2luWDogbGFiZWxMYXlvdXQueCxcbiAgICAgIG9yaWdpblk6IGxhYmVsTGF5b3V0LnksXG4gICAgICB6MjogMTBcbiAgICB9KTtcbiAgICBzZXRMYWJlbExpbmVTdHlsZShwb2x5Z29uLCBnZXRMYWJlbExpbmVTdGF0ZXNNb2RlbHMoaXRlbU1vZGVsKSwge1xuICAgICAgLy8gRGVmYXVsdCB1c2UgaXRlbSB2aXN1YWwgY29sb3JcbiAgICAgIHN0cm9rZTogdmlzdWFsQ29sb3JcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIEZ1bm5lbFBpZWNlO1xufShncmFwaGljLlBvbHlnb24pO1xudmFyIEZ1bm5lbFZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRnVubmVsVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRnVubmVsVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gRnVubmVsVmlldy50eXBlO1xuICAgIF90aGlzLmlnbm9yZUxhYmVsTGluZVVwZGF0ZSA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEZ1bm5lbFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgZGF0YS5kaWZmKG9sZERhdGEpLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgZnVubmVsUGllY2UgPSBuZXcgRnVubmVsUGllY2UoZGF0YSwgaWR4KTtcbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIGZ1bm5lbFBpZWNlKTtcbiAgICAgIGdyb3VwLmFkZChmdW5uZWxQaWVjZSk7XG4gICAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgdmFyIHBpZWNlID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICBwaWVjZS51cGRhdGVEYXRhKGRhdGEsIG5ld0lkeCk7XG4gICAgICBncm91cC5hZGQocGllY2UpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgcGllY2UpO1xuICAgIH0pLnJlbW92ZShmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgcGllY2UgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwoaWR4KTtcbiAgICAgIGdyYXBoaWMucmVtb3ZlRWxlbWVudFdpdGhGYWRlT3V0KHBpZWNlLCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICB9KS5leGVjdXRlKCk7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH07XG4gIEZ1bm5lbFZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICB9O1xuICBGdW5uZWxWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG4gIEZ1bm5lbFZpZXcudHlwZSA9ICdmdW5uZWwnO1xuICByZXR1cm4gRnVubmVsVmlldztcbn0oQ2hhcnRWaWV3KTtcbmV4cG9ydCBkZWZhdWx0IEZ1bm5lbFZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IGNyZWF0ZVNlcmllc0RhdGFTaW1wbHkgZnJvbSAnLi4vaGVscGVyL2NyZWF0ZVNlcmllc0RhdGFTaW1wbHkuanMnO1xuaW1wb3J0IHsgZGVmYXVsdEVtcGhhc2lzIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG5pbXBvcnQgeyBtYWtlU2VyaWVzRW5jb2RlRm9yTmFtZUJhc2VkIH0gZnJvbSAnLi4vLi4vZGF0YS9oZWxwZXIvc291cmNlSGVscGVyLmpzJztcbmltcG9ydCBMZWdlbmRWaXN1YWxQcm92aWRlciBmcm9tICcuLi8uLi92aXN1YWwvTGVnZW5kVmlzdWFsUHJvdmlkZXIuanMnO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcy5qcyc7XG52YXIgRnVubmVsU2VyaWVzTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRnVubmVsU2VyaWVzTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEZ1bm5lbFNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBGdW5uZWxTZXJpZXNNb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBGdW5uZWxTZXJpZXNNb2RlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBFbmFibGUgbGVnZW5kIHNlbGVjdGlvbiBmb3IgZWFjaCBkYXRhIGl0ZW1cbiAgICAvLyBVc2UgYSBmdW5jdGlvbiBpbnN0ZWFkIG9mIGRpcmVjdCBhY2Nlc3MgYmVjYXVzZSBkYXRhIHJlZmVyZW5jZSBtYXkgY2hhbmdlZFxuICAgIHRoaXMubGVnZW5kVmlzdWFsUHJvdmlkZXIgPSBuZXcgTGVnZW5kVmlzdWFsUHJvdmlkZXIoenJVdGlsLmJpbmQodGhpcy5nZXREYXRhLCB0aGlzKSwgenJVdGlsLmJpbmQodGhpcy5nZXRSYXdEYXRhLCB0aGlzKSk7XG4gICAgLy8gRXh0ZW5kIGxhYmVsTGluZSBlbXBoYXNpc1xuICAgIHRoaXMuX2RlZmF1bHRMYWJlbExpbmUob3B0aW9uKTtcbiAgfTtcbiAgRnVubmVsU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIHJldHVybiBjcmVhdGVTZXJpZXNEYXRhU2ltcGx5KHRoaXMsIHtcbiAgICAgIGNvb3JkRGltZW5zaW9uczogWyd2YWx1ZSddLFxuICAgICAgZW5jb2RlRGVmYXVsdGVyOiB6clV0aWwuY3VycnkobWFrZVNlcmllc0VuY29kZUZvck5hbWVCYXNlZCwgdGhpcylcbiAgICB9KTtcbiAgfTtcbiAgRnVubmVsU2VyaWVzTW9kZWwucHJvdG90eXBlLl9kZWZhdWx0TGFiZWxMaW5lID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIC8vIEV4dGVuZCBsYWJlbExpbmUgZW1waGFzaXNcbiAgICBkZWZhdWx0RW1waGFzaXMob3B0aW9uLCAnbGFiZWxMaW5lJywgWydzaG93J10pO1xuICAgIHZhciBsYWJlbExpbmVOb3JtYWxPcHQgPSBvcHRpb24ubGFiZWxMaW5lO1xuICAgIHZhciBsYWJlbExpbmVFbXBoYXNpc09wdCA9IG9wdGlvbi5lbXBoYXNpcy5sYWJlbExpbmU7XG4gICAgLy8gTm90IHNob3cgbGFiZWwgbGluZSBpZiBgbGFiZWwubm9ybWFsLnNob3cgPSBmYWxzZWBcbiAgICBsYWJlbExpbmVOb3JtYWxPcHQuc2hvdyA9IGxhYmVsTGluZU5vcm1hbE9wdC5zaG93ICYmIG9wdGlvbi5sYWJlbC5zaG93O1xuICAgIGxhYmVsTGluZUVtcGhhc2lzT3B0LnNob3cgPSBsYWJlbExpbmVFbXBoYXNpc09wdC5zaG93ICYmIG9wdGlvbi5lbXBoYXNpcy5sYWJlbC5zaG93O1xuICB9O1xuICAvLyBPdmVyd3JpdGVcbiAgRnVubmVsU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldERhdGFQYXJhbXMgPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICB2YXIgcGFyYW1zID0gX3N1cGVyLnByb3RvdHlwZS5nZXREYXRhUGFyYW1zLmNhbGwodGhpcywgZGF0YUluZGV4KTtcbiAgICB2YXIgdmFsdWVEaW0gPSBkYXRhLm1hcERpbWVuc2lvbigndmFsdWUnKTtcbiAgICB2YXIgc3VtID0gZGF0YS5nZXRTdW0odmFsdWVEaW0pO1xuICAgIC8vIFBlcmNlbnQgaXMgMCBpZiBzdW0gaXMgMFxuICAgIHBhcmFtcy5wZXJjZW50ID0gIXN1bSA/IDAgOiArKGRhdGEuZ2V0KHZhbHVlRGltLCBkYXRhSW5kZXgpIC8gc3VtICogMTAwKS50b0ZpeGVkKDIpO1xuICAgIHBhcmFtcy4kdmFycy5wdXNoKCdwZXJjZW50Jyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfTtcbiAgRnVubmVsU2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMuZnVubmVsJztcbiAgRnVubmVsU2VyaWVzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAvLyB6bGV2ZWw6IDAsICAgICAgICAgICAgICAgICAgLy8g5LiA57qn5bGC5Y+gXG4gICAgejogMixcbiAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG4gICAgY29sb3JCeTogJ2RhdGEnLFxuICAgIGxlZnQ6IDgwLFxuICAgIHRvcDogNjAsXG4gICAgcmlnaHQ6IDgwLFxuICAgIGJvdHRvbTogNjAsXG4gICAgLy8gd2lkdGg6IHt0b3RhbFdpZHRofSAtIGxlZnQgLSByaWdodCxcbiAgICAvLyBoZWlnaHQ6IHt0b3RhbEhlaWdodH0gLSB0b3AgLSBib3R0b20sXG4gICAgLy8g6buY6K6k5Y+W5pWw5o2u5pyA5bCP5pyA5aSn5YC8XG4gICAgLy8gbWluOiAwLFxuICAgIC8vIG1heDogMTAwLFxuICAgIG1pblNpemU6ICcwJScsXG4gICAgbWF4U2l6ZTogJzEwMCUnLFxuICAgIHNvcnQ6ICdkZXNjZW5kaW5nJyxcbiAgICBvcmllbnQ6ICd2ZXJ0aWNhbCcsXG4gICAgZ2FwOiAwLFxuICAgIGZ1bm5lbEFsaWduOiAnY2VudGVyJyxcbiAgICBsYWJlbDoge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIHBvc2l0aW9uOiAnb3V0ZXInXG4gICAgICAvLyBmb3JtYXR0ZXI6IOagh+etvuaWh+acrOagvOW8j+WZqO+8jOWQjFRvb2x0aXAuZm9ybWF0dGVy77yM5LiN5pSv5oyB5byC5q2l5Zue6LCDXG4gICAgfSxcbiAgICBsYWJlbExpbmU6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBsZW5ndGg6IDIwLFxuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIC8vIGNvbG9yOiDlkITlvIIsXG4gICAgICAgIHdpZHRoOiAxXG4gICAgICB9XG4gICAgfSxcbiAgICBpdGVtU3R5bGU6IHtcbiAgICAgIC8vIGNvbG9yOiDlkITlvIIsXG4gICAgICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICB9LFxuICAgIGVtcGhhc2lzOiB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICBzaG93OiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3Q6IHtcbiAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMyMTIxMjEnXG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gRnVubmVsU2VyaWVzTW9kZWw7XG59KFNlcmllc01vZGVsKTtcbmV4cG9ydCBkZWZhdWx0IEZ1bm5lbFNlcmllc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgbGF5b3V0IGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0LmpzJztcbmltcG9ydCB7IHBhcnNlUGVyY2VudCwgbGluZWFyTWFwIH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5mdW5jdGlvbiBnZXRWaWV3UmVjdChzZXJpZXNNb2RlbCwgYXBpKSB7XG4gIHJldHVybiBsYXlvdXQuZ2V0TGF5b3V0UmVjdChzZXJpZXNNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSwge1xuICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNvcnRlZEluZGljZXMoZGF0YSwgc29ydCkge1xuICB2YXIgdmFsdWVEaW0gPSBkYXRhLm1hcERpbWVuc2lvbigndmFsdWUnKTtcbiAgdmFyIHZhbHVlQXJyID0gZGF0YS5tYXBBcnJheSh2YWx1ZURpbSwgZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH0pO1xuICB2YXIgaW5kaWNlcyA9IFtdO1xuICB2YXIgaXNBc2NlbmRpbmcgPSBzb3J0ID09PSAnYXNjZW5kaW5nJztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaW5kaWNlc1tpXSA9IGk7XG4gIH1cbiAgLy8gQWRkIGN1c3RvbSBzb3J0YWJsZSBmdW5jdGlvbiAmIG5vbmUgc29ydGFibGUgb3BldGlvbiBieSBcIm9wdGlvbnMuc29ydFwiXG4gIGlmIChpc0Z1bmN0aW9uKHNvcnQpKSB7XG4gICAgaW5kaWNlcy5zb3J0KHNvcnQpO1xuICB9IGVsc2UgaWYgKHNvcnQgIT09ICdub25lJykge1xuICAgIGluZGljZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGlzQXNjZW5kaW5nID8gdmFsdWVBcnJbYV0gLSB2YWx1ZUFycltiXSA6IHZhbHVlQXJyW2JdIC0gdmFsdWVBcnJbYV07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGluZGljZXM7XG59XG5mdW5jdGlvbiBsYWJlbExheW91dChkYXRhKSB7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICB2YXIgb3JpZW50ID0gc2VyaWVzTW9kZWwuZ2V0KCdvcmllbnQnKTtcbiAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICB2YXIgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwnKTtcbiAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgIHZhciBsYWJlbExpbmVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWxMaW5lJyk7XG4gICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgIHZhciBwb2ludHMgPSBsYXlvdXQucG9pbnRzO1xuICAgIHZhciBpc0xhYmVsSW5zaWRlID0gbGFiZWxQb3NpdGlvbiA9PT0gJ2lubmVyJyB8fCBsYWJlbFBvc2l0aW9uID09PSAnaW5zaWRlJyB8fCBsYWJlbFBvc2l0aW9uID09PSAnY2VudGVyJyB8fCBsYWJlbFBvc2l0aW9uID09PSAnaW5zaWRlTGVmdCcgfHwgbGFiZWxQb3NpdGlvbiA9PT0gJ2luc2lkZVJpZ2h0JztcbiAgICB2YXIgdGV4dEFsaWduO1xuICAgIHZhciB0ZXh0WDtcbiAgICB2YXIgdGV4dFk7XG4gICAgdmFyIGxpbmVQb2ludHM7XG4gICAgaWYgKGlzTGFiZWxJbnNpZGUpIHtcbiAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09PSAnaW5zaWRlTGVmdCcpIHtcbiAgICAgICAgdGV4dFggPSAocG9pbnRzWzBdWzBdICsgcG9pbnRzWzNdWzBdKSAvIDIgKyA1O1xuICAgICAgICB0ZXh0WSA9IChwb2ludHNbMF1bMV0gKyBwb2ludHNbM11bMV0pIC8gMjtcbiAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgfSBlbHNlIGlmIChsYWJlbFBvc2l0aW9uID09PSAnaW5zaWRlUmlnaHQnKSB7XG4gICAgICAgIHRleHRYID0gKHBvaW50c1sxXVswXSArIHBvaW50c1syXVswXSkgLyAyIC0gNTtcbiAgICAgICAgdGV4dFkgPSAocG9pbnRzWzFdWzFdICsgcG9pbnRzWzJdWzFdKSAvIDI7XG4gICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0WCA9IChwb2ludHNbMF1bMF0gKyBwb2ludHNbMV1bMF0gKyBwb2ludHNbMl1bMF0gKyBwb2ludHNbM11bMF0pIC8gNDtcbiAgICAgICAgdGV4dFkgPSAocG9pbnRzWzBdWzFdICsgcG9pbnRzWzFdWzFdICsgcG9pbnRzWzJdWzFdICsgcG9pbnRzWzNdWzFdKSAvIDQ7XG4gICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgfVxuICAgICAgbGluZVBvaW50cyA9IFtbdGV4dFgsIHRleHRZXSwgW3RleHRYLCB0ZXh0WV1dO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeDEgPSB2b2lkIDA7XG4gICAgICB2YXIgeTEgPSB2b2lkIDA7XG4gICAgICB2YXIgeDIgPSB2b2lkIDA7XG4gICAgICB2YXIgeTIgPSB2b2lkIDA7XG4gICAgICB2YXIgbGFiZWxMaW5lTGVuID0gbGFiZWxMaW5lTW9kZWwuZ2V0KCdsZW5ndGgnKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChvcmllbnQgPT09ICd2ZXJ0aWNhbCcgJiYgWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihsYWJlbFBvc2l0aW9uKSA+IC0xKSB7XG4gICAgICAgICAgbGFiZWxQb3NpdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Bvc2l0aW9uIGVycm9yOiBGdW5uZWwgY2hhcnQgb24gdmVydGljYWwgb3JpZW50IGRvc2Ugbm90IHN1cHBvcnQgdG9wIGFuZCBib3R0b20uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnICYmIFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YobGFiZWxQb3NpdGlvbikgPiAtMSkge1xuICAgICAgICAgIGxhYmVsUG9zaXRpb24gPSAnYm90dG9tJztcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Bvc2l0aW9uIGVycm9yOiBGdW5uZWwgY2hhcnQgb24gaG9yaXpvbnRhbCBvcmllbnQgZG9zZSBub3Qgc3VwcG9ydCBsZWZ0IGFuZCByaWdodC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAvLyBMZWZ0IHNpZGVcbiAgICAgICAgeDEgPSAocG9pbnRzWzNdWzBdICsgcG9pbnRzWzBdWzBdKSAvIDI7XG4gICAgICAgIHkxID0gKHBvaW50c1szXVsxXSArIHBvaW50c1swXVsxXSkgLyAyO1xuICAgICAgICB4MiA9IHgxIC0gbGFiZWxMaW5lTGVuO1xuICAgICAgICB0ZXh0WCA9IHgyIC0gNTtcbiAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSBpZiAobGFiZWxQb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAvLyBSaWdodCBzaWRlXG4gICAgICAgIHgxID0gKHBvaW50c1sxXVswXSArIHBvaW50c1syXVswXSkgLyAyO1xuICAgICAgICB5MSA9IChwb2ludHNbMV1bMV0gKyBwb2ludHNbMl1bMV0pIC8gMjtcbiAgICAgICAgeDIgPSB4MSArIGxhYmVsTGluZUxlbjtcbiAgICAgICAgdGV4dFggPSB4MiArIDU7XG4gICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgIH0gZWxzZSBpZiAobGFiZWxQb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgLy8gVG9wIHNpZGVcbiAgICAgICAgeDEgPSAocG9pbnRzWzNdWzBdICsgcG9pbnRzWzBdWzBdKSAvIDI7XG4gICAgICAgIHkxID0gKHBvaW50c1szXVsxXSArIHBvaW50c1swXVsxXSkgLyAyO1xuICAgICAgICB5MiA9IHkxIC0gbGFiZWxMaW5lTGVuO1xuICAgICAgICB0ZXh0WSA9IHkyIC0gNTtcbiAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB9IGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIC8vIEJvdHRvbSBzaWRlXG4gICAgICAgIHgxID0gKHBvaW50c1sxXVswXSArIHBvaW50c1syXVswXSkgLyAyO1xuICAgICAgICB5MSA9IChwb2ludHNbMV1bMV0gKyBwb2ludHNbMl1bMV0pIC8gMjtcbiAgICAgICAgeTIgPSB5MSArIGxhYmVsTGluZUxlbjtcbiAgICAgICAgdGV4dFkgPSB5MiArIDU7XG4gICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgfSBlbHNlIGlmIChsYWJlbFBvc2l0aW9uID09PSAncmlnaHRUb3AnKSB7XG4gICAgICAgIC8vIFJpZ2h0VG9wIHNpZGVcbiAgICAgICAgeDEgPSBvcmllbnQgPT09ICdob3Jpem9udGFsJyA/IHBvaW50c1szXVswXSA6IHBvaW50c1sxXVswXTtcbiAgICAgICAgeTEgPSBvcmllbnQgPT09ICdob3Jpem9udGFsJyA/IHBvaW50c1szXVsxXSA6IHBvaW50c1sxXVsxXTtcbiAgICAgICAgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgeTIgPSB5MSAtIGxhYmVsTGluZUxlbjtcbiAgICAgICAgICB0ZXh0WSA9IHkyIC0gNTtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4MiA9IHgxICsgbGFiZWxMaW5lTGVuO1xuICAgICAgICAgIHRleHRYID0geDIgKyA1O1xuICAgICAgICAgIHRleHRBbGlnbiA9ICd0b3AnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT09ICdyaWdodEJvdHRvbScpIHtcbiAgICAgICAgLy8gUmlnaHRCb3R0b20gc2lkZVxuICAgICAgICB4MSA9IHBvaW50c1syXVswXTtcbiAgICAgICAgeTEgPSBwb2ludHNbMl1bMV07XG4gICAgICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgIHkyID0geTEgKyBsYWJlbExpbmVMZW47XG4gICAgICAgICAgdGV4dFkgPSB5MiArIDU7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeDIgPSB4MSArIGxhYmVsTGluZUxlbjtcbiAgICAgICAgICB0ZXh0WCA9IHgyICsgNTtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnYm90dG9tJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsYWJlbFBvc2l0aW9uID09PSAnbGVmdFRvcCcpIHtcbiAgICAgICAgLy8gTGVmdFRvcCBzaWRlXG4gICAgICAgIHgxID0gcG9pbnRzWzBdWzBdO1xuICAgICAgICB5MSA9IG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gcG9pbnRzWzBdWzFdIDogcG9pbnRzWzFdWzFdO1xuICAgICAgICBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICB5MiA9IHkxIC0gbGFiZWxMaW5lTGVuO1xuICAgICAgICAgIHRleHRZID0geTIgLSA1O1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHgyID0geDEgLSBsYWJlbExpbmVMZW47XG4gICAgICAgICAgdGV4dFggPSB4MiAtIDU7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsYWJlbFBvc2l0aW9uID09PSAnbGVmdEJvdHRvbScpIHtcbiAgICAgICAgLy8gTGVmdEJvdHRvbSBzaWRlXG4gICAgICAgIHgxID0gb3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyBwb2ludHNbMV1bMF0gOiBwb2ludHNbM11bMF07XG4gICAgICAgIHkxID0gb3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyBwb2ludHNbMV1bMV0gOiBwb2ludHNbMl1bMV07XG4gICAgICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgIHkyID0geTEgKyBsYWJlbExpbmVMZW47XG4gICAgICAgICAgdGV4dFkgPSB5MiArIDU7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeDIgPSB4MSAtIGxhYmVsTGluZUxlbjtcbiAgICAgICAgICB0ZXh0WCA9IHgyIC0gNTtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSaWdodCBzaWRlIG9yIEJvdHRvbSBzaWRlXG4gICAgICAgIHgxID0gKHBvaW50c1sxXVswXSArIHBvaW50c1syXVswXSkgLyAyO1xuICAgICAgICB5MSA9IChwb2ludHNbMV1bMV0gKyBwb2ludHNbMl1bMV0pIC8gMjtcbiAgICAgICAgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgeTIgPSB5MSArIGxhYmVsTGluZUxlbjtcbiAgICAgICAgICB0ZXh0WSA9IHkyICsgNTtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4MiA9IHgxICsgbGFiZWxMaW5lTGVuO1xuICAgICAgICAgIHRleHRYID0geDIgKyA1O1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgIHgyID0geDE7XG4gICAgICAgIHRleHRYID0geDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5MiA9IHkxO1xuICAgICAgICB0ZXh0WSA9IHkyO1xuICAgICAgfVxuICAgICAgbGluZVBvaW50cyA9IFtbeDEsIHkxXSwgW3gyLCB5Ml1dO1xuICAgIH1cbiAgICBsYXlvdXQubGFiZWwgPSB7XG4gICAgICBsaW5lUG9pbnRzOiBsaW5lUG9pbnRzLFxuICAgICAgeDogdGV4dFgsXG4gICAgICB5OiB0ZXh0WSxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICBpbnNpZGU6IGlzTGFiZWxJbnNpZGVcbiAgICB9O1xuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZ1bm5lbExheW91dChlY01vZGVsLCBhcGkpIHtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdmdW5uZWwnLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgdmFsdWVEaW0gPSBkYXRhLm1hcERpbWVuc2lvbigndmFsdWUnKTtcbiAgICB2YXIgc29ydCA9IHNlcmllc01vZGVsLmdldCgnc29ydCcpO1xuICAgIHZhciB2aWV3UmVjdCA9IGdldFZpZXdSZWN0KHNlcmllc01vZGVsLCBhcGkpO1xuICAgIHZhciBvcmllbnQgPSBzZXJpZXNNb2RlbC5nZXQoJ29yaWVudCcpO1xuICAgIHZhciB2aWV3V2lkdGggPSB2aWV3UmVjdC53aWR0aDtcbiAgICB2YXIgdmlld0hlaWdodCA9IHZpZXdSZWN0LmhlaWdodDtcbiAgICB2YXIgaW5kaWNlcyA9IGdldFNvcnRlZEluZGljZXMoZGF0YSwgc29ydCk7XG4gICAgdmFyIHggPSB2aWV3UmVjdC54O1xuICAgIHZhciB5ID0gdmlld1JlY3QueTtcbiAgICB2YXIgc2l6ZUV4dGVudCA9IG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gW3BhcnNlUGVyY2VudChzZXJpZXNNb2RlbC5nZXQoJ21pblNpemUnKSwgdmlld0hlaWdodCksIHBhcnNlUGVyY2VudChzZXJpZXNNb2RlbC5nZXQoJ21heFNpemUnKSwgdmlld0hlaWdodCldIDogW3BhcnNlUGVyY2VudChzZXJpZXNNb2RlbC5nZXQoJ21pblNpemUnKSwgdmlld1dpZHRoKSwgcGFyc2VQZXJjZW50KHNlcmllc01vZGVsLmdldCgnbWF4U2l6ZScpLCB2aWV3V2lkdGgpXTtcbiAgICB2YXIgZGF0YUV4dGVudCA9IGRhdGEuZ2V0RGF0YUV4dGVudCh2YWx1ZURpbSk7XG4gICAgdmFyIG1pbiA9IHNlcmllc01vZGVsLmdldCgnbWluJyk7XG4gICAgdmFyIG1heCA9IHNlcmllc01vZGVsLmdldCgnbWF4Jyk7XG4gICAgaWYgKG1pbiA9PSBudWxsKSB7XG4gICAgICBtaW4gPSBNYXRoLm1pbihkYXRhRXh0ZW50WzBdLCAwKTtcbiAgICB9XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBkYXRhRXh0ZW50WzFdO1xuICAgIH1cbiAgICB2YXIgZnVubmVsQWxpZ24gPSBzZXJpZXNNb2RlbC5nZXQoJ2Z1bm5lbEFsaWduJyk7XG4gICAgdmFyIGdhcCA9IHNlcmllc01vZGVsLmdldCgnZ2FwJyk7XG4gICAgdmFyIHZpZXdTaXplID0gb3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyB2aWV3V2lkdGggOiB2aWV3SGVpZ2h0O1xuICAgIHZhciBpdGVtU2l6ZSA9ICh2aWV3U2l6ZSAtIGdhcCAqIChkYXRhLmNvdW50KCkgLSAxKSkgLyBkYXRhLmNvdW50KCk7XG4gICAgdmFyIGdldExpbmVQb2ludHMgPSBmdW5jdGlvbiAoaWR4LCBvZmZzZXQpIHtcbiAgICAgIC8vIEVuZCBwb2ludCBpbmRleCBpcyBkYXRhLmNvdW50KCkgYW5kIHdlIGFzc2lnbiBpdCAwXG4gICAgICBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgdmFyIHZhbF8xID0gZGF0YS5nZXQodmFsdWVEaW0sIGlkeCkgfHwgMDtcbiAgICAgICAgdmFyIGl0ZW1IZWlnaHQgPSBsaW5lYXJNYXAodmFsXzEsIFttaW4sIG1heF0sIHNpemVFeHRlbnQsIHRydWUpO1xuICAgICAgICB2YXIgeTAgPSB2b2lkIDA7XG4gICAgICAgIHN3aXRjaCAoZnVubmVsQWxpZ24pIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgeTAgPSB5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIHkwID0geSArICh2aWV3SGVpZ2h0IC0gaXRlbUhlaWdodCkgLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHkwID0geSArICh2aWV3SGVpZ2h0IC0gaXRlbUhlaWdodCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1tvZmZzZXQsIHkwXSwgW29mZnNldCwgeTAgKyBpdGVtSGVpZ2h0XV07XG4gICAgICB9XG4gICAgICB2YXIgdmFsID0gZGF0YS5nZXQodmFsdWVEaW0sIGlkeCkgfHwgMDtcbiAgICAgIHZhciBpdGVtV2lkdGggPSBsaW5lYXJNYXAodmFsLCBbbWluLCBtYXhdLCBzaXplRXh0ZW50LCB0cnVlKTtcbiAgICAgIHZhciB4MDtcbiAgICAgIHN3aXRjaCAoZnVubmVsQWxpZ24pIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgeDAgPSB4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIHgwID0geCArICh2aWV3V2lkdGggLSBpdGVtV2lkdGgpIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHgwID0geCArIHZpZXdXaWR0aCAtIGl0ZW1XaWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBbW3gwLCBvZmZzZXRdLCBbeDAgKyBpdGVtV2lkdGgsIG9mZnNldF1dO1xuICAgIH07XG4gICAgaWYgKHNvcnQgPT09ICdhc2NlbmRpbmcnKSB7XG4gICAgICAvLyBGcm9tIGJvdHRvbSB0byB0b3BcbiAgICAgIGl0ZW1TaXplID0gLWl0ZW1TaXplO1xuICAgICAgZ2FwID0gLWdhcDtcbiAgICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICB4ICs9IHZpZXdXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgKz0gdmlld0hlaWdodDtcbiAgICAgIH1cbiAgICAgIGluZGljZXMgPSBpbmRpY2VzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWR4ID0gaW5kaWNlc1tpXTtcbiAgICAgIHZhciBuZXh0SWR4ID0gaW5kaWNlc1tpICsgMV07XG4gICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICB2YXIgd2lkdGggPSBpdGVtTW9kZWwuZ2V0KFsnaXRlbVN0eWxlJywgJ3dpZHRoJ10pO1xuICAgICAgICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgIHdpZHRoID0gaXRlbVNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2lkdGggPSBwYXJzZVBlcmNlbnQod2lkdGgsIHZpZXdXaWR0aCk7XG4gICAgICAgICAgaWYgKHNvcnQgPT09ICdhc2NlbmRpbmcnKSB7XG4gICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gZ2V0TGluZVBvaW50cyhpZHgsIHgpO1xuICAgICAgICB2YXIgZW5kID0gZ2V0TGluZVBvaW50cyhuZXh0SWR4LCB4ICsgd2lkdGgpO1xuICAgICAgICB4ICs9IHdpZHRoICsgZ2FwO1xuICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCB7XG4gICAgICAgICAgcG9pbnRzOiBzdGFydC5jb25jYXQoZW5kLnNsaWNlKCkucmV2ZXJzZSgpKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSBpdGVtTW9kZWwuZ2V0KFsnaXRlbVN0eWxlJywgJ2hlaWdodCddKTtcbiAgICAgICAgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgaGVpZ2h0ID0gaXRlbVNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVpZ2h0ID0gcGFyc2VQZXJjZW50KGhlaWdodCwgdmlld0hlaWdodCk7XG4gICAgICAgICAgaWYgKHNvcnQgPT09ICdhc2NlbmRpbmcnKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSBnZXRMaW5lUG9pbnRzKGlkeCwgeSk7XG4gICAgICAgIHZhciBlbmQgPSBnZXRMaW5lUG9pbnRzKG5leHRJZHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB5ICs9IGhlaWdodCArIGdhcDtcbiAgICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwge1xuICAgICAgICAgIHBvaW50czogc3RhcnQuY29uY2F0KGVuZC5zbGljZSgpLnJldmVyc2UoKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxhYmVsTGF5b3V0KGRhdGEpO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBGdW5uZWxWaWV3IGZyb20gJy4vRnVubmVsVmlldy5qcyc7XG5pbXBvcnQgRnVubmVsU2VyaWVzTW9kZWwgZnJvbSAnLi9GdW5uZWxTZXJpZXMuanMnO1xuaW1wb3J0IGZ1bm5lbExheW91dCBmcm9tICcuL2Z1bm5lbExheW91dC5qcyc7XG5pbXBvcnQgZGF0YUZpbHRlciBmcm9tICcuLi8uLi9wcm9jZXNzb3IvZGF0YUZpbHRlci5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ2hhcnRWaWV3KEZ1bm5lbFZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChGdW5uZWxTZXJpZXNNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckxheW91dChmdW5uZWxMYXlvdXQpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJQcm9jZXNzb3IoZGF0YUZpbHRlcignZnVubmVsJykpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///74508\n")},88745:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n;// ./node_modules/echarts/lib/chart/graph/categoryFilter.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction categoryFilter(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n  if (!legendModels || !legendModels.length) {\n    return;\n  }\n  ecModel.eachSeriesByType('graph', function (graphSeries) {\n    var categoriesData = graphSeries.getCategoriesData();\n    var graph = graphSeries.getGraph();\n    var data = graph.data;\n    var categoryNames = categoriesData.mapArray(categoriesData.getName);\n    data.filterSelf(function (idx) {\n      var model = data.getItemModel(idx);\n      var category = model.getShallow('category');\n      if (category != null) {\n        if ((0,util.isNumber)(category)) {\n          category = categoryNames[category];\n        }\n        // If in any legend component the status is not selected.\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(category)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    });\n  });\n}\n;// ./node_modules/echarts/lib/chart/graph/categoryVisual.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction categoryVisual(ecModel) {\n  var paletteScope = {};\n  ecModel.eachSeriesByType('graph', function (seriesModel) {\n    var categoriesData = seriesModel.getCategoriesData();\n    var data = seriesModel.getData();\n    var categoryNameIdxMap = {};\n    categoriesData.each(function (idx) {\n      var name = categoriesData.getName(idx);\n      // Add prefix to avoid conflict with Object.prototype.\n      categoryNameIdxMap['ec-' + name] = idx;\n      var itemModel = categoriesData.getItemModel(idx);\n      var style = itemModel.getModel('itemStyle').getItemStyle();\n      if (!style.fill) {\n        // Get color from palette.\n        style.fill = seriesModel.getColorFromPalette(name, paletteScope);\n      }\n      categoriesData.setItemVisual(idx, 'style', style);\n      var symbolVisualList = ['symbol', 'symbolSize', 'symbolKeepAspect'];\n      for (var i = 0; i < symbolVisualList.length; i++) {\n        var symbolVisual = itemModel.getShallow(symbolVisualList[i], true);\n        if (symbolVisual != null) {\n          categoriesData.setItemVisual(idx, symbolVisualList[i], symbolVisual);\n        }\n      }\n    });\n    // Assign category color to visual\n    if (categoriesData.count()) {\n      data.each(function (idx) {\n        var model = data.getItemModel(idx);\n        var categoryIdx = model.getShallow('category');\n        if (categoryIdx != null) {\n          if ((0,util.isString)(categoryIdx)) {\n            categoryIdx = categoryNameIdxMap['ec-' + categoryIdx];\n          }\n          var categoryStyle = categoriesData.getItemVisual(categoryIdx, 'style');\n          var style = data.ensureUniqueItemVisual(idx, 'style');\n          (0,util.extend)(style, categoryStyle);\n          var visualList = ['symbol', 'symbolSize', 'symbolKeepAspect'];\n          for (var i = 0; i < visualList.length; i++) {\n            data.setItemVisual(idx, visualList[i], categoriesData.getItemVisual(categoryIdx, visualList[i]));\n          }\n        }\n      });\n    }\n  });\n}\n;// ./node_modules/echarts/lib/chart/graph/edgeVisual.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction normalize(a) {\n  if (!(a instanceof Array)) {\n    a = [a, a];\n  }\n  return a;\n}\nfunction graphEdgeVisual(ecModel) {\n  ecModel.eachSeriesByType('graph', function (seriesModel) {\n    var graph = seriesModel.getGraph();\n    var edgeData = seriesModel.getEdgeData();\n    var symbolType = normalize(seriesModel.get('edgeSymbol'));\n    var symbolSize = normalize(seriesModel.get('edgeSymbolSize'));\n    // const colorQuery = ['lineStyle', 'color'] as const;\n    // const opacityQuery = ['lineStyle', 'opacity'] as const;\n    edgeData.setVisual('fromSymbol', symbolType && symbolType[0]);\n    edgeData.setVisual('toSymbol', symbolType && symbolType[1]);\n    edgeData.setVisual('fromSymbolSize', symbolSize && symbolSize[0]);\n    edgeData.setVisual('toSymbolSize', symbolSize && symbolSize[1]);\n    edgeData.setVisual('style', seriesModel.getModel('lineStyle').getLineStyle());\n    edgeData.each(function (idx) {\n      var itemModel = edgeData.getItemModel(idx);\n      var edge = graph.getEdgeByIndex(idx);\n      var symbolType = normalize(itemModel.getShallow('symbol', true));\n      var symbolSize = normalize(itemModel.getShallow('symbolSize', true));\n      // Edge visual must after node visual\n      var style = itemModel.getModel('lineStyle').getLineStyle();\n      var existsStyle = edgeData.ensureUniqueItemVisual(idx, 'style');\n      (0,util.extend)(existsStyle, style);\n      switch (existsStyle.stroke) {\n        case 'source':\n          {\n            var nodeStyle = edge.node1.getVisual('style');\n            existsStyle.stroke = nodeStyle && nodeStyle.fill;\n            break;\n          }\n        case 'target':\n          {\n            var nodeStyle = edge.node2.getVisual('style');\n            existsStyle.stroke = nodeStyle && nodeStyle.fill;\n            break;\n          }\n      }\n      symbolType[0] && edge.setVisual('fromSymbol', symbolType[0]);\n      symbolType[1] && edge.setVisual('toSymbol', symbolType[1]);\n      symbolSize[0] && edge.setVisual('fromSymbolSize', symbolSize[0]);\n      symbolSize[1] && edge.setVisual('toSymbolSize', symbolSize[1]);\n    });\n  });\n}\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/vector.js\nvar vector = __webpack_require__(83509);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/multipleGraphEdgeHelper.js\nvar multipleGraphEdgeHelper = __webpack_require__(34747);\n;// ./node_modules/echarts/lib/chart/graph/simpleLayoutHelper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction simpleLayout(seriesModel) {\n  var coordSys = seriesModel.coordinateSystem;\n  if (coordSys && coordSys.type !== 'view') {\n    return;\n  }\n  var graph = seriesModel.getGraph();\n  graph.eachNode(function (node) {\n    var model = node.getModel();\n    node.setLayout([+model.get('x'), +model.get('y')]);\n  });\n  simpleLayoutEdge(graph, seriesModel);\n}\nfunction simpleLayoutEdge(graph, seriesModel) {\n  graph.eachEdge(function (edge, index) {\n    var curveness = util.retrieve3(edge.getModel().get(['lineStyle', 'curveness']), -(0,multipleGraphEdgeHelper/* getCurvenessForEdge */.bj)(edge, seriesModel, index, true), 0);\n    var p1 = vector.clone(edge.node1.getLayout());\n    var p2 = vector.clone(edge.node2.getLayout());\n    var points = [p1, p2];\n    if (+curveness) {\n      points.push([(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness]);\n    }\n    edge.setLayout(points);\n  });\n}\n;// ./node_modules/echarts/lib/chart/graph/simpleLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction graphSimpleLayout(ecModel, api) {\n  ecModel.eachSeriesByType('graph', function (seriesModel) {\n    var layout = seriesModel.get('layout');\n    var coordSys = seriesModel.coordinateSystem;\n    if (coordSys && coordSys.type !== 'view') {\n      var data_1 = seriesModel.getData();\n      var dimensions_1 = [];\n      (0,util.each)(coordSys.dimensions, function (coordDim) {\n        dimensions_1 = dimensions_1.concat(data_1.mapDimensionsAll(coordDim));\n      });\n      for (var dataIndex = 0; dataIndex < data_1.count(); dataIndex++) {\n        var value = [];\n        var hasValue = false;\n        for (var i = 0; i < dimensions_1.length; i++) {\n          var val = data_1.get(dimensions_1[i], dataIndex);\n          if (!isNaN(val)) {\n            hasValue = true;\n          }\n          value.push(val);\n        }\n        if (hasValue) {\n          data_1.setItemLayout(dataIndex, coordSys.dataToPoint(value));\n        } else {\n          // Also {Array.<number>}, not undefined to avoid if...else... statement\n          data_1.setItemLayout(dataIndex, [NaN, NaN]);\n        }\n      }\n      simpleLayoutEdge(data_1.graph, seriesModel);\n    } else if (!layout || layout === 'none') {\n      simpleLayout(seriesModel);\n    }\n  });\n}\n;// ./node_modules/echarts/lib/chart/graph/graphHelper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nfunction getNodeGlobalScale(seriesModel) {\n  var coordSys = seriesModel.coordinateSystem;\n  if (coordSys.type !== 'view') {\n    return 1;\n  }\n  var nodeScaleRatio = seriesModel.option.nodeScaleRatio;\n  var groupZoom = coordSys.scaleX;\n  // Scale node when zoom changes\n  var roamZoom = coordSys.getZoom();\n  var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;\n  return nodeScale / groupZoom;\n}\nfunction getSymbolSize(node) {\n  var symbolSize = node.getVisual('symbolSize');\n  if (symbolSize instanceof Array) {\n    symbolSize = (symbolSize[0] + symbolSize[1]) / 2;\n  }\n  return +symbolSize;\n}\n;// ./node_modules/echarts/lib/chart/graph/circularLayoutHelper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar PI = Math.PI;\nvar _symbolRadiansHalf = [];\n/**\r\n * `basedOn` can be:\r\n * 'value':\r\n *     This layout is not accurate and have same bad case. For example,\r\n *     if the min value is very smaller than the max value, the nodes\r\n *     with the min value probably overlap even though there is enough\r\n *     space to layout them. So we only use this approach in the as the\r\n *     init layout of the force layout.\r\n *     FIXME\r\n *     Probably we do not need this method any more but use\r\n *     `basedOn: 'symbolSize'` in force layout if\r\n *     delay its init operations to GraphView.\r\n * 'symbolSize':\r\n *     This approach work only if all of the symbol size calculated.\r\n *     That is, the progressive rendering is not applied to graph.\r\n *     FIXME\r\n *     If progressive rendering is applied to graph some day,\r\n *     probably we have to use `basedOn: 'value'`.\r\n */\nfunction circularLayout(seriesModel, basedOn, draggingNode, pointer) {\n  var coordSys = seriesModel.coordinateSystem;\n  if (coordSys && coordSys.type !== 'view') {\n    return;\n  }\n  var rect = coordSys.getBoundingRect();\n  var nodeData = seriesModel.getData();\n  var graph = nodeData.graph;\n  var cx = rect.width / 2 + rect.x;\n  var cy = rect.height / 2 + rect.y;\n  var r = Math.min(rect.width, rect.height) / 2;\n  var count = nodeData.count();\n  nodeData.setLayout({\n    cx: cx,\n    cy: cy\n  });\n  if (!count) {\n    return;\n  }\n  if (draggingNode) {\n    var _a = coordSys.pointToData(pointer),\n      tempX = _a[0],\n      tempY = _a[1];\n    var v = [tempX - cx, tempY - cy];\n    vector.normalize(v, v);\n    vector.scale(v, v, r);\n    draggingNode.setLayout([cx + v[0], cy + v[1]], true);\n    var circularRotateLabel = seriesModel.get(['circular', 'rotateLabel']);\n    rotateNodeLabel(draggingNode, circularRotateLabel, cx, cy);\n  }\n  _layoutNodesBasedOn[basedOn](seriesModel, graph, nodeData, r, cx, cy, count);\n  graph.eachEdge(function (edge, index) {\n    var curveness = util.retrieve3(edge.getModel().get(['lineStyle', 'curveness']), (0,multipleGraphEdgeHelper/* getCurvenessForEdge */.bj)(edge, seriesModel, index), 0);\n    var p1 = vector.clone(edge.node1.getLayout());\n    var p2 = vector.clone(edge.node2.getLayout());\n    var cp1;\n    var x12 = (p1[0] + p2[0]) / 2;\n    var y12 = (p1[1] + p2[1]) / 2;\n    if (+curveness) {\n      curveness *= 3;\n      cp1 = [cx * curveness + x12 * (1 - curveness), cy * curveness + y12 * (1 - curveness)];\n    }\n    edge.setLayout([p1, p2, cp1]);\n  });\n}\nvar _layoutNodesBasedOn = {\n  value: function (seriesModel, graph, nodeData, r, cx, cy, count) {\n    var angle = 0;\n    var sum = nodeData.getSum('value');\n    var unitAngle = Math.PI * 2 / (sum || count);\n    graph.eachNode(function (node) {\n      var value = node.getValue('value');\n      var radianHalf = unitAngle * (sum ? value : 1) / 2;\n      angle += radianHalf;\n      node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);\n      angle += radianHalf;\n    });\n  },\n  symbolSize: function (seriesModel, graph, nodeData, r, cx, cy, count) {\n    var sumRadian = 0;\n    _symbolRadiansHalf.length = count;\n    var nodeScale = getNodeGlobalScale(seriesModel);\n    graph.eachNode(function (node) {\n      var symbolSize = getSymbolSize(node);\n      // Normally this case will not happen, but we still add\n      // some the defensive code (2px is an arbitrary value).\n      isNaN(symbolSize) && (symbolSize = 2);\n      symbolSize < 0 && (symbolSize = 0);\n      symbolSize *= nodeScale;\n      var symbolRadianHalf = Math.asin(symbolSize / 2 / r);\n      // when `symbolSize / 2` is bigger than `r`.\n      isNaN(symbolRadianHalf) && (symbolRadianHalf = PI / 2);\n      _symbolRadiansHalf[node.dataIndex] = symbolRadianHalf;\n      sumRadian += symbolRadianHalf * 2;\n    });\n    var halfRemainRadian = (2 * PI - sumRadian) / count / 2;\n    var angle = 0;\n    graph.eachNode(function (node) {\n      var radianHalf = halfRemainRadian + _symbolRadiansHalf[node.dataIndex];\n      angle += radianHalf;\n      // init circular layout for\n      // 1. layout undefined node\n      // 2. not fixed node\n      (!node.getLayout() || !node.getLayout().fixed) && node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);\n      angle += radianHalf;\n    });\n  }\n};\nfunction rotateNodeLabel(node, circularRotateLabel, cx, cy) {\n  var el = node.getGraphicEl();\n  // need to check if el exists. '-' value may not create node element.\n  if (!el) {\n    return;\n  }\n  var nodeModel = node.getModel();\n  var labelRotate = nodeModel.get(['label', 'rotate']) || 0;\n  var symbolPath = el.getSymbolPath();\n  if (circularRotateLabel) {\n    var pos = node.getLayout();\n    var rad = Math.atan2(pos[1] - cy, pos[0] - cx);\n    if (rad < 0) {\n      rad = Math.PI * 2 + rad;\n    }\n    var isLeft = pos[0] < cx;\n    if (isLeft) {\n      rad = rad - Math.PI;\n    }\n    var textPosition = isLeft ? 'left' : 'right';\n    symbolPath.setTextConfig({\n      rotation: -rad,\n      position: textPosition,\n      origin: 'center'\n    });\n    var emphasisState = symbolPath.ensureState('emphasis');\n    util.extend(emphasisState.textConfig || (emphasisState.textConfig = {}), {\n      position: textPosition\n    });\n  } else {\n    symbolPath.setTextConfig({\n      rotation: labelRotate *= Math.PI / 180\n    });\n  }\n}\n;// ./node_modules/echarts/lib/chart/graph/circularLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction graphCircularLayout(ecModel) {\n  ecModel.eachSeriesByType('graph', function (seriesModel) {\n    if (seriesModel.get('layout') === 'circular') {\n      circularLayout(seriesModel, 'symbolSize');\n    }\n  });\n}\n;// ./node_modules/echarts/lib/chart/graph/forceHelper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/*\r\n* A third-party license is embedded for some of the code in this file:\r\n* Some formulas were originally copied from \"d3.js\" with some\r\n* modifications made for this project.\r\n* (See more details in the comment of the method \"step\" below.)\r\n* The use of the source code of this file is also subject to the terms\r\n* and consitions of the license of \"d3.js\" (BSD-3Clause, see\r\n* </licenses/LICENSE-d3>).\r\n*/\n\nvar scaleAndAdd = vector.scaleAndAdd;\n// function adjacentNode(n, e) {\n//     return e.n1 === n ? e.n2 : e.n1;\n// }\nfunction forceLayout(inNodes, inEdges, opts) {\n  var nodes = inNodes;\n  var edges = inEdges;\n  var rect = opts.rect;\n  var width = rect.width;\n  var height = rect.height;\n  var center = [rect.x + width / 2, rect.y + height / 2];\n  // let scale = opts.scale || 1;\n  var gravity = opts.gravity == null ? 0.1 : opts.gravity;\n  // for (let i = 0; i < edges.length; i++) {\n  //     let e = edges[i];\n  //     let n1 = e.n1;\n  //     let n2 = e.n2;\n  //     n1.edges = n1.edges || [];\n  //     n2.edges = n2.edges || [];\n  //     n1.edges.push(e);\n  //     n2.edges.push(e);\n  // }\n  // Init position\n  for (var i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    if (!n.p) {\n      n.p = vector.create(width * (Math.random() - 0.5) + center[0], height * (Math.random() - 0.5) + center[1]);\n    }\n    n.pp = vector.clone(n.p);\n    n.edges = null;\n  }\n  // Formula in 'Graph Drawing by Force-directed Placement'\n  // let k = scale * Math.sqrt(width * height / nodes.length);\n  // let k2 = k * k;\n  var initialFriction = opts.friction == null ? 0.6 : opts.friction;\n  var friction = initialFriction;\n  var beforeStepCallback;\n  var afterStepCallback;\n  return {\n    warmUp: function () {\n      friction = initialFriction * 0.8;\n    },\n    setFixed: function (idx) {\n      nodes[idx].fixed = true;\n    },\n    setUnfixed: function (idx) {\n      nodes[idx].fixed = false;\n    },\n    /**\r\n     * Before step hook\r\n     */\n    beforeStep: function (cb) {\n      beforeStepCallback = cb;\n    },\n    /**\r\n     * After step hook\r\n     */\n    afterStep: function (cb) {\n      afterStepCallback = cb;\n    },\n    /**\r\n     * Some formulas were originally copied from \"d3.js\"\r\n     * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js\r\n     * with some modifications made for this project.\r\n     * See the license statement at the head of this file.\r\n     */\n    step: function (cb) {\n      beforeStepCallback && beforeStepCallback(nodes, edges);\n      var v12 = [];\n      var nLen = nodes.length;\n      for (var i = 0; i < edges.length; i++) {\n        var e = edges[i];\n        if (e.ignoreForceLayout) {\n          continue;\n        }\n        var n1 = e.n1;\n        var n2 = e.n2;\n        vector.sub(v12, n2.p, n1.p);\n        var d = vector.len(v12) - e.d;\n        var w = n2.w / (n1.w + n2.w);\n        if (isNaN(w)) {\n          w = 0;\n        }\n        vector.normalize(v12, v12);\n        !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);\n        !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);\n      }\n      // Gravity\n      for (var i = 0; i < nLen; i++) {\n        var n = nodes[i];\n        if (!n.fixed) {\n          vector.sub(v12, center, n.p);\n          // let d = vec2.len(v12);\n          // vec2.scale(v12, v12, 1 / d);\n          // let gravityFactor = gravity;\n          scaleAndAdd(n.p, n.p, v12, gravity * friction);\n        }\n      }\n      // Repulsive\n      // PENDING\n      for (var i = 0; i < nLen; i++) {\n        var n1 = nodes[i];\n        for (var j = i + 1; j < nLen; j++) {\n          var n2 = nodes[j];\n          vector.sub(v12, n2.p, n1.p);\n          var d = vector.len(v12);\n          if (d === 0) {\n            // Random repulse\n            vector.set(v12, Math.random() - 0.5, Math.random() - 0.5);\n            d = 1;\n          }\n          var repFact = (n1.rep + n2.rep) / d / d;\n          !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);\n          !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);\n        }\n      }\n      var v = [];\n      for (var i = 0; i < nLen; i++) {\n        var n = nodes[i];\n        if (!n.fixed) {\n          vector.sub(v, n.p, n.pp);\n          scaleAndAdd(n.p, n.p, v, friction);\n          vector.copy(n.pp, n.p);\n        }\n      }\n      friction = friction * 0.992;\n      var finished = friction < 0.01;\n      afterStepCallback && afterStepCallback(nodes, edges, finished);\n      cb && cb(finished);\n    }\n  };\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n;// ./node_modules/echarts/lib/chart/graph/forceLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nfunction graphForceLayout(ecModel) {\n  ecModel.eachSeriesByType('graph', function (graphSeries) {\n    var coordSys = graphSeries.coordinateSystem;\n    if (coordSys && coordSys.type !== 'view') {\n      return;\n    }\n    if (graphSeries.get('layout') === 'force') {\n      var preservedPoints_1 = graphSeries.preservedPoints || {};\n      var graph_1 = graphSeries.getGraph();\n      var nodeData_1 = graph_1.data;\n      var edgeData = graph_1.edgeData;\n      var forceModel = graphSeries.getModel('force');\n      var initLayout = forceModel.get('initLayout');\n      if (graphSeries.preservedPoints) {\n        nodeData_1.each(function (idx) {\n          var id = nodeData_1.getId(idx);\n          nodeData_1.setItemLayout(idx, preservedPoints_1[id] || [NaN, NaN]);\n        });\n      } else if (!initLayout || initLayout === 'none') {\n        simpleLayout(graphSeries);\n      } else if (initLayout === 'circular') {\n        circularLayout(graphSeries, 'value');\n      }\n      var nodeDataExtent_1 = nodeData_1.getDataExtent('value');\n      var edgeDataExtent_1 = edgeData.getDataExtent('value');\n      // let edgeDataExtent = edgeData.getDataExtent('value');\n      var repulsion = forceModel.get('repulsion');\n      var edgeLength = forceModel.get('edgeLength');\n      var repulsionArr_1 = util.isArray(repulsion) ? repulsion : [repulsion, repulsion];\n      var edgeLengthArr_1 = util.isArray(edgeLength) ? edgeLength : [edgeLength, edgeLength];\n      // Larger value has smaller length\n      edgeLengthArr_1 = [edgeLengthArr_1[1], edgeLengthArr_1[0]];\n      var nodes_1 = nodeData_1.mapArray('value', function (value, idx) {\n        var point = nodeData_1.getItemLayout(idx);\n        var rep = (0,number/* linearMap */.Cb)(value, nodeDataExtent_1, repulsionArr_1);\n        if (isNaN(rep)) {\n          rep = (repulsionArr_1[0] + repulsionArr_1[1]) / 2;\n        }\n        return {\n          w: rep,\n          rep: rep,\n          fixed: nodeData_1.getItemModel(idx).get('fixed'),\n          p: !point || isNaN(point[0]) || isNaN(point[1]) ? null : point\n        };\n      });\n      var edges = edgeData.mapArray('value', function (value, idx) {\n        var edge = graph_1.getEdgeByIndex(idx);\n        var d = (0,number/* linearMap */.Cb)(value, edgeDataExtent_1, edgeLengthArr_1);\n        if (isNaN(d)) {\n          d = (edgeLengthArr_1[0] + edgeLengthArr_1[1]) / 2;\n        }\n        var edgeModel = edge.getModel();\n        var curveness = util.retrieve3(edge.getModel().get(['lineStyle', 'curveness']), -(0,multipleGraphEdgeHelper/* getCurvenessForEdge */.bj)(edge, graphSeries, idx, true), 0);\n        return {\n          n1: nodes_1[edge.node1.dataIndex],\n          n2: nodes_1[edge.node2.dataIndex],\n          d: d,\n          curveness: curveness,\n          ignoreForceLayout: edgeModel.get('ignoreForceLayout')\n        };\n      });\n      // let coordSys = graphSeries.coordinateSystem;\n      var rect = coordSys.getBoundingRect();\n      var forceInstance = forceLayout(nodes_1, edges, {\n        rect: rect,\n        gravity: forceModel.get('gravity'),\n        friction: forceModel.get('friction')\n      });\n      forceInstance.beforeStep(function (nodes, edges) {\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          if (nodes[i].fixed) {\n            // Write back to layout instance\n            vector.copy(nodes[i].p, graph_1.getNodeByIndex(i).getLayout());\n          }\n        }\n      });\n      forceInstance.afterStep(function (nodes, edges, stopped) {\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          if (!nodes[i].fixed) {\n            graph_1.getNodeByIndex(i).setLayout(nodes[i].p);\n          }\n          preservedPoints_1[nodeData_1.getId(i)] = nodes[i].p;\n        }\n        for (var i = 0, l = edges.length; i < l; i++) {\n          var e = edges[i];\n          var edge = graph_1.getEdgeByIndex(i);\n          var p1 = e.n1.p;\n          var p2 = e.n2.p;\n          var points = edge.getLayout();\n          points = points ? points.slice() : [];\n          points[0] = points[0] || [];\n          points[1] = points[1] || [];\n          vector.copy(points[0], p1);\n          vector.copy(points[1], p2);\n          if (+e.curveness) {\n            points[2] = [(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness];\n          }\n          edge.setLayout(points);\n        }\n      });\n      graphSeries.forceLayout = forceInstance;\n      graphSeries.preservedPoints = preservedPoints_1;\n      // Step to get the layout\n      forceInstance.step();\n    } else {\n      // Remove prev injected forceLayout instance\n      graphSeries.forceLayout = null;\n    }\n  });\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/View.js\nvar View = __webpack_require__(56219);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/bbox.js\nvar bbox = __webpack_require__(48813);\n;// ./node_modules/echarts/lib/chart/graph/createView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// FIXME Where to create the simple view coordinate system\n\n\n\n\nfunction getViewRect(seriesModel, api, aspect) {\n  var option = (0,util.extend)(seriesModel.getBoxLayoutParams(), {\n    aspect: aspect\n  });\n  return (0,layout/* getLayoutRect */.dV)(option, {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n}\nfunction createViewCoordSys(ecModel, api) {\n  var viewList = [];\n  ecModel.eachSeriesByType('graph', function (seriesModel) {\n    var coordSysType = seriesModel.get('coordinateSystem');\n    if (!coordSysType || coordSysType === 'view') {\n      var data_1 = seriesModel.getData();\n      var positions = data_1.mapArray(function (idx) {\n        var itemModel = data_1.getItemModel(idx);\n        return [+itemModel.get('x'), +itemModel.get('y')];\n      });\n      var min = [];\n      var max = [];\n      bbox/* fromPoints */.Cr(positions, min, max);\n      // If width or height is 0\n      if (max[0] - min[0] === 0) {\n        max[0] += 1;\n        min[0] -= 1;\n      }\n      if (max[1] - min[1] === 0) {\n        max[1] += 1;\n        min[1] -= 1;\n      }\n      var aspect = (max[0] - min[0]) / (max[1] - min[1]);\n      // FIXME If get view rect after data processed?\n      var viewRect = getViewRect(seriesModel, api, aspect);\n      // Position may be NaN, use view rect instead\n      if (isNaN(aspect)) {\n        min = [viewRect.x, viewRect.y];\n        max = [viewRect.x + viewRect.width, viewRect.y + viewRect.height];\n      }\n      var bbWidth = max[0] - min[0];\n      var bbHeight = max[1] - min[1];\n      var viewWidth = viewRect.width;\n      var viewHeight = viewRect.height;\n      var viewCoordSys = seriesModel.coordinateSystem = new View/* default */.A();\n      viewCoordSys.zoomLimit = seriesModel.get('scaleLimit');\n      viewCoordSys.setBoundingRect(min[0], min[1], bbWidth, bbHeight);\n      viewCoordSys.setViewRect(viewRect.x, viewRect.y, viewWidth, viewHeight);\n      // Update roam info\n      viewCoordSys.setCenter(seriesModel.get('center'), api);\n      viewCoordSys.setZoom(seriesModel.get('zoom'));\n      viewList.push(viewCoordSys);\n    }\n  });\n  return viewList;\n}\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/SymbolDraw.js\nvar SymbolDraw = __webpack_require__(18386);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/LineDraw.js\nvar LineDraw = __webpack_require__(64380);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/RoamController.js\nvar RoamController = __webpack_require__(81722);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/roamHelper.js\nvar roamHelper = __webpack_require__(56366);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/cursorHelper.js\nvar cursorHelper = __webpack_require__(72589);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/curve.js\nvar curve = __webpack_require__(89259);\n;// ./node_modules/echarts/lib/chart/graph/adjustEdge.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar v1 = [];\nvar v2 = [];\nvar v3 = [];\nvar quadraticAt = curve/* quadraticAt */.k3;\nvar v2DistSquare = vector.distSquare;\nvar mathAbs = Math.abs;\nfunction intersectCurveCircle(curvePoints, center, radius) {\n  var p0 = curvePoints[0];\n  var p1 = curvePoints[1];\n  var p2 = curvePoints[2];\n  var d = Infinity;\n  var t;\n  var radiusSquare = radius * radius;\n  var interval = 0.1;\n  for (var _t = 0.1; _t <= 0.9; _t += 0.1) {\n    v1[0] = quadraticAt(p0[0], p1[0], p2[0], _t);\n    v1[1] = quadraticAt(p0[1], p1[1], p2[1], _t);\n    var diff = mathAbs(v2DistSquare(v1, center) - radiusSquare);\n    if (diff < d) {\n      d = diff;\n      t = _t;\n    }\n  }\n  // Assume the segment is monotone，Find root through Bisection method\n  // At most 32 iteration\n  for (var i = 0; i < 32; i++) {\n    // let prev = t - interval;\n    var next = t + interval;\n    // v1[0] = quadraticAt(p0[0], p1[0], p2[0], prev);\n    // v1[1] = quadraticAt(p0[1], p1[1], p2[1], prev);\n    v2[0] = quadraticAt(p0[0], p1[0], p2[0], t);\n    v2[1] = quadraticAt(p0[1], p1[1], p2[1], t);\n    v3[0] = quadraticAt(p0[0], p1[0], p2[0], next);\n    v3[1] = quadraticAt(p0[1], p1[1], p2[1], next);\n    var diff = v2DistSquare(v2, center) - radiusSquare;\n    if (mathAbs(diff) < 1e-2) {\n      break;\n    }\n    // let prevDiff = v2DistSquare(v1, center) - radiusSquare;\n    var nextDiff = v2DistSquare(v3, center) - radiusSquare;\n    interval /= 2;\n    if (diff < 0) {\n      if (nextDiff >= 0) {\n        t = t + interval;\n      } else {\n        t = t - interval;\n      }\n    } else {\n      if (nextDiff >= 0) {\n        t = t - interval;\n      } else {\n        t = t + interval;\n      }\n    }\n  }\n  return t;\n}\n// Adjust edge to avoid\nfunction adjustEdge(graph, scale) {\n  var tmp0 = [];\n  var quadraticSubdivide = curve/* quadraticSubdivide */.kx;\n  var pts = [[], [], []];\n  var pts2 = [[], []];\n  var v = [];\n  scale /= 2;\n  graph.eachEdge(function (edge, idx) {\n    var linePoints = edge.getLayout();\n    var fromSymbol = edge.getVisual('fromSymbol');\n    var toSymbol = edge.getVisual('toSymbol');\n    if (!linePoints.__original) {\n      linePoints.__original = [vector.clone(linePoints[0]), vector.clone(linePoints[1])];\n      if (linePoints[2]) {\n        linePoints.__original.push(vector.clone(linePoints[2]));\n      }\n    }\n    var originalPoints = linePoints.__original;\n    // Quadratic curve\n    if (linePoints[2] != null) {\n      vector.copy(pts[0], originalPoints[0]);\n      vector.copy(pts[1], originalPoints[2]);\n      vector.copy(pts[2], originalPoints[1]);\n      if (fromSymbol && fromSymbol !== 'none') {\n        var symbolSize = getSymbolSize(edge.node1);\n        var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale);\n        // Subdivide and get the second\n        quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);\n        pts[0][0] = tmp0[3];\n        pts[1][0] = tmp0[4];\n        quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);\n        pts[0][1] = tmp0[3];\n        pts[1][1] = tmp0[4];\n      }\n      if (toSymbol && toSymbol !== 'none') {\n        var symbolSize = getSymbolSize(edge.node2);\n        var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale);\n        // Subdivide and get the first\n        quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);\n        pts[1][0] = tmp0[1];\n        pts[2][0] = tmp0[2];\n        quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);\n        pts[1][1] = tmp0[1];\n        pts[2][1] = tmp0[2];\n      }\n      // Copy back to layout\n      vector.copy(linePoints[0], pts[0]);\n      vector.copy(linePoints[1], pts[2]);\n      vector.copy(linePoints[2], pts[1]);\n    }\n    // Line\n    else {\n      vector.copy(pts2[0], originalPoints[0]);\n      vector.copy(pts2[1], originalPoints[1]);\n      vector.sub(v, pts2[1], pts2[0]);\n      vector.normalize(v, v);\n      if (fromSymbol && fromSymbol !== 'none') {\n        var symbolSize = getSymbolSize(edge.node1);\n        vector.scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale);\n      }\n      if (toSymbol && toSymbol !== 'none') {\n        var symbolSize = getSymbolSize(edge.node2);\n        vector.scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale);\n      }\n      vector.copy(linePoints[0], pts2[0]);\n      vector.copy(linePoints[1], pts2[1]);\n    }\n  });\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n;// ./node_modules/echarts/lib/chart/graph/GraphView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction isViewCoordSys(coordSys) {\n  return coordSys.type === 'view';\n}\nvar GraphView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(GraphView, _super);\n  function GraphView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = GraphView.type;\n    return _this;\n  }\n  GraphView.prototype.init = function (ecModel, api) {\n    var symbolDraw = new SymbolDraw/* default */.A();\n    var lineDraw = new LineDraw/* default */.A();\n    var group = this.group;\n    this._controller = new RoamController/* default */.A(api.getZr());\n    this._controllerHost = {\n      target: group\n    };\n    group.add(symbolDraw.group);\n    group.add(lineDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineDraw = lineDraw;\n    this._firstRender = true;\n  };\n  GraphView.prototype.render = function (seriesModel, ecModel, api) {\n    var _this = this;\n    var coordSys = seriesModel.coordinateSystem;\n    this._model = seriesModel;\n    var symbolDraw = this._symbolDraw;\n    var lineDraw = this._lineDraw;\n    var group = this.group;\n    if (isViewCoordSys(coordSys)) {\n      var groupNewProp = {\n        x: coordSys.x,\n        y: coordSys.y,\n        scaleX: coordSys.scaleX,\n        scaleY: coordSys.scaleY\n      };\n      if (this._firstRender) {\n        group.attr(groupNewProp);\n      } else {\n        basicTransition/* updateProps */.oi(group, groupNewProp, seriesModel);\n      }\n    }\n    // Fix edge contact point with node\n    adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));\n    var data = seriesModel.getData();\n    symbolDraw.updateData(data);\n    var edgeData = seriesModel.getEdgeData();\n    // TODO: TYPE\n    lineDraw.updateData(edgeData);\n    this._updateNodeAndLinkScale();\n    this._updateController(seriesModel, ecModel, api);\n    clearTimeout(this._layoutTimeout);\n    var forceLayout = seriesModel.forceLayout;\n    var layoutAnimation = seriesModel.get(['force', 'layoutAnimation']);\n    if (forceLayout) {\n      this._startForceLayoutIteration(forceLayout, layoutAnimation);\n    }\n    var layout = seriesModel.get('layout');\n    data.graph.eachNode(function (node) {\n      var idx = node.dataIndex;\n      var el = node.getGraphicEl();\n      var itemModel = node.getModel();\n      if (!el) {\n        return;\n      }\n      // Update draggable\n      el.off('drag').off('dragend');\n      var draggable = itemModel.get('draggable');\n      if (draggable) {\n        el.on('drag', function (e) {\n          switch (layout) {\n            case 'force':\n              forceLayout.warmUp();\n              !_this._layouting && _this._startForceLayoutIteration(forceLayout, layoutAnimation);\n              forceLayout.setFixed(idx);\n              // Write position back to layout\n              data.setItemLayout(idx, [el.x, el.y]);\n              break;\n            case 'circular':\n              data.setItemLayout(idx, [el.x, el.y]);\n              // mark node fixed\n              node.setLayout({\n                fixed: true\n              }, true);\n              // recalculate circular layout\n              circularLayout(seriesModel, 'symbolSize', node, [e.offsetX, e.offsetY]);\n              _this.updateLayout(seriesModel);\n              break;\n            case 'none':\n            default:\n              data.setItemLayout(idx, [el.x, el.y]);\n              // update edge\n              simpleLayoutEdge(seriesModel.getGraph(), seriesModel);\n              _this.updateLayout(seriesModel);\n              break;\n          }\n        }).on('dragend', function () {\n          if (forceLayout) {\n            forceLayout.setUnfixed(idx);\n          }\n        });\n      }\n      el.setDraggable(draggable, !!itemModel.get('cursor'));\n      var focus = itemModel.get(['emphasis', 'focus']);\n      if (focus === 'adjacency') {\n        (0,innerStore/* getECData */.z)(el).focus = node.getAdjacentDataIndices();\n      }\n    });\n    data.graph.eachEdge(function (edge) {\n      var el = edge.getGraphicEl();\n      var focus = edge.getModel().get(['emphasis', 'focus']);\n      if (!el) {\n        return;\n      }\n      if (focus === 'adjacency') {\n        (0,innerStore/* getECData */.z)(el).focus = {\n          edge: [edge.dataIndex],\n          node: [edge.node1.dataIndex, edge.node2.dataIndex]\n        };\n      }\n    });\n    var circularRotateLabel = seriesModel.get('layout') === 'circular' && seriesModel.get(['circular', 'rotateLabel']);\n    var cx = data.getLayout('cx');\n    var cy = data.getLayout('cy');\n    data.graph.eachNode(function (node) {\n      rotateNodeLabel(node, circularRotateLabel, cx, cy);\n    });\n    this._firstRender = false;\n  };\n  GraphView.prototype.dispose = function () {\n    this.remove();\n    this._controller && this._controller.dispose();\n    this._controllerHost = null;\n  };\n  GraphView.prototype._startForceLayoutIteration = function (forceLayout, layoutAnimation) {\n    var self = this;\n    (function step() {\n      forceLayout.step(function (stopped) {\n        self.updateLayout(self._model);\n        (self._layouting = !stopped) && (layoutAnimation ? self._layoutTimeout = setTimeout(step, 16) : step());\n      });\n    })();\n  };\n  GraphView.prototype._updateController = function (seriesModel, ecModel, api) {\n    var _this = this;\n    var controller = this._controller;\n    var controllerHost = this._controllerHost;\n    var group = this.group;\n    controller.setPointerChecker(function (e, x, y) {\n      var rect = group.getBoundingRect();\n      rect.applyTransform(group.transform);\n      return rect.contain(x, y) && !(0,cursorHelper/* onIrrelevantElement */.I)(e, api, seriesModel);\n    });\n    if (!isViewCoordSys(seriesModel.coordinateSystem)) {\n      controller.disable();\n      return;\n    }\n    controller.enable(seriesModel.get('roam'));\n    controllerHost.zoomLimit = seriesModel.get('scaleLimit');\n    controllerHost.zoom = seriesModel.coordinateSystem.getZoom();\n    controller.off('pan').off('zoom').on('pan', function (e) {\n      roamHelper/* updateViewOnPan */.t(controllerHost, e.dx, e.dy);\n      api.dispatchAction({\n        seriesId: seriesModel.id,\n        type: 'graphRoam',\n        dx: e.dx,\n        dy: e.dy\n      });\n    }).on('zoom', function (e) {\n      roamHelper/* updateViewOnZoom */.x(controllerHost, e.scale, e.originX, e.originY);\n      api.dispatchAction({\n        seriesId: seriesModel.id,\n        type: 'graphRoam',\n        zoom: e.scale,\n        originX: e.originX,\n        originY: e.originY\n      });\n      _this._updateNodeAndLinkScale();\n      adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));\n      _this._lineDraw.updateLayout();\n      // Only update label layout on zoom\n      api.updateLabelLayout();\n    });\n  };\n  GraphView.prototype._updateNodeAndLinkScale = function () {\n    var seriesModel = this._model;\n    var data = seriesModel.getData();\n    var nodeScale = getNodeGlobalScale(seriesModel);\n    data.eachItemGraphicEl(function (el, idx) {\n      el && el.setSymbolScale(nodeScale);\n    });\n  };\n  GraphView.prototype.updateLayout = function (seriesModel) {\n    adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));\n    this._symbolDraw.updateLayout();\n    this._lineDraw.updateLayout();\n  };\n  GraphView.prototype.remove = function () {\n    clearTimeout(this._layoutTimeout);\n    this._layouting = false;\n    this._layoutTimeout = null;\n    this._symbolDraw && this._symbolDraw.remove();\n    this._lineDraw && this._lineDraw.remove();\n  };\n  GraphView.type = 'graph';\n  return GraphView;\n}(Chart/* default */.A);\n/* harmony default export */ const graph_GraphView = (GraphView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/SeriesData.js\nvar SeriesData = __webpack_require__(6006);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Model.js + 2 modules\nvar Model = __webpack_require__(43172);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createGraphFromNodeEdge.js\nvar createGraphFromNodeEdge = __webpack_require__(62695);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/LegendVisualProvider.js\nvar LegendVisualProvider = __webpack_require__(58239);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js\nvar tooltipMarkup = __webpack_require__(3961);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/tooltip/seriesFormatTooltip.js\nvar seriesFormatTooltip = __webpack_require__(4235);\n;// ./node_modules/echarts/lib/chart/graph/GraphSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\nvar GraphSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(GraphSeriesModel, _super);\n  function GraphSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = GraphSeriesModel.type;\n    _this.hasSymbolVisual = true;\n    return _this;\n  }\n  GraphSeriesModel.prototype.init = function (option) {\n    _super.prototype.init.apply(this, arguments);\n    var self = this;\n    function getCategoriesData() {\n      return self._categoriesData;\n    }\n    // Provide data for legend select\n    this.legendVisualProvider = new LegendVisualProvider/* default */.A(getCategoriesData, getCategoriesData);\n    this.fillDataTextStyle(option.edges || option.links);\n    this._updateCategoriesData();\n  };\n  GraphSeriesModel.prototype.mergeOption = function (option) {\n    _super.prototype.mergeOption.apply(this, arguments);\n    this.fillDataTextStyle(option.edges || option.links);\n    this._updateCategoriesData();\n  };\n  GraphSeriesModel.prototype.mergeDefaultAndTheme = function (option) {\n    _super.prototype.mergeDefaultAndTheme.apply(this, arguments);\n    (0,model/* defaultEmphasis */.M5)(option, 'edgeLabel', ['show']);\n  };\n  GraphSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    var edges = option.edges || option.links || [];\n    var nodes = option.data || option.nodes || [];\n    var self = this;\n    if (nodes && edges) {\n      // auto curveness\n      (0,multipleGraphEdgeHelper/* initCurvenessList */.PH)(this);\n      var graph = (0,createGraphFromNodeEdge/* default */.A)(nodes, edges, this, true, beforeLink);\n      util.each(graph.edges, function (edge) {\n        (0,multipleGraphEdgeHelper/* createEdgeMapForCurveness */.$M)(edge.node1, edge.node2, this, edge.dataIndex);\n      }, this);\n      return graph.data;\n    }\n    function beforeLink(nodeData, edgeData) {\n      // Overwrite nodeData.getItemModel to\n      nodeData.wrapMethod('getItemModel', function (model) {\n        var categoriesModels = self._categoriesModels;\n        var categoryIdx = model.getShallow('category');\n        var categoryModel = categoriesModels[categoryIdx];\n        if (categoryModel) {\n          categoryModel.parentModel = model.parentModel;\n          model.parentModel = categoryModel;\n        }\n        return model;\n      });\n      // TODO Inherit resolveParentPath by default in Model#getModel?\n      var oldGetModel = Model/* default */.A.prototype.getModel;\n      function newGetModel(path, parentModel) {\n        var model = oldGetModel.call(this, path, parentModel);\n        model.resolveParentPath = resolveParentPath;\n        return model;\n      }\n      edgeData.wrapMethod('getItemModel', function (model) {\n        model.resolveParentPath = resolveParentPath;\n        model.getModel = newGetModel;\n        return model;\n      });\n      function resolveParentPath(pathArr) {\n        if (pathArr && (pathArr[0] === 'label' || pathArr[1] === 'label')) {\n          var newPathArr = pathArr.slice();\n          if (pathArr[0] === 'label') {\n            newPathArr[0] = 'edgeLabel';\n          } else if (pathArr[1] === 'label') {\n            newPathArr[1] = 'edgeLabel';\n          }\n          return newPathArr;\n        }\n        return pathArr;\n      }\n    }\n  };\n  GraphSeriesModel.prototype.getGraph = function () {\n    return this.getData().graph;\n  };\n  GraphSeriesModel.prototype.getEdgeData = function () {\n    return this.getGraph().edgeData;\n  };\n  GraphSeriesModel.prototype.getCategoriesData = function () {\n    return this._categoriesData;\n  };\n  GraphSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n    if (dataType === 'edge') {\n      var nodeData = this.getData();\n      var params = this.getDataParams(dataIndex, dataType);\n      var edge = nodeData.graph.getEdgeByIndex(dataIndex);\n      var sourceName = nodeData.getName(edge.node1.dataIndex);\n      var targetName = nodeData.getName(edge.node2.dataIndex);\n      var nameArr = [];\n      sourceName != null && nameArr.push(sourceName);\n      targetName != null && nameArr.push(targetName);\n      return (0,tooltipMarkup/* createTooltipMarkup */.Qx)('nameValue', {\n        name: nameArr.join(' > '),\n        value: params.value,\n        noValue: params.value == null\n      });\n    }\n    // dataType === 'node' or empty\n    var nodeMarkup = (0,seriesFormatTooltip/* defaultSeriesFormatTooltip */.J)({\n      series: this,\n      dataIndex: dataIndex,\n      multipleSeries: multipleSeries\n    });\n    return nodeMarkup;\n  };\n  GraphSeriesModel.prototype._updateCategoriesData = function () {\n    var categories = util.map(this.option.categories || [], function (category) {\n      // Data must has value\n      return category.value != null ? category : util.extend({\n        value: 0\n      }, category);\n    });\n    var categoriesData = new SeriesData/* default */.A(['value'], this);\n    categoriesData.initData(categories);\n    this._categoriesData = categoriesData;\n    this._categoriesModels = categoriesData.mapArray(function (idx) {\n      return categoriesData.getItemModel(idx);\n    });\n  };\n  GraphSeriesModel.prototype.setZoom = function (zoom) {\n    this.option.zoom = zoom;\n  };\n  GraphSeriesModel.prototype.setCenter = function (center) {\n    this.option.center = center;\n  };\n  GraphSeriesModel.prototype.isAnimationEnabled = function () {\n    return _super.prototype.isAnimationEnabled.call(this)\n    // Not enable animation when do force layout\n    && !(this.get('layout') === 'force' && this.get(['force', 'layoutAnimation']));\n  };\n  GraphSeriesModel.type = 'series.graph';\n  GraphSeriesModel.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar'];\n  GraphSeriesModel.defaultOption = {\n    // zlevel: 0,\n    z: 2,\n    coordinateSystem: 'view',\n    // Default option for all coordinate systems\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // geoIndex: 0,\n    legendHoverLink: true,\n    layout: null,\n    // Configuration of circular layout\n    circular: {\n      rotateLabel: false\n    },\n    // Configuration of force directed layout\n    force: {\n      initLayout: null,\n      // Node repulsion. Can be an array to represent range.\n      repulsion: [0, 50],\n      gravity: 0.1,\n      // Initial friction\n      friction: 0.6,\n      // Edge length. Can be an array to represent range.\n      edgeLength: 30,\n      layoutAnimation: true\n    },\n    left: 'center',\n    top: 'center',\n    // right: null,\n    // bottom: null,\n    // width: '80%',\n    // height: '80%',\n    symbol: 'circle',\n    symbolSize: 10,\n    edgeSymbol: ['none', 'none'],\n    edgeSymbolSize: 10,\n    edgeLabel: {\n      position: 'middle',\n      distance: 5\n    },\n    draggable: false,\n    roam: false,\n    // Default on center of graph\n    center: null,\n    zoom: 1,\n    // Symbol size scale ratio in roam\n    nodeScaleRatio: 0.6,\n    // cursor: null,\n    // categories: [],\n    // data: []\n    // Or\n    // nodes: []\n    //\n    // links: []\n    // Or\n    // edges: []\n    label: {\n      show: false,\n      formatter: '{b}'\n    },\n    itemStyle: {},\n    lineStyle: {\n      color: '#aaa',\n      width: 1,\n      opacity: 0.5\n    },\n    emphasis: {\n      scale: true,\n      label: {\n        show: true\n      }\n    },\n    select: {\n      itemStyle: {\n        borderColor: '#212121'\n      }\n    }\n  };\n  return GraphSeriesModel;\n}(Series/* default */.A);\n/* harmony default export */ const GraphSeries = (GraphSeriesModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/action/roamHelper.js\nvar action_roamHelper = __webpack_require__(78536);\n;// ./node_modules/echarts/lib/chart/graph/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\nvar actionInfo = {\n  type: 'graphRoam',\n  event: 'graphRoam',\n  update: 'none'\n};\nfunction install(registers) {\n  registers.registerChartView(graph_GraphView);\n  registers.registerSeriesModel(GraphSeries);\n  registers.registerProcessor(categoryFilter);\n  registers.registerVisual(categoryVisual);\n  registers.registerVisual(graphEdgeVisual);\n  registers.registerLayout(graphSimpleLayout);\n  registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, graphCircularLayout);\n  registers.registerLayout(graphForceLayout);\n  registers.registerCoordinateSystem('graphView', {\n    dimensions: View/* default */.A.dimensions,\n    create: createViewCoordSys\n  });\n  // Register legacy focus actions\n  registers.registerAction({\n    type: 'focusNodeAdjacency',\n    event: 'focusNodeAdjacency',\n    update: 'series:focusNodeAdjacency'\n  }, util.noop);\n  registers.registerAction({\n    type: 'unfocusNodeAdjacency',\n    event: 'unfocusNodeAdjacency',\n    update: 'series:unfocusNodeAdjacency'\n  }, util.noop);\n  // Register roam action.\n  registers.registerAction(actionInfo, function (payload, ecModel, api) {\n    ecModel.eachComponent({\n      mainType: 'series',\n      query: payload\n    }, function (seriesModel) {\n      var coordSys = seriesModel.coordinateSystem;\n      var res = (0,action_roamHelper/* updateCenterAndZoom */.f)(coordSys, payload, undefined, api);\n      seriesModel.setCenter && seriesModel.setCenter(res.center);\n      seriesModel.setZoom && seriesModel.setZoom(res.zoom);\n    });\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODg3NDUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dyYXBoL2NhdGVnb3J5RmlsdGVyLmpzPzA1MmYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dyYXBoL2NhdGVnb3J5VmlzdWFsLmpzPzhmNGQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dyYXBoL2VkZ2VWaXN1YWwuanM/YjEzNSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvZ3JhcGgvc2ltcGxlTGF5b3V0SGVscGVyLmpzP2E1NjIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dyYXBoL3NpbXBsZUxheW91dC5qcz85ZmYxIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ncmFwaC9ncmFwaEhlbHBlci5qcz82M2U2Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ncmFwaC9jaXJjdWxhckxheW91dEhlbHBlci5qcz82YTFmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ncmFwaC9jaXJjdWxhckxheW91dC5qcz9lMzZiIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ncmFwaC9mb3JjZUhlbHBlci5qcz84YmJmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ncmFwaC9mb3JjZUxheW91dC5qcz83YTIxIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ncmFwaC9jcmVhdGVWaWV3LmpzPzczMWUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dyYXBoL2FkanVzdEVkZ2UuanM/NGNjMiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvZ3JhcGgvR3JhcGhWaWV3LmpzP2RmZGQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dyYXBoL0dyYXBoU2VyaWVzLmpzPzM3ZTEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dyYXBoL2luc3RhbGwuanM/ZjJmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGlzTnVtYmVyIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhdGVnb3J5RmlsdGVyKGVjTW9kZWwpIHtcbiAgdmFyIGxlZ2VuZE1vZGVscyA9IGVjTW9kZWwuZmluZENvbXBvbmVudHMoe1xuICAgIG1haW5UeXBlOiAnbGVnZW5kJ1xuICB9KTtcbiAgaWYgKCFsZWdlbmRNb2RlbHMgfHwgIWxlZ2VuZE1vZGVscy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdncmFwaCcsIGZ1bmN0aW9uIChncmFwaFNlcmllcykge1xuICAgIHZhciBjYXRlZ29yaWVzRGF0YSA9IGdyYXBoU2VyaWVzLmdldENhdGVnb3JpZXNEYXRhKCk7XG4gICAgdmFyIGdyYXBoID0gZ3JhcGhTZXJpZXMuZ2V0R3JhcGgoKTtcbiAgICB2YXIgZGF0YSA9IGdyYXBoLmRhdGE7XG4gICAgdmFyIGNhdGVnb3J5TmFtZXMgPSBjYXRlZ29yaWVzRGF0YS5tYXBBcnJheShjYXRlZ29yaWVzRGF0YS5nZXROYW1lKTtcbiAgICBkYXRhLmZpbHRlclNlbGYoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIG1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgIHZhciBjYXRlZ29yeSA9IG1vZGVsLmdldFNoYWxsb3coJ2NhdGVnb3J5Jyk7XG4gICAgICBpZiAoY2F0ZWdvcnkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoY2F0ZWdvcnkpKSB7XG4gICAgICAgICAgY2F0ZWdvcnkgPSBjYXRlZ29yeU5hbWVzW2NhdGVnb3J5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBpbiBhbnkgbGVnZW5kIGNvbXBvbmVudCB0aGUgc3RhdHVzIGlzIG5vdCBzZWxlY3RlZC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWdlbmRNb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWxlZ2VuZE1vZGVsc1tpXS5pc1NlbGVjdGVkKGNhdGVnb3J5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgZXh0ZW5kLCBpc1N0cmluZyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYXRlZ29yeVZpc3VhbChlY01vZGVsKSB7XG4gIHZhciBwYWxldHRlU2NvcGUgPSB7fTtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdncmFwaCcsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjYXRlZ29yaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldENhdGVnb3JpZXNEYXRhKCk7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGNhdGVnb3J5TmFtZUlkeE1hcCA9IHt9O1xuICAgIGNhdGVnb3JpZXNEYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIG5hbWUgPSBjYXRlZ29yaWVzRGF0YS5nZXROYW1lKGlkeCk7XG4gICAgICAvLyBBZGQgcHJlZml4IHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZS5cbiAgICAgIGNhdGVnb3J5TmFtZUlkeE1hcFsnZWMtJyArIG5hbWVdID0gaWR4O1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGNhdGVnb3JpZXNEYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgdmFyIHN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgIGlmICghc3R5bGUuZmlsbCkge1xuICAgICAgICAvLyBHZXQgY29sb3IgZnJvbSBwYWxldHRlLlxuICAgICAgICBzdHlsZS5maWxsID0gc2VyaWVzTW9kZWwuZ2V0Q29sb3JGcm9tUGFsZXR0ZShuYW1lLCBwYWxldHRlU2NvcGUpO1xuICAgICAgfVxuICAgICAgY2F0ZWdvcmllc0RhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdzdHlsZScsIHN0eWxlKTtcbiAgICAgIHZhciBzeW1ib2xWaXN1YWxMaXN0ID0gWydzeW1ib2wnLCAnc3ltYm9sU2l6ZScsICdzeW1ib2xLZWVwQXNwZWN0J107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbFZpc3VhbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN5bWJvbFZpc3VhbCA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KHN5bWJvbFZpc3VhbExpc3RbaV0sIHRydWUpO1xuICAgICAgICBpZiAoc3ltYm9sVmlzdWFsICE9IG51bGwpIHtcbiAgICAgICAgICBjYXRlZ29yaWVzRGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwgc3ltYm9sVmlzdWFsTGlzdFtpXSwgc3ltYm9sVmlzdWFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFzc2lnbiBjYXRlZ29yeSBjb2xvciB0byB2aXN1YWxcbiAgICBpZiAoY2F0ZWdvcmllc0RhdGEuY291bnQoKSkge1xuICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgICAgdmFyIGNhdGVnb3J5SWR4ID0gbW9kZWwuZ2V0U2hhbGxvdygnY2F0ZWdvcnknKTtcbiAgICAgICAgaWYgKGNhdGVnb3J5SWR4ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoaXNTdHJpbmcoY2F0ZWdvcnlJZHgpKSB7XG4gICAgICAgICAgICBjYXRlZ29yeUlkeCA9IGNhdGVnb3J5TmFtZUlkeE1hcFsnZWMtJyArIGNhdGVnb3J5SWR4XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNhdGVnb3J5U3R5bGUgPSBjYXRlZ29yaWVzRGF0YS5nZXRJdGVtVmlzdWFsKGNhdGVnb3J5SWR4LCAnc3R5bGUnKTtcbiAgICAgICAgICB2YXIgc3R5bGUgPSBkYXRhLmVuc3VyZVVuaXF1ZUl0ZW1WaXN1YWwoaWR4LCAnc3R5bGUnKTtcbiAgICAgICAgICBleHRlbmQoc3R5bGUsIGNhdGVnb3J5U3R5bGUpO1xuICAgICAgICAgIHZhciB2aXN1YWxMaXN0ID0gWydzeW1ib2wnLCAnc3ltYm9sU2l6ZScsICdzeW1ib2xLZWVwQXNwZWN0J107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aXN1YWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCB2aXN1YWxMaXN0W2ldLCBjYXRlZ29yaWVzRGF0YS5nZXRJdGVtVmlzdWFsKGNhdGVnb3J5SWR4LCB2aXN1YWxMaXN0W2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmZ1bmN0aW9uIG5vcm1hbGl6ZShhKSB7XG4gIGlmICghKGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICBhID0gW2EsIGFdO1xuICB9XG4gIHJldHVybiBhO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ3JhcGhFZGdlVmlzdWFsKGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdncmFwaCcsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBncmFwaCA9IHNlcmllc01vZGVsLmdldEdyYXBoKCk7XG4gICAgdmFyIGVkZ2VEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RWRnZURhdGEoKTtcbiAgICB2YXIgc3ltYm9sVHlwZSA9IG5vcm1hbGl6ZShzZXJpZXNNb2RlbC5nZXQoJ2VkZ2VTeW1ib2wnKSk7XG4gICAgdmFyIHN5bWJvbFNpemUgPSBub3JtYWxpemUoc2VyaWVzTW9kZWwuZ2V0KCdlZGdlU3ltYm9sU2l6ZScpKTtcbiAgICAvLyBjb25zdCBjb2xvclF1ZXJ5ID0gWydsaW5lU3R5bGUnLCAnY29sb3InXSBhcyBjb25zdDtcbiAgICAvLyBjb25zdCBvcGFjaXR5UXVlcnkgPSBbJ2xpbmVTdHlsZScsICdvcGFjaXR5J10gYXMgY29uc3Q7XG4gICAgZWRnZURhdGEuc2V0VmlzdWFsKCdmcm9tU3ltYm9sJywgc3ltYm9sVHlwZSAmJiBzeW1ib2xUeXBlWzBdKTtcbiAgICBlZGdlRGF0YS5zZXRWaXN1YWwoJ3RvU3ltYm9sJywgc3ltYm9sVHlwZSAmJiBzeW1ib2xUeXBlWzFdKTtcbiAgICBlZGdlRGF0YS5zZXRWaXN1YWwoJ2Zyb21TeW1ib2xTaXplJywgc3ltYm9sU2l6ZSAmJiBzeW1ib2xTaXplWzBdKTtcbiAgICBlZGdlRGF0YS5zZXRWaXN1YWwoJ3RvU3ltYm9sU2l6ZScsIHN5bWJvbFNpemUgJiYgc3ltYm9sU2l6ZVsxXSk7XG4gICAgZWRnZURhdGEuc2V0VmlzdWFsKCdzdHlsZScsIHNlcmllc01vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKSk7XG4gICAgZWRnZURhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgaXRlbU1vZGVsID0gZWRnZURhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICB2YXIgZWRnZSA9IGdyYXBoLmdldEVkZ2VCeUluZGV4KGlkeCk7XG4gICAgICB2YXIgc3ltYm9sVHlwZSA9IG5vcm1hbGl6ZShpdGVtTW9kZWwuZ2V0U2hhbGxvdygnc3ltYm9sJywgdHJ1ZSkpO1xuICAgICAgdmFyIHN5bWJvbFNpemUgPSBub3JtYWxpemUoaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbFNpemUnLCB0cnVlKSk7XG4gICAgICAvLyBFZGdlIHZpc3VhbCBtdXN0IGFmdGVyIG5vZGUgdmlzdWFsXG4gICAgICB2YXIgc3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpO1xuICAgICAgdmFyIGV4aXN0c1N0eWxlID0gZWRnZURhdGEuZW5zdXJlVW5pcXVlSXRlbVZpc3VhbChpZHgsICdzdHlsZScpO1xuICAgICAgZXh0ZW5kKGV4aXN0c1N0eWxlLCBzdHlsZSk7XG4gICAgICBzd2l0Y2ggKGV4aXN0c1N0eWxlLnN0cm9rZSkge1xuICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBub2RlU3R5bGUgPSBlZGdlLm5vZGUxLmdldFZpc3VhbCgnc3R5bGUnKTtcbiAgICAgICAgICAgIGV4aXN0c1N0eWxlLnN0cm9rZSA9IG5vZGVTdHlsZSAmJiBub2RlU3R5bGUuZmlsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbm9kZVN0eWxlID0gZWRnZS5ub2RlMi5nZXRWaXN1YWwoJ3N0eWxlJyk7XG4gICAgICAgICAgICBleGlzdHNTdHlsZS5zdHJva2UgPSBub2RlU3R5bGUgJiYgbm9kZVN0eWxlLmZpbGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBzeW1ib2xUeXBlWzBdICYmIGVkZ2Uuc2V0VmlzdWFsKCdmcm9tU3ltYm9sJywgc3ltYm9sVHlwZVswXSk7XG4gICAgICBzeW1ib2xUeXBlWzFdICYmIGVkZ2Uuc2V0VmlzdWFsKCd0b1N5bWJvbCcsIHN5bWJvbFR5cGVbMV0pO1xuICAgICAgc3ltYm9sU2l6ZVswXSAmJiBlZGdlLnNldFZpc3VhbCgnZnJvbVN5bWJvbFNpemUnLCBzeW1ib2xTaXplWzBdKTtcbiAgICAgIHN5bWJvbFNpemVbMV0gJiYgZWRnZS5zZXRWaXN1YWwoJ3RvU3ltYm9sU2l6ZScsIHN5bWJvbFNpemVbMV0pO1xuICAgIH0pO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnenJlbmRlci9saWIvY29yZS92ZWN0b3IuanMnO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBnZXRDdXJ2ZW5lc3NGb3JFZGdlIH0gZnJvbSAnLi4vaGVscGVyL211bHRpcGxlR3JhcGhFZGdlSGVscGVyLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGVMYXlvdXQoc2VyaWVzTW9kZWwpIHtcbiAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgaWYgKGNvb3JkU3lzICYmIGNvb3JkU3lzLnR5cGUgIT09ICd2aWV3Jykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZ3JhcGggPSBzZXJpZXNNb2RlbC5nZXRHcmFwaCgpO1xuICBncmFwaC5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBtb2RlbCA9IG5vZGUuZ2V0TW9kZWwoKTtcbiAgICBub2RlLnNldExheW91dChbK21vZGVsLmdldCgneCcpLCArbW9kZWwuZ2V0KCd5JyldKTtcbiAgfSk7XG4gIHNpbXBsZUxheW91dEVkZ2UoZ3JhcGgsIHNlcmllc01vZGVsKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGVMYXlvdXRFZGdlKGdyYXBoLCBzZXJpZXNNb2RlbCkge1xuICBncmFwaC5lYWNoRWRnZShmdW5jdGlvbiAoZWRnZSwgaW5kZXgpIHtcbiAgICB2YXIgY3VydmVuZXNzID0genJVdGlsLnJldHJpZXZlMyhlZGdlLmdldE1vZGVsKCkuZ2V0KFsnbGluZVN0eWxlJywgJ2N1cnZlbmVzcyddKSwgLWdldEN1cnZlbmVzc0ZvckVkZ2UoZWRnZSwgc2VyaWVzTW9kZWwsIGluZGV4LCB0cnVlKSwgMCk7XG4gICAgdmFyIHAxID0gdmVjMi5jbG9uZShlZGdlLm5vZGUxLmdldExheW91dCgpKTtcbiAgICB2YXIgcDIgPSB2ZWMyLmNsb25lKGVkZ2Uubm9kZTIuZ2V0TGF5b3V0KCkpO1xuICAgIHZhciBwb2ludHMgPSBbcDEsIHAyXTtcbiAgICBpZiAoK2N1cnZlbmVzcykge1xuICAgICAgcG9pbnRzLnB1c2goWyhwMVswXSArIHAyWzBdKSAvIDIgLSAocDFbMV0gLSBwMlsxXSkgKiBjdXJ2ZW5lc3MsIChwMVsxXSArIHAyWzFdKSAvIDIgLSAocDJbMF0gLSBwMVswXSkgKiBjdXJ2ZW5lc3NdKTtcbiAgICB9XG4gICAgZWRnZS5zZXRMYXlvdXQocG9pbnRzKTtcbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IHNpbXBsZUxheW91dCwgc2ltcGxlTGF5b3V0RWRnZSB9IGZyb20gJy4vc2ltcGxlTGF5b3V0SGVscGVyLmpzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdyYXBoU2ltcGxlTGF5b3V0KGVjTW9kZWwsIGFwaSkge1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ2dyYXBoJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGxheW91dCA9IHNlcmllc01vZGVsLmdldCgnbGF5b3V0Jyk7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMudHlwZSAhPT0gJ3ZpZXcnKSB7XG4gICAgICB2YXIgZGF0YV8xID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgdmFyIGRpbWVuc2lvbnNfMSA9IFtdO1xuICAgICAgZWFjaChjb29yZFN5cy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoY29vcmREaW0pIHtcbiAgICAgICAgZGltZW5zaW9uc18xID0gZGltZW5zaW9uc18xLmNvbmNhdChkYXRhXzEubWFwRGltZW5zaW9uc0FsbChjb29yZERpbSkpO1xuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBkYXRhSW5kZXggPSAwOyBkYXRhSW5kZXggPCBkYXRhXzEuY291bnQoKTsgZGF0YUluZGV4KyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gW107XG4gICAgICAgIHZhciBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnNfMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB2YWwgPSBkYXRhXzEuZ2V0KGRpbWVuc2lvbnNfMVtpXSwgZGF0YUluZGV4KTtcbiAgICAgICAgICBpZiAoIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNWYWx1ZSkge1xuICAgICAgICAgIGRhdGFfMS5zZXRJdGVtTGF5b3V0KGRhdGFJbmRleCwgY29vcmRTeXMuZGF0YVRvUG9pbnQodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbHNvIHtBcnJheS48bnVtYmVyPn0sIG5vdCB1bmRlZmluZWQgdG8gYXZvaWQgaWYuLi5lbHNlLi4uIHN0YXRlbWVudFxuICAgICAgICAgIGRhdGFfMS5zZXRJdGVtTGF5b3V0KGRhdGFJbmRleCwgW05hTiwgTmFOXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNpbXBsZUxheW91dEVkZ2UoZGF0YV8xLmdyYXBoLCBzZXJpZXNNb2RlbCk7XG4gICAgfSBlbHNlIGlmICghbGF5b3V0IHx8IGxheW91dCA9PT0gJ25vbmUnKSB7XG4gICAgICBzaW1wbGVMYXlvdXQoc2VyaWVzTW9kZWwpO1xuICAgIH1cbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZUdsb2JhbFNjYWxlKHNlcmllc01vZGVsKSB7XG4gIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gIGlmIChjb29yZFN5cy50eXBlICE9PSAndmlldycpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICB2YXIgbm9kZVNjYWxlUmF0aW8gPSBzZXJpZXNNb2RlbC5vcHRpb24ubm9kZVNjYWxlUmF0aW87XG4gIHZhciBncm91cFpvb20gPSBjb29yZFN5cy5zY2FsZVg7XG4gIC8vIFNjYWxlIG5vZGUgd2hlbiB6b29tIGNoYW5nZXNcbiAgdmFyIHJvYW1ab29tID0gY29vcmRTeXMuZ2V0Wm9vbSgpO1xuICB2YXIgbm9kZVNjYWxlID0gKHJvYW1ab29tIC0gMSkgKiBub2RlU2NhbGVSYXRpbyArIDE7XG4gIHJldHVybiBub2RlU2NhbGUgLyBncm91cFpvb207XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U3ltYm9sU2l6ZShub2RlKSB7XG4gIHZhciBzeW1ib2xTaXplID0gbm9kZS5nZXRWaXN1YWwoJ3N5bWJvbFNpemUnKTtcbiAgaWYgKHN5bWJvbFNpemUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHN5bWJvbFNpemUgPSAoc3ltYm9sU2l6ZVswXSArIHN5bWJvbFNpemVbMV0pIC8gMjtcbiAgfVxuICByZXR1cm4gK3N5bWJvbFNpemU7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzJztcbmltcG9ydCB7IGdldFN5bWJvbFNpemUsIGdldE5vZGVHbG9iYWxTY2FsZSB9IGZyb20gJy4vZ3JhcGhIZWxwZXIuanMnO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBnZXRDdXJ2ZW5lc3NGb3JFZGdlIH0gZnJvbSAnLi4vaGVscGVyL211bHRpcGxlR3JhcGhFZGdlSGVscGVyLmpzJztcbnZhciBQSSA9IE1hdGguUEk7XG52YXIgX3N5bWJvbFJhZGlhbnNIYWxmID0gW107XG4vKipcclxuICogYGJhc2VkT25gIGNhbiBiZTpcclxuICogJ3ZhbHVlJzpcclxuICogICAgIFRoaXMgbGF5b3V0IGlzIG5vdCBhY2N1cmF0ZSBhbmQgaGF2ZSBzYW1lIGJhZCBjYXNlLiBGb3IgZXhhbXBsZSxcclxuICogICAgIGlmIHRoZSBtaW4gdmFsdWUgaXMgdmVyeSBzbWFsbGVyIHRoYW4gdGhlIG1heCB2YWx1ZSwgdGhlIG5vZGVzXHJcbiAqICAgICB3aXRoIHRoZSBtaW4gdmFsdWUgcHJvYmFibHkgb3ZlcmxhcCBldmVuIHRob3VnaCB0aGVyZSBpcyBlbm91Z2hcclxuICogICAgIHNwYWNlIHRvIGxheW91dCB0aGVtLiBTbyB3ZSBvbmx5IHVzZSB0aGlzIGFwcHJvYWNoIGluIHRoZSBhcyB0aGVcclxuICogICAgIGluaXQgbGF5b3V0IG9mIHRoZSBmb3JjZSBsYXlvdXQuXHJcbiAqICAgICBGSVhNRVxyXG4gKiAgICAgUHJvYmFibHkgd2UgZG8gbm90IG5lZWQgdGhpcyBtZXRob2QgYW55IG1vcmUgYnV0IHVzZVxyXG4gKiAgICAgYGJhc2VkT246ICdzeW1ib2xTaXplJ2AgaW4gZm9yY2UgbGF5b3V0IGlmXHJcbiAqICAgICBkZWxheSBpdHMgaW5pdCBvcGVyYXRpb25zIHRvIEdyYXBoVmlldy5cclxuICogJ3N5bWJvbFNpemUnOlxyXG4gKiAgICAgVGhpcyBhcHByb2FjaCB3b3JrIG9ubHkgaWYgYWxsIG9mIHRoZSBzeW1ib2wgc2l6ZSBjYWxjdWxhdGVkLlxyXG4gKiAgICAgVGhhdCBpcywgdGhlIHByb2dyZXNzaXZlIHJlbmRlcmluZyBpcyBub3QgYXBwbGllZCB0byBncmFwaC5cclxuICogICAgIEZJWE1FXHJcbiAqICAgICBJZiBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgaXMgYXBwbGllZCB0byBncmFwaCBzb21lIGRheSxcclxuICogICAgIHByb2JhYmx5IHdlIGhhdmUgdG8gdXNlIGBiYXNlZE9uOiAndmFsdWUnYC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2lyY3VsYXJMYXlvdXQoc2VyaWVzTW9kZWwsIGJhc2VkT24sIGRyYWdnaW5nTm9kZSwgcG9pbnRlcikge1xuICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMudHlwZSAhPT0gJ3ZpZXcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWN0ID0gY29vcmRTeXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gIHZhciBub2RlRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGdyYXBoID0gbm9kZURhdGEuZ3JhcGg7XG4gIHZhciBjeCA9IHJlY3Qud2lkdGggLyAyICsgcmVjdC54O1xuICB2YXIgY3kgPSByZWN0LmhlaWdodCAvIDIgKyByZWN0Lnk7XG4gIHZhciByID0gTWF0aC5taW4ocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpIC8gMjtcbiAgdmFyIGNvdW50ID0gbm9kZURhdGEuY291bnQoKTtcbiAgbm9kZURhdGEuc2V0TGF5b3V0KHtcbiAgICBjeDogY3gsXG4gICAgY3k6IGN5XG4gIH0pO1xuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChkcmFnZ2luZ05vZGUpIHtcbiAgICB2YXIgX2EgPSBjb29yZFN5cy5wb2ludFRvRGF0YShwb2ludGVyKSxcbiAgICAgIHRlbXBYID0gX2FbMF0sXG4gICAgICB0ZW1wWSA9IF9hWzFdO1xuICAgIHZhciB2ID0gW3RlbXBYIC0gY3gsIHRlbXBZIC0gY3ldO1xuICAgIHZlYzIubm9ybWFsaXplKHYsIHYpO1xuICAgIHZlYzIuc2NhbGUodiwgdiwgcik7XG4gICAgZHJhZ2dpbmdOb2RlLnNldExheW91dChbY3ggKyB2WzBdLCBjeSArIHZbMV1dLCB0cnVlKTtcbiAgICB2YXIgY2lyY3VsYXJSb3RhdGVMYWJlbCA9IHNlcmllc01vZGVsLmdldChbJ2NpcmN1bGFyJywgJ3JvdGF0ZUxhYmVsJ10pO1xuICAgIHJvdGF0ZU5vZGVMYWJlbChkcmFnZ2luZ05vZGUsIGNpcmN1bGFyUm90YXRlTGFiZWwsIGN4LCBjeSk7XG4gIH1cbiAgX2xheW91dE5vZGVzQmFzZWRPbltiYXNlZE9uXShzZXJpZXNNb2RlbCwgZ3JhcGgsIG5vZGVEYXRhLCByLCBjeCwgY3ksIGNvdW50KTtcbiAgZ3JhcGguZWFjaEVkZ2UoZnVuY3Rpb24gKGVkZ2UsIGluZGV4KSB7XG4gICAgdmFyIGN1cnZlbmVzcyA9IHpyVXRpbC5yZXRyaWV2ZTMoZWRnZS5nZXRNb2RlbCgpLmdldChbJ2xpbmVTdHlsZScsICdjdXJ2ZW5lc3MnXSksIGdldEN1cnZlbmVzc0ZvckVkZ2UoZWRnZSwgc2VyaWVzTW9kZWwsIGluZGV4KSwgMCk7XG4gICAgdmFyIHAxID0gdmVjMi5jbG9uZShlZGdlLm5vZGUxLmdldExheW91dCgpKTtcbiAgICB2YXIgcDIgPSB2ZWMyLmNsb25lKGVkZ2Uubm9kZTIuZ2V0TGF5b3V0KCkpO1xuICAgIHZhciBjcDE7XG4gICAgdmFyIHgxMiA9IChwMVswXSArIHAyWzBdKSAvIDI7XG4gICAgdmFyIHkxMiA9IChwMVsxXSArIHAyWzFdKSAvIDI7XG4gICAgaWYgKCtjdXJ2ZW5lc3MpIHtcbiAgICAgIGN1cnZlbmVzcyAqPSAzO1xuICAgICAgY3AxID0gW2N4ICogY3VydmVuZXNzICsgeDEyICogKDEgLSBjdXJ2ZW5lc3MpLCBjeSAqIGN1cnZlbmVzcyArIHkxMiAqICgxIC0gY3VydmVuZXNzKV07XG4gICAgfVxuICAgIGVkZ2Uuc2V0TGF5b3V0KFtwMSwgcDIsIGNwMV0pO1xuICB9KTtcbn1cbnZhciBfbGF5b3V0Tm9kZXNCYXNlZE9uID0ge1xuICB2YWx1ZTogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBncmFwaCwgbm9kZURhdGEsIHIsIGN4LCBjeSwgY291bnQpIHtcbiAgICB2YXIgYW5nbGUgPSAwO1xuICAgIHZhciBzdW0gPSBub2RlRGF0YS5nZXRTdW0oJ3ZhbHVlJyk7XG4gICAgdmFyIHVuaXRBbmdsZSA9IE1hdGguUEkgKiAyIC8gKHN1bSB8fCBjb3VudCk7XG4gICAgZ3JhcGguZWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0VmFsdWUoJ3ZhbHVlJyk7XG4gICAgICB2YXIgcmFkaWFuSGFsZiA9IHVuaXRBbmdsZSAqIChzdW0gPyB2YWx1ZSA6IDEpIC8gMjtcbiAgICAgIGFuZ2xlICs9IHJhZGlhbkhhbGY7XG4gICAgICBub2RlLnNldExheW91dChbciAqIE1hdGguY29zKGFuZ2xlKSArIGN4LCByICogTWF0aC5zaW4oYW5nbGUpICsgY3ldKTtcbiAgICAgIGFuZ2xlICs9IHJhZGlhbkhhbGY7XG4gICAgfSk7XG4gIH0sXG4gIHN5bWJvbFNpemU6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZ3JhcGgsIG5vZGVEYXRhLCByLCBjeCwgY3ksIGNvdW50KSB7XG4gICAgdmFyIHN1bVJhZGlhbiA9IDA7XG4gICAgX3N5bWJvbFJhZGlhbnNIYWxmLmxlbmd0aCA9IGNvdW50O1xuICAgIHZhciBub2RlU2NhbGUgPSBnZXROb2RlR2xvYmFsU2NhbGUoc2VyaWVzTW9kZWwpO1xuICAgIGdyYXBoLmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgc3ltYm9sU2l6ZSA9IGdldFN5bWJvbFNpemUobm9kZSk7XG4gICAgICAvLyBOb3JtYWxseSB0aGlzIGNhc2Ugd2lsbCBub3QgaGFwcGVuLCBidXQgd2Ugc3RpbGwgYWRkXG4gICAgICAvLyBzb21lIHRoZSBkZWZlbnNpdmUgY29kZSAoMnB4IGlzIGFuIGFyYml0cmFyeSB2YWx1ZSkuXG4gICAgICBpc05hTihzeW1ib2xTaXplKSAmJiAoc3ltYm9sU2l6ZSA9IDIpO1xuICAgICAgc3ltYm9sU2l6ZSA8IDAgJiYgKHN5bWJvbFNpemUgPSAwKTtcbiAgICAgIHN5bWJvbFNpemUgKj0gbm9kZVNjYWxlO1xuICAgICAgdmFyIHN5bWJvbFJhZGlhbkhhbGYgPSBNYXRoLmFzaW4oc3ltYm9sU2l6ZSAvIDIgLyByKTtcbiAgICAgIC8vIHdoZW4gYHN5bWJvbFNpemUgLyAyYCBpcyBiaWdnZXIgdGhhbiBgcmAuXG4gICAgICBpc05hTihzeW1ib2xSYWRpYW5IYWxmKSAmJiAoc3ltYm9sUmFkaWFuSGFsZiA9IFBJIC8gMik7XG4gICAgICBfc3ltYm9sUmFkaWFuc0hhbGZbbm9kZS5kYXRhSW5kZXhdID0gc3ltYm9sUmFkaWFuSGFsZjtcbiAgICAgIHN1bVJhZGlhbiArPSBzeW1ib2xSYWRpYW5IYWxmICogMjtcbiAgICB9KTtcbiAgICB2YXIgaGFsZlJlbWFpblJhZGlhbiA9ICgyICogUEkgLSBzdW1SYWRpYW4pIC8gY291bnQgLyAyO1xuICAgIHZhciBhbmdsZSA9IDA7XG4gICAgZ3JhcGguZWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciByYWRpYW5IYWxmID0gaGFsZlJlbWFpblJhZGlhbiArIF9zeW1ib2xSYWRpYW5zSGFsZltub2RlLmRhdGFJbmRleF07XG4gICAgICBhbmdsZSArPSByYWRpYW5IYWxmO1xuICAgICAgLy8gaW5pdCBjaXJjdWxhciBsYXlvdXQgZm9yXG4gICAgICAvLyAxLiBsYXlvdXQgdW5kZWZpbmVkIG5vZGVcbiAgICAgIC8vIDIuIG5vdCBmaXhlZCBub2RlXG4gICAgICAoIW5vZGUuZ2V0TGF5b3V0KCkgfHwgIW5vZGUuZ2V0TGF5b3V0KCkuZml4ZWQpICYmIG5vZGUuc2V0TGF5b3V0KFtyICogTWF0aC5jb3MoYW5nbGUpICsgY3gsIHIgKiBNYXRoLnNpbihhbmdsZSkgKyBjeV0pO1xuICAgICAgYW5nbGUgKz0gcmFkaWFuSGFsZjtcbiAgICB9KTtcbiAgfVxufTtcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVOb2RlTGFiZWwobm9kZSwgY2lyY3VsYXJSb3RhdGVMYWJlbCwgY3gsIGN5KSB7XG4gIHZhciBlbCA9IG5vZGUuZ2V0R3JhcGhpY0VsKCk7XG4gIC8vIG5lZWQgdG8gY2hlY2sgaWYgZWwgZXhpc3RzLiAnLScgdmFsdWUgbWF5IG5vdCBjcmVhdGUgbm9kZSBlbGVtZW50LlxuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBub2RlTW9kZWwgPSBub2RlLmdldE1vZGVsKCk7XG4gIHZhciBsYWJlbFJvdGF0ZSA9IG5vZGVNb2RlbC5nZXQoWydsYWJlbCcsICdyb3RhdGUnXSkgfHwgMDtcbiAgdmFyIHN5bWJvbFBhdGggPSBlbC5nZXRTeW1ib2xQYXRoKCk7XG4gIGlmIChjaXJjdWxhclJvdGF0ZUxhYmVsKSB7XG4gICAgdmFyIHBvcyA9IG5vZGUuZ2V0TGF5b3V0KCk7XG4gICAgdmFyIHJhZCA9IE1hdGguYXRhbjIocG9zWzFdIC0gY3ksIHBvc1swXSAtIGN4KTtcbiAgICBpZiAocmFkIDwgMCkge1xuICAgICAgcmFkID0gTWF0aC5QSSAqIDIgKyByYWQ7XG4gICAgfVxuICAgIHZhciBpc0xlZnQgPSBwb3NbMF0gPCBjeDtcbiAgICBpZiAoaXNMZWZ0KSB7XG4gICAgICByYWQgPSByYWQgLSBNYXRoLlBJO1xuICAgIH1cbiAgICB2YXIgdGV4dFBvc2l0aW9uID0gaXNMZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICBzeW1ib2xQYXRoLnNldFRleHRDb25maWcoe1xuICAgICAgcm90YXRpb246IC1yYWQsXG4gICAgICBwb3NpdGlvbjogdGV4dFBvc2l0aW9uLFxuICAgICAgb3JpZ2luOiAnY2VudGVyJ1xuICAgIH0pO1xuICAgIHZhciBlbXBoYXNpc1N0YXRlID0gc3ltYm9sUGF0aC5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKTtcbiAgICB6clV0aWwuZXh0ZW5kKGVtcGhhc2lzU3RhdGUudGV4dENvbmZpZyB8fCAoZW1waGFzaXNTdGF0ZS50ZXh0Q29uZmlnID0ge30pLCB7XG4gICAgICBwb3NpdGlvbjogdGV4dFBvc2l0aW9uXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3ltYm9sUGF0aC5zZXRUZXh0Q29uZmlnKHtcbiAgICAgIHJvdGF0aW9uOiBsYWJlbFJvdGF0ZSAqPSBNYXRoLlBJIC8gMTgwXG4gICAgfSk7XG4gIH1cbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGNpcmN1bGFyTGF5b3V0IH0gZnJvbSAnLi9jaXJjdWxhckxheW91dEhlbHBlci5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBncmFwaENpcmN1bGFyTGF5b3V0KGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdncmFwaCcsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIGlmIChzZXJpZXNNb2RlbC5nZXQoJ2xheW91dCcpID09PSAnY2lyY3VsYXInKSB7XG4gICAgICBjaXJjdWxhckxheW91dChzZXJpZXNNb2RlbCwgJ3N5bWJvbFNpemUnKTtcbiAgICB9XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLypcclxuKiBBIHRoaXJkLXBhcnR5IGxpY2Vuc2UgaXMgZW1iZWRkZWQgZm9yIHNvbWUgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlOlxyXG4qIFNvbWUgZm9ybXVsYXMgd2VyZSBvcmlnaW5hbGx5IGNvcGllZCBmcm9tIFwiZDMuanNcIiB3aXRoIHNvbWVcclxuKiBtb2RpZmljYXRpb25zIG1hZGUgZm9yIHRoaXMgcHJvamVjdC5cclxuKiAoU2VlIG1vcmUgZGV0YWlscyBpbiB0aGUgY29tbWVudCBvZiB0aGUgbWV0aG9kIFwic3RlcFwiIGJlbG93LilcclxuKiBUaGUgdXNlIG9mIHRoZSBzb3VyY2UgY29kZSBvZiB0aGlzIGZpbGUgaXMgYWxzbyBzdWJqZWN0IHRvIHRoZSB0ZXJtc1xyXG4qIGFuZCBjb25zaXRpb25zIG9mIHRoZSBsaWNlbnNlIG9mIFwiZDMuanNcIiAoQlNELTNDbGF1c2UsIHNlZVxyXG4qIDwvbGljZW5zZXMvTElDRU5TRS1kMz4pLlxyXG4qL1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvci5qcyc7XG52YXIgc2NhbGVBbmRBZGQgPSB2ZWMyLnNjYWxlQW5kQWRkO1xuLy8gZnVuY3Rpb24gYWRqYWNlbnROb2RlKG4sIGUpIHtcbi8vICAgICByZXR1cm4gZS5uMSA9PT0gbiA/IGUubjIgOiBlLm4xO1xuLy8gfVxuZXhwb3J0IGZ1bmN0aW9uIGZvcmNlTGF5b3V0KGluTm9kZXMsIGluRWRnZXMsIG9wdHMpIHtcbiAgdmFyIG5vZGVzID0gaW5Ob2RlcztcbiAgdmFyIGVkZ2VzID0gaW5FZGdlcztcbiAgdmFyIHJlY3QgPSBvcHRzLnJlY3Q7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgdmFyIGNlbnRlciA9IFtyZWN0LnggKyB3aWR0aCAvIDIsIHJlY3QueSArIGhlaWdodCAvIDJdO1xuICAvLyBsZXQgc2NhbGUgPSBvcHRzLnNjYWxlIHx8IDE7XG4gIHZhciBncmF2aXR5ID0gb3B0cy5ncmF2aXR5ID09IG51bGwgPyAwLjEgOiBvcHRzLmdyYXZpdHk7XG4gIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgLy8gICAgIGxldCBlID0gZWRnZXNbaV07XG4gIC8vICAgICBsZXQgbjEgPSBlLm4xO1xuICAvLyAgICAgbGV0IG4yID0gZS5uMjtcbiAgLy8gICAgIG4xLmVkZ2VzID0gbjEuZWRnZXMgfHwgW107XG4gIC8vICAgICBuMi5lZGdlcyA9IG4yLmVkZ2VzIHx8IFtdO1xuICAvLyAgICAgbjEuZWRnZXMucHVzaChlKTtcbiAgLy8gICAgIG4yLmVkZ2VzLnB1c2goZSk7XG4gIC8vIH1cbiAgLy8gSW5pdCBwb3NpdGlvblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICBpZiAoIW4ucCkge1xuICAgICAgbi5wID0gdmVjMi5jcmVhdGUod2lkdGggKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKyBjZW50ZXJbMF0sIGhlaWdodCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSArIGNlbnRlclsxXSk7XG4gICAgfVxuICAgIG4ucHAgPSB2ZWMyLmNsb25lKG4ucCk7XG4gICAgbi5lZGdlcyA9IG51bGw7XG4gIH1cbiAgLy8gRm9ybXVsYSBpbiAnR3JhcGggRHJhd2luZyBieSBGb3JjZS1kaXJlY3RlZCBQbGFjZW1lbnQnXG4gIC8vIGxldCBrID0gc2NhbGUgKiBNYXRoLnNxcnQod2lkdGggKiBoZWlnaHQgLyBub2Rlcy5sZW5ndGgpO1xuICAvLyBsZXQgazIgPSBrICogaztcbiAgdmFyIGluaXRpYWxGcmljdGlvbiA9IG9wdHMuZnJpY3Rpb24gPT0gbnVsbCA/IDAuNiA6IG9wdHMuZnJpY3Rpb247XG4gIHZhciBmcmljdGlvbiA9IGluaXRpYWxGcmljdGlvbjtcbiAgdmFyIGJlZm9yZVN0ZXBDYWxsYmFjaztcbiAgdmFyIGFmdGVyU3RlcENhbGxiYWNrO1xuICByZXR1cm4ge1xuICAgIHdhcm1VcDogZnVuY3Rpb24gKCkge1xuICAgICAgZnJpY3Rpb24gPSBpbml0aWFsRnJpY3Rpb24gKiAwLjg7XG4gICAgfSxcbiAgICBzZXRGaXhlZDogZnVuY3Rpb24gKGlkeCkge1xuICAgICAgbm9kZXNbaWR4XS5maXhlZCA9IHRydWU7XG4gICAgfSxcbiAgICBzZXRVbmZpeGVkOiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICBub2Rlc1tpZHhdLmZpeGVkID0gZmFsc2U7XG4gICAgfSxcbiAgICAvKipcclxuICAgICAqIEJlZm9yZSBzdGVwIGhvb2tcclxuICAgICAqL1xuICAgIGJlZm9yZVN0ZXA6IGZ1bmN0aW9uIChjYikge1xuICAgICAgYmVmb3JlU3RlcENhbGxiYWNrID0gY2I7XG4gICAgfSxcbiAgICAvKipcclxuICAgICAqIEFmdGVyIHN0ZXAgaG9va1xyXG4gICAgICovXG4gICAgYWZ0ZXJTdGVwOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIGFmdGVyU3RlcENhbGxiYWNrID0gY2I7XG4gICAgfSxcbiAgICAvKipcclxuICAgICAqIFNvbWUgZm9ybXVsYXMgd2VyZSBvcmlnaW5hbGx5IGNvcGllZCBmcm9tIFwiZDMuanNcIlxyXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzL2Jsb2IvYjUxNmQ3N2ZiODU2NmI1NzYwODhlNzM0MTA0Mzc0OTQ3MTdhZGEyNi9zcmMvbGF5b3V0L2ZvcmNlLmpzXHJcbiAgICAgKiB3aXRoIHNvbWUgbW9kaWZpY2F0aW9ucyBtYWRlIGZvciB0aGlzIHByb2plY3QuXHJcbiAgICAgKiBTZWUgdGhlIGxpY2Vuc2Ugc3RhdGVtZW50IGF0IHRoZSBoZWFkIG9mIHRoaXMgZmlsZS5cclxuICAgICAqL1xuICAgIHN0ZXA6IGZ1bmN0aW9uIChjYikge1xuICAgICAgYmVmb3JlU3RlcENhbGxiYWNrICYmIGJlZm9yZVN0ZXBDYWxsYmFjayhub2RlcywgZWRnZXMpO1xuICAgICAgdmFyIHYxMiA9IFtdO1xuICAgICAgdmFyIG5MZW4gPSBub2Rlcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgICAgIGlmIChlLmlnbm9yZUZvcmNlTGF5b3V0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4xID0gZS5uMTtcbiAgICAgICAgdmFyIG4yID0gZS5uMjtcbiAgICAgICAgdmVjMi5zdWIodjEyLCBuMi5wLCBuMS5wKTtcbiAgICAgICAgdmFyIGQgPSB2ZWMyLmxlbih2MTIpIC0gZS5kO1xuICAgICAgICB2YXIgdyA9IG4yLncgLyAobjEudyArIG4yLncpO1xuICAgICAgICBpZiAoaXNOYU4odykpIHtcbiAgICAgICAgICB3ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh2MTIsIHYxMik7XG4gICAgICAgICFuMS5maXhlZCAmJiBzY2FsZUFuZEFkZChuMS5wLCBuMS5wLCB2MTIsIHcgKiBkICogZnJpY3Rpb24pO1xuICAgICAgICAhbjIuZml4ZWQgJiYgc2NhbGVBbmRBZGQobjIucCwgbjIucCwgdjEyLCAtKDEgLSB3KSAqIGQgKiBmcmljdGlvbik7XG4gICAgICB9XG4gICAgICAvLyBHcmF2aXR5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5MZW47IGkrKykge1xuICAgICAgICB2YXIgbiA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoIW4uZml4ZWQpIHtcbiAgICAgICAgICB2ZWMyLnN1Yih2MTIsIGNlbnRlciwgbi5wKTtcbiAgICAgICAgICAvLyBsZXQgZCA9IHZlYzIubGVuKHYxMik7XG4gICAgICAgICAgLy8gdmVjMi5zY2FsZSh2MTIsIHYxMiwgMSAvIGQpO1xuICAgICAgICAgIC8vIGxldCBncmF2aXR5RmFjdG9yID0gZ3Jhdml0eTtcbiAgICAgICAgICBzY2FsZUFuZEFkZChuLnAsIG4ucCwgdjEyLCBncmF2aXR5ICogZnJpY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZXB1bHNpdmVcbiAgICAgIC8vIFBFTkRJTkdcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBuMSA9IG5vZGVzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBuTGVuOyBqKyspIHtcbiAgICAgICAgICB2YXIgbjIgPSBub2Rlc1tqXTtcbiAgICAgICAgICB2ZWMyLnN1Yih2MTIsIG4yLnAsIG4xLnApO1xuICAgICAgICAgIHZhciBkID0gdmVjMi5sZW4odjEyKTtcbiAgICAgICAgICBpZiAoZCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gUmFuZG9tIHJlcHVsc2VcbiAgICAgICAgICAgIHZlYzIuc2V0KHYxMiwgTWF0aC5yYW5kb20oKSAtIDAuNSwgTWF0aC5yYW5kb20oKSAtIDAuNSk7XG4gICAgICAgICAgICBkID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlcEZhY3QgPSAobjEucmVwICsgbjIucmVwKSAvIGQgLyBkO1xuICAgICAgICAgICFuMS5maXhlZCAmJiBzY2FsZUFuZEFkZChuMS5wcCwgbjEucHAsIHYxMiwgcmVwRmFjdCk7XG4gICAgICAgICAgIW4yLmZpeGVkICYmIHNjYWxlQW5kQWRkKG4yLnBwLCBuMi5wcCwgdjEyLCAtcmVwRmFjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB2ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5MZW47IGkrKykge1xuICAgICAgICB2YXIgbiA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoIW4uZml4ZWQpIHtcbiAgICAgICAgICB2ZWMyLnN1Yih2LCBuLnAsIG4ucHApO1xuICAgICAgICAgIHNjYWxlQW5kQWRkKG4ucCwgbi5wLCB2LCBmcmljdGlvbik7XG4gICAgICAgICAgdmVjMi5jb3B5KG4ucHAsIG4ucCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZyaWN0aW9uID0gZnJpY3Rpb24gKiAwLjk5MjtcbiAgICAgIHZhciBmaW5pc2hlZCA9IGZyaWN0aW9uIDwgMC4wMTtcbiAgICAgIGFmdGVyU3RlcENhbGxiYWNrICYmIGFmdGVyU3RlcENhbGxiYWNrKG5vZGVzLCBlZGdlcywgZmluaXNoZWQpO1xuICAgICAgY2IgJiYgY2IoZmluaXNoZWQpO1xuICAgIH1cbiAgfTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGZvcmNlTGF5b3V0IH0gZnJvbSAnLi9mb3JjZUhlbHBlci5qcyc7XG5pbXBvcnQgeyBzaW1wbGVMYXlvdXQgfSBmcm9tICcuL3NpbXBsZUxheW91dEhlbHBlci5qcyc7XG5pbXBvcnQgeyBjaXJjdWxhckxheW91dCB9IGZyb20gJy4vY2lyY3VsYXJMYXlvdXRIZWxwZXIuanMnO1xuaW1wb3J0IHsgbGluZWFyTWFwIH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvci5qcyc7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGdldEN1cnZlbmVzc0ZvckVkZ2UgfSBmcm9tICcuLi9oZWxwZXIvbXVsdGlwbGVHcmFwaEVkZ2VIZWxwZXIuanMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ3JhcGhGb3JjZUxheW91dChlY01vZGVsKSB7XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgnZ3JhcGgnLCBmdW5jdGlvbiAoZ3JhcGhTZXJpZXMpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBncmFwaFNlcmllcy5jb29yZGluYXRlU3lzdGVtO1xuICAgIGlmIChjb29yZFN5cyAmJiBjb29yZFN5cy50eXBlICE9PSAndmlldycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGdyYXBoU2VyaWVzLmdldCgnbGF5b3V0JykgPT09ICdmb3JjZScpIHtcbiAgICAgIHZhciBwcmVzZXJ2ZWRQb2ludHNfMSA9IGdyYXBoU2VyaWVzLnByZXNlcnZlZFBvaW50cyB8fCB7fTtcbiAgICAgIHZhciBncmFwaF8xID0gZ3JhcGhTZXJpZXMuZ2V0R3JhcGgoKTtcbiAgICAgIHZhciBub2RlRGF0YV8xID0gZ3JhcGhfMS5kYXRhO1xuICAgICAgdmFyIGVkZ2VEYXRhID0gZ3JhcGhfMS5lZGdlRGF0YTtcbiAgICAgIHZhciBmb3JjZU1vZGVsID0gZ3JhcGhTZXJpZXMuZ2V0TW9kZWwoJ2ZvcmNlJyk7XG4gICAgICB2YXIgaW5pdExheW91dCA9IGZvcmNlTW9kZWwuZ2V0KCdpbml0TGF5b3V0Jyk7XG4gICAgICBpZiAoZ3JhcGhTZXJpZXMucHJlc2VydmVkUG9pbnRzKSB7XG4gICAgICAgIG5vZGVEYXRhXzEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgdmFyIGlkID0gbm9kZURhdGFfMS5nZXRJZChpZHgpO1xuICAgICAgICAgIG5vZGVEYXRhXzEuc2V0SXRlbUxheW91dChpZHgsIHByZXNlcnZlZFBvaW50c18xW2lkXSB8fCBbTmFOLCBOYU5dKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCFpbml0TGF5b3V0IHx8IGluaXRMYXlvdXQgPT09ICdub25lJykge1xuICAgICAgICBzaW1wbGVMYXlvdXQoZ3JhcGhTZXJpZXMpO1xuICAgICAgfSBlbHNlIGlmIChpbml0TGF5b3V0ID09PSAnY2lyY3VsYXInKSB7XG4gICAgICAgIGNpcmN1bGFyTGF5b3V0KGdyYXBoU2VyaWVzLCAndmFsdWUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBub2RlRGF0YUV4dGVudF8xID0gbm9kZURhdGFfMS5nZXREYXRhRXh0ZW50KCd2YWx1ZScpO1xuICAgICAgdmFyIGVkZ2VEYXRhRXh0ZW50XzEgPSBlZGdlRGF0YS5nZXREYXRhRXh0ZW50KCd2YWx1ZScpO1xuICAgICAgLy8gbGV0IGVkZ2VEYXRhRXh0ZW50ID0gZWRnZURhdGEuZ2V0RGF0YUV4dGVudCgndmFsdWUnKTtcbiAgICAgIHZhciByZXB1bHNpb24gPSBmb3JjZU1vZGVsLmdldCgncmVwdWxzaW9uJyk7XG4gICAgICB2YXIgZWRnZUxlbmd0aCA9IGZvcmNlTW9kZWwuZ2V0KCdlZGdlTGVuZ3RoJyk7XG4gICAgICB2YXIgcmVwdWxzaW9uQXJyXzEgPSB6clV0aWwuaXNBcnJheShyZXB1bHNpb24pID8gcmVwdWxzaW9uIDogW3JlcHVsc2lvbiwgcmVwdWxzaW9uXTtcbiAgICAgIHZhciBlZGdlTGVuZ3RoQXJyXzEgPSB6clV0aWwuaXNBcnJheShlZGdlTGVuZ3RoKSA/IGVkZ2VMZW5ndGggOiBbZWRnZUxlbmd0aCwgZWRnZUxlbmd0aF07XG4gICAgICAvLyBMYXJnZXIgdmFsdWUgaGFzIHNtYWxsZXIgbGVuZ3RoXG4gICAgICBlZGdlTGVuZ3RoQXJyXzEgPSBbZWRnZUxlbmd0aEFycl8xWzFdLCBlZGdlTGVuZ3RoQXJyXzFbMF1dO1xuICAgICAgdmFyIG5vZGVzXzEgPSBub2RlRGF0YV8xLm1hcEFycmF5KCd2YWx1ZScsIGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICAgIHZhciBwb2ludCA9IG5vZGVEYXRhXzEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgICB2YXIgcmVwID0gbGluZWFyTWFwKHZhbHVlLCBub2RlRGF0YUV4dGVudF8xLCByZXB1bHNpb25BcnJfMSk7XG4gICAgICAgIGlmIChpc05hTihyZXApKSB7XG4gICAgICAgICAgcmVwID0gKHJlcHVsc2lvbkFycl8xWzBdICsgcmVwdWxzaW9uQXJyXzFbMV0pIC8gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHc6IHJlcCxcbiAgICAgICAgICByZXA6IHJlcCxcbiAgICAgICAgICBmaXhlZDogbm9kZURhdGFfMS5nZXRJdGVtTW9kZWwoaWR4KS5nZXQoJ2ZpeGVkJyksXG4gICAgICAgICAgcDogIXBvaW50IHx8IGlzTmFOKHBvaW50WzBdKSB8fCBpc05hTihwb2ludFsxXSkgPyBudWxsIDogcG9pbnRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGVkZ2VzID0gZWRnZURhdGEubWFwQXJyYXkoJ3ZhbHVlJywgZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBncmFwaF8xLmdldEVkZ2VCeUluZGV4KGlkeCk7XG4gICAgICAgIHZhciBkID0gbGluZWFyTWFwKHZhbHVlLCBlZGdlRGF0YUV4dGVudF8xLCBlZGdlTGVuZ3RoQXJyXzEpO1xuICAgICAgICBpZiAoaXNOYU4oZCkpIHtcbiAgICAgICAgICBkID0gKGVkZ2VMZW5ndGhBcnJfMVswXSArIGVkZ2VMZW5ndGhBcnJfMVsxXSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlZGdlTW9kZWwgPSBlZGdlLmdldE1vZGVsKCk7XG4gICAgICAgIHZhciBjdXJ2ZW5lc3MgPSB6clV0aWwucmV0cmlldmUzKGVkZ2UuZ2V0TW9kZWwoKS5nZXQoWydsaW5lU3R5bGUnLCAnY3VydmVuZXNzJ10pLCAtZ2V0Q3VydmVuZXNzRm9yRWRnZShlZGdlLCBncmFwaFNlcmllcywgaWR4LCB0cnVlKSwgMCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbjE6IG5vZGVzXzFbZWRnZS5ub2RlMS5kYXRhSW5kZXhdLFxuICAgICAgICAgIG4yOiBub2Rlc18xW2VkZ2Uubm9kZTIuZGF0YUluZGV4XSxcbiAgICAgICAgICBkOiBkLFxuICAgICAgICAgIGN1cnZlbmVzczogY3VydmVuZXNzLFxuICAgICAgICAgIGlnbm9yZUZvcmNlTGF5b3V0OiBlZGdlTW9kZWwuZ2V0KCdpZ25vcmVGb3JjZUxheW91dCcpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIC8vIGxldCBjb29yZFN5cyA9IGdyYXBoU2VyaWVzLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICB2YXIgcmVjdCA9IGNvb3JkU3lzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgdmFyIGZvcmNlSW5zdGFuY2UgPSBmb3JjZUxheW91dChub2Rlc18xLCBlZGdlcywge1xuICAgICAgICByZWN0OiByZWN0LFxuICAgICAgICBncmF2aXR5OiBmb3JjZU1vZGVsLmdldCgnZ3Jhdml0eScpLFxuICAgICAgICBmcmljdGlvbjogZm9yY2VNb2RlbC5nZXQoJ2ZyaWN0aW9uJylcbiAgICAgIH0pO1xuICAgICAgZm9yY2VJbnN0YW5jZS5iZWZvcmVTdGVwKGZ1bmN0aW9uIChub2RlcywgZWRnZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAobm9kZXNbaV0uZml4ZWQpIHtcbiAgICAgICAgICAgIC8vIFdyaXRlIGJhY2sgdG8gbGF5b3V0IGluc3RhbmNlXG4gICAgICAgICAgICB2ZWMyLmNvcHkobm9kZXNbaV0ucCwgZ3JhcGhfMS5nZXROb2RlQnlJbmRleChpKS5nZXRMYXlvdXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZvcmNlSW5zdGFuY2UuYWZ0ZXJTdGVwKGZ1bmN0aW9uIChub2RlcywgZWRnZXMsIHN0b3BwZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoIW5vZGVzW2ldLmZpeGVkKSB7XG4gICAgICAgICAgICBncmFwaF8xLmdldE5vZGVCeUluZGV4KGkpLnNldExheW91dChub2Rlc1tpXS5wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJlc2VydmVkUG9pbnRzXzFbbm9kZURhdGFfMS5nZXRJZChpKV0gPSBub2Rlc1tpXS5wO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWRnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGUgPSBlZGdlc1tpXTtcbiAgICAgICAgICB2YXIgZWRnZSA9IGdyYXBoXzEuZ2V0RWRnZUJ5SW5kZXgoaSk7XG4gICAgICAgICAgdmFyIHAxID0gZS5uMS5wO1xuICAgICAgICAgIHZhciBwMiA9IGUubjIucDtcbiAgICAgICAgICB2YXIgcG9pbnRzID0gZWRnZS5nZXRMYXlvdXQoKTtcbiAgICAgICAgICBwb2ludHMgPSBwb2ludHMgPyBwb2ludHMuc2xpY2UoKSA6IFtdO1xuICAgICAgICAgIHBvaW50c1swXSA9IHBvaW50c1swXSB8fCBbXTtcbiAgICAgICAgICBwb2ludHNbMV0gPSBwb2ludHNbMV0gfHwgW107XG4gICAgICAgICAgdmVjMi5jb3B5KHBvaW50c1swXSwgcDEpO1xuICAgICAgICAgIHZlYzIuY29weShwb2ludHNbMV0sIHAyKTtcbiAgICAgICAgICBpZiAoK2UuY3VydmVuZXNzKSB7XG4gICAgICAgICAgICBwb2ludHNbMl0gPSBbKHAxWzBdICsgcDJbMF0pIC8gMiAtIChwMVsxXSAtIHAyWzFdKSAqIGUuY3VydmVuZXNzLCAocDFbMV0gKyBwMlsxXSkgLyAyIC0gKHAyWzBdIC0gcDFbMF0pICogZS5jdXJ2ZW5lc3NdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlZGdlLnNldExheW91dChwb2ludHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGdyYXBoU2VyaWVzLmZvcmNlTGF5b3V0ID0gZm9yY2VJbnN0YW5jZTtcbiAgICAgIGdyYXBoU2VyaWVzLnByZXNlcnZlZFBvaW50cyA9IHByZXNlcnZlZFBvaW50c18xO1xuICAgICAgLy8gU3RlcCB0byBnZXQgdGhlIGxheW91dFxuICAgICAgZm9yY2VJbnN0YW5jZS5zdGVwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBwcmV2IGluamVjdGVkIGZvcmNlTGF5b3V0IGluc3RhbmNlXG4gICAgICBncmFwaFNlcmllcy5mb3JjZUxheW91dCA9IG51bGw7XG4gICAgfVxuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbi8vIEZJWE1FIFdoZXJlIHRvIGNyZWF0ZSB0aGUgc2ltcGxlIHZpZXcgY29vcmRpbmF0ZSBzeXN0ZW1cbmltcG9ydCBWaWV3IGZyb20gJy4uLy4uL2Nvb3JkL1ZpZXcuanMnO1xuaW1wb3J0IHsgZ2V0TGF5b3V0UmVjdCB9IGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0LmpzJztcbmltcG9ydCAqIGFzIGJib3ggZnJvbSAnenJlbmRlci9saWIvY29yZS9iYm94LmpzJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5mdW5jdGlvbiBnZXRWaWV3UmVjdChzZXJpZXNNb2RlbCwgYXBpLCBhc3BlY3QpIHtcbiAgdmFyIG9wdGlvbiA9IGV4dGVuZChzZXJpZXNNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSwge1xuICAgIGFzcGVjdDogYXNwZWN0XG4gIH0pO1xuICByZXR1cm4gZ2V0TGF5b3V0UmVjdChvcHRpb24sIHtcbiAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVWaWV3Q29vcmRTeXMoZWNNb2RlbCwgYXBpKSB7XG4gIHZhciB2aWV3TGlzdCA9IFtdO1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ2dyYXBoJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGNvb3JkU3lzVHlwZSA9IHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpO1xuICAgIGlmICghY29vcmRTeXNUeXBlIHx8IGNvb3JkU3lzVHlwZSA9PT0gJ3ZpZXcnKSB7XG4gICAgICB2YXIgZGF0YV8xID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IGRhdGFfMS5tYXBBcnJheShmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhXzEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgIHJldHVybiBbK2l0ZW1Nb2RlbC5nZXQoJ3gnKSwgK2l0ZW1Nb2RlbC5nZXQoJ3knKV07XG4gICAgICB9KTtcbiAgICAgIHZhciBtaW4gPSBbXTtcbiAgICAgIHZhciBtYXggPSBbXTtcbiAgICAgIGJib3guZnJvbVBvaW50cyhwb3NpdGlvbnMsIG1pbiwgbWF4KTtcbiAgICAgIC8vIElmIHdpZHRoIG9yIGhlaWdodCBpcyAwXG4gICAgICBpZiAobWF4WzBdIC0gbWluWzBdID09PSAwKSB7XG4gICAgICAgIG1heFswXSArPSAxO1xuICAgICAgICBtaW5bMF0gLT0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhbMV0gLSBtaW5bMV0gPT09IDApIHtcbiAgICAgICAgbWF4WzFdICs9IDE7XG4gICAgICAgIG1pblsxXSAtPSAxO1xuICAgICAgfVxuICAgICAgdmFyIGFzcGVjdCA9IChtYXhbMF0gLSBtaW5bMF0pIC8gKG1heFsxXSAtIG1pblsxXSk7XG4gICAgICAvLyBGSVhNRSBJZiBnZXQgdmlldyByZWN0IGFmdGVyIGRhdGEgcHJvY2Vzc2VkP1xuICAgICAgdmFyIHZpZXdSZWN0ID0gZ2V0Vmlld1JlY3Qoc2VyaWVzTW9kZWwsIGFwaSwgYXNwZWN0KTtcbiAgICAgIC8vIFBvc2l0aW9uIG1heSBiZSBOYU4sIHVzZSB2aWV3IHJlY3QgaW5zdGVhZFxuICAgICAgaWYgKGlzTmFOKGFzcGVjdCkpIHtcbiAgICAgICAgbWluID0gW3ZpZXdSZWN0LngsIHZpZXdSZWN0LnldO1xuICAgICAgICBtYXggPSBbdmlld1JlY3QueCArIHZpZXdSZWN0LndpZHRoLCB2aWV3UmVjdC55ICsgdmlld1JlY3QuaGVpZ2h0XTtcbiAgICAgIH1cbiAgICAgIHZhciBiYldpZHRoID0gbWF4WzBdIC0gbWluWzBdO1xuICAgICAgdmFyIGJiSGVpZ2h0ID0gbWF4WzFdIC0gbWluWzFdO1xuICAgICAgdmFyIHZpZXdXaWR0aCA9IHZpZXdSZWN0LndpZHRoO1xuICAgICAgdmFyIHZpZXdIZWlnaHQgPSB2aWV3UmVjdC5oZWlnaHQ7XG4gICAgICB2YXIgdmlld0Nvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IG5ldyBWaWV3KCk7XG4gICAgICB2aWV3Q29vcmRTeXMuem9vbUxpbWl0ID0gc2VyaWVzTW9kZWwuZ2V0KCdzY2FsZUxpbWl0Jyk7XG4gICAgICB2aWV3Q29vcmRTeXMuc2V0Qm91bmRpbmdSZWN0KG1pblswXSwgbWluWzFdLCBiYldpZHRoLCBiYkhlaWdodCk7XG4gICAgICB2aWV3Q29vcmRTeXMuc2V0Vmlld1JlY3Qodmlld1JlY3QueCwgdmlld1JlY3QueSwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KTtcbiAgICAgIC8vIFVwZGF0ZSByb2FtIGluZm9cbiAgICAgIHZpZXdDb29yZFN5cy5zZXRDZW50ZXIoc2VyaWVzTW9kZWwuZ2V0KCdjZW50ZXInKSwgYXBpKTtcbiAgICAgIHZpZXdDb29yZFN5cy5zZXRab29tKHNlcmllc01vZGVsLmdldCgnem9vbScpKTtcbiAgICAgIHZpZXdMaXN0LnB1c2godmlld0Nvb3JkU3lzKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdmlld0xpc3Q7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyBjdXJ2ZVRvb2wgZnJvbSAnenJlbmRlci9saWIvY29yZS9jdXJ2ZS5qcyc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzJztcbmltcG9ydCB7IGdldFN5bWJvbFNpemUgfSBmcm9tICcuL2dyYXBoSGVscGVyLmpzJztcbnZhciB2MSA9IFtdO1xudmFyIHYyID0gW107XG52YXIgdjMgPSBbXTtcbnZhciBxdWFkcmF0aWNBdCA9IGN1cnZlVG9vbC5xdWFkcmF0aWNBdDtcbnZhciB2MkRpc3RTcXVhcmUgPSB2ZWMyLmRpc3RTcXVhcmU7XG52YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuZnVuY3Rpb24gaW50ZXJzZWN0Q3VydmVDaXJjbGUoY3VydmVQb2ludHMsIGNlbnRlciwgcmFkaXVzKSB7XG4gIHZhciBwMCA9IGN1cnZlUG9pbnRzWzBdO1xuICB2YXIgcDEgPSBjdXJ2ZVBvaW50c1sxXTtcbiAgdmFyIHAyID0gY3VydmVQb2ludHNbMl07XG4gIHZhciBkID0gSW5maW5pdHk7XG4gIHZhciB0O1xuICB2YXIgcmFkaXVzU3F1YXJlID0gcmFkaXVzICogcmFkaXVzO1xuICB2YXIgaW50ZXJ2YWwgPSAwLjE7XG4gIGZvciAodmFyIF90ID0gMC4xOyBfdCA8PSAwLjk7IF90ICs9IDAuMSkge1xuICAgIHYxWzBdID0gcXVhZHJhdGljQXQocDBbMF0sIHAxWzBdLCBwMlswXSwgX3QpO1xuICAgIHYxWzFdID0gcXVhZHJhdGljQXQocDBbMV0sIHAxWzFdLCBwMlsxXSwgX3QpO1xuICAgIHZhciBkaWZmID0gbWF0aEFicyh2MkRpc3RTcXVhcmUodjEsIGNlbnRlcikgLSByYWRpdXNTcXVhcmUpO1xuICAgIGlmIChkaWZmIDwgZCkge1xuICAgICAgZCA9IGRpZmY7XG4gICAgICB0ID0gX3Q7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSB0aGUgc2VnbWVudCBpcyBtb25vdG9uZe+8jEZpbmQgcm9vdCB0aHJvdWdoIEJpc2VjdGlvbiBtZXRob2RcbiAgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgLy8gbGV0IHByZXYgPSB0IC0gaW50ZXJ2YWw7XG4gICAgdmFyIG5leHQgPSB0ICsgaW50ZXJ2YWw7XG4gICAgLy8gdjFbMF0gPSBxdWFkcmF0aWNBdChwMFswXSwgcDFbMF0sIHAyWzBdLCBwcmV2KTtcbiAgICAvLyB2MVsxXSA9IHF1YWRyYXRpY0F0KHAwWzFdLCBwMVsxXSwgcDJbMV0sIHByZXYpO1xuICAgIHYyWzBdID0gcXVhZHJhdGljQXQocDBbMF0sIHAxWzBdLCBwMlswXSwgdCk7XG4gICAgdjJbMV0gPSBxdWFkcmF0aWNBdChwMFsxXSwgcDFbMV0sIHAyWzFdLCB0KTtcbiAgICB2M1swXSA9IHF1YWRyYXRpY0F0KHAwWzBdLCBwMVswXSwgcDJbMF0sIG5leHQpO1xuICAgIHYzWzFdID0gcXVhZHJhdGljQXQocDBbMV0sIHAxWzFdLCBwMlsxXSwgbmV4dCk7XG4gICAgdmFyIGRpZmYgPSB2MkRpc3RTcXVhcmUodjIsIGNlbnRlcikgLSByYWRpdXNTcXVhcmU7XG4gICAgaWYgKG1hdGhBYnMoZGlmZikgPCAxZS0yKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gbGV0IHByZXZEaWZmID0gdjJEaXN0U3F1YXJlKHYxLCBjZW50ZXIpIC0gcmFkaXVzU3F1YXJlO1xuICAgIHZhciBuZXh0RGlmZiA9IHYyRGlzdFNxdWFyZSh2MywgY2VudGVyKSAtIHJhZGl1c1NxdWFyZTtcbiAgICBpbnRlcnZhbCAvPSAyO1xuICAgIGlmIChkaWZmIDwgMCkge1xuICAgICAgaWYgKG5leHREaWZmID49IDApIHtcbiAgICAgICAgdCA9IHQgKyBpbnRlcnZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSB0IC0gaW50ZXJ2YWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXh0RGlmZiA+PSAwKSB7XG4gICAgICAgIHQgPSB0IC0gaW50ZXJ2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gdCArIGludGVydmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdDtcbn1cbi8vIEFkanVzdCBlZGdlIHRvIGF2b2lkXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGp1c3RFZGdlKGdyYXBoLCBzY2FsZSkge1xuICB2YXIgdG1wMCA9IFtdO1xuICB2YXIgcXVhZHJhdGljU3ViZGl2aWRlID0gY3VydmVUb29sLnF1YWRyYXRpY1N1YmRpdmlkZTtcbiAgdmFyIHB0cyA9IFtbXSwgW10sIFtdXTtcbiAgdmFyIHB0czIgPSBbW10sIFtdXTtcbiAgdmFyIHYgPSBbXTtcbiAgc2NhbGUgLz0gMjtcbiAgZ3JhcGguZWFjaEVkZ2UoZnVuY3Rpb24gKGVkZ2UsIGlkeCkge1xuICAgIHZhciBsaW5lUG9pbnRzID0gZWRnZS5nZXRMYXlvdXQoKTtcbiAgICB2YXIgZnJvbVN5bWJvbCA9IGVkZ2UuZ2V0VmlzdWFsKCdmcm9tU3ltYm9sJyk7XG4gICAgdmFyIHRvU3ltYm9sID0gZWRnZS5nZXRWaXN1YWwoJ3RvU3ltYm9sJyk7XG4gICAgaWYgKCFsaW5lUG9pbnRzLl9fb3JpZ2luYWwpIHtcbiAgICAgIGxpbmVQb2ludHMuX19vcmlnaW5hbCA9IFt2ZWMyLmNsb25lKGxpbmVQb2ludHNbMF0pLCB2ZWMyLmNsb25lKGxpbmVQb2ludHNbMV0pXTtcbiAgICAgIGlmIChsaW5lUG9pbnRzWzJdKSB7XG4gICAgICAgIGxpbmVQb2ludHMuX19vcmlnaW5hbC5wdXNoKHZlYzIuY2xvbmUobGluZVBvaW50c1syXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3JpZ2luYWxQb2ludHMgPSBsaW5lUG9pbnRzLl9fb3JpZ2luYWw7XG4gICAgLy8gUXVhZHJhdGljIGN1cnZlXG4gICAgaWYgKGxpbmVQb2ludHNbMl0gIT0gbnVsbCkge1xuICAgICAgdmVjMi5jb3B5KHB0c1swXSwgb3JpZ2luYWxQb2ludHNbMF0pO1xuICAgICAgdmVjMi5jb3B5KHB0c1sxXSwgb3JpZ2luYWxQb2ludHNbMl0pO1xuICAgICAgdmVjMi5jb3B5KHB0c1syXSwgb3JpZ2luYWxQb2ludHNbMV0pO1xuICAgICAgaWYgKGZyb21TeW1ib2wgJiYgZnJvbVN5bWJvbCAhPT0gJ25vbmUnKSB7XG4gICAgICAgIHZhciBzeW1ib2xTaXplID0gZ2V0U3ltYm9sU2l6ZShlZGdlLm5vZGUxKTtcbiAgICAgICAgdmFyIHQgPSBpbnRlcnNlY3RDdXJ2ZUNpcmNsZShwdHMsIG9yaWdpbmFsUG9pbnRzWzBdLCBzeW1ib2xTaXplICogc2NhbGUpO1xuICAgICAgICAvLyBTdWJkaXZpZGUgYW5kIGdldCB0aGUgc2Vjb25kXG4gICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZShwdHNbMF1bMF0sIHB0c1sxXVswXSwgcHRzWzJdWzBdLCB0LCB0bXAwKTtcbiAgICAgICAgcHRzWzBdWzBdID0gdG1wMFszXTtcbiAgICAgICAgcHRzWzFdWzBdID0gdG1wMFs0XTtcbiAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKHB0c1swXVsxXSwgcHRzWzFdWzFdLCBwdHNbMl1bMV0sIHQsIHRtcDApO1xuICAgICAgICBwdHNbMF1bMV0gPSB0bXAwWzNdO1xuICAgICAgICBwdHNbMV1bMV0gPSB0bXAwWzRdO1xuICAgICAgfVxuICAgICAgaWYgKHRvU3ltYm9sICYmIHRvU3ltYm9sICE9PSAnbm9uZScpIHtcbiAgICAgICAgdmFyIHN5bWJvbFNpemUgPSBnZXRTeW1ib2xTaXplKGVkZ2Uubm9kZTIpO1xuICAgICAgICB2YXIgdCA9IGludGVyc2VjdEN1cnZlQ2lyY2xlKHB0cywgb3JpZ2luYWxQb2ludHNbMV0sIHN5bWJvbFNpemUgKiBzY2FsZSk7XG4gICAgICAgIC8vIFN1YmRpdmlkZSBhbmQgZ2V0IHRoZSBmaXJzdFxuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUocHRzWzBdWzBdLCBwdHNbMV1bMF0sIHB0c1syXVswXSwgdCwgdG1wMCk7XG4gICAgICAgIHB0c1sxXVswXSA9IHRtcDBbMV07XG4gICAgICAgIHB0c1syXVswXSA9IHRtcDBbMl07XG4gICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZShwdHNbMF1bMV0sIHB0c1sxXVsxXSwgcHRzWzJdWzFdLCB0LCB0bXAwKTtcbiAgICAgICAgcHRzWzFdWzFdID0gdG1wMFsxXTtcbiAgICAgICAgcHRzWzJdWzFdID0gdG1wMFsyXTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgYmFjayB0byBsYXlvdXRcbiAgICAgIHZlYzIuY29weShsaW5lUG9pbnRzWzBdLCBwdHNbMF0pO1xuICAgICAgdmVjMi5jb3B5KGxpbmVQb2ludHNbMV0sIHB0c1syXSk7XG4gICAgICB2ZWMyLmNvcHkobGluZVBvaW50c1syXSwgcHRzWzFdKTtcbiAgICB9XG4gICAgLy8gTGluZVxuICAgIGVsc2Uge1xuICAgICAgdmVjMi5jb3B5KHB0czJbMF0sIG9yaWdpbmFsUG9pbnRzWzBdKTtcbiAgICAgIHZlYzIuY29weShwdHMyWzFdLCBvcmlnaW5hbFBvaW50c1sxXSk7XG4gICAgICB2ZWMyLnN1Yih2LCBwdHMyWzFdLCBwdHMyWzBdKTtcbiAgICAgIHZlYzIubm9ybWFsaXplKHYsIHYpO1xuICAgICAgaWYgKGZyb21TeW1ib2wgJiYgZnJvbVN5bWJvbCAhPT0gJ25vbmUnKSB7XG4gICAgICAgIHZhciBzeW1ib2xTaXplID0gZ2V0U3ltYm9sU2l6ZShlZGdlLm5vZGUxKTtcbiAgICAgICAgdmVjMi5zY2FsZUFuZEFkZChwdHMyWzBdLCBwdHMyWzBdLCB2LCBzeW1ib2xTaXplICogc2NhbGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRvU3ltYm9sICYmIHRvU3ltYm9sICE9PSAnbm9uZScpIHtcbiAgICAgICAgdmFyIHN5bWJvbFNpemUgPSBnZXRTeW1ib2xTaXplKGVkZ2Uubm9kZTIpO1xuICAgICAgICB2ZWMyLnNjYWxlQW5kQWRkKHB0czJbMV0sIHB0czJbMV0sIHYsIC1zeW1ib2xTaXplICogc2NhbGUpO1xuICAgICAgfVxuICAgICAgdmVjMi5jb3B5KGxpbmVQb2ludHNbMF0sIHB0czJbMF0pO1xuICAgICAgdmVjMi5jb3B5KGxpbmVQb2ludHNbMV0sIHB0czJbMV0pO1xuICAgIH1cbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBTeW1ib2xEcmF3IGZyb20gJy4uL2hlbHBlci9TeW1ib2xEcmF3LmpzJztcbmltcG9ydCBMaW5lRHJhdyBmcm9tICcuLi9oZWxwZXIvTGluZURyYXcuanMnO1xuaW1wb3J0IFJvYW1Db250cm9sbGVyIGZyb20gJy4uLy4uL2NvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXIuanMnO1xuaW1wb3J0ICogYXMgcm9hbUhlbHBlciBmcm9tICcuLi8uLi9jb21wb25lbnQvaGVscGVyL3JvYW1IZWxwZXIuanMnO1xuaW1wb3J0IHsgb25JcnJlbGV2YW50RWxlbWVudCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudC9oZWxwZXIvY3Vyc29ySGVscGVyLmpzJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCBhZGp1c3RFZGdlIGZyb20gJy4vYWRqdXN0RWRnZS5qcyc7XG5pbXBvcnQgeyBnZXROb2RlR2xvYmFsU2NhbGUgfSBmcm9tICcuL2dyYXBoSGVscGVyLmpzJztcbmltcG9ydCBDaGFydFZpZXcgZnJvbSAnLi4vLi4vdmlldy9DaGFydC5qcyc7XG5pbXBvcnQgeyBnZXRFQ0RhdGEgfSBmcm9tICcuLi8uLi91dGlsL2lubmVyU3RvcmUuanMnO1xuaW1wb3J0IHsgc2ltcGxlTGF5b3V0RWRnZSB9IGZyb20gJy4vc2ltcGxlTGF5b3V0SGVscGVyLmpzJztcbmltcG9ydCB7IGNpcmN1bGFyTGF5b3V0LCByb3RhdGVOb2RlTGFiZWwgfSBmcm9tICcuL2NpcmN1bGFyTGF5b3V0SGVscGVyLmpzJztcbmZ1bmN0aW9uIGlzVmlld0Nvb3JkU3lzKGNvb3JkU3lzKSB7XG4gIHJldHVybiBjb29yZFN5cy50eXBlID09PSAndmlldyc7XG59XG52YXIgR3JhcGhWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEdyYXBoVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gR3JhcGhWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBHcmFwaFZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgR3JhcGhWaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBzeW1ib2xEcmF3ID0gbmV3IFN5bWJvbERyYXcoKTtcbiAgICB2YXIgbGluZURyYXcgPSBuZXcgTGluZURyYXcoKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHRoaXMuX2NvbnRyb2xsZXIgPSBuZXcgUm9hbUNvbnRyb2xsZXIoYXBpLmdldFpyKCkpO1xuICAgIHRoaXMuX2NvbnRyb2xsZXJIb3N0ID0ge1xuICAgICAgdGFyZ2V0OiBncm91cFxuICAgIH07XG4gICAgZ3JvdXAuYWRkKHN5bWJvbERyYXcuZ3JvdXApO1xuICAgIGdyb3VwLmFkZChsaW5lRHJhdy5ncm91cCk7XG4gICAgdGhpcy5fc3ltYm9sRHJhdyA9IHN5bWJvbERyYXc7XG4gICAgdGhpcy5fbGluZURyYXcgPSBsaW5lRHJhdztcbiAgICB0aGlzLl9maXJzdFJlbmRlciA9IHRydWU7XG4gIH07XG4gIEdyYXBoVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdGhpcy5fbW9kZWwgPSBzZXJpZXNNb2RlbDtcbiAgICB2YXIgc3ltYm9sRHJhdyA9IHRoaXMuX3N5bWJvbERyYXc7XG4gICAgdmFyIGxpbmVEcmF3ID0gdGhpcy5fbGluZURyYXc7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICBpZiAoaXNWaWV3Q29vcmRTeXMoY29vcmRTeXMpKSB7XG4gICAgICB2YXIgZ3JvdXBOZXdQcm9wID0ge1xuICAgICAgICB4OiBjb29yZFN5cy54LFxuICAgICAgICB5OiBjb29yZFN5cy55LFxuICAgICAgICBzY2FsZVg6IGNvb3JkU3lzLnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiBjb29yZFN5cy5zY2FsZVlcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5fZmlyc3RSZW5kZXIpIHtcbiAgICAgICAgZ3JvdXAuYXR0cihncm91cE5ld1Byb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhncm91cCwgZ3JvdXBOZXdQcm9wLCBzZXJpZXNNb2RlbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpeCBlZGdlIGNvbnRhY3QgcG9pbnQgd2l0aCBub2RlXG4gICAgYWRqdXN0RWRnZShzZXJpZXNNb2RlbC5nZXRHcmFwaCgpLCBnZXROb2RlR2xvYmFsU2NhbGUoc2VyaWVzTW9kZWwpKTtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICBzeW1ib2xEcmF3LnVwZGF0ZURhdGEoZGF0YSk7XG4gICAgdmFyIGVkZ2VEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RWRnZURhdGEoKTtcbiAgICAvLyBUT0RPOiBUWVBFXG4gICAgbGluZURyYXcudXBkYXRlRGF0YShlZGdlRGF0YSk7XG4gICAgdGhpcy5fdXBkYXRlTm9kZUFuZExpbmtTY2FsZSgpO1xuICAgIHRoaXMuX3VwZGF0ZUNvbnRyb2xsZXIoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2xheW91dFRpbWVvdXQpO1xuICAgIHZhciBmb3JjZUxheW91dCA9IHNlcmllc01vZGVsLmZvcmNlTGF5b3V0O1xuICAgIHZhciBsYXlvdXRBbmltYXRpb24gPSBzZXJpZXNNb2RlbC5nZXQoWydmb3JjZScsICdsYXlvdXRBbmltYXRpb24nXSk7XG4gICAgaWYgKGZvcmNlTGF5b3V0KSB7XG4gICAgICB0aGlzLl9zdGFydEZvcmNlTGF5b3V0SXRlcmF0aW9uKGZvcmNlTGF5b3V0LCBsYXlvdXRBbmltYXRpb24pO1xuICAgIH1cbiAgICB2YXIgbGF5b3V0ID0gc2VyaWVzTW9kZWwuZ2V0KCdsYXlvdXQnKTtcbiAgICBkYXRhLmdyYXBoLmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgaWR4ID0gbm9kZS5kYXRhSW5kZXg7XG4gICAgICB2YXIgZWwgPSBub2RlLmdldEdyYXBoaWNFbCgpO1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IG5vZGUuZ2V0TW9kZWwoKTtcbiAgICAgIGlmICghZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIGRyYWdnYWJsZVxuICAgICAgZWwub2ZmKCdkcmFnJykub2ZmKCdkcmFnZW5kJyk7XG4gICAgICB2YXIgZHJhZ2dhYmxlID0gaXRlbU1vZGVsLmdldCgnZHJhZ2dhYmxlJyk7XG4gICAgICBpZiAoZHJhZ2dhYmxlKSB7XG4gICAgICAgIGVsLm9uKCdkcmFnJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBzd2l0Y2ggKGxheW91dCkge1xuICAgICAgICAgICAgY2FzZSAnZm9yY2UnOlxuICAgICAgICAgICAgICBmb3JjZUxheW91dC53YXJtVXAoKTtcbiAgICAgICAgICAgICAgIV90aGlzLl9sYXlvdXRpbmcgJiYgX3RoaXMuX3N0YXJ0Rm9yY2VMYXlvdXRJdGVyYXRpb24oZm9yY2VMYXlvdXQsIGxheW91dEFuaW1hdGlvbik7XG4gICAgICAgICAgICAgIGZvcmNlTGF5b3V0LnNldEZpeGVkKGlkeCk7XG4gICAgICAgICAgICAgIC8vIFdyaXRlIHBvc2l0aW9uIGJhY2sgdG8gbGF5b3V0XG4gICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIFtlbC54LCBlbC55XSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2lyY3VsYXInOlxuICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBbZWwueCwgZWwueV0pO1xuICAgICAgICAgICAgICAvLyBtYXJrIG5vZGUgZml4ZWRcbiAgICAgICAgICAgICAgbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgICAgICAgICAgIGZpeGVkOiB0cnVlXG4gICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAvLyByZWNhbGN1bGF0ZSBjaXJjdWxhciBsYXlvdXRcbiAgICAgICAgICAgICAgY2lyY3VsYXJMYXlvdXQoc2VyaWVzTW9kZWwsICdzeW1ib2xTaXplJywgbm9kZSwgW2Uub2Zmc2V0WCwgZS5vZmZzZXRZXSk7XG4gICAgICAgICAgICAgIF90aGlzLnVwZGF0ZUxheW91dChzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBbZWwueCwgZWwueV0pO1xuICAgICAgICAgICAgICAvLyB1cGRhdGUgZWRnZVxuICAgICAgICAgICAgICBzaW1wbGVMYXlvdXRFZGdlKHNlcmllc01vZGVsLmdldEdyYXBoKCksIHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgX3RoaXMudXBkYXRlTGF5b3V0KHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5vbignZHJhZ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZm9yY2VMYXlvdXQpIHtcbiAgICAgICAgICAgIGZvcmNlTGF5b3V0LnNldFVuZml4ZWQoaWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWwuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSwgISFpdGVtTW9kZWwuZ2V0KCdjdXJzb3InKSk7XG4gICAgICB2YXIgZm9jdXMgPSBpdGVtTW9kZWwuZ2V0KFsnZW1waGFzaXMnLCAnZm9jdXMnXSk7XG4gICAgICBpZiAoZm9jdXMgPT09ICdhZGphY2VuY3knKSB7XG4gICAgICAgIGdldEVDRGF0YShlbCkuZm9jdXMgPSBub2RlLmdldEFkamFjZW50RGF0YUluZGljZXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkYXRhLmdyYXBoLmVhY2hFZGdlKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICB2YXIgZWwgPSBlZGdlLmdldEdyYXBoaWNFbCgpO1xuICAgICAgdmFyIGZvY3VzID0gZWRnZS5nZXRNb2RlbCgpLmdldChbJ2VtcGhhc2lzJywgJ2ZvY3VzJ10pO1xuICAgICAgaWYgKCFlbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZm9jdXMgPT09ICdhZGphY2VuY3knKSB7XG4gICAgICAgIGdldEVDRGF0YShlbCkuZm9jdXMgPSB7XG4gICAgICAgICAgZWRnZTogW2VkZ2UuZGF0YUluZGV4XSxcbiAgICAgICAgICBub2RlOiBbZWRnZS5ub2RlMS5kYXRhSW5kZXgsIGVkZ2Uubm9kZTIuZGF0YUluZGV4XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBjaXJjdWxhclJvdGF0ZUxhYmVsID0gc2VyaWVzTW9kZWwuZ2V0KCdsYXlvdXQnKSA9PT0gJ2NpcmN1bGFyJyAmJiBzZXJpZXNNb2RlbC5nZXQoWydjaXJjdWxhcicsICdyb3RhdGVMYWJlbCddKTtcbiAgICB2YXIgY3ggPSBkYXRhLmdldExheW91dCgnY3gnKTtcbiAgICB2YXIgY3kgPSBkYXRhLmdldExheW91dCgnY3knKTtcbiAgICBkYXRhLmdyYXBoLmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByb3RhdGVOb2RlTGFiZWwobm9kZSwgY2lyY3VsYXJSb3RhdGVMYWJlbCwgY3gsIGN5KTtcbiAgICB9KTtcbiAgICB0aGlzLl9maXJzdFJlbmRlciA9IGZhbHNlO1xuICB9O1xuICBHcmFwaFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgICB0aGlzLl9jb250cm9sbGVyICYmIHRoaXMuX2NvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2NvbnRyb2xsZXJIb3N0ID0gbnVsbDtcbiAgfTtcbiAgR3JhcGhWaWV3LnByb3RvdHlwZS5fc3RhcnRGb3JjZUxheW91dEl0ZXJhdGlvbiA9IGZ1bmN0aW9uIChmb3JjZUxheW91dCwgbGF5b3V0QW5pbWF0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIChmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgZm9yY2VMYXlvdXQuc3RlcChmdW5jdGlvbiAoc3RvcHBlZCkge1xuICAgICAgICBzZWxmLnVwZGF0ZUxheW91dChzZWxmLl9tb2RlbCk7XG4gICAgICAgIChzZWxmLl9sYXlvdXRpbmcgPSAhc3RvcHBlZCkgJiYgKGxheW91dEFuaW1hdGlvbiA/IHNlbGYuX2xheW91dFRpbWVvdXQgPSBzZXRUaW1lb3V0KHN0ZXAsIDE2KSA6IHN0ZXAoKSk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9O1xuICBHcmFwaFZpZXcucHJvdG90eXBlLl91cGRhdGVDb250cm9sbGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBjb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlcjtcbiAgICB2YXIgY29udHJvbGxlckhvc3QgPSB0aGlzLl9jb250cm9sbGVySG9zdDtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIGNvbnRyb2xsZXIuc2V0UG9pbnRlckNoZWNrZXIoZnVuY3Rpb24gKGUsIHgsIHkpIHtcbiAgICAgIHZhciByZWN0ID0gZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICByZWN0LmFwcGx5VHJhbnNmb3JtKGdyb3VwLnRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gcmVjdC5jb250YWluKHgsIHkpICYmICFvbklycmVsZXZhbnRFbGVtZW50KGUsIGFwaSwgc2VyaWVzTW9kZWwpO1xuICAgIH0pO1xuICAgIGlmICghaXNWaWV3Q29vcmRTeXMoc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSkpIHtcbiAgICAgIGNvbnRyb2xsZXIuZGlzYWJsZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250cm9sbGVyLmVuYWJsZShzZXJpZXNNb2RlbC5nZXQoJ3JvYW0nKSk7XG4gICAgY29udHJvbGxlckhvc3Quem9vbUxpbWl0ID0gc2VyaWVzTW9kZWwuZ2V0KCdzY2FsZUxpbWl0Jyk7XG4gICAgY29udHJvbGxlckhvc3Quem9vbSA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0Wm9vbSgpO1xuICAgIGNvbnRyb2xsZXIub2ZmKCdwYW4nKS5vZmYoJ3pvb20nKS5vbigncGFuJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJvYW1IZWxwZXIudXBkYXRlVmlld09uUGFuKGNvbnRyb2xsZXJIb3N0LCBlLmR4LCBlLmR5KTtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHNlcmllc0lkOiBzZXJpZXNNb2RlbC5pZCxcbiAgICAgICAgdHlwZTogJ2dyYXBoUm9hbScsXG4gICAgICAgIGR4OiBlLmR4LFxuICAgICAgICBkeTogZS5keVxuICAgICAgfSk7XG4gICAgfSkub24oJ3pvb20nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcm9hbUhlbHBlci51cGRhdGVWaWV3T25ab29tKGNvbnRyb2xsZXJIb3N0LCBlLnNjYWxlLCBlLm9yaWdpblgsIGUub3JpZ2luWSk7XG4gICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICBzZXJpZXNJZDogc2VyaWVzTW9kZWwuaWQsXG4gICAgICAgIHR5cGU6ICdncmFwaFJvYW0nLFxuICAgICAgICB6b29tOiBlLnNjYWxlLFxuICAgICAgICBvcmlnaW5YOiBlLm9yaWdpblgsXG4gICAgICAgIG9yaWdpblk6IGUub3JpZ2luWVxuICAgICAgfSk7XG4gICAgICBfdGhpcy5fdXBkYXRlTm9kZUFuZExpbmtTY2FsZSgpO1xuICAgICAgYWRqdXN0RWRnZShzZXJpZXNNb2RlbC5nZXRHcmFwaCgpLCBnZXROb2RlR2xvYmFsU2NhbGUoc2VyaWVzTW9kZWwpKTtcbiAgICAgIF90aGlzLl9saW5lRHJhdy51cGRhdGVMYXlvdXQoKTtcbiAgICAgIC8vIE9ubHkgdXBkYXRlIGxhYmVsIGxheW91dCBvbiB6b29tXG4gICAgICBhcGkudXBkYXRlTGFiZWxMYXlvdXQoKTtcbiAgICB9KTtcbiAgfTtcbiAgR3JhcGhWaWV3LnByb3RvdHlwZS5fdXBkYXRlTm9kZUFuZExpbmtTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgbm9kZVNjYWxlID0gZ2V0Tm9kZUdsb2JhbFNjYWxlKHNlcmllc01vZGVsKTtcbiAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICBlbCAmJiBlbC5zZXRTeW1ib2xTY2FsZShub2RlU2NhbGUpO1xuICAgIH0pO1xuICB9O1xuICBHcmFwaFZpZXcucHJvdG90eXBlLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIGFkanVzdEVkZ2Uoc2VyaWVzTW9kZWwuZ2V0R3JhcGgoKSwgZ2V0Tm9kZUdsb2JhbFNjYWxlKHNlcmllc01vZGVsKSk7XG4gICAgdGhpcy5fc3ltYm9sRHJhdy51cGRhdGVMYXlvdXQoKTtcbiAgICB0aGlzLl9saW5lRHJhdy51cGRhdGVMYXlvdXQoKTtcbiAgfTtcbiAgR3JhcGhWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2xheW91dFRpbWVvdXQpO1xuICAgIHRoaXMuX2xheW91dGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2xheW91dFRpbWVvdXQgPSBudWxsO1xuICAgIHRoaXMuX3N5bWJvbERyYXcgJiYgdGhpcy5fc3ltYm9sRHJhdy5yZW1vdmUoKTtcbiAgICB0aGlzLl9saW5lRHJhdyAmJiB0aGlzLl9saW5lRHJhdy5yZW1vdmUoKTtcbiAgfTtcbiAgR3JhcGhWaWV3LnR5cGUgPSAnZ3JhcGgnO1xuICByZXR1cm4gR3JhcGhWaWV3O1xufShDaGFydFZpZXcpO1xuZXhwb3J0IGRlZmF1bHQgR3JhcGhWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgU2VyaWVzRGF0YSBmcm9tICcuLi8uLi9kYXRhL1Nlcmllc0RhdGEuanMnO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0RW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Nb2RlbC5qcyc7XG5pbXBvcnQgY3JlYXRlR3JhcGhGcm9tTm9kZUVkZ2UgZnJvbSAnLi4vaGVscGVyL2NyZWF0ZUdyYXBoRnJvbU5vZGVFZGdlLmpzJztcbmltcG9ydCBMZWdlbmRWaXN1YWxQcm92aWRlciBmcm9tICcuLi8uLi92aXN1YWwvTGVnZW5kVmlzdWFsUHJvdmlkZXIuanMnO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVUb29sdGlwTWFya3VwIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50L3Rvb2x0aXAvdG9vbHRpcE1hcmt1cC5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0U2VyaWVzRm9ybWF0VG9vbHRpcCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudC90b29sdGlwL3Nlcmllc0Zvcm1hdFRvb2x0aXAuanMnO1xuaW1wb3J0IHsgaW5pdEN1cnZlbmVzc0xpc3QsIGNyZWF0ZUVkZ2VNYXBGb3JDdXJ2ZW5lc3MgfSBmcm9tICcuLi9oZWxwZXIvbXVsdGlwbGVHcmFwaEVkZ2VIZWxwZXIuanMnO1xudmFyIEdyYXBoU2VyaWVzTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoR3JhcGhTZXJpZXNNb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gR3JhcGhTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gR3JhcGhTZXJpZXNNb2RlbC50eXBlO1xuICAgIF90aGlzLmhhc1N5bWJvbFZpc3VhbCA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEdyYXBoU2VyaWVzTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIGdldENhdGVnb3JpZXNEYXRhKCkge1xuICAgICAgcmV0dXJuIHNlbGYuX2NhdGVnb3JpZXNEYXRhO1xuICAgIH1cbiAgICAvLyBQcm92aWRlIGRhdGEgZm9yIGxlZ2VuZCBzZWxlY3RcbiAgICB0aGlzLmxlZ2VuZFZpc3VhbFByb3ZpZGVyID0gbmV3IExlZ2VuZFZpc3VhbFByb3ZpZGVyKGdldENhdGVnb3JpZXNEYXRhLCBnZXRDYXRlZ29yaWVzRGF0YSk7XG4gICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShvcHRpb24uZWRnZXMgfHwgb3B0aW9uLmxpbmtzKTtcbiAgICB0aGlzLl91cGRhdGVDYXRlZ29yaWVzRGF0YSgpO1xuICB9O1xuICBHcmFwaFNlcmllc01vZGVsLnByb3RvdHlwZS5tZXJnZU9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLm1lcmdlT3B0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShvcHRpb24uZWRnZXMgfHwgb3B0aW9uLmxpbmtzKTtcbiAgICB0aGlzLl91cGRhdGVDYXRlZ29yaWVzRGF0YSgpO1xuICB9O1xuICBHcmFwaFNlcmllc01vZGVsLnByb3RvdHlwZS5tZXJnZURlZmF1bHRBbmRUaGVtZSA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLm1lcmdlRGVmYXVsdEFuZFRoZW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgZGVmYXVsdEVtcGhhc2lzKG9wdGlvbiwgJ2VkZ2VMYWJlbCcsIFsnc2hvdyddKTtcbiAgfTtcbiAgR3JhcGhTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGEgPSBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgdmFyIGVkZ2VzID0gb3B0aW9uLmVkZ2VzIHx8IG9wdGlvbi5saW5rcyB8fCBbXTtcbiAgICB2YXIgbm9kZXMgPSBvcHRpb24uZGF0YSB8fCBvcHRpb24ubm9kZXMgfHwgW107XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChub2RlcyAmJiBlZGdlcykge1xuICAgICAgLy8gYXV0byBjdXJ2ZW5lc3NcbiAgICAgIGluaXRDdXJ2ZW5lc3NMaXN0KHRoaXMpO1xuICAgICAgdmFyIGdyYXBoID0gY3JlYXRlR3JhcGhGcm9tTm9kZUVkZ2Uobm9kZXMsIGVkZ2VzLCB0aGlzLCB0cnVlLCBiZWZvcmVMaW5rKTtcbiAgICAgIHpyVXRpbC5lYWNoKGdyYXBoLmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICBjcmVhdGVFZGdlTWFwRm9yQ3VydmVuZXNzKGVkZ2Uubm9kZTEsIGVkZ2Uubm9kZTIsIHRoaXMsIGVkZ2UuZGF0YUluZGV4KTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuIGdyYXBoLmRhdGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJlZm9yZUxpbmsobm9kZURhdGEsIGVkZ2VEYXRhKSB7XG4gICAgICAvLyBPdmVyd3JpdGUgbm9kZURhdGEuZ2V0SXRlbU1vZGVsIHRvXG4gICAgICBub2RlRGF0YS53cmFwTWV0aG9kKCdnZXRJdGVtTW9kZWwnLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXNNb2RlbHMgPSBzZWxmLl9jYXRlZ29yaWVzTW9kZWxzO1xuICAgICAgICB2YXIgY2F0ZWdvcnlJZHggPSBtb2RlbC5nZXRTaGFsbG93KCdjYXRlZ29yeScpO1xuICAgICAgICB2YXIgY2F0ZWdvcnlNb2RlbCA9IGNhdGVnb3JpZXNNb2RlbHNbY2F0ZWdvcnlJZHhdO1xuICAgICAgICBpZiAoY2F0ZWdvcnlNb2RlbCkge1xuICAgICAgICAgIGNhdGVnb3J5TW9kZWwucGFyZW50TW9kZWwgPSBtb2RlbC5wYXJlbnRNb2RlbDtcbiAgICAgICAgICBtb2RlbC5wYXJlbnRNb2RlbCA9IGNhdGVnb3J5TW9kZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgfSk7XG4gICAgICAvLyBUT0RPIEluaGVyaXQgcmVzb2x2ZVBhcmVudFBhdGggYnkgZGVmYXVsdCBpbiBNb2RlbCNnZXRNb2RlbD9cbiAgICAgIHZhciBvbGRHZXRNb2RlbCA9IE1vZGVsLnByb3RvdHlwZS5nZXRNb2RlbDtcbiAgICAgIGZ1bmN0aW9uIG5ld0dldE1vZGVsKHBhdGgsIHBhcmVudE1vZGVsKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IG9sZEdldE1vZGVsLmNhbGwodGhpcywgcGF0aCwgcGFyZW50TW9kZWwpO1xuICAgICAgICBtb2RlbC5yZXNvbHZlUGFyZW50UGF0aCA9IHJlc29sdmVQYXJlbnRQYXRoO1xuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICB9XG4gICAgICBlZGdlRGF0YS53cmFwTWV0aG9kKCdnZXRJdGVtTW9kZWwnLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWwucmVzb2x2ZVBhcmVudFBhdGggPSByZXNvbHZlUGFyZW50UGF0aDtcbiAgICAgICAgbW9kZWwuZ2V0TW9kZWwgPSBuZXdHZXRNb2RlbDtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgfSk7XG4gICAgICBmdW5jdGlvbiByZXNvbHZlUGFyZW50UGF0aChwYXRoQXJyKSB7XG4gICAgICAgIGlmIChwYXRoQXJyICYmIChwYXRoQXJyWzBdID09PSAnbGFiZWwnIHx8IHBhdGhBcnJbMV0gPT09ICdsYWJlbCcpKSB7XG4gICAgICAgICAgdmFyIG5ld1BhdGhBcnIgPSBwYXRoQXJyLnNsaWNlKCk7XG4gICAgICAgICAgaWYgKHBhdGhBcnJbMF0gPT09ICdsYWJlbCcpIHtcbiAgICAgICAgICAgIG5ld1BhdGhBcnJbMF0gPSAnZWRnZUxhYmVsJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhdGhBcnJbMV0gPT09ICdsYWJlbCcpIHtcbiAgICAgICAgICAgIG5ld1BhdGhBcnJbMV0gPSAnZWRnZUxhYmVsJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ld1BhdGhBcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGhBcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBHcmFwaFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRHcmFwaCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREYXRhKCkuZ3JhcGg7XG4gIH07XG4gIEdyYXBoU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEVkZ2VEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldEdyYXBoKCkuZWRnZURhdGE7XG4gIH07XG4gIEdyYXBoU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldENhdGVnb3JpZXNEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jYXRlZ29yaWVzRGF0YTtcbiAgfTtcbiAgR3JhcGhTZXJpZXNNb2RlbC5wcm90b3R5cGUuZm9ybWF0VG9vbHRpcCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIG11bHRpcGxlU2VyaWVzLCBkYXRhVHlwZSkge1xuICAgIGlmIChkYXRhVHlwZSA9PT0gJ2VkZ2UnKSB7XG4gICAgICB2YXIgbm9kZURhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmdldERhdGFQYXJhbXMoZGF0YUluZGV4LCBkYXRhVHlwZSk7XG4gICAgICB2YXIgZWRnZSA9IG5vZGVEYXRhLmdyYXBoLmdldEVkZ2VCeUluZGV4KGRhdGFJbmRleCk7XG4gICAgICB2YXIgc291cmNlTmFtZSA9IG5vZGVEYXRhLmdldE5hbWUoZWRnZS5ub2RlMS5kYXRhSW5kZXgpO1xuICAgICAgdmFyIHRhcmdldE5hbWUgPSBub2RlRGF0YS5nZXROYW1lKGVkZ2Uubm9kZTIuZGF0YUluZGV4KTtcbiAgICAgIHZhciBuYW1lQXJyID0gW107XG4gICAgICBzb3VyY2VOYW1lICE9IG51bGwgJiYgbmFtZUFyci5wdXNoKHNvdXJjZU5hbWUpO1xuICAgICAgdGFyZ2V0TmFtZSAhPSBudWxsICYmIG5hbWVBcnIucHVzaCh0YXJnZXROYW1lKTtcbiAgICAgIHJldHVybiBjcmVhdGVUb29sdGlwTWFya3VwKCduYW1lVmFsdWUnLCB7XG4gICAgICAgIG5hbWU6IG5hbWVBcnIuam9pbignID4gJyksXG4gICAgICAgIHZhbHVlOiBwYXJhbXMudmFsdWUsXG4gICAgICAgIG5vVmFsdWU6IHBhcmFtcy52YWx1ZSA9PSBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gZGF0YVR5cGUgPT09ICdub2RlJyBvciBlbXB0eVxuICAgIHZhciBub2RlTWFya3VwID0gZGVmYXVsdFNlcmllc0Zvcm1hdFRvb2x0aXAoe1xuICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgZGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgICBtdWx0aXBsZVNlcmllczogbXVsdGlwbGVTZXJpZXNcbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZU1hcmt1cDtcbiAgfTtcbiAgR3JhcGhTZXJpZXNNb2RlbC5wcm90b3R5cGUuX3VwZGF0ZUNhdGVnb3JpZXNEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYXRlZ29yaWVzID0genJVdGlsLm1hcCh0aGlzLm9wdGlvbi5jYXRlZ29yaWVzIHx8IFtdLCBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgIC8vIERhdGEgbXVzdCBoYXMgdmFsdWVcbiAgICAgIHJldHVybiBjYXRlZ29yeS52YWx1ZSAhPSBudWxsID8gY2F0ZWdvcnkgOiB6clV0aWwuZXh0ZW5kKHtcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0sIGNhdGVnb3J5KTtcbiAgICB9KTtcbiAgICB2YXIgY2F0ZWdvcmllc0RhdGEgPSBuZXcgU2VyaWVzRGF0YShbJ3ZhbHVlJ10sIHRoaXMpO1xuICAgIGNhdGVnb3JpZXNEYXRhLmluaXREYXRhKGNhdGVnb3JpZXMpO1xuICAgIHRoaXMuX2NhdGVnb3JpZXNEYXRhID0gY2F0ZWdvcmllc0RhdGE7XG4gICAgdGhpcy5fY2F0ZWdvcmllc01vZGVscyA9IGNhdGVnb3JpZXNEYXRhLm1hcEFycmF5KGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHJldHVybiBjYXRlZ29yaWVzRGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICB9KTtcbiAgfTtcbiAgR3JhcGhTZXJpZXNNb2RlbC5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uICh6b29tKSB7XG4gICAgdGhpcy5vcHRpb24uem9vbSA9IHpvb207XG4gIH07XG4gIEdyYXBoU2VyaWVzTW9kZWwucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uIChjZW50ZXIpIHtcbiAgICB0aGlzLm9wdGlvbi5jZW50ZXIgPSBjZW50ZXI7XG4gIH07XG4gIEdyYXBoU2VyaWVzTW9kZWwucHJvdG90eXBlLmlzQW5pbWF0aW9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5pc0FuaW1hdGlvbkVuYWJsZWQuY2FsbCh0aGlzKVxuICAgIC8vIE5vdCBlbmFibGUgYW5pbWF0aW9uIHdoZW4gZG8gZm9yY2UgbGF5b3V0XG4gICAgJiYgISh0aGlzLmdldCgnbGF5b3V0JykgPT09ICdmb3JjZScgJiYgdGhpcy5nZXQoWydmb3JjZScsICdsYXlvdXRBbmltYXRpb24nXSkpO1xuICB9O1xuICBHcmFwaFNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLmdyYXBoJztcbiAgR3JhcGhTZXJpZXNNb2RlbC5kZXBlbmRlbmNpZXMgPSBbJ2dyaWQnLCAncG9sYXInLCAnZ2VvJywgJ3NpbmdsZUF4aXMnLCAnY2FsZW5kYXInXTtcbiAgR3JhcGhTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIC8vIHpsZXZlbDogMCxcbiAgICB6OiAyLFxuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICd2aWV3JyxcbiAgICAvLyBEZWZhdWx0IG9wdGlvbiBmb3IgYWxsIGNvb3JkaW5hdGUgc3lzdGVtc1xuICAgIC8vIHhBeGlzSW5kZXg6IDAsXG4gICAgLy8geUF4aXNJbmRleDogMCxcbiAgICAvLyBwb2xhckluZGV4OiAwLFxuICAgIC8vIGdlb0luZGV4OiAwLFxuICAgIGxlZ2VuZEhvdmVyTGluazogdHJ1ZSxcbiAgICBsYXlvdXQ6IG51bGwsXG4gICAgLy8gQ29uZmlndXJhdGlvbiBvZiBjaXJjdWxhciBsYXlvdXRcbiAgICBjaXJjdWxhcjoge1xuICAgICAgcm90YXRlTGFiZWw6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBDb25maWd1cmF0aW9uIG9mIGZvcmNlIGRpcmVjdGVkIGxheW91dFxuICAgIGZvcmNlOiB7XG4gICAgICBpbml0TGF5b3V0OiBudWxsLFxuICAgICAgLy8gTm9kZSByZXB1bHNpb24uIENhbiBiZSBhbiBhcnJheSB0byByZXByZXNlbnQgcmFuZ2UuXG4gICAgICByZXB1bHNpb246IFswLCA1MF0sXG4gICAgICBncmF2aXR5OiAwLjEsXG4gICAgICAvLyBJbml0aWFsIGZyaWN0aW9uXG4gICAgICBmcmljdGlvbjogMC42LFxuICAgICAgLy8gRWRnZSBsZW5ndGguIENhbiBiZSBhbiBhcnJheSB0byByZXByZXNlbnQgcmFuZ2UuXG4gICAgICBlZGdlTGVuZ3RoOiAzMCxcbiAgICAgIGxheW91dEFuaW1hdGlvbjogdHJ1ZVxuICAgIH0sXG4gICAgbGVmdDogJ2NlbnRlcicsXG4gICAgdG9wOiAnY2VudGVyJyxcbiAgICAvLyByaWdodDogbnVsbCxcbiAgICAvLyBib3R0b206IG51bGwsXG4gICAgLy8gd2lkdGg6ICc4MCUnLFxuICAgIC8vIGhlaWdodDogJzgwJScsXG4gICAgc3ltYm9sOiAnY2lyY2xlJyxcbiAgICBzeW1ib2xTaXplOiAxMCxcbiAgICBlZGdlU3ltYm9sOiBbJ25vbmUnLCAnbm9uZSddLFxuICAgIGVkZ2VTeW1ib2xTaXplOiAxMCxcbiAgICBlZGdlTGFiZWw6IHtcbiAgICAgIHBvc2l0aW9uOiAnbWlkZGxlJyxcbiAgICAgIGRpc3RhbmNlOiA1XG4gICAgfSxcbiAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgIHJvYW06IGZhbHNlLFxuICAgIC8vIERlZmF1bHQgb24gY2VudGVyIG9mIGdyYXBoXG4gICAgY2VudGVyOiBudWxsLFxuICAgIHpvb206IDEsXG4gICAgLy8gU3ltYm9sIHNpemUgc2NhbGUgcmF0aW8gaW4gcm9hbVxuICAgIG5vZGVTY2FsZVJhdGlvOiAwLjYsXG4gICAgLy8gY3Vyc29yOiBudWxsLFxuICAgIC8vIGNhdGVnb3JpZXM6IFtdLFxuICAgIC8vIGRhdGE6IFtdXG4gICAgLy8gT3JcbiAgICAvLyBub2RlczogW11cbiAgICAvL1xuICAgIC8vIGxpbmtzOiBbXVxuICAgIC8vIE9yXG4gICAgLy8gZWRnZXM6IFtdXG4gICAgbGFiZWw6IHtcbiAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgZm9ybWF0dGVyOiAne2J9J1xuICAgIH0sXG4gICAgaXRlbVN0eWxlOiB7fSxcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnI2FhYScsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIG9wYWNpdHk6IDAuNVxuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIHNjYWxlOiB0cnVlLFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0OiB7XG4gICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMjEyMTIxJ1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEdyYXBoU2VyaWVzTW9kZWw7XG59KFNlcmllc01vZGVsKTtcbmV4cG9ydCBkZWZhdWx0IEdyYXBoU2VyaWVzTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgY2F0ZWdvcnlGaWx0ZXIgZnJvbSAnLi9jYXRlZ29yeUZpbHRlci5qcyc7XG5pbXBvcnQgY2F0ZWdvcnlWaXN1YWwgZnJvbSAnLi9jYXRlZ29yeVZpc3VhbC5qcyc7XG5pbXBvcnQgZWRnZVZpc3VhbCBmcm9tICcuL2VkZ2VWaXN1YWwuanMnO1xuaW1wb3J0IHNpbXBsZUxheW91dCBmcm9tICcuL3NpbXBsZUxheW91dC5qcyc7XG5pbXBvcnQgY2lyY3VsYXJMYXlvdXQgZnJvbSAnLi9jaXJjdWxhckxheW91dC5qcyc7XG5pbXBvcnQgZm9yY2VMYXlvdXQgZnJvbSAnLi9mb3JjZUxheW91dC5qcyc7XG5pbXBvcnQgY3JlYXRlVmlldyBmcm9tICcuL2NyZWF0ZVZpZXcuanMnO1xuaW1wb3J0IFZpZXcgZnJvbSAnLi4vLi4vY29vcmQvVmlldy5qcyc7XG5pbXBvcnQgR3JhcGhWaWV3IGZyb20gJy4vR3JhcGhWaWV3LmpzJztcbmltcG9ydCBHcmFwaFNlcmllc01vZGVsIGZyb20gJy4vR3JhcGhTZXJpZXMuanMnO1xuaW1wb3J0IHsgdXBkYXRlQ2VudGVyQW5kWm9vbSB9IGZyb20gJy4uLy4uL2FjdGlvbi9yb2FtSGVscGVyLmpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xudmFyIGFjdGlvbkluZm8gPSB7XG4gIHR5cGU6ICdncmFwaFJvYW0nLFxuICBldmVudDogJ2dyYXBoUm9hbScsXG4gIHVwZGF0ZTogJ25vbmUnXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhHcmFwaFZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChHcmFwaFNlcmllc01vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJvY2Vzc29yKGNhdGVnb3J5RmlsdGVyKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyVmlzdWFsKGNhdGVnb3J5VmlzdWFsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyVmlzdWFsKGVkZ2VWaXN1YWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQoc2ltcGxlTGF5b3V0KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KHJlZ2lzdGVycy5QUklPUklUWS5WSVNVQUwuUE9TVF9DSEFSVF9MQVlPVVQsIGNpcmN1bGFyTGF5b3V0KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KGZvcmNlTGF5b3V0KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29vcmRpbmF0ZVN5c3RlbSgnZ3JhcGhWaWV3Jywge1xuICAgIGRpbWVuc2lvbnM6IFZpZXcuZGltZW5zaW9ucyxcbiAgICBjcmVhdGU6IGNyZWF0ZVZpZXdcbiAgfSk7XG4gIC8vIFJlZ2lzdGVyIGxlZ2FjeSBmb2N1cyBhY3Rpb25zXG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogJ2ZvY3VzTm9kZUFkamFjZW5jeScsXG4gICAgZXZlbnQ6ICdmb2N1c05vZGVBZGphY2VuY3knLFxuICAgIHVwZGF0ZTogJ3Nlcmllczpmb2N1c05vZGVBZGphY2VuY3knXG4gIH0sIG5vb3ApO1xuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgIHR5cGU6ICd1bmZvY3VzTm9kZUFkamFjZW5jeScsXG4gICAgZXZlbnQ6ICd1bmZvY3VzTm9kZUFkamFjZW5jeScsXG4gICAgdXBkYXRlOiAnc2VyaWVzOnVuZm9jdXNOb2RlQWRqYWNlbmN5J1xuICB9LCBub29wKTtcbiAgLy8gUmVnaXN0ZXIgcm9hbSBhY3Rpb24uXG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbihhY3Rpb25JbmZvLCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiAnc2VyaWVzJyxcbiAgICAgIHF1ZXJ5OiBwYXlsb2FkXG4gICAgfSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdmFyIHJlcyA9IHVwZGF0ZUNlbnRlckFuZFpvb20oY29vcmRTeXMsIHBheWxvYWQsIHVuZGVmaW5lZCwgYXBpKTtcbiAgICAgIHNlcmllc01vZGVsLnNldENlbnRlciAmJiBzZXJpZXNNb2RlbC5zZXRDZW50ZXIocmVzLmNlbnRlcik7XG4gICAgICBzZXJpZXNNb2RlbC5zZXRab29tICYmIHNlcmllc01vZGVsLnNldFpvb20ocmVzLnpvb20pO1xuICAgIH0pO1xuICB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///88745\n")}}]);