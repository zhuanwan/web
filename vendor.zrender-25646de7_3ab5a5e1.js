"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[8865],{14647:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _core_timsort_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83470);\n/* harmony import */ var _graphic_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56448);\n\n\n\nvar invalidZErrorLogged = false;\nfunction logInvalidZError() {\n    if (invalidZErrorLogged) {\n        return;\n    }\n    invalidZErrorLogged = true;\n    console.warn('z / z2 / zlevel of displayable is invalid, which may cause unexpected errors');\n}\nfunction shapeCompareFunc(a, b) {\n    if (a.zlevel === b.zlevel) {\n        if (a.z === b.z) {\n            return a.z2 - b.z2;\n        }\n        return a.z - b.z;\n    }\n    return a.zlevel - b.zlevel;\n}\nvar Storage = (function () {\n    function Storage() {\n        this._roots = [];\n        this._displayList = [];\n        this._displayListLen = 0;\n        this.displayableSortFunc = shapeCompareFunc;\n    }\n    Storage.prototype.traverse = function (cb, context) {\n        for (var i = 0; i < this._roots.length; i++) {\n            this._roots[i].traverse(cb, context);\n        }\n    };\n    Storage.prototype.getDisplayList = function (update, includeIgnore) {\n        includeIgnore = includeIgnore || false;\n        var displayList = this._displayList;\n        if (update || !displayList.length) {\n            this.updateDisplayList(includeIgnore);\n        }\n        return displayList;\n    };\n    Storage.prototype.updateDisplayList = function (includeIgnore) {\n        this._displayListLen = 0;\n        var roots = this._roots;\n        var displayList = this._displayList;\n        for (var i = 0, len = roots.length; i < len; i++) {\n            this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n        }\n        displayList.length = this._displayListLen;\n        (0,_core_timsort_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A)(displayList, shapeCompareFunc);\n    };\n    Storage.prototype._updateAndAddDisplayable = function (el, clipPaths, includeIgnore) {\n        if (el.ignore && !includeIgnore) {\n            return;\n        }\n        el.beforeUpdate();\n        el.update();\n        el.afterUpdate();\n        var userSetClipPath = el.getClipPath();\n        if (el.ignoreClip) {\n            clipPaths = null;\n        }\n        else if (userSetClipPath) {\n            if (clipPaths) {\n                clipPaths = clipPaths.slice();\n            }\n            else {\n                clipPaths = [];\n            }\n            var currentClipPath = userSetClipPath;\n            var parentClipPath = el;\n            while (currentClipPath) {\n                currentClipPath.parent = parentClipPath;\n                currentClipPath.updateTransform();\n                clipPaths.push(currentClipPath);\n                parentClipPath = currentClipPath;\n                currentClipPath = currentClipPath.getClipPath();\n            }\n        }\n        if (el.childrenRef) {\n            var children = el.childrenRef();\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (el.__dirty) {\n                    child.__dirty |= _graphic_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .REDRAW_BIT */ .M;\n                }\n                this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n            }\n            el.__dirty = 0;\n        }\n        else {\n            var disp = el;\n            if (clipPaths && clipPaths.length) {\n                disp.__clipPaths = clipPaths;\n            }\n            else if (disp.__clipPaths && disp.__clipPaths.length > 0) {\n                disp.__clipPaths = [];\n            }\n            if (isNaN(disp.z)) {\n                logInvalidZError();\n                disp.z = 0;\n            }\n            if (isNaN(disp.z2)) {\n                logInvalidZError();\n                disp.z2 = 0;\n            }\n            if (isNaN(disp.zlevel)) {\n                logInvalidZError();\n                disp.zlevel = 0;\n            }\n            this._displayList[this._displayListLen++] = disp;\n        }\n        var decalEl = el.getDecalElement && el.getDecalElement();\n        if (decalEl) {\n            this._updateAndAddDisplayable(decalEl, clipPaths, includeIgnore);\n        }\n        var textGuide = el.getTextGuideLine();\n        if (textGuide) {\n            this._updateAndAddDisplayable(textGuide, clipPaths, includeIgnore);\n        }\n        var textEl = el.getTextContent();\n        if (textEl) {\n            this._updateAndAddDisplayable(textEl, clipPaths, includeIgnore);\n        }\n    };\n    Storage.prototype.addRoot = function (el) {\n        if (el.__zr && el.__zr.storage === this) {\n            return;\n        }\n        this._roots.push(el);\n    };\n    Storage.prototype.delRoot = function (el) {\n        if (el instanceof Array) {\n            for (var i = 0, l = el.length; i < l; i++) {\n                this.delRoot(el[i]);\n            }\n            return;\n        }\n        var idx = _core_util_js__WEBPACK_IMPORTED_MODULE_2__.indexOf(this._roots, el);\n        if (idx >= 0) {\n            this._roots.splice(idx, 1);\n        }\n    };\n    Storage.prototype.delAllRoots = function () {\n        this._roots = [];\n        this._displayList = [];\n        this._displayListLen = 0;\n        return;\n    };\n    Storage.prototype.getRoots = function () {\n        return this._roots;\n    };\n    Storage.prototype.dispose = function () {\n        this._displayList = null;\n        this._roots = null;\n    };\n    return Storage;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Storage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ2NDcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9TdG9yYWdlLmpzPzA0NjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgdGltc29ydCBmcm9tICcuL2NvcmUvdGltc29ydC5qcyc7XG5pbXBvcnQgeyBSRURSQVdfQklUIH0gZnJvbSAnLi9ncmFwaGljL2NvbnN0YW50cy5qcyc7XG52YXIgaW52YWxpZFpFcnJvckxvZ2dlZCA9IGZhbHNlO1xuZnVuY3Rpb24gbG9nSW52YWxpZFpFcnJvcigpIHtcbiAgICBpZiAoaW52YWxpZFpFcnJvckxvZ2dlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFsaWRaRXJyb3JMb2dnZWQgPSB0cnVlO1xuICAgIGNvbnNvbGUud2FybigneiAvIHoyIC8gemxldmVsIG9mIGRpc3BsYXlhYmxlIGlzIGludmFsaWQsIHdoaWNoIG1heSBjYXVzZSB1bmV4cGVjdGVkIGVycm9ycycpO1xufVxuZnVuY3Rpb24gc2hhcGVDb21wYXJlRnVuYyhhLCBiKSB7XG4gICAgaWYgKGEuemxldmVsID09PSBiLnpsZXZlbCkge1xuICAgICAgICBpZiAoYS56ID09PSBiLnopIHtcbiAgICAgICAgICAgIHJldHVybiBhLnoyIC0gYi56MjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS56IC0gYi56O1xuICAgIH1cbiAgICByZXR1cm4gYS56bGV2ZWwgLSBiLnpsZXZlbDtcbn1cbnZhciBTdG9yYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdG9yYWdlKCkge1xuICAgICAgICB0aGlzLl9yb290cyA9IFtdO1xuICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgICAgIHRoaXMuZGlzcGxheWFibGVTb3J0RnVuYyA9IHNoYXBlQ29tcGFyZUZ1bmM7XG4gICAgfVxuICAgIFN0b3JhZ2UucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzW2ldLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmFnZS5wcm90b3R5cGUuZ2V0RGlzcGxheUxpc3QgPSBmdW5jdGlvbiAodXBkYXRlLCBpbmNsdWRlSWdub3JlKSB7XG4gICAgICAgIGluY2x1ZGVJZ25vcmUgPSBpbmNsdWRlSWdub3JlIHx8IGZhbHNlO1xuICAgICAgICB2YXIgZGlzcGxheUxpc3QgPSB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgICAgICAgaWYgKHVwZGF0ZSB8fCAhZGlzcGxheUxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXlMaXN0KGluY2x1ZGVJZ25vcmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXNwbGF5TGlzdDtcbiAgICB9O1xuICAgIFN0b3JhZ2UucHJvdG90eXBlLnVwZGF0ZURpc3BsYXlMaXN0ID0gZnVuY3Rpb24gKGluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuICAgICAgICB2YXIgcm9vdHMgPSB0aGlzLl9yb290cztcbiAgICAgICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5fZGlzcGxheUxpc3Q7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb290cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQW5kQWRkRGlzcGxheWFibGUocm9vdHNbaV0sIG51bGwsIGluY2x1ZGVJZ25vcmUpO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BsYXlMaXN0Lmxlbmd0aCA9IHRoaXMuX2Rpc3BsYXlMaXN0TGVuO1xuICAgICAgICB0aW1zb3J0KGRpc3BsYXlMaXN0LCBzaGFwZUNvbXBhcmVGdW5jKTtcbiAgICB9O1xuICAgIFN0b3JhZ2UucHJvdG90eXBlLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZSA9IGZ1bmN0aW9uIChlbCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKSB7XG4gICAgICAgIGlmIChlbC5pZ25vcmUgJiYgIWluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbC5iZWZvcmVVcGRhdGUoKTtcbiAgICAgICAgZWwudXBkYXRlKCk7XG4gICAgICAgIGVsLmFmdGVyVXBkYXRlKCk7XG4gICAgICAgIHZhciB1c2VyU2V0Q2xpcFBhdGggPSBlbC5nZXRDbGlwUGF0aCgpO1xuICAgICAgICBpZiAoZWwuaWdub3JlQ2xpcCkge1xuICAgICAgICAgICAgY2xpcFBhdGhzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1c2VyU2V0Q2xpcFBhdGgpIHtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgICAgICAgICBjbGlwUGF0aHMgPSBjbGlwUGF0aHMuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsaXBQYXRocyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRDbGlwUGF0aCA9IHVzZXJTZXRDbGlwUGF0aDtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDbGlwUGF0aCA9IGVsO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRDbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDbGlwUGF0aC5wYXJlbnQgPSBwYXJlbnRDbGlwUGF0aDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2xpcFBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICAgICAgY2xpcFBhdGhzLnB1c2goY3VycmVudENsaXBQYXRoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRDbGlwUGF0aCA9IGN1cnJlbnRDbGlwUGF0aDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGguZ2V0Q2xpcFBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwuY2hpbGRyZW5SZWYpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuUmVmKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuX19kaXJ0eSB8PSBSRURSQVdfQklUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShjaGlsZCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLl9fZGlydHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpc3AgPSBlbDtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aHMgJiYgY2xpcFBhdGhzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRpc3AuX19jbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNwLl9fY2xpcFBhdGhzICYmIGRpc3AuX19jbGlwUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGRpc3AuX19jbGlwUGF0aHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTihkaXNwLnopKSB7XG4gICAgICAgICAgICAgICAgbG9nSW52YWxpZFpFcnJvcigpO1xuICAgICAgICAgICAgICAgIGRpc3AueiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOYU4oZGlzcC56MikpIHtcbiAgICAgICAgICAgICAgICBsb2dJbnZhbGlkWkVycm9yKCk7XG4gICAgICAgICAgICAgICAgZGlzcC56MiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOYU4oZGlzcC56bGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgbG9nSW52YWxpZFpFcnJvcigpO1xuICAgICAgICAgICAgICAgIGRpc3AuemxldmVsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0W3RoaXMuX2Rpc3BsYXlMaXN0TGVuKytdID0gZGlzcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVjYWxFbCA9IGVsLmdldERlY2FsRWxlbWVudCAmJiBlbC5nZXREZWNhbEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGRlY2FsRWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKGRlY2FsRWwsIGNsaXBQYXRocywgaW5jbHVkZUlnbm9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHRHdWlkZSA9IGVsLmdldFRleHRHdWlkZUxpbmUoKTtcbiAgICAgICAgaWYgKHRleHRHdWlkZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQW5kQWRkRGlzcGxheWFibGUodGV4dEd1aWRlLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0RWwgPSBlbC5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICBpZiAodGV4dEVsKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZSh0ZXh0RWwsIGNsaXBQYXRocywgaW5jbHVkZUlnbm9yZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JhZ2UucHJvdG90eXBlLmFkZFJvb3QgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsLl9fenIgJiYgZWwuX196ci5zdG9yYWdlID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm9vdHMucHVzaChlbCk7XG4gICAgfTtcbiAgICBTdG9yYWdlLnByb3RvdHlwZS5kZWxSb290ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsUm9vdChlbFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9yb290cywgZWwpO1xuICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdG9yYWdlLnByb3RvdHlwZS5kZWxBbGxSb290cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgICAgICAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICBTdG9yYWdlLnByb3RvdHlwZS5nZXRSb290cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RzO1xuICAgIH07XG4gICAgU3RvcmFnZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZGlzcGxheUxpc3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9yb290cyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU3RvcmFnZTtcbn0oKSk7XG5leHBvcnQgZGVmYXVsdCBTdG9yYWdlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14647\n")},21756:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  F: () => (/* binding */ cloneValue),\n  A: () => (/* binding */ animation_Animator)\n});\n\n;// ./node_modules/zrender/lib/animation/easing.js\nvar easingFuncs = {\n    linear: function (k) {\n        return k;\n    },\n    quadraticIn: function (k) {\n        return k * k;\n    },\n    quadraticOut: function (k) {\n        return k * (2 - k);\n    },\n    quadraticInOut: function (k) {\n        if ((k *= 2) < 1) {\n            return 0.5 * k * k;\n        }\n        return -0.5 * (--k * (k - 2) - 1);\n    },\n    cubicIn: function (k) {\n        return k * k * k;\n    },\n    cubicOut: function (k) {\n        return --k * k * k + 1;\n    },\n    cubicInOut: function (k) {\n        if ((k *= 2) < 1) {\n            return 0.5 * k * k * k;\n        }\n        return 0.5 * ((k -= 2) * k * k + 2);\n    },\n    quarticIn: function (k) {\n        return k * k * k * k;\n    },\n    quarticOut: function (k) {\n        return 1 - (--k * k * k * k);\n    },\n    quarticInOut: function (k) {\n        if ((k *= 2) < 1) {\n            return 0.5 * k * k * k * k;\n        }\n        return -0.5 * ((k -= 2) * k * k * k - 2);\n    },\n    quinticIn: function (k) {\n        return k * k * k * k * k;\n    },\n    quinticOut: function (k) {\n        return --k * k * k * k * k + 1;\n    },\n    quinticInOut: function (k) {\n        if ((k *= 2) < 1) {\n            return 0.5 * k * k * k * k * k;\n        }\n        return 0.5 * ((k -= 2) * k * k * k * k + 2);\n    },\n    sinusoidalIn: function (k) {\n        return 1 - Math.cos(k * Math.PI / 2);\n    },\n    sinusoidalOut: function (k) {\n        return Math.sin(k * Math.PI / 2);\n    },\n    sinusoidalInOut: function (k) {\n        return 0.5 * (1 - Math.cos(Math.PI * k));\n    },\n    exponentialIn: function (k) {\n        return k === 0 ? 0 : Math.pow(1024, k - 1);\n    },\n    exponentialOut: function (k) {\n        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n    },\n    exponentialInOut: function (k) {\n        if (k === 0) {\n            return 0;\n        }\n        if (k === 1) {\n            return 1;\n        }\n        if ((k *= 2) < 1) {\n            return 0.5 * Math.pow(1024, k - 1);\n        }\n        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n    },\n    circularIn: function (k) {\n        return 1 - Math.sqrt(1 - k * k);\n    },\n    circularOut: function (k) {\n        return Math.sqrt(1 - (--k * k));\n    },\n    circularInOut: function (k) {\n        if ((k *= 2) < 1) {\n            return -0.5 * (Math.sqrt(1 - k * k) - 1);\n        }\n        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n    },\n    elasticIn: function (k) {\n        var s;\n        var a = 0.1;\n        var p = 0.4;\n        if (k === 0) {\n            return 0;\n        }\n        if (k === 1) {\n            return 1;\n        }\n        if (!a || a < 1) {\n            a = 1;\n            s = p / 4;\n        }\n        else {\n            s = p * Math.asin(1 / a) / (2 * Math.PI);\n        }\n        return -(a * Math.pow(2, 10 * (k -= 1))\n            * Math.sin((k - s) * (2 * Math.PI) / p));\n    },\n    elasticOut: function (k) {\n        var s;\n        var a = 0.1;\n        var p = 0.4;\n        if (k === 0) {\n            return 0;\n        }\n        if (k === 1) {\n            return 1;\n        }\n        if (!a || a < 1) {\n            a = 1;\n            s = p / 4;\n        }\n        else {\n            s = p * Math.asin(1 / a) / (2 * Math.PI);\n        }\n        return (a * Math.pow(2, -10 * k)\n            * Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n    },\n    elasticInOut: function (k) {\n        var s;\n        var a = 0.1;\n        var p = 0.4;\n        if (k === 0) {\n            return 0;\n        }\n        if (k === 1) {\n            return 1;\n        }\n        if (!a || a < 1) {\n            a = 1;\n            s = p / 4;\n        }\n        else {\n            s = p * Math.asin(1 / a) / (2 * Math.PI);\n        }\n        if ((k *= 2) < 1) {\n            return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                * Math.sin((k - s) * (2 * Math.PI) / p));\n        }\n        return a * Math.pow(2, -10 * (k -= 1))\n            * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n    },\n    backIn: function (k) {\n        var s = 1.70158;\n        return k * k * ((s + 1) * k - s);\n    },\n    backOut: function (k) {\n        var s = 1.70158;\n        return --k * k * ((s + 1) * k + s) + 1;\n    },\n    backInOut: function (k) {\n        var s = 1.70158 * 1.525;\n        if ((k *= 2) < 1) {\n            return 0.5 * (k * k * ((s + 1) * k - s));\n        }\n        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n    },\n    bounceIn: function (k) {\n        return 1 - easingFuncs.bounceOut(1 - k);\n    },\n    bounceOut: function (k) {\n        if (k < (1 / 2.75)) {\n            return 7.5625 * k * k;\n        }\n        else if (k < (2 / 2.75)) {\n            return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n        }\n        else if (k < (2.5 / 2.75)) {\n            return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n        }\n        else {\n            return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n        }\n    },\n    bounceInOut: function (k) {\n        if (k < 0.5) {\n            return easingFuncs.bounceIn(k * 2) * 0.5;\n        }\n        return easingFuncs.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n    }\n};\n/* harmony default export */ const animation_easing = (easingFuncs);\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/animation/cubicEasing.js\nvar cubicEasing = __webpack_require__(96320);\n;// ./node_modules/zrender/lib/animation/Clip.js\n\n\n\nvar Clip = (function () {\n    function Clip(opts) {\n        this._inited = false;\n        this._startTime = 0;\n        this._pausedTime = 0;\n        this._paused = false;\n        this._life = opts.life || 1000;\n        this._delay = opts.delay || 0;\n        this.loop = opts.loop || false;\n        this.onframe = opts.onframe || util.noop;\n        this.ondestroy = opts.ondestroy || util.noop;\n        this.onrestart = opts.onrestart || util.noop;\n        opts.easing && this.setEasing(opts.easing);\n    }\n    Clip.prototype.step = function (globalTime, deltaTime) {\n        if (!this._inited) {\n            this._startTime = globalTime + this._delay;\n            this._inited = true;\n        }\n        if (this._paused) {\n            this._pausedTime += deltaTime;\n            return;\n        }\n        var life = this._life;\n        var elapsedTime = globalTime - this._startTime - this._pausedTime;\n        var percent = elapsedTime / life;\n        if (percent < 0) {\n            percent = 0;\n        }\n        percent = Math.min(percent, 1);\n        var easingFunc = this.easingFunc;\n        var schedule = easingFunc ? easingFunc(percent) : percent;\n        this.onframe(schedule);\n        if (percent === 1) {\n            if (this.loop) {\n                var remainder = elapsedTime % life;\n                this._startTime = globalTime - remainder;\n                this._pausedTime = 0;\n                this.onrestart();\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    };\n    Clip.prototype.pause = function () {\n        this._paused = true;\n    };\n    Clip.prototype.resume = function () {\n        this._paused = false;\n    };\n    Clip.prototype.setEasing = function (easing) {\n        this.easing = easing;\n        this.easingFunc = (0,util.isFunction)(easing)\n            ? easing\n            : animation_easing[easing] || (0,cubicEasing/* createCubicEasingFunc */.w)(easing);\n    };\n    return Clip;\n}());\n/* harmony default export */ const animation_Clip = (Clip);\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/tool/color.js\nvar color = __webpack_require__(47698);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/svg/helper.js\nvar helper = __webpack_require__(3455);\n;// ./node_modules/zrender/lib/animation/Animator.js\n\n\n\n\n\n\n;\nvar arraySlice = Array.prototype.slice;\nfunction interpolateNumber(p0, p1, percent) {\n    return (p1 - p0) * percent + p0;\n}\nfunction interpolate1DArray(out, p0, p1, percent) {\n    var len = p0.length;\n    for (var i = 0; i < len; i++) {\n        out[i] = interpolateNumber(p0[i], p1[i], percent);\n    }\n    return out;\n}\nfunction interpolate2DArray(out, p0, p1, percent) {\n    var len = p0.length;\n    var len2 = len && p0[0].length;\n    for (var i = 0; i < len; i++) {\n        if (!out[i]) {\n            out[i] = [];\n        }\n        for (var j = 0; j < len2; j++) {\n            out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n        }\n    }\n    return out;\n}\nfunction add1DArray(out, p0, p1, sign) {\n    var len = p0.length;\n    for (var i = 0; i < len; i++) {\n        out[i] = p0[i] + p1[i] * sign;\n    }\n    return out;\n}\nfunction add2DArray(out, p0, p1, sign) {\n    var len = p0.length;\n    var len2 = len && p0[0].length;\n    for (var i = 0; i < len; i++) {\n        if (!out[i]) {\n            out[i] = [];\n        }\n        for (var j = 0; j < len2; j++) {\n            out[i][j] = p0[i][j] + p1[i][j] * sign;\n        }\n    }\n    return out;\n}\nfunction fillColorStops(val0, val1) {\n    var len0 = val0.length;\n    var len1 = val1.length;\n    var shorterArr = len0 > len1 ? val1 : val0;\n    var shorterLen = Math.min(len0, len1);\n    var last = shorterArr[shorterLen - 1] || { color: [0, 0, 0, 0], offset: 0 };\n    for (var i = shorterLen; i < Math.max(len0, len1); i++) {\n        shorterArr.push({\n            offset: last.offset,\n            color: last.color.slice()\n        });\n    }\n}\nfunction fillArray(val0, val1, arrDim) {\n    var arr0 = val0;\n    var arr1 = val1;\n    if (!arr0.push || !arr1.push) {\n        return;\n    }\n    var arr0Len = arr0.length;\n    var arr1Len = arr1.length;\n    if (arr0Len !== arr1Len) {\n        var isPreviousLarger = arr0Len > arr1Len;\n        if (isPreviousLarger) {\n            arr0.length = arr1Len;\n        }\n        else {\n            for (var i = arr0Len; i < arr1Len; i++) {\n                arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n            }\n        }\n    }\n    var len2 = arr0[0] && arr0[0].length;\n    for (var i = 0; i < arr0.length; i++) {\n        if (arrDim === 1) {\n            if (isNaN(arr0[i])) {\n                arr0[i] = arr1[i];\n            }\n        }\n        else {\n            for (var j = 0; j < len2; j++) {\n                if (isNaN(arr0[i][j])) {\n                    arr0[i][j] = arr1[i][j];\n                }\n            }\n        }\n    }\n}\nfunction cloneValue(value) {\n    if ((0,util.isArrayLike)(value)) {\n        var len = value.length;\n        if ((0,util.isArrayLike)(value[0])) {\n            var ret = [];\n            for (var i = 0; i < len; i++) {\n                ret.push(arraySlice.call(value[i]));\n            }\n            return ret;\n        }\n        return arraySlice.call(value);\n    }\n    return value;\n}\nfunction rgba2String(rgba) {\n    rgba[0] = Math.floor(rgba[0]) || 0;\n    rgba[1] = Math.floor(rgba[1]) || 0;\n    rgba[2] = Math.floor(rgba[2]) || 0;\n    rgba[3] = rgba[3] == null ? 1 : rgba[3];\n    return 'rgba(' + rgba.join(',') + ')';\n}\nfunction guessArrayDim(value) {\n    return (0,util.isArrayLike)(value && value[0]) ? 2 : 1;\n}\nvar VALUE_TYPE_NUMBER = 0;\nvar VALUE_TYPE_1D_ARRAY = 1;\nvar VALUE_TYPE_2D_ARRAY = 2;\nvar VALUE_TYPE_COLOR = 3;\nvar VALUE_TYPE_LINEAR_GRADIENT = 4;\nvar VALUE_TYPE_RADIAL_GRADIENT = 5;\nvar VALUE_TYPE_UNKOWN = 6;\nfunction isGradientValueType(valType) {\n    return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;\n}\nfunction isArrayValueType(valType) {\n    return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;\n}\nvar tmpRgba = [0, 0, 0, 0];\nvar Track = (function () {\n    function Track(propName) {\n        this.keyframes = [];\n        this.discrete = false;\n        this._invalid = false;\n        this._needsSort = false;\n        this._lastFr = 0;\n        this._lastFrP = 0;\n        this.propName = propName;\n    }\n    Track.prototype.isFinished = function () {\n        return this._finished;\n    };\n    Track.prototype.setFinished = function () {\n        this._finished = true;\n        if (this._additiveTrack) {\n            this._additiveTrack.setFinished();\n        }\n    };\n    Track.prototype.needsAnimate = function () {\n        return this.keyframes.length >= 1;\n    };\n    Track.prototype.getAdditiveTrack = function () {\n        return this._additiveTrack;\n    };\n    Track.prototype.addKeyframe = function (time, rawValue, easing) {\n        this._needsSort = true;\n        var keyframes = this.keyframes;\n        var len = keyframes.length;\n        var discrete = false;\n        var valType = VALUE_TYPE_UNKOWN;\n        var value = rawValue;\n        if ((0,util.isArrayLike)(rawValue)) {\n            var arrayDim = guessArrayDim(rawValue);\n            valType = arrayDim;\n            if (arrayDim === 1 && !(0,util.isNumber)(rawValue[0])\n                || arrayDim === 2 && !(0,util.isNumber)(rawValue[0][0])) {\n                discrete = true;\n            }\n        }\n        else {\n            if ((0,util.isNumber)(rawValue) && !(0,util.eqNaN)(rawValue)) {\n                valType = VALUE_TYPE_NUMBER;\n            }\n            else if ((0,util.isString)(rawValue)) {\n                if (!isNaN(+rawValue)) {\n                    valType = VALUE_TYPE_NUMBER;\n                }\n                else {\n                    var colorArray = color.parse(rawValue);\n                    if (colorArray) {\n                        value = colorArray;\n                        valType = VALUE_TYPE_COLOR;\n                    }\n                }\n            }\n            else if ((0,util.isGradientObject)(rawValue)) {\n                var parsedGradient = (0,util.extend)({}, value);\n                parsedGradient.colorStops = (0,util.map)(rawValue.colorStops, function (colorStop) { return ({\n                    offset: colorStop.offset,\n                    color: color.parse(colorStop.color)\n                }); });\n                if ((0,helper/* isLinearGradient */.OS)(rawValue)) {\n                    valType = VALUE_TYPE_LINEAR_GRADIENT;\n                }\n                else if ((0,helper/* isRadialGradient */.OH)(rawValue)) {\n                    valType = VALUE_TYPE_RADIAL_GRADIENT;\n                }\n                value = parsedGradient;\n            }\n        }\n        if (len === 0) {\n            this.valType = valType;\n        }\n        else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {\n            discrete = true;\n        }\n        this.discrete = this.discrete || discrete;\n        var kf = {\n            time: time,\n            value: value,\n            rawValue: rawValue,\n            percent: 0\n        };\n        if (easing) {\n            kf.easing = easing;\n            kf.easingFunc = (0,util.isFunction)(easing)\n                ? easing\n                : animation_easing[easing] || (0,cubicEasing/* createCubicEasingFunc */.w)(easing);\n        }\n        keyframes.push(kf);\n        return kf;\n    };\n    Track.prototype.prepare = function (maxTime, additiveTrack) {\n        var kfs = this.keyframes;\n        if (this._needsSort) {\n            kfs.sort(function (a, b) {\n                return a.time - b.time;\n            });\n        }\n        var valType = this.valType;\n        var kfsLen = kfs.length;\n        var lastKf = kfs[kfsLen - 1];\n        var isDiscrete = this.discrete;\n        var isArr = isArrayValueType(valType);\n        var isGradient = isGradientValueType(valType);\n        for (var i = 0; i < kfsLen; i++) {\n            var kf = kfs[i];\n            var value = kf.value;\n            var lastValue = lastKf.value;\n            kf.percent = kf.time / maxTime;\n            if (!isDiscrete) {\n                if (isArr && i !== kfsLen - 1) {\n                    fillArray(value, lastValue, valType);\n                }\n                else if (isGradient) {\n                    fillColorStops(value.colorStops, lastValue.colorStops);\n                }\n            }\n        }\n        if (!isDiscrete\n            && valType !== VALUE_TYPE_RADIAL_GRADIENT\n            && additiveTrack\n            && this.needsAnimate()\n            && additiveTrack.needsAnimate()\n            && valType === additiveTrack.valType\n            && !additiveTrack._finished) {\n            this._additiveTrack = additiveTrack;\n            var startValue = kfs[0].value;\n            for (var i = 0; i < kfsLen; i++) {\n                if (valType === VALUE_TYPE_NUMBER) {\n                    kfs[i].additiveValue = kfs[i].value - startValue;\n                }\n                else if (valType === VALUE_TYPE_COLOR) {\n                    kfs[i].additiveValue =\n                        add1DArray([], kfs[i].value, startValue, -1);\n                }\n                else if (isArrayValueType(valType)) {\n                    kfs[i].additiveValue = valType === VALUE_TYPE_1D_ARRAY\n                        ? add1DArray([], kfs[i].value, startValue, -1)\n                        : add2DArray([], kfs[i].value, startValue, -1);\n                }\n            }\n        }\n    };\n    Track.prototype.step = function (target, percent) {\n        if (this._finished) {\n            return;\n        }\n        if (this._additiveTrack && this._additiveTrack._finished) {\n            this._additiveTrack = null;\n        }\n        var isAdditive = this._additiveTrack != null;\n        var valueKey = isAdditive ? 'additiveValue' : 'value';\n        var valType = this.valType;\n        var keyframes = this.keyframes;\n        var kfsNum = keyframes.length;\n        var propName = this.propName;\n        var isValueColor = valType === VALUE_TYPE_COLOR;\n        var frameIdx;\n        var lastFrame = this._lastFr;\n        var mathMin = Math.min;\n        var frame;\n        var nextFrame;\n        if (kfsNum === 1) {\n            frame = nextFrame = keyframes[0];\n        }\n        else {\n            if (percent < 0) {\n                frameIdx = 0;\n            }\n            else if (percent < this._lastFrP) {\n                var start = mathMin(lastFrame + 1, kfsNum - 1);\n                for (frameIdx = start; frameIdx >= 0; frameIdx--) {\n                    if (keyframes[frameIdx].percent <= percent) {\n                        break;\n                    }\n                }\n                frameIdx = mathMin(frameIdx, kfsNum - 2);\n            }\n            else {\n                for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) {\n                    if (keyframes[frameIdx].percent > percent) {\n                        break;\n                    }\n                }\n                frameIdx = mathMin(frameIdx - 1, kfsNum - 2);\n            }\n            nextFrame = keyframes[frameIdx + 1];\n            frame = keyframes[frameIdx];\n        }\n        if (!(frame && nextFrame)) {\n            return;\n        }\n        this._lastFr = frameIdx;\n        this._lastFrP = percent;\n        var interval = (nextFrame.percent - frame.percent);\n        var w = interval === 0 ? 1 : mathMin((percent - frame.percent) / interval, 1);\n        if (nextFrame.easingFunc) {\n            w = nextFrame.easingFunc(w);\n        }\n        var targetArr = isAdditive ? this._additiveValue\n            : (isValueColor ? tmpRgba : target[propName]);\n        if ((isArrayValueType(valType) || isValueColor) && !targetArr) {\n            targetArr = this._additiveValue = [];\n        }\n        if (this.discrete) {\n            target[propName] = w < 1 ? frame.rawValue : nextFrame.rawValue;\n        }\n        else if (isArrayValueType(valType)) {\n            valType === VALUE_TYPE_1D_ARRAY\n                ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w)\n                : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);\n        }\n        else if (isGradientValueType(valType)) {\n            var val = frame[valueKey];\n            var nextVal_1 = nextFrame[valueKey];\n            var isLinearGradient_1 = valType === VALUE_TYPE_LINEAR_GRADIENT;\n            target[propName] = {\n                type: isLinearGradient_1 ? 'linear' : 'radial',\n                x: interpolateNumber(val.x, nextVal_1.x, w),\n                y: interpolateNumber(val.y, nextVal_1.y, w),\n                colorStops: (0,util.map)(val.colorStops, function (colorStop, idx) {\n                    var nextColorStop = nextVal_1.colorStops[idx];\n                    return {\n                        offset: interpolateNumber(colorStop.offset, nextColorStop.offset, w),\n                        color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w))\n                    };\n                }),\n                global: nextVal_1.global\n            };\n            if (isLinearGradient_1) {\n                target[propName].x2 = interpolateNumber(val.x2, nextVal_1.x2, w);\n                target[propName].y2 = interpolateNumber(val.y2, nextVal_1.y2, w);\n            }\n            else {\n                target[propName].r = interpolateNumber(val.r, nextVal_1.r, w);\n            }\n        }\n        else if (isValueColor) {\n            interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);\n            if (!isAdditive) {\n                target[propName] = rgba2String(targetArr);\n            }\n        }\n        else {\n            var value = interpolateNumber(frame[valueKey], nextFrame[valueKey], w);\n            if (isAdditive) {\n                this._additiveValue = value;\n            }\n            else {\n                target[propName] = value;\n            }\n        }\n        if (isAdditive) {\n            this._addToTarget(target);\n        }\n    };\n    Track.prototype._addToTarget = function (target) {\n        var valType = this.valType;\n        var propName = this.propName;\n        var additiveValue = this._additiveValue;\n        if (valType === VALUE_TYPE_NUMBER) {\n            target[propName] = target[propName] + additiveValue;\n        }\n        else if (valType === VALUE_TYPE_COLOR) {\n            color.parse(target[propName], tmpRgba);\n            add1DArray(tmpRgba, tmpRgba, additiveValue, 1);\n            target[propName] = rgba2String(tmpRgba);\n        }\n        else if (valType === VALUE_TYPE_1D_ARRAY) {\n            add1DArray(target[propName], target[propName], additiveValue, 1);\n        }\n        else if (valType === VALUE_TYPE_2D_ARRAY) {\n            add2DArray(target[propName], target[propName], additiveValue, 1);\n        }\n    };\n    return Track;\n}());\nvar Animator = (function () {\n    function Animator(target, loop, allowDiscreteAnimation, additiveTo) {\n        this._tracks = {};\n        this._trackKeys = [];\n        this._maxTime = 0;\n        this._started = 0;\n        this._clip = null;\n        this._target = target;\n        this._loop = loop;\n        if (loop && additiveTo) {\n            (0,util.logError)('Can\\' use additive animation on looped animation.');\n            return;\n        }\n        this._additiveAnimators = additiveTo;\n        this._allowDiscrete = allowDiscreteAnimation;\n    }\n    Animator.prototype.getMaxTime = function () {\n        return this._maxTime;\n    };\n    Animator.prototype.getDelay = function () {\n        return this._delay;\n    };\n    Animator.prototype.getLoop = function () {\n        return this._loop;\n    };\n    Animator.prototype.getTarget = function () {\n        return this._target;\n    };\n    Animator.prototype.changeTarget = function (target) {\n        this._target = target;\n    };\n    Animator.prototype.when = function (time, props, easing) {\n        return this.whenWithKeys(time, props, (0,util.keys)(props), easing);\n    };\n    Animator.prototype.whenWithKeys = function (time, props, propNames, easing) {\n        var tracks = this._tracks;\n        for (var i = 0; i < propNames.length; i++) {\n            var propName = propNames[i];\n            var track = tracks[propName];\n            if (!track) {\n                track = tracks[propName] = new Track(propName);\n                var initialValue = void 0;\n                var additiveTrack = this._getAdditiveTrack(propName);\n                if (additiveTrack) {\n                    var addtiveTrackKfs = additiveTrack.keyframes;\n                    var lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];\n                    initialValue = lastFinalKf && lastFinalKf.value;\n                    if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {\n                        initialValue = rgba2String(initialValue);\n                    }\n                }\n                else {\n                    initialValue = this._target[propName];\n                }\n                if (initialValue == null) {\n                    continue;\n                }\n                if (time > 0) {\n                    track.addKeyframe(0, cloneValue(initialValue), easing);\n                }\n                this._trackKeys.push(propName);\n            }\n            track.addKeyframe(time, cloneValue(props[propName]), easing);\n        }\n        this._maxTime = Math.max(this._maxTime, time);\n        return this;\n    };\n    Animator.prototype.pause = function () {\n        this._clip.pause();\n        this._paused = true;\n    };\n    Animator.prototype.resume = function () {\n        this._clip.resume();\n        this._paused = false;\n    };\n    Animator.prototype.isPaused = function () {\n        return !!this._paused;\n    };\n    Animator.prototype.duration = function (duration) {\n        this._maxTime = duration;\n        this._force = true;\n        return this;\n    };\n    Animator.prototype._doneCallback = function () {\n        this._setTracksFinished();\n        this._clip = null;\n        var doneList = this._doneCbs;\n        if (doneList) {\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        }\n    };\n    Animator.prototype._abortedCallback = function () {\n        this._setTracksFinished();\n        var animation = this.animation;\n        var abortedList = this._abortedCbs;\n        if (animation) {\n            animation.removeClip(this._clip);\n        }\n        this._clip = null;\n        if (abortedList) {\n            for (var i = 0; i < abortedList.length; i++) {\n                abortedList[i].call(this);\n            }\n        }\n    };\n    Animator.prototype._setTracksFinished = function () {\n        var tracks = this._tracks;\n        var tracksKeys = this._trackKeys;\n        for (var i = 0; i < tracksKeys.length; i++) {\n            tracks[tracksKeys[i]].setFinished();\n        }\n    };\n    Animator.prototype._getAdditiveTrack = function (trackName) {\n        var additiveTrack;\n        var additiveAnimators = this._additiveAnimators;\n        if (additiveAnimators) {\n            for (var i = 0; i < additiveAnimators.length; i++) {\n                var track = additiveAnimators[i].getTrack(trackName);\n                if (track) {\n                    additiveTrack = track;\n                }\n            }\n        }\n        return additiveTrack;\n    };\n    Animator.prototype.start = function (easing) {\n        if (this._started > 0) {\n            return;\n        }\n        this._started = 1;\n        var self = this;\n        var tracks = [];\n        var maxTime = this._maxTime || 0;\n        for (var i = 0; i < this._trackKeys.length; i++) {\n            var propName = this._trackKeys[i];\n            var track = this._tracks[propName];\n            var additiveTrack = this._getAdditiveTrack(propName);\n            var kfs = track.keyframes;\n            var kfsNum = kfs.length;\n            track.prepare(maxTime, additiveTrack);\n            if (track.needsAnimate()) {\n                if (!this._allowDiscrete && track.discrete) {\n                    var lastKf = kfs[kfsNum - 1];\n                    if (lastKf) {\n                        self._target[track.propName] = lastKf.rawValue;\n                    }\n                    track.setFinished();\n                }\n                else {\n                    tracks.push(track);\n                }\n            }\n        }\n        if (tracks.length || this._force) {\n            var clip = new animation_Clip({\n                life: maxTime,\n                loop: this._loop,\n                delay: this._delay || 0,\n                onframe: function (percent) {\n                    self._started = 2;\n                    var additiveAnimators = self._additiveAnimators;\n                    if (additiveAnimators) {\n                        var stillHasAdditiveAnimator = false;\n                        for (var i = 0; i < additiveAnimators.length; i++) {\n                            if (additiveAnimators[i]._clip) {\n                                stillHasAdditiveAnimator = true;\n                                break;\n                            }\n                        }\n                        if (!stillHasAdditiveAnimator) {\n                            self._additiveAnimators = null;\n                        }\n                    }\n                    for (var i = 0; i < tracks.length; i++) {\n                        tracks[i].step(self._target, percent);\n                    }\n                    var onframeList = self._onframeCbs;\n                    if (onframeList) {\n                        for (var i = 0; i < onframeList.length; i++) {\n                            onframeList[i](self._target, percent);\n                        }\n                    }\n                },\n                ondestroy: function () {\n                    self._doneCallback();\n                }\n            });\n            this._clip = clip;\n            if (this.animation) {\n                this.animation.addClip(clip);\n            }\n            if (easing) {\n                clip.setEasing(easing);\n            }\n        }\n        else {\n            this._doneCallback();\n        }\n        return this;\n    };\n    Animator.prototype.stop = function (forwardToLast) {\n        if (!this._clip) {\n            return;\n        }\n        var clip = this._clip;\n        if (forwardToLast) {\n            clip.onframe(1);\n        }\n        this._abortedCallback();\n    };\n    Animator.prototype.delay = function (time) {\n        this._delay = time;\n        return this;\n    };\n    Animator.prototype.during = function (cb) {\n        if (cb) {\n            if (!this._onframeCbs) {\n                this._onframeCbs = [];\n            }\n            this._onframeCbs.push(cb);\n        }\n        return this;\n    };\n    Animator.prototype.done = function (cb) {\n        if (cb) {\n            if (!this._doneCbs) {\n                this._doneCbs = [];\n            }\n            this._doneCbs.push(cb);\n        }\n        return this;\n    };\n    Animator.prototype.aborted = function (cb) {\n        if (cb) {\n            if (!this._abortedCbs) {\n                this._abortedCbs = [];\n            }\n            this._abortedCbs.push(cb);\n        }\n        return this;\n    };\n    Animator.prototype.getClip = function () {\n        return this._clip;\n    };\n    Animator.prototype.getTrack = function (propName) {\n        return this._tracks[propName];\n    };\n    Animator.prototype.getTracks = function () {\n        var _this = this;\n        return (0,util.map)(this._trackKeys, function (key) { return _this._tracks[key]; });\n    };\n    Animator.prototype.stopTracks = function (propNames, forwardToLast) {\n        if (!propNames.length || !this._clip) {\n            return true;\n        }\n        var tracks = this._tracks;\n        var tracksKeys = this._trackKeys;\n        for (var i = 0; i < propNames.length; i++) {\n            var track = tracks[propNames[i]];\n            if (track && !track.isFinished()) {\n                if (forwardToLast) {\n                    track.step(this._target, 1);\n                }\n                else if (this._started === 1) {\n                    track.step(this._target, 0);\n                }\n                track.setFinished();\n            }\n        }\n        var allAborted = true;\n        for (var i = 0; i < tracksKeys.length; i++) {\n            if (!tracks[tracksKeys[i]].isFinished()) {\n                allAborted = false;\n                break;\n            }\n        }\n        if (allAborted) {\n            this._abortedCallback();\n        }\n        return allAborted;\n    };\n    Animator.prototype.saveTo = function (target, trackKeys, firstOrLast) {\n        if (!target) {\n            return;\n        }\n        trackKeys = trackKeys || this._trackKeys;\n        for (var i = 0; i < trackKeys.length; i++) {\n            var propName = trackKeys[i];\n            var track = this._tracks[propName];\n            if (!track || track.isFinished()) {\n                continue;\n            }\n            var kfs = track.keyframes;\n            var kf = kfs[firstOrLast ? 0 : kfs.length - 1];\n            if (kf) {\n                target[propName] = cloneValue(kf.rawValue);\n            }\n        }\n    };\n    Animator.prototype.__changeFinalValue = function (finalProps, trackKeys) {\n        trackKeys = trackKeys || (0,util.keys)(finalProps);\n        for (var i = 0; i < trackKeys.length; i++) {\n            var propName = trackKeys[i];\n            var track = this._tracks[propName];\n            if (!track) {\n                continue;\n            }\n            var kfs = track.keyframes;\n            if (kfs.length > 1) {\n                var lastKf = kfs.pop();\n                track.addKeyframe(lastKf.time, finalProps[propName]);\n                track.prepare(this._maxTime, track.getAdditiveTrack());\n            }\n        }\n    };\n    return Animator;\n}());\n/* harmony default export */ const animation_Animator = (Animator);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE3NTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzPzFlODUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9DbGlwLmpzPzIzMTQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qcz9lZTE1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBlYXNpbmdGdW5jcyA9IHtcbiAgICBsaW5lYXI6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrO1xuICAgIH0sXG4gICAgcXVhZHJhdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICogaztcbiAgICB9LFxuICAgIHF1YWRyYXRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIGsgKiAoMiAtIGspO1xuICAgIH0sXG4gICAgcXVhZHJhdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG4gICAgfSxcbiAgICBjdWJpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAqIGsgKiBrO1xuICAgIH0sXG4gICAgY3ViaWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XG4gICAgfSxcbiAgICBjdWJpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xuICAgIH0sXG4gICAgcXVhcnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAqIGsgKiBrICogaztcbiAgICB9LFxuICAgIHF1YXJ0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiAxIC0gKC0tayAqIGsgKiBrICogayk7XG4gICAgfSxcbiAgICBxdWFydGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMC41ICogKChrIC09IDIpICogayAqIGsgKiBrIC0gMik7XG4gICAgfSxcbiAgICBxdWludGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICogayAqIGsgKiBrICogaztcbiAgICB9LFxuICAgIHF1aW50aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcbiAgICB9LFxuICAgIHF1aW50aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG4gICAgfSxcbiAgICBzaW51c29pZGFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiAxIC0gTWF0aC5jb3MoayAqIE1hdGguUEkgLyAyKTtcbiAgICB9LFxuICAgIHNpbnVzb2lkYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpbihrICogTWF0aC5QSSAvIDIpO1xuICAgIH0sXG4gICAgc2ludXNvaWRhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICAgIH0sXG4gICAgZXhwb25lbnRpYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICAgIH0sXG4gICAgZXhwb25lbnRpYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBrKTtcbiAgICB9LFxuICAgIGV4cG9uZW50aWFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAoayAtIDEpKSArIDIpO1xuICAgIH0sXG4gICAgY2lyY3VsYXJJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIGsgKiBrKTtcbiAgICB9LFxuICAgIGNpcmN1bGFyT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS1rICogaykpO1xuICAgIH0sXG4gICAgY2lyY3VsYXJJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBrICogaykgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGsgLT0gMikgKiBrKSArIDEpO1xuICAgIH0sXG4gICAgZWxhc3RpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgcztcbiAgICAgICAgdmFyIGEgPSAwLjE7XG4gICAgICAgIHZhciBwID0gMC40O1xuICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgICAgICAgYSA9IDE7XG4gICAgICAgICAgICBzID0gcCAvIDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKVxuICAgICAgICAgICAgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgICB9LFxuICAgIGVsYXN0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBzO1xuICAgICAgICB2YXIgYSA9IDAuMTtcbiAgICAgICAgdmFyIHAgPSAwLjQ7XG4gICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICAgICAgICBhID0gMTtcbiAgICAgICAgICAgIHMgPSBwIC8gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhICogTWF0aC5wb3coMiwgLTEwICogaylcbiAgICAgICAgICAgICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDEpO1xuICAgIH0sXG4gICAgZWxhc3RpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgcztcbiAgICAgICAgdmFyIGEgPSAwLjE7XG4gICAgICAgIHZhciBwID0gMC40O1xuICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgICAgICAgYSA9IDE7XG4gICAgICAgICAgICBzID0gcCAvIDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKVxuICAgICAgICAgICAgICAgICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAoayAtPSAxKSlcbiAgICAgICAgICAgICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG4gICAgfSxcbiAgICBiYWNrSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG4gICAgfSxcbiAgICBiYWNrT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuICAgIH0sXG4gICAgYmFja0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgcyA9IDEuNzAxNTggKiAxLjUyNTtcbiAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG4gICAgfSxcbiAgICBib3VuY2VJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIDEgLSBlYXNpbmdGdW5jcy5ib3VuY2VPdXQoMSAtIGspO1xuICAgIH0sXG4gICAgYm91bmNlT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoayA8ICgxIC8gMi43NSkpIHtcbiAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiBrICogaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrIDwgKDIgLyAyLjc1KSkge1xuICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgxLjUgLyAyLjc1KSkgKiBrICsgMC43NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrIDwgKDIuNSAvIDIuNzUpKSB7XG4gICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuMjUgLyAyLjc1KSkgKiBrICsgMC45Mzc1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgyLjYyNSAvIDIuNzUpKSAqIGsgKyAwLjk4NDM3NTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYm91bmNlSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChrIDwgMC41KSB7XG4gICAgICAgICAgICByZXR1cm4gZWFzaW5nRnVuY3MuYm91bmNlSW4oayAqIDIpICogMC41O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlYXNpbmdGdW5jcy5ib3VuY2VPdXQoayAqIDIgLSAxKSAqIDAuNSArIDAuNTtcbiAgICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgZWFzaW5nRnVuY3M7XG4iLCJpbXBvcnQgZWFzaW5nRnVuY3MgZnJvbSAnLi9lYXNpbmcuanMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiwgbm9vcCB9IGZyb20gJy4uL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDdWJpY0Vhc2luZ0Z1bmMgfSBmcm9tICcuL2N1YmljRWFzaW5nLmpzJztcbnZhciBDbGlwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGlwKG9wdHMpIHtcbiAgICAgICAgdGhpcy5faW5pdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGlmZSA9IG9wdHMubGlmZSB8fCAxMDAwO1xuICAgICAgICB0aGlzLl9kZWxheSA9IG9wdHMuZGVsYXkgfHwgMDtcbiAgICAgICAgdGhpcy5sb29wID0gb3B0cy5sb29wIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLm9uZnJhbWUgPSBvcHRzLm9uZnJhbWUgfHwgbm9vcDtcbiAgICAgICAgdGhpcy5vbmRlc3Ryb3kgPSBvcHRzLm9uZGVzdHJveSB8fCBub29wO1xuICAgICAgICB0aGlzLm9ucmVzdGFydCA9IG9wdHMub25yZXN0YXJ0IHx8IG5vb3A7XG4gICAgICAgIG9wdHMuZWFzaW5nICYmIHRoaXMuc2V0RWFzaW5nKG9wdHMuZWFzaW5nKTtcbiAgICB9XG4gICAgQ2xpcC5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uIChnbG9iYWxUaW1lLCBkZWx0YVRpbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pbml0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgKyB0aGlzLl9kZWxheTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSBkZWx0YVRpbWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpZmUgPSB0aGlzLl9saWZlO1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZTtcbiAgICAgICAgdmFyIHBlcmNlbnQgPSBlbGFwc2VkVGltZSAvIGxpZmU7XG4gICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcGVyY2VudCA9IE1hdGgubWluKHBlcmNlbnQsIDEpO1xuICAgICAgICB2YXIgZWFzaW5nRnVuYyA9IHRoaXMuZWFzaW5nRnVuYztcbiAgICAgICAgdmFyIHNjaGVkdWxlID0gZWFzaW5nRnVuYyA/IGVhc2luZ0Z1bmMocGVyY2VudCkgOiBwZXJjZW50O1xuICAgICAgICB0aGlzLm9uZnJhbWUoc2NoZWR1bGUpO1xuICAgICAgICBpZiAocGVyY2VudCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubG9vcCkge1xuICAgICAgICAgICAgICAgIHZhciByZW1haW5kZXIgPSBlbGFwc2VkVGltZSAlIGxpZmU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gZ2xvYmFsVGltZSAtIHJlbWFpbmRlcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLm9ucmVzdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQ2xpcC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgfTtcbiAgICBDbGlwLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgQ2xpcC5wcm90b3R5cGUuc2V0RWFzaW5nID0gZnVuY3Rpb24gKGVhc2luZykge1xuICAgICAgICB0aGlzLmVhc2luZyA9IGVhc2luZztcbiAgICAgICAgdGhpcy5lYXNpbmdGdW5jID0gaXNGdW5jdGlvbihlYXNpbmcpXG4gICAgICAgICAgICA/IGVhc2luZ1xuICAgICAgICAgICAgOiBlYXNpbmdGdW5jc1tlYXNpbmddIHx8IGNyZWF0ZUN1YmljRWFzaW5nRnVuYyhlYXNpbmcpO1xuICAgIH07XG4gICAgcmV0dXJuIENsaXA7XG59KCkpO1xuZXhwb3J0IGRlZmF1bHQgQ2xpcDtcbiIsImltcG9ydCBDbGlwIGZyb20gJy4vQ2xpcC5qcyc7XG5pbXBvcnQgKiBhcyBjb2xvciBmcm9tICcuLi90b29sL2NvbG9yLmpzJztcbmltcG9ydCB7IGVxTmFOLCBleHRlbmQsIGlzQXJyYXlMaWtlLCBpc0Z1bmN0aW9uLCBpc0dyYWRpZW50T2JqZWN0LCBpc051bWJlciwgaXNTdHJpbmcsIGtleXMsIGxvZ0Vycm9yLCBtYXAgfSBmcm9tICcuLi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IGVhc2luZ0Z1bmNzIGZyb20gJy4vZWFzaW5nLmpzJztcbmltcG9ydCB7IGNyZWF0ZUN1YmljRWFzaW5nRnVuYyB9IGZyb20gJy4vY3ViaWNFYXNpbmcuanMnO1xuaW1wb3J0IHsgaXNMaW5lYXJHcmFkaWVudCwgaXNSYWRpYWxHcmFkaWVudCB9IGZyb20gJy4uL3N2Zy9oZWxwZXIuanMnO1xuO1xudmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihwMCwgcDEsIHBlcmNlbnQpIHtcbiAgICByZXR1cm4gKHAxIC0gcDApICogcGVyY2VudCArIHAwO1xufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUxREFycmF5KG91dCwgcDAsIHAxLCBwZXJjZW50KSB7XG4gICAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IGludGVycG9sYXRlTnVtYmVyKHAwW2ldLCBwMVtpXSwgcGVyY2VudCk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZTJEQXJyYXkob3V0LCBwMCwgcDEsIHBlcmNlbnQpIHtcbiAgICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuICAgIHZhciBsZW4yID0gbGVuICYmIHAwWzBdLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghb3V0W2ldKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgb3V0W2ldW2pdID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV1bal0sIHAxW2ldW2pdLCBwZXJjZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gYWRkMURBcnJheShvdXQsIHAwLCBwMSwgc2lnbikge1xuICAgIHZhciBsZW4gPSBwMC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBwMFtpXSArIHAxW2ldICogc2lnbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGFkZDJEQXJyYXkob3V0LCBwMCwgcDEsIHNpZ24pIHtcbiAgICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuICAgIHZhciBsZW4yID0gbGVuICYmIHAwWzBdLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghb3V0W2ldKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgb3V0W2ldW2pdID0gcDBbaV1bal0gKyBwMVtpXVtqXSAqIHNpZ247XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGZpbGxDb2xvclN0b3BzKHZhbDAsIHZhbDEpIHtcbiAgICB2YXIgbGVuMCA9IHZhbDAubGVuZ3RoO1xuICAgIHZhciBsZW4xID0gdmFsMS5sZW5ndGg7XG4gICAgdmFyIHNob3J0ZXJBcnIgPSBsZW4wID4gbGVuMSA/IHZhbDEgOiB2YWwwO1xuICAgIHZhciBzaG9ydGVyTGVuID0gTWF0aC5taW4obGVuMCwgbGVuMSk7XG4gICAgdmFyIGxhc3QgPSBzaG9ydGVyQXJyW3Nob3J0ZXJMZW4gLSAxXSB8fCB7IGNvbG9yOiBbMCwgMCwgMCwgMF0sIG9mZnNldDogMCB9O1xuICAgIGZvciAodmFyIGkgPSBzaG9ydGVyTGVuOyBpIDwgTWF0aC5tYXgobGVuMCwgbGVuMSk7IGkrKykge1xuICAgICAgICBzaG9ydGVyQXJyLnB1c2goe1xuICAgICAgICAgICAgb2Zmc2V0OiBsYXN0Lm9mZnNldCxcbiAgICAgICAgICAgIGNvbG9yOiBsYXN0LmNvbG9yLnNsaWNlKClcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmlsbEFycmF5KHZhbDAsIHZhbDEsIGFyckRpbSkge1xuICAgIHZhciBhcnIwID0gdmFsMDtcbiAgICB2YXIgYXJyMSA9IHZhbDE7XG4gICAgaWYgKCFhcnIwLnB1c2ggfHwgIWFycjEucHVzaCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBhcnIwTGVuID0gYXJyMC5sZW5ndGg7XG4gICAgdmFyIGFycjFMZW4gPSBhcnIxLmxlbmd0aDtcbiAgICBpZiAoYXJyMExlbiAhPT0gYXJyMUxlbikge1xuICAgICAgICB2YXIgaXNQcmV2aW91c0xhcmdlciA9IGFycjBMZW4gPiBhcnIxTGVuO1xuICAgICAgICBpZiAoaXNQcmV2aW91c0xhcmdlcikge1xuICAgICAgICAgICAgYXJyMC5sZW5ndGggPSBhcnIxTGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGFycjBMZW47IGkgPCBhcnIxTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnIwLnB1c2goYXJyRGltID09PSAxID8gYXJyMVtpXSA6IGFycmF5U2xpY2UuY2FsbChhcnIxW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGxlbjIgPSBhcnIwWzBdICYmIGFycjBbMF0ubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4oYXJyMFtpXSkpIHtcbiAgICAgICAgICAgICAgICBhcnIwW2ldID0gYXJyMVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGFycjBbaV1bal0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycjBbaV1bal0gPSBhcnIxW2ldW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWVbMF0pKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goYXJyYXlTbGljZS5jYWxsKHZhbHVlW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheVNsaWNlLmNhbGwodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiByZ2JhMlN0cmluZyhyZ2JhKSB7XG4gICAgcmdiYVswXSA9IE1hdGguZmxvb3IocmdiYVswXSkgfHwgMDtcbiAgICByZ2JhWzFdID0gTWF0aC5mbG9vcihyZ2JhWzFdKSB8fCAwO1xuICAgIHJnYmFbMl0gPSBNYXRoLmZsb29yKHJnYmFbMl0pIHx8IDA7XG4gICAgcmdiYVszXSA9IHJnYmFbM10gPT0gbnVsbCA/IDEgOiByZ2JhWzNdO1xuICAgIHJldHVybiAncmdiYSgnICsgcmdiYS5qb2luKCcsJykgKyAnKSc7XG59XG5mdW5jdGlvbiBndWVzc0FycmF5RGltKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKHZhbHVlICYmIHZhbHVlWzBdKSA/IDIgOiAxO1xufVxudmFyIFZBTFVFX1RZUEVfTlVNQkVSID0gMDtcbnZhciBWQUxVRV9UWVBFXzFEX0FSUkFZID0gMTtcbnZhciBWQUxVRV9UWVBFXzJEX0FSUkFZID0gMjtcbnZhciBWQUxVRV9UWVBFX0NPTE9SID0gMztcbnZhciBWQUxVRV9UWVBFX0xJTkVBUl9HUkFESUVOVCA9IDQ7XG52YXIgVkFMVUVfVFlQRV9SQURJQUxfR1JBRElFTlQgPSA1O1xudmFyIFZBTFVFX1RZUEVfVU5LT1dOID0gNjtcbmZ1bmN0aW9uIGlzR3JhZGllbnRWYWx1ZVR5cGUodmFsVHlwZSkge1xuICAgIHJldHVybiB2YWxUeXBlID09PSBWQUxVRV9UWVBFX0xJTkVBUl9HUkFESUVOVCB8fCB2YWxUeXBlID09PSBWQUxVRV9UWVBFX1JBRElBTF9HUkFESUVOVDtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlWYWx1ZVR5cGUodmFsVHlwZSkge1xuICAgIHJldHVybiB2YWxUeXBlID09PSBWQUxVRV9UWVBFXzFEX0FSUkFZIHx8IHZhbFR5cGUgPT09IFZBTFVFX1RZUEVfMkRfQVJSQVk7XG59XG52YXIgdG1wUmdiYSA9IFswLCAwLCAwLCAwXTtcbnZhciBUcmFjayA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhY2socHJvcE5hbWUpIHtcbiAgICAgICAgdGhpcy5rZXlmcmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5kaXNjcmV0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbnZhbGlkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25lZWRzU29ydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sYXN0RnIgPSAwO1xuICAgICAgICB0aGlzLl9sYXN0RnJQID0gMDtcbiAgICAgICAgdGhpcy5wcm9wTmFtZSA9IHByb3BOYW1lO1xuICAgIH1cbiAgICBUcmFjay5wcm90b3R5cGUuaXNGaW5pc2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmlzaGVkO1xuICAgIH07XG4gICAgVHJhY2sucHJvdG90eXBlLnNldEZpbmlzaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9hZGRpdGl2ZVRyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRpdGl2ZVRyYWNrLnNldEZpbmlzaGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYWNrLnByb3RvdHlwZS5uZWVkc0FuaW1hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleWZyYW1lcy5sZW5ndGggPj0gMTtcbiAgICB9O1xuICAgIFRyYWNrLnByb3RvdHlwZS5nZXRBZGRpdGl2ZVRyYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkaXRpdmVUcmFjaztcbiAgICB9O1xuICAgIFRyYWNrLnByb3RvdHlwZS5hZGRLZXlmcmFtZSA9IGZ1bmN0aW9uICh0aW1lLCByYXdWYWx1ZSwgZWFzaW5nKSB7XG4gICAgICAgIHRoaXMuX25lZWRzU29ydCA9IHRydWU7XG4gICAgICAgIHZhciBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcztcbiAgICAgICAgdmFyIGxlbiA9IGtleWZyYW1lcy5sZW5ndGg7XG4gICAgICAgIHZhciBkaXNjcmV0ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgdmFsVHlwZSA9IFZBTFVFX1RZUEVfVU5LT1dOO1xuICAgICAgICB2YXIgdmFsdWUgPSByYXdWYWx1ZTtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHJhd1ZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIGFycmF5RGltID0gZ3Vlc3NBcnJheURpbShyYXdWYWx1ZSk7XG4gICAgICAgICAgICB2YWxUeXBlID0gYXJyYXlEaW07XG4gICAgICAgICAgICBpZiAoYXJyYXlEaW0gPT09IDEgJiYgIWlzTnVtYmVyKHJhd1ZhbHVlWzBdKVxuICAgICAgICAgICAgICAgIHx8IGFycmF5RGltID09PSAyICYmICFpc051bWJlcihyYXdWYWx1ZVswXVswXSkpIHtcbiAgICAgICAgICAgICAgICBkaXNjcmV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIocmF3VmFsdWUpICYmICFlcU5hTihyYXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWxUeXBlID0gVkFMVUVfVFlQRV9OVU1CRVI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhyYXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKCtyYXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsVHlwZSA9IFZBTFVFX1RZUEVfTlVNQkVSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yQXJyYXkgPSBjb2xvci5wYXJzZShyYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvckFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbG9yQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxUeXBlID0gVkFMVUVfVFlQRV9DT0xPUjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzR3JhZGllbnRPYmplY3QocmF3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZEdyYWRpZW50ID0gZXh0ZW5kKHt9LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcGFyc2VkR3JhZGllbnQuY29sb3JTdG9wcyA9IG1hcChyYXdWYWx1ZS5jb2xvclN0b3BzLCBmdW5jdGlvbiAoY29sb3JTdG9wKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGNvbG9yU3RvcC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvci5wYXJzZShjb2xvclN0b3AuY29sb3IpXG4gICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChpc0xpbmVhckdyYWRpZW50KHJhd1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxUeXBlID0gVkFMVUVfVFlQRV9MSU5FQVJfR1JBRElFTlQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUmFkaWFsR3JhZGllbnQocmF3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbFR5cGUgPSBWQUxVRV9UWVBFX1JBRElBTF9HUkFESUVOVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZWRHcmFkaWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhbFR5cGUgPSB2YWxUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbFR5cGUgIT09IHRoaXMudmFsVHlwZSB8fCB2YWxUeXBlID09PSBWQUxVRV9UWVBFX1VOS09XTikge1xuICAgICAgICAgICAgZGlzY3JldGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzY3JldGUgPSB0aGlzLmRpc2NyZXRlIHx8IGRpc2NyZXRlO1xuICAgICAgICB2YXIga2YgPSB7XG4gICAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcmF3VmFsdWU6IHJhd1ZhbHVlLFxuICAgICAgICAgICAgcGVyY2VudDogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZWFzaW5nKSB7XG4gICAgICAgICAgICBrZi5lYXNpbmcgPSBlYXNpbmc7XG4gICAgICAgICAgICBrZi5lYXNpbmdGdW5jID0gaXNGdW5jdGlvbihlYXNpbmcpXG4gICAgICAgICAgICAgICAgPyBlYXNpbmdcbiAgICAgICAgICAgICAgICA6IGVhc2luZ0Z1bmNzW2Vhc2luZ10gfHwgY3JlYXRlQ3ViaWNFYXNpbmdGdW5jKGVhc2luZyk7XG4gICAgICAgIH1cbiAgICAgICAga2V5ZnJhbWVzLnB1c2goa2YpO1xuICAgICAgICByZXR1cm4ga2Y7XG4gICAgfTtcbiAgICBUcmFjay5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uIChtYXhUaW1lLCBhZGRpdGl2ZVRyYWNrKSB7XG4gICAgICAgIHZhciBrZnMgPSB0aGlzLmtleWZyYW1lcztcbiAgICAgICAgaWYgKHRoaXMuX25lZWRzU29ydCkge1xuICAgICAgICAgICAga2ZzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbFR5cGUgPSB0aGlzLnZhbFR5cGU7XG4gICAgICAgIHZhciBrZnNMZW4gPSBrZnMubGVuZ3RoO1xuICAgICAgICB2YXIgbGFzdEtmID0ga2ZzW2tmc0xlbiAtIDFdO1xuICAgICAgICB2YXIgaXNEaXNjcmV0ZSA9IHRoaXMuZGlzY3JldGU7XG4gICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXlWYWx1ZVR5cGUodmFsVHlwZSk7XG4gICAgICAgIHZhciBpc0dyYWRpZW50ID0gaXNHcmFkaWVudFZhbHVlVHlwZSh2YWxUeXBlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZnNMZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGtmID0ga2ZzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0ga2YudmFsdWU7XG4gICAgICAgICAgICB2YXIgbGFzdFZhbHVlID0gbGFzdEtmLnZhbHVlO1xuICAgICAgICAgICAga2YucGVyY2VudCA9IGtmLnRpbWUgLyBtYXhUaW1lO1xuICAgICAgICAgICAgaWYgKCFpc0Rpc2NyZXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyICYmIGkgIT09IGtmc0xlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbEFycmF5KHZhbHVlLCBsYXN0VmFsdWUsIHZhbFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0dyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvclN0b3BzKHZhbHVlLmNvbG9yU3RvcHMsIGxhc3RWYWx1ZS5jb2xvclN0b3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0Rpc2NyZXRlXG4gICAgICAgICAgICAmJiB2YWxUeXBlICE9PSBWQUxVRV9UWVBFX1JBRElBTF9HUkFESUVOVFxuICAgICAgICAgICAgJiYgYWRkaXRpdmVUcmFja1xuICAgICAgICAgICAgJiYgdGhpcy5uZWVkc0FuaW1hdGUoKVxuICAgICAgICAgICAgJiYgYWRkaXRpdmVUcmFjay5uZWVkc0FuaW1hdGUoKVxuICAgICAgICAgICAgJiYgdmFsVHlwZSA9PT0gYWRkaXRpdmVUcmFjay52YWxUeXBlXG4gICAgICAgICAgICAmJiAhYWRkaXRpdmVUcmFjay5fZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aXZlVHJhY2sgPSBhZGRpdGl2ZVRyYWNrO1xuICAgICAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBrZnNbMF0udmFsdWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtmc0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbFR5cGUgPT09IFZBTFVFX1RZUEVfTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgICAgIGtmc1tpXS5hZGRpdGl2ZVZhbHVlID0ga2ZzW2ldLnZhbHVlIC0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsVHlwZSA9PT0gVkFMVUVfVFlQRV9DT0xPUikge1xuICAgICAgICAgICAgICAgICAgICBrZnNbaV0uYWRkaXRpdmVWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGQxREFycmF5KFtdLCBrZnNbaV0udmFsdWUsIHN0YXJ0VmFsdWUsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheVZhbHVlVHlwZSh2YWxUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBrZnNbaV0uYWRkaXRpdmVWYWx1ZSA9IHZhbFR5cGUgPT09IFZBTFVFX1RZUEVfMURfQVJSQVlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYWRkMURBcnJheShbXSwga2ZzW2ldLnZhbHVlLCBzdGFydFZhbHVlLCAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYWRkMkRBcnJheShbXSwga2ZzW2ldLnZhbHVlLCBzdGFydFZhbHVlLCAtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFjay5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FkZGl0aXZlVHJhY2sgJiYgdGhpcy5fYWRkaXRpdmVUcmFjay5fZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aXZlVHJhY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0FkZGl0aXZlID0gdGhpcy5fYWRkaXRpdmVUcmFjayAhPSBudWxsO1xuICAgICAgICB2YXIgdmFsdWVLZXkgPSBpc0FkZGl0aXZlID8gJ2FkZGl0aXZlVmFsdWUnIDogJ3ZhbHVlJztcbiAgICAgICAgdmFyIHZhbFR5cGUgPSB0aGlzLnZhbFR5cGU7XG4gICAgICAgIHZhciBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcztcbiAgICAgICAgdmFyIGtmc051bSA9IGtleWZyYW1lcy5sZW5ndGg7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHRoaXMucHJvcE5hbWU7XG4gICAgICAgIHZhciBpc1ZhbHVlQ29sb3IgPSB2YWxUeXBlID09PSBWQUxVRV9UWVBFX0NPTE9SO1xuICAgICAgICB2YXIgZnJhbWVJZHg7XG4gICAgICAgIHZhciBsYXN0RnJhbWUgPSB0aGlzLl9sYXN0RnI7XG4gICAgICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgICAgIHZhciBmcmFtZTtcbiAgICAgICAgdmFyIG5leHRGcmFtZTtcbiAgICAgICAgaWYgKGtmc051bSA9PT0gMSkge1xuICAgICAgICAgICAgZnJhbWUgPSBuZXh0RnJhbWUgPSBrZXlmcmFtZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgICAgICBmcmFtZUlkeCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwZXJjZW50IDwgdGhpcy5fbGFzdEZyUCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IG1hdGhNaW4obGFzdEZyYW1lICsgMSwga2ZzTnVtIC0gMSk7XG4gICAgICAgICAgICAgICAgZm9yIChmcmFtZUlkeCA9IHN0YXJ0OyBmcmFtZUlkeCA+PSAwOyBmcmFtZUlkeC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlmcmFtZXNbZnJhbWVJZHhdLnBlcmNlbnQgPD0gcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJhbWVJZHggPSBtYXRoTWluKGZyYW1lSWR4LCBrZnNOdW0gLSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoZnJhbWVJZHggPSBsYXN0RnJhbWU7IGZyYW1lSWR4IDwga2ZzTnVtOyBmcmFtZUlkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlmcmFtZXNbZnJhbWVJZHhdLnBlcmNlbnQgPiBwZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcmFtZUlkeCA9IG1hdGhNaW4oZnJhbWVJZHggLSAxLCBrZnNOdW0gLSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRGcmFtZSA9IGtleWZyYW1lc1tmcmFtZUlkeCArIDFdO1xuICAgICAgICAgICAgZnJhbWUgPSBrZXlmcmFtZXNbZnJhbWVJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGZyYW1lICYmIG5leHRGcmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0RnIgPSBmcmFtZUlkeDtcbiAgICAgICAgdGhpcy5fbGFzdEZyUCA9IHBlcmNlbnQ7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IChuZXh0RnJhbWUucGVyY2VudCAtIGZyYW1lLnBlcmNlbnQpO1xuICAgICAgICB2YXIgdyA9IGludGVydmFsID09PSAwID8gMSA6IG1hdGhNaW4oKHBlcmNlbnQgLSBmcmFtZS5wZXJjZW50KSAvIGludGVydmFsLCAxKTtcbiAgICAgICAgaWYgKG5leHRGcmFtZS5lYXNpbmdGdW5jKSB7XG4gICAgICAgICAgICB3ID0gbmV4dEZyYW1lLmVhc2luZ0Z1bmModyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhcmdldEFyciA9IGlzQWRkaXRpdmUgPyB0aGlzLl9hZGRpdGl2ZVZhbHVlXG4gICAgICAgICAgICA6IChpc1ZhbHVlQ29sb3IgPyB0bXBSZ2JhIDogdGFyZ2V0W3Byb3BOYW1lXSk7XG4gICAgICAgIGlmICgoaXNBcnJheVZhbHVlVHlwZSh2YWxUeXBlKSB8fCBpc1ZhbHVlQ29sb3IpICYmICF0YXJnZXRBcnIpIHtcbiAgICAgICAgICAgIHRhcmdldEFyciA9IHRoaXMuX2FkZGl0aXZlVmFsdWUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXNjcmV0ZSkge1xuICAgICAgICAgICAgdGFyZ2V0W3Byb3BOYW1lXSA9IHcgPCAxID8gZnJhbWUucmF3VmFsdWUgOiBuZXh0RnJhbWUucmF3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBcnJheVZhbHVlVHlwZSh2YWxUeXBlKSkge1xuICAgICAgICAgICAgdmFsVHlwZSA9PT0gVkFMVUVfVFlQRV8xRF9BUlJBWVxuICAgICAgICAgICAgICAgID8gaW50ZXJwb2xhdGUxREFycmF5KHRhcmdldEFyciwgZnJhbWVbdmFsdWVLZXldLCBuZXh0RnJhbWVbdmFsdWVLZXldLCB3KVxuICAgICAgICAgICAgICAgIDogaW50ZXJwb2xhdGUyREFycmF5KHRhcmdldEFyciwgZnJhbWVbdmFsdWVLZXldLCBuZXh0RnJhbWVbdmFsdWVLZXldLCB3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0dyYWRpZW50VmFsdWVUeXBlKHZhbFR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gZnJhbWVbdmFsdWVLZXldO1xuICAgICAgICAgICAgdmFyIG5leHRWYWxfMSA9IG5leHRGcmFtZVt2YWx1ZUtleV07XG4gICAgICAgICAgICB2YXIgaXNMaW5lYXJHcmFkaWVudF8xID0gdmFsVHlwZSA9PT0gVkFMVUVfVFlQRV9MSU5FQVJfR1JBRElFTlQ7XG4gICAgICAgICAgICB0YXJnZXRbcHJvcE5hbWVdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGlzTGluZWFyR3JhZGllbnRfMSA/ICdsaW5lYXInIDogJ3JhZGlhbCcsXG4gICAgICAgICAgICAgICAgeDogaW50ZXJwb2xhdGVOdW1iZXIodmFsLngsIG5leHRWYWxfMS54LCB3KSxcbiAgICAgICAgICAgICAgICB5OiBpbnRlcnBvbGF0ZU51bWJlcih2YWwueSwgbmV4dFZhbF8xLnksIHcpLFxuICAgICAgICAgICAgICAgIGNvbG9yU3RvcHM6IG1hcCh2YWwuY29sb3JTdG9wcywgZnVuY3Rpb24gKGNvbG9yU3RvcCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q29sb3JTdG9wID0gbmV4dFZhbF8xLmNvbG9yU3RvcHNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogaW50ZXJwb2xhdGVOdW1iZXIoY29sb3JTdG9wLm9mZnNldCwgbmV4dENvbG9yU3RvcC5vZmZzZXQsIHcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJnYmEyU3RyaW5nKGludGVycG9sYXRlMURBcnJheShbXSwgY29sb3JTdG9wLmNvbG9yLCBuZXh0Q29sb3JTdG9wLmNvbG9yLCB3KSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBnbG9iYWw6IG5leHRWYWxfMS5nbG9iYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaXNMaW5lYXJHcmFkaWVudF8xKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BOYW1lXS54MiA9IGludGVycG9sYXRlTnVtYmVyKHZhbC54MiwgbmV4dFZhbF8xLngyLCB3KTtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcE5hbWVdLnkyID0gaW50ZXJwb2xhdGVOdW1iZXIodmFsLnkyLCBuZXh0VmFsXzEueTIsIHcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BOYW1lXS5yID0gaW50ZXJwb2xhdGVOdW1iZXIodmFsLnIsIG5leHRWYWxfMS5yLCB3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgIGludGVycG9sYXRlMURBcnJheSh0YXJnZXRBcnIsIGZyYW1lW3ZhbHVlS2V5XSwgbmV4dEZyYW1lW3ZhbHVlS2V5XSwgdyk7XG4gICAgICAgICAgICBpZiAoIWlzQWRkaXRpdmUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcE5hbWVdID0gcmdiYTJTdHJpbmcodGFyZ2V0QXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGludGVycG9sYXRlTnVtYmVyKGZyYW1lW3ZhbHVlS2V5XSwgbmV4dEZyYW1lW3ZhbHVlS2V5XSwgdyk7XG4gICAgICAgICAgICBpZiAoaXNBZGRpdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aXZlVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBZGRpdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9UYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhY2sucHJvdG90eXBlLl9hZGRUb1RhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIHZhbFR5cGUgPSB0aGlzLnZhbFR5cGU7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHRoaXMucHJvcE5hbWU7XG4gICAgICAgIHZhciBhZGRpdGl2ZVZhbHVlID0gdGhpcy5fYWRkaXRpdmVWYWx1ZTtcbiAgICAgICAgaWYgKHZhbFR5cGUgPT09IFZBTFVFX1RZUEVfTlVNQkVSKSB7XG4gICAgICAgICAgICB0YXJnZXRbcHJvcE5hbWVdID0gdGFyZ2V0W3Byb3BOYW1lXSArIGFkZGl0aXZlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsVHlwZSA9PT0gVkFMVUVfVFlQRV9DT0xPUikge1xuICAgICAgICAgICAgY29sb3IucGFyc2UodGFyZ2V0W3Byb3BOYW1lXSwgdG1wUmdiYSk7XG4gICAgICAgICAgICBhZGQxREFycmF5KHRtcFJnYmEsIHRtcFJnYmEsIGFkZGl0aXZlVmFsdWUsIDEpO1xuICAgICAgICAgICAgdGFyZ2V0W3Byb3BOYW1lXSA9IHJnYmEyU3RyaW5nKHRtcFJnYmEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbFR5cGUgPT09IFZBTFVFX1RZUEVfMURfQVJSQVkpIHtcbiAgICAgICAgICAgIGFkZDFEQXJyYXkodGFyZ2V0W3Byb3BOYW1lXSwgdGFyZ2V0W3Byb3BOYW1lXSwgYWRkaXRpdmVWYWx1ZSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsVHlwZSA9PT0gVkFMVUVfVFlQRV8yRF9BUlJBWSkge1xuICAgICAgICAgICAgYWRkMkRBcnJheSh0YXJnZXRbcHJvcE5hbWVdLCB0YXJnZXRbcHJvcE5hbWVdLCBhZGRpdGl2ZVZhbHVlLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRyYWNrO1xufSgpKTtcbnZhciBBbmltYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0b3IodGFyZ2V0LCBsb29wLCBhbGxvd0Rpc2NyZXRlQW5pbWF0aW9uLCBhZGRpdGl2ZVRvKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl90cmFja0tleXMgPSBbXTtcbiAgICAgICAgdGhpcy5fbWF4VGltZSA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSAwO1xuICAgICAgICB0aGlzLl9jbGlwID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLl9sb29wID0gbG9vcDtcbiAgICAgICAgaWYgKGxvb3AgJiYgYWRkaXRpdmVUbykge1xuICAgICAgICAgICAgbG9nRXJyb3IoJ0NhblxcJyB1c2UgYWRkaXRpdmUgYW5pbWF0aW9uIG9uIGxvb3BlZCBhbmltYXRpb24uJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWRkaXRpdmVBbmltYXRvcnMgPSBhZGRpdGl2ZVRvO1xuICAgICAgICB0aGlzLl9hbGxvd0Rpc2NyZXRlID0gYWxsb3dEaXNjcmV0ZUFuaW1hdGlvbjtcbiAgICB9XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLmdldE1heFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhUaW1lO1xuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLmdldERlbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVsYXk7XG4gICAgfTtcbiAgICBBbmltYXRvci5wcm90b3R5cGUuZ2V0TG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvb3A7XG4gICAgfTtcbiAgICBBbmltYXRvci5wcm90b3R5cGUuZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLmNoYW5nZVRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbiAodGltZSwgcHJvcHMsIGVhc2luZykge1xuICAgICAgICByZXR1cm4gdGhpcy53aGVuV2l0aEtleXModGltZSwgcHJvcHMsIGtleXMocHJvcHMpLCBlYXNpbmcpO1xuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLndoZW5XaXRoS2V5cyA9IGZ1bmN0aW9uICh0aW1lLCBwcm9wcywgcHJvcE5hbWVzLCBlYXNpbmcpIHtcbiAgICAgICAgdmFyIHRyYWNrcyA9IHRoaXMuX3RyYWNrcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BOYW1lc1tpXTtcbiAgICAgICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1twcm9wTmFtZV07XG4gICAgICAgICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgICAgICAgICAgdHJhY2sgPSB0cmFja3NbcHJvcE5hbWVdID0gbmV3IFRyYWNrKHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbFZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBhZGRpdGl2ZVRyYWNrID0gdGhpcy5fZ2V0QWRkaXRpdmVUcmFjayhwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZGl0aXZlVHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZHRpdmVUcmFja0tmcyA9IGFkZGl0aXZlVHJhY2sua2V5ZnJhbWVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdEZpbmFsS2YgPSBhZGR0aXZlVHJhY2tLZnNbYWRkdGl2ZVRyYWNrS2ZzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBsYXN0RmluYWxLZiAmJiBsYXN0RmluYWxLZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZGl0aXZlVHJhY2sudmFsVHlwZSA9PT0gVkFMVUVfVFlQRV9DT0xPUiAmJiBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IHJnYmEyU3RyaW5nKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IHRoaXMuX3RhcmdldFtwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLmFkZEtleWZyYW1lKDAsIGNsb25lVmFsdWUoaW5pdGlhbFZhbHVlKSwgZWFzaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhY2tLZXlzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2suYWRkS2V5ZnJhbWUodGltZSwgY2xvbmVWYWx1ZShwcm9wc1twcm9wTmFtZV0pLCBlYXNpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21heFRpbWUgPSBNYXRoLm1heCh0aGlzLl9tYXhUaW1lLCB0aW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBbmltYXRvci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NsaXAucGF1c2UoKTtcbiAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIEFuaW1hdG9yLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NsaXAucmVzdW1lKCk7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9wYXVzZWQ7XG4gICAgfTtcbiAgICBBbmltYXRvci5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5fbWF4VGltZSA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLl9mb3JjZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLl9kb25lQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NldFRyYWNrc0ZpbmlzaGVkKCk7XG4gICAgICAgIHRoaXMuX2NsaXAgPSBudWxsO1xuICAgICAgICB2YXIgZG9uZUxpc3QgPSB0aGlzLl9kb25lQ2JzO1xuICAgICAgICBpZiAoZG9uZUxpc3QpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBkb25lTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZG9uZUxpc3RbaV0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLl9hYm9ydGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NldFRyYWNrc0ZpbmlzaGVkKCk7XG4gICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbjtcbiAgICAgICAgdmFyIGFib3J0ZWRMaXN0ID0gdGhpcy5fYWJvcnRlZENicztcbiAgICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgYW5pbWF0aW9uLnJlbW92ZUNsaXAodGhpcy5fY2xpcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xpcCA9IG51bGw7XG4gICAgICAgIGlmIChhYm9ydGVkTGlzdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhYm9ydGVkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFib3J0ZWRMaXN0W2ldLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFuaW1hdG9yLnByb3RvdHlwZS5fc2V0VHJhY2tzRmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmFja3MgPSB0aGlzLl90cmFja3M7XG4gICAgICAgIHZhciB0cmFja3NLZXlzID0gdGhpcy5fdHJhY2tLZXlzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrc0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyYWNrc1t0cmFja3NLZXlzW2ldXS5zZXRGaW5pc2hlZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbmltYXRvci5wcm90b3R5cGUuX2dldEFkZGl0aXZlVHJhY2sgPSBmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICAgIHZhciBhZGRpdGl2ZVRyYWNrO1xuICAgICAgICB2YXIgYWRkaXRpdmVBbmltYXRvcnMgPSB0aGlzLl9hZGRpdGl2ZUFuaW1hdG9ycztcbiAgICAgICAgaWYgKGFkZGl0aXZlQW5pbWF0b3JzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZGl0aXZlQW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gYWRkaXRpdmVBbmltYXRvcnNbaV0uZ2V0VHJhY2sodHJhY2tOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpdmVUcmFjayA9IHRyYWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkaXRpdmVUcmFjaztcbiAgICB9O1xuICAgIEFuaW1hdG9yLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChlYXNpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXJ0ZWQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IDE7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHRyYWNrcyA9IFtdO1xuICAgICAgICB2YXIgbWF4VGltZSA9IHRoaXMuX21heFRpbWUgfHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90cmFja0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHRoaXMuX3RyYWNrS2V5c1tpXTtcbiAgICAgICAgICAgIHZhciB0cmFjayA9IHRoaXMuX3RyYWNrc1twcm9wTmFtZV07XG4gICAgICAgICAgICB2YXIgYWRkaXRpdmVUcmFjayA9IHRoaXMuX2dldEFkZGl0aXZlVHJhY2socHJvcE5hbWUpO1xuICAgICAgICAgICAgdmFyIGtmcyA9IHRyYWNrLmtleWZyYW1lcztcbiAgICAgICAgICAgIHZhciBrZnNOdW0gPSBrZnMubGVuZ3RoO1xuICAgICAgICAgICAgdHJhY2sucHJlcGFyZShtYXhUaW1lLCBhZGRpdGl2ZVRyYWNrKTtcbiAgICAgICAgICAgIGlmICh0cmFjay5uZWVkc0FuaW1hdGUoKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYWxsb3dEaXNjcmV0ZSAmJiB0cmFjay5kaXNjcmV0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdEtmID0ga2ZzW2tmc051bSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEtmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl90YXJnZXRbdHJhY2sucHJvcE5hbWVdID0gbGFzdEtmLnJhd1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLnNldEZpbmlzaGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFja3MucHVzaCh0cmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFja3MubGVuZ3RoIHx8IHRoaXMuX2ZvcmNlKSB7XG4gICAgICAgICAgICB2YXIgY2xpcCA9IG5ldyBDbGlwKHtcbiAgICAgICAgICAgICAgICBsaWZlOiBtYXhUaW1lLFxuICAgICAgICAgICAgICAgIGxvb3A6IHRoaXMuX2xvb3AsXG4gICAgICAgICAgICAgICAgZGVsYXk6IHRoaXMuX2RlbGF5IHx8IDAsXG4gICAgICAgICAgICAgICAgb25mcmFtZTogZnVuY3Rpb24gKHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fc3RhcnRlZCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRpdGl2ZUFuaW1hdG9ycyA9IHNlbGYuX2FkZGl0aXZlQW5pbWF0b3JzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpdmVBbmltYXRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGlsbEhhc0FkZGl0aXZlQW5pbWF0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkaXRpdmVBbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpdmVBbmltYXRvcnNbaV0uX2NsaXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RpbGxIYXNBZGRpdGl2ZUFuaW1hdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGlsbEhhc0FkZGl0aXZlQW5pbWF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRpdGl2ZUFuaW1hdG9ycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrc1tpXS5zdGVwKHNlbGYuX3RhcmdldCwgcGVyY2VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uZnJhbWVMaXN0ID0gc2VsZi5fb25mcmFtZUNicztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uZnJhbWVMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9uZnJhbWVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25mcmFtZUxpc3RbaV0oc2VsZi5fdGFyZ2V0LCBwZXJjZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fY2xpcCA9IGNsaXA7XG4gICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGRDbGlwKGNsaXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVhc2luZykge1xuICAgICAgICAgICAgICAgIGNsaXAuc2V0RWFzaW5nKGVhc2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kb25lQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFuaW1hdG9yLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jbGlwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsaXAgPSB0aGlzLl9jbGlwO1xuICAgICAgICBpZiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICAgICAgY2xpcC5vbmZyYW1lKDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Fib3J0ZWRDYWxsYmFjaygpO1xuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgdGhpcy5fZGVsYXkgPSB0aW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFuaW1hdG9yLnByb3RvdHlwZS5kdXJpbmcgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX29uZnJhbWVDYnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbmZyYW1lQ2JzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vbmZyYW1lQ2JzLnB1c2goY2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RvbmVDYnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb25lQ2JzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kb25lQ2JzLnB1c2goY2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLmFib3J0ZWQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Fib3J0ZWRDYnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hYm9ydGVkQ2JzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hYm9ydGVkQ2JzLnB1c2goY2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLmdldENsaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGlwO1xuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLmdldFRyYWNrID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja3NbcHJvcE5hbWVdO1xuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLmdldFRyYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG1hcCh0aGlzLl90cmFja0tleXMsIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIF90aGlzLl90cmFja3Nba2V5XTsgfSk7XG4gICAgfTtcbiAgICBBbmltYXRvci5wcm90b3R5cGUuc3RvcFRyYWNrcyA9IGZ1bmN0aW9uIChwcm9wTmFtZXMsIGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgaWYgKCFwcm9wTmFtZXMubGVuZ3RoIHx8ICF0aGlzLl9jbGlwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy5fdHJhY2tzO1xuICAgICAgICB2YXIgdHJhY2tzS2V5cyA9IHRoaXMuX3RyYWNrS2V5cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1twcm9wTmFtZXNbaV1dO1xuICAgICAgICAgICAgaWYgKHRyYWNrICYmICF0cmFjay5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5zdGVwKHRoaXMuX3RhcmdldCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXJ0ZWQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suc3RlcCh0aGlzLl90YXJnZXQsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFjay5zZXRGaW5pc2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBhbGxBYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3NLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRyYWNrc1t0cmFja3NLZXlzW2ldXS5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgICAgICAgICAgICBhbGxBYm9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbEFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0ZWRDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxBYm9ydGVkO1xuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLnNhdmVUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIHRyYWNrS2V5cywgZmlyc3RPckxhc3QpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFja0tleXMgPSB0cmFja0tleXMgfHwgdGhpcy5fdHJhY2tLZXlzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gdHJhY2tLZXlzW2ldO1xuICAgICAgICAgICAgdmFyIHRyYWNrID0gdGhpcy5fdHJhY2tzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIGlmICghdHJhY2sgfHwgdHJhY2suaXNGaW5pc2hlZCgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIga2ZzID0gdHJhY2sua2V5ZnJhbWVzO1xuICAgICAgICAgICAgdmFyIGtmID0ga2ZzW2ZpcnN0T3JMYXN0ID8gMCA6IGtmcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChrZikge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wTmFtZV0gPSBjbG9uZVZhbHVlKGtmLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5pbWF0b3IucHJvdG90eXBlLl9fY2hhbmdlRmluYWxWYWx1ZSA9IGZ1bmN0aW9uIChmaW5hbFByb3BzLCB0cmFja0tleXMpIHtcbiAgICAgICAgdHJhY2tLZXlzID0gdHJhY2tLZXlzIHx8IGtleXMoZmluYWxQcm9wcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSB0cmFja0tleXNbaV07XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLl90cmFja3NbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtmcyA9IHRyYWNrLmtleWZyYW1lcztcbiAgICAgICAgICAgIGlmIChrZnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0S2YgPSBrZnMucG9wKCk7XG4gICAgICAgICAgICAgICAgdHJhY2suYWRkS2V5ZnJhbWUobGFzdEtmLnRpbWUsIGZpbmFsUHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgICB0cmFjay5wcmVwYXJlKHRoaXMuX21heFRpbWUsIHRyYWNrLmdldEFkZGl0aXZlVHJhY2soKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRvcjtcbn0oKSk7XG5leHBvcnQgZGVmYXVsdCBBbmltYXRvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21756\n")},45825:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _core_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38123);\n\nvar requestAnimationFrame;\nrequestAnimationFrame = (_core_env_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.hasGlobalWindow\n    && ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))\n        || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))\n        || window.mozRequestAnimationFrame\n        || window.webkitRequestAnimationFrame)) || function (func) {\n    return setTimeout(func, 16);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (requestAnimationFrame);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU4MjUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanM/ZjkxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZW52IGZyb20gJy4uL2NvcmUvZW52LmpzJztcbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoZW52Lmhhc0dsb2JhbFdpbmRvd1xuICAgICYmICgod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSlcbiAgICAgICAgfHwgKHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpKVxuICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKSB8fCBmdW5jdGlvbiAoZnVuYykge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmMsIDE2KTtcbn07XG5leHBvcnQgZGVmYXVsdCByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///45825\n')},56494:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15727);\n/* harmony import */ var _core_util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(98026);\n/* harmony import */ var _core_vector_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(83509);\n/* harmony import */ var _mixin_Draggable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32939);\n/* harmony import */ var _core_Eventful_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57861);\n/* harmony import */ var _core_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35452);\n/* harmony import */ var _core_GestureMgr_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(77357);\n/* harmony import */ var _core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29308);\n\n\n\n\n\n\n\n\nvar SILENT = 'silent';\nfunction makeEventPacket(eveType, targetInfo, event) {\n    return {\n        type: eveType,\n        event: event,\n        target: targetInfo.target,\n        topTarget: targetInfo.topTarget,\n        cancelBubble: false,\n        offsetX: event.zrX,\n        offsetY: event.zrY,\n        gestureEvent: event.gestureEvent,\n        pinchX: event.pinchX,\n        pinchY: event.pinchY,\n        pinchScale: event.pinchScale,\n        wheelDelta: event.zrDelta,\n        zrByTouch: event.zrByTouch,\n        which: event.which,\n        stop: stopEvent\n    };\n}\nfunction stopEvent() {\n    _core_event_js__WEBPACK_IMPORTED_MODULE_0__/* .stop */ .ds(this.event);\n}\nvar EmptyProxy = (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .C6)(EmptyProxy, _super);\n    function EmptyProxy() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.handler = null;\n        return _this;\n    }\n    EmptyProxy.prototype.dispose = function () { };\n    EmptyProxy.prototype.setCursor = function () { };\n    return EmptyProxy;\n}(_core_Eventful_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A));\nvar HoveredResult = (function () {\n    function HoveredResult(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    return HoveredResult;\n}());\nvar handlerNames = [\n    'click', 'dblclick', 'mousewheel', 'mouseout',\n    'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n];\nvar tmpRect = new _core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A(0, 0, 0, 0);\nvar Handler = (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .C6)(Handler, _super);\n    function Handler(storage, painter, proxy, painterRoot, pointerSize) {\n        var _this = _super.call(this) || this;\n        _this._hovered = new HoveredResult(0, 0);\n        _this.storage = storage;\n        _this.painter = painter;\n        _this.painterRoot = painterRoot;\n        _this._pointerSize = pointerSize;\n        proxy = proxy || new EmptyProxy();\n        _this.proxy = null;\n        _this.setHandlerProxy(proxy);\n        _this._draggingMgr = new _mixin_Draggable_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A(_this);\n        return _this;\n    }\n    Handler.prototype.setHandlerProxy = function (proxy) {\n        if (this.proxy) {\n            this.proxy.dispose();\n        }\n        if (proxy) {\n            _core_util_js__WEBPACK_IMPORTED_MODULE_5__.each(handlerNames, function (name) {\n                proxy.on && proxy.on(name, this[name], this);\n            }, this);\n            proxy.handler = this;\n        }\n        this.proxy = proxy;\n    };\n    Handler.prototype.mousemove = function (event) {\n        var x = event.zrX;\n        var y = event.zrY;\n        var isOutside = isOutsideBoundary(this, x, y);\n        var lastHovered = this._hovered;\n        var lastHoveredTarget = lastHovered.target;\n        if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n            lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n            lastHoveredTarget = lastHovered.target;\n        }\n        var hovered = this._hovered = isOutside ? new HoveredResult(x, y) : this.findHover(x, y);\n        var hoveredTarget = hovered.target;\n        var proxy = this.proxy;\n        proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');\n        if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n            this.dispatchToElement(lastHovered, 'mouseout', event);\n        }\n        this.dispatchToElement(hovered, 'mousemove', event);\n        if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n            this.dispatchToElement(hovered, 'mouseover', event);\n        }\n    };\n    Handler.prototype.mouseout = function (event) {\n        var eventControl = event.zrEventControl;\n        if (eventControl !== 'only_globalout') {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n        }\n        if (eventControl !== 'no_globalout') {\n            this.trigger('globalout', { type: 'globalout', event: event });\n        }\n    };\n    Handler.prototype.resize = function () {\n        this._hovered = new HoveredResult(0, 0);\n    };\n    Handler.prototype.dispatch = function (eventName, eventArgs) {\n        var handler = this[eventName];\n        handler && handler.call(this, eventArgs);\n    };\n    Handler.prototype.dispose = function () {\n        this.proxy.dispose();\n        this.storage = null;\n        this.proxy = null;\n        this.painter = null;\n    };\n    Handler.prototype.setCursorStyle = function (cursorStyle) {\n        var proxy = this.proxy;\n        proxy.setCursor && proxy.setCursor(cursorStyle);\n    };\n    Handler.prototype.dispatchToElement = function (targetInfo, eventName, event) {\n        targetInfo = targetInfo || {};\n        var el = targetInfo.target;\n        if (el && el.silent) {\n            return;\n        }\n        var eventKey = ('on' + eventName);\n        var eventPacket = makeEventPacket(eventName, targetInfo, event);\n        while (el) {\n            el[eventKey]\n                && (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket));\n            el.trigger(eventName, eventPacket);\n            el = el.__hostTarget ? el.__hostTarget : el.parent;\n            if (eventPacket.cancelBubble) {\n                break;\n            }\n        }\n        if (!eventPacket.cancelBubble) {\n            this.trigger(eventName, eventPacket);\n            if (this.painter && this.painter.eachOtherLayer) {\n                this.painter.eachOtherLayer(function (layer) {\n                    if (typeof (layer[eventKey]) === 'function') {\n                        layer[eventKey].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        }\n    };\n    Handler.prototype.findHover = function (x, y, exclude) {\n        var list = this.storage.getDisplayList();\n        var out = new HoveredResult(x, y);\n        setHoverTarget(list, out, x, y, exclude);\n        if (this._pointerSize && !out.target) {\n            var candidates = [];\n            var pointerSize = this._pointerSize;\n            var targetSizeHalf = pointerSize / 2;\n            var pointerRect = new _core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A(x - targetSizeHalf, y - targetSizeHalf, pointerSize, pointerSize);\n            for (var i = list.length - 1; i >= 0; i--) {\n                var el = list[i];\n                if (el !== exclude\n                    && !el.ignore\n                    && !el.ignoreCoarsePointer\n                    && (!el.parent || !el.parent.ignoreCoarsePointer)) {\n                    tmpRect.copy(el.getBoundingRect());\n                    if (el.transform) {\n                        tmpRect.applyTransform(el.transform);\n                    }\n                    if (tmpRect.intersect(pointerRect)) {\n                        candidates.push(el);\n                    }\n                }\n            }\n            if (candidates.length) {\n                var rStep = 4;\n                var thetaStep = Math.PI / 12;\n                var PI2 = Math.PI * 2;\n                for (var r = 0; r < targetSizeHalf; r += rStep) {\n                    for (var theta = 0; theta < PI2; theta += thetaStep) {\n                        var x1 = x + r * Math.cos(theta);\n                        var y1 = y + r * Math.sin(theta);\n                        setHoverTarget(candidates, out, x1, y1, exclude);\n                        if (out.target) {\n                            return out;\n                        }\n                    }\n                }\n            }\n        }\n        return out;\n    };\n    Handler.prototype.processGesture = function (event, stage) {\n        if (!this._gestureMgr) {\n            this._gestureMgr = new _core_GestureMgr_js__WEBPACK_IMPORTED_MODULE_6__/* .GestureMgr */ ._();\n        }\n        var gestureMgr = this._gestureMgr;\n        stage === 'start' && gestureMgr.clear();\n        var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);\n        stage === 'end' && gestureMgr.clear();\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n            var res = new HoveredResult();\n            res.target = gestureInfo.target;\n            this.dispatchToElement(res, type, gestureInfo.event);\n        }\n    };\n    return Handler;\n}(_core_Eventful_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A));\n_core_util_js__WEBPACK_IMPORTED_MODULE_5__.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n    Handler.prototype[name] = function (event) {\n        var x = event.zrX;\n        var y = event.zrY;\n        var isOutside = isOutsideBoundary(this, x, y);\n        var hovered;\n        var hoveredTarget;\n        if (name !== 'mouseup' || !isOutside) {\n            hovered = this.findHover(x, y);\n            hoveredTarget = hovered.target;\n        }\n        if (name === 'mousedown') {\n            this._downEl = hoveredTarget;\n            this._downPoint = [event.zrX, event.zrY];\n            this._upEl = hoveredTarget;\n        }\n        else if (name === 'mouseup') {\n            this._upEl = hoveredTarget;\n        }\n        else if (name === 'click') {\n            if (this._downEl !== this._upEl\n                || !this._downPoint\n                || _core_vector_js__WEBPACK_IMPORTED_MODULE_7__.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n                return;\n            }\n            this._downPoint = null;\n        }\n        this.dispatchToElement(hovered, name, event);\n    };\n});\nfunction isHover(displayable, x, y) {\n    if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n        var el = displayable;\n        var isSilent = void 0;\n        var ignoreClip = false;\n        while (el) {\n            if (el.ignoreClip) {\n                ignoreClip = true;\n            }\n            if (!ignoreClip) {\n                var clipPath = el.getClipPath();\n                if (clipPath && !clipPath.contain(x, y)) {\n                    return false;\n                }\n            }\n            if (el.silent) {\n                isSilent = true;\n            }\n            var hostEl = el.__hostTarget;\n            el = hostEl ? hostEl : el.parent;\n        }\n        return isSilent ? SILENT : true;\n    }\n    return false;\n}\nfunction setHoverTarget(list, out, x, y, exclude) {\n    for (var i = list.length - 1; i >= 0; i--) {\n        var el = list[i];\n        var hoverCheckResult = void 0;\n        if (el !== exclude\n            && !el.ignore\n            && (hoverCheckResult = isHover(el, x, y))) {\n            !out.topTarget && (out.topTarget = el);\n            if (hoverCheckResult !== SILENT) {\n                out.target = el;\n                break;\n            }\n        }\n    }\n}\nfunction isOutsideBoundary(handlerInstance, x, y) {\n    var painter = handlerInstance.painter;\n    return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Handler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY0OTQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9IYW5kbGVyLmpzP2E0NTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi9jb3JlL3ZlY3Rvci5qcyc7XG5pbXBvcnQgRHJhZ2dhYmxlIGZyb20gJy4vbWl4aW4vRHJhZ2dhYmxlLmpzJztcbmltcG9ydCBFdmVudGZ1bCBmcm9tICcuL2NvcmUvRXZlbnRmdWwuanMnO1xuaW1wb3J0ICogYXMgZXZlbnRUb29sIGZyb20gJy4vY29yZS9ldmVudC5qcyc7XG5pbXBvcnQgeyBHZXN0dXJlTWdyIH0gZnJvbSAnLi9jb3JlL0dlc3R1cmVNZ3IuanMnO1xuaW1wb3J0IEJvdW5kaW5nUmVjdCBmcm9tICcuL2NvcmUvQm91bmRpbmdSZWN0LmpzJztcbnZhciBTSUxFTlQgPSAnc2lsZW50JztcbmZ1bmN0aW9uIG1ha2VFdmVudFBhY2tldChldmVUeXBlLCB0YXJnZXRJbmZvLCBldmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGV2ZVR5cGUsXG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRJbmZvLnRhcmdldCxcbiAgICAgICAgdG9wVGFyZ2V0OiB0YXJnZXRJbmZvLnRvcFRhcmdldCxcbiAgICAgICAgY2FuY2VsQnViYmxlOiBmYWxzZSxcbiAgICAgICAgb2Zmc2V0WDogZXZlbnQuenJYLFxuICAgICAgICBvZmZzZXRZOiBldmVudC56clksXG4gICAgICAgIGdlc3R1cmVFdmVudDogZXZlbnQuZ2VzdHVyZUV2ZW50LFxuICAgICAgICBwaW5jaFg6IGV2ZW50LnBpbmNoWCxcbiAgICAgICAgcGluY2hZOiBldmVudC5waW5jaFksXG4gICAgICAgIHBpbmNoU2NhbGU6IGV2ZW50LnBpbmNoU2NhbGUsXG4gICAgICAgIHdoZWVsRGVsdGE6IGV2ZW50LnpyRGVsdGEsXG4gICAgICAgIHpyQnlUb3VjaDogZXZlbnQuenJCeVRvdWNoLFxuICAgICAgICB3aGljaDogZXZlbnQud2hpY2gsXG4gICAgICAgIHN0b3A6IHN0b3BFdmVudFxuICAgIH07XG59XG5mdW5jdGlvbiBzdG9wRXZlbnQoKSB7XG4gICAgZXZlbnRUb29sLnN0b3AodGhpcy5ldmVudCk7XG59XG52YXIgRW1wdHlQcm94eSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVtcHR5UHJveHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1wdHlQcm94eSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhbmRsZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEVtcHR5UHJveHkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgRW1wdHlQcm94eS5wcm90b3R5cGUuc2V0Q3Vyc29yID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBFbXB0eVByb3h5O1xufShFdmVudGZ1bCkpO1xudmFyIEhvdmVyZWRSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhvdmVyZWRSZXN1bHQoeCwgeSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbiAgICByZXR1cm4gSG92ZXJlZFJlc3VsdDtcbn0oKSk7XG52YXIgaGFuZGxlck5hbWVzID0gW1xuICAgICdjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JyxcbiAgICAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J1xuXTtcbnZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbnZhciBIYW5kbGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGFuZGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIYW5kbGVyKHN0b3JhZ2UsIHBhaW50ZXIsIHByb3h5LCBwYWludGVyUm9vdCwgcG9pbnRlclNpemUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2hvdmVyZWQgPSBuZXcgSG92ZXJlZFJlc3VsdCgwLCAwKTtcbiAgICAgICAgX3RoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgICAgIF90aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuICAgICAgICBfdGhpcy5wYWludGVyUm9vdCA9IHBhaW50ZXJSb290O1xuICAgICAgICBfdGhpcy5fcG9pbnRlclNpemUgPSBwb2ludGVyU2l6ZTtcbiAgICAgICAgcHJveHkgPSBwcm94eSB8fCBuZXcgRW1wdHlQcm94eSgpO1xuICAgICAgICBfdGhpcy5wcm94eSA9IG51bGw7XG4gICAgICAgIF90aGlzLnNldEhhbmRsZXJQcm94eShwcm94eSk7XG4gICAgICAgIF90aGlzLl9kcmFnZ2luZ01nciA9IG5ldyBEcmFnZ2FibGUoX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEhhbmRsZXIucHJvdG90eXBlLnNldEhhbmRsZXJQcm94eSA9IGZ1bmN0aW9uIChwcm94eSkge1xuICAgICAgICBpZiAodGhpcy5wcm94eSkge1xuICAgICAgICAgICAgdGhpcy5wcm94eS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3h5KSB7XG4gICAgICAgICAgICB1dGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHByb3h5Lm9uICYmIHByb3h5Lm9uKG5hbWUsIHRoaXNbbmFtZV0sIHRoaXMpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICBwcm94eS5oYW5kbGVyID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3h5ID0gcHJveHk7XG4gICAgfTtcbiAgICBIYW5kbGVyLnByb3RvdHlwZS5tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHggPSBldmVudC56clg7XG4gICAgICAgIHZhciB5ID0gZXZlbnQuenJZO1xuICAgICAgICB2YXIgaXNPdXRzaWRlID0gaXNPdXRzaWRlQm91bmRhcnkodGhpcywgeCwgeSk7XG4gICAgICAgIHZhciBsYXN0SG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQ7XG4gICAgICAgIHZhciBsYXN0SG92ZXJlZFRhcmdldCA9IGxhc3RIb3ZlcmVkLnRhcmdldDtcbiAgICAgICAgaWYgKGxhc3RIb3ZlcmVkVGFyZ2V0ICYmICFsYXN0SG92ZXJlZFRhcmdldC5fX3pyKSB7XG4gICAgICAgICAgICBsYXN0SG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKGxhc3RIb3ZlcmVkLngsIGxhc3RIb3ZlcmVkLnkpO1xuICAgICAgICAgICAgbGFzdEhvdmVyZWRUYXJnZXQgPSBsYXN0SG92ZXJlZC50YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkID0gaXNPdXRzaWRlID8gbmV3IEhvdmVyZWRSZXN1bHQoeCwgeSkgOiB0aGlzLmZpbmRIb3Zlcih4LCB5KTtcbiAgICAgICAgdmFyIGhvdmVyZWRUYXJnZXQgPSBob3ZlcmVkLnRhcmdldDtcbiAgICAgICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcbiAgICAgICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihob3ZlcmVkVGFyZ2V0ID8gaG92ZXJlZFRhcmdldC5jdXJzb3IgOiAnZGVmYXVsdCcpO1xuICAgICAgICBpZiAobGFzdEhvdmVyZWRUYXJnZXQgJiYgaG92ZXJlZFRhcmdldCAhPT0gbGFzdEhvdmVyZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQobGFzdEhvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW1vdmUnLCBldmVudCk7XG4gICAgICAgIGlmIChob3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW92ZXInLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhhbmRsZXIucHJvdG90eXBlLm1vdXNlb3V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudENvbnRyb2wgPSBldmVudC56ckV2ZW50Q29udHJvbDtcbiAgICAgICAgaWYgKGV2ZW50Q29udHJvbCAhPT0gJ29ubHlfZ2xvYmFsb3V0Jykge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudCh0aGlzLl9ob3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50Q29udHJvbCAhPT0gJ25vX2dsb2JhbG91dCcpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZ2xvYmFsb3V0JywgeyB0eXBlOiAnZ2xvYmFsb3V0JywgZXZlbnQ6IGV2ZW50IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIYW5kbGVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2hvdmVyZWQgPSBuZXcgSG92ZXJlZFJlc3VsdCgwLCAwKTtcbiAgICB9O1xuICAgIEhhbmRsZXIucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcmdzKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpc1tldmVudE5hbWVdO1xuICAgICAgICBoYW5kbGVyICYmIGhhbmRsZXIuY2FsbCh0aGlzLCBldmVudEFyZ3MpO1xuICAgIH07XG4gICAgSGFuZGxlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm94eS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IG51bGw7XG4gICAgICAgIHRoaXMucHJveHkgPSBudWxsO1xuICAgICAgICB0aGlzLnBhaW50ZXIgPSBudWxsO1xuICAgIH07XG4gICAgSGFuZGxlci5wcm90b3R5cGUuc2V0Q3Vyc29yU3R5bGUgPSBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICAgICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcbiAgICAgICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihjdXJzb3JTdHlsZSk7XG4gICAgfTtcbiAgICBIYW5kbGVyLnByb3RvdHlwZS5kaXNwYXRjaFRvRWxlbWVudCA9IGZ1bmN0aW9uICh0YXJnZXRJbmZvLCBldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgICAgIHRhcmdldEluZm8gPSB0YXJnZXRJbmZvIHx8IHt9O1xuICAgICAgICB2YXIgZWwgPSB0YXJnZXRJbmZvLnRhcmdldDtcbiAgICAgICAgaWYgKGVsICYmIGVsLnNpbGVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudEtleSA9ICgnb24nICsgZXZlbnROYW1lKTtcbiAgICAgICAgdmFyIGV2ZW50UGFja2V0ID0gbWFrZUV2ZW50UGFja2V0KGV2ZW50TmFtZSwgdGFyZ2V0SW5mbywgZXZlbnQpO1xuICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgIGVsW2V2ZW50S2V5XVxuICAgICAgICAgICAgICAgICYmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUgPSAhIWVsW2V2ZW50S2V5XS5jYWxsKGVsLCBldmVudFBhY2tldCkpO1xuICAgICAgICAgICAgZWwudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgIGVsID0gZWwuX19ob3N0VGFyZ2V0ID8gZWwuX19ob3N0VGFyZ2V0IDogZWwucGFyZW50O1xuICAgICAgICAgICAgaWYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wYWludGVyICYmIHRoaXMucGFpbnRlci5lYWNoT3RoZXJMYXllcikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlci5lYWNoT3RoZXJMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAobGF5ZXJbZXZlbnRLZXldKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJbZXZlbnRLZXldLmNhbGwobGF5ZXIsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIudHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBIYW5kbGVyLnByb3RvdHlwZS5maW5kSG92ZXIgPSBmdW5jdGlvbiAoeCwgeSwgZXhjbHVkZSkge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpO1xuICAgICAgICB2YXIgb3V0ID0gbmV3IEhvdmVyZWRSZXN1bHQoeCwgeSk7XG4gICAgICAgIHNldEhvdmVyVGFyZ2V0KGxpc3QsIG91dCwgeCwgeSwgZXhjbHVkZSk7XG4gICAgICAgIGlmICh0aGlzLl9wb2ludGVyU2l6ZSAmJiAhb3V0LnRhcmdldCkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBwb2ludGVyU2l6ZSA9IHRoaXMuX3BvaW50ZXJTaXplO1xuICAgICAgICAgICAgdmFyIHRhcmdldFNpemVIYWxmID0gcG9pbnRlclNpemUgLyAyO1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCh4IC0gdGFyZ2V0U2l6ZUhhbGYsIHkgLSB0YXJnZXRTaXplSGFsZiwgcG9pbnRlclNpemUsIHBvaW50ZXJTaXplKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZWwgIT09IGV4Y2x1ZGVcbiAgICAgICAgICAgICAgICAgICAgJiYgIWVsLmlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAmJiAhZWwuaWdub3JlQ29hcnNlUG9pbnRlclxuICAgICAgICAgICAgICAgICAgICAmJiAoIWVsLnBhcmVudCB8fCAhZWwucGFyZW50Lmlnbm9yZUNvYXJzZVBvaW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuY29weShlbC5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodG1wUmVjdC5pbnRlcnNlY3QocG9pbnRlclJlY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJTdGVwID0gNDtcbiAgICAgICAgICAgICAgICB2YXIgdGhldGFTdGVwID0gTWF0aC5QSSAvIDEyO1xuICAgICAgICAgICAgICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHRhcmdldFNpemVIYWxmOyByICs9IHJTdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRoZXRhID0gMDsgdGhldGEgPCBQSTI7IHRoZXRhICs9IHRoZXRhU3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0geCArIHIgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSB5ICsgciAqIE1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEhvdmVyVGFyZ2V0KGNhbmRpZGF0ZXMsIG91dCwgeDEsIHkxLCBleGNsdWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXQudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgSGFuZGxlci5wcm90b3R5cGUucHJvY2Vzc0dlc3R1cmUgPSBmdW5jdGlvbiAoZXZlbnQsIHN0YWdlKSB7XG4gICAgICAgIGlmICghdGhpcy5fZ2VzdHVyZU1ncikge1xuICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZU1nciA9IG5ldyBHZXN0dXJlTWdyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdlc3R1cmVNZ3IgPSB0aGlzLl9nZXN0dXJlTWdyO1xuICAgICAgICBzdGFnZSA9PT0gJ3N0YXJ0JyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7XG4gICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IGdlc3R1cmVNZ3IucmVjb2duaXplKGV2ZW50LCB0aGlzLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCkudGFyZ2V0LCB0aGlzLnByb3h5LmRvbSk7XG4gICAgICAgIHN0YWdlID09PSAnZW5kJyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7XG4gICAgICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXN0dXJlSW5mby50eXBlO1xuICAgICAgICAgICAgZXZlbnQuZ2VzdHVyZUV2ZW50ID0gdHlwZTtcbiAgICAgICAgICAgIHZhciByZXMgPSBuZXcgSG92ZXJlZFJlc3VsdCgpO1xuICAgICAgICAgICAgcmVzLnRhcmdldCA9IGdlc3R1cmVJbmZvLnRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocmVzLCB0eXBlLCBnZXN0dXJlSW5mby5ldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBIYW5kbGVyO1xufShFdmVudGZ1bCkpO1xudXRpbC5lYWNoKFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2V3aGVlbCcsICdkYmxjbGljaycsICdjb250ZXh0bWVudSddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIEhhbmRsZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB4ID0gZXZlbnQuenJYO1xuICAgICAgICB2YXIgeSA9IGV2ZW50LnpyWTtcbiAgICAgICAgdmFyIGlzT3V0c2lkZSA9IGlzT3V0c2lkZUJvdW5kYXJ5KHRoaXMsIHgsIHkpO1xuICAgICAgICB2YXIgaG92ZXJlZDtcbiAgICAgICAgdmFyIGhvdmVyZWRUYXJnZXQ7XG4gICAgICAgIGlmIChuYW1lICE9PSAnbW91c2V1cCcgfHwgIWlzT3V0c2lkZSkge1xuICAgICAgICAgICAgaG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKHgsIHkpO1xuICAgICAgICAgICAgaG92ZXJlZFRhcmdldCA9IGhvdmVyZWQudGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgdGhpcy5fZG93bkVsID0gaG92ZXJlZFRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuX2Rvd25Qb2ludCA9IFtldmVudC56clgsIGV2ZW50LnpyWV07XG4gICAgICAgICAgICB0aGlzLl91cEVsID0gaG92ZXJlZFRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnbW91c2V1cCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwRWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kb3duRWwgIT09IHRoaXMuX3VwRWxcbiAgICAgICAgICAgICAgICB8fCAhdGhpcy5fZG93blBvaW50XG4gICAgICAgICAgICAgICAgfHwgdmVjMi5kaXN0KHRoaXMuX2Rvd25Qb2ludCwgW2V2ZW50LnpyWCwgZXZlbnQuenJZXSkgPiA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZG93blBvaW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsIG5hbWUsIGV2ZW50KTtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBpc0hvdmVyKGRpc3BsYXlhYmxlLCB4LCB5KSB7XG4gICAgaWYgKGRpc3BsYXlhYmxlW2Rpc3BsYXlhYmxlLnJlY3RIb3ZlciA/ICdyZWN0Q29udGFpbicgOiAnY29udGFpbiddKHgsIHkpKSB7XG4gICAgICAgIHZhciBlbCA9IGRpc3BsYXlhYmxlO1xuICAgICAgICB2YXIgaXNTaWxlbnQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBpZ25vcmVDbGlwID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsLmlnbm9yZUNsaXApIHtcbiAgICAgICAgICAgICAgICBpZ25vcmVDbGlwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaWdub3JlQ2xpcCkge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwUGF0aCA9IGVsLmdldENsaXBQYXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsaXBQYXRoICYmICFjbGlwUGF0aC5jb250YWluKHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWwuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgaXNTaWxlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhvc3RFbCA9IGVsLl9faG9zdFRhcmdldDtcbiAgICAgICAgICAgIGVsID0gaG9zdEVsID8gaG9zdEVsIDogZWwucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1NpbGVudCA/IFNJTEVOVCA6IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNldEhvdmVyVGFyZ2V0KGxpc3QsIG91dCwgeCwgeSwgZXhjbHVkZSkge1xuICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBlbCA9IGxpc3RbaV07XG4gICAgICAgIHZhciBob3ZlckNoZWNrUmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICBpZiAoZWwgIT09IGV4Y2x1ZGVcbiAgICAgICAgICAgICYmICFlbC5pZ25vcmVcbiAgICAgICAgICAgICYmIChob3ZlckNoZWNrUmVzdWx0ID0gaXNIb3ZlcihlbCwgeCwgeSkpKSB7XG4gICAgICAgICAgICAhb3V0LnRvcFRhcmdldCAmJiAob3V0LnRvcFRhcmdldCA9IGVsKTtcbiAgICAgICAgICAgIGlmIChob3ZlckNoZWNrUmVzdWx0ICE9PSBTSUxFTlQpIHtcbiAgICAgICAgICAgICAgICBvdXQudGFyZ2V0ID0gZWw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc091dHNpZGVCb3VuZGFyeShoYW5kbGVySW5zdGFuY2UsIHgsIHkpIHtcbiAgICB2YXIgcGFpbnRlciA9IGhhbmRsZXJJbnN0YW5jZS5wYWludGVyO1xuICAgIHJldHVybiB4IDwgMCB8fCB4ID4gcGFpbnRlci5nZXRXaWR0aCgpIHx8IHkgPCAwIHx8IHkgPiBwYWludGVyLmdldEhlaWdodCgpO1xufVxuZXhwb3J0IGRlZmF1bHQgSGFuZGxlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///56494\n")},62454:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony export PRESERVED_NORMAL_STATE */\n/* harmony import */ var _core_Transformable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92836);\n/* harmony import */ var _animation_Animator_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(21756);\n/* harmony import */ var _core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29308);\n/* harmony import */ var _core_Eventful_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(57861);\n/* harmony import */ var _contain_text_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45558);\n/* harmony import */ var _core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73098);\n/* harmony import */ var _tool_color_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(47698);\n/* harmony import */ var _graphic_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56448);\n\n\n\n\n\n\n\n\n\nvar PRESERVED_NORMAL_STATE = '__zr_normal__';\nvar PRIMARY_STATES_KEYS = _core_Transformable_js__WEBPACK_IMPORTED_MODULE_0__/* .TRANSFORMABLE_PROPS */ .Wx.concat(['ignore']);\nvar DEFAULT_ANIMATABLE_MAP = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.reduce)(_core_Transformable_js__WEBPACK_IMPORTED_MODULE_0__/* .TRANSFORMABLE_PROPS */ .Wx, function (obj, key) {\n    obj[key] = true;\n    return obj;\n}, { ignore: false });\nvar tmpTextPosCalcRes = {};\nvar tmpBoundingRect = new _core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A(0, 0, 0, 0);\nvar Element = (function () {\n    function Element(props) {\n        this.id = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.guid)();\n        this.animators = [];\n        this.currentStates = [];\n        this.states = {};\n        this._init(props);\n    }\n    Element.prototype._init = function (props) {\n        this.attr(props);\n    };\n    Element.prototype.drift = function (dx, dy, e) {\n        switch (this.draggable) {\n            case 'horizontal':\n                dy = 0;\n                break;\n            case 'vertical':\n                dx = 0;\n                break;\n        }\n        var m = this.transform;\n        if (!m) {\n            m = this.transform = [1, 0, 0, 1, 0, 0];\n        }\n        m[4] += dx;\n        m[5] += dy;\n        this.decomposeTransform();\n        this.markRedraw();\n    };\n    Element.prototype.beforeUpdate = function () { };\n    Element.prototype.afterUpdate = function () { };\n    Element.prototype.update = function () {\n        this.updateTransform();\n        if (this.__dirty) {\n            this.updateInnerText();\n        }\n    };\n    Element.prototype.updateInnerText = function (forceUpdate) {\n        var textEl = this._textContent;\n        if (textEl && (!textEl.ignore || forceUpdate)) {\n            if (!this.textConfig) {\n                this.textConfig = {};\n            }\n            var textConfig = this.textConfig;\n            var isLocal = textConfig.local;\n            var innerTransformable = textEl.innerTransformable;\n            var textAlign = void 0;\n            var textVerticalAlign = void 0;\n            var textStyleChanged = false;\n            innerTransformable.parent = isLocal ? this : null;\n            var innerOrigin = false;\n            innerTransformable.copyTransform(textEl);\n            if (textConfig.position != null) {\n                var layoutRect = tmpBoundingRect;\n                if (textConfig.layoutRect) {\n                    layoutRect.copy(textConfig.layoutRect);\n                }\n                else {\n                    layoutRect.copy(this.getBoundingRect());\n                }\n                if (!isLocal) {\n                    layoutRect.applyTransform(this.transform);\n                }\n                if (this.calculateTextPosition) {\n                    this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);\n                }\n                else {\n                    (0,_contain_text_js__WEBPACK_IMPORTED_MODULE_3__/* .calculateTextPosition */ .X4)(tmpTextPosCalcRes, textConfig, layoutRect);\n                }\n                innerTransformable.x = tmpTextPosCalcRes.x;\n                innerTransformable.y = tmpTextPosCalcRes.y;\n                textAlign = tmpTextPosCalcRes.align;\n                textVerticalAlign = tmpTextPosCalcRes.verticalAlign;\n                var textOrigin = textConfig.origin;\n                if (textOrigin && textConfig.rotation != null) {\n                    var relOriginX = void 0;\n                    var relOriginY = void 0;\n                    if (textOrigin === 'center') {\n                        relOriginX = layoutRect.width * 0.5;\n                        relOriginY = layoutRect.height * 0.5;\n                    }\n                    else {\n                        relOriginX = (0,_contain_text_js__WEBPACK_IMPORTED_MODULE_3__/* .parsePercent */ .lo)(textOrigin[0], layoutRect.width);\n                        relOriginY = (0,_contain_text_js__WEBPACK_IMPORTED_MODULE_3__/* .parsePercent */ .lo)(textOrigin[1], layoutRect.height);\n                    }\n                    innerOrigin = true;\n                    innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x);\n                    innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y);\n                }\n            }\n            if (textConfig.rotation != null) {\n                innerTransformable.rotation = textConfig.rotation;\n            }\n            var textOffset = textConfig.offset;\n            if (textOffset) {\n                innerTransformable.x += textOffset[0];\n                innerTransformable.y += textOffset[1];\n                if (!innerOrigin) {\n                    innerTransformable.originX = -textOffset[0];\n                    innerTransformable.originY = -textOffset[1];\n                }\n            }\n            var isInside = textConfig.inside == null\n                ? (typeof textConfig.position === 'string' && textConfig.position.indexOf('inside') >= 0)\n                : textConfig.inside;\n            var innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});\n            var textFill = void 0;\n            var textStroke = void 0;\n            var autoStroke = void 0;\n            if (isInside && this.canBeInsideText()) {\n                textFill = textConfig.insideFill;\n                textStroke = textConfig.insideStroke;\n                if (textFill == null || textFill === 'auto') {\n                    textFill = this.getInsideTextFill();\n                }\n                if (textStroke == null || textStroke === 'auto') {\n                    textStroke = this.getInsideTextStroke(textFill);\n                    autoStroke = true;\n                }\n            }\n            else {\n                textFill = textConfig.outsideFill;\n                textStroke = textConfig.outsideStroke;\n                if (textFill == null || textFill === 'auto') {\n                    textFill = this.getOutsideFill();\n                }\n                if (textStroke == null || textStroke === 'auto') {\n                    textStroke = this.getOutsideStroke(textFill);\n                    autoStroke = true;\n                }\n            }\n            textFill = textFill || '#000';\n            if (textFill !== innerTextDefaultStyle.fill\n                || textStroke !== innerTextDefaultStyle.stroke\n                || autoStroke !== innerTextDefaultStyle.autoStroke\n                || textAlign !== innerTextDefaultStyle.align\n                || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {\n                textStyleChanged = true;\n                innerTextDefaultStyle.fill = textFill;\n                innerTextDefaultStyle.stroke = textStroke;\n                innerTextDefaultStyle.autoStroke = autoStroke;\n                innerTextDefaultStyle.align = textAlign;\n                innerTextDefaultStyle.verticalAlign = textVerticalAlign;\n                textEl.setDefaultTextStyle(innerTextDefaultStyle);\n            }\n            textEl.__dirty |= _graphic_constants_js__WEBPACK_IMPORTED_MODULE_4__/* .REDRAW_BIT */ .M;\n            if (textStyleChanged) {\n                textEl.dirtyStyle(true);\n            }\n        }\n    };\n    Element.prototype.canBeInsideText = function () {\n        return true;\n    };\n    Element.prototype.getInsideTextFill = function () {\n        return '#fff';\n    };\n    Element.prototype.getInsideTextStroke = function (textFill) {\n        return '#000';\n    };\n    Element.prototype.getOutsideFill = function () {\n        return this.__zr && this.__zr.isDarkMode() ? _config_js__WEBPACK_IMPORTED_MODULE_5__/* .LIGHT_LABEL_COLOR */ .el : _config_js__WEBPACK_IMPORTED_MODULE_5__/* .DARK_LABEL_COLOR */ ._S;\n    };\n    Element.prototype.getOutsideStroke = function (textFill) {\n        var backgroundColor = this.__zr && this.__zr.getBackgroundColor();\n        var colorArr = typeof backgroundColor === 'string' && (0,_tool_color_js__WEBPACK_IMPORTED_MODULE_6__.parse)(backgroundColor);\n        if (!colorArr) {\n            colorArr = [255, 255, 255, 1];\n        }\n        var alpha = colorArr[3];\n        var isDark = this.__zr.isDarkMode();\n        for (var i = 0; i < 3; i++) {\n            colorArr[i] = colorArr[i] * alpha + (isDark ? 0 : 255) * (1 - alpha);\n        }\n        colorArr[3] = 1;\n        return (0,_tool_color_js__WEBPACK_IMPORTED_MODULE_6__.stringify)(colorArr, 'rgba');\n    };\n    Element.prototype.traverse = function (cb, context) { };\n    Element.prototype.attrKV = function (key, value) {\n        if (key === 'textConfig') {\n            this.setTextConfig(value);\n        }\n        else if (key === 'textContent') {\n            this.setTextContent(value);\n        }\n        else if (key === 'clipPath') {\n            this.setClipPath(value);\n        }\n        else if (key === 'extra') {\n            this.extra = this.extra || {};\n            (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)(this.extra, value);\n        }\n        else {\n            this[key] = value;\n        }\n    };\n    Element.prototype.hide = function () {\n        this.ignore = true;\n        this.markRedraw();\n    };\n    Element.prototype.show = function () {\n        this.ignore = false;\n        this.markRedraw();\n    };\n    Element.prototype.attr = function (keyOrObj, value) {\n        if (typeof keyOrObj === 'string') {\n            this.attrKV(keyOrObj, value);\n        }\n        else if ((0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(keyOrObj)) {\n            var obj = keyOrObj;\n            var keysArr = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.keys)(obj);\n            for (var i = 0; i < keysArr.length; i++) {\n                var key = keysArr[i];\n                this.attrKV(key, keyOrObj[key]);\n            }\n        }\n        this.markRedraw();\n        return this;\n    };\n    Element.prototype.saveCurrentToNormalState = function (toState) {\n        this._innerSaveToNormal(toState);\n        var normalState = this._normalState;\n        for (var i = 0; i < this.animators.length; i++) {\n            var animator = this.animators[i];\n            var fromStateTransition = animator.__fromStateTransition;\n            if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {\n                continue;\n            }\n            var targetName = animator.targetName;\n            var target = targetName\n                ? normalState[targetName] : normalState;\n            animator.saveTo(target);\n        }\n    };\n    Element.prototype._innerSaveToNormal = function (toState) {\n        var normalState = this._normalState;\n        if (!normalState) {\n            normalState = this._normalState = {};\n        }\n        if (toState.textConfig && !normalState.textConfig) {\n            normalState.textConfig = this.textConfig;\n        }\n        this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);\n    };\n    Element.prototype._savePrimaryToNormal = function (toState, normalState, primaryKeys) {\n        for (var i = 0; i < primaryKeys.length; i++) {\n            var key = primaryKeys[i];\n            if (toState[key] != null && !(key in normalState)) {\n                normalState[key] = this[key];\n            }\n        }\n    };\n    Element.prototype.hasState = function () {\n        return this.currentStates.length > 0;\n    };\n    Element.prototype.getState = function (name) {\n        return this.states[name];\n    };\n    Element.prototype.ensureState = function (name) {\n        var states = this.states;\n        if (!states[name]) {\n            states[name] = {};\n        }\n        return states[name];\n    };\n    Element.prototype.clearStates = function (noAnimation) {\n        this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);\n    };\n    Element.prototype.useState = function (stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {\n        var toNormalState = stateName === PRESERVED_NORMAL_STATE;\n        var hasStates = this.hasState();\n        if (!hasStates && toNormalState) {\n            return;\n        }\n        var currentStates = this.currentStates;\n        var animationCfg = this.stateTransition;\n        if ((0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.indexOf)(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {\n            return;\n        }\n        var state;\n        if (this.stateProxy && !toNormalState) {\n            state = this.stateProxy(stateName);\n        }\n        if (!state) {\n            state = (this.states && this.states[stateName]);\n        }\n        if (!state && !toNormalState) {\n            (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.logError)(\"State \" + stateName + \" not exists.\");\n            return;\n        }\n        if (!toNormalState) {\n            this.saveCurrentToNormalState(state);\n        }\n        var useHoverLayer = !!((state && state.hoverLayer) || forceUseHoverLayer);\n        if (useHoverLayer) {\n            this._toggleHoverLayerFlag(true);\n        }\n        this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);\n        var textContent = this._textContent;\n        var textGuide = this._textGuide;\n        if (textContent) {\n            textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);\n        }\n        if (textGuide) {\n            textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);\n        }\n        if (toNormalState) {\n            this.currentStates = [];\n            this._normalState = {};\n        }\n        else {\n            if (!keepCurrentStates) {\n                this.currentStates = [stateName];\n            }\n            else {\n                this.currentStates.push(stateName);\n            }\n        }\n        this._updateAnimationTargets();\n        this.markRedraw();\n        if (!useHoverLayer && this.__inHover) {\n            this._toggleHoverLayerFlag(false);\n            this.__dirty &= ~_graphic_constants_js__WEBPACK_IMPORTED_MODULE_4__/* .REDRAW_BIT */ .M;\n        }\n        return state;\n    };\n    Element.prototype.useStates = function (states, noAnimation, forceUseHoverLayer) {\n        if (!states.length) {\n            this.clearStates();\n        }\n        else {\n            var stateObjects = [];\n            var currentStates = this.currentStates;\n            var len = states.length;\n            var notChange = len === currentStates.length;\n            if (notChange) {\n                for (var i = 0; i < len; i++) {\n                    if (states[i] !== currentStates[i]) {\n                        notChange = false;\n                        break;\n                    }\n                }\n            }\n            if (notChange) {\n                return;\n            }\n            for (var i = 0; i < len; i++) {\n                var stateName = states[i];\n                var stateObj = void 0;\n                if (this.stateProxy) {\n                    stateObj = this.stateProxy(stateName, states);\n                }\n                if (!stateObj) {\n                    stateObj = this.states[stateName];\n                }\n                if (stateObj) {\n                    stateObjects.push(stateObj);\n                }\n            }\n            var lastStateObj = stateObjects[len - 1];\n            var useHoverLayer = !!((lastStateObj && lastStateObj.hoverLayer) || forceUseHoverLayer);\n            if (useHoverLayer) {\n                this._toggleHoverLayerFlag(true);\n            }\n            var mergedState = this._mergeStates(stateObjects);\n            var animationCfg = this.stateTransition;\n            this.saveCurrentToNormalState(mergedState);\n            this._applyStateObj(states.join(','), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);\n            var textContent = this._textContent;\n            var textGuide = this._textGuide;\n            if (textContent) {\n                textContent.useStates(states, noAnimation, useHoverLayer);\n            }\n            if (textGuide) {\n                textGuide.useStates(states, noAnimation, useHoverLayer);\n            }\n            this._updateAnimationTargets();\n            this.currentStates = states.slice();\n            this.markRedraw();\n            if (!useHoverLayer && this.__inHover) {\n                this._toggleHoverLayerFlag(false);\n                this.__dirty &= ~_graphic_constants_js__WEBPACK_IMPORTED_MODULE_4__/* .REDRAW_BIT */ .M;\n            }\n        }\n    };\n    Element.prototype.isSilent = function () {\n        var isSilent = this.silent;\n        var ancestor = this.parent;\n        while (!isSilent && ancestor) {\n            if (ancestor.silent) {\n                isSilent = true;\n                break;\n            }\n            ancestor = ancestor.parent;\n        }\n        return isSilent;\n    };\n    Element.prototype._updateAnimationTargets = function () {\n        for (var i = 0; i < this.animators.length; i++) {\n            var animator = this.animators[i];\n            if (animator.targetName) {\n                animator.changeTarget(this[animator.targetName]);\n            }\n        }\n    };\n    Element.prototype.removeState = function (state) {\n        var idx = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.indexOf)(this.currentStates, state);\n        if (idx >= 0) {\n            var currentStates = this.currentStates.slice();\n            currentStates.splice(idx, 1);\n            this.useStates(currentStates);\n        }\n    };\n    Element.prototype.replaceState = function (oldState, newState, forceAdd) {\n        var currentStates = this.currentStates.slice();\n        var idx = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.indexOf)(currentStates, oldState);\n        var newStateExists = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.indexOf)(currentStates, newState) >= 0;\n        if (idx >= 0) {\n            if (!newStateExists) {\n                currentStates[idx] = newState;\n            }\n            else {\n                currentStates.splice(idx, 1);\n            }\n        }\n        else if (forceAdd && !newStateExists) {\n            currentStates.push(newState);\n        }\n        this.useStates(currentStates);\n    };\n    Element.prototype.toggleState = function (state, enable) {\n        if (enable) {\n            this.useState(state, true);\n        }\n        else {\n            this.removeState(state);\n        }\n    };\n    Element.prototype._mergeStates = function (states) {\n        var mergedState = {};\n        var mergedTextConfig;\n        for (var i = 0; i < states.length; i++) {\n            var state = states[i];\n            (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)(mergedState, state);\n            if (state.textConfig) {\n                mergedTextConfig = mergedTextConfig || {};\n                (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)(mergedTextConfig, state.textConfig);\n            }\n        }\n        if (mergedTextConfig) {\n            mergedState.textConfig = mergedTextConfig;\n        }\n        return mergedState;\n    };\n    Element.prototype._applyStateObj = function (stateName, state, normalState, keepCurrentStates, transition, animationCfg) {\n        var needsRestoreToNormal = !(state && keepCurrentStates);\n        if (state && state.textConfig) {\n            this.textConfig = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, keepCurrentStates ? this.textConfig : normalState.textConfig);\n            (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)(this.textConfig, state.textConfig);\n        }\n        else if (needsRestoreToNormal) {\n            if (normalState.textConfig) {\n                this.textConfig = normalState.textConfig;\n            }\n        }\n        var transitionTarget = {};\n        var hasTransition = false;\n        for (var i = 0; i < PRIMARY_STATES_KEYS.length; i++) {\n            var key = PRIMARY_STATES_KEYS[i];\n            var propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key];\n            if (state && state[key] != null) {\n                if (propNeedsTransition) {\n                    hasTransition = true;\n                    transitionTarget[key] = state[key];\n                }\n                else {\n                    this[key] = state[key];\n                }\n            }\n            else if (needsRestoreToNormal) {\n                if (normalState[key] != null) {\n                    if (propNeedsTransition) {\n                        hasTransition = true;\n                        transitionTarget[key] = normalState[key];\n                    }\n                    else {\n                        this[key] = normalState[key];\n                    }\n                }\n            }\n        }\n        if (!transition) {\n            for (var i = 0; i < this.animators.length; i++) {\n                var animator = this.animators[i];\n                var targetName = animator.targetName;\n                if (!animator.getLoop()) {\n                    animator.__changeFinalValue(targetName\n                        ? (state || normalState)[targetName]\n                        : (state || normalState));\n                }\n            }\n        }\n        if (hasTransition) {\n            this._transitionState(stateName, transitionTarget, animationCfg);\n        }\n    };\n    Element.prototype._attachComponent = function (componentEl) {\n        if (componentEl.__zr && !componentEl.__hostTarget) {\n            if (false) {}\n            return;\n        }\n        if (componentEl === this) {\n            if (false) {}\n            return;\n        }\n        var zr = this.__zr;\n        if (zr) {\n            componentEl.addSelfToZr(zr);\n        }\n        componentEl.__zr = zr;\n        componentEl.__hostTarget = this;\n    };\n    Element.prototype._detachComponent = function (componentEl) {\n        if (componentEl.__zr) {\n            componentEl.removeSelfFromZr(componentEl.__zr);\n        }\n        componentEl.__zr = null;\n        componentEl.__hostTarget = null;\n    };\n    Element.prototype.getClipPath = function () {\n        return this._clipPath;\n    };\n    Element.prototype.setClipPath = function (clipPath) {\n        if (this._clipPath && this._clipPath !== clipPath) {\n            this.removeClipPath();\n        }\n        this._attachComponent(clipPath);\n        this._clipPath = clipPath;\n        this.markRedraw();\n    };\n    Element.prototype.removeClipPath = function () {\n        var clipPath = this._clipPath;\n        if (clipPath) {\n            this._detachComponent(clipPath);\n            this._clipPath = null;\n            this.markRedraw();\n        }\n    };\n    Element.prototype.getTextContent = function () {\n        return this._textContent;\n    };\n    Element.prototype.setTextContent = function (textEl) {\n        var previousTextContent = this._textContent;\n        if (previousTextContent === textEl) {\n            return;\n        }\n        if (previousTextContent && previousTextContent !== textEl) {\n            this.removeTextContent();\n        }\n        if (false) {}\n        textEl.innerTransformable = new _core_Transformable_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Ay();\n        this._attachComponent(textEl);\n        this._textContent = textEl;\n        this.markRedraw();\n    };\n    Element.prototype.setTextConfig = function (cfg) {\n        if (!this.textConfig) {\n            this.textConfig = {};\n        }\n        (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)(this.textConfig, cfg);\n        this.markRedraw();\n    };\n    Element.prototype.removeTextConfig = function () {\n        this.textConfig = null;\n        this.markRedraw();\n    };\n    Element.prototype.removeTextContent = function () {\n        var textEl = this._textContent;\n        if (textEl) {\n            textEl.innerTransformable = null;\n            this._detachComponent(textEl);\n            this._textContent = null;\n            this._innerTextDefaultStyle = null;\n            this.markRedraw();\n        }\n    };\n    Element.prototype.getTextGuideLine = function () {\n        return this._textGuide;\n    };\n    Element.prototype.setTextGuideLine = function (guideLine) {\n        if (this._textGuide && this._textGuide !== guideLine) {\n            this.removeTextGuideLine();\n        }\n        this._attachComponent(guideLine);\n        this._textGuide = guideLine;\n        this.markRedraw();\n    };\n    Element.prototype.removeTextGuideLine = function () {\n        var textGuide = this._textGuide;\n        if (textGuide) {\n            this._detachComponent(textGuide);\n            this._textGuide = null;\n            this.markRedraw();\n        }\n    };\n    Element.prototype.markRedraw = function () {\n        this.__dirty |= _graphic_constants_js__WEBPACK_IMPORTED_MODULE_4__/* .REDRAW_BIT */ .M;\n        var zr = this.__zr;\n        if (zr) {\n            if (this.__inHover) {\n                zr.refreshHover();\n            }\n            else {\n                zr.refresh();\n            }\n        }\n        if (this.__hostTarget) {\n            this.__hostTarget.markRedraw();\n        }\n    };\n    Element.prototype.dirty = function () {\n        this.markRedraw();\n    };\n    Element.prototype._toggleHoverLayerFlag = function (inHover) {\n        this.__inHover = inHover;\n        var textContent = this._textContent;\n        var textGuide = this._textGuide;\n        if (textContent) {\n            textContent.__inHover = inHover;\n        }\n        if (textGuide) {\n            textGuide.__inHover = inHover;\n        }\n    };\n    Element.prototype.addSelfToZr = function (zr) {\n        if (this.__zr === zr) {\n            return;\n        }\n        this.__zr = zr;\n        var animators = this.animators;\n        if (animators) {\n            for (var i = 0; i < animators.length; i++) {\n                zr.animation.addAnimator(animators[i]);\n            }\n        }\n        if (this._clipPath) {\n            this._clipPath.addSelfToZr(zr);\n        }\n        if (this._textContent) {\n            this._textContent.addSelfToZr(zr);\n        }\n        if (this._textGuide) {\n            this._textGuide.addSelfToZr(zr);\n        }\n    };\n    Element.prototype.removeSelfFromZr = function (zr) {\n        if (!this.__zr) {\n            return;\n        }\n        this.__zr = null;\n        var animators = this.animators;\n        if (animators) {\n            for (var i = 0; i < animators.length; i++) {\n                zr.animation.removeAnimator(animators[i]);\n            }\n        }\n        if (this._clipPath) {\n            this._clipPath.removeSelfFromZr(zr);\n        }\n        if (this._textContent) {\n            this._textContent.removeSelfFromZr(zr);\n        }\n        if (this._textGuide) {\n            this._textGuide.removeSelfFromZr(zr);\n        }\n    };\n    Element.prototype.animate = function (key, loop, allowDiscreteAnimation) {\n        var target = key ? this[key] : this;\n        if (false) {}\n        var animator = new _animation_Animator_js__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .A(target, loop, allowDiscreteAnimation);\n        key && (animator.targetName = key);\n        this.addAnimator(animator, key);\n        return animator;\n    };\n    Element.prototype.addAnimator = function (animator, key) {\n        var zr = this.__zr;\n        var el = this;\n        animator.during(function () {\n            el.updateDuringAnimation(key);\n        }).done(function () {\n            var animators = el.animators;\n            var idx = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.indexOf)(animators, animator);\n            if (idx >= 0) {\n                animators.splice(idx, 1);\n            }\n        });\n        this.animators.push(animator);\n        if (zr) {\n            zr.animation.addAnimator(animator);\n        }\n        zr && zr.wakeUp();\n    };\n    Element.prototype.updateDuringAnimation = function (key) {\n        this.markRedraw();\n    };\n    Element.prototype.stopAnimation = function (scope, forwardToLast) {\n        var animators = this.animators;\n        var len = animators.length;\n        var leftAnimators = [];\n        for (var i = 0; i < len; i++) {\n            var animator = animators[i];\n            if (!scope || scope === animator.scope) {\n                animator.stop(forwardToLast);\n            }\n            else {\n                leftAnimators.push(animator);\n            }\n        }\n        this.animators = leftAnimators;\n        return this;\n    };\n    Element.prototype.animateTo = function (target, cfg, animationProps) {\n        animateTo(this, target, cfg, animationProps);\n    };\n    Element.prototype.animateFrom = function (target, cfg, animationProps) {\n        animateTo(this, target, cfg, animationProps, true);\n    };\n    Element.prototype._transitionState = function (stateName, target, cfg, animationProps) {\n        var animators = animateTo(this, target, cfg, animationProps);\n        for (var i = 0; i < animators.length; i++) {\n            animators[i].__fromStateTransition = stateName;\n        }\n    };\n    Element.prototype.getBoundingRect = function () {\n        return null;\n    };\n    Element.prototype.getPaintRect = function () {\n        return null;\n    };\n    Element.initDefaultProps = (function () {\n        var elProto = Element.prototype;\n        elProto.type = 'element';\n        elProto.name = '';\n        elProto.ignore =\n            elProto.silent =\n                elProto.isGroup =\n                    elProto.draggable =\n                        elProto.dragging =\n                            elProto.ignoreClip =\n                                elProto.__inHover = false;\n        elProto.__dirty = _graphic_constants_js__WEBPACK_IMPORTED_MODULE_4__/* .REDRAW_BIT */ .M;\n        var logs = {};\n        function logDeprecatedError(key, xKey, yKey) {\n            if (!logs[key + xKey + yKey]) {\n                console.warn(\"DEPRECATED: '\" + key + \"' has been deprecated. use '\" + xKey + \"', '\" + yKey + \"' instead\");\n                logs[key + xKey + yKey] = true;\n            }\n        }\n        function createLegacyProperty(key, privateKey, xKey, yKey) {\n            Object.defineProperty(elProto, key, {\n                get: function () {\n                    if (false) {}\n                    if (!this[privateKey]) {\n                        var pos = this[privateKey] = [];\n                        enhanceArray(this, pos);\n                    }\n                    return this[privateKey];\n                },\n                set: function (pos) {\n                    if (false) {}\n                    this[xKey] = pos[0];\n                    this[yKey] = pos[1];\n                    this[privateKey] = pos;\n                    enhanceArray(this, pos);\n                }\n            });\n            function enhanceArray(self, pos) {\n                Object.defineProperty(pos, 0, {\n                    get: function () {\n                        return self[xKey];\n                    },\n                    set: function (val) {\n                        self[xKey] = val;\n                    }\n                });\n                Object.defineProperty(pos, 1, {\n                    get: function () {\n                        return self[yKey];\n                    },\n                    set: function (val) {\n                        self[yKey] = val;\n                    }\n                });\n            }\n        }\n        if (Object.defineProperty) {\n            createLegacyProperty('position', '_legacyPos', 'x', 'y');\n            createLegacyProperty('scale', '_legacyScale', 'scaleX', 'scaleY');\n            createLegacyProperty('origin', '_legacyOrigin', 'originX', 'originY');\n        }\n    })();\n    return Element;\n}());\n(0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.mixin)(Element, _core_Eventful_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .A);\n(0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.mixin)(Element, _core_Transformable_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Ay);\nfunction animateTo(animatable, target, cfg, animationProps, reverse) {\n    cfg = cfg || {};\n    var animators = [];\n    animateToShallow(animatable, '', animatable, target, cfg, animationProps, animators, reverse);\n    var finishCount = animators.length;\n    var doneHappened = false;\n    var cfgDone = cfg.done;\n    var cfgAborted = cfg.aborted;\n    var doneCb = function () {\n        doneHappened = true;\n        finishCount--;\n        if (finishCount <= 0) {\n            doneHappened\n                ? (cfgDone && cfgDone())\n                : (cfgAborted && cfgAborted());\n        }\n    };\n    var abortedCb = function () {\n        finishCount--;\n        if (finishCount <= 0) {\n            doneHappened\n                ? (cfgDone && cfgDone())\n                : (cfgAborted && cfgAborted());\n        }\n    };\n    if (!finishCount) {\n        cfgDone && cfgDone();\n    }\n    if (animators.length > 0 && cfg.during) {\n        animators[0].during(function (target, percent) {\n            cfg.during(percent);\n        });\n    }\n    for (var i = 0; i < animators.length; i++) {\n        var animator = animators[i];\n        if (doneCb) {\n            animator.done(doneCb);\n        }\n        if (abortedCb) {\n            animator.aborted(abortedCb);\n        }\n        if (cfg.force) {\n            animator.duration(cfg.duration);\n        }\n        animator.start(cfg.easing);\n    }\n    return animators;\n}\nfunction copyArrShallow(source, target, len) {\n    for (var i = 0; i < len; i++) {\n        source[i] = target[i];\n    }\n}\nfunction is2DArray(value) {\n    return (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArrayLike)(value[0]);\n}\nfunction copyValue(target, source, key) {\n    if ((0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArrayLike)(source[key])) {\n        if (!(0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArrayLike)(target[key])) {\n            target[key] = [];\n        }\n        if ((0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isTypedArray)(source[key])) {\n            var len = source[key].length;\n            if (target[key].length !== len) {\n                target[key] = new (source[key].constructor)(len);\n                copyArrShallow(target[key], source[key], len);\n            }\n        }\n        else {\n            var sourceArr = source[key];\n            var targetArr = target[key];\n            var len0 = sourceArr.length;\n            if (is2DArray(sourceArr)) {\n                var len1 = sourceArr[0].length;\n                for (var i = 0; i < len0; i++) {\n                    if (!targetArr[i]) {\n                        targetArr[i] = Array.prototype.slice.call(sourceArr[i]);\n                    }\n                    else {\n                        copyArrShallow(targetArr[i], sourceArr[i], len1);\n                    }\n                }\n            }\n            else {\n                copyArrShallow(targetArr, sourceArr, len0);\n            }\n            targetArr.length = sourceArr.length;\n        }\n    }\n    else {\n        target[key] = source[key];\n    }\n}\nfunction isValueSame(val1, val2) {\n    return val1 === val2\n        || (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArrayLike)(val1) && (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArrayLike)(val2) && is1DArraySame(val1, val2);\n}\nfunction is1DArraySame(arr0, arr1) {\n    var len = arr0.length;\n    if (len !== arr1.length) {\n        return false;\n    }\n    for (var i = 0; i < len; i++) {\n        if (arr0[i] !== arr1[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction animateToShallow(animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse) {\n    var targetKeys = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.keys)(target);\n    var duration = cfg.duration;\n    var delay = cfg.delay;\n    var additive = cfg.additive;\n    var setToFinal = cfg.setToFinal;\n    var animateAll = !(0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(animationProps);\n    var existsAnimators = animatable.animators;\n    var animationKeys = [];\n    for (var k = 0; k < targetKeys.length; k++) {\n        var innerKey = targetKeys[k];\n        var targetVal = target[innerKey];\n        if (targetVal != null && animateObj[innerKey] != null\n            && (animateAll || animationProps[innerKey])) {\n            if ((0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(targetVal)\n                && !(0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArrayLike)(targetVal)\n                && !(0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isGradientObject)(targetVal)) {\n                if (topKey) {\n                    if (!reverse) {\n                        animateObj[innerKey] = targetVal;\n                        animatable.updateDuringAnimation(topKey);\n                    }\n                    continue;\n                }\n                animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse);\n            }\n            else {\n                animationKeys.push(innerKey);\n            }\n        }\n        else if (!reverse) {\n            animateObj[innerKey] = targetVal;\n            animatable.updateDuringAnimation(topKey);\n            animationKeys.push(innerKey);\n        }\n    }\n    var keyLen = animationKeys.length;\n    if (!additive && keyLen) {\n        for (var i = 0; i < existsAnimators.length; i++) {\n            var animator = existsAnimators[i];\n            if (animator.targetName === topKey) {\n                var allAborted = animator.stopTracks(animationKeys);\n                if (allAborted) {\n                    var idx = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.indexOf)(existsAnimators, animator);\n                    existsAnimators.splice(idx, 1);\n                }\n            }\n        }\n    }\n    if (!cfg.force) {\n        animationKeys = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.filter)(animationKeys, function (key) { return !isValueSame(target[key], animateObj[key]); });\n        keyLen = animationKeys.length;\n    }\n    if (keyLen > 0\n        || (cfg.force && !animators.length)) {\n        var revertedSource = void 0;\n        var reversedTarget = void 0;\n        var sourceClone = void 0;\n        if (reverse) {\n            reversedTarget = {};\n            if (setToFinal) {\n                revertedSource = {};\n            }\n            for (var i = 0; i < keyLen; i++) {\n                var innerKey = animationKeys[i];\n                reversedTarget[innerKey] = animateObj[innerKey];\n                if (setToFinal) {\n                    revertedSource[innerKey] = target[innerKey];\n                }\n                else {\n                    animateObj[innerKey] = target[innerKey];\n                }\n            }\n        }\n        else if (setToFinal) {\n            sourceClone = {};\n            for (var i = 0; i < keyLen; i++) {\n                var innerKey = animationKeys[i];\n                sourceClone[innerKey] = (0,_animation_Animator_js__WEBPACK_IMPORTED_MODULE_7__/* .cloneValue */ .F)(animateObj[innerKey]);\n                copyValue(animateObj, target, innerKey);\n            }\n        }\n        var animator = new _animation_Animator_js__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .A(animateObj, false, false, additive ? (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.filter)(existsAnimators, function (animator) { return animator.targetName === topKey; }) : null);\n        animator.targetName = topKey;\n        if (cfg.scope) {\n            animator.scope = cfg.scope;\n        }\n        if (setToFinal && revertedSource) {\n            animator.whenWithKeys(0, revertedSource, animationKeys);\n        }\n        if (sourceClone) {\n            animator.whenWithKeys(0, sourceClone, animationKeys);\n        }\n        animator.whenWithKeys(duration == null ? 500 : duration, reverse ? reversedTarget : target, animationKeys).delay(delay || 0);\n        animatable.addAnimator(animator, topKey);\n        animators.push(animator);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Element);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI0NTQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL0VsZW1lbnQuanM/MTAyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVHJhbnNmb3JtYWJsZSwgeyBUUkFOU0ZPUk1BQkxFX1BST1BTIH0gZnJvbSAnLi9jb3JlL1RyYW5zZm9ybWFibGUuanMnO1xuaW1wb3J0IEFuaW1hdG9yLCB7IGNsb25lVmFsdWUgfSBmcm9tICcuL2FuaW1hdGlvbi9BbmltYXRvci5qcyc7XG5pbXBvcnQgQm91bmRpbmdSZWN0IGZyb20gJy4vY29yZS9Cb3VuZGluZ1JlY3QuanMnO1xuaW1wb3J0IEV2ZW50ZnVsIGZyb20gJy4vY29yZS9FdmVudGZ1bC5qcyc7XG5pbXBvcnQgeyBjYWxjdWxhdGVUZXh0UG9zaXRpb24sIHBhcnNlUGVyY2VudCB9IGZyb20gJy4vY29udGFpbi90ZXh0LmpzJztcbmltcG9ydCB7IGd1aWQsIGlzT2JqZWN0LCBrZXlzLCBleHRlbmQsIGluZGV4T2YsIGxvZ0Vycm9yLCBtaXhpbiwgaXNBcnJheUxpa2UsIGlzVHlwZWRBcnJheSwgaXNHcmFkaWVudE9iamVjdCwgZmlsdGVyLCByZWR1Y2UgfSBmcm9tICcuL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBMSUdIVF9MQUJFTF9DT0xPUiwgREFSS19MQUJFTF9DT0xPUiB9IGZyb20gJy4vY29uZmlnLmpzJztcbmltcG9ydCB7IHBhcnNlLCBzdHJpbmdpZnkgfSBmcm9tICcuL3Rvb2wvY29sb3IuanMnO1xuaW1wb3J0IHsgUkVEUkFXX0JJVCB9IGZyb20gJy4vZ3JhcGhpYy9jb25zdGFudHMuanMnO1xuZXhwb3J0IHZhciBQUkVTRVJWRURfTk9STUFMX1NUQVRFID0gJ19fenJfbm9ybWFsX18nO1xudmFyIFBSSU1BUllfU1RBVEVTX0tFWVMgPSBUUkFOU0ZPUk1BQkxFX1BST1BTLmNvbmNhdChbJ2lnbm9yZSddKTtcbnZhciBERUZBVUxUX0FOSU1BVEFCTEVfTUFQID0gcmVkdWNlKFRSQU5TRk9STUFCTEVfUFJPUFMsIGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgIG9ialtrZXldID0gdHJ1ZTtcbiAgICByZXR1cm4gb2JqO1xufSwgeyBpZ25vcmU6IGZhbHNlIH0pO1xudmFyIHRtcFRleHRQb3NDYWxjUmVzID0ge307XG52YXIgdG1wQm91bmRpbmdSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbnZhciBFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbGVtZW50KHByb3BzKSB7XG4gICAgICAgIHRoaXMuaWQgPSBndWlkKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0b3JzID0gW107XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHt9O1xuICAgICAgICB0aGlzLl9pbml0KHByb3BzKTtcbiAgICB9XG4gICAgRWxlbWVudC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5hdHRyKHByb3BzKTtcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmRyaWZ0ID0gZnVuY3Rpb24gKGR4LCBkeSwgZSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgICAgICAgICBkeSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgICAgICAgICAgZHggPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgbSA9IHRoaXMudHJhbnNmb3JtID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIG1bNF0gKz0gZHg7XG4gICAgICAgIG1bNV0gKz0gZHk7XG4gICAgICAgIHRoaXMuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMubWFya1JlZHJhdygpO1xuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuYmVmb3JlVXBkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmFmdGVyVXBkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgaWYgKHRoaXMuX19kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbm5lclRleHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUudXBkYXRlSW5uZXJUZXh0ID0gZnVuY3Rpb24gKGZvcmNlVXBkYXRlKSB7XG4gICAgICAgIHZhciB0ZXh0RWwgPSB0aGlzLl90ZXh0Q29udGVudDtcbiAgICAgICAgaWYgKHRleHRFbCAmJiAoIXRleHRFbC5pZ25vcmUgfHwgZm9yY2VVcGRhdGUpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudGV4dENvbmZpZykge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dENvbmZpZyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRleHRDb25maWcgPSB0aGlzLnRleHRDb25maWc7XG4gICAgICAgICAgICB2YXIgaXNMb2NhbCA9IHRleHRDb25maWcubG9jYWw7XG4gICAgICAgICAgICB2YXIgaW5uZXJUcmFuc2Zvcm1hYmxlID0gdGV4dEVsLmlubmVyVHJhbnNmb3JtYWJsZTtcbiAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgdGV4dFN0eWxlQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5uZXJUcmFuc2Zvcm1hYmxlLnBhcmVudCA9IGlzTG9jYWwgPyB0aGlzIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBpbm5lck9yaWdpbiA9IGZhbHNlO1xuICAgICAgICAgICAgaW5uZXJUcmFuc2Zvcm1hYmxlLmNvcHlUcmFuc2Zvcm0odGV4dEVsKTtcbiAgICAgICAgICAgIGlmICh0ZXh0Q29uZmlnLnBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5b3V0UmVjdCA9IHRtcEJvdW5kaW5nUmVjdDtcbiAgICAgICAgICAgICAgICBpZiAodGV4dENvbmZpZy5sYXlvdXRSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dFJlY3QuY29weSh0ZXh0Q29uZmlnLmxheW91dFJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0UmVjdC5jb3B5KHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzTG9jYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0UmVjdC5hcHBseVRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGN1bGF0ZVRleHRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVRleHRQb3NpdGlvbih0bXBUZXh0UG9zQ2FsY1JlcywgdGV4dENvbmZpZywgbGF5b3V0UmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVUZXh0UG9zaXRpb24odG1wVGV4dFBvc0NhbGNSZXMsIHRleHRDb25maWcsIGxheW91dFJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbm5lclRyYW5zZm9ybWFibGUueCA9IHRtcFRleHRQb3NDYWxjUmVzLng7XG4gICAgICAgICAgICAgICAgaW5uZXJUcmFuc2Zvcm1hYmxlLnkgPSB0bXBUZXh0UG9zQ2FsY1Jlcy55O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IHRtcFRleHRQb3NDYWxjUmVzLmFsaWduO1xuICAgICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gdG1wVGV4dFBvc0NhbGNSZXMudmVydGljYWxBbGlnbjtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dE9yaWdpbiA9IHRleHRDb25maWcub3JpZ2luO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0T3JpZ2luICYmIHRleHRDb25maWcucm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVsT3JpZ2luWCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbE9yaWdpblkgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0T3JpZ2luID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsT3JpZ2luWCA9IGxheW91dFJlY3Qud2lkdGggKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxPcmlnaW5ZID0gbGF5b3V0UmVjdC5oZWlnaHQgKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxPcmlnaW5YID0gcGFyc2VQZXJjZW50KHRleHRPcmlnaW5bMF0sIGxheW91dFJlY3Qud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsT3JpZ2luWSA9IHBhcnNlUGVyY2VudCh0ZXh0T3JpZ2luWzFdLCBsYXlvdXRSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPcmlnaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpbm5lclRyYW5zZm9ybWFibGUub3JpZ2luWCA9IC1pbm5lclRyYW5zZm9ybWFibGUueCArIHJlbE9yaWdpblggKyAoaXNMb2NhbCA/IDAgOiBsYXlvdXRSZWN0LngpO1xuICAgICAgICAgICAgICAgICAgICBpbm5lclRyYW5zZm9ybWFibGUub3JpZ2luWSA9IC1pbm5lclRyYW5zZm9ybWFibGUueSArIHJlbE9yaWdpblkgKyAoaXNMb2NhbCA/IDAgOiBsYXlvdXRSZWN0LnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0Q29uZmlnLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbm5lclRyYW5zZm9ybWFibGUucm90YXRpb24gPSB0ZXh0Q29uZmlnLnJvdGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRleHRPZmZzZXQgPSB0ZXh0Q29uZmlnLm9mZnNldDtcbiAgICAgICAgICAgIGlmICh0ZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaW5uZXJUcmFuc2Zvcm1hYmxlLnggKz0gdGV4dE9mZnNldFswXTtcbiAgICAgICAgICAgICAgICBpbm5lclRyYW5zZm9ybWFibGUueSArPSB0ZXh0T2Zmc2V0WzFdO1xuICAgICAgICAgICAgICAgIGlmICghaW5uZXJPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJUcmFuc2Zvcm1hYmxlLm9yaWdpblggPSAtdGV4dE9mZnNldFswXTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJUcmFuc2Zvcm1hYmxlLm9yaWdpblkgPSAtdGV4dE9mZnNldFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXNJbnNpZGUgPSB0ZXh0Q29uZmlnLmluc2lkZSA9PSBudWxsXG4gICAgICAgICAgICAgICAgPyAodHlwZW9mIHRleHRDb25maWcucG9zaXRpb24gPT09ICdzdHJpbmcnICYmIHRleHRDb25maWcucG9zaXRpb24uaW5kZXhPZignaW5zaWRlJykgPj0gMClcbiAgICAgICAgICAgICAgICA6IHRleHRDb25maWcuaW5zaWRlO1xuICAgICAgICAgICAgdmFyIGlubmVyVGV4dERlZmF1bHRTdHlsZSA9IHRoaXMuX2lubmVyVGV4dERlZmF1bHRTdHlsZSB8fCAodGhpcy5faW5uZXJUZXh0RGVmYXVsdFN0eWxlID0ge30pO1xuICAgICAgICAgICAgdmFyIHRleHRGaWxsID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIHRleHRTdHJva2UgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgYXV0b1N0cm9rZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChpc0luc2lkZSAmJiB0aGlzLmNhbkJlSW5zaWRlVGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdGV4dEZpbGwgPSB0ZXh0Q29uZmlnLmluc2lkZUZpbGw7XG4gICAgICAgICAgICAgICAgdGV4dFN0cm9rZSA9IHRleHRDb25maWcuaW5zaWRlU3Ryb2tlO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0RmlsbCA9PSBudWxsIHx8IHRleHRGaWxsID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZpbGwgPSB0aGlzLmdldEluc2lkZVRleHRGaWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZXh0U3Ryb2tlID09IG51bGwgfHwgdGV4dFN0cm9rZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRTdHJva2UgPSB0aGlzLmdldEluc2lkZVRleHRTdHJva2UodGV4dEZpbGwpO1xuICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0RmlsbCA9IHRleHRDb25maWcub3V0c2lkZUZpbGw7XG4gICAgICAgICAgICAgICAgdGV4dFN0cm9rZSA9IHRleHRDb25maWcub3V0c2lkZVN0cm9rZTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dEZpbGwgPT0gbnVsbCB8fCB0ZXh0RmlsbCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRGaWxsID0gdGhpcy5nZXRPdXRzaWRlRmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dFN0cm9rZSA9PSBudWxsIHx8IHRleHRTdHJva2UgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0U3Ryb2tlID0gdGhpcy5nZXRPdXRzaWRlU3Ryb2tlKHRleHRGaWxsKTtcbiAgICAgICAgICAgICAgICAgICAgYXV0b1N0cm9rZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dEZpbGwgPSB0ZXh0RmlsbCB8fCAnIzAwMCc7XG4gICAgICAgICAgICBpZiAodGV4dEZpbGwgIT09IGlubmVyVGV4dERlZmF1bHRTdHlsZS5maWxsXG4gICAgICAgICAgICAgICAgfHwgdGV4dFN0cm9rZSAhPT0gaW5uZXJUZXh0RGVmYXVsdFN0eWxlLnN0cm9rZVxuICAgICAgICAgICAgICAgIHx8IGF1dG9TdHJva2UgIT09IGlubmVyVGV4dERlZmF1bHRTdHlsZS5hdXRvU3Ryb2tlXG4gICAgICAgICAgICAgICAgfHwgdGV4dEFsaWduICE9PSBpbm5lclRleHREZWZhdWx0U3R5bGUuYWxpZ25cbiAgICAgICAgICAgICAgICB8fCB0ZXh0VmVydGljYWxBbGlnbiAhPT0gaW5uZXJUZXh0RGVmYXVsdFN0eWxlLnZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICB0ZXh0U3R5bGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpbm5lclRleHREZWZhdWx0U3R5bGUuZmlsbCA9IHRleHRGaWxsO1xuICAgICAgICAgICAgICAgIGlubmVyVGV4dERlZmF1bHRTdHlsZS5zdHJva2UgPSB0ZXh0U3Ryb2tlO1xuICAgICAgICAgICAgICAgIGlubmVyVGV4dERlZmF1bHRTdHlsZS5hdXRvU3Ryb2tlID0gYXV0b1N0cm9rZTtcbiAgICAgICAgICAgICAgICBpbm5lclRleHREZWZhdWx0U3R5bGUuYWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgaW5uZXJUZXh0RGVmYXVsdFN0eWxlLnZlcnRpY2FsQWxpZ24gPSB0ZXh0VmVydGljYWxBbGlnbjtcbiAgICAgICAgICAgICAgICB0ZXh0RWwuc2V0RGVmYXVsdFRleHRTdHlsZShpbm5lclRleHREZWZhdWx0U3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dEVsLl9fZGlydHkgfD0gUkVEUkFXX0JJVDtcbiAgICAgICAgICAgIGlmICh0ZXh0U3R5bGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGV4dEVsLmRpcnR5U3R5bGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmNhbkJlSW5zaWRlVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5nZXRJbnNpZGVUZXh0RmlsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcjZmZmJztcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmdldEluc2lkZVRleHRTdHJva2UgPSBmdW5jdGlvbiAodGV4dEZpbGwpIHtcbiAgICAgICAgcmV0dXJuICcjMDAwJztcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmdldE91dHNpZGVGaWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3pyICYmIHRoaXMuX196ci5pc0RhcmtNb2RlKCkgPyBMSUdIVF9MQUJFTF9DT0xPUiA6IERBUktfTEFCRUxfQ09MT1I7XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5nZXRPdXRzaWRlU3Ryb2tlID0gZnVuY3Rpb24gKHRleHRGaWxsKSB7XG4gICAgICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLmdldEJhY2tncm91bmRDb2xvcigpO1xuICAgICAgICB2YXIgY29sb3JBcnIgPSB0eXBlb2YgYmFja2dyb3VuZENvbG9yID09PSAnc3RyaW5nJyAmJiBwYXJzZShiYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICBpZiAoIWNvbG9yQXJyKSB7XG4gICAgICAgICAgICBjb2xvckFyciA9IFsyNTUsIDI1NSwgMjU1LCAxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxwaGEgPSBjb2xvckFyclszXTtcbiAgICAgICAgdmFyIGlzRGFyayA9IHRoaXMuX196ci5pc0RhcmtNb2RlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICBjb2xvckFycltpXSA9IGNvbG9yQXJyW2ldICogYWxwaGEgKyAoaXNEYXJrID8gMCA6IDI1NSkgKiAoMSAtIGFscGhhKTtcbiAgICAgICAgfVxuICAgICAgICBjb2xvckFyclszXSA9IDE7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3JBcnIsICdyZ2JhJyk7XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uIChjYiwgY29udGV4dCkgeyB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmF0dHJLViA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICd0ZXh0Q29uZmlnJykge1xuICAgICAgICAgICAgdGhpcy5zZXRUZXh0Q29uZmlnKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VGV4dENvbnRlbnQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2NsaXBQYXRoJykge1xuICAgICAgICAgICAgdGhpcy5zZXRDbGlwUGF0aCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZXh0cmEnKSB7XG4gICAgICAgICAgICB0aGlzLmV4dHJhID0gdGhpcy5leHRyYSB8fCB7fTtcbiAgICAgICAgICAgIGV4dGVuZCh0aGlzLmV4dHJhLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZ25vcmUgPSB0cnVlO1xuICAgICAgICB0aGlzLm1hcmtSZWRyYXcoKTtcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWdub3JlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWFya1JlZHJhdygpO1xuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuYXR0ciA9IGZ1bmN0aW9uIChrZXlPck9iaiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXlPck9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cktWKGtleU9yT2JqLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3Qoa2V5T3JPYmopKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ga2V5T3JPYmo7XG4gICAgICAgICAgICB2YXIga2V5c0FyciA9IGtleXMob2JqKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0Fyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzQXJyW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cktWKGtleSwga2V5T3JPYmpba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrUmVkcmF3KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2F2ZUN1cnJlbnRUb05vcm1hbFN0YXRlID0gZnVuY3Rpb24gKHRvU3RhdGUpIHtcbiAgICAgICAgdGhpcy5faW5uZXJTYXZlVG9Ob3JtYWwodG9TdGF0ZSk7XG4gICAgICAgIHZhciBub3JtYWxTdGF0ZSA9IHRoaXMuX25vcm1hbFN0YXRlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSB0aGlzLmFuaW1hdG9yc1tpXTtcbiAgICAgICAgICAgIHZhciBmcm9tU3RhdGVUcmFuc2l0aW9uID0gYW5pbWF0b3IuX19mcm9tU3RhdGVUcmFuc2l0aW9uO1xuICAgICAgICAgICAgaWYgKGFuaW1hdG9yLmdldExvb3AoKSB8fCBmcm9tU3RhdGVUcmFuc2l0aW9uICYmIGZyb21TdGF0ZVRyYW5zaXRpb24gIT09IFBSRVNFUlZFRF9OT1JNQUxfU1RBVEUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YXJnZXROYW1lID0gYW5pbWF0b3IudGFyZ2V0TmFtZTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXROYW1lXG4gICAgICAgICAgICAgICAgPyBub3JtYWxTdGF0ZVt0YXJnZXROYW1lXSA6IG5vcm1hbFN0YXRlO1xuICAgICAgICAgICAgYW5pbWF0b3Iuc2F2ZVRvKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLl9pbm5lclNhdmVUb05vcm1hbCA9IGZ1bmN0aW9uICh0b1N0YXRlKSB7XG4gICAgICAgIHZhciBub3JtYWxTdGF0ZSA9IHRoaXMuX25vcm1hbFN0YXRlO1xuICAgICAgICBpZiAoIW5vcm1hbFN0YXRlKSB7XG4gICAgICAgICAgICBub3JtYWxTdGF0ZSA9IHRoaXMuX25vcm1hbFN0YXRlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvU3RhdGUudGV4dENvbmZpZyAmJiAhbm9ybWFsU3RhdGUudGV4dENvbmZpZykge1xuICAgICAgICAgICAgbm9ybWFsU3RhdGUudGV4dENvbmZpZyA9IHRoaXMudGV4dENvbmZpZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zYXZlUHJpbWFyeVRvTm9ybWFsKHRvU3RhdGUsIG5vcm1hbFN0YXRlLCBQUklNQVJZX1NUQVRFU19LRVlTKTtcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLl9zYXZlUHJpbWFyeVRvTm9ybWFsID0gZnVuY3Rpb24gKHRvU3RhdGUsIG5vcm1hbFN0YXRlLCBwcmltYXJ5S2V5cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW1hcnlLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gcHJpbWFyeUtleXNbaV07XG4gICAgICAgICAgICBpZiAodG9TdGF0ZVtrZXldICE9IG51bGwgJiYgIShrZXkgaW4gbm9ybWFsU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsU3RhdGVba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuaGFzU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdGF0ZXMubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzW25hbWVdO1xuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuZW5zdXJlU3RhdGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgc3RhdGVzID0gdGhpcy5zdGF0ZXM7XG4gICAgICAgIGlmICghc3RhdGVzW25hbWVdKSB7XG4gICAgICAgICAgICBzdGF0ZXNbbmFtZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVzW25hbWVdO1xuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuY2xlYXJTdGF0ZXMgPSBmdW5jdGlvbiAobm9BbmltYXRpb24pIHtcbiAgICAgICAgdGhpcy51c2VTdGF0ZShQUkVTRVJWRURfTk9STUFMX1NUQVRFLCBmYWxzZSwgbm9BbmltYXRpb24pO1xuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUudXNlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGVOYW1lLCBrZWVwQ3VycmVudFN0YXRlcywgbm9BbmltYXRpb24sIGZvcmNlVXNlSG92ZXJMYXllcikge1xuICAgICAgICB2YXIgdG9Ob3JtYWxTdGF0ZSA9IHN0YXRlTmFtZSA9PT0gUFJFU0VSVkVEX05PUk1BTF9TVEFURTtcbiAgICAgICAgdmFyIGhhc1N0YXRlcyA9IHRoaXMuaGFzU3RhdGUoKTtcbiAgICAgICAgaWYgKCFoYXNTdGF0ZXMgJiYgdG9Ob3JtYWxTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50U3RhdGVzID0gdGhpcy5jdXJyZW50U3RhdGVzO1xuICAgICAgICB2YXIgYW5pbWF0aW9uQ2ZnID0gdGhpcy5zdGF0ZVRyYW5zaXRpb247XG4gICAgICAgIGlmIChpbmRleE9mKGN1cnJlbnRTdGF0ZXMsIHN0YXRlTmFtZSkgPj0gMCAmJiAoa2VlcEN1cnJlbnRTdGF0ZXMgfHwgY3VycmVudFN0YXRlcy5sZW5ndGggPT09IDEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZVByb3h5ICYmICF0b05vcm1hbFN0YXRlKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHRoaXMuc3RhdGVQcm94eShzdGF0ZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHN0YXRlID0gKHRoaXMuc3RhdGVzICYmIHRoaXMuc3RhdGVzW3N0YXRlTmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdGUgJiYgIXRvTm9ybWFsU3RhdGUpIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKFwiU3RhdGUgXCIgKyBzdGF0ZU5hbWUgKyBcIiBub3QgZXhpc3RzLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvTm9ybWFsU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2F2ZUN1cnJlbnRUb05vcm1hbFN0YXRlKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXNlSG92ZXJMYXllciA9ICEhKChzdGF0ZSAmJiBzdGF0ZS5ob3ZlckxheWVyKSB8fCBmb3JjZVVzZUhvdmVyTGF5ZXIpO1xuICAgICAgICBpZiAodXNlSG92ZXJMYXllcikge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlSG92ZXJMYXllckZsYWcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXBwbHlTdGF0ZU9iaihzdGF0ZU5hbWUsIHN0YXRlLCB0aGlzLl9ub3JtYWxTdGF0ZSwga2VlcEN1cnJlbnRTdGF0ZXMsICFub0FuaW1hdGlvbiAmJiAhdGhpcy5fX2luSG92ZXIgJiYgYW5pbWF0aW9uQ2ZnICYmIGFuaW1hdGlvbkNmZy5kdXJhdGlvbiA+IDAsIGFuaW1hdGlvbkNmZyk7XG4gICAgICAgIHZhciB0ZXh0Q29udGVudCA9IHRoaXMuX3RleHRDb250ZW50O1xuICAgICAgICB2YXIgdGV4dEd1aWRlID0gdGhpcy5fdGV4dEd1aWRlO1xuICAgICAgICBpZiAodGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgIHRleHRDb250ZW50LnVzZVN0YXRlKHN0YXRlTmFtZSwga2VlcEN1cnJlbnRTdGF0ZXMsIG5vQW5pbWF0aW9uLCB1c2VIb3ZlckxheWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dEd1aWRlKSB7XG4gICAgICAgICAgICB0ZXh0R3VpZGUudXNlU3RhdGUoc3RhdGVOYW1lLCBrZWVwQ3VycmVudFN0YXRlcywgbm9BbmltYXRpb24sIHVzZUhvdmVyTGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b05vcm1hbFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX25vcm1hbFN0YXRlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBDdXJyZW50U3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdGVzID0gW3N0YXRlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZXMucHVzaChzdGF0ZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUFuaW1hdGlvblRhcmdldHMoKTtcbiAgICAgICAgdGhpcy5tYXJrUmVkcmF3KCk7XG4gICAgICAgIGlmICghdXNlSG92ZXJMYXllciAmJiB0aGlzLl9faW5Ib3Zlcikge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlSG92ZXJMYXllckZsYWcoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fX2RpcnR5ICY9IH5SRURSQVdfQklUO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnVzZVN0YXRlcyA9IGZ1bmN0aW9uIChzdGF0ZXMsIG5vQW5pbWF0aW9uLCBmb3JjZVVzZUhvdmVyTGF5ZXIpIHtcbiAgICAgICAgaWYgKCFzdGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyU3RhdGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVPYmplY3RzID0gW107XG4gICAgICAgICAgICB2YXIgY3VycmVudFN0YXRlcyA9IHRoaXMuY3VycmVudFN0YXRlcztcbiAgICAgICAgICAgIHZhciBsZW4gPSBzdGF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG5vdENoYW5nZSA9IGxlbiA9PT0gY3VycmVudFN0YXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobm90Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVzW2ldICE9PSBjdXJyZW50U3RhdGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVOYW1lID0gc3RhdGVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZU9iaiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZVByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlT2JqID0gdGhpcy5zdGF0ZVByb3h5KHN0YXRlTmFtZSwgc3RhdGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZU9iaikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZU9iaiA9IHRoaXMuc3RhdGVzW3N0YXRlTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZU9iaikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZU9iamVjdHMucHVzaChzdGF0ZU9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxhc3RTdGF0ZU9iaiA9IHN0YXRlT2JqZWN0c1tsZW4gLSAxXTtcbiAgICAgICAgICAgIHZhciB1c2VIb3ZlckxheWVyID0gISEoKGxhc3RTdGF0ZU9iaiAmJiBsYXN0U3RhdGVPYmouaG92ZXJMYXllcikgfHwgZm9yY2VVc2VIb3ZlckxheWVyKTtcbiAgICAgICAgICAgIGlmICh1c2VIb3ZlckxheWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlSG92ZXJMYXllckZsYWcodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWVyZ2VkU3RhdGUgPSB0aGlzLl9tZXJnZVN0YXRlcyhzdGF0ZU9iamVjdHMpO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkNmZyA9IHRoaXMuc3RhdGVUcmFuc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5zYXZlQ3VycmVudFRvTm9ybWFsU3RhdGUobWVyZ2VkU3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlTdGF0ZU9iaihzdGF0ZXMuam9pbignLCcpLCBtZXJnZWRTdGF0ZSwgdGhpcy5fbm9ybWFsU3RhdGUsIGZhbHNlLCAhbm9BbmltYXRpb24gJiYgIXRoaXMuX19pbkhvdmVyICYmIGFuaW1hdGlvbkNmZyAmJiBhbmltYXRpb25DZmcuZHVyYXRpb24gPiAwLCBhbmltYXRpb25DZmcpO1xuICAgICAgICAgICAgdmFyIHRleHRDb250ZW50ID0gdGhpcy5fdGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgdGV4dEd1aWRlID0gdGhpcy5fdGV4dEd1aWRlO1xuICAgICAgICAgICAgaWYgKHRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnQudXNlU3RhdGVzKHN0YXRlcywgbm9BbmltYXRpb24sIHVzZUhvdmVyTGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRleHRHdWlkZSkge1xuICAgICAgICAgICAgICAgIHRleHRHdWlkZS51c2VTdGF0ZXMoc3RhdGVzLCBub0FuaW1hdGlvbiwgdXNlSG92ZXJMYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVBbmltYXRpb25UYXJnZXRzKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZXMgPSBzdGF0ZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMubWFya1JlZHJhdygpO1xuICAgICAgICAgICAgaWYgKCF1c2VIb3ZlckxheWVyICYmIHRoaXMuX19pbkhvdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlSG92ZXJMYXllckZsYWcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19kaXJ0eSAmPSB+UkVEUkFXX0JJVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuaXNTaWxlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpc1NpbGVudCA9IHRoaXMuc2lsZW50O1xuICAgICAgICB2YXIgYW5jZXN0b3IgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgd2hpbGUgKCFpc1NpbGVudCAmJiBhbmNlc3Rvcikge1xuICAgICAgICAgICAgaWYgKGFuY2VzdG9yLnNpbGVudCkge1xuICAgICAgICAgICAgICAgIGlzU2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1NpbGVudDtcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLl91cGRhdGVBbmltYXRpb25UYXJnZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSB0aGlzLmFuaW1hdG9yc1tpXTtcbiAgICAgICAgICAgIGlmIChhbmltYXRvci50YXJnZXROYW1lKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3IuY2hhbmdlVGFyZ2V0KHRoaXNbYW5pbWF0b3IudGFyZ2V0TmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgaWR4ID0gaW5kZXhPZih0aGlzLmN1cnJlbnRTdGF0ZXMsIHN0YXRlKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFN0YXRlcyA9IHRoaXMuY3VycmVudFN0YXRlcy5zbGljZSgpO1xuICAgICAgICAgICAgY3VycmVudFN0YXRlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIHRoaXMudXNlU3RhdGVzKGN1cnJlbnRTdGF0ZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiAob2xkU3RhdGUsIG5ld1N0YXRlLCBmb3JjZUFkZCkge1xuICAgICAgICB2YXIgY3VycmVudFN0YXRlcyA9IHRoaXMuY3VycmVudFN0YXRlcy5zbGljZSgpO1xuICAgICAgICB2YXIgaWR4ID0gaW5kZXhPZihjdXJyZW50U3RhdGVzLCBvbGRTdGF0ZSk7XG4gICAgICAgIHZhciBuZXdTdGF0ZUV4aXN0cyA9IGluZGV4T2YoY3VycmVudFN0YXRlcywgbmV3U3RhdGUpID49IDA7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZUV4aXN0cykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZXNbaWR4XSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFN0YXRlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JjZUFkZCAmJiAhbmV3U3RhdGVFeGlzdHMpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZXMucHVzaChuZXdTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VTdGF0ZXMoY3VycmVudFN0YXRlcyk7XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS50b2dnbGVTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZW5hYmxlKSB7XG4gICAgICAgIGlmIChlbmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMudXNlU3RhdGUoc3RhdGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTdGF0ZShzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLl9tZXJnZVN0YXRlcyA9IGZ1bmN0aW9uIChzdGF0ZXMpIHtcbiAgICAgICAgdmFyIG1lcmdlZFN0YXRlID0ge307XG4gICAgICAgIHZhciBtZXJnZWRUZXh0Q29uZmlnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gc3RhdGVzW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKG1lcmdlZFN0YXRlLCBzdGF0ZSk7XG4gICAgICAgICAgICBpZiAoc3RhdGUudGV4dENvbmZpZykge1xuICAgICAgICAgICAgICAgIG1lcmdlZFRleHRDb25maWcgPSBtZXJnZWRUZXh0Q29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgIGV4dGVuZChtZXJnZWRUZXh0Q29uZmlnLCBzdGF0ZS50ZXh0Q29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVyZ2VkVGV4dENvbmZpZykge1xuICAgICAgICAgICAgbWVyZ2VkU3RhdGUudGV4dENvbmZpZyA9IG1lcmdlZFRleHRDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlZFN0YXRlO1xuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuX2FwcGx5U3RhdGVPYmogPSBmdW5jdGlvbiAoc3RhdGVOYW1lLCBzdGF0ZSwgbm9ybWFsU3RhdGUsIGtlZXBDdXJyZW50U3RhdGVzLCB0cmFuc2l0aW9uLCBhbmltYXRpb25DZmcpIHtcbiAgICAgICAgdmFyIG5lZWRzUmVzdG9yZVRvTm9ybWFsID0gIShzdGF0ZSAmJiBrZWVwQ3VycmVudFN0YXRlcyk7XG4gICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS50ZXh0Q29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRDb25maWcgPSBleHRlbmQoe30sIGtlZXBDdXJyZW50U3RhdGVzID8gdGhpcy50ZXh0Q29uZmlnIDogbm9ybWFsU3RhdGUudGV4dENvbmZpZyk7XG4gICAgICAgICAgICBleHRlbmQodGhpcy50ZXh0Q29uZmlnLCBzdGF0ZS50ZXh0Q29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZWVkc1Jlc3RvcmVUb05vcm1hbCkge1xuICAgICAgICAgICAgaWYgKG5vcm1hbFN0YXRlLnRleHRDb25maWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRDb25maWcgPSBub3JtYWxTdGF0ZS50ZXh0Q29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2l0aW9uVGFyZ2V0ID0ge307XG4gICAgICAgIHZhciBoYXNUcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUFJJTUFSWV9TVEFURVNfS0VZUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IFBSSU1BUllfU1RBVEVTX0tFWVNbaV07XG4gICAgICAgICAgICB2YXIgcHJvcE5lZWRzVHJhbnNpdGlvbiA9IHRyYW5zaXRpb24gJiYgREVGQVVMVF9BTklNQVRBQkxFX01BUFtrZXldO1xuICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTmVlZHNUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1RyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uVGFyZ2V0W2tleV0gPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZWVkc1Jlc3RvcmVUb05vcm1hbCkge1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxTdGF0ZVtrZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BOZWVkc1RyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1RyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvblRhcmdldFtrZXldID0gbm9ybWFsU3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IG5vcm1hbFN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdG9yID0gdGhpcy5hbmltYXRvcnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldE5hbWUgPSBhbmltYXRvci50YXJnZXROYW1lO1xuICAgICAgICAgICAgICAgIGlmICghYW5pbWF0b3IuZ2V0TG9vcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdG9yLl9fY2hhbmdlRmluYWxWYWx1ZSh0YXJnZXROYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChzdGF0ZSB8fCBub3JtYWxTdGF0ZSlbdGFyZ2V0TmFtZV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogKHN0YXRlIHx8IG5vcm1hbFN0YXRlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uU3RhdGUoc3RhdGVOYW1lLCB0cmFuc2l0aW9uVGFyZ2V0LCBhbmltYXRpb25DZmcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5fYXR0YWNoQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudEVsKSB7XG4gICAgICAgIGlmIChjb21wb25lbnRFbC5fX3pyICYmICFjb21wb25lbnRFbC5fX2hvc3RUYXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0IGVsZW1lbnQgaGFzIGJlZW4gYWRkZWQgdG8genJlbmRlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50RWwgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWN1cnNpdmUgY29tcG9uZW50IGF0dGFjaG1lbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICBpZiAoenIpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudEVsLmFkZFNlbGZUb1pyKHpyKTtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnRFbC5fX3pyID0genI7XG4gICAgICAgIGNvbXBvbmVudEVsLl9faG9zdFRhcmdldCA9IHRoaXM7XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5fZGV0YWNoQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudEVsKSB7XG4gICAgICAgIGlmIChjb21wb25lbnRFbC5fX3pyKSB7XG4gICAgICAgICAgICBjb21wb25lbnRFbC5yZW1vdmVTZWxmRnJvbVpyKGNvbXBvbmVudEVsLl9fenIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudEVsLl9fenIgPSBudWxsO1xuICAgICAgICBjb21wb25lbnRFbC5fX2hvc3RUYXJnZXQgPSBudWxsO1xuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuZ2V0Q2xpcFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGlwUGF0aDtcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnNldENsaXBQYXRoID0gZnVuY3Rpb24gKGNsaXBQYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGlwUGF0aCAmJiB0aGlzLl9jbGlwUGF0aCAhPT0gY2xpcFBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2xpcFBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hdHRhY2hDb21wb25lbnQoY2xpcFBhdGgpO1xuICAgICAgICB0aGlzLl9jbGlwUGF0aCA9IGNsaXBQYXRoO1xuICAgICAgICB0aGlzLm1hcmtSZWRyYXcoKTtcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUNsaXBQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLl9jbGlwUGF0aDtcbiAgICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXRhY2hDb21wb25lbnQoY2xpcFBhdGgpO1xuICAgICAgICAgICAgdGhpcy5fY2xpcFBhdGggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tYXJrUmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmdldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dENvbnRlbnQ7XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uICh0ZXh0RWwpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzVGV4dENvbnRlbnQgPSB0aGlzLl90ZXh0Q29udGVudDtcbiAgICAgICAgaWYgKHByZXZpb3VzVGV4dENvbnRlbnQgPT09IHRleHRFbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aW91c1RleHRDb250ZW50ICYmIHByZXZpb3VzVGV4dENvbnRlbnQgIT09IHRleHRFbCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVUZXh0Q29udGVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGV4dEVsLl9fenIgJiYgIXRleHRFbC5fX2hvc3RUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHQgZWxlbWVudCBoYXMgYmVlbiBhZGRlZCB0byB6cmVuZGVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRleHRFbC5pbm5lclRyYW5zZm9ybWFibGUgPSBuZXcgVHJhbnNmb3JtYWJsZSgpO1xuICAgICAgICB0aGlzLl9hdHRhY2hDb21wb25lbnQodGV4dEVsKTtcbiAgICAgICAgdGhpcy5fdGV4dENvbnRlbnQgPSB0ZXh0RWw7XG4gICAgICAgIHRoaXMubWFya1JlZHJhdygpO1xuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2V0VGV4dENvbmZpZyA9IGZ1bmN0aW9uIChjZmcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRleHRDb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dENvbmZpZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGV4dGVuZCh0aGlzLnRleHRDb25maWcsIGNmZyk7XG4gICAgICAgIHRoaXMubWFya1JlZHJhdygpO1xuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlVGV4dENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50ZXh0Q29uZmlnID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXJrUmVkcmF3KCk7XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVUZXh0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRleHRFbCA9IHRoaXMuX3RleHRDb250ZW50O1xuICAgICAgICBpZiAodGV4dEVsKSB7XG4gICAgICAgICAgICB0ZXh0RWwuaW5uZXJUcmFuc2Zvcm1hYmxlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2RldGFjaENvbXBvbmVudCh0ZXh0RWwpO1xuICAgICAgICAgICAgdGhpcy5fdGV4dENvbnRlbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faW5uZXJUZXh0RGVmYXVsdFN0eWxlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubWFya1JlZHJhdygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5nZXRUZXh0R3VpZGVMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEd1aWRlO1xuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2V0VGV4dEd1aWRlTGluZSA9IGZ1bmN0aW9uIChndWlkZUxpbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHRHdWlkZSAmJiB0aGlzLl90ZXh0R3VpZGUgIT09IGd1aWRlTGluZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVUZXh0R3VpZGVMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNoQ29tcG9uZW50KGd1aWRlTGluZSk7XG4gICAgICAgIHRoaXMuX3RleHRHdWlkZSA9IGd1aWRlTGluZTtcbiAgICAgICAgdGhpcy5tYXJrUmVkcmF3KCk7XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVUZXh0R3VpZGVMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGV4dEd1aWRlID0gdGhpcy5fdGV4dEd1aWRlO1xuICAgICAgICBpZiAodGV4dEd1aWRlKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXRhY2hDb21wb25lbnQodGV4dEd1aWRlKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRHdWlkZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1hcmtSZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUubWFya1JlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fX2RpcnR5IHw9IFJFRFJBV19CSVQ7XG4gICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgaWYgKHpyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fX2luSG92ZXIpIHtcbiAgICAgICAgICAgICAgICB6ci5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHpyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fX2hvc3RUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX19ob3N0VGFyZ2V0Lm1hcmtSZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuZGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWFya1JlZHJhdygpO1xuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuX3RvZ2dsZUhvdmVyTGF5ZXJGbGFnID0gZnVuY3Rpb24gKGluSG92ZXIpIHtcbiAgICAgICAgdGhpcy5fX2luSG92ZXIgPSBpbkhvdmVyO1xuICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSB0aGlzLl90ZXh0Q29udGVudDtcbiAgICAgICAgdmFyIHRleHRHdWlkZSA9IHRoaXMuX3RleHRHdWlkZTtcbiAgICAgICAgaWYgKHRleHRDb250ZW50KSB7XG4gICAgICAgICAgICB0ZXh0Q29udGVudC5fX2luSG92ZXIgPSBpbkhvdmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0R3VpZGUpIHtcbiAgICAgICAgICAgIHRleHRHdWlkZS5fX2luSG92ZXIgPSBpbkhvdmVyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5hZGRTZWxmVG9aciA9IGZ1bmN0aW9uICh6cikge1xuICAgICAgICBpZiAodGhpcy5fX3pyID09PSB6cikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX196ciA9IHpyO1xuICAgICAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG4gICAgICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NsaXBQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RleHRDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0Q29udGVudC5hZGRTZWxmVG9acih6cik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RleHRHdWlkZSkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dEd1aWRlLmFkZFNlbGZUb1pyKHpyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlU2VsZkZyb21aciA9IGZ1bmN0aW9uICh6cikge1xuICAgICAgICBpZiAoIXRoaXMuX196cikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX196ciA9IG51bGw7XG4gICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB6ci5hbmltYXRpb24ucmVtb3ZlQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2xpcFBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoenIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dENvbnRlbnQucmVtb3ZlU2VsZkZyb21acih6cik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RleHRHdWlkZSkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dEd1aWRlLnJlbW92ZVNlbGZGcm9tWnIoenIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKGtleSwgbG9vcCwgYWxsb3dEaXNjcmV0ZUFuaW1hdGlvbikge1xuICAgICAgICB2YXIgdGFyZ2V0ID0ga2V5ID8gdGhpc1trZXldIDogdGhpcztcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbG9nRXJyb3IoJ1Byb3BlcnR5IFwiJ1xuICAgICAgICAgICAgICAgICAgICArIGtleVxuICAgICAgICAgICAgICAgICAgICArICdcIiBpcyBub3QgZXhpc3RlZCBpbiBlbGVtZW50ICdcbiAgICAgICAgICAgICAgICAgICAgKyB0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKHRhcmdldCwgbG9vcCwgYWxsb3dEaXNjcmV0ZUFuaW1hdGlvbik7XG4gICAgICAgIGtleSAmJiAoYW5pbWF0b3IudGFyZ2V0TmFtZSA9IGtleSk7XG4gICAgICAgIHRoaXMuYWRkQW5pbWF0b3IoYW5pbWF0b3IsIGtleSk7XG4gICAgICAgIHJldHVybiBhbmltYXRvcjtcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmFkZEFuaW1hdG9yID0gZnVuY3Rpb24gKGFuaW1hdG9yLCBrZXkpIHtcbiAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICB2YXIgZWwgPSB0aGlzO1xuICAgICAgICBhbmltYXRvci5kdXJpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZWwudXBkYXRlRHVyaW5nQW5pbWF0aW9uKGtleSk7XG4gICAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IGVsLmFuaW1hdG9ycztcbiAgICAgICAgICAgIHZhciBpZHggPSBpbmRleE9mKGFuaW1hdG9ycywgYW5pbWF0b3IpO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hbmltYXRvcnMucHVzaChhbmltYXRvcik7XG4gICAgICAgIGlmICh6cikge1xuICAgICAgICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB6ciAmJiB6ci53YWtlVXAoKTtcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnVwZGF0ZUR1cmluZ0FuaW1hdGlvbiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy5tYXJrUmVkcmF3KCk7XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKHNjb3BlLCBmb3J3YXJkVG9MYXN0KSB7XG4gICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgdmFyIGxlbiA9IGFuaW1hdG9ycy5sZW5ndGg7XG4gICAgICAgIHZhciBsZWZ0QW5pbWF0b3JzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRvciA9IGFuaW1hdG9yc1tpXTtcbiAgICAgICAgICAgIGlmICghc2NvcGUgfHwgc2NvcGUgPT09IGFuaW1hdG9yLnNjb3BlKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3Iuc3RvcChmb3J3YXJkVG9MYXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlZnRBbmltYXRvcnMucHVzaChhbmltYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltYXRvcnMgPSBsZWZ0QW5pbWF0b3JzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmFuaW1hdGVUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIGNmZywgYW5pbWF0aW9uUHJvcHMpIHtcbiAgICAgICAgYW5pbWF0ZVRvKHRoaXMsIHRhcmdldCwgY2ZnLCBhbmltYXRpb25Qcm9wcyk7XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5hbmltYXRlRnJvbSA9IGZ1bmN0aW9uICh0YXJnZXQsIGNmZywgYW5pbWF0aW9uUHJvcHMpIHtcbiAgICAgICAgYW5pbWF0ZVRvKHRoaXMsIHRhcmdldCwgY2ZnLCBhbmltYXRpb25Qcm9wcywgdHJ1ZSk7XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5fdHJhbnNpdGlvblN0YXRlID0gZnVuY3Rpb24gKHN0YXRlTmFtZSwgdGFyZ2V0LCBjZmcsIGFuaW1hdGlvblByb3BzKSB7XG4gICAgICAgIHZhciBhbmltYXRvcnMgPSBhbmltYXRlVG8odGhpcywgdGFyZ2V0LCBjZmcsIGFuaW1hdGlvblByb3BzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFuaW1hdG9yc1tpXS5fX2Zyb21TdGF0ZVRyYW5zaXRpb24gPSBzdGF0ZU5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5nZXRQYWludFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRWxlbWVudC5pbml0RGVmYXVsdFByb3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsUHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcbiAgICAgICAgZWxQcm90by50eXBlID0gJ2VsZW1lbnQnO1xuICAgICAgICBlbFByb3RvLm5hbWUgPSAnJztcbiAgICAgICAgZWxQcm90by5pZ25vcmUgPVxuICAgICAgICAgICAgZWxQcm90by5zaWxlbnQgPVxuICAgICAgICAgICAgICAgIGVsUHJvdG8uaXNHcm91cCA9XG4gICAgICAgICAgICAgICAgICAgIGVsUHJvdG8uZHJhZ2dhYmxlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsUHJvdG8uZHJhZ2dpbmcgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsUHJvdG8uaWdub3JlQ2xpcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsUHJvdG8uX19pbkhvdmVyID0gZmFsc2U7XG4gICAgICAgIGVsUHJvdG8uX19kaXJ0eSA9IFJFRFJBV19CSVQ7XG4gICAgICAgIHZhciBsb2dzID0ge307XG4gICAgICAgIGZ1bmN0aW9uIGxvZ0RlcHJlY2F0ZWRFcnJvcihrZXksIHhLZXksIHlLZXkpIHtcbiAgICAgICAgICAgIGlmICghbG9nc1trZXkgKyB4S2V5ICsgeUtleV0pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEOiAnXCIgKyBrZXkgKyBcIicgaGFzIGJlZW4gZGVwcmVjYXRlZC4gdXNlICdcIiArIHhLZXkgKyBcIicsICdcIiArIHlLZXkgKyBcIicgaW5zdGVhZFwiKTtcbiAgICAgICAgICAgICAgICBsb2dzW2tleSArIHhLZXkgKyB5S2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlTGVnYWN5UHJvcGVydHkoa2V5LCBwcml2YXRlS2V5LCB4S2V5LCB5S2V5KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxQcm90bywga2V5LCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dEZXByZWNhdGVkRXJyb3Ioa2V5LCB4S2V5LCB5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNbcHJpdmF0ZUtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzW3ByaXZhdGVLZXldID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmhhbmNlQXJyYXkodGhpcywgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1twcml2YXRlS2V5XTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRGVwcmVjYXRlZEVycm9yKGtleSwgeEtleSwgeUtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpc1t4S2V5XSA9IHBvc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1t5S2V5XSA9IHBvc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1twcml2YXRlS2V5XSA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgZW5oYW5jZUFycmF5KHRoaXMsIHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBlbmhhbmNlQXJyYXkoc2VsZiwgcG9zKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBvcywgMCwge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmW3hLZXldO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGZbeEtleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocG9zLCAxLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGZbeUtleV07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZlt5S2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGNyZWF0ZUxlZ2FjeVByb3BlcnR5KCdwb3NpdGlvbicsICdfbGVnYWN5UG9zJywgJ3gnLCAneScpO1xuICAgICAgICAgICAgY3JlYXRlTGVnYWN5UHJvcGVydHkoJ3NjYWxlJywgJ19sZWdhY3lTY2FsZScsICdzY2FsZVgnLCAnc2NhbGVZJyk7XG4gICAgICAgICAgICBjcmVhdGVMZWdhY3lQcm9wZXJ0eSgnb3JpZ2luJywgJ19sZWdhY3lPcmlnaW4nLCAnb3JpZ2luWCcsICdvcmlnaW5ZJyk7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIHJldHVybiBFbGVtZW50O1xufSgpKTtcbm1peGluKEVsZW1lbnQsIEV2ZW50ZnVsKTtcbm1peGluKEVsZW1lbnQsIFRyYW5zZm9ybWFibGUpO1xuZnVuY3Rpb24gYW5pbWF0ZVRvKGFuaW1hdGFibGUsIHRhcmdldCwgY2ZnLCBhbmltYXRpb25Qcm9wcywgcmV2ZXJzZSkge1xuICAgIGNmZyA9IGNmZyB8fCB7fTtcbiAgICB2YXIgYW5pbWF0b3JzID0gW107XG4gICAgYW5pbWF0ZVRvU2hhbGxvdyhhbmltYXRhYmxlLCAnJywgYW5pbWF0YWJsZSwgdGFyZ2V0LCBjZmcsIGFuaW1hdGlvblByb3BzLCBhbmltYXRvcnMsIHJldmVyc2UpO1xuICAgIHZhciBmaW5pc2hDb3VudCA9IGFuaW1hdG9ycy5sZW5ndGg7XG4gICAgdmFyIGRvbmVIYXBwZW5lZCA9IGZhbHNlO1xuICAgIHZhciBjZmdEb25lID0gY2ZnLmRvbmU7XG4gICAgdmFyIGNmZ0Fib3J0ZWQgPSBjZmcuYWJvcnRlZDtcbiAgICB2YXIgZG9uZUNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lSGFwcGVuZWQgPSB0cnVlO1xuICAgICAgICBmaW5pc2hDb3VudC0tO1xuICAgICAgICBpZiAoZmluaXNoQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgZG9uZUhhcHBlbmVkXG4gICAgICAgICAgICAgICAgPyAoY2ZnRG9uZSAmJiBjZmdEb25lKCkpXG4gICAgICAgICAgICAgICAgOiAoY2ZnQWJvcnRlZCAmJiBjZmdBYm9ydGVkKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgYWJvcnRlZENiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmaW5pc2hDb3VudC0tO1xuICAgICAgICBpZiAoZmluaXNoQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgZG9uZUhhcHBlbmVkXG4gICAgICAgICAgICAgICAgPyAoY2ZnRG9uZSAmJiBjZmdEb25lKCkpXG4gICAgICAgICAgICAgICAgOiAoY2ZnQWJvcnRlZCAmJiBjZmdBYm9ydGVkKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWZpbmlzaENvdW50KSB7XG4gICAgICAgIGNmZ0RvbmUgJiYgY2ZnRG9uZSgpO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0b3JzLmxlbmd0aCA+IDAgJiYgY2ZnLmR1cmluZykge1xuICAgICAgICBhbmltYXRvcnNbMF0uZHVyaW5nKGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAgICAgICAgIGNmZy5kdXJpbmcocGVyY2VudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYW5pbWF0b3IgPSBhbmltYXRvcnNbaV07XG4gICAgICAgIGlmIChkb25lQ2IpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yLmRvbmUoZG9uZUNiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWJvcnRlZENiKSB7XG4gICAgICAgICAgICBhbmltYXRvci5hYm9ydGVkKGFib3J0ZWRDYik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5mb3JjZSkge1xuICAgICAgICAgICAgYW5pbWF0b3IuZHVyYXRpb24oY2ZnLmR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBhbmltYXRvci5zdGFydChjZmcuZWFzaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdG9ycztcbn1cbmZ1bmN0aW9uIGNvcHlBcnJTaGFsbG93KHNvdXJjZSwgdGFyZ2V0LCBsZW4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHNvdXJjZVtpXSA9IHRhcmdldFtpXTtcbiAgICB9XG59XG5mdW5jdGlvbiBpczJEQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheUxpa2UodmFsdWVbMF0pO1xufVxuZnVuY3Rpb24gY29weVZhbHVlKHRhcmdldCwgc291cmNlLCBrZXkpIHtcbiAgICBpZiAoaXNBcnJheUxpa2Uoc291cmNlW2tleV0pKSB7XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1R5cGVkQXJyYXkoc291cmNlW2tleV0pKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gc291cmNlW2tleV0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRhcmdldFtrZXldLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBuZXcgKHNvdXJjZVtrZXldLmNvbnN0cnVjdG9yKShsZW4pO1xuICAgICAgICAgICAgICAgIGNvcHlBcnJTaGFsbG93KHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VBcnIgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRBcnIgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgIHZhciBsZW4wID0gc291cmNlQXJyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpczJEQXJyYXkoc291cmNlQXJyKSkge1xuICAgICAgICAgICAgICAgIHZhciBsZW4xID0gc291cmNlQXJyWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldEFycltpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QXJyW2ldID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc291cmNlQXJyW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlBcnJTaGFsbG93KHRhcmdldEFycltpXSwgc291cmNlQXJyW2ldLCBsZW4xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHlBcnJTaGFsbG93KHRhcmdldEFyciwgc291cmNlQXJyLCBsZW4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldEFyci5sZW5ndGggPSBzb3VyY2VBcnIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsdWVTYW1lKHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gdmFsMSA9PT0gdmFsMlxuICAgICAgICB8fCBpc0FycmF5TGlrZSh2YWwxKSAmJiBpc0FycmF5TGlrZSh2YWwyKSAmJiBpczFEQXJyYXlTYW1lKHZhbDEsIHZhbDIpO1xufVxuZnVuY3Rpb24gaXMxREFycmF5U2FtZShhcnIwLCBhcnIxKSB7XG4gICAgdmFyIGxlbiA9IGFycjAubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IGFycjEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoYXJyMFtpXSAhPT0gYXJyMVtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYW5pbWF0ZVRvU2hhbGxvdyhhbmltYXRhYmxlLCB0b3BLZXksIGFuaW1hdGVPYmosIHRhcmdldCwgY2ZnLCBhbmltYXRpb25Qcm9wcywgYW5pbWF0b3JzLCByZXZlcnNlKSB7XG4gICAgdmFyIHRhcmdldEtleXMgPSBrZXlzKHRhcmdldCk7XG4gICAgdmFyIGR1cmF0aW9uID0gY2ZnLmR1cmF0aW9uO1xuICAgIHZhciBkZWxheSA9IGNmZy5kZWxheTtcbiAgICB2YXIgYWRkaXRpdmUgPSBjZmcuYWRkaXRpdmU7XG4gICAgdmFyIHNldFRvRmluYWwgPSBjZmcuc2V0VG9GaW5hbDtcbiAgICB2YXIgYW5pbWF0ZUFsbCA9ICFpc09iamVjdChhbmltYXRpb25Qcm9wcyk7XG4gICAgdmFyIGV4aXN0c0FuaW1hdG9ycyA9IGFuaW1hdGFibGUuYW5pbWF0b3JzO1xuICAgIHZhciBhbmltYXRpb25LZXlzID0gW107XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCB0YXJnZXRLZXlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpbm5lcktleSA9IHRhcmdldEtleXNba107XG4gICAgICAgIHZhciB0YXJnZXRWYWwgPSB0YXJnZXRbaW5uZXJLZXldO1xuICAgICAgICBpZiAodGFyZ2V0VmFsICE9IG51bGwgJiYgYW5pbWF0ZU9ialtpbm5lcktleV0gIT0gbnVsbFxuICAgICAgICAgICAgJiYgKGFuaW1hdGVBbGwgfHwgYW5pbWF0aW9uUHJvcHNbaW5uZXJLZXldKSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHRhcmdldFZhbClcbiAgICAgICAgICAgICAgICAmJiAhaXNBcnJheUxpa2UodGFyZ2V0VmFsKVxuICAgICAgICAgICAgICAgICYmICFpc0dyYWRpZW50T2JqZWN0KHRhcmdldFZhbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9wS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZU9ialtpbm5lcktleV0gPSB0YXJnZXRWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRhYmxlLnVwZGF0ZUR1cmluZ0FuaW1hdGlvbih0b3BLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbmltYXRlVG9TaGFsbG93KGFuaW1hdGFibGUsIGlubmVyS2V5LCBhbmltYXRlT2JqW2lubmVyS2V5XSwgdGFyZ2V0VmFsLCBjZmcsIGFuaW1hdGlvblByb3BzICYmIGFuaW1hdGlvblByb3BzW2lubmVyS2V5XSwgYW5pbWF0b3JzLCByZXZlcnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbktleXMucHVzaChpbm5lcktleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXJldmVyc2UpIHtcbiAgICAgICAgICAgIGFuaW1hdGVPYmpbaW5uZXJLZXldID0gdGFyZ2V0VmFsO1xuICAgICAgICAgICAgYW5pbWF0YWJsZS51cGRhdGVEdXJpbmdBbmltYXRpb24odG9wS2V5KTtcbiAgICAgICAgICAgIGFuaW1hdGlvbktleXMucHVzaChpbm5lcktleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGtleUxlbiA9IGFuaW1hdGlvbktleXMubGVuZ3RoO1xuICAgIGlmICghYWRkaXRpdmUgJiYga2V5TGVuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhpc3RzQW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBleGlzdHNBbmltYXRvcnNbaV07XG4gICAgICAgICAgICBpZiAoYW5pbWF0b3IudGFyZ2V0TmFtZSA9PT0gdG9wS2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFsbEFib3J0ZWQgPSBhbmltYXRvci5zdG9wVHJhY2tzKGFuaW1hdGlvbktleXMpO1xuICAgICAgICAgICAgICAgIGlmIChhbGxBYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBpbmRleE9mKGV4aXN0c0FuaW1hdG9ycywgYW5pbWF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBleGlzdHNBbmltYXRvcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2ZnLmZvcmNlKSB7XG4gICAgICAgIGFuaW1hdGlvbktleXMgPSBmaWx0ZXIoYW5pbWF0aW9uS2V5cywgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gIWlzVmFsdWVTYW1lKHRhcmdldFtrZXldLCBhbmltYXRlT2JqW2tleV0pOyB9KTtcbiAgICAgICAga2V5TGVuID0gYW5pbWF0aW9uS2V5cy5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChrZXlMZW4gPiAwXG4gICAgICAgIHx8IChjZmcuZm9yY2UgJiYgIWFuaW1hdG9ycy5sZW5ndGgpKSB7XG4gICAgICAgIHZhciByZXZlcnRlZFNvdXJjZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHJldmVyc2VkVGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgICB2YXIgc291cmNlQ2xvbmUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICByZXZlcnNlZFRhcmdldCA9IHt9O1xuICAgICAgICAgICAgaWYgKHNldFRvRmluYWwpIHtcbiAgICAgICAgICAgICAgICByZXZlcnRlZFNvdXJjZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbm5lcktleSA9IGFuaW1hdGlvbktleXNbaV07XG4gICAgICAgICAgICAgICAgcmV2ZXJzZWRUYXJnZXRbaW5uZXJLZXldID0gYW5pbWF0ZU9ialtpbm5lcktleV07XG4gICAgICAgICAgICAgICAgaWYgKHNldFRvRmluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0ZWRTb3VyY2VbaW5uZXJLZXldID0gdGFyZ2V0W2lubmVyS2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGVPYmpbaW5uZXJLZXldID0gdGFyZ2V0W2lubmVyS2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2V0VG9GaW5hbCkge1xuICAgICAgICAgICAgc291cmNlQ2xvbmUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5TGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJLZXkgPSBhbmltYXRpb25LZXlzW2ldO1xuICAgICAgICAgICAgICAgIHNvdXJjZUNsb25lW2lubmVyS2V5XSA9IGNsb25lVmFsdWUoYW5pbWF0ZU9ialtpbm5lcktleV0pO1xuICAgICAgICAgICAgICAgIGNvcHlWYWx1ZShhbmltYXRlT2JqLCB0YXJnZXQsIGlubmVyS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoYW5pbWF0ZU9iaiwgZmFsc2UsIGZhbHNlLCBhZGRpdGl2ZSA/IGZpbHRlcihleGlzdHNBbmltYXRvcnMsIGZ1bmN0aW9uIChhbmltYXRvcikgeyByZXR1cm4gYW5pbWF0b3IudGFyZ2V0TmFtZSA9PT0gdG9wS2V5OyB9KSA6IG51bGwpO1xuICAgICAgICBhbmltYXRvci50YXJnZXROYW1lID0gdG9wS2V5O1xuICAgICAgICBpZiAoY2ZnLnNjb3BlKSB7XG4gICAgICAgICAgICBhbmltYXRvci5zY29wZSA9IGNmZy5zY29wZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0VG9GaW5hbCAmJiByZXZlcnRlZFNvdXJjZSkge1xuICAgICAgICAgICAgYW5pbWF0b3Iud2hlbldpdGhLZXlzKDAsIHJldmVydGVkU291cmNlLCBhbmltYXRpb25LZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlQ2xvbmUpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yLndoZW5XaXRoS2V5cygwLCBzb3VyY2VDbG9uZSwgYW5pbWF0aW9uS2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgYW5pbWF0b3Iud2hlbldpdGhLZXlzKGR1cmF0aW9uID09IG51bGwgPyA1MDAgOiBkdXJhdGlvbiwgcmV2ZXJzZSA/IHJldmVyc2VkVGFyZ2V0IDogdGFyZ2V0LCBhbmltYXRpb25LZXlzKS5kZWxheShkZWxheSB8fCAwKTtcbiAgICAgICAgYW5pbWF0YWJsZS5hZGRBbmltYXRvcihhbmltYXRvciwgdG9wS2V5KTtcbiAgICAgICAgYW5pbWF0b3JzLnB1c2goYW5pbWF0b3IpO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEVsZW1lbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///62454\n")},79021:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   W: () => (/* binding */ getTime)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15727);\n/* harmony import */ var _core_Eventful_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(57861);\n/* harmony import */ var _requestAnimationFrame_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45825);\n/* harmony import */ var _Animator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21756);\n\n\n\n\nfunction getTime() {\n    return new Date().getTime();\n}\nvar Animation = (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(Animation, _super);\n    function Animation(opts) {\n        var _this = _super.call(this) || this;\n        _this._running = false;\n        _this._time = 0;\n        _this._pausedTime = 0;\n        _this._pauseStart = 0;\n        _this._paused = false;\n        opts = opts || {};\n        _this.stage = opts.stage || {};\n        return _this;\n    }\n    Animation.prototype.addClip = function (clip) {\n        if (clip.animation) {\n            this.removeClip(clip);\n        }\n        if (!this._head) {\n            this._head = this._tail = clip;\n        }\n        else {\n            this._tail.next = clip;\n            clip.prev = this._tail;\n            clip.next = null;\n            this._tail = clip;\n        }\n        clip.animation = this;\n    };\n    Animation.prototype.addAnimator = function (animator) {\n        animator.animation = this;\n        var clip = animator.getClip();\n        if (clip) {\n            this.addClip(clip);\n        }\n    };\n    Animation.prototype.removeClip = function (clip) {\n        if (!clip.animation) {\n            return;\n        }\n        var prev = clip.prev;\n        var next = clip.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            this._head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            this._tail = prev;\n        }\n        clip.next = clip.prev = clip.animation = null;\n    };\n    Animation.prototype.removeAnimator = function (animator) {\n        var clip = animator.getClip();\n        if (clip) {\n            this.removeClip(clip);\n        }\n        animator.animation = null;\n    };\n    Animation.prototype.update = function (notTriggerFrameAndStageUpdate) {\n        var time = getTime() - this._pausedTime;\n        var delta = time - this._time;\n        var clip = this._head;\n        while (clip) {\n            var nextClip = clip.next;\n            var finished = clip.step(time, delta);\n            if (finished) {\n                clip.ondestroy();\n                this.removeClip(clip);\n                clip = nextClip;\n            }\n            else {\n                clip = nextClip;\n            }\n        }\n        this._time = time;\n        if (!notTriggerFrameAndStageUpdate) {\n            this.trigger(\'frame\', delta);\n            this.stage.update && this.stage.update();\n        }\n    };\n    Animation.prototype._startLoop = function () {\n        var self = this;\n        this._running = true;\n        function step() {\n            if (self._running) {\n                (0,_requestAnimationFrame_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(step);\n                !self._paused && self.update();\n            }\n        }\n        (0,_requestAnimationFrame_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(step);\n    };\n    Animation.prototype.start = function () {\n        if (this._running) {\n            return;\n        }\n        this._time = getTime();\n        this._pausedTime = 0;\n        this._startLoop();\n    };\n    Animation.prototype.stop = function () {\n        this._running = false;\n    };\n    Animation.prototype.pause = function () {\n        if (!this._paused) {\n            this._pauseStart = getTime();\n            this._paused = true;\n        }\n    };\n    Animation.prototype.resume = function () {\n        if (this._paused) {\n            this._pausedTime += getTime() - this._pauseStart;\n            this._paused = false;\n        }\n    };\n    Animation.prototype.clear = function () {\n        var clip = this._head;\n        while (clip) {\n            var nextClip = clip.next;\n            clip.prev = clip.next = clip.animation = null;\n            clip = nextClip;\n        }\n        this._head = this._tail = null;\n    };\n    Animation.prototype.isFinished = function () {\n        return this._head == null;\n    };\n    Animation.prototype.animate = function (target, options) {\n        options = options || {};\n        this.start();\n        var animator = new _Animator_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A(target, options.loop);\n        this.addAnimator(animator);\n        return animator;\n    };\n    return Animation;\n}(_core_Eventful_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A));\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Animation);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkwMjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdGlvbi5qcz9jNGZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IEV2ZW50ZnVsIGZyb20gJy4uL2NvcmUvRXZlbnRmdWwuanMnO1xuaW1wb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tICcuL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyc7XG5pbXBvcnQgQW5pbWF0b3IgZnJvbSAnLi9BbmltYXRvci5qcyc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0VGltZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59XG52YXIgQW5pbWF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5pbWF0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbihvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl90aW1lID0gMDtcbiAgICAgICAgX3RoaXMuX3BhdXNlZFRpbWUgPSAwO1xuICAgICAgICBfdGhpcy5fcGF1c2VTdGFydCA9IDA7XG4gICAgICAgIF90aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIF90aGlzLnN0YWdlID0gb3B0cy5zdGFnZSB8fCB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBbmltYXRpb24ucHJvdG90eXBlLmFkZENsaXAgPSBmdW5jdGlvbiAoY2xpcCkge1xuICAgICAgICBpZiAoY2xpcC5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2xpcChjbGlwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gY2xpcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IGNsaXA7XG4gICAgICAgICAgICBjbGlwLnByZXYgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgY2xpcC5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBjbGlwO1xuICAgICAgICB9XG4gICAgICAgIGNsaXAuYW5pbWF0aW9uID0gdGhpcztcbiAgICB9O1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuYWRkQW5pbWF0b3IgPSBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICAgICAgYW5pbWF0b3IuYW5pbWF0aW9uID0gdGhpcztcbiAgICAgICAgdmFyIGNsaXAgPSBhbmltYXRvci5nZXRDbGlwKCk7XG4gICAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgICAgICB0aGlzLmFkZENsaXAoY2xpcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUucmVtb3ZlQ2xpcCA9IGZ1bmN0aW9uIChjbGlwKSB7XG4gICAgICAgIGlmICghY2xpcC5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldiA9IGNsaXAucHJldjtcbiAgICAgICAgdmFyIG5leHQgPSBjbGlwLm5leHQ7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIG5leHQucHJldiA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBjbGlwLm5leHQgPSBjbGlwLnByZXYgPSBjbGlwLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgfTtcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLnJlbW92ZUFuaW1hdG9yID0gZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgICAgIHZhciBjbGlwID0gYW5pbWF0b3IuZ2V0Q2xpcCgpO1xuICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGlwKGNsaXApO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgfTtcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChub3RUcmlnZ2VyRnJhbWVBbmRTdGFnZVVwZGF0ZSkge1xuICAgICAgICB2YXIgdGltZSA9IGdldFRpbWUoKSAtIHRoaXMuX3BhdXNlZFRpbWU7XG4gICAgICAgIHZhciBkZWx0YSA9IHRpbWUgLSB0aGlzLl90aW1lO1xuICAgICAgICB2YXIgY2xpcCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChjbGlwKSB7XG4gICAgICAgICAgICB2YXIgbmV4dENsaXAgPSBjbGlwLm5leHQ7XG4gICAgICAgICAgICB2YXIgZmluaXNoZWQgPSBjbGlwLnN0ZXAodGltZSwgZGVsdGEpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgY2xpcC5vbmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNsaXAoY2xpcCk7XG4gICAgICAgICAgICAgICAgY2xpcCA9IG5leHRDbGlwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xpcCA9IG5leHRDbGlwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgICAgICBpZiAoIW5vdFRyaWdnZXJGcmFtZUFuZFN0YWdlVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2ZyYW1lJywgZGVsdGEpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS51cGRhdGUgJiYgdGhpcy5zdGFnZS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5fc3RhcnRMb29wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX3J1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgICAgICAgICAgIXNlbGYuX3BhdXNlZCAmJiBzZWxmLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICB9O1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXJ0TG9vcCgpO1xuICAgIH07XG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IGdldFRpbWUoKSAtIHRoaXMuX3BhdXNlU3RhcnQ7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsaXAgPSB0aGlzLl9oZWFkO1xuICAgICAgICB3aGlsZSAoY2xpcCkge1xuICAgICAgICAgICAgdmFyIG5leHRDbGlwID0gY2xpcC5uZXh0O1xuICAgICAgICAgICAgY2xpcC5wcmV2ID0gY2xpcC5uZXh0ID0gY2xpcC5hbmltYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgY2xpcCA9IG5leHRDbGlwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gbnVsbDtcbiAgICB9O1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuaXNGaW5pc2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWQgPT0gbnVsbDtcbiAgICB9O1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKHRhcmdldCwgb3B0aW9ucy5sb29wKTtcbiAgICAgICAgdGhpcy5hZGRBbmltYXRvcihhbmltYXRvcik7XG4gICAgICAgIHJldHVybiBhbmltYXRvcjtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb247XG59KEV2ZW50ZnVsKSk7XG5leHBvcnQgZGVmYXVsdCBBbmltYXRpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///79021\n')},96320:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   w: () => (/* binding */ createCubicEasingFunc)\n/* harmony export */ });\n/* harmony import */ var _core_curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89259);\n/* harmony import */ var _core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n\nvar regexp = /cubic-bezier\\(([0-9,\\.e ]+)\\)/;\nfunction createCubicEasingFunc(cubicEasingStr) {\n    var cubic = cubicEasingStr && regexp.exec(cubicEasingStr);\n    if (cubic) {\n        var points = cubic[1].split(',');\n        var a_1 = +(0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.trim)(points[0]);\n        var b_1 = +(0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.trim)(points[1]);\n        var c_1 = +(0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.trim)(points[2]);\n        var d_1 = +(0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.trim)(points[3]);\n        if (isNaN(a_1 + b_1 + c_1 + d_1)) {\n            return;\n        }\n        var roots_1 = [];\n        return function (p) {\n            return p <= 0\n                ? 0 : p >= 1\n                ? 1\n                : (0,_core_curve_js__WEBPACK_IMPORTED_MODULE_1__/* .cubicRootAt */ ._E)(0, a_1, c_1, 1, p, roots_1) && (0,_core_curve_js__WEBPACK_IMPORTED_MODULE_1__/* .cubicAt */ .Yb)(0, b_1, d_1, 1, roots_1[0]);\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYzMjAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9jdWJpY0Vhc2luZy5qcz84MjRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGN1YmljQXQsIGN1YmljUm9vdEF0IH0gZnJvbSAnLi4vY29yZS9jdXJ2ZS5qcyc7XG5pbXBvcnQgeyB0cmltIH0gZnJvbSAnLi4vY29yZS91dGlsLmpzJztcbnZhciByZWdleHAgPSAvY3ViaWMtYmV6aWVyXFwoKFswLTksXFwuZSBdKylcXCkvO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1YmljRWFzaW5nRnVuYyhjdWJpY0Vhc2luZ1N0cikge1xuICAgIHZhciBjdWJpYyA9IGN1YmljRWFzaW5nU3RyICYmIHJlZ2V4cC5leGVjKGN1YmljRWFzaW5nU3RyKTtcbiAgICBpZiAoY3ViaWMpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IGN1YmljWzFdLnNwbGl0KCcsJyk7XG4gICAgICAgIHZhciBhXzEgPSArdHJpbShwb2ludHNbMF0pO1xuICAgICAgICB2YXIgYl8xID0gK3RyaW0ocG9pbnRzWzFdKTtcbiAgICAgICAgdmFyIGNfMSA9ICt0cmltKHBvaW50c1syXSk7XG4gICAgICAgIHZhciBkXzEgPSArdHJpbShwb2ludHNbM10pO1xuICAgICAgICBpZiAoaXNOYU4oYV8xICsgYl8xICsgY18xICsgZF8xKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb290c18xID0gW107XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgcmV0dXJuIHAgPD0gMFxuICAgICAgICAgICAgICAgID8gMCA6IHAgPj0gMVxuICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgIDogY3ViaWNSb290QXQoMCwgYV8xLCBjXzEsIDEsIHAsIHJvb3RzXzEpICYmIGN1YmljQXQoMCwgYl8xLCBkXzEsIDEsIHJvb3RzXzFbMF0pO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///96320\n")}}]);