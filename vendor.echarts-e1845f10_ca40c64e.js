"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[5990],{1854:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74179);\n/* harmony import */ var _view_Component_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(59109);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _MarkerModel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82802);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n/* harmony import */ var _util_states_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34833);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\nvar inner = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nvar MarkerView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .C6)(MarkerView, _super);\n  function MarkerView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = MarkerView.type;\n    return _this;\n  }\n  MarkerView.prototype.init = function () {\n    this.markerGroupMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.createHashMap)();\n  };\n  MarkerView.prototype.render = function (markerModel, ecModel, api) {\n    var _this = this;\n    var markerGroupMap = this.markerGroupMap;\n    markerGroupMap.each(function (item) {\n      inner(item).keep = false;\n    });\n    ecModel.eachSeries(function (seriesModel) {\n      var markerModel = _MarkerModel_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.getMarkerModelFromSeries(seriesModel, _this.type);\n      markerModel && _this.renderSeries(seriesModel, markerModel, ecModel, api);\n    });\n    markerGroupMap.each(function (item) {\n      !inner(item).keep && _this.group.remove(item.group);\n    });\n  };\n  MarkerView.prototype.markKeep = function (drawGroup) {\n    inner(drawGroup).keep = true;\n  };\n  MarkerView.prototype.toggleBlurSeries = function (seriesModelList, isBlur) {\n    var _this = this;\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(seriesModelList, function (seriesModel) {\n      var markerModel = _MarkerModel_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.getMarkerModelFromSeries(seriesModel, _this.type);\n      if (markerModel) {\n        var data = markerModel.getData();\n        data.eachItemGraphicEl(function (el) {\n          if (el) {\n            isBlur ? (0,_util_states_js__WEBPACK_IMPORTED_MODULE_4__/* .enterBlur */ .QX)(el) : (0,_util_states_js__WEBPACK_IMPORTED_MODULE_4__/* .leaveBlur */ .JC)(el);\n          }\n        });\n      }\n    });\n  };\n  MarkerView.type = \'marker\';\n  return MarkerView;\n}(_view_Component_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MarkerView);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg1NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya2VyVmlldy5qcz9kOTE2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQ29tcG9uZW50VmlldyBmcm9tICcuLi8uLi92aWV3L0NvbXBvbmVudC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoTWFwLCBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBNYXJrZXJNb2RlbCBmcm9tICcuL01hcmtlck1vZGVsLmpzJztcbmltcG9ydCB7IG1ha2VJbm5lciB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xuaW1wb3J0IHsgZW50ZXJCbHVyLCBsZWF2ZUJsdXIgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbnZhciBNYXJrZXJWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKE1hcmtlclZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIE1hcmtlclZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IE1hcmtlclZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgTWFya2VyVmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1hcmtlckdyb3VwTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuICB9O1xuICBNYXJrZXJWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAobWFya2VyTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIG1hcmtlckdyb3VwTWFwID0gdGhpcy5tYXJrZXJHcm91cE1hcDtcbiAgICBtYXJrZXJHcm91cE1hcC5lYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpbm5lcihpdGVtKS5rZWVwID0gZmFsc2U7XG4gICAgfSk7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIG1hcmtlck1vZGVsID0gTWFya2VyTW9kZWwuZ2V0TWFya2VyTW9kZWxGcm9tU2VyaWVzKHNlcmllc01vZGVsLCBfdGhpcy50eXBlKTtcbiAgICAgIG1hcmtlck1vZGVsICYmIF90aGlzLnJlbmRlclNlcmllcyhzZXJpZXNNb2RlbCwgbWFya2VyTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgfSk7XG4gICAgbWFya2VyR3JvdXBNYXAuZWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgIWlubmVyKGl0ZW0pLmtlZXAgJiYgX3RoaXMuZ3JvdXAucmVtb3ZlKGl0ZW0uZ3JvdXApO1xuICAgIH0pO1xuICB9O1xuICBNYXJrZXJWaWV3LnByb3RvdHlwZS5tYXJrS2VlcCA9IGZ1bmN0aW9uIChkcmF3R3JvdXApIHtcbiAgICBpbm5lcihkcmF3R3JvdXApLmtlZXAgPSB0cnVlO1xuICB9O1xuICBNYXJrZXJWaWV3LnByb3RvdHlwZS50b2dnbGVCbHVyU2VyaWVzID0gZnVuY3Rpb24gKHNlcmllc01vZGVsTGlzdCwgaXNCbHVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBlYWNoKHNlcmllc01vZGVsTGlzdCwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgbWFya2VyTW9kZWwgPSBNYXJrZXJNb2RlbC5nZXRNYXJrZXJNb2RlbEZyb21TZXJpZXMoc2VyaWVzTW9kZWwsIF90aGlzLnR5cGUpO1xuICAgICAgaWYgKG1hcmtlck1vZGVsKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWFya2VyTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgaXNCbHVyID8gZW50ZXJCbHVyKGVsKSA6IGxlYXZlQmx1cihlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgTWFya2VyVmlldy50eXBlID0gJ21hcmtlcic7XG4gIHJldHVybiBNYXJrZXJWaWV3O1xufShDb21wb25lbnRWaWV3KTtcbmV4cG9ydCBkZWZhdWx0IE1hcmtlclZpZXc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1854\n')},2400:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   P: () => (/* binding */ makeBackground),\n/* harmony export */   Z: () => (/* binding */ layout)\n/* harmony export */ });\n/* harmony import */ var _util_layout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34253);\n/* harmony import */ var _util_format_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83412);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30010);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// @ts-nocheck\n\n\n\n/**\r\n * Layout list like component.\r\n * It will box layout each items in group of component and then position the whole group in the viewport\r\n * @param {module:zrender/group/Group} group\r\n * @param {module:echarts/model/Component} componentModel\r\n * @param {module:echarts/ExtensionAPI}\r\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = (0,_util_layout_js__WEBPACK_IMPORTED_MODULE_0__/* .getLayoutRect */ .dV)(boxLayoutParams, viewportSize, padding);\n  (0,_util_layout_js__WEBPACK_IMPORTED_MODULE_0__/* .box */ .aP)(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  (0,_util_layout_js__WEBPACK_IMPORTED_MODULE_0__/* .positionElement */ .m$)(group, boxLayoutParams, viewportSize, padding);\n}\nfunction makeBackground(rect, componentModel) {\n  var padding = _util_format_js__WEBPACK_IMPORTED_MODULE_1__/* .normalizeCssArray */ .QX(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  rect = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  });\n  // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n  return rect;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQwMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvbGlzdENvbXBvbmVudC5qcz9hODQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLy8gQHRzLW5vY2hlY2tcbmltcG9ydCB7IGdldExheW91dFJlY3QsIGJveCBhcyBsYXlvdXRCb3gsIHBvc2l0aW9uRWxlbWVudCB9IGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0LmpzJztcbmltcG9ydCAqIGFzIGZvcm1hdFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9mb3JtYXQuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuLyoqXHJcbiAqIExheW91dCBsaXN0IGxpa2UgY29tcG9uZW50LlxyXG4gKiBJdCB3aWxsIGJveCBsYXlvdXQgZWFjaCBpdGVtcyBpbiBncm91cCBvZiBjb21wb25lbnQgYW5kIHRoZW4gcG9zaXRpb24gdGhlIHdob2xlIGdyb3VwIGluIHRoZSB2aWV3cG9ydFxyXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyb3VwL0dyb3VwfSBncm91cFxyXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gY29tcG9uZW50TW9kZWxcclxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxheW91dChncm91cCwgY29tcG9uZW50TW9kZWwsIGFwaSkge1xuICB2YXIgYm94TGF5b3V0UGFyYW1zID0gY29tcG9uZW50TW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCk7XG4gIHZhciBwYWRkaW5nID0gY29tcG9uZW50TW9kZWwuZ2V0KCdwYWRkaW5nJyk7XG4gIHZhciB2aWV3cG9ydFNpemUgPSB7XG4gICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gIH07XG4gIHZhciByZWN0ID0gZ2V0TGF5b3V0UmVjdChib3hMYXlvdXRQYXJhbXMsIHZpZXdwb3J0U2l6ZSwgcGFkZGluZyk7XG4gIGxheW91dEJveChjb21wb25lbnRNb2RlbC5nZXQoJ29yaWVudCcpLCBncm91cCwgY29tcG9uZW50TW9kZWwuZ2V0KCdpdGVtR2FwJyksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgcG9zaXRpb25FbGVtZW50KGdyb3VwLCBib3hMYXlvdXRQYXJhbXMsIHZpZXdwb3J0U2l6ZSwgcGFkZGluZyk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZUJhY2tncm91bmQocmVjdCwgY29tcG9uZW50TW9kZWwpIHtcbiAgdmFyIHBhZGRpbmcgPSBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KGNvbXBvbmVudE1vZGVsLmdldCgncGFkZGluZycpKTtcbiAgdmFyIHN0eWxlID0gY29tcG9uZW50TW9kZWwuZ2V0SXRlbVN0eWxlKFsnY29sb3InLCAnb3BhY2l0eSddKTtcbiAgc3R5bGUuZmlsbCA9IGNvbXBvbmVudE1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG4gIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICBzaGFwZToge1xuICAgICAgeDogcmVjdC54IC0gcGFkZGluZ1szXSxcbiAgICAgIHk6IHJlY3QueSAtIHBhZGRpbmdbMF0sXG4gICAgICB3aWR0aDogcmVjdC53aWR0aCArIHBhZGRpbmdbMV0gKyBwYWRkaW5nWzNdLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCArIHBhZGRpbmdbMF0gKyBwYWRkaW5nWzJdLFxuICAgICAgcjogY29tcG9uZW50TW9kZWwuZ2V0KCdib3JkZXJSYWRpdXMnKVxuICAgIH0sXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIHNpbGVudDogdHJ1ZSxcbiAgICB6MjogLTFcbiAgfSk7XG4gIC8vIEZJWE1FXG4gIC8vIGBzdWJQaXhlbE9wdGltaXplUmVjdGAgbWF5IGJyaW5nIHNvbWUgZ2FwIGJldHdlZW4gZWRnZSBvZiB2aWV3cGFydFxuICAvLyBhbmQgYmFja2dyb3VuZCByZWN0IHdoZW4gc2V0dGluZyBsaWtlIGBsZWZ0OiAwYCwgYHRvcDogMGAuXG4gIC8vIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZVJlY3QocmVjdCk7XG4gIHJldHVybiByZWN0O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2400\n")},8027:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _RoamController_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(81722);\n/* harmony import */ var _component_helper_roamHelper_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(56366);\n/* harmony import */ var _component_helper_cursorHelper_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(72589);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43870);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5638);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(52505);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(39195);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82591);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(43199);\n/* harmony import */ var _util_states_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(34833);\n/* harmony import */ var _coord_geo_geoSourceManager_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(76311);\n/* harmony import */ var _util_component_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12616);\n/* harmony import */ var _label_labelStyle_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(89632);\n/* harmony import */ var _util_innerStore_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(69622);\n/* harmony import */ var _util_decal_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(23538);\n/* harmony import */ var zrender_lib_graphic_Displayable_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(71519);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * Only these tags enable use `itemStyle` if they are named in SVG.\r\n * Other tags like <text> <tspan> <image> might not suitable for `itemStyle`.\r\n * They will not be considered to be styled until some requirements come.\r\n */\nvar OPTION_STYLE_ENABLED_TAGS = ['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path'];\nvar OPTION_STYLE_ENABLED_TAG_MAP = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap(OPTION_STYLE_ENABLED_TAGS);\nvar STATE_TRIGGER_TAG_MAP = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(['g']));\nvar LABEL_HOST_MAP = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(['g']));\nvar mapLabelRaw = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .makeInner */ .$r)();\nfunction getFixedItemStyle(model) {\n  var itemStyle = model.getItemStyle();\n  var areaColor = model.get('areaColor');\n  // If user want the color not to be changed when hover,\n  // they should both set areaColor and color to be null.\n  if (areaColor != null) {\n    itemStyle.fill = areaColor;\n  }\n  return itemStyle;\n}\n// Only stroke can be used for line.\n// Using fill in style if stroke not exits.\n// TODO Not sure yet. Perhaps a separate `lineStyle`?\nfunction fixLineStyle(styleHost) {\n  var style = styleHost.style;\n  if (style) {\n    style.stroke = style.stroke || style.fill;\n    style.fill = null;\n  }\n}\nvar MapDraw = /** @class */function () {\n  function MapDraw(api) {\n    var group = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A();\n    this.uid = (0,_util_component_js__WEBPACK_IMPORTED_MODULE_3__/* .getUID */ .$Q)('ec_map_draw');\n    this._controller = new _RoamController_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A(api.getZr());\n    this._controllerHost = {\n      target: group\n    };\n    this.group = group;\n    group.add(this._regionsGroup = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A());\n    group.add(this._svgGroup = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A());\n  }\n  MapDraw.prototype.draw = function (mapOrGeoModel, ecModel, api, fromView, payload) {\n    var isGeo = mapOrGeoModel.mainType === 'geo';\n    // Map series has data. GEO model that controlled by map series\n    // will be assigned with map data. Other GEO model has no data.\n    var data = mapOrGeoModel.getData && mapOrGeoModel.getData();\n    isGeo && ecModel.eachComponent({\n      mainType: 'series',\n      subType: 'map'\n    }, function (mapSeries) {\n      if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {\n        data = mapSeries.getData();\n      }\n    });\n    var geo = mapOrGeoModel.coordinateSystem;\n    var regionsGroup = this._regionsGroup;\n    var group = this.group;\n    var transformInfo = geo.getTransformInfo();\n    var transformInfoRaw = transformInfo.raw;\n    var transformInfoRoam = transformInfo.roam;\n    // No animation when first draw or in action\n    var isFirstDraw = !regionsGroup.childAt(0) || payload;\n    if (isFirstDraw) {\n      group.x = transformInfoRoam.x;\n      group.y = transformInfoRoam.y;\n      group.scaleX = transformInfoRoam.scaleX;\n      group.scaleY = transformInfoRoam.scaleY;\n      group.dirty();\n    } else {\n      _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__/* .updateProps */ .oi(group, transformInfoRoam, mapOrGeoModel);\n    }\n    var isVisualEncodedByVisualMap = data && data.getVisual('visualMeta') && data.getVisual('visualMeta').length > 0;\n    var viewBuildCtx = {\n      api: api,\n      geo: geo,\n      mapOrGeoModel: mapOrGeoModel,\n      data: data,\n      isVisualEncodedByVisualMap: isVisualEncodedByVisualMap,\n      isGeo: isGeo,\n      transformInfoRaw: transformInfoRaw\n    };\n    if (geo.resourceType === 'geoJSON') {\n      this._buildGeoJSON(viewBuildCtx);\n    } else if (geo.resourceType === 'geoSVG') {\n      this._buildSVG(viewBuildCtx);\n    }\n    this._updateController(mapOrGeoModel, ecModel, api);\n    this._updateMapSelectHandler(mapOrGeoModel, regionsGroup, api, fromView);\n  };\n  MapDraw.prototype._buildGeoJSON = function (viewBuildCtx) {\n    var regionsGroupByName = this._regionsGroupByName = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap();\n    var regionsInfoByName = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap();\n    var regionsGroup = this._regionsGroup;\n    var transformInfoRaw = viewBuildCtx.transformInfoRaw;\n    var mapOrGeoModel = viewBuildCtx.mapOrGeoModel;\n    var data = viewBuildCtx.data;\n    var projection = viewBuildCtx.geo.projection;\n    var projectionStream = projection && projection.stream;\n    function transformPoint(point, project) {\n      if (project) {\n        // projection may return null point.\n        point = project(point);\n      }\n      return point && [point[0] * transformInfoRaw.scaleX + transformInfoRaw.x, point[1] * transformInfoRaw.scaleY + transformInfoRaw.y];\n    }\n    ;\n    function transformPolygonPoints(inPoints) {\n      var outPoints = [];\n      // If projectionStream is provided. Use it instead of single point project.\n      var project = !projectionStream && projection && projection.project;\n      for (var i = 0; i < inPoints.length; ++i) {\n        var newPt = transformPoint(inPoints[i], project);\n        newPt && outPoints.push(newPt);\n      }\n      return outPoints;\n    }\n    function getPolyShape(points) {\n      return {\n        shape: {\n          points: transformPolygonPoints(points)\n        }\n      };\n    }\n    regionsGroup.removeAll();\n    // Only when the resource is GeoJSON, there is `geo.regions`.\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(viewBuildCtx.geo.regions, function (region) {\n      var regionName = region.name;\n      // Consider in GeoJson properties.name may be duplicated, for example,\n      // there is multiple region named \"United Kindom\" or \"France\" (so many\n      // colonies). And it is not appropriate to merge them in geo, which\n      // will make them share the same label and bring trouble in label\n      // location calculation.\n      var regionGroup = regionsGroupByName.get(regionName);\n      var _a = regionsInfoByName.get(regionName) || {},\n        dataIdx = _a.dataIdx,\n        regionModel = _a.regionModel;\n      if (!regionGroup) {\n        regionGroup = regionsGroupByName.set(regionName, new _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A());\n        regionsGroup.add(regionGroup);\n        dataIdx = data ? data.indexOfName(regionName) : null;\n        regionModel = viewBuildCtx.isGeo ? mapOrGeoModel.getRegionModel(regionName) : data ? data.getItemModel(dataIdx) : null;\n        var silent = regionModel.get('silent', true);\n        silent != null && (regionGroup.silent = silent);\n        regionsInfoByName.set(regionName, {\n          dataIdx: dataIdx,\n          regionModel: regionModel\n        });\n      }\n      var polygonSubpaths = [];\n      var polylineSubpaths = [];\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(region.geometries, function (geometry) {\n        // Polygon and MultiPolygon\n        if (geometry.type === 'polygon') {\n          var polys = [geometry.exterior].concat(geometry.interiors || []);\n          if (projectionStream) {\n            polys = projectPolys(polys, projectionStream);\n          }\n          zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(polys, function (poly) {\n            polygonSubpaths.push(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A(getPolyShape(poly)));\n          });\n        }\n        // LineString and MultiLineString\n        else {\n          var points = geometry.points;\n          if (projectionStream) {\n            points = projectPolys(points, projectionStream, true);\n          }\n          zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(points, function (points) {\n            polylineSubpaths.push(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .A(getPolyShape(points)));\n          });\n        }\n      });\n      var centerPt = transformPoint(region.getCenter(), projection && projection.project);\n      function createCompoundPath(subpaths, isLine) {\n        if (!subpaths.length) {\n          return;\n        }\n        var compoundPath = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .A({\n          culling: true,\n          segmentIgnoreThreshold: 1,\n          shape: {\n            paths: subpaths\n          }\n        });\n        regionGroup.add(compoundPath);\n        applyOptionStyleForRegion(viewBuildCtx, compoundPath, dataIdx, regionModel);\n        resetLabelForRegion(viewBuildCtx, compoundPath, regionName, regionModel, mapOrGeoModel, dataIdx, centerPt);\n        if (isLine) {\n          fixLineStyle(compoundPath);\n          zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(compoundPath.states, fixLineStyle);\n        }\n      }\n      createCompoundPath(polygonSubpaths);\n      createCompoundPath(polylineSubpaths, true);\n    });\n    // Ensure children have been added to `regionGroup` before calling them.\n    regionsGroupByName.each(function (regionGroup, regionName) {\n      var _a = regionsInfoByName.get(regionName),\n        dataIdx = _a.dataIdx,\n        regionModel = _a.regionModel;\n      resetEventTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel, dataIdx);\n      resetTooltipForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);\n      resetStateTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);\n    }, this);\n  };\n  MapDraw.prototype._buildSVG = function (viewBuildCtx) {\n    var mapName = viewBuildCtx.geo.map;\n    var transformInfoRaw = viewBuildCtx.transformInfoRaw;\n    this._svgGroup.x = transformInfoRaw.x;\n    this._svgGroup.y = transformInfoRaw.y;\n    this._svgGroup.scaleX = transformInfoRaw.scaleX;\n    this._svgGroup.scaleY = transformInfoRaw.scaleY;\n    if (this._svgResourceChanged(mapName)) {\n      this._freeSVG();\n      this._useSVG(mapName);\n    }\n    var svgDispatcherMap = this._svgDispatcherMap = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap();\n    var focusSelf = false;\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(this._svgGraphicRecord.named, function (namedItem) {\n      // Note that we also allow different elements have the same name.\n      // For example, a glyph of a city and the label of the city have\n      // the same name and their tooltip info can be defined in a single\n      // region option.\n      var regionName = namedItem.name;\n      var mapOrGeoModel = viewBuildCtx.mapOrGeoModel;\n      var data = viewBuildCtx.data;\n      var svgNodeTagLower = namedItem.svgNodeTagLower;\n      var el = namedItem.el;\n      var dataIdx = data ? data.indexOfName(regionName) : null;\n      var regionModel = mapOrGeoModel.getRegionModel(regionName);\n      if (OPTION_STYLE_ENABLED_TAG_MAP.get(svgNodeTagLower) != null && el instanceof zrender_lib_graphic_Displayable_js__WEBPACK_IMPORTED_MODULE_9__/* [\"default\"] */ .Ay) {\n        applyOptionStyleForRegion(viewBuildCtx, el, dataIdx, regionModel);\n      }\n      if (el instanceof zrender_lib_graphic_Displayable_js__WEBPACK_IMPORTED_MODULE_9__/* [\"default\"] */ .Ay) {\n        el.culling = true;\n      }\n      var silent = regionModel.get('silent', true);\n      silent != null && (el.silent = silent);\n      // We do not know how the SVG like so we'd better not to change z2.\n      // Otherwise it might bring some unexpected result. For example,\n      // an area hovered that make some inner city can not be clicked.\n      el.z2EmphasisLift = 0;\n      // If self named:\n      if (!namedItem.namedFrom) {\n        // label should batter to be displayed based on the center of <g>\n        // if it is named rather than displayed on each child.\n        if (LABEL_HOST_MAP.get(svgNodeTagLower) != null) {\n          resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, null);\n        }\n        resetEventTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx);\n        resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);\n        if (STATE_TRIGGER_TAG_MAP.get(svgNodeTagLower) != null) {\n          var focus_1 = resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);\n          if (focus_1 === 'self') {\n            focusSelf = true;\n          }\n          var els = svgDispatcherMap.get(regionName) || svgDispatcherMap.set(regionName, []);\n          els.push(el);\n        }\n      }\n    }, this);\n    this._enableBlurEntireSVG(focusSelf, viewBuildCtx);\n  };\n  MapDraw.prototype._enableBlurEntireSVG = function (focusSelf, viewBuildCtx) {\n    // It's a little complicated to support blurring the entire geoSVG in series-map.\n    // So do not support it until some requirements come.\n    // At present, in series-map, only regions can be blurred.\n    if (focusSelf && viewBuildCtx.isGeo) {\n      var blurStyle = viewBuildCtx.mapOrGeoModel.getModel(['blur', 'itemStyle']).getItemStyle();\n      // Only support `opacity` here. Because not sure that other props are suitable for\n      // all of the elements generated by SVG (especially for Text/TSpan/Image/... ).\n      var opacity_1 = blurStyle.opacity;\n      this._svgGraphicRecord.root.traverse(function (el) {\n        if (!el.isGroup) {\n          // PENDING: clear those settings to SVG elements when `_freeSVG`.\n          // (Currently it happen not to be needed.)\n          (0,_util_states_js__WEBPACK_IMPORTED_MODULE_10__/* .setDefaultStateProxy */ .DW)(el);\n          var style = el.ensureState('blur').style || {};\n          // Do not overwrite the region style that already set from region option.\n          if (style.opacity == null && opacity_1 != null) {\n            style.opacity = opacity_1;\n          }\n          // If `ensureState('blur').style = {}`, there will be default opacity.\n          // Enable `stateTransition` (animation).\n          el.ensureState('emphasis');\n        }\n      });\n    }\n  };\n  MapDraw.prototype.remove = function () {\n    this._regionsGroup.removeAll();\n    this._regionsGroupByName = null;\n    this._svgGroup.removeAll();\n    this._freeSVG();\n    this._controller.dispose();\n    this._controllerHost = null;\n  };\n  MapDraw.prototype.findHighDownDispatchers = function (name, geoModel) {\n    if (name == null) {\n      return [];\n    }\n    var geo = geoModel.coordinateSystem;\n    if (geo.resourceType === 'geoJSON') {\n      var regionsGroupByName = this._regionsGroupByName;\n      if (regionsGroupByName) {\n        var regionGroup = regionsGroupByName.get(name);\n        return regionGroup ? [regionGroup] : [];\n      }\n    } else if (geo.resourceType === 'geoSVG') {\n      return this._svgDispatcherMap && this._svgDispatcherMap.get(name) || [];\n    }\n  };\n  MapDraw.prototype._svgResourceChanged = function (mapName) {\n    return this._svgMapName !== mapName;\n  };\n  MapDraw.prototype._useSVG = function (mapName) {\n    var resource = _coord_geo_geoSourceManager_js__WEBPACK_IMPORTED_MODULE_11__/* [\"default\"] */ .A.getGeoResource(mapName);\n    if (resource && resource.type === 'geoSVG') {\n      var svgGraphic = resource.useGraphic(this.uid);\n      this._svgGroup.add(svgGraphic.root);\n      this._svgGraphicRecord = svgGraphic;\n      this._svgMapName = mapName;\n    }\n  };\n  MapDraw.prototype._freeSVG = function () {\n    var mapName = this._svgMapName;\n    if (mapName == null) {\n      return;\n    }\n    var resource = _coord_geo_geoSourceManager_js__WEBPACK_IMPORTED_MODULE_11__/* [\"default\"] */ .A.getGeoResource(mapName);\n    if (resource && resource.type === 'geoSVG') {\n      resource.freeGraphic(this.uid);\n    }\n    this._svgGraphicRecord = null;\n    this._svgDispatcherMap = null;\n    this._svgGroup.removeAll();\n    this._svgMapName = null;\n  };\n  MapDraw.prototype._updateController = function (mapOrGeoModel, ecModel, api) {\n    var geo = mapOrGeoModel.coordinateSystem;\n    var controller = this._controller;\n    var controllerHost = this._controllerHost;\n    // @ts-ignore FIXME:TS\n    controllerHost.zoomLimit = mapOrGeoModel.get('scaleLimit');\n    controllerHost.zoom = geo.getZoom();\n    // roamType is will be set default true if it is null\n    // @ts-ignore FIXME:TS\n    controller.enable(mapOrGeoModel.get('roam') || false);\n    var mainType = mapOrGeoModel.mainType;\n    function makeActionBase() {\n      var action = {\n        type: 'geoRoam',\n        componentType: mainType\n      };\n      action[mainType + 'Id'] = mapOrGeoModel.id;\n      return action;\n    }\n    controller.off('pan').on('pan', function (e) {\n      this._mouseDownFlag = false;\n      _component_helper_roamHelper_js__WEBPACK_IMPORTED_MODULE_12__/* .updateViewOnPan */ .t(controllerHost, e.dx, e.dy);\n      api.dispatchAction(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend(makeActionBase(), {\n        dx: e.dx,\n        dy: e.dy,\n        animation: {\n          duration: 0\n        }\n      }));\n    }, this);\n    controller.off('zoom').on('zoom', function (e) {\n      this._mouseDownFlag = false;\n      _component_helper_roamHelper_js__WEBPACK_IMPORTED_MODULE_12__/* .updateViewOnZoom */ .x(controllerHost, e.scale, e.originX, e.originY);\n      api.dispatchAction(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend(makeActionBase(), {\n        totalZoom: controllerHost.zoom,\n        zoom: e.scale,\n        originX: e.originX,\n        originY: e.originY,\n        animation: {\n          duration: 0\n        }\n      }));\n    }, this);\n    controller.setPointerChecker(function (e, x, y) {\n      return geo.containPoint([x, y]) && !(0,_component_helper_cursorHelper_js__WEBPACK_IMPORTED_MODULE_13__/* .onIrrelevantElement */ .I)(e, api, mapOrGeoModel);\n    });\n  };\n  /**\r\n   * FIXME: this is a temporarily workaround.\r\n   * When `geoRoam` the elements need to be reset in `MapView['render']`, because the props like\r\n   * `ignore` might have been modified by `LabelManager`, and `LabelManager#addLabelsOfSeries`\r\n   * will subsequently cache `defaultAttr` like `ignore`. If do not do this reset, the modified\r\n   * props will have no chance to be restored.\r\n   * Note: This reset should be after `clearStates` in `renderSeries` because `useStates` in\r\n   * `renderSeries` will cache the modified `ignore` to `el._normalState`.\r\n   * TODO:\r\n   * Use clone/immutable in `LabelManager`?\r\n   */\n  MapDraw.prototype.resetForLabelLayout = function () {\n    this.group.traverse(function (el) {\n      var label = el.getTextContent();\n      if (label) {\n        label.ignore = mapLabelRaw(label).ignore;\n      }\n    });\n  };\n  MapDraw.prototype._updateMapSelectHandler = function (mapOrGeoModel, regionsGroup, api, fromView) {\n    var mapDraw = this;\n    regionsGroup.off('mousedown');\n    regionsGroup.off('click');\n    // @ts-ignore FIXME:TS resolve type conflict\n    if (mapOrGeoModel.get('selectedMode')) {\n      regionsGroup.on('mousedown', function () {\n        mapDraw._mouseDownFlag = true;\n      });\n      regionsGroup.on('click', function (e) {\n        if (!mapDraw._mouseDownFlag) {\n          return;\n        }\n        mapDraw._mouseDownFlag = false;\n      });\n    }\n  };\n  return MapDraw;\n}();\n;\nfunction applyOptionStyleForRegion(viewBuildCtx, el, dataIndex, regionModel) {\n  // All of the path are using `itemStyle`, because\n  // (1) Some SVG also use fill on polyline (The different between\n  // polyline and polygon is \"open\" or \"close\" but not fill or not).\n  // (2) For the common props like opacity, if some use itemStyle\n  // and some use `lineStyle`, it might confuse users.\n  // (3) Most SVG use <path>, where can not detect whether to draw a \"line\"\n  // or a filled shape, so use `itemStyle` for <path>.\n  var normalStyleModel = regionModel.getModel('itemStyle');\n  var emphasisStyleModel = regionModel.getModel(['emphasis', 'itemStyle']);\n  var blurStyleModel = regionModel.getModel(['blur', 'itemStyle']);\n  var selectStyleModel = regionModel.getModel(['select', 'itemStyle']);\n  // NOTE: DON'T use 'style' in visual when drawing map.\n  // This component is used for drawing underlying map for both geo component and map series.\n  var normalStyle = getFixedItemStyle(normalStyleModel);\n  var emphasisStyle = getFixedItemStyle(emphasisStyleModel);\n  var selectStyle = getFixedItemStyle(selectStyleModel);\n  var blurStyle = getFixedItemStyle(blurStyleModel);\n  // Update the itemStyle if has data visual\n  var data = viewBuildCtx.data;\n  if (data) {\n    // Only visual color of each item will be used. It can be encoded by visualMap\n    // But visual color of series is used in symbol drawing\n    // Visual color for each series is for the symbol draw\n    var style = data.getItemVisual(dataIndex, 'style');\n    var decal = data.getItemVisual(dataIndex, 'decal');\n    if (viewBuildCtx.isVisualEncodedByVisualMap && style.fill) {\n      normalStyle.fill = style.fill;\n    }\n    if (decal) {\n      normalStyle.decal = (0,_util_decal_js__WEBPACK_IMPORTED_MODULE_14__/* .createOrUpdatePatternFromDecal */ .w)(decal, viewBuildCtx.api);\n    }\n  }\n  // SVG text, tspan and image can be named but not supporeted\n  // to be styled by region option yet.\n  el.setStyle(normalStyle);\n  el.style.strokeNoScale = true;\n  el.ensureState('emphasis').style = emphasisStyle;\n  el.ensureState('select').style = selectStyle;\n  el.ensureState('blur').style = blurStyle;\n  // Enable blur\n  (0,_util_states_js__WEBPACK_IMPORTED_MODULE_10__/* .setDefaultStateProxy */ .DW)(el);\n}\nfunction resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel,\n// Exist only if `viewBuildCtx.data` exists.\ndataIdx,\n// If labelXY not provided, use `textConfig.position: 'inside'`\nlabelXY) {\n  var data = viewBuildCtx.data;\n  var isGeo = viewBuildCtx.isGeo;\n  var isDataNaN = data && isNaN(data.get(data.mapDimension('value'), dataIdx));\n  var itemLayout = data && data.getItemLayout(dataIdx);\n  // In the following cases label will be drawn\n  // 1. In map series and data value is NaN\n  // 2. In geo component\n  // 3. Region has no series legendIcon, which will be add a showLabel flag in mapSymbolLayout\n  if (isGeo || isDataNaN || itemLayout && itemLayout.showLabel) {\n    var query = !isGeo ? dataIdx : regionName;\n    var labelFetcher = void 0;\n    // Consider dataIdx not found.\n    if (!data || dataIdx >= 0) {\n      labelFetcher = mapOrGeoModel;\n    }\n    var specifiedTextOpt = labelXY ? {\n      normal: {\n        align: 'center',\n        verticalAlign: 'middle'\n      }\n    } : null;\n    // Caveat: must be called after `setDefaultStateProxy(el);` called.\n    // because textContent will be assign with `el.stateProxy` inside.\n    (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_15__/* .setLabelStyle */ .qM)(el, (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_15__/* .getLabelStatesModels */ .lx)(regionModel), {\n      labelFetcher: labelFetcher,\n      labelDataIndex: query,\n      defaultText: regionName\n    }, specifiedTextOpt);\n    var textEl = el.getTextContent();\n    if (textEl) {\n      mapLabelRaw(textEl).ignore = textEl.ignore;\n      if (el.textConfig && labelXY) {\n        // Compute a relative offset based on the el bounding rect.\n        var rect = el.getBoundingRect().clone();\n        // Need to make sure the percent position base on the same rect in normal and\n        // emphasis state. Otherwise if using boundingRect of el, but the emphasis state\n        // has borderWidth (even 0.5px), the text position will be changed obviously\n        // if the position is very big like ['1234%', '1345%'].\n        el.textConfig.layoutRect = rect;\n        el.textConfig.position = [(labelXY[0] - rect.x) / rect.width * 100 + '%', (labelXY[1] - rect.y) / rect.height * 100 + '%'];\n      }\n    }\n    // PENDING:\n    // If labelLayout is enabled (test/label-layout.html), el.dataIndex should be specified.\n    // But el.dataIndex is also used to determine whether user event should be triggered,\n    // where el.seriesIndex or el.dataModel must be specified. At present for a single el\n    // there is not case that \"only label layout enabled but user event disabled\", so here\n    // we depends `resetEventTriggerForRegion` to do the job of setting `el.dataIndex`.\n    el.disableLabelAnimation = true;\n  } else {\n    el.removeTextContent();\n    el.removeTextConfig();\n    el.disableLabelAnimation = null;\n  }\n}\nfunction resetEventTriggerForRegion(viewBuildCtx, eventTrigger, regionName, regionModel, mapOrGeoModel,\n// Exist only if `viewBuildCtx.data` exists.\ndataIdx) {\n  // setItemGraphicEl, setHoverStyle after all polygons and labels\n  // are added to the regionGroup\n  if (viewBuildCtx.data) {\n    // FIXME: when series-map use a SVG map, and there are duplicated name specified\n    // on different SVG elements, after `data.setItemGraphicEl(...)`:\n    // (1) all of them will be mounted with `dataIndex`, `seriesIndex`, so that tooltip\n    // can be triggered only mouse hover. That's correct.\n    // (2) only the last element will be kept in `data`, so that if trigger tooltip\n    // by `dispatchAction`, only the last one can be found and triggered. That might be\n    // not correct. We will fix it in future if anyone demanding that.\n    viewBuildCtx.data.setItemGraphicEl(dataIdx, eventTrigger);\n  }\n  // series-map will not trigger \"geoselectchange\" no matter it is\n  // based on a declared geo component. Because series-map will\n  // trigger \"selectchange\". If it trigger both the two events,\n  // If users call `chart.dispatchAction({type: 'toggleSelect'})`,\n  // it not easy to also fire event \"geoselectchanged\".\n  else {\n    // Package custom mouse event for geo component\n    (0,_util_innerStore_js__WEBPACK_IMPORTED_MODULE_16__/* .getECData */ .z)(eventTrigger).eventData = {\n      componentType: 'geo',\n      componentIndex: mapOrGeoModel.componentIndex,\n      geoIndex: mapOrGeoModel.componentIndex,\n      name: regionName,\n      region: regionModel && regionModel.option || {}\n    };\n  }\n}\nfunction resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {\n  if (!viewBuildCtx.data) {\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_17__.setTooltipConfig({\n      el: el,\n      componentModel: mapOrGeoModel,\n      itemName: regionName,\n      // @ts-ignore FIXME:TS fix the \"compatible with each other\"?\n      itemTooltipOption: regionModel.get('tooltip')\n    });\n  }\n}\nfunction resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {\n  // @ts-ignore FIXME:TS fix the \"compatible with each other\"?\n  el.highDownSilentOnTouch = !!mapOrGeoModel.get('selectedMode');\n  // @ts-ignore FIXME:TS fix the \"compatible with each other\"?\n  var emphasisModel = regionModel.getModel('emphasis');\n  var focus = emphasisModel.get('focus');\n  (0,_util_states_js__WEBPACK_IMPORTED_MODULE_10__/* .toggleHoverEmphasis */ .Lm)(el, focus, emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n  if (viewBuildCtx.isGeo) {\n    (0,_util_states_js__WEBPACK_IMPORTED_MODULE_10__/* .enableComponentHighDownFeatures */ .ml)(el, mapOrGeoModel, regionName);\n  }\n  return focus;\n}\nfunction projectPolys(rings,\n// Polygons include exterior and interiors. Or polylines.\ncreateStream, isLine) {\n  var polygons = [];\n  var curPoly;\n  function startPolygon() {\n    curPoly = [];\n  }\n  function endPolygon() {\n    if (curPoly.length) {\n      polygons.push(curPoly);\n      curPoly = [];\n    }\n  }\n  var stream = createStream({\n    polygonStart: startPolygon,\n    polygonEnd: endPolygon,\n    lineStart: startPolygon,\n    lineEnd: endPolygon,\n    point: function (x, y) {\n      // May have NaN values from stream.\n      if (isFinite(x) && isFinite(y)) {\n        curPoly.push([x, y]);\n      }\n    },\n    sphere: function () {}\n  });\n  !isLine && stream.polygonStart();\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(rings, function (ring) {\n    stream.lineStart();\n    for (var i = 0; i < ring.length; i++) {\n      stream.point(ring[i][0], ring[i][1]);\n    }\n    stream.lineEnd();\n  });\n  !isLine && stream.polygonEnd();\n  return polygons;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapDraw);\n// @ts-ignore FIXME:TS fix the \"compatible with each other\"?//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODAyNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9NYXBEcmF3LmpzPzQ3YWMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBSb2FtQ29udHJvbGxlciBmcm9tICcuL1JvYW1Db250cm9sbGVyLmpzJztcbmltcG9ydCAqIGFzIHJvYW1IZWxwZXIgZnJvbSAnLi4vLi4vY29tcG9uZW50L2hlbHBlci9yb2FtSGVscGVyLmpzJztcbmltcG9ydCB7IG9uSXJyZWxldmFudEVsZW1lbnQgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvaGVscGVyL2N1cnNvckhlbHBlci5qcyc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyB0b2dnbGVIb3ZlckVtcGhhc2lzLCBlbmFibGVDb21wb25lbnRIaWdoRG93bkZlYXR1cmVzLCBzZXREZWZhdWx0U3RhdGVQcm94eSB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdGVzLmpzJztcbmltcG9ydCBnZW9Tb3VyY2VNYW5hZ2VyIGZyb20gJy4uLy4uL2Nvb3JkL2dlby9nZW9Tb3VyY2VNYW5hZ2VyLmpzJztcbmltcG9ydCB7IGdldFVJRCB9IGZyb20gJy4uLy4uL3V0aWwvY29tcG9uZW50LmpzJztcbmltcG9ydCB7IHNldExhYmVsU3R5bGUsIGdldExhYmVsU3RhdGVzTW9kZWxzIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG5pbXBvcnQgeyBnZXRFQ0RhdGEgfSBmcm9tICcuLi8uLi91dGlsL2lubmVyU3RvcmUuanMnO1xuaW1wb3J0IHsgY3JlYXRlT3JVcGRhdGVQYXR0ZXJuRnJvbURlY2FsIH0gZnJvbSAnLi4vLi4vdXRpbC9kZWNhbC5qcyc7XG5pbXBvcnQgRGlzcGxheWFibGUgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qcyc7XG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbi8qKlxyXG4gKiBPbmx5IHRoZXNlIHRhZ3MgZW5hYmxlIHVzZSBgaXRlbVN0eWxlYCBpZiB0aGV5IGFyZSBuYW1lZCBpbiBTVkcuXHJcbiAqIE90aGVyIHRhZ3MgbGlrZSA8dGV4dD4gPHRzcGFuPiA8aW1hZ2U+IG1pZ2h0IG5vdCBzdWl0YWJsZSBmb3IgYGl0ZW1TdHlsZWAuXHJcbiAqIFRoZXkgd2lsbCBub3QgYmUgY29uc2lkZXJlZCB0byBiZSBzdHlsZWQgdW50aWwgc29tZSByZXF1aXJlbWVudHMgY29tZS5cclxuICovXG52YXIgT1BUSU9OX1NUWUxFX0VOQUJMRURfVEFHUyA9IFsncmVjdCcsICdjaXJjbGUnLCAnbGluZScsICdlbGxpcHNlJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncGF0aCddO1xudmFyIE9QVElPTl9TVFlMRV9FTkFCTEVEX1RBR19NQVAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcChPUFRJT05fU1RZTEVfRU5BQkxFRF9UQUdTKTtcbnZhciBTVEFURV9UUklHR0VSX1RBR19NQVAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcChPUFRJT05fU1RZTEVfRU5BQkxFRF9UQUdTLmNvbmNhdChbJ2cnXSkpO1xudmFyIExBQkVMX0hPU1RfTUFQID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoT1BUSU9OX1NUWUxFX0VOQUJMRURfVEFHUy5jb25jYXQoWydnJ10pKTtcbnZhciBtYXBMYWJlbFJhdyA9IG1ha2VJbm5lcigpO1xuZnVuY3Rpb24gZ2V0Rml4ZWRJdGVtU3R5bGUobW9kZWwpIHtcbiAgdmFyIGl0ZW1TdHlsZSA9IG1vZGVsLmdldEl0ZW1TdHlsZSgpO1xuICB2YXIgYXJlYUNvbG9yID0gbW9kZWwuZ2V0KCdhcmVhQ29sb3InKTtcbiAgLy8gSWYgdXNlciB3YW50IHRoZSBjb2xvciBub3QgdG8gYmUgY2hhbmdlZCB3aGVuIGhvdmVyLFxuICAvLyB0aGV5IHNob3VsZCBib3RoIHNldCBhcmVhQ29sb3IgYW5kIGNvbG9yIHRvIGJlIG51bGwuXG4gIGlmIChhcmVhQ29sb3IgIT0gbnVsbCkge1xuICAgIGl0ZW1TdHlsZS5maWxsID0gYXJlYUNvbG9yO1xuICB9XG4gIHJldHVybiBpdGVtU3R5bGU7XG59XG4vLyBPbmx5IHN0cm9rZSBjYW4gYmUgdXNlZCBmb3IgbGluZS5cbi8vIFVzaW5nIGZpbGwgaW4gc3R5bGUgaWYgc3Ryb2tlIG5vdCBleGl0cy5cbi8vIFRPRE8gTm90IHN1cmUgeWV0LiBQZXJoYXBzIGEgc2VwYXJhdGUgYGxpbmVTdHlsZWA/XG5mdW5jdGlvbiBmaXhMaW5lU3R5bGUoc3R5bGVIb3N0KSB7XG4gIHZhciBzdHlsZSA9IHN0eWxlSG9zdC5zdHlsZTtcbiAgaWYgKHN0eWxlKSB7XG4gICAgc3R5bGUuc3Ryb2tlID0gc3R5bGUuc3Ryb2tlIHx8IHN0eWxlLmZpbGw7XG4gICAgc3R5bGUuZmlsbCA9IG51bGw7XG4gIH1cbn1cbnZhciBNYXBEcmF3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWFwRHJhdyhhcGkpIHtcbiAgICB2YXIgZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHRoaXMudWlkID0gZ2V0VUlEKCdlY19tYXBfZHJhdycpO1xuICAgIHRoaXMuX2NvbnRyb2xsZXIgPSBuZXcgUm9hbUNvbnRyb2xsZXIoYXBpLmdldFpyKCkpO1xuICAgIHRoaXMuX2NvbnRyb2xsZXJIb3N0ID0ge1xuICAgICAgdGFyZ2V0OiBncm91cFxuICAgIH07XG4gICAgdGhpcy5ncm91cCA9IGdyb3VwO1xuICAgIGdyb3VwLmFkZCh0aGlzLl9yZWdpb25zR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpKTtcbiAgICBncm91cC5hZGQodGhpcy5fc3ZnR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpKTtcbiAgfVxuICBNYXBEcmF3LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKG1hcE9yR2VvTW9kZWwsIGVjTW9kZWwsIGFwaSwgZnJvbVZpZXcsIHBheWxvYWQpIHtcbiAgICB2YXIgaXNHZW8gPSBtYXBPckdlb01vZGVsLm1haW5UeXBlID09PSAnZ2VvJztcbiAgICAvLyBNYXAgc2VyaWVzIGhhcyBkYXRhLiBHRU8gbW9kZWwgdGhhdCBjb250cm9sbGVkIGJ5IG1hcCBzZXJpZXNcbiAgICAvLyB3aWxsIGJlIGFzc2lnbmVkIHdpdGggbWFwIGRhdGEuIE90aGVyIEdFTyBtb2RlbCBoYXMgbm8gZGF0YS5cbiAgICB2YXIgZGF0YSA9IG1hcE9yR2VvTW9kZWwuZ2V0RGF0YSAmJiBtYXBPckdlb01vZGVsLmdldERhdGEoKTtcbiAgICBpc0dlbyAmJiBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6ICdzZXJpZXMnLFxuICAgICAgc3ViVHlwZTogJ21hcCdcbiAgICB9LCBmdW5jdGlvbiAobWFwU2VyaWVzKSB7XG4gICAgICBpZiAoIWRhdGEgJiYgbWFwU2VyaWVzLmdldEhvc3RHZW9Nb2RlbCgpID09PSBtYXBPckdlb01vZGVsKSB7XG4gICAgICAgIGRhdGEgPSBtYXBTZXJpZXMuZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBnZW8gPSBtYXBPckdlb01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIHJlZ2lvbnNHcm91cCA9IHRoaXMuX3JlZ2lvbnNHcm91cDtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciB0cmFuc2Zvcm1JbmZvID0gZ2VvLmdldFRyYW5zZm9ybUluZm8oKTtcbiAgICB2YXIgdHJhbnNmb3JtSW5mb1JhdyA9IHRyYW5zZm9ybUluZm8ucmF3O1xuICAgIHZhciB0cmFuc2Zvcm1JbmZvUm9hbSA9IHRyYW5zZm9ybUluZm8ucm9hbTtcbiAgICAvLyBObyBhbmltYXRpb24gd2hlbiBmaXJzdCBkcmF3IG9yIGluIGFjdGlvblxuICAgIHZhciBpc0ZpcnN0RHJhdyA9ICFyZWdpb25zR3JvdXAuY2hpbGRBdCgwKSB8fCBwYXlsb2FkO1xuICAgIGlmIChpc0ZpcnN0RHJhdykge1xuICAgICAgZ3JvdXAueCA9IHRyYW5zZm9ybUluZm9Sb2FtLng7XG4gICAgICBncm91cC55ID0gdHJhbnNmb3JtSW5mb1JvYW0ueTtcbiAgICAgIGdyb3VwLnNjYWxlWCA9IHRyYW5zZm9ybUluZm9Sb2FtLnNjYWxlWDtcbiAgICAgIGdyb3VwLnNjYWxlWSA9IHRyYW5zZm9ybUluZm9Sb2FtLnNjYWxlWTtcbiAgICAgIGdyb3VwLmRpcnR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZ3JvdXAsIHRyYW5zZm9ybUluZm9Sb2FtLCBtYXBPckdlb01vZGVsKTtcbiAgICB9XG4gICAgdmFyIGlzVmlzdWFsRW5jb2RlZEJ5VmlzdWFsTWFwID0gZGF0YSAmJiBkYXRhLmdldFZpc3VhbCgndmlzdWFsTWV0YScpICYmIGRhdGEuZ2V0VmlzdWFsKCd2aXN1YWxNZXRhJykubGVuZ3RoID4gMDtcbiAgICB2YXIgdmlld0J1aWxkQ3R4ID0ge1xuICAgICAgYXBpOiBhcGksXG4gICAgICBnZW86IGdlbyxcbiAgICAgIG1hcE9yR2VvTW9kZWw6IG1hcE9yR2VvTW9kZWwsXG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgaXNWaXN1YWxFbmNvZGVkQnlWaXN1YWxNYXA6IGlzVmlzdWFsRW5jb2RlZEJ5VmlzdWFsTWFwLFxuICAgICAgaXNHZW86IGlzR2VvLFxuICAgICAgdHJhbnNmb3JtSW5mb1JhdzogdHJhbnNmb3JtSW5mb1Jhd1xuICAgIH07XG4gICAgaWYgKGdlby5yZXNvdXJjZVR5cGUgPT09ICdnZW9KU09OJykge1xuICAgICAgdGhpcy5fYnVpbGRHZW9KU09OKHZpZXdCdWlsZEN0eCk7XG4gICAgfSBlbHNlIGlmIChnZW8ucmVzb3VyY2VUeXBlID09PSAnZ2VvU1ZHJykge1xuICAgICAgdGhpcy5fYnVpbGRTVkcodmlld0J1aWxkQ3R4KTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlQ29udHJvbGxlcihtYXBPckdlb01vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgIHRoaXMuX3VwZGF0ZU1hcFNlbGVjdEhhbmRsZXIobWFwT3JHZW9Nb2RlbCwgcmVnaW9uc0dyb3VwLCBhcGksIGZyb21WaWV3KTtcbiAgfTtcbiAgTWFwRHJhdy5wcm90b3R5cGUuX2J1aWxkR2VvSlNPTiA9IGZ1bmN0aW9uICh2aWV3QnVpbGRDdHgpIHtcbiAgICB2YXIgcmVnaW9uc0dyb3VwQnlOYW1lID0gdGhpcy5fcmVnaW9uc0dyb3VwQnlOYW1lID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgICB2YXIgcmVnaW9uc0luZm9CeU5hbWUgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICAgIHZhciByZWdpb25zR3JvdXAgPSB0aGlzLl9yZWdpb25zR3JvdXA7XG4gICAgdmFyIHRyYW5zZm9ybUluZm9SYXcgPSB2aWV3QnVpbGRDdHgudHJhbnNmb3JtSW5mb1JhdztcbiAgICB2YXIgbWFwT3JHZW9Nb2RlbCA9IHZpZXdCdWlsZEN0eC5tYXBPckdlb01vZGVsO1xuICAgIHZhciBkYXRhID0gdmlld0J1aWxkQ3R4LmRhdGE7XG4gICAgdmFyIHByb2plY3Rpb24gPSB2aWV3QnVpbGRDdHguZ2VvLnByb2plY3Rpb247XG4gICAgdmFyIHByb2plY3Rpb25TdHJlYW0gPSBwcm9qZWN0aW9uICYmIHByb2plY3Rpb24uc3RyZWFtO1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KHBvaW50LCBwcm9qZWN0KSB7XG4gICAgICBpZiAocHJvamVjdCkge1xuICAgICAgICAvLyBwcm9qZWN0aW9uIG1heSByZXR1cm4gbnVsbCBwb2ludC5cbiAgICAgICAgcG9pbnQgPSBwcm9qZWN0KHBvaW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb2ludCAmJiBbcG9pbnRbMF0gKiB0cmFuc2Zvcm1JbmZvUmF3LnNjYWxlWCArIHRyYW5zZm9ybUluZm9SYXcueCwgcG9pbnRbMV0gKiB0cmFuc2Zvcm1JbmZvUmF3LnNjYWxlWSArIHRyYW5zZm9ybUluZm9SYXcueV07XG4gICAgfVxuICAgIDtcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2x5Z29uUG9pbnRzKGluUG9pbnRzKSB7XG4gICAgICB2YXIgb3V0UG9pbnRzID0gW107XG4gICAgICAvLyBJZiBwcm9qZWN0aW9uU3RyZWFtIGlzIHByb3ZpZGVkLiBVc2UgaXQgaW5zdGVhZCBvZiBzaW5nbGUgcG9pbnQgcHJvamVjdC5cbiAgICAgIHZhciBwcm9qZWN0ID0gIXByb2plY3Rpb25TdHJlYW0gJiYgcHJvamVjdGlvbiAmJiBwcm9qZWN0aW9uLnByb2plY3Q7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluUG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBuZXdQdCA9IHRyYW5zZm9ybVBvaW50KGluUG9pbnRzW2ldLCBwcm9qZWN0KTtcbiAgICAgICAgbmV3UHQgJiYgb3V0UG9pbnRzLnB1c2gobmV3UHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dFBvaW50cztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UG9seVNoYXBlKHBvaW50cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICBwb2ludHM6IHRyYW5zZm9ybVBvbHlnb25Qb2ludHMocG9pbnRzKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZWdpb25zR3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgLy8gT25seSB3aGVuIHRoZSByZXNvdXJjZSBpcyBHZW9KU09OLCB0aGVyZSBpcyBgZ2VvLnJlZ2lvbnNgLlxuICAgIHpyVXRpbC5lYWNoKHZpZXdCdWlsZEN0eC5nZW8ucmVnaW9ucywgZnVuY3Rpb24gKHJlZ2lvbikge1xuICAgICAgdmFyIHJlZ2lvbk5hbWUgPSByZWdpb24ubmFtZTtcbiAgICAgIC8vIENvbnNpZGVyIGluIEdlb0pzb24gcHJvcGVydGllcy5uYW1lIG1heSBiZSBkdXBsaWNhdGVkLCBmb3IgZXhhbXBsZSxcbiAgICAgIC8vIHRoZXJlIGlzIG11bHRpcGxlIHJlZ2lvbiBuYW1lZCBcIlVuaXRlZCBLaW5kb21cIiBvciBcIkZyYW5jZVwiIChzbyBtYW55XG4gICAgICAvLyBjb2xvbmllcykuIEFuZCBpdCBpcyBub3QgYXBwcm9wcmlhdGUgdG8gbWVyZ2UgdGhlbSBpbiBnZW8sIHdoaWNoXG4gICAgICAvLyB3aWxsIG1ha2UgdGhlbSBzaGFyZSB0aGUgc2FtZSBsYWJlbCBhbmQgYnJpbmcgdHJvdWJsZSBpbiBsYWJlbFxuICAgICAgLy8gbG9jYXRpb24gY2FsY3VsYXRpb24uXG4gICAgICB2YXIgcmVnaW9uR3JvdXAgPSByZWdpb25zR3JvdXBCeU5hbWUuZ2V0KHJlZ2lvbk5hbWUpO1xuICAgICAgdmFyIF9hID0gcmVnaW9uc0luZm9CeU5hbWUuZ2V0KHJlZ2lvbk5hbWUpIHx8IHt9LFxuICAgICAgICBkYXRhSWR4ID0gX2EuZGF0YUlkeCxcbiAgICAgICAgcmVnaW9uTW9kZWwgPSBfYS5yZWdpb25Nb2RlbDtcbiAgICAgIGlmICghcmVnaW9uR3JvdXApIHtcbiAgICAgICAgcmVnaW9uR3JvdXAgPSByZWdpb25zR3JvdXBCeU5hbWUuc2V0KHJlZ2lvbk5hbWUsIG5ldyBncmFwaGljLkdyb3VwKCkpO1xuICAgICAgICByZWdpb25zR3JvdXAuYWRkKHJlZ2lvbkdyb3VwKTtcbiAgICAgICAgZGF0YUlkeCA9IGRhdGEgPyBkYXRhLmluZGV4T2ZOYW1lKHJlZ2lvbk5hbWUpIDogbnVsbDtcbiAgICAgICAgcmVnaW9uTW9kZWwgPSB2aWV3QnVpbGRDdHguaXNHZW8gPyBtYXBPckdlb01vZGVsLmdldFJlZ2lvbk1vZGVsKHJlZ2lvbk5hbWUpIDogZGF0YSA/IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJZHgpIDogbnVsbDtcbiAgICAgICAgdmFyIHNpbGVudCA9IHJlZ2lvbk1vZGVsLmdldCgnc2lsZW50JywgdHJ1ZSk7XG4gICAgICAgIHNpbGVudCAhPSBudWxsICYmIChyZWdpb25Hcm91cC5zaWxlbnQgPSBzaWxlbnQpO1xuICAgICAgICByZWdpb25zSW5mb0J5TmFtZS5zZXQocmVnaW9uTmFtZSwge1xuICAgICAgICAgIGRhdGFJZHg6IGRhdGFJZHgsXG4gICAgICAgICAgcmVnaW9uTW9kZWw6IHJlZ2lvbk1vZGVsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIHBvbHlnb25TdWJwYXRocyA9IFtdO1xuICAgICAgdmFyIHBvbHlsaW5lU3VicGF0aHMgPSBbXTtcbiAgICAgIHpyVXRpbC5lYWNoKHJlZ2lvbi5nZW9tZXRyaWVzLCBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgLy8gUG9seWdvbiBhbmQgTXVsdGlQb2x5Z29uXG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAncG9seWdvbicpIHtcbiAgICAgICAgICB2YXIgcG9seXMgPSBbZ2VvbWV0cnkuZXh0ZXJpb3JdLmNvbmNhdChnZW9tZXRyeS5pbnRlcmlvcnMgfHwgW10pO1xuICAgICAgICAgIGlmIChwcm9qZWN0aW9uU3RyZWFtKSB7XG4gICAgICAgICAgICBwb2x5cyA9IHByb2plY3RQb2x5cyhwb2x5cywgcHJvamVjdGlvblN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHpyVXRpbC5lYWNoKHBvbHlzLCBmdW5jdGlvbiAocG9seSkge1xuICAgICAgICAgICAgcG9seWdvblN1YnBhdGhzLnB1c2gobmV3IGdyYXBoaWMuUG9seWdvbihnZXRQb2x5U2hhcGUocG9seSkpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMaW5lU3RyaW5nIGFuZCBNdWx0aUxpbmVTdHJpbmdcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IGdlb21ldHJ5LnBvaW50cztcbiAgICAgICAgICBpZiAocHJvamVjdGlvblN0cmVhbSkge1xuICAgICAgICAgICAgcG9pbnRzID0gcHJvamVjdFBvbHlzKHBvaW50cywgcHJvamVjdGlvblN0cmVhbSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHpyVXRpbC5lYWNoKHBvaW50cywgZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgICAgICAgcG9seWxpbmVTdWJwYXRocy5wdXNoKG5ldyBncmFwaGljLlBvbHlsaW5lKGdldFBvbHlTaGFwZShwb2ludHMpKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGNlbnRlclB0ID0gdHJhbnNmb3JtUG9pbnQocmVnaW9uLmdldENlbnRlcigpLCBwcm9qZWN0aW9uICYmIHByb2plY3Rpb24ucHJvamVjdCk7XG4gICAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZFBhdGgoc3VicGF0aHMsIGlzTGluZSkge1xuICAgICAgICBpZiAoIXN1YnBhdGhzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcG91bmRQYXRoID0gbmV3IGdyYXBoaWMuQ29tcG91bmRQYXRoKHtcbiAgICAgICAgICBjdWxsaW5nOiB0cnVlLFxuICAgICAgICAgIHNlZ21lbnRJZ25vcmVUaHJlc2hvbGQ6IDEsXG4gICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHBhdGhzOiBzdWJwYXRoc1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlZ2lvbkdyb3VwLmFkZChjb21wb3VuZFBhdGgpO1xuICAgICAgICBhcHBseU9wdGlvblN0eWxlRm9yUmVnaW9uKHZpZXdCdWlsZEN0eCwgY29tcG91bmRQYXRoLCBkYXRhSWR4LCByZWdpb25Nb2RlbCk7XG4gICAgICAgIHJlc2V0TGFiZWxGb3JSZWdpb24odmlld0J1aWxkQ3R4LCBjb21wb3VuZFBhdGgsIHJlZ2lvbk5hbWUsIHJlZ2lvbk1vZGVsLCBtYXBPckdlb01vZGVsLCBkYXRhSWR4LCBjZW50ZXJQdCk7XG4gICAgICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgICBmaXhMaW5lU3R5bGUoY29tcG91bmRQYXRoKTtcbiAgICAgICAgICB6clV0aWwuZWFjaChjb21wb3VuZFBhdGguc3RhdGVzLCBmaXhMaW5lU3R5bGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjcmVhdGVDb21wb3VuZFBhdGgocG9seWdvblN1YnBhdGhzKTtcbiAgICAgIGNyZWF0ZUNvbXBvdW5kUGF0aChwb2x5bGluZVN1YnBhdGhzLCB0cnVlKTtcbiAgICB9KTtcbiAgICAvLyBFbnN1cmUgY2hpbGRyZW4gaGF2ZSBiZWVuIGFkZGVkIHRvIGByZWdpb25Hcm91cGAgYmVmb3JlIGNhbGxpbmcgdGhlbS5cbiAgICByZWdpb25zR3JvdXBCeU5hbWUuZWFjaChmdW5jdGlvbiAocmVnaW9uR3JvdXAsIHJlZ2lvbk5hbWUpIHtcbiAgICAgIHZhciBfYSA9IHJlZ2lvbnNJbmZvQnlOYW1lLmdldChyZWdpb25OYW1lKSxcbiAgICAgICAgZGF0YUlkeCA9IF9hLmRhdGFJZHgsXG4gICAgICAgIHJlZ2lvbk1vZGVsID0gX2EucmVnaW9uTW9kZWw7XG4gICAgICByZXNldEV2ZW50VHJpZ2dlckZvclJlZ2lvbih2aWV3QnVpbGRDdHgsIHJlZ2lvbkdyb3VwLCByZWdpb25OYW1lLCByZWdpb25Nb2RlbCwgbWFwT3JHZW9Nb2RlbCwgZGF0YUlkeCk7XG4gICAgICByZXNldFRvb2x0aXBGb3JSZWdpb24odmlld0J1aWxkQ3R4LCByZWdpb25Hcm91cCwgcmVnaW9uTmFtZSwgcmVnaW9uTW9kZWwsIG1hcE9yR2VvTW9kZWwpO1xuICAgICAgcmVzZXRTdGF0ZVRyaWdnZXJGb3JSZWdpb24odmlld0J1aWxkQ3R4LCByZWdpb25Hcm91cCwgcmVnaW9uTmFtZSwgcmVnaW9uTW9kZWwsIG1hcE9yR2VvTW9kZWwpO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuICBNYXBEcmF3LnByb3RvdHlwZS5fYnVpbGRTVkcgPSBmdW5jdGlvbiAodmlld0J1aWxkQ3R4KSB7XG4gICAgdmFyIG1hcE5hbWUgPSB2aWV3QnVpbGRDdHguZ2VvLm1hcDtcbiAgICB2YXIgdHJhbnNmb3JtSW5mb1JhdyA9IHZpZXdCdWlsZEN0eC50cmFuc2Zvcm1JbmZvUmF3O1xuICAgIHRoaXMuX3N2Z0dyb3VwLnggPSB0cmFuc2Zvcm1JbmZvUmF3Lng7XG4gICAgdGhpcy5fc3ZnR3JvdXAueSA9IHRyYW5zZm9ybUluZm9SYXcueTtcbiAgICB0aGlzLl9zdmdHcm91cC5zY2FsZVggPSB0cmFuc2Zvcm1JbmZvUmF3LnNjYWxlWDtcbiAgICB0aGlzLl9zdmdHcm91cC5zY2FsZVkgPSB0cmFuc2Zvcm1JbmZvUmF3LnNjYWxlWTtcbiAgICBpZiAodGhpcy5fc3ZnUmVzb3VyY2VDaGFuZ2VkKG1hcE5hbWUpKSB7XG4gICAgICB0aGlzLl9mcmVlU1ZHKCk7XG4gICAgICB0aGlzLl91c2VTVkcobWFwTmFtZSk7XG4gICAgfVxuICAgIHZhciBzdmdEaXNwYXRjaGVyTWFwID0gdGhpcy5fc3ZnRGlzcGF0Y2hlck1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgdmFyIGZvY3VzU2VsZiA9IGZhbHNlO1xuICAgIHpyVXRpbC5lYWNoKHRoaXMuX3N2Z0dyYXBoaWNSZWNvcmQubmFtZWQsIGZ1bmN0aW9uIChuYW1lZEl0ZW0pIHtcbiAgICAgIC8vIE5vdGUgdGhhdCB3ZSBhbHNvIGFsbG93IGRpZmZlcmVudCBlbGVtZW50cyBoYXZlIHRoZSBzYW1lIG5hbWUuXG4gICAgICAvLyBGb3IgZXhhbXBsZSwgYSBnbHlwaCBvZiBhIGNpdHkgYW5kIHRoZSBsYWJlbCBvZiB0aGUgY2l0eSBoYXZlXG4gICAgICAvLyB0aGUgc2FtZSBuYW1lIGFuZCB0aGVpciB0b29sdGlwIGluZm8gY2FuIGJlIGRlZmluZWQgaW4gYSBzaW5nbGVcbiAgICAgIC8vIHJlZ2lvbiBvcHRpb24uXG4gICAgICB2YXIgcmVnaW9uTmFtZSA9IG5hbWVkSXRlbS5uYW1lO1xuICAgICAgdmFyIG1hcE9yR2VvTW9kZWwgPSB2aWV3QnVpbGRDdHgubWFwT3JHZW9Nb2RlbDtcbiAgICAgIHZhciBkYXRhID0gdmlld0J1aWxkQ3R4LmRhdGE7XG4gICAgICB2YXIgc3ZnTm9kZVRhZ0xvd2VyID0gbmFtZWRJdGVtLnN2Z05vZGVUYWdMb3dlcjtcbiAgICAgIHZhciBlbCA9IG5hbWVkSXRlbS5lbDtcbiAgICAgIHZhciBkYXRhSWR4ID0gZGF0YSA/IGRhdGEuaW5kZXhPZk5hbWUocmVnaW9uTmFtZSkgOiBudWxsO1xuICAgICAgdmFyIHJlZ2lvbk1vZGVsID0gbWFwT3JHZW9Nb2RlbC5nZXRSZWdpb25Nb2RlbChyZWdpb25OYW1lKTtcbiAgICAgIGlmIChPUFRJT05fU1RZTEVfRU5BQkxFRF9UQUdfTUFQLmdldChzdmdOb2RlVGFnTG93ZXIpICE9IG51bGwgJiYgZWwgaW5zdGFuY2VvZiBEaXNwbGF5YWJsZSkge1xuICAgICAgICBhcHBseU9wdGlvblN0eWxlRm9yUmVnaW9uKHZpZXdCdWlsZEN0eCwgZWwsIGRhdGFJZHgsIHJlZ2lvbk1vZGVsKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbCBpbnN0YW5jZW9mIERpc3BsYXlhYmxlKSB7XG4gICAgICAgIGVsLmN1bGxpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHNpbGVudCA9IHJlZ2lvbk1vZGVsLmdldCgnc2lsZW50JywgdHJ1ZSk7XG4gICAgICBzaWxlbnQgIT0gbnVsbCAmJiAoZWwuc2lsZW50ID0gc2lsZW50KTtcbiAgICAgIC8vIFdlIGRvIG5vdCBrbm93IGhvdyB0aGUgU1ZHIGxpa2Ugc28gd2UnZCBiZXR0ZXIgbm90IHRvIGNoYW5nZSB6Mi5cbiAgICAgIC8vIE90aGVyd2lzZSBpdCBtaWdodCBicmluZyBzb21lIHVuZXhwZWN0ZWQgcmVzdWx0LiBGb3IgZXhhbXBsZSxcbiAgICAgIC8vIGFuIGFyZWEgaG92ZXJlZCB0aGF0IG1ha2Ugc29tZSBpbm5lciBjaXR5IGNhbiBub3QgYmUgY2xpY2tlZC5cbiAgICAgIGVsLnoyRW1waGFzaXNMaWZ0ID0gMDtcbiAgICAgIC8vIElmIHNlbGYgbmFtZWQ6XG4gICAgICBpZiAoIW5hbWVkSXRlbS5uYW1lZEZyb20pIHtcbiAgICAgICAgLy8gbGFiZWwgc2hvdWxkIGJhdHRlciB0byBiZSBkaXNwbGF5ZWQgYmFzZWQgb24gdGhlIGNlbnRlciBvZiA8Zz5cbiAgICAgICAgLy8gaWYgaXQgaXMgbmFtZWQgcmF0aGVyIHRoYW4gZGlzcGxheWVkIG9uIGVhY2ggY2hpbGQuXG4gICAgICAgIGlmIChMQUJFTF9IT1NUX01BUC5nZXQoc3ZnTm9kZVRhZ0xvd2VyKSAhPSBudWxsKSB7XG4gICAgICAgICAgcmVzZXRMYWJlbEZvclJlZ2lvbih2aWV3QnVpbGRDdHgsIGVsLCByZWdpb25OYW1lLCByZWdpb25Nb2RlbCwgbWFwT3JHZW9Nb2RlbCwgZGF0YUlkeCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXRFdmVudFRyaWdnZXJGb3JSZWdpb24odmlld0J1aWxkQ3R4LCBlbCwgcmVnaW9uTmFtZSwgcmVnaW9uTW9kZWwsIG1hcE9yR2VvTW9kZWwsIGRhdGFJZHgpO1xuICAgICAgICByZXNldFRvb2x0aXBGb3JSZWdpb24odmlld0J1aWxkQ3R4LCBlbCwgcmVnaW9uTmFtZSwgcmVnaW9uTW9kZWwsIG1hcE9yR2VvTW9kZWwpO1xuICAgICAgICBpZiAoU1RBVEVfVFJJR0dFUl9UQUdfTUFQLmdldChzdmdOb2RlVGFnTG93ZXIpICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgZm9jdXNfMSA9IHJlc2V0U3RhdGVUcmlnZ2VyRm9yUmVnaW9uKHZpZXdCdWlsZEN0eCwgZWwsIHJlZ2lvbk5hbWUsIHJlZ2lvbk1vZGVsLCBtYXBPckdlb01vZGVsKTtcbiAgICAgICAgICBpZiAoZm9jdXNfMSA9PT0gJ3NlbGYnKSB7XG4gICAgICAgICAgICBmb2N1c1NlbGYgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZWxzID0gc3ZnRGlzcGF0Y2hlck1hcC5nZXQocmVnaW9uTmFtZSkgfHwgc3ZnRGlzcGF0Y2hlck1hcC5zZXQocmVnaW9uTmFtZSwgW10pO1xuICAgICAgICAgIGVscy5wdXNoKGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX2VuYWJsZUJsdXJFbnRpcmVTVkcoZm9jdXNTZWxmLCB2aWV3QnVpbGRDdHgpO1xuICB9O1xuICBNYXBEcmF3LnByb3RvdHlwZS5fZW5hYmxlQmx1ckVudGlyZVNWRyA9IGZ1bmN0aW9uIChmb2N1c1NlbGYsIHZpZXdCdWlsZEN0eCkge1xuICAgIC8vIEl0J3MgYSBsaXR0bGUgY29tcGxpY2F0ZWQgdG8gc3VwcG9ydCBibHVycmluZyB0aGUgZW50aXJlIGdlb1NWRyBpbiBzZXJpZXMtbWFwLlxuICAgIC8vIFNvIGRvIG5vdCBzdXBwb3J0IGl0IHVudGlsIHNvbWUgcmVxdWlyZW1lbnRzIGNvbWUuXG4gICAgLy8gQXQgcHJlc2VudCwgaW4gc2VyaWVzLW1hcCwgb25seSByZWdpb25zIGNhbiBiZSBibHVycmVkLlxuICAgIGlmIChmb2N1c1NlbGYgJiYgdmlld0J1aWxkQ3R4LmlzR2VvKSB7XG4gICAgICB2YXIgYmx1clN0eWxlID0gdmlld0J1aWxkQ3R4Lm1hcE9yR2VvTW9kZWwuZ2V0TW9kZWwoWydibHVyJywgJ2l0ZW1TdHlsZSddKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgIC8vIE9ubHkgc3VwcG9ydCBgb3BhY2l0eWAgaGVyZS4gQmVjYXVzZSBub3Qgc3VyZSB0aGF0IG90aGVyIHByb3BzIGFyZSBzdWl0YWJsZSBmb3JcbiAgICAgIC8vIGFsbCBvZiB0aGUgZWxlbWVudHMgZ2VuZXJhdGVkIGJ5IFNWRyAoZXNwZWNpYWxseSBmb3IgVGV4dC9UU3Bhbi9JbWFnZS8uLi4gKS5cbiAgICAgIHZhciBvcGFjaXR5XzEgPSBibHVyU3R5bGUub3BhY2l0eTtcbiAgICAgIHRoaXMuX3N2Z0dyYXBoaWNSZWNvcmQucm9vdC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgICAgICAgLy8gUEVORElORzogY2xlYXIgdGhvc2Ugc2V0dGluZ3MgdG8gU1ZHIGVsZW1lbnRzIHdoZW4gYF9mcmVlU1ZHYC5cbiAgICAgICAgICAvLyAoQ3VycmVudGx5IGl0IGhhcHBlbiBub3QgdG8gYmUgbmVlZGVkLilcbiAgICAgICAgICBzZXREZWZhdWx0U3RhdGVQcm94eShlbCk7XG4gICAgICAgICAgdmFyIHN0eWxlID0gZWwuZW5zdXJlU3RhdGUoJ2JsdXInKS5zdHlsZSB8fCB7fTtcbiAgICAgICAgICAvLyBEbyBub3Qgb3ZlcndyaXRlIHRoZSByZWdpb24gc3R5bGUgdGhhdCBhbHJlYWR5IHNldCBmcm9tIHJlZ2lvbiBvcHRpb24uXG4gICAgICAgICAgaWYgKHN0eWxlLm9wYWNpdHkgPT0gbnVsbCAmJiBvcGFjaXR5XzEgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3R5bGUub3BhY2l0eSA9IG9wYWNpdHlfMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgYGVuc3VyZVN0YXRlKCdibHVyJykuc3R5bGUgPSB7fWAsIHRoZXJlIHdpbGwgYmUgZGVmYXVsdCBvcGFjaXR5LlxuICAgICAgICAgIC8vIEVuYWJsZSBgc3RhdGVUcmFuc2l0aW9uYCAoYW5pbWF0aW9uKS5cbiAgICAgICAgICBlbC5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBNYXBEcmF3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVnaW9uc0dyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMuX3JlZ2lvbnNHcm91cEJ5TmFtZSA9IG51bGw7XG4gICAgdGhpcy5fc3ZnR3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5fZnJlZVNWRygpO1xuICAgIHRoaXMuX2NvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2NvbnRyb2xsZXJIb3N0ID0gbnVsbDtcbiAgfTtcbiAgTWFwRHJhdy5wcm90b3R5cGUuZmluZEhpZ2hEb3duRGlzcGF0Y2hlcnMgPSBmdW5jdGlvbiAobmFtZSwgZ2VvTW9kZWwpIHtcbiAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBnZW8gPSBnZW9Nb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIGlmIChnZW8ucmVzb3VyY2VUeXBlID09PSAnZ2VvSlNPTicpIHtcbiAgICAgIHZhciByZWdpb25zR3JvdXBCeU5hbWUgPSB0aGlzLl9yZWdpb25zR3JvdXBCeU5hbWU7XG4gICAgICBpZiAocmVnaW9uc0dyb3VwQnlOYW1lKSB7XG4gICAgICAgIHZhciByZWdpb25Hcm91cCA9IHJlZ2lvbnNHcm91cEJ5TmFtZS5nZXQobmFtZSk7XG4gICAgICAgIHJldHVybiByZWdpb25Hcm91cCA/IFtyZWdpb25Hcm91cF0gOiBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdlby5yZXNvdXJjZVR5cGUgPT09ICdnZW9TVkcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3ZnRGlzcGF0Y2hlck1hcCAmJiB0aGlzLl9zdmdEaXNwYXRjaGVyTWFwLmdldChuYW1lKSB8fCBbXTtcbiAgICB9XG4gIH07XG4gIE1hcERyYXcucHJvdG90eXBlLl9zdmdSZXNvdXJjZUNoYW5nZWQgPSBmdW5jdGlvbiAobWFwTmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9zdmdNYXBOYW1lICE9PSBtYXBOYW1lO1xuICB9O1xuICBNYXBEcmF3LnByb3RvdHlwZS5fdXNlU1ZHID0gZnVuY3Rpb24gKG1hcE5hbWUpIHtcbiAgICB2YXIgcmVzb3VyY2UgPSBnZW9Tb3VyY2VNYW5hZ2VyLmdldEdlb1Jlc291cmNlKG1hcE5hbWUpO1xuICAgIGlmIChyZXNvdXJjZSAmJiByZXNvdXJjZS50eXBlID09PSAnZ2VvU1ZHJykge1xuICAgICAgdmFyIHN2Z0dyYXBoaWMgPSByZXNvdXJjZS51c2VHcmFwaGljKHRoaXMudWlkKTtcbiAgICAgIHRoaXMuX3N2Z0dyb3VwLmFkZChzdmdHcmFwaGljLnJvb3QpO1xuICAgICAgdGhpcy5fc3ZnR3JhcGhpY1JlY29yZCA9IHN2Z0dyYXBoaWM7XG4gICAgICB0aGlzLl9zdmdNYXBOYW1lID0gbWFwTmFtZTtcbiAgICB9XG4gIH07XG4gIE1hcERyYXcucHJvdG90eXBlLl9mcmVlU1ZHID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYXBOYW1lID0gdGhpcy5fc3ZnTWFwTmFtZTtcbiAgICBpZiAobWFwTmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZXNvdXJjZSA9IGdlb1NvdXJjZU1hbmFnZXIuZ2V0R2VvUmVzb3VyY2UobWFwTmFtZSk7XG4gICAgaWYgKHJlc291cmNlICYmIHJlc291cmNlLnR5cGUgPT09ICdnZW9TVkcnKSB7XG4gICAgICByZXNvdXJjZS5mcmVlR3JhcGhpYyh0aGlzLnVpZCk7XG4gICAgfVxuICAgIHRoaXMuX3N2Z0dyYXBoaWNSZWNvcmQgPSBudWxsO1xuICAgIHRoaXMuX3N2Z0Rpc3BhdGNoZXJNYXAgPSBudWxsO1xuICAgIHRoaXMuX3N2Z0dyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMuX3N2Z01hcE5hbWUgPSBudWxsO1xuICB9O1xuICBNYXBEcmF3LnByb3RvdHlwZS5fdXBkYXRlQ29udHJvbGxlciA9IGZ1bmN0aW9uIChtYXBPckdlb01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZ2VvID0gbWFwT3JHZW9Nb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBjb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlcjtcbiAgICB2YXIgY29udHJvbGxlckhvc3QgPSB0aGlzLl9jb250cm9sbGVySG9zdDtcbiAgICAvLyBAdHMtaWdub3JlIEZJWE1FOlRTXG4gICAgY29udHJvbGxlckhvc3Quem9vbUxpbWl0ID0gbWFwT3JHZW9Nb2RlbC5nZXQoJ3NjYWxlTGltaXQnKTtcbiAgICBjb250cm9sbGVySG9zdC56b29tID0gZ2VvLmdldFpvb20oKTtcbiAgICAvLyByb2FtVHlwZSBpcyB3aWxsIGJlIHNldCBkZWZhdWx0IHRydWUgaWYgaXQgaXMgbnVsbFxuICAgIC8vIEB0cy1pZ25vcmUgRklYTUU6VFNcbiAgICBjb250cm9sbGVyLmVuYWJsZShtYXBPckdlb01vZGVsLmdldCgncm9hbScpIHx8IGZhbHNlKTtcbiAgICB2YXIgbWFpblR5cGUgPSBtYXBPckdlb01vZGVsLm1haW5UeXBlO1xuICAgIGZ1bmN0aW9uIG1ha2VBY3Rpb25CYXNlKCkge1xuICAgICAgdmFyIGFjdGlvbiA9IHtcbiAgICAgICAgdHlwZTogJ2dlb1JvYW0nLFxuICAgICAgICBjb21wb25lbnRUeXBlOiBtYWluVHlwZVxuICAgICAgfTtcbiAgICAgIGFjdGlvblttYWluVHlwZSArICdJZCddID0gbWFwT3JHZW9Nb2RlbC5pZDtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfVxuICAgIGNvbnRyb2xsZXIub2ZmKCdwYW4nKS5vbigncGFuJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX21vdXNlRG93bkZsYWcgPSBmYWxzZTtcbiAgICAgIHJvYW1IZWxwZXIudXBkYXRlVmlld09uUGFuKGNvbnRyb2xsZXJIb3N0LCBlLmR4LCBlLmR5KTtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih6clV0aWwuZXh0ZW5kKG1ha2VBY3Rpb25CYXNlKCksIHtcbiAgICAgICAgZHg6IGUuZHgsXG4gICAgICAgIGR5OiBlLmR5LFxuICAgICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSwgdGhpcyk7XG4gICAgY29udHJvbGxlci5vZmYoJ3pvb20nKS5vbignem9vbScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9tb3VzZURvd25GbGFnID0gZmFsc2U7XG4gICAgICByb2FtSGVscGVyLnVwZGF0ZVZpZXdPblpvb20oY29udHJvbGxlckhvc3QsIGUuc2NhbGUsIGUub3JpZ2luWCwgZS5vcmlnaW5ZKTtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih6clV0aWwuZXh0ZW5kKG1ha2VBY3Rpb25CYXNlKCksIHtcbiAgICAgICAgdG90YWxab29tOiBjb250cm9sbGVySG9zdC56b29tLFxuICAgICAgICB6b29tOiBlLnNjYWxlLFxuICAgICAgICBvcmlnaW5YOiBlLm9yaWdpblgsXG4gICAgICAgIG9yaWdpblk6IGUub3JpZ2luWSxcbiAgICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0sIHRoaXMpO1xuICAgIGNvbnRyb2xsZXIuc2V0UG9pbnRlckNoZWNrZXIoZnVuY3Rpb24gKGUsIHgsIHkpIHtcbiAgICAgIHJldHVybiBnZW8uY29udGFpblBvaW50KFt4LCB5XSkgJiYgIW9uSXJyZWxldmFudEVsZW1lbnQoZSwgYXBpLCBtYXBPckdlb01vZGVsKTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogRklYTUU6IHRoaXMgaXMgYSB0ZW1wb3JhcmlseSB3b3JrYXJvdW5kLlxyXG4gICAqIFdoZW4gYGdlb1JvYW1gIHRoZSBlbGVtZW50cyBuZWVkIHRvIGJlIHJlc2V0IGluIGBNYXBWaWV3WydyZW5kZXInXWAsIGJlY2F1c2UgdGhlIHByb3BzIGxpa2VcclxuICAgKiBgaWdub3JlYCBtaWdodCBoYXZlIGJlZW4gbW9kaWZpZWQgYnkgYExhYmVsTWFuYWdlcmAsIGFuZCBgTGFiZWxNYW5hZ2VyI2FkZExhYmVsc09mU2VyaWVzYFxyXG4gICAqIHdpbGwgc3Vic2VxdWVudGx5IGNhY2hlIGBkZWZhdWx0QXR0cmAgbGlrZSBgaWdub3JlYC4gSWYgZG8gbm90IGRvIHRoaXMgcmVzZXQsIHRoZSBtb2RpZmllZFxyXG4gICAqIHByb3BzIHdpbGwgaGF2ZSBubyBjaGFuY2UgdG8gYmUgcmVzdG9yZWQuXHJcbiAgICogTm90ZTogVGhpcyByZXNldCBzaG91bGQgYmUgYWZ0ZXIgYGNsZWFyU3RhdGVzYCBpbiBgcmVuZGVyU2VyaWVzYCBiZWNhdXNlIGB1c2VTdGF0ZXNgIGluXHJcbiAgICogYHJlbmRlclNlcmllc2Agd2lsbCBjYWNoZSB0aGUgbW9kaWZpZWQgYGlnbm9yZWAgdG8gYGVsLl9ub3JtYWxTdGF0ZWAuXHJcbiAgICogVE9ETzpcclxuICAgKiBVc2UgY2xvbmUvaW1tdXRhYmxlIGluIGBMYWJlbE1hbmFnZXJgP1xyXG4gICAqL1xuICBNYXBEcmF3LnByb3RvdHlwZS5yZXNldEZvckxhYmVsTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICB2YXIgbGFiZWwgPSBlbC5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgIGxhYmVsLmlnbm9yZSA9IG1hcExhYmVsUmF3KGxhYmVsKS5pZ25vcmU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIE1hcERyYXcucHJvdG90eXBlLl91cGRhdGVNYXBTZWxlY3RIYW5kbGVyID0gZnVuY3Rpb24gKG1hcE9yR2VvTW9kZWwsIHJlZ2lvbnNHcm91cCwgYXBpLCBmcm9tVmlldykge1xuICAgIHZhciBtYXBEcmF3ID0gdGhpcztcbiAgICByZWdpb25zR3JvdXAub2ZmKCdtb3VzZWRvd24nKTtcbiAgICByZWdpb25zR3JvdXAub2ZmKCdjbGljaycpO1xuICAgIC8vIEB0cy1pZ25vcmUgRklYTUU6VFMgcmVzb2x2ZSB0eXBlIGNvbmZsaWN0XG4gICAgaWYgKG1hcE9yR2VvTW9kZWwuZ2V0KCdzZWxlY3RlZE1vZGUnKSkge1xuICAgICAgcmVnaW9uc0dyb3VwLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1hcERyYXcuX21vdXNlRG93bkZsYWcgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICByZWdpb25zR3JvdXAub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFtYXBEcmF3Ll9tb3VzZURvd25GbGFnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hcERyYXcuX21vdXNlRG93bkZsYWcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE1hcERyYXc7XG59KCk7XG47XG5mdW5jdGlvbiBhcHBseU9wdGlvblN0eWxlRm9yUmVnaW9uKHZpZXdCdWlsZEN0eCwgZWwsIGRhdGFJbmRleCwgcmVnaW9uTW9kZWwpIHtcbiAgLy8gQWxsIG9mIHRoZSBwYXRoIGFyZSB1c2luZyBgaXRlbVN0eWxlYCwgYmVjYXVzZVxuICAvLyAoMSkgU29tZSBTVkcgYWxzbyB1c2UgZmlsbCBvbiBwb2x5bGluZSAoVGhlIGRpZmZlcmVudCBiZXR3ZWVuXG4gIC8vIHBvbHlsaW5lIGFuZCBwb2x5Z29uIGlzIFwib3BlblwiIG9yIFwiY2xvc2VcIiBidXQgbm90IGZpbGwgb3Igbm90KS5cbiAgLy8gKDIpIEZvciB0aGUgY29tbW9uIHByb3BzIGxpa2Ugb3BhY2l0eSwgaWYgc29tZSB1c2UgaXRlbVN0eWxlXG4gIC8vIGFuZCBzb21lIHVzZSBgbGluZVN0eWxlYCwgaXQgbWlnaHQgY29uZnVzZSB1c2Vycy5cbiAgLy8gKDMpIE1vc3QgU1ZHIHVzZSA8cGF0aD4sIHdoZXJlIGNhbiBub3QgZGV0ZWN0IHdoZXRoZXIgdG8gZHJhdyBhIFwibGluZVwiXG4gIC8vIG9yIGEgZmlsbGVkIHNoYXBlLCBzbyB1c2UgYGl0ZW1TdHlsZWAgZm9yIDxwYXRoPi5cbiAgdmFyIG5vcm1hbFN0eWxlTW9kZWwgPSByZWdpb25Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJyk7XG4gIHZhciBlbXBoYXNpc1N0eWxlTW9kZWwgPSByZWdpb25Nb2RlbC5nZXRNb2RlbChbJ2VtcGhhc2lzJywgJ2l0ZW1TdHlsZSddKTtcbiAgdmFyIGJsdXJTdHlsZU1vZGVsID0gcmVnaW9uTW9kZWwuZ2V0TW9kZWwoWydibHVyJywgJ2l0ZW1TdHlsZSddKTtcbiAgdmFyIHNlbGVjdFN0eWxlTW9kZWwgPSByZWdpb25Nb2RlbC5nZXRNb2RlbChbJ3NlbGVjdCcsICdpdGVtU3R5bGUnXSk7XG4gIC8vIE5PVEU6IERPTidUIHVzZSAnc3R5bGUnIGluIHZpc3VhbCB3aGVuIGRyYXdpbmcgbWFwLlxuICAvLyBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIGZvciBkcmF3aW5nIHVuZGVybHlpbmcgbWFwIGZvciBib3RoIGdlbyBjb21wb25lbnQgYW5kIG1hcCBzZXJpZXMuXG4gIHZhciBub3JtYWxTdHlsZSA9IGdldEZpeGVkSXRlbVN0eWxlKG5vcm1hbFN0eWxlTW9kZWwpO1xuICB2YXIgZW1waGFzaXNTdHlsZSA9IGdldEZpeGVkSXRlbVN0eWxlKGVtcGhhc2lzU3R5bGVNb2RlbCk7XG4gIHZhciBzZWxlY3RTdHlsZSA9IGdldEZpeGVkSXRlbVN0eWxlKHNlbGVjdFN0eWxlTW9kZWwpO1xuICB2YXIgYmx1clN0eWxlID0gZ2V0Rml4ZWRJdGVtU3R5bGUoYmx1clN0eWxlTW9kZWwpO1xuICAvLyBVcGRhdGUgdGhlIGl0ZW1TdHlsZSBpZiBoYXMgZGF0YSB2aXN1YWxcbiAgdmFyIGRhdGEgPSB2aWV3QnVpbGRDdHguZGF0YTtcbiAgaWYgKGRhdGEpIHtcbiAgICAvLyBPbmx5IHZpc3VhbCBjb2xvciBvZiBlYWNoIGl0ZW0gd2lsbCBiZSB1c2VkLiBJdCBjYW4gYmUgZW5jb2RlZCBieSB2aXN1YWxNYXBcbiAgICAvLyBCdXQgdmlzdWFsIGNvbG9yIG9mIHNlcmllcyBpcyB1c2VkIGluIHN5bWJvbCBkcmF3aW5nXG4gICAgLy8gVmlzdWFsIGNvbG9yIGZvciBlYWNoIHNlcmllcyBpcyBmb3IgdGhlIHN5bWJvbCBkcmF3XG4gICAgdmFyIHN0eWxlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ3N0eWxlJyk7XG4gICAgdmFyIGRlY2FsID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ2RlY2FsJyk7XG4gICAgaWYgKHZpZXdCdWlsZEN0eC5pc1Zpc3VhbEVuY29kZWRCeVZpc3VhbE1hcCAmJiBzdHlsZS5maWxsKSB7XG4gICAgICBub3JtYWxTdHlsZS5maWxsID0gc3R5bGUuZmlsbDtcbiAgICB9XG4gICAgaWYgKGRlY2FsKSB7XG4gICAgICBub3JtYWxTdHlsZS5kZWNhbCA9IGNyZWF0ZU9yVXBkYXRlUGF0dGVybkZyb21EZWNhbChkZWNhbCwgdmlld0J1aWxkQ3R4LmFwaSk7XG4gICAgfVxuICB9XG4gIC8vIFNWRyB0ZXh0LCB0c3BhbiBhbmQgaW1hZ2UgY2FuIGJlIG5hbWVkIGJ1dCBub3Qgc3VwcG9yZXRlZFxuICAvLyB0byBiZSBzdHlsZWQgYnkgcmVnaW9uIG9wdGlvbiB5ZXQuXG4gIGVsLnNldFN0eWxlKG5vcm1hbFN0eWxlKTtcbiAgZWwuc3R5bGUuc3Ryb2tlTm9TY2FsZSA9IHRydWU7XG4gIGVsLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpLnN0eWxlID0gZW1waGFzaXNTdHlsZTtcbiAgZWwuZW5zdXJlU3RhdGUoJ3NlbGVjdCcpLnN0eWxlID0gc2VsZWN0U3R5bGU7XG4gIGVsLmVuc3VyZVN0YXRlKCdibHVyJykuc3R5bGUgPSBibHVyU3R5bGU7XG4gIC8vIEVuYWJsZSBibHVyXG4gIHNldERlZmF1bHRTdGF0ZVByb3h5KGVsKTtcbn1cbmZ1bmN0aW9uIHJlc2V0TGFiZWxGb3JSZWdpb24odmlld0J1aWxkQ3R4LCBlbCwgcmVnaW9uTmFtZSwgcmVnaW9uTW9kZWwsIG1hcE9yR2VvTW9kZWwsXG4vLyBFeGlzdCBvbmx5IGlmIGB2aWV3QnVpbGRDdHguZGF0YWAgZXhpc3RzLlxuZGF0YUlkeCxcbi8vIElmIGxhYmVsWFkgbm90IHByb3ZpZGVkLCB1c2UgYHRleHRDb25maWcucG9zaXRpb246ICdpbnNpZGUnYFxubGFiZWxYWSkge1xuICB2YXIgZGF0YSA9IHZpZXdCdWlsZEN0eC5kYXRhO1xuICB2YXIgaXNHZW8gPSB2aWV3QnVpbGRDdHguaXNHZW87XG4gIHZhciBpc0RhdGFOYU4gPSBkYXRhICYmIGlzTmFOKGRhdGEuZ2V0KGRhdGEubWFwRGltZW5zaW9uKCd2YWx1ZScpLCBkYXRhSWR4KSk7XG4gIHZhciBpdGVtTGF5b3V0ID0gZGF0YSAmJiBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUlkeCk7XG4gIC8vIEluIHRoZSBmb2xsb3dpbmcgY2FzZXMgbGFiZWwgd2lsbCBiZSBkcmF3blxuICAvLyAxLiBJbiBtYXAgc2VyaWVzIGFuZCBkYXRhIHZhbHVlIGlzIE5hTlxuICAvLyAyLiBJbiBnZW8gY29tcG9uZW50XG4gIC8vIDMuIFJlZ2lvbiBoYXMgbm8gc2VyaWVzIGxlZ2VuZEljb24sIHdoaWNoIHdpbGwgYmUgYWRkIGEgc2hvd0xhYmVsIGZsYWcgaW4gbWFwU3ltYm9sTGF5b3V0XG4gIGlmIChpc0dlbyB8fCBpc0RhdGFOYU4gfHwgaXRlbUxheW91dCAmJiBpdGVtTGF5b3V0LnNob3dMYWJlbCkge1xuICAgIHZhciBxdWVyeSA9ICFpc0dlbyA/IGRhdGFJZHggOiByZWdpb25OYW1lO1xuICAgIHZhciBsYWJlbEZldGNoZXIgPSB2b2lkIDA7XG4gICAgLy8gQ29uc2lkZXIgZGF0YUlkeCBub3QgZm91bmQuXG4gICAgaWYgKCFkYXRhIHx8IGRhdGFJZHggPj0gMCkge1xuICAgICAgbGFiZWxGZXRjaGVyID0gbWFwT3JHZW9Nb2RlbDtcbiAgICB9XG4gICAgdmFyIHNwZWNpZmllZFRleHRPcHQgPSBsYWJlbFhZID8ge1xuICAgICAgbm9ybWFsOiB7XG4gICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICAgIH1cbiAgICB9IDogbnVsbDtcbiAgICAvLyBDYXZlYXQ6IG11c3QgYmUgY2FsbGVkIGFmdGVyIGBzZXREZWZhdWx0U3RhdGVQcm94eShlbCk7YCBjYWxsZWQuXG4gICAgLy8gYmVjYXVzZSB0ZXh0Q29udGVudCB3aWxsIGJlIGFzc2lnbiB3aXRoIGBlbC5zdGF0ZVByb3h5YCBpbnNpZGUuXG4gICAgc2V0TGFiZWxTdHlsZShlbCwgZ2V0TGFiZWxTdGF0ZXNNb2RlbHMocmVnaW9uTW9kZWwpLCB7XG4gICAgICBsYWJlbEZldGNoZXI6IGxhYmVsRmV0Y2hlcixcbiAgICAgIGxhYmVsRGF0YUluZGV4OiBxdWVyeSxcbiAgICAgIGRlZmF1bHRUZXh0OiByZWdpb25OYW1lXG4gICAgfSwgc3BlY2lmaWVkVGV4dE9wdCk7XG4gICAgdmFyIHRleHRFbCA9IGVsLmdldFRleHRDb250ZW50KCk7XG4gICAgaWYgKHRleHRFbCkge1xuICAgICAgbWFwTGFiZWxSYXcodGV4dEVsKS5pZ25vcmUgPSB0ZXh0RWwuaWdub3JlO1xuICAgICAgaWYgKGVsLnRleHRDb25maWcgJiYgbGFiZWxYWSkge1xuICAgICAgICAvLyBDb21wdXRlIGEgcmVsYXRpdmUgb2Zmc2V0IGJhc2VkIG9uIHRoZSBlbCBib3VuZGluZyByZWN0LlxuICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgICAgIC8vIE5lZWQgdG8gbWFrZSBzdXJlIHRoZSBwZXJjZW50IHBvc2l0aW9uIGJhc2Ugb24gdGhlIHNhbWUgcmVjdCBpbiBub3JtYWwgYW5kXG4gICAgICAgIC8vIGVtcGhhc2lzIHN0YXRlLiBPdGhlcndpc2UgaWYgdXNpbmcgYm91bmRpbmdSZWN0IG9mIGVsLCBidXQgdGhlIGVtcGhhc2lzIHN0YXRlXG4gICAgICAgIC8vIGhhcyBib3JkZXJXaWR0aCAoZXZlbiAwLjVweCksIHRoZSB0ZXh0IHBvc2l0aW9uIHdpbGwgYmUgY2hhbmdlZCBvYnZpb3VzbHlcbiAgICAgICAgLy8gaWYgdGhlIHBvc2l0aW9uIGlzIHZlcnkgYmlnIGxpa2UgWycxMjM0JScsICcxMzQ1JSddLlxuICAgICAgICBlbC50ZXh0Q29uZmlnLmxheW91dFJlY3QgPSByZWN0O1xuICAgICAgICBlbC50ZXh0Q29uZmlnLnBvc2l0aW9uID0gWyhsYWJlbFhZWzBdIC0gcmVjdC54KSAvIHJlY3Qud2lkdGggKiAxMDAgKyAnJScsIChsYWJlbFhZWzFdIC0gcmVjdC55KSAvIHJlY3QuaGVpZ2h0ICogMTAwICsgJyUnXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUEVORElORzpcbiAgICAvLyBJZiBsYWJlbExheW91dCBpcyBlbmFibGVkICh0ZXN0L2xhYmVsLWxheW91dC5odG1sKSwgZWwuZGF0YUluZGV4IHNob3VsZCBiZSBzcGVjaWZpZWQuXG4gICAgLy8gQnV0IGVsLmRhdGFJbmRleCBpcyBhbHNvIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdXNlciBldmVudCBzaG91bGQgYmUgdHJpZ2dlcmVkLFxuICAgIC8vIHdoZXJlIGVsLnNlcmllc0luZGV4IG9yIGVsLmRhdGFNb2RlbCBtdXN0IGJlIHNwZWNpZmllZC4gQXQgcHJlc2VudCBmb3IgYSBzaW5nbGUgZWxcbiAgICAvLyB0aGVyZSBpcyBub3QgY2FzZSB0aGF0IFwib25seSBsYWJlbCBsYXlvdXQgZW5hYmxlZCBidXQgdXNlciBldmVudCBkaXNhYmxlZFwiLCBzbyBoZXJlXG4gICAgLy8gd2UgZGVwZW5kcyBgcmVzZXRFdmVudFRyaWdnZXJGb3JSZWdpb25gIHRvIGRvIHRoZSBqb2Igb2Ygc2V0dGluZyBgZWwuZGF0YUluZGV4YC5cbiAgICBlbC5kaXNhYmxlTGFiZWxBbmltYXRpb24gPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGVsLnJlbW92ZVRleHRDb250ZW50KCk7XG4gICAgZWwucmVtb3ZlVGV4dENvbmZpZygpO1xuICAgIGVsLmRpc2FibGVMYWJlbEFuaW1hdGlvbiA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc2V0RXZlbnRUcmlnZ2VyRm9yUmVnaW9uKHZpZXdCdWlsZEN0eCwgZXZlbnRUcmlnZ2VyLCByZWdpb25OYW1lLCByZWdpb25Nb2RlbCwgbWFwT3JHZW9Nb2RlbCxcbi8vIEV4aXN0IG9ubHkgaWYgYHZpZXdCdWlsZEN0eC5kYXRhYCBleGlzdHMuXG5kYXRhSWR4KSB7XG4gIC8vIHNldEl0ZW1HcmFwaGljRWwsIHNldEhvdmVyU3R5bGUgYWZ0ZXIgYWxsIHBvbHlnb25zIGFuZCBsYWJlbHNcbiAgLy8gYXJlIGFkZGVkIHRvIHRoZSByZWdpb25Hcm91cFxuICBpZiAodmlld0J1aWxkQ3R4LmRhdGEpIHtcbiAgICAvLyBGSVhNRTogd2hlbiBzZXJpZXMtbWFwIHVzZSBhIFNWRyBtYXAsIGFuZCB0aGVyZSBhcmUgZHVwbGljYXRlZCBuYW1lIHNwZWNpZmllZFxuICAgIC8vIG9uIGRpZmZlcmVudCBTVkcgZWxlbWVudHMsIGFmdGVyIGBkYXRhLnNldEl0ZW1HcmFwaGljRWwoLi4uKWA6XG4gICAgLy8gKDEpIGFsbCBvZiB0aGVtIHdpbGwgYmUgbW91bnRlZCB3aXRoIGBkYXRhSW5kZXhgLCBgc2VyaWVzSW5kZXhgLCBzbyB0aGF0IHRvb2x0aXBcbiAgICAvLyBjYW4gYmUgdHJpZ2dlcmVkIG9ubHkgbW91c2UgaG92ZXIuIFRoYXQncyBjb3JyZWN0LlxuICAgIC8vICgyKSBvbmx5IHRoZSBsYXN0IGVsZW1lbnQgd2lsbCBiZSBrZXB0IGluIGBkYXRhYCwgc28gdGhhdCBpZiB0cmlnZ2VyIHRvb2x0aXBcbiAgICAvLyBieSBgZGlzcGF0Y2hBY3Rpb25gLCBvbmx5IHRoZSBsYXN0IG9uZSBjYW4gYmUgZm91bmQgYW5kIHRyaWdnZXJlZC4gVGhhdCBtaWdodCBiZVxuICAgIC8vIG5vdCBjb3JyZWN0LiBXZSB3aWxsIGZpeCBpdCBpbiBmdXR1cmUgaWYgYW55b25lIGRlbWFuZGluZyB0aGF0LlxuICAgIHZpZXdCdWlsZEN0eC5kYXRhLnNldEl0ZW1HcmFwaGljRWwoZGF0YUlkeCwgZXZlbnRUcmlnZ2VyKTtcbiAgfVxuICAvLyBzZXJpZXMtbWFwIHdpbGwgbm90IHRyaWdnZXIgXCJnZW9zZWxlY3RjaGFuZ2VcIiBubyBtYXR0ZXIgaXQgaXNcbiAgLy8gYmFzZWQgb24gYSBkZWNsYXJlZCBnZW8gY29tcG9uZW50LiBCZWNhdXNlIHNlcmllcy1tYXAgd2lsbFxuICAvLyB0cmlnZ2VyIFwic2VsZWN0Y2hhbmdlXCIuIElmIGl0IHRyaWdnZXIgYm90aCB0aGUgdHdvIGV2ZW50cyxcbiAgLy8gSWYgdXNlcnMgY2FsbCBgY2hhcnQuZGlzcGF0Y2hBY3Rpb24oe3R5cGU6ICd0b2dnbGVTZWxlY3QnfSlgLFxuICAvLyBpdCBub3QgZWFzeSB0byBhbHNvIGZpcmUgZXZlbnQgXCJnZW9zZWxlY3RjaGFuZ2VkXCIuXG4gIGVsc2Uge1xuICAgIC8vIFBhY2thZ2UgY3VzdG9tIG1vdXNlIGV2ZW50IGZvciBnZW8gY29tcG9uZW50XG4gICAgZ2V0RUNEYXRhKGV2ZW50VHJpZ2dlcikuZXZlbnREYXRhID0ge1xuICAgICAgY29tcG9uZW50VHlwZTogJ2dlbycsXG4gICAgICBjb21wb25lbnRJbmRleDogbWFwT3JHZW9Nb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgIGdlb0luZGV4OiBtYXBPckdlb01vZGVsLmNvbXBvbmVudEluZGV4LFxuICAgICAgbmFtZTogcmVnaW9uTmFtZSxcbiAgICAgIHJlZ2lvbjogcmVnaW9uTW9kZWwgJiYgcmVnaW9uTW9kZWwub3B0aW9uIHx8IHt9XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRUb29sdGlwRm9yUmVnaW9uKHZpZXdCdWlsZEN0eCwgZWwsIHJlZ2lvbk5hbWUsIHJlZ2lvbk1vZGVsLCBtYXBPckdlb01vZGVsKSB7XG4gIGlmICghdmlld0J1aWxkQ3R4LmRhdGEpIHtcbiAgICBncmFwaGljLnNldFRvb2x0aXBDb25maWcoe1xuICAgICAgZWw6IGVsLFxuICAgICAgY29tcG9uZW50TW9kZWw6IG1hcE9yR2VvTW9kZWwsXG4gICAgICBpdGVtTmFtZTogcmVnaW9uTmFtZSxcbiAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU6VFMgZml4IHRoZSBcImNvbXBhdGlibGUgd2l0aCBlYWNoIG90aGVyXCI/XG4gICAgICBpdGVtVG9vbHRpcE9wdGlvbjogcmVnaW9uTW9kZWwuZ2V0KCd0b29sdGlwJylcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRTdGF0ZVRyaWdnZXJGb3JSZWdpb24odmlld0J1aWxkQ3R4LCBlbCwgcmVnaW9uTmFtZSwgcmVnaW9uTW9kZWwsIG1hcE9yR2VvTW9kZWwpIHtcbiAgLy8gQHRzLWlnbm9yZSBGSVhNRTpUUyBmaXggdGhlIFwiY29tcGF0aWJsZSB3aXRoIGVhY2ggb3RoZXJcIj9cbiAgZWwuaGlnaERvd25TaWxlbnRPblRvdWNoID0gISFtYXBPckdlb01vZGVsLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG4gIC8vIEB0cy1pZ25vcmUgRklYTUU6VFMgZml4IHRoZSBcImNvbXBhdGlibGUgd2l0aCBlYWNoIG90aGVyXCI/XG4gIHZhciBlbXBoYXNpc01vZGVsID0gcmVnaW9uTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJyk7XG4gIHZhciBmb2N1cyA9IGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpO1xuICB0b2dnbGVIb3ZlckVtcGhhc2lzKGVsLCBmb2N1cywgZW1waGFzaXNNb2RlbC5nZXQoJ2JsdXJTY29wZScpLCBlbXBoYXNpc01vZGVsLmdldCgnZGlzYWJsZWQnKSk7XG4gIGlmICh2aWV3QnVpbGRDdHguaXNHZW8pIHtcbiAgICBlbmFibGVDb21wb25lbnRIaWdoRG93bkZlYXR1cmVzKGVsLCBtYXBPckdlb01vZGVsLCByZWdpb25OYW1lKTtcbiAgfVxuICByZXR1cm4gZm9jdXM7XG59XG5mdW5jdGlvbiBwcm9qZWN0UG9seXMocmluZ3MsXG4vLyBQb2x5Z29ucyBpbmNsdWRlIGV4dGVyaW9yIGFuZCBpbnRlcmlvcnMuIE9yIHBvbHlsaW5lcy5cbmNyZWF0ZVN0cmVhbSwgaXNMaW5lKSB7XG4gIHZhciBwb2x5Z29ucyA9IFtdO1xuICB2YXIgY3VyUG9seTtcbiAgZnVuY3Rpb24gc3RhcnRQb2x5Z29uKCkge1xuICAgIGN1clBvbHkgPSBbXTtcbiAgfVxuICBmdW5jdGlvbiBlbmRQb2x5Z29uKCkge1xuICAgIGlmIChjdXJQb2x5Lmxlbmd0aCkge1xuICAgICAgcG9seWdvbnMucHVzaChjdXJQb2x5KTtcbiAgICAgIGN1clBvbHkgPSBbXTtcbiAgICB9XG4gIH1cbiAgdmFyIHN0cmVhbSA9IGNyZWF0ZVN0cmVhbSh7XG4gICAgcG9seWdvblN0YXJ0OiBzdGFydFBvbHlnb24sXG4gICAgcG9seWdvbkVuZDogZW5kUG9seWdvbixcbiAgICBsaW5lU3RhcnQ6IHN0YXJ0UG9seWdvbixcbiAgICBsaW5lRW5kOiBlbmRQb2x5Z29uLFxuICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gTWF5IGhhdmUgTmFOIHZhbHVlcyBmcm9tIHN0cmVhbS5cbiAgICAgIGlmIChpc0Zpbml0ZSh4KSAmJiBpc0Zpbml0ZSh5KSkge1xuICAgICAgICBjdXJQb2x5LnB1c2goW3gsIHldKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNwaGVyZTogZnVuY3Rpb24gKCkge31cbiAgfSk7XG4gICFpc0xpbmUgJiYgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICB6clV0aWwuZWFjaChyaW5ncywgZnVuY3Rpb24gKHJpbmcpIHtcbiAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdHJlYW0ucG9pbnQocmluZ1tpXVswXSwgcmluZ1tpXVsxXSk7XG4gICAgfVxuICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gIH0pO1xuICAhaXNMaW5lICYmIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gIHJldHVybiBwb2x5Z29ucztcbn1cbmV4cG9ydCBkZWZhdWx0IE1hcERyYXc7XG4vLyBAdHMtaWdub3JlIEZJWE1FOlRTIGZpeCB0aGUgXCJjb21wYXRpYmxlIHdpdGggZWFjaCBvdGhlclwiPyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8027\n")},18909:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/radar/RadarModel.js\nvar RadarModel = __webpack_require__(71674);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axis/AxisBuilder.js\nvar AxisBuilder = __webpack_require__(89598);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Circle.js\nvar Circle = __webpack_require__(31571);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Ring.js\nvar Ring = __webpack_require__(42933);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polyline.js\nvar Polyline = __webpack_require__(39195);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polygon.js\nvar Polygon = __webpack_require__(52505);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar Component = __webpack_require__(59109);\n;// ./node_modules/echarts/lib/component/radar/RadarView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar RadarView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(RadarView, _super);\n  function RadarView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = RadarView.type;\n    return _this;\n  }\n  RadarView.prototype.render = function (radarModel, ecModel, api) {\n    var group = this.group;\n    group.removeAll();\n    this._buildAxes(radarModel);\n    this._buildSplitLineAndArea(radarModel);\n  };\n  RadarView.prototype._buildAxes = function (radarModel) {\n    var radar = radarModel.coordinateSystem;\n    var indicatorAxes = radar.getIndicatorAxes();\n    var axisBuilders = util.map(indicatorAxes, function (indicatorAxis) {\n      var axisName = indicatorAxis.model.get('showName') ? indicatorAxis.name : ''; // hide name\n      var axisBuilder = new AxisBuilder/* default */.A(indicatorAxis.model, {\n        axisName: axisName,\n        position: [radar.cx, radar.cy],\n        rotation: indicatorAxis.angle,\n        labelDirection: -1,\n        tickDirection: -1,\n        nameDirection: 1\n      });\n      return axisBuilder;\n    });\n    util.each(axisBuilders, function (axisBuilder) {\n      util.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n      this.group.add(axisBuilder.getGroup());\n    }, this);\n  };\n  RadarView.prototype._buildSplitLineAndArea = function (radarModel) {\n    var radar = radarModel.coordinateSystem;\n    var indicatorAxes = radar.getIndicatorAxes();\n    if (!indicatorAxes.length) {\n      return;\n    }\n    var shape = radarModel.get('shape');\n    var splitLineModel = radarModel.getModel('splitLine');\n    var splitAreaModel = radarModel.getModel('splitArea');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var showSplitLine = splitLineModel.get('show');\n    var showSplitArea = splitAreaModel.get('show');\n    var splitLineColors = lineStyleModel.get('color');\n    var splitAreaColors = areaStyleModel.get('color');\n    var splitLineColorsArr = util.isArray(splitLineColors) ? splitLineColors : [splitLineColors];\n    var splitAreaColorsArr = util.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];\n    var splitLines = [];\n    var splitAreas = [];\n    function getColorIndex(areaOrLine, areaOrLineColorList, idx) {\n      var colorIndex = idx % areaOrLineColorList.length;\n      areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];\n      return colorIndex;\n    }\n    if (shape === 'circle') {\n      var ticksRadius = indicatorAxes[0].getTicksCoords();\n      var cx = radar.cx;\n      var cy = radar.cy;\n      for (var i = 0; i < ticksRadius.length; i++) {\n        if (showSplitLine) {\n          var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);\n          splitLines[colorIndex].push(new Circle/* default */.A({\n            shape: {\n              cx: cx,\n              cy: cy,\n              r: ticksRadius[i].coord\n            }\n          }));\n        }\n        if (showSplitArea && i < ticksRadius.length - 1) {\n          var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i);\n          splitAreas[colorIndex].push(new Ring/* default */.A({\n            shape: {\n              cx: cx,\n              cy: cy,\n              r0: ticksRadius[i].coord,\n              r: ticksRadius[i + 1].coord\n            }\n          }));\n        }\n      }\n    }\n    // Polyyon\n    else {\n      var realSplitNumber_1;\n      var axesTicksPoints = util.map(indicatorAxes, function (indicatorAxis, idx) {\n        var ticksCoords = indicatorAxis.getTicksCoords();\n        realSplitNumber_1 = realSplitNumber_1 == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber_1);\n        return util.map(ticksCoords, function (tickCoord) {\n          return radar.coordToPoint(tickCoord.coord, idx);\n        });\n      });\n      var prevPoints = [];\n      for (var i = 0; i <= realSplitNumber_1; i++) {\n        var points = [];\n        for (var j = 0; j < indicatorAxes.length; j++) {\n          points.push(axesTicksPoints[j][i]);\n        }\n        // Close\n        if (points[0]) {\n          points.push(points[0].slice());\n        } else {\n          if (false) {}\n        }\n        if (showSplitLine) {\n          var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);\n          splitLines[colorIndex].push(new Polyline/* default */.A({\n            shape: {\n              points: points\n            }\n          }));\n        }\n        if (showSplitArea && prevPoints) {\n          var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i - 1);\n          splitAreas[colorIndex].push(new Polygon/* default */.A({\n            shape: {\n              points: points.concat(prevPoints)\n            }\n          }));\n        }\n        prevPoints = points.slice().reverse();\n      }\n    }\n    var lineStyle = lineStyleModel.getLineStyle();\n    var areaStyle = areaStyleModel.getAreaStyle();\n    // Add splitArea before splitLine\n    util.each(splitAreas, function (splitAreas, idx) {\n      this.group.add(graphic.mergePath(splitAreas, {\n        style: util.defaults({\n          stroke: 'none',\n          fill: splitAreaColorsArr[idx % splitAreaColorsArr.length]\n        }, areaStyle),\n        silent: true\n      }));\n    }, this);\n    util.each(splitLines, function (splitLines, idx) {\n      this.group.add(graphic.mergePath(splitLines, {\n        style: util.defaults({\n          fill: 'none',\n          stroke: splitLineColorsArr[idx % splitLineColorsArr.length]\n        }, lineStyle),\n        silent: true\n      }));\n    }, this);\n  };\n  RadarView.type = 'radar';\n  return RadarView;\n}(Component/* default */.A);\n/* harmony default export */ const radar_RadarView = (RadarView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/radar/Radar.js + 1 modules\nvar Radar = __webpack_require__(96504);\n;// ./node_modules/echarts/lib/component/radar/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction install(registers) {\n  registers.registerCoordinateSystem('radar', Radar/* default */.A);\n  registers.registerComponentModel(RadarModel/* default */.A);\n  registers.registerComponentView(radar_RadarView);\n  registers.registerVisual({\n    seriesType: 'radar',\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      // itemVisual symbol is for selected data\n      data.each(function (idx) {\n        data.setItemVisual(idx, 'legendIcon', 'roundRect');\n      });\n      // visual is for unselected data\n      data.setVisual('legendIcon', 'roundRect');\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg5MDkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvcmFkYXIvUmFkYXJWaWV3LmpzPzYzODYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9yYWRhci9pbnN0YWxsLmpzP2QwNmQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IEF4aXNCdWlsZGVyIGZyb20gJy4uL2F4aXMvQXhpc0J1aWxkZXIuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IENvbXBvbmVudFZpZXcgZnJvbSAnLi4vLi4vdmlldy9Db21wb25lbnQuanMnO1xudmFyIGF4aXNCdWlsZGVyQXR0cnMgPSBbJ2F4aXNMaW5lJywgJ2F4aXNUaWNrTGFiZWwnLCAnYXhpc05hbWUnXTtcbnZhciBSYWRhclZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUmFkYXJWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBSYWRhclZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IFJhZGFyVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBSYWRhclZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChyYWRhck1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMuX2J1aWxkQXhlcyhyYWRhck1vZGVsKTtcbiAgICB0aGlzLl9idWlsZFNwbGl0TGluZUFuZEFyZWEocmFkYXJNb2RlbCk7XG4gIH07XG4gIFJhZGFyVmlldy5wcm90b3R5cGUuX2J1aWxkQXhlcyA9IGZ1bmN0aW9uIChyYWRhck1vZGVsKSB7XG4gICAgdmFyIHJhZGFyID0gcmFkYXJNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBpbmRpY2F0b3JBeGVzID0gcmFkYXIuZ2V0SW5kaWNhdG9yQXhlcygpO1xuICAgIHZhciBheGlzQnVpbGRlcnMgPSB6clV0aWwubWFwKGluZGljYXRvckF4ZXMsIGZ1bmN0aW9uIChpbmRpY2F0b3JBeGlzKSB7XG4gICAgICB2YXIgYXhpc05hbWUgPSBpbmRpY2F0b3JBeGlzLm1vZGVsLmdldCgnc2hvd05hbWUnKSA/IGluZGljYXRvckF4aXMubmFtZSA6ICcnOyAvLyBoaWRlIG5hbWVcbiAgICAgIHZhciBheGlzQnVpbGRlciA9IG5ldyBBeGlzQnVpbGRlcihpbmRpY2F0b3JBeGlzLm1vZGVsLCB7XG4gICAgICAgIGF4aXNOYW1lOiBheGlzTmFtZSxcbiAgICAgICAgcG9zaXRpb246IFtyYWRhci5jeCwgcmFkYXIuY3ldLFxuICAgICAgICByb3RhdGlvbjogaW5kaWNhdG9yQXhpcy5hbmdsZSxcbiAgICAgICAgbGFiZWxEaXJlY3Rpb246IC0xLFxuICAgICAgICB0aWNrRGlyZWN0aW9uOiAtMSxcbiAgICAgICAgbmFtZURpcmVjdGlvbjogMVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXhpc0J1aWxkZXI7XG4gICAgfSk7XG4gICAgenJVdGlsLmVhY2goYXhpc0J1aWxkZXJzLCBmdW5jdGlvbiAoYXhpc0J1aWxkZXIpIHtcbiAgICAgIHpyVXRpbC5lYWNoKGF4aXNCdWlsZGVyQXR0cnMsIGF4aXNCdWlsZGVyLmFkZCwgYXhpc0J1aWxkZXIpO1xuICAgICAgdGhpcy5ncm91cC5hZGQoYXhpc0J1aWxkZXIuZ2V0R3JvdXAoKSk7XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIFJhZGFyVmlldy5wcm90b3R5cGUuX2J1aWxkU3BsaXRMaW5lQW5kQXJlYSA9IGZ1bmN0aW9uIChyYWRhck1vZGVsKSB7XG4gICAgdmFyIHJhZGFyID0gcmFkYXJNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBpbmRpY2F0b3JBeGVzID0gcmFkYXIuZ2V0SW5kaWNhdG9yQXhlcygpO1xuICAgIGlmICghaW5kaWNhdG9yQXhlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNoYXBlID0gcmFkYXJNb2RlbC5nZXQoJ3NoYXBlJyk7XG4gICAgdmFyIHNwbGl0TGluZU1vZGVsID0gcmFkYXJNb2RlbC5nZXRNb2RlbCgnc3BsaXRMaW5lJyk7XG4gICAgdmFyIHNwbGl0QXJlYU1vZGVsID0gcmFkYXJNb2RlbC5nZXRNb2RlbCgnc3BsaXRBcmVhJyk7XG4gICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gc3BsaXRMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgIHZhciBhcmVhU3R5bGVNb2RlbCA9IHNwbGl0QXJlYU1vZGVsLmdldE1vZGVsKCdhcmVhU3R5bGUnKTtcbiAgICB2YXIgc2hvd1NwbGl0TGluZSA9IHNwbGl0TGluZU1vZGVsLmdldCgnc2hvdycpO1xuICAgIHZhciBzaG93U3BsaXRBcmVhID0gc3BsaXRBcmVhTW9kZWwuZ2V0KCdzaG93Jyk7XG4gICAgdmFyIHNwbGl0TGluZUNvbG9ycyA9IGxpbmVTdHlsZU1vZGVsLmdldCgnY29sb3InKTtcbiAgICB2YXIgc3BsaXRBcmVhQ29sb3JzID0gYXJlYVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICAgIHZhciBzcGxpdExpbmVDb2xvcnNBcnIgPSB6clV0aWwuaXNBcnJheShzcGxpdExpbmVDb2xvcnMpID8gc3BsaXRMaW5lQ29sb3JzIDogW3NwbGl0TGluZUNvbG9yc107XG4gICAgdmFyIHNwbGl0QXJlYUNvbG9yc0FyciA9IHpyVXRpbC5pc0FycmF5KHNwbGl0QXJlYUNvbG9ycykgPyBzcGxpdEFyZWFDb2xvcnMgOiBbc3BsaXRBcmVhQ29sb3JzXTtcbiAgICB2YXIgc3BsaXRMaW5lcyA9IFtdO1xuICAgIHZhciBzcGxpdEFyZWFzID0gW107XG4gICAgZnVuY3Rpb24gZ2V0Q29sb3JJbmRleChhcmVhT3JMaW5lLCBhcmVhT3JMaW5lQ29sb3JMaXN0LCBpZHgpIHtcbiAgICAgIHZhciBjb2xvckluZGV4ID0gaWR4ICUgYXJlYU9yTGluZUNvbG9yTGlzdC5sZW5ndGg7XG4gICAgICBhcmVhT3JMaW5lW2NvbG9ySW5kZXhdID0gYXJlYU9yTGluZVtjb2xvckluZGV4XSB8fCBbXTtcbiAgICAgIHJldHVybiBjb2xvckluZGV4O1xuICAgIH1cbiAgICBpZiAoc2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICB2YXIgdGlja3NSYWRpdXMgPSBpbmRpY2F0b3JBeGVzWzBdLmdldFRpY2tzQ29vcmRzKCk7XG4gICAgICB2YXIgY3ggPSByYWRhci5jeDtcbiAgICAgIHZhciBjeSA9IHJhZGFyLmN5O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc1JhZGl1cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2hvd1NwbGl0TGluZSkge1xuICAgICAgICAgIHZhciBjb2xvckluZGV4ID0gZ2V0Q29sb3JJbmRleChzcGxpdExpbmVzLCBzcGxpdExpbmVDb2xvcnNBcnIsIGkpO1xuICAgICAgICAgIHNwbGl0TGluZXNbY29sb3JJbmRleF0ucHVzaChuZXcgZ3JhcGhpYy5DaXJjbGUoe1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICAgIHI6IHRpY2tzUmFkaXVzW2ldLmNvb3JkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG93U3BsaXRBcmVhICYmIGkgPCB0aWNrc1JhZGl1cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIGNvbG9ySW5kZXggPSBnZXRDb2xvckluZGV4KHNwbGl0QXJlYXMsIHNwbGl0QXJlYUNvbG9yc0FyciwgaSk7XG4gICAgICAgICAgc3BsaXRBcmVhc1tjb2xvckluZGV4XS5wdXNoKG5ldyBncmFwaGljLlJpbmcoe1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICAgIHIwOiB0aWNrc1JhZGl1c1tpXS5jb29yZCxcbiAgICAgICAgICAgICAgcjogdGlja3NSYWRpdXNbaSArIDFdLmNvb3JkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFBvbHl5b25cbiAgICBlbHNlIHtcbiAgICAgIHZhciByZWFsU3BsaXROdW1iZXJfMTtcbiAgICAgIHZhciBheGVzVGlja3NQb2ludHMgPSB6clV0aWwubWFwKGluZGljYXRvckF4ZXMsIGZ1bmN0aW9uIChpbmRpY2F0b3JBeGlzLCBpZHgpIHtcbiAgICAgICAgdmFyIHRpY2tzQ29vcmRzID0gaW5kaWNhdG9yQXhpcy5nZXRUaWNrc0Nvb3JkcygpO1xuICAgICAgICByZWFsU3BsaXROdW1iZXJfMSA9IHJlYWxTcGxpdE51bWJlcl8xID09IG51bGwgPyB0aWNrc0Nvb3Jkcy5sZW5ndGggLSAxIDogTWF0aC5taW4odGlja3NDb29yZHMubGVuZ3RoIC0gMSwgcmVhbFNwbGl0TnVtYmVyXzEpO1xuICAgICAgICByZXR1cm4genJVdGlsLm1hcCh0aWNrc0Nvb3JkcywgZnVuY3Rpb24gKHRpY2tDb29yZCkge1xuICAgICAgICAgIHJldHVybiByYWRhci5jb29yZFRvUG9pbnQodGlja0Nvb3JkLmNvb3JkLCBpZHgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHByZXZQb2ludHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHJlYWxTcGxpdE51bWJlcl8xOyBpKyspIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGluZGljYXRvckF4ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBwb2ludHMucHVzaChheGVzVGlja3NQb2ludHNbal1baV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsb3NlXG4gICAgICAgIGlmIChwb2ludHNbMF0pIHtcbiAgICAgICAgICBwb2ludHMucHVzaChwb2ludHNbMF0uc2xpY2UoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhblxcJ3QgZHJhdyB2YWx1ZSBheGlzICcgKyBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3dTcGxpdExpbmUpIHtcbiAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IGdldENvbG9ySW5kZXgoc3BsaXRMaW5lcywgc3BsaXRMaW5lQ29sb3JzQXJyLCBpKTtcbiAgICAgICAgICBzcGxpdExpbmVzW2NvbG9ySW5kZXhdLnB1c2gobmV3IGdyYXBoaWMuUG9seWxpbmUoe1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3dTcGxpdEFyZWEgJiYgcHJldlBvaW50cykge1xuICAgICAgICAgIHZhciBjb2xvckluZGV4ID0gZ2V0Q29sb3JJbmRleChzcGxpdEFyZWFzLCBzcGxpdEFyZWFDb2xvcnNBcnIsIGkgLSAxKTtcbiAgICAgICAgICBzcGxpdEFyZWFzW2NvbG9ySW5kZXhdLnB1c2gobmV3IGdyYXBoaWMuUG9seWdvbih7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICBwb2ludHM6IHBvaW50cy5jb25jYXQocHJldlBvaW50cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldlBvaW50cyA9IHBvaW50cy5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGxpbmVTdHlsZSA9IGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpO1xuICAgIHZhciBhcmVhU3R5bGUgPSBhcmVhU3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKTtcbiAgICAvLyBBZGQgc3BsaXRBcmVhIGJlZm9yZSBzcGxpdExpbmVcbiAgICB6clV0aWwuZWFjaChzcGxpdEFyZWFzLCBmdW5jdGlvbiAoc3BsaXRBcmVhcywgaWR4KSB7XG4gICAgICB0aGlzLmdyb3VwLmFkZChncmFwaGljLm1lcmdlUGF0aChzcGxpdEFyZWFzLCB7XG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIHN0cm9rZTogJ25vbmUnLFxuICAgICAgICAgIGZpbGw6IHNwbGl0QXJlYUNvbG9yc0FycltpZHggJSBzcGxpdEFyZWFDb2xvcnNBcnIubGVuZ3RoXVxuICAgICAgICB9LCBhcmVhU3R5bGUpLFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICB9LCB0aGlzKTtcbiAgICB6clV0aWwuZWFjaChzcGxpdExpbmVzLCBmdW5jdGlvbiAoc3BsaXRMaW5lcywgaWR4KSB7XG4gICAgICB0aGlzLmdyb3VwLmFkZChncmFwaGljLm1lcmdlUGF0aChzcGxpdExpbmVzLCB7XG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICBzdHJva2U6IHNwbGl0TGluZUNvbG9yc0FycltpZHggJSBzcGxpdExpbmVDb2xvcnNBcnIubGVuZ3RoXVxuICAgICAgICB9LCBsaW5lU3R5bGUpLFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgUmFkYXJWaWV3LnR5cGUgPSAncmFkYXInO1xuICByZXR1cm4gUmFkYXJWaWV3O1xufShDb21wb25lbnRWaWV3KTtcbmV4cG9ydCBkZWZhdWx0IFJhZGFyVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBSYWRhck1vZGVsIGZyb20gJy4uLy4uL2Nvb3JkL3JhZGFyL1JhZGFyTW9kZWwuanMnO1xuaW1wb3J0IFJhZGFyVmlldyBmcm9tICcuL1JhZGFyVmlldy5qcyc7XG5pbXBvcnQgUmFkYXIgZnJvbSAnLi4vLi4vY29vcmQvcmFkYXIvUmFkYXIuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvb3JkaW5hdGVTeXN0ZW0oJ3JhZGFyJywgUmFkYXIpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChSYWRhck1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhSYWRhclZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJWaXN1YWwoe1xuICAgIHNlcmllc1R5cGU6ICdyYWRhcicsXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAvLyBpdGVtVmlzdWFsIHN5bWJvbCBpcyBmb3Igc2VsZWN0ZWQgZGF0YVxuICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgZGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwgJ2xlZ2VuZEljb24nLCAncm91bmRSZWN0Jyk7XG4gICAgICB9KTtcbiAgICAgIC8vIHZpc3VhbCBpcyBmb3IgdW5zZWxlY3RlZCBkYXRhXG4gICAgICBkYXRhLnNldFZpc3VhbCgnbGVnZW5kSWNvbicsICdyb3VuZFJlY3QnKTtcbiAgICB9XG4gIH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18909\n")},22158:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/checkMarkerInSeries.js\nvar checkMarkerInSeries = __webpack_require__(72581);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/MarkerModel.js\nvar MarkerModel = __webpack_require__(82802);\n;// ./node_modules/echarts/lib/component/marker/MarkPointModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar MarkPointModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(MarkPointModel, _super);\n  function MarkPointModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = MarkPointModel.type;\n    return _this;\n  }\n  MarkPointModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {\n    return new MarkPointModel(markerOpt, masterMarkerModel, ecModel);\n  };\n  MarkPointModel.type = 'markPoint';\n  MarkPointModel.defaultOption = {\n    // zlevel: 0,\n    z: 5,\n    symbol: 'pin',\n    symbolSize: 50,\n    // symbolRotate: 0,\n    // symbolOffset: [0, 0]\n    tooltip: {\n      trigger: 'item'\n    },\n    label: {\n      show: true,\n      position: 'inside'\n    },\n    itemStyle: {\n      borderWidth: 2\n    },\n    emphasis: {\n      label: {\n        show: true\n      }\n    }\n  };\n  return MarkPointModel;\n}(MarkerModel/* default */.A);\n/* harmony default export */ const marker_MarkPointModel = (MarkPointModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/SymbolDraw.js\nvar SymbolDraw = __webpack_require__(18386);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/SeriesData.js\nvar SeriesData = __webpack_require__(6006);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/markerHelper.js\nvar markerHelper = __webpack_require__(71171);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/MarkerView.js\nvar MarkerView = __webpack_require__(1854);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/helper.js\nvar helper = __webpack_require__(37395);\n;// ./node_modules/echarts/lib/component/marker/MarkPointView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\nfunction updateMarkerLayout(mpData, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  mpData.each(function (idx) {\n    var itemModel = mpData.getItemModel(idx);\n    var point;\n    var xPx = number/* parsePercent */.lo(itemModel.get('x'), api.getWidth());\n    var yPx = number/* parsePercent */.lo(itemModel.get('y'), api.getHeight());\n    if (!isNaN(xPx) && !isNaN(yPx)) {\n      point = [xPx, yPx];\n    }\n    // Chart like bar may have there own marker positioning logic\n    else if (seriesModel.getMarkerPosition) {\n      // Use the getMarkerPosition\n      point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));\n    } else if (coordSys) {\n      var x = mpData.get(coordSys.dimensions[0], idx);\n      var y = mpData.get(coordSys.dimensions[1], idx);\n      point = coordSys.dataToPoint([x, y]);\n    }\n    // Use x, y if has any\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n    mpData.setItemLayout(idx, point);\n  });\n}\nvar MarkPointView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(MarkPointView, _super);\n  function MarkPointView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = MarkPointView.type;\n    return _this;\n  }\n  MarkPointView.prototype.updateTransform = function (markPointModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var mpModel = MarkerModel/* default */.A.getMarkerModelFromSeries(seriesModel, 'markPoint');\n      if (mpModel) {\n        updateMarkerLayout(mpModel.getData(), seriesModel, api);\n        this.markerGroupMap.get(seriesModel.id).updateLayout();\n      }\n    }, this);\n  };\n  MarkPointView.prototype.renderSeries = function (seriesModel, mpModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var symbolDrawMap = this.markerGroupMap;\n    var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw/* default */.A());\n    var mpData = createData(coordSys, seriesModel, mpModel);\n    // FIXME\n    mpModel.setData(mpData);\n    updateMarkerLayout(mpModel.getData(), seriesModel, api);\n    mpData.each(function (idx) {\n      var itemModel = mpData.getItemModel(idx);\n      var symbol = itemModel.getShallow('symbol');\n      var symbolSize = itemModel.getShallow('symbolSize');\n      var symbolRotate = itemModel.getShallow('symbolRotate');\n      var symbolOffset = itemModel.getShallow('symbolOffset');\n      var symbolKeepAspect = itemModel.getShallow('symbolKeepAspect');\n      // TODO: refactor needed: single data item should not support callback function\n      if ((0,util.isFunction)(symbol) || (0,util.isFunction)(symbolSize) || (0,util.isFunction)(symbolRotate) || (0,util.isFunction)(symbolOffset)) {\n        var rawIdx = mpModel.getRawValue(idx);\n        var dataParams = mpModel.getDataParams(idx);\n        if ((0,util.isFunction)(symbol)) {\n          symbol = symbol(rawIdx, dataParams);\n        }\n        if ((0,util.isFunction)(symbolSize)) {\n          // FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？\n          symbolSize = symbolSize(rawIdx, dataParams);\n        }\n        if ((0,util.isFunction)(symbolRotate)) {\n          symbolRotate = symbolRotate(rawIdx, dataParams);\n        }\n        if ((0,util.isFunction)(symbolOffset)) {\n          symbolOffset = symbolOffset(rawIdx, dataParams);\n        }\n      }\n      var style = itemModel.getModel('itemStyle').getItemStyle();\n      var color = (0,helper/* getVisualFromData */.rI)(seriesData, 'color');\n      if (!style.fill) {\n        style.fill = color;\n      }\n      mpData.setItemVisual(idx, {\n        symbol: symbol,\n        symbolSize: symbolSize,\n        symbolRotate: symbolRotate,\n        symbolOffset: symbolOffset,\n        symbolKeepAspect: symbolKeepAspect,\n        style: style\n      });\n    });\n    // TODO Text are wrong\n    symbolDraw.updateData(mpData);\n    this.group.add(symbolDraw.group);\n    // Set host model for tooltip\n    // FIXME\n    mpData.eachItemGraphicEl(function (el) {\n      el.traverse(function (child) {\n        (0,innerStore/* getECData */.z)(child).dataModel = mpModel;\n      });\n    });\n    this.markKeep(symbolDraw);\n    symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');\n  };\n  MarkPointView.type = 'markPoint';\n  return MarkPointView;\n}(MarkerView/* default */.A);\nfunction createData(coordSys, seriesModel, mpModel) {\n  var coordDimsInfos;\n  if (coordSys) {\n    coordDimsInfos = (0,util.map)(coordSys && coordSys.dimensions, function (coordDim) {\n      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};\n      // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n      return (0,util.extend)((0,util.extend)({}, info), {\n        name: coordDim,\n        // DON'T use ordinalMeta to parse and collect ordinal.\n        ordinalMeta: null\n      });\n    });\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n  }\n  var mpData = new SeriesData/* default */.A(coordDimsInfos, mpModel);\n  var dataOpt = (0,util.map)(mpModel.get('data'), (0,util.curry)(markerHelper/* dataTransform */.xx, seriesModel));\n  if (coordSys) {\n    dataOpt = (0,util.filter)(dataOpt, (0,util.curry)(markerHelper/* dataFilter */.Lq, coordSys));\n  }\n  var dimValueGetter = markerHelper/* createMarkerDimValueGetter */.fY(!!coordSys, coordDimsInfos);\n  mpData.initData(dataOpt, null, dimValueGetter);\n  return mpData;\n}\n/* harmony default export */ const marker_MarkPointView = (MarkPointView);\n;// ./node_modules/echarts/lib/component/marker/installMarkPoint.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\n\n\nfunction install(registers) {\n  registers.registerComponentModel(marker_MarkPointModel);\n  registers.registerComponentView(marker_MarkPointView);\n  registers.registerPreprocessor(function (opt) {\n    if ((0,checkMarkerInSeries/* default */.A)(opt.series, 'markPoint')) {\n      // Make sure markPoint component is enabled\n      opt.markPoint = opt.markPoint || {};\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIxNTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtQb2ludE1vZGVsLmpzP2I4ZDMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50Vmlldy5qcz80Njc5Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL2luc3RhbGxNYXJrUG9pbnQuanM/NmViNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IE1hcmtlck1vZGVsIGZyb20gJy4vTWFya2VyTW9kZWwuanMnO1xudmFyIE1hcmtQb2ludE1vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKE1hcmtQb2ludE1vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBNYXJrUG9pbnRNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gTWFya1BvaW50TW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgTWFya1BvaW50TW9kZWwucHJvdG90eXBlLmNyZWF0ZU1hcmtlck1vZGVsRnJvbVNlcmllcyA9IGZ1bmN0aW9uIChtYXJrZXJPcHQsIG1hc3Rlck1hcmtlck1vZGVsLCBlY01vZGVsKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrUG9pbnRNb2RlbChtYXJrZXJPcHQsIG1hc3Rlck1hcmtlck1vZGVsLCBlY01vZGVsKTtcbiAgfTtcbiAgTWFya1BvaW50TW9kZWwudHlwZSA9ICdtYXJrUG9pbnQnO1xuICBNYXJrUG9pbnRNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIC8vIHpsZXZlbDogMCxcbiAgICB6OiA1LFxuICAgIHN5bWJvbDogJ3BpbicsXG4gICAgc3ltYm9sU2l6ZTogNTAsXG4gICAgLy8gc3ltYm9sUm90YXRlOiAwLFxuICAgIC8vIHN5bWJvbE9mZnNldDogWzAsIDBdXG4gICAgdG9vbHRpcDoge1xuICAgICAgdHJpZ2dlcjogJ2l0ZW0nXG4gICAgfSxcbiAgICBsYWJlbDoge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIHBvc2l0aW9uOiAnaW5zaWRlJ1xuICAgIH0sXG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICBib3JkZXJXaWR0aDogMlxuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIHNob3c6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBNYXJrUG9pbnRNb2RlbDtcbn0oTWFya2VyTW9kZWwpO1xuZXhwb3J0IGRlZmF1bHQgTWFya1BvaW50TW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBTeW1ib2xEcmF3IGZyb20gJy4uLy4uL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3LmpzJztcbmltcG9ydCAqIGFzIG51bWJlclV0aWwgZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IFNlcmllc0RhdGEgZnJvbSAnLi4vLi4vZGF0YS9TZXJpZXNEYXRhLmpzJztcbmltcG9ydCAqIGFzIG1hcmtlckhlbHBlciBmcm9tICcuL21hcmtlckhlbHBlci5qcyc7XG5pbXBvcnQgTWFya2VyVmlldyBmcm9tICcuL01hcmtlclZpZXcuanMnO1xuaW1wb3J0IE1hcmtlck1vZGVsIGZyb20gJy4vTWFya2VyTW9kZWwuanMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiwgbWFwLCBmaWx0ZXIsIGN1cnJ5LCBleHRlbmQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlLmpzJztcbmltcG9ydCB7IGdldFZpc3VhbEZyb21EYXRhIH0gZnJvbSAnLi4vLi4vdmlzdWFsL2hlbHBlci5qcyc7XG5mdW5jdGlvbiB1cGRhdGVNYXJrZXJMYXlvdXQobXBEYXRhLCBzZXJpZXNNb2RlbCwgYXBpKSB7XG4gIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gIG1wRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICB2YXIgaXRlbU1vZGVsID0gbXBEYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgIHZhciBwb2ludDtcbiAgICB2YXIgeFB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgneCcpLCBhcGkuZ2V0V2lkdGgoKSk7XG4gICAgdmFyIHlQeCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGl0ZW1Nb2RlbC5nZXQoJ3knKSwgYXBpLmdldEhlaWdodCgpKTtcbiAgICBpZiAoIWlzTmFOKHhQeCkgJiYgIWlzTmFOKHlQeCkpIHtcbiAgICAgIHBvaW50ID0gW3hQeCwgeVB4XTtcbiAgICB9XG4gICAgLy8gQ2hhcnQgbGlrZSBiYXIgbWF5IGhhdmUgdGhlcmUgb3duIG1hcmtlciBwb3NpdGlvbmluZyBsb2dpY1xuICAgIGVsc2UgaWYgKHNlcmllc01vZGVsLmdldE1hcmtlclBvc2l0aW9uKSB7XG4gICAgICAvLyBVc2UgdGhlIGdldE1hcmtlclBvc2l0aW9uXG4gICAgICBwb2ludCA9IHNlcmllc01vZGVsLmdldE1hcmtlclBvc2l0aW9uKG1wRGF0YS5nZXRWYWx1ZXMobXBEYXRhLmRpbWVuc2lvbnMsIGlkeCkpO1xuICAgIH0gZWxzZSBpZiAoY29vcmRTeXMpIHtcbiAgICAgIHZhciB4ID0gbXBEYXRhLmdldChjb29yZFN5cy5kaW1lbnNpb25zWzBdLCBpZHgpO1xuICAgICAgdmFyIHkgPSBtcERhdGEuZ2V0KGNvb3JkU3lzLmRpbWVuc2lvbnNbMV0sIGlkeCk7XG4gICAgICBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KFt4LCB5XSk7XG4gICAgfVxuICAgIC8vIFVzZSB4LCB5IGlmIGhhcyBhbnlcbiAgICBpZiAoIWlzTmFOKHhQeCkpIHtcbiAgICAgIHBvaW50WzBdID0geFB4O1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKHlQeCkpIHtcbiAgICAgIHBvaW50WzFdID0geVB4O1xuICAgIH1cbiAgICBtcERhdGEuc2V0SXRlbUxheW91dChpZHgsIHBvaW50KTtcbiAgfSk7XG59XG52YXIgTWFya1BvaW50VmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNYXJrUG9pbnRWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBNYXJrUG9pbnRWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBNYXJrUG9pbnRWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIE1hcmtQb2ludFZpZXcucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtYXJrUG9pbnRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIG1wTW9kZWwgPSBNYXJrZXJNb2RlbC5nZXRNYXJrZXJNb2RlbEZyb21TZXJpZXMoc2VyaWVzTW9kZWwsICdtYXJrUG9pbnQnKTtcbiAgICAgIGlmIChtcE1vZGVsKSB7XG4gICAgICAgIHVwZGF0ZU1hcmtlckxheW91dChtcE1vZGVsLmdldERhdGEoKSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgICAgIHRoaXMubWFya2VyR3JvdXBNYXAuZ2V0KHNlcmllc01vZGVsLmlkKS51cGRhdGVMYXlvdXQoKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgTWFya1BvaW50Vmlldy5wcm90b3R5cGUucmVuZGVyU2VyaWVzID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBtcE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBzZXJpZXNJZCA9IHNlcmllc01vZGVsLmlkO1xuICAgIHZhciBzZXJpZXNEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBzeW1ib2xEcmF3TWFwID0gdGhpcy5tYXJrZXJHcm91cE1hcDtcbiAgICB2YXIgc3ltYm9sRHJhdyA9IHN5bWJvbERyYXdNYXAuZ2V0KHNlcmllc0lkKSB8fCBzeW1ib2xEcmF3TWFwLnNldChzZXJpZXNJZCwgbmV3IFN5bWJvbERyYXcoKSk7XG4gICAgdmFyIG1wRGF0YSA9IGNyZWF0ZURhdGEoY29vcmRTeXMsIHNlcmllc01vZGVsLCBtcE1vZGVsKTtcbiAgICAvLyBGSVhNRVxuICAgIG1wTW9kZWwuc2V0RGF0YShtcERhdGEpO1xuICAgIHVwZGF0ZU1hcmtlckxheW91dChtcE1vZGVsLmdldERhdGEoKSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgbXBEYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IG1wRGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgIHZhciBzeW1ib2wgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnc3ltYm9sJyk7XG4gICAgICB2YXIgc3ltYm9sU2l6ZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xTaXplJyk7XG4gICAgICB2YXIgc3ltYm9sUm90YXRlID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbFJvdGF0ZScpO1xuICAgICAgdmFyIHN5bWJvbE9mZnNldCA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xPZmZzZXQnKTtcbiAgICAgIHZhciBzeW1ib2xLZWVwQXNwZWN0ID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbEtlZXBBc3BlY3QnKTtcbiAgICAgIC8vIFRPRE86IHJlZmFjdG9yIG5lZWRlZDogc2luZ2xlIGRhdGEgaXRlbSBzaG91bGQgbm90IHN1cHBvcnQgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHN5bWJvbCkgfHwgaXNGdW5jdGlvbihzeW1ib2xTaXplKSB8fCBpc0Z1bmN0aW9uKHN5bWJvbFJvdGF0ZSkgfHwgaXNGdW5jdGlvbihzeW1ib2xPZmZzZXQpKSB7XG4gICAgICAgIHZhciByYXdJZHggPSBtcE1vZGVsLmdldFJhd1ZhbHVlKGlkeCk7XG4gICAgICAgIHZhciBkYXRhUGFyYW1zID0gbXBNb2RlbC5nZXREYXRhUGFyYW1zKGlkeCk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHN5bWJvbCkpIHtcbiAgICAgICAgICBzeW1ib2wgPSBzeW1ib2wocmF3SWR4LCBkYXRhUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihzeW1ib2xTaXplKSkge1xuICAgICAgICAgIC8vIEZJWE1FIOi/memHjOS4jeWFvOWuuSBFQ2hhcnRzIDIueO+8jDIueCDosozkvLzlj4LmlbDmmK/mlbTkuKrmlbDmja7vvJ9cbiAgICAgICAgICBzeW1ib2xTaXplID0gc3ltYm9sU2l6ZShyYXdJZHgsIGRhdGFQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHN5bWJvbFJvdGF0ZSkpIHtcbiAgICAgICAgICBzeW1ib2xSb3RhdGUgPSBzeW1ib2xSb3RhdGUocmF3SWR4LCBkYXRhUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihzeW1ib2xPZmZzZXQpKSB7XG4gICAgICAgICAgc3ltYm9sT2Zmc2V0ID0gc3ltYm9sT2Zmc2V0KHJhd0lkeCwgZGF0YVBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJykuZ2V0SXRlbVN0eWxlKCk7XG4gICAgICB2YXIgY29sb3IgPSBnZXRWaXN1YWxGcm9tRGF0YShzZXJpZXNEYXRhLCAnY29sb3InKTtcbiAgICAgIGlmICghc3R5bGUuZmlsbCkge1xuICAgICAgICBzdHlsZS5maWxsID0gY29sb3I7XG4gICAgICB9XG4gICAgICBtcERhdGEuc2V0SXRlbVZpc3VhbChpZHgsIHtcbiAgICAgICAgc3ltYm9sOiBzeW1ib2wsXG4gICAgICAgIHN5bWJvbFNpemU6IHN5bWJvbFNpemUsXG4gICAgICAgIHN5bWJvbFJvdGF0ZTogc3ltYm9sUm90YXRlLFxuICAgICAgICBzeW1ib2xPZmZzZXQ6IHN5bWJvbE9mZnNldCxcbiAgICAgICAgc3ltYm9sS2VlcEFzcGVjdDogc3ltYm9sS2VlcEFzcGVjdCxcbiAgICAgICAgc3R5bGU6IHN0eWxlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBUT0RPIFRleHQgYXJlIHdyb25nXG4gICAgc3ltYm9sRHJhdy51cGRhdGVEYXRhKG1wRGF0YSk7XG4gICAgdGhpcy5ncm91cC5hZGQoc3ltYm9sRHJhdy5ncm91cCk7XG4gICAgLy8gU2V0IGhvc3QgbW9kZWwgZm9yIHRvb2x0aXBcbiAgICAvLyBGSVhNRVxuICAgIG1wRGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBnZXRFQ0RhdGEoY2hpbGQpLmRhdGFNb2RlbCA9IG1wTW9kZWw7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLm1hcmtLZWVwKHN5bWJvbERyYXcpO1xuICAgIHN5bWJvbERyYXcuZ3JvdXAuc2lsZW50ID0gbXBNb2RlbC5nZXQoJ3NpbGVudCcpIHx8IHNlcmllc01vZGVsLmdldCgnc2lsZW50Jyk7XG4gIH07XG4gIE1hcmtQb2ludFZpZXcudHlwZSA9ICdtYXJrUG9pbnQnO1xuICByZXR1cm4gTWFya1BvaW50Vmlldztcbn0oTWFya2VyVmlldyk7XG5mdW5jdGlvbiBjcmVhdGVEYXRhKGNvb3JkU3lzLCBzZXJpZXNNb2RlbCwgbXBNb2RlbCkge1xuICB2YXIgY29vcmREaW1zSW5mb3M7XG4gIGlmIChjb29yZFN5cykge1xuICAgIGNvb3JkRGltc0luZm9zID0gbWFwKGNvb3JkU3lzICYmIGNvb3JkU3lzLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChjb29yZERpbSkge1xuICAgICAgdmFyIGluZm8gPSBzZXJpZXNNb2RlbC5nZXREYXRhKCkuZ2V0RGltZW5zaW9uSW5mbyhzZXJpZXNNb2RlbC5nZXREYXRhKCkubWFwRGltZW5zaW9uKGNvb3JkRGltKSkgfHwge307XG4gICAgICAvLyBJbiBtYXAgc2VyaWVzIGRhdGEgZG9uJ3QgaGF2ZSBsbmcgYW5kIGxhdCBkaW1lbnNpb24uIEZhbGxiYWNrIHRvIHNhbWUgd2l0aCBjb29yZFN5c1xuICAgICAgcmV0dXJuIGV4dGVuZChleHRlbmQoe30sIGluZm8pLCB7XG4gICAgICAgIG5hbWU6IGNvb3JkRGltLFxuICAgICAgICAvLyBET04nVCB1c2Ugb3JkaW5hbE1ldGEgdG8gcGFyc2UgYW5kIGNvbGxlY3Qgb3JkaW5hbC5cbiAgICAgICAgb3JkaW5hbE1ldGE6IG51bGxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvb3JkRGltc0luZm9zID0gW3tcbiAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICB0eXBlOiAnZmxvYXQnXG4gICAgfV07XG4gIH1cbiAgdmFyIG1wRGF0YSA9IG5ldyBTZXJpZXNEYXRhKGNvb3JkRGltc0luZm9zLCBtcE1vZGVsKTtcbiAgdmFyIGRhdGFPcHQgPSBtYXAobXBNb2RlbC5nZXQoJ2RhdGEnKSwgY3VycnkobWFya2VySGVscGVyLmRhdGFUcmFuc2Zvcm0sIHNlcmllc01vZGVsKSk7XG4gIGlmIChjb29yZFN5cykge1xuICAgIGRhdGFPcHQgPSBmaWx0ZXIoZGF0YU9wdCwgY3VycnkobWFya2VySGVscGVyLmRhdGFGaWx0ZXIsIGNvb3JkU3lzKSk7XG4gIH1cbiAgdmFyIGRpbVZhbHVlR2V0dGVyID0gbWFya2VySGVscGVyLmNyZWF0ZU1hcmtlckRpbVZhbHVlR2V0dGVyKCEhY29vcmRTeXMsIGNvb3JkRGltc0luZm9zKTtcbiAgbXBEYXRhLmluaXREYXRhKGRhdGFPcHQsIG51bGwsIGRpbVZhbHVlR2V0dGVyKTtcbiAgcmV0dXJuIG1wRGF0YTtcbn1cbmV4cG9ydCBkZWZhdWx0IE1hcmtQb2ludFZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbmltcG9ydCBjaGVja01hcmtlckluU2VyaWVzIGZyb20gJy4vY2hlY2tNYXJrZXJJblNlcmllcy5qcyc7XG5pbXBvcnQgTWFya1BvaW50TW9kZWwgZnJvbSAnLi9NYXJrUG9pbnRNb2RlbC5qcyc7XG5pbXBvcnQgTWFya1BvaW50VmlldyBmcm9tICcuL01hcmtQb2ludFZpZXcuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKE1hcmtQb2ludE1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhNYXJrUG9pbnRWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHQpIHtcbiAgICBpZiAoY2hlY2tNYXJrZXJJblNlcmllcyhvcHQuc2VyaWVzLCAnbWFya1BvaW50JykpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSBtYXJrUG9pbnQgY29tcG9uZW50IGlzIGVuYWJsZWRcbiAgICAgIG9wdC5tYXJrUG9pbnQgPSBvcHQubWFya1BvaW50IHx8IHt9O1xuICAgIH1cbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22158\n")},23868:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ck: () => (/* binding */ isTaken),\n/* harmony export */   _r: () => (/* binding */ release),\n/* harmony export */   s: () => (/* binding */ take)\n/* harmony export */ });\n/* harmony import */ var _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95383);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// @ts-nocheck\n\n\nvar ATTR = '\\0_ec_interaction_mutex';\nfunction take(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  store[resourceKey] = userKey;\n}\nfunction release(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  var uKey = store[resourceKey];\n  if (uKey === userKey) {\n    store[resourceKey] = null;\n  }\n}\nfunction isTaken(zr, resourceKey) {\n  return !!getStore(zr)[resourceKey];\n}\nfunction getStore(zr) {\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n/**\r\n * payload: {\r\n *     type: 'takeGlobalCursor',\r\n *     key: 'dataZoomSelect', or 'brush', or ...,\r\n *         If no userKey, release global cursor.\r\n * }\r\n */\n// TODO: SELF REGISTERED.\n_core_echarts_js__WEBPACK_IMPORTED_MODULE_0__/* .registerAction */ .OH({\n  type: 'takeGlobalCursor',\n  event: 'globalCursorTaken',\n  update: 'update'\n}, zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.noop);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM4NjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9pbnRlcmFjdGlvbk11dGV4LmpzPzhiMWYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG4vLyBAdHMtbm9jaGVja1xuaW1wb3J0ICogYXMgZWNoYXJ0cyBmcm9tICcuLi8uLi9jb3JlL2VjaGFydHMuanMnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG52YXIgQVRUUiA9ICdcXDBfZWNfaW50ZXJhY3Rpb25fbXV0ZXgnO1xuZXhwb3J0IGZ1bmN0aW9uIHRha2UoenIsIHJlc291cmNlS2V5LCB1c2VyS2V5KSB7XG4gIHZhciBzdG9yZSA9IGdldFN0b3JlKHpyKTtcbiAgc3RvcmVbcmVzb3VyY2VLZXldID0gdXNlcktleTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWxlYXNlKHpyLCByZXNvdXJjZUtleSwgdXNlcktleSkge1xuICB2YXIgc3RvcmUgPSBnZXRTdG9yZSh6cik7XG4gIHZhciB1S2V5ID0gc3RvcmVbcmVzb3VyY2VLZXldO1xuICBpZiAodUtleSA9PT0gdXNlcktleSkge1xuICAgIHN0b3JlW3Jlc291cmNlS2V5XSA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1Rha2VuKHpyLCByZXNvdXJjZUtleSkge1xuICByZXR1cm4gISFnZXRTdG9yZSh6cilbcmVzb3VyY2VLZXldO1xufVxuZnVuY3Rpb24gZ2V0U3RvcmUoenIpIHtcbiAgcmV0dXJuIHpyW0FUVFJdIHx8ICh6cltBVFRSXSA9IHt9KTtcbn1cbi8qKlxyXG4gKiBwYXlsb2FkOiB7XHJcbiAqICAgICB0eXBlOiAndGFrZUdsb2JhbEN1cnNvcicsXHJcbiAqICAgICBrZXk6ICdkYXRhWm9vbVNlbGVjdCcsIG9yICdicnVzaCcsIG9yIC4uLixcclxuICogICAgICAgICBJZiBubyB1c2VyS2V5LCByZWxlYXNlIGdsb2JhbCBjdXJzb3IuXHJcbiAqIH1cclxuICovXG4vLyBUT0RPOiBTRUxGIFJFR0lTVEVSRUQuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ3Rha2VHbG9iYWxDdXJzb3InLFxuICBldmVudDogJ2dsb2JhbEN1cnNvclRha2VuJyxcbiAgdXBkYXRlOiAndXBkYXRlJ1xufSwgbm9vcCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23868\n")},25451:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wd: () => (/* binding */ makeRectPanelClipPath),\n/* harmony export */   wx: () => (/* binding */ makeLinearBrushOtherExtent),\n/* harmony export */   x$: () => (/* binding */ makeRectIsTargetByCursor)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29308);\n/* harmony import */ var _cursorHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72589);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43199);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction makeRectPanelClipPath(rect) {\n  rect = normalizeRect(rect);\n  return function (localPoints) {\n    return _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__.clipPointsByRect(localPoints, rect);\n  };\n}\nfunction makeLinearBrushOtherExtent(rect, specifiedXYIndex) {\n  rect = normalizeRect(rect);\n  return function (xyIndex) {\n    var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;\n    var brushWidth = idx ? rect.width : rect.height;\n    var base = idx ? rect.x : rect.y;\n    return [base, base + (brushWidth || 0)];\n  };\n}\nfunction makeRectIsTargetByCursor(rect, api, targetModel) {\n  var boundingRect = normalizeRect(rect);\n  return function (e, localCursorPoint) {\n    return boundingRect.contain(localCursorPoint[0], localCursorPoint[1]) && !(0,_cursorHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .onIrrelevantElement */ .I)(e, api, targetModel);\n  };\n}\n// Consider width/height is negative.\nfunction normalizeRect(rect) {\n  return zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.create(rect);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU0NTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvYnJ1c2hIZWxwZXIuanM/M2M4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBCb3VuZGluZ1JlY3QgZnJvbSAnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMnO1xuaW1wb3J0IHsgb25JcnJlbGV2YW50RWxlbWVudCB9IGZyb20gJy4vY3Vyc29ySGVscGVyLmpzJztcbmltcG9ydCAqIGFzIGdyYXBoaWNVdGlsIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlY3RQYW5lbENsaXBQYXRoKHJlY3QpIHtcbiAgcmVjdCA9IG5vcm1hbGl6ZVJlY3QocmVjdCk7XG4gIHJldHVybiBmdW5jdGlvbiAobG9jYWxQb2ludHMpIHtcbiAgICByZXR1cm4gZ3JhcGhpY1V0aWwuY2xpcFBvaW50c0J5UmVjdChsb2NhbFBvaW50cywgcmVjdCk7XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZUxpbmVhckJydXNoT3RoZXJFeHRlbnQocmVjdCwgc3BlY2lmaWVkWFlJbmRleCkge1xuICByZWN0ID0gbm9ybWFsaXplUmVjdChyZWN0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4eUluZGV4KSB7XG4gICAgdmFyIGlkeCA9IHNwZWNpZmllZFhZSW5kZXggIT0gbnVsbCA/IHNwZWNpZmllZFhZSW5kZXggOiB4eUluZGV4O1xuICAgIHZhciBicnVzaFdpZHRoID0gaWR4ID8gcmVjdC53aWR0aCA6IHJlY3QuaGVpZ2h0O1xuICAgIHZhciBiYXNlID0gaWR4ID8gcmVjdC54IDogcmVjdC55O1xuICAgIHJldHVybiBbYmFzZSwgYmFzZSArIChicnVzaFdpZHRoIHx8IDApXTtcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUmVjdElzVGFyZ2V0QnlDdXJzb3IocmVjdCwgYXBpLCB0YXJnZXRNb2RlbCkge1xuICB2YXIgYm91bmRpbmdSZWN0ID0gbm9ybWFsaXplUmVjdChyZWN0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlLCBsb2NhbEN1cnNvclBvaW50KSB7XG4gICAgcmV0dXJuIGJvdW5kaW5nUmVjdC5jb250YWluKGxvY2FsQ3Vyc29yUG9pbnRbMF0sIGxvY2FsQ3Vyc29yUG9pbnRbMV0pICYmICFvbklycmVsZXZhbnRFbGVtZW50KGUsIGFwaSwgdGFyZ2V0TW9kZWwpO1xuICB9O1xufVxuLy8gQ29uc2lkZXIgd2lkdGgvaGVpZ2h0IGlzIG5lZ2F0aXZlLlxuZnVuY3Rpb24gbm9ybWFsaXplUmVjdChyZWN0KSB7XG4gIHJldHVybiBCb3VuZGluZ1JlY3QuY3JlYXRlKHJlY3QpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25451\n')},39838:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/checkMarkerInSeries.js\nvar checkMarkerInSeries = __webpack_require__(72581);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/MarkerModel.js\nvar MarkerModel = __webpack_require__(82802);\n;// ./node_modules/echarts/lib/component/marker/MarkAreaModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar MarkAreaModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(MarkAreaModel, _super);\n  function MarkAreaModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = MarkAreaModel.type;\n    return _this;\n  }\n  MarkAreaModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {\n    return new MarkAreaModel(markerOpt, masterMarkerModel, ecModel);\n  };\n  MarkAreaModel.type = 'markArea';\n  MarkAreaModel.defaultOption = {\n    // zlevel: 0,\n    // PENDING\n    z: 1,\n    tooltip: {\n      trigger: 'item'\n    },\n    // markArea should fixed on the coordinate system\n    animation: false,\n    label: {\n      show: true,\n      position: 'top'\n    },\n    itemStyle: {\n      // color and borderColor default to use color from series\n      // color: 'auto'\n      // borderColor: 'auto'\n      borderWidth: 0\n    },\n    emphasis: {\n      label: {\n        show: true,\n        position: 'top'\n      }\n    }\n  };\n  return MarkAreaModel;\n}(MarkerModel/* default */.A);\n/* harmony default export */ const marker_MarkAreaModel = (MarkAreaModel);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/tool/color.js\nvar tool_color = __webpack_require__(47698);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/SeriesData.js\nvar SeriesData = __webpack_require__(6006);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polygon.js\nvar Polygon = __webpack_require__(52505);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/markerHelper.js\nvar markerHelper = __webpack_require__(71171);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/MarkerView.js\nvar MarkerView = __webpack_require__(1854);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/CoordinateSystem.js\nvar CoordinateSystem = __webpack_require__(41849);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/helper.js\nvar helper = __webpack_require__(37395);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/dataValueHelper.js\nvar dataValueHelper = __webpack_require__(31825);\n;// ./node_modules/echarts/lib/component/marker/MarkAreaView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n// TODO Optimize on polar\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar inner = (0,model/* makeInner */.$r)();\nvar markAreaTransform = function (seriesModel, coordSys, maModel, item) {\n  // item may be null\n  var item0 = item[0];\n  var item1 = item[1];\n  if (!item0 || !item1) {\n    return;\n  }\n  var lt = markerHelper/* dataTransform */.xx(seriesModel, item0);\n  var rb = markerHelper/* dataTransform */.xx(seriesModel, item1);\n  // FIXME make sure lt is less than rb\n  var ltCoord = lt.coord;\n  var rbCoord = rb.coord;\n  ltCoord[0] = (0,util.retrieve)(ltCoord[0], -Infinity);\n  ltCoord[1] = (0,util.retrieve)(ltCoord[1], -Infinity);\n  rbCoord[0] = (0,util.retrieve)(rbCoord[0], Infinity);\n  rbCoord[1] = (0,util.retrieve)(rbCoord[1], Infinity);\n  // Merge option into one\n  var result = (0,util.mergeAll)([{}, lt, rb]);\n  result.coord = [lt.coord, rb.coord];\n  result.x0 = lt.x;\n  result.y0 = lt.y;\n  result.x1 = rb.x;\n  result.y1 = rb.y;\n  return result;\n};\nfunction isInfinity(val) {\n  return !isNaN(val) && !isFinite(val);\n}\n// If a markArea has one dim\nfunction ifMarkAreaHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n  var otherDimIndex = 1 - dimIndex;\n  return isInfinity(fromCoord[otherDimIndex]) && isInfinity(toCoord[otherDimIndex]);\n}\nfunction markAreaFilter(coordSys, item) {\n  var fromCoord = item.coord[0];\n  var toCoord = item.coord[1];\n  var item0 = {\n    coord: fromCoord,\n    x: item.x0,\n    y: item.y0\n  };\n  var item1 = {\n    coord: toCoord,\n    x: item.x1,\n    y: item.y1\n  };\n  if ((0,CoordinateSystem/* isCoordinateSystemType */.g)(coordSys, 'cartesian2d')) {\n    // In case\n    // {\n    //  markArea: {\n    //    data: [{ yAxis: 2 }]\n    //  }\n    // }\n    if (fromCoord && toCoord && (ifMarkAreaHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkAreaHasOnlyDim(0, fromCoord, toCoord, coordSys))) {\n      return true;\n    }\n    // Directly returning true may also do the work,\n    // because markArea will not be shown automatically\n    // when it's not included in coordinate system.\n    // But filtering ahead can avoid keeping rendering markArea\n    // when there are too many of them.\n    return markerHelper/* zoneFilter */.PN(coordSys, item0, item1);\n  }\n  return markerHelper/* dataFilter */.Lq(coordSys, item0) || markerHelper/* dataFilter */.Lq(coordSys, item1);\n}\n// dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']\nfunction getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  var itemModel = data.getItemModel(idx);\n  var point;\n  var xPx = number/* parsePercent */.lo(itemModel.get(dims[0]), api.getWidth());\n  var yPx = number/* parsePercent */.lo(itemModel.get(dims[1]), api.getHeight());\n  if (!isNaN(xPx) && !isNaN(yPx)) {\n    point = [xPx, yPx];\n  } else {\n    // Chart like bar may have there own marker positioning logic\n    if (seriesModel.getMarkerPosition) {\n      // Consider the case that user input the right-bottom point first\n      // Pick the larger x and y as 'x1' and 'y1'\n      var pointValue0 = data.getValues(['x0', 'y0'], idx);\n      var pointValue1 = data.getValues(['x1', 'y1'], idx);\n      var clampPointValue0 = coordSys.clampData(pointValue0);\n      var clampPointValue1 = coordSys.clampData(pointValue1);\n      var pointValue = [];\n      if (dims[0] === 'x0') {\n        pointValue[0] = clampPointValue0[0] > clampPointValue1[0] ? pointValue1[0] : pointValue0[0];\n      } else {\n        pointValue[0] = clampPointValue0[0] > clampPointValue1[0] ? pointValue0[0] : pointValue1[0];\n      }\n      if (dims[1] === 'y0') {\n        pointValue[1] = clampPointValue0[1] > clampPointValue1[1] ? pointValue1[1] : pointValue0[1];\n      } else {\n        pointValue[1] = clampPointValue0[1] > clampPointValue1[1] ? pointValue0[1] : pointValue1[1];\n      }\n      // Use the getMarkerPosition\n      point = seriesModel.getMarkerPosition(pointValue, dims, true);\n    } else {\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n      var pt = [x, y];\n      coordSys.clampData && coordSys.clampData(pt, pt);\n      point = coordSys.dataToPoint(pt, true);\n    }\n    if ((0,CoordinateSystem/* isCoordinateSystemType */.g)(coordSys, 'cartesian2d')) {\n      // TODO: TYPE ts@4.1 may still infer it as Axis instead of Axis2D. Not sure if it's a bug\n      var xAxis = coordSys.getAxis('x');\n      var yAxis = coordSys.getAxis('y');\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n      if (isInfinity(x)) {\n        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);\n      } else if (isInfinity(y)) {\n        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);\n      }\n    }\n    // Use x, y if has any\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n  }\n  return point;\n}\nvar dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];\nvar MarkAreaView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(MarkAreaView, _super);\n  function MarkAreaView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = MarkAreaView.type;\n    return _this;\n  }\n  MarkAreaView.prototype.updateTransform = function (markAreaModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var maModel = MarkerModel/* default */.A.getMarkerModelFromSeries(seriesModel, 'markArea');\n      if (maModel) {\n        var areaData_1 = maModel.getData();\n        areaData_1.each(function (idx) {\n          var points = (0,util.map)(dimPermutations, function (dim) {\n            return getSingleMarkerEndPoint(areaData_1, idx, dim, seriesModel, api);\n          });\n          // Layout\n          areaData_1.setItemLayout(idx, points);\n          var el = areaData_1.getItemGraphicEl(idx);\n          el.setShape('points', points);\n        });\n      }\n    }, this);\n  };\n  MarkAreaView.prototype.renderSeries = function (seriesModel, maModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var areaGroupMap = this.markerGroupMap;\n    var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {\n      group: new Group/* default */.A()\n    });\n    this.group.add(polygonGroup.group);\n    this.markKeep(polygonGroup);\n    var areaData = createList(coordSys, seriesModel, maModel);\n    // Line data for tooltip and formatter\n    maModel.setData(areaData);\n    // Update visual and layout of line\n    areaData.each(function (idx) {\n      // Layout\n      var points = (0,util.map)(dimPermutations, function (dim) {\n        return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n      });\n      var xAxisScale = coordSys.getAxis('x').scale;\n      var yAxisScale = coordSys.getAxis('y').scale;\n      var xAxisExtent = xAxisScale.getExtent();\n      var yAxisExtent = yAxisScale.getExtent();\n      var xPointExtent = [xAxisScale.parse(areaData.get('x0', idx)), xAxisScale.parse(areaData.get('x1', idx))];\n      var yPointExtent = [yAxisScale.parse(areaData.get('y0', idx)), yAxisScale.parse(areaData.get('y1', idx))];\n      number/* asc */.Y6(xPointExtent);\n      number/* asc */.Y6(yPointExtent);\n      var overlapped = !(xAxisExtent[0] > xPointExtent[1] || xAxisExtent[1] < xPointExtent[0] || yAxisExtent[0] > yPointExtent[1] || yAxisExtent[1] < yPointExtent[0]);\n      // If none of the area is inside coordSys, allClipped is set to be true\n      // in layout so that label will not be displayed. See #12591\n      var allClipped = !overlapped;\n      areaData.setItemLayout(idx, {\n        points: points,\n        allClipped: allClipped\n      });\n      var style = areaData.getItemModel(idx).getModel('itemStyle').getItemStyle();\n      var color = (0,helper/* getVisualFromData */.rI)(seriesData, 'color');\n      if (!style.fill) {\n        style.fill = color;\n        if ((0,util.isString)(style.fill)) {\n          style.fill = tool_color.modifyAlpha(style.fill, 0.4);\n        }\n      }\n      if (!style.stroke) {\n        style.stroke = color;\n      }\n      // Visual\n      areaData.setItemVisual(idx, 'style', style);\n    });\n    areaData.diff(inner(polygonGroup).data).add(function (idx) {\n      var layout = areaData.getItemLayout(idx);\n      if (!layout.allClipped) {\n        var polygon = new Polygon/* default */.A({\n          shape: {\n            points: layout.points\n          }\n        });\n        areaData.setItemGraphicEl(idx, polygon);\n        polygonGroup.group.add(polygon);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var polygon = inner(polygonGroup).data.getItemGraphicEl(oldIdx);\n      var layout = areaData.getItemLayout(newIdx);\n      if (!layout.allClipped) {\n        if (polygon) {\n          basicTransition/* updateProps */.oi(polygon, {\n            shape: {\n              points: layout.points\n            }\n          }, maModel, newIdx);\n        } else {\n          polygon = new Polygon/* default */.A({\n            shape: {\n              points: layout.points\n            }\n          });\n        }\n        areaData.setItemGraphicEl(newIdx, polygon);\n        polygonGroup.group.add(polygon);\n      } else if (polygon) {\n        polygonGroup.group.remove(polygon);\n      }\n    }).remove(function (idx) {\n      var polygon = inner(polygonGroup).data.getItemGraphicEl(idx);\n      polygonGroup.group.remove(polygon);\n    }).execute();\n    areaData.eachItemGraphicEl(function (polygon, idx) {\n      var itemModel = areaData.getItemModel(idx);\n      var style = areaData.getItemVisual(idx, 'style');\n      polygon.useStyle(areaData.getItemVisual(idx, 'style'));\n      (0,labelStyle/* setLabelStyle */.qM)(polygon, (0,labelStyle/* getLabelStatesModels */.lx)(itemModel), {\n        labelFetcher: maModel,\n        labelDataIndex: idx,\n        defaultText: areaData.getName(idx) || '',\n        inheritColor: (0,util.isString)(style.fill) ? tool_color.modifyAlpha(style.fill, 1) : '#000'\n      });\n      (0,states/* setStatesStylesFromModel */.Mx)(polygon, itemModel);\n      (0,states/* toggleHoverEmphasis */.Lm)(polygon, null, null, itemModel.get(['emphasis', 'disabled']));\n      (0,innerStore/* getECData */.z)(polygon).dataModel = maModel;\n    });\n    inner(polygonGroup).data = areaData;\n    polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');\n  };\n  MarkAreaView.type = 'markArea';\n  return MarkAreaView;\n}(MarkerView/* default */.A);\nfunction createList(coordSys, seriesModel, maModel) {\n  var areaData;\n  var dataDims;\n  var dims = ['x0', 'y0', 'x1', 'y1'];\n  if (coordSys) {\n    var coordDimsInfos_1 = (0,util.map)(coordSys && coordSys.dimensions, function (coordDim) {\n      var data = seriesModel.getData();\n      var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {};\n      // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n      return (0,util.extend)((0,util.extend)({}, info), {\n        name: coordDim,\n        // DON'T use ordinalMeta to parse and collect ordinal.\n        ordinalMeta: null\n      });\n    });\n    dataDims = (0,util.map)(dims, function (dim, idx) {\n      return {\n        name: dim,\n        type: coordDimsInfos_1[idx % 2].type\n      };\n    });\n    areaData = new SeriesData/* default */.A(dataDims, maModel);\n  } else {\n    dataDims = [{\n      name: 'value',\n      type: 'float'\n    }];\n    areaData = new SeriesData/* default */.A(dataDims, maModel);\n  }\n  var optData = (0,util.map)(maModel.get('data'), (0,util.curry)(markAreaTransform, seriesModel, coordSys, maModel));\n  if (coordSys) {\n    optData = (0,util.filter)(optData, (0,util.curry)(markAreaFilter, coordSys));\n  }\n  var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {\n    // TODO should convert to ParsedValue?\n    var rawVal = item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];\n    return (0,dataValueHelper/* parseDataValue */.Pn)(rawVal, dataDims[dimIndex]);\n  } : function (item, dimName, dataIndex, dimIndex) {\n    return (0,dataValueHelper/* parseDataValue */.Pn)(item.value, dataDims[dimIndex]);\n  };\n  areaData.initData(optData, null, dimValueGetter);\n  areaData.hasItemOption = true;\n  return areaData;\n}\n/* harmony default export */ const marker_MarkAreaView = (MarkAreaView);\n;// ./node_modules/echarts/lib/component/marker/installMarkArea.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction install(registers) {\n  registers.registerComponentModel(marker_MarkAreaModel);\n  registers.registerComponentView(marker_MarkAreaView);\n  registers.registerPreprocessor(function (opt) {\n    if ((0,checkMarkerInSeries/* default */.A)(opt.series, 'markArea')) {\n      // Make sure markArea component is enabled\n      opt.markArea = opt.markArea || {};\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzk4MzguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrQXJlYU1vZGVsLmpzPzJmMGUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya0FyZWFWaWV3LmpzPzE5OWIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvaW5zdGFsbE1hcmtBcmVhLmpzPzZhYTQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBNYXJrZXJNb2RlbCBmcm9tICcuL01hcmtlck1vZGVsLmpzJztcbnZhciBNYXJrQXJlYU1vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKE1hcmtBcmVhTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIE1hcmtBcmVhTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IE1hcmtBcmVhTW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgTWFya0FyZWFNb2RlbC5wcm90b3R5cGUuY3JlYXRlTWFya2VyTW9kZWxGcm9tU2VyaWVzID0gZnVuY3Rpb24gKG1hcmtlck9wdCwgbWFzdGVyTWFya2VyTW9kZWwsIGVjTW9kZWwpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtBcmVhTW9kZWwobWFya2VyT3B0LCBtYXN0ZXJNYXJrZXJNb2RlbCwgZWNNb2RlbCk7XG4gIH07XG4gIE1hcmtBcmVhTW9kZWwudHlwZSA9ICdtYXJrQXJlYSc7XG4gIE1hcmtBcmVhTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAvLyB6bGV2ZWw6IDAsXG4gICAgLy8gUEVORElOR1xuICAgIHo6IDEsXG4gICAgdG9vbHRpcDoge1xuICAgICAgdHJpZ2dlcjogJ2l0ZW0nXG4gICAgfSxcbiAgICAvLyBtYXJrQXJlYSBzaG91bGQgZml4ZWQgb24gdGhlIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgYW5pbWF0aW9uOiBmYWxzZSxcbiAgICBsYWJlbDoge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIHBvc2l0aW9uOiAndG9wJ1xuICAgIH0sXG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICAvLyBjb2xvciBhbmQgYm9yZGVyQ29sb3IgZGVmYXVsdCB0byB1c2UgY29sb3IgZnJvbSBzZXJpZXNcbiAgICAgIC8vIGNvbG9yOiAnYXV0bydcbiAgICAgIC8vIGJvcmRlckNvbG9yOiAnYXV0bydcbiAgICAgIGJvcmRlcldpZHRoOiAwXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246ICd0b3AnXG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gTWFya0FyZWFNb2RlbDtcbn0oTWFya2VyTW9kZWwpO1xuZXhwb3J0IGRlZmF1bHQgTWFya0FyZWFNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuLy8gVE9ETyBPcHRpbWl6ZSBvbiBwb2xhclxuaW1wb3J0ICogYXMgY29sb3JVdGlsIGZyb20gJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3IuanMnO1xuaW1wb3J0IFNlcmllc0RhdGEgZnJvbSAnLi4vLi4vZGF0YS9TZXJpZXNEYXRhLmpzJztcbmltcG9ydCAqIGFzIG51bWJlclV0aWwgZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IHsgdG9nZ2xlSG92ZXJFbXBoYXNpcywgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMuanMnO1xuaW1wb3J0ICogYXMgbWFya2VySGVscGVyIGZyb20gJy4vbWFya2VySGVscGVyLmpzJztcbmltcG9ydCBNYXJrZXJWaWV3IGZyb20gJy4vTWFya2VyVmlldy5qcyc7XG5pbXBvcnQgeyByZXRyaWV2ZSwgbWVyZ2VBbGwsIG1hcCwgY3VycnksIGZpbHRlciwgZXh0ZW5kLCBpc1N0cmluZyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBpc0Nvb3JkaW5hdGVTeXN0ZW1UeXBlIH0gZnJvbSAnLi4vLi4vY29vcmQvQ29vcmRpbmF0ZVN5c3RlbS5qcyc7XG5pbXBvcnQgTWFya2VyTW9kZWwgZnJvbSAnLi9NYXJrZXJNb2RlbC5qcyc7XG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCB7IGdldFZpc3VhbEZyb21EYXRhIH0gZnJvbSAnLi4vLi4vdmlzdWFsL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBzZXRMYWJlbFN0eWxlLCBnZXRMYWJlbFN0YXRlc01vZGVscyB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlLmpzJztcbmltcG9ydCB7IHBhcnNlRGF0YVZhbHVlIH0gZnJvbSAnLi4vLi4vZGF0YS9oZWxwZXIvZGF0YVZhbHVlSGVscGVyLmpzJztcbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xudmFyIG1hcmtBcmVhVHJhbnNmb3JtID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBjb29yZFN5cywgbWFNb2RlbCwgaXRlbSkge1xuICAvLyBpdGVtIG1heSBiZSBudWxsXG4gIHZhciBpdGVtMCA9IGl0ZW1bMF07XG4gIHZhciBpdGVtMSA9IGl0ZW1bMV07XG4gIGlmICghaXRlbTAgfHwgIWl0ZW0xKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBsdCA9IG1hcmtlckhlbHBlci5kYXRhVHJhbnNmb3JtKHNlcmllc01vZGVsLCBpdGVtMCk7XG4gIHZhciByYiA9IG1hcmtlckhlbHBlci5kYXRhVHJhbnNmb3JtKHNlcmllc01vZGVsLCBpdGVtMSk7XG4gIC8vIEZJWE1FIG1ha2Ugc3VyZSBsdCBpcyBsZXNzIHRoYW4gcmJcbiAgdmFyIGx0Q29vcmQgPSBsdC5jb29yZDtcbiAgdmFyIHJiQ29vcmQgPSByYi5jb29yZDtcbiAgbHRDb29yZFswXSA9IHJldHJpZXZlKGx0Q29vcmRbMF0sIC1JbmZpbml0eSk7XG4gIGx0Q29vcmRbMV0gPSByZXRyaWV2ZShsdENvb3JkWzFdLCAtSW5maW5pdHkpO1xuICByYkNvb3JkWzBdID0gcmV0cmlldmUocmJDb29yZFswXSwgSW5maW5pdHkpO1xuICByYkNvb3JkWzFdID0gcmV0cmlldmUocmJDb29yZFsxXSwgSW5maW5pdHkpO1xuICAvLyBNZXJnZSBvcHRpb24gaW50byBvbmVcbiAgdmFyIHJlc3VsdCA9IG1lcmdlQWxsKFt7fSwgbHQsIHJiXSk7XG4gIHJlc3VsdC5jb29yZCA9IFtsdC5jb29yZCwgcmIuY29vcmRdO1xuICByZXN1bHQueDAgPSBsdC54O1xuICByZXN1bHQueTAgPSBsdC55O1xuICByZXN1bHQueDEgPSByYi54O1xuICByZXN1bHQueTEgPSByYi55O1xuICByZXR1cm4gcmVzdWx0O1xufTtcbmZ1bmN0aW9uIGlzSW5maW5pdHkodmFsKSB7XG4gIHJldHVybiAhaXNOYU4odmFsKSAmJiAhaXNGaW5pdGUodmFsKTtcbn1cbi8vIElmIGEgbWFya0FyZWEgaGFzIG9uZSBkaW1cbmZ1bmN0aW9uIGlmTWFya0FyZWFIYXNPbmx5RGltKGRpbUluZGV4LCBmcm9tQ29vcmQsIHRvQ29vcmQsIGNvb3JkU3lzKSB7XG4gIHZhciBvdGhlckRpbUluZGV4ID0gMSAtIGRpbUluZGV4O1xuICByZXR1cm4gaXNJbmZpbml0eShmcm9tQ29vcmRbb3RoZXJEaW1JbmRleF0pICYmIGlzSW5maW5pdHkodG9Db29yZFtvdGhlckRpbUluZGV4XSk7XG59XG5mdW5jdGlvbiBtYXJrQXJlYUZpbHRlcihjb29yZFN5cywgaXRlbSkge1xuICB2YXIgZnJvbUNvb3JkID0gaXRlbS5jb29yZFswXTtcbiAgdmFyIHRvQ29vcmQgPSBpdGVtLmNvb3JkWzFdO1xuICB2YXIgaXRlbTAgPSB7XG4gICAgY29vcmQ6IGZyb21Db29yZCxcbiAgICB4OiBpdGVtLngwLFxuICAgIHk6IGl0ZW0ueTBcbiAgfTtcbiAgdmFyIGl0ZW0xID0ge1xuICAgIGNvb3JkOiB0b0Nvb3JkLFxuICAgIHg6IGl0ZW0ueDEsXG4gICAgeTogaXRlbS55MVxuICB9O1xuICBpZiAoaXNDb29yZGluYXRlU3lzdGVtVHlwZShjb29yZFN5cywgJ2NhcnRlc2lhbjJkJykpIHtcbiAgICAvLyBJbiBjYXNlXG4gICAgLy8ge1xuICAgIC8vICBtYXJrQXJlYToge1xuICAgIC8vICAgIGRhdGE6IFt7IHlBeGlzOiAyIH1dXG4gICAgLy8gIH1cbiAgICAvLyB9XG4gICAgaWYgKGZyb21Db29yZCAmJiB0b0Nvb3JkICYmIChpZk1hcmtBcmVhSGFzT25seURpbSgxLCBmcm9tQ29vcmQsIHRvQ29vcmQsIGNvb3JkU3lzKSB8fCBpZk1hcmtBcmVhSGFzT25seURpbSgwLCBmcm9tQ29vcmQsIHRvQ29vcmQsIGNvb3JkU3lzKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBEaXJlY3RseSByZXR1cm5pbmcgdHJ1ZSBtYXkgYWxzbyBkbyB0aGUgd29yayxcbiAgICAvLyBiZWNhdXNlIG1hcmtBcmVhIHdpbGwgbm90IGJlIHNob3duIGF1dG9tYXRpY2FsbHlcbiAgICAvLyB3aGVuIGl0J3Mgbm90IGluY2x1ZGVkIGluIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgIC8vIEJ1dCBmaWx0ZXJpbmcgYWhlYWQgY2FuIGF2b2lkIGtlZXBpbmcgcmVuZGVyaW5nIG1hcmtBcmVhXG4gICAgLy8gd2hlbiB0aGVyZSBhcmUgdG9vIG1hbnkgb2YgdGhlbS5cbiAgICByZXR1cm4gbWFya2VySGVscGVyLnpvbmVGaWx0ZXIoY29vcmRTeXMsIGl0ZW0wLCBpdGVtMSk7XG4gIH1cbiAgcmV0dXJuIG1hcmtlckhlbHBlci5kYXRhRmlsdGVyKGNvb3JkU3lzLCBpdGVtMCkgfHwgbWFya2VySGVscGVyLmRhdGFGaWx0ZXIoY29vcmRTeXMsIGl0ZW0xKTtcbn1cbi8vIGRpbXMgY2FuIGJlIFsneDAnLCAneTAnXSwgWyd4MScsICd5MSddLCBbJ3gwJywgJ3kxJ10sIFsneDEnLCAneTAnXVxuZnVuY3Rpb24gZ2V0U2luZ2xlTWFya2VyRW5kUG9pbnQoZGF0YSwgaWR4LCBkaW1zLCBzZXJpZXNNb2RlbCwgYXBpKSB7XG4gIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICB2YXIgcG9pbnQ7XG4gIHZhciB4UHggPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChpdGVtTW9kZWwuZ2V0KGRpbXNbMF0pLCBhcGkuZ2V0V2lkdGgoKSk7XG4gIHZhciB5UHggPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChpdGVtTW9kZWwuZ2V0KGRpbXNbMV0pLCBhcGkuZ2V0SGVpZ2h0KCkpO1xuICBpZiAoIWlzTmFOKHhQeCkgJiYgIWlzTmFOKHlQeCkpIHtcbiAgICBwb2ludCA9IFt4UHgsIHlQeF07XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hhcnQgbGlrZSBiYXIgbWF5IGhhdmUgdGhlcmUgb3duIG1hcmtlciBwb3NpdGlvbmluZyBsb2dpY1xuICAgIGlmIChzZXJpZXNNb2RlbC5nZXRNYXJrZXJQb3NpdGlvbikge1xuICAgICAgLy8gQ29uc2lkZXIgdGhlIGNhc2UgdGhhdCB1c2VyIGlucHV0IHRoZSByaWdodC1ib3R0b20gcG9pbnQgZmlyc3RcbiAgICAgIC8vIFBpY2sgdGhlIGxhcmdlciB4IGFuZCB5IGFzICd4MScgYW5kICd5MSdcbiAgICAgIHZhciBwb2ludFZhbHVlMCA9IGRhdGEuZ2V0VmFsdWVzKFsneDAnLCAneTAnXSwgaWR4KTtcbiAgICAgIHZhciBwb2ludFZhbHVlMSA9IGRhdGEuZ2V0VmFsdWVzKFsneDEnLCAneTEnXSwgaWR4KTtcbiAgICAgIHZhciBjbGFtcFBvaW50VmFsdWUwID0gY29vcmRTeXMuY2xhbXBEYXRhKHBvaW50VmFsdWUwKTtcbiAgICAgIHZhciBjbGFtcFBvaW50VmFsdWUxID0gY29vcmRTeXMuY2xhbXBEYXRhKHBvaW50VmFsdWUxKTtcbiAgICAgIHZhciBwb2ludFZhbHVlID0gW107XG4gICAgICBpZiAoZGltc1swXSA9PT0gJ3gwJykge1xuICAgICAgICBwb2ludFZhbHVlWzBdID0gY2xhbXBQb2ludFZhbHVlMFswXSA+IGNsYW1wUG9pbnRWYWx1ZTFbMF0gPyBwb2ludFZhbHVlMVswXSA6IHBvaW50VmFsdWUwWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnRWYWx1ZVswXSA9IGNsYW1wUG9pbnRWYWx1ZTBbMF0gPiBjbGFtcFBvaW50VmFsdWUxWzBdID8gcG9pbnRWYWx1ZTBbMF0gOiBwb2ludFZhbHVlMVswXTtcbiAgICAgIH1cbiAgICAgIGlmIChkaW1zWzFdID09PSAneTAnKSB7XG4gICAgICAgIHBvaW50VmFsdWVbMV0gPSBjbGFtcFBvaW50VmFsdWUwWzFdID4gY2xhbXBQb2ludFZhbHVlMVsxXSA/IHBvaW50VmFsdWUxWzFdIDogcG9pbnRWYWx1ZTBbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb2ludFZhbHVlWzFdID0gY2xhbXBQb2ludFZhbHVlMFsxXSA+IGNsYW1wUG9pbnRWYWx1ZTFbMV0gPyBwb2ludFZhbHVlMFsxXSA6IHBvaW50VmFsdWUxWzFdO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHRoZSBnZXRNYXJrZXJQb3NpdGlvblxuICAgICAgcG9pbnQgPSBzZXJpZXNNb2RlbC5nZXRNYXJrZXJQb3NpdGlvbihwb2ludFZhbHVlLCBkaW1zLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHggPSBkYXRhLmdldChkaW1zWzBdLCBpZHgpO1xuICAgICAgdmFyIHkgPSBkYXRhLmdldChkaW1zWzFdLCBpZHgpO1xuICAgICAgdmFyIHB0ID0gW3gsIHldO1xuICAgICAgY29vcmRTeXMuY2xhbXBEYXRhICYmIGNvb3JkU3lzLmNsYW1wRGF0YShwdCwgcHQpO1xuICAgICAgcG9pbnQgPSBjb29yZFN5cy5kYXRhVG9Qb2ludChwdCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChpc0Nvb3JkaW5hdGVTeXN0ZW1UeXBlKGNvb3JkU3lzLCAnY2FydGVzaWFuMmQnKSkge1xuICAgICAgLy8gVE9ETzogVFlQRSB0c0A0LjEgbWF5IHN0aWxsIGluZmVyIGl0IGFzIEF4aXMgaW5zdGVhZCBvZiBBeGlzMkQuIE5vdCBzdXJlIGlmIGl0J3MgYSBidWdcbiAgICAgIHZhciB4QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3gnKTtcbiAgICAgIHZhciB5QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3knKTtcbiAgICAgIHZhciB4ID0gZGF0YS5nZXQoZGltc1swXSwgaWR4KTtcbiAgICAgIHZhciB5ID0gZGF0YS5nZXQoZGltc1sxXSwgaWR4KTtcbiAgICAgIGlmIChpc0luZmluaXR5KHgpKSB7XG4gICAgICAgIHBvaW50WzBdID0geEF4aXMudG9HbG9iYWxDb29yZCh4QXhpcy5nZXRFeHRlbnQoKVtkaW1zWzBdID09PSAneDAnID8gMCA6IDFdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJbmZpbml0eSh5KSkge1xuICAgICAgICBwb2ludFsxXSA9IHlBeGlzLnRvR2xvYmFsQ29vcmQoeUF4aXMuZ2V0RXh0ZW50KClbZGltc1sxXSA9PT0gJ3kwJyA/IDAgOiAxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVzZSB4LCB5IGlmIGhhcyBhbnlcbiAgICBpZiAoIWlzTmFOKHhQeCkpIHtcbiAgICAgIHBvaW50WzBdID0geFB4O1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKHlQeCkpIHtcbiAgICAgIHBvaW50WzFdID0geVB4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcG9pbnQ7XG59XG5leHBvcnQgdmFyIGRpbVBlcm11dGF0aW9ucyA9IFtbJ3gwJywgJ3kwJ10sIFsneDEnLCAneTAnXSwgWyd4MScsICd5MSddLCBbJ3gwJywgJ3kxJ11dO1xudmFyIE1hcmtBcmVhVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNYXJrQXJlYVZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIE1hcmtBcmVhVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gTWFya0FyZWFWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIE1hcmtBcmVhVmlldy5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKG1hcmtBcmVhTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHZhciBtYU1vZGVsID0gTWFya2VyTW9kZWwuZ2V0TWFya2VyTW9kZWxGcm9tU2VyaWVzKHNlcmllc01vZGVsLCAnbWFya0FyZWEnKTtcbiAgICAgIGlmIChtYU1vZGVsKSB7XG4gICAgICAgIHZhciBhcmVhRGF0YV8xID0gbWFNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgIGFyZWFEYXRhXzEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IG1hcChkaW1QZXJtdXRhdGlvbnMsIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTaW5nbGVNYXJrZXJFbmRQb2ludChhcmVhRGF0YV8xLCBpZHgsIGRpbSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gTGF5b3V0XG4gICAgICAgICAgYXJlYURhdGFfMS5zZXRJdGVtTGF5b3V0KGlkeCwgcG9pbnRzKTtcbiAgICAgICAgICB2YXIgZWwgPSBhcmVhRGF0YV8xLmdldEl0ZW1HcmFwaGljRWwoaWR4KTtcbiAgICAgICAgICBlbC5zZXRTaGFwZSgncG9pbnRzJywgcG9pbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIE1hcmtBcmVhVmlldy5wcm90b3R5cGUucmVuZGVyU2VyaWVzID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBtYU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBzZXJpZXNJZCA9IHNlcmllc01vZGVsLmlkO1xuICAgIHZhciBzZXJpZXNEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBhcmVhR3JvdXBNYXAgPSB0aGlzLm1hcmtlckdyb3VwTWFwO1xuICAgIHZhciBwb2x5Z29uR3JvdXAgPSBhcmVhR3JvdXBNYXAuZ2V0KHNlcmllc0lkKSB8fCBhcmVhR3JvdXBNYXAuc2V0KHNlcmllc0lkLCB7XG4gICAgICBncm91cDogbmV3IGdyYXBoaWMuR3JvdXAoKVxuICAgIH0pO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHBvbHlnb25Hcm91cC5ncm91cCk7XG4gICAgdGhpcy5tYXJrS2VlcChwb2x5Z29uR3JvdXApO1xuICAgIHZhciBhcmVhRGF0YSA9IGNyZWF0ZUxpc3QoY29vcmRTeXMsIHNlcmllc01vZGVsLCBtYU1vZGVsKTtcbiAgICAvLyBMaW5lIGRhdGEgZm9yIHRvb2x0aXAgYW5kIGZvcm1hdHRlclxuICAgIG1hTW9kZWwuc2V0RGF0YShhcmVhRGF0YSk7XG4gICAgLy8gVXBkYXRlIHZpc3VhbCBhbmQgbGF5b3V0IG9mIGxpbmVcbiAgICBhcmVhRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIC8vIExheW91dFxuICAgICAgdmFyIHBvaW50cyA9IG1hcChkaW1QZXJtdXRhdGlvbnMsIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgcmV0dXJuIGdldFNpbmdsZU1hcmtlckVuZFBvaW50KGFyZWFEYXRhLCBpZHgsIGRpbSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgICB9KTtcbiAgICAgIHZhciB4QXhpc1NjYWxlID0gY29vcmRTeXMuZ2V0QXhpcygneCcpLnNjYWxlO1xuICAgICAgdmFyIHlBeGlzU2NhbGUgPSBjb29yZFN5cy5nZXRBeGlzKCd5Jykuc2NhbGU7XG4gICAgICB2YXIgeEF4aXNFeHRlbnQgPSB4QXhpc1NjYWxlLmdldEV4dGVudCgpO1xuICAgICAgdmFyIHlBeGlzRXh0ZW50ID0geUF4aXNTY2FsZS5nZXRFeHRlbnQoKTtcbiAgICAgIHZhciB4UG9pbnRFeHRlbnQgPSBbeEF4aXNTY2FsZS5wYXJzZShhcmVhRGF0YS5nZXQoJ3gwJywgaWR4KSksIHhBeGlzU2NhbGUucGFyc2UoYXJlYURhdGEuZ2V0KCd4MScsIGlkeCkpXTtcbiAgICAgIHZhciB5UG9pbnRFeHRlbnQgPSBbeUF4aXNTY2FsZS5wYXJzZShhcmVhRGF0YS5nZXQoJ3kwJywgaWR4KSksIHlBeGlzU2NhbGUucGFyc2UoYXJlYURhdGEuZ2V0KCd5MScsIGlkeCkpXTtcbiAgICAgIG51bWJlclV0aWwuYXNjKHhQb2ludEV4dGVudCk7XG4gICAgICBudW1iZXJVdGlsLmFzYyh5UG9pbnRFeHRlbnQpO1xuICAgICAgdmFyIG92ZXJsYXBwZWQgPSAhKHhBeGlzRXh0ZW50WzBdID4geFBvaW50RXh0ZW50WzFdIHx8IHhBeGlzRXh0ZW50WzFdIDwgeFBvaW50RXh0ZW50WzBdIHx8IHlBeGlzRXh0ZW50WzBdID4geVBvaW50RXh0ZW50WzFdIHx8IHlBeGlzRXh0ZW50WzFdIDwgeVBvaW50RXh0ZW50WzBdKTtcbiAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGFyZWEgaXMgaW5zaWRlIGNvb3JkU3lzLCBhbGxDbGlwcGVkIGlzIHNldCB0byBiZSB0cnVlXG4gICAgICAvLyBpbiBsYXlvdXQgc28gdGhhdCBsYWJlbCB3aWxsIG5vdCBiZSBkaXNwbGF5ZWQuIFNlZSAjMTI1OTFcbiAgICAgIHZhciBhbGxDbGlwcGVkID0gIW92ZXJsYXBwZWQ7XG4gICAgICBhcmVhRGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwge1xuICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgYWxsQ2xpcHBlZDogYWxsQ2xpcHBlZFxuICAgICAgfSk7XG4gICAgICB2YXIgc3R5bGUgPSBhcmVhRGF0YS5nZXRJdGVtTW9kZWwoaWR4KS5nZXRNb2RlbCgnaXRlbVN0eWxlJykuZ2V0SXRlbVN0eWxlKCk7XG4gICAgICB2YXIgY29sb3IgPSBnZXRWaXN1YWxGcm9tRGF0YShzZXJpZXNEYXRhLCAnY29sb3InKTtcbiAgICAgIGlmICghc3R5bGUuZmlsbCkge1xuICAgICAgICBzdHlsZS5maWxsID0gY29sb3I7XG4gICAgICAgIGlmIChpc1N0cmluZyhzdHlsZS5maWxsKSkge1xuICAgICAgICAgIHN0eWxlLmZpbGwgPSBjb2xvclV0aWwubW9kaWZ5QWxwaGEoc3R5bGUuZmlsbCwgMC40KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFzdHlsZS5zdHJva2UpIHtcbiAgICAgICAgc3R5bGUuc3Ryb2tlID0gY29sb3I7XG4gICAgICB9XG4gICAgICAvLyBWaXN1YWxcbiAgICAgIGFyZWFEYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3R5bGUnLCBzdHlsZSk7XG4gICAgfSk7XG4gICAgYXJlYURhdGEuZGlmZihpbm5lcihwb2x5Z29uR3JvdXApLmRhdGEpLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgbGF5b3V0ID0gYXJlYURhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgaWYgKCFsYXlvdXQuYWxsQ2xpcHBlZCkge1xuICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBncmFwaGljLlBvbHlnb24oe1xuICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBwb2ludHM6IGxheW91dC5wb2ludHNcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhcmVhRGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgcG9seWdvbik7XG4gICAgICAgIHBvbHlnb25Hcm91cC5ncm91cC5hZGQocG9seWdvbik7XG4gICAgICB9XG4gICAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgdmFyIHBvbHlnb24gPSBpbm5lcihwb2x5Z29uR3JvdXApLmRhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuICAgICAgdmFyIGxheW91dCA9IGFyZWFEYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KTtcbiAgICAgIGlmICghbGF5b3V0LmFsbENsaXBwZWQpIHtcbiAgICAgICAgaWYgKHBvbHlnb24pIHtcbiAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvbHlnb24sIHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgIHBvaW50czogbGF5b3V0LnBvaW50c1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIG1hTW9kZWwsIG5ld0lkeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9seWdvbiA9IG5ldyBncmFwaGljLlBvbHlnb24oe1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgcG9pbnRzOiBsYXlvdXQucG9pbnRzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJlYURhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIHBvbHlnb24pO1xuICAgICAgICBwb2x5Z29uR3JvdXAuZ3JvdXAuYWRkKHBvbHlnb24pO1xuICAgICAgfSBlbHNlIGlmIChwb2x5Z29uKSB7XG4gICAgICAgIHBvbHlnb25Hcm91cC5ncm91cC5yZW1vdmUocG9seWdvbik7XG4gICAgICB9XG4gICAgfSkucmVtb3ZlKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBwb2x5Z29uID0gaW5uZXIocG9seWdvbkdyb3VwKS5kYXRhLmdldEl0ZW1HcmFwaGljRWwoaWR4KTtcbiAgICAgIHBvbHlnb25Hcm91cC5ncm91cC5yZW1vdmUocG9seWdvbik7XG4gICAgfSkuZXhlY3V0ZSgpO1xuICAgIGFyZWFEYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChwb2x5Z29uLCBpZHgpIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBhcmVhRGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgIHZhciBzdHlsZSA9IGFyZWFEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3R5bGUnKTtcbiAgICAgIHBvbHlnb24udXNlU3R5bGUoYXJlYURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzdHlsZScpKTtcbiAgICAgIHNldExhYmVsU3R5bGUocG9seWdvbiwgZ2V0TGFiZWxTdGF0ZXNNb2RlbHMoaXRlbU1vZGVsKSwge1xuICAgICAgICBsYWJlbEZldGNoZXI6IG1hTW9kZWwsXG4gICAgICAgIGxhYmVsRGF0YUluZGV4OiBpZHgsXG4gICAgICAgIGRlZmF1bHRUZXh0OiBhcmVhRGF0YS5nZXROYW1lKGlkeCkgfHwgJycsXG4gICAgICAgIGluaGVyaXRDb2xvcjogaXNTdHJpbmcoc3R5bGUuZmlsbCkgPyBjb2xvclV0aWwubW9kaWZ5QWxwaGEoc3R5bGUuZmlsbCwgMSkgOiAnIzAwMCdcbiAgICAgIH0pO1xuICAgICAgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsKHBvbHlnb24sIGl0ZW1Nb2RlbCk7XG4gICAgICB0b2dnbGVIb3ZlckVtcGhhc2lzKHBvbHlnb24sIG51bGwsIG51bGwsIGl0ZW1Nb2RlbC5nZXQoWydlbXBoYXNpcycsICdkaXNhYmxlZCddKSk7XG4gICAgICBnZXRFQ0RhdGEocG9seWdvbikuZGF0YU1vZGVsID0gbWFNb2RlbDtcbiAgICB9KTtcbiAgICBpbm5lcihwb2x5Z29uR3JvdXApLmRhdGEgPSBhcmVhRGF0YTtcbiAgICBwb2x5Z29uR3JvdXAuZ3JvdXAuc2lsZW50ID0gbWFNb2RlbC5nZXQoJ3NpbGVudCcpIHx8IHNlcmllc01vZGVsLmdldCgnc2lsZW50Jyk7XG4gIH07XG4gIE1hcmtBcmVhVmlldy50eXBlID0gJ21hcmtBcmVhJztcbiAgcmV0dXJuIE1hcmtBcmVhVmlldztcbn0oTWFya2VyVmlldyk7XG5mdW5jdGlvbiBjcmVhdGVMaXN0KGNvb3JkU3lzLCBzZXJpZXNNb2RlbCwgbWFNb2RlbCkge1xuICB2YXIgYXJlYURhdGE7XG4gIHZhciBkYXRhRGltcztcbiAgdmFyIGRpbXMgPSBbJ3gwJywgJ3kwJywgJ3gxJywgJ3kxJ107XG4gIGlmIChjb29yZFN5cykge1xuICAgIHZhciBjb29yZERpbXNJbmZvc18xID0gbWFwKGNvb3JkU3lzICYmIGNvb3JkU3lzLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChjb29yZERpbSkge1xuICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgaW5mbyA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkYXRhLm1hcERpbWVuc2lvbihjb29yZERpbSkpIHx8IHt9O1xuICAgICAgLy8gSW4gbWFwIHNlcmllcyBkYXRhIGRvbid0IGhhdmUgbG5nIGFuZCBsYXQgZGltZW5zaW9uLiBGYWxsYmFjayB0byBzYW1lIHdpdGggY29vcmRTeXNcbiAgICAgIHJldHVybiBleHRlbmQoZXh0ZW5kKHt9LCBpbmZvKSwge1xuICAgICAgICBuYW1lOiBjb29yZERpbSxcbiAgICAgICAgLy8gRE9OJ1QgdXNlIG9yZGluYWxNZXRhIHRvIHBhcnNlIGFuZCBjb2xsZWN0IG9yZGluYWwuXG4gICAgICAgIG9yZGluYWxNZXRhOiBudWxsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBkYXRhRGltcyA9IG1hcChkaW1zLCBmdW5jdGlvbiAoZGltLCBpZHgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGRpbSxcbiAgICAgICAgdHlwZTogY29vcmREaW1zSW5mb3NfMVtpZHggJSAyXS50eXBlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGFyZWFEYXRhID0gbmV3IFNlcmllc0RhdGEoZGF0YURpbXMsIG1hTW9kZWwpO1xuICB9IGVsc2Uge1xuICAgIGRhdGFEaW1zID0gW3tcbiAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICB0eXBlOiAnZmxvYXQnXG4gICAgfV07XG4gICAgYXJlYURhdGEgPSBuZXcgU2VyaWVzRGF0YShkYXRhRGltcywgbWFNb2RlbCk7XG4gIH1cbiAgdmFyIG9wdERhdGEgPSBtYXAobWFNb2RlbC5nZXQoJ2RhdGEnKSwgY3VycnkobWFya0FyZWFUcmFuc2Zvcm0sIHNlcmllc01vZGVsLCBjb29yZFN5cywgbWFNb2RlbCkpO1xuICBpZiAoY29vcmRTeXMpIHtcbiAgICBvcHREYXRhID0gZmlsdGVyKG9wdERhdGEsIGN1cnJ5KG1hcmtBcmVhRmlsdGVyLCBjb29yZFN5cykpO1xuICB9XG4gIHZhciBkaW1WYWx1ZUdldHRlciA9IGNvb3JkU3lzID8gZnVuY3Rpb24gKGl0ZW0sIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgICAvLyBUT0RPIHNob3VsZCBjb252ZXJ0IHRvIFBhcnNlZFZhbHVlP1xuICAgIHZhciByYXdWYWwgPSBpdGVtLmNvb3JkW01hdGguZmxvb3IoZGltSW5kZXggLyAyKV1bZGltSW5kZXggJSAyXTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVmFsdWUocmF3VmFsLCBkYXRhRGltc1tkaW1JbmRleF0pO1xuICB9IDogZnVuY3Rpb24gKGl0ZW0sIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgICByZXR1cm4gcGFyc2VEYXRhVmFsdWUoaXRlbS52YWx1ZSwgZGF0YURpbXNbZGltSW5kZXhdKTtcbiAgfTtcbiAgYXJlYURhdGEuaW5pdERhdGEob3B0RGF0YSwgbnVsbCwgZGltVmFsdWVHZXR0ZXIpO1xuICBhcmVhRGF0YS5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgcmV0dXJuIGFyZWFEYXRhO1xufVxuZXhwb3J0IGRlZmF1bHQgTWFya0FyZWFWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IGNoZWNrTWFya2VySW5TZXJpZXMgZnJvbSAnLi9jaGVja01hcmtlckluU2VyaWVzLmpzJztcbmltcG9ydCBNYXJrQXJlYU1vZGVsIGZyb20gJy4vTWFya0FyZWFNb2RlbC5qcyc7XG5pbXBvcnQgTWFya0FyZWFWaWV3IGZyb20gJy4vTWFya0FyZWFWaWV3LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChNYXJrQXJlYU1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhNYXJrQXJlYVZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJQcmVwcm9jZXNzb3IoZnVuY3Rpb24gKG9wdCkge1xuICAgIGlmIChjaGVja01hcmtlckluU2VyaWVzKG9wdC5zZXJpZXMsICdtYXJrQXJlYScpKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgbWFya0FyZWEgY29tcG9uZW50IGlzIGVuYWJsZWRcbiAgICAgIG9wdC5tYXJrQXJlYSA9IG9wdC5tYXJrQXJlYSB8fCB7fTtcbiAgICB9XG4gIH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39838\n")},42998:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/checkMarkerInSeries.js\nvar checkMarkerInSeries = __webpack_require__(72581);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/MarkerModel.js\nvar MarkerModel = __webpack_require__(82802);\n;// ./node_modules/echarts/lib/component/marker/MarkLineModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar MarkLineModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(MarkLineModel, _super);\n  function MarkLineModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = MarkLineModel.type;\n    return _this;\n  }\n  MarkLineModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {\n    return new MarkLineModel(markerOpt, masterMarkerModel, ecModel);\n  };\n  MarkLineModel.type = 'markLine';\n  MarkLineModel.defaultOption = {\n    // zlevel: 0,\n    z: 5,\n    symbol: ['circle', 'arrow'],\n    symbolSize: [8, 16],\n    // symbolRotate: 0,\n    symbolOffset: 0,\n    precision: 2,\n    tooltip: {\n      trigger: 'item'\n    },\n    label: {\n      show: true,\n      position: 'end',\n      distance: 5\n    },\n    lineStyle: {\n      type: 'dashed'\n    },\n    emphasis: {\n      label: {\n        show: true\n      },\n      lineStyle: {\n        width: 3\n      }\n    },\n    animationEasing: 'linear'\n  };\n  return MarkLineModel;\n}(MarkerModel/* default */.A);\n/* harmony default export */ const marker_MarkLineModel = (MarkLineModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/SeriesData.js\nvar SeriesData = __webpack_require__(6006);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/markerHelper.js\nvar markerHelper = __webpack_require__(71171);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/LineDraw.js\nvar LineDraw = __webpack_require__(64380);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/MarkerView.js\nvar MarkerView = __webpack_require__(1854);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/dataStackHelper.js\nvar dataStackHelper = __webpack_require__(65008);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/CoordinateSystem.js\nvar CoordinateSystem = __webpack_require__(41849);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/helper.js\nvar helper = __webpack_require__(37395);\n;// ./node_modules/echarts/lib/component/marker/MarkLineView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar inner = (0,model/* makeInner */.$r)();\nvar markLineTransform = function (seriesModel, coordSys, mlModel, item) {\n  var data = seriesModel.getData();\n  var itemArray;\n  if (!(0,util.isArray)(item)) {\n    // Special type markLine like 'min', 'max', 'average', 'median'\n    var mlType = item.type;\n    if (mlType === 'min' || mlType === 'max' || mlType === 'average' || mlType === 'median'\n    // In case\n    // data: [{\n    //   yAxis: 10\n    // }]\n    || item.xAxis != null || item.yAxis != null) {\n      var valueAxis = void 0;\n      var value = void 0;\n      if (item.yAxis != null || item.xAxis != null) {\n        valueAxis = coordSys.getAxis(item.yAxis != null ? 'y' : 'x');\n        value = (0,util.retrieve)(item.yAxis, item.xAxis);\n      } else {\n        var axisInfo = markerHelper/* getAxisInfo */.Yc(item, data, coordSys, seriesModel);\n        valueAxis = axisInfo.valueAxis;\n        var valueDataDim = (0,dataStackHelper/* getStackedDimension */.me)(data, axisInfo.valueDataDim);\n        value = markerHelper/* numCalculate */.vz(data, valueDataDim, mlType);\n      }\n      var valueIndex = valueAxis.dim === 'x' ? 0 : 1;\n      var baseIndex = 1 - valueIndex;\n      // Normized to 2d data with start and end point\n      var mlFrom = (0,util.clone)(item);\n      var mlTo = {\n        coord: []\n      };\n      mlFrom.type = null;\n      mlFrom.coord = [];\n      mlFrom.coord[baseIndex] = -Infinity;\n      mlTo.coord[baseIndex] = Infinity;\n      var precision = mlModel.get('precision');\n      if (precision >= 0 && (0,util.isNumber)(value)) {\n        value = +value.toFixed(Math.min(precision, 20));\n      }\n      mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;\n      itemArray = [mlFrom, mlTo, {\n        type: mlType,\n        valueIndex: item.valueIndex,\n        // Force to use the value of calculated value.\n        value: value\n      }];\n    } else {\n      // Invalid data\n      if (false) {}\n      itemArray = [];\n    }\n  } else {\n    itemArray = item;\n  }\n  var normalizedItem = [markerHelper/* dataTransform */.xx(seriesModel, itemArray[0]), markerHelper/* dataTransform */.xx(seriesModel, itemArray[1]), (0,util.extend)({}, itemArray[2])];\n  // Avoid line data type is extended by from(to) data type\n  normalizedItem[2].type = normalizedItem[2].type || null;\n  // Merge from option and to option into line option\n  (0,util.merge)(normalizedItem[2], normalizedItem[0]);\n  (0,util.merge)(normalizedItem[2], normalizedItem[1]);\n  return normalizedItem;\n};\nfunction isInfinity(val) {\n  return !isNaN(val) && !isFinite(val);\n}\n// If a markLine has one dim\nfunction ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n  var otherDimIndex = 1 - dimIndex;\n  var dimName = coordSys.dimensions[dimIndex];\n  return isInfinity(fromCoord[otherDimIndex]) && isInfinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);\n}\nfunction markLineFilter(coordSys, item) {\n  if (coordSys.type === 'cartesian2d') {\n    var fromCoord = item[0].coord;\n    var toCoord = item[1].coord;\n    // In case\n    // {\n    //  markLine: {\n    //    data: [{ yAxis: 2 }]\n    //  }\n    // }\n    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {\n      return true;\n    }\n  }\n  return markerHelper/* dataFilter */.Lq(coordSys, item[0]) && markerHelper/* dataFilter */.Lq(coordSys, item[1]);\n}\nfunction updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  var itemModel = data.getItemModel(idx);\n  var point;\n  var xPx = number/* parsePercent */.lo(itemModel.get('x'), api.getWidth());\n  var yPx = number/* parsePercent */.lo(itemModel.get('y'), api.getHeight());\n  if (!isNaN(xPx) && !isNaN(yPx)) {\n    point = [xPx, yPx];\n  } else {\n    // Chart like bar may have there own marker positioning logic\n    if (seriesModel.getMarkerPosition) {\n      // Use the getMarkerPosition\n      point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));\n    } else {\n      var dims = coordSys.dimensions;\n      var x = data.get(dims[0], idx);\n      var y = data.get(dims[1], idx);\n      point = coordSys.dataToPoint([x, y]);\n    }\n    // Expand line to the edge of grid if value on one axis is Inifnity\n    // In case\n    //  markLine: {\n    //    data: [{\n    //      yAxis: 2\n    //      // or\n    //      type: 'average'\n    //    }]\n    //  }\n    if ((0,CoordinateSystem/* isCoordinateSystemType */.g)(coordSys, 'cartesian2d')) {\n      // TODO: TYPE ts@4.1 may still infer it as Axis instead of Axis2D. Not sure if it's a bug\n      var xAxis = coordSys.getAxis('x');\n      var yAxis = coordSys.getAxis('y');\n      var dims = coordSys.dimensions;\n      if (isInfinity(data.get(dims[0], idx))) {\n        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);\n      } else if (isInfinity(data.get(dims[1], idx))) {\n        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);\n      }\n    }\n    // Use x, y if has any\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n  }\n  data.setItemLayout(idx, point);\n}\nvar MarkLineView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(MarkLineView, _super);\n  function MarkLineView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = MarkLineView.type;\n    return _this;\n  }\n  MarkLineView.prototype.updateTransform = function (markLineModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var mlModel = MarkerModel/* default */.A.getMarkerModelFromSeries(seriesModel, 'markLine');\n      if (mlModel) {\n        var mlData_1 = mlModel.getData();\n        var fromData_1 = inner(mlModel).from;\n        var toData_1 = inner(mlModel).to;\n        // Update visual and layout of from symbol and to symbol\n        fromData_1.each(function (idx) {\n          updateSingleMarkerEndLayout(fromData_1, idx, true, seriesModel, api);\n          updateSingleMarkerEndLayout(toData_1, idx, false, seriesModel, api);\n        });\n        // Update layout of line\n        mlData_1.each(function (idx) {\n          mlData_1.setItemLayout(idx, [fromData_1.getItemLayout(idx), toData_1.getItemLayout(idx)]);\n        });\n        this.markerGroupMap.get(seriesModel.id).updateLayout();\n      }\n    }, this);\n  };\n  MarkLineView.prototype.renderSeries = function (seriesModel, mlModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var lineDrawMap = this.markerGroupMap;\n    var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw/* default */.A());\n    this.group.add(lineDraw.group);\n    var mlData = createList(coordSys, seriesModel, mlModel);\n    var fromData = mlData.from;\n    var toData = mlData.to;\n    var lineData = mlData.line;\n    inner(mlModel).from = fromData;\n    inner(mlModel).to = toData;\n    // Line data for tooltip and formatter\n    mlModel.setData(lineData);\n    // TODO\n    // Functionally, `symbolSize` & `symbolOffset` can also be 2D array now.\n    // But the related logic and type definition are not finished yet.\n    // Finish it if required\n    var symbolType = mlModel.get('symbol');\n    var symbolSize = mlModel.get('symbolSize');\n    var symbolRotate = mlModel.get('symbolRotate');\n    var symbolOffset = mlModel.get('symbolOffset');\n    // TODO: support callback function like markPoint\n    if (!(0,util.isArray)(symbolType)) {\n      symbolType = [symbolType, symbolType];\n    }\n    if (!(0,util.isArray)(symbolSize)) {\n      symbolSize = [symbolSize, symbolSize];\n    }\n    if (!(0,util.isArray)(symbolRotate)) {\n      symbolRotate = [symbolRotate, symbolRotate];\n    }\n    if (!(0,util.isArray)(symbolOffset)) {\n      symbolOffset = [symbolOffset, symbolOffset];\n    }\n    // Update visual and layout of from symbol and to symbol\n    mlData.from.each(function (idx) {\n      updateDataVisualAndLayout(fromData, idx, true);\n      updateDataVisualAndLayout(toData, idx, false);\n    });\n    // Update visual and layout of line\n    lineData.each(function (idx) {\n      var lineStyle = lineData.getItemModel(idx).getModel('lineStyle').getLineStyle();\n      // lineData.setItemVisual(idx, {\n      //     color: lineColor || fromData.getItemVisual(idx, 'color')\n      // });\n      lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);\n      if (lineStyle.stroke == null) {\n        lineStyle.stroke = fromData.getItemVisual(idx, 'style').fill;\n      }\n      lineData.setItemVisual(idx, {\n        fromSymbolKeepAspect: fromData.getItemVisual(idx, 'symbolKeepAspect'),\n        fromSymbolOffset: fromData.getItemVisual(idx, 'symbolOffset'),\n        fromSymbolRotate: fromData.getItemVisual(idx, 'symbolRotate'),\n        fromSymbolSize: fromData.getItemVisual(idx, 'symbolSize'),\n        fromSymbol: fromData.getItemVisual(idx, 'symbol'),\n        toSymbolKeepAspect: toData.getItemVisual(idx, 'symbolKeepAspect'),\n        toSymbolOffset: toData.getItemVisual(idx, 'symbolOffset'),\n        toSymbolRotate: toData.getItemVisual(idx, 'symbolRotate'),\n        toSymbolSize: toData.getItemVisual(idx, 'symbolSize'),\n        toSymbol: toData.getItemVisual(idx, 'symbol'),\n        style: lineStyle\n      });\n    });\n    lineDraw.updateData(lineData);\n    // Set host model for tooltip\n    // FIXME\n    mlData.line.eachItemGraphicEl(function (el) {\n      (0,innerStore/* getECData */.z)(el).dataModel = mlModel;\n      el.traverse(function (child) {\n        (0,innerStore/* getECData */.z)(child).dataModel = mlModel;\n      });\n    });\n    function updateDataVisualAndLayout(data, idx, isFrom) {\n      var itemModel = data.getItemModel(idx);\n      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);\n      var style = itemModel.getModel('itemStyle').getItemStyle();\n      if (style.fill == null) {\n        style.fill = (0,helper/* getVisualFromData */.rI)(seriesData, 'color');\n      }\n      data.setItemVisual(idx, {\n        symbolKeepAspect: itemModel.get('symbolKeepAspect'),\n        // `0` should be considered as a valid value, so use `retrieve2` instead of `||`\n        symbolOffset: (0,util.retrieve2)(itemModel.get('symbolOffset', true), symbolOffset[isFrom ? 0 : 1]),\n        symbolRotate: (0,util.retrieve2)(itemModel.get('symbolRotate', true), symbolRotate[isFrom ? 0 : 1]),\n        // TODO: when 2d array is supported, it should ignore parent\n        symbolSize: (0,util.retrieve2)(itemModel.get('symbolSize'), symbolSize[isFrom ? 0 : 1]),\n        symbol: (0,util.retrieve2)(itemModel.get('symbol', true), symbolType[isFrom ? 0 : 1]),\n        style: style\n      });\n    }\n    this.markKeep(lineDraw);\n    lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');\n  };\n  MarkLineView.type = 'markLine';\n  return MarkLineView;\n}(MarkerView/* default */.A);\nfunction createList(coordSys, seriesModel, mlModel) {\n  var coordDimsInfos;\n  if (coordSys) {\n    coordDimsInfos = (0,util.map)(coordSys && coordSys.dimensions, function (coordDim) {\n      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};\n      // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n      return (0,util.extend)((0,util.extend)({}, info), {\n        name: coordDim,\n        // DON'T use ordinalMeta to parse and collect ordinal.\n        ordinalMeta: null\n      });\n    });\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n  }\n  var fromData = new SeriesData/* default */.A(coordDimsInfos, mlModel);\n  var toData = new SeriesData/* default */.A(coordDimsInfos, mlModel);\n  // No dimensions\n  var lineData = new SeriesData/* default */.A([], mlModel);\n  var optData = (0,util.map)(mlModel.get('data'), (0,util.curry)(markLineTransform, seriesModel, coordSys, mlModel));\n  if (coordSys) {\n    optData = (0,util.filter)(optData, (0,util.curry)(markLineFilter, coordSys));\n  }\n  var dimValueGetter = markerHelper/* createMarkerDimValueGetter */.fY(!!coordSys, coordDimsInfos);\n  fromData.initData((0,util.map)(optData, function (item) {\n    return item[0];\n  }), null, dimValueGetter);\n  toData.initData((0,util.map)(optData, function (item) {\n    return item[1];\n  }), null, dimValueGetter);\n  lineData.initData((0,util.map)(optData, function (item) {\n    return item[2];\n  }));\n  lineData.hasItemOption = true;\n  return {\n    from: fromData,\n    to: toData,\n    line: lineData\n  };\n}\n/* harmony default export */ const marker_MarkLineView = (MarkLineView);\n;// ./node_modules/echarts/lib/component/marker/installMarkLine.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\n\n\nfunction install(registers) {\n  registers.registerComponentModel(marker_MarkLineModel);\n  registers.registerComponentView(marker_MarkLineView);\n  registers.registerPreprocessor(function (opt) {\n    if ((0,checkMarkerInSeries/* default */.A)(opt.series, 'markLine')) {\n      // Make sure markLine component is enabled\n      opt.markLine = opt.markLine || {};\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI5OTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrTGluZU1vZGVsLmpzPzZjYzIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya0xpbmVWaWV3LmpzPzdjYjQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvaW5zdGFsbE1hcmtMaW5lLmpzP2UzZjciXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBNYXJrZXJNb2RlbCBmcm9tICcuL01hcmtlck1vZGVsLmpzJztcbnZhciBNYXJrTGluZU1vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKE1hcmtMaW5lTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIE1hcmtMaW5lTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IE1hcmtMaW5lTW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgTWFya0xpbmVNb2RlbC5wcm90b3R5cGUuY3JlYXRlTWFya2VyTW9kZWxGcm9tU2VyaWVzID0gZnVuY3Rpb24gKG1hcmtlck9wdCwgbWFzdGVyTWFya2VyTW9kZWwsIGVjTW9kZWwpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtMaW5lTW9kZWwobWFya2VyT3B0LCBtYXN0ZXJNYXJrZXJNb2RlbCwgZWNNb2RlbCk7XG4gIH07XG4gIE1hcmtMaW5lTW9kZWwudHlwZSA9ICdtYXJrTGluZSc7XG4gIE1hcmtMaW5lTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAvLyB6bGV2ZWw6IDAsXG4gICAgejogNSxcbiAgICBzeW1ib2w6IFsnY2lyY2xlJywgJ2Fycm93J10sXG4gICAgc3ltYm9sU2l6ZTogWzgsIDE2XSxcbiAgICAvLyBzeW1ib2xSb3RhdGU6IDAsXG4gICAgc3ltYm9sT2Zmc2V0OiAwLFxuICAgIHByZWNpc2lvbjogMixcbiAgICB0b29sdGlwOiB7XG4gICAgICB0cmlnZ2VyOiAnaXRlbSdcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgcG9zaXRpb246ICdlbmQnLFxuICAgICAgZGlzdGFuY2U6IDVcbiAgICB9LFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgdHlwZTogJ2Rhc2hlZCdcbiAgICB9LFxuICAgIGVtcGhhc2lzOiB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICBzaG93OiB0cnVlXG4gICAgICB9LFxuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiAzXG4gICAgICB9XG4gICAgfSxcbiAgICBhbmltYXRpb25FYXNpbmc6ICdsaW5lYXInXG4gIH07XG4gIHJldHVybiBNYXJrTGluZU1vZGVsO1xufShNYXJrZXJNb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBNYXJrTGluZU1vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgU2VyaWVzRGF0YSBmcm9tICcuLi8uLi9kYXRhL1Nlcmllc0RhdGEuanMnO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7XG5pbXBvcnQgKiBhcyBtYXJrZXJIZWxwZXIgZnJvbSAnLi9tYXJrZXJIZWxwZXIuanMnO1xuaW1wb3J0IExpbmVEcmF3IGZyb20gJy4uLy4uL2NoYXJ0L2hlbHBlci9MaW5lRHJhdy5qcyc7XG5pbXBvcnQgTWFya2VyVmlldyBmcm9tICcuL01hcmtlclZpZXcuanMnO1xuaW1wb3J0IHsgZ2V0U3RhY2tlZERpbWVuc2lvbiB9IGZyb20gJy4uLy4uL2RhdGEvaGVscGVyL2RhdGFTdGFja0hlbHBlci5qcyc7XG5pbXBvcnQgeyBpc0Nvb3JkaW5hdGVTeXN0ZW1UeXBlIH0gZnJvbSAnLi4vLi4vY29vcmQvQ29vcmRpbmF0ZVN5c3RlbS5qcyc7XG5pbXBvcnQgeyBnZXRFQ0RhdGEgfSBmcm9tICcuLi8uLi91dGlsL2lubmVyU3RvcmUuanMnO1xuaW1wb3J0IE1hcmtlck1vZGVsIGZyb20gJy4vTWFya2VyTW9kZWwuanMnO1xuaW1wb3J0IHsgaXNBcnJheSwgcmV0cmlldmUsIHJldHJpZXZlMiwgY2xvbmUsIGV4dGVuZCwgbG9nRXJyb3IsIG1lcmdlLCBtYXAsIGN1cnJ5LCBmaWx0ZXIsIGlzTnVtYmVyIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IG1ha2VJbm5lciB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xuaW1wb3J0IHsgZ2V0VmlzdWFsRnJvbURhdGEgfSBmcm9tICcuLi8uLi92aXN1YWwvaGVscGVyLmpzJztcbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xudmFyIG1hcmtMaW5lVHJhbnNmb3JtID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBjb29yZFN5cywgbWxNb2RlbCwgaXRlbSkge1xuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGl0ZW1BcnJheTtcbiAgaWYgKCFpc0FycmF5KGl0ZW0pKSB7XG4gICAgLy8gU3BlY2lhbCB0eXBlIG1hcmtMaW5lIGxpa2UgJ21pbicsICdtYXgnLCAnYXZlcmFnZScsICdtZWRpYW4nXG4gICAgdmFyIG1sVHlwZSA9IGl0ZW0udHlwZTtcbiAgICBpZiAobWxUeXBlID09PSAnbWluJyB8fCBtbFR5cGUgPT09ICdtYXgnIHx8IG1sVHlwZSA9PT0gJ2F2ZXJhZ2UnIHx8IG1sVHlwZSA9PT0gJ21lZGlhbidcbiAgICAvLyBJbiBjYXNlXG4gICAgLy8gZGF0YTogW3tcbiAgICAvLyAgIHlBeGlzOiAxMFxuICAgIC8vIH1dXG4gICAgfHwgaXRlbS54QXhpcyAhPSBudWxsIHx8IGl0ZW0ueUF4aXMgIT0gbnVsbCkge1xuICAgICAgdmFyIHZhbHVlQXhpcyA9IHZvaWQgMDtcbiAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgIGlmIChpdGVtLnlBeGlzICE9IG51bGwgfHwgaXRlbS54QXhpcyAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoaXRlbS55QXhpcyAhPSBudWxsID8gJ3knIDogJ3gnKTtcbiAgICAgICAgdmFsdWUgPSByZXRyaWV2ZShpdGVtLnlBeGlzLCBpdGVtLnhBeGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBheGlzSW5mbyA9IG1hcmtlckhlbHBlci5nZXRBeGlzSW5mbyhpdGVtLCBkYXRhLCBjb29yZFN5cywgc2VyaWVzTW9kZWwpO1xuICAgICAgICB2YWx1ZUF4aXMgPSBheGlzSW5mby52YWx1ZUF4aXM7XG4gICAgICAgIHZhciB2YWx1ZURhdGFEaW0gPSBnZXRTdGFja2VkRGltZW5zaW9uKGRhdGEsIGF4aXNJbmZvLnZhbHVlRGF0YURpbSk7XG4gICAgICAgIHZhbHVlID0gbWFya2VySGVscGVyLm51bUNhbGN1bGF0ZShkYXRhLCB2YWx1ZURhdGFEaW0sIG1sVHlwZSk7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVJbmRleCA9IHZhbHVlQXhpcy5kaW0gPT09ICd4JyA/IDAgOiAxO1xuICAgICAgdmFyIGJhc2VJbmRleCA9IDEgLSB2YWx1ZUluZGV4O1xuICAgICAgLy8gTm9ybWl6ZWQgdG8gMmQgZGF0YSB3aXRoIHN0YXJ0IGFuZCBlbmQgcG9pbnRcbiAgICAgIHZhciBtbEZyb20gPSBjbG9uZShpdGVtKTtcbiAgICAgIHZhciBtbFRvID0ge1xuICAgICAgICBjb29yZDogW11cbiAgICAgIH07XG4gICAgICBtbEZyb20udHlwZSA9IG51bGw7XG4gICAgICBtbEZyb20uY29vcmQgPSBbXTtcbiAgICAgIG1sRnJvbS5jb29yZFtiYXNlSW5kZXhdID0gLUluZmluaXR5O1xuICAgICAgbWxUby5jb29yZFtiYXNlSW5kZXhdID0gSW5maW5pdHk7XG4gICAgICB2YXIgcHJlY2lzaW9uID0gbWxNb2RlbC5nZXQoJ3ByZWNpc2lvbicpO1xuICAgICAgaWYgKHByZWNpc2lvbiA+PSAwICYmIGlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9ICt2YWx1ZS50b0ZpeGVkKE1hdGgubWluKHByZWNpc2lvbiwgMjApKTtcbiAgICAgIH1cbiAgICAgIG1sRnJvbS5jb29yZFt2YWx1ZUluZGV4XSA9IG1sVG8uY29vcmRbdmFsdWVJbmRleF0gPSB2YWx1ZTtcbiAgICAgIGl0ZW1BcnJheSA9IFttbEZyb20sIG1sVG8sIHtcbiAgICAgICAgdHlwZTogbWxUeXBlLFxuICAgICAgICB2YWx1ZUluZGV4OiBpdGVtLnZhbHVlSW5kZXgsXG4gICAgICAgIC8vIEZvcmNlIHRvIHVzZSB0aGUgdmFsdWUgb2YgY2FsY3VsYXRlZCB2YWx1ZS5cbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW52YWxpZCBkYXRhXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBsb2dFcnJvcignSW52YWxpZCBtYXJrTGluZSBkYXRhLicpO1xuICAgICAgfVxuICAgICAgaXRlbUFycmF5ID0gW107XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGl0ZW1BcnJheSA9IGl0ZW07XG4gIH1cbiAgdmFyIG5vcm1hbGl6ZWRJdGVtID0gW21hcmtlckhlbHBlci5kYXRhVHJhbnNmb3JtKHNlcmllc01vZGVsLCBpdGVtQXJyYXlbMF0pLCBtYXJrZXJIZWxwZXIuZGF0YVRyYW5zZm9ybShzZXJpZXNNb2RlbCwgaXRlbUFycmF5WzFdKSwgZXh0ZW5kKHt9LCBpdGVtQXJyYXlbMl0pXTtcbiAgLy8gQXZvaWQgbGluZSBkYXRhIHR5cGUgaXMgZXh0ZW5kZWQgYnkgZnJvbSh0bykgZGF0YSB0eXBlXG4gIG5vcm1hbGl6ZWRJdGVtWzJdLnR5cGUgPSBub3JtYWxpemVkSXRlbVsyXS50eXBlIHx8IG51bGw7XG4gIC8vIE1lcmdlIGZyb20gb3B0aW9uIGFuZCB0byBvcHRpb24gaW50byBsaW5lIG9wdGlvblxuICBtZXJnZShub3JtYWxpemVkSXRlbVsyXSwgbm9ybWFsaXplZEl0ZW1bMF0pO1xuICBtZXJnZShub3JtYWxpemVkSXRlbVsyXSwgbm9ybWFsaXplZEl0ZW1bMV0pO1xuICByZXR1cm4gbm9ybWFsaXplZEl0ZW07XG59O1xuZnVuY3Rpb24gaXNJbmZpbml0eSh2YWwpIHtcbiAgcmV0dXJuICFpc05hTih2YWwpICYmICFpc0Zpbml0ZSh2YWwpO1xufVxuLy8gSWYgYSBtYXJrTGluZSBoYXMgb25lIGRpbVxuZnVuY3Rpb24gaWZNYXJrTGluZUhhc09ubHlEaW0oZGltSW5kZXgsIGZyb21Db29yZCwgdG9Db29yZCwgY29vcmRTeXMpIHtcbiAgdmFyIG90aGVyRGltSW5kZXggPSAxIC0gZGltSW5kZXg7XG4gIHZhciBkaW1OYW1lID0gY29vcmRTeXMuZGltZW5zaW9uc1tkaW1JbmRleF07XG4gIHJldHVybiBpc0luZmluaXR5KGZyb21Db29yZFtvdGhlckRpbUluZGV4XSkgJiYgaXNJbmZpbml0eSh0b0Nvb3JkW290aGVyRGltSW5kZXhdKSAmJiBmcm9tQ29vcmRbZGltSW5kZXhdID09PSB0b0Nvb3JkW2RpbUluZGV4XSAmJiBjb29yZFN5cy5nZXRBeGlzKGRpbU5hbWUpLmNvbnRhaW5EYXRhKGZyb21Db29yZFtkaW1JbmRleF0pO1xufVxuZnVuY3Rpb24gbWFya0xpbmVGaWx0ZXIoY29vcmRTeXMsIGl0ZW0pIHtcbiAgaWYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICB2YXIgZnJvbUNvb3JkID0gaXRlbVswXS5jb29yZDtcbiAgICB2YXIgdG9Db29yZCA9IGl0ZW1bMV0uY29vcmQ7XG4gICAgLy8gSW4gY2FzZVxuICAgIC8vIHtcbiAgICAvLyAgbWFya0xpbmU6IHtcbiAgICAvLyAgICBkYXRhOiBbeyB5QXhpczogMiB9XVxuICAgIC8vICB9XG4gICAgLy8gfVxuICAgIGlmIChmcm9tQ29vcmQgJiYgdG9Db29yZCAmJiAoaWZNYXJrTGluZUhhc09ubHlEaW0oMSwgZnJvbUNvb3JkLCB0b0Nvb3JkLCBjb29yZFN5cykgfHwgaWZNYXJrTGluZUhhc09ubHlEaW0oMCwgZnJvbUNvb3JkLCB0b0Nvb3JkLCBjb29yZFN5cykpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hcmtlckhlbHBlci5kYXRhRmlsdGVyKGNvb3JkU3lzLCBpdGVtWzBdKSAmJiBtYXJrZXJIZWxwZXIuZGF0YUZpbHRlcihjb29yZFN5cywgaXRlbVsxXSk7XG59XG5mdW5jdGlvbiB1cGRhdGVTaW5nbGVNYXJrZXJFbmRMYXlvdXQoZGF0YSwgaWR4LCBpc0Zyb20sIHNlcmllc01vZGVsLCBhcGkpIHtcbiAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gIHZhciBwb2ludDtcbiAgdmFyIHhQeCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGl0ZW1Nb2RlbC5nZXQoJ3gnKSwgYXBpLmdldFdpZHRoKCkpO1xuICB2YXIgeVB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgneScpLCBhcGkuZ2V0SGVpZ2h0KCkpO1xuICBpZiAoIWlzTmFOKHhQeCkgJiYgIWlzTmFOKHlQeCkpIHtcbiAgICBwb2ludCA9IFt4UHgsIHlQeF07XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hhcnQgbGlrZSBiYXIgbWF5IGhhdmUgdGhlcmUgb3duIG1hcmtlciBwb3NpdGlvbmluZyBsb2dpY1xuICAgIGlmIChzZXJpZXNNb2RlbC5nZXRNYXJrZXJQb3NpdGlvbikge1xuICAgICAgLy8gVXNlIHRoZSBnZXRNYXJrZXJQb3NpdGlvblxuICAgICAgcG9pbnQgPSBzZXJpZXNNb2RlbC5nZXRNYXJrZXJQb3NpdGlvbihkYXRhLmdldFZhbHVlcyhkYXRhLmRpbWVuc2lvbnMsIGlkeCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGltcyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7XG4gICAgICB2YXIgeCA9IGRhdGEuZ2V0KGRpbXNbMF0sIGlkeCk7XG4gICAgICB2YXIgeSA9IGRhdGEuZ2V0KGRpbXNbMV0sIGlkeCk7XG4gICAgICBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KFt4LCB5XSk7XG4gICAgfVxuICAgIC8vIEV4cGFuZCBsaW5lIHRvIHRoZSBlZGdlIG9mIGdyaWQgaWYgdmFsdWUgb24gb25lIGF4aXMgaXMgSW5pZm5pdHlcbiAgICAvLyBJbiBjYXNlXG4gICAgLy8gIG1hcmtMaW5lOiB7XG4gICAgLy8gICAgZGF0YTogW3tcbiAgICAvLyAgICAgIHlBeGlzOiAyXG4gICAgLy8gICAgICAvLyBvclxuICAgIC8vICAgICAgdHlwZTogJ2F2ZXJhZ2UnXG4gICAgLy8gICAgfV1cbiAgICAvLyAgfVxuICAgIGlmIChpc0Nvb3JkaW5hdGVTeXN0ZW1UeXBlKGNvb3JkU3lzLCAnY2FydGVzaWFuMmQnKSkge1xuICAgICAgLy8gVE9ETzogVFlQRSB0c0A0LjEgbWF5IHN0aWxsIGluZmVyIGl0IGFzIEF4aXMgaW5zdGVhZCBvZiBBeGlzMkQuIE5vdCBzdXJlIGlmIGl0J3MgYSBidWdcbiAgICAgIHZhciB4QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3gnKTtcbiAgICAgIHZhciB5QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3knKTtcbiAgICAgIHZhciBkaW1zID0gY29vcmRTeXMuZGltZW5zaW9ucztcbiAgICAgIGlmIChpc0luZmluaXR5KGRhdGEuZ2V0KGRpbXNbMF0sIGlkeCkpKSB7XG4gICAgICAgIHBvaW50WzBdID0geEF4aXMudG9HbG9iYWxDb29yZCh4QXhpcy5nZXRFeHRlbnQoKVtpc0Zyb20gPyAwIDogMV0pO1xuICAgICAgfSBlbHNlIGlmIChpc0luZmluaXR5KGRhdGEuZ2V0KGRpbXNbMV0sIGlkeCkpKSB7XG4gICAgICAgIHBvaW50WzFdID0geUF4aXMudG9HbG9iYWxDb29yZCh5QXhpcy5nZXRFeHRlbnQoKVtpc0Zyb20gPyAwIDogMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2UgeCwgeSBpZiBoYXMgYW55XG4gICAgaWYgKCFpc05hTih4UHgpKSB7XG4gICAgICBwb2ludFswXSA9IHhQeDtcbiAgICB9XG4gICAgaWYgKCFpc05hTih5UHgpKSB7XG4gICAgICBwb2ludFsxXSA9IHlQeDtcbiAgICB9XG4gIH1cbiAgZGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwgcG9pbnQpO1xufVxudmFyIE1hcmtMaW5lVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNYXJrTGluZVZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIE1hcmtMaW5lVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gTWFya0xpbmVWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIE1hcmtMaW5lVmlldy5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKG1hcmtMaW5lTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHZhciBtbE1vZGVsID0gTWFya2VyTW9kZWwuZ2V0TWFya2VyTW9kZWxGcm9tU2VyaWVzKHNlcmllc01vZGVsLCAnbWFya0xpbmUnKTtcbiAgICAgIGlmIChtbE1vZGVsKSB7XG4gICAgICAgIHZhciBtbERhdGFfMSA9IG1sTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgZnJvbURhdGFfMSA9IGlubmVyKG1sTW9kZWwpLmZyb207XG4gICAgICAgIHZhciB0b0RhdGFfMSA9IGlubmVyKG1sTW9kZWwpLnRvO1xuICAgICAgICAvLyBVcGRhdGUgdmlzdWFsIGFuZCBsYXlvdXQgb2YgZnJvbSBzeW1ib2wgYW5kIHRvIHN5bWJvbFxuICAgICAgICBmcm9tRGF0YV8xLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgIHVwZGF0ZVNpbmdsZU1hcmtlckVuZExheW91dChmcm9tRGF0YV8xLCBpZHgsIHRydWUsIHNlcmllc01vZGVsLCBhcGkpO1xuICAgICAgICAgIHVwZGF0ZVNpbmdsZU1hcmtlckVuZExheW91dCh0b0RhdGFfMSwgaWR4LCBmYWxzZSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBVcGRhdGUgbGF5b3V0IG9mIGxpbmVcbiAgICAgICAgbWxEYXRhXzEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgbWxEYXRhXzEuc2V0SXRlbUxheW91dChpZHgsIFtmcm9tRGF0YV8xLmdldEl0ZW1MYXlvdXQoaWR4KSwgdG9EYXRhXzEuZ2V0SXRlbUxheW91dChpZHgpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcmtlckdyb3VwTWFwLmdldChzZXJpZXNNb2RlbC5pZCkudXBkYXRlTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIE1hcmtMaW5lVmlldy5wcm90b3R5cGUucmVuZGVyU2VyaWVzID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBtbE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBzZXJpZXNJZCA9IHNlcmllc01vZGVsLmlkO1xuICAgIHZhciBzZXJpZXNEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBsaW5lRHJhd01hcCA9IHRoaXMubWFya2VyR3JvdXBNYXA7XG4gICAgdmFyIGxpbmVEcmF3ID0gbGluZURyYXdNYXAuZ2V0KHNlcmllc0lkKSB8fCBsaW5lRHJhd01hcC5zZXQoc2VyaWVzSWQsIG5ldyBMaW5lRHJhdygpKTtcbiAgICB0aGlzLmdyb3VwLmFkZChsaW5lRHJhdy5ncm91cCk7XG4gICAgdmFyIG1sRGF0YSA9IGNyZWF0ZUxpc3QoY29vcmRTeXMsIHNlcmllc01vZGVsLCBtbE1vZGVsKTtcbiAgICB2YXIgZnJvbURhdGEgPSBtbERhdGEuZnJvbTtcbiAgICB2YXIgdG9EYXRhID0gbWxEYXRhLnRvO1xuICAgIHZhciBsaW5lRGF0YSA9IG1sRGF0YS5saW5lO1xuICAgIGlubmVyKG1sTW9kZWwpLmZyb20gPSBmcm9tRGF0YTtcbiAgICBpbm5lcihtbE1vZGVsKS50byA9IHRvRGF0YTtcbiAgICAvLyBMaW5lIGRhdGEgZm9yIHRvb2x0aXAgYW5kIGZvcm1hdHRlclxuICAgIG1sTW9kZWwuc2V0RGF0YShsaW5lRGF0YSk7XG4gICAgLy8gVE9ET1xuICAgIC8vIEZ1bmN0aW9uYWxseSwgYHN5bWJvbFNpemVgICYgYHN5bWJvbE9mZnNldGAgY2FuIGFsc28gYmUgMkQgYXJyYXkgbm93LlxuICAgIC8vIEJ1dCB0aGUgcmVsYXRlZCBsb2dpYyBhbmQgdHlwZSBkZWZpbml0aW9uIGFyZSBub3QgZmluaXNoZWQgeWV0LlxuICAgIC8vIEZpbmlzaCBpdCBpZiByZXF1aXJlZFxuICAgIHZhciBzeW1ib2xUeXBlID0gbWxNb2RlbC5nZXQoJ3N5bWJvbCcpO1xuICAgIHZhciBzeW1ib2xTaXplID0gbWxNb2RlbC5nZXQoJ3N5bWJvbFNpemUnKTtcbiAgICB2YXIgc3ltYm9sUm90YXRlID0gbWxNb2RlbC5nZXQoJ3N5bWJvbFJvdGF0ZScpO1xuICAgIHZhciBzeW1ib2xPZmZzZXQgPSBtbE1vZGVsLmdldCgnc3ltYm9sT2Zmc2V0Jyk7XG4gICAgLy8gVE9ETzogc3VwcG9ydCBjYWxsYmFjayBmdW5jdGlvbiBsaWtlIG1hcmtQb2ludFxuICAgIGlmICghaXNBcnJheShzeW1ib2xUeXBlKSkge1xuICAgICAgc3ltYm9sVHlwZSA9IFtzeW1ib2xUeXBlLCBzeW1ib2xUeXBlXTtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5KHN5bWJvbFNpemUpKSB7XG4gICAgICBzeW1ib2xTaXplID0gW3N5bWJvbFNpemUsIHN5bWJvbFNpemVdO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXkoc3ltYm9sUm90YXRlKSkge1xuICAgICAgc3ltYm9sUm90YXRlID0gW3N5bWJvbFJvdGF0ZSwgc3ltYm9sUm90YXRlXTtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5KHN5bWJvbE9mZnNldCkpIHtcbiAgICAgIHN5bWJvbE9mZnNldCA9IFtzeW1ib2xPZmZzZXQsIHN5bWJvbE9mZnNldF07XG4gICAgfVxuICAgIC8vIFVwZGF0ZSB2aXN1YWwgYW5kIGxheW91dCBvZiBmcm9tIHN5bWJvbCBhbmQgdG8gc3ltYm9sXG4gICAgbWxEYXRhLmZyb20uZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB1cGRhdGVEYXRhVmlzdWFsQW5kTGF5b3V0KGZyb21EYXRhLCBpZHgsIHRydWUpO1xuICAgICAgdXBkYXRlRGF0YVZpc3VhbEFuZExheW91dCh0b0RhdGEsIGlkeCwgZmFsc2UpO1xuICAgIH0pO1xuICAgIC8vIFVwZGF0ZSB2aXN1YWwgYW5kIGxheW91dCBvZiBsaW5lXG4gICAgbGluZURhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgbGluZVN0eWxlID0gbGluZURhdGEuZ2V0SXRlbU1vZGVsKGlkeCkuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpO1xuICAgICAgLy8gbGluZURhdGEuc2V0SXRlbVZpc3VhbChpZHgsIHtcbiAgICAgIC8vICAgICBjb2xvcjogbGluZUNvbG9yIHx8IGZyb21EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKVxuICAgICAgLy8gfSk7XG4gICAgICBsaW5lRGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwgW2Zyb21EYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSwgdG9EYXRhLmdldEl0ZW1MYXlvdXQoaWR4KV0pO1xuICAgICAgaWYgKGxpbmVTdHlsZS5zdHJva2UgPT0gbnVsbCkge1xuICAgICAgICBsaW5lU3R5bGUuc3Ryb2tlID0gZnJvbURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzdHlsZScpLmZpbGw7XG4gICAgICB9XG4gICAgICBsaW5lRGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwge1xuICAgICAgICBmcm9tU3ltYm9sS2VlcEFzcGVjdDogZnJvbURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xLZWVwQXNwZWN0JyksXG4gICAgICAgIGZyb21TeW1ib2xPZmZzZXQ6IGZyb21EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sT2Zmc2V0JyksXG4gICAgICAgIGZyb21TeW1ib2xSb3RhdGU6IGZyb21EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sUm90YXRlJyksXG4gICAgICAgIGZyb21TeW1ib2xTaXplOiBmcm9tRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFNpemUnKSxcbiAgICAgICAgZnJvbVN5bWJvbDogZnJvbURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSxcbiAgICAgICAgdG9TeW1ib2xLZWVwQXNwZWN0OiB0b0RhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xLZWVwQXNwZWN0JyksXG4gICAgICAgIHRvU3ltYm9sT2Zmc2V0OiB0b0RhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xPZmZzZXQnKSxcbiAgICAgICAgdG9TeW1ib2xSb3RhdGU6IHRvRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFJvdGF0ZScpLFxuICAgICAgICB0b1N5bWJvbFNpemU6IHRvRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFNpemUnKSxcbiAgICAgICAgdG9TeW1ib2w6IHRvRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbCcpLFxuICAgICAgICBzdHlsZTogbGluZVN0eWxlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBsaW5lRHJhdy51cGRhdGVEYXRhKGxpbmVEYXRhKTtcbiAgICAvLyBTZXQgaG9zdCBtb2RlbCBmb3IgdG9vbHRpcFxuICAgIC8vIEZJWE1FXG4gICAgbWxEYXRhLmxpbmUuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICBnZXRFQ0RhdGEoZWwpLmRhdGFNb2RlbCA9IG1sTW9kZWw7XG4gICAgICBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgZ2V0RUNEYXRhKGNoaWxkKS5kYXRhTW9kZWwgPSBtbE1vZGVsO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gdXBkYXRlRGF0YVZpc3VhbEFuZExheW91dChkYXRhLCBpZHgsIGlzRnJvbSkge1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICB1cGRhdGVTaW5nbGVNYXJrZXJFbmRMYXlvdXQoZGF0YSwgaWR4LCBpc0Zyb20sIHNlcmllc01vZGVsLCBhcGkpO1xuICAgICAgdmFyIHN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgIGlmIChzdHlsZS5maWxsID09IG51bGwpIHtcbiAgICAgICAgc3R5bGUuZmlsbCA9IGdldFZpc3VhbEZyb21EYXRhKHNlcmllc0RhdGEsICdjb2xvcicpO1xuICAgICAgfVxuICAgICAgZGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwge1xuICAgICAgICBzeW1ib2xLZWVwQXNwZWN0OiBpdGVtTW9kZWwuZ2V0KCdzeW1ib2xLZWVwQXNwZWN0JyksXG4gICAgICAgIC8vIGAwYCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBhIHZhbGlkIHZhbHVlLCBzbyB1c2UgYHJldHJpZXZlMmAgaW5zdGVhZCBvZiBgfHxgXG4gICAgICAgIHN5bWJvbE9mZnNldDogcmV0cmlldmUyKGl0ZW1Nb2RlbC5nZXQoJ3N5bWJvbE9mZnNldCcsIHRydWUpLCBzeW1ib2xPZmZzZXRbaXNGcm9tID8gMCA6IDFdKSxcbiAgICAgICAgc3ltYm9sUm90YXRlOiByZXRyaWV2ZTIoaXRlbU1vZGVsLmdldCgnc3ltYm9sUm90YXRlJywgdHJ1ZSksIHN5bWJvbFJvdGF0ZVtpc0Zyb20gPyAwIDogMV0pLFxuICAgICAgICAvLyBUT0RPOiB3aGVuIDJkIGFycmF5IGlzIHN1cHBvcnRlZCwgaXQgc2hvdWxkIGlnbm9yZSBwYXJlbnRcbiAgICAgICAgc3ltYm9sU2l6ZTogcmV0cmlldmUyKGl0ZW1Nb2RlbC5nZXQoJ3N5bWJvbFNpemUnKSwgc3ltYm9sU2l6ZVtpc0Zyb20gPyAwIDogMV0pLFxuICAgICAgICBzeW1ib2w6IHJldHJpZXZlMihpdGVtTW9kZWwuZ2V0KCdzeW1ib2wnLCB0cnVlKSwgc3ltYm9sVHlwZVtpc0Zyb20gPyAwIDogMV0pLFxuICAgICAgICBzdHlsZTogc3R5bGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLm1hcmtLZWVwKGxpbmVEcmF3KTtcbiAgICBsaW5lRHJhdy5ncm91cC5zaWxlbnQgPSBtbE1vZGVsLmdldCgnc2lsZW50JykgfHwgc2VyaWVzTW9kZWwuZ2V0KCdzaWxlbnQnKTtcbiAgfTtcbiAgTWFya0xpbmVWaWV3LnR5cGUgPSAnbWFya0xpbmUnO1xuICByZXR1cm4gTWFya0xpbmVWaWV3O1xufShNYXJrZXJWaWV3KTtcbmZ1bmN0aW9uIGNyZWF0ZUxpc3QoY29vcmRTeXMsIHNlcmllc01vZGVsLCBtbE1vZGVsKSB7XG4gIHZhciBjb29yZERpbXNJbmZvcztcbiAgaWYgKGNvb3JkU3lzKSB7XG4gICAgY29vcmREaW1zSW5mb3MgPSBtYXAoY29vcmRTeXMgJiYgY29vcmRTeXMuZGltZW5zaW9ucywgZnVuY3Rpb24gKGNvb3JkRGltKSB7XG4gICAgICB2YXIgaW5mbyA9IHNlcmllc01vZGVsLmdldERhdGEoKS5nZXREaW1lbnNpb25JbmZvKHNlcmllc01vZGVsLmdldERhdGEoKS5tYXBEaW1lbnNpb24oY29vcmREaW0pKSB8fCB7fTtcbiAgICAgIC8vIEluIG1hcCBzZXJpZXMgZGF0YSBkb24ndCBoYXZlIGxuZyBhbmQgbGF0IGRpbWVuc2lvbi4gRmFsbGJhY2sgdG8gc2FtZSB3aXRoIGNvb3JkU3lzXG4gICAgICByZXR1cm4gZXh0ZW5kKGV4dGVuZCh7fSwgaW5mbyksIHtcbiAgICAgICAgbmFtZTogY29vcmREaW0sXG4gICAgICAgIC8vIERPTidUIHVzZSBvcmRpbmFsTWV0YSB0byBwYXJzZSBhbmQgY29sbGVjdCBvcmRpbmFsLlxuICAgICAgICBvcmRpbmFsTWV0YTogbnVsbFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29vcmREaW1zSW5mb3MgPSBbe1xuICAgICAgbmFtZTogJ3ZhbHVlJyxcbiAgICAgIHR5cGU6ICdmbG9hdCdcbiAgICB9XTtcbiAgfVxuICB2YXIgZnJvbURhdGEgPSBuZXcgU2VyaWVzRGF0YShjb29yZERpbXNJbmZvcywgbWxNb2RlbCk7XG4gIHZhciB0b0RhdGEgPSBuZXcgU2VyaWVzRGF0YShjb29yZERpbXNJbmZvcywgbWxNb2RlbCk7XG4gIC8vIE5vIGRpbWVuc2lvbnNcbiAgdmFyIGxpbmVEYXRhID0gbmV3IFNlcmllc0RhdGEoW10sIG1sTW9kZWwpO1xuICB2YXIgb3B0RGF0YSA9IG1hcChtbE1vZGVsLmdldCgnZGF0YScpLCBjdXJyeShtYXJrTGluZVRyYW5zZm9ybSwgc2VyaWVzTW9kZWwsIGNvb3JkU3lzLCBtbE1vZGVsKSk7XG4gIGlmIChjb29yZFN5cykge1xuICAgIG9wdERhdGEgPSBmaWx0ZXIob3B0RGF0YSwgY3VycnkobWFya0xpbmVGaWx0ZXIsIGNvb3JkU3lzKSk7XG4gIH1cbiAgdmFyIGRpbVZhbHVlR2V0dGVyID0gbWFya2VySGVscGVyLmNyZWF0ZU1hcmtlckRpbVZhbHVlR2V0dGVyKCEhY29vcmRTeXMsIGNvb3JkRGltc0luZm9zKTtcbiAgZnJvbURhdGEuaW5pdERhdGEobWFwKG9wdERhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1bMF07XG4gIH0pLCBudWxsLCBkaW1WYWx1ZUdldHRlcik7XG4gIHRvRGF0YS5pbml0RGF0YShtYXAob3B0RGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbVsxXTtcbiAgfSksIG51bGwsIGRpbVZhbHVlR2V0dGVyKTtcbiAgbGluZURhdGEuaW5pdERhdGEobWFwKG9wdERhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1bMl07XG4gIH0pKTtcbiAgbGluZURhdGEuaGFzSXRlbU9wdGlvbiA9IHRydWU7XG4gIHJldHVybiB7XG4gICAgZnJvbTogZnJvbURhdGEsXG4gICAgdG86IHRvRGF0YSxcbiAgICBsaW5lOiBsaW5lRGF0YVxuICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgTWFya0xpbmVWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG5pbXBvcnQgY2hlY2tNYXJrZXJJblNlcmllcyBmcm9tICcuL2NoZWNrTWFya2VySW5TZXJpZXMuanMnO1xuaW1wb3J0IE1hcmtMaW5lTW9kZWwgZnJvbSAnLi9NYXJrTGluZU1vZGVsLmpzJztcbmltcG9ydCBNYXJrTGluZVZpZXcgZnJvbSAnLi9NYXJrTGluZVZpZXcuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKE1hcmtMaW5lTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KE1hcmtMaW5lVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0KSB7XG4gICAgaWYgKGNoZWNrTWFya2VySW5TZXJpZXMob3B0LnNlcmllcywgJ21hcmtMaW5lJykpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSBtYXJrTGluZSBjb21wb25lbnQgaXMgZW5hYmxlZFxuICAgICAgb3B0Lm1hcmtMaW5lID0gb3B0Lm1hcmtMaW5lIHx8IHt9O1xuICAgIH1cbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///42998\n")},46105:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/parallel/parallelPreprocessor.js\nvar parallelPreprocessor = __webpack_require__(78308);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar Component = __webpack_require__(59109);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/throttle.js\nvar throttle = __webpack_require__(24711);\n;// ./node_modules/echarts/lib/component/parallel/ParallelView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar CLICK_THRESHOLD = 5; // > 4\nvar ParallelView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ParallelView, _super);\n  function ParallelView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ParallelView.type;\n    return _this;\n  }\n  ParallelView.prototype.render = function (parallelModel, ecModel, api) {\n    this._model = parallelModel;\n    this._api = api;\n    if (!this._handlers) {\n      this._handlers = {};\n      (0,util.each)(handlers, function (handler, eventName) {\n        api.getZr().on(eventName, this._handlers[eventName] = (0,util.bind)(handler, this));\n      }, this);\n    }\n    (0,throttle/* createOrUpdate */.N)(this, '_throttledDispatchExpand', parallelModel.get('axisExpandRate'), 'fixRate');\n  };\n  ParallelView.prototype.dispose = function (ecModel, api) {\n    (0,throttle/* clear */.IU)(this, '_throttledDispatchExpand');\n    (0,util.each)(this._handlers, function (handler, eventName) {\n      api.getZr().off(eventName, handler);\n    });\n    this._handlers = null;\n  };\n  /**\r\n   * @internal\r\n   * @param {Object} [opt] If null, cancel the last action triggering for debounce.\r\n   */\n  ParallelView.prototype._throttledDispatchExpand = function (opt) {\n    this._dispatchExpand(opt);\n  };\n  /**\r\n   * @internal\r\n   */\n  ParallelView.prototype._dispatchExpand = function (opt) {\n    opt && this._api.dispatchAction((0,util.extend)({\n      type: 'parallelAxisExpand'\n    }, opt));\n  };\n  ParallelView.type = 'parallel';\n  return ParallelView;\n}(Component/* default */.A);\nvar handlers = {\n  mousedown: function (e) {\n    if (checkTrigger(this, 'click')) {\n      this._mouseDownPoint = [e.offsetX, e.offsetY];\n    }\n  },\n  mouseup: function (e) {\n    var mouseDownPoint = this._mouseDownPoint;\n    if (checkTrigger(this, 'click') && mouseDownPoint) {\n      var point = [e.offsetX, e.offsetY];\n      var dist = Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2);\n      if (dist > CLICK_THRESHOLD) {\n        return;\n      }\n      var result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]);\n      result.behavior !== 'none' && this._dispatchExpand({\n        axisExpandWindow: result.axisExpandWindow\n      });\n    }\n    this._mouseDownPoint = null;\n  },\n  mousemove: function (e) {\n    // Should do nothing when brushing.\n    if (this._mouseDownPoint || !checkTrigger(this, 'mousemove')) {\n      return;\n    }\n    var model = this._model;\n    var result = model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]);\n    var behavior = result.behavior;\n    behavior === 'jump' && this._throttledDispatchExpand.debounceNextCall(model.get('axisExpandDebounce'));\n    this._throttledDispatchExpand(behavior === 'none' ? null // Cancel the last trigger, in case that mouse slide out of the area quickly.\n    : {\n      axisExpandWindow: result.axisExpandWindow,\n      // Jumping uses animation, and sliding suppresses animation.\n      animation: behavior === 'jump' ? null : {\n        duration: 0 // Disable animation.\n      }\n    });\n  }\n};\nfunction checkTrigger(view, triggerOn) {\n  var model = view._model;\n  return model.get('axisExpandable') && model.get('axisExpandTriggerOn') === triggerOn;\n}\n/* harmony default export */ const parallel_ParallelView = (ParallelView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/parallel/ParallelModel.js\nvar ParallelModel = __webpack_require__(24130);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/parallel/parallelCreator.js + 2 modules\nvar parallelCreator = __webpack_require__(42744);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/axisModelCreator.js + 1 modules\nvar axisModelCreator = __webpack_require__(59470);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/parallel/AxisModel.js\nvar AxisModel = __webpack_require__(61504);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axis/ParallelAxisView.js\nvar ParallelAxisView = __webpack_require__(60755);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axis/parallelAxisAction.js\nvar parallelAxisAction = __webpack_require__(68520);\n;// ./node_modules/echarts/lib/component/parallel/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nvar defaultAxisOption = {\n  type: 'value',\n  areaSelectStyle: {\n    width: 20,\n    borderWidth: 1,\n    borderColor: 'rgba(160,197,232)',\n    color: 'rgba(160,197,232)',\n    opacity: 0.3\n  },\n  realtime: true,\n  z: 10\n};\nfunction install(registers) {\n  registers.registerComponentView(parallel_ParallelView);\n  registers.registerComponentModel(ParallelModel/* default */.A);\n  registers.registerCoordinateSystem('parallel', parallelCreator/* default */.A);\n  registers.registerPreprocessor(parallelPreprocessor/* default */.A);\n  registers.registerComponentModel(AxisModel/* default */.A);\n  registers.registerComponentView(ParallelAxisView/* default */.A);\n  (0,axisModelCreator/* default */.A)(registers, 'parallel', AxisModel/* default */.A, defaultAxisOption);\n  (0,parallelAxisAction/* installParallelActions */.o)(registers);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYxMDUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3BhcmFsbGVsL1BhcmFsbGVsVmlldy5qcz9jZTY4Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvcGFyYWxsZWwvaW5zdGFsbC5qcz82YjRhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQ29tcG9uZW50VmlldyBmcm9tICcuLi8uLi92aWV3L0NvbXBvbmVudC5qcyc7XG5pbXBvcnQgeyBlYWNoLCBiaW5kLCBleHRlbmQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgY3JlYXRlT3JVcGRhdGUsIGNsZWFyIH0gZnJvbSAnLi4vLi4vdXRpbC90aHJvdHRsZS5qcyc7XG52YXIgQ0xJQ0tfVEhSRVNIT0xEID0gNTsgLy8gPiA0XG52YXIgUGFyYWxsZWxWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBhcmFsbGVsVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gUGFyYWxsZWxWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBQYXJhbGxlbFZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgUGFyYWxsZWxWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocGFyYWxsZWxNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5fbW9kZWwgPSBwYXJhbGxlbE1vZGVsO1xuICAgIHRoaXMuX2FwaSA9IGFwaTtcbiAgICBpZiAoIXRoaXMuX2hhbmRsZXJzKSB7XG4gICAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuICAgICAgZWFjaChoYW5kbGVycywgZnVuY3Rpb24gKGhhbmRsZXIsIGV2ZW50TmFtZSkge1xuICAgICAgICBhcGkuZ2V0WnIoKS5vbihldmVudE5hbWUsIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0gPSBiaW5kKGhhbmRsZXIsIHRoaXMpKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBjcmVhdGVPclVwZGF0ZSh0aGlzLCAnX3Rocm90dGxlZERpc3BhdGNoRXhwYW5kJywgcGFyYWxsZWxNb2RlbC5nZXQoJ2F4aXNFeHBhbmRSYXRlJyksICdmaXhSYXRlJyk7XG4gIH07XG4gIFBhcmFsbGVsVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBjbGVhcih0aGlzLCAnX3Rocm90dGxlZERpc3BhdGNoRXhwYW5kJyk7XG4gICAgZWFjaCh0aGlzLl9oYW5kbGVycywgZnVuY3Rpb24gKGhhbmRsZXIsIGV2ZW50TmFtZSkge1xuICAgICAgYXBpLmdldFpyKCkub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfSk7XG4gICAgdGhpcy5faGFuZGxlcnMgPSBudWxsO1xuICB9O1xuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdF0gSWYgbnVsbCwgY2FuY2VsIHRoZSBsYXN0IGFjdGlvbiB0cmlnZ2VyaW5nIGZvciBkZWJvdW5jZS5cclxuICAgKi9cbiAgUGFyYWxsZWxWaWV3LnByb3RvdHlwZS5fdGhyb3R0bGVkRGlzcGF0Y2hFeHBhbmQgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgdGhpcy5fZGlzcGF0Y2hFeHBhbmQob3B0KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG4gIFBhcmFsbGVsVmlldy5wcm90b3R5cGUuX2Rpc3BhdGNoRXhwYW5kID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIG9wdCAmJiB0aGlzLl9hcGkuZGlzcGF0Y2hBY3Rpb24oZXh0ZW5kKHtcbiAgICAgIHR5cGU6ICdwYXJhbGxlbEF4aXNFeHBhbmQnXG4gICAgfSwgb3B0KSk7XG4gIH07XG4gIFBhcmFsbGVsVmlldy50eXBlID0gJ3BhcmFsbGVsJztcbiAgcmV0dXJuIFBhcmFsbGVsVmlldztcbn0oQ29tcG9uZW50Vmlldyk7XG52YXIgaGFuZGxlcnMgPSB7XG4gIG1vdXNlZG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoY2hlY2tUcmlnZ2VyKHRoaXMsICdjbGljaycpKSB7XG4gICAgICB0aGlzLl9tb3VzZURvd25Qb2ludCA9IFtlLm9mZnNldFgsIGUub2Zmc2V0WV07XG4gICAgfVxuICB9LFxuICBtb3VzZXVwOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZURvd25Qb2ludCA9IHRoaXMuX21vdXNlRG93blBvaW50O1xuICAgIGlmIChjaGVja1RyaWdnZXIodGhpcywgJ2NsaWNrJykgJiYgbW91c2VEb3duUG9pbnQpIHtcbiAgICAgIHZhciBwb2ludCA9IFtlLm9mZnNldFgsIGUub2Zmc2V0WV07XG4gICAgICB2YXIgZGlzdCA9IE1hdGgucG93KG1vdXNlRG93blBvaW50WzBdIC0gcG9pbnRbMF0sIDIpICsgTWF0aC5wb3cobW91c2VEb3duUG9pbnRbMV0gLSBwb2ludFsxXSwgMik7XG4gICAgICBpZiAoZGlzdCA+IENMSUNLX1RIUkVTSE9MRCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fbW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRTbGlkZWRBeGlzRXhwYW5kV2luZG93KFtlLm9mZnNldFgsIGUub2Zmc2V0WV0pO1xuICAgICAgcmVzdWx0LmJlaGF2aW9yICE9PSAnbm9uZScgJiYgdGhpcy5fZGlzcGF0Y2hFeHBhbmQoe1xuICAgICAgICBheGlzRXhwYW5kV2luZG93OiByZXN1bHQuYXhpc0V4cGFuZFdpbmRvd1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX21vdXNlRG93blBvaW50ID0gbnVsbDtcbiAgfSxcbiAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgIC8vIFNob3VsZCBkbyBub3RoaW5nIHdoZW4gYnJ1c2hpbmcuXG4gICAgaWYgKHRoaXMuX21vdXNlRG93blBvaW50IHx8ICFjaGVja1RyaWdnZXIodGhpcywgJ21vdXNlbW92ZScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBtb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgIHZhciByZXN1bHQgPSBtb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFNsaWRlZEF4aXNFeHBhbmRXaW5kb3coW2Uub2Zmc2V0WCwgZS5vZmZzZXRZXSk7XG4gICAgdmFyIGJlaGF2aW9yID0gcmVzdWx0LmJlaGF2aW9yO1xuICAgIGJlaGF2aW9yID09PSAnanVtcCcgJiYgdGhpcy5fdGhyb3R0bGVkRGlzcGF0Y2hFeHBhbmQuZGVib3VuY2VOZXh0Q2FsbChtb2RlbC5nZXQoJ2F4aXNFeHBhbmREZWJvdW5jZScpKTtcbiAgICB0aGlzLl90aHJvdHRsZWREaXNwYXRjaEV4cGFuZChiZWhhdmlvciA9PT0gJ25vbmUnID8gbnVsbCAvLyBDYW5jZWwgdGhlIGxhc3QgdHJpZ2dlciwgaW4gY2FzZSB0aGF0IG1vdXNlIHNsaWRlIG91dCBvZiB0aGUgYXJlYSBxdWlja2x5LlxuICAgIDoge1xuICAgICAgYXhpc0V4cGFuZFdpbmRvdzogcmVzdWx0LmF4aXNFeHBhbmRXaW5kb3csXG4gICAgICAvLyBKdW1waW5nIHVzZXMgYW5pbWF0aW9uLCBhbmQgc2xpZGluZyBzdXBwcmVzc2VzIGFuaW1hdGlvbi5cbiAgICAgIGFuaW1hdGlvbjogYmVoYXZpb3IgPT09ICdqdW1wJyA/IG51bGwgOiB7XG4gICAgICAgIGR1cmF0aW9uOiAwIC8vIERpc2FibGUgYW5pbWF0aW9uLlxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gY2hlY2tUcmlnZ2VyKHZpZXcsIHRyaWdnZXJPbikge1xuICB2YXIgbW9kZWwgPSB2aWV3Ll9tb2RlbDtcbiAgcmV0dXJuIG1vZGVsLmdldCgnYXhpc0V4cGFuZGFibGUnKSAmJiBtb2RlbC5nZXQoJ2F4aXNFeHBhbmRUcmlnZ2VyT24nKSA9PT0gdHJpZ2dlck9uO1xufVxuZXhwb3J0IGRlZmF1bHQgUGFyYWxsZWxWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHBhcmFsbGVsUHJlcHJvY2Vzc29yIGZyb20gJy4uLy4uL2Nvb3JkL3BhcmFsbGVsL3BhcmFsbGVsUHJlcHJvY2Vzc29yLmpzJztcbmltcG9ydCBQYXJhbGxlbFZpZXcgZnJvbSAnLi9QYXJhbGxlbFZpZXcuanMnO1xuaW1wb3J0IFBhcmFsbGVsTW9kZWwgZnJvbSAnLi4vLi4vY29vcmQvcGFyYWxsZWwvUGFyYWxsZWxNb2RlbC5qcyc7XG5pbXBvcnQgcGFyYWxsZWxDb29yZFN5c0NyZWF0b3IgZnJvbSAnLi4vLi4vY29vcmQvcGFyYWxsZWwvcGFyYWxsZWxDcmVhdG9yLmpzJztcbmltcG9ydCBheGlzTW9kZWxDcmVhdG9yIGZyb20gJy4uLy4uL2Nvb3JkL2F4aXNNb2RlbENyZWF0b3IuanMnO1xuaW1wb3J0IFBhcmFsbGVsQXhpc01vZGVsIGZyb20gJy4uLy4uL2Nvb3JkL3BhcmFsbGVsL0F4aXNNb2RlbC5qcyc7XG5pbXBvcnQgUGFyYWxsZWxBeGlzVmlldyBmcm9tICcuLi9heGlzL1BhcmFsbGVsQXhpc1ZpZXcuanMnO1xuaW1wb3J0IHsgaW5zdGFsbFBhcmFsbGVsQWN0aW9ucyB9IGZyb20gJy4uL2F4aXMvcGFyYWxsZWxBeGlzQWN0aW9uLmpzJztcbnZhciBkZWZhdWx0QXhpc09wdGlvbiA9IHtcbiAgdHlwZTogJ3ZhbHVlJyxcbiAgYXJlYVNlbGVjdFN0eWxlOiB7XG4gICAgd2lkdGg6IDIwLFxuICAgIGJvcmRlcldpZHRoOiAxLFxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgxNjAsMTk3LDIzMiknLFxuICAgIGNvbG9yOiAncmdiYSgxNjAsMTk3LDIzMiknLFxuICAgIG9wYWNpdHk6IDAuM1xuICB9LFxuICByZWFsdGltZTogdHJ1ZSxcbiAgejogMTBcbn07XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhQYXJhbGxlbFZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChQYXJhbGxlbE1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29vcmRpbmF0ZVN5c3RlbSgncGFyYWxsZWwnLCBwYXJhbGxlbENvb3JkU3lzQ3JlYXRvcik7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByZXByb2Nlc3NvcihwYXJhbGxlbFByZXByb2Nlc3Nvcik7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKFBhcmFsbGVsQXhpc01vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhQYXJhbGxlbEF4aXNWaWV3KTtcbiAgYXhpc01vZGVsQ3JlYXRvcihyZWdpc3RlcnMsICdwYXJhbGxlbCcsIFBhcmFsbGVsQXhpc01vZGVsLCBkZWZhdWx0QXhpc09wdGlvbik7XG4gIGluc3RhbGxQYXJhbGxlbEFjdGlvbnMocmVnaXN0ZXJzKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///46105\n")},56366:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   t: () => (/* binding */ updateViewOnPan),\n/* harmony export */   x: () => (/* binding */ updateViewOnZoom)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * For geo and graph.\r\n */\nfunction updateViewOnPan(controllerHost, dx, dy) {\n  var target = controllerHost.target;\n  target.x += dx;\n  target.y += dy;\n  target.dirty();\n}\n/**\r\n * For geo and graph.\r\n */\nfunction updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {\n  var target = controllerHost.target;\n  var zoomLimit = controllerHost.zoomLimit;\n  var newZoom = controllerHost.zoom = controllerHost.zoom || 1;\n  newZoom *= zoomDelta;\n  if (zoomLimit) {\n    var zoomMin = zoomLimit.min || 0;\n    var zoomMax = zoomLimit.max || Infinity;\n    newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);\n  }\n  var zoomScale = newZoom / controllerHost.zoom;\n  controllerHost.zoom = newZoom;\n  // Keep the mouse center when scaling\n  target.x -= (zoomX - target.x) * (zoomScale - 1);\n  target.y -= (zoomY - target.y) * (zoomScale - 1);\n  target.scaleX *= zoomScale;\n  target.scaleY *= zoomScale;\n  target.dirty();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYzNjYuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9yb2FtSGVscGVyLmpzP2FiNTciXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG4vKipcclxuICogRm9yIGdlbyBhbmQgZ3JhcGguXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVZpZXdPblBhbihjb250cm9sbGVySG9zdCwgZHgsIGR5KSB7XG4gIHZhciB0YXJnZXQgPSBjb250cm9sbGVySG9zdC50YXJnZXQ7XG4gIHRhcmdldC54ICs9IGR4O1xuICB0YXJnZXQueSArPSBkeTtcbiAgdGFyZ2V0LmRpcnR5KCk7XG59XG4vKipcclxuICogRm9yIGdlbyBhbmQgZ3JhcGguXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVZpZXdPblpvb20oY29udHJvbGxlckhvc3QsIHpvb21EZWx0YSwgem9vbVgsIHpvb21ZKSB7XG4gIHZhciB0YXJnZXQgPSBjb250cm9sbGVySG9zdC50YXJnZXQ7XG4gIHZhciB6b29tTGltaXQgPSBjb250cm9sbGVySG9zdC56b29tTGltaXQ7XG4gIHZhciBuZXdab29tID0gY29udHJvbGxlckhvc3Quem9vbSA9IGNvbnRyb2xsZXJIb3N0Lnpvb20gfHwgMTtcbiAgbmV3Wm9vbSAqPSB6b29tRGVsdGE7XG4gIGlmICh6b29tTGltaXQpIHtcbiAgICB2YXIgem9vbU1pbiA9IHpvb21MaW1pdC5taW4gfHwgMDtcbiAgICB2YXIgem9vbU1heCA9IHpvb21MaW1pdC5tYXggfHwgSW5maW5pdHk7XG4gICAgbmV3Wm9vbSA9IE1hdGgubWF4KE1hdGgubWluKHpvb21NYXgsIG5ld1pvb20pLCB6b29tTWluKTtcbiAgfVxuICB2YXIgem9vbVNjYWxlID0gbmV3Wm9vbSAvIGNvbnRyb2xsZXJIb3N0Lnpvb207XG4gIGNvbnRyb2xsZXJIb3N0Lnpvb20gPSBuZXdab29tO1xuICAvLyBLZWVwIHRoZSBtb3VzZSBjZW50ZXIgd2hlbiBzY2FsaW5nXG4gIHRhcmdldC54IC09ICh6b29tWCAtIHRhcmdldC54KSAqICh6b29tU2NhbGUgLSAxKTtcbiAgdGFyZ2V0LnkgLT0gKHpvb21ZIC0gdGFyZ2V0LnkpICogKHpvb21TY2FsZSAtIDEpO1xuICB0YXJnZXQuc2NhbGVYICo9IHpvb21TY2FsZTtcbiAgdGFyZ2V0LnNjYWxlWSAqPSB6b29tU2NhbGU7XG4gIHRhcmdldC5kaXJ0eSgpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///56366\n')},59166:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ install)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _extension_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3087);\n/* harmony import */ var _axis_AxisView_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(22480);\n/* harmony import */ var _axisPointer_PolarAxisPointer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(23953);\n/* harmony import */ var _axisPointer_install_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(46524);\n/* harmony import */ var _coord_polar_PolarModel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(17838);\n/* harmony import */ var _coord_axisModelCreator_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(59470);\n/* harmony import */ var _coord_polar_AxisModel_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(96413);\n/* harmony import */ var _coord_polar_polarCreator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(42506);\n/* harmony import */ var _axis_AngleAxisView_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(59481);\n/* harmony import */ var _axis_RadiusAxisView_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(13006);\n/* harmony import */ var _view_Component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59109);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(98026);\n/* harmony import */ var _layout_barPolar_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(95926);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar angleAxisExtraOption = {\n  startAngle: 90,\n  clockwise: true,\n  splitNumber: 12,\n  axisLabel: {\n    rotate: 0\n  }\n};\nvar radiusAxisExtraOption = {\n  splitNumber: 5\n};\nvar PolarView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(PolarView, _super);\n  function PolarView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = PolarView.type;\n    return _this;\n  }\n  PolarView.type = \'polar\';\n  return PolarView;\n}(_view_Component_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);\nfunction install(registers) {\n  (0,_extension_js__WEBPACK_IMPORTED_MODULE_2__/* .use */ .Y)(_axisPointer_install_js__WEBPACK_IMPORTED_MODULE_3__/* .install */ .a);\n  _axis_AxisView_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.registerAxisPointerClass(\'PolarAxisPointer\', _axisPointer_PolarAxisPointer_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A);\n  registers.registerCoordinateSystem(\'polar\', _coord_polar_polarCreator_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A);\n  registers.registerComponentModel(_coord_polar_PolarModel_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A);\n  registers.registerComponentView(PolarView);\n  // Model and view for angleAxis and radiusAxis\n  (0,_coord_axisModelCreator_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(registers, \'angle\', _coord_polar_AxisModel_js__WEBPACK_IMPORTED_MODULE_9__/* .AngleAxisModel */ .w2, angleAxisExtraOption);\n  (0,_coord_axisModelCreator_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(registers, \'radius\', _coord_polar_AxisModel_js__WEBPACK_IMPORTED_MODULE_9__/* .RadiusAxisModel */ .vI, radiusAxisExtraOption);\n  registers.registerComponentView(_axis_AngleAxisView_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A);\n  registers.registerComponentView(_axis_RadiusAxisView_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A);\n  registers.registerLayout((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_12__.curry)(_layout_barPolar_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A, \'bar\'));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkxNjYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvcG9sYXIvaW5zdGFsbC5qcz9hOTgyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyB1c2UgfSBmcm9tICcuLi8uLi9leHRlbnNpb24uanMnO1xuaW1wb3J0IEF4aXNWaWV3IGZyb20gJy4uL2F4aXMvQXhpc1ZpZXcuanMnO1xuaW1wb3J0IFBvbGFyQXhpc1BvaW50ZXIgZnJvbSAnLi4vYXhpc1BvaW50ZXIvUG9sYXJBeGlzUG9pbnRlci5qcyc7XG5pbXBvcnQgeyBpbnN0YWxsIGFzIGluc3RhbGxBeGlzUG9pbnRlciB9IGZyb20gJy4uL2F4aXNQb2ludGVyL2luc3RhbGwuanMnO1xuaW1wb3J0IFBvbGFyTW9kZWwgZnJvbSAnLi4vLi4vY29vcmQvcG9sYXIvUG9sYXJNb2RlbC5qcyc7XG5pbXBvcnQgYXhpc01vZGVsQ3JlYXRvciBmcm9tICcuLi8uLi9jb29yZC9heGlzTW9kZWxDcmVhdG9yLmpzJztcbmltcG9ydCB7IEFuZ2xlQXhpc01vZGVsLCBSYWRpdXNBeGlzTW9kZWwgfSBmcm9tICcuLi8uLi9jb29yZC9wb2xhci9BeGlzTW9kZWwuanMnO1xuaW1wb3J0IHBvbGFyQ3JlYXRvciBmcm9tICcuLi8uLi9jb29yZC9wb2xhci9wb2xhckNyZWF0b3IuanMnO1xuaW1wb3J0IEFuZ2xlQXhpc1ZpZXcgZnJvbSAnLi4vYXhpcy9BbmdsZUF4aXNWaWV3LmpzJztcbmltcG9ydCBSYWRpdXNBeGlzVmlldyBmcm9tICcuLi9heGlzL1JhZGl1c0F4aXNWaWV3LmpzJztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50LmpzJztcbmltcG9ydCB7IGN1cnJ5IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBiYXJMYXlvdXRQb2xhciBmcm9tICcuLi8uLi9sYXlvdXQvYmFyUG9sYXIuanMnO1xudmFyIGFuZ2xlQXhpc0V4dHJhT3B0aW9uID0ge1xuICBzdGFydEFuZ2xlOiA5MCxcbiAgY2xvY2t3aXNlOiB0cnVlLFxuICBzcGxpdE51bWJlcjogMTIsXG4gIGF4aXNMYWJlbDoge1xuICAgIHJvdGF0ZTogMFxuICB9XG59O1xudmFyIHJhZGl1c0F4aXNFeHRyYU9wdGlvbiA9IHtcbiAgc3BsaXROdW1iZXI6IDVcbn07XG52YXIgUG9sYXJWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBvbGFyVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gUG9sYXJWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBQb2xhclZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgUG9sYXJWaWV3LnR5cGUgPSAncG9sYXInO1xuICByZXR1cm4gUG9sYXJWaWV3O1xufShDb21wb25lbnRWaWV3KTtcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICB1c2UoaW5zdGFsbEF4aXNQb2ludGVyKTtcbiAgQXhpc1ZpZXcucmVnaXN0ZXJBeGlzUG9pbnRlckNsYXNzKCdQb2xhckF4aXNQb2ludGVyJywgUG9sYXJBeGlzUG9pbnRlcik7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvb3JkaW5hdGVTeXN0ZW0oJ3BvbGFyJywgcG9sYXJDcmVhdG9yKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50TW9kZWwoUG9sYXJNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoUG9sYXJWaWV3KTtcbiAgLy8gTW9kZWwgYW5kIHZpZXcgZm9yIGFuZ2xlQXhpcyBhbmQgcmFkaXVzQXhpc1xuICBheGlzTW9kZWxDcmVhdG9yKHJlZ2lzdGVycywgJ2FuZ2xlJywgQW5nbGVBeGlzTW9kZWwsIGFuZ2xlQXhpc0V4dHJhT3B0aW9uKTtcbiAgYXhpc01vZGVsQ3JlYXRvcihyZWdpc3RlcnMsICdyYWRpdXMnLCBSYWRpdXNBeGlzTW9kZWwsIHJhZGl1c0F4aXNFeHRyYU9wdGlvbik7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoQW5nbGVBeGlzVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoUmFkaXVzQXhpc1ZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQoY3VycnkoYmFyTGF5b3V0UG9sYXIsICdiYXInKSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///59166\n')},69380:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install_install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/extension.js\nvar extension = __webpack_require__(3087);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Model.js + 2 modules\nvar Model = __webpack_require__(43172);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Component.js\nvar Component = __webpack_require__(15915);\n;// ./node_modules/echarts/lib/component/legend/LegendModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar getDefaultSelectorOptions = function (ecModel, type) {\n  if (type === 'all') {\n    return {\n      type: 'all',\n      title: ecModel.getLocaleModel().get(['legend', 'selector', 'all'])\n    };\n  } else if (type === 'inverse') {\n    return {\n      type: 'inverse',\n      title: ecModel.getLocaleModel().get(['legend', 'selector', 'inverse'])\n    };\n  }\n};\nvar LegendModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(LegendModel, _super);\n  function LegendModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = LegendModel.type;\n    _this.layoutMode = {\n      type: 'box',\n      // legend.width/height are maxWidth/maxHeight actually,\n      // whereas real width/height is calculated by its content.\n      // (Setting {left: 10, right: 10} does not make sense).\n      // So consider the case:\n      // `setOption({legend: {left: 10});`\n      // then `setOption({legend: {right: 10});`\n      // The previous `left` should be cleared by setting `ignoreSize`.\n      ignoreSize: true\n    };\n    return _this;\n  }\n  LegendModel.prototype.init = function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    option.selected = option.selected || {};\n    this._updateSelector(option);\n  };\n  LegendModel.prototype.mergeOption = function (option, ecModel) {\n    _super.prototype.mergeOption.call(this, option, ecModel);\n    this._updateSelector(option);\n  };\n  LegendModel.prototype._updateSelector = function (option) {\n    var selector = option.selector;\n    var ecModel = this.ecModel;\n    if (selector === true) {\n      selector = option.selector = ['all', 'inverse'];\n    }\n    if (util.isArray(selector)) {\n      util.each(selector, function (item, index) {\n        util.isString(item) && (item = {\n          type: item\n        });\n        selector[index] = util.merge(item, getDefaultSelectorOptions(ecModel, item.type));\n      });\n    }\n  };\n  LegendModel.prototype.optionUpdated = function () {\n    this._updateData(this.ecModel);\n    var legendData = this._data;\n    // If selectedMode is single, try to select one\n    if (legendData[0] && this.get('selectedMode') === 'single') {\n      var hasSelected = false;\n      // If has any selected in option.selected\n      for (var i = 0; i < legendData.length; i++) {\n        var name_1 = legendData[i].get('name');\n        if (this.isSelected(name_1)) {\n          // Force to unselect others\n          this.select(name_1);\n          hasSelected = true;\n          break;\n        }\n      }\n      // Try select the first if selectedMode is single\n      !hasSelected && this.select(legendData[0].get('name'));\n    }\n  };\n  LegendModel.prototype._updateData = function (ecModel) {\n    var potentialData = [];\n    var availableNames = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      var seriesName = seriesModel.name;\n      availableNames.push(seriesName);\n      var isPotential;\n      if (seriesModel.legendVisualProvider) {\n        var provider = seriesModel.legendVisualProvider;\n        var names = provider.getAllNames();\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n          availableNames = availableNames.concat(names);\n        }\n        if (names.length) {\n          potentialData = potentialData.concat(names);\n        } else {\n          isPotential = true;\n        }\n      } else {\n        isPotential = true;\n      }\n      if (isPotential && (0,model/* isNameSpecified */.O0)(seriesModel)) {\n        potentialData.push(seriesModel.name);\n      }\n    });\n    /**\r\n     * @type {Array.<string>}\r\n     * @private\r\n     */\n    this._availableNames = availableNames;\n    // If legend.data is not specified in option, use availableNames as data,\n    // which is convenient for user preparing option.\n    var rawData = this.get('data') || potentialData;\n    var legendNameMap = util.createHashMap();\n    var legendData = util.map(rawData, function (dataItem) {\n      // Can be string or number\n      if (util.isString(dataItem) || util.isNumber(dataItem)) {\n        dataItem = {\n          name: dataItem\n        };\n      }\n      if (legendNameMap.get(dataItem.name)) {\n        // remove legend name duplicate\n        return null;\n      }\n      legendNameMap.set(dataItem.name, true);\n      return new Model/* default */.A(dataItem, this, this.ecModel);\n    }, this);\n    /**\r\n     * @type {Array.<module:echarts/model/Model>}\r\n     * @private\r\n     */\n    this._data = util.filter(legendData, function (item) {\n      return !!item;\n    });\n  };\n  LegendModel.prototype.getData = function () {\n    return this._data;\n  };\n  LegendModel.prototype.select = function (name) {\n    var selected = this.option.selected;\n    var selectedMode = this.get('selectedMode');\n    if (selectedMode === 'single') {\n      var data = this._data;\n      util.each(data, function (dataItem) {\n        selected[dataItem.get('name')] = false;\n      });\n    }\n    selected[name] = true;\n  };\n  LegendModel.prototype.unSelect = function (name) {\n    if (this.get('selectedMode') !== 'single') {\n      this.option.selected[name] = false;\n    }\n  };\n  LegendModel.prototype.toggleSelected = function (name) {\n    var selected = this.option.selected;\n    // Default is true\n    if (!selected.hasOwnProperty(name)) {\n      selected[name] = true;\n    }\n    this[selected[name] ? 'unSelect' : 'select'](name);\n  };\n  LegendModel.prototype.allSelect = function () {\n    var data = this._data;\n    var selected = this.option.selected;\n    util.each(data, function (dataItem) {\n      selected[dataItem.get('name', true)] = true;\n    });\n  };\n  LegendModel.prototype.inverseSelect = function () {\n    var data = this._data;\n    var selected = this.option.selected;\n    util.each(data, function (dataItem) {\n      var name = dataItem.get('name', true);\n      // Initially, default value is true\n      if (!selected.hasOwnProperty(name)) {\n        selected[name] = true;\n      }\n      selected[name] = !selected[name];\n    });\n  };\n  LegendModel.prototype.isSelected = function (name) {\n    var selected = this.option.selected;\n    return !(selected.hasOwnProperty(name) && !selected[name]) && util.indexOf(this._availableNames, name) >= 0;\n  };\n  LegendModel.prototype.getOrient = function () {\n    return this.get('orient') === 'vertical' ? {\n      index: 1,\n      name: 'vertical'\n    } : {\n      index: 0,\n      name: 'horizontal'\n    };\n  };\n  LegendModel.type = 'legend.plain';\n  LegendModel.dependencies = ['series'];\n  LegendModel.defaultOption = {\n    // zlevel: 0,\n    z: 4,\n    show: true,\n    orient: 'horizontal',\n    left: 'center',\n    // right: 'center',\n    top: 0,\n    // bottom: null,\n    align: 'auto',\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderColor: '#ccc',\n    borderRadius: 0,\n    borderWidth: 0,\n    padding: 5,\n    itemGap: 10,\n    itemWidth: 25,\n    itemHeight: 14,\n    symbolRotate: 'inherit',\n    symbolKeepAspect: true,\n    inactiveColor: '#ccc',\n    inactiveBorderColor: '#ccc',\n    inactiveBorderWidth: 'auto',\n    itemStyle: {\n      color: 'inherit',\n      opacity: 'inherit',\n      borderColor: 'inherit',\n      borderWidth: 'auto',\n      borderCap: 'inherit',\n      borderJoin: 'inherit',\n      borderDashOffset: 'inherit',\n      borderMiterLimit: 'inherit'\n    },\n    lineStyle: {\n      width: 'auto',\n      color: 'inherit',\n      inactiveColor: '#ccc',\n      inactiveWidth: 2,\n      opacity: 'inherit',\n      type: 'inherit',\n      cap: 'inherit',\n      join: 'inherit',\n      dashOffset: 'inherit',\n      miterLimit: 'inherit'\n    },\n    textStyle: {\n      color: '#333'\n    },\n    selectedMode: true,\n    selector: false,\n    selectorLabel: {\n      show: true,\n      borderRadius: 10,\n      padding: [3, 5, 3, 5],\n      fontSize: 12,\n      fontFamily: 'sans-serif',\n      color: '#666',\n      borderWidth: 1,\n      borderColor: '#666'\n    },\n    emphasis: {\n      selectorLabel: {\n        show: true,\n        color: '#eee',\n        backgroundColor: '#666'\n      }\n    },\n    selectorPosition: 'auto',\n    selectorItemGap: 7,\n    selectorButtonGap: 10,\n    tooltip: {\n      show: false\n    }\n  };\n  return LegendModel;\n}(Component/* default */.A);\n/* harmony default export */ const legend_LegendModel = (LegendModel);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/tool/color.js\nvar color = __webpack_require__(47698);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/listComponent.js\nvar listComponent = __webpack_require__(2400);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar view_Component = __webpack_require__(59109);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/symbol.js\nvar symbol = __webpack_require__(62103);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/decal.js\nvar decal = __webpack_require__(23538);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n;// ./node_modules/echarts/lib/component/legend/LegendView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\nvar curry = util.curry;\nvar each = util.each;\nvar LegendView_Group = Group/* default */.A;\nvar LegendView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(LegendView, _super);\n  function LegendView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = LegendView.type;\n    _this.newlineDisabled = false;\n    return _this;\n  }\n  LegendView.prototype.init = function () {\n    this.group.add(this._contentGroup = new LegendView_Group());\n    this.group.add(this._selectorGroup = new LegendView_Group());\n    this._isFirstRender = true;\n  };\n  /**\r\n   * @protected\r\n   */\n  LegendView.prototype.getContentGroup = function () {\n    return this._contentGroup;\n  };\n  /**\r\n   * @protected\r\n   */\n  LegendView.prototype.getSelectorGroup = function () {\n    return this._selectorGroup;\n  };\n  /**\r\n   * @override\r\n   */\n  LegendView.prototype.render = function (legendModel, ecModel, api) {\n    var isFirstRender = this._isFirstRender;\n    this._isFirstRender = false;\n    this.resetInner();\n    if (!legendModel.get('show', true)) {\n      return;\n    }\n    var itemAlign = legendModel.get('align');\n    var orient = legendModel.get('orient');\n    if (!itemAlign || itemAlign === 'auto') {\n      itemAlign = legendModel.get('left') === 'right' && orient === 'vertical' ? 'right' : 'left';\n    }\n    // selector has been normalized to an array in model\n    var selector = legendModel.get('selector', true);\n    var selectorPosition = legendModel.get('selectorPosition', true);\n    if (selector && (!selectorPosition || selectorPosition === 'auto')) {\n      selectorPosition = orient === 'horizontal' ? 'end' : 'start';\n    }\n    this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n    // Perform layout.\n    var positionInfo = legendModel.getBoxLayoutParams();\n    var viewportSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var padding = legendModel.get('padding');\n    var maxSize = layout/* getLayoutRect */.dV(positionInfo, viewportSize, padding);\n    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition);\n    // Place mainGroup, based on the calculated `mainRect`.\n    var layoutRect = layout/* getLayoutRect */.dV(util.defaults({\n      width: mainRect.width,\n      height: mainRect.height\n    }, positionInfo), viewportSize, padding);\n    this.group.x = layoutRect.x - mainRect.x;\n    this.group.y = layoutRect.y - mainRect.y;\n    this.group.markRedraw();\n    // Render background after group is layout.\n    this.group.add(this._backgroundEl = (0,listComponent/* makeBackground */.P)(mainRect, legendModel));\n  };\n  LegendView.prototype.resetInner = function () {\n    this.getContentGroup().removeAll();\n    this._backgroundEl && this.group.remove(this._backgroundEl);\n    this.getSelectorGroup().removeAll();\n  };\n  LegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n    var contentGroup = this.getContentGroup();\n    var legendDrawnMap = util.createHashMap();\n    var selectMode = legendModel.get('selectedMode');\n    var excludeSeriesId = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      !seriesModel.get('legendHoverLink') && excludeSeriesId.push(seriesModel.id);\n    });\n    each(legendModel.getData(), function (legendItemModel, dataIndex) {\n      var name = legendItemModel.get('name');\n      // Use empty string or \\n as a newline string\n      if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n        var g = new LegendView_Group();\n        // @ts-ignore\n        g.newline = true;\n        contentGroup.add(g);\n        return;\n      }\n      // Representitive series.\n      var seriesModel = ecModel.getSeriesByName(name)[0];\n      if (legendDrawnMap.get(name)) {\n        // Have been drawn\n        return;\n      }\n      // Legend to control series.\n      if (seriesModel) {\n        var data = seriesModel.getData();\n        var lineVisualStyle = data.getVisual('legendLineStyle') || {};\n        var legendIcon = data.getVisual('legendIcon');\n        /**\r\n         * `data.getVisual('style')` may be the color from the register\r\n         * in series. For example, for line series,\r\n         */\n        var style = data.getVisual('style');\n        var itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, style, legendIcon, selectMode, api);\n        itemGroup.on('click', curry(dispatchSelectAction, name, null, api, excludeSeriesId)).on('mouseover', curry(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));\n        if (ecModel.ssr) {\n          itemGroup.eachChild(function (child) {\n            var ecData = (0,innerStore/* getECData */.z)(child);\n            ecData.seriesIndex = seriesModel.seriesIndex;\n            ecData.dataIndex = dataIndex;\n            ecData.ssrType = 'legend';\n          });\n        }\n        legendDrawnMap.set(name, true);\n      } else {\n        // Legend to control data. In pie and funnel.\n        ecModel.eachRawSeries(function (seriesModel) {\n          // In case multiple series has same data name\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n          if (seriesModel.legendVisualProvider) {\n            var provider = seriesModel.legendVisualProvider;\n            if (!provider.containName(name)) {\n              return;\n            }\n            var idx = provider.indexOfName(name);\n            var style = provider.getItemVisual(idx, 'style');\n            var legendIcon = provider.getItemVisual(idx, 'legendIcon');\n            var colorArr = (0,color.parse)(style.fill);\n            // Color may be set to transparent in visualMap when data is out of range.\n            // Do not show nothing.\n            if (colorArr && colorArr[3] === 0) {\n              colorArr[3] = 0.2;\n              // TODO color is set to 0, 0, 0, 0. Should show correct RGBA\n              style = util.extend(util.extend({}, style), {\n                fill: (0,color.stringify)(colorArr, 'rgba')\n              });\n            }\n            var itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, {}, style, legendIcon, selectMode, api);\n            // FIXME: consider different series has items with the same name.\n            itemGroup.on('click', curry(dispatchSelectAction, null, name, api, excludeSeriesId))\n            // Should not specify the series name, consider legend controls\n            // more than one pie series.\n            .on('mouseover', curry(dispatchHighlightAction, null, name, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, null, name, api, excludeSeriesId));\n            if (ecModel.ssr) {\n              itemGroup.eachChild(function (child) {\n                var ecData = (0,innerStore/* getECData */.z)(child);\n                ecData.seriesIndex = seriesModel.seriesIndex;\n                ecData.dataIndex = dataIndex;\n                ecData.ssrType = 'legend';\n              });\n            }\n            legendDrawnMap.set(name, true);\n          }\n        }, this);\n      }\n      if (false) {}\n    }, this);\n    if (selector) {\n      this._createSelector(selector, legendModel, api, orient, selectorPosition);\n    }\n  };\n  LegendView.prototype._createSelector = function (selector, legendModel, api, orient, selectorPosition) {\n    var selectorGroup = this.getSelectorGroup();\n    each(selector, function createSelectorButton(selectorItem) {\n      var type = selectorItem.type;\n      var labelText = new Text/* default */.Ay({\n        style: {\n          x: 0,\n          y: 0,\n          align: 'center',\n          verticalAlign: 'middle'\n        },\n        onclick: function () {\n          api.dispatchAction({\n            type: type === 'all' ? 'legendAllSelect' : 'legendInverseSelect',\n            legendId: legendModel.id\n          });\n        }\n      });\n      selectorGroup.add(labelText);\n      var labelModel = legendModel.getModel('selectorLabel');\n      var emphasisLabelModel = legendModel.getModel(['emphasis', 'selectorLabel']);\n      (0,labelStyle/* setLabelStyle */.qM)(labelText, {\n        normal: labelModel,\n        emphasis: emphasisLabelModel\n      }, {\n        defaultText: selectorItem.title\n      });\n      (0,states/* enableHoverEmphasis */.iJ)(labelText);\n    });\n  };\n  LegendView.prototype._createItem = function (seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, itemVisualStyle, legendIcon, selectMode, api) {\n    var drawType = seriesModel.visualDrawType;\n    var itemWidth = legendModel.get('itemWidth');\n    var itemHeight = legendModel.get('itemHeight');\n    var isSelected = legendModel.isSelected(name);\n    var iconRotate = legendItemModel.get('symbolRotate');\n    var symbolKeepAspect = legendItemModel.get('symbolKeepAspect');\n    var legendIconType = legendItemModel.get('icon');\n    legendIcon = legendIconType || legendIcon || 'roundRect';\n    var style = getLegendStyle(legendIcon, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api);\n    var itemGroup = new LegendView_Group();\n    var textStyleModel = legendItemModel.getModel('textStyle');\n    if (util.isFunction(seriesModel.getLegendIcon) && (!legendIconType || legendIconType === 'inherit')) {\n      // Series has specific way to define legend icon\n      itemGroup.add(seriesModel.getLegendIcon({\n        itemWidth: itemWidth,\n        itemHeight: itemHeight,\n        icon: legendIcon,\n        iconRotate: iconRotate,\n        itemStyle: style.itemStyle,\n        lineStyle: style.lineStyle,\n        symbolKeepAspect: symbolKeepAspect\n      }));\n    } else {\n      // Use default legend icon policy for most series\n      var rotate = legendIconType === 'inherit' && seriesModel.getData().getVisual('symbol') ? iconRotate === 'inherit' ? seriesModel.getData().getVisual('symbolRotate') : iconRotate : 0; // No rotation for no icon\n      itemGroup.add(getDefaultLegendIcon({\n        itemWidth: itemWidth,\n        itemHeight: itemHeight,\n        icon: legendIcon,\n        iconRotate: rotate,\n        itemStyle: style.itemStyle,\n        lineStyle: style.lineStyle,\n        symbolKeepAspect: symbolKeepAspect\n      }));\n    }\n    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n    var textAlign = itemAlign;\n    var formatter = legendModel.get('formatter');\n    var content = name;\n    if (util.isString(formatter) && formatter) {\n      content = formatter.replace('{name}', name != null ? name : '');\n    } else if (util.isFunction(formatter)) {\n      content = formatter(name);\n    }\n    var textColor = isSelected ? textStyleModel.getTextColor() : legendItemModel.get('inactiveColor');\n    itemGroup.add(new Text/* default */.Ay({\n      style: (0,labelStyle/* createTextStyle */.VB)(textStyleModel, {\n        text: content,\n        x: textX,\n        y: itemHeight / 2,\n        fill: textColor,\n        align: textAlign,\n        verticalAlign: 'middle'\n      }, {\n        inheritColor: textColor\n      })\n    }));\n    // Add a invisible rect to increase the area of mouse hover\n    var hitRect = new Rect/* default */.A({\n      shape: itemGroup.getBoundingRect(),\n      style: {\n        // Cannot use 'invisible' because SVG SSR will miss the node\n        fill: 'transparent'\n      }\n    });\n    var tooltipModel = legendItemModel.getModel('tooltip');\n    if (tooltipModel.get('show')) {\n      graphic.setTooltipConfig({\n        el: hitRect,\n        componentModel: legendModel,\n        itemName: name,\n        itemTooltipOption: tooltipModel.option\n      });\n    }\n    itemGroup.add(hitRect);\n    itemGroup.eachChild(function (child) {\n      child.silent = true;\n    });\n    hitRect.silent = !selectMode;\n    this.getContentGroup().add(itemGroup);\n    (0,states/* enableHoverEmphasis */.iJ)(itemGroup);\n    // @ts-ignore\n    itemGroup.__legendDataIndex = dataIndex;\n    return itemGroup;\n  };\n  LegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n    var contentGroup = this.getContentGroup();\n    var selectorGroup = this.getSelectorGroup();\n    // Place items in contentGroup.\n    layout/* box */.aP(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n    var contentRect = contentGroup.getBoundingRect();\n    var contentPos = [-contentRect.x, -contentRect.y];\n    selectorGroup.markRedraw();\n    contentGroup.markRedraw();\n    if (selector) {\n      // Place buttons in selectorGroup\n      layout/* box */.aP(\n      // Buttons in selectorGroup always layout horizontally\n      'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n      var selectorRect = selectorGroup.getBoundingRect();\n      var selectorPos = [-selectorRect.x, -selectorRect.y];\n      var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n      var orientIdx = legendModel.getOrient().index;\n      var wh = orientIdx === 0 ? 'width' : 'height';\n      var hw = orientIdx === 0 ? 'height' : 'width';\n      var yx = orientIdx === 0 ? 'y' : 'x';\n      if (selectorPosition === 'end') {\n        selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;\n      } else {\n        contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;\n      }\n      // Always align selector to content as 'middle'\n      selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;\n      selectorGroup.x = selectorPos[0];\n      selectorGroup.y = selectorPos[1];\n      contentGroup.x = contentPos[0];\n      contentGroup.y = contentPos[1];\n      var mainRect = {\n        x: 0,\n        y: 0\n      };\n      mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];\n      mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);\n      mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);\n      return mainRect;\n    } else {\n      contentGroup.x = contentPos[0];\n      contentGroup.y = contentPos[1];\n      return this.group.getBoundingRect();\n    }\n  };\n  /**\r\n   * @protected\r\n   */\n  LegendView.prototype.remove = function () {\n    this.getContentGroup().removeAll();\n    this._isFirstRender = true;\n  };\n  LegendView.type = 'legend.plain';\n  return LegendView;\n}(view_Component/* default */.A);\nfunction getLegendStyle(iconType, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api) {\n  /**\r\n   * Use series style if is inherit;\r\n   * elsewise, use legend style\r\n   */\n  function handleCommonProps(style, visualStyle) {\n    // If lineStyle.width is 'auto', it is set to be 2 if series has border\n    if (style.lineWidth === 'auto') {\n      style.lineWidth = visualStyle.lineWidth > 0 ? 2 : 0;\n    }\n    each(style, function (propVal, propName) {\n      style[propName] === 'inherit' && (style[propName] = visualStyle[propName]);\n    });\n  }\n  // itemStyle\n  var itemStyleModel = legendItemModel.getModel('itemStyle');\n  var itemStyle = itemStyleModel.getItemStyle();\n  var iconBrushType = iconType.lastIndexOf('empty', 0) === 0 ? 'fill' : 'stroke';\n  var decalStyle = itemStyleModel.getShallow('decal');\n  itemStyle.decal = !decalStyle || decalStyle === 'inherit' ? itemVisualStyle.decal : (0,decal/* createOrUpdatePatternFromDecal */.w)(decalStyle, api);\n  if (itemStyle.fill === 'inherit') {\n    /**\r\n     * Series with visualDrawType as 'stroke' should have\r\n     * series stroke as legend fill\r\n     */\n    itemStyle.fill = itemVisualStyle[drawType];\n  }\n  if (itemStyle.stroke === 'inherit') {\n    /**\r\n     * icon type with \"emptyXXX\" should use fill color\r\n     * in visual style\r\n     */\n    itemStyle.stroke = itemVisualStyle[iconBrushType];\n  }\n  if (itemStyle.opacity === 'inherit') {\n    /**\r\n     * Use lineStyle.opacity if drawType is stroke\r\n     */\n    itemStyle.opacity = (drawType === 'fill' ? itemVisualStyle : lineVisualStyle).opacity;\n  }\n  handleCommonProps(itemStyle, itemVisualStyle);\n  // lineStyle\n  var legendLineModel = legendItemModel.getModel('lineStyle');\n  var lineStyle = legendLineModel.getLineStyle();\n  handleCommonProps(lineStyle, lineVisualStyle);\n  // Fix auto color to real color\n  itemStyle.fill === 'auto' && (itemStyle.fill = itemVisualStyle.fill);\n  itemStyle.stroke === 'auto' && (itemStyle.stroke = itemVisualStyle.fill);\n  lineStyle.stroke === 'auto' && (lineStyle.stroke = itemVisualStyle.fill);\n  if (!isSelected) {\n    var borderWidth = legendItemModel.get('inactiveBorderWidth');\n    /**\r\n     * Since stroke is set to be inactiveBorderColor, it may occur that\r\n     * there is no border in series but border in legend, so we need to\r\n     * use border only when series has border if is set to be auto\r\n     */\n    var visualHasBorder = itemStyle[iconBrushType];\n    itemStyle.lineWidth = borderWidth === 'auto' ? itemVisualStyle.lineWidth > 0 && visualHasBorder ? 2 : 0 : itemStyle.lineWidth;\n    itemStyle.fill = legendItemModel.get('inactiveColor');\n    itemStyle.stroke = legendItemModel.get('inactiveBorderColor');\n    lineStyle.stroke = legendLineModel.get('inactiveColor');\n    lineStyle.lineWidth = legendLineModel.get('inactiveWidth');\n  }\n  return {\n    itemStyle: itemStyle,\n    lineStyle: lineStyle\n  };\n}\nfunction getDefaultLegendIcon(opt) {\n  var symboType = opt.icon || 'roundRect';\n  var icon = (0,symbol/* createSymbol */.v5)(symboType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill, opt.symbolKeepAspect);\n  icon.setStyle(opt.itemStyle);\n  icon.rotation = (opt.iconRotate || 0) * Math.PI / 180;\n  icon.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);\n  if (symboType.indexOf('empty') > -1) {\n    icon.style.stroke = icon.style.fill;\n    icon.style.fill = '#fff';\n    icon.style.lineWidth = 2;\n  }\n  return icon;\n}\nfunction dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {\n  // downplay before unselect\n  dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);\n  api.dispatchAction({\n    type: 'legendToggleSelect',\n    name: seriesName != null ? seriesName : dataName\n  });\n  // highlight after select\n  // TODO highlight immediately may cause animation loss.\n  dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);\n}\nfunction isUseHoverLayer(api) {\n  var list = api.getZr().storage.getDisplayList();\n  var emphasisState;\n  var i = 0;\n  var len = list.length;\n  while (i < len && !(emphasisState = list[i].states.emphasis)) {\n    i++;\n  }\n  return emphasisState && emphasisState.hoverLayer;\n}\nfunction dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {\n  // If element hover will move to a hoverLayer.\n  if (!isUseHoverLayer(api)) {\n    api.dispatchAction({\n      type: 'highlight',\n      seriesName: seriesName,\n      name: dataName,\n      excludeSeriesId: excludeSeriesId\n    });\n  }\n}\nfunction dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {\n  // If element hover will move to a hoverLayer.\n  if (!isUseHoverLayer(api)) {\n    api.dispatchAction({\n      type: 'downplay',\n      seriesName: seriesName,\n      name: dataName,\n      excludeSeriesId: excludeSeriesId\n    });\n  }\n}\n/* harmony default export */ const legend_LegendView = (LegendView);\n;// ./node_modules/echarts/lib/component/legend/legendFilter.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nfunction legendFilter(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n  if (legendModels && legendModels.length) {\n    ecModel.filterSeries(function (series) {\n      // If in any legend component the status is not selected.\n      // Because in legend series is assumed selected when it is not in the legend data.\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(series.name)) {\n          return false;\n        }\n      }\n      return true;\n    });\n  }\n}\n;// ./node_modules/echarts/lib/component/legend/legendAction.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n  var isAllSelect = methodName === 'allSelect' || methodName === 'inverseSelect';\n  var selectedMap = {};\n  var actionLegendIndices = [];\n  ecModel.eachComponent({\n    mainType: 'legend',\n    query: payload\n  }, function (legendModel) {\n    if (isAllSelect) {\n      legendModel[methodName]();\n    } else {\n      legendModel[methodName](payload.name);\n    }\n    makeSelectedMap(legendModel, selectedMap);\n    actionLegendIndices.push(legendModel.componentIndex);\n  });\n  var allSelectedMap = {};\n  // make selectedMap from all legend components\n  ecModel.eachComponent('legend', function (legendModel) {\n    (0,util.each)(selectedMap, function (isSelected, name) {\n      // Force other legend has same selected status\n      // Or the first is toggled to true and other are toggled to false\n      // In the case one legend has some item unSelected in option. And if other legend\n      // doesn't has the item, they will assume it is selected.\n      legendModel[isSelected ? 'select' : 'unSelect'](name);\n    });\n    makeSelectedMap(legendModel, allSelectedMap);\n  });\n  // Return the event explicitly\n  return isAllSelect ? {\n    selected: allSelectedMap,\n    // return legendIndex array to tell the developers which legends are allSelect / inverseSelect\n    legendIndex: actionLegendIndices\n  } : {\n    name: payload.name,\n    selected: allSelectedMap\n  };\n}\nfunction makeSelectedMap(legendModel, out) {\n  var selectedMap = out || {};\n  (0,util.each)(legendModel.getData(), function (model) {\n    var name = model.get('name');\n    // Wrap element\n    if (name === '\\n' || name === '') {\n      return;\n    }\n    var isItemSelected = legendModel.isSelected(name);\n    if ((0,util.hasOwn)(selectedMap, name)) {\n      // Unselected if any legend is unselected\n      selectedMap[name] = selectedMap[name] && isItemSelected;\n    } else {\n      selectedMap[name] = isItemSelected;\n    }\n  });\n  return selectedMap;\n}\nfunction installLegendAction(registers) {\n  /**\r\n   * @event legendToggleSelect\r\n   * @type {Object}\r\n   * @property {string} type 'legendToggleSelect'\r\n   * @property {string} [from]\r\n   * @property {string} name Series name or data item name\r\n   */\n  registers.registerAction('legendToggleSelect', 'legendselectchanged', (0,util.curry)(legendSelectActionHandler, 'toggleSelected'));\n  registers.registerAction('legendAllSelect', 'legendselectall', (0,util.curry)(legendSelectActionHandler, 'allSelect'));\n  registers.registerAction('legendInverseSelect', 'legendinverseselect', (0,util.curry)(legendSelectActionHandler, 'inverseSelect'));\n  /**\r\n   * @event legendSelect\r\n   * @type {Object}\r\n   * @property {string} type 'legendSelect'\r\n   * @property {string} name Series name or data item name\r\n   */\n  registers.registerAction('legendSelect', 'legendselected', (0,util.curry)(legendSelectActionHandler, 'select'));\n  /**\r\n   * @event legendUnSelect\r\n   * @type {Object}\r\n   * @property {string} type 'legendUnSelect'\r\n   * @property {string} name Series name or data item name\r\n   */\n  registers.registerAction('legendUnSelect', 'legendunselected', (0,util.curry)(legendSelectActionHandler, 'unSelect'));\n}\n;// ./node_modules/echarts/lib/component/legend/installLegendPlain.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nfunction install(registers) {\n  registers.registerComponentModel(legend_LegendModel);\n  registers.registerComponentView(legend_LegendView);\n  registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);\n  registers.registerSubTypeDefaulter('legend', function () {\n    return 'plain';\n  });\n  installLegendAction(registers);\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/component.js\nvar component = __webpack_require__(12616);\n;// ./node_modules/echarts/lib/component/legend/ScrollableLegendModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar ScrollableLegendModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ScrollableLegendModel, _super);\n  function ScrollableLegendModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ScrollableLegendModel.type;\n    return _this;\n  }\n  /**\r\n   * @param {number} scrollDataIndex\r\n   */\n  ScrollableLegendModel.prototype.setScrollDataIndex = function (scrollDataIndex) {\n    this.option.scrollDataIndex = scrollDataIndex;\n  };\n  ScrollableLegendModel.prototype.init = function (option, parentModel, ecModel) {\n    var inputPositionParams = (0,layout/* getLayoutParams */.vs)(option);\n    _super.prototype.init.call(this, option, parentModel, ecModel);\n    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);\n  };\n  /**\r\n   * @override\r\n   */\n  ScrollableLegendModel.prototype.mergeOption = function (option, ecModel) {\n    _super.prototype.mergeOption.call(this, option, ecModel);\n    mergeAndNormalizeLayoutParams(this, this.option, option);\n  };\n  ScrollableLegendModel.type = 'legend.scroll';\n  ScrollableLegendModel.defaultOption = (0,component/* inheritDefaultOption */.G_)(legend_LegendModel.defaultOption, {\n    scrollDataIndex: 0,\n    pageButtonItemGap: 5,\n    pageButtonGap: null,\n    pageButtonPosition: 'end',\n    pageFormatter: '{current}/{total}',\n    pageIcons: {\n      horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],\n      vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']\n    },\n    pageIconColor: '#2f4554',\n    pageIconInactiveColor: '#aaa',\n    pageIconSize: 15,\n    pageTextStyle: {\n      color: '#333'\n    },\n    animationDurationUpdate: 800\n  });\n  return ScrollableLegendModel;\n}(legend_LegendModel);\n;\n// Do not `ignoreSize` to enable setting {left: 10, right: 10}.\nfunction mergeAndNormalizeLayoutParams(legendModel, target, raw) {\n  var orient = legendModel.getOrient();\n  var ignoreSize = [1, 1];\n  ignoreSize[orient.index] = 0;\n  (0,layout/* mergeLayoutParam */.YA)(target, raw, {\n    type: 'box',\n    ignoreSize: !!ignoreSize\n  });\n}\n/* harmony default export */ const legend_ScrollableLegendModel = (ScrollableLegendModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n;// ./node_modules/echarts/lib/component/legend/ScrollableLegendView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * Separate legend and scrollable legend to reduce package size.\r\n */\n\n\n\n\nvar ScrollableLegendView_Group = Group/* default */.A;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ScrollableLegendView, _super);\n  function ScrollableLegendView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ScrollableLegendView.type;\n    _this.newlineDisabled = true;\n    _this._currentIndex = 0;\n    return _this;\n  }\n  ScrollableLegendView.prototype.init = function () {\n    _super.prototype.init.call(this);\n    this.group.add(this._containerGroup = new ScrollableLegendView_Group());\n    this._containerGroup.add(this.getContentGroup());\n    this.group.add(this._controllerGroup = new ScrollableLegendView_Group());\n  };\n  /**\r\n   * @override\r\n   */\n  ScrollableLegendView.prototype.resetInner = function () {\n    _super.prototype.resetInner.call(this);\n    this._controllerGroup.removeAll();\n    this._containerGroup.removeClipPath();\n    this._containerGroup.__rectSize = null;\n  };\n  /**\r\n   * @override\r\n   */\n  ScrollableLegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n    var self = this;\n    // Render content items.\n    _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n    var controllerGroup = this._controllerGroup;\n    // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n    var pageIconSize = legendModel.get('pageIconSize', true);\n    var pageIconSizeArr = util.isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new Text/* default */.Ay({\n      name: 'pageText',\n      style: {\n        // Placeholder to calculate a proper layout.\n        text: 'xx/xx',\n        fill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        verticalAlign: 'middle',\n        align: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: util.bind(self._pageGo, self, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSizeArr[0] / 2,\n        y: -pageIconSizeArr[1] / 2,\n        width: pageIconSizeArr[0],\n        height: pageIconSizeArr[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  };\n  /**\r\n   * @override\r\n   */\n  ScrollableLegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n    var selectorGroup = this.getSelectorGroup();\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx];\n    selector && layout/* box */.aP(\n    // Buttons in selectorGroup always layout horizontally\n    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n    var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n    var selectorRect = selectorGroup.getBoundingRect();\n    var selectorPos = [-selectorRect.x, -selectorRect.y];\n    var processMaxSize = util.clone(maxSize);\n    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);\n    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);\n    if (selector) {\n      if (selectorPosition === 'end') {\n        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;\n      } else {\n        var offset = selectorRect[wh] + selectorButtonGap;\n        selectorPos[orientIdx] -= offset;\n        mainRect[xy] -= offset;\n      }\n      mainRect[wh] += selectorRect[wh] + selectorButtonGap;\n      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;\n      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);\n      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);\n      selectorGroup.x = selectorPos[0];\n      selectorGroup.y = selectorPos[1];\n      selectorGroup.markRedraw();\n    }\n    return mainRect;\n  };\n  ScrollableLegendView.prototype._layoutContentAndController = function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup;\n    // Place items in contentGroup.\n    layout/* box */.aP(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layout/* box */.aP(\n    // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    // In case that the inner elements of contentGroup layout do not based on [0, 0]\n    var contentPos = [-contentRect.x, -contentRect.y];\n    // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup[xy];\n    }\n    // Layout container group based on 0.\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = util.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true));\n    // Place containerGroup and controllerGroup and contentGroup.\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true);\n      // controller is on the right / bottom.\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      }\n      // controller is on the left / top.\n      else {\n        containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n      }\n    }\n    // Always align controller to content as 'middle'.\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.setPosition(contentPos);\n    containerGroup.setPosition(containerPos);\n    controllerGroup.setPosition(controllerPos);\n    // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n    var mainRect = {\n      x: 0,\n      y: 0\n    };\n    // Consider content may be overflow (should be clipped).\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);\n    // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new Rect/* default */.A({\n        shape: clipShape\n      }));\n      // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as placeholders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    }\n    // Content translate animation.\n    var pageInfo = this._getPageInfo(legendModel);\n    pageInfo.pageIndex != null && basicTransition/* updateProps */.oi(contentGroup, {\n      x: pageInfo.contentPosition[0],\n      y: pageInfo.contentPosition[1]\n    },\n    // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird effect.\n    showController ? legendModel : null);\n    this._updatePageInfoView(legendModel, pageInfo);\n    return mainRect;\n  };\n  ScrollableLegendView.prototype._pageGo = function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  };\n  ScrollableLegendView.prototype._updatePageInfoView = function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    util.each(['pagePrev', 'pageNext'], function (name) {\n      var key = name + 'DataIndex';\n      var canJump = pageInfo[key] != null;\n      var icon = controllerGroup.childOfName(name);\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', util.isString(pageFormatter) ? pageFormatter.replace('{current}', current == null ? '' : current + '').replace('{total}', total == null ? '' : total + '') : pageFormatter({\n      current: current,\n      total: total\n    }));\n  };\n  /**\r\n   *  contentPosition: Array.<number>, null when data item not found.\r\n   *  pageIndex: number, null when data item not found.\r\n   *  pageCount: number, always be a number, can be 0.\r\n   *  pagePrevDataIndex: number, null when no previous page.\r\n   *  pageNextDataIndex: number, null when no next page.\r\n   * }\r\n   */\n  ScrollableLegendView.prototype._getPageInfo = function (legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: [contentGroup.x, contentGroup.y],\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n    if (!targetItem) {\n      return result;\n    }\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s;\n    // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n      if (\n      // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize\n      // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      || currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n          ++result.pageCount;\n        }\n      }\n      winEndItemInfo = currItemInfo;\n    }\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n      if (\n      // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)\n      // e.g., when page size is smaller than item size.\n      ) && winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n      winStartItemInfo = currItemInfo;\n    }\n    return result;\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el[xy];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  };\n  ScrollableLegendView.prototype._findTargetItemIndex = function (targetDataIndex) {\n    if (!this._showController) {\n      return 0;\n    }\n    var index;\n    var contentGroup = this.getContentGroup();\n    var defaultIndex;\n    contentGroup.eachChild(function (child, idx) {\n      var legendDataIdx = child.__legendDataIndex;\n      // FIXME\n      // If the given targetDataIndex (from model) is illegal,\n      // we use defaultIndex. But the index on the legend model and\n      // action payload is still illegal. That case will not be\n      // changed until some scenario requires.\n      if (defaultIndex == null && legendDataIdx != null) {\n        defaultIndex = idx;\n      }\n      if (legendDataIdx === targetDataIndex) {\n        index = idx;\n      }\n    });\n    return index != null ? index : defaultIndex;\n  };\n  ScrollableLegendView.type = 'legend.scroll';\n  return ScrollableLegendView;\n}(legend_LegendView);\n/* harmony default export */ const legend_ScrollableLegendView = (ScrollableLegendView);\n;// ./node_modules/echarts/lib/component/legend/scrollableLegendAction.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nfunction installScrollableLegendAction(registers) {\n  /**\r\n   * @event legendScroll\r\n   * @type {Object}\r\n   * @property {string} type 'legendScroll'\r\n   * @property {string} scrollDataIndex\r\n   */\n  registers.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {\n    var scrollDataIndex = payload.scrollDataIndex;\n    scrollDataIndex != null && ecModel.eachComponent({\n      mainType: 'legend',\n      subType: 'scroll',\n      query: payload\n    }, function (legendModel) {\n      legendModel.setScrollDataIndex(scrollDataIndex);\n    });\n  });\n}\n;// ./node_modules/echarts/lib/component/legend/installLegendScroll.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nfunction installLegendScroll_install(registers) {\n  (0,extension/* use */.Y)(install);\n  registers.registerComponentModel(legend_ScrollableLegendModel);\n  registers.registerComponentView(legend_ScrollableLegendView);\n  installScrollableLegendAction(registers);\n}\n;// ./node_modules/echarts/lib/component/legend/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction install_install(registers) {\n  (0,extension/* use */.Y)(install);\n  (0,extension/* use */.Y)(installLegendScroll_install);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkzODAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kTW9kZWwuanM/MTUzYSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9MZWdlbmRWaWV3LmpzP2Q2ZmIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kRmlsdGVyLmpzPzg0MDYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kQWN0aW9uLmpzPzI4ZTAiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvaW5zdGFsbExlZ2VuZFBsYWluLmpzP2Y4NWQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsLmpzP2U4OGYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvU2Nyb2xsYWJsZUxlZ2VuZFZpZXcuanM/Zjg5NCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9zY3JvbGxhYmxlTGVnZW5kQWN0aW9uLmpzP2MxYjAiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvaW5zdGFsbExlZ2VuZFNjcm9sbC5qcz8zYTkzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL2luc3RhbGwuanM/NzM1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvTW9kZWwuanMnO1xuaW1wb3J0IHsgaXNOYW1lU3BlY2lmaWVkIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50LmpzJztcbnZhciBnZXREZWZhdWx0U2VsZWN0b3JPcHRpb25zID0gZnVuY3Rpb24gKGVjTW9kZWwsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09ICdhbGwnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdhbGwnLFxuICAgICAgdGl0bGU6IGVjTW9kZWwuZ2V0TG9jYWxlTW9kZWwoKS5nZXQoWydsZWdlbmQnLCAnc2VsZWN0b3InLCAnYWxsJ10pXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnaW52ZXJzZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2ludmVyc2UnLFxuICAgICAgdGl0bGU6IGVjTW9kZWwuZ2V0TG9jYWxlTW9kZWwoKS5nZXQoWydsZWdlbmQnLCAnc2VsZWN0b3InLCAnaW52ZXJzZSddKVxuICAgIH07XG4gIH1cbn07XG52YXIgTGVnZW5kTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTGVnZW5kTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIExlZ2VuZE1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBMZWdlbmRNb2RlbC50eXBlO1xuICAgIF90aGlzLmxheW91dE1vZGUgPSB7XG4gICAgICB0eXBlOiAnYm94JyxcbiAgICAgIC8vIGxlZ2VuZC53aWR0aC9oZWlnaHQgYXJlIG1heFdpZHRoL21heEhlaWdodCBhY3R1YWxseSxcbiAgICAgIC8vIHdoZXJlYXMgcmVhbCB3aWR0aC9oZWlnaHQgaXMgY2FsY3VsYXRlZCBieSBpdHMgY29udGVudC5cbiAgICAgIC8vIChTZXR0aW5nIHtsZWZ0OiAxMCwgcmlnaHQ6IDEwfSBkb2VzIG5vdCBtYWtlIHNlbnNlKS5cbiAgICAgIC8vIFNvIGNvbnNpZGVyIHRoZSBjYXNlOlxuICAgICAgLy8gYHNldE9wdGlvbih7bGVnZW5kOiB7bGVmdDogMTB9KTtgXG4gICAgICAvLyB0aGVuIGBzZXRPcHRpb24oe2xlZ2VuZDoge3JpZ2h0OiAxMH0pO2BcbiAgICAgIC8vIFRoZSBwcmV2aW91cyBgbGVmdGAgc2hvdWxkIGJlIGNsZWFyZWQgYnkgc2V0dGluZyBgaWdub3JlU2l6ZWAuXG4gICAgICBpZ25vcmVTaXplOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgTGVnZW5kTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCkge1xuICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcbiAgICBvcHRpb24uc2VsZWN0ZWQgPSBvcHRpb24uc2VsZWN0ZWQgfHwge307XG4gICAgdGhpcy5fdXBkYXRlU2VsZWN0b3Iob3B0aW9uKTtcbiAgfTtcbiAgTGVnZW5kTW9kZWwucHJvdG90eXBlLm1lcmdlT3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUubWVyZ2VPcHRpb24uY2FsbCh0aGlzLCBvcHRpb24sIGVjTW9kZWwpO1xuICAgIHRoaXMuX3VwZGF0ZVNlbGVjdG9yKG9wdGlvbik7XG4gIH07XG4gIExlZ2VuZE1vZGVsLnByb3RvdHlwZS5fdXBkYXRlU2VsZWN0b3IgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gb3B0aW9uLnNlbGVjdG9yO1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgIGlmIChzZWxlY3RvciA9PT0gdHJ1ZSkge1xuICAgICAgc2VsZWN0b3IgPSBvcHRpb24uc2VsZWN0b3IgPSBbJ2FsbCcsICdpbnZlcnNlJ107XG4gICAgfVxuICAgIGlmICh6clV0aWwuaXNBcnJheShzZWxlY3RvcikpIHtcbiAgICAgIHpyVXRpbC5lYWNoKHNlbGVjdG9yLCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgenJVdGlsLmlzU3RyaW5nKGl0ZW0pICYmIChpdGVtID0ge1xuICAgICAgICAgIHR5cGU6IGl0ZW1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGVjdG9yW2luZGV4XSA9IHpyVXRpbC5tZXJnZShpdGVtLCBnZXREZWZhdWx0U2VsZWN0b3JPcHRpb25zKGVjTW9kZWwsIGl0ZW0udHlwZSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBMZWdlbmRNb2RlbC5wcm90b3R5cGUub3B0aW9uVXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl91cGRhdGVEYXRhKHRoaXMuZWNNb2RlbCk7XG4gICAgdmFyIGxlZ2VuZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIC8vIElmIHNlbGVjdGVkTW9kZSBpcyBzaW5nbGUsIHRyeSB0byBzZWxlY3Qgb25lXG4gICAgaWYgKGxlZ2VuZERhdGFbMF0gJiYgdGhpcy5nZXQoJ3NlbGVjdGVkTW9kZScpID09PSAnc2luZ2xlJykge1xuICAgICAgdmFyIGhhc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAvLyBJZiBoYXMgYW55IHNlbGVjdGVkIGluIG9wdGlvbi5zZWxlY3RlZFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWdlbmREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lXzEgPSBsZWdlbmREYXRhW2ldLmdldCgnbmFtZScpO1xuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkKG5hbWVfMSkpIHtcbiAgICAgICAgICAvLyBGb3JjZSB0byB1bnNlbGVjdCBvdGhlcnNcbiAgICAgICAgICB0aGlzLnNlbGVjdChuYW1lXzEpO1xuICAgICAgICAgIGhhc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVHJ5IHNlbGVjdCB0aGUgZmlyc3QgaWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZVxuICAgICAgIWhhc1NlbGVjdGVkICYmIHRoaXMuc2VsZWN0KGxlZ2VuZERhdGFbMF0uZ2V0KCduYW1lJykpO1xuICAgIH1cbiAgfTtcbiAgTGVnZW5kTW9kZWwucHJvdG90eXBlLl91cGRhdGVEYXRhID0gZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICB2YXIgcG90ZW50aWFsRGF0YSA9IFtdO1xuICAgIHZhciBhdmFpbGFibGVOYW1lcyA9IFtdO1xuICAgIGVjTW9kZWwuZWFjaFJhd1NlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHZhciBzZXJpZXNOYW1lID0gc2VyaWVzTW9kZWwubmFtZTtcbiAgICAgIGF2YWlsYWJsZU5hbWVzLnB1c2goc2VyaWVzTmFtZSk7XG4gICAgICB2YXIgaXNQb3RlbnRpYWw7XG4gICAgICBpZiAoc2VyaWVzTW9kZWwubGVnZW5kVmlzdWFsUHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gc2VyaWVzTW9kZWwubGVnZW5kVmlzdWFsUHJvdmlkZXI7XG4gICAgICAgIHZhciBuYW1lcyA9IHByb3ZpZGVyLmdldEFsbE5hbWVzKCk7XG4gICAgICAgIGlmICghZWNNb2RlbC5pc1Nlcmllc0ZpbHRlcmVkKHNlcmllc01vZGVsKSkge1xuICAgICAgICAgIGF2YWlsYWJsZU5hbWVzID0gYXZhaWxhYmxlTmFtZXMuY29uY2F0KG5hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcG90ZW50aWFsRGF0YSA9IHBvdGVudGlhbERhdGEuY29uY2F0KG5hbWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1BvdGVudGlhbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzUG90ZW50aWFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BvdGVudGlhbCAmJiBpc05hbWVTcGVjaWZpZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgIHBvdGVudGlhbERhdGEucHVzaChzZXJpZXNNb2RlbC5uYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cbiAgICB0aGlzLl9hdmFpbGFibGVOYW1lcyA9IGF2YWlsYWJsZU5hbWVzO1xuICAgIC8vIElmIGxlZ2VuZC5kYXRhIGlzIG5vdCBzcGVjaWZpZWQgaW4gb3B0aW9uLCB1c2UgYXZhaWxhYmxlTmFtZXMgYXMgZGF0YSxcbiAgICAvLyB3aGljaCBpcyBjb252ZW5pZW50IGZvciB1c2VyIHByZXBhcmluZyBvcHRpb24uXG4gICAgdmFyIHJhd0RhdGEgPSB0aGlzLmdldCgnZGF0YScpIHx8IHBvdGVudGlhbERhdGE7XG4gICAgdmFyIGxlZ2VuZE5hbWVNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICAgIHZhciBsZWdlbmREYXRhID0genJVdGlsLm1hcChyYXdEYXRhLCBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcbiAgICAgIC8vIENhbiBiZSBzdHJpbmcgb3IgbnVtYmVyXG4gICAgICBpZiAoenJVdGlsLmlzU3RyaW5nKGRhdGFJdGVtKSB8fCB6clV0aWwuaXNOdW1iZXIoZGF0YUl0ZW0pKSB7XG4gICAgICAgIGRhdGFJdGVtID0ge1xuICAgICAgICAgIG5hbWU6IGRhdGFJdGVtXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAobGVnZW5kTmFtZU1hcC5nZXQoZGF0YUl0ZW0ubmFtZSkpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGxlZ2VuZCBuYW1lIGR1cGxpY2F0ZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGxlZ2VuZE5hbWVNYXAuc2V0KGRhdGFJdGVtLm5hbWUsIHRydWUpO1xuICAgICAgcmV0dXJuIG5ldyBNb2RlbChkYXRhSXRlbSwgdGhpcywgdGhpcy5lY01vZGVsKTtcbiAgICB9LCB0aGlzKTtcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xuICAgIHRoaXMuX2RhdGEgPSB6clV0aWwuZmlsdGVyKGxlZ2VuZERhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gISFpdGVtO1xuICAgIH0pO1xuICB9O1xuICBMZWdlbmRNb2RlbC5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfTtcbiAgTGVnZW5kTW9kZWwucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gdGhpcy5vcHRpb24uc2VsZWN0ZWQ7XG4gICAgdmFyIHNlbGVjdGVkTW9kZSA9IHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKTtcbiAgICBpZiAoc2VsZWN0ZWRNb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgenJVdGlsLmVhY2goZGF0YSwgZnVuY3Rpb24gKGRhdGFJdGVtKSB7XG4gICAgICAgIHNlbGVjdGVkW2RhdGFJdGVtLmdldCgnbmFtZScpXSA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNlbGVjdGVkW25hbWVdID0gdHJ1ZTtcbiAgfTtcbiAgTGVnZW5kTW9kZWwucHJvdG90eXBlLnVuU2VsZWN0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAodGhpcy5nZXQoJ3NlbGVjdGVkTW9kZScpICE9PSAnc2luZ2xlJykge1xuICAgICAgdGhpcy5vcHRpb24uc2VsZWN0ZWRbbmFtZV0gPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIExlZ2VuZE1vZGVsLnByb3RvdHlwZS50b2dnbGVTZWxlY3RlZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gdGhpcy5vcHRpb24uc2VsZWN0ZWQ7XG4gICAgLy8gRGVmYXVsdCBpcyB0cnVlXG4gICAgaWYgKCFzZWxlY3RlZC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgc2VsZWN0ZWRbbmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzW3NlbGVjdGVkW25hbWVdID8gJ3VuU2VsZWN0JyA6ICdzZWxlY3QnXShuYW1lKTtcbiAgfTtcbiAgTGVnZW5kTW9kZWwucHJvdG90eXBlLmFsbFNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdmFyIHNlbGVjdGVkID0gdGhpcy5vcHRpb24uc2VsZWN0ZWQ7XG4gICAgenJVdGlsLmVhY2goZGF0YSwgZnVuY3Rpb24gKGRhdGFJdGVtKSB7XG4gICAgICBzZWxlY3RlZFtkYXRhSXRlbS5nZXQoJ25hbWUnLCB0cnVlKV0gPSB0cnVlO1xuICAgIH0pO1xuICB9O1xuICBMZWdlbmRNb2RlbC5wcm90b3R5cGUuaW52ZXJzZVNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdmFyIHNlbGVjdGVkID0gdGhpcy5vcHRpb24uc2VsZWN0ZWQ7XG4gICAgenJVdGlsLmVhY2goZGF0YSwgZnVuY3Rpb24gKGRhdGFJdGVtKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGFJdGVtLmdldCgnbmFtZScsIHRydWUpO1xuICAgICAgLy8gSW5pdGlhbGx5LCBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgIGlmICghc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgc2VsZWN0ZWRbbmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc2VsZWN0ZWRbbmFtZV0gPSAhc2VsZWN0ZWRbbmFtZV07XG4gICAgfSk7XG4gIH07XG4gIExlZ2VuZE1vZGVsLnByb3RvdHlwZS5pc1NlbGVjdGVkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbi5zZWxlY3RlZDtcbiAgICByZXR1cm4gIShzZWxlY3RlZC5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhc2VsZWN0ZWRbbmFtZV0pICYmIHpyVXRpbC5pbmRleE9mKHRoaXMuX2F2YWlsYWJsZU5hbWVzLCBuYW1lKSA+PSAwO1xuICB9O1xuICBMZWdlbmRNb2RlbC5wcm90b3R5cGUuZ2V0T3JpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnb3JpZW50JykgPT09ICd2ZXJ0aWNhbCcgPyB7XG4gICAgICBpbmRleDogMSxcbiAgICAgIG5hbWU6ICd2ZXJ0aWNhbCdcbiAgICB9IDoge1xuICAgICAgaW5kZXg6IDAsXG4gICAgICBuYW1lOiAnaG9yaXpvbnRhbCdcbiAgICB9O1xuICB9O1xuICBMZWdlbmRNb2RlbC50eXBlID0gJ2xlZ2VuZC5wbGFpbic7XG4gIExlZ2VuZE1vZGVsLmRlcGVuZGVuY2llcyA9IFsnc2VyaWVzJ107XG4gIExlZ2VuZE1vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgLy8gemxldmVsOiAwLFxuICAgIHo6IDQsXG4gICAgc2hvdzogdHJ1ZSxcbiAgICBvcmllbnQ6ICdob3Jpem9udGFsJyxcbiAgICBsZWZ0OiAnY2VudGVyJyxcbiAgICAvLyByaWdodDogJ2NlbnRlcicsXG4gICAgdG9wOiAwLFxuICAgIC8vIGJvdHRvbTogbnVsbCxcbiAgICBhbGlnbjogJ2F1dG8nLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIHBhZGRpbmc6IDUsXG4gICAgaXRlbUdhcDogMTAsXG4gICAgaXRlbVdpZHRoOiAyNSxcbiAgICBpdGVtSGVpZ2h0OiAxNCxcbiAgICBzeW1ib2xSb3RhdGU6ICdpbmhlcml0JyxcbiAgICBzeW1ib2xLZWVwQXNwZWN0OiB0cnVlLFxuICAgIGluYWN0aXZlQ29sb3I6ICcjY2NjJyxcbiAgICBpbmFjdGl2ZUJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgaW5hY3RpdmVCb3JkZXJXaWR0aDogJ2F1dG8nLFxuICAgIGl0ZW1TdHlsZToge1xuICAgICAgY29sb3I6ICdpbmhlcml0JyxcbiAgICAgIG9wYWNpdHk6ICdpbmhlcml0JyxcbiAgICAgIGJvcmRlckNvbG9yOiAnaW5oZXJpdCcsXG4gICAgICBib3JkZXJXaWR0aDogJ2F1dG8nLFxuICAgICAgYm9yZGVyQ2FwOiAnaW5oZXJpdCcsXG4gICAgICBib3JkZXJKb2luOiAnaW5oZXJpdCcsXG4gICAgICBib3JkZXJEYXNoT2Zmc2V0OiAnaW5oZXJpdCcsXG4gICAgICBib3JkZXJNaXRlckxpbWl0OiAnaW5oZXJpdCdcbiAgICB9LFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgd2lkdGg6ICdhdXRvJyxcbiAgICAgIGNvbG9yOiAnaW5oZXJpdCcsXG4gICAgICBpbmFjdGl2ZUNvbG9yOiAnI2NjYycsXG4gICAgICBpbmFjdGl2ZVdpZHRoOiAyLFxuICAgICAgb3BhY2l0eTogJ2luaGVyaXQnLFxuICAgICAgdHlwZTogJ2luaGVyaXQnLFxuICAgICAgY2FwOiAnaW5oZXJpdCcsXG4gICAgICBqb2luOiAnaW5oZXJpdCcsXG4gICAgICBkYXNoT2Zmc2V0OiAnaW5oZXJpdCcsXG4gICAgICBtaXRlckxpbWl0OiAnaW5oZXJpdCdcbiAgICB9LFxuICAgIHRleHRTdHlsZToge1xuICAgICAgY29sb3I6ICcjMzMzJ1xuICAgIH0sXG4gICAgc2VsZWN0ZWRNb2RlOiB0cnVlLFxuICAgIHNlbGVjdG9yOiBmYWxzZSxcbiAgICBzZWxlY3RvckxhYmVsOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgYm9yZGVyUmFkaXVzOiAxMCxcbiAgICAgIHBhZGRpbmc6IFszLCA1LCAzLCA1XSxcbiAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgIGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcbiAgICAgIGNvbG9yOiAnIzY2NicsXG4gICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgIGJvcmRlckNvbG9yOiAnIzY2NidcbiAgICB9LFxuICAgIGVtcGhhc2lzOiB7XG4gICAgICBzZWxlY3RvckxhYmVsOiB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIGNvbG9yOiAnI2VlZScsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyM2NjYnXG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3RvclBvc2l0aW9uOiAnYXV0bycsXG4gICAgc2VsZWN0b3JJdGVtR2FwOiA3LFxuICAgIHNlbGVjdG9yQnV0dG9uR2FwOiAxMCxcbiAgICB0b29sdGlwOiB7XG4gICAgICBzaG93OiBmYWxzZVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIExlZ2VuZE1vZGVsO1xufShDb21wb25lbnRNb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBMZWdlbmRNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBwYXJzZSwgc3RyaW5naWZ5IH0gZnJvbSAnenJlbmRlci9saWIvdG9vbC9jb2xvci5qcyc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBlbmFibGVIb3ZlckVtcGhhc2lzIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMuanMnO1xuaW1wb3J0IHsgc2V0TGFiZWxTdHlsZSwgY3JlYXRlVGV4dFN0eWxlIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG5pbXBvcnQgeyBtYWtlQmFja2dyb3VuZCB9IGZyb20gJy4uL2hlbHBlci9saXN0Q29tcG9uZW50LmpzJztcbmltcG9ydCAqIGFzIGxheW91dFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQuanMnO1xuaW1wb3J0IENvbXBvbmVudFZpZXcgZnJvbSAnLi4vLi4vdmlldy9Db21wb25lbnQuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3ltYm9sIH0gZnJvbSAnLi4vLi4vdXRpbC9zeW1ib2wuanMnO1xuaW1wb3J0IHsgY3JlYXRlT3JVcGRhdGVQYXR0ZXJuRnJvbURlY2FsIH0gZnJvbSAnLi4vLi4vdXRpbC9kZWNhbC5qcyc7XG5pbXBvcnQgeyBnZXRFQ0RhdGEgfSBmcm9tICcuLi8uLi91dGlsL2lubmVyU3RvcmUuanMnO1xudmFyIGN1cnJ5ID0genJVdGlsLmN1cnJ5O1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBHcm91cCA9IGdyYXBoaWMuR3JvdXA7XG52YXIgTGVnZW5kVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhMZWdlbmRWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBMZWdlbmRWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBMZWdlbmRWaWV3LnR5cGU7XG4gICAgX3RoaXMubmV3bGluZURpc2FibGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIExlZ2VuZFZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5fY29udGVudEdyb3VwID0gbmV3IEdyb3VwKCkpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX3NlbGVjdG9yR3JvdXAgPSBuZXcgR3JvdXAoKSk7XG4gICAgdGhpcy5faXNGaXJzdFJlbmRlciA9IHRydWU7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cbiAgTGVnZW5kVmlldy5wcm90b3R5cGUuZ2V0Q29udGVudEdyb3VwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50R3JvdXA7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cbiAgTGVnZW5kVmlldy5wcm90b3R5cGUuZ2V0U2VsZWN0b3JHcm91cCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0b3JHcm91cDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXG4gIExlZ2VuZFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGlzRmlyc3RSZW5kZXIgPSB0aGlzLl9pc0ZpcnN0UmVuZGVyO1xuICAgIHRoaXMuX2lzRmlyc3RSZW5kZXIgPSBmYWxzZTtcbiAgICB0aGlzLnJlc2V0SW5uZXIoKTtcbiAgICBpZiAoIWxlZ2VuZE1vZGVsLmdldCgnc2hvdycsIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpdGVtQWxpZ24gPSBsZWdlbmRNb2RlbC5nZXQoJ2FsaWduJyk7XG4gICAgdmFyIG9yaWVudCA9IGxlZ2VuZE1vZGVsLmdldCgnb3JpZW50Jyk7XG4gICAgaWYgKCFpdGVtQWxpZ24gfHwgaXRlbUFsaWduID09PSAnYXV0bycpIHtcbiAgICAgIGl0ZW1BbGlnbiA9IGxlZ2VuZE1vZGVsLmdldCgnbGVmdCcpID09PSAncmlnaHQnICYmIG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgfVxuICAgIC8vIHNlbGVjdG9yIGhhcyBiZWVuIG5vcm1hbGl6ZWQgdG8gYW4gYXJyYXkgaW4gbW9kZWxcbiAgICB2YXIgc2VsZWN0b3IgPSBsZWdlbmRNb2RlbC5nZXQoJ3NlbGVjdG9yJywgdHJ1ZSk7XG4gICAgdmFyIHNlbGVjdG9yUG9zaXRpb24gPSBsZWdlbmRNb2RlbC5nZXQoJ3NlbGVjdG9yUG9zaXRpb24nLCB0cnVlKTtcbiAgICBpZiAoc2VsZWN0b3IgJiYgKCFzZWxlY3RvclBvc2l0aW9uIHx8IHNlbGVjdG9yUG9zaXRpb24gPT09ICdhdXRvJykpIHtcbiAgICAgIHNlbGVjdG9yUG9zaXRpb24gPSBvcmllbnQgPT09ICdob3Jpem9udGFsJyA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJJbm5lcihpdGVtQWxpZ24sIGxlZ2VuZE1vZGVsLCBlY01vZGVsLCBhcGksIHNlbGVjdG9yLCBvcmllbnQsIHNlbGVjdG9yUG9zaXRpb24pO1xuICAgIC8vIFBlcmZvcm0gbGF5b3V0LlxuICAgIHZhciBwb3NpdGlvbkluZm8gPSBsZWdlbmRNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKTtcbiAgICB2YXIgdmlld3BvcnRTaXplID0ge1xuICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICB9O1xuICAgIHZhciBwYWRkaW5nID0gbGVnZW5kTW9kZWwuZ2V0KCdwYWRkaW5nJyk7XG4gICAgdmFyIG1heFNpemUgPSBsYXlvdXRVdGlsLmdldExheW91dFJlY3QocG9zaXRpb25JbmZvLCB2aWV3cG9ydFNpemUsIHBhZGRpbmcpO1xuICAgIHZhciBtYWluUmVjdCA9IHRoaXMubGF5b3V0SW5uZXIobGVnZW5kTW9kZWwsIGl0ZW1BbGlnbiwgbWF4U2l6ZSwgaXNGaXJzdFJlbmRlciwgc2VsZWN0b3IsIHNlbGVjdG9yUG9zaXRpb24pO1xuICAgIC8vIFBsYWNlIG1haW5Hcm91cCwgYmFzZWQgb24gdGhlIGNhbGN1bGF0ZWQgYG1haW5SZWN0YC5cbiAgICB2YXIgbGF5b3V0UmVjdCA9IGxheW91dFV0aWwuZ2V0TGF5b3V0UmVjdCh6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgd2lkdGg6IG1haW5SZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBtYWluUmVjdC5oZWlnaHRcbiAgICB9LCBwb3NpdGlvbkluZm8pLCB2aWV3cG9ydFNpemUsIHBhZGRpbmcpO1xuICAgIHRoaXMuZ3JvdXAueCA9IGxheW91dFJlY3QueCAtIG1haW5SZWN0Lng7XG4gICAgdGhpcy5ncm91cC55ID0gbGF5b3V0UmVjdC55IC0gbWFpblJlY3QueTtcbiAgICB0aGlzLmdyb3VwLm1hcmtSZWRyYXcoKTtcbiAgICAvLyBSZW5kZXIgYmFja2dyb3VuZCBhZnRlciBncm91cCBpcyBsYXlvdXQuXG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5fYmFja2dyb3VuZEVsID0gbWFrZUJhY2tncm91bmQobWFpblJlY3QsIGxlZ2VuZE1vZGVsKSk7XG4gIH07XG4gIExlZ2VuZFZpZXcucHJvdG90eXBlLnJlc2V0SW5uZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5nZXRDb250ZW50R3JvdXAoKS5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kRWwgJiYgdGhpcy5ncm91cC5yZW1vdmUodGhpcy5fYmFja2dyb3VuZEVsKTtcbiAgICB0aGlzLmdldFNlbGVjdG9yR3JvdXAoKS5yZW1vdmVBbGwoKTtcbiAgfTtcbiAgTGVnZW5kVmlldy5wcm90b3R5cGUucmVuZGVySW5uZXIgPSBmdW5jdGlvbiAoaXRlbUFsaWduLCBsZWdlbmRNb2RlbCwgZWNNb2RlbCwgYXBpLCBzZWxlY3Rvciwgb3JpZW50LCBzZWxlY3RvclBvc2l0aW9uKSB7XG4gICAgdmFyIGNvbnRlbnRHcm91cCA9IHRoaXMuZ2V0Q29udGVudEdyb3VwKCk7XG4gICAgdmFyIGxlZ2VuZERyYXduTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgICB2YXIgc2VsZWN0TW9kZSA9IGxlZ2VuZE1vZGVsLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG4gICAgdmFyIGV4Y2x1ZGVTZXJpZXNJZCA9IFtdO1xuICAgIGVjTW9kZWwuZWFjaFJhd1NlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICFzZXJpZXNNb2RlbC5nZXQoJ2xlZ2VuZEhvdmVyTGluaycpICYmIGV4Y2x1ZGVTZXJpZXNJZC5wdXNoKHNlcmllc01vZGVsLmlkKTtcbiAgICB9KTtcbiAgICBlYWNoKGxlZ2VuZE1vZGVsLmdldERhdGEoKSwgZnVuY3Rpb24gKGxlZ2VuZEl0ZW1Nb2RlbCwgZGF0YUluZGV4KSB7XG4gICAgICB2YXIgbmFtZSA9IGxlZ2VuZEl0ZW1Nb2RlbC5nZXQoJ25hbWUnKTtcbiAgICAgIC8vIFVzZSBlbXB0eSBzdHJpbmcgb3IgXFxuIGFzIGEgbmV3bGluZSBzdHJpbmdcbiAgICAgIGlmICghdGhpcy5uZXdsaW5lRGlzYWJsZWQgJiYgKG5hbWUgPT09ICcnIHx8IG5hbWUgPT09ICdcXG4nKSkge1xuICAgICAgICB2YXIgZyA9IG5ldyBHcm91cCgpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGcubmV3bGluZSA9IHRydWU7XG4gICAgICAgIGNvbnRlbnRHcm91cC5hZGQoZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJlcHJlc2VudGl0aXZlIHNlcmllcy5cbiAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlOYW1lKG5hbWUpWzBdO1xuICAgICAgaWYgKGxlZ2VuZERyYXduTWFwLmdldChuYW1lKSkge1xuICAgICAgICAvLyBIYXZlIGJlZW4gZHJhd25cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gTGVnZW5kIHRvIGNvbnRyb2wgc2VyaWVzLlxuICAgICAgaWYgKHNlcmllc01vZGVsKSB7XG4gICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgbGluZVZpc3VhbFN0eWxlID0gZGF0YS5nZXRWaXN1YWwoJ2xlZ2VuZExpbmVTdHlsZScpIHx8IHt9O1xuICAgICAgICB2YXIgbGVnZW5kSWNvbiA9IGRhdGEuZ2V0VmlzdWFsKCdsZWdlbmRJY29uJyk7XG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGBkYXRhLmdldFZpc3VhbCgnc3R5bGUnKWAgbWF5IGJlIHRoZSBjb2xvciBmcm9tIHRoZSByZWdpc3RlclxyXG4gICAgICAgICAqIGluIHNlcmllcy4gRm9yIGV4YW1wbGUsIGZvciBsaW5lIHNlcmllcyxcclxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHN0eWxlID0gZGF0YS5nZXRWaXN1YWwoJ3N0eWxlJyk7XG4gICAgICAgIHZhciBpdGVtR3JvdXAgPSB0aGlzLl9jcmVhdGVJdGVtKHNlcmllc01vZGVsLCBuYW1lLCBkYXRhSW5kZXgsIGxlZ2VuZEl0ZW1Nb2RlbCwgbGVnZW5kTW9kZWwsIGl0ZW1BbGlnbiwgbGluZVZpc3VhbFN0eWxlLCBzdHlsZSwgbGVnZW5kSWNvbiwgc2VsZWN0TW9kZSwgYXBpKTtcbiAgICAgICAgaXRlbUdyb3VwLm9uKCdjbGljaycsIGN1cnJ5KGRpc3BhdGNoU2VsZWN0QWN0aW9uLCBuYW1lLCBudWxsLCBhcGksIGV4Y2x1ZGVTZXJpZXNJZCkpLm9uKCdtb3VzZW92ZXInLCBjdXJyeShkaXNwYXRjaEhpZ2hsaWdodEFjdGlvbiwgc2VyaWVzTW9kZWwubmFtZSwgbnVsbCwgYXBpLCBleGNsdWRlU2VyaWVzSWQpKS5vbignbW91c2VvdXQnLCBjdXJyeShkaXNwYXRjaERvd25wbGF5QWN0aW9uLCBzZXJpZXNNb2RlbC5uYW1lLCBudWxsLCBhcGksIGV4Y2x1ZGVTZXJpZXNJZCkpO1xuICAgICAgICBpZiAoZWNNb2RlbC5zc3IpIHtcbiAgICAgICAgICBpdGVtR3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdmFyIGVjRGF0YSA9IGdldEVDRGF0YShjaGlsZCk7XG4gICAgICAgICAgICBlY0RhdGEuc2VyaWVzSW5kZXggPSBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleDtcbiAgICAgICAgICAgIGVjRGF0YS5kYXRhSW5kZXggPSBkYXRhSW5kZXg7XG4gICAgICAgICAgICBlY0RhdGEuc3NyVHlwZSA9ICdsZWdlbmQnO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxlZ2VuZERyYXduTWFwLnNldChuYW1lLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExlZ2VuZCB0byBjb250cm9sIGRhdGEuIEluIHBpZSBhbmQgZnVubmVsLlxuICAgICAgICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgLy8gSW4gY2FzZSBtdWx0aXBsZSBzZXJpZXMgaGFzIHNhbWUgZGF0YSBuYW1lXG4gICAgICAgICAgaWYgKGxlZ2VuZERyYXduTWFwLmdldChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VyaWVzTW9kZWwubGVnZW5kVmlzdWFsUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IHNlcmllc01vZGVsLmxlZ2VuZFZpc3VhbFByb3ZpZGVyO1xuICAgICAgICAgICAgaWYgKCFwcm92aWRlci5jb250YWluTmFtZShuYW1lKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWR4ID0gcHJvdmlkZXIuaW5kZXhPZk5hbWUobmFtZSk7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBwcm92aWRlci5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJyk7XG4gICAgICAgICAgICB2YXIgbGVnZW5kSWNvbiA9IHByb3ZpZGVyLmdldEl0ZW1WaXN1YWwoaWR4LCAnbGVnZW5kSWNvbicpO1xuICAgICAgICAgICAgdmFyIGNvbG9yQXJyID0gcGFyc2Uoc3R5bGUuZmlsbCk7XG4gICAgICAgICAgICAvLyBDb2xvciBtYXkgYmUgc2V0IHRvIHRyYW5zcGFyZW50IGluIHZpc3VhbE1hcCB3aGVuIGRhdGEgaXMgb3V0IG9mIHJhbmdlLlxuICAgICAgICAgICAgLy8gRG8gbm90IHNob3cgbm90aGluZy5cbiAgICAgICAgICAgIGlmIChjb2xvckFyciAmJiBjb2xvckFyclszXSA9PT0gMCkge1xuICAgICAgICAgICAgICBjb2xvckFyclszXSA9IDAuMjtcbiAgICAgICAgICAgICAgLy8gVE9ETyBjb2xvciBpcyBzZXQgdG8gMCwgMCwgMCwgMC4gU2hvdWxkIHNob3cgY29ycmVjdCBSR0JBXG4gICAgICAgICAgICAgIHN0eWxlID0genJVdGlsLmV4dGVuZCh6clV0aWwuZXh0ZW5kKHt9LCBzdHlsZSksIHtcbiAgICAgICAgICAgICAgICBmaWxsOiBzdHJpbmdpZnkoY29sb3JBcnIsICdyZ2JhJylcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXRlbUdyb3VwID0gdGhpcy5fY3JlYXRlSXRlbShzZXJpZXNNb2RlbCwgbmFtZSwgZGF0YUluZGV4LCBsZWdlbmRJdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLCBpdGVtQWxpZ24sIHt9LCBzdHlsZSwgbGVnZW5kSWNvbiwgc2VsZWN0TW9kZSwgYXBpKTtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBjb25zaWRlciBkaWZmZXJlbnQgc2VyaWVzIGhhcyBpdGVtcyB3aXRoIHRoZSBzYW1lIG5hbWUuXG4gICAgICAgICAgICBpdGVtR3JvdXAub24oJ2NsaWNrJywgY3VycnkoZGlzcGF0Y2hTZWxlY3RBY3Rpb24sIG51bGwsIG5hbWUsIGFwaSwgZXhjbHVkZVNlcmllc0lkKSlcbiAgICAgICAgICAgIC8vIFNob3VsZCBub3Qgc3BlY2lmeSB0aGUgc2VyaWVzIG5hbWUsIGNvbnNpZGVyIGxlZ2VuZCBjb250cm9sc1xuICAgICAgICAgICAgLy8gbW9yZSB0aGFuIG9uZSBwaWUgc2VyaWVzLlxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBjdXJyeShkaXNwYXRjaEhpZ2hsaWdodEFjdGlvbiwgbnVsbCwgbmFtZSwgYXBpLCBleGNsdWRlU2VyaWVzSWQpKS5vbignbW91c2VvdXQnLCBjdXJyeShkaXNwYXRjaERvd25wbGF5QWN0aW9uLCBudWxsLCBuYW1lLCBhcGksIGV4Y2x1ZGVTZXJpZXNJZCkpO1xuICAgICAgICAgICAgaWYgKGVjTW9kZWwuc3NyKSB7XG4gICAgICAgICAgICAgIGl0ZW1Hcm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVjRGF0YSA9IGdldEVDRGF0YShjaGlsZCk7XG4gICAgICAgICAgICAgICAgZWNEYXRhLnNlcmllc0luZGV4ID0gc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXg7XG4gICAgICAgICAgICAgICAgZWNEYXRhLmRhdGFJbmRleCA9IGRhdGFJbmRleDtcbiAgICAgICAgICAgICAgICBlY0RhdGEuc3NyVHlwZSA9ICdsZWdlbmQnO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlZ2VuZERyYXduTWFwLnNldChuYW1lLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKCFsZWdlbmREcmF3bk1hcC5nZXQobmFtZSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArICcgc2VyaWVzIG5vdCBleGlzdHMuIExlZ2VuZCBkYXRhIHNob3VsZCBiZSBzYW1lIHdpdGggc2VyaWVzIG5hbWUgb3IgZGF0YSBuYW1lLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICB0aGlzLl9jcmVhdGVTZWxlY3RvcihzZWxlY3RvciwgbGVnZW5kTW9kZWwsIGFwaSwgb3JpZW50LCBzZWxlY3RvclBvc2l0aW9uKTtcbiAgICB9XG4gIH07XG4gIExlZ2VuZFZpZXcucHJvdG90eXBlLl9jcmVhdGVTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3RvciwgbGVnZW5kTW9kZWwsIGFwaSwgb3JpZW50LCBzZWxlY3RvclBvc2l0aW9uKSB7XG4gICAgdmFyIHNlbGVjdG9yR3JvdXAgPSB0aGlzLmdldFNlbGVjdG9yR3JvdXAoKTtcbiAgICBlYWNoKHNlbGVjdG9yLCBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvckJ1dHRvbihzZWxlY3Rvckl0ZW0pIHtcbiAgICAgIHZhciB0eXBlID0gc2VsZWN0b3JJdGVtLnR5cGU7XG4gICAgICB2YXIgbGFiZWxUZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJ1xuICAgICAgICB9LFxuICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUgPT09ICdhbGwnID8gJ2xlZ2VuZEFsbFNlbGVjdCcgOiAnbGVnZW5kSW52ZXJzZVNlbGVjdCcsXG4gICAgICAgICAgICBsZWdlbmRJZDogbGVnZW5kTW9kZWwuaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZWxlY3Rvckdyb3VwLmFkZChsYWJlbFRleHQpO1xuICAgICAgdmFyIGxhYmVsTW9kZWwgPSBsZWdlbmRNb2RlbC5nZXRNb2RlbCgnc2VsZWN0b3JMYWJlbCcpO1xuICAgICAgdmFyIGVtcGhhc2lzTGFiZWxNb2RlbCA9IGxlZ2VuZE1vZGVsLmdldE1vZGVsKFsnZW1waGFzaXMnLCAnc2VsZWN0b3JMYWJlbCddKTtcbiAgICAgIHNldExhYmVsU3R5bGUobGFiZWxUZXh0LCB7XG4gICAgICAgIG5vcm1hbDogbGFiZWxNb2RlbCxcbiAgICAgICAgZW1waGFzaXM6IGVtcGhhc2lzTGFiZWxNb2RlbFxuICAgICAgfSwge1xuICAgICAgICBkZWZhdWx0VGV4dDogc2VsZWN0b3JJdGVtLnRpdGxlXG4gICAgICB9KTtcbiAgICAgIGVuYWJsZUhvdmVyRW1waGFzaXMobGFiZWxUZXh0KTtcbiAgICB9KTtcbiAgfTtcbiAgTGVnZW5kVmlldy5wcm90b3R5cGUuX2NyZWF0ZUl0ZW0gPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIG5hbWUsIGRhdGFJbmRleCwgbGVnZW5kSXRlbU1vZGVsLCBsZWdlbmRNb2RlbCwgaXRlbUFsaWduLCBsaW5lVmlzdWFsU3R5bGUsIGl0ZW1WaXN1YWxTdHlsZSwgbGVnZW5kSWNvbiwgc2VsZWN0TW9kZSwgYXBpKSB7XG4gICAgdmFyIGRyYXdUeXBlID0gc2VyaWVzTW9kZWwudmlzdWFsRHJhd1R5cGU7XG4gICAgdmFyIGl0ZW1XaWR0aCA9IGxlZ2VuZE1vZGVsLmdldCgnaXRlbVdpZHRoJyk7XG4gICAgdmFyIGl0ZW1IZWlnaHQgPSBsZWdlbmRNb2RlbC5nZXQoJ2l0ZW1IZWlnaHQnKTtcbiAgICB2YXIgaXNTZWxlY3RlZCA9IGxlZ2VuZE1vZGVsLmlzU2VsZWN0ZWQobmFtZSk7XG4gICAgdmFyIGljb25Sb3RhdGUgPSBsZWdlbmRJdGVtTW9kZWwuZ2V0KCdzeW1ib2xSb3RhdGUnKTtcbiAgICB2YXIgc3ltYm9sS2VlcEFzcGVjdCA9IGxlZ2VuZEl0ZW1Nb2RlbC5nZXQoJ3N5bWJvbEtlZXBBc3BlY3QnKTtcbiAgICB2YXIgbGVnZW5kSWNvblR5cGUgPSBsZWdlbmRJdGVtTW9kZWwuZ2V0KCdpY29uJyk7XG4gICAgbGVnZW5kSWNvbiA9IGxlZ2VuZEljb25UeXBlIHx8IGxlZ2VuZEljb24gfHwgJ3JvdW5kUmVjdCc7XG4gICAgdmFyIHN0eWxlID0gZ2V0TGVnZW5kU3R5bGUobGVnZW5kSWNvbiwgbGVnZW5kSXRlbU1vZGVsLCBsaW5lVmlzdWFsU3R5bGUsIGl0ZW1WaXN1YWxTdHlsZSwgZHJhd1R5cGUsIGlzU2VsZWN0ZWQsIGFwaSk7XG4gICAgdmFyIGl0ZW1Hcm91cCA9IG5ldyBHcm91cCgpO1xuICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGxlZ2VuZEl0ZW1Nb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKHNlcmllc01vZGVsLmdldExlZ2VuZEljb24pICYmICghbGVnZW5kSWNvblR5cGUgfHwgbGVnZW5kSWNvblR5cGUgPT09ICdpbmhlcml0JykpIHtcbiAgICAgIC8vIFNlcmllcyBoYXMgc3BlY2lmaWMgd2F5IHRvIGRlZmluZSBsZWdlbmQgaWNvblxuICAgICAgaXRlbUdyb3VwLmFkZChzZXJpZXNNb2RlbC5nZXRMZWdlbmRJY29uKHtcbiAgICAgICAgaXRlbVdpZHRoOiBpdGVtV2lkdGgsXG4gICAgICAgIGl0ZW1IZWlnaHQ6IGl0ZW1IZWlnaHQsXG4gICAgICAgIGljb246IGxlZ2VuZEljb24sXG4gICAgICAgIGljb25Sb3RhdGU6IGljb25Sb3RhdGUsXG4gICAgICAgIGl0ZW1TdHlsZTogc3R5bGUuaXRlbVN0eWxlLFxuICAgICAgICBsaW5lU3R5bGU6IHN0eWxlLmxpbmVTdHlsZSxcbiAgICAgICAgc3ltYm9sS2VlcEFzcGVjdDogc3ltYm9sS2VlcEFzcGVjdFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2UgZGVmYXVsdCBsZWdlbmQgaWNvbiBwb2xpY3kgZm9yIG1vc3Qgc2VyaWVzXG4gICAgICB2YXIgcm90YXRlID0gbGVnZW5kSWNvblR5cGUgPT09ICdpbmhlcml0JyAmJiBzZXJpZXNNb2RlbC5nZXREYXRhKCkuZ2V0VmlzdWFsKCdzeW1ib2wnKSA/IGljb25Sb3RhdGUgPT09ICdpbmhlcml0JyA/IHNlcmllc01vZGVsLmdldERhdGEoKS5nZXRWaXN1YWwoJ3N5bWJvbFJvdGF0ZScpIDogaWNvblJvdGF0ZSA6IDA7IC8vIE5vIHJvdGF0aW9uIGZvciBubyBpY29uXG4gICAgICBpdGVtR3JvdXAuYWRkKGdldERlZmF1bHRMZWdlbmRJY29uKHtcbiAgICAgICAgaXRlbVdpZHRoOiBpdGVtV2lkdGgsXG4gICAgICAgIGl0ZW1IZWlnaHQ6IGl0ZW1IZWlnaHQsXG4gICAgICAgIGljb246IGxlZ2VuZEljb24sXG4gICAgICAgIGljb25Sb3RhdGU6IHJvdGF0ZSxcbiAgICAgICAgaXRlbVN0eWxlOiBzdHlsZS5pdGVtU3R5bGUsXG4gICAgICAgIGxpbmVTdHlsZTogc3R5bGUubGluZVN0eWxlLFxuICAgICAgICBzeW1ib2xLZWVwQXNwZWN0OiBzeW1ib2xLZWVwQXNwZWN0XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHZhciB0ZXh0WCA9IGl0ZW1BbGlnbiA9PT0gJ2xlZnQnID8gaXRlbVdpZHRoICsgNSA6IC01O1xuICAgIHZhciB0ZXh0QWxpZ24gPSBpdGVtQWxpZ247XG4gICAgdmFyIGZvcm1hdHRlciA9IGxlZ2VuZE1vZGVsLmdldCgnZm9ybWF0dGVyJyk7XG4gICAgdmFyIGNvbnRlbnQgPSBuYW1lO1xuICAgIGlmICh6clV0aWwuaXNTdHJpbmcoZm9ybWF0dGVyKSAmJiBmb3JtYXR0ZXIpIHtcbiAgICAgIGNvbnRlbnQgPSBmb3JtYXR0ZXIucmVwbGFjZSgne25hbWV9JywgbmFtZSAhPSBudWxsID8gbmFtZSA6ICcnKTtcbiAgICB9IGVsc2UgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKGZvcm1hdHRlcikpIHtcbiAgICAgIGNvbnRlbnQgPSBmb3JtYXR0ZXIobmFtZSk7XG4gICAgfVxuICAgIHZhciB0ZXh0Q29sb3IgPSBpc1NlbGVjdGVkID8gdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCkgOiBsZWdlbmRJdGVtTW9kZWwuZ2V0KCdpbmFjdGl2ZUNvbG9yJyk7XG4gICAgaXRlbUdyb3VwLmFkZChuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUodGV4dFN0eWxlTW9kZWwsIHtcbiAgICAgICAgdGV4dDogY29udGVudCxcbiAgICAgICAgeDogdGV4dFgsXG4gICAgICAgIHk6IGl0ZW1IZWlnaHQgLyAyLFxuICAgICAgICBmaWxsOiB0ZXh0Q29sb3IsXG4gICAgICAgIGFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgICB9LCB7XG4gICAgICAgIGluaGVyaXRDb2xvcjogdGV4dENvbG9yXG4gICAgICB9KVxuICAgIH0pKTtcbiAgICAvLyBBZGQgYSBpbnZpc2libGUgcmVjdCB0byBpbmNyZWFzZSB0aGUgYXJlYSBvZiBtb3VzZSBob3ZlclxuICAgIHZhciBoaXRSZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICBzaGFwZTogaXRlbUdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgLy8gQ2Fubm90IHVzZSAnaW52aXNpYmxlJyBiZWNhdXNlIFNWRyBTU1Igd2lsbCBtaXNzIHRoZSBub2RlXG4gICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCdcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgdG9vbHRpcE1vZGVsID0gbGVnZW5kSXRlbU1vZGVsLmdldE1vZGVsKCd0b29sdGlwJyk7XG4gICAgaWYgKHRvb2x0aXBNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgZ3JhcGhpYy5zZXRUb29sdGlwQ29uZmlnKHtcbiAgICAgICAgZWw6IGhpdFJlY3QsXG4gICAgICAgIGNvbXBvbmVudE1vZGVsOiBsZWdlbmRNb2RlbCxcbiAgICAgICAgaXRlbU5hbWU6IG5hbWUsXG4gICAgICAgIGl0ZW1Ub29sdGlwT3B0aW9uOiB0b29sdGlwTW9kZWwub3B0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gICAgaXRlbUdyb3VwLmFkZChoaXRSZWN0KTtcbiAgICBpdGVtR3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgY2hpbGQuc2lsZW50ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBoaXRSZWN0LnNpbGVudCA9ICFzZWxlY3RNb2RlO1xuICAgIHRoaXMuZ2V0Q29udGVudEdyb3VwKCkuYWRkKGl0ZW1Hcm91cCk7XG4gICAgZW5hYmxlSG92ZXJFbXBoYXNpcyhpdGVtR3JvdXApO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpdGVtR3JvdXAuX19sZWdlbmREYXRhSW5kZXggPSBkYXRhSW5kZXg7XG4gICAgcmV0dXJuIGl0ZW1Hcm91cDtcbiAgfTtcbiAgTGVnZW5kVmlldy5wcm90b3R5cGUubGF5b3V0SW5uZXIgPSBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIGl0ZW1BbGlnbiwgbWF4U2l6ZSwgaXNGaXJzdFJlbmRlciwgc2VsZWN0b3IsIHNlbGVjdG9yUG9zaXRpb24pIHtcbiAgICB2YXIgY29udGVudEdyb3VwID0gdGhpcy5nZXRDb250ZW50R3JvdXAoKTtcbiAgICB2YXIgc2VsZWN0b3JHcm91cCA9IHRoaXMuZ2V0U2VsZWN0b3JHcm91cCgpO1xuICAgIC8vIFBsYWNlIGl0ZW1zIGluIGNvbnRlbnRHcm91cC5cbiAgICBsYXlvdXRVdGlsLmJveChsZWdlbmRNb2RlbC5nZXQoJ29yaWVudCcpLCBjb250ZW50R3JvdXAsIGxlZ2VuZE1vZGVsLmdldCgnaXRlbUdhcCcpLCBtYXhTaXplLndpZHRoLCBtYXhTaXplLmhlaWdodCk7XG4gICAgdmFyIGNvbnRlbnRSZWN0ID0gY29udGVudEdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBjb250ZW50UG9zID0gWy1jb250ZW50UmVjdC54LCAtY29udGVudFJlY3QueV07XG4gICAgc2VsZWN0b3JHcm91cC5tYXJrUmVkcmF3KCk7XG4gICAgY29udGVudEdyb3VwLm1hcmtSZWRyYXcoKTtcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIC8vIFBsYWNlIGJ1dHRvbnMgaW4gc2VsZWN0b3JHcm91cFxuICAgICAgbGF5b3V0VXRpbC5ib3goXG4gICAgICAvLyBCdXR0b25zIGluIHNlbGVjdG9yR3JvdXAgYWx3YXlzIGxheW91dCBob3Jpem9udGFsbHlcbiAgICAgICdob3Jpem9udGFsJywgc2VsZWN0b3JHcm91cCwgbGVnZW5kTW9kZWwuZ2V0KCdzZWxlY3Rvckl0ZW1HYXAnLCB0cnVlKSk7XG4gICAgICB2YXIgc2VsZWN0b3JSZWN0ID0gc2VsZWN0b3JHcm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgIHZhciBzZWxlY3RvclBvcyA9IFstc2VsZWN0b3JSZWN0LngsIC1zZWxlY3RvclJlY3QueV07XG4gICAgICB2YXIgc2VsZWN0b3JCdXR0b25HYXAgPSBsZWdlbmRNb2RlbC5nZXQoJ3NlbGVjdG9yQnV0dG9uR2FwJywgdHJ1ZSk7XG4gICAgICB2YXIgb3JpZW50SWR4ID0gbGVnZW5kTW9kZWwuZ2V0T3JpZW50KCkuaW5kZXg7XG4gICAgICB2YXIgd2ggPSBvcmllbnRJZHggPT09IDAgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICB2YXIgaHcgPSBvcmllbnRJZHggPT09IDAgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICB2YXIgeXggPSBvcmllbnRJZHggPT09IDAgPyAneScgOiAneCc7XG4gICAgICBpZiAoc2VsZWN0b3JQb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgc2VsZWN0b3JQb3Nbb3JpZW50SWR4XSArPSBjb250ZW50UmVjdFt3aF0gKyBzZWxlY3RvckJ1dHRvbkdhcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnRQb3Nbb3JpZW50SWR4XSArPSBzZWxlY3RvclJlY3Rbd2hdICsgc2VsZWN0b3JCdXR0b25HYXA7XG4gICAgICB9XG4gICAgICAvLyBBbHdheXMgYWxpZ24gc2VsZWN0b3IgdG8gY29udGVudCBhcyAnbWlkZGxlJ1xuICAgICAgc2VsZWN0b3JQb3NbMSAtIG9yaWVudElkeF0gKz0gY29udGVudFJlY3RbaHddIC8gMiAtIHNlbGVjdG9yUmVjdFtod10gLyAyO1xuICAgICAgc2VsZWN0b3JHcm91cC54ID0gc2VsZWN0b3JQb3NbMF07XG4gICAgICBzZWxlY3Rvckdyb3VwLnkgPSBzZWxlY3RvclBvc1sxXTtcbiAgICAgIGNvbnRlbnRHcm91cC54ID0gY29udGVudFBvc1swXTtcbiAgICAgIGNvbnRlbnRHcm91cC55ID0gY29udGVudFBvc1sxXTtcbiAgICAgIHZhciBtYWluUmVjdCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIG1haW5SZWN0W3doXSA9IGNvbnRlbnRSZWN0W3doXSArIHNlbGVjdG9yQnV0dG9uR2FwICsgc2VsZWN0b3JSZWN0W3doXTtcbiAgICAgIG1haW5SZWN0W2h3XSA9IE1hdGgubWF4KGNvbnRlbnRSZWN0W2h3XSwgc2VsZWN0b3JSZWN0W2h3XSk7XG4gICAgICBtYWluUmVjdFt5eF0gPSBNYXRoLm1pbigwLCBzZWxlY3RvclJlY3RbeXhdICsgc2VsZWN0b3JQb3NbMSAtIG9yaWVudElkeF0pO1xuICAgICAgcmV0dXJuIG1haW5SZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50R3JvdXAueCA9IGNvbnRlbnRQb3NbMF07XG4gICAgICBjb250ZW50R3JvdXAueSA9IGNvbnRlbnRQb3NbMV07XG4gICAgICByZXR1cm4gdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cbiAgTGVnZW5kVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZ2V0Q29udGVudEdyb3VwKCkucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5faXNGaXJzdFJlbmRlciA9IHRydWU7XG4gIH07XG4gIExlZ2VuZFZpZXcudHlwZSA9ICdsZWdlbmQucGxhaW4nO1xuICByZXR1cm4gTGVnZW5kVmlldztcbn0oQ29tcG9uZW50Vmlldyk7XG5mdW5jdGlvbiBnZXRMZWdlbmRTdHlsZShpY29uVHlwZSwgbGVnZW5kSXRlbU1vZGVsLCBsaW5lVmlzdWFsU3R5bGUsIGl0ZW1WaXN1YWxTdHlsZSwgZHJhd1R5cGUsIGlzU2VsZWN0ZWQsIGFwaSkge1xuICAvKipcclxuICAgKiBVc2Ugc2VyaWVzIHN0eWxlIGlmIGlzIGluaGVyaXQ7XHJcbiAgICogZWxzZXdpc2UsIHVzZSBsZWdlbmQgc3R5bGVcclxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlQ29tbW9uUHJvcHMoc3R5bGUsIHZpc3VhbFN0eWxlKSB7XG4gICAgLy8gSWYgbGluZVN0eWxlLndpZHRoIGlzICdhdXRvJywgaXQgaXMgc2V0IHRvIGJlIDIgaWYgc2VyaWVzIGhhcyBib3JkZXJcbiAgICBpZiAoc3R5bGUubGluZVdpZHRoID09PSAnYXV0bycpIHtcbiAgICAgIHN0eWxlLmxpbmVXaWR0aCA9IHZpc3VhbFN0eWxlLmxpbmVXaWR0aCA+IDAgPyAyIDogMDtcbiAgICB9XG4gICAgZWFjaChzdHlsZSwgZnVuY3Rpb24gKHByb3BWYWwsIHByb3BOYW1lKSB7XG4gICAgICBzdHlsZVtwcm9wTmFtZV0gPT09ICdpbmhlcml0JyAmJiAoc3R5bGVbcHJvcE5hbWVdID0gdmlzdWFsU3R5bGVbcHJvcE5hbWVdKTtcbiAgICB9KTtcbiAgfVxuICAvLyBpdGVtU3R5bGVcbiAgdmFyIGl0ZW1TdHlsZU1vZGVsID0gbGVnZW5kSXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKTtcbiAgdmFyIGl0ZW1TdHlsZSA9IGl0ZW1TdHlsZU1vZGVsLmdldEl0ZW1TdHlsZSgpO1xuICB2YXIgaWNvbkJydXNoVHlwZSA9IGljb25UeXBlLmxhc3RJbmRleE9mKCdlbXB0eScsIDApID09PSAwID8gJ2ZpbGwnIDogJ3N0cm9rZSc7XG4gIHZhciBkZWNhbFN0eWxlID0gaXRlbVN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZGVjYWwnKTtcbiAgaXRlbVN0eWxlLmRlY2FsID0gIWRlY2FsU3R5bGUgfHwgZGVjYWxTdHlsZSA9PT0gJ2luaGVyaXQnID8gaXRlbVZpc3VhbFN0eWxlLmRlY2FsIDogY3JlYXRlT3JVcGRhdGVQYXR0ZXJuRnJvbURlY2FsKGRlY2FsU3R5bGUsIGFwaSk7XG4gIGlmIChpdGVtU3R5bGUuZmlsbCA9PT0gJ2luaGVyaXQnKSB7XG4gICAgLyoqXHJcbiAgICAgKiBTZXJpZXMgd2l0aCB2aXN1YWxEcmF3VHlwZSBhcyAnc3Ryb2tlJyBzaG91bGQgaGF2ZVxyXG4gICAgICogc2VyaWVzIHN0cm9rZSBhcyBsZWdlbmQgZmlsbFxyXG4gICAgICovXG4gICAgaXRlbVN0eWxlLmZpbGwgPSBpdGVtVmlzdWFsU3R5bGVbZHJhd1R5cGVdO1xuICB9XG4gIGlmIChpdGVtU3R5bGUuc3Ryb2tlID09PSAnaW5oZXJpdCcpIHtcbiAgICAvKipcclxuICAgICAqIGljb24gdHlwZSB3aXRoIFwiZW1wdHlYWFhcIiBzaG91bGQgdXNlIGZpbGwgY29sb3JcclxuICAgICAqIGluIHZpc3VhbCBzdHlsZVxyXG4gICAgICovXG4gICAgaXRlbVN0eWxlLnN0cm9rZSA9IGl0ZW1WaXN1YWxTdHlsZVtpY29uQnJ1c2hUeXBlXTtcbiAgfVxuICBpZiAoaXRlbVN0eWxlLm9wYWNpdHkgPT09ICdpbmhlcml0Jykge1xuICAgIC8qKlxyXG4gICAgICogVXNlIGxpbmVTdHlsZS5vcGFjaXR5IGlmIGRyYXdUeXBlIGlzIHN0cm9rZVxyXG4gICAgICovXG4gICAgaXRlbVN0eWxlLm9wYWNpdHkgPSAoZHJhd1R5cGUgPT09ICdmaWxsJyA/IGl0ZW1WaXN1YWxTdHlsZSA6IGxpbmVWaXN1YWxTdHlsZSkub3BhY2l0eTtcbiAgfVxuICBoYW5kbGVDb21tb25Qcm9wcyhpdGVtU3R5bGUsIGl0ZW1WaXN1YWxTdHlsZSk7XG4gIC8vIGxpbmVTdHlsZVxuICB2YXIgbGVnZW5kTGluZU1vZGVsID0gbGVnZW5kSXRlbU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgdmFyIGxpbmVTdHlsZSA9IGxlZ2VuZExpbmVNb2RlbC5nZXRMaW5lU3R5bGUoKTtcbiAgaGFuZGxlQ29tbW9uUHJvcHMobGluZVN0eWxlLCBsaW5lVmlzdWFsU3R5bGUpO1xuICAvLyBGaXggYXV0byBjb2xvciB0byByZWFsIGNvbG9yXG4gIGl0ZW1TdHlsZS5maWxsID09PSAnYXV0bycgJiYgKGl0ZW1TdHlsZS5maWxsID0gaXRlbVZpc3VhbFN0eWxlLmZpbGwpO1xuICBpdGVtU3R5bGUuc3Ryb2tlID09PSAnYXV0bycgJiYgKGl0ZW1TdHlsZS5zdHJva2UgPSBpdGVtVmlzdWFsU3R5bGUuZmlsbCk7XG4gIGxpbmVTdHlsZS5zdHJva2UgPT09ICdhdXRvJyAmJiAobGluZVN0eWxlLnN0cm9rZSA9IGl0ZW1WaXN1YWxTdHlsZS5maWxsKTtcbiAgaWYgKCFpc1NlbGVjdGVkKSB7XG4gICAgdmFyIGJvcmRlcldpZHRoID0gbGVnZW5kSXRlbU1vZGVsLmdldCgnaW5hY3RpdmVCb3JkZXJXaWR0aCcpO1xuICAgIC8qKlxyXG4gICAgICogU2luY2Ugc3Ryb2tlIGlzIHNldCB0byBiZSBpbmFjdGl2ZUJvcmRlckNvbG9yLCBpdCBtYXkgb2NjdXIgdGhhdFxyXG4gICAgICogdGhlcmUgaXMgbm8gYm9yZGVyIGluIHNlcmllcyBidXQgYm9yZGVyIGluIGxlZ2VuZCwgc28gd2UgbmVlZCB0b1xyXG4gICAgICogdXNlIGJvcmRlciBvbmx5IHdoZW4gc2VyaWVzIGhhcyBib3JkZXIgaWYgaXMgc2V0IHRvIGJlIGF1dG9cclxuICAgICAqL1xuICAgIHZhciB2aXN1YWxIYXNCb3JkZXIgPSBpdGVtU3R5bGVbaWNvbkJydXNoVHlwZV07XG4gICAgaXRlbVN0eWxlLmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoID09PSAnYXV0bycgPyBpdGVtVmlzdWFsU3R5bGUubGluZVdpZHRoID4gMCAmJiB2aXN1YWxIYXNCb3JkZXIgPyAyIDogMCA6IGl0ZW1TdHlsZS5saW5lV2lkdGg7XG4gICAgaXRlbVN0eWxlLmZpbGwgPSBsZWdlbmRJdGVtTW9kZWwuZ2V0KCdpbmFjdGl2ZUNvbG9yJyk7XG4gICAgaXRlbVN0eWxlLnN0cm9rZSA9IGxlZ2VuZEl0ZW1Nb2RlbC5nZXQoJ2luYWN0aXZlQm9yZGVyQ29sb3InKTtcbiAgICBsaW5lU3R5bGUuc3Ryb2tlID0gbGVnZW5kTGluZU1vZGVsLmdldCgnaW5hY3RpdmVDb2xvcicpO1xuICAgIGxpbmVTdHlsZS5saW5lV2lkdGggPSBsZWdlbmRMaW5lTW9kZWwuZ2V0KCdpbmFjdGl2ZVdpZHRoJyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpdGVtU3R5bGU6IGl0ZW1TdHlsZSxcbiAgICBsaW5lU3R5bGU6IGxpbmVTdHlsZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdExlZ2VuZEljb24ob3B0KSB7XG4gIHZhciBzeW1ib1R5cGUgPSBvcHQuaWNvbiB8fCAncm91bmRSZWN0JztcbiAgdmFyIGljb24gPSBjcmVhdGVTeW1ib2woc3ltYm9UeXBlLCAwLCAwLCBvcHQuaXRlbVdpZHRoLCBvcHQuaXRlbUhlaWdodCwgb3B0Lml0ZW1TdHlsZS5maWxsLCBvcHQuc3ltYm9sS2VlcEFzcGVjdCk7XG4gIGljb24uc2V0U3R5bGUob3B0Lml0ZW1TdHlsZSk7XG4gIGljb24ucm90YXRpb24gPSAob3B0Lmljb25Sb3RhdGUgfHwgMCkgKiBNYXRoLlBJIC8gMTgwO1xuICBpY29uLnNldE9yaWdpbihbb3B0Lml0ZW1XaWR0aCAvIDIsIG9wdC5pdGVtSGVpZ2h0IC8gMl0pO1xuICBpZiAoc3ltYm9UeXBlLmluZGV4T2YoJ2VtcHR5JykgPiAtMSkge1xuICAgIGljb24uc3R5bGUuc3Ryb2tlID0gaWNvbi5zdHlsZS5maWxsO1xuICAgIGljb24uc3R5bGUuZmlsbCA9ICcjZmZmJztcbiAgICBpY29uLnN0eWxlLmxpbmVXaWR0aCA9IDI7XG4gIH1cbiAgcmV0dXJuIGljb247XG59XG5mdW5jdGlvbiBkaXNwYXRjaFNlbGVjdEFjdGlvbihzZXJpZXNOYW1lLCBkYXRhTmFtZSwgYXBpLCBleGNsdWRlU2VyaWVzSWQpIHtcbiAgLy8gZG93bnBsYXkgYmVmb3JlIHVuc2VsZWN0XG4gIGRpc3BhdGNoRG93bnBsYXlBY3Rpb24oc2VyaWVzTmFtZSwgZGF0YU5hbWUsIGFwaSwgZXhjbHVkZVNlcmllc0lkKTtcbiAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAnbGVnZW5kVG9nZ2xlU2VsZWN0JyxcbiAgICBuYW1lOiBzZXJpZXNOYW1lICE9IG51bGwgPyBzZXJpZXNOYW1lIDogZGF0YU5hbWVcbiAgfSk7XG4gIC8vIGhpZ2hsaWdodCBhZnRlciBzZWxlY3RcbiAgLy8gVE9ETyBoaWdobGlnaHQgaW1tZWRpYXRlbHkgbWF5IGNhdXNlIGFuaW1hdGlvbiBsb3NzLlxuICBkaXNwYXRjaEhpZ2hsaWdodEFjdGlvbihzZXJpZXNOYW1lLCBkYXRhTmFtZSwgYXBpLCBleGNsdWRlU2VyaWVzSWQpO1xufVxuZnVuY3Rpb24gaXNVc2VIb3ZlckxheWVyKGFwaSkge1xuICB2YXIgbGlzdCA9IGFwaS5nZXRacigpLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTtcbiAgdmFyIGVtcGhhc2lzU3RhdGU7XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB3aGlsZSAoaSA8IGxlbiAmJiAhKGVtcGhhc2lzU3RhdGUgPSBsaXN0W2ldLnN0YXRlcy5lbXBoYXNpcykpIHtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIGVtcGhhc2lzU3RhdGUgJiYgZW1waGFzaXNTdGF0ZS5ob3ZlckxheWVyO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hIaWdobGlnaHRBY3Rpb24oc2VyaWVzTmFtZSwgZGF0YU5hbWUsIGFwaSwgZXhjbHVkZVNlcmllc0lkKSB7XG4gIC8vIElmIGVsZW1lbnQgaG92ZXIgd2lsbCBtb3ZlIHRvIGEgaG92ZXJMYXllci5cbiAgaWYgKCFpc1VzZUhvdmVyTGF5ZXIoYXBpKSkge1xuICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnaGlnaGxpZ2h0JyxcbiAgICAgIHNlcmllc05hbWU6IHNlcmllc05hbWUsXG4gICAgICBuYW1lOiBkYXRhTmFtZSxcbiAgICAgIGV4Y2x1ZGVTZXJpZXNJZDogZXhjbHVkZVNlcmllc0lkXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRG93bnBsYXlBY3Rpb24oc2VyaWVzTmFtZSwgZGF0YU5hbWUsIGFwaSwgZXhjbHVkZVNlcmllc0lkKSB7XG4gIC8vIElmIGVsZW1lbnQgaG92ZXIgd2lsbCBtb3ZlIHRvIGEgaG92ZXJMYXllci5cbiAgaWYgKCFpc1VzZUhvdmVyTGF5ZXIoYXBpKSkge1xuICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnZG93bnBsYXknLFxuICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTmFtZSxcbiAgICAgIG5hbWU6IGRhdGFOYW1lLFxuICAgICAgZXhjbHVkZVNlcmllc0lkOiBleGNsdWRlU2VyaWVzSWRcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgTGVnZW5kVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxlZ2VuZEZpbHRlcihlY01vZGVsKSB7XG4gIHZhciBsZWdlbmRNb2RlbHMgPSBlY01vZGVsLmZpbmRDb21wb25lbnRzKHtcbiAgICBtYWluVHlwZTogJ2xlZ2VuZCdcbiAgfSk7XG4gIGlmIChsZWdlbmRNb2RlbHMgJiYgbGVnZW5kTW9kZWxzLmxlbmd0aCkge1xuICAgIGVjTW9kZWwuZmlsdGVyU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgIC8vIElmIGluIGFueSBsZWdlbmQgY29tcG9uZW50IHRoZSBzdGF0dXMgaXMgbm90IHNlbGVjdGVkLlxuICAgICAgLy8gQmVjYXVzZSBpbiBsZWdlbmQgc2VyaWVzIGlzIGFzc3VtZWQgc2VsZWN0ZWQgd2hlbiBpdCBpcyBub3QgaW4gdGhlIGxlZ2VuZCBkYXRhLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWdlbmRNb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFsZWdlbmRNb2RlbHNbaV0uaXNTZWxlY3RlZChzZXJpZXMubmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBjdXJyeSwgZWFjaCwgaGFzT3duIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmZ1bmN0aW9uIGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIobWV0aG9kTmFtZSwgcGF5bG9hZCwgZWNNb2RlbCkge1xuICB2YXIgaXNBbGxTZWxlY3QgPSBtZXRob2ROYW1lID09PSAnYWxsU2VsZWN0JyB8fCBtZXRob2ROYW1lID09PSAnaW52ZXJzZVNlbGVjdCc7XG4gIHZhciBzZWxlY3RlZE1hcCA9IHt9O1xuICB2YXIgYWN0aW9uTGVnZW5kSW5kaWNlcyA9IFtdO1xuICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgIG1haW5UeXBlOiAnbGVnZW5kJyxcbiAgICBxdWVyeTogcGF5bG9hZFxuICB9LCBmdW5jdGlvbiAobGVnZW5kTW9kZWwpIHtcbiAgICBpZiAoaXNBbGxTZWxlY3QpIHtcbiAgICAgIGxlZ2VuZE1vZGVsW21ldGhvZE5hbWVdKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZ2VuZE1vZGVsW21ldGhvZE5hbWVdKHBheWxvYWQubmFtZSk7XG4gICAgfVxuICAgIG1ha2VTZWxlY3RlZE1hcChsZWdlbmRNb2RlbCwgc2VsZWN0ZWRNYXApO1xuICAgIGFjdGlvbkxlZ2VuZEluZGljZXMucHVzaChsZWdlbmRNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gIH0pO1xuICB2YXIgYWxsU2VsZWN0ZWRNYXAgPSB7fTtcbiAgLy8gbWFrZSBzZWxlY3RlZE1hcCBmcm9tIGFsbCBsZWdlbmQgY29tcG9uZW50c1xuICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ2xlZ2VuZCcsIGZ1bmN0aW9uIChsZWdlbmRNb2RlbCkge1xuICAgIGVhY2goc2VsZWN0ZWRNYXAsIGZ1bmN0aW9uIChpc1NlbGVjdGVkLCBuYW1lKSB7XG4gICAgICAvLyBGb3JjZSBvdGhlciBsZWdlbmQgaGFzIHNhbWUgc2VsZWN0ZWQgc3RhdHVzXG4gICAgICAvLyBPciB0aGUgZmlyc3QgaXMgdG9nZ2xlZCB0byB0cnVlIGFuZCBvdGhlciBhcmUgdG9nZ2xlZCB0byBmYWxzZVxuICAgICAgLy8gSW4gdGhlIGNhc2Ugb25lIGxlZ2VuZCBoYXMgc29tZSBpdGVtIHVuU2VsZWN0ZWQgaW4gb3B0aW9uLiBBbmQgaWYgb3RoZXIgbGVnZW5kXG4gICAgICAvLyBkb2Vzbid0IGhhcyB0aGUgaXRlbSwgdGhleSB3aWxsIGFzc3VtZSBpdCBpcyBzZWxlY3RlZC5cbiAgICAgIGxlZ2VuZE1vZGVsW2lzU2VsZWN0ZWQgPyAnc2VsZWN0JyA6ICd1blNlbGVjdCddKG5hbWUpO1xuICAgIH0pO1xuICAgIG1ha2VTZWxlY3RlZE1hcChsZWdlbmRNb2RlbCwgYWxsU2VsZWN0ZWRNYXApO1xuICB9KTtcbiAgLy8gUmV0dXJuIHRoZSBldmVudCBleHBsaWNpdGx5XG4gIHJldHVybiBpc0FsbFNlbGVjdCA/IHtcbiAgICBzZWxlY3RlZDogYWxsU2VsZWN0ZWRNYXAsXG4gICAgLy8gcmV0dXJuIGxlZ2VuZEluZGV4IGFycmF5IHRvIHRlbGwgdGhlIGRldmVsb3BlcnMgd2hpY2ggbGVnZW5kcyBhcmUgYWxsU2VsZWN0IC8gaW52ZXJzZVNlbGVjdFxuICAgIGxlZ2VuZEluZGV4OiBhY3Rpb25MZWdlbmRJbmRpY2VzXG4gIH0gOiB7XG4gICAgbmFtZTogcGF5bG9hZC5uYW1lLFxuICAgIHNlbGVjdGVkOiBhbGxTZWxlY3RlZE1hcFxuICB9O1xufVxuZnVuY3Rpb24gbWFrZVNlbGVjdGVkTWFwKGxlZ2VuZE1vZGVsLCBvdXQpIHtcbiAgdmFyIHNlbGVjdGVkTWFwID0gb3V0IHx8IHt9O1xuICBlYWNoKGxlZ2VuZE1vZGVsLmdldERhdGEoKSwgZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgdmFyIG5hbWUgPSBtb2RlbC5nZXQoJ25hbWUnKTtcbiAgICAvLyBXcmFwIGVsZW1lbnRcbiAgICBpZiAobmFtZSA9PT0gJ1xcbicgfHwgbmFtZSA9PT0gJycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGlzSXRlbVNlbGVjdGVkID0gbGVnZW5kTW9kZWwuaXNTZWxlY3RlZChuYW1lKTtcbiAgICBpZiAoaGFzT3duKHNlbGVjdGVkTWFwLCBuYW1lKSkge1xuICAgICAgLy8gVW5zZWxlY3RlZCBpZiBhbnkgbGVnZW5kIGlzIHVuc2VsZWN0ZWRcbiAgICAgIHNlbGVjdGVkTWFwW25hbWVdID0gc2VsZWN0ZWRNYXBbbmFtZV0gJiYgaXNJdGVtU2VsZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkTWFwW25hbWVdID0gaXNJdGVtU2VsZWN0ZWQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlbGVjdGVkTWFwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGxMZWdlbmRBY3Rpb24ocmVnaXN0ZXJzKSB7XG4gIC8qKlxyXG4gICAqIEBldmVudCBsZWdlbmRUb2dnbGVTZWxlY3RcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlICdsZWdlbmRUb2dnbGVTZWxlY3QnXHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmcm9tXVxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFNlcmllcyBuYW1lIG9yIGRhdGEgaXRlbSBuYW1lXHJcbiAgICovXG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbignbGVnZW5kVG9nZ2xlU2VsZWN0JywgJ2xlZ2VuZHNlbGVjdGNoYW5nZWQnLCBjdXJyeShsZWdlbmRTZWxlY3RBY3Rpb25IYW5kbGVyLCAndG9nZ2xlU2VsZWN0ZWQnKSk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbignbGVnZW5kQWxsU2VsZWN0JywgJ2xlZ2VuZHNlbGVjdGFsbCcsIGN1cnJ5KGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIsICdhbGxTZWxlY3QnKSk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbignbGVnZW5kSW52ZXJzZVNlbGVjdCcsICdsZWdlbmRpbnZlcnNlc2VsZWN0JywgY3VycnkobGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlciwgJ2ludmVyc2VTZWxlY3QnKSk7XG4gIC8qKlxyXG4gICAqIEBldmVudCBsZWdlbmRTZWxlY3RcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlICdsZWdlbmRTZWxlY3QnXHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgU2VyaWVzIG5hbWUgb3IgZGF0YSBpdGVtIG5hbWVcclxuICAgKi9cbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKCdsZWdlbmRTZWxlY3QnLCAnbGVnZW5kc2VsZWN0ZWQnLCBjdXJyeShsZWdlbmRTZWxlY3RBY3Rpb25IYW5kbGVyLCAnc2VsZWN0JykpO1xuICAvKipcclxuICAgKiBAZXZlbnQgbGVnZW5kVW5TZWxlY3RcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlICdsZWdlbmRVblNlbGVjdCdcclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBTZXJpZXMgbmFtZSBvciBkYXRhIGl0ZW0gbmFtZVxyXG4gICAqL1xuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oJ2xlZ2VuZFVuU2VsZWN0JywgJ2xlZ2VuZHVuc2VsZWN0ZWQnLCBjdXJyeShsZWdlbmRTZWxlY3RBY3Rpb25IYW5kbGVyLCAndW5TZWxlY3QnKSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgTGVnZW5kTW9kZWwgZnJvbSAnLi9MZWdlbmRNb2RlbC5qcyc7XG5pbXBvcnQgTGVnZW5kVmlldyBmcm9tICcuL0xlZ2VuZFZpZXcuanMnO1xuaW1wb3J0IGxlZ2VuZEZpbHRlciBmcm9tICcuL2xlZ2VuZEZpbHRlci5qcyc7XG5pbXBvcnQgeyBpbnN0YWxsTGVnZW5kQWN0aW9uIH0gZnJvbSAnLi9sZWdlbmRBY3Rpb24uanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKExlZ2VuZE1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhMZWdlbmRWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJvY2Vzc29yKHJlZ2lzdGVycy5QUklPUklUWS5QUk9DRVNTT1IuU0VSSUVTX0ZJTFRFUiwgbGVnZW5kRmlsdGVyKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlcignbGVnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAncGxhaW4nO1xuICB9KTtcbiAgaW5zdGFsbExlZ2VuZEFjdGlvbihyZWdpc3RlcnMpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgTGVnZW5kTW9kZWwgZnJvbSAnLi9MZWdlbmRNb2RlbC5qcyc7XG5pbXBvcnQgeyBtZXJnZUxheW91dFBhcmFtLCBnZXRMYXlvdXRQYXJhbXMgfSBmcm9tICcuLi8uLi91dGlsL2xheW91dC5qcyc7XG5pbXBvcnQgeyBpbmhlcml0RGVmYXVsdE9wdGlvbiB9IGZyb20gJy4uLy4uL3V0aWwvY29tcG9uZW50LmpzJztcbnZhciBTY3JvbGxhYmxlTGVnZW5kTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBTY3JvbGxhYmxlTGVnZW5kTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IFNjcm9sbGFibGVMZWdlbmRNb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsRGF0YUluZGV4XHJcbiAgICovXG4gIFNjcm9sbGFibGVMZWdlbmRNb2RlbC5wcm90b3R5cGUuc2V0U2Nyb2xsRGF0YUluZGV4ID0gZnVuY3Rpb24gKHNjcm9sbERhdGFJbmRleCkge1xuICAgIHRoaXMub3B0aW9uLnNjcm9sbERhdGFJbmRleCA9IHNjcm9sbERhdGFJbmRleDtcbiAgfTtcbiAgU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpIHtcbiAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGdldExheW91dFBhcmFtcyhvcHRpb24pO1xuICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpO1xuICAgIG1lcmdlQW5kTm9ybWFsaXplTGF5b3V0UGFyYW1zKHRoaXMsIG9wdGlvbiwgaW5wdXRQb3NpdGlvblBhcmFtcyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBTY3JvbGxhYmxlTGVnZW5kTW9kZWwucHJvdG90eXBlLm1lcmdlT3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUubWVyZ2VPcHRpb24uY2FsbCh0aGlzLCBvcHRpb24sIGVjTW9kZWwpO1xuICAgIG1lcmdlQW5kTm9ybWFsaXplTGF5b3V0UGFyYW1zKHRoaXMsIHRoaXMub3B0aW9uLCBvcHRpb24pO1xuICB9O1xuICBTY3JvbGxhYmxlTGVnZW5kTW9kZWwudHlwZSA9ICdsZWdlbmQuc2Nyb2xsJztcbiAgU2Nyb2xsYWJsZUxlZ2VuZE1vZGVsLmRlZmF1bHRPcHRpb24gPSBpbmhlcml0RGVmYXVsdE9wdGlvbihMZWdlbmRNb2RlbC5kZWZhdWx0T3B0aW9uLCB7XG4gICAgc2Nyb2xsRGF0YUluZGV4OiAwLFxuICAgIHBhZ2VCdXR0b25JdGVtR2FwOiA1LFxuICAgIHBhZ2VCdXR0b25HYXA6IG51bGwsXG4gICAgcGFnZUJ1dHRvblBvc2l0aW9uOiAnZW5kJyxcbiAgICBwYWdlRm9ybWF0dGVyOiAne2N1cnJlbnR9L3t0b3RhbH0nLFxuICAgIHBhZ2VJY29uczoge1xuICAgICAgaG9yaXpvbnRhbDogWydNMCwwTDEyLC0xMEwxMiwxMHonLCAnTTAsMEwtMTIsLTEwTC0xMiwxMHonXSxcbiAgICAgIHZlcnRpY2FsOiBbJ00wLDBMMjAsMEwxMCwtMjB6JywgJ00wLDBMMjAsMEwxMCwyMHonXVxuICAgIH0sXG4gICAgcGFnZUljb25Db2xvcjogJyMyZjQ1NTQnLFxuICAgIHBhZ2VJY29uSW5hY3RpdmVDb2xvcjogJyNhYWEnLFxuICAgIHBhZ2VJY29uU2l6ZTogMTUsXG4gICAgcGFnZVRleHRTdHlsZToge1xuICAgICAgY29sb3I6ICcjMzMzJ1xuICAgIH0sXG4gICAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDgwMFxuICB9KTtcbiAgcmV0dXJuIFNjcm9sbGFibGVMZWdlbmRNb2RlbDtcbn0oTGVnZW5kTW9kZWwpO1xuO1xuLy8gRG8gbm90IGBpZ25vcmVTaXplYCB0byBlbmFibGUgc2V0dGluZyB7bGVmdDogMTAsIHJpZ2h0OiAxMH0uXG5mdW5jdGlvbiBtZXJnZUFuZE5vcm1hbGl6ZUxheW91dFBhcmFtcyhsZWdlbmRNb2RlbCwgdGFyZ2V0LCByYXcpIHtcbiAgdmFyIG9yaWVudCA9IGxlZ2VuZE1vZGVsLmdldE9yaWVudCgpO1xuICB2YXIgaWdub3JlU2l6ZSA9IFsxLCAxXTtcbiAgaWdub3JlU2l6ZVtvcmllbnQuaW5kZXhdID0gMDtcbiAgbWVyZ2VMYXlvdXRQYXJhbSh0YXJnZXQsIHJhdywge1xuICAgIHR5cGU6ICdib3gnLFxuICAgIGlnbm9yZVNpemU6ICEhaWdub3JlU2l6ZVxuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IFNjcm9sbGFibGVMZWdlbmRNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuLyoqXHJcbiAqIFNlcGFyYXRlIGxlZ2VuZCBhbmQgc2Nyb2xsYWJsZSBsZWdlbmQgdG8gcmVkdWNlIHBhY2thZ2Ugc2l6ZS5cclxuICovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCAqIGFzIGxheW91dFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQuanMnO1xuaW1wb3J0IExlZ2VuZFZpZXcgZnJvbSAnLi9MZWdlbmRWaWV3LmpzJztcbnZhciBHcm91cCA9IGdyYXBoaWMuR3JvdXA7XG52YXIgV0ggPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xudmFyIFhZID0gWyd4JywgJ3knXTtcbnZhciBTY3JvbGxhYmxlTGVnZW5kVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTY3JvbGxhYmxlTGVnZW5kVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gU2Nyb2xsYWJsZUxlZ2VuZFZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IFNjcm9sbGFibGVMZWdlbmRWaWV3LnR5cGU7XG4gICAgX3RoaXMubmV3bGluZURpc2FibGVkID0gdHJ1ZTtcbiAgICBfdGhpcy5fY3VycmVudEluZGV4ID0gMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5fY29udGFpbmVyR3JvdXAgPSBuZXcgR3JvdXAoKSk7XG4gICAgdGhpcy5fY29udGFpbmVyR3JvdXAuYWRkKHRoaXMuZ2V0Q29udGVudEdyb3VwKCkpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2NvbnRyb2xsZXJHcm91cCA9IG5ldyBHcm91cCgpKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXG4gIFNjcm9sbGFibGVMZWdlbmRWaWV3LnByb3RvdHlwZS5yZXNldElubmVyID0gZnVuY3Rpb24gKCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUucmVzZXRJbm5lci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX2NvbnRyb2xsZXJHcm91cC5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLl9jb250YWluZXJHcm91cC5yZW1vdmVDbGlwUGF0aCgpO1xuICAgIHRoaXMuX2NvbnRhaW5lckdyb3VwLl9fcmVjdFNpemUgPSBudWxsO1xuICB9O1xuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcucHJvdG90eXBlLnJlbmRlcklubmVyID0gZnVuY3Rpb24gKGl0ZW1BbGlnbiwgbGVnZW5kTW9kZWwsIGVjTW9kZWwsIGFwaSwgc2VsZWN0b3IsIG9yaWVudCwgc2VsZWN0b3JQb3NpdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBSZW5kZXIgY29udGVudCBpdGVtcy5cbiAgICBfc3VwZXIucHJvdG90eXBlLnJlbmRlcklubmVyLmNhbGwodGhpcywgaXRlbUFsaWduLCBsZWdlbmRNb2RlbCwgZWNNb2RlbCwgYXBpLCBzZWxlY3Rvciwgb3JpZW50LCBzZWxlY3RvclBvc2l0aW9uKTtcbiAgICB2YXIgY29udHJvbGxlckdyb3VwID0gdGhpcy5fY29udHJvbGxlckdyb3VwO1xuICAgIC8vIEZJWE1FOiBzdXBwb3J0IGJlICdhdXRvJyBhZGFwdCB0byBzaXplIG51bWJlciB0ZXh0IGxlbmd0aCxcbiAgICAvLyBlLmcuLCAnMy8xMjM0NScgc2hvdWxkIG5vdCBvdmVybGFwIHdpdGggdGhlIGNvbnRyb2wgYXJyb3cgYnV0dG9uLlxuICAgIHZhciBwYWdlSWNvblNpemUgPSBsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VJY29uU2l6ZScsIHRydWUpO1xuICAgIHZhciBwYWdlSWNvblNpemVBcnIgPSB6clV0aWwuaXNBcnJheShwYWdlSWNvblNpemUpID8gcGFnZUljb25TaXplIDogW3BhZ2VJY29uU2l6ZSwgcGFnZUljb25TaXplXTtcbiAgICBjcmVhdGVQYWdlQnV0dG9uKCdwYWdlUHJldicsIDApO1xuICAgIHZhciBwYWdlVGV4dFN0eWxlTW9kZWwgPSBsZWdlbmRNb2RlbC5nZXRNb2RlbCgncGFnZVRleHRTdHlsZScpO1xuICAgIGNvbnRyb2xsZXJHcm91cC5hZGQobmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICBuYW1lOiAncGFnZVRleHQnLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgLy8gUGxhY2Vob2xkZXIgdG8gY2FsY3VsYXRlIGEgcHJvcGVyIGxheW91dC5cbiAgICAgICAgdGV4dDogJ3h4L3h4JyxcbiAgICAgICAgZmlsbDogcGFnZVRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpLFxuICAgICAgICBmb250OiBwYWdlVGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgYWxpZ246ICdjZW50ZXInXG4gICAgICB9LFxuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSkpO1xuICAgIGNyZWF0ZVBhZ2VCdXR0b24oJ3BhZ2VOZXh0JywgMSk7XG4gICAgZnVuY3Rpb24gY3JlYXRlUGFnZUJ1dHRvbihuYW1lLCBpY29uSWR4KSB7XG4gICAgICB2YXIgcGFnZURhdGFJbmRleE5hbWUgPSBuYW1lICsgJ0RhdGFJbmRleCc7XG4gICAgICB2YXIgaWNvbiA9IGdyYXBoaWMuY3JlYXRlSWNvbihsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VJY29ucycsIHRydWUpW2xlZ2VuZE1vZGVsLmdldE9yaWVudCgpLm5hbWVdW2ljb25JZHhdLCB7XG4gICAgICAgIC8vIEJ1dHRvbnMgd2lsbCBiZSBjcmVhdGVkIGluIGVhY2ggcmVuZGVyLCBzbyB3ZSBkbyBub3QgbmVlZFxuICAgICAgICAvLyB0byB3b3JyeSBhYm91dCBhdm9pZGluZyB1c2luZyBsZWdlbmRNb2RlbCBrZXB0IGluIHNjb3BlLlxuICAgICAgICBvbmNsaWNrOiB6clV0aWwuYmluZChzZWxmLl9wYWdlR28sIHNlbGYsIHBhZ2VEYXRhSW5kZXhOYW1lLCBsZWdlbmRNb2RlbCwgYXBpKVxuICAgICAgfSwge1xuICAgICAgICB4OiAtcGFnZUljb25TaXplQXJyWzBdIC8gMixcbiAgICAgICAgeTogLXBhZ2VJY29uU2l6ZUFyclsxXSAvIDIsXG4gICAgICAgIHdpZHRoOiBwYWdlSWNvblNpemVBcnJbMF0sXG4gICAgICAgIGhlaWdodDogcGFnZUljb25TaXplQXJyWzFdXG4gICAgICB9KTtcbiAgICAgIGljb24ubmFtZSA9IG5hbWU7XG4gICAgICBjb250cm9sbGVyR3JvdXAuYWRkKGljb24pO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXG4gIFNjcm9sbGFibGVMZWdlbmRWaWV3LnByb3RvdHlwZS5sYXlvdXRJbm5lciA9IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgaXRlbUFsaWduLCBtYXhTaXplLCBpc0ZpcnN0UmVuZGVyLCBzZWxlY3Rvciwgc2VsZWN0b3JQb3NpdGlvbikge1xuICAgIHZhciBzZWxlY3Rvckdyb3VwID0gdGhpcy5nZXRTZWxlY3Rvckdyb3VwKCk7XG4gICAgdmFyIG9yaWVudElkeCA9IGxlZ2VuZE1vZGVsLmdldE9yaWVudCgpLmluZGV4O1xuICAgIHZhciB3aCA9IFdIW29yaWVudElkeF07XG4gICAgdmFyIHh5ID0gWFlbb3JpZW50SWR4XTtcbiAgICB2YXIgaHcgPSBXSFsxIC0gb3JpZW50SWR4XTtcbiAgICB2YXIgeXggPSBYWVsxIC0gb3JpZW50SWR4XTtcbiAgICBzZWxlY3RvciAmJiBsYXlvdXRVdGlsLmJveChcbiAgICAvLyBCdXR0b25zIGluIHNlbGVjdG9yR3JvdXAgYWx3YXlzIGxheW91dCBob3Jpem9udGFsbHlcbiAgICAnaG9yaXpvbnRhbCcsIHNlbGVjdG9yR3JvdXAsIGxlZ2VuZE1vZGVsLmdldCgnc2VsZWN0b3JJdGVtR2FwJywgdHJ1ZSkpO1xuICAgIHZhciBzZWxlY3RvckJ1dHRvbkdhcCA9IGxlZ2VuZE1vZGVsLmdldCgnc2VsZWN0b3JCdXR0b25HYXAnLCB0cnVlKTtcbiAgICB2YXIgc2VsZWN0b3JSZWN0ID0gc2VsZWN0b3JHcm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgc2VsZWN0b3JQb3MgPSBbLXNlbGVjdG9yUmVjdC54LCAtc2VsZWN0b3JSZWN0LnldO1xuICAgIHZhciBwcm9jZXNzTWF4U2l6ZSA9IHpyVXRpbC5jbG9uZShtYXhTaXplKTtcbiAgICBzZWxlY3RvciAmJiAocHJvY2Vzc01heFNpemVbd2hdID0gbWF4U2l6ZVt3aF0gLSBzZWxlY3RvclJlY3Rbd2hdIC0gc2VsZWN0b3JCdXR0b25HYXApO1xuICAgIHZhciBtYWluUmVjdCA9IHRoaXMuX2xheW91dENvbnRlbnRBbmRDb250cm9sbGVyKGxlZ2VuZE1vZGVsLCBpc0ZpcnN0UmVuZGVyLCBwcm9jZXNzTWF4U2l6ZSwgb3JpZW50SWR4LCB3aCwgaHcsIHl4LCB4eSk7XG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc2VsZWN0b3JQb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgc2VsZWN0b3JQb3Nbb3JpZW50SWR4XSArPSBtYWluUmVjdFt3aF0gKyBzZWxlY3RvckJ1dHRvbkdhcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBzZWxlY3RvclJlY3Rbd2hdICsgc2VsZWN0b3JCdXR0b25HYXA7XG4gICAgICAgIHNlbGVjdG9yUG9zW29yaWVudElkeF0gLT0gb2Zmc2V0O1xuICAgICAgICBtYWluUmVjdFt4eV0gLT0gb2Zmc2V0O1xuICAgICAgfVxuICAgICAgbWFpblJlY3Rbd2hdICs9IHNlbGVjdG9yUmVjdFt3aF0gKyBzZWxlY3RvckJ1dHRvbkdhcDtcbiAgICAgIHNlbGVjdG9yUG9zWzEgLSBvcmllbnRJZHhdICs9IG1haW5SZWN0W3l4XSArIG1haW5SZWN0W2h3XSAvIDIgLSBzZWxlY3RvclJlY3RbaHddIC8gMjtcbiAgICAgIG1haW5SZWN0W2h3XSA9IE1hdGgubWF4KG1haW5SZWN0W2h3XSwgc2VsZWN0b3JSZWN0W2h3XSk7XG4gICAgICBtYWluUmVjdFt5eF0gPSBNYXRoLm1pbihtYWluUmVjdFt5eF0sIHNlbGVjdG9yUmVjdFt5eF0gKyBzZWxlY3RvclBvc1sxIC0gb3JpZW50SWR4XSk7XG4gICAgICBzZWxlY3Rvckdyb3VwLnggPSBzZWxlY3RvclBvc1swXTtcbiAgICAgIHNlbGVjdG9yR3JvdXAueSA9IHNlbGVjdG9yUG9zWzFdO1xuICAgICAgc2VsZWN0b3JHcm91cC5tYXJrUmVkcmF3KCk7XG4gICAgfVxuICAgIHJldHVybiBtYWluUmVjdDtcbiAgfTtcbiAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcucHJvdG90eXBlLl9sYXlvdXRDb250ZW50QW5kQ29udHJvbGxlciA9IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgaXNGaXJzdFJlbmRlciwgbWF4U2l6ZSwgb3JpZW50SWR4LCB3aCwgaHcsIHl4LCB4eSkge1xuICAgIHZhciBjb250ZW50R3JvdXAgPSB0aGlzLmdldENvbnRlbnRHcm91cCgpO1xuICAgIHZhciBjb250YWluZXJHcm91cCA9IHRoaXMuX2NvbnRhaW5lckdyb3VwO1xuICAgIHZhciBjb250cm9sbGVyR3JvdXAgPSB0aGlzLl9jb250cm9sbGVyR3JvdXA7XG4gICAgLy8gUGxhY2UgaXRlbXMgaW4gY29udGVudEdyb3VwLlxuICAgIGxheW91dFV0aWwuYm94KGxlZ2VuZE1vZGVsLmdldCgnb3JpZW50JyksIGNvbnRlbnRHcm91cCwgbGVnZW5kTW9kZWwuZ2V0KCdpdGVtR2FwJyksICFvcmllbnRJZHggPyBudWxsIDogbWF4U2l6ZS53aWR0aCwgb3JpZW50SWR4ID8gbnVsbCA6IG1heFNpemUuaGVpZ2h0KTtcbiAgICBsYXlvdXRVdGlsLmJveChcbiAgICAvLyBCdXR0b25zIGluIGNvbnRyb2xsZXIgYXJlIGxheW91dCBhbHdheXMgaG9yaXpvbnRhbGx5LlxuICAgICdob3Jpem9udGFsJywgY29udHJvbGxlckdyb3VwLCBsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VCdXR0b25JdGVtR2FwJywgdHJ1ZSkpO1xuICAgIHZhciBjb250ZW50UmVjdCA9IGNvbnRlbnRHcm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgY29udHJvbGxlclJlY3QgPSBjb250cm9sbGVyR3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIHNob3dDb250cm9sbGVyID0gdGhpcy5fc2hvd0NvbnRyb2xsZXIgPSBjb250ZW50UmVjdFt3aF0gPiBtYXhTaXplW3doXTtcbiAgICAvLyBJbiBjYXNlIHRoYXQgdGhlIGlubmVyIGVsZW1lbnRzIG9mIGNvbnRlbnRHcm91cCBsYXlvdXQgZG8gbm90IGJhc2VkIG9uIFswLCAwXVxuICAgIHZhciBjb250ZW50UG9zID0gWy1jb250ZW50UmVjdC54LCAtY29udGVudFJlY3QueV07XG4gICAgLy8gUmVtYWluIGNvbnRlbnRQb3Mgd2hlbiBzY3JvbGwgYW5pbWF0aW9uIHBlcmZyb21pbmcuXG4gICAgLy8gSWYgZmlyc3QgcmVuZGVyaW5nLCBgY29udGVudEdyb3VwLnBvc2l0aW9uYCBpcyBbMCwgMF0sIHdoaWNoXG4gICAgLy8gZG9lcyBub3QgbWFrZSBzZW5zZSBhbmQgbWF5IGNhdXNlIHVuZXhlcGN0ZWQgYW5pbWF0aW9uIGlmIGFkb3B0ZWQuXG4gICAgaWYgKCFpc0ZpcnN0UmVuZGVyKSB7XG4gICAgICBjb250ZW50UG9zW29yaWVudElkeF0gPSBjb250ZW50R3JvdXBbeHldO1xuICAgIH1cbiAgICAvLyBMYXlvdXQgY29udGFpbmVyIGdyb3VwIGJhc2VkIG9uIDAuXG4gICAgdmFyIGNvbnRhaW5lclBvcyA9IFswLCAwXTtcbiAgICB2YXIgY29udHJvbGxlclBvcyA9IFstY29udHJvbGxlclJlY3QueCwgLWNvbnRyb2xsZXJSZWN0LnldO1xuICAgIHZhciBwYWdlQnV0dG9uR2FwID0genJVdGlsLnJldHJpZXZlMihsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VCdXR0b25HYXAnLCB0cnVlKSwgbGVnZW5kTW9kZWwuZ2V0KCdpdGVtR2FwJywgdHJ1ZSkpO1xuICAgIC8vIFBsYWNlIGNvbnRhaW5lckdyb3VwIGFuZCBjb250cm9sbGVyR3JvdXAgYW5kIGNvbnRlbnRHcm91cC5cbiAgICBpZiAoc2hvd0NvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBwYWdlQnV0dG9uUG9zaXRpb24gPSBsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VCdXR0b25Qb3NpdGlvbicsIHRydWUpO1xuICAgICAgLy8gY29udHJvbGxlciBpcyBvbiB0aGUgcmlnaHQgLyBib3R0b20uXG4gICAgICBpZiAocGFnZUJ1dHRvblBvc2l0aW9uID09PSAnZW5kJykge1xuICAgICAgICBjb250cm9sbGVyUG9zW29yaWVudElkeF0gKz0gbWF4U2l6ZVt3aF0gLSBjb250cm9sbGVyUmVjdFt3aF07XG4gICAgICB9XG4gICAgICAvLyBjb250cm9sbGVyIGlzIG9uIHRoZSBsZWZ0IC8gdG9wLlxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lclBvc1tvcmllbnRJZHhdICs9IGNvbnRyb2xsZXJSZWN0W3doXSArIHBhZ2VCdXR0b25HYXA7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFsd2F5cyBhbGlnbiBjb250cm9sbGVyIHRvIGNvbnRlbnQgYXMgJ21pZGRsZScuXG4gICAgY29udHJvbGxlclBvc1sxIC0gb3JpZW50SWR4XSArPSBjb250ZW50UmVjdFtod10gLyAyIC0gY29udHJvbGxlclJlY3RbaHddIC8gMjtcbiAgICBjb250ZW50R3JvdXAuc2V0UG9zaXRpb24oY29udGVudFBvcyk7XG4gICAgY29udGFpbmVyR3JvdXAuc2V0UG9zaXRpb24oY29udGFpbmVyUG9zKTtcbiAgICBjb250cm9sbGVyR3JvdXAuc2V0UG9zaXRpb24oY29udHJvbGxlclBvcyk7XG4gICAgLy8gQ2FsY3VsYXRlIGBtYWluUmVjdGAgYW5kIHNldCBgY2xpcFBhdGhgLlxuICAgIC8vIG1haW5SZWN0IHNob3VsZCBub3QgYmUgY2FsY3VsYXRlZCBieSBgdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKWBcbiAgICAvLyBmb3Igc2FrZSBvZiB0aGUgb3ZlcmZsb3cuXG4gICAgdmFyIG1haW5SZWN0ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIC8vIENvbnNpZGVyIGNvbnRlbnQgbWF5IGJlIG92ZXJmbG93IChzaG91bGQgYmUgY2xpcHBlZCkuXG4gICAgbWFpblJlY3Rbd2hdID0gc2hvd0NvbnRyb2xsZXIgPyBtYXhTaXplW3doXSA6IGNvbnRlbnRSZWN0W3doXTtcbiAgICBtYWluUmVjdFtod10gPSBNYXRoLm1heChjb250ZW50UmVjdFtod10sIGNvbnRyb2xsZXJSZWN0W2h3XSk7XG4gICAgLy8gYGNvbnRhaW5lclJlY3RbeXhdICsgY29udGFpbmVyUG9zWzEgLSBvcmllbnRJZHhdYCBpcyAwLlxuICAgIG1haW5SZWN0W3l4XSA9IE1hdGgubWluKDAsIGNvbnRyb2xsZXJSZWN0W3l4XSArIGNvbnRyb2xsZXJQb3NbMSAtIG9yaWVudElkeF0pO1xuICAgIGNvbnRhaW5lckdyb3VwLl9fcmVjdFNpemUgPSBtYXhTaXplW3doXTtcbiAgICBpZiAoc2hvd0NvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBjbGlwU2hhcGUgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICBjbGlwU2hhcGVbd2hdID0gTWF0aC5tYXgobWF4U2l6ZVt3aF0gLSBjb250cm9sbGVyUmVjdFt3aF0gLSBwYWdlQnV0dG9uR2FwLCAwKTtcbiAgICAgIGNsaXBTaGFwZVtod10gPSBtYWluUmVjdFtod107XG4gICAgICBjb250YWluZXJHcm91cC5zZXRDbGlwUGF0aChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgc2hhcGU6IGNsaXBTaGFwZVxuICAgICAgfSkpO1xuICAgICAgLy8gQ29uc2lkZXIgY29udGVudCBtYXkgYmUgbGFyZ2VyIHRoYW4gY29udGFpbmVyLCBjb250YWluZXIgcmVjdFxuICAgICAgLy8gY2FuIG5vdCBiZSBvYnRhaW5lZCBmcm9tIGBjb250YWluZXJHcm91cC5nZXRCb3VuZGluZ1JlY3QoKWAuXG4gICAgICBjb250YWluZXJHcm91cC5fX3JlY3RTaXplID0gY2xpcFNoYXBlW3doXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRG8gbm90IHJlbW92ZSBvciBpZ25vcmUgY29udHJvbGxlci4gS2VlcCB0aGVtIHNldCBhcyBwbGFjZWhvbGRlcnMuXG4gICAgICBjb250cm9sbGVyR3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC5hdHRyKHtcbiAgICAgICAgICBpbnZpc2libGU6IHRydWUsXG4gICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENvbnRlbnQgdHJhbnNsYXRlIGFuaW1hdGlvbi5cbiAgICB2YXIgcGFnZUluZm8gPSB0aGlzLl9nZXRQYWdlSW5mbyhsZWdlbmRNb2RlbCk7XG4gICAgcGFnZUluZm8ucGFnZUluZGV4ICE9IG51bGwgJiYgZ3JhcGhpYy51cGRhdGVQcm9wcyhjb250ZW50R3JvdXAsIHtcbiAgICAgIHg6IHBhZ2VJbmZvLmNvbnRlbnRQb3NpdGlvblswXSxcbiAgICAgIHk6IHBhZ2VJbmZvLmNvbnRlbnRQb3NpdGlvblsxXVxuICAgIH0sXG4gICAgLy8gV2hlbiBzd2l0Y2ggZnJvbSBcInNob3cgY29udHJvbGxlclwiIHRvIFwibm90IHNob3cgY29udHJvbGxlclwiLCB2aWV3IHNob3VsZCBiZVxuICAgIC8vIHVwZGF0ZWQgaW1tZWRpYXRlbHkgd2l0aG91dCBhbmltYXRpb24sIG90aGVyd2lzZSBjYXVzZXMgd2VpcmQgZWZmZWN0LlxuICAgIHNob3dDb250cm9sbGVyID8gbGVnZW5kTW9kZWwgOiBudWxsKTtcbiAgICB0aGlzLl91cGRhdGVQYWdlSW5mb1ZpZXcobGVnZW5kTW9kZWwsIHBhZ2VJbmZvKTtcbiAgICByZXR1cm4gbWFpblJlY3Q7XG4gIH07XG4gIFNjcm9sbGFibGVMZWdlbmRWaWV3LnByb3RvdHlwZS5fcGFnZUdvID0gZnVuY3Rpb24gKHRvLCBsZWdlbmRNb2RlbCwgYXBpKSB7XG4gICAgdmFyIHNjcm9sbERhdGFJbmRleCA9IHRoaXMuX2dldFBhZ2VJbmZvKGxlZ2VuZE1vZGVsKVt0b107XG4gICAgc2Nyb2xsRGF0YUluZGV4ICE9IG51bGwgJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdsZWdlbmRTY3JvbGwnLFxuICAgICAgc2Nyb2xsRGF0YUluZGV4OiBzY3JvbGxEYXRhSW5kZXgsXG4gICAgICBsZWdlbmRJZDogbGVnZW5kTW9kZWwuaWRcbiAgICB9KTtcbiAgfTtcbiAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcucHJvdG90eXBlLl91cGRhdGVQYWdlSW5mb1ZpZXcgPSBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIHBhZ2VJbmZvKSB7XG4gICAgdmFyIGNvbnRyb2xsZXJHcm91cCA9IHRoaXMuX2NvbnRyb2xsZXJHcm91cDtcbiAgICB6clV0aWwuZWFjaChbJ3BhZ2VQcmV2JywgJ3BhZ2VOZXh0J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIga2V5ID0gbmFtZSArICdEYXRhSW5kZXgnO1xuICAgICAgdmFyIGNhbkp1bXAgPSBwYWdlSW5mb1trZXldICE9IG51bGw7XG4gICAgICB2YXIgaWNvbiA9IGNvbnRyb2xsZXJHcm91cC5jaGlsZE9mTmFtZShuYW1lKTtcbiAgICAgIGlmIChpY29uKSB7XG4gICAgICAgIGljb24uc2V0U3R5bGUoJ2ZpbGwnLCBjYW5KdW1wID8gbGVnZW5kTW9kZWwuZ2V0KCdwYWdlSWNvbkNvbG9yJywgdHJ1ZSkgOiBsZWdlbmRNb2RlbC5nZXQoJ3BhZ2VJY29uSW5hY3RpdmVDb2xvcicsIHRydWUpKTtcbiAgICAgICAgaWNvbi5jdXJzb3IgPSBjYW5KdW1wID8gJ3BvaW50ZXInIDogJ2RlZmF1bHQnO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBwYWdlVGV4dCA9IGNvbnRyb2xsZXJHcm91cC5jaGlsZE9mTmFtZSgncGFnZVRleHQnKTtcbiAgICB2YXIgcGFnZUZvcm1hdHRlciA9IGxlZ2VuZE1vZGVsLmdldCgncGFnZUZvcm1hdHRlcicpO1xuICAgIHZhciBwYWdlSW5kZXggPSBwYWdlSW5mby5wYWdlSW5kZXg7XG4gICAgdmFyIGN1cnJlbnQgPSBwYWdlSW5kZXggIT0gbnVsbCA/IHBhZ2VJbmRleCArIDEgOiAwO1xuICAgIHZhciB0b3RhbCA9IHBhZ2VJbmZvLnBhZ2VDb3VudDtcbiAgICBwYWdlVGV4dCAmJiBwYWdlRm9ybWF0dGVyICYmIHBhZ2VUZXh0LnNldFN0eWxlKCd0ZXh0JywgenJVdGlsLmlzU3RyaW5nKHBhZ2VGb3JtYXR0ZXIpID8gcGFnZUZvcm1hdHRlci5yZXBsYWNlKCd7Y3VycmVudH0nLCBjdXJyZW50ID09IG51bGwgPyAnJyA6IGN1cnJlbnQgKyAnJykucmVwbGFjZSgne3RvdGFsfScsIHRvdGFsID09IG51bGwgPyAnJyA6IHRvdGFsICsgJycpIDogcGFnZUZvcm1hdHRlcih7XG4gICAgICBjdXJyZW50OiBjdXJyZW50LFxuICAgICAgdG90YWw6IHRvdGFsXG4gICAgfSkpO1xuICB9O1xuICAvKipcclxuICAgKiAgY29udGVudFBvc2l0aW9uOiBBcnJheS48bnVtYmVyPiwgbnVsbCB3aGVuIGRhdGEgaXRlbSBub3QgZm91bmQuXHJcbiAgICogIHBhZ2VJbmRleDogbnVtYmVyLCBudWxsIHdoZW4gZGF0YSBpdGVtIG5vdCBmb3VuZC5cclxuICAgKiAgcGFnZUNvdW50OiBudW1iZXIsIGFsd2F5cyBiZSBhIG51bWJlciwgY2FuIGJlIDAuXHJcbiAgICogIHBhZ2VQcmV2RGF0YUluZGV4OiBudW1iZXIsIG51bGwgd2hlbiBubyBwcmV2aW91cyBwYWdlLlxyXG4gICAqICBwYWdlTmV4dERhdGFJbmRleDogbnVtYmVyLCBudWxsIHdoZW4gbm8gbmV4dCBwYWdlLlxyXG4gICAqIH1cclxuICAgKi9cbiAgU2Nyb2xsYWJsZUxlZ2VuZFZpZXcucHJvdG90eXBlLl9nZXRQYWdlSW5mbyA9IGZ1bmN0aW9uIChsZWdlbmRNb2RlbCkge1xuICAgIHZhciBzY3JvbGxEYXRhSW5kZXggPSBsZWdlbmRNb2RlbC5nZXQoJ3Njcm9sbERhdGFJbmRleCcsIHRydWUpO1xuICAgIHZhciBjb250ZW50R3JvdXAgPSB0aGlzLmdldENvbnRlbnRHcm91cCgpO1xuICAgIHZhciBjb250YWluZXJSZWN0U2l6ZSA9IHRoaXMuX2NvbnRhaW5lckdyb3VwLl9fcmVjdFNpemU7XG4gICAgdmFyIG9yaWVudElkeCA9IGxlZ2VuZE1vZGVsLmdldE9yaWVudCgpLmluZGV4O1xuICAgIHZhciB3aCA9IFdIW29yaWVudElkeF07XG4gICAgdmFyIHh5ID0gWFlbb3JpZW50SWR4XTtcbiAgICB2YXIgdGFyZ2V0SXRlbUluZGV4ID0gdGhpcy5fZmluZFRhcmdldEl0ZW1JbmRleChzY3JvbGxEYXRhSW5kZXgpO1xuICAgIHZhciBjaGlsZHJlbiA9IGNvbnRlbnRHcm91cC5jaGlsZHJlbigpO1xuICAgIHZhciB0YXJnZXRJdGVtID0gY2hpbGRyZW5bdGFyZ2V0SXRlbUluZGV4XTtcbiAgICB2YXIgaXRlbUNvdW50ID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHZhciBwQ291bnQgPSAhaXRlbUNvdW50ID8gMCA6IDE7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGNvbnRlbnRQb3NpdGlvbjogW2NvbnRlbnRHcm91cC54LCBjb250ZW50R3JvdXAueV0sXG4gICAgICBwYWdlQ291bnQ6IHBDb3VudCxcbiAgICAgIHBhZ2VJbmRleDogcENvdW50IC0gMSxcbiAgICAgIHBhZ2VQcmV2RGF0YUluZGV4OiBudWxsLFxuICAgICAgcGFnZU5leHREYXRhSW5kZXg6IG51bGxcbiAgICB9O1xuICAgIGlmICghdGFyZ2V0SXRlbSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmFyIHRhcmdldEl0ZW1JbmZvID0gZ2V0SXRlbUluZm8odGFyZ2V0SXRlbSk7XG4gICAgcmVzdWx0LmNvbnRlbnRQb3NpdGlvbltvcmllbnRJZHhdID0gLXRhcmdldEl0ZW1JbmZvLnM7XG4gICAgLy8gU3RyYXRlZ3k6XG4gICAgLy8gKDEpIEFsd2F5cyBhbGlnbiBiYXNlZCBvbiB0aGUgbGVmdC90b3AgbW9zdCBpdGVtLlxuICAgIC8vICgyKSBJdCBpcyB1c2VyLWZyaWVuZGx5IHRoYXQgdGhlIGxhc3QgaXRlbSBzaG93biBpbiB0aGVcbiAgICAvLyBjdXJyZW50IHdpbmRvdyBpcyBzaG93biBhdCB0aGUgYmVnaW5pbmcgb2YgbmV4dCB3aW5kb3cuXG4gICAgLy8gT3RoZXJ3aXNlIGlmIGhhbGYgb2YgdGhlIGxhc3QgaXRlbSBpcyBjdXQgYnkgdGhlIHdpbmRvdyxcbiAgICAvLyBpdCB3aWxsIGhhdmUgbm8gY2hhbmNlIHRvIGRpc3BsYXkgZW50aXJlbHkuXG4gICAgLy8gKDMpIENvbnNpZGVyIHRoYXQgaXRlbSBzaXplIHByb2JhYmx5IGJlIGRpZmZlcmVudCwgd2VcbiAgICAvLyBoYXZlIGNhbGN1bGF0ZSBwYWdlSW5kZXggYnkgc2l6ZSByYXRoZXIgdGhhbiBpdGVtIGluZGV4LFxuICAgIC8vIGFuZCB3ZSBjYW4gbm90IGdldCBwYWdlIGluZGV4IGRpcmVjdGx5IGJ5IGRpdmlzaW9uLlxuICAgIC8vICg0KSBUaGUgd2luZG93IGlzIHRvIG5hcnJvdyB0byBjb250YWluIG1vcmUgdGhhblxuICAgIC8vIG9uZSBpdGVtLCB3ZSBzaG91bGQgbWFrZSBzdXJlIHRoYXQgdGhlIHBhZ2UgY2FuIGJlIGZsaXBlZC5cbiAgICBmb3IgKHZhciBpID0gdGFyZ2V0SXRlbUluZGV4ICsgMSwgd2luU3RhcnRJdGVtSW5mbyA9IHRhcmdldEl0ZW1JbmZvLCB3aW5FbmRJdGVtSW5mbyA9IHRhcmdldEl0ZW1JbmZvLCBjdXJySXRlbUluZm8gPSBudWxsOyBpIDw9IGl0ZW1Db3VudDsgKytpKSB7XG4gICAgICBjdXJySXRlbUluZm8gPSBnZXRJdGVtSW5mbyhjaGlsZHJlbltpXSk7XG4gICAgICBpZiAoXG4gICAgICAvLyBIYWxmIG9mIHRoZSBsYXN0IGl0ZW0gaXMgb3V0IG9mIHRoZSB3aW5kb3cuXG4gICAgICAhY3Vyckl0ZW1JbmZvICYmIHdpbkVuZEl0ZW1JbmZvLmUgPiB3aW5TdGFydEl0ZW1JbmZvLnMgKyBjb250YWluZXJSZWN0U2l6ZVxuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgaXRlbSBkb2VzIG5vdCBpbnRlcnNlY3Qgd2l0aCB0aGUgd2luZG93LCB0aGUgbmV3IHBhZ2VcbiAgICAgIC8vIGNhbiBiZSBzdGFydGVkIGF0IHRoZSBjdXJyZW50IGl0ZW0gb3IgdGhlIGxhc3QgaXRlbS5cbiAgICAgIHx8IGN1cnJJdGVtSW5mbyAmJiAhaW50ZXJzZWN0KGN1cnJJdGVtSW5mbywgd2luU3RhcnRJdGVtSW5mby5zKSkge1xuICAgICAgICBpZiAod2luRW5kSXRlbUluZm8uaSA+IHdpblN0YXJ0SXRlbUluZm8uaSkge1xuICAgICAgICAgIHdpblN0YXJ0SXRlbUluZm8gPSB3aW5FbmRJdGVtSW5mbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlLmcuLCB3aGVuIHBhZ2Ugc2l6ZSBpcyBzbWFsbGVyIHRoYW4gaXRlbSBzaXplLlxuICAgICAgICAgIHdpblN0YXJ0SXRlbUluZm8gPSBjdXJySXRlbUluZm87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpblN0YXJ0SXRlbUluZm8pIHtcbiAgICAgICAgICBpZiAocmVzdWx0LnBhZ2VOZXh0RGF0YUluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYWdlTmV4dERhdGFJbmRleCA9IHdpblN0YXJ0SXRlbUluZm8uaTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKytyZXN1bHQucGFnZUNvdW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aW5FbmRJdGVtSW5mbyA9IGN1cnJJdGVtSW5mbztcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHRhcmdldEl0ZW1JbmRleCAtIDEsIHdpblN0YXJ0SXRlbUluZm8gPSB0YXJnZXRJdGVtSW5mbywgd2luRW5kSXRlbUluZm8gPSB0YXJnZXRJdGVtSW5mbywgY3Vyckl0ZW1JbmZvID0gbnVsbDsgaSA+PSAtMTsgLS1pKSB7XG4gICAgICBjdXJySXRlbUluZm8gPSBnZXRJdGVtSW5mbyhjaGlsZHJlbltpXSk7XG4gICAgICBpZiAoXG4gICAgICAvLyBJZiB0aGUgdGhlIGVuZCBpdGVtIGRvZXMgbm90IGludGVyc2VjdCB3aXRoIHRoZSB3aW5kb3cgc3RhcnRlZFxuICAgICAgLy8gZnJvbSB0aGUgY3VycmVudCBpdGVtLCBhIHBhZ2UgY2FuIGJlIHNldHRsZWQuXG4gICAgICAoIWN1cnJJdGVtSW5mbyB8fCAhaW50ZXJzZWN0KHdpbkVuZEl0ZW1JbmZvLCBjdXJySXRlbUluZm8ucylcbiAgICAgIC8vIGUuZy4sIHdoZW4gcGFnZSBzaXplIGlzIHNtYWxsZXIgdGhhbiBpdGVtIHNpemUuXG4gICAgICApICYmIHdpblN0YXJ0SXRlbUluZm8uaSA8IHdpbkVuZEl0ZW1JbmZvLmkpIHtcbiAgICAgICAgd2luRW5kSXRlbUluZm8gPSB3aW5TdGFydEl0ZW1JbmZvO1xuICAgICAgICBpZiAocmVzdWx0LnBhZ2VQcmV2RGF0YUluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQucGFnZVByZXZEYXRhSW5kZXggPSB3aW5TdGFydEl0ZW1JbmZvLmk7XG4gICAgICAgIH1cbiAgICAgICAgKytyZXN1bHQucGFnZUNvdW50O1xuICAgICAgICArK3Jlc3VsdC5wYWdlSW5kZXg7XG4gICAgICB9XG4gICAgICB3aW5TdGFydEl0ZW1JbmZvID0gY3Vyckl0ZW1JbmZvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICAgIGZ1bmN0aW9uIGdldEl0ZW1JbmZvKGVsKSB7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgdmFyIGl0ZW1SZWN0ID0gZWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIHZhciBzdGFydCA9IGl0ZW1SZWN0W3h5XSArIGVsW3h5XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzOiBzdGFydCxcbiAgICAgICAgICBlOiBzdGFydCArIGl0ZW1SZWN0W3doXSxcbiAgICAgICAgICBpOiBlbC5fX2xlZ2VuZERhdGFJbmRleFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3QoaXRlbUluZm8sIHdpblN0YXJ0KSB7XG4gICAgICByZXR1cm4gaXRlbUluZm8uZSA+PSB3aW5TdGFydCAmJiBpdGVtSW5mby5zIDw9IHdpblN0YXJ0ICsgY29udGFpbmVyUmVjdFNpemU7XG4gICAgfVxuICB9O1xuICBTY3JvbGxhYmxlTGVnZW5kVmlldy5wcm90b3R5cGUuX2ZpbmRUYXJnZXRJdGVtSW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0RGF0YUluZGV4KSB7XG4gICAgaWYgKCF0aGlzLl9zaG93Q29udHJvbGxlcikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciBpbmRleDtcbiAgICB2YXIgY29udGVudEdyb3VwID0gdGhpcy5nZXRDb250ZW50R3JvdXAoKTtcbiAgICB2YXIgZGVmYXVsdEluZGV4O1xuICAgIGNvbnRlbnRHcm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkLCBpZHgpIHtcbiAgICAgIHZhciBsZWdlbmREYXRhSWR4ID0gY2hpbGQuX19sZWdlbmREYXRhSW5kZXg7XG4gICAgICAvLyBGSVhNRVxuICAgICAgLy8gSWYgdGhlIGdpdmVuIHRhcmdldERhdGFJbmRleCAoZnJvbSBtb2RlbCkgaXMgaWxsZWdhbCxcbiAgICAgIC8vIHdlIHVzZSBkZWZhdWx0SW5kZXguIEJ1dCB0aGUgaW5kZXggb24gdGhlIGxlZ2VuZCBtb2RlbCBhbmRcbiAgICAgIC8vIGFjdGlvbiBwYXlsb2FkIGlzIHN0aWxsIGlsbGVnYWwuIFRoYXQgY2FzZSB3aWxsIG5vdCBiZVxuICAgICAgLy8gY2hhbmdlZCB1bnRpbCBzb21lIHNjZW5hcmlvIHJlcXVpcmVzLlxuICAgICAgaWYgKGRlZmF1bHRJbmRleCA9PSBudWxsICYmIGxlZ2VuZERhdGFJZHggIT0gbnVsbCkge1xuICAgICAgICBkZWZhdWx0SW5kZXggPSBpZHg7XG4gICAgICB9XG4gICAgICBpZiAobGVnZW5kRGF0YUlkeCA9PT0gdGFyZ2V0RGF0YUluZGV4KSB7XG4gICAgICAgIGluZGV4ID0gaWR4O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpbmRleCAhPSBudWxsID8gaW5kZXggOiBkZWZhdWx0SW5kZXg7XG4gIH07XG4gIFNjcm9sbGFibGVMZWdlbmRWaWV3LnR5cGUgPSAnbGVnZW5kLnNjcm9sbCc7XG4gIHJldHVybiBTY3JvbGxhYmxlTGVnZW5kVmlldztcbn0oTGVnZW5kVmlldyk7XG5leHBvcnQgZGVmYXVsdCBTY3JvbGxhYmxlTGVnZW5kVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluc3RhbGxTY3JvbGxhYmxlTGVnZW5kQWN0aW9uKHJlZ2lzdGVycykge1xuICAvKipcclxuICAgKiBAZXZlbnQgbGVnZW5kU2Nyb2xsXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAnbGVnZW5kU2Nyb2xsJ1xyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzY3JvbGxEYXRhSW5kZXhcclxuICAgKi9cbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKCdsZWdlbmRTY3JvbGwnLCAnbGVnZW5kc2Nyb2xsJywgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICB2YXIgc2Nyb2xsRGF0YUluZGV4ID0gcGF5bG9hZC5zY3JvbGxEYXRhSW5kZXg7XG4gICAgc2Nyb2xsRGF0YUluZGV4ICE9IG51bGwgJiYgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiAnbGVnZW5kJyxcbiAgICAgIHN1YlR5cGU6ICdzY3JvbGwnLFxuICAgICAgcXVlcnk6IHBheWxvYWRcbiAgICB9LCBmdW5jdGlvbiAobGVnZW5kTW9kZWwpIHtcbiAgICAgIGxlZ2VuZE1vZGVsLnNldFNjcm9sbERhdGFJbmRleChzY3JvbGxEYXRhSW5kZXgpO1xuICAgIH0pO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IHVzZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbi5qcyc7XG5pbXBvcnQgeyBpbnN0YWxsIGFzIGluc3RhbGxMZWdlbmRQbGFpbiB9IGZyb20gJy4vaW5zdGFsbExlZ2VuZFBsYWluLmpzJztcbmltcG9ydCBTY3JvbGxhYmxlTGVnZW5kTW9kZWwgZnJvbSAnLi9TY3JvbGxhYmxlTGVnZW5kTW9kZWwuanMnO1xuaW1wb3J0IFNjcm9sbGFibGVMZWdlbmRWaWV3IGZyb20gJy4vU2Nyb2xsYWJsZUxlZ2VuZFZpZXcuanMnO1xuaW1wb3J0IGluc3RhbGxTY3JvbGxhYmxlTGVnZW5kQWN0aW9uIGZyb20gJy4vc2Nyb2xsYWJsZUxlZ2VuZEFjdGlvbi5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgdXNlKGluc3RhbGxMZWdlbmRQbGFpbik7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKFNjcm9sbGFibGVMZWdlbmRNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoU2Nyb2xsYWJsZUxlZ2VuZFZpZXcpO1xuICBpbnN0YWxsU2Nyb2xsYWJsZUxlZ2VuZEFjdGlvbihyZWdpc3RlcnMpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgdXNlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9uLmpzJztcbmltcG9ydCB7IGluc3RhbGwgYXMgaW5zdGFsbExlZ2VuZFBsYWluIH0gZnJvbSAnLi9pbnN0YWxsTGVnZW5kUGxhaW4uanMnO1xuaW1wb3J0IHsgaW5zdGFsbCBhcyBpbnN0YWxsTGVnZW5kU2Nyb2xsIH0gZnJvbSAnLi9pbnN0YWxsTGVnZW5kU2Nyb2xsLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICB1c2UoaW5zdGFsbExlZ2VuZFBsYWluKTtcbiAgdXNlKGluc3RhbGxMZWdlbmRTY3JvbGwpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///69380\n")},71171:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Lq: () => (/* binding */ dataFilter),\n/* harmony export */   PN: () => (/* binding */ zoneFilter),\n/* harmony export */   Yc: () => (/* binding */ getAxisInfo),\n/* harmony export */   fY: () => (/* binding */ createMarkerDimValueGetter),\n/* harmony export */   vz: () => (/* binding */ numCalculate),\n/* harmony export */   xx: () => (/* binding */ dataTransform)\n/* harmony export */ });\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24326);\n/* harmony import */ var _data_helper_dataStackHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65008);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _data_helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31825);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n}\nfunction markerTypeCalculatorWithExtent(markerType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var stacked = (0,_data_helper_dataStackHelper_js__WEBPACK_IMPORTED_MODULE_0__/* .isDimensionStacked */ .sJ)(data, targetDataDim /* , otherDataDim */);\n  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;\n  var value = numCalculate(data, calcDataDim, markerType);\n  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);\n  coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);\n  var coordArrValue = data.get(targetDataDim, dataIndex);\n  // Make it simple, do not visit all stacked value to count precision.\n  var precision = _util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .getPrecision */ .XV(data.get(targetDataDim, dataIndex));\n  precision = Math.min(precision, 20);\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n  return [coordArr, coordArrValue];\n}\n// TODO Specified percent\nvar markerTypeCalculator = {\n  min: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.curry)(markerTypeCalculatorWithExtent, 'min'),\n  max: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.curry)(markerTypeCalculatorWithExtent, 'max'),\n  average: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.curry)(markerTypeCalculatorWithExtent, 'average'),\n  median: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.curry)(markerTypeCalculatorWithExtent, 'median')\n};\n/**\r\n * Transform markPoint data item to format used in List by do the following\r\n * 1. Calculate statistic like `max`, `min`, `average`\r\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\r\n */\nfunction dataTransform(seriesModel, item) {\n  if (!item) {\n    return;\n  }\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem;\n  var dims = coordSys && coordSys.dimensions;\n  // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n  if (!hasXAndY(item) && !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(item.coord) && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(dims)) {\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);\n    // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n    item = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone)(item);\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.indexOf)(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.indexOf)(dims, axisInfo.valueAxis.dim);\n      var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);\n      item.coord = coordInfo[0];\n      // Force to use the value of calculated value.\n      // let item use the value without stack.\n      item.value = coordInfo[1];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      item.coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis];\n    }\n  }\n  // x y is provided\n  if (item.coord == null || !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(dims)) {\n    item.coord = [];\n  } else {\n    // Each coord support max, min, average\n    var coord = item.coord;\n    for (var i = 0; i < 2; i++) {\n      if (markerTypeCalculator[coord[i]]) {\n        coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);\n      }\n    }\n  }\n  return item;\n}\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);\n  }\n  return ret;\n}\nfunction dataDimToCoordDim(seriesModel, dataDim) {\n  var dimItem = seriesModel.getData().getDimensionInfo(dataDim);\n  return dimItem && dimItem.coordDim;\n}\n/**\r\n * Filter data which is out of coordinateSystem range\r\n * [dataFilter description]\r\n */\nfunction dataFilter(\n// Currently only polar and cartesian has containData.\ncoordSys, item) {\n  // Always return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\nfunction zoneFilter(\n// Currently only polar and cartesian has containData.\ncoordSys, item1, item2) {\n  // Always return true if there is no coordSys\n  return coordSys && coordSys.containZone && item1.coord && item2.coord && !hasXOrY(item1) && !hasXOrY(item2) ? coordSys.containZone(item1.coord, item2.coord) : true;\n}\nfunction createMarkerDimValueGetter(inCoordSys, dims) {\n  return inCoordSys ? function (item, dimName, dataIndex, dimIndex) {\n    var rawVal = dimIndex < 2\n    // x, y, radius, angle\n    ? item.coord && item.coord[dimIndex] : item.value;\n    return (0,_data_helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_3__/* .parseDataValue */ .Pn)(rawVal, dims[dimIndex]);\n  } : function (item, dimName, dataIndex, dimIndex) {\n    return (0,_data_helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_3__/* .parseDataValue */ .Pn)(item.value, dims[dimIndex]);\n  };\n}\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum_1 = 0;\n    var count_1 = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum_1 += val;\n        count_1++;\n      }\n    });\n    return sum_1 / count_1;\n  } else if (type === 'median') {\n    return data.getMedian(valueDataDim);\n  } else {\n    // max & min\n    return data.getDataExtent(valueDataDim)[type === 'max' ? 1 : 0];\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzExNzEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL21hcmtlckhlbHBlci5qcz8wZWM2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7XG5pbXBvcnQgeyBpc0RpbWVuc2lvblN0YWNrZWQgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9kYXRhU3RhY2tIZWxwZXIuanMnO1xuaW1wb3J0IHsgaW5kZXhPZiwgY3VycnksIGNsb25lLCBpc0FycmF5IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IHBhcnNlRGF0YVZhbHVlIH0gZnJvbSAnLi4vLi4vZGF0YS9oZWxwZXIvZGF0YVZhbHVlSGVscGVyLmpzJztcbmZ1bmN0aW9uIGhhc1hPclkoaXRlbSkge1xuICByZXR1cm4gIShpc05hTihwYXJzZUZsb2F0KGl0ZW0ueCkpICYmIGlzTmFOKHBhcnNlRmxvYXQoaXRlbS55KSkpO1xufVxuZnVuY3Rpb24gaGFzWEFuZFkoaXRlbSkge1xuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQoaXRlbS54KSkgJiYgIWlzTmFOKHBhcnNlRmxvYXQoaXRlbS55KSk7XG59XG5mdW5jdGlvbiBtYXJrZXJUeXBlQ2FsY3VsYXRvcldpdGhFeHRlbnQobWFya2VyVHlwZSwgZGF0YSwgb3RoZXJEYXRhRGltLCB0YXJnZXREYXRhRGltLCBvdGhlckNvb3JkSW5kZXgsIHRhcmdldENvb3JkSW5kZXgpIHtcbiAgdmFyIGNvb3JkQXJyID0gW107XG4gIHZhciBzdGFja2VkID0gaXNEaW1lbnNpb25TdGFja2VkKGRhdGEsIHRhcmdldERhdGFEaW0gLyogLCBvdGhlckRhdGFEaW0gKi8pO1xuICB2YXIgY2FsY0RhdGFEaW0gPSBzdGFja2VkID8gZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrUmVzdWx0RGltZW5zaW9uJykgOiB0YXJnZXREYXRhRGltO1xuICB2YXIgdmFsdWUgPSBudW1DYWxjdWxhdGUoZGF0YSwgY2FsY0RhdGFEaW0sIG1hcmtlclR5cGUpO1xuICB2YXIgZGF0YUluZGV4ID0gZGF0YS5pbmRpY2VzT2ZOZWFyZXN0KGNhbGNEYXRhRGltLCB2YWx1ZSlbMF07XG4gIGNvb3JkQXJyW290aGVyQ29vcmRJbmRleF0gPSBkYXRhLmdldChvdGhlckRhdGFEaW0sIGRhdGFJbmRleCk7XG4gIGNvb3JkQXJyW3RhcmdldENvb3JkSW5kZXhdID0gZGF0YS5nZXQoY2FsY0RhdGFEaW0sIGRhdGFJbmRleCk7XG4gIHZhciBjb29yZEFyclZhbHVlID0gZGF0YS5nZXQodGFyZ2V0RGF0YURpbSwgZGF0YUluZGV4KTtcbiAgLy8gTWFrZSBpdCBzaW1wbGUsIGRvIG5vdCB2aXNpdCBhbGwgc3RhY2tlZCB2YWx1ZSB0byBjb3VudCBwcmVjaXNpb24uXG4gIHZhciBwcmVjaXNpb24gPSBudW1iZXJVdGlsLmdldFByZWNpc2lvbihkYXRhLmdldCh0YXJnZXREYXRhRGltLCBkYXRhSW5kZXgpKTtcbiAgcHJlY2lzaW9uID0gTWF0aC5taW4ocHJlY2lzaW9uLCAyMCk7XG4gIGlmIChwcmVjaXNpb24gPj0gMCkge1xuICAgIGNvb3JkQXJyW3RhcmdldENvb3JkSW5kZXhdID0gK2Nvb3JkQXJyW3RhcmdldENvb3JkSW5kZXhdLnRvRml4ZWQocHJlY2lzaW9uKTtcbiAgfVxuICByZXR1cm4gW2Nvb3JkQXJyLCBjb29yZEFyclZhbHVlXTtcbn1cbi8vIFRPRE8gU3BlY2lmaWVkIHBlcmNlbnRcbnZhciBtYXJrZXJUeXBlQ2FsY3VsYXRvciA9IHtcbiAgbWluOiBjdXJyeShtYXJrZXJUeXBlQ2FsY3VsYXRvcldpdGhFeHRlbnQsICdtaW4nKSxcbiAgbWF4OiBjdXJyeShtYXJrZXJUeXBlQ2FsY3VsYXRvcldpdGhFeHRlbnQsICdtYXgnKSxcbiAgYXZlcmFnZTogY3VycnkobWFya2VyVHlwZUNhbGN1bGF0b3JXaXRoRXh0ZW50LCAnYXZlcmFnZScpLFxuICBtZWRpYW46IGN1cnJ5KG1hcmtlclR5cGVDYWxjdWxhdG9yV2l0aEV4dGVudCwgJ21lZGlhbicpXG59O1xuLyoqXHJcbiAqIFRyYW5zZm9ybSBtYXJrUG9pbnQgZGF0YSBpdGVtIHRvIGZvcm1hdCB1c2VkIGluIExpc3QgYnkgZG8gdGhlIGZvbGxvd2luZ1xyXG4gKiAxLiBDYWxjdWxhdGUgc3RhdGlzdGljIGxpa2UgYG1heGAsIGBtaW5gLCBgYXZlcmFnZWBcclxuICogMi4gQ29udmVydCBgaXRlbS54QXhpc2AsIGBpdGVtLnlBeGlzYCB0byBgaXRlbS5jb29yZGAgYXJyYXlcclxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YVRyYW5zZm9ybShzZXJpZXNNb2RlbCwgaXRlbSkge1xuICBpZiAoIWl0ZW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gIHZhciBkaW1zID0gY29vcmRTeXMgJiYgY29vcmRTeXMuZGltZW5zaW9ucztcbiAgLy8gMS4gSWYgbm90IHNwZWNpZnkgdGhlIHBvc2l0aW9uIHdpdGggcGl4ZWwgZGlyZWN0bHlcbiAgLy8gMi4gSWYgYGNvb3JkYCBpcyBub3QgYSBkYXRhIGFycmF5LiBXaGljaCB1c2VzIGB4QXhpc2AsXG4gIC8vIGB5QXhpc2AgdG8gc3BlY2lmeSB0aGUgY29vcmQgb24gZWFjaCBkaW1lbnNpb25cbiAgLy8gcGFyc2VGbG9hdCBmaXJzdCBiZWNhdXNlIGl0ZW0ueCBhbmQgaXRlbS55IGNhbiBiZSBwZXJjZW50IHN0cmluZyBsaWtlICcyMCUnXG4gIGlmICghaGFzWEFuZFkoaXRlbSkgJiYgIWlzQXJyYXkoaXRlbS5jb29yZCkgJiYgaXNBcnJheShkaW1zKSkge1xuICAgIHZhciBheGlzSW5mbyA9IGdldEF4aXNJbmZvKGl0ZW0sIGRhdGEsIGNvb3JkU3lzLCBzZXJpZXNNb2RlbCk7XG4gICAgLy8gQ2xvbmUgdGhlIG9wdGlvblxuICAgIC8vIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyB4QXhpcywgeUF4aXMsIHJhZGl1c0F4aXMsIGFuZ2xlQXhpcywgZ2VvQ29vcmQgdG8gdmFsdWVcbiAgICBpdGVtID0gY2xvbmUoaXRlbSk7XG4gICAgaWYgKGl0ZW0udHlwZSAmJiBtYXJrZXJUeXBlQ2FsY3VsYXRvcltpdGVtLnR5cGVdICYmIGF4aXNJbmZvLmJhc2VBeGlzICYmIGF4aXNJbmZvLnZhbHVlQXhpcykge1xuICAgICAgdmFyIG90aGVyQ29vcmRJbmRleCA9IGluZGV4T2YoZGltcywgYXhpc0luZm8uYmFzZUF4aXMuZGltKTtcbiAgICAgIHZhciB0YXJnZXRDb29yZEluZGV4ID0gaW5kZXhPZihkaW1zLCBheGlzSW5mby52YWx1ZUF4aXMuZGltKTtcbiAgICAgIHZhciBjb29yZEluZm8gPSBtYXJrZXJUeXBlQ2FsY3VsYXRvcltpdGVtLnR5cGVdKGRhdGEsIGF4aXNJbmZvLmJhc2VEYXRhRGltLCBheGlzSW5mby52YWx1ZURhdGFEaW0sIG90aGVyQ29vcmRJbmRleCwgdGFyZ2V0Q29vcmRJbmRleCk7XG4gICAgICBpdGVtLmNvb3JkID0gY29vcmRJbmZvWzBdO1xuICAgICAgLy8gRm9yY2UgdG8gdXNlIHRoZSB2YWx1ZSBvZiBjYWxjdWxhdGVkIHZhbHVlLlxuICAgICAgLy8gbGV0IGl0ZW0gdXNlIHRoZSB2YWx1ZSB3aXRob3V0IHN0YWNrLlxuICAgICAgaXRlbS52YWx1ZSA9IGNvb3JkSW5mb1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUUgT25seSBoYXMgb25lIG9mIHhBeGlzIGFuZCB5QXhpcy5cbiAgICAgIGl0ZW0uY29vcmQgPSBbaXRlbS54QXhpcyAhPSBudWxsID8gaXRlbS54QXhpcyA6IGl0ZW0ucmFkaXVzQXhpcywgaXRlbS55QXhpcyAhPSBudWxsID8gaXRlbS55QXhpcyA6IGl0ZW0uYW5nbGVBeGlzXTtcbiAgICB9XG4gIH1cbiAgLy8geCB5IGlzIHByb3ZpZGVkXG4gIGlmIChpdGVtLmNvb3JkID09IG51bGwgfHwgIWlzQXJyYXkoZGltcykpIHtcbiAgICBpdGVtLmNvb3JkID0gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gRWFjaCBjb29yZCBzdXBwb3J0IG1heCwgbWluLCBhdmVyYWdlXG4gICAgdmFyIGNvb3JkID0gaXRlbS5jb29yZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgaWYgKG1hcmtlclR5cGVDYWxjdWxhdG9yW2Nvb3JkW2ldXSkge1xuICAgICAgICBjb29yZFtpXSA9IG51bUNhbGN1bGF0ZShkYXRhLCBkYXRhLm1hcERpbWVuc2lvbihkaW1zW2ldKSwgY29vcmRbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBeGlzSW5mbyhpdGVtLCBkYXRhLCBjb29yZFN5cywgc2VyaWVzTW9kZWwpIHtcbiAgdmFyIHJldCA9IHt9O1xuICBpZiAoaXRlbS52YWx1ZUluZGV4ICE9IG51bGwgfHwgaXRlbS52YWx1ZURpbSAhPSBudWxsKSB7XG4gICAgcmV0LnZhbHVlRGF0YURpbSA9IGl0ZW0udmFsdWVJbmRleCAhPSBudWxsID8gZGF0YS5nZXREaW1lbnNpb24oaXRlbS52YWx1ZUluZGV4KSA6IGl0ZW0udmFsdWVEaW07XG4gICAgcmV0LnZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoZGF0YURpbVRvQ29vcmREaW0oc2VyaWVzTW9kZWwsIHJldC52YWx1ZURhdGFEaW0pKTtcbiAgICByZXQuYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRPdGhlckF4aXMocmV0LnZhbHVlQXhpcyk7XG4gICAgcmV0LmJhc2VEYXRhRGltID0gZGF0YS5tYXBEaW1lbnNpb24ocmV0LmJhc2VBeGlzLmRpbSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0LmJhc2VBeGlzID0gc2VyaWVzTW9kZWwuZ2V0QmFzZUF4aXMoKTtcbiAgICByZXQudmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKHJldC5iYXNlQXhpcyk7XG4gICAgcmV0LmJhc2VEYXRhRGltID0gZGF0YS5tYXBEaW1lbnNpb24ocmV0LmJhc2VBeGlzLmRpbSk7XG4gICAgcmV0LnZhbHVlRGF0YURpbSA9IGRhdGEubWFwRGltZW5zaW9uKHJldC52YWx1ZUF4aXMuZGltKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gZGF0YURpbVRvQ29vcmREaW0oc2VyaWVzTW9kZWwsIGRhdGFEaW0pIHtcbiAgdmFyIGRpbUl0ZW0gPSBzZXJpZXNNb2RlbC5nZXREYXRhKCkuZ2V0RGltZW5zaW9uSW5mbyhkYXRhRGltKTtcbiAgcmV0dXJuIGRpbUl0ZW0gJiYgZGltSXRlbS5jb29yZERpbTtcbn1cbi8qKlxyXG4gKiBGaWx0ZXIgZGF0YSB3aGljaCBpcyBvdXQgb2YgY29vcmRpbmF0ZVN5c3RlbSByYW5nZVxyXG4gKiBbZGF0YUZpbHRlciBkZXNjcmlwdGlvbl1cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YUZpbHRlcihcbi8vIEN1cnJlbnRseSBvbmx5IHBvbGFyIGFuZCBjYXJ0ZXNpYW4gaGFzIGNvbnRhaW5EYXRhLlxuY29vcmRTeXMsIGl0ZW0pIHtcbiAgLy8gQWx3YXlzIHJldHVybiB0cnVlIGlmIHRoZXJlIGlzIG5vIGNvb3JkU3lzXG4gIHJldHVybiBjb29yZFN5cyAmJiBjb29yZFN5cy5jb250YWluRGF0YSAmJiBpdGVtLmNvb3JkICYmICFoYXNYT3JZKGl0ZW0pID8gY29vcmRTeXMuY29udGFpbkRhdGEoaXRlbS5jb29yZCkgOiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHpvbmVGaWx0ZXIoXG4vLyBDdXJyZW50bHkgb25seSBwb2xhciBhbmQgY2FydGVzaWFuIGhhcyBjb250YWluRGF0YS5cbmNvb3JkU3lzLCBpdGVtMSwgaXRlbTIpIHtcbiAgLy8gQWx3YXlzIHJldHVybiB0cnVlIGlmIHRoZXJlIGlzIG5vIGNvb3JkU3lzXG4gIHJldHVybiBjb29yZFN5cyAmJiBjb29yZFN5cy5jb250YWluWm9uZSAmJiBpdGVtMS5jb29yZCAmJiBpdGVtMi5jb29yZCAmJiAhaGFzWE9yWShpdGVtMSkgJiYgIWhhc1hPclkoaXRlbTIpID8gY29vcmRTeXMuY29udGFpblpvbmUoaXRlbTEuY29vcmQsIGl0ZW0yLmNvb3JkKSA6IHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWFya2VyRGltVmFsdWVHZXR0ZXIoaW5Db29yZFN5cywgZGltcykge1xuICByZXR1cm4gaW5Db29yZFN5cyA/IGZ1bmN0aW9uIChpdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgdmFyIHJhd1ZhbCA9IGRpbUluZGV4IDwgMlxuICAgIC8vIHgsIHksIHJhZGl1cywgYW5nbGVcbiAgICA/IGl0ZW0uY29vcmQgJiYgaXRlbS5jb29yZFtkaW1JbmRleF0gOiBpdGVtLnZhbHVlO1xuICAgIHJldHVybiBwYXJzZURhdGFWYWx1ZShyYXdWYWwsIGRpbXNbZGltSW5kZXhdKTtcbiAgfSA6IGZ1bmN0aW9uIChpdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVZhbHVlKGl0ZW0udmFsdWUsIGRpbXNbZGltSW5kZXhdKTtcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1DYWxjdWxhdGUoZGF0YSwgdmFsdWVEYXRhRGltLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnYXZlcmFnZScpIHtcbiAgICB2YXIgc3VtXzEgPSAwO1xuICAgIHZhciBjb3VudF8xID0gMDtcbiAgICBkYXRhLmVhY2godmFsdWVEYXRhRGltLCBmdW5jdGlvbiAodmFsLCBpZHgpIHtcbiAgICAgIGlmICghaXNOYU4odmFsKSkge1xuICAgICAgICBzdW1fMSArPSB2YWw7XG4gICAgICAgIGNvdW50XzErKztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3VtXzEgLyBjb3VudF8xO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtZWRpYW4nKSB7XG4gICAgcmV0dXJuIGRhdGEuZ2V0TWVkaWFuKHZhbHVlRGF0YURpbSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWF4ICYgbWluXG4gICAgcmV0dXJuIGRhdGEuZ2V0RGF0YUV4dGVudCh2YWx1ZURhdGFEaW0pW3R5cGUgPT09ICdtYXgnID8gMSA6IDBdO1xuICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///71171\n")},72581:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ checkMarkerInSeries)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction checkMarkerInSeries(seriesOpts, markerType) {\n  if (!seriesOpts) {\n    return false;\n  }\n  var seriesOptArr = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(seriesOpts) ? seriesOpts : [seriesOpts];\n  for (var idx = 0; idx < seriesOptArr.length; idx++) {\n    if (seriesOptArr[idx] && seriesOptArr[idx][markerType]) {\n      return true;\n    }\n  }\n  return false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI1ODEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9jaGVja01hcmtlckluU2VyaWVzLmpzPzIxOTMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNoZWNrTWFya2VySW5TZXJpZXMoc2VyaWVzT3B0cywgbWFya2VyVHlwZSkge1xuICBpZiAoIXNlcmllc09wdHMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHNlcmllc09wdEFyciA9IGlzQXJyYXkoc2VyaWVzT3B0cykgPyBzZXJpZXNPcHRzIDogW3Nlcmllc09wdHNdO1xuICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBzZXJpZXNPcHRBcnIubGVuZ3RoOyBpZHgrKykge1xuICAgIGlmIChzZXJpZXNPcHRBcnJbaWR4XSAmJiBzZXJpZXNPcHRBcnJbaWR4XVttYXJrZXJUeXBlXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///72581\n')},72589:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ onIrrelevantElement)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar IRRELEVANT_EXCLUDES = {\n  \'axisPointer\': 1,\n  \'tooltip\': 1,\n  \'brush\': 1\n};\n/**\r\n * Avoid that: mouse click on a elements that is over geo or graph,\r\n * but roam is triggered.\r\n */\nfunction onIrrelevantElement(e, api, targetCoordSysModel) {\n  var model = api.getComponentByElement(e.topTarget);\n  // If model is axisModel, it works only if it is injected with coordinateSystem.\n  var coordSys = model && model.coordinateSystem;\n  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES.hasOwnProperty(model.mainType) && coordSys && coordSys.model !== targetCoordSysModel;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI1ODkuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9jdXJzb3JIZWxwZXIuanM/MmJiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbnZhciBJUlJFTEVWQU5UX0VYQ0xVREVTID0ge1xuICAnYXhpc1BvaW50ZXInOiAxLFxuICAndG9vbHRpcCc6IDEsXG4gICdicnVzaCc6IDFcbn07XG4vKipcclxuICogQXZvaWQgdGhhdDogbW91c2UgY2xpY2sgb24gYSBlbGVtZW50cyB0aGF0IGlzIG92ZXIgZ2VvIG9yIGdyYXBoLFxyXG4gKiBidXQgcm9hbSBpcyB0cmlnZ2VyZWQuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uSXJyZWxldmFudEVsZW1lbnQoZSwgYXBpLCB0YXJnZXRDb29yZFN5c01vZGVsKSB7XG4gIHZhciBtb2RlbCA9IGFwaS5nZXRDb21wb25lbnRCeUVsZW1lbnQoZS50b3BUYXJnZXQpO1xuICAvLyBJZiBtb2RlbCBpcyBheGlzTW9kZWwsIGl0IHdvcmtzIG9ubHkgaWYgaXQgaXMgaW5qZWN0ZWQgd2l0aCBjb29yZGluYXRlU3lzdGVtLlxuICB2YXIgY29vcmRTeXMgPSBtb2RlbCAmJiBtb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICByZXR1cm4gbW9kZWwgJiYgbW9kZWwgIT09IHRhcmdldENvb3JkU3lzTW9kZWwgJiYgIUlSUkVMRVZBTlRfRVhDTFVERVMuaGFzT3duUHJvcGVydHkobW9kZWwubWFpblR5cGUpICYmIGNvb3JkU3lzICYmIGNvb3JkU3lzLm1vZGVsICE9PSB0YXJnZXRDb29yZFN5c01vZGVsO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///72589\n')},81722:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_Eventful_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(57861);\n/* harmony import */ var zrender_lib_core_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35452);\n/* harmony import */ var _interactionMutex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23868);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n;\nvar RoamController = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(RoamController, _super);\n  function RoamController(zr) {\n    var _this = _super.call(this) || this;\n    _this._zr = zr;\n    // Avoid two roamController bind the same handler\n    var mousedownHandler = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.bind)(_this._mousedownHandler, _this);\n    var mousemoveHandler = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.bind)(_this._mousemoveHandler, _this);\n    var mouseupHandler = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.bind)(_this._mouseupHandler, _this);\n    var mousewheelHandler = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.bind)(_this._mousewheelHandler, _this);\n    var pinchHandler = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.bind)(_this._pinchHandler, _this);\n    /**\r\n     * Notice: only enable needed types. For example, if 'zoom'\r\n     * is not needed, 'zoom' should not be enabled, otherwise\r\n     * default mousewheel behaviour (scroll page) will be disabled.\r\n     */\n    _this.enable = function (controlType, opt) {\n      // Disable previous first\n      this.disable();\n      this._opt = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.clone)(opt) || {}, {\n        zoomOnMouseWheel: true,\n        moveOnMouseMove: true,\n        // By default, wheel do not trigger move.\n        moveOnMouseWheel: false,\n        preventDefaultMouseMove: true\n      });\n      if (controlType == null) {\n        controlType = true;\n      }\n      if (controlType === true || controlType === 'move' || controlType === 'pan') {\n        zr.on('mousedown', mousedownHandler);\n        zr.on('mousemove', mousemoveHandler);\n        zr.on('mouseup', mouseupHandler);\n      }\n      if (controlType === true || controlType === 'scale' || controlType === 'zoom') {\n        zr.on('mousewheel', mousewheelHandler);\n        zr.on('pinch', pinchHandler);\n      }\n    };\n    _this.disable = function () {\n      zr.off('mousedown', mousedownHandler);\n      zr.off('mousemove', mousemoveHandler);\n      zr.off('mouseup', mouseupHandler);\n      zr.off('mousewheel', mousewheelHandler);\n      zr.off('pinch', pinchHandler);\n    };\n    return _this;\n  }\n  RoamController.prototype.isDragging = function () {\n    return this._dragging;\n  };\n  RoamController.prototype.isPinching = function () {\n    return this._pinching;\n  };\n  RoamController.prototype.setPointerChecker = function (pointerChecker) {\n    this.pointerChecker = pointerChecker;\n  };\n  RoamController.prototype.dispose = function () {\n    this.disable();\n  };\n  RoamController.prototype._mousedownHandler = function (e) {\n    if (zrender_lib_core_event_js__WEBPACK_IMPORTED_MODULE_2__/* .isMiddleOrRightButtonOnMouseUpDown */ .W5(e)) {\n      return;\n    }\n    var el = e.target;\n    while (el) {\n      if (el.draggable) {\n        return;\n      }\n      // check if host is draggable\n      el = el.__hostTarget || el.parent;\n    }\n    var x = e.offsetX;\n    var y = e.offsetY;\n    // Only check on mosedown, but not mousemove.\n    // Mouse can be out of target when mouse moving.\n    if (this.pointerChecker && this.pointerChecker(e, x, y)) {\n      this._x = x;\n      this._y = y;\n      this._dragging = true;\n    }\n  };\n  RoamController.prototype._mousemoveHandler = function (e) {\n    if (!this._dragging || !isAvailableBehavior('moveOnMouseMove', e, this._opt) || e.gestureEvent === 'pinch' || _interactionMutex_js__WEBPACK_IMPORTED_MODULE_3__/* .isTaken */ .Ck(this._zr, 'globalPan')) {\n      return;\n    }\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var oldX = this._x;\n    var oldY = this._y;\n    var dx = x - oldX;\n    var dy = y - oldY;\n    this._x = x;\n    this._y = y;\n    this._opt.preventDefaultMouseMove && zrender_lib_core_event_js__WEBPACK_IMPORTED_MODULE_2__/* .stop */ .ds(e.event);\n    trigger(this, 'pan', 'moveOnMouseMove', e, {\n      dx: dx,\n      dy: dy,\n      oldX: oldX,\n      oldY: oldY,\n      newX: x,\n      newY: y,\n      isAvailableBehavior: null\n    });\n  };\n  RoamController.prototype._mouseupHandler = function (e) {\n    if (!zrender_lib_core_event_js__WEBPACK_IMPORTED_MODULE_2__/* .isMiddleOrRightButtonOnMouseUpDown */ .W5(e)) {\n      this._dragging = false;\n    }\n  };\n  RoamController.prototype._mousewheelHandler = function (e) {\n    var shouldZoom = isAvailableBehavior('zoomOnMouseWheel', e, this._opt);\n    var shouldMove = isAvailableBehavior('moveOnMouseWheel', e, this._opt);\n    var wheelDelta = e.wheelDelta;\n    var absWheelDeltaDelta = Math.abs(wheelDelta);\n    var originX = e.offsetX;\n    var originY = e.offsetY;\n    // wheelDelta maybe -0 in chrome mac.\n    if (wheelDelta === 0 || !shouldZoom && !shouldMove) {\n      return;\n    }\n    // If both `shouldZoom` and `shouldMove` is true, trigger\n    // their event both, and the final behavior is determined\n    // by event listener themselves.\n    if (shouldZoom) {\n      // Convenience:\n      // Mac and VM Windows on Mac: scroll up: zoom out.\n      // Windows: scroll up: zoom in.\n      // FIXME: Should do more test in different environment.\n      // wheelDelta is too complicated in difference nvironment\n      // (https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel),\n      // although it has been normallized by zrender.\n      // wheelDelta of mouse wheel is bigger than touch pad.\n      var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;\n      var scale = wheelDelta > 0 ? factor : 1 / factor;\n      checkPointerAndTrigger(this, 'zoom', 'zoomOnMouseWheel', e, {\n        scale: scale,\n        originX: originX,\n        originY: originY,\n        isAvailableBehavior: null\n      });\n    }\n    if (shouldMove) {\n      // FIXME: Should do more test in different environment.\n      var absDelta = Math.abs(wheelDelta);\n      // wheelDelta of mouse wheel is bigger than touch pad.\n      var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);\n      checkPointerAndTrigger(this, 'scrollMove', 'moveOnMouseWheel', e, {\n        scrollDelta: scrollDelta,\n        originX: originX,\n        originY: originY,\n        isAvailableBehavior: null\n      });\n    }\n  };\n  RoamController.prototype._pinchHandler = function (e) {\n    if (_interactionMutex_js__WEBPACK_IMPORTED_MODULE_3__/* .isTaken */ .Ck(this._zr, 'globalPan')) {\n      return;\n    }\n    var scale = e.pinchScale > 1 ? 1.1 : 1 / 1.1;\n    checkPointerAndTrigger(this, 'zoom', null, e, {\n      scale: scale,\n      originX: e.pinchX,\n      originY: e.pinchY,\n      isAvailableBehavior: null\n    });\n  };\n  return RoamController;\n}(zrender_lib_core_Eventful_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A);\nfunction checkPointerAndTrigger(controller, eventName, behaviorToCheck, e, contollerEvent) {\n  if (controller.pointerChecker && controller.pointerChecker(e, contollerEvent.originX, contollerEvent.originY)) {\n    // When mouse is out of roamController rect,\n    // default befavoius should not be be disabled, otherwise\n    // page sliding is disabled, contrary to expectation.\n    zrender_lib_core_event_js__WEBPACK_IMPORTED_MODULE_2__/* .stop */ .ds(e.event);\n    trigger(controller, eventName, behaviorToCheck, e, contollerEvent);\n  }\n}\nfunction trigger(controller, eventName, behaviorToCheck, e, contollerEvent) {\n  // Also provide behavior checker for event listener, for some case that\n  // multiple components share one listener.\n  contollerEvent.isAvailableBehavior = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.bind)(isAvailableBehavior, null, behaviorToCheck, e);\n  // TODO should not have type issue.\n  controller.trigger(eventName, contollerEvent);\n}\n// settings: {\n//     zoomOnMouseWheel\n//     moveOnMouseMove\n//     moveOnMouseWheel\n// }\n// The value can be: true / false / 'shift' / 'ctrl' / 'alt'.\nfunction isAvailableBehavior(behaviorToCheck, e, settings) {\n  var setting = settings[behaviorToCheck];\n  return !behaviorToCheck || setting && (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString)(setting) || e.event[setting + 'Key']);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoamController);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE3MjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXIuanM/NzQ4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IEV2ZW50ZnVsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvRXZlbnRmdWwuanMnO1xuaW1wb3J0ICogYXMgZXZlbnRUb29sIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanMnO1xuaW1wb3J0ICogYXMgaW50ZXJhY3Rpb25NdXRleCBmcm9tICcuL2ludGVyYWN0aW9uTXV0ZXguanMnO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGJpbmQsIGRlZmF1bHRzLCBjbG9uZSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG47XG52YXIgUm9hbUNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUm9hbUNvbnRyb2xsZXIsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFJvYW1Db250cm9sbGVyKHpyKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5fenIgPSB6cjtcbiAgICAvLyBBdm9pZCB0d28gcm9hbUNvbnRyb2xsZXIgYmluZCB0aGUgc2FtZSBoYW5kbGVyXG4gICAgdmFyIG1vdXNlZG93bkhhbmRsZXIgPSBiaW5kKF90aGlzLl9tb3VzZWRvd25IYW5kbGVyLCBfdGhpcyk7XG4gICAgdmFyIG1vdXNlbW92ZUhhbmRsZXIgPSBiaW5kKF90aGlzLl9tb3VzZW1vdmVIYW5kbGVyLCBfdGhpcyk7XG4gICAgdmFyIG1vdXNldXBIYW5kbGVyID0gYmluZChfdGhpcy5fbW91c2V1cEhhbmRsZXIsIF90aGlzKTtcbiAgICB2YXIgbW91c2V3aGVlbEhhbmRsZXIgPSBiaW5kKF90aGlzLl9tb3VzZXdoZWVsSGFuZGxlciwgX3RoaXMpO1xuICAgIHZhciBwaW5jaEhhbmRsZXIgPSBiaW5kKF90aGlzLl9waW5jaEhhbmRsZXIsIF90aGlzKTtcbiAgICAvKipcclxuICAgICAqIE5vdGljZTogb25seSBlbmFibGUgbmVlZGVkIHR5cGVzLiBGb3IgZXhhbXBsZSwgaWYgJ3pvb20nXHJcbiAgICAgKiBpcyBub3QgbmVlZGVkLCAnem9vbScgc2hvdWxkIG5vdCBiZSBlbmFibGVkLCBvdGhlcndpc2VcclxuICAgICAqIGRlZmF1bHQgbW91c2V3aGVlbCBiZWhhdmlvdXIgKHNjcm9sbCBwYWdlKSB3aWxsIGJlIGRpc2FibGVkLlxyXG4gICAgICovXG4gICAgX3RoaXMuZW5hYmxlID0gZnVuY3Rpb24gKGNvbnRyb2xUeXBlLCBvcHQpIHtcbiAgICAgIC8vIERpc2FibGUgcHJldmlvdXMgZmlyc3RcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgdGhpcy5fb3B0ID0gZGVmYXVsdHMoY2xvbmUob3B0KSB8fCB7fSwge1xuICAgICAgICB6b29tT25Nb3VzZVdoZWVsOiB0cnVlLFxuICAgICAgICBtb3ZlT25Nb3VzZU1vdmU6IHRydWUsXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHdoZWVsIGRvIG5vdCB0cmlnZ2VyIG1vdmUuXG4gICAgICAgIG1vdmVPbk1vdXNlV2hlZWw6IGZhbHNlLFxuICAgICAgICBwcmV2ZW50RGVmYXVsdE1vdXNlTW92ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoY29udHJvbFR5cGUgPT0gbnVsbCkge1xuICAgICAgICBjb250cm9sVHlwZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY29udHJvbFR5cGUgPT09IHRydWUgfHwgY29udHJvbFR5cGUgPT09ICdtb3ZlJyB8fCBjb250cm9sVHlwZSA9PT0gJ3BhbicpIHtcbiAgICAgICAgenIub24oJ21vdXNlZG93bicsIG1vdXNlZG93bkhhbmRsZXIpO1xuICAgICAgICB6ci5vbignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlSGFuZGxlcik7XG4gICAgICAgIHpyLm9uKCdtb3VzZXVwJywgbW91c2V1cEhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRyb2xUeXBlID09PSB0cnVlIHx8IGNvbnRyb2xUeXBlID09PSAnc2NhbGUnIHx8IGNvbnRyb2xUeXBlID09PSAnem9vbScpIHtcbiAgICAgICAgenIub24oJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsSGFuZGxlcik7XG4gICAgICAgIHpyLm9uKCdwaW5jaCcsIHBpbmNoSGFuZGxlcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBfdGhpcy5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgenIub2ZmKCdtb3VzZWRvd24nLCBtb3VzZWRvd25IYW5kbGVyKTtcbiAgICAgIHpyLm9mZignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlSGFuZGxlcik7XG4gICAgICB6ci5vZmYoJ21vdXNldXAnLCBtb3VzZXVwSGFuZGxlcik7XG4gICAgICB6ci5vZmYoJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsSGFuZGxlcik7XG4gICAgICB6ci5vZmYoJ3BpbmNoJywgcGluY2hIYW5kbGVyKTtcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBSb2FtQ29udHJvbGxlci5wcm90b3R5cGUuaXNEcmFnZ2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJhZ2dpbmc7XG4gIH07XG4gIFJvYW1Db250cm9sbGVyLnByb3RvdHlwZS5pc1BpbmNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9waW5jaGluZztcbiAgfTtcbiAgUm9hbUNvbnRyb2xsZXIucHJvdG90eXBlLnNldFBvaW50ZXJDaGVja2VyID0gZnVuY3Rpb24gKHBvaW50ZXJDaGVja2VyKSB7XG4gICAgdGhpcy5wb2ludGVyQ2hlY2tlciA9IHBvaW50ZXJDaGVja2VyO1xuICB9O1xuICBSb2FtQ29udHJvbGxlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgfTtcbiAgUm9hbUNvbnRyb2xsZXIucHJvdG90eXBlLl9tb3VzZWRvd25IYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZXZlbnRUb29sLmlzTWlkZGxlT3JSaWdodEJ1dHRvbk9uTW91c2VVcERvd24oZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBpZiAoZWwuZHJhZ2dhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIGlmIGhvc3QgaXMgZHJhZ2dhYmxlXG4gICAgICBlbCA9IGVsLl9faG9zdFRhcmdldCB8fCBlbC5wYXJlbnQ7XG4gICAgfVxuICAgIHZhciB4ID0gZS5vZmZzZXRYO1xuICAgIHZhciB5ID0gZS5vZmZzZXRZO1xuICAgIC8vIE9ubHkgY2hlY2sgb24gbW9zZWRvd24sIGJ1dCBub3QgbW91c2Vtb3ZlLlxuICAgIC8vIE1vdXNlIGNhbiBiZSBvdXQgb2YgdGFyZ2V0IHdoZW4gbW91c2UgbW92aW5nLlxuICAgIGlmICh0aGlzLnBvaW50ZXJDaGVja2VyICYmIHRoaXMucG9pbnRlckNoZWNrZXIoZSwgeCwgeSkpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICB0aGlzLl9kcmFnZ2luZyA9IHRydWU7XG4gICAgfVxuICB9O1xuICBSb2FtQ29udHJvbGxlci5wcm90b3R5cGUuX21vdXNlbW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmICghdGhpcy5fZHJhZ2dpbmcgfHwgIWlzQXZhaWxhYmxlQmVoYXZpb3IoJ21vdmVPbk1vdXNlTW92ZScsIGUsIHRoaXMuX29wdCkgfHwgZS5nZXN0dXJlRXZlbnQgPT09ICdwaW5jaCcgfHwgaW50ZXJhY3Rpb25NdXRleC5pc1Rha2VuKHRoaXMuX3pyLCAnZ2xvYmFsUGFuJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHggPSBlLm9mZnNldFg7XG4gICAgdmFyIHkgPSBlLm9mZnNldFk7XG4gICAgdmFyIG9sZFggPSB0aGlzLl94O1xuICAgIHZhciBvbGRZID0gdGhpcy5feTtcbiAgICB2YXIgZHggPSB4IC0gb2xkWDtcbiAgICB2YXIgZHkgPSB5IC0gb2xkWTtcbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl95ID0geTtcbiAgICB0aGlzLl9vcHQucHJldmVudERlZmF1bHRNb3VzZU1vdmUgJiYgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XG4gICAgdHJpZ2dlcih0aGlzLCAncGFuJywgJ21vdmVPbk1vdXNlTW92ZScsIGUsIHtcbiAgICAgIGR4OiBkeCxcbiAgICAgIGR5OiBkeSxcbiAgICAgIG9sZFg6IG9sZFgsXG4gICAgICBvbGRZOiBvbGRZLFxuICAgICAgbmV3WDogeCxcbiAgICAgIG5ld1k6IHksXG4gICAgICBpc0F2YWlsYWJsZUJlaGF2aW9yOiBudWxsXG4gICAgfSk7XG4gIH07XG4gIFJvYW1Db250cm9sbGVyLnByb3RvdHlwZS5fbW91c2V1cEhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmICghZXZlbnRUb29sLmlzTWlkZGxlT3JSaWdodEJ1dHRvbk9uTW91c2VVcERvd24oZSkpIHtcbiAgICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBSb2FtQ29udHJvbGxlci5wcm90b3R5cGUuX21vdXNld2hlZWxIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2hvdWxkWm9vbSA9IGlzQXZhaWxhYmxlQmVoYXZpb3IoJ3pvb21Pbk1vdXNlV2hlZWwnLCBlLCB0aGlzLl9vcHQpO1xuICAgIHZhciBzaG91bGRNb3ZlID0gaXNBdmFpbGFibGVCZWhhdmlvcignbW92ZU9uTW91c2VXaGVlbCcsIGUsIHRoaXMuX29wdCk7XG4gICAgdmFyIHdoZWVsRGVsdGEgPSBlLndoZWVsRGVsdGE7XG4gICAgdmFyIGFic1doZWVsRGVsdGFEZWx0YSA9IE1hdGguYWJzKHdoZWVsRGVsdGEpO1xuICAgIHZhciBvcmlnaW5YID0gZS5vZmZzZXRYO1xuICAgIHZhciBvcmlnaW5ZID0gZS5vZmZzZXRZO1xuICAgIC8vIHdoZWVsRGVsdGEgbWF5YmUgLTAgaW4gY2hyb21lIG1hYy5cbiAgICBpZiAod2hlZWxEZWx0YSA9PT0gMCB8fCAhc2hvdWxkWm9vbSAmJiAhc2hvdWxkTW92ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiBib3RoIGBzaG91bGRab29tYCBhbmQgYHNob3VsZE1vdmVgIGlzIHRydWUsIHRyaWdnZXJcbiAgICAvLyB0aGVpciBldmVudCBib3RoLCBhbmQgdGhlIGZpbmFsIGJlaGF2aW9yIGlzIGRldGVybWluZWRcbiAgICAvLyBieSBldmVudCBsaXN0ZW5lciB0aGVtc2VsdmVzLlxuICAgIGlmIChzaG91bGRab29tKSB7XG4gICAgICAvLyBDb252ZW5pZW5jZTpcbiAgICAgIC8vIE1hYyBhbmQgVk0gV2luZG93cyBvbiBNYWM6IHNjcm9sbCB1cDogem9vbSBvdXQuXG4gICAgICAvLyBXaW5kb3dzOiBzY3JvbGwgdXA6IHpvb20gaW4uXG4gICAgICAvLyBGSVhNRTogU2hvdWxkIGRvIG1vcmUgdGVzdCBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnQuXG4gICAgICAvLyB3aGVlbERlbHRhIGlzIHRvbyBjb21wbGljYXRlZCBpbiBkaWZmZXJlbmNlIG52aXJvbm1lbnRcbiAgICAgIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvbW91c2V3aGVlbCksXG4gICAgICAvLyBhbHRob3VnaCBpdCBoYXMgYmVlbiBub3JtYWxsaXplZCBieSB6cmVuZGVyLlxuICAgICAgLy8gd2hlZWxEZWx0YSBvZiBtb3VzZSB3aGVlbCBpcyBiaWdnZXIgdGhhbiB0b3VjaCBwYWQuXG4gICAgICB2YXIgZmFjdG9yID0gYWJzV2hlZWxEZWx0YURlbHRhID4gMyA/IDEuNCA6IGFic1doZWVsRGVsdGFEZWx0YSA+IDEgPyAxLjIgOiAxLjE7XG4gICAgICB2YXIgc2NhbGUgPSB3aGVlbERlbHRhID4gMCA/IGZhY3RvciA6IDEgLyBmYWN0b3I7XG4gICAgICBjaGVja1BvaW50ZXJBbmRUcmlnZ2VyKHRoaXMsICd6b29tJywgJ3pvb21Pbk1vdXNlV2hlZWwnLCBlLCB7XG4gICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgb3JpZ2luWDogb3JpZ2luWCxcbiAgICAgICAgb3JpZ2luWTogb3JpZ2luWSxcbiAgICAgICAgaXNBdmFpbGFibGVCZWhhdmlvcjogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzaG91bGRNb3ZlKSB7XG4gICAgICAvLyBGSVhNRTogU2hvdWxkIGRvIG1vcmUgdGVzdCBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnQuXG4gICAgICB2YXIgYWJzRGVsdGEgPSBNYXRoLmFicyh3aGVlbERlbHRhKTtcbiAgICAgIC8vIHdoZWVsRGVsdGEgb2YgbW91c2Ugd2hlZWwgaXMgYmlnZ2VyIHRoYW4gdG91Y2ggcGFkLlxuICAgICAgdmFyIHNjcm9sbERlbHRhID0gKHdoZWVsRGVsdGEgPiAwID8gMSA6IC0xKSAqIChhYnNEZWx0YSA+IDMgPyAwLjQgOiBhYnNEZWx0YSA+IDEgPyAwLjE1IDogMC4wNSk7XG4gICAgICBjaGVja1BvaW50ZXJBbmRUcmlnZ2VyKHRoaXMsICdzY3JvbGxNb3ZlJywgJ21vdmVPbk1vdXNlV2hlZWwnLCBlLCB7XG4gICAgICAgIHNjcm9sbERlbHRhOiBzY3JvbGxEZWx0YSxcbiAgICAgICAgb3JpZ2luWDogb3JpZ2luWCxcbiAgICAgICAgb3JpZ2luWTogb3JpZ2luWSxcbiAgICAgICAgaXNBdmFpbGFibGVCZWhhdmlvcjogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBSb2FtQ29udHJvbGxlci5wcm90b3R5cGUuX3BpbmNoSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGludGVyYWN0aW9uTXV0ZXguaXNUYWtlbih0aGlzLl96ciwgJ2dsb2JhbFBhbicpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzY2FsZSA9IGUucGluY2hTY2FsZSA+IDEgPyAxLjEgOiAxIC8gMS4xO1xuICAgIGNoZWNrUG9pbnRlckFuZFRyaWdnZXIodGhpcywgJ3pvb20nLCBudWxsLCBlLCB7XG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBvcmlnaW5YOiBlLnBpbmNoWCxcbiAgICAgIG9yaWdpblk6IGUucGluY2hZLFxuICAgICAgaXNBdmFpbGFibGVCZWhhdmlvcjogbnVsbFxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gUm9hbUNvbnRyb2xsZXI7XG59KEV2ZW50ZnVsKTtcbmZ1bmN0aW9uIGNoZWNrUG9pbnRlckFuZFRyaWdnZXIoY29udHJvbGxlciwgZXZlbnROYW1lLCBiZWhhdmlvclRvQ2hlY2ssIGUsIGNvbnRvbGxlckV2ZW50KSB7XG4gIGlmIChjb250cm9sbGVyLnBvaW50ZXJDaGVja2VyICYmIGNvbnRyb2xsZXIucG9pbnRlckNoZWNrZXIoZSwgY29udG9sbGVyRXZlbnQub3JpZ2luWCwgY29udG9sbGVyRXZlbnQub3JpZ2luWSkpIHtcbiAgICAvLyBXaGVuIG1vdXNlIGlzIG91dCBvZiByb2FtQ29udHJvbGxlciByZWN0LFxuICAgIC8vIGRlZmF1bHQgYmVmYXZvaXVzIHNob3VsZCBub3QgYmUgYmUgZGlzYWJsZWQsIG90aGVyd2lzZVxuICAgIC8vIHBhZ2Ugc2xpZGluZyBpcyBkaXNhYmxlZCwgY29udHJhcnkgdG8gZXhwZWN0YXRpb24uXG4gICAgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XG4gICAgdHJpZ2dlcihjb250cm9sbGVyLCBldmVudE5hbWUsIGJlaGF2aW9yVG9DaGVjaywgZSwgY29udG9sbGVyRXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyKGNvbnRyb2xsZXIsIGV2ZW50TmFtZSwgYmVoYXZpb3JUb0NoZWNrLCBlLCBjb250b2xsZXJFdmVudCkge1xuICAvLyBBbHNvIHByb3ZpZGUgYmVoYXZpb3IgY2hlY2tlciBmb3IgZXZlbnQgbGlzdGVuZXIsIGZvciBzb21lIGNhc2UgdGhhdFxuICAvLyBtdWx0aXBsZSBjb21wb25lbnRzIHNoYXJlIG9uZSBsaXN0ZW5lci5cbiAgY29udG9sbGVyRXZlbnQuaXNBdmFpbGFibGVCZWhhdmlvciA9IGJpbmQoaXNBdmFpbGFibGVCZWhhdmlvciwgbnVsbCwgYmVoYXZpb3JUb0NoZWNrLCBlKTtcbiAgLy8gVE9ETyBzaG91bGQgbm90IGhhdmUgdHlwZSBpc3N1ZS5cbiAgY29udHJvbGxlci50cmlnZ2VyKGV2ZW50TmFtZSwgY29udG9sbGVyRXZlbnQpO1xufVxuLy8gc2V0dGluZ3M6IHtcbi8vICAgICB6b29tT25Nb3VzZVdoZWVsXG4vLyAgICAgbW92ZU9uTW91c2VNb3ZlXG4vLyAgICAgbW92ZU9uTW91c2VXaGVlbFxuLy8gfVxuLy8gVGhlIHZhbHVlIGNhbiBiZTogdHJ1ZSAvIGZhbHNlIC8gJ3NoaWZ0JyAvICdjdHJsJyAvICdhbHQnLlxuZnVuY3Rpb24gaXNBdmFpbGFibGVCZWhhdmlvcihiZWhhdmlvclRvQ2hlY2ssIGUsIHNldHRpbmdzKSB7XG4gIHZhciBzZXR0aW5nID0gc2V0dGluZ3NbYmVoYXZpb3JUb0NoZWNrXTtcbiAgcmV0dXJuICFiZWhhdmlvclRvQ2hlY2sgfHwgc2V0dGluZyAmJiAoIWlzU3RyaW5nKHNldHRpbmcpIHx8IGUuZXZlbnRbc2V0dGluZyArICdLZXknXSk7XG59XG5leHBvcnQgZGVmYXVsdCBSb2FtQ29udHJvbGxlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///81722\n")},82802:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98026);\n/* harmony import */ var zrender_lib_core_env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38123);\n/* harmony import */ var _model_mixin_dataFormat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9427);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(15915);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n/* harmony import */ var _tooltip_tooltipMarkup_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3961);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nfunction fillLabel(opt) {\n  (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .defaultEmphasis */ .M5)(opt, 'label', ['show']);\n}\n// { [componentType]: MarkerModel }\nvar inner = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nvar MarkerModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .C6)(MarkerModel, _super);\n  function MarkerModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = MarkerModel.type;\n    /**\r\n     * If marker model is created by self from series\r\n     */\n    _this.createdBySelf = false;\n    return _this;\n  }\n  /**\r\n   * @overrite\r\n   */\n  MarkerModel.prototype.init = function (option, parentModel, ecModel) {\n    if (false) {}\n    this.mergeDefaultAndTheme(option, ecModel);\n    this._mergeOption(option, ecModel, false, true);\n  };\n  MarkerModel.prototype.isAnimationEnabled = function () {\n    if (zrender_lib_core_env_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A.node) {\n      return false;\n    }\n    var hostSeries = this.__hostSeries;\n    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();\n  };\n  /**\r\n   * @overrite\r\n   */\n  MarkerModel.prototype.mergeOption = function (newOpt, ecModel) {\n    this._mergeOption(newOpt, ecModel, false, false);\n  };\n  MarkerModel.prototype._mergeOption = function (newOpt, ecModel, createdBySelf, isInit) {\n    var componentType = this.mainType;\n    if (!createdBySelf) {\n      ecModel.eachSeries(function (seriesModel) {\n        // mainType can be markPoint, markLine, markArea\n        var markerOpt = seriesModel.get(this.mainType, true);\n        var markerModel = inner(seriesModel)[componentType];\n        if (!markerOpt || !markerOpt.data) {\n          inner(seriesModel)[componentType] = null;\n          return;\n        }\n        if (!markerModel) {\n          if (isInit) {\n            // Default label emphasis `position` and `show`\n            fillLabel(markerOpt);\n          }\n          zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.each(markerOpt.data, function (item) {\n            // FIXME Overwrite fillLabel method ?\n            if (item instanceof Array) {\n              fillLabel(item[0]);\n              fillLabel(item[1]);\n            } else {\n              fillLabel(item);\n            }\n          });\n          markerModel = this.createMarkerModelFromSeries(markerOpt, this, ecModel);\n          // markerModel = new ImplementedMarkerModel(\n          //     markerOpt, this, ecModel\n          // );\n          zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.extend(markerModel, {\n            mainType: this.mainType,\n            // Use the same series index and name\n            seriesIndex: seriesModel.seriesIndex,\n            name: seriesModel.name,\n            createdBySelf: true\n          });\n          markerModel.__hostSeries = seriesModel;\n        } else {\n          markerModel._mergeOption(markerOpt, ecModel, true);\n        }\n        inner(seriesModel)[componentType] = markerModel;\n      }, this);\n    }\n  };\n  MarkerModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n    var data = this.getData();\n    var value = this.getRawValue(dataIndex);\n    var itemName = data.getName(dataIndex);\n    return (0,_tooltip_tooltipMarkup_js__WEBPACK_IMPORTED_MODULE_4__/* .createTooltipMarkup */ .Qx)('section', {\n      header: this.name,\n      blocks: [(0,_tooltip_tooltipMarkup_js__WEBPACK_IMPORTED_MODULE_4__/* .createTooltipMarkup */ .Qx)('nameValue', {\n        name: itemName,\n        value: value,\n        noName: !itemName,\n        noValue: value == null\n      })]\n    });\n  };\n  MarkerModel.prototype.getData = function () {\n    return this._data;\n  };\n  MarkerModel.prototype.setData = function (data) {\n    this._data = data;\n  };\n  MarkerModel.prototype.getDataParams = function (dataIndex, dataType) {\n    var params = _model_mixin_dataFormat_js__WEBPACK_IMPORTED_MODULE_5__/* .DataFormatMixin */ .J.prototype.getDataParams.call(this, dataIndex, dataType);\n    var hostSeries = this.__hostSeries;\n    if (hostSeries) {\n      params.seriesId = hostSeries.id;\n      params.seriesName = hostSeries.name;\n      params.seriesType = hostSeries.subType;\n    }\n    return params;\n  };\n  MarkerModel.getMarkerModelFromSeries = function (seriesModel,\n  // Support three types of markers. Strict check.\n  componentType) {\n    return inner(seriesModel)[componentType];\n  };\n  MarkerModel.type = 'marker';\n  MarkerModel.dependencies = ['series', 'grid', 'polar', 'geo'];\n  return MarkerModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A);\nzrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.mixin(MarkerModel, _model_mixin_dataFormat_js__WEBPACK_IMPORTED_MODULE_5__/* .DataFormatMixin */ .J.prototype);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MarkerModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI4MDIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya2VyTW9kZWwuanM/NGExMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgZW52IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvZW52LmpzJztcbmltcG9ydCB7IERhdGFGb3JtYXRNaXhpbiB9IGZyb20gJy4uLy4uL21vZGVsL21peGluL2RhdGFGb3JtYXQuanMnO1xuaW1wb3J0IENvbXBvbmVudE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL0NvbXBvbmVudC5qcyc7XG5pbXBvcnQgeyBtYWtlSW5uZXIsIGRlZmF1bHRFbXBoYXNpcyB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xuaW1wb3J0IHsgY3JlYXRlVG9vbHRpcE1hcmt1cCB9IGZyb20gJy4uL3Rvb2x0aXAvdG9vbHRpcE1hcmt1cC5qcyc7XG5mdW5jdGlvbiBmaWxsTGFiZWwob3B0KSB7XG4gIGRlZmF1bHRFbXBoYXNpcyhvcHQsICdsYWJlbCcsIFsnc2hvdyddKTtcbn1cbi8vIHsgW2NvbXBvbmVudFR5cGVdOiBNYXJrZXJNb2RlbCB9XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbnZhciBNYXJrZXJNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNYXJrZXJNb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gTWFya2VyTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IE1hcmtlck1vZGVsLnR5cGU7XG4gICAgLyoqXHJcbiAgICAgKiBJZiBtYXJrZXIgbW9kZWwgaXMgY3JlYXRlZCBieSBzZWxmIGZyb20gc2VyaWVzXHJcbiAgICAgKi9cbiAgICBfdGhpcy5jcmVhdGVkQnlTZWxmID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIEBvdmVycml0ZVxyXG4gICAqL1xuICBNYXJrZXJNb2RlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdtYXJrZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWFya2VyIGNvbXBvbmVudCBpcyBhYnN0cmFjdCBjb21wb25lbnQuIFVzZSBtYXJrTGluZSwgbWFya1BvaW50LCBtYXJrQXJlYSBpbnN0ZWFkLicpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1lcmdlRGVmYXVsdEFuZFRoZW1lKG9wdGlvbiwgZWNNb2RlbCk7XG4gICAgdGhpcy5fbWVyZ2VPcHRpb24ob3B0aW9uLCBlY01vZGVsLCBmYWxzZSwgdHJ1ZSk7XG4gIH07XG4gIE1hcmtlck1vZGVsLnByb3RvdHlwZS5pc0FuaW1hdGlvbkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBob3N0U2VyaWVzID0gdGhpcy5fX2hvc3RTZXJpZXM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2hhbGxvdygnYW5pbWF0aW9uJykgJiYgaG9zdFNlcmllcyAmJiBob3N0U2VyaWVzLmlzQW5pbWF0aW9uRW5hYmxlZCgpO1xuICB9O1xuICAvKipcclxuICAgKiBAb3ZlcnJpdGVcclxuICAgKi9cbiAgTWFya2VyTW9kZWwucHJvdG90eXBlLm1lcmdlT3B0aW9uID0gZnVuY3Rpb24gKG5ld09wdCwgZWNNb2RlbCkge1xuICAgIHRoaXMuX21lcmdlT3B0aW9uKG5ld09wdCwgZWNNb2RlbCwgZmFsc2UsIGZhbHNlKTtcbiAgfTtcbiAgTWFya2VyTW9kZWwucHJvdG90eXBlLl9tZXJnZU9wdGlvbiA9IGZ1bmN0aW9uIChuZXdPcHQsIGVjTW9kZWwsIGNyZWF0ZWRCeVNlbGYsIGlzSW5pdCkge1xuICAgIHZhciBjb21wb25lbnRUeXBlID0gdGhpcy5tYWluVHlwZTtcbiAgICBpZiAoIWNyZWF0ZWRCeVNlbGYpIHtcbiAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgLy8gbWFpblR5cGUgY2FuIGJlIG1hcmtQb2ludCwgbWFya0xpbmUsIG1hcmtBcmVhXG4gICAgICAgIHZhciBtYXJrZXJPcHQgPSBzZXJpZXNNb2RlbC5nZXQodGhpcy5tYWluVHlwZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBtYXJrZXJNb2RlbCA9IGlubmVyKHNlcmllc01vZGVsKVtjb21wb25lbnRUeXBlXTtcbiAgICAgICAgaWYgKCFtYXJrZXJPcHQgfHwgIW1hcmtlck9wdC5kYXRhKSB7XG4gICAgICAgICAgaW5uZXIoc2VyaWVzTW9kZWwpW2NvbXBvbmVudFR5cGVdID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXJrZXJNb2RlbCkge1xuICAgICAgICAgIGlmIChpc0luaXQpIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgbGFiZWwgZW1waGFzaXMgYHBvc2l0aW9uYCBhbmQgYHNob3dgXG4gICAgICAgICAgICBmaWxsTGFiZWwobWFya2VyT3B0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgenJVdGlsLmVhY2gobWFya2VyT3B0LmRhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBPdmVyd3JpdGUgZmlsbExhYmVsIG1ldGhvZCA/XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgIGZpbGxMYWJlbChpdGVtWzBdKTtcbiAgICAgICAgICAgICAgZmlsbExhYmVsKGl0ZW1bMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmlsbExhYmVsKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1hcmtlck1vZGVsID0gdGhpcy5jcmVhdGVNYXJrZXJNb2RlbEZyb21TZXJpZXMobWFya2VyT3B0LCB0aGlzLCBlY01vZGVsKTtcbiAgICAgICAgICAvLyBtYXJrZXJNb2RlbCA9IG5ldyBJbXBsZW1lbnRlZE1hcmtlck1vZGVsKFxuICAgICAgICAgIC8vICAgICBtYXJrZXJPcHQsIHRoaXMsIGVjTW9kZWxcbiAgICAgICAgICAvLyApO1xuICAgICAgICAgIHpyVXRpbC5leHRlbmQobWFya2VyTW9kZWwsIHtcbiAgICAgICAgICAgIG1haW5UeXBlOiB0aGlzLm1haW5UeXBlLFxuICAgICAgICAgICAgLy8gVXNlIHRoZSBzYW1lIHNlcmllcyBpbmRleCBhbmQgbmFtZVxuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc01vZGVsLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgbmFtZTogc2VyaWVzTW9kZWwubmFtZSxcbiAgICAgICAgICAgIGNyZWF0ZWRCeVNlbGY6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtYXJrZXJNb2RlbC5fX2hvc3RTZXJpZXMgPSBzZXJpZXNNb2RlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXJrZXJNb2RlbC5fbWVyZ2VPcHRpb24obWFya2VyT3B0LCBlY01vZGVsLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lcihzZXJpZXNNb2RlbClbY29tcG9uZW50VHlwZV0gPSBtYXJrZXJNb2RlbDtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgTWFya2VyTW9kZWwucHJvdG90eXBlLmZvcm1hdFRvb2x0aXAgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBtdWx0aXBsZVNlcmllcywgZGF0YVR5cGUpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0UmF3VmFsdWUoZGF0YUluZGV4KTtcbiAgICB2YXIgaXRlbU5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4KTtcbiAgICByZXR1cm4gY3JlYXRlVG9vbHRpcE1hcmt1cCgnc2VjdGlvbicsIHtcbiAgICAgIGhlYWRlcjogdGhpcy5uYW1lLFxuICAgICAgYmxvY2tzOiBbY3JlYXRlVG9vbHRpcE1hcmt1cCgnbmFtZVZhbHVlJywge1xuICAgICAgICBuYW1lOiBpdGVtTmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBub05hbWU6ICFpdGVtTmFtZSxcbiAgICAgICAgbm9WYWx1ZTogdmFsdWUgPT0gbnVsbFxuICAgICAgfSldXG4gICAgfSk7XG4gIH07XG4gIE1hcmtlck1vZGVsLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9O1xuICBNYXJrZXJNb2RlbC5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH07XG4gIE1hcmtlck1vZGVsLnByb3RvdHlwZS5nZXREYXRhUGFyYW1zID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgZGF0YVR5cGUpIHtcbiAgICB2YXIgcGFyYW1zID0gRGF0YUZvcm1hdE1peGluLnByb3RvdHlwZS5nZXREYXRhUGFyYW1zLmNhbGwodGhpcywgZGF0YUluZGV4LCBkYXRhVHlwZSk7XG4gICAgdmFyIGhvc3RTZXJpZXMgPSB0aGlzLl9faG9zdFNlcmllcztcbiAgICBpZiAoaG9zdFNlcmllcykge1xuICAgICAgcGFyYW1zLnNlcmllc0lkID0gaG9zdFNlcmllcy5pZDtcbiAgICAgIHBhcmFtcy5zZXJpZXNOYW1lID0gaG9zdFNlcmllcy5uYW1lO1xuICAgICAgcGFyYW1zLnNlcmllc1R5cGUgPSBob3N0U2VyaWVzLnN1YlR5cGU7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG4gIH07XG4gIE1hcmtlck1vZGVsLmdldE1hcmtlck1vZGVsRnJvbVNlcmllcyA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCxcbiAgLy8gU3VwcG9ydCB0aHJlZSB0eXBlcyBvZiBtYXJrZXJzLiBTdHJpY3QgY2hlY2suXG4gIGNvbXBvbmVudFR5cGUpIHtcbiAgICByZXR1cm4gaW5uZXIoc2VyaWVzTW9kZWwpW2NvbXBvbmVudFR5cGVdO1xuICB9O1xuICBNYXJrZXJNb2RlbC50eXBlID0gJ21hcmtlcic7XG4gIE1hcmtlck1vZGVsLmRlcGVuZGVuY2llcyA9IFsnc2VyaWVzJywgJ2dyaWQnLCAncG9sYXInLCAnZ2VvJ107XG4gIHJldHVybiBNYXJrZXJNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuenJVdGlsLm1peGluKE1hcmtlck1vZGVsLCBEYXRhRm9ybWF0TWl4aW4ucHJvdG90eXBlKTtcbmV4cG9ydCBkZWZhdWx0IE1hcmtlck1vZGVsOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///82802\n")},98983:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ sliderMove)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * Calculate slider move result.\r\n * Usage:\r\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\r\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\r\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\r\n *\r\n * @param delta Move length.\r\n * @param handleEnds handleEnds[0] can be bigger then handleEnds[1].\r\n *              handleEnds will be modified in this method.\r\n * @param extent handleEnds is restricted by extent.\r\n *              extent[0] should less or equals than extent[1].\r\n * @param handleIndex Can be \'all\', means that both move the two handleEnds.\r\n * @param minSpan The range of dataZoom can not be smaller than that.\r\n *              If not set, handle0 and cross handle1. If set as a non-negative\r\n *              number (including `0`), handles will push each other when reaching\r\n *              the minSpan.\r\n * @param maxSpan The range of dataZoom can not be larger than that.\r\n * @return The input handleEnds.\r\n */\nfunction sliderMove(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n  delta = delta || 0;\n  var extentSpan = extent[1] - extent[0];\n  // Notice maxSpan and minSpan can be null/undefined.\n  if (minSpan != null) {\n    minSpan = restrict(minSpan, [0, extentSpan]);\n  }\n  if (maxSpan != null) {\n    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n  }\n  if (handleIndex === \'all\') {\n    var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n    handleSpan = restrict(handleSpan, [0, extentSpan]);\n    minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);\n    handleIndex = 0;\n  }\n  handleEnds[0] = restrict(handleEnds[0], extent);\n  handleEnds[1] = restrict(handleEnds[1], extent);\n  var originalDistSign = getSpanSign(handleEnds, handleIndex);\n  handleEnds[handleIndex] += delta;\n  // Restrict in extent.\n  var extentMinSpan = minSpan || 0;\n  var realExtent = extent.slice();\n  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);\n  // Expand span.\n  var currDistSign;\n  currDistSign = getSpanSign(handleEnds, handleIndex);\n  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n    // If minSpan exists, \'cross\' is forbidden.\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n  }\n  // Shrink span.\n  currDistSign = getSpanSign(handleEnds, handleIndex);\n  if (maxSpan != null && currDistSign.span > maxSpan) {\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n  }\n  return handleEnds;\n}\nfunction getSpanSign(handleEnds, handleIndex) {\n  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex];\n  // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n  // is at left of handleEnds[1] for non-cross case.\n  return {\n    span: Math.abs(dist),\n    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n  };\n}\nfunction restrict(value, extend) {\n  return Math.min(extend[1] != null ? extend[1] : Infinity, Math.max(extend[0] != null ? extend[0] : -Infinity, value));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg5ODMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvc2xpZGVyTW92ZS5qcz80Njg0Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLyoqXHJcbiAqIENhbGN1bGF0ZSBzbGlkZXIgbW92ZSByZXN1bHQuXHJcbiAqIFVzYWdlOlxyXG4gKiAoMSkgSWYgYm90aCBoYW5kbGUwIGFuZCBoYW5kbGUxIGFyZSBuZWVkZWQgdG8gYmUgbW92ZWQsIHNldCBtaW5TcGFuIHRoZSBzYW1lIGFzXHJcbiAqIG1heFNwYW4gYW5kIHRoZSBzYW1lIGFzIGBNYXRoLmFicyhoYW5kbGVFbmRbMV0gLSBoYW5kbGVFbmRzWzBdKWAuXHJcbiAqICgyKSBJZiBoYW5kbGUwIGlzIGZvcmJpZGRlbiB0byBjcm9zcyBoYW5kbGUxLCBzZXQgbWluU3BhbiBhcyBgMGAuXHJcbiAqXHJcbiAqIEBwYXJhbSBkZWx0YSBNb3ZlIGxlbmd0aC5cclxuICogQHBhcmFtIGhhbmRsZUVuZHMgaGFuZGxlRW5kc1swXSBjYW4gYmUgYmlnZ2VyIHRoZW4gaGFuZGxlRW5kc1sxXS5cclxuICogICAgICAgICAgICAgIGhhbmRsZUVuZHMgd2lsbCBiZSBtb2RpZmllZCBpbiB0aGlzIG1ldGhvZC5cclxuICogQHBhcmFtIGV4dGVudCBoYW5kbGVFbmRzIGlzIHJlc3RyaWN0ZWQgYnkgZXh0ZW50LlxyXG4gKiAgICAgICAgICAgICAgZXh0ZW50WzBdIHNob3VsZCBsZXNzIG9yIGVxdWFscyB0aGFuIGV4dGVudFsxXS5cclxuICogQHBhcmFtIGhhbmRsZUluZGV4IENhbiBiZSAnYWxsJywgbWVhbnMgdGhhdCBib3RoIG1vdmUgdGhlIHR3byBoYW5kbGVFbmRzLlxyXG4gKiBAcGFyYW0gbWluU3BhbiBUaGUgcmFuZ2Ugb2YgZGF0YVpvb20gY2FuIG5vdCBiZSBzbWFsbGVyIHRoYW4gdGhhdC5cclxuICogICAgICAgICAgICAgIElmIG5vdCBzZXQsIGhhbmRsZTAgYW5kIGNyb3NzIGhhbmRsZTEuIElmIHNldCBhcyBhIG5vbi1uZWdhdGl2ZVxyXG4gKiAgICAgICAgICAgICAgbnVtYmVyIChpbmNsdWRpbmcgYDBgKSwgaGFuZGxlcyB3aWxsIHB1c2ggZWFjaCBvdGhlciB3aGVuIHJlYWNoaW5nXHJcbiAqICAgICAgICAgICAgICB0aGUgbWluU3Bhbi5cclxuICogQHBhcmFtIG1heFNwYW4gVGhlIHJhbmdlIG9mIGRhdGFab29tIGNhbiBub3QgYmUgbGFyZ2VyIHRoYW4gdGhhdC5cclxuICogQHJldHVybiBUaGUgaW5wdXQgaGFuZGxlRW5kcy5cclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzbGlkZXJNb3ZlKGRlbHRhLCBoYW5kbGVFbmRzLCBleHRlbnQsIGhhbmRsZUluZGV4LCBtaW5TcGFuLCBtYXhTcGFuKSB7XG4gIGRlbHRhID0gZGVsdGEgfHwgMDtcbiAgdmFyIGV4dGVudFNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gIC8vIE5vdGljZSBtYXhTcGFuIGFuZCBtaW5TcGFuIGNhbiBiZSBudWxsL3VuZGVmaW5lZC5cbiAgaWYgKG1pblNwYW4gIT0gbnVsbCkge1xuICAgIG1pblNwYW4gPSByZXN0cmljdChtaW5TcGFuLCBbMCwgZXh0ZW50U3Bhbl0pO1xuICB9XG4gIGlmIChtYXhTcGFuICE9IG51bGwpIHtcbiAgICBtYXhTcGFuID0gTWF0aC5tYXgobWF4U3BhbiwgbWluU3BhbiAhPSBudWxsID8gbWluU3BhbiA6IDApO1xuICB9XG4gIGlmIChoYW5kbGVJbmRleCA9PT0gJ2FsbCcpIHtcbiAgICB2YXIgaGFuZGxlU3BhbiA9IE1hdGguYWJzKGhhbmRsZUVuZHNbMV0gLSBoYW5kbGVFbmRzWzBdKTtcbiAgICBoYW5kbGVTcGFuID0gcmVzdHJpY3QoaGFuZGxlU3BhbiwgWzAsIGV4dGVudFNwYW5dKTtcbiAgICBtaW5TcGFuID0gbWF4U3BhbiA9IHJlc3RyaWN0KGhhbmRsZVNwYW4sIFttaW5TcGFuLCBtYXhTcGFuXSk7XG4gICAgaGFuZGxlSW5kZXggPSAwO1xuICB9XG4gIGhhbmRsZUVuZHNbMF0gPSByZXN0cmljdChoYW5kbGVFbmRzWzBdLCBleHRlbnQpO1xuICBoYW5kbGVFbmRzWzFdID0gcmVzdHJpY3QoaGFuZGxlRW5kc1sxXSwgZXh0ZW50KTtcbiAgdmFyIG9yaWdpbmFsRGlzdFNpZ24gPSBnZXRTcGFuU2lnbihoYW5kbGVFbmRzLCBoYW5kbGVJbmRleCk7XG4gIGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICs9IGRlbHRhO1xuICAvLyBSZXN0cmljdCBpbiBleHRlbnQuXG4gIHZhciBleHRlbnRNaW5TcGFuID0gbWluU3BhbiB8fCAwO1xuICB2YXIgcmVhbEV4dGVudCA9IGV4dGVudC5zbGljZSgpO1xuICBvcmlnaW5hbERpc3RTaWduLnNpZ24gPCAwID8gcmVhbEV4dGVudFswXSArPSBleHRlbnRNaW5TcGFuIDogcmVhbEV4dGVudFsxXSAtPSBleHRlbnRNaW5TcGFuO1xuICBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XSA9IHJlc3RyaWN0KGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdLCByZWFsRXh0ZW50KTtcbiAgLy8gRXhwYW5kIHNwYW4uXG4gIHZhciBjdXJyRGlzdFNpZ247XG4gIGN1cnJEaXN0U2lnbiA9IGdldFNwYW5TaWduKGhhbmRsZUVuZHMsIGhhbmRsZUluZGV4KTtcbiAgaWYgKG1pblNwYW4gIT0gbnVsbCAmJiAoY3VyckRpc3RTaWduLnNpZ24gIT09IG9yaWdpbmFsRGlzdFNpZ24uc2lnbiB8fCBjdXJyRGlzdFNpZ24uc3BhbiA8IG1pblNwYW4pKSB7XG4gICAgLy8gSWYgbWluU3BhbiBleGlzdHMsICdjcm9zcycgaXMgZm9yYmlkZGVuLlxuICAgIGhhbmRsZUVuZHNbMSAtIGhhbmRsZUluZGV4XSA9IGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICsgb3JpZ2luYWxEaXN0U2lnbi5zaWduICogbWluU3BhbjtcbiAgfVxuICAvLyBTaHJpbmsgc3Bhbi5cbiAgY3VyckRpc3RTaWduID0gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpO1xuICBpZiAobWF4U3BhbiAhPSBudWxsICYmIGN1cnJEaXN0U2lnbi5zcGFuID4gbWF4U3Bhbikge1xuICAgIGhhbmRsZUVuZHNbMSAtIGhhbmRsZUluZGV4XSA9IGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICsgY3VyckRpc3RTaWduLnNpZ24gKiBtYXhTcGFuO1xuICB9XG4gIHJldHVybiBoYW5kbGVFbmRzO1xufVxuZnVuY3Rpb24gZ2V0U3BhblNpZ24oaGFuZGxlRW5kcywgaGFuZGxlSW5kZXgpIHtcbiAgdmFyIGRpc3QgPSBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XSAtIGhhbmRsZUVuZHNbMSAtIGhhbmRsZUluZGV4XTtcbiAgLy8gSWYgYGhhbmRsZUVuZHNbMF0gPT09IGhhbmRsZUVuZHNbMV1gLCBhbHdheXMgYmVsaWV2ZSB0aGF0IGhhbmRsZUVuZFswXVxuICAvLyBpcyBhdCBsZWZ0IG9mIGhhbmRsZUVuZHNbMV0gZm9yIG5vbi1jcm9zcyBjYXNlLlxuICByZXR1cm4ge1xuICAgIHNwYW46IE1hdGguYWJzKGRpc3QpLFxuICAgIHNpZ246IGRpc3QgPiAwID8gLTEgOiBkaXN0IDwgMCA/IDEgOiBoYW5kbGVJbmRleCA/IC0xIDogMVxuICB9O1xufVxuZnVuY3Rpb24gcmVzdHJpY3QodmFsdWUsIGV4dGVuZCkge1xuICByZXR1cm4gTWF0aC5taW4oZXh0ZW5kWzFdICE9IG51bGwgPyBleHRlbmRbMV0gOiBJbmZpbml0eSwgTWF0aC5tYXgoZXh0ZW5kWzBdICE9IG51bGwgPyBleHRlbmRbMF0gOiAtSW5maW5pdHksIHZhbHVlKSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///98983\n')}}]);