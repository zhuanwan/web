"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[3072],{1727:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24326);\n/* harmony import */ var _axisTickLabelBuilder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8287);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar NORMALIZED_EXTENT = [0, 1];\n/**\r\n * Base class of Axis.\r\n */\nvar Axis = /** @class */function () {\n  function Axis(dim, scale, extent) {\n    this.onBand = false;\n    this.inverse = false;\n    this.dim = dim;\n    this.scale = scale;\n    this._extent = extent || [0, 0];\n  }\n  /**\r\n   * If axis extent contain given coord\r\n   */\n  Axis.prototype.contain = function (coord) {\n    var extent = this._extent;\n    var min = Math.min(extent[0], extent[1]);\n    var max = Math.max(extent[0], extent[1]);\n    return coord >= min && coord <= max;\n  };\n  /**\r\n   * If axis extent contain given data\r\n   */\n  Axis.prototype.containData = function (data) {\n    return this.scale.contain(data);\n  };\n  /**\r\n   * Get coord extent.\r\n   */\n  Axis.prototype.getExtent = function () {\n    return this._extent.slice();\n  };\n  /**\r\n   * Get precision used for formatting\r\n   */\n  Axis.prototype.getPixelPrecision = function (dataExtent) {\n    return (0,_util_number_js__WEBPACK_IMPORTED_MODULE_0__/* .getPixelPrecision */ .hb)(dataExtent || this.scale.getExtent(), this._extent);\n  };\n  /**\r\n   * Set coord extent\r\n   */\n  Axis.prototype.setExtent = function (start, end) {\n    var extent = this._extent;\n    extent[0] = start;\n    extent[1] = end;\n  };\n  /**\r\n   * Convert data to coord. Data is the rank if it has an ordinal scale\r\n   */\n  Axis.prototype.dataToCoord = function (data, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n    data = scale.normalize(data);\n    if (this.onBand && scale.type === 'ordinal') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n    return (0,_util_number_js__WEBPACK_IMPORTED_MODULE_0__/* .linearMap */ .Cb)(data, NORMALIZED_EXTENT, extent, clamp);\n  };\n  /**\r\n   * Convert coord to data. Data is the rank if it has an ordinal scale\r\n   */\n  Axis.prototype.coordToData = function (coord, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n    if (this.onBand && scale.type === 'ordinal') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n    var t = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_0__/* .linearMap */ .Cb)(coord, extent, NORMALIZED_EXTENT, clamp);\n    return this.scale.scale(t);\n  };\n  /**\r\n   * Convert pixel point to data in axis\r\n   */\n  Axis.prototype.pointToData = function (point, clamp) {\n    // Should be implemented in derived class if necessary.\n    return;\n  };\n  /**\r\n   * Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,\r\n   * `axis.getTicksCoords` considers `onBand`, which is used by\r\n   * `boundaryGap:true` of category axis and splitLine and splitArea.\r\n   * @param opt.tickModel default: axis.model.getModel('axisTick')\r\n   * @param opt.clamp If `true`, the first and the last\r\n   *        tick must be at the axis end points. Otherwise, clip ticks\r\n   *        that outside the axis extent.\r\n   */\n  Axis.prototype.getTicksCoords = function (opt) {\n    opt = opt || {};\n    var tickModel = opt.tickModel || this.getTickModel();\n    var result = (0,_axisTickLabelBuilder_js__WEBPACK_IMPORTED_MODULE_1__/* .createAxisTicks */ .MI)(this, tickModel);\n    var ticks = result.ticks;\n    var ticksCoords = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(ticks, function (tickVal) {\n      return {\n        coord: this.dataToCoord(this.scale.type === 'ordinal' ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),\n        tickValue: tickVal\n      };\n    }, this);\n    var alignWithLabel = tickModel.get('alignWithLabel');\n    fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);\n    return ticksCoords;\n  };\n  Axis.prototype.getMinorTicksCoords = function () {\n    if (this.scale.type === 'ordinal') {\n      // Category axis doesn't support minor ticks\n      return [];\n    }\n    var minorTickModel = this.model.getModel('minorTick');\n    var splitNumber = minorTickModel.get('splitNumber');\n    // Protection.\n    if (!(splitNumber > 0 && splitNumber < 100)) {\n      splitNumber = 5;\n    }\n    var minorTicks = this.scale.getMinorTicks(splitNumber);\n    var minorTicksCoords = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(minorTicks, function (minorTicksGroup) {\n      return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(minorTicksGroup, function (minorTick) {\n        return {\n          coord: this.dataToCoord(minorTick),\n          tickValue: minorTick\n        };\n      }, this);\n    }, this);\n    return minorTicksCoords;\n  };\n  Axis.prototype.getViewLabels = function () {\n    return (0,_axisTickLabelBuilder_js__WEBPACK_IMPORTED_MODULE_1__/* .createAxisLabels */ .vI)(this).labels;\n  };\n  Axis.prototype.getLabelModel = function () {\n    return this.model.getModel('axisLabel');\n  };\n  /**\r\n   * Notice here we only get the default tick model. For splitLine\r\n   * or splitArea, we should pass the splitLineModel or splitAreaModel\r\n   * manually when calling `getTicksCoords`.\r\n   * In GL, this method may be overridden to:\r\n   * `axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));`\r\n   */\n  Axis.prototype.getTickModel = function () {\n    return this.model.getModel('axisTick');\n  };\n  /**\r\n   * Get width of band\r\n   */\n  Axis.prototype.getBandWidth = function () {\n    var axisExtent = this._extent;\n    var dataExtent = this.scale.getExtent();\n    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n    // Fix #2728, avoid NaN when only one data.\n    len === 0 && (len = 1);\n    var size = Math.abs(axisExtent[1] - axisExtent[0]);\n    return Math.abs(size) / len;\n  };\n  /**\r\n   * Only be called in category axis.\r\n   * Can be overridden, consider other axes like in 3D.\r\n   * @return Auto interval for cateogry axis tick and label\r\n   */\n  Axis.prototype.calculateCategoryInterval = function () {\n    return (0,_axisTickLabelBuilder_js__WEBPACK_IMPORTED_MODULE_1__/* .calculateCategoryInterval */ .EO)(this);\n  };\n  return Axis;\n}();\nfunction fixExtentWithBands(extent, nTick) {\n  var size = extent[1] - extent[0];\n  var len = nTick;\n  var margin = size / len / 2;\n  extent[0] += margin;\n  extent[1] -= margin;\n}\n// If axis has labels [1, 2, 3, 4]. Bands on the axis are\n// |---1---|---2---|---3---|---4---|.\n// So the displayed ticks and splitLine/splitArea should between\n// each data item, otherwise cause misleading (e.g., split tow bars\n// of a single data item when there are two bar series).\n// Also consider if tickCategoryInterval > 0 and onBand, ticks and\n// splitLine/spliteArea should layout appropriately corresponding\n// to displayed labels. (So we should not use `getBandWidth` in this\n// case).\nfunction fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp) {\n  var ticksLen = ticksCoords.length;\n  if (!axis.onBand || alignWithLabel || !ticksLen) {\n    return;\n  }\n  var axisExtent = axis.getExtent();\n  var last;\n  var diffSize;\n  if (ticksLen === 1) {\n    ticksCoords[0].coord = axisExtent[0];\n    last = ticksCoords[1] = {\n      coord: axisExtent[1],\n      tickValue: ticksCoords[0].tickValue\n    };\n  } else {\n    var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;\n    var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(ticksCoords, function (ticksItem) {\n      ticksItem.coord -= shift_1 / 2;\n    });\n    var dataExtent = axis.scale.getExtent();\n    diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;\n    last = {\n      coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize,\n      tickValue: dataExtent[1] + 1\n    };\n    ticksCoords.push(last);\n  }\n  var inverse = axisExtent[0] > axisExtent[1];\n  // Handling clamp.\n  if (littleThan(ticksCoords[0].coord, axisExtent[0])) {\n    clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();\n  }\n  if (clamp && littleThan(axisExtent[0], ticksCoords[0].coord)) {\n    ticksCoords.unshift({\n      coord: axisExtent[0]\n    });\n  }\n  if (littleThan(axisExtent[1], last.coord)) {\n    clamp ? last.coord = axisExtent[1] : ticksCoords.pop();\n  }\n  if (clamp && littleThan(last.coord, axisExtent[1])) {\n    ticksCoords.push({\n      coord: axisExtent[1]\n    });\n  }\n  function littleThan(a, b) {\n    // Avoid rounding error cause calculated tick coord different with extent.\n    // It may cause an extra unnecessary tick added.\n    a = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_0__/* .round */ .LI)(a);\n    b = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_0__/* .round */ .LI)(b);\n    return inverse ? a > b : a < b;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Axis);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcyNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL0F4aXMuanM/NjI0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGVhY2gsIG1hcCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBsaW5lYXJNYXAsIGdldFBpeGVsUHJlY2lzaW9uLCByb3VuZCB9IGZyb20gJy4uL3V0aWwvbnVtYmVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZUF4aXNUaWNrcywgY3JlYXRlQXhpc0xhYmVscywgY2FsY3VsYXRlQ2F0ZWdvcnlJbnRlcnZhbCB9IGZyb20gJy4vYXhpc1RpY2tMYWJlbEJ1aWxkZXIuanMnO1xudmFyIE5PUk1BTElaRURfRVhURU5UID0gWzAsIDFdO1xuLyoqXHJcbiAqIEJhc2UgY2xhc3Mgb2YgQXhpcy5cclxuICovXG52YXIgQXhpcyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF4aXMoZGltLCBzY2FsZSwgZXh0ZW50KSB7XG4gICAgdGhpcy5vbkJhbmQgPSBmYWxzZTtcbiAgICB0aGlzLmludmVyc2UgPSBmYWxzZTtcbiAgICB0aGlzLmRpbSA9IGRpbTtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5fZXh0ZW50ID0gZXh0ZW50IHx8IFswLCAwXTtcbiAgfVxuICAvKipcclxuICAgKiBJZiBheGlzIGV4dGVudCBjb250YWluIGdpdmVuIGNvb3JkXHJcbiAgICovXG4gIEF4aXMucHJvdG90eXBlLmNvbnRhaW4gPSBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICByZXR1cm4gY29vcmQgPj0gbWluICYmIGNvb3JkIDw9IG1heDtcbiAgfTtcbiAgLyoqXHJcbiAgICogSWYgYXhpcyBleHRlbnQgY29udGFpbiBnaXZlbiBkYXRhXHJcbiAgICovXG4gIEF4aXMucHJvdG90eXBlLmNvbnRhaW5EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZS5jb250YWluKGRhdGEpO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgY29vcmQgZXh0ZW50LlxyXG4gICAqL1xuICBBeGlzLnByb3RvdHlwZS5nZXRFeHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dGVudC5zbGljZSgpO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgcHJlY2lzaW9uIHVzZWQgZm9yIGZvcm1hdHRpbmdcclxuICAgKi9cbiAgQXhpcy5wcm90b3R5cGUuZ2V0UGl4ZWxQcmVjaXNpb24gPSBmdW5jdGlvbiAoZGF0YUV4dGVudCkge1xuICAgIHJldHVybiBnZXRQaXhlbFByZWNpc2lvbihkYXRhRXh0ZW50IHx8IHRoaXMuc2NhbGUuZ2V0RXh0ZW50KCksIHRoaXMuX2V4dGVudCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFNldCBjb29yZCBleHRlbnRcclxuICAgKi9cbiAgQXhpcy5wcm90b3R5cGUuc2V0RXh0ZW50ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIGV4dGVudFswXSA9IHN0YXJ0O1xuICAgIGV4dGVudFsxXSA9IGVuZDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ29udmVydCBkYXRhIHRvIGNvb3JkLiBEYXRhIGlzIHRoZSByYW5rIGlmIGl0IGhhcyBhbiBvcmRpbmFsIHNjYWxlXHJcbiAgICovXG4gIEF4aXMucHJvdG90eXBlLmRhdGFUb0Nvb3JkID0gZnVuY3Rpb24gKGRhdGEsIGNsYW1wKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgIGRhdGEgPSBzY2FsZS5ub3JtYWxpemUoZGF0YSk7XG4gICAgaWYgKHRoaXMub25CYW5kICYmIHNjYWxlLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgZXh0ZW50ID0gZXh0ZW50LnNsaWNlKCk7XG4gICAgICBmaXhFeHRlbnRXaXRoQmFuZHMoZXh0ZW50LCBzY2FsZS5jb3VudCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVhck1hcChkYXRhLCBOT1JNQUxJWkVEX0VYVEVOVCwgZXh0ZW50LCBjbGFtcCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENvbnZlcnQgY29vcmQgdG8gZGF0YS4gRGF0YSBpcyB0aGUgcmFuayBpZiBpdCBoYXMgYW4gb3JkaW5hbCBzY2FsZVxyXG4gICAqL1xuICBBeGlzLnByb3RvdHlwZS5jb29yZFRvRGF0YSA9IGZ1bmN0aW9uIChjb29yZCwgY2xhbXApIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgaWYgKHRoaXMub25CYW5kICYmIHNjYWxlLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgZXh0ZW50ID0gZXh0ZW50LnNsaWNlKCk7XG4gICAgICBmaXhFeHRlbnRXaXRoQmFuZHMoZXh0ZW50LCBzY2FsZS5jb3VudCgpKTtcbiAgICB9XG4gICAgdmFyIHQgPSBsaW5lYXJNYXAoY29vcmQsIGV4dGVudCwgTk9STUFMSVpFRF9FWFRFTlQsIGNsYW1wKTtcbiAgICByZXR1cm4gdGhpcy5zY2FsZS5zY2FsZSh0KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ29udmVydCBwaXhlbCBwb2ludCB0byBkYXRhIGluIGF4aXNcclxuICAgKi9cbiAgQXhpcy5wcm90b3R5cGUucG9pbnRUb0RhdGEgPSBmdW5jdGlvbiAocG9pbnQsIGNsYW1wKSB7XG4gICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIGRlcml2ZWQgY2xhc3MgaWYgbmVjZXNzYXJ5LlxuICAgIHJldHVybjtcbiAgfTtcbiAgLyoqXHJcbiAgICogRGlmZmVyZW50IGZyb20gYHpyVXRpbC5tYXAoYXhpcy5nZXRUaWNrcygpLCBheGlzLmRhdGFUb0Nvb3JkLCBheGlzKWAsXHJcbiAgICogYGF4aXMuZ2V0VGlja3NDb29yZHNgIGNvbnNpZGVycyBgb25CYW5kYCwgd2hpY2ggaXMgdXNlZCBieVxyXG4gICAqIGBib3VuZGFyeUdhcDp0cnVlYCBvZiBjYXRlZ29yeSBheGlzIGFuZCBzcGxpdExpbmUgYW5kIHNwbGl0QXJlYS5cclxuICAgKiBAcGFyYW0gb3B0LnRpY2tNb2RlbCBkZWZhdWx0OiBheGlzLm1vZGVsLmdldE1vZGVsKCdheGlzVGljaycpXHJcbiAgICogQHBhcmFtIG9wdC5jbGFtcCBJZiBgdHJ1ZWAsIHRoZSBmaXJzdCBhbmQgdGhlIGxhc3RcclxuICAgKiAgICAgICAgdGljayBtdXN0IGJlIGF0IHRoZSBheGlzIGVuZCBwb2ludHMuIE90aGVyd2lzZSwgY2xpcCB0aWNrc1xyXG4gICAqICAgICAgICB0aGF0IG91dHNpZGUgdGhlIGF4aXMgZXh0ZW50LlxyXG4gICAqL1xuICBBeGlzLnByb3RvdHlwZS5nZXRUaWNrc0Nvb3JkcyA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgdmFyIHRpY2tNb2RlbCA9IG9wdC50aWNrTW9kZWwgfHwgdGhpcy5nZXRUaWNrTW9kZWwoKTtcbiAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQXhpc1RpY2tzKHRoaXMsIHRpY2tNb2RlbCk7XG4gICAgdmFyIHRpY2tzID0gcmVzdWx0LnRpY2tzO1xuICAgIHZhciB0aWNrc0Nvb3JkcyA9IG1hcCh0aWNrcywgZnVuY3Rpb24gKHRpY2tWYWwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvb3JkOiB0aGlzLmRhdGFUb0Nvb3JkKHRoaXMuc2NhbGUudHlwZSA9PT0gJ29yZGluYWwnID8gdGhpcy5zY2FsZS5nZXRSYXdPcmRpbmFsTnVtYmVyKHRpY2tWYWwpIDogdGlja1ZhbCksXG4gICAgICAgIHRpY2tWYWx1ZTogdGlja1ZhbFxuICAgICAgfTtcbiAgICB9LCB0aGlzKTtcbiAgICB2YXIgYWxpZ25XaXRoTGFiZWwgPSB0aWNrTW9kZWwuZ2V0KCdhbGlnbldpdGhMYWJlbCcpO1xuICAgIGZpeE9uQmFuZFRpY2tzQ29vcmRzKHRoaXMsIHRpY2tzQ29vcmRzLCBhbGlnbldpdGhMYWJlbCwgb3B0LmNsYW1wKTtcbiAgICByZXR1cm4gdGlja3NDb29yZHM7XG4gIH07XG4gIEF4aXMucHJvdG90eXBlLmdldE1pbm9yVGlja3NDb29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc2NhbGUudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAvLyBDYXRlZ29yeSBheGlzIGRvZXNuJ3Qgc3VwcG9ydCBtaW5vciB0aWNrc1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgbWlub3JUaWNrTW9kZWwgPSB0aGlzLm1vZGVsLmdldE1vZGVsKCdtaW5vclRpY2snKTtcbiAgICB2YXIgc3BsaXROdW1iZXIgPSBtaW5vclRpY2tNb2RlbC5nZXQoJ3NwbGl0TnVtYmVyJyk7XG4gICAgLy8gUHJvdGVjdGlvbi5cbiAgICBpZiAoIShzcGxpdE51bWJlciA+IDAgJiYgc3BsaXROdW1iZXIgPCAxMDApKSB7XG4gICAgICBzcGxpdE51bWJlciA9IDU7XG4gICAgfVxuICAgIHZhciBtaW5vclRpY2tzID0gdGhpcy5zY2FsZS5nZXRNaW5vclRpY2tzKHNwbGl0TnVtYmVyKTtcbiAgICB2YXIgbWlub3JUaWNrc0Nvb3JkcyA9IG1hcChtaW5vclRpY2tzLCBmdW5jdGlvbiAobWlub3JUaWNrc0dyb3VwKSB7XG4gICAgICByZXR1cm4gbWFwKG1pbm9yVGlja3NHcm91cCwgZnVuY3Rpb24gKG1pbm9yVGljaykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvb3JkOiB0aGlzLmRhdGFUb0Nvb3JkKG1pbm9yVGljayksXG4gICAgICAgICAgdGlja1ZhbHVlOiBtaW5vclRpY2tcbiAgICAgICAgfTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBtaW5vclRpY2tzQ29vcmRzO1xuICB9O1xuICBBeGlzLnByb3RvdHlwZS5nZXRWaWV3TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVBeGlzTGFiZWxzKHRoaXMpLmxhYmVscztcbiAgfTtcbiAgQXhpcy5wcm90b3R5cGUuZ2V0TGFiZWxNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXRNb2RlbCgnYXhpc0xhYmVsJyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIE5vdGljZSBoZXJlIHdlIG9ubHkgZ2V0IHRoZSBkZWZhdWx0IHRpY2sgbW9kZWwuIEZvciBzcGxpdExpbmVcclxuICAgKiBvciBzcGxpdEFyZWEsIHdlIHNob3VsZCBwYXNzIHRoZSBzcGxpdExpbmVNb2RlbCBvciBzcGxpdEFyZWFNb2RlbFxyXG4gICAqIG1hbnVhbGx5IHdoZW4gY2FsbGluZyBgZ2V0VGlja3NDb29yZHNgLlxyXG4gICAqIEluIEdMLCB0aGlzIG1ldGhvZCBtYXkgYmUgb3ZlcnJpZGRlbiB0bzpcclxuICAgKiBgYXhpc01vZGVsLmdldE1vZGVsKCdheGlzVGljaycsIGdyaWQzRE1vZGVsLmdldE1vZGVsKCdheGlzVGljaycpKTtgXHJcbiAgICovXG4gIEF4aXMucHJvdG90eXBlLmdldFRpY2tNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXRNb2RlbCgnYXhpc1RpY2snKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IHdpZHRoIG9mIGJhbmRcclxuICAgKi9cbiAgQXhpcy5wcm90b3R5cGUuZ2V0QmFuZFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBheGlzRXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBkYXRhRXh0ZW50ID0gdGhpcy5zY2FsZS5nZXRFeHRlbnQoKTtcbiAgICB2YXIgbGVuID0gZGF0YUV4dGVudFsxXSAtIGRhdGFFeHRlbnRbMF0gKyAodGhpcy5vbkJhbmQgPyAxIDogMCk7XG4gICAgLy8gRml4ICMyNzI4LCBhdm9pZCBOYU4gd2hlbiBvbmx5IG9uZSBkYXRhLlxuICAgIGxlbiA9PT0gMCAmJiAobGVuID0gMSk7XG4gICAgdmFyIHNpemUgPSBNYXRoLmFicyhheGlzRXh0ZW50WzFdIC0gYXhpc0V4dGVudFswXSk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHNpemUpIC8gbGVuO1xuICB9O1xuICAvKipcclxuICAgKiBPbmx5IGJlIGNhbGxlZCBpbiBjYXRlZ29yeSBheGlzLlxyXG4gICAqIENhbiBiZSBvdmVycmlkZGVuLCBjb25zaWRlciBvdGhlciBheGVzIGxpa2UgaW4gM0QuXHJcbiAgICogQHJldHVybiBBdXRvIGludGVydmFsIGZvciBjYXRlb2dyeSBheGlzIHRpY2sgYW5kIGxhYmVsXHJcbiAgICovXG4gIEF4aXMucHJvdG90eXBlLmNhbGN1bGF0ZUNhdGVnb3J5SW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZUNhdGVnb3J5SW50ZXJ2YWwodGhpcyk7XG4gIH07XG4gIHJldHVybiBBeGlzO1xufSgpO1xuZnVuY3Rpb24gZml4RXh0ZW50V2l0aEJhbmRzKGV4dGVudCwgblRpY2spIHtcbiAgdmFyIHNpemUgPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gIHZhciBsZW4gPSBuVGljaztcbiAgdmFyIG1hcmdpbiA9IHNpemUgLyBsZW4gLyAyO1xuICBleHRlbnRbMF0gKz0gbWFyZ2luO1xuICBleHRlbnRbMV0gLT0gbWFyZ2luO1xufVxuLy8gSWYgYXhpcyBoYXMgbGFiZWxzIFsxLCAyLCAzLCA0XS4gQmFuZHMgb24gdGhlIGF4aXMgYXJlXG4vLyB8LS0tMS0tLXwtLS0yLS0tfC0tLTMtLS18LS0tNC0tLXwuXG4vLyBTbyB0aGUgZGlzcGxheWVkIHRpY2tzIGFuZCBzcGxpdExpbmUvc3BsaXRBcmVhIHNob3VsZCBiZXR3ZWVuXG4vLyBlYWNoIGRhdGEgaXRlbSwgb3RoZXJ3aXNlIGNhdXNlIG1pc2xlYWRpbmcgKGUuZy4sIHNwbGl0IHRvdyBiYXJzXG4vLyBvZiBhIHNpbmdsZSBkYXRhIGl0ZW0gd2hlbiB0aGVyZSBhcmUgdHdvIGJhciBzZXJpZXMpLlxuLy8gQWxzbyBjb25zaWRlciBpZiB0aWNrQ2F0ZWdvcnlJbnRlcnZhbCA+IDAgYW5kIG9uQmFuZCwgdGlja3MgYW5kXG4vLyBzcGxpdExpbmUvc3BsaXRlQXJlYSBzaG91bGQgbGF5b3V0IGFwcHJvcHJpYXRlbHkgY29ycmVzcG9uZGluZ1xuLy8gdG8gZGlzcGxheWVkIGxhYmVscy4gKFNvIHdlIHNob3VsZCBub3QgdXNlIGBnZXRCYW5kV2lkdGhgIGluIHRoaXNcbi8vIGNhc2UpLlxuZnVuY3Rpb24gZml4T25CYW5kVGlja3NDb29yZHMoYXhpcywgdGlja3NDb29yZHMsIGFsaWduV2l0aExhYmVsLCBjbGFtcCkge1xuICB2YXIgdGlja3NMZW4gPSB0aWNrc0Nvb3Jkcy5sZW5ndGg7XG4gIGlmICghYXhpcy5vbkJhbmQgfHwgYWxpZ25XaXRoTGFiZWwgfHwgIXRpY2tzTGVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBheGlzRXh0ZW50ID0gYXhpcy5nZXRFeHRlbnQoKTtcbiAgdmFyIGxhc3Q7XG4gIHZhciBkaWZmU2l6ZTtcbiAgaWYgKHRpY2tzTGVuID09PSAxKSB7XG4gICAgdGlja3NDb29yZHNbMF0uY29vcmQgPSBheGlzRXh0ZW50WzBdO1xuICAgIGxhc3QgPSB0aWNrc0Nvb3Jkc1sxXSA9IHtcbiAgICAgIGNvb3JkOiBheGlzRXh0ZW50WzFdLFxuICAgICAgdGlja1ZhbHVlOiB0aWNrc0Nvb3Jkc1swXS50aWNrVmFsdWVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBjcm9zc0xlbiA9IHRpY2tzQ29vcmRzW3RpY2tzTGVuIC0gMV0udGlja1ZhbHVlIC0gdGlja3NDb29yZHNbMF0udGlja1ZhbHVlO1xuICAgIHZhciBzaGlmdF8xID0gKHRpY2tzQ29vcmRzW3RpY2tzTGVuIC0gMV0uY29vcmQgLSB0aWNrc0Nvb3Jkc1swXS5jb29yZCkgLyBjcm9zc0xlbjtcbiAgICBlYWNoKHRpY2tzQ29vcmRzLCBmdW5jdGlvbiAodGlja3NJdGVtKSB7XG4gICAgICB0aWNrc0l0ZW0uY29vcmQgLT0gc2hpZnRfMSAvIDI7XG4gICAgfSk7XG4gICAgdmFyIGRhdGFFeHRlbnQgPSBheGlzLnNjYWxlLmdldEV4dGVudCgpO1xuICAgIGRpZmZTaXplID0gMSArIGRhdGFFeHRlbnRbMV0gLSB0aWNrc0Nvb3Jkc1t0aWNrc0xlbiAtIDFdLnRpY2tWYWx1ZTtcbiAgICBsYXN0ID0ge1xuICAgICAgY29vcmQ6IHRpY2tzQ29vcmRzW3RpY2tzTGVuIC0gMV0uY29vcmQgKyBzaGlmdF8xICogZGlmZlNpemUsXG4gICAgICB0aWNrVmFsdWU6IGRhdGFFeHRlbnRbMV0gKyAxXG4gICAgfTtcbiAgICB0aWNrc0Nvb3Jkcy5wdXNoKGxhc3QpO1xuICB9XG4gIHZhciBpbnZlcnNlID0gYXhpc0V4dGVudFswXSA+IGF4aXNFeHRlbnRbMV07XG4gIC8vIEhhbmRsaW5nIGNsYW1wLlxuICBpZiAobGl0dGxlVGhhbih0aWNrc0Nvb3Jkc1swXS5jb29yZCwgYXhpc0V4dGVudFswXSkpIHtcbiAgICBjbGFtcCA/IHRpY2tzQ29vcmRzWzBdLmNvb3JkID0gYXhpc0V4dGVudFswXSA6IHRpY2tzQ29vcmRzLnNoaWZ0KCk7XG4gIH1cbiAgaWYgKGNsYW1wICYmIGxpdHRsZVRoYW4oYXhpc0V4dGVudFswXSwgdGlja3NDb29yZHNbMF0uY29vcmQpKSB7XG4gICAgdGlja3NDb29yZHMudW5zaGlmdCh7XG4gICAgICBjb29yZDogYXhpc0V4dGVudFswXVxuICAgIH0pO1xuICB9XG4gIGlmIChsaXR0bGVUaGFuKGF4aXNFeHRlbnRbMV0sIGxhc3QuY29vcmQpKSB7XG4gICAgY2xhbXAgPyBsYXN0LmNvb3JkID0gYXhpc0V4dGVudFsxXSA6IHRpY2tzQ29vcmRzLnBvcCgpO1xuICB9XG4gIGlmIChjbGFtcCAmJiBsaXR0bGVUaGFuKGxhc3QuY29vcmQsIGF4aXNFeHRlbnRbMV0pKSB7XG4gICAgdGlja3NDb29yZHMucHVzaCh7XG4gICAgICBjb29yZDogYXhpc0V4dGVudFsxXVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGxpdHRsZVRoYW4oYSwgYikge1xuICAgIC8vIEF2b2lkIHJvdW5kaW5nIGVycm9yIGNhdXNlIGNhbGN1bGF0ZWQgdGljayBjb29yZCBkaWZmZXJlbnQgd2l0aCBleHRlbnQuXG4gICAgLy8gSXQgbWF5IGNhdXNlIGFuIGV4dHJhIHVubmVjZXNzYXJ5IHRpY2sgYWRkZWQuXG4gICAgYSA9IHJvdW5kKGEpO1xuICAgIGIgPSByb3VuZChiKTtcbiAgICByZXR1cm4gaW52ZXJzZSA/IGEgPiBiIDogYSA8IGI7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEF4aXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1727\n")},41849:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   g: () => (/* binding */ isCoordinateSystemType)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nfunction isCoordinateSystemType(coordSys, type) {\n  return coordSys.type === type;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE4NDkuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvQ29vcmRpbmF0ZVN5c3RlbS5qcz8yYzk1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29vcmRpbmF0ZVN5c3RlbVR5cGUoY29vcmRTeXMsIHR5cGUpIHtcbiAgcmV0dXJuIGNvb3JkU3lzLnR5cGUgPT09IHR5cGU7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///41849\n')},56219:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83509);\n/* harmony import */ var zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45587);\n/* harmony import */ var zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29308);\n/* harmony import */ var zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92836);\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24326);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * Simple view coordinate system\r\n * Mapping given x, y to transformd view x, y\r\n */\n\n\n\n\n\nvar v2ApplyTransform = zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_0__.applyTransform;\nvar View = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .C6)(View, _super);\n  function View(name) {\n    var _this = _super.call(this) || this;\n    _this.type = \'view\';\n    _this.dimensions = [\'x\', \'y\'];\n    /**\r\n     * Represents the transform brought by roam/zoom.\r\n     * If `View[\'_viewRect\']` applies roam transform,\r\n     * we can get the final displayed rect.\r\n     */\n    _this._roamTransformable = new zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay();\n    /**\r\n     * Represents the transform from `View[\'_rect\']` to `View[\'_viewRect\']`.\r\n     */\n    _this._rawTransformable = new zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay();\n    _this.name = name;\n    return _this;\n  }\n  View.prototype.setBoundingRect = function (x, y, width, height) {\n    this._rect = new zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A(x, y, width, height);\n    return this._rect;\n  };\n  /**\r\n   * @return {module:zrender/core/BoundingRect}\r\n   */\n  View.prototype.getBoundingRect = function () {\n    return this._rect;\n  };\n  View.prototype.setViewRect = function (x, y, width, height) {\n    this._transformTo(x, y, width, height);\n    this._viewRect = new zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A(x, y, width, height);\n  };\n  /**\r\n   * Transformed to particular position and size\r\n   */\n  View.prototype._transformTo = function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var rawTransform = this._rawTransformable;\n    rawTransform.transform = rect.calculateTransform(new zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A(x, y, width, height));\n    var rawParent = rawTransform.parent;\n    rawTransform.parent = null;\n    rawTransform.decomposeTransform();\n    rawTransform.parent = rawParent;\n    this._updateTransform();\n  };\n  /**\r\n   * Set center of view\r\n   */\n  View.prototype.setCenter = function (centerCoord, api) {\n    if (!centerCoord) {\n      return;\n    }\n    this._center = [(0,_util_number_js__WEBPACK_IMPORTED_MODULE_4__/* .parsePercent */ .lo)(centerCoord[0], api.getWidth()), (0,_util_number_js__WEBPACK_IMPORTED_MODULE_4__/* .parsePercent */ .lo)(centerCoord[1], api.getHeight())];\n    this._updateCenterAndZoom();\n  };\n  View.prototype.setZoom = function (zoom) {\n    zoom = zoom || 1;\n    var zoomLimit = this.zoomLimit;\n    if (zoomLimit) {\n      if (zoomLimit.max != null) {\n        zoom = Math.min(zoomLimit.max, zoom);\n      }\n      if (zoomLimit.min != null) {\n        zoom = Math.max(zoomLimit.min, zoom);\n      }\n    }\n    this._zoom = zoom;\n    this._updateCenterAndZoom();\n  };\n  /**\r\n   * Get default center without roam\r\n   */\n  View.prototype.getDefaultCenter = function () {\n    // Rect before any transform\n    var rawRect = this.getBoundingRect();\n    var cx = rawRect.x + rawRect.width / 2;\n    var cy = rawRect.y + rawRect.height / 2;\n    return [cx, cy];\n  };\n  View.prototype.getCenter = function () {\n    return this._center || this.getDefaultCenter();\n  };\n  View.prototype.getZoom = function () {\n    return this._zoom || 1;\n  };\n  View.prototype.getRoamTransform = function () {\n    return this._roamTransformable.getLocalTransform();\n  };\n  /**\r\n   * Remove roam\r\n   */\n  View.prototype._updateCenterAndZoom = function () {\n    // Must update after view transform updated\n    var rawTransformMatrix = this._rawTransformable.getLocalTransform();\n    var roamTransform = this._roamTransformable;\n    var defaultCenter = this.getDefaultCenter();\n    var center = this.getCenter();\n    var zoom = this.getZoom();\n    center = zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_0__.applyTransform([], center, rawTransformMatrix);\n    defaultCenter = zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_0__.applyTransform([], defaultCenter, rawTransformMatrix);\n    roamTransform.originX = center[0];\n    roamTransform.originY = center[1];\n    roamTransform.x = defaultCenter[0] - center[0];\n    roamTransform.y = defaultCenter[1] - center[1];\n    roamTransform.scaleX = roamTransform.scaleY = zoom;\n    this._updateTransform();\n  };\n  /**\r\n   * Update transform props on `this` based on the current\r\n   * `this._roamTransformable` and `this._rawTransformable`.\r\n   */\n  View.prototype._updateTransform = function () {\n    var roamTransformable = this._roamTransformable;\n    var rawTransformable = this._rawTransformable;\n    rawTransformable.parent = roamTransformable;\n    roamTransformable.updateTransform();\n    rawTransformable.updateTransform();\n    zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__.copy(this.transform || (this.transform = []), rawTransformable.transform || zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__.create());\n    this._rawTransform = rawTransformable.getLocalTransform();\n    this.invTransform = this.invTransform || [];\n    zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__.invert(this.invTransform, this.transform);\n    this.decomposeTransform();\n  };\n  View.prototype.getTransformInfo = function () {\n    var rawTransformable = this._rawTransformable;\n    var roamTransformable = this._roamTransformable;\n    // Because roamTransformabel has `originX/originY` modified,\n    // but the caller of `getTransformInfo` can not handle `originX/originY`,\n    // so need to recalculate them.\n    var dummyTransformable = new zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay();\n    dummyTransformable.transform = roamTransformable.transform;\n    dummyTransformable.decomposeTransform();\n    return {\n      roam: {\n        x: dummyTransformable.x,\n        y: dummyTransformable.y,\n        scaleX: dummyTransformable.scaleX,\n        scaleY: dummyTransformable.scaleY\n      },\n      raw: {\n        x: rawTransformable.x,\n        y: rawTransformable.y,\n        scaleX: rawTransformable.scaleX,\n        scaleY: rawTransformable.scaleY\n      }\n    };\n  };\n  View.prototype.getViewRect = function () {\n    return this._viewRect;\n  };\n  /**\r\n   * Get view rect after roam transform\r\n   */\n  View.prototype.getViewRectAfterRoam = function () {\n    var rect = this.getBoundingRect().clone();\n    rect.applyTransform(this.transform);\n    return rect;\n  };\n  /**\r\n   * Convert a single (lon, lat) data item to (x, y) point.\r\n   */\n  View.prototype.dataToPoint = function (data, noRoam, out) {\n    var transform = noRoam ? this._rawTransform : this.transform;\n    out = out || [];\n    return transform ? v2ApplyTransform(out, data, transform) : zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_0__.copy(out, data);\n  };\n  /**\r\n   * Convert a (x, y) point to (lon, lat) data\r\n   */\n  View.prototype.pointToData = function (point) {\n    var invTransform = this.invTransform;\n    return invTransform ? v2ApplyTransform([], point, invTransform) : [point[0], point[1]];\n  };\n  View.prototype.convertToPixel = function (ecModel, finder, value) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.dataToPoint(value) : null;\n  };\n  View.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.pointToData(pixel) : null;\n  };\n  /**\r\n   * @implements\r\n   */\n  View.prototype.containPoint = function (point) {\n    return this.getViewRectAfterRoam().contain(point[0], point[1]);\n  };\n  View.dimensions = [\'x\', \'y\'];\n  return View;\n}(zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay);\nfunction getCoordSys(finder) {\n  var seriesModel = finder.seriesModel;\n  return seriesModel ? seriesModel.coordinateSystem : null; // e.g., graph.\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (View);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYyMTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvVmlldy5qcz85OWUzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG4vKipcclxuICogU2ltcGxlIHZpZXcgY29vcmRpbmF0ZSBzeXN0ZW1cclxuICogTWFwcGluZyBnaXZlbiB4LCB5IHRvIHRyYW5zZm9ybWQgdmlldyB4LCB5XHJcbiAqL1xuaW1wb3J0ICogYXMgdmVjdG9yIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzJztcbmltcG9ydCAqIGFzIG1hdHJpeCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qcyc7XG5pbXBvcnQgQm91bmRpbmdSZWN0IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJztcbmltcG9ydCBUcmFuc2Zvcm1hYmxlIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvVHJhbnNmb3JtYWJsZS5qcyc7XG5pbXBvcnQgeyBwYXJzZVBlcmNlbnQgfSBmcm9tICcuLi91dGlsL251bWJlci5qcyc7XG52YXIgdjJBcHBseVRyYW5zZm9ybSA9IHZlY3Rvci5hcHBseVRyYW5zZm9ybTtcbnZhciBWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFZpZXcobmFtZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9ICd2aWV3JztcbiAgICBfdGhpcy5kaW1lbnNpb25zID0gWyd4JywgJ3knXTtcbiAgICAvKipcclxuICAgICAqIFJlcHJlc2VudHMgdGhlIHRyYW5zZm9ybSBicm91Z2h0IGJ5IHJvYW0vem9vbS5cclxuICAgICAqIElmIGBWaWV3Wydfdmlld1JlY3QnXWAgYXBwbGllcyByb2FtIHRyYW5zZm9ybSxcclxuICAgICAqIHdlIGNhbiBnZXQgdGhlIGZpbmFsIGRpc3BsYXllZCByZWN0LlxyXG4gICAgICovXG4gICAgX3RoaXMuX3JvYW1UcmFuc2Zvcm1hYmxlID0gbmV3IFRyYW5zZm9ybWFibGUoKTtcbiAgICAvKipcclxuICAgICAqIFJlcHJlc2VudHMgdGhlIHRyYW5zZm9ybSBmcm9tIGBWaWV3WydfcmVjdCddYCB0byBgVmlld1snX3ZpZXdSZWN0J11gLlxyXG4gICAgICovXG4gICAgX3RoaXMuX3Jhd1RyYW5zZm9ybWFibGUgPSBuZXcgVHJhbnNmb3JtYWJsZSgpO1xuICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBWaWV3LnByb3RvdHlwZS5zZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICB9O1xuICAvKipcclxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cclxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICB9O1xuICBWaWV3LnByb3RvdHlwZS5zZXRWaWV3UmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5fdHJhbnNmb3JtVG8oeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5fdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuICAvKipcclxuICAgKiBUcmFuc2Zvcm1lZCB0byBwYXJ0aWN1bGFyIHBvc2l0aW9uIGFuZCBzaXplXHJcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLl90cmFuc2Zvcm1UbyA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciByYXdUcmFuc2Zvcm0gPSB0aGlzLl9yYXdUcmFuc2Zvcm1hYmxlO1xuICAgIHJhd1RyYW5zZm9ybS50cmFuc2Zvcm0gPSByZWN0LmNhbGN1bGF0ZVRyYW5zZm9ybShuZXcgQm91bmRpbmdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgICB2YXIgcmF3UGFyZW50ID0gcmF3VHJhbnNmb3JtLnBhcmVudDtcbiAgICByYXdUcmFuc2Zvcm0ucGFyZW50ID0gbnVsbDtcbiAgICByYXdUcmFuc2Zvcm0uZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gICAgcmF3VHJhbnNmb3JtLnBhcmVudCA9IHJhd1BhcmVudDtcbiAgICB0aGlzLl91cGRhdGVUcmFuc2Zvcm0oKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU2V0IGNlbnRlciBvZiB2aWV3XHJcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uIChjZW50ZXJDb29yZCwgYXBpKSB7XG4gICAgaWYgKCFjZW50ZXJDb29yZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jZW50ZXIgPSBbcGFyc2VQZXJjZW50KGNlbnRlckNvb3JkWzBdLCBhcGkuZ2V0V2lkdGgoKSksIHBhcnNlUGVyY2VudChjZW50ZXJDb29yZFsxXSwgYXBpLmdldEhlaWdodCgpKV07XG4gICAgdGhpcy5fdXBkYXRlQ2VudGVyQW5kWm9vbSgpO1xuICB9O1xuICBWaWV3LnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24gKHpvb20pIHtcbiAgICB6b29tID0gem9vbSB8fCAxO1xuICAgIHZhciB6b29tTGltaXQgPSB0aGlzLnpvb21MaW1pdDtcbiAgICBpZiAoem9vbUxpbWl0KSB7XG4gICAgICBpZiAoem9vbUxpbWl0Lm1heCAhPSBudWxsKSB7XG4gICAgICAgIHpvb20gPSBNYXRoLm1pbih6b29tTGltaXQubWF4LCB6b29tKTtcbiAgICAgIH1cbiAgICAgIGlmICh6b29tTGltaXQubWluICE9IG51bGwpIHtcbiAgICAgICAgem9vbSA9IE1hdGgubWF4KHpvb21MaW1pdC5taW4sIHpvb20pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl96b29tID0gem9vbTtcbiAgICB0aGlzLl91cGRhdGVDZW50ZXJBbmRab29tKCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCBkZWZhdWx0IGNlbnRlciB3aXRob3V0IHJvYW1cclxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0RGVmYXVsdENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZWN0IGJlZm9yZSBhbnkgdHJhbnNmb3JtXG4gICAgdmFyIHJhd1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBjeCA9IHJhd1JlY3QueCArIHJhd1JlY3Qud2lkdGggLyAyO1xuICAgIHZhciBjeSA9IHJhd1JlY3QueSArIHJhd1JlY3QuaGVpZ2h0IC8gMjtcbiAgICByZXR1cm4gW2N4LCBjeV07XG4gIH07XG4gIFZpZXcucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2VudGVyIHx8IHRoaXMuZ2V0RGVmYXVsdENlbnRlcigpO1xuICB9O1xuICBWaWV3LnByb3RvdHlwZS5nZXRab29tID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl96b29tIHx8IDE7XG4gIH07XG4gIFZpZXcucHJvdG90eXBlLmdldFJvYW1UcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvYW1UcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtKCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbW92ZSByb2FtXHJcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLl91cGRhdGVDZW50ZXJBbmRab29tID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIE11c3QgdXBkYXRlIGFmdGVyIHZpZXcgdHJhbnNmb3JtIHVwZGF0ZWRcbiAgICB2YXIgcmF3VHJhbnNmb3JtTWF0cml4ID0gdGhpcy5fcmF3VHJhbnNmb3JtYWJsZS5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuICAgIHZhciByb2FtVHJhbnNmb3JtID0gdGhpcy5fcm9hbVRyYW5zZm9ybWFibGU7XG4gICAgdmFyIGRlZmF1bHRDZW50ZXIgPSB0aGlzLmdldERlZmF1bHRDZW50ZXIoKTtcbiAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcbiAgICB2YXIgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpO1xuICAgIGNlbnRlciA9IHZlY3Rvci5hcHBseVRyYW5zZm9ybShbXSwgY2VudGVyLCByYXdUcmFuc2Zvcm1NYXRyaXgpO1xuICAgIGRlZmF1bHRDZW50ZXIgPSB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0oW10sIGRlZmF1bHRDZW50ZXIsIHJhd1RyYW5zZm9ybU1hdHJpeCk7XG4gICAgcm9hbVRyYW5zZm9ybS5vcmlnaW5YID0gY2VudGVyWzBdO1xuICAgIHJvYW1UcmFuc2Zvcm0ub3JpZ2luWSA9IGNlbnRlclsxXTtcbiAgICByb2FtVHJhbnNmb3JtLnggPSBkZWZhdWx0Q2VudGVyWzBdIC0gY2VudGVyWzBdO1xuICAgIHJvYW1UcmFuc2Zvcm0ueSA9IGRlZmF1bHRDZW50ZXJbMV0gLSBjZW50ZXJbMV07XG4gICAgcm9hbVRyYW5zZm9ybS5zY2FsZVggPSByb2FtVHJhbnNmb3JtLnNjYWxlWSA9IHpvb207XG4gICAgdGhpcy5fdXBkYXRlVHJhbnNmb3JtKCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0cmFuc2Zvcm0gcHJvcHMgb24gYHRoaXNgIGJhc2VkIG9uIHRoZSBjdXJyZW50XHJcbiAgICogYHRoaXMuX3JvYW1UcmFuc2Zvcm1hYmxlYCBhbmQgYHRoaXMuX3Jhd1RyYW5zZm9ybWFibGVgLlxyXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5fdXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByb2FtVHJhbnNmb3JtYWJsZSA9IHRoaXMuX3JvYW1UcmFuc2Zvcm1hYmxlO1xuICAgIHZhciByYXdUcmFuc2Zvcm1hYmxlID0gdGhpcy5fcmF3VHJhbnNmb3JtYWJsZTtcbiAgICByYXdUcmFuc2Zvcm1hYmxlLnBhcmVudCA9IHJvYW1UcmFuc2Zvcm1hYmxlO1xuICAgIHJvYW1UcmFuc2Zvcm1hYmxlLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIHJhd1RyYW5zZm9ybWFibGUudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgbWF0cml4LmNvcHkodGhpcy50cmFuc2Zvcm0gfHwgKHRoaXMudHJhbnNmb3JtID0gW10pLCByYXdUcmFuc2Zvcm1hYmxlLnRyYW5zZm9ybSB8fCBtYXRyaXguY3JlYXRlKCkpO1xuICAgIHRoaXMuX3Jhd1RyYW5zZm9ybSA9IHJhd1RyYW5zZm9ybWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLmludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtIHx8IFtdO1xuICAgIG1hdHJpeC5pbnZlcnQodGhpcy5pbnZUcmFuc2Zvcm0sIHRoaXMudHJhbnNmb3JtKTtcbiAgICB0aGlzLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICB9O1xuICBWaWV3LnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1JbmZvID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByYXdUcmFuc2Zvcm1hYmxlID0gdGhpcy5fcmF3VHJhbnNmb3JtYWJsZTtcbiAgICB2YXIgcm9hbVRyYW5zZm9ybWFibGUgPSB0aGlzLl9yb2FtVHJhbnNmb3JtYWJsZTtcbiAgICAvLyBCZWNhdXNlIHJvYW1UcmFuc2Zvcm1hYmVsIGhhcyBgb3JpZ2luWC9vcmlnaW5ZYCBtb2RpZmllZCxcbiAgICAvLyBidXQgdGhlIGNhbGxlciBvZiBgZ2V0VHJhbnNmb3JtSW5mb2AgY2FuIG5vdCBoYW5kbGUgYG9yaWdpblgvb3JpZ2luWWAsXG4gICAgLy8gc28gbmVlZCB0byByZWNhbGN1bGF0ZSB0aGVtLlxuICAgIHZhciBkdW1teVRyYW5zZm9ybWFibGUgPSBuZXcgVHJhbnNmb3JtYWJsZSgpO1xuICAgIGR1bW15VHJhbnNmb3JtYWJsZS50cmFuc2Zvcm0gPSByb2FtVHJhbnNmb3JtYWJsZS50cmFuc2Zvcm07XG4gICAgZHVtbXlUcmFuc2Zvcm1hYmxlLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICAgIHJldHVybiB7XG4gICAgICByb2FtOiB7XG4gICAgICAgIHg6IGR1bW15VHJhbnNmb3JtYWJsZS54LFxuICAgICAgICB5OiBkdW1teVRyYW5zZm9ybWFibGUueSxcbiAgICAgICAgc2NhbGVYOiBkdW1teVRyYW5zZm9ybWFibGUuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IGR1bW15VHJhbnNmb3JtYWJsZS5zY2FsZVlcbiAgICAgIH0sXG4gICAgICByYXc6IHtcbiAgICAgICAgeDogcmF3VHJhbnNmb3JtYWJsZS54LFxuICAgICAgICB5OiByYXdUcmFuc2Zvcm1hYmxlLnksXG4gICAgICAgIHNjYWxlWDogcmF3VHJhbnNmb3JtYWJsZS5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogcmF3VHJhbnNmb3JtYWJsZS5zY2FsZVlcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBWaWV3LnByb3RvdHlwZS5nZXRWaWV3UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld1JlY3Q7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCB2aWV3IHJlY3QgYWZ0ZXIgcm9hbSB0cmFuc2Zvcm1cclxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0Vmlld1JlY3RBZnRlclJvYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgcmVjdC5hcHBseVRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH07XG4gIC8qKlxyXG4gICAqIENvbnZlcnQgYSBzaW5nbGUgKGxvbiwgbGF0KSBkYXRhIGl0ZW0gdG8gKHgsIHkpIHBvaW50LlxyXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5kYXRhVG9Qb2ludCA9IGZ1bmN0aW9uIChkYXRhLCBub1JvYW0sIG91dCkge1xuICAgIHZhciB0cmFuc2Zvcm0gPSBub1JvYW0gPyB0aGlzLl9yYXdUcmFuc2Zvcm0gOiB0aGlzLnRyYW5zZm9ybTtcbiAgICBvdXQgPSBvdXQgfHwgW107XG4gICAgcmV0dXJuIHRyYW5zZm9ybSA/IHYyQXBwbHlUcmFuc2Zvcm0ob3V0LCBkYXRhLCB0cmFuc2Zvcm0pIDogdmVjdG9yLmNvcHkob3V0LCBkYXRhKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ29udmVydCBhICh4LCB5KSBwb2ludCB0byAobG9uLCBsYXQpIGRhdGFcclxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUucG9pbnRUb0RhdGEgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm07XG4gICAgcmV0dXJuIGludlRyYW5zZm9ybSA/IHYyQXBwbHlUcmFuc2Zvcm0oW10sIHBvaW50LCBpbnZUcmFuc2Zvcm0pIDogW3BvaW50WzBdLCBwb2ludFsxXV07XG4gIH07XG4gIFZpZXcucHJvdG90eXBlLmNvbnZlcnRUb1BpeGVsID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlciwgdmFsdWUpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBnZXRDb29yZFN5cyhmaW5kZXIpO1xuICAgIHJldHVybiBjb29yZFN5cyA9PT0gdGhpcyA/IGNvb3JkU3lzLmRhdGFUb1BvaW50KHZhbHVlKSA6IG51bGw7XG4gIH07XG4gIFZpZXcucHJvdG90eXBlLmNvbnZlcnRGcm9tUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCBwaXhlbCkge1xuICAgIHZhciBjb29yZFN5cyA9IGdldENvb3JkU3lzKGZpbmRlcik7XG4gICAgcmV0dXJuIGNvb3JkU3lzID09PSB0aGlzID8gY29vcmRTeXMucG9pbnRUb0RhdGEocGl4ZWwpIDogbnVsbDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQGltcGxlbWVudHNcclxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuY29udGFpblBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Vmlld1JlY3RBZnRlclJvYW0oKS5jb250YWluKHBvaW50WzBdLCBwb2ludFsxXSk7XG4gIH07XG4gIFZpZXcuZGltZW5zaW9ucyA9IFsneCcsICd5J107XG4gIHJldHVybiBWaWV3O1xufShUcmFuc2Zvcm1hYmxlKTtcbmZ1bmN0aW9uIGdldENvb3JkU3lzKGZpbmRlcikge1xuICB2YXIgc2VyaWVzTW9kZWwgPSBmaW5kZXIuc2VyaWVzTW9kZWw7XG4gIHJldHVybiBzZXJpZXNNb2RlbCA/IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gOiBudWxsOyAvLyBlLmcuLCBncmFwaC5cbn1cbmV4cG9ydCBkZWZhdWx0IFZpZXc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///56219\n')}}]);