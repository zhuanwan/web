"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[3824],{15787:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ single_singleCreator)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/Axis.js\nvar Axis = __webpack_require__(1727);\n;// ./node_modules/echarts/lib/coord/single/SingleAxis.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar SingleAxis = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(SingleAxis, _super);\n  function SingleAxis(dim, scale, coordExtent, axisType, position) {\n    var _this = _super.call(this, dim, scale, coordExtent) || this;\n    _this.type = axisType || 'value';\n    _this.position = position || 'bottom';\n    return _this;\n  }\n  /**\r\n   * Judge the orient of the axis.\r\n   */\n  SingleAxis.prototype.isHorizontal = function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  };\n  SingleAxis.prototype.pointToData = function (point, clamp) {\n    return this.coordinateSystem.pointToData(point)[0];\n  };\n  return SingleAxis;\n}(Axis/* default */.A);\n/* harmony default export */ const single_SingleAxis = (SingleAxis);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/axisHelper.js\nvar axisHelper = __webpack_require__(99031);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n;// ./node_modules/echarts/lib/coord/single/Single.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * Single coordinates system.\r\n */\n\n\n\n\nvar singleDimensions = ['single'];\n/**\r\n * Create a single coordinates system.\r\n */\nvar Single = /** @class */function () {\n  function Single(axisModel, ecModel, api) {\n    this.type = 'single';\n    this.dimension = 'single';\n    /**\r\n     * Add it just for draw tooltip.\r\n     */\n    this.dimensions = singleDimensions;\n    this.axisPointerEnabled = true;\n    this.model = axisModel;\n    this._init(axisModel, ecModel, api);\n  }\n  /**\r\n   * Initialize single coordinate system.\r\n   */\n  Single.prototype._init = function (axisModel, ecModel, api) {\n    var dim = this.dimension;\n    var axis = new single_SingleAxis(dim, axisHelper/* createScaleByModel */.f$(axisModel), [0, 0], axisModel.get('type'), axisModel.get('position'));\n    var isCategory = axis.type === 'category';\n    axis.onBand = isCategory && axisModel.get('boundaryGap');\n    axis.inverse = axisModel.get('inverse');\n    axis.orient = axisModel.get('orient');\n    axisModel.axis = axis;\n    axis.model = axisModel;\n    axis.coordinateSystem = this;\n    this._axis = axis;\n  };\n  /**\r\n   * Update axis scale after data processed\r\n   */\n  Single.prototype.update = function (ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      if (seriesModel.coordinateSystem === this) {\n        var data_1 = seriesModel.getData();\n        (0,util.each)(data_1.mapDimensionsAll(this.dimension), function (dim) {\n          this._axis.scale.unionExtentFromData(data_1, dim);\n        }, this);\n        axisHelper/* niceScaleExtent */.af(this._axis.scale, this._axis.model);\n      }\n    }, this);\n  };\n  /**\r\n   * Resize the single coordinate system.\r\n   */\n  Single.prototype.resize = function (axisModel, api) {\n    this._rect = (0,layout/* getLayoutRect */.dV)({\n      left: axisModel.get('left'),\n      top: axisModel.get('top'),\n      right: axisModel.get('right'),\n      bottom: axisModel.get('bottom'),\n      width: axisModel.get('width'),\n      height: axisModel.get('height')\n    }, {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    this._adjustAxis();\n  };\n  Single.prototype.getRect = function () {\n    return this._rect;\n  };\n  Single.prototype._adjustAxis = function () {\n    var rect = this._rect;\n    var axis = this._axis;\n    var isHorizontal = axis.isHorizontal();\n    var extent = isHorizontal ? [0, rect.width] : [0, rect.height];\n    var idx = axis.inverse ? 1 : 0;\n    axis.setExtent(extent[idx], extent[1 - idx]);\n    this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y);\n  };\n  Single.prototype._updateAxisTransform = function (axis, coordBase) {\n    var axisExtent = axis.getExtent();\n    var extentSum = axisExtent[0] + axisExtent[1];\n    var isHorizontal = axis.isHorizontal();\n    axis.toGlobalCoord = isHorizontal ? function (coord) {\n      return coord + coordBase;\n    } : function (coord) {\n      return extentSum - coord + coordBase;\n    };\n    axis.toLocalCoord = isHorizontal ? function (coord) {\n      return coord - coordBase;\n    } : function (coord) {\n      return extentSum - coord + coordBase;\n    };\n  };\n  /**\r\n   * Get axis.\r\n   */\n  Single.prototype.getAxis = function () {\n    return this._axis;\n  };\n  /**\r\n   * Get axis, add it just for draw tooltip.\r\n   */\n  Single.prototype.getBaseAxis = function () {\n    return this._axis;\n  };\n  Single.prototype.getAxes = function () {\n    return [this._axis];\n  };\n  Single.prototype.getTooltipAxes = function () {\n    return {\n      baseAxes: [this.getAxis()],\n      // Empty otherAxes\n      otherAxes: []\n    };\n  };\n  /**\r\n   * If contain point.\r\n   */\n  Single.prototype.containPoint = function (point) {\n    var rect = this.getRect();\n    var axis = this.getAxis();\n    var orient = axis.orient;\n    if (orient === 'horizontal') {\n      return axis.contain(axis.toLocalCoord(point[0])) && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n    } else {\n      return axis.contain(axis.toLocalCoord(point[1])) && point[0] >= rect.y && point[0] <= rect.y + rect.height;\n    }\n  };\n  Single.prototype.pointToData = function (point) {\n    var axis = this.getAxis();\n    return [axis.coordToData(axis.toLocalCoord(point[axis.orient === 'horizontal' ? 0 : 1]))];\n  };\n  /**\r\n   * Convert the series data to concrete point.\r\n   * Can be [val] | val\r\n   */\n  Single.prototype.dataToPoint = function (val) {\n    var axis = this.getAxis();\n    var rect = this.getRect();\n    var pt = [];\n    var idx = axis.orient === 'horizontal' ? 0 : 1;\n    if (val instanceof Array) {\n      val = val[0];\n    }\n    pt[idx] = axis.toGlobalCoord(axis.dataToCoord(+val));\n    pt[1 - idx] = idx === 0 ? rect.y + rect.height / 2 : rect.x + rect.width / 2;\n    return pt;\n  };\n  Single.prototype.convertToPixel = function (ecModel, finder, value) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? this.dataToPoint(value) : null;\n  };\n  Single.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? this.pointToData(pixel) : null;\n  };\n  return Single;\n}();\nfunction getCoordSys(finder) {\n  var seriesModel = finder.seriesModel;\n  var singleModel = finder.singleAxisModel;\n  return singleModel && singleModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;\n}\n/* harmony default export */ const single_Single = (Single);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n;// ./node_modules/echarts/lib/coord/single/singleCreator.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * Single coordinate system creator.\r\n */\n\n\n/**\r\n * Create single coordinate system and inject it into seriesModel.\r\n */\nfunction create(ecModel, api) {\n  var singles = [];\n  ecModel.eachComponent('singleAxis', function (axisModel, idx) {\n    var single = new single_Single(axisModel, ecModel, api);\n    single.name = 'single_' + idx;\n    single.resize(axisModel, api);\n    axisModel.coordinateSystem = single;\n    singles.push(single);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (seriesModel.get('coordinateSystem') === 'singleAxis') {\n      var singleAxisModel = seriesModel.getReferringComponents('singleAxis', model/* SINGLE_REFERRING */.US).models[0];\n      seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem;\n    }\n  });\n  return singles;\n}\nvar singleCreator = {\n  create: create,\n  dimensions: singleDimensions\n};\n/* harmony default export */ const single_singleCreator = (singleCreator);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU3ODcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9zaW5nbGUvU2luZ2xlQXhpcy5qcz8wMjA4Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9zaW5nbGUvU2luZ2xlLmpzPzM2OTgiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL3NpbmdsZS9zaW5nbGVDcmVhdG9yLmpzP2ZjZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBBeGlzIGZyb20gJy4uL0F4aXMuanMnO1xudmFyIFNpbmdsZUF4aXMgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2luZ2xlQXhpcywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gU2luZ2xlQXhpcyhkaW0sIHNjYWxlLCBjb29yZEV4dGVudCwgYXhpc1R5cGUsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGltLCBzY2FsZSwgY29vcmRFeHRlbnQpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IGF4aXNUeXBlIHx8ICd2YWx1ZSc7XG4gICAgX3RoaXMucG9zaXRpb24gPSBwb3NpdGlvbiB8fCAnYm90dG9tJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogSnVkZ2UgdGhlIG9yaWVudCBvZiB0aGUgYXhpcy5cclxuICAgKi9cbiAgU2luZ2xlQXhpcy5wcm90b3R5cGUuaXNIb3Jpem9udGFsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gIH07XG4gIFNpbmdsZUF4aXMucHJvdG90eXBlLnBvaW50VG9EYXRhID0gZnVuY3Rpb24gKHBvaW50LCBjbGFtcCkge1xuICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVTeXN0ZW0ucG9pbnRUb0RhdGEocG9pbnQpWzBdO1xuICB9O1xuICByZXR1cm4gU2luZ2xlQXhpcztcbn0oQXhpcyk7XG5leHBvcnQgZGVmYXVsdCBTaW5nbGVBeGlzOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLyoqXHJcbiAqIFNpbmdsZSBjb29yZGluYXRlcyBzeXN0ZW0uXHJcbiAqL1xuaW1wb3J0IFNpbmdsZUF4aXMgZnJvbSAnLi9TaW5nbGVBeGlzLmpzJztcbmltcG9ydCAqIGFzIGF4aXNIZWxwZXIgZnJvbSAnLi4vYXhpc0hlbHBlci5qcyc7XG5pbXBvcnQgeyBnZXRMYXlvdXRSZWN0IH0gZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQuanMnO1xuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5leHBvcnQgdmFyIHNpbmdsZURpbWVuc2lvbnMgPSBbJ3NpbmdsZSddO1xuLyoqXHJcbiAqIENyZWF0ZSBhIHNpbmdsZSBjb29yZGluYXRlcyBzeXN0ZW0uXHJcbiAqL1xudmFyIFNpbmdsZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNpbmdsZShheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMudHlwZSA9ICdzaW5nbGUnO1xuICAgIHRoaXMuZGltZW5zaW9uID0gJ3NpbmdsZSc7XG4gICAgLyoqXHJcbiAgICAgKiBBZGQgaXQganVzdCBmb3IgZHJhdyB0b29sdGlwLlxyXG4gICAgICovXG4gICAgdGhpcy5kaW1lbnNpb25zID0gc2luZ2xlRGltZW5zaW9ucztcbiAgICB0aGlzLmF4aXNQb2ludGVyRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5tb2RlbCA9IGF4aXNNb2RlbDtcbiAgICB0aGlzLl9pbml0KGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgfVxuICAvKipcclxuICAgKiBJbml0aWFsaXplIHNpbmdsZSBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgKi9cbiAgU2luZ2xlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBkaW0gPSB0aGlzLmRpbWVuc2lvbjtcbiAgICB2YXIgYXhpcyA9IG5ldyBTaW5nbGVBeGlzKGRpbSwgYXhpc0hlbHBlci5jcmVhdGVTY2FsZUJ5TW9kZWwoYXhpc01vZGVsKSwgWzAsIDBdLCBheGlzTW9kZWwuZ2V0KCd0eXBlJyksIGF4aXNNb2RlbC5nZXQoJ3Bvc2l0aW9uJykpO1xuICAgIHZhciBpc0NhdGVnb3J5ID0gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknO1xuICAgIGF4aXMub25CYW5kID0gaXNDYXRlZ29yeSAmJiBheGlzTW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuICAgIGF4aXMuaW52ZXJzZSA9IGF4aXNNb2RlbC5nZXQoJ2ludmVyc2UnKTtcbiAgICBheGlzLm9yaWVudCA9IGF4aXNNb2RlbC5nZXQoJ29yaWVudCcpO1xuICAgIGF4aXNNb2RlbC5heGlzID0gYXhpcztcbiAgICBheGlzLm1vZGVsID0gYXhpc01vZGVsO1xuICAgIGF4aXMuY29vcmRpbmF0ZVN5c3RlbSA9IHRoaXM7XG4gICAgdGhpcy5fYXhpcyA9IGF4aXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBheGlzIHNjYWxlIGFmdGVyIGRhdGEgcHJvY2Vzc2VkXHJcbiAgICovXG4gIFNpbmdsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIGlmIChzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtID09PSB0aGlzKSB7XG4gICAgICAgIHZhciBkYXRhXzEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgIGVhY2goZGF0YV8xLm1hcERpbWVuc2lvbnNBbGwodGhpcy5kaW1lbnNpb24pLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgICAgdGhpcy5fYXhpcy5zY2FsZS51bmlvbkV4dGVudEZyb21EYXRhKGRhdGFfMSwgZGltKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGF4aXNIZWxwZXIubmljZVNjYWxlRXh0ZW50KHRoaXMuX2F4aXMuc2NhbGUsIHRoaXMuX2F4aXMubW9kZWwpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuICAvKipcclxuICAgKiBSZXNpemUgdGhlIHNpbmdsZSBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgKi9cbiAgU2luZ2xlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoYXhpc01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLl9yZWN0ID0gZ2V0TGF5b3V0UmVjdCh7XG4gICAgICBsZWZ0OiBheGlzTW9kZWwuZ2V0KCdsZWZ0JyksXG4gICAgICB0b3A6IGF4aXNNb2RlbC5nZXQoJ3RvcCcpLFxuICAgICAgcmlnaHQ6IGF4aXNNb2RlbC5nZXQoJ3JpZ2h0JyksXG4gICAgICBib3R0b206IGF4aXNNb2RlbC5nZXQoJ2JvdHRvbScpLFxuICAgICAgd2lkdGg6IGF4aXNNb2RlbC5nZXQoJ3dpZHRoJyksXG4gICAgICBoZWlnaHQ6IGF4aXNNb2RlbC5nZXQoJ2hlaWdodCcpXG4gICAgfSwge1xuICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICB9KTtcbiAgICB0aGlzLl9hZGp1c3RBeGlzKCk7XG4gIH07XG4gIFNpbmdsZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgfTtcbiAgU2luZ2xlLnByb3RvdHlwZS5fYWRqdXN0QXhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuX3JlY3Q7XG4gICAgdmFyIGF4aXMgPSB0aGlzLl9heGlzO1xuICAgIHZhciBpc0hvcml6b250YWwgPSBheGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIHZhciBleHRlbnQgPSBpc0hvcml6b250YWwgPyBbMCwgcmVjdC53aWR0aF0gOiBbMCwgcmVjdC5oZWlnaHRdO1xuICAgIHZhciBpZHggPSBheGlzLmludmVyc2UgPyAxIDogMDtcbiAgICBheGlzLnNldEV4dGVudChleHRlbnRbaWR4XSwgZXh0ZW50WzEgLSBpZHhdKTtcbiAgICB0aGlzLl91cGRhdGVBeGlzVHJhbnNmb3JtKGF4aXMsIGlzSG9yaXpvbnRhbCA/IHJlY3QueCA6IHJlY3QueSk7XG4gIH07XG4gIFNpbmdsZS5wcm90b3R5cGUuX3VwZGF0ZUF4aXNUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoYXhpcywgY29vcmRCYXNlKSB7XG4gICAgdmFyIGF4aXNFeHRlbnQgPSBheGlzLmdldEV4dGVudCgpO1xuICAgIHZhciBleHRlbnRTdW0gPSBheGlzRXh0ZW50WzBdICsgYXhpc0V4dGVudFsxXTtcbiAgICB2YXIgaXNIb3Jpem9udGFsID0gYXhpcy5pc0hvcml6b250YWwoKTtcbiAgICBheGlzLnRvR2xvYmFsQ29vcmQgPSBpc0hvcml6b250YWwgPyBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgIHJldHVybiBjb29yZCArIGNvb3JkQmFzZTtcbiAgICB9IDogZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICByZXR1cm4gZXh0ZW50U3VtIC0gY29vcmQgKyBjb29yZEJhc2U7XG4gICAgfTtcbiAgICBheGlzLnRvTG9jYWxDb29yZCA9IGlzSG9yaXpvbnRhbCA/IGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgcmV0dXJuIGNvb3JkIC0gY29vcmRCYXNlO1xuICAgIH0gOiBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgIHJldHVybiBleHRlbnRTdW0gLSBjb29yZCArIGNvb3JkQmFzZTtcbiAgICB9O1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgYXhpcy5cclxuICAgKi9cbiAgU2luZ2xlLnByb3RvdHlwZS5nZXRBeGlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9heGlzO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgYXhpcywgYWRkIGl0IGp1c3QgZm9yIGRyYXcgdG9vbHRpcC5cclxuICAgKi9cbiAgU2luZ2xlLnByb3RvdHlwZS5nZXRCYXNlQXhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXhpcztcbiAgfTtcbiAgU2luZ2xlLnByb3RvdHlwZS5nZXRBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbdGhpcy5fYXhpc107XG4gIH07XG4gIFNpbmdsZS5wcm90b3R5cGUuZ2V0VG9vbHRpcEF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2VBeGVzOiBbdGhpcy5nZXRBeGlzKCldLFxuICAgICAgLy8gRW1wdHkgb3RoZXJBeGVzXG4gICAgICBvdGhlckF4ZXM6IFtdXG4gICAgfTtcbiAgfTtcbiAgLyoqXHJcbiAgICogSWYgY29udGFpbiBwb2ludC5cclxuICAgKi9cbiAgU2luZ2xlLnByb3RvdHlwZS5jb250YWluUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0UmVjdCgpO1xuICAgIHZhciBheGlzID0gdGhpcy5nZXRBeGlzKCk7XG4gICAgdmFyIG9yaWVudCA9IGF4aXMub3JpZW50O1xuICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgcmV0dXJuIGF4aXMuY29udGFpbihheGlzLnRvTG9jYWxDb29yZChwb2ludFswXSkpICYmIHBvaW50WzFdID49IHJlY3QueSAmJiBwb2ludFsxXSA8PSByZWN0LnkgKyByZWN0LmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF4aXMuY29udGFpbihheGlzLnRvTG9jYWxDb29yZChwb2ludFsxXSkpICYmIHBvaW50WzBdID49IHJlY3QueSAmJiBwb2ludFswXSA8PSByZWN0LnkgKyByZWN0LmhlaWdodDtcbiAgICB9XG4gIH07XG4gIFNpbmdsZS5wcm90b3R5cGUucG9pbnRUb0RhdGEgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMuZ2V0QXhpcygpO1xuICAgIHJldHVybiBbYXhpcy5jb29yZFRvRGF0YShheGlzLnRvTG9jYWxDb29yZChwb2ludFtheGlzLm9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gMCA6IDFdKSldO1xuICB9O1xuICAvKipcclxuICAgKiBDb252ZXJ0IHRoZSBzZXJpZXMgZGF0YSB0byBjb25jcmV0ZSBwb2ludC5cclxuICAgKiBDYW4gYmUgW3ZhbF0gfCB2YWxcclxuICAgKi9cbiAgU2luZ2xlLnByb3RvdHlwZS5kYXRhVG9Qb2ludCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMuZ2V0QXhpcygpO1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRSZWN0KCk7XG4gICAgdmFyIHB0ID0gW107XG4gICAgdmFyIGlkeCA9IGF4aXMub3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyAwIDogMTtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHZhbCA9IHZhbFswXTtcbiAgICB9XG4gICAgcHRbaWR4XSA9IGF4aXMudG9HbG9iYWxDb29yZChheGlzLmRhdGFUb0Nvb3JkKCt2YWwpKTtcbiAgICBwdFsxIC0gaWR4XSA9IGlkeCA9PT0gMCA/IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiA6IHJlY3QueCArIHJlY3Qud2lkdGggLyAyO1xuICAgIHJldHVybiBwdDtcbiAgfTtcbiAgU2luZ2xlLnByb3RvdHlwZS5jb252ZXJ0VG9QaXhlbCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIsIHZhbHVlKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gZ2V0Q29vcmRTeXMoZmluZGVyKTtcbiAgICByZXR1cm4gY29vcmRTeXMgPT09IHRoaXMgPyB0aGlzLmRhdGFUb1BvaW50KHZhbHVlKSA6IG51bGw7XG4gIH07XG4gIFNpbmdsZS5wcm90b3R5cGUuY29udmVydEZyb21QaXhlbCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIsIHBpeGVsKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gZ2V0Q29vcmRTeXMoZmluZGVyKTtcbiAgICByZXR1cm4gY29vcmRTeXMgPT09IHRoaXMgPyB0aGlzLnBvaW50VG9EYXRhKHBpeGVsKSA6IG51bGw7XG4gIH07XG4gIHJldHVybiBTaW5nbGU7XG59KCk7XG5mdW5jdGlvbiBnZXRDb29yZFN5cyhmaW5kZXIpIHtcbiAgdmFyIHNlcmllc01vZGVsID0gZmluZGVyLnNlcmllc01vZGVsO1xuICB2YXIgc2luZ2xlTW9kZWwgPSBmaW5kZXIuc2luZ2xlQXhpc01vZGVsO1xuICByZXR1cm4gc2luZ2xlTW9kZWwgJiYgc2luZ2xlTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSB8fCBzZXJpZXNNb2RlbCAmJiBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xufVxuZXhwb3J0IGRlZmF1bHQgU2luZ2xlOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLyoqXHJcbiAqIFNpbmdsZSBjb29yZGluYXRlIHN5c3RlbSBjcmVhdG9yLlxyXG4gKi9cbmltcG9ydCBTaW5nbGUsIHsgc2luZ2xlRGltZW5zaW9ucyB9IGZyb20gJy4vU2luZ2xlLmpzJztcbmltcG9ydCB7IFNJTkdMRV9SRUZFUlJJTkcgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbi8qKlxyXG4gKiBDcmVhdGUgc2luZ2xlIGNvb3JkaW5hdGUgc3lzdGVtIGFuZCBpbmplY3QgaXQgaW50byBzZXJpZXNNb2RlbC5cclxuICovXG5mdW5jdGlvbiBjcmVhdGUoZWNNb2RlbCwgYXBpKSB7XG4gIHZhciBzaW5nbGVzID0gW107XG4gIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnc2luZ2xlQXhpcycsIGZ1bmN0aW9uIChheGlzTW9kZWwsIGlkeCkge1xuICAgIHZhciBzaW5nbGUgPSBuZXcgU2luZ2xlKGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICBzaW5nbGUubmFtZSA9ICdzaW5nbGVfJyArIGlkeDtcbiAgICBzaW5nbGUucmVzaXplKGF4aXNNb2RlbCwgYXBpKTtcbiAgICBheGlzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IHNpbmdsZTtcbiAgICBzaW5nbGVzLnB1c2goc2luZ2xlKTtcbiAgfSk7XG4gIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICBpZiAoc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykgPT09ICdzaW5nbGVBeGlzJykge1xuICAgICAgdmFyIHNpbmdsZUF4aXNNb2RlbCA9IHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3NpbmdsZUF4aXMnLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG4gICAgICBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gc2luZ2xlQXhpc01vZGVsICYmIHNpbmdsZUF4aXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzaW5nbGVzO1xufVxudmFyIHNpbmdsZUNyZWF0b3IgPSB7XG4gIGNyZWF0ZTogY3JlYXRlLFxuICBkaW1lbnNpb25zOiBzaW5nbGVEaW1lbnNpb25zXG59O1xuZXhwb3J0IGRlZmF1bHQgc2luZ2xlQ3JlYXRvcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15787\n")},17838:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15915);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar PolarModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(PolarModel, _super);\n  function PolarModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = PolarModel.type;\n    return _this;\n  }\n  PolarModel.prototype.findAxisModel = function (axisType) {\n    var foundAxisModel;\n    var ecModel = this.ecModel;\n    ecModel.eachComponent(axisType, function (axisModel) {\n      if (axisModel.getCoordSysModel() === this) {\n        foundAxisModel = axisModel;\n      }\n    }, this);\n    return foundAxisModel;\n  };\n  PolarModel.type = 'polar';\n  PolarModel.dependencies = ['radiusAxis', 'angleAxis'];\n  PolarModel.defaultOption = {\n    // zlevel: 0,\n    z: 0,\n    center: ['50%', '50%'],\n    radius: '80%'\n  };\n  return PolarModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PolarModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc4MzguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9wb2xhci9Qb2xhck1vZGVsLmpzPzg3ZmEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBDb21wb25lbnRNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Db21wb25lbnQuanMnO1xudmFyIFBvbGFyTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUG9sYXJNb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gUG9sYXJNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gUG9sYXJNb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBQb2xhck1vZGVsLnByb3RvdHlwZS5maW5kQXhpc01vZGVsID0gZnVuY3Rpb24gKGF4aXNUeXBlKSB7XG4gICAgdmFyIGZvdW5kQXhpc01vZGVsO1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudChheGlzVHlwZSwgZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgICAgaWYgKGF4aXNNb2RlbC5nZXRDb29yZFN5c01vZGVsKCkgPT09IHRoaXMpIHtcbiAgICAgICAgZm91bmRBeGlzTW9kZWwgPSBheGlzTW9kZWw7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIGZvdW5kQXhpc01vZGVsO1xuICB9O1xuICBQb2xhck1vZGVsLnR5cGUgPSAncG9sYXInO1xuICBQb2xhck1vZGVsLmRlcGVuZGVuY2llcyA9IFsncmFkaXVzQXhpcycsICdhbmdsZUF4aXMnXTtcbiAgUG9sYXJNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIC8vIHpsZXZlbDogMCxcbiAgICB6OiAwLFxuICAgIGNlbnRlcjogWyc1MCUnLCAnNTAlJ10sXG4gICAgcmFkaXVzOiAnODAlJ1xuICB9O1xuICByZXR1cm4gUG9sYXJNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuZXhwb3J0IGRlZmF1bHQgUG9sYXJNb2RlbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17838\n")},24130:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15915);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar ParallelModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(ParallelModel, _super);\n  function ParallelModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ParallelModel.type;\n    return _this;\n  }\n  ParallelModel.prototype.init = function () {\n    _super.prototype.init.apply(this, arguments);\n    this.mergeOption({});\n  };\n  ParallelModel.prototype.mergeOption = function (newOption) {\n    var thisOption = this.option;\n    newOption && zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.merge(thisOption, newOption, true);\n    this._initDimensions();\n  };\n  /**\r\n   * Whether series or axis is in this coordinate system.\r\n   */\n  ParallelModel.prototype.contains = function (model, ecModel) {\n    var parallelIndex = model.get('parallelIndex');\n    return parallelIndex != null && ecModel.getComponent('parallel', parallelIndex) === this;\n  };\n  ParallelModel.prototype.setAxisExpand = function (opt) {\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(['axisExpandable', 'axisExpandCenter', 'axisExpandCount', 'axisExpandWidth', 'axisExpandWindow'], function (name) {\n      if (opt.hasOwnProperty(name)) {\n        // @ts-ignore FIXME: why \"never\" inferred in this.option[name]?\n        this.option[name] = opt[name];\n      }\n    }, this);\n  };\n  ParallelModel.prototype._initDimensions = function () {\n    var dimensions = this.dimensions = [];\n    var parallelAxisIndex = this.parallelAxisIndex = [];\n    var axisModels = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.filter(this.ecModel.queryComponents({\n      mainType: 'parallelAxis'\n    }), function (axisModel) {\n      // Can not use this.contains here, because\n      // initialization has not been completed yet.\n      return (axisModel.get('parallelIndex') || 0) === this.componentIndex;\n    }, this);\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(axisModels, function (axisModel) {\n      dimensions.push('dim' + axisModel.get('dim'));\n      parallelAxisIndex.push(axisModel.componentIndex);\n    });\n  };\n  ParallelModel.type = 'parallel';\n  ParallelModel.dependencies = ['parallelAxis'];\n  ParallelModel.layoutMode = 'box';\n  ParallelModel.defaultOption = {\n    // zlevel: 0,\n    z: 0,\n    left: 80,\n    top: 60,\n    right: 80,\n    bottom: 60,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    layout: 'horizontal',\n    // FIXME\n    // naming?\n    axisExpandable: false,\n    axisExpandCenter: null,\n    axisExpandCount: 0,\n    axisExpandWidth: 50,\n    axisExpandRate: 17,\n    axisExpandDebounce: 50,\n    // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.\n    // Do not doc to user until necessary.\n    axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],\n    axisExpandTriggerOn: 'click',\n    parallelAxisDefault: null\n  };\n  return ParallelModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ParallelModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQxMzAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9wYXJhbGxlbC9QYXJhbGxlbE1vZGVsLmpzPzBmZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IENvbXBvbmVudE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL0NvbXBvbmVudC5qcyc7XG52YXIgUGFyYWxsZWxNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQYXJhbGxlbE1vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBQYXJhbGxlbE1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBQYXJhbGxlbE1vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFBhcmFsbGVsTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5tZXJnZU9wdGlvbih7fSk7XG4gIH07XG4gIFBhcmFsbGVsTW9kZWwucHJvdG90eXBlLm1lcmdlT3B0aW9uID0gZnVuY3Rpb24gKG5ld09wdGlvbikge1xuICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgbmV3T3B0aW9uICYmIHpyVXRpbC5tZXJnZSh0aGlzT3B0aW9uLCBuZXdPcHRpb24sIHRydWUpO1xuICAgIHRoaXMuX2luaXREaW1lbnNpb25zKCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgc2VyaWVzIG9yIGF4aXMgaXMgaW4gdGhpcyBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgKi9cbiAgUGFyYWxsZWxNb2RlbC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAobW9kZWwsIGVjTW9kZWwpIHtcbiAgICB2YXIgcGFyYWxsZWxJbmRleCA9IG1vZGVsLmdldCgncGFyYWxsZWxJbmRleCcpO1xuICAgIHJldHVybiBwYXJhbGxlbEluZGV4ICE9IG51bGwgJiYgZWNNb2RlbC5nZXRDb21wb25lbnQoJ3BhcmFsbGVsJywgcGFyYWxsZWxJbmRleCkgPT09IHRoaXM7XG4gIH07XG4gIFBhcmFsbGVsTW9kZWwucHJvdG90eXBlLnNldEF4aXNFeHBhbmQgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgenJVdGlsLmVhY2goWydheGlzRXhwYW5kYWJsZScsICdheGlzRXhwYW5kQ2VudGVyJywgJ2F4aXNFeHBhbmRDb3VudCcsICdheGlzRXhwYW5kV2lkdGgnLCAnYXhpc0V4cGFuZFdpbmRvdyddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKG9wdC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FOiB3aHkgXCJuZXZlclwiIGluZmVycmVkIGluIHRoaXMub3B0aW9uW25hbWVdP1xuICAgICAgICB0aGlzLm9wdGlvbltuYW1lXSA9IG9wdFtuYW1lXTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgUGFyYWxsZWxNb2RlbC5wcm90b3R5cGUuX2luaXREaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zID0gW107XG4gICAgdmFyIHBhcmFsbGVsQXhpc0luZGV4ID0gdGhpcy5wYXJhbGxlbEF4aXNJbmRleCA9IFtdO1xuICAgIHZhciBheGlzTW9kZWxzID0genJVdGlsLmZpbHRlcih0aGlzLmVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgIG1haW5UeXBlOiAncGFyYWxsZWxBeGlzJ1xuICAgIH0pLCBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgICAvLyBDYW4gbm90IHVzZSB0aGlzLmNvbnRhaW5zIGhlcmUsIGJlY2F1c2VcbiAgICAgIC8vIGluaXRpYWxpemF0aW9uIGhhcyBub3QgYmVlbiBjb21wbGV0ZWQgeWV0LlxuICAgICAgcmV0dXJuIChheGlzTW9kZWwuZ2V0KCdwYXJhbGxlbEluZGV4JykgfHwgMCkgPT09IHRoaXMuY29tcG9uZW50SW5kZXg7XG4gICAgfSwgdGhpcyk7XG4gICAgenJVdGlsLmVhY2goYXhpc01vZGVscywgZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgICAgZGltZW5zaW9ucy5wdXNoKCdkaW0nICsgYXhpc01vZGVsLmdldCgnZGltJykpO1xuICAgICAgcGFyYWxsZWxBeGlzSW5kZXgucHVzaChheGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgIH0pO1xuICB9O1xuICBQYXJhbGxlbE1vZGVsLnR5cGUgPSAncGFyYWxsZWwnO1xuICBQYXJhbGxlbE1vZGVsLmRlcGVuZGVuY2llcyA9IFsncGFyYWxsZWxBeGlzJ107XG4gIFBhcmFsbGVsTW9kZWwubGF5b3V0TW9kZSA9ICdib3gnO1xuICBQYXJhbGxlbE1vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgLy8gemxldmVsOiAwLFxuICAgIHo6IDAsXG4gICAgbGVmdDogODAsXG4gICAgdG9wOiA2MCxcbiAgICByaWdodDogODAsXG4gICAgYm90dG9tOiA2MCxcbiAgICAvLyB3aWR0aDoge3RvdGFsV2lkdGh9IC0gbGVmdCAtIHJpZ2h0LFxuICAgIC8vIGhlaWdodDoge3RvdGFsSGVpZ2h0fSAtIHRvcCAtIGJvdHRvbSxcbiAgICBsYXlvdXQ6ICdob3Jpem9udGFsJyxcbiAgICAvLyBGSVhNRVxuICAgIC8vIG5hbWluZz9cbiAgICBheGlzRXhwYW5kYWJsZTogZmFsc2UsXG4gICAgYXhpc0V4cGFuZENlbnRlcjogbnVsbCxcbiAgICBheGlzRXhwYW5kQ291bnQ6IDAsXG4gICAgYXhpc0V4cGFuZFdpZHRoOiA1MCxcbiAgICBheGlzRXhwYW5kUmF0ZTogMTcsXG4gICAgYXhpc0V4cGFuZERlYm91bmNlOiA1MCxcbiAgICAvLyBbb3V0LCBpbiwganVtcFRhcmdldF0uIEluIHBlcmNlbnRhZ2UuIElmIHVzZSBbbnVsbCwgMC4wNV0sIG51bGwgbWVhbnMgZnVsbC5cbiAgICAvLyBEbyBub3QgZG9jIHRvIHVzZXIgdW50aWwgbmVjZXNzYXJ5LlxuICAgIGF4aXNFeHBhbmRTbGlkZVRyaWdnZXJBcmVhOiBbLTAuMTUsIDAuMDUsIDAuNF0sXG4gICAgYXhpc0V4cGFuZFRyaWdnZXJPbjogJ2NsaWNrJyxcbiAgICBwYXJhbGxlbEF4aXNEZWZhdWx0OiBudWxsXG4gIH07XG4gIHJldHVybiBQYXJhbGxlbE1vZGVsO1xufShDb21wb25lbnRNb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBQYXJhbGxlbE1vZGVsOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///24130\n")},31024:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   U5: () => (/* binding */ GeoSVGRegion),\n/* harmony export */   cn: () => (/* binding */ GeoJSONRegion),\n/* harmony export */   m5: () => (/* binding */ GeoJSONPolygonGeometry),\n/* harmony export */   nS: () => (/* binding */ GeoJSONLineStringGeometry)\n/* harmony export */ });\n/* unused harmony export Region */\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29308);\n/* harmony import */ var zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83509);\n/* harmony import */ var zrender_lib_contain_polygon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51183);\n/* harmony import */ var zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45587);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\nvar TMP_TRANSFORM = [];\nfunction transformPoints(points, transform) {\n  for (var p = 0; p < points.length; p++) {\n    zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_0__.applyTransform(points[p], points[p], transform);\n  }\n}\nfunction updateBBoxFromPoints(points, min, max, projection) {\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n    if (projection) {\n      // projection may return null point.\n      p = projection.project(p);\n    }\n    if (p && isFinite(p[0]) && isFinite(p[1])) {\n      zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_0__.min(min, min, p);\n      zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_0__.max(max, max, p);\n    }\n  }\n}\nfunction centroid(points) {\n  var signedArea = 0;\n  var cx = 0;\n  var cy = 0;\n  var len = points.length;\n  var x0 = points[len - 1][0];\n  var y0 = points[len - 1][1];\n  // Polygon should been closed.\n  for (var i = 0; i < len; i++) {\n    var x1 = points[i][0];\n    var y1 = points[i][1];\n    var a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n    x0 = x1;\n    y0 = y1;\n  }\n  return signedArea ? [cx / signedArea / 3, cy / signedArea / 3, signedArea] : [points[0][0] || 0, points[0][1] || 0];\n}\nvar Region = /** @class */function () {\n  function Region(name) {\n    this.name = name;\n  }\n  Region.prototype.setCenter = function (center) {\n    this._center = center;\n  };\n  /**\r\n   * Get center point in data unit. That is,\r\n   * for GeoJSONRegion, the unit is lat/lng,\r\n   * for GeoSVGRegion, the unit is SVG local coord.\r\n   */\n  Region.prototype.getCenter = function () {\n    var center = this._center;\n    if (!center) {\n      // In most cases there are no need to calculate this center.\n      // So calculate only when called.\n      center = this._center = this.calcCenter();\n    }\n    return center;\n  };\n  return Region;\n}();\n\nvar GeoJSONPolygonGeometry = /** @class */function () {\n  function GeoJSONPolygonGeometry(exterior, interiors) {\n    this.type = 'polygon';\n    this.exterior = exterior;\n    this.interiors = interiors;\n  }\n  return GeoJSONPolygonGeometry;\n}();\n\nvar GeoJSONLineStringGeometry = /** @class */function () {\n  function GeoJSONLineStringGeometry(points) {\n    this.type = 'linestring';\n    this.points = points;\n  }\n  return GeoJSONLineStringGeometry;\n}();\n\nvar GeoJSONRegion = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .C6)(GeoJSONRegion, _super);\n  function GeoJSONRegion(name, geometries, cp) {\n    var _this = _super.call(this, name) || this;\n    _this.type = 'geoJSON';\n    _this.geometries = geometries;\n    _this._center = cp && [cp[0], cp[1]];\n    return _this;\n  }\n  GeoJSONRegion.prototype.calcCenter = function () {\n    var geometries = this.geometries;\n    var largestGeo;\n    var largestGeoSize = 0;\n    for (var i = 0; i < geometries.length; i++) {\n      var geo = geometries[i];\n      var exterior = geo.exterior;\n      // Simple trick to use points count instead of polygon area as region size.\n      // Ignore linestring\n      var size = exterior && exterior.length;\n      if (size > largestGeoSize) {\n        largestGeo = geo;\n        largestGeoSize = size;\n      }\n    }\n    if (largestGeo) {\n      return centroid(largestGeo.exterior);\n    }\n    // from bounding rect by default.\n    var rect = this.getBoundingRect();\n    return [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  };\n  GeoJSONRegion.prototype.getBoundingRect = function (projection) {\n    var rect = this._rect;\n    // Always recalculate if using projection.\n    if (rect && !projection) {\n      return rect;\n    }\n    var min = [Infinity, Infinity];\n    var max = [-Infinity, -Infinity];\n    var geometries = this.geometries;\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(geometries, function (geo) {\n      if (geo.type === 'polygon') {\n        // Doesn't consider hole\n        updateBBoxFromPoints(geo.exterior, min, max, projection);\n      } else {\n        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(geo.points, function (points) {\n          updateBBoxFromPoints(points, min, max, projection);\n        });\n      }\n    });\n    // Normalie invalid bounding.\n    if (!(isFinite(min[0]) && isFinite(min[1]) && isFinite(max[0]) && isFinite(max[1]))) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n    rect = new zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n    if (!projection) {\n      this._rect = rect;\n    }\n    return rect;\n  };\n  GeoJSONRegion.prototype.contain = function (coord) {\n    var rect = this.getBoundingRect();\n    var geometries = this.geometries;\n    if (!rect.contain(coord[0], coord[1])) {\n      return false;\n    }\n    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {\n      var geo = geometries[i];\n      // Only support polygon.\n      if (geo.type !== 'polygon') {\n        continue;\n      }\n      var exterior = geo.exterior;\n      var interiors = geo.interiors;\n      if (zrender_lib_contain_polygon_js__WEBPACK_IMPORTED_MODULE_4__/* .contain */ .l(exterior, coord[0], coord[1])) {\n        // Not in the region if point is in the hole.\n        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {\n          if (zrender_lib_contain_polygon_js__WEBPACK_IMPORTED_MODULE_4__/* .contain */ .l(interiors[k], coord[0], coord[1])) {\n            continue loopGeo;\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  };\n  /**\r\n   * Transform the raw coords to target bounding.\r\n   * @param x\r\n   * @param y\r\n   * @param width\r\n   * @param height\r\n   */\n  GeoJSONRegion.prototype.transformTo = function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var aspect = rect.width / rect.height;\n    if (!width) {\n      width = aspect * height;\n    } else if (!height) {\n      height = width / aspect;\n    }\n    var target = new zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A(x, y, width, height);\n    var transform = rect.calculateTransform(target);\n    var geometries = this.geometries;\n    for (var i = 0; i < geometries.length; i++) {\n      var geo = geometries[i];\n      if (geo.type === 'polygon') {\n        transformPoints(geo.exterior, transform);\n        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(geo.interiors, function (interior) {\n          transformPoints(interior, transform);\n        });\n      } else {\n        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(geo.points, function (points) {\n          transformPoints(points, transform);\n        });\n      }\n    }\n    rect = this._rect;\n    rect.copy(target);\n    // Update center\n    this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  };\n  GeoJSONRegion.prototype.cloneShallow = function (name) {\n    name == null && (name = this.name);\n    var newRegion = new GeoJSONRegion(name, this.geometries, this._center);\n    newRegion._rect = this._rect;\n    newRegion.transformTo = null; // Simply avoid to be called.\n    return newRegion;\n  };\n  return GeoJSONRegion;\n}(Region);\n\nvar GeoSVGRegion = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .C6)(GeoSVGRegion, _super);\n  function GeoSVGRegion(name, elOnlyForCalculate) {\n    var _this = _super.call(this, name) || this;\n    _this.type = 'geoSVG';\n    _this._elOnlyForCalculate = elOnlyForCalculate;\n    return _this;\n  }\n  GeoSVGRegion.prototype.calcCenter = function () {\n    var el = this._elOnlyForCalculate;\n    var rect = el.getBoundingRect();\n    var center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n    var mat = zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__.identity(TMP_TRANSFORM);\n    var target = el;\n    while (target && !target.isGeoSVGGraphicRoot) {\n      zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__.mul(mat, target.getLocalTransform(), mat);\n      target = target.parent;\n    }\n    zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__.invert(mat, mat);\n    zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_0__.applyTransform(center, center, mat);\n    return center;\n  };\n  return GeoSVGRegion;\n}(Region);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEwMjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9nZW8vUmVnaW9uLmpzP2YxZTAiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBCb3VuZGluZ1JlY3QgZnJvbSAnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMnO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvci5qcyc7XG5pbXBvcnQgKiBhcyBwb2x5Z29uQ29udGFpbiBmcm9tICd6cmVuZGVyL2xpYi9jb250YWluL3BvbHlnb24uanMnO1xuaW1wb3J0ICogYXMgbWF0cml4IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzJztcbmltcG9ydCB7IGVhY2ggfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xudmFyIFRNUF9UUkFOU0ZPUk0gPSBbXTtcbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50cyhwb2ludHMsIHRyYW5zZm9ybSkge1xuICBmb3IgKHZhciBwID0gMDsgcCA8IHBvaW50cy5sZW5ndGg7IHArKykge1xuICAgIHZlYzIuYXBwbHlUcmFuc2Zvcm0ocG9pbnRzW3BdLCBwb2ludHNbcF0sIHRyYW5zZm9ybSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUJCb3hGcm9tUG9pbnRzKHBvaW50cywgbWluLCBtYXgsIHByb2plY3Rpb24pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgLy8gcHJvamVjdGlvbiBtYXkgcmV0dXJuIG51bGwgcG9pbnQuXG4gICAgICBwID0gcHJvamVjdGlvbi5wcm9qZWN0KHApO1xuICAgIH1cbiAgICBpZiAocCAmJiBpc0Zpbml0ZShwWzBdKSAmJiBpc0Zpbml0ZShwWzFdKSkge1xuICAgICAgdmVjMi5taW4obWluLCBtaW4sIHApO1xuICAgICAgdmVjMi5tYXgobWF4LCBtYXgsIHApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2VudHJvaWQocG9pbnRzKSB7XG4gIHZhciBzaWduZWRBcmVhID0gMDtcbiAgdmFyIGN4ID0gMDtcbiAgdmFyIGN5ID0gMDtcbiAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gIHZhciB4MCA9IHBvaW50c1tsZW4gLSAxXVswXTtcbiAgdmFyIHkwID0gcG9pbnRzW2xlbiAtIDFdWzFdO1xuICAvLyBQb2x5Z29uIHNob3VsZCBiZWVuIGNsb3NlZC5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4MSA9IHBvaW50c1tpXVswXTtcbiAgICB2YXIgeTEgPSBwb2ludHNbaV1bMV07XG4gICAgdmFyIGEgPSB4MCAqIHkxIC0geDEgKiB5MDtcbiAgICBzaWduZWRBcmVhICs9IGE7XG4gICAgY3ggKz0gKHgwICsgeDEpICogYTtcbiAgICBjeSArPSAoeTAgKyB5MSkgKiBhO1xuICAgIHgwID0geDE7XG4gICAgeTAgPSB5MTtcbiAgfVxuICByZXR1cm4gc2lnbmVkQXJlYSA/IFtjeCAvIHNpZ25lZEFyZWEgLyAzLCBjeSAvIHNpZ25lZEFyZWEgLyAzLCBzaWduZWRBcmVhXSA6IFtwb2ludHNbMF1bMF0gfHwgMCwgcG9pbnRzWzBdWzFdIHx8IDBdO1xufVxudmFyIFJlZ2lvbiA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlZ2lvbihuYW1lKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuICBSZWdpb24ucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uIChjZW50ZXIpIHtcbiAgICB0aGlzLl9jZW50ZXIgPSBjZW50ZXI7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCBjZW50ZXIgcG9pbnQgaW4gZGF0YSB1bml0LiBUaGF0IGlzLFxyXG4gICAqIGZvciBHZW9KU09OUmVnaW9uLCB0aGUgdW5pdCBpcyBsYXQvbG5nLFxyXG4gICAqIGZvciBHZW9TVkdSZWdpb24sIHRoZSB1bml0IGlzIFNWRyBsb2NhbCBjb29yZC5cclxuICAgKi9cbiAgUmVnaW9uLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNlbnRlciA9IHRoaXMuX2NlbnRlcjtcbiAgICBpZiAoIWNlbnRlcikge1xuICAgICAgLy8gSW4gbW9zdCBjYXNlcyB0aGVyZSBhcmUgbm8gbmVlZCB0byBjYWxjdWxhdGUgdGhpcyBjZW50ZXIuXG4gICAgICAvLyBTbyBjYWxjdWxhdGUgb25seSB3aGVuIGNhbGxlZC5cbiAgICAgIGNlbnRlciA9IHRoaXMuX2NlbnRlciA9IHRoaXMuY2FsY0NlbnRlcigpO1xuICAgIH1cbiAgICByZXR1cm4gY2VudGVyO1xuICB9O1xuICByZXR1cm4gUmVnaW9uO1xufSgpO1xuZXhwb3J0IHsgUmVnaW9uIH07XG52YXIgR2VvSlNPTlBvbHlnb25HZW9tZXRyeSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdlb0pTT05Qb2x5Z29uR2VvbWV0cnkoZXh0ZXJpb3IsIGludGVyaW9ycykge1xuICAgIHRoaXMudHlwZSA9ICdwb2x5Z29uJztcbiAgICB0aGlzLmV4dGVyaW9yID0gZXh0ZXJpb3I7XG4gICAgdGhpcy5pbnRlcmlvcnMgPSBpbnRlcmlvcnM7XG4gIH1cbiAgcmV0dXJuIEdlb0pTT05Qb2x5Z29uR2VvbWV0cnk7XG59KCk7XG5leHBvcnQgeyBHZW9KU09OUG9seWdvbkdlb21ldHJ5IH07XG52YXIgR2VvSlNPTkxpbmVTdHJpbmdHZW9tZXRyeSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdlb0pTT05MaW5lU3RyaW5nR2VvbWV0cnkocG9pbnRzKSB7XG4gICAgdGhpcy50eXBlID0gJ2xpbmVzdHJpbmcnO1xuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICB9XG4gIHJldHVybiBHZW9KU09OTGluZVN0cmluZ0dlb21ldHJ5O1xufSgpO1xuZXhwb3J0IHsgR2VvSlNPTkxpbmVTdHJpbmdHZW9tZXRyeSB9O1xudmFyIEdlb0pTT05SZWdpb24gPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoR2VvSlNPTlJlZ2lvbiwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gR2VvSlNPTlJlZ2lvbihuYW1lLCBnZW9tZXRyaWVzLCBjcCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9ICdnZW9KU09OJztcbiAgICBfdGhpcy5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcbiAgICBfdGhpcy5fY2VudGVyID0gY3AgJiYgW2NwWzBdLCBjcFsxXV07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEdlb0pTT05SZWdpb24ucHJvdG90eXBlLmNhbGNDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSB0aGlzLmdlb21ldHJpZXM7XG4gICAgdmFyIGxhcmdlc3RHZW87XG4gICAgdmFyIGxhcmdlc3RHZW9TaXplID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBnZW8gPSBnZW9tZXRyaWVzW2ldO1xuICAgICAgdmFyIGV4dGVyaW9yID0gZ2VvLmV4dGVyaW9yO1xuICAgICAgLy8gU2ltcGxlIHRyaWNrIHRvIHVzZSBwb2ludHMgY291bnQgaW5zdGVhZCBvZiBwb2x5Z29uIGFyZWEgYXMgcmVnaW9uIHNpemUuXG4gICAgICAvLyBJZ25vcmUgbGluZXN0cmluZ1xuICAgICAgdmFyIHNpemUgPSBleHRlcmlvciAmJiBleHRlcmlvci5sZW5ndGg7XG4gICAgICBpZiAoc2l6ZSA+IGxhcmdlc3RHZW9TaXplKSB7XG4gICAgICAgIGxhcmdlc3RHZW8gPSBnZW87XG4gICAgICAgIGxhcmdlc3RHZW9TaXplID0gc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhcmdlc3RHZW8pIHtcbiAgICAgIHJldHVybiBjZW50cm9pZChsYXJnZXN0R2VvLmV4dGVyaW9yKTtcbiAgICB9XG4gICAgLy8gZnJvbSBib3VuZGluZyByZWN0IGJ5IGRlZmF1bHQuXG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHJldHVybiBbcmVjdC54ICsgcmVjdC53aWR0aCAvIDIsIHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMl07XG4gIH07XG4gIEdlb0pTT05SZWdpb24ucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uIChwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLl9yZWN0O1xuICAgIC8vIEFsd2F5cyByZWNhbGN1bGF0ZSBpZiB1c2luZyBwcm9qZWN0aW9uLlxuICAgIGlmIChyZWN0ICYmICFwcm9qZWN0aW9uKSB7XG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gICAgdmFyIG1pbiA9IFtJbmZpbml0eSwgSW5maW5pdHldO1xuICAgIHZhciBtYXggPSBbLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgIHZhciBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzO1xuICAgIGVhY2goZ2VvbWV0cmllcywgZnVuY3Rpb24gKGdlbykge1xuICAgICAgaWYgKGdlby50eXBlID09PSAncG9seWdvbicpIHtcbiAgICAgICAgLy8gRG9lc24ndCBjb25zaWRlciBob2xlXG4gICAgICAgIHVwZGF0ZUJCb3hGcm9tUG9pbnRzKGdlby5leHRlcmlvciwgbWluLCBtYXgsIHByb2plY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFjaChnZW8ucG9pbnRzLCBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICAgICAgdXBkYXRlQkJveEZyb21Qb2ludHMocG9pbnRzLCBtaW4sIG1heCwgcHJvamVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIE5vcm1hbGllIGludmFsaWQgYm91bmRpbmcuXG4gICAgaWYgKCEoaXNGaW5pdGUobWluWzBdKSAmJiBpc0Zpbml0ZShtaW5bMV0pICYmIGlzRmluaXRlKG1heFswXSkgJiYgaXNGaW5pdGUobWF4WzFdKSkpIHtcbiAgICAgIG1pblswXSA9IG1pblsxXSA9IG1heFswXSA9IG1heFsxXSA9IDA7XG4gICAgfVxuICAgIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG4gICAgaWYgKCFwcm9qZWN0aW9uKSB7XG4gICAgICB0aGlzLl9yZWN0ID0gcmVjdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH07XG4gIEdlb0pTT05SZWdpb24ucHJvdG90eXBlLmNvbnRhaW4gPSBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIGdlb21ldHJpZXMgPSB0aGlzLmdlb21ldHJpZXM7XG4gICAgaWYgKCFyZWN0LmNvbnRhaW4oY29vcmRbMF0sIGNvb3JkWzFdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsb29wR2VvOiBmb3IgKHZhciBpID0gMCwgbGVuID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGdlbyA9IGdlb21ldHJpZXNbaV07XG4gICAgICAvLyBPbmx5IHN1cHBvcnQgcG9seWdvbi5cbiAgICAgIGlmIChnZW8udHlwZSAhPT0gJ3BvbHlnb24nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGV4dGVyaW9yID0gZ2VvLmV4dGVyaW9yO1xuICAgICAgdmFyIGludGVyaW9ycyA9IGdlby5pbnRlcmlvcnM7XG4gICAgICBpZiAocG9seWdvbkNvbnRhaW4uY29udGFpbihleHRlcmlvciwgY29vcmRbMF0sIGNvb3JkWzFdKSkge1xuICAgICAgICAvLyBOb3QgaW4gdGhlIHJlZ2lvbiBpZiBwb2ludCBpcyBpbiB0aGUgaG9sZS5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCAoaW50ZXJpb3JzID8gaW50ZXJpb3JzLmxlbmd0aCA6IDApOyBrKyspIHtcbiAgICAgICAgICBpZiAocG9seWdvbkNvbnRhaW4uY29udGFpbihpbnRlcmlvcnNba10sIGNvb3JkWzBdLCBjb29yZFsxXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlIGxvb3BHZW87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgcmF3IGNvb3JkcyB0byB0YXJnZXQgYm91bmRpbmcuXHJcbiAgICogQHBhcmFtIHhcclxuICAgKiBAcGFyYW0geVxyXG4gICAqIEBwYXJhbSB3aWR0aFxyXG4gICAqIEBwYXJhbSBoZWlnaHRcclxuICAgKi9cbiAgR2VvSlNPTlJlZ2lvbi5wcm90b3R5cGUudHJhbnNmb3JtVG8gPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgYXNwZWN0ID0gcmVjdC53aWR0aCAvIHJlY3QuaGVpZ2h0O1xuICAgIGlmICghd2lkdGgpIHtcbiAgICAgIHdpZHRoID0gYXNwZWN0ICogaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoIWhlaWdodCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfVxuICAgIHZhciB0YXJnZXQgPSBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciB0cmFuc2Zvcm0gPSByZWN0LmNhbGN1bGF0ZVRyYW5zZm9ybSh0YXJnZXQpO1xuICAgIHZhciBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGdlbyA9IGdlb21ldHJpZXNbaV07XG4gICAgICBpZiAoZ2VvLnR5cGUgPT09ICdwb2x5Z29uJykge1xuICAgICAgICB0cmFuc2Zvcm1Qb2ludHMoZ2VvLmV4dGVyaW9yLCB0cmFuc2Zvcm0pO1xuICAgICAgICBlYWNoKGdlby5pbnRlcmlvcnMsIGZ1bmN0aW9uIChpbnRlcmlvcikge1xuICAgICAgICAgIHRyYW5zZm9ybVBvaW50cyhpbnRlcmlvciwgdHJhbnNmb3JtKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYWNoKGdlby5wb2ludHMsIGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1Qb2ludHMocG9pbnRzLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVjdCA9IHRoaXMuX3JlY3Q7XG4gICAgcmVjdC5jb3B5KHRhcmdldCk7XG4gICAgLy8gVXBkYXRlIGNlbnRlclxuICAgIHRoaXMuX2NlbnRlciA9IFtyZWN0LnggKyByZWN0LndpZHRoIC8gMiwgcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyXTtcbiAgfTtcbiAgR2VvSlNPTlJlZ2lvbi5wcm90b3R5cGUuY2xvbmVTaGFsbG93ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBuYW1lID09IG51bGwgJiYgKG5hbWUgPSB0aGlzLm5hbWUpO1xuICAgIHZhciBuZXdSZWdpb24gPSBuZXcgR2VvSlNPTlJlZ2lvbihuYW1lLCB0aGlzLmdlb21ldHJpZXMsIHRoaXMuX2NlbnRlcik7XG4gICAgbmV3UmVnaW9uLl9yZWN0ID0gdGhpcy5fcmVjdDtcbiAgICBuZXdSZWdpb24udHJhbnNmb3JtVG8gPSBudWxsOyAvLyBTaW1wbHkgYXZvaWQgdG8gYmUgY2FsbGVkLlxuICAgIHJldHVybiBuZXdSZWdpb247XG4gIH07XG4gIHJldHVybiBHZW9KU09OUmVnaW9uO1xufShSZWdpb24pO1xuZXhwb3J0IHsgR2VvSlNPTlJlZ2lvbiB9O1xudmFyIEdlb1NWR1JlZ2lvbiA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhHZW9TVkdSZWdpb24sIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEdlb1NWR1JlZ2lvbihuYW1lLCBlbE9ubHlGb3JDYWxjdWxhdGUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSAnZ2VvU1ZHJztcbiAgICBfdGhpcy5fZWxPbmx5Rm9yQ2FsY3VsYXRlID0gZWxPbmx5Rm9yQ2FsY3VsYXRlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBHZW9TVkdSZWdpb24ucHJvdG90eXBlLmNhbGNDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5fZWxPbmx5Rm9yQ2FsY3VsYXRlO1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIGNlbnRlciA9IFtyZWN0LnggKyByZWN0LndpZHRoIC8gMiwgcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyXTtcbiAgICB2YXIgbWF0ID0gbWF0cml4LmlkZW50aXR5KFRNUF9UUkFOU0ZPUk0pO1xuICAgIHZhciB0YXJnZXQgPSBlbDtcbiAgICB3aGlsZSAodGFyZ2V0ICYmICF0YXJnZXQuaXNHZW9TVkdHcmFwaGljUm9vdCkge1xuICAgICAgbWF0cml4Lm11bChtYXQsIHRhcmdldC5nZXRMb2NhbFRyYW5zZm9ybSgpLCBtYXQpO1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudDtcbiAgICB9XG4gICAgbWF0cml4LmludmVydChtYXQsIG1hdCk7XG4gICAgdmVjMi5hcHBseVRyYW5zZm9ybShjZW50ZXIsIGNlbnRlciwgbWF0KTtcbiAgICByZXR1cm4gY2VudGVyO1xuICB9O1xuICByZXR1cm4gR2VvU1ZHUmVnaW9uO1xufShSZWdpb24pO1xuZXhwb3J0IHsgR2VvU1ZHUmVnaW9uIH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31024\n")},36788:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15915);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar GridModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(GridModel, _super);\n  function GridModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  GridModel.type = 'grid';\n  GridModel.dependencies = ['xAxis', 'yAxis'];\n  GridModel.layoutMode = 'box';\n  GridModel.defaultOption = {\n    show: false,\n    // zlevel: 0,\n    z: 0,\n    left: '10%',\n    top: 60,\n    right: '10%',\n    bottom: 70,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderWidth: 1,\n    borderColor: '#ccc'\n  };\n  return GridModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GridModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY3ODguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0dyaWRNb2RlbC5qcz9kODA4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50LmpzJztcbnZhciBHcmlkTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoR3JpZE1vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBHcmlkTW9kZWwoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIEdyaWRNb2RlbC50eXBlID0gJ2dyaWQnO1xuICBHcmlkTW9kZWwuZGVwZW5kZW5jaWVzID0gWyd4QXhpcycsICd5QXhpcyddO1xuICBHcmlkTW9kZWwubGF5b3V0TW9kZSA9ICdib3gnO1xuICBHcmlkTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICBzaG93OiBmYWxzZSxcbiAgICAvLyB6bGV2ZWw6IDAsXG4gICAgejogMCxcbiAgICBsZWZ0OiAnMTAlJyxcbiAgICB0b3A6IDYwLFxuICAgIHJpZ2h0OiAnMTAlJyxcbiAgICBib3R0b206IDcwLFxuICAgIC8vIElmIGdyaWQgc2l6ZSBjb250YWluIGxhYmVsXG4gICAgY29udGFpbkxhYmVsOiBmYWxzZSxcbiAgICAvLyB3aWR0aDoge3RvdGFsV2lkdGh9IC0gbGVmdCAtIHJpZ2h0LFxuICAgIC8vIGhlaWdodDoge3RvdGFsSGVpZ2h0fSAtIHRvcCAtIGJvdHRvbSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICBib3JkZXJXaWR0aDogMSxcbiAgICBib3JkZXJDb2xvcjogJyNjY2MnXG4gIH07XG4gIHJldHVybiBHcmlkTW9kZWw7XG59KENvbXBvbmVudE1vZGVsKTtcbmV4cG9ydCBkZWZhdWx0IEdyaWRNb2RlbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///36788\n")},42262:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tc: () => (/* binding */ ensureScaleRawExtentInfo)\n/* harmony export */ });\n/* unused harmony exports ScaleRawExtentInfo, parseAxisModelMinMax */\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var zrender_lib_contain_text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45558);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar ScaleRawExtentInfo = /** @class */function () {\n  function ScaleRawExtentInfo(scale, model,\n  // Usually: data extent from all series on this axis.\n  originalExtent) {\n    this._prepareParams(scale, model, originalExtent);\n  }\n  /**\r\n   * Parameters depending on outside (like model, user callback)\r\n   * are prepared and fixed here.\r\n   */\n  ScaleRawExtentInfo.prototype._prepareParams = function (scale, model,\n  // Usually: data extent from all series on this axis.\n  dataExtent) {\n    if (dataExtent[1] < dataExtent[0]) {\n      dataExtent = [NaN, NaN];\n    }\n    this._dataMin = dataExtent[0];\n    this._dataMax = dataExtent[1];\n    var isOrdinal = this._isOrdinal = scale.type === 'ordinal';\n    this._needCrossZero = scale.type === 'interval' && model.getNeedCrossZero && model.getNeedCrossZero();\n    var axisMinValue = model.get('min', true);\n    if (axisMinValue == null) {\n      axisMinValue = model.get('startValue', true);\n    }\n    var modelMinRaw = this._modelMinRaw = axisMinValue;\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(modelMinRaw)) {\n      // This callback always provides users the full data extent (before data is filtered).\n      this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw({\n        min: dataExtent[0],\n        max: dataExtent[1]\n      }));\n    } else if (modelMinRaw !== 'dataMin') {\n      this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw);\n    }\n    var modelMaxRaw = this._modelMaxRaw = model.get('max', true);\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(modelMaxRaw)) {\n      // This callback always provides users the full data extent (before data is filtered).\n      this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw({\n        min: dataExtent[0],\n        max: dataExtent[1]\n      }));\n    } else if (modelMaxRaw !== 'dataMax') {\n      this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw);\n    }\n    if (isOrdinal) {\n      // FIXME: there is a flaw here: if there is no \"block\" data processor like `dataZoom`,\n      // and progressive rendering is using, here the category result might just only contain\n      // the processed chunk rather than the entire result.\n      this._axisDataLen = model.getCategories().length;\n    } else {\n      var boundaryGap = model.get('boundaryGap');\n      var boundaryGapArr = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];\n      if (typeof boundaryGapArr[0] === 'boolean' || typeof boundaryGapArr[1] === 'boolean') {\n        if (false) {}\n        this._boundaryGapInner = [0, 0];\n      } else {\n        this._boundaryGapInner = [(0,zrender_lib_contain_text_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(boundaryGapArr[0], 1), (0,zrender_lib_contain_text_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(boundaryGapArr[1], 1)];\n      }\n    }\n  };\n  /**\r\n   * Calculate extent by prepared parameters.\r\n   * This method has no external dependency and can be called duplicatedly,\r\n   * getting the same result.\r\n   * If parameters changed, should call this method to recalcuate.\r\n   */\n  ScaleRawExtentInfo.prototype.calculate = function () {\n    // Notice: When min/max is not set (that is, when there are null/undefined,\n    // which is the most common case), these cases should be ensured:\n    // (1) For 'ordinal', show all axis.data.\n    // (2) For others:\n    //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n    //      disabled).\n    //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n    //      be the result that originalExtent enlarged by boundaryGap.\n    // (3) If no data, it should be ensured that `scale.setBlank` is set.\n    var isOrdinal = this._isOrdinal;\n    var dataMin = this._dataMin;\n    var dataMax = this._dataMax;\n    var axisDataLen = this._axisDataLen;\n    var boundaryGapInner = this._boundaryGapInner;\n    var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;\n    // Currently if a `'value'` axis model min is specified as 'dataMin'/'dataMax',\n    // `boundaryGap` will not be used. It's the different from specifying as `null`/`undefined`.\n    var min = this._modelMinRaw === 'dataMin' ? dataMin : this._modelMinNum;\n    var max = this._modelMaxRaw === 'dataMax' ? dataMax : this._modelMaxNum;\n    // If `_modelMinNum`/`_modelMaxNum` is `null`/`undefined`, should not be fixed.\n    var minFixed = min != null;\n    var maxFixed = max != null;\n    if (min == null) {\n      min = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;\n    }\n    if (max == null) {\n      max = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;\n    }\n    (min == null || !isFinite(min)) && (min = NaN);\n    (max == null || !isFinite(max)) && (max = NaN);\n    var isBlank = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.eqNaN)(min) || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.eqNaN)(max) || isOrdinal && !axisDataLen;\n    // If data extent modified, need to recalculated to ensure cross zero.\n    if (this._needCrossZero) {\n      // Axis is over zero and min is not set\n      if (min > 0 && max > 0 && !minFixed) {\n        min = 0;\n        // minFixed = true;\n      }\n      // Axis is under zero and max is not set\n      if (min < 0 && max < 0 && !maxFixed) {\n        max = 0;\n        // maxFixed = true;\n      }\n      // PENDING:\n      // When `needCrossZero` and all data is positive/negative, should it be ensured\n      // that the results processed by boundaryGap are positive/negative?\n      // If so, here `minFixed`/`maxFixed` need to be set.\n    }\n    var determinedMin = this._determinedMin;\n    var determinedMax = this._determinedMax;\n    if (determinedMin != null) {\n      min = determinedMin;\n      minFixed = true;\n    }\n    if (determinedMax != null) {\n      max = determinedMax;\n      maxFixed = true;\n    }\n    // Ensure min/max be finite number or NaN here. (not to be null/undefined)\n    // `NaN` means min/max axis is blank.\n    return {\n      min: min,\n      max: max,\n      minFixed: minFixed,\n      maxFixed: maxFixed,\n      isBlank: isBlank\n    };\n  };\n  ScaleRawExtentInfo.prototype.modifyDataMinMax = function (minMaxName, val) {\n    if (false) {}\n    this[DATA_MIN_MAX_ATTR[minMaxName]] = val;\n  };\n  ScaleRawExtentInfo.prototype.setDeterminedMinMax = function (minMaxName, val) {\n    var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];\n    if (false) {}\n    this[attr] = val;\n  };\n  ScaleRawExtentInfo.prototype.freeze = function () {\n    // @ts-ignore\n    this.frozen = true;\n  };\n  return ScaleRawExtentInfo;\n}();\n\nvar DETERMINED_MIN_MAX_ATTR = {\n  min: '_determinedMin',\n  max: '_determinedMax'\n};\nvar DATA_MIN_MAX_ATTR = {\n  min: '_dataMin',\n  max: '_dataMax'\n};\n/**\r\n * Get scale min max and related info only depends on model settings.\r\n * This method can be called after coordinate system created.\r\n * For example, in data processing stage.\r\n *\r\n * Scale extent info probably be required multiple times during a workflow.\r\n * For example:\r\n * (1) `dataZoom` depends it to get the axis extent in \"100%\" state.\r\n * (2) `processor/extentCalculator` depends it to make sure whether axis extent is specified.\r\n * (3) `coordSys.update` use it to finally decide the scale extent.\r\n * But the callback of `min`/`max` should not be called multiple times.\r\n * The code below should not be implemented repeatedly either.\r\n * So we cache the result in the scale instance, which will be recreated at the beginning\r\n * of the workflow (because `scale` instance will be recreated each round of the workflow).\r\n */\nfunction ensureScaleRawExtentInfo(scale, model,\n// Usually: data extent from all series on this axis.\noriginalExtent) {\n  // Do not permit to recreate.\n  var rawExtentInfo = scale.rawExtentInfo;\n  if (rawExtentInfo) {\n    return rawExtentInfo;\n  }\n  rawExtentInfo = new ScaleRawExtentInfo(scale, model, originalExtent);\n  // @ts-ignore\n  scale.rawExtentInfo = rawExtentInfo;\n  return rawExtentInfo;\n}\nfunction parseAxisModelMinMax(scale, minMax) {\n  return minMax == null ? null : (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.eqNaN)(minMax) ? NaN : scale.parse(minMax);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIyNjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvc2NhbGVSYXdFeHRlbnRJbmZvLmpzPzU1YzkiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBhc3NlcnQsIGlzQXJyYXksIGVxTmFOLCBpc0Z1bmN0aW9uIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IHBhcnNlUGVyY2VudCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcyc7XG52YXIgU2NhbGVSYXdFeHRlbnRJbmZvID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2NhbGVSYXdFeHRlbnRJbmZvKHNjYWxlLCBtb2RlbCxcbiAgLy8gVXN1YWxseTogZGF0YSBleHRlbnQgZnJvbSBhbGwgc2VyaWVzIG9uIHRoaXMgYXhpcy5cbiAgb3JpZ2luYWxFeHRlbnQpIHtcbiAgICB0aGlzLl9wcmVwYXJlUGFyYW1zKHNjYWxlLCBtb2RlbCwgb3JpZ2luYWxFeHRlbnQpO1xuICB9XG4gIC8qKlxyXG4gICAqIFBhcmFtZXRlcnMgZGVwZW5kaW5nIG9uIG91dHNpZGUgKGxpa2UgbW9kZWwsIHVzZXIgY2FsbGJhY2spXHJcbiAgICogYXJlIHByZXBhcmVkIGFuZCBmaXhlZCBoZXJlLlxyXG4gICAqL1xuICBTY2FsZVJhd0V4dGVudEluZm8ucHJvdG90eXBlLl9wcmVwYXJlUGFyYW1zID0gZnVuY3Rpb24gKHNjYWxlLCBtb2RlbCxcbiAgLy8gVXN1YWxseTogZGF0YSBleHRlbnQgZnJvbSBhbGwgc2VyaWVzIG9uIHRoaXMgYXhpcy5cbiAgZGF0YUV4dGVudCkge1xuICAgIGlmIChkYXRhRXh0ZW50WzFdIDwgZGF0YUV4dGVudFswXSkge1xuICAgICAgZGF0YUV4dGVudCA9IFtOYU4sIE5hTl07XG4gICAgfVxuICAgIHRoaXMuX2RhdGFNaW4gPSBkYXRhRXh0ZW50WzBdO1xuICAgIHRoaXMuX2RhdGFNYXggPSBkYXRhRXh0ZW50WzFdO1xuICAgIHZhciBpc09yZGluYWwgPSB0aGlzLl9pc09yZGluYWwgPSBzY2FsZS50eXBlID09PSAnb3JkaW5hbCc7XG4gICAgdGhpcy5fbmVlZENyb3NzWmVybyA9IHNjYWxlLnR5cGUgPT09ICdpbnRlcnZhbCcgJiYgbW9kZWwuZ2V0TmVlZENyb3NzWmVybyAmJiBtb2RlbC5nZXROZWVkQ3Jvc3NaZXJvKCk7XG4gICAgdmFyIGF4aXNNaW5WYWx1ZSA9IG1vZGVsLmdldCgnbWluJywgdHJ1ZSk7XG4gICAgaWYgKGF4aXNNaW5WYWx1ZSA9PSBudWxsKSB7XG4gICAgICBheGlzTWluVmFsdWUgPSBtb2RlbC5nZXQoJ3N0YXJ0VmFsdWUnLCB0cnVlKTtcbiAgICB9XG4gICAgdmFyIG1vZGVsTWluUmF3ID0gdGhpcy5fbW9kZWxNaW5SYXcgPSBheGlzTWluVmFsdWU7XG4gICAgaWYgKGlzRnVuY3Rpb24obW9kZWxNaW5SYXcpKSB7XG4gICAgICAvLyBUaGlzIGNhbGxiYWNrIGFsd2F5cyBwcm92aWRlcyB1c2VycyB0aGUgZnVsbCBkYXRhIGV4dGVudCAoYmVmb3JlIGRhdGEgaXMgZmlsdGVyZWQpLlxuICAgICAgdGhpcy5fbW9kZWxNaW5OdW0gPSBwYXJzZUF4aXNNb2RlbE1pbk1heChzY2FsZSwgbW9kZWxNaW5SYXcoe1xuICAgICAgICBtaW46IGRhdGFFeHRlbnRbMF0sXG4gICAgICAgIG1heDogZGF0YUV4dGVudFsxXVxuICAgICAgfSkpO1xuICAgIH0gZWxzZSBpZiAobW9kZWxNaW5SYXcgIT09ICdkYXRhTWluJykge1xuICAgICAgdGhpcy5fbW9kZWxNaW5OdW0gPSBwYXJzZUF4aXNNb2RlbE1pbk1heChzY2FsZSwgbW9kZWxNaW5SYXcpO1xuICAgIH1cbiAgICB2YXIgbW9kZWxNYXhSYXcgPSB0aGlzLl9tb2RlbE1heFJhdyA9IG1vZGVsLmdldCgnbWF4JywgdHJ1ZSk7XG4gICAgaWYgKGlzRnVuY3Rpb24obW9kZWxNYXhSYXcpKSB7XG4gICAgICAvLyBUaGlzIGNhbGxiYWNrIGFsd2F5cyBwcm92aWRlcyB1c2VycyB0aGUgZnVsbCBkYXRhIGV4dGVudCAoYmVmb3JlIGRhdGEgaXMgZmlsdGVyZWQpLlxuICAgICAgdGhpcy5fbW9kZWxNYXhOdW0gPSBwYXJzZUF4aXNNb2RlbE1pbk1heChzY2FsZSwgbW9kZWxNYXhSYXcoe1xuICAgICAgICBtaW46IGRhdGFFeHRlbnRbMF0sXG4gICAgICAgIG1heDogZGF0YUV4dGVudFsxXVxuICAgICAgfSkpO1xuICAgIH0gZWxzZSBpZiAobW9kZWxNYXhSYXcgIT09ICdkYXRhTWF4Jykge1xuICAgICAgdGhpcy5fbW9kZWxNYXhOdW0gPSBwYXJzZUF4aXNNb2RlbE1pbk1heChzY2FsZSwgbW9kZWxNYXhSYXcpO1xuICAgIH1cbiAgICBpZiAoaXNPcmRpbmFsKSB7XG4gICAgICAvLyBGSVhNRTogdGhlcmUgaXMgYSBmbGF3IGhlcmU6IGlmIHRoZXJlIGlzIG5vIFwiYmxvY2tcIiBkYXRhIHByb2Nlc3NvciBsaWtlIGBkYXRhWm9vbWAsXG4gICAgICAvLyBhbmQgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIHVzaW5nLCBoZXJlIHRoZSBjYXRlZ29yeSByZXN1bHQgbWlnaHQganVzdCBvbmx5IGNvbnRhaW5cbiAgICAgIC8vIHRoZSBwcm9jZXNzZWQgY2h1bmsgcmF0aGVyIHRoYW4gdGhlIGVudGlyZSByZXN1bHQuXG4gICAgICB0aGlzLl9heGlzRGF0YUxlbiA9IG1vZGVsLmdldENhdGVnb3JpZXMoKS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBib3VuZGFyeUdhcCA9IG1vZGVsLmdldCgnYm91bmRhcnlHYXAnKTtcbiAgICAgIHZhciBib3VuZGFyeUdhcEFyciA9IGlzQXJyYXkoYm91bmRhcnlHYXApID8gYm91bmRhcnlHYXAgOiBbYm91bmRhcnlHYXAgfHwgMCwgYm91bmRhcnlHYXAgfHwgMF07XG4gICAgICBpZiAodHlwZW9mIGJvdW5kYXJ5R2FwQXJyWzBdID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIGJvdW5kYXJ5R2FwQXJyWzFdID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0Jvb2xlYW4gdHlwZSBmb3IgYm91bmRhcnlHYXAgaXMgb25seSAnICsgJ2FsbG93ZWQgZm9yIG9yZGluYWwgYXhpcy4gUGxlYXNlIHVzZSBzdHJpbmcgaW4gJyArICdwZXJjZW50YWdlIGluc3RlYWQsIGUuZy4sIFwiMjAlXCIuIEN1cnJlbnRseSwgJyArICdib3VuZGFyeUdhcCBpcyBzZXQgdG8gYmUgMC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ib3VuZGFyeUdhcElubmVyID0gWzAsIDBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYm91bmRhcnlHYXBJbm5lciA9IFtwYXJzZVBlcmNlbnQoYm91bmRhcnlHYXBBcnJbMF0sIDEpLCBwYXJzZVBlcmNlbnQoYm91bmRhcnlHYXBBcnJbMV0sIDEpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBleHRlbnQgYnkgcHJlcGFyZWQgcGFyYW1ldGVycy5cclxuICAgKiBUaGlzIG1ldGhvZCBoYXMgbm8gZXh0ZXJuYWwgZGVwZW5kZW5jeSBhbmQgY2FuIGJlIGNhbGxlZCBkdXBsaWNhdGVkbHksXHJcbiAgICogZ2V0dGluZyB0aGUgc2FtZSByZXN1bHQuXHJcbiAgICogSWYgcGFyYW1ldGVycyBjaGFuZ2VkLCBzaG91bGQgY2FsbCB0aGlzIG1ldGhvZCB0byByZWNhbGN1YXRlLlxyXG4gICAqL1xuICBTY2FsZVJhd0V4dGVudEluZm8ucHJvdG90eXBlLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBOb3RpY2U6IFdoZW4gbWluL21heCBpcyBub3Qgc2V0ICh0aGF0IGlzLCB3aGVuIHRoZXJlIGFyZSBudWxsL3VuZGVmaW5lZCxcbiAgICAvLyB3aGljaCBpcyB0aGUgbW9zdCBjb21tb24gY2FzZSksIHRoZXNlIGNhc2VzIHNob3VsZCBiZSBlbnN1cmVkOlxuICAgIC8vICgxKSBGb3IgJ29yZGluYWwnLCBzaG93IGFsbCBheGlzLmRhdGEuXG4gICAgLy8gKDIpIEZvciBvdGhlcnM6XG4gICAgLy8gICAgICArIGBib3VuZGFyeUdhcGAgaXMgYXBwbGllZCAoaWYgbWluL21heCBzZXQsIGJvdW5kYXJ5R2FwIGlzXG4gICAgLy8gICAgICBkaXNhYmxlZCkuXG4gICAgLy8gICAgICArIElmIGBuZWVkQ3Jvc3NaZXJvYCwgbWluL21heCBzaG91bGQgYmUgemVybywgb3RoZXJ3aXNlLCBtaW4vbWF4IHNob3VsZFxuICAgIC8vICAgICAgYmUgdGhlIHJlc3VsdCB0aGF0IG9yaWdpbmFsRXh0ZW50IGVubGFyZ2VkIGJ5IGJvdW5kYXJ5R2FwLlxuICAgIC8vICgzKSBJZiBubyBkYXRhLCBpdCBzaG91bGQgYmUgZW5zdXJlZCB0aGF0IGBzY2FsZS5zZXRCbGFua2AgaXMgc2V0LlxuICAgIHZhciBpc09yZGluYWwgPSB0aGlzLl9pc09yZGluYWw7XG4gICAgdmFyIGRhdGFNaW4gPSB0aGlzLl9kYXRhTWluO1xuICAgIHZhciBkYXRhTWF4ID0gdGhpcy5fZGF0YU1heDtcbiAgICB2YXIgYXhpc0RhdGFMZW4gPSB0aGlzLl9heGlzRGF0YUxlbjtcbiAgICB2YXIgYm91bmRhcnlHYXBJbm5lciA9IHRoaXMuX2JvdW5kYXJ5R2FwSW5uZXI7XG4gICAgdmFyIHNwYW4gPSAhaXNPcmRpbmFsID8gZGF0YU1heCAtIGRhdGFNaW4gfHwgTWF0aC5hYnMoZGF0YU1pbikgOiBudWxsO1xuICAgIC8vIEN1cnJlbnRseSBpZiBhIGAndmFsdWUnYCBheGlzIG1vZGVsIG1pbiBpcyBzcGVjaWZpZWQgYXMgJ2RhdGFNaW4nLydkYXRhTWF4JyxcbiAgICAvLyBgYm91bmRhcnlHYXBgIHdpbGwgbm90IGJlIHVzZWQuIEl0J3MgdGhlIGRpZmZlcmVudCBmcm9tIHNwZWNpZnlpbmcgYXMgYG51bGxgL2B1bmRlZmluZWRgLlxuICAgIHZhciBtaW4gPSB0aGlzLl9tb2RlbE1pblJhdyA9PT0gJ2RhdGFNaW4nID8gZGF0YU1pbiA6IHRoaXMuX21vZGVsTWluTnVtO1xuICAgIHZhciBtYXggPSB0aGlzLl9tb2RlbE1heFJhdyA9PT0gJ2RhdGFNYXgnID8gZGF0YU1heCA6IHRoaXMuX21vZGVsTWF4TnVtO1xuICAgIC8vIElmIGBfbW9kZWxNaW5OdW1gL2BfbW9kZWxNYXhOdW1gIGlzIGBudWxsYC9gdW5kZWZpbmVkYCwgc2hvdWxkIG5vdCBiZSBmaXhlZC5cbiAgICB2YXIgbWluRml4ZWQgPSBtaW4gIT0gbnVsbDtcbiAgICB2YXIgbWF4Rml4ZWQgPSBtYXggIT0gbnVsbDtcbiAgICBpZiAobWluID09IG51bGwpIHtcbiAgICAgIG1pbiA9IGlzT3JkaW5hbCA/IGF4aXNEYXRhTGVuID8gMCA6IE5hTiA6IGRhdGFNaW4gLSBib3VuZGFyeUdhcElubmVyWzBdICogc3BhbjtcbiAgICB9XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBpc09yZGluYWwgPyBheGlzRGF0YUxlbiA/IGF4aXNEYXRhTGVuIC0gMSA6IE5hTiA6IGRhdGFNYXggKyBib3VuZGFyeUdhcElubmVyWzFdICogc3BhbjtcbiAgICB9XG4gICAgKG1pbiA9PSBudWxsIHx8ICFpc0Zpbml0ZShtaW4pKSAmJiAobWluID0gTmFOKTtcbiAgICAobWF4ID09IG51bGwgfHwgIWlzRmluaXRlKG1heCkpICYmIChtYXggPSBOYU4pO1xuICAgIHZhciBpc0JsYW5rID0gZXFOYU4obWluKSB8fCBlcU5hTihtYXgpIHx8IGlzT3JkaW5hbCAmJiAhYXhpc0RhdGFMZW47XG4gICAgLy8gSWYgZGF0YSBleHRlbnQgbW9kaWZpZWQsIG5lZWQgdG8gcmVjYWxjdWxhdGVkIHRvIGVuc3VyZSBjcm9zcyB6ZXJvLlxuICAgIGlmICh0aGlzLl9uZWVkQ3Jvc3NaZXJvKSB7XG4gICAgICAvLyBBeGlzIGlzIG92ZXIgemVybyBhbmQgbWluIGlzIG5vdCBzZXRcbiAgICAgIGlmIChtaW4gPiAwICYmIG1heCA+IDAgJiYgIW1pbkZpeGVkKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICAgIC8vIG1pbkZpeGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIEF4aXMgaXMgdW5kZXIgemVybyBhbmQgbWF4IGlzIG5vdCBzZXRcbiAgICAgIGlmIChtaW4gPCAwICYmIG1heCA8IDAgJiYgIW1heEZpeGVkKSB7XG4gICAgICAgIG1heCA9IDA7XG4gICAgICAgIC8vIG1heEZpeGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFBFTkRJTkc6XG4gICAgICAvLyBXaGVuIGBuZWVkQ3Jvc3NaZXJvYCBhbmQgYWxsIGRhdGEgaXMgcG9zaXRpdmUvbmVnYXRpdmUsIHNob3VsZCBpdCBiZSBlbnN1cmVkXG4gICAgICAvLyB0aGF0IHRoZSByZXN1bHRzIHByb2Nlc3NlZCBieSBib3VuZGFyeUdhcCBhcmUgcG9zaXRpdmUvbmVnYXRpdmU/XG4gICAgICAvLyBJZiBzbywgaGVyZSBgbWluRml4ZWRgL2BtYXhGaXhlZGAgbmVlZCB0byBiZSBzZXQuXG4gICAgfVxuICAgIHZhciBkZXRlcm1pbmVkTWluID0gdGhpcy5fZGV0ZXJtaW5lZE1pbjtcbiAgICB2YXIgZGV0ZXJtaW5lZE1heCA9IHRoaXMuX2RldGVybWluZWRNYXg7XG4gICAgaWYgKGRldGVybWluZWRNaW4gIT0gbnVsbCkge1xuICAgICAgbWluID0gZGV0ZXJtaW5lZE1pbjtcbiAgICAgIG1pbkZpeGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRldGVybWluZWRNYXggIT0gbnVsbCkge1xuICAgICAgbWF4ID0gZGV0ZXJtaW5lZE1heDtcbiAgICAgIG1heEZpeGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRW5zdXJlIG1pbi9tYXggYmUgZmluaXRlIG51bWJlciBvciBOYU4gaGVyZS4gKG5vdCB0byBiZSBudWxsL3VuZGVmaW5lZClcbiAgICAvLyBgTmFOYCBtZWFucyBtaW4vbWF4IGF4aXMgaXMgYmxhbmsuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXgsXG4gICAgICBtaW5GaXhlZDogbWluRml4ZWQsXG4gICAgICBtYXhGaXhlZDogbWF4Rml4ZWQsXG4gICAgICBpc0JsYW5rOiBpc0JsYW5rXG4gICAgfTtcbiAgfTtcbiAgU2NhbGVSYXdFeHRlbnRJbmZvLnByb3RvdHlwZS5tb2RpZnlEYXRhTWluTWF4ID0gZnVuY3Rpb24gKG1pbk1heE5hbWUsIHZhbCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQoIXRoaXMuZnJvemVuKTtcbiAgICB9XG4gICAgdGhpc1tEQVRBX01JTl9NQVhfQVRUUlttaW5NYXhOYW1lXV0gPSB2YWw7XG4gIH07XG4gIFNjYWxlUmF3RXh0ZW50SW5mby5wcm90b3R5cGUuc2V0RGV0ZXJtaW5lZE1pbk1heCA9IGZ1bmN0aW9uIChtaW5NYXhOYW1lLCB2YWwpIHtcbiAgICB2YXIgYXR0ciA9IERFVEVSTUlORURfTUlOX01BWF9BVFRSW21pbk1heE5hbWVdO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQoIXRoaXMuZnJvemVuXG4gICAgICAvLyBFYXJzZSB0aGVtIHVzdWFsbHkgbWVhbnMgbG9naWMgZmxhdy5cbiAgICAgICYmIHRoaXNbYXR0cl0gPT0gbnVsbCk7XG4gICAgfVxuICAgIHRoaXNbYXR0cl0gPSB2YWw7XG4gIH07XG4gIFNjYWxlUmF3RXh0ZW50SW5mby5wcm90b3R5cGUuZnJlZXplID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmZyb3plbiA9IHRydWU7XG4gIH07XG4gIHJldHVybiBTY2FsZVJhd0V4dGVudEluZm87XG59KCk7XG5leHBvcnQgeyBTY2FsZVJhd0V4dGVudEluZm8gfTtcbnZhciBERVRFUk1JTkVEX01JTl9NQVhfQVRUUiA9IHtcbiAgbWluOiAnX2RldGVybWluZWRNaW4nLFxuICBtYXg6ICdfZGV0ZXJtaW5lZE1heCdcbn07XG52YXIgREFUQV9NSU5fTUFYX0FUVFIgPSB7XG4gIG1pbjogJ19kYXRhTWluJyxcbiAgbWF4OiAnX2RhdGFNYXgnXG59O1xuLyoqXHJcbiAqIEdldCBzY2FsZSBtaW4gbWF4IGFuZCByZWxhdGVkIGluZm8gb25seSBkZXBlbmRzIG9uIG1vZGVsIHNldHRpbmdzLlxyXG4gKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIGFmdGVyIGNvb3JkaW5hdGUgc3lzdGVtIGNyZWF0ZWQuXHJcbiAqIEZvciBleGFtcGxlLCBpbiBkYXRhIHByb2Nlc3Npbmcgc3RhZ2UuXHJcbiAqXHJcbiAqIFNjYWxlIGV4dGVudCBpbmZvIHByb2JhYmx5IGJlIHJlcXVpcmVkIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhIHdvcmtmbG93LlxyXG4gKiBGb3IgZXhhbXBsZTpcclxuICogKDEpIGBkYXRhWm9vbWAgZGVwZW5kcyBpdCB0byBnZXQgdGhlIGF4aXMgZXh0ZW50IGluIFwiMTAwJVwiIHN0YXRlLlxyXG4gKiAoMikgYHByb2Nlc3Nvci9leHRlbnRDYWxjdWxhdG9yYCBkZXBlbmRzIGl0IHRvIG1ha2Ugc3VyZSB3aGV0aGVyIGF4aXMgZXh0ZW50IGlzIHNwZWNpZmllZC5cclxuICogKDMpIGBjb29yZFN5cy51cGRhdGVgIHVzZSBpdCB0byBmaW5hbGx5IGRlY2lkZSB0aGUgc2NhbGUgZXh0ZW50LlxyXG4gKiBCdXQgdGhlIGNhbGxiYWNrIG9mIGBtaW5gL2BtYXhgIHNob3VsZCBub3QgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxyXG4gKiBUaGUgY29kZSBiZWxvdyBzaG91bGQgbm90IGJlIGltcGxlbWVudGVkIHJlcGVhdGVkbHkgZWl0aGVyLlxyXG4gKiBTbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluIHRoZSBzY2FsZSBpbnN0YW5jZSwgd2hpY2ggd2lsbCBiZSByZWNyZWF0ZWQgYXQgdGhlIGJlZ2lubmluZ1xyXG4gKiBvZiB0aGUgd29ya2Zsb3cgKGJlY2F1c2UgYHNjYWxlYCBpbnN0YW5jZSB3aWxsIGJlIHJlY3JlYXRlZCBlYWNoIHJvdW5kIG9mIHRoZSB3b3JrZmxvdykuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVNjYWxlUmF3RXh0ZW50SW5mbyhzY2FsZSwgbW9kZWwsXG4vLyBVc3VhbGx5OiBkYXRhIGV4dGVudCBmcm9tIGFsbCBzZXJpZXMgb24gdGhpcyBheGlzLlxub3JpZ2luYWxFeHRlbnQpIHtcbiAgLy8gRG8gbm90IHBlcm1pdCB0byByZWNyZWF0ZS5cbiAgdmFyIHJhd0V4dGVudEluZm8gPSBzY2FsZS5yYXdFeHRlbnRJbmZvO1xuICBpZiAocmF3RXh0ZW50SW5mbykge1xuICAgIHJldHVybiByYXdFeHRlbnRJbmZvO1xuICB9XG4gIHJhd0V4dGVudEluZm8gPSBuZXcgU2NhbGVSYXdFeHRlbnRJbmZvKHNjYWxlLCBtb2RlbCwgb3JpZ2luYWxFeHRlbnQpO1xuICAvLyBAdHMtaWdub3JlXG4gIHNjYWxlLnJhd0V4dGVudEluZm8gPSByYXdFeHRlbnRJbmZvO1xuICByZXR1cm4gcmF3RXh0ZW50SW5mbztcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUF4aXNNb2RlbE1pbk1heChzY2FsZSwgbWluTWF4KSB7XG4gIHJldHVybiBtaW5NYXggPT0gbnVsbCA/IG51bGwgOiBlcU5hTihtaW5NYXgpID8gTmFOIDogc2NhbGUucGFyc2UobWluTWF4KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///42262\n")},42506:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ polar_polarCreator)\n});\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/Axis.js\nvar Axis = __webpack_require__(1727);\n;// ./node_modules/echarts/lib/coord/polar/RadiusAxis.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar RadiusAxis = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(RadiusAxis, _super);\n  function RadiusAxis(scale, radiusExtent) {\n    return _super.call(this, 'radius', scale, radiusExtent) || this;\n  }\n  RadiusAxis.prototype.pointToData = function (point, clamp) {\n    return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1];\n  };\n  return RadiusAxis;\n}(Axis/* default */.A);\nRadiusAxis.prototype.dataToRadius = Axis/* default */.A.prototype.dataToCoord;\nRadiusAxis.prototype.radiusToData = Axis/* default */.A.prototype.coordToData;\n/* harmony default export */ const polar_RadiusAxis = (RadiusAxis);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/contain/text.js\nvar contain_text = __webpack_require__(45558);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n;// ./node_modules/echarts/lib/coord/polar/AngleAxis.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar inner = (0,model/* makeInner */.$r)();\nvar AngleAxis = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(AngleAxis, _super);\n  function AngleAxis(scale, angleExtent) {\n    return _super.call(this, 'angle', scale, angleExtent || [0, 360]) || this;\n  }\n  AngleAxis.prototype.pointToData = function (point, clamp) {\n    return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1];\n  };\n  /**\r\n   * Only be called in category axis.\r\n   * Angle axis uses text height to decide interval\r\n   *\r\n   * @override\r\n   * @return {number} Auto interval for cateogry axis tick and label\r\n   */\n  AngleAxis.prototype.calculateCategoryInterval = function () {\n    var axis = this;\n    var labelModel = axis.getLabelModel();\n    var ordinalScale = axis.scale;\n    var ordinalExtent = ordinalScale.getExtent();\n    // Providing this method is for optimization:\n    // avoid generating a long array by `getTicks`\n    // in large category data case.\n    var tickCount = ordinalScale.count();\n    if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n      return 0;\n    }\n    var tickValue = ordinalExtent[0];\n    var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n    var unitH = Math.abs(unitSpan);\n    // Not precise, just use height as text width\n    // and each distance from axis line yet.\n    var rect = contain_text/* getBoundingRect */.NO(tickValue == null ? '' : tickValue + '', labelModel.getFont(), 'center', 'top');\n    var maxH = Math.max(rect.height, 7);\n    var dh = maxH / unitH;\n    // 0/0 is NaN, 1/0 is Infinity.\n    isNaN(dh) && (dh = Infinity);\n    var interval = Math.max(0, Math.floor(dh));\n    var cache = inner(axis.model);\n    var lastAutoInterval = cache.lastAutoInterval;\n    var lastTickCount = cache.lastTickCount;\n    // Use cache to keep interval stable while moving zoom window,\n    // otherwise the calculated interval might jitter when the zoom\n    // window size is close to the interval-changing size.\n    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1\n    // Always choose the bigger one, otherwise the critical\n    // point is not the same when zooming in or zooming out.\n    && lastAutoInterval > interval) {\n      interval = lastAutoInterval;\n    }\n    // Only update cache if cache not used, otherwise the\n    // changing of interval is too insensitive.\n    else {\n      cache.lastTickCount = tickCount;\n      cache.lastAutoInterval = interval;\n    }\n    return interval;\n  };\n  return AngleAxis;\n}(Axis/* default */.A);\nAngleAxis.prototype.dataToAngle = Axis/* default */.A.prototype.dataToCoord;\nAngleAxis.prototype.angleToData = Axis/* default */.A.prototype.coordToData;\n/* harmony default export */ const polar_AngleAxis = (AngleAxis);\n;// ./node_modules/echarts/lib/coord/polar/Polar.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar polarDimensions = ['radius', 'angle'];\nvar Polar = /** @class */function () {\n  function Polar(name) {\n    this.dimensions = polarDimensions;\n    this.type = 'polar';\n    /**\r\n     * x of polar center\r\n     */\n    this.cx = 0;\n    /**\r\n     * y of polar center\r\n     */\n    this.cy = 0;\n    this._radiusAxis = new polar_RadiusAxis();\n    this._angleAxis = new polar_AngleAxis();\n    this.axisPointerEnabled = true;\n    this.name = name || '';\n    this._radiusAxis.polar = this._angleAxis.polar = this;\n  }\n  /**\r\n   * If contain coord\r\n   */\n  Polar.prototype.containPoint = function (point) {\n    var coord = this.pointToCoord(point);\n    return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);\n  };\n  /**\r\n   * If contain data\r\n   */\n  Polar.prototype.containData = function (data) {\n    return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);\n  };\n  Polar.prototype.getAxis = function (dim) {\n    var key = '_' + dim + 'Axis';\n    return this[key];\n  };\n  Polar.prototype.getAxes = function () {\n    return [this._radiusAxis, this._angleAxis];\n  };\n  /**\r\n   * Get axes by type of scale\r\n   */\n  Polar.prototype.getAxesByScale = function (scaleType) {\n    var axes = [];\n    var angleAxis = this._angleAxis;\n    var radiusAxis = this._radiusAxis;\n    angleAxis.scale.type === scaleType && axes.push(angleAxis);\n    radiusAxis.scale.type === scaleType && axes.push(radiusAxis);\n    return axes;\n  };\n  Polar.prototype.getAngleAxis = function () {\n    return this._angleAxis;\n  };\n  Polar.prototype.getRadiusAxis = function () {\n    return this._radiusAxis;\n  };\n  Polar.prototype.getOtherAxis = function (axis) {\n    var angleAxis = this._angleAxis;\n    return axis === angleAxis ? this._radiusAxis : angleAxis;\n  };\n  /**\r\n   * Base axis will be used on stacking.\r\n   *\r\n   */\n  Polar.prototype.getBaseAxis = function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAngleAxis();\n  };\n  Polar.prototype.getTooltipAxes = function (dim) {\n    var baseAxis = dim != null && dim !== 'auto' ? this.getAxis(dim) : this.getBaseAxis();\n    return {\n      baseAxes: [baseAxis],\n      otherAxes: [this.getOtherAxis(baseAxis)]\n    };\n  };\n  /**\r\n   * Convert a single data item to (x, y) point.\r\n   * Parameter data is an array which the first element is radius and the second is angle\r\n   */\n  Polar.prototype.dataToPoint = function (data, clamp) {\n    return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp), this._angleAxis.dataToAngle(data[1], clamp)]);\n  };\n  /**\r\n   * Convert a (x, y) point to data\r\n   */\n  Polar.prototype.pointToData = function (point, clamp) {\n    var coord = this.pointToCoord(point);\n    return [this._radiusAxis.radiusToData(coord[0], clamp), this._angleAxis.angleToData(coord[1], clamp)];\n  };\n  /**\r\n   * Convert a (x, y) point to (radius, angle) coord\r\n   */\n  Polar.prototype.pointToCoord = function (point) {\n    var dx = point[0] - this.cx;\n    var dy = point[1] - this.cy;\n    var angleAxis = this.getAngleAxis();\n    var extent = angleAxis.getExtent();\n    var minAngle = Math.min(extent[0], extent[1]);\n    var maxAngle = Math.max(extent[0], extent[1]);\n    // Fix fixed extent in polarCreator\n    // FIXME\n    angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;\n    var radius = Math.sqrt(dx * dx + dy * dy);\n    dx /= radius;\n    dy /= radius;\n    var radian = Math.atan2(-dy, dx) / Math.PI * 180;\n    // move to angleExtent\n    var dir = radian < minAngle ? 1 : -1;\n    while (radian < minAngle || radian > maxAngle) {\n      radian += dir * 360;\n    }\n    return [radius, radian];\n  };\n  /**\r\n   * Convert a (radius, angle) coord to (x, y) point\r\n   */\n  Polar.prototype.coordToPoint = function (coord) {\n    var radius = coord[0];\n    var radian = coord[1] / 180 * Math.PI;\n    var x = Math.cos(radian) * radius + this.cx;\n    // Inverse the y\n    var y = -Math.sin(radian) * radius + this.cy;\n    return [x, y];\n  };\n  /**\r\n   * Get ring area of cartesian.\r\n   * Area will have a contain function to determine if a point is in the coordinate system.\r\n   */\n  Polar.prototype.getArea = function () {\n    var angleAxis = this.getAngleAxis();\n    var radiusAxis = this.getRadiusAxis();\n    var radiusExtent = radiusAxis.getExtent().slice();\n    radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();\n    var angleExtent = angleAxis.getExtent();\n    var RADIAN = Math.PI / 180;\n    var EPSILON = 1e-4;\n    return {\n      cx: this.cx,\n      cy: this.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse,\n      contain: function (x, y) {\n        // It's a ring shape.\n        // Start angle and end angle don't matter\n        var dx = x - this.cx;\n        var dy = y - this.cy;\n        var d2 = dx * dx + dy * dy;\n        var r = this.r;\n        var r0 = this.r0;\n        // minus a tiny value 1e-4 in double side to avoid being clipped unexpectedly\n        // r == r0 contain nothing\n        return r !== r0 && d2 - EPSILON <= r * r && d2 + EPSILON >= r0 * r0;\n      }\n    };\n  };\n  Polar.prototype.convertToPixel = function (ecModel, finder, value) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? this.dataToPoint(value) : null;\n  };\n  Polar.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? this.pointToData(pixel) : null;\n  };\n  return Polar;\n}();\nfunction getCoordSys(finder) {\n  var seriesModel = finder.seriesModel;\n  var polarModel = finder.polarModel;\n  return polarModel && polarModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;\n}\n/* harmony default export */ const polar_Polar = (Polar);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/axisHelper.js\nvar axisHelper = __webpack_require__(99031);\n;// ./node_modules/echarts/lib/coord/polar/polarCreator.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// TODO Axis scale\n\n\n\n\n\n/**\r\n * Resize method bound to the polar\r\n */\nfunction resizePolar(polar, polarModel, api) {\n  var center = polarModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  polar.cx = (0,number/* parsePercent */.lo)(center[0], width);\n  polar.cy = (0,number/* parsePercent */.lo)(center[1], height);\n  var radiusAxis = polar.getRadiusAxis();\n  var size = Math.min(width, height) / 2;\n  var radius = polarModel.get('radius');\n  if (radius == null) {\n    radius = [0, '100%'];\n  } else if (!util.isArray(radius)) {\n    // r0 = 0\n    radius = [0, radius];\n  }\n  var parsedRadius = [(0,number/* parsePercent */.lo)(radius[0], size), (0,number/* parsePercent */.lo)(radius[1], size)];\n  radiusAxis.inverse ? radiusAxis.setExtent(parsedRadius[1], parsedRadius[0]) : radiusAxis.setExtent(parsedRadius[0], parsedRadius[1]);\n}\n/**\r\n * Update polar\r\n */\nfunction updatePolarScale(ecModel, api) {\n  var polar = this;\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  // Reset scale\n  angleAxis.scale.setExtent(Infinity, -Infinity);\n  radiusAxis.scale.setExtent(Infinity, -Infinity);\n  ecModel.eachSeries(function (seriesModel) {\n    if (seriesModel.coordinateSystem === polar) {\n      var data_1 = seriesModel.getData();\n      util.each((0,axisHelper/* getDataDimensionsOnAxis */.wq)(data_1, 'radius'), function (dim) {\n        radiusAxis.scale.unionExtentFromData(data_1, dim);\n      });\n      util.each((0,axisHelper/* getDataDimensionsOnAxis */.wq)(data_1, 'angle'), function (dim) {\n        angleAxis.scale.unionExtentFromData(data_1, dim);\n      });\n    }\n  });\n  (0,axisHelper/* niceScaleExtent */.af)(angleAxis.scale, angleAxis.model);\n  (0,axisHelper/* niceScaleExtent */.af)(radiusAxis.scale, radiusAxis.model);\n  // Fix extent of category angle axis\n  if (angleAxis.type === 'category' && !angleAxis.onBand) {\n    var extent = angleAxis.getExtent();\n    var diff = 360 / angleAxis.scale.count();\n    angleAxis.inverse ? extent[1] += diff : extent[1] -= diff;\n    angleAxis.setExtent(extent[0], extent[1]);\n  }\n}\nfunction isAngleAxisModel(axisModel) {\n  return axisModel.mainType === 'angleAxis';\n}\n/**\r\n * Set common axis properties\r\n */\nfunction setAxis(axis, axisModel) {\n  var _a;\n  axis.type = axisModel.get('type');\n  axis.scale = (0,axisHelper/* createScaleByModel */.f$)(axisModel);\n  axis.onBand = axisModel.get('boundaryGap') && axis.type === 'category';\n  axis.inverse = axisModel.get('inverse');\n  if (isAngleAxisModel(axisModel)) {\n    axis.inverse = axis.inverse !== axisModel.get('clockwise');\n    var startAngle = axisModel.get('startAngle');\n    var endAngle = (_a = axisModel.get('endAngle')) !== null && _a !== void 0 ? _a : startAngle + (axis.inverse ? -360 : 360);\n    axis.setExtent(startAngle, endAngle);\n  }\n  // Inject axis instance\n  axisModel.axis = axis;\n  axis.model = axisModel;\n}\nvar polarCreator = {\n  dimensions: polarDimensions,\n  create: function (ecModel, api) {\n    var polarList = [];\n    ecModel.eachComponent('polar', function (polarModel, idx) {\n      var polar = new polar_Polar(idx + '');\n      // Inject resize and update method\n      polar.update = updatePolarScale;\n      var radiusAxis = polar.getRadiusAxis();\n      var angleAxis = polar.getAngleAxis();\n      var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n      var angleAxisModel = polarModel.findAxisModel('angleAxis');\n      setAxis(radiusAxis, radiusAxisModel);\n      setAxis(angleAxis, angleAxisModel);\n      resizePolar(polar, polarModel, api);\n      polarList.push(polar);\n      polarModel.coordinateSystem = polar;\n      polar.model = polarModel;\n    });\n    // Inject coordinateSystem to series\n    ecModel.eachSeries(function (seriesModel) {\n      if (seriesModel.get('coordinateSystem') === 'polar') {\n        var polarModel = seriesModel.getReferringComponents('polar', model/* SINGLE_REFERRING */.US).models[0];\n        if (false) {}\n        seriesModel.coordinateSystem = polarModel.coordinateSystem;\n      }\n    });\n    return polarList;\n  }\n};\n/* harmony default export */ const polar_polarCreator = (polarCreator);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI1MDYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvcG9sYXIvUmFkaXVzQXhpcy5qcz85NzdmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9wb2xhci9BbmdsZUF4aXMuanM/YzUwNSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvcG9sYXIvUG9sYXIuanM/MWIwYSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvcG9sYXIvcG9sYXJDcmVhdG9yLmpzPzE4MjEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBBeGlzIGZyb20gJy4uL0F4aXMuanMnO1xudmFyIFJhZGl1c0F4aXMgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUmFkaXVzQXhpcywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gUmFkaXVzQXhpcyhzY2FsZSwgcmFkaXVzRXh0ZW50KSB7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdyYWRpdXMnLCBzY2FsZSwgcmFkaXVzRXh0ZW50KSB8fCB0aGlzO1xuICB9XG4gIFJhZGl1c0F4aXMucHJvdG90eXBlLnBvaW50VG9EYXRhID0gZnVuY3Rpb24gKHBvaW50LCBjbGFtcCkge1xuICAgIHJldHVybiB0aGlzLnBvbGFyLnBvaW50VG9EYXRhKHBvaW50LCBjbGFtcClbdGhpcy5kaW0gPT09ICdyYWRpdXMnID8gMCA6IDFdO1xuICB9O1xuICByZXR1cm4gUmFkaXVzQXhpcztcbn0oQXhpcyk7XG5SYWRpdXNBeGlzLnByb3RvdHlwZS5kYXRhVG9SYWRpdXMgPSBBeGlzLnByb3RvdHlwZS5kYXRhVG9Db29yZDtcblJhZGl1c0F4aXMucHJvdG90eXBlLnJhZGl1c1RvRGF0YSA9IEF4aXMucHJvdG90eXBlLmNvb3JkVG9EYXRhO1xuZXhwb3J0IGRlZmF1bHQgUmFkaXVzQXhpczsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgdGV4dENvbnRhaW4gZnJvbSAnenJlbmRlci9saWIvY29udGFpbi90ZXh0LmpzJztcbmltcG9ydCBBeGlzIGZyb20gJy4uL0F4aXMuanMnO1xuaW1wb3J0IHsgbWFrZUlubmVyIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbnZhciBBbmdsZUF4aXMgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQW5nbGVBeGlzLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBBbmdsZUF4aXMoc2NhbGUsIGFuZ2xlRXh0ZW50KSB7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdhbmdsZScsIHNjYWxlLCBhbmdsZUV4dGVudCB8fCBbMCwgMzYwXSkgfHwgdGhpcztcbiAgfVxuICBBbmdsZUF4aXMucHJvdG90eXBlLnBvaW50VG9EYXRhID0gZnVuY3Rpb24gKHBvaW50LCBjbGFtcCkge1xuICAgIHJldHVybiB0aGlzLnBvbGFyLnBvaW50VG9EYXRhKHBvaW50LCBjbGFtcClbdGhpcy5kaW0gPT09ICdyYWRpdXMnID8gMCA6IDFdO1xuICB9O1xuICAvKipcclxuICAgKiBPbmx5IGJlIGNhbGxlZCBpbiBjYXRlZ29yeSBheGlzLlxyXG4gICAqIEFuZ2xlIGF4aXMgdXNlcyB0ZXh0IGhlaWdodCB0byBkZWNpZGUgaW50ZXJ2YWxcclxuICAgKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gQXV0byBpbnRlcnZhbCBmb3IgY2F0ZW9ncnkgYXhpcyB0aWNrIGFuZCBsYWJlbFxyXG4gICAqL1xuICBBbmdsZUF4aXMucHJvdG90eXBlLmNhbGN1bGF0ZUNhdGVnb3J5SW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF4aXMgPSB0aGlzO1xuICAgIHZhciBsYWJlbE1vZGVsID0gYXhpcy5nZXRMYWJlbE1vZGVsKCk7XG4gICAgdmFyIG9yZGluYWxTY2FsZSA9IGF4aXMuc2NhbGU7XG4gICAgdmFyIG9yZGluYWxFeHRlbnQgPSBvcmRpbmFsU2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgLy8gUHJvdmlkaW5nIHRoaXMgbWV0aG9kIGlzIGZvciBvcHRpbWl6YXRpb246XG4gICAgLy8gYXZvaWQgZ2VuZXJhdGluZyBhIGxvbmcgYXJyYXkgYnkgYGdldFRpY2tzYFxuICAgIC8vIGluIGxhcmdlIGNhdGVnb3J5IGRhdGEgY2FzZS5cbiAgICB2YXIgdGlja0NvdW50ID0gb3JkaW5hbFNjYWxlLmNvdW50KCk7XG4gICAgaWYgKG9yZGluYWxFeHRlbnRbMV0gLSBvcmRpbmFsRXh0ZW50WzBdIDwgMSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciB0aWNrVmFsdWUgPSBvcmRpbmFsRXh0ZW50WzBdO1xuICAgIHZhciB1bml0U3BhbiA9IGF4aXMuZGF0YVRvQ29vcmQodGlja1ZhbHVlICsgMSkgLSBheGlzLmRhdGFUb0Nvb3JkKHRpY2tWYWx1ZSk7XG4gICAgdmFyIHVuaXRIID0gTWF0aC5hYnModW5pdFNwYW4pO1xuICAgIC8vIE5vdCBwcmVjaXNlLCBqdXN0IHVzZSBoZWlnaHQgYXMgdGV4dCB3aWR0aFxuICAgIC8vIGFuZCBlYWNoIGRpc3RhbmNlIGZyb20gYXhpcyBsaW5lIHlldC5cbiAgICB2YXIgcmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdCh0aWNrVmFsdWUgPT0gbnVsbCA/ICcnIDogdGlja1ZhbHVlICsgJycsIGxhYmVsTW9kZWwuZ2V0Rm9udCgpLCAnY2VudGVyJywgJ3RvcCcpO1xuICAgIHZhciBtYXhIID0gTWF0aC5tYXgocmVjdC5oZWlnaHQsIDcpO1xuICAgIHZhciBkaCA9IG1heEggLyB1bml0SDtcbiAgICAvLyAwLzAgaXMgTmFOLCAxLzAgaXMgSW5maW5pdHkuXG4gICAgaXNOYU4oZGgpICYmIChkaCA9IEluZmluaXR5KTtcbiAgICB2YXIgaW50ZXJ2YWwgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKGRoKSk7XG4gICAgdmFyIGNhY2hlID0gaW5uZXIoYXhpcy5tb2RlbCk7XG4gICAgdmFyIGxhc3RBdXRvSW50ZXJ2YWwgPSBjYWNoZS5sYXN0QXV0b0ludGVydmFsO1xuICAgIHZhciBsYXN0VGlja0NvdW50ID0gY2FjaGUubGFzdFRpY2tDb3VudDtcbiAgICAvLyBVc2UgY2FjaGUgdG8ga2VlcCBpbnRlcnZhbCBzdGFibGUgd2hpbGUgbW92aW5nIHpvb20gd2luZG93LFxuICAgIC8vIG90aGVyd2lzZSB0aGUgY2FsY3VsYXRlZCBpbnRlcnZhbCBtaWdodCBqaXR0ZXIgd2hlbiB0aGUgem9vbVxuICAgIC8vIHdpbmRvdyBzaXplIGlzIGNsb3NlIHRvIHRoZSBpbnRlcnZhbC1jaGFuZ2luZyBzaXplLlxuICAgIGlmIChsYXN0QXV0b0ludGVydmFsICE9IG51bGwgJiYgbGFzdFRpY2tDb3VudCAhPSBudWxsICYmIE1hdGguYWJzKGxhc3RBdXRvSW50ZXJ2YWwgLSBpbnRlcnZhbCkgPD0gMSAmJiBNYXRoLmFicyhsYXN0VGlja0NvdW50IC0gdGlja0NvdW50KSA8PSAxXG4gICAgLy8gQWx3YXlzIGNob29zZSB0aGUgYmlnZ2VyIG9uZSwgb3RoZXJ3aXNlIHRoZSBjcml0aWNhbFxuICAgIC8vIHBvaW50IGlzIG5vdCB0aGUgc2FtZSB3aGVuIHpvb21pbmcgaW4gb3Igem9vbWluZyBvdXQuXG4gICAgJiYgbGFzdEF1dG9JbnRlcnZhbCA+IGludGVydmFsKSB7XG4gICAgICBpbnRlcnZhbCA9IGxhc3RBdXRvSW50ZXJ2YWw7XG4gICAgfVxuICAgIC8vIE9ubHkgdXBkYXRlIGNhY2hlIGlmIGNhY2hlIG5vdCB1c2VkLCBvdGhlcndpc2UgdGhlXG4gICAgLy8gY2hhbmdpbmcgb2YgaW50ZXJ2YWwgaXMgdG9vIGluc2Vuc2l0aXZlLlxuICAgIGVsc2Uge1xuICAgICAgY2FjaGUubGFzdFRpY2tDb3VudCA9IHRpY2tDb3VudDtcbiAgICAgIGNhY2hlLmxhc3RBdXRvSW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGludGVydmFsO1xuICB9O1xuICByZXR1cm4gQW5nbGVBeGlzO1xufShBeGlzKTtcbkFuZ2xlQXhpcy5wcm90b3R5cGUuZGF0YVRvQW5nbGUgPSBBeGlzLnByb3RvdHlwZS5kYXRhVG9Db29yZDtcbkFuZ2xlQXhpcy5wcm90b3R5cGUuYW5nbGVUb0RhdGEgPSBBeGlzLnByb3RvdHlwZS5jb29yZFRvRGF0YTtcbmV4cG9ydCBkZWZhdWx0IEFuZ2xlQXhpczsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBSYWRpdXNBeGlzIGZyb20gJy4vUmFkaXVzQXhpcy5qcyc7XG5pbXBvcnQgQW5nbGVBeGlzIGZyb20gJy4vQW5nbGVBeGlzLmpzJztcbmV4cG9ydCB2YXIgcG9sYXJEaW1lbnNpb25zID0gWydyYWRpdXMnLCAnYW5nbGUnXTtcbnZhciBQb2xhciA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBvbGFyKG5hbWUpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBwb2xhckRpbWVuc2lvbnM7XG4gICAgdGhpcy50eXBlID0gJ3BvbGFyJztcbiAgICAvKipcclxuICAgICAqIHggb2YgcG9sYXIgY2VudGVyXHJcbiAgICAgKi9cbiAgICB0aGlzLmN4ID0gMDtcbiAgICAvKipcclxuICAgICAqIHkgb2YgcG9sYXIgY2VudGVyXHJcbiAgICAgKi9cbiAgICB0aGlzLmN5ID0gMDtcbiAgICB0aGlzLl9yYWRpdXNBeGlzID0gbmV3IFJhZGl1c0F4aXMoKTtcbiAgICB0aGlzLl9hbmdsZUF4aXMgPSBuZXcgQW5nbGVBeGlzKCk7XG4gICAgdGhpcy5heGlzUG9pbnRlckVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgJyc7XG4gICAgdGhpcy5fcmFkaXVzQXhpcy5wb2xhciA9IHRoaXMuX2FuZ2xlQXhpcy5wb2xhciA9IHRoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogSWYgY29udGFpbiBjb29yZFxyXG4gICAqL1xuICBQb2xhci5wcm90b3R5cGUuY29udGFpblBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgdmFyIGNvb3JkID0gdGhpcy5wb2ludFRvQ29vcmQocG9pbnQpO1xuICAgIHJldHVybiB0aGlzLl9yYWRpdXNBeGlzLmNvbnRhaW4oY29vcmRbMF0pICYmIHRoaXMuX2FuZ2xlQXhpcy5jb250YWluKGNvb3JkWzFdKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogSWYgY29udGFpbiBkYXRhXHJcbiAgICovXG4gIFBvbGFyLnByb3RvdHlwZS5jb250YWluRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JhZGl1c0F4aXMuY29udGFpbkRhdGEoZGF0YVswXSkgJiYgdGhpcy5fYW5nbGVBeGlzLmNvbnRhaW5EYXRhKGRhdGFbMV0pO1xuICB9O1xuICBQb2xhci5wcm90b3R5cGUuZ2V0QXhpcyA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgICB2YXIga2V5ID0gJ18nICsgZGltICsgJ0F4aXMnO1xuICAgIHJldHVybiB0aGlzW2tleV07XG4gIH07XG4gIFBvbGFyLnByb3RvdHlwZS5nZXRBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbdGhpcy5fcmFkaXVzQXhpcywgdGhpcy5fYW5nbGVBeGlzXTtcbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IGF4ZXMgYnkgdHlwZSBvZiBzY2FsZVxyXG4gICAqL1xuICBQb2xhci5wcm90b3R5cGUuZ2V0QXhlc0J5U2NhbGUgPSBmdW5jdGlvbiAoc2NhbGVUeXBlKSB7XG4gICAgdmFyIGF4ZXMgPSBbXTtcbiAgICB2YXIgYW5nbGVBeGlzID0gdGhpcy5fYW5nbGVBeGlzO1xuICAgIHZhciByYWRpdXNBeGlzID0gdGhpcy5fcmFkaXVzQXhpcztcbiAgICBhbmdsZUF4aXMuc2NhbGUudHlwZSA9PT0gc2NhbGVUeXBlICYmIGF4ZXMucHVzaChhbmdsZUF4aXMpO1xuICAgIHJhZGl1c0F4aXMuc2NhbGUudHlwZSA9PT0gc2NhbGVUeXBlICYmIGF4ZXMucHVzaChyYWRpdXNBeGlzKTtcbiAgICByZXR1cm4gYXhlcztcbiAgfTtcbiAgUG9sYXIucHJvdG90eXBlLmdldEFuZ2xlQXhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYW5nbGVBeGlzO1xuICB9O1xuICBQb2xhci5wcm90b3R5cGUuZ2V0UmFkaXVzQXhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmFkaXVzQXhpcztcbiAgfTtcbiAgUG9sYXIucHJvdG90eXBlLmdldE90aGVyQXhpcyA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgdmFyIGFuZ2xlQXhpcyA9IHRoaXMuX2FuZ2xlQXhpcztcbiAgICByZXR1cm4gYXhpcyA9PT0gYW5nbGVBeGlzID8gdGhpcy5fcmFkaXVzQXhpcyA6IGFuZ2xlQXhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQmFzZSBheGlzIHdpbGwgYmUgdXNlZCBvbiBzdGFja2luZy5cclxuICAgKlxyXG4gICAqL1xuICBQb2xhci5wcm90b3R5cGUuZ2V0QmFzZUF4aXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXhlc0J5U2NhbGUoJ29yZGluYWwnKVswXSB8fCB0aGlzLmdldEF4ZXNCeVNjYWxlKCd0aW1lJylbMF0gfHwgdGhpcy5nZXRBbmdsZUF4aXMoKTtcbiAgfTtcbiAgUG9sYXIucHJvdG90eXBlLmdldFRvb2x0aXBBeGVzID0gZnVuY3Rpb24gKGRpbSkge1xuICAgIHZhciBiYXNlQXhpcyA9IGRpbSAhPSBudWxsICYmIGRpbSAhPT0gJ2F1dG8nID8gdGhpcy5nZXRBeGlzKGRpbSkgOiB0aGlzLmdldEJhc2VBeGlzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2VBeGVzOiBbYmFzZUF4aXNdLFxuICAgICAgb3RoZXJBeGVzOiBbdGhpcy5nZXRPdGhlckF4aXMoYmFzZUF4aXMpXVxuICAgIH07XG4gIH07XG4gIC8qKlxyXG4gICAqIENvbnZlcnQgYSBzaW5nbGUgZGF0YSBpdGVtIHRvICh4LCB5KSBwb2ludC5cclxuICAgKiBQYXJhbWV0ZXIgZGF0YSBpcyBhbiBhcnJheSB3aGljaCB0aGUgZmlyc3QgZWxlbWVudCBpcyByYWRpdXMgYW5kIHRoZSBzZWNvbmQgaXMgYW5nbGVcclxuICAgKi9cbiAgUG9sYXIucHJvdG90eXBlLmRhdGFUb1BvaW50ID0gZnVuY3Rpb24gKGRhdGEsIGNsYW1wKSB7XG4gICAgcmV0dXJuIHRoaXMuY29vcmRUb1BvaW50KFt0aGlzLl9yYWRpdXNBeGlzLmRhdGFUb1JhZGl1cyhkYXRhWzBdLCBjbGFtcCksIHRoaXMuX2FuZ2xlQXhpcy5kYXRhVG9BbmdsZShkYXRhWzFdLCBjbGFtcCldKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ29udmVydCBhICh4LCB5KSBwb2ludCB0byBkYXRhXHJcbiAgICovXG4gIFBvbGFyLnByb3RvdHlwZS5wb2ludFRvRGF0YSA9IGZ1bmN0aW9uIChwb2ludCwgY2xhbXApIHtcbiAgICB2YXIgY29vcmQgPSB0aGlzLnBvaW50VG9Db29yZChwb2ludCk7XG4gICAgcmV0dXJuIFt0aGlzLl9yYWRpdXNBeGlzLnJhZGl1c1RvRGF0YShjb29yZFswXSwgY2xhbXApLCB0aGlzLl9hbmdsZUF4aXMuYW5nbGVUb0RhdGEoY29vcmRbMV0sIGNsYW1wKV07XG4gIH07XG4gIC8qKlxyXG4gICAqIENvbnZlcnQgYSAoeCwgeSkgcG9pbnQgdG8gKHJhZGl1cywgYW5nbGUpIGNvb3JkXHJcbiAgICovXG4gIFBvbGFyLnByb3RvdHlwZS5wb2ludFRvQ29vcmQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgZHggPSBwb2ludFswXSAtIHRoaXMuY3g7XG4gICAgdmFyIGR5ID0gcG9pbnRbMV0gLSB0aGlzLmN5O1xuICAgIHZhciBhbmdsZUF4aXMgPSB0aGlzLmdldEFuZ2xlQXhpcygpO1xuICAgIHZhciBleHRlbnQgPSBhbmdsZUF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIG1pbkFuZ2xlID0gTWF0aC5taW4oZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICAgIHZhciBtYXhBbmdsZSA9IE1hdGgubWF4KGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICAvLyBGaXggZml4ZWQgZXh0ZW50IGluIHBvbGFyQ3JlYXRvclxuICAgIC8vIEZJWE1FXG4gICAgYW5nbGVBeGlzLmludmVyc2UgPyBtaW5BbmdsZSA9IG1heEFuZ2xlIC0gMzYwIDogbWF4QW5nbGUgPSBtaW5BbmdsZSArIDM2MDtcbiAgICB2YXIgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICBkeCAvPSByYWRpdXM7XG4gICAgZHkgLz0gcmFkaXVzO1xuICAgIHZhciByYWRpYW4gPSBNYXRoLmF0YW4yKC1keSwgZHgpIC8gTWF0aC5QSSAqIDE4MDtcbiAgICAvLyBtb3ZlIHRvIGFuZ2xlRXh0ZW50XG4gICAgdmFyIGRpciA9IHJhZGlhbiA8IG1pbkFuZ2xlID8gMSA6IC0xO1xuICAgIHdoaWxlIChyYWRpYW4gPCBtaW5BbmdsZSB8fCByYWRpYW4gPiBtYXhBbmdsZSkge1xuICAgICAgcmFkaWFuICs9IGRpciAqIDM2MDtcbiAgICB9XG4gICAgcmV0dXJuIFtyYWRpdXMsIHJhZGlhbl07XG4gIH07XG4gIC8qKlxyXG4gICAqIENvbnZlcnQgYSAocmFkaXVzLCBhbmdsZSkgY29vcmQgdG8gKHgsIHkpIHBvaW50XHJcbiAgICovXG4gIFBvbGFyLnByb3RvdHlwZS5jb29yZFRvUG9pbnQgPSBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICB2YXIgcmFkaXVzID0gY29vcmRbMF07XG4gICAgdmFyIHJhZGlhbiA9IGNvb3JkWzFdIC8gMTgwICogTWF0aC5QSTtcbiAgICB2YXIgeCA9IE1hdGguY29zKHJhZGlhbikgKiByYWRpdXMgKyB0aGlzLmN4O1xuICAgIC8vIEludmVyc2UgdGhlIHlcbiAgICB2YXIgeSA9IC1NYXRoLnNpbihyYWRpYW4pICogcmFkaXVzICsgdGhpcy5jeTtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgcmluZyBhcmVhIG9mIGNhcnRlc2lhbi5cclxuICAgKiBBcmVhIHdpbGwgaGF2ZSBhIGNvbnRhaW4gZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGEgcG9pbnQgaXMgaW4gdGhlIGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAqL1xuICBQb2xhci5wcm90b3R5cGUuZ2V0QXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYW5nbGVBeGlzID0gdGhpcy5nZXRBbmdsZUF4aXMoKTtcbiAgICB2YXIgcmFkaXVzQXhpcyA9IHRoaXMuZ2V0UmFkaXVzQXhpcygpO1xuICAgIHZhciByYWRpdXNFeHRlbnQgPSByYWRpdXNBeGlzLmdldEV4dGVudCgpLnNsaWNlKCk7XG4gICAgcmFkaXVzRXh0ZW50WzBdID4gcmFkaXVzRXh0ZW50WzFdICYmIHJhZGl1c0V4dGVudC5yZXZlcnNlKCk7XG4gICAgdmFyIGFuZ2xlRXh0ZW50ID0gYW5nbGVBeGlzLmdldEV4dGVudCgpO1xuICAgIHZhciBSQURJQU4gPSBNYXRoLlBJIC8gMTgwO1xuICAgIHZhciBFUFNJTE9OID0gMWUtNDtcbiAgICByZXR1cm4ge1xuICAgICAgY3g6IHRoaXMuY3gsXG4gICAgICBjeTogdGhpcy5jeSxcbiAgICAgIHIwOiByYWRpdXNFeHRlbnRbMF0sXG4gICAgICByOiByYWRpdXNFeHRlbnRbMV0sXG4gICAgICBzdGFydEFuZ2xlOiAtYW5nbGVFeHRlbnRbMF0gKiBSQURJQU4sXG4gICAgICBlbmRBbmdsZTogLWFuZ2xlRXh0ZW50WzFdICogUkFESUFOLFxuICAgICAgY2xvY2t3aXNlOiBhbmdsZUF4aXMuaW52ZXJzZSxcbiAgICAgIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIC8vIEl0J3MgYSByaW5nIHNoYXBlLlxuICAgICAgICAvLyBTdGFydCBhbmdsZSBhbmQgZW5kIGFuZ2xlIGRvbid0IG1hdHRlclxuICAgICAgICB2YXIgZHggPSB4IC0gdGhpcy5jeDtcbiAgICAgICAgdmFyIGR5ID0geSAtIHRoaXMuY3k7XG4gICAgICAgIHZhciBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICB2YXIgciA9IHRoaXMucjtcbiAgICAgICAgdmFyIHIwID0gdGhpcy5yMDtcbiAgICAgICAgLy8gbWludXMgYSB0aW55IHZhbHVlIDFlLTQgaW4gZG91YmxlIHNpZGUgdG8gYXZvaWQgYmVpbmcgY2xpcHBlZCB1bmV4cGVjdGVkbHlcbiAgICAgICAgLy8gciA9PSByMCBjb250YWluIG5vdGhpbmdcbiAgICAgICAgcmV0dXJuIHIgIT09IHIwICYmIGQyIC0gRVBTSUxPTiA8PSByICogciAmJiBkMiArIEVQU0lMT04gPj0gcjAgKiByMDtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBQb2xhci5wcm90b3R5cGUuY29udmVydFRvUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkge1xuICAgIHZhciBjb29yZFN5cyA9IGdldENvb3JkU3lzKGZpbmRlcik7XG4gICAgcmV0dXJuIGNvb3JkU3lzID09PSB0aGlzID8gdGhpcy5kYXRhVG9Qb2ludCh2YWx1ZSkgOiBudWxsO1xuICB9O1xuICBQb2xhci5wcm90b3R5cGUuY29udmVydEZyb21QaXhlbCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIsIHBpeGVsKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gZ2V0Q29vcmRTeXMoZmluZGVyKTtcbiAgICByZXR1cm4gY29vcmRTeXMgPT09IHRoaXMgPyB0aGlzLnBvaW50VG9EYXRhKHBpeGVsKSA6IG51bGw7XG4gIH07XG4gIHJldHVybiBQb2xhcjtcbn0oKTtcbmZ1bmN0aW9uIGdldENvb3JkU3lzKGZpbmRlcikge1xuICB2YXIgc2VyaWVzTW9kZWwgPSBmaW5kZXIuc2VyaWVzTW9kZWw7XG4gIHZhciBwb2xhck1vZGVsID0gZmluZGVyLnBvbGFyTW9kZWw7XG4gIHJldHVybiBwb2xhck1vZGVsICYmIHBvbGFyTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSB8fCBzZXJpZXNNb2RlbCAmJiBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xufVxuZXhwb3J0IGRlZmF1bHQgUG9sYXI7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG4vLyBUT0RPIEF4aXMgc2NhbGVcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IFBvbGFyLCB7IHBvbGFyRGltZW5zaW9ucyB9IGZyb20gJy4vUG9sYXIuanMnO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50IH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlU2NhbGVCeU1vZGVsLCBuaWNlU2NhbGVFeHRlbnQsIGdldERhdGFEaW1lbnNpb25zT25BeGlzIH0gZnJvbSAnLi4vLi4vY29vcmQvYXhpc0hlbHBlci5qcyc7XG5pbXBvcnQgeyBTSU5HTEVfUkVGRVJSSU5HIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG4vKipcclxuICogUmVzaXplIG1ldGhvZCBib3VuZCB0byB0aGUgcG9sYXJcclxuICovXG5mdW5jdGlvbiByZXNpemVQb2xhcihwb2xhciwgcG9sYXJNb2RlbCwgYXBpKSB7XG4gIHZhciBjZW50ZXIgPSBwb2xhck1vZGVsLmdldCgnY2VudGVyJyk7XG4gIHZhciB3aWR0aCA9IGFwaS5nZXRXaWR0aCgpO1xuICB2YXIgaGVpZ2h0ID0gYXBpLmdldEhlaWdodCgpO1xuICBwb2xhci5jeCA9IHBhcnNlUGVyY2VudChjZW50ZXJbMF0sIHdpZHRoKTtcbiAgcG9sYXIuY3kgPSBwYXJzZVBlcmNlbnQoY2VudGVyWzFdLCBoZWlnaHQpO1xuICB2YXIgcmFkaXVzQXhpcyA9IHBvbGFyLmdldFJhZGl1c0F4aXMoKTtcbiAgdmFyIHNpemUgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7XG4gIHZhciByYWRpdXMgPSBwb2xhck1vZGVsLmdldCgncmFkaXVzJyk7XG4gIGlmIChyYWRpdXMgPT0gbnVsbCkge1xuICAgIHJhZGl1cyA9IFswLCAnMTAwJSddO1xuICB9IGVsc2UgaWYgKCF6clV0aWwuaXNBcnJheShyYWRpdXMpKSB7XG4gICAgLy8gcjAgPSAwXG4gICAgcmFkaXVzID0gWzAsIHJhZGl1c107XG4gIH1cbiAgdmFyIHBhcnNlZFJhZGl1cyA9IFtwYXJzZVBlcmNlbnQocmFkaXVzWzBdLCBzaXplKSwgcGFyc2VQZXJjZW50KHJhZGl1c1sxXSwgc2l6ZSldO1xuICByYWRpdXNBeGlzLmludmVyc2UgPyByYWRpdXNBeGlzLnNldEV4dGVudChwYXJzZWRSYWRpdXNbMV0sIHBhcnNlZFJhZGl1c1swXSkgOiByYWRpdXNBeGlzLnNldEV4dGVudChwYXJzZWRSYWRpdXNbMF0sIHBhcnNlZFJhZGl1c1sxXSk7XG59XG4vKipcclxuICogVXBkYXRlIHBvbGFyXHJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlUG9sYXJTY2FsZShlY01vZGVsLCBhcGkpIHtcbiAgdmFyIHBvbGFyID0gdGhpcztcbiAgdmFyIGFuZ2xlQXhpcyA9IHBvbGFyLmdldEFuZ2xlQXhpcygpO1xuICB2YXIgcmFkaXVzQXhpcyA9IHBvbGFyLmdldFJhZGl1c0F4aXMoKTtcbiAgLy8gUmVzZXQgc2NhbGVcbiAgYW5nbGVBeGlzLnNjYWxlLnNldEV4dGVudChJbmZpbml0eSwgLUluZmluaXR5KTtcbiAgcmFkaXVzQXhpcy5zY2FsZS5zZXRFeHRlbnQoSW5maW5pdHksIC1JbmZpbml0eSk7XG4gIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICBpZiAoc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9PT0gcG9sYXIpIHtcbiAgICAgIHZhciBkYXRhXzEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB6clV0aWwuZWFjaChnZXREYXRhRGltZW5zaW9uc09uQXhpcyhkYXRhXzEsICdyYWRpdXMnKSwgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICByYWRpdXNBeGlzLnNjYWxlLnVuaW9uRXh0ZW50RnJvbURhdGEoZGF0YV8xLCBkaW0pO1xuICAgICAgfSk7XG4gICAgICB6clV0aWwuZWFjaChnZXREYXRhRGltZW5zaW9uc09uQXhpcyhkYXRhXzEsICdhbmdsZScpLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIGFuZ2xlQXhpcy5zY2FsZS51bmlvbkV4dGVudEZyb21EYXRhKGRhdGFfMSwgZGltKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIG5pY2VTY2FsZUV4dGVudChhbmdsZUF4aXMuc2NhbGUsIGFuZ2xlQXhpcy5tb2RlbCk7XG4gIG5pY2VTY2FsZUV4dGVudChyYWRpdXNBeGlzLnNjYWxlLCByYWRpdXNBeGlzLm1vZGVsKTtcbiAgLy8gRml4IGV4dGVudCBvZiBjYXRlZ29yeSBhbmdsZSBheGlzXG4gIGlmIChhbmdsZUF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyAmJiAhYW5nbGVBeGlzLm9uQmFuZCkge1xuICAgIHZhciBleHRlbnQgPSBhbmdsZUF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIGRpZmYgPSAzNjAgLyBhbmdsZUF4aXMuc2NhbGUuY291bnQoKTtcbiAgICBhbmdsZUF4aXMuaW52ZXJzZSA/IGV4dGVudFsxXSArPSBkaWZmIDogZXh0ZW50WzFdIC09IGRpZmY7XG4gICAgYW5nbGVBeGlzLnNldEV4dGVudChleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQW5nbGVBeGlzTW9kZWwoYXhpc01vZGVsKSB7XG4gIHJldHVybiBheGlzTW9kZWwubWFpblR5cGUgPT09ICdhbmdsZUF4aXMnO1xufVxuLyoqXHJcbiAqIFNldCBjb21tb24gYXhpcyBwcm9wZXJ0aWVzXHJcbiAqL1xuZnVuY3Rpb24gc2V0QXhpcyhheGlzLCBheGlzTW9kZWwpIHtcbiAgdmFyIF9hO1xuICBheGlzLnR5cGUgPSBheGlzTW9kZWwuZ2V0KCd0eXBlJyk7XG4gIGF4aXMuc2NhbGUgPSBjcmVhdGVTY2FsZUJ5TW9kZWwoYXhpc01vZGVsKTtcbiAgYXhpcy5vbkJhbmQgPSBheGlzTW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpICYmIGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgYXhpcy5pbnZlcnNlID0gYXhpc01vZGVsLmdldCgnaW52ZXJzZScpO1xuICBpZiAoaXNBbmdsZUF4aXNNb2RlbChheGlzTW9kZWwpKSB7XG4gICAgYXhpcy5pbnZlcnNlID0gYXhpcy5pbnZlcnNlICE9PSBheGlzTW9kZWwuZ2V0KCdjbG9ja3dpc2UnKTtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IGF4aXNNb2RlbC5nZXQoJ3N0YXJ0QW5nbGUnKTtcbiAgICB2YXIgZW5kQW5nbGUgPSAoX2EgPSBheGlzTW9kZWwuZ2V0KCdlbmRBbmdsZScpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzdGFydEFuZ2xlICsgKGF4aXMuaW52ZXJzZSA/IC0zNjAgOiAzNjApO1xuICAgIGF4aXMuc2V0RXh0ZW50KHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgfVxuICAvLyBJbmplY3QgYXhpcyBpbnN0YW5jZVxuICBheGlzTW9kZWwuYXhpcyA9IGF4aXM7XG4gIGF4aXMubW9kZWwgPSBheGlzTW9kZWw7XG59XG52YXIgcG9sYXJDcmVhdG9yID0ge1xuICBkaW1lbnNpb25zOiBwb2xhckRpbWVuc2lvbnMsXG4gIGNyZWF0ZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBwb2xhckxpc3QgPSBbXTtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ3BvbGFyJywgZnVuY3Rpb24gKHBvbGFyTW9kZWwsIGlkeCkge1xuICAgICAgdmFyIHBvbGFyID0gbmV3IFBvbGFyKGlkeCArICcnKTtcbiAgICAgIC8vIEluamVjdCByZXNpemUgYW5kIHVwZGF0ZSBtZXRob2RcbiAgICAgIHBvbGFyLnVwZGF0ZSA9IHVwZGF0ZVBvbGFyU2NhbGU7XG4gICAgICB2YXIgcmFkaXVzQXhpcyA9IHBvbGFyLmdldFJhZGl1c0F4aXMoKTtcbiAgICAgIHZhciBhbmdsZUF4aXMgPSBwb2xhci5nZXRBbmdsZUF4aXMoKTtcbiAgICAgIHZhciByYWRpdXNBeGlzTW9kZWwgPSBwb2xhck1vZGVsLmZpbmRBeGlzTW9kZWwoJ3JhZGl1c0F4aXMnKTtcbiAgICAgIHZhciBhbmdsZUF4aXNNb2RlbCA9IHBvbGFyTW9kZWwuZmluZEF4aXNNb2RlbCgnYW5nbGVBeGlzJyk7XG4gICAgICBzZXRBeGlzKHJhZGl1c0F4aXMsIHJhZGl1c0F4aXNNb2RlbCk7XG4gICAgICBzZXRBeGlzKGFuZ2xlQXhpcywgYW5nbGVBeGlzTW9kZWwpO1xuICAgICAgcmVzaXplUG9sYXIocG9sYXIsIHBvbGFyTW9kZWwsIGFwaSk7XG4gICAgICBwb2xhckxpc3QucHVzaChwb2xhcik7XG4gICAgICBwb2xhck1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSBwb2xhcjtcbiAgICAgIHBvbGFyLm1vZGVsID0gcG9sYXJNb2RlbDtcbiAgICB9KTtcbiAgICAvLyBJbmplY3QgY29vcmRpbmF0ZVN5c3RlbSB0byBzZXJpZXNcbiAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICBpZiAoc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykgPT09ICdwb2xhcicpIHtcbiAgICAgICAgdmFyIHBvbGFyTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKCdwb2xhcicsIFNJTkdMRV9SRUZFUlJJTkcpLm1vZGVsc1swXTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIXBvbGFyTW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9sYXIgXCInICsgenJVdGlsLnJldHJpZXZlKHNlcmllc01vZGVsLmdldCgncG9sYXJJbmRleCcpLCBzZXJpZXNNb2RlbC5nZXQoJ3BvbGFySWQnKSwgMCkgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSBwb2xhck1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvbGFyTGlzdDtcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IHBvbGFyQ3JlYXRvcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///42506\n")},42744:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ parallelCreator)\n});\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/matrix.js\nvar matrix = __webpack_require__(45587);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/axisHelper.js\nvar axisHelper = __webpack_require__(99031);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/Axis.js\nvar Axis = __webpack_require__(1727);\n;// ./node_modules/echarts/lib/coord/parallel/ParallelAxis.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar ParallelAxis = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ParallelAxis, _super);\n  function ParallelAxis(dim, scale, coordExtent, axisType, axisIndex) {\n    var _this = _super.call(this, dim, scale, coordExtent) || this;\n    _this.type = axisType || 'value';\n    _this.axisIndex = axisIndex;\n    return _this;\n  }\n  ParallelAxis.prototype.isHorizontal = function () {\n    return this.coordinateSystem.getModel().get('layout') !== 'horizontal';\n  };\n  return ParallelAxis;\n}(Axis/* default */.A);\n/* harmony default export */ const parallel_ParallelAxis = (ParallelAxis);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/sliderMove.js\nvar sliderMove = __webpack_require__(98983);\n;// ./node_modules/echarts/lib/coord/parallel/Parallel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * Parallel Coordinates\r\n * <https://en.wikipedia.org/wiki/Parallel_coordinates>\r\n */\n\n\n\n\n\n\n\n\nvar each = util.each;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathFloor = Math.floor;\nvar mathCeil = Math.ceil;\nvar round = number/* round */.LI;\nvar PI = Math.PI;\nvar Parallel = /** @class */function () {\n  function Parallel(parallelModel, ecModel, api) {\n    this.type = 'parallel';\n    /**\r\n     * key: dimension\r\n     */\n    this._axesMap = util.createHashMap();\n    /**\r\n     * key: dimension\r\n     * value: {position: [], rotation, }\r\n     */\n    this._axesLayout = {};\n    this.dimensions = parallelModel.dimensions;\n    this._model = parallelModel;\n    this._init(parallelModel, ecModel, api);\n  }\n  Parallel.prototype._init = function (parallelModel, ecModel, api) {\n    var dimensions = parallelModel.dimensions;\n    var parallelAxisIndex = parallelModel.parallelAxisIndex;\n    each(dimensions, function (dim, idx) {\n      var axisIndex = parallelAxisIndex[idx];\n      var axisModel = ecModel.getComponent('parallelAxis', axisIndex);\n      var axis = this._axesMap.set(dim, new parallel_ParallelAxis(dim, axisHelper/* createScaleByModel */.f$(axisModel), [0, 0], axisModel.get('type'), axisIndex));\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse');\n      // Injection\n      axisModel.axis = axis;\n      axis.model = axisModel;\n      axis.coordinateSystem = axisModel.coordinateSystem = this;\n    }, this);\n  };\n  /**\r\n   * Update axis scale after data processed\r\n   */\n  Parallel.prototype.update = function (ecModel, api) {\n    this._updateAxesFromSeries(this._model, ecModel);\n  };\n  Parallel.prototype.containPoint = function (point) {\n    var layoutInfo = this._makeLayoutInfo();\n    var axisBase = layoutInfo.axisBase;\n    var layoutBase = layoutInfo.layoutBase;\n    var pixelDimIndex = layoutInfo.pixelDimIndex;\n    var pAxis = point[1 - pixelDimIndex];\n    var pLayout = point[pixelDimIndex];\n    return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;\n  };\n  Parallel.prototype.getModel = function () {\n    return this._model;\n  };\n  /**\r\n   * Update properties from series\r\n   */\n  Parallel.prototype._updateAxesFromSeries = function (parallelModel, ecModel) {\n    ecModel.eachSeries(function (seriesModel) {\n      if (!parallelModel.contains(seriesModel, ecModel)) {\n        return;\n      }\n      var data = seriesModel.getData();\n      each(this.dimensions, function (dim) {\n        var axis = this._axesMap.get(dim);\n        axis.scale.unionExtentFromData(data, data.mapDimension(dim));\n        axisHelper/* niceScaleExtent */.af(axis.scale, axis.model);\n      }, this);\n    }, this);\n  };\n  /**\r\n   * Resize the parallel coordinate system.\r\n   */\n  Parallel.prototype.resize = function (parallelModel, api) {\n    this._rect = layout/* getLayoutRect */.dV(parallelModel.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    this._layoutAxes();\n  };\n  Parallel.prototype.getRect = function () {\n    return this._rect;\n  };\n  Parallel.prototype._makeLayoutInfo = function () {\n    var parallelModel = this._model;\n    var rect = this._rect;\n    var xy = ['x', 'y'];\n    var wh = ['width', 'height'];\n    var layout = parallelModel.get('layout');\n    var pixelDimIndex = layout === 'horizontal' ? 0 : 1;\n    var layoutLength = rect[wh[pixelDimIndex]];\n    var layoutExtent = [0, layoutLength];\n    var axisCount = this.dimensions.length;\n    var axisExpandWidth = restrict(parallelModel.get('axisExpandWidth'), layoutExtent);\n    var axisExpandCount = restrict(parallelModel.get('axisExpandCount') || 0, [0, axisCount]);\n    var axisExpandable = parallelModel.get('axisExpandable') && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0;\n    // `axisExpandWindow` is According to the coordinates of [0, axisExpandLength],\n    // for sake of consider the case that axisCollapseWidth is 0 (when screen is narrow),\n    // where collapsed axes should be overlapped.\n    var axisExpandWindow = parallelModel.get('axisExpandWindow');\n    var winSize;\n    if (!axisExpandWindow) {\n      winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);\n      var axisExpandCenter = parallelModel.get('axisExpandCenter') || mathFloor(axisCount / 2);\n      axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];\n      axisExpandWindow[1] = axisExpandWindow[0] + winSize;\n    } else {\n      winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);\n      axisExpandWindow[1] = axisExpandWindow[0] + winSize;\n    }\n    var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount);\n    // Avoid axisCollapseWidth is too small.\n    axisCollapseWidth < 3 && (axisCollapseWidth = 0);\n    // Find the first and last indices > ewin[0] and < ewin[1].\n    var winInnerIndices = [mathFloor(round(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round(axisExpandWindow[1] / axisExpandWidth, 1)) - 1];\n    // Pos in ec coordinates.\n    var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];\n    return {\n      layout: layout,\n      pixelDimIndex: pixelDimIndex,\n      layoutBase: rect[xy[pixelDimIndex]],\n      layoutLength: layoutLength,\n      axisBase: rect[xy[1 - pixelDimIndex]],\n      axisLength: rect[wh[1 - pixelDimIndex]],\n      axisExpandable: axisExpandable,\n      axisExpandWidth: axisExpandWidth,\n      axisCollapseWidth: axisCollapseWidth,\n      axisExpandWindow: axisExpandWindow,\n      axisCount: axisCount,\n      winInnerIndices: winInnerIndices,\n      axisExpandWindow0Pos: axisExpandWindow0Pos\n    };\n  };\n  Parallel.prototype._layoutAxes = function () {\n    var rect = this._rect;\n    var axes = this._axesMap;\n    var dimensions = this.dimensions;\n    var layoutInfo = this._makeLayoutInfo();\n    var layout = layoutInfo.layout;\n    axes.each(function (axis) {\n      var axisExtent = [0, layoutInfo.axisLength];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);\n    });\n    each(dimensions, function (dim, idx) {\n      var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);\n      var positionTable = {\n        horizontal: {\n          x: posInfo.position,\n          y: layoutInfo.axisLength\n        },\n        vertical: {\n          x: 0,\n          y: posInfo.position\n        }\n      };\n      var rotationTable = {\n        horizontal: PI / 2,\n        vertical: 0\n      };\n      var position = [positionTable[layout].x + rect.x, positionTable[layout].y + rect.y];\n      var rotation = rotationTable[layout];\n      var transform = matrix.create();\n      matrix.rotate(transform, transform, rotation);\n      matrix.translate(transform, transform, position);\n      // TODO\n      // tick layout info\n      // TODO\n      // update dimensions info based on axis order.\n      this._axesLayout[dim] = {\n        position: position,\n        rotation: rotation,\n        transform: transform,\n        axisNameAvailableWidth: posInfo.axisNameAvailableWidth,\n        axisLabelShow: posInfo.axisLabelShow,\n        nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,\n        tickDirection: 1,\n        labelDirection: 1\n      };\n    }, this);\n  };\n  /**\r\n   * Get axis by dim.\r\n   */\n  Parallel.prototype.getAxis = function (dim) {\n    return this._axesMap.get(dim);\n  };\n  /**\r\n   * Convert a dim value of a single item of series data to Point.\r\n   */\n  Parallel.prototype.dataToPoint = function (value, dim) {\n    return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);\n  };\n  /**\r\n   * Travel data for one time, get activeState of each data item.\r\n   * @param start the start dataIndex that travel from.\r\n   * @param end the next dataIndex of the last dataIndex will be travel.\r\n   */\n  Parallel.prototype.eachActiveState = function (data, callback, start, end) {\n    start == null && (start = 0);\n    end == null && (end = data.count());\n    var axesMap = this._axesMap;\n    var dimensions = this.dimensions;\n    var dataDimensions = [];\n    var axisModels = [];\n    util.each(dimensions, function (axisDim) {\n      dataDimensions.push(data.mapDimension(axisDim));\n      axisModels.push(axesMap.get(axisDim).model);\n    });\n    var hasActiveSet = this.hasAxisBrushed();\n    for (var dataIndex = start; dataIndex < end; dataIndex++) {\n      var activeState = void 0;\n      if (!hasActiveSet) {\n        activeState = 'normal';\n      } else {\n        activeState = 'active';\n        var values = data.getValues(dataDimensions, dataIndex);\n        for (var j = 0, lenj = dimensions.length; j < lenj; j++) {\n          var state = axisModels[j].getActiveState(values[j]);\n          if (state === 'inactive') {\n            activeState = 'inactive';\n            break;\n          }\n        }\n      }\n      callback(activeState, dataIndex);\n    }\n  };\n  /**\r\n   * Whether has any activeSet.\r\n   */\n  Parallel.prototype.hasAxisBrushed = function () {\n    var dimensions = this.dimensions;\n    var axesMap = this._axesMap;\n    var hasActiveSet = false;\n    for (var j = 0, lenj = dimensions.length; j < lenj; j++) {\n      if (axesMap.get(dimensions[j]).model.getActiveState() !== 'normal') {\n        hasActiveSet = true;\n      }\n    }\n    return hasActiveSet;\n  };\n  /**\r\n   * Convert coords of each axis to Point.\r\n   *  Return point. For example: [10, 20]\r\n   */\n  Parallel.prototype.axisCoordToPoint = function (coord, dim) {\n    var axisLayout = this._axesLayout[dim];\n    return graphic.applyTransform([coord, 0], axisLayout.transform);\n  };\n  /**\r\n   * Get axis layout.\r\n   */\n  Parallel.prototype.getAxisLayout = function (dim) {\n    return util.clone(this._axesLayout[dim]);\n  };\n  /**\r\n   * @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}.\r\n   */\n  Parallel.prototype.getSlidedAxisExpandWindow = function (point) {\n    var layoutInfo = this._makeLayoutInfo();\n    var pixelDimIndex = layoutInfo.pixelDimIndex;\n    var axisExpandWindow = layoutInfo.axisExpandWindow.slice();\n    var winSize = axisExpandWindow[1] - axisExpandWindow[0];\n    var extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)];\n    // Out of the area of coordinate system.\n    if (!this.containPoint(point)) {\n      return {\n        behavior: 'none',\n        axisExpandWindow: axisExpandWindow\n      };\n    }\n    // Convert the point from global to expand coordinates.\n    var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos;\n    // For dragging operation convenience, the window should not be\n    // slided when mouse is the center area of the window.\n    var delta;\n    var behavior = 'slide';\n    var axisCollapseWidth = layoutInfo.axisCollapseWidth;\n    var triggerArea = this._model.get('axisExpandSlideTriggerArea');\n    // But consider touch device, jump is necessary.\n    var useJump = triggerArea[0] != null;\n    if (axisCollapseWidth) {\n      if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {\n        behavior = 'jump';\n        delta = pointCoord - winSize * triggerArea[2];\n      } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {\n        behavior = 'jump';\n        delta = pointCoord - winSize * (1 - triggerArea[2]);\n      } else {\n        (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);\n      }\n      delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;\n      delta ? (0,sliderMove/* default */.A)(delta, axisExpandWindow, extent, 'all')\n      // Avoid nonsense triger on mousemove.\n      : behavior = 'none';\n    }\n    // When screen is too narrow, make it visible and slidable, although it is hard to interact.\n    else {\n      var winSize2 = axisExpandWindow[1] - axisExpandWindow[0];\n      var pos = extent[1] * pointCoord / winSize2;\n      axisExpandWindow = [mathMax(0, pos - winSize2 / 2)];\n      axisExpandWindow[1] = mathMin(extent[1], axisExpandWindow[0] + winSize2);\n      axisExpandWindow[0] = axisExpandWindow[1] - winSize2;\n    }\n    return {\n      axisExpandWindow: axisExpandWindow,\n      behavior: behavior\n    };\n  };\n  return Parallel;\n}();\nfunction restrict(len, extent) {\n  return mathMin(mathMax(len, extent[0]), extent[1]);\n}\nfunction layoutAxisWithoutExpand(axisIndex, layoutInfo) {\n  var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);\n  return {\n    position: step * axisIndex,\n    axisNameAvailableWidth: step,\n    axisLabelShow: true\n  };\n}\nfunction layoutAxisWithExpand(axisIndex, layoutInfo) {\n  var layoutLength = layoutInfo.layoutLength;\n  var axisExpandWidth = layoutInfo.axisExpandWidth;\n  var axisCount = layoutInfo.axisCount;\n  var axisCollapseWidth = layoutInfo.axisCollapseWidth;\n  var winInnerIndices = layoutInfo.winInnerIndices;\n  var position;\n  var axisNameAvailableWidth = axisCollapseWidth;\n  var axisLabelShow = false;\n  var nameTruncateMaxWidth;\n  if (axisIndex < winInnerIndices[0]) {\n    position = axisIndex * axisCollapseWidth;\n    nameTruncateMaxWidth = axisCollapseWidth;\n  } else if (axisIndex <= winInnerIndices[1]) {\n    position = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];\n    axisNameAvailableWidth = axisExpandWidth;\n    axisLabelShow = true;\n  } else {\n    position = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;\n    nameTruncateMaxWidth = axisCollapseWidth;\n  }\n  return {\n    position: position,\n    axisNameAvailableWidth: axisNameAvailableWidth,\n    axisLabelShow: axisLabelShow,\n    nameTruncateMaxWidth: nameTruncateMaxWidth\n  };\n}\n/* harmony default export */ const parallel_Parallel = (Parallel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n;// ./node_modules/echarts/lib/coord/parallel/parallelCreator.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * Parallel coordinate system creater.\r\n */\n\n\nfunction createParallelCoordSys(ecModel, api) {\n  var coordSysList = [];\n  ecModel.eachComponent('parallel', function (parallelModel, idx) {\n    var coordSys = new parallel_Parallel(parallelModel, ecModel, api);\n    coordSys.name = 'parallel_' + idx;\n    coordSys.resize(parallelModel, api);\n    parallelModel.coordinateSystem = coordSys;\n    coordSys.model = parallelModel;\n    coordSysList.push(coordSys);\n  });\n  // Inject the coordinateSystems into seriesModel\n  ecModel.eachSeries(function (seriesModel) {\n    if (seriesModel.get('coordinateSystem') === 'parallel') {\n      var parallelModel = seriesModel.getReferringComponents('parallel', model/* SINGLE_REFERRING */.US).models[0];\n      seriesModel.coordinateSystem = parallelModel.coordinateSystem;\n    }\n  });\n  return coordSysList;\n}\nvar parallelCoordSysCreator = {\n  create: createParallelCoordSys\n};\n/* harmony default export */ const parallelCreator = (parallelCoordSysCreator);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI3NDQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9wYXJhbGxlbC9QYXJhbGxlbEF4aXMuanM/ODk0ZiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvcGFyYWxsZWwvUGFyYWxsZWwuanM/MzBmYSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvcGFyYWxsZWwvcGFyYWxsZWxDcmVhdG9yLmpzPzhlYTEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBBeGlzIGZyb20gJy4uL0F4aXMuanMnO1xudmFyIFBhcmFsbGVsQXhpcyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQYXJhbGxlbEF4aXMsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFBhcmFsbGVsQXhpcyhkaW0sIHNjYWxlLCBjb29yZEV4dGVudCwgYXhpc1R5cGUsIGF4aXNJbmRleCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRpbSwgc2NhbGUsIGNvb3JkRXh0ZW50KSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBheGlzVHlwZSB8fCAndmFsdWUnO1xuICAgIF90aGlzLmF4aXNJbmRleCA9IGF4aXNJbmRleDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgUGFyYWxsZWxBeGlzLnByb3RvdHlwZS5pc0hvcml6b250YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZVN5c3RlbS5nZXRNb2RlbCgpLmdldCgnbGF5b3V0JykgIT09ICdob3Jpem9udGFsJztcbiAgfTtcbiAgcmV0dXJuIFBhcmFsbGVsQXhpcztcbn0oQXhpcyk7XG5leHBvcnQgZGVmYXVsdCBQYXJhbGxlbEF4aXM7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG4vKipcclxuICogUGFyYWxsZWwgQ29vcmRpbmF0ZXNcclxuICogPGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BhcmFsbGVsX2Nvb3JkaW5hdGVzPlxyXG4gKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgbWF0cml4IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzJztcbmltcG9ydCAqIGFzIGxheW91dFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQuanMnO1xuaW1wb3J0ICogYXMgYXhpc0hlbHBlciBmcm9tICcuLi8uLi9jb29yZC9heGlzSGVscGVyLmpzJztcbmltcG9ydCBQYXJhbGxlbEF4aXMgZnJvbSAnLi9QYXJhbGxlbEF4aXMuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7XG5pbXBvcnQgc2xpZGVyTW92ZSBmcm9tICcuLi8uLi9jb21wb25lbnQvaGVscGVyL3NsaWRlck1vdmUuanMnO1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhGbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbWF0aENlaWwgPSBNYXRoLmNlaWw7XG52YXIgcm91bmQgPSBudW1iZXJVdGlsLnJvdW5kO1xudmFyIFBJID0gTWF0aC5QSTtcbnZhciBQYXJhbGxlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhcmFsbGVsKHBhcmFsbGVsTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMudHlwZSA9ICdwYXJhbGxlbCc7XG4gICAgLyoqXHJcbiAgICAgKiBrZXk6IGRpbWVuc2lvblxyXG4gICAgICovXG4gICAgdGhpcy5fYXhlc01hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgLyoqXHJcbiAgICAgKiBrZXk6IGRpbWVuc2lvblxyXG4gICAgICogdmFsdWU6IHtwb3NpdGlvbjogW10sIHJvdGF0aW9uLCB9XHJcbiAgICAgKi9cbiAgICB0aGlzLl9heGVzTGF5b3V0ID0ge307XG4gICAgdGhpcy5kaW1lbnNpb25zID0gcGFyYWxsZWxNb2RlbC5kaW1lbnNpb25zO1xuICAgIHRoaXMuX21vZGVsID0gcGFyYWxsZWxNb2RlbDtcbiAgICB0aGlzLl9pbml0KHBhcmFsbGVsTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gIH1cbiAgUGFyYWxsZWwucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKHBhcmFsbGVsTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBkaW1lbnNpb25zID0gcGFyYWxsZWxNb2RlbC5kaW1lbnNpb25zO1xuICAgIHZhciBwYXJhbGxlbEF4aXNJbmRleCA9IHBhcmFsbGVsTW9kZWwucGFyYWxsZWxBeGlzSW5kZXg7XG4gICAgZWFjaChkaW1lbnNpb25zLCBmdW5jdGlvbiAoZGltLCBpZHgpIHtcbiAgICAgIHZhciBheGlzSW5kZXggPSBwYXJhbGxlbEF4aXNJbmRleFtpZHhdO1xuICAgICAgdmFyIGF4aXNNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdwYXJhbGxlbEF4aXMnLCBheGlzSW5kZXgpO1xuICAgICAgdmFyIGF4aXMgPSB0aGlzLl9heGVzTWFwLnNldChkaW0sIG5ldyBQYXJhbGxlbEF4aXMoZGltLCBheGlzSGVscGVyLmNyZWF0ZVNjYWxlQnlNb2RlbChheGlzTW9kZWwpLCBbMCwgMF0sIGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSwgYXhpc0luZGV4KSk7XG4gICAgICB2YXIgaXNDYXRlZ29yeSA9IGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgICAgIGF4aXMub25CYW5kID0gaXNDYXRlZ29yeSAmJiBheGlzTW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuICAgICAgYXhpcy5pbnZlcnNlID0gYXhpc01vZGVsLmdldCgnaW52ZXJzZScpO1xuICAgICAgLy8gSW5qZWN0aW9uXG4gICAgICBheGlzTW9kZWwuYXhpcyA9IGF4aXM7XG4gICAgICBheGlzLm1vZGVsID0gYXhpc01vZGVsO1xuICAgICAgYXhpcy5jb29yZGluYXRlU3lzdGVtID0gYXhpc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSB0aGlzO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgYXhpcyBzY2FsZSBhZnRlciBkYXRhIHByb2Nlc3NlZFxyXG4gICAqL1xuICBQYXJhbGxlbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuX3VwZGF0ZUF4ZXNGcm9tU2VyaWVzKHRoaXMuX21vZGVsLCBlY01vZGVsKTtcbiAgfTtcbiAgUGFyYWxsZWwucHJvdG90eXBlLmNvbnRhaW5Qb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBsYXlvdXRJbmZvID0gdGhpcy5fbWFrZUxheW91dEluZm8oKTtcbiAgICB2YXIgYXhpc0Jhc2UgPSBsYXlvdXRJbmZvLmF4aXNCYXNlO1xuICAgIHZhciBsYXlvdXRCYXNlID0gbGF5b3V0SW5mby5sYXlvdXRCYXNlO1xuICAgIHZhciBwaXhlbERpbUluZGV4ID0gbGF5b3V0SW5mby5waXhlbERpbUluZGV4O1xuICAgIHZhciBwQXhpcyA9IHBvaW50WzEgLSBwaXhlbERpbUluZGV4XTtcbiAgICB2YXIgcExheW91dCA9IHBvaW50W3BpeGVsRGltSW5kZXhdO1xuICAgIHJldHVybiBwQXhpcyA+PSBheGlzQmFzZSAmJiBwQXhpcyA8PSBheGlzQmFzZSArIGxheW91dEluZm8uYXhpc0xlbmd0aCAmJiBwTGF5b3V0ID49IGxheW91dEJhc2UgJiYgcExheW91dCA8PSBsYXlvdXRCYXNlICsgbGF5b3V0SW5mby5sYXlvdXRMZW5ndGg7XG4gIH07XG4gIFBhcmFsbGVsLnByb3RvdHlwZS5nZXRNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBwcm9wZXJ0aWVzIGZyb20gc2VyaWVzXHJcbiAgICovXG4gIFBhcmFsbGVsLnByb3RvdHlwZS5fdXBkYXRlQXhlc0Zyb21TZXJpZXMgPSBmdW5jdGlvbiAocGFyYWxsZWxNb2RlbCwgZWNNb2RlbCkge1xuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIGlmICghcGFyYWxsZWxNb2RlbC5jb250YWlucyhzZXJpZXNNb2RlbCwgZWNNb2RlbCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICBlYWNoKHRoaXMuZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICB2YXIgYXhpcyA9IHRoaXMuX2F4ZXNNYXAuZ2V0KGRpbSk7XG4gICAgICAgIGF4aXMuc2NhbGUudW5pb25FeHRlbnRGcm9tRGF0YShkYXRhLCBkYXRhLm1hcERpbWVuc2lvbihkaW0pKTtcbiAgICAgICAgYXhpc0hlbHBlci5uaWNlU2NhbGVFeHRlbnQoYXhpcy5zY2FsZSwgYXhpcy5tb2RlbCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmVzaXplIHRoZSBwYXJhbGxlbCBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgKi9cbiAgUGFyYWxsZWwucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChwYXJhbGxlbE1vZGVsLCBhcGkpIHtcbiAgICB0aGlzLl9yZWN0ID0gbGF5b3V0VXRpbC5nZXRMYXlvdXRSZWN0KHBhcmFsbGVsTW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCksIHtcbiAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgfSk7XG4gICAgdGhpcy5fbGF5b3V0QXhlcygpO1xuICB9O1xuICBQYXJhbGxlbC5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgfTtcbiAgUGFyYWxsZWwucHJvdG90eXBlLl9tYWtlTGF5b3V0SW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyYWxsZWxNb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdDtcbiAgICB2YXIgeHkgPSBbJ3gnLCAneSddO1xuICAgIHZhciB3aCA9IFsnd2lkdGgnLCAnaGVpZ2h0J107XG4gICAgdmFyIGxheW91dCA9IHBhcmFsbGVsTW9kZWwuZ2V0KCdsYXlvdXQnKTtcbiAgICB2YXIgcGl4ZWxEaW1JbmRleCA9IGxheW91dCA9PT0gJ2hvcml6b250YWwnID8gMCA6IDE7XG4gICAgdmFyIGxheW91dExlbmd0aCA9IHJlY3Rbd2hbcGl4ZWxEaW1JbmRleF1dO1xuICAgIHZhciBsYXlvdXRFeHRlbnQgPSBbMCwgbGF5b3V0TGVuZ3RoXTtcbiAgICB2YXIgYXhpc0NvdW50ID0gdGhpcy5kaW1lbnNpb25zLmxlbmd0aDtcbiAgICB2YXIgYXhpc0V4cGFuZFdpZHRoID0gcmVzdHJpY3QocGFyYWxsZWxNb2RlbC5nZXQoJ2F4aXNFeHBhbmRXaWR0aCcpLCBsYXlvdXRFeHRlbnQpO1xuICAgIHZhciBheGlzRXhwYW5kQ291bnQgPSByZXN0cmljdChwYXJhbGxlbE1vZGVsLmdldCgnYXhpc0V4cGFuZENvdW50JykgfHwgMCwgWzAsIGF4aXNDb3VudF0pO1xuICAgIHZhciBheGlzRXhwYW5kYWJsZSA9IHBhcmFsbGVsTW9kZWwuZ2V0KCdheGlzRXhwYW5kYWJsZScpICYmIGF4aXNDb3VudCA+IDMgJiYgYXhpc0NvdW50ID4gYXhpc0V4cGFuZENvdW50ICYmIGF4aXNFeHBhbmRDb3VudCA+IDEgJiYgYXhpc0V4cGFuZFdpZHRoID4gMCAmJiBsYXlvdXRMZW5ndGggPiAwO1xuICAgIC8vIGBheGlzRXhwYW5kV2luZG93YCBpcyBBY2NvcmRpbmcgdG8gdGhlIGNvb3JkaW5hdGVzIG9mIFswLCBheGlzRXhwYW5kTGVuZ3RoXSxcbiAgICAvLyBmb3Igc2FrZSBvZiBjb25zaWRlciB0aGUgY2FzZSB0aGF0IGF4aXNDb2xsYXBzZVdpZHRoIGlzIDAgKHdoZW4gc2NyZWVuIGlzIG5hcnJvdyksXG4gICAgLy8gd2hlcmUgY29sbGFwc2VkIGF4ZXMgc2hvdWxkIGJlIG92ZXJsYXBwZWQuXG4gICAgdmFyIGF4aXNFeHBhbmRXaW5kb3cgPSBwYXJhbGxlbE1vZGVsLmdldCgnYXhpc0V4cGFuZFdpbmRvdycpO1xuICAgIHZhciB3aW5TaXplO1xuICAgIGlmICghYXhpc0V4cGFuZFdpbmRvdykge1xuICAgICAgd2luU2l6ZSA9IHJlc3RyaWN0KGF4aXNFeHBhbmRXaWR0aCAqIChheGlzRXhwYW5kQ291bnQgLSAxKSwgbGF5b3V0RXh0ZW50KTtcbiAgICAgIHZhciBheGlzRXhwYW5kQ2VudGVyID0gcGFyYWxsZWxNb2RlbC5nZXQoJ2F4aXNFeHBhbmRDZW50ZXInKSB8fCBtYXRoRmxvb3IoYXhpc0NvdW50IC8gMik7XG4gICAgICBheGlzRXhwYW5kV2luZG93ID0gW2F4aXNFeHBhbmRXaWR0aCAqIGF4aXNFeHBhbmRDZW50ZXIgLSB3aW5TaXplIC8gMl07XG4gICAgICBheGlzRXhwYW5kV2luZG93WzFdID0gYXhpc0V4cGFuZFdpbmRvd1swXSArIHdpblNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpblNpemUgPSByZXN0cmljdChheGlzRXhwYW5kV2luZG93WzFdIC0gYXhpc0V4cGFuZFdpbmRvd1swXSwgbGF5b3V0RXh0ZW50KTtcbiAgICAgIGF4aXNFeHBhbmRXaW5kb3dbMV0gPSBheGlzRXhwYW5kV2luZG93WzBdICsgd2luU2l6ZTtcbiAgICB9XG4gICAgdmFyIGF4aXNDb2xsYXBzZVdpZHRoID0gKGxheW91dExlbmd0aCAtIHdpblNpemUpIC8gKGF4aXNDb3VudCAtIGF4aXNFeHBhbmRDb3VudCk7XG4gICAgLy8gQXZvaWQgYXhpc0NvbGxhcHNlV2lkdGggaXMgdG9vIHNtYWxsLlxuICAgIGF4aXNDb2xsYXBzZVdpZHRoIDwgMyAmJiAoYXhpc0NvbGxhcHNlV2lkdGggPSAwKTtcbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBhbmQgbGFzdCBpbmRpY2VzID4gZXdpblswXSBhbmQgPCBld2luWzFdLlxuICAgIHZhciB3aW5Jbm5lckluZGljZXMgPSBbbWF0aEZsb29yKHJvdW5kKGF4aXNFeHBhbmRXaW5kb3dbMF0gLyBheGlzRXhwYW5kV2lkdGgsIDEpKSArIDEsIG1hdGhDZWlsKHJvdW5kKGF4aXNFeHBhbmRXaW5kb3dbMV0gLyBheGlzRXhwYW5kV2lkdGgsIDEpKSAtIDFdO1xuICAgIC8vIFBvcyBpbiBlYyBjb29yZGluYXRlcy5cbiAgICB2YXIgYXhpc0V4cGFuZFdpbmRvdzBQb3MgPSBheGlzQ29sbGFwc2VXaWR0aCAvIGF4aXNFeHBhbmRXaWR0aCAqIGF4aXNFeHBhbmRXaW5kb3dbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgcGl4ZWxEaW1JbmRleDogcGl4ZWxEaW1JbmRleCxcbiAgICAgIGxheW91dEJhc2U6IHJlY3RbeHlbcGl4ZWxEaW1JbmRleF1dLFxuICAgICAgbGF5b3V0TGVuZ3RoOiBsYXlvdXRMZW5ndGgsXG4gICAgICBheGlzQmFzZTogcmVjdFt4eVsxIC0gcGl4ZWxEaW1JbmRleF1dLFxuICAgICAgYXhpc0xlbmd0aDogcmVjdFt3aFsxIC0gcGl4ZWxEaW1JbmRleF1dLFxuICAgICAgYXhpc0V4cGFuZGFibGU6IGF4aXNFeHBhbmRhYmxlLFxuICAgICAgYXhpc0V4cGFuZFdpZHRoOiBheGlzRXhwYW5kV2lkdGgsXG4gICAgICBheGlzQ29sbGFwc2VXaWR0aDogYXhpc0NvbGxhcHNlV2lkdGgsXG4gICAgICBheGlzRXhwYW5kV2luZG93OiBheGlzRXhwYW5kV2luZG93LFxuICAgICAgYXhpc0NvdW50OiBheGlzQ291bnQsXG4gICAgICB3aW5Jbm5lckluZGljZXM6IHdpbklubmVySW5kaWNlcyxcbiAgICAgIGF4aXNFeHBhbmRXaW5kb3cwUG9zOiBheGlzRXhwYW5kV2luZG93MFBvc1xuICAgIH07XG4gIH07XG4gIFBhcmFsbGVsLnByb3RvdHlwZS5fbGF5b3V0QXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuX3JlY3Q7XG4gICAgdmFyIGF4ZXMgPSB0aGlzLl9heGVzTWFwO1xuICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zO1xuICAgIHZhciBsYXlvdXRJbmZvID0gdGhpcy5fbWFrZUxheW91dEluZm8oKTtcbiAgICB2YXIgbGF5b3V0ID0gbGF5b3V0SW5mby5sYXlvdXQ7XG4gICAgYXhlcy5lYWNoKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICB2YXIgYXhpc0V4dGVudCA9IFswLCBsYXlvdXRJbmZvLmF4aXNMZW5ndGhdO1xuICAgICAgdmFyIGlkeCA9IGF4aXMuaW52ZXJzZSA/IDEgOiAwO1xuICAgICAgYXhpcy5zZXRFeHRlbnQoYXhpc0V4dGVudFtpZHhdLCBheGlzRXh0ZW50WzEgLSBpZHhdKTtcbiAgICB9KTtcbiAgICBlYWNoKGRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW0sIGlkeCkge1xuICAgICAgdmFyIHBvc0luZm8gPSAobGF5b3V0SW5mby5heGlzRXhwYW5kYWJsZSA/IGxheW91dEF4aXNXaXRoRXhwYW5kIDogbGF5b3V0QXhpc1dpdGhvdXRFeHBhbmQpKGlkeCwgbGF5b3V0SW5mbyk7XG4gICAgICB2YXIgcG9zaXRpb25UYWJsZSA9IHtcbiAgICAgICAgaG9yaXpvbnRhbDoge1xuICAgICAgICAgIHg6IHBvc0luZm8ucG9zaXRpb24sXG4gICAgICAgICAgeTogbGF5b3V0SW5mby5heGlzTGVuZ3RoXG4gICAgICAgIH0sXG4gICAgICAgIHZlcnRpY2FsOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiBwb3NJbmZvLnBvc2l0aW9uXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgcm90YXRpb25UYWJsZSA9IHtcbiAgICAgICAgaG9yaXpvbnRhbDogUEkgLyAyLFxuICAgICAgICB2ZXJ0aWNhbDogMFxuICAgICAgfTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IFtwb3NpdGlvblRhYmxlW2xheW91dF0ueCArIHJlY3QueCwgcG9zaXRpb25UYWJsZVtsYXlvdXRdLnkgKyByZWN0LnldO1xuICAgICAgdmFyIHJvdGF0aW9uID0gcm90YXRpb25UYWJsZVtsYXlvdXRdO1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IG1hdHJpeC5jcmVhdGUoKTtcbiAgICAgIG1hdHJpeC5yb3RhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIHJvdGF0aW9uKTtcbiAgICAgIG1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIHBvc2l0aW9uKTtcbiAgICAgIC8vIFRPRE9cbiAgICAgIC8vIHRpY2sgbGF5b3V0IGluZm9cbiAgICAgIC8vIFRPRE9cbiAgICAgIC8vIHVwZGF0ZSBkaW1lbnNpb25zIGluZm8gYmFzZWQgb24gYXhpcyBvcmRlci5cbiAgICAgIHRoaXMuX2F4ZXNMYXlvdXRbZGltXSA9IHtcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoOiBwb3NJbmZvLmF4aXNOYW1lQXZhaWxhYmxlV2lkdGgsXG4gICAgICAgIGF4aXNMYWJlbFNob3c6IHBvc0luZm8uYXhpc0xhYmVsU2hvdyxcbiAgICAgICAgbmFtZVRydW5jYXRlTWF4V2lkdGg6IHBvc0luZm8ubmFtZVRydW5jYXRlTWF4V2lkdGgsXG4gICAgICAgIHRpY2tEaXJlY3Rpb246IDEsXG4gICAgICAgIGxhYmVsRGlyZWN0aW9uOiAxXG4gICAgICB9O1xuICAgIH0sIHRoaXMpO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgYXhpcyBieSBkaW0uXHJcbiAgICovXG4gIFBhcmFsbGVsLnByb3RvdHlwZS5nZXRBeGlzID0gZnVuY3Rpb24gKGRpbSkge1xuICAgIHJldHVybiB0aGlzLl9heGVzTWFwLmdldChkaW0pO1xuICB9O1xuICAvKipcclxuICAgKiBDb252ZXJ0IGEgZGltIHZhbHVlIG9mIGEgc2luZ2xlIGl0ZW0gb2Ygc2VyaWVzIGRhdGEgdG8gUG9pbnQuXHJcbiAgICovXG4gIFBhcmFsbGVsLnByb3RvdHlwZS5kYXRhVG9Qb2ludCA9IGZ1bmN0aW9uICh2YWx1ZSwgZGltKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhpc0Nvb3JkVG9Qb2ludCh0aGlzLl9heGVzTWFwLmdldChkaW0pLmRhdGFUb0Nvb3JkKHZhbHVlKSwgZGltKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVHJhdmVsIGRhdGEgZm9yIG9uZSB0aW1lLCBnZXQgYWN0aXZlU3RhdGUgb2YgZWFjaCBkYXRhIGl0ZW0uXHJcbiAgICogQHBhcmFtIHN0YXJ0IHRoZSBzdGFydCBkYXRhSW5kZXggdGhhdCB0cmF2ZWwgZnJvbS5cclxuICAgKiBAcGFyYW0gZW5kIHRoZSBuZXh0IGRhdGFJbmRleCBvZiB0aGUgbGFzdCBkYXRhSW5kZXggd2lsbCBiZSB0cmF2ZWwuXHJcbiAgICovXG4gIFBhcmFsbGVsLnByb3RvdHlwZS5lYWNoQWN0aXZlU3RhdGUgPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2ssIHN0YXJ0LCBlbmQpIHtcbiAgICBzdGFydCA9PSBudWxsICYmIChzdGFydCA9IDApO1xuICAgIGVuZCA9PSBudWxsICYmIChlbmQgPSBkYXRhLmNvdW50KCkpO1xuICAgIHZhciBheGVzTWFwID0gdGhpcy5fYXhlc01hcDtcbiAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICB2YXIgZGF0YURpbWVuc2lvbnMgPSBbXTtcbiAgICB2YXIgYXhpc01vZGVscyA9IFtdO1xuICAgIHpyVXRpbC5lYWNoKGRpbWVuc2lvbnMsIGZ1bmN0aW9uIChheGlzRGltKSB7XG4gICAgICBkYXRhRGltZW5zaW9ucy5wdXNoKGRhdGEubWFwRGltZW5zaW9uKGF4aXNEaW0pKTtcbiAgICAgIGF4aXNNb2RlbHMucHVzaChheGVzTWFwLmdldChheGlzRGltKS5tb2RlbCk7XG4gICAgfSk7XG4gICAgdmFyIGhhc0FjdGl2ZVNldCA9IHRoaXMuaGFzQXhpc0JydXNoZWQoKTtcbiAgICBmb3IgKHZhciBkYXRhSW5kZXggPSBzdGFydDsgZGF0YUluZGV4IDwgZW5kOyBkYXRhSW5kZXgrKykge1xuICAgICAgdmFyIGFjdGl2ZVN0YXRlID0gdm9pZCAwO1xuICAgICAgaWYgKCFoYXNBY3RpdmVTZXQpIHtcbiAgICAgICAgYWN0aXZlU3RhdGUgPSAnbm9ybWFsJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZVN0YXRlID0gJ2FjdGl2ZSc7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBkYXRhLmdldFZhbHVlcyhkYXRhRGltZW5zaW9ucywgZGF0YUluZGV4KTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbmogPSBkaW1lbnNpb25zLmxlbmd0aDsgaiA8IGxlbmo7IGorKykge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IGF4aXNNb2RlbHNbal0uZ2V0QWN0aXZlU3RhdGUodmFsdWVzW2pdKTtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09ICdpbmFjdGl2ZScpIHtcbiAgICAgICAgICAgIGFjdGl2ZVN0YXRlID0gJ2luYWN0aXZlJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FsbGJhY2soYWN0aXZlU3RhdGUsIGRhdGFJbmRleCk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBXaGV0aGVyIGhhcyBhbnkgYWN0aXZlU2V0LlxyXG4gICAqL1xuICBQYXJhbGxlbC5wcm90b3R5cGUuaGFzQXhpc0JydXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gICAgdmFyIGF4ZXNNYXAgPSB0aGlzLl9heGVzTWFwO1xuICAgIHZhciBoYXNBY3RpdmVTZXQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBqID0gMCwgbGVuaiA9IGRpbWVuc2lvbnMubGVuZ3RoOyBqIDwgbGVuajsgaisrKSB7XG4gICAgICBpZiAoYXhlc01hcC5nZXQoZGltZW5zaW9uc1tqXSkubW9kZWwuZ2V0QWN0aXZlU3RhdGUoKSAhPT0gJ25vcm1hbCcpIHtcbiAgICAgICAgaGFzQWN0aXZlU2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhc0FjdGl2ZVNldDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ29udmVydCBjb29yZHMgb2YgZWFjaCBheGlzIHRvIFBvaW50LlxyXG4gICAqICBSZXR1cm4gcG9pbnQuIEZvciBleGFtcGxlOiBbMTAsIDIwXVxyXG4gICAqL1xuICBQYXJhbGxlbC5wcm90b3R5cGUuYXhpc0Nvb3JkVG9Qb2ludCA9IGZ1bmN0aW9uIChjb29yZCwgZGltKSB7XG4gICAgdmFyIGF4aXNMYXlvdXQgPSB0aGlzLl9heGVzTGF5b3V0W2RpbV07XG4gICAgcmV0dXJuIGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0oW2Nvb3JkLCAwXSwgYXhpc0xheW91dC50cmFuc2Zvcm0pO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgYXhpcyBsYXlvdXQuXHJcbiAgICovXG4gIFBhcmFsbGVsLnByb3RvdHlwZS5nZXRBeGlzTGF5b3V0ID0gZnVuY3Rpb24gKGRpbSkge1xuICAgIHJldHVybiB6clV0aWwuY2xvbmUodGhpcy5fYXhlc0xheW91dFtkaW1dKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSB7YXhpc0V4cGFuZFdpbmRvdywgZGVsdGEsIGJlaGF2aW9yOiAnanVtcCcgfCAnc2xpZGUnIHwgJ25vbmUnfS5cclxuICAgKi9cbiAgUGFyYWxsZWwucHJvdG90eXBlLmdldFNsaWRlZEF4aXNFeHBhbmRXaW5kb3cgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgbGF5b3V0SW5mbyA9IHRoaXMuX21ha2VMYXlvdXRJbmZvKCk7XG4gICAgdmFyIHBpeGVsRGltSW5kZXggPSBsYXlvdXRJbmZvLnBpeGVsRGltSW5kZXg7XG4gICAgdmFyIGF4aXNFeHBhbmRXaW5kb3cgPSBsYXlvdXRJbmZvLmF4aXNFeHBhbmRXaW5kb3cuc2xpY2UoKTtcbiAgICB2YXIgd2luU2l6ZSA9IGF4aXNFeHBhbmRXaW5kb3dbMV0gLSBheGlzRXhwYW5kV2luZG93WzBdO1xuICAgIHZhciBleHRlbnQgPSBbMCwgbGF5b3V0SW5mby5heGlzRXhwYW5kV2lkdGggKiAobGF5b3V0SW5mby5heGlzQ291bnQgLSAxKV07XG4gICAgLy8gT3V0IG9mIHRoZSBhcmVhIG9mIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgIGlmICghdGhpcy5jb250YWluUG9pbnQocG9pbnQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiZWhhdmlvcjogJ25vbmUnLFxuICAgICAgICBheGlzRXhwYW5kV2luZG93OiBheGlzRXhwYW5kV2luZG93XG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBwb2ludCBmcm9tIGdsb2JhbCB0byBleHBhbmQgY29vcmRpbmF0ZXMuXG4gICAgdmFyIHBvaW50Q29vcmQgPSBwb2ludFtwaXhlbERpbUluZGV4XSAtIGxheW91dEluZm8ubGF5b3V0QmFzZSAtIGxheW91dEluZm8uYXhpc0V4cGFuZFdpbmRvdzBQb3M7XG4gICAgLy8gRm9yIGRyYWdnaW5nIG9wZXJhdGlvbiBjb252ZW5pZW5jZSwgdGhlIHdpbmRvdyBzaG91bGQgbm90IGJlXG4gICAgLy8gc2xpZGVkIHdoZW4gbW91c2UgaXMgdGhlIGNlbnRlciBhcmVhIG9mIHRoZSB3aW5kb3cuXG4gICAgdmFyIGRlbHRhO1xuICAgIHZhciBiZWhhdmlvciA9ICdzbGlkZSc7XG4gICAgdmFyIGF4aXNDb2xsYXBzZVdpZHRoID0gbGF5b3V0SW5mby5heGlzQ29sbGFwc2VXaWR0aDtcbiAgICB2YXIgdHJpZ2dlckFyZWEgPSB0aGlzLl9tb2RlbC5nZXQoJ2F4aXNFeHBhbmRTbGlkZVRyaWdnZXJBcmVhJyk7XG4gICAgLy8gQnV0IGNvbnNpZGVyIHRvdWNoIGRldmljZSwganVtcCBpcyBuZWNlc3NhcnkuXG4gICAgdmFyIHVzZUp1bXAgPSB0cmlnZ2VyQXJlYVswXSAhPSBudWxsO1xuICAgIGlmIChheGlzQ29sbGFwc2VXaWR0aCkge1xuICAgICAgaWYgKHVzZUp1bXAgJiYgYXhpc0NvbGxhcHNlV2lkdGggJiYgcG9pbnRDb29yZCA8IHdpblNpemUgKiB0cmlnZ2VyQXJlYVswXSkge1xuICAgICAgICBiZWhhdmlvciA9ICdqdW1wJztcbiAgICAgICAgZGVsdGEgPSBwb2ludENvb3JkIC0gd2luU2l6ZSAqIHRyaWdnZXJBcmVhWzJdO1xuICAgICAgfSBlbHNlIGlmICh1c2VKdW1wICYmIGF4aXNDb2xsYXBzZVdpZHRoICYmIHBvaW50Q29vcmQgPiB3aW5TaXplICogKDEgLSB0cmlnZ2VyQXJlYVswXSkpIHtcbiAgICAgICAgYmVoYXZpb3IgPSAnanVtcCc7XG4gICAgICAgIGRlbHRhID0gcG9pbnRDb29yZCAtIHdpblNpemUgKiAoMSAtIHRyaWdnZXJBcmVhWzJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChkZWx0YSA9IHBvaW50Q29vcmQgLSB3aW5TaXplICogdHJpZ2dlckFyZWFbMV0pID49IDAgJiYgKGRlbHRhID0gcG9pbnRDb29yZCAtIHdpblNpemUgKiAoMSAtIHRyaWdnZXJBcmVhWzFdKSkgPD0gMCAmJiAoZGVsdGEgPSAwKTtcbiAgICAgIH1cbiAgICAgIGRlbHRhICo9IGxheW91dEluZm8uYXhpc0V4cGFuZFdpZHRoIC8gYXhpc0NvbGxhcHNlV2lkdGg7XG4gICAgICBkZWx0YSA/IHNsaWRlck1vdmUoZGVsdGEsIGF4aXNFeHBhbmRXaW5kb3csIGV4dGVudCwgJ2FsbCcpXG4gICAgICAvLyBBdm9pZCBub25zZW5zZSB0cmlnZXIgb24gbW91c2Vtb3ZlLlxuICAgICAgOiBiZWhhdmlvciA9ICdub25lJztcbiAgICB9XG4gICAgLy8gV2hlbiBzY3JlZW4gaXMgdG9vIG5hcnJvdywgbWFrZSBpdCB2aXNpYmxlIGFuZCBzbGlkYWJsZSwgYWx0aG91Z2ggaXQgaXMgaGFyZCB0byBpbnRlcmFjdC5cbiAgICBlbHNlIHtcbiAgICAgIHZhciB3aW5TaXplMiA9IGF4aXNFeHBhbmRXaW5kb3dbMV0gLSBheGlzRXhwYW5kV2luZG93WzBdO1xuICAgICAgdmFyIHBvcyA9IGV4dGVudFsxXSAqIHBvaW50Q29vcmQgLyB3aW5TaXplMjtcbiAgICAgIGF4aXNFeHBhbmRXaW5kb3cgPSBbbWF0aE1heCgwLCBwb3MgLSB3aW5TaXplMiAvIDIpXTtcbiAgICAgIGF4aXNFeHBhbmRXaW5kb3dbMV0gPSBtYXRoTWluKGV4dGVudFsxXSwgYXhpc0V4cGFuZFdpbmRvd1swXSArIHdpblNpemUyKTtcbiAgICAgIGF4aXNFeHBhbmRXaW5kb3dbMF0gPSBheGlzRXhwYW5kV2luZG93WzFdIC0gd2luU2l6ZTI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBheGlzRXhwYW5kV2luZG93OiBheGlzRXhwYW5kV2luZG93LFxuICAgICAgYmVoYXZpb3I6IGJlaGF2aW9yXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIFBhcmFsbGVsO1xufSgpO1xuZnVuY3Rpb24gcmVzdHJpY3QobGVuLCBleHRlbnQpIHtcbiAgcmV0dXJuIG1hdGhNaW4obWF0aE1heChsZW4sIGV4dGVudFswXSksIGV4dGVudFsxXSk7XG59XG5mdW5jdGlvbiBsYXlvdXRBeGlzV2l0aG91dEV4cGFuZChheGlzSW5kZXgsIGxheW91dEluZm8pIHtcbiAgdmFyIHN0ZXAgPSBsYXlvdXRJbmZvLmxheW91dExlbmd0aCAvIChsYXlvdXRJbmZvLmF4aXNDb3VudCAtIDEpO1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBzdGVwICogYXhpc0luZGV4LFxuICAgIGF4aXNOYW1lQXZhaWxhYmxlV2lkdGg6IHN0ZXAsXG4gICAgYXhpc0xhYmVsU2hvdzogdHJ1ZVxuICB9O1xufVxuZnVuY3Rpb24gbGF5b3V0QXhpc1dpdGhFeHBhbmQoYXhpc0luZGV4LCBsYXlvdXRJbmZvKSB7XG4gIHZhciBsYXlvdXRMZW5ndGggPSBsYXlvdXRJbmZvLmxheW91dExlbmd0aDtcbiAgdmFyIGF4aXNFeHBhbmRXaWR0aCA9IGxheW91dEluZm8uYXhpc0V4cGFuZFdpZHRoO1xuICB2YXIgYXhpc0NvdW50ID0gbGF5b3V0SW5mby5heGlzQ291bnQ7XG4gIHZhciBheGlzQ29sbGFwc2VXaWR0aCA9IGxheW91dEluZm8uYXhpc0NvbGxhcHNlV2lkdGg7XG4gIHZhciB3aW5Jbm5lckluZGljZXMgPSBsYXlvdXRJbmZvLndpbklubmVySW5kaWNlcztcbiAgdmFyIHBvc2l0aW9uO1xuICB2YXIgYXhpc05hbWVBdmFpbGFibGVXaWR0aCA9IGF4aXNDb2xsYXBzZVdpZHRoO1xuICB2YXIgYXhpc0xhYmVsU2hvdyA9IGZhbHNlO1xuICB2YXIgbmFtZVRydW5jYXRlTWF4V2lkdGg7XG4gIGlmIChheGlzSW5kZXggPCB3aW5Jbm5lckluZGljZXNbMF0pIHtcbiAgICBwb3NpdGlvbiA9IGF4aXNJbmRleCAqIGF4aXNDb2xsYXBzZVdpZHRoO1xuICAgIG5hbWVUcnVuY2F0ZU1heFdpZHRoID0gYXhpc0NvbGxhcHNlV2lkdGg7XG4gIH0gZWxzZSBpZiAoYXhpc0luZGV4IDw9IHdpbklubmVySW5kaWNlc1sxXSkge1xuICAgIHBvc2l0aW9uID0gbGF5b3V0SW5mby5heGlzRXhwYW5kV2luZG93MFBvcyArIGF4aXNJbmRleCAqIGF4aXNFeHBhbmRXaWR0aCAtIGxheW91dEluZm8uYXhpc0V4cGFuZFdpbmRvd1swXTtcbiAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoID0gYXhpc0V4cGFuZFdpZHRoO1xuICAgIGF4aXNMYWJlbFNob3cgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHBvc2l0aW9uID0gbGF5b3V0TGVuZ3RoIC0gKGF4aXNDb3VudCAtIDEgLSBheGlzSW5kZXgpICogYXhpc0NvbGxhcHNlV2lkdGg7XG4gICAgbmFtZVRydW5jYXRlTWF4V2lkdGggPSBheGlzQ29sbGFwc2VXaWR0aDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoOiBheGlzTmFtZUF2YWlsYWJsZVdpZHRoLFxuICAgIGF4aXNMYWJlbFNob3c6IGF4aXNMYWJlbFNob3csXG4gICAgbmFtZVRydW5jYXRlTWF4V2lkdGg6IG5hbWVUcnVuY2F0ZU1heFdpZHRoXG4gIH07XG59XG5leHBvcnQgZGVmYXVsdCBQYXJhbGxlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbi8qKlxyXG4gKiBQYXJhbGxlbCBjb29yZGluYXRlIHN5c3RlbSBjcmVhdGVyLlxyXG4gKi9cbmltcG9ydCBQYXJhbGxlbCBmcm9tICcuL1BhcmFsbGVsLmpzJztcbmltcG9ydCB7IFNJTkdMRV9SRUZFUlJJTkcgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmZ1bmN0aW9uIGNyZWF0ZVBhcmFsbGVsQ29vcmRTeXMoZWNNb2RlbCwgYXBpKSB7XG4gIHZhciBjb29yZFN5c0xpc3QgPSBbXTtcbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdwYXJhbGxlbCcsIGZ1bmN0aW9uIChwYXJhbGxlbE1vZGVsLCBpZHgpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBuZXcgUGFyYWxsZWwocGFyYWxsZWxNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICBjb29yZFN5cy5uYW1lID0gJ3BhcmFsbGVsXycgKyBpZHg7XG4gICAgY29vcmRTeXMucmVzaXplKHBhcmFsbGVsTW9kZWwsIGFwaSk7XG4gICAgcGFyYWxsZWxNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gY29vcmRTeXM7XG4gICAgY29vcmRTeXMubW9kZWwgPSBwYXJhbGxlbE1vZGVsO1xuICAgIGNvb3JkU3lzTGlzdC5wdXNoKGNvb3JkU3lzKTtcbiAgfSk7XG4gIC8vIEluamVjdCB0aGUgY29vcmRpbmF0ZVN5c3RlbXMgaW50byBzZXJpZXNNb2RlbFxuICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgaWYgKHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpID09PSAncGFyYWxsZWwnKSB7XG4gICAgICB2YXIgcGFyYWxsZWxNb2RlbCA9IHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3BhcmFsbGVsJywgU0lOR0xFX1JFRkVSUklORykubW9kZWxzWzBdO1xuICAgICAgc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IHBhcmFsbGVsTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY29vcmRTeXNMaXN0O1xufVxudmFyIHBhcmFsbGVsQ29vcmRTeXNDcmVhdG9yID0ge1xuICBjcmVhdGU6IGNyZWF0ZVBhcmFsbGVsQ29vcmRTeXNcbn07XG5leHBvcnQgZGVmYXVsdCBwYXJhbGxlbENvb3JkU3lzQ3JlYXRvcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///42744\n")},57483:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   P: () => (/* binding */ CartesianAxisModel)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98026);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15915);\n/* harmony import */ var _axisModelCommonMixin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12462);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar CartesianAxisModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(CartesianAxisModel, _super);\n  function CartesianAxisModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  CartesianAxisModel.prototype.getCoordSysModel = function () {\n    return this.getReferringComponents(\'grid\', _util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .SINGLE_REFERRING */ .US).models[0];\n  };\n  CartesianAxisModel.type = \'cartesian2dAxis\';\n  return CartesianAxisModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A);\n\nzrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.mixin(CartesianAxisModel, _axisModelCommonMixin_js__WEBPACK_IMPORTED_MODULE_4__/* .AxisModelCommonMixin */ .L);\n/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (CartesianAxisModel)));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc0ODMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWwuanM/MTM1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50LmpzJztcbmltcG9ydCB7IEF4aXNNb2RlbENvbW1vbk1peGluIH0gZnJvbSAnLi4vYXhpc01vZGVsQ29tbW9uTWl4aW4uanMnO1xuaW1wb3J0IHsgU0lOR0xFX1JFRkVSUklORyB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xudmFyIENhcnRlc2lhbkF4aXNNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDYXJ0ZXNpYW5BeGlzTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIENhcnRlc2lhbkF4aXNNb2RlbCgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgQ2FydGVzaWFuQXhpc01vZGVsLnByb3RvdHlwZS5nZXRDb29yZFN5c01vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ2dyaWQnLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG4gIH07XG4gIENhcnRlc2lhbkF4aXNNb2RlbC50eXBlID0gJ2NhcnRlc2lhbjJkQXhpcyc7XG4gIHJldHVybiBDYXJ0ZXNpYW5BeGlzTW9kZWw7XG59KENvbXBvbmVudE1vZGVsKTtcbmV4cG9ydCB7IENhcnRlc2lhbkF4aXNNb2RlbCB9O1xuenJVdGlsLm1peGluKENhcnRlc2lhbkF4aXNNb2RlbCwgQXhpc01vZGVsQ29tbW9uTWl4aW4pO1xuZXhwb3J0IGRlZmF1bHQgQ2FydGVzaWFuQXhpc01vZGVsOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///57483\n')},61504:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(15915);\n/* harmony import */ var _model_mixin_makeStyleMapper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32944);\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24326);\n/* harmony import */ var _axisModelCommonMixin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12462);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\nvar ParallelAxisModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(ParallelAxisModel, _super);\n  function ParallelAxisModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ParallelAxisModel.type;\n    /**\r\n     * @readOnly\r\n     */\n    _this.activeIntervals = [];\n    return _this;\n  }\n  ParallelAxisModel.prototype.getAreaSelectStyle = function () {\n    return (0,_model_mixin_makeStyleMapper_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)([['fill', 'color'], ['lineWidth', 'borderWidth'], ['stroke', 'borderColor'], ['width', 'width'], ['opacity', 'opacity']\n    // Option decal is in `DecalObject` but style.decal is in `PatternObject`.\n    // So do not transfer decal directly.\n    ])(this.getModel('areaSelectStyle'));\n  };\n  /**\r\n   * The code of this feature is put on AxisModel but not ParallelAxis,\r\n   * because axisModel can be alive after echarts updating but instance of\r\n   * ParallelAxis having been disposed. this._activeInterval should be kept\r\n   * when action dispatched (i.e. legend click).\r\n   *\r\n   * @param intervals `interval.length === 0` means set all active.\r\n   */\n  ParallelAxisModel.prototype.setActiveIntervals = function (intervals) {\n    var activeIntervals = this.activeIntervals = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone(intervals);\n    // Normalize\n    if (activeIntervals) {\n      for (var i = activeIntervals.length - 1; i >= 0; i--) {\n        _util_number_js__WEBPACK_IMPORTED_MODULE_3__/* .asc */ .Y6(activeIntervals[i]);\n      }\n    }\n  };\n  /**\r\n   * @param value When only attempting detect whether 'no activeIntervals set',\r\n   *        `value` is not needed to be input.\r\n   */\n  ParallelAxisModel.prototype.getActiveState = function (value) {\n    var activeIntervals = this.activeIntervals;\n    if (!activeIntervals.length) {\n      return 'normal';\n    }\n    if (value == null || isNaN(+value)) {\n      return 'inactive';\n    }\n    // Simple optimization\n    if (activeIntervals.length === 1) {\n      var interval = activeIntervals[0];\n      if (interval[0] <= value && value <= interval[1]) {\n        return 'active';\n      }\n    } else {\n      for (var i = 0, len = activeIntervals.length; i < len; i++) {\n        if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {\n          return 'active';\n        }\n      }\n    }\n    return 'inactive';\n  };\n  return ParallelAxisModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A);\nzrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.mixin(ParallelAxisModel, _axisModelCommonMixin_js__WEBPACK_IMPORTED_MODULE_5__/* .AxisModelCommonMixin */ .L);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ParallelAxisModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE1MDQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL3BhcmFsbGVsL0F4aXNNb2RlbC5qcz9kM2IwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBDb21wb25lbnRNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Db21wb25lbnQuanMnO1xuaW1wb3J0IG1ha2VTdHlsZU1hcHBlciBmcm9tICcuLi8uLi9tb2RlbC9taXhpbi9tYWtlU3R5bGVNYXBwZXIuanMnO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7XG5pbXBvcnQgeyBBeGlzTW9kZWxDb21tb25NaXhpbiB9IGZyb20gJy4uL2F4aXNNb2RlbENvbW1vbk1peGluLmpzJztcbnZhciBQYXJhbGxlbEF4aXNNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQYXJhbGxlbEF4aXNNb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gUGFyYWxsZWxBeGlzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IFBhcmFsbGVsQXhpc01vZGVsLnR5cGU7XG4gICAgLyoqXHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqL1xuICAgIF90aGlzLmFjdGl2ZUludGVydmFscyA9IFtdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBQYXJhbGxlbEF4aXNNb2RlbC5wcm90b3R5cGUuZ2V0QXJlYVNlbGVjdFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtYWtlU3R5bGVNYXBwZXIoW1snZmlsbCcsICdjb2xvciddLCBbJ2xpbmVXaWR0aCcsICdib3JkZXJXaWR0aCddLCBbJ3N0cm9rZScsICdib3JkZXJDb2xvciddLCBbJ3dpZHRoJywgJ3dpZHRoJ10sIFsnb3BhY2l0eScsICdvcGFjaXR5J11cbiAgICAvLyBPcHRpb24gZGVjYWwgaXMgaW4gYERlY2FsT2JqZWN0YCBidXQgc3R5bGUuZGVjYWwgaXMgaW4gYFBhdHRlcm5PYmplY3RgLlxuICAgIC8vIFNvIGRvIG5vdCB0cmFuc2ZlciBkZWNhbCBkaXJlY3RseS5cbiAgICBdKSh0aGlzLmdldE1vZGVsKCdhcmVhU2VsZWN0U3R5bGUnKSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFRoZSBjb2RlIG9mIHRoaXMgZmVhdHVyZSBpcyBwdXQgb24gQXhpc01vZGVsIGJ1dCBub3QgUGFyYWxsZWxBeGlzLFxyXG4gICAqIGJlY2F1c2UgYXhpc01vZGVsIGNhbiBiZSBhbGl2ZSBhZnRlciBlY2hhcnRzIHVwZGF0aW5nIGJ1dCBpbnN0YW5jZSBvZlxyXG4gICAqIFBhcmFsbGVsQXhpcyBoYXZpbmcgYmVlbiBkaXNwb3NlZC4gdGhpcy5fYWN0aXZlSW50ZXJ2YWwgc2hvdWxkIGJlIGtlcHRcclxuICAgKiB3aGVuIGFjdGlvbiBkaXNwYXRjaGVkIChpLmUuIGxlZ2VuZCBjbGljaykuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaW50ZXJ2YWxzIGBpbnRlcnZhbC5sZW5ndGggPT09IDBgIG1lYW5zIHNldCBhbGwgYWN0aXZlLlxyXG4gICAqL1xuICBQYXJhbGxlbEF4aXNNb2RlbC5wcm90b3R5cGUuc2V0QWN0aXZlSW50ZXJ2YWxzID0gZnVuY3Rpb24gKGludGVydmFscykge1xuICAgIHZhciBhY3RpdmVJbnRlcnZhbHMgPSB0aGlzLmFjdGl2ZUludGVydmFscyA9IHpyVXRpbC5jbG9uZShpbnRlcnZhbHMpO1xuICAgIC8vIE5vcm1hbGl6ZVxuICAgIGlmIChhY3RpdmVJbnRlcnZhbHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSBhY3RpdmVJbnRlcnZhbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbnVtYmVyVXRpbC5hc2MoYWN0aXZlSW50ZXJ2YWxzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB2YWx1ZSBXaGVuIG9ubHkgYXR0ZW1wdGluZyBkZXRlY3Qgd2hldGhlciAnbm8gYWN0aXZlSW50ZXJ2YWxzIHNldCcsXHJcbiAgICogICAgICAgIGB2YWx1ZWAgaXMgbm90IG5lZWRlZCB0byBiZSBpbnB1dC5cclxuICAgKi9cbiAgUGFyYWxsZWxBeGlzTW9kZWwucHJvdG90eXBlLmdldEFjdGl2ZVN0YXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGFjdGl2ZUludGVydmFscyA9IHRoaXMuYWN0aXZlSW50ZXJ2YWxzO1xuICAgIGlmICghYWN0aXZlSW50ZXJ2YWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICdub3JtYWwnO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBpc05hTigrdmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2luYWN0aXZlJztcbiAgICB9XG4gICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxuICAgIGlmIChhY3RpdmVJbnRlcnZhbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgaW50ZXJ2YWwgPSBhY3RpdmVJbnRlcnZhbHNbMF07XG4gICAgICBpZiAoaW50ZXJ2YWxbMF0gPD0gdmFsdWUgJiYgdmFsdWUgPD0gaW50ZXJ2YWxbMV0pIHtcbiAgICAgICAgcmV0dXJuICdhY3RpdmUnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYWN0aXZlSW50ZXJ2YWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChhY3RpdmVJbnRlcnZhbHNbaV1bMF0gPD0gdmFsdWUgJiYgdmFsdWUgPD0gYWN0aXZlSW50ZXJ2YWxzW2ldWzFdKSB7XG4gICAgICAgICAgcmV0dXJuICdhY3RpdmUnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnaW5hY3RpdmUnO1xuICB9O1xuICByZXR1cm4gUGFyYWxsZWxBeGlzTW9kZWw7XG59KENvbXBvbmVudE1vZGVsKTtcbnpyVXRpbC5taXhpbihQYXJhbGxlbEF4aXNNb2RlbCwgQXhpc01vZGVsQ29tbW9uTWl4aW4pO1xuZXhwb3J0IGRlZmF1bHQgUGFyYWxsZWxBeGlzTW9kZWw7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///61504\n")},68971:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ polarPrepareCustom)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n// import AngleAxis from './AngleAxis.js';\nfunction dataToCoordSize(dataSize, dataItem) {\n  // dataItem is necessary in log axis.\n  dataItem = dataItem || [0, 0];\n  return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map(['Radius', 'Angle'], function (dim, dimIdx) {\n    var getterName = 'get' + dim + 'Axis';\n    // TODO: TYPE Check Angle Axis\n    var axis = this[getterName]();\n    var val = dataItem[dimIdx];\n    var halfSize = dataSize[dimIdx] / 2;\n    var result = axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));\n    if (dim === 'Angle') {\n      result = result * Math.PI / 180;\n    }\n    return result;\n  }, this);\n}\nfunction polarPrepareCustom(coordSys) {\n  var radiusAxis = coordSys.getRadiusAxis();\n  var angleAxis = coordSys.getAngleAxis();\n  var radius = radiusAxis.getExtent();\n  radius[0] > radius[1] && radius.reverse();\n  return {\n    coordSys: {\n      type: 'polar',\n      cx: coordSys.cx,\n      cy: coordSys.cy,\n      r: radius[1],\n      r0: radius[0]\n    },\n    api: {\n      coord: function (data) {\n        var radius = radiusAxis.dataToRadius(data[0]);\n        var angle = angleAxis.dataToAngle(data[1]);\n        var coord = coordSys.coordToPoint([radius, angle]);\n        coord.push(radius, angle * Math.PI / 180);\n        return coord;\n      },\n      size: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.bind(dataToCoordSize, coordSys)\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg5NzEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvcG9sYXIvcHJlcGFyZUN1c3RvbS5qcz8wYTAxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG4vLyBpbXBvcnQgQW5nbGVBeGlzIGZyb20gJy4vQW5nbGVBeGlzLmpzJztcbmZ1bmN0aW9uIGRhdGFUb0Nvb3JkU2l6ZShkYXRhU2l6ZSwgZGF0YUl0ZW0pIHtcbiAgLy8gZGF0YUl0ZW0gaXMgbmVjZXNzYXJ5IGluIGxvZyBheGlzLlxuICBkYXRhSXRlbSA9IGRhdGFJdGVtIHx8IFswLCAwXTtcbiAgcmV0dXJuIHpyVXRpbC5tYXAoWydSYWRpdXMnLCAnQW5nbGUnXSwgZnVuY3Rpb24gKGRpbSwgZGltSWR4KSB7XG4gICAgdmFyIGdldHRlck5hbWUgPSAnZ2V0JyArIGRpbSArICdBeGlzJztcbiAgICAvLyBUT0RPOiBUWVBFIENoZWNrIEFuZ2xlIEF4aXNcbiAgICB2YXIgYXhpcyA9IHRoaXNbZ2V0dGVyTmFtZV0oKTtcbiAgICB2YXIgdmFsID0gZGF0YUl0ZW1bZGltSWR4XTtcbiAgICB2YXIgaGFsZlNpemUgPSBkYXRhU2l6ZVtkaW1JZHhdIC8gMjtcbiAgICB2YXIgcmVzdWx0ID0gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gYXhpcy5nZXRCYW5kV2lkdGgoKSA6IE1hdGguYWJzKGF4aXMuZGF0YVRvQ29vcmQodmFsIC0gaGFsZlNpemUpIC0gYXhpcy5kYXRhVG9Db29yZCh2YWwgKyBoYWxmU2l6ZSkpO1xuICAgIGlmIChkaW0gPT09ICdBbmdsZScpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIE1hdGguUEkgLyAxODA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHRoaXMpO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcG9sYXJQcmVwYXJlQ3VzdG9tKGNvb3JkU3lzKSB7XG4gIHZhciByYWRpdXNBeGlzID0gY29vcmRTeXMuZ2V0UmFkaXVzQXhpcygpO1xuICB2YXIgYW5nbGVBeGlzID0gY29vcmRTeXMuZ2V0QW5nbGVBeGlzKCk7XG4gIHZhciByYWRpdXMgPSByYWRpdXNBeGlzLmdldEV4dGVudCgpO1xuICByYWRpdXNbMF0gPiByYWRpdXNbMV0gJiYgcmFkaXVzLnJldmVyc2UoKTtcbiAgcmV0dXJuIHtcbiAgICBjb29yZFN5czoge1xuICAgICAgdHlwZTogJ3BvbGFyJyxcbiAgICAgIGN4OiBjb29yZFN5cy5jeCxcbiAgICAgIGN5OiBjb29yZFN5cy5jeSxcbiAgICAgIHI6IHJhZGl1c1sxXSxcbiAgICAgIHIwOiByYWRpdXNbMF1cbiAgICB9LFxuICAgIGFwaToge1xuICAgICAgY29vcmQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSByYWRpdXNBeGlzLmRhdGFUb1JhZGl1cyhkYXRhWzBdKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gYW5nbGVBeGlzLmRhdGFUb0FuZ2xlKGRhdGFbMV0pO1xuICAgICAgICB2YXIgY29vcmQgPSBjb29yZFN5cy5jb29yZFRvUG9pbnQoW3JhZGl1cywgYW5nbGVdKTtcbiAgICAgICAgY29vcmQucHVzaChyYWRpdXMsIGFuZ2xlICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgIHJldHVybiBjb29yZDtcbiAgICAgIH0sXG4gICAgICBzaXplOiB6clV0aWwuYmluZChkYXRhVG9Db29yZFNpemUsIGNvb3JkU3lzKVxuICAgIH1cbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///68971\n")},69718:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ parseGeoJSON)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _Region_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31024);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * Parse and decode geo json\r\n */\n\n\nfunction decode(json) {\n  if (!json.UTF8Encoding) {\n    return json;\n  }\n  var jsonCompressed = json;\n  var encodeScale = jsonCompressed.UTF8Scale;\n  if (encodeScale == null) {\n    encodeScale = 1024;\n  }\n  var features = jsonCompressed.features;\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(features, function (feature) {\n    var geometry = feature.geometry;\n    var encodeOffsets = geometry.encodeOffsets;\n    var coordinates = geometry.coordinates;\n    // Geometry may be appeded manually in the script after json loaded.\n    // In this case this geometry is usually not encoded.\n    if (!encodeOffsets) {\n      return;\n    }\n    switch (geometry.type) {\n      case 'LineString':\n        geometry.coordinates = decodeRing(coordinates, encodeOffsets, encodeScale);\n        break;\n      case 'Polygon':\n        decodeRings(coordinates, encodeOffsets, encodeScale);\n        break;\n      case 'MultiLineString':\n        decodeRings(coordinates, encodeOffsets, encodeScale);\n        break;\n      case 'MultiPolygon':\n        zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(coordinates, function (rings, idx) {\n          return decodeRings(rings, encodeOffsets[idx], encodeScale);\n        });\n    }\n  });\n  // Has been decoded\n  jsonCompressed.UTF8Encoding = false;\n  return jsonCompressed;\n}\nfunction decodeRings(rings, encodeOffsets, encodeScale) {\n  for (var c = 0; c < rings.length; c++) {\n    rings[c] = decodeRing(rings[c], encodeOffsets[c], encodeScale);\n  }\n}\nfunction decodeRing(coordinate, encodeOffsets, encodeScale) {\n  var result = [];\n  var prevX = encodeOffsets[0];\n  var prevY = encodeOffsets[1];\n  for (var i = 0; i < coordinate.length; i += 2) {\n    var x = coordinate.charCodeAt(i) - 64;\n    var y = coordinate.charCodeAt(i + 1) - 64;\n    // ZigZag decoding\n    x = x >> 1 ^ -(x & 1);\n    y = y >> 1 ^ -(y & 1);\n    // Delta deocding\n    x += prevX;\n    y += prevY;\n    prevX = x;\n    prevY = y;\n    // Dequantize\n    result.push([x / encodeScale, y / encodeScale]);\n  }\n  return result;\n}\nfunction parseGeoJSON(geoJson, nameProperty) {\n  geoJson = decode(geoJson);\n  return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.filter(geoJson.features, function (featureObj) {\n    // Output of mapshaper may have geometry null\n    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;\n  }), function (featureObj) {\n    var properties = featureObj.properties;\n    var geo = featureObj.geometry;\n    var geometries = [];\n    switch (geo.type) {\n      case 'Polygon':\n        var coordinates = geo.coordinates;\n        // According to the GeoJSON specification.\n        // First must be exterior, and the rest are all interior(holes).\n        geometries.push(new _Region_js__WEBPACK_IMPORTED_MODULE_1__/* .GeoJSONPolygonGeometry */ .m5(coordinates[0], coordinates.slice(1)));\n        break;\n      case 'MultiPolygon':\n        zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(geo.coordinates, function (item) {\n          if (item[0]) {\n            geometries.push(new _Region_js__WEBPACK_IMPORTED_MODULE_1__/* .GeoJSONPolygonGeometry */ .m5(item[0], item.slice(1)));\n          }\n        });\n        break;\n      case 'LineString':\n        geometries.push(new _Region_js__WEBPACK_IMPORTED_MODULE_1__/* .GeoJSONLineStringGeometry */ .nS([geo.coordinates]));\n        break;\n      case 'MultiLineString':\n        geometries.push(new _Region_js__WEBPACK_IMPORTED_MODULE_1__/* .GeoJSONLineStringGeometry */ .nS(geo.coordinates));\n    }\n    var region = new _Region_js__WEBPACK_IMPORTED_MODULE_1__/* .GeoJSONRegion */ .cn(properties[nameProperty || 'name'], geometries, properties.cp);\n    region.properties = properties;\n    return region;\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk3MTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2dlby9wYXJzZUdlb0pzb24uanM/YjA5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbi8qKlxyXG4gKiBQYXJzZSBhbmQgZGVjb2RlIGdlbyBqc29uXHJcbiAqL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBHZW9KU09OTGluZVN0cmluZ0dlb21ldHJ5LCBHZW9KU09OUG9seWdvbkdlb21ldHJ5LCBHZW9KU09OUmVnaW9uIH0gZnJvbSAnLi9SZWdpb24uanMnO1xuZnVuY3Rpb24gZGVjb2RlKGpzb24pIHtcbiAgaWYgKCFqc29uLlVURjhFbmNvZGluZykge1xuICAgIHJldHVybiBqc29uO1xuICB9XG4gIHZhciBqc29uQ29tcHJlc3NlZCA9IGpzb247XG4gIHZhciBlbmNvZGVTY2FsZSA9IGpzb25Db21wcmVzc2VkLlVURjhTY2FsZTtcbiAgaWYgKGVuY29kZVNjYWxlID09IG51bGwpIHtcbiAgICBlbmNvZGVTY2FsZSA9IDEwMjQ7XG4gIH1cbiAgdmFyIGZlYXR1cmVzID0ganNvbkNvbXByZXNzZWQuZmVhdHVyZXM7XG4gIHpyVXRpbC5lYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnk7XG4gICAgdmFyIGVuY29kZU9mZnNldHMgPSBnZW9tZXRyeS5lbmNvZGVPZmZzZXRzO1xuICAgIHZhciBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgIC8vIEdlb21ldHJ5IG1heSBiZSBhcHBlZGVkIG1hbnVhbGx5IGluIHRoZSBzY3JpcHQgYWZ0ZXIganNvbiBsb2FkZWQuXG4gICAgLy8gSW4gdGhpcyBjYXNlIHRoaXMgZ2VvbWV0cnkgaXMgdXN1YWxseSBub3QgZW5jb2RlZC5cbiAgICBpZiAoIWVuY29kZU9mZnNldHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XG4gICAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBkZWNvZGVSaW5nKGNvb3JkaW5hdGVzLCBlbmNvZGVPZmZzZXRzLCBlbmNvZGVTY2FsZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgIGRlY29kZVJpbmdzKGNvb3JkaW5hdGVzLCBlbmNvZGVPZmZzZXRzLCBlbmNvZGVTY2FsZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgICAgZGVjb2RlUmluZ3MoY29vcmRpbmF0ZXMsIGVuY29kZU9mZnNldHMsIGVuY29kZVNjYWxlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICB6clV0aWwuZWFjaChjb29yZGluYXRlcywgZnVuY3Rpb24gKHJpbmdzLCBpZHgpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb2RlUmluZ3MocmluZ3MsIGVuY29kZU9mZnNldHNbaWR4XSwgZW5jb2RlU2NhbGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICAvLyBIYXMgYmVlbiBkZWNvZGVkXG4gIGpzb25Db21wcmVzc2VkLlVURjhFbmNvZGluZyA9IGZhbHNlO1xuICByZXR1cm4ganNvbkNvbXByZXNzZWQ7XG59XG5mdW5jdGlvbiBkZWNvZGVSaW5ncyhyaW5ncywgZW5jb2RlT2Zmc2V0cywgZW5jb2RlU2NhbGUpIHtcbiAgZm9yICh2YXIgYyA9IDA7IGMgPCByaW5ncy5sZW5ndGg7IGMrKykge1xuICAgIHJpbmdzW2NdID0gZGVjb2RlUmluZyhyaW5nc1tjXSwgZW5jb2RlT2Zmc2V0c1tjXSwgZW5jb2RlU2NhbGUpO1xuICB9XG59XG5mdW5jdGlvbiBkZWNvZGVSaW5nKGNvb3JkaW5hdGUsIGVuY29kZU9mZnNldHMsIGVuY29kZVNjYWxlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHByZXZYID0gZW5jb2RlT2Zmc2V0c1swXTtcbiAgdmFyIHByZXZZID0gZW5jb2RlT2Zmc2V0c1sxXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHggPSBjb29yZGluYXRlLmNoYXJDb2RlQXQoaSkgLSA2NDtcbiAgICB2YXIgeSA9IGNvb3JkaW5hdGUuY2hhckNvZGVBdChpICsgMSkgLSA2NDtcbiAgICAvLyBaaWdaYWcgZGVjb2RpbmdcbiAgICB4ID0geCA+PiAxIF4gLSh4ICYgMSk7XG4gICAgeSA9IHkgPj4gMSBeIC0oeSAmIDEpO1xuICAgIC8vIERlbHRhIGRlb2NkaW5nXG4gICAgeCArPSBwcmV2WDtcbiAgICB5ICs9IHByZXZZO1xuICAgIHByZXZYID0geDtcbiAgICBwcmV2WSA9IHk7XG4gICAgLy8gRGVxdWFudGl6ZVxuICAgIHJlc3VsdC5wdXNoKFt4IC8gZW5jb2RlU2NhbGUsIHkgLyBlbmNvZGVTY2FsZV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZUdlb0pTT04oZ2VvSnNvbiwgbmFtZVByb3BlcnR5KSB7XG4gIGdlb0pzb24gPSBkZWNvZGUoZ2VvSnNvbik7XG4gIHJldHVybiB6clV0aWwubWFwKHpyVXRpbC5maWx0ZXIoZ2VvSnNvbi5mZWF0dXJlcywgZnVuY3Rpb24gKGZlYXR1cmVPYmopIHtcbiAgICAvLyBPdXRwdXQgb2YgbWFwc2hhcGVyIG1heSBoYXZlIGdlb21ldHJ5IG51bGxcbiAgICByZXR1cm4gZmVhdHVyZU9iai5nZW9tZXRyeSAmJiBmZWF0dXJlT2JqLnByb3BlcnRpZXMgJiYgZmVhdHVyZU9iai5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggPiAwO1xuICB9KSwgZnVuY3Rpb24gKGZlYXR1cmVPYmopIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IGZlYXR1cmVPYmoucHJvcGVydGllcztcbiAgICB2YXIgZ2VvID0gZmVhdHVyZU9iai5nZW9tZXRyeTtcbiAgICB2YXIgZ2VvbWV0cmllcyA9IFtdO1xuICAgIHN3aXRjaCAoZ2VvLnR5cGUpIHtcbiAgICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW8uY29vcmRpbmF0ZXM7XG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgR2VvSlNPTiBzcGVjaWZpY2F0aW9uLlxuICAgICAgICAvLyBGaXJzdCBtdXN0IGJlIGV4dGVyaW9yLCBhbmQgdGhlIHJlc3QgYXJlIGFsbCBpbnRlcmlvcihob2xlcykuXG4gICAgICAgIGdlb21ldHJpZXMucHVzaChuZXcgR2VvSlNPTlBvbHlnb25HZW9tZXRyeShjb29yZGluYXRlc1swXSwgY29vcmRpbmF0ZXMuc2xpY2UoMSkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICB6clV0aWwuZWFjaChnZW8uY29vcmRpbmF0ZXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaWYgKGl0ZW1bMF0pIHtcbiAgICAgICAgICAgIGdlb21ldHJpZXMucHVzaChuZXcgR2VvSlNPTlBvbHlnb25HZW9tZXRyeShpdGVtWzBdLCBpdGVtLnNsaWNlKDEpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgZ2VvbWV0cmllcy5wdXNoKG5ldyBHZW9KU09OTGluZVN0cmluZ0dlb21ldHJ5KFtnZW8uY29vcmRpbmF0ZXNdKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgICAgZ2VvbWV0cmllcy5wdXNoKG5ldyBHZW9KU09OTGluZVN0cmluZ0dlb21ldHJ5KGdlby5jb29yZGluYXRlcykpO1xuICAgIH1cbiAgICB2YXIgcmVnaW9uID0gbmV3IEdlb0pTT05SZWdpb24ocHJvcGVydGllc1tuYW1lUHJvcGVydHkgfHwgJ25hbWUnXSwgZ2VvbWV0cmllcywgcHJvcGVydGllcy5jcCk7XG4gICAgcmVnaW9uLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgIHJldHVybiByZWdpb247XG4gIH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///69718\n")},71674:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _axisDefault_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13286);\n/* harmony import */ var _model_Model_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43172);\n/* harmony import */ var _axisModelCommonMixin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12462);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(15915);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\nvar valueAxisDefault = _axisDefault_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A.value;\nfunction defaultsShow(opt, show) {\n  return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults({\n    show: show\n  }, opt);\n}\nvar RadarModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__extends */ .C6)(RadarModel, _super);\n  function RadarModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = RadarModel.type;\n    return _this;\n  }\n  RadarModel.prototype.optionUpdated = function () {\n    var boundaryGap = this.get('boundaryGap');\n    var splitNumber = this.get('splitNumber');\n    var scale = this.get('scale');\n    var axisLine = this.get('axisLine');\n    var axisTick = this.get('axisTick');\n    // let axisType = this.get('axisType');\n    var axisLabel = this.get('axisLabel');\n    var nameTextStyle = this.get('axisName');\n    var showName = this.get(['axisName', 'show']);\n    var nameFormatter = this.get(['axisName', 'formatter']);\n    var nameGap = this.get('axisNameGap');\n    var triggerEvent = this.get('triggerEvent');\n    var indicatorModels = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map(this.get('indicator') || [], function (indicatorOpt) {\n      // PENDING\n      if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {\n        indicatorOpt.min = 0;\n      } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {\n        indicatorOpt.max = 0;\n      }\n      var iNameTextStyle = nameTextStyle;\n      if (indicatorOpt.color != null) {\n        iNameTextStyle = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults({\n          color: indicatorOpt.color\n        }, nameTextStyle);\n      }\n      // Use same configuration\n      var innerIndicatorOpt = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.merge(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.clone(indicatorOpt), {\n        boundaryGap: boundaryGap,\n        splitNumber: splitNumber,\n        scale: scale,\n        axisLine: axisLine,\n        axisTick: axisTick,\n        // axisType: axisType,\n        axisLabel: axisLabel,\n        // Compatible with 2 and use text\n        name: indicatorOpt.text,\n        showName: showName,\n        nameLocation: 'end',\n        nameGap: nameGap,\n        // min: 0,\n        nameTextStyle: iNameTextStyle,\n        triggerEvent: triggerEvent\n      }, false);\n      if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString(nameFormatter)) {\n        var indName = innerIndicatorOpt.name;\n        innerIndicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');\n      } else if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction(nameFormatter)) {\n        innerIndicatorOpt.name = nameFormatter(innerIndicatorOpt.name, innerIndicatorOpt);\n      }\n      var model = new _model_Model_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A(innerIndicatorOpt, null, this.ecModel);\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.mixin(model, _axisModelCommonMixin_js__WEBPACK_IMPORTED_MODULE_4__/* .AxisModelCommonMixin */ .L.prototype);\n      // For triggerEvent.\n      model.mainType = 'radar';\n      model.componentIndex = this.componentIndex;\n      return model;\n    }, this);\n    this._indicatorModels = indicatorModels;\n  };\n  RadarModel.prototype.getIndicatorModels = function () {\n    return this._indicatorModels;\n  };\n  RadarModel.type = 'radar';\n  RadarModel.defaultOption = {\n    // zlevel: 0,\n    z: 0,\n    center: ['50%', '50%'],\n    radius: '75%',\n    startAngle: 90,\n    axisName: {\n      show: true\n      // formatter: null\n      // textStyle: {}\n    },\n    boundaryGap: [0, 0],\n    splitNumber: 5,\n    axisNameGap: 15,\n    scale: false,\n    // Polygon or circle\n    shape: 'polygon',\n    axisLine: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.merge({\n      lineStyle: {\n        color: '#bbb'\n      }\n    }, valueAxisDefault.axisLine),\n    axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),\n    axisTick: defaultsShow(valueAxisDefault.axisTick, false),\n    // axisType: 'value',\n    splitLine: defaultsShow(valueAxisDefault.splitLine, true),\n    splitArea: defaultsShow(valueAxisDefault.splitArea, true),\n    // {text, min, max}\n    indicator: []\n  };\n  return RadarModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadarModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE2NzQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9yYWRhci9SYWRhck1vZGVsLmpzP2YwZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IGF4aXNEZWZhdWx0IGZyb20gJy4uL2F4aXNEZWZhdWx0LmpzJztcbmltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Nb2RlbC5qcyc7XG5pbXBvcnQgeyBBeGlzTW9kZWxDb21tb25NaXhpbiB9IGZyb20gJy4uL2F4aXNNb2RlbENvbW1vbk1peGluLmpzJztcbmltcG9ydCBDb21wb25lbnRNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Db21wb25lbnQuanMnO1xudmFyIHZhbHVlQXhpc0RlZmF1bHQgPSBheGlzRGVmYXVsdC52YWx1ZTtcbmZ1bmN0aW9uIGRlZmF1bHRzU2hvdyhvcHQsIHNob3cpIHtcbiAgcmV0dXJuIHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgc2hvdzogc2hvd1xuICB9LCBvcHQpO1xufVxudmFyIFJhZGFyTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUmFkYXJNb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gUmFkYXJNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gUmFkYXJNb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBSYWRhck1vZGVsLnByb3RvdHlwZS5vcHRpb25VcGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBib3VuZGFyeUdhcCA9IHRoaXMuZ2V0KCdib3VuZGFyeUdhcCcpO1xuICAgIHZhciBzcGxpdE51bWJlciA9IHRoaXMuZ2V0KCdzcGxpdE51bWJlcicpO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0KCdzY2FsZScpO1xuICAgIHZhciBheGlzTGluZSA9IHRoaXMuZ2V0KCdheGlzTGluZScpO1xuICAgIHZhciBheGlzVGljayA9IHRoaXMuZ2V0KCdheGlzVGljaycpO1xuICAgIC8vIGxldCBheGlzVHlwZSA9IHRoaXMuZ2V0KCdheGlzVHlwZScpO1xuICAgIHZhciBheGlzTGFiZWwgPSB0aGlzLmdldCgnYXhpc0xhYmVsJyk7XG4gICAgdmFyIG5hbWVUZXh0U3R5bGUgPSB0aGlzLmdldCgnYXhpc05hbWUnKTtcbiAgICB2YXIgc2hvd05hbWUgPSB0aGlzLmdldChbJ2F4aXNOYW1lJywgJ3Nob3cnXSk7XG4gICAgdmFyIG5hbWVGb3JtYXR0ZXIgPSB0aGlzLmdldChbJ2F4aXNOYW1lJywgJ2Zvcm1hdHRlciddKTtcbiAgICB2YXIgbmFtZUdhcCA9IHRoaXMuZ2V0KCdheGlzTmFtZUdhcCcpO1xuICAgIHZhciB0cmlnZ2VyRXZlbnQgPSB0aGlzLmdldCgndHJpZ2dlckV2ZW50Jyk7XG4gICAgdmFyIGluZGljYXRvck1vZGVscyA9IHpyVXRpbC5tYXAodGhpcy5nZXQoJ2luZGljYXRvcicpIHx8IFtdLCBmdW5jdGlvbiAoaW5kaWNhdG9yT3B0KSB7XG4gICAgICAvLyBQRU5ESU5HXG4gICAgICBpZiAoaW5kaWNhdG9yT3B0Lm1heCAhPSBudWxsICYmIGluZGljYXRvck9wdC5tYXggPiAwICYmICFpbmRpY2F0b3JPcHQubWluKSB7XG4gICAgICAgIGluZGljYXRvck9wdC5taW4gPSAwO1xuICAgICAgfSBlbHNlIGlmIChpbmRpY2F0b3JPcHQubWluICE9IG51bGwgJiYgaW5kaWNhdG9yT3B0Lm1pbiA8IDAgJiYgIWluZGljYXRvck9wdC5tYXgpIHtcbiAgICAgICAgaW5kaWNhdG9yT3B0Lm1heCA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgaU5hbWVUZXh0U3R5bGUgPSBuYW1lVGV4dFN0eWxlO1xuICAgICAgaWYgKGluZGljYXRvck9wdC5jb2xvciAhPSBudWxsKSB7XG4gICAgICAgIGlOYW1lVGV4dFN0eWxlID0genJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICBjb2xvcjogaW5kaWNhdG9yT3B0LmNvbG9yXG4gICAgICAgIH0sIG5hbWVUZXh0U3R5bGUpO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNhbWUgY29uZmlndXJhdGlvblxuICAgICAgdmFyIGlubmVySW5kaWNhdG9yT3B0ID0genJVdGlsLm1lcmdlKHpyVXRpbC5jbG9uZShpbmRpY2F0b3JPcHQpLCB7XG4gICAgICAgIGJvdW5kYXJ5R2FwOiBib3VuZGFyeUdhcCxcbiAgICAgICAgc3BsaXROdW1iZXI6IHNwbGl0TnVtYmVyLFxuICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgIGF4aXNMaW5lOiBheGlzTGluZSxcbiAgICAgICAgYXhpc1RpY2s6IGF4aXNUaWNrLFxuICAgICAgICAvLyBheGlzVHlwZTogYXhpc1R5cGUsXG4gICAgICAgIGF4aXNMYWJlbDogYXhpc0xhYmVsLFxuICAgICAgICAvLyBDb21wYXRpYmxlIHdpdGggMiBhbmQgdXNlIHRleHRcbiAgICAgICAgbmFtZTogaW5kaWNhdG9yT3B0LnRleHQsXG4gICAgICAgIHNob3dOYW1lOiBzaG93TmFtZSxcbiAgICAgICAgbmFtZUxvY2F0aW9uOiAnZW5kJyxcbiAgICAgICAgbmFtZUdhcDogbmFtZUdhcCxcbiAgICAgICAgLy8gbWluOiAwLFxuICAgICAgICBuYW1lVGV4dFN0eWxlOiBpTmFtZVRleHRTdHlsZSxcbiAgICAgICAgdHJpZ2dlckV2ZW50OiB0cmlnZ2VyRXZlbnRcbiAgICAgIH0sIGZhbHNlKTtcbiAgICAgIGlmICh6clV0aWwuaXNTdHJpbmcobmFtZUZvcm1hdHRlcikpIHtcbiAgICAgICAgdmFyIGluZE5hbWUgPSBpbm5lckluZGljYXRvck9wdC5uYW1lO1xuICAgICAgICBpbm5lckluZGljYXRvck9wdC5uYW1lID0gbmFtZUZvcm1hdHRlci5yZXBsYWNlKCd7dmFsdWV9JywgaW5kTmFtZSAhPSBudWxsID8gaW5kTmFtZSA6ICcnKTtcbiAgICAgIH0gZWxzZSBpZiAoenJVdGlsLmlzRnVuY3Rpb24obmFtZUZvcm1hdHRlcikpIHtcbiAgICAgICAgaW5uZXJJbmRpY2F0b3JPcHQubmFtZSA9IG5hbWVGb3JtYXR0ZXIoaW5uZXJJbmRpY2F0b3JPcHQubmFtZSwgaW5uZXJJbmRpY2F0b3JPcHQpO1xuICAgICAgfVxuICAgICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKGlubmVySW5kaWNhdG9yT3B0LCBudWxsLCB0aGlzLmVjTW9kZWwpO1xuICAgICAgenJVdGlsLm1peGluKG1vZGVsLCBBeGlzTW9kZWxDb21tb25NaXhpbi5wcm90b3R5cGUpO1xuICAgICAgLy8gRm9yIHRyaWdnZXJFdmVudC5cbiAgICAgIG1vZGVsLm1haW5UeXBlID0gJ3JhZGFyJztcbiAgICAgIG1vZGVsLmNvbXBvbmVudEluZGV4ID0gdGhpcy5jb21wb25lbnRJbmRleDtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9pbmRpY2F0b3JNb2RlbHMgPSBpbmRpY2F0b3JNb2RlbHM7XG4gIH07XG4gIFJhZGFyTW9kZWwucHJvdG90eXBlLmdldEluZGljYXRvck1vZGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kaWNhdG9yTW9kZWxzO1xuICB9O1xuICBSYWRhck1vZGVsLnR5cGUgPSAncmFkYXInO1xuICBSYWRhck1vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgLy8gemxldmVsOiAwLFxuICAgIHo6IDAsXG4gICAgY2VudGVyOiBbJzUwJScsICc1MCUnXSxcbiAgICByYWRpdXM6ICc3NSUnLFxuICAgIHN0YXJ0QW5nbGU6IDkwLFxuICAgIGF4aXNOYW1lOiB7XG4gICAgICBzaG93OiB0cnVlXG4gICAgICAvLyBmb3JtYXR0ZXI6IG51bGxcbiAgICAgIC8vIHRleHRTdHlsZToge31cbiAgICB9LFxuICAgIGJvdW5kYXJ5R2FwOiBbMCwgMF0sXG4gICAgc3BsaXROdW1iZXI6IDUsXG4gICAgYXhpc05hbWVHYXA6IDE1LFxuICAgIHNjYWxlOiBmYWxzZSxcbiAgICAvLyBQb2x5Z29uIG9yIGNpcmNsZVxuICAgIHNoYXBlOiAncG9seWdvbicsXG4gICAgYXhpc0xpbmU6IHpyVXRpbC5tZXJnZSh7XG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgY29sb3I6ICcjYmJiJ1xuICAgICAgfVxuICAgIH0sIHZhbHVlQXhpc0RlZmF1bHQuYXhpc0xpbmUpLFxuICAgIGF4aXNMYWJlbDogZGVmYXVsdHNTaG93KHZhbHVlQXhpc0RlZmF1bHQuYXhpc0xhYmVsLCBmYWxzZSksXG4gICAgYXhpc1RpY2s6IGRlZmF1bHRzU2hvdyh2YWx1ZUF4aXNEZWZhdWx0LmF4aXNUaWNrLCBmYWxzZSksXG4gICAgLy8gYXhpc1R5cGU6ICd2YWx1ZScsXG4gICAgc3BsaXRMaW5lOiBkZWZhdWx0c1Nob3codmFsdWVBeGlzRGVmYXVsdC5zcGxpdExpbmUsIHRydWUpLFxuICAgIHNwbGl0QXJlYTogZGVmYXVsdHNTaG93KHZhbHVlQXhpc0RlZmF1bHQuc3BsaXRBcmVhLCB0cnVlKSxcbiAgICAvLyB7dGV4dCwgbWluLCBtYXh9XG4gICAgaW5kaWNhdG9yOiBbXVxuICB9O1xuICByZXR1cm4gUmFkYXJNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuZXhwb3J0IGRlZmF1bHQgUmFkYXJNb2RlbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///71674\n")},74345:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ cartesian_Grid)\n});\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/axisHelper.js\nvar axisHelper = __webpack_require__(99031);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/BoundingRect.js\nvar BoundingRect = __webpack_require__(29308);\n;// ./node_modules/echarts/lib/coord/cartesian/Cartesian.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar Cartesian = /** @class */function () {\n  function Cartesian(name) {\n    this.type = 'cartesian';\n    this._dimList = [];\n    this._axes = {};\n    this.name = name || '';\n  }\n  Cartesian.prototype.getAxis = function (dim) {\n    return this._axes[dim];\n  };\n  Cartesian.prototype.getAxes = function () {\n    return util.map(this._dimList, function (dim) {\n      return this._axes[dim];\n    }, this);\n  };\n  Cartesian.prototype.getAxesByScale = function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return util.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  };\n  Cartesian.prototype.addAxis = function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n    this._dimList.push(dim);\n  };\n  return Cartesian;\n}();\n;\n/* harmony default export */ const cartesian_Cartesian = (Cartesian);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/matrix.js\nvar matrix = __webpack_require__(45587);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/vector.js\nvar vector = __webpack_require__(83509);\n;// ./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar cartesian2DDimensions = ['x', 'y'];\nfunction canCalculateAffineTransform(scale) {\n  return scale.type === 'interval' || scale.type === 'time';\n}\nvar Cartesian2D = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(Cartesian2D, _super);\n  function Cartesian2D() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = 'cartesian2d';\n    _this.dimensions = cartesian2DDimensions;\n    return _this;\n  }\n  /**\r\n   * Calculate an affine transform matrix if two axes are time or value.\r\n   * It's mainly for accelartion on the large time series data.\r\n   */\n  Cartesian2D.prototype.calcAffineTransform = function () {\n    this._transform = this._invTransform = null;\n    var xAxisScale = this.getAxis('x').scale;\n    var yAxisScale = this.getAxis('y').scale;\n    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {\n      return;\n    }\n    var xScaleExtent = xAxisScale.getExtent();\n    var yScaleExtent = yAxisScale.getExtent();\n    var start = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);\n    var end = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);\n    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];\n    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];\n    if (!xScaleSpan || !yScaleSpan) {\n      return;\n    }\n    // Accelerate data to point calculation on the special large time series data.\n    var scaleX = (end[0] - start[0]) / xScaleSpan;\n    var scaleY = (end[1] - start[1]) / yScaleSpan;\n    var translateX = start[0] - xScaleExtent[0] * scaleX;\n    var translateY = start[1] - yScaleExtent[0] * scaleY;\n    var m = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];\n    this._invTransform = (0,matrix.invert)([], m);\n  };\n  /**\r\n   * Base axis will be used on stacking.\r\n   */\n  Cartesian2D.prototype.getBaseAxis = function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  };\n  Cartesian2D.prototype.containPoint = function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  };\n  Cartesian2D.prototype.containData = function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  };\n  Cartesian2D.prototype.containZone = function (data1, data2) {\n    var zoneDiag1 = this.dataToPoint(data1);\n    var zoneDiag2 = this.dataToPoint(data2);\n    var area = this.getArea();\n    var zone = new BoundingRect/* default */.A(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);\n    return area.intersect(zone);\n  };\n  Cartesian2D.prototype.dataToPoint = function (data, clamp, out) {\n    out = out || [];\n    var xVal = data[0];\n    var yVal = data[1];\n    // Fast path\n    if (this._transform\n    // It's supported that if data is like `[Inifity, 123]`, where only Y pixel calculated.\n    && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {\n      return (0,vector.applyTransform)(out, data, this._transform);\n    }\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp));\n    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp));\n    return out;\n  };\n  Cartesian2D.prototype.clampData = function (data, out) {\n    var xScale = this.getAxis('x').scale;\n    var yScale = this.getAxis('y').scale;\n    var xAxisExtent = xScale.getExtent();\n    var yAxisExtent = yScale.getExtent();\n    var x = xScale.parse(data[0]);\n    var y = yScale.parse(data[1]);\n    out = out || [];\n    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));\n    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));\n    return out;\n  };\n  Cartesian2D.prototype.pointToData = function (point, clamp) {\n    var out = [];\n    if (this._invTransform) {\n      return (0,vector.applyTransform)(out, point, this._invTransform);\n    }\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp);\n    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp);\n    return out;\n  };\n  Cartesian2D.prototype.getOtherAxis = function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  };\n  /**\r\n   * Get rect area of cartesian.\r\n   * Area will have a contain function to determine if a point is in the coordinate system.\r\n   */\n  Cartesian2D.prototype.getArea = function (tolerance) {\n    tolerance = tolerance || 0;\n    var xExtent = this.getAxis('x').getGlobalExtent();\n    var yExtent = this.getAxis('y').getGlobalExtent();\n    var x = Math.min(xExtent[0], xExtent[1]) - tolerance;\n    var y = Math.min(yExtent[0], yExtent[1]) - tolerance;\n    var width = Math.max(xExtent[0], xExtent[1]) - x + tolerance;\n    var height = Math.max(yExtent[0], yExtent[1]) - y + tolerance;\n    return new BoundingRect/* default */.A(x, y, width, height);\n  };\n  return Cartesian2D;\n}(cartesian_Cartesian);\n;\n/* harmony default export */ const cartesian_Cartesian2D = (Cartesian2D);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/Axis.js\nvar Axis = __webpack_require__(1727);\n;// ./node_modules/echarts/lib/coord/cartesian/Axis2D.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar Axis2D = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(Axis2D, _super);\n  function Axis2D(dim, scale, coordExtent, axisType, position) {\n    var _this = _super.call(this, dim, scale, coordExtent) || this;\n    /**\r\n     * Index of axis, can be used as key\r\n     * Injected outside.\r\n     */\n    _this.index = 0;\n    _this.type = axisType || 'value';\n    _this.position = position || 'bottom';\n    return _this;\n  }\n  Axis2D.prototype.isHorizontal = function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  };\n  /**\r\n   * Each item cooresponds to this.getExtent(), which\r\n   * means globalExtent[0] may greater than globalExtent[1],\r\n   * unless `asc` is input.\r\n   *\r\n   * @param {boolean} [asc]\r\n   * @return {Array.<number>}\r\n   */\n  Axis2D.prototype.getGlobalExtent = function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  };\n  Axis2D.prototype.pointToData = function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  };\n  /**\r\n   * Set ordinalSortInfo\r\n   * @param info new OrdinalSortInfo\r\n   */\n  Axis2D.prototype.setCategorySortInfo = function (info) {\n    if (this.type !== 'category') {\n      return false;\n    }\n    this.model.option.categorySortInfo = info;\n    this.scale.setSortInfo(info);\n  };\n  return Axis2D;\n}(Axis/* default */.A);\n/* harmony default export */ const cartesian_Axis2D = (Axis2D);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js\nvar cartesianAxisHelper = __webpack_require__(96878);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/scale/helper.js\nvar helper = __webpack_require__(67071);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/axisAlignTicks.js\nvar axisAlignTicks = __webpack_require__(3486);\n;// ./node_modules/echarts/lib/coord/cartesian/Grid.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * Grid is a region which contains at most 4 cartesian systems\r\n *\r\n * TODO Default cartesian\r\n */\n\n\n\n\n\n\n\n\n\nvar Grid = /** @class */function () {\n  function Grid(gridModel, ecModel, api) {\n    // FIXME:TS where used (different from registered type 'cartesian2d')?\n    this.type = 'grid';\n    this._coordsMap = {};\n    this._coordsList = [];\n    this._axesMap = {};\n    this._axesList = [];\n    this.axisPointerEnabled = true;\n    this.dimensions = cartesian2DDimensions;\n    this._initCartesian(gridModel, ecModel, api);\n    this.model = gridModel;\n  }\n  Grid.prototype.getRect = function () {\n    return this._rect;\n  };\n  Grid.prototype.update = function (ecModel, api) {\n    var axesMap = this._axesMap;\n    this._updateScale(ecModel, this.model);\n    function updateAxisTicks(axes) {\n      var alignTo;\n      // Axis is added in order of axisIndex.\n      var axesIndices = (0,util.keys)(axes);\n      var len = axesIndices.length;\n      if (!len) {\n        return;\n      }\n      var axisNeedsAlign = [];\n      // Process once and calculate the ticks for those don't use alignTicks.\n      for (var i = len - 1; i >= 0; i--) {\n        var idx = +axesIndices[i]; // Convert to number.\n        var axis = axes[idx];\n        var model = axis.model;\n        var scale = axis.scale;\n        if (\n        // Only value and log axis without interval support alignTicks.\n        (0,helper/* isIntervalOrLogScale */.rf)(scale) && model.get('alignTicks') && model.get('interval') == null) {\n          axisNeedsAlign.push(axis);\n        } else {\n          (0,axisHelper/* niceScaleExtent */.af)(scale, model);\n          if ((0,helper/* isIntervalOrLogScale */.rf)(scale)) {\n            // Can only align to interval or log axis.\n            alignTo = axis;\n          }\n        }\n      }\n      ;\n      // All axes has set alignTicks. Pick the first one.\n      // PENDING. Should we find the axis that both set interval, min, max and align to this one?\n      if (axisNeedsAlign.length) {\n        if (!alignTo) {\n          alignTo = axisNeedsAlign.pop();\n          (0,axisHelper/* niceScaleExtent */.af)(alignTo.scale, alignTo.model);\n        }\n        (0,util.each)(axisNeedsAlign, function (axis) {\n          (0,axisAlignTicks/* alignScaleTicks */.m)(axis.scale, axis.model, alignTo.scale);\n        });\n      }\n    }\n    updateAxisTicks(axesMap.x);\n    updateAxisTicks(axesMap.y);\n    // Key: axisDim_axisIndex, value: boolean, whether onZero target.\n    var onZeroRecords = {};\n    (0,util.each)(axesMap.x, function (xAxis) {\n      fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);\n    });\n    (0,util.each)(axesMap.y, function (yAxis) {\n      fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);\n    });\n    // Resize again if containLabel is enabled\n    // FIXME It may cause getting wrong grid size in data processing stage\n    this.resize(this.model, api);\n  };\n  /**\r\n   * Resize the grid\r\n   */\n  Grid.prototype.resize = function (gridModel, api, ignoreContainLabel) {\n    var boxLayoutParams = gridModel.getBoxLayoutParams();\n    var isContainLabel = !ignoreContainLabel && gridModel.get('containLabel');\n    var gridRect = (0,layout/* getLayoutRect */.dV)(boxLayoutParams, {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    this._rect = gridRect;\n    var axesList = this._axesList;\n    adjustAxes();\n    // Minus label size\n    if (isContainLabel) {\n      (0,util.each)(axesList, function (axis) {\n        if (!axis.model.get(['axisLabel', 'inside'])) {\n          var labelUnionRect = (0,axisHelper/* estimateLabelUnionRect */.Og)(axis);\n          if (labelUnionRect) {\n            var dim = axis.isHorizontal() ? 'height' : 'width';\n            var margin = axis.model.get(['axisLabel', 'margin']);\n            gridRect[dim] -= labelUnionRect[dim] + margin;\n            if (axis.position === 'top') {\n              gridRect.y += labelUnionRect.height + margin;\n            } else if (axis.position === 'left') {\n              gridRect.x += labelUnionRect.width + margin;\n            }\n          }\n        }\n      });\n      adjustAxes();\n    }\n    (0,util.each)(this._coordsList, function (coord) {\n      // Calculate affine matrix to accelerate the data to point transform.\n      // If all the axes scales are time or value.\n      coord.calcAffineTransform();\n    });\n    function adjustAxes() {\n      (0,util.each)(axesList, function (axis) {\n        var isHorizontal = axis.isHorizontal();\n        var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n        var idx = axis.inverse ? 1 : 0;\n        axis.setExtent(extent[idx], extent[1 - idx]);\n        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n      });\n    }\n  };\n  Grid.prototype.getAxis = function (dim, axisIndex) {\n    var axesMapOnDim = this._axesMap[dim];\n    if (axesMapOnDim != null) {\n      return axesMapOnDim[axisIndex || 0];\n    }\n  };\n  Grid.prototype.getAxes = function () {\n    return this._axesList.slice();\n  };\n  Grid.prototype.getCartesian = function (xAxisIndex, yAxisIndex) {\n    if (xAxisIndex != null && yAxisIndex != null) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      return this._coordsMap[key];\n    }\n    if ((0,util.isObject)(xAxisIndex)) {\n      yAxisIndex = xAxisIndex.yAxisIndex;\n      xAxisIndex = xAxisIndex.xAxisIndex;\n    }\n    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n      if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n        return coordList[i];\n      }\n    }\n  };\n  Grid.prototype.getCartesians = function () {\n    return this._coordsList.slice();\n  };\n  /**\r\n   * @implements\r\n   */\n  Grid.prototype.convertToPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n  };\n  /**\r\n   * @implements\r\n   */\n  Grid.prototype.convertFromPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n  };\n  Grid.prototype._findConvertTarget = function (finder) {\n    var seriesModel = finder.seriesModel;\n    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis', model/* SINGLE_REFERRING */.US).models[0];\n    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis', model/* SINGLE_REFERRING */.US).models[0];\n    var gridModel = finder.gridModel;\n    var coordsList = this._coordsList;\n    var cartesian;\n    var axis;\n    if (seriesModel) {\n      cartesian = seriesModel.coordinateSystem;\n      (0,util.indexOf)(coordsList, cartesian) < 0 && (cartesian = null);\n    } else if (xAxisModel && yAxisModel) {\n      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    } else if (xAxisModel) {\n      axis = this.getAxis('x', xAxisModel.componentIndex);\n    } else if (yAxisModel) {\n      axis = this.getAxis('y', yAxisModel.componentIndex);\n    }\n    // Lowest priority.\n    else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n    return {\n      cartesian: cartesian,\n      axis: axis\n    };\n  };\n  /**\r\n   * @implements\r\n   */\n  Grid.prototype.containPoint = function (point) {\n    var coord = this._coordsList[0];\n    if (coord) {\n      return coord.containPoint(point);\n    }\n  };\n  /**\r\n   * Initialize cartesian coordinate systems\r\n   */\n  Grid.prototype._initCartesian = function (gridModel, ecModel, api) {\n    var _this = this;\n    var grid = this;\n    var axisPositionUsed = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false\n    };\n    var axesMap = {\n      x: {},\n      y: {}\n    };\n    var axesCount = {\n      x: 0,\n      y: 0\n    };\n    // Create axis\n    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n    if (!axesCount.x || !axesCount.y) {\n      // Roll back when there no either x or y axis\n      this._axesMap = {};\n      this._axesList = [];\n      return;\n    }\n    this._axesMap = axesMap;\n    // Create cartesian2d\n    (0,util.each)(axesMap.x, function (xAxis, xAxisIndex) {\n      (0,util.each)(axesMap.y, function (yAxis, yAxisIndex) {\n        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n        var cartesian = new cartesian_Cartesian2D(key);\n        cartesian.master = _this;\n        cartesian.model = gridModel;\n        _this._coordsMap[key] = cartesian;\n        _this._coordsList.push(cartesian);\n        cartesian.addAxis(xAxis);\n        cartesian.addAxis(yAxis);\n      });\n    });\n    function createAxisCreator(dimName) {\n      return function (axisModel, idx) {\n        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {\n          return;\n        }\n        var axisPosition = axisModel.get('position');\n        if (dimName === 'x') {\n          // Fix position\n          if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n            // Default bottom of X\n            axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';\n          }\n        } else {\n          // Fix position\n          if (axisPosition !== 'left' && axisPosition !== 'right') {\n            // Default left of Y\n            axisPosition = axisPositionUsed.left ? 'right' : 'left';\n          }\n        }\n        axisPositionUsed[axisPosition] = true;\n        var axis = new cartesian_Axis2D(dimName, (0,axisHelper/* createScaleByModel */.f$)(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n        var isCategory = axis.type === 'category';\n        axis.onBand = isCategory && axisModel.get('boundaryGap');\n        axis.inverse = axisModel.get('inverse');\n        // Inject axis into axisModel\n        axisModel.axis = axis;\n        // Inject axisModel into axis\n        axis.model = axisModel;\n        // Inject grid info axis\n        axis.grid = grid;\n        // Index of axis, can be used as key\n        axis.index = idx;\n        grid._axesList.push(axis);\n        axesMap[dimName][idx] = axis;\n        axesCount[dimName]++;\n      };\n    }\n  };\n  /**\r\n   * Update cartesian properties from series.\r\n   */\n  Grid.prototype._updateScale = function (ecModel, gridModel) {\n    // Reset scale\n    (0,util.each)(this._axesList, function (axis) {\n      axis.scale.setExtent(Infinity, -Infinity);\n      if (axis.type === 'category') {\n        var categorySortInfo = axis.model.get('categorySortInfo');\n        axis.scale.setSortInfo(categorySortInfo);\n      }\n    });\n    ecModel.eachSeries(function (seriesModel) {\n      if ((0,cartesianAxisHelper/* isCartesian2DSeries */.gO)(seriesModel)) {\n        var axesModelMap = (0,cartesianAxisHelper/* findAxisModels */.LR)(seriesModel);\n        var xAxisModel = axesModelMap.xAxisModel;\n        var yAxisModel = axesModelMap.yAxisModel;\n        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {\n          return;\n        }\n        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        var data = seriesModel.getData();\n        var xAxis = cartesian.getAxis('x');\n        var yAxis = cartesian.getAxis('y');\n        unionExtent(data, xAxis);\n        unionExtent(data, yAxis);\n      }\n    }, this);\n    function unionExtent(data, axis) {\n      (0,util.each)((0,axisHelper/* getDataDimensionsOnAxis */.wq)(data, axis.dim), function (dim) {\n        axis.scale.unionExtentFromData(data, dim);\n      });\n    }\n  };\n  /**\r\n   * @param dim 'x' or 'y' or 'auto' or null/undefined\r\n   */\n  Grid.prototype.getTooltipAxes = function (dim) {\n    var baseAxes = [];\n    var otherAxes = [];\n    (0,util.each)(this.getCartesians(), function (cartesian) {\n      var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n      var otherAxis = cartesian.getOtherAxis(baseAxis);\n      (0,util.indexOf)(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n      (0,util.indexOf)(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n    });\n    return {\n      baseAxes: baseAxes,\n      otherAxes: otherAxes\n    };\n  };\n  Grid.create = function (ecModel, api) {\n    var grids = [];\n    ecModel.eachComponent('grid', function (gridModel, idx) {\n      var grid = new Grid(gridModel, ecModel, api);\n      grid.name = 'grid_' + idx;\n      // dataSampling requires axis extent, so resize\n      // should be performed in create stage.\n      grid.resize(gridModel, api, true);\n      gridModel.coordinateSystem = grid;\n      grids.push(grid);\n    });\n    // Inject the coordinateSystems into seriesModel\n    ecModel.eachSeries(function (seriesModel) {\n      if (!(0,cartesianAxisHelper/* isCartesian2DSeries */.gO)(seriesModel)) {\n        return;\n      }\n      var axesModelMap = (0,cartesianAxisHelper/* findAxisModels */.LR)(seriesModel);\n      var xAxisModel = axesModelMap.xAxisModel;\n      var yAxisModel = axesModelMap.yAxisModel;\n      var gridModel = xAxisModel.getCoordSysModel();\n      if (false) {}\n      var grid = gridModel.coordinateSystem;\n      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    });\n    return grids;\n  };\n  // For deciding which dimensions to use when creating list data\n  Grid.dimensions = cartesian2DDimensions;\n  return Grid;\n}();\n/**\r\n * Check if the axis is used in the specified grid.\r\n */\nfunction isAxisUsedInTheGrid(axisModel, gridModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis,\n// Key: see `getOnZeroRecordKey`\nonZeroRecords) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];\n  };\n  // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxisOnZeroOf;\n  var axisModel = axis.model;\n  var onZero = axisModel.get(['axisLine', 'onZero']);\n  var onZeroAxisIndex = axisModel.get(['axisLine', 'onZeroAxisIndex']);\n  if (!onZero) {\n    return;\n  }\n  // If target axis is specified.\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];\n    }\n  } else {\n    // Find the first available other axis.\n    for (var idx in otherAxes) {\n      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx])\n      // Consider that two Y axes on one value axis,\n      // if both onZero, the two Y axes overlap.\n      && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {\n        otherAxisOnZeroOf = otherAxes[idx];\n        break;\n      }\n    }\n  }\n  if (otherAxisOnZeroOf) {\n    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;\n  }\n  function getOnZeroRecordKey(axis) {\n    return axis.dim + '_' + axis.index;\n  }\n}\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && (0,axisHelper/* ifAxisCrossZero */.JJ)(axis);\n}\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1];\n  // Fast transform\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n/* harmony default export */ const cartesian_Grid = (Grid);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQzNDUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4uanM/OTgyMSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbjJELmpzPzA1ZDUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQuanM/NDc3YiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0dyaWQuanM/MjA2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xudmFyIENhcnRlc2lhbiA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhcnRlc2lhbihuYW1lKSB7XG4gICAgdGhpcy50eXBlID0gJ2NhcnRlc2lhbic7XG4gICAgdGhpcy5fZGltTGlzdCA9IFtdO1xuICAgIHRoaXMuX2F4ZXMgPSB7fTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICcnO1xuICB9XG4gIENhcnRlc2lhbi5wcm90b3R5cGUuZ2V0QXhpcyA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgICByZXR1cm4gdGhpcy5fYXhlc1tkaW1dO1xuICB9O1xuICBDYXJ0ZXNpYW4ucHJvdG90eXBlLmdldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHpyVXRpbC5tYXAodGhpcy5fZGltTGlzdCwgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2F4ZXNbZGltXTtcbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgQ2FydGVzaWFuLnByb3RvdHlwZS5nZXRBeGVzQnlTY2FsZSA9IGZ1bmN0aW9uIChzY2FsZVR5cGUpIHtcbiAgICBzY2FsZVR5cGUgPSBzY2FsZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4genJVdGlsLmZpbHRlcih0aGlzLmdldEF4ZXMoKSwgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgIHJldHVybiBheGlzLnNjYWxlLnR5cGUgPT09IHNjYWxlVHlwZTtcbiAgICB9KTtcbiAgfTtcbiAgQ2FydGVzaWFuLnByb3RvdHlwZS5hZGRBeGlzID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICB2YXIgZGltID0gYXhpcy5kaW07XG4gICAgdGhpcy5fYXhlc1tkaW1dID0gYXhpcztcbiAgICB0aGlzLl9kaW1MaXN0LnB1c2goZGltKTtcbiAgfTtcbiAgcmV0dXJuIENhcnRlc2lhbjtcbn0oKTtcbjtcbmV4cG9ydCBkZWZhdWx0IENhcnRlc2lhbjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IEJvdW5kaW5nUmVjdCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcyc7XG5pbXBvcnQgQ2FydGVzaWFuIGZyb20gJy4vQ2FydGVzaWFuLmpzJztcbmltcG9ydCB7IGludmVydCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzJztcbmltcG9ydCB7IGFwcGx5VHJhbnNmb3JtIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS92ZWN0b3IuanMnO1xuZXhwb3J0IHZhciBjYXJ0ZXNpYW4yRERpbWVuc2lvbnMgPSBbJ3gnLCAneSddO1xuZnVuY3Rpb24gY2FuQ2FsY3VsYXRlQWZmaW5lVHJhbnNmb3JtKHNjYWxlKSB7XG4gIHJldHVybiBzY2FsZS50eXBlID09PSAnaW50ZXJ2YWwnIHx8IHNjYWxlLnR5cGUgPT09ICd0aW1lJztcbn1cbnZhciBDYXJ0ZXNpYW4yRCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDYXJ0ZXNpYW4yRCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gQ2FydGVzaWFuMkQoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9ICdjYXJ0ZXNpYW4yZCc7XG4gICAgX3RoaXMuZGltZW5zaW9ucyA9IGNhcnRlc2lhbjJERGltZW5zaW9ucztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIGFuIGFmZmluZSB0cmFuc2Zvcm0gbWF0cml4IGlmIHR3byBheGVzIGFyZSB0aW1lIG9yIHZhbHVlLlxyXG4gICAqIEl0J3MgbWFpbmx5IGZvciBhY2NlbGFydGlvbiBvbiB0aGUgbGFyZ2UgdGltZSBzZXJpZXMgZGF0YS5cclxuICAgKi9cbiAgQ2FydGVzaWFuMkQucHJvdG90eXBlLmNhbGNBZmZpbmVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdHJhbnNmb3JtID0gdGhpcy5faW52VHJhbnNmb3JtID0gbnVsbDtcbiAgICB2YXIgeEF4aXNTY2FsZSA9IHRoaXMuZ2V0QXhpcygneCcpLnNjYWxlO1xuICAgIHZhciB5QXhpc1NjYWxlID0gdGhpcy5nZXRBeGlzKCd5Jykuc2NhbGU7XG4gICAgaWYgKCFjYW5DYWxjdWxhdGVBZmZpbmVUcmFuc2Zvcm0oeEF4aXNTY2FsZSkgfHwgIWNhbkNhbGN1bGF0ZUFmZmluZVRyYW5zZm9ybSh5QXhpc1NjYWxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgeFNjYWxlRXh0ZW50ID0geEF4aXNTY2FsZS5nZXRFeHRlbnQoKTtcbiAgICB2YXIgeVNjYWxlRXh0ZW50ID0geUF4aXNTY2FsZS5nZXRFeHRlbnQoKTtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLmRhdGFUb1BvaW50KFt4U2NhbGVFeHRlbnRbMF0sIHlTY2FsZUV4dGVudFswXV0pO1xuICAgIHZhciBlbmQgPSB0aGlzLmRhdGFUb1BvaW50KFt4U2NhbGVFeHRlbnRbMV0sIHlTY2FsZUV4dGVudFsxXV0pO1xuICAgIHZhciB4U2NhbGVTcGFuID0geFNjYWxlRXh0ZW50WzFdIC0geFNjYWxlRXh0ZW50WzBdO1xuICAgIHZhciB5U2NhbGVTcGFuID0geVNjYWxlRXh0ZW50WzFdIC0geVNjYWxlRXh0ZW50WzBdO1xuICAgIGlmICgheFNjYWxlU3BhbiB8fCAheVNjYWxlU3Bhbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBBY2NlbGVyYXRlIGRhdGEgdG8gcG9pbnQgY2FsY3VsYXRpb24gb24gdGhlIHNwZWNpYWwgbGFyZ2UgdGltZSBzZXJpZXMgZGF0YS5cbiAgICB2YXIgc2NhbGVYID0gKGVuZFswXSAtIHN0YXJ0WzBdKSAvIHhTY2FsZVNwYW47XG4gICAgdmFyIHNjYWxlWSA9IChlbmRbMV0gLSBzdGFydFsxXSkgLyB5U2NhbGVTcGFuO1xuICAgIHZhciB0cmFuc2xhdGVYID0gc3RhcnRbMF0gLSB4U2NhbGVFeHRlbnRbMF0gKiBzY2FsZVg7XG4gICAgdmFyIHRyYW5zbGF0ZVkgPSBzdGFydFsxXSAtIHlTY2FsZUV4dGVudFswXSAqIHNjYWxlWTtcbiAgICB2YXIgbSA9IHRoaXMuX3RyYW5zZm9ybSA9IFtzY2FsZVgsIDAsIDAsIHNjYWxlWSwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWV07XG4gICAgdGhpcy5faW52VHJhbnNmb3JtID0gaW52ZXJ0KFtdLCBtKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQmFzZSBheGlzIHdpbGwgYmUgdXNlZCBvbiBzdGFja2luZy5cclxuICAgKi9cbiAgQ2FydGVzaWFuMkQucHJvdG90eXBlLmdldEJhc2VBeGlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF4ZXNCeVNjYWxlKCdvcmRpbmFsJylbMF0gfHwgdGhpcy5nZXRBeGVzQnlTY2FsZSgndGltZScpWzBdIHx8IHRoaXMuZ2V0QXhpcygneCcpO1xuICB9O1xuICBDYXJ0ZXNpYW4yRC5wcm90b3R5cGUuY29udGFpblBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgdmFyIGF4aXNYID0gdGhpcy5nZXRBeGlzKCd4Jyk7XG4gICAgdmFyIGF4aXNZID0gdGhpcy5nZXRBeGlzKCd5Jyk7XG4gICAgcmV0dXJuIGF4aXNYLmNvbnRhaW4oYXhpc1gudG9Mb2NhbENvb3JkKHBvaW50WzBdKSkgJiYgYXhpc1kuY29udGFpbihheGlzWS50b0xvY2FsQ29vcmQocG9pbnRbMV0pKTtcbiAgfTtcbiAgQ2FydGVzaWFuMkQucHJvdG90eXBlLmNvbnRhaW5EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBeGlzKCd4JykuY29udGFpbkRhdGEoZGF0YVswXSkgJiYgdGhpcy5nZXRBeGlzKCd5JykuY29udGFpbkRhdGEoZGF0YVsxXSk7XG4gIH07XG4gIENhcnRlc2lhbjJELnByb3RvdHlwZS5jb250YWluWm9uZSA9IGZ1bmN0aW9uIChkYXRhMSwgZGF0YTIpIHtcbiAgICB2YXIgem9uZURpYWcxID0gdGhpcy5kYXRhVG9Qb2ludChkYXRhMSk7XG4gICAgdmFyIHpvbmVEaWFnMiA9IHRoaXMuZGF0YVRvUG9pbnQoZGF0YTIpO1xuICAgIHZhciBhcmVhID0gdGhpcy5nZXRBcmVhKCk7XG4gICAgdmFyIHpvbmUgPSBuZXcgQm91bmRpbmdSZWN0KHpvbmVEaWFnMVswXSwgem9uZURpYWcxWzFdLCB6b25lRGlhZzJbMF0gLSB6b25lRGlhZzFbMF0sIHpvbmVEaWFnMlsxXSAtIHpvbmVEaWFnMVsxXSk7XG4gICAgcmV0dXJuIGFyZWEuaW50ZXJzZWN0KHpvbmUpO1xuICB9O1xuICBDYXJ0ZXNpYW4yRC5wcm90b3R5cGUuZGF0YVRvUG9pbnQgPSBmdW5jdGlvbiAoZGF0YSwgY2xhbXAsIG91dCkge1xuICAgIG91dCA9IG91dCB8fCBbXTtcbiAgICB2YXIgeFZhbCA9IGRhdGFbMF07XG4gICAgdmFyIHlWYWwgPSBkYXRhWzFdO1xuICAgIC8vIEZhc3QgcGF0aFxuICAgIGlmICh0aGlzLl90cmFuc2Zvcm1cbiAgICAvLyBJdCdzIHN1cHBvcnRlZCB0aGF0IGlmIGRhdGEgaXMgbGlrZSBgW0luaWZpdHksIDEyM11gLCB3aGVyZSBvbmx5IFkgcGl4ZWwgY2FsY3VsYXRlZC5cbiAgICAmJiB4VmFsICE9IG51bGwgJiYgaXNGaW5pdGUoeFZhbCkgJiYgeVZhbCAhPSBudWxsICYmIGlzRmluaXRlKHlWYWwpKSB7XG4gICAgICByZXR1cm4gYXBwbHlUcmFuc2Zvcm0ob3V0LCBkYXRhLCB0aGlzLl90cmFuc2Zvcm0pO1xuICAgIH1cbiAgICB2YXIgeEF4aXMgPSB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgICB2YXIgeUF4aXMgPSB0aGlzLmdldEF4aXMoJ3knKTtcbiAgICBvdXRbMF0gPSB4QXhpcy50b0dsb2JhbENvb3JkKHhBeGlzLmRhdGFUb0Nvb3JkKHhWYWwsIGNsYW1wKSk7XG4gICAgb3V0WzFdID0geUF4aXMudG9HbG9iYWxDb29yZCh5QXhpcy5kYXRhVG9Db29yZCh5VmFsLCBjbGFtcCkpO1xuICAgIHJldHVybiBvdXQ7XG4gIH07XG4gIENhcnRlc2lhbjJELnByb3RvdHlwZS5jbGFtcERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgb3V0KSB7XG4gICAgdmFyIHhTY2FsZSA9IHRoaXMuZ2V0QXhpcygneCcpLnNjYWxlO1xuICAgIHZhciB5U2NhbGUgPSB0aGlzLmdldEF4aXMoJ3knKS5zY2FsZTtcbiAgICB2YXIgeEF4aXNFeHRlbnQgPSB4U2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIHlBeGlzRXh0ZW50ID0geVNjYWxlLmdldEV4dGVudCgpO1xuICAgIHZhciB4ID0geFNjYWxlLnBhcnNlKGRhdGFbMF0pO1xuICAgIHZhciB5ID0geVNjYWxlLnBhcnNlKGRhdGFbMV0pO1xuICAgIG91dCA9IG91dCB8fCBbXTtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihNYXRoLm1heChNYXRoLm1pbih4QXhpc0V4dGVudFswXSwgeEF4aXNFeHRlbnRbMV0pLCB4KSwgTWF0aC5tYXgoeEF4aXNFeHRlbnRbMF0sIHhBeGlzRXh0ZW50WzFdKSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5taW4oeUF4aXNFeHRlbnRbMF0sIHlBeGlzRXh0ZW50WzFdKSwgeSksIE1hdGgubWF4KHlBeGlzRXh0ZW50WzBdLCB5QXhpc0V4dGVudFsxXSkpO1xuICAgIHJldHVybiBvdXQ7XG4gIH07XG4gIENhcnRlc2lhbjJELnByb3RvdHlwZS5wb2ludFRvRGF0YSA9IGZ1bmN0aW9uIChwb2ludCwgY2xhbXApIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgaWYgKHRoaXMuX2ludlRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIGFwcGx5VHJhbnNmb3JtKG91dCwgcG9pbnQsIHRoaXMuX2ludlRyYW5zZm9ybSk7XG4gICAgfVxuICAgIHZhciB4QXhpcyA9IHRoaXMuZ2V0QXhpcygneCcpO1xuICAgIHZhciB5QXhpcyA9IHRoaXMuZ2V0QXhpcygneScpO1xuICAgIG91dFswXSA9IHhBeGlzLmNvb3JkVG9EYXRhKHhBeGlzLnRvTG9jYWxDb29yZChwb2ludFswXSksIGNsYW1wKTtcbiAgICBvdXRbMV0gPSB5QXhpcy5jb29yZFRvRGF0YSh5QXhpcy50b0xvY2FsQ29vcmQocG9pbnRbMV0pLCBjbGFtcCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbiAgQ2FydGVzaWFuMkQucHJvdG90eXBlLmdldE90aGVyQXhpcyA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXhpcyhheGlzLmRpbSA9PT0gJ3gnID8gJ3knIDogJ3gnKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IHJlY3QgYXJlYSBvZiBjYXJ0ZXNpYW4uXHJcbiAgICogQXJlYSB3aWxsIGhhdmUgYSBjb250YWluIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhIHBvaW50IGlzIGluIHRoZSBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgKi9cbiAgQ2FydGVzaWFuMkQucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbiAodG9sZXJhbmNlKSB7XG4gICAgdG9sZXJhbmNlID0gdG9sZXJhbmNlIHx8IDA7XG4gICAgdmFyIHhFeHRlbnQgPSB0aGlzLmdldEF4aXMoJ3gnKS5nZXRHbG9iYWxFeHRlbnQoKTtcbiAgICB2YXIgeUV4dGVudCA9IHRoaXMuZ2V0QXhpcygneScpLmdldEdsb2JhbEV4dGVudCgpO1xuICAgIHZhciB4ID0gTWF0aC5taW4oeEV4dGVudFswXSwgeEV4dGVudFsxXSkgLSB0b2xlcmFuY2U7XG4gICAgdmFyIHkgPSBNYXRoLm1pbih5RXh0ZW50WzBdLCB5RXh0ZW50WzFdKSAtIHRvbGVyYW5jZTtcbiAgICB2YXIgd2lkdGggPSBNYXRoLm1heCh4RXh0ZW50WzBdLCB4RXh0ZW50WzFdKSAtIHggKyB0b2xlcmFuY2U7XG4gICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KHlFeHRlbnRbMF0sIHlFeHRlbnRbMV0pIC0geSArIHRvbGVyYW5jZTtcbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgfTtcbiAgcmV0dXJuIENhcnRlc2lhbjJEO1xufShDYXJ0ZXNpYW4pO1xuO1xuZXhwb3J0IGRlZmF1bHQgQ2FydGVzaWFuMkQ7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBBeGlzIGZyb20gJy4uL0F4aXMuanMnO1xudmFyIEF4aXMyRCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhBeGlzMkQsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEF4aXMyRChkaW0sIHNjYWxlLCBjb29yZEV4dGVudCwgYXhpc1R5cGUsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGltLCBzY2FsZSwgY29vcmRFeHRlbnQpIHx8IHRoaXM7XG4gICAgLyoqXHJcbiAgICAgKiBJbmRleCBvZiBheGlzLCBjYW4gYmUgdXNlZCBhcyBrZXlcclxuICAgICAqIEluamVjdGVkIG91dHNpZGUuXHJcbiAgICAgKi9cbiAgICBfdGhpcy5pbmRleCA9IDA7XG4gICAgX3RoaXMudHlwZSA9IGF4aXNUeXBlIHx8ICd2YWx1ZSc7XG4gICAgX3RoaXMucG9zaXRpb24gPSBwb3NpdGlvbiB8fCAnYm90dG9tJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgQXhpczJELnByb3RvdHlwZS5pc0hvcml6b250YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfTtcbiAgLyoqXHJcbiAgICogRWFjaCBpdGVtIGNvb3Jlc3BvbmRzIHRvIHRoaXMuZ2V0RXh0ZW50KCksIHdoaWNoXHJcbiAgICogbWVhbnMgZ2xvYmFsRXh0ZW50WzBdIG1heSBncmVhdGVyIHRoYW4gZ2xvYmFsRXh0ZW50WzFdLFxyXG4gICAqIHVubGVzcyBgYXNjYCBpcyBpbnB1dC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzY11cclxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cclxuICAgKi9cbiAgQXhpczJELnByb3RvdHlwZS5nZXRHbG9iYWxFeHRlbnQgPSBmdW5jdGlvbiAoYXNjKSB7XG4gICAgdmFyIHJldCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgcmV0WzBdID0gdGhpcy50b0dsb2JhbENvb3JkKHJldFswXSk7XG4gICAgcmV0WzFdID0gdGhpcy50b0dsb2JhbENvb3JkKHJldFsxXSk7XG4gICAgYXNjICYmIHJldFswXSA+IHJldFsxXSAmJiByZXQucmV2ZXJzZSgpO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIEF4aXMyRC5wcm90b3R5cGUucG9pbnRUb0RhdGEgPSBmdW5jdGlvbiAocG9pbnQsIGNsYW1wKSB7XG4gICAgcmV0dXJuIHRoaXMuY29vcmRUb0RhdGEodGhpcy50b0xvY2FsQ29vcmQocG9pbnRbdGhpcy5kaW0gPT09ICd4JyA/IDAgOiAxXSksIGNsYW1wKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU2V0IG9yZGluYWxTb3J0SW5mb1xyXG4gICAqIEBwYXJhbSBpbmZvIG5ldyBPcmRpbmFsU29ydEluZm9cclxuICAgKi9cbiAgQXhpczJELnByb3RvdHlwZS5zZXRDYXRlZ29yeVNvcnRJbmZvID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICBpZiAodGhpcy50eXBlICE9PSAnY2F0ZWdvcnknKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubW9kZWwub3B0aW9uLmNhdGVnb3J5U29ydEluZm8gPSBpbmZvO1xuICAgIHRoaXMuc2NhbGUuc2V0U29ydEluZm8oaW5mbyk7XG4gIH07XG4gIHJldHVybiBBeGlzMkQ7XG59KEF4aXMpO1xuZXhwb3J0IGRlZmF1bHQgQXhpczJEOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLyoqXHJcbiAqIEdyaWQgaXMgYSByZWdpb24gd2hpY2ggY29udGFpbnMgYXQgbW9zdCA0IGNhcnRlc2lhbiBzeXN0ZW1zXHJcbiAqXHJcbiAqIFRPRE8gRGVmYXVsdCBjYXJ0ZXNpYW5cclxuICovXG5pbXBvcnQgeyBpc09iamVjdCwgZWFjaCwgaW5kZXhPZiwgcmV0cmlldmUzLCBrZXlzIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGdldExheW91dFJlY3QgfSBmcm9tICcuLi8uLi91dGlsL2xheW91dC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTY2FsZUJ5TW9kZWwsIGlmQXhpc0Nyb3NzWmVybywgbmljZVNjYWxlRXh0ZW50LCBlc3RpbWF0ZUxhYmVsVW5pb25SZWN0LCBnZXREYXRhRGltZW5zaW9uc09uQXhpcyB9IGZyb20gJy4uLy4uL2Nvb3JkL2F4aXNIZWxwZXIuanMnO1xuaW1wb3J0IENhcnRlc2lhbjJELCB7IGNhcnRlc2lhbjJERGltZW5zaW9ucyB9IGZyb20gJy4vQ2FydGVzaWFuMkQuanMnO1xuaW1wb3J0IEF4aXMyRCBmcm9tICcuL0F4aXMyRC5qcyc7XG5pbXBvcnQgeyBTSU5HTEVfUkVGRVJSSU5HIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG5pbXBvcnQgeyBpc0NhcnRlc2lhbjJEU2VyaWVzLCBmaW5kQXhpc01vZGVscyB9IGZyb20gJy4vY2FydGVzaWFuQXhpc0hlbHBlci5qcyc7XG5pbXBvcnQgeyBpc0ludGVydmFsT3JMb2dTY2FsZSB9IGZyb20gJy4uLy4uL3NjYWxlL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBhbGlnblNjYWxlVGlja3MgfSBmcm9tICcuLi9heGlzQWxpZ25UaWNrcy5qcyc7XG52YXIgR3JpZCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdyaWQoZ3JpZE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAvLyBGSVhNRTpUUyB3aGVyZSB1c2VkIChkaWZmZXJlbnQgZnJvbSByZWdpc3RlcmVkIHR5cGUgJ2NhcnRlc2lhbjJkJyk/XG4gICAgdGhpcy50eXBlID0gJ2dyaWQnO1xuICAgIHRoaXMuX2Nvb3Jkc01hcCA9IHt9O1xuICAgIHRoaXMuX2Nvb3Jkc0xpc3QgPSBbXTtcbiAgICB0aGlzLl9heGVzTWFwID0ge307XG4gICAgdGhpcy5fYXhlc0xpc3QgPSBbXTtcbiAgICB0aGlzLmF4aXNQb2ludGVyRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gY2FydGVzaWFuMkREaW1lbnNpb25zO1xuICAgIHRoaXMuX2luaXRDYXJ0ZXNpYW4oZ3JpZE1vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgIHRoaXMubW9kZWwgPSBncmlkTW9kZWw7XG4gIH1cbiAgR3JpZC5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgfTtcbiAgR3JpZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBheGVzTWFwID0gdGhpcy5fYXhlc01hcDtcbiAgICB0aGlzLl91cGRhdGVTY2FsZShlY01vZGVsLCB0aGlzLm1vZGVsKTtcbiAgICBmdW5jdGlvbiB1cGRhdGVBeGlzVGlja3MoYXhlcykge1xuICAgICAgdmFyIGFsaWduVG87XG4gICAgICAvLyBBeGlzIGlzIGFkZGVkIGluIG9yZGVyIG9mIGF4aXNJbmRleC5cbiAgICAgIHZhciBheGVzSW5kaWNlcyA9IGtleXMoYXhlcyk7XG4gICAgICB2YXIgbGVuID0gYXhlc0luZGljZXMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGF4aXNOZWVkc0FsaWduID0gW107XG4gICAgICAvLyBQcm9jZXNzIG9uY2UgYW5kIGNhbGN1bGF0ZSB0aGUgdGlja3MgZm9yIHRob3NlIGRvbid0IHVzZSBhbGlnblRpY2tzLlxuICAgICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBpZHggPSArYXhlc0luZGljZXNbaV07IC8vIENvbnZlcnQgdG8gbnVtYmVyLlxuICAgICAgICB2YXIgYXhpcyA9IGF4ZXNbaWR4XTtcbiAgICAgICAgdmFyIG1vZGVsID0gYXhpcy5tb2RlbDtcbiAgICAgICAgdmFyIHNjYWxlID0gYXhpcy5zY2FsZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBPbmx5IHZhbHVlIGFuZCBsb2cgYXhpcyB3aXRob3V0IGludGVydmFsIHN1cHBvcnQgYWxpZ25UaWNrcy5cbiAgICAgICAgaXNJbnRlcnZhbE9yTG9nU2NhbGUoc2NhbGUpICYmIG1vZGVsLmdldCgnYWxpZ25UaWNrcycpICYmIG1vZGVsLmdldCgnaW50ZXJ2YWwnKSA9PSBudWxsKSB7XG4gICAgICAgICAgYXhpc05lZWRzQWxpZ24ucHVzaChheGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuaWNlU2NhbGVFeHRlbnQoc2NhbGUsIG1vZGVsKTtcbiAgICAgICAgICBpZiAoaXNJbnRlcnZhbE9yTG9nU2NhbGUoc2NhbGUpKSB7XG4gICAgICAgICAgICAvLyBDYW4gb25seSBhbGlnbiB0byBpbnRlcnZhbCBvciBsb2cgYXhpcy5cbiAgICAgICAgICAgIGFsaWduVG8gPSBheGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgO1xuICAgICAgLy8gQWxsIGF4ZXMgaGFzIHNldCBhbGlnblRpY2tzLiBQaWNrIHRoZSBmaXJzdCBvbmUuXG4gICAgICAvLyBQRU5ESU5HLiBTaG91bGQgd2UgZmluZCB0aGUgYXhpcyB0aGF0IGJvdGggc2V0IGludGVydmFsLCBtaW4sIG1heCBhbmQgYWxpZ24gdG8gdGhpcyBvbmU/XG4gICAgICBpZiAoYXhpc05lZWRzQWxpZ24ubGVuZ3RoKSB7XG4gICAgICAgIGlmICghYWxpZ25Ubykge1xuICAgICAgICAgIGFsaWduVG8gPSBheGlzTmVlZHNBbGlnbi5wb3AoKTtcbiAgICAgICAgICBuaWNlU2NhbGVFeHRlbnQoYWxpZ25Uby5zY2FsZSwgYWxpZ25Uby5tb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWFjaChheGlzTmVlZHNBbGlnbiwgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICBhbGlnblNjYWxlVGlja3MoYXhpcy5zY2FsZSwgYXhpcy5tb2RlbCwgYWxpZ25Uby5zY2FsZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVBeGlzVGlja3MoYXhlc01hcC54KTtcbiAgICB1cGRhdGVBeGlzVGlja3MoYXhlc01hcC55KTtcbiAgICAvLyBLZXk6IGF4aXNEaW1fYXhpc0luZGV4LCB2YWx1ZTogYm9vbGVhbiwgd2hldGhlciBvblplcm8gdGFyZ2V0LlxuICAgIHZhciBvblplcm9SZWNvcmRzID0ge307XG4gICAgZWFjaChheGVzTWFwLngsIGZ1bmN0aW9uICh4QXhpcykge1xuICAgICAgZml4QXhpc09uWmVybyhheGVzTWFwLCAneScsIHhBeGlzLCBvblplcm9SZWNvcmRzKTtcbiAgICB9KTtcbiAgICBlYWNoKGF4ZXNNYXAueSwgZnVuY3Rpb24gKHlBeGlzKSB7XG4gICAgICBmaXhBeGlzT25aZXJvKGF4ZXNNYXAsICd4JywgeUF4aXMsIG9uWmVyb1JlY29yZHMpO1xuICAgIH0pO1xuICAgIC8vIFJlc2l6ZSBhZ2FpbiBpZiBjb250YWluTGFiZWwgaXMgZW5hYmxlZFxuICAgIC8vIEZJWE1FIEl0IG1heSBjYXVzZSBnZXR0aW5nIHdyb25nIGdyaWQgc2l6ZSBpbiBkYXRhIHByb2Nlc3Npbmcgc3RhZ2VcbiAgICB0aGlzLnJlc2l6ZSh0aGlzLm1vZGVsLCBhcGkpO1xuICB9O1xuICAvKipcclxuICAgKiBSZXNpemUgdGhlIGdyaWRcclxuICAgKi9cbiAgR3JpZC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKGdyaWRNb2RlbCwgYXBpLCBpZ25vcmVDb250YWluTGFiZWwpIHtcbiAgICB2YXIgYm94TGF5b3V0UGFyYW1zID0gZ3JpZE1vZGVsLmdldEJveExheW91dFBhcmFtcygpO1xuICAgIHZhciBpc0NvbnRhaW5MYWJlbCA9ICFpZ25vcmVDb250YWluTGFiZWwgJiYgZ3JpZE1vZGVsLmdldCgnY29udGFpbkxhYmVsJyk7XG4gICAgdmFyIGdyaWRSZWN0ID0gZ2V0TGF5b3V0UmVjdChib3hMYXlvdXRQYXJhbXMsIHtcbiAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgfSk7XG4gICAgdGhpcy5fcmVjdCA9IGdyaWRSZWN0O1xuICAgIHZhciBheGVzTGlzdCA9IHRoaXMuX2F4ZXNMaXN0O1xuICAgIGFkanVzdEF4ZXMoKTtcbiAgICAvLyBNaW51cyBsYWJlbCBzaXplXG4gICAgaWYgKGlzQ29udGFpbkxhYmVsKSB7XG4gICAgICBlYWNoKGF4ZXNMaXN0LCBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICBpZiAoIWF4aXMubW9kZWwuZ2V0KFsnYXhpc0xhYmVsJywgJ2luc2lkZSddKSkge1xuICAgICAgICAgIHZhciBsYWJlbFVuaW9uUmVjdCA9IGVzdGltYXRlTGFiZWxVbmlvblJlY3QoYXhpcyk7XG4gICAgICAgICAgaWYgKGxhYmVsVW5pb25SZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGltID0gYXhpcy5pc0hvcml6b250YWwoKSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgICAgIHZhciBtYXJnaW4gPSBheGlzLm1vZGVsLmdldChbJ2F4aXNMYWJlbCcsICdtYXJnaW4nXSk7XG4gICAgICAgICAgICBncmlkUmVjdFtkaW1dIC09IGxhYmVsVW5pb25SZWN0W2RpbV0gKyBtYXJnaW47XG4gICAgICAgICAgICBpZiAoYXhpcy5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgZ3JpZFJlY3QueSArPSBsYWJlbFVuaW9uUmVjdC5oZWlnaHQgKyBtYXJnaW47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF4aXMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICBncmlkUmVjdC54ICs9IGxhYmVsVW5pb25SZWN0LndpZHRoICsgbWFyZ2luO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhZGp1c3RBeGVzKCk7XG4gICAgfVxuICAgIGVhY2godGhpcy5fY29vcmRzTGlzdCwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgYWZmaW5lIG1hdHJpeCB0byBhY2NlbGVyYXRlIHRoZSBkYXRhIHRvIHBvaW50IHRyYW5zZm9ybS5cbiAgICAgIC8vIElmIGFsbCB0aGUgYXhlcyBzY2FsZXMgYXJlIHRpbWUgb3IgdmFsdWUuXG4gICAgICBjb29yZC5jYWxjQWZmaW5lVHJhbnNmb3JtKCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gYWRqdXN0QXhlcygpIHtcbiAgICAgIGVhY2goYXhlc0xpc3QsIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgIHZhciBpc0hvcml6b250YWwgPSBheGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgICB2YXIgZXh0ZW50ID0gaXNIb3Jpem9udGFsID8gWzAsIGdyaWRSZWN0LndpZHRoXSA6IFswLCBncmlkUmVjdC5oZWlnaHRdO1xuICAgICAgICB2YXIgaWR4ID0gYXhpcy5pbnZlcnNlID8gMSA6IDA7XG4gICAgICAgIGF4aXMuc2V0RXh0ZW50KGV4dGVudFtpZHhdLCBleHRlbnRbMSAtIGlkeF0pO1xuICAgICAgICB1cGRhdGVBeGlzVHJhbnNmb3JtKGF4aXMsIGlzSG9yaXpvbnRhbCA/IGdyaWRSZWN0LnggOiBncmlkUmVjdC55KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgR3JpZC5wcm90b3R5cGUuZ2V0QXhpcyA9IGZ1bmN0aW9uIChkaW0sIGF4aXNJbmRleCkge1xuICAgIHZhciBheGVzTWFwT25EaW0gPSB0aGlzLl9heGVzTWFwW2RpbV07XG4gICAgaWYgKGF4ZXNNYXBPbkRpbSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gYXhlc01hcE9uRGltW2F4aXNJbmRleCB8fCAwXTtcbiAgICB9XG4gIH07XG4gIEdyaWQucHJvdG90eXBlLmdldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F4ZXNMaXN0LnNsaWNlKCk7XG4gIH07XG4gIEdyaWQucHJvdG90eXBlLmdldENhcnRlc2lhbiA9IGZ1bmN0aW9uICh4QXhpc0luZGV4LCB5QXhpc0luZGV4KSB7XG4gICAgaWYgKHhBeGlzSW5kZXggIT0gbnVsbCAmJiB5QXhpc0luZGV4ICE9IG51bGwpIHtcbiAgICAgIHZhciBrZXkgPSAneCcgKyB4QXhpc0luZGV4ICsgJ3knICsgeUF4aXNJbmRleDtcbiAgICAgIHJldHVybiB0aGlzLl9jb29yZHNNYXBba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHhBeGlzSW5kZXgpKSB7XG4gICAgICB5QXhpc0luZGV4ID0geEF4aXNJbmRleC55QXhpc0luZGV4O1xuICAgICAgeEF4aXNJbmRleCA9IHhBeGlzSW5kZXgueEF4aXNJbmRleDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGNvb3JkTGlzdCA9IHRoaXMuX2Nvb3Jkc0xpc3Q7IGkgPCBjb29yZExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjb29yZExpc3RbaV0uZ2V0QXhpcygneCcpLmluZGV4ID09PSB4QXhpc0luZGV4IHx8IGNvb3JkTGlzdFtpXS5nZXRBeGlzKCd5JykuaW5kZXggPT09IHlBeGlzSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkTGlzdFtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIEdyaWQucHJvdG90eXBlLmdldENhcnRlc2lhbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvb3Jkc0xpc3Quc2xpY2UoKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQGltcGxlbWVudHNcclxuICAgKi9cbiAgR3JpZC5wcm90b3R5cGUuY29udmVydFRvUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl9maW5kQ29udmVydFRhcmdldChmaW5kZXIpO1xuICAgIHJldHVybiB0YXJnZXQuY2FydGVzaWFuID8gdGFyZ2V0LmNhcnRlc2lhbi5kYXRhVG9Qb2ludCh2YWx1ZSkgOiB0YXJnZXQuYXhpcyA/IHRhcmdldC5heGlzLnRvR2xvYmFsQ29vcmQodGFyZ2V0LmF4aXMuZGF0YVRvQ29vcmQodmFsdWUpKSA6IG51bGw7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBpbXBsZW1lbnRzXHJcbiAgICovXG4gIEdyaWQucHJvdG90eXBlLmNvbnZlcnRGcm9tUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl9maW5kQ29udmVydFRhcmdldChmaW5kZXIpO1xuICAgIHJldHVybiB0YXJnZXQuY2FydGVzaWFuID8gdGFyZ2V0LmNhcnRlc2lhbi5wb2ludFRvRGF0YSh2YWx1ZSkgOiB0YXJnZXQuYXhpcyA/IHRhcmdldC5heGlzLmNvb3JkVG9EYXRhKHRhcmdldC5heGlzLnRvTG9jYWxDb29yZCh2YWx1ZSkpIDogbnVsbDtcbiAgfTtcbiAgR3JpZC5wcm90b3R5cGUuX2ZpbmRDb252ZXJ0VGFyZ2V0ID0gZnVuY3Rpb24gKGZpbmRlcikge1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGZpbmRlci5zZXJpZXNNb2RlbDtcbiAgICB2YXIgeEF4aXNNb2RlbCA9IGZpbmRlci54QXhpc01vZGVsIHx8IHNlcmllc01vZGVsICYmIHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3hBeGlzJywgU0lOR0xFX1JFRkVSUklORykubW9kZWxzWzBdO1xuICAgIHZhciB5QXhpc01vZGVsID0gZmluZGVyLnlBeGlzTW9kZWwgfHwgc2VyaWVzTW9kZWwgJiYgc2VyaWVzTW9kZWwuZ2V0UmVmZXJyaW5nQ29tcG9uZW50cygneUF4aXMnLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG4gICAgdmFyIGdyaWRNb2RlbCA9IGZpbmRlci5ncmlkTW9kZWw7XG4gICAgdmFyIGNvb3Jkc0xpc3QgPSB0aGlzLl9jb29yZHNMaXN0O1xuICAgIHZhciBjYXJ0ZXNpYW47XG4gICAgdmFyIGF4aXM7XG4gICAgaWYgKHNlcmllc01vZGVsKSB7XG4gICAgICBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgaW5kZXhPZihjb29yZHNMaXN0LCBjYXJ0ZXNpYW4pIDwgMCAmJiAoY2FydGVzaWFuID0gbnVsbCk7XG4gICAgfSBlbHNlIGlmICh4QXhpc01vZGVsICYmIHlBeGlzTW9kZWwpIHtcbiAgICAgIGNhcnRlc2lhbiA9IHRoaXMuZ2V0Q2FydGVzaWFuKHhBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgsIHlBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoeEF4aXNNb2RlbCkge1xuICAgICAgYXhpcyA9IHRoaXMuZ2V0QXhpcygneCcsIHhBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoeUF4aXNNb2RlbCkge1xuICAgICAgYXhpcyA9IHRoaXMuZ2V0QXhpcygneScsIHlBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgIH1cbiAgICAvLyBMb3dlc3QgcHJpb3JpdHkuXG4gICAgZWxzZSBpZiAoZ3JpZE1vZGVsKSB7XG4gICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgaWYgKGdyaWQgPT09IHRoaXMpIHtcbiAgICAgICAgY2FydGVzaWFuID0gdGhpcy5fY29vcmRzTGlzdFswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhcnRlc2lhbjogY2FydGVzaWFuLFxuICAgICAgYXhpczogYXhpc1xuICAgIH07XG4gIH07XG4gIC8qKlxyXG4gICAqIEBpbXBsZW1lbnRzXHJcbiAgICovXG4gIEdyaWQucHJvdG90eXBlLmNvbnRhaW5Qb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBjb29yZCA9IHRoaXMuX2Nvb3Jkc0xpc3RbMF07XG4gICAgaWYgKGNvb3JkKSB7XG4gICAgICByZXR1cm4gY29vcmQuY29udGFpblBvaW50KHBvaW50KTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgY2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtc1xyXG4gICAqL1xuICBHcmlkLnByb3RvdHlwZS5faW5pdENhcnRlc2lhbiA9IGZ1bmN0aW9uIChncmlkTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGdyaWQgPSB0aGlzO1xuICAgIHZhciBheGlzUG9zaXRpb25Vc2VkID0ge1xuICAgICAgbGVmdDogZmFsc2UsXG4gICAgICByaWdodDogZmFsc2UsXG4gICAgICB0b3A6IGZhbHNlLFxuICAgICAgYm90dG9tOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIGF4ZXNNYXAgPSB7XG4gICAgICB4OiB7fSxcbiAgICAgIHk6IHt9XG4gICAgfTtcbiAgICB2YXIgYXhlc0NvdW50ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIC8vIENyZWF0ZSBheGlzXG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCd4QXhpcycsIGNyZWF0ZUF4aXNDcmVhdG9yKCd4JyksIHRoaXMpO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgneUF4aXMnLCBjcmVhdGVBeGlzQ3JlYXRvcigneScpLCB0aGlzKTtcbiAgICBpZiAoIWF4ZXNDb3VudC54IHx8ICFheGVzQ291bnQueSkge1xuICAgICAgLy8gUm9sbCBiYWNrIHdoZW4gdGhlcmUgbm8gZWl0aGVyIHggb3IgeSBheGlzXG4gICAgICB0aGlzLl9heGVzTWFwID0ge307XG4gICAgICB0aGlzLl9heGVzTGlzdCA9IFtdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9heGVzTWFwID0gYXhlc01hcDtcbiAgICAvLyBDcmVhdGUgY2FydGVzaWFuMmRcbiAgICBlYWNoKGF4ZXNNYXAueCwgZnVuY3Rpb24gKHhBeGlzLCB4QXhpc0luZGV4KSB7XG4gICAgICBlYWNoKGF4ZXNNYXAueSwgZnVuY3Rpb24gKHlBeGlzLCB5QXhpc0luZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSAneCcgKyB4QXhpc0luZGV4ICsgJ3knICsgeUF4aXNJbmRleDtcbiAgICAgICAgdmFyIGNhcnRlc2lhbiA9IG5ldyBDYXJ0ZXNpYW4yRChrZXkpO1xuICAgICAgICBjYXJ0ZXNpYW4ubWFzdGVyID0gX3RoaXM7XG4gICAgICAgIGNhcnRlc2lhbi5tb2RlbCA9IGdyaWRNb2RlbDtcbiAgICAgICAgX3RoaXMuX2Nvb3Jkc01hcFtrZXldID0gY2FydGVzaWFuO1xuICAgICAgICBfdGhpcy5fY29vcmRzTGlzdC5wdXNoKGNhcnRlc2lhbik7XG4gICAgICAgIGNhcnRlc2lhbi5hZGRBeGlzKHhBeGlzKTtcbiAgICAgICAgY2FydGVzaWFuLmFkZEF4aXMoeUF4aXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY3JlYXRlQXhpc0NyZWF0b3IoZGltTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChheGlzTW9kZWwsIGlkeCkge1xuICAgICAgICBpZiAoIWlzQXhpc1VzZWRJblRoZUdyaWQoYXhpc01vZGVsLCBncmlkTW9kZWwpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBheGlzUG9zaXRpb24gPSBheGlzTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgICAgICBpZiAoZGltTmFtZSA9PT0gJ3gnKSB7XG4gICAgICAgICAgLy8gRml4IHBvc2l0aW9uXG4gICAgICAgICAgaWYgKGF4aXNQb3NpdGlvbiAhPT0gJ3RvcCcgJiYgYXhpc1Bvc2l0aW9uICE9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBib3R0b20gb2YgWFxuICAgICAgICAgICAgYXhpc1Bvc2l0aW9uID0gYXhpc1Bvc2l0aW9uVXNlZC5ib3R0b20gPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGaXggcG9zaXRpb25cbiAgICAgICAgICBpZiAoYXhpc1Bvc2l0aW9uICE9PSAnbGVmdCcgJiYgYXhpc1Bvc2l0aW9uICE9PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGxlZnQgb2YgWVxuICAgICAgICAgICAgYXhpc1Bvc2l0aW9uID0gYXhpc1Bvc2l0aW9uVXNlZC5sZWZ0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXhpc1Bvc2l0aW9uVXNlZFtheGlzUG9zaXRpb25dID0gdHJ1ZTtcbiAgICAgICAgdmFyIGF4aXMgPSBuZXcgQXhpczJEKGRpbU5hbWUsIGNyZWF0ZVNjYWxlQnlNb2RlbChheGlzTW9kZWwpLCBbMCwgMF0sIGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSwgYXhpc1Bvc2l0aW9uKTtcbiAgICAgICAgdmFyIGlzQ2F0ZWdvcnkgPSBheGlzLnR5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgICAgIGF4aXMub25CYW5kID0gaXNDYXRlZ29yeSAmJiBheGlzTW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuICAgICAgICBheGlzLmludmVyc2UgPSBheGlzTW9kZWwuZ2V0KCdpbnZlcnNlJyk7XG4gICAgICAgIC8vIEluamVjdCBheGlzIGludG8gYXhpc01vZGVsXG4gICAgICAgIGF4aXNNb2RlbC5heGlzID0gYXhpcztcbiAgICAgICAgLy8gSW5qZWN0IGF4aXNNb2RlbCBpbnRvIGF4aXNcbiAgICAgICAgYXhpcy5tb2RlbCA9IGF4aXNNb2RlbDtcbiAgICAgICAgLy8gSW5qZWN0IGdyaWQgaW5mbyBheGlzXG4gICAgICAgIGF4aXMuZ3JpZCA9IGdyaWQ7XG4gICAgICAgIC8vIEluZGV4IG9mIGF4aXMsIGNhbiBiZSB1c2VkIGFzIGtleVxuICAgICAgICBheGlzLmluZGV4ID0gaWR4O1xuICAgICAgICBncmlkLl9heGVzTGlzdC5wdXNoKGF4aXMpO1xuICAgICAgICBheGVzTWFwW2RpbU5hbWVdW2lkeF0gPSBheGlzO1xuICAgICAgICBheGVzQ291bnRbZGltTmFtZV0rKztcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgY2FydGVzaWFuIHByb3BlcnRpZXMgZnJvbSBzZXJpZXMuXHJcbiAgICovXG4gIEdyaWQucHJvdG90eXBlLl91cGRhdGVTY2FsZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBncmlkTW9kZWwpIHtcbiAgICAvLyBSZXNldCBzY2FsZVxuICAgIGVhY2godGhpcy5fYXhlc0xpc3QsIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICBheGlzLnNjYWxlLnNldEV4dGVudChJbmZpbml0eSwgLUluZmluaXR5KTtcbiAgICAgIGlmIChheGlzLnR5cGUgPT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgdmFyIGNhdGVnb3J5U29ydEluZm8gPSBheGlzLm1vZGVsLmdldCgnY2F0ZWdvcnlTb3J0SW5mbycpO1xuICAgICAgICBheGlzLnNjYWxlLnNldFNvcnRJbmZvKGNhdGVnb3J5U29ydEluZm8pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIGlmIChpc0NhcnRlc2lhbjJEU2VyaWVzKHNlcmllc01vZGVsKSkge1xuICAgICAgICB2YXIgYXhlc01vZGVsTWFwID0gZmluZEF4aXNNb2RlbHMoc2VyaWVzTW9kZWwpO1xuICAgICAgICB2YXIgeEF4aXNNb2RlbCA9IGF4ZXNNb2RlbE1hcC54QXhpc01vZGVsO1xuICAgICAgICB2YXIgeUF4aXNNb2RlbCA9IGF4ZXNNb2RlbE1hcC55QXhpc01vZGVsO1xuICAgICAgICBpZiAoIWlzQXhpc1VzZWRJblRoZUdyaWQoeEF4aXNNb2RlbCwgZ3JpZE1vZGVsKSB8fCAhaXNBeGlzVXNlZEluVGhlR3JpZCh5QXhpc01vZGVsLCBncmlkTW9kZWwpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYXJ0ZXNpYW4gPSB0aGlzLmdldENhcnRlc2lhbih4QXhpc01vZGVsLmNvbXBvbmVudEluZGV4LCB5QXhpc01vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgIHZhciB4QXhpcyA9IGNhcnRlc2lhbi5nZXRBeGlzKCd4Jyk7XG4gICAgICAgIHZhciB5QXhpcyA9IGNhcnRlc2lhbi5nZXRBeGlzKCd5Jyk7XG4gICAgICAgIHVuaW9uRXh0ZW50KGRhdGEsIHhBeGlzKTtcbiAgICAgICAgdW5pb25FeHRlbnQoZGF0YSwgeUF4aXMpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIGZ1bmN0aW9uIHVuaW9uRXh0ZW50KGRhdGEsIGF4aXMpIHtcbiAgICAgIGVhY2goZ2V0RGF0YURpbWVuc2lvbnNPbkF4aXMoZGF0YSwgYXhpcy5kaW0pLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIGF4aXMuc2NhbGUudW5pb25FeHRlbnRGcm9tRGF0YShkYXRhLCBkaW0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBAcGFyYW0gZGltICd4JyBvciAneScgb3IgJ2F1dG8nIG9yIG51bGwvdW5kZWZpbmVkXHJcbiAgICovXG4gIEdyaWQucHJvdG90eXBlLmdldFRvb2x0aXBBeGVzID0gZnVuY3Rpb24gKGRpbSkge1xuICAgIHZhciBiYXNlQXhlcyA9IFtdO1xuICAgIHZhciBvdGhlckF4ZXMgPSBbXTtcbiAgICBlYWNoKHRoaXMuZ2V0Q2FydGVzaWFucygpLCBmdW5jdGlvbiAoY2FydGVzaWFuKSB7XG4gICAgICB2YXIgYmFzZUF4aXMgPSBkaW0gIT0gbnVsbCAmJiBkaW0gIT09ICdhdXRvJyA/IGNhcnRlc2lhbi5nZXRBeGlzKGRpbSkgOiBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKTtcbiAgICAgIHZhciBvdGhlckF4aXMgPSBjYXJ0ZXNpYW4uZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKTtcbiAgICAgIGluZGV4T2YoYmFzZUF4ZXMsIGJhc2VBeGlzKSA8IDAgJiYgYmFzZUF4ZXMucHVzaChiYXNlQXhpcyk7XG4gICAgICBpbmRleE9mKG90aGVyQXhlcywgb3RoZXJBeGlzKSA8IDAgJiYgb3RoZXJBeGVzLnB1c2gob3RoZXJBeGlzKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZUF4ZXM6IGJhc2VBeGVzLFxuICAgICAgb3RoZXJBeGVzOiBvdGhlckF4ZXNcbiAgICB9O1xuICB9O1xuICBHcmlkLmNyZWF0ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZ3JpZHMgPSBbXTtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ2dyaWQnLCBmdW5jdGlvbiAoZ3JpZE1vZGVsLCBpZHgpIHtcbiAgICAgIHZhciBncmlkID0gbmV3IEdyaWQoZ3JpZE1vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgZ3JpZC5uYW1lID0gJ2dyaWRfJyArIGlkeDtcbiAgICAgIC8vIGRhdGFTYW1wbGluZyByZXF1aXJlcyBheGlzIGV4dGVudCwgc28gcmVzaXplXG4gICAgICAvLyBzaG91bGQgYmUgcGVyZm9ybWVkIGluIGNyZWF0ZSBzdGFnZS5cbiAgICAgIGdyaWQucmVzaXplKGdyaWRNb2RlbCwgYXBpLCB0cnVlKTtcbiAgICAgIGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gZ3JpZDtcbiAgICAgIGdyaWRzLnB1c2goZ3JpZCk7XG4gICAgfSk7XG4gICAgLy8gSW5qZWN0IHRoZSBjb29yZGluYXRlU3lzdGVtcyBpbnRvIHNlcmllc01vZGVsXG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgaWYgKCFpc0NhcnRlc2lhbjJEU2VyaWVzKHNlcmllc01vZGVsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYXhlc01vZGVsTWFwID0gZmluZEF4aXNNb2RlbHMoc2VyaWVzTW9kZWwpO1xuICAgICAgdmFyIHhBeGlzTW9kZWwgPSBheGVzTW9kZWxNYXAueEF4aXNNb2RlbDtcbiAgICAgIHZhciB5QXhpc01vZGVsID0gYXhlc01vZGVsTWFwLnlBeGlzTW9kZWw7XG4gICAgICB2YXIgZ3JpZE1vZGVsID0geEF4aXNNb2RlbC5nZXRDb29yZFN5c01vZGVsKCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIWdyaWRNb2RlbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR3JpZCBcIicgKyByZXRyaWV2ZTMoeEF4aXNNb2RlbC5nZXQoJ2dyaWRJbmRleCcpLCB4QXhpc01vZGVsLmdldCgnZ3JpZElkJyksIDApICsgJ1wiIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4QXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKSAhPT0geUF4aXNNb2RlbC5nZXRDb29yZFN5c01vZGVsKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3hBeGlzIGFuZCB5QXhpcyBtdXN0IHVzZSB0aGUgc2FtZSBncmlkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBncmlkID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gZ3JpZC5nZXRDYXJ0ZXNpYW4oeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCwgeUF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdyaWRzO1xuICB9O1xuICAvLyBGb3IgZGVjaWRpbmcgd2hpY2ggZGltZW5zaW9ucyB0byB1c2Ugd2hlbiBjcmVhdGluZyBsaXN0IGRhdGFcbiAgR3JpZC5kaW1lbnNpb25zID0gY2FydGVzaWFuMkREaW1lbnNpb25zO1xuICByZXR1cm4gR3JpZDtcbn0oKTtcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgYXhpcyBpcyB1c2VkIGluIHRoZSBzcGVjaWZpZWQgZ3JpZC5cclxuICovXG5mdW5jdGlvbiBpc0F4aXNVc2VkSW5UaGVHcmlkKGF4aXNNb2RlbCwgZ3JpZE1vZGVsKSB7XG4gIHJldHVybiBheGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpID09PSBncmlkTW9kZWw7XG59XG5mdW5jdGlvbiBmaXhBeGlzT25aZXJvKGF4ZXNNYXAsIG90aGVyQXhpc0RpbSwgYXhpcyxcbi8vIEtleTogc2VlIGBnZXRPblplcm9SZWNvcmRLZXlgXG5vblplcm9SZWNvcmRzKSB7XG4gIGF4aXMuZ2V0QXhlc09uWmVyb09mID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE86IG9uWmVybyBvZiBtdWx0aXBsZSBheGVzLlxuICAgIHJldHVybiBvdGhlckF4aXNPblplcm9PZiA/IFtvdGhlckF4aXNPblplcm9PZl0gOiBbXTtcbiAgfTtcbiAgLy8gb25aZXJvIGNhbiBub3QgYmUgZW5hYmxlZCBpbiB0aGVzZSB0d28gc2l0dWF0aW9uczpcbiAgLy8gMS4gV2hlbiBhbnkgb3RoZXIgYXhpcyBpcyBhIGNhdGVnb3J5IGF4aXMuXG4gIC8vIDIuIFdoZW4gbm8gYXhpcyBpcyBjcm9zcyAwIHBvaW50LlxuICB2YXIgb3RoZXJBeGVzID0gYXhlc01hcFtvdGhlckF4aXNEaW1dO1xuICB2YXIgb3RoZXJBeGlzT25aZXJvT2Y7XG4gIHZhciBheGlzTW9kZWwgPSBheGlzLm1vZGVsO1xuICB2YXIgb25aZXJvID0gYXhpc01vZGVsLmdldChbJ2F4aXNMaW5lJywgJ29uWmVybyddKTtcbiAgdmFyIG9uWmVyb0F4aXNJbmRleCA9IGF4aXNNb2RlbC5nZXQoWydheGlzTGluZScsICdvblplcm9BeGlzSW5kZXgnXSk7XG4gIGlmICghb25aZXJvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIElmIHRhcmdldCBheGlzIGlzIHNwZWNpZmllZC5cbiAgaWYgKG9uWmVyb0F4aXNJbmRleCAhPSBudWxsKSB7XG4gICAgaWYgKGNhbk9uWmVyb1RvQXhpcyhvdGhlckF4ZXNbb25aZXJvQXhpc0luZGV4XSkpIHtcbiAgICAgIG90aGVyQXhpc09uWmVyb09mID0gb3RoZXJBeGVzW29uWmVyb0F4aXNJbmRleF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgdGhlIGZpcnN0IGF2YWlsYWJsZSBvdGhlciBheGlzLlxuICAgIGZvciAodmFyIGlkeCBpbiBvdGhlckF4ZXMpIHtcbiAgICAgIGlmIChvdGhlckF4ZXMuaGFzT3duUHJvcGVydHkoaWR4KSAmJiBjYW5Pblplcm9Ub0F4aXMob3RoZXJBeGVzW2lkeF0pXG4gICAgICAvLyBDb25zaWRlciB0aGF0IHR3byBZIGF4ZXMgb24gb25lIHZhbHVlIGF4aXMsXG4gICAgICAvLyBpZiBib3RoIG9uWmVybywgdGhlIHR3byBZIGF4ZXMgb3ZlcmxhcC5cbiAgICAgICYmICFvblplcm9SZWNvcmRzW2dldE9uWmVyb1JlY29yZEtleShvdGhlckF4ZXNbaWR4XSldKSB7XG4gICAgICAgIG90aGVyQXhpc09uWmVyb09mID0gb3RoZXJBeGVzW2lkeF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAob3RoZXJBeGlzT25aZXJvT2YpIHtcbiAgICBvblplcm9SZWNvcmRzW2dldE9uWmVyb1JlY29yZEtleShvdGhlckF4aXNPblplcm9PZildID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRPblplcm9SZWNvcmRLZXkoYXhpcykge1xuICAgIHJldHVybiBheGlzLmRpbSArICdfJyArIGF4aXMuaW5kZXg7XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbk9uWmVyb1RvQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzICYmIGF4aXMudHlwZSAhPT0gJ2NhdGVnb3J5JyAmJiBheGlzLnR5cGUgIT09ICd0aW1lJyAmJiBpZkF4aXNDcm9zc1plcm8oYXhpcyk7XG59XG5mdW5jdGlvbiB1cGRhdGVBeGlzVHJhbnNmb3JtKGF4aXMsIGNvb3JkQmFzZSkge1xuICB2YXIgYXhpc0V4dGVudCA9IGF4aXMuZ2V0RXh0ZW50KCk7XG4gIHZhciBheGlzRXh0ZW50U3VtID0gYXhpc0V4dGVudFswXSArIGF4aXNFeHRlbnRbMV07XG4gIC8vIEZhc3QgdHJhbnNmb3JtXG4gIGF4aXMudG9HbG9iYWxDb29yZCA9IGF4aXMuZGltID09PSAneCcgPyBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICByZXR1cm4gY29vcmQgKyBjb29yZEJhc2U7XG4gIH0gOiBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICByZXR1cm4gYXhpc0V4dGVudFN1bSAtIGNvb3JkICsgY29vcmRCYXNlO1xuICB9O1xuICBheGlzLnRvTG9jYWxDb29yZCA9IGF4aXMuZGltID09PSAneCcgPyBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICByZXR1cm4gY29vcmQgLSBjb29yZEJhc2U7XG4gIH0gOiBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICByZXR1cm4gYXhpc0V4dGVudFN1bSAtIGNvb3JkICsgY29vcmRCYXNlO1xuICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgR3JpZDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///74345\n")},76311:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ geoSourceManager)\n});\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/tool/parseSVG.js\nvar parseSVG = __webpack_require__(69942);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/BoundingRect.js\nvar BoundingRect = __webpack_require__(29308);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/tool/parseXML.js\nvar parseXML = __webpack_require__(2141);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/geo/Region.js\nvar Region = __webpack_require__(31024);\n;// ./node_modules/echarts/lib/coord/geo/GeoSVGResource.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n/**\r\n * \"region available\" means that: enable users to set attribute `name=\"xxx\"` on those tags\r\n * to make it be a region.\r\n * 1. region styles and its label styles can be defined in echarts opton:\r\n * ```js\r\n * geo: {\r\n *     regions: [{\r\n *         name: 'xxx',\r\n *         itemStyle: { ... },\r\n *         label: { ... }\r\n *     }, {\r\n *         ...\r\n *     },\r\n *     ...]\r\n * };\r\n * ```\r\n * 2. name can be duplicated in different SVG tag. All of the tags with the same name share\r\n * a region option. For exampel if there are two <path> representing two lung lobes. They have\r\n * no common parents but both of them need to display label \"lung\" inside.\r\n */\nvar REGION_AVAILABLE_SVG_TAG_MAP = (0,util.createHashMap)(['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path',\n// <text> <tspan> are also enabled because some SVG might paint text itself,\n// but still need to trigger events or tooltip.\n'text', 'tspan',\n// <g> is also enabled because this case: if multiple tags share one name\n// and need label displayed, every tags will display the name, which is not\n// expected. So we can put them into a <g name=\"xxx\">. Thereby only one label\n// displayed and located based on the bounding rect of the <g>.\n'g']);\nvar GeoSVGResource = /** @class */function () {\n  function GeoSVGResource(mapName, svg) {\n    this.type = 'geoSVG';\n    // All used graphics. key: hostKey, value: root\n    this._usedGraphicMap = (0,util.createHashMap)();\n    // All unused graphics.\n    this._freedGraphics = [];\n    this._mapName = mapName;\n    // Only perform parse to XML object here, which might be time\n    // consiming for large SVG.\n    // Although convert XML to zrender element is also time consiming,\n    // if we do it here, the clone of zrender elements has to be\n    // required. So we do it once for each geo instance, util real\n    // performance issues call for optimizing it.\n    this._parsedXML = (0,parseXML/* parseXML */.h)(svg);\n  }\n  GeoSVGResource.prototype.load = function /* nameMap: NameMap */\n  () {\n    // In the \"load\" stage, graphic need to be built to\n    // get boundingRect for geo coordinate system.\n    var firstGraphic = this._firstGraphic;\n    // Create the return data structure only when first graphic created.\n    // Because they will be used in geo coordinate system update stage,\n    // and `regions` will be mounted at `geo` coordinate system,\n    // in which there is no \"view\" info, so that it should better not to\n    // make references to graphic elements.\n    if (!firstGraphic) {\n      firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);\n      this._freedGraphics.push(firstGraphic);\n      this._boundingRect = this._firstGraphic.boundingRect.clone();\n      // PENDING: `nameMap` will not be supported until some real requirement come.\n      // if (nameMap) {\n      //     named = applyNameMap(named, nameMap);\n      // }\n      var _a = createRegions(firstGraphic.named),\n        regions = _a.regions,\n        regionsMap = _a.regionsMap;\n      this._regions = regions;\n      this._regionsMap = regionsMap;\n    }\n    return {\n      boundingRect: this._boundingRect,\n      regions: this._regions,\n      regionsMap: this._regionsMap\n    };\n  };\n  GeoSVGResource.prototype._buildGraphic = function (svgXML) {\n    var result;\n    var rootFromParse;\n    try {\n      result = svgXML && (0,parseSVG/* parseSVG */.cM)(svgXML, {\n        ignoreViewBox: true,\n        ignoreRootClip: true\n      }) || {};\n      rootFromParse = result.root;\n      (0,util.assert)(rootFromParse != null);\n    } catch (e) {\n      throw new Error('Invalid svg format\\n' + e.message);\n    }\n    // Note: we keep the covenant that the root has no transform. So always add an extra root.\n    var root = new Group/* default */.A();\n    root.add(rootFromParse);\n    root.isGeoSVGGraphicRoot = true;\n    // [THE_RULE_OF_VIEWPORT_AND_VIEWBOX]\n    //\n    // Consider: `<svg width=\"...\" height=\"...\" viewBox=\"...\">`\n    // - the `width/height` we call it `svgWidth/svgHeight` for short.\n    // - `(0, 0, svgWidth, svgHeight)` defines the viewport of the SVG, or say,\n    //   \"viewport boundingRect\", or `boundingRect` for short.\n    // - `viewBox` defines the transform from the real content ot the viewport.\n    //   `viewBox` has the same unit as the content of SVG.\n    //   If `viewBox` exists, a transform is defined, so the unit of `svgWidth/svgHeight` become\n    //   different from the content of SVG. Otherwise, they are the same.\n    //\n    // If both `svgWidth/svgHeight/viewBox` are specified in a SVG file, the transform rule will be:\n    // 0. `boundingRect` is `(0, 0, svgWidth, svgHeight)`. Set it to Geo['_rect'] (View['_rect']).\n    // 1. Make a transform from `viewBox` to `boundingRect`.\n    //    Note: only support `preserveAspectRatio 'xMidYMid'` here. That is, this transform will preserve\n    //    the aspect ratio.\n    // 2. Make a transform from boundingRect to Geo['_viewRect'] (View['_viewRect'])\n    //    (`Geo`/`View` will do this job).\n    //    Note: this transform might not preserve aspect radio, which depending on how users specify\n    //    viewRect in echarts option (e.g., `geo.left/top/width/height` will not preserve aspect ratio,\n    //    but `geo.layoutCenter/layoutSize` will preserve aspect ratio).\n    //\n    // If `svgWidth/svgHeight` not specified, we use `viewBox` as the `boundingRect` to make the SVG\n    // layout look good.\n    //\n    // If neither `svgWidth/svgHeight` nor `viewBox` are not specified, we calculate the boundingRect\n    // of the SVG content and use them to make SVG layout look good.\n    var svgWidth = result.width;\n    var svgHeight = result.height;\n    var viewBoxRect = result.viewBoxRect;\n    var boundingRect = this._boundingRect;\n    if (!boundingRect) {\n      var bRectX = void 0;\n      var bRectY = void 0;\n      var bRectWidth = void 0;\n      var bRectHeight = void 0;\n      if (svgWidth != null) {\n        bRectX = 0;\n        bRectWidth = svgWidth;\n      } else if (viewBoxRect) {\n        bRectX = viewBoxRect.x;\n        bRectWidth = viewBoxRect.width;\n      }\n      if (svgHeight != null) {\n        bRectY = 0;\n        bRectHeight = svgHeight;\n      } else if (viewBoxRect) {\n        bRectY = viewBoxRect.y;\n        bRectHeight = viewBoxRect.height;\n      }\n      // If both viewBox and svgWidth/svgHeight not specified,\n      // we have to determine how to layout those element to make them look good.\n      if (bRectX == null || bRectY == null) {\n        var calculatedBoundingRect = rootFromParse.getBoundingRect();\n        if (bRectX == null) {\n          bRectX = calculatedBoundingRect.x;\n          bRectWidth = calculatedBoundingRect.width;\n        }\n        if (bRectY == null) {\n          bRectY = calculatedBoundingRect.y;\n          bRectHeight = calculatedBoundingRect.height;\n        }\n      }\n      boundingRect = this._boundingRect = new BoundingRect/* default */.A(bRectX, bRectY, bRectWidth, bRectHeight);\n    }\n    if (viewBoxRect) {\n      var viewBoxTransform = (0,parseSVG/* makeViewBoxTransform */.ps)(viewBoxRect, boundingRect);\n      // Only support `preserveAspectRatio 'xMidYMid'`\n      rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;\n      rootFromParse.x = viewBoxTransform.x;\n      rootFromParse.y = viewBoxTransform.y;\n    }\n    // SVG needs to clip based on `viewBox`. And some SVG files really rely on this feature.\n    // They do not strictly confine all of the content inside a display rect, but deliberately\n    // use a `viewBox` to define a displayable rect.\n    // PENDING:\n    // The drawback of the `setClipPath` here is: the region label (genereted by echarts) near the\n    // edge might also be clipped, because region labels are put as `textContent` of the SVG path.\n    root.setClipPath(new Rect/* default */.A({\n      shape: boundingRect.plain()\n    }));\n    var named = [];\n    (0,util.each)(result.named, function (namedItem) {\n      if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {\n        named.push(namedItem);\n        setSilent(namedItem.el);\n      }\n    });\n    return {\n      root: root,\n      boundingRect: boundingRect,\n      named: named\n    };\n  };\n  /**\r\n   * Consider:\r\n   * (1) One graphic element can not be shared by different `geoView` running simultaneously.\r\n   *     Notice, also need to consider multiple echarts instances share a `mapRecord`.\r\n   * (2) Converting SVG to graphic elements is time consuming.\r\n   * (3) In the current architecture, `load` should be called frequently to get boundingRect,\r\n   *     and it is called without view info.\r\n   * So we maintain graphic elements in this module, and enables `view` to use/return these\r\n   * graphics from/to the pool with it's uid.\r\n   */\n  GeoSVGResource.prototype.useGraphic = function (hostKey /* , nameMap: NameMap */) {\n    var usedRootMap = this._usedGraphicMap;\n    var svgGraphic = usedRootMap.get(hostKey);\n    if (svgGraphic) {\n      return svgGraphic;\n    }\n    svgGraphic = this._freedGraphics.pop()\n    // use the first boundingRect to avoid duplicated boundingRect calculation.\n    || this._buildGraphic(this._parsedXML);\n    usedRootMap.set(hostKey, svgGraphic);\n    // PENDING: `nameMap` will not be supported until some real requirement come.\n    // `nameMap` can only be obtained from echarts option.\n    // The original `named` must not be modified.\n    // if (nameMap) {\n    //     svgGraphic = extend({}, svgGraphic);\n    //     svgGraphic.named = applyNameMap(svgGraphic.named, nameMap);\n    // }\n    return svgGraphic;\n  };\n  GeoSVGResource.prototype.freeGraphic = function (hostKey) {\n    var usedRootMap = this._usedGraphicMap;\n    var svgGraphic = usedRootMap.get(hostKey);\n    if (svgGraphic) {\n      usedRootMap.removeKey(hostKey);\n      this._freedGraphics.push(svgGraphic);\n    }\n  };\n  return GeoSVGResource;\n}();\n\nfunction setSilent(el) {\n  // Only named element has silent: false, other elements should\n  // act as background and has no user interaction.\n  el.silent = false;\n  // text|tspan will be converted to group.\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.silent = false;\n    });\n  }\n}\nfunction createRegions(named) {\n  var regions = [];\n  var regionsMap = (0,util.createHashMap)();\n  // Create resions only for the first graphic.\n  (0,util.each)(named, function (namedItem) {\n    // Region has feature to calculate center for tooltip or other features.\n    // If there is a <g name=\"xxx\">, the center should be the center of the\n    // bounding rect of the g.\n    if (namedItem.namedFrom != null) {\n      return;\n    }\n    var region = new Region/* GeoSVGRegion */.U5(namedItem.name, namedItem.el);\n    // PENDING: if `nameMap` supported, this region can not be mounted on\n    // `this`, but can only be created each time `load()` called.\n    regions.push(region);\n    // PENDING: if multiple tag named with the same name, only one will be\n    // found by `_regionsMap`. `_regionsMap` is used to find a coordinate\n    // by name. We use `region.getCenter()` as the coordinate.\n    regionsMap.set(namedItem.name, region);\n  });\n  return {\n    regions: regions,\n    regionsMap: regionsMap\n  };\n}\n// PENDING: `nameMap` will not be supported until some real requirement come.\n// /**\n//  * Use the alias in geoNameMap.\n//  * The input `named` must not be modified.\n//  */\n// function applyNameMap(\n//     named: GeoSVGGraphicRecord['named'],\n//     nameMap: NameMap\n// ): GeoSVGGraphicRecord['named'] {\n//     const result = [] as GeoSVGGraphicRecord['named'];\n//     for (let i = 0; i < named.length; i++) {\n//         let regionGraphic = named[i];\n//         const name = regionGraphic.name;\n//         if (nameMap && nameMap.hasOwnProperty(name)) {\n//             regionGraphic = extend({}, regionGraphic);\n//             regionGraphic.name = name;\n//         }\n//         result.push(regionGraphic);\n//     }\n//     return result;\n// }\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/geo/parseGeoJson.js\nvar parseGeoJson = __webpack_require__(69718);\n;// ./node_modules/echarts/lib/coord/geo/fix/nanhai.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// Fix for 南海诸岛\n\n\nvar geoCoord = [126, 25];\nvar nanhaiName = '南海诸岛';\nvar points = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];\nfor (var i = 0; i < points.length; i++) {\n  for (var k = 0; k < points[i].length; k++) {\n    points[i][k][0] /= 10.5;\n    points[i][k][1] /= -10.5 / 0.75;\n    points[i][k][0] += geoCoord[0];\n    points[i][k][1] += geoCoord[1];\n  }\n}\nfunction fixNanhai(mapType, regions) {\n  if (mapType === 'china') {\n    for (var i = 0; i < regions.length; i++) {\n      // Already exists.\n      if (regions[i].name === nanhaiName) {\n        return;\n      }\n    }\n    regions.push(new Region/* GeoJSONRegion */.cn(nanhaiName, util.map(points, function (exterior) {\n      return {\n        type: 'polygon',\n        exterior: exterior\n      };\n    }), geoCoord));\n  }\n}\n;// ./node_modules/echarts/lib/coord/geo/fix/textCoord.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar coordsOffsetMap = {\n  '南海诸岛': [32, 80],\n  // 全国\n  '广东': [0, -10],\n  '香港': [10, 5],\n  '澳门': [-10, 10],\n  // '北京': [-10, 0],\n  '天津': [5, 5]\n};\nfunction fixTextCoords(mapType, region) {\n  if (mapType === 'china') {\n    var coordFix = coordsOffsetMap[region.name];\n    if (coordFix) {\n      var cp = region.getCenter();\n      cp[0] += coordFix[0] / 10.5;\n      cp[1] += -coordFix[1] / (10.5 / 0.75);\n      region.setCenter(cp);\n    }\n  }\n}\n;// ./node_modules/echarts/lib/coord/geo/fix/diaoyuIsland.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// Fix for 钓鱼岛\n// let Region = require('../Region');\n// let zrUtil = require('zrender/lib/core/util');\n// let geoCoord = [126, 25];\nvar diaoyuIsland_points = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];\nfunction fixDiaoyuIsland(mapType, region) {\n  if (mapType === 'china' && region.name === '台湾') {\n    region.geometries.push({\n      type: 'polygon',\n      exterior: diaoyuIsland_points[0]\n    });\n  }\n}\n;// ./node_modules/echarts/lib/coord/geo/GeoJSONResource.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n// Built-in GEO fixer.\n\n\n\n\nvar DEFAULT_NAME_PROPERTY = 'name';\nvar GeoJSONResource = /** @class */function () {\n  function GeoJSONResource(mapName, geoJSON, specialAreas) {\n    this.type = 'geoJSON';\n    this._parsedMap = (0,util.createHashMap)();\n    this._mapName = mapName;\n    this._specialAreas = specialAreas;\n    // PENDING: delay the parse to the first usage to rapid up the FMP?\n    this._geoJSON = parseInput(geoJSON);\n  }\n  /**\r\n   * @param nameMap can be null/undefined\r\n   * @param nameProperty can be null/undefined\r\n   */\n  GeoJSONResource.prototype.load = function (nameMap, nameProperty) {\n    nameProperty = nameProperty || DEFAULT_NAME_PROPERTY;\n    var parsed = this._parsedMap.get(nameProperty);\n    if (!parsed) {\n      var rawRegions = this._parseToRegions(nameProperty);\n      parsed = this._parsedMap.set(nameProperty, {\n        regions: rawRegions,\n        boundingRect: calculateBoundingRect(rawRegions)\n      });\n    }\n    var regionsMap = (0,util.createHashMap)();\n    var finalRegions = [];\n    (0,util.each)(parsed.regions, function (region) {\n      var regionName = region.name;\n      // Try use the alias in geoNameMap\n      if (nameMap && (0,util.hasOwn)(nameMap, regionName)) {\n        region = region.cloneShallow(regionName = nameMap[regionName]);\n      }\n      finalRegions.push(region);\n      regionsMap.set(regionName, region);\n    });\n    return {\n      regions: finalRegions,\n      boundingRect: parsed.boundingRect || new BoundingRect/* default */.A(0, 0, 0, 0),\n      regionsMap: regionsMap\n    };\n  };\n  GeoJSONResource.prototype._parseToRegions = function (nameProperty) {\n    var mapName = this._mapName;\n    var geoJSON = this._geoJSON;\n    var rawRegions;\n    // https://jsperf.com/try-catch-performance-overhead\n    try {\n      rawRegions = geoJSON ? (0,parseGeoJson/* default */.A)(geoJSON, nameProperty) : [];\n    } catch (e) {\n      throw new Error('Invalid geoJson format\\n' + e.message);\n    }\n    fixNanhai(mapName, rawRegions);\n    (0,util.each)(rawRegions, function (region) {\n      var regionName = region.name;\n      fixTextCoords(mapName, region);\n      fixDiaoyuIsland(mapName, region);\n      // Some area like Alaska in USA map needs to be tansformed\n      // to look better\n      var specialArea = this._specialAreas && this._specialAreas[regionName];\n      if (specialArea) {\n        region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);\n      }\n    }, this);\n    return rawRegions;\n  };\n  /**\r\n   * Only for exporting to users.\r\n   * **MUST NOT** used internally.\r\n   */\n  GeoJSONResource.prototype.getMapForUser = function () {\n    return {\n      // For backward compatibility, use geoJson\n      // PENDING: it has been returning them without clone.\n      // do we need to avoid outsite modification?\n      geoJson: this._geoJSON,\n      geoJSON: this._geoJSON,\n      specialAreas: this._specialAreas\n    };\n  };\n  return GeoJSONResource;\n}();\n\nfunction calculateBoundingRect(regions) {\n  var rect;\n  for (var i = 0; i < regions.length; i++) {\n    var regionRect = regions[i].getBoundingRect();\n    rect = rect || regionRect.clone();\n    rect.union(regionRect);\n  }\n  return rect;\n}\nfunction parseInput(source) {\n  return !(0,util.isString)(source) ? source : typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(source) : new Function('return (' + source + ');')();\n}\n;// ./node_modules/echarts/lib/coord/geo/geoSourceManager.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar storage = (0,util.createHashMap)();\n/* harmony default export */ const geoSourceManager = ({\n  /**\r\n   * Compatible with previous `echarts.registerMap`.\r\n   *\r\n   * @usage\r\n   * ```js\r\n   *\r\n   * echarts.registerMap('USA', geoJson, specialAreas);\r\n   *\r\n   * echarts.registerMap('USA', {\r\n   *     geoJson: geoJson,\r\n   *     specialAreas: {...}\r\n   * });\r\n   * echarts.registerMap('USA', {\r\n   *     geoJSON: geoJson,\r\n   *     specialAreas: {...}\r\n   * });\r\n   *\r\n   * echarts.registerMap('airport', {\r\n   *     svg: svg\r\n   * }\r\n   * ```\r\n   *\r\n   * Note:\r\n   * Do not support that register multiple geoJSON or SVG\r\n   * one map name. Because different geoJSON and SVG have\r\n   * different unit. It's not easy to make sure how those\r\n   * units are mapping/normalize.\r\n   * If intending to use multiple geoJSON or SVG, we can\r\n   * use multiple geo coordinate system.\r\n   */\n  registerMap: function (mapName, rawDef, rawSpecialAreas) {\n    if (rawDef.svg) {\n      var resource = new GeoSVGResource(mapName, rawDef.svg);\n      storage.set(mapName, resource);\n    } else {\n      // Recommend:\n      //     echarts.registerMap('eu', { geoJSON: xxx, specialAreas: xxx });\n      // Backward compatibility:\n      //     echarts.registerMap('eu', geoJSON, specialAreas);\n      //     echarts.registerMap('eu', { geoJson: xxx, specialAreas: xxx });\n      var geoJSON = rawDef.geoJson || rawDef.geoJSON;\n      if (geoJSON && !rawDef.features) {\n        rawSpecialAreas = rawDef.specialAreas;\n      } else {\n        geoJSON = rawDef;\n      }\n      var resource = new GeoJSONResource(mapName, geoJSON, rawSpecialAreas);\n      storage.set(mapName, resource);\n    }\n  },\n  getGeoResource: function (mapName) {\n    return storage.get(mapName);\n  },\n  /**\r\n   * Only for exporting to users.\r\n   * **MUST NOT** used internally.\r\n   */\n  getMapForUser: function (mapName) {\n    var resource = storage.get(mapName);\n    // Do not support return SVG until some real requirement come.\n    return resource && resource.type === 'geoJSON' && resource.getMapForUser();\n  },\n  load: function (mapName, nameMap, nameProperty) {\n    var resource = storage.get(mapName);\n    if (!resource) {\n      if (false) {}\n      return;\n    }\n    return resource.load(nameMap, nameProperty);\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYzMTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9nZW8vR2VvU1ZHUmVzb3VyY2UuanM/ZGUxNiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL2ZpeC9uYW5oYWkuanM/ZDdjZCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL2ZpeC90ZXh0Q29vcmQuanM/MTMzMSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL2ZpeC9kaWFveXVJc2xhbmQuanM/ZmIwNyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvZ2VvL0dlb0pTT05SZXNvdXJjZS5qcz9iMDhjIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9nZW8vZ2VvU291cmNlTWFuYWdlci5qcz9iYjgwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgcGFyc2VTVkcsIG1ha2VWaWV3Qm94VHJhbnNmb3JtIH0gZnJvbSAnenJlbmRlci9saWIvdG9vbC9wYXJzZVNWRy5qcyc7XG5pbXBvcnQgR3JvdXAgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9Hcm91cC5qcyc7XG5pbXBvcnQgUmVjdCBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QuanMnO1xuaW1wb3J0IHsgYXNzZXJ0LCBjcmVhdGVIYXNoTWFwLCBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBCb3VuZGluZ1JlY3QgZnJvbSAnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMnO1xuaW1wb3J0IHsgcGFyc2VYTUwgfSBmcm9tICd6cmVuZGVyL2xpYi90b29sL3BhcnNlWE1MLmpzJztcbmltcG9ydCB7IEdlb1NWR1JlZ2lvbiB9IGZyb20gJy4vUmVnaW9uLmpzJztcbi8qKlxyXG4gKiBcInJlZ2lvbiBhdmFpbGFibGVcIiBtZWFucyB0aGF0OiBlbmFibGUgdXNlcnMgdG8gc2V0IGF0dHJpYnV0ZSBgbmFtZT1cInh4eFwiYCBvbiB0aG9zZSB0YWdzXHJcbiAqIHRvIG1ha2UgaXQgYmUgYSByZWdpb24uXHJcbiAqIDEuIHJlZ2lvbiBzdHlsZXMgYW5kIGl0cyBsYWJlbCBzdHlsZXMgY2FuIGJlIGRlZmluZWQgaW4gZWNoYXJ0cyBvcHRvbjpcclxuICogYGBganNcclxuICogZ2VvOiB7XHJcbiAqICAgICByZWdpb25zOiBbe1xyXG4gKiAgICAgICAgIG5hbWU6ICd4eHgnLFxyXG4gKiAgICAgICAgIGl0ZW1TdHlsZTogeyAuLi4gfSxcclxuICogICAgICAgICBsYWJlbDogeyAuLi4gfVxyXG4gKiAgICAgfSwge1xyXG4gKiAgICAgICAgIC4uLlxyXG4gKiAgICAgfSxcclxuICogICAgIC4uLl1cclxuICogfTtcclxuICogYGBgXHJcbiAqIDIuIG5hbWUgY2FuIGJlIGR1cGxpY2F0ZWQgaW4gZGlmZmVyZW50IFNWRyB0YWcuIEFsbCBvZiB0aGUgdGFncyB3aXRoIHRoZSBzYW1lIG5hbWUgc2hhcmVcclxuICogYSByZWdpb24gb3B0aW9uLiBGb3IgZXhhbXBlbCBpZiB0aGVyZSBhcmUgdHdvIDxwYXRoPiByZXByZXNlbnRpbmcgdHdvIGx1bmcgbG9iZXMuIFRoZXkgaGF2ZVxyXG4gKiBubyBjb21tb24gcGFyZW50cyBidXQgYm90aCBvZiB0aGVtIG5lZWQgdG8gZGlzcGxheSBsYWJlbCBcImx1bmdcIiBpbnNpZGUuXHJcbiAqL1xudmFyIFJFR0lPTl9BVkFJTEFCTEVfU1ZHX1RBR19NQVAgPSBjcmVhdGVIYXNoTWFwKFsncmVjdCcsICdjaXJjbGUnLCAnbGluZScsICdlbGxpcHNlJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncGF0aCcsXG4vLyA8dGV4dD4gPHRzcGFuPiBhcmUgYWxzbyBlbmFibGVkIGJlY2F1c2Ugc29tZSBTVkcgbWlnaHQgcGFpbnQgdGV4dCBpdHNlbGYsXG4vLyBidXQgc3RpbGwgbmVlZCB0byB0cmlnZ2VyIGV2ZW50cyBvciB0b29sdGlwLlxuJ3RleHQnLCAndHNwYW4nLFxuLy8gPGc+IGlzIGFsc28gZW5hYmxlZCBiZWNhdXNlIHRoaXMgY2FzZTogaWYgbXVsdGlwbGUgdGFncyBzaGFyZSBvbmUgbmFtZVxuLy8gYW5kIG5lZWQgbGFiZWwgZGlzcGxheWVkLCBldmVyeSB0YWdzIHdpbGwgZGlzcGxheSB0aGUgbmFtZSwgd2hpY2ggaXMgbm90XG4vLyBleHBlY3RlZC4gU28gd2UgY2FuIHB1dCB0aGVtIGludG8gYSA8ZyBuYW1lPVwieHh4XCI+LiBUaGVyZWJ5IG9ubHkgb25lIGxhYmVsXG4vLyBkaXNwbGF5ZWQgYW5kIGxvY2F0ZWQgYmFzZWQgb24gdGhlIGJvdW5kaW5nIHJlY3Qgb2YgdGhlIDxnPi5cbidnJ10pO1xudmFyIEdlb1NWR1Jlc291cmNlID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2VvU1ZHUmVzb3VyY2UobWFwTmFtZSwgc3ZnKSB7XG4gICAgdGhpcy50eXBlID0gJ2dlb1NWRyc7XG4gICAgLy8gQWxsIHVzZWQgZ3JhcGhpY3MuIGtleTogaG9zdEtleSwgdmFsdWU6IHJvb3RcbiAgICB0aGlzLl91c2VkR3JhcGhpY01hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgICAvLyBBbGwgdW51c2VkIGdyYXBoaWNzLlxuICAgIHRoaXMuX2ZyZWVkR3JhcGhpY3MgPSBbXTtcbiAgICB0aGlzLl9tYXBOYW1lID0gbWFwTmFtZTtcbiAgICAvLyBPbmx5IHBlcmZvcm0gcGFyc2UgdG8gWE1MIG9iamVjdCBoZXJlLCB3aGljaCBtaWdodCBiZSB0aW1lXG4gICAgLy8gY29uc2ltaW5nIGZvciBsYXJnZSBTVkcuXG4gICAgLy8gQWx0aG91Z2ggY29udmVydCBYTUwgdG8genJlbmRlciBlbGVtZW50IGlzIGFsc28gdGltZSBjb25zaW1pbmcsXG4gICAgLy8gaWYgd2UgZG8gaXQgaGVyZSwgdGhlIGNsb25lIG9mIHpyZW5kZXIgZWxlbWVudHMgaGFzIHRvIGJlXG4gICAgLy8gcmVxdWlyZWQuIFNvIHdlIGRvIGl0IG9uY2UgZm9yIGVhY2ggZ2VvIGluc3RhbmNlLCB1dGlsIHJlYWxcbiAgICAvLyBwZXJmb3JtYW5jZSBpc3N1ZXMgY2FsbCBmb3Igb3B0aW1pemluZyBpdC5cbiAgICB0aGlzLl9wYXJzZWRYTUwgPSBwYXJzZVhNTChzdmcpO1xuICB9XG4gIEdlb1NWR1Jlc291cmNlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gLyogbmFtZU1hcDogTmFtZU1hcCAqL1xuICAoKSB7XG4gICAgLy8gSW4gdGhlIFwibG9hZFwiIHN0YWdlLCBncmFwaGljIG5lZWQgdG8gYmUgYnVpbHQgdG9cbiAgICAvLyBnZXQgYm91bmRpbmdSZWN0IGZvciBnZW8gY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgdmFyIGZpcnN0R3JhcGhpYyA9IHRoaXMuX2ZpcnN0R3JhcGhpYztcbiAgICAvLyBDcmVhdGUgdGhlIHJldHVybiBkYXRhIHN0cnVjdHVyZSBvbmx5IHdoZW4gZmlyc3QgZ3JhcGhpYyBjcmVhdGVkLlxuICAgIC8vIEJlY2F1c2UgdGhleSB3aWxsIGJlIHVzZWQgaW4gZ2VvIGNvb3JkaW5hdGUgc3lzdGVtIHVwZGF0ZSBzdGFnZSxcbiAgICAvLyBhbmQgYHJlZ2lvbnNgIHdpbGwgYmUgbW91bnRlZCBhdCBgZ2VvYCBjb29yZGluYXRlIHN5c3RlbSxcbiAgICAvLyBpbiB3aGljaCB0aGVyZSBpcyBubyBcInZpZXdcIiBpbmZvLCBzbyB0aGF0IGl0IHNob3VsZCBiZXR0ZXIgbm90IHRvXG4gICAgLy8gbWFrZSByZWZlcmVuY2VzIHRvIGdyYXBoaWMgZWxlbWVudHMuXG4gICAgaWYgKCFmaXJzdEdyYXBoaWMpIHtcbiAgICAgIGZpcnN0R3JhcGhpYyA9IHRoaXMuX2ZpcnN0R3JhcGhpYyA9IHRoaXMuX2J1aWxkR3JhcGhpYyh0aGlzLl9wYXJzZWRYTUwpO1xuICAgICAgdGhpcy5fZnJlZWRHcmFwaGljcy5wdXNoKGZpcnN0R3JhcGhpYyk7XG4gICAgICB0aGlzLl9ib3VuZGluZ1JlY3QgPSB0aGlzLl9maXJzdEdyYXBoaWMuYm91bmRpbmdSZWN0LmNsb25lKCk7XG4gICAgICAvLyBQRU5ESU5HOiBgbmFtZU1hcGAgd2lsbCBub3QgYmUgc3VwcG9ydGVkIHVudGlsIHNvbWUgcmVhbCByZXF1aXJlbWVudCBjb21lLlxuICAgICAgLy8gaWYgKG5hbWVNYXApIHtcbiAgICAgIC8vICAgICBuYW1lZCA9IGFwcGx5TmFtZU1hcChuYW1lZCwgbmFtZU1hcCk7XG4gICAgICAvLyB9XG4gICAgICB2YXIgX2EgPSBjcmVhdGVSZWdpb25zKGZpcnN0R3JhcGhpYy5uYW1lZCksXG4gICAgICAgIHJlZ2lvbnMgPSBfYS5yZWdpb25zLFxuICAgICAgICByZWdpb25zTWFwID0gX2EucmVnaW9uc01hcDtcbiAgICAgIHRoaXMuX3JlZ2lvbnMgPSByZWdpb25zO1xuICAgICAgdGhpcy5fcmVnaW9uc01hcCA9IHJlZ2lvbnNNYXA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBib3VuZGluZ1JlY3Q6IHRoaXMuX2JvdW5kaW5nUmVjdCxcbiAgICAgIHJlZ2lvbnM6IHRoaXMuX3JlZ2lvbnMsXG4gICAgICByZWdpb25zTWFwOiB0aGlzLl9yZWdpb25zTWFwXG4gICAgfTtcbiAgfTtcbiAgR2VvU1ZHUmVzb3VyY2UucHJvdG90eXBlLl9idWlsZEdyYXBoaWMgPSBmdW5jdGlvbiAoc3ZnWE1MKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgcm9vdEZyb21QYXJzZTtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gc3ZnWE1MICYmIHBhcnNlU1ZHKHN2Z1hNTCwge1xuICAgICAgICBpZ25vcmVWaWV3Qm94OiB0cnVlLFxuICAgICAgICBpZ25vcmVSb290Q2xpcDogdHJ1ZVxuICAgICAgfSkgfHwge307XG4gICAgICByb290RnJvbVBhcnNlID0gcmVzdWx0LnJvb3Q7XG4gICAgICBhc3NlcnQocm9vdEZyb21QYXJzZSAhPSBudWxsKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3ZnIGZvcm1hdFxcbicgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICAvLyBOb3RlOiB3ZSBrZWVwIHRoZSBjb3ZlbmFudCB0aGF0IHRoZSByb290IGhhcyBubyB0cmFuc2Zvcm0uIFNvIGFsd2F5cyBhZGQgYW4gZXh0cmEgcm9vdC5cbiAgICB2YXIgcm9vdCA9IG5ldyBHcm91cCgpO1xuICAgIHJvb3QuYWRkKHJvb3RGcm9tUGFyc2UpO1xuICAgIHJvb3QuaXNHZW9TVkdHcmFwaGljUm9vdCA9IHRydWU7XG4gICAgLy8gW1RIRV9SVUxFX09GX1ZJRVdQT1JUX0FORF9WSUVXQk9YXVxuICAgIC8vXG4gICAgLy8gQ29uc2lkZXI6IGA8c3ZnIHdpZHRoPVwiLi4uXCIgaGVpZ2h0PVwiLi4uXCIgdmlld0JveD1cIi4uLlwiPmBcbiAgICAvLyAtIHRoZSBgd2lkdGgvaGVpZ2h0YCB3ZSBjYWxsIGl0IGBzdmdXaWR0aC9zdmdIZWlnaHRgIGZvciBzaG9ydC5cbiAgICAvLyAtIGAoMCwgMCwgc3ZnV2lkdGgsIHN2Z0hlaWdodClgIGRlZmluZXMgdGhlIHZpZXdwb3J0IG9mIHRoZSBTVkcsIG9yIHNheSxcbiAgICAvLyAgIFwidmlld3BvcnQgYm91bmRpbmdSZWN0XCIsIG9yIGBib3VuZGluZ1JlY3RgIGZvciBzaG9ydC5cbiAgICAvLyAtIGB2aWV3Qm94YCBkZWZpbmVzIHRoZSB0cmFuc2Zvcm0gZnJvbSB0aGUgcmVhbCBjb250ZW50IG90IHRoZSB2aWV3cG9ydC5cbiAgICAvLyAgIGB2aWV3Qm94YCBoYXMgdGhlIHNhbWUgdW5pdCBhcyB0aGUgY29udGVudCBvZiBTVkcuXG4gICAgLy8gICBJZiBgdmlld0JveGAgZXhpc3RzLCBhIHRyYW5zZm9ybSBpcyBkZWZpbmVkLCBzbyB0aGUgdW5pdCBvZiBgc3ZnV2lkdGgvc3ZnSGVpZ2h0YCBiZWNvbWVcbiAgICAvLyAgIGRpZmZlcmVudCBmcm9tIHRoZSBjb250ZW50IG9mIFNWRy4gT3RoZXJ3aXNlLCB0aGV5IGFyZSB0aGUgc2FtZS5cbiAgICAvL1xuICAgIC8vIElmIGJvdGggYHN2Z1dpZHRoL3N2Z0hlaWdodC92aWV3Qm94YCBhcmUgc3BlY2lmaWVkIGluIGEgU1ZHIGZpbGUsIHRoZSB0cmFuc2Zvcm0gcnVsZSB3aWxsIGJlOlxuICAgIC8vIDAuIGBib3VuZGluZ1JlY3RgIGlzIGAoMCwgMCwgc3ZnV2lkdGgsIHN2Z0hlaWdodClgLiBTZXQgaXQgdG8gR2VvWydfcmVjdCddIChWaWV3WydfcmVjdCddKS5cbiAgICAvLyAxLiBNYWtlIGEgdHJhbnNmb3JtIGZyb20gYHZpZXdCb3hgIHRvIGBib3VuZGluZ1JlY3RgLlxuICAgIC8vICAgIE5vdGU6IG9ubHkgc3VwcG9ydCBgcHJlc2VydmVBc3BlY3RSYXRpbyAneE1pZFlNaWQnYCBoZXJlLiBUaGF0IGlzLCB0aGlzIHRyYW5zZm9ybSB3aWxsIHByZXNlcnZlXG4gICAgLy8gICAgdGhlIGFzcGVjdCByYXRpby5cbiAgICAvLyAyLiBNYWtlIGEgdHJhbnNmb3JtIGZyb20gYm91bmRpbmdSZWN0IHRvIEdlb1snX3ZpZXdSZWN0J10gKFZpZXdbJ192aWV3UmVjdCddKVxuICAgIC8vICAgIChgR2VvYC9gVmlld2Agd2lsbCBkbyB0aGlzIGpvYikuXG4gICAgLy8gICAgTm90ZTogdGhpcyB0cmFuc2Zvcm0gbWlnaHQgbm90IHByZXNlcnZlIGFzcGVjdCByYWRpbywgd2hpY2ggZGVwZW5kaW5nIG9uIGhvdyB1c2VycyBzcGVjaWZ5XG4gICAgLy8gICAgdmlld1JlY3QgaW4gZWNoYXJ0cyBvcHRpb24gKGUuZy4sIGBnZW8ubGVmdC90b3Avd2lkdGgvaGVpZ2h0YCB3aWxsIG5vdCBwcmVzZXJ2ZSBhc3BlY3QgcmF0aW8sXG4gICAgLy8gICAgYnV0IGBnZW8ubGF5b3V0Q2VudGVyL2xheW91dFNpemVgIHdpbGwgcHJlc2VydmUgYXNwZWN0IHJhdGlvKS5cbiAgICAvL1xuICAgIC8vIElmIGBzdmdXaWR0aC9zdmdIZWlnaHRgIG5vdCBzcGVjaWZpZWQsIHdlIHVzZSBgdmlld0JveGAgYXMgdGhlIGBib3VuZGluZ1JlY3RgIHRvIG1ha2UgdGhlIFNWR1xuICAgIC8vIGxheW91dCBsb29rIGdvb2QuXG4gICAgLy9cbiAgICAvLyBJZiBuZWl0aGVyIGBzdmdXaWR0aC9zdmdIZWlnaHRgIG5vciBgdmlld0JveGAgYXJlIG5vdCBzcGVjaWZpZWQsIHdlIGNhbGN1bGF0ZSB0aGUgYm91bmRpbmdSZWN0XG4gICAgLy8gb2YgdGhlIFNWRyBjb250ZW50IGFuZCB1c2UgdGhlbSB0byBtYWtlIFNWRyBsYXlvdXQgbG9vayBnb29kLlxuICAgIHZhciBzdmdXaWR0aCA9IHJlc3VsdC53aWR0aDtcbiAgICB2YXIgc3ZnSGVpZ2h0ID0gcmVzdWx0LmhlaWdodDtcbiAgICB2YXIgdmlld0JveFJlY3QgPSByZXN1bHQudmlld0JveFJlY3Q7XG4gICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuX2JvdW5kaW5nUmVjdDtcbiAgICBpZiAoIWJvdW5kaW5nUmVjdCkge1xuICAgICAgdmFyIGJSZWN0WCA9IHZvaWQgMDtcbiAgICAgIHZhciBiUmVjdFkgPSB2b2lkIDA7XG4gICAgICB2YXIgYlJlY3RXaWR0aCA9IHZvaWQgMDtcbiAgICAgIHZhciBiUmVjdEhlaWdodCA9IHZvaWQgMDtcbiAgICAgIGlmIChzdmdXaWR0aCAhPSBudWxsKSB7XG4gICAgICAgIGJSZWN0WCA9IDA7XG4gICAgICAgIGJSZWN0V2lkdGggPSBzdmdXaWR0aDtcbiAgICAgIH0gZWxzZSBpZiAodmlld0JveFJlY3QpIHtcbiAgICAgICAgYlJlY3RYID0gdmlld0JveFJlY3QueDtcbiAgICAgICAgYlJlY3RXaWR0aCA9IHZpZXdCb3hSZWN0LndpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHN2Z0hlaWdodCAhPSBudWxsKSB7XG4gICAgICAgIGJSZWN0WSA9IDA7XG4gICAgICAgIGJSZWN0SGVpZ2h0ID0gc3ZnSGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmICh2aWV3Qm94UmVjdCkge1xuICAgICAgICBiUmVjdFkgPSB2aWV3Qm94UmVjdC55O1xuICAgICAgICBiUmVjdEhlaWdodCA9IHZpZXdCb3hSZWN0LmhlaWdodDtcbiAgICAgIH1cbiAgICAgIC8vIElmIGJvdGggdmlld0JveCBhbmQgc3ZnV2lkdGgvc3ZnSGVpZ2h0IG5vdCBzcGVjaWZpZWQsXG4gICAgICAvLyB3ZSBoYXZlIHRvIGRldGVybWluZSBob3cgdG8gbGF5b3V0IHRob3NlIGVsZW1lbnQgdG8gbWFrZSB0aGVtIGxvb2sgZ29vZC5cbiAgICAgIGlmIChiUmVjdFggPT0gbnVsbCB8fCBiUmVjdFkgPT0gbnVsbCkge1xuICAgICAgICB2YXIgY2FsY3VsYXRlZEJvdW5kaW5nUmVjdCA9IHJvb3RGcm9tUGFyc2UuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIGlmIChiUmVjdFggPT0gbnVsbCkge1xuICAgICAgICAgIGJSZWN0WCA9IGNhbGN1bGF0ZWRCb3VuZGluZ1JlY3QueDtcbiAgICAgICAgICBiUmVjdFdpZHRoID0gY2FsY3VsYXRlZEJvdW5kaW5nUmVjdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYlJlY3RZID09IG51bGwpIHtcbiAgICAgICAgICBiUmVjdFkgPSBjYWxjdWxhdGVkQm91bmRpbmdSZWN0Lnk7XG4gICAgICAgICAgYlJlY3RIZWlnaHQgPSBjYWxjdWxhdGVkQm91bmRpbmdSZWN0LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYm91bmRpbmdSZWN0ID0gdGhpcy5fYm91bmRpbmdSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChiUmVjdFgsIGJSZWN0WSwgYlJlY3RXaWR0aCwgYlJlY3RIZWlnaHQpO1xuICAgIH1cbiAgICBpZiAodmlld0JveFJlY3QpIHtcbiAgICAgIHZhciB2aWV3Qm94VHJhbnNmb3JtID0gbWFrZVZpZXdCb3hUcmFuc2Zvcm0odmlld0JveFJlY3QsIGJvdW5kaW5nUmVjdCk7XG4gICAgICAvLyBPbmx5IHN1cHBvcnQgYHByZXNlcnZlQXNwZWN0UmF0aW8gJ3hNaWRZTWlkJ2BcbiAgICAgIHJvb3RGcm9tUGFyc2Uuc2NhbGVYID0gcm9vdEZyb21QYXJzZS5zY2FsZVkgPSB2aWV3Qm94VHJhbnNmb3JtLnNjYWxlO1xuICAgICAgcm9vdEZyb21QYXJzZS54ID0gdmlld0JveFRyYW5zZm9ybS54O1xuICAgICAgcm9vdEZyb21QYXJzZS55ID0gdmlld0JveFRyYW5zZm9ybS55O1xuICAgIH1cbiAgICAvLyBTVkcgbmVlZHMgdG8gY2xpcCBiYXNlZCBvbiBgdmlld0JveGAuIEFuZCBzb21lIFNWRyBmaWxlcyByZWFsbHkgcmVseSBvbiB0aGlzIGZlYXR1cmUuXG4gICAgLy8gVGhleSBkbyBub3Qgc3RyaWN0bHkgY29uZmluZSBhbGwgb2YgdGhlIGNvbnRlbnQgaW5zaWRlIGEgZGlzcGxheSByZWN0LCBidXQgZGVsaWJlcmF0ZWx5XG4gICAgLy8gdXNlIGEgYHZpZXdCb3hgIHRvIGRlZmluZSBhIGRpc3BsYXlhYmxlIHJlY3QuXG4gICAgLy8gUEVORElORzpcbiAgICAvLyBUaGUgZHJhd2JhY2sgb2YgdGhlIGBzZXRDbGlwUGF0aGAgaGVyZSBpczogdGhlIHJlZ2lvbiBsYWJlbCAoZ2VuZXJldGVkIGJ5IGVjaGFydHMpIG5lYXIgdGhlXG4gICAgLy8gZWRnZSBtaWdodCBhbHNvIGJlIGNsaXBwZWQsIGJlY2F1c2UgcmVnaW9uIGxhYmVscyBhcmUgcHV0IGFzIGB0ZXh0Q29udGVudGAgb2YgdGhlIFNWRyBwYXRoLlxuICAgIHJvb3Quc2V0Q2xpcFBhdGgobmV3IFJlY3Qoe1xuICAgICAgc2hhcGU6IGJvdW5kaW5nUmVjdC5wbGFpbigpXG4gICAgfSkpO1xuICAgIHZhciBuYW1lZCA9IFtdO1xuICAgIGVhY2gocmVzdWx0Lm5hbWVkLCBmdW5jdGlvbiAobmFtZWRJdGVtKSB7XG4gICAgICBpZiAoUkVHSU9OX0FWQUlMQUJMRV9TVkdfVEFHX01BUC5nZXQobmFtZWRJdGVtLnN2Z05vZGVUYWdMb3dlcikgIT0gbnVsbCkge1xuICAgICAgICBuYW1lZC5wdXNoKG5hbWVkSXRlbSk7XG4gICAgICAgIHNldFNpbGVudChuYW1lZEl0ZW0uZWwpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByb290OiByb290LFxuICAgICAgYm91bmRpbmdSZWN0OiBib3VuZGluZ1JlY3QsXG4gICAgICBuYW1lZDogbmFtZWRcbiAgICB9O1xuICB9O1xuICAvKipcclxuICAgKiBDb25zaWRlcjpcclxuICAgKiAoMSkgT25lIGdyYXBoaWMgZWxlbWVudCBjYW4gbm90IGJlIHNoYXJlZCBieSBkaWZmZXJlbnQgYGdlb1ZpZXdgIHJ1bm5pbmcgc2ltdWx0YW5lb3VzbHkuXHJcbiAgICogICAgIE5vdGljZSwgYWxzbyBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVjaGFydHMgaW5zdGFuY2VzIHNoYXJlIGEgYG1hcFJlY29yZGAuXHJcbiAgICogKDIpIENvbnZlcnRpbmcgU1ZHIHRvIGdyYXBoaWMgZWxlbWVudHMgaXMgdGltZSBjb25zdW1pbmcuXHJcbiAgICogKDMpIEluIHRoZSBjdXJyZW50IGFyY2hpdGVjdHVyZSwgYGxvYWRgIHNob3VsZCBiZSBjYWxsZWQgZnJlcXVlbnRseSB0byBnZXQgYm91bmRpbmdSZWN0LFxyXG4gICAqICAgICBhbmQgaXQgaXMgY2FsbGVkIHdpdGhvdXQgdmlldyBpbmZvLlxyXG4gICAqIFNvIHdlIG1haW50YWluIGdyYXBoaWMgZWxlbWVudHMgaW4gdGhpcyBtb2R1bGUsIGFuZCBlbmFibGVzIGB2aWV3YCB0byB1c2UvcmV0dXJuIHRoZXNlXHJcbiAgICogZ3JhcGhpY3MgZnJvbS90byB0aGUgcG9vbCB3aXRoIGl0J3MgdWlkLlxyXG4gICAqL1xuICBHZW9TVkdSZXNvdXJjZS5wcm90b3R5cGUudXNlR3JhcGhpYyA9IGZ1bmN0aW9uIChob3N0S2V5IC8qICwgbmFtZU1hcDogTmFtZU1hcCAqLykge1xuICAgIHZhciB1c2VkUm9vdE1hcCA9IHRoaXMuX3VzZWRHcmFwaGljTWFwO1xuICAgIHZhciBzdmdHcmFwaGljID0gdXNlZFJvb3RNYXAuZ2V0KGhvc3RLZXkpO1xuICAgIGlmIChzdmdHcmFwaGljKSB7XG4gICAgICByZXR1cm4gc3ZnR3JhcGhpYztcbiAgICB9XG4gICAgc3ZnR3JhcGhpYyA9IHRoaXMuX2ZyZWVkR3JhcGhpY3MucG9wKClcbiAgICAvLyB1c2UgdGhlIGZpcnN0IGJvdW5kaW5nUmVjdCB0byBhdm9pZCBkdXBsaWNhdGVkIGJvdW5kaW5nUmVjdCBjYWxjdWxhdGlvbi5cbiAgICB8fCB0aGlzLl9idWlsZEdyYXBoaWModGhpcy5fcGFyc2VkWE1MKTtcbiAgICB1c2VkUm9vdE1hcC5zZXQoaG9zdEtleSwgc3ZnR3JhcGhpYyk7XG4gICAgLy8gUEVORElORzogYG5hbWVNYXBgIHdpbGwgbm90IGJlIHN1cHBvcnRlZCB1bnRpbCBzb21lIHJlYWwgcmVxdWlyZW1lbnQgY29tZS5cbiAgICAvLyBgbmFtZU1hcGAgY2FuIG9ubHkgYmUgb2J0YWluZWQgZnJvbSBlY2hhcnRzIG9wdGlvbi5cbiAgICAvLyBUaGUgb3JpZ2luYWwgYG5hbWVkYCBtdXN0IG5vdCBiZSBtb2RpZmllZC5cbiAgICAvLyBpZiAobmFtZU1hcCkge1xuICAgIC8vICAgICBzdmdHcmFwaGljID0gZXh0ZW5kKHt9LCBzdmdHcmFwaGljKTtcbiAgICAvLyAgICAgc3ZnR3JhcGhpYy5uYW1lZCA9IGFwcGx5TmFtZU1hcChzdmdHcmFwaGljLm5hbWVkLCBuYW1lTWFwKTtcbiAgICAvLyB9XG4gICAgcmV0dXJuIHN2Z0dyYXBoaWM7XG4gIH07XG4gIEdlb1NWR1Jlc291cmNlLnByb3RvdHlwZS5mcmVlR3JhcGhpYyA9IGZ1bmN0aW9uIChob3N0S2V5KSB7XG4gICAgdmFyIHVzZWRSb290TWFwID0gdGhpcy5fdXNlZEdyYXBoaWNNYXA7XG4gICAgdmFyIHN2Z0dyYXBoaWMgPSB1c2VkUm9vdE1hcC5nZXQoaG9zdEtleSk7XG4gICAgaWYgKHN2Z0dyYXBoaWMpIHtcbiAgICAgIHVzZWRSb290TWFwLnJlbW92ZUtleShob3N0S2V5KTtcbiAgICAgIHRoaXMuX2ZyZWVkR3JhcGhpY3MucHVzaChzdmdHcmFwaGljKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBHZW9TVkdSZXNvdXJjZTtcbn0oKTtcbmV4cG9ydCB7IEdlb1NWR1Jlc291cmNlIH07XG5mdW5jdGlvbiBzZXRTaWxlbnQoZWwpIHtcbiAgLy8gT25seSBuYW1lZCBlbGVtZW50IGhhcyBzaWxlbnQ6IGZhbHNlLCBvdGhlciBlbGVtZW50cyBzaG91bGRcbiAgLy8gYWN0IGFzIGJhY2tncm91bmQgYW5kIGhhcyBubyB1c2VyIGludGVyYWN0aW9uLlxuICBlbC5zaWxlbnQgPSBmYWxzZTtcbiAgLy8gdGV4dHx0c3BhbiB3aWxsIGJlIGNvbnZlcnRlZCB0byBncm91cC5cbiAgaWYgKGVsLmlzR3JvdXApIHtcbiAgICBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGNoaWxkLnNpbGVudCA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVSZWdpb25zKG5hbWVkKSB7XG4gIHZhciByZWdpb25zID0gW107XG4gIHZhciByZWdpb25zTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuICAvLyBDcmVhdGUgcmVzaW9ucyBvbmx5IGZvciB0aGUgZmlyc3QgZ3JhcGhpYy5cbiAgZWFjaChuYW1lZCwgZnVuY3Rpb24gKG5hbWVkSXRlbSkge1xuICAgIC8vIFJlZ2lvbiBoYXMgZmVhdHVyZSB0byBjYWxjdWxhdGUgY2VudGVyIGZvciB0b29sdGlwIG9yIG90aGVyIGZlYXR1cmVzLlxuICAgIC8vIElmIHRoZXJlIGlzIGEgPGcgbmFtZT1cInh4eFwiPiwgdGhlIGNlbnRlciBzaG91bGQgYmUgdGhlIGNlbnRlciBvZiB0aGVcbiAgICAvLyBib3VuZGluZyByZWN0IG9mIHRoZSBnLlxuICAgIGlmIChuYW1lZEl0ZW0ubmFtZWRGcm9tICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJlZ2lvbiA9IG5ldyBHZW9TVkdSZWdpb24obmFtZWRJdGVtLm5hbWUsIG5hbWVkSXRlbS5lbCk7XG4gICAgLy8gUEVORElORzogaWYgYG5hbWVNYXBgIHN1cHBvcnRlZCwgdGhpcyByZWdpb24gY2FuIG5vdCBiZSBtb3VudGVkIG9uXG4gICAgLy8gYHRoaXNgLCBidXQgY2FuIG9ubHkgYmUgY3JlYXRlZCBlYWNoIHRpbWUgYGxvYWQoKWAgY2FsbGVkLlxuICAgIHJlZ2lvbnMucHVzaChyZWdpb24pO1xuICAgIC8vIFBFTkRJTkc6IGlmIG11bHRpcGxlIHRhZyBuYW1lZCB3aXRoIHRoZSBzYW1lIG5hbWUsIG9ubHkgb25lIHdpbGwgYmVcbiAgICAvLyBmb3VuZCBieSBgX3JlZ2lvbnNNYXBgLiBgX3JlZ2lvbnNNYXBgIGlzIHVzZWQgdG8gZmluZCBhIGNvb3JkaW5hdGVcbiAgICAvLyBieSBuYW1lLiBXZSB1c2UgYHJlZ2lvbi5nZXRDZW50ZXIoKWAgYXMgdGhlIGNvb3JkaW5hdGUuXG4gICAgcmVnaW9uc01hcC5zZXQobmFtZWRJdGVtLm5hbWUsIHJlZ2lvbik7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHJlZ2lvbnM6IHJlZ2lvbnMsXG4gICAgcmVnaW9uc01hcDogcmVnaW9uc01hcFxuICB9O1xufVxuLy8gUEVORElORzogYG5hbWVNYXBgIHdpbGwgbm90IGJlIHN1cHBvcnRlZCB1bnRpbCBzb21lIHJlYWwgcmVxdWlyZW1lbnQgY29tZS5cbi8vIC8qKlxuLy8gICogVXNlIHRoZSBhbGlhcyBpbiBnZW9OYW1lTWFwLlxuLy8gICogVGhlIGlucHV0IGBuYW1lZGAgbXVzdCBub3QgYmUgbW9kaWZpZWQuXG4vLyAgKi9cbi8vIGZ1bmN0aW9uIGFwcGx5TmFtZU1hcChcbi8vICAgICBuYW1lZDogR2VvU1ZHR3JhcGhpY1JlY29yZFsnbmFtZWQnXSxcbi8vICAgICBuYW1lTWFwOiBOYW1lTWFwXG4vLyApOiBHZW9TVkdHcmFwaGljUmVjb3JkWyduYW1lZCddIHtcbi8vICAgICBjb25zdCByZXN1bHQgPSBbXSBhcyBHZW9TVkdHcmFwaGljUmVjb3JkWyduYW1lZCddO1xuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZWQubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgbGV0IHJlZ2lvbkdyYXBoaWMgPSBuYW1lZFtpXTtcbi8vICAgICAgICAgY29uc3QgbmFtZSA9IHJlZ2lvbkdyYXBoaWMubmFtZTtcbi8vICAgICAgICAgaWYgKG5hbWVNYXAgJiYgbmFtZU1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuLy8gICAgICAgICAgICAgcmVnaW9uR3JhcGhpYyA9IGV4dGVuZCh7fSwgcmVnaW9uR3JhcGhpYyk7XG4vLyAgICAgICAgICAgICByZWdpb25HcmFwaGljLm5hbWUgPSBuYW1lO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIHJlc3VsdC5wdXNoKHJlZ2lvbkdyYXBoaWMpO1xuLy8gICAgIH1cbi8vICAgICByZXR1cm4gcmVzdWx0O1xuLy8gfSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLy8gRml4IGZvciDljZfmtbfor7jlsptcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgR2VvSlNPTlJlZ2lvbiB9IGZyb20gJy4uL1JlZ2lvbi5qcyc7XG52YXIgZ2VvQ29vcmQgPSBbMTI2LCAyNV07XG52YXIgbmFuaGFpTmFtZSA9ICfljZfmtbfor7jlspsnO1xudmFyIHBvaW50cyA9IFtbWzAsIDMuNV0sIFs3LCAxMS4yXSwgWzE1LCAxMS45XSwgWzMwLCA3XSwgWzQyLCAwLjddLCBbNTIsIDAuN10sIFs1NiwgNy43XSwgWzU5LCAwLjddLCBbNjQsIDAuN10sIFs2NCwgMF0sIFs1LCAwXSwgWzAsIDMuNV1dLCBbWzEzLCAxNi4xXSwgWzE5LCAxNC43XSwgWzE2LCAyMS43XSwgWzExLCAyMy4xXSwgWzEzLCAxNi4xXV0sIFtbMTIsIDMyLjJdLCBbMTQsIDM4LjVdLCBbMTUsIDM4LjVdLCBbMTMsIDMyLjJdLCBbMTIsIDMyLjJdXSwgW1sxNiwgNDcuNl0sIFsxMiwgNTMuMl0sIFsxMywgNTMuMl0sIFsxOCwgNDcuNl0sIFsxNiwgNDcuNl1dLCBbWzYsIDY0LjRdLCBbOCwgNzBdLCBbOSwgNzBdLCBbOCwgNjQuNF0sIFs2LCA2NC40XV0sIFtbMjMsIDgyLjZdLCBbMjksIDc5LjhdLCBbMzAsIDc5LjhdLCBbMjUsIDgyLjZdLCBbMjMsIDgyLjZdXSwgW1szNywgNzAuN10sIFs0MywgNjIuM10sIFs0NCwgNjIuM10sIFszOSwgNzAuN10sIFszNywgNzAuN11dLCBbWzQ4LCA1MS4xXSwgWzUxLCA0NS41XSwgWzUzLCA0NS41XSwgWzUwLCA1MS4xXSwgWzQ4LCA1MS4xXV0sIFtbNTEsIDM1XSwgWzUxLCAyOC43XSwgWzUzLCAyOC43XSwgWzUzLCAzNV0sIFs1MSwgMzVdXSwgW1s1MiwgMjIuNF0sIFs1NSwgMTcuNV0sIFs1NiwgMTcuNV0sIFs1MywgMjIuNF0sIFs1MiwgMjIuNF1dLCBbWzU4LCAxMi42XSwgWzYyLCA3XSwgWzYzLCA3XSwgWzYwLCAxMi42XSwgWzU4LCAxMi42XV0sIFtbMCwgMy41XSwgWzAsIDkzLjFdLCBbNjQsIDkzLjFdLCBbNjQsIDBdLCBbNjMsIDBdLCBbNjMsIDkyLjRdLCBbMSwgOTIuNF0sIFsxLCAzLjVdLCBbMCwgMy41XV1dO1xuZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCBwb2ludHNbaV0ubGVuZ3RoOyBrKyspIHtcbiAgICBwb2ludHNbaV1ba11bMF0gLz0gMTAuNTtcbiAgICBwb2ludHNbaV1ba11bMV0gLz0gLTEwLjUgLyAwLjc1O1xuICAgIHBvaW50c1tpXVtrXVswXSArPSBnZW9Db29yZFswXTtcbiAgICBwb2ludHNbaV1ba11bMV0gKz0gZ2VvQ29vcmRbMV07XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpeE5hbmhhaShtYXBUeXBlLCByZWdpb25zKSB7XG4gIGlmIChtYXBUeXBlID09PSAnY2hpbmEnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBBbHJlYWR5IGV4aXN0cy5cbiAgICAgIGlmIChyZWdpb25zW2ldLm5hbWUgPT09IG5hbmhhaU5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZWdpb25zLnB1c2gobmV3IEdlb0pTT05SZWdpb24obmFuaGFpTmFtZSwgenJVdGlsLm1hcChwb2ludHMsIGZ1bmN0aW9uIChleHRlcmlvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3BvbHlnb24nLFxuICAgICAgICBleHRlcmlvcjogZXh0ZXJpb3JcbiAgICAgIH07XG4gICAgfSksIGdlb0Nvb3JkKSk7XG4gIH1cbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbnZhciBjb29yZHNPZmZzZXRNYXAgPSB7XG4gICfljZfmtbfor7jlspsnOiBbMzIsIDgwXSxcbiAgLy8g5YWo5Zu9XG4gICflub/kuJwnOiBbMCwgLTEwXSxcbiAgJ+mmmea4ryc6IFsxMCwgNV0sXG4gICfmvrPpl6gnOiBbLTEwLCAxMF0sXG4gIC8vICfljJfkuqwnOiBbLTEwLCAwXSxcbiAgJ+Wkqea0pSc6IFs1LCA1XVxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpeFRleHRDb29yZHMobWFwVHlwZSwgcmVnaW9uKSB7XG4gIGlmIChtYXBUeXBlID09PSAnY2hpbmEnKSB7XG4gICAgdmFyIGNvb3JkRml4ID0gY29vcmRzT2Zmc2V0TWFwW3JlZ2lvbi5uYW1lXTtcbiAgICBpZiAoY29vcmRGaXgpIHtcbiAgICAgIHZhciBjcCA9IHJlZ2lvbi5nZXRDZW50ZXIoKTtcbiAgICAgIGNwWzBdICs9IGNvb3JkRml4WzBdIC8gMTAuNTtcbiAgICAgIGNwWzFdICs9IC1jb29yZEZpeFsxXSAvICgxMC41IC8gMC43NSk7XG4gICAgICByZWdpb24uc2V0Q2VudGVyKGNwKTtcbiAgICB9XG4gIH1cbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbi8vIEZpeCBmb3Ig6ZKT6bG85bKbXG4vLyBsZXQgUmVnaW9uID0gcmVxdWlyZSgnLi4vUmVnaW9uJyk7XG4vLyBsZXQgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4vLyBsZXQgZ2VvQ29vcmQgPSBbMTI2LCAyNV07XG52YXIgcG9pbnRzID0gW1tbMTIzLjQ1MTY1MjUyNjg1NTQ3LCAyNS43MzUyNzE2NDQwMjI2MV0sIFsxMjMuNDk3MzE0NDUzMTI0OTksIDI1LjczNTI3MTY0NDAyMjYxXSwgWzEyMy40OTczMTQ0NTMxMjQ5OSwgMjUuNzUwNzM0MDY0NjAwODg0XSwgWzEyMy40NTE2NTI1MjY4NTU0NywgMjUuNzUwNzM0MDY0NjAwODg0XSwgWzEyMy40NTE2NTI1MjY4NTU0NywgMjUuNzM1MjcxNjQ0MDIyNjFdXV07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaXhEaWFveXVJc2xhbmQobWFwVHlwZSwgcmVnaW9uKSB7XG4gIGlmIChtYXBUeXBlID09PSAnY2hpbmEnICYmIHJlZ2lvbi5uYW1lID09PSAn5Y+w5rm+Jykge1xuICAgIHJlZ2lvbi5nZW9tZXRyaWVzLnB1c2goe1xuICAgICAgdHlwZTogJ3BvbHlnb24nLFxuICAgICAgZXh0ZXJpb3I6IHBvaW50c1swXVxuICAgIH0pO1xuICB9XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBlYWNoLCBpc1N0cmluZywgY3JlYXRlSGFzaE1hcCwgaGFzT3duIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBwYXJzZUdlb0pzb24gZnJvbSAnLi9wYXJzZUdlb0pzb24uanMnO1xuLy8gQnVpbHQtaW4gR0VPIGZpeGVyLlxuaW1wb3J0IGZpeE5hbmhhaSBmcm9tICcuL2ZpeC9uYW5oYWkuanMnO1xuaW1wb3J0IGZpeFRleHRDb29yZCBmcm9tICcuL2ZpeC90ZXh0Q29vcmQuanMnO1xuaW1wb3J0IGZpeERpYW95dUlzbGFuZCBmcm9tICcuL2ZpeC9kaWFveXVJc2xhbmQuanMnO1xuaW1wb3J0IEJvdW5kaW5nUmVjdCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcyc7XG52YXIgREVGQVVMVF9OQU1FX1BST1BFUlRZID0gJ25hbWUnO1xudmFyIEdlb0pTT05SZXNvdXJjZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdlb0pTT05SZXNvdXJjZShtYXBOYW1lLCBnZW9KU09OLCBzcGVjaWFsQXJlYXMpIHtcbiAgICB0aGlzLnR5cGUgPSAnZ2VvSlNPTic7XG4gICAgdGhpcy5fcGFyc2VkTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuICAgIHRoaXMuX21hcE5hbWUgPSBtYXBOYW1lO1xuICAgIHRoaXMuX3NwZWNpYWxBcmVhcyA9IHNwZWNpYWxBcmVhcztcbiAgICAvLyBQRU5ESU5HOiBkZWxheSB0aGUgcGFyc2UgdG8gdGhlIGZpcnN0IHVzYWdlIHRvIHJhcGlkIHVwIHRoZSBGTVA/XG4gICAgdGhpcy5fZ2VvSlNPTiA9IHBhcnNlSW5wdXQoZ2VvSlNPTik7XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIG5hbWVNYXAgY2FuIGJlIG51bGwvdW5kZWZpbmVkXHJcbiAgICogQHBhcmFtIG5hbWVQcm9wZXJ0eSBjYW4gYmUgbnVsbC91bmRlZmluZWRcclxuICAgKi9cbiAgR2VvSlNPTlJlc291cmNlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKG5hbWVNYXAsIG5hbWVQcm9wZXJ0eSkge1xuICAgIG5hbWVQcm9wZXJ0eSA9IG5hbWVQcm9wZXJ0eSB8fCBERUZBVUxUX05BTUVfUFJPUEVSVFk7XG4gICAgdmFyIHBhcnNlZCA9IHRoaXMuX3BhcnNlZE1hcC5nZXQobmFtZVByb3BlcnR5KTtcbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgdmFyIHJhd1JlZ2lvbnMgPSB0aGlzLl9wYXJzZVRvUmVnaW9ucyhuYW1lUHJvcGVydHkpO1xuICAgICAgcGFyc2VkID0gdGhpcy5fcGFyc2VkTWFwLnNldChuYW1lUHJvcGVydHksIHtcbiAgICAgICAgcmVnaW9uczogcmF3UmVnaW9ucyxcbiAgICAgICAgYm91bmRpbmdSZWN0OiBjYWxjdWxhdGVCb3VuZGluZ1JlY3QocmF3UmVnaW9ucylcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcmVnaW9uc01hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgICB2YXIgZmluYWxSZWdpb25zID0gW107XG4gICAgZWFjaChwYXJzZWQucmVnaW9ucywgZnVuY3Rpb24gKHJlZ2lvbikge1xuICAgICAgdmFyIHJlZ2lvbk5hbWUgPSByZWdpb24ubmFtZTtcbiAgICAgIC8vIFRyeSB1c2UgdGhlIGFsaWFzIGluIGdlb05hbWVNYXBcbiAgICAgIGlmIChuYW1lTWFwICYmIGhhc093bihuYW1lTWFwLCByZWdpb25OYW1lKSkge1xuICAgICAgICByZWdpb24gPSByZWdpb24uY2xvbmVTaGFsbG93KHJlZ2lvbk5hbWUgPSBuYW1lTWFwW3JlZ2lvbk5hbWVdKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsUmVnaW9ucy5wdXNoKHJlZ2lvbik7XG4gICAgICByZWdpb25zTWFwLnNldChyZWdpb25OYW1lLCByZWdpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZWdpb25zOiBmaW5hbFJlZ2lvbnMsXG4gICAgICBib3VuZGluZ1JlY3Q6IHBhcnNlZC5ib3VuZGluZ1JlY3QgfHwgbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKSxcbiAgICAgIHJlZ2lvbnNNYXA6IHJlZ2lvbnNNYXBcbiAgICB9O1xuICB9O1xuICBHZW9KU09OUmVzb3VyY2UucHJvdG90eXBlLl9wYXJzZVRvUmVnaW9ucyA9IGZ1bmN0aW9uIChuYW1lUHJvcGVydHkpIHtcbiAgICB2YXIgbWFwTmFtZSA9IHRoaXMuX21hcE5hbWU7XG4gICAgdmFyIGdlb0pTT04gPSB0aGlzLl9nZW9KU09OO1xuICAgIHZhciByYXdSZWdpb25zO1xuICAgIC8vIGh0dHBzOi8vanNwZXJmLmNvbS90cnktY2F0Y2gtcGVyZm9ybWFuY2Utb3ZlcmhlYWRcbiAgICB0cnkge1xuICAgICAgcmF3UmVnaW9ucyA9IGdlb0pTT04gPyBwYXJzZUdlb0pzb24oZ2VvSlNPTiwgbmFtZVByb3BlcnR5KSA6IFtdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBnZW9Kc29uIGZvcm1hdFxcbicgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBmaXhOYW5oYWkobWFwTmFtZSwgcmF3UmVnaW9ucyk7XG4gICAgZWFjaChyYXdSZWdpb25zLCBmdW5jdGlvbiAocmVnaW9uKSB7XG4gICAgICB2YXIgcmVnaW9uTmFtZSA9IHJlZ2lvbi5uYW1lO1xuICAgICAgZml4VGV4dENvb3JkKG1hcE5hbWUsIHJlZ2lvbik7XG4gICAgICBmaXhEaWFveXVJc2xhbmQobWFwTmFtZSwgcmVnaW9uKTtcbiAgICAgIC8vIFNvbWUgYXJlYSBsaWtlIEFsYXNrYSBpbiBVU0EgbWFwIG5lZWRzIHRvIGJlIHRhbnNmb3JtZWRcbiAgICAgIC8vIHRvIGxvb2sgYmV0dGVyXG4gICAgICB2YXIgc3BlY2lhbEFyZWEgPSB0aGlzLl9zcGVjaWFsQXJlYXMgJiYgdGhpcy5fc3BlY2lhbEFyZWFzW3JlZ2lvbk5hbWVdO1xuICAgICAgaWYgKHNwZWNpYWxBcmVhKSB7XG4gICAgICAgIHJlZ2lvbi50cmFuc2Zvcm1UbyhzcGVjaWFsQXJlYS5sZWZ0LCBzcGVjaWFsQXJlYS50b3AsIHNwZWNpYWxBcmVhLndpZHRoLCBzcGVjaWFsQXJlYS5oZWlnaHQpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiByYXdSZWdpb25zO1xuICB9O1xuICAvKipcclxuICAgKiBPbmx5IGZvciBleHBvcnRpbmcgdG8gdXNlcnMuXHJcbiAgICogKipNVVNUIE5PVCoqIHVzZWQgaW50ZXJuYWxseS5cclxuICAgKi9cbiAgR2VvSlNPTlJlc291cmNlLnByb3RvdHlwZS5nZXRNYXBGb3JVc2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIGdlb0pzb25cbiAgICAgIC8vIFBFTkRJTkc6IGl0IGhhcyBiZWVuIHJldHVybmluZyB0aGVtIHdpdGhvdXQgY2xvbmUuXG4gICAgICAvLyBkbyB3ZSBuZWVkIHRvIGF2b2lkIG91dHNpdGUgbW9kaWZpY2F0aW9uP1xuICAgICAgZ2VvSnNvbjogdGhpcy5fZ2VvSlNPTixcbiAgICAgIGdlb0pTT046IHRoaXMuX2dlb0pTT04sXG4gICAgICBzcGVjaWFsQXJlYXM6IHRoaXMuX3NwZWNpYWxBcmVhc1xuICAgIH07XG4gIH07XG4gIHJldHVybiBHZW9KU09OUmVzb3VyY2U7XG59KCk7XG5leHBvcnQgeyBHZW9KU09OUmVzb3VyY2UgfTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZUJvdW5kaW5nUmVjdChyZWdpb25zKSB7XG4gIHZhciByZWN0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVnaW9uUmVjdCA9IHJlZ2lvbnNbaV0uZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgcmVjdCA9IHJlY3QgfHwgcmVnaW9uUmVjdC5jbG9uZSgpO1xuICAgIHJlY3QudW5pb24ocmVnaW9uUmVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlY3Q7XG59XG5mdW5jdGlvbiBwYXJzZUlucHV0KHNvdXJjZSkge1xuICByZXR1cm4gIWlzU3RyaW5nKHNvdXJjZSkgPyBzb3VyY2UgOiB0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcgJiYgSlNPTi5wYXJzZSA/IEpTT04ucGFyc2Uoc291cmNlKSA6IG5ldyBGdW5jdGlvbigncmV0dXJuICgnICsgc291cmNlICsgJyk7JykoKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGNyZWF0ZUhhc2hNYXAgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgR2VvU1ZHUmVzb3VyY2UgfSBmcm9tICcuL0dlb1NWR1Jlc291cmNlLmpzJztcbmltcG9ydCB7IEdlb0pTT05SZXNvdXJjZSB9IGZyb20gJy4vR2VvSlNPTlJlc291cmNlLmpzJztcbnZhciBzdG9yYWdlID0gY3JlYXRlSGFzaE1hcCgpO1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcclxuICAgKiBDb21wYXRpYmxlIHdpdGggcHJldmlvdXMgYGVjaGFydHMucmVnaXN0ZXJNYXBgLlxyXG4gICAqXHJcbiAgICogQHVzYWdlXHJcbiAgICogYGBganNcclxuICAgKlxyXG4gICAqIGVjaGFydHMucmVnaXN0ZXJNYXAoJ1VTQScsIGdlb0pzb24sIHNwZWNpYWxBcmVhcyk7XHJcbiAgICpcclxuICAgKiBlY2hhcnRzLnJlZ2lzdGVyTWFwKCdVU0EnLCB7XHJcbiAgICogICAgIGdlb0pzb246IGdlb0pzb24sXHJcbiAgICogICAgIHNwZWNpYWxBcmVhczogey4uLn1cclxuICAgKiB9KTtcclxuICAgKiBlY2hhcnRzLnJlZ2lzdGVyTWFwKCdVU0EnLCB7XHJcbiAgICogICAgIGdlb0pTT046IGdlb0pzb24sXHJcbiAgICogICAgIHNwZWNpYWxBcmVhczogey4uLn1cclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIGVjaGFydHMucmVnaXN0ZXJNYXAoJ2FpcnBvcnQnLCB7XHJcbiAgICogICAgIHN2Zzogc3ZnXHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogTm90ZTpcclxuICAgKiBEbyBub3Qgc3VwcG9ydCB0aGF0IHJlZ2lzdGVyIG11bHRpcGxlIGdlb0pTT04gb3IgU1ZHXHJcbiAgICogb25lIG1hcCBuYW1lLiBCZWNhdXNlIGRpZmZlcmVudCBnZW9KU09OIGFuZCBTVkcgaGF2ZVxyXG4gICAqIGRpZmZlcmVudCB1bml0LiBJdCdzIG5vdCBlYXN5IHRvIG1ha2Ugc3VyZSBob3cgdGhvc2VcclxuICAgKiB1bml0cyBhcmUgbWFwcGluZy9ub3JtYWxpemUuXHJcbiAgICogSWYgaW50ZW5kaW5nIHRvIHVzZSBtdWx0aXBsZSBnZW9KU09OIG9yIFNWRywgd2UgY2FuXHJcbiAgICogdXNlIG11bHRpcGxlIGdlbyBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgKi9cbiAgcmVnaXN0ZXJNYXA6IGZ1bmN0aW9uIChtYXBOYW1lLCByYXdEZWYsIHJhd1NwZWNpYWxBcmVhcykge1xuICAgIGlmIChyYXdEZWYuc3ZnKSB7XG4gICAgICB2YXIgcmVzb3VyY2UgPSBuZXcgR2VvU1ZHUmVzb3VyY2UobWFwTmFtZSwgcmF3RGVmLnN2Zyk7XG4gICAgICBzdG9yYWdlLnNldChtYXBOYW1lLCByZXNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlY29tbWVuZDpcbiAgICAgIC8vICAgICBlY2hhcnRzLnJlZ2lzdGVyTWFwKCdldScsIHsgZ2VvSlNPTjogeHh4LCBzcGVjaWFsQXJlYXM6IHh4eCB9KTtcbiAgICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6XG4gICAgICAvLyAgICAgZWNoYXJ0cy5yZWdpc3Rlck1hcCgnZXUnLCBnZW9KU09OLCBzcGVjaWFsQXJlYXMpO1xuICAgICAgLy8gICAgIGVjaGFydHMucmVnaXN0ZXJNYXAoJ2V1JywgeyBnZW9Kc29uOiB4eHgsIHNwZWNpYWxBcmVhczogeHh4IH0pO1xuICAgICAgdmFyIGdlb0pTT04gPSByYXdEZWYuZ2VvSnNvbiB8fCByYXdEZWYuZ2VvSlNPTjtcbiAgICAgIGlmIChnZW9KU09OICYmICFyYXdEZWYuZmVhdHVyZXMpIHtcbiAgICAgICAgcmF3U3BlY2lhbEFyZWFzID0gcmF3RGVmLnNwZWNpYWxBcmVhcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlb0pTT04gPSByYXdEZWY7XG4gICAgICB9XG4gICAgICB2YXIgcmVzb3VyY2UgPSBuZXcgR2VvSlNPTlJlc291cmNlKG1hcE5hbWUsIGdlb0pTT04sIHJhd1NwZWNpYWxBcmVhcyk7XG4gICAgICBzdG9yYWdlLnNldChtYXBOYW1lLCByZXNvdXJjZSk7XG4gICAgfVxuICB9LFxuICBnZXRHZW9SZXNvdXJjZTogZnVuY3Rpb24gKG1hcE5hbWUpIHtcbiAgICByZXR1cm4gc3RvcmFnZS5nZXQobWFwTmFtZSk7XG4gIH0sXG4gIC8qKlxyXG4gICAqIE9ubHkgZm9yIGV4cG9ydGluZyB0byB1c2Vycy5cclxuICAgKiAqKk1VU1QgTk9UKiogdXNlZCBpbnRlcm5hbGx5LlxyXG4gICAqL1xuICBnZXRNYXBGb3JVc2VyOiBmdW5jdGlvbiAobWFwTmFtZSkge1xuICAgIHZhciByZXNvdXJjZSA9IHN0b3JhZ2UuZ2V0KG1hcE5hbWUpO1xuICAgIC8vIERvIG5vdCBzdXBwb3J0IHJldHVybiBTVkcgdW50aWwgc29tZSByZWFsIHJlcXVpcmVtZW50IGNvbWUuXG4gICAgcmV0dXJuIHJlc291cmNlICYmIHJlc291cmNlLnR5cGUgPT09ICdnZW9KU09OJyAmJiByZXNvdXJjZS5nZXRNYXBGb3JVc2VyKCk7XG4gIH0sXG4gIGxvYWQ6IGZ1bmN0aW9uIChtYXBOYW1lLCBuYW1lTWFwLCBuYW1lUHJvcGVydHkpIHtcbiAgICB2YXIgcmVzb3VyY2UgPSBzdG9yYWdlLmdldChtYXBOYW1lKTtcbiAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdNYXAgJyArIG1hcE5hbWUgKyAnIG5vdCBleGlzdHMuIFRoZSBHZW9KU09OIG9mIHRoZSBtYXAgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc291cmNlLmxvYWQobmFtZU1hcCwgbmFtZVByb3BlcnR5KTtcbiAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///76311\n")},76953:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ singlePrepareCustom)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction dataToCoordSize(dataSize, dataItem) {\n  // dataItem is necessary in log axis.\n  var axis = this.getAxis();\n  var val = dataItem instanceof Array ? dataItem[0] : dataItem;\n  var halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;\n  return axis.type === \'category\' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));\n}\nfunction singlePrepareCustom(coordSys) {\n  var rect = coordSys.getRect();\n  return {\n    coordSys: {\n      type: \'singleAxis\',\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    },\n    api: {\n      coord: function (val) {\n        // do not provide "out" param\n        return coordSys.dataToPoint(val);\n      },\n      size: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.bind)(dataToCoordSize, coordSys)\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY5NTMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL3NpbmdsZS9wcmVwYXJlQ3VzdG9tLmpzP2NhMzEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBiaW5kIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmZ1bmN0aW9uIGRhdGFUb0Nvb3JkU2l6ZShkYXRhU2l6ZSwgZGF0YUl0ZW0pIHtcbiAgLy8gZGF0YUl0ZW0gaXMgbmVjZXNzYXJ5IGluIGxvZyBheGlzLlxuICB2YXIgYXhpcyA9IHRoaXMuZ2V0QXhpcygpO1xuICB2YXIgdmFsID0gZGF0YUl0ZW0gaW5zdGFuY2VvZiBBcnJheSA/IGRhdGFJdGVtWzBdIDogZGF0YUl0ZW07XG4gIHZhciBoYWxmU2l6ZSA9IChkYXRhU2l6ZSBpbnN0YW5jZW9mIEFycmF5ID8gZGF0YVNpemVbMF0gOiBkYXRhU2l6ZSkgLyAyO1xuICByZXR1cm4gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gYXhpcy5nZXRCYW5kV2lkdGgoKSA6IE1hdGguYWJzKGF4aXMuZGF0YVRvQ29vcmQodmFsIC0gaGFsZlNpemUpIC0gYXhpcy5kYXRhVG9Db29yZCh2YWwgKyBoYWxmU2l6ZSkpO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2luZ2xlUHJlcGFyZUN1c3RvbShjb29yZFN5cykge1xuICB2YXIgcmVjdCA9IGNvb3JkU3lzLmdldFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICBjb29yZFN5czoge1xuICAgICAgdHlwZTogJ3NpbmdsZUF4aXMnLFxuICAgICAgeDogcmVjdC54LFxuICAgICAgeTogcmVjdC55LFxuICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgfSxcbiAgICBhcGk6IHtcbiAgICAgIGNvb3JkOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIC8vIGRvIG5vdCBwcm92aWRlIFwib3V0XCIgcGFyYW1cbiAgICAgICAgcmV0dXJuIGNvb3JkU3lzLmRhdGFUb1BvaW50KHZhbCk7XG4gICAgICB9LFxuICAgICAgc2l6ZTogYmluZChkYXRhVG9Db29yZFNpemUsIGNvb3JkU3lzKVxuICAgIH1cbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///76953\n')},78308:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ parallelPreprocessor)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction parallelPreprocessor(option) {\n  createParallelIfNeeded(option);\n  mergeAxisOptionFromParallel(option);\n}\n/**\r\n * Create a parallel coordinate if not exists.\r\n * @inner\r\n */\nfunction createParallelIfNeeded(option) {\n  if (option.parallel) {\n    return;\n  }\n  var hasParallelSeries = false;\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(option.series, function (seriesOpt) {\n    if (seriesOpt && seriesOpt.type === \'parallel\') {\n      hasParallelSeries = true;\n    }\n  });\n  if (hasParallelSeries) {\n    option.parallel = [{}];\n  }\n}\n/**\r\n * Merge aixs definition from parallel option (if exists) to axis option.\r\n * @inner\r\n */\nfunction mergeAxisOptionFromParallel(option) {\n  var axes = _util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .normalizeToArray */ .qB(option.parallelAxis);\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(axes, function (axisOption) {\n    if (!zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject(axisOption)) {\n      return;\n    }\n    var parallelIndex = axisOption.parallelIndex || 0;\n    var parallelOption = _util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .normalizeToArray */ .qB(option.parallel)[parallelIndex];\n    if (parallelOption && parallelOption.parallelAxisDefault) {\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.merge(axisOption, parallelOption.parallelAxisDefault, false);\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzgzMDguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvcGFyYWxsZWwvcGFyYWxsZWxQcmVwcm9jZXNzb3IuanM/MzZkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgbW9kZWxVdGlsIGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyYWxsZWxQcmVwcm9jZXNzb3Iob3B0aW9uKSB7XG4gIGNyZWF0ZVBhcmFsbGVsSWZOZWVkZWQob3B0aW9uKTtcbiAgbWVyZ2VBeGlzT3B0aW9uRnJvbVBhcmFsbGVsKG9wdGlvbik7XG59XG4vKipcclxuICogQ3JlYXRlIGEgcGFyYWxsZWwgY29vcmRpbmF0ZSBpZiBub3QgZXhpc3RzLlxyXG4gKiBAaW5uZXJcclxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJhbGxlbElmTmVlZGVkKG9wdGlvbikge1xuICBpZiAob3B0aW9uLnBhcmFsbGVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBoYXNQYXJhbGxlbFNlcmllcyA9IGZhbHNlO1xuICB6clV0aWwuZWFjaChvcHRpb24uc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzT3B0KSB7XG4gICAgaWYgKHNlcmllc09wdCAmJiBzZXJpZXNPcHQudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgaGFzUGFyYWxsZWxTZXJpZXMgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIGlmIChoYXNQYXJhbGxlbFNlcmllcykge1xuICAgIG9wdGlvbi5wYXJhbGxlbCA9IFt7fV07XG4gIH1cbn1cbi8qKlxyXG4gKiBNZXJnZSBhaXhzIGRlZmluaXRpb24gZnJvbSBwYXJhbGxlbCBvcHRpb24gKGlmIGV4aXN0cykgdG8gYXhpcyBvcHRpb24uXHJcbiAqIEBpbm5lclxyXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXhpc09wdGlvbkZyb21QYXJhbGxlbChvcHRpb24pIHtcbiAgdmFyIGF4ZXMgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShvcHRpb24ucGFyYWxsZWxBeGlzKTtcbiAgenJVdGlsLmVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXNPcHRpb24pIHtcbiAgICBpZiAoIXpyVXRpbC5pc09iamVjdChheGlzT3B0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGFyYWxsZWxJbmRleCA9IGF4aXNPcHRpb24ucGFyYWxsZWxJbmRleCB8fCAwO1xuICAgIHZhciBwYXJhbGxlbE9wdGlvbiA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG9wdGlvbi5wYXJhbGxlbClbcGFyYWxsZWxJbmRleF07XG4gICAgaWYgKHBhcmFsbGVsT3B0aW9uICYmIHBhcmFsbGVsT3B0aW9uLnBhcmFsbGVsQXhpc0RlZmF1bHQpIHtcbiAgICAgIHpyVXRpbC5tZXJnZShheGlzT3B0aW9uLCBwYXJhbGxlbE9wdGlvbi5wYXJhbGxlbEF4aXNEZWZhdWx0LCBmYWxzZSk7XG4gICAgfVxuICB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///78308\n')},79798:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ geoPrepareCustom)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction dataToCoordSize(dataSize, dataItem) {\n  dataItem = dataItem || [0, 0];\n  return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map([0, 1], function (dimIdx) {\n    var val = dataItem[dimIdx];\n    var halfSize = dataSize[dimIdx] / 2;\n    var p1 = [];\n    var p2 = [];\n    p1[dimIdx] = val - halfSize;\n    p2[dimIdx] = val + halfSize;\n    p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];\n    return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);\n  }, this);\n}\nfunction geoPrepareCustom(coordSys) {\n  var rect = coordSys.getBoundingRect();\n  return {\n    coordSys: {\n      type: \'geo\',\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height,\n      zoom: coordSys.getZoom()\n    },\n    api: {\n      coord: function (data) {\n        // do not provide "out" and noRoam param,\n        // Compatible with this usage:\n        // echarts.util.map(item.points, api.coord)\n        return coordSys.dataToPoint(data);\n      },\n      size: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.bind(dataToCoordSize, coordSys)\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk3OTguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2dlby9wcmVwYXJlQ3VzdG9tLmpzPzllMzgiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmZ1bmN0aW9uIGRhdGFUb0Nvb3JkU2l6ZShkYXRhU2l6ZSwgZGF0YUl0ZW0pIHtcbiAgZGF0YUl0ZW0gPSBkYXRhSXRlbSB8fCBbMCwgMF07XG4gIHJldHVybiB6clV0aWwubWFwKFswLCAxXSwgZnVuY3Rpb24gKGRpbUlkeCkge1xuICAgIHZhciB2YWwgPSBkYXRhSXRlbVtkaW1JZHhdO1xuICAgIHZhciBoYWxmU2l6ZSA9IGRhdGFTaXplW2RpbUlkeF0gLyAyO1xuICAgIHZhciBwMSA9IFtdO1xuICAgIHZhciBwMiA9IFtdO1xuICAgIHAxW2RpbUlkeF0gPSB2YWwgLSBoYWxmU2l6ZTtcbiAgICBwMltkaW1JZHhdID0gdmFsICsgaGFsZlNpemU7XG4gICAgcDFbMSAtIGRpbUlkeF0gPSBwMlsxIC0gZGltSWR4XSA9IGRhdGFJdGVtWzEgLSBkaW1JZHhdO1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmRhdGFUb1BvaW50KHAxKVtkaW1JZHhdIC0gdGhpcy5kYXRhVG9Qb2ludChwMilbZGltSWR4XSk7XG4gIH0sIHRoaXMpO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2VvUHJlcGFyZUN1c3RvbShjb29yZFN5cykge1xuICB2YXIgcmVjdCA9IGNvb3JkU3lzLmdldEJvdW5kaW5nUmVjdCgpO1xuICByZXR1cm4ge1xuICAgIGNvb3JkU3lzOiB7XG4gICAgICB0eXBlOiAnZ2VvJyxcbiAgICAgIHg6IHJlY3QueCxcbiAgICAgIHk6IHJlY3QueSxcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgIHpvb206IGNvb3JkU3lzLmdldFpvb20oKVxuICAgIH0sXG4gICAgYXBpOiB7XG4gICAgICBjb29yZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gZG8gbm90IHByb3ZpZGUgXCJvdXRcIiBhbmQgbm9Sb2FtIHBhcmFtLFxuICAgICAgICAvLyBDb21wYXRpYmxlIHdpdGggdGhpcyB1c2FnZTpcbiAgICAgICAgLy8gZWNoYXJ0cy51dGlsLm1hcChpdGVtLnBvaW50cywgYXBpLmNvb3JkKVxuICAgICAgICByZXR1cm4gY29vcmRTeXMuZGF0YVRvUG9pbnQoZGF0YSk7XG4gICAgICB9LFxuICAgICAgc2l6ZTogenJVdGlsLmJpbmQoZGF0YVRvQ29vcmRTaXplLCBjb29yZFN5cylcbiAgICB9XG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///79798\n')},84557:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ cartesianPrepareCustom)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction dataToCoordSize(dataSize, dataItem) {\n  // dataItem is necessary in log axis.\n  dataItem = dataItem || [0, 0];\n  return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map(['x', 'y'], function (dim, dimIdx) {\n    var axis = this.getAxis(dim);\n    var val = dataItem[dimIdx];\n    var halfSize = dataSize[dimIdx] / 2;\n    return axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));\n  }, this);\n}\nfunction cartesianPrepareCustom(coordSys) {\n  var rect = coordSys.master.getRect();\n  return {\n    coordSys: {\n      // The name exposed to user is always 'cartesian2d' but not 'grid'.\n      type: 'cartesian2d',\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    },\n    api: {\n      coord: function (data) {\n        // do not provide \"out\" param\n        return coordSys.dataToPoint(data);\n      },\n      size: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.bind(dataToCoordSize, coordSys)\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ1NTcuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL3ByZXBhcmVDdXN0b20uanM/ZDhlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuZnVuY3Rpb24gZGF0YVRvQ29vcmRTaXplKGRhdGFTaXplLCBkYXRhSXRlbSkge1xuICAvLyBkYXRhSXRlbSBpcyBuZWNlc3NhcnkgaW4gbG9nIGF4aXMuXG4gIGRhdGFJdGVtID0gZGF0YUl0ZW0gfHwgWzAsIDBdO1xuICByZXR1cm4genJVdGlsLm1hcChbJ3gnLCAneSddLCBmdW5jdGlvbiAoZGltLCBkaW1JZHgpIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMuZ2V0QXhpcyhkaW0pO1xuICAgIHZhciB2YWwgPSBkYXRhSXRlbVtkaW1JZHhdO1xuICAgIHZhciBoYWxmU2l6ZSA9IGRhdGFTaXplW2RpbUlkeF0gLyAyO1xuICAgIHJldHVybiBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyBheGlzLmdldEJhbmRXaWR0aCgpIDogTWF0aC5hYnMoYXhpcy5kYXRhVG9Db29yZCh2YWwgLSBoYWxmU2l6ZSkgLSBheGlzLmRhdGFUb0Nvb3JkKHZhbCArIGhhbGZTaXplKSk7XG4gIH0sIHRoaXMpO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2FydGVzaWFuUHJlcGFyZUN1c3RvbShjb29yZFN5cykge1xuICB2YXIgcmVjdCA9IGNvb3JkU3lzLm1hc3Rlci5nZXRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgY29vcmRTeXM6IHtcbiAgICAgIC8vIFRoZSBuYW1lIGV4cG9zZWQgdG8gdXNlciBpcyBhbHdheXMgJ2NhcnRlc2lhbjJkJyBidXQgbm90ICdncmlkJy5cbiAgICAgIHR5cGU6ICdjYXJ0ZXNpYW4yZCcsXG4gICAgICB4OiByZWN0LngsXG4gICAgICB5OiByZWN0LnksXG4gICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICB9LFxuICAgIGFwaToge1xuICAgICAgY29vcmQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIGRvIG5vdCBwcm92aWRlIFwib3V0XCIgcGFyYW1cbiAgICAgICAgcmV0dXJuIGNvb3JkU3lzLmRhdGFUb1BvaW50KGRhdGEpO1xuICAgICAgfSxcbiAgICAgIHNpemU6IHpyVXRpbC5iaW5kKGRhdGFUb0Nvb3JkU2l6ZSwgY29vcmRTeXMpXG4gICAgfVxuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///84557\n")},85508:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Z: () => (/* binding */ layout)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction layout(axisModel, opt) {\n  opt = opt || {};\n  var single = axisModel.coordinateSystem;\n  var axis = axisModel.axis;\n  var layout = {};\n  var axisPosition = axis.position;\n  var orient = axis.orient;\n  var rect = single.getRect();\n  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n  var positionMap = {\n    horizontal: {\n      top: rectBound[2],\n      bottom: rectBound[3]\n    },\n    vertical: {\n      left: rectBound[0],\n      right: rectBound[1]\n    }\n  };\n  layout.position = [orient === 'vertical' ? positionMap.vertical[axisPosition] : rectBound[0], orient === 'horizontal' ? positionMap.horizontal[axisPosition] : rectBound[3]];\n  var r = {\n    horizontal: 0,\n    vertical: 1\n  };\n  layout.rotation = Math.PI / 2 * r[orient];\n  var directionMap = {\n    top: -1,\n    bottom: 1,\n    right: 1,\n    left: -1\n  };\n  layout.labelDirection = layout.tickDirection = layout.nameDirection = directionMap[axisPosition];\n  if (axisModel.get(['axisTick', 'inside'])) {\n    layout.tickDirection = -layout.tickDirection;\n  }\n  if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.retrieve(opt.labelInside, axisModel.get(['axisLabel', 'inside']))) {\n    layout.labelDirection = -layout.labelDirection;\n  }\n  var labelRotation = opt.rotate;\n  labelRotation == null && (labelRotation = axisModel.get(['axisLabel', 'rotate']));\n  layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n  layout.z2 = 1;\n  return layout;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU1MDguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL3NpbmdsZS9zaW5nbGVBeGlzSGVscGVyLmpzP2I0YzQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBsYXlvdXQoYXhpc01vZGVsLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICB2YXIgc2luZ2xlID0gYXhpc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gIHZhciBsYXlvdXQgPSB7fTtcbiAgdmFyIGF4aXNQb3NpdGlvbiA9IGF4aXMucG9zaXRpb247XG4gIHZhciBvcmllbnQgPSBheGlzLm9yaWVudDtcbiAgdmFyIHJlY3QgPSBzaW5nbGUuZ2V0UmVjdCgpO1xuICB2YXIgcmVjdEJvdW5kID0gW3JlY3QueCwgcmVjdC54ICsgcmVjdC53aWR0aCwgcmVjdC55LCByZWN0LnkgKyByZWN0LmhlaWdodF07XG4gIHZhciBwb3NpdGlvbk1hcCA9IHtcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICB0b3A6IHJlY3RCb3VuZFsyXSxcbiAgICAgIGJvdHRvbTogcmVjdEJvdW5kWzNdXG4gICAgfSxcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgbGVmdDogcmVjdEJvdW5kWzBdLFxuICAgICAgcmlnaHQ6IHJlY3RCb3VuZFsxXVxuICAgIH1cbiAgfTtcbiAgbGF5b3V0LnBvc2l0aW9uID0gW29yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/IHBvc2l0aW9uTWFwLnZlcnRpY2FsW2F4aXNQb3NpdGlvbl0gOiByZWN0Qm91bmRbMF0sIG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gcG9zaXRpb25NYXAuaG9yaXpvbnRhbFtheGlzUG9zaXRpb25dIDogcmVjdEJvdW5kWzNdXTtcbiAgdmFyIHIgPSB7XG4gICAgaG9yaXpvbnRhbDogMCxcbiAgICB2ZXJ0aWNhbDogMVxuICB9O1xuICBsYXlvdXQucm90YXRpb24gPSBNYXRoLlBJIC8gMiAqIHJbb3JpZW50XTtcbiAgdmFyIGRpcmVjdGlvbk1hcCA9IHtcbiAgICB0b3A6IC0xLFxuICAgIGJvdHRvbTogMSxcbiAgICByaWdodDogMSxcbiAgICBsZWZ0OiAtMVxuICB9O1xuICBsYXlvdXQubGFiZWxEaXJlY3Rpb24gPSBsYXlvdXQudGlja0RpcmVjdGlvbiA9IGxheW91dC5uYW1lRGlyZWN0aW9uID0gZGlyZWN0aW9uTWFwW2F4aXNQb3NpdGlvbl07XG4gIGlmIChheGlzTW9kZWwuZ2V0KFsnYXhpc1RpY2snLCAnaW5zaWRlJ10pKSB7XG4gICAgbGF5b3V0LnRpY2tEaXJlY3Rpb24gPSAtbGF5b3V0LnRpY2tEaXJlY3Rpb247XG4gIH1cbiAgaWYgKHpyVXRpbC5yZXRyaWV2ZShvcHQubGFiZWxJbnNpZGUsIGF4aXNNb2RlbC5nZXQoWydheGlzTGFiZWwnLCAnaW5zaWRlJ10pKSkge1xuICAgIGxheW91dC5sYWJlbERpcmVjdGlvbiA9IC1sYXlvdXQubGFiZWxEaXJlY3Rpb247XG4gIH1cbiAgdmFyIGxhYmVsUm90YXRpb24gPSBvcHQucm90YXRlO1xuICBsYWJlbFJvdGF0aW9uID09IG51bGwgJiYgKGxhYmVsUm90YXRpb24gPSBheGlzTW9kZWwuZ2V0KFsnYXhpc0xhYmVsJywgJ3JvdGF0ZSddKSk7XG4gIGxheW91dC5sYWJlbFJvdGF0aW9uID0gYXhpc1Bvc2l0aW9uID09PSAndG9wJyA/IC1sYWJlbFJvdGF0aW9uIDogbGFiZWxSb3RhdGlvbjtcbiAgbGF5b3V0LnoyID0gMTtcbiAgcmV0dXJuIGxheW91dDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///85508\n")},86351:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15915);\n/* harmony import */ var _axisModelCommonMixin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12462);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar SingleAxisModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(SingleAxisModel, _super);\n  function SingleAxisModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = SingleAxisModel.type;\n    return _this;\n  }\n  SingleAxisModel.prototype.getCoordSysModel = function () {\n    return this;\n  };\n  SingleAxisModel.type = 'singleAxis';\n  SingleAxisModel.layoutMode = 'box';\n  SingleAxisModel.defaultOption = {\n    left: '5%',\n    top: '5%',\n    right: '5%',\n    bottom: '5%',\n    type: 'value',\n    position: 'bottom',\n    orient: 'horizontal',\n    axisLine: {\n      show: true,\n      lineStyle: {\n        width: 1,\n        type: 'solid'\n      }\n    },\n    // Single coordinate system and single axis is the,\n    // which is used as the parent tooltip model.\n    // same model, so we set default tooltip show as true.\n    tooltip: {\n      show: true\n    },\n    axisTick: {\n      show: true,\n      length: 6,\n      lineStyle: {\n        width: 1\n      }\n    },\n    axisLabel: {\n      show: true,\n      interval: 'auto'\n    },\n    splitLine: {\n      show: true,\n      lineStyle: {\n        type: 'dashed',\n        opacity: 0.2\n      }\n    }\n  };\n  return SingleAxisModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A);\n(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.mixin)(SingleAxisModel, _axisModelCommonMixin_js__WEBPACK_IMPORTED_MODULE_3__/* .AxisModelCommonMixin */ .L.prototype);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SingleAxisModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYzNTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL3NpbmdsZS9BeGlzTW9kZWwuanM/N2FkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IENvbXBvbmVudE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL0NvbXBvbmVudC5qcyc7XG5pbXBvcnQgeyBBeGlzTW9kZWxDb21tb25NaXhpbiB9IGZyb20gJy4uL2F4aXNNb2RlbENvbW1vbk1peGluLmpzJztcbmltcG9ydCB7IG1peGluIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbnZhciBTaW5nbGVBeGlzTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2luZ2xlQXhpc01vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBTaW5nbGVBeGlzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IFNpbmdsZUF4aXNNb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBTaW5nbGVBeGlzTW9kZWwucHJvdG90eXBlLmdldENvb3JkU3lzTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIFNpbmdsZUF4aXNNb2RlbC50eXBlID0gJ3NpbmdsZUF4aXMnO1xuICBTaW5nbGVBeGlzTW9kZWwubGF5b3V0TW9kZSA9ICdib3gnO1xuICBTaW5nbGVBeGlzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICBsZWZ0OiAnNSUnLFxuICAgIHRvcDogJzUlJyxcbiAgICByaWdodDogJzUlJyxcbiAgICBib3R0b206ICc1JScsXG4gICAgdHlwZTogJ3ZhbHVlJyxcbiAgICBwb3NpdGlvbjogJ2JvdHRvbScsXG4gICAgb3JpZW50OiAnaG9yaXpvbnRhbCcsXG4gICAgYXhpc0xpbmU6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFNpbmdsZSBjb29yZGluYXRlIHN5c3RlbSBhbmQgc2luZ2xlIGF4aXMgaXMgdGhlLFxuICAgIC8vIHdoaWNoIGlzIHVzZWQgYXMgdGhlIHBhcmVudCB0b29sdGlwIG1vZGVsLlxuICAgIC8vIHNhbWUgbW9kZWwsIHNvIHdlIHNldCBkZWZhdWx0IHRvb2x0aXAgc2hvdyBhcyB0cnVlLlxuICAgIHRvb2x0aXA6IHtcbiAgICAgIHNob3c6IHRydWVcbiAgICB9LFxuICAgIGF4aXNUaWNrOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgbGVuZ3RoOiA2LFxuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiAxXG4gICAgICB9XG4gICAgfSxcbiAgICBheGlzTGFiZWw6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBpbnRlcnZhbDogJ2F1dG8nXG4gICAgfSxcbiAgICBzcGxpdExpbmU6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgdHlwZTogJ2Rhc2hlZCcsXG4gICAgICAgIG9wYWNpdHk6IDAuMlxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFNpbmdsZUF4aXNNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xubWl4aW4oU2luZ2xlQXhpc01vZGVsLCBBeGlzTW9kZWxDb21tb25NaXhpbi5wcm90b3R5cGUpO1xuZXhwb3J0IGRlZmF1bHQgU2luZ2xlQXhpc01vZGVsOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///86351\n")},89737:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar coordinateSystemCreators = {};\nvar CoordinateSystemManager = /** @class */function () {\n  function CoordinateSystemManager() {\n    this._coordinateSystems = [];\n  }\n  CoordinateSystemManager.prototype.create = function (ecModel, api) {\n    var coordinateSystems = [];\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(coordinateSystemCreators, function (creator, type) {\n      var list = creator.create(ecModel, api);\n      coordinateSystems = coordinateSystems.concat(list || []);\n    });\n    this._coordinateSystems = coordinateSystems;\n  };\n  CoordinateSystemManager.prototype.update = function (ecModel, api) {\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(this._coordinateSystems, function (coordSys) {\n      coordSys.update && coordSys.update(ecModel, api);\n    });\n  };\n  CoordinateSystemManager.prototype.getCoordinateSystems = function () {\n    return this._coordinateSystems.slice();\n  };\n  CoordinateSystemManager.register = function (type, creator) {\n    coordinateSystemCreators[type] = creator;\n  };\n  CoordinateSystemManager.get = function (type) {\n    return coordinateSystemCreators[type];\n  };\n  return CoordinateSystemManager;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoordinateSystemManager);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk3MzcuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29yZS9Db29yZGluYXRlU3lzdGVtLmpzPzZiMTgiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbnZhciBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnMgPSB7fTtcbnZhciBDb29yZGluYXRlU3lzdGVtTWFuYWdlciA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyKCkge1xuICAgIHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zID0gW107XG4gIH1cbiAgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgY29vcmRpbmF0ZVN5c3RlbXMgPSBbXTtcbiAgICB6clV0aWwuZWFjaChjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnMsIGZ1bmN0aW9uIChjcmVhdG9yLCB0eXBlKSB7XG4gICAgICB2YXIgbGlzdCA9IGNyZWF0b3IuY3JlYXRlKGVjTW9kZWwsIGFwaSk7XG4gICAgICBjb29yZGluYXRlU3lzdGVtcyA9IGNvb3JkaW5hdGVTeXN0ZW1zLmNvbmNhdChsaXN0IHx8IFtdKTtcbiAgICB9KTtcbiAgICB0aGlzLl9jb29yZGluYXRlU3lzdGVtcyA9IGNvb3JkaW5hdGVTeXN0ZW1zO1xuICB9O1xuICBDb29yZGluYXRlU3lzdGVtTWFuYWdlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHpyVXRpbC5lYWNoKHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zLCBmdW5jdGlvbiAoY29vcmRTeXMpIHtcbiAgICAgIGNvb3JkU3lzLnVwZGF0ZSAmJiBjb29yZFN5cy51cGRhdGUoZWNNb2RlbCwgYXBpKTtcbiAgICB9KTtcbiAgfTtcbiAgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIucHJvdG90eXBlLmdldENvb3JkaW5hdGVTeXN0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlU3lzdGVtcy5zbGljZSgpO1xuICB9O1xuICBDb29yZGluYXRlU3lzdGVtTWFuYWdlci5yZWdpc3RlciA9IGZ1bmN0aW9uICh0eXBlLCBjcmVhdG9yKSB7XG4gICAgY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3JzW3R5cGVdID0gY3JlYXRvcjtcbiAgfTtcbiAgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIuZ2V0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICByZXR1cm4gY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3JzW3R5cGVdO1xuICB9O1xuICByZXR1cm4gQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXI7XG59KCk7XG5leHBvcnQgZGVmYXVsdCBDb29yZGluYXRlU3lzdGVtTWFuYWdlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///89737\n')},93074:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98026);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48170);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(15915);\n/* harmony import */ var _model_Model_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(43172);\n/* harmony import */ var _geoCreator_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98592);\n/* harmony import */ var _geoSourceManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76311);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n;\nvar GeoModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(GeoModel, _super);\n  function GeoModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = GeoModel.type;\n    return _this;\n  }\n  GeoModel.prototype.init = function (option, parentModel, ecModel) {\n    var source = _geoSourceManager_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A.getGeoResource(option.map);\n    if (source && source.type === 'geoJSON') {\n      var itemStyle = option.itemStyle = option.itemStyle || {};\n      if (!('color' in itemStyle)) {\n        itemStyle.color = '#eee';\n      }\n    }\n    this.mergeDefaultAndTheme(option, ecModel);\n    // Default label emphasis `show`\n    _util_model_js__WEBPACK_IMPORTED_MODULE_2__/* .defaultEmphasis */ .M5(option, 'label', ['show']);\n  };\n  GeoModel.prototype.optionUpdated = function () {\n    var _this = this;\n    var option = this.option;\n    option.regions = _geoCreator_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A.getFilledRegions(option.regions, option.map, option.nameMap, option.nameProperty);\n    var selectedMap = {};\n    this._optionModelMap = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.reduce(option.regions || [], function (optionModelMap, regionOpt) {\n      var regionName = regionOpt.name;\n      if (regionName) {\n        optionModelMap.set(regionName, new _model_Model_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A(regionOpt, _this, _this.ecModel));\n        if (regionOpt.selected) {\n          selectedMap[regionName] = true;\n        }\n      }\n      return optionModelMap;\n    }, zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.createHashMap());\n    if (!option.selectedMap) {\n      option.selectedMap = selectedMap;\n    }\n  };\n  /**\r\n   * Get model of region.\r\n   */\n  GeoModel.prototype.getRegionModel = function (name) {\n    return this._optionModelMap.get(name) || new _model_Model_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A(null, this, this.ecModel);\n  };\n  /**\r\n   * Format label\r\n   * @param name Region name\r\n   */\n  GeoModel.prototype.getFormattedLabel = function (name, status) {\n    var regionModel = this.getRegionModel(name);\n    var formatter = status === 'normal' ? regionModel.get(['label', 'formatter']) : regionModel.get(['emphasis', 'label', 'formatter']);\n    var params = {\n      name: name\n    };\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.isFunction(formatter)) {\n      params.status = status;\n      return formatter(params);\n    } else if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.isString(formatter)) {\n      return formatter.replace('{a}', name != null ? name : '');\n    }\n  };\n  GeoModel.prototype.setZoom = function (zoom) {\n    this.option.zoom = zoom;\n  };\n  GeoModel.prototype.setCenter = function (center) {\n    this.option.center = center;\n  };\n  // PENGING If selectedMode is null ?\n  GeoModel.prototype.select = function (name) {\n    var option = this.option;\n    var selectedMode = option.selectedMode;\n    if (!selectedMode) {\n      return;\n    }\n    if (selectedMode !== 'multiple') {\n      option.selectedMap = null;\n    }\n    var selectedMap = option.selectedMap || (option.selectedMap = {});\n    selectedMap[name] = true;\n  };\n  GeoModel.prototype.unSelect = function (name) {\n    var selectedMap = this.option.selectedMap;\n    if (selectedMap) {\n      selectedMap[name] = false;\n    }\n  };\n  GeoModel.prototype.toggleSelected = function (name) {\n    this[this.isSelected(name) ? 'unSelect' : 'select'](name);\n  };\n  GeoModel.prototype.isSelected = function (name) {\n    var selectedMap = this.option.selectedMap;\n    return !!(selectedMap && selectedMap[name]);\n  };\n  GeoModel.type = 'geo';\n  GeoModel.layoutMode = 'box';\n  GeoModel.defaultOption = {\n    // zlevel: 0,\n    z: 0,\n    show: true,\n    left: 'center',\n    top: 'center',\n    // Default value:\n    // for geoSVG source: 1,\n    // for geoJSON source: 0.75.\n    aspectScale: null,\n    // /// Layout with center and size\n    // If you want to put map in a fixed size box with right aspect ratio\n    // This two properties may be more convenient\n    // layoutCenter: [50%, 50%]\n    // layoutSize: 100\n    silent: false,\n    // Map type\n    map: '',\n    // Define left-top, right-bottom coords to control view\n    // For example, [ [180, 90], [-180, -90] ]\n    boundingCoords: null,\n    // Default on center of map\n    center: null,\n    zoom: 1,\n    scaleLimit: null,\n    // selectedMode: false\n    label: {\n      show: false,\n      color: '#000'\n    },\n    itemStyle: {\n      borderWidth: 0.5,\n      borderColor: '#444'\n      // Default color:\n      // + geoJSON: #eee\n      // + geoSVG: null (use SVG original `fill`)\n      // color: '#eee'\n    },\n    emphasis: {\n      label: {\n        show: true,\n        color: 'rgb(100,0,0)'\n      },\n      itemStyle: {\n        color: 'rgba(255,215,0,0.8)'\n      }\n    },\n    select: {\n      label: {\n        show: true,\n        color: 'rgb(100,0,0)'\n      },\n      itemStyle: {\n        color: 'rgba(255,215,0,0.8)'\n      }\n    },\n    regions: []\n    // tooltip: {\n    //     show: false\n    // }\n  };\n  return GeoModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTMwNzQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9nZW8vR2VvTW9kZWwuanM/MWU4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgKiBhcyBtb2RlbFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50LmpzJztcbmltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Nb2RlbC5qcyc7XG5pbXBvcnQgZ2VvQ3JlYXRvciBmcm9tICcuL2dlb0NyZWF0b3IuanMnO1xuaW1wb3J0IGdlb1NvdXJjZU1hbmFnZXIgZnJvbSAnLi9nZW9Tb3VyY2VNYW5hZ2VyLmpzJztcbjtcbnZhciBHZW9Nb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhHZW9Nb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gR2VvTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IEdlb01vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEdlb01vZGVsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpIHtcbiAgICB2YXIgc291cmNlID0gZ2VvU291cmNlTWFuYWdlci5nZXRHZW9SZXNvdXJjZShvcHRpb24ubWFwKTtcbiAgICBpZiAoc291cmNlICYmIHNvdXJjZS50eXBlID09PSAnZ2VvSlNPTicpIHtcbiAgICAgIHZhciBpdGVtU3R5bGUgPSBvcHRpb24uaXRlbVN0eWxlID0gb3B0aW9uLml0ZW1TdHlsZSB8fCB7fTtcbiAgICAgIGlmICghKCdjb2xvcicgaW4gaXRlbVN0eWxlKSkge1xuICAgICAgICBpdGVtU3R5bGUuY29sb3IgPSAnI2VlZSc7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcbiAgICAvLyBEZWZhdWx0IGxhYmVsIGVtcGhhc2lzIGBzaG93YFxuICAgIG1vZGVsVXRpbC5kZWZhdWx0RW1waGFzaXMob3B0aW9uLCAnbGFiZWwnLCBbJ3Nob3cnXSk7XG4gIH07XG4gIEdlb01vZGVsLnByb3RvdHlwZS5vcHRpb25VcGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIG9wdGlvbi5yZWdpb25zID0gZ2VvQ3JlYXRvci5nZXRGaWxsZWRSZWdpb25zKG9wdGlvbi5yZWdpb25zLCBvcHRpb24ubWFwLCBvcHRpb24ubmFtZU1hcCwgb3B0aW9uLm5hbWVQcm9wZXJ0eSk7XG4gICAgdmFyIHNlbGVjdGVkTWFwID0ge307XG4gICAgdGhpcy5fb3B0aW9uTW9kZWxNYXAgPSB6clV0aWwucmVkdWNlKG9wdGlvbi5yZWdpb25zIHx8IFtdLCBmdW5jdGlvbiAob3B0aW9uTW9kZWxNYXAsIHJlZ2lvbk9wdCkge1xuICAgICAgdmFyIHJlZ2lvbk5hbWUgPSByZWdpb25PcHQubmFtZTtcbiAgICAgIGlmIChyZWdpb25OYW1lKSB7XG4gICAgICAgIG9wdGlvbk1vZGVsTWFwLnNldChyZWdpb25OYW1lLCBuZXcgTW9kZWwocmVnaW9uT3B0LCBfdGhpcywgX3RoaXMuZWNNb2RlbCkpO1xuICAgICAgICBpZiAocmVnaW9uT3B0LnNlbGVjdGVkKSB7XG4gICAgICAgICAgc2VsZWN0ZWRNYXBbcmVnaW9uTmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9uTW9kZWxNYXA7XG4gICAgfSwgenJVdGlsLmNyZWF0ZUhhc2hNYXAoKSk7XG4gICAgaWYgKCFvcHRpb24uc2VsZWN0ZWRNYXApIHtcbiAgICAgIG9wdGlvbi5zZWxlY3RlZE1hcCA9IHNlbGVjdGVkTWFwO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IG1vZGVsIG9mIHJlZ2lvbi5cclxuICAgKi9cbiAgR2VvTW9kZWwucHJvdG90eXBlLmdldFJlZ2lvbk1vZGVsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9uTW9kZWxNYXAuZ2V0KG5hbWUpIHx8IG5ldyBNb2RlbChudWxsLCB0aGlzLCB0aGlzLmVjTW9kZWwpO1xuICB9O1xuICAvKipcclxuICAgKiBGb3JtYXQgbGFiZWxcclxuICAgKiBAcGFyYW0gbmFtZSBSZWdpb24gbmFtZVxyXG4gICAqL1xuICBHZW9Nb2RlbC5wcm90b3R5cGUuZ2V0Rm9ybWF0dGVkTGFiZWwgPSBmdW5jdGlvbiAobmFtZSwgc3RhdHVzKSB7XG4gICAgdmFyIHJlZ2lvbk1vZGVsID0gdGhpcy5nZXRSZWdpb25Nb2RlbChuYW1lKTtcbiAgICB2YXIgZm9ybWF0dGVyID0gc3RhdHVzID09PSAnbm9ybWFsJyA/IHJlZ2lvbk1vZGVsLmdldChbJ2xhYmVsJywgJ2Zvcm1hdHRlciddKSA6IHJlZ2lvbk1vZGVsLmdldChbJ2VtcGhhc2lzJywgJ2xhYmVsJywgJ2Zvcm1hdHRlciddKTtcbiAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgbmFtZTogbmFtZVxuICAgIH07XG4gICAgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKGZvcm1hdHRlcikpIHtcbiAgICAgIHBhcmFtcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyKHBhcmFtcyk7XG4gICAgfSBlbHNlIGlmICh6clV0aWwuaXNTdHJpbmcoZm9ybWF0dGVyKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlci5yZXBsYWNlKCd7YX0nLCBuYW1lICE9IG51bGwgPyBuYW1lIDogJycpO1xuICAgIH1cbiAgfTtcbiAgR2VvTW9kZWwucHJvdG90eXBlLnNldFpvb20gPSBmdW5jdGlvbiAoem9vbSkge1xuICAgIHRoaXMub3B0aW9uLnpvb20gPSB6b29tO1xuICB9O1xuICBHZW9Nb2RlbC5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGNlbnRlcikge1xuICAgIHRoaXMub3B0aW9uLmNlbnRlciA9IGNlbnRlcjtcbiAgfTtcbiAgLy8gUEVOR0lORyBJZiBzZWxlY3RlZE1vZGUgaXMgbnVsbCA/XG4gIEdlb01vZGVsLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgc2VsZWN0ZWRNb2RlID0gb3B0aW9uLnNlbGVjdGVkTW9kZTtcbiAgICBpZiAoIXNlbGVjdGVkTW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2VsZWN0ZWRNb2RlICE9PSAnbXVsdGlwbGUnKSB7XG4gICAgICBvcHRpb24uc2VsZWN0ZWRNYXAgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgc2VsZWN0ZWRNYXAgPSBvcHRpb24uc2VsZWN0ZWRNYXAgfHwgKG9wdGlvbi5zZWxlY3RlZE1hcCA9IHt9KTtcbiAgICBzZWxlY3RlZE1hcFtuYW1lXSA9IHRydWU7XG4gIH07XG4gIEdlb01vZGVsLnByb3RvdHlwZS51blNlbGVjdCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHNlbGVjdGVkTWFwID0gdGhpcy5vcHRpb24uc2VsZWN0ZWRNYXA7XG4gICAgaWYgKHNlbGVjdGVkTWFwKSB7XG4gICAgICBzZWxlY3RlZE1hcFtuYW1lXSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgR2VvTW9kZWwucHJvdG90eXBlLnRvZ2dsZVNlbGVjdGVkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aGlzW3RoaXMuaXNTZWxlY3RlZChuYW1lKSA/ICd1blNlbGVjdCcgOiAnc2VsZWN0J10obmFtZSk7XG4gIH07XG4gIEdlb01vZGVsLnByb3RvdHlwZS5pc1NlbGVjdGVkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc2VsZWN0ZWRNYXAgPSB0aGlzLm9wdGlvbi5zZWxlY3RlZE1hcDtcbiAgICByZXR1cm4gISEoc2VsZWN0ZWRNYXAgJiYgc2VsZWN0ZWRNYXBbbmFtZV0pO1xuICB9O1xuICBHZW9Nb2RlbC50eXBlID0gJ2dlbyc7XG4gIEdlb01vZGVsLmxheW91dE1vZGUgPSAnYm94JztcbiAgR2VvTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAvLyB6bGV2ZWw6IDAsXG4gICAgejogMCxcbiAgICBzaG93OiB0cnVlLFxuICAgIGxlZnQ6ICdjZW50ZXInLFxuICAgIHRvcDogJ2NlbnRlcicsXG4gICAgLy8gRGVmYXVsdCB2YWx1ZTpcbiAgICAvLyBmb3IgZ2VvU1ZHIHNvdXJjZTogMSxcbiAgICAvLyBmb3IgZ2VvSlNPTiBzb3VyY2U6IDAuNzUuXG4gICAgYXNwZWN0U2NhbGU6IG51bGwsXG4gICAgLy8gLy8vIExheW91dCB3aXRoIGNlbnRlciBhbmQgc2l6ZVxuICAgIC8vIElmIHlvdSB3YW50IHRvIHB1dCBtYXAgaW4gYSBmaXhlZCBzaXplIGJveCB3aXRoIHJpZ2h0IGFzcGVjdCByYXRpb1xuICAgIC8vIFRoaXMgdHdvIHByb3BlcnRpZXMgbWF5IGJlIG1vcmUgY29udmVuaWVudFxuICAgIC8vIGxheW91dENlbnRlcjogWzUwJSwgNTAlXVxuICAgIC8vIGxheW91dFNpemU6IDEwMFxuICAgIHNpbGVudDogZmFsc2UsXG4gICAgLy8gTWFwIHR5cGVcbiAgICBtYXA6ICcnLFxuICAgIC8vIERlZmluZSBsZWZ0LXRvcCwgcmlnaHQtYm90dG9tIGNvb3JkcyB0byBjb250cm9sIHZpZXdcbiAgICAvLyBGb3IgZXhhbXBsZSwgWyBbMTgwLCA5MF0sIFstMTgwLCAtOTBdIF1cbiAgICBib3VuZGluZ0Nvb3JkczogbnVsbCxcbiAgICAvLyBEZWZhdWx0IG9uIGNlbnRlciBvZiBtYXBcbiAgICBjZW50ZXI6IG51bGwsXG4gICAgem9vbTogMSxcbiAgICBzY2FsZUxpbWl0OiBudWxsLFxuICAgIC8vIHNlbGVjdGVkTW9kZTogZmFsc2VcbiAgICBsYWJlbDoge1xuICAgICAgc2hvdzogZmFsc2UsXG4gICAgICBjb2xvcjogJyMwMDAnXG4gICAgfSxcbiAgICBpdGVtU3R5bGU6IHtcbiAgICAgIGJvcmRlcldpZHRoOiAwLjUsXG4gICAgICBib3JkZXJDb2xvcjogJyM0NDQnXG4gICAgICAvLyBEZWZhdWx0IGNvbG9yOlxuICAgICAgLy8gKyBnZW9KU09OOiAjZWVlXG4gICAgICAvLyArIGdlb1NWRzogbnVsbCAodXNlIFNWRyBvcmlnaW5hbCBgZmlsbGApXG4gICAgICAvLyBjb2xvcjogJyNlZWUnXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgY29sb3I6ICdyZ2IoMTAwLDAsMCknXG4gICAgICB9LFxuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAncmdiYSgyNTUsMjE1LDAsMC44KSdcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdDoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgY29sb3I6ICdyZ2IoMTAwLDAsMCknXG4gICAgICB9LFxuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAncmdiYSgyNTUsMjE1LDAsMC44KSdcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlZ2lvbnM6IFtdXG4gICAgLy8gdG9vbHRpcDoge1xuICAgIC8vICAgICBzaG93OiBmYWxzZVxuICAgIC8vIH1cbiAgfTtcbiAgcmV0dXJuIEdlb01vZGVsO1xufShDb21wb25lbnRNb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBHZW9Nb2RlbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///93074\n")},96413:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   vI: () => (/* binding */ RadiusAxisModel),\n/* harmony export */   w2: () => (/* binding */ AngleAxisModel)\n/* harmony export */ });\n/* unused harmony export PolarAxisModel */\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98026);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15915);\n/* harmony import */ var _axisModelCommonMixin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12462);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar PolarAxisModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(PolarAxisModel, _super);\n  function PolarAxisModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  PolarAxisModel.prototype.getCoordSysModel = function () {\n    return this.getReferringComponents(\'polar\', _util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .SINGLE_REFERRING */ .US).models[0];\n  };\n  PolarAxisModel.type = \'polarAxis\';\n  return PolarAxisModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A);\nzrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.mixin(PolarAxisModel, _axisModelCommonMixin_js__WEBPACK_IMPORTED_MODULE_4__/* .AxisModelCommonMixin */ .L);\n\nvar AngleAxisModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(AngleAxisModel, _super);\n  function AngleAxisModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = AngleAxisModel.type;\n    return _this;\n  }\n  AngleAxisModel.type = \'angleAxis\';\n  return AngleAxisModel;\n}(PolarAxisModel);\n\nvar RadiusAxisModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(RadiusAxisModel, _super);\n  function RadiusAxisModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = RadiusAxisModel.type;\n    return _this;\n  }\n  RadiusAxisModel.type = \'radiusAxis\';\n  return RadiusAxisModel;\n}(PolarAxisModel);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY0MTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL3BvbGFyL0F4aXNNb2RlbC5qcz8zN2I1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBDb21wb25lbnRNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Db21wb25lbnQuanMnO1xuaW1wb3J0IHsgQXhpc01vZGVsQ29tbW9uTWl4aW4gfSBmcm9tICcuLi9heGlzTW9kZWxDb21tb25NaXhpbi5qcyc7XG5pbXBvcnQgeyBTSU5HTEVfUkVGRVJSSU5HIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG52YXIgUG9sYXJBeGlzTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUG9sYXJBeGlzTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFBvbGFyQXhpc01vZGVsKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICBQb2xhckF4aXNNb2RlbC5wcm90b3R5cGUuZ2V0Q29vcmRTeXNNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZWZlcnJpbmdDb21wb25lbnRzKCdwb2xhcicsIFNJTkdMRV9SRUZFUlJJTkcpLm1vZGVsc1swXTtcbiAgfTtcbiAgUG9sYXJBeGlzTW9kZWwudHlwZSA9ICdwb2xhckF4aXMnO1xuICByZXR1cm4gUG9sYXJBeGlzTW9kZWw7XG59KENvbXBvbmVudE1vZGVsKTtcbnpyVXRpbC5taXhpbihQb2xhckF4aXNNb2RlbCwgQXhpc01vZGVsQ29tbW9uTWl4aW4pO1xuZXhwb3J0IHsgUG9sYXJBeGlzTW9kZWwgfTtcbnZhciBBbmdsZUF4aXNNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhBbmdsZUF4aXNNb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gQW5nbGVBeGlzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IEFuZ2xlQXhpc01vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEFuZ2xlQXhpc01vZGVsLnR5cGUgPSAnYW5nbGVBeGlzJztcbiAgcmV0dXJuIEFuZ2xlQXhpc01vZGVsO1xufShQb2xhckF4aXNNb2RlbCk7XG5leHBvcnQgeyBBbmdsZUF4aXNNb2RlbCB9O1xudmFyIFJhZGl1c0F4aXNNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhSYWRpdXNBeGlzTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFJhZGl1c0F4aXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gUmFkaXVzQXhpc01vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFJhZGl1c0F4aXNNb2RlbC50eXBlID0gJ3JhZGl1c0F4aXMnO1xuICByZXR1cm4gUmFkaXVzQXhpc01vZGVsO1xufShQb2xhckF4aXNNb2RlbCk7XG5leHBvcnQgeyBSYWRpdXNBeGlzTW9kZWwgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///96413\n')},96504:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ radar_Radar)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/Axis.js\nvar Axis = __webpack_require__(1727);\n;// ./node_modules/echarts/lib/coord/radar/IndicatorAxis.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar IndicatorAxis = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(IndicatorAxis, _super);\n  function IndicatorAxis(dim, scale, radiusExtent) {\n    var _this = _super.call(this, dim, scale, radiusExtent) || this;\n    _this.type = 'value';\n    _this.angle = 0;\n    _this.name = '';\n    return _this;\n  }\n  return IndicatorAxis;\n}(Axis/* default */.A);\n/* harmony default export */ const radar_IndicatorAxis = (IndicatorAxis);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/scale/Interval.js\nvar Interval = __webpack_require__(74562);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/axisAlignTicks.js\nvar axisAlignTicks = __webpack_require__(3486);\n;// ./node_modules/echarts/lib/coord/radar/Radar.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// TODO clockwise\n\n\n\n\n\nvar Radar = /** @class */function () {\n  function Radar(radarModel, ecModel, api) {\n    /**\r\n     *\r\n     * Radar dimensions\r\n     */\n    this.dimensions = [];\n    this._model = radarModel;\n    this._indicatorAxes = (0,util.map)(radarModel.getIndicatorModels(), function (indicatorModel, idx) {\n      var dim = 'indicator_' + idx;\n      var indicatorAxis = new radar_IndicatorAxis(dim, new Interval/* default */.A()\n      // (indicatorModel.get('axisType') === 'log') ? new LogScale() : new IntervalScale()\n      );\n      indicatorAxis.name = indicatorModel.get('name');\n      // Inject model and axis\n      indicatorAxis.model = indicatorModel;\n      indicatorModel.axis = indicatorAxis;\n      this.dimensions.push(dim);\n      return indicatorAxis;\n    }, this);\n    this.resize(radarModel, api);\n  }\n  Radar.prototype.getIndicatorAxes = function () {\n    return this._indicatorAxes;\n  };\n  Radar.prototype.dataToPoint = function (value, indicatorIndex) {\n    var indicatorAxis = this._indicatorAxes[indicatorIndex];\n    return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);\n  };\n  // TODO: API should be coordToPoint([coord, indicatorIndex])\n  Radar.prototype.coordToPoint = function (coord, indicatorIndex) {\n    var indicatorAxis = this._indicatorAxes[indicatorIndex];\n    var angle = indicatorAxis.angle;\n    var x = this.cx + coord * Math.cos(angle);\n    var y = this.cy - coord * Math.sin(angle);\n    return [x, y];\n  };\n  Radar.prototype.pointToData = function (pt) {\n    var dx = pt[0] - this.cx;\n    var dy = pt[1] - this.cy;\n    var radius = Math.sqrt(dx * dx + dy * dy);\n    dx /= radius;\n    dy /= radius;\n    var radian = Math.atan2(-dy, dx);\n    // Find the closest angle\n    // FIXME index can calculated directly\n    var minRadianDiff = Infinity;\n    var closestAxis;\n    var closestAxisIdx = -1;\n    for (var i = 0; i < this._indicatorAxes.length; i++) {\n      var indicatorAxis = this._indicatorAxes[i];\n      var diff = Math.abs(radian - indicatorAxis.angle);\n      if (diff < minRadianDiff) {\n        closestAxis = indicatorAxis;\n        closestAxisIdx = i;\n        minRadianDiff = diff;\n      }\n    }\n    return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];\n  };\n  Radar.prototype.resize = function (radarModel, api) {\n    var center = radarModel.get('center');\n    var viewWidth = api.getWidth();\n    var viewHeight = api.getHeight();\n    var viewSize = Math.min(viewWidth, viewHeight) / 2;\n    this.cx = number/* parsePercent */.lo(center[0], viewWidth);\n    this.cy = number/* parsePercent */.lo(center[1], viewHeight);\n    this.startAngle = radarModel.get('startAngle') * Math.PI / 180;\n    // radius may be single value like `20`, `'80%'`, or array like `[10, '80%']`\n    var radius = radarModel.get('radius');\n    if ((0,util.isString)(radius) || (0,util.isNumber)(radius)) {\n      radius = [0, radius];\n    }\n    this.r0 = number/* parsePercent */.lo(radius[0], viewSize);\n    this.r = number/* parsePercent */.lo(radius[1], viewSize);\n    (0,util.each)(this._indicatorAxes, function (indicatorAxis, idx) {\n      indicatorAxis.setExtent(this.r0, this.r);\n      var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;\n      // Normalize to [-PI, PI]\n      angle = Math.atan2(Math.sin(angle), Math.cos(angle));\n      indicatorAxis.angle = angle;\n    }, this);\n  };\n  Radar.prototype.update = function (ecModel, api) {\n    var indicatorAxes = this._indicatorAxes;\n    var radarModel = this._model;\n    (0,util.each)(indicatorAxes, function (indicatorAxis) {\n      indicatorAxis.scale.setExtent(Infinity, -Infinity);\n    });\n    ecModel.eachSeriesByType('radar', function (radarSeries, idx) {\n      if (radarSeries.get('coordinateSystem') !== 'radar'\n      // @ts-ignore\n      || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel) {\n        return;\n      }\n      var data = radarSeries.getData();\n      (0,util.each)(indicatorAxes, function (indicatorAxis) {\n        indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));\n      });\n    }, this);\n    var splitNumber = radarModel.get('splitNumber');\n    var dummyScale = new Interval/* default */.A();\n    dummyScale.setExtent(0, splitNumber);\n    dummyScale.setInterval(1);\n    // Force all the axis fixing the maxSplitNumber.\n    (0,util.each)(indicatorAxes, function (indicatorAxis, idx) {\n      (0,axisAlignTicks/* alignScaleTicks */.m)(indicatorAxis.scale, indicatorAxis.model, dummyScale);\n    });\n  };\n  Radar.prototype.convertToPixel = function (ecModel, finder, value) {\n    console.warn('Not implemented.');\n    return null;\n  };\n  Radar.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n    console.warn('Not implemented.');\n    return null;\n  };\n  Radar.prototype.containPoint = function (point) {\n    console.warn('Not implemented.');\n    return false;\n  };\n  Radar.create = function (ecModel, api) {\n    var radarList = [];\n    ecModel.eachComponent('radar', function (radarModel) {\n      var radar = new Radar(radarModel, ecModel, api);\n      radarList.push(radar);\n      radarModel.coordinateSystem = radar;\n    });\n    ecModel.eachSeriesByType('radar', function (radarSeries) {\n      if (radarSeries.get('coordinateSystem') === 'radar') {\n        // Inject coordinate system\n        // @ts-ignore\n        radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];\n      }\n    });\n    return radarList;\n  };\n  /**\r\n   * Radar dimensions is based on the data\r\n   */\n  Radar.dimensions = [];\n  return Radar;\n}();\n/* harmony default export */ const radar_Radar = (Radar);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY1MDQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvcmFkYXIvSW5kaWNhdG9yQXhpcy5qcz85ODQ3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9yYWRhci9SYWRhci5qcz9mMTkxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQXhpcyBmcm9tICcuLi9BeGlzLmpzJztcbnZhciBJbmRpY2F0b3JBeGlzID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEluZGljYXRvckF4aXMsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEluZGljYXRvckF4aXMoZGltLCBzY2FsZSwgcmFkaXVzRXh0ZW50KSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGltLCBzY2FsZSwgcmFkaXVzRXh0ZW50KSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSAndmFsdWUnO1xuICAgIF90aGlzLmFuZ2xlID0gMDtcbiAgICBfdGhpcy5uYW1lID0gJyc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHJldHVybiBJbmRpY2F0b3JBeGlzO1xufShBeGlzKTtcbmV4cG9ydCBkZWZhdWx0IEluZGljYXRvckF4aXM7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG4vLyBUT0RPIGNsb2Nrd2lzZVxuaW1wb3J0IEluZGljYXRvckF4aXMgZnJvbSAnLi9JbmRpY2F0b3JBeGlzLmpzJztcbmltcG9ydCBJbnRlcnZhbFNjYWxlIGZyb20gJy4uLy4uL3NjYWxlL0ludGVydmFsLmpzJztcbmltcG9ydCAqIGFzIG51bWJlclV0aWwgZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IHsgbWFwLCBlYWNoLCBpc1N0cmluZywgaXNOdW1iZXIgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgYWxpZ25TY2FsZVRpY2tzIH0gZnJvbSAnLi4vYXhpc0FsaWduVGlja3MuanMnO1xudmFyIFJhZGFyID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmFkYXIocmFkYXJNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogUmFkYXIgZGltZW5zaW9uc1xyXG4gICAgICovXG4gICAgdGhpcy5kaW1lbnNpb25zID0gW107XG4gICAgdGhpcy5fbW9kZWwgPSByYWRhck1vZGVsO1xuICAgIHRoaXMuX2luZGljYXRvckF4ZXMgPSBtYXAocmFkYXJNb2RlbC5nZXRJbmRpY2F0b3JNb2RlbHMoKSwgZnVuY3Rpb24gKGluZGljYXRvck1vZGVsLCBpZHgpIHtcbiAgICAgIHZhciBkaW0gPSAnaW5kaWNhdG9yXycgKyBpZHg7XG4gICAgICB2YXIgaW5kaWNhdG9yQXhpcyA9IG5ldyBJbmRpY2F0b3JBeGlzKGRpbSwgbmV3IEludGVydmFsU2NhbGUoKVxuICAgICAgLy8gKGluZGljYXRvck1vZGVsLmdldCgnYXhpc1R5cGUnKSA9PT0gJ2xvZycpID8gbmV3IExvZ1NjYWxlKCkgOiBuZXcgSW50ZXJ2YWxTY2FsZSgpXG4gICAgICApO1xuICAgICAgaW5kaWNhdG9yQXhpcy5uYW1lID0gaW5kaWNhdG9yTW9kZWwuZ2V0KCduYW1lJyk7XG4gICAgICAvLyBJbmplY3QgbW9kZWwgYW5kIGF4aXNcbiAgICAgIGluZGljYXRvckF4aXMubW9kZWwgPSBpbmRpY2F0b3JNb2RlbDtcbiAgICAgIGluZGljYXRvck1vZGVsLmF4aXMgPSBpbmRpY2F0b3JBeGlzO1xuICAgICAgdGhpcy5kaW1lbnNpb25zLnB1c2goZGltKTtcbiAgICAgIHJldHVybiBpbmRpY2F0b3JBeGlzO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMucmVzaXplKHJhZGFyTW9kZWwsIGFwaSk7XG4gIH1cbiAgUmFkYXIucHJvdG90eXBlLmdldEluZGljYXRvckF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGljYXRvckF4ZXM7XG4gIH07XG4gIFJhZGFyLnByb3RvdHlwZS5kYXRhVG9Qb2ludCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kaWNhdG9ySW5kZXgpIHtcbiAgICB2YXIgaW5kaWNhdG9yQXhpcyA9IHRoaXMuX2luZGljYXRvckF4ZXNbaW5kaWNhdG9ySW5kZXhdO1xuICAgIHJldHVybiB0aGlzLmNvb3JkVG9Qb2ludChpbmRpY2F0b3JBeGlzLmRhdGFUb0Nvb3JkKHZhbHVlKSwgaW5kaWNhdG9ySW5kZXgpO1xuICB9O1xuICAvLyBUT0RPOiBBUEkgc2hvdWxkIGJlIGNvb3JkVG9Qb2ludChbY29vcmQsIGluZGljYXRvckluZGV4XSlcbiAgUmFkYXIucHJvdG90eXBlLmNvb3JkVG9Qb2ludCA9IGZ1bmN0aW9uIChjb29yZCwgaW5kaWNhdG9ySW5kZXgpIHtcbiAgICB2YXIgaW5kaWNhdG9yQXhpcyA9IHRoaXMuX2luZGljYXRvckF4ZXNbaW5kaWNhdG9ySW5kZXhdO1xuICAgIHZhciBhbmdsZSA9IGluZGljYXRvckF4aXMuYW5nbGU7XG4gICAgdmFyIHggPSB0aGlzLmN4ICsgY29vcmQgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgdmFyIHkgPSB0aGlzLmN5IC0gY29vcmQgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfTtcbiAgUmFkYXIucHJvdG90eXBlLnBvaW50VG9EYXRhID0gZnVuY3Rpb24gKHB0KSB7XG4gICAgdmFyIGR4ID0gcHRbMF0gLSB0aGlzLmN4O1xuICAgIHZhciBkeSA9IHB0WzFdIC0gdGhpcy5jeTtcbiAgICB2YXIgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICBkeCAvPSByYWRpdXM7XG4gICAgZHkgLz0gcmFkaXVzO1xuICAgIHZhciByYWRpYW4gPSBNYXRoLmF0YW4yKC1keSwgZHgpO1xuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgYW5nbGVcbiAgICAvLyBGSVhNRSBpbmRleCBjYW4gY2FsY3VsYXRlZCBkaXJlY3RseVxuICAgIHZhciBtaW5SYWRpYW5EaWZmID0gSW5maW5pdHk7XG4gICAgdmFyIGNsb3Nlc3RBeGlzO1xuICAgIHZhciBjbG9zZXN0QXhpc0lkeCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW5kaWNhdG9yQXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluZGljYXRvckF4aXMgPSB0aGlzLl9pbmRpY2F0b3JBeGVzW2ldO1xuICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhyYWRpYW4gLSBpbmRpY2F0b3JBeGlzLmFuZ2xlKTtcbiAgICAgIGlmIChkaWZmIDwgbWluUmFkaWFuRGlmZikge1xuICAgICAgICBjbG9zZXN0QXhpcyA9IGluZGljYXRvckF4aXM7XG4gICAgICAgIGNsb3Nlc3RBeGlzSWR4ID0gaTtcbiAgICAgICAgbWluUmFkaWFuRGlmZiA9IGRpZmY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbY2xvc2VzdEF4aXNJZHgsICsoY2xvc2VzdEF4aXMgJiYgY2xvc2VzdEF4aXMuY29vcmRUb0RhdGEocmFkaXVzKSldO1xuICB9O1xuICBSYWRhci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHJhZGFyTW9kZWwsIGFwaSkge1xuICAgIHZhciBjZW50ZXIgPSByYWRhck1vZGVsLmdldCgnY2VudGVyJyk7XG4gICAgdmFyIHZpZXdXaWR0aCA9IGFwaS5nZXRXaWR0aCgpO1xuICAgIHZhciB2aWV3SGVpZ2h0ID0gYXBpLmdldEhlaWdodCgpO1xuICAgIHZhciB2aWV3U2l6ZSA9IE1hdGgubWluKHZpZXdXaWR0aCwgdmlld0hlaWdodCkgLyAyO1xuICAgIHRoaXMuY3ggPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChjZW50ZXJbMF0sIHZpZXdXaWR0aCk7XG4gICAgdGhpcy5jeSA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGNlbnRlclsxXSwgdmlld0hlaWdodCk7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gcmFkYXJNb2RlbC5nZXQoJ3N0YXJ0QW5nbGUnKSAqIE1hdGguUEkgLyAxODA7XG4gICAgLy8gcmFkaXVzIG1heSBiZSBzaW5nbGUgdmFsdWUgbGlrZSBgMjBgLCBgJzgwJSdgLCBvciBhcnJheSBsaWtlIGBbMTAsICc4MCUnXWBcbiAgICB2YXIgcmFkaXVzID0gcmFkYXJNb2RlbC5nZXQoJ3JhZGl1cycpO1xuICAgIGlmIChpc1N0cmluZyhyYWRpdXMpIHx8IGlzTnVtYmVyKHJhZGl1cykpIHtcbiAgICAgIHJhZGl1cyA9IFswLCByYWRpdXNdO1xuICAgIH1cbiAgICB0aGlzLnIwID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQocmFkaXVzWzBdLCB2aWV3U2l6ZSk7XG4gICAgdGhpcy5yID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQocmFkaXVzWzFdLCB2aWV3U2l6ZSk7XG4gICAgZWFjaCh0aGlzLl9pbmRpY2F0b3JBeGVzLCBmdW5jdGlvbiAoaW5kaWNhdG9yQXhpcywgaWR4KSB7XG4gICAgICBpbmRpY2F0b3JBeGlzLnNldEV4dGVudCh0aGlzLnIwLCB0aGlzLnIpO1xuICAgICAgdmFyIGFuZ2xlID0gdGhpcy5zdGFydEFuZ2xlICsgaWR4ICogTWF0aC5QSSAqIDIgLyB0aGlzLl9pbmRpY2F0b3JBeGVzLmxlbmd0aDtcbiAgICAgIC8vIE5vcm1hbGl6ZSB0byBbLVBJLCBQSV1cbiAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihNYXRoLnNpbihhbmdsZSksIE1hdGguY29zKGFuZ2xlKSk7XG4gICAgICBpbmRpY2F0b3JBeGlzLmFuZ2xlID0gYW5nbGU7XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIFJhZGFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGluZGljYXRvckF4ZXMgPSB0aGlzLl9pbmRpY2F0b3JBeGVzO1xuICAgIHZhciByYWRhck1vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgZWFjaChpbmRpY2F0b3JBeGVzLCBmdW5jdGlvbiAoaW5kaWNhdG9yQXhpcykge1xuICAgICAgaW5kaWNhdG9yQXhpcy5zY2FsZS5zZXRFeHRlbnQoSW5maW5pdHksIC1JbmZpbml0eSk7XG4gICAgfSk7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdyYWRhcicsIGZ1bmN0aW9uIChyYWRhclNlcmllcywgaWR4KSB7XG4gICAgICBpZiAocmFkYXJTZXJpZXMuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykgIT09ICdyYWRhcidcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHx8IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdyYWRhcicsIHJhZGFyU2VyaWVzLmdldCgncmFkYXJJbmRleCcpKSAhPT0gcmFkYXJNb2RlbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IHJhZGFyU2VyaWVzLmdldERhdGEoKTtcbiAgICAgIGVhY2goaW5kaWNhdG9yQXhlcywgZnVuY3Rpb24gKGluZGljYXRvckF4aXMpIHtcbiAgICAgICAgaW5kaWNhdG9yQXhpcy5zY2FsZS51bmlvbkV4dGVudEZyb21EYXRhKGRhdGEsIGRhdGEubWFwRGltZW5zaW9uKGluZGljYXRvckF4aXMuZGltKSk7XG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcbiAgICB2YXIgc3BsaXROdW1iZXIgPSByYWRhck1vZGVsLmdldCgnc3BsaXROdW1iZXInKTtcbiAgICB2YXIgZHVtbXlTY2FsZSA9IG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gICAgZHVtbXlTY2FsZS5zZXRFeHRlbnQoMCwgc3BsaXROdW1iZXIpO1xuICAgIGR1bW15U2NhbGUuc2V0SW50ZXJ2YWwoMSk7XG4gICAgLy8gRm9yY2UgYWxsIHRoZSBheGlzIGZpeGluZyB0aGUgbWF4U3BsaXROdW1iZXIuXG4gICAgZWFjaChpbmRpY2F0b3JBeGVzLCBmdW5jdGlvbiAoaW5kaWNhdG9yQXhpcywgaWR4KSB7XG4gICAgICBhbGlnblNjYWxlVGlja3MoaW5kaWNhdG9yQXhpcy5zY2FsZSwgaW5kaWNhdG9yQXhpcy5tb2RlbCwgZHVtbXlTY2FsZSk7XG4gICAgfSk7XG4gIH07XG4gIFJhZGFyLnByb3RvdHlwZS5jb252ZXJ0VG9QaXhlbCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIsIHZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKCdOb3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIFJhZGFyLnByb3RvdHlwZS5jb252ZXJ0RnJvbVBpeGVsID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlciwgcGl4ZWwpIHtcbiAgICBjb25zb2xlLndhcm4oJ05vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgUmFkYXIucHJvdG90eXBlLmNvbnRhaW5Qb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIGNvbnNvbGUud2FybignTm90IGltcGxlbWVudGVkLicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgUmFkYXIuY3JlYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciByYWRhckxpc3QgPSBbXTtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ3JhZGFyJywgZnVuY3Rpb24gKHJhZGFyTW9kZWwpIHtcbiAgICAgIHZhciByYWRhciA9IG5ldyBSYWRhcihyYWRhck1vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgcmFkYXJMaXN0LnB1c2gocmFkYXIpO1xuICAgICAgcmFkYXJNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gcmFkYXI7XG4gICAgfSk7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdyYWRhcicsIGZ1bmN0aW9uIChyYWRhclNlcmllcykge1xuICAgICAgaWYgKHJhZGFyU2VyaWVzLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpID09PSAncmFkYXInKSB7XG4gICAgICAgIC8vIEluamVjdCBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJhZGFyU2VyaWVzLmNvb3JkaW5hdGVTeXN0ZW0gPSByYWRhckxpc3RbcmFkYXJTZXJpZXMuZ2V0KCdyYWRhckluZGV4JykgfHwgMF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJhZGFyTGlzdDtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmFkYXIgZGltZW5zaW9ucyBpcyBiYXNlZCBvbiB0aGUgZGF0YVxyXG4gICAqL1xuICBSYWRhci5kaW1lbnNpb25zID0gW107XG4gIHJldHVybiBSYWRhcjtcbn0oKTtcbmV4cG9ydCBkZWZhdWx0IFJhZGFyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///96504\n")},96878:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LR: () => (/* binding */ findAxisModels),\n/* harmony export */   Zp: () => (/* binding */ layout),\n/* harmony export */   gO: () => (/* binding */ isCartesian2DSeries)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n/**\r\n * Can only be called after coordinate system creation stage.\r\n * (Can be called before coordinate system update stage).\r\n */\nfunction layout(gridModel, axisModel, opt) {\n  opt = opt || {};\n  var grid = gridModel.coordinateSystem;\n  var axis = axisModel.axis;\n  var layout = {};\n  var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];\n  var rawAxisPosition = axis.position;\n  var axisPosition = otherAxisOnZeroOf ? 'onZero' : rawAxisPosition;\n  var axisDim = axis.dim;\n  var rect = grid.getRect();\n  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n  var idx = {\n    left: 0,\n    right: 1,\n    top: 0,\n    bottom: 1,\n    onZero: 2\n  };\n  var axisOffset = axisModel.get('offset') || 0;\n  var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];\n  if (otherAxisOnZeroOf) {\n    var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));\n    posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);\n  }\n  // Axis position\n  layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]];\n  // Axis rotation\n  layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n  // Tick and label direction, x y is axisDim\n  var dirMap = {\n    top: -1,\n    bottom: 1,\n    left: -1,\n    right: 1\n  };\n  layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n  layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;\n  if (axisModel.get(['axisTick', 'inside'])) {\n    layout.tickDirection = -layout.tickDirection;\n  }\n  if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.retrieve(opt.labelInside, axisModel.get(['axisLabel', 'inside']))) {\n    layout.labelDirection = -layout.labelDirection;\n  }\n  // Special label rotation\n  var labelRotate = axisModel.get(['axisLabel', 'rotate']);\n  layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate;\n  // Over splitLine and splitArea\n  layout.z2 = 1;\n  return layout;\n}\nfunction isCartesian2DSeries(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\nfunction findAxisModels(seriesModel) {\n  var axisModelMap = {\n    xAxisModel: null,\n    yAxisModel: null\n  };\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(axisModelMap, function (v, key) {\n    var axisType = key.replace(/Model$/, '');\n    var axisModel = seriesModel.getReferringComponents(axisType, _util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .SINGLE_REFERRING */ .US).models[0];\n    if (false) {}\n    axisModelMap[key] = axisModel;\n  });\n  return axisModelMap;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY4NzguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9jYXJ0ZXNpYW5BeGlzSGVscGVyLmpzPzE2NTYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IFNJTkdMRV9SRUZFUlJJTkcgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbi8qKlxyXG4gKiBDYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgY29vcmRpbmF0ZSBzeXN0ZW0gY3JlYXRpb24gc3RhZ2UuXHJcbiAqIChDYW4gYmUgY2FsbGVkIGJlZm9yZSBjb29yZGluYXRlIHN5c3RlbSB1cGRhdGUgc3RhZ2UpLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXlvdXQoZ3JpZE1vZGVsLCBheGlzTW9kZWwsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIHZhciBncmlkID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gIHZhciBsYXlvdXQgPSB7fTtcbiAgdmFyIG90aGVyQXhpc09uWmVyb09mID0gYXhpcy5nZXRBeGVzT25aZXJvT2YoKVswXTtcbiAgdmFyIHJhd0F4aXNQb3NpdGlvbiA9IGF4aXMucG9zaXRpb247XG4gIHZhciBheGlzUG9zaXRpb24gPSBvdGhlckF4aXNPblplcm9PZiA/ICdvblplcm8nIDogcmF3QXhpc1Bvc2l0aW9uO1xuICB2YXIgYXhpc0RpbSA9IGF4aXMuZGltO1xuICB2YXIgcmVjdCA9IGdyaWQuZ2V0UmVjdCgpO1xuICB2YXIgcmVjdEJvdW5kID0gW3JlY3QueCwgcmVjdC54ICsgcmVjdC53aWR0aCwgcmVjdC55LCByZWN0LnkgKyByZWN0LmhlaWdodF07XG4gIHZhciBpZHggPSB7XG4gICAgbGVmdDogMCxcbiAgICByaWdodDogMSxcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiAxLFxuICAgIG9uWmVybzogMlxuICB9O1xuICB2YXIgYXhpc09mZnNldCA9IGF4aXNNb2RlbC5nZXQoJ29mZnNldCcpIHx8IDA7XG4gIHZhciBwb3NCb3VuZCA9IGF4aXNEaW0gPT09ICd4JyA/IFtyZWN0Qm91bmRbMl0gLSBheGlzT2Zmc2V0LCByZWN0Qm91bmRbM10gKyBheGlzT2Zmc2V0XSA6IFtyZWN0Qm91bmRbMF0gLSBheGlzT2Zmc2V0LCByZWN0Qm91bmRbMV0gKyBheGlzT2Zmc2V0XTtcbiAgaWYgKG90aGVyQXhpc09uWmVyb09mKSB7XG4gICAgdmFyIG9uWmVyb0Nvb3JkID0gb3RoZXJBeGlzT25aZXJvT2YudG9HbG9iYWxDb29yZChvdGhlckF4aXNPblplcm9PZi5kYXRhVG9Db29yZCgwKSk7XG4gICAgcG9zQm91bmRbaWR4Lm9uWmVyb10gPSBNYXRoLm1heChNYXRoLm1pbihvblplcm9Db29yZCwgcG9zQm91bmRbMV0pLCBwb3NCb3VuZFswXSk7XG4gIH1cbiAgLy8gQXhpcyBwb3NpdGlvblxuICBsYXlvdXQucG9zaXRpb24gPSBbYXhpc0RpbSA9PT0gJ3knID8gcG9zQm91bmRbaWR4W2F4aXNQb3NpdGlvbl1dIDogcmVjdEJvdW5kWzBdLCBheGlzRGltID09PSAneCcgPyBwb3NCb3VuZFtpZHhbYXhpc1Bvc2l0aW9uXV0gOiByZWN0Qm91bmRbM11dO1xuICAvLyBBeGlzIHJvdGF0aW9uXG4gIGxheW91dC5yb3RhdGlvbiA9IE1hdGguUEkgLyAyICogKGF4aXNEaW0gPT09ICd4JyA/IDAgOiAxKTtcbiAgLy8gVGljayBhbmQgbGFiZWwgZGlyZWN0aW9uLCB4IHkgaXMgYXhpc0RpbVxuICB2YXIgZGlyTWFwID0ge1xuICAgIHRvcDogLTEsXG4gICAgYm90dG9tOiAxLFxuICAgIGxlZnQ6IC0xLFxuICAgIHJpZ2h0OiAxXG4gIH07XG4gIGxheW91dC5sYWJlbERpcmVjdGlvbiA9IGxheW91dC50aWNrRGlyZWN0aW9uID0gbGF5b3V0Lm5hbWVEaXJlY3Rpb24gPSBkaXJNYXBbcmF3QXhpc1Bvc2l0aW9uXTtcbiAgbGF5b3V0LmxhYmVsT2Zmc2V0ID0gb3RoZXJBeGlzT25aZXJvT2YgPyBwb3NCb3VuZFtpZHhbcmF3QXhpc1Bvc2l0aW9uXV0gLSBwb3NCb3VuZFtpZHgub25aZXJvXSA6IDA7XG4gIGlmIChheGlzTW9kZWwuZ2V0KFsnYXhpc1RpY2snLCAnaW5zaWRlJ10pKSB7XG4gICAgbGF5b3V0LnRpY2tEaXJlY3Rpb24gPSAtbGF5b3V0LnRpY2tEaXJlY3Rpb247XG4gIH1cbiAgaWYgKHpyVXRpbC5yZXRyaWV2ZShvcHQubGFiZWxJbnNpZGUsIGF4aXNNb2RlbC5nZXQoWydheGlzTGFiZWwnLCAnaW5zaWRlJ10pKSkge1xuICAgIGxheW91dC5sYWJlbERpcmVjdGlvbiA9IC1sYXlvdXQubGFiZWxEaXJlY3Rpb247XG4gIH1cbiAgLy8gU3BlY2lhbCBsYWJlbCByb3RhdGlvblxuICB2YXIgbGFiZWxSb3RhdGUgPSBheGlzTW9kZWwuZ2V0KFsnYXhpc0xhYmVsJywgJ3JvdGF0ZSddKTtcbiAgbGF5b3V0LmxhYmVsUm90YXRlID0gYXhpc1Bvc2l0aW9uID09PSAndG9wJyA/IC1sYWJlbFJvdGF0ZSA6IGxhYmVsUm90YXRlO1xuICAvLyBPdmVyIHNwbGl0TGluZSBhbmQgc3BsaXRBcmVhXG4gIGxheW91dC56MiA9IDE7XG4gIHJldHVybiBsYXlvdXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDYXJ0ZXNpYW4yRFNlcmllcyhzZXJpZXNNb2RlbCkge1xuICByZXR1cm4gc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykgPT09ICdjYXJ0ZXNpYW4yZCc7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZEF4aXNNb2RlbHMoc2VyaWVzTW9kZWwpIHtcbiAgdmFyIGF4aXNNb2RlbE1hcCA9IHtcbiAgICB4QXhpc01vZGVsOiBudWxsLFxuICAgIHlBeGlzTW9kZWw6IG51bGxcbiAgfTtcbiAgenJVdGlsLmVhY2goYXhpc01vZGVsTWFwLCBmdW5jdGlvbiAodiwga2V5KSB7XG4gICAgdmFyIGF4aXNUeXBlID0ga2V5LnJlcGxhY2UoL01vZGVsJC8sICcnKTtcbiAgICB2YXIgYXhpc01vZGVsID0gc2VyaWVzTW9kZWwuZ2V0UmVmZXJyaW5nQ29tcG9uZW50cyhheGlzVHlwZSwgU0lOR0xFX1JFRkVSUklORykubW9kZWxzWzBdO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWF4aXNNb2RlbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXhpc1R5cGUgKyAnIFwiJyArIHpyVXRpbC5yZXRyaWV2ZTMoc2VyaWVzTW9kZWwuZ2V0KGF4aXNUeXBlICsgJ0luZGV4JyksIHNlcmllc01vZGVsLmdldChheGlzVHlwZSArICdJZCcpLCAwKSArICdcIiBub3QgZm91bmQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXhpc01vZGVsTWFwW2tleV0gPSBheGlzTW9kZWw7XG4gIH0pO1xuICByZXR1cm4gYXhpc01vZGVsTWFwO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///96878\n")},98592:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ geo_geoCreator)\n});\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/BoundingRect.js\nvar BoundingRect = __webpack_require__(29308);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/View.js\nvar View = __webpack_require__(56219);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/geo/geoSourceManager.js + 5 modules\nvar geoSourceManager = __webpack_require__(76311);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n;// ./node_modules/echarts/lib/coord/geo/Geo.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar GEO_DEFAULT_PARAMS = {\n  'geoJSON': {\n    aspectScale: 0.75,\n    invertLongitute: true\n  },\n  'geoSVG': {\n    aspectScale: 1,\n    invertLongitute: false\n  }\n};\nvar geo2DDimensions = ['lng', 'lat'];\nvar Geo = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(Geo, _super);\n  function Geo(name, map, opt) {\n    var _this = _super.call(this, name) || this;\n    _this.dimensions = geo2DDimensions;\n    _this.type = 'geo';\n    // Only store specified name coord via `addGeoCoord`.\n    _this._nameCoordMap = util.createHashMap();\n    _this.map = map;\n    var projection = opt.projection;\n    var source = geoSourceManager/* default */.A.load(map, opt.nameMap, opt.nameProperty);\n    var resource = geoSourceManager/* default */.A.getGeoResource(map);\n    var resourceType = _this.resourceType = resource ? resource.type : null;\n    var regions = _this.regions = source.regions;\n    var defaultParams = GEO_DEFAULT_PARAMS[resource.type];\n    _this._regionsMap = source.regionsMap;\n    _this.regions = source.regions;\n    if (false) {}\n    _this.projection = projection;\n    var boundingRect;\n    if (projection) {\n      // Can't reuse the raw bounding rect\n      for (var i = 0; i < regions.length; i++) {\n        var regionRect = regions[i].getBoundingRect(projection);\n        boundingRect = boundingRect || regionRect.clone();\n        boundingRect.union(regionRect);\n      }\n    } else {\n      boundingRect = source.boundingRect;\n    }\n    _this.setBoundingRect(boundingRect.x, boundingRect.y, boundingRect.width, boundingRect.height);\n    // aspectScale and invertLongitute actually is the parameters default raw projection.\n    // So we ignore them if projection is given.\n    // Ignore default aspect scale if projection exits.\n    _this.aspectScale = projection ? 1 : util.retrieve2(opt.aspectScale, defaultParams.aspectScale);\n    // Not invert longitude if projection exits.\n    _this._invertLongitute = projection ? false : defaultParams.invertLongitute;\n    return _this;\n  }\n  Geo.prototype._transformTo = function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var invertLongitute = this._invertLongitute;\n    rect = rect.clone();\n    if (invertLongitute) {\n      // Longitude is inverted.\n      rect.y = -rect.y - rect.height;\n    }\n    var rawTransformable = this._rawTransformable;\n    rawTransformable.transform = rect.calculateTransform(new BoundingRect/* default */.A(x, y, width, height));\n    var rawParent = rawTransformable.parent;\n    rawTransformable.parent = null;\n    rawTransformable.decomposeTransform();\n    rawTransformable.parent = rawParent;\n    if (invertLongitute) {\n      rawTransformable.scaleY = -rawTransformable.scaleY;\n    }\n    this._updateTransform();\n  };\n  Geo.prototype.getRegion = function (name) {\n    return this._regionsMap.get(name);\n  };\n  Geo.prototype.getRegionByCoord = function (coord) {\n    var regions = this.regions;\n    for (var i = 0; i < regions.length; i++) {\n      var region = regions[i];\n      if (region.type === 'geoJSON' && region.contain(coord)) {\n        return regions[i];\n      }\n    }\n  };\n  /**\r\n   * Add geoCoord for indexing by name\r\n   */\n  Geo.prototype.addGeoCoord = function (name, geoCoord) {\n    this._nameCoordMap.set(name, geoCoord);\n  };\n  /**\r\n   * Get geoCoord by name\r\n   */\n  Geo.prototype.getGeoCoord = function (name) {\n    var region = this._regionsMap.get(name);\n    // Calculate center only on demand.\n    return this._nameCoordMap.get(name) || region && region.getCenter();\n  };\n  Geo.prototype.dataToPoint = function (data, noRoam, out) {\n    if (util.isString(data)) {\n      // Map area name to geoCoord\n      data = this.getGeoCoord(data);\n    }\n    if (data) {\n      var projection = this.projection;\n      if (projection) {\n        // projection may return null point.\n        data = projection.project(data);\n      }\n      return data && this.projectedToPoint(data, noRoam, out);\n    }\n  };\n  Geo.prototype.pointToData = function (point) {\n    var projection = this.projection;\n    if (projection) {\n      // projection may return null point.\n      point = projection.unproject(point);\n    }\n    return point && this.pointToProjected(point);\n  };\n  /**\r\n   * Point to projected data. Same with pointToData when projection is used.\r\n   */\n  Geo.prototype.pointToProjected = function (point) {\n    return _super.prototype.pointToData.call(this, point);\n  };\n  Geo.prototype.projectedToPoint = function (projected, noRoam, out) {\n    return _super.prototype.dataToPoint.call(this, projected, noRoam, out);\n  };\n  Geo.prototype.convertToPixel = function (ecModel, finder, value) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.dataToPoint(value) : null;\n  };\n  Geo.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.pointToData(pixel) : null;\n  };\n  return Geo;\n}(View/* default */.A);\n;\nutil.mixin(Geo, View/* default */.A);\nfunction getCoordSys(finder) {\n  var geoModel = finder.geoModel;\n  var seriesModel = finder.seriesModel;\n  return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem // For map series.\n  || (seriesModel.getReferringComponents('geo', model/* SINGLE_REFERRING */.US).models[0] || {}).coordinateSystem : null;\n}\n/* harmony default export */ const geo_Geo = (Geo);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/vector.js\nvar vector = __webpack_require__(83509);\n;// ./node_modules/echarts/lib/coord/geo/geoCreator.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n/**\r\n * Resize method bound to the geo\r\n */\nfunction resizeGeo(geoModel, api) {\n  var boundingCoords = geoModel.get('boundingCoords');\n  if (boundingCoords != null) {\n    var leftTop_1 = boundingCoords[0];\n    var rightBottom_1 = boundingCoords[1];\n    if (!(isFinite(leftTop_1[0]) && isFinite(leftTop_1[1]) && isFinite(rightBottom_1[0]) && isFinite(rightBottom_1[1]))) {\n      if (false) {}\n    } else {\n      // Sample around the lng/lat rect and use projection to calculate actual bounding rect.\n      var projection_1 = this.projection;\n      if (projection_1) {\n        var xMin = leftTop_1[0];\n        var yMin = leftTop_1[1];\n        var xMax = rightBottom_1[0];\n        var yMax = rightBottom_1[1];\n        leftTop_1 = [Infinity, Infinity];\n        rightBottom_1 = [-Infinity, -Infinity];\n        // TODO better way?\n        var sampleLine = function (x0, y0, x1, y1) {\n          var dx = x1 - x0;\n          var dy = y1 - y0;\n          for (var i = 0; i <= 100; i++) {\n            var p = i / 100;\n            var pt = projection_1.project([x0 + dx * p, y0 + dy * p]);\n            vector.min(leftTop_1, leftTop_1, pt);\n            vector.max(rightBottom_1, rightBottom_1, pt);\n          }\n        };\n        // Top\n        sampleLine(xMin, yMin, xMax, yMin);\n        // Right\n        sampleLine(xMax, yMin, xMax, yMax);\n        // Bottom\n        sampleLine(xMax, yMax, xMin, yMax);\n        // Left\n        sampleLine(xMin, yMax, xMax, yMin);\n      }\n      this.setBoundingRect(leftTop_1[0], leftTop_1[1], rightBottom_1[0] - leftTop_1[0], rightBottom_1[1] - leftTop_1[1]);\n    }\n  }\n  var rect = this.getBoundingRect();\n  var centerOption = geoModel.get('layoutCenter');\n  var sizeOption = geoModel.get('layoutSize');\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  var aspect = rect.width / rect.height * this.aspectScale;\n  var useCenterAndSize = false;\n  var center;\n  var size;\n  if (centerOption && sizeOption) {\n    center = [number/* parsePercent */.lo(centerOption[0], viewWidth), number/* parsePercent */.lo(centerOption[1], viewHeight)];\n    size = number/* parsePercent */.lo(sizeOption, Math.min(viewWidth, viewHeight));\n    if (!isNaN(center[0]) && !isNaN(center[1]) && !isNaN(size)) {\n      useCenterAndSize = true;\n    } else {\n      if (false) {}\n    }\n  }\n  var viewRect;\n  if (useCenterAndSize) {\n    viewRect = {};\n    if (aspect > 1) {\n      // Width is same with size\n      viewRect.width = size;\n      viewRect.height = size / aspect;\n    } else {\n      viewRect.height = size;\n      viewRect.width = size * aspect;\n    }\n    viewRect.y = center[1] - viewRect.height / 2;\n    viewRect.x = center[0] - viewRect.width / 2;\n  } else {\n    // Use left/top/width/height\n    var boxLayoutOption = geoModel.getBoxLayoutParams();\n    boxLayoutOption.aspect = aspect;\n    viewRect = layout/* getLayoutRect */.dV(boxLayoutOption, {\n      width: viewWidth,\n      height: viewHeight\n    });\n  }\n  this.setViewRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);\n  this.setCenter(geoModel.get('center'), api);\n  this.setZoom(geoModel.get('zoom'));\n}\n// Back compat for ECharts2, where the coord map is set on map series:\n// {type: 'map', geoCoord: {'cityA': [116.46,39.92], 'cityA': [119.12,24.61]}},\nfunction setGeoCoords(geo, model) {\n  util.each(model.get('geoCoord'), function (geoCoord, name) {\n    geo.addGeoCoord(name, geoCoord);\n  });\n}\nvar GeoCreator = /** @class */function () {\n  function GeoCreator() {\n    // For deciding which dimensions to use when creating list data\n    this.dimensions = geo2DDimensions;\n  }\n  GeoCreator.prototype.create = function (ecModel, api) {\n    var geoList = [];\n    function getCommonGeoProperties(model) {\n      return {\n        nameProperty: model.get('nameProperty'),\n        aspectScale: model.get('aspectScale'),\n        projection: model.get('projection')\n      };\n    }\n    // FIXME Create each time may be slow\n    ecModel.eachComponent('geo', function (geoModel, idx) {\n      var mapName = geoModel.get('map');\n      var geo = new geo_Geo(mapName + idx, mapName, util.extend({\n        nameMap: geoModel.get('nameMap')\n      }, getCommonGeoProperties(geoModel)));\n      geo.zoomLimit = geoModel.get('scaleLimit');\n      geoList.push(geo);\n      // setGeoCoords(geo, geoModel);\n      geoModel.coordinateSystem = geo;\n      geo.model = geoModel;\n      // Inject resize method\n      geo.resize = resizeGeo;\n      geo.resize(geoModel, api);\n    });\n    ecModel.eachSeries(function (seriesModel) {\n      var coordSys = seriesModel.get('coordinateSystem');\n      if (coordSys === 'geo') {\n        var geoIndex = seriesModel.get('geoIndex') || 0;\n        seriesModel.coordinateSystem = geoList[geoIndex];\n      }\n    });\n    // If has map series\n    var mapModelGroupBySeries = {};\n    ecModel.eachSeriesByType('map', function (seriesModel) {\n      if (!seriesModel.getHostGeoModel()) {\n        var mapType = seriesModel.getMapType();\n        mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];\n        mapModelGroupBySeries[mapType].push(seriesModel);\n      }\n    });\n    util.each(mapModelGroupBySeries, function (mapSeries, mapType) {\n      var nameMapList = util.map(mapSeries, function (singleMapSeries) {\n        return singleMapSeries.get('nameMap');\n      });\n      var geo = new geo_Geo(mapType, mapType, util.extend({\n        nameMap: util.mergeAll(nameMapList)\n      }, getCommonGeoProperties(mapSeries[0])));\n      geo.zoomLimit = util.retrieve.apply(null, util.map(mapSeries, function (singleMapSeries) {\n        return singleMapSeries.get('scaleLimit');\n      }));\n      geoList.push(geo);\n      // Inject resize method\n      geo.resize = resizeGeo;\n      geo.resize(mapSeries[0], api);\n      util.each(mapSeries, function (singleMapSeries) {\n        singleMapSeries.coordinateSystem = geo;\n        setGeoCoords(geo, singleMapSeries);\n      });\n    });\n    return geoList;\n  };\n  /**\r\n   * Fill given regions array\r\n   */\n  GeoCreator.prototype.getFilledRegions = function (originRegionArr, mapName, nameMap, nameProperty) {\n    // Not use the original\n    var regionsArr = (originRegionArr || []).slice();\n    var dataNameMap = util.createHashMap();\n    for (var i = 0; i < regionsArr.length; i++) {\n      dataNameMap.set(regionsArr[i].name, regionsArr[i]);\n    }\n    var source = geoSourceManager/* default */.A.load(mapName, nameMap, nameProperty);\n    util.each(source.regions, function (region) {\n      var name = region.name;\n      var regionOption = dataNameMap.get(name);\n      // apply specified echarts style in GeoJSON data\n      var specifiedGeoJSONRegionStyle = region.properties && region.properties.echartsStyle;\n      if (!regionOption) {\n        regionOption = {\n          name: name\n        };\n        regionsArr.push(regionOption);\n      }\n      specifiedGeoJSONRegionStyle && util.merge(regionOption, specifiedGeoJSONRegionStyle);\n    });\n    return regionsArr;\n  };\n  return GeoCreator;\n}();\nvar geoCreator = new GeoCreator();\n/* harmony default export */ const geo_geoCreator = (geoCreator);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg1OTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9nZW8vR2VvLmpzPzhiNDIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2dlby9nZW9DcmVhdG9yLmpzPzNhMDgiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IEJvdW5kaW5nUmVjdCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcyc7XG5pbXBvcnQgVmlldyBmcm9tICcuLi9WaWV3LmpzJztcbmltcG9ydCBnZW9Tb3VyY2VNYW5hZ2VyIGZyb20gJy4vZ2VvU291cmNlTWFuYWdlci5qcyc7XG5pbXBvcnQgeyBTSU5HTEVfUkVGRVJSSU5HIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vdXRpbC9sb2cuanMnO1xudmFyIEdFT19ERUZBVUxUX1BBUkFNUyA9IHtcbiAgJ2dlb0pTT04nOiB7XG4gICAgYXNwZWN0U2NhbGU6IDAuNzUsXG4gICAgaW52ZXJ0TG9uZ2l0dXRlOiB0cnVlXG4gIH0sXG4gICdnZW9TVkcnOiB7XG4gICAgYXNwZWN0U2NhbGU6IDEsXG4gICAgaW52ZXJ0TG9uZ2l0dXRlOiBmYWxzZVxuICB9XG59O1xuZXhwb3J0IHZhciBnZW8yRERpbWVuc2lvbnMgPSBbJ2xuZycsICdsYXQnXTtcbnZhciBHZW8gPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoR2VvLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBHZW8obmFtZSwgbWFwLCBvcHQpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xuICAgIF90aGlzLmRpbWVuc2lvbnMgPSBnZW8yRERpbWVuc2lvbnM7XG4gICAgX3RoaXMudHlwZSA9ICdnZW8nO1xuICAgIC8vIE9ubHkgc3RvcmUgc3BlY2lmaWVkIG5hbWUgY29vcmQgdmlhIGBhZGRHZW9Db29yZGAuXG4gICAgX3RoaXMuX25hbWVDb29yZE1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgX3RoaXMubWFwID0gbWFwO1xuICAgIHZhciBwcm9qZWN0aW9uID0gb3B0LnByb2plY3Rpb247XG4gICAgdmFyIHNvdXJjZSA9IGdlb1NvdXJjZU1hbmFnZXIubG9hZChtYXAsIG9wdC5uYW1lTWFwLCBvcHQubmFtZVByb3BlcnR5KTtcbiAgICB2YXIgcmVzb3VyY2UgPSBnZW9Tb3VyY2VNYW5hZ2VyLmdldEdlb1Jlc291cmNlKG1hcCk7XG4gICAgdmFyIHJlc291cmNlVHlwZSA9IF90aGlzLnJlc291cmNlVHlwZSA9IHJlc291cmNlID8gcmVzb3VyY2UudHlwZSA6IG51bGw7XG4gICAgdmFyIHJlZ2lvbnMgPSBfdGhpcy5yZWdpb25zID0gc291cmNlLnJlZ2lvbnM7XG4gICAgdmFyIGRlZmF1bHRQYXJhbXMgPSBHRU9fREVGQVVMVF9QQVJBTVNbcmVzb3VyY2UudHlwZV07XG4gICAgX3RoaXMuX3JlZ2lvbnNNYXAgPSBzb3VyY2UucmVnaW9uc01hcDtcbiAgICBfdGhpcy5yZWdpb25zID0gc291cmNlLnJlZ2lvbnM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgcHJvamVjdGlvbikge1xuICAgICAgLy8gRG8gc29tZSBjaGVja1xuICAgICAgaWYgKHJlc291cmNlVHlwZSA9PT0gJ2dlb1NWRycpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKFwiTWFwIFwiICsgbWFwICsgXCIgd2l0aCBTVkcgc291cmNlIGNhbid0IHVzZSBwcm9qZWN0aW9uLiBPbmx5IEdlb0pTT04gc291cmNlIHN1cHBvcnRzIHByb2plY3Rpb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHByb2plY3Rpb24gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCEocHJvamVjdGlvbi5wcm9qZWN0ICYmIHByb2plY3Rpb24udW5wcm9qZWN0KSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ3Byb2plY3QgYW5kIHVucHJvamVjdCBtdXN0IGJlIGJvdGggcHJvdmlkZWQgaW4gdGhlIHByb2plY2l0b24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvamVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIF90aGlzLnByb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuICAgIHZhciBib3VuZGluZ1JlY3Q7XG4gICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgIC8vIENhbid0IHJldXNlIHRoZSByYXcgYm91bmRpbmcgcmVjdFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZWdpb25SZWN0ID0gcmVnaW9uc1tpXS5nZXRCb3VuZGluZ1JlY3QocHJvamVjdGlvbik7XG4gICAgICAgIGJvdW5kaW5nUmVjdCA9IGJvdW5kaW5nUmVjdCB8fCByZWdpb25SZWN0LmNsb25lKCk7XG4gICAgICAgIGJvdW5kaW5nUmVjdC51bmlvbihyZWdpb25SZWN0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRpbmdSZWN0ID0gc291cmNlLmJvdW5kaW5nUmVjdDtcbiAgICB9XG4gICAgX3RoaXMuc2V0Qm91bmRpbmdSZWN0KGJvdW5kaW5nUmVjdC54LCBib3VuZGluZ1JlY3QueSwgYm91bmRpbmdSZWN0LndpZHRoLCBib3VuZGluZ1JlY3QuaGVpZ2h0KTtcbiAgICAvLyBhc3BlY3RTY2FsZSBhbmQgaW52ZXJ0TG9uZ2l0dXRlIGFjdHVhbGx5IGlzIHRoZSBwYXJhbWV0ZXJzIGRlZmF1bHQgcmF3IHByb2plY3Rpb24uXG4gICAgLy8gU28gd2UgaWdub3JlIHRoZW0gaWYgcHJvamVjdGlvbiBpcyBnaXZlbi5cbiAgICAvLyBJZ25vcmUgZGVmYXVsdCBhc3BlY3Qgc2NhbGUgaWYgcHJvamVjdGlvbiBleGl0cy5cbiAgICBfdGhpcy5hc3BlY3RTY2FsZSA9IHByb2plY3Rpb24gPyAxIDogenJVdGlsLnJldHJpZXZlMihvcHQuYXNwZWN0U2NhbGUsIGRlZmF1bHRQYXJhbXMuYXNwZWN0U2NhbGUpO1xuICAgIC8vIE5vdCBpbnZlcnQgbG9uZ2l0dWRlIGlmIHByb2plY3Rpb24gZXhpdHMuXG4gICAgX3RoaXMuX2ludmVydExvbmdpdHV0ZSA9IHByb2plY3Rpb24gPyBmYWxzZSA6IGRlZmF1bHRQYXJhbXMuaW52ZXJ0TG9uZ2l0dXRlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBHZW8ucHJvdG90eXBlLl90cmFuc2Zvcm1UbyA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBpbnZlcnRMb25naXR1dGUgPSB0aGlzLl9pbnZlcnRMb25naXR1dGU7XG4gICAgcmVjdCA9IHJlY3QuY2xvbmUoKTtcbiAgICBpZiAoaW52ZXJ0TG9uZ2l0dXRlKSB7XG4gICAgICAvLyBMb25naXR1ZGUgaXMgaW52ZXJ0ZWQuXG4gICAgICByZWN0LnkgPSAtcmVjdC55IC0gcmVjdC5oZWlnaHQ7XG4gICAgfVxuICAgIHZhciByYXdUcmFuc2Zvcm1hYmxlID0gdGhpcy5fcmF3VHJhbnNmb3JtYWJsZTtcbiAgICByYXdUcmFuc2Zvcm1hYmxlLnRyYW5zZm9ybSA9IHJlY3QuY2FsY3VsYXRlVHJhbnNmb3JtKG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICAgIHZhciByYXdQYXJlbnQgPSByYXdUcmFuc2Zvcm1hYmxlLnBhcmVudDtcbiAgICByYXdUcmFuc2Zvcm1hYmxlLnBhcmVudCA9IG51bGw7XG4gICAgcmF3VHJhbnNmb3JtYWJsZS5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgICByYXdUcmFuc2Zvcm1hYmxlLnBhcmVudCA9IHJhd1BhcmVudDtcbiAgICBpZiAoaW52ZXJ0TG9uZ2l0dXRlKSB7XG4gICAgICByYXdUcmFuc2Zvcm1hYmxlLnNjYWxlWSA9IC1yYXdUcmFuc2Zvcm1hYmxlLnNjYWxlWTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlVHJhbnNmb3JtKCk7XG4gIH07XG4gIEdlby5wcm90b3R5cGUuZ2V0UmVnaW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVnaW9uc01hcC5nZXQobmFtZSk7XG4gIH07XG4gIEdlby5wcm90b3R5cGUuZ2V0UmVnaW9uQnlDb29yZCA9IGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHZhciByZWdpb25zID0gdGhpcy5yZWdpb25zO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlZ2lvbiA9IHJlZ2lvbnNbaV07XG4gICAgICBpZiAocmVnaW9uLnR5cGUgPT09ICdnZW9KU09OJyAmJiByZWdpb24uY29udGFpbihjb29yZCkpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lvbnNbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBBZGQgZ2VvQ29vcmQgZm9yIGluZGV4aW5nIGJ5IG5hbWVcclxuICAgKi9cbiAgR2VvLnByb3RvdHlwZS5hZGRHZW9Db29yZCA9IGZ1bmN0aW9uIChuYW1lLCBnZW9Db29yZCkge1xuICAgIHRoaXMuX25hbWVDb29yZE1hcC5zZXQobmFtZSwgZ2VvQ29vcmQpO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgZ2VvQ29vcmQgYnkgbmFtZVxyXG4gICAqL1xuICBHZW8ucHJvdG90eXBlLmdldEdlb0Nvb3JkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgcmVnaW9uID0gdGhpcy5fcmVnaW9uc01hcC5nZXQobmFtZSk7XG4gICAgLy8gQ2FsY3VsYXRlIGNlbnRlciBvbmx5IG9uIGRlbWFuZC5cbiAgICByZXR1cm4gdGhpcy5fbmFtZUNvb3JkTWFwLmdldChuYW1lKSB8fCByZWdpb24gJiYgcmVnaW9uLmdldENlbnRlcigpO1xuICB9O1xuICBHZW8ucHJvdG90eXBlLmRhdGFUb1BvaW50ID0gZnVuY3Rpb24gKGRhdGEsIG5vUm9hbSwgb3V0KSB7XG4gICAgaWYgKHpyVXRpbC5pc1N0cmluZyhkYXRhKSkge1xuICAgICAgLy8gTWFwIGFyZWEgbmFtZSB0byBnZW9Db29yZFxuICAgICAgZGF0YSA9IHRoaXMuZ2V0R2VvQ29vcmQoZGF0YSk7XG4gICAgfVxuICAgIGlmIChkYXRhKSB7XG4gICAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMucHJvamVjdGlvbjtcbiAgICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAgIC8vIHByb2plY3Rpb24gbWF5IHJldHVybiBudWxsIHBvaW50LlxuICAgICAgICBkYXRhID0gcHJvamVjdGlvbi5wcm9qZWN0KGRhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGEgJiYgdGhpcy5wcm9qZWN0ZWRUb1BvaW50KGRhdGEsIG5vUm9hbSwgb3V0KTtcbiAgICB9XG4gIH07XG4gIEdlby5wcm90b3R5cGUucG9pbnRUb0RhdGEgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMucHJvamVjdGlvbjtcbiAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgLy8gcHJvamVjdGlvbiBtYXkgcmV0dXJuIG51bGwgcG9pbnQuXG4gICAgICBwb2ludCA9IHByb2plY3Rpb24udW5wcm9qZWN0KHBvaW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50ICYmIHRoaXMucG9pbnRUb1Byb2plY3RlZChwb2ludCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFBvaW50IHRvIHByb2plY3RlZCBkYXRhLiBTYW1lIHdpdGggcG9pbnRUb0RhdGEgd2hlbiBwcm9qZWN0aW9uIGlzIHVzZWQuXHJcbiAgICovXG4gIEdlby5wcm90b3R5cGUucG9pbnRUb1Byb2plY3RlZCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnBvaW50VG9EYXRhLmNhbGwodGhpcywgcG9pbnQpO1xuICB9O1xuICBHZW8ucHJvdG90eXBlLnByb2plY3RlZFRvUG9pbnQgPSBmdW5jdGlvbiAocHJvamVjdGVkLCBub1JvYW0sIG91dCkge1xuICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmRhdGFUb1BvaW50LmNhbGwodGhpcywgcHJvamVjdGVkLCBub1JvYW0sIG91dCk7XG4gIH07XG4gIEdlby5wcm90b3R5cGUuY29udmVydFRvUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkge1xuICAgIHZhciBjb29yZFN5cyA9IGdldENvb3JkU3lzKGZpbmRlcik7XG4gICAgcmV0dXJuIGNvb3JkU3lzID09PSB0aGlzID8gY29vcmRTeXMuZGF0YVRvUG9pbnQodmFsdWUpIDogbnVsbDtcbiAgfTtcbiAgR2VvLnByb3RvdHlwZS5jb252ZXJ0RnJvbVBpeGVsID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlciwgcGl4ZWwpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBnZXRDb29yZFN5cyhmaW5kZXIpO1xuICAgIHJldHVybiBjb29yZFN5cyA9PT0gdGhpcyA/IGNvb3JkU3lzLnBvaW50VG9EYXRhKHBpeGVsKSA6IG51bGw7XG4gIH07XG4gIHJldHVybiBHZW87XG59KFZpZXcpO1xuO1xuenJVdGlsLm1peGluKEdlbywgVmlldyk7XG5mdW5jdGlvbiBnZXRDb29yZFN5cyhmaW5kZXIpIHtcbiAgdmFyIGdlb01vZGVsID0gZmluZGVyLmdlb01vZGVsO1xuICB2YXIgc2VyaWVzTW9kZWwgPSBmaW5kZXIuc2VyaWVzTW9kZWw7XG4gIHJldHVybiBnZW9Nb2RlbCA/IGdlb01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gOiBzZXJpZXNNb2RlbCA/IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gLy8gRm9yIG1hcCBzZXJpZXMuXG4gIHx8IChzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKCdnZW8nLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF0gfHwge30pLmNvb3JkaW5hdGVTeXN0ZW0gOiBudWxsO1xufVxuZXhwb3J0IGRlZmF1bHQgR2VvOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgR2VvLCB7IGdlbzJERGltZW5zaW9ucyB9IGZyb20gJy4vR2VvLmpzJztcbmltcG9ydCAqIGFzIGxheW91dCBmcm9tICcuLi8uLi91dGlsL2xheW91dC5qcyc7XG5pbXBvcnQgKiBhcyBudW1iZXJVdGlsIGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyLmpzJztcbmltcG9ydCBnZW9Tb3VyY2VNYW5hZ2VyIGZyb20gJy4vZ2VvU291cmNlTWFuYWdlci5qcyc7XG5pbXBvcnQgKiBhcyB2ZWN0b3IgZnJvbSAnenJlbmRlci9saWIvY29yZS92ZWN0b3IuanMnO1xuLyoqXHJcbiAqIFJlc2l6ZSBtZXRob2QgYm91bmQgdG8gdGhlIGdlb1xyXG4gKi9cbmZ1bmN0aW9uIHJlc2l6ZUdlbyhnZW9Nb2RlbCwgYXBpKSB7XG4gIHZhciBib3VuZGluZ0Nvb3JkcyA9IGdlb01vZGVsLmdldCgnYm91bmRpbmdDb29yZHMnKTtcbiAgaWYgKGJvdW5kaW5nQ29vcmRzICE9IG51bGwpIHtcbiAgICB2YXIgbGVmdFRvcF8xID0gYm91bmRpbmdDb29yZHNbMF07XG4gICAgdmFyIHJpZ2h0Qm90dG9tXzEgPSBib3VuZGluZ0Nvb3Jkc1sxXTtcbiAgICBpZiAoIShpc0Zpbml0ZShsZWZ0VG9wXzFbMF0pICYmIGlzRmluaXRlKGxlZnRUb3BfMVsxXSkgJiYgaXNGaW5pdGUocmlnaHRCb3R0b21fMVswXSkgJiYgaXNGaW5pdGUocmlnaHRCb3R0b21fMVsxXSkpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGJvdW5kaW5nQ29vcmRzJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNhbXBsZSBhcm91bmQgdGhlIGxuZy9sYXQgcmVjdCBhbmQgdXNlIHByb2plY3Rpb24gdG8gY2FsY3VsYXRlIGFjdHVhbCBib3VuZGluZyByZWN0LlxuICAgICAgdmFyIHByb2plY3Rpb25fMSA9IHRoaXMucHJvamVjdGlvbjtcbiAgICAgIGlmIChwcm9qZWN0aW9uXzEpIHtcbiAgICAgICAgdmFyIHhNaW4gPSBsZWZ0VG9wXzFbMF07XG4gICAgICAgIHZhciB5TWluID0gbGVmdFRvcF8xWzFdO1xuICAgICAgICB2YXIgeE1heCA9IHJpZ2h0Qm90dG9tXzFbMF07XG4gICAgICAgIHZhciB5TWF4ID0gcmlnaHRCb3R0b21fMVsxXTtcbiAgICAgICAgbGVmdFRvcF8xID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gICAgICAgIHJpZ2h0Qm90dG9tXzEgPSBbLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgICAgICAvLyBUT0RPIGJldHRlciB3YXk/XG4gICAgICAgIHZhciBzYW1wbGVMaW5lID0gZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgICAgdmFyIGR4ID0geDEgLSB4MDtcbiAgICAgICAgICB2YXIgZHkgPSB5MSAtIHkwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDEwMDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGkgLyAxMDA7XG4gICAgICAgICAgICB2YXIgcHQgPSBwcm9qZWN0aW9uXzEucHJvamVjdChbeDAgKyBkeCAqIHAsIHkwICsgZHkgKiBwXSk7XG4gICAgICAgICAgICB2ZWN0b3IubWluKGxlZnRUb3BfMSwgbGVmdFRvcF8xLCBwdCk7XG4gICAgICAgICAgICB2ZWN0b3IubWF4KHJpZ2h0Qm90dG9tXzEsIHJpZ2h0Qm90dG9tXzEsIHB0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRvcFxuICAgICAgICBzYW1wbGVMaW5lKHhNaW4sIHlNaW4sIHhNYXgsIHlNaW4pO1xuICAgICAgICAvLyBSaWdodFxuICAgICAgICBzYW1wbGVMaW5lKHhNYXgsIHlNaW4sIHhNYXgsIHlNYXgpO1xuICAgICAgICAvLyBCb3R0b21cbiAgICAgICAgc2FtcGxlTGluZSh4TWF4LCB5TWF4LCB4TWluLCB5TWF4KTtcbiAgICAgICAgLy8gTGVmdFxuICAgICAgICBzYW1wbGVMaW5lKHhNaW4sIHlNYXgsIHhNYXgsIHlNaW4pO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRCb3VuZGluZ1JlY3QobGVmdFRvcF8xWzBdLCBsZWZ0VG9wXzFbMV0sIHJpZ2h0Qm90dG9tXzFbMF0gLSBsZWZ0VG9wXzFbMF0sIHJpZ2h0Qm90dG9tXzFbMV0gLSBsZWZ0VG9wXzFbMV0pO1xuICAgIH1cbiAgfVxuICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gIHZhciBjZW50ZXJPcHRpb24gPSBnZW9Nb2RlbC5nZXQoJ2xheW91dENlbnRlcicpO1xuICB2YXIgc2l6ZU9wdGlvbiA9IGdlb01vZGVsLmdldCgnbGF5b3V0U2l6ZScpO1xuICB2YXIgdmlld1dpZHRoID0gYXBpLmdldFdpZHRoKCk7XG4gIHZhciB2aWV3SGVpZ2h0ID0gYXBpLmdldEhlaWdodCgpO1xuICB2YXIgYXNwZWN0ID0gcmVjdC53aWR0aCAvIHJlY3QuaGVpZ2h0ICogdGhpcy5hc3BlY3RTY2FsZTtcbiAgdmFyIHVzZUNlbnRlckFuZFNpemUgPSBmYWxzZTtcbiAgdmFyIGNlbnRlcjtcbiAgdmFyIHNpemU7XG4gIGlmIChjZW50ZXJPcHRpb24gJiYgc2l6ZU9wdGlvbikge1xuICAgIGNlbnRlciA9IFtudW1iZXJVdGlsLnBhcnNlUGVyY2VudChjZW50ZXJPcHRpb25bMF0sIHZpZXdXaWR0aCksIG51bWJlclV0aWwucGFyc2VQZXJjZW50KGNlbnRlck9wdGlvblsxXSwgdmlld0hlaWdodCldO1xuICAgIHNpemUgPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChzaXplT3B0aW9uLCBNYXRoLm1pbih2aWV3V2lkdGgsIHZpZXdIZWlnaHQpKTtcbiAgICBpZiAoIWlzTmFOKGNlbnRlclswXSkgJiYgIWlzTmFOKGNlbnRlclsxXSkgJiYgIWlzTmFOKHNpemUpKSB7XG4gICAgICB1c2VDZW50ZXJBbmRTaXplID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdHaXZlbiBsYXlvdXRDZW50ZXIgb3IgbGF5b3V0U2l6ZSBkYXRhIGFyZSBpbnZhbGlkLiBVc2UgbGVmdC90b3Avd2lkdGgvaGVpZ2h0IGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciB2aWV3UmVjdDtcbiAgaWYgKHVzZUNlbnRlckFuZFNpemUpIHtcbiAgICB2aWV3UmVjdCA9IHt9O1xuICAgIGlmIChhc3BlY3QgPiAxKSB7XG4gICAgICAvLyBXaWR0aCBpcyBzYW1lIHdpdGggc2l6ZVxuICAgICAgdmlld1JlY3Qud2lkdGggPSBzaXplO1xuICAgICAgdmlld1JlY3QuaGVpZ2h0ID0gc2l6ZSAvIGFzcGVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlld1JlY3QuaGVpZ2h0ID0gc2l6ZTtcbiAgICAgIHZpZXdSZWN0LndpZHRoID0gc2l6ZSAqIGFzcGVjdDtcbiAgICB9XG4gICAgdmlld1JlY3QueSA9IGNlbnRlclsxXSAtIHZpZXdSZWN0LmhlaWdodCAvIDI7XG4gICAgdmlld1JlY3QueCA9IGNlbnRlclswXSAtIHZpZXdSZWN0LndpZHRoIC8gMjtcbiAgfSBlbHNlIHtcbiAgICAvLyBVc2UgbGVmdC90b3Avd2lkdGgvaGVpZ2h0XG4gICAgdmFyIGJveExheW91dE9wdGlvbiA9IGdlb01vZGVsLmdldEJveExheW91dFBhcmFtcygpO1xuICAgIGJveExheW91dE9wdGlvbi5hc3BlY3QgPSBhc3BlY3Q7XG4gICAgdmlld1JlY3QgPSBsYXlvdXQuZ2V0TGF5b3V0UmVjdChib3hMYXlvdXRPcHRpb24sIHtcbiAgICAgIHdpZHRoOiB2aWV3V2lkdGgsXG4gICAgICBoZWlnaHQ6IHZpZXdIZWlnaHRcbiAgICB9KTtcbiAgfVxuICB0aGlzLnNldFZpZXdSZWN0KHZpZXdSZWN0LngsIHZpZXdSZWN0LnksIHZpZXdSZWN0LndpZHRoLCB2aWV3UmVjdC5oZWlnaHQpO1xuICB0aGlzLnNldENlbnRlcihnZW9Nb2RlbC5nZXQoJ2NlbnRlcicpLCBhcGkpO1xuICB0aGlzLnNldFpvb20oZ2VvTW9kZWwuZ2V0KCd6b29tJykpO1xufVxuLy8gQmFjayBjb21wYXQgZm9yIEVDaGFydHMyLCB3aGVyZSB0aGUgY29vcmQgbWFwIGlzIHNldCBvbiBtYXAgc2VyaWVzOlxuLy8ge3R5cGU6ICdtYXAnLCBnZW9Db29yZDogeydjaXR5QSc6IFsxMTYuNDYsMzkuOTJdLCAnY2l0eUEnOiBbMTE5LjEyLDI0LjYxXX19LFxuZnVuY3Rpb24gc2V0R2VvQ29vcmRzKGdlbywgbW9kZWwpIHtcbiAgenJVdGlsLmVhY2gobW9kZWwuZ2V0KCdnZW9Db29yZCcpLCBmdW5jdGlvbiAoZ2VvQ29vcmQsIG5hbWUpIHtcbiAgICBnZW8uYWRkR2VvQ29vcmQobmFtZSwgZ2VvQ29vcmQpO1xuICB9KTtcbn1cbnZhciBHZW9DcmVhdG9yID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2VvQ3JlYXRvcigpIHtcbiAgICAvLyBGb3IgZGVjaWRpbmcgd2hpY2ggZGltZW5zaW9ucyB0byB1c2Ugd2hlbiBjcmVhdGluZyBsaXN0IGRhdGFcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBnZW8yRERpbWVuc2lvbnM7XG4gIH1cbiAgR2VvQ3JlYXRvci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBnZW9MaXN0ID0gW107XG4gICAgZnVuY3Rpb24gZ2V0Q29tbW9uR2VvUHJvcGVydGllcyhtb2RlbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZVByb3BlcnR5OiBtb2RlbC5nZXQoJ25hbWVQcm9wZXJ0eScpLFxuICAgICAgICBhc3BlY3RTY2FsZTogbW9kZWwuZ2V0KCdhc3BlY3RTY2FsZScpLFxuICAgICAgICBwcm9qZWN0aW9uOiBtb2RlbC5nZXQoJ3Byb2plY3Rpb24nKVxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gRklYTUUgQ3JlYXRlIGVhY2ggdGltZSBtYXkgYmUgc2xvd1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnZ2VvJywgZnVuY3Rpb24gKGdlb01vZGVsLCBpZHgpIHtcbiAgICAgIHZhciBtYXBOYW1lID0gZ2VvTW9kZWwuZ2V0KCdtYXAnKTtcbiAgICAgIHZhciBnZW8gPSBuZXcgR2VvKG1hcE5hbWUgKyBpZHgsIG1hcE5hbWUsIHpyVXRpbC5leHRlbmQoe1xuICAgICAgICBuYW1lTWFwOiBnZW9Nb2RlbC5nZXQoJ25hbWVNYXAnKVxuICAgICAgfSwgZ2V0Q29tbW9uR2VvUHJvcGVydGllcyhnZW9Nb2RlbCkpKTtcbiAgICAgIGdlby56b29tTGltaXQgPSBnZW9Nb2RlbC5nZXQoJ3NjYWxlTGltaXQnKTtcbiAgICAgIGdlb0xpc3QucHVzaChnZW8pO1xuICAgICAgLy8gc2V0R2VvQ29vcmRzKGdlbywgZ2VvTW9kZWwpO1xuICAgICAgZ2VvTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IGdlbztcbiAgICAgIGdlby5tb2RlbCA9IGdlb01vZGVsO1xuICAgICAgLy8gSW5qZWN0IHJlc2l6ZSBtZXRob2RcbiAgICAgIGdlby5yZXNpemUgPSByZXNpemVHZW87XG4gICAgICBnZW8ucmVzaXplKGdlb01vZGVsLCBhcGkpO1xuICAgIH0pO1xuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpO1xuICAgICAgaWYgKGNvb3JkU3lzID09PSAnZ2VvJykge1xuICAgICAgICB2YXIgZ2VvSW5kZXggPSBzZXJpZXNNb2RlbC5nZXQoJ2dlb0luZGV4JykgfHwgMDtcbiAgICAgICAgc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IGdlb0xpc3RbZ2VvSW5kZXhdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIElmIGhhcyBtYXAgc2VyaWVzXG4gICAgdmFyIG1hcE1vZGVsR3JvdXBCeVNlcmllcyA9IHt9O1xuICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgnbWFwJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICBpZiAoIXNlcmllc01vZGVsLmdldEhvc3RHZW9Nb2RlbCgpKSB7XG4gICAgICAgIHZhciBtYXBUeXBlID0gc2VyaWVzTW9kZWwuZ2V0TWFwVHlwZSgpO1xuICAgICAgICBtYXBNb2RlbEdyb3VwQnlTZXJpZXNbbWFwVHlwZV0gPSBtYXBNb2RlbEdyb3VwQnlTZXJpZXNbbWFwVHlwZV0gfHwgW107XG4gICAgICAgIG1hcE1vZGVsR3JvdXBCeVNlcmllc1ttYXBUeXBlXS5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB6clV0aWwuZWFjaChtYXBNb2RlbEdyb3VwQnlTZXJpZXMsIGZ1bmN0aW9uIChtYXBTZXJpZXMsIG1hcFR5cGUpIHtcbiAgICAgIHZhciBuYW1lTWFwTGlzdCA9IHpyVXRpbC5tYXAobWFwU2VyaWVzLCBmdW5jdGlvbiAoc2luZ2xlTWFwU2VyaWVzKSB7XG4gICAgICAgIHJldHVybiBzaW5nbGVNYXBTZXJpZXMuZ2V0KCduYW1lTWFwJyk7XG4gICAgICB9KTtcbiAgICAgIHZhciBnZW8gPSBuZXcgR2VvKG1hcFR5cGUsIG1hcFR5cGUsIHpyVXRpbC5leHRlbmQoe1xuICAgICAgICBuYW1lTWFwOiB6clV0aWwubWVyZ2VBbGwobmFtZU1hcExpc3QpXG4gICAgICB9LCBnZXRDb21tb25HZW9Qcm9wZXJ0aWVzKG1hcFNlcmllc1swXSkpKTtcbiAgICAgIGdlby56b29tTGltaXQgPSB6clV0aWwucmV0cmlldmUuYXBwbHkobnVsbCwgenJVdGlsLm1hcChtYXBTZXJpZXMsIGZ1bmN0aW9uIChzaW5nbGVNYXBTZXJpZXMpIHtcbiAgICAgICAgcmV0dXJuIHNpbmdsZU1hcFNlcmllcy5nZXQoJ3NjYWxlTGltaXQnKTtcbiAgICAgIH0pKTtcbiAgICAgIGdlb0xpc3QucHVzaChnZW8pO1xuICAgICAgLy8gSW5qZWN0IHJlc2l6ZSBtZXRob2RcbiAgICAgIGdlby5yZXNpemUgPSByZXNpemVHZW87XG4gICAgICBnZW8ucmVzaXplKG1hcFNlcmllc1swXSwgYXBpKTtcbiAgICAgIHpyVXRpbC5lYWNoKG1hcFNlcmllcywgZnVuY3Rpb24gKHNpbmdsZU1hcFNlcmllcykge1xuICAgICAgICBzaW5nbGVNYXBTZXJpZXMuY29vcmRpbmF0ZVN5c3RlbSA9IGdlbztcbiAgICAgICAgc2V0R2VvQ29vcmRzKGdlbywgc2luZ2xlTWFwU2VyaWVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBnZW9MaXN0O1xuICB9O1xuICAvKipcclxuICAgKiBGaWxsIGdpdmVuIHJlZ2lvbnMgYXJyYXlcclxuICAgKi9cbiAgR2VvQ3JlYXRvci5wcm90b3R5cGUuZ2V0RmlsbGVkUmVnaW9ucyA9IGZ1bmN0aW9uIChvcmlnaW5SZWdpb25BcnIsIG1hcE5hbWUsIG5hbWVNYXAsIG5hbWVQcm9wZXJ0eSkge1xuICAgIC8vIE5vdCB1c2UgdGhlIG9yaWdpbmFsXG4gICAgdmFyIHJlZ2lvbnNBcnIgPSAob3JpZ2luUmVnaW9uQXJyIHx8IFtdKS5zbGljZSgpO1xuICAgIHZhciBkYXRhTmFtZU1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpb25zQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhTmFtZU1hcC5zZXQocmVnaW9uc0FycltpXS5uYW1lLCByZWdpb25zQXJyW2ldKTtcbiAgICB9XG4gICAgdmFyIHNvdXJjZSA9IGdlb1NvdXJjZU1hbmFnZXIubG9hZChtYXBOYW1lLCBuYW1lTWFwLCBuYW1lUHJvcGVydHkpO1xuICAgIHpyVXRpbC5lYWNoKHNvdXJjZS5yZWdpb25zLCBmdW5jdGlvbiAocmVnaW9uKSB7XG4gICAgICB2YXIgbmFtZSA9IHJlZ2lvbi5uYW1lO1xuICAgICAgdmFyIHJlZ2lvbk9wdGlvbiA9IGRhdGFOYW1lTWFwLmdldChuYW1lKTtcbiAgICAgIC8vIGFwcGx5IHNwZWNpZmllZCBlY2hhcnRzIHN0eWxlIGluIEdlb0pTT04gZGF0YVxuICAgICAgdmFyIHNwZWNpZmllZEdlb0pTT05SZWdpb25TdHlsZSA9IHJlZ2lvbi5wcm9wZXJ0aWVzICYmIHJlZ2lvbi5wcm9wZXJ0aWVzLmVjaGFydHNTdHlsZTtcbiAgICAgIGlmICghcmVnaW9uT3B0aW9uKSB7XG4gICAgICAgIHJlZ2lvbk9wdGlvbiA9IHtcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgICAgIHJlZ2lvbnNBcnIucHVzaChyZWdpb25PcHRpb24pO1xuICAgICAgfVxuICAgICAgc3BlY2lmaWVkR2VvSlNPTlJlZ2lvblN0eWxlICYmIHpyVXRpbC5tZXJnZShyZWdpb25PcHRpb24sIHNwZWNpZmllZEdlb0pTT05SZWdpb25TdHlsZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlZ2lvbnNBcnI7XG4gIH07XG4gIHJldHVybiBHZW9DcmVhdG9yO1xufSgpO1xudmFyIGdlb0NyZWF0b3IgPSBuZXcgR2VvQ3JlYXRvcigpO1xuZXhwb3J0IGRlZmF1bHQgZ2VvQ3JlYXRvcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///98592\n")}}]);