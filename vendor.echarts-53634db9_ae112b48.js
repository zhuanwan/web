"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[8564],{14403:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var zrender_lib_core_Eventful_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(57861);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43870);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(30010);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(43199);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(39195);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(52505);\n/* harmony import */ var _interactionMutex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23868);\n/* harmony import */ var _data_DataDiffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16563);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\nvar BRUSH_PANEL_GLOBAL = true;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(210,219,238,0.3)',\n    fill: '#D2DBEE'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\r\n * params:\r\n *     areas: Array.<Array>, coord relates to container group,\r\n *                             If no container specified, to global.\r\n *     opt {\r\n *         isEnd: boolean,\r\n *         removeOnClick: boolean\r\n *     }\r\n */\nvar BrushController = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(BrushController, _super);\n  function BrushController(zr) {\n    var _this = _super.call(this) || this;\n    /**\r\n     * @internal\r\n     */\n    _this._track = [];\n    /**\r\n     * @internal\r\n     */\n    _this._covers = [];\n    _this._handlers = {};\n    if (false) {}\n    _this._zr = zr;\n    _this.group = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A();\n    _this._uid = 'brushController_' + baseUID++;\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(pointerHandlers, function (handler, eventName) {\n      this._handlers[eventName] = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.bind)(handler, this);\n    }, _this);\n    return _this;\n  }\n  /**\r\n   * If set to `false`, select disabled.\r\n   */\n  BrushController.prototype.enableBrush = function (brushOption) {\n    if (false) {}\n    this._brushType && this._doDisableBrush();\n    brushOption.brushType && this._doEnableBrush(brushOption);\n    return this;\n  };\n  BrushController.prototype._doEnableBrush = function (brushOption) {\n    var zr = this._zr;\n    // Consider roam, which takes globalPan too.\n    if (!this._enableGlobalPan) {\n      _interactionMutex_js__WEBPACK_IMPORTED_MODULE_3__/* .take */ .s(zr, MUTEX_RESOURCE_KEY, this._uid);\n    }\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(this._handlers, function (handler, eventName) {\n      zr.on(eventName, handler);\n    });\n    this._brushType = brushOption.brushType;\n    this._brushOption = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.merge)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone)(DEFAULT_BRUSH_OPT), brushOption, true);\n  };\n  BrushController.prototype._doDisableBrush = function () {\n    var zr = this._zr;\n    _interactionMutex_js__WEBPACK_IMPORTED_MODULE_3__/* .release */ ._r(zr, MUTEX_RESOURCE_KEY, this._uid);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(this._handlers, function (handler, eventName) {\n      zr.off(eventName, handler);\n    });\n    this._brushType = this._brushOption = null;\n  };\n  /**\r\n   * @param panelOpts If not pass, it is global brush.\r\n   */\n  BrushController.prototype.setPanels = function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels_1 = this._panels = {};\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(panelOpts, function (panelOpts) {\n        panels_1[panelOpts.panelId] = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone)(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n    return this;\n  };\n  BrushController.prototype.mount = function (opt) {\n    opt = opt || {};\n    if (false) {}\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n    this._zr.add(thisGroup);\n    thisGroup.attr({\n      x: opt.x || 0,\n      y: opt.y || 0,\n      rotation: opt.rotation || 0,\n      scaleX: opt.scaleX || 1,\n      scaleY: opt.scaleY || 1\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  };\n  // eachCover(cb, context): void {\n  //     each(this._covers, cb, context);\n  // }\n  /**\r\n   * Update covers.\r\n   * @param coverConfigList\r\n   *        If coverConfigList is null/undefined, all covers removed.\r\n   */\n  BrushController.prototype.updateCovers = function (coverConfigList) {\n    if (false) {}\n    coverConfigList = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(coverConfigList, function (coverConfig) {\n      return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.merge)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone)(DEFAULT_BRUSH_OPT), coverConfig, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new _data_DataDiffer_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A(oldCovers, coverConfigList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushInternal = coverConfigList[newIndex];\n      // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbidden.\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  };\n  BrushController.prototype.unmount = function () {\n    if (false) {}\n    this.enableBrush(false);\n    // container may 'removeAll' outside.\n    clearCovers(this);\n    this._zr.remove(this.group);\n    if (false) {}\n    return this;\n  };\n  BrushController.prototype.dispose = function () {\n    this.unmount();\n    this.off();\n  };\n  return BrushController;\n}(zrender_lib_core_Eventful_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A);\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n  return creatingCover;\n}\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n}\n// return target panel or `true` (means global panel)\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n  if (!panels) {\n    return BRUSH_PANEL_GLOBAL; // Global panel\n  }\n  var panel;\n  var transform = controller._transform;\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n}\n// Return a panel or true\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n  if (!panels) {\n    return BRUSH_PANEL_GLOBAL; // Global panel\n  }\n  var panelId = cover.__brushOption.panelId;\n  // User may give cover without coord sys info,\n  // which is then treated as global panel.\n  return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL;\n}\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\nfunction trigger(controller, opt) {\n  var areas = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone)(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', {\n    areas: areas,\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n  if (!track.length) {\n    return false;\n  }\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\n;\nfunction createBaseRectCover(rectRangeConverter, controller, brushOption, edgeNameSequences) {\n  var cover = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A();\n  cover.add(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.curry)(driftRect, rectRangeConverter, controller, cover, ['n', 's', 'w', 'e']),\n    ondragend: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.curry)(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(edgeNameSequences, function (nameSequence) {\n    cover.add(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A({\n      name: nameSequence.join(''),\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.curry)(driftRect, rectRangeConverter, controller, cover, nameSequence),\n      ondragend: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.curry)(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)([['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']], function (nameSequence) {\n    var el = cover.childOfName(nameSequence.join(''));\n    var globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\nfunction makeStyle(brushOption) {\n  return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.defaults)({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]], [min[1], max[1]] // y range\n  ];\n}\nfunction getTransform(controller) {\n  return _util_graphic_js__WEBPACK_IMPORTED_MODULE_7__.getTransform(controller.group);\n}\nfunction getGlobalDirection1(controller, localDirName) {\n  var map = {\n    w: 'left',\n    e: 'right',\n    n: 'top',\n    s: 'bottom'\n  };\n  var inverseMap = {\n    left: 'w',\n    right: 'e',\n    top: 'n',\n    bottom: 's'\n  };\n  var dir = _util_graphic_js__WEBPACK_IMPORTED_MODULE_7__.transformDirection(map[localDirName], getTransform(controller));\n  return inverseMap[dir];\n}\nfunction getGlobalDirection2(controller, localDirNameSeq) {\n  var globalDir = [getGlobalDirection1(controller, localDirNameSeq[0]), getGlobalDirection1(controller, localDirNameSeq[1])];\n  (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n  return globalDir.join('');\n}\nfunction driftRect(rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {\n  var brushOption = cover.__brushOption;\n  var rectRange = rectRangeConverter.toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(dirNameSequence, function (dirName) {\n    var ind = DIRECTION_MAP[dirName];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\nfunction driftPolygon(controller, cover, dx, dy) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone)(data);\n}\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\nfunction resetCursor(controller, e, localCursorPoint) {\n  if (\n  // Check active\n  !controller._brushType\n  // resetCursor should be always called when mouse is in zr area,\n  // but not called when mouse is out of zr area to avoid bad influence\n  // if `mousemove`, `mouseup` are triggered from `document` event.\n  || isOutsideZrArea(controller, e.offsetX, e.offsetY)) {\n    return;\n  }\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint);\n  // Check whether in covers.\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n      if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n  currPanel && zr.setCursorStyle('crosshair');\n}\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n  controller._track.push(localCursorPoint.slice());\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone)(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n      controller._covers.push(creatingCover);\n    }\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n  return eventParams;\n}\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    if (false) {}\n    return panel.defaultBrushType;\n  }\n  return brushType;\n}\nvar pointerHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mouse out side the browser.\n      handleDragEnd(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var localCursorPoint = this.group.transformCoordToLocal(x, y);\n    resetCursor(this, e, localCursorPoint);\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: function (e) {\n    handleDragEnd(this, e);\n  }\n};\nfunction handleDragEnd(controller, e) {\n  if (controller._dragging) {\n    preventDefault(e);\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var localCursorPoint = controller.group.transformCoordToLocal(x, y);\n    var eventParams = updateCoverByMouse(controller, e, localCursorPoint, true);\n    controller._dragging = false;\n    controller._track = [];\n    controller._creatingCover = null;\n    // trigger event should be at final, after procedure will be nested.\n    eventParams && trigger(controller, eventParams);\n  }\n}\nfunction isOutsideZrArea(controller, x, y) {\n  var zr = controller._zr;\n  return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();\n}\n/**\r\n * key: brushType\r\n */\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      function returnInput(range) {\n        return range;\n      }\n      return createBaseRectCover({\n        toRectRange: returnInput,\n        fromRectRange: returnInput\n      }, controller, brushOption, [['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A();\n      // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n      cover.add(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .A({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0));\n      // Use graphic.Polygon close the shape.\n      cover.add(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_9__/* [\"default\"] */ .A({\n        name: 'main',\n        draggable: true,\n        drift: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.curry)(driftPolygon, controller, cover),\n        ondragend: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.curry)(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover({\n        toRectRange: function (range) {\n          var rectRange = [range, [0, 100]];\n          xyIndex && rectRange.reverse();\n          return rectRange;\n        },\n        fromRectRange: function (rectRange) {\n          return rectRange[xyIndex];\n        }\n      }, controller, brushOption, [[['w'], ['e']], [['n'], ['s']]][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent;\n      // If brushWidth not specified, fit the panel.\n      var panel = getPanelByCover(controller, cover);\n      if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BrushController);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ0MDMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL0JydXNoQ29udHJvbGxlci5qcz9hYzc4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBjdXJyeSwgZWFjaCwgbWFwLCBiaW5kLCBtZXJnZSwgY2xvbmUsIGRlZmF1bHRzLCBhc3NlcnQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IEV2ZW50ZnVsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvRXZlbnRmdWwuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0ICogYXMgaW50ZXJhY3Rpb25NdXRleCBmcm9tICcuL2ludGVyYWN0aW9uTXV0ZXguanMnO1xuaW1wb3J0IERhdGFEaWZmZXIgZnJvbSAnLi4vLi4vZGF0YS9EYXRhRGlmZmVyLmpzJztcbnZhciBCUlVTSF9QQU5FTF9HTE9CQUwgPSB0cnVlO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aFBvdyA9IE1hdGgucG93O1xudmFyIENPVkVSX1ogPSAxMDAwMDtcbnZhciBVTlNFTEVDVF9USFJFU0hPTEQgPSA2O1xudmFyIE1JTl9SRVNJWkVfTElORV9XSURUSCA9IDY7XG52YXIgTVVURVhfUkVTT1VSQ0VfS0VZID0gJ2dsb2JhbFBhbic7XG52YXIgRElSRUNUSU9OX01BUCA9IHtcbiAgdzogWzAsIDBdLFxuICBlOiBbMCwgMV0sXG4gIG46IFsxLCAwXSxcbiAgczogWzEsIDFdXG59O1xudmFyIENVUlNPUl9NQVAgPSB7XG4gIHc6ICdldycsXG4gIGU6ICdldycsXG4gIG46ICducycsXG4gIHM6ICducycsXG4gIG5lOiAnbmVzdycsXG4gIHN3OiAnbmVzdycsXG4gIG53OiAnbndzZScsXG4gIHNlOiAnbndzZSdcbn07XG52YXIgREVGQVVMVF9CUlVTSF9PUFQgPSB7XG4gIGJydXNoU3R5bGU6IHtcbiAgICBsaW5lV2lkdGg6IDIsXG4gICAgc3Ryb2tlOiAncmdiYSgyMTAsMjE5LDIzOCwwLjMpJyxcbiAgICBmaWxsOiAnI0QyREJFRSdcbiAgfSxcbiAgdHJhbnNmb3JtYWJsZTogdHJ1ZSxcbiAgYnJ1c2hNb2RlOiAnc2luZ2xlJyxcbiAgcmVtb3ZlT25DbGljazogZmFsc2Vcbn07XG52YXIgYmFzZVVJRCA9IDA7XG4vKipcclxuICogcGFyYW1zOlxyXG4gKiAgICAgYXJlYXM6IEFycmF5LjxBcnJheT4sIGNvb3JkIHJlbGF0ZXMgdG8gY29udGFpbmVyIGdyb3VwLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm8gY29udGFpbmVyIHNwZWNpZmllZCwgdG8gZ2xvYmFsLlxyXG4gKiAgICAgb3B0IHtcclxuICogICAgICAgICBpc0VuZDogYm9vbGVhbixcclxuICogICAgICAgICByZW1vdmVPbkNsaWNrOiBib29sZWFuXHJcbiAqICAgICB9XHJcbiAqL1xudmFyIEJydXNoQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhCcnVzaENvbnRyb2xsZXIsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEJydXNoQ29udHJvbGxlcih6cikge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xuICAgIF90aGlzLl90cmFjayA9IFtdO1xuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cbiAgICBfdGhpcy5fY292ZXJzID0gW107XG4gICAgX3RoaXMuX2hhbmRsZXJzID0ge307XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydCh6cik7XG4gICAgfVxuICAgIF90aGlzLl96ciA9IHpyO1xuICAgIF90aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICBfdGhpcy5fdWlkID0gJ2JydXNoQ29udHJvbGxlcl8nICsgYmFzZVVJRCsrO1xuICAgIGVhY2gocG9pbnRlckhhbmRsZXJzLCBmdW5jdGlvbiAoaGFuZGxlciwgZXZlbnROYW1lKSB7XG4gICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdID0gYmluZChoYW5kbGVyLCB0aGlzKTtcbiAgICB9LCBfdGhpcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIElmIHNldCB0byBgZmFsc2VgLCBzZWxlY3QgZGlzYWJsZWQuXHJcbiAgICovXG4gIEJydXNoQ29udHJvbGxlci5wcm90b3R5cGUuZW5hYmxlQnJ1c2ggPSBmdW5jdGlvbiAoYnJ1c2hPcHRpb24pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0KHRoaXMuX21vdW50ZWQpO1xuICAgIH1cbiAgICB0aGlzLl9icnVzaFR5cGUgJiYgdGhpcy5fZG9EaXNhYmxlQnJ1c2goKTtcbiAgICBicnVzaE9wdGlvbi5icnVzaFR5cGUgJiYgdGhpcy5fZG9FbmFibGVCcnVzaChicnVzaE9wdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIEJydXNoQ29udHJvbGxlci5wcm90b3R5cGUuX2RvRW5hYmxlQnJ1c2ggPSBmdW5jdGlvbiAoYnJ1c2hPcHRpb24pIHtcbiAgICB2YXIgenIgPSB0aGlzLl96cjtcbiAgICAvLyBDb25zaWRlciByb2FtLCB3aGljaCB0YWtlcyBnbG9iYWxQYW4gdG9vLlxuICAgIGlmICghdGhpcy5fZW5hYmxlR2xvYmFsUGFuKSB7XG4gICAgICBpbnRlcmFjdGlvbk11dGV4LnRha2UoenIsIE1VVEVYX1JFU09VUkNFX0tFWSwgdGhpcy5fdWlkKTtcbiAgICB9XG4gICAgZWFjaCh0aGlzLl9oYW5kbGVycywgZnVuY3Rpb24gKGhhbmRsZXIsIGV2ZW50TmFtZSkge1xuICAgICAgenIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9icnVzaFR5cGUgPSBicnVzaE9wdGlvbi5icnVzaFR5cGU7XG4gICAgdGhpcy5fYnJ1c2hPcHRpb24gPSBtZXJnZShjbG9uZShERUZBVUxUX0JSVVNIX09QVCksIGJydXNoT3B0aW9uLCB0cnVlKTtcbiAgfTtcbiAgQnJ1c2hDb250cm9sbGVyLnByb3RvdHlwZS5fZG9EaXNhYmxlQnJ1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHpyID0gdGhpcy5fenI7XG4gICAgaW50ZXJhY3Rpb25NdXRleC5yZWxlYXNlKHpyLCBNVVRFWF9SRVNPVVJDRV9LRVksIHRoaXMuX3VpZCk7XG4gICAgZWFjaCh0aGlzLl9oYW5kbGVycywgZnVuY3Rpb24gKGhhbmRsZXIsIGV2ZW50TmFtZSkge1xuICAgICAgenIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfSk7XG4gICAgdGhpcy5fYnJ1c2hUeXBlID0gdGhpcy5fYnJ1c2hPcHRpb24gPSBudWxsO1xuICB9O1xuICAvKipcclxuICAgKiBAcGFyYW0gcGFuZWxPcHRzIElmIG5vdCBwYXNzLCBpdCBpcyBnbG9iYWwgYnJ1c2guXHJcbiAgICovXG4gIEJydXNoQ29udHJvbGxlci5wcm90b3R5cGUuc2V0UGFuZWxzID0gZnVuY3Rpb24gKHBhbmVsT3B0cykge1xuICAgIGlmIChwYW5lbE9wdHMgJiYgcGFuZWxPcHRzLmxlbmd0aCkge1xuICAgICAgdmFyIHBhbmVsc18xID0gdGhpcy5fcGFuZWxzID0ge307XG4gICAgICBlYWNoKHBhbmVsT3B0cywgZnVuY3Rpb24gKHBhbmVsT3B0cykge1xuICAgICAgICBwYW5lbHNfMVtwYW5lbE9wdHMucGFuZWxJZF0gPSBjbG9uZShwYW5lbE9wdHMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhbmVscyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBCcnVzaENvbnRyb2xsZXIucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhpcy5fbW91bnRlZCA9IHRydWU7IC8vIHNob3VsZCBiZSBhdCBmaXJzdC5cbiAgICB9XG4gICAgdGhpcy5fZW5hYmxlR2xvYmFsUGFuID0gb3B0LmVuYWJsZUdsb2JhbFBhbjtcbiAgICB2YXIgdGhpc0dyb3VwID0gdGhpcy5ncm91cDtcbiAgICB0aGlzLl96ci5hZGQodGhpc0dyb3VwKTtcbiAgICB0aGlzR3JvdXAuYXR0cih7XG4gICAgICB4OiBvcHQueCB8fCAwLFxuICAgICAgeTogb3B0LnkgfHwgMCxcbiAgICAgIHJvdGF0aW9uOiBvcHQucm90YXRpb24gfHwgMCxcbiAgICAgIHNjYWxlWDogb3B0LnNjYWxlWCB8fCAxLFxuICAgICAgc2NhbGVZOiBvcHQuc2NhbGVZIHx8IDFcbiAgICB9KTtcbiAgICB0aGlzLl90cmFuc2Zvcm0gPSB0aGlzR3JvdXAuZ2V0TG9jYWxUcmFuc2Zvcm0oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLy8gZWFjaENvdmVyKGNiLCBjb250ZXh0KTogdm9pZCB7XG4gIC8vICAgICBlYWNoKHRoaXMuX2NvdmVycywgY2IsIGNvbnRleHQpO1xuICAvLyB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBjb3ZlcnMuXHJcbiAgICogQHBhcmFtIGNvdmVyQ29uZmlnTGlzdFxyXG4gICAqICAgICAgICBJZiBjb3ZlckNvbmZpZ0xpc3QgaXMgbnVsbC91bmRlZmluZWQsIGFsbCBjb3ZlcnMgcmVtb3ZlZC5cclxuICAgKi9cbiAgQnJ1c2hDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVDb3ZlcnMgPSBmdW5jdGlvbiAoY292ZXJDb25maWdMaXN0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydCh0aGlzLl9tb3VudGVkKTtcbiAgICB9XG4gICAgY292ZXJDb25maWdMaXN0ID0gbWFwKGNvdmVyQ29uZmlnTGlzdCwgZnVuY3Rpb24gKGNvdmVyQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbWVyZ2UoY2xvbmUoREVGQVVMVF9CUlVTSF9PUFQpLCBjb3ZlckNvbmZpZywgdHJ1ZSk7XG4gICAgfSk7XG4gICAgdmFyIHRtcElkUHJlZml4ID0gJ1xcMC1icnVzaC1pbmRleC0nO1xuICAgIHZhciBvbGRDb3ZlcnMgPSB0aGlzLl9jb3ZlcnM7XG4gICAgdmFyIG5ld0NvdmVycyA9IHRoaXMuX2NvdmVycyA9IFtdO1xuICAgIHZhciBjb250cm9sbGVyID0gdGhpcztcbiAgICB2YXIgY3JlYXRpbmdDb3ZlciA9IHRoaXMuX2NyZWF0aW5nQ292ZXI7XG4gICAgbmV3IERhdGFEaWZmZXIob2xkQ292ZXJzLCBjb3ZlckNvbmZpZ0xpc3QsIG9sZEdldEtleSwgZ2V0S2V5KS5hZGQoYWRkT3JVcGRhdGUpLnVwZGF0ZShhZGRPclVwZGF0ZSkucmVtb3ZlKHJlbW92ZSkuZXhlY3V0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICAgIGZ1bmN0aW9uIGdldEtleShicnVzaE9wdGlvbiwgaW5kZXgpIHtcbiAgICAgIHJldHVybiAoYnJ1c2hPcHRpb24uaWQgIT0gbnVsbCA/IGJydXNoT3B0aW9uLmlkIDogdG1wSWRQcmVmaXggKyBpbmRleCkgKyAnLScgKyBicnVzaE9wdGlvbi5icnVzaFR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9sZEdldEtleShjb3ZlciwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBnZXRLZXkoY292ZXIuX19icnVzaE9wdGlvbiwgaW5kZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRPclVwZGF0ZShuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgICAgIHZhciBuZXdCcnVzaEludGVybmFsID0gY292ZXJDb25maWdMaXN0W25ld0luZGV4XTtcbiAgICAgIC8vIENvbnNpZGVyIHNldE9wdGlvbiBpbiBldmVudCBsaXN0ZW5lciBvZiBicnVzaFNlbGVjdCxcbiAgICAgIC8vIHdoZXJlIHVwZGF0aW5nIGNvdmVyIHdoZW4gY3JlYXRpbmcgc2hvdWxkIGJlIGZvcmJpZGRlbi5cbiAgICAgIGlmIChvbGRJbmRleCAhPSBudWxsICYmIG9sZENvdmVyc1tvbGRJbmRleF0gPT09IGNyZWF0aW5nQ292ZXIpIHtcbiAgICAgICAgbmV3Q292ZXJzW25ld0luZGV4XSA9IG9sZENvdmVyc1tvbGRJbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY292ZXIgPSBuZXdDb3ZlcnNbbmV3SW5kZXhdID0gb2xkSW5kZXggIT0gbnVsbCA/IChvbGRDb3ZlcnNbb2xkSW5kZXhdLl9fYnJ1c2hPcHRpb24gPSBuZXdCcnVzaEludGVybmFsLCBvbGRDb3ZlcnNbb2xkSW5kZXhdKSA6IGVuZENyZWF0aW5nKGNvbnRyb2xsZXIsIGNyZWF0ZUNvdmVyKGNvbnRyb2xsZXIsIG5ld0JydXNoSW50ZXJuYWwpKTtcbiAgICAgICAgdXBkYXRlQ292ZXJBZnRlckNyZWF0aW9uKGNvbnRyb2xsZXIsIGNvdmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlKG9sZEluZGV4KSB7XG4gICAgICBpZiAob2xkQ292ZXJzW29sZEluZGV4XSAhPT0gY3JlYXRpbmdDb3Zlcikge1xuICAgICAgICBjb250cm9sbGVyLmdyb3VwLnJlbW92ZShvbGRDb3ZlcnNbb2xkSW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIEJydXNoQ29udHJvbGxlci5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCF0aGlzLl9tb3VudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbmFibGVCcnVzaChmYWxzZSk7XG4gICAgLy8gY29udGFpbmVyIG1heSAncmVtb3ZlQWxsJyBvdXRzaWRlLlxuICAgIGNsZWFyQ292ZXJzKHRoaXMpO1xuICAgIHRoaXMuX3pyLnJlbW92ZSh0aGlzLmdyb3VwKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhpcy5fbW91bnRlZCA9IGZhbHNlOyAvLyBzaG91bGQgYmUgYXQgbGFzdC5cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIEJydXNoQ29udHJvbGxlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVubW91bnQoKTtcbiAgICB0aGlzLm9mZigpO1xuICB9O1xuICByZXR1cm4gQnJ1c2hDb250cm9sbGVyO1xufShFdmVudGZ1bCk7XG5mdW5jdGlvbiBjcmVhdGVDb3Zlcihjb250cm9sbGVyLCBicnVzaE9wdGlvbikge1xuICB2YXIgY292ZXIgPSBjb3ZlclJlbmRlcmVyc1ticnVzaE9wdGlvbi5icnVzaFR5cGVdLmNyZWF0ZUNvdmVyKGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uKTtcbiAgY292ZXIuX19icnVzaE9wdGlvbiA9IGJydXNoT3B0aW9uO1xuICB1cGRhdGVaKGNvdmVyLCBicnVzaE9wdGlvbik7XG4gIGNvbnRyb2xsZXIuZ3JvdXAuYWRkKGNvdmVyKTtcbiAgcmV0dXJuIGNvdmVyO1xufVxuZnVuY3Rpb24gZW5kQ3JlYXRpbmcoY29udHJvbGxlciwgY3JlYXRpbmdDb3Zlcikge1xuICB2YXIgY292ZXJSZW5kZXJlciA9IGdldENvdmVyUmVuZGVyZXIoY3JlYXRpbmdDb3Zlcik7XG4gIGlmIChjb3ZlclJlbmRlcmVyLmVuZENyZWF0aW5nKSB7XG4gICAgY292ZXJSZW5kZXJlci5lbmRDcmVhdGluZyhjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyKTtcbiAgICB1cGRhdGVaKGNyZWF0aW5nQ292ZXIsIGNyZWF0aW5nQ292ZXIuX19icnVzaE9wdGlvbik7XG4gIH1cbiAgcmV0dXJuIGNyZWF0aW5nQ292ZXI7XG59XG5mdW5jdGlvbiB1cGRhdGVDb3ZlclNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyKSB7XG4gIHZhciBicnVzaE9wdGlvbiA9IGNvdmVyLl9fYnJ1c2hPcHRpb247XG4gIGdldENvdmVyUmVuZGVyZXIoY292ZXIpLnVwZGF0ZUNvdmVyU2hhcGUoY29udHJvbGxlciwgY292ZXIsIGJydXNoT3B0aW9uLnJhbmdlLCBicnVzaE9wdGlvbik7XG59XG5mdW5jdGlvbiB1cGRhdGVaKGNvdmVyLCBicnVzaE9wdGlvbikge1xuICB2YXIgeiA9IGJydXNoT3B0aW9uLno7XG4gIHogPT0gbnVsbCAmJiAoeiA9IENPVkVSX1opO1xuICBjb3Zlci50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICBlbC56ID0gejtcbiAgICBlbC56MiA9IHo7IC8vIENvbnNpZGVyIGluIGdpdmVuIGNvbnRhaW5lci5cbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDb3ZlckFmdGVyQ3JlYXRpb24oY29udHJvbGxlciwgY292ZXIpIHtcbiAgZ2V0Q292ZXJSZW5kZXJlcihjb3ZlcikudXBkYXRlQ29tbW9uKGNvbnRyb2xsZXIsIGNvdmVyKTtcbiAgdXBkYXRlQ292ZXJTaGFwZShjb250cm9sbGVyLCBjb3Zlcik7XG59XG5mdW5jdGlvbiBnZXRDb3ZlclJlbmRlcmVyKGNvdmVyKSB7XG4gIHJldHVybiBjb3ZlclJlbmRlcmVyc1tjb3Zlci5fX2JydXNoT3B0aW9uLmJydXNoVHlwZV07XG59XG4vLyByZXR1cm4gdGFyZ2V0IHBhbmVsIG9yIGB0cnVlYCAobWVhbnMgZ2xvYmFsIHBhbmVsKVxuZnVuY3Rpb24gZ2V0UGFuZWxCeVBvaW50KGNvbnRyb2xsZXIsIGUsIGxvY2FsQ3Vyc29yUG9pbnQpIHtcbiAgdmFyIHBhbmVscyA9IGNvbnRyb2xsZXIuX3BhbmVscztcbiAgaWYgKCFwYW5lbHMpIHtcbiAgICByZXR1cm4gQlJVU0hfUEFORUxfR0xPQkFMOyAvLyBHbG9iYWwgcGFuZWxcbiAgfVxuICB2YXIgcGFuZWw7XG4gIHZhciB0cmFuc2Zvcm0gPSBjb250cm9sbGVyLl90cmFuc2Zvcm07XG4gIGVhY2gocGFuZWxzLCBmdW5jdGlvbiAocG4pIHtcbiAgICBwbi5pc1RhcmdldEJ5Q3Vyc29yKGUsIGxvY2FsQ3Vyc29yUG9pbnQsIHRyYW5zZm9ybSkgJiYgKHBhbmVsID0gcG4pO1xuICB9KTtcbiAgcmV0dXJuIHBhbmVsO1xufVxuLy8gUmV0dXJuIGEgcGFuZWwgb3IgdHJ1ZVxuZnVuY3Rpb24gZ2V0UGFuZWxCeUNvdmVyKGNvbnRyb2xsZXIsIGNvdmVyKSB7XG4gIHZhciBwYW5lbHMgPSBjb250cm9sbGVyLl9wYW5lbHM7XG4gIGlmICghcGFuZWxzKSB7XG4gICAgcmV0dXJuIEJSVVNIX1BBTkVMX0dMT0JBTDsgLy8gR2xvYmFsIHBhbmVsXG4gIH1cbiAgdmFyIHBhbmVsSWQgPSBjb3Zlci5fX2JydXNoT3B0aW9uLnBhbmVsSWQ7XG4gIC8vIFVzZXIgbWF5IGdpdmUgY292ZXIgd2l0aG91dCBjb29yZCBzeXMgaW5mbyxcbiAgLy8gd2hpY2ggaXMgdGhlbiB0cmVhdGVkIGFzIGdsb2JhbCBwYW5lbC5cbiAgcmV0dXJuIHBhbmVsSWQgIT0gbnVsbCA/IHBhbmVsc1twYW5lbElkXSA6IEJSVVNIX1BBTkVMX0dMT0JBTDtcbn1cbmZ1bmN0aW9uIGNsZWFyQ292ZXJzKGNvbnRyb2xsZXIpIHtcbiAgdmFyIGNvdmVycyA9IGNvbnRyb2xsZXIuX2NvdmVycztcbiAgdmFyIG9yaWdpbmFsTGVuZ3RoID0gY292ZXJzLmxlbmd0aDtcbiAgZWFjaChjb3ZlcnMsIGZ1bmN0aW9uIChjb3Zlcikge1xuICAgIGNvbnRyb2xsZXIuZ3JvdXAucmVtb3ZlKGNvdmVyKTtcbiAgfSwgY29udHJvbGxlcik7XG4gIGNvdmVycy5sZW5ndGggPSAwO1xuICByZXR1cm4gISFvcmlnaW5hbExlbmd0aDtcbn1cbmZ1bmN0aW9uIHRyaWdnZXIoY29udHJvbGxlciwgb3B0KSB7XG4gIHZhciBhcmVhcyA9IG1hcChjb250cm9sbGVyLl9jb3ZlcnMsIGZ1bmN0aW9uIChjb3Zlcikge1xuICAgIHZhciBicnVzaE9wdGlvbiA9IGNvdmVyLl9fYnJ1c2hPcHRpb247XG4gICAgdmFyIHJhbmdlID0gY2xvbmUoYnJ1c2hPcHRpb24ucmFuZ2UpO1xuICAgIHJldHVybiB7XG4gICAgICBicnVzaFR5cGU6IGJydXNoT3B0aW9uLmJydXNoVHlwZSxcbiAgICAgIHBhbmVsSWQ6IGJydXNoT3B0aW9uLnBhbmVsSWQsXG4gICAgICByYW5nZTogcmFuZ2VcbiAgICB9O1xuICB9KTtcbiAgY29udHJvbGxlci50cmlnZ2VyKCdicnVzaCcsIHtcbiAgICBhcmVhczogYXJlYXMsXG4gICAgaXNFbmQ6ICEhb3B0LmlzRW5kLFxuICAgIHJlbW92ZU9uQ2xpY2s6ICEhb3B0LnJlbW92ZU9uQ2xpY2tcbiAgfSk7XG59XG5mdW5jdGlvbiBzaG91bGRTaG93Q292ZXIoY29udHJvbGxlcikge1xuICB2YXIgdHJhY2sgPSBjb250cm9sbGVyLl90cmFjaztcbiAgaWYgKCF0cmFjay5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHAyID0gdHJhY2tbdHJhY2subGVuZ3RoIC0gMV07XG4gIHZhciBwMSA9IHRyYWNrWzBdO1xuICB2YXIgZHggPSBwMlswXSAtIHAxWzBdO1xuICB2YXIgZHkgPSBwMlsxXSAtIHAxWzFdO1xuICB2YXIgZGlzdCA9IG1hdGhQb3coZHggKiBkeCArIGR5ICogZHksIDAuNSk7XG4gIHJldHVybiBkaXN0ID4gVU5TRUxFQ1RfVEhSRVNIT0xEO1xufVxuZnVuY3Rpb24gZ2V0VHJhY2tFbmRzKHRyYWNrKSB7XG4gIHZhciB0YWlsID0gdHJhY2subGVuZ3RoIC0gMTtcbiAgdGFpbCA8IDAgJiYgKHRhaWwgPSAwKTtcbiAgcmV0dXJuIFt0cmFja1swXSwgdHJhY2tbdGFpbF1dO1xufVxuO1xuZnVuY3Rpb24gY3JlYXRlQmFzZVJlY3RDb3ZlcihyZWN0UmFuZ2VDb252ZXJ0ZXIsIGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uLCBlZGdlTmFtZVNlcXVlbmNlcykge1xuICB2YXIgY292ZXIgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICBjb3Zlci5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgbmFtZTogJ21haW4nLFxuICAgIHN0eWxlOiBtYWtlU3R5bGUoYnJ1c2hPcHRpb24pLFxuICAgIHNpbGVudDogdHJ1ZSxcbiAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgY3Vyc29yOiAnbW92ZScsXG4gICAgZHJpZnQ6IGN1cnJ5KGRyaWZ0UmVjdCwgcmVjdFJhbmdlQ29udmVydGVyLCBjb250cm9sbGVyLCBjb3ZlciwgWyduJywgJ3MnLCAndycsICdlJ10pLFxuICAgIG9uZHJhZ2VuZDogY3VycnkodHJpZ2dlciwgY29udHJvbGxlciwge1xuICAgICAgaXNFbmQ6IHRydWVcbiAgICB9KVxuICB9KSk7XG4gIGVhY2goZWRnZU5hbWVTZXF1ZW5jZXMsIGZ1bmN0aW9uIChuYW1lU2VxdWVuY2UpIHtcbiAgICBjb3Zlci5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICBuYW1lOiBuYW1lU2VxdWVuY2Uuam9pbignJyksXG4gICAgICBzdHlsZToge1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9LFxuICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgaW52aXNpYmxlOiB0cnVlLFxuICAgICAgZHJpZnQ6IGN1cnJ5KGRyaWZ0UmVjdCwgcmVjdFJhbmdlQ29udmVydGVyLCBjb250cm9sbGVyLCBjb3ZlciwgbmFtZVNlcXVlbmNlKSxcbiAgICAgIG9uZHJhZ2VuZDogY3VycnkodHJpZ2dlciwgY29udHJvbGxlciwge1xuICAgICAgICBpc0VuZDogdHJ1ZVxuICAgICAgfSlcbiAgICB9KSk7XG4gIH0pO1xuICByZXR1cm4gY292ZXI7XG59XG5mdW5jdGlvbiB1cGRhdGVCYXNlUmVjdChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pIHtcbiAgdmFyIGxpbmVXaWR0aCA9IGJydXNoT3B0aW9uLmJydXNoU3R5bGUubGluZVdpZHRoIHx8IDA7XG4gIHZhciBoYW5kbGVTaXplID0gbWF0aE1heChsaW5lV2lkdGgsIE1JTl9SRVNJWkVfTElORV9XSURUSCk7XG4gIHZhciB4ID0gbG9jYWxSYW5nZVswXVswXTtcbiAgdmFyIHkgPSBsb2NhbFJhbmdlWzFdWzBdO1xuICB2YXIgeGEgPSB4IC0gbGluZVdpZHRoIC8gMjtcbiAgdmFyIHlhID0geSAtIGxpbmVXaWR0aCAvIDI7XG4gIHZhciB4MiA9IGxvY2FsUmFuZ2VbMF1bMV07XG4gIHZhciB5MiA9IGxvY2FsUmFuZ2VbMV1bMV07XG4gIHZhciB4MmEgPSB4MiAtIGhhbmRsZVNpemUgKyBsaW5lV2lkdGggLyAyO1xuICB2YXIgeTJhID0geTIgLSBoYW5kbGVTaXplICsgbGluZVdpZHRoIC8gMjtcbiAgdmFyIHdpZHRoID0geDIgLSB4O1xuICB2YXIgaGVpZ2h0ID0geTIgLSB5O1xuICB2YXIgd2lkdGhhID0gd2lkdGggKyBsaW5lV2lkdGg7XG4gIHZhciBoZWlnaHRhID0gaGVpZ2h0ICsgbGluZVdpZHRoO1xuICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdtYWluJywgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIGlmIChicnVzaE9wdGlvbi50cmFuc2Zvcm1hYmxlKSB7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAndycsIHhhLCB5YSwgaGFuZGxlU2l6ZSwgaGVpZ2h0YSk7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnZScsIHgyYSwgeWEsIGhhbmRsZVNpemUsIGhlaWdodGEpO1xuICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ24nLCB4YSwgeWEsIHdpZHRoYSwgaGFuZGxlU2l6ZSk7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAncycsIHhhLCB5MmEsIHdpZHRoYSwgaGFuZGxlU2l6ZSk7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnbncnLCB4YSwgeWEsIGhhbmRsZVNpemUsIGhhbmRsZVNpemUpO1xuICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ25lJywgeDJhLCB5YSwgaGFuZGxlU2l6ZSwgaGFuZGxlU2l6ZSk7XG4gICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnc3cnLCB4YSwgeTJhLCBoYW5kbGVTaXplLCBoYW5kbGVTaXplKTtcbiAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdzZScsIHgyYSwgeTJhLCBoYW5kbGVTaXplLCBoYW5kbGVTaXplKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQ29tbW9uKGNvbnRyb2xsZXIsIGNvdmVyKSB7XG4gIHZhciBicnVzaE9wdGlvbiA9IGNvdmVyLl9fYnJ1c2hPcHRpb247XG4gIHZhciB0cmFuc2Zvcm1hYmxlID0gYnJ1c2hPcHRpb24udHJhbnNmb3JtYWJsZTtcbiAgdmFyIG1haW5FbCA9IGNvdmVyLmNoaWxkQXQoMCk7XG4gIG1haW5FbC51c2VTdHlsZShtYWtlU3R5bGUoYnJ1c2hPcHRpb24pKTtcbiAgbWFpbkVsLmF0dHIoe1xuICAgIHNpbGVudDogIXRyYW5zZm9ybWFibGUsXG4gICAgY3Vyc29yOiB0cmFuc2Zvcm1hYmxlID8gJ21vdmUnIDogJ2RlZmF1bHQnXG4gIH0pO1xuICBlYWNoKFtbJ3cnXSwgWydlJ10sIFsnbiddLCBbJ3MnXSwgWydzJywgJ2UnXSwgWydzJywgJ3cnXSwgWyduJywgJ2UnXSwgWyduJywgJ3cnXV0sIGZ1bmN0aW9uIChuYW1lU2VxdWVuY2UpIHtcbiAgICB2YXIgZWwgPSBjb3Zlci5jaGlsZE9mTmFtZShuYW1lU2VxdWVuY2Uuam9pbignJykpO1xuICAgIHZhciBnbG9iYWxEaXIgPSBuYW1lU2VxdWVuY2UubGVuZ3RoID09PSAxID8gZ2V0R2xvYmFsRGlyZWN0aW9uMShjb250cm9sbGVyLCBuYW1lU2VxdWVuY2VbMF0pIDogZ2V0R2xvYmFsRGlyZWN0aW9uMihjb250cm9sbGVyLCBuYW1lU2VxdWVuY2UpO1xuICAgIGVsICYmIGVsLmF0dHIoe1xuICAgICAgc2lsZW50OiAhdHJhbnNmb3JtYWJsZSxcbiAgICAgIGludmlzaWJsZTogIXRyYW5zZm9ybWFibGUsXG4gICAgICBjdXJzb3I6IHRyYW5zZm9ybWFibGUgPyBDVVJTT1JfTUFQW2dsb2JhbERpcl0gKyAnLXJlc2l6ZScgOiBudWxsXG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCBuYW1lLCB4LCB5LCB3LCBoKSB7XG4gIHZhciBlbCA9IGNvdmVyLmNoaWxkT2ZOYW1lKG5hbWUpO1xuICBlbCAmJiBlbC5zZXRTaGFwZShwb2ludHNUb1JlY3QoY2xpcEJ5UGFuZWwoY29udHJvbGxlciwgY292ZXIsIFtbeCwgeV0sIFt4ICsgdywgeSArIGhdXSkpKTtcbn1cbmZ1bmN0aW9uIG1ha2VTdHlsZShicnVzaE9wdGlvbikge1xuICByZXR1cm4gZGVmYXVsdHMoe1xuICAgIHN0cm9rZU5vU2NhbGU6IHRydWVcbiAgfSwgYnJ1c2hPcHRpb24uYnJ1c2hTdHlsZSk7XG59XG5mdW5jdGlvbiBmb3JtYXRSZWN0UmFuZ2UoeCwgeSwgeDIsIHkyKSB7XG4gIHZhciBtaW4gPSBbbWF0aE1pbih4LCB4MiksIG1hdGhNaW4oeSwgeTIpXTtcbiAgdmFyIG1heCA9IFttYXRoTWF4KHgsIHgyKSwgbWF0aE1heCh5LCB5MildO1xuICByZXR1cm4gW1ttaW5bMF0sIG1heFswXV0sIFttaW5bMV0sIG1heFsxXV0gLy8geSByYW5nZVxuICBdO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKGNvbnRyb2xsZXIpIHtcbiAgcmV0dXJuIGdyYXBoaWMuZ2V0VHJhbnNmb3JtKGNvbnRyb2xsZXIuZ3JvdXApO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsRGlyZWN0aW9uMShjb250cm9sbGVyLCBsb2NhbERpck5hbWUpIHtcbiAgdmFyIG1hcCA9IHtcbiAgICB3OiAnbGVmdCcsXG4gICAgZTogJ3JpZ2h0JyxcbiAgICBuOiAndG9wJyxcbiAgICBzOiAnYm90dG9tJ1xuICB9O1xuICB2YXIgaW52ZXJzZU1hcCA9IHtcbiAgICBsZWZ0OiAndycsXG4gICAgcmlnaHQ6ICdlJyxcbiAgICB0b3A6ICduJyxcbiAgICBib3R0b206ICdzJ1xuICB9O1xuICB2YXIgZGlyID0gZ3JhcGhpYy50cmFuc2Zvcm1EaXJlY3Rpb24obWFwW2xvY2FsRGlyTmFtZV0sIGdldFRyYW5zZm9ybShjb250cm9sbGVyKSk7XG4gIHJldHVybiBpbnZlcnNlTWFwW2Rpcl07XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxEaXJlY3Rpb24yKGNvbnRyb2xsZXIsIGxvY2FsRGlyTmFtZVNlcSkge1xuICB2YXIgZ2xvYmFsRGlyID0gW2dldEdsb2JhbERpcmVjdGlvbjEoY29udHJvbGxlciwgbG9jYWxEaXJOYW1lU2VxWzBdKSwgZ2V0R2xvYmFsRGlyZWN0aW9uMShjb250cm9sbGVyLCBsb2NhbERpck5hbWVTZXFbMV0pXTtcbiAgKGdsb2JhbERpclswXSA9PT0gJ2UnIHx8IGdsb2JhbERpclswXSA9PT0gJ3cnKSAmJiBnbG9iYWxEaXIucmV2ZXJzZSgpO1xuICByZXR1cm4gZ2xvYmFsRGlyLmpvaW4oJycpO1xufVxuZnVuY3Rpb24gZHJpZnRSZWN0KHJlY3RSYW5nZUNvbnZlcnRlciwgY29udHJvbGxlciwgY292ZXIsIGRpck5hbWVTZXF1ZW5jZSwgZHgsIGR5KSB7XG4gIHZhciBicnVzaE9wdGlvbiA9IGNvdmVyLl9fYnJ1c2hPcHRpb247XG4gIHZhciByZWN0UmFuZ2UgPSByZWN0UmFuZ2VDb252ZXJ0ZXIudG9SZWN0UmFuZ2UoYnJ1c2hPcHRpb24ucmFuZ2UpO1xuICB2YXIgbG9jYWxEZWx0YSA9IHRvTG9jYWxEZWx0YShjb250cm9sbGVyLCBkeCwgZHkpO1xuICBlYWNoKGRpck5hbWVTZXF1ZW5jZSwgZnVuY3Rpb24gKGRpck5hbWUpIHtcbiAgICB2YXIgaW5kID0gRElSRUNUSU9OX01BUFtkaXJOYW1lXTtcbiAgICByZWN0UmFuZ2VbaW5kWzBdXVtpbmRbMV1dICs9IGxvY2FsRGVsdGFbaW5kWzBdXTtcbiAgfSk7XG4gIGJydXNoT3B0aW9uLnJhbmdlID0gcmVjdFJhbmdlQ29udmVydGVyLmZyb21SZWN0UmFuZ2UoZm9ybWF0UmVjdFJhbmdlKHJlY3RSYW5nZVswXVswXSwgcmVjdFJhbmdlWzFdWzBdLCByZWN0UmFuZ2VbMF1bMV0sIHJlY3RSYW5nZVsxXVsxXSkpO1xuICB1cGRhdGVDb3ZlckFmdGVyQ3JlYXRpb24oY29udHJvbGxlciwgY292ZXIpO1xuICB0cmlnZ2VyKGNvbnRyb2xsZXIsIHtcbiAgICBpc0VuZDogZmFsc2VcbiAgfSk7XG59XG5mdW5jdGlvbiBkcmlmdFBvbHlnb24oY29udHJvbGxlciwgY292ZXIsIGR4LCBkeSkge1xuICB2YXIgcmFuZ2UgPSBjb3Zlci5fX2JydXNoT3B0aW9uLnJhbmdlO1xuICB2YXIgbG9jYWxEZWx0YSA9IHRvTG9jYWxEZWx0YShjb250cm9sbGVyLCBkeCwgZHkpO1xuICBlYWNoKHJhbmdlLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICBwb2ludFswXSArPSBsb2NhbERlbHRhWzBdO1xuICAgIHBvaW50WzFdICs9IGxvY2FsRGVsdGFbMV07XG4gIH0pO1xuICB1cGRhdGVDb3ZlckFmdGVyQ3JlYXRpb24oY29udHJvbGxlciwgY292ZXIpO1xuICB0cmlnZ2VyKGNvbnRyb2xsZXIsIHtcbiAgICBpc0VuZDogZmFsc2VcbiAgfSk7XG59XG5mdW5jdGlvbiB0b0xvY2FsRGVsdGEoY29udHJvbGxlciwgZHgsIGR5KSB7XG4gIHZhciB0aGlzR3JvdXAgPSBjb250cm9sbGVyLmdyb3VwO1xuICB2YXIgbG9jYWxEID0gdGhpc0dyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbChkeCwgZHkpO1xuICB2YXIgbG9jYWxaZXJvID0gdGhpc0dyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCgwLCAwKTtcbiAgcmV0dXJuIFtsb2NhbERbMF0gLSBsb2NhbFplcm9bMF0sIGxvY2FsRFsxXSAtIGxvY2FsWmVyb1sxXV07XG59XG5mdW5jdGlvbiBjbGlwQnlQYW5lbChjb250cm9sbGVyLCBjb3ZlciwgZGF0YSkge1xuICB2YXIgcGFuZWwgPSBnZXRQYW5lbEJ5Q292ZXIoY29udHJvbGxlciwgY292ZXIpO1xuICByZXR1cm4gcGFuZWwgJiYgcGFuZWwgIT09IEJSVVNIX1BBTkVMX0dMT0JBTCA/IHBhbmVsLmNsaXBQYXRoKGRhdGEsIGNvbnRyb2xsZXIuX3RyYW5zZm9ybSkgOiBjbG9uZShkYXRhKTtcbn1cbmZ1bmN0aW9uIHBvaW50c1RvUmVjdChwb2ludHMpIHtcbiAgdmFyIHhtaW4gPSBtYXRoTWluKHBvaW50c1swXVswXSwgcG9pbnRzWzFdWzBdKTtcbiAgdmFyIHltaW4gPSBtYXRoTWluKHBvaW50c1swXVsxXSwgcG9pbnRzWzFdWzFdKTtcbiAgdmFyIHhtYXggPSBtYXRoTWF4KHBvaW50c1swXVswXSwgcG9pbnRzWzFdWzBdKTtcbiAgdmFyIHltYXggPSBtYXRoTWF4KHBvaW50c1swXVsxXSwgcG9pbnRzWzFdWzFdKTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4bWluLFxuICAgIHk6IHltaW4sXG4gICAgd2lkdGg6IHhtYXggLSB4bWluLFxuICAgIGhlaWdodDogeW1heCAtIHltaW5cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc2V0Q3Vyc29yKGNvbnRyb2xsZXIsIGUsIGxvY2FsQ3Vyc29yUG9pbnQpIHtcbiAgaWYgKFxuICAvLyBDaGVjayBhY3RpdmVcbiAgIWNvbnRyb2xsZXIuX2JydXNoVHlwZVxuICAvLyByZXNldEN1cnNvciBzaG91bGQgYmUgYWx3YXlzIGNhbGxlZCB3aGVuIG1vdXNlIGlzIGluIHpyIGFyZWEsXG4gIC8vIGJ1dCBub3QgY2FsbGVkIHdoZW4gbW91c2UgaXMgb3V0IG9mIHpyIGFyZWEgdG8gYXZvaWQgYmFkIGluZmx1ZW5jZVxuICAvLyBpZiBgbW91c2Vtb3ZlYCwgYG1vdXNldXBgIGFyZSB0cmlnZ2VyZWQgZnJvbSBgZG9jdW1lbnRgIGV2ZW50LlxuICB8fCBpc091dHNpZGVackFyZWEoY29udHJvbGxlciwgZS5vZmZzZXRYLCBlLm9mZnNldFkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB6ciA9IGNvbnRyb2xsZXIuX3pyO1xuICB2YXIgY292ZXJzID0gY29udHJvbGxlci5fY292ZXJzO1xuICB2YXIgY3VyclBhbmVsID0gZ2V0UGFuZWxCeVBvaW50KGNvbnRyb2xsZXIsIGUsIGxvY2FsQ3Vyc29yUG9pbnQpO1xuICAvLyBDaGVjayB3aGV0aGVyIGluIGNvdmVycy5cbiAgaWYgKCFjb250cm9sbGVyLl9kcmFnZ2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY292ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnJ1c2hPcHRpb24gPSBjb3ZlcnNbaV0uX19icnVzaE9wdGlvbjtcbiAgICAgIGlmIChjdXJyUGFuZWwgJiYgKGN1cnJQYW5lbCA9PT0gQlJVU0hfUEFORUxfR0xPQkFMIHx8IGJydXNoT3B0aW9uLnBhbmVsSWQgPT09IGN1cnJQYW5lbC5wYW5lbElkKSAmJiBjb3ZlclJlbmRlcmVyc1ticnVzaE9wdGlvbi5icnVzaFR5cGVdLmNvbnRhaW4oY292ZXJzW2ldLCBsb2NhbEN1cnNvclBvaW50WzBdLCBsb2NhbEN1cnNvclBvaW50WzFdKSkge1xuICAgICAgICAvLyBVc2UgY3Vyc29yIHN0eWxlIHNldCBvbiBjb3Zlci5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjdXJyUGFuZWwgJiYgenIuc2V0Q3Vyc29yU3R5bGUoJ2Nyb3NzaGFpcicpO1xufVxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xuICB2YXIgcmF3RSA9IGUuZXZlbnQ7XG4gIHJhd0UucHJldmVudERlZmF1bHQgJiYgcmF3RS5wcmV2ZW50RGVmYXVsdCgpO1xufVxuZnVuY3Rpb24gbWFpblNoYXBlQ29udGFpbihjb3ZlciwgeCwgeSkge1xuICByZXR1cm4gY292ZXIuY2hpbGRPZk5hbWUoJ21haW4nKS5jb250YWluKHgsIHkpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ292ZXJCeU1vdXNlKGNvbnRyb2xsZXIsIGUsIGxvY2FsQ3Vyc29yUG9pbnQsIGlzRW5kKSB7XG4gIHZhciBjcmVhdGluZ0NvdmVyID0gY29udHJvbGxlci5fY3JlYXRpbmdDb3ZlcjtcbiAgdmFyIHBhbmVsID0gY29udHJvbGxlci5fY3JlYXRpbmdQYW5lbDtcbiAgdmFyIHRoaXNCcnVzaE9wdGlvbiA9IGNvbnRyb2xsZXIuX2JydXNoT3B0aW9uO1xuICB2YXIgZXZlbnRQYXJhbXM7XG4gIGNvbnRyb2xsZXIuX3RyYWNrLnB1c2gobG9jYWxDdXJzb3JQb2ludC5zbGljZSgpKTtcbiAgaWYgKHNob3VsZFNob3dDb3Zlcihjb250cm9sbGVyKSB8fCBjcmVhdGluZ0NvdmVyKSB7XG4gICAgaWYgKHBhbmVsICYmICFjcmVhdGluZ0NvdmVyKSB7XG4gICAgICB0aGlzQnJ1c2hPcHRpb24uYnJ1c2hNb2RlID09PSAnc2luZ2xlJyAmJiBjbGVhckNvdmVycyhjb250cm9sbGVyKTtcbiAgICAgIHZhciBicnVzaE9wdGlvbiA9IGNsb25lKHRoaXNCcnVzaE9wdGlvbik7XG4gICAgICBicnVzaE9wdGlvbi5icnVzaFR5cGUgPSBkZXRlcm1pbmVCcnVzaFR5cGUoYnJ1c2hPcHRpb24uYnJ1c2hUeXBlLCBwYW5lbCk7XG4gICAgICBicnVzaE9wdGlvbi5wYW5lbElkID0gcGFuZWwgPT09IEJSVVNIX1BBTkVMX0dMT0JBTCA/IG51bGwgOiBwYW5lbC5wYW5lbElkO1xuICAgICAgY3JlYXRpbmdDb3ZlciA9IGNvbnRyb2xsZXIuX2NyZWF0aW5nQ292ZXIgPSBjcmVhdGVDb3Zlcihjb250cm9sbGVyLCBicnVzaE9wdGlvbik7XG4gICAgICBjb250cm9sbGVyLl9jb3ZlcnMucHVzaChjcmVhdGluZ0NvdmVyKTtcbiAgICB9XG4gICAgaWYgKGNyZWF0aW5nQ292ZXIpIHtcbiAgICAgIHZhciBjb3ZlclJlbmRlcmVyID0gY292ZXJSZW5kZXJlcnNbZGV0ZXJtaW5lQnJ1c2hUeXBlKGNvbnRyb2xsZXIuX2JydXNoVHlwZSwgcGFuZWwpXTtcbiAgICAgIHZhciBjb3ZlckJydXNoT3B0aW9uID0gY3JlYXRpbmdDb3Zlci5fX2JydXNoT3B0aW9uO1xuICAgICAgY292ZXJCcnVzaE9wdGlvbi5yYW5nZSA9IGNvdmVyUmVuZGVyZXIuZ2V0Q3JlYXRpbmdSYW5nZShjbGlwQnlQYW5lbChjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyLCBjb250cm9sbGVyLl90cmFjaykpO1xuICAgICAgaWYgKGlzRW5kKSB7XG4gICAgICAgIGVuZENyZWF0aW5nKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpO1xuICAgICAgICBjb3ZlclJlbmRlcmVyLnVwZGF0ZUNvbW1vbihjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZUNvdmVyU2hhcGUoY29udHJvbGxlciwgY3JlYXRpbmdDb3Zlcik7XG4gICAgICBldmVudFBhcmFtcyA9IHtcbiAgICAgICAgaXNFbmQ6IGlzRW5kXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VuZCAmJiB0aGlzQnJ1c2hPcHRpb24uYnJ1c2hNb2RlID09PSAnc2luZ2xlJyAmJiB0aGlzQnJ1c2hPcHRpb24ucmVtb3ZlT25DbGljaykge1xuICAgIC8vIEhlbHAgdXNlciB0byByZW1vdmUgY292ZXJzIGVhc2lseSwgb25seSBieSBhIHRpbnkgZHJhZywgaW4gJ3NpbmdsZScgbW9kZS5cbiAgICAvLyBCdXQgYSBzaW5nbGUgY2xpY2sgZG8gbm90IGNsZWFyIGNvdmVycywgYmVjYXVzZSB1c2VyIG1heSBoYXZlIGNhc3VhbFxuICAgIC8vIGNsaWNrcyAoZm9yIGV4YW1wbGUsIGNsaWNrIG9uIG90aGVyIGNvbXBvbmVudCBhbmQgZG8gbm90IGV4cGVjdCBjb3ZlcnNcbiAgICAvLyBkaXNhcHBlYXIpLlxuICAgIC8vIE9ubHkgc29tZSBjb3ZlciByZW1vdmVkLCB0cmlnZ2VyIGFjdGlvbiwgYnV0IG5vdCBldmVyeSBjbGljayB0cmlnZ2VyIGFjdGlvbi5cbiAgICBpZiAoZ2V0UGFuZWxCeVBvaW50KGNvbnRyb2xsZXIsIGUsIGxvY2FsQ3Vyc29yUG9pbnQpICYmIGNsZWFyQ292ZXJzKGNvbnRyb2xsZXIpKSB7XG4gICAgICBldmVudFBhcmFtcyA9IHtcbiAgICAgICAgaXNFbmQ6IGlzRW5kLFxuICAgICAgICByZW1vdmVPbkNsaWNrOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRQYXJhbXM7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVCcnVzaFR5cGUoYnJ1c2hUeXBlLCBwYW5lbCkge1xuICBpZiAoYnJ1c2hUeXBlID09PSAnYXV0bycpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0KHBhbmVsICYmIHBhbmVsLmRlZmF1bHRCcnVzaFR5cGUsICdNVVNUIGhhdmUgZGVmYXVsdEJydXNoVHlwZSB3aGVuIGJydXNoVHlwZSBpcyBcImF0dW9cIicpO1xuICAgIH1cbiAgICByZXR1cm4gcGFuZWwuZGVmYXVsdEJydXNoVHlwZTtcbiAgfVxuICByZXR1cm4gYnJ1c2hUeXBlO1xufVxudmFyIHBvaW50ZXJIYW5kbGVycyA9IHtcbiAgbW91c2Vkb3duOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmICh0aGlzLl9kcmFnZ2luZykge1xuICAgICAgLy8gSW4gY2FzZSBzb21lIGJyb3dzZXIgZG8gbm90IHN1cHBvcnQgZ2xvYmFsT3V0LFxuICAgICAgLy8gYW5kIHJlbGVhc2UgbW91c2Ugb3V0IHNpZGUgdGhlIGJyb3dzZXIuXG4gICAgICBoYW5kbGVEcmFnRW5kKHRoaXMsIGUpO1xuICAgIH0gZWxzZSBpZiAoIWUudGFyZ2V0IHx8ICFlLnRhcmdldC5kcmFnZ2FibGUpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgdmFyIGxvY2FsQ3Vyc29yUG9pbnQgPSB0aGlzLmdyb3VwLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG4gICAgICB0aGlzLl9jcmVhdGluZ0NvdmVyID0gbnVsbDtcbiAgICAgIHZhciBwYW5lbCA9IHRoaXMuX2NyZWF0aW5nUGFuZWwgPSBnZXRQYW5lbEJ5UG9pbnQodGhpcywgZSwgbG9jYWxDdXJzb3JQb2ludCk7XG4gICAgICBpZiAocGFuZWwpIHtcbiAgICAgICAgdGhpcy5fZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl90cmFjayA9IFtsb2NhbEN1cnNvclBvaW50LnNsaWNlKCldO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciB4ID0gZS5vZmZzZXRYO1xuICAgIHZhciB5ID0gZS5vZmZzZXRZO1xuICAgIHZhciBsb2NhbEN1cnNvclBvaW50ID0gdGhpcy5ncm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgcmVzZXRDdXJzb3IodGhpcywgZSwgbG9jYWxDdXJzb3JQb2ludCk7XG4gICAgaWYgKHRoaXMuX2RyYWdnaW5nKSB7XG4gICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIHZhciBldmVudFBhcmFtcyA9IHVwZGF0ZUNvdmVyQnlNb3VzZSh0aGlzLCBlLCBsb2NhbEN1cnNvclBvaW50LCBmYWxzZSk7XG4gICAgICBldmVudFBhcmFtcyAmJiB0cmlnZ2VyKHRoaXMsIGV2ZW50UGFyYW1zKTtcbiAgICB9XG4gIH0sXG4gIG1vdXNldXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgaGFuZGxlRHJhZ0VuZCh0aGlzLCBlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGhhbmRsZURyYWdFbmQoY29udHJvbGxlciwgZSkge1xuICBpZiAoY29udHJvbGxlci5fZHJhZ2dpbmcpIHtcbiAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgICB2YXIgeSA9IGUub2Zmc2V0WTtcbiAgICB2YXIgbG9jYWxDdXJzb3JQb2ludCA9IGNvbnRyb2xsZXIuZ3JvdXAudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgIHZhciBldmVudFBhcmFtcyA9IHVwZGF0ZUNvdmVyQnlNb3VzZShjb250cm9sbGVyLCBlLCBsb2NhbEN1cnNvclBvaW50LCB0cnVlKTtcbiAgICBjb250cm9sbGVyLl9kcmFnZ2luZyA9IGZhbHNlO1xuICAgIGNvbnRyb2xsZXIuX3RyYWNrID0gW107XG4gICAgY29udHJvbGxlci5fY3JlYXRpbmdDb3ZlciA9IG51bGw7XG4gICAgLy8gdHJpZ2dlciBldmVudCBzaG91bGQgYmUgYXQgZmluYWwsIGFmdGVyIHByb2NlZHVyZSB3aWxsIGJlIG5lc3RlZC5cbiAgICBldmVudFBhcmFtcyAmJiB0cmlnZ2VyKGNvbnRyb2xsZXIsIGV2ZW50UGFyYW1zKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNPdXRzaWRlWnJBcmVhKGNvbnRyb2xsZXIsIHgsIHkpIHtcbiAgdmFyIHpyID0gY29udHJvbGxlci5fenI7XG4gIHJldHVybiB4IDwgMCB8fCB4ID4genIuZ2V0V2lkdGgoKSB8fCB5IDwgMCB8fCB5ID4genIuZ2V0SGVpZ2h0KCk7XG59XG4vKipcclxuICoga2V5OiBicnVzaFR5cGVcclxuICovXG52YXIgY292ZXJSZW5kZXJlcnMgPSB7XG4gIGxpbmVYOiBnZXRMaW5lUmVuZGVyZXIoMCksXG4gIGxpbmVZOiBnZXRMaW5lUmVuZGVyZXIoMSksXG4gIHJlY3Q6IHtcbiAgICBjcmVhdGVDb3ZlcjogZnVuY3Rpb24gKGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uKSB7XG4gICAgICBmdW5jdGlvbiByZXR1cm5JbnB1dChyYW5nZSkge1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlQmFzZVJlY3RDb3Zlcih7XG4gICAgICAgIHRvUmVjdFJhbmdlOiByZXR1cm5JbnB1dCxcbiAgICAgICAgZnJvbVJlY3RSYW5nZTogcmV0dXJuSW5wdXRcbiAgICAgIH0sIGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uLCBbWyd3J10sIFsnZSddLCBbJ24nXSwgWydzJ10sIFsncycsICdlJ10sIFsncycsICd3J10sIFsnbicsICdlJ10sIFsnbicsICd3J11dKTtcbiAgICB9LFxuICAgIGdldENyZWF0aW5nUmFuZ2U6IGZ1bmN0aW9uIChsb2NhbFRyYWNrKSB7XG4gICAgICB2YXIgZW5kcyA9IGdldFRyYWNrRW5kcyhsb2NhbFRyYWNrKTtcbiAgICAgIHJldHVybiBmb3JtYXRSZWN0UmFuZ2UoZW5kc1sxXVswXSwgZW5kc1sxXVsxXSwgZW5kc1swXVswXSwgZW5kc1swXVsxXSk7XG4gICAgfSxcbiAgICB1cGRhdGVDb3ZlclNoYXBlOiBmdW5jdGlvbiAoY29udHJvbGxlciwgY292ZXIsIGxvY2FsUmFuZ2UsIGJydXNoT3B0aW9uKSB7XG4gICAgICB1cGRhdGVCYXNlUmVjdChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pO1xuICAgIH0sXG4gICAgdXBkYXRlQ29tbW9uOiB1cGRhdGVDb21tb24sXG4gICAgY29udGFpbjogbWFpblNoYXBlQ29udGFpblxuICB9LFxuICBwb2x5Z29uOiB7XG4gICAgY3JlYXRlQ292ZXI6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBicnVzaE9wdGlvbikge1xuICAgICAgdmFyIGNvdmVyID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICAgIC8vIERvIG5vdCB1c2UgZ3JhcGhpYy5Qb2x5Z29uIGJlY2F1c2UgZ3JhcGhpYy5Qb2x5bGluZSBkbyBub3QgY2xvc2UgdGhlXG4gICAgICAvLyBib3JkZXIgb2YgdGhlIHNoYXBlIHdoZW4gZHJhd2luZywgd2hpY2ggaXMgYSBiZXR0ZXIgZXhwZXJpZW5jZSBmb3IgdXNlci5cbiAgICAgIGNvdmVyLmFkZChuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7XG4gICAgICAgIG5hbWU6ICdtYWluJyxcbiAgICAgICAgc3R5bGU6IG1ha2VTdHlsZShicnVzaE9wdGlvbiksXG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGNvdmVyO1xuICAgIH0sXG4gICAgZ2V0Q3JlYXRpbmdSYW5nZTogZnVuY3Rpb24gKGxvY2FsVHJhY2spIHtcbiAgICAgIHJldHVybiBsb2NhbFRyYWNrO1xuICAgIH0sXG4gICAgZW5kQ3JlYXRpbmc6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBjb3Zlcikge1xuICAgICAgY292ZXIucmVtb3ZlKGNvdmVyLmNoaWxkQXQoMCkpO1xuICAgICAgLy8gVXNlIGdyYXBoaWMuUG9seWdvbiBjbG9zZSB0aGUgc2hhcGUuXG4gICAgICBjb3Zlci5hZGQobmV3IGdyYXBoaWMuUG9seWdvbih7XG4gICAgICAgIG5hbWU6ICdtYWluJyxcbiAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICBkcmlmdDogY3VycnkoZHJpZnRQb2x5Z29uLCBjb250cm9sbGVyLCBjb3ZlciksXG4gICAgICAgIG9uZHJhZ2VuZDogY3VycnkodHJpZ2dlciwgY29udHJvbGxlciwge1xuICAgICAgICAgIGlzRW5kOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9KSk7XG4gICAgfSxcbiAgICB1cGRhdGVDb3ZlclNoYXBlOiBmdW5jdGlvbiAoY29udHJvbGxlciwgY292ZXIsIGxvY2FsUmFuZ2UsIGJydXNoT3B0aW9uKSB7XG4gICAgICBjb3Zlci5jaGlsZEF0KDApLnNldFNoYXBlKHtcbiAgICAgICAgcG9pbnRzOiBjbGlwQnlQYW5lbChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlQ29tbW9uOiB1cGRhdGVDb21tb24sXG4gICAgY29udGFpbjogbWFpblNoYXBlQ29udGFpblxuICB9XG59O1xuZnVuY3Rpb24gZ2V0TGluZVJlbmRlcmVyKHh5SW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVDb3ZlcjogZnVuY3Rpb24gKGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQmFzZVJlY3RDb3Zlcih7XG4gICAgICAgIHRvUmVjdFJhbmdlOiBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICB2YXIgcmVjdFJhbmdlID0gW3JhbmdlLCBbMCwgMTAwXV07XG4gICAgICAgICAgeHlJbmRleCAmJiByZWN0UmFuZ2UucmV2ZXJzZSgpO1xuICAgICAgICAgIHJldHVybiByZWN0UmFuZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21SZWN0UmFuZ2U6IGZ1bmN0aW9uIChyZWN0UmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gcmVjdFJhbmdlW3h5SW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9LCBjb250cm9sbGVyLCBicnVzaE9wdGlvbiwgW1tbJ3cnXSwgWydlJ11dLCBbWyduJ10sIFsncyddXV1beHlJbmRleF0pO1xuICAgIH0sXG4gICAgZ2V0Q3JlYXRpbmdSYW5nZTogZnVuY3Rpb24gKGxvY2FsVHJhY2spIHtcbiAgICAgIHZhciBlbmRzID0gZ2V0VHJhY2tFbmRzKGxvY2FsVHJhY2spO1xuICAgICAgdmFyIG1pbiA9IG1hdGhNaW4oZW5kc1swXVt4eUluZGV4XSwgZW5kc1sxXVt4eUluZGV4XSk7XG4gICAgICB2YXIgbWF4ID0gbWF0aE1heChlbmRzWzBdW3h5SW5kZXhdLCBlbmRzWzFdW3h5SW5kZXhdKTtcbiAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH0sXG4gICAgdXBkYXRlQ292ZXJTaGFwZTogZnVuY3Rpb24gKGNvbnRyb2xsZXIsIGNvdmVyLCBsb2NhbFJhbmdlLCBicnVzaE9wdGlvbikge1xuICAgICAgdmFyIG90aGVyRXh0ZW50O1xuICAgICAgLy8gSWYgYnJ1c2hXaWR0aCBub3Qgc3BlY2lmaWVkLCBmaXQgdGhlIHBhbmVsLlxuICAgICAgdmFyIHBhbmVsID0gZ2V0UGFuZWxCeUNvdmVyKGNvbnRyb2xsZXIsIGNvdmVyKTtcbiAgICAgIGlmIChwYW5lbCAhPT0gQlJVU0hfUEFORUxfR0xPQkFMICYmIHBhbmVsLmdldExpbmVhckJydXNoT3RoZXJFeHRlbnQpIHtcbiAgICAgICAgb3RoZXJFeHRlbnQgPSBwYW5lbC5nZXRMaW5lYXJCcnVzaE90aGVyRXh0ZW50KHh5SW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHpyID0gY29udHJvbGxlci5fenI7XG4gICAgICAgIG90aGVyRXh0ZW50ID0gWzAsIFt6ci5nZXRXaWR0aCgpLCB6ci5nZXRIZWlnaHQoKV1bMSAtIHh5SW5kZXhdXTtcbiAgICAgIH1cbiAgICAgIHZhciByZWN0UmFuZ2UgPSBbbG9jYWxSYW5nZSwgb3RoZXJFeHRlbnRdO1xuICAgICAgeHlJbmRleCAmJiByZWN0UmFuZ2UucmV2ZXJzZSgpO1xuICAgICAgdXBkYXRlQmFzZVJlY3QoY29udHJvbGxlciwgY292ZXIsIHJlY3RSYW5nZSwgYnJ1c2hPcHRpb24pO1xuICAgIH0sXG4gICAgdXBkYXRlQ29tbW9uOiB1cGRhdGVDb21tb24sXG4gICAgY29udGFpbjogbWFpblNoYXBlQ29udGFpblxuICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgQnJ1c2hDb250cm9sbGVyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14403\n")},98595:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43199);\n/* harmony import */ var _brushHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25451);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n// FIXME\n// how to genarialize to more coordinate systems.\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\nvar BrushTargetManager = /** @class */function () {\n  /**\r\n   * @param finder contains Index/Id/Name of xAxis/yAxis/geo/grid\r\n   *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\r\n   * @param opt.include include coordinate system types.\r\n   */\n  function BrushTargetManager(finder, ecModel, opt) {\n    var _this = this;\n    this._targetInfoList = [];\n    var foundCpts = parseFinder(ecModel, finder);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(targetInfoBuilders, function (builder, type) {\n      if (!opt || !opt.include || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf)(opt.include, type) >= 0) {\n        builder(foundCpts, _this._targetInfoList);\n      }\n    });\n  }\n  BrushTargetManager.prototype.setOutputRanges = function (areas, ecModel) {\n    this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n      (area.coordRanges || (area.coordRanges = [])).push(coordRange);\n      // area.coordRange is the first of area.coordRanges\n      if (!area.coordRange) {\n        area.coordRange = coordRange;\n        // In 'category' axis, coord to pixel is not reversible, so we can not\n        // rebuild range by coordRange accrately, which may bring trouble when\n        // brushing only one item. So we use __rangeOffset to rebuilding range\n        // by coordRange. And this it only used in brush component so it is no\n        // need to be adapted to coordRanges.\n        var result = coordConvert[area.brushType](0, coordSys, coordRange);\n        area.__rangeOffset = {\n          offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n          xyMinMax: result.xyMinMax\n        };\n      }\n    });\n    return areas;\n  };\n  BrushTargetManager.prototype.matchOutputRanges = function (areas, ecModel, cb) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n      if (targetInfo && targetInfo !== true) {\n        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(targetInfo.coordSyses, function (coordSys) {\n          var result = coordConvert[area.brushType](1, coordSys, area.range, true);\n          cb(area, result.values, coordSys, ecModel);\n        });\n      }\n    }, this);\n  };\n  /**\r\n   * the `areas` is `BrushModel.areas`.\r\n   * Called in layout stage.\r\n   * convert `area.coordRange` to global range and set panelId to `area.range`.\r\n   */\n  BrushTargetManager.prototype.setInputRanges = function (areas, ecModel) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n      if (false) {}\n      area.range = area.range || [];\n      // convert coordRange to global range and set panelId.\n      if (targetInfo && targetInfo !== true) {\n        area.panelId = targetInfo.panelId;\n        // (1) area.range should always be calculate from coordRange but does\n        // not keep its original value, for the sake of the dataZoom scenario,\n        // where area.coordRange remains unchanged but area.range may be changed.\n        // (2) Only support converting one coordRange to pixel range in brush\n        // component. So do not consider `coordRanges`.\n        // (3) About __rangeOffset, see comment above.\n        var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n        var rangeOffset = area.__rangeOffset;\n        area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n      }\n    }, this);\n  };\n  BrushTargetManager.prototype.makePanelOpts = function (api, getDefaultBrushType) {\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)(this._targetInfoList, function (targetInfo) {\n      var rect = targetInfo.getPanelRect();\n      return {\n        panelId: targetInfo.panelId,\n        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,\n        clipPath: _brushHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .makeRectPanelClipPath */ .wd(rect),\n        isTargetByCursor: _brushHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .makeRectIsTargetByCursor */ .x$(rect, api, targetInfo.coordSysModel),\n        getLinearBrushOtherExtent: _brushHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .makeLinearBrushOtherExtent */ .wx(rect)\n      };\n    });\n  };\n  BrushTargetManager.prototype.controlSeries = function (area, seriesModel, ecModel) {\n    // Check whether area is bound in coord, and series do not belong to that coord.\n    // If do not do this check, some brush (like lineX) will controll all axes.\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    return targetInfo === true || targetInfo && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf)(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n  };\n  /**\r\n   * If return Object, a coord found.\r\n   * If return true, global found.\r\n   * Otherwise nothing found.\r\n   */\n  BrushTargetManager.prototype.findTargetInfo = function (area, ecModel) {\n    var targetInfoList = this._targetInfoList;\n    var foundCpts = parseFinder(ecModel, area);\n    for (var i = 0; i < targetInfoList.length; i++) {\n      var targetInfo = targetInfoList[i];\n      var areaPanelId = area.panelId;\n      if (areaPanelId) {\n        if (targetInfo.panelId === areaPanelId) {\n          return targetInfo;\n        }\n      } else {\n        for (var j = 0; j < targetInfoMatchers.length; j++) {\n          if (targetInfoMatchers[j](foundCpts, targetInfo)) {\n            return targetInfo;\n          }\n        }\n      }\n    }\n    return true;\n  };\n  return BrushTargetManager;\n}();\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\nfunction parseFinder(ecModel, finder) {\n  return (0,_util_model_js__WEBPACK_IMPORTED_MODULE_2__/* .parseFinder */ ._e)(ecModel, finder, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels;\n    // Remove duplicated.\n    var gridModelMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();\n    var xAxesHas = {};\n    var yAxesHas = {};\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(grid.getCartesians(), function (cartesian, index) {\n        if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf)(xAxisModels, cartesian.getAxis('x').model) >= 0 || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf)(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilders.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilders.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [\n// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n},\n// geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilders = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.master.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone();\n    // geo roam and zoom transform\n    rect.applyTransform(_util_graphic_js__WEBPACK_IMPORTED_MODULE_3__.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.curry)(axisConvert, 0),\n  lineY: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.curry)(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp);\n    var xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)(rangeOrCoordRange, function (item) {\n      var p = to ? coordSys.pointToData(item, clamp) : coordSys.dataToPoint(item, clamp);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  if (false) {}\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\nvar diffProcessor = {\n  lineX: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.curry)(axisDiffProcessor, 0),\n  lineY: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.curry)(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n}\n// We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n// Return [0~1, 0~1]\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BrushTargetManager);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg1OTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9CcnVzaFRhcmdldE1hbmFnZXIuanM/MjcxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGVhY2gsIGluZGV4T2YsIGN1cnJ5LCBhc3NlcnQsIG1hcCwgY3JlYXRlSGFzaE1hcCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgKiBhcyBicnVzaEhlbHBlciBmcm9tICcuL2JydXNoSGVscGVyLmpzJztcbmltcG9ydCB7IHBhcnNlRmluZGVyIGFzIG1vZGVsVXRpbFBhcnNlRmluZGVyIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG4vLyBGSVhNRVxuLy8gaG93IHRvIGdlbmFyaWFsaXplIHRvIG1vcmUgY29vcmRpbmF0ZSBzeXN0ZW1zLlxudmFyIElOQ0xVREVfRklOREVSX01BSU5fVFlQRVMgPSBbJ2dyaWQnLCAneEF4aXMnLCAneUF4aXMnLCAnZ2VvJywgJ2dyYXBoJywgJ3BvbGFyJywgJ3JhZGl1c0F4aXMnLCAnYW5nbGVBeGlzJywgJ2JtYXAnXTtcbnZhciBCcnVzaFRhcmdldE1hbmFnZXIgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBAcGFyYW0gZmluZGVyIGNvbnRhaW5zIEluZGV4L0lkL05hbWUgb2YgeEF4aXMveUF4aXMvZ2VvL2dyaWRcclxuICAgKiAgICAgICAgRWFjaCBjYW4gYmUge251bWJlcnxBcnJheS48bnVtYmVyPn0uIGxpa2U6IHt4QXhpc0luZGV4OiBbMywgNF19XHJcbiAgICogQHBhcmFtIG9wdC5pbmNsdWRlIGluY2x1ZGUgY29vcmRpbmF0ZSBzeXN0ZW0gdHlwZXMuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEJydXNoVGFyZ2V0TWFuYWdlcihmaW5kZXIsIGVjTW9kZWwsIG9wdCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fdGFyZ2V0SW5mb0xpc3QgPSBbXTtcbiAgICB2YXIgZm91bmRDcHRzID0gcGFyc2VGaW5kZXIoZWNNb2RlbCwgZmluZGVyKTtcbiAgICBlYWNoKHRhcmdldEluZm9CdWlsZGVycywgZnVuY3Rpb24gKGJ1aWxkZXIsIHR5cGUpIHtcbiAgICAgIGlmICghb3B0IHx8ICFvcHQuaW5jbHVkZSB8fCBpbmRleE9mKG9wdC5pbmNsdWRlLCB0eXBlKSA+PSAwKSB7XG4gICAgICAgIGJ1aWxkZXIoZm91bmRDcHRzLCBfdGhpcy5fdGFyZ2V0SW5mb0xpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIEJydXNoVGFyZ2V0TWFuYWdlci5wcm90b3R5cGUuc2V0T3V0cHV0UmFuZ2VzID0gZnVuY3Rpb24gKGFyZWFzLCBlY01vZGVsKSB7XG4gICAgdGhpcy5tYXRjaE91dHB1dFJhbmdlcyhhcmVhcywgZWNNb2RlbCwgZnVuY3Rpb24gKGFyZWEsIGNvb3JkUmFuZ2UsIGNvb3JkU3lzKSB7XG4gICAgICAoYXJlYS5jb29yZFJhbmdlcyB8fCAoYXJlYS5jb29yZFJhbmdlcyA9IFtdKSkucHVzaChjb29yZFJhbmdlKTtcbiAgICAgIC8vIGFyZWEuY29vcmRSYW5nZSBpcyB0aGUgZmlyc3Qgb2YgYXJlYS5jb29yZFJhbmdlc1xuICAgICAgaWYgKCFhcmVhLmNvb3JkUmFuZ2UpIHtcbiAgICAgICAgYXJlYS5jb29yZFJhbmdlID0gY29vcmRSYW5nZTtcbiAgICAgICAgLy8gSW4gJ2NhdGVnb3J5JyBheGlzLCBjb29yZCB0byBwaXhlbCBpcyBub3QgcmV2ZXJzaWJsZSwgc28gd2UgY2FuIG5vdFxuICAgICAgICAvLyByZWJ1aWxkIHJhbmdlIGJ5IGNvb3JkUmFuZ2UgYWNjcmF0ZWx5LCB3aGljaCBtYXkgYnJpbmcgdHJvdWJsZSB3aGVuXG4gICAgICAgIC8vIGJydXNoaW5nIG9ubHkgb25lIGl0ZW0uIFNvIHdlIHVzZSBfX3JhbmdlT2Zmc2V0IHRvIHJlYnVpbGRpbmcgcmFuZ2VcbiAgICAgICAgLy8gYnkgY29vcmRSYW5nZS4gQW5kIHRoaXMgaXQgb25seSB1c2VkIGluIGJydXNoIGNvbXBvbmVudCBzbyBpdCBpcyBub1xuICAgICAgICAvLyBuZWVkIHRvIGJlIGFkYXB0ZWQgdG8gY29vcmRSYW5nZXMuXG4gICAgICAgIHZhciByZXN1bHQgPSBjb29yZENvbnZlcnRbYXJlYS5icnVzaFR5cGVdKDAsIGNvb3JkU3lzLCBjb29yZFJhbmdlKTtcbiAgICAgICAgYXJlYS5fX3JhbmdlT2Zmc2V0ID0ge1xuICAgICAgICAgIG9mZnNldDogZGlmZlByb2Nlc3NvclthcmVhLmJydXNoVHlwZV0ocmVzdWx0LnZhbHVlcywgYXJlYS5yYW5nZSwgWzEsIDFdKSxcbiAgICAgICAgICB4eU1pbk1heDogcmVzdWx0Lnh5TWluTWF4XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFyZWFzO1xuICB9O1xuICBCcnVzaFRhcmdldE1hbmFnZXIucHJvdG90eXBlLm1hdGNoT3V0cHV0UmFuZ2VzID0gZnVuY3Rpb24gKGFyZWFzLCBlY01vZGVsLCBjYikge1xuICAgIGVhY2goYXJlYXMsIGZ1bmN0aW9uIChhcmVhKSB7XG4gICAgICB2YXIgdGFyZ2V0SW5mbyA9IHRoaXMuZmluZFRhcmdldEluZm8oYXJlYSwgZWNNb2RlbCk7XG4gICAgICBpZiAodGFyZ2V0SW5mbyAmJiB0YXJnZXRJbmZvICE9PSB0cnVlKSB7XG4gICAgICAgIGVhY2godGFyZ2V0SW5mby5jb29yZFN5c2VzLCBmdW5jdGlvbiAoY29vcmRTeXMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY29vcmRDb252ZXJ0W2FyZWEuYnJ1c2hUeXBlXSgxLCBjb29yZFN5cywgYXJlYS5yYW5nZSwgdHJ1ZSk7XG4gICAgICAgICAgY2IoYXJlYSwgcmVzdWx0LnZhbHVlcywgY29vcmRTeXMsIGVjTW9kZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogdGhlIGBhcmVhc2AgaXMgYEJydXNoTW9kZWwuYXJlYXNgLlxyXG4gICAqIENhbGxlZCBpbiBsYXlvdXQgc3RhZ2UuXHJcbiAgICogY29udmVydCBgYXJlYS5jb29yZFJhbmdlYCB0byBnbG9iYWwgcmFuZ2UgYW5kIHNldCBwYW5lbElkIHRvIGBhcmVhLnJhbmdlYC5cclxuICAgKi9cbiAgQnJ1c2hUYXJnZXRNYW5hZ2VyLnByb3RvdHlwZS5zZXRJbnB1dFJhbmdlcyA9IGZ1bmN0aW9uIChhcmVhcywgZWNNb2RlbCkge1xuICAgIGVhY2goYXJlYXMsIGZ1bmN0aW9uIChhcmVhKSB7XG4gICAgICB2YXIgdGFyZ2V0SW5mbyA9IHRoaXMuZmluZFRhcmdldEluZm8oYXJlYSwgZWNNb2RlbCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhc3NlcnQoIXRhcmdldEluZm8gfHwgdGFyZ2V0SW5mbyA9PT0gdHJ1ZSB8fCBhcmVhLmNvb3JkUmFuZ2UsICdjb29yZFJhbmdlIG11c3QgYmUgc3BlY2lmaWVkIHdoZW4gY29vcmQgaW5kZXggc3BlY2lmaWVkLicpO1xuICAgICAgICBhc3NlcnQoIXRhcmdldEluZm8gfHwgdGFyZ2V0SW5mbyAhPT0gdHJ1ZSB8fCBhcmVhLnJhbmdlLCAncmFuZ2UgbXVzdCBiZSBzcGVjaWZpZWQgaW4gZ2xvYmFsIGJydXNoLicpO1xuICAgICAgfVxuICAgICAgYXJlYS5yYW5nZSA9IGFyZWEucmFuZ2UgfHwgW107XG4gICAgICAvLyBjb252ZXJ0IGNvb3JkUmFuZ2UgdG8gZ2xvYmFsIHJhbmdlIGFuZCBzZXQgcGFuZWxJZC5cbiAgICAgIGlmICh0YXJnZXRJbmZvICYmIHRhcmdldEluZm8gIT09IHRydWUpIHtcbiAgICAgICAgYXJlYS5wYW5lbElkID0gdGFyZ2V0SW5mby5wYW5lbElkO1xuICAgICAgICAvLyAoMSkgYXJlYS5yYW5nZSBzaG91bGQgYWx3YXlzIGJlIGNhbGN1bGF0ZSBmcm9tIGNvb3JkUmFuZ2UgYnV0IGRvZXNcbiAgICAgICAgLy8gbm90IGtlZXAgaXRzIG9yaWdpbmFsIHZhbHVlLCBmb3IgdGhlIHNha2Ugb2YgdGhlIGRhdGFab29tIHNjZW5hcmlvLFxuICAgICAgICAvLyB3aGVyZSBhcmVhLmNvb3JkUmFuZ2UgcmVtYWlucyB1bmNoYW5nZWQgYnV0IGFyZWEucmFuZ2UgbWF5IGJlIGNoYW5nZWQuXG4gICAgICAgIC8vICgyKSBPbmx5IHN1cHBvcnQgY29udmVydGluZyBvbmUgY29vcmRSYW5nZSB0byBwaXhlbCByYW5nZSBpbiBicnVzaFxuICAgICAgICAvLyBjb21wb25lbnQuIFNvIGRvIG5vdCBjb25zaWRlciBgY29vcmRSYW5nZXNgLlxuICAgICAgICAvLyAoMykgQWJvdXQgX19yYW5nZU9mZnNldCwgc2VlIGNvbW1lbnQgYWJvdmUuXG4gICAgICAgIHZhciByZXN1bHQgPSBjb29yZENvbnZlcnRbYXJlYS5icnVzaFR5cGVdKDAsIHRhcmdldEluZm8uY29vcmRTeXMsIGFyZWEuY29vcmRSYW5nZSk7XG4gICAgICAgIHZhciByYW5nZU9mZnNldCA9IGFyZWEuX19yYW5nZU9mZnNldDtcbiAgICAgICAgYXJlYS5yYW5nZSA9IHJhbmdlT2Zmc2V0ID8gZGlmZlByb2Nlc3NvclthcmVhLmJydXNoVHlwZV0ocmVzdWx0LnZhbHVlcywgcmFuZ2VPZmZzZXQub2Zmc2V0LCBnZXRTY2FsZXMocmVzdWx0Lnh5TWluTWF4LCByYW5nZU9mZnNldC54eU1pbk1heCkpIDogcmVzdWx0LnZhbHVlcztcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgQnJ1c2hUYXJnZXRNYW5hZ2VyLnByb3RvdHlwZS5tYWtlUGFuZWxPcHRzID0gZnVuY3Rpb24gKGFwaSwgZ2V0RGVmYXVsdEJydXNoVHlwZSkge1xuICAgIHJldHVybiBtYXAodGhpcy5fdGFyZ2V0SW5mb0xpc3QsIGZ1bmN0aW9uICh0YXJnZXRJbmZvKSB7XG4gICAgICB2YXIgcmVjdCA9IHRhcmdldEluZm8uZ2V0UGFuZWxSZWN0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYW5lbElkOiB0YXJnZXRJbmZvLnBhbmVsSWQsXG4gICAgICAgIGRlZmF1bHRCcnVzaFR5cGU6IGdldERlZmF1bHRCcnVzaFR5cGUgPyBnZXREZWZhdWx0QnJ1c2hUeXBlKHRhcmdldEluZm8pIDogbnVsbCxcbiAgICAgICAgY2xpcFBhdGg6IGJydXNoSGVscGVyLm1ha2VSZWN0UGFuZWxDbGlwUGF0aChyZWN0KSxcbiAgICAgICAgaXNUYXJnZXRCeUN1cnNvcjogYnJ1c2hIZWxwZXIubWFrZVJlY3RJc1RhcmdldEJ5Q3Vyc29yKHJlY3QsIGFwaSwgdGFyZ2V0SW5mby5jb29yZFN5c01vZGVsKSxcbiAgICAgICAgZ2V0TGluZWFyQnJ1c2hPdGhlckV4dGVudDogYnJ1c2hIZWxwZXIubWFrZUxpbmVhckJydXNoT3RoZXJFeHRlbnQocmVjdClcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG4gIEJydXNoVGFyZ2V0TWFuYWdlci5wcm90b3R5cGUuY29udHJvbFNlcmllcyA9IGZ1bmN0aW9uIChhcmVhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgIC8vIENoZWNrIHdoZXRoZXIgYXJlYSBpcyBib3VuZCBpbiBjb29yZCwgYW5kIHNlcmllcyBkbyBub3QgYmVsb25nIHRvIHRoYXQgY29vcmQuXG4gICAgLy8gSWYgZG8gbm90IGRvIHRoaXMgY2hlY2ssIHNvbWUgYnJ1c2ggKGxpa2UgbGluZVgpIHdpbGwgY29udHJvbGwgYWxsIGF4ZXMuXG4gICAgdmFyIHRhcmdldEluZm8gPSB0aGlzLmZpbmRUYXJnZXRJbmZvKGFyZWEsIGVjTW9kZWwpO1xuICAgIHJldHVybiB0YXJnZXRJbmZvID09PSB0cnVlIHx8IHRhcmdldEluZm8gJiYgaW5kZXhPZih0YXJnZXRJbmZvLmNvb3JkU3lzZXMsIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0pID49IDA7XG4gIH07XG4gIC8qKlxyXG4gICAqIElmIHJldHVybiBPYmplY3QsIGEgY29vcmQgZm91bmQuXHJcbiAgICogSWYgcmV0dXJuIHRydWUsIGdsb2JhbCBmb3VuZC5cclxuICAgKiBPdGhlcndpc2Ugbm90aGluZyBmb3VuZC5cclxuICAgKi9cbiAgQnJ1c2hUYXJnZXRNYW5hZ2VyLnByb3RvdHlwZS5maW5kVGFyZ2V0SW5mbyA9IGZ1bmN0aW9uIChhcmVhLCBlY01vZGVsKSB7XG4gICAgdmFyIHRhcmdldEluZm9MaXN0ID0gdGhpcy5fdGFyZ2V0SW5mb0xpc3Q7XG4gICAgdmFyIGZvdW5kQ3B0cyA9IHBhcnNlRmluZGVyKGVjTW9kZWwsIGFyZWEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0SW5mb0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0YXJnZXRJbmZvID0gdGFyZ2V0SW5mb0xpc3RbaV07XG4gICAgICB2YXIgYXJlYVBhbmVsSWQgPSBhcmVhLnBhbmVsSWQ7XG4gICAgICBpZiAoYXJlYVBhbmVsSWQpIHtcbiAgICAgICAgaWYgKHRhcmdldEluZm8ucGFuZWxJZCA9PT0gYXJlYVBhbmVsSWQpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0SW5mbztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0YXJnZXRJbmZvTWF0Y2hlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodGFyZ2V0SW5mb01hdGNoZXJzW2pdKGZvdW5kQ3B0cywgdGFyZ2V0SW5mbykpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRJbmZvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgcmV0dXJuIEJydXNoVGFyZ2V0TWFuYWdlcjtcbn0oKTtcbmZ1bmN0aW9uIGZvcm1hdE1pbk1heChtaW5NYXgpIHtcbiAgbWluTWF4WzBdID4gbWluTWF4WzFdICYmIG1pbk1heC5yZXZlcnNlKCk7XG4gIHJldHVybiBtaW5NYXg7XG59XG5mdW5jdGlvbiBwYXJzZUZpbmRlcihlY01vZGVsLCBmaW5kZXIpIHtcbiAgcmV0dXJuIG1vZGVsVXRpbFBhcnNlRmluZGVyKGVjTW9kZWwsIGZpbmRlciwge1xuICAgIGluY2x1ZGVNYWluVHlwZXM6IElOQ0xVREVfRklOREVSX01BSU5fVFlQRVNcbiAgfSk7XG59XG52YXIgdGFyZ2V0SW5mb0J1aWxkZXJzID0ge1xuICBncmlkOiBmdW5jdGlvbiAoZm91bmRDcHRzLCB0YXJnZXRJbmZvTGlzdCkge1xuICAgIHZhciB4QXhpc01vZGVscyA9IGZvdW5kQ3B0cy54QXhpc01vZGVscztcbiAgICB2YXIgeUF4aXNNb2RlbHMgPSBmb3VuZENwdHMueUF4aXNNb2RlbHM7XG4gICAgdmFyIGdyaWRNb2RlbHMgPSBmb3VuZENwdHMuZ3JpZE1vZGVscztcbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlZC5cbiAgICB2YXIgZ3JpZE1vZGVsTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuICAgIHZhciB4QXhlc0hhcyA9IHt9O1xuICAgIHZhciB5QXhlc0hhcyA9IHt9O1xuICAgIGlmICgheEF4aXNNb2RlbHMgJiYgIXlBeGlzTW9kZWxzICYmICFncmlkTW9kZWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVhY2goeEF4aXNNb2RlbHMsIGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICAgIHZhciBncmlkTW9kZWwgPSBheGlzTW9kZWwuYXhpcy5ncmlkLm1vZGVsO1xuICAgICAgZ3JpZE1vZGVsTWFwLnNldChncmlkTW9kZWwuaWQsIGdyaWRNb2RlbCk7XG4gICAgICB4QXhlc0hhc1tncmlkTW9kZWwuaWRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBlYWNoKHlBeGlzTW9kZWxzLCBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgICB2YXIgZ3JpZE1vZGVsID0gYXhpc01vZGVsLmF4aXMuZ3JpZC5tb2RlbDtcbiAgICAgIGdyaWRNb2RlbE1hcC5zZXQoZ3JpZE1vZGVsLmlkLCBncmlkTW9kZWwpO1xuICAgICAgeUF4ZXNIYXNbZ3JpZE1vZGVsLmlkXSA9IHRydWU7XG4gICAgfSk7XG4gICAgZWFjaChncmlkTW9kZWxzLCBmdW5jdGlvbiAoZ3JpZE1vZGVsKSB7XG4gICAgICBncmlkTW9kZWxNYXAuc2V0KGdyaWRNb2RlbC5pZCwgZ3JpZE1vZGVsKTtcbiAgICAgIHhBeGVzSGFzW2dyaWRNb2RlbC5pZF0gPSB0cnVlO1xuICAgICAgeUF4ZXNIYXNbZ3JpZE1vZGVsLmlkXSA9IHRydWU7XG4gICAgfSk7XG4gICAgZ3JpZE1vZGVsTWFwLmVhY2goZnVuY3Rpb24gKGdyaWRNb2RlbCkge1xuICAgICAgdmFyIGdyaWQgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgIHZhciBjYXJ0ZXNpYW5zID0gW107XG4gICAgICBlYWNoKGdyaWQuZ2V0Q2FydGVzaWFucygpLCBmdW5jdGlvbiAoY2FydGVzaWFuLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXhPZih4QXhpc01vZGVscywgY2FydGVzaWFuLmdldEF4aXMoJ3gnKS5tb2RlbCkgPj0gMCB8fCBpbmRleE9mKHlBeGlzTW9kZWxzLCBjYXJ0ZXNpYW4uZ2V0QXhpcygneScpLm1vZGVsKSA+PSAwKSB7XG4gICAgICAgICAgY2FydGVzaWFucy5wdXNoKGNhcnRlc2lhbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGFyZ2V0SW5mb0xpc3QucHVzaCh7XG4gICAgICAgIHBhbmVsSWQ6ICdncmlkLS0nICsgZ3JpZE1vZGVsLmlkLFxuICAgICAgICBncmlkTW9kZWw6IGdyaWRNb2RlbCxcbiAgICAgICAgY29vcmRTeXNNb2RlbDogZ3JpZE1vZGVsLFxuICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IG9uZSBhcyB0aGUgcmVwcmVzZW50aXRpdmUgY29vcmRTeXMuXG4gICAgICAgIGNvb3JkU3lzOiBjYXJ0ZXNpYW5zWzBdLFxuICAgICAgICBjb29yZFN5c2VzOiBjYXJ0ZXNpYW5zLFxuICAgICAgICBnZXRQYW5lbFJlY3Q6IHBhbmVsUmVjdEJ1aWxkZXJzLmdyaWQsXG4gICAgICAgIHhBeGlzRGVjbGFyZWQ6IHhBeGVzSGFzW2dyaWRNb2RlbC5pZF0sXG4gICAgICAgIHlBeGlzRGVjbGFyZWQ6IHlBeGVzSGFzW2dyaWRNb2RlbC5pZF1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBnZW86IGZ1bmN0aW9uIChmb3VuZENwdHMsIHRhcmdldEluZm9MaXN0KSB7XG4gICAgZWFjaChmb3VuZENwdHMuZ2VvTW9kZWxzLCBmdW5jdGlvbiAoZ2VvTW9kZWwpIHtcbiAgICAgIHZhciBjb29yZFN5cyA9IGdlb01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICB0YXJnZXRJbmZvTGlzdC5wdXNoKHtcbiAgICAgICAgcGFuZWxJZDogJ2dlby0tJyArIGdlb01vZGVsLmlkLFxuICAgICAgICBnZW9Nb2RlbDogZ2VvTW9kZWwsXG4gICAgICAgIGNvb3JkU3lzTW9kZWw6IGdlb01vZGVsLFxuICAgICAgICBjb29yZFN5czogY29vcmRTeXMsXG4gICAgICAgIGNvb3JkU3lzZXM6IFtjb29yZFN5c10sXG4gICAgICAgIGdldFBhbmVsUmVjdDogcGFuZWxSZWN0QnVpbGRlcnMuZ2VvXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciB0YXJnZXRJbmZvTWF0Y2hlcnMgPSBbXG4vLyBncmlkXG5mdW5jdGlvbiAoZm91bmRDcHRzLCB0YXJnZXRJbmZvKSB7XG4gIHZhciB4QXhpc01vZGVsID0gZm91bmRDcHRzLnhBeGlzTW9kZWw7XG4gIHZhciB5QXhpc01vZGVsID0gZm91bmRDcHRzLnlBeGlzTW9kZWw7XG4gIHZhciBncmlkTW9kZWwgPSBmb3VuZENwdHMuZ3JpZE1vZGVsO1xuICAhZ3JpZE1vZGVsICYmIHhBeGlzTW9kZWwgJiYgKGdyaWRNb2RlbCA9IHhBeGlzTW9kZWwuYXhpcy5ncmlkLm1vZGVsKTtcbiAgIWdyaWRNb2RlbCAmJiB5QXhpc01vZGVsICYmIChncmlkTW9kZWwgPSB5QXhpc01vZGVsLmF4aXMuZ3JpZC5tb2RlbCk7XG4gIHJldHVybiBncmlkTW9kZWwgJiYgZ3JpZE1vZGVsID09PSB0YXJnZXRJbmZvLmdyaWRNb2RlbDtcbn0sXG4vLyBnZW9cbmZ1bmN0aW9uIChmb3VuZENwdHMsIHRhcmdldEluZm8pIHtcbiAgdmFyIGdlb01vZGVsID0gZm91bmRDcHRzLmdlb01vZGVsO1xuICByZXR1cm4gZ2VvTW9kZWwgJiYgZ2VvTW9kZWwgPT09IHRhcmdldEluZm8uZ2VvTW9kZWw7XG59XTtcbnZhciBwYW5lbFJlY3RCdWlsZGVycyA9IHtcbiAgZ3JpZDogZnVuY3Rpb24gKCkge1xuICAgIC8vIGdyaWQgaXMgbm90IFRyYW5zZm9ybWFibGUuXG4gICAgcmV0dXJuIHRoaXMuY29vcmRTeXMubWFzdGVyLmdldFJlY3QoKS5jbG9uZSgpO1xuICB9LFxuICBnZW86IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29vcmRTeXMgPSB0aGlzLmNvb3JkU3lzO1xuICAgIHZhciByZWN0ID0gY29vcmRTeXMuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgICAvLyBnZW8gcm9hbSBhbmQgem9vbSB0cmFuc2Zvcm1cbiAgICByZWN0LmFwcGx5VHJhbnNmb3JtKGdyYXBoaWMuZ2V0VHJhbnNmb3JtKGNvb3JkU3lzKSk7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbn07XG52YXIgY29vcmRDb252ZXJ0ID0ge1xuICBsaW5lWDogY3VycnkoYXhpc0NvbnZlcnQsIDApLFxuICBsaW5lWTogY3VycnkoYXhpc0NvbnZlcnQsIDEpLFxuICByZWN0OiBmdW5jdGlvbiAodG8sIGNvb3JkU3lzLCByYW5nZU9yQ29vcmRSYW5nZSwgY2xhbXApIHtcbiAgICB2YXIgeG1pbnltaW4gPSB0byA/IGNvb3JkU3lzLnBvaW50VG9EYXRhKFtyYW5nZU9yQ29vcmRSYW5nZVswXVswXSwgcmFuZ2VPckNvb3JkUmFuZ2VbMV1bMF1dLCBjbGFtcCkgOiBjb29yZFN5cy5kYXRhVG9Qb2ludChbcmFuZ2VPckNvb3JkUmFuZ2VbMF1bMF0sIHJhbmdlT3JDb29yZFJhbmdlWzFdWzBdXSwgY2xhbXApO1xuICAgIHZhciB4bWF4eW1heCA9IHRvID8gY29vcmRTeXMucG9pbnRUb0RhdGEoW3JhbmdlT3JDb29yZFJhbmdlWzBdWzFdLCByYW5nZU9yQ29vcmRSYW5nZVsxXVsxXV0sIGNsYW1wKSA6IGNvb3JkU3lzLmRhdGFUb1BvaW50KFtyYW5nZU9yQ29vcmRSYW5nZVswXVsxXSwgcmFuZ2VPckNvb3JkUmFuZ2VbMV1bMV1dLCBjbGFtcCk7XG4gICAgdmFyIHZhbHVlcyA9IFtmb3JtYXRNaW5NYXgoW3htaW55bWluWzBdLCB4bWF4eW1heFswXV0pLCBmb3JtYXRNaW5NYXgoW3htaW55bWluWzFdLCB4bWF4eW1heFsxXV0pXTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICB4eU1pbk1heDogdmFsdWVzXG4gICAgfTtcbiAgfSxcbiAgcG9seWdvbjogZnVuY3Rpb24gKHRvLCBjb29yZFN5cywgcmFuZ2VPckNvb3JkUmFuZ2UsIGNsYW1wKSB7XG4gICAgdmFyIHh5TWluTWF4ID0gW1tJbmZpbml0eSwgLUluZmluaXR5XSwgW0luZmluaXR5LCAtSW5maW5pdHldXTtcbiAgICB2YXIgdmFsdWVzID0gbWFwKHJhbmdlT3JDb29yZFJhbmdlLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHAgPSB0byA/IGNvb3JkU3lzLnBvaW50VG9EYXRhKGl0ZW0sIGNsYW1wKSA6IGNvb3JkU3lzLmRhdGFUb1BvaW50KGl0ZW0sIGNsYW1wKTtcbiAgICAgIHh5TWluTWF4WzBdWzBdID0gTWF0aC5taW4oeHlNaW5NYXhbMF1bMF0sIHBbMF0pO1xuICAgICAgeHlNaW5NYXhbMV1bMF0gPSBNYXRoLm1pbih4eU1pbk1heFsxXVswXSwgcFsxXSk7XG4gICAgICB4eU1pbk1heFswXVsxXSA9IE1hdGgubWF4KHh5TWluTWF4WzBdWzFdLCBwWzBdKTtcbiAgICAgIHh5TWluTWF4WzFdWzFdID0gTWF0aC5tYXgoeHlNaW5NYXhbMV1bMV0sIHBbMV0pO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgeHlNaW5NYXg6IHh5TWluTWF4XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGF4aXNDb252ZXJ0KGF4aXNOYW1lSW5kZXgsIHRvLCBjb29yZFN5cywgcmFuZ2VPckNvb3JkUmFuZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJywgJ2xpbmVYL2xpbmVZIGJydXNoIGlzIGF2YWlsYWJsZSBvbmx5IGluIGNhcnRlc2lhbjJkLicpO1xuICB9XG4gIHZhciBheGlzID0gY29vcmRTeXMuZ2V0QXhpcyhbJ3gnLCAneSddW2F4aXNOYW1lSW5kZXhdKTtcbiAgdmFyIHZhbHVlcyA9IGZvcm1hdE1pbk1heChtYXAoWzAsIDFdLCBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiB0byA/IGF4aXMuY29vcmRUb0RhdGEoYXhpcy50b0xvY2FsQ29vcmQocmFuZ2VPckNvb3JkUmFuZ2VbaV0pLCB0cnVlKSA6IGF4aXMudG9HbG9iYWxDb29yZChheGlzLmRhdGFUb0Nvb3JkKHJhbmdlT3JDb29yZFJhbmdlW2ldKSk7XG4gIH0pKTtcbiAgdmFyIHh5TWluTWF4ID0gW107XG4gIHh5TWluTWF4W2F4aXNOYW1lSW5kZXhdID0gdmFsdWVzO1xuICB4eU1pbk1heFsxIC0gYXhpc05hbWVJbmRleF0gPSBbTmFOLCBOYU5dO1xuICByZXR1cm4ge1xuICAgIHZhbHVlczogdmFsdWVzLFxuICAgIHh5TWluTWF4OiB4eU1pbk1heFxuICB9O1xufVxudmFyIGRpZmZQcm9jZXNzb3IgPSB7XG4gIGxpbmVYOiBjdXJyeShheGlzRGlmZlByb2Nlc3NvciwgMCksXG4gIGxpbmVZOiBjdXJyeShheGlzRGlmZlByb2Nlc3NvciwgMSksXG4gIHJlY3Q6IGZ1bmN0aW9uICh2YWx1ZXMsIHJlZmVyLCBzY2FsZXMpIHtcbiAgICByZXR1cm4gW1t2YWx1ZXNbMF1bMF0gLSBzY2FsZXNbMF0gKiByZWZlclswXVswXSwgdmFsdWVzWzBdWzFdIC0gc2NhbGVzWzBdICogcmVmZXJbMF1bMV1dLCBbdmFsdWVzWzFdWzBdIC0gc2NhbGVzWzFdICogcmVmZXJbMV1bMF0sIHZhbHVlc1sxXVsxXSAtIHNjYWxlc1sxXSAqIHJlZmVyWzFdWzFdXV07XG4gIH0sXG4gIHBvbHlnb246IGZ1bmN0aW9uICh2YWx1ZXMsIHJlZmVyLCBzY2FsZXMpIHtcbiAgICByZXR1cm4gbWFwKHZhbHVlcywgZnVuY3Rpb24gKGl0ZW0sIGlkeCkge1xuICAgICAgcmV0dXJuIFtpdGVtWzBdIC0gc2NhbGVzWzBdICogcmVmZXJbaWR4XVswXSwgaXRlbVsxXSAtIHNjYWxlc1sxXSAqIHJlZmVyW2lkeF1bMV1dO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gYXhpc0RpZmZQcm9jZXNzb3IoYXhpc05hbWVJbmRleCwgdmFsdWVzLCByZWZlciwgc2NhbGVzKSB7XG4gIHJldHVybiBbdmFsdWVzWzBdIC0gc2NhbGVzW2F4aXNOYW1lSW5kZXhdICogcmVmZXJbMF0sIHZhbHVlc1sxXSAtIHNjYWxlc1theGlzTmFtZUluZGV4XSAqIHJlZmVyWzFdXTtcbn1cbi8vIFdlIGhhdmUgdG8gcHJvY2VzcyBzY2FsZSBjYXVzZWQgYnkgZGF0YVpvb20gbWFudWFsbHksXG4vLyBhbHRob3VnaCBpdCBtaWdodCBiZSBub3QgYWNjdXJhdGUuXG4vLyBSZXR1cm4gWzB+MSwgMH4xXVxuZnVuY3Rpb24gZ2V0U2NhbGVzKHh5TWluTWF4Q3VyciwgeHlNaW5NYXhPcmlnaW4pIHtcbiAgdmFyIHNpemVDdXJyID0gZ2V0U2l6ZSh4eU1pbk1heEN1cnIpO1xuICB2YXIgc2l6ZU9yaWdpbiA9IGdldFNpemUoeHlNaW5NYXhPcmlnaW4pO1xuICB2YXIgc2NhbGVzID0gW3NpemVDdXJyWzBdIC8gc2l6ZU9yaWdpblswXSwgc2l6ZUN1cnJbMV0gLyBzaXplT3JpZ2luWzFdXTtcbiAgaXNOYU4oc2NhbGVzWzBdKSAmJiAoc2NhbGVzWzBdID0gMSk7XG4gIGlzTmFOKHNjYWxlc1sxXSkgJiYgKHNjYWxlc1sxXSA9IDEpO1xuICByZXR1cm4gc2NhbGVzO1xufVxuZnVuY3Rpb24gZ2V0U2l6ZSh4eU1pbk1heCkge1xuICByZXR1cm4geHlNaW5NYXggPyBbeHlNaW5NYXhbMF1bMV0gLSB4eU1pbk1heFswXVswXSwgeHlNaW5NYXhbMV1bMV0gLSB4eU1pbk1heFsxXVswXV0gOiBbTmFOLCBOYU5dO1xufVxuZXhwb3J0IGRlZmF1bHQgQnJ1c2hUYXJnZXRNYW5hZ2VyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///98595\n")}}]);