"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[9796],{3455:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $2: () => (/* binding */ normalizeColor),\n/* harmony export */   Cv: () => (/* binding */ isAroundZero),\n/* harmony export */   MD: () => (/* binding */ getPathPrecision),\n/* harmony export */   OH: () => (/* binding */ isRadialGradient),\n/* harmony export */   OS: () => (/* binding */ isLinearGradient),\n/* harmony export */   Pt: () => (/* binding */ isPattern),\n/* harmony export */   WG: () => (/* binding */ encodeBase64),\n/* harmony export */   XP: () => (/* binding */ round4),\n/* harmony export */   Xu: () => (/* binding */ getIdURL),\n/* harmony export */   Z1: () => (/* binding */ getSRTTransformString),\n/* harmony export */   bn: () => (/* binding */ isGradient),\n/* harmony export */   dX: () => (/* binding */ hasShadow),\n/* harmony export */   eQ: () => (/* binding */ TEXT_ALIGN_TO_ANCHOR),\n/* harmony export */   nV: () => (/* binding */ getMatrixStr),\n/* harmony export */   sL: () => (/* binding */ isImagePattern),\n/* harmony export */   sZ: () => (/* binding */ adjustTextY),\n/* harmony export */   si: () => (/* binding */ getShadowKey)\n/* harmony export */ });\n/* unused harmony exports round3, round1, getClipPathsKey, isSVGPattern */\n/* harmony import */ var _core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _tool_color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47698);\n/* harmony import */ var _core_env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38123);\n\n\n\nvar mathRound = Math.round;\nfunction normalizeColor(color) {\n    var opacity;\n    if (!color || color === 'transparent') {\n        color = 'none';\n    }\n    else if (typeof color === 'string' && color.indexOf('rgba') > -1) {\n        var arr = (0,_tool_color_js__WEBPACK_IMPORTED_MODULE_0__.parse)(color);\n        if (arr) {\n            color = 'rgb(' + arr[0] + ',' + arr[1] + ',' + arr[2] + ')';\n            opacity = arr[3];\n        }\n    }\n    return {\n        color: color,\n        opacity: opacity == null ? 1 : opacity\n    };\n}\nvar EPSILON = 1e-4;\nfunction isAroundZero(transform) {\n    return transform < EPSILON && transform > -EPSILON;\n}\nfunction round3(transform) {\n    return mathRound(transform * 1e3) / 1e3;\n}\nfunction round4(transform) {\n    return mathRound(transform * 1e4) / 1e4;\n}\nfunction round1(transform) {\n    return mathRound(transform * 10) / 10;\n}\nfunction getMatrixStr(m) {\n    return 'matrix('\n        + round3(m[0]) + ','\n        + round3(m[1]) + ','\n        + round3(m[2]) + ','\n        + round3(m[3]) + ','\n        + round4(m[4]) + ','\n        + round4(m[5])\n        + ')';\n}\nvar TEXT_ALIGN_TO_ANCHOR = {\n    left: 'start',\n    right: 'end',\n    center: 'middle',\n    middle: 'middle'\n};\nfunction adjustTextY(y, lineHeight, textBaseline) {\n    if (textBaseline === 'top') {\n        y += lineHeight / 2;\n    }\n    else if (textBaseline === 'bottom') {\n        y -= lineHeight / 2;\n    }\n    return y;\n}\nfunction hasShadow(style) {\n    return style\n        && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY);\n}\nfunction getShadowKey(displayable) {\n    var style = displayable.style;\n    var globalScale = displayable.getGlobalScale();\n    return [\n        style.shadowColor,\n        (style.shadowBlur || 0).toFixed(2),\n        (style.shadowOffsetX || 0).toFixed(2),\n        (style.shadowOffsetY || 0).toFixed(2),\n        globalScale[0],\n        globalScale[1]\n    ].join(',');\n}\nfunction getClipPathsKey(clipPaths) {\n    var key = [];\n    if (clipPaths) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            key.push(clipPath.id);\n        }\n    }\n    return key.join(',');\n}\nfunction isImagePattern(val) {\n    return val && (!!val.image);\n}\nfunction isSVGPattern(val) {\n    return val && (!!val.svgElement);\n}\nfunction isPattern(val) {\n    return isImagePattern(val) || isSVGPattern(val);\n}\nfunction isLinearGradient(val) {\n    return val.type === 'linear';\n}\nfunction isRadialGradient(val) {\n    return val.type === 'radial';\n}\nfunction isGradient(val) {\n    return val && (val.type === 'linear'\n        || val.type === 'radial');\n}\nfunction getIdURL(id) {\n    return \"url(#\" + id + \")\";\n}\nfunction getPathPrecision(el) {\n    var scale = el.getGlobalScale();\n    var size = Math.max(scale[0], scale[1]);\n    return Math.max(Math.ceil(Math.log(size) / Math.log(10)), 1);\n}\nfunction getSRTTransformString(transform) {\n    var x = transform.x || 0;\n    var y = transform.y || 0;\n    var rotation = (transform.rotation || 0) * _core_util_js__WEBPACK_IMPORTED_MODULE_1__.RADIAN_TO_DEGREE;\n    var scaleX = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(transform.scaleX, 1);\n    var scaleY = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(transform.scaleY, 1);\n    var skewX = transform.skewX || 0;\n    var skewY = transform.skewY || 0;\n    var res = [];\n    if (x || y) {\n        res.push(\"translate(\" + x + \"px,\" + y + \"px)\");\n    }\n    if (rotation) {\n        res.push(\"rotate(\" + rotation + \")\");\n    }\n    if (scaleX !== 1 || scaleY !== 1) {\n        res.push(\"scale(\" + scaleX + \",\" + scaleY + \")\");\n    }\n    if (skewX || skewY) {\n        res.push(\"skew(\" + mathRound(skewX * _core_util_js__WEBPACK_IMPORTED_MODULE_1__.RADIAN_TO_DEGREE) + \"deg, \" + mathRound(skewY * _core_util_js__WEBPACK_IMPORTED_MODULE_1__.RADIAN_TO_DEGREE) + \"deg)\");\n    }\n    return res.join(' ');\n}\nvar encodeBase64 = (function () {\n    if (_core_env_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A.hasGlobalWindow && (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(window.btoa)) {\n        return function (str) {\n            return window.btoa(unescape(encodeURIComponent(str)));\n        };\n    }\n    if (typeof Buffer !== 'undefined') {\n        return function (str) {\n            return Buffer.from(str).toString('base64');\n        };\n    }\n    return function (str) {\n        if (false) {}\n        return null;\n    };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ1NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3N2Zy9oZWxwZXIuanM/NjZkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSQURJQU5fVE9fREVHUkVFLCByZXRyaWV2ZTIsIGxvZ0Vycm9yLCBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vY29yZS91dGlsLmpzJztcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAnLi4vdG9vbC9jb2xvci5qcyc7XG5pbXBvcnQgZW52IGZyb20gJy4uL2NvcmUvZW52LmpzJztcbnZhciBtYXRoUm91bmQgPSBNYXRoLnJvdW5kO1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gICAgdmFyIG9wYWNpdHk7XG4gICAgaWYgKCFjb2xvciB8fCBjb2xvciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICBjb2xvciA9ICdub25lJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyAmJiBjb2xvci5pbmRleE9mKCdyZ2JhJykgPiAtMSkge1xuICAgICAgICB2YXIgYXJyID0gcGFyc2UoY29sb3IpO1xuICAgICAgICBpZiAoYXJyKSB7XG4gICAgICAgICAgICBjb2xvciA9ICdyZ2IoJyArIGFyclswXSArICcsJyArIGFyclsxXSArICcsJyArIGFyclsyXSArICcpJztcbiAgICAgICAgICAgIG9wYWNpdHkgPSBhcnJbM107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBvcGFjaXR5OiBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eVxuICAgIH07XG59XG52YXIgRVBTSUxPTiA9IDFlLTQ7XG5leHBvcnQgZnVuY3Rpb24gaXNBcm91bmRaZXJvKHRyYW5zZm9ybSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm0gPCBFUFNJTE9OICYmIHRyYW5zZm9ybSA+IC1FUFNJTE9OO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kMyh0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gbWF0aFJvdW5kKHRyYW5zZm9ybSAqIDFlMykgLyAxZTM7XG59XG5leHBvcnQgZnVuY3Rpb24gcm91bmQ0KHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBtYXRoUm91bmQodHJhbnNmb3JtICogMWU0KSAvIDFlNDtcbn1cbmV4cG9ydCBmdW5jdGlvbiByb3VuZDEodHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIG1hdGhSb3VuZCh0cmFuc2Zvcm0gKiAxMCkgLyAxMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXRyaXhTdHIobSkge1xuICAgIHJldHVybiAnbWF0cml4KCdcbiAgICAgICAgKyByb3VuZDMobVswXSkgKyAnLCdcbiAgICAgICAgKyByb3VuZDMobVsxXSkgKyAnLCdcbiAgICAgICAgKyByb3VuZDMobVsyXSkgKyAnLCdcbiAgICAgICAgKyByb3VuZDMobVszXSkgKyAnLCdcbiAgICAgICAgKyByb3VuZDQobVs0XSkgKyAnLCdcbiAgICAgICAgKyByb3VuZDQobVs1XSlcbiAgICAgICAgKyAnKSc7XG59XG5leHBvcnQgdmFyIFRFWFRfQUxJR05fVE9fQU5DSE9SID0ge1xuICAgIGxlZnQ6ICdzdGFydCcsXG4gICAgcmlnaHQ6ICdlbmQnLFxuICAgIGNlbnRlcjogJ21pZGRsZScsXG4gICAgbWlkZGxlOiAnbWlkZGxlJ1xufTtcbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RUZXh0WSh5LCBsaW5lSGVpZ2h0LCB0ZXh0QmFzZWxpbmUpIHtcbiAgICBpZiAodGV4dEJhc2VsaW5lID09PSAndG9wJykge1xuICAgICAgICB5ICs9IGxpbmVIZWlnaHQgLyAyO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIHkgLT0gbGluZUhlaWdodCAvIDI7XG4gICAgfVxuICAgIHJldHVybiB5O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc1NoYWRvdyhzdHlsZSkge1xuICAgIHJldHVybiBzdHlsZVxuICAgICAgICAmJiAoc3R5bGUuc2hhZG93Qmx1ciB8fCBzdHlsZS5zaGFkb3dPZmZzZXRYIHx8IHN0eWxlLnNoYWRvd09mZnNldFkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYWRvd0tleShkaXNwbGF5YWJsZSkge1xuICAgIHZhciBzdHlsZSA9IGRpc3BsYXlhYmxlLnN0eWxlO1xuICAgIHZhciBnbG9iYWxTY2FsZSA9IGRpc3BsYXlhYmxlLmdldEdsb2JhbFNjYWxlKCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3R5bGUuc2hhZG93Q29sb3IsXG4gICAgICAgIChzdHlsZS5zaGFkb3dCbHVyIHx8IDApLnRvRml4ZWQoMiksXG4gICAgICAgIChzdHlsZS5zaGFkb3dPZmZzZXRYIHx8IDApLnRvRml4ZWQoMiksXG4gICAgICAgIChzdHlsZS5zaGFkb3dPZmZzZXRZIHx8IDApLnRvRml4ZWQoMiksXG4gICAgICAgIGdsb2JhbFNjYWxlWzBdLFxuICAgICAgICBnbG9iYWxTY2FsZVsxXVxuICAgIF0uam9pbignLCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENsaXBQYXRoc0tleShjbGlwUGF0aHMpIHtcbiAgICB2YXIga2V5ID0gW107XG4gICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuICAgICAgICAgICAga2V5LnB1c2goY2xpcFBhdGguaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXkuam9pbignLCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzSW1hZ2VQYXR0ZXJuKHZhbCkge1xuICAgIHJldHVybiB2YWwgJiYgKCEhdmFsLmltYWdlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1NWR1BhdHRlcm4odmFsKSB7XG4gICAgcmV0dXJuIHZhbCAmJiAoISF2YWwuc3ZnRWxlbWVudCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNQYXR0ZXJuKHZhbCkge1xuICAgIHJldHVybiBpc0ltYWdlUGF0dGVybih2YWwpIHx8IGlzU1ZHUGF0dGVybih2YWwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTGluZWFyR3JhZGllbnQodmFsKSB7XG4gICAgcmV0dXJuIHZhbC50eXBlID09PSAnbGluZWFyJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1JhZGlhbEdyYWRpZW50KHZhbCkge1xuICAgIHJldHVybiB2YWwudHlwZSA9PT0gJ3JhZGlhbCc7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNHcmFkaWVudCh2YWwpIHtcbiAgICByZXR1cm4gdmFsICYmICh2YWwudHlwZSA9PT0gJ2xpbmVhcidcbiAgICAgICAgfHwgdmFsLnR5cGUgPT09ICdyYWRpYWwnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRJZFVSTChpZCkge1xuICAgIHJldHVybiBcInVybCgjXCIgKyBpZCArIFwiKVwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhdGhQcmVjaXNpb24oZWwpIHtcbiAgICB2YXIgc2NhbGUgPSBlbC5nZXRHbG9iYWxTY2FsZSgpO1xuICAgIHZhciBzaXplID0gTWF0aC5tYXgoc2NhbGVbMF0sIHNjYWxlWzFdKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5jZWlsKE1hdGgubG9nKHNpemUpIC8gTWF0aC5sb2coMTApKSwgMSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U1JUVHJhbnNmb3JtU3RyaW5nKHRyYW5zZm9ybSkge1xuICAgIHZhciB4ID0gdHJhbnNmb3JtLnggfHwgMDtcbiAgICB2YXIgeSA9IHRyYW5zZm9ybS55IHx8IDA7XG4gICAgdmFyIHJvdGF0aW9uID0gKHRyYW5zZm9ybS5yb3RhdGlvbiB8fCAwKSAqIFJBRElBTl9UT19ERUdSRUU7XG4gICAgdmFyIHNjYWxlWCA9IHJldHJpZXZlMih0cmFuc2Zvcm0uc2NhbGVYLCAxKTtcbiAgICB2YXIgc2NhbGVZID0gcmV0cmlldmUyKHRyYW5zZm9ybS5zY2FsZVksIDEpO1xuICAgIHZhciBza2V3WCA9IHRyYW5zZm9ybS5za2V3WCB8fCAwO1xuICAgIHZhciBza2V3WSA9IHRyYW5zZm9ybS5za2V3WSB8fCAwO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBpZiAoeCB8fCB5KSB7XG4gICAgICAgIHJlcy5wdXNoKFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsXCIgKyB5ICsgXCJweClcIik7XG4gICAgfVxuICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICByZXMucHVzaChcInJvdGF0ZShcIiArIHJvdGF0aW9uICsgXCIpXCIpO1xuICAgIH1cbiAgICBpZiAoc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMSkge1xuICAgICAgICByZXMucHVzaChcInNjYWxlKFwiICsgc2NhbGVYICsgXCIsXCIgKyBzY2FsZVkgKyBcIilcIik7XG4gICAgfVxuICAgIGlmIChza2V3WCB8fCBza2V3WSkge1xuICAgICAgICByZXMucHVzaChcInNrZXcoXCIgKyBtYXRoUm91bmQoc2tld1ggKiBSQURJQU5fVE9fREVHUkVFKSArIFwiZGVnLCBcIiArIG1hdGhSb3VuZChza2V3WSAqIFJBRElBTl9UT19ERUdSRUUpICsgXCJkZWcpXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLmpvaW4oJyAnKTtcbn1cbmV4cG9ydCB2YXIgZW5jb2RlQmFzZTY0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW52Lmhhc0dsb2JhbFdpbmRvdyAmJiBpc0Z1bmN0aW9uKHdpbmRvdy5idG9hKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgbG9nRXJyb3IoJ0Jhc2U2NCBpc25cXCd0IG5hdGl2ZWx5IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3455\n")},18409:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ Painter)\n});\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/svg/helper.js\nvar helper = __webpack_require__(3455);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Path.js\nvar Path = __webpack_require__(59482);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Image.js\nvar graphic_Image = __webpack_require__(90540);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/contain/text.js\nvar contain_text = __webpack_require__(45558);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/TSpan.js\nvar TSpan = __webpack_require__(19845);\n;// ./node_modules/zrender/lib/svg/SVGPathRebuilder.js\n\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\nvar PI2 = Math.PI * 2;\nvar degree = 180 / PI;\nvar SVGPathRebuilder = (function () {\n    function SVGPathRebuilder() {\n    }\n    SVGPathRebuilder.prototype.reset = function (precision) {\n        this._start = true;\n        this._d = [];\n        this._str = '';\n        this._p = Math.pow(10, precision || 4);\n    };\n    SVGPathRebuilder.prototype.moveTo = function (x, y) {\n        this._add('M', x, y);\n    };\n    SVGPathRebuilder.prototype.lineTo = function (x, y) {\n        this._add('L', x, y);\n    };\n    SVGPathRebuilder.prototype.bezierCurveTo = function (x, y, x2, y2, x3, y3) {\n        this._add('C', x, y, x2, y2, x3, y3);\n    };\n    SVGPathRebuilder.prototype.quadraticCurveTo = function (x, y, x2, y2) {\n        this._add('Q', x, y, x2, y2);\n    };\n    SVGPathRebuilder.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n        this.ellipse(cx, cy, r, r, 0, startAngle, endAngle, anticlockwise);\n    };\n    SVGPathRebuilder.prototype.ellipse = function (cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise) {\n        var dTheta = endAngle - startAngle;\n        var clockwise = !anticlockwise;\n        var dThetaPositive = Math.abs(dTheta);\n        var isCircle = (0,helper/* isAroundZero */.Cv)(dThetaPositive - PI2)\n            || (clockwise ? dTheta >= PI2 : -dTheta >= PI2);\n        var unifiedTheta = dTheta > 0 ? dTheta % PI2 : (dTheta % PI2 + PI2);\n        var large = false;\n        if (isCircle) {\n            large = true;\n        }\n        else if ((0,helper/* isAroundZero */.Cv)(dThetaPositive)) {\n            large = false;\n        }\n        else {\n            large = (unifiedTheta >= PI) === !!clockwise;\n        }\n        var x0 = cx + rx * mathCos(startAngle);\n        var y0 = cy + ry * mathSin(startAngle);\n        if (this._start) {\n            this._add('M', x0, y0);\n        }\n        var xRot = Math.round(psi * degree);\n        if (isCircle) {\n            var p = 1 / this._p;\n            var dTheta_1 = (clockwise ? 1 : -1) * (PI2 - p);\n            this._add('A', rx, ry, xRot, 1, +clockwise, cx + rx * mathCos(startAngle + dTheta_1), cy + ry * mathSin(startAngle + dTheta_1));\n            if (p > 1e-2) {\n                this._add('A', rx, ry, xRot, 0, +clockwise, x0, y0);\n            }\n        }\n        else {\n            var x = cx + rx * mathCos(endAngle);\n            var y = cy + ry * mathSin(endAngle);\n            this._add('A', rx, ry, xRot, +large, +clockwise, x, y);\n        }\n    };\n    SVGPathRebuilder.prototype.rect = function (x, y, w, h) {\n        this._add('M', x, y);\n        this._add('l', w, 0);\n        this._add('l', 0, h);\n        this._add('l', -w, 0);\n        this._add('Z');\n    };\n    SVGPathRebuilder.prototype.closePath = function () {\n        if (this._d.length > 0) {\n            this._add('Z');\n        }\n    };\n    SVGPathRebuilder.prototype._add = function (cmd, a, b, c, d, e, f, g, h) {\n        var vals = [];\n        var p = this._p;\n        for (var i = 1; i < arguments.length; i++) {\n            var val = arguments[i];\n            if (isNaN(val)) {\n                this._invalid = true;\n                return;\n            }\n            vals.push(Math.round(val * p) / p);\n        }\n        this._d.push(cmd + vals.join(' '));\n        this._start = cmd === 'Z';\n    };\n    SVGPathRebuilder.prototype.generateStr = function () {\n        this._str = this._invalid ? '' : this._d.join('');\n        this._d = [];\n    };\n    SVGPathRebuilder.prototype.getStr = function () {\n        return this._str;\n    };\n    return SVGPathRebuilder;\n}());\n/* harmony default export */ const svg_SVGPathRebuilder = (SVGPathRebuilder);\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/canvas/dashStyle.js\nvar dashStyle = __webpack_require__(76050);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n;// ./node_modules/zrender/lib/svg/mapStyleToAttrs.js\n\n\n\n\n\nvar NONE = 'none';\nvar mathRound = Math.round;\nfunction pathHasFill(style) {\n    var fill = style.fill;\n    return fill != null && fill !== NONE;\n}\nfunction pathHasStroke(style) {\n    var stroke = style.stroke;\n    return stroke != null && stroke !== NONE;\n}\nvar strokeProps = ['lineCap', 'miterLimit', 'lineJoin'];\nvar svgStrokeProps = (0,util.map)(strokeProps, function (prop) { return \"stroke-\" + prop.toLowerCase(); });\nfunction mapStyleToAttrs(updateAttr, style, el, forceUpdate) {\n    var opacity = style.opacity == null ? 1 : style.opacity;\n    if (el instanceof graphic_Image/* default */.Ay) {\n        updateAttr('opacity', opacity);\n        return;\n    }\n    if (pathHasFill(style)) {\n        var fill = (0,helper/* normalizeColor */.$2)(style.fill);\n        updateAttr('fill', fill.color);\n        var fillOpacity = style.fillOpacity != null\n            ? style.fillOpacity * fill.opacity * opacity\n            : fill.opacity * opacity;\n        if (forceUpdate || fillOpacity < 1) {\n            updateAttr('fill-opacity', fillOpacity);\n        }\n    }\n    else {\n        updateAttr('fill', NONE);\n    }\n    if (pathHasStroke(style)) {\n        var stroke = (0,helper/* normalizeColor */.$2)(style.stroke);\n        updateAttr('stroke', stroke.color);\n        var strokeScale = style.strokeNoScale\n            ? el.getLineScale()\n            : 1;\n        var strokeWidth = (strokeScale ? (style.lineWidth || 0) / strokeScale : 0);\n        var strokeOpacity = style.strokeOpacity != null\n            ? style.strokeOpacity * stroke.opacity * opacity\n            : stroke.opacity * opacity;\n        var strokeFirst = style.strokeFirst;\n        if (forceUpdate || strokeWidth !== 1) {\n            updateAttr('stroke-width', strokeWidth);\n        }\n        if (forceUpdate || strokeFirst) {\n            updateAttr('paint-order', strokeFirst ? 'stroke' : 'fill');\n        }\n        if (forceUpdate || strokeOpacity < 1) {\n            updateAttr('stroke-opacity', strokeOpacity);\n        }\n        if (style.lineDash) {\n            var _a = (0,dashStyle/* getLineDash */.V)(el), lineDash = _a[0], lineDashOffset = _a[1];\n            if (lineDash) {\n                lineDashOffset = mathRound(lineDashOffset || 0);\n                updateAttr('stroke-dasharray', lineDash.join(','));\n                if (lineDashOffset || forceUpdate) {\n                    updateAttr('stroke-dashoffset', lineDashOffset);\n                }\n            }\n        }\n        else if (forceUpdate) {\n            updateAttr('stroke-dasharray', NONE);\n        }\n        for (var i = 0; i < strokeProps.length; i++) {\n            var propName = strokeProps[i];\n            if (forceUpdate || style[propName] !== Path/* DEFAULT_PATH_STYLE */.MW[propName]) {\n                var val = style[propName] || Path/* DEFAULT_PATH_STYLE */.MW[propName];\n                val && updateAttr(svgStrokeProps[i], val);\n            }\n        }\n    }\n    else if (forceUpdate) {\n        updateAttr('stroke', NONE);\n    }\n}\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/dom.js + 1 modules\nvar dom = __webpack_require__(29687);\n;// ./node_modules/zrender/lib/svg/core.js\n\n\nvar SVGNS = 'http://www.w3.org/2000/svg';\nvar XLINKNS = 'http://www.w3.org/1999/xlink';\nvar XMLNS = 'http://www.w3.org/2000/xmlns/';\nvar XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\nvar META_DATA_PREFIX = 'ecmeta_';\nfunction createElement(name) {\n    return document.createElementNS(SVGNS, name);\n}\n;\nfunction createVNode(tag, key, attrs, children, text) {\n    return {\n        tag: tag,\n        attrs: attrs || {},\n        children: children,\n        text: text,\n        key: key\n    };\n}\nfunction createElementOpen(name, attrs) {\n    var attrsStr = [];\n    if (attrs) {\n        for (var key in attrs) {\n            var val = attrs[key];\n            var part = key;\n            if (val === false) {\n                continue;\n            }\n            else if (val !== true && val != null) {\n                part += \"=\\\"\" + val + \"\\\"\";\n            }\n            attrsStr.push(part);\n        }\n    }\n    return \"<\" + name + \" \" + attrsStr.join(' ') + \">\";\n}\nfunction createElementClose(name) {\n    return \"</\" + name + \">\";\n}\nfunction vNodeToString(el, opts) {\n    opts = opts || {};\n    var S = opts.newline ? '\\n' : '';\n    function convertElToString(el) {\n        var children = el.children, tag = el.tag, attrs = el.attrs, text = el.text;\n        return createElementOpen(tag, attrs)\n            + (tag !== 'style' ? (0,dom/* encodeHTML */.Me)(text) : text || '')\n            + (children ? \"\" + S + (0,util.map)(children, function (child) { return convertElToString(child); }).join(S) + S : '')\n            + createElementClose(tag);\n    }\n    return convertElToString(el);\n}\nfunction getCssString(selectorNodes, animationNodes, opts) {\n    opts = opts || {};\n    var S = opts.newline ? '\\n' : '';\n    var bracketBegin = \" {\" + S;\n    var bracketEnd = S + \"}\";\n    var selectors = (0,util.map)((0,util.keys)(selectorNodes), function (className) {\n        return className + bracketBegin + (0,util.map)((0,util.keys)(selectorNodes[className]), function (attrName) {\n            return attrName + \":\" + selectorNodes[className][attrName] + \";\";\n        }).join(S) + bracketEnd;\n    }).join(S);\n    var animations = (0,util.map)((0,util.keys)(animationNodes), function (animationName) {\n        return \"@keyframes \" + animationName + bracketBegin + (0,util.map)((0,util.keys)(animationNodes[animationName]), function (percent) {\n            return percent + bracketBegin + (0,util.map)((0,util.keys)(animationNodes[animationName][percent]), function (attrName) {\n                var val = animationNodes[animationName][percent][attrName];\n                if (attrName === 'd') {\n                    val = \"path(\\\"\" + val + \"\\\")\";\n                }\n                return attrName + \":\" + val + \";\";\n            }).join(S) + bracketEnd;\n        }).join(S) + bracketEnd;\n    }).join(S);\n    if (!selectors && !animations) {\n        return '';\n    }\n    return ['<![CDATA[', selectors, animations, ']]>'].join(S);\n}\nfunction createBrushScope(zrId) {\n    return {\n        zrId: zrId,\n        shadowCache: {},\n        patternCache: {},\n        gradientCache: {},\n        clipPathCache: {},\n        defs: {},\n        cssNodes: {},\n        cssAnims: {},\n        cssStyleCache: {},\n        cssAnimIdx: 0,\n        shadowIdx: 0,\n        gradientIdx: 0,\n        patternIdx: 0,\n        clipPathIdx: 0\n    };\n}\nfunction createSVGVNode(width, height, children, useViewBox) {\n    return createVNode('svg', 'root', {\n        'width': width,\n        'height': height,\n        'xmlns': SVGNS,\n        'xmlns:xlink': XLINKNS,\n        'version': '1.1',\n        'baseProfile': 'full',\n        'viewBox': useViewBox ? \"0 0 \" + width + \" \" + height : false\n    }, children);\n}\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/helper/image.js\nvar helper_image = __webpack_require__(12191);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/Transformable.js\nvar Transformable = __webpack_require__(92836);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/PathProxy.js\nvar PathProxy = __webpack_require__(68717);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/CompoundPath.js\nvar CompoundPath = __webpack_require__(82591);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/animation/cubicEasing.js\nvar cubicEasing = __webpack_require__(96320);\n;// ./node_modules/zrender/lib/svg/cssClassId.js\nvar cssClassIdx = 0;\nfunction getClassId() {\n    return cssClassIdx++;\n}\n\n;// ./node_modules/zrender/lib/svg/cssAnimation.js\n\n\n\n\n\n\n\n\n\nvar EASING_MAP = {\n    cubicIn: '0.32,0,0.67,0',\n    cubicOut: '0.33,1,0.68,1',\n    cubicInOut: '0.65,0,0.35,1',\n    quadraticIn: '0.11,0,0.5,0',\n    quadraticOut: '0.5,1,0.89,1',\n    quadraticInOut: '0.45,0,0.55,1',\n    quarticIn: '0.5,0,0.75,0',\n    quarticOut: '0.25,1,0.5,1',\n    quarticInOut: '0.76,0,0.24,1',\n    quinticIn: '0.64,0,0.78,0',\n    quinticOut: '0.22,1,0.36,1',\n    quinticInOut: '0.83,0,0.17,1',\n    sinusoidalIn: '0.12,0,0.39,0',\n    sinusoidalOut: '0.61,1,0.88,1',\n    sinusoidalInOut: '0.37,0,0.63,1',\n    exponentialIn: '0.7,0,0.84,0',\n    exponentialOut: '0.16,1,0.3,1',\n    exponentialInOut: '0.87,0,0.13,1',\n    circularIn: '0.55,0,1,0.45',\n    circularOut: '0,0.55,0.45,1',\n    circularInOut: '0.85,0,0.15,1'\n};\nvar transformOriginKey = 'transform-origin';\nfunction buildPathString(el, kfShape, path) {\n    var shape = (0,util.extend)({}, el.shape);\n    (0,util.extend)(shape, kfShape);\n    el.buildPath(path, shape);\n    var svgPathBuilder = new svg_SVGPathRebuilder();\n    svgPathBuilder.reset((0,helper/* getPathPrecision */.MD)(el));\n    path.rebuildPath(svgPathBuilder, 1);\n    svgPathBuilder.generateStr();\n    return svgPathBuilder.getStr();\n}\nfunction setTransformOrigin(target, transform) {\n    var originX = transform.originX, originY = transform.originY;\n    if (originX || originY) {\n        target[transformOriginKey] = originX + \"px \" + originY + \"px\";\n    }\n}\nvar ANIMATE_STYLE_MAP = {\n    fill: 'fill',\n    opacity: 'opacity',\n    lineWidth: 'stroke-width',\n    lineDashOffset: 'stroke-dashoffset'\n};\nfunction addAnimation(cssAnim, scope) {\n    var animationName = scope.zrId + '-ani-' + scope.cssAnimIdx++;\n    scope.cssAnims[animationName] = cssAnim;\n    return animationName;\n}\nfunction createCompoundPathCSSAnimation(el, attrs, scope) {\n    var paths = el.shape.paths;\n    var composedAnim = {};\n    var cssAnimationCfg;\n    var cssAnimationName;\n    (0,util.each)(paths, function (path) {\n        var subScope = createBrushScope(scope.zrId);\n        subScope.animation = true;\n        createCSSAnimation(path, {}, subScope, true);\n        var cssAnims = subScope.cssAnims;\n        var cssNodes = subScope.cssNodes;\n        var animNames = (0,util.keys)(cssAnims);\n        var len = animNames.length;\n        if (!len) {\n            return;\n        }\n        cssAnimationName = animNames[len - 1];\n        var lastAnim = cssAnims[cssAnimationName];\n        for (var percent in lastAnim) {\n            var kf = lastAnim[percent];\n            composedAnim[percent] = composedAnim[percent] || { d: '' };\n            composedAnim[percent].d += kf.d || '';\n        }\n        for (var className in cssNodes) {\n            var val = cssNodes[className].animation;\n            if (val.indexOf(cssAnimationName) >= 0) {\n                cssAnimationCfg = val;\n            }\n        }\n    });\n    if (!cssAnimationCfg) {\n        return;\n    }\n    attrs.d = false;\n    var animationName = addAnimation(composedAnim, scope);\n    return cssAnimationCfg.replace(cssAnimationName, animationName);\n}\nfunction getEasingFunc(easing) {\n    return (0,util.isString)(easing)\n        ? EASING_MAP[easing]\n            ? \"cubic-bezier(\" + EASING_MAP[easing] + \")\"\n            : (0,cubicEasing/* createCubicEasingFunc */.w)(easing) ? easing : ''\n        : '';\n}\nfunction createCSSAnimation(el, attrs, scope, onlyShape) {\n    var animators = el.animators;\n    var len = animators.length;\n    var cssAnimations = [];\n    if (el instanceof CompoundPath/* default */.A) {\n        var animationCfg = createCompoundPathCSSAnimation(el, attrs, scope);\n        if (animationCfg) {\n            cssAnimations.push(animationCfg);\n        }\n        else if (!len) {\n            return;\n        }\n    }\n    else if (!len) {\n        return;\n    }\n    var groupAnimators = {};\n    for (var i = 0; i < len; i++) {\n        var animator = animators[i];\n        var cfgArr = [animator.getMaxTime() / 1000 + 's'];\n        var easing = getEasingFunc(animator.getClip().easing);\n        var delay = animator.getDelay();\n        if (easing) {\n            cfgArr.push(easing);\n        }\n        else {\n            cfgArr.push('linear');\n        }\n        if (delay) {\n            cfgArr.push(delay / 1000 + 's');\n        }\n        if (animator.getLoop()) {\n            cfgArr.push('infinite');\n        }\n        var cfg = cfgArr.join(' ');\n        groupAnimators[cfg] = groupAnimators[cfg] || [cfg, []];\n        groupAnimators[cfg][1].push(animator);\n    }\n    function createSingleCSSAnimation(groupAnimator) {\n        var animators = groupAnimator[1];\n        var len = animators.length;\n        var transformKfs = {};\n        var shapeKfs = {};\n        var finalKfs = {};\n        var animationTimingFunctionAttrName = 'animation-timing-function';\n        function saveAnimatorTrackToCssKfs(animator, cssKfs, toCssAttrName) {\n            var tracks = animator.getTracks();\n            var maxTime = animator.getMaxTime();\n            for (var k = 0; k < tracks.length; k++) {\n                var track = tracks[k];\n                if (track.needsAnimate()) {\n                    var kfs = track.keyframes;\n                    var attrName = track.propName;\n                    toCssAttrName && (attrName = toCssAttrName(attrName));\n                    if (attrName) {\n                        for (var i = 0; i < kfs.length; i++) {\n                            var kf = kfs[i];\n                            var percent = Math.round(kf.time / maxTime * 100) + '%';\n                            var kfEasing = getEasingFunc(kf.easing);\n                            var rawValue = kf.rawValue;\n                            if ((0,util.isString)(rawValue) || (0,util.isNumber)(rawValue)) {\n                                cssKfs[percent] = cssKfs[percent] || {};\n                                cssKfs[percent][attrName] = kf.rawValue;\n                                if (kfEasing) {\n                                    cssKfs[percent][animationTimingFunctionAttrName] = kfEasing;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for (var i = 0; i < len; i++) {\n            var animator = animators[i];\n            var targetProp = animator.targetName;\n            if (!targetProp) {\n                !onlyShape && saveAnimatorTrackToCssKfs(animator, transformKfs);\n            }\n            else if (targetProp === 'shape') {\n                saveAnimatorTrackToCssKfs(animator, shapeKfs);\n            }\n        }\n        for (var percent in transformKfs) {\n            var transform = {};\n            (0,Transformable/* copyTransform */.IT)(transform, el);\n            (0,util.extend)(transform, transformKfs[percent]);\n            var str = (0,helper/* getSRTTransformString */.Z1)(transform);\n            var timingFunction = transformKfs[percent][animationTimingFunctionAttrName];\n            finalKfs[percent] = str ? {\n                transform: str\n            } : {};\n            setTransformOrigin(finalKfs[percent], transform);\n            if (timingFunction) {\n                finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;\n            }\n        }\n        ;\n        var path;\n        var canAnimateShape = true;\n        for (var percent in shapeKfs) {\n            finalKfs[percent] = finalKfs[percent] || {};\n            var isFirst = !path;\n            var timingFunction = shapeKfs[percent][animationTimingFunctionAttrName];\n            if (isFirst) {\n                path = new PathProxy/* default */.A();\n            }\n            var len_1 = path.len();\n            path.reset();\n            finalKfs[percent].d = buildPathString(el, shapeKfs[percent], path);\n            var newLen = path.len();\n            if (!isFirst && len_1 !== newLen) {\n                canAnimateShape = false;\n                break;\n            }\n            if (timingFunction) {\n                finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;\n            }\n        }\n        ;\n        if (!canAnimateShape) {\n            for (var percent in finalKfs) {\n                delete finalKfs[percent].d;\n            }\n        }\n        if (!onlyShape) {\n            for (var i = 0; i < len; i++) {\n                var animator = animators[i];\n                var targetProp = animator.targetName;\n                if (targetProp === 'style') {\n                    saveAnimatorTrackToCssKfs(animator, finalKfs, function (propName) { return ANIMATE_STYLE_MAP[propName]; });\n                }\n            }\n        }\n        var percents = (0,util.keys)(finalKfs);\n        var allTransformOriginSame = true;\n        var transformOrigin;\n        for (var i = 1; i < percents.length; i++) {\n            var p0 = percents[i - 1];\n            var p1 = percents[i];\n            if (finalKfs[p0][transformOriginKey] !== finalKfs[p1][transformOriginKey]) {\n                allTransformOriginSame = false;\n                break;\n            }\n            transformOrigin = finalKfs[p0][transformOriginKey];\n        }\n        if (allTransformOriginSame && transformOrigin) {\n            for (var percent in finalKfs) {\n                if (finalKfs[percent][transformOriginKey]) {\n                    delete finalKfs[percent][transformOriginKey];\n                }\n            }\n            attrs[transformOriginKey] = transformOrigin;\n        }\n        if ((0,util.filter)(percents, function (percent) { return (0,util.keys)(finalKfs[percent]).length > 0; }).length) {\n            var animationName = addAnimation(finalKfs, scope);\n            return animationName + \" \" + groupAnimator[0] + \" both\";\n        }\n    }\n    for (var key in groupAnimators) {\n        var animationCfg = createSingleCSSAnimation(groupAnimators[key]);\n        if (animationCfg) {\n            cssAnimations.push(animationCfg);\n        }\n    }\n    if (cssAnimations.length) {\n        var className = scope.zrId + '-cls-' + getClassId();\n        scope.cssNodes['.' + className] = {\n            animation: cssAnimations.join(',')\n        };\n        attrs[\"class\"] = className;\n    }\n}\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/platform.js\nvar platform = __webpack_require__(59741);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/tool/color.js\nvar color = __webpack_require__(47698);\n;// ./node_modules/zrender/lib/svg/cssEmphasis.js\n\n\nfunction createCSSEmphasis(el, attrs, scope) {\n    if (!el.ignore) {\n        if (el.isSilent()) {\n            var style = {\n                'pointer-events': 'none'\n            };\n            setClassAttribute(style, attrs, scope, true);\n        }\n        else {\n            var emphasisStyle = el.states.emphasis && el.states.emphasis.style\n                ? el.states.emphasis.style\n                : {};\n            var fill = emphasisStyle.fill;\n            if (!fill) {\n                var normalFill = el.style && el.style.fill;\n                var selectFill = el.states.select\n                    && el.states.select.style\n                    && el.states.select.style.fill;\n                var fromFill = el.currentStates.indexOf('select') >= 0\n                    ? (selectFill || normalFill)\n                    : normalFill;\n                if (fromFill) {\n                    fill = (0,color.liftColor)(fromFill);\n                }\n            }\n            var lineWidth = emphasisStyle.lineWidth;\n            if (lineWidth) {\n                var scaleX = (!emphasisStyle.strokeNoScale && el.transform)\n                    ? el.transform[0]\n                    : 1;\n                lineWidth = lineWidth / scaleX;\n            }\n            var style = {\n                cursor: 'pointer'\n            };\n            if (fill) {\n                style.fill = fill;\n            }\n            if (emphasisStyle.stroke) {\n                style.stroke = emphasisStyle.stroke;\n            }\n            if (lineWidth) {\n                style['stroke-width'] = lineWidth;\n            }\n            setClassAttribute(style, attrs, scope, true);\n        }\n    }\n}\nfunction setClassAttribute(style, attrs, scope, withHover) {\n    var styleKey = JSON.stringify(style);\n    var className = scope.cssStyleCache[styleKey];\n    if (!className) {\n        className = scope.zrId + '-cls-' + getClassId();\n        scope.cssStyleCache[styleKey] = className;\n        scope.cssNodes['.' + className + (withHover ? ':hover' : '')] = style;\n    }\n    attrs[\"class\"] = attrs[\"class\"] ? (attrs[\"class\"] + ' ' + className) : className;\n}\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/zrender.js\nvar zrender = __webpack_require__(33572);\n;// ./node_modules/zrender/lib/svg/graphic.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar round = Math.round;\nfunction isImageLike(val) {\n    return val && (0,util.isString)(val.src);\n}\nfunction isCanvasLike(val) {\n    return val && (0,util.isFunction)(val.toDataURL);\n}\nfunction setStyleAttrs(attrs, style, el, scope) {\n    mapStyleToAttrs(function (key, val) {\n        var isFillStroke = key === 'fill' || key === 'stroke';\n        if (isFillStroke && (0,helper/* isGradient */.bn)(val)) {\n            setGradient(style, attrs, key, scope);\n        }\n        else if (isFillStroke && (0,helper/* isPattern */.Pt)(val)) {\n            setPattern(el, attrs, key, scope);\n        }\n        else {\n            attrs[key] = val;\n        }\n        if (isFillStroke && scope.ssr && val === 'none') {\n            attrs['pointer-events'] = 'visible';\n        }\n    }, style, el, false);\n    setShadow(el, attrs, scope);\n}\nfunction setMetaData(attrs, el) {\n    var metaData = (0,zrender.getElementSSRData)(el);\n    if (metaData) {\n        metaData.each(function (val, key) {\n            val != null && (attrs[(META_DATA_PREFIX + key).toLowerCase()] = val + '');\n        });\n        if (el.isSilent()) {\n            attrs[META_DATA_PREFIX + 'silent'] = 'true';\n        }\n    }\n}\nfunction noRotateScale(m) {\n    return (0,helper/* isAroundZero */.Cv)(m[0] - 1)\n        && (0,helper/* isAroundZero */.Cv)(m[1])\n        && (0,helper/* isAroundZero */.Cv)(m[2])\n        && (0,helper/* isAroundZero */.Cv)(m[3] - 1);\n}\nfunction noTranslate(m) {\n    return (0,helper/* isAroundZero */.Cv)(m[4]) && (0,helper/* isAroundZero */.Cv)(m[5]);\n}\nfunction setTransform(attrs, m, compress) {\n    if (m && !(noTranslate(m) && noRotateScale(m))) {\n        var mul = compress ? 10 : 1e4;\n        attrs.transform = noRotateScale(m)\n            ? \"translate(\" + round(m[4] * mul) / mul + \" \" + round(m[5] * mul) / mul + \")\" : (0,helper/* getMatrixStr */.nV)(m);\n    }\n}\nfunction convertPolyShape(shape, attrs, mul) {\n    var points = shape.points;\n    var strArr = [];\n    for (var i = 0; i < points.length; i++) {\n        strArr.push(round(points[i][0] * mul) / mul);\n        strArr.push(round(points[i][1] * mul) / mul);\n    }\n    attrs.points = strArr.join(' ');\n}\nfunction validatePolyShape(shape) {\n    return !shape.smooth;\n}\nfunction createAttrsConvert(desc) {\n    var normalizedDesc = (0,util.map)(desc, function (item) {\n        return (typeof item === 'string' ? [item, item] : item);\n    });\n    return function (shape, attrs, mul) {\n        for (var i = 0; i < normalizedDesc.length; i++) {\n            var item = normalizedDesc[i];\n            var val = shape[item[0]];\n            if (val != null) {\n                attrs[item[1]] = round(val * mul) / mul;\n            }\n        }\n    };\n}\nvar builtinShapesDef = {\n    circle: [createAttrsConvert(['cx', 'cy', 'r'])],\n    polyline: [convertPolyShape, validatePolyShape],\n    polygon: [convertPolyShape, validatePolyShape]\n};\nfunction hasShapeAnimation(el) {\n    var animators = el.animators;\n    for (var i = 0; i < animators.length; i++) {\n        if (animators[i].targetName === 'shape') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction brushSVGPath(el, scope) {\n    var style = el.style;\n    var shape = el.shape;\n    var builtinShpDef = builtinShapesDef[el.type];\n    var attrs = {};\n    var needsAnimate = scope.animation;\n    var svgElType = 'path';\n    var strokePercent = el.style.strokePercent;\n    var precision = (scope.compress && (0,helper/* getPathPrecision */.MD)(el)) || 4;\n    if (builtinShpDef\n        && !scope.willUpdate\n        && !(builtinShpDef[1] && !builtinShpDef[1](shape))\n        && !(needsAnimate && hasShapeAnimation(el))\n        && !(strokePercent < 1)) {\n        svgElType = el.type;\n        var mul = Math.pow(10, precision);\n        builtinShpDef[0](shape, attrs, mul);\n    }\n    else {\n        var needBuildPath = !el.path || el.shapeChanged();\n        if (!el.path) {\n            el.createPathProxy();\n        }\n        var path = el.path;\n        if (needBuildPath) {\n            path.beginPath();\n            el.buildPath(path, el.shape);\n            el.pathUpdated();\n        }\n        var pathVersion = path.getVersion();\n        var elExt = el;\n        var svgPathBuilder = elExt.__svgPathBuilder;\n        if (elExt.__svgPathVersion !== pathVersion\n            || !svgPathBuilder\n            || strokePercent !== elExt.__svgPathStrokePercent) {\n            if (!svgPathBuilder) {\n                svgPathBuilder = elExt.__svgPathBuilder = new svg_SVGPathRebuilder();\n            }\n            svgPathBuilder.reset(precision);\n            path.rebuildPath(svgPathBuilder, strokePercent);\n            svgPathBuilder.generateStr();\n            elExt.__svgPathVersion = pathVersion;\n            elExt.__svgPathStrokePercent = strokePercent;\n        }\n        attrs.d = svgPathBuilder.getStr();\n    }\n    setTransform(attrs, el.transform);\n    setStyleAttrs(attrs, style, el, scope);\n    setMetaData(attrs, el);\n    scope.animation && createCSSAnimation(el, attrs, scope);\n    scope.emphasis && createCSSEmphasis(el, attrs, scope);\n    return createVNode(svgElType, el.id + '', attrs);\n}\nfunction brushSVGImage(el, scope) {\n    var style = el.style;\n    var image = style.image;\n    if (image && !(0,util.isString)(image)) {\n        if (isImageLike(image)) {\n            image = image.src;\n        }\n        else if (isCanvasLike(image)) {\n            image = image.toDataURL();\n        }\n    }\n    if (!image) {\n        return;\n    }\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var dw = style.width;\n    var dh = style.height;\n    var attrs = {\n        href: image,\n        width: dw,\n        height: dh\n    };\n    if (x) {\n        attrs.x = x;\n    }\n    if (y) {\n        attrs.y = y;\n    }\n    setTransform(attrs, el.transform);\n    setStyleAttrs(attrs, style, el, scope);\n    setMetaData(attrs, el);\n    scope.animation && createCSSAnimation(el, attrs, scope);\n    return createVNode('image', el.id + '', attrs);\n}\n;\nfunction brushSVGTSpan(el, scope) {\n    var style = el.style;\n    var text = style.text;\n    text != null && (text += '');\n    if (!text || isNaN(style.x) || isNaN(style.y)) {\n        return;\n    }\n    var font = style.font || platform/* DEFAULT_FONT */.OH;\n    var x = style.x || 0;\n    var y = (0,helper/* adjustTextY */.sZ)(style.y || 0, (0,contain_text/* getLineHeight */.ks)(font), style.textBaseline);\n    var textAlign = helper/* TEXT_ALIGN_TO_ANCHOR */.eQ[style.textAlign]\n        || style.textAlign;\n    var attrs = {\n        'dominant-baseline': 'central',\n        'text-anchor': textAlign\n    };\n    if ((0,Text/* hasSeparateFont */.XE)(style)) {\n        var separatedFontStr = '';\n        var fontStyle = style.fontStyle;\n        var fontSize = (0,Text/* parseFontSize */.I5)(style.fontSize);\n        if (!parseFloat(fontSize)) {\n            return;\n        }\n        var fontFamily = style.fontFamily || platform/* DEFAULT_FONT_FAMILY */.zs;\n        var fontWeight = style.fontWeight;\n        separatedFontStr += \"font-size:\" + fontSize + \";font-family:\" + fontFamily + \";\";\n        if (fontStyle && fontStyle !== 'normal') {\n            separatedFontStr += \"font-style:\" + fontStyle + \";\";\n        }\n        if (fontWeight && fontWeight !== 'normal') {\n            separatedFontStr += \"font-weight:\" + fontWeight + \";\";\n        }\n        attrs.style = separatedFontStr;\n    }\n    else {\n        attrs.style = \"font: \" + font;\n    }\n    if (text.match(/\\s/)) {\n        attrs['xml:space'] = 'preserve';\n    }\n    if (x) {\n        attrs.x = x;\n    }\n    if (y) {\n        attrs.y = y;\n    }\n    setTransform(attrs, el.transform);\n    setStyleAttrs(attrs, style, el, scope);\n    setMetaData(attrs, el);\n    scope.animation && createCSSAnimation(el, attrs, scope);\n    return createVNode('text', el.id + '', attrs, undefined, text);\n}\nfunction brush(el, scope) {\n    if (el instanceof Path/* default */.Ay) {\n        return brushSVGPath(el, scope);\n    }\n    else if (el instanceof graphic_Image/* default */.Ay) {\n        return brushSVGImage(el, scope);\n    }\n    else if (el instanceof TSpan/* default */.A) {\n        return brushSVGTSpan(el, scope);\n    }\n}\nfunction setShadow(el, attrs, scope) {\n    var style = el.style;\n    if ((0,helper/* hasShadow */.dX)(style)) {\n        var shadowKey = (0,helper/* getShadowKey */.si)(el);\n        var shadowCache = scope.shadowCache;\n        var shadowId = shadowCache[shadowKey];\n        if (!shadowId) {\n            var globalScale = el.getGlobalScale();\n            var scaleX = globalScale[0];\n            var scaleY = globalScale[1];\n            if (!scaleX || !scaleY) {\n                return;\n            }\n            var offsetX = style.shadowOffsetX || 0;\n            var offsetY = style.shadowOffsetY || 0;\n            var blur_1 = style.shadowBlur;\n            var _a = (0,helper/* normalizeColor */.$2)(style.shadowColor), opacity = _a.opacity, color = _a.color;\n            var stdDx = blur_1 / 2 / scaleX;\n            var stdDy = blur_1 / 2 / scaleY;\n            var stdDeviation = stdDx + ' ' + stdDy;\n            shadowId = scope.zrId + '-s' + scope.shadowIdx++;\n            scope.defs[shadowId] = createVNode('filter', shadowId, {\n                'id': shadowId,\n                'x': '-100%',\n                'y': '-100%',\n                'width': '300%',\n                'height': '300%'\n            }, [\n                createVNode('feDropShadow', '', {\n                    'dx': offsetX / scaleX,\n                    'dy': offsetY / scaleY,\n                    'stdDeviation': stdDeviation,\n                    'flood-color': color,\n                    'flood-opacity': opacity\n                })\n            ]);\n            shadowCache[shadowKey] = shadowId;\n        }\n        attrs.filter = (0,helper/* getIdURL */.Xu)(shadowId);\n    }\n}\nfunction setGradient(style, attrs, target, scope) {\n    var val = style[target];\n    var gradientTag;\n    var gradientAttrs = {\n        'gradientUnits': val.global\n            ? 'userSpaceOnUse'\n            : 'objectBoundingBox'\n    };\n    if ((0,helper/* isLinearGradient */.OS)(val)) {\n        gradientTag = 'linearGradient';\n        gradientAttrs.x1 = val.x;\n        gradientAttrs.y1 = val.y;\n        gradientAttrs.x2 = val.x2;\n        gradientAttrs.y2 = val.y2;\n    }\n    else if ((0,helper/* isRadialGradient */.OH)(val)) {\n        gradientTag = 'radialGradient';\n        gradientAttrs.cx = (0,util.retrieve2)(val.x, 0.5);\n        gradientAttrs.cy = (0,util.retrieve2)(val.y, 0.5);\n        gradientAttrs.r = (0,util.retrieve2)(val.r, 0.5);\n    }\n    else {\n        if (false) {}\n        return;\n    }\n    var colors = val.colorStops;\n    var colorStops = [];\n    for (var i = 0, len = colors.length; i < len; ++i) {\n        var offset = (0,helper/* round4 */.XP)(colors[i].offset) * 100 + '%';\n        var stopColor = colors[i].color;\n        var _a = (0,helper/* normalizeColor */.$2)(stopColor), color = _a.color, opacity = _a.opacity;\n        var stopsAttrs = {\n            'offset': offset\n        };\n        stopsAttrs['stop-color'] = color;\n        if (opacity < 1) {\n            stopsAttrs['stop-opacity'] = opacity;\n        }\n        colorStops.push(createVNode('stop', i + '', stopsAttrs));\n    }\n    var gradientVNode = createVNode(gradientTag, '', gradientAttrs, colorStops);\n    var gradientKey = vNodeToString(gradientVNode);\n    var gradientCache = scope.gradientCache;\n    var gradientId = gradientCache[gradientKey];\n    if (!gradientId) {\n        gradientId = scope.zrId + '-g' + scope.gradientIdx++;\n        gradientCache[gradientKey] = gradientId;\n        gradientAttrs.id = gradientId;\n        scope.defs[gradientId] = createVNode(gradientTag, gradientId, gradientAttrs, colorStops);\n    }\n    attrs[target] = (0,helper/* getIdURL */.Xu)(gradientId);\n}\nfunction setPattern(el, attrs, target, scope) {\n    var val = el.style[target];\n    var boundingRect = el.getBoundingRect();\n    var patternAttrs = {};\n    var repeat = val.repeat;\n    var noRepeat = repeat === 'no-repeat';\n    var repeatX = repeat === 'repeat-x';\n    var repeatY = repeat === 'repeat-y';\n    var child;\n    if ((0,helper/* isImagePattern */.sL)(val)) {\n        var imageWidth_1 = val.imageWidth;\n        var imageHeight_1 = val.imageHeight;\n        var imageSrc = void 0;\n        var patternImage = val.image;\n        if ((0,util.isString)(patternImage)) {\n            imageSrc = patternImage;\n        }\n        else if (isImageLike(patternImage)) {\n            imageSrc = patternImage.src;\n        }\n        else if (isCanvasLike(patternImage)) {\n            imageSrc = patternImage.toDataURL();\n        }\n        if (typeof Image === 'undefined') {\n            var errMsg = 'Image width/height must been given explictly in svg-ssr renderer.';\n            (0,util.assert)(imageWidth_1, errMsg);\n            (0,util.assert)(imageHeight_1, errMsg);\n        }\n        else if (imageWidth_1 == null || imageHeight_1 == null) {\n            var setSizeToVNode_1 = function (vNode, img) {\n                if (vNode) {\n                    var svgEl = vNode.elm;\n                    var width = imageWidth_1 || img.width;\n                    var height = imageHeight_1 || img.height;\n                    if (vNode.tag === 'pattern') {\n                        if (repeatX) {\n                            height = 1;\n                            width /= boundingRect.width;\n                        }\n                        else if (repeatY) {\n                            width = 1;\n                            height /= boundingRect.height;\n                        }\n                    }\n                    vNode.attrs.width = width;\n                    vNode.attrs.height = height;\n                    if (svgEl) {\n                        svgEl.setAttribute('width', width);\n                        svgEl.setAttribute('height', height);\n                    }\n                }\n            };\n            var createdImage = (0,helper_image/* createOrUpdateImage */.OD)(imageSrc, null, el, function (img) {\n                noRepeat || setSizeToVNode_1(patternVNode, img);\n                setSizeToVNode_1(child, img);\n            });\n            if (createdImage && createdImage.width && createdImage.height) {\n                imageWidth_1 = imageWidth_1 || createdImage.width;\n                imageHeight_1 = imageHeight_1 || createdImage.height;\n            }\n        }\n        child = createVNode('image', 'img', {\n            href: imageSrc,\n            width: imageWidth_1,\n            height: imageHeight_1\n        });\n        patternAttrs.width = imageWidth_1;\n        patternAttrs.height = imageHeight_1;\n    }\n    else if (val.svgElement) {\n        child = (0,util.clone)(val.svgElement);\n        patternAttrs.width = val.svgWidth;\n        patternAttrs.height = val.svgHeight;\n    }\n    if (!child) {\n        return;\n    }\n    var patternWidth;\n    var patternHeight;\n    if (noRepeat) {\n        patternWidth = patternHeight = 1;\n    }\n    else if (repeatX) {\n        patternHeight = 1;\n        patternWidth = patternAttrs.width / boundingRect.width;\n    }\n    else if (repeatY) {\n        patternWidth = 1;\n        patternHeight = patternAttrs.height / boundingRect.height;\n    }\n    else {\n        patternAttrs.patternUnits = 'userSpaceOnUse';\n    }\n    if (patternWidth != null && !isNaN(patternWidth)) {\n        patternAttrs.width = patternWidth;\n    }\n    if (patternHeight != null && !isNaN(patternHeight)) {\n        patternAttrs.height = patternHeight;\n    }\n    var patternTransform = (0,helper/* getSRTTransformString */.Z1)(val);\n    patternTransform && (patternAttrs.patternTransform = patternTransform);\n    var patternVNode = createVNode('pattern', '', patternAttrs, [child]);\n    var patternKey = vNodeToString(patternVNode);\n    var patternCache = scope.patternCache;\n    var patternId = patternCache[patternKey];\n    if (!patternId) {\n        patternId = scope.zrId + '-p' + scope.patternIdx++;\n        patternCache[patternKey] = patternId;\n        patternAttrs.id = patternId;\n        patternVNode = scope.defs[patternId] = createVNode('pattern', patternId, patternAttrs, [child]);\n    }\n    attrs[target] = (0,helper/* getIdURL */.Xu)(patternId);\n}\nfunction setClipPath(clipPath, attrs, scope) {\n    var clipPathCache = scope.clipPathCache, defs = scope.defs;\n    var clipPathId = clipPathCache[clipPath.id];\n    if (!clipPathId) {\n        clipPathId = scope.zrId + '-c' + scope.clipPathIdx++;\n        var clipPathAttrs = {\n            id: clipPathId\n        };\n        clipPathCache[clipPath.id] = clipPathId;\n        defs[clipPathId] = createVNode('clipPath', clipPathId, clipPathAttrs, [brushSVGPath(clipPath, scope)]);\n    }\n    attrs['clip-path'] = (0,helper/* getIdURL */.Xu)(clipPathId);\n}\n\n;// ./node_modules/zrender/lib/svg/domapi.js\nfunction createTextNode(text) {\n    return document.createTextNode(text);\n}\nfunction createComment(text) {\n    return document.createComment(text);\n}\nfunction insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n}\nfunction removeChild(node, child) {\n    node.removeChild(child);\n}\nfunction appendChild(node, child) {\n    node.appendChild(child);\n}\nfunction parentNode(node) {\n    return node.parentNode;\n}\nfunction nextSibling(node) {\n    return node.nextSibling;\n}\nfunction tagName(elm) {\n    return elm.tagName;\n}\nfunction setTextContent(node, text) {\n    node.textContent = text;\n}\nfunction getTextContent(node) {\n    return node.textContent;\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\nfunction isText(node) {\n    return node.nodeType === 3;\n}\nfunction isComment(node) {\n    return node.nodeType === 8;\n}\n\n;// ./node_modules/zrender/lib/svg/patch.js\n\n\n\nvar colonChar = 58;\nvar xChar = 120;\nvar emptyNode = createVNode('', '');\nfunction isUndef(s) {\n    return s === undefined;\n}\nfunction isDef(s) {\n    return s !== undefined;\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    var map = {};\n    for (var i = beginIdx; i <= endIdx; ++i) {\n        var key = children[i].key;\n        if (key !== undefined) {\n            if (false) {}\n            map[key] = i;\n        }\n    }\n    return map;\n}\nfunction sameVnode(vnode1, vnode2) {\n    var isSameKey = vnode1.key === vnode2.key;\n    var isSameTag = vnode1.tag === vnode2.tag;\n    return isSameTag && isSameKey;\n}\nfunction createElm(vnode) {\n    var i;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n        var elm = (vnode.elm = createElement(tag));\n        updateAttrs(emptyNode, vnode);\n        if ((0,util.isArray)(children)) {\n            for (i = 0; i < children.length; ++i) {\n                var ch = children[i];\n                if (ch != null) {\n                    appendChild(elm, createElm(ch));\n                }\n            }\n        }\n        else if (isDef(vnode.text) && !(0,util.isObject)(vnode.text)) {\n            appendChild(elm, createTextNode(vnode.text));\n        }\n    }\n    else {\n        vnode.elm = createTextNode(vnode.text);\n    }\n    return vnode.elm;\n}\nfunction addVnodes(parentElm, before, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n        if (ch != null) {\n            insertBefore(parentElm, createElm(ch), before);\n        }\n    }\n}\nfunction removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n        if (ch != null) {\n            if (isDef(ch.tag)) {\n                var parent_1 = parentNode(ch.elm);\n                removeChild(parent_1, ch.elm);\n            }\n            else {\n                removeChild(parentElm, ch.elm);\n            }\n        }\n    }\n}\nfunction updateAttrs(oldVnode, vnode) {\n    var key;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode && oldVnode.attrs || {};\n    var attrs = vnode.attrs || {};\n    if (oldAttrs === attrs) {\n        return;\n    }\n    for (key in attrs) {\n        var cur = attrs[key];\n        var old = oldAttrs[key];\n        if (old !== cur) {\n            if (cur === true) {\n                elm.setAttribute(key, '');\n            }\n            else if (cur === false) {\n                elm.removeAttribute(key);\n            }\n            else {\n                if (key === 'style') {\n                    elm.style.cssText = cur;\n                }\n                else if (key.charCodeAt(0) !== xChar) {\n                    elm.setAttribute(key, cur);\n                }\n                else if (key === 'xmlns:xlink' || key === 'xmlns') {\n                    elm.setAttributeNS(XMLNS, key, cur);\n                }\n                else if (key.charCodeAt(3) === colonChar) {\n                    elm.setAttributeNS(XML_NAMESPACE, key, cur);\n                }\n                else if (key.charCodeAt(5) === colonChar) {\n                    elm.setAttributeNS(XLINKNS, key, cur);\n                }\n                else {\n                    elm.setAttribute(key, cur);\n                }\n            }\n        }\n    }\n    for (key in oldAttrs) {\n        if (!(key in attrs)) {\n            elm.removeAttribute(key);\n        }\n    }\n}\nfunction updateChildren(parentElm, oldCh, newCh) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx;\n    var idxInOld;\n    var elmToMove;\n    var before;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (oldStartVnode == null) {\n            oldStartVnode = oldCh[++oldStartIdx];\n        }\n        else if (oldEndVnode == null) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (newStartVnode == null) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (newEndVnode == null) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (sameVnode(oldStartVnode, newStartVnode)) {\n            patchVnode(oldStartVnode, newStartVnode);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (sameVnode(oldEndVnode, newEndVnode)) {\n            patchVnode(oldEndVnode, newEndVnode);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (sameVnode(oldStartVnode, newEndVnode)) {\n            patchVnode(oldStartVnode, newEndVnode);\n            insertBefore(parentElm, oldStartVnode.elm, nextSibling(oldEndVnode.elm));\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (sameVnode(oldEndVnode, newStartVnode)) {\n            patchVnode(oldEndVnode, newStartVnode);\n            insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            if (isUndef(oldKeyToIdx)) {\n                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n            }\n            idxInOld = oldKeyToIdx[newStartVnode.key];\n            if (isUndef(idxInOld)) {\n                insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);\n            }\n            else {\n                elmToMove = oldCh[idxInOld];\n                if (elmToMove.tag !== newStartVnode.tag) {\n                    insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);\n                }\n                else {\n                    patchVnode(elmToMove, newStartVnode);\n                    oldCh[idxInOld] = undefined;\n                    insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n                }\n            }\n            newStartVnode = newCh[++newStartIdx];\n        }\n    }\n    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n        if (oldStartIdx > oldEndIdx) {\n            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);\n        }\n        else {\n            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n        }\n    }\n}\nfunction patchVnode(oldVnode, vnode) {\n    var elm = (vnode.elm = oldVnode.elm);\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (oldVnode === vnode) {\n        return;\n    }\n    updateAttrs(oldVnode, vnode);\n    if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n            if (oldCh !== ch) {\n                updateChildren(elm, oldCh, ch);\n            }\n        }\n        else if (isDef(ch)) {\n            if (isDef(oldVnode.text)) {\n                setTextContent(elm, '');\n            }\n            addVnodes(elm, null, ch, 0, ch.length - 1);\n        }\n        else if (isDef(oldCh)) {\n            removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        }\n        else if (isDef(oldVnode.text)) {\n            setTextContent(elm, '');\n        }\n    }\n    else if (oldVnode.text !== vnode.text) {\n        if (isDef(oldCh)) {\n            removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        }\n        setTextContent(elm, vnode.text);\n    }\n}\nfunction patch(oldVnode, vnode) {\n    if (sameVnode(oldVnode, vnode)) {\n        patchVnode(oldVnode, vnode);\n    }\n    else {\n        var elm = oldVnode.elm;\n        var parent_2 = parentNode(elm);\n        createElm(vnode);\n        if (parent_2 !== null) {\n            insertBefore(parent_2, vnode.elm, nextSibling(elm));\n            removeVnodes(parent_2, [oldVnode], 0, 0);\n        }\n    }\n    return vnode;\n}\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/canvas/helper.js\nvar canvas_helper = __webpack_require__(53479);\n;// ./node_modules/zrender/lib/svg/Painter.js\n\n\n\n\n\n\nvar svgId = 0;\nvar SVGPainter = (function () {\n    function SVGPainter(root, storage, opts) {\n        this.type = 'svg';\n        this.refreshHover = createMethodNotSupport('refreshHover');\n        this.configLayer = createMethodNotSupport('configLayer');\n        this.storage = storage;\n        this._opts = opts = (0,util.extend)({}, opts);\n        this.root = root;\n        this._id = 'zr' + svgId++;\n        this._oldVNode = createSVGVNode(opts.width, opts.height);\n        if (root && !opts.ssr) {\n            var viewport = this._viewport = document.createElement('div');\n            viewport.style.cssText = 'position:relative;overflow:hidden';\n            var svgDom = this._svgDom = this._oldVNode.elm = createElement('svg');\n            updateAttrs(null, this._oldVNode);\n            viewport.appendChild(svgDom);\n            root.appendChild(viewport);\n        }\n        this.resize(opts.width, opts.height);\n    }\n    SVGPainter.prototype.getType = function () {\n        return this.type;\n    };\n    SVGPainter.prototype.getViewportRoot = function () {\n        return this._viewport;\n    };\n    SVGPainter.prototype.getViewportRootOffset = function () {\n        var viewportRoot = this.getViewportRoot();\n        if (viewportRoot) {\n            return {\n                offsetLeft: viewportRoot.offsetLeft || 0,\n                offsetTop: viewportRoot.offsetTop || 0\n            };\n        }\n    };\n    SVGPainter.prototype.getSvgDom = function () {\n        return this._svgDom;\n    };\n    SVGPainter.prototype.refresh = function () {\n        if (this.root) {\n            var vnode = this.renderToVNode({\n                willUpdate: true\n            });\n            vnode.attrs.style = 'position:absolute;left:0;top:0;user-select:none';\n            patch(this._oldVNode, vnode);\n            this._oldVNode = vnode;\n        }\n    };\n    SVGPainter.prototype.renderOneToVNode = function (el) {\n        return brush(el, createBrushScope(this._id));\n    };\n    SVGPainter.prototype.renderToVNode = function (opts) {\n        opts = opts || {};\n        var list = this.storage.getDisplayList(true);\n        var width = this._width;\n        var height = this._height;\n        var scope = createBrushScope(this._id);\n        scope.animation = opts.animation;\n        scope.willUpdate = opts.willUpdate;\n        scope.compress = opts.compress;\n        scope.emphasis = opts.emphasis;\n        scope.ssr = this._opts.ssr;\n        var children = [];\n        var bgVNode = this._bgVNode = createBackgroundVNode(width, height, this._backgroundColor, scope);\n        bgVNode && children.push(bgVNode);\n        var mainVNode = !opts.compress\n            ? (this._mainVNode = createVNode('g', 'main', {}, [])) : null;\n        this._paintList(list, scope, mainVNode ? mainVNode.children : children);\n        mainVNode && children.push(mainVNode);\n        var defs = (0,util.map)((0,util.keys)(scope.defs), function (id) { return scope.defs[id]; });\n        if (defs.length) {\n            children.push(createVNode('defs', 'defs', {}, defs));\n        }\n        if (opts.animation) {\n            var animationCssStr = getCssString(scope.cssNodes, scope.cssAnims, { newline: true });\n            if (animationCssStr) {\n                var styleNode = createVNode('style', 'stl', {}, [], animationCssStr);\n                children.push(styleNode);\n            }\n        }\n        return createSVGVNode(width, height, children, opts.useViewBox);\n    };\n    SVGPainter.prototype.renderToString = function (opts) {\n        opts = opts || {};\n        return vNodeToString(this.renderToVNode({\n            animation: (0,util.retrieve2)(opts.cssAnimation, true),\n            emphasis: (0,util.retrieve2)(opts.cssEmphasis, true),\n            willUpdate: false,\n            compress: true,\n            useViewBox: (0,util.retrieve2)(opts.useViewBox, true)\n        }), { newline: true });\n    };\n    SVGPainter.prototype.setBackgroundColor = function (backgroundColor) {\n        this._backgroundColor = backgroundColor;\n    };\n    SVGPainter.prototype.getSvgRoot = function () {\n        return this._mainVNode && this._mainVNode.elm;\n    };\n    SVGPainter.prototype._paintList = function (list, scope, out) {\n        var listLen = list.length;\n        var clipPathsGroupsStack = [];\n        var clipPathsGroupsStackDepth = 0;\n        var currentClipPathGroup;\n        var prevClipPaths;\n        var clipGroupNodeIdx = 0;\n        for (var i = 0; i < listLen; i++) {\n            var displayable = list[i];\n            if (!displayable.invisible) {\n                var clipPaths = displayable.__clipPaths;\n                var len = clipPaths && clipPaths.length || 0;\n                var prevLen = prevClipPaths && prevClipPaths.length || 0;\n                var lca = void 0;\n                for (lca = Math.max(len - 1, prevLen - 1); lca >= 0; lca--) {\n                    if (clipPaths && prevClipPaths\n                        && clipPaths[lca] === prevClipPaths[lca]) {\n                        break;\n                    }\n                }\n                for (var i_1 = prevLen - 1; i_1 > lca; i_1--) {\n                    clipPathsGroupsStackDepth--;\n                    currentClipPathGroup = clipPathsGroupsStack[clipPathsGroupsStackDepth - 1];\n                }\n                for (var i_2 = lca + 1; i_2 < len; i_2++) {\n                    var groupAttrs = {};\n                    setClipPath(clipPaths[i_2], groupAttrs, scope);\n                    var g = createVNode('g', 'clip-g-' + clipGroupNodeIdx++, groupAttrs, []);\n                    (currentClipPathGroup ? currentClipPathGroup.children : out).push(g);\n                    clipPathsGroupsStack[clipPathsGroupsStackDepth++] = g;\n                    currentClipPathGroup = g;\n                }\n                prevClipPaths = clipPaths;\n                var ret = brush(displayable, scope);\n                if (ret) {\n                    (currentClipPathGroup ? currentClipPathGroup.children : out).push(ret);\n                }\n            }\n        }\n    };\n    SVGPainter.prototype.resize = function (width, height) {\n        var opts = this._opts;\n        var root = this.root;\n        var viewport = this._viewport;\n        width != null && (opts.width = width);\n        height != null && (opts.height = height);\n        if (root && viewport) {\n            viewport.style.display = 'none';\n            width = (0,canvas_helper/* getSize */.YC)(root, 0, opts);\n            height = (0,canvas_helper/* getSize */.YC)(root, 1, opts);\n            viewport.style.display = '';\n        }\n        if (this._width !== width || this._height !== height) {\n            this._width = width;\n            this._height = height;\n            if (viewport) {\n                var viewportStyle = viewport.style;\n                viewportStyle.width = width + 'px';\n                viewportStyle.height = height + 'px';\n            }\n            if (!(0,helper/* isPattern */.Pt)(this._backgroundColor)) {\n                var svgDom = this._svgDom;\n                if (svgDom) {\n                    svgDom.setAttribute('width', width);\n                    svgDom.setAttribute('height', height);\n                }\n                var bgEl = this._bgVNode && this._bgVNode.elm;\n                if (bgEl) {\n                    bgEl.setAttribute('width', width);\n                    bgEl.setAttribute('height', height);\n                }\n            }\n            else {\n                this.refresh();\n            }\n        }\n    };\n    SVGPainter.prototype.getWidth = function () {\n        return this._width;\n    };\n    SVGPainter.prototype.getHeight = function () {\n        return this._height;\n    };\n    SVGPainter.prototype.dispose = function () {\n        if (this.root) {\n            this.root.innerHTML = '';\n        }\n        this._svgDom =\n            this._viewport =\n                this.storage =\n                    this._oldVNode =\n                        this._bgVNode =\n                            this._mainVNode = null;\n    };\n    SVGPainter.prototype.clear = function () {\n        if (this._svgDom) {\n            this._svgDom.innerHTML = null;\n        }\n        this._oldVNode = null;\n    };\n    SVGPainter.prototype.toDataURL = function (base64) {\n        var str = this.renderToString();\n        var prefix = 'data:image/svg+xml;';\n        if (base64) {\n            str = (0,helper/* encodeBase64 */.WG)(str);\n            return str && prefix + 'base64,' + str;\n        }\n        return prefix + 'charset=UTF-8,' + encodeURIComponent(str);\n    };\n    return SVGPainter;\n}());\nfunction createMethodNotSupport(method) {\n    return function () {\n        if (false) {}\n    };\n}\nfunction createBackgroundVNode(width, height, backgroundColor, scope) {\n    var bgVNode;\n    if (backgroundColor && backgroundColor !== 'none') {\n        bgVNode = createVNode('rect', 'bg', {\n            width: width,\n            height: height,\n            x: '0',\n            y: '0'\n        });\n        if ((0,helper/* isGradient */.bn)(backgroundColor)) {\n            setGradient({ fill: backgroundColor }, bgVNode.attrs, 'fill', scope);\n        }\n        else if ((0,helper/* isPattern */.Pt)(backgroundColor)) {\n            setPattern({\n                style: {\n                    fill: backgroundColor\n                },\n                dirty: util.noop,\n                getBoundingRect: function () { return ({ width: width, height: height }); }\n            }, bgVNode.attrs, 'fill', scope);\n        }\n        else {\n            var _a = (0,helper/* normalizeColor */.$2)(backgroundColor), color = _a.color, opacity = _a.opacity;\n            bgVNode.attrs.fill = color;\n            opacity < 1 && (bgVNode.attrs['fill-opacity'] = opacity);\n        }\n    }\n    return bgVNode;\n}\n/* harmony default export */ const Painter = (SVGPainter);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg0MDkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDblJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9kQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvc3ZnL1NWR1BhdGhSZWJ1aWxkZXIuanM/N2U3ZSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvc3ZnL21hcFN0eWxlVG9BdHRycy5qcz9hZTllIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9zdmcvY29yZS5qcz83MWM2Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9zdmcvY3NzQ2xhc3NJZC5qcz9jNzU3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9zdmcvY3NzQW5pbWF0aW9uLmpzPzNlYWMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3N2Zy9jc3NFbXBoYXNpcy5qcz9lMTkzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9zdmcvZ3JhcGhpYy5qcz81MTI1Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9zdmcvZG9tYXBpLmpzPzQzZmMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3N2Zy9wYXRjaC5qcz9jMGE3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9zdmcvUGFpbnRlci5qcz82ZTkwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzQXJvdW5kWmVybyB9IGZyb20gJy4vaGVscGVyLmpzJztcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIFBJID0gTWF0aC5QSTtcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBkZWdyZWUgPSAxODAgLyBQSTtcbnZhciBTVkdQYXRoUmVidWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTVkdQYXRoUmVidWlsZGVyKCkge1xuICAgIH1cbiAgICBTVkdQYXRoUmVidWlsZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcbiAgICAgICAgdGhpcy5fc3RhcnQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kID0gW107XG4gICAgICAgIHRoaXMuX3N0ciA9ICcnO1xuICAgICAgICB0aGlzLl9wID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiB8fCA0KTtcbiAgICB9O1xuICAgIFNWR1BhdGhSZWJ1aWxkZXIucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHRoaXMuX2FkZCgnTScsIHgsIHkpO1xuICAgIH07XG4gICAgU1ZHUGF0aFJlYnVpbGRlci5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdGhpcy5fYWRkKCdMJywgeCwgeSk7XG4gICAgfTtcbiAgICBTVkdQYXRoUmVidWlsZGVyLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24gKHgsIHksIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgIHRoaXMuX2FkZCgnQycsIHgsIHksIHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9O1xuICAgIFNWR1BhdGhSZWJ1aWxkZXIucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiAoeCwgeSwgeDIsIHkyKSB7XG4gICAgICAgIHRoaXMuX2FkZCgnUScsIHgsIHksIHgyLCB5Mik7XG4gICAgfTtcbiAgICBTVkdQYXRoUmVidWlsZGVyLnByb3RvdHlwZS5hcmMgPSBmdW5jdGlvbiAoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICB0aGlzLmVsbGlwc2UoY3gsIGN5LCByLCByLCAwLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG4gICAgfTtcbiAgICBTVkdQYXRoUmVidWlsZGVyLnByb3RvdHlwZS5lbGxpcHNlID0gZnVuY3Rpb24gKGN4LCBjeSwgcngsIHJ5LCBwc2ksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgIHZhciBkVGhldGEgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gICAgICAgIHZhciBjbG9ja3dpc2UgPSAhYW50aWNsb2Nrd2lzZTtcbiAgICAgICAgdmFyIGRUaGV0YVBvc2l0aXZlID0gTWF0aC5hYnMoZFRoZXRhKTtcbiAgICAgICAgdmFyIGlzQ2lyY2xlID0gaXNBcm91bmRaZXJvKGRUaGV0YVBvc2l0aXZlIC0gUEkyKVxuICAgICAgICAgICAgfHwgKGNsb2Nrd2lzZSA/IGRUaGV0YSA+PSBQSTIgOiAtZFRoZXRhID49IFBJMik7XG4gICAgICAgIHZhciB1bmlmaWVkVGhldGEgPSBkVGhldGEgPiAwID8gZFRoZXRhICUgUEkyIDogKGRUaGV0YSAlIFBJMiArIFBJMik7XG4gICAgICAgIHZhciBsYXJnZSA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNDaXJjbGUpIHtcbiAgICAgICAgICAgIGxhcmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Fyb3VuZFplcm8oZFRoZXRhUG9zaXRpdmUpKSB7XG4gICAgICAgICAgICBsYXJnZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFyZ2UgPSAodW5pZmllZFRoZXRhID49IFBJKSA9PT0gISFjbG9ja3dpc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHgwID0gY3ggKyByeCAqIG1hdGhDb3Moc3RhcnRBbmdsZSk7XG4gICAgICAgIHZhciB5MCA9IGN5ICsgcnkgKiBtYXRoU2luKHN0YXJ0QW5nbGUpO1xuICAgICAgICBpZiAodGhpcy5fc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZCgnTScsIHgwLCB5MCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHhSb3QgPSBNYXRoLnJvdW5kKHBzaSAqIGRlZ3JlZSk7XG4gICAgICAgIGlmIChpc0NpcmNsZSkge1xuICAgICAgICAgICAgdmFyIHAgPSAxIC8gdGhpcy5fcDtcbiAgICAgICAgICAgIHZhciBkVGhldGFfMSA9IChjbG9ja3dpc2UgPyAxIDogLTEpICogKFBJMiAtIHApO1xuICAgICAgICAgICAgdGhpcy5fYWRkKCdBJywgcngsIHJ5LCB4Um90LCAxLCArY2xvY2t3aXNlLCBjeCArIHJ4ICogbWF0aENvcyhzdGFydEFuZ2xlICsgZFRoZXRhXzEpLCBjeSArIHJ5ICogbWF0aFNpbihzdGFydEFuZ2xlICsgZFRoZXRhXzEpKTtcbiAgICAgICAgICAgIGlmIChwID4gMWUtMikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZCgnQScsIHJ4LCByeSwgeFJvdCwgMCwgK2Nsb2Nrd2lzZSwgeDAsIHkwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB4ID0gY3ggKyByeCAqIG1hdGhDb3MoZW5kQW5nbGUpO1xuICAgICAgICAgICAgdmFyIHkgPSBjeSArIHJ5ICogbWF0aFNpbihlbmRBbmdsZSk7XG4gICAgICAgICAgICB0aGlzLl9hZGQoJ0EnLCByeCwgcnksIHhSb3QsICtsYXJnZSwgK2Nsb2Nrd2lzZSwgeCwgeSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNWR1BhdGhSZWJ1aWxkZXIucHJvdG90eXBlLnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgICAgICB0aGlzLl9hZGQoJ00nLCB4LCB5KTtcbiAgICAgICAgdGhpcy5fYWRkKCdsJywgdywgMCk7XG4gICAgICAgIHRoaXMuX2FkZCgnbCcsIDAsIGgpO1xuICAgICAgICB0aGlzLl9hZGQoJ2wnLCAtdywgMCk7XG4gICAgICAgIHRoaXMuX2FkZCgnWicpO1xuICAgIH07XG4gICAgU1ZHUGF0aFJlYnVpbGRlci5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGQoJ1onKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU1ZHUGF0aFJlYnVpbGRlci5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uIChjbWQsIGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpIHtcbiAgICAgICAgdmFyIHZhbHMgPSBbXTtcbiAgICAgICAgdmFyIHAgPSB0aGlzLl9wO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChpc05hTih2YWwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW52YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFscy5wdXNoKE1hdGgucm91bmQodmFsICogcCkgLyBwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kLnB1c2goY21kICsgdmFscy5qb2luKCcgJykpO1xuICAgICAgICB0aGlzLl9zdGFydCA9IGNtZCA9PT0gJ1onO1xuICAgIH07XG4gICAgU1ZHUGF0aFJlYnVpbGRlci5wcm90b3R5cGUuZ2VuZXJhdGVTdHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N0ciA9IHRoaXMuX2ludmFsaWQgPyAnJyA6IHRoaXMuX2Quam9pbignJyk7XG4gICAgICAgIHRoaXMuX2QgPSBbXTtcbiAgICB9O1xuICAgIFNWR1BhdGhSZWJ1aWxkZXIucHJvdG90eXBlLmdldFN0ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cjtcbiAgICB9O1xuICAgIHJldHVybiBTVkdQYXRoUmVidWlsZGVyO1xufSgpKTtcbmV4cG9ydCBkZWZhdWx0IFNWR1BhdGhSZWJ1aWxkZXI7XG4iLCJpbXBvcnQgeyBERUZBVUxUX1BBVEhfU1RZTEUgfSBmcm9tICcuLi9ncmFwaGljL1BhdGguanMnO1xuaW1wb3J0IFpSSW1hZ2UgZnJvbSAnLi4vZ3JhcGhpYy9JbWFnZS5qcyc7XG5pbXBvcnQgeyBnZXRMaW5lRGFzaCB9IGZyb20gJy4uL2NhbnZhcy9kYXNoU3R5bGUuanMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vY29yZS91dGlsLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZUNvbG9yIH0gZnJvbSAnLi9oZWxwZXIuanMnO1xudmFyIE5PTkUgPSAnbm9uZSc7XG52YXIgbWF0aFJvdW5kID0gTWF0aC5yb3VuZDtcbmZ1bmN0aW9uIHBhdGhIYXNGaWxsKHN0eWxlKSB7XG4gICAgdmFyIGZpbGwgPSBzdHlsZS5maWxsO1xuICAgIHJldHVybiBmaWxsICE9IG51bGwgJiYgZmlsbCAhPT0gTk9ORTtcbn1cbmZ1bmN0aW9uIHBhdGhIYXNTdHJva2Uoc3R5bGUpIHtcbiAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgIHJldHVybiBzdHJva2UgIT0gbnVsbCAmJiBzdHJva2UgIT09IE5PTkU7XG59XG52YXIgc3Ryb2tlUHJvcHMgPSBbJ2xpbmVDYXAnLCAnbWl0ZXJMaW1pdCcsICdsaW5lSm9pbiddO1xudmFyIHN2Z1N0cm9rZVByb3BzID0gbWFwKHN0cm9rZVByb3BzLCBmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gXCJzdHJva2UtXCIgKyBwcm9wLnRvTG93ZXJDYXNlKCk7IH0pO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWFwU3R5bGVUb0F0dHJzKHVwZGF0ZUF0dHIsIHN0eWxlLCBlbCwgZm9yY2VVcGRhdGUpIHtcbiAgICB2YXIgb3BhY2l0eSA9IHN0eWxlLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBzdHlsZS5vcGFjaXR5O1xuICAgIGlmIChlbCBpbnN0YW5jZW9mIFpSSW1hZ2UpIHtcbiAgICAgICAgdXBkYXRlQXR0cignb3BhY2l0eScsIG9wYWNpdHkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwYXRoSGFzRmlsbChzdHlsZSkpIHtcbiAgICAgICAgdmFyIGZpbGwgPSBub3JtYWxpemVDb2xvcihzdHlsZS5maWxsKTtcbiAgICAgICAgdXBkYXRlQXR0cignZmlsbCcsIGZpbGwuY29sb3IpO1xuICAgICAgICB2YXIgZmlsbE9wYWNpdHkgPSBzdHlsZS5maWxsT3BhY2l0eSAhPSBudWxsXG4gICAgICAgICAgICA/IHN0eWxlLmZpbGxPcGFjaXR5ICogZmlsbC5vcGFjaXR5ICogb3BhY2l0eVxuICAgICAgICAgICAgOiBmaWxsLm9wYWNpdHkgKiBvcGFjaXR5O1xuICAgICAgICBpZiAoZm9yY2VVcGRhdGUgfHwgZmlsbE9wYWNpdHkgPCAxKSB7XG4gICAgICAgICAgICB1cGRhdGVBdHRyKCdmaWxsLW9wYWNpdHknLCBmaWxsT3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVwZGF0ZUF0dHIoJ2ZpbGwnLCBOT05FKTtcbiAgICB9XG4gICAgaWYgKHBhdGhIYXNTdHJva2Uoc3R5bGUpKSB7XG4gICAgICAgIHZhciBzdHJva2UgPSBub3JtYWxpemVDb2xvcihzdHlsZS5zdHJva2UpO1xuICAgICAgICB1cGRhdGVBdHRyKCdzdHJva2UnLCBzdHJva2UuY29sb3IpO1xuICAgICAgICB2YXIgc3Ryb2tlU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlXG4gICAgICAgICAgICA/IGVsLmdldExpbmVTY2FsZSgpXG4gICAgICAgICAgICA6IDE7XG4gICAgICAgIHZhciBzdHJva2VXaWR0aCA9IChzdHJva2VTY2FsZSA/IChzdHlsZS5saW5lV2lkdGggfHwgMCkgLyBzdHJva2VTY2FsZSA6IDApO1xuICAgICAgICB2YXIgc3Ryb2tlT3BhY2l0eSA9IHN0eWxlLnN0cm9rZU9wYWNpdHkgIT0gbnVsbFxuICAgICAgICAgICAgPyBzdHlsZS5zdHJva2VPcGFjaXR5ICogc3Ryb2tlLm9wYWNpdHkgKiBvcGFjaXR5XG4gICAgICAgICAgICA6IHN0cm9rZS5vcGFjaXR5ICogb3BhY2l0eTtcbiAgICAgICAgdmFyIHN0cm9rZUZpcnN0ID0gc3R5bGUuc3Ryb2tlRmlyc3Q7XG4gICAgICAgIGlmIChmb3JjZVVwZGF0ZSB8fCBzdHJva2VXaWR0aCAhPT0gMSkge1xuICAgICAgICAgICAgdXBkYXRlQXR0cignc3Ryb2tlLXdpZHRoJywgc3Ryb2tlV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JjZVVwZGF0ZSB8fCBzdHJva2VGaXJzdCkge1xuICAgICAgICAgICAgdXBkYXRlQXR0cigncGFpbnQtb3JkZXInLCBzdHJva2VGaXJzdCA/ICdzdHJva2UnIDogJ2ZpbGwnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yY2VVcGRhdGUgfHwgc3Ryb2tlT3BhY2l0eSA8IDEpIHtcbiAgICAgICAgICAgIHVwZGF0ZUF0dHIoJ3N0cm9rZS1vcGFjaXR5Jywgc3Ryb2tlT3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlLmxpbmVEYXNoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRMaW5lRGFzaChlbCksIGxpbmVEYXNoID0gX2FbMF0sIGxpbmVEYXNoT2Zmc2V0ID0gX2FbMV07XG4gICAgICAgICAgICBpZiAobGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICBsaW5lRGFzaE9mZnNldCA9IG1hdGhSb3VuZChsaW5lRGFzaE9mZnNldCB8fCAwKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVBdHRyKCdzdHJva2UtZGFzaGFycmF5JywgbGluZURhc2guam9pbignLCcpKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZURhc2hPZmZzZXQgfHwgZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQXR0cignc3Ryb2tlLWRhc2hvZmZzZXQnLCBsaW5lRGFzaE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgICB1cGRhdGVBdHRyKCdzdHJva2UtZGFzaGFycmF5JywgTk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJva2VQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gc3Ryb2tlUHJvcHNbaV07XG4gICAgICAgICAgICBpZiAoZm9yY2VVcGRhdGUgfHwgc3R5bGVbcHJvcE5hbWVdICE9PSBERUZBVUxUX1BBVEhfU1RZTEVbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHN0eWxlW3Byb3BOYW1lXSB8fCBERUZBVUxUX1BBVEhfU1RZTEVbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIHZhbCAmJiB1cGRhdGVBdHRyKHN2Z1N0cm9rZVByb3BzW2ldLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGZvcmNlVXBkYXRlKSB7XG4gICAgICAgIHVwZGF0ZUF0dHIoJ3N0cm9rZScsIE5PTkUpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGtleXMsIG1hcCB9IGZyb20gJy4uL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBlbmNvZGVIVE1MIH0gZnJvbSAnLi4vY29yZS9kb20uanMnO1xuZXhwb3J0IHZhciBTVkdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5leHBvcnQgdmFyIFhMSU5LTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5leHBvcnQgdmFyIFhNTE5TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJztcbmV4cG9ydCB2YXIgWE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnO1xuZXhwb3J0IHZhciBNRVRBX0RBVEFfUFJFRklYID0gJ2VjbWV0YV8nO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHTlMsIG5hbWUpO1xufVxuO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZOb2RlKHRhZywga2V5LCBhdHRycywgY2hpbGRyZW4sIHRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgYXR0cnM6IGF0dHJzIHx8IHt9LFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGtleToga2V5XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRPcGVuKG5hbWUsIGF0dHJzKSB7XG4gICAgdmFyIGF0dHJzU3RyID0gW107XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICB2YXIgcGFydCA9IGtleTtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHRydWUgJiYgdmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJ0ICs9IFwiPVxcXCJcIiArIHZhbCArIFwiXFxcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0cnNTdHIucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCI8XCIgKyBuYW1lICsgXCIgXCIgKyBhdHRyc1N0ci5qb2luKCcgJykgKyBcIj5cIjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRDbG9zZShuYW1lKSB7XG4gICAgcmV0dXJuIFwiPC9cIiArIG5hbWUgKyBcIj5cIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2Tm9kZVRvU3RyaW5nKGVsLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIFMgPSBvcHRzLm5ld2xpbmUgPyAnXFxuJyA6ICcnO1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRFbFRvU3RyaW5nKGVsKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuLCB0YWcgPSBlbC50YWcsIGF0dHJzID0gZWwuYXR0cnMsIHRleHQgPSBlbC50ZXh0O1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudE9wZW4odGFnLCBhdHRycylcbiAgICAgICAgICAgICsgKHRhZyAhPT0gJ3N0eWxlJyA/IGVuY29kZUhUTUwodGV4dCkgOiB0ZXh0IHx8ICcnKVxuICAgICAgICAgICAgKyAoY2hpbGRyZW4gPyBcIlwiICsgUyArIG1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjb252ZXJ0RWxUb1N0cmluZyhjaGlsZCk7IH0pLmpvaW4oUykgKyBTIDogJycpXG4gICAgICAgICAgICArIGNyZWF0ZUVsZW1lbnRDbG9zZSh0YWcpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydEVsVG9TdHJpbmcoZWwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENzc1N0cmluZyhzZWxlY3Rvck5vZGVzLCBhbmltYXRpb25Ob2Rlcywgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBTID0gb3B0cy5uZXdsaW5lID8gJ1xcbicgOiAnJztcbiAgICB2YXIgYnJhY2tldEJlZ2luID0gXCIge1wiICsgUztcbiAgICB2YXIgYnJhY2tldEVuZCA9IFMgKyBcIn1cIjtcbiAgICB2YXIgc2VsZWN0b3JzID0gbWFwKGtleXMoc2VsZWN0b3JOb2RlcyksIGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZSArIGJyYWNrZXRCZWdpbiArIG1hcChrZXlzKHNlbGVjdG9yTm9kZXNbY2xhc3NOYW1lXSksIGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0dHJOYW1lICsgXCI6XCIgKyBzZWxlY3Rvck5vZGVzW2NsYXNzTmFtZV1bYXR0ck5hbWVdICsgXCI7XCI7XG4gICAgICAgIH0pLmpvaW4oUykgKyBicmFja2V0RW5kO1xuICAgIH0pLmpvaW4oUyk7XG4gICAgdmFyIGFuaW1hdGlvbnMgPSBtYXAoa2V5cyhhbmltYXRpb25Ob2RlcyksIGZ1bmN0aW9uIChhbmltYXRpb25OYW1lKSB7XG4gICAgICAgIHJldHVybiBcIkBrZXlmcmFtZXMgXCIgKyBhbmltYXRpb25OYW1lICsgYnJhY2tldEJlZ2luICsgbWFwKGtleXMoYW5pbWF0aW9uTm9kZXNbYW5pbWF0aW9uTmFtZV0pLCBmdW5jdGlvbiAocGVyY2VudCkge1xuICAgICAgICAgICAgcmV0dXJuIHBlcmNlbnQgKyBicmFja2V0QmVnaW4gKyBtYXAoa2V5cyhhbmltYXRpb25Ob2Rlc1thbmltYXRpb25OYW1lXVtwZXJjZW50XSksIGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBhbmltYXRpb25Ob2Rlc1thbmltYXRpb25OYW1lXVtwZXJjZW50XVthdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJOYW1lID09PSAnZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gXCJwYXRoKFxcXCJcIiArIHZhbCArIFwiXFxcIilcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJOYW1lICsgXCI6XCIgKyB2YWwgKyBcIjtcIjtcbiAgICAgICAgICAgIH0pLmpvaW4oUykgKyBicmFja2V0RW5kO1xuICAgICAgICB9KS5qb2luKFMpICsgYnJhY2tldEVuZDtcbiAgICB9KS5qb2luKFMpO1xuICAgIGlmICghc2VsZWN0b3JzICYmICFhbmltYXRpb25zKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIFsnPCFbQ0RBVEFbJywgc2VsZWN0b3JzLCBhbmltYXRpb25zLCAnXV0+J10uam9pbihTKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCcnVzaFNjb3BlKHpySWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB6cklkOiB6cklkLFxuICAgICAgICBzaGFkb3dDYWNoZToge30sXG4gICAgICAgIHBhdHRlcm5DYWNoZToge30sXG4gICAgICAgIGdyYWRpZW50Q2FjaGU6IHt9LFxuICAgICAgICBjbGlwUGF0aENhY2hlOiB7fSxcbiAgICAgICAgZGVmczoge30sXG4gICAgICAgIGNzc05vZGVzOiB7fSxcbiAgICAgICAgY3NzQW5pbXM6IHt9LFxuICAgICAgICBjc3NTdHlsZUNhY2hlOiB7fSxcbiAgICAgICAgY3NzQW5pbUlkeDogMCxcbiAgICAgICAgc2hhZG93SWR4OiAwLFxuICAgICAgICBncmFkaWVudElkeDogMCxcbiAgICAgICAgcGF0dGVybklkeDogMCxcbiAgICAgICAgY2xpcFBhdGhJZHg6IDBcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNWR1ZOb2RlKHdpZHRoLCBoZWlnaHQsIGNoaWxkcmVuLCB1c2VWaWV3Qm94KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKCdzdmcnLCAncm9vdCcsIHtcbiAgICAgICAgJ3dpZHRoJzogd2lkdGgsXG4gICAgICAgICdoZWlnaHQnOiBoZWlnaHQsXG4gICAgICAgICd4bWxucyc6IFNWR05TLFxuICAgICAgICAneG1sbnM6eGxpbmsnOiBYTElOS05TLFxuICAgICAgICAndmVyc2lvbic6ICcxLjEnLFxuICAgICAgICAnYmFzZVByb2ZpbGUnOiAnZnVsbCcsXG4gICAgICAgICd2aWV3Qm94JzogdXNlVmlld0JveCA/IFwiMCAwIFwiICsgd2lkdGggKyBcIiBcIiArIGhlaWdodCA6IGZhbHNlXG4gICAgfSwgY2hpbGRyZW4pO1xufVxuIiwidmFyIGNzc0NsYXNzSWR4ID0gMDtcbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzc0lkKCkge1xuICAgIHJldHVybiBjc3NDbGFzc0lkeCsrO1xufVxuIiwiaW1wb3J0IHsgY29weVRyYW5zZm9ybSB9IGZyb20gJy4uL2NvcmUvVHJhbnNmb3JtYWJsZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVCcnVzaFNjb3BlIH0gZnJvbSAnLi9jb3JlLmpzJztcbmltcG9ydCBTVkdQYXRoUmVidWlsZGVyIGZyb20gJy4vU1ZHUGF0aFJlYnVpbGRlci5qcyc7XG5pbXBvcnQgUGF0aFByb3h5IGZyb20gJy4uL2NvcmUvUGF0aFByb3h5LmpzJztcbmltcG9ydCB7IGdldFBhdGhQcmVjaXNpb24sIGdldFNSVFRyYW5zZm9ybVN0cmluZyB9IGZyb20gJy4vaGVscGVyLmpzJztcbmltcG9ydCB7IGVhY2gsIGV4dGVuZCwgZmlsdGVyLCBpc051bWJlciwgaXNTdHJpbmcsIGtleXMgfSBmcm9tICcuLi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IENvbXBvdW5kUGF0aCBmcm9tICcuLi9ncmFwaGljL0NvbXBvdW5kUGF0aC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDdWJpY0Vhc2luZ0Z1bmMgfSBmcm9tICcuLi9hbmltYXRpb24vY3ViaWNFYXNpbmcuanMnO1xuaW1wb3J0IHsgZ2V0Q2xhc3NJZCB9IGZyb20gJy4vY3NzQ2xhc3NJZC5qcyc7XG5leHBvcnQgdmFyIEVBU0lOR19NQVAgPSB7XG4gICAgY3ViaWNJbjogJzAuMzIsMCwwLjY3LDAnLFxuICAgIGN1YmljT3V0OiAnMC4zMywxLDAuNjgsMScsXG4gICAgY3ViaWNJbk91dDogJzAuNjUsMCwwLjM1LDEnLFxuICAgIHF1YWRyYXRpY0luOiAnMC4xMSwwLDAuNSwwJyxcbiAgICBxdWFkcmF0aWNPdXQ6ICcwLjUsMSwwLjg5LDEnLFxuICAgIHF1YWRyYXRpY0luT3V0OiAnMC40NSwwLDAuNTUsMScsXG4gICAgcXVhcnRpY0luOiAnMC41LDAsMC43NSwwJyxcbiAgICBxdWFydGljT3V0OiAnMC4yNSwxLDAuNSwxJyxcbiAgICBxdWFydGljSW5PdXQ6ICcwLjc2LDAsMC4yNCwxJyxcbiAgICBxdWludGljSW46ICcwLjY0LDAsMC43OCwwJyxcbiAgICBxdWludGljT3V0OiAnMC4yMiwxLDAuMzYsMScsXG4gICAgcXVpbnRpY0luT3V0OiAnMC44MywwLDAuMTcsMScsXG4gICAgc2ludXNvaWRhbEluOiAnMC4xMiwwLDAuMzksMCcsXG4gICAgc2ludXNvaWRhbE91dDogJzAuNjEsMSwwLjg4LDEnLFxuICAgIHNpbnVzb2lkYWxJbk91dDogJzAuMzcsMCwwLjYzLDEnLFxuICAgIGV4cG9uZW50aWFsSW46ICcwLjcsMCwwLjg0LDAnLFxuICAgIGV4cG9uZW50aWFsT3V0OiAnMC4xNiwxLDAuMywxJyxcbiAgICBleHBvbmVudGlhbEluT3V0OiAnMC44NywwLDAuMTMsMScsXG4gICAgY2lyY3VsYXJJbjogJzAuNTUsMCwxLDAuNDUnLFxuICAgIGNpcmN1bGFyT3V0OiAnMCwwLjU1LDAuNDUsMScsXG4gICAgY2lyY3VsYXJJbk91dDogJzAuODUsMCwwLjE1LDEnXG59O1xudmFyIHRyYW5zZm9ybU9yaWdpbktleSA9ICd0cmFuc2Zvcm0tb3JpZ2luJztcbmZ1bmN0aW9uIGJ1aWxkUGF0aFN0cmluZyhlbCwga2ZTaGFwZSwgcGF0aCkge1xuICAgIHZhciBzaGFwZSA9IGV4dGVuZCh7fSwgZWwuc2hhcGUpO1xuICAgIGV4dGVuZChzaGFwZSwga2ZTaGFwZSk7XG4gICAgZWwuYnVpbGRQYXRoKHBhdGgsIHNoYXBlKTtcbiAgICB2YXIgc3ZnUGF0aEJ1aWxkZXIgPSBuZXcgU1ZHUGF0aFJlYnVpbGRlcigpO1xuICAgIHN2Z1BhdGhCdWlsZGVyLnJlc2V0KGdldFBhdGhQcmVjaXNpb24oZWwpKTtcbiAgICBwYXRoLnJlYnVpbGRQYXRoKHN2Z1BhdGhCdWlsZGVyLCAxKTtcbiAgICBzdmdQYXRoQnVpbGRlci5nZW5lcmF0ZVN0cigpO1xuICAgIHJldHVybiBzdmdQYXRoQnVpbGRlci5nZXRTdHIoKTtcbn1cbmZ1bmN0aW9uIHNldFRyYW5zZm9ybU9yaWdpbih0YXJnZXQsIHRyYW5zZm9ybSkge1xuICAgIHZhciBvcmlnaW5YID0gdHJhbnNmb3JtLm9yaWdpblgsIG9yaWdpblkgPSB0cmFuc2Zvcm0ub3JpZ2luWTtcbiAgICBpZiAob3JpZ2luWCB8fCBvcmlnaW5ZKSB7XG4gICAgICAgIHRhcmdldFt0cmFuc2Zvcm1PcmlnaW5LZXldID0gb3JpZ2luWCArIFwicHggXCIgKyBvcmlnaW5ZICsgXCJweFwiO1xuICAgIH1cbn1cbmV4cG9ydCB2YXIgQU5JTUFURV9TVFlMRV9NQVAgPSB7XG4gICAgZmlsbDogJ2ZpbGwnLFxuICAgIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgICBsaW5lV2lkdGg6ICdzdHJva2Utd2lkdGgnLFxuICAgIGxpbmVEYXNoT2Zmc2V0OiAnc3Ryb2tlLWRhc2hvZmZzZXQnXG59O1xuZnVuY3Rpb24gYWRkQW5pbWF0aW9uKGNzc0FuaW0sIHNjb3BlKSB7XG4gICAgdmFyIGFuaW1hdGlvbk5hbWUgPSBzY29wZS56cklkICsgJy1hbmktJyArIHNjb3BlLmNzc0FuaW1JZHgrKztcbiAgICBzY29wZS5jc3NBbmltc1thbmltYXRpb25OYW1lXSA9IGNzc0FuaW07XG4gICAgcmV0dXJuIGFuaW1hdGlvbk5hbWU7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21wb3VuZFBhdGhDU1NBbmltYXRpb24oZWwsIGF0dHJzLCBzY29wZSkge1xuICAgIHZhciBwYXRocyA9IGVsLnNoYXBlLnBhdGhzO1xuICAgIHZhciBjb21wb3NlZEFuaW0gPSB7fTtcbiAgICB2YXIgY3NzQW5pbWF0aW9uQ2ZnO1xuICAgIHZhciBjc3NBbmltYXRpb25OYW1lO1xuICAgIGVhY2gocGF0aHMsIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBzdWJTY29wZSA9IGNyZWF0ZUJydXNoU2NvcGUoc2NvcGUuenJJZCk7XG4gICAgICAgIHN1YlNjb3BlLmFuaW1hdGlvbiA9IHRydWU7XG4gICAgICAgIGNyZWF0ZUNTU0FuaW1hdGlvbihwYXRoLCB7fSwgc3ViU2NvcGUsIHRydWUpO1xuICAgICAgICB2YXIgY3NzQW5pbXMgPSBzdWJTY29wZS5jc3NBbmltcztcbiAgICAgICAgdmFyIGNzc05vZGVzID0gc3ViU2NvcGUuY3NzTm9kZXM7XG4gICAgICAgIHZhciBhbmltTmFtZXMgPSBrZXlzKGNzc0FuaW1zKTtcbiAgICAgICAgdmFyIGxlbiA9IGFuaW1OYW1lcy5sZW5ndGg7XG4gICAgICAgIGlmICghbGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3NzQW5pbWF0aW9uTmFtZSA9IGFuaW1OYW1lc1tsZW4gLSAxXTtcbiAgICAgICAgdmFyIGxhc3RBbmltID0gY3NzQW5pbXNbY3NzQW5pbWF0aW9uTmFtZV07XG4gICAgICAgIGZvciAodmFyIHBlcmNlbnQgaW4gbGFzdEFuaW0pIHtcbiAgICAgICAgICAgIHZhciBrZiA9IGxhc3RBbmltW3BlcmNlbnRdO1xuICAgICAgICAgICAgY29tcG9zZWRBbmltW3BlcmNlbnRdID0gY29tcG9zZWRBbmltW3BlcmNlbnRdIHx8IHsgZDogJycgfTtcbiAgICAgICAgICAgIGNvbXBvc2VkQW5pbVtwZXJjZW50XS5kICs9IGtmLmQgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgY2xhc3NOYW1lIGluIGNzc05vZGVzKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gY3NzTm9kZXNbY2xhc3NOYW1lXS5hbmltYXRpb247XG4gICAgICAgICAgICBpZiAodmFsLmluZGV4T2YoY3NzQW5pbWF0aW9uTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNzc0FuaW1hdGlvbkNmZyA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY3NzQW5pbWF0aW9uQ2ZnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXR0cnMuZCA9IGZhbHNlO1xuICAgIHZhciBhbmltYXRpb25OYW1lID0gYWRkQW5pbWF0aW9uKGNvbXBvc2VkQW5pbSwgc2NvcGUpO1xuICAgIHJldHVybiBjc3NBbmltYXRpb25DZmcucmVwbGFjZShjc3NBbmltYXRpb25OYW1lLCBhbmltYXRpb25OYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEVhc2luZ0Z1bmMoZWFzaW5nKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKGVhc2luZylcbiAgICAgICAgPyBFQVNJTkdfTUFQW2Vhc2luZ11cbiAgICAgICAgICAgID8gXCJjdWJpYy1iZXppZXIoXCIgKyBFQVNJTkdfTUFQW2Vhc2luZ10gKyBcIilcIlxuICAgICAgICAgICAgOiBjcmVhdGVDdWJpY0Vhc2luZ0Z1bmMoZWFzaW5nKSA/IGVhc2luZyA6ICcnXG4gICAgICAgIDogJyc7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ1NTQW5pbWF0aW9uKGVsLCBhdHRycywgc2NvcGUsIG9ubHlTaGFwZSkge1xuICAgIHZhciBhbmltYXRvcnMgPSBlbC5hbmltYXRvcnM7XG4gICAgdmFyIGxlbiA9IGFuaW1hdG9ycy5sZW5ndGg7XG4gICAgdmFyIGNzc0FuaW1hdGlvbnMgPSBbXTtcbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbkNmZyA9IGNyZWF0ZUNvbXBvdW5kUGF0aENTU0FuaW1hdGlvbihlbCwgYXR0cnMsIHNjb3BlKTtcbiAgICAgICAgaWYgKGFuaW1hdGlvbkNmZykge1xuICAgICAgICAgICAgY3NzQW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbkNmZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWxlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFsZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZ3JvdXBBbmltYXRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBhbmltYXRvciA9IGFuaW1hdG9yc1tpXTtcbiAgICAgICAgdmFyIGNmZ0FyciA9IFthbmltYXRvci5nZXRNYXhUaW1lKCkgLyAxMDAwICsgJ3MnXTtcbiAgICAgICAgdmFyIGVhc2luZyA9IGdldEVhc2luZ0Z1bmMoYW5pbWF0b3IuZ2V0Q2xpcCgpLmVhc2luZyk7XG4gICAgICAgIHZhciBkZWxheSA9IGFuaW1hdG9yLmdldERlbGF5KCk7XG4gICAgICAgIGlmIChlYXNpbmcpIHtcbiAgICAgICAgICAgIGNmZ0Fyci5wdXNoKGVhc2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjZmdBcnIucHVzaCgnbGluZWFyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgICAgICBjZmdBcnIucHVzaChkZWxheSAvIDEwMDAgKyAncycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRvci5nZXRMb29wKCkpIHtcbiAgICAgICAgICAgIGNmZ0Fyci5wdXNoKCdpbmZpbml0ZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjZmcgPSBjZmdBcnIuam9pbignICcpO1xuICAgICAgICBncm91cEFuaW1hdG9yc1tjZmddID0gZ3JvdXBBbmltYXRvcnNbY2ZnXSB8fCBbY2ZnLCBbXV07XG4gICAgICAgIGdyb3VwQW5pbWF0b3JzW2NmZ11bMV0ucHVzaChhbmltYXRvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNpbmdsZUNTU0FuaW1hdGlvbihncm91cEFuaW1hdG9yKSB7XG4gICAgICAgIHZhciBhbmltYXRvcnMgPSBncm91cEFuaW1hdG9yWzFdO1xuICAgICAgICB2YXIgbGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICAgICAgdmFyIHRyYW5zZm9ybUtmcyA9IHt9O1xuICAgICAgICB2YXIgc2hhcGVLZnMgPSB7fTtcbiAgICAgICAgdmFyIGZpbmFsS2ZzID0ge307XG4gICAgICAgIHZhciBhbmltYXRpb25UaW1pbmdGdW5jdGlvbkF0dHJOYW1lID0gJ2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24nO1xuICAgICAgICBmdW5jdGlvbiBzYXZlQW5pbWF0b3JUcmFja1RvQ3NzS2ZzKGFuaW1hdG9yLCBjc3NLZnMsIHRvQ3NzQXR0ck5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0cmFja3MgPSBhbmltYXRvci5nZXRUcmFja3MoKTtcbiAgICAgICAgICAgIHZhciBtYXhUaW1lID0gYW5pbWF0b3IuZ2V0TWF4VGltZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0cmFja3MubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3Nba107XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrLm5lZWRzQW5pbWF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZnMgPSB0cmFjay5rZXlmcmFtZXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IHRyYWNrLnByb3BOYW1lO1xuICAgICAgICAgICAgICAgICAgICB0b0Nzc0F0dHJOYW1lICYmIChhdHRyTmFtZSA9IHRvQ3NzQXR0ck5hbWUoYXR0ck5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZiA9IGtmc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IE1hdGgucm91bmQoa2YudGltZSAvIG1heFRpbWUgKiAxMDApICsgJyUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZkVhc2luZyA9IGdldEVhc2luZ0Z1bmMoa2YuZWFzaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3VmFsdWUgPSBrZi5yYXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcocmF3VmFsdWUpIHx8IGlzTnVtYmVyKHJhd1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NLZnNbcGVyY2VudF0gPSBjc3NLZnNbcGVyY2VudF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc0tmc1twZXJjZW50XVthdHRyTmFtZV0gPSBrZi5yYXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtmRWFzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NLZnNbcGVyY2VudF1bYW5pbWF0aW9uVGltaW5nRnVuY3Rpb25BdHRyTmFtZV0gPSBrZkVhc2luZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBhbmltYXRvcnNbaV07XG4gICAgICAgICAgICB2YXIgdGFyZ2V0UHJvcCA9IGFuaW1hdG9yLnRhcmdldE5hbWU7XG4gICAgICAgICAgICBpZiAoIXRhcmdldFByb3ApIHtcbiAgICAgICAgICAgICAgICAhb25seVNoYXBlICYmIHNhdmVBbmltYXRvclRyYWNrVG9Dc3NLZnMoYW5pbWF0b3IsIHRyYW5zZm9ybUtmcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRQcm9wID09PSAnc2hhcGUnKSB7XG4gICAgICAgICAgICAgICAgc2F2ZUFuaW1hdG9yVHJhY2tUb0Nzc0tmcyhhbmltYXRvciwgc2hhcGVLZnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHBlcmNlbnQgaW4gdHJhbnNmb3JtS2ZzKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0ge307XG4gICAgICAgICAgICBjb3B5VHJhbnNmb3JtKHRyYW5zZm9ybSwgZWwpO1xuICAgICAgICAgICAgZXh0ZW5kKHRyYW5zZm9ybSwgdHJhbnNmb3JtS2ZzW3BlcmNlbnRdKTtcbiAgICAgICAgICAgIHZhciBzdHIgPSBnZXRTUlRUcmFuc2Zvcm1TdHJpbmcodHJhbnNmb3JtKTtcbiAgICAgICAgICAgIHZhciB0aW1pbmdGdW5jdGlvbiA9IHRyYW5zZm9ybUtmc1twZXJjZW50XVthbmltYXRpb25UaW1pbmdGdW5jdGlvbkF0dHJOYW1lXTtcbiAgICAgICAgICAgIGZpbmFsS2ZzW3BlcmNlbnRdID0gc3RyID8ge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc3RyXG4gICAgICAgICAgICB9IDoge307XG4gICAgICAgICAgICBzZXRUcmFuc2Zvcm1PcmlnaW4oZmluYWxLZnNbcGVyY2VudF0sIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICBpZiAodGltaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBmaW5hbEtmc1twZXJjZW50XVthbmltYXRpb25UaW1pbmdGdW5jdGlvbkF0dHJOYW1lXSA9IHRpbWluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgdmFyIHBhdGg7XG4gICAgICAgIHZhciBjYW5BbmltYXRlU2hhcGUgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBwZXJjZW50IGluIHNoYXBlS2ZzKSB7XG4gICAgICAgICAgICBmaW5hbEtmc1twZXJjZW50XSA9IGZpbmFsS2ZzW3BlcmNlbnRdIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGlzRmlyc3QgPSAhcGF0aDtcbiAgICAgICAgICAgIHZhciB0aW1pbmdGdW5jdGlvbiA9IHNoYXBlS2ZzW3BlcmNlbnRdW2FuaW1hdGlvblRpbWluZ0Z1bmN0aW9uQXR0ck5hbWVdO1xuICAgICAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlbl8xID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgIHBhdGgucmVzZXQoKTtcbiAgICAgICAgICAgIGZpbmFsS2ZzW3BlcmNlbnRdLmQgPSBidWlsZFBhdGhTdHJpbmcoZWwsIHNoYXBlS2ZzW3BlcmNlbnRdLCBwYXRoKTtcbiAgICAgICAgICAgIHZhciBuZXdMZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgaWYgKCFpc0ZpcnN0ICYmIGxlbl8xICE9PSBuZXdMZW4pIHtcbiAgICAgICAgICAgICAgICBjYW5BbmltYXRlU2hhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1pbmdGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGZpbmFsS2ZzW3BlcmNlbnRdW2FuaW1hdGlvblRpbWluZ0Z1bmN0aW9uQXR0ck5hbWVdID0gdGltaW5nRnVuY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAoIWNhbkFuaW1hdGVTaGFwZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgcGVyY2VudCBpbiBmaW5hbEtmcykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBmaW5hbEtmc1twZXJjZW50XS5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb25seVNoYXBlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdG9yID0gYW5pbWF0b3JzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRQcm9wID0gYW5pbWF0b3IudGFyZ2V0TmFtZTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0UHJvcCA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgICAgICBzYXZlQW5pbWF0b3JUcmFja1RvQ3NzS2ZzKGFuaW1hdG9yLCBmaW5hbEtmcywgZnVuY3Rpb24gKHByb3BOYW1lKSB7IHJldHVybiBBTklNQVRFX1NUWUxFX01BUFtwcm9wTmFtZV07IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcGVyY2VudHMgPSBrZXlzKGZpbmFsS2ZzKTtcbiAgICAgICAgdmFyIGFsbFRyYW5zZm9ybU9yaWdpblNhbWUgPSB0cnVlO1xuICAgICAgICB2YXIgdHJhbnNmb3JtT3JpZ2luO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBlcmNlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcDAgPSBwZXJjZW50c1tpIC0gMV07XG4gICAgICAgICAgICB2YXIgcDEgPSBwZXJjZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChmaW5hbEtmc1twMF1bdHJhbnNmb3JtT3JpZ2luS2V5XSAhPT0gZmluYWxLZnNbcDFdW3RyYW5zZm9ybU9yaWdpbktleV0pIHtcbiAgICAgICAgICAgICAgICBhbGxUcmFuc2Zvcm1PcmlnaW5TYW1lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW4gPSBmaW5hbEtmc1twMF1bdHJhbnNmb3JtT3JpZ2luS2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsVHJhbnNmb3JtT3JpZ2luU2FtZSAmJiB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIHBlcmNlbnQgaW4gZmluYWxLZnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxLZnNbcGVyY2VudF1bdHJhbnNmb3JtT3JpZ2luS2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZmluYWxLZnNbcGVyY2VudF1bdHJhbnNmb3JtT3JpZ2luS2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRyc1t0cmFuc2Zvcm1PcmlnaW5LZXldID0gdHJhbnNmb3JtT3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXIocGVyY2VudHMsIGZ1bmN0aW9uIChwZXJjZW50KSB7IHJldHVybiBrZXlzKGZpbmFsS2ZzW3BlcmNlbnRdKS5sZW5ndGggPiAwOyB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25OYW1lID0gYWRkQW5pbWF0aW9uKGZpbmFsS2ZzLCBzY29wZSk7XG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uTmFtZSArIFwiIFwiICsgZ3JvdXBBbmltYXRvclswXSArIFwiIGJvdGhcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gZ3JvdXBBbmltYXRvcnMpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbkNmZyA9IGNyZWF0ZVNpbmdsZUNTU0FuaW1hdGlvbihncm91cEFuaW1hdG9yc1trZXldKTtcbiAgICAgICAgaWYgKGFuaW1hdGlvbkNmZykge1xuICAgICAgICAgICAgY3NzQW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbkNmZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNzc0FuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBzY29wZS56cklkICsgJy1jbHMtJyArIGdldENsYXNzSWQoKTtcbiAgICAgICAgc2NvcGUuY3NzTm9kZXNbJy4nICsgY2xhc3NOYW1lXSA9IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbjogY3NzQW5pbWF0aW9ucy5qb2luKCcsJylcbiAgICAgICAgfTtcbiAgICAgICAgYXR0cnNbXCJjbGFzc1wiXSA9IGNsYXNzTmFtZTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBsaWZ0Q29sb3IgfSBmcm9tICcuLi90b29sL2NvbG9yLmpzJztcbmltcG9ydCB7IGdldENsYXNzSWQgfSBmcm9tICcuL2Nzc0NsYXNzSWQuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNTU0VtcGhhc2lzKGVsLCBhdHRycywgc2NvcGUpIHtcbiAgICBpZiAoIWVsLmlnbm9yZSkge1xuICAgICAgICBpZiAoZWwuaXNTaWxlbnQoKSkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICdub25lJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldENsYXNzQXR0cmlidXRlKHN0eWxlLCBhdHRycywgc2NvcGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVtcGhhc2lzU3R5bGUgPSBlbC5zdGF0ZXMuZW1waGFzaXMgJiYgZWwuc3RhdGVzLmVtcGhhc2lzLnN0eWxlXG4gICAgICAgICAgICAgICAgPyBlbC5zdGF0ZXMuZW1waGFzaXMuc3R5bGVcbiAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICAgICAgdmFyIGZpbGwgPSBlbXBoYXNpc1N0eWxlLmZpbGw7XG4gICAgICAgICAgICBpZiAoIWZpbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsRmlsbCA9IGVsLnN0eWxlICYmIGVsLnN0eWxlLmZpbGw7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdEZpbGwgPSBlbC5zdGF0ZXMuc2VsZWN0XG4gICAgICAgICAgICAgICAgICAgICYmIGVsLnN0YXRlcy5zZWxlY3Quc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgJiYgZWwuc3RhdGVzLnNlbGVjdC5zdHlsZS5maWxsO1xuICAgICAgICAgICAgICAgIHZhciBmcm9tRmlsbCA9IGVsLmN1cnJlbnRTdGF0ZXMuaW5kZXhPZignc2VsZWN0JykgPj0gMFxuICAgICAgICAgICAgICAgICAgICA/IChzZWxlY3RGaWxsIHx8IG5vcm1hbEZpbGwpXG4gICAgICAgICAgICAgICAgICAgIDogbm9ybWFsRmlsbDtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUZpbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbCA9IGxpZnRDb2xvcihmcm9tRmlsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGVtcGhhc2lzU3R5bGUubGluZVdpZHRoO1xuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCkge1xuICAgICAgICAgICAgICAgIHZhciBzY2FsZVggPSAoIWVtcGhhc2lzU3R5bGUuc3Ryb2tlTm9TY2FsZSAmJiBlbC50cmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgICAgID8gZWwudHJhbnNmb3JtWzBdXG4gICAgICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBsaW5lV2lkdGggLyBzY2FsZVg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgICAgIHN0eWxlLmZpbGwgPSBmaWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVtcGhhc2lzU3R5bGUuc3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuc3Ryb2tlID0gZW1waGFzaXNTdHlsZS5zdHJva2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVbJ3N0cm9rZS13aWR0aCddID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q2xhc3NBdHRyaWJ1dGUoc3R5bGUsIGF0dHJzLCBzY29wZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzZXRDbGFzc0F0dHJpYnV0ZShzdHlsZSwgYXR0cnMsIHNjb3BlLCB3aXRoSG92ZXIpIHtcbiAgICB2YXIgc3R5bGVLZXkgPSBKU09OLnN0cmluZ2lmeShzdHlsZSk7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHNjb3BlLmNzc1N0eWxlQ2FjaGVbc3R5bGVLZXldO1xuICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IHNjb3BlLnpySWQgKyAnLWNscy0nICsgZ2V0Q2xhc3NJZCgpO1xuICAgICAgICBzY29wZS5jc3NTdHlsZUNhY2hlW3N0eWxlS2V5XSA9IGNsYXNzTmFtZTtcbiAgICAgICAgc2NvcGUuY3NzTm9kZXNbJy4nICsgY2xhc3NOYW1lICsgKHdpdGhIb3ZlciA/ICc6aG92ZXInIDogJycpXSA9IHN0eWxlO1xuICAgIH1cbiAgICBhdHRyc1tcImNsYXNzXCJdID0gYXR0cnNbXCJjbGFzc1wiXSA/IChhdHRyc1tcImNsYXNzXCJdICsgJyAnICsgY2xhc3NOYW1lKSA6IGNsYXNzTmFtZTtcbn1cbiIsImltcG9ydCB7IGFkanVzdFRleHRZLCBnZXRJZFVSTCwgZ2V0TWF0cml4U3RyLCBnZXRQYXRoUHJlY2lzaW9uLCBnZXRTaGFkb3dLZXksIGdldFNSVFRyYW5zZm9ybVN0cmluZywgaGFzU2hhZG93LCBpc0Fyb3VuZFplcm8sIGlzR3JhZGllbnQsIGlzSW1hZ2VQYXR0ZXJuLCBpc0xpbmVhckdyYWRpZW50LCBpc1BhdHRlcm4sIGlzUmFkaWFsR3JhZGllbnQsIG5vcm1hbGl6ZUNvbG9yLCByb3VuZDQsIFRFWFRfQUxJR05fVE9fQU5DSE9SIH0gZnJvbSAnLi9oZWxwZXIuanMnO1xuaW1wb3J0IFBhdGggZnJvbSAnLi4vZ3JhcGhpYy9QYXRoLmpzJztcbmltcG9ydCBaUkltYWdlIGZyb20gJy4uL2dyYXBoaWMvSW1hZ2UuanMnO1xuaW1wb3J0IHsgZ2V0TGluZUhlaWdodCB9IGZyb20gJy4uL2NvbnRhaW4vdGV4dC5qcyc7XG5pbXBvcnQgVFNwYW4gZnJvbSAnLi4vZ3JhcGhpYy9UU3Bhbi5qcyc7XG5pbXBvcnQgU1ZHUGF0aFJlYnVpbGRlciBmcm9tICcuL1NWR1BhdGhSZWJ1aWxkZXIuanMnO1xuaW1wb3J0IG1hcFN0eWxlVG9BdHRycyBmcm9tICcuL21hcFN0eWxlVG9BdHRycy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSwgdk5vZGVUb1N0cmluZywgTUVUQV9EQVRBX1BSRUZJWCB9IGZyb20gJy4vY29yZS5qcyc7XG5pbXBvcnQgeyBhc3NlcnQsIGNsb25lLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgbG9nRXJyb3IsIG1hcCwgcmV0cmlldmUyIH0gZnJvbSAnLi4vY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGNyZWF0ZU9yVXBkYXRlSW1hZ2UgfSBmcm9tICcuLi9ncmFwaGljL2hlbHBlci9pbWFnZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDU1NBbmltYXRpb24gfSBmcm9tICcuL2Nzc0FuaW1hdGlvbi5qcyc7XG5pbXBvcnQgeyBoYXNTZXBhcmF0ZUZvbnQsIHBhcnNlRm9udFNpemUgfSBmcm9tICcuLi9ncmFwaGljL1RleHQuanMnO1xuaW1wb3J0IHsgREVGQVVMVF9GT05ULCBERUZBVUxUX0ZPTlRfRkFNSUxZIH0gZnJvbSAnLi4vY29yZS9wbGF0Zm9ybS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDU1NFbXBoYXNpcyB9IGZyb20gJy4vY3NzRW1waGFzaXMuanMnO1xuaW1wb3J0IHsgZ2V0RWxlbWVudFNTUkRhdGEgfSBmcm9tICcuLi96cmVuZGVyLmpzJztcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG5mdW5jdGlvbiBpc0ltYWdlTGlrZSh2YWwpIHtcbiAgICByZXR1cm4gdmFsICYmIGlzU3RyaW5nKHZhbC5zcmMpO1xufVxuZnVuY3Rpb24gaXNDYW52YXNMaWtlKHZhbCkge1xuICAgIHJldHVybiB2YWwgJiYgaXNGdW5jdGlvbih2YWwudG9EYXRhVVJMKTtcbn1cbmZ1bmN0aW9uIHNldFN0eWxlQXR0cnMoYXR0cnMsIHN0eWxlLCBlbCwgc2NvcGUpIHtcbiAgICBtYXBTdHlsZVRvQXR0cnMoZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgIHZhciBpc0ZpbGxTdHJva2UgPSBrZXkgPT09ICdmaWxsJyB8fCBrZXkgPT09ICdzdHJva2UnO1xuICAgICAgICBpZiAoaXNGaWxsU3Ryb2tlICYmIGlzR3JhZGllbnQodmFsKSkge1xuICAgICAgICAgICAgc2V0R3JhZGllbnQoc3R5bGUsIGF0dHJzLCBrZXksIHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0ZpbGxTdHJva2UgJiYgaXNQYXR0ZXJuKHZhbCkpIHtcbiAgICAgICAgICAgIHNldFBhdHRlcm4oZWwsIGF0dHJzLCBrZXksIHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRmlsbFN0cm9rZSAmJiBzY29wZS5zc3IgJiYgdmFsID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGF0dHJzWydwb2ludGVyLWV2ZW50cyddID0gJ3Zpc2libGUnO1xuICAgICAgICB9XG4gICAgfSwgc3R5bGUsIGVsLCBmYWxzZSk7XG4gICAgc2V0U2hhZG93KGVsLCBhdHRycywgc2NvcGUpO1xufVxuZnVuY3Rpb24gc2V0TWV0YURhdGEoYXR0cnMsIGVsKSB7XG4gICAgdmFyIG1ldGFEYXRhID0gZ2V0RWxlbWVudFNTUkRhdGEoZWwpO1xuICAgIGlmIChtZXRhRGF0YSkge1xuICAgICAgICBtZXRhRGF0YS5lYWNoKGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgICAgICAgICAgdmFsICE9IG51bGwgJiYgKGF0dHJzWyhNRVRBX0RBVEFfUFJFRklYICsga2V5KS50b0xvd2VyQ2FzZSgpXSA9IHZhbCArICcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlbC5pc1NpbGVudCgpKSB7XG4gICAgICAgICAgICBhdHRyc1tNRVRBX0RBVEFfUFJFRklYICsgJ3NpbGVudCddID0gJ3RydWUnO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbm9Sb3RhdGVTY2FsZShtKSB7XG4gICAgcmV0dXJuIGlzQXJvdW5kWmVybyhtWzBdIC0gMSlcbiAgICAgICAgJiYgaXNBcm91bmRaZXJvKG1bMV0pXG4gICAgICAgICYmIGlzQXJvdW5kWmVybyhtWzJdKVxuICAgICAgICAmJiBpc0Fyb3VuZFplcm8obVszXSAtIDEpO1xufVxuZnVuY3Rpb24gbm9UcmFuc2xhdGUobSkge1xuICAgIHJldHVybiBpc0Fyb3VuZFplcm8obVs0XSkgJiYgaXNBcm91bmRaZXJvKG1bNV0pO1xufVxuZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGF0dHJzLCBtLCBjb21wcmVzcykge1xuICAgIGlmIChtICYmICEobm9UcmFuc2xhdGUobSkgJiYgbm9Sb3RhdGVTY2FsZShtKSkpIHtcbiAgICAgICAgdmFyIG11bCA9IGNvbXByZXNzID8gMTAgOiAxZTQ7XG4gICAgICAgIGF0dHJzLnRyYW5zZm9ybSA9IG5vUm90YXRlU2NhbGUobSlcbiAgICAgICAgICAgID8gXCJ0cmFuc2xhdGUoXCIgKyByb3VuZChtWzRdICogbXVsKSAvIG11bCArIFwiIFwiICsgcm91bmQobVs1XSAqIG11bCkgLyBtdWwgKyBcIilcIiA6IGdldE1hdHJpeFN0cihtKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0UG9seVNoYXBlKHNoYXBlLCBhdHRycywgbXVsKSB7XG4gICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICB2YXIgc3RyQXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RyQXJyLnB1c2gocm91bmQocG9pbnRzW2ldWzBdICogbXVsKSAvIG11bCk7XG4gICAgICAgIHN0ckFyci5wdXNoKHJvdW5kKHBvaW50c1tpXVsxXSAqIG11bCkgLyBtdWwpO1xuICAgIH1cbiAgICBhdHRycy5wb2ludHMgPSBzdHJBcnIuam9pbignICcpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQb2x5U2hhcGUoc2hhcGUpIHtcbiAgICByZXR1cm4gIXNoYXBlLnNtb290aDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUF0dHJzQ29udmVydChkZXNjKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWREZXNjID0gbWFwKGRlc2MsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnID8gW2l0ZW0sIGl0ZW1dIDogaXRlbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzaGFwZSwgYXR0cnMsIG11bCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vcm1hbGl6ZWREZXNjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IG5vcm1hbGl6ZWREZXNjW2ldO1xuICAgICAgICAgICAgdmFyIHZhbCA9IHNoYXBlW2l0ZW1bMF1dO1xuICAgICAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNbaXRlbVsxXV0gPSByb3VuZCh2YWwgKiBtdWwpIC8gbXVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbnZhciBidWlsdGluU2hhcGVzRGVmID0ge1xuICAgIGNpcmNsZTogW2NyZWF0ZUF0dHJzQ29udmVydChbJ2N4JywgJ2N5JywgJ3InXSldLFxuICAgIHBvbHlsaW5lOiBbY29udmVydFBvbHlTaGFwZSwgdmFsaWRhdGVQb2x5U2hhcGVdLFxuICAgIHBvbHlnb246IFtjb252ZXJ0UG9seVNoYXBlLCB2YWxpZGF0ZVBvbHlTaGFwZV1cbn07XG5mdW5jdGlvbiBoYXNTaGFwZUFuaW1hdGlvbihlbCkge1xuICAgIHZhciBhbmltYXRvcnMgPSBlbC5hbmltYXRvcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFuaW1hdG9yc1tpXS50YXJnZXROYW1lID09PSAnc2hhcGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gYnJ1c2hTVkdQYXRoKGVsLCBzY29wZSkge1xuICAgIHZhciBzdHlsZSA9IGVsLnN0eWxlO1xuICAgIHZhciBzaGFwZSA9IGVsLnNoYXBlO1xuICAgIHZhciBidWlsdGluU2hwRGVmID0gYnVpbHRpblNoYXBlc0RlZltlbC50eXBlXTtcbiAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICB2YXIgbmVlZHNBbmltYXRlID0gc2NvcGUuYW5pbWF0aW9uO1xuICAgIHZhciBzdmdFbFR5cGUgPSAncGF0aCc7XG4gICAgdmFyIHN0cm9rZVBlcmNlbnQgPSBlbC5zdHlsZS5zdHJva2VQZXJjZW50O1xuICAgIHZhciBwcmVjaXNpb24gPSAoc2NvcGUuY29tcHJlc3MgJiYgZ2V0UGF0aFByZWNpc2lvbihlbCkpIHx8IDQ7XG4gICAgaWYgKGJ1aWx0aW5TaHBEZWZcbiAgICAgICAgJiYgIXNjb3BlLndpbGxVcGRhdGVcbiAgICAgICAgJiYgIShidWlsdGluU2hwRGVmWzFdICYmICFidWlsdGluU2hwRGVmWzFdKHNoYXBlKSlcbiAgICAgICAgJiYgIShuZWVkc0FuaW1hdGUgJiYgaGFzU2hhcGVBbmltYXRpb24oZWwpKVxuICAgICAgICAmJiAhKHN0cm9rZVBlcmNlbnQgPCAxKSkge1xuICAgICAgICBzdmdFbFR5cGUgPSBlbC50eXBlO1xuICAgICAgICB2YXIgbXVsID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgICAgIGJ1aWx0aW5TaHBEZWZbMF0oc2hhcGUsIGF0dHJzLCBtdWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG5lZWRCdWlsZFBhdGggPSAhZWwucGF0aCB8fCBlbC5zaGFwZUNoYW5nZWQoKTtcbiAgICAgICAgaWYgKCFlbC5wYXRoKSB7XG4gICAgICAgICAgICBlbC5jcmVhdGVQYXRoUHJveHkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aCA9IGVsLnBhdGg7XG4gICAgICAgIGlmIChuZWVkQnVpbGRQYXRoKSB7XG4gICAgICAgICAgICBwYXRoLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgZWwuYnVpbGRQYXRoKHBhdGgsIGVsLnNoYXBlKTtcbiAgICAgICAgICAgIGVsLnBhdGhVcGRhdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdGhWZXJzaW9uID0gcGF0aC5nZXRWZXJzaW9uKCk7XG4gICAgICAgIHZhciBlbEV4dCA9IGVsO1xuICAgICAgICB2YXIgc3ZnUGF0aEJ1aWxkZXIgPSBlbEV4dC5fX3N2Z1BhdGhCdWlsZGVyO1xuICAgICAgICBpZiAoZWxFeHQuX19zdmdQYXRoVmVyc2lvbiAhPT0gcGF0aFZlcnNpb25cbiAgICAgICAgICAgIHx8ICFzdmdQYXRoQnVpbGRlclxuICAgICAgICAgICAgfHwgc3Ryb2tlUGVyY2VudCAhPT0gZWxFeHQuX19zdmdQYXRoU3Ryb2tlUGVyY2VudCkge1xuICAgICAgICAgICAgaWYgKCFzdmdQYXRoQnVpbGRlcikge1xuICAgICAgICAgICAgICAgIHN2Z1BhdGhCdWlsZGVyID0gZWxFeHQuX19zdmdQYXRoQnVpbGRlciA9IG5ldyBTVkdQYXRoUmVidWlsZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdmdQYXRoQnVpbGRlci5yZXNldChwcmVjaXNpb24pO1xuICAgICAgICAgICAgcGF0aC5yZWJ1aWxkUGF0aChzdmdQYXRoQnVpbGRlciwgc3Ryb2tlUGVyY2VudCk7XG4gICAgICAgICAgICBzdmdQYXRoQnVpbGRlci5nZW5lcmF0ZVN0cigpO1xuICAgICAgICAgICAgZWxFeHQuX19zdmdQYXRoVmVyc2lvbiA9IHBhdGhWZXJzaW9uO1xuICAgICAgICAgICAgZWxFeHQuX19zdmdQYXRoU3Ryb2tlUGVyY2VudCA9IHN0cm9rZVBlcmNlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMuZCA9IHN2Z1BhdGhCdWlsZGVyLmdldFN0cigpO1xuICAgIH1cbiAgICBzZXRUcmFuc2Zvcm0oYXR0cnMsIGVsLnRyYW5zZm9ybSk7XG4gICAgc2V0U3R5bGVBdHRycyhhdHRycywgc3R5bGUsIGVsLCBzY29wZSk7XG4gICAgc2V0TWV0YURhdGEoYXR0cnMsIGVsKTtcbiAgICBzY29wZS5hbmltYXRpb24gJiYgY3JlYXRlQ1NTQW5pbWF0aW9uKGVsLCBhdHRycywgc2NvcGUpO1xuICAgIHNjb3BlLmVtcGhhc2lzICYmIGNyZWF0ZUNTU0VtcGhhc2lzKGVsLCBhdHRycywgc2NvcGUpO1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShzdmdFbFR5cGUsIGVsLmlkICsgJycsIGF0dHJzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBicnVzaFNWR0ltYWdlKGVsLCBzY29wZSkge1xuICAgIHZhciBzdHlsZSA9IGVsLnN0eWxlO1xuICAgIHZhciBpbWFnZSA9IHN0eWxlLmltYWdlO1xuICAgIGlmIChpbWFnZSAmJiAhaXNTdHJpbmcoaW1hZ2UpKSB7XG4gICAgICAgIGlmIChpc0ltYWdlTGlrZShpbWFnZSkpIHtcbiAgICAgICAgICAgIGltYWdlID0gaW1hZ2Uuc3JjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2FudmFzTGlrZShpbWFnZSkpIHtcbiAgICAgICAgICAgIGltYWdlID0gaW1hZ2UudG9EYXRhVVJMKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICAgIHZhciB5ID0gc3R5bGUueSB8fCAwO1xuICAgIHZhciBkdyA9IHN0eWxlLndpZHRoO1xuICAgIHZhciBkaCA9IHN0eWxlLmhlaWdodDtcbiAgICB2YXIgYXR0cnMgPSB7XG4gICAgICAgIGhyZWY6IGltYWdlLFxuICAgICAgICB3aWR0aDogZHcsXG4gICAgICAgIGhlaWdodDogZGhcbiAgICB9O1xuICAgIGlmICh4KSB7XG4gICAgICAgIGF0dHJzLnggPSB4O1xuICAgIH1cbiAgICBpZiAoeSkge1xuICAgICAgICBhdHRycy55ID0geTtcbiAgICB9XG4gICAgc2V0VHJhbnNmb3JtKGF0dHJzLCBlbC50cmFuc2Zvcm0pO1xuICAgIHNldFN0eWxlQXR0cnMoYXR0cnMsIHN0eWxlLCBlbCwgc2NvcGUpO1xuICAgIHNldE1ldGFEYXRhKGF0dHJzLCBlbCk7XG4gICAgc2NvcGUuYW5pbWF0aW9uICYmIGNyZWF0ZUNTU0FuaW1hdGlvbihlbCwgYXR0cnMsIHNjb3BlKTtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoJ2ltYWdlJywgZWwuaWQgKyAnJywgYXR0cnMpO1xufVxuO1xuZXhwb3J0IGZ1bmN0aW9uIGJydXNoU1ZHVFNwYW4oZWwsIHNjb3BlKSB7XG4gICAgdmFyIHN0eWxlID0gZWwuc3R5bGU7XG4gICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0O1xuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG4gICAgaWYgKCF0ZXh0IHx8IGlzTmFOKHN0eWxlLngpIHx8IGlzTmFOKHN0eWxlLnkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGZvbnQgPSBzdHlsZS5mb250IHx8IERFRkFVTFRfRk9OVDtcbiAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICB2YXIgeSA9IGFkanVzdFRleHRZKHN0eWxlLnkgfHwgMCwgZ2V0TGluZUhlaWdodChmb250KSwgc3R5bGUudGV4dEJhc2VsaW5lKTtcbiAgICB2YXIgdGV4dEFsaWduID0gVEVYVF9BTElHTl9UT19BTkNIT1Jbc3R5bGUudGV4dEFsaWduXVxuICAgICAgICB8fCBzdHlsZS50ZXh0QWxpZ247XG4gICAgdmFyIGF0dHJzID0ge1xuICAgICAgICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnY2VudHJhbCcsXG4gICAgICAgICd0ZXh0LWFuY2hvcic6IHRleHRBbGlnblxuICAgIH07XG4gICAgaWYgKGhhc1NlcGFyYXRlRm9udChzdHlsZSkpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRlZEZvbnRTdHIgPSAnJztcbiAgICAgICAgdmFyIGZvbnRTdHlsZSA9IHN0eWxlLmZvbnRTdHlsZTtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gcGFyc2VGb250U2l6ZShzdHlsZS5mb250U2l6ZSk7XG4gICAgICAgIGlmICghcGFyc2VGbG9hdChmb250U2l6ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHkgfHwgREVGQVVMVF9GT05UX0ZBTUlMWTtcbiAgICAgICAgdmFyIGZvbnRXZWlnaHQgPSBzdHlsZS5mb250V2VpZ2h0O1xuICAgICAgICBzZXBhcmF0ZWRGb250U3RyICs9IFwiZm9udC1zaXplOlwiICsgZm9udFNpemUgKyBcIjtmb250LWZhbWlseTpcIiArIGZvbnRGYW1pbHkgKyBcIjtcIjtcbiAgICAgICAgaWYgKGZvbnRTdHlsZSAmJiBmb250U3R5bGUgIT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgICBzZXBhcmF0ZWRGb250U3RyICs9IFwiZm9udC1zdHlsZTpcIiArIGZvbnRTdHlsZSArIFwiO1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb250V2VpZ2h0ICYmIGZvbnRXZWlnaHQgIT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgICBzZXBhcmF0ZWRGb250U3RyICs9IFwiZm9udC13ZWlnaHQ6XCIgKyBmb250V2VpZ2h0ICsgXCI7XCI7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMuc3R5bGUgPSBzZXBhcmF0ZWRGb250U3RyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXR0cnMuc3R5bGUgPSBcImZvbnQ6IFwiICsgZm9udDtcbiAgICB9XG4gICAgaWYgKHRleHQubWF0Y2goL1xccy8pKSB7XG4gICAgICAgIGF0dHJzWyd4bWw6c3BhY2UnXSA9ICdwcmVzZXJ2ZSc7XG4gICAgfVxuICAgIGlmICh4KSB7XG4gICAgICAgIGF0dHJzLnggPSB4O1xuICAgIH1cbiAgICBpZiAoeSkge1xuICAgICAgICBhdHRycy55ID0geTtcbiAgICB9XG4gICAgc2V0VHJhbnNmb3JtKGF0dHJzLCBlbC50cmFuc2Zvcm0pO1xuICAgIHNldFN0eWxlQXR0cnMoYXR0cnMsIHN0eWxlLCBlbCwgc2NvcGUpO1xuICAgIHNldE1ldGFEYXRhKGF0dHJzLCBlbCk7XG4gICAgc2NvcGUuYW5pbWF0aW9uICYmIGNyZWF0ZUNTU0FuaW1hdGlvbihlbCwgYXR0cnMsIHNjb3BlKTtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoJ3RleHQnLCBlbC5pZCArICcnLCBhdHRycywgdW5kZWZpbmVkLCB0ZXh0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBicnVzaChlbCwgc2NvcGUpIHtcbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgICAgIHJldHVybiBicnVzaFNWR1BhdGgoZWwsIHNjb3BlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZWwgaW5zdGFuY2VvZiBaUkltYWdlKSB7XG4gICAgICAgIHJldHVybiBicnVzaFNWR0ltYWdlKGVsLCBzY29wZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgVFNwYW4pIHtcbiAgICAgICAgcmV0dXJuIGJydXNoU1ZHVFNwYW4oZWwsIHNjb3BlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRTaGFkb3coZWwsIGF0dHJzLCBzY29wZSkge1xuICAgIHZhciBzdHlsZSA9IGVsLnN0eWxlO1xuICAgIGlmIChoYXNTaGFkb3coc3R5bGUpKSB7XG4gICAgICAgIHZhciBzaGFkb3dLZXkgPSBnZXRTaGFkb3dLZXkoZWwpO1xuICAgICAgICB2YXIgc2hhZG93Q2FjaGUgPSBzY29wZS5zaGFkb3dDYWNoZTtcbiAgICAgICAgdmFyIHNoYWRvd0lkID0gc2hhZG93Q2FjaGVbc2hhZG93S2V5XTtcbiAgICAgICAgaWYgKCFzaGFkb3dJZCkge1xuICAgICAgICAgICAgdmFyIGdsb2JhbFNjYWxlID0gZWwuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICAgICAgICAgIHZhciBzY2FsZVggPSBnbG9iYWxTY2FsZVswXTtcbiAgICAgICAgICAgIHZhciBzY2FsZVkgPSBnbG9iYWxTY2FsZVsxXTtcbiAgICAgICAgICAgIGlmICghc2NhbGVYIHx8ICFzY2FsZVkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IHN0eWxlLnNoYWRvd09mZnNldFggfHwgMDtcbiAgICAgICAgICAgIHZhciBvZmZzZXRZID0gc3R5bGUuc2hhZG93T2Zmc2V0WSB8fCAwO1xuICAgICAgICAgICAgdmFyIGJsdXJfMSA9IHN0eWxlLnNoYWRvd0JsdXI7XG4gICAgICAgICAgICB2YXIgX2EgPSBub3JtYWxpemVDb2xvcihzdHlsZS5zaGFkb3dDb2xvciksIG9wYWNpdHkgPSBfYS5vcGFjaXR5LCBjb2xvciA9IF9hLmNvbG9yO1xuICAgICAgICAgICAgdmFyIHN0ZER4ID0gYmx1cl8xIC8gMiAvIHNjYWxlWDtcbiAgICAgICAgICAgIHZhciBzdGREeSA9IGJsdXJfMSAvIDIgLyBzY2FsZVk7XG4gICAgICAgICAgICB2YXIgc3RkRGV2aWF0aW9uID0gc3RkRHggKyAnICcgKyBzdGREeTtcbiAgICAgICAgICAgIHNoYWRvd0lkID0gc2NvcGUuenJJZCArICctcycgKyBzY29wZS5zaGFkb3dJZHgrKztcbiAgICAgICAgICAgIHNjb3BlLmRlZnNbc2hhZG93SWRdID0gY3JlYXRlVk5vZGUoJ2ZpbHRlcicsIHNoYWRvd0lkLCB7XG4gICAgICAgICAgICAgICAgJ2lkJzogc2hhZG93SWQsXG4gICAgICAgICAgICAgICAgJ3gnOiAnLTEwMCUnLFxuICAgICAgICAgICAgICAgICd5JzogJy0xMDAlJyxcbiAgICAgICAgICAgICAgICAnd2lkdGgnOiAnMzAwJScsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6ICczMDAlJ1xuICAgICAgICAgICAgfSwgW1xuICAgICAgICAgICAgICAgIGNyZWF0ZVZOb2RlKCdmZURyb3BTaGFkb3cnLCAnJywge1xuICAgICAgICAgICAgICAgICAgICAnZHgnOiBvZmZzZXRYIC8gc2NhbGVYLFxuICAgICAgICAgICAgICAgICAgICAnZHknOiBvZmZzZXRZIC8gc2NhbGVZLFxuICAgICAgICAgICAgICAgICAgICAnc3RkRGV2aWF0aW9uJzogc3RkRGV2aWF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAnZmxvb2QtY29sb3InOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgJ2Zsb29kLW9wYWNpdHknOiBvcGFjaXR5XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgc2hhZG93Q2FjaGVbc2hhZG93S2V5XSA9IHNoYWRvd0lkO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJzLmZpbHRlciA9IGdldElkVVJMKHNoYWRvd0lkKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0R3JhZGllbnQoc3R5bGUsIGF0dHJzLCB0YXJnZXQsIHNjb3BlKSB7XG4gICAgdmFyIHZhbCA9IHN0eWxlW3RhcmdldF07XG4gICAgdmFyIGdyYWRpZW50VGFnO1xuICAgIHZhciBncmFkaWVudEF0dHJzID0ge1xuICAgICAgICAnZ3JhZGllbnRVbml0cyc6IHZhbC5nbG9iYWxcbiAgICAgICAgICAgID8gJ3VzZXJTcGFjZU9uVXNlJ1xuICAgICAgICAgICAgOiAnb2JqZWN0Qm91bmRpbmdCb3gnXG4gICAgfTtcbiAgICBpZiAoaXNMaW5lYXJHcmFkaWVudCh2YWwpKSB7XG4gICAgICAgIGdyYWRpZW50VGFnID0gJ2xpbmVhckdyYWRpZW50JztcbiAgICAgICAgZ3JhZGllbnRBdHRycy54MSA9IHZhbC54O1xuICAgICAgICBncmFkaWVudEF0dHJzLnkxID0gdmFsLnk7XG4gICAgICAgIGdyYWRpZW50QXR0cnMueDIgPSB2YWwueDI7XG4gICAgICAgIGdyYWRpZW50QXR0cnMueTIgPSB2YWwueTI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUmFkaWFsR3JhZGllbnQodmFsKSkge1xuICAgICAgICBncmFkaWVudFRhZyA9ICdyYWRpYWxHcmFkaWVudCc7XG4gICAgICAgIGdyYWRpZW50QXR0cnMuY3ggPSByZXRyaWV2ZTIodmFsLngsIDAuNSk7XG4gICAgICAgIGdyYWRpZW50QXR0cnMuY3kgPSByZXRyaWV2ZTIodmFsLnksIDAuNSk7XG4gICAgICAgIGdyYWRpZW50QXR0cnMuciA9IHJldHJpZXZlMih2YWwuciwgMC41KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBsb2dFcnJvcignSWxsZWdhbCBncmFkaWVudCB0eXBlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvbG9ycyA9IHZhbC5jb2xvclN0b3BzO1xuICAgIHZhciBjb2xvclN0b3BzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcm91bmQ0KGNvbG9yc1tpXS5vZmZzZXQpICogMTAwICsgJyUnO1xuICAgICAgICB2YXIgc3RvcENvbG9yID0gY29sb3JzW2ldLmNvbG9yO1xuICAgICAgICB2YXIgX2EgPSBub3JtYWxpemVDb2xvcihzdG9wQ29sb3IpLCBjb2xvciA9IF9hLmNvbG9yLCBvcGFjaXR5ID0gX2Eub3BhY2l0eTtcbiAgICAgICAgdmFyIHN0b3BzQXR0cnMgPSB7XG4gICAgICAgICAgICAnb2Zmc2V0Jzogb2Zmc2V0XG4gICAgICAgIH07XG4gICAgICAgIHN0b3BzQXR0cnNbJ3N0b3AtY29sb3InXSA9IGNvbG9yO1xuICAgICAgICBpZiAob3BhY2l0eSA8IDEpIHtcbiAgICAgICAgICAgIHN0b3BzQXR0cnNbJ3N0b3Atb3BhY2l0eSddID0gb3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICBjb2xvclN0b3BzLnB1c2goY3JlYXRlVk5vZGUoJ3N0b3AnLCBpICsgJycsIHN0b3BzQXR0cnMpKTtcbiAgICB9XG4gICAgdmFyIGdyYWRpZW50Vk5vZGUgPSBjcmVhdGVWTm9kZShncmFkaWVudFRhZywgJycsIGdyYWRpZW50QXR0cnMsIGNvbG9yU3RvcHMpO1xuICAgIHZhciBncmFkaWVudEtleSA9IHZOb2RlVG9TdHJpbmcoZ3JhZGllbnRWTm9kZSk7XG4gICAgdmFyIGdyYWRpZW50Q2FjaGUgPSBzY29wZS5ncmFkaWVudENhY2hlO1xuICAgIHZhciBncmFkaWVudElkID0gZ3JhZGllbnRDYWNoZVtncmFkaWVudEtleV07XG4gICAgaWYgKCFncmFkaWVudElkKSB7XG4gICAgICAgIGdyYWRpZW50SWQgPSBzY29wZS56cklkICsgJy1nJyArIHNjb3BlLmdyYWRpZW50SWR4Kys7XG4gICAgICAgIGdyYWRpZW50Q2FjaGVbZ3JhZGllbnRLZXldID0gZ3JhZGllbnRJZDtcbiAgICAgICAgZ3JhZGllbnRBdHRycy5pZCA9IGdyYWRpZW50SWQ7XG4gICAgICAgIHNjb3BlLmRlZnNbZ3JhZGllbnRJZF0gPSBjcmVhdGVWTm9kZShncmFkaWVudFRhZywgZ3JhZGllbnRJZCwgZ3JhZGllbnRBdHRycywgY29sb3JTdG9wcyk7XG4gICAgfVxuICAgIGF0dHJzW3RhcmdldF0gPSBnZXRJZFVSTChncmFkaWVudElkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRQYXR0ZXJuKGVsLCBhdHRycywgdGFyZ2V0LCBzY29wZSkge1xuICAgIHZhciB2YWwgPSBlbC5zdHlsZVt0YXJnZXRdO1xuICAgIHZhciBib3VuZGluZ1JlY3QgPSBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgcGF0dGVybkF0dHJzID0ge307XG4gICAgdmFyIHJlcGVhdCA9IHZhbC5yZXBlYXQ7XG4gICAgdmFyIG5vUmVwZWF0ID0gcmVwZWF0ID09PSAnbm8tcmVwZWF0JztcbiAgICB2YXIgcmVwZWF0WCA9IHJlcGVhdCA9PT0gJ3JlcGVhdC14JztcbiAgICB2YXIgcmVwZWF0WSA9IHJlcGVhdCA9PT0gJ3JlcGVhdC15JztcbiAgICB2YXIgY2hpbGQ7XG4gICAgaWYgKGlzSW1hZ2VQYXR0ZXJuKHZhbCkpIHtcbiAgICAgICAgdmFyIGltYWdlV2lkdGhfMSA9IHZhbC5pbWFnZVdpZHRoO1xuICAgICAgICB2YXIgaW1hZ2VIZWlnaHRfMSA9IHZhbC5pbWFnZUhlaWdodDtcbiAgICAgICAgdmFyIGltYWdlU3JjID0gdm9pZCAwO1xuICAgICAgICB2YXIgcGF0dGVybkltYWdlID0gdmFsLmltYWdlO1xuICAgICAgICBpZiAoaXNTdHJpbmcocGF0dGVybkltYWdlKSkge1xuICAgICAgICAgICAgaW1hZ2VTcmMgPSBwYXR0ZXJuSW1hZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNJbWFnZUxpa2UocGF0dGVybkltYWdlKSkge1xuICAgICAgICAgICAgaW1hZ2VTcmMgPSBwYXR0ZXJuSW1hZ2Uuc3JjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2FudmFzTGlrZShwYXR0ZXJuSW1hZ2UpKSB7XG4gICAgICAgICAgICBpbWFnZVNyYyA9IHBhdHRlcm5JbWFnZS50b0RhdGFVUkwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIEltYWdlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFyIGVyck1zZyA9ICdJbWFnZSB3aWR0aC9oZWlnaHQgbXVzdCBiZWVuIGdpdmVuIGV4cGxpY3RseSBpbiBzdmctc3NyIHJlbmRlcmVyLic7XG4gICAgICAgICAgICBhc3NlcnQoaW1hZ2VXaWR0aF8xLCBlcnJNc2cpO1xuICAgICAgICAgICAgYXNzZXJ0KGltYWdlSGVpZ2h0XzEsIGVyck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW1hZ2VXaWR0aF8xID09IG51bGwgfHwgaW1hZ2VIZWlnaHRfMSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgc2V0U2l6ZVRvVk5vZGVfMSA9IGZ1bmN0aW9uICh2Tm9kZSwgaW1nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdmdFbCA9IHZOb2RlLmVsbTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2VXaWR0aF8xIHx8IGltZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGltYWdlSGVpZ2h0XzEgfHwgaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZOb2RlLnRhZyA9PT0gJ3BhdHRlcm4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwZWF0WCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggLz0gYm91bmRpbmdSZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVwZWF0WSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgLz0gYm91bmRpbmdSZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2Tm9kZS5hdHRycy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2Tm9kZS5hdHRycy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdmdFbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY3JlYXRlZEltYWdlID0gY3JlYXRlT3JVcGRhdGVJbWFnZShpbWFnZVNyYywgbnVsbCwgZWwsIGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgICAgICAgICBub1JlcGVhdCB8fCBzZXRTaXplVG9WTm9kZV8xKHBhdHRlcm5WTm9kZSwgaW1nKTtcbiAgICAgICAgICAgICAgICBzZXRTaXplVG9WTm9kZV8xKGNoaWxkLCBpbWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY3JlYXRlZEltYWdlICYmIGNyZWF0ZWRJbWFnZS53aWR0aCAmJiBjcmVhdGVkSW1hZ2UuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VXaWR0aF8xID0gaW1hZ2VXaWR0aF8xIHx8IGNyZWF0ZWRJbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICBpbWFnZUhlaWdodF8xID0gaW1hZ2VIZWlnaHRfMSB8fCBjcmVhdGVkSW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gY3JlYXRlVk5vZGUoJ2ltYWdlJywgJ2ltZycsIHtcbiAgICAgICAgICAgIGhyZWY6IGltYWdlU3JjLFxuICAgICAgICAgICAgd2lkdGg6IGltYWdlV2lkdGhfMSxcbiAgICAgICAgICAgIGhlaWdodDogaW1hZ2VIZWlnaHRfMVxuICAgICAgICB9KTtcbiAgICAgICAgcGF0dGVybkF0dHJzLndpZHRoID0gaW1hZ2VXaWR0aF8xO1xuICAgICAgICBwYXR0ZXJuQXR0cnMuaGVpZ2h0ID0gaW1hZ2VIZWlnaHRfMTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsLnN2Z0VsZW1lbnQpIHtcbiAgICAgICAgY2hpbGQgPSBjbG9uZSh2YWwuc3ZnRWxlbWVudCk7XG4gICAgICAgIHBhdHRlcm5BdHRycy53aWR0aCA9IHZhbC5zdmdXaWR0aDtcbiAgICAgICAgcGF0dGVybkF0dHJzLmhlaWdodCA9IHZhbC5zdmdIZWlnaHQ7XG4gICAgfVxuICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGF0dGVybldpZHRoO1xuICAgIHZhciBwYXR0ZXJuSGVpZ2h0O1xuICAgIGlmIChub1JlcGVhdCkge1xuICAgICAgICBwYXR0ZXJuV2lkdGggPSBwYXR0ZXJuSGVpZ2h0ID0gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVwZWF0WCkge1xuICAgICAgICBwYXR0ZXJuSGVpZ2h0ID0gMTtcbiAgICAgICAgcGF0dGVybldpZHRoID0gcGF0dGVybkF0dHJzLndpZHRoIC8gYm91bmRpbmdSZWN0LndpZHRoO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXBlYXRZKSB7XG4gICAgICAgIHBhdHRlcm5XaWR0aCA9IDE7XG4gICAgICAgIHBhdHRlcm5IZWlnaHQgPSBwYXR0ZXJuQXR0cnMuaGVpZ2h0IC8gYm91bmRpbmdSZWN0LmhlaWdodDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhdHRlcm5BdHRycy5wYXR0ZXJuVW5pdHMgPSAndXNlclNwYWNlT25Vc2UnO1xuICAgIH1cbiAgICBpZiAocGF0dGVybldpZHRoICE9IG51bGwgJiYgIWlzTmFOKHBhdHRlcm5XaWR0aCkpIHtcbiAgICAgICAgcGF0dGVybkF0dHJzLndpZHRoID0gcGF0dGVybldpZHRoO1xuICAgIH1cbiAgICBpZiAocGF0dGVybkhlaWdodCAhPSBudWxsICYmICFpc05hTihwYXR0ZXJuSGVpZ2h0KSkge1xuICAgICAgICBwYXR0ZXJuQXR0cnMuaGVpZ2h0ID0gcGF0dGVybkhlaWdodDtcbiAgICB9XG4gICAgdmFyIHBhdHRlcm5UcmFuc2Zvcm0gPSBnZXRTUlRUcmFuc2Zvcm1TdHJpbmcodmFsKTtcbiAgICBwYXR0ZXJuVHJhbnNmb3JtICYmIChwYXR0ZXJuQXR0cnMucGF0dGVyblRyYW5zZm9ybSA9IHBhdHRlcm5UcmFuc2Zvcm0pO1xuICAgIHZhciBwYXR0ZXJuVk5vZGUgPSBjcmVhdGVWTm9kZSgncGF0dGVybicsICcnLCBwYXR0ZXJuQXR0cnMsIFtjaGlsZF0pO1xuICAgIHZhciBwYXR0ZXJuS2V5ID0gdk5vZGVUb1N0cmluZyhwYXR0ZXJuVk5vZGUpO1xuICAgIHZhciBwYXR0ZXJuQ2FjaGUgPSBzY29wZS5wYXR0ZXJuQ2FjaGU7XG4gICAgdmFyIHBhdHRlcm5JZCA9IHBhdHRlcm5DYWNoZVtwYXR0ZXJuS2V5XTtcbiAgICBpZiAoIXBhdHRlcm5JZCkge1xuICAgICAgICBwYXR0ZXJuSWQgPSBzY29wZS56cklkICsgJy1wJyArIHNjb3BlLnBhdHRlcm5JZHgrKztcbiAgICAgICAgcGF0dGVybkNhY2hlW3BhdHRlcm5LZXldID0gcGF0dGVybklkO1xuICAgICAgICBwYXR0ZXJuQXR0cnMuaWQgPSBwYXR0ZXJuSWQ7XG4gICAgICAgIHBhdHRlcm5WTm9kZSA9IHNjb3BlLmRlZnNbcGF0dGVybklkXSA9IGNyZWF0ZVZOb2RlKCdwYXR0ZXJuJywgcGF0dGVybklkLCBwYXR0ZXJuQXR0cnMsIFtjaGlsZF0pO1xuICAgIH1cbiAgICBhdHRyc1t0YXJnZXRdID0gZ2V0SWRVUkwocGF0dGVybklkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRDbGlwUGF0aChjbGlwUGF0aCwgYXR0cnMsIHNjb3BlKSB7XG4gICAgdmFyIGNsaXBQYXRoQ2FjaGUgPSBzY29wZS5jbGlwUGF0aENhY2hlLCBkZWZzID0gc2NvcGUuZGVmcztcbiAgICB2YXIgY2xpcFBhdGhJZCA9IGNsaXBQYXRoQ2FjaGVbY2xpcFBhdGguaWRdO1xuICAgIGlmICghY2xpcFBhdGhJZCkge1xuICAgICAgICBjbGlwUGF0aElkID0gc2NvcGUuenJJZCArICctYycgKyBzY29wZS5jbGlwUGF0aElkeCsrO1xuICAgICAgICB2YXIgY2xpcFBhdGhBdHRycyA9IHtcbiAgICAgICAgICAgIGlkOiBjbGlwUGF0aElkXG4gICAgICAgIH07XG4gICAgICAgIGNsaXBQYXRoQ2FjaGVbY2xpcFBhdGguaWRdID0gY2xpcFBhdGhJZDtcbiAgICAgICAgZGVmc1tjbGlwUGF0aElkXSA9IGNyZWF0ZVZOb2RlKCdjbGlwUGF0aCcsIGNsaXBQYXRoSWQsIGNsaXBQYXRoQXR0cnMsIFticnVzaFNWR1BhdGgoY2xpcFBhdGgsIHNjb3BlKV0pO1xuICAgIH1cbiAgICBhdHRyc1snY2xpcC1wYXRoJ10gPSBnZXRJZFVSTChjbGlwUGF0aElkKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh0ZXh0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQodGV4dCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2hpbGQobm9kZSwgY2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDaGlsZChub2RlLCBjaGlsZCkge1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcmVudE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnBhcmVudE5vZGU7XG59XG5leHBvcnQgZnVuY3Rpb24gbmV4dFNpYmxpbmcobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRhZ05hbWUoZWxtKSB7XG4gICAgcmV0dXJuIGVsbS50YWdOYW1lO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldFRleHRDb250ZW50KG5vZGUsIHRleHQpIHtcbiAgICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0Q29udGVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudGV4dENvbnRlbnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1RleHQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29tbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDg7XG59XG4iLCJpbXBvcnQgeyBpc0FycmF5LCBpc09iamVjdCB9IGZyb20gJy4uL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBjcmVhdGVWTm9kZSwgWE1MTlMsIFhNTF9OQU1FU1BBQ0UsIFhMSU5LTlMgfSBmcm9tICcuL2NvcmUuanMnO1xuaW1wb3J0ICogYXMgYXBpIGZyb20gJy4vZG9tYXBpLmpzJztcbnZhciBjb2xvbkNoYXIgPSA1ODtcbnZhciB4Q2hhciA9IDEyMDtcbnZhciBlbXB0eU5vZGUgPSBjcmVhdGVWTm9kZSgnJywgJycpO1xuZnVuY3Rpb24gaXNVbmRlZihzKSB7XG4gICAgcmV0dXJuIHMgPT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzRGVmKHMpIHtcbiAgICByZXR1cm4gcyAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHgoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgICB2YXIgbWFwID0ge307XG4gICAgZm9yICh2YXIgaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFwW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRHVwbGljYXRlIGtleSBcIiArIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwW2tleV0gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBzYW1lVm5vZGUodm5vZGUxLCB2bm9kZTIpIHtcbiAgICB2YXIgaXNTYW1lS2V5ID0gdm5vZGUxLmtleSA9PT0gdm5vZGUyLmtleTtcbiAgICB2YXIgaXNTYW1lVGFnID0gdm5vZGUxLnRhZyA9PT0gdm5vZGUyLnRhZztcbiAgICByZXR1cm4gaXNTYW1lVGFnICYmIGlzU2FtZUtleTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsbSh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgICAgdmFyIGVsbSA9ICh2bm9kZS5lbG0gPSBjcmVhdGVFbGVtZW50KHRhZykpO1xuICAgICAgICB1cGRhdGVBdHRycyhlbXB0eU5vZGUsIHZub2RlKTtcbiAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhcGkuYXBwZW5kQ2hpbGQoZWxtLCBjcmVhdGVFbG0oY2gpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEZWYodm5vZGUudGV4dCkgJiYgIWlzT2JqZWN0KHZub2RlLnRleHQpKSB7XG4gICAgICAgICAgICBhcGkuYXBwZW5kQ2hpbGQoZWxtLCBhcGkuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2bm9kZS5lbG0gPSBhcGkuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZS5lbG07XG59XG5mdW5jdGlvbiBhZGRWbm9kZXMocGFyZW50RWxtLCBiZWZvcmUsIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgICAgaWYgKGNoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBjcmVhdGVFbG0oY2gpLCBiZWZvcmUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgICBpZiAoY2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBhcGkucGFyZW50Tm9kZShjaC5lbG0pO1xuICAgICAgICAgICAgICAgIGFwaS5yZW1vdmVDaGlsZChwYXJlbnRfMSwgY2guZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwaS5yZW1vdmVDaGlsZChwYXJlbnRFbG0sIGNoLmVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQXR0cnMob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIGtleTtcbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICAgIHZhciBvbGRBdHRycyA9IG9sZFZub2RlICYmIG9sZFZub2RlLmF0dHJzIHx8IHt9O1xuICAgIHZhciBhdHRycyA9IHZub2RlLmF0dHJzIHx8IHt9O1xuICAgIGlmIChvbGRBdHRycyA9PT0gYXR0cnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICB2YXIgY3VyID0gYXR0cnNba2V5XTtcbiAgICAgICAgdmFyIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgICAgICAgaWYgKGN1ciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoa2V5LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgICAgICBlbG0uc3R5bGUuY3NzVGV4dCA9IGN1cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5LmNoYXJDb2RlQXQoMCkgIT09IHhDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoa2V5LCBjdXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICd4bWxuczp4bGluaycgfHwga2V5ID09PSAneG1sbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGVOUyhYTUxOUywga2V5LCBjdXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkuY2hhckNvZGVBdCgzKSA9PT0gY29sb25DaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGVOUyhYTUxfTkFNRVNQQUNFLCBrZXksIGN1cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleS5jaGFyQ29kZUF0KDUpID09PSBjb2xvbkNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZU5TKFhMSU5LTlMsIGtleSwgY3VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoa2V5LCBjdXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgICAgICBpZiAoIShrZXkgaW4gYXR0cnMpKSB7XG4gICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVDaGlsZHJlbihwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeDtcbiAgICB2YXIgaWR4SW5PbGQ7XG4gICAgdmFyIGVsbVRvTW92ZTtcbiAgICB2YXIgYmVmb3JlO1xuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICAgIGlmIChvbGRTdGFydFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbGRFbmRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdTdGFydFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdFbmRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSk7XG4gICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKTtcbiAgICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSk7XG4gICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGFwaS5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpO1xuICAgICAgICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHtcbiAgICAgICAgICAgICAgICBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeEluT2xkID0gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7XG4gICAgICAgICAgICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlKSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgICAgICAgIGlmIChlbG1Ub01vdmUudGFnICE9PSBuZXdTdGFydFZub2RlLnRhZykge1xuICAgICAgICAgICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUpLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaFZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGVsbVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCB8fCBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICAgICAgICBiZWZvcmUgPSBuZXdDaFtuZXdFbmRJZHggKyAxXSA9PSBudWxsID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIGJlZm9yZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgZWxtID0gKHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbSk7XG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHVwZGF0ZUF0dHJzKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgICAgICAgICBhcGkuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgICAgIGFwaS5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBhcGkuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXRjaChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAoc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudF8yID0gYXBpLnBhcmVudE5vZGUoZWxtKTtcbiAgICAgICAgY3JlYXRlRWxtKHZub2RlKTtcbiAgICAgICAgaWYgKHBhcmVudF8yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudF8yLCB2bm9kZS5lbG0sIGFwaS5uZXh0U2libGluZyhlbG0pKTtcbiAgICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRfMiwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xufVxuIiwiaW1wb3J0IHsgYnJ1c2gsIHNldENsaXBQYXRoLCBzZXRHcmFkaWVudCwgc2V0UGF0dGVybiB9IGZyb20gJy4vZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBjcmVhdGVWTm9kZSwgdk5vZGVUb1N0cmluZywgZ2V0Q3NzU3RyaW5nLCBjcmVhdGVCcnVzaFNjb3BlLCBjcmVhdGVTVkdWTm9kZSB9IGZyb20gJy4vY29yZS5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVDb2xvciwgZW5jb2RlQmFzZTY0LCBpc0dyYWRpZW50LCBpc1BhdHRlcm4gfSBmcm9tICcuL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBleHRlbmQsIGtleXMsIGxvZ0Vycm9yLCBtYXAsIG5vb3AsIHJldHJpZXZlMiB9IGZyb20gJy4uL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgcGF0Y2gsIHsgdXBkYXRlQXR0cnMgfSBmcm9tICcuL3BhdGNoLmpzJztcbmltcG9ydCB7IGdldFNpemUgfSBmcm9tICcuLi9jYW52YXMvaGVscGVyLmpzJztcbnZhciBzdmdJZCA9IDA7XG52YXIgU1ZHUGFpbnRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU1ZHUGFpbnRlcihyb290LCBzdG9yYWdlLCBvcHRzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzdmcnO1xuICAgICAgICB0aGlzLnJlZnJlc2hIb3ZlciA9IGNyZWF0ZU1ldGhvZE5vdFN1cHBvcnQoJ3JlZnJlc2hIb3ZlcicpO1xuICAgICAgICB0aGlzLmNvbmZpZ0xheWVyID0gY3JlYXRlTWV0aG9kTm90U3VwcG9ydCgnY29uZmlnTGF5ZXInKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICAgICAgdGhpcy5fb3B0cyA9IG9wdHMgPSBleHRlbmQoe30sIG9wdHMpO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLl9pZCA9ICd6cicgKyBzdmdJZCsrO1xuICAgICAgICB0aGlzLl9vbGRWTm9kZSA9IGNyZWF0ZVNWR1ZOb2RlKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgICAgICAgaWYgKHJvb3QgJiYgIW9wdHMuc3NyKSB7XG4gICAgICAgICAgICB2YXIgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdmlld3BvcnQuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW4nO1xuICAgICAgICAgICAgdmFyIHN2Z0RvbSA9IHRoaXMuX3N2Z0RvbSA9IHRoaXMuX29sZFZOb2RlLmVsbSA9IGNyZWF0ZUVsZW1lbnQoJ3N2ZycpO1xuICAgICAgICAgICAgdXBkYXRlQXR0cnMobnVsbCwgdGhpcy5fb2xkVk5vZGUpO1xuICAgICAgICAgICAgdmlld3BvcnQuYXBwZW5kQ2hpbGQoc3ZnRG9tKTtcbiAgICAgICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQodmlld3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzaXplKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgICB9XG4gICAgU1ZHUGFpbnRlci5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgICB9O1xuICAgIFNWR1BhaW50ZXIucHJvdG90eXBlLmdldFZpZXdwb3J0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0O1xuICAgIH07XG4gICAgU1ZHUGFpbnRlci5wcm90b3R5cGUuZ2V0Vmlld3BvcnRSb290T2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmlld3BvcnRSb290ID0gdGhpcy5nZXRWaWV3cG9ydFJvb3QoKTtcbiAgICAgICAgaWYgKHZpZXdwb3J0Um9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0OiB2aWV3cG9ydFJvb3Qub2Zmc2V0TGVmdCB8fCAwLFxuICAgICAgICAgICAgICAgIG9mZnNldFRvcDogdmlld3BvcnRSb290Lm9mZnNldFRvcCB8fCAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTVkdQYWludGVyLnByb3RvdHlwZS5nZXRTdmdEb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdmdEb207XG4gICAgfTtcbiAgICBTVkdQYWludGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICB2YXIgdm5vZGUgPSB0aGlzLnJlbmRlclRvVk5vZGUoe1xuICAgICAgICAgICAgICAgIHdpbGxVcGRhdGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdm5vZGUuYXR0cnMuc3R5bGUgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO3VzZXItc2VsZWN0Om5vbmUnO1xuICAgICAgICAgICAgcGF0Y2godGhpcy5fb2xkVk5vZGUsIHZub2RlKTtcbiAgICAgICAgICAgIHRoaXMuX29sZFZOb2RlID0gdm5vZGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNWR1BhaW50ZXIucHJvdG90eXBlLnJlbmRlck9uZVRvVk5vZGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGJydXNoKGVsLCBjcmVhdGVCcnVzaFNjb3BlKHRoaXMuX2lkKSk7XG4gICAgfTtcbiAgICBTVkdQYWludGVyLnByb3RvdHlwZS5yZW5kZXJUb1ZOb2RlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgdmFyIHNjb3BlID0gY3JlYXRlQnJ1c2hTY29wZSh0aGlzLl9pZCk7XG4gICAgICAgIHNjb3BlLmFuaW1hdGlvbiA9IG9wdHMuYW5pbWF0aW9uO1xuICAgICAgICBzY29wZS53aWxsVXBkYXRlID0gb3B0cy53aWxsVXBkYXRlO1xuICAgICAgICBzY29wZS5jb21wcmVzcyA9IG9wdHMuY29tcHJlc3M7XG4gICAgICAgIHNjb3BlLmVtcGhhc2lzID0gb3B0cy5lbXBoYXNpcztcbiAgICAgICAgc2NvcGUuc3NyID0gdGhpcy5fb3B0cy5zc3I7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB2YXIgYmdWTm9kZSA9IHRoaXMuX2JnVk5vZGUgPSBjcmVhdGVCYWNrZ3JvdW5kVk5vZGUod2lkdGgsIGhlaWdodCwgdGhpcy5fYmFja2dyb3VuZENvbG9yLCBzY29wZSk7XG4gICAgICAgIGJnVk5vZGUgJiYgY2hpbGRyZW4ucHVzaChiZ1ZOb2RlKTtcbiAgICAgICAgdmFyIG1haW5WTm9kZSA9ICFvcHRzLmNvbXByZXNzXG4gICAgICAgICAgICA/ICh0aGlzLl9tYWluVk5vZGUgPSBjcmVhdGVWTm9kZSgnZycsICdtYWluJywge30sIFtdKSkgOiBudWxsO1xuICAgICAgICB0aGlzLl9wYWludExpc3QobGlzdCwgc2NvcGUsIG1haW5WTm9kZSA/IG1haW5WTm9kZS5jaGlsZHJlbiA6IGNoaWxkcmVuKTtcbiAgICAgICAgbWFpblZOb2RlICYmIGNoaWxkcmVuLnB1c2gobWFpblZOb2RlKTtcbiAgICAgICAgdmFyIGRlZnMgPSBtYXAoa2V5cyhzY29wZS5kZWZzKSwgZnVuY3Rpb24gKGlkKSB7IHJldHVybiBzY29wZS5kZWZzW2lkXTsgfSk7XG4gICAgICAgIGlmIChkZWZzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVWTm9kZSgnZGVmcycsICdkZWZzJywge30sIGRlZnMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25Dc3NTdHIgPSBnZXRDc3NTdHJpbmcoc2NvcGUuY3NzTm9kZXMsIHNjb3BlLmNzc0FuaW1zLCB7IG5ld2xpbmU6IHRydWUgfSk7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uQ3NzU3RyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlTm9kZSA9IGNyZWF0ZVZOb2RlKCdzdHlsZScsICdzdGwnLCB7fSwgW10sIGFuaW1hdGlvbkNzc1N0cik7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChzdHlsZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVTVkdWTm9kZSh3aWR0aCwgaGVpZ2h0LCBjaGlsZHJlbiwgb3B0cy51c2VWaWV3Qm94KTtcbiAgICB9O1xuICAgIFNWR1BhaW50ZXIucHJvdG90eXBlLnJlbmRlclRvU3RyaW5nID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHJldHVybiB2Tm9kZVRvU3RyaW5nKHRoaXMucmVuZGVyVG9WTm9kZSh7XG4gICAgICAgICAgICBhbmltYXRpb246IHJldHJpZXZlMihvcHRzLmNzc0FuaW1hdGlvbiwgdHJ1ZSksXG4gICAgICAgICAgICBlbXBoYXNpczogcmV0cmlldmUyKG9wdHMuY3NzRW1waGFzaXMsIHRydWUpLFxuICAgICAgICAgICAgd2lsbFVwZGF0ZTogZmFsc2UsXG4gICAgICAgICAgICBjb21wcmVzczogdHJ1ZSxcbiAgICAgICAgICAgIHVzZVZpZXdCb3g6IHJldHJpZXZlMihvcHRzLnVzZVZpZXdCb3gsIHRydWUpXG4gICAgICAgIH0pLCB7IG5ld2xpbmU6IHRydWUgfSk7XG4gICAgfTtcbiAgICBTVkdQYWludGVyLnByb3RvdHlwZS5zZXRCYWNrZ3JvdW5kQ29sb3IgPSBmdW5jdGlvbiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcbiAgICB9O1xuICAgIFNWR1BhaW50ZXIucHJvdG90eXBlLmdldFN2Z1Jvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYWluVk5vZGUgJiYgdGhpcy5fbWFpblZOb2RlLmVsbTtcbiAgICB9O1xuICAgIFNWR1BhaW50ZXIucHJvdG90eXBlLl9wYWludExpc3QgPSBmdW5jdGlvbiAobGlzdCwgc2NvcGUsIG91dCkge1xuICAgICAgICB2YXIgbGlzdExlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgY2xpcFBhdGhzR3JvdXBzU3RhY2sgPSBbXTtcbiAgICAgICAgdmFyIGNsaXBQYXRoc0dyb3Vwc1N0YWNrRGVwdGggPSAwO1xuICAgICAgICB2YXIgY3VycmVudENsaXBQYXRoR3JvdXA7XG4gICAgICAgIHZhciBwcmV2Q2xpcFBhdGhzO1xuICAgICAgICB2YXIgY2xpcEdyb3VwTm9kZUlkeCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdExlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGlzcGxheWFibGUgPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKCFkaXNwbGF5YWJsZS5pbnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcFBhdGhzID0gZGlzcGxheWFibGUuX19jbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGNsaXBQYXRocyAmJiBjbGlwUGF0aHMubGVuZ3RoIHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZMZW4gPSBwcmV2Q2xpcFBhdGhzICYmIHByZXZDbGlwUGF0aHMubGVuZ3RoIHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIGxjYSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxjYSA9IE1hdGgubWF4KGxlbiAtIDEsIHByZXZMZW4gLSAxKTsgbGNhID49IDA7IGxjYS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGlwUGF0aHMgJiYgcHJldkNsaXBQYXRoc1xuICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2xpcFBhdGhzW2xjYV0gPT09IHByZXZDbGlwUGF0aHNbbGNhXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaV8xID0gcHJldkxlbiAtIDE7IGlfMSA+IGxjYTsgaV8xLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGhzR3JvdXBzU3RhY2tEZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2xpcFBhdGhHcm91cCA9IGNsaXBQYXRoc0dyb3Vwc1N0YWNrW2NsaXBQYXRoc0dyb3Vwc1N0YWNrRGVwdGggLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaV8yID0gbGNhICsgMTsgaV8yIDwgbGVuOyBpXzIrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBBdHRycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBzZXRDbGlwUGF0aChjbGlwUGF0aHNbaV8yXSwgZ3JvdXBBdHRycywgc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IGNyZWF0ZVZOb2RlKCdnJywgJ2NsaXAtZy0nICsgY2xpcEdyb3VwTm9kZUlkeCsrLCBncm91cEF0dHJzLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIChjdXJyZW50Q2xpcFBhdGhHcm91cCA/IGN1cnJlbnRDbGlwUGF0aEdyb3VwLmNoaWxkcmVuIDogb3V0KS5wdXNoKGcpO1xuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aHNHcm91cHNTdGFja1tjbGlwUGF0aHNHcm91cHNTdGFja0RlcHRoKytdID0gZztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENsaXBQYXRoR3JvdXAgPSBnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2Q2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBicnVzaChkaXNwbGF5YWJsZSwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRDbGlwUGF0aEdyb3VwID8gY3VycmVudENsaXBQYXRoR3JvdXAuY2hpbGRyZW4gOiBvdXQpLnB1c2gocmV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNWR1BhaW50ZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5fb3B0cztcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgIHZhciB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0O1xuICAgICAgICB3aWR0aCAhPSBudWxsICYmIChvcHRzLndpZHRoID0gd2lkdGgpO1xuICAgICAgICBoZWlnaHQgIT0gbnVsbCAmJiAob3B0cy5oZWlnaHQgPSBoZWlnaHQpO1xuICAgICAgICBpZiAocm9vdCAmJiB2aWV3cG9ydCkge1xuICAgICAgICAgICAgdmlld3BvcnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHdpZHRoID0gZ2V0U2l6ZShyb290LCAwLCBvcHRzKTtcbiAgICAgICAgICAgIGhlaWdodCA9IGdldFNpemUocm9vdCwgMSwgb3B0cyk7XG4gICAgICAgICAgICB2aWV3cG9ydC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3dpZHRoICE9PSB3aWR0aCB8fCB0aGlzLl9oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydFN0eWxlID0gdmlld3BvcnQuc3R5bGU7XG4gICAgICAgICAgICAgICAgdmlld3BvcnRTdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICB2aWV3cG9ydFN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUGF0dGVybih0aGlzLl9iYWNrZ3JvdW5kQ29sb3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN2Z0RvbSA9IHRoaXMuX3N2Z0RvbTtcbiAgICAgICAgICAgICAgICBpZiAoc3ZnRG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHN2Z0RvbS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBzdmdEb20uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYmdFbCA9IHRoaXMuX2JnVk5vZGUgJiYgdGhpcy5fYmdWTm9kZS5lbG07XG4gICAgICAgICAgICAgICAgaWYgKGJnRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgYmdFbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBiZ0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU1ZHUGFpbnRlci5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9O1xuICAgIFNWR1BhaW50ZXIucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9O1xuICAgIFNWR1BhaW50ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdmdEb20gPVxuICAgICAgICAgICAgdGhpcy5fdmlld3BvcnQgPVxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29sZFZOb2RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2JnVk5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21haW5WTm9kZSA9IG51bGw7XG4gICAgfTtcbiAgICBTVkdQYWludGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N2Z0RvbSkge1xuICAgICAgICAgICAgdGhpcy5fc3ZnRG9tLmlubmVySFRNTCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2xkVk5vZGUgPSBudWxsO1xuICAgIH07XG4gICAgU1ZHUGFpbnRlci5wcm90b3R5cGUudG9EYXRhVVJMID0gZnVuY3Rpb24gKGJhc2U2NCkge1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5yZW5kZXJUb1N0cmluZygpO1xuICAgICAgICB2YXIgcHJlZml4ID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDsnO1xuICAgICAgICBpZiAoYmFzZTY0KSB7XG4gICAgICAgICAgICBzdHIgPSBlbmNvZGVCYXNlNjQoc3RyKTtcbiAgICAgICAgICAgIHJldHVybiBzdHIgJiYgcHJlZml4ICsgJ2Jhc2U2NCwnICsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnY2hhcnNldD1VVEYtOCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cik7XG4gICAgfTtcbiAgICByZXR1cm4gU1ZHUGFpbnRlcjtcbn0oKSk7XG5mdW5jdGlvbiBjcmVhdGVNZXRob2ROb3RTdXBwb3J0KG1ldGhvZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBsb2dFcnJvcignSW4gU1ZHIG1vZGUgcGFpbnRlciBub3Qgc3VwcG9ydCBtZXRob2QgXCInICsgbWV0aG9kICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQmFja2dyb3VuZFZOb2RlKHdpZHRoLCBoZWlnaHQsIGJhY2tncm91bmRDb2xvciwgc2NvcGUpIHtcbiAgICB2YXIgYmdWTm9kZTtcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yICYmIGJhY2tncm91bmRDb2xvciAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGJnVk5vZGUgPSBjcmVhdGVWTm9kZSgncmVjdCcsICdiZycsIHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgeDogJzAnLFxuICAgICAgICAgICAgeTogJzAnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNHcmFkaWVudChiYWNrZ3JvdW5kQ29sb3IpKSB7XG4gICAgICAgICAgICBzZXRHcmFkaWVudCh7IGZpbGw6IGJhY2tncm91bmRDb2xvciB9LCBiZ1ZOb2RlLmF0dHJzLCAnZmlsbCcsIHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BhdHRlcm4oYmFja2dyb3VuZENvbG9yKSkge1xuICAgICAgICAgICAgc2V0UGF0dGVybih7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogYmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaXJ0eTogbm9vcCxcbiAgICAgICAgICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7IH1cbiAgICAgICAgICAgIH0sIGJnVk5vZGUuYXR0cnMsICdmaWxsJywgc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9hID0gbm9ybWFsaXplQ29sb3IoYmFja2dyb3VuZENvbG9yKSwgY29sb3IgPSBfYS5jb2xvciwgb3BhY2l0eSA9IF9hLm9wYWNpdHk7XG4gICAgICAgICAgICBiZ1ZOb2RlLmF0dHJzLmZpbGwgPSBjb2xvcjtcbiAgICAgICAgICAgIG9wYWNpdHkgPCAxICYmIChiZ1ZOb2RlLmF0dHJzWydmaWxsLW9wYWNpdHknXSA9IG9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiZ1ZOb2RlO1xufVxuZXhwb3J0IGRlZmF1bHQgU1ZHUGFpbnRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18409\n")}}]);