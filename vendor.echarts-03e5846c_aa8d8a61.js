"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[4066],{3486:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   m: () => (/* binding */ alignScaleTicks)\n/* harmony export */ });\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24326);\n/* harmony import */ var _scale_Interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74562);\n/* harmony import */ var _axisHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99031);\n/* harmony import */ var _scale_helper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(67071);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar mathLog = Math.log;\nfunction alignScaleTicks(scale, axisModel, alignToScale) {\n  var intervalScaleProto = _scale_Interval_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.prototype;\n  // NOTE: There is a precondition for log scale  here:\n  // In log scale we store _interval and _extent of exponent value.\n  // So if we use the method of InternalScale to set/get these data.\n  // It process the exponent value, which is linear and what we want here.\n  var alignToTicks = intervalScaleProto.getTicks.call(alignToScale);\n  var alignToNicedTicks = intervalScaleProto.getTicks.call(alignToScale, true);\n  var alignToSplitNumber = alignToTicks.length - 1;\n  var alignToInterval = intervalScaleProto.getInterval.call(alignToScale);\n  var scaleExtent = (0,_axisHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .getScaleExtent */ .Rx)(scale, axisModel);\n  var rawExtent = scaleExtent.extent;\n  var isMinFixed = scaleExtent.fixMin;\n  var isMaxFixed = scaleExtent.fixMax;\n  if (scale.type === \'log\') {\n    var logBase = mathLog(scale.base);\n    rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];\n  }\n  scale.setExtent(rawExtent[0], rawExtent[1]);\n  scale.calcNiceExtent({\n    splitNumber: alignToSplitNumber,\n    fixMin: isMinFixed,\n    fixMax: isMaxFixed\n  });\n  var extent = intervalScaleProto.getExtent.call(scale);\n  // Need to update the rawExtent.\n  // Because value in rawExtent may be not parsed. e.g. \'dataMin\', \'dataMax\'\n  if (isMinFixed) {\n    rawExtent[0] = extent[0];\n  }\n  if (isMaxFixed) {\n    rawExtent[1] = extent[1];\n  }\n  var interval = intervalScaleProto.getInterval.call(scale);\n  var min = rawExtent[0];\n  var max = rawExtent[1];\n  if (isMinFixed && isMaxFixed) {\n    // User set min, max, divide to get new interval\n    interval = (max - min) / alignToSplitNumber;\n  } else if (isMinFixed) {\n    max = rawExtent[0] + interval * alignToSplitNumber;\n    // User set min, expand extent on the other side\n    while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1])) {\n      interval = (0,_scale_helper_js__WEBPACK_IMPORTED_MODULE_2__/* .increaseInterval */ .kH)(interval);\n      max = rawExtent[0] + interval * alignToSplitNumber;\n    }\n  } else if (isMaxFixed) {\n    // User set max, expand extent on the other side\n    min = rawExtent[1] - interval * alignToSplitNumber;\n    while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0])) {\n      interval = (0,_scale_helper_js__WEBPACK_IMPORTED_MODULE_2__/* .increaseInterval */ .kH)(interval);\n      min = rawExtent[1] - interval * alignToSplitNumber;\n    }\n  } else {\n    var nicedSplitNumber = scale.getTicks().length - 1;\n    if (nicedSplitNumber > alignToSplitNumber) {\n      interval = (0,_scale_helper_js__WEBPACK_IMPORTED_MODULE_2__/* .increaseInterval */ .kH)(interval);\n    }\n    var range = interval * alignToSplitNumber;\n    max = Math.ceil(rawExtent[1] / interval) * interval;\n    min = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_3__/* .round */ .LI)(max - range);\n    // Not change the result that crossing zero.\n    if (min < 0 && rawExtent[0] >= 0) {\n      min = 0;\n      max = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_3__/* .round */ .LI)(range);\n    } else if (max > 0 && rawExtent[1] <= 0) {\n      max = 0;\n      min = -(0,_util_number_js__WEBPACK_IMPORTED_MODULE_3__/* .round */ .LI)(range);\n    }\n  }\n  // Adjust min, max based on the extent of alignTo. When min or max is set in alignTo scale\n  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;\n  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval;\n  // NOTE: Must in setExtent -> setInterval -> setNiceExtent order.\n  intervalScaleProto.setExtent.call(scale, min + interval * t0, max + interval * t1);\n  intervalScaleProto.setInterval.call(scale, interval);\n  if (t0 || t1) {\n    intervalScaleProto.setNiceExtent.call(scale, min + interval, max - interval);\n  }\n  if (false) { var ticks; }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ4Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc0FsaWduVGlja3MuanM/NzI4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGdldFByZWNpc2lvblNhZmUsIHJvdW5kIH0gZnJvbSAnLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IEludGVydmFsU2NhbGUgZnJvbSAnLi4vc2NhbGUvSW50ZXJ2YWwuanMnO1xuaW1wb3J0IHsgZ2V0U2NhbGVFeHRlbnQgfSBmcm9tICcuL2F4aXNIZWxwZXIuanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uL3V0aWwvbG9nLmpzJztcbmltcG9ydCB7IGluY3JlYXNlSW50ZXJ2YWwsIGlzVmFsdWVOaWNlIH0gZnJvbSAnLi4vc2NhbGUvaGVscGVyLmpzJztcbnZhciBtYXRoTG9nID0gTWF0aC5sb2c7XG5leHBvcnQgZnVuY3Rpb24gYWxpZ25TY2FsZVRpY2tzKHNjYWxlLCBheGlzTW9kZWwsIGFsaWduVG9TY2FsZSkge1xuICB2YXIgaW50ZXJ2YWxTY2FsZVByb3RvID0gSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGU7XG4gIC8vIE5PVEU6IFRoZXJlIGlzIGEgcHJlY29uZGl0aW9uIGZvciBsb2cgc2NhbGUgIGhlcmU6XG4gIC8vIEluIGxvZyBzY2FsZSB3ZSBzdG9yZSBfaW50ZXJ2YWwgYW5kIF9leHRlbnQgb2YgZXhwb25lbnQgdmFsdWUuXG4gIC8vIFNvIGlmIHdlIHVzZSB0aGUgbWV0aG9kIG9mIEludGVybmFsU2NhbGUgdG8gc2V0L2dldCB0aGVzZSBkYXRhLlxuICAvLyBJdCBwcm9jZXNzIHRoZSBleHBvbmVudCB2YWx1ZSwgd2hpY2ggaXMgbGluZWFyIGFuZCB3aGF0IHdlIHdhbnQgaGVyZS5cbiAgdmFyIGFsaWduVG9UaWNrcyA9IGludGVydmFsU2NhbGVQcm90by5nZXRUaWNrcy5jYWxsKGFsaWduVG9TY2FsZSk7XG4gIHZhciBhbGlnblRvTmljZWRUaWNrcyA9IGludGVydmFsU2NhbGVQcm90by5nZXRUaWNrcy5jYWxsKGFsaWduVG9TY2FsZSwgdHJ1ZSk7XG4gIHZhciBhbGlnblRvU3BsaXROdW1iZXIgPSBhbGlnblRvVGlja3MubGVuZ3RoIC0gMTtcbiAgdmFyIGFsaWduVG9JbnRlcnZhbCA9IGludGVydmFsU2NhbGVQcm90by5nZXRJbnRlcnZhbC5jYWxsKGFsaWduVG9TY2FsZSk7XG4gIHZhciBzY2FsZUV4dGVudCA9IGdldFNjYWxlRXh0ZW50KHNjYWxlLCBheGlzTW9kZWwpO1xuICB2YXIgcmF3RXh0ZW50ID0gc2NhbGVFeHRlbnQuZXh0ZW50O1xuICB2YXIgaXNNaW5GaXhlZCA9IHNjYWxlRXh0ZW50LmZpeE1pbjtcbiAgdmFyIGlzTWF4Rml4ZWQgPSBzY2FsZUV4dGVudC5maXhNYXg7XG4gIGlmIChzY2FsZS50eXBlID09PSAnbG9nJykge1xuICAgIHZhciBsb2dCYXNlID0gbWF0aExvZyhzY2FsZS5iYXNlKTtcbiAgICByYXdFeHRlbnQgPSBbbWF0aExvZyhyYXdFeHRlbnRbMF0pIC8gbG9nQmFzZSwgbWF0aExvZyhyYXdFeHRlbnRbMV0pIC8gbG9nQmFzZV07XG4gIH1cbiAgc2NhbGUuc2V0RXh0ZW50KHJhd0V4dGVudFswXSwgcmF3RXh0ZW50WzFdKTtcbiAgc2NhbGUuY2FsY05pY2VFeHRlbnQoe1xuICAgIHNwbGl0TnVtYmVyOiBhbGlnblRvU3BsaXROdW1iZXIsXG4gICAgZml4TWluOiBpc01pbkZpeGVkLFxuICAgIGZpeE1heDogaXNNYXhGaXhlZFxuICB9KTtcbiAgdmFyIGV4dGVudCA9IGludGVydmFsU2NhbGVQcm90by5nZXRFeHRlbnQuY2FsbChzY2FsZSk7XG4gIC8vIE5lZWQgdG8gdXBkYXRlIHRoZSByYXdFeHRlbnQuXG4gIC8vIEJlY2F1c2UgdmFsdWUgaW4gcmF3RXh0ZW50IG1heSBiZSBub3QgcGFyc2VkLiBlLmcuICdkYXRhTWluJywgJ2RhdGFNYXgnXG4gIGlmIChpc01pbkZpeGVkKSB7XG4gICAgcmF3RXh0ZW50WzBdID0gZXh0ZW50WzBdO1xuICB9XG4gIGlmIChpc01heEZpeGVkKSB7XG4gICAgcmF3RXh0ZW50WzFdID0gZXh0ZW50WzFdO1xuICB9XG4gIHZhciBpbnRlcnZhbCA9IGludGVydmFsU2NhbGVQcm90by5nZXRJbnRlcnZhbC5jYWxsKHNjYWxlKTtcbiAgdmFyIG1pbiA9IHJhd0V4dGVudFswXTtcbiAgdmFyIG1heCA9IHJhd0V4dGVudFsxXTtcbiAgaWYgKGlzTWluRml4ZWQgJiYgaXNNYXhGaXhlZCkge1xuICAgIC8vIFVzZXIgc2V0IG1pbiwgbWF4LCBkaXZpZGUgdG8gZ2V0IG5ldyBpbnRlcnZhbFxuICAgIGludGVydmFsID0gKG1heCAtIG1pbikgLyBhbGlnblRvU3BsaXROdW1iZXI7XG4gIH0gZWxzZSBpZiAoaXNNaW5GaXhlZCkge1xuICAgIG1heCA9IHJhd0V4dGVudFswXSArIGludGVydmFsICogYWxpZ25Ub1NwbGl0TnVtYmVyO1xuICAgIC8vIFVzZXIgc2V0IG1pbiwgZXhwYW5kIGV4dGVudCBvbiB0aGUgb3RoZXIgc2lkZVxuICAgIHdoaWxlIChtYXggPCByYXdFeHRlbnRbMV0gJiYgaXNGaW5pdGUobWF4KSAmJiBpc0Zpbml0ZShyYXdFeHRlbnRbMV0pKSB7XG4gICAgICBpbnRlcnZhbCA9IGluY3JlYXNlSW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgbWF4ID0gcmF3RXh0ZW50WzBdICsgaW50ZXJ2YWwgKiBhbGlnblRvU3BsaXROdW1iZXI7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTWF4Rml4ZWQpIHtcbiAgICAvLyBVc2VyIHNldCBtYXgsIGV4cGFuZCBleHRlbnQgb24gdGhlIG90aGVyIHNpZGVcbiAgICBtaW4gPSByYXdFeHRlbnRbMV0gLSBpbnRlcnZhbCAqIGFsaWduVG9TcGxpdE51bWJlcjtcbiAgICB3aGlsZSAobWluID4gcmF3RXh0ZW50WzBdICYmIGlzRmluaXRlKG1pbikgJiYgaXNGaW5pdGUocmF3RXh0ZW50WzBdKSkge1xuICAgICAgaW50ZXJ2YWwgPSBpbmNyZWFzZUludGVydmFsKGludGVydmFsKTtcbiAgICAgIG1pbiA9IHJhd0V4dGVudFsxXSAtIGludGVydmFsICogYWxpZ25Ub1NwbGl0TnVtYmVyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbmljZWRTcGxpdE51bWJlciA9IHNjYWxlLmdldFRpY2tzKCkubGVuZ3RoIC0gMTtcbiAgICBpZiAobmljZWRTcGxpdE51bWJlciA+IGFsaWduVG9TcGxpdE51bWJlcikge1xuICAgICAgaW50ZXJ2YWwgPSBpbmNyZWFzZUludGVydmFsKGludGVydmFsKTtcbiAgICB9XG4gICAgdmFyIHJhbmdlID0gaW50ZXJ2YWwgKiBhbGlnblRvU3BsaXROdW1iZXI7XG4gICAgbWF4ID0gTWF0aC5jZWlsKHJhd0V4dGVudFsxXSAvIGludGVydmFsKSAqIGludGVydmFsO1xuICAgIG1pbiA9IHJvdW5kKG1heCAtIHJhbmdlKTtcbiAgICAvLyBOb3QgY2hhbmdlIHRoZSByZXN1bHQgdGhhdCBjcm9zc2luZyB6ZXJvLlxuICAgIGlmIChtaW4gPCAwICYmIHJhd0V4dGVudFswXSA+PSAwKSB7XG4gICAgICBtaW4gPSAwO1xuICAgICAgbWF4ID0gcm91bmQocmFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobWF4ID4gMCAmJiByYXdFeHRlbnRbMV0gPD0gMCkge1xuICAgICAgbWF4ID0gMDtcbiAgICAgIG1pbiA9IC1yb3VuZChyYW5nZSk7XG4gICAgfVxuICB9XG4gIC8vIEFkanVzdCBtaW4sIG1heCBiYXNlZCBvbiB0aGUgZXh0ZW50IG9mIGFsaWduVG8uIFdoZW4gbWluIG9yIG1heCBpcyBzZXQgaW4gYWxpZ25UbyBzY2FsZVxuICB2YXIgdDAgPSAoYWxpZ25Ub1RpY2tzWzBdLnZhbHVlIC0gYWxpZ25Ub05pY2VkVGlja3NbMF0udmFsdWUpIC8gYWxpZ25Ub0ludGVydmFsO1xuICB2YXIgdDEgPSAoYWxpZ25Ub1RpY2tzW2FsaWduVG9TcGxpdE51bWJlcl0udmFsdWUgLSBhbGlnblRvTmljZWRUaWNrc1thbGlnblRvU3BsaXROdW1iZXJdLnZhbHVlKSAvIGFsaWduVG9JbnRlcnZhbDtcbiAgLy8gTk9URTogTXVzdCBpbiBzZXRFeHRlbnQgLT4gc2V0SW50ZXJ2YWwgLT4gc2V0TmljZUV4dGVudCBvcmRlci5cbiAgaW50ZXJ2YWxTY2FsZVByb3RvLnNldEV4dGVudC5jYWxsKHNjYWxlLCBtaW4gKyBpbnRlcnZhbCAqIHQwLCBtYXggKyBpbnRlcnZhbCAqIHQxKTtcbiAgaW50ZXJ2YWxTY2FsZVByb3RvLnNldEludGVydmFsLmNhbGwoc2NhbGUsIGludGVydmFsKTtcbiAgaWYgKHQwIHx8IHQxKSB7XG4gICAgaW50ZXJ2YWxTY2FsZVByb3RvLnNldE5pY2VFeHRlbnQuY2FsbChzY2FsZSwgbWluICsgaW50ZXJ2YWwsIG1heCAtIGludGVydmFsKTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciB0aWNrcyA9IGludGVydmFsU2NhbGVQcm90by5nZXRUaWNrcy5jYWxsKHNjYWxlKTtcbiAgICBpZiAodGlja3NbMV0gJiYgKCFpc1ZhbHVlTmljZShpbnRlcnZhbCkgfHwgZ2V0UHJlY2lzaW9uU2FmZSh0aWNrc1sxXS52YWx1ZSkgPiBnZXRQcmVjaXNpb25TYWZlKGludGVydmFsKSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIFwiVGhlIHRpY2tzIG1heSBiZSBub3QgcmVhZGFibGUgd2hlbiBzZXQgbWluOiBcIiArIGF4aXNNb2RlbC5nZXQoJ21pbicpICsgXCIsIG1heDogXCIgKyBheGlzTW9kZWwuZ2V0KCdtYXgnKSArIFwiIGFuZCBhbGlnblRpY2tzOiB0cnVlXCIpO1xuICAgIH1cbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3486\n')},5196:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98026);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15915);\n/* harmony import */ var _util_layout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34253);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar CalendarModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(CalendarModel, _super);\n  function CalendarModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = CalendarModel.type;\n    return _this;\n  }\n  /**\r\n   * @override\r\n   */\n  CalendarModel.prototype.init = function (option, parentModel, ecModel) {\n    var inputPositionParams = (0,_util_layout_js__WEBPACK_IMPORTED_MODULE_1__/* .getLayoutParams */ .vs)(option);\n    _super.prototype.init.apply(this, arguments);\n    mergeAndNormalizeLayoutParams(option, inputPositionParams);\n  };\n  /**\r\n   * @override\r\n   */\n  CalendarModel.prototype.mergeOption = function (option) {\n    _super.prototype.mergeOption.apply(this, arguments);\n    mergeAndNormalizeLayoutParams(this.option, option);\n  };\n  CalendarModel.prototype.getCellSize = function () {\n    // Has been normalized\n    return this.option.cellSize;\n  };\n  CalendarModel.type = 'calendar';\n  CalendarModel.defaultOption = {\n    // zlevel: 0,\n    z: 2,\n    left: 80,\n    top: 60,\n    cellSize: 20,\n    // horizontal vertical\n    orient: 'horizontal',\n    // month separate line style\n    splitLine: {\n      show: true,\n      lineStyle: {\n        color: '#000',\n        width: 1,\n        type: 'solid'\n      }\n    },\n    // rect style  temporarily unused emphasis\n    itemStyle: {\n      color: '#fff',\n      borderWidth: 1,\n      borderColor: '#ccc'\n    },\n    // week text style\n    dayLabel: {\n      show: true,\n      firstDay: 0,\n      // start end\n      position: 'start',\n      margin: '50%',\n      color: '#000'\n    },\n    // month text style\n    monthLabel: {\n      show: true,\n      // start end\n      position: 'start',\n      margin: 5,\n      // center or left\n      align: 'center',\n      formatter: null,\n      color: '#000'\n    },\n    // year text style\n    yearLabel: {\n      show: true,\n      // top bottom left right\n      position: null,\n      margin: 30,\n      formatter: null,\n      color: '#ccc',\n      fontFamily: 'sans-serif',\n      fontWeight: 'bolder',\n      fontSize: 20\n    }\n  };\n  return CalendarModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A);\nfunction mergeAndNormalizeLayoutParams(target, raw) {\n  // Normalize cellSize\n  var cellSize = target.cellSize;\n  var cellSizeArr;\n  if (!zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.isArray(cellSize)) {\n    cellSizeArr = target.cellSize = [cellSize, cellSize];\n  } else {\n    cellSizeArr = cellSize;\n  }\n  if (cellSizeArr.length === 1) {\n    cellSizeArr[1] = cellSizeArr[0];\n  }\n  var ignoreSize = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.map([0, 1], function (hvIdx) {\n    // If user have set `width` or both `left` and `right`, cellSizeArr\n    // will be automatically set to 'auto', otherwise the default\n    // setting of cellSizeArr will make `width` setting not work.\n    if ((0,_util_layout_js__WEBPACK_IMPORTED_MODULE_1__/* .sizeCalculable */ .Qf)(raw, hvIdx)) {\n      cellSizeArr[hvIdx] = 'auto';\n    }\n    return cellSizeArr[hvIdx] != null && cellSizeArr[hvIdx] !== 'auto';\n  });\n  (0,_util_layout_js__WEBPACK_IMPORTED_MODULE_1__/* .mergeLayoutParam */ .YA)(target, raw, {\n    type: 'box',\n    ignoreSize: ignoreSize\n  });\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalendarModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE5Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhbGVuZGFyL0NhbGVuZGFyTW9kZWwuanM/NjcyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50LmpzJztcbmltcG9ydCB7IGdldExheW91dFBhcmFtcywgc2l6ZUNhbGN1bGFibGUsIG1lcmdlTGF5b3V0UGFyYW0gfSBmcm9tICcuLi8uLi91dGlsL2xheW91dC5qcyc7XG52YXIgQ2FsZW5kYXJNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDYWxlbmRhck1vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBDYWxlbmRhck1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBDYWxlbmRhck1vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBDYWxlbmRhck1vZGVsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpIHtcbiAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGdldExheW91dFBhcmFtcyhvcHRpb24pO1xuICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIG1lcmdlQW5kTm9ybWFsaXplTGF5b3V0UGFyYW1zKG9wdGlvbiwgaW5wdXRQb3NpdGlvblBhcmFtcyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBDYWxlbmRhck1vZGVsLnByb3RvdHlwZS5tZXJnZU9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLm1lcmdlT3B0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgbWVyZ2VBbmROb3JtYWxpemVMYXlvdXRQYXJhbXModGhpcy5vcHRpb24sIG9wdGlvbik7XG4gIH07XG4gIENhbGVuZGFyTW9kZWwucHJvdG90eXBlLmdldENlbGxTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEhhcyBiZWVuIG5vcm1hbGl6ZWRcbiAgICByZXR1cm4gdGhpcy5vcHRpb24uY2VsbFNpemU7XG4gIH07XG4gIENhbGVuZGFyTW9kZWwudHlwZSA9ICdjYWxlbmRhcic7XG4gIENhbGVuZGFyTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAvLyB6bGV2ZWw6IDAsXG4gICAgejogMixcbiAgICBsZWZ0OiA4MCxcbiAgICB0b3A6IDYwLFxuICAgIGNlbGxTaXplOiAyMCxcbiAgICAvLyBob3Jpem9udGFsIHZlcnRpY2FsXG4gICAgb3JpZW50OiAnaG9yaXpvbnRhbCcsXG4gICAgLy8gbW9udGggc2VwYXJhdGUgbGluZSBzdHlsZVxuICAgIHNwbGl0TGluZToge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBjb2xvcjogJyMwMDAnLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gcmVjdCBzdHlsZSAgdGVtcG9yYXJpbHkgdW51c2VkIGVtcGhhc2lzXG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICBib3JkZXJDb2xvcjogJyNjY2MnXG4gICAgfSxcbiAgICAvLyB3ZWVrIHRleHQgc3R5bGVcbiAgICBkYXlMYWJlbDoge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIGZpcnN0RGF5OiAwLFxuICAgICAgLy8gc3RhcnQgZW5kXG4gICAgICBwb3NpdGlvbjogJ3N0YXJ0JyxcbiAgICAgIG1hcmdpbjogJzUwJScsXG4gICAgICBjb2xvcjogJyMwMDAnXG4gICAgfSxcbiAgICAvLyBtb250aCB0ZXh0IHN0eWxlXG4gICAgbW9udGhMYWJlbDoge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIC8vIHN0YXJ0IGVuZFxuICAgICAgcG9zaXRpb246ICdzdGFydCcsXG4gICAgICBtYXJnaW46IDUsXG4gICAgICAvLyBjZW50ZXIgb3IgbGVmdFxuICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgZm9ybWF0dGVyOiBudWxsLFxuICAgICAgY29sb3I6ICcjMDAwJ1xuICAgIH0sXG4gICAgLy8geWVhciB0ZXh0IHN0eWxlXG4gICAgeWVhckxhYmVsOiB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgLy8gdG9wIGJvdHRvbSBsZWZ0IHJpZ2h0XG4gICAgICBwb3NpdGlvbjogbnVsbCxcbiAgICAgIG1hcmdpbjogMzAsXG4gICAgICBmb3JtYXR0ZXI6IG51bGwsXG4gICAgICBjb2xvcjogJyNjY2MnLFxuICAgICAgZm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuICAgICAgZm9udFdlaWdodDogJ2JvbGRlcicsXG4gICAgICBmb250U2l6ZTogMjBcbiAgICB9XG4gIH07XG4gIHJldHVybiBDYWxlbmRhck1vZGVsO1xufShDb21wb25lbnRNb2RlbCk7XG5mdW5jdGlvbiBtZXJnZUFuZE5vcm1hbGl6ZUxheW91dFBhcmFtcyh0YXJnZXQsIHJhdykge1xuICAvLyBOb3JtYWxpemUgY2VsbFNpemVcbiAgdmFyIGNlbGxTaXplID0gdGFyZ2V0LmNlbGxTaXplO1xuICB2YXIgY2VsbFNpemVBcnI7XG4gIGlmICghenJVdGlsLmlzQXJyYXkoY2VsbFNpemUpKSB7XG4gICAgY2VsbFNpemVBcnIgPSB0YXJnZXQuY2VsbFNpemUgPSBbY2VsbFNpemUsIGNlbGxTaXplXTtcbiAgfSBlbHNlIHtcbiAgICBjZWxsU2l6ZUFyciA9IGNlbGxTaXplO1xuICB9XG4gIGlmIChjZWxsU2l6ZUFyci5sZW5ndGggPT09IDEpIHtcbiAgICBjZWxsU2l6ZUFyclsxXSA9IGNlbGxTaXplQXJyWzBdO1xuICB9XG4gIHZhciBpZ25vcmVTaXplID0genJVdGlsLm1hcChbMCwgMV0sIGZ1bmN0aW9uIChodklkeCkge1xuICAgIC8vIElmIHVzZXIgaGF2ZSBzZXQgYHdpZHRoYCBvciBib3RoIGBsZWZ0YCBhbmQgYHJpZ2h0YCwgY2VsbFNpemVBcnJcbiAgICAvLyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvICdhdXRvJywgb3RoZXJ3aXNlIHRoZSBkZWZhdWx0XG4gICAgLy8gc2V0dGluZyBvZiBjZWxsU2l6ZUFyciB3aWxsIG1ha2UgYHdpZHRoYCBzZXR0aW5nIG5vdCB3b3JrLlxuICAgIGlmIChzaXplQ2FsY3VsYWJsZShyYXcsIGh2SWR4KSkge1xuICAgICAgY2VsbFNpemVBcnJbaHZJZHhdID0gJ2F1dG8nO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbFNpemVBcnJbaHZJZHhdICE9IG51bGwgJiYgY2VsbFNpemVBcnJbaHZJZHhdICE9PSAnYXV0byc7XG4gIH0pO1xuICBtZXJnZUxheW91dFBhcmFtKHRhcmdldCwgcmF3LCB7XG4gICAgdHlwZTogJ2JveCcsXG4gICAgaWdub3JlU2l6ZTogaWdub3JlU2l6ZVxuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IENhbGVuZGFyTW9kZWw7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5196\n")},8287:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EO: () => (/* binding */ calculateCategoryInterval),\n/* harmony export */   MI: () => (/* binding */ createAxisTicks),\n/* harmony export */   vI: () => (/* binding */ createAxisLabels)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var zrender_lib_contain_text_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45558);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n/* harmony import */ var _axisHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99031);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar inner = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nfunction tickValuesToNumbers(axis, values) {\n  var nums = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map(values, function (val) {\n    return axis.scale.parse(val);\n  });\n  if (axis.type === 'time' && nums.length > 0) {\n    // Time axis needs duplicate first/last tick (see TimeScale.getTicks())\n    // The first and last tick/label don't get drawn\n    nums.sort();\n    nums.unshift(nums[0]);\n    nums.push(nums[nums.length - 1]);\n  }\n  return nums;\n}\nfunction createAxisLabels(axis) {\n  var custom = axis.getLabelModel().get('customValues');\n  if (custom) {\n    var labelFormatter_1 = (0,_axisHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .makeLabelFormatter */ .ry)(axis);\n    var extent_1 = axis.scale.getExtent();\n    var tickNumbers = tickValuesToNumbers(axis, custom);\n    var ticks = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.filter(tickNumbers, function (val) {\n      return val >= extent_1[0] && val <= extent_1[1];\n    });\n    return {\n      labels: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map(ticks, function (numval) {\n        var tick = {\n          value: numval\n        };\n        return {\n          formattedLabel: labelFormatter_1(tick),\n          rawLabel: axis.scale.getLabel(tick),\n          tickValue: numval\n        };\n      })\n    };\n  }\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);\n}\n/**\r\n * @param {module:echats/coord/Axis} axis\r\n * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.\r\n * @return {Object} {\r\n *     ticks: Array.<number>\r\n *     tickCategoryInterval: number\r\n * }\r\n */\nfunction createAxisTicks(axis, tickModel) {\n  var custom = axis.getTickModel().get('customValues');\n  if (custom) {\n    var extent_2 = axis.scale.getExtent();\n    var tickNumbers = tickValuesToNumbers(axis, custom);\n    return {\n      ticks: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.filter(tickNumbers, function (val) {\n        return val >= extent_2[0] && val <= extent_2[1];\n      })\n    };\n  }\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {\n    ticks: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map(axis.scale.getTicks(), function (tick) {\n      return tick.value;\n    })\n  };\n}\nfunction makeCategoryLabels(axis) {\n  var labelModel = axis.getLabelModel();\n  var result = makeCategoryLabelsActually(axis, labelModel);\n  return !labelModel.get('show') || axis.scale.isBlank() ? {\n    labels: [],\n    labelCategoryInterval: result.labelCategoryInterval\n  } : result;\n}\nfunction makeCategoryLabelsActually(axis, labelModel) {\n  var labelsCache = getListCache(axis, 'labels');\n  var optionLabelInterval = (0,_axisHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .getOptionCategoryInterval */ .j2)(labelModel);\n  var result = listCacheGet(labelsCache, optionLabelInterval);\n  if (result) {\n    return result;\n  }\n  var labels;\n  var numericLabelInterval;\n  if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction(optionLabelInterval)) {\n    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);\n  } else {\n    numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;\n    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);\n  }\n  // Cache to avoid calling interval function repeatedly.\n  return listCacheSet(labelsCache, optionLabelInterval, {\n    labels: labels,\n    labelCategoryInterval: numericLabelInterval\n  });\n}\nfunction makeCategoryTicks(axis, tickModel) {\n  var ticksCache = getListCache(axis, 'ticks');\n  var optionTickInterval = (0,_axisHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .getOptionCategoryInterval */ .j2)(tickModel);\n  var result = listCacheGet(ticksCache, optionTickInterval);\n  if (result) {\n    return result;\n  }\n  var ticks;\n  var tickCategoryInterval;\n  // Optimize for the case that large category data and no label displayed,\n  // we should not return all ticks.\n  if (!tickModel.get('show') || axis.scale.isBlank()) {\n    ticks = [];\n  }\n  if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction(optionTickInterval)) {\n    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);\n  }\n  // Always use label interval by default despite label show. Consider this\n  // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows\n  // labels. `splitLine` and `axisTick` should be consistent in this case.\n  else if (optionTickInterval === 'auto') {\n    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());\n    tickCategoryInterval = labelsResult.labelCategoryInterval;\n    ticks = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map(labelsResult.labels, function (labelItem) {\n      return labelItem.tickValue;\n    });\n  } else {\n    tickCategoryInterval = optionTickInterval;\n    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);\n  }\n  // Cache to avoid calling interval function repeatedly.\n  return listCacheSet(ticksCache, optionTickInterval, {\n    ticks: ticks,\n    tickCategoryInterval: tickCategoryInterval\n  });\n}\nfunction makeRealNumberLabels(axis) {\n  var ticks = axis.scale.getTicks();\n  var labelFormatter = (0,_axisHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .makeLabelFormatter */ .ry)(axis);\n  return {\n    labels: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map(ticks, function (tick, idx) {\n      return {\n        level: tick.level,\n        formattedLabel: labelFormatter(tick, idx),\n        rawLabel: axis.scale.getLabel(tick),\n        tickValue: tick.value\n      };\n    })\n  };\n}\nfunction getListCache(axis, prop) {\n  // Because key can be a function, and cache size always is small, we use array cache.\n  return inner(axis)[prop] || (inner(axis)[prop] = []);\n}\nfunction listCacheGet(cache, key) {\n  for (var i = 0; i < cache.length; i++) {\n    if (cache[i].key === key) {\n      return cache[i].value;\n    }\n  }\n}\nfunction listCacheSet(cache, key, value) {\n  cache.push({\n    key: key,\n    value: value\n  });\n  return value;\n}\nfunction makeAutoCategoryInterval(axis) {\n  var result = inner(axis).autoInterval;\n  return result != null ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();\n}\n/**\r\n * Calculate interval for category axis ticks and labels.\r\n * To get precise result, at least one of `getRotate` and `isHorizontal`\r\n * should be implemented in axis.\r\n */\nfunction calculateCategoryInterval(axis) {\n  var params = fetchAutoCategoryIntervalCalculationParams(axis);\n  var labelFormatter = (0,_axisHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .makeLabelFormatter */ .ry)(axis);\n  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  // Providing this method is for optimization:\n  // avoid generating a long array by `getTicks`\n  // in large category data case.\n  var tickCount = ordinalScale.count();\n  if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n    return 0;\n  }\n  var step = 1;\n  // Simple optimization. Empirical value: tick count should less than 40.\n  if (tickCount > 40) {\n    step = Math.max(1, Math.floor(tickCount / 40));\n  }\n  var tickValue = ordinalExtent[0];\n  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n  var unitW = Math.abs(unitSpan * Math.cos(rotation));\n  var unitH = Math.abs(unitSpan * Math.sin(rotation));\n  var maxW = 0;\n  var maxH = 0;\n  // Caution: Performance sensitive for large category data.\n  // Consider dataZoom, we should make appropriate step to avoid O(n) loop.\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    var width = 0;\n    var height = 0;\n    // Not precise, do not consider align and vertical align\n    // and each distance from axis line yet.\n    var rect = zrender_lib_contain_text_js__WEBPACK_IMPORTED_MODULE_3__/* .getBoundingRect */ .NO(labelFormatter({\n      value: tickValue\n    }), params.font, 'center', 'top');\n    // Magic number\n    width = rect.width * 1.3;\n    height = rect.height * 1.3;\n    // Min size, void long loop.\n    maxW = Math.max(maxW, width, 7);\n    maxH = Math.max(maxH, height, 7);\n  }\n  var dw = maxW / unitW;\n  var dh = maxH / unitH;\n  // 0/0 is NaN, 1/0 is Infinity.\n  isNaN(dw) && (dw = Infinity);\n  isNaN(dh) && (dh = Infinity);\n  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));\n  var cache = inner(axis.model);\n  var axisExtent = axis.getExtent();\n  var lastAutoInterval = cache.lastAutoInterval;\n  var lastTickCount = cache.lastTickCount;\n  // Use cache to keep interval stable while moving zoom window,\n  // otherwise the calculated interval might jitter when the zoom\n  // window size is close to the interval-changing size.\n  // For example, if all of the axis labels are `a, b, c, d, e, f, g`.\n  // The jitter will cause that sometimes the displayed labels are\n  // `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).\n  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1\n  // Always choose the bigger one, otherwise the critical\n  // point is not the same when zooming in or zooming out.\n  && lastAutoInterval > interval\n  // If the axis change is caused by chart resize, the cache should not\n  // be used. Otherwise some hidden labels might not be shown again.\n  && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {\n    interval = lastAutoInterval;\n  }\n  // Only update cache if cache not used, otherwise the\n  // changing of interval is too insensitive.\n  else {\n    cache.lastTickCount = tickCount;\n    cache.lastAutoInterval = interval;\n    cache.axisExtent0 = axisExtent[0];\n    cache.axisExtent1 = axisExtent[1];\n  }\n  return interval;\n}\nfunction fetchAutoCategoryIntervalCalculationParams(axis) {\n  var labelModel = axis.getLabelModel();\n  return {\n    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,\n    labelRotate: labelModel.get('rotate') || 0,\n    font: labelModel.getFont()\n  };\n}\nfunction makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {\n  var labelFormatter = (0,_axisHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .makeLabelFormatter */ .ry)(axis);\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  var labelModel = axis.getLabelModel();\n  var result = [];\n  // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...\n  var step = Math.max((categoryInterval || 0) + 1, 1);\n  var startTick = ordinalExtent[0];\n  var tickCount = ordinalScale.count();\n  // Calculate start tick based on zero if possible to keep label consistent\n  // while zooming and moving while interval > 0. Otherwise the selection\n  // of displayable ticks and symbols probably keep changing.\n  // 3 is empirical value.\n  if (startTick !== 0 && step > 1 && tickCount / step > 2) {\n    startTick = Math.round(Math.ceil(startTick / step) * step);\n  }\n  // (1) Only add min max label here but leave overlap checking\n  // to render stage, which also ensure the returned list\n  // suitable for splitLine and splitArea rendering.\n  // (2) Scales except category always contain min max label so\n  // do not need to perform this process.\n  var showAllLabel = (0,_axisHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .shouldShowAllLabels */ .PJ)(axis);\n  var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;\n  var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;\n  if (includeMinLabel && startTick !== ordinalExtent[0]) {\n    addItem(ordinalExtent[0]);\n  }\n  // Optimize: avoid generating large array by `ordinalScale.getTicks()`.\n  var tickValue = startTick;\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    addItem(tickValue);\n  }\n  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {\n    addItem(ordinalExtent[1]);\n  }\n  function addItem(tickValue) {\n    var tickObj = {\n      value: tickValue\n    };\n    result.push(onlyTick ? tickValue : {\n      formattedLabel: labelFormatter(tickObj),\n      rawLabel: ordinalScale.getLabel(tickObj),\n      tickValue: tickValue\n    });\n  }\n  return result;\n}\nfunction makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {\n  var ordinalScale = axis.scale;\n  var labelFormatter = (0,_axisHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .makeLabelFormatter */ .ry)(axis);\n  var result = [];\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(ordinalScale.getTicks(), function (tick) {\n    var rawLabel = ordinalScale.getLabel(tick);\n    var tickValue = tick.value;\n    if (categoryInterval(tick.value, rawLabel)) {\n      result.push(onlyTick ? tickValue : {\n        formattedLabel: labelFormatter(tick),\n        rawLabel: rawLabel,\n        tickValue: tickValue\n      });\n    }\n  });\n  return result;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI4Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9heGlzVGlja0xhYmVsQnVpbGRlci5qcz83MmE1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgKiBhcyB0ZXh0Q29udGFpbiBmcm9tICd6cmVuZGVyL2xpYi9jb250YWluL3RleHQuanMnO1xuaW1wb3J0IHsgbWFrZUlubmVyIH0gZnJvbSAnLi4vdXRpbC9tb2RlbC5qcyc7XG5pbXBvcnQgeyBtYWtlTGFiZWxGb3JtYXR0ZXIsIGdldE9wdGlvbkNhdGVnb3J5SW50ZXJ2YWwsIHNob3VsZFNob3dBbGxMYWJlbHMgfSBmcm9tICcuL2F4aXNIZWxwZXIuanMnO1xudmFyIGlubmVyID0gbWFrZUlubmVyKCk7XG5mdW5jdGlvbiB0aWNrVmFsdWVzVG9OdW1iZXJzKGF4aXMsIHZhbHVlcykge1xuICB2YXIgbnVtcyA9IHpyVXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIGF4aXMuc2NhbGUucGFyc2UodmFsKTtcbiAgfSk7XG4gIGlmIChheGlzLnR5cGUgPT09ICd0aW1lJyAmJiBudW1zLmxlbmd0aCA+IDApIHtcbiAgICAvLyBUaW1lIGF4aXMgbmVlZHMgZHVwbGljYXRlIGZpcnN0L2xhc3QgdGljayAoc2VlIFRpbWVTY2FsZS5nZXRUaWNrcygpKVxuICAgIC8vIFRoZSBmaXJzdCBhbmQgbGFzdCB0aWNrL2xhYmVsIGRvbid0IGdldCBkcmF3blxuICAgIG51bXMuc29ydCgpO1xuICAgIG51bXMudW5zaGlmdChudW1zWzBdKTtcbiAgICBudW1zLnB1c2gobnVtc1tudW1zLmxlbmd0aCAtIDFdKTtcbiAgfVxuICByZXR1cm4gbnVtcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBeGlzTGFiZWxzKGF4aXMpIHtcbiAgdmFyIGN1c3RvbSA9IGF4aXMuZ2V0TGFiZWxNb2RlbCgpLmdldCgnY3VzdG9tVmFsdWVzJyk7XG4gIGlmIChjdXN0b20pIHtcbiAgICB2YXIgbGFiZWxGb3JtYXR0ZXJfMSA9IG1ha2VMYWJlbEZvcm1hdHRlcihheGlzKTtcbiAgICB2YXIgZXh0ZW50XzEgPSBheGlzLnNjYWxlLmdldEV4dGVudCgpO1xuICAgIHZhciB0aWNrTnVtYmVycyA9IHRpY2tWYWx1ZXNUb051bWJlcnMoYXhpcywgY3VzdG9tKTtcbiAgICB2YXIgdGlja3MgPSB6clV0aWwuZmlsdGVyKHRpY2tOdW1iZXJzLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gdmFsID49IGV4dGVudF8xWzBdICYmIHZhbCA8PSBleHRlbnRfMVsxXTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWxzOiB6clV0aWwubWFwKHRpY2tzLCBmdW5jdGlvbiAobnVtdmFsKSB7XG4gICAgICAgIHZhciB0aWNrID0ge1xuICAgICAgICAgIHZhbHVlOiBudW12YWxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmb3JtYXR0ZWRMYWJlbDogbGFiZWxGb3JtYXR0ZXJfMSh0aWNrKSxcbiAgICAgICAgICByYXdMYWJlbDogYXhpcy5zY2FsZS5nZXRMYWJlbCh0aWNrKSxcbiAgICAgICAgICB0aWNrVmFsdWU6IG51bXZhbFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIC8vIE9ubHkgb3JkaW5hbCBzY2FsZSBzdXBwb3J0IHRpY2sgaW50ZXJ2YWxcbiAgcmV0dXJuIGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IG1ha2VDYXRlZ29yeUxhYmVscyhheGlzKSA6IG1ha2VSZWFsTnVtYmVyTGFiZWxzKGF4aXMpO1xufVxuLyoqXHJcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGF0cy9jb29yZC9BeGlzfSBheGlzXHJcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IHRpY2tNb2RlbCBGb3IgZXhhbXBsZSwgY2FuIGJlIGF4aXNUaWNrLCBzcGxpdExpbmUsIHNwbGl0QXJlYS5cclxuICogQHJldHVybiB7T2JqZWN0fSB7XHJcbiAqICAgICB0aWNrczogQXJyYXkuPG51bWJlcj5cclxuICogICAgIHRpY2tDYXRlZ29yeUludGVydmFsOiBudW1iZXJcclxuICogfVxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBeGlzVGlja3MoYXhpcywgdGlja01vZGVsKSB7XG4gIHZhciBjdXN0b20gPSBheGlzLmdldFRpY2tNb2RlbCgpLmdldCgnY3VzdG9tVmFsdWVzJyk7XG4gIGlmIChjdXN0b20pIHtcbiAgICB2YXIgZXh0ZW50XzIgPSBheGlzLnNjYWxlLmdldEV4dGVudCgpO1xuICAgIHZhciB0aWNrTnVtYmVycyA9IHRpY2tWYWx1ZXNUb051bWJlcnMoYXhpcywgY3VzdG9tKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGlja3M6IHpyVXRpbC5maWx0ZXIodGlja051bWJlcnMsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+PSBleHRlbnRfMlswXSAmJiB2YWwgPD0gZXh0ZW50XzJbMV07XG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgLy8gT25seSBvcmRpbmFsIHNjYWxlIHN1cHBvcnQgdGljayBpbnRlcnZhbFxuICByZXR1cm4gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gbWFrZUNhdGVnb3J5VGlja3MoYXhpcywgdGlja01vZGVsKSA6IHtcbiAgICB0aWNrczogenJVdGlsLm1hcChheGlzLnNjYWxlLmdldFRpY2tzKCksIGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICByZXR1cm4gdGljay52YWx1ZTtcbiAgICB9KVxuICB9O1xufVxuZnVuY3Rpb24gbWFrZUNhdGVnb3J5TGFiZWxzKGF4aXMpIHtcbiAgdmFyIGxhYmVsTW9kZWwgPSBheGlzLmdldExhYmVsTW9kZWwoKTtcbiAgdmFyIHJlc3VsdCA9IG1ha2VDYXRlZ29yeUxhYmVsc0FjdHVhbGx5KGF4aXMsIGxhYmVsTW9kZWwpO1xuICByZXR1cm4gIWxhYmVsTW9kZWwuZ2V0KCdzaG93JykgfHwgYXhpcy5zY2FsZS5pc0JsYW5rKCkgPyB7XG4gICAgbGFiZWxzOiBbXSxcbiAgICBsYWJlbENhdGVnb3J5SW50ZXJ2YWw6IHJlc3VsdC5sYWJlbENhdGVnb3J5SW50ZXJ2YWxcbiAgfSA6IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1ha2VDYXRlZ29yeUxhYmVsc0FjdHVhbGx5KGF4aXMsIGxhYmVsTW9kZWwpIHtcbiAgdmFyIGxhYmVsc0NhY2hlID0gZ2V0TGlzdENhY2hlKGF4aXMsICdsYWJlbHMnKTtcbiAgdmFyIG9wdGlvbkxhYmVsSW50ZXJ2YWwgPSBnZXRPcHRpb25DYXRlZ29yeUludGVydmFsKGxhYmVsTW9kZWwpO1xuICB2YXIgcmVzdWx0ID0gbGlzdENhY2hlR2V0KGxhYmVsc0NhY2hlLCBvcHRpb25MYWJlbEludGVydmFsKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIGxhYmVscztcbiAgdmFyIG51bWVyaWNMYWJlbEludGVydmFsO1xuICBpZiAoenJVdGlsLmlzRnVuY3Rpb24ob3B0aW9uTGFiZWxJbnRlcnZhbCkpIHtcbiAgICBsYWJlbHMgPSBtYWtlTGFiZWxzQnlDdXN0b21pemVkQ2F0ZWdvcnlJbnRlcnZhbChheGlzLCBvcHRpb25MYWJlbEludGVydmFsKTtcbiAgfSBlbHNlIHtcbiAgICBudW1lcmljTGFiZWxJbnRlcnZhbCA9IG9wdGlvbkxhYmVsSW50ZXJ2YWwgPT09ICdhdXRvJyA/IG1ha2VBdXRvQ2F0ZWdvcnlJbnRlcnZhbChheGlzKSA6IG9wdGlvbkxhYmVsSW50ZXJ2YWw7XG4gICAgbGFiZWxzID0gbWFrZUxhYmVsc0J5TnVtZXJpY0NhdGVnb3J5SW50ZXJ2YWwoYXhpcywgbnVtZXJpY0xhYmVsSW50ZXJ2YWwpO1xuICB9XG4gIC8vIENhY2hlIHRvIGF2b2lkIGNhbGxpbmcgaW50ZXJ2YWwgZnVuY3Rpb24gcmVwZWF0ZWRseS5cbiAgcmV0dXJuIGxpc3RDYWNoZVNldChsYWJlbHNDYWNoZSwgb3B0aW9uTGFiZWxJbnRlcnZhbCwge1xuICAgIGxhYmVsczogbGFiZWxzLFxuICAgIGxhYmVsQ2F0ZWdvcnlJbnRlcnZhbDogbnVtZXJpY0xhYmVsSW50ZXJ2YWxcbiAgfSk7XG59XG5mdW5jdGlvbiBtYWtlQ2F0ZWdvcnlUaWNrcyhheGlzLCB0aWNrTW9kZWwpIHtcbiAgdmFyIHRpY2tzQ2FjaGUgPSBnZXRMaXN0Q2FjaGUoYXhpcywgJ3RpY2tzJyk7XG4gIHZhciBvcHRpb25UaWNrSW50ZXJ2YWwgPSBnZXRPcHRpb25DYXRlZ29yeUludGVydmFsKHRpY2tNb2RlbCk7XG4gIHZhciByZXN1bHQgPSBsaXN0Q2FjaGVHZXQodGlja3NDYWNoZSwgb3B0aW9uVGlja0ludGVydmFsKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIHRpY2tzO1xuICB2YXIgdGlja0NhdGVnb3J5SW50ZXJ2YWw7XG4gIC8vIE9wdGltaXplIGZvciB0aGUgY2FzZSB0aGF0IGxhcmdlIGNhdGVnb3J5IGRhdGEgYW5kIG5vIGxhYmVsIGRpc3BsYXllZCxcbiAgLy8gd2Ugc2hvdWxkIG5vdCByZXR1cm4gYWxsIHRpY2tzLlxuICBpZiAoIXRpY2tNb2RlbC5nZXQoJ3Nob3cnKSB8fCBheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgIHRpY2tzID0gW107XG4gIH1cbiAgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKG9wdGlvblRpY2tJbnRlcnZhbCkpIHtcbiAgICB0aWNrcyA9IG1ha2VMYWJlbHNCeUN1c3RvbWl6ZWRDYXRlZ29yeUludGVydmFsKGF4aXMsIG9wdGlvblRpY2tJbnRlcnZhbCwgdHJ1ZSk7XG4gIH1cbiAgLy8gQWx3YXlzIHVzZSBsYWJlbCBpbnRlcnZhbCBieSBkZWZhdWx0IGRlc3BpdGUgbGFiZWwgc2hvdy4gQ29uc2lkZXIgdGhpc1xuICAvLyBzY2VuYXJpbywgVXNlIG11bHRpcGxlIGdyaWQgd2l0aCB0aGUgeEF4aXMgc3luYywgYW5kIG9ubHkgb25lIHhBeGlzIHNob3dzXG4gIC8vIGxhYmVscy4gYHNwbGl0TGluZWAgYW5kIGBheGlzVGlja2Agc2hvdWxkIGJlIGNvbnNpc3RlbnQgaW4gdGhpcyBjYXNlLlxuICBlbHNlIGlmIChvcHRpb25UaWNrSW50ZXJ2YWwgPT09ICdhdXRvJykge1xuICAgIHZhciBsYWJlbHNSZXN1bHQgPSBtYWtlQ2F0ZWdvcnlMYWJlbHNBY3R1YWxseShheGlzLCBheGlzLmdldExhYmVsTW9kZWwoKSk7XG4gICAgdGlja0NhdGVnb3J5SW50ZXJ2YWwgPSBsYWJlbHNSZXN1bHQubGFiZWxDYXRlZ29yeUludGVydmFsO1xuICAgIHRpY2tzID0genJVdGlsLm1hcChsYWJlbHNSZXN1bHQubGFiZWxzLCBmdW5jdGlvbiAobGFiZWxJdGVtKSB7XG4gICAgICByZXR1cm4gbGFiZWxJdGVtLnRpY2tWYWx1ZTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aWNrQ2F0ZWdvcnlJbnRlcnZhbCA9IG9wdGlvblRpY2tJbnRlcnZhbDtcbiAgICB0aWNrcyA9IG1ha2VMYWJlbHNCeU51bWVyaWNDYXRlZ29yeUludGVydmFsKGF4aXMsIHRpY2tDYXRlZ29yeUludGVydmFsLCB0cnVlKTtcbiAgfVxuICAvLyBDYWNoZSB0byBhdm9pZCBjYWxsaW5nIGludGVydmFsIGZ1bmN0aW9uIHJlcGVhdGVkbHkuXG4gIHJldHVybiBsaXN0Q2FjaGVTZXQodGlja3NDYWNoZSwgb3B0aW9uVGlja0ludGVydmFsLCB7XG4gICAgdGlja3M6IHRpY2tzLFxuICAgIHRpY2tDYXRlZ29yeUludGVydmFsOiB0aWNrQ2F0ZWdvcnlJbnRlcnZhbFxuICB9KTtcbn1cbmZ1bmN0aW9uIG1ha2VSZWFsTnVtYmVyTGFiZWxzKGF4aXMpIHtcbiAgdmFyIHRpY2tzID0gYXhpcy5zY2FsZS5nZXRUaWNrcygpO1xuICB2YXIgbGFiZWxGb3JtYXR0ZXIgPSBtYWtlTGFiZWxGb3JtYXR0ZXIoYXhpcyk7XG4gIHJldHVybiB7XG4gICAgbGFiZWxzOiB6clV0aWwubWFwKHRpY2tzLCBmdW5jdGlvbiAodGljaywgaWR4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZXZlbDogdGljay5sZXZlbCxcbiAgICAgICAgZm9ybWF0dGVkTGFiZWw6IGxhYmVsRm9ybWF0dGVyKHRpY2ssIGlkeCksXG4gICAgICAgIHJhd0xhYmVsOiBheGlzLnNjYWxlLmdldExhYmVsKHRpY2spLFxuICAgICAgICB0aWNrVmFsdWU6IHRpY2sudmFsdWVcbiAgICAgIH07XG4gICAgfSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldExpc3RDYWNoZShheGlzLCBwcm9wKSB7XG4gIC8vIEJlY2F1c2Uga2V5IGNhbiBiZSBhIGZ1bmN0aW9uLCBhbmQgY2FjaGUgc2l6ZSBhbHdheXMgaXMgc21hbGwsIHdlIHVzZSBhcnJheSBjYWNoZS5cbiAgcmV0dXJuIGlubmVyKGF4aXMpW3Byb3BdIHx8IChpbm5lcihheGlzKVtwcm9wXSA9IFtdKTtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChjYWNoZSwga2V5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY2FjaGVbaV0ua2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiBjYWNoZVtpXS52YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChjYWNoZSwga2V5LCB2YWx1ZSkge1xuICBjYWNoZS5wdXNoKHtcbiAgICBrZXk6IGtleSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIG1ha2VBdXRvQ2F0ZWdvcnlJbnRlcnZhbChheGlzKSB7XG4gIHZhciByZXN1bHQgPSBpbm5lcihheGlzKS5hdXRvSW50ZXJ2YWw7XG4gIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGlubmVyKGF4aXMpLmF1dG9JbnRlcnZhbCA9IGF4aXMuY2FsY3VsYXRlQ2F0ZWdvcnlJbnRlcnZhbCgpO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZSBpbnRlcnZhbCBmb3IgY2F0ZWdvcnkgYXhpcyB0aWNrcyBhbmQgbGFiZWxzLlxyXG4gKiBUbyBnZXQgcHJlY2lzZSByZXN1bHQsIGF0IGxlYXN0IG9uZSBvZiBgZ2V0Um90YXRlYCBhbmQgYGlzSG9yaXpvbnRhbGBcclxuICogc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIGF4aXMuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUNhdGVnb3J5SW50ZXJ2YWwoYXhpcykge1xuICB2YXIgcGFyYW1zID0gZmV0Y2hBdXRvQ2F0ZWdvcnlJbnRlcnZhbENhbGN1bGF0aW9uUGFyYW1zKGF4aXMpO1xuICB2YXIgbGFiZWxGb3JtYXR0ZXIgPSBtYWtlTGFiZWxGb3JtYXR0ZXIoYXhpcyk7XG4gIHZhciByb3RhdGlvbiA9IChwYXJhbXMuYXhpc1JvdGF0ZSAtIHBhcmFtcy5sYWJlbFJvdGF0ZSkgLyAxODAgKiBNYXRoLlBJO1xuICB2YXIgb3JkaW5hbFNjYWxlID0gYXhpcy5zY2FsZTtcbiAgdmFyIG9yZGluYWxFeHRlbnQgPSBvcmRpbmFsU2NhbGUuZ2V0RXh0ZW50KCk7XG4gIC8vIFByb3ZpZGluZyB0aGlzIG1ldGhvZCBpcyBmb3Igb3B0aW1pemF0aW9uOlxuICAvLyBhdm9pZCBnZW5lcmF0aW5nIGEgbG9uZyBhcnJheSBieSBgZ2V0VGlja3NgXG4gIC8vIGluIGxhcmdlIGNhdGVnb3J5IGRhdGEgY2FzZS5cbiAgdmFyIHRpY2tDb3VudCA9IG9yZGluYWxTY2FsZS5jb3VudCgpO1xuICBpZiAob3JkaW5hbEV4dGVudFsxXSAtIG9yZGluYWxFeHRlbnRbMF0gPCAxKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHN0ZXAgPSAxO1xuICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uLiBFbXBpcmljYWwgdmFsdWU6IHRpY2sgY291bnQgc2hvdWxkIGxlc3MgdGhhbiA0MC5cbiAgaWYgKHRpY2tDb3VudCA+IDQwKSB7XG4gICAgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IodGlja0NvdW50IC8gNDApKTtcbiAgfVxuICB2YXIgdGlja1ZhbHVlID0gb3JkaW5hbEV4dGVudFswXTtcbiAgdmFyIHVuaXRTcGFuID0gYXhpcy5kYXRhVG9Db29yZCh0aWNrVmFsdWUgKyAxKSAtIGF4aXMuZGF0YVRvQ29vcmQodGlja1ZhbHVlKTtcbiAgdmFyIHVuaXRXID0gTWF0aC5hYnModW5pdFNwYW4gKiBNYXRoLmNvcyhyb3RhdGlvbikpO1xuICB2YXIgdW5pdEggPSBNYXRoLmFicyh1bml0U3BhbiAqIE1hdGguc2luKHJvdGF0aW9uKSk7XG4gIHZhciBtYXhXID0gMDtcbiAgdmFyIG1heEggPSAwO1xuICAvLyBDYXV0aW9uOiBQZXJmb3JtYW5jZSBzZW5zaXRpdmUgZm9yIGxhcmdlIGNhdGVnb3J5IGRhdGEuXG4gIC8vIENvbnNpZGVyIGRhdGFab29tLCB3ZSBzaG91bGQgbWFrZSBhcHByb3ByaWF0ZSBzdGVwIHRvIGF2b2lkIE8obikgbG9vcC5cbiAgZm9yICg7IHRpY2tWYWx1ZSA8PSBvcmRpbmFsRXh0ZW50WzFdOyB0aWNrVmFsdWUgKz0gc3RlcCkge1xuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgdmFyIGhlaWdodCA9IDA7XG4gICAgLy8gTm90IHByZWNpc2UsIGRvIG5vdCBjb25zaWRlciBhbGlnbiBhbmQgdmVydGljYWwgYWxpZ25cbiAgICAvLyBhbmQgZWFjaCBkaXN0YW5jZSBmcm9tIGF4aXMgbGluZSB5ZXQuXG4gICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QobGFiZWxGb3JtYXR0ZXIoe1xuICAgICAgdmFsdWU6IHRpY2tWYWx1ZVxuICAgIH0pLCBwYXJhbXMuZm9udCwgJ2NlbnRlcicsICd0b3AnKTtcbiAgICAvLyBNYWdpYyBudW1iZXJcbiAgICB3aWR0aCA9IHJlY3Qud2lkdGggKiAxLjM7XG4gICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKiAxLjM7XG4gICAgLy8gTWluIHNpemUsIHZvaWQgbG9uZyBsb29wLlxuICAgIG1heFcgPSBNYXRoLm1heChtYXhXLCB3aWR0aCwgNyk7XG4gICAgbWF4SCA9IE1hdGgubWF4KG1heEgsIGhlaWdodCwgNyk7XG4gIH1cbiAgdmFyIGR3ID0gbWF4VyAvIHVuaXRXO1xuICB2YXIgZGggPSBtYXhIIC8gdW5pdEg7XG4gIC8vIDAvMCBpcyBOYU4sIDEvMCBpcyBJbmZpbml0eS5cbiAgaXNOYU4oZHcpICYmIChkdyA9IEluZmluaXR5KTtcbiAgaXNOYU4oZGgpICYmIChkaCA9IEluZmluaXR5KTtcbiAgdmFyIGludGVydmFsID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihNYXRoLm1pbihkdywgZGgpKSk7XG4gIHZhciBjYWNoZSA9IGlubmVyKGF4aXMubW9kZWwpO1xuICB2YXIgYXhpc0V4dGVudCA9IGF4aXMuZ2V0RXh0ZW50KCk7XG4gIHZhciBsYXN0QXV0b0ludGVydmFsID0gY2FjaGUubGFzdEF1dG9JbnRlcnZhbDtcbiAgdmFyIGxhc3RUaWNrQ291bnQgPSBjYWNoZS5sYXN0VGlja0NvdW50O1xuICAvLyBVc2UgY2FjaGUgdG8ga2VlcCBpbnRlcnZhbCBzdGFibGUgd2hpbGUgbW92aW5nIHpvb20gd2luZG93LFxuICAvLyBvdGhlcndpc2UgdGhlIGNhbGN1bGF0ZWQgaW50ZXJ2YWwgbWlnaHQgaml0dGVyIHdoZW4gdGhlIHpvb21cbiAgLy8gd2luZG93IHNpemUgaXMgY2xvc2UgdG8gdGhlIGludGVydmFsLWNoYW5naW5nIHNpemUuXG4gIC8vIEZvciBleGFtcGxlLCBpZiBhbGwgb2YgdGhlIGF4aXMgbGFiZWxzIGFyZSBgYSwgYiwgYywgZCwgZSwgZiwgZ2AuXG4gIC8vIFRoZSBqaXR0ZXIgd2lsbCBjYXVzZSB0aGF0IHNvbWV0aW1lcyB0aGUgZGlzcGxheWVkIGxhYmVscyBhcmVcbiAgLy8gYGEsIGQsIGdgIChpbnRlcnZhbDogMikgc29tZXRpbWVzIGBhLCBjLCBlYChpbnRlcnZhbDogMSkuXG4gIGlmIChsYXN0QXV0b0ludGVydmFsICE9IG51bGwgJiYgbGFzdFRpY2tDb3VudCAhPSBudWxsICYmIE1hdGguYWJzKGxhc3RBdXRvSW50ZXJ2YWwgLSBpbnRlcnZhbCkgPD0gMSAmJiBNYXRoLmFicyhsYXN0VGlja0NvdW50IC0gdGlja0NvdW50KSA8PSAxXG4gIC8vIEFsd2F5cyBjaG9vc2UgdGhlIGJpZ2dlciBvbmUsIG90aGVyd2lzZSB0aGUgY3JpdGljYWxcbiAgLy8gcG9pbnQgaXMgbm90IHRoZSBzYW1lIHdoZW4gem9vbWluZyBpbiBvciB6b29taW5nIG91dC5cbiAgJiYgbGFzdEF1dG9JbnRlcnZhbCA+IGludGVydmFsXG4gIC8vIElmIHRoZSBheGlzIGNoYW5nZSBpcyBjYXVzZWQgYnkgY2hhcnQgcmVzaXplLCB0aGUgY2FjaGUgc2hvdWxkIG5vdFxuICAvLyBiZSB1c2VkLiBPdGhlcndpc2Ugc29tZSBoaWRkZW4gbGFiZWxzIG1pZ2h0IG5vdCBiZSBzaG93biBhZ2Fpbi5cbiAgJiYgY2FjaGUuYXhpc0V4dGVudDAgPT09IGF4aXNFeHRlbnRbMF0gJiYgY2FjaGUuYXhpc0V4dGVudDEgPT09IGF4aXNFeHRlbnRbMV0pIHtcbiAgICBpbnRlcnZhbCA9IGxhc3RBdXRvSW50ZXJ2YWw7XG4gIH1cbiAgLy8gT25seSB1cGRhdGUgY2FjaGUgaWYgY2FjaGUgbm90IHVzZWQsIG90aGVyd2lzZSB0aGVcbiAgLy8gY2hhbmdpbmcgb2YgaW50ZXJ2YWwgaXMgdG9vIGluc2Vuc2l0aXZlLlxuICBlbHNlIHtcbiAgICBjYWNoZS5sYXN0VGlja0NvdW50ID0gdGlja0NvdW50O1xuICAgIGNhY2hlLmxhc3RBdXRvSW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICBjYWNoZS5heGlzRXh0ZW50MCA9IGF4aXNFeHRlbnRbMF07XG4gICAgY2FjaGUuYXhpc0V4dGVudDEgPSBheGlzRXh0ZW50WzFdO1xuICB9XG4gIHJldHVybiBpbnRlcnZhbDtcbn1cbmZ1bmN0aW9uIGZldGNoQXV0b0NhdGVnb3J5SW50ZXJ2YWxDYWxjdWxhdGlvblBhcmFtcyhheGlzKSB7XG4gIHZhciBsYWJlbE1vZGVsID0gYXhpcy5nZXRMYWJlbE1vZGVsKCk7XG4gIHJldHVybiB7XG4gICAgYXhpc1JvdGF0ZTogYXhpcy5nZXRSb3RhdGUgPyBheGlzLmdldFJvdGF0ZSgpIDogYXhpcy5pc0hvcml6b250YWwgJiYgIWF4aXMuaXNIb3Jpem9udGFsKCkgPyA5MCA6IDAsXG4gICAgbGFiZWxSb3RhdGU6IGxhYmVsTW9kZWwuZ2V0KCdyb3RhdGUnKSB8fCAwLFxuICAgIGZvbnQ6IGxhYmVsTW9kZWwuZ2V0Rm9udCgpXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlTGFiZWxzQnlOdW1lcmljQ2F0ZWdvcnlJbnRlcnZhbChheGlzLCBjYXRlZ29yeUludGVydmFsLCBvbmx5VGljaykge1xuICB2YXIgbGFiZWxGb3JtYXR0ZXIgPSBtYWtlTGFiZWxGb3JtYXR0ZXIoYXhpcyk7XG4gIHZhciBvcmRpbmFsU2NhbGUgPSBheGlzLnNjYWxlO1xuICB2YXIgb3JkaW5hbEV4dGVudCA9IG9yZGluYWxTY2FsZS5nZXRFeHRlbnQoKTtcbiAgdmFyIGxhYmVsTW9kZWwgPSBheGlzLmdldExhYmVsTW9kZWwoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAvLyBUT0RPOiBheGlzVHlwZTogb3JkaW5hbFRpbWUsIHBpY2sgdGhlIHRpY2sgZnJvbSBlYWNoIG1vbnRoL2RheS95ZWFyLy4uLlxuICB2YXIgc3RlcCA9IE1hdGgubWF4KChjYXRlZ29yeUludGVydmFsIHx8IDApICsgMSwgMSk7XG4gIHZhciBzdGFydFRpY2sgPSBvcmRpbmFsRXh0ZW50WzBdO1xuICB2YXIgdGlja0NvdW50ID0gb3JkaW5hbFNjYWxlLmNvdW50KCk7XG4gIC8vIENhbGN1bGF0ZSBzdGFydCB0aWNrIGJhc2VkIG9uIHplcm8gaWYgcG9zc2libGUgdG8ga2VlcCBsYWJlbCBjb25zaXN0ZW50XG4gIC8vIHdoaWxlIHpvb21pbmcgYW5kIG1vdmluZyB3aGlsZSBpbnRlcnZhbCA+IDAuIE90aGVyd2lzZSB0aGUgc2VsZWN0aW9uXG4gIC8vIG9mIGRpc3BsYXlhYmxlIHRpY2tzIGFuZCBzeW1ib2xzIHByb2JhYmx5IGtlZXAgY2hhbmdpbmcuXG4gIC8vIDMgaXMgZW1waXJpY2FsIHZhbHVlLlxuICBpZiAoc3RhcnRUaWNrICE9PSAwICYmIHN0ZXAgPiAxICYmIHRpY2tDb3VudCAvIHN0ZXAgPiAyKSB7XG4gICAgc3RhcnRUaWNrID0gTWF0aC5yb3VuZChNYXRoLmNlaWwoc3RhcnRUaWNrIC8gc3RlcCkgKiBzdGVwKTtcbiAgfVxuICAvLyAoMSkgT25seSBhZGQgbWluIG1heCBsYWJlbCBoZXJlIGJ1dCBsZWF2ZSBvdmVybGFwIGNoZWNraW5nXG4gIC8vIHRvIHJlbmRlciBzdGFnZSwgd2hpY2ggYWxzbyBlbnN1cmUgdGhlIHJldHVybmVkIGxpc3RcbiAgLy8gc3VpdGFibGUgZm9yIHNwbGl0TGluZSBhbmQgc3BsaXRBcmVhIHJlbmRlcmluZy5cbiAgLy8gKDIpIFNjYWxlcyBleGNlcHQgY2F0ZWdvcnkgYWx3YXlzIGNvbnRhaW4gbWluIG1heCBsYWJlbCBzb1xuICAvLyBkbyBub3QgbmVlZCB0byBwZXJmb3JtIHRoaXMgcHJvY2Vzcy5cbiAgdmFyIHNob3dBbGxMYWJlbCA9IHNob3VsZFNob3dBbGxMYWJlbHMoYXhpcyk7XG4gIHZhciBpbmNsdWRlTWluTGFiZWwgPSBsYWJlbE1vZGVsLmdldCgnc2hvd01pbkxhYmVsJykgfHwgc2hvd0FsbExhYmVsO1xuICB2YXIgaW5jbHVkZU1heExhYmVsID0gbGFiZWxNb2RlbC5nZXQoJ3Nob3dNYXhMYWJlbCcpIHx8IHNob3dBbGxMYWJlbDtcbiAgaWYgKGluY2x1ZGVNaW5MYWJlbCAmJiBzdGFydFRpY2sgIT09IG9yZGluYWxFeHRlbnRbMF0pIHtcbiAgICBhZGRJdGVtKG9yZGluYWxFeHRlbnRbMF0pO1xuICB9XG4gIC8vIE9wdGltaXplOiBhdm9pZCBnZW5lcmF0aW5nIGxhcmdlIGFycmF5IGJ5IGBvcmRpbmFsU2NhbGUuZ2V0VGlja3MoKWAuXG4gIHZhciB0aWNrVmFsdWUgPSBzdGFydFRpY2s7XG4gIGZvciAoOyB0aWNrVmFsdWUgPD0gb3JkaW5hbEV4dGVudFsxXTsgdGlja1ZhbHVlICs9IHN0ZXApIHtcbiAgICBhZGRJdGVtKHRpY2tWYWx1ZSk7XG4gIH1cbiAgaWYgKGluY2x1ZGVNYXhMYWJlbCAmJiB0aWNrVmFsdWUgLSBzdGVwICE9PSBvcmRpbmFsRXh0ZW50WzFdKSB7XG4gICAgYWRkSXRlbShvcmRpbmFsRXh0ZW50WzFdKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRJdGVtKHRpY2tWYWx1ZSkge1xuICAgIHZhciB0aWNrT2JqID0ge1xuICAgICAgdmFsdWU6IHRpY2tWYWx1ZVxuICAgIH07XG4gICAgcmVzdWx0LnB1c2gob25seVRpY2sgPyB0aWNrVmFsdWUgOiB7XG4gICAgICBmb3JtYXR0ZWRMYWJlbDogbGFiZWxGb3JtYXR0ZXIodGlja09iaiksXG4gICAgICByYXdMYWJlbDogb3JkaW5hbFNjYWxlLmdldExhYmVsKHRpY2tPYmopLFxuICAgICAgdGlja1ZhbHVlOiB0aWNrVmFsdWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFrZUxhYmVsc0J5Q3VzdG9taXplZENhdGVnb3J5SW50ZXJ2YWwoYXhpcywgY2F0ZWdvcnlJbnRlcnZhbCwgb25seVRpY2spIHtcbiAgdmFyIG9yZGluYWxTY2FsZSA9IGF4aXMuc2NhbGU7XG4gIHZhciBsYWJlbEZvcm1hdHRlciA9IG1ha2VMYWJlbEZvcm1hdHRlcihheGlzKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB6clV0aWwuZWFjaChvcmRpbmFsU2NhbGUuZ2V0VGlja3MoKSwgZnVuY3Rpb24gKHRpY2spIHtcbiAgICB2YXIgcmF3TGFiZWwgPSBvcmRpbmFsU2NhbGUuZ2V0TGFiZWwodGljayk7XG4gICAgdmFyIHRpY2tWYWx1ZSA9IHRpY2sudmFsdWU7XG4gICAgaWYgKGNhdGVnb3J5SW50ZXJ2YWwodGljay52YWx1ZSwgcmF3TGFiZWwpKSB7XG4gICAgICByZXN1bHQucHVzaChvbmx5VGljayA/IHRpY2tWYWx1ZSA6IHtcbiAgICAgICAgZm9ybWF0dGVkTGFiZWw6IGxhYmVsRm9ybWF0dGVyKHRpY2spLFxuICAgICAgICByYXdMYWJlbDogcmF3TGFiZWwsXG4gICAgICAgIHRpY2tWYWx1ZTogdGlja1ZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8287\n")},12462:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   L: () => (/* binding */ AxisModelCommonMixin)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nvar AxisModelCommonMixin = /** @class */function () {\n  function AxisModelCommonMixin() {}\n  AxisModelCommonMixin.prototype.getNeedCrossZero = function () {\n    var option = this.option;\n    return !option.scale;\n  };\n  /**\r\n   * Should be implemented by each axis model if necessary.\r\n   * @return coordinate system model\r\n   */\n  AxisModelCommonMixin.prototype.getCoordSysModel = function () {\n    return;\n  };\n  return AxisModelCommonMixin;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0NjIuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9heGlzTW9kZWxDb21tb25NaXhpbi5qcz85ZTBiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xudmFyIEF4aXNNb2RlbENvbW1vbk1peGluID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXhpc01vZGVsQ29tbW9uTWl4aW4oKSB7fVxuICBBeGlzTW9kZWxDb21tb25NaXhpbi5wcm90b3R5cGUuZ2V0TmVlZENyb3NzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgcmV0dXJuICFvcHRpb24uc2NhbGU7XG4gIH07XG4gIC8qKlxyXG4gICAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIGF4aXMgbW9kZWwgaWYgbmVjZXNzYXJ5LlxyXG4gICAqIEByZXR1cm4gY29vcmRpbmF0ZSBzeXN0ZW0gbW9kZWxcclxuICAgKi9cbiAgQXhpc01vZGVsQ29tbW9uTWl4aW4ucHJvdG90eXBlLmdldENvb3JkU3lzTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuO1xuICB9O1xuICByZXR1cm4gQXhpc01vZGVsQ29tbW9uTWl4aW47XG59KCk7XG5leHBvcnQgeyBBeGlzTW9kZWxDb21tb25NaXhpbiB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12462\n')},13286:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar defaultOption = {\n  show: true,\n  // zlevel: 0,\n  z: 0,\n  // Inverse the axis.\n  inverse: false,\n  // Axis name displayed.\n  name: '',\n  // 'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // By degree. By default auto rotate by nameLocation.\n  nameRotate: null,\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // Use global text style by default.\n  nameTextStyle: {},\n  // The gap between axisName and axisLine.\n  nameGap: 15,\n  // Default `false` to support tooltip.\n  silent: false,\n  // Default `false` to avoid legacy user event listener fail.\n  triggerEvent: false,\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  axisLine: {\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    lineStyle: {\n      color: '#6E7079',\n      width: 1,\n      type: 'solid'\n    },\n    // The arrow at both ends the the axis.\n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  axisTick: {\n    show: true,\n    // Whether axisTick is inside the grid or outside the grid.\n    inside: false,\n    // The length of axisTick.\n    length: 5,\n    lineStyle: {\n      width: 1\n    }\n  },\n  axisLabel: {\n    show: true,\n    // Whether axisLabel is inside the grid or outside the grid.\n    inside: false,\n    rotate: 0,\n    // true | false | null/undefined (auto)\n    showMinLabel: null,\n    // true | false | null/undefined (auto)\n    showMaxLabel: null,\n    margin: 8,\n    // formatter: null,\n    fontSize: 12\n  },\n  splitLine: {\n    show: true,\n    showMinLine: true,\n    showMaxLine: true,\n    lineStyle: {\n      color: ['#E0E6F1'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  splitArea: {\n    show: false,\n    areaStyle: {\n      color: ['rgba(250,250,250,0.2)', 'rgba(210,219,238,0.2)']\n    }\n  }\n};\nvar categoryAxis = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.merge({\n  // The gap at both ends of the axis. For categoryAxis, boolean.\n  boundaryGap: true,\n  // Set false to faster category collection.\n  deduplication: null,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\nvar valueAxis = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.merge({\n  boundaryGap: [0, 0],\n  axisLine: {\n    // Not shown when other axis is categoryAxis in cartesian\n    show: 'auto'\n  },\n  axisTick: {\n    // Not shown when other axis is categoryAxis in cartesian\n    show: 'auto'\n  },\n  // TODO\n  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]\n  splitNumber: 5,\n  minorTick: {\n    // Minor tick, not available for cateogry axis.\n    show: false,\n    // Split number of minor ticks. The value should be in range of (0, 100)\n    splitNumber: 5,\n    // Length of minor tick\n    length: 3,\n    // Line style\n    lineStyle: {\n      // Default to be same with axisTick\n    }\n  },\n  minorSplitLine: {\n    show: false,\n    lineStyle: {\n      color: '#F4F7FD',\n      width: 1\n    }\n  }\n}, defaultOption);\nvar timeAxis = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.merge({\n  splitNumber: 6,\n  axisLabel: {\n    // To eliminate labels that are not nice\n    showMinLabel: false,\n    showMaxLabel: false,\n    rich: {\n      primary: {\n        fontWeight: 'bold'\n      }\n    }\n  },\n  splitLine: {\n    show: false\n  }\n}, valueAxis);\nvar logAxis = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.defaults({\n  logBase: 10\n}, valueAxis);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  category: categoryAxis,\n  value: valueAxis,\n  time: timeAxis,\n  log: logAxis\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMyODYuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9heGlzRGVmYXVsdC5qcz82OGMwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG52YXIgZGVmYXVsdE9wdGlvbiA9IHtcbiAgc2hvdzogdHJ1ZSxcbiAgLy8gemxldmVsOiAwLFxuICB6OiAwLFxuICAvLyBJbnZlcnNlIHRoZSBheGlzLlxuICBpbnZlcnNlOiBmYWxzZSxcbiAgLy8gQXhpcyBuYW1lIGRpc3BsYXllZC5cbiAgbmFtZTogJycsXG4gIC8vICdzdGFydCcgfCAnbWlkZGxlJyB8ICdlbmQnXG4gIG5hbWVMb2NhdGlvbjogJ2VuZCcsXG4gIC8vIEJ5IGRlZ3JlZS4gQnkgZGVmYXVsdCBhdXRvIHJvdGF0ZSBieSBuYW1lTG9jYXRpb24uXG4gIG5hbWVSb3RhdGU6IG51bGwsXG4gIG5hbWVUcnVuY2F0ZToge1xuICAgIG1heFdpZHRoOiBudWxsLFxuICAgIGVsbGlwc2lzOiAnLi4uJyxcbiAgICBwbGFjZWhvbGRlcjogJy4nXG4gIH0sXG4gIC8vIFVzZSBnbG9iYWwgdGV4dCBzdHlsZSBieSBkZWZhdWx0LlxuICBuYW1lVGV4dFN0eWxlOiB7fSxcbiAgLy8gVGhlIGdhcCBiZXR3ZWVuIGF4aXNOYW1lIGFuZCBheGlzTGluZS5cbiAgbmFtZUdhcDogMTUsXG4gIC8vIERlZmF1bHQgYGZhbHNlYCB0byBzdXBwb3J0IHRvb2x0aXAuXG4gIHNpbGVudDogZmFsc2UsXG4gIC8vIERlZmF1bHQgYGZhbHNlYCB0byBhdm9pZCBsZWdhY3kgdXNlciBldmVudCBsaXN0ZW5lciBmYWlsLlxuICB0cmlnZ2VyRXZlbnQ6IGZhbHNlLFxuICB0b29sdGlwOiB7XG4gICAgc2hvdzogZmFsc2VcbiAgfSxcbiAgYXhpc1BvaW50ZXI6IHt9LFxuICBheGlzTGluZToge1xuICAgIHNob3c6IHRydWUsXG4gICAgb25aZXJvOiB0cnVlLFxuICAgIG9uWmVyb0F4aXNJbmRleDogbnVsbCxcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnIzZFNzA3OScsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICB9LFxuICAgIC8vIFRoZSBhcnJvdyBhdCBib3RoIGVuZHMgdGhlIHRoZSBheGlzLlxuICAgIHN5bWJvbDogWydub25lJywgJ25vbmUnXSxcbiAgICBzeW1ib2xTaXplOiBbMTAsIDE1XVxuICB9LFxuICBheGlzVGljazoge1xuICAgIHNob3c6IHRydWUsXG4gICAgLy8gV2hldGhlciBheGlzVGljayBpcyBpbnNpZGUgdGhlIGdyaWQgb3Igb3V0c2lkZSB0aGUgZ3JpZC5cbiAgICBpbnNpZGU6IGZhbHNlLFxuICAgIC8vIFRoZSBsZW5ndGggb2YgYXhpc1RpY2suXG4gICAgbGVuZ3RoOiA1LFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgd2lkdGg6IDFcbiAgICB9XG4gIH0sXG4gIGF4aXNMYWJlbDoge1xuICAgIHNob3c6IHRydWUsXG4gICAgLy8gV2hldGhlciBheGlzTGFiZWwgaXMgaW5zaWRlIHRoZSBncmlkIG9yIG91dHNpZGUgdGhlIGdyaWQuXG4gICAgaW5zaWRlOiBmYWxzZSxcbiAgICByb3RhdGU6IDAsXG4gICAgLy8gdHJ1ZSB8IGZhbHNlIHwgbnVsbC91bmRlZmluZWQgKGF1dG8pXG4gICAgc2hvd01pbkxhYmVsOiBudWxsLFxuICAgIC8vIHRydWUgfCBmYWxzZSB8IG51bGwvdW5kZWZpbmVkIChhdXRvKVxuICAgIHNob3dNYXhMYWJlbDogbnVsbCxcbiAgICBtYXJnaW46IDgsXG4gICAgLy8gZm9ybWF0dGVyOiBudWxsLFxuICAgIGZvbnRTaXplOiAxMlxuICB9LFxuICBzcGxpdExpbmU6IHtcbiAgICBzaG93OiB0cnVlLFxuICAgIHNob3dNaW5MaW5lOiB0cnVlLFxuICAgIHNob3dNYXhMaW5lOiB0cnVlLFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgY29sb3I6IFsnI0UwRTZGMSddLFxuICAgICAgd2lkdGg6IDEsXG4gICAgICB0eXBlOiAnc29saWQnXG4gICAgfVxuICB9LFxuICBzcGxpdEFyZWE6IHtcbiAgICBzaG93OiBmYWxzZSxcbiAgICBhcmVhU3R5bGU6IHtcbiAgICAgIGNvbG9yOiBbJ3JnYmEoMjUwLDI1MCwyNTAsMC4yKScsICdyZ2JhKDIxMCwyMTksMjM4LDAuMiknXVxuICAgIH1cbiAgfVxufTtcbnZhciBjYXRlZ29yeUF4aXMgPSB6clV0aWwubWVyZ2Uoe1xuICAvLyBUaGUgZ2FwIGF0IGJvdGggZW5kcyBvZiB0aGUgYXhpcy4gRm9yIGNhdGVnb3J5QXhpcywgYm9vbGVhbi5cbiAgYm91bmRhcnlHYXA6IHRydWUsXG4gIC8vIFNldCBmYWxzZSB0byBmYXN0ZXIgY2F0ZWdvcnkgY29sbGVjdGlvbi5cbiAgZGVkdXBsaWNhdGlvbjogbnVsbCxcbiAgLy8gc3BsaXRBcmVhOiB7XG4gIC8vIHNob3c6IGZhbHNlXG4gIC8vIH0sXG4gIHNwbGl0TGluZToge1xuICAgIHNob3c6IGZhbHNlXG4gIH0sXG4gIGF4aXNUaWNrOiB7XG4gICAgLy8gSWYgdGljayBpcyBhbGlnbiB3aXRoIGxhYmVsIHdoZW4gYm91bmRhcnlHYXAgaXMgdHJ1ZVxuICAgIGFsaWduV2l0aExhYmVsOiBmYWxzZSxcbiAgICBpbnRlcnZhbDogJ2F1dG8nXG4gIH0sXG4gIGF4aXNMYWJlbDoge1xuICAgIGludGVydmFsOiAnYXV0bydcbiAgfVxufSwgZGVmYXVsdE9wdGlvbik7XG52YXIgdmFsdWVBeGlzID0genJVdGlsLm1lcmdlKHtcbiAgYm91bmRhcnlHYXA6IFswLCAwXSxcbiAgYXhpc0xpbmU6IHtcbiAgICAvLyBOb3Qgc2hvd24gd2hlbiBvdGhlciBheGlzIGlzIGNhdGVnb3J5QXhpcyBpbiBjYXJ0ZXNpYW5cbiAgICBzaG93OiAnYXV0bydcbiAgfSxcbiAgYXhpc1RpY2s6IHtcbiAgICAvLyBOb3Qgc2hvd24gd2hlbiBvdGhlciBheGlzIGlzIGNhdGVnb3J5QXhpcyBpbiBjYXJ0ZXNpYW5cbiAgICBzaG93OiAnYXV0bydcbiAgfSxcbiAgLy8gVE9ET1xuICAvLyBtaW4vbWF4OiBbMzAsIGRhdGFtaW4sIDYwXSBvciBbMjAsIGRhdGFtaW5dIG9yIFtkYXRhbWluLCA2MF1cbiAgc3BsaXROdW1iZXI6IDUsXG4gIG1pbm9yVGljazoge1xuICAgIC8vIE1pbm9yIHRpY2ssIG5vdCBhdmFpbGFibGUgZm9yIGNhdGVvZ3J5IGF4aXMuXG4gICAgc2hvdzogZmFsc2UsXG4gICAgLy8gU3BsaXQgbnVtYmVyIG9mIG1pbm9yIHRpY2tzLiBUaGUgdmFsdWUgc2hvdWxkIGJlIGluIHJhbmdlIG9mICgwLCAxMDApXG4gICAgc3BsaXROdW1iZXI6IDUsXG4gICAgLy8gTGVuZ3RoIG9mIG1pbm9yIHRpY2tcbiAgICBsZW5ndGg6IDMsXG4gICAgLy8gTGluZSBzdHlsZVxuICAgIGxpbmVTdHlsZToge1xuICAgICAgLy8gRGVmYXVsdCB0byBiZSBzYW1lIHdpdGggYXhpc1RpY2tcbiAgICB9XG4gIH0sXG4gIG1pbm9yU3BsaXRMaW5lOiB7XG4gICAgc2hvdzogZmFsc2UsXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNGNEY3RkQnLFxuICAgICAgd2lkdGg6IDFcbiAgICB9XG4gIH1cbn0sIGRlZmF1bHRPcHRpb24pO1xudmFyIHRpbWVBeGlzID0genJVdGlsLm1lcmdlKHtcbiAgc3BsaXROdW1iZXI6IDYsXG4gIGF4aXNMYWJlbDoge1xuICAgIC8vIFRvIGVsaW1pbmF0ZSBsYWJlbHMgdGhhdCBhcmUgbm90IG5pY2VcbiAgICBzaG93TWluTGFiZWw6IGZhbHNlLFxuICAgIHNob3dNYXhMYWJlbDogZmFsc2UsXG4gICAgcmljaDoge1xuICAgICAgcHJpbWFyeToge1xuICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCdcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNwbGl0TGluZToge1xuICAgIHNob3c6IGZhbHNlXG4gIH1cbn0sIHZhbHVlQXhpcyk7XG52YXIgbG9nQXhpcyA9IHpyVXRpbC5kZWZhdWx0cyh7XG4gIGxvZ0Jhc2U6IDEwXG59LCB2YWx1ZUF4aXMpO1xuZXhwb3J0IGRlZmF1bHQge1xuICBjYXRlZ29yeTogY2F0ZWdvcnlBeGlzLFxuICB2YWx1ZTogdmFsdWVBeGlzLFxuICB0aW1lOiB0aW1lQXhpcyxcbiAgbG9nOiBsb2dBeGlzXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13286\n")},23509:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _util_layout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(34253);\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24326);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n// (24*60*60*1000)\nvar PROXIMATE_ONE_DAY = 86400000;\nvar Calendar = /** @class */function () {\n  function Calendar(calendarModel, ecModel, api) {\n    this.type = 'calendar';\n    this.dimensions = Calendar.dimensions;\n    // Required in createListFromData\n    this.getDimensionsInfo = Calendar.getDimensionsInfo;\n    this._model = calendarModel;\n  }\n  Calendar.getDimensionsInfo = function () {\n    return [{\n      name: 'time',\n      type: 'time'\n    }, 'value'];\n  };\n  Calendar.prototype.getRangeInfo = function () {\n    return this._rangeInfo;\n  };\n  Calendar.prototype.getModel = function () {\n    return this._model;\n  };\n  Calendar.prototype.getRect = function () {\n    return this._rect;\n  };\n  Calendar.prototype.getCellWidth = function () {\n    return this._sw;\n  };\n  Calendar.prototype.getCellHeight = function () {\n    return this._sh;\n  };\n  Calendar.prototype.getOrient = function () {\n    return this._orient;\n  };\n  /**\r\n   * getFirstDayOfWeek\r\n   *\r\n   * @example\r\n   *     0 : start at Sunday\r\n   *     1 : start at Monday\r\n   *\r\n   * @return {number}\r\n   */\n  Calendar.prototype.getFirstDayOfWeek = function () {\n    return this._firstDayOfWeek;\n  };\n  /**\r\n   * get date info\r\n   * }\r\n   */\n  Calendar.prototype.getDateInfo = function (date) {\n    date = _util_number_js__WEBPACK_IMPORTED_MODULE_0__/* .parseDate */ ._U(date);\n    var y = date.getFullYear();\n    var m = date.getMonth() + 1;\n    var mStr = m < 10 ? '0' + m : '' + m;\n    var d = date.getDate();\n    var dStr = d < 10 ? '0' + d : '' + d;\n    var day = date.getDay();\n    day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);\n    return {\n      y: y + '',\n      m: mStr,\n      d: dStr,\n      day: day,\n      time: date.getTime(),\n      formatedDate: y + '-' + mStr + '-' + dStr,\n      date: date\n    };\n  };\n  Calendar.prototype.getNextNDay = function (date, n) {\n    n = n || 0;\n    if (n === 0) {\n      return this.getDateInfo(date);\n    }\n    date = new Date(this.getDateInfo(date).time);\n    date.setDate(date.getDate() + n);\n    return this.getDateInfo(date);\n  };\n  Calendar.prototype.update = function (ecModel, api) {\n    this._firstDayOfWeek = +this._model.getModel('dayLabel').get('firstDay');\n    this._orient = this._model.get('orient');\n    this._lineWidth = this._model.getModel('itemStyle').getItemStyle().lineWidth || 0;\n    this._rangeInfo = this._getRangeInfo(this._initRangeOption());\n    var weeks = this._rangeInfo.weeks || 1;\n    var whNames = ['width', 'height'];\n    var cellSize = this._model.getCellSize().slice();\n    var layoutParams = this._model.getBoxLayoutParams();\n    var cellNumbers = this._orient === 'horizontal' ? [weeks, 7] : [7, weeks];\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each([0, 1], function (idx) {\n      if (cellSizeSpecified(cellSize, idx)) {\n        layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];\n      }\n    });\n    var whGlobal = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var calendarRect = this._rect = _util_layout_js__WEBPACK_IMPORTED_MODULE_2__/* .getLayoutRect */ .dV(layoutParams, whGlobal);\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each([0, 1], function (idx) {\n      if (!cellSizeSpecified(cellSize, idx)) {\n        cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];\n      }\n    });\n    function cellSizeSpecified(cellSize, idx) {\n      return cellSize[idx] != null && cellSize[idx] !== 'auto';\n    }\n    // Has been calculated out number.\n    this._sw = cellSize[0];\n    this._sh = cellSize[1];\n  };\n  /**\r\n   * Convert a time data(time, value) item to (x, y) point.\r\n   */\n  // TODO Clamp of calendar is not same with cartesian coordinate systems.\n  // It will return NaN if data exceeds.\n  Calendar.prototype.dataToPoint = function (data, clamp) {\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray(data) && (data = data[0]);\n    clamp == null && (clamp = true);\n    var dayInfo = this.getDateInfo(data);\n    var range = this._rangeInfo;\n    var date = dayInfo.formatedDate;\n    // if not in range return [NaN, NaN]\n    if (clamp && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {\n      return [NaN, NaN];\n    }\n    var week = dayInfo.day;\n    var nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;\n    if (this._orient === 'vertical') {\n      return [this._rect.x + week * this._sw + this._sw / 2, this._rect.y + nthWeek * this._sh + this._sh / 2];\n    }\n    return [this._rect.x + nthWeek * this._sw + this._sw / 2, this._rect.y + week * this._sh + this._sh / 2];\n  };\n  /**\r\n   * Convert a (x, y) point to time data\r\n   */\n  Calendar.prototype.pointToData = function (point) {\n    var date = this.pointToDate(point);\n    return date && date.time;\n  };\n  /**\r\n   * Convert a time date item to (x, y) four point.\r\n   */\n  Calendar.prototype.dataToRect = function (data, clamp) {\n    var point = this.dataToPoint(data, clamp);\n    return {\n      contentShape: {\n        x: point[0] - (this._sw - this._lineWidth) / 2,\n        y: point[1] - (this._sh - this._lineWidth) / 2,\n        width: this._sw - this._lineWidth,\n        height: this._sh - this._lineWidth\n      },\n      center: point,\n      tl: [point[0] - this._sw / 2, point[1] - this._sh / 2],\n      tr: [point[0] + this._sw / 2, point[1] - this._sh / 2],\n      br: [point[0] + this._sw / 2, point[1] + this._sh / 2],\n      bl: [point[0] - this._sw / 2, point[1] + this._sh / 2]\n    };\n  };\n  /**\r\n   * Convert a (x, y) point to time date\r\n   *\r\n   * @param  {Array} point point\r\n   * @return {Object}       date\r\n   */\n  Calendar.prototype.pointToDate = function (point) {\n    var nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;\n    var nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;\n    var range = this._rangeInfo.range;\n    if (this._orient === 'vertical') {\n      return this._getDateByWeeksAndDay(nthY, nthX - 1, range);\n    }\n    return this._getDateByWeeksAndDay(nthX, nthY - 1, range);\n  };\n  Calendar.prototype.convertToPixel = function (ecModel, finder, value) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.dataToPoint(value) : null;\n  };\n  Calendar.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.pointToData(pixel) : null;\n  };\n  Calendar.prototype.containPoint = function (point) {\n    console.warn('Not implemented.');\n    return false;\n  };\n  /**\r\n   * initRange\r\n   * Normalize to an [start, end] array\r\n   */\n  Calendar.prototype._initRangeOption = function () {\n    var range = this._model.get('range');\n    var normalizedRange;\n    // Convert [1990] to 1990\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray(range) && range.length === 1) {\n      range = range[0];\n    }\n    if (!zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray(range)) {\n      var rangeStr = range.toString();\n      // One year.\n      if (/^\\d{4}$/.test(rangeStr)) {\n        normalizedRange = [rangeStr + '-01-01', rangeStr + '-12-31'];\n      }\n      // One month\n      if (/^\\d{4}[\\/|-]\\d{1,2}$/.test(rangeStr)) {\n        var start = this.getDateInfo(rangeStr);\n        var firstDay = start.date;\n        firstDay.setMonth(firstDay.getMonth() + 1);\n        var end = this.getNextNDay(firstDay, -1);\n        normalizedRange = [start.formatedDate, end.formatedDate];\n      }\n      // One day\n      if (/^\\d{4}[\\/|-]\\d{1,2}[\\/|-]\\d{1,2}$/.test(rangeStr)) {\n        normalizedRange = [rangeStr, rangeStr];\n      }\n    } else {\n      normalizedRange = range;\n    }\n    if (!normalizedRange) {\n      if (false) {}\n      // Not handling it.\n      return range;\n    }\n    var tmp = this._getRangeInfo(normalizedRange);\n    if (tmp.start.time > tmp.end.time) {\n      normalizedRange.reverse();\n    }\n    return normalizedRange;\n  };\n  /**\r\n   * range info\r\n   *\r\n   * @private\r\n   * @param  {Array} range range ['2017-01-01', '2017-07-08']\r\n   *  If range[0] > range[1], they will not be reversed.\r\n   * @return {Object}       obj\r\n   */\n  Calendar.prototype._getRangeInfo = function (range) {\n    var parsedRange = [this.getDateInfo(range[0]), this.getDateInfo(range[1])];\n    var reversed;\n    if (parsedRange[0].time > parsedRange[1].time) {\n      reversed = true;\n      parsedRange.reverse();\n    }\n    var allDay = Math.floor(parsedRange[1].time / PROXIMATE_ONE_DAY) - Math.floor(parsedRange[0].time / PROXIMATE_ONE_DAY) + 1;\n    // Consider case1 (#11677 #10430):\n    // Set the system timezone as \"UK\", set the range to `['2016-07-01', '2016-12-31']`\n    // Consider case2:\n    // Firstly set system timezone as \"Time Zone: America/Toronto\",\n    // ```\n    // let first = new Date(1478412000000 - 3600 * 1000 * 2.5);\n    // let second = new Date(1478412000000);\n    // let allDays = Math.floor(second / ONE_DAY) - Math.floor(first / ONE_DAY) + 1;\n    // ```\n    // will get wrong result because of DST. So we should fix it.\n    var date = new Date(parsedRange[0].time);\n    var startDateNum = date.getDate();\n    var endDateNum = parsedRange[1].date.getDate();\n    date.setDate(startDateNum + allDay - 1);\n    // The bias can not over a month, so just compare date.\n    var dateNum = date.getDate();\n    if (dateNum !== endDateNum) {\n      var sign = date.getTime() - parsedRange[1].time > 0 ? 1 : -1;\n      while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - parsedRange[1].time) * sign > 0) {\n        allDay -= sign;\n        date.setDate(dateNum - sign);\n      }\n    }\n    var weeks = Math.floor((allDay + parsedRange[0].day + 6) / 7);\n    var nthWeek = reversed ? -weeks + 1 : weeks - 1;\n    reversed && parsedRange.reverse();\n    return {\n      range: [parsedRange[0].formatedDate, parsedRange[1].formatedDate],\n      start: parsedRange[0],\n      end: parsedRange[1],\n      allDay: allDay,\n      weeks: weeks,\n      // From 0.\n      nthWeek: nthWeek,\n      fweek: parsedRange[0].day,\n      lweek: parsedRange[1].day\n    };\n  };\n  /**\r\n   * get date by nthWeeks and week day in range\r\n   *\r\n   * @private\r\n   * @param  {number} nthWeek the week\r\n   * @param  {number} day   the week day\r\n   * @param  {Array} range [d1, d2]\r\n   * @return {Object}\r\n   */\n  Calendar.prototype._getDateByWeeksAndDay = function (nthWeek, day, range) {\n    var rangeInfo = this._getRangeInfo(range);\n    if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {\n      return null;\n    }\n    var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;\n    var date = new Date(rangeInfo.start.time);\n    date.setDate(+rangeInfo.start.d + nthDay);\n    return this.getDateInfo(date);\n  };\n  Calendar.create = function (ecModel, api) {\n    var calendarList = [];\n    ecModel.eachComponent('calendar', function (calendarModel) {\n      var calendar = new Calendar(calendarModel, ecModel, api);\n      calendarList.push(calendar);\n      calendarModel.coordinateSystem = calendar;\n    });\n    ecModel.eachSeries(function (calendarSeries) {\n      if (calendarSeries.get('coordinateSystem') === 'calendar') {\n        // Inject coordinate system\n        calendarSeries.coordinateSystem = calendarList[calendarSeries.get('calendarIndex') || 0];\n      }\n    });\n    return calendarList;\n  };\n  Calendar.dimensions = ['time', 'value'];\n  return Calendar;\n}();\nfunction getCoordSys(finder) {\n  var calendarModel = finder.calendarModel;\n  var seriesModel = finder.seriesModel;\n  var coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;\n  return coordSys;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Calendar);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM1MDkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhbGVuZGFyL0NhbGVuZGFyLmpzPzNmNTAiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIGxheW91dCBmcm9tICcuLi8uLi91dGlsL2xheW91dC5qcyc7XG5pbXBvcnQgKiBhcyBudW1iZXJVdGlsIGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyLmpzJztcbi8vICgyNCo2MCo2MCoxMDAwKVxudmFyIFBST1hJTUFURV9PTkVfREFZID0gODY0MDAwMDA7XG52YXIgQ2FsZW5kYXIgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYWxlbmRhcihjYWxlbmRhck1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLnR5cGUgPSAnY2FsZW5kYXInO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IENhbGVuZGFyLmRpbWVuc2lvbnM7XG4gICAgLy8gUmVxdWlyZWQgaW4gY3JlYXRlTGlzdEZyb21EYXRhXG4gICAgdGhpcy5nZXREaW1lbnNpb25zSW5mbyA9IENhbGVuZGFyLmdldERpbWVuc2lvbnNJbmZvO1xuICAgIHRoaXMuX21vZGVsID0gY2FsZW5kYXJNb2RlbDtcbiAgfVxuICBDYWxlbmRhci5nZXREaW1lbnNpb25zSW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIG5hbWU6ICd0aW1lJyxcbiAgICAgIHR5cGU6ICd0aW1lJ1xuICAgIH0sICd2YWx1ZSddO1xuICB9O1xuICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0UmFuZ2VJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yYW5nZUluZm87XG4gIH07XG4gIENhbGVuZGFyLnByb3RvdHlwZS5nZXRNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIH07XG4gIENhbGVuZGFyLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICB9O1xuICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0Q2VsbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zdztcbiAgfTtcbiAgQ2FsZW5kYXIucHJvdG90eXBlLmdldENlbGxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NoO1xuICB9O1xuICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0T3JpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmllbnQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIGdldEZpcnN0RGF5T2ZXZWVrXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqICAgICAwIDogc3RhcnQgYXQgU3VuZGF5XHJcbiAgICogICAgIDEgOiBzdGFydCBhdCBNb25kYXlcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cbiAgQ2FsZW5kYXIucHJvdG90eXBlLmdldEZpcnN0RGF5T2ZXZWVrID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdERheU9mV2VlaztcbiAgfTtcbiAgLyoqXHJcbiAgICogZ2V0IGRhdGUgaW5mb1xyXG4gICAqIH1cclxuICAgKi9cbiAgQ2FsZW5kYXIucHJvdG90eXBlLmdldERhdGVJbmZvID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICBkYXRlID0gbnVtYmVyVXRpbC5wYXJzZURhdGUoZGF0ZSk7XG4gICAgdmFyIHkgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgdmFyIG0gPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xuICAgIHZhciBtU3RyID0gbSA8IDEwID8gJzAnICsgbSA6ICcnICsgbTtcbiAgICB2YXIgZCA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgIHZhciBkU3RyID0gZCA8IDEwID8gJzAnICsgZCA6ICcnICsgZDtcbiAgICB2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgICBkYXkgPSBNYXRoLmFicygoZGF5ICsgNyAtIHRoaXMuZ2V0Rmlyc3REYXlPZldlZWsoKSkgJSA3KTtcbiAgICByZXR1cm4ge1xuICAgICAgeTogeSArICcnLFxuICAgICAgbTogbVN0cixcbiAgICAgIGQ6IGRTdHIsXG4gICAgICBkYXk6IGRheSxcbiAgICAgIHRpbWU6IGRhdGUuZ2V0VGltZSgpLFxuICAgICAgZm9ybWF0ZWREYXRlOiB5ICsgJy0nICsgbVN0ciArICctJyArIGRTdHIsXG4gICAgICBkYXRlOiBkYXRlXG4gICAgfTtcbiAgfTtcbiAgQ2FsZW5kYXIucHJvdG90eXBlLmdldE5leHRORGF5ID0gZnVuY3Rpb24gKGRhdGUsIG4pIHtcbiAgICBuID0gbiB8fCAwO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXREYXRlSW5mbyhkYXRlKTtcbiAgICB9XG4gICAgZGF0ZSA9IG5ldyBEYXRlKHRoaXMuZ2V0RGF0ZUluZm8oZGF0ZSkudGltZSk7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgbik7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0ZUluZm8oZGF0ZSk7XG4gIH07XG4gIENhbGVuZGFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5fZmlyc3REYXlPZldlZWsgPSArdGhpcy5fbW9kZWwuZ2V0TW9kZWwoJ2RheUxhYmVsJykuZ2V0KCdmaXJzdERheScpO1xuICAgIHRoaXMuX29yaWVudCA9IHRoaXMuX21vZGVsLmdldCgnb3JpZW50Jyk7XG4gICAgdGhpcy5fbGluZVdpZHRoID0gdGhpcy5fbW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZSgpLmxpbmVXaWR0aCB8fCAwO1xuICAgIHRoaXMuX3JhbmdlSW5mbyA9IHRoaXMuX2dldFJhbmdlSW5mbyh0aGlzLl9pbml0UmFuZ2VPcHRpb24oKSk7XG4gICAgdmFyIHdlZWtzID0gdGhpcy5fcmFuZ2VJbmZvLndlZWtzIHx8IDE7XG4gICAgdmFyIHdoTmFtZXMgPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuICAgIHZhciBjZWxsU2l6ZSA9IHRoaXMuX21vZGVsLmdldENlbGxTaXplKCkuc2xpY2UoKTtcbiAgICB2YXIgbGF5b3V0UGFyYW1zID0gdGhpcy5fbW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCk7XG4gICAgdmFyIGNlbGxOdW1iZXJzID0gdGhpcy5fb3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyBbd2Vla3MsIDddIDogWzcsIHdlZWtzXTtcbiAgICB6clV0aWwuZWFjaChbMCwgMV0sIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIGlmIChjZWxsU2l6ZVNwZWNpZmllZChjZWxsU2l6ZSwgaWR4KSkge1xuICAgICAgICBsYXlvdXRQYXJhbXNbd2hOYW1lc1tpZHhdXSA9IGNlbGxTaXplW2lkeF0gKiBjZWxsTnVtYmVyc1tpZHhdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciB3aEdsb2JhbCA9IHtcbiAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgfTtcbiAgICB2YXIgY2FsZW5kYXJSZWN0ID0gdGhpcy5fcmVjdCA9IGxheW91dC5nZXRMYXlvdXRSZWN0KGxheW91dFBhcmFtcywgd2hHbG9iYWwpO1xuICAgIHpyVXRpbC5lYWNoKFswLCAxXSwgZnVuY3Rpb24gKGlkeCkge1xuICAgICAgaWYgKCFjZWxsU2l6ZVNwZWNpZmllZChjZWxsU2l6ZSwgaWR4KSkge1xuICAgICAgICBjZWxsU2l6ZVtpZHhdID0gY2FsZW5kYXJSZWN0W3doTmFtZXNbaWR4XV0gLyBjZWxsTnVtYmVyc1tpZHhdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNlbGxTaXplU3BlY2lmaWVkKGNlbGxTaXplLCBpZHgpIHtcbiAgICAgIHJldHVybiBjZWxsU2l6ZVtpZHhdICE9IG51bGwgJiYgY2VsbFNpemVbaWR4XSAhPT0gJ2F1dG8nO1xuICAgIH1cbiAgICAvLyBIYXMgYmVlbiBjYWxjdWxhdGVkIG91dCBudW1iZXIuXG4gICAgdGhpcy5fc3cgPSBjZWxsU2l6ZVswXTtcbiAgICB0aGlzLl9zaCA9IGNlbGxTaXplWzFdO1xuICB9O1xuICAvKipcclxuICAgKiBDb252ZXJ0IGEgdGltZSBkYXRhKHRpbWUsIHZhbHVlKSBpdGVtIHRvICh4LCB5KSBwb2ludC5cclxuICAgKi9cbiAgLy8gVE9ETyBDbGFtcCBvZiBjYWxlbmRhciBpcyBub3Qgc2FtZSB3aXRoIGNhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbXMuXG4gIC8vIEl0IHdpbGwgcmV0dXJuIE5hTiBpZiBkYXRhIGV4Y2VlZHMuXG4gIENhbGVuZGFyLnByb3RvdHlwZS5kYXRhVG9Qb2ludCA9IGZ1bmN0aW9uIChkYXRhLCBjbGFtcCkge1xuICAgIHpyVXRpbC5pc0FycmF5KGRhdGEpICYmIChkYXRhID0gZGF0YVswXSk7XG4gICAgY2xhbXAgPT0gbnVsbCAmJiAoY2xhbXAgPSB0cnVlKTtcbiAgICB2YXIgZGF5SW5mbyA9IHRoaXMuZ2V0RGF0ZUluZm8oZGF0YSk7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2VJbmZvO1xuICAgIHZhciBkYXRlID0gZGF5SW5mby5mb3JtYXRlZERhdGU7XG4gICAgLy8gaWYgbm90IGluIHJhbmdlIHJldHVybiBbTmFOLCBOYU5dXG4gICAgaWYgKGNsYW1wICYmICEoZGF5SW5mby50aW1lID49IHJhbmdlLnN0YXJ0LnRpbWUgJiYgZGF5SW5mby50aW1lIDwgcmFuZ2UuZW5kLnRpbWUgKyBQUk9YSU1BVEVfT05FX0RBWSkpIHtcbiAgICAgIHJldHVybiBbTmFOLCBOYU5dO1xuICAgIH1cbiAgICB2YXIgd2VlayA9IGRheUluZm8uZGF5O1xuICAgIHZhciBudGhXZWVrID0gdGhpcy5fZ2V0UmFuZ2VJbmZvKFtyYW5nZS5zdGFydC50aW1lLCBkYXRlXSkubnRoV2VlaztcbiAgICBpZiAodGhpcy5fb3JpZW50ID09PSAndmVydGljYWwnKSB7XG4gICAgICByZXR1cm4gW3RoaXMuX3JlY3QueCArIHdlZWsgKiB0aGlzLl9zdyArIHRoaXMuX3N3IC8gMiwgdGhpcy5fcmVjdC55ICsgbnRoV2VlayAqIHRoaXMuX3NoICsgdGhpcy5fc2ggLyAyXTtcbiAgICB9XG4gICAgcmV0dXJuIFt0aGlzLl9yZWN0LnggKyBudGhXZWVrICogdGhpcy5fc3cgKyB0aGlzLl9zdyAvIDIsIHRoaXMuX3JlY3QueSArIHdlZWsgKiB0aGlzLl9zaCArIHRoaXMuX3NoIC8gMl07XG4gIH07XG4gIC8qKlxyXG4gICAqIENvbnZlcnQgYSAoeCwgeSkgcG9pbnQgdG8gdGltZSBkYXRhXHJcbiAgICovXG4gIENhbGVuZGFyLnByb3RvdHlwZS5wb2ludFRvRGF0YSA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBkYXRlID0gdGhpcy5wb2ludFRvRGF0ZShwb2ludCk7XG4gICAgcmV0dXJuIGRhdGUgJiYgZGF0ZS50aW1lO1xuICB9O1xuICAvKipcclxuICAgKiBDb252ZXJ0IGEgdGltZSBkYXRlIGl0ZW0gdG8gKHgsIHkpIGZvdXIgcG9pbnQuXHJcbiAgICovXG4gIENhbGVuZGFyLnByb3RvdHlwZS5kYXRhVG9SZWN0ID0gZnVuY3Rpb24gKGRhdGEsIGNsYW1wKSB7XG4gICAgdmFyIHBvaW50ID0gdGhpcy5kYXRhVG9Qb2ludChkYXRhLCBjbGFtcCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnRTaGFwZToge1xuICAgICAgICB4OiBwb2ludFswXSAtICh0aGlzLl9zdyAtIHRoaXMuX2xpbmVXaWR0aCkgLyAyLFxuICAgICAgICB5OiBwb2ludFsxXSAtICh0aGlzLl9zaCAtIHRoaXMuX2xpbmVXaWR0aCkgLyAyLFxuICAgICAgICB3aWR0aDogdGhpcy5fc3cgLSB0aGlzLl9saW5lV2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5fc2ggLSB0aGlzLl9saW5lV2lkdGhcbiAgICAgIH0sXG4gICAgICBjZW50ZXI6IHBvaW50LFxuICAgICAgdGw6IFtwb2ludFswXSAtIHRoaXMuX3N3IC8gMiwgcG9pbnRbMV0gLSB0aGlzLl9zaCAvIDJdLFxuICAgICAgdHI6IFtwb2ludFswXSArIHRoaXMuX3N3IC8gMiwgcG9pbnRbMV0gLSB0aGlzLl9zaCAvIDJdLFxuICAgICAgYnI6IFtwb2ludFswXSArIHRoaXMuX3N3IC8gMiwgcG9pbnRbMV0gKyB0aGlzLl9zaCAvIDJdLFxuICAgICAgYmw6IFtwb2ludFswXSAtIHRoaXMuX3N3IC8gMiwgcG9pbnRbMV0gKyB0aGlzLl9zaCAvIDJdXG4gICAgfTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ29udmVydCBhICh4LCB5KSBwb2ludCB0byB0aW1lIGRhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0FycmF5fSBwb2ludCBwb2ludFxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgZGF0ZVxyXG4gICAqL1xuICBDYWxlbmRhci5wcm90b3R5cGUucG9pbnRUb0RhdGUgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgbnRoWCA9IE1hdGguZmxvb3IoKHBvaW50WzBdIC0gdGhpcy5fcmVjdC54KSAvIHRoaXMuX3N3KSArIDE7XG4gICAgdmFyIG50aFkgPSBNYXRoLmZsb29yKChwb2ludFsxXSAtIHRoaXMuX3JlY3QueSkgLyB0aGlzLl9zaCkgKyAxO1xuICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlSW5mby5yYW5nZTtcbiAgICBpZiAodGhpcy5fb3JpZW50ID09PSAndmVydGljYWwnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RGF0ZUJ5V2Vla3NBbmREYXkobnRoWSwgbnRoWCAtIDEsIHJhbmdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldERhdGVCeVdlZWtzQW5kRGF5KG50aFgsIG50aFkgLSAxLCByYW5nZSk7XG4gIH07XG4gIENhbGVuZGFyLnByb3RvdHlwZS5jb252ZXJ0VG9QaXhlbCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIsIHZhbHVlKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gZ2V0Q29vcmRTeXMoZmluZGVyKTtcbiAgICByZXR1cm4gY29vcmRTeXMgPT09IHRoaXMgPyBjb29yZFN5cy5kYXRhVG9Qb2ludCh2YWx1ZSkgOiBudWxsO1xuICB9O1xuICBDYWxlbmRhci5wcm90b3R5cGUuY29udmVydEZyb21QaXhlbCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIsIHBpeGVsKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gZ2V0Q29vcmRTeXMoZmluZGVyKTtcbiAgICByZXR1cm4gY29vcmRTeXMgPT09IHRoaXMgPyBjb29yZFN5cy5wb2ludFRvRGF0YShwaXhlbCkgOiBudWxsO1xuICB9O1xuICBDYWxlbmRhci5wcm90b3R5cGUuY29udGFpblBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgY29uc29sZS53YXJuKCdOb3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICAvKipcclxuICAgKiBpbml0UmFuZ2VcclxuICAgKiBOb3JtYWxpemUgdG8gYW4gW3N0YXJ0LCBlbmRdIGFycmF5XHJcbiAgICovXG4gIENhbGVuZGFyLnByb3RvdHlwZS5faW5pdFJhbmdlT3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByYW5nZSA9IHRoaXMuX21vZGVsLmdldCgncmFuZ2UnKTtcbiAgICB2YXIgbm9ybWFsaXplZFJhbmdlO1xuICAgIC8vIENvbnZlcnQgWzE5OTBdIHRvIDE5OTBcbiAgICBpZiAoenJVdGlsLmlzQXJyYXkocmFuZ2UpICYmIHJhbmdlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmFuZ2UgPSByYW5nZVswXTtcbiAgICB9XG4gICAgaWYgKCF6clV0aWwuaXNBcnJheShyYW5nZSkpIHtcbiAgICAgIHZhciByYW5nZVN0ciA9IHJhbmdlLnRvU3RyaW5nKCk7XG4gICAgICAvLyBPbmUgeWVhci5cbiAgICAgIGlmICgvXlxcZHs0fSQvLnRlc3QocmFuZ2VTdHIpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRSYW5nZSA9IFtyYW5nZVN0ciArICctMDEtMDEnLCByYW5nZVN0ciArICctMTItMzEnXTtcbiAgICAgIH1cbiAgICAgIC8vIE9uZSBtb250aFxuICAgICAgaWYgKC9eXFxkezR9W1xcL3wtXVxcZHsxLDJ9JC8udGVzdChyYW5nZVN0cikpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXREYXRlSW5mbyhyYW5nZVN0cik7XG4gICAgICAgIHZhciBmaXJzdERheSA9IHN0YXJ0LmRhdGU7XG4gICAgICAgIGZpcnN0RGF5LnNldE1vbnRoKGZpcnN0RGF5LmdldE1vbnRoKCkgKyAxKTtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZ2V0TmV4dE5EYXkoZmlyc3REYXksIC0xKTtcbiAgICAgICAgbm9ybWFsaXplZFJhbmdlID0gW3N0YXJ0LmZvcm1hdGVkRGF0ZSwgZW5kLmZvcm1hdGVkRGF0ZV07XG4gICAgICB9XG4gICAgICAvLyBPbmUgZGF5XG4gICAgICBpZiAoL15cXGR7NH1bXFwvfC1dXFxkezEsMn1bXFwvfC1dXFxkezEsMn0kLy50ZXN0KHJhbmdlU3RyKSkge1xuICAgICAgICBub3JtYWxpemVkUmFuZ2UgPSBbcmFuZ2VTdHIsIHJhbmdlU3RyXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplZFJhbmdlID0gcmFuZ2U7XG4gICAgfVxuICAgIGlmICghbm9ybWFsaXplZFJhbmdlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB6clV0aWwubG9nRXJyb3IoJ0ludmFsaWQgZGF0ZSByYW5nZS4nKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vdCBoYW5kbGluZyBpdC5cbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gICAgdmFyIHRtcCA9IHRoaXMuX2dldFJhbmdlSW5mbyhub3JtYWxpemVkUmFuZ2UpO1xuICAgIGlmICh0bXAuc3RhcnQudGltZSA+IHRtcC5lbmQudGltZSkge1xuICAgICAgbm9ybWFsaXplZFJhbmdlLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRSYW5nZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogcmFuZ2UgaW5mb1xyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0gIHtBcnJheX0gcmFuZ2UgcmFuZ2UgWycyMDE3LTAxLTAxJywgJzIwMTctMDctMDgnXVxyXG4gICAqICBJZiByYW5nZVswXSA+IHJhbmdlWzFdLCB0aGV5IHdpbGwgbm90IGJlIHJldmVyc2VkLlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgb2JqXHJcbiAgICovXG4gIENhbGVuZGFyLnByb3RvdHlwZS5fZ2V0UmFuZ2VJbmZvID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgdmFyIHBhcnNlZFJhbmdlID0gW3RoaXMuZ2V0RGF0ZUluZm8ocmFuZ2VbMF0pLCB0aGlzLmdldERhdGVJbmZvKHJhbmdlWzFdKV07XG4gICAgdmFyIHJldmVyc2VkO1xuICAgIGlmIChwYXJzZWRSYW5nZVswXS50aW1lID4gcGFyc2VkUmFuZ2VbMV0udGltZSkge1xuICAgICAgcmV2ZXJzZWQgPSB0cnVlO1xuICAgICAgcGFyc2VkUmFuZ2UucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB2YXIgYWxsRGF5ID0gTWF0aC5mbG9vcihwYXJzZWRSYW5nZVsxXS50aW1lIC8gUFJPWElNQVRFX09ORV9EQVkpIC0gTWF0aC5mbG9vcihwYXJzZWRSYW5nZVswXS50aW1lIC8gUFJPWElNQVRFX09ORV9EQVkpICsgMTtcbiAgICAvLyBDb25zaWRlciBjYXNlMSAoIzExNjc3ICMxMDQzMCk6XG4gICAgLy8gU2V0IHRoZSBzeXN0ZW0gdGltZXpvbmUgYXMgXCJVS1wiLCBzZXQgdGhlIHJhbmdlIHRvIGBbJzIwMTYtMDctMDEnLCAnMjAxNi0xMi0zMSddYFxuICAgIC8vIENvbnNpZGVyIGNhc2UyOlxuICAgIC8vIEZpcnN0bHkgc2V0IHN5c3RlbSB0aW1lem9uZSBhcyBcIlRpbWUgWm9uZTogQW1lcmljYS9Ub3JvbnRvXCIsXG4gICAgLy8gYGBgXG4gICAgLy8gbGV0IGZpcnN0ID0gbmV3IERhdGUoMTQ3ODQxMjAwMDAwMCAtIDM2MDAgKiAxMDAwICogMi41KTtcbiAgICAvLyBsZXQgc2Vjb25kID0gbmV3IERhdGUoMTQ3ODQxMjAwMDAwMCk7XG4gICAgLy8gbGV0IGFsbERheXMgPSBNYXRoLmZsb29yKHNlY29uZCAvIE9ORV9EQVkpIC0gTWF0aC5mbG9vcihmaXJzdCAvIE9ORV9EQVkpICsgMTtcbiAgICAvLyBgYGBcbiAgICAvLyB3aWxsIGdldCB3cm9uZyByZXN1bHQgYmVjYXVzZSBvZiBEU1QuIFNvIHdlIHNob3VsZCBmaXggaXQuXG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShwYXJzZWRSYW5nZVswXS50aW1lKTtcbiAgICB2YXIgc3RhcnREYXRlTnVtID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgdmFyIGVuZERhdGVOdW0gPSBwYXJzZWRSYW5nZVsxXS5kYXRlLmdldERhdGUoKTtcbiAgICBkYXRlLnNldERhdGUoc3RhcnREYXRlTnVtICsgYWxsRGF5IC0gMSk7XG4gICAgLy8gVGhlIGJpYXMgY2FuIG5vdCBvdmVyIGEgbW9udGgsIHNvIGp1c3QgY29tcGFyZSBkYXRlLlxuICAgIHZhciBkYXRlTnVtID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgaWYgKGRhdGVOdW0gIT09IGVuZERhdGVOdW0pIHtcbiAgICAgIHZhciBzaWduID0gZGF0ZS5nZXRUaW1lKCkgLSBwYXJzZWRSYW5nZVsxXS50aW1lID4gMCA/IDEgOiAtMTtcbiAgICAgIHdoaWxlICgoZGF0ZU51bSA9IGRhdGUuZ2V0RGF0ZSgpKSAhPT0gZW5kRGF0ZU51bSAmJiAoZGF0ZS5nZXRUaW1lKCkgLSBwYXJzZWRSYW5nZVsxXS50aW1lKSAqIHNpZ24gPiAwKSB7XG4gICAgICAgIGFsbERheSAtPSBzaWduO1xuICAgICAgICBkYXRlLnNldERhdGUoZGF0ZU51bSAtIHNpZ24pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgd2Vla3MgPSBNYXRoLmZsb29yKChhbGxEYXkgKyBwYXJzZWRSYW5nZVswXS5kYXkgKyA2KSAvIDcpO1xuICAgIHZhciBudGhXZWVrID0gcmV2ZXJzZWQgPyAtd2Vla3MgKyAxIDogd2Vla3MgLSAxO1xuICAgIHJldmVyc2VkICYmIHBhcnNlZFJhbmdlLnJldmVyc2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmFuZ2U6IFtwYXJzZWRSYW5nZVswXS5mb3JtYXRlZERhdGUsIHBhcnNlZFJhbmdlWzFdLmZvcm1hdGVkRGF0ZV0sXG4gICAgICBzdGFydDogcGFyc2VkUmFuZ2VbMF0sXG4gICAgICBlbmQ6IHBhcnNlZFJhbmdlWzFdLFxuICAgICAgYWxsRGF5OiBhbGxEYXksXG4gICAgICB3ZWVrczogd2Vla3MsXG4gICAgICAvLyBGcm9tIDAuXG4gICAgICBudGhXZWVrOiBudGhXZWVrLFxuICAgICAgZndlZWs6IHBhcnNlZFJhbmdlWzBdLmRheSxcbiAgICAgIGx3ZWVrOiBwYXJzZWRSYW5nZVsxXS5kYXlcbiAgICB9O1xuICB9O1xuICAvKipcclxuICAgKiBnZXQgZGF0ZSBieSBudGhXZWVrcyBhbmQgd2VlayBkYXkgaW4gcmFuZ2VcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBudGhXZWVrIHRoZSB3ZWVrXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkYXkgICB0aGUgd2VlayBkYXlcclxuICAgKiBAcGFyYW0gIHtBcnJheX0gcmFuZ2UgW2QxLCBkMl1cclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXG4gIENhbGVuZGFyLnByb3RvdHlwZS5fZ2V0RGF0ZUJ5V2Vla3NBbmREYXkgPSBmdW5jdGlvbiAobnRoV2VlaywgZGF5LCByYW5nZSkge1xuICAgIHZhciByYW5nZUluZm8gPSB0aGlzLl9nZXRSYW5nZUluZm8ocmFuZ2UpO1xuICAgIGlmIChudGhXZWVrID4gcmFuZ2VJbmZvLndlZWtzIHx8IG50aFdlZWsgPT09IDAgJiYgZGF5IDwgcmFuZ2VJbmZvLmZ3ZWVrIHx8IG50aFdlZWsgPT09IHJhbmdlSW5mby53ZWVrcyAmJiBkYXkgPiByYW5nZUluZm8ubHdlZWspIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbnRoRGF5ID0gKG50aFdlZWsgLSAxKSAqIDcgLSByYW5nZUluZm8uZndlZWsgKyBkYXk7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShyYW5nZUluZm8uc3RhcnQudGltZSk7XG4gICAgZGF0ZS5zZXREYXRlKCtyYW5nZUluZm8uc3RhcnQuZCArIG50aERheSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0ZUluZm8oZGF0ZSk7XG4gIH07XG4gIENhbGVuZGFyLmNyZWF0ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgY2FsZW5kYXJMaXN0ID0gW107XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdjYWxlbmRhcicsIGZ1bmN0aW9uIChjYWxlbmRhck1vZGVsKSB7XG4gICAgICB2YXIgY2FsZW5kYXIgPSBuZXcgQ2FsZW5kYXIoY2FsZW5kYXJNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICAgIGNhbGVuZGFyTGlzdC5wdXNoKGNhbGVuZGFyKTtcbiAgICAgIGNhbGVuZGFyTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IGNhbGVuZGFyO1xuICAgIH0pO1xuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoY2FsZW5kYXJTZXJpZXMpIHtcbiAgICAgIGlmIChjYWxlbmRhclNlcmllcy5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKSA9PT0gJ2NhbGVuZGFyJykge1xuICAgICAgICAvLyBJbmplY3QgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgICAgY2FsZW5kYXJTZXJpZXMuY29vcmRpbmF0ZVN5c3RlbSA9IGNhbGVuZGFyTGlzdFtjYWxlbmRhclNlcmllcy5nZXQoJ2NhbGVuZGFySW5kZXgnKSB8fCAwXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2FsZW5kYXJMaXN0O1xuICB9O1xuICBDYWxlbmRhci5kaW1lbnNpb25zID0gWyd0aW1lJywgJ3ZhbHVlJ107XG4gIHJldHVybiBDYWxlbmRhcjtcbn0oKTtcbmZ1bmN0aW9uIGdldENvb3JkU3lzKGZpbmRlcikge1xuICB2YXIgY2FsZW5kYXJNb2RlbCA9IGZpbmRlci5jYWxlbmRhck1vZGVsO1xuICB2YXIgc2VyaWVzTW9kZWwgPSBmaW5kZXIuc2VyaWVzTW9kZWw7XG4gIHZhciBjb29yZFN5cyA9IGNhbGVuZGFyTW9kZWwgPyBjYWxlbmRhck1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gOiBzZXJpZXNNb2RlbCA/IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gOiBudWxsO1xuICByZXR1cm4gY29vcmRTeXM7XG59XG5leHBvcnQgZGVmYXVsdCBDYWxlbmRhcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23509\n")},36915:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ calendarPrepareCustom)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nfunction calendarPrepareCustom(coordSys) {\n  var rect = coordSys.getRect();\n  var rangeInfo = coordSys.getRangeInfo();\n  return {\n    coordSys: {\n      type: \'calendar\',\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height,\n      cellWidth: coordSys.getCellWidth(),\n      cellHeight: coordSys.getCellHeight(),\n      rangeInfo: {\n        start: rangeInfo.start,\n        end: rangeInfo.end,\n        weeks: rangeInfo.weeks,\n        dayCount: rangeInfo.allDay\n      }\n    },\n    api: {\n      coord: function (data, clamp) {\n        return coordSys.dataToPoint(data, clamp);\n      }\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY5MTUuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhbGVuZGFyL3ByZXBhcmVDdXN0b20uanM/NzIzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhbGVuZGFyUHJlcGFyZUN1c3RvbShjb29yZFN5cykge1xuICB2YXIgcmVjdCA9IGNvb3JkU3lzLmdldFJlY3QoKTtcbiAgdmFyIHJhbmdlSW5mbyA9IGNvb3JkU3lzLmdldFJhbmdlSW5mbygpO1xuICByZXR1cm4ge1xuICAgIGNvb3JkU3lzOiB7XG4gICAgICB0eXBlOiAnY2FsZW5kYXInLFxuICAgICAgeDogcmVjdC54LFxuICAgICAgeTogcmVjdC55LFxuICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgICAgY2VsbFdpZHRoOiBjb29yZFN5cy5nZXRDZWxsV2lkdGgoKSxcbiAgICAgIGNlbGxIZWlnaHQ6IGNvb3JkU3lzLmdldENlbGxIZWlnaHQoKSxcbiAgICAgIHJhbmdlSW5mbzoge1xuICAgICAgICBzdGFydDogcmFuZ2VJbmZvLnN0YXJ0LFxuICAgICAgICBlbmQ6IHJhbmdlSW5mby5lbmQsXG4gICAgICAgIHdlZWtzOiByYW5nZUluZm8ud2Vla3MsXG4gICAgICAgIGRheUNvdW50OiByYW5nZUluZm8uYWxsRGF5XG4gICAgICB9XG4gICAgfSxcbiAgICBhcGk6IHtcbiAgICAgIGNvb3JkOiBmdW5jdGlvbiAoZGF0YSwgY2xhbXApIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkU3lzLmRhdGFUb1BvaW50KGRhdGEsIGNsYW1wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///36915\n')},59470:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ axisModelCreator)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/axisDefault.js\nvar axisDefault = __webpack_require__(13286);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/OrdinalMeta.js\nvar OrdinalMeta = __webpack_require__(15135);\n;// ./node_modules/echarts/lib/coord/axisCommonTypes.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar AXIS_TYPES = {\n  value: 1,\n  category: 1,\n  time: 1,\n  log: 1\n};\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n;// ./node_modules/echarts/lib/coord/axisModelCreator.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n/**\r\n * Generate sub axis model class\r\n * @param axisName 'x' 'y' 'radius' 'angle' 'parallel' ...\r\n */\nfunction axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {\n  (0,util.each)(AXIS_TYPES, function (v, axisType) {\n    var defaultOption = (0,util.merge)((0,util.merge)({}, axisDefault/* default */.A[axisType], true), extraDefaultOption, true);\n    var AxisModel = /** @class */function (_super) {\n      (0,tslib_es6/* __extends */.C6)(AxisModel, _super);\n      function AxisModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = axisName + 'Axis.' + axisType;\n        return _this;\n      }\n      AxisModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {\n        var layoutMode = (0,layout/* fetchLayoutMode */.ad)(this);\n        var inputPositionParams = layoutMode ? (0,layout/* getLayoutParams */.vs)(option) : {};\n        var themeModel = ecModel.getTheme();\n        (0,util.merge)(option, themeModel.get(axisType + 'Axis'));\n        (0,util.merge)(option, this.getDefaultOption());\n        option.type = getAxisType(option);\n        if (layoutMode) {\n          (0,layout/* mergeLayoutParam */.YA)(option, inputPositionParams, layoutMode);\n        }\n      };\n      AxisModel.prototype.optionUpdated = function () {\n        var thisOption = this.option;\n        if (thisOption.type === 'category') {\n          this.__ordinalMeta = OrdinalMeta/* default */.A.createByAxisModel(this);\n        }\n      };\n      /**\r\n       * Should not be called before all of 'getInitailData' finished.\r\n       * Because categories are collected during initializing data.\r\n       */\n      AxisModel.prototype.getCategories = function (rawData) {\n        var option = this.option;\n        // FIXME\n        // warning if called before all of 'getInitailData' finished.\n        if (option.type === 'category') {\n          if (rawData) {\n            return option.data;\n          }\n          return this.__ordinalMeta.categories;\n        }\n      };\n      AxisModel.prototype.getOrdinalMeta = function () {\n        return this.__ordinalMeta;\n      };\n      AxisModel.type = axisName + 'Axis.' + axisType;\n      AxisModel.defaultOption = defaultOption;\n      return AxisModel;\n    }(BaseAxisModelClass);\n    registers.registerComponentModel(AxisModel);\n  });\n  registers.registerSubTypeDefaulter(axisName + 'Axis', getAxisType);\n}\nfunction getAxisType(option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTk0NzAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9heGlzQ29tbW9uVHlwZXMuanM/Y2FjYiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc01vZGVsQ3JlYXRvci5qcz9iOTA2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuZXhwb3J0IHZhciBBWElTX1RZUEVTID0ge1xuICB2YWx1ZTogMSxcbiAgY2F0ZWdvcnk6IDEsXG4gIHRpbWU6IDEsXG4gIGxvZzogMVxufTsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IGF4aXNEZWZhdWx0IGZyb20gJy4vYXhpc0RlZmF1bHQuanMnO1xuaW1wb3J0IHsgZ2V0TGF5b3V0UGFyYW1zLCBtZXJnZUxheW91dFBhcmFtLCBmZXRjaExheW91dE1vZGUgfSBmcm9tICcuLi91dGlsL2xheW91dC5qcyc7XG5pbXBvcnQgT3JkaW5hbE1ldGEgZnJvbSAnLi4vZGF0YS9PcmRpbmFsTWV0YS5qcyc7XG5pbXBvcnQgeyBBWElTX1RZUEVTIH0gZnJvbSAnLi9heGlzQ29tbW9uVHlwZXMuanMnO1xuaW1wb3J0IHsgZWFjaCwgbWVyZ2UgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuLyoqXHJcbiAqIEdlbmVyYXRlIHN1YiBheGlzIG1vZGVsIGNsYXNzXHJcbiAqIEBwYXJhbSBheGlzTmFtZSAneCcgJ3knICdyYWRpdXMnICdhbmdsZScgJ3BhcmFsbGVsJyAuLi5cclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBheGlzTW9kZWxDcmVhdG9yKHJlZ2lzdGVycywgYXhpc05hbWUsIEJhc2VBeGlzTW9kZWxDbGFzcywgZXh0cmFEZWZhdWx0T3B0aW9uKSB7XG4gIGVhY2goQVhJU19UWVBFUywgZnVuY3Rpb24gKHYsIGF4aXNUeXBlKSB7XG4gICAgdmFyIGRlZmF1bHRPcHRpb24gPSBtZXJnZShtZXJnZSh7fSwgYXhpc0RlZmF1bHRbYXhpc1R5cGVdLCB0cnVlKSwgZXh0cmFEZWZhdWx0T3B0aW9uLCB0cnVlKTtcbiAgICB2YXIgQXhpc01vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyhBeGlzTW9kZWwsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBeGlzTW9kZWwoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gYXhpc05hbWUgKyAnQXhpcy4nICsgYXhpc1R5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cbiAgICAgIEF4aXNNb2RlbC5wcm90b3R5cGUubWVyZ2VEZWZhdWx0QW5kVGhlbWUgPSBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgIHZhciBsYXlvdXRNb2RlID0gZmV0Y2hMYXlvdXRNb2RlKHRoaXMpO1xuICAgICAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGxheW91dE1vZGUgPyBnZXRMYXlvdXRQYXJhbXMob3B0aW9uKSA6IHt9O1xuICAgICAgICB2YXIgdGhlbWVNb2RlbCA9IGVjTW9kZWwuZ2V0VGhlbWUoKTtcbiAgICAgICAgbWVyZ2Uob3B0aW9uLCB0aGVtZU1vZGVsLmdldChheGlzVHlwZSArICdBeGlzJykpO1xuICAgICAgICBtZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTtcbiAgICAgICAgb3B0aW9uLnR5cGUgPSBnZXRBeGlzVHlwZShvcHRpb24pO1xuICAgICAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgICAgIG1lcmdlTGF5b3V0UGFyYW0ob3B0aW9uLCBpbnB1dFBvc2l0aW9uUGFyYW1zLCBsYXlvdXRNb2RlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEF4aXNNb2RlbC5wcm90b3R5cGUub3B0aW9uVXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgaWYgKHRoaXNPcHRpb24udHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgIHRoaXMuX19vcmRpbmFsTWV0YSA9IE9yZGluYWxNZXRhLmNyZWF0ZUJ5QXhpc01vZGVsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXHJcbiAgICAgICAqIFNob3VsZCBub3QgYmUgY2FsbGVkIGJlZm9yZSBhbGwgb2YgJ2dldEluaXRhaWxEYXRhJyBmaW5pc2hlZC5cclxuICAgICAgICogQmVjYXVzZSBjYXRlZ29yaWVzIGFyZSBjb2xsZWN0ZWQgZHVyaW5nIGluaXRpYWxpemluZyBkYXRhLlxyXG4gICAgICAgKi9cbiAgICAgIEF4aXNNb2RlbC5wcm90b3R5cGUuZ2V0Q2F0ZWdvcmllcyA9IGZ1bmN0aW9uIChyYXdEYXRhKSB7XG4gICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLy8gd2FybmluZyBpZiBjYWxsZWQgYmVmb3JlIGFsbCBvZiAnZ2V0SW5pdGFpbERhdGEnIGZpbmlzaGVkLlxuICAgICAgICBpZiAob3B0aW9uLnR5cGUgPT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgICBpZiAocmF3RGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5kYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fX29yZGluYWxNZXRhLmNhdGVnb3JpZXM7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBBeGlzTW9kZWwucHJvdG90eXBlLmdldE9yZGluYWxNZXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29yZGluYWxNZXRhO1xuICAgICAgfTtcbiAgICAgIEF4aXNNb2RlbC50eXBlID0gYXhpc05hbWUgKyAnQXhpcy4nICsgYXhpc1R5cGU7XG4gICAgICBBeGlzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IGRlZmF1bHRPcHRpb247XG4gICAgICByZXR1cm4gQXhpc01vZGVsO1xuICAgIH0oQmFzZUF4aXNNb2RlbENsYXNzKTtcbiAgICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChBeGlzTW9kZWwpO1xuICB9KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlcihheGlzTmFtZSArICdBeGlzJywgZ2V0QXhpc1R5cGUpO1xufVxuZnVuY3Rpb24gZ2V0QXhpc1R5cGUob3B0aW9uKSB7XG4gIC8vIERlZmF1bHQgYXhpcyB3aXRoIGRhdGEgaXMgY2F0ZWdvcnkgYXhpc1xuICByZXR1cm4gb3B0aW9uLnR5cGUgfHwgKG9wdGlvbi5kYXRhID8gJ2NhdGVnb3J5JyA6ICd2YWx1ZScpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///59470\n")},99031:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dt: () => (/* binding */ getAxisRawValue),\n/* harmony export */   JJ: () => (/* binding */ ifAxisCrossZero),\n/* harmony export */   Og: () => (/* binding */ estimateLabelUnionRect),\n/* harmony export */   PJ: () => (/* binding */ shouldShowAllLabels),\n/* harmony export */   PN: () => (/* binding */ unionAxisExtentFromData),\n/* harmony export */   Rx: () => (/* binding */ getScaleExtent),\n/* harmony export */   af: () => (/* binding */ niceScaleExtent),\n/* harmony export */   f$: () => (/* binding */ createScaleByModel),\n/* harmony export */   j2: () => (/* binding */ getOptionCategoryInterval),\n/* harmony export */   ry: () => (/* binding */ makeLabelFormatter),\n/* harmony export */   wq: () => (/* binding */ getDataDimensionsOnAxis)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _scale_Ordinal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18550);\n/* harmony import */ var _scale_Interval_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(74562);\n/* harmony import */ var _scale_Scale_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(28613);\n/* harmony import */ var _layout_barGrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62536);\n/* harmony import */ var zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(29308);\n/* harmony import */ var _scale_Time_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12706);\n/* harmony import */ var _scale_Log_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(48605);\n/* harmony import */ var _data_helper_dataStackHelper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(65008);\n/* harmony import */ var _scaleRawExtentInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42262);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n/**\r\n * Get axis scale extent before niced.\r\n * Item of returned array can only be number (including Infinity and NaN).\r\n *\r\n * Caution:\r\n * Precondition of calling this method:\r\n * The scale extent has been initialized using series data extent via\r\n * `scale.setExtent` or `scale.unionExtentFromData`;\r\n */\nfunction getScaleExtent(scale, model) {\n  var scaleType = scale.type;\n  var rawExtentResult = (0,_scaleRawExtentInfo_js__WEBPACK_IMPORTED_MODULE_0__/* .ensureScaleRawExtentInfo */ .Tc)(scale, model, scale.getExtent()).calculate();\n  scale.setBlank(rawExtentResult.isBlank);\n  var min = rawExtentResult.min;\n  var max = rawExtentResult.max;\n  // If bars are placed on a base axis of type time or interval account for axis boundary overflow and current axis\n  // is base axis\n  // FIXME\n  // (1) Consider support value axis, where below zero and axis `onZero` should be handled properly.\n  // (2) Refactor the logic with `barGrid`. Is it not need to `makeBarWidthAndOffsetInfo` twice with different extent?\n  //     Should not depend on series type `bar`?\n  // (3) Fix that might overlap when using dataZoom.\n  // (4) Consider other chart types using `barGrid`?\n  // See #6728, #4862, `test/bar-overflow-time-plot.html`\n  var ecModel = model.ecModel;\n  if (ecModel && scaleType === 'time' /* || scaleType === 'interval' */) {\n    var barSeriesModels = (0,_layout_barGrid_js__WEBPACK_IMPORTED_MODULE_1__/* .prepareLayoutBarSeries */ .GL)('bar', ecModel);\n    var isBaseAxisAndHasBarSeries_1 = false;\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each(barSeriesModels, function (seriesModel) {\n      isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;\n    });\n    if (isBaseAxisAndHasBarSeries_1) {\n      // Calculate placement of bars on axis. TODO should be decoupled\n      // with barLayout\n      var barWidthAndOffset = (0,_layout_barGrid_js__WEBPACK_IMPORTED_MODULE_1__/* .makeColumnLayout */ .vq)(barSeriesModels);\n      // Adjust axis min and max to account for overflow\n      var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);\n      min = adjustedScale.min;\n      max = adjustedScale.max;\n    }\n  }\n  return {\n    extent: [min, max],\n    // \"fix\" means \"fixed\", the value should not be\n    // changed in the subsequent steps.\n    fixMin: rawExtentResult.minFixed,\n    fixMax: rawExtentResult.maxFixed\n  };\n}\nfunction adjustScaleForOverflow(min, max, model,\n// Only support cartesian coord yet.\nbarWidthAndOffset) {\n  // Get Axis Length\n  var axisExtent = model.axis.getExtent();\n  var axisLength = Math.abs(axisExtent[1] - axisExtent[0]);\n  // Get bars on current base axis and calculate min and max overflow\n  var barsOnCurrentAxis = (0,_layout_barGrid_js__WEBPACK_IMPORTED_MODULE_1__/* .retrieveColumnLayout */ .VA)(barWidthAndOffset, model.axis);\n  if (barsOnCurrentAxis === undefined) {\n    return {\n      min: min,\n      max: max\n    };\n  }\n  var minOverflow = Infinity;\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each(barsOnCurrentAxis, function (item) {\n    minOverflow = Math.min(item.offset, minOverflow);\n  });\n  var maxOverflow = -Infinity;\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each(barsOnCurrentAxis, function (item) {\n    maxOverflow = Math.max(item.offset + item.width, maxOverflow);\n  });\n  minOverflow = Math.abs(minOverflow);\n  maxOverflow = Math.abs(maxOverflow);\n  var totalOverFlow = minOverflow + maxOverflow;\n  // Calculate required buffer based on old range and overflow\n  var oldRange = max - min;\n  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;\n  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;\n  max += overflowBuffer * (maxOverflow / totalOverFlow);\n  min -= overflowBuffer * (minOverflow / totalOverFlow);\n  return {\n    min: min,\n    max: max\n  };\n}\n// Precondition of calling this method:\n// The scale extent has been initialized using series data extent via\n// `scale.setExtent` or `scale.unionExtentFromData`;\nfunction niceScaleExtent(scale, inModel) {\n  var model = inModel;\n  var extentInfo = getScaleExtent(scale, model);\n  var extent = extentInfo.extent;\n  var splitNumber = model.get('splitNumber');\n  if (scale instanceof _scale_Log_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A) {\n    scale.base = model.get('logBase');\n  }\n  var scaleType = scale.type;\n  var interval = model.get('interval');\n  var isIntervalOrTime = scaleType === 'interval' || scaleType === 'time';\n  scale.setExtent(extent[0], extent[1]);\n  scale.calcNiceExtent({\n    splitNumber: splitNumber,\n    fixMin: extentInfo.fixMin,\n    fixMax: extentInfo.fixMax,\n    minInterval: isIntervalOrTime ? model.get('minInterval') : null,\n    maxInterval: isIntervalOrTime ? model.get('maxInterval') : null\n  });\n  // If some one specified the min, max. And the default calculated interval\n  // is not good enough. He can specify the interval. It is often appeared\n  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n  // to be 60.\n  // FIXME\n  if (interval != null) {\n    scale.setInterval && scale.setInterval(interval);\n  }\n}\n/**\r\n * @param axisType Default retrieve from model.type\r\n */\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new _scale_Ordinal_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A({\n          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),\n          extent: [Infinity, -Infinity]\n        });\n      case 'time':\n        return new _scale_Time_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A({\n          locale: model.ecModel.getLocaleModel(),\n          useUTC: model.ecModel.get('useUTC')\n        });\n      default:\n        // case 'value'/'interval', 'log', or others.\n        return new (_scale_Scale_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A.getClass(axisType) || _scale_Interval_js__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .A)();\n    }\n  }\n}\n/**\r\n * Check if the axis cross 0\r\n */\nfunction ifAxisCrossZero(axis) {\n  var dataExtent = axis.scale.getExtent();\n  var min = dataExtent[0];\n  var max = dataExtent[1];\n  return !(min > 0 && max > 0 || min < 0 && max < 0);\n}\n/**\r\n * @param axis\r\n * @return Label formatter function.\r\n *         param: {number} tickValue,\r\n *         param: {number} idx, the index in all ticks.\r\n *                         If category axis, this param is not required.\r\n *         return: {string} label string.\r\n */\nfunction makeLabelFormatter(axis) {\n  var labelFormatter = axis.getLabelModel().get('formatter');\n  var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;\n  if (axis.scale.type === 'time') {\n    return function (tpl) {\n      return function (tick, idx) {\n        return axis.scale.getFormattedLabel(tick, idx, tpl);\n      };\n    }(labelFormatter);\n  } else if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isString(labelFormatter)) {\n    return function (tpl) {\n      return function (tick) {\n        // For category axis, get raw value; for numeric axis,\n        // get formatted label like '1,333,444'.\n        var label = axis.scale.getLabel(tick);\n        var text = tpl.replace('{value}', label != null ? label : '');\n        return text;\n      };\n    }(labelFormatter);\n  } else if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isFunction(labelFormatter)) {\n    return function (cb) {\n      return function (tick, idx) {\n        // The original intention of `idx` is \"the index of the tick in all ticks\".\n        // But the previous implementation of category axis do not consider the\n        // `axisLabel.interval`, which cause that, for example, the `interval` is\n        // `1`, then the ticks \"name5\", \"name7\", \"name9\" are displayed, where the\n        // corresponding `idx` are `0`, `2`, `4`, but not `0`, `1`, `2`. So we keep\n        // the definition here for back compatibility.\n        if (categoryTickStart != null) {\n          idx = tick.value - categoryTickStart;\n        }\n        return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {\n          level: tick.level\n        } : null);\n      };\n    }(labelFormatter);\n  } else {\n    return function (tick) {\n      return axis.scale.getLabel(tick);\n    };\n  }\n}\nfunction getAxisRawValue(axis, tick) {\n  // In category axis with data zoom, tick is not the original\n  // index of axis.data. So tick should not be exposed to user\n  // in category axis.\n  return axis.type === 'category' ? axis.scale.getLabel(tick) : tick.value;\n}\n/**\r\n * @param axis\r\n * @return Be null/undefined if no labels.\r\n */\nfunction estimateLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var scale = axis.scale;\n  if (!axisModel.get(['axisLabel', 'show']) || scale.isBlank()) {\n    return;\n  }\n  var realNumberScaleTicks;\n  var tickCount;\n  var categoryScaleExtent = scale.getExtent();\n  // Optimize for large category data, avoid call `getTicks()`.\n  if (scale instanceof _scale_Ordinal_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A) {\n    tickCount = scale.count();\n  } else {\n    realNumberScaleTicks = scale.getTicks();\n    tickCount = realNumberScaleTicks.length;\n  }\n  var axisLabelModel = axis.getLabelModel();\n  var labelFormatter = makeLabelFormatter(axis);\n  var rect;\n  var step = 1;\n  // Simple optimization for large amount of labels\n  if (tickCount > 40) {\n    step = Math.ceil(tickCount / 40);\n  }\n  for (var i = 0; i < tickCount; i += step) {\n    var tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {\n      value: categoryScaleExtent[0] + i\n    };\n    var label = labelFormatter(tick, i);\n    var unrotatedSingleRect = axisLabelModel.getTextRect(label);\n    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n    rect ? rect.union(singleRect) : rect = singleRect;\n  }\n  return rect;\n}\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var beforeWidth = textRect.width;\n  var beforeHeight = textRect.height;\n  var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));\n  var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));\n  var rotatedRect = new zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .A(textRect.x, textRect.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n/**\r\n * @param model axisLabelModel or axisTickModel\r\n * @return {number|String} Can be null|'auto'|number|function\r\n */\nfunction getOptionCategoryInterval(model) {\n  var interval = model.get('interval');\n  return interval == null ? 'auto' : interval;\n}\n/**\r\n * Set `categoryInterval` as 0 implicitly indicates that\r\n * show all labels regardless of overlap.\r\n * @param {Object} axis axisModel.axis\r\n */\nfunction shouldShowAllLabels(axis) {\n  return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0;\n}\nfunction getDataDimensionsOnAxis(data, axisDim) {\n  // Remove duplicated dat dimensions caused by `getStackedDimension`.\n  var dataDimMap = {};\n  // Currently `mapDimensionsAll` will contain stack result dimension ('__\\0ecstackresult').\n  // PENDING: is it reasonable? Do we need to remove the original dim from \"coord dim\" since\n  // there has been stacked result dim?\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each(data.mapDimensionsAll(axisDim), function (dataDim) {\n    // For example, the extent of the original dimension\n    // is [0.1, 0.5], the extent of the `stackResultDimension`\n    // is [7, 9], the final extent should NOT include [0.1, 0.5],\n    // because there is no graphic corresponding to [0.1, 0.5].\n    // See the case in `test/area-stack.html` `main1`, where area line\n    // stack needs `yAxis` not start from 0.\n    dataDimMap[(0,_data_helper_dataStackHelper_js__WEBPACK_IMPORTED_MODULE_9__/* .getStackedDimension */ .me)(data, dataDim)] = true;\n  });\n  return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.keys(dataDimMap);\n}\nfunction unionAxisExtentFromData(dataExtent, data, axisDim) {\n  if (data) {\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each(getDataDimensionsOnAxis(data, axisDim), function (dim) {\n      var seriesExtent = data.getApproximateExtent(dim);\n      seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n      seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n    });\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkwMzEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc0hlbHBlci5qcz83NTBhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgT3JkaW5hbFNjYWxlIGZyb20gJy4uL3NjYWxlL09yZGluYWwuanMnO1xuaW1wb3J0IEludGVydmFsU2NhbGUgZnJvbSAnLi4vc2NhbGUvSW50ZXJ2YWwuanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4uL3NjYWxlL1NjYWxlLmpzJztcbmltcG9ydCB7IHByZXBhcmVMYXlvdXRCYXJTZXJpZXMsIG1ha2VDb2x1bW5MYXlvdXQsIHJldHJpZXZlQ29sdW1uTGF5b3V0IH0gZnJvbSAnLi4vbGF5b3V0L2JhckdyaWQuanMnO1xuaW1wb3J0IEJvdW5kaW5nUmVjdCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcyc7XG5pbXBvcnQgVGltZVNjYWxlIGZyb20gJy4uL3NjYWxlL1RpbWUuanMnO1xuaW1wb3J0IExvZ1NjYWxlIGZyb20gJy4uL3NjYWxlL0xvZy5qcyc7XG5pbXBvcnQgeyBnZXRTdGFja2VkRGltZW5zaW9uIH0gZnJvbSAnLi4vZGF0YS9oZWxwZXIvZGF0YVN0YWNrSGVscGVyLmpzJztcbmltcG9ydCB7IGVuc3VyZVNjYWxlUmF3RXh0ZW50SW5mbyB9IGZyb20gJy4vc2NhbGVSYXdFeHRlbnRJbmZvLmpzJztcbi8qKlxyXG4gKiBHZXQgYXhpcyBzY2FsZSBleHRlbnQgYmVmb3JlIG5pY2VkLlxyXG4gKiBJdGVtIG9mIHJldHVybmVkIGFycmF5IGNhbiBvbmx5IGJlIG51bWJlciAoaW5jbHVkaW5nIEluZmluaXR5IGFuZCBOYU4pLlxyXG4gKlxyXG4gKiBDYXV0aW9uOlxyXG4gKiBQcmVjb25kaXRpb24gb2YgY2FsbGluZyB0aGlzIG1ldGhvZDpcclxuICogVGhlIHNjYWxlIGV4dGVudCBoYXMgYmVlbiBpbml0aWFsaXplZCB1c2luZyBzZXJpZXMgZGF0YSBleHRlbnQgdmlhXHJcbiAqIGBzY2FsZS5zZXRFeHRlbnRgIG9yIGBzY2FsZS51bmlvbkV4dGVudEZyb21EYXRhYDtcclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGVFeHRlbnQoc2NhbGUsIG1vZGVsKSB7XG4gIHZhciBzY2FsZVR5cGUgPSBzY2FsZS50eXBlO1xuICB2YXIgcmF3RXh0ZW50UmVzdWx0ID0gZW5zdXJlU2NhbGVSYXdFeHRlbnRJbmZvKHNjYWxlLCBtb2RlbCwgc2NhbGUuZ2V0RXh0ZW50KCkpLmNhbGN1bGF0ZSgpO1xuICBzY2FsZS5zZXRCbGFuayhyYXdFeHRlbnRSZXN1bHQuaXNCbGFuayk7XG4gIHZhciBtaW4gPSByYXdFeHRlbnRSZXN1bHQubWluO1xuICB2YXIgbWF4ID0gcmF3RXh0ZW50UmVzdWx0Lm1heDtcbiAgLy8gSWYgYmFycyBhcmUgcGxhY2VkIG9uIGEgYmFzZSBheGlzIG9mIHR5cGUgdGltZSBvciBpbnRlcnZhbCBhY2NvdW50IGZvciBheGlzIGJvdW5kYXJ5IG92ZXJmbG93IGFuZCBjdXJyZW50IGF4aXNcbiAgLy8gaXMgYmFzZSBheGlzXG4gIC8vIEZJWE1FXG4gIC8vICgxKSBDb25zaWRlciBzdXBwb3J0IHZhbHVlIGF4aXMsIHdoZXJlIGJlbG93IHplcm8gYW5kIGF4aXMgYG9uWmVyb2Agc2hvdWxkIGJlIGhhbmRsZWQgcHJvcGVybHkuXG4gIC8vICgyKSBSZWZhY3RvciB0aGUgbG9naWMgd2l0aCBgYmFyR3JpZGAuIElzIGl0IG5vdCBuZWVkIHRvIGBtYWtlQmFyV2lkdGhBbmRPZmZzZXRJbmZvYCB0d2ljZSB3aXRoIGRpZmZlcmVudCBleHRlbnQ/XG4gIC8vICAgICBTaG91bGQgbm90IGRlcGVuZCBvbiBzZXJpZXMgdHlwZSBgYmFyYD9cbiAgLy8gKDMpIEZpeCB0aGF0IG1pZ2h0IG92ZXJsYXAgd2hlbiB1c2luZyBkYXRhWm9vbS5cbiAgLy8gKDQpIENvbnNpZGVyIG90aGVyIGNoYXJ0IHR5cGVzIHVzaW5nIGBiYXJHcmlkYD9cbiAgLy8gU2VlICM2NzI4LCAjNDg2MiwgYHRlc3QvYmFyLW92ZXJmbG93LXRpbWUtcGxvdC5odG1sYFxuICB2YXIgZWNNb2RlbCA9IG1vZGVsLmVjTW9kZWw7XG4gIGlmIChlY01vZGVsICYmIHNjYWxlVHlwZSA9PT0gJ3RpbWUnIC8qIHx8IHNjYWxlVHlwZSA9PT0gJ2ludGVydmFsJyAqLykge1xuICAgIHZhciBiYXJTZXJpZXNNb2RlbHMgPSBwcmVwYXJlTGF5b3V0QmFyU2VyaWVzKCdiYXInLCBlY01vZGVsKTtcbiAgICB2YXIgaXNCYXNlQXhpc0FuZEhhc0JhclNlcmllc18xID0gZmFsc2U7XG4gICAgenJVdGlsLmVhY2goYmFyU2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIGlzQmFzZUF4aXNBbmRIYXNCYXJTZXJpZXNfMSA9IGlzQmFzZUF4aXNBbmRIYXNCYXJTZXJpZXNfMSB8fCBzZXJpZXNNb2RlbC5nZXRCYXNlQXhpcygpID09PSBtb2RlbC5heGlzO1xuICAgIH0pO1xuICAgIGlmIChpc0Jhc2VBeGlzQW5kSGFzQmFyU2VyaWVzXzEpIHtcbiAgICAgIC8vIENhbGN1bGF0ZSBwbGFjZW1lbnQgb2YgYmFycyBvbiBheGlzLiBUT0RPIHNob3VsZCBiZSBkZWNvdXBsZWRcbiAgICAgIC8vIHdpdGggYmFyTGF5b3V0XG4gICAgICB2YXIgYmFyV2lkdGhBbmRPZmZzZXQgPSBtYWtlQ29sdW1uTGF5b3V0KGJhclNlcmllc01vZGVscyk7XG4gICAgICAvLyBBZGp1c3QgYXhpcyBtaW4gYW5kIG1heCB0byBhY2NvdW50IGZvciBvdmVyZmxvd1xuICAgICAgdmFyIGFkanVzdGVkU2NhbGUgPSBhZGp1c3RTY2FsZUZvck92ZXJmbG93KG1pbiwgbWF4LCBtb2RlbCwgYmFyV2lkdGhBbmRPZmZzZXQpO1xuICAgICAgbWluID0gYWRqdXN0ZWRTY2FsZS5taW47XG4gICAgICBtYXggPSBhZGp1c3RlZFNjYWxlLm1heDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBleHRlbnQ6IFttaW4sIG1heF0sXG4gICAgLy8gXCJmaXhcIiBtZWFucyBcImZpeGVkXCIsIHRoZSB2YWx1ZSBzaG91bGQgbm90IGJlXG4gICAgLy8gY2hhbmdlZCBpbiB0aGUgc3Vic2VxdWVudCBzdGVwcy5cbiAgICBmaXhNaW46IHJhd0V4dGVudFJlc3VsdC5taW5GaXhlZCxcbiAgICBmaXhNYXg6IHJhd0V4dGVudFJlc3VsdC5tYXhGaXhlZFxuICB9O1xufVxuZnVuY3Rpb24gYWRqdXN0U2NhbGVGb3JPdmVyZmxvdyhtaW4sIG1heCwgbW9kZWwsXG4vLyBPbmx5IHN1cHBvcnQgY2FydGVzaWFuIGNvb3JkIHlldC5cbmJhcldpZHRoQW5kT2Zmc2V0KSB7XG4gIC8vIEdldCBBeGlzIExlbmd0aFxuICB2YXIgYXhpc0V4dGVudCA9IG1vZGVsLmF4aXMuZ2V0RXh0ZW50KCk7XG4gIHZhciBheGlzTGVuZ3RoID0gTWF0aC5hYnMoYXhpc0V4dGVudFsxXSAtIGF4aXNFeHRlbnRbMF0pO1xuICAvLyBHZXQgYmFycyBvbiBjdXJyZW50IGJhc2UgYXhpcyBhbmQgY2FsY3VsYXRlIG1pbiBhbmQgbWF4IG92ZXJmbG93XG4gIHZhciBiYXJzT25DdXJyZW50QXhpcyA9IHJldHJpZXZlQ29sdW1uTGF5b3V0KGJhcldpZHRoQW5kT2Zmc2V0LCBtb2RlbC5heGlzKTtcbiAgaWYgKGJhcnNPbkN1cnJlbnRBeGlzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBtaW4sXG4gICAgICBtYXg6IG1heFxuICAgIH07XG4gIH1cbiAgdmFyIG1pbk92ZXJmbG93ID0gSW5maW5pdHk7XG4gIHpyVXRpbC5lYWNoKGJhcnNPbkN1cnJlbnRBeGlzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgIG1pbk92ZXJmbG93ID0gTWF0aC5taW4oaXRlbS5vZmZzZXQsIG1pbk92ZXJmbG93KTtcbiAgfSk7XG4gIHZhciBtYXhPdmVyZmxvdyA9IC1JbmZpbml0eTtcbiAgenJVdGlsLmVhY2goYmFyc09uQ3VycmVudEF4aXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgbWF4T3ZlcmZsb3cgPSBNYXRoLm1heChpdGVtLm9mZnNldCArIGl0ZW0ud2lkdGgsIG1heE92ZXJmbG93KTtcbiAgfSk7XG4gIG1pbk92ZXJmbG93ID0gTWF0aC5hYnMobWluT3ZlcmZsb3cpO1xuICBtYXhPdmVyZmxvdyA9IE1hdGguYWJzKG1heE92ZXJmbG93KTtcbiAgdmFyIHRvdGFsT3ZlckZsb3cgPSBtaW5PdmVyZmxvdyArIG1heE92ZXJmbG93O1xuICAvLyBDYWxjdWxhdGUgcmVxdWlyZWQgYnVmZmVyIGJhc2VkIG9uIG9sZCByYW5nZSBhbmQgb3ZlcmZsb3dcbiAgdmFyIG9sZFJhbmdlID0gbWF4IC0gbWluO1xuICB2YXIgb2xkUmFuZ2VQZXJjZW50T2ZOZXcgPSAxIC0gKG1pbk92ZXJmbG93ICsgbWF4T3ZlcmZsb3cpIC8gYXhpc0xlbmd0aDtcbiAgdmFyIG92ZXJmbG93QnVmZmVyID0gb2xkUmFuZ2UgLyBvbGRSYW5nZVBlcmNlbnRPZk5ldyAtIG9sZFJhbmdlO1xuICBtYXggKz0gb3ZlcmZsb3dCdWZmZXIgKiAobWF4T3ZlcmZsb3cgLyB0b3RhbE92ZXJGbG93KTtcbiAgbWluIC09IG92ZXJmbG93QnVmZmVyICogKG1pbk92ZXJmbG93IC8gdG90YWxPdmVyRmxvdyk7XG4gIHJldHVybiB7XG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXhcbiAgfTtcbn1cbi8vIFByZWNvbmRpdGlvbiBvZiBjYWxsaW5nIHRoaXMgbWV0aG9kOlxuLy8gVGhlIHNjYWxlIGV4dGVudCBoYXMgYmVlbiBpbml0aWFsaXplZCB1c2luZyBzZXJpZXMgZGF0YSBleHRlbnQgdmlhXG4vLyBgc2NhbGUuc2V0RXh0ZW50YCBvciBgc2NhbGUudW5pb25FeHRlbnRGcm9tRGF0YWA7XG5leHBvcnQgZnVuY3Rpb24gbmljZVNjYWxlRXh0ZW50KHNjYWxlLCBpbk1vZGVsKSB7XG4gIHZhciBtb2RlbCA9IGluTW9kZWw7XG4gIHZhciBleHRlbnRJbmZvID0gZ2V0U2NhbGVFeHRlbnQoc2NhbGUsIG1vZGVsKTtcbiAgdmFyIGV4dGVudCA9IGV4dGVudEluZm8uZXh0ZW50O1xuICB2YXIgc3BsaXROdW1iZXIgPSBtb2RlbC5nZXQoJ3NwbGl0TnVtYmVyJyk7XG4gIGlmIChzY2FsZSBpbnN0YW5jZW9mIExvZ1NjYWxlKSB7XG4gICAgc2NhbGUuYmFzZSA9IG1vZGVsLmdldCgnbG9nQmFzZScpO1xuICB9XG4gIHZhciBzY2FsZVR5cGUgPSBzY2FsZS50eXBlO1xuICB2YXIgaW50ZXJ2YWwgPSBtb2RlbC5nZXQoJ2ludGVydmFsJyk7XG4gIHZhciBpc0ludGVydmFsT3JUaW1lID0gc2NhbGVUeXBlID09PSAnaW50ZXJ2YWwnIHx8IHNjYWxlVHlwZSA9PT0gJ3RpbWUnO1xuICBzY2FsZS5zZXRFeHRlbnQoZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICBzY2FsZS5jYWxjTmljZUV4dGVudCh7XG4gICAgc3BsaXROdW1iZXI6IHNwbGl0TnVtYmVyLFxuICAgIGZpeE1pbjogZXh0ZW50SW5mby5maXhNaW4sXG4gICAgZml4TWF4OiBleHRlbnRJbmZvLmZpeE1heCxcbiAgICBtaW5JbnRlcnZhbDogaXNJbnRlcnZhbE9yVGltZSA/IG1vZGVsLmdldCgnbWluSW50ZXJ2YWwnKSA6IG51bGwsXG4gICAgbWF4SW50ZXJ2YWw6IGlzSW50ZXJ2YWxPclRpbWUgPyBtb2RlbC5nZXQoJ21heEludGVydmFsJykgOiBudWxsXG4gIH0pO1xuICAvLyBJZiBzb21lIG9uZSBzcGVjaWZpZWQgdGhlIG1pbiwgbWF4LiBBbmQgdGhlIGRlZmF1bHQgY2FsY3VsYXRlZCBpbnRlcnZhbFxuICAvLyBpcyBub3QgZ29vZCBlbm91Z2guIEhlIGNhbiBzcGVjaWZ5IHRoZSBpbnRlcnZhbC4gSXQgaXMgb2Z0ZW4gYXBwZWFyZWRcbiAgLy8gaW4gYW5nbGUgYXhpcyB3aXRoIGFuZ2xlIDAgLSAzNjAuIEludGVydmFsIGNhbGN1bGF0ZWQgaW4gaW50ZXJ2YWwgc2NhbGUgaXMgaGFyZFxuICAvLyB0byBiZSA2MC5cbiAgLy8gRklYTUVcbiAgaWYgKGludGVydmFsICE9IG51bGwpIHtcbiAgICBzY2FsZS5zZXRJbnRlcnZhbCAmJiBzY2FsZS5zZXRJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH1cbn1cbi8qKlxyXG4gKiBAcGFyYW0gYXhpc1R5cGUgRGVmYXVsdCByZXRyaWV2ZSBmcm9tIG1vZGVsLnR5cGVcclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2NhbGVCeU1vZGVsKG1vZGVsLCBheGlzVHlwZSkge1xuICBheGlzVHlwZSA9IGF4aXNUeXBlIHx8IG1vZGVsLmdldCgndHlwZScpO1xuICBpZiAoYXhpc1R5cGUpIHtcbiAgICBzd2l0Y2ggKGF4aXNUeXBlKSB7XG4gICAgICAvLyBCdWlsZGluIHNjYWxlXG4gICAgICBjYXNlICdjYXRlZ29yeSc6XG4gICAgICAgIHJldHVybiBuZXcgT3JkaW5hbFNjYWxlKHtcbiAgICAgICAgICBvcmRpbmFsTWV0YTogbW9kZWwuZ2V0T3JkaW5hbE1ldGEgPyBtb2RlbC5nZXRPcmRpbmFsTWV0YSgpIDogbW9kZWwuZ2V0Q2F0ZWdvcmllcygpLFxuICAgICAgICAgIGV4dGVudDogW0luZmluaXR5LCAtSW5maW5pdHldXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgIHJldHVybiBuZXcgVGltZVNjYWxlKHtcbiAgICAgICAgICBsb2NhbGU6IG1vZGVsLmVjTW9kZWwuZ2V0TG9jYWxlTW9kZWwoKSxcbiAgICAgICAgICB1c2VVVEM6IG1vZGVsLmVjTW9kZWwuZ2V0KCd1c2VVVEMnKVxuICAgICAgICB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGNhc2UgJ3ZhbHVlJy8naW50ZXJ2YWwnLCAnbG9nJywgb3Igb3RoZXJzLlxuICAgICAgICByZXR1cm4gbmV3IChTY2FsZS5nZXRDbGFzcyhheGlzVHlwZSkgfHwgSW50ZXJ2YWxTY2FsZSkoKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgYXhpcyBjcm9zcyAwXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlmQXhpc0Nyb3NzWmVybyhheGlzKSB7XG4gIHZhciBkYXRhRXh0ZW50ID0gYXhpcy5zY2FsZS5nZXRFeHRlbnQoKTtcbiAgdmFyIG1pbiA9IGRhdGFFeHRlbnRbMF07XG4gIHZhciBtYXggPSBkYXRhRXh0ZW50WzFdO1xuICByZXR1cm4gIShtaW4gPiAwICYmIG1heCA+IDAgfHwgbWluIDwgMCAmJiBtYXggPCAwKTtcbn1cbi8qKlxyXG4gKiBAcGFyYW0gYXhpc1xyXG4gKiBAcmV0dXJuIExhYmVsIGZvcm1hdHRlciBmdW5jdGlvbi5cclxuICogICAgICAgICBwYXJhbToge251bWJlcn0gdGlja1ZhbHVlLFxyXG4gKiAgICAgICAgIHBhcmFtOiB7bnVtYmVyfSBpZHgsIHRoZSBpbmRleCBpbiBhbGwgdGlja3MuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIElmIGNhdGVnb3J5IGF4aXMsIHRoaXMgcGFyYW0gaXMgbm90IHJlcXVpcmVkLlxyXG4gKiAgICAgICAgIHJldHVybjoge3N0cmluZ30gbGFiZWwgc3RyaW5nLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTGFiZWxGb3JtYXR0ZXIoYXhpcykge1xuICB2YXIgbGFiZWxGb3JtYXR0ZXIgPSBheGlzLmdldExhYmVsTW9kZWwoKS5nZXQoJ2Zvcm1hdHRlcicpO1xuICB2YXIgY2F0ZWdvcnlUaWNrU3RhcnQgPSBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyBheGlzLnNjYWxlLmdldEV4dGVudCgpWzBdIDogbnVsbDtcbiAgaWYgKGF4aXMuc2NhbGUudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0cGwpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodGljaywgaWR4KSB7XG4gICAgICAgIHJldHVybiBheGlzLnNjYWxlLmdldEZvcm1hdHRlZExhYmVsKHRpY2ssIGlkeCwgdHBsKTtcbiAgICAgIH07XG4gICAgfShsYWJlbEZvcm1hdHRlcik7XG4gIH0gZWxzZSBpZiAoenJVdGlsLmlzU3RyaW5nKGxhYmVsRm9ybWF0dGVyKSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodHBsKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgICAgLy8gRm9yIGNhdGVnb3J5IGF4aXMsIGdldCByYXcgdmFsdWU7IGZvciBudW1lcmljIGF4aXMsXG4gICAgICAgIC8vIGdldCBmb3JtYXR0ZWQgbGFiZWwgbGlrZSAnMSwzMzMsNDQ0Jy5cbiAgICAgICAgdmFyIGxhYmVsID0gYXhpcy5zY2FsZS5nZXRMYWJlbCh0aWNrKTtcbiAgICAgICAgdmFyIHRleHQgPSB0cGwucmVwbGFjZSgne3ZhbHVlfScsIGxhYmVsICE9IG51bGwgPyBsYWJlbCA6ICcnKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9O1xuICAgIH0obGFiZWxGb3JtYXR0ZXIpO1xuICB9IGVsc2UgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKGxhYmVsRm9ybWF0dGVyKSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodGljaywgaWR4KSB7XG4gICAgICAgIC8vIFRoZSBvcmlnaW5hbCBpbnRlbnRpb24gb2YgYGlkeGAgaXMgXCJ0aGUgaW5kZXggb2YgdGhlIHRpY2sgaW4gYWxsIHRpY2tzXCIuXG4gICAgICAgIC8vIEJ1dCB0aGUgcHJldmlvdXMgaW1wbGVtZW50YXRpb24gb2YgY2F0ZWdvcnkgYXhpcyBkbyBub3QgY29uc2lkZXIgdGhlXG4gICAgICAgIC8vIGBheGlzTGFiZWwuaW50ZXJ2YWxgLCB3aGljaCBjYXVzZSB0aGF0LCBmb3IgZXhhbXBsZSwgdGhlIGBpbnRlcnZhbGAgaXNcbiAgICAgICAgLy8gYDFgLCB0aGVuIHRoZSB0aWNrcyBcIm5hbWU1XCIsIFwibmFtZTdcIiwgXCJuYW1lOVwiIGFyZSBkaXNwbGF5ZWQsIHdoZXJlIHRoZVxuICAgICAgICAvLyBjb3JyZXNwb25kaW5nIGBpZHhgIGFyZSBgMGAsIGAyYCwgYDRgLCBidXQgbm90IGAwYCwgYDFgLCBgMmAuIFNvIHdlIGtlZXBcbiAgICAgICAgLy8gdGhlIGRlZmluaXRpb24gaGVyZSBmb3IgYmFjayBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoY2F0ZWdvcnlUaWNrU3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgIGlkeCA9IHRpY2sudmFsdWUgLSBjYXRlZ29yeVRpY2tTdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2IoZ2V0QXhpc1Jhd1ZhbHVlKGF4aXMsIHRpY2spLCBpZHgsIHRpY2subGV2ZWwgIT0gbnVsbCA/IHtcbiAgICAgICAgICBsZXZlbDogdGljay5sZXZlbFxuICAgICAgICB9IDogbnVsbCk7XG4gICAgICB9O1xuICAgIH0obGFiZWxGb3JtYXR0ZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGljaykge1xuICAgICAgcmV0dXJuIGF4aXMuc2NhbGUuZ2V0TGFiZWwodGljayk7XG4gICAgfTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEF4aXNSYXdWYWx1ZShheGlzLCB0aWNrKSB7XG4gIC8vIEluIGNhdGVnb3J5IGF4aXMgd2l0aCBkYXRhIHpvb20sIHRpY2sgaXMgbm90IHRoZSBvcmlnaW5hbFxuICAvLyBpbmRleCBvZiBheGlzLmRhdGEuIFNvIHRpY2sgc2hvdWxkIG5vdCBiZSBleHBvc2VkIHRvIHVzZXJcbiAgLy8gaW4gY2F0ZWdvcnkgYXhpcy5cbiAgcmV0dXJuIGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IGF4aXMuc2NhbGUuZ2V0TGFiZWwodGljaykgOiB0aWNrLnZhbHVlO1xufVxuLyoqXHJcbiAqIEBwYXJhbSBheGlzXHJcbiAqIEByZXR1cm4gQmUgbnVsbC91bmRlZmluZWQgaWYgbm8gbGFiZWxzLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc3RpbWF0ZUxhYmVsVW5pb25SZWN0KGF4aXMpIHtcbiAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gIHZhciBzY2FsZSA9IGF4aXMuc2NhbGU7XG4gIGlmICghYXhpc01vZGVsLmdldChbJ2F4aXNMYWJlbCcsICdzaG93J10pIHx8IHNjYWxlLmlzQmxhbmsoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVhbE51bWJlclNjYWxlVGlja3M7XG4gIHZhciB0aWNrQ291bnQ7XG4gIHZhciBjYXRlZ29yeVNjYWxlRXh0ZW50ID0gc2NhbGUuZ2V0RXh0ZW50KCk7XG4gIC8vIE9wdGltaXplIGZvciBsYXJnZSBjYXRlZ29yeSBkYXRhLCBhdm9pZCBjYWxsIGBnZXRUaWNrcygpYC5cbiAgaWYgKHNjYWxlIGluc3RhbmNlb2YgT3JkaW5hbFNjYWxlKSB7XG4gICAgdGlja0NvdW50ID0gc2NhbGUuY291bnQoKTtcbiAgfSBlbHNlIHtcbiAgICByZWFsTnVtYmVyU2NhbGVUaWNrcyA9IHNjYWxlLmdldFRpY2tzKCk7XG4gICAgdGlja0NvdW50ID0gcmVhbE51bWJlclNjYWxlVGlja3MubGVuZ3RoO1xuICB9XG4gIHZhciBheGlzTGFiZWxNb2RlbCA9IGF4aXMuZ2V0TGFiZWxNb2RlbCgpO1xuICB2YXIgbGFiZWxGb3JtYXR0ZXIgPSBtYWtlTGFiZWxGb3JtYXR0ZXIoYXhpcyk7XG4gIHZhciByZWN0O1xuICB2YXIgc3RlcCA9IDE7XG4gIC8vIFNpbXBsZSBvcHRpbWl6YXRpb24gZm9yIGxhcmdlIGFtb3VudCBvZiBsYWJlbHNcbiAgaWYgKHRpY2tDb3VudCA+IDQwKSB7XG4gICAgc3RlcCA9IE1hdGguY2VpbCh0aWNrQ291bnQgLyA0MCk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrQ291bnQ7IGkgKz0gc3RlcCkge1xuICAgIHZhciB0aWNrID0gcmVhbE51bWJlclNjYWxlVGlja3MgPyByZWFsTnVtYmVyU2NhbGVUaWNrc1tpXSA6IHtcbiAgICAgIHZhbHVlOiBjYXRlZ29yeVNjYWxlRXh0ZW50WzBdICsgaVxuICAgIH07XG4gICAgdmFyIGxhYmVsID0gbGFiZWxGb3JtYXR0ZXIodGljaywgaSk7XG4gICAgdmFyIHVucm90YXRlZFNpbmdsZVJlY3QgPSBheGlzTGFiZWxNb2RlbC5nZXRUZXh0UmVjdChsYWJlbCk7XG4gICAgdmFyIHNpbmdsZVJlY3QgPSByb3RhdGVUZXh0UmVjdCh1bnJvdGF0ZWRTaW5nbGVSZWN0LCBheGlzTGFiZWxNb2RlbC5nZXQoJ3JvdGF0ZScpIHx8IDApO1xuICAgIHJlY3QgPyByZWN0LnVuaW9uKHNpbmdsZVJlY3QpIDogcmVjdCA9IHNpbmdsZVJlY3Q7XG4gIH1cbiAgcmV0dXJuIHJlY3Q7XG59XG5mdW5jdGlvbiByb3RhdGVUZXh0UmVjdCh0ZXh0UmVjdCwgcm90YXRlKSB7XG4gIHZhciByb3RhdGVSYWRpYW5zID0gcm90YXRlICogTWF0aC5QSSAvIDE4MDtcbiAgdmFyIGJlZm9yZVdpZHRoID0gdGV4dFJlY3Qud2lkdGg7XG4gIHZhciBiZWZvcmVIZWlnaHQgPSB0ZXh0UmVjdC5oZWlnaHQ7XG4gIHZhciBhZnRlcldpZHRoID0gYmVmb3JlV2lkdGggKiBNYXRoLmFicyhNYXRoLmNvcyhyb3RhdGVSYWRpYW5zKSkgKyBNYXRoLmFicyhiZWZvcmVIZWlnaHQgKiBNYXRoLnNpbihyb3RhdGVSYWRpYW5zKSk7XG4gIHZhciBhZnRlckhlaWdodCA9IGJlZm9yZVdpZHRoICogTWF0aC5hYnMoTWF0aC5zaW4ocm90YXRlUmFkaWFucykpICsgTWF0aC5hYnMoYmVmb3JlSGVpZ2h0ICogTWF0aC5jb3Mocm90YXRlUmFkaWFucykpO1xuICB2YXIgcm90YXRlZFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHRleHRSZWN0LngsIHRleHRSZWN0LnksIGFmdGVyV2lkdGgsIGFmdGVySGVpZ2h0KTtcbiAgcmV0dXJuIHJvdGF0ZWRSZWN0O1xufVxuLyoqXHJcbiAqIEBwYXJhbSBtb2RlbCBheGlzTGFiZWxNb2RlbCBvciBheGlzVGlja01vZGVsXHJcbiAqIEByZXR1cm4ge251bWJlcnxTdHJpbmd9IENhbiBiZSBudWxsfCdhdXRvJ3xudW1iZXJ8ZnVuY3Rpb25cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3B0aW9uQ2F0ZWdvcnlJbnRlcnZhbChtb2RlbCkge1xuICB2YXIgaW50ZXJ2YWwgPSBtb2RlbC5nZXQoJ2ludGVydmFsJyk7XG4gIHJldHVybiBpbnRlcnZhbCA9PSBudWxsID8gJ2F1dG8nIDogaW50ZXJ2YWw7XG59XG4vKipcclxuICogU2V0IGBjYXRlZ29yeUludGVydmFsYCBhcyAwIGltcGxpY2l0bHkgaW5kaWNhdGVzIHRoYXRcclxuICogc2hvdyBhbGwgbGFiZWxzIHJlZ2FyZGxlc3Mgb2Ygb3ZlcmxhcC5cclxuICogQHBhcmFtIHtPYmplY3R9IGF4aXMgYXhpc01vZGVsLmF4aXNcclxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkU2hvd0FsbExhYmVscyhheGlzKSB7XG4gIHJldHVybiBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgJiYgZ2V0T3B0aW9uQ2F0ZWdvcnlJbnRlcnZhbChheGlzLmdldExhYmVsTW9kZWwoKSkgPT09IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YURpbWVuc2lvbnNPbkF4aXMoZGF0YSwgYXhpc0RpbSkge1xuICAvLyBSZW1vdmUgZHVwbGljYXRlZCBkYXQgZGltZW5zaW9ucyBjYXVzZWQgYnkgYGdldFN0YWNrZWREaW1lbnNpb25gLlxuICB2YXIgZGF0YURpbU1hcCA9IHt9O1xuICAvLyBDdXJyZW50bHkgYG1hcERpbWVuc2lvbnNBbGxgIHdpbGwgY29udGFpbiBzdGFjayByZXN1bHQgZGltZW5zaW9uICgnX19cXDBlY3N0YWNrcmVzdWx0JykuXG4gIC8vIFBFTkRJTkc6IGlzIGl0IHJlYXNvbmFibGU/IERvIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBvcmlnaW5hbCBkaW0gZnJvbSBcImNvb3JkIGRpbVwiIHNpbmNlXG4gIC8vIHRoZXJlIGhhcyBiZWVuIHN0YWNrZWQgcmVzdWx0IGRpbT9cbiAgenJVdGlsLmVhY2goZGF0YS5tYXBEaW1lbnNpb25zQWxsKGF4aXNEaW0pLCBmdW5jdGlvbiAoZGF0YURpbSkge1xuICAgIC8vIEZvciBleGFtcGxlLCB0aGUgZXh0ZW50IG9mIHRoZSBvcmlnaW5hbCBkaW1lbnNpb25cbiAgICAvLyBpcyBbMC4xLCAwLjVdLCB0aGUgZXh0ZW50IG9mIHRoZSBgc3RhY2tSZXN1bHREaW1lbnNpb25gXG4gICAgLy8gaXMgWzcsIDldLCB0aGUgZmluYWwgZXh0ZW50IHNob3VsZCBOT1QgaW5jbHVkZSBbMC4xLCAwLjVdLFxuICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gZ3JhcGhpYyBjb3JyZXNwb25kaW5nIHRvIFswLjEsIDAuNV0uXG4gICAgLy8gU2VlIHRoZSBjYXNlIGluIGB0ZXN0L2FyZWEtc3RhY2suaHRtbGAgYG1haW4xYCwgd2hlcmUgYXJlYSBsaW5lXG4gICAgLy8gc3RhY2sgbmVlZHMgYHlBeGlzYCBub3Qgc3RhcnQgZnJvbSAwLlxuICAgIGRhdGFEaW1NYXBbZ2V0U3RhY2tlZERpbWVuc2lvbihkYXRhLCBkYXRhRGltKV0gPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHpyVXRpbC5rZXlzKGRhdGFEaW1NYXApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVuaW9uQXhpc0V4dGVudEZyb21EYXRhKGRhdGFFeHRlbnQsIGRhdGEsIGF4aXNEaW0pIHtcbiAgaWYgKGRhdGEpIHtcbiAgICB6clV0aWwuZWFjaChnZXREYXRhRGltZW5zaW9uc09uQXhpcyhkYXRhLCBheGlzRGltKSwgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgdmFyIHNlcmllc0V4dGVudCA9IGRhdGEuZ2V0QXBwcm94aW1hdGVFeHRlbnQoZGltKTtcbiAgICAgIHNlcmllc0V4dGVudFswXSA8IGRhdGFFeHRlbnRbMF0gJiYgKGRhdGFFeHRlbnRbMF0gPSBzZXJpZXNFeHRlbnRbMF0pO1xuICAgICAgc2VyaWVzRXh0ZW50WzFdID4gZGF0YUV4dGVudFsxXSAmJiAoZGF0YUV4dGVudFsxXSA9IHNlcmllc0V4dGVudFsxXSk7XG4gICAgfSk7XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///99031\n")}}]);