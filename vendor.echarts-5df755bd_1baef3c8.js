"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[1704],{40830:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Component.js\nvar Component = __webpack_require__(15915);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n;// ./node_modules/echarts/lib/component/graphic/GraphicModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n;\n;\n;\nfunction setKeyInfoToNewElOption(resultItem, newElOption) {\n  var existElOption = resultItem.existing;\n  // Set id and type after id assigned.\n  newElOption.id = resultItem.keyInfo.id;\n  !newElOption.type && existElOption && (newElOption.type = existElOption.type);\n  // Set parent id if not specified\n  if (newElOption.parentId == null) {\n    var newElParentOption = newElOption.parentOption;\n    if (newElParentOption) {\n      newElOption.parentId = newElParentOption.id;\n    } else if (existElOption) {\n      newElOption.parentId = existElOption.parentId;\n    }\n  }\n  // Clear\n  newElOption.parentOption = null;\n}\nfunction isSetLoc(obj, props) {\n  var isSet;\n  util.each(props, function (prop) {\n    obj[prop] != null && obj[prop] !== 'auto' && (isSet = true);\n  });\n  return isSet;\n}\nfunction mergeNewElOptionToExist(existList, index, newElOption) {\n  // Update existing options, for `getOption` feature.\n  var newElOptCopy = util.extend({}, newElOption);\n  var existElOption = existList[index];\n  var $action = newElOption.$action || 'merge';\n  if ($action === 'merge') {\n    if (existElOption) {\n      if (false) { var newType; }\n      // We can ensure that newElOptCopy and existElOption are not\n      // the same object, so `merge` will not change newElOptCopy.\n      util.merge(existElOption, newElOptCopy, true);\n      // Rigid body, use ignoreSize.\n      (0,layout/* mergeLayoutParam */.YA)(existElOption, newElOptCopy, {\n        ignoreSize: true\n      });\n      // Will be used in render.\n      (0,layout/* copyLayoutParams */.Ir)(newElOption, existElOption);\n      // Copy transition info to new option so it can be used in the transition.\n      // DO IT AFTER merge\n      copyTransitionInfo(newElOption, existElOption);\n      copyTransitionInfo(newElOption, existElOption, 'shape');\n      copyTransitionInfo(newElOption, existElOption, 'style');\n      copyTransitionInfo(newElOption, existElOption, 'extra');\n      // Copy clipPath\n      newElOption.clipPath = existElOption.clipPath;\n    } else {\n      existList[index] = newElOptCopy;\n    }\n  } else if ($action === 'replace') {\n    existList[index] = newElOptCopy;\n  } else if ($action === 'remove') {\n    // null will be cleaned later.\n    existElOption && (existList[index] = null);\n  }\n}\nvar TRANSITION_PROPS_TO_COPY = ['transition', 'enterFrom', 'leaveTo'];\nvar ROOT_TRANSITION_PROPS_TO_COPY = TRANSITION_PROPS_TO_COPY.concat(['enterAnimation', 'updateAnimation', 'leaveAnimation']);\nfunction copyTransitionInfo(target, source, targetProp) {\n  if (targetProp) {\n    if (!target[targetProp] && source[targetProp]) {\n      // TODO avoid creating this empty object when there is no transition configuration.\n      target[targetProp] = {};\n    }\n    target = target[targetProp];\n    source = source[targetProp];\n  }\n  if (!target || !source) {\n    return;\n  }\n  var props = targetProp ? TRANSITION_PROPS_TO_COPY : ROOT_TRANSITION_PROPS_TO_COPY;\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    if (target[prop] == null && source[prop] != null) {\n      target[prop] = source[prop];\n    }\n  }\n}\nfunction setLayoutInfoToExist(existItem, newElOption) {\n  if (!existItem) {\n    return;\n  }\n  existItem.hv = newElOption.hv = [\n  // Rigid body, don't care about `width`.\n  isSetLoc(newElOption, ['left', 'right']),\n  // Rigid body, don't care about `height`.\n  isSetLoc(newElOption, ['top', 'bottom'])];\n  // Give default group size. Otherwise layout error may occur.\n  if (existItem.type === 'group') {\n    var existingGroupOpt = existItem;\n    var newGroupOpt = newElOption;\n    existingGroupOpt.width == null && (existingGroupOpt.width = newGroupOpt.width = 0);\n    existingGroupOpt.height == null && (existingGroupOpt.height = newGroupOpt.height = 0);\n  }\n}\nvar GraphicComponentModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(GraphicComponentModel, _super);\n  function GraphicComponentModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = GraphicComponentModel.type;\n    _this.preventAutoZ = true;\n    return _this;\n  }\n  GraphicComponentModel.prototype.mergeOption = function (option, ecModel) {\n    // Prevent default merge to elements\n    var elements = this.option.elements;\n    this.option.elements = null;\n    _super.prototype.mergeOption.call(this, option, ecModel);\n    this.option.elements = elements;\n  };\n  GraphicComponentModel.prototype.optionUpdated = function (newOption, isInit) {\n    var thisOption = this.option;\n    var newList = (isInit ? thisOption : newOption).elements;\n    var existList = thisOption.elements = isInit ? [] : thisOption.elements;\n    var flattenedList = [];\n    this._flatten(newList, flattenedList, null);\n    var mappingResult = model/* mappingToExists */.O2(existList, flattenedList, 'normalMerge');\n    // Clear elOptionsToUpdate\n    var elOptionsToUpdate = this._elOptionsToUpdate = [];\n    util.each(mappingResult, function (resultItem, index) {\n      var newElOption = resultItem.newOption;\n      if (false) {}\n      if (!newElOption) {\n        return;\n      }\n      elOptionsToUpdate.push(newElOption);\n      setKeyInfoToNewElOption(resultItem, newElOption);\n      mergeNewElOptionToExist(existList, index, newElOption);\n      setLayoutInfoToExist(existList[index], newElOption);\n    }, this);\n    // Clean\n    thisOption.elements = util.filter(existList, function (item) {\n      // $action should be volatile, otherwise option gotten from\n      // `getOption` will contain unexpected $action.\n      item && delete item.$action;\n      return item != null;\n    });\n  };\n  /**\r\n   * Convert\r\n   * [{\r\n   *  type: 'group',\r\n   *  id: 'xx',\r\n   *  children: [{type: 'circle'}, {type: 'polygon'}]\r\n   * }]\r\n   * to\r\n   * [\r\n   *  {type: 'group', id: 'xx'},\r\n   *  {type: 'circle', parentId: 'xx'},\r\n   *  {type: 'polygon', parentId: 'xx'}\r\n   * ]\r\n   */\n  GraphicComponentModel.prototype._flatten = function (optionList, result, parentOption) {\n    util.each(optionList, function (option) {\n      if (!option) {\n        return;\n      }\n      if (parentOption) {\n        option.parentOption = parentOption;\n      }\n      result.push(option);\n      var children = option.children;\n      // here we don't judge if option.type is `group`\n      // when new option doesn't provide `type`, it will cause that the children can't be updated.\n      if (children && children.length) {\n        this._flatten(children, result, option);\n      }\n      // Deleting for JSON output, and for not affecting group creation.\n      delete option.children;\n    }, this);\n  };\n  // FIXME\n  // Pass to view using payload? setOption has a payload?\n  GraphicComponentModel.prototype.useElOptionsToUpdate = function () {\n    var els = this._elOptionsToUpdate;\n    // Clear to avoid render duplicately when zooming.\n    this._elOptionsToUpdate = null;\n    return els;\n  };\n  GraphicComponentModel.type = 'graphic';\n  GraphicComponentModel.defaultOption = {\n    elements: []\n    // parentId: null\n  };\n  return GraphicComponentModel;\n}(Component/* default */.A);\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Displayable.js\nvar Displayable = __webpack_require__(71519);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Image.js\nvar Image = __webpack_require__(90540);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar view_Component = __webpack_require__(59109);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/styleCompat.js\nvar styleCompat = __webpack_require__(9848);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/customGraphicTransition.js\nvar customGraphicTransition = __webpack_require__(57625);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/customGraphicKeyframeAnimation.js\nvar customGraphicKeyframeAnimation = __webpack_require__(92606);\n;// ./node_modules/echarts/lib/component/graphic/GraphicView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar nonShapeGraphicElements = {\n  // Reserved but not supported in graphic component.\n  path: null,\n  compoundPath: null,\n  // Supported in graphic component.\n  group: Group/* default */.A,\n  image: Image/* default */.Ay,\n  text: Text/* default */.Ay\n};\nvar inner = model/* makeInner */.$r();\n// ------------------------\n// View\n// ------------------------\nvar GraphicComponentView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(GraphicComponentView, _super);\n  function GraphicComponentView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = GraphicComponentView.type;\n    return _this;\n  }\n  GraphicComponentView.prototype.init = function () {\n    this._elMap = util.createHashMap();\n  };\n  GraphicComponentView.prototype.render = function (graphicModel, ecModel, api) {\n    // Having leveraged between use cases and algorithm complexity, a very\n    // simple layout mechanism is used:\n    // The size(width/height) can be determined by itself or its parent (not\n    // implemented yet), but can not by its children. (Top-down travel)\n    // The location(x/y) can be determined by the bounding rect of itself\n    // (can including its descendants or not) and the size of its parent.\n    // (Bottom-up travel)\n    // When `chart.clear()` or `chart.setOption({...}, true)` with the same id,\n    // view will be reused.\n    if (graphicModel !== this._lastGraphicModel) {\n      this._clear();\n    }\n    this._lastGraphicModel = graphicModel;\n    this._updateElements(graphicModel);\n    this._relocate(graphicModel, api);\n  };\n  /**\r\n   * Update graphic elements.\r\n   */\n  GraphicComponentView.prototype._updateElements = function (graphicModel) {\n    var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();\n    if (!elOptionsToUpdate) {\n      return;\n    }\n    var elMap = this._elMap;\n    var rootGroup = this.group;\n    var globalZ = graphicModel.get('z');\n    var globalZLevel = graphicModel.get('zlevel');\n    // Top-down tranverse to assign graphic settings to each elements.\n    util.each(elOptionsToUpdate, function (elOption) {\n      var id = model/* convertOptionIdName */.vS(elOption.id, null);\n      var elExisting = id != null ? elMap.get(id) : null;\n      var parentId = model/* convertOptionIdName */.vS(elOption.parentId, null);\n      var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;\n      var elType = elOption.type;\n      var elOptionStyle = elOption.style;\n      if (elType === 'text' && elOptionStyle) {\n        // In top/bottom mode, textVerticalAlign should not be used, which cause\n        // inaccurately locating.\n        if (elOption.hv && elOption.hv[1]) {\n          elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = elOptionStyle.verticalAlign = elOptionStyle.align = null;\n        }\n      }\n      var textContentOption = elOption.textContent;\n      var textConfig = elOption.textConfig;\n      if (elOptionStyle && (0,styleCompat/* isEC4CompatibleStyle */.ex)(elOptionStyle, elType, !!textConfig, !!textContentOption)) {\n        var convertResult = (0,styleCompat/* convertFromEC4CompatibleStyle */.lH)(elOptionStyle, elType, true);\n        if (!textConfig && convertResult.textConfig) {\n          textConfig = elOption.textConfig = convertResult.textConfig;\n        }\n        if (!textContentOption && convertResult.textContent) {\n          textContentOption = convertResult.textContent;\n        }\n      }\n      // Remove unnecessary props to avoid potential problems.\n      var elOptionCleaned = getCleanedElOption(elOption);\n      // For simple, do not support parent change, otherwise reorder is needed.\n      if (false) {}\n      var $action = elOption.$action || 'merge';\n      var isMerge = $action === 'merge';\n      var isReplace = $action === 'replace';\n      if (isMerge) {\n        var isInit = !elExisting;\n        var el_1 = elExisting;\n        if (isInit) {\n          el_1 = createEl(id, targetElParent, elOption.type, elMap);\n        } else {\n          el_1 && (inner(el_1).isNew = false);\n          // Stop and restore before update any other attributes.\n          (0,customGraphicKeyframeAnimation/* stopPreviousKeyframeAnimationAndRestore */.$)(el_1);\n        }\n        if (el_1) {\n          (0,customGraphicTransition/* applyUpdateTransition */.rh)(el_1, elOptionCleaned, graphicModel, {\n            isInit: isInit\n          });\n          updateCommonAttrs(el_1, elOption, globalZ, globalZLevel);\n        }\n      } else if (isReplace) {\n        removeEl(elExisting, elOption, elMap, graphicModel);\n        var el_2 = createEl(id, targetElParent, elOption.type, elMap);\n        if (el_2) {\n          (0,customGraphicTransition/* applyUpdateTransition */.rh)(el_2, elOptionCleaned, graphicModel, {\n            isInit: true\n          });\n          updateCommonAttrs(el_2, elOption, globalZ, globalZLevel);\n        }\n      } else if ($action === 'remove') {\n        (0,customGraphicTransition/* updateLeaveTo */.aB)(elExisting, elOption);\n        removeEl(elExisting, elOption, elMap, graphicModel);\n      }\n      var el = elMap.get(id);\n      if (el && textContentOption) {\n        if (isMerge) {\n          var textContentExisting = el.getTextContent();\n          textContentExisting ? textContentExisting.attr(textContentOption) : el.setTextContent(new Text/* default */.Ay(textContentOption));\n        } else if (isReplace) {\n          el.setTextContent(new Text/* default */.Ay(textContentOption));\n        }\n      }\n      if (el) {\n        var clipPathOption = elOption.clipPath;\n        if (clipPathOption) {\n          var clipPathType = clipPathOption.type;\n          var clipPath = void 0;\n          var isInit = false;\n          if (isMerge) {\n            var oldClipPath = el.getClipPath();\n            isInit = !oldClipPath || inner(oldClipPath).type !== clipPathType;\n            clipPath = isInit ? newEl(clipPathType) : oldClipPath;\n          } else if (isReplace) {\n            isInit = true;\n            clipPath = newEl(clipPathType);\n          }\n          el.setClipPath(clipPath);\n          (0,customGraphicTransition/* applyUpdateTransition */.rh)(clipPath, clipPathOption, graphicModel, {\n            isInit: isInit\n          });\n          (0,customGraphicKeyframeAnimation/* applyKeyframeAnimation */.L)(clipPath, clipPathOption.keyframeAnimation, graphicModel);\n        }\n        var elInner = inner(el);\n        el.setTextConfig(textConfig);\n        elInner.option = elOption;\n        setEventData(el, graphicModel, elOption);\n        graphic.setTooltipConfig({\n          el: el,\n          componentModel: graphicModel,\n          itemName: el.name,\n          itemTooltipOption: elOption.tooltip\n        });\n        (0,customGraphicKeyframeAnimation/* applyKeyframeAnimation */.L)(el, elOption.keyframeAnimation, graphicModel);\n      }\n    });\n  };\n  /**\r\n   * Locate graphic elements.\r\n   */\n  GraphicComponentView.prototype._relocate = function (graphicModel, api) {\n    var elOptions = graphicModel.option.elements;\n    var rootGroup = this.group;\n    var elMap = this._elMap;\n    var apiWidth = api.getWidth();\n    var apiHeight = api.getHeight();\n    var xy = ['x', 'y'];\n    // Top-down to calculate percentage width/height of group\n    for (var i = 0; i < elOptions.length; i++) {\n      var elOption = elOptions[i];\n      var id = model/* convertOptionIdName */.vS(elOption.id, null);\n      var el = id != null ? elMap.get(id) : null;\n      if (!el || !el.isGroup) {\n        continue;\n      }\n      var parentEl = el.parent;\n      var isParentRoot = parentEl === rootGroup;\n      // Like 'position:absolut' in css, default 0.\n      var elInner = inner(el);\n      var parentElInner = inner(parentEl);\n      elInner.width = (0,number/* parsePercent */.lo)(elInner.option.width, isParentRoot ? apiWidth : parentElInner.width) || 0;\n      elInner.height = (0,number/* parsePercent */.lo)(elInner.option.height, isParentRoot ? apiHeight : parentElInner.height) || 0;\n    }\n    // Bottom-up tranvese all elements (consider ec resize) to locate elements.\n    for (var i = elOptions.length - 1; i >= 0; i--) {\n      var elOption = elOptions[i];\n      var id = model/* convertOptionIdName */.vS(elOption.id, null);\n      var el = id != null ? elMap.get(id) : null;\n      if (!el) {\n        continue;\n      }\n      var parentEl = el.parent;\n      var parentElInner = inner(parentEl);\n      var containerInfo = parentEl === rootGroup ? {\n        width: apiWidth,\n        height: apiHeight\n      } : {\n        width: parentElInner.width,\n        height: parentElInner.height\n      };\n      // PENDING\n      // Currently, when `bounding: 'all'`, the union bounding rect of the group\n      // does not include the rect of [0, 0, group.width, group.height], which\n      // is probably weird for users. Should we make a break change for it?\n      var layoutPos = {};\n      var layouted = layout/* positionElement */.m$(el, elOption, containerInfo, null, {\n        hv: elOption.hv,\n        boundingMode: elOption.bounding\n      }, layoutPos);\n      if (!inner(el).isNew && layouted) {\n        var transition = elOption.transition;\n        var animatePos = {};\n        for (var k = 0; k < xy.length; k++) {\n          var key = xy[k];\n          var val = layoutPos[key];\n          if (transition && ((0,customGraphicTransition/* isTransitionAll */.ho)(transition) || util.indexOf(transition, key) >= 0)) {\n            animatePos[key] = val;\n          } else {\n            el[key] = val;\n          }\n        }\n        (0,basicTransition/* updateProps */.oi)(el, animatePos, graphicModel, 0);\n      } else {\n        el.attr(layoutPos);\n      }\n    }\n  };\n  /**\r\n   * Clear all elements.\r\n   */\n  GraphicComponentView.prototype._clear = function () {\n    var _this = this;\n    var elMap = this._elMap;\n    elMap.each(function (el) {\n      removeEl(el, inner(el).option, elMap, _this._lastGraphicModel);\n    });\n    this._elMap = util.createHashMap();\n  };\n  GraphicComponentView.prototype.dispose = function () {\n    this._clear();\n  };\n  GraphicComponentView.type = 'graphic';\n  return GraphicComponentView;\n}(view_Component/* default */.A);\n\nfunction newEl(graphicType) {\n  if (false) {}\n  var Clz = util.hasOwn(nonShapeGraphicElements, graphicType)\n  // Those graphic elements are not shapes. They should not be\n  // overwritten by users, so do them first.\n  ? nonShapeGraphicElements[graphicType] : graphic.getShapeClass(graphicType);\n  if (false) {}\n  var el = new Clz({});\n  inner(el).type = graphicType;\n  return el;\n}\nfunction createEl(id, targetElParent, graphicType, elMap) {\n  var el = newEl(graphicType);\n  targetElParent.add(el);\n  elMap.set(id, el);\n  inner(el).id = id;\n  inner(el).isNew = true;\n  return el;\n}\nfunction removeEl(elExisting, elOption, elMap, graphicModel) {\n  var existElParent = elExisting && elExisting.parent;\n  if (existElParent) {\n    elExisting.type === 'group' && elExisting.traverse(function (el) {\n      removeEl(el, elOption, elMap, graphicModel);\n    });\n    (0,customGraphicTransition/* applyLeaveTransition */.h8)(elExisting, elOption, graphicModel);\n    elMap.removeKey(inner(elExisting).id);\n  }\n}\nfunction updateCommonAttrs(el, elOption, defaultZ, defaultZlevel) {\n  if (!el.isGroup) {\n    util.each([['cursor', Displayable/* default */.Ay.prototype.cursor],\n    // We should not support configure z and zlevel in the element level.\n    // But seems we didn't limit it previously. So here still use it to avoid breaking.\n    ['zlevel', defaultZlevel || 0], ['z', defaultZ || 0],\n    // z2 must not be null/undefined, otherwise sort error may occur.\n    ['z2', 0]], function (item) {\n      var prop = item[0];\n      if (util.hasOwn(elOption, prop)) {\n        el[prop] = util.retrieve2(elOption[prop], item[1]);\n      } else if (el[prop] == null) {\n        el[prop] = item[1];\n      }\n    });\n  }\n  util.each(util.keys(elOption), function (key) {\n    // Assign event handlers.\n    // PENDING: should enumerate all event names or use pattern matching?\n    if (key.indexOf('on') === 0) {\n      var val = elOption[key];\n      el[key] = util.isFunction(val) ? val : null;\n    }\n  });\n  if (util.hasOwn(elOption, 'draggable')) {\n    el.draggable = elOption.draggable;\n  }\n  // Other attributes\n  elOption.name != null && (el.name = elOption.name);\n  elOption.id != null && (el.id = elOption.id);\n}\n// Remove unnecessary props to avoid potential problems.\nfunction getCleanedElOption(elOption) {\n  elOption = util.extend({}, elOption);\n  util.each(['id', 'parentId', '$action', 'hv', 'bounding', 'textContent', 'clipPath'].concat(layout/* LOCATION_PARAMS */.Tj), function (name) {\n    delete elOption[name];\n  });\n  return elOption;\n}\nfunction setEventData(el, graphicModel, elOption) {\n  var eventData = (0,innerStore/* getECData */.z)(el).eventData;\n  // Simple optimize for large amount of elements that no need event.\n  if (!el.silent && !el.ignore && !eventData) {\n    eventData = (0,innerStore/* getECData */.z)(el).eventData = {\n      componentType: 'graphic',\n      componentIndex: graphicModel.componentIndex,\n      name: el.name\n    };\n  }\n  // `elOption.info` enables user to mount some info on\n  // elements and use them in event handlers.\n  if (eventData) {\n    eventData.info = elOption.info;\n  }\n}\n;// ./node_modules/echarts/lib/component/graphic/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction install(registers) {\n  registers.registerComponentModel(GraphicComponentModel);\n  registers.registerComponentView(GraphicComponentView);\n  registers.registerPreprocessor(function (option) {\n    var graphicOption = option.graphic;\n    // Convert\n    // {graphic: [{left: 10, type: 'circle'}, ...]}\n    // or\n    // {graphic: {left: 10, type: 'circle'}}\n    // to\n    // {graphic: [{elements: [{left: 10, type: 'circle'}, ...]}]}\n    if ((0,util.isArray)(graphicOption)) {\n      if (!graphicOption[0] || !graphicOption[0].elements) {\n        option.graphic = [{\n          elements: graphicOption\n        }];\n      } else {\n        // Only one graphic instance can be instantiated. (We don't\n        // want that too many views are created in echarts._viewMap.)\n        option.graphic = [option.graphic[0]];\n      }\n    } else if (graphicOption && !graphicOption.elements) {\n      option.graphic = [{\n        elements: [graphicOption]\n      }];\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA4MzAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZ3JhcGhpYy9HcmFwaGljTW9kZWwuanM/NTUzYyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2dyYXBoaWMvR3JhcGhpY1ZpZXcuanM/NmFkNCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2dyYXBoaWMvaW5zdGFsbC5qcz9mOTZkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIG1vZGVsVXRpbCBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCBDb21wb25lbnRNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Db21wb25lbnQuanMnO1xuaW1wb3J0IHsgY29weUxheW91dFBhcmFtcywgbWVyZ2VMYXlvdXRQYXJhbSB9IGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0LmpzJztcbjtcbjtcbjtcbmV4cG9ydCBmdW5jdGlvbiBzZXRLZXlJbmZvVG9OZXdFbE9wdGlvbihyZXN1bHRJdGVtLCBuZXdFbE9wdGlvbikge1xuICB2YXIgZXhpc3RFbE9wdGlvbiA9IHJlc3VsdEl0ZW0uZXhpc3Rpbmc7XG4gIC8vIFNldCBpZCBhbmQgdHlwZSBhZnRlciBpZCBhc3NpZ25lZC5cbiAgbmV3RWxPcHRpb24uaWQgPSByZXN1bHRJdGVtLmtleUluZm8uaWQ7XG4gICFuZXdFbE9wdGlvbi50eXBlICYmIGV4aXN0RWxPcHRpb24gJiYgKG5ld0VsT3B0aW9uLnR5cGUgPSBleGlzdEVsT3B0aW9uLnR5cGUpO1xuICAvLyBTZXQgcGFyZW50IGlkIGlmIG5vdCBzcGVjaWZpZWRcbiAgaWYgKG5ld0VsT3B0aW9uLnBhcmVudElkID09IG51bGwpIHtcbiAgICB2YXIgbmV3RWxQYXJlbnRPcHRpb24gPSBuZXdFbE9wdGlvbi5wYXJlbnRPcHRpb247XG4gICAgaWYgKG5ld0VsUGFyZW50T3B0aW9uKSB7XG4gICAgICBuZXdFbE9wdGlvbi5wYXJlbnRJZCA9IG5ld0VsUGFyZW50T3B0aW9uLmlkO1xuICAgIH0gZWxzZSBpZiAoZXhpc3RFbE9wdGlvbikge1xuICAgICAgbmV3RWxPcHRpb24ucGFyZW50SWQgPSBleGlzdEVsT3B0aW9uLnBhcmVudElkO1xuICAgIH1cbiAgfVxuICAvLyBDbGVhclxuICBuZXdFbE9wdGlvbi5wYXJlbnRPcHRpb24gPSBudWxsO1xufVxuZnVuY3Rpb24gaXNTZXRMb2Mob2JqLCBwcm9wcykge1xuICB2YXIgaXNTZXQ7XG4gIHpyVXRpbC5lYWNoKHByb3BzLCBmdW5jdGlvbiAocHJvcCkge1xuICAgIG9ialtwcm9wXSAhPSBudWxsICYmIG9ialtwcm9wXSAhPT0gJ2F1dG8nICYmIChpc1NldCA9IHRydWUpO1xuICB9KTtcbiAgcmV0dXJuIGlzU2V0O1xufVxuZnVuY3Rpb24gbWVyZ2VOZXdFbE9wdGlvblRvRXhpc3QoZXhpc3RMaXN0LCBpbmRleCwgbmV3RWxPcHRpb24pIHtcbiAgLy8gVXBkYXRlIGV4aXN0aW5nIG9wdGlvbnMsIGZvciBgZ2V0T3B0aW9uYCBmZWF0dXJlLlxuICB2YXIgbmV3RWxPcHRDb3B5ID0genJVdGlsLmV4dGVuZCh7fSwgbmV3RWxPcHRpb24pO1xuICB2YXIgZXhpc3RFbE9wdGlvbiA9IGV4aXN0TGlzdFtpbmRleF07XG4gIHZhciAkYWN0aW9uID0gbmV3RWxPcHRpb24uJGFjdGlvbiB8fCAnbWVyZ2UnO1xuICBpZiAoJGFjdGlvbiA9PT0gJ21lcmdlJykge1xuICAgIGlmIChleGlzdEVsT3B0aW9uKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgbmV3VHlwZSA9IG5ld0VsT3B0aW9uLnR5cGU7XG4gICAgICAgIHpyVXRpbC5hc3NlcnQoIW5ld1R5cGUgfHwgZXhpc3RFbE9wdGlvbi50eXBlID09PSBuZXdUeXBlLCAnUGxlYXNlIHNldCAkYWN0aW9uOiBcInJlcGxhY2VcIiB0byBjaGFuZ2UgYHR5cGVgJyk7XG4gICAgICB9XG4gICAgICAvLyBXZSBjYW4gZW5zdXJlIHRoYXQgbmV3RWxPcHRDb3B5IGFuZCBleGlzdEVsT3B0aW9uIGFyZSBub3RcbiAgICAgIC8vIHRoZSBzYW1lIG9iamVjdCwgc28gYG1lcmdlYCB3aWxsIG5vdCBjaGFuZ2UgbmV3RWxPcHRDb3B5LlxuICAgICAgenJVdGlsLm1lcmdlKGV4aXN0RWxPcHRpb24sIG5ld0VsT3B0Q29weSwgdHJ1ZSk7XG4gICAgICAvLyBSaWdpZCBib2R5LCB1c2UgaWdub3JlU2l6ZS5cbiAgICAgIG1lcmdlTGF5b3V0UGFyYW0oZXhpc3RFbE9wdGlvbiwgbmV3RWxPcHRDb3B5LCB7XG4gICAgICAgIGlnbm9yZVNpemU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgLy8gV2lsbCBiZSB1c2VkIGluIHJlbmRlci5cbiAgICAgIGNvcHlMYXlvdXRQYXJhbXMobmV3RWxPcHRpb24sIGV4aXN0RWxPcHRpb24pO1xuICAgICAgLy8gQ29weSB0cmFuc2l0aW9uIGluZm8gdG8gbmV3IG9wdGlvbiBzbyBpdCBjYW4gYmUgdXNlZCBpbiB0aGUgdHJhbnNpdGlvbi5cbiAgICAgIC8vIERPIElUIEFGVEVSIG1lcmdlXG4gICAgICBjb3B5VHJhbnNpdGlvbkluZm8obmV3RWxPcHRpb24sIGV4aXN0RWxPcHRpb24pO1xuICAgICAgY29weVRyYW5zaXRpb25JbmZvKG5ld0VsT3B0aW9uLCBleGlzdEVsT3B0aW9uLCAnc2hhcGUnKTtcbiAgICAgIGNvcHlUcmFuc2l0aW9uSW5mbyhuZXdFbE9wdGlvbiwgZXhpc3RFbE9wdGlvbiwgJ3N0eWxlJyk7XG4gICAgICBjb3B5VHJhbnNpdGlvbkluZm8obmV3RWxPcHRpb24sIGV4aXN0RWxPcHRpb24sICdleHRyYScpO1xuICAgICAgLy8gQ29weSBjbGlwUGF0aFxuICAgICAgbmV3RWxPcHRpb24uY2xpcFBhdGggPSBleGlzdEVsT3B0aW9uLmNsaXBQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdExpc3RbaW5kZXhdID0gbmV3RWxPcHRDb3B5O1xuICAgIH1cbiAgfSBlbHNlIGlmICgkYWN0aW9uID09PSAncmVwbGFjZScpIHtcbiAgICBleGlzdExpc3RbaW5kZXhdID0gbmV3RWxPcHRDb3B5O1xuICB9IGVsc2UgaWYgKCRhY3Rpb24gPT09ICdyZW1vdmUnKSB7XG4gICAgLy8gbnVsbCB3aWxsIGJlIGNsZWFuZWQgbGF0ZXIuXG4gICAgZXhpc3RFbE9wdGlvbiAmJiAoZXhpc3RMaXN0W2luZGV4XSA9IG51bGwpO1xuICB9XG59XG52YXIgVFJBTlNJVElPTl9QUk9QU19UT19DT1BZID0gWyd0cmFuc2l0aW9uJywgJ2VudGVyRnJvbScsICdsZWF2ZVRvJ107XG52YXIgUk9PVF9UUkFOU0lUSU9OX1BST1BTX1RPX0NPUFkgPSBUUkFOU0lUSU9OX1BST1BTX1RPX0NPUFkuY29uY2F0KFsnZW50ZXJBbmltYXRpb24nLCAndXBkYXRlQW5pbWF0aW9uJywgJ2xlYXZlQW5pbWF0aW9uJ10pO1xuZnVuY3Rpb24gY29weVRyYW5zaXRpb25JbmZvKHRhcmdldCwgc291cmNlLCB0YXJnZXRQcm9wKSB7XG4gIGlmICh0YXJnZXRQcm9wKSB7XG4gICAgaWYgKCF0YXJnZXRbdGFyZ2V0UHJvcF0gJiYgc291cmNlW3RhcmdldFByb3BdKSB7XG4gICAgICAvLyBUT0RPIGF2b2lkIGNyZWF0aW5nIHRoaXMgZW1wdHkgb2JqZWN0IHdoZW4gdGhlcmUgaXMgbm8gdHJhbnNpdGlvbiBjb25maWd1cmF0aW9uLlxuICAgICAgdGFyZ2V0W3RhcmdldFByb3BdID0ge307XG4gICAgfVxuICAgIHRhcmdldCA9IHRhcmdldFt0YXJnZXRQcm9wXTtcbiAgICBzb3VyY2UgPSBzb3VyY2VbdGFyZ2V0UHJvcF07XG4gIH1cbiAgaWYgKCF0YXJnZXQgfHwgIXNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcHJvcHMgPSB0YXJnZXRQcm9wID8gVFJBTlNJVElPTl9QUk9QU19UT19DT1BZIDogUk9PVF9UUkFOU0lUSU9OX1BST1BTX1RPX0NPUFk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIGlmICh0YXJnZXRbcHJvcF0gPT0gbnVsbCAmJiBzb3VyY2VbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0TGF5b3V0SW5mb1RvRXhpc3QoZXhpc3RJdGVtLCBuZXdFbE9wdGlvbikge1xuICBpZiAoIWV4aXN0SXRlbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBleGlzdEl0ZW0uaHYgPSBuZXdFbE9wdGlvbi5odiA9IFtcbiAgLy8gUmlnaWQgYm9keSwgZG9uJ3QgY2FyZSBhYm91dCBgd2lkdGhgLlxuICBpc1NldExvYyhuZXdFbE9wdGlvbiwgWydsZWZ0JywgJ3JpZ2h0J10pLFxuICAvLyBSaWdpZCBib2R5LCBkb24ndCBjYXJlIGFib3V0IGBoZWlnaHRgLlxuICBpc1NldExvYyhuZXdFbE9wdGlvbiwgWyd0b3AnLCAnYm90dG9tJ10pXTtcbiAgLy8gR2l2ZSBkZWZhdWx0IGdyb3VwIHNpemUuIE90aGVyd2lzZSBsYXlvdXQgZXJyb3IgbWF5IG9jY3VyLlxuICBpZiAoZXhpc3RJdGVtLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICB2YXIgZXhpc3RpbmdHcm91cE9wdCA9IGV4aXN0SXRlbTtcbiAgICB2YXIgbmV3R3JvdXBPcHQgPSBuZXdFbE9wdGlvbjtcbiAgICBleGlzdGluZ0dyb3VwT3B0LndpZHRoID09IG51bGwgJiYgKGV4aXN0aW5nR3JvdXBPcHQud2lkdGggPSBuZXdHcm91cE9wdC53aWR0aCA9IDApO1xuICAgIGV4aXN0aW5nR3JvdXBPcHQuaGVpZ2h0ID09IG51bGwgJiYgKGV4aXN0aW5nR3JvdXBPcHQuaGVpZ2h0ID0gbmV3R3JvdXBPcHQuaGVpZ2h0ID0gMCk7XG4gIH1cbn1cbnZhciBHcmFwaGljQ29tcG9uZW50TW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoR3JhcGhpY0NvbXBvbmVudE1vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBHcmFwaGljQ29tcG9uZW50TW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IEdyYXBoaWNDb21wb25lbnRNb2RlbC50eXBlO1xuICAgIF90aGlzLnByZXZlbnRBdXRvWiA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEdyYXBoaWNDb21wb25lbnRNb2RlbC5wcm90b3R5cGUubWVyZ2VPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgLy8gUHJldmVudCBkZWZhdWx0IG1lcmdlIHRvIGVsZW1lbnRzXG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5vcHRpb24uZWxlbWVudHM7XG4gICAgdGhpcy5vcHRpb24uZWxlbWVudHMgPSBudWxsO1xuICAgIF9zdXBlci5wcm90b3R5cGUubWVyZ2VPcHRpb24uY2FsbCh0aGlzLCBvcHRpb24sIGVjTW9kZWwpO1xuICAgIHRoaXMub3B0aW9uLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIH07XG4gIEdyYXBoaWNDb21wb25lbnRNb2RlbC5wcm90b3R5cGUub3B0aW9uVXBkYXRlZCA9IGZ1bmN0aW9uIChuZXdPcHRpb24sIGlzSW5pdCkge1xuICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIG5ld0xpc3QgPSAoaXNJbml0ID8gdGhpc09wdGlvbiA6IG5ld09wdGlvbikuZWxlbWVudHM7XG4gICAgdmFyIGV4aXN0TGlzdCA9IHRoaXNPcHRpb24uZWxlbWVudHMgPSBpc0luaXQgPyBbXSA6IHRoaXNPcHRpb24uZWxlbWVudHM7XG4gICAgdmFyIGZsYXR0ZW5lZExpc3QgPSBbXTtcbiAgICB0aGlzLl9mbGF0dGVuKG5ld0xpc3QsIGZsYXR0ZW5lZExpc3QsIG51bGwpO1xuICAgIHZhciBtYXBwaW5nUmVzdWx0ID0gbW9kZWxVdGlsLm1hcHBpbmdUb0V4aXN0cyhleGlzdExpc3QsIGZsYXR0ZW5lZExpc3QsICdub3JtYWxNZXJnZScpO1xuICAgIC8vIENsZWFyIGVsT3B0aW9uc1RvVXBkYXRlXG4gICAgdmFyIGVsT3B0aW9uc1RvVXBkYXRlID0gdGhpcy5fZWxPcHRpb25zVG9VcGRhdGUgPSBbXTtcbiAgICB6clV0aWwuZWFjaChtYXBwaW5nUmVzdWx0LCBmdW5jdGlvbiAocmVzdWx0SXRlbSwgaW5kZXgpIHtcbiAgICAgIHZhciBuZXdFbE9wdGlvbiA9IHJlc3VsdEl0ZW0ubmV3T3B0aW9uO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgenJVdGlsLmFzc2VydCh6clV0aWwuaXNPYmplY3QobmV3RWxPcHRpb24pIHx8IHJlc3VsdEl0ZW0uZXhpc3RpbmcsICdFbXB0eSBncmFwaGljIG9wdGlvbiBkZWZpbml0aW9uJyk7XG4gICAgICB9XG4gICAgICBpZiAoIW5ld0VsT3B0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsT3B0aW9uc1RvVXBkYXRlLnB1c2gobmV3RWxPcHRpb24pO1xuICAgICAgc2V0S2V5SW5mb1RvTmV3RWxPcHRpb24ocmVzdWx0SXRlbSwgbmV3RWxPcHRpb24pO1xuICAgICAgbWVyZ2VOZXdFbE9wdGlvblRvRXhpc3QoZXhpc3RMaXN0LCBpbmRleCwgbmV3RWxPcHRpb24pO1xuICAgICAgc2V0TGF5b3V0SW5mb1RvRXhpc3QoZXhpc3RMaXN0W2luZGV4XSwgbmV3RWxPcHRpb24pO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIENsZWFuXG4gICAgdGhpc09wdGlvbi5lbGVtZW50cyA9IHpyVXRpbC5maWx0ZXIoZXhpc3RMaXN0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgLy8gJGFjdGlvbiBzaG91bGQgYmUgdm9sYXRpbGUsIG90aGVyd2lzZSBvcHRpb24gZ290dGVuIGZyb21cbiAgICAgIC8vIGBnZXRPcHRpb25gIHdpbGwgY29udGFpbiB1bmV4cGVjdGVkICRhY3Rpb24uXG4gICAgICBpdGVtICYmIGRlbGV0ZSBpdGVtLiRhY3Rpb247XG4gICAgICByZXR1cm4gaXRlbSAhPSBudWxsO1xuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBDb252ZXJ0XHJcbiAgICogW3tcclxuICAgKiAgdHlwZTogJ2dyb3VwJyxcclxuICAgKiAgaWQ6ICd4eCcsXHJcbiAgICogIGNoaWxkcmVuOiBbe3R5cGU6ICdjaXJjbGUnfSwge3R5cGU6ICdwb2x5Z29uJ31dXHJcbiAgICogfV1cclxuICAgKiB0b1xyXG4gICAqIFtcclxuICAgKiAge3R5cGU6ICdncm91cCcsIGlkOiAneHgnfSxcclxuICAgKiAge3R5cGU6ICdjaXJjbGUnLCBwYXJlbnRJZDogJ3h4J30sXHJcbiAgICogIHt0eXBlOiAncG9seWdvbicsIHBhcmVudElkOiAneHgnfVxyXG4gICAqIF1cclxuICAgKi9cbiAgR3JhcGhpY0NvbXBvbmVudE1vZGVsLnByb3RvdHlwZS5fZmxhdHRlbiA9IGZ1bmN0aW9uIChvcHRpb25MaXN0LCByZXN1bHQsIHBhcmVudE9wdGlvbikge1xuICAgIHpyVXRpbC5lYWNoKG9wdGlvbkxpc3QsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgIGlmICghb3B0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRPcHRpb24pIHtcbiAgICAgICAgb3B0aW9uLnBhcmVudE9wdGlvbiA9IHBhcmVudE9wdGlvbjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKG9wdGlvbik7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBvcHRpb24uY2hpbGRyZW47XG4gICAgICAvLyBoZXJlIHdlIGRvbid0IGp1ZGdlIGlmIG9wdGlvbi50eXBlIGlzIGBncm91cGBcbiAgICAgIC8vIHdoZW4gbmV3IG9wdGlvbiBkb2Vzbid0IHByb3ZpZGUgYHR5cGVgLCBpdCB3aWxsIGNhdXNlIHRoYXQgdGhlIGNoaWxkcmVuIGNhbid0IGJlIHVwZGF0ZWQuXG4gICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2ZsYXR0ZW4oY2hpbGRyZW4sIHJlc3VsdCwgb3B0aW9uKTtcbiAgICAgIH1cbiAgICAgIC8vIERlbGV0aW5nIGZvciBKU09OIG91dHB1dCwgYW5kIGZvciBub3QgYWZmZWN0aW5nIGdyb3VwIGNyZWF0aW9uLlxuICAgICAgZGVsZXRlIG9wdGlvbi5jaGlsZHJlbjtcbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgLy8gRklYTUVcbiAgLy8gUGFzcyB0byB2aWV3IHVzaW5nIHBheWxvYWQ/IHNldE9wdGlvbiBoYXMgYSBwYXlsb2FkP1xuICBHcmFwaGljQ29tcG9uZW50TW9kZWwucHJvdG90eXBlLnVzZUVsT3B0aW9uc1RvVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbHMgPSB0aGlzLl9lbE9wdGlvbnNUb1VwZGF0ZTtcbiAgICAvLyBDbGVhciB0byBhdm9pZCByZW5kZXIgZHVwbGljYXRlbHkgd2hlbiB6b29taW5nLlxuICAgIHRoaXMuX2VsT3B0aW9uc1RvVXBkYXRlID0gbnVsbDtcbiAgICByZXR1cm4gZWxzO1xuICB9O1xuICBHcmFwaGljQ29tcG9uZW50TW9kZWwudHlwZSA9ICdncmFwaGljJztcbiAgR3JhcGhpY0NvbXBvbmVudE1vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgZWxlbWVudHM6IFtdXG4gICAgLy8gcGFyZW50SWQ6IG51bGxcbiAgfTtcbiAgcmV0dXJuIEdyYXBoaWNDb21wb25lbnRNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuZXhwb3J0IHsgR3JhcGhpY0NvbXBvbmVudE1vZGVsIH07IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IERpc3BsYXlhYmxlIGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanMnO1xuaW1wb3J0ICogYXMgbW9kZWxVdGlsIGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpY1V0aWwgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCAqIGFzIGxheW91dFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQuanMnO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50IH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IENvbXBvbmVudFZpZXcgZnJvbSAnLi4vLi4vdmlldy9Db21wb25lbnQuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlLmpzJztcbmltcG9ydCB7IGlzRUM0Q29tcGF0aWJsZVN0eWxlLCBjb252ZXJ0RnJvbUVDNENvbXBhdGlibGVTdHlsZSB9IGZyb20gJy4uLy4uL3V0aWwvc3R5bGVDb21wYXQuanMnO1xuaW1wb3J0IHsgYXBwbHlMZWF2ZVRyYW5zaXRpb24sIGFwcGx5VXBkYXRlVHJhbnNpdGlvbiwgaXNUcmFuc2l0aW9uQWxsLCB1cGRhdGVMZWF2ZVRvIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL2N1c3RvbUdyYXBoaWNUcmFuc2l0aW9uLmpzJztcbmltcG9ydCB7IHVwZGF0ZVByb3BzIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL2Jhc2ljVHJhbnNpdGlvbi5qcyc7XG5pbXBvcnQgeyBhcHBseUtleWZyYW1lQW5pbWF0aW9uLCBzdG9wUHJldmlvdXNLZXlmcmFtZUFuaW1hdGlvbkFuZFJlc3RvcmUgfSBmcm9tICcuLi8uLi9hbmltYXRpb24vY3VzdG9tR3JhcGhpY0tleWZyYW1lQW5pbWF0aW9uLmpzJztcbnZhciBub25TaGFwZUdyYXBoaWNFbGVtZW50cyA9IHtcbiAgLy8gUmVzZXJ2ZWQgYnV0IG5vdCBzdXBwb3J0ZWQgaW4gZ3JhcGhpYyBjb21wb25lbnQuXG4gIHBhdGg6IG51bGwsXG4gIGNvbXBvdW5kUGF0aDogbnVsbCxcbiAgLy8gU3VwcG9ydGVkIGluIGdyYXBoaWMgY29tcG9uZW50LlxuICBncm91cDogZ3JhcGhpY1V0aWwuR3JvdXAsXG4gIGltYWdlOiBncmFwaGljVXRpbC5JbWFnZSxcbiAgdGV4dDogZ3JhcGhpY1V0aWwuVGV4dFxufTtcbmV4cG9ydCB2YXIgaW5uZXIgPSBtb2RlbFV0aWwubWFrZUlubmVyKCk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFZpZXdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIEdyYXBoaWNDb21wb25lbnRWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEdyYXBoaWNDb21wb25lbnRWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBHcmFwaGljQ29tcG9uZW50VmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gR3JhcGhpY0NvbXBvbmVudFZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgR3JhcGhpY0NvbXBvbmVudFZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZWxNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICB9O1xuICBHcmFwaGljQ29tcG9uZW50Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGdyYXBoaWNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgLy8gSGF2aW5nIGxldmVyYWdlZCBiZXR3ZWVuIHVzZSBjYXNlcyBhbmQgYWxnb3JpdGhtIGNvbXBsZXhpdHksIGEgdmVyeVxuICAgIC8vIHNpbXBsZSBsYXlvdXQgbWVjaGFuaXNtIGlzIHVzZWQ6XG4gICAgLy8gVGhlIHNpemUod2lkdGgvaGVpZ2h0KSBjYW4gYmUgZGV0ZXJtaW5lZCBieSBpdHNlbGYgb3IgaXRzIHBhcmVudCAobm90XG4gICAgLy8gaW1wbGVtZW50ZWQgeWV0KSwgYnV0IGNhbiBub3QgYnkgaXRzIGNoaWxkcmVuLiAoVG9wLWRvd24gdHJhdmVsKVxuICAgIC8vIFRoZSBsb2NhdGlvbih4L3kpIGNhbiBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBib3VuZGluZyByZWN0IG9mIGl0c2VsZlxuICAgIC8vIChjYW4gaW5jbHVkaW5nIGl0cyBkZXNjZW5kYW50cyBvciBub3QpIGFuZCB0aGUgc2l6ZSBvZiBpdHMgcGFyZW50LlxuICAgIC8vIChCb3R0b20tdXAgdHJhdmVsKVxuICAgIC8vIFdoZW4gYGNoYXJ0LmNsZWFyKClgIG9yIGBjaGFydC5zZXRPcHRpb24oey4uLn0sIHRydWUpYCB3aXRoIHRoZSBzYW1lIGlkLFxuICAgIC8vIHZpZXcgd2lsbCBiZSByZXVzZWQuXG4gICAgaWYgKGdyYXBoaWNNb2RlbCAhPT0gdGhpcy5fbGFzdEdyYXBoaWNNb2RlbCkge1xuICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5fbGFzdEdyYXBoaWNNb2RlbCA9IGdyYXBoaWNNb2RlbDtcbiAgICB0aGlzLl91cGRhdGVFbGVtZW50cyhncmFwaGljTW9kZWwpO1xuICAgIHRoaXMuX3JlbG9jYXRlKGdyYXBoaWNNb2RlbCwgYXBpKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIGdyYXBoaWMgZWxlbWVudHMuXHJcbiAgICovXG4gIEdyYXBoaWNDb21wb25lbnRWaWV3LnByb3RvdHlwZS5fdXBkYXRlRWxlbWVudHMgPSBmdW5jdGlvbiAoZ3JhcGhpY01vZGVsKSB7XG4gICAgdmFyIGVsT3B0aW9uc1RvVXBkYXRlID0gZ3JhcGhpY01vZGVsLnVzZUVsT3B0aW9uc1RvVXBkYXRlKCk7XG4gICAgaWYgKCFlbE9wdGlvbnNUb1VwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZWxNYXAgPSB0aGlzLl9lbE1hcDtcbiAgICB2YXIgcm9vdEdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgZ2xvYmFsWiA9IGdyYXBoaWNNb2RlbC5nZXQoJ3onKTtcbiAgICB2YXIgZ2xvYmFsWkxldmVsID0gZ3JhcGhpY01vZGVsLmdldCgnemxldmVsJyk7XG4gICAgLy8gVG9wLWRvd24gdHJhbnZlcnNlIHRvIGFzc2lnbiBncmFwaGljIHNldHRpbmdzIHRvIGVhY2ggZWxlbWVudHMuXG4gICAgenJVdGlsLmVhY2goZWxPcHRpb25zVG9VcGRhdGUsIGZ1bmN0aW9uIChlbE9wdGlvbikge1xuICAgICAgdmFyIGlkID0gbW9kZWxVdGlsLmNvbnZlcnRPcHRpb25JZE5hbWUoZWxPcHRpb24uaWQsIG51bGwpO1xuICAgICAgdmFyIGVsRXhpc3RpbmcgPSBpZCAhPSBudWxsID8gZWxNYXAuZ2V0KGlkKSA6IG51bGw7XG4gICAgICB2YXIgcGFyZW50SWQgPSBtb2RlbFV0aWwuY29udmVydE9wdGlvbklkTmFtZShlbE9wdGlvbi5wYXJlbnRJZCwgbnVsbCk7XG4gICAgICB2YXIgdGFyZ2V0RWxQYXJlbnQgPSBwYXJlbnRJZCAhPSBudWxsID8gZWxNYXAuZ2V0KHBhcmVudElkKSA6IHJvb3RHcm91cDtcbiAgICAgIHZhciBlbFR5cGUgPSBlbE9wdGlvbi50eXBlO1xuICAgICAgdmFyIGVsT3B0aW9uU3R5bGUgPSBlbE9wdGlvbi5zdHlsZTtcbiAgICAgIGlmIChlbFR5cGUgPT09ICd0ZXh0JyAmJiBlbE9wdGlvblN0eWxlKSB7XG4gICAgICAgIC8vIEluIHRvcC9ib3R0b20gbW9kZSwgdGV4dFZlcnRpY2FsQWxpZ24gc2hvdWxkIG5vdCBiZSB1c2VkLCB3aGljaCBjYXVzZVxuICAgICAgICAvLyBpbmFjY3VyYXRlbHkgbG9jYXRpbmcuXG4gICAgICAgIGlmIChlbE9wdGlvbi5odiAmJiBlbE9wdGlvbi5odlsxXSkge1xuICAgICAgICAgIGVsT3B0aW9uU3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gPSBlbE9wdGlvblN0eWxlLnRleHRCYXNlbGluZSA9IGVsT3B0aW9uU3R5bGUudmVydGljYWxBbGlnbiA9IGVsT3B0aW9uU3R5bGUuYWxpZ24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdGV4dENvbnRlbnRPcHRpb24gPSBlbE9wdGlvbi50ZXh0Q29udGVudDtcbiAgICAgIHZhciB0ZXh0Q29uZmlnID0gZWxPcHRpb24udGV4dENvbmZpZztcbiAgICAgIGlmIChlbE9wdGlvblN0eWxlICYmIGlzRUM0Q29tcGF0aWJsZVN0eWxlKGVsT3B0aW9uU3R5bGUsIGVsVHlwZSwgISF0ZXh0Q29uZmlnLCAhIXRleHRDb250ZW50T3B0aW9uKSkge1xuICAgICAgICB2YXIgY29udmVydFJlc3VsdCA9IGNvbnZlcnRGcm9tRUM0Q29tcGF0aWJsZVN0eWxlKGVsT3B0aW9uU3R5bGUsIGVsVHlwZSwgdHJ1ZSk7XG4gICAgICAgIGlmICghdGV4dENvbmZpZyAmJiBjb252ZXJ0UmVzdWx0LnRleHRDb25maWcpIHtcbiAgICAgICAgICB0ZXh0Q29uZmlnID0gZWxPcHRpb24udGV4dENvbmZpZyA9IGNvbnZlcnRSZXN1bHQudGV4dENvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRleHRDb250ZW50T3B0aW9uICYmIGNvbnZlcnRSZXN1bHQudGV4dENvbnRlbnQpIHtcbiAgICAgICAgICB0ZXh0Q29udGVudE9wdGlvbiA9IGNvbnZlcnRSZXN1bHQudGV4dENvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSB1bm5lY2Vzc2FyeSBwcm9wcyB0byBhdm9pZCBwb3RlbnRpYWwgcHJvYmxlbXMuXG4gICAgICB2YXIgZWxPcHRpb25DbGVhbmVkID0gZ2V0Q2xlYW5lZEVsT3B0aW9uKGVsT3B0aW9uKTtcbiAgICAgIC8vIEZvciBzaW1wbGUsIGRvIG5vdCBzdXBwb3J0IHBhcmVudCBjaGFuZ2UsIG90aGVyd2lzZSByZW9yZGVyIGlzIG5lZWRlZC5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVsRXhpc3RpbmcgJiYgenJVdGlsLmFzc2VydCh0YXJnZXRFbFBhcmVudCA9PT0gZWxFeGlzdGluZy5wYXJlbnQsICdDaGFuZ2luZyBwYXJlbnQgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciAkYWN0aW9uID0gZWxPcHRpb24uJGFjdGlvbiB8fCAnbWVyZ2UnO1xuICAgICAgdmFyIGlzTWVyZ2UgPSAkYWN0aW9uID09PSAnbWVyZ2UnO1xuICAgICAgdmFyIGlzUmVwbGFjZSA9ICRhY3Rpb24gPT09ICdyZXBsYWNlJztcbiAgICAgIGlmIChpc01lcmdlKSB7XG4gICAgICAgIHZhciBpc0luaXQgPSAhZWxFeGlzdGluZztcbiAgICAgICAgdmFyIGVsXzEgPSBlbEV4aXN0aW5nO1xuICAgICAgICBpZiAoaXNJbml0KSB7XG4gICAgICAgICAgZWxfMSA9IGNyZWF0ZUVsKGlkLCB0YXJnZXRFbFBhcmVudCwgZWxPcHRpb24udHlwZSwgZWxNYXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsXzEgJiYgKGlubmVyKGVsXzEpLmlzTmV3ID0gZmFsc2UpO1xuICAgICAgICAgIC8vIFN0b3AgYW5kIHJlc3RvcmUgYmVmb3JlIHVwZGF0ZSBhbnkgb3RoZXIgYXR0cmlidXRlcy5cbiAgICAgICAgICBzdG9wUHJldmlvdXNLZXlmcmFtZUFuaW1hdGlvbkFuZFJlc3RvcmUoZWxfMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsXzEpIHtcbiAgICAgICAgICBhcHBseVVwZGF0ZVRyYW5zaXRpb24oZWxfMSwgZWxPcHRpb25DbGVhbmVkLCBncmFwaGljTW9kZWwsIHtcbiAgICAgICAgICAgIGlzSW5pdDogaXNJbml0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdXBkYXRlQ29tbW9uQXR0cnMoZWxfMSwgZWxPcHRpb24sIGdsb2JhbFosIGdsb2JhbFpMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNSZXBsYWNlKSB7XG4gICAgICAgIHJlbW92ZUVsKGVsRXhpc3RpbmcsIGVsT3B0aW9uLCBlbE1hcCwgZ3JhcGhpY01vZGVsKTtcbiAgICAgICAgdmFyIGVsXzIgPSBjcmVhdGVFbChpZCwgdGFyZ2V0RWxQYXJlbnQsIGVsT3B0aW9uLnR5cGUsIGVsTWFwKTtcbiAgICAgICAgaWYgKGVsXzIpIHtcbiAgICAgICAgICBhcHBseVVwZGF0ZVRyYW5zaXRpb24oZWxfMiwgZWxPcHRpb25DbGVhbmVkLCBncmFwaGljTW9kZWwsIHtcbiAgICAgICAgICAgIGlzSW5pdDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHVwZGF0ZUNvbW1vbkF0dHJzKGVsXzIsIGVsT3B0aW9uLCBnbG9iYWxaLCBnbG9iYWxaTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCRhY3Rpb24gPT09ICdyZW1vdmUnKSB7XG4gICAgICAgIHVwZGF0ZUxlYXZlVG8oZWxFeGlzdGluZywgZWxPcHRpb24pO1xuICAgICAgICByZW1vdmVFbChlbEV4aXN0aW5nLCBlbE9wdGlvbiwgZWxNYXAsIGdyYXBoaWNNb2RlbCk7XG4gICAgICB9XG4gICAgICB2YXIgZWwgPSBlbE1hcC5nZXQoaWQpO1xuICAgICAgaWYgKGVsICYmIHRleHRDb250ZW50T3B0aW9uKSB7XG4gICAgICAgIGlmIChpc01lcmdlKSB7XG4gICAgICAgICAgdmFyIHRleHRDb250ZW50RXhpc3RpbmcgPSBlbC5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICAgIHRleHRDb250ZW50RXhpc3RpbmcgPyB0ZXh0Q29udGVudEV4aXN0aW5nLmF0dHIodGV4dENvbnRlbnRPcHRpb24pIDogZWwuc2V0VGV4dENvbnRlbnQobmV3IGdyYXBoaWNVdGlsLlRleHQodGV4dENvbnRlbnRPcHRpb24pKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlcGxhY2UpIHtcbiAgICAgICAgICBlbC5zZXRUZXh0Q29udGVudChuZXcgZ3JhcGhpY1V0aWwuVGV4dCh0ZXh0Q29udGVudE9wdGlvbikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgdmFyIGNsaXBQYXRoT3B0aW9uID0gZWxPcHRpb24uY2xpcFBhdGg7XG4gICAgICAgIGlmIChjbGlwUGF0aE9wdGlvbikge1xuICAgICAgICAgIHZhciBjbGlwUGF0aFR5cGUgPSBjbGlwUGF0aE9wdGlvbi50eXBlO1xuICAgICAgICAgIHZhciBjbGlwUGF0aCA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgaXNJbml0ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGlzTWVyZ2UpIHtcbiAgICAgICAgICAgIHZhciBvbGRDbGlwUGF0aCA9IGVsLmdldENsaXBQYXRoKCk7XG4gICAgICAgICAgICBpc0luaXQgPSAhb2xkQ2xpcFBhdGggfHwgaW5uZXIob2xkQ2xpcFBhdGgpLnR5cGUgIT09IGNsaXBQYXRoVHlwZTtcbiAgICAgICAgICAgIGNsaXBQYXRoID0gaXNJbml0ID8gbmV3RWwoY2xpcFBhdGhUeXBlKSA6IG9sZENsaXBQYXRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZXBsYWNlKSB7XG4gICAgICAgICAgICBpc0luaXQgPSB0cnVlO1xuICAgICAgICAgICAgY2xpcFBhdGggPSBuZXdFbChjbGlwUGF0aFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbC5zZXRDbGlwUGF0aChjbGlwUGF0aCk7XG4gICAgICAgICAgYXBwbHlVcGRhdGVUcmFuc2l0aW9uKGNsaXBQYXRoLCBjbGlwUGF0aE9wdGlvbiwgZ3JhcGhpY01vZGVsLCB7XG4gICAgICAgICAgICBpc0luaXQ6IGlzSW5pdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFwcGx5S2V5ZnJhbWVBbmltYXRpb24oY2xpcFBhdGgsIGNsaXBQYXRoT3B0aW9uLmtleWZyYW1lQW5pbWF0aW9uLCBncmFwaGljTW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbElubmVyID0gaW5uZXIoZWwpO1xuICAgICAgICBlbC5zZXRUZXh0Q29uZmlnKHRleHRDb25maWcpO1xuICAgICAgICBlbElubmVyLm9wdGlvbiA9IGVsT3B0aW9uO1xuICAgICAgICBzZXRFdmVudERhdGEoZWwsIGdyYXBoaWNNb2RlbCwgZWxPcHRpb24pO1xuICAgICAgICBncmFwaGljVXRpbC5zZXRUb29sdGlwQ29uZmlnKHtcbiAgICAgICAgICBlbDogZWwsXG4gICAgICAgICAgY29tcG9uZW50TW9kZWw6IGdyYXBoaWNNb2RlbCxcbiAgICAgICAgICBpdGVtTmFtZTogZWwubmFtZSxcbiAgICAgICAgICBpdGVtVG9vbHRpcE9wdGlvbjogZWxPcHRpb24udG9vbHRpcFxuICAgICAgICB9KTtcbiAgICAgICAgYXBwbHlLZXlmcmFtZUFuaW1hdGlvbihlbCwgZWxPcHRpb24ua2V5ZnJhbWVBbmltYXRpb24sIGdyYXBoaWNNb2RlbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIExvY2F0ZSBncmFwaGljIGVsZW1lbnRzLlxyXG4gICAqL1xuICBHcmFwaGljQ29tcG9uZW50Vmlldy5wcm90b3R5cGUuX3JlbG9jYXRlID0gZnVuY3Rpb24gKGdyYXBoaWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGVsT3B0aW9ucyA9IGdyYXBoaWNNb2RlbC5vcHRpb24uZWxlbWVudHM7XG4gICAgdmFyIHJvb3RHcm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGVsTWFwID0gdGhpcy5fZWxNYXA7XG4gICAgdmFyIGFwaVdpZHRoID0gYXBpLmdldFdpZHRoKCk7XG4gICAgdmFyIGFwaUhlaWdodCA9IGFwaS5nZXRIZWlnaHQoKTtcbiAgICB2YXIgeHkgPSBbJ3gnLCAneSddO1xuICAgIC8vIFRvcC1kb3duIHRvIGNhbGN1bGF0ZSBwZXJjZW50YWdlIHdpZHRoL2hlaWdodCBvZiBncm91cFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxPcHRpb24gPSBlbE9wdGlvbnNbaV07XG4gICAgICB2YXIgaWQgPSBtb2RlbFV0aWwuY29udmVydE9wdGlvbklkTmFtZShlbE9wdGlvbi5pZCwgbnVsbCk7XG4gICAgICB2YXIgZWwgPSBpZCAhPSBudWxsID8gZWxNYXAuZ2V0KGlkKSA6IG51bGw7XG4gICAgICBpZiAoIWVsIHx8ICFlbC5pc0dyb3VwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHBhcmVudEVsID0gZWwucGFyZW50O1xuICAgICAgdmFyIGlzUGFyZW50Um9vdCA9IHBhcmVudEVsID09PSByb290R3JvdXA7XG4gICAgICAvLyBMaWtlICdwb3NpdGlvbjphYnNvbHV0JyBpbiBjc3MsIGRlZmF1bHQgMC5cbiAgICAgIHZhciBlbElubmVyID0gaW5uZXIoZWwpO1xuICAgICAgdmFyIHBhcmVudEVsSW5uZXIgPSBpbm5lcihwYXJlbnRFbCk7XG4gICAgICBlbElubmVyLndpZHRoID0gcGFyc2VQZXJjZW50KGVsSW5uZXIub3B0aW9uLndpZHRoLCBpc1BhcmVudFJvb3QgPyBhcGlXaWR0aCA6IHBhcmVudEVsSW5uZXIud2lkdGgpIHx8IDA7XG4gICAgICBlbElubmVyLmhlaWdodCA9IHBhcnNlUGVyY2VudChlbElubmVyLm9wdGlvbi5oZWlnaHQsIGlzUGFyZW50Um9vdCA/IGFwaUhlaWdodCA6IHBhcmVudEVsSW5uZXIuaGVpZ2h0KSB8fCAwO1xuICAgIH1cbiAgICAvLyBCb3R0b20tdXAgdHJhbnZlc2UgYWxsIGVsZW1lbnRzIChjb25zaWRlciBlYyByZXNpemUpIHRvIGxvY2F0ZSBlbGVtZW50cy5cbiAgICBmb3IgKHZhciBpID0gZWxPcHRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZWxPcHRpb24gPSBlbE9wdGlvbnNbaV07XG4gICAgICB2YXIgaWQgPSBtb2RlbFV0aWwuY29udmVydE9wdGlvbklkTmFtZShlbE9wdGlvbi5pZCwgbnVsbCk7XG4gICAgICB2YXIgZWwgPSBpZCAhPSBudWxsID8gZWxNYXAuZ2V0KGlkKSA6IG51bGw7XG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHBhcmVudEVsID0gZWwucGFyZW50O1xuICAgICAgdmFyIHBhcmVudEVsSW5uZXIgPSBpbm5lcihwYXJlbnRFbCk7XG4gICAgICB2YXIgY29udGFpbmVySW5mbyA9IHBhcmVudEVsID09PSByb290R3JvdXAgPyB7XG4gICAgICAgIHdpZHRoOiBhcGlXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBhcGlIZWlnaHRcbiAgICAgIH0gOiB7XG4gICAgICAgIHdpZHRoOiBwYXJlbnRFbElubmVyLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHBhcmVudEVsSW5uZXIuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgLy8gUEVORElOR1xuICAgICAgLy8gQ3VycmVudGx5LCB3aGVuIGBib3VuZGluZzogJ2FsbCdgLCB0aGUgdW5pb24gYm91bmRpbmcgcmVjdCBvZiB0aGUgZ3JvdXBcbiAgICAgIC8vIGRvZXMgbm90IGluY2x1ZGUgdGhlIHJlY3Qgb2YgWzAsIDAsIGdyb3VwLndpZHRoLCBncm91cC5oZWlnaHRdLCB3aGljaFxuICAgICAgLy8gaXMgcHJvYmFibHkgd2VpcmQgZm9yIHVzZXJzLiBTaG91bGQgd2UgbWFrZSBhIGJyZWFrIGNoYW5nZSBmb3IgaXQ/XG4gICAgICB2YXIgbGF5b3V0UG9zID0ge307XG4gICAgICB2YXIgbGF5b3V0ZWQgPSBsYXlvdXRVdGlsLnBvc2l0aW9uRWxlbWVudChlbCwgZWxPcHRpb24sIGNvbnRhaW5lckluZm8sIG51bGwsIHtcbiAgICAgICAgaHY6IGVsT3B0aW9uLmh2LFxuICAgICAgICBib3VuZGluZ01vZGU6IGVsT3B0aW9uLmJvdW5kaW5nXG4gICAgICB9LCBsYXlvdXRQb3MpO1xuICAgICAgaWYgKCFpbm5lcihlbCkuaXNOZXcgJiYgbGF5b3V0ZWQpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBlbE9wdGlvbi50cmFuc2l0aW9uO1xuICAgICAgICB2YXIgYW5pbWF0ZVBvcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHh5Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHh5W2tdO1xuICAgICAgICAgIHZhciB2YWwgPSBsYXlvdXRQb3Nba2V5XTtcbiAgICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiAoaXNUcmFuc2l0aW9uQWxsKHRyYW5zaXRpb24pIHx8IHpyVXRpbC5pbmRleE9mKHRyYW5zaXRpb24sIGtleSkgPj0gMCkpIHtcbiAgICAgICAgICAgIGFuaW1hdGVQb3Nba2V5XSA9IHZhbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxba2V5XSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlUHJvcHMoZWwsIGFuaW1hdGVQb3MsIGdyYXBoaWNNb2RlbCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5hdHRyKGxheW91dFBvcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBDbGVhciBhbGwgZWxlbWVudHMuXHJcbiAgICovXG4gIEdyYXBoaWNDb21wb25lbnRWaWV3LnByb3RvdHlwZS5fY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZWxNYXAgPSB0aGlzLl9lbE1hcDtcbiAgICBlbE1hcC5lYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmVtb3ZlRWwoZWwsIGlubmVyKGVsKS5vcHRpb24sIGVsTWFwLCBfdGhpcy5fbGFzdEdyYXBoaWNNb2RlbCk7XG4gICAgfSk7XG4gICAgdGhpcy5fZWxNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICB9O1xuICBHcmFwaGljQ29tcG9uZW50Vmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jbGVhcigpO1xuICB9O1xuICBHcmFwaGljQ29tcG9uZW50Vmlldy50eXBlID0gJ2dyYXBoaWMnO1xuICByZXR1cm4gR3JhcGhpY0NvbXBvbmVudFZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuZXhwb3J0IHsgR3JhcGhpY0NvbXBvbmVudFZpZXcgfTtcbmZ1bmN0aW9uIG5ld0VsKGdyYXBoaWNUeXBlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgenJVdGlsLmFzc2VydChncmFwaGljVHlwZSwgJ2dyYXBoaWMgdHlwZSBNVVNUIGJlIHNldCcpO1xuICB9XG4gIHZhciBDbHogPSB6clV0aWwuaGFzT3duKG5vblNoYXBlR3JhcGhpY0VsZW1lbnRzLCBncmFwaGljVHlwZSlcbiAgLy8gVGhvc2UgZ3JhcGhpYyBlbGVtZW50cyBhcmUgbm90IHNoYXBlcy4gVGhleSBzaG91bGQgbm90IGJlXG4gIC8vIG92ZXJ3cml0dGVuIGJ5IHVzZXJzLCBzbyBkbyB0aGVtIGZpcnN0LlxuICA/IG5vblNoYXBlR3JhcGhpY0VsZW1lbnRzW2dyYXBoaWNUeXBlXSA6IGdyYXBoaWNVdGlsLmdldFNoYXBlQ2xhc3MoZ3JhcGhpY1R5cGUpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHpyVXRpbC5hc3NlcnQoQ2x6LCBcImdyYXBoaWMgdHlwZSBcIiArIGdyYXBoaWNUeXBlICsgXCIgY2FuIG5vdCBiZSBmb3VuZFwiKTtcbiAgfVxuICB2YXIgZWwgPSBuZXcgQ2x6KHt9KTtcbiAgaW5uZXIoZWwpLnR5cGUgPSBncmFwaGljVHlwZTtcbiAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gY3JlYXRlRWwoaWQsIHRhcmdldEVsUGFyZW50LCBncmFwaGljVHlwZSwgZWxNYXApIHtcbiAgdmFyIGVsID0gbmV3RWwoZ3JhcGhpY1R5cGUpO1xuICB0YXJnZXRFbFBhcmVudC5hZGQoZWwpO1xuICBlbE1hcC5zZXQoaWQsIGVsKTtcbiAgaW5uZXIoZWwpLmlkID0gaWQ7XG4gIGlubmVyKGVsKS5pc05ldyA9IHRydWU7XG4gIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIHJlbW92ZUVsKGVsRXhpc3RpbmcsIGVsT3B0aW9uLCBlbE1hcCwgZ3JhcGhpY01vZGVsKSB7XG4gIHZhciBleGlzdEVsUGFyZW50ID0gZWxFeGlzdGluZyAmJiBlbEV4aXN0aW5nLnBhcmVudDtcbiAgaWYgKGV4aXN0RWxQYXJlbnQpIHtcbiAgICBlbEV4aXN0aW5nLnR5cGUgPT09ICdncm91cCcgJiYgZWxFeGlzdGluZy50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJlbW92ZUVsKGVsLCBlbE9wdGlvbiwgZWxNYXAsIGdyYXBoaWNNb2RlbCk7XG4gICAgfSk7XG4gICAgYXBwbHlMZWF2ZVRyYW5zaXRpb24oZWxFeGlzdGluZywgZWxPcHRpb24sIGdyYXBoaWNNb2RlbCk7XG4gICAgZWxNYXAucmVtb3ZlS2V5KGlubmVyKGVsRXhpc3RpbmcpLmlkKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQ29tbW9uQXR0cnMoZWwsIGVsT3B0aW9uLCBkZWZhdWx0WiwgZGVmYXVsdFpsZXZlbCkge1xuICBpZiAoIWVsLmlzR3JvdXApIHtcbiAgICB6clV0aWwuZWFjaChbWydjdXJzb3InLCBEaXNwbGF5YWJsZS5wcm90b3R5cGUuY3Vyc29yXSxcbiAgICAvLyBXZSBzaG91bGQgbm90IHN1cHBvcnQgY29uZmlndXJlIHogYW5kIHpsZXZlbCBpbiB0aGUgZWxlbWVudCBsZXZlbC5cbiAgICAvLyBCdXQgc2VlbXMgd2UgZGlkbid0IGxpbWl0IGl0IHByZXZpb3VzbHkuIFNvIGhlcmUgc3RpbGwgdXNlIGl0IHRvIGF2b2lkIGJyZWFraW5nLlxuICAgIFsnemxldmVsJywgZGVmYXVsdFpsZXZlbCB8fCAwXSwgWyd6JywgZGVmYXVsdFogfHwgMF0sXG4gICAgLy8gejIgbXVzdCBub3QgYmUgbnVsbC91bmRlZmluZWQsIG90aGVyd2lzZSBzb3J0IGVycm9yIG1heSBvY2N1ci5cbiAgICBbJ3oyJywgMF1dLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHByb3AgPSBpdGVtWzBdO1xuICAgICAgaWYgKHpyVXRpbC5oYXNPd24oZWxPcHRpb24sIHByb3ApKSB7XG4gICAgICAgIGVsW3Byb3BdID0genJVdGlsLnJldHJpZXZlMihlbE9wdGlvbltwcm9wXSwgaXRlbVsxXSk7XG4gICAgICB9IGVsc2UgaWYgKGVsW3Byb3BdID09IG51bGwpIHtcbiAgICAgICAgZWxbcHJvcF0gPSBpdGVtWzFdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHpyVXRpbC5lYWNoKHpyVXRpbC5rZXlzKGVsT3B0aW9uKSwgZnVuY3Rpb24gKGtleSkge1xuICAgIC8vIEFzc2lnbiBldmVudCBoYW5kbGVycy5cbiAgICAvLyBQRU5ESU5HOiBzaG91bGQgZW51bWVyYXRlIGFsbCBldmVudCBuYW1lcyBvciB1c2UgcGF0dGVybiBtYXRjaGluZz9cbiAgICBpZiAoa2V5LmluZGV4T2YoJ29uJykgPT09IDApIHtcbiAgICAgIHZhciB2YWwgPSBlbE9wdGlvbltrZXldO1xuICAgICAgZWxba2V5XSA9IHpyVXRpbC5pc0Z1bmN0aW9uKHZhbCkgPyB2YWwgOiBudWxsO1xuICAgIH1cbiAgfSk7XG4gIGlmICh6clV0aWwuaGFzT3duKGVsT3B0aW9uLCAnZHJhZ2dhYmxlJykpIHtcbiAgICBlbC5kcmFnZ2FibGUgPSBlbE9wdGlvbi5kcmFnZ2FibGU7XG4gIH1cbiAgLy8gT3RoZXIgYXR0cmlidXRlc1xuICBlbE9wdGlvbi5uYW1lICE9IG51bGwgJiYgKGVsLm5hbWUgPSBlbE9wdGlvbi5uYW1lKTtcbiAgZWxPcHRpb24uaWQgIT0gbnVsbCAmJiAoZWwuaWQgPSBlbE9wdGlvbi5pZCk7XG59XG4vLyBSZW1vdmUgdW5uZWNlc3NhcnkgcHJvcHMgdG8gYXZvaWQgcG90ZW50aWFsIHByb2JsZW1zLlxuZnVuY3Rpb24gZ2V0Q2xlYW5lZEVsT3B0aW9uKGVsT3B0aW9uKSB7XG4gIGVsT3B0aW9uID0genJVdGlsLmV4dGVuZCh7fSwgZWxPcHRpb24pO1xuICB6clV0aWwuZWFjaChbJ2lkJywgJ3BhcmVudElkJywgJyRhY3Rpb24nLCAnaHYnLCAnYm91bmRpbmcnLCAndGV4dENvbnRlbnQnLCAnY2xpcFBhdGgnXS5jb25jYXQobGF5b3V0VXRpbC5MT0NBVElPTl9QQVJBTVMpLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGRlbGV0ZSBlbE9wdGlvbltuYW1lXTtcbiAgfSk7XG4gIHJldHVybiBlbE9wdGlvbjtcbn1cbmZ1bmN0aW9uIHNldEV2ZW50RGF0YShlbCwgZ3JhcGhpY01vZGVsLCBlbE9wdGlvbikge1xuICB2YXIgZXZlbnREYXRhID0gZ2V0RUNEYXRhKGVsKS5ldmVudERhdGE7XG4gIC8vIFNpbXBsZSBvcHRpbWl6ZSBmb3IgbGFyZ2UgYW1vdW50IG9mIGVsZW1lbnRzIHRoYXQgbm8gbmVlZCBldmVudC5cbiAgaWYgKCFlbC5zaWxlbnQgJiYgIWVsLmlnbm9yZSAmJiAhZXZlbnREYXRhKSB7XG4gICAgZXZlbnREYXRhID0gZ2V0RUNEYXRhKGVsKS5ldmVudERhdGEgPSB7XG4gICAgICBjb21wb25lbnRUeXBlOiAnZ3JhcGhpYycsXG4gICAgICBjb21wb25lbnRJbmRleDogZ3JhcGhpY01vZGVsLmNvbXBvbmVudEluZGV4LFxuICAgICAgbmFtZTogZWwubmFtZVxuICAgIH07XG4gIH1cbiAgLy8gYGVsT3B0aW9uLmluZm9gIGVuYWJsZXMgdXNlciB0byBtb3VudCBzb21lIGluZm8gb25cbiAgLy8gZWxlbWVudHMgYW5kIHVzZSB0aGVtIGluIGV2ZW50IGhhbmRsZXJzLlxuICBpZiAoZXZlbnREYXRhKSB7XG4gICAgZXZlbnREYXRhLmluZm8gPSBlbE9wdGlvbi5pbmZvO1xuICB9XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IEdyYXBoaWNDb21wb25lbnRNb2RlbCB9IGZyb20gJy4vR3JhcGhpY01vZGVsLmpzJztcbmltcG9ydCB7IEdyYXBoaWNDb21wb25lbnRWaWV3IH0gZnJvbSAnLi9HcmFwaGljVmlldy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50TW9kZWwoR3JhcGhpY0NvbXBvbmVudE1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhHcmFwaGljQ29tcG9uZW50Vmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgdmFyIGdyYXBoaWNPcHRpb24gPSBvcHRpb24uZ3JhcGhpYztcbiAgICAvLyBDb252ZXJ0XG4gICAgLy8ge2dyYXBoaWM6IFt7bGVmdDogMTAsIHR5cGU6ICdjaXJjbGUnfSwgLi4uXX1cbiAgICAvLyBvclxuICAgIC8vIHtncmFwaGljOiB7bGVmdDogMTAsIHR5cGU6ICdjaXJjbGUnfX1cbiAgICAvLyB0b1xuICAgIC8vIHtncmFwaGljOiBbe2VsZW1lbnRzOiBbe2xlZnQ6IDEwLCB0eXBlOiAnY2lyY2xlJ30sIC4uLl19XX1cbiAgICBpZiAoaXNBcnJheShncmFwaGljT3B0aW9uKSkge1xuICAgICAgaWYgKCFncmFwaGljT3B0aW9uWzBdIHx8ICFncmFwaGljT3B0aW9uWzBdLmVsZW1lbnRzKSB7XG4gICAgICAgIG9wdGlvbi5ncmFwaGljID0gW3tcbiAgICAgICAgICBlbGVtZW50czogZ3JhcGhpY09wdGlvblxuICAgICAgICB9XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9ubHkgb25lIGdyYXBoaWMgaW5zdGFuY2UgY2FuIGJlIGluc3RhbnRpYXRlZC4gKFdlIGRvbid0XG4gICAgICAgIC8vIHdhbnQgdGhhdCB0b28gbWFueSB2aWV3cyBhcmUgY3JlYXRlZCBpbiBlY2hhcnRzLl92aWV3TWFwLilcbiAgICAgICAgb3B0aW9uLmdyYXBoaWMgPSBbb3B0aW9uLmdyYXBoaWNbMF1dO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3JhcGhpY09wdGlvbiAmJiAhZ3JhcGhpY09wdGlvbi5lbGVtZW50cykge1xuICAgICAgb3B0aW9uLmdyYXBoaWMgPSBbe1xuICAgICAgICBlbGVtZW50czogW2dyYXBoaWNPcHRpb25dXG4gICAgICB9XTtcbiAgICB9XG4gIH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///40830\n")},45620:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ install)\n/* harmony export */ });\n/* harmony import */ var _installSimple_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(69446);\n/* harmony import */ var _axisPointer_install_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46524);\n/* harmony import */ var _extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3087);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction install(registers) {\n  (0,_extension_js__WEBPACK_IMPORTED_MODULE_0__/* .use */ .Y)(_installSimple_js__WEBPACK_IMPORTED_MODULE_1__/* .install */ .a);\n  (0,_extension_js__WEBPACK_IMPORTED_MODULE_0__/* .use */ .Y)(_axisPointer_install_js__WEBPACK_IMPORTED_MODULE_2__/* .install */ .a);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU2MjAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZ3JpZC9pbnN0YWxsLmpzPzA2MmUiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBpbnN0YWxsIGFzIGluc3RhbGxTaW1wbGUgfSBmcm9tICcuL2luc3RhbGxTaW1wbGUuanMnO1xuaW1wb3J0IHsgaW5zdGFsbCBhcyBpbnN0YWxsQXhpc1BvaW50ZXIgfSBmcm9tICcuLi9heGlzUG9pbnRlci9pbnN0YWxsLmpzJztcbmltcG9ydCB7IHVzZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbi5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgdXNlKGluc3RhbGxTaW1wbGUpO1xuICB1c2UoaW5zdGFsbEF4aXNQb2ludGVyKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///45620\n')},69446:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ install)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _view_Component_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(59109);\n/* harmony import */ var _coord_cartesian_GridModel_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36788);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30010);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _coord_cartesian_AxisModel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(57483);\n/* harmony import */ var _coord_axisModelCreator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(59470);\n/* harmony import */ var _coord_cartesian_Grid_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(74345);\n/* harmony import */ var _axis_CartesianAxisView_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1284);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n// Grid view\nvar GridView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(GridView, _super);\n  function GridView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = \'grid\';\n    return _this;\n  }\n  GridView.prototype.render = function (gridModel, ecModel) {\n    this.group.removeAll();\n    if (gridModel.get(\'show\')) {\n      this.group.add(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.defaults)({\n          fill: gridModel.get(\'backgroundColor\')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  };\n  GridView.type = \'grid\';\n  return GridView;\n}(_view_Component_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A);\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: \'\',\n  offset: 0\n};\nfunction install(registers) {\n  registers.registerComponentView(GridView);\n  registers.registerComponentModel(_coord_cartesian_GridModel_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A);\n  registers.registerCoordinateSystem(\'cartesian2d\', _coord_cartesian_Grid_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A);\n  (0,_coord_axisModelCreator_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(registers, \'x\', _coord_cartesian_AxisModel_js__WEBPACK_IMPORTED_MODULE_7__/* .CartesianAxisModel */ .P, extraOption);\n  (0,_coord_axisModelCreator_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(registers, \'y\', _coord_cartesian_AxisModel_js__WEBPACK_IMPORTED_MODULE_7__/* .CartesianAxisModel */ .P, extraOption);\n  registers.registerComponentView(_axis_CartesianAxisView_js__WEBPACK_IMPORTED_MODULE_8__/* .CartesianXAxisView */ .xR);\n  registers.registerComponentView(_axis_CartesianAxisView_js__WEBPACK_IMPORTED_MODULE_8__/* .CartesianYAxisView */ .O8);\n  registers.registerPreprocessor(function (option) {\n    // Only create grid when need\n    if (option.xAxis && option.yAxis && !option.grid) {\n      option.grid = {};\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk0NDYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9ncmlkL2luc3RhbGxTaW1wbGUuanM/ODAyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IENvbXBvbmVudFZpZXcgZnJvbSAnLi4vLi4vdmlldy9Db21wb25lbnQuanMnO1xuaW1wb3J0IEdyaWRNb2RlbCBmcm9tICcuLi8uLi9jb29yZC9jYXJ0ZXNpYW4vR3JpZE1vZGVsLmpzJztcbmltcG9ydCB7IFJlY3QgfSBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IHsgZGVmYXVsdHMgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgQ2FydGVzaWFuQXhpc01vZGVsIH0gZnJvbSAnLi4vLi4vY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbC5qcyc7XG5pbXBvcnQgYXhpc01vZGVsQ3JlYXRvciBmcm9tICcuLi8uLi9jb29yZC9heGlzTW9kZWxDcmVhdG9yLmpzJztcbmltcG9ydCBHcmlkIGZyb20gJy4uLy4uL2Nvb3JkL2NhcnRlc2lhbi9HcmlkLmpzJztcbmltcG9ydCB7IENhcnRlc2lhblhBeGlzVmlldywgQ2FydGVzaWFuWUF4aXNWaWV3IH0gZnJvbSAnLi4vYXhpcy9DYXJ0ZXNpYW5BeGlzVmlldy5qcyc7XG4vLyBHcmlkIHZpZXdcbnZhciBHcmlkVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhHcmlkVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gR3JpZFZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9ICdncmlkJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgR3JpZFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChncmlkTW9kZWwsIGVjTW9kZWwpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIGlmIChncmlkTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIHRoaXMuZ3JvdXAuYWRkKG5ldyBSZWN0KHtcbiAgICAgICAgc2hhcGU6IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFJlY3QoKSxcbiAgICAgICAgc3R5bGU6IGRlZmF1bHRzKHtcbiAgICAgICAgICBmaWxsOiBncmlkTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKVxuICAgICAgICB9LCBncmlkTW9kZWwuZ2V0SXRlbVN0eWxlKCkpLFxuICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgIHoyOiAtMVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcbiAgR3JpZFZpZXcudHlwZSA9ICdncmlkJztcbiAgcmV0dXJuIEdyaWRWaWV3O1xufShDb21wb25lbnRWaWV3KTtcbnZhciBleHRyYU9wdGlvbiA9IHtcbiAgLy8gZ3JpZEluZGV4OiAwLFxuICAvLyBncmlkSWQ6ICcnLFxuICBvZmZzZXQ6IDBcbn07XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhHcmlkVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKEdyaWRNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvb3JkaW5hdGVTeXN0ZW0oJ2NhcnRlc2lhbjJkJywgR3JpZCk7XG4gIGF4aXNNb2RlbENyZWF0b3IocmVnaXN0ZXJzLCAneCcsIENhcnRlc2lhbkF4aXNNb2RlbCwgZXh0cmFPcHRpb24pO1xuICBheGlzTW9kZWxDcmVhdG9yKHJlZ2lzdGVycywgJ3knLCBDYXJ0ZXNpYW5BeGlzTW9kZWwsIGV4dHJhT3B0aW9uKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhDYXJ0ZXNpYW5YQXhpc1ZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KENhcnRlc2lhbllBeGlzVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgLy8gT25seSBjcmVhdGUgZ3JpZCB3aGVuIG5lZWRcbiAgICBpZiAob3B0aW9uLnhBeGlzICYmIG9wdGlvbi55QXhpcyAmJiAhb3B0aW9uLmdyaWQpIHtcbiAgICAgIG9wdGlvbi5ncmlkID0ge307XG4gICAgfVxuICB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///69446\n')}}]);