"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[9222],{16985:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   M_: () => (/* binding */ registerFeature),\n/* harmony export */   Ms: () => (/* binding */ ToolboxFeature),\n/* harmony export */   x$: () => (/* binding */ getFeature)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\nvar ToolboxFeature = /** @class */function () {\n  function ToolboxFeature() {}\n  return ToolboxFeature;\n}();\n\nvar features = {};\nfunction registerFeature(name, ctor) {\n  features[name] = ctor;\n}\nfunction getFeature(name) {\n  return features[name];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY5ODUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlTWFuYWdlci5qcz9mMzdjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG52YXIgVG9vbGJveEZlYXR1cmUgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb29sYm94RmVhdHVyZSgpIHt9XG4gIHJldHVybiBUb29sYm94RmVhdHVyZTtcbn0oKTtcbmV4cG9ydCB7IFRvb2xib3hGZWF0dXJlIH07XG52YXIgZmVhdHVyZXMgPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckZlYXR1cmUobmFtZSwgY3Rvcikge1xuICBmZWF0dXJlc1tuYW1lXSA9IGN0b3I7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RmVhdHVyZShuYW1lKSB7XG4gIHJldHVybiBmZWF0dXJlc1tuYW1lXTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16985\n')},55855:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _featureManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16985);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar ICON_TYPES = ['rect', 'polygon', 'lineX', 'lineY', 'keep', 'clear'];\nvar BrushFeature = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(BrushFeature, _super);\n  function BrushFeature() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  BrushFeature.prototype.render = function (featureModel, ecModel, api) {\n    var brushType;\n    var brushMode;\n    var isBrushed;\n    ecModel.eachComponent({\n      mainType: 'brush'\n    }, function (brushModel) {\n      brushType = brushModel.brushType;\n      brushMode = brushModel.brushOption.brushMode || 'single';\n      isBrushed = isBrushed || !!brushModel.areas.length;\n    });\n    this._brushType = brushType;\n    this._brushMode = brushMode;\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(featureModel.get('type', true), function (type) {\n      featureModel.setIconStatus(type, (type === 'keep' ? brushMode === 'multiple' : type === 'clear' ? isBrushed : type === brushType) ? 'emphasis' : 'normal');\n    });\n  };\n  BrushFeature.prototype.updateView = function (featureModel, ecModel, api) {\n    this.render(featureModel, ecModel, api);\n  };\n  BrushFeature.prototype.getIcons = function () {\n    var model = this.model;\n    var availableIcons = model.get('icon', true);\n    var icons = {};\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(model.get('type', true), function (type) {\n      if (availableIcons[type]) {\n        icons[type] = availableIcons[type];\n      }\n    });\n    return icons;\n  };\n  ;\n  BrushFeature.prototype.onclick = function (ecModel, api, type) {\n    var brushType = this._brushType;\n    var brushMode = this._brushMode;\n    if (type === 'clear') {\n      // Trigger parallel action firstly\n      api.dispatchAction({\n        type: 'axisAreaSelect',\n        intervals: []\n      });\n      api.dispatchAction({\n        type: 'brush',\n        command: 'clear',\n        // Clear all areas of all brush components.\n        areas: []\n      });\n    } else {\n      api.dispatchAction({\n        type: 'takeGlobalCursor',\n        key: 'brush',\n        brushOption: {\n          brushType: type === 'keep' ? brushType : brushType === type ? false : type,\n          brushMode: type === 'keep' ? brushMode === 'multiple' ? 'single' : 'multiple' : brushMode\n        }\n      });\n    }\n  };\n  ;\n  BrushFeature.getDefaultOption = function (ecModel) {\n    var defaultOption = {\n      show: true,\n      type: ICON_TYPES.slice(),\n      icon: {\n        /* eslint-disable */\n        rect: 'M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13',\n        polygon: 'M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2',\n        lineX: 'M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4',\n        lineY: 'M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4',\n        keep: 'M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z',\n        clear: 'M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2' // jshint ignore:line\n        /* eslint-enable */\n      },\n      // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`\n      title: ecModel.getLocaleModel().get(['toolbox', 'brush', 'title'])\n    };\n    return defaultOption;\n  };\n  return BrushFeature;\n}(_featureManager_js__WEBPACK_IMPORTED_MODULE_2__/* .ToolboxFeature */ .Ms);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BrushFeature);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU4NTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9CcnVzaC5qcz8zYWZhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IFRvb2xib3hGZWF0dXJlIH0gZnJvbSAnLi4vZmVhdHVyZU1hbmFnZXIuanMnO1xudmFyIElDT05fVFlQRVMgPSBbJ3JlY3QnLCAncG9seWdvbicsICdsaW5lWCcsICdsaW5lWScsICdrZWVwJywgJ2NsZWFyJ107XG52YXIgQnJ1c2hGZWF0dXJlID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEJydXNoRmVhdHVyZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gQnJ1c2hGZWF0dXJlKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICBCcnVzaEZlYXR1cmUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChmZWF0dXJlTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBicnVzaFR5cGU7XG4gICAgdmFyIGJydXNoTW9kZTtcbiAgICB2YXIgaXNCcnVzaGVkO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICBtYWluVHlwZTogJ2JydXNoJ1xuICAgIH0sIGZ1bmN0aW9uIChicnVzaE1vZGVsKSB7XG4gICAgICBicnVzaFR5cGUgPSBicnVzaE1vZGVsLmJydXNoVHlwZTtcbiAgICAgIGJydXNoTW9kZSA9IGJydXNoTW9kZWwuYnJ1c2hPcHRpb24uYnJ1c2hNb2RlIHx8ICdzaW5nbGUnO1xuICAgICAgaXNCcnVzaGVkID0gaXNCcnVzaGVkIHx8ICEhYnJ1c2hNb2RlbC5hcmVhcy5sZW5ndGg7XG4gICAgfSk7XG4gICAgdGhpcy5fYnJ1c2hUeXBlID0gYnJ1c2hUeXBlO1xuICAgIHRoaXMuX2JydXNoTW9kZSA9IGJydXNoTW9kZTtcbiAgICB6clV0aWwuZWFjaChmZWF0dXJlTW9kZWwuZ2V0KCd0eXBlJywgdHJ1ZSksIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBmZWF0dXJlTW9kZWwuc2V0SWNvblN0YXR1cyh0eXBlLCAodHlwZSA9PT0gJ2tlZXAnID8gYnJ1c2hNb2RlID09PSAnbXVsdGlwbGUnIDogdHlwZSA9PT0gJ2NsZWFyJyA/IGlzQnJ1c2hlZCA6IHR5cGUgPT09IGJydXNoVHlwZSkgPyAnZW1waGFzaXMnIDogJ25vcm1hbCcpO1xuICAgIH0pO1xuICB9O1xuICBCcnVzaEZlYXR1cmUucHJvdG90eXBlLnVwZGF0ZVZpZXcgPSBmdW5jdGlvbiAoZmVhdHVyZU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLnJlbmRlcihmZWF0dXJlTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gIH07XG4gIEJydXNoRmVhdHVyZS5wcm90b3R5cGUuZ2V0SWNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICB2YXIgYXZhaWxhYmxlSWNvbnMgPSBtb2RlbC5nZXQoJ2ljb24nLCB0cnVlKTtcbiAgICB2YXIgaWNvbnMgPSB7fTtcbiAgICB6clV0aWwuZWFjaChtb2RlbC5nZXQoJ3R5cGUnLCB0cnVlKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmIChhdmFpbGFibGVJY29uc1t0eXBlXSkge1xuICAgICAgICBpY29uc1t0eXBlXSA9IGF2YWlsYWJsZUljb25zW3R5cGVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpY29ucztcbiAgfTtcbiAgO1xuICBCcnVzaEZlYXR1cmUucHJvdG90eXBlLm9uY2xpY2sgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpLCB0eXBlKSB7XG4gICAgdmFyIGJydXNoVHlwZSA9IHRoaXMuX2JydXNoVHlwZTtcbiAgICB2YXIgYnJ1c2hNb2RlID0gdGhpcy5fYnJ1c2hNb2RlO1xuICAgIGlmICh0eXBlID09PSAnY2xlYXInKSB7XG4gICAgICAvLyBUcmlnZ2VyIHBhcmFsbGVsIGFjdGlvbiBmaXJzdGx5XG4gICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICB0eXBlOiAnYXhpc0FyZWFTZWxlY3QnLFxuICAgICAgICBpbnRlcnZhbHM6IFtdXG4gICAgICB9KTtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHR5cGU6ICdicnVzaCcsXG4gICAgICAgIGNvbW1hbmQ6ICdjbGVhcicsXG4gICAgICAgIC8vIENsZWFyIGFsbCBhcmVhcyBvZiBhbGwgYnJ1c2ggY29tcG9uZW50cy5cbiAgICAgICAgYXJlYXM6IFtdXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ3Rha2VHbG9iYWxDdXJzb3InLFxuICAgICAgICBrZXk6ICdicnVzaCcsXG4gICAgICAgIGJydXNoT3B0aW9uOiB7XG4gICAgICAgICAgYnJ1c2hUeXBlOiB0eXBlID09PSAna2VlcCcgPyBicnVzaFR5cGUgOiBicnVzaFR5cGUgPT09IHR5cGUgPyBmYWxzZSA6IHR5cGUsXG4gICAgICAgICAgYnJ1c2hNb2RlOiB0eXBlID09PSAna2VlcCcgPyBicnVzaE1vZGUgPT09ICdtdWx0aXBsZScgPyAnc2luZ2xlJyA6ICdtdWx0aXBsZScgOiBicnVzaE1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICA7XG4gIEJydXNoRmVhdHVyZS5nZXREZWZhdWx0T3B0aW9uID0gZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICB0eXBlOiBJQ09OX1RZUEVTLnNsaWNlKCksXG4gICAgICBpY29uOiB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgICAgIHJlY3Q6ICdNNy4zLDM0LjcgTTAuNCwxMFYtMC4yaDkuOCBNODkuNiwxMFYtMC4yaC05LjggTTAuNCw2MHYxMC4yaDkuOCBNODkuNiw2MHYxMC4yaC05LjggTTEyLjMsMjIuNFYxMC41aDEzLjEgTTMzLjYsMTAuNWg3LjggTTQ5LjEsMTAuNWg3LjggTTc3LjUsMjIuNFYxMC41aC0xMyBNMTIuMywzMS4xdjguMiBNNzcuNywzMS4xdjguMiBNMTIuMyw0Ny42djExLjloMTMuMSBNMzMuNiw1OS41aDcuNiBNNDkuMSw1OS41IGg3LjcgTTc3LjUsNDcuNnYxMS45aC0xMycsXG4gICAgICAgIHBvbHlnb246ICdNNTUuMiwzNC45YzEuNywwLDMuMSwxLjQsMy4xLDMuMXMtMS40LDMuMS0zLjEsMy4xIHMtMy4xLTEuNC0zLjEtMy4xUzUzLjUsMzQuOSw1NS4yLDM0Ljl6IE01MC40LDUxYzEuNywwLDMuMSwxLjQsMy4xLDMuMWMwLDEuNy0xLjQsMy4xLTMuMSwzLjFjLTEuNywwLTMuMS0xLjQtMy4xLTMuMSBDNDcuMyw1Mi40LDQ4LjcsNTEsNTAuNCw1MXogTTU1LjYsMzcuMWwxLjUtNy44IE02MC4xLDEzLjVsMS42LTguN2wtNy44LDQgTTU5LDE5bC0xLDUuMyBNMjQsMTYuMWw2LjQsNC45bDYuNC0zLjMgTTQ4LjUsMTEuNiBsLTUuOSwzLjEgTTE5LjEsMTIuOEw5LjcsNS4xbDEuMSw3LjcgTTEzLjQsMjkuOGwxLDcuM2w2LjYsMS42IE0xMS42LDE4LjRsMSw2LjEgTTMyLjgsNDEuOSBNMjYuNiw0MC40IE0yNy4zLDQwLjJsNi4xLDEuNiBNNDkuOSw1Mi4xbC01LjYtNy42bC00LjktMS4yJyxcbiAgICAgICAgbGluZVg6ICdNMTUuMiwzMCBNMTkuNywxNS42VjEuOUgyOSBNMzQuOCwxLjlINDAuNCBNNTUuMywxNS42VjEuOUg0NS45IE0xOS43LDQ0LjRWNTguMUgyOSBNMzQuOCw1OC4xSDQwLjQgTTU1LjMsNDQuNCBWNTguMUg0NS45IE0xMi41LDIwLjNsLTkuNCw5LjZsOS42LDkuOCBNMy4xLDI5LjloMTYuNSBNNjIuNSwyMC4zbDkuNCw5LjZMNjIuMywzOS43IE03MS45LDI5LjlINTUuNCcsXG4gICAgICAgIGxpbmVZOiAnTTM4LjgsNy43IE01Mi43LDEyaDEzLjJ2OSBNNjUuOSwyNi42VjMyIE01Mi43LDQ2LjNoMTMuMnYtOSBNMjQuOSwxMkgxMS44djkgTTExLjgsMjYuNlYzMiBNMjQuOSw0Ni4zSDExLjh2LTkgTTQ4LjIsNS4xbC05LjMtOWwtOS40LDkuMiBNMzguOS0zLjlWMTIgTTQ4LjIsNTMuM2wtOS4zLDlsLTkuNC05LjIgTTM4LjksNjIuM1Y0Ni40JyxcbiAgICAgICAga2VlcDogJ000LDEwLjVWMWgxMC4zIE0yMC43LDFoNi4xIE0zMywxaDYuMSBNNTUuNCwxMC41VjFINDUuMiBNNCwxNy4zdjYuNiBNNTUuNiwxNy4zdjYuNiBNNCwzMC41VjQwaDEwLjMgTTIwLjcsNDAgaDYuMSBNMzMsNDBoNi4xIE01NS40LDMwLjVWNDBINDUuMiBNMjEsMTguOWg2Mi45djQ4LjZIMjFWMTguOXonLFxuICAgICAgICBjbGVhcjogJ00yMiwxNC43bDMwLjksMzEgTTUyLjksMTQuN0wyMiw0NS43IE00LjcsMTYuOFY0LjJoMTMuMSBNMjYsNC4yaDcuOCBNNDEuNiw0LjJoNy44IE03MC4zLDE2LjhWNC4ySDU3LjIgTTQuNywyNS45djguNiBNNzAuMywyNS45djguNiBNNC43LDQzLjJ2MTIuNmgxMy4xIE0yNiw1NS44aDcuOCBNNDEuNiw1NS44aDcuOCBNNzAuMyw0My4ydjEyLjZINTcuMicgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgIH0sXG4gICAgICAvLyBgcmVjdGAsIGBwb2x5Z29uYCwgYGxpbmVYYCwgYGxpbmVZYCwgYGtlZXBgLCBgY2xlYXJgXG4gICAgICB0aXRsZTogZWNNb2RlbC5nZXRMb2NhbGVNb2RlbCgpLmdldChbJ3Rvb2xib3gnLCAnYnJ1c2gnLCAndGl0bGUnXSlcbiAgICB9O1xuICAgIHJldHVybiBkZWZhdWx0T3B0aW9uO1xuICB9O1xuICByZXR1cm4gQnJ1c2hGZWF0dXJlO1xufShUb29sYm94RmVhdHVyZSk7XG5leHBvcnQgZGVmYXVsdCBCcnVzaEZlYXR1cmU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///55855\n")},92260:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/extension.js\nvar extension = __webpack_require__(3087);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/installDataZoomSelect.js + 2 modules\nvar installDataZoomSelect = __webpack_require__(95376);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/toolbox/featureManager.js\nvar featureManager = __webpack_require__(16985);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Component.js\nvar Component = __webpack_require__(15915);\n;// ./node_modules/echarts/lib/component/toolbox/ToolboxModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar ToolboxModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ToolboxModel, _super);\n  function ToolboxModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ToolboxModel.type;\n    return _this;\n  }\n  ToolboxModel.prototype.optionUpdated = function () {\n    _super.prototype.optionUpdated.apply(this, arguments);\n    var ecModel = this.ecModel;\n    util.each(this.option.feature, function (featureOpt, featureName) {\n      var Feature = featureManager/* getFeature */.x$(featureName);\n      if (Feature) {\n        if (Feature.getDefaultOption) {\n          Feature.defaultOption = Feature.getDefaultOption(ecModel);\n        }\n        util.merge(featureOpt, Feature.defaultOption);\n      }\n    });\n  };\n  ToolboxModel.type = 'toolbox';\n  ToolboxModel.layoutMode = {\n    type: 'box',\n    ignoreSize: true\n  };\n  ToolboxModel.defaultOption = {\n    show: true,\n    z: 6,\n    // zlevel: 0,\n    orient: 'horizontal',\n    left: 'right',\n    top: 'top',\n    // right\n    // bottom\n    backgroundColor: 'transparent',\n    borderColor: '#ccc',\n    borderRadius: 0,\n    borderWidth: 0,\n    padding: 5,\n    itemSize: 15,\n    itemGap: 8,\n    showTitle: true,\n    iconStyle: {\n      borderColor: '#666',\n      color: 'none'\n    },\n    emphasis: {\n      iconStyle: {\n        borderColor: '#3E98C5'\n      }\n    },\n    // textStyle: {},\n    // feature\n    tooltip: {\n      show: false,\n      position: 'bottom'\n    }\n  };\n  return ToolboxModel;\n}(Component/* default */.A);\n/* harmony default export */ const toolbox_ToolboxModel = (ToolboxModel);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/contain/text.js\nvar contain_text = __webpack_require__(45558);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Model.js + 2 modules\nvar Model = __webpack_require__(43172);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/DataDiffer.js\nvar DataDiffer = __webpack_require__(16563);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/listComponent.js\nvar listComponent = __webpack_require__(2400);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar view_Component = __webpack_require__(59109);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/component.js\nvar component = __webpack_require__(12616);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n;// ./node_modules/echarts/lib/component/toolbox/ToolboxView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar ToolboxView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ToolboxView, _super);\n  function ToolboxView() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  ToolboxView.prototype.render = function (toolboxModel, ecModel, api, payload) {\n    var group = this.group;\n    group.removeAll();\n    if (!toolboxModel.get('show')) {\n      return;\n    }\n    var itemSize = +toolboxModel.get('itemSize');\n    var isVertical = toolboxModel.get('orient') === 'vertical';\n    var featureOpts = toolboxModel.get('feature') || {};\n    var features = this._features || (this._features = {});\n    var featureNames = [];\n    util.each(featureOpts, function (opt, name) {\n      featureNames.push(name);\n    });\n    new DataDiffer/* default */.A(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(util.curry(processFeature, null)).execute();\n    // Keep for diff.\n    this._featureNames = featureNames;\n    function processFeature(newIndex, oldIndex) {\n      var featureName = featureNames[newIndex];\n      var oldName = featureNames[oldIndex];\n      var featureOpt = featureOpts[featureName];\n      var featureModel = new Model/* default */.A(featureOpt, toolboxModel, toolboxModel.ecModel);\n      var feature;\n      // FIX#11236, merge feature title from MagicType newOption. TODO: consider seriesIndex ?\n      if (payload && payload.newTitle != null && payload.featureName === featureName) {\n        featureOpt.title = payload.newTitle;\n      }\n      if (featureName && !oldName) {\n        // Create\n        if (isUserFeatureName(featureName)) {\n          feature = {\n            onclick: featureModel.option.onclick,\n            featureName: featureName\n          };\n        } else {\n          var Feature = (0,featureManager/* getFeature */.x$)(featureName);\n          if (!Feature) {\n            return;\n          }\n          feature = new Feature();\n        }\n        features[featureName] = feature;\n      } else {\n        feature = features[oldName];\n        // If feature does not exist.\n        if (!feature) {\n          return;\n        }\n      }\n      feature.uid = (0,component/* getUID */.$Q)('toolbox-feature');\n      feature.model = featureModel;\n      feature.ecModel = ecModel;\n      feature.api = api;\n      var isToolboxFeature = feature instanceof featureManager/* ToolboxFeature */.Ms;\n      if (!featureName && oldName) {\n        isToolboxFeature && feature.dispose && feature.dispose(ecModel, api);\n        return;\n      }\n      if (!featureModel.get('show') || isToolboxFeature && feature.unusable) {\n        isToolboxFeature && feature.remove && feature.remove(ecModel, api);\n        return;\n      }\n      createIconPaths(featureModel, feature, featureName);\n      featureModel.setIconStatus = function (iconName, status) {\n        var option = this.option;\n        var iconPaths = this.iconPaths;\n        option.iconStatus = option.iconStatus || {};\n        option.iconStatus[iconName] = status;\n        if (iconPaths[iconName]) {\n          (status === 'emphasis' ? states/* enterEmphasis */.HY : states/* leaveEmphasis */.SD)(iconPaths[iconName]);\n        }\n      };\n      if (feature instanceof featureManager/* ToolboxFeature */.Ms) {\n        if (feature.render) {\n          feature.render(featureModel, ecModel, api, payload);\n        }\n      }\n    }\n    function createIconPaths(featureModel, feature, featureName) {\n      var iconStyleModel = featureModel.getModel('iconStyle');\n      var iconStyleEmphasisModel = featureModel.getModel(['emphasis', 'iconStyle']);\n      // If one feature has multiple icons, they are organized as\n      // {\n      //     icon: {\n      //         foo: '',\n      //         bar: ''\n      //     },\n      //     title: {\n      //         foo: '',\n      //         bar: ''\n      //     }\n      // }\n      var icons = feature instanceof featureManager/* ToolboxFeature */.Ms && feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n      var titles = featureModel.get('title') || {};\n      var iconsMap;\n      var titlesMap;\n      if (util.isString(icons)) {\n        iconsMap = {};\n        iconsMap[featureName] = icons;\n      } else {\n        iconsMap = icons;\n      }\n      if (util.isString(titles)) {\n        titlesMap = {};\n        titlesMap[featureName] = titles;\n      } else {\n        titlesMap = titles;\n      }\n      var iconPaths = featureModel.iconPaths = {};\n      util.each(iconsMap, function (iconStr, iconName) {\n        var path = graphic.createIcon(iconStr, {}, {\n          x: -itemSize / 2,\n          y: -itemSize / 2,\n          width: itemSize,\n          height: itemSize\n        }); // TODO handling image\n        path.setStyle(iconStyleModel.getItemStyle());\n        var pathEmphasisState = path.ensureState('emphasis');\n        pathEmphasisState.style = iconStyleEmphasisModel.getItemStyle();\n        // Text position calculation\n        // TODO: extract `textStyle` from `iconStyle` and use `createTextStyle`\n        var textContent = new Text/* default */.Ay({\n          style: {\n            text: titlesMap[iconName],\n            align: iconStyleEmphasisModel.get('textAlign'),\n            borderRadius: iconStyleEmphasisModel.get('textBorderRadius'),\n            padding: iconStyleEmphasisModel.get('textPadding'),\n            fill: null,\n            font: (0,labelStyle/* getFont */.c8)({\n              fontStyle: iconStyleEmphasisModel.get('textFontStyle'),\n              fontFamily: iconStyleEmphasisModel.get('textFontFamily'),\n              fontSize: iconStyleEmphasisModel.get('textFontSize'),\n              fontWeight: iconStyleEmphasisModel.get('textFontWeight')\n            }, ecModel)\n          },\n          ignore: true\n        });\n        path.setTextContent(textContent);\n        graphic.setTooltipConfig({\n          el: path,\n          componentModel: toolboxModel,\n          itemName: iconName,\n          formatterParamsExtra: {\n            title: titlesMap[iconName]\n          }\n        });\n        path.__title = titlesMap[iconName];\n        path.on('mouseover', function () {\n          // Should not reuse above hoverStyle, which might be modified.\n          var hoverStyle = iconStyleEmphasisModel.getItemStyle();\n          var defaultTextPosition = isVertical ? toolboxModel.get('right') == null && toolboxModel.get('left') !== 'right' ? 'right' : 'left' : toolboxModel.get('bottom') == null && toolboxModel.get('top') !== 'bottom' ? 'bottom' : 'top';\n          textContent.setStyle({\n            fill: iconStyleEmphasisModel.get('textFill') || hoverStyle.fill || hoverStyle.stroke || '#000',\n            backgroundColor: iconStyleEmphasisModel.get('textBackgroundColor')\n          });\n          path.setTextConfig({\n            position: iconStyleEmphasisModel.get('textPosition') || defaultTextPosition\n          });\n          textContent.ignore = !toolboxModel.get('showTitle');\n          // Use enterEmphasis and leaveEmphasis provide by ec.\n          // There are flags managed by the echarts.\n          api.enterEmphasis(this);\n        }).on('mouseout', function () {\n          if (featureModel.get(['iconStatus', iconName]) !== 'emphasis') {\n            api.leaveEmphasis(this);\n          }\n          textContent.hide();\n        });\n        (featureModel.get(['iconStatus', iconName]) === 'emphasis' ? states/* enterEmphasis */.HY : states/* leaveEmphasis */.SD)(path);\n        group.add(path);\n        path.on('click', util.bind(feature.onclick, feature, ecModel, api, iconName));\n        iconPaths[iconName] = path;\n      });\n    }\n    listComponent/* layout */.Z(group, toolboxModel, api);\n    // Render background after group is layout\n    // FIXME\n    group.add(listComponent/* makeBackground */.P(group.getBoundingRect(), toolboxModel));\n    // Adjust icon title positions to avoid them out of screen\n    isVertical || group.eachChild(function (icon) {\n      var titleText = icon.__title;\n      // const hoverStyle = icon.hoverStyle;\n      // TODO simplify code?\n      var emphasisState = icon.ensureState('emphasis');\n      var emphasisTextConfig = emphasisState.textConfig || (emphasisState.textConfig = {});\n      var textContent = icon.getTextContent();\n      var emphasisTextState = textContent && textContent.ensureState('emphasis');\n      // May be background element\n      if (emphasisTextState && !util.isFunction(emphasisTextState) && titleText) {\n        var emphasisTextStyle = emphasisTextState.style || (emphasisTextState.style = {});\n        var rect = contain_text/* getBoundingRect */.NO(titleText, Text/* default */.Ay.makeFont(emphasisTextStyle));\n        var offsetX = icon.x + group.x;\n        var offsetY = icon.y + group.y + itemSize;\n        var needPutOnTop = false;\n        if (offsetY + rect.height > api.getHeight()) {\n          emphasisTextConfig.position = 'top';\n          needPutOnTop = true;\n        }\n        var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 10;\n        if (offsetX + rect.width / 2 > api.getWidth()) {\n          emphasisTextConfig.position = ['100%', topOffset];\n          emphasisTextStyle.align = 'right';\n        } else if (offsetX - rect.width / 2 < 0) {\n          emphasisTextConfig.position = [0, topOffset];\n          emphasisTextStyle.align = 'left';\n        }\n      }\n    });\n  };\n  ToolboxView.prototype.updateView = function (toolboxModel, ecModel, api, payload) {\n    util.each(this._features, function (feature) {\n      feature instanceof featureManager/* ToolboxFeature */.Ms && feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n    });\n  };\n  // updateLayout(toolboxModel, ecModel, api, payload) {\n  //     zrUtil.each(this._features, function (feature) {\n  //         feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);\n  //     });\n  // },\n  ToolboxView.prototype.remove = function (ecModel, api) {\n    util.each(this._features, function (feature) {\n      feature instanceof featureManager/* ToolboxFeature */.Ms && feature.remove && feature.remove(ecModel, api);\n    });\n    this.group.removeAll();\n  };\n  ToolboxView.prototype.dispose = function (ecModel, api) {\n    util.each(this._features, function (feature) {\n      feature instanceof featureManager/* ToolboxFeature */.Ms && feature.dispose && feature.dispose(ecModel, api);\n    });\n  };\n  ToolboxView.type = 'toolbox';\n  return ToolboxView;\n}(view_Component/* default */.A);\nfunction isUserFeatureName(featureName) {\n  return featureName.indexOf('my') === 0;\n}\n/* harmony default export */ const toolbox_ToolboxView = (ToolboxView);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/env.js\nvar env = __webpack_require__(38123);\n;// ./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/* global window, Uint8Array, document */\n\n\nvar SaveAsImage = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(SaveAsImage, _super);\n  function SaveAsImage() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  SaveAsImage.prototype.onclick = function (ecModel, api) {\n    var model = this.model;\n    var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n    var isSvg = api.getZr().painter.getType() === 'svg';\n    var type = isSvg ? 'svg' : model.get('type', true) || 'png';\n    var url = api.getConnectedDataURL({\n      type: type,\n      backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',\n      connectedBackgroundColor: model.get('connectedBackgroundColor'),\n      excludeComponents: model.get('excludeComponents'),\n      pixelRatio: model.get('pixelRatio')\n    });\n    var browser = env/* default */.A.browser;\n    // Chrome, Firefox, New Edge\n    if (typeof MouseEvent === 'function' && (browser.newEdge || !browser.ie && !browser.edge)) {\n      var $a = document.createElement('a');\n      $a.download = title + '.' + type;\n      $a.target = '_blank';\n      $a.href = url;\n      var evt = new MouseEvent('click', {\n        // some micro front-end frameworkï¼Œ window maybe is a Proxy\n        view: document.defaultView,\n        bubbles: true,\n        cancelable: false\n      });\n      $a.dispatchEvent(evt);\n    }\n    // IE or old Edge\n    else {\n      // @ts-ignore\n      if (window.navigator.msSaveOrOpenBlob || isSvg) {\n        var parts = url.split(',');\n        // data:[<mime type>][;charset=<charset>][;base64],<encoded data>\n        var base64Encoded = parts[0].indexOf('base64') > -1;\n        var bstr = isSvg\n        // should decode the svg data uri first\n        ? decodeURIComponent(parts[1]) : parts[1];\n        // only `atob` when the data uri is encoded with base64\n        // otherwise, like `svg` data uri exported by zrender,\n        // there will be an error, for it's not encoded with base64.\n        // (just a url-encoded string through `encodeURIComponent`)\n        base64Encoded && (bstr = window.atob(bstr));\n        var filename = title + '.' + type;\n        // @ts-ignore\n        if (window.navigator.msSaveOrOpenBlob) {\n          var n = bstr.length;\n          var u8arr = new Uint8Array(n);\n          while (n--) {\n            u8arr[n] = bstr.charCodeAt(n);\n          }\n          var blob = new Blob([u8arr]); // @ts-ignore\n          window.navigator.msSaveOrOpenBlob(blob, filename);\n        } else {\n          var frame = document.createElement('iframe');\n          document.body.appendChild(frame);\n          var cw = frame.contentWindow;\n          var doc = cw.document;\n          doc.open('image/svg+xml', 'replace');\n          doc.write(bstr);\n          doc.close();\n          cw.focus();\n          doc.execCommand('SaveAs', true, filename);\n          document.body.removeChild(frame);\n        }\n      } else {\n        var lang = model.get('lang');\n        var html = '' + '<body style=\"margin:0;\">' + '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + (lang && lang[0] || '') + '\" />' + '</body>';\n        var tab = window.open();\n        tab.document.write(html);\n        tab.document.title = title;\n      }\n    }\n  };\n  SaveAsImage.getDefaultOption = function (ecModel) {\n    var defaultOption = {\n      show: true,\n      icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n      title: ecModel.getLocaleModel().get(['toolbox', 'saveAsImage', 'title']),\n      type: 'png',\n      // Default use option.backgroundColor\n      // backgroundColor: '#fff',\n      connectedBackgroundColor: '#fff',\n      name: '',\n      excludeComponents: ['toolbox'],\n      // use current pixel ratio of device by default\n      // pixelRatio: 1,\n      lang: ecModel.getLocaleModel().get(['toolbox', 'saveAsImage', 'lang'])\n    };\n    return defaultOption;\n  };\n  return SaveAsImage;\n}(featureManager/* ToolboxFeature */.Ms);\n/* harmony default export */ const feature_SaveAsImage = (SaveAsImage);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/core/echarts.js + 3 modules\nvar echarts = __webpack_require__(95383);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar util_model = __webpack_require__(48170);\n;// ./node_modules/echarts/lib/component/toolbox/feature/MagicType.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar INNER_STACK_KEYWORD = '__ec_magicType_stack__';\nvar ICON_TYPES = (/* unused pure expression or super */ null && (['line', 'bar', 'stack']));\n// stack and tiled appears in pair for the title\nvar TITLE_TYPES = (/* unused pure expression or super */ null && (['line', 'bar', 'stack', 'tiled']));\nvar radioTypes = [['line', 'bar'], ['stack']];\nvar MagicType = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(MagicType, _super);\n  function MagicType() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  MagicType.prototype.getIcons = function () {\n    var model = this.model;\n    var availableIcons = model.get('icon');\n    var icons = {};\n    util.each(model.get('type'), function (type) {\n      if (availableIcons[type]) {\n        icons[type] = availableIcons[type];\n      }\n    });\n    return icons;\n  };\n  MagicType.getDefaultOption = function (ecModel) {\n    var defaultOption = {\n      show: true,\n      type: [],\n      // Icon group\n      icon: {\n        line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n        bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n        // eslint-disable-next-line\n        stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z' // jshint ignore:line\n      },\n      // `line`, `bar`, `stack`, `tiled`\n      title: ecModel.getLocaleModel().get(['toolbox', 'magicType', 'title']),\n      option: {},\n      seriesIndex: {}\n    };\n    return defaultOption;\n  };\n  MagicType.prototype.onclick = function (ecModel, api, type) {\n    var model = this.model;\n    var seriesIndex = model.get(['seriesIndex', type]);\n    // Not supported magicType\n    if (!seriesOptGenreator[type]) {\n      return;\n    }\n    var newOption = {\n      series: []\n    };\n    var generateNewSeriesTypes = function (seriesModel) {\n      var seriesType = seriesModel.subType;\n      var seriesId = seriesModel.id;\n      var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);\n      if (newSeriesOpt) {\n        // PENDING If merge original option?\n        util.defaults(newSeriesOpt, seriesModel.option);\n        newOption.series.push(newSeriesOpt);\n      }\n      // Modify boundaryGap\n      var coordSys = seriesModel.coordinateSystem;\n      if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n        var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n        if (categoryAxis) {\n          var axisDim = categoryAxis.dim;\n          var axisType = axisDim + 'Axis';\n          var axisModel = seriesModel.getReferringComponents(axisType, util_model/* SINGLE_REFERRING */.US).models[0];\n          var axisIndex = axisModel.componentIndex;\n          newOption[axisType] = newOption[axisType] || [];\n          for (var i = 0; i <= axisIndex; i++) {\n            newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n          }\n          newOption[axisType][axisIndex].boundaryGap = type === 'bar';\n        }\n      }\n    };\n    util.each(radioTypes, function (radio) {\n      if (util.indexOf(radio, type) >= 0) {\n        util.each(radio, function (item) {\n          model.setIconStatus(item, 'normal');\n        });\n      }\n    });\n    model.setIconStatus(type, 'emphasis');\n    ecModel.eachComponent({\n      mainType: 'series',\n      query: seriesIndex == null ? null : {\n        seriesIndex: seriesIndex\n      }\n    }, generateNewSeriesTypes);\n    var newTitle;\n    var currentType = type;\n    // Change title of stack\n    if (type === 'stack') {\n      // use titles in model instead of ecModel\n      // as stack and tiled appears in pair, just flip them\n      // no need of checking stack state\n      newTitle = util.merge({\n        stack: model.option.title.tiled,\n        tiled: model.option.title.stack\n      }, model.option.title);\n      if (model.get(['iconStatus', type]) !== 'emphasis') {\n        currentType = 'tiled';\n      }\n    }\n    api.dispatchAction({\n      type: 'changeMagicType',\n      currentType: currentType,\n      newOption: newOption,\n      newTitle: newTitle,\n      featureName: 'magicType'\n    });\n  };\n  return MagicType;\n}(featureManager/* ToolboxFeature */.Ms);\nvar seriesOptGenreator = {\n  'line': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'bar') {\n      return util.merge({\n        id: seriesId,\n        type: 'line',\n        // Preserve data related option\n        data: seriesModel.get('data'),\n        stack: seriesModel.get('stack'),\n        markPoint: seriesModel.get('markPoint'),\n        markLine: seriesModel.get('markLine')\n      }, model.get(['option', 'line']) || {}, true);\n    }\n  },\n  'bar': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line') {\n      return util.merge({\n        id: seriesId,\n        type: 'bar',\n        // Preserve data related option\n        data: seriesModel.get('data'),\n        stack: seriesModel.get('stack'),\n        markPoint: seriesModel.get('markPoint'),\n        markLine: seriesModel.get('markLine')\n      }, model.get(['option', 'bar']) || {}, true);\n    }\n  },\n  'stack': function (seriesType, seriesId, seriesModel, model) {\n    var isStack = seriesModel.get('stack') === INNER_STACK_KEYWORD;\n    if (seriesType === 'line' || seriesType === 'bar') {\n      model.setIconStatus('stack', isStack ? 'normal' : 'emphasis');\n      return util.merge({\n        id: seriesId,\n        stack: isStack ? '' : INNER_STACK_KEYWORD\n      }, model.get(['option', 'stack']) || {}, true);\n    }\n  }\n};\n// TODO: SELF REGISTERED.\necharts/* registerAction */.OH({\n  type: 'changeMagicType',\n  event: 'magicTypeChanged',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  ecModel.mergeOption(payload.newOption);\n});\n/* harmony default export */ const feature_MagicType = (MagicType);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/event.js\nvar core_event = __webpack_require__(35452);\n;// ./node_modules/echarts/lib/component/toolbox/feature/DataView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/* global document */\n\n\n\n\n\n/* global document */\nvar BLOCK_SPLITER = new Array(60).join('-');\nvar ITEM_SPLITER = '\\t';\n/**\r\n * Group series into two types\r\n *  1. on category axis, like line, bar\r\n *  2. others, like scatter, pie\r\n */\nfunction groupSeries(ecModel) {\n  var seriesGroupByCategoryAxis = {};\n  var otherSeries = [];\n  var meta = [];\n  ecModel.eachRawSeries(function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n    if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n      // TODO: TYPE Consider polar? Include polar may increase unecessary bundle size.\n      var baseAxis = coordSys.getBaseAxis();\n      if (baseAxis.type === 'category') {\n        var key = baseAxis.dim + '_' + baseAxis.index;\n        if (!seriesGroupByCategoryAxis[key]) {\n          seriesGroupByCategoryAxis[key] = {\n            categoryAxis: baseAxis,\n            valueAxis: coordSys.getOtherAxis(baseAxis),\n            series: []\n          };\n          meta.push({\n            axisDim: baseAxis.dim,\n            axisIndex: baseAxis.index\n          });\n        }\n        seriesGroupByCategoryAxis[key].series.push(seriesModel);\n      } else {\n        otherSeries.push(seriesModel);\n      }\n    } else {\n      otherSeries.push(seriesModel);\n    }\n  });\n  return {\n    seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n    other: otherSeries,\n    meta: meta\n  };\n}\n/**\r\n * Assemble content of series on cateogory axis\r\n * @inner\r\n */\nfunction assembleSeriesWithCategoryAxis(groups) {\n  var tables = [];\n  util.each(groups, function (group, key) {\n    var categoryAxis = group.categoryAxis;\n    var valueAxis = group.valueAxis;\n    var valueAxisDim = valueAxis.dim;\n    var headers = [' '].concat(util.map(group.series, function (series) {\n      return series.name;\n    }));\n    // @ts-ignore TODO Polar\n    var columns = [categoryAxis.model.getCategories()];\n    util.each(group.series, function (series) {\n      var rawData = series.getRawData();\n      columns.push(series.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function (val) {\n        return val;\n      }));\n    });\n    // Assemble table content\n    var lines = [headers.join(ITEM_SPLITER)];\n    for (var i = 0; i < columns[0].length; i++) {\n      var items = [];\n      for (var j = 0; j < columns.length; j++) {\n        items.push(columns[j][i]);\n      }\n      lines.push(items.join(ITEM_SPLITER));\n    }\n    tables.push(lines.join('\\n'));\n  });\n  return tables.join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\n/**\r\n * Assemble content of other series\r\n */\nfunction assembleOtherSeries(series) {\n  return util.map(series, function (series) {\n    var data = series.getRawData();\n    var lines = [series.name];\n    var vals = [];\n    data.each(data.dimensions, function () {\n      var argLen = arguments.length;\n      var dataIndex = arguments[argLen - 1];\n      var name = data.getName(dataIndex);\n      for (var i = 0; i < argLen - 1; i++) {\n        vals[i] = arguments[i];\n      }\n      lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));\n    });\n    return lines.join('\\n');\n  }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\nfunction getContentFromModel(ecModel) {\n  var result = groupSeries(ecModel);\n  return {\n    value: util.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {\n      return !!str.replace(/[\\n\\t\\s]/g, '');\n    }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n    meta: result.meta\n  };\n}\nfunction trim(str) {\n  return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n}\n/**\r\n * If a block is tsv format\r\n */\nfunction isTSVFormat(block) {\n  // Simple method to find out if a block is tsv format\n  var firstLine = block.slice(0, block.indexOf('\\n'));\n  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n    return true;\n  }\n}\nvar itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n/**\r\n * @param {string} tsv\r\n * @return {Object}\r\n */\nfunction parseTSVContents(tsv) {\n  var tsvLines = tsv.split(/\\n+/g);\n  var headers = trim(tsvLines.shift()).split(itemSplitRegex);\n  var categories = [];\n  var series = util.map(headers, function (header) {\n    return {\n      name: header,\n      data: []\n    };\n  });\n  for (var i = 0; i < tsvLines.length; i++) {\n    var items = trim(tsvLines[i]).split(itemSplitRegex);\n    categories.push(items.shift());\n    for (var j = 0; j < items.length; j++) {\n      series[j] && (series[j].data[i] = items[j]);\n    }\n  }\n  return {\n    series: series,\n    categories: categories\n  };\n}\nfunction parseListContents(str) {\n  var lines = str.split(/\\n+/g);\n  var seriesName = trim(lines.shift());\n  var data = [];\n  for (var i = 0; i < lines.length; i++) {\n    // if line is empty, ignore it.\n    // there is a case that a user forgot to delete `\\n`.\n    var line = trim(lines[i]);\n    if (!line) {\n      continue;\n    }\n    var items = line.split(itemSplitRegex);\n    var name_1 = '';\n    var value = void 0;\n    var hasName = false;\n    if (isNaN(items[0])) {\n      // First item is name\n      hasName = true;\n      name_1 = items[0];\n      items = items.slice(1);\n      data[i] = {\n        name: name_1,\n        value: []\n      };\n      value = data[i].value;\n    } else {\n      value = data[i] = [];\n    }\n    for (var j = 0; j < items.length; j++) {\n      value.push(+items[j]);\n    }\n    if (value.length === 1) {\n      hasName ? data[i].value = value[0] : data[i] = value[0];\n    }\n  }\n  return {\n    name: seriesName,\n    data: data\n  };\n}\nfunction parseContents(str, blockMetaList) {\n  var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n  var newOption = {\n    series: []\n  };\n  util.each(blocks, function (block, idx) {\n    if (isTSVFormat(block)) {\n      var result = parseTSVContents(block);\n      var blockMeta = blockMetaList[idx];\n      var axisKey = blockMeta.axisDim + 'Axis';\n      if (blockMeta) {\n        newOption[axisKey] = newOption[axisKey] || [];\n        newOption[axisKey][blockMeta.axisIndex] = {\n          data: result.categories\n        };\n        newOption.series = newOption.series.concat(result.series);\n      }\n    } else {\n      var result = parseListContents(block);\n      newOption.series.push(result);\n    }\n  });\n  return newOption;\n}\nvar DataView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(DataView, _super);\n  function DataView() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DataView.prototype.onclick = function (ecModel, api) {\n    // FIXME: better way?\n    setTimeout(function () {\n      api.dispatchAction({\n        type: 'hideTip'\n      });\n    });\n    var container = api.getDom();\n    var model = this.model;\n    if (this._dom) {\n      container.removeChild(this._dom);\n    }\n    var root = document.createElement('div');\n    // use padding to avoid 5px whitespace\n    root.style.cssText = 'position:absolute;top:0;bottom:0;left:0;right:0;padding:5px';\n    root.style.backgroundColor = model.get('backgroundColor') || '#fff';\n    // Create elements\n    var header = document.createElement('h4');\n    var lang = model.get('lang') || [];\n    header.innerHTML = lang[0] || model.get('title');\n    header.style.cssText = 'margin:10px 20px';\n    header.style.color = model.get('textColor');\n    var viewMain = document.createElement('div');\n    var textarea = document.createElement('textarea');\n    viewMain.style.cssText = 'overflow:auto';\n    var optionToContent = model.get('optionToContent');\n    var contentToOption = model.get('contentToOption');\n    var result = getContentFromModel(ecModel);\n    if (util.isFunction(optionToContent)) {\n      var htmlOrDom = optionToContent(api.getOption());\n      if (util.isString(htmlOrDom)) {\n        viewMain.innerHTML = htmlOrDom;\n      } else if (util.isDom(htmlOrDom)) {\n        viewMain.appendChild(htmlOrDom);\n      }\n    } else {\n      // Use default textarea\n      textarea.readOnly = model.get('readOnly');\n      var style = textarea.style;\n      // eslint-disable-next-line max-len\n      style.cssText = 'display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none';\n      style.color = model.get('textColor');\n      style.borderColor = model.get('textareaBorderColor');\n      style.backgroundColor = model.get('textareaColor');\n      textarea.value = result.value;\n      viewMain.appendChild(textarea);\n    }\n    var blockMetaList = result.meta;\n    var buttonContainer = document.createElement('div');\n    buttonContainer.style.cssText = 'position:absolute;bottom:5px;left:0;right:0';\n    // eslint-disable-next-line max-len\n    var buttonStyle = 'float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n    var closeButton = document.createElement('div');\n    var refreshButton = document.createElement('div');\n    buttonStyle += ';background-color:' + model.get('buttonColor');\n    buttonStyle += ';color:' + model.get('buttonTextColor');\n    var self = this;\n    function close() {\n      container.removeChild(root);\n      self._dom = null;\n    }\n    (0,core_event/* addEventListener */.q2)(closeButton, 'click', close);\n    (0,core_event/* addEventListener */.q2)(refreshButton, 'click', function () {\n      if (contentToOption == null && optionToContent != null || contentToOption != null && optionToContent == null) {\n        if (false) {}\n        close();\n        return;\n      }\n      var newOption;\n      try {\n        if (util.isFunction(contentToOption)) {\n          newOption = contentToOption(viewMain, api.getOption());\n        } else {\n          newOption = parseContents(textarea.value, blockMetaList);\n        }\n      } catch (e) {\n        close();\n        throw new Error('Data view format error ' + e);\n      }\n      if (newOption) {\n        api.dispatchAction({\n          type: 'changeDataView',\n          newOption: newOption\n        });\n      }\n      close();\n    });\n    closeButton.innerHTML = lang[1];\n    refreshButton.innerHTML = lang[2];\n    refreshButton.style.cssText = closeButton.style.cssText = buttonStyle;\n    !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n    buttonContainer.appendChild(closeButton);\n    root.appendChild(header);\n    root.appendChild(viewMain);\n    root.appendChild(buttonContainer);\n    viewMain.style.height = container.clientHeight - 80 + 'px';\n    container.appendChild(root);\n    this._dom = root;\n  };\n  DataView.prototype.remove = function (ecModel, api) {\n    this._dom && api.getDom().removeChild(this._dom);\n  };\n  DataView.prototype.dispose = function (ecModel, api) {\n    this.remove(ecModel, api);\n  };\n  DataView.getDefaultOption = function (ecModel) {\n    var defaultOption = {\n      show: true,\n      readOnly: false,\n      optionToContent: null,\n      contentToOption: null,\n      // eslint-disable-next-line\n      icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n      title: ecModel.getLocaleModel().get(['toolbox', 'dataView', 'title']),\n      lang: ecModel.getLocaleModel().get(['toolbox', 'dataView', 'lang']),\n      backgroundColor: '#fff',\n      textColor: '#000',\n      textareaColor: '#fff',\n      textareaBorderColor: '#333',\n      buttonColor: '#c23531',\n      buttonTextColor: '#fff'\n    };\n    return defaultOption;\n  };\n  return DataView;\n}(featureManager/* ToolboxFeature */.Ms);\n/**\r\n * @inner\r\n */\nfunction tryMergeDataOption(newData, originalData) {\n  return util.map(newData, function (newVal, idx) {\n    var original = originalData && originalData[idx];\n    if (util.isObject(original) && !util.isArray(original)) {\n      var newValIsObject = util.isObject(newVal) && !util.isArray(newVal);\n      if (!newValIsObject) {\n        newVal = {\n          value: newVal\n        };\n      }\n      // original data has name but new data has no name\n      var shouldDeleteName = original.name != null && newVal.name == null;\n      // Original data has option\n      newVal = util.defaults(newVal, original);\n      shouldDeleteName && delete newVal.name;\n      return newVal;\n    } else {\n      return newVal;\n    }\n  });\n}\n// TODO: SELF REGISTERED.\necharts/* registerAction */.OH({\n  type: 'changeDataView',\n  event: 'dataViewChanged',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  var newSeriesOptList = [];\n  util.each(payload.newOption.series, function (seriesOpt) {\n    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n    if (!seriesModel) {\n      // New created series\n      // Geuss the series type\n      newSeriesOptList.push(util.extend({\n        // Default is scatter\n        type: 'scatter'\n      }, seriesOpt));\n    } else {\n      var originalData = seriesModel.get('data');\n      newSeriesOptList.push({\n        name: seriesOpt.name,\n        data: tryMergeDataOption(seriesOpt.data, originalData)\n      });\n    }\n  });\n  ecModel.mergeOption(util.defaults({\n    series: newSeriesOptList\n  }, payload.newOption));\n});\n/* harmony default export */ const feature_DataView = (DataView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/history.js\nvar dataZoom_history = __webpack_require__(78668);\n;// ./node_modules/echarts/lib/component/toolbox/feature/Restore.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar RestoreOption = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(RestoreOption, _super);\n  function RestoreOption() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  RestoreOption.prototype.onclick = function (ecModel, api) {\n    dataZoom_history/* clear */.IU(ecModel);\n    api.dispatchAction({\n      type: 'restore',\n      from: this.uid\n    });\n  };\n  RestoreOption.getDefaultOption = function (ecModel) {\n    var defaultOption = {\n      show: true,\n      // eslint-disable-next-line\n      icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n      title: ecModel.getLocaleModel().get(['toolbox', 'restore', 'title'])\n    };\n    return defaultOption;\n  };\n  return RestoreOption;\n}(featureManager/* ToolboxFeature */.Ms);\n// TODO: SELF REGISTERED.\necharts/* registerAction */.OH({\n  type: 'restore',\n  event: 'restore',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  ecModel.resetOption('recreate');\n});\n/* harmony default export */ const Restore = (RestoreOption);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/BrushController.js\nvar BrushController = __webpack_require__(14403);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/BrushTargetManager.js\nvar BrushTargetManager = __webpack_require__(98595);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/sliderMove.js\nvar sliderMove = __webpack_require__(98983);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/internalComponentCreator.js\nvar internalComponentCreator = __webpack_require__(7442);\n;// ./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n// TODO depends on DataZoom and Brush\n\n\n\n\n\n\n\n\nvar each = util.each;\nvar DATA_ZOOM_ID_BASE = (0,util_model/* makeInternalComponentId */.S_)('toolbox-dataZoom_');\nvar DataZoom_ICON_TYPES = (/* unused pure expression or super */ null && (['zoom', 'back']));\nvar DataZoomFeature = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(DataZoomFeature, _super);\n  function DataZoomFeature() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DataZoomFeature.prototype.render = function (featureModel, ecModel, api, payload) {\n    if (!this._brushController) {\n      this._brushController = new BrushController/* default */.A(api.getZr());\n      this._brushController.on('brush', util.bind(this._onBrush, this)).mount();\n    }\n    updateZoomBtnStatus(featureModel, ecModel, this, payload, api);\n    updateBackBtnStatus(featureModel, ecModel);\n  };\n  DataZoomFeature.prototype.onclick = function (ecModel, api, type) {\n    handlers[type].call(this);\n  };\n  DataZoomFeature.prototype.remove = function (ecModel, api) {\n    this._brushController && this._brushController.unmount();\n  };\n  DataZoomFeature.prototype.dispose = function (ecModel, api) {\n    this._brushController && this._brushController.dispose();\n  };\n  DataZoomFeature.prototype._onBrush = function (eventParam) {\n    var areas = eventParam.areas;\n    if (!eventParam.isEnd || !areas.length) {\n      return;\n    }\n    var snapshot = {};\n    var ecModel = this.ecModel;\n    this._brushController.updateCovers([]); // remove cover\n    var brushTargetManager = new BrushTargetManager/* default */.A(makeAxisFinder(this.model), ecModel, {\n      include: ['grid']\n    });\n    brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n      if (coordSys.type !== 'cartesian2d') {\n        return;\n      }\n      var brushType = area.brushType;\n      if (brushType === 'rect') {\n        setBatch('x', coordSys, coordRange[0]);\n        setBatch('y', coordSys, coordRange[1]);\n      } else {\n        setBatch({\n          lineX: 'x',\n          lineY: 'y'\n        }[brushType], coordSys, coordRange);\n      }\n    });\n    dataZoom_history/* push */.VC(ecModel, snapshot);\n    this._dispatchZoomAction(snapshot);\n    function setBatch(dimName, coordSys, minMax) {\n      var axis = coordSys.getAxis(dimName);\n      var axisModel = axis.model;\n      var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);\n      // Restrict range.\n      var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();\n      if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {\n        minMax = (0,sliderMove/* default */.A)(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);\n      }\n      dataZoomModel && (snapshot[dataZoomModel.id] = {\n        dataZoomId: dataZoomModel.id,\n        startValue: minMax[0],\n        endValue: minMax[1]\n      });\n    }\n    function findDataZoom(dimName, axisModel, ecModel) {\n      var found;\n      ecModel.eachComponent({\n        mainType: 'dataZoom',\n        subType: 'select'\n      }, function (dzModel) {\n        var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);\n        has && (found = dzModel);\n      });\n      return found;\n    }\n  };\n  ;\n  DataZoomFeature.prototype._dispatchZoomAction = function (snapshot) {\n    var batch = [];\n    // Convert from hash map to array.\n    each(snapshot, function (batchItem, dataZoomId) {\n      batch.push(util.clone(batchItem));\n    });\n    batch.length && this.api.dispatchAction({\n      type: 'dataZoom',\n      from: this.uid,\n      batch: batch\n    });\n  };\n  DataZoomFeature.getDefaultOption = function (ecModel) {\n    var defaultOption = {\n      show: true,\n      filterMode: 'filter',\n      // Icon group\n      icon: {\n        zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n        back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n      },\n      // `zoom`, `back`\n      title: ecModel.getLocaleModel().get(['toolbox', 'dataZoom', 'title']),\n      brushStyle: {\n        borderWidth: 0,\n        color: 'rgba(210,219,238,0.2)'\n      }\n    };\n    return defaultOption;\n  };\n  return DataZoomFeature;\n}(featureManager/* ToolboxFeature */.Ms);\nvar handlers = {\n  zoom: function () {\n    var nextActive = !this._isZoomActive;\n    this.api.dispatchAction({\n      type: 'takeGlobalCursor',\n      key: 'dataZoomSelect',\n      dataZoomSelectActive: nextActive\n    });\n  },\n  back: function () {\n    this._dispatchZoomAction(dataZoom_history/* pop */.uY(this.ecModel));\n  }\n};\nfunction makeAxisFinder(dzFeatureModel) {\n  var setting = {\n    xAxisIndex: dzFeatureModel.get('xAxisIndex', true),\n    yAxisIndex: dzFeatureModel.get('yAxisIndex', true),\n    xAxisId: dzFeatureModel.get('xAxisId', true),\n    yAxisId: dzFeatureModel.get('yAxisId', true)\n  };\n  // If both `xAxisIndex` `xAxisId` not set, it means 'all'.\n  // If both `yAxisIndex` `yAxisId` not set, it means 'all'.\n  // Some old cases set like this below to close yAxis control but leave xAxis control:\n  // `{ feature: { dataZoom: { yAxisIndex: false } }`.\n  if (setting.xAxisIndex == null && setting.xAxisId == null) {\n    setting.xAxisIndex = 'all';\n  }\n  if (setting.yAxisIndex == null && setting.yAxisId == null) {\n    setting.yAxisIndex = 'all';\n  }\n  return setting;\n}\nfunction updateBackBtnStatus(featureModel, ecModel) {\n  featureModel.setIconStatus('back', dataZoom_history/* count */.U9(ecModel) > 1 ? 'emphasis' : 'normal');\n}\nfunction updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {\n  var zoomActive = view._isZoomActive;\n  if (payload && payload.type === 'takeGlobalCursor') {\n    zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;\n  }\n  view._isZoomActive = zoomActive;\n  featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n  var brushTargetManager = new BrushTargetManager/* default */.A(makeAxisFinder(featureModel), ecModel, {\n    include: ['grid']\n  });\n  var panels = brushTargetManager.makePanelOpts(api, function (targetInfo) {\n    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect';\n  });\n  view._brushController.setPanels(panels).enableBrush(zoomActive && panels.length ? {\n    brushType: 'auto',\n    brushStyle: featureModel.getModel('brushStyle').getItemStyle()\n  } : false);\n}\n(0,internalComponentCreator/* registerInternalOptionCreator */.S)('dataZoom', function (ecModel) {\n  var toolboxModel = ecModel.getComponent('toolbox', 0);\n  var featureDataZoomPath = ['feature', 'dataZoom'];\n  if (!toolboxModel || toolboxModel.get(featureDataZoomPath) == null) {\n    return;\n  }\n  var dzFeatureModel = toolboxModel.getModel(featureDataZoomPath);\n  var dzOptions = [];\n  var finder = makeAxisFinder(dzFeatureModel);\n  var finderResult = (0,util_model/* parseFinder */._e)(ecModel, finder);\n  each(finderResult.xAxisModels, function (axisModel) {\n    return buildInternalOptions(axisModel, 'xAxis', 'xAxisIndex');\n  });\n  each(finderResult.yAxisModels, function (axisModel) {\n    return buildInternalOptions(axisModel, 'yAxis', 'yAxisIndex');\n  });\n  function buildInternalOptions(axisModel, axisMainType, axisIndexPropName) {\n    var axisIndex = axisModel.componentIndex;\n    var newOpt = {\n      type: 'select',\n      $fromToolbox: true,\n      // Default to be filter\n      filterMode: dzFeatureModel.get('filterMode', true) || 'filter',\n      // Id for merge mapping.\n      id: DATA_ZOOM_ID_BASE + axisMainType + axisIndex\n    };\n    newOpt[axisIndexPropName] = axisIndex;\n    dzOptions.push(newOpt);\n  }\n  return dzOptions;\n});\n/* harmony default export */ const DataZoom = (DataZoomFeature);\n;// ./node_modules/echarts/lib/component/toolbox/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n// TODOD: REGISTER IN INSTALL\n\n\n\n\n\n\nfunction install(registers) {\n  registers.registerComponentModel(toolbox_ToolboxModel);\n  registers.registerComponentView(toolbox_ToolboxView);\n  (0,featureManager/* registerFeature */.M_)('saveAsImage', feature_SaveAsImage);\n  (0,featureManager/* registerFeature */.M_)('magicType', feature_MagicType);\n  (0,featureManager/* registerFeature */.M_)('dataView', feature_DataView);\n  (0,featureManager/* registerFeature */.M_)('dataZoom', DataZoom);\n  (0,featureManager/* registerFeature */.M_)('restore', Restore);\n  (0,extension/* use */.Y)(installDataZoomSelect/* install */.a);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIyNjAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvVG9vbGJveE1vZGVsLmpzPzllZmUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L1Rvb2xib3hWaWV3LmpzP2Y2NDEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvU2F2ZUFzSW1hZ2UuanM/NmVmYyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9NYWdpY1R5cGUuanM/NmMzYyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhVmlldy5qcz8zOWVmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL1Jlc3RvcmUuanM/OGY4ZiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhWm9vbS5qcz9kMGJmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbGJveC9pbnN0YWxsLmpzP2ZkOTciXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgZmVhdHVyZU1hbmFnZXIgZnJvbSAnLi9mZWF0dXJlTWFuYWdlci5qcyc7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50LmpzJztcbnZhciBUb29sYm94TW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVG9vbGJveE1vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBUb29sYm94TW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IFRvb2xib3hNb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBUb29sYm94TW9kZWwucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5vcHRpb25VcGRhdGVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgenJVdGlsLmVhY2godGhpcy5vcHRpb24uZmVhdHVyZSwgZnVuY3Rpb24gKGZlYXR1cmVPcHQsIGZlYXR1cmVOYW1lKSB7XG4gICAgICB2YXIgRmVhdHVyZSA9IGZlYXR1cmVNYW5hZ2VyLmdldEZlYXR1cmUoZmVhdHVyZU5hbWUpO1xuICAgICAgaWYgKEZlYXR1cmUpIHtcbiAgICAgICAgaWYgKEZlYXR1cmUuZ2V0RGVmYXVsdE9wdGlvbikge1xuICAgICAgICAgIEZlYXR1cmUuZGVmYXVsdE9wdGlvbiA9IEZlYXR1cmUuZ2V0RGVmYXVsdE9wdGlvbihlY01vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICB6clV0aWwubWVyZ2UoZmVhdHVyZU9wdCwgRmVhdHVyZS5kZWZhdWx0T3B0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgVG9vbGJveE1vZGVsLnR5cGUgPSAndG9vbGJveCc7XG4gIFRvb2xib3hNb2RlbC5sYXlvdXRNb2RlID0ge1xuICAgIHR5cGU6ICdib3gnLFxuICAgIGlnbm9yZVNpemU6IHRydWVcbiAgfTtcbiAgVG9vbGJveE1vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgc2hvdzogdHJ1ZSxcbiAgICB6OiA2LFxuICAgIC8vIHpsZXZlbDogMCxcbiAgICBvcmllbnQ6ICdob3Jpem9udGFsJyxcbiAgICBsZWZ0OiAncmlnaHQnLFxuICAgIHRvcDogJ3RvcCcsXG4gICAgLy8gcmlnaHRcbiAgICAvLyBib3R0b21cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgYm9yZGVyQ29sb3I6ICcjY2NjJyxcbiAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgcGFkZGluZzogNSxcbiAgICBpdGVtU2l6ZTogMTUsXG4gICAgaXRlbUdhcDogOCxcbiAgICBzaG93VGl0bGU6IHRydWUsXG4gICAgaWNvblN0eWxlOiB7XG4gICAgICBib3JkZXJDb2xvcjogJyM2NjYnLFxuICAgICAgY29sb3I6ICdub25lJ1xuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIGljb25TdHlsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMzRTk4QzUnXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyB0ZXh0U3R5bGU6IHt9LFxuICAgIC8vIGZlYXR1cmVcbiAgICB0b29sdGlwOiB7XG4gICAgICBzaG93OiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uOiAnYm90dG9tJ1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFRvb2xib3hNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuZXhwb3J0IGRlZmF1bHQgVG9vbGJveE1vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIHRleHRDb250YWluIGZyb20gJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcyc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBlbnRlckVtcGhhc2lzLCBsZWF2ZUVtcGhhc2lzIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMuanMnO1xuaW1wb3J0IE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL01vZGVsLmpzJztcbmltcG9ydCBEYXRhRGlmZmVyIGZyb20gJy4uLy4uL2RhdGEvRGF0YURpZmZlci5qcyc7XG5pbXBvcnQgKiBhcyBsaXN0Q29tcG9uZW50SGVscGVyIGZyb20gJy4uL2hlbHBlci9saXN0Q29tcG9uZW50LmpzJztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50LmpzJztcbmltcG9ydCB7IFRvb2xib3hGZWF0dXJlLCBnZXRGZWF0dXJlIH0gZnJvbSAnLi9mZWF0dXJlTWFuYWdlci5qcyc7XG5pbXBvcnQgeyBnZXRVSUQgfSBmcm9tICcuLi8uLi91dGlsL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgWlJUZXh0IGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qcyc7XG5pbXBvcnQgeyBnZXRGb250IH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG52YXIgVG9vbGJveFZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVG9vbGJveFZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFRvb2xib3hWaWV3KCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICBUb29sYm94Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHRvb2xib3hNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgICBpZiAoIXRvb2xib3hNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXRlbVNpemUgPSArdG9vbGJveE1vZGVsLmdldCgnaXRlbVNpemUnKTtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IHRvb2xib3hNb2RlbC5nZXQoJ29yaWVudCcpID09PSAndmVydGljYWwnO1xuICAgIHZhciBmZWF0dXJlT3B0cyA9IHRvb2xib3hNb2RlbC5nZXQoJ2ZlYXR1cmUnKSB8fCB7fTtcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLl9mZWF0dXJlcyB8fCAodGhpcy5fZmVhdHVyZXMgPSB7fSk7XG4gICAgdmFyIGZlYXR1cmVOYW1lcyA9IFtdO1xuICAgIHpyVXRpbC5lYWNoKGZlYXR1cmVPcHRzLCBmdW5jdGlvbiAob3B0LCBuYW1lKSB7XG4gICAgICBmZWF0dXJlTmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICBuZXcgRGF0YURpZmZlcih0aGlzLl9mZWF0dXJlTmFtZXMgfHwgW10sIGZlYXR1cmVOYW1lcykuYWRkKHByb2Nlc3NGZWF0dXJlKS51cGRhdGUocHJvY2Vzc0ZlYXR1cmUpLnJlbW92ZSh6clV0aWwuY3VycnkocHJvY2Vzc0ZlYXR1cmUsIG51bGwpKS5leGVjdXRlKCk7XG4gICAgLy8gS2VlcCBmb3IgZGlmZi5cbiAgICB0aGlzLl9mZWF0dXJlTmFtZXMgPSBmZWF0dXJlTmFtZXM7XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0ZlYXR1cmUobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gICAgICB2YXIgZmVhdHVyZU5hbWUgPSBmZWF0dXJlTmFtZXNbbmV3SW5kZXhdO1xuICAgICAgdmFyIG9sZE5hbWUgPSBmZWF0dXJlTmFtZXNbb2xkSW5kZXhdO1xuICAgICAgdmFyIGZlYXR1cmVPcHQgPSBmZWF0dXJlT3B0c1tmZWF0dXJlTmFtZV07XG4gICAgICB2YXIgZmVhdHVyZU1vZGVsID0gbmV3IE1vZGVsKGZlYXR1cmVPcHQsIHRvb2xib3hNb2RlbCwgdG9vbGJveE1vZGVsLmVjTW9kZWwpO1xuICAgICAgdmFyIGZlYXR1cmU7XG4gICAgICAvLyBGSVgjMTEyMzYsIG1lcmdlIGZlYXR1cmUgdGl0bGUgZnJvbSBNYWdpY1R5cGUgbmV3T3B0aW9uLiBUT0RPOiBjb25zaWRlciBzZXJpZXNJbmRleCA/XG4gICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLm5ld1RpdGxlICE9IG51bGwgJiYgcGF5bG9hZC5mZWF0dXJlTmFtZSA9PT0gZmVhdHVyZU5hbWUpIHtcbiAgICAgICAgZmVhdHVyZU9wdC50aXRsZSA9IHBheWxvYWQubmV3VGl0bGU7XG4gICAgICB9XG4gICAgICBpZiAoZmVhdHVyZU5hbWUgJiYgIW9sZE5hbWUpIHtcbiAgICAgICAgLy8gQ3JlYXRlXG4gICAgICAgIGlmIChpc1VzZXJGZWF0dXJlTmFtZShmZWF0dXJlTmFtZSkpIHtcbiAgICAgICAgICBmZWF0dXJlID0ge1xuICAgICAgICAgICAgb25jbGljazogZmVhdHVyZU1vZGVsLm9wdGlvbi5vbmNsaWNrLFxuICAgICAgICAgICAgZmVhdHVyZU5hbWU6IGZlYXR1cmVOYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgRmVhdHVyZSA9IGdldEZlYXR1cmUoZmVhdHVyZU5hbWUpO1xuICAgICAgICAgIGlmICghRmVhdHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmZWF0dXJlID0gbmV3IEZlYXR1cmUoKTtcbiAgICAgICAgfVxuICAgICAgICBmZWF0dXJlc1tmZWF0dXJlTmFtZV0gPSBmZWF0dXJlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmVhdHVyZSA9IGZlYXR1cmVzW29sZE5hbWVdO1xuICAgICAgICAvLyBJZiBmZWF0dXJlIGRvZXMgbm90IGV4aXN0LlxuICAgICAgICBpZiAoIWZlYXR1cmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZlYXR1cmUudWlkID0gZ2V0VUlEKCd0b29sYm94LWZlYXR1cmUnKTtcbiAgICAgIGZlYXR1cmUubW9kZWwgPSBmZWF0dXJlTW9kZWw7XG4gICAgICBmZWF0dXJlLmVjTW9kZWwgPSBlY01vZGVsO1xuICAgICAgZmVhdHVyZS5hcGkgPSBhcGk7XG4gICAgICB2YXIgaXNUb29sYm94RmVhdHVyZSA9IGZlYXR1cmUgaW5zdGFuY2VvZiBUb29sYm94RmVhdHVyZTtcbiAgICAgIGlmICghZmVhdHVyZU5hbWUgJiYgb2xkTmFtZSkge1xuICAgICAgICBpc1Rvb2xib3hGZWF0dXJlICYmIGZlYXR1cmUuZGlzcG9zZSAmJiBmZWF0dXJlLmRpc3Bvc2UoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFmZWF0dXJlTW9kZWwuZ2V0KCdzaG93JykgfHwgaXNUb29sYm94RmVhdHVyZSAmJiBmZWF0dXJlLnVudXNhYmxlKSB7XG4gICAgICAgIGlzVG9vbGJveEZlYXR1cmUgJiYgZmVhdHVyZS5yZW1vdmUgJiYgZmVhdHVyZS5yZW1vdmUoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3JlYXRlSWNvblBhdGhzKGZlYXR1cmVNb2RlbCwgZmVhdHVyZSwgZmVhdHVyZU5hbWUpO1xuICAgICAgZmVhdHVyZU1vZGVsLnNldEljb25TdGF0dXMgPSBmdW5jdGlvbiAoaWNvbk5hbWUsIHN0YXR1cykge1xuICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgICAgIHZhciBpY29uUGF0aHMgPSB0aGlzLmljb25QYXRocztcbiAgICAgICAgb3B0aW9uLmljb25TdGF0dXMgPSBvcHRpb24uaWNvblN0YXR1cyB8fCB7fTtcbiAgICAgICAgb3B0aW9uLmljb25TdGF0dXNbaWNvbk5hbWVdID0gc3RhdHVzO1xuICAgICAgICBpZiAoaWNvblBhdGhzW2ljb25OYW1lXSkge1xuICAgICAgICAgIChzdGF0dXMgPT09ICdlbXBoYXNpcycgPyBlbnRlckVtcGhhc2lzIDogbGVhdmVFbXBoYXNpcykoaWNvblBhdGhzW2ljb25OYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoZmVhdHVyZSBpbnN0YW5jZW9mIFRvb2xib3hGZWF0dXJlKSB7XG4gICAgICAgIGlmIChmZWF0dXJlLnJlbmRlcikge1xuICAgICAgICAgIGZlYXR1cmUucmVuZGVyKGZlYXR1cmVNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVJY29uUGF0aHMoZmVhdHVyZU1vZGVsLCBmZWF0dXJlLCBmZWF0dXJlTmFtZSkge1xuICAgICAgdmFyIGljb25TdHlsZU1vZGVsID0gZmVhdHVyZU1vZGVsLmdldE1vZGVsKCdpY29uU3R5bGUnKTtcbiAgICAgIHZhciBpY29uU3R5bGVFbXBoYXNpc01vZGVsID0gZmVhdHVyZU1vZGVsLmdldE1vZGVsKFsnZW1waGFzaXMnLCAnaWNvblN0eWxlJ10pO1xuICAgICAgLy8gSWYgb25lIGZlYXR1cmUgaGFzIG11bHRpcGxlIGljb25zLCB0aGV5IGFyZSBvcmdhbml6ZWQgYXNcbiAgICAgIC8vIHtcbiAgICAgIC8vICAgICBpY29uOiB7XG4gICAgICAvLyAgICAgICAgIGZvbzogJycsXG4gICAgICAvLyAgICAgICAgIGJhcjogJydcbiAgICAgIC8vICAgICB9LFxuICAgICAgLy8gICAgIHRpdGxlOiB7XG4gICAgICAvLyAgICAgICAgIGZvbzogJycsXG4gICAgICAvLyAgICAgICAgIGJhcjogJydcbiAgICAgIC8vICAgICB9XG4gICAgICAvLyB9XG4gICAgICB2YXIgaWNvbnMgPSBmZWF0dXJlIGluc3RhbmNlb2YgVG9vbGJveEZlYXR1cmUgJiYgZmVhdHVyZS5nZXRJY29ucyA/IGZlYXR1cmUuZ2V0SWNvbnMoKSA6IGZlYXR1cmVNb2RlbC5nZXQoJ2ljb24nKTtcbiAgICAgIHZhciB0aXRsZXMgPSBmZWF0dXJlTW9kZWwuZ2V0KCd0aXRsZScpIHx8IHt9O1xuICAgICAgdmFyIGljb25zTWFwO1xuICAgICAgdmFyIHRpdGxlc01hcDtcbiAgICAgIGlmICh6clV0aWwuaXNTdHJpbmcoaWNvbnMpKSB7XG4gICAgICAgIGljb25zTWFwID0ge307XG4gICAgICAgIGljb25zTWFwW2ZlYXR1cmVOYW1lXSA9IGljb25zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWNvbnNNYXAgPSBpY29ucztcbiAgICAgIH1cbiAgICAgIGlmICh6clV0aWwuaXNTdHJpbmcodGl0bGVzKSkge1xuICAgICAgICB0aXRsZXNNYXAgPSB7fTtcbiAgICAgICAgdGl0bGVzTWFwW2ZlYXR1cmVOYW1lXSA9IHRpdGxlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlc01hcCA9IHRpdGxlcztcbiAgICAgIH1cbiAgICAgIHZhciBpY29uUGF0aHMgPSBmZWF0dXJlTW9kZWwuaWNvblBhdGhzID0ge307XG4gICAgICB6clV0aWwuZWFjaChpY29uc01hcCwgZnVuY3Rpb24gKGljb25TdHIsIGljb25OYW1lKSB7XG4gICAgICAgIHZhciBwYXRoID0gZ3JhcGhpYy5jcmVhdGVJY29uKGljb25TdHIsIHt9LCB7XG4gICAgICAgICAgeDogLWl0ZW1TaXplIC8gMixcbiAgICAgICAgICB5OiAtaXRlbVNpemUgLyAyLFxuICAgICAgICAgIHdpZHRoOiBpdGVtU2l6ZSxcbiAgICAgICAgICBoZWlnaHQ6IGl0ZW1TaXplXG4gICAgICAgIH0pOyAvLyBUT0RPIGhhbmRsaW5nIGltYWdlXG4gICAgICAgIHBhdGguc2V0U3R5bGUoaWNvblN0eWxlTW9kZWwuZ2V0SXRlbVN0eWxlKCkpO1xuICAgICAgICB2YXIgcGF0aEVtcGhhc2lzU3RhdGUgPSBwYXRoLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpO1xuICAgICAgICBwYXRoRW1waGFzaXNTdGF0ZS5zdHlsZSA9IGljb25TdHlsZUVtcGhhc2lzTW9kZWwuZ2V0SXRlbVN0eWxlKCk7XG4gICAgICAgIC8vIFRleHQgcG9zaXRpb24gY2FsY3VsYXRpb25cbiAgICAgICAgLy8gVE9ETzogZXh0cmFjdCBgdGV4dFN0eWxlYCBmcm9tIGBpY29uU3R5bGVgIGFuZCB1c2UgYGNyZWF0ZVRleHRTdHlsZWBcbiAgICAgICAgdmFyIHRleHRDb250ZW50ID0gbmV3IFpSVGV4dCh7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHRleHQ6IHRpdGxlc01hcFtpY29uTmFtZV0sXG4gICAgICAgICAgICBhbGlnbjogaWNvblN0eWxlRW1waGFzaXNNb2RlbC5nZXQoJ3RleHRBbGlnbicpLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBpY29uU3R5bGVFbXBoYXNpc01vZGVsLmdldCgndGV4dEJvcmRlclJhZGl1cycpLFxuICAgICAgICAgICAgcGFkZGluZzogaWNvblN0eWxlRW1waGFzaXNNb2RlbC5nZXQoJ3RleHRQYWRkaW5nJyksXG4gICAgICAgICAgICBmaWxsOiBudWxsLFxuICAgICAgICAgICAgZm9udDogZ2V0Rm9udCh7XG4gICAgICAgICAgICAgIGZvbnRTdHlsZTogaWNvblN0eWxlRW1waGFzaXNNb2RlbC5nZXQoJ3RleHRGb250U3R5bGUnKSxcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogaWNvblN0eWxlRW1waGFzaXNNb2RlbC5nZXQoJ3RleHRGb250RmFtaWx5JyksXG4gICAgICAgICAgICAgIGZvbnRTaXplOiBpY29uU3R5bGVFbXBoYXNpc01vZGVsLmdldCgndGV4dEZvbnRTaXplJyksXG4gICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGljb25TdHlsZUVtcGhhc2lzTW9kZWwuZ2V0KCd0ZXh0Rm9udFdlaWdodCcpXG4gICAgICAgICAgICB9LCBlY01vZGVsKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWdub3JlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBwYXRoLnNldFRleHRDb250ZW50KHRleHRDb250ZW50KTtcbiAgICAgICAgZ3JhcGhpYy5zZXRUb29sdGlwQ29uZmlnKHtcbiAgICAgICAgICBlbDogcGF0aCxcbiAgICAgICAgICBjb21wb25lbnRNb2RlbDogdG9vbGJveE1vZGVsLFxuICAgICAgICAgIGl0ZW1OYW1lOiBpY29uTmFtZSxcbiAgICAgICAgICBmb3JtYXR0ZXJQYXJhbXNFeHRyYToge1xuICAgICAgICAgICAgdGl0bGU6IHRpdGxlc01hcFtpY29uTmFtZV1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXRoLl9fdGl0bGUgPSB0aXRsZXNNYXBbaWNvbk5hbWVdO1xuICAgICAgICBwYXRoLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gU2hvdWxkIG5vdCByZXVzZSBhYm92ZSBob3ZlclN0eWxlLCB3aGljaCBtaWdodCBiZSBtb2RpZmllZC5cbiAgICAgICAgICB2YXIgaG92ZXJTdHlsZSA9IGljb25TdHlsZUVtcGhhc2lzTW9kZWwuZ2V0SXRlbVN0eWxlKCk7XG4gICAgICAgICAgdmFyIGRlZmF1bHRUZXh0UG9zaXRpb24gPSBpc1ZlcnRpY2FsID8gdG9vbGJveE1vZGVsLmdldCgncmlnaHQnKSA9PSBudWxsICYmIHRvb2xib3hNb2RlbC5nZXQoJ2xlZnQnKSAhPT0gJ3JpZ2h0JyA/ICdyaWdodCcgOiAnbGVmdCcgOiB0b29sYm94TW9kZWwuZ2V0KCdib3R0b20nKSA9PSBudWxsICYmIHRvb2xib3hNb2RlbC5nZXQoJ3RvcCcpICE9PSAnYm90dG9tJyA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICAgICAgdGV4dENvbnRlbnQuc2V0U3R5bGUoe1xuICAgICAgICAgICAgZmlsbDogaWNvblN0eWxlRW1waGFzaXNNb2RlbC5nZXQoJ3RleHRGaWxsJykgfHwgaG92ZXJTdHlsZS5maWxsIHx8IGhvdmVyU3R5bGUuc3Ryb2tlIHx8ICcjMDAwJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogaWNvblN0eWxlRW1waGFzaXNNb2RlbC5nZXQoJ3RleHRCYWNrZ3JvdW5kQ29sb3InKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBhdGguc2V0VGV4dENvbmZpZyh7XG4gICAgICAgICAgICBwb3NpdGlvbjogaWNvblN0eWxlRW1waGFzaXNNb2RlbC5nZXQoJ3RleHRQb3NpdGlvbicpIHx8IGRlZmF1bHRUZXh0UG9zaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0ZXh0Q29udGVudC5pZ25vcmUgPSAhdG9vbGJveE1vZGVsLmdldCgnc2hvd1RpdGxlJyk7XG4gICAgICAgICAgLy8gVXNlIGVudGVyRW1waGFzaXMgYW5kIGxlYXZlRW1waGFzaXMgcHJvdmlkZSBieSBlYy5cbiAgICAgICAgICAvLyBUaGVyZSBhcmUgZmxhZ3MgbWFuYWdlZCBieSB0aGUgZWNoYXJ0cy5cbiAgICAgICAgICBhcGkuZW50ZXJFbXBoYXNpcyh0aGlzKTtcbiAgICAgICAgfSkub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmZWF0dXJlTW9kZWwuZ2V0KFsnaWNvblN0YXR1cycsIGljb25OYW1lXSkgIT09ICdlbXBoYXNpcycpIHtcbiAgICAgICAgICAgIGFwaS5sZWF2ZUVtcGhhc2lzKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0Q29udGVudC5oaWRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAoZmVhdHVyZU1vZGVsLmdldChbJ2ljb25TdGF0dXMnLCBpY29uTmFtZV0pID09PSAnZW1waGFzaXMnID8gZW50ZXJFbXBoYXNpcyA6IGxlYXZlRW1waGFzaXMpKHBhdGgpO1xuICAgICAgICBncm91cC5hZGQocGF0aCk7XG4gICAgICAgIHBhdGgub24oJ2NsaWNrJywgenJVdGlsLmJpbmQoZmVhdHVyZS5vbmNsaWNrLCBmZWF0dXJlLCBlY01vZGVsLCBhcGksIGljb25OYW1lKSk7XG4gICAgICAgIGljb25QYXRoc1tpY29uTmFtZV0gPSBwYXRoO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3RDb21wb25lbnRIZWxwZXIubGF5b3V0KGdyb3VwLCB0b29sYm94TW9kZWwsIGFwaSk7XG4gICAgLy8gUmVuZGVyIGJhY2tncm91bmQgYWZ0ZXIgZ3JvdXAgaXMgbGF5b3V0XG4gICAgLy8gRklYTUVcbiAgICBncm91cC5hZGQobGlzdENvbXBvbmVudEhlbHBlci5tYWtlQmFja2dyb3VuZChncm91cC5nZXRCb3VuZGluZ1JlY3QoKSwgdG9vbGJveE1vZGVsKSk7XG4gICAgLy8gQWRqdXN0IGljb24gdGl0bGUgcG9zaXRpb25zIHRvIGF2b2lkIHRoZW0gb3V0IG9mIHNjcmVlblxuICAgIGlzVmVydGljYWwgfHwgZ3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChpY29uKSB7XG4gICAgICB2YXIgdGl0bGVUZXh0ID0gaWNvbi5fX3RpdGxlO1xuICAgICAgLy8gY29uc3QgaG92ZXJTdHlsZSA9IGljb24uaG92ZXJTdHlsZTtcbiAgICAgIC8vIFRPRE8gc2ltcGxpZnkgY29kZT9cbiAgICAgIHZhciBlbXBoYXNpc1N0YXRlID0gaWNvbi5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKTtcbiAgICAgIHZhciBlbXBoYXNpc1RleHRDb25maWcgPSBlbXBoYXNpc1N0YXRlLnRleHRDb25maWcgfHwgKGVtcGhhc2lzU3RhdGUudGV4dENvbmZpZyA9IHt9KTtcbiAgICAgIHZhciB0ZXh0Q29udGVudCA9IGljb24uZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgIHZhciBlbXBoYXNpc1RleHRTdGF0ZSA9IHRleHRDb250ZW50ICYmIHRleHRDb250ZW50LmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpO1xuICAgICAgLy8gTWF5IGJlIGJhY2tncm91bmQgZWxlbWVudFxuICAgICAgaWYgKGVtcGhhc2lzVGV4dFN0YXRlICYmICF6clV0aWwuaXNGdW5jdGlvbihlbXBoYXNpc1RleHRTdGF0ZSkgJiYgdGl0bGVUZXh0KSB7XG4gICAgICAgIHZhciBlbXBoYXNpc1RleHRTdHlsZSA9IGVtcGhhc2lzVGV4dFN0YXRlLnN0eWxlIHx8IChlbXBoYXNpc1RleHRTdGF0ZS5zdHlsZSA9IHt9KTtcbiAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGl0bGVUZXh0LCBaUlRleHQubWFrZUZvbnQoZW1waGFzaXNUZXh0U3R5bGUpKTtcbiAgICAgICAgdmFyIG9mZnNldFggPSBpY29uLnggKyBncm91cC54O1xuICAgICAgICB2YXIgb2Zmc2V0WSA9IGljb24ueSArIGdyb3VwLnkgKyBpdGVtU2l6ZTtcbiAgICAgICAgdmFyIG5lZWRQdXRPblRvcCA9IGZhbHNlO1xuICAgICAgICBpZiAob2Zmc2V0WSArIHJlY3QuaGVpZ2h0ID4gYXBpLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgZW1waGFzaXNUZXh0Q29uZmlnLnBvc2l0aW9uID0gJ3RvcCc7XG4gICAgICAgICAgbmVlZFB1dE9uVG9wID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9wT2Zmc2V0ID0gbmVlZFB1dE9uVG9wID8gLTUgLSByZWN0LmhlaWdodCA6IGl0ZW1TaXplICsgMTA7XG4gICAgICAgIGlmIChvZmZzZXRYICsgcmVjdC53aWR0aCAvIDIgPiBhcGkuZ2V0V2lkdGgoKSkge1xuICAgICAgICAgIGVtcGhhc2lzVGV4dENvbmZpZy5wb3NpdGlvbiA9IFsnMTAwJScsIHRvcE9mZnNldF07XG4gICAgICAgICAgZW1waGFzaXNUZXh0U3R5bGUuYWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldFggLSByZWN0LndpZHRoIC8gMiA8IDApIHtcbiAgICAgICAgICBlbXBoYXNpc1RleHRDb25maWcucG9zaXRpb24gPSBbMCwgdG9wT2Zmc2V0XTtcbiAgICAgICAgICBlbXBoYXNpc1RleHRTdHlsZS5hbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBUb29sYm94Vmlldy5wcm90b3R5cGUudXBkYXRlVmlldyA9IGZ1bmN0aW9uICh0b29sYm94TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHpyVXRpbC5lYWNoKHRoaXMuX2ZlYXR1cmVzLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgZmVhdHVyZSBpbnN0YW5jZW9mIFRvb2xib3hGZWF0dXJlICYmIGZlYXR1cmUudXBkYXRlVmlldyAmJiBmZWF0dXJlLnVwZGF0ZVZpZXcoZmVhdHVyZS5tb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICB9KTtcbiAgfTtcbiAgLy8gdXBkYXRlTGF5b3V0KHRvb2xib3hNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gIC8vICAgICB6clV0aWwuZWFjaCh0aGlzLl9mZWF0dXJlcywgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgLy8gICAgICAgICBmZWF0dXJlLnVwZGF0ZUxheW91dCAmJiBmZWF0dXJlLnVwZGF0ZUxheW91dChmZWF0dXJlLm1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAvLyAgICAgfSk7XG4gIC8vIH0sXG4gIFRvb2xib3hWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgenJVdGlsLmVhY2godGhpcy5fZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICBmZWF0dXJlIGluc3RhbmNlb2YgVG9vbGJveEZlYXR1cmUgJiYgZmVhdHVyZS5yZW1vdmUgJiYgZmVhdHVyZS5yZW1vdmUoZWNNb2RlbCwgYXBpKTtcbiAgICB9KTtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICB9O1xuICBUb29sYm94Vmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB6clV0aWwuZWFjaCh0aGlzLl9mZWF0dXJlcywgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgIGZlYXR1cmUgaW5zdGFuY2VvZiBUb29sYm94RmVhdHVyZSAmJiBmZWF0dXJlLmRpc3Bvc2UgJiYgZmVhdHVyZS5kaXNwb3NlKGVjTW9kZWwsIGFwaSk7XG4gICAgfSk7XG4gIH07XG4gIFRvb2xib3hWaWV3LnR5cGUgPSAndG9vbGJveCc7XG4gIHJldHVybiBUb29sYm94Vmlldztcbn0oQ29tcG9uZW50Vmlldyk7XG5mdW5jdGlvbiBpc1VzZXJGZWF0dXJlTmFtZShmZWF0dXJlTmFtZSkge1xuICByZXR1cm4gZmVhdHVyZU5hbWUuaW5kZXhPZignbXknKSA9PT0gMDtcbn1cbmV4cG9ydCBkZWZhdWx0IFRvb2xib3hWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG4vKiBnbG9iYWwgd2luZG93LCBVaW50OEFycmF5LCBkb2N1bWVudCAqL1xuaW1wb3J0IGVudiBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL2Vudi5qcyc7XG5pbXBvcnQgeyBUb29sYm94RmVhdHVyZSB9IGZyb20gJy4uL2ZlYXR1cmVNYW5hZ2VyLmpzJztcbnZhciBTYXZlQXNJbWFnZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTYXZlQXNJbWFnZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gU2F2ZUFzSW1hZ2UoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIFNhdmVBc0ltYWdlLnByb3RvdHlwZS5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgdmFyIHRpdGxlID0gbW9kZWwuZ2V0KCduYW1lJykgfHwgZWNNb2RlbC5nZXQoJ3RpdGxlLjAudGV4dCcpIHx8ICdlY2hhcnRzJztcbiAgICB2YXIgaXNTdmcgPSBhcGkuZ2V0WnIoKS5wYWludGVyLmdldFR5cGUoKSA9PT0gJ3N2Zyc7XG4gICAgdmFyIHR5cGUgPSBpc1N2ZyA/ICdzdmcnIDogbW9kZWwuZ2V0KCd0eXBlJywgdHJ1ZSkgfHwgJ3BuZyc7XG4gICAgdmFyIHVybCA9IGFwaS5nZXRDb25uZWN0ZWREYXRhVVJMKHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJywgdHJ1ZSkgfHwgZWNNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpIHx8ICcjZmZmJyxcbiAgICAgIGNvbm5lY3RlZEJhY2tncm91bmRDb2xvcjogbW9kZWwuZ2V0KCdjb25uZWN0ZWRCYWNrZ3JvdW5kQ29sb3InKSxcbiAgICAgIGV4Y2x1ZGVDb21wb25lbnRzOiBtb2RlbC5nZXQoJ2V4Y2x1ZGVDb21wb25lbnRzJyksXG4gICAgICBwaXhlbFJhdGlvOiBtb2RlbC5nZXQoJ3BpeGVsUmF0aW8nKVxuICAgIH0pO1xuICAgIHZhciBicm93c2VyID0gZW52LmJyb3dzZXI7XG4gICAgLy8gQ2hyb21lLCBGaXJlZm94LCBOZXcgRWRnZVxuICAgIGlmICh0eXBlb2YgTW91c2VFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiAoYnJvd3Nlci5uZXdFZGdlIHx8ICFicm93c2VyLmllICYmICFicm93c2VyLmVkZ2UpKSB7XG4gICAgICB2YXIgJGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAkYS5kb3dubG9hZCA9IHRpdGxlICsgJy4nICsgdHlwZTtcbiAgICAgICRhLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgJGEuaHJlZiA9IHVybDtcbiAgICAgIHZhciBldnQgPSBuZXcgTW91c2VFdmVudCgnY2xpY2snLCB7XG4gICAgICAgIC8vIHNvbWUgbWljcm8gZnJvbnQtZW5kIGZyYW1ld29ya++8jCB3aW5kb3cgbWF5YmUgaXMgYSBQcm94eVxuICAgICAgICB2aWV3OiBkb2N1bWVudC5kZWZhdWx0VmlldyxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgJGEuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH1cbiAgICAvLyBJRSBvciBvbGQgRWRnZVxuICAgIGVsc2Uge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYiB8fCBpc1N2Zykge1xuICAgICAgICB2YXIgcGFydHMgPSB1cmwuc3BsaXQoJywnKTtcbiAgICAgICAgLy8gZGF0YTpbPG1pbWUgdHlwZT5dWztjaGFyc2V0PTxjaGFyc2V0Pl1bO2Jhc2U2NF0sPGVuY29kZWQgZGF0YT5cbiAgICAgICAgdmFyIGJhc2U2NEVuY29kZWQgPSBwYXJ0c1swXS5pbmRleE9mKCdiYXNlNjQnKSA+IC0xO1xuICAgICAgICB2YXIgYnN0ciA9IGlzU3ZnXG4gICAgICAgIC8vIHNob3VsZCBkZWNvZGUgdGhlIHN2ZyBkYXRhIHVyaSBmaXJzdFxuICAgICAgICA/IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0c1sxXSkgOiBwYXJ0c1sxXTtcbiAgICAgICAgLy8gb25seSBgYXRvYmAgd2hlbiB0aGUgZGF0YSB1cmkgaXMgZW5jb2RlZCB3aXRoIGJhc2U2NFxuICAgICAgICAvLyBvdGhlcndpc2UsIGxpa2UgYHN2Z2AgZGF0YSB1cmkgZXhwb3J0ZWQgYnkgenJlbmRlcixcbiAgICAgICAgLy8gdGhlcmUgd2lsbCBiZSBhbiBlcnJvciwgZm9yIGl0J3Mgbm90IGVuY29kZWQgd2l0aCBiYXNlNjQuXG4gICAgICAgIC8vIChqdXN0IGEgdXJsLWVuY29kZWQgc3RyaW5nIHRocm91Z2ggYGVuY29kZVVSSUNvbXBvbmVudGApXG4gICAgICAgIGJhc2U2NEVuY29kZWQgJiYgKGJzdHIgPSB3aW5kb3cuYXRvYihic3RyKSk7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IHRpdGxlICsgJy4nICsgdHlwZTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKSB7XG4gICAgICAgICAgdmFyIG4gPSBic3RyLmxlbmd0aDtcbiAgICAgICAgICB2YXIgdThhcnIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICB1OGFycltuXSA9IGJzdHIuY2hhckNvZGVBdChuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbdThhcnJdKTsgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihibG9iLCBmaWxlbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmcmFtZSk7XG4gICAgICAgICAgdmFyIGN3ID0gZnJhbWUuY29udGVudFdpbmRvdztcbiAgICAgICAgICB2YXIgZG9jID0gY3cuZG9jdW1lbnQ7XG4gICAgICAgICAgZG9jLm9wZW4oJ2ltYWdlL3N2Zyt4bWwnLCAncmVwbGFjZScpO1xuICAgICAgICAgIGRvYy53cml0ZShic3RyKTtcbiAgICAgICAgICBkb2MuY2xvc2UoKTtcbiAgICAgICAgICBjdy5mb2N1cygpO1xuICAgICAgICAgIGRvYy5leGVjQ29tbWFuZCgnU2F2ZUFzJywgdHJ1ZSwgZmlsZW5hbWUpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGFuZyA9IG1vZGVsLmdldCgnbGFuZycpO1xuICAgICAgICB2YXIgaHRtbCA9ICcnICsgJzxib2R5IHN0eWxlPVwibWFyZ2luOjA7XCI+JyArICc8aW1nIHNyYz1cIicgKyB1cmwgKyAnXCIgc3R5bGU9XCJtYXgtd2lkdGg6MTAwJTtcIiB0aXRsZT1cIicgKyAobGFuZyAmJiBsYW5nWzBdIHx8ICcnKSArICdcIiAvPicgKyAnPC9ib2R5Pic7XG4gICAgICAgIHZhciB0YWIgPSB3aW5kb3cub3BlbigpO1xuICAgICAgICB0YWIuZG9jdW1lbnQud3JpdGUoaHRtbCk7XG4gICAgICAgIHRhYi5kb2N1bWVudC50aXRsZSA9IHRpdGxlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgU2F2ZUFzSW1hZ2UuZ2V0RGVmYXVsdE9wdGlvbiA9IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgaWNvbjogJ000LjcsMjIuOUwyOS4zLDQ1LjVMNTQuNywyMy40TTQuNiw0My42TDQuNiw1OEw1My44LDU4TDUzLjgsNDMuNk0yOS4yLDQ1LjFMMjkuMiwwJyxcbiAgICAgIHRpdGxlOiBlY01vZGVsLmdldExvY2FsZU1vZGVsKCkuZ2V0KFsndG9vbGJveCcsICdzYXZlQXNJbWFnZScsICd0aXRsZSddKSxcbiAgICAgIHR5cGU6ICdwbmcnLFxuICAgICAgLy8gRGVmYXVsdCB1c2Ugb3B0aW9uLmJhY2tncm91bmRDb2xvclxuICAgICAgLy8gYmFja2dyb3VuZENvbG9yOiAnI2ZmZicsXG4gICAgICBjb25uZWN0ZWRCYWNrZ3JvdW5kQ29sb3I6ICcjZmZmJyxcbiAgICAgIG5hbWU6ICcnLFxuICAgICAgZXhjbHVkZUNvbXBvbmVudHM6IFsndG9vbGJveCddLFxuICAgICAgLy8gdXNlIGN1cnJlbnQgcGl4ZWwgcmF0aW8gb2YgZGV2aWNlIGJ5IGRlZmF1bHRcbiAgICAgIC8vIHBpeGVsUmF0aW86IDEsXG4gICAgICBsYW5nOiBlY01vZGVsLmdldExvY2FsZU1vZGVsKCkuZ2V0KFsndG9vbGJveCcsICdzYXZlQXNJbWFnZScsICdsYW5nJ10pXG4gICAgfTtcbiAgICByZXR1cm4gZGVmYXVsdE9wdGlvbjtcbiAgfTtcbiAgcmV0dXJuIFNhdmVBc0ltYWdlO1xufShUb29sYm94RmVhdHVyZSk7XG5leHBvcnQgZGVmYXVsdCBTYXZlQXNJbWFnZTsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgZWNoYXJ0cyBmcm9tICcuLi8uLi8uLi9jb3JlL2VjaGFydHMuanMnO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBUb29sYm94RmVhdHVyZSB9IGZyb20gJy4uL2ZlYXR1cmVNYW5hZ2VyLmpzJztcbmltcG9ydCB7IFNJTkdMRV9SRUZFUlJJTkcgfSBmcm9tICcuLi8uLi8uLi91dGlsL21vZGVsLmpzJztcbnZhciBJTk5FUl9TVEFDS19LRVlXT1JEID0gJ19fZWNfbWFnaWNUeXBlX3N0YWNrX18nO1xudmFyIElDT05fVFlQRVMgPSBbJ2xpbmUnLCAnYmFyJywgJ3N0YWNrJ107XG4vLyBzdGFjayBhbmQgdGlsZWQgYXBwZWFycyBpbiBwYWlyIGZvciB0aGUgdGl0bGVcbnZhciBUSVRMRV9UWVBFUyA9IFsnbGluZScsICdiYXInLCAnc3RhY2snLCAndGlsZWQnXTtcbnZhciByYWRpb1R5cGVzID0gW1snbGluZScsICdiYXInXSwgWydzdGFjayddXTtcbnZhciBNYWdpY1R5cGUgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTWFnaWNUeXBlLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBNYWdpY1R5cGUoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIE1hZ2ljVHlwZS5wcm90b3R5cGUuZ2V0SWNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICB2YXIgYXZhaWxhYmxlSWNvbnMgPSBtb2RlbC5nZXQoJ2ljb24nKTtcbiAgICB2YXIgaWNvbnMgPSB7fTtcbiAgICB6clV0aWwuZWFjaChtb2RlbC5nZXQoJ3R5cGUnKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmIChhdmFpbGFibGVJY29uc1t0eXBlXSkge1xuICAgICAgICBpY29uc1t0eXBlXSA9IGF2YWlsYWJsZUljb25zW3R5cGVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpY29ucztcbiAgfTtcbiAgTWFnaWNUeXBlLmdldERlZmF1bHRPcHRpb24gPSBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHZhciBkZWZhdWx0T3B0aW9uID0ge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIHR5cGU6IFtdLFxuICAgICAgLy8gSWNvbiBncm91cFxuICAgICAgaWNvbjoge1xuICAgICAgICBsaW5lOiAnTTQuMSwyOC45aDcuMWw5LjMtMjJsNy40LDM4bDkuNy0xOS43bDMsMTIuOGgxNC45TTQuMSw1OGg1MS40JyxcbiAgICAgICAgYmFyOiAnTTYuNywyMi45aDEwVjQ4aC0xMFYyMi45ek0yNC45LDEzaDEwdjM1aC0xMFYxM3pNNDMuMiwyaDEwdjQ2aC0xMFYyek0zLjEsNThoNTMuNycsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBzdGFjazogJ004LjIsMzguNGwtOC40LDQuMWwzMC42LDE1LjNMNjAsNDIuNWwtOC4xLTQuMWwtMjEuNSwxMUw4LjIsMzguNHogTTUxLjksMzBsLTguMSw0LjJsLTEzLjQsNi45bC0xMy45LTYuOUw4LjIsMzBsLTguNCw0LjJsOC40LDQuMmwyMi4yLDExbDIxLjUtMTFsOC4xLTQuMkw1MS45LDMweiBNNTEuOSwyMS43bC04LjEsNC4yTDM1LjcsMzBsLTUuMywyLjhMMjQuOSwzMGwtOC40LTQuMWwtOC4zLTQuMmwtOC40LDQuMkw4LjIsMzBsOC4zLDQuMmwxMy45LDYuOWwxMy40LTYuOWw4LjEtNC4ybDguMS00LjFMNTEuOSwyMS43ek0zMC40LDIuMkwtMC4yLDE3LjVsOC40LDQuMWw4LjMsNC4ybDguNCw0LjJsNS41LDIuN2w1LjMtMi43bDguMS00LjJsOC4xLTQuMmw4LjEtNC4xTDMwLjQsMi4yeicgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICB9LFxuICAgICAgLy8gYGxpbmVgLCBgYmFyYCwgYHN0YWNrYCwgYHRpbGVkYFxuICAgICAgdGl0bGU6IGVjTW9kZWwuZ2V0TG9jYWxlTW9kZWwoKS5nZXQoWyd0b29sYm94JywgJ21hZ2ljVHlwZScsICd0aXRsZSddKSxcbiAgICAgIG9wdGlvbjoge30sXG4gICAgICBzZXJpZXNJbmRleDoge31cbiAgICB9O1xuICAgIHJldHVybiBkZWZhdWx0T3B0aW9uO1xuICB9O1xuICBNYWdpY1R5cGUucHJvdG90eXBlLm9uY2xpY2sgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpLCB0eXBlKSB7XG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICB2YXIgc2VyaWVzSW5kZXggPSBtb2RlbC5nZXQoWydzZXJpZXNJbmRleCcsIHR5cGVdKTtcbiAgICAvLyBOb3Qgc3VwcG9ydGVkIG1hZ2ljVHlwZVxuICAgIGlmICghc2VyaWVzT3B0R2VucmVhdG9yW3R5cGVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXdPcHRpb24gPSB7XG4gICAgICBzZXJpZXM6IFtdXG4gICAgfTtcbiAgICB2YXIgZ2VuZXJhdGVOZXdTZXJpZXNUeXBlcyA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIHNlcmllc1R5cGUgPSBzZXJpZXNNb2RlbC5zdWJUeXBlO1xuICAgICAgdmFyIHNlcmllc0lkID0gc2VyaWVzTW9kZWwuaWQ7XG4gICAgICB2YXIgbmV3U2VyaWVzT3B0ID0gc2VyaWVzT3B0R2VucmVhdG9yW3R5cGVdKHNlcmllc1R5cGUsIHNlcmllc0lkLCBzZXJpZXNNb2RlbCwgbW9kZWwpO1xuICAgICAgaWYgKG5ld1Nlcmllc09wdCkge1xuICAgICAgICAvLyBQRU5ESU5HIElmIG1lcmdlIG9yaWdpbmFsIG9wdGlvbj9cbiAgICAgICAgenJVdGlsLmRlZmF1bHRzKG5ld1Nlcmllc09wdCwgc2VyaWVzTW9kZWwub3B0aW9uKTtcbiAgICAgICAgbmV3T3B0aW9uLnNlcmllcy5wdXNoKG5ld1Nlcmllc09wdCk7XG4gICAgICB9XG4gICAgICAvLyBNb2RpZnkgYm91bmRhcnlHYXBcbiAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJyAmJiAodHlwZSA9PT0gJ2xpbmUnIHx8IHR5cGUgPT09ICdiYXInKSkge1xuICAgICAgICB2YXIgY2F0ZWdvcnlBeGlzID0gY29vcmRTeXMuZ2V0QXhlc0J5U2NhbGUoJ29yZGluYWwnKVswXTtcbiAgICAgICAgaWYgKGNhdGVnb3J5QXhpcykge1xuICAgICAgICAgIHZhciBheGlzRGltID0gY2F0ZWdvcnlBeGlzLmRpbTtcbiAgICAgICAgICB2YXIgYXhpc1R5cGUgPSBheGlzRGltICsgJ0F4aXMnO1xuICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKGF4aXNUeXBlLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG4gICAgICAgICAgdmFyIGF4aXNJbmRleCA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcbiAgICAgICAgICBuZXdPcHRpb25bYXhpc1R5cGVdID0gbmV3T3B0aW9uW2F4aXNUeXBlXSB8fCBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBheGlzSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgbmV3T3B0aW9uW2F4aXNUeXBlXVtheGlzSW5kZXhdID0gbmV3T3B0aW9uW2F4aXNUeXBlXVtheGlzSW5kZXhdIHx8IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdPcHRpb25bYXhpc1R5cGVdW2F4aXNJbmRleF0uYm91bmRhcnlHYXAgPSB0eXBlID09PSAnYmFyJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgenJVdGlsLmVhY2gocmFkaW9UeXBlcywgZnVuY3Rpb24gKHJhZGlvKSB7XG4gICAgICBpZiAoenJVdGlsLmluZGV4T2YocmFkaW8sIHR5cGUpID49IDApIHtcbiAgICAgICAgenJVdGlsLmVhY2gocmFkaW8sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgbW9kZWwuc2V0SWNvblN0YXR1cyhpdGVtLCAnbm9ybWFsJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1vZGVsLnNldEljb25TdGF0dXModHlwZSwgJ2VtcGhhc2lzJyk7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiAnc2VyaWVzJyxcbiAgICAgIHF1ZXJ5OiBzZXJpZXNJbmRleCA9PSBudWxsID8gbnVsbCA6IHtcbiAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4XG4gICAgICB9XG4gICAgfSwgZ2VuZXJhdGVOZXdTZXJpZXNUeXBlcyk7XG4gICAgdmFyIG5ld1RpdGxlO1xuICAgIHZhciBjdXJyZW50VHlwZSA9IHR5cGU7XG4gICAgLy8gQ2hhbmdlIHRpdGxlIG9mIHN0YWNrXG4gICAgaWYgKHR5cGUgPT09ICdzdGFjaycpIHtcbiAgICAgIC8vIHVzZSB0aXRsZXMgaW4gbW9kZWwgaW5zdGVhZCBvZiBlY01vZGVsXG4gICAgICAvLyBhcyBzdGFjayBhbmQgdGlsZWQgYXBwZWFycyBpbiBwYWlyLCBqdXN0IGZsaXAgdGhlbVxuICAgICAgLy8gbm8gbmVlZCBvZiBjaGVja2luZyBzdGFjayBzdGF0ZVxuICAgICAgbmV3VGl0bGUgPSB6clV0aWwubWVyZ2Uoe1xuICAgICAgICBzdGFjazogbW9kZWwub3B0aW9uLnRpdGxlLnRpbGVkLFxuICAgICAgICB0aWxlZDogbW9kZWwub3B0aW9uLnRpdGxlLnN0YWNrXG4gICAgICB9LCBtb2RlbC5vcHRpb24udGl0bGUpO1xuICAgICAgaWYgKG1vZGVsLmdldChbJ2ljb25TdGF0dXMnLCB0eXBlXSkgIT09ICdlbXBoYXNpcycpIHtcbiAgICAgICAgY3VycmVudFR5cGUgPSAndGlsZWQnO1xuICAgICAgfVxuICAgIH1cbiAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2NoYW5nZU1hZ2ljVHlwZScsXG4gICAgICBjdXJyZW50VHlwZTogY3VycmVudFR5cGUsXG4gICAgICBuZXdPcHRpb246IG5ld09wdGlvbixcbiAgICAgIG5ld1RpdGxlOiBuZXdUaXRsZSxcbiAgICAgIGZlYXR1cmVOYW1lOiAnbWFnaWNUeXBlJ1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gTWFnaWNUeXBlO1xufShUb29sYm94RmVhdHVyZSk7XG52YXIgc2VyaWVzT3B0R2VucmVhdG9yID0ge1xuICAnbGluZSc6IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBzZXJpZXNJZCwgc2VyaWVzTW9kZWwsIG1vZGVsKSB7XG4gICAgaWYgKHNlcmllc1R5cGUgPT09ICdiYXInKSB7XG4gICAgICByZXR1cm4genJVdGlsLm1lcmdlKHtcbiAgICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgIC8vIFByZXNlcnZlIGRhdGEgcmVsYXRlZCBvcHRpb25cbiAgICAgICAgZGF0YTogc2VyaWVzTW9kZWwuZ2V0KCdkYXRhJyksXG4gICAgICAgIHN0YWNrOiBzZXJpZXNNb2RlbC5nZXQoJ3N0YWNrJyksXG4gICAgICAgIG1hcmtQb2ludDogc2VyaWVzTW9kZWwuZ2V0KCdtYXJrUG9pbnQnKSxcbiAgICAgICAgbWFya0xpbmU6IHNlcmllc01vZGVsLmdldCgnbWFya0xpbmUnKVxuICAgICAgfSwgbW9kZWwuZ2V0KFsnb3B0aW9uJywgJ2xpbmUnXSkgfHwge30sIHRydWUpO1xuICAgIH1cbiAgfSxcbiAgJ2Jhcic6IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBzZXJpZXNJZCwgc2VyaWVzTW9kZWwsIG1vZGVsKSB7XG4gICAgaWYgKHNlcmllc1R5cGUgPT09ICdsaW5lJykge1xuICAgICAgcmV0dXJuIHpyVXRpbC5tZXJnZSh7XG4gICAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgICAgdHlwZTogJ2JhcicsXG4gICAgICAgIC8vIFByZXNlcnZlIGRhdGEgcmVsYXRlZCBvcHRpb25cbiAgICAgICAgZGF0YTogc2VyaWVzTW9kZWwuZ2V0KCdkYXRhJyksXG4gICAgICAgIHN0YWNrOiBzZXJpZXNNb2RlbC5nZXQoJ3N0YWNrJyksXG4gICAgICAgIG1hcmtQb2ludDogc2VyaWVzTW9kZWwuZ2V0KCdtYXJrUG9pbnQnKSxcbiAgICAgICAgbWFya0xpbmU6IHNlcmllc01vZGVsLmdldCgnbWFya0xpbmUnKVxuICAgICAgfSwgbW9kZWwuZ2V0KFsnb3B0aW9uJywgJ2JhciddKSB8fCB7fSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuICAnc3RhY2snOiBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgc2VyaWVzSWQsIHNlcmllc01vZGVsLCBtb2RlbCkge1xuICAgIHZhciBpc1N0YWNrID0gc2VyaWVzTW9kZWwuZ2V0KCdzdGFjaycpID09PSBJTk5FUl9TVEFDS19LRVlXT1JEO1xuICAgIGlmIChzZXJpZXNUeXBlID09PSAnbGluZScgfHwgc2VyaWVzVHlwZSA9PT0gJ2JhcicpIHtcbiAgICAgIG1vZGVsLnNldEljb25TdGF0dXMoJ3N0YWNrJywgaXNTdGFjayA/ICdub3JtYWwnIDogJ2VtcGhhc2lzJyk7XG4gICAgICByZXR1cm4genJVdGlsLm1lcmdlKHtcbiAgICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgICBzdGFjazogaXNTdGFjayA/ICcnIDogSU5ORVJfU1RBQ0tfS0VZV09SRFxuICAgICAgfSwgbW9kZWwuZ2V0KFsnb3B0aW9uJywgJ3N0YWNrJ10pIHx8IHt9LCB0cnVlKTtcbiAgICB9XG4gIH1cbn07XG4vLyBUT0RPOiBTRUxGIFJFR0lTVEVSRUQuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ2NoYW5nZU1hZ2ljVHlwZScsXG4gIGV2ZW50OiAnbWFnaWNUeXBlQ2hhbmdlZCcsXG4gIHVwZGF0ZTogJ3ByZXBhcmVBbmRVcGRhdGUnXG59LCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICBlY01vZGVsLm1lcmdlT3B0aW9uKHBheWxvYWQubmV3T3B0aW9uKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgTWFnaWNUeXBlOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG4vKiBnbG9iYWwgZG9jdW1lbnQgKi9cbmltcG9ydCAqIGFzIGVjaGFydHMgZnJvbSAnLi4vLi4vLi4vY29yZS9lY2hhcnRzLmpzJztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgVG9vbGJveEZlYXR1cmUgfSBmcm9tICcuLi9mZWF0dXJlTWFuYWdlci5qcyc7XG5pbXBvcnQgeyBhZGRFdmVudExpc3RlbmVyIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS9ldmVudC5qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vdXRpbC9sb2cuanMnO1xuLyogZ2xvYmFsIGRvY3VtZW50ICovXG52YXIgQkxPQ0tfU1BMSVRFUiA9IG5ldyBBcnJheSg2MCkuam9pbignLScpO1xudmFyIElURU1fU1BMSVRFUiA9ICdcXHQnO1xuLyoqXHJcbiAqIEdyb3VwIHNlcmllcyBpbnRvIHR3byB0eXBlc1xyXG4gKiAgMS4gb24gY2F0ZWdvcnkgYXhpcywgbGlrZSBsaW5lLCBiYXJcclxuICogIDIuIG90aGVycywgbGlrZSBzY2F0dGVyLCBwaWVcclxuICovXG5mdW5jdGlvbiBncm91cFNlcmllcyhlY01vZGVsKSB7XG4gIHZhciBzZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzID0ge307XG4gIHZhciBvdGhlclNlcmllcyA9IFtdO1xuICB2YXIgbWV0YSA9IFtdO1xuICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICBpZiAoY29vcmRTeXMgJiYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgfHwgY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJykpIHtcbiAgICAgIC8vIFRPRE86IFRZUEUgQ29uc2lkZXIgcG9sYXI/IEluY2x1ZGUgcG9sYXIgbWF5IGluY3JlYXNlIHVuZWNlc3NhcnkgYnVuZGxlIHNpemUuXG4gICAgICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgaWYgKGJhc2VBeGlzLnR5cGUgPT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgdmFyIGtleSA9IGJhc2VBeGlzLmRpbSArICdfJyArIGJhc2VBeGlzLmluZGV4O1xuICAgICAgICBpZiAoIXNlcmllc0dyb3VwQnlDYXRlZ29yeUF4aXNba2V5XSkge1xuICAgICAgICAgIHNlcmllc0dyb3VwQnlDYXRlZ29yeUF4aXNba2V5XSA9IHtcbiAgICAgICAgICAgIGNhdGVnb3J5QXhpczogYmFzZUF4aXMsXG4gICAgICAgICAgICB2YWx1ZUF4aXM6IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyksXG4gICAgICAgICAgICBzZXJpZXM6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgICBtZXRhLnB1c2goe1xuICAgICAgICAgICAgYXhpc0RpbTogYmFzZUF4aXMuZGltLFxuICAgICAgICAgICAgYXhpc0luZGV4OiBiYXNlQXhpcy5pbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlcmllc0dyb3VwQnlDYXRlZ29yeUF4aXNba2V5XS5zZXJpZXMucHVzaChzZXJpZXNNb2RlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdGhlclNlcmllcy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXJTZXJpZXMucHVzaChzZXJpZXNNb2RlbCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzOiBzZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzLFxuICAgIG90aGVyOiBvdGhlclNlcmllcyxcbiAgICBtZXRhOiBtZXRhXG4gIH07XG59XG4vKipcclxuICogQXNzZW1ibGUgY29udGVudCBvZiBzZXJpZXMgb24gY2F0ZW9nb3J5IGF4aXNcclxuICogQGlubmVyXHJcbiAqL1xuZnVuY3Rpb24gYXNzZW1ibGVTZXJpZXNXaXRoQ2F0ZWdvcnlBeGlzKGdyb3Vwcykge1xuICB2YXIgdGFibGVzID0gW107XG4gIHpyVXRpbC5lYWNoKGdyb3VwcywgZnVuY3Rpb24gKGdyb3VwLCBrZXkpIHtcbiAgICB2YXIgY2F0ZWdvcnlBeGlzID0gZ3JvdXAuY2F0ZWdvcnlBeGlzO1xuICAgIHZhciB2YWx1ZUF4aXMgPSBncm91cC52YWx1ZUF4aXM7XG4gICAgdmFyIHZhbHVlQXhpc0RpbSA9IHZhbHVlQXhpcy5kaW07XG4gICAgdmFyIGhlYWRlcnMgPSBbJyAnXS5jb25jYXQoenJVdGlsLm1hcChncm91cC5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgIHJldHVybiBzZXJpZXMubmFtZTtcbiAgICB9KSk7XG4gICAgLy8gQHRzLWlnbm9yZSBUT0RPIFBvbGFyXG4gICAgdmFyIGNvbHVtbnMgPSBbY2F0ZWdvcnlBeGlzLm1vZGVsLmdldENhdGVnb3JpZXMoKV07XG4gICAgenJVdGlsLmVhY2goZ3JvdXAuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICB2YXIgcmF3RGF0YSA9IHNlcmllcy5nZXRSYXdEYXRhKCk7XG4gICAgICBjb2x1bW5zLnB1c2goc2VyaWVzLmdldFJhd0RhdGEoKS5tYXBBcnJheShyYXdEYXRhLm1hcERpbWVuc2lvbih2YWx1ZUF4aXNEaW0pLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgLy8gQXNzZW1ibGUgdGFibGUgY29udGVudFxuICAgIHZhciBsaW5lcyA9IFtoZWFkZXJzLmpvaW4oSVRFTV9TUExJVEVSKV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5zWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1ucy5sZW5ndGg7IGorKykge1xuICAgICAgICBpdGVtcy5wdXNoKGNvbHVtbnNbal1baV0pO1xuICAgICAgfVxuICAgICAgbGluZXMucHVzaChpdGVtcy5qb2luKElURU1fU1BMSVRFUikpO1xuICAgIH1cbiAgICB0YWJsZXMucHVzaChsaW5lcy5qb2luKCdcXG4nKSk7XG4gIH0pO1xuICByZXR1cm4gdGFibGVzLmpvaW4oJ1xcblxcbicgKyBCTE9DS19TUExJVEVSICsgJ1xcblxcbicpO1xufVxuLyoqXHJcbiAqIEFzc2VtYmxlIGNvbnRlbnQgb2Ygb3RoZXIgc2VyaWVzXHJcbiAqL1xuZnVuY3Rpb24gYXNzZW1ibGVPdGhlclNlcmllcyhzZXJpZXMpIHtcbiAgcmV0dXJuIHpyVXRpbC5tYXAoc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXMuZ2V0UmF3RGF0YSgpO1xuICAgIHZhciBsaW5lcyA9IFtzZXJpZXMubmFtZV07XG4gICAgdmFyIHZhbHMgPSBbXTtcbiAgICBkYXRhLmVhY2goZGF0YS5kaW1lbnNpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJnTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBkYXRhSW5kZXggPSBhcmd1bWVudHNbYXJnTGVuIC0gMV07XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuZ2V0TmFtZShkYXRhSW5kZXgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdMZW4gLSAxOyBpKyspIHtcbiAgICAgICAgdmFsc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIH1cbiAgICAgIGxpbmVzLnB1c2goKG5hbWUgPyBuYW1lICsgSVRFTV9TUExJVEVSIDogJycpICsgdmFscy5qb2luKElURU1fU1BMSVRFUikpO1xuICAgIH0pO1xuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbiAgfSkuam9pbignXFxuXFxuJyArIEJMT0NLX1NQTElURVIgKyAnXFxuXFxuJyk7XG59XG5mdW5jdGlvbiBnZXRDb250ZW50RnJvbU1vZGVsKGVjTW9kZWwpIHtcbiAgdmFyIHJlc3VsdCA9IGdyb3VwU2VyaWVzKGVjTW9kZWwpO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB6clV0aWwuZmlsdGVyKFthc3NlbWJsZVNlcmllc1dpdGhDYXRlZ29yeUF4aXMocmVzdWx0LnNlcmllc0dyb3VwQnlDYXRlZ29yeUF4aXMpLCBhc3NlbWJsZU90aGVyU2VyaWVzKHJlc3VsdC5vdGhlcildLCBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gISFzdHIucmVwbGFjZSgvW1xcblxcdFxcc10vZywgJycpO1xuICAgIH0pLmpvaW4oJ1xcblxcbicgKyBCTE9DS19TUExJVEVSICsgJ1xcblxcbicpLFxuICAgIG1ldGE6IHJlc3VsdC5tZXRhXG4gIH07XG59XG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xufVxuLyoqXHJcbiAqIElmIGEgYmxvY2sgaXMgdHN2IGZvcm1hdFxyXG4gKi9cbmZ1bmN0aW9uIGlzVFNWRm9ybWF0KGJsb2NrKSB7XG4gIC8vIFNpbXBsZSBtZXRob2QgdG8gZmluZCBvdXQgaWYgYSBibG9jayBpcyB0c3YgZm9ybWF0XG4gIHZhciBmaXJzdExpbmUgPSBibG9jay5zbGljZSgwLCBibG9jay5pbmRleE9mKCdcXG4nKSk7XG4gIGlmIChmaXJzdExpbmUuaW5kZXhPZihJVEVNX1NQTElURVIpID49IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxudmFyIGl0ZW1TcGxpdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnWycgKyBJVEVNX1NQTElURVIgKyAnXSsnLCAnZycpO1xuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0c3ZcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVFNWQ29udGVudHModHN2KSB7XG4gIHZhciB0c3ZMaW5lcyA9IHRzdi5zcGxpdCgvXFxuKy9nKTtcbiAgdmFyIGhlYWRlcnMgPSB0cmltKHRzdkxpbmVzLnNoaWZ0KCkpLnNwbGl0KGl0ZW1TcGxpdFJlZ2V4KTtcbiAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgdmFyIHNlcmllcyA9IHpyVXRpbC5tYXAoaGVhZGVycywgZnVuY3Rpb24gKGhlYWRlcikge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBoZWFkZXIsXG4gICAgICBkYXRhOiBbXVxuICAgIH07XG4gIH0pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRzdkxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW1zID0gdHJpbSh0c3ZMaW5lc1tpXSkuc3BsaXQoaXRlbVNwbGl0UmVnZXgpO1xuICAgIGNhdGVnb3JpZXMucHVzaChpdGVtcy5zaGlmdCgpKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICBzZXJpZXNbal0gJiYgKHNlcmllc1tqXS5kYXRhW2ldID0gaXRlbXNbal0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNlcmllczogc2VyaWVzLFxuICAgIGNhdGVnb3JpZXM6IGNhdGVnb3JpZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlTGlzdENvbnRlbnRzKHN0cikge1xuICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoL1xcbisvZyk7XG4gIHZhciBzZXJpZXNOYW1lID0gdHJpbShsaW5lcy5zaGlmdCgpKTtcbiAgdmFyIGRhdGEgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGlmIGxpbmUgaXMgZW1wdHksIGlnbm9yZSBpdC5cbiAgICAvLyB0aGVyZSBpcyBhIGNhc2UgdGhhdCBhIHVzZXIgZm9yZ290IHRvIGRlbGV0ZSBgXFxuYC5cbiAgICB2YXIgbGluZSA9IHRyaW0obGluZXNbaV0pO1xuICAgIGlmICghbGluZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpdGVtcyA9IGxpbmUuc3BsaXQoaXRlbVNwbGl0UmVnZXgpO1xuICAgIHZhciBuYW1lXzEgPSAnJztcbiAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG4gICAgdmFyIGhhc05hbWUgPSBmYWxzZTtcbiAgICBpZiAoaXNOYU4oaXRlbXNbMF0pKSB7XG4gICAgICAvLyBGaXJzdCBpdGVtIGlzIG5hbWVcbiAgICAgIGhhc05hbWUgPSB0cnVlO1xuICAgICAgbmFtZV8xID0gaXRlbXNbMF07XG4gICAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKDEpO1xuICAgICAgZGF0YVtpXSA9IHtcbiAgICAgICAgbmFtZTogbmFtZV8xLFxuICAgICAgICB2YWx1ZTogW11cbiAgICAgIH07XG4gICAgICB2YWx1ZSA9IGRhdGFbaV0udmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gZGF0YVtpXSA9IFtdO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YWx1ZS5wdXNoKCtpdGVtc1tqXSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGhhc05hbWUgPyBkYXRhW2ldLnZhbHVlID0gdmFsdWVbMF0gOiBkYXRhW2ldID0gdmFsdWVbMF07XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogc2VyaWVzTmFtZSxcbiAgICBkYXRhOiBkYXRhXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUNvbnRlbnRzKHN0ciwgYmxvY2tNZXRhTGlzdCkge1xuICB2YXIgYmxvY2tzID0gc3RyLnNwbGl0KG5ldyBSZWdFeHAoJ1xcbionICsgQkxPQ0tfU1BMSVRFUiArICdcXG4qJywgJ2cnKSk7XG4gIHZhciBuZXdPcHRpb24gPSB7XG4gICAgc2VyaWVzOiBbXVxuICB9O1xuICB6clV0aWwuZWFjaChibG9ja3MsIGZ1bmN0aW9uIChibG9jaywgaWR4KSB7XG4gICAgaWYgKGlzVFNWRm9ybWF0KGJsb2NrKSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlVFNWQ29udGVudHMoYmxvY2spO1xuICAgICAgdmFyIGJsb2NrTWV0YSA9IGJsb2NrTWV0YUxpc3RbaWR4XTtcbiAgICAgIHZhciBheGlzS2V5ID0gYmxvY2tNZXRhLmF4aXNEaW0gKyAnQXhpcyc7XG4gICAgICBpZiAoYmxvY2tNZXRhKSB7XG4gICAgICAgIG5ld09wdGlvbltheGlzS2V5XSA9IG5ld09wdGlvbltheGlzS2V5XSB8fCBbXTtcbiAgICAgICAgbmV3T3B0aW9uW2F4aXNLZXldW2Jsb2NrTWV0YS5heGlzSW5kZXhdID0ge1xuICAgICAgICAgIGRhdGE6IHJlc3VsdC5jYXRlZ29yaWVzXG4gICAgICAgIH07XG4gICAgICAgIG5ld09wdGlvbi5zZXJpZXMgPSBuZXdPcHRpb24uc2VyaWVzLmNvbmNhdChyZXN1bHQuc2VyaWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGlzdENvbnRlbnRzKGJsb2NrKTtcbiAgICAgIG5ld09wdGlvbi5zZXJpZXMucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXdPcHRpb247XG59XG52YXIgRGF0YVZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRGF0YVZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIERhdGFWaWV3KCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICBEYXRhVmlldy5wcm90b3R5cGUub25jbGljayA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAvLyBGSVhNRTogYmV0dGVyIHdheT9cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHR5cGU6ICdoaWRlVGlwJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGNvbnRhaW5lciA9IGFwaS5nZXREb20oKTtcbiAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgIGlmICh0aGlzLl9kb20pIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9kb20pO1xuICAgIH1cbiAgICB2YXIgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8vIHVzZSBwYWRkaW5nIHRvIGF2b2lkIDVweCB3aGl0ZXNwYWNlXG4gICAgcm9vdC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2JvdHRvbTowO2xlZnQ6MDtyaWdodDowO3BhZGRpbmc6NXB4JztcbiAgICByb290LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJykgfHwgJyNmZmYnO1xuICAgIC8vIENyZWF0ZSBlbGVtZW50c1xuICAgIHZhciBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoNCcpO1xuICAgIHZhciBsYW5nID0gbW9kZWwuZ2V0KCdsYW5nJykgfHwgW107XG4gICAgaGVhZGVyLmlubmVySFRNTCA9IGxhbmdbMF0gfHwgbW9kZWwuZ2V0KCd0aXRsZScpO1xuICAgIGhlYWRlci5zdHlsZS5jc3NUZXh0ID0gJ21hcmdpbjoxMHB4IDIwcHgnO1xuICAgIGhlYWRlci5zdHlsZS5jb2xvciA9IG1vZGVsLmdldCgndGV4dENvbG9yJyk7XG4gICAgdmFyIHZpZXdNYWluID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIHRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB2aWV3TWFpbi5zdHlsZS5jc3NUZXh0ID0gJ292ZXJmbG93OmF1dG8nO1xuICAgIHZhciBvcHRpb25Ub0NvbnRlbnQgPSBtb2RlbC5nZXQoJ29wdGlvblRvQ29udGVudCcpO1xuICAgIHZhciBjb250ZW50VG9PcHRpb24gPSBtb2RlbC5nZXQoJ2NvbnRlbnRUb09wdGlvbicpO1xuICAgIHZhciByZXN1bHQgPSBnZXRDb250ZW50RnJvbU1vZGVsKGVjTW9kZWwpO1xuICAgIGlmICh6clV0aWwuaXNGdW5jdGlvbihvcHRpb25Ub0NvbnRlbnQpKSB7XG4gICAgICB2YXIgaHRtbE9yRG9tID0gb3B0aW9uVG9Db250ZW50KGFwaS5nZXRPcHRpb24oKSk7XG4gICAgICBpZiAoenJVdGlsLmlzU3RyaW5nKGh0bWxPckRvbSkpIHtcbiAgICAgICAgdmlld01haW4uaW5uZXJIVE1MID0gaHRtbE9yRG9tO1xuICAgICAgfSBlbHNlIGlmICh6clV0aWwuaXNEb20oaHRtbE9yRG9tKSkge1xuICAgICAgICB2aWV3TWFpbi5hcHBlbmRDaGlsZChodG1sT3JEb20pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2UgZGVmYXVsdCB0ZXh0YXJlYVxuICAgICAgdGV4dGFyZWEucmVhZE9ubHkgPSBtb2RlbC5nZXQoJ3JlYWRPbmx5Jyk7XG4gICAgICB2YXIgc3R5bGUgPSB0ZXh0YXJlYS5zdHlsZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICBzdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtmb250LWZhbWlseTptb25vc3BhY2U7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS42cmVtO3Jlc2l6ZTpub25lO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdXRsaW5lOm5vbmUnO1xuICAgICAgc3R5bGUuY29sb3IgPSBtb2RlbC5nZXQoJ3RleHRDb2xvcicpO1xuICAgICAgc3R5bGUuYm9yZGVyQ29sb3IgPSBtb2RlbC5nZXQoJ3RleHRhcmVhQm9yZGVyQ29sb3InKTtcbiAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IG1vZGVsLmdldCgndGV4dGFyZWFDb2xvcicpO1xuICAgICAgdGV4dGFyZWEudmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICB2aWV3TWFpbi5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7XG4gICAgfVxuICAgIHZhciBibG9ja01ldGFMaXN0ID0gcmVzdWx0Lm1ldGE7XG4gICAgdmFyIGJ1dHRvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJ1dHRvbkNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTo1cHg7bGVmdDowO3JpZ2h0OjAnO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgdmFyIGJ1dHRvblN0eWxlID0gJ2Zsb2F0OnJpZ2h0O21hcmdpbi1yaWdodDoyMHB4O2JvcmRlcjpub25lO2N1cnNvcjpwb2ludGVyO3BhZGRpbmc6MnB4IDVweDtmb250LXNpemU6MTJweDtib3JkZXItcmFkaXVzOjNweCc7XG4gICAgdmFyIGNsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIHJlZnJlc2hCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBidXR0b25TdHlsZSArPSAnO2JhY2tncm91bmQtY29sb3I6JyArIG1vZGVsLmdldCgnYnV0dG9uQ29sb3InKTtcbiAgICBidXR0b25TdHlsZSArPSAnO2NvbG9yOicgKyBtb2RlbC5nZXQoJ2J1dHRvblRleHRDb2xvcicpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChyb290KTtcbiAgICAgIHNlbGYuX2RvbSA9IG51bGw7XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXIoY2xvc2VCdXR0b24sICdjbGljaycsIGNsb3NlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKHJlZnJlc2hCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb250ZW50VG9PcHRpb24gPT0gbnVsbCAmJiBvcHRpb25Ub0NvbnRlbnQgIT0gbnVsbCB8fCBjb250ZW50VG9PcHRpb24gIT0gbnVsbCAmJiBvcHRpb25Ub0NvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgIHdhcm4oJ0l0IHNlZW1zIHlvdSBoYXZlIGp1c3QgcHJvdmlkZWQgb25lIG9mIGBjb250ZW50VG9PcHRpb25gIGFuZCBgb3B0aW9uVG9Db250ZW50YCBmdW5jdGlvbnMgYnV0IG1pc3NlZCB0aGUgb3RoZXIgb25lLiBEYXRhIGNoYW5nZSBpcyBpZ25vcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdPcHRpb247XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoenJVdGlsLmlzRnVuY3Rpb24oY29udGVudFRvT3B0aW9uKSkge1xuICAgICAgICAgIG5ld09wdGlvbiA9IGNvbnRlbnRUb09wdGlvbih2aWV3TWFpbiwgYXBpLmdldE9wdGlvbigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdPcHRpb24gPSBwYXJzZUNvbnRlbnRzKHRleHRhcmVhLnZhbHVlLCBibG9ja01ldGFMaXN0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgdmlldyBmb3JtYXQgZXJyb3IgJyArIGUpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld09wdGlvbikge1xuICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgIHR5cGU6ICdjaGFuZ2VEYXRhVmlldycsXG4gICAgICAgICAgbmV3T3B0aW9uOiBuZXdPcHRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjbG9zZSgpO1xuICAgIH0pO1xuICAgIGNsb3NlQnV0dG9uLmlubmVySFRNTCA9IGxhbmdbMV07XG4gICAgcmVmcmVzaEJ1dHRvbi5pbm5lckhUTUwgPSBsYW5nWzJdO1xuICAgIHJlZnJlc2hCdXR0b24uc3R5bGUuY3NzVGV4dCA9IGNsb3NlQnV0dG9uLnN0eWxlLmNzc1RleHQgPSBidXR0b25TdHlsZTtcbiAgICAhbW9kZWwuZ2V0KCdyZWFkT25seScpICYmIGJ1dHRvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChyZWZyZXNoQnV0dG9uKTtcbiAgICBidXR0b25Db250YWluZXIuYXBwZW5kQ2hpbGQoY2xvc2VCdXR0b24pO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgICByb290LmFwcGVuZENoaWxkKHZpZXdNYWluKTtcbiAgICByb290LmFwcGVuZENoaWxkKGJ1dHRvbkNvbnRhaW5lcik7XG4gICAgdmlld01haW4uc3R5bGUuaGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodCAtIDgwICsgJ3B4JztcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocm9vdCk7XG4gICAgdGhpcy5fZG9tID0gcm9vdDtcbiAgfTtcbiAgRGF0YVZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLl9kb20gJiYgYXBpLmdldERvbSgpLnJlbW92ZUNoaWxkKHRoaXMuX2RvbSk7XG4gIH07XG4gIERhdGFWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gIH07XG4gIERhdGFWaWV3LmdldERlZmF1bHRPcHRpb24gPSBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHZhciBkZWZhdWx0T3B0aW9uID0ge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIHJlYWRPbmx5OiBmYWxzZSxcbiAgICAgIG9wdGlvblRvQ29udGVudDogbnVsbCxcbiAgICAgIGNvbnRlbnRUb09wdGlvbjogbnVsbCxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgaWNvbjogJ00xNy41LDE3LjNIMzMgTTE3LjUsMTcuM0gzMyBNNDUuNCwyOS41aC0yOCBNMTEuNSwydjU2SDUxVjE0LjhMMzguNCwySDExLjV6IE0zOC40LDIuMnYxMi43SDUxIE00NS40LDQxLjdoLTI4JyxcbiAgICAgIHRpdGxlOiBlY01vZGVsLmdldExvY2FsZU1vZGVsKCkuZ2V0KFsndG9vbGJveCcsICdkYXRhVmlldycsICd0aXRsZSddKSxcbiAgICAgIGxhbmc6IGVjTW9kZWwuZ2V0TG9jYWxlTW9kZWwoKS5nZXQoWyd0b29sYm94JywgJ2RhdGFWaWV3JywgJ2xhbmcnXSksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZmJyxcbiAgICAgIHRleHRDb2xvcjogJyMwMDAnLFxuICAgICAgdGV4dGFyZWFDb2xvcjogJyNmZmYnLFxuICAgICAgdGV4dGFyZWFCb3JkZXJDb2xvcjogJyMzMzMnLFxuICAgICAgYnV0dG9uQ29sb3I6ICcjYzIzNTMxJyxcbiAgICAgIGJ1dHRvblRleHRDb2xvcjogJyNmZmYnXG4gICAgfTtcbiAgICByZXR1cm4gZGVmYXVsdE9wdGlvbjtcbiAgfTtcbiAgcmV0dXJuIERhdGFWaWV3O1xufShUb29sYm94RmVhdHVyZSk7XG4vKipcclxuICogQGlubmVyXHJcbiAqL1xuZnVuY3Rpb24gdHJ5TWVyZ2VEYXRhT3B0aW9uKG5ld0RhdGEsIG9yaWdpbmFsRGF0YSkge1xuICByZXR1cm4genJVdGlsLm1hcChuZXdEYXRhLCBmdW5jdGlvbiAobmV3VmFsLCBpZHgpIHtcbiAgICB2YXIgb3JpZ2luYWwgPSBvcmlnaW5hbERhdGEgJiYgb3JpZ2luYWxEYXRhW2lkeF07XG4gICAgaWYgKHpyVXRpbC5pc09iamVjdChvcmlnaW5hbCkgJiYgIXpyVXRpbC5pc0FycmF5KG9yaWdpbmFsKSkge1xuICAgICAgdmFyIG5ld1ZhbElzT2JqZWN0ID0genJVdGlsLmlzT2JqZWN0KG5ld1ZhbCkgJiYgIXpyVXRpbC5pc0FycmF5KG5ld1ZhbCk7XG4gICAgICBpZiAoIW5ld1ZhbElzT2JqZWN0KSB7XG4gICAgICAgIG5ld1ZhbCA9IHtcbiAgICAgICAgICB2YWx1ZTogbmV3VmFsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyBvcmlnaW5hbCBkYXRhIGhhcyBuYW1lIGJ1dCBuZXcgZGF0YSBoYXMgbm8gbmFtZVxuICAgICAgdmFyIHNob3VsZERlbGV0ZU5hbWUgPSBvcmlnaW5hbC5uYW1lICE9IG51bGwgJiYgbmV3VmFsLm5hbWUgPT0gbnVsbDtcbiAgICAgIC8vIE9yaWdpbmFsIGRhdGEgaGFzIG9wdGlvblxuICAgICAgbmV3VmFsID0genJVdGlsLmRlZmF1bHRzKG5ld1ZhbCwgb3JpZ2luYWwpO1xuICAgICAgc2hvdWxkRGVsZXRlTmFtZSAmJiBkZWxldGUgbmV3VmFsLm5hbWU7XG4gICAgICByZXR1cm4gbmV3VmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3VmFsO1xuICAgIH1cbiAgfSk7XG59XG4vLyBUT0RPOiBTRUxGIFJFR0lTVEVSRUQuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ2NoYW5nZURhdGFWaWV3JyxcbiAgZXZlbnQ6ICdkYXRhVmlld0NoYW5nZWQnLFxuICB1cGRhdGU6ICdwcmVwYXJlQW5kVXBkYXRlJ1xufSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgdmFyIG5ld1Nlcmllc09wdExpc3QgPSBbXTtcbiAgenJVdGlsLmVhY2gocGF5bG9hZC5uZXdPcHRpb24uc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzT3B0KSB7XG4gICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeU5hbWUoc2VyaWVzT3B0Lm5hbWUpWzBdO1xuICAgIGlmICghc2VyaWVzTW9kZWwpIHtcbiAgICAgIC8vIE5ldyBjcmVhdGVkIHNlcmllc1xuICAgICAgLy8gR2V1c3MgdGhlIHNlcmllcyB0eXBlXG4gICAgICBuZXdTZXJpZXNPcHRMaXN0LnB1c2goenJVdGlsLmV4dGVuZCh7XG4gICAgICAgIC8vIERlZmF1bHQgaXMgc2NhdHRlclxuICAgICAgICB0eXBlOiAnc2NhdHRlcidcbiAgICAgIH0sIHNlcmllc09wdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3JpZ2luYWxEYXRhID0gc2VyaWVzTW9kZWwuZ2V0KCdkYXRhJyk7XG4gICAgICBuZXdTZXJpZXNPcHRMaXN0LnB1c2goe1xuICAgICAgICBuYW1lOiBzZXJpZXNPcHQubmFtZSxcbiAgICAgICAgZGF0YTogdHJ5TWVyZ2VEYXRhT3B0aW9uKHNlcmllc09wdC5kYXRhLCBvcmlnaW5hbERhdGEpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBlY01vZGVsLm1lcmdlT3B0aW9uKHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgc2VyaWVzOiBuZXdTZXJpZXNPcHRMaXN0XG4gIH0sIHBheWxvYWQubmV3T3B0aW9uKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IERhdGFWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBlY2hhcnRzIGZyb20gJy4uLy4uLy4uL2NvcmUvZWNoYXJ0cy5qcyc7XG5pbXBvcnQgKiBhcyBoaXN0b3J5IGZyb20gJy4uLy4uL2RhdGFab29tL2hpc3RvcnkuanMnO1xuaW1wb3J0IHsgVG9vbGJveEZlYXR1cmUgfSBmcm9tICcuLi9mZWF0dXJlTWFuYWdlci5qcyc7XG52YXIgUmVzdG9yZU9wdGlvbiA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhSZXN0b3JlT3B0aW9uLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBSZXN0b3JlT3B0aW9uKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICBSZXN0b3JlT3B0aW9uLnByb3RvdHlwZS5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIGhpc3RvcnkuY2xlYXIoZWNNb2RlbCk7XG4gICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdyZXN0b3JlJyxcbiAgICAgIGZyb206IHRoaXMudWlkXG4gICAgfSk7XG4gIH07XG4gIFJlc3RvcmVPcHRpb24uZ2V0RGVmYXVsdE9wdGlvbiA9IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBpY29uOiAnTTMuOCwzMy40IE00NywxOC45aDkuOFY4LjcgTTU2LjMsMjAuMSBDNTIuMSw5LDQwLjUsMC42LDI2LjgsMi4xQzEyLjYsMy43LDEuNiwxNi4yLDIuMSwzMC42IE0xMyw0MS4xSDMuMXYxMC4yIE0zLjcsMzkuOWM0LjIsMTEuMSwxNS44LDE5LjUsMjkuNSwxOCBjMTQuMi0xLjYsMjUuMi0xNC4xLDI0LjctMjguNScsXG4gICAgICB0aXRsZTogZWNNb2RlbC5nZXRMb2NhbGVNb2RlbCgpLmdldChbJ3Rvb2xib3gnLCAncmVzdG9yZScsICd0aXRsZSddKVxuICAgIH07XG4gICAgcmV0dXJuIGRlZmF1bHRPcHRpb247XG4gIH07XG4gIHJldHVybiBSZXN0b3JlT3B0aW9uO1xufShUb29sYm94RmVhdHVyZSk7XG4vLyBUT0RPOiBTRUxGIFJFR0lTVEVSRUQuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ3Jlc3RvcmUnLFxuICBldmVudDogJ3Jlc3RvcmUnLFxuICB1cGRhdGU6ICdwcmVwYXJlQW5kVXBkYXRlJ1xufSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5yZXNldE9wdGlvbigncmVjcmVhdGUnKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgUmVzdG9yZU9wdGlvbjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuLy8gVE9ETyBkZXBlbmRzIG9uIERhdGFab29tIGFuZCBCcnVzaFxuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgQnJ1c2hDb250cm9sbGVyIGZyb20gJy4uLy4uL2hlbHBlci9CcnVzaENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IEJydXNoVGFyZ2V0TWFuYWdlciBmcm9tICcuLi8uLi9oZWxwZXIvQnJ1c2hUYXJnZXRNYW5hZ2VyLmpzJztcbmltcG9ydCAqIGFzIGhpc3RvcnkgZnJvbSAnLi4vLi4vZGF0YVpvb20vaGlzdG9yeS5qcyc7XG5pbXBvcnQgc2xpZGVyTW92ZSBmcm9tICcuLi8uLi9oZWxwZXIvc2xpZGVyTW92ZS5qcyc7XG5pbXBvcnQgeyBUb29sYm94RmVhdHVyZSB9IGZyb20gJy4uL2ZlYXR1cmVNYW5hZ2VyLmpzJztcbmltcG9ydCB7IG1ha2VJbnRlcm5hbENvbXBvbmVudElkLCBwYXJzZUZpbmRlciB9IGZyb20gJy4uLy4uLy4uL3V0aWwvbW9kZWwuanMnO1xuaW1wb3J0IHsgcmVnaXN0ZXJJbnRlcm5hbE9wdGlvbkNyZWF0b3IgfSBmcm9tICcuLi8uLi8uLi9tb2RlbC9pbnRlcm5hbENvbXBvbmVudENyZWF0b3IuanMnO1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBEQVRBX1pPT01fSURfQkFTRSA9IG1ha2VJbnRlcm5hbENvbXBvbmVudElkKCd0b29sYm94LWRhdGFab29tXycpO1xudmFyIElDT05fVFlQRVMgPSBbJ3pvb20nLCAnYmFjayddO1xudmFyIERhdGFab29tRmVhdHVyZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhEYXRhWm9vbUZlYXR1cmUsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIERhdGFab29tRmVhdHVyZSgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgRGF0YVpvb21GZWF0dXJlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZmVhdHVyZU1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICBpZiAoIXRoaXMuX2JydXNoQ29udHJvbGxlcikge1xuICAgICAgdGhpcy5fYnJ1c2hDb250cm9sbGVyID0gbmV3IEJydXNoQ29udHJvbGxlcihhcGkuZ2V0WnIoKSk7XG4gICAgICB0aGlzLl9icnVzaENvbnRyb2xsZXIub24oJ2JydXNoJywgenJVdGlsLmJpbmQodGhpcy5fb25CcnVzaCwgdGhpcykpLm1vdW50KCk7XG4gICAgfVxuICAgIHVwZGF0ZVpvb21CdG5TdGF0dXMoZmVhdHVyZU1vZGVsLCBlY01vZGVsLCB0aGlzLCBwYXlsb2FkLCBhcGkpO1xuICAgIHVwZGF0ZUJhY2tCdG5TdGF0dXMoZmVhdHVyZU1vZGVsLCBlY01vZGVsKTtcbiAgfTtcbiAgRGF0YVpvb21GZWF0dXJlLnByb3RvdHlwZS5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSwgdHlwZSkge1xuICAgIGhhbmRsZXJzW3R5cGVdLmNhbGwodGhpcyk7XG4gIH07XG4gIERhdGFab29tRmVhdHVyZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuX2JydXNoQ29udHJvbGxlciAmJiB0aGlzLl9icnVzaENvbnRyb2xsZXIudW5tb3VudCgpO1xuICB9O1xuICBEYXRhWm9vbUZlYXR1cmUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5fYnJ1c2hDb250cm9sbGVyICYmIHRoaXMuX2JydXNoQ29udHJvbGxlci5kaXNwb3NlKCk7XG4gIH07XG4gIERhdGFab29tRmVhdHVyZS5wcm90b3R5cGUuX29uQnJ1c2ggPSBmdW5jdGlvbiAoZXZlbnRQYXJhbSkge1xuICAgIHZhciBhcmVhcyA9IGV2ZW50UGFyYW0uYXJlYXM7XG4gICAgaWYgKCFldmVudFBhcmFtLmlzRW5kIHx8ICFhcmVhcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNuYXBzaG90ID0ge307XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgdGhpcy5fYnJ1c2hDb250cm9sbGVyLnVwZGF0ZUNvdmVycyhbXSk7IC8vIHJlbW92ZSBjb3ZlclxuICAgIHZhciBicnVzaFRhcmdldE1hbmFnZXIgPSBuZXcgQnJ1c2hUYXJnZXRNYW5hZ2VyKG1ha2VBeGlzRmluZGVyKHRoaXMubW9kZWwpLCBlY01vZGVsLCB7XG4gICAgICBpbmNsdWRlOiBbJ2dyaWQnXVxuICAgIH0pO1xuICAgIGJydXNoVGFyZ2V0TWFuYWdlci5tYXRjaE91dHB1dFJhbmdlcyhhcmVhcywgZWNNb2RlbCwgZnVuY3Rpb24gKGFyZWEsIGNvb3JkUmFuZ2UsIGNvb3JkU3lzKSB7XG4gICAgICBpZiAoY29vcmRTeXMudHlwZSAhPT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYnJ1c2hUeXBlID0gYXJlYS5icnVzaFR5cGU7XG4gICAgICBpZiAoYnJ1c2hUeXBlID09PSAncmVjdCcpIHtcbiAgICAgICAgc2V0QmF0Y2goJ3gnLCBjb29yZFN5cywgY29vcmRSYW5nZVswXSk7XG4gICAgICAgIHNldEJhdGNoKCd5JywgY29vcmRTeXMsIGNvb3JkUmFuZ2VbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0QmF0Y2goe1xuICAgICAgICAgIGxpbmVYOiAneCcsXG4gICAgICAgICAgbGluZVk6ICd5J1xuICAgICAgICB9W2JydXNoVHlwZV0sIGNvb3JkU3lzLCBjb29yZFJhbmdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBoaXN0b3J5LnB1c2goZWNNb2RlbCwgc25hcHNob3QpO1xuICAgIHRoaXMuX2Rpc3BhdGNoWm9vbUFjdGlvbihzbmFwc2hvdCk7XG4gICAgZnVuY3Rpb24gc2V0QmF0Y2goZGltTmFtZSwgY29vcmRTeXMsIG1pbk1heCkge1xuICAgICAgdmFyIGF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKGRpbU5hbWUpO1xuICAgICAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gICAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IGZpbmREYXRhWm9vbShkaW1OYW1lLCBheGlzTW9kZWwsIGVjTW9kZWwpO1xuICAgICAgLy8gUmVzdHJpY3QgcmFuZ2UuXG4gICAgICB2YXIgbWluTWF4U3BhbiA9IGRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KGF4aXNNb2RlbCkuZ2V0TWluTWF4U3BhbigpO1xuICAgICAgaWYgKG1pbk1heFNwYW4ubWluVmFsdWVTcGFuICE9IG51bGwgfHwgbWluTWF4U3Bhbi5tYXhWYWx1ZVNwYW4gIT0gbnVsbCkge1xuICAgICAgICBtaW5NYXggPSBzbGlkZXJNb3ZlKDAsIG1pbk1heC5zbGljZSgpLCBheGlzLnNjYWxlLmdldEV4dGVudCgpLCAwLCBtaW5NYXhTcGFuLm1pblZhbHVlU3BhbiwgbWluTWF4U3Bhbi5tYXhWYWx1ZVNwYW4pO1xuICAgICAgfVxuICAgICAgZGF0YVpvb21Nb2RlbCAmJiAoc25hcHNob3RbZGF0YVpvb21Nb2RlbC5pZF0gPSB7XG4gICAgICAgIGRhdGFab29tSWQ6IGRhdGFab29tTW9kZWwuaWQsXG4gICAgICAgIHN0YXJ0VmFsdWU6IG1pbk1heFswXSxcbiAgICAgICAgZW5kVmFsdWU6IG1pbk1heFsxXVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmREYXRhWm9vbShkaW1OYW1lLCBheGlzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgIHZhciBmb3VuZDtcbiAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICAgIG1haW5UeXBlOiAnZGF0YVpvb20nLFxuICAgICAgICBzdWJUeXBlOiAnc2VsZWN0J1xuICAgICAgfSwgZnVuY3Rpb24gKGR6TW9kZWwpIHtcbiAgICAgICAgdmFyIGhhcyA9IGR6TW9kZWwuZ2V0QXhpc01vZGVsKGRpbU5hbWUsIGF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gICAgICAgIGhhcyAmJiAoZm91bmQgPSBkek1vZGVsKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgfTtcbiAgO1xuICBEYXRhWm9vbUZlYXR1cmUucHJvdG90eXBlLl9kaXNwYXRjaFpvb21BY3Rpb24gPSBmdW5jdGlvbiAoc25hcHNob3QpIHtcbiAgICB2YXIgYmF0Y2ggPSBbXTtcbiAgICAvLyBDb252ZXJ0IGZyb20gaGFzaCBtYXAgdG8gYXJyYXkuXG4gICAgZWFjaChzbmFwc2hvdCwgZnVuY3Rpb24gKGJhdGNoSXRlbSwgZGF0YVpvb21JZCkge1xuICAgICAgYmF0Y2gucHVzaCh6clV0aWwuY2xvbmUoYmF0Y2hJdGVtKSk7XG4gICAgfSk7XG4gICAgYmF0Y2gubGVuZ3RoICYmIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdkYXRhWm9vbScsXG4gICAgICBmcm9tOiB0aGlzLnVpZCxcbiAgICAgIGJhdGNoOiBiYXRjaFxuICAgIH0pO1xuICB9O1xuICBEYXRhWm9vbUZlYXR1cmUuZ2V0RGVmYXVsdE9wdGlvbiA9IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgZmlsdGVyTW9kZTogJ2ZpbHRlcicsXG4gICAgICAvLyBJY29uIGdyb3VwXG4gICAgICBpY29uOiB7XG4gICAgICAgIHpvb206ICdNMCwxMy41aDI2LjkgTTEzLjUsMjYuOVYwIE0zMi4xLDEzLjVINThWNThIMTMuNSBWMzIuMScsXG4gICAgICAgIGJhY2s6ICdNMjIsMS40TDkuOSwxMy41bDEyLjMsMTIuMyBNMTAuMywxMy41SDU0Ljl2NDQuNiBIMTAuM3YtMjYnXG4gICAgICB9LFxuICAgICAgLy8gYHpvb21gLCBgYmFja2BcbiAgICAgIHRpdGxlOiBlY01vZGVsLmdldExvY2FsZU1vZGVsKCkuZ2V0KFsndG9vbGJveCcsICdkYXRhWm9vbScsICd0aXRsZSddKSxcbiAgICAgIGJydXNoU3R5bGU6IHtcbiAgICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICAgIGNvbG9yOiAncmdiYSgyMTAsMjE5LDIzOCwwLjIpJ1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGRlZmF1bHRPcHRpb247XG4gIH07XG4gIHJldHVybiBEYXRhWm9vbUZlYXR1cmU7XG59KFRvb2xib3hGZWF0dXJlKTtcbnZhciBoYW5kbGVycyA9IHtcbiAgem9vbTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXh0QWN0aXZlID0gIXRoaXMuX2lzWm9vbUFjdGl2ZTtcbiAgICB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAndGFrZUdsb2JhbEN1cnNvcicsXG4gICAgICBrZXk6ICdkYXRhWm9vbVNlbGVjdCcsXG4gICAgICBkYXRhWm9vbVNlbGVjdEFjdGl2ZTogbmV4dEFjdGl2ZVxuICAgIH0pO1xuICB9LFxuICBiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZGlzcGF0Y2hab29tQWN0aW9uKGhpc3RvcnkucG9wKHRoaXMuZWNNb2RlbCkpO1xuICB9XG59O1xuZnVuY3Rpb24gbWFrZUF4aXNGaW5kZXIoZHpGZWF0dXJlTW9kZWwpIHtcbiAgdmFyIHNldHRpbmcgPSB7XG4gICAgeEF4aXNJbmRleDogZHpGZWF0dXJlTW9kZWwuZ2V0KCd4QXhpc0luZGV4JywgdHJ1ZSksXG4gICAgeUF4aXNJbmRleDogZHpGZWF0dXJlTW9kZWwuZ2V0KCd5QXhpc0luZGV4JywgdHJ1ZSksXG4gICAgeEF4aXNJZDogZHpGZWF0dXJlTW9kZWwuZ2V0KCd4QXhpc0lkJywgdHJ1ZSksXG4gICAgeUF4aXNJZDogZHpGZWF0dXJlTW9kZWwuZ2V0KCd5QXhpc0lkJywgdHJ1ZSlcbiAgfTtcbiAgLy8gSWYgYm90aCBgeEF4aXNJbmRleGAgYHhBeGlzSWRgIG5vdCBzZXQsIGl0IG1lYW5zICdhbGwnLlxuICAvLyBJZiBib3RoIGB5QXhpc0luZGV4YCBgeUF4aXNJZGAgbm90IHNldCwgaXQgbWVhbnMgJ2FsbCcuXG4gIC8vIFNvbWUgb2xkIGNhc2VzIHNldCBsaWtlIHRoaXMgYmVsb3cgdG8gY2xvc2UgeUF4aXMgY29udHJvbCBidXQgbGVhdmUgeEF4aXMgY29udHJvbDpcbiAgLy8gYHsgZmVhdHVyZTogeyBkYXRhWm9vbTogeyB5QXhpc0luZGV4OiBmYWxzZSB9IH1gLlxuICBpZiAoc2V0dGluZy54QXhpc0luZGV4ID09IG51bGwgJiYgc2V0dGluZy54QXhpc0lkID09IG51bGwpIHtcbiAgICBzZXR0aW5nLnhBeGlzSW5kZXggPSAnYWxsJztcbiAgfVxuICBpZiAoc2V0dGluZy55QXhpc0luZGV4ID09IG51bGwgJiYgc2V0dGluZy55QXhpc0lkID09IG51bGwpIHtcbiAgICBzZXR0aW5nLnlBeGlzSW5kZXggPSAnYWxsJztcbiAgfVxuICByZXR1cm4gc2V0dGluZztcbn1cbmZ1bmN0aW9uIHVwZGF0ZUJhY2tCdG5TdGF0dXMoZmVhdHVyZU1vZGVsLCBlY01vZGVsKSB7XG4gIGZlYXR1cmVNb2RlbC5zZXRJY29uU3RhdHVzKCdiYWNrJywgaGlzdG9yeS5jb3VudChlY01vZGVsKSA+IDEgPyAnZW1waGFzaXMnIDogJ25vcm1hbCcpO1xufVxuZnVuY3Rpb24gdXBkYXRlWm9vbUJ0blN0YXR1cyhmZWF0dXJlTW9kZWwsIGVjTW9kZWwsIHZpZXcsIHBheWxvYWQsIGFwaSkge1xuICB2YXIgem9vbUFjdGl2ZSA9IHZpZXcuX2lzWm9vbUFjdGl2ZTtcbiAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC50eXBlID09PSAndGFrZUdsb2JhbEN1cnNvcicpIHtcbiAgICB6b29tQWN0aXZlID0gcGF5bG9hZC5rZXkgPT09ICdkYXRhWm9vbVNlbGVjdCcgPyBwYXlsb2FkLmRhdGFab29tU2VsZWN0QWN0aXZlIDogZmFsc2U7XG4gIH1cbiAgdmlldy5faXNab29tQWN0aXZlID0gem9vbUFjdGl2ZTtcbiAgZmVhdHVyZU1vZGVsLnNldEljb25TdGF0dXMoJ3pvb20nLCB6b29tQWN0aXZlID8gJ2VtcGhhc2lzJyA6ICdub3JtYWwnKTtcbiAgdmFyIGJydXNoVGFyZ2V0TWFuYWdlciA9IG5ldyBCcnVzaFRhcmdldE1hbmFnZXIobWFrZUF4aXNGaW5kZXIoZmVhdHVyZU1vZGVsKSwgZWNNb2RlbCwge1xuICAgIGluY2x1ZGU6IFsnZ3JpZCddXG4gIH0pO1xuICB2YXIgcGFuZWxzID0gYnJ1c2hUYXJnZXRNYW5hZ2VyLm1ha2VQYW5lbE9wdHMoYXBpLCBmdW5jdGlvbiAodGFyZ2V0SW5mbykge1xuICAgIHJldHVybiB0YXJnZXRJbmZvLnhBeGlzRGVjbGFyZWQgJiYgIXRhcmdldEluZm8ueUF4aXNEZWNsYXJlZCA/ICdsaW5lWCcgOiAhdGFyZ2V0SW5mby54QXhpc0RlY2xhcmVkICYmIHRhcmdldEluZm8ueUF4aXNEZWNsYXJlZCA/ICdsaW5lWScgOiAncmVjdCc7XG4gIH0pO1xuICB2aWV3Ll9icnVzaENvbnRyb2xsZXIuc2V0UGFuZWxzKHBhbmVscykuZW5hYmxlQnJ1c2goem9vbUFjdGl2ZSAmJiBwYW5lbHMubGVuZ3RoID8ge1xuICAgIGJydXNoVHlwZTogJ2F1dG8nLFxuICAgIGJydXNoU3R5bGU6IGZlYXR1cmVNb2RlbC5nZXRNb2RlbCgnYnJ1c2hTdHlsZScpLmdldEl0ZW1TdHlsZSgpXG4gIH0gOiBmYWxzZSk7XG59XG5yZWdpc3RlckludGVybmFsT3B0aW9uQ3JlYXRvcignZGF0YVpvb20nLCBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICB2YXIgdG9vbGJveE1vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3Rvb2xib3gnLCAwKTtcbiAgdmFyIGZlYXR1cmVEYXRhWm9vbVBhdGggPSBbJ2ZlYXR1cmUnLCAnZGF0YVpvb20nXTtcbiAgaWYgKCF0b29sYm94TW9kZWwgfHwgdG9vbGJveE1vZGVsLmdldChmZWF0dXJlRGF0YVpvb21QYXRoKSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBkekZlYXR1cmVNb2RlbCA9IHRvb2xib3hNb2RlbC5nZXRNb2RlbChmZWF0dXJlRGF0YVpvb21QYXRoKTtcbiAgdmFyIGR6T3B0aW9ucyA9IFtdO1xuICB2YXIgZmluZGVyID0gbWFrZUF4aXNGaW5kZXIoZHpGZWF0dXJlTW9kZWwpO1xuICB2YXIgZmluZGVyUmVzdWx0ID0gcGFyc2VGaW5kZXIoZWNNb2RlbCwgZmluZGVyKTtcbiAgZWFjaChmaW5kZXJSZXN1bHQueEF4aXNNb2RlbHMsIGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICByZXR1cm4gYnVpbGRJbnRlcm5hbE9wdGlvbnMoYXhpc01vZGVsLCAneEF4aXMnLCAneEF4aXNJbmRleCcpO1xuICB9KTtcbiAgZWFjaChmaW5kZXJSZXN1bHQueUF4aXNNb2RlbHMsIGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICByZXR1cm4gYnVpbGRJbnRlcm5hbE9wdGlvbnMoYXhpc01vZGVsLCAneUF4aXMnLCAneUF4aXNJbmRleCcpO1xuICB9KTtcbiAgZnVuY3Rpb24gYnVpbGRJbnRlcm5hbE9wdGlvbnMoYXhpc01vZGVsLCBheGlzTWFpblR5cGUsIGF4aXNJbmRleFByb3BOYW1lKSB7XG4gICAgdmFyIGF4aXNJbmRleCA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcbiAgICB2YXIgbmV3T3B0ID0ge1xuICAgICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgICAkZnJvbVRvb2xib3g6IHRydWUsXG4gICAgICAvLyBEZWZhdWx0IHRvIGJlIGZpbHRlclxuICAgICAgZmlsdGVyTW9kZTogZHpGZWF0dXJlTW9kZWwuZ2V0KCdmaWx0ZXJNb2RlJywgdHJ1ZSkgfHwgJ2ZpbHRlcicsXG4gICAgICAvLyBJZCBmb3IgbWVyZ2UgbWFwcGluZy5cbiAgICAgIGlkOiBEQVRBX1pPT01fSURfQkFTRSArIGF4aXNNYWluVHlwZSArIGF4aXNJbmRleFxuICAgIH07XG4gICAgbmV3T3B0W2F4aXNJbmRleFByb3BOYW1lXSA9IGF4aXNJbmRleDtcbiAgICBkek9wdGlvbnMucHVzaChuZXdPcHQpO1xuICB9XG4gIHJldHVybiBkek9wdGlvbnM7XG59KTtcbmV4cG9ydCBkZWZhdWx0IERhdGFab29tRmVhdHVyZTsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IHVzZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbi5qcyc7XG5pbXBvcnQgeyBpbnN0YWxsIGFzIGluc3RhbGxEYXRhWm9vbVNlbGVjdCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudC9kYXRhWm9vbS9pbnN0YWxsRGF0YVpvb21TZWxlY3QuanMnO1xuaW1wb3J0IFRvb2xib3hNb2RlbCBmcm9tICcuL1Rvb2xib3hNb2RlbC5qcyc7XG5pbXBvcnQgVG9vbGJveFZpZXcgZnJvbSAnLi9Ub29sYm94Vmlldy5qcyc7XG4vLyBUT0RPRDogUkVHSVNURVIgSU4gSU5TVEFMTFxuaW1wb3J0IHsgcmVnaXN0ZXJGZWF0dXJlIH0gZnJvbSAnLi9mZWF0dXJlTWFuYWdlci5qcyc7XG5pbXBvcnQgU2F2ZUFzSW1hZ2UgZnJvbSAnLi9mZWF0dXJlL1NhdmVBc0ltYWdlLmpzJztcbmltcG9ydCBNYWdpY1R5cGUgZnJvbSAnLi9mZWF0dXJlL01hZ2ljVHlwZS5qcyc7XG5pbXBvcnQgRGF0YVZpZXcgZnJvbSAnLi9mZWF0dXJlL0RhdGFWaWV3LmpzJztcbmltcG9ydCBSZXN0b3JlIGZyb20gJy4vZmVhdHVyZS9SZXN0b3JlLmpzJztcbmltcG9ydCBEYXRhWm9vbSBmcm9tICcuL2ZlYXR1cmUvRGF0YVpvb20uanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKFRvb2xib3hNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoVG9vbGJveFZpZXcpO1xuICByZWdpc3RlckZlYXR1cmUoJ3NhdmVBc0ltYWdlJywgU2F2ZUFzSW1hZ2UpO1xuICByZWdpc3RlckZlYXR1cmUoJ21hZ2ljVHlwZScsIE1hZ2ljVHlwZSk7XG4gIHJlZ2lzdGVyRmVhdHVyZSgnZGF0YVZpZXcnLCBEYXRhVmlldyk7XG4gIHJlZ2lzdGVyRmVhdHVyZSgnZGF0YVpvb20nLCBEYXRhWm9vbSk7XG4gIHJlZ2lzdGVyRmVhdHVyZSgncmVzdG9yZScsIFJlc3RvcmUpO1xuICB1c2UoaW5zdGFsbERhdGFab29tU2VsZWN0KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///92260\n")}}]);