"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[834],{1284:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   O8: () => (/* binding */ CartesianYAxisView),\n/* harmony export */   xR: () => (/* binding */ CartesianXAxisView)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98026);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43870);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(43199);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(82861);\n/* harmony import */ var _AxisBuilder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89598);\n/* harmony import */ var _AxisView_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(22480);\n/* harmony import */ var _coord_cartesian_cartesianAxisHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96878);\n/* harmony import */ var _axisSplitHelper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(35369);\n/* harmony import */ var _scale_helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(67071);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine', 'minorSplitLine'];\nvar CartesianAxisView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(CartesianAxisView, _super);\n  function CartesianAxisView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = CartesianAxisView.type;\n    _this.axisPointerClass = 'CartesianAxisPointer';\n    return _this;\n  }\n  /**\r\n   * @override\r\n   */\n  CartesianAxisView.prototype.render = function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A();\n    this.group.add(this._axisGroup);\n    if (!axisModel.get('show')) {\n      return;\n    }\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = _coord_cartesian_cartesianAxisHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .layout */ .Zp(gridModel, axisModel);\n    var axisBuilder = new _AxisBuilder_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A(axisModel, zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.extend({\n      handleAutoShown: function (elementType) {\n        var cartesians = gridModel.coordinateSystem.getCartesians();\n        for (var i = 0; i < cartesians.length; i++) {\n          if ((0,_scale_helper_js__WEBPACK_IMPORTED_MODULE_5__/* .isIntervalOrLogScale */ .rf)(cartesians[i].getOtherAxis(axisModel.axis).scale)) {\n            // Still show axis tick or axisLine if other axis is value / log\n            return true;\n          }\n        }\n        // Not show axisTick or axisLine if other axis is category / time\n        return false;\n      }\n    }, layout));\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n    this._axisGroup.add(axisBuilder.getGroup());\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get([name, 'show'])) {\n        axisElementBuilders[name](this, this._axisGroup, axisModel, gridModel);\n      }\n    }, this);\n    // THIS is a special case for bar racing chart.\n    // Update the axis label from the natural initial layout to\n    // sorted layout should has no animation.\n    var isInitialSortFromBarRacing = payload && payload.type === 'changeAxisOrder' && payload.isInitSort;\n    if (!isInitialSortFromBarRacing) {\n      _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    }\n    _super.prototype.render.call(this, axisModel, ecModel, api, payload);\n  };\n  CartesianAxisView.prototype.remove = function () {\n    (0,_axisSplitHelper_js__WEBPACK_IMPORTED_MODULE_7__/* .rectCoordAxisHandleRemove */ .V)(this);\n  };\n  CartesianAxisView.type = 'cartesianAxis';\n  return CartesianAxisView;\n}(_AxisView_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .A);\nvar axisElementBuilders = {\n  splitLine: function (axisView, axisGroup, axisModel, gridModel) {\n    var axis = axisModel.axis;\n    if (axis.scale.isBlank()) {\n      return;\n    }\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var showMinLine = splitLineModel.get('showMinLine') !== false;\n    var showMaxLine = splitLineModel.get('showMaxLine') !== false;\n    lineColors = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitLineModel\n    });\n    var p1 = [];\n    var p2 = [];\n    var lineStyle = lineStyleModel.getLineStyle();\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n      if (i === 0 && !showMinLine || i === ticksCoords.length - 1 && !showMaxLine) {\n        continue;\n      }\n      var tickValue = ticksCoords[i].tickValue;\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n      var colorIndex = lineCount++ % lineColors.length;\n      var line = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_9__/* [\"default\"] */ .A({\n        anid: tickValue != null ? 'line_' + tickValue : null,\n        autoBatch: true,\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      });\n      _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__.subPixelOptimizeLine(line.shape, lineStyle.lineWidth);\n      axisGroup.add(line);\n    }\n  },\n  minorSplitLine: function (axisView, axisGroup, axisModel, gridModel) {\n    var axis = axisModel.axis;\n    var minorSplitLineModel = axisModel.getModel('minorSplitLine');\n    var lineStyleModel = minorSplitLineModel.getModel('lineStyle');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var minorTicksCoords = axis.getMinorTicksCoords();\n    if (!minorTicksCoords.length) {\n      return;\n    }\n    var p1 = [];\n    var p2 = [];\n    var lineStyle = lineStyleModel.getLineStyle();\n    for (var i = 0; i < minorTicksCoords.length; i++) {\n      for (var k = 0; k < minorTicksCoords[i].length; k++) {\n        var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);\n        if (isHorizontal) {\n          p1[0] = tickCoord;\n          p1[1] = gridRect.y;\n          p2[0] = tickCoord;\n          p2[1] = gridRect.y + gridRect.height;\n        } else {\n          p1[0] = gridRect.x;\n          p1[1] = tickCoord;\n          p2[0] = gridRect.x + gridRect.width;\n          p2[1] = tickCoord;\n        }\n        var line = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_9__/* [\"default\"] */ .A({\n          anid: 'minor_line_' + minorTicksCoords[i][k].tickValue,\n          autoBatch: true,\n          shape: {\n            x1: p1[0],\n            y1: p1[1],\n            x2: p2[0],\n            y2: p2[1]\n          },\n          style: lineStyle,\n          silent: true\n        });\n        _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__.subPixelOptimizeLine(line.shape, lineStyle.lineWidth);\n        axisGroup.add(line);\n      }\n    }\n  },\n  splitArea: function (axisView, axisGroup, axisModel, gridModel) {\n    (0,_axisSplitHelper_js__WEBPACK_IMPORTED_MODULE_7__/* .rectCoordAxisBuildSplitArea */ .Y)(axisView, axisGroup, axisModel, gridModel);\n  }\n};\nvar CartesianXAxisView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(CartesianXAxisView, _super);\n  function CartesianXAxisView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = CartesianXAxisView.type;\n    return _this;\n  }\n  CartesianXAxisView.type = 'xAxis';\n  return CartesianXAxisView;\n}(CartesianAxisView);\n\nvar CartesianYAxisView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(CartesianYAxisView, _super);\n  function CartesianYAxisView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = CartesianXAxisView.type;\n    return _this;\n  }\n  CartesianYAxisView.type = 'yAxis';\n  return CartesianYAxisView;\n}(CartesianAxisView);\n\n/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (CartesianAxisView)));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI4NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9DYXJ0ZXNpYW5BeGlzVmlldy5qcz85NGQwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCBBeGlzQnVpbGRlciBmcm9tICcuL0F4aXNCdWlsZGVyLmpzJztcbmltcG9ydCBBeGlzVmlldyBmcm9tICcuL0F4aXNWaWV3LmpzJztcbmltcG9ydCAqIGFzIGNhcnRlc2lhbkF4aXNIZWxwZXIgZnJvbSAnLi4vLi4vY29vcmQvY2FydGVzaWFuL2NhcnRlc2lhbkF4aXNIZWxwZXIuanMnO1xuaW1wb3J0IHsgcmVjdENvb3JkQXhpc0J1aWxkU3BsaXRBcmVhLCByZWN0Q29vcmRBeGlzSGFuZGxlUmVtb3ZlIH0gZnJvbSAnLi9heGlzU3BsaXRIZWxwZXIuanMnO1xuaW1wb3J0IHsgaXNJbnRlcnZhbE9yTG9nU2NhbGUgfSBmcm9tICcuLi8uLi9zY2FsZS9oZWxwZXIuanMnO1xudmFyIGF4aXNCdWlsZGVyQXR0cnMgPSBbJ2F4aXNMaW5lJywgJ2F4aXNUaWNrTGFiZWwnLCAnYXhpc05hbWUnXTtcbnZhciBzZWxmQnVpbGRlckF0dHJzID0gWydzcGxpdEFyZWEnLCAnc3BsaXRMaW5lJywgJ21pbm9yU3BsaXRMaW5lJ107XG52YXIgQ2FydGVzaWFuQXhpc1ZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ2FydGVzaWFuQXhpc1ZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIENhcnRlc2lhbkF4aXNWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBDYXJ0ZXNpYW5BeGlzVmlldy50eXBlO1xuICAgIF90aGlzLmF4aXNQb2ludGVyQ2xhc3MgPSAnQ2FydGVzaWFuQXhpc1BvaW50ZXInO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgQ2FydGVzaWFuQXhpc1ZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdmFyIG9sZEF4aXNHcm91cCA9IHRoaXMuX2F4aXNHcm91cDtcbiAgICB0aGlzLl9heGlzR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2F4aXNHcm91cCk7XG4gICAgaWYgKCFheGlzTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGdyaWRNb2RlbCA9IGF4aXNNb2RlbC5nZXRDb29yZFN5c01vZGVsKCk7XG4gICAgdmFyIGxheW91dCA9IGNhcnRlc2lhbkF4aXNIZWxwZXIubGF5b3V0KGdyaWRNb2RlbCwgYXhpc01vZGVsKTtcbiAgICB2YXIgYXhpc0J1aWxkZXIgPSBuZXcgQXhpc0J1aWxkZXIoYXhpc01vZGVsLCB6clV0aWwuZXh0ZW5kKHtcbiAgICAgIGhhbmRsZUF1dG9TaG93bjogZnVuY3Rpb24gKGVsZW1lbnRUeXBlKSB7XG4gICAgICAgIHZhciBjYXJ0ZXNpYW5zID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0Q2FydGVzaWFucygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhcnRlc2lhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaXNJbnRlcnZhbE9yTG9nU2NhbGUoY2FydGVzaWFuc1tpXS5nZXRPdGhlckF4aXMoYXhpc01vZGVsLmF4aXMpLnNjYWxlKSkge1xuICAgICAgICAgICAgLy8gU3RpbGwgc2hvdyBheGlzIHRpY2sgb3IgYXhpc0xpbmUgaWYgb3RoZXIgYXhpcyBpcyB2YWx1ZSAvIGxvZ1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCBzaG93IGF4aXNUaWNrIG9yIGF4aXNMaW5lIGlmIG90aGVyIGF4aXMgaXMgY2F0ZWdvcnkgLyB0aW1lXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCBsYXlvdXQpKTtcbiAgICB6clV0aWwuZWFjaChheGlzQnVpbGRlckF0dHJzLCBheGlzQnVpbGRlci5hZGQsIGF4aXNCdWlsZGVyKTtcbiAgICB0aGlzLl9heGlzR3JvdXAuYWRkKGF4aXNCdWlsZGVyLmdldEdyb3VwKCkpO1xuICAgIHpyVXRpbC5lYWNoKHNlbGZCdWlsZGVyQXR0cnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAoYXhpc01vZGVsLmdldChbbmFtZSwgJ3Nob3cnXSkpIHtcbiAgICAgICAgYXhpc0VsZW1lbnRCdWlsZGVyc1tuYW1lXSh0aGlzLCB0aGlzLl9heGlzR3JvdXAsIGF4aXNNb2RlbCwgZ3JpZE1vZGVsKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICAvLyBUSElTIGlzIGEgc3BlY2lhbCBjYXNlIGZvciBiYXIgcmFjaW5nIGNoYXJ0LlxuICAgIC8vIFVwZGF0ZSB0aGUgYXhpcyBsYWJlbCBmcm9tIHRoZSBuYXR1cmFsIGluaXRpYWwgbGF5b3V0IHRvXG4gICAgLy8gc29ydGVkIGxheW91dCBzaG91bGQgaGFzIG5vIGFuaW1hdGlvbi5cbiAgICB2YXIgaXNJbml0aWFsU29ydEZyb21CYXJSYWNpbmcgPSBwYXlsb2FkICYmIHBheWxvYWQudHlwZSA9PT0gJ2NoYW5nZUF4aXNPcmRlcicgJiYgcGF5bG9hZC5pc0luaXRTb3J0O1xuICAgIGlmICghaXNJbml0aWFsU29ydEZyb21CYXJSYWNpbmcpIHtcbiAgICAgIGdyYXBoaWMuZ3JvdXBUcmFuc2l0aW9uKG9sZEF4aXNHcm91cCwgdGhpcy5fYXhpc0dyb3VwLCBheGlzTW9kZWwpO1xuICAgIH1cbiAgICBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMsIGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgfTtcbiAgQ2FydGVzaWFuQXhpc1ZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZWN0Q29vcmRBeGlzSGFuZGxlUmVtb3ZlKHRoaXMpO1xuICB9O1xuICBDYXJ0ZXNpYW5BeGlzVmlldy50eXBlID0gJ2NhcnRlc2lhbkF4aXMnO1xuICByZXR1cm4gQ2FydGVzaWFuQXhpc1ZpZXc7XG59KEF4aXNWaWV3KTtcbnZhciBheGlzRWxlbWVudEJ1aWxkZXJzID0ge1xuICBzcGxpdExpbmU6IGZ1bmN0aW9uIChheGlzVmlldywgYXhpc0dyb3VwLCBheGlzTW9kZWwsIGdyaWRNb2RlbCkge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgaWYgKGF4aXMuc2NhbGUuaXNCbGFuaygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzcGxpdExpbmVNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRMaW5lJyk7XG4gICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gc3BsaXRMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgIHZhciBsaW5lQ29sb3JzID0gbGluZVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICAgIHZhciBzaG93TWluTGluZSA9IHNwbGl0TGluZU1vZGVsLmdldCgnc2hvd01pbkxpbmUnKSAhPT0gZmFsc2U7XG4gICAgdmFyIHNob3dNYXhMaW5lID0gc3BsaXRMaW5lTW9kZWwuZ2V0KCdzaG93TWF4TGluZScpICE9PSBmYWxzZTtcbiAgICBsaW5lQ29sb3JzID0genJVdGlsLmlzQXJyYXkobGluZUNvbG9ycykgPyBsaW5lQ29sb3JzIDogW2xpbmVDb2xvcnNdO1xuICAgIHZhciBncmlkUmVjdCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFJlY3QoKTtcbiAgICB2YXIgaXNIb3Jpem9udGFsID0gYXhpcy5pc0hvcml6b250YWwoKTtcbiAgICB2YXIgbGluZUNvdW50ID0gMDtcbiAgICB2YXIgdGlja3NDb29yZHMgPSBheGlzLmdldFRpY2tzQ29vcmRzKHtcbiAgICAgIHRpY2tNb2RlbDogc3BsaXRMaW5lTW9kZWxcbiAgICB9KTtcbiAgICB2YXIgcDEgPSBbXTtcbiAgICB2YXIgcDIgPSBbXTtcbiAgICB2YXIgbGluZVN0eWxlID0gbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRpY2tDb29yZCA9IGF4aXMudG9HbG9iYWxDb29yZCh0aWNrc0Nvb3Jkc1tpXS5jb29yZCk7XG4gICAgICBpZiAoaSA9PT0gMCAmJiAhc2hvd01pbkxpbmUgfHwgaSA9PT0gdGlja3NDb29yZHMubGVuZ3RoIC0gMSAmJiAhc2hvd01heExpbmUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgdGlja1ZhbHVlID0gdGlja3NDb29yZHNbaV0udGlja1ZhbHVlO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBwMVswXSA9IHRpY2tDb29yZDtcbiAgICAgICAgcDFbMV0gPSBncmlkUmVjdC55O1xuICAgICAgICBwMlswXSA9IHRpY2tDb29yZDtcbiAgICAgICAgcDJbMV0gPSBncmlkUmVjdC55ICsgZ3JpZFJlY3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcDFbMF0gPSBncmlkUmVjdC54O1xuICAgICAgICBwMVsxXSA9IHRpY2tDb29yZDtcbiAgICAgICAgcDJbMF0gPSBncmlkUmVjdC54ICsgZ3JpZFJlY3Qud2lkdGg7XG4gICAgICAgIHAyWzFdID0gdGlja0Nvb3JkO1xuICAgICAgfVxuICAgICAgdmFyIGNvbG9ySW5kZXggPSBsaW5lQ291bnQrKyAlIGxpbmVDb2xvcnMubGVuZ3RoO1xuICAgICAgdmFyIGxpbmUgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcbiAgICAgICAgYW5pZDogdGlja1ZhbHVlICE9IG51bGwgPyAnbGluZV8nICsgdGlja1ZhbHVlIDogbnVsbCxcbiAgICAgICAgYXV0b0JhdGNoOiB0cnVlLFxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIHgxOiBwMVswXSxcbiAgICAgICAgICB5MTogcDFbMV0sXG4gICAgICAgICAgeDI6IHAyWzBdLFxuICAgICAgICAgIHkyOiBwMlsxXVxuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICBzdHJva2U6IGxpbmVDb2xvcnNbY29sb3JJbmRleF1cbiAgICAgICAgfSwgbGluZVN0eWxlKSxcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUobGluZS5zaGFwZSwgbGluZVN0eWxlLmxpbmVXaWR0aCk7XG4gICAgICBheGlzR3JvdXAuYWRkKGxpbmUpO1xuICAgIH1cbiAgfSxcbiAgbWlub3JTcGxpdExpbmU6IGZ1bmN0aW9uIChheGlzVmlldywgYXhpc0dyb3VwLCBheGlzTW9kZWwsIGdyaWRNb2RlbCkge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIG1pbm9yU3BsaXRMaW5lTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ21pbm9yU3BsaXRMaW5lJyk7XG4gICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gbWlub3JTcGxpdExpbmVNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJyk7XG4gICAgdmFyIGdyaWRSZWN0ID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpO1xuICAgIHZhciBpc0hvcml6b250YWwgPSBheGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIHZhciBtaW5vclRpY2tzQ29vcmRzID0gYXhpcy5nZXRNaW5vclRpY2tzQ29vcmRzKCk7XG4gICAgaWYgKCFtaW5vclRpY2tzQ29vcmRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcDEgPSBbXTtcbiAgICB2YXIgcDIgPSBbXTtcbiAgICB2YXIgbGluZVN0eWxlID0gbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5vclRpY2tzQ29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IG1pbm9yVGlja3NDb29yZHNbaV0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIHRpY2tDb29yZCA9IGF4aXMudG9HbG9iYWxDb29yZChtaW5vclRpY2tzQ29vcmRzW2ldW2tdLmNvb3JkKTtcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgIHAxWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICAgIHAxWzFdID0gZ3JpZFJlY3QueTtcbiAgICAgICAgICBwMlswXSA9IHRpY2tDb29yZDtcbiAgICAgICAgICBwMlsxXSA9IGdyaWRSZWN0LnkgKyBncmlkUmVjdC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcDFbMF0gPSBncmlkUmVjdC54O1xuICAgICAgICAgIHAxWzFdID0gdGlja0Nvb3JkO1xuICAgICAgICAgIHAyWzBdID0gZ3JpZFJlY3QueCArIGdyaWRSZWN0LndpZHRoO1xuICAgICAgICAgIHAyWzFdID0gdGlja0Nvb3JkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lID0gbmV3IGdyYXBoaWMuTGluZSh7XG4gICAgICAgICAgYW5pZDogJ21pbm9yX2xpbmVfJyArIG1pbm9yVGlja3NDb29yZHNbaV1ba10udGlja1ZhbHVlLFxuICAgICAgICAgIGF1dG9CYXRjaDogdHJ1ZSxcbiAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgeDE6IHAxWzBdLFxuICAgICAgICAgICAgeTE6IHAxWzFdLFxuICAgICAgICAgICAgeDI6IHAyWzBdLFxuICAgICAgICAgICAgeTI6IHAyWzFdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHlsZTogbGluZVN0eWxlLFxuICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZShsaW5lLnNoYXBlLCBsaW5lU3R5bGUubGluZVdpZHRoKTtcbiAgICAgICAgYXhpc0dyb3VwLmFkZChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNwbGl0QXJlYTogZnVuY3Rpb24gKGF4aXNWaWV3LCBheGlzR3JvdXAsIGF4aXNNb2RlbCwgZ3JpZE1vZGVsKSB7XG4gICAgcmVjdENvb3JkQXhpc0J1aWxkU3BsaXRBcmVhKGF4aXNWaWV3LCBheGlzR3JvdXAsIGF4aXNNb2RlbCwgZ3JpZE1vZGVsKTtcbiAgfVxufTtcbnZhciBDYXJ0ZXNpYW5YQXhpc1ZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ2FydGVzaWFuWEF4aXNWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBDYXJ0ZXNpYW5YQXhpc1ZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IENhcnRlc2lhblhBeGlzVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBDYXJ0ZXNpYW5YQXhpc1ZpZXcudHlwZSA9ICd4QXhpcyc7XG4gIHJldHVybiBDYXJ0ZXNpYW5YQXhpc1ZpZXc7XG59KENhcnRlc2lhbkF4aXNWaWV3KTtcbmV4cG9ydCB7IENhcnRlc2lhblhBeGlzVmlldyB9O1xudmFyIENhcnRlc2lhbllBeGlzVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDYXJ0ZXNpYW5ZQXhpc1ZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIENhcnRlc2lhbllBeGlzVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gQ2FydGVzaWFuWEF4aXNWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIENhcnRlc2lhbllBeGlzVmlldy50eXBlID0gJ3lBeGlzJztcbiAgcmV0dXJuIENhcnRlc2lhbllBeGlzVmlldztcbn0oQ2FydGVzaWFuQXhpc1ZpZXcpO1xuZXhwb3J0IHsgQ2FydGVzaWFuWUF4aXNWaWV3IH07XG5leHBvcnQgZGVmYXVsdCBDYXJ0ZXNpYW5BeGlzVmlldzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1284\n")},3686:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DA: () => (/* binding */ buildCartesianSingleLabelElOption),\n/* harmony export */   MU: () => (/* binding */ makeLineShape),\n/* harmony export */   T8: () => (/* binding */ buildLabelElOption),\n/* harmony export */   Tc: () => (/* binding */ getTransformedPosition),\n/* harmony export */   _F: () => (/* binding */ getValueLabel),\n/* harmony export */   bY: () => (/* binding */ buildElStyle),\n/* harmony export */   cU: () => (/* binding */ makeRectShape),\n/* harmony export */   u7: () => (/* binding */ makeSectorShape)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98026);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(43199);\n/* harmony import */ var zrender_lib_contain_text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45558);\n/* harmony import */ var _util_format_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83412);\n/* harmony import */ var zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45587);\n/* harmony import */ var _coord_axisHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99031);\n/* harmony import */ var _axis_AxisBuilder_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(89598);\n/* harmony import */ var _label_labelStyle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89632);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nfunction buildElStyle(axisPointerModel) {\n  var axisPointerType = axisPointerModel.get('type');\n  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n  var style;\n  if (axisPointerType === 'line') {\n    style = styleModel.getLineStyle();\n    style.fill = null;\n  } else if (axisPointerType === 'shadow') {\n    style = styleModel.getAreaStyle();\n    style.stroke = null;\n  }\n  return style;\n}\n/**\r\n * @param {Function} labelPos {align, verticalAlign, position}\r\n */\nfunction buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {\n  var value = axisPointerModel.get('value');\n  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {\n    precision: axisPointerModel.get(['label', 'precision']),\n    formatter: axisPointerModel.get(['label', 'formatter'])\n  });\n  var labelModel = axisPointerModel.getModel('label');\n  var paddings = _util_format_js__WEBPACK_IMPORTED_MODULE_0__/* .normalizeCssArray */ .QX(labelModel.get('padding') || 0);\n  var font = labelModel.getFont();\n  var textRect = zrender_lib_contain_text_js__WEBPACK_IMPORTED_MODULE_1__/* .getBoundingRect */ .NO(text, font);\n  var position = labelPos.position;\n  var width = textRect.width + paddings[1] + paddings[3];\n  var height = textRect.height + paddings[0] + paddings[2];\n  // Adjust by align.\n  var align = labelPos.align;\n  align === 'right' && (position[0] -= width);\n  align === 'center' && (position[0] -= width / 2);\n  var verticalAlign = labelPos.verticalAlign;\n  verticalAlign === 'bottom' && (position[1] -= height);\n  verticalAlign === 'middle' && (position[1] -= height / 2);\n  // Not overflow ec container\n  confineInContainer(position, width, height, api);\n  var bgColor = labelModel.get('backgroundColor');\n  if (!bgColor || bgColor === 'auto') {\n    bgColor = axisModel.get(['axisLine', 'lineStyle', 'color']);\n  }\n  elOption.label = {\n    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},\n    x: position[0],\n    y: position[1],\n    style: (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_2__/* .createTextStyle */ .VB)(labelModel, {\n      text: text,\n      font: font,\n      fill: labelModel.getTextColor(),\n      padding: paddings,\n      backgroundColor: bgColor\n    }),\n    // Label should be over axisPointer.\n    z2: 10\n  };\n}\n// Do not overflow ec container\nfunction confineInContainer(position, width, height, api) {\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  position[0] = Math.min(position[0] + width, viewWidth) - width;\n  position[1] = Math.min(position[1] + height, viewHeight) - height;\n  position[0] = Math.max(position[0], 0);\n  position[1] = Math.max(position[1], 0);\n}\nfunction getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {\n  value = axis.scale.parse(value);\n  var text = axis.scale.getLabel({\n    value: value\n  }, {\n    // If `precision` is set, width can be fixed (like '12.00500'), which\n    // helps to debounce when when moving label.\n    precision: opt.precision\n  });\n  var formatter = opt.formatter;\n  if (formatter) {\n    var params_1 = {\n      value: _coord_axisHelper_js__WEBPACK_IMPORTED_MODULE_3__/* .getAxisRawValue */ .Dt(axis, {\n        value: value\n      }),\n      axisDimension: axis.dim,\n      axisIndex: axis.index,\n      seriesData: []\n    };\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.each(seriesDataIndices, function (idxItem) {\n      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n      var dataIndex = idxItem.dataIndexInside;\n      var dataParams = series && series.getDataParams(dataIndex);\n      dataParams && params_1.seriesData.push(dataParams);\n    });\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.isString(formatter)) {\n      text = formatter.replace('{value}', text);\n    } else if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.isFunction(formatter)) {\n      text = formatter(params_1);\n    }\n  }\n  return text;\n}\nfunction getTransformedPosition(axis, value, layoutInfo) {\n  var transform = zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__.create();\n  zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__.rotate(transform, transform, layoutInfo.rotation);\n  zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__.translate(transform, transform, layoutInfo.position);\n  return _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);\n}\nfunction buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {\n  // @ts-ignore\n  var textLayout = _axis_AxisBuilder_js__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .A.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);\n  layoutInfo.labelMargin = axisPointerModel.get(['label', 'margin']);\n  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n    position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n    align: textLayout.textAlign,\n    verticalAlign: textLayout.textVerticalAlign\n  });\n}\nfunction makeLineShape(p1, p2, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x1: p1[xDimIndex],\n    y1: p1[1 - xDimIndex],\n    x2: p2[xDimIndex],\n    y2: p2[1 - xDimIndex]\n  };\n}\nfunction makeRectShape(xy, wh, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x: xy[xDimIndex],\n    y: xy[1 - xDimIndex],\n    width: wh[xDimIndex],\n    height: wh[1 - xDimIndex]\n  };\n}\nfunction makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n  return {\n    cx: cx,\n    cy: cy,\n    r0: r0,\n    r: r,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    clockwise: true\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY4Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL3ZpZXdIZWxwZXIuanM/MDMzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0ICogYXMgdGV4dENvbnRhaW4gZnJvbSAnenJlbmRlci9saWIvY29udGFpbi90ZXh0LmpzJztcbmltcG9ydCAqIGFzIGZvcm1hdFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9mb3JtYXQuanMnO1xuaW1wb3J0ICogYXMgbWF0cml4IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzJztcbmltcG9ydCAqIGFzIGF4aXNIZWxwZXIgZnJvbSAnLi4vLi4vY29vcmQvYXhpc0hlbHBlci5qcyc7XG5pbXBvcnQgQXhpc0J1aWxkZXIgZnJvbSAnLi4vYXhpcy9BeGlzQnVpbGRlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVUZXh0U3R5bGUgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBidWlsZEVsU3R5bGUoYXhpc1BvaW50ZXJNb2RlbCkge1xuICB2YXIgYXhpc1BvaW50ZXJUeXBlID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgdmFyIHN0eWxlTW9kZWwgPSBheGlzUG9pbnRlck1vZGVsLmdldE1vZGVsKGF4aXNQb2ludGVyVHlwZSArICdTdHlsZScpO1xuICB2YXIgc3R5bGU7XG4gIGlmIChheGlzUG9pbnRlclR5cGUgPT09ICdsaW5lJykge1xuICAgIHN0eWxlID0gc3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKTtcbiAgICBzdHlsZS5maWxsID0gbnVsbDtcbiAgfSBlbHNlIGlmIChheGlzUG9pbnRlclR5cGUgPT09ICdzaGFkb3cnKSB7XG4gICAgc3R5bGUgPSBzdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpO1xuICAgIHN0eWxlLnN0cm9rZSA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHN0eWxlO1xufVxuLyoqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxhYmVsUG9zIHthbGlnbiwgdmVydGljYWxBbGlnbiwgcG9zaXRpb259XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTGFiZWxFbE9wdGlvbihlbE9wdGlvbiwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGksIGxhYmVsUG9zKSB7XG4gIHZhciB2YWx1ZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd2YWx1ZScpO1xuICB2YXIgdGV4dCA9IGdldFZhbHVlTGFiZWwodmFsdWUsIGF4aXNNb2RlbC5heGlzLCBheGlzTW9kZWwuZWNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3Nlcmllc0RhdGFJbmRpY2VzJyksIHtcbiAgICBwcmVjaXNpb246IGF4aXNQb2ludGVyTW9kZWwuZ2V0KFsnbGFiZWwnLCAncHJlY2lzaW9uJ10pLFxuICAgIGZvcm1hdHRlcjogYXhpc1BvaW50ZXJNb2RlbC5nZXQoWydsYWJlbCcsICdmb3JtYXR0ZXInXSlcbiAgfSk7XG4gIHZhciBsYWJlbE1vZGVsID0gYXhpc1BvaW50ZXJNb2RlbC5nZXRNb2RlbCgnbGFiZWwnKTtcbiAgdmFyIHBhZGRpbmdzID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShsYWJlbE1vZGVsLmdldCgncGFkZGluZycpIHx8IDApO1xuICB2YXIgZm9udCA9IGxhYmVsTW9kZWwuZ2V0Rm9udCgpO1xuICB2YXIgdGV4dFJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCk7XG4gIHZhciBwb3NpdGlvbiA9IGxhYmVsUG9zLnBvc2l0aW9uO1xuICB2YXIgd2lkdGggPSB0ZXh0UmVjdC53aWR0aCArIHBhZGRpbmdzWzFdICsgcGFkZGluZ3NbM107XG4gIHZhciBoZWlnaHQgPSB0ZXh0UmVjdC5oZWlnaHQgKyBwYWRkaW5nc1swXSArIHBhZGRpbmdzWzJdO1xuICAvLyBBZGp1c3QgYnkgYWxpZ24uXG4gIHZhciBhbGlnbiA9IGxhYmVsUG9zLmFsaWduO1xuICBhbGlnbiA9PT0gJ3JpZ2h0JyAmJiAocG9zaXRpb25bMF0gLT0gd2lkdGgpO1xuICBhbGlnbiA9PT0gJ2NlbnRlcicgJiYgKHBvc2l0aW9uWzBdIC09IHdpZHRoIC8gMik7XG4gIHZhciB2ZXJ0aWNhbEFsaWduID0gbGFiZWxQb3MudmVydGljYWxBbGlnbjtcbiAgdmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScgJiYgKHBvc2l0aW9uWzFdIC09IGhlaWdodCk7XG4gIHZlcnRpY2FsQWxpZ24gPT09ICdtaWRkbGUnICYmIChwb3NpdGlvblsxXSAtPSBoZWlnaHQgLyAyKTtcbiAgLy8gTm90IG92ZXJmbG93IGVjIGNvbnRhaW5lclxuICBjb25maW5lSW5Db250YWluZXIocG9zaXRpb24sIHdpZHRoLCBoZWlnaHQsIGFwaSk7XG4gIHZhciBiZ0NvbG9yID0gbGFiZWxNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuICBpZiAoIWJnQ29sb3IgfHwgYmdDb2xvciA9PT0gJ2F1dG8nKSB7XG4gICAgYmdDb2xvciA9IGF4aXNNb2RlbC5nZXQoWydheGlzTGluZScsICdsaW5lU3R5bGUnLCAnY29sb3InXSk7XG4gIH1cbiAgZWxPcHRpb24ubGFiZWwgPSB7XG4gICAgLy8gc2hhcGU6IHt4OiAwLCB5OiAwLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCByOiBsYWJlbE1vZGVsLmdldCgnYm9yZGVyUmFkaXVzJyl9LFxuICAgIHg6IHBvc2l0aW9uWzBdLFxuICAgIHk6IHBvc2l0aW9uWzFdLFxuICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUobGFiZWxNb2RlbCwge1xuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICBmaWxsOiBsYWJlbE1vZGVsLmdldFRleHRDb2xvcigpLFxuICAgICAgcGFkZGluZzogcGFkZGluZ3MsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJnQ29sb3JcbiAgICB9KSxcbiAgICAvLyBMYWJlbCBzaG91bGQgYmUgb3ZlciBheGlzUG9pbnRlci5cbiAgICB6MjogMTBcbiAgfTtcbn1cbi8vIERvIG5vdCBvdmVyZmxvdyBlYyBjb250YWluZXJcbmZ1bmN0aW9uIGNvbmZpbmVJbkNvbnRhaW5lcihwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCwgYXBpKSB7XG4gIHZhciB2aWV3V2lkdGggPSBhcGkuZ2V0V2lkdGgoKTtcbiAgdmFyIHZpZXdIZWlnaHQgPSBhcGkuZ2V0SGVpZ2h0KCk7XG4gIHBvc2l0aW9uWzBdID0gTWF0aC5taW4ocG9zaXRpb25bMF0gKyB3aWR0aCwgdmlld1dpZHRoKSAtIHdpZHRoO1xuICBwb3NpdGlvblsxXSA9IE1hdGgubWluKHBvc2l0aW9uWzFdICsgaGVpZ2h0LCB2aWV3SGVpZ2h0KSAtIGhlaWdodDtcbiAgcG9zaXRpb25bMF0gPSBNYXRoLm1heChwb3NpdGlvblswXSwgMCk7XG4gIHBvc2l0aW9uWzFdID0gTWF0aC5tYXgocG9zaXRpb25bMV0sIDApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlTGFiZWwodmFsdWUsIGF4aXMsIGVjTW9kZWwsIHNlcmllc0RhdGFJbmRpY2VzLCBvcHQpIHtcbiAgdmFsdWUgPSBheGlzLnNjYWxlLnBhcnNlKHZhbHVlKTtcbiAgdmFyIHRleHQgPSBheGlzLnNjYWxlLmdldExhYmVsKHtcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSwge1xuICAgIC8vIElmIGBwcmVjaXNpb25gIGlzIHNldCwgd2lkdGggY2FuIGJlIGZpeGVkIChsaWtlICcxMi4wMDUwMCcpLCB3aGljaFxuICAgIC8vIGhlbHBzIHRvIGRlYm91bmNlIHdoZW4gd2hlbiBtb3ZpbmcgbGFiZWwuXG4gICAgcHJlY2lzaW9uOiBvcHQucHJlY2lzaW9uXG4gIH0pO1xuICB2YXIgZm9ybWF0dGVyID0gb3B0LmZvcm1hdHRlcjtcbiAgaWYgKGZvcm1hdHRlcikge1xuICAgIHZhciBwYXJhbXNfMSA9IHtcbiAgICAgIHZhbHVlOiBheGlzSGVscGVyLmdldEF4aXNSYXdWYWx1ZShheGlzLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSksXG4gICAgICBheGlzRGltZW5zaW9uOiBheGlzLmRpbSxcbiAgICAgIGF4aXNJbmRleDogYXhpcy5pbmRleCxcbiAgICAgIHNlcmllc0RhdGE6IFtdXG4gICAgfTtcbiAgICB6clV0aWwuZWFjaChzZXJpZXNEYXRhSW5kaWNlcywgZnVuY3Rpb24gKGlkeEl0ZW0pIHtcbiAgICAgIHZhciBzZXJpZXMgPSBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoaWR4SXRlbS5zZXJpZXNJbmRleCk7XG4gICAgICB2YXIgZGF0YUluZGV4ID0gaWR4SXRlbS5kYXRhSW5kZXhJbnNpZGU7XG4gICAgICB2YXIgZGF0YVBhcmFtcyA9IHNlcmllcyAmJiBzZXJpZXMuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgpO1xuICAgICAgZGF0YVBhcmFtcyAmJiBwYXJhbXNfMS5zZXJpZXNEYXRhLnB1c2goZGF0YVBhcmFtcyk7XG4gICAgfSk7XG4gICAgaWYgKHpyVXRpbC5pc1N0cmluZyhmb3JtYXR0ZXIpKSB7XG4gICAgICB0ZXh0ID0gZm9ybWF0dGVyLnJlcGxhY2UoJ3t2YWx1ZX0nLCB0ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKGZvcm1hdHRlcikpIHtcbiAgICAgIHRleHQgPSBmb3JtYXR0ZXIocGFyYW1zXzEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1lZFBvc2l0aW9uKGF4aXMsIHZhbHVlLCBsYXlvdXRJbmZvKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSBtYXRyaXguY3JlYXRlKCk7XG4gIG1hdHJpeC5yb3RhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIGxheW91dEluZm8ucm90YXRpb24pO1xuICBtYXRyaXgudHJhbnNsYXRlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCBsYXlvdXRJbmZvLnBvc2l0aW9uKTtcbiAgcmV0dXJuIGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0oW2F4aXMuZGF0YVRvQ29vcmQodmFsdWUpLCAobGF5b3V0SW5mby5sYWJlbE9mZnNldCB8fCAwKSArIChsYXlvdXRJbmZvLmxhYmVsRGlyZWN0aW9uIHx8IDEpICogKGxheW91dEluZm8ubGFiZWxNYXJnaW4gfHwgMCldLCB0cmFuc2Zvcm0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQ2FydGVzaWFuU2luZ2xlTGFiZWxFbE9wdGlvbih2YWx1ZSwgZWxPcHRpb24sIGxheW91dEluZm8sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgdmFyIHRleHRMYXlvdXQgPSBBeGlzQnVpbGRlci5pbm5lclRleHRMYXlvdXQobGF5b3V0SW5mby5yb3RhdGlvbiwgMCwgbGF5b3V0SW5mby5sYWJlbERpcmVjdGlvbik7XG4gIGxheW91dEluZm8ubGFiZWxNYXJnaW4gPSBheGlzUG9pbnRlck1vZGVsLmdldChbJ2xhYmVsJywgJ21hcmdpbiddKTtcbiAgYnVpbGRMYWJlbEVsT3B0aW9uKGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSwge1xuICAgIHBvc2l0aW9uOiBnZXRUcmFuc2Zvcm1lZFBvc2l0aW9uKGF4aXNNb2RlbC5heGlzLCB2YWx1ZSwgbGF5b3V0SW5mbyksXG4gICAgYWxpZ246IHRleHRMYXlvdXQudGV4dEFsaWduLFxuICAgIHZlcnRpY2FsQWxpZ246IHRleHRMYXlvdXQudGV4dFZlcnRpY2FsQWxpZ25cbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZUxpbmVTaGFwZShwMSwgcDIsIHhEaW1JbmRleCkge1xuICB4RGltSW5kZXggPSB4RGltSW5kZXggfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB4MTogcDFbeERpbUluZGV4XSxcbiAgICB5MTogcDFbMSAtIHhEaW1JbmRleF0sXG4gICAgeDI6IHAyW3hEaW1JbmRleF0sXG4gICAgeTI6IHAyWzEgLSB4RGltSW5kZXhdXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlY3RTaGFwZSh4eSwgd2gsIHhEaW1JbmRleCkge1xuICB4RGltSW5kZXggPSB4RGltSW5kZXggfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB4OiB4eVt4RGltSW5kZXhdLFxuICAgIHk6IHh5WzEgLSB4RGltSW5kZXhdLFxuICAgIHdpZHRoOiB3aFt4RGltSW5kZXhdLFxuICAgIGhlaWdodDogd2hbMSAtIHhEaW1JbmRleF1cbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlU2VjdG9yU2hhcGUoY3gsIGN5LCByMCwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgcmV0dXJuIHtcbiAgICBjeDogY3gsXG4gICAgY3k6IGN5LFxuICAgIHIwOiByMCxcbiAgICByOiByLFxuICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGU6IGVuZEFuZ2xlLFxuICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3686\n")},13006:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98026);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43870);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43199);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(31571);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(25014);\n/* harmony import */ var _AxisBuilder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89598);\n/* harmony import */ var _AxisView_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(22480);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitLine', 'splitArea', 'minorSplitLine'];\nvar RadiusAxisView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(RadiusAxisView, _super);\n  function RadiusAxisView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = RadiusAxisView.type;\n    _this.axisPointerClass = 'PolarAxisPointer';\n    return _this;\n  }\n  RadiusAxisView.prototype.render = function (radiusAxisModel, ecModel) {\n    this.group.removeAll();\n    if (!radiusAxisModel.get('show')) {\n      return;\n    }\n    var oldAxisGroup = this._axisGroup;\n    var newAxisGroup = this._axisGroup = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A();\n    this.group.add(newAxisGroup);\n    var radiusAxis = radiusAxisModel.axis;\n    var polar = radiusAxis.polar;\n    var angleAxis = polar.getAngleAxis();\n    var ticksCoords = radiusAxis.getTicksCoords();\n    var minorTicksCoords = radiusAxis.getMinorTicksCoords();\n    var axisAngle = angleAxis.getExtent()[0];\n    var radiusExtent = radiusAxis.getExtent();\n    var layout = layoutAxis(polar, radiusAxisModel, axisAngle);\n    var axisBuilder = new _AxisBuilder_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A(radiusAxisModel, layout);\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n    newAxisGroup.add(axisBuilder.getGroup());\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__.groupTransition(oldAxisGroup, newAxisGroup, radiusAxisModel);\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.each(selfBuilderAttrs, function (name) {\n      if (radiusAxisModel.get([name, 'show']) && !radiusAxis.scale.isBlank()) {\n        axisElementBuilders[name](this.group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords);\n      }\n    }, this);\n  };\n  RadiusAxisView.type = 'radiusAxis';\n  return RadiusAxisView;\n}(_AxisView_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A);\nvar axisElementBuilders = {\n  splitLine: function (group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {\n    var splitLineModel = radiusAxisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineCount = 0;\n    var angleAxis = polar.getAngleAxis();\n    var RADIAN = Math.PI / 180;\n    var angleExtent = angleAxis.getExtent();\n    var shapeType = Math.abs(angleExtent[1] - angleExtent[0]) === 360 ? 'Circle' : 'Arc';\n    lineColors = lineColors instanceof Array ? lineColors : [lineColors];\n    var splitLines = [];\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var colorIndex = lineCount++ % lineColors.length;\n      splitLines[colorIndex] = splitLines[colorIndex] || [];\n      splitLines[colorIndex].push(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__[shapeType]({\n        shape: {\n          cx: polar.cx,\n          cy: polar.cy,\n          // ensure circle radius >= 0\n          r: Math.max(ticksCoords[i].coord, 0),\n          startAngle: -angleExtent[0] * RADIAN,\n          endAngle: -angleExtent[1] * RADIAN,\n          clockwise: angleAxis.inverse\n        }\n      }));\n    }\n    // Simple optimization\n    // Batching the lines if color are the same\n    for (var i = 0; i < splitLines.length; i++) {\n      group.add(_util_graphic_js__WEBPACK_IMPORTED_MODULE_4__.mergePath(splitLines[i], {\n        style: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.defaults({\n          stroke: lineColors[i % lineColors.length],\n          fill: null\n        }, lineStyleModel.getLineStyle()),\n        silent: true\n      }));\n    }\n  },\n  minorSplitLine: function (group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {\n    if (!minorTicksCoords.length) {\n      return;\n    }\n    var minorSplitLineModel = radiusAxisModel.getModel('minorSplitLine');\n    var lineStyleModel = minorSplitLineModel.getModel('lineStyle');\n    var lines = [];\n    for (var i = 0; i < minorTicksCoords.length; i++) {\n      for (var k = 0; k < minorTicksCoords[i].length; k++) {\n        lines.push(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A({\n          shape: {\n            cx: polar.cx,\n            cy: polar.cy,\n            r: minorTicksCoords[i][k].coord\n          }\n        }));\n      }\n    }\n    group.add(_util_graphic_js__WEBPACK_IMPORTED_MODULE_4__.mergePath(lines, {\n      style: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.defaults({\n        fill: null\n      }, lineStyleModel.getLineStyle()),\n      silent: true\n    }));\n  },\n  splitArea: function (group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {\n    if (!ticksCoords.length) {\n      return;\n    }\n    var splitAreaModel = radiusAxisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var lineCount = 0;\n    areaColors = areaColors instanceof Array ? areaColors : [areaColors];\n    var splitAreas = [];\n    var prevRadius = ticksCoords[0].coord;\n    for (var i = 1; i < ticksCoords.length; i++) {\n      var colorIndex = lineCount++ % areaColors.length;\n      splitAreas[colorIndex] = splitAreas[colorIndex] || [];\n      splitAreas[colorIndex].push(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .A({\n        shape: {\n          cx: polar.cx,\n          cy: polar.cy,\n          r0: prevRadius,\n          r: ticksCoords[i].coord,\n          startAngle: 0,\n          endAngle: Math.PI * 2\n        },\n        silent: true\n      }));\n      prevRadius = ticksCoords[i].coord;\n    }\n    // Simple optimization\n    // Batching the lines if color are the same\n    for (var i = 0; i < splitAreas.length; i++) {\n      group.add(_util_graphic_js__WEBPACK_IMPORTED_MODULE_4__.mergePath(splitAreas[i], {\n        style: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.defaults({\n          fill: areaColors[i % areaColors.length]\n        }, areaStyleModel.getAreaStyle()),\n        silent: true\n      }));\n    }\n  }\n};\n/**\r\n * @inner\r\n */\nfunction layoutAxis(polar, radiusAxisModel, axisAngle) {\n  return {\n    position: [polar.cx, polar.cy],\n    rotation: axisAngle / 180 * Math.PI,\n    labelDirection: -1,\n    tickDirection: -1,\n    nameDirection: 1,\n    labelRotate: radiusAxisModel.getModel('axisLabel').get('rotate'),\n    // Over splitLine and splitArea\n    z2: 1\n  };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadiusAxisView);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMwMDYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL1JhZGl1c0F4aXNWaWV3LmpzP2QwNDEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IEF4aXNCdWlsZGVyIGZyb20gJy4vQXhpc0J1aWxkZXIuanMnO1xuaW1wb3J0IEF4aXNWaWV3IGZyb20gJy4vQXhpc1ZpZXcuanMnO1xudmFyIGF4aXNCdWlsZGVyQXR0cnMgPSBbJ2F4aXNMaW5lJywgJ2F4aXNUaWNrTGFiZWwnLCAnYXhpc05hbWUnXTtcbnZhciBzZWxmQnVpbGRlckF0dHJzID0gWydzcGxpdExpbmUnLCAnc3BsaXRBcmVhJywgJ21pbm9yU3BsaXRMaW5lJ107XG52YXIgUmFkaXVzQXhpc1ZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUmFkaXVzQXhpc1ZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFJhZGl1c0F4aXNWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBSYWRpdXNBeGlzVmlldy50eXBlO1xuICAgIF90aGlzLmF4aXNQb2ludGVyQ2xhc3MgPSAnUG9sYXJBeGlzUG9pbnRlcic7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFJhZGl1c0F4aXNWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocmFkaXVzQXhpc01vZGVsLCBlY01vZGVsKSB7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICBpZiAoIXJhZGl1c0F4aXNNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb2xkQXhpc0dyb3VwID0gdGhpcy5fYXhpc0dyb3VwO1xuICAgIHZhciBuZXdBeGlzR3JvdXAgPSB0aGlzLl9heGlzR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKG5ld0F4aXNHcm91cCk7XG4gICAgdmFyIHJhZGl1c0F4aXMgPSByYWRpdXNBeGlzTW9kZWwuYXhpcztcbiAgICB2YXIgcG9sYXIgPSByYWRpdXNBeGlzLnBvbGFyO1xuICAgIHZhciBhbmdsZUF4aXMgPSBwb2xhci5nZXRBbmdsZUF4aXMoKTtcbiAgICB2YXIgdGlja3NDb29yZHMgPSByYWRpdXNBeGlzLmdldFRpY2tzQ29vcmRzKCk7XG4gICAgdmFyIG1pbm9yVGlja3NDb29yZHMgPSByYWRpdXNBeGlzLmdldE1pbm9yVGlja3NDb29yZHMoKTtcbiAgICB2YXIgYXhpc0FuZ2xlID0gYW5nbGVBeGlzLmdldEV4dGVudCgpWzBdO1xuICAgIHZhciByYWRpdXNFeHRlbnQgPSByYWRpdXNBeGlzLmdldEV4dGVudCgpO1xuICAgIHZhciBsYXlvdXQgPSBsYXlvdXRBeGlzKHBvbGFyLCByYWRpdXNBeGlzTW9kZWwsIGF4aXNBbmdsZSk7XG4gICAgdmFyIGF4aXNCdWlsZGVyID0gbmV3IEF4aXNCdWlsZGVyKHJhZGl1c0F4aXNNb2RlbCwgbGF5b3V0KTtcbiAgICB6clV0aWwuZWFjaChheGlzQnVpbGRlckF0dHJzLCBheGlzQnVpbGRlci5hZGQsIGF4aXNCdWlsZGVyKTtcbiAgICBuZXdBeGlzR3JvdXAuYWRkKGF4aXNCdWlsZGVyLmdldEdyb3VwKCkpO1xuICAgIGdyYXBoaWMuZ3JvdXBUcmFuc2l0aW9uKG9sZEF4aXNHcm91cCwgbmV3QXhpc0dyb3VwLCByYWRpdXNBeGlzTW9kZWwpO1xuICAgIHpyVXRpbC5lYWNoKHNlbGZCdWlsZGVyQXR0cnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAocmFkaXVzQXhpc01vZGVsLmdldChbbmFtZSwgJ3Nob3cnXSkgJiYgIXJhZGl1c0F4aXMuc2NhbGUuaXNCbGFuaygpKSB7XG4gICAgICAgIGF4aXNFbGVtZW50QnVpbGRlcnNbbmFtZV0odGhpcy5ncm91cCwgcmFkaXVzQXhpc01vZGVsLCBwb2xhciwgYXhpc0FuZ2xlLCByYWRpdXNFeHRlbnQsIHRpY2tzQ29vcmRzLCBtaW5vclRpY2tzQ29vcmRzKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgUmFkaXVzQXhpc1ZpZXcudHlwZSA9ICdyYWRpdXNBeGlzJztcbiAgcmV0dXJuIFJhZGl1c0F4aXNWaWV3O1xufShBeGlzVmlldyk7XG52YXIgYXhpc0VsZW1lbnRCdWlsZGVycyA9IHtcbiAgc3BsaXRMaW5lOiBmdW5jdGlvbiAoZ3JvdXAsIHJhZGl1c0F4aXNNb2RlbCwgcG9sYXIsIGF4aXNBbmdsZSwgcmFkaXVzRXh0ZW50LCB0aWNrc0Nvb3Jkcykge1xuICAgIHZhciBzcGxpdExpbmVNb2RlbCA9IHJhZGl1c0F4aXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRMaW5lJyk7XG4gICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gc3BsaXRMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgIHZhciBsaW5lQ29sb3JzID0gbGluZVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICAgIHZhciBsaW5lQ291bnQgPSAwO1xuICAgIHZhciBhbmdsZUF4aXMgPSBwb2xhci5nZXRBbmdsZUF4aXMoKTtcbiAgICB2YXIgUkFESUFOID0gTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgYW5nbGVFeHRlbnQgPSBhbmdsZUF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIHNoYXBlVHlwZSA9IE1hdGguYWJzKGFuZ2xlRXh0ZW50WzFdIC0gYW5nbGVFeHRlbnRbMF0pID09PSAzNjAgPyAnQ2lyY2xlJyA6ICdBcmMnO1xuICAgIGxpbmVDb2xvcnMgPSBsaW5lQ29sb3JzIGluc3RhbmNlb2YgQXJyYXkgPyBsaW5lQ29sb3JzIDogW2xpbmVDb2xvcnNdO1xuICAgIHZhciBzcGxpdExpbmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvbG9ySW5kZXggPSBsaW5lQ291bnQrKyAlIGxpbmVDb2xvcnMubGVuZ3RoO1xuICAgICAgc3BsaXRMaW5lc1tjb2xvckluZGV4XSA9IHNwbGl0TGluZXNbY29sb3JJbmRleF0gfHwgW107XG4gICAgICBzcGxpdExpbmVzW2NvbG9ySW5kZXhdLnB1c2gobmV3IGdyYXBoaWNbc2hhcGVUeXBlXSh7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgY3g6IHBvbGFyLmN4LFxuICAgICAgICAgIGN5OiBwb2xhci5jeSxcbiAgICAgICAgICAvLyBlbnN1cmUgY2lyY2xlIHJhZGl1cyA+PSAwXG4gICAgICAgICAgcjogTWF0aC5tYXgodGlja3NDb29yZHNbaV0uY29vcmQsIDApLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IC1hbmdsZUV4dGVudFswXSAqIFJBRElBTixcbiAgICAgICAgICBlbmRBbmdsZTogLWFuZ2xlRXh0ZW50WzFdICogUkFESUFOLFxuICAgICAgICAgIGNsb2Nrd2lzZTogYW5nbGVBeGlzLmludmVyc2VcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG4gICAgLy8gQmF0Y2hpbmcgdGhlIGxpbmVzIGlmIGNvbG9yIGFyZSB0aGUgc2FtZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ3JvdXAuYWRkKGdyYXBoaWMubWVyZ2VQYXRoKHNwbGl0TGluZXNbaV0sIHtcbiAgICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgc3Ryb2tlOiBsaW5lQ29sb3JzW2kgJSBsaW5lQ29sb3JzLmxlbmd0aF0sXG4gICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LCBsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKSksXG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSxcbiAgbWlub3JTcGxpdExpbmU6IGZ1bmN0aW9uIChncm91cCwgcmFkaXVzQXhpc01vZGVsLCBwb2xhciwgYXhpc0FuZ2xlLCByYWRpdXNFeHRlbnQsIHRpY2tzQ29vcmRzLCBtaW5vclRpY2tzQ29vcmRzKSB7XG4gICAgaWYgKCFtaW5vclRpY2tzQ29vcmRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbWlub3JTcGxpdExpbmVNb2RlbCA9IHJhZGl1c0F4aXNNb2RlbC5nZXRNb2RlbCgnbWlub3JTcGxpdExpbmUnKTtcbiAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSBtaW5vclNwbGl0TGluZU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbm9yVGlja3NDb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbWlub3JUaWNrc0Nvb3Jkc1tpXS5sZW5ndGg7IGsrKykge1xuICAgICAgICBsaW5lcy5wdXNoKG5ldyBncmFwaGljLkNpcmNsZSh7XG4gICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIGN4OiBwb2xhci5jeCxcbiAgICAgICAgICAgIGN5OiBwb2xhci5jeSxcbiAgICAgICAgICAgIHI6IG1pbm9yVGlja3NDb29yZHNbaV1ba10uY29vcmRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ3JvdXAuYWRkKGdyYXBoaWMubWVyZ2VQYXRoKGxpbmVzLCB7XG4gICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgZmlsbDogbnVsbFxuICAgICAgfSwgbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCkpLFxuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSkpO1xuICB9LFxuICBzcGxpdEFyZWE6IGZ1bmN0aW9uIChncm91cCwgcmFkaXVzQXhpc01vZGVsLCBwb2xhciwgYXhpc0FuZ2xlLCByYWRpdXNFeHRlbnQsIHRpY2tzQ29vcmRzKSB7XG4gICAgaWYgKCF0aWNrc0Nvb3Jkcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNwbGl0QXJlYU1vZGVsID0gcmFkaXVzQXhpc01vZGVsLmdldE1vZGVsKCdzcGxpdEFyZWEnKTtcbiAgICB2YXIgYXJlYVN0eWxlTW9kZWwgPSBzcGxpdEFyZWFNb2RlbC5nZXRNb2RlbCgnYXJlYVN0eWxlJyk7XG4gICAgdmFyIGFyZWFDb2xvcnMgPSBhcmVhU3R5bGVNb2RlbC5nZXQoJ2NvbG9yJyk7XG4gICAgdmFyIGxpbmVDb3VudCA9IDA7XG4gICAgYXJlYUNvbG9ycyA9IGFyZWFDb2xvcnMgaW5zdGFuY2VvZiBBcnJheSA/IGFyZWFDb2xvcnMgOiBbYXJlYUNvbG9yc107XG4gICAgdmFyIHNwbGl0QXJlYXMgPSBbXTtcbiAgICB2YXIgcHJldlJhZGl1cyA9IHRpY2tzQ29vcmRzWzBdLmNvb3JkO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGlja3NDb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb2xvckluZGV4ID0gbGluZUNvdW50KysgJSBhcmVhQ29sb3JzLmxlbmd0aDtcbiAgICAgIHNwbGl0QXJlYXNbY29sb3JJbmRleF0gPSBzcGxpdEFyZWFzW2NvbG9ySW5kZXhdIHx8IFtdO1xuICAgICAgc3BsaXRBcmVhc1tjb2xvckluZGV4XS5wdXNoKG5ldyBncmFwaGljLlNlY3Rvcih7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgY3g6IHBvbGFyLmN4LFxuICAgICAgICAgIGN5OiBwb2xhci5jeSxcbiAgICAgICAgICByMDogcHJldlJhZGl1cyxcbiAgICAgICAgICByOiB0aWNrc0Nvb3Jkc1tpXS5jb29yZCxcbiAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxuICAgICAgICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMlxuICAgICAgICB9LFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICAgIHByZXZSYWRpdXMgPSB0aWNrc0Nvb3Jkc1tpXS5jb29yZDtcbiAgICB9XG4gICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxuICAgIC8vIEJhdGNoaW5nIHRoZSBsaW5lcyBpZiBjb2xvciBhcmUgdGhlIHNhbWVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0QXJlYXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdyb3VwLmFkZChncmFwaGljLm1lcmdlUGF0aChzcGxpdEFyZWFzW2ldLCB7XG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIGZpbGw6IGFyZWFDb2xvcnNbaSAlIGFyZWFDb2xvcnMubGVuZ3RoXVxuICAgICAgICB9LCBhcmVhU3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKSksXG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxufTtcbi8qKlxyXG4gKiBAaW5uZXJcclxuICovXG5mdW5jdGlvbiBsYXlvdXRBeGlzKHBvbGFyLCByYWRpdXNBeGlzTW9kZWwsIGF4aXNBbmdsZSkge1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBbcG9sYXIuY3gsIHBvbGFyLmN5XSxcbiAgICByb3RhdGlvbjogYXhpc0FuZ2xlIC8gMTgwICogTWF0aC5QSSxcbiAgICBsYWJlbERpcmVjdGlvbjogLTEsXG4gICAgdGlja0RpcmVjdGlvbjogLTEsXG4gICAgbmFtZURpcmVjdGlvbjogMSxcbiAgICBsYWJlbFJvdGF0ZTogcmFkaXVzQXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKS5nZXQoJ3JvdGF0ZScpLFxuICAgIC8vIE92ZXIgc3BsaXRMaW5lIGFuZCBzcGxpdEFyZWFcbiAgICB6MjogMVxuICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgUmFkaXVzQXhpc1ZpZXc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13006\n")},22480:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _axisPointer_modelHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49890);\n/* harmony import */ var _view_Component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(59109);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar axisPointerClazz = {};\n/**\r\n * Base class of AxisView.\r\n */\nvar AxisView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(AxisView, _super);\n  function AxisView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = AxisView.type;\n    return _this;\n  }\n  /**\r\n   * @override\r\n   */\n  AxisView.prototype.render = function (axisModel, ecModel, api, payload) {\n    // FIXME\n    // This process should proformed after coordinate systems updated\n    // (axis scale updated), and should be performed each time update.\n    // So put it here temporarily, although it is not appropriate to\n    // put a model-writing procedure in `view`.\n    this.axisPointerClass && _axisPointer_modelHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .fixValue */ .h_(axisModel);\n    _super.prototype.render.apply(this, arguments);\n    this._doUpdateAxisPointerClass(axisModel, api, true);\n  };\n  /**\r\n   * Action handler.\r\n   */\n  AxisView.prototype.updateAxisPointer = function (axisModel, ecModel, api, payload) {\n    this._doUpdateAxisPointerClass(axisModel, api, false);\n  };\n  /**\r\n   * @override\r\n   */\n  AxisView.prototype.remove = function (ecModel, api) {\n    var axisPointer = this._axisPointer;\n    axisPointer && axisPointer.remove(api);\n  };\n  /**\r\n   * @override\r\n   */\n  AxisView.prototype.dispose = function (ecModel, api) {\n    this._disposeAxisPointer(api);\n    _super.prototype.dispose.apply(this, arguments);\n  };\n  AxisView.prototype._doUpdateAxisPointerClass = function (axisModel, api, forceRender) {\n    var Clazz = AxisView.getAxisPointerClass(this.axisPointerClass);\n    if (!Clazz) {\n      return;\n    }\n    var axisPointerModel = _axisPointer_modelHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .getAxisPointerModel */ .mg(axisModel);\n    axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api);\n  };\n  AxisView.prototype._disposeAxisPointer = function (api) {\n    this._axisPointer && this._axisPointer.dispose(api);\n    this._axisPointer = null;\n  };\n  AxisView.registerAxisPointerClass = function (type, clazz) {\n    if (false) {}\n    axisPointerClazz[type] = clazz;\n  };\n  ;\n  AxisView.getAxisPointerClass = function (type) {\n    return type && axisPointerClazz[type];\n  };\n  ;\n  AxisView.type = \'axis\';\n  return AxisView;\n}(_view_Component_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxisView);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI0ODAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQXhpc1ZpZXcuanM/M2Y4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgYXhpc1BvaW50ZXJNb2RlbEhlbHBlciBmcm9tICcuLi9heGlzUG9pbnRlci9tb2RlbEhlbHBlci5qcyc7XG5pbXBvcnQgQ29tcG9uZW50VmlldyBmcm9tICcuLi8uLi92aWV3L0NvbXBvbmVudC5qcyc7XG52YXIgYXhpc1BvaW50ZXJDbGF6eiA9IHt9O1xuLyoqXHJcbiAqIEJhc2UgY2xhc3Mgb2YgQXhpc1ZpZXcuXHJcbiAqL1xudmFyIEF4aXNWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEF4aXNWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBBeGlzVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gQXhpc1ZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXG4gIEF4aXNWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAvLyBGSVhNRVxuICAgIC8vIFRoaXMgcHJvY2VzcyBzaG91bGQgcHJvZm9ybWVkIGFmdGVyIGNvb3JkaW5hdGUgc3lzdGVtcyB1cGRhdGVkXG4gICAgLy8gKGF4aXMgc2NhbGUgdXBkYXRlZCksIGFuZCBzaG91bGQgYmUgcGVyZm9ybWVkIGVhY2ggdGltZSB1cGRhdGUuXG4gICAgLy8gU28gcHV0IGl0IGhlcmUgdGVtcG9yYXJpbHksIGFsdGhvdWdoIGl0IGlzIG5vdCBhcHByb3ByaWF0ZSB0b1xuICAgIC8vIHB1dCBhIG1vZGVsLXdyaXRpbmcgcHJvY2VkdXJlIGluIGB2aWV3YC5cbiAgICB0aGlzLmF4aXNQb2ludGVyQ2xhc3MgJiYgYXhpc1BvaW50ZXJNb2RlbEhlbHBlci5maXhWYWx1ZShheGlzTW9kZWwpO1xuICAgIF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fZG9VcGRhdGVBeGlzUG9pbnRlckNsYXNzKGF4aXNNb2RlbCwgYXBpLCB0cnVlKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQWN0aW9uIGhhbmRsZXIuXHJcbiAgICovXG4gIEF4aXNWaWV3LnByb3RvdHlwZS51cGRhdGVBeGlzUG9pbnRlciA9IGZ1bmN0aW9uIChheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMuX2RvVXBkYXRlQXhpc1BvaW50ZXJDbGFzcyhheGlzTW9kZWwsIGFwaSwgZmFsc2UpO1xuICB9O1xuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgQXhpc1ZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgYXhpc1BvaW50ZXIgPSB0aGlzLl9heGlzUG9pbnRlcjtcbiAgICBheGlzUG9pbnRlciAmJiBheGlzUG9pbnRlci5yZW1vdmUoYXBpKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXG4gIEF4aXNWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuX2Rpc3Bvc2VBeGlzUG9pbnRlcihhcGkpO1xuICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBBeGlzVmlldy5wcm90b3R5cGUuX2RvVXBkYXRlQXhpc1BvaW50ZXJDbGFzcyA9IGZ1bmN0aW9uIChheGlzTW9kZWwsIGFwaSwgZm9yY2VSZW5kZXIpIHtcbiAgICB2YXIgQ2xhenogPSBBeGlzVmlldy5nZXRBeGlzUG9pbnRlckNsYXNzKHRoaXMuYXhpc1BvaW50ZXJDbGFzcyk7XG4gICAgaWYgKCFDbGF6eikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWxIZWxwZXIuZ2V0QXhpc1BvaW50ZXJNb2RlbChheGlzTW9kZWwpO1xuICAgIGF4aXNQb2ludGVyTW9kZWwgPyAodGhpcy5fYXhpc1BvaW50ZXIgfHwgKHRoaXMuX2F4aXNQb2ludGVyID0gbmV3IENsYXp6KCkpKS5yZW5kZXIoYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGksIGZvcmNlUmVuZGVyKSA6IHRoaXMuX2Rpc3Bvc2VBeGlzUG9pbnRlcihhcGkpO1xuICB9O1xuICBBeGlzVmlldy5wcm90b3R5cGUuX2Rpc3Bvc2VBeGlzUG9pbnRlciA9IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB0aGlzLl9heGlzUG9pbnRlciAmJiB0aGlzLl9heGlzUG9pbnRlci5kaXNwb3NlKGFwaSk7XG4gICAgdGhpcy5fYXhpc1BvaW50ZXIgPSBudWxsO1xuICB9O1xuICBBeGlzVmlldy5yZWdpc3RlckF4aXNQb2ludGVyQ2xhc3MgPSBmdW5jdGlvbiAodHlwZSwgY2xhenopIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGF4aXNQb2ludGVyQ2xhenpbdHlwZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdheGlzUG9pbnRlciAnICsgdHlwZSArICcgZXhpc3RzJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGF4aXNQb2ludGVyQ2xhenpbdHlwZV0gPSBjbGF6ejtcbiAgfTtcbiAgO1xuICBBeGlzVmlldy5nZXRBeGlzUG9pbnRlckNsYXNzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSAmJiBheGlzUG9pbnRlckNsYXp6W3R5cGVdO1xuICB9O1xuICA7XG4gIEF4aXNWaWV3LnR5cGUgPSAnYXhpcyc7XG4gIHJldHVybiBBeGlzVmlldztcbn0oQ29tcG9uZW50Vmlldyk7XG5leHBvcnQgZGVmYXVsdCBBeGlzVmlldzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22480\n')},23953:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _BaseAxisPointer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53226);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43199);\n/* harmony import */ var _viewHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3686);\n/* harmony import */ var zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45587);\n/* harmony import */ var _axis_AxisBuilder_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(89598);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\nvar PolarAxisPointer = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(PolarAxisPointer, _super);\n  function PolarAxisPointer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * @override\r\n   */\n  PolarAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {\n    var axis = axisModel.axis;\n    if (axis.dim === 'angle') {\n      this.animationThreshold = Math.PI / 18;\n    }\n    var polar = axis.polar;\n    var otherAxis = polar.getOtherAxis(axis);\n    var otherExtent = otherAxis.getExtent();\n    var coordValue = axis.dataToCoord(value);\n    var axisPointerType = axisPointerModel.get('type');\n    if (axisPointerType && axisPointerType !== 'none') {\n      var elStyle = _viewHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .buildElStyle */ .bY(axisPointerModel);\n      var pointerOption = pointerShapeBuilder[axisPointerType](axis, polar, coordValue, otherExtent);\n      pointerOption.style = elStyle;\n      elOption.graphicKey = pointerOption.type;\n      elOption.pointer = pointerOption;\n    }\n    var labelMargin = axisPointerModel.get(['label', 'margin']);\n    var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin);\n    _viewHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .buildLabelElOption */ .T8(elOption, axisModel, axisPointerModel, api, labelPos);\n  };\n  return PolarAxisPointer;\n}(_BaseAxisPointer_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A);\n;\nfunction getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {\n  var axis = axisModel.axis;\n  var coord = axis.dataToCoord(value);\n  var axisAngle = polar.getAngleAxis().getExtent()[0];\n  axisAngle = axisAngle / 180 * Math.PI;\n  var radiusExtent = polar.getRadiusAxis().getExtent();\n  var position;\n  var align;\n  var verticalAlign;\n  if (axis.dim === 'radius') {\n    var transform = zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_3__.create();\n    zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_3__.rotate(transform, transform, axisAngle);\n    zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_3__.translate(transform, transform, [polar.cx, polar.cy]);\n    position = _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__.applyTransform([coord, -labelMargin], transform);\n    var labelRotation = axisModel.getModel('axisLabel').get('rotate') || 0;\n    // @ts-ignore\n    var labelLayout = _axis_AxisBuilder_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);\n    align = labelLayout.textAlign;\n    verticalAlign = labelLayout.textVerticalAlign;\n  } else {\n    // angle axis\n    var r = radiusExtent[1];\n    position = polar.coordToPoint([r + labelMargin, coord]);\n    var cx = polar.cx;\n    var cy = polar.cy;\n    align = Math.abs(position[0] - cx) / r < 0.3 ? 'center' : position[0] > cx ? 'left' : 'right';\n    verticalAlign = Math.abs(position[1] - cy) / r < 0.3 ? 'middle' : position[1] > cy ? 'top' : 'bottom';\n  }\n  return {\n    position: position,\n    align: align,\n    verticalAlign: verticalAlign\n  };\n}\nvar pointerShapeBuilder = {\n  line: function (axis, polar, coordValue, otherExtent) {\n    return axis.dim === 'angle' ? {\n      type: 'Line',\n      shape: _viewHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .makeLineShape */ .MU(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))\n    } : {\n      type: 'Circle',\n      shape: {\n        cx: polar.cx,\n        cy: polar.cy,\n        r: coordValue\n      }\n    };\n  },\n  shadow: function (axis, polar, coordValue, otherExtent) {\n    var bandWidth = Math.max(1, axis.getBandWidth());\n    var radian = Math.PI / 180;\n    return axis.dim === 'angle' ? {\n      type: 'Sector',\n      shape: _viewHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .makeSectorShape */ .u7(polar.cx, polar.cy, otherExtent[0], otherExtent[1],\n      // In ECharts y is negative if angle is positive\n      (-coordValue - bandWidth / 2) * radian, (-coordValue + bandWidth / 2) * radian)\n    } : {\n      type: 'Sector',\n      shape: _viewHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .makeSectorShape */ .u7(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)\n    };\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PolarAxisPointer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM5NTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9Qb2xhckF4aXNQb2ludGVyLmpzPzA0YjkiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBCYXNlQXhpc1BvaW50ZXIgZnJvbSAnLi9CYXNlQXhpc1BvaW50ZXIuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0ICogYXMgdmlld0hlbHBlciBmcm9tICcuL3ZpZXdIZWxwZXIuanMnO1xuaW1wb3J0ICogYXMgbWF0cml4IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzJztcbmltcG9ydCBBeGlzQnVpbGRlciBmcm9tICcuLi9heGlzL0F4aXNCdWlsZGVyLmpzJztcbnZhciBQb2xhckF4aXNQb2ludGVyID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBvbGFyQXhpc1BvaW50ZXIsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFBvbGFyQXhpc1BvaW50ZXIoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBQb2xhckF4aXNQb2ludGVyLnByb3RvdHlwZS5tYWtlRWxPcHRpb24gPSBmdW5jdGlvbiAoZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSkge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgaWYgKGF4aXMuZGltID09PSAnYW5nbGUnKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblRocmVzaG9sZCA9IE1hdGguUEkgLyAxODtcbiAgICB9XG4gICAgdmFyIHBvbGFyID0gYXhpcy5wb2xhcjtcbiAgICB2YXIgb3RoZXJBeGlzID0gcG9sYXIuZ2V0T3RoZXJBeGlzKGF4aXMpO1xuICAgIHZhciBvdGhlckV4dGVudCA9IG90aGVyQXhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgY29vcmRWYWx1ZSA9IGF4aXMuZGF0YVRvQ29vcmQodmFsdWUpO1xuICAgIHZhciBheGlzUG9pbnRlclR5cGUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndHlwZScpO1xuICAgIGlmIChheGlzUG9pbnRlclR5cGUgJiYgYXhpc1BvaW50ZXJUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgIHZhciBlbFN0eWxlID0gdmlld0hlbHBlci5idWlsZEVsU3R5bGUoYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICB2YXIgcG9pbnRlck9wdGlvbiA9IHBvaW50ZXJTaGFwZUJ1aWxkZXJbYXhpc1BvaW50ZXJUeXBlXShheGlzLCBwb2xhciwgY29vcmRWYWx1ZSwgb3RoZXJFeHRlbnQpO1xuICAgICAgcG9pbnRlck9wdGlvbi5zdHlsZSA9IGVsU3R5bGU7XG4gICAgICBlbE9wdGlvbi5ncmFwaGljS2V5ID0gcG9pbnRlck9wdGlvbi50eXBlO1xuICAgICAgZWxPcHRpb24ucG9pbnRlciA9IHBvaW50ZXJPcHRpb247XG4gICAgfVxuICAgIHZhciBsYWJlbE1hcmdpbiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KFsnbGFiZWwnLCAnbWFyZ2luJ10pO1xuICAgIHZhciBsYWJlbFBvcyA9IGdldExhYmVsUG9zaXRpb24odmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgcG9sYXIsIGxhYmVsTWFyZ2luKTtcbiAgICB2aWV3SGVscGVyLmJ1aWxkTGFiZWxFbE9wdGlvbihlbE9wdGlvbiwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGksIGxhYmVsUG9zKTtcbiAgfTtcbiAgcmV0dXJuIFBvbGFyQXhpc1BvaW50ZXI7XG59KEJhc2VBeGlzUG9pbnRlcik7XG47XG5mdW5jdGlvbiBnZXRMYWJlbFBvc2l0aW9uKHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIHBvbGFyLCBsYWJlbE1hcmdpbikge1xuICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICB2YXIgY29vcmQgPSBheGlzLmRhdGFUb0Nvb3JkKHZhbHVlKTtcbiAgdmFyIGF4aXNBbmdsZSA9IHBvbGFyLmdldEFuZ2xlQXhpcygpLmdldEV4dGVudCgpWzBdO1xuICBheGlzQW5nbGUgPSBheGlzQW5nbGUgLyAxODAgKiBNYXRoLlBJO1xuICB2YXIgcmFkaXVzRXh0ZW50ID0gcG9sYXIuZ2V0UmFkaXVzQXhpcygpLmdldEV4dGVudCgpO1xuICB2YXIgcG9zaXRpb247XG4gIHZhciBhbGlnbjtcbiAgdmFyIHZlcnRpY2FsQWxpZ247XG4gIGlmIChheGlzLmRpbSA9PT0gJ3JhZGl1cycpIHtcbiAgICB2YXIgdHJhbnNmb3JtID0gbWF0cml4LmNyZWF0ZSgpO1xuICAgIG1hdHJpeC5yb3RhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIGF4aXNBbmdsZSk7XG4gICAgbWF0cml4LnRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybSwgW3BvbGFyLmN4LCBwb2xhci5jeV0pO1xuICAgIHBvc2l0aW9uID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybShbY29vcmQsIC1sYWJlbE1hcmdpbl0sIHRyYW5zZm9ybSk7XG4gICAgdmFyIGxhYmVsUm90YXRpb24gPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNMYWJlbCcpLmdldCgncm90YXRlJykgfHwgMDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFyIGxhYmVsTGF5b3V0ID0gQXhpc0J1aWxkZXIuaW5uZXJUZXh0TGF5b3V0KGF4aXNBbmdsZSwgbGFiZWxSb3RhdGlvbiAqIE1hdGguUEkgLyAxODAsIC0xKTtcbiAgICBhbGlnbiA9IGxhYmVsTGF5b3V0LnRleHRBbGlnbjtcbiAgICB2ZXJ0aWNhbEFsaWduID0gbGFiZWxMYXlvdXQudGV4dFZlcnRpY2FsQWxpZ247XG4gIH0gZWxzZSB7XG4gICAgLy8gYW5nbGUgYXhpc1xuICAgIHZhciByID0gcmFkaXVzRXh0ZW50WzFdO1xuICAgIHBvc2l0aW9uID0gcG9sYXIuY29vcmRUb1BvaW50KFtyICsgbGFiZWxNYXJnaW4sIGNvb3JkXSk7XG4gICAgdmFyIGN4ID0gcG9sYXIuY3g7XG4gICAgdmFyIGN5ID0gcG9sYXIuY3k7XG4gICAgYWxpZ24gPSBNYXRoLmFicyhwb3NpdGlvblswXSAtIGN4KSAvIHIgPCAwLjMgPyAnY2VudGVyJyA6IHBvc2l0aW9uWzBdID4gY3ggPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIHZlcnRpY2FsQWxpZ24gPSBNYXRoLmFicyhwb3NpdGlvblsxXSAtIGN5KSAvIHIgPCAwLjMgPyAnbWlkZGxlJyA6IHBvc2l0aW9uWzFdID4gY3kgPyAndG9wJyA6ICdib3R0b20nO1xuICB9XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgIGFsaWduOiBhbGlnbixcbiAgICB2ZXJ0aWNhbEFsaWduOiB2ZXJ0aWNhbEFsaWduXG4gIH07XG59XG52YXIgcG9pbnRlclNoYXBlQnVpbGRlciA9IHtcbiAgbGluZTogZnVuY3Rpb24gKGF4aXMsIHBvbGFyLCBjb29yZFZhbHVlLCBvdGhlckV4dGVudCkge1xuICAgIHJldHVybiBheGlzLmRpbSA9PT0gJ2FuZ2xlJyA/IHtcbiAgICAgIHR5cGU6ICdMaW5lJyxcbiAgICAgIHNoYXBlOiB2aWV3SGVscGVyLm1ha2VMaW5lU2hhcGUocG9sYXIuY29vcmRUb1BvaW50KFtvdGhlckV4dGVudFswXSwgY29vcmRWYWx1ZV0pLCBwb2xhci5jb29yZFRvUG9pbnQoW290aGVyRXh0ZW50WzFdLCBjb29yZFZhbHVlXSkpXG4gICAgfSA6IHtcbiAgICAgIHR5cGU6ICdDaXJjbGUnLFxuICAgICAgc2hhcGU6IHtcbiAgICAgICAgY3g6IHBvbGFyLmN4LFxuICAgICAgICBjeTogcG9sYXIuY3ksXG4gICAgICAgIHI6IGNvb3JkVmFsdWVcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBzaGFkb3c6IGZ1bmN0aW9uIChheGlzLCBwb2xhciwgY29vcmRWYWx1ZSwgb3RoZXJFeHRlbnQpIHtcbiAgICB2YXIgYmFuZFdpZHRoID0gTWF0aC5tYXgoMSwgYXhpcy5nZXRCYW5kV2lkdGgoKSk7XG4gICAgdmFyIHJhZGlhbiA9IE1hdGguUEkgLyAxODA7XG4gICAgcmV0dXJuIGF4aXMuZGltID09PSAnYW5nbGUnID8ge1xuICAgICAgdHlwZTogJ1NlY3RvcicsXG4gICAgICBzaGFwZTogdmlld0hlbHBlci5tYWtlU2VjdG9yU2hhcGUocG9sYXIuY3gsIHBvbGFyLmN5LCBvdGhlckV4dGVudFswXSwgb3RoZXJFeHRlbnRbMV0sXG4gICAgICAvLyBJbiBFQ2hhcnRzIHkgaXMgbmVnYXRpdmUgaWYgYW5nbGUgaXMgcG9zaXRpdmVcbiAgICAgICgtY29vcmRWYWx1ZSAtIGJhbmRXaWR0aCAvIDIpICogcmFkaWFuLCAoLWNvb3JkVmFsdWUgKyBiYW5kV2lkdGggLyAyKSAqIHJhZGlhbilcbiAgICB9IDoge1xuICAgICAgdHlwZTogJ1NlY3RvcicsXG4gICAgICBzaGFwZTogdmlld0hlbHBlci5tYWtlU2VjdG9yU2hhcGUocG9sYXIuY3gsIHBvbGFyLmN5LCBjb29yZFZhbHVlIC0gYmFuZFdpZHRoIC8gMiwgY29vcmRWYWx1ZSArIGJhbmRXaWR0aCAvIDIsIDAsIE1hdGguUEkgKiAyKVxuICAgIH07XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBQb2xhckF4aXNQb2ludGVyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///23953\n")},26333:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ findPointFromSeries)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n/**\r\n * @param finder contains {seriesIndex, dataIndex, dataIndexInside}\r\n * @param ecModel\r\n * @return  {point: [x, y], el: ...} point Will not be null.\r\n */\nfunction findPointFromSeries(finder, ecModel) {\n  var point = [];\n  var seriesIndex = finder.seriesIndex;\n  var seriesModel;\n  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {\n    return {\n      point: []\n    };\n  }\n  var data = seriesModel.getData();\n  var dataIndex = _util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .queryDataIndex */ .le(data, finder);\n  if (dataIndex == null || dataIndex < 0 || zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray(dataIndex)) {\n    return {\n      point: []\n    };\n  }\n  var el = data.getItemGraphicEl(dataIndex);\n  var coordSys = seriesModel.coordinateSystem;\n  if (seriesModel.getTooltipPosition) {\n    point = seriesModel.getTooltipPosition(dataIndex) || [];\n  } else if (coordSys && coordSys.dataToPoint) {\n    if (finder.isStacked) {\n      var baseAxis = coordSys.getBaseAxis();\n      var valueAxis = coordSys.getOtherAxis(baseAxis);\n      var valueAxisDim = valueAxis.dim;\n      var baseAxisDim = baseAxis.dim;\n      var baseDataOffset = valueAxisDim === \'x\' || valueAxisDim === \'radius\' ? 1 : 0;\n      var baseDim = data.mapDimension(baseAxisDim);\n      var stackedData = [];\n      stackedData[baseDataOffset] = data.get(baseDim, dataIndex);\n      stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo(\'stackResultDimension\'), dataIndex);\n      point = coordSys.dataToPoint(stackedData) || [];\n    } else {\n      point = coordSys.dataToPoint(data.getValues(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }), dataIndex)) || [];\n    }\n  } else if (el) {\n    // Use graphic bounding rect\n    var rect = el.getBoundingRect().clone();\n    rect.applyTransform(el.transform);\n    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  }\n  return {\n    point: point,\n    el: el\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYzMzMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9maW5kUG9pbnRGcm9tU2VyaWVzLmpzPzUwYmYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIG1vZGVsVXRpbCBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbi8qKlxyXG4gKiBAcGFyYW0gZmluZGVyIGNvbnRhaW5zIHtzZXJpZXNJbmRleCwgZGF0YUluZGV4LCBkYXRhSW5kZXhJbnNpZGV9XHJcbiAqIEBwYXJhbSBlY01vZGVsXHJcbiAqIEByZXR1cm4gIHtwb2ludDogW3gsIHldLCBlbDogLi4ufSBwb2ludCBXaWxsIG5vdCBiZSBudWxsLlxyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmRQb2ludEZyb21TZXJpZXMoZmluZGVyLCBlY01vZGVsKSB7XG4gIHZhciBwb2ludCA9IFtdO1xuICB2YXIgc2VyaWVzSW5kZXggPSBmaW5kZXIuc2VyaWVzSW5kZXg7XG4gIHZhciBzZXJpZXNNb2RlbDtcbiAgaWYgKHNlcmllc0luZGV4ID09IG51bGwgfHwgIShzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChzZXJpZXNJbmRleCkpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50OiBbXVxuICAgIH07XG4gIH1cbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgZmluZGVyKTtcbiAgaWYgKGRhdGFJbmRleCA9PSBudWxsIHx8IGRhdGFJbmRleCA8IDAgfHwgenJVdGlsLmlzQXJyYXkoZGF0YUluZGV4KSkge1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludDogW11cbiAgICB9O1xuICB9XG4gIHZhciBlbCA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgpO1xuICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICBpZiAoc2VyaWVzTW9kZWwuZ2V0VG9vbHRpcFBvc2l0aW9uKSB7XG4gICAgcG9pbnQgPSBzZXJpZXNNb2RlbC5nZXRUb29sdGlwUG9zaXRpb24oZGF0YUluZGV4KSB8fCBbXTtcbiAgfSBlbHNlIGlmIChjb29yZFN5cyAmJiBjb29yZFN5cy5kYXRhVG9Qb2ludCkge1xuICAgIGlmIChmaW5kZXIuaXNTdGFja2VkKSB7XG4gICAgICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgdmFyIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgICB2YXIgdmFsdWVBeGlzRGltID0gdmFsdWVBeGlzLmRpbTtcbiAgICAgIHZhciBiYXNlQXhpc0RpbSA9IGJhc2VBeGlzLmRpbTtcbiAgICAgIHZhciBiYXNlRGF0YU9mZnNldCA9IHZhbHVlQXhpc0RpbSA9PT0gJ3gnIHx8IHZhbHVlQXhpc0RpbSA9PT0gJ3JhZGl1cycgPyAxIDogMDtcbiAgICAgIHZhciBiYXNlRGltID0gZGF0YS5tYXBEaW1lbnNpb24oYmFzZUF4aXNEaW0pO1xuICAgICAgdmFyIHN0YWNrZWREYXRhID0gW107XG4gICAgICBzdGFja2VkRGF0YVtiYXNlRGF0YU9mZnNldF0gPSBkYXRhLmdldChiYXNlRGltLCBkYXRhSW5kZXgpO1xuICAgICAgc3RhY2tlZERhdGFbMSAtIGJhc2VEYXRhT2Zmc2V0XSA9IGRhdGEuZ2V0KGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja1Jlc3VsdERpbWVuc2lvbicpLCBkYXRhSW5kZXgpO1xuICAgICAgcG9pbnQgPSBjb29yZFN5cy5kYXRhVG9Qb2ludChzdGFja2VkRGF0YSkgfHwgW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoZGF0YS5nZXRWYWx1ZXMoenJVdGlsLm1hcChjb29yZFN5cy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIHJldHVybiBkYXRhLm1hcERpbWVuc2lvbihkaW0pO1xuICAgICAgfSksIGRhdGFJbmRleCkpIHx8IFtdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlbCkge1xuICAgIC8vIFVzZSBncmFwaGljIGJvdW5kaW5nIHJlY3RcbiAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgcmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICAgIHBvaW50ID0gW3JlY3QueCArIHJlY3Qud2lkdGggLyAyLCByZWN0LnkgKyByZWN0LmhlaWdodCAvIDJdO1xuICB9XG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IHBvaW50LFxuICAgIGVsOiBlbFxuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26333\n')},35369:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   V: () => (/* binding */ rectCoordAxisHandleRemove),\n/* harmony export */   Y: () => (/* binding */ rectCoordAxisBuildSplitArea)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30010);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar inner = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nfunction rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {\n  var axis = axisModel.axis;\n  if (axis.scale.isBlank()) {\n    return;\n  }\n  // TODO: TYPE\n  var splitAreaModel = axisModel.getModel(\'splitArea\');\n  var areaStyleModel = splitAreaModel.getModel(\'areaStyle\');\n  var areaColors = areaStyleModel.get(\'color\');\n  var gridRect = gridModel.coordinateSystem.getRect();\n  var ticksCoords = axis.getTicksCoords({\n    tickModel: splitAreaModel,\n    clamp: true\n  });\n  if (!ticksCoords.length) {\n    return;\n  }\n  // For Making appropriate splitArea animation, the color and anid\n  // should be corresponding to previous one if possible.\n  var areaColorsLen = areaColors.length;\n  var lastSplitAreaColors = inner(axisView).splitAreaColors;\n  var newSplitAreaColors = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.createHashMap();\n  var colorIndex = 0;\n  if (lastSplitAreaColors) {\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);\n      if (cIndex != null) {\n        colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;\n        break;\n      }\n    }\n  }\n  var prev = axis.toGlobalCoord(ticksCoords[0].coord);\n  var areaStyle = areaStyleModel.getAreaStyle();\n  areaColors = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray(areaColors) ? areaColors : [areaColors];\n  for (var i = 1; i < ticksCoords.length; i++) {\n    var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n    var x = void 0;\n    var y = void 0;\n    var width = void 0;\n    var height = void 0;\n    if (axis.isHorizontal()) {\n      x = prev;\n      y = gridRect.y;\n      width = tickCoord - x;\n      height = gridRect.height;\n      prev = x + width;\n    } else {\n      x = gridRect.x;\n      y = prev;\n      width = gridRect.width;\n      height = tickCoord - y;\n      prev = y + height;\n    }\n    var tickValue = ticksCoords[i - 1].tickValue;\n    tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);\n    axisGroup.add(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A({\n      anid: tickValue != null ? \'area_\' + tickValue : null,\n      shape: {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      },\n      style: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults({\n        fill: areaColors[colorIndex]\n      }, areaStyle),\n      autoBatch: true,\n      silent: true\n    }));\n    colorIndex = (colorIndex + 1) % areaColorsLen;\n  }\n  inner(axisView).splitAreaColors = newSplitAreaColors;\n}\nfunction rectCoordAxisHandleRemove(axisView) {\n  inner(axisView).splitAreaColors = null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUzNjkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL2F4aXNTcGxpdEhlbHBlci5qcz83YmVkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY3RDb29yZEF4aXNCdWlsZFNwbGl0QXJlYShheGlzVmlldywgYXhpc0dyb3VwLCBheGlzTW9kZWwsIGdyaWRNb2RlbCkge1xuICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICBpZiAoYXhpcy5zY2FsZS5pc0JsYW5rKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVE9ETzogVFlQRVxuICB2YXIgc3BsaXRBcmVhTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ3NwbGl0QXJlYScpO1xuICB2YXIgYXJlYVN0eWxlTW9kZWwgPSBzcGxpdEFyZWFNb2RlbC5nZXRNb2RlbCgnYXJlYVN0eWxlJyk7XG4gIHZhciBhcmVhQ29sb3JzID0gYXJlYVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuICB2YXIgZ3JpZFJlY3QgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG4gIHZhciB0aWNrc0Nvb3JkcyA9IGF4aXMuZ2V0VGlja3NDb29yZHMoe1xuICAgIHRpY2tNb2RlbDogc3BsaXRBcmVhTW9kZWwsXG4gICAgY2xhbXA6IHRydWVcbiAgfSk7XG4gIGlmICghdGlja3NDb29yZHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEZvciBNYWtpbmcgYXBwcm9wcmlhdGUgc3BsaXRBcmVhIGFuaW1hdGlvbiwgdGhlIGNvbG9yIGFuZCBhbmlkXG4gIC8vIHNob3VsZCBiZSBjb3JyZXNwb25kaW5nIHRvIHByZXZpb3VzIG9uZSBpZiBwb3NzaWJsZS5cbiAgdmFyIGFyZWFDb2xvcnNMZW4gPSBhcmVhQ29sb3JzLmxlbmd0aDtcbiAgdmFyIGxhc3RTcGxpdEFyZWFDb2xvcnMgPSBpbm5lcihheGlzVmlldykuc3BsaXRBcmVhQ29sb3JzO1xuICB2YXIgbmV3U3BsaXRBcmVhQ29sb3JzID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgdmFyIGNvbG9ySW5kZXggPSAwO1xuICBpZiAobGFzdFNwbGl0QXJlYUNvbG9ycykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3NDb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjSW5kZXggPSBsYXN0U3BsaXRBcmVhQ29sb3JzLmdldCh0aWNrc0Nvb3Jkc1tpXS50aWNrVmFsdWUpO1xuICAgICAgaWYgKGNJbmRleCAhPSBudWxsKSB7XG4gICAgICAgIGNvbG9ySW5kZXggPSAoY0luZGV4ICsgKGFyZWFDb2xvcnNMZW4gLSAxKSAqIGkpICUgYXJlYUNvbG9yc0xlbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBwcmV2ID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzWzBdLmNvb3JkKTtcbiAgdmFyIGFyZWFTdHlsZSA9IGFyZWFTdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpO1xuICBhcmVhQ29sb3JzID0genJVdGlsLmlzQXJyYXkoYXJlYUNvbG9ycykgPyBhcmVhQ29sb3JzIDogW2FyZWFDb2xvcnNdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IHRpY2tzQ29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRpY2tDb29yZCA9IGF4aXMudG9HbG9iYWxDb29yZCh0aWNrc0Nvb3Jkc1tpXS5jb29yZCk7XG4gICAgdmFyIHggPSB2b2lkIDA7XG4gICAgdmFyIHkgPSB2b2lkIDA7XG4gICAgdmFyIHdpZHRoID0gdm9pZCAwO1xuICAgIHZhciBoZWlnaHQgPSB2b2lkIDA7XG4gICAgaWYgKGF4aXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHggPSBwcmV2O1xuICAgICAgeSA9IGdyaWRSZWN0Lnk7XG4gICAgICB3aWR0aCA9IHRpY2tDb29yZCAtIHg7XG4gICAgICBoZWlnaHQgPSBncmlkUmVjdC5oZWlnaHQ7XG4gICAgICBwcmV2ID0geCArIHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gZ3JpZFJlY3QueDtcbiAgICAgIHkgPSBwcmV2O1xuICAgICAgd2lkdGggPSBncmlkUmVjdC53aWR0aDtcbiAgICAgIGhlaWdodCA9IHRpY2tDb29yZCAtIHk7XG4gICAgICBwcmV2ID0geSArIGhlaWdodDtcbiAgICB9XG4gICAgdmFyIHRpY2tWYWx1ZSA9IHRpY2tzQ29vcmRzW2kgLSAxXS50aWNrVmFsdWU7XG4gICAgdGlja1ZhbHVlICE9IG51bGwgJiYgbmV3U3BsaXRBcmVhQ29sb3JzLnNldCh0aWNrVmFsdWUsIGNvbG9ySW5kZXgpO1xuICAgIGF4aXNHcm91cC5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICBhbmlkOiB0aWNrVmFsdWUgIT0gbnVsbCA/ICdhcmVhXycgKyB0aWNrVmFsdWUgOiBudWxsLFxuICAgICAgc2hhcGU6IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfSxcbiAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICBmaWxsOiBhcmVhQ29sb3JzW2NvbG9ySW5kZXhdXG4gICAgICB9LCBhcmVhU3R5bGUpLFxuICAgICAgYXV0b0JhdGNoOiB0cnVlLFxuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSkpO1xuICAgIGNvbG9ySW5kZXggPSAoY29sb3JJbmRleCArIDEpICUgYXJlYUNvbG9yc0xlbjtcbiAgfVxuICBpbm5lcihheGlzVmlldykuc3BsaXRBcmVhQ29sb3JzID0gbmV3U3BsaXRBcmVhQ29sb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlY3RDb29yZEF4aXNIYW5kbGVSZW1vdmUoYXhpc1ZpZXcpIHtcbiAgaW5uZXIoYXhpc1ZpZXcpLnNwbGl0QXJlYUNvbG9ycyA9IG51bGw7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///35369\n')},44784:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ unregister),\n/* harmony export */   k: () => (/* binding */ register)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var zrender_lib_core_env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38123);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar inner = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nvar each = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each;\n/**\r\n * @param {string} key\r\n * @param {module:echarts/ExtensionAPI} api\r\n * @param {Function} handler\r\n *      param: {string} currTrigger\r\n *      param: {Array.<number>} point\r\n */\nfunction register(key, api, handler) {\n  if (zrender_lib_core_env_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A.node) {\n    return;\n  }\n  var zr = api.getZr();\n  inner(zr).records || (inner(zr).records = {});\n  initGlobalListeners(zr, api);\n  var record = inner(zr).records[key] || (inner(zr).records[key] = {});\n  record.handler = handler;\n}\nfunction initGlobalListeners(zr, api) {\n  if (inner(zr).initialized) {\n    return;\n  }\n  inner(zr).initialized = true;\n  useHandler('click', zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.curry(doEnter, 'click'));\n  useHandler('mousemove', zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.curry(doEnter, 'mousemove'));\n  // useHandler('mouseout', onLeave);\n  useHandler('globalout', onLeave);\n  function useHandler(eventType, cb) {\n    zr.on(eventType, function (e) {\n      var dis = makeDispatchAction(api);\n      each(inner(zr).records, function (record) {\n        record && cb(record, e, dis.dispatchAction);\n      });\n      dispatchTooltipFinally(dis.pendings, api);\n    });\n  }\n}\nfunction dispatchTooltipFinally(pendings, api) {\n  var showLen = pendings.showTip.length;\n  var hideLen = pendings.hideTip.length;\n  var actuallyPayload;\n  if (showLen) {\n    actuallyPayload = pendings.showTip[showLen - 1];\n  } else if (hideLen) {\n    actuallyPayload = pendings.hideTip[hideLen - 1];\n  }\n  if (actuallyPayload) {\n    actuallyPayload.dispatchAction = null;\n    api.dispatchAction(actuallyPayload);\n  }\n}\nfunction onLeave(record, e, dispatchAction) {\n  record.handler('leave', null, dispatchAction);\n}\nfunction doEnter(currTrigger, record, e, dispatchAction) {\n  record.handler(currTrigger, e, dispatchAction);\n}\nfunction makeDispatchAction(api) {\n  var pendings = {\n    showTip: [],\n    hideTip: []\n  };\n  // FIXME\n  // better approach?\n  // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n  // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n  // So we have to add \"final stage\" to merge those dispatched actions.\n  var dispatchAction = function (payload) {\n    var pendingList = pendings[payload.type];\n    if (pendingList) {\n      pendingList.push(payload);\n    } else {\n      payload.dispatchAction = dispatchAction;\n      api.dispatchAction(payload);\n    }\n  };\n  return {\n    dispatchAction: dispatchAction,\n    pendings: pendings\n  };\n}\nfunction unregister(key, api) {\n  if (zrender_lib_core_env_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A.node) {\n    return;\n  }\n  var zr = api.getZr();\n  var record = (inner(zr).records || {})[key];\n  if (record) {\n    inner(zr).records[key] = null;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ3ODQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvZ2xvYmFsTGlzdGVuZXIuanM/OGY1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IGVudiBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL2Vudi5qcyc7XG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbi8qKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XHJcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxyXG4gKiAgICAgIHBhcmFtOiB7c3RyaW5nfSBjdXJyVHJpZ2dlclxyXG4gKiAgICAgIHBhcmFtOiB7QXJyYXkuPG51bWJlcj59IHBvaW50XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKGtleSwgYXBpLCBoYW5kbGVyKSB7XG4gIGlmIChlbnYubm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgaW5uZXIoenIpLnJlY29yZHMgfHwgKGlubmVyKHpyKS5yZWNvcmRzID0ge30pO1xuICBpbml0R2xvYmFsTGlzdGVuZXJzKHpyLCBhcGkpO1xuICB2YXIgcmVjb3JkID0gaW5uZXIoenIpLnJlY29yZHNba2V5XSB8fCAoaW5uZXIoenIpLnJlY29yZHNba2V5XSA9IHt9KTtcbiAgcmVjb3JkLmhhbmRsZXIgPSBoYW5kbGVyO1xufVxuZnVuY3Rpb24gaW5pdEdsb2JhbExpc3RlbmVycyh6ciwgYXBpKSB7XG4gIGlmIChpbm5lcih6cikuaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaW5uZXIoenIpLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgdXNlSGFuZGxlcignY2xpY2snLCB6clV0aWwuY3VycnkoZG9FbnRlciwgJ2NsaWNrJykpO1xuICB1c2VIYW5kbGVyKCdtb3VzZW1vdmUnLCB6clV0aWwuY3VycnkoZG9FbnRlciwgJ21vdXNlbW92ZScpKTtcbiAgLy8gdXNlSGFuZGxlcignbW91c2VvdXQnLCBvbkxlYXZlKTtcbiAgdXNlSGFuZGxlcignZ2xvYmFsb3V0Jywgb25MZWF2ZSk7XG4gIGZ1bmN0aW9uIHVzZUhhbmRsZXIoZXZlbnRUeXBlLCBjYikge1xuICAgIHpyLm9uKGV2ZW50VHlwZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBkaXMgPSBtYWtlRGlzcGF0Y2hBY3Rpb24oYXBpKTtcbiAgICAgIGVhY2goaW5uZXIoenIpLnJlY29yZHMsIGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgcmVjb3JkICYmIGNiKHJlY29yZCwgZSwgZGlzLmRpc3BhdGNoQWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgZGlzcGF0Y2hUb29sdGlwRmluYWxseShkaXMucGVuZGluZ3MsIGFwaSk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpc3BhdGNoVG9vbHRpcEZpbmFsbHkocGVuZGluZ3MsIGFwaSkge1xuICB2YXIgc2hvd0xlbiA9IHBlbmRpbmdzLnNob3dUaXAubGVuZ3RoO1xuICB2YXIgaGlkZUxlbiA9IHBlbmRpbmdzLmhpZGVUaXAubGVuZ3RoO1xuICB2YXIgYWN0dWFsbHlQYXlsb2FkO1xuICBpZiAoc2hvd0xlbikge1xuICAgIGFjdHVhbGx5UGF5bG9hZCA9IHBlbmRpbmdzLnNob3dUaXBbc2hvd0xlbiAtIDFdO1xuICB9IGVsc2UgaWYgKGhpZGVMZW4pIHtcbiAgICBhY3R1YWxseVBheWxvYWQgPSBwZW5kaW5ncy5oaWRlVGlwW2hpZGVMZW4gLSAxXTtcbiAgfVxuICBpZiAoYWN0dWFsbHlQYXlsb2FkKSB7XG4gICAgYWN0dWFsbHlQYXlsb2FkLmRpc3BhdGNoQWN0aW9uID0gbnVsbDtcbiAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oYWN0dWFsbHlQYXlsb2FkKTtcbiAgfVxufVxuZnVuY3Rpb24gb25MZWF2ZShyZWNvcmQsIGUsIGRpc3BhdGNoQWN0aW9uKSB7XG4gIHJlY29yZC5oYW5kbGVyKCdsZWF2ZScsIG51bGwsIGRpc3BhdGNoQWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGRvRW50ZXIoY3VyclRyaWdnZXIsIHJlY29yZCwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgcmVjb3JkLmhhbmRsZXIoY3VyclRyaWdnZXIsIGUsIGRpc3BhdGNoQWN0aW9uKTtcbn1cbmZ1bmN0aW9uIG1ha2VEaXNwYXRjaEFjdGlvbihhcGkpIHtcbiAgdmFyIHBlbmRpbmdzID0ge1xuICAgIHNob3dUaXA6IFtdLFxuICAgIGhpZGVUaXA6IFtdXG4gIH07XG4gIC8vIEZJWE1FXG4gIC8vIGJldHRlciBhcHByb2FjaD9cbiAgLy8gJ3Nob3dUaXAnIGFuZCAnaGlkZVRpcCcgY2FuIGJlIHRyaWdnZXJlZCBieSBheGlzUG9pbnRlciBhbmQgdG9vbHRpcCxcbiAgLy8gd2hpY2ggbWF5IGJlIGNvbmZsaWN0LCAoYXhpc1BvaW50ZXIgY2FsbCBzaG93VGlwIGJ1dCB0b29sdGlwIGNhbGwgaGlkZVRpcCk7XG4gIC8vIFNvIHdlIGhhdmUgdG8gYWRkIFwiZmluYWwgc3RhZ2VcIiB0byBtZXJnZSB0aG9zZSBkaXNwYXRjaGVkIGFjdGlvbnMuXG4gIHZhciBkaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgdmFyIHBlbmRpbmdMaXN0ID0gcGVuZGluZ3NbcGF5bG9hZC50eXBlXTtcbiAgICBpZiAocGVuZGluZ0xpc3QpIHtcbiAgICAgIHBlbmRpbmdMaXN0LnB1c2gocGF5bG9hZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gPSBkaXNwYXRjaEFjdGlvbjtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbihwYXlsb2FkKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgZGlzcGF0Y2hBY3Rpb246IGRpc3BhdGNoQWN0aW9uLFxuICAgIHBlbmRpbmdzOiBwZW5kaW5nc1xuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVucmVnaXN0ZXIoa2V5LCBhcGkpIHtcbiAgaWYgKGVudi5ub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICB2YXIgcmVjb3JkID0gKGlubmVyKHpyKS5yZWNvcmRzIHx8IHt9KVtrZXldO1xuICBpZiAocmVjb3JkKSB7XG4gICAgaW5uZXIoenIpLnJlY29yZHNba2V5XSA9IG51bGw7XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///44784\n")},46524:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axis/AxisView.js\nvar AxisView = __webpack_require__(22480);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js\nvar BaseAxisPointer = __webpack_require__(53226);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axisPointer/viewHelper.js\nvar viewHelper = __webpack_require__(3686);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js\nvar cartesianAxisHelper = __webpack_require__(96878);\n;// ./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar CartesianAxisPointer = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(CartesianAxisPointer, _super);\n  function CartesianAxisPointer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * @override\r\n   */\n  CartesianAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisPointerType = axisPointerModel.get('type');\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n    if (axisPointerType && axisPointerType !== 'none') {\n      var elStyle = viewHelper/* buildElStyle */.bY(axisPointerModel);\n      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);\n      pointerOption.style = elStyle;\n      elOption.graphicKey = pointerOption.type;\n      elOption.pointer = pointerOption;\n    }\n    var layoutInfo = cartesianAxisHelper/* layout */.Zp(grid.model, axisModel);\n    viewHelper/* buildCartesianSingleLabelElOption */.DA(\n    // @ts-ignore\n    value, elOption, layoutInfo, axisModel, axisPointerModel, api);\n  };\n  /**\r\n   * @override\r\n   */\n  CartesianAxisPointer.prototype.getHandleTransform = function (value, axisModel, axisPointerModel) {\n    var layoutInfo = cartesianAxisHelper/* layout */.Zp(axisModel.axis.grid.model, axisModel, {\n      labelInside: false\n    });\n    // @ts-ignore\n    layoutInfo.labelMargin = axisPointerModel.get(['handle', 'margin']);\n    var pos = viewHelper/* getTransformedPosition */.Tc(axisModel.axis, value, layoutInfo);\n    return {\n      x: pos[0],\n      y: pos[1],\n      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n    };\n  };\n  /**\r\n   * @override\r\n   */\n  CartesianAxisPointer.prototype.updateHandleTransform = function (transform, delta, axisModel, axisPointerModel) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisExtent = axis.getGlobalExtent(true);\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var dimIndex = axis.dim === 'x' ? 0 : 1;\n    var currPosition = [transform.x, transform.y];\n    currPosition[dimIndex] += delta[dimIndex];\n    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n    var cursorPoint = [cursorOtherValue, cursorOtherValue];\n    cursorPoint[dimIndex] = currPosition[dimIndex];\n    // Make tooltip do not overlap axisPointer and in the middle of the grid.\n    var tooltipOptions = [{\n      verticalAlign: 'middle'\n    }, {\n      align: 'center'\n    }];\n    return {\n      x: currPosition[0],\n      y: currPosition[1],\n      rotation: transform.rotation,\n      cursorPoint: cursorPoint,\n      tooltipOption: tooltipOptions[dimIndex]\n    };\n  };\n  return CartesianAxisPointer;\n}(BaseAxisPointer/* default */.A);\nfunction getCartesian(grid, axis) {\n  var opt = {};\n  opt[axis.dim + 'AxisIndex'] = axis.index;\n  return grid.getCartesian(opt);\n}\nvar pointerShapeBuilder = {\n  line: function (axis, pixelValue, otherExtent) {\n    var targetShape = viewHelper/* makeLineShape */.MU([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));\n    return {\n      type: 'Line',\n      subPixelOptimize: true,\n      shape: targetShape\n    };\n  },\n  shadow: function (axis, pixelValue, otherExtent) {\n    var bandWidth = Math.max(1, axis.getBandWidth());\n    var span = otherExtent[1] - otherExtent[0];\n    return {\n      type: 'Rect',\n      shape: viewHelper/* makeRectShape */.cU([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))\n    };\n  }\n};\nfunction getAxisDimIndex(axis) {\n  return axis.dim === 'x' ? 0 : 1;\n}\n/* harmony default export */ const axisPointer_CartesianAxisPointer = (CartesianAxisPointer);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Component.js\nvar Component = __webpack_require__(15915);\n;// ./node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar AxisPointerModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(AxisPointerModel, _super);\n  function AxisPointerModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = AxisPointerModel.type;\n    return _this;\n  }\n  AxisPointerModel.type = 'axisPointer';\n  AxisPointerModel.defaultOption = {\n    // 'auto' means that show when triggered by tooltip or handle.\n    show: 'auto',\n    // zlevel: 0,\n    z: 50,\n    type: 'line',\n    // axispointer triggered by tootip determine snap automatically,\n    // see `modelHelper`.\n    snap: false,\n    triggerTooltip: true,\n    triggerEmphasis: true,\n    value: null,\n    status: null,\n    link: [],\n    // Do not set 'auto' here, otherwise global animation: false\n    // will not effect at this axispointer.\n    animation: null,\n    animationDurationUpdate: 200,\n    lineStyle: {\n      color: '#B9BEC9',\n      width: 1,\n      type: 'dashed'\n    },\n    shadowStyle: {\n      color: 'rgba(210,219,238,0.2)'\n    },\n    label: {\n      show: true,\n      formatter: null,\n      precision: 'auto',\n      margin: 3,\n      color: '#fff',\n      padding: [5, 7, 5, 7],\n      backgroundColor: 'auto',\n      borderColor: null,\n      borderWidth: 0,\n      borderRadius: 3\n    },\n    handle: {\n      show: false,\n      // eslint-disable-next-line\n      icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',\n      size: 45,\n      // handle margin is from symbol center to axis, which is stable when circular move.\n      margin: 50,\n      // color: '#1b8bbd'\n      // color: '#2f4554'\n      color: '#333',\n      shadowBlur: 3,\n      shadowColor: '#aaa',\n      shadowOffsetX: 0,\n      shadowOffsetY: 2,\n      // For mobile performance\n      throttle: 40\n    }\n  };\n  return AxisPointerModel;\n}(Component/* default */.A);\n/* harmony default export */ const axisPointer_AxisPointerModel = (AxisPointerModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axisPointer/globalListener.js\nvar globalListener = __webpack_require__(44784);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar view_Component = __webpack_require__(59109);\n;// ./node_modules/echarts/lib/component/axisPointer/AxisPointerView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar AxisPointerView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(AxisPointerView, _super);\n  function AxisPointerView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = AxisPointerView.type;\n    return _this;\n  }\n  AxisPointerView.prototype.render = function (globalAxisPointerModel, ecModel, api) {\n    var globalTooltipModel = ecModel.getComponent('tooltip');\n    var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click';\n    // Register global listener in AxisPointerView to enable\n    // AxisPointerView to be independent to Tooltip.\n    globalListener/* register */.k('axisPointer', api, function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {\n        dispatchAction({\n          type: 'updateAxisPointer',\n          currTrigger: currTrigger,\n          x: e && e.offsetX,\n          y: e && e.offsetY\n        });\n      }\n    });\n  };\n  AxisPointerView.prototype.remove = function (ecModel, api) {\n    globalListener/* unregister */.h('axisPointer', api);\n  };\n  AxisPointerView.prototype.dispose = function (ecModel, api) {\n    globalListener/* unregister */.h('axisPointer', api);\n  };\n  AxisPointerView.type = 'axisPointer';\n  return AxisPointerView;\n}(view_Component/* default */.A);\n/* harmony default export */ const axisPointer_AxisPointerView = (AxisPointerView);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axisPointer/modelHelper.js\nvar modelHelper = __webpack_require__(49890);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js\nvar findPointFromSeries = __webpack_require__(26333);\n;// ./node_modules/echarts/lib/component/axisPointer/axisTrigger.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar inner = (0,model/* makeInner */.$r)();\n/**\r\n * Basic logic: check all axis, if they do not demand show/highlight,\r\n * then hide/downplay them.\r\n *\r\n * @return content of event obj for echarts.connect.\r\n */\nfunction axisTrigger(payload, ecModel, api) {\n  var currTrigger = payload.currTrigger;\n  var point = [payload.x, payload.y];\n  var finder = payload;\n  var dispatchAction = payload.dispatchAction || (0,util.bind)(api.dispatchAction, api);\n  var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n  // Pending\n  // See #6121. But we are not able to reproduce it yet.\n  if (!coordSysAxesInfo) {\n    return;\n  }\n  if (illegalPoint(point)) {\n    // Used in the default behavior of `connection`: use the sample seriesIndex\n    // and dataIndex. And also used in the tooltipView trigger.\n    point = (0,findPointFromSeries/* default */.A)({\n      seriesIndex: finder.seriesIndex,\n      // Do not use dataIndexInside from other ec instance.\n      // FIXME: auto detect it?\n      dataIndex: finder.dataIndex\n    }, ecModel).point;\n  }\n  var isIllegalPoint = illegalPoint(point);\n  // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n  // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n  // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n  // and dataIndex.\n  var inputAxesInfo = finder.axesInfo;\n  var axesInfo = coordSysAxesInfo.axesInfo;\n  var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n  var outputPayload = {};\n  var showValueMap = {};\n  var dataByCoordSys = {\n    list: [],\n    map: {}\n  };\n  var updaters = {\n    showPointer: (0,util.curry)(showPointer, showValueMap),\n    showTooltip: (0,util.curry)(showTooltip, dataByCoordSys)\n  };\n  // Process for triggered axes.\n  (0,util.each)(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n    // If a point given, it must be contained by the coordinate system.\n    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n    (0,util.each)(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n      var axis = axisInfo.axis;\n      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);\n      // If no inputAxesInfo, no axis is restricted.\n      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n        var val = inputAxisInfo && inputAxisInfo.value;\n        if (val == null && !isIllegalPoint) {\n          val = axis.pointToData(point);\n        }\n        val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);\n      }\n    });\n  });\n  // Process for linked axes.\n  var linkTriggers = {};\n  (0,util.each)(axesInfo, function (tarAxisInfo, tarKey) {\n    var linkGroup = tarAxisInfo.linkGroup;\n    // If axis has been triggered in the previous stage, it should not be triggered by link.\n    if (linkGroup && !showValueMap[tarKey]) {\n      (0,util.each)(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n        var srcValItem = showValueMap[srcKey];\n        // If srcValItem exist, source axis is triggered, so link to target axis.\n        if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n          var val = srcValItem.value;\n          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));\n          linkTriggers[tarAxisInfo.key] = val;\n        }\n      });\n    }\n  });\n  (0,util.each)(linkTriggers, function (val, tarKey) {\n    processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);\n  });\n  updateModelActually(showValueMap, axesInfo, outputPayload);\n  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n  dispatchHighDownActually(axesInfo, dispatchAction, api);\n  return outputPayload;\n}\nfunction processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {\n  var axis = axisInfo.axis;\n  if (axis.scale.isBlank() || !axis.containData(newValue)) {\n    return;\n  }\n  if (!axisInfo.involveSeries) {\n    updaters.showPointer(axisInfo, newValue);\n    return;\n  }\n  // Heavy calculation. So put it after axis.containData checking.\n  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n  var payloadBatch = payloadInfo.payloadBatch;\n  var snapToValue = payloadInfo.snapToValue;\n  // Fill content of event obj for echarts.connect.\n  // By default use the first involved series data as a sample to connect.\n  if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n    (0,util.extend)(outputFinder, payloadBatch[0]);\n  }\n  // If no linkSource input, this process is for collecting link\n  // target, where snap should not be accepted.\n  if (!noSnap && axisInfo.snap) {\n    if (axis.containData(snapToValue) && snapToValue != null) {\n      newValue = snapToValue;\n    }\n  }\n  updaters.showPointer(axisInfo, newValue, payloadBatch);\n  // Tooltip should always be snapToValue, otherwise there will be\n  // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n}\nfunction buildPayloadsBySeries(value, axisInfo) {\n  var axis = axisInfo.axis;\n  var dim = axis.dim;\n  var snapToValue = value;\n  var payloadBatch = [];\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n  (0,util.each)(axisInfo.seriesModels, function (series, idx) {\n    var dataDim = series.getData().mapDimensionsAll(dim);\n    var seriesNestestValue;\n    var dataIndices;\n    if (series.getAxisTooltipData) {\n      var result = series.getAxisTooltipData(dataDim, value, axis);\n      dataIndices = result.dataIndices;\n      seriesNestestValue = result.nestestValue;\n    } else {\n      dataIndices = series.getData().indicesOfNearest(dataDim[0], value,\n      // Add a threshold to avoid find the wrong dataIndex\n      // when data length is not same.\n      // false,\n      axis.type === 'category' ? 0.5 : null);\n      if (!dataIndices.length) {\n        return;\n      }\n      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n    }\n    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n      return;\n    }\n    var diff = value - seriesNestestValue;\n    var dist = Math.abs(diff);\n    // Consider category case\n    if (dist <= minDist) {\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        snapToValue = seriesNestestValue;\n        payloadBatch.length = 0;\n      }\n      (0,util.each)(dataIndices, function (dataIndex) {\n        payloadBatch.push({\n          seriesIndex: series.seriesIndex,\n          dataIndexInside: dataIndex,\n          dataIndex: series.getData().getRawIndex(dataIndex)\n        });\n      });\n    }\n  });\n  return {\n    payloadBatch: payloadBatch,\n    snapToValue: snapToValue\n  };\n}\nfunction showPointer(showValueMap, axisInfo, value, payloadBatch) {\n  showValueMap[axisInfo.key] = {\n    value: value,\n    payloadBatch: payloadBatch\n  };\n}\nfunction showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n  var payloadBatch = payloadInfo.payloadBatch;\n  var axis = axisInfo.axis;\n  var axisModel = axis.model;\n  var axisPointerModel = axisInfo.axisPointerModel;\n  // If no data, do not create anything in dataByCoordSys,\n  // whose length will be used to judge whether dispatch action.\n  if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n    return;\n  }\n  var coordSysModel = axisInfo.coordSys.model;\n  var coordSysKey = modelHelper/* makeKey */.og(coordSysModel);\n  var coordSysItem = dataByCoordSys.map[coordSysKey];\n  if (!coordSysItem) {\n    coordSysItem = dataByCoordSys.map[coordSysKey] = {\n      coordSysId: coordSysModel.id,\n      coordSysIndex: coordSysModel.componentIndex,\n      coordSysType: coordSysModel.type,\n      coordSysMainType: coordSysModel.mainType,\n      dataByAxis: []\n    };\n    dataByCoordSys.list.push(coordSysItem);\n  }\n  coordSysItem.dataByAxis.push({\n    axisDim: axis.dim,\n    axisIndex: axisModel.componentIndex,\n    axisType: axisModel.type,\n    axisId: axisModel.id,\n    value: value,\n    // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n    // depends that all models have been updated. So it should not be performed\n    // here. Considering axisPointerModel used here is volatile, which is hard\n    // to be retrieve in TooltipView, we prepare parameters here.\n    valueLabelOpt: {\n      precision: axisPointerModel.get(['label', 'precision']),\n      formatter: axisPointerModel.get(['label', 'formatter'])\n    },\n    seriesDataIndices: payloadBatch.slice()\n  });\n}\nfunction updateModelActually(showValueMap, axesInfo, outputPayload) {\n  var outputAxesInfo = outputPayload.axesInfo = [];\n  // Basic logic: If no 'show' required, 'hide' this axisPointer.\n  (0,util.each)(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    var valItem = showValueMap[key];\n    if (valItem) {\n      !axisInfo.useHandle && (option.status = 'show');\n      option.value = valItem.value;\n      // For label formatter param and highlight.\n      option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n    }\n    // When always show (e.g., handle used), remain\n    // original value and status.\n    else {\n      // If hide, value still need to be set, consider\n      // click legend to toggle axis blank.\n      !axisInfo.useHandle && (option.status = 'hide');\n    }\n    // If status is 'hide', should be no info in payload.\n    option.status === 'show' && outputAxesInfo.push({\n      axisDim: axisInfo.axis.dim,\n      axisIndex: axisInfo.axis.model.componentIndex,\n      value: option.value\n    });\n  });\n}\nfunction dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n  // Basic logic: If no showTip required, hideTip will be dispatched.\n  if (illegalPoint(point) || !dataByCoordSys.list.length) {\n    dispatchAction({\n      type: 'hideTip'\n    });\n    return;\n  }\n  // In most case only one axis (or event one series is used). It is\n  // convenient to fetch payload.seriesIndex and payload.dataIndex\n  // directly. So put the first seriesIndex and dataIndex of the first\n  // axis on the payload.\n  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n  dispatchAction({\n    type: 'showTip',\n    escapeConnect: true,\n    x: point[0],\n    y: point[1],\n    tooltipOption: payload.tooltipOption,\n    position: payload.position,\n    dataIndexInside: sampleItem.dataIndexInside,\n    dataIndex: sampleItem.dataIndex,\n    seriesIndex: sampleItem.seriesIndex,\n    dataByCoordSys: dataByCoordSys.list\n  });\n}\nfunction dispatchHighDownActually(axesInfo, dispatchAction, api) {\n  // FIXME\n  // highlight status modification should be a stage of main process?\n  // (Consider confilct (e.g., legend and axisPointer) and setOption)\n  var zr = api.getZr();\n  var highDownKey = 'axisPointerLastHighlights';\n  var lastHighlights = inner(zr)[highDownKey] || {};\n  var newHighlights = inner(zr)[highDownKey] = {};\n  // Update highlight/downplay status according to axisPointer model.\n  // Build hash map and remove duplicate incidentally.\n  (0,util.each)(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    option.status === 'show' && axisInfo.triggerEmphasis && (0,util.each)(option.seriesDataIndices, function (batchItem) {\n      var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n      newHighlights[key] = batchItem;\n    });\n  });\n  // Diff.\n  var toHighlight = [];\n  var toDownplay = [];\n  (0,util.each)(lastHighlights, function (batchItem, key) {\n    !newHighlights[key] && toDownplay.push(batchItem);\n  });\n  (0,util.each)(newHighlights, function (batchItem, key) {\n    !lastHighlights[key] && toHighlight.push(batchItem);\n  });\n  toDownplay.length && api.dispatchAction({\n    type: 'downplay',\n    escapeConnect: true,\n    // Not blur others when highlight in axisPointer.\n    notBlur: true,\n    batch: toDownplay\n  });\n  toHighlight.length && api.dispatchAction({\n    type: 'highlight',\n    escapeConnect: true,\n    // Not blur others when highlight in axisPointer.\n    notBlur: true,\n    batch: toHighlight\n  });\n}\nfunction findInputAxisInfo(inputAxesInfo, axisInfo) {\n  for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n    var inputAxisInfo = inputAxesInfo[i];\n    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {\n      return inputAxisInfo;\n    }\n  }\n}\nfunction makeMapperParam(axisInfo) {\n  var axisModel = axisInfo.axis.model;\n  var item = {};\n  var dim = item.axisDim = axisInfo.axis.dim;\n  item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n  item.axisName = item[dim + 'AxisName'] = axisModel.name;\n  item.axisId = item[dim + 'AxisId'] = axisModel.id;\n  return item;\n}\nfunction illegalPoint(point) {\n  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n}\n;// ./node_modules/echarts/lib/component/axisPointer/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nfunction install(registers) {\n  // CartesianAxisPointer is not supposed to be required here. But consider\n  // echarts.simple.js and online build tooltip, which only require gridSimple,\n  // CartesianAxisPointer should be able to required somewhere.\n  AxisView/* default */.A.registerAxisPointerClass('CartesianAxisPointer', axisPointer_CartesianAxisPointer);\n  registers.registerComponentModel(axisPointer_AxisPointerModel);\n  registers.registerComponentView(axisPointer_AxisPointerView);\n  registers.registerPreprocessor(function (option) {\n    // Always has a global axisPointerModel for default setting.\n    if (option) {\n      (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});\n      var link = option.axisPointer.link;\n      // Normalize to array to avoid object mergin. But if link\n      // is not set, remain null/undefined, otherwise it will\n      // override existent link setting.\n      if (link && !(0,util.isArray)(link)) {\n        option.axisPointer.link = [link];\n      }\n    }\n  });\n  // This process should proformed after coordinate systems created\n  // and series data processed. So put it on statistic processing stage.\n  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n    // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n    // allAxesInfo should be updated when setOption performed.\n    ecModel.getComponent('axisPointer').coordSysAxesInfo = (0,modelHelper/* collect */.Fo)(ecModel, api);\n  });\n  // Broadcast to all views.\n  registers.registerAction({\n    type: 'updateAxisPointer',\n    event: 'updateAxisPointer',\n    update: ':updateAxisPointer'\n  }, axisTrigger);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDY1MjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0NhcnRlc2lhbkF4aXNQb2ludGVyLmpzP2IyMzUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlck1vZGVsLmpzPzBmMWQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlclZpZXcuanM/MTQzNyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2F4aXNUcmlnZ2VyLmpzPzYwZTciLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9pbnN0YWxsLmpzPzc1ZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBCYXNlQXhpc1BvaW50ZXIgZnJvbSAnLi9CYXNlQXhpc1BvaW50ZXIuanMnO1xuaW1wb3J0ICogYXMgdmlld0hlbHBlciBmcm9tICcuL3ZpZXdIZWxwZXIuanMnO1xuaW1wb3J0ICogYXMgY2FydGVzaWFuQXhpc0hlbHBlciBmcm9tICcuLi8uLi9jb29yZC9jYXJ0ZXNpYW4vY2FydGVzaWFuQXhpc0hlbHBlci5qcyc7XG52YXIgQ2FydGVzaWFuQXhpc1BvaW50ZXIgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ2FydGVzaWFuQXhpc1BvaW50ZXIsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIENhcnRlc2lhbkF4aXNQb2ludGVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgQ2FydGVzaWFuQXhpc1BvaW50ZXIucHJvdG90eXBlLm1ha2VFbE9wdGlvbiA9IGZ1bmN0aW9uIChlbE9wdGlvbiwgdmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgZ3JpZCA9IGF4aXMuZ3JpZDtcbiAgICB2YXIgYXhpc1BvaW50ZXJUeXBlID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgb3RoZXJFeHRlbnQgPSBnZXRDYXJ0ZXNpYW4oZ3JpZCwgYXhpcykuZ2V0T3RoZXJBeGlzKGF4aXMpLmdldEdsb2JhbEV4dGVudCgpO1xuICAgIHZhciBwaXhlbFZhbHVlID0gYXhpcy50b0dsb2JhbENvb3JkKGF4aXMuZGF0YVRvQ29vcmQodmFsdWUsIHRydWUpKTtcbiAgICBpZiAoYXhpc1BvaW50ZXJUeXBlICYmIGF4aXNQb2ludGVyVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICB2YXIgZWxTdHlsZSA9IHZpZXdIZWxwZXIuYnVpbGRFbFN0eWxlKGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgdmFyIHBvaW50ZXJPcHRpb24gPSBwb2ludGVyU2hhcGVCdWlsZGVyW2F4aXNQb2ludGVyVHlwZV0oYXhpcywgcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnQpO1xuICAgICAgcG9pbnRlck9wdGlvbi5zdHlsZSA9IGVsU3R5bGU7XG4gICAgICBlbE9wdGlvbi5ncmFwaGljS2V5ID0gcG9pbnRlck9wdGlvbi50eXBlO1xuICAgICAgZWxPcHRpb24ucG9pbnRlciA9IHBvaW50ZXJPcHRpb247XG4gICAgfVxuICAgIHZhciBsYXlvdXRJbmZvID0gY2FydGVzaWFuQXhpc0hlbHBlci5sYXlvdXQoZ3JpZC5tb2RlbCwgYXhpc01vZGVsKTtcbiAgICB2aWV3SGVscGVyLmJ1aWxkQ2FydGVzaWFuU2luZ2xlTGFiZWxFbE9wdGlvbihcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFsdWUsIGVsT3B0aW9uLCBsYXlvdXRJbmZvLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBDYXJ0ZXNpYW5BeGlzUG9pbnRlci5wcm90b3R5cGUuZ2V0SGFuZGxlVHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICB2YXIgbGF5b3V0SW5mbyA9IGNhcnRlc2lhbkF4aXNIZWxwZXIubGF5b3V0KGF4aXNNb2RlbC5heGlzLmdyaWQubW9kZWwsIGF4aXNNb2RlbCwge1xuICAgICAgbGFiZWxJbnNpZGU6IGZhbHNlXG4gICAgfSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGxheW91dEluZm8ubGFiZWxNYXJnaW4gPSBheGlzUG9pbnRlck1vZGVsLmdldChbJ2hhbmRsZScsICdtYXJnaW4nXSk7XG4gICAgdmFyIHBvcyA9IHZpZXdIZWxwZXIuZ2V0VHJhbnNmb3JtZWRQb3NpdGlvbihheGlzTW9kZWwuYXhpcywgdmFsdWUsIGxheW91dEluZm8pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwb3NbMF0sXG4gICAgICB5OiBwb3NbMV0sXG4gICAgICByb3RhdGlvbjogbGF5b3V0SW5mby5yb3RhdGlvbiArIChsYXlvdXRJbmZvLmxhYmVsRGlyZWN0aW9uIDwgMCA/IE1hdGguUEkgOiAwKVxuICAgIH07XG4gIH07XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBDYXJ0ZXNpYW5BeGlzUG9pbnRlci5wcm90b3R5cGUudXBkYXRlSGFuZGxlVHJhbnNmb3JtID0gZnVuY3Rpb24gKHRyYW5zZm9ybSwgZGVsdGEsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIGdyaWQgPSBheGlzLmdyaWQ7XG4gICAgdmFyIGF4aXNFeHRlbnQgPSBheGlzLmdldEdsb2JhbEV4dGVudCh0cnVlKTtcbiAgICB2YXIgb3RoZXJFeHRlbnQgPSBnZXRDYXJ0ZXNpYW4oZ3JpZCwgYXhpcykuZ2V0T3RoZXJBeGlzKGF4aXMpLmdldEdsb2JhbEV4dGVudCgpO1xuICAgIHZhciBkaW1JbmRleCA9IGF4aXMuZGltID09PSAneCcgPyAwIDogMTtcbiAgICB2YXIgY3VyclBvc2l0aW9uID0gW3RyYW5zZm9ybS54LCB0cmFuc2Zvcm0ueV07XG4gICAgY3VyclBvc2l0aW9uW2RpbUluZGV4XSArPSBkZWx0YVtkaW1JbmRleF07XG4gICAgY3VyclBvc2l0aW9uW2RpbUluZGV4XSA9IE1hdGgubWluKGF4aXNFeHRlbnRbMV0sIGN1cnJQb3NpdGlvbltkaW1JbmRleF0pO1xuICAgIGN1cnJQb3NpdGlvbltkaW1JbmRleF0gPSBNYXRoLm1heChheGlzRXh0ZW50WzBdLCBjdXJyUG9zaXRpb25bZGltSW5kZXhdKTtcbiAgICB2YXIgY3Vyc29yT3RoZXJWYWx1ZSA9IChvdGhlckV4dGVudFsxXSArIG90aGVyRXh0ZW50WzBdKSAvIDI7XG4gICAgdmFyIGN1cnNvclBvaW50ID0gW2N1cnNvck90aGVyVmFsdWUsIGN1cnNvck90aGVyVmFsdWVdO1xuICAgIGN1cnNvclBvaW50W2RpbUluZGV4XSA9IGN1cnJQb3NpdGlvbltkaW1JbmRleF07XG4gICAgLy8gTWFrZSB0b29sdGlwIGRvIG5vdCBvdmVybGFwIGF4aXNQb2ludGVyIGFuZCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBncmlkLlxuICAgIHZhciB0b29sdGlwT3B0aW9ucyA9IFt7XG4gICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJ1xuICAgIH0sIHtcbiAgICAgIGFsaWduOiAnY2VudGVyJ1xuICAgIH1dO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBjdXJyUG9zaXRpb25bMF0sXG4gICAgICB5OiBjdXJyUG9zaXRpb25bMV0sXG4gICAgICByb3RhdGlvbjogdHJhbnNmb3JtLnJvdGF0aW9uLFxuICAgICAgY3Vyc29yUG9pbnQ6IGN1cnNvclBvaW50LFxuICAgICAgdG9vbHRpcE9wdGlvbjogdG9vbHRpcE9wdGlvbnNbZGltSW5kZXhdXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIENhcnRlc2lhbkF4aXNQb2ludGVyO1xufShCYXNlQXhpc1BvaW50ZXIpO1xuZnVuY3Rpb24gZ2V0Q2FydGVzaWFuKGdyaWQsIGF4aXMpIHtcbiAgdmFyIG9wdCA9IHt9O1xuICBvcHRbYXhpcy5kaW0gKyAnQXhpc0luZGV4J10gPSBheGlzLmluZGV4O1xuICByZXR1cm4gZ3JpZC5nZXRDYXJ0ZXNpYW4ob3B0KTtcbn1cbnZhciBwb2ludGVyU2hhcGVCdWlsZGVyID0ge1xuICBsaW5lOiBmdW5jdGlvbiAoYXhpcywgcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnQpIHtcbiAgICB2YXIgdGFyZ2V0U2hhcGUgPSB2aWV3SGVscGVyLm1ha2VMaW5lU2hhcGUoW3BpeGVsVmFsdWUsIG90aGVyRXh0ZW50WzBdXSwgW3BpeGVsVmFsdWUsIG90aGVyRXh0ZW50WzFdXSwgZ2V0QXhpc0RpbUluZGV4KGF4aXMpKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0xpbmUnLFxuICAgICAgc3ViUGl4ZWxPcHRpbWl6ZTogdHJ1ZSxcbiAgICAgIHNoYXBlOiB0YXJnZXRTaGFwZVxuICAgIH07XG4gIH0sXG4gIHNoYWRvdzogZnVuY3Rpb24gKGF4aXMsIHBpeGVsVmFsdWUsIG90aGVyRXh0ZW50KSB7XG4gICAgdmFyIGJhbmRXaWR0aCA9IE1hdGgubWF4KDEsIGF4aXMuZ2V0QmFuZFdpZHRoKCkpO1xuICAgIHZhciBzcGFuID0gb3RoZXJFeHRlbnRbMV0gLSBvdGhlckV4dGVudFswXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1JlY3QnLFxuICAgICAgc2hhcGU6IHZpZXdIZWxwZXIubWFrZVJlY3RTaGFwZShbcGl4ZWxWYWx1ZSAtIGJhbmRXaWR0aCAvIDIsIG90aGVyRXh0ZW50WzBdXSwgW2JhbmRXaWR0aCwgc3Bhbl0sIGdldEF4aXNEaW1JbmRleChheGlzKSlcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0QXhpc0RpbUluZGV4KGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMuZGltID09PSAneCcgPyAwIDogMTtcbn1cbmV4cG9ydCBkZWZhdWx0IENhcnRlc2lhbkF4aXNQb2ludGVyOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50LmpzJztcbnZhciBBeGlzUG9pbnRlck1vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEF4aXNQb2ludGVyTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEF4aXNQb2ludGVyTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IEF4aXNQb2ludGVyTW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgQXhpc1BvaW50ZXJNb2RlbC50eXBlID0gJ2F4aXNQb2ludGVyJztcbiAgQXhpc1BvaW50ZXJNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIC8vICdhdXRvJyBtZWFucyB0aGF0IHNob3cgd2hlbiB0cmlnZ2VyZWQgYnkgdG9vbHRpcCBvciBoYW5kbGUuXG4gICAgc2hvdzogJ2F1dG8nLFxuICAgIC8vIHpsZXZlbDogMCxcbiAgICB6OiA1MCxcbiAgICB0eXBlOiAnbGluZScsXG4gICAgLy8gYXhpc3BvaW50ZXIgdHJpZ2dlcmVkIGJ5IHRvb3RpcCBkZXRlcm1pbmUgc25hcCBhdXRvbWF0aWNhbGx5LFxuICAgIC8vIHNlZSBgbW9kZWxIZWxwZXJgLlxuICAgIHNuYXA6IGZhbHNlLFxuICAgIHRyaWdnZXJUb29sdGlwOiB0cnVlLFxuICAgIHRyaWdnZXJFbXBoYXNpczogdHJ1ZSxcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBzdGF0dXM6IG51bGwsXG4gICAgbGluazogW10sXG4gICAgLy8gRG8gbm90IHNldCAnYXV0bycgaGVyZSwgb3RoZXJ3aXNlIGdsb2JhbCBhbmltYXRpb246IGZhbHNlXG4gICAgLy8gd2lsbCBub3QgZWZmZWN0IGF0IHRoaXMgYXhpc3BvaW50ZXIuXG4gICAgYW5pbWF0aW9uOiBudWxsLFxuICAgIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlOiAyMDAsXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNCOUJFQzknLFxuICAgICAgd2lkdGg6IDEsXG4gICAgICB0eXBlOiAnZGFzaGVkJ1xuICAgIH0sXG4gICAgc2hhZG93U3R5bGU6IHtcbiAgICAgIGNvbG9yOiAncmdiYSgyMTAsMjE5LDIzOCwwLjIpJ1xuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBmb3JtYXR0ZXI6IG51bGwsXG4gICAgICBwcmVjaXNpb246ICdhdXRvJyxcbiAgICAgIG1hcmdpbjogMyxcbiAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICBwYWRkaW5nOiBbNSwgNywgNSwgN10sXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdhdXRvJyxcbiAgICAgIGJvcmRlckNvbG9yOiBudWxsLFxuICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICBib3JkZXJSYWRpdXM6IDNcbiAgICB9LFxuICAgIGhhbmRsZToge1xuICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGljb246ICdNMTAuNywxMS45di0xLjNIOS4zdjEuM2MtNC45LDAuMy04LjgsNC40LTguOCw5LjRjMCw1LDMuOSw5LjEsOC44LDkuNGgxLjNjNC45LTAuMyw4LjgtNC40LDguOC05LjRDMTkuNSwxNi4zLDE1LjYsMTIuMiwxMC43LDExLjl6IE0xMy4zLDI0LjRINi43di0xLjJoNi42eiBNMTMuMywyMkg2Ljd2LTEuMmg2LjZ6IE0xMy4zLDE5LjZINi43di0xLjJoNi42eicsXG4gICAgICBzaXplOiA0NSxcbiAgICAgIC8vIGhhbmRsZSBtYXJnaW4gaXMgZnJvbSBzeW1ib2wgY2VudGVyIHRvIGF4aXMsIHdoaWNoIGlzIHN0YWJsZSB3aGVuIGNpcmN1bGFyIG1vdmUuXG4gICAgICBtYXJnaW46IDUwLFxuICAgICAgLy8gY29sb3I6ICcjMWI4YmJkJ1xuICAgICAgLy8gY29sb3I6ICcjMmY0NTU0J1xuICAgICAgY29sb3I6ICcjMzMzJyxcbiAgICAgIHNoYWRvd0JsdXI6IDMsXG4gICAgICBzaGFkb3dDb2xvcjogJyNhYWEnLFxuICAgICAgc2hhZG93T2Zmc2V0WDogMCxcbiAgICAgIHNoYWRvd09mZnNldFk6IDIsXG4gICAgICAvLyBGb3IgbW9iaWxlIHBlcmZvcm1hbmNlXG4gICAgICB0aHJvdHRsZTogNDBcbiAgICB9XG4gIH07XG4gIHJldHVybiBBeGlzUG9pbnRlck1vZGVsO1xufShDb21wb25lbnRNb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBBeGlzUG9pbnRlck1vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBnbG9iYWxMaXN0ZW5lciBmcm9tICcuL2dsb2JhbExpc3RlbmVyLmpzJztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50LmpzJztcbnZhciBBeGlzUG9pbnRlclZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQXhpc1BvaW50ZXJWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBBeGlzUG9pbnRlclZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IEF4aXNQb2ludGVyVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBBeGlzUG9pbnRlclZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChnbG9iYWxBeGlzUG9pbnRlck1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZ2xvYmFsVG9vbHRpcE1vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3Rvb2x0aXAnKTtcbiAgICB2YXIgdHJpZ2dlck9uID0gZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3RyaWdnZXJPbicpIHx8IGdsb2JhbFRvb2x0aXBNb2RlbCAmJiBnbG9iYWxUb29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyT24nKSB8fCAnbW91c2Vtb3ZlfGNsaWNrJztcbiAgICAvLyBSZWdpc3RlciBnbG9iYWwgbGlzdGVuZXIgaW4gQXhpc1BvaW50ZXJWaWV3IHRvIGVuYWJsZVxuICAgIC8vIEF4aXNQb2ludGVyVmlldyB0byBiZSBpbmRlcGVuZGVudCB0byBUb29sdGlwLlxuICAgIGdsb2JhbExpc3RlbmVyLnJlZ2lzdGVyKCdheGlzUG9pbnRlcicsIGFwaSwgZnVuY3Rpb24gKGN1cnJUcmlnZ2VyLCBlLCBkaXNwYXRjaEFjdGlvbikge1xuICAgICAgLy8gSWYgJ25vbmUnLCBpdCBpcyBub3QgY29udHJvbGxlZCBieSBtb3VzZSB0b3RhbGx5LlxuICAgICAgaWYgKHRyaWdnZXJPbiAhPT0gJ25vbmUnICYmIChjdXJyVHJpZ2dlciA9PT0gJ2xlYXZlJyB8fCB0cmlnZ2VyT24uaW5kZXhPZihjdXJyVHJpZ2dlcikgPj0gMCkpIHtcbiAgICAgICAgZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgIHR5cGU6ICd1cGRhdGVBeGlzUG9pbnRlcicsXG4gICAgICAgICAgY3VyclRyaWdnZXI6IGN1cnJUcmlnZ2VyLFxuICAgICAgICAgIHg6IGUgJiYgZS5vZmZzZXRYLFxuICAgICAgICAgIHk6IGUgJiYgZS5vZmZzZXRZXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBBeGlzUG9pbnRlclZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBnbG9iYWxMaXN0ZW5lci51bnJlZ2lzdGVyKCdheGlzUG9pbnRlcicsIGFwaSk7XG4gIH07XG4gIEF4aXNQb2ludGVyVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBnbG9iYWxMaXN0ZW5lci51bnJlZ2lzdGVyKCdheGlzUG9pbnRlcicsIGFwaSk7XG4gIH07XG4gIEF4aXNQb2ludGVyVmlldy50eXBlID0gJ2F4aXNQb2ludGVyJztcbiAgcmV0dXJuIEF4aXNQb2ludGVyVmlldztcbn0oQ29tcG9uZW50Vmlldyk7XG5leHBvcnQgZGVmYXVsdCBBeGlzUG9pbnRlclZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCAqIGFzIG1vZGVsSGVscGVyIGZyb20gJy4vbW9kZWxIZWxwZXIuanMnO1xuaW1wb3J0IGZpbmRQb2ludEZyb21TZXJpZXMgZnJvbSAnLi9maW5kUG9pbnRGcm9tU2VyaWVzLmpzJztcbmltcG9ydCB7IGVhY2gsIGN1cnJ5LCBiaW5kLCBleHRlbmQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xudmFyIGlubmVyID0gbWFrZUlubmVyKCk7XG4vKipcclxuICogQmFzaWMgbG9naWM6IGNoZWNrIGFsbCBheGlzLCBpZiB0aGV5IGRvIG5vdCBkZW1hbmQgc2hvdy9oaWdobGlnaHQsXHJcbiAqIHRoZW4gaGlkZS9kb3ducGxheSB0aGVtLlxyXG4gKlxyXG4gKiBAcmV0dXJuIGNvbnRlbnQgb2YgZXZlbnQgb2JqIGZvciBlY2hhcnRzLmNvbm5lY3QuXHJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXhpc1RyaWdnZXIocGF5bG9hZCwgZWNNb2RlbCwgYXBpKSB7XG4gIHZhciBjdXJyVHJpZ2dlciA9IHBheWxvYWQuY3VyclRyaWdnZXI7XG4gIHZhciBwb2ludCA9IFtwYXlsb2FkLngsIHBheWxvYWQueV07XG4gIHZhciBmaW5kZXIgPSBwYXlsb2FkO1xuICB2YXIgZGlzcGF0Y2hBY3Rpb24gPSBwYXlsb2FkLmRpc3BhdGNoQWN0aW9uIHx8IGJpbmQoYXBpLmRpc3BhdGNoQWN0aW9uLCBhcGkpO1xuICB2YXIgY29vcmRTeXNBeGVzSW5mbyA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpLmNvb3JkU3lzQXhlc0luZm87XG4gIC8vIFBlbmRpbmdcbiAgLy8gU2VlICM2MTIxLiBCdXQgd2UgYXJlIG5vdCBhYmxlIHRvIHJlcHJvZHVjZSBpdCB5ZXQuXG4gIGlmICghY29vcmRTeXNBeGVzSW5mbykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaWxsZWdhbFBvaW50KHBvaW50KSkge1xuICAgIC8vIFVzZWQgaW4gdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgYGNvbm5lY3Rpb25gOiB1c2UgdGhlIHNhbXBsZSBzZXJpZXNJbmRleFxuICAgIC8vIGFuZCBkYXRhSW5kZXguIEFuZCBhbHNvIHVzZWQgaW4gdGhlIHRvb2x0aXBWaWV3IHRyaWdnZXIuXG4gICAgcG9pbnQgPSBmaW5kUG9pbnRGcm9tU2VyaWVzKHtcbiAgICAgIHNlcmllc0luZGV4OiBmaW5kZXIuc2VyaWVzSW5kZXgsXG4gICAgICAvLyBEbyBub3QgdXNlIGRhdGFJbmRleEluc2lkZSBmcm9tIG90aGVyIGVjIGluc3RhbmNlLlxuICAgICAgLy8gRklYTUU6IGF1dG8gZGV0ZWN0IGl0P1xuICAgICAgZGF0YUluZGV4OiBmaW5kZXIuZGF0YUluZGV4XG4gICAgfSwgZWNNb2RlbCkucG9pbnQ7XG4gIH1cbiAgdmFyIGlzSWxsZWdhbFBvaW50ID0gaWxsZWdhbFBvaW50KHBvaW50KTtcbiAgLy8gQXhpcyBhbmQgdmFsdWUgY2FuIGJlIHNwZWNpZmllZCB3aGVuIGNhbGxpbmcgZGlzcGF0Y2hBY3Rpb24oe3R5cGU6ICd1cGRhdGVBeGlzUG9pbnRlcid9KS5cbiAgLy8gTm90aWNlOiBJbiB0aGlzIGNhc2UsIGl0IGlzIGRpZmZpY3VsdCB0byBnZXQgdGhlIGBwb2ludGAgKHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBzaG93XG4gIC8vIHRvb2x0aXAsIHNvIGlmIHBvaW50IGlzIG5vdCBnaXZlbiwgd2UganVzdCB1c2UgdGhlIHBvaW50IGZvdW5kIGJ5IHNhbXBsZSBzZXJpZXNJbmRleFxuICAvLyBhbmQgZGF0YUluZGV4LlxuICB2YXIgaW5wdXRBeGVzSW5mbyA9IGZpbmRlci5heGVzSW5mbztcbiAgdmFyIGF4ZXNJbmZvID0gY29vcmRTeXNBeGVzSW5mby5heGVzSW5mbztcbiAgdmFyIHNob3VsZEhpZGUgPSBjdXJyVHJpZ2dlciA9PT0gJ2xlYXZlJyB8fCBpbGxlZ2FsUG9pbnQocG9pbnQpO1xuICB2YXIgb3V0cHV0UGF5bG9hZCA9IHt9O1xuICB2YXIgc2hvd1ZhbHVlTWFwID0ge307XG4gIHZhciBkYXRhQnlDb29yZFN5cyA9IHtcbiAgICBsaXN0OiBbXSxcbiAgICBtYXA6IHt9XG4gIH07XG4gIHZhciB1cGRhdGVycyA9IHtcbiAgICBzaG93UG9pbnRlcjogY3Vycnkoc2hvd1BvaW50ZXIsIHNob3dWYWx1ZU1hcCksXG4gICAgc2hvd1Rvb2x0aXA6IGN1cnJ5KHNob3dUb29sdGlwLCBkYXRhQnlDb29yZFN5cylcbiAgfTtcbiAgLy8gUHJvY2VzcyBmb3IgdHJpZ2dlcmVkIGF4ZXMuXG4gIGVhY2goY29vcmRTeXNBeGVzSW5mby5jb29yZFN5c01hcCwgZnVuY3Rpb24gKGNvb3JkU3lzLCBjb29yZFN5c0tleSkge1xuICAgIC8vIElmIGEgcG9pbnQgZ2l2ZW4sIGl0IG11c3QgYmUgY29udGFpbmVkIGJ5IHRoZSBjb29yZGluYXRlIHN5c3RlbS5cbiAgICB2YXIgY29vcmRTeXNDb250YWluc1BvaW50ID0gaXNJbGxlZ2FsUG9pbnQgfHwgY29vcmRTeXMuY29udGFpblBvaW50KHBvaW50KTtcbiAgICBlYWNoKGNvb3JkU3lzQXhlc0luZm8uY29vcmRTeXNBeGVzSW5mb1tjb29yZFN5c0tleV0sIGZ1bmN0aW9uIChheGlzSW5mbywga2V5KSB7XG4gICAgICB2YXIgYXhpcyA9IGF4aXNJbmZvLmF4aXM7XG4gICAgICB2YXIgaW5wdXRBeGlzSW5mbyA9IGZpbmRJbnB1dEF4aXNJbmZvKGlucHV0QXhlc0luZm8sIGF4aXNJbmZvKTtcbiAgICAgIC8vIElmIG5vIGlucHV0QXhlc0luZm8sIG5vIGF4aXMgaXMgcmVzdHJpY3RlZC5cbiAgICAgIGlmICghc2hvdWxkSGlkZSAmJiBjb29yZFN5c0NvbnRhaW5zUG9pbnQgJiYgKCFpbnB1dEF4ZXNJbmZvIHx8IGlucHV0QXhpc0luZm8pKSB7XG4gICAgICAgIHZhciB2YWwgPSBpbnB1dEF4aXNJbmZvICYmIGlucHV0QXhpc0luZm8udmFsdWU7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCAmJiAhaXNJbGxlZ2FsUG9pbnQpIHtcbiAgICAgICAgICB2YWwgPSBheGlzLnBvaW50VG9EYXRhKHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YWwgIT0gbnVsbCAmJiBwcm9jZXNzT25BeGlzKGF4aXNJbmZvLCB2YWwsIHVwZGF0ZXJzLCBmYWxzZSwgb3V0cHV0UGF5bG9hZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICAvLyBQcm9jZXNzIGZvciBsaW5rZWQgYXhlcy5cbiAgdmFyIGxpbmtUcmlnZ2VycyA9IHt9O1xuICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAodGFyQXhpc0luZm8sIHRhcktleSkge1xuICAgIHZhciBsaW5rR3JvdXAgPSB0YXJBeGlzSW5mby5saW5rR3JvdXA7XG4gICAgLy8gSWYgYXhpcyBoYXMgYmVlbiB0cmlnZ2VyZWQgaW4gdGhlIHByZXZpb3VzIHN0YWdlLCBpdCBzaG91bGQgbm90IGJlIHRyaWdnZXJlZCBieSBsaW5rLlxuICAgIGlmIChsaW5rR3JvdXAgJiYgIXNob3dWYWx1ZU1hcFt0YXJLZXldKSB7XG4gICAgICBlYWNoKGxpbmtHcm91cC5heGVzSW5mbywgZnVuY3Rpb24gKHNyY0F4aXNJbmZvLCBzcmNLZXkpIHtcbiAgICAgICAgdmFyIHNyY1ZhbEl0ZW0gPSBzaG93VmFsdWVNYXBbc3JjS2V5XTtcbiAgICAgICAgLy8gSWYgc3JjVmFsSXRlbSBleGlzdCwgc291cmNlIGF4aXMgaXMgdHJpZ2dlcmVkLCBzbyBsaW5rIHRvIHRhcmdldCBheGlzLlxuICAgICAgICBpZiAoc3JjQXhpc0luZm8gIT09IHRhckF4aXNJbmZvICYmIHNyY1ZhbEl0ZW0pIHtcbiAgICAgICAgICB2YXIgdmFsID0gc3JjVmFsSXRlbS52YWx1ZTtcbiAgICAgICAgICBsaW5rR3JvdXAubWFwcGVyICYmICh2YWwgPSB0YXJBeGlzSW5mby5heGlzLnNjYWxlLnBhcnNlKGxpbmtHcm91cC5tYXBwZXIodmFsLCBtYWtlTWFwcGVyUGFyYW0oc3JjQXhpc0luZm8pLCBtYWtlTWFwcGVyUGFyYW0odGFyQXhpc0luZm8pKSkpO1xuICAgICAgICAgIGxpbmtUcmlnZ2Vyc1t0YXJBeGlzSW5mby5rZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBlYWNoKGxpbmtUcmlnZ2VycywgZnVuY3Rpb24gKHZhbCwgdGFyS2V5KSB7XG4gICAgcHJvY2Vzc09uQXhpcyhheGVzSW5mb1t0YXJLZXldLCB2YWwsIHVwZGF0ZXJzLCB0cnVlLCBvdXRwdXRQYXlsb2FkKTtcbiAgfSk7XG4gIHVwZGF0ZU1vZGVsQWN0dWFsbHkoc2hvd1ZhbHVlTWFwLCBheGVzSW5mbywgb3V0cHV0UGF5bG9hZCk7XG4gIGRpc3BhdGNoVG9vbHRpcEFjdHVhbGx5KGRhdGFCeUNvb3JkU3lzLCBwb2ludCwgcGF5bG9hZCwgZGlzcGF0Y2hBY3Rpb24pO1xuICBkaXNwYXRjaEhpZ2hEb3duQWN0dWFsbHkoYXhlc0luZm8sIGRpc3BhdGNoQWN0aW9uLCBhcGkpO1xuICByZXR1cm4gb3V0cHV0UGF5bG9hZDtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NPbkF4aXMoYXhpc0luZm8sIG5ld1ZhbHVlLCB1cGRhdGVycywgbm9TbmFwLCBvdXRwdXRGaW5kZXIpIHtcbiAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICBpZiAoYXhpcy5zY2FsZS5pc0JsYW5rKCkgfHwgIWF4aXMuY29udGFpbkRhdGEobmV3VmFsdWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghYXhpc0luZm8uaW52b2x2ZVNlcmllcykge1xuICAgIHVwZGF0ZXJzLnNob3dQb2ludGVyKGF4aXNJbmZvLCBuZXdWYWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEhlYXZ5IGNhbGN1bGF0aW9uLiBTbyBwdXQgaXQgYWZ0ZXIgYXhpcy5jb250YWluRGF0YSBjaGVja2luZy5cbiAgdmFyIHBheWxvYWRJbmZvID0gYnVpbGRQYXlsb2Fkc0J5U2VyaWVzKG5ld1ZhbHVlLCBheGlzSW5mbyk7XG4gIHZhciBwYXlsb2FkQmF0Y2ggPSBwYXlsb2FkSW5mby5wYXlsb2FkQmF0Y2g7XG4gIHZhciBzbmFwVG9WYWx1ZSA9IHBheWxvYWRJbmZvLnNuYXBUb1ZhbHVlO1xuICAvLyBGaWxsIGNvbnRlbnQgb2YgZXZlbnQgb2JqIGZvciBlY2hhcnRzLmNvbm5lY3QuXG4gIC8vIEJ5IGRlZmF1bHQgdXNlIHRoZSBmaXJzdCBpbnZvbHZlZCBzZXJpZXMgZGF0YSBhcyBhIHNhbXBsZSB0byBjb25uZWN0LlxuICBpZiAocGF5bG9hZEJhdGNoWzBdICYmIG91dHB1dEZpbmRlci5zZXJpZXNJbmRleCA9PSBudWxsKSB7XG4gICAgZXh0ZW5kKG91dHB1dEZpbmRlciwgcGF5bG9hZEJhdGNoWzBdKTtcbiAgfVxuICAvLyBJZiBubyBsaW5rU291cmNlIGlucHV0LCB0aGlzIHByb2Nlc3MgaXMgZm9yIGNvbGxlY3RpbmcgbGlua1xuICAvLyB0YXJnZXQsIHdoZXJlIHNuYXAgc2hvdWxkIG5vdCBiZSBhY2NlcHRlZC5cbiAgaWYgKCFub1NuYXAgJiYgYXhpc0luZm8uc25hcCkge1xuICAgIGlmIChheGlzLmNvbnRhaW5EYXRhKHNuYXBUb1ZhbHVlKSAmJiBzbmFwVG9WYWx1ZSAhPSBudWxsKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNuYXBUb1ZhbHVlO1xuICAgIH1cbiAgfVxuICB1cGRhdGVycy5zaG93UG9pbnRlcihheGlzSW5mbywgbmV3VmFsdWUsIHBheWxvYWRCYXRjaCk7XG4gIC8vIFRvb2x0aXAgc2hvdWxkIGFsd2F5cyBiZSBzbmFwVG9WYWx1ZSwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IFwiYXhpcyB2YWx1ZSB+IHNlcmllcyB2YWx1ZVwiIG1hcHBpbmcgZGlzcGxheWVkIGluIHRvb2x0aXAuXG4gIHVwZGF0ZXJzLnNob3dUb29sdGlwKGF4aXNJbmZvLCBwYXlsb2FkSW5mbywgc25hcFRvVmFsdWUpO1xufVxuZnVuY3Rpb24gYnVpbGRQYXlsb2Fkc0J5U2VyaWVzKHZhbHVlLCBheGlzSW5mbykge1xuICB2YXIgYXhpcyA9IGF4aXNJbmZvLmF4aXM7XG4gIHZhciBkaW0gPSBheGlzLmRpbTtcbiAgdmFyIHNuYXBUb1ZhbHVlID0gdmFsdWU7XG4gIHZhciBwYXlsb2FkQmF0Y2ggPSBbXTtcbiAgdmFyIG1pbkRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICB2YXIgbWluRGlmZiA9IC0xO1xuICBlYWNoKGF4aXNJbmZvLnNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllcywgaWR4KSB7XG4gICAgdmFyIGRhdGFEaW0gPSBzZXJpZXMuZ2V0RGF0YSgpLm1hcERpbWVuc2lvbnNBbGwoZGltKTtcbiAgICB2YXIgc2VyaWVzTmVzdGVzdFZhbHVlO1xuICAgIHZhciBkYXRhSW5kaWNlcztcbiAgICBpZiAoc2VyaWVzLmdldEF4aXNUb29sdGlwRGF0YSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHNlcmllcy5nZXRBeGlzVG9vbHRpcERhdGEoZGF0YURpbSwgdmFsdWUsIGF4aXMpO1xuICAgICAgZGF0YUluZGljZXMgPSByZXN1bHQuZGF0YUluZGljZXM7XG4gICAgICBzZXJpZXNOZXN0ZXN0VmFsdWUgPSByZXN1bHQubmVzdGVzdFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhSW5kaWNlcyA9IHNlcmllcy5nZXREYXRhKCkuaW5kaWNlc09mTmVhcmVzdChkYXRhRGltWzBdLCB2YWx1ZSxcbiAgICAgIC8vIEFkZCBhIHRocmVzaG9sZCB0byBhdm9pZCBmaW5kIHRoZSB3cm9uZyBkYXRhSW5kZXhcbiAgICAgIC8vIHdoZW4gZGF0YSBsZW5ndGggaXMgbm90IHNhbWUuXG4gICAgICAvLyBmYWxzZSxcbiAgICAgIGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IDAuNSA6IG51bGwpO1xuICAgICAgaWYgKCFkYXRhSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VyaWVzTmVzdGVzdFZhbHVlID0gc2VyaWVzLmdldERhdGEoKS5nZXQoZGF0YURpbVswXSwgZGF0YUluZGljZXNbMF0pO1xuICAgIH1cbiAgICBpZiAoc2VyaWVzTmVzdGVzdFZhbHVlID09IG51bGwgfHwgIWlzRmluaXRlKHNlcmllc05lc3Rlc3RWYWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRpZmYgPSB2YWx1ZSAtIHNlcmllc05lc3Rlc3RWYWx1ZTtcbiAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGRpZmYpO1xuICAgIC8vIENvbnNpZGVyIGNhdGVnb3J5IGNhc2VcbiAgICBpZiAoZGlzdCA8PSBtaW5EaXN0KSB7XG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3QgfHwgZGlmZiA+PSAwICYmIG1pbkRpZmYgPCAwKSB7XG4gICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICBtaW5EaWZmID0gZGlmZjtcbiAgICAgICAgc25hcFRvVmFsdWUgPSBzZXJpZXNOZXN0ZXN0VmFsdWU7XG4gICAgICAgIHBheWxvYWRCYXRjaC5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgZWFjaChkYXRhSW5kaWNlcywgZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICBwYXlsb2FkQmF0Y2gucHVzaCh7XG4gICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllcy5zZXJpZXNJbmRleCxcbiAgICAgICAgICBkYXRhSW5kZXhJbnNpZGU6IGRhdGFJbmRleCxcbiAgICAgICAgICBkYXRhSW5kZXg6IHNlcmllcy5nZXREYXRhKCkuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcGF5bG9hZEJhdGNoOiBwYXlsb2FkQmF0Y2gsXG4gICAgc25hcFRvVmFsdWU6IHNuYXBUb1ZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBzaG93UG9pbnRlcihzaG93VmFsdWVNYXAsIGF4aXNJbmZvLCB2YWx1ZSwgcGF5bG9hZEJhdGNoKSB7XG4gIHNob3dWYWx1ZU1hcFtheGlzSW5mby5rZXldID0ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBwYXlsb2FkQmF0Y2g6IHBheWxvYWRCYXRjaFxuICB9O1xufVxuZnVuY3Rpb24gc2hvd1Rvb2x0aXAoZGF0YUJ5Q29vcmRTeXMsIGF4aXNJbmZvLCBwYXlsb2FkSW5mbywgdmFsdWUpIHtcbiAgdmFyIHBheWxvYWRCYXRjaCA9IHBheWxvYWRJbmZvLnBheWxvYWRCYXRjaDtcbiAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICB2YXIgYXhpc01vZGVsID0gYXhpcy5tb2RlbDtcbiAgdmFyIGF4aXNQb2ludGVyTW9kZWwgPSBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsO1xuICAvLyBJZiBubyBkYXRhLCBkbyBub3QgY3JlYXRlIGFueXRoaW5nIGluIGRhdGFCeUNvb3JkU3lzLFxuICAvLyB3aG9zZSBsZW5ndGggd2lsbCBiZSB1c2VkIHRvIGp1ZGdlIHdoZXRoZXIgZGlzcGF0Y2ggYWN0aW9uLlxuICBpZiAoIWF4aXNJbmZvLnRyaWdnZXJUb29sdGlwIHx8ICFwYXlsb2FkQmF0Y2gubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjb29yZFN5c01vZGVsID0gYXhpc0luZm8uY29vcmRTeXMubW9kZWw7XG4gIHZhciBjb29yZFN5c0tleSA9IG1vZGVsSGVscGVyLm1ha2VLZXkoY29vcmRTeXNNb2RlbCk7XG4gIHZhciBjb29yZFN5c0l0ZW0gPSBkYXRhQnlDb29yZFN5cy5tYXBbY29vcmRTeXNLZXldO1xuICBpZiAoIWNvb3JkU3lzSXRlbSkge1xuICAgIGNvb3JkU3lzSXRlbSA9IGRhdGFCeUNvb3JkU3lzLm1hcFtjb29yZFN5c0tleV0gPSB7XG4gICAgICBjb29yZFN5c0lkOiBjb29yZFN5c01vZGVsLmlkLFxuICAgICAgY29vcmRTeXNJbmRleDogY29vcmRTeXNNb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgIGNvb3JkU3lzVHlwZTogY29vcmRTeXNNb2RlbC50eXBlLFxuICAgICAgY29vcmRTeXNNYWluVHlwZTogY29vcmRTeXNNb2RlbC5tYWluVHlwZSxcbiAgICAgIGRhdGFCeUF4aXM6IFtdXG4gICAgfTtcbiAgICBkYXRhQnlDb29yZFN5cy5saXN0LnB1c2goY29vcmRTeXNJdGVtKTtcbiAgfVxuICBjb29yZFN5c0l0ZW0uZGF0YUJ5QXhpcy5wdXNoKHtcbiAgICBheGlzRGltOiBheGlzLmRpbSxcbiAgICBheGlzSW5kZXg6IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICBheGlzVHlwZTogYXhpc01vZGVsLnR5cGUsXG4gICAgYXhpc0lkOiBheGlzTW9kZWwuaWQsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIC8vIENhdXN0aW9uOiB2aWV3SGVscGVyLmdldFZhbHVlTGFiZWwgaXMgYWN0dWFsbHkgb24gXCJ2aWV3IHN0YWdlXCIsIHdoaWNoXG4gICAgLy8gZGVwZW5kcyB0aGF0IGFsbCBtb2RlbHMgaGF2ZSBiZWVuIHVwZGF0ZWQuIFNvIGl0IHNob3VsZCBub3QgYmUgcGVyZm9ybWVkXG4gICAgLy8gaGVyZS4gQ29uc2lkZXJpbmcgYXhpc1BvaW50ZXJNb2RlbCB1c2VkIGhlcmUgaXMgdm9sYXRpbGUsIHdoaWNoIGlzIGhhcmRcbiAgICAvLyB0byBiZSByZXRyaWV2ZSBpbiBUb29sdGlwVmlldywgd2UgcHJlcGFyZSBwYXJhbWV0ZXJzIGhlcmUuXG4gICAgdmFsdWVMYWJlbE9wdDoge1xuICAgICAgcHJlY2lzaW9uOiBheGlzUG9pbnRlck1vZGVsLmdldChbJ2xhYmVsJywgJ3ByZWNpc2lvbiddKSxcbiAgICAgIGZvcm1hdHRlcjogYXhpc1BvaW50ZXJNb2RlbC5nZXQoWydsYWJlbCcsICdmb3JtYXR0ZXInXSlcbiAgICB9LFxuICAgIHNlcmllc0RhdGFJbmRpY2VzOiBwYXlsb2FkQmF0Y2guc2xpY2UoKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsQWN0dWFsbHkoc2hvd1ZhbHVlTWFwLCBheGVzSW5mbywgb3V0cHV0UGF5bG9hZCkge1xuICB2YXIgb3V0cHV0QXhlc0luZm8gPSBvdXRwdXRQYXlsb2FkLmF4ZXNJbmZvID0gW107XG4gIC8vIEJhc2ljIGxvZ2ljOiBJZiBubyAnc2hvdycgcmVxdWlyZWQsICdoaWRlJyB0aGlzIGF4aXNQb2ludGVyLlxuICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAoYXhpc0luZm8sIGtleSkge1xuICAgIHZhciBvcHRpb24gPSBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsLm9wdGlvbjtcbiAgICB2YXIgdmFsSXRlbSA9IHNob3dWYWx1ZU1hcFtrZXldO1xuICAgIGlmICh2YWxJdGVtKSB7XG4gICAgICAhYXhpc0luZm8udXNlSGFuZGxlICYmIChvcHRpb24uc3RhdHVzID0gJ3Nob3cnKTtcbiAgICAgIG9wdGlvbi52YWx1ZSA9IHZhbEl0ZW0udmFsdWU7XG4gICAgICAvLyBGb3IgbGFiZWwgZm9ybWF0dGVyIHBhcmFtIGFuZCBoaWdobGlnaHQuXG4gICAgICBvcHRpb24uc2VyaWVzRGF0YUluZGljZXMgPSAodmFsSXRlbS5wYXlsb2FkQmF0Y2ggfHwgW10pLnNsaWNlKCk7XG4gICAgfVxuICAgIC8vIFdoZW4gYWx3YXlzIHNob3cgKGUuZy4sIGhhbmRsZSB1c2VkKSwgcmVtYWluXG4gICAgLy8gb3JpZ2luYWwgdmFsdWUgYW5kIHN0YXR1cy5cbiAgICBlbHNlIHtcbiAgICAgIC8vIElmIGhpZGUsIHZhbHVlIHN0aWxsIG5lZWQgdG8gYmUgc2V0LCBjb25zaWRlclxuICAgICAgLy8gY2xpY2sgbGVnZW5kIHRvIHRvZ2dsZSBheGlzIGJsYW5rLlxuICAgICAgIWF4aXNJbmZvLnVzZUhhbmRsZSAmJiAob3B0aW9uLnN0YXR1cyA9ICdoaWRlJyk7XG4gICAgfVxuICAgIC8vIElmIHN0YXR1cyBpcyAnaGlkZScsIHNob3VsZCBiZSBubyBpbmZvIGluIHBheWxvYWQuXG4gICAgb3B0aW9uLnN0YXR1cyA9PT0gJ3Nob3cnICYmIG91dHB1dEF4ZXNJbmZvLnB1c2goe1xuICAgICAgYXhpc0RpbTogYXhpc0luZm8uYXhpcy5kaW0sXG4gICAgICBheGlzSW5kZXg6IGF4aXNJbmZvLmF4aXMubW9kZWwuY29tcG9uZW50SW5kZXgsXG4gICAgICB2YWx1ZTogb3B0aW9uLnZhbHVlXG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hUb29sdGlwQWN0dWFsbHkoZGF0YUJ5Q29vcmRTeXMsIHBvaW50LCBwYXlsb2FkLCBkaXNwYXRjaEFjdGlvbikge1xuICAvLyBCYXNpYyBsb2dpYzogSWYgbm8gc2hvd1RpcCByZXF1aXJlZCwgaGlkZVRpcCB3aWxsIGJlIGRpc3BhdGNoZWQuXG4gIGlmIChpbGxlZ2FsUG9pbnQocG9pbnQpIHx8ICFkYXRhQnlDb29yZFN5cy5saXN0Lmxlbmd0aCkge1xuICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdoaWRlVGlwJ1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBJbiBtb3N0IGNhc2Ugb25seSBvbmUgYXhpcyAob3IgZXZlbnQgb25lIHNlcmllcyBpcyB1c2VkKS4gSXQgaXNcbiAgLy8gY29udmVuaWVudCB0byBmZXRjaCBwYXlsb2FkLnNlcmllc0luZGV4IGFuZCBwYXlsb2FkLmRhdGFJbmRleFxuICAvLyBkaXJlY3RseS4gU28gcHV0IHRoZSBmaXJzdCBzZXJpZXNJbmRleCBhbmQgZGF0YUluZGV4IG9mIHRoZSBmaXJzdFxuICAvLyBheGlzIG9uIHRoZSBwYXlsb2FkLlxuICB2YXIgc2FtcGxlSXRlbSA9ICgoZGF0YUJ5Q29vcmRTeXMubGlzdFswXS5kYXRhQnlBeGlzWzBdIHx8IHt9KS5zZXJpZXNEYXRhSW5kaWNlcyB8fCBbXSlbMF0gfHwge307XG4gIGRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgZXNjYXBlQ29ubmVjdDogdHJ1ZSxcbiAgICB4OiBwb2ludFswXSxcbiAgICB5OiBwb2ludFsxXSxcbiAgICB0b29sdGlwT3B0aW9uOiBwYXlsb2FkLnRvb2x0aXBPcHRpb24sXG4gICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXG4gICAgZGF0YUluZGV4SW5zaWRlOiBzYW1wbGVJdGVtLmRhdGFJbmRleEluc2lkZSxcbiAgICBkYXRhSW5kZXg6IHNhbXBsZUl0ZW0uZGF0YUluZGV4LFxuICAgIHNlcmllc0luZGV4OiBzYW1wbGVJdGVtLnNlcmllc0luZGV4LFxuICAgIGRhdGFCeUNvb3JkU3lzOiBkYXRhQnlDb29yZFN5cy5saXN0XG4gIH0pO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hIaWdoRG93bkFjdHVhbGx5KGF4ZXNJbmZvLCBkaXNwYXRjaEFjdGlvbiwgYXBpKSB7XG4gIC8vIEZJWE1FXG4gIC8vIGhpZ2hsaWdodCBzdGF0dXMgbW9kaWZpY2F0aW9uIHNob3VsZCBiZSBhIHN0YWdlIG9mIG1haW4gcHJvY2Vzcz9cbiAgLy8gKENvbnNpZGVyIGNvbmZpbGN0IChlLmcuLCBsZWdlbmQgYW5kIGF4aXNQb2ludGVyKSBhbmQgc2V0T3B0aW9uKVxuICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgdmFyIGhpZ2hEb3duS2V5ID0gJ2F4aXNQb2ludGVyTGFzdEhpZ2hsaWdodHMnO1xuICB2YXIgbGFzdEhpZ2hsaWdodHMgPSBpbm5lcih6cilbaGlnaERvd25LZXldIHx8IHt9O1xuICB2YXIgbmV3SGlnaGxpZ2h0cyA9IGlubmVyKHpyKVtoaWdoRG93bktleV0gPSB7fTtcbiAgLy8gVXBkYXRlIGhpZ2hsaWdodC9kb3ducGxheSBzdGF0dXMgYWNjb3JkaW5nIHRvIGF4aXNQb2ludGVyIG1vZGVsLlxuICAvLyBCdWlsZCBoYXNoIG1hcCBhbmQgcmVtb3ZlIGR1cGxpY2F0ZSBpbmNpZGVudGFsbHkuXG4gIGVhY2goYXhlc0luZm8sIGZ1bmN0aW9uIChheGlzSW5mbywga2V5KSB7XG4gICAgdmFyIG9wdGlvbiA9IGF4aXNJbmZvLmF4aXNQb2ludGVyTW9kZWwub3B0aW9uO1xuICAgIG9wdGlvbi5zdGF0dXMgPT09ICdzaG93JyAmJiBheGlzSW5mby50cmlnZ2VyRW1waGFzaXMgJiYgZWFjaChvcHRpb24uc2VyaWVzRGF0YUluZGljZXMsIGZ1bmN0aW9uIChiYXRjaEl0ZW0pIHtcbiAgICAgIHZhciBrZXkgPSBiYXRjaEl0ZW0uc2VyaWVzSW5kZXggKyAnIHwgJyArIGJhdGNoSXRlbS5kYXRhSW5kZXg7XG4gICAgICBuZXdIaWdobGlnaHRzW2tleV0gPSBiYXRjaEl0ZW07XG4gICAgfSk7XG4gIH0pO1xuICAvLyBEaWZmLlxuICB2YXIgdG9IaWdobGlnaHQgPSBbXTtcbiAgdmFyIHRvRG93bnBsYXkgPSBbXTtcbiAgZWFjaChsYXN0SGlnaGxpZ2h0cywgZnVuY3Rpb24gKGJhdGNoSXRlbSwga2V5KSB7XG4gICAgIW5ld0hpZ2hsaWdodHNba2V5XSAmJiB0b0Rvd25wbGF5LnB1c2goYmF0Y2hJdGVtKTtcbiAgfSk7XG4gIGVhY2gobmV3SGlnaGxpZ2h0cywgZnVuY3Rpb24gKGJhdGNoSXRlbSwga2V5KSB7XG4gICAgIWxhc3RIaWdobGlnaHRzW2tleV0gJiYgdG9IaWdobGlnaHQucHVzaChiYXRjaEl0ZW0pO1xuICB9KTtcbiAgdG9Eb3ducGxheS5sZW5ndGggJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAnZG93bnBsYXknLFxuICAgIGVzY2FwZUNvbm5lY3Q6IHRydWUsXG4gICAgLy8gTm90IGJsdXIgb3RoZXJzIHdoZW4gaGlnaGxpZ2h0IGluIGF4aXNQb2ludGVyLlxuICAgIG5vdEJsdXI6IHRydWUsXG4gICAgYmF0Y2g6IHRvRG93bnBsYXlcbiAgfSk7XG4gIHRvSGlnaGxpZ2h0Lmxlbmd0aCAmJiBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgIHR5cGU6ICdoaWdobGlnaHQnLFxuICAgIGVzY2FwZUNvbm5lY3Q6IHRydWUsXG4gICAgLy8gTm90IGJsdXIgb3RoZXJzIHdoZW4gaGlnaGxpZ2h0IGluIGF4aXNQb2ludGVyLlxuICAgIG5vdEJsdXI6IHRydWUsXG4gICAgYmF0Y2g6IHRvSGlnaGxpZ2h0XG4gIH0pO1xufVxuZnVuY3Rpb24gZmluZElucHV0QXhpc0luZm8oaW5wdXRBeGVzSW5mbywgYXhpc0luZm8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAoaW5wdXRBeGVzSW5mbyB8fCBbXSkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5wdXRBeGlzSW5mbyA9IGlucHV0QXhlc0luZm9baV07XG4gICAgaWYgKGF4aXNJbmZvLmF4aXMuZGltID09PSBpbnB1dEF4aXNJbmZvLmF4aXNEaW0gJiYgYXhpc0luZm8uYXhpcy5tb2RlbC5jb21wb25lbnRJbmRleCA9PT0gaW5wdXRBeGlzSW5mby5heGlzSW5kZXgpIHtcbiAgICAgIHJldHVybiBpbnB1dEF4aXNJbmZvO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFrZU1hcHBlclBhcmFtKGF4aXNJbmZvKSB7XG4gIHZhciBheGlzTW9kZWwgPSBheGlzSW5mby5heGlzLm1vZGVsO1xuICB2YXIgaXRlbSA9IHt9O1xuICB2YXIgZGltID0gaXRlbS5heGlzRGltID0gYXhpc0luZm8uYXhpcy5kaW07XG4gIGl0ZW0uYXhpc0luZGV4ID0gaXRlbVtkaW0gKyAnQXhpc0luZGV4J10gPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG4gIGl0ZW0uYXhpc05hbWUgPSBpdGVtW2RpbSArICdBeGlzTmFtZSddID0gYXhpc01vZGVsLm5hbWU7XG4gIGl0ZW0uYXhpc0lkID0gaXRlbVtkaW0gKyAnQXhpc0lkJ10gPSBheGlzTW9kZWwuaWQ7XG4gIHJldHVybiBpdGVtO1xufVxuZnVuY3Rpb24gaWxsZWdhbFBvaW50KHBvaW50KSB7XG4gIHJldHVybiAhcG9pbnQgfHwgcG9pbnRbMF0gPT0gbnVsbCB8fCBpc05hTihwb2ludFswXSkgfHwgcG9pbnRbMV0gPT0gbnVsbCB8fCBpc05hTihwb2ludFsxXSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgQXhpc1ZpZXcgZnJvbSAnLi4vYXhpcy9BeGlzVmlldy5qcyc7XG5pbXBvcnQgQ2FydGVzaWFuQXhpc1BvaW50ZXIgZnJvbSAnLi9DYXJ0ZXNpYW5BeGlzUG9pbnRlci5qcyc7XG5pbXBvcnQgQXhpc1BvaW50ZXJNb2RlbCBmcm9tICcuL0F4aXNQb2ludGVyTW9kZWwuanMnO1xuaW1wb3J0IEF4aXNQb2ludGVyVmlldyBmcm9tICcuL0F4aXNQb2ludGVyVmlldy5qcyc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGNvbGxlY3QgfSBmcm9tICcuL21vZGVsSGVscGVyLmpzJztcbmltcG9ydCBheGlzVHJpZ2dlciBmcm9tICcuL2F4aXNUcmlnZ2VyLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICAvLyBDYXJ0ZXNpYW5BeGlzUG9pbnRlciBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgcmVxdWlyZWQgaGVyZS4gQnV0IGNvbnNpZGVyXG4gIC8vIGVjaGFydHMuc2ltcGxlLmpzIGFuZCBvbmxpbmUgYnVpbGQgdG9vbHRpcCwgd2hpY2ggb25seSByZXF1aXJlIGdyaWRTaW1wbGUsXG4gIC8vIENhcnRlc2lhbkF4aXNQb2ludGVyIHNob3VsZCBiZSBhYmxlIHRvIHJlcXVpcmVkIHNvbWV3aGVyZS5cbiAgQXhpc1ZpZXcucmVnaXN0ZXJBeGlzUG9pbnRlckNsYXNzKCdDYXJ0ZXNpYW5BeGlzUG9pbnRlcicsIENhcnRlc2lhbkF4aXNQb2ludGVyKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50TW9kZWwoQXhpc1BvaW50ZXJNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoQXhpc1BvaW50ZXJWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAvLyBBbHdheXMgaGFzIGEgZ2xvYmFsIGF4aXNQb2ludGVyTW9kZWwgZm9yIGRlZmF1bHQgc2V0dGluZy5cbiAgICBpZiAob3B0aW9uKSB7XG4gICAgICAoIW9wdGlvbi5heGlzUG9pbnRlciB8fCBvcHRpb24uYXhpc1BvaW50ZXIubGVuZ3RoID09PSAwKSAmJiAob3B0aW9uLmF4aXNQb2ludGVyID0ge30pO1xuICAgICAgdmFyIGxpbmsgPSBvcHRpb24uYXhpc1BvaW50ZXIubGluaztcbiAgICAgIC8vIE5vcm1hbGl6ZSB0byBhcnJheSB0byBhdm9pZCBvYmplY3QgbWVyZ2luLiBCdXQgaWYgbGlua1xuICAgICAgLy8gaXMgbm90IHNldCwgcmVtYWluIG51bGwvdW5kZWZpbmVkLCBvdGhlcndpc2UgaXQgd2lsbFxuICAgICAgLy8gb3ZlcnJpZGUgZXhpc3RlbnQgbGluayBzZXR0aW5nLlxuICAgICAgaWYgKGxpbmsgJiYgIWlzQXJyYXkobGluaykpIHtcbiAgICAgICAgb3B0aW9uLmF4aXNQb2ludGVyLmxpbmsgPSBbbGlua107XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgLy8gVGhpcyBwcm9jZXNzIHNob3VsZCBwcm9mb3JtZWQgYWZ0ZXIgY29vcmRpbmF0ZSBzeXN0ZW1zIGNyZWF0ZWRcbiAgLy8gYW5kIHNlcmllcyBkYXRhIHByb2Nlc3NlZC4gU28gcHV0IGl0IG9uIHN0YXRpc3RpYyBwcm9jZXNzaW5nIHN0YWdlLlxuICByZWdpc3RlcnMucmVnaXN0ZXJQcm9jZXNzb3IocmVnaXN0ZXJzLlBSSU9SSVRZLlBST0NFU1NPUi5TVEFUSVNUSUMsIGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAvLyBCdWlsZCBheGlzUG9pbnRlck1vZGVsLCBtZXJnaW4gdG9vbHRpcC5heGlzUG9pbnRlciBtb2RlbCBmb3IgZWFjaCBheGlzLlxuICAgIC8vIGFsbEF4ZXNJbmZvIHNob3VsZCBiZSB1cGRhdGVkIHdoZW4gc2V0T3B0aW9uIHBlcmZvcm1lZC5cbiAgICBlY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKS5jb29yZFN5c0F4ZXNJbmZvID0gY29sbGVjdChlY01vZGVsLCBhcGkpO1xuICB9KTtcbiAgLy8gQnJvYWRjYXN0IHRvIGFsbCB2aWV3cy5cbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgIGV2ZW50OiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgIHVwZGF0ZTogJzp1cGRhdGVBeGlzUG9pbnRlcidcbiAgfSwgYXhpc1RyaWdnZXIpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///46524\n")},49890:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fo: () => (/* binding */ collect),\n/* harmony export */   Yc: () => (/* binding */ getAxisInfo),\n/* harmony export */   h_: () => (/* binding */ fixValue),\n/* harmony export */   mg: () => (/* binding */ getAxisPointerModel),\n/* harmony export */   og: () => (/* binding */ makeKey)\n/* harmony export */ });\n/* harmony import */ var _model_Model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43172);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n// Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n// allAxesInfo should be updated when setOption performed.\nfunction collect(ecModel, api) {\n  var result = {\n    /**\r\n     * key: makeKey(axis.model)\r\n     * value: {\r\n     *      axis,\r\n     *      coordSys,\r\n     *      axisPointerModel,\r\n     *      triggerTooltip,\r\n     *      triggerEmphasis,\r\n     *      involveSeries,\r\n     *      snap,\r\n     *      seriesModels,\r\n     *      seriesDataCount\r\n     * }\r\n     */\n    axesInfo: {},\n    seriesInvolved: false,\n    /**\r\n     * key: makeKey(coordSys.model)\r\n     * value: Object: key makeKey(axis.model), value: axisInfo\r\n     */\n    coordSysAxesInfo: {},\n    coordSysMap: {}\n  };\n  collectAxesInfo(result, ecModel, api);\n  // Check seriesInvolved for performance, in case too many series in some chart.\n  result.seriesInvolved && collectSeriesInfo(result, ecModel);\n  return result;\n}\nfunction collectAxesInfo(result, ecModel, api) {\n  var globalTooltipModel = ecModel.getComponent('tooltip');\n  var globalAxisPointerModel = ecModel.getComponent('axisPointer');\n  // links can only be set on global.\n  var linksOption = globalAxisPointerModel.get('link', true) || [];\n  var linkGroups = [];\n  // Collect axes info.\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(api.getCoordinateSystems(), function (coordSys) {\n    // Some coordinate system do not support axes, like geo.\n    if (!coordSys.axisPointerEnabled) {\n      return;\n    }\n    var coordSysKey = makeKey(coordSys.model);\n    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n    result.coordSysMap[coordSysKey] = coordSys;\n    // Set tooltip (like 'cross') is a convenient way to show axisPointer\n    // for user. So we enable setting tooltip on coordSys model.\n    var coordSysModel = coordSys.model;\n    var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(coordSys.getAxes(), (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.curry)(saveTooltipAxisInfo, false, null));\n    // If axis tooltip used, choose tooltip axis for each coordSys.\n    // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n    if (coordSys.getTooltipAxes && globalTooltipModel\n    // If tooltip.showContent is set as false, tooltip will not\n    // show but axisPointer will show as normal.\n    && baseTooltipModel.get('show')) {\n      // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n      // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n      var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n      var cross = baseTooltipModel.get(['axisPointer', 'type']) === 'cross';\n      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(['axisPointer', 'axis']));\n      if (triggerAxis || cross) {\n        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(tooltipAxes.baseAxes, (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.curry)(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));\n      }\n      if (cross) {\n        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(tooltipAxes.otherAxes, (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.curry)(saveTooltipAxisInfo, 'cross', false));\n      }\n    }\n    // fromTooltip: true | false | 'cross'\n    // triggerTooltip: true | false | null\n    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n      var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n      var axisPointerShow = axisPointerModel.get('show');\n      if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {\n        return;\n      }\n      if (triggerTooltip == null) {\n        triggerTooltip = axisPointerModel.get('triggerTooltip');\n      }\n      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;\n      var snap = axisPointerModel.get('snap');\n      var triggerEmphasis = axisPointerModel.get('triggerEmphasis');\n      var axisKey = makeKey(axis.model);\n      var involveSeries = triggerTooltip || snap || axis.type === 'category';\n      // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n      var axisInfo = result.axesInfo[axisKey] = {\n        key: axisKey,\n        axis: axis,\n        coordSys: coordSys,\n        axisPointerModel: axisPointerModel,\n        triggerTooltip: triggerTooltip,\n        triggerEmphasis: triggerEmphasis,\n        involveSeries: involveSeries,\n        snap: snap,\n        useHandle: isHandleTrigger(axisPointerModel),\n        seriesModels: [],\n        linkGroup: null\n      };\n      axesInfoInCoordSys[axisKey] = axisInfo;\n      result.seriesInvolved = result.seriesInvolved || involveSeries;\n      var groupIndex = getLinkGroupIndex(linksOption, axis);\n      if (groupIndex != null) {\n        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {\n          axesInfo: {}\n        });\n        linkGroup.axesInfo[axisKey] = axisInfo;\n        linkGroup.mapper = linksOption[groupIndex].mapper;\n        axisInfo.linkGroup = linkGroup;\n      }\n    }\n  });\n}\nfunction makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {\n  var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n  var fields = ['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'];\n  var volatileOption = {};\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(fields, function (field) {\n    volatileOption[field] = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.clone)(tooltipAxisPointerModel.get(field));\n  });\n  // category axis do not auto snap, otherwise some tick that do not\n  // has value can not be hovered. value/time/log axis default snap if\n  // triggered from tooltip and trigger tooltip.\n  volatileOption.snap = axis.type !== 'category' && !!triggerTooltip;\n  // Compatible with previous behavior, tooltip axis does not show label by default.\n  // Only these properties can be overridden from tooltip to axisPointer.\n  if (tooltipAxisPointerModel.get('type') === 'cross') {\n    volatileOption.type = 'line';\n  }\n  var labelOption = volatileOption.label || (volatileOption.label = {});\n  // Follow the convention, do not show label when triggered by tooltip by default.\n  labelOption.show == null && (labelOption.show = false);\n  if (fromTooltip === 'cross') {\n    // When 'cross', both axes show labels.\n    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(['label', 'show']);\n    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;\n    // If triggerTooltip, this is a base axis, which should better not use cross style\n    // (cross style is dashed by default)\n    if (!triggerTooltip) {\n      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n      crossStyle && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.defaults)(labelOption, crossStyle.textStyle);\n    }\n  }\n  return axis.model.getModel('axisPointer', new _model_Model_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A(volatileOption, globalAxisPointerModel, ecModel));\n}\nfunction collectSeriesInfo(result, ecModel) {\n  // Prepare data for axis trigger\n  ecModel.eachSeries(function (seriesModel) {\n    // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesTooltipTrigger = seriesModel.get(['tooltip', 'trigger'], true);\n    var seriesTooltipShow = seriesModel.get(['tooltip', 'show'], true);\n    if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get(['axisPointer', 'show'], true) === false) {\n      return;\n    }\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n      var axis = axisInfo.axis;\n      if (coordSys.getAxis(axis.dim) === axis) {\n        axisInfo.seriesModels.push(seriesModel);\n        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n        axisInfo.seriesDataCount += seriesModel.getData().count();\n      }\n    });\n  });\n}\n/**\r\n * For example:\r\n * {\r\n *     axisPointer: {\r\n *         links: [{\r\n *             xAxisIndex: [2, 4],\r\n *             yAxisIndex: 'all'\r\n *         }, {\r\n *             xAxisId: ['a5', 'a7'],\r\n *             xAxisName: 'xxx'\r\n *         }]\r\n *     }\r\n * }\r\n */\nfunction getLinkGroupIndex(linksOption, axis) {\n  var axisModel = axis.model;\n  var dim = axis.dim;\n  for (var i = 0; i < linksOption.length; i++) {\n    var linkOption = linksOption[i] || {};\n    if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {\n      return i;\n    }\n  }\n}\nfunction checkPropInLink(linkPropValue, axisPropValue) {\n  return linkPropValue === 'all' || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(linkPropValue) && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf)(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;\n}\nfunction fixValue(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n  if (!axisInfo) {\n    return;\n  }\n  var axisPointerModel = axisInfo.axisPointerModel;\n  var scale = axisInfo.axis.scale;\n  var option = axisPointerModel.option;\n  var status = axisPointerModel.get('status');\n  var value = axisPointerModel.get('value');\n  // Parse init value for category and time axis.\n  if (value != null) {\n    value = scale.parse(value);\n  }\n  var useHandle = isHandleTrigger(axisPointerModel);\n  // If `handle` used, `axisPointer` will always be displayed, so value\n  // and status should be initialized.\n  if (status == null) {\n    option.status = useHandle ? 'show' : 'hide';\n  }\n  var extent = scale.getExtent().slice();\n  extent[0] > extent[1] && extent.reverse();\n  if (\n  // Pick a value on axis when initializing.\n  value == null\n  // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n  // where we should re-pick a value to keep `handle` displaying normally.\n  || value > extent[1]) {\n    // Make handle displayed on the end of the axis when init, which looks better.\n    value = extent[1];\n  }\n  if (value < extent[0]) {\n    value = extent[0];\n  }\n  option.value = value;\n  if (useHandle) {\n    option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n  }\n}\nfunction getAxisInfo(axisModel) {\n  var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n}\nfunction getAxisPointerModel(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n  return axisInfo && axisInfo.axisPointerModel;\n}\nfunction isHandleTrigger(axisPointerModel) {\n  return !!axisPointerModel.get(['handle', 'show']);\n}\n/**\r\n * @param {module:echarts/model/Model} model\r\n * @return {string} unique key\r\n */\nfunction makeKey(model) {\n  return model.type + '||' + model.id;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk4OTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL21vZGVsSGVscGVyLmpzPzkwNWUiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvTW9kZWwuanMnO1xuaW1wb3J0IHsgZWFjaCwgY3VycnksIGNsb25lLCBkZWZhdWx0cywgaXNBcnJheSwgaW5kZXhPZiB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG4vLyBCdWlsZCBheGlzUG9pbnRlck1vZGVsLCBtZXJnaW4gdG9vbHRpcC5heGlzUG9pbnRlciBtb2RlbCBmb3IgZWFjaCBheGlzLlxuLy8gYWxsQXhlc0luZm8gc2hvdWxkIGJlIHVwZGF0ZWQgd2hlbiBzZXRPcHRpb24gcGVyZm9ybWVkLlxuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3QoZWNNb2RlbCwgYXBpKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBrZXk6IG1ha2VLZXkoYXhpcy5tb2RlbClcclxuICAgICAqIHZhbHVlOiB7XHJcbiAgICAgKiAgICAgIGF4aXMsXHJcbiAgICAgKiAgICAgIGNvb3JkU3lzLFxyXG4gICAgICogICAgICBheGlzUG9pbnRlck1vZGVsLFxyXG4gICAgICogICAgICB0cmlnZ2VyVG9vbHRpcCxcclxuICAgICAqICAgICAgdHJpZ2dlckVtcGhhc2lzLFxyXG4gICAgICogICAgICBpbnZvbHZlU2VyaWVzLFxyXG4gICAgICogICAgICBzbmFwLFxyXG4gICAgICogICAgICBzZXJpZXNNb2RlbHMsXHJcbiAgICAgKiAgICAgIHNlcmllc0RhdGFDb3VudFxyXG4gICAgICogfVxyXG4gICAgICovXG4gICAgYXhlc0luZm86IHt9LFxuICAgIHNlcmllc0ludm9sdmVkOiBmYWxzZSxcbiAgICAvKipcclxuICAgICAqIGtleTogbWFrZUtleShjb29yZFN5cy5tb2RlbClcclxuICAgICAqIHZhbHVlOiBPYmplY3Q6IGtleSBtYWtlS2V5KGF4aXMubW9kZWwpLCB2YWx1ZTogYXhpc0luZm9cclxuICAgICAqL1xuICAgIGNvb3JkU3lzQXhlc0luZm86IHt9LFxuICAgIGNvb3JkU3lzTWFwOiB7fVxuICB9O1xuICBjb2xsZWN0QXhlc0luZm8ocmVzdWx0LCBlY01vZGVsLCBhcGkpO1xuICAvLyBDaGVjayBzZXJpZXNJbnZvbHZlZCBmb3IgcGVyZm9ybWFuY2UsIGluIGNhc2UgdG9vIG1hbnkgc2VyaWVzIGluIHNvbWUgY2hhcnQuXG4gIHJlc3VsdC5zZXJpZXNJbnZvbHZlZCAmJiBjb2xsZWN0U2VyaWVzSW5mbyhyZXN1bHQsIGVjTW9kZWwpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29sbGVjdEF4ZXNJbmZvKHJlc3VsdCwgZWNNb2RlbCwgYXBpKSB7XG4gIHZhciBnbG9iYWxUb29sdGlwTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgndG9vbHRpcCcpO1xuICB2YXIgZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdheGlzUG9pbnRlcicpO1xuICAvLyBsaW5rcyBjYW4gb25seSBiZSBzZXQgb24gZ2xvYmFsLlxuICB2YXIgbGlua3NPcHRpb24gPSBnbG9iYWxBeGlzUG9pbnRlck1vZGVsLmdldCgnbGluaycsIHRydWUpIHx8IFtdO1xuICB2YXIgbGlua0dyb3VwcyA9IFtdO1xuICAvLyBDb2xsZWN0IGF4ZXMgaW5mby5cbiAgZWFjaChhcGkuZ2V0Q29vcmRpbmF0ZVN5c3RlbXMoKSwgZnVuY3Rpb24gKGNvb3JkU3lzKSB7XG4gICAgLy8gU29tZSBjb29yZGluYXRlIHN5c3RlbSBkbyBub3Qgc3VwcG9ydCBheGVzLCBsaWtlIGdlby5cbiAgICBpZiAoIWNvb3JkU3lzLmF4aXNQb2ludGVyRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY29vcmRTeXNLZXkgPSBtYWtlS2V5KGNvb3JkU3lzLm1vZGVsKTtcbiAgICB2YXIgYXhlc0luZm9JbkNvb3JkU3lzID0gcmVzdWx0LmNvb3JkU3lzQXhlc0luZm9bY29vcmRTeXNLZXldID0ge307XG4gICAgcmVzdWx0LmNvb3JkU3lzTWFwW2Nvb3JkU3lzS2V5XSA9IGNvb3JkU3lzO1xuICAgIC8vIFNldCB0b29sdGlwIChsaWtlICdjcm9zcycpIGlzIGEgY29udmVuaWVudCB3YXkgdG8gc2hvdyBheGlzUG9pbnRlclxuICAgIC8vIGZvciB1c2VyLiBTbyB3ZSBlbmFibGUgc2V0dGluZyB0b29sdGlwIG9uIGNvb3JkU3lzIG1vZGVsLlxuICAgIHZhciBjb29yZFN5c01vZGVsID0gY29vcmRTeXMubW9kZWw7XG4gICAgdmFyIGJhc2VUb29sdGlwTW9kZWwgPSBjb29yZFN5c01vZGVsLmdldE1vZGVsKCd0b29sdGlwJywgZ2xvYmFsVG9vbHRpcE1vZGVsKTtcbiAgICBlYWNoKGNvb3JkU3lzLmdldEF4ZXMoKSwgY3Vycnkoc2F2ZVRvb2x0aXBBeGlzSW5mbywgZmFsc2UsIG51bGwpKTtcbiAgICAvLyBJZiBheGlzIHRvb2x0aXAgdXNlZCwgY2hvb3NlIHRvb2x0aXAgYXhpcyBmb3IgZWFjaCBjb29yZFN5cy5cbiAgICAvLyBOb3RpY2UgdGhpcyBjYXNlOiBjb29yZFN5cyBpcyBgZ3JpZGAgYnV0IG5vdCBgY2FydGVzaWFuMkRgIGhlcmUuXG4gICAgaWYgKGNvb3JkU3lzLmdldFRvb2x0aXBBeGVzICYmIGdsb2JhbFRvb2x0aXBNb2RlbFxuICAgIC8vIElmIHRvb2x0aXAuc2hvd0NvbnRlbnQgaXMgc2V0IGFzIGZhbHNlLCB0b29sdGlwIHdpbGwgbm90XG4gICAgLy8gc2hvdyBidXQgYXhpc1BvaW50ZXIgd2lsbCBzaG93IGFzIG5vcm1hbC5cbiAgICAmJiBiYXNlVG9vbHRpcE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAvLyBDb21wYXRpYmxlIHdpdGggcHJldmlvdXMgbG9naWMuIEJ1dCBzZXJpZXMudG9vbHRpcC50cmlnZ2VyOiAnYXhpcydcbiAgICAgIC8vIG9yIHNlcmllcy5kYXRhW25dLnRvb2x0aXAudHJpZ2dlcjogJ2F4aXMnIGFyZSBub3Qgc3VwcG9ydCBhbnkgbW9yZS5cbiAgICAgIHZhciB0cmlnZ2VyQXhpcyA9IGJhc2VUb29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyJykgPT09ICdheGlzJztcbiAgICAgIHZhciBjcm9zcyA9IGJhc2VUb29sdGlwTW9kZWwuZ2V0KFsnYXhpc1BvaW50ZXInLCAndHlwZSddKSA9PT0gJ2Nyb3NzJztcbiAgICAgIHZhciB0b29sdGlwQXhlcyA9IGNvb3JkU3lzLmdldFRvb2x0aXBBeGVzKGJhc2VUb29sdGlwTW9kZWwuZ2V0KFsnYXhpc1BvaW50ZXInLCAnYXhpcyddKSk7XG4gICAgICBpZiAodHJpZ2dlckF4aXMgfHwgY3Jvc3MpIHtcbiAgICAgICAgZWFjaCh0b29sdGlwQXhlcy5iYXNlQXhlcywgY3Vycnkoc2F2ZVRvb2x0aXBBeGlzSW5mbywgY3Jvc3MgPyAnY3Jvc3MnIDogdHJ1ZSwgdHJpZ2dlckF4aXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjcm9zcykge1xuICAgICAgICBlYWNoKHRvb2x0aXBBeGVzLm90aGVyQXhlcywgY3Vycnkoc2F2ZVRvb2x0aXBBeGlzSW5mbywgJ2Nyb3NzJywgZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZnJvbVRvb2x0aXA6IHRydWUgfCBmYWxzZSB8ICdjcm9zcydcbiAgICAvLyB0cmlnZ2VyVG9vbHRpcDogdHJ1ZSB8IGZhbHNlIHwgbnVsbFxuICAgIGZ1bmN0aW9uIHNhdmVUb29sdGlwQXhpc0luZm8oZnJvbVRvb2x0aXAsIHRyaWdnZXJUb29sdGlwLCBheGlzKSB7XG4gICAgICB2YXIgYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXMubW9kZWwuZ2V0TW9kZWwoJ2F4aXNQb2ludGVyJywgZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICB2YXIgYXhpc1BvaW50ZXJTaG93ID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3Nob3cnKTtcbiAgICAgIGlmICghYXhpc1BvaW50ZXJTaG93IHx8IGF4aXNQb2ludGVyU2hvdyA9PT0gJ2F1dG8nICYmICFmcm9tVG9vbHRpcCAmJiAhaXNIYW5kbGVUcmlnZ2VyKGF4aXNQb2ludGVyTW9kZWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmlnZ2VyVG9vbHRpcCA9PSBudWxsKSB7XG4gICAgICAgIHRyaWdnZXJUb29sdGlwID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3RyaWdnZXJUb29sdGlwJyk7XG4gICAgICB9XG4gICAgICBheGlzUG9pbnRlck1vZGVsID0gZnJvbVRvb2x0aXAgPyBtYWtlQXhpc1BvaW50ZXJNb2RlbChheGlzLCBiYXNlVG9vbHRpcE1vZGVsLCBnbG9iYWxBeGlzUG9pbnRlck1vZGVsLCBlY01vZGVsLCBmcm9tVG9vbHRpcCwgdHJpZ2dlclRvb2x0aXApIDogYXhpc1BvaW50ZXJNb2RlbDtcbiAgICAgIHZhciBzbmFwID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3NuYXAnKTtcbiAgICAgIHZhciB0cmlnZ2VyRW1waGFzaXMgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndHJpZ2dlckVtcGhhc2lzJyk7XG4gICAgICB2YXIgYXhpc0tleSA9IG1ha2VLZXkoYXhpcy5tb2RlbCk7XG4gICAgICB2YXIgaW52b2x2ZVNlcmllcyA9IHRyaWdnZXJUb29sdGlwIHx8IHNuYXAgfHwgYXhpcy50eXBlID09PSAnY2F0ZWdvcnknO1xuICAgICAgLy8gSWYgcmVzdWx0LmF4ZXNJbmZvW2tleV0gZXhpc3QsIG92ZXJyaWRlIGl0ICh0b29sdGlwIGhhcyBoaWdoZXIgcHJpb3JpdHkpLlxuICAgICAgdmFyIGF4aXNJbmZvID0gcmVzdWx0LmF4ZXNJbmZvW2F4aXNLZXldID0ge1xuICAgICAgICBrZXk6IGF4aXNLZXksXG4gICAgICAgIGF4aXM6IGF4aXMsXG4gICAgICAgIGNvb3JkU3lzOiBjb29yZFN5cyxcbiAgICAgICAgYXhpc1BvaW50ZXJNb2RlbDogYXhpc1BvaW50ZXJNb2RlbCxcbiAgICAgICAgdHJpZ2dlclRvb2x0aXA6IHRyaWdnZXJUb29sdGlwLFxuICAgICAgICB0cmlnZ2VyRW1waGFzaXM6IHRyaWdnZXJFbXBoYXNpcyxcbiAgICAgICAgaW52b2x2ZVNlcmllczogaW52b2x2ZVNlcmllcyxcbiAgICAgICAgc25hcDogc25hcCxcbiAgICAgICAgdXNlSGFuZGxlOiBpc0hhbmRsZVRyaWdnZXIoYXhpc1BvaW50ZXJNb2RlbCksXG4gICAgICAgIHNlcmllc01vZGVsczogW10sXG4gICAgICAgIGxpbmtHcm91cDogbnVsbFxuICAgICAgfTtcbiAgICAgIGF4ZXNJbmZvSW5Db29yZFN5c1theGlzS2V5XSA9IGF4aXNJbmZvO1xuICAgICAgcmVzdWx0LnNlcmllc0ludm9sdmVkID0gcmVzdWx0LnNlcmllc0ludm9sdmVkIHx8IGludm9sdmVTZXJpZXM7XG4gICAgICB2YXIgZ3JvdXBJbmRleCA9IGdldExpbmtHcm91cEluZGV4KGxpbmtzT3B0aW9uLCBheGlzKTtcbiAgICAgIGlmIChncm91cEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxpbmtHcm91cCA9IGxpbmtHcm91cHNbZ3JvdXBJbmRleF0gfHwgKGxpbmtHcm91cHNbZ3JvdXBJbmRleF0gPSB7XG4gICAgICAgICAgYXhlc0luZm86IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBsaW5rR3JvdXAuYXhlc0luZm9bYXhpc0tleV0gPSBheGlzSW5mbztcbiAgICAgICAgbGlua0dyb3VwLm1hcHBlciA9IGxpbmtzT3B0aW9uW2dyb3VwSW5kZXhdLm1hcHBlcjtcbiAgICAgICAgYXhpc0luZm8ubGlua0dyb3VwID0gbGlua0dyb3VwO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBtYWtlQXhpc1BvaW50ZXJNb2RlbChheGlzLCBiYXNlVG9vbHRpcE1vZGVsLCBnbG9iYWxBeGlzUG9pbnRlck1vZGVsLCBlY01vZGVsLCBmcm9tVG9vbHRpcCwgdHJpZ2dlclRvb2x0aXApIHtcbiAgdmFyIHRvb2x0aXBBeGlzUG9pbnRlck1vZGVsID0gYmFzZVRvb2x0aXBNb2RlbC5nZXRNb2RlbCgnYXhpc1BvaW50ZXInKTtcbiAgdmFyIGZpZWxkcyA9IFsndHlwZScsICdzbmFwJywgJ2xpbmVTdHlsZScsICdzaGFkb3dTdHlsZScsICdsYWJlbCcsICdhbmltYXRpb24nLCAnYW5pbWF0aW9uRHVyYXRpb25VcGRhdGUnLCAnYW5pbWF0aW9uRWFzaW5nVXBkYXRlJywgJ3onXTtcbiAgdmFyIHZvbGF0aWxlT3B0aW9uID0ge307XG4gIGVhY2goZmllbGRzLCBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICB2b2xhdGlsZU9wdGlvbltmaWVsZF0gPSBjbG9uZSh0b29sdGlwQXhpc1BvaW50ZXJNb2RlbC5nZXQoZmllbGQpKTtcbiAgfSk7XG4gIC8vIGNhdGVnb3J5IGF4aXMgZG8gbm90IGF1dG8gc25hcCwgb3RoZXJ3aXNlIHNvbWUgdGljayB0aGF0IGRvIG5vdFxuICAvLyBoYXMgdmFsdWUgY2FuIG5vdCBiZSBob3ZlcmVkLiB2YWx1ZS90aW1lL2xvZyBheGlzIGRlZmF1bHQgc25hcCBpZlxuICAvLyB0cmlnZ2VyZWQgZnJvbSB0b29sdGlwIGFuZCB0cmlnZ2VyIHRvb2x0aXAuXG4gIHZvbGF0aWxlT3B0aW9uLnNuYXAgPSBheGlzLnR5cGUgIT09ICdjYXRlZ29yeScgJiYgISF0cmlnZ2VyVG9vbHRpcDtcbiAgLy8gQ29tcGF0aWJsZSB3aXRoIHByZXZpb3VzIGJlaGF2aW9yLCB0b29sdGlwIGF4aXMgZG9lcyBub3Qgc2hvdyBsYWJlbCBieSBkZWZhdWx0LlxuICAvLyBPbmx5IHRoZXNlIHByb3BlcnRpZXMgY2FuIGJlIG92ZXJyaWRkZW4gZnJvbSB0b29sdGlwIHRvIGF4aXNQb2ludGVyLlxuICBpZiAodG9vbHRpcEF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJykgPT09ICdjcm9zcycpIHtcbiAgICB2b2xhdGlsZU9wdGlvbi50eXBlID0gJ2xpbmUnO1xuICB9XG4gIHZhciBsYWJlbE9wdGlvbiA9IHZvbGF0aWxlT3B0aW9uLmxhYmVsIHx8ICh2b2xhdGlsZU9wdGlvbi5sYWJlbCA9IHt9KTtcbiAgLy8gRm9sbG93IHRoZSBjb252ZW50aW9uLCBkbyBub3Qgc2hvdyBsYWJlbCB3aGVuIHRyaWdnZXJlZCBieSB0b29sdGlwIGJ5IGRlZmF1bHQuXG4gIGxhYmVsT3B0aW9uLnNob3cgPT0gbnVsbCAmJiAobGFiZWxPcHRpb24uc2hvdyA9IGZhbHNlKTtcbiAgaWYgKGZyb21Ub29sdGlwID09PSAnY3Jvc3MnKSB7XG4gICAgLy8gV2hlbiAnY3Jvc3MnLCBib3RoIGF4ZXMgc2hvdyBsYWJlbHMuXG4gICAgdmFyIHRvb2x0aXBBeGlzUG9pbnRlckxhYmVsU2hvdyA9IHRvb2x0aXBBeGlzUG9pbnRlck1vZGVsLmdldChbJ2xhYmVsJywgJ3Nob3cnXSk7XG4gICAgbGFiZWxPcHRpb24uc2hvdyA9IHRvb2x0aXBBeGlzUG9pbnRlckxhYmVsU2hvdyAhPSBudWxsID8gdG9vbHRpcEF4aXNQb2ludGVyTGFiZWxTaG93IDogdHJ1ZTtcbiAgICAvLyBJZiB0cmlnZ2VyVG9vbHRpcCwgdGhpcyBpcyBhIGJhc2UgYXhpcywgd2hpY2ggc2hvdWxkIGJldHRlciBub3QgdXNlIGNyb3NzIHN0eWxlXG4gICAgLy8gKGNyb3NzIHN0eWxlIGlzIGRhc2hlZCBieSBkZWZhdWx0KVxuICAgIGlmICghdHJpZ2dlclRvb2x0aXApIHtcbiAgICAgIHZhciBjcm9zc1N0eWxlID0gdm9sYXRpbGVPcHRpb24ubGluZVN0eWxlID0gdG9vbHRpcEF4aXNQb2ludGVyTW9kZWwuZ2V0KCdjcm9zc1N0eWxlJyk7XG4gICAgICBjcm9zc1N0eWxlICYmIGRlZmF1bHRzKGxhYmVsT3B0aW9uLCBjcm9zc1N0eWxlLnRleHRTdHlsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBheGlzLm1vZGVsLmdldE1vZGVsKCdheGlzUG9pbnRlcicsIG5ldyBNb2RlbCh2b2xhdGlsZU9wdGlvbiwgZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCwgZWNNb2RlbCkpO1xufVxuZnVuY3Rpb24gY29sbGVjdFNlcmllc0luZm8ocmVzdWx0LCBlY01vZGVsKSB7XG4gIC8vIFByZXBhcmUgZGF0YSBmb3IgYXhpcyB0cmlnZ2VyXG4gIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAvLyBOb3RpY2UgdGhpcyBjYXNlOiB0aGlzIGNvb3JkU3lzIGlzIGBjYXJ0ZXNpYW4yRGAgYnV0IG5vdCBgZ3JpZGAuXG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPSBzZXJpZXNNb2RlbC5nZXQoWyd0b29sdGlwJywgJ3RyaWdnZXInXSwgdHJ1ZSk7XG4gICAgdmFyIHNlcmllc1Rvb2x0aXBTaG93ID0gc2VyaWVzTW9kZWwuZ2V0KFsndG9vbHRpcCcsICdzaG93J10sIHRydWUpO1xuICAgIGlmICghY29vcmRTeXMgfHwgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPT09ICdub25lJyB8fCBzZXJpZXNUb29sdGlwVHJpZ2dlciA9PT0gZmFsc2UgfHwgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPT09ICdpdGVtJyB8fCBzZXJpZXNUb29sdGlwU2hvdyA9PT0gZmFsc2UgfHwgc2VyaWVzTW9kZWwuZ2V0KFsnYXhpc1BvaW50ZXInLCAnc2hvdyddLCB0cnVlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWFjaChyZXN1bHQuY29vcmRTeXNBeGVzSW5mb1ttYWtlS2V5KGNvb3JkU3lzLm1vZGVsKV0sIGZ1bmN0aW9uIChheGlzSW5mbykge1xuICAgICAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICAgICAgaWYgKGNvb3JkU3lzLmdldEF4aXMoYXhpcy5kaW0pID09PSBheGlzKSB7XG4gICAgICAgIGF4aXNJbmZvLnNlcmllc01vZGVscy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgICAgYXhpc0luZm8uc2VyaWVzRGF0YUNvdW50ID09IG51bGwgJiYgKGF4aXNJbmZvLnNlcmllc0RhdGFDb3VudCA9IDApO1xuICAgICAgICBheGlzSW5mby5zZXJpZXNEYXRhQ291bnQgKz0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmNvdW50KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXHJcbiAqIEZvciBleGFtcGxlOlxyXG4gKiB7XHJcbiAqICAgICBheGlzUG9pbnRlcjoge1xyXG4gKiAgICAgICAgIGxpbmtzOiBbe1xyXG4gKiAgICAgICAgICAgICB4QXhpc0luZGV4OiBbMiwgNF0sXHJcbiAqICAgICAgICAgICAgIHlBeGlzSW5kZXg6ICdhbGwnXHJcbiAqICAgICAgICAgfSwge1xyXG4gKiAgICAgICAgICAgICB4QXhpc0lkOiBbJ2E1JywgJ2E3J10sXHJcbiAqICAgICAgICAgICAgIHhBeGlzTmFtZTogJ3h4eCdcclxuICogICAgICAgICB9XVxyXG4gKiAgICAgfVxyXG4gKiB9XHJcbiAqL1xuZnVuY3Rpb24gZ2V0TGlua0dyb3VwSW5kZXgobGlua3NPcHRpb24sIGF4aXMpIHtcbiAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gIHZhciBkaW0gPSBheGlzLmRpbTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rc09wdGlvbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5rT3B0aW9uID0gbGlua3NPcHRpb25baV0gfHwge307XG4gICAgaWYgKGNoZWNrUHJvcEluTGluayhsaW5rT3B0aW9uW2RpbSArICdBeGlzSWQnXSwgYXhpc01vZGVsLmlkKSB8fCBjaGVja1Byb3BJbkxpbmsobGlua09wdGlvbltkaW0gKyAnQXhpc0luZGV4J10sIGF4aXNNb2RlbC5jb21wb25lbnRJbmRleCkgfHwgY2hlY2tQcm9wSW5MaW5rKGxpbmtPcHRpb25bZGltICsgJ0F4aXNOYW1lJ10sIGF4aXNNb2RlbC5uYW1lKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja1Byb3BJbkxpbmsobGlua1Byb3BWYWx1ZSwgYXhpc1Byb3BWYWx1ZSkge1xuICByZXR1cm4gbGlua1Byb3BWYWx1ZSA9PT0gJ2FsbCcgfHwgaXNBcnJheShsaW5rUHJvcFZhbHVlKSAmJiBpbmRleE9mKGxpbmtQcm9wVmFsdWUsIGF4aXNQcm9wVmFsdWUpID49IDAgfHwgbGlua1Byb3BWYWx1ZSA9PT0gYXhpc1Byb3BWYWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaXhWYWx1ZShheGlzTW9kZWwpIHtcbiAgdmFyIGF4aXNJbmZvID0gZ2V0QXhpc0luZm8oYXhpc01vZGVsKTtcbiAgaWYgKCFheGlzSW5mbykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXNJbmZvLmF4aXNQb2ludGVyTW9kZWw7XG4gIHZhciBzY2FsZSA9IGF4aXNJbmZvLmF4aXMuc2NhbGU7XG4gIHZhciBvcHRpb24gPSBheGlzUG9pbnRlck1vZGVsLm9wdGlvbjtcbiAgdmFyIHN0YXR1cyA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzdGF0dXMnKTtcbiAgdmFyIHZhbHVlID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3ZhbHVlJyk7XG4gIC8vIFBhcnNlIGluaXQgdmFsdWUgZm9yIGNhdGVnb3J5IGFuZCB0aW1lIGF4aXMuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdmFsdWUgPSBzY2FsZS5wYXJzZSh2YWx1ZSk7XG4gIH1cbiAgdmFyIHVzZUhhbmRsZSA9IGlzSGFuZGxlVHJpZ2dlcihheGlzUG9pbnRlck1vZGVsKTtcbiAgLy8gSWYgYGhhbmRsZWAgdXNlZCwgYGF4aXNQb2ludGVyYCB3aWxsIGFsd2F5cyBiZSBkaXNwbGF5ZWQsIHNvIHZhbHVlXG4gIC8vIGFuZCBzdGF0dXMgc2hvdWxkIGJlIGluaXRpYWxpemVkLlxuICBpZiAoc3RhdHVzID09IG51bGwpIHtcbiAgICBvcHRpb24uc3RhdHVzID0gdXNlSGFuZGxlID8gJ3Nob3cnIDogJ2hpZGUnO1xuICB9XG4gIHZhciBleHRlbnQgPSBzY2FsZS5nZXRFeHRlbnQoKS5zbGljZSgpO1xuICBleHRlbnRbMF0gPiBleHRlbnRbMV0gJiYgZXh0ZW50LnJldmVyc2UoKTtcbiAgaWYgKFxuICAvLyBQaWNrIGEgdmFsdWUgb24gYXhpcyB3aGVuIGluaXRpYWxpemluZy5cbiAgdmFsdWUgPT0gbnVsbFxuICAvLyBJZiBib3RoIGBoYW5kbGVgIGFuZCBgZGF0YVpvb21gIGFyZSB1c2VkLCB2YWx1ZSBtYXkgYmUgb3V0IG9mIGF4aXMgZXh0ZW50LFxuICAvLyB3aGVyZSB3ZSBzaG91bGQgcmUtcGljayBhIHZhbHVlIHRvIGtlZXAgYGhhbmRsZWAgZGlzcGxheWluZyBub3JtYWxseS5cbiAgfHwgdmFsdWUgPiBleHRlbnRbMV0pIHtcbiAgICAvLyBNYWtlIGhhbmRsZSBkaXNwbGF5ZWQgb24gdGhlIGVuZCBvZiB0aGUgYXhpcyB3aGVuIGluaXQsIHdoaWNoIGxvb2tzIGJldHRlci5cbiAgICB2YWx1ZSA9IGV4dGVudFsxXTtcbiAgfVxuICBpZiAodmFsdWUgPCBleHRlbnRbMF0pIHtcbiAgICB2YWx1ZSA9IGV4dGVudFswXTtcbiAgfVxuICBvcHRpb24udmFsdWUgPSB2YWx1ZTtcbiAgaWYgKHVzZUhhbmRsZSkge1xuICAgIG9wdGlvbi5zdGF0dXMgPSBheGlzSW5mby5heGlzLnNjYWxlLmlzQmxhbmsoKSA/ICdoaWRlJyA6ICdzaG93JztcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEF4aXNJbmZvKGF4aXNNb2RlbCkge1xuICB2YXIgY29vcmRTeXNBeGVzSW5mbyA9IChheGlzTW9kZWwuZWNNb2RlbC5nZXRDb21wb25lbnQoJ2F4aXNQb2ludGVyJykgfHwge30pLmNvb3JkU3lzQXhlc0luZm87XG4gIHJldHVybiBjb29yZFN5c0F4ZXNJbmZvICYmIGNvb3JkU3lzQXhlc0luZm8uYXhlc0luZm9bbWFrZUtleShheGlzTW9kZWwpXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBeGlzUG9pbnRlck1vZGVsKGF4aXNNb2RlbCkge1xuICB2YXIgYXhpc0luZm8gPSBnZXRBeGlzSW5mbyhheGlzTW9kZWwpO1xuICByZXR1cm4gYXhpc0luZm8gJiYgYXhpc0luZm8uYXhpc1BvaW50ZXJNb2RlbDtcbn1cbmZ1bmN0aW9uIGlzSGFuZGxlVHJpZ2dlcihheGlzUG9pbnRlck1vZGVsKSB7XG4gIHJldHVybiAhIWF4aXNQb2ludGVyTW9kZWwuZ2V0KFsnaGFuZGxlJywgJ3Nob3cnXSk7XG59XG4vKipcclxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbW9kZWxcclxuICogQHJldHVybiB7c3RyaW5nfSB1bmlxdWUga2V5XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VLZXkobW9kZWwpIHtcbiAgcmV0dXJuIG1vZGVsLnR5cGUgKyAnfHwnICsgbW9kZWwuaWQ7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///49890\n")},53226:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43870);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43199);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(32322);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(5638);\n/* harmony import */ var _modelHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49890);\n/* harmony import */ var zrender_lib_core_event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(35452);\n/* harmony import */ var _util_throttle_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(24711);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\nvar inner = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nvar clone = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.clone;\nvar bind = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.bind;\n/**\r\n * Base axis pointer class in 2D.\r\n */\nvar BaseAxisPointer = /** @class */function () {\n  function BaseAxisPointer() {\n    this._dragging = false;\n    /**\r\n     * In px, arbitrary value. Do not set too small,\r\n     * no animation is ok for most cases.\r\n     */\n    this.animationThreshold = 15;\n  }\n  /**\r\n   * @implement\r\n   */\n  BaseAxisPointer.prototype.render = function (axisModel, axisPointerModel, api, forceRender) {\n    var value = axisPointerModel.get('value');\n    var status = axisPointerModel.get('status');\n    // Bind them to `this`, not in closure, otherwise they will not\n    // be replaced when user calling setOption in not merge mode.\n    this._axisModel = axisModel;\n    this._axisPointerModel = axisPointerModel;\n    this._api = api;\n    // Optimize: `render` will be called repeatedly during mouse move.\n    // So it is power consuming if performing `render` each time,\n    // especially on mobile device.\n    if (!forceRender && this._lastValue === value && this._lastStatus === status) {\n      return;\n    }\n    this._lastValue = value;\n    this._lastStatus = status;\n    var group = this._group;\n    var handle = this._handle;\n    if (!status || status === 'hide') {\n      // Do not clear here, for animation better.\n      group && group.hide();\n      handle && handle.hide();\n      return;\n    }\n    group && group.show();\n    handle && handle.show();\n    // Otherwise status is 'show'\n    var elOption = {};\n    this.makeElOption(elOption, value, axisModel, axisPointerModel, api);\n    // Enable change axis pointer type.\n    var graphicKey = elOption.graphicKey;\n    if (graphicKey !== this._lastGraphicKey) {\n      this.clear(api);\n    }\n    this._lastGraphicKey = graphicKey;\n    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);\n    if (!group) {\n      group = this._group = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A();\n      this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n      this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n      api.getZr().add(group);\n    } else {\n      var doUpdateProps = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.curry(updateProps, axisPointerModel, moveAnimation);\n      this.updatePointerEl(group, elOption, doUpdateProps);\n      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n    }\n    updateMandatoryProps(group, axisPointerModel, true);\n    this._renderHandle(value);\n  };\n  /**\r\n   * @implement\r\n   */\n  BaseAxisPointer.prototype.remove = function (api) {\n    this.clear(api);\n  };\n  /**\r\n   * @implement\r\n   */\n  BaseAxisPointer.prototype.dispose = function (api) {\n    this.clear(api);\n  };\n  /**\r\n   * @protected\r\n   */\n  BaseAxisPointer.prototype.determineAnimation = function (axisModel, axisPointerModel) {\n    var animation = axisPointerModel.get('animation');\n    var axis = axisModel.axis;\n    var isCategoryAxis = axis.type === 'category';\n    var useSnap = axisPointerModel.get('snap');\n    // Value axis without snap always do not snap.\n    if (!useSnap && !isCategoryAxis) {\n      return false;\n    }\n    if (animation === 'auto' || animation == null) {\n      var animationThreshold = this.animationThreshold;\n      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n        return true;\n      }\n      // It is important to auto animation when snap used. Consider if there is\n      // a dataZoom, animation will be disabled when too many points exist, while\n      // it will be enabled for better visual effect when little points exist.\n      if (useSnap) {\n        var seriesDataCount = _modelHelper_js__WEBPACK_IMPORTED_MODULE_3__/* .getAxisInfo */ .Yc(axisModel).seriesDataCount;\n        var axisExtent = axis.getExtent();\n        // Approximate band width\n        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n      }\n      return false;\n    }\n    return animation === true;\n  };\n  /**\r\n   * add {pointer, label, graphicKey} to elOption\r\n   * @protected\r\n   */\n  BaseAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {\n    // Should be implemenented by sub-class.\n  };\n  /**\r\n   * @protected\r\n   */\n  BaseAxisPointer.prototype.createPointerEl = function (group, elOption, axisModel, axisPointerModel) {\n    var pointerOption = elOption.pointer;\n    if (pointerOption) {\n      var pointerEl = inner(group).pointerEl = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__[pointerOption.type](clone(elOption.pointer));\n      group.add(pointerEl);\n    }\n  };\n  /**\r\n   * @protected\r\n   */\n  BaseAxisPointer.prototype.createLabelEl = function (group, elOption, axisModel, axisPointerModel) {\n    if (elOption.label) {\n      var labelEl = inner(group).labelEl = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .Ay(clone(elOption.label));\n      group.add(labelEl);\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  };\n  /**\r\n   * @protected\r\n   */\n  BaseAxisPointer.prototype.updatePointerEl = function (group, elOption, updateProps) {\n    var pointerEl = inner(group).pointerEl;\n    if (pointerEl && elOption.pointer) {\n      pointerEl.setStyle(elOption.pointer.style);\n      updateProps(pointerEl, {\n        shape: elOption.pointer.shape\n      });\n    }\n  };\n  /**\r\n   * @protected\r\n   */\n  BaseAxisPointer.prototype.updateLabelEl = function (group, elOption, updateProps, axisPointerModel) {\n    var labelEl = inner(group).labelEl;\n    if (labelEl) {\n      labelEl.setStyle(elOption.label.style);\n      updateProps(labelEl, {\n        // Consider text length change in vertical axis, animation should\n        // be used on shape, otherwise the effect will be weird.\n        // TODOTODO\n        // shape: elOption.label.shape,\n        x: elOption.label.x,\n        y: elOption.label.y\n      });\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  };\n  /**\r\n   * @private\r\n   */\n  BaseAxisPointer.prototype._renderHandle = function (value) {\n    if (this._dragging || !this.updateHandleTransform) {\n      return;\n    }\n    var axisPointerModel = this._axisPointerModel;\n    var zr = this._api.getZr();\n    var handle = this._handle;\n    var handleModel = axisPointerModel.getModel('handle');\n    var status = axisPointerModel.get('status');\n    if (!handleModel.get('show') || !status || status === 'hide') {\n      handle && zr.remove(handle);\n      this._handle = null;\n      return;\n    }\n    var isInit;\n    if (!this._handle) {\n      isInit = true;\n      handle = this._handle = _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__.createIcon(handleModel.get('icon'), {\n        cursor: 'move',\n        draggable: true,\n        onmousemove: function (e) {\n          // For mobile device, prevent screen slider on the button.\n          zrender_lib_core_event_js__WEBPACK_IMPORTED_MODULE_6__/* .stop */ .ds(e.event);\n        },\n        onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n        drift: bind(this._onHandleDragMove, this),\n        ondragend: bind(this._onHandleDragEnd, this)\n      });\n      zr.add(handle);\n    }\n    updateMandatoryProps(handle, axisPointerModel, false);\n    // update style\n    handle.setStyle(handleModel.getItemStyle(null, ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY']));\n    // update position\n    var handleSize = handleModel.get('size');\n    if (!zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray(handleSize)) {\n      handleSize = [handleSize, handleSize];\n    }\n    handle.scaleX = handleSize[0] / 2;\n    handle.scaleY = handleSize[1] / 2;\n    _util_throttle_js__WEBPACK_IMPORTED_MODULE_7__/* .createOrUpdate */ .N(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');\n    this._moveHandleToValue(value, isInit);\n  };\n  BaseAxisPointer.prototype._moveHandleToValue = function (value, isInit) {\n    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));\n  };\n  BaseAxisPointer.prototype._onHandleDragMove = function (dx, dy) {\n    var handle = this._handle;\n    if (!handle) {\n      return;\n    }\n    this._dragging = true;\n    // Persistent for throttle.\n    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);\n    this._payloadInfo = trans;\n    handle.stopAnimation();\n    handle.attr(getHandleTransProps(trans));\n    inner(handle).lastProp = null;\n    this._doDispatchAxisPointer();\n  };\n  /**\r\n   * Throttled method.\r\n   */\n  BaseAxisPointer.prototype._doDispatchAxisPointer = function () {\n    var handle = this._handle;\n    if (!handle) {\n      return;\n    }\n    var payloadInfo = this._payloadInfo;\n    var axisModel = this._axisModel;\n    this._api.dispatchAction({\n      type: 'updateAxisPointer',\n      x: payloadInfo.cursorPoint[0],\n      y: payloadInfo.cursorPoint[1],\n      tooltipOption: payloadInfo.tooltipOption,\n      axesInfo: [{\n        axisDim: axisModel.axis.dim,\n        axisIndex: axisModel.componentIndex\n      }]\n    });\n  };\n  BaseAxisPointer.prototype._onHandleDragEnd = function () {\n    this._dragging = false;\n    var handle = this._handle;\n    if (!handle) {\n      return;\n    }\n    var value = this._axisPointerModel.get('value');\n    // Consider snap or categroy axis, handle may be not consistent with\n    // axisPointer. So move handle to align the exact value position when\n    // drag ended.\n    this._moveHandleToValue(value);\n    // For the effect: tooltip will be shown when finger holding on handle\n    // button, and will be hidden after finger left handle button.\n    this._api.dispatchAction({\n      type: 'hideTip'\n    });\n  };\n  /**\r\n   * @private\r\n   */\n  BaseAxisPointer.prototype.clear = function (api) {\n    this._lastValue = null;\n    this._lastStatus = null;\n    var zr = api.getZr();\n    var group = this._group;\n    var handle = this._handle;\n    if (zr && group) {\n      this._lastGraphicKey = null;\n      group && zr.remove(group);\n      handle && zr.remove(handle);\n      this._group = null;\n      this._handle = null;\n      this._payloadInfo = null;\n    }\n    _util_throttle_js__WEBPACK_IMPORTED_MODULE_7__/* .clear */ .IU(this, '_doDispatchAxisPointer');\n  };\n  /**\r\n   * @protected\r\n   */\n  BaseAxisPointer.prototype.doClear = function () {\n    // Implemented by sub-class if necessary.\n  };\n  BaseAxisPointer.prototype.buildLabel = function (xy, wh, xDimIndex) {\n    xDimIndex = xDimIndex || 0;\n    return {\n      x: xy[xDimIndex],\n      y: xy[1 - xDimIndex],\n      width: wh[xDimIndex],\n      height: wh[1 - xDimIndex]\n    };\n  };\n  return BaseAxisPointer;\n}();\nfunction updateProps(animationModel, moveAnimation, el, props) {\n  // Animation optimize.\n  if (!propsEqual(inner(el).lastProp, props)) {\n    inner(el).lastProp = props;\n    moveAnimation ? _util_graphic_js__WEBPACK_IMPORTED_MODULE_8__/* .updateProps */ .oi(el, props, animationModel) : (el.stopAnimation(), el.attr(props));\n  }\n}\nfunction propsEqual(lastProps, newProps) {\n  if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject(lastProps) && zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject(newProps)) {\n    var equals_1 = true;\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(newProps, function (item, key) {\n      equals_1 = equals_1 && propsEqual(lastProps[key], item);\n    });\n    return !!equals_1;\n  } else {\n    return lastProps === newProps;\n  }\n}\nfunction updateLabelShowHide(labelEl, axisPointerModel) {\n  labelEl[axisPointerModel.get(['label', 'show']) ? 'show' : 'hide']();\n}\nfunction getHandleTransProps(trans) {\n  return {\n    x: trans.x || 0,\n    y: trans.y || 0,\n    rotation: trans.rotation || 0\n  };\n}\nfunction updateMandatoryProps(group, axisPointerModel, silent) {\n  var z = axisPointerModel.get('z');\n  var zlevel = axisPointerModel.get('zlevel');\n  group && group.traverse(function (el) {\n    if (el.type !== 'group') {\n      z != null && (el.z = z);\n      zlevel != null && (el.zlevel = zlevel);\n      el.silent = silent;\n    }\n  });\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseAxisPointer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMyMjYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQmFzZUF4aXNQb2ludGVyLmpzPzYzZGEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCAqIGFzIGF4aXNQb2ludGVyTW9kZWxIZWxwZXIgZnJvbSAnLi9tb2RlbEhlbHBlci5qcyc7XG5pbXBvcnQgKiBhcyBldmVudFRvb2wgZnJvbSAnenJlbmRlci9saWIvY29yZS9ldmVudC5qcyc7XG5pbXBvcnQgKiBhcyB0aHJvdHRsZVV0aWwgZnJvbSAnLi4vLi4vdXRpbC90aHJvdHRsZS5qcyc7XG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xudmFyIGNsb25lID0genJVdGlsLmNsb25lO1xudmFyIGJpbmQgPSB6clV0aWwuYmluZDtcbi8qKlxyXG4gKiBCYXNlIGF4aXMgcG9pbnRlciBjbGFzcyBpbiAyRC5cclxuICovXG52YXIgQmFzZUF4aXNQb2ludGVyID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZUF4aXNQb2ludGVyKCkge1xuICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgLyoqXHJcbiAgICAgKiBJbiBweCwgYXJiaXRyYXJ5IHZhbHVlLiBEbyBub3Qgc2V0IHRvbyBzbWFsbCxcclxuICAgICAqIG5vIGFuaW1hdGlvbiBpcyBvayBmb3IgbW9zdCBjYXNlcy5cclxuICAgICAqL1xuICAgIHRoaXMuYW5pbWF0aW9uVGhyZXNob2xkID0gMTU7XG4gIH1cbiAgLyoqXHJcbiAgICogQGltcGxlbWVudFxyXG4gICAqL1xuICBCYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSwgZm9yY2VSZW5kZXIpIHtcbiAgICB2YXIgdmFsdWUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTtcbiAgICB2YXIgc3RhdHVzID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3N0YXR1cycpO1xuICAgIC8vIEJpbmQgdGhlbSB0byBgdGhpc2AsIG5vdCBpbiBjbG9zdXJlLCBvdGhlcndpc2UgdGhleSB3aWxsIG5vdFxuICAgIC8vIGJlIHJlcGxhY2VkIHdoZW4gdXNlciBjYWxsaW5nIHNldE9wdGlvbiBpbiBub3QgbWVyZ2UgbW9kZS5cbiAgICB0aGlzLl9heGlzTW9kZWwgPSBheGlzTW9kZWw7XG4gICAgdGhpcy5fYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWw7XG4gICAgdGhpcy5fYXBpID0gYXBpO1xuICAgIC8vIE9wdGltaXplOiBgcmVuZGVyYCB3aWxsIGJlIGNhbGxlZCByZXBlYXRlZGx5IGR1cmluZyBtb3VzZSBtb3ZlLlxuICAgIC8vIFNvIGl0IGlzIHBvd2VyIGNvbnN1bWluZyBpZiBwZXJmb3JtaW5nIGByZW5kZXJgIGVhY2ggdGltZSxcbiAgICAvLyBlc3BlY2lhbGx5IG9uIG1vYmlsZSBkZXZpY2UuXG4gICAgaWYgKCFmb3JjZVJlbmRlciAmJiB0aGlzLl9sYXN0VmFsdWUgPT09IHZhbHVlICYmIHRoaXMuX2xhc3RTdGF0dXMgPT09IHN0YXR1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl9sYXN0U3RhdHVzID0gc3RhdHVzO1xuICAgIHZhciBncm91cCA9IHRoaXMuX2dyb3VwO1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG4gICAgaWYgKCFzdGF0dXMgfHwgc3RhdHVzID09PSAnaGlkZScpIHtcbiAgICAgIC8vIERvIG5vdCBjbGVhciBoZXJlLCBmb3IgYW5pbWF0aW9uIGJldHRlci5cbiAgICAgIGdyb3VwICYmIGdyb3VwLmhpZGUoKTtcbiAgICAgIGhhbmRsZSAmJiBoYW5kbGUuaGlkZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBncm91cCAmJiBncm91cC5zaG93KCk7XG4gICAgaGFuZGxlICYmIGhhbmRsZS5zaG93KCk7XG4gICAgLy8gT3RoZXJ3aXNlIHN0YXR1cyBpcyAnc2hvdydcbiAgICB2YXIgZWxPcHRpb24gPSB7fTtcbiAgICB0aGlzLm1ha2VFbE9wdGlvbihlbE9wdGlvbiwgdmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpKTtcbiAgICAvLyBFbmFibGUgY2hhbmdlIGF4aXMgcG9pbnRlciB0eXBlLlxuICAgIHZhciBncmFwaGljS2V5ID0gZWxPcHRpb24uZ3JhcGhpY0tleTtcbiAgICBpZiAoZ3JhcGhpY0tleSAhPT0gdGhpcy5fbGFzdEdyYXBoaWNLZXkpIHtcbiAgICAgIHRoaXMuY2xlYXIoYXBpKTtcbiAgICB9XG4gICAgdGhpcy5fbGFzdEdyYXBoaWNLZXkgPSBncmFwaGljS2V5O1xuICAgIHZhciBtb3ZlQW5pbWF0aW9uID0gdGhpcy5fbW92ZUFuaW1hdGlvbiA9IHRoaXMuZGV0ZXJtaW5lQW5pbWF0aW9uKGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgZ3JvdXAgPSB0aGlzLl9ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgICB0aGlzLmNyZWF0ZVBvaW50ZXJFbChncm91cCwgZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICB0aGlzLmNyZWF0ZUxhYmVsRWwoZ3JvdXAsIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgYXBpLmdldFpyKCkuYWRkKGdyb3VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRvVXBkYXRlUHJvcHMgPSB6clV0aWwuY3VycnkodXBkYXRlUHJvcHMsIGF4aXNQb2ludGVyTW9kZWwsIG1vdmVBbmltYXRpb24pO1xuICAgICAgdGhpcy51cGRhdGVQb2ludGVyRWwoZ3JvdXAsIGVsT3B0aW9uLCBkb1VwZGF0ZVByb3BzKTtcbiAgICAgIHRoaXMudXBkYXRlTGFiZWxFbChncm91cCwgZWxPcHRpb24sIGRvVXBkYXRlUHJvcHMsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgIH1cbiAgICB1cGRhdGVNYW5kYXRvcnlQcm9wcyhncm91cCwgYXhpc1BvaW50ZXJNb2RlbCwgdHJ1ZSk7XG4gICAgdGhpcy5fcmVuZGVySGFuZGxlKHZhbHVlKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQGltcGxlbWVudFxyXG4gICAqL1xuICBCYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB0aGlzLmNsZWFyKGFwaSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBpbXBsZW1lbnRcclxuICAgKi9cbiAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKGFwaSkge1xuICAgIHRoaXMuY2xlYXIoYXBpKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xuICBCYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlLmRldGVybWluZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICB2YXIgYW5pbWF0aW9uID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2FuaW1hdGlvbicpO1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIGlzQ2F0ZWdvcnlBeGlzID0gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknO1xuICAgIHZhciB1c2VTbmFwID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3NuYXAnKTtcbiAgICAvLyBWYWx1ZSBheGlzIHdpdGhvdXQgc25hcCBhbHdheXMgZG8gbm90IHNuYXAuXG4gICAgaWYgKCF1c2VTbmFwICYmICFpc0NhdGVnb3J5QXhpcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uID09PSAnYXV0bycgfHwgYW5pbWF0aW9uID09IG51bGwpIHtcbiAgICAgIHZhciBhbmltYXRpb25UaHJlc2hvbGQgPSB0aGlzLmFuaW1hdGlvblRocmVzaG9sZDtcbiAgICAgIGlmIChpc0NhdGVnb3J5QXhpcyAmJiBheGlzLmdldEJhbmRXaWR0aCgpID4gYW5pbWF0aW9uVGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIGF1dG8gYW5pbWF0aW9uIHdoZW4gc25hcCB1c2VkLiBDb25zaWRlciBpZiB0aGVyZSBpc1xuICAgICAgLy8gYSBkYXRhWm9vbSwgYW5pbWF0aW9uIHdpbGwgYmUgZGlzYWJsZWQgd2hlbiB0b28gbWFueSBwb2ludHMgZXhpc3QsIHdoaWxlXG4gICAgICAvLyBpdCB3aWxsIGJlIGVuYWJsZWQgZm9yIGJldHRlciB2aXN1YWwgZWZmZWN0IHdoZW4gbGl0dGxlIHBvaW50cyBleGlzdC5cbiAgICAgIGlmICh1c2VTbmFwKSB7XG4gICAgICAgIHZhciBzZXJpZXNEYXRhQ291bnQgPSBheGlzUG9pbnRlck1vZGVsSGVscGVyLmdldEF4aXNJbmZvKGF4aXNNb2RlbCkuc2VyaWVzRGF0YUNvdW50O1xuICAgICAgICB2YXIgYXhpc0V4dGVudCA9IGF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgICAgIC8vIEFwcHJveGltYXRlIGJhbmQgd2lkdGhcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGF4aXNFeHRlbnRbMF0gLSBheGlzRXh0ZW50WzFdKSAvIHNlcmllc0RhdGFDb3VudCA+IGFuaW1hdGlvblRocmVzaG9sZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbiA9PT0gdHJ1ZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogYWRkIHtwb2ludGVyLCBsYWJlbCwgZ3JhcGhpY0tleX0gdG8gZWxPcHRpb25cclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXG4gIEJhc2VBeGlzUG9pbnRlci5wcm90b3R5cGUubWFrZUVsT3B0aW9uID0gZnVuY3Rpb24gKGVsT3B0aW9uLCB2YWx1ZSwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGkpIHtcbiAgICAvLyBTaG91bGQgYmUgaW1wbGVtZW5lbnRlZCBieSBzdWItY2xhc3MuXG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cbiAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5jcmVhdGVQb2ludGVyRWwgPSBmdW5jdGlvbiAoZ3JvdXAsIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICB2YXIgcG9pbnRlck9wdGlvbiA9IGVsT3B0aW9uLnBvaW50ZXI7XG4gICAgaWYgKHBvaW50ZXJPcHRpb24pIHtcbiAgICAgIHZhciBwb2ludGVyRWwgPSBpbm5lcihncm91cCkucG9pbnRlckVsID0gbmV3IGdyYXBoaWNbcG9pbnRlck9wdGlvbi50eXBlXShjbG9uZShlbE9wdGlvbi5wb2ludGVyKSk7XG4gICAgICBncm91cC5hZGQocG9pbnRlckVsKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cbiAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5jcmVhdGVMYWJlbEVsID0gZnVuY3Rpb24gKGdyb3VwLCBlbE9wdGlvbiwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsKSB7XG4gICAgaWYgKGVsT3B0aW9uLmxhYmVsKSB7XG4gICAgICB2YXIgbGFiZWxFbCA9IGlubmVyKGdyb3VwKS5sYWJlbEVsID0gbmV3IGdyYXBoaWMuVGV4dChjbG9uZShlbE9wdGlvbi5sYWJlbCkpO1xuICAgICAgZ3JvdXAuYWRkKGxhYmVsRWwpO1xuICAgICAgdXBkYXRlTGFiZWxTaG93SGlkZShsYWJlbEVsLCBheGlzUG9pbnRlck1vZGVsKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cbiAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS51cGRhdGVQb2ludGVyRWwgPSBmdW5jdGlvbiAoZ3JvdXAsIGVsT3B0aW9uLCB1cGRhdGVQcm9wcykge1xuICAgIHZhciBwb2ludGVyRWwgPSBpbm5lcihncm91cCkucG9pbnRlckVsO1xuICAgIGlmIChwb2ludGVyRWwgJiYgZWxPcHRpb24ucG9pbnRlcikge1xuICAgICAgcG9pbnRlckVsLnNldFN0eWxlKGVsT3B0aW9uLnBvaW50ZXIuc3R5bGUpO1xuICAgICAgdXBkYXRlUHJvcHMocG9pbnRlckVsLCB7XG4gICAgICAgIHNoYXBlOiBlbE9wdGlvbi5wb2ludGVyLnNoYXBlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cbiAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS51cGRhdGVMYWJlbEVsID0gZnVuY3Rpb24gKGdyb3VwLCBlbE9wdGlvbiwgdXBkYXRlUHJvcHMsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICB2YXIgbGFiZWxFbCA9IGlubmVyKGdyb3VwKS5sYWJlbEVsO1xuICAgIGlmIChsYWJlbEVsKSB7XG4gICAgICBsYWJlbEVsLnNldFN0eWxlKGVsT3B0aW9uLmxhYmVsLnN0eWxlKTtcbiAgICAgIHVwZGF0ZVByb3BzKGxhYmVsRWwsIHtcbiAgICAgICAgLy8gQ29uc2lkZXIgdGV4dCBsZW5ndGggY2hhbmdlIGluIHZlcnRpY2FsIGF4aXMsIGFuaW1hdGlvbiBzaG91bGRcbiAgICAgICAgLy8gYmUgdXNlZCBvbiBzaGFwZSwgb3RoZXJ3aXNlIHRoZSBlZmZlY3Qgd2lsbCBiZSB3ZWlyZC5cbiAgICAgICAgLy8gVE9ET1RPRE9cbiAgICAgICAgLy8gc2hhcGU6IGVsT3B0aW9uLmxhYmVsLnNoYXBlLFxuICAgICAgICB4OiBlbE9wdGlvbi5sYWJlbC54LFxuICAgICAgICB5OiBlbE9wdGlvbi5sYWJlbC55XG4gICAgICB9KTtcbiAgICAgIHVwZGF0ZUxhYmVsU2hvd0hpZGUobGFiZWxFbCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBCYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlLl9yZW5kZXJIYW5kbGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fZHJhZ2dpbmcgfHwgIXRoaXMudXBkYXRlSGFuZGxlVHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBheGlzUG9pbnRlck1vZGVsID0gdGhpcy5fYXhpc1BvaW50ZXJNb2RlbDtcbiAgICB2YXIgenIgPSB0aGlzLl9hcGkuZ2V0WnIoKTtcbiAgICB2YXIgaGFuZGxlID0gdGhpcy5faGFuZGxlO1xuICAgIHZhciBoYW5kbGVNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0TW9kZWwoJ2hhbmRsZScpO1xuICAgIHZhciBzdGF0dXMgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc3RhdHVzJyk7XG4gICAgaWYgKCFoYW5kbGVNb2RlbC5nZXQoJ3Nob3cnKSB8fCAhc3RhdHVzIHx8IHN0YXR1cyA9PT0gJ2hpZGUnKSB7XG4gICAgICBoYW5kbGUgJiYgenIucmVtb3ZlKGhhbmRsZSk7XG4gICAgICB0aGlzLl9oYW5kbGUgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXNJbml0O1xuICAgIGlmICghdGhpcy5faGFuZGxlKSB7XG4gICAgICBpc0luaXQgPSB0cnVlO1xuICAgICAgaGFuZGxlID0gdGhpcy5faGFuZGxlID0gZ3JhcGhpYy5jcmVhdGVJY29uKGhhbmRsZU1vZGVsLmdldCgnaWNvbicpLCB7XG4gICAgICAgIGN1cnNvcjogJ21vdmUnLFxuICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgIG9ubW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIC8vIEZvciBtb2JpbGUgZGV2aWNlLCBwcmV2ZW50IHNjcmVlbiBzbGlkZXIgb24gdGhlIGJ1dHRvbi5cbiAgICAgICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25tb3VzZWRvd246IGJpbmQodGhpcy5fb25IYW5kbGVEcmFnTW92ZSwgdGhpcywgMCwgMCksXG4gICAgICAgIGRyaWZ0OiBiaW5kKHRoaXMuX29uSGFuZGxlRHJhZ01vdmUsIHRoaXMpLFxuICAgICAgICBvbmRyYWdlbmQ6IGJpbmQodGhpcy5fb25IYW5kbGVEcmFnRW5kLCB0aGlzKVxuICAgICAgfSk7XG4gICAgICB6ci5hZGQoaGFuZGxlKTtcbiAgICB9XG4gICAgdXBkYXRlTWFuZGF0b3J5UHJvcHMoaGFuZGxlLCBheGlzUG9pbnRlck1vZGVsLCBmYWxzZSk7XG4gICAgLy8gdXBkYXRlIHN0eWxlXG4gICAgaGFuZGxlLnNldFN0eWxlKGhhbmRsZU1vZGVsLmdldEl0ZW1TdHlsZShudWxsLCBbJ2NvbG9yJywgJ2JvcmRlckNvbG9yJywgJ2JvcmRlcldpZHRoJywgJ29wYWNpdHknLCAnc2hhZG93Q29sb3InLCAnc2hhZG93Qmx1cicsICdzaGFkb3dPZmZzZXRYJywgJ3NoYWRvd09mZnNldFknXSkpO1xuICAgIC8vIHVwZGF0ZSBwb3NpdGlvblxuICAgIHZhciBoYW5kbGVTaXplID0gaGFuZGxlTW9kZWwuZ2V0KCdzaXplJyk7XG4gICAgaWYgKCF6clV0aWwuaXNBcnJheShoYW5kbGVTaXplKSkge1xuICAgICAgaGFuZGxlU2l6ZSA9IFtoYW5kbGVTaXplLCBoYW5kbGVTaXplXTtcbiAgICB9XG4gICAgaGFuZGxlLnNjYWxlWCA9IGhhbmRsZVNpemVbMF0gLyAyO1xuICAgIGhhbmRsZS5zY2FsZVkgPSBoYW5kbGVTaXplWzFdIC8gMjtcbiAgICB0aHJvdHRsZVV0aWwuY3JlYXRlT3JVcGRhdGUodGhpcywgJ19kb0Rpc3BhdGNoQXhpc1BvaW50ZXInLCBoYW5kbGVNb2RlbC5nZXQoJ3Rocm90dGxlJykgfHwgMCwgJ2ZpeFJhdGUnKTtcbiAgICB0aGlzLl9tb3ZlSGFuZGxlVG9WYWx1ZSh2YWx1ZSwgaXNJbml0KTtcbiAgfTtcbiAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5fbW92ZUhhbmRsZVRvVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGlzSW5pdCkge1xuICAgIHVwZGF0ZVByb3BzKHRoaXMuX2F4aXNQb2ludGVyTW9kZWwsICFpc0luaXQgJiYgdGhpcy5fbW92ZUFuaW1hdGlvbiwgdGhpcy5faGFuZGxlLCBnZXRIYW5kbGVUcmFuc1Byb3BzKHRoaXMuZ2V0SGFuZGxlVHJhbnNmb3JtKHZhbHVlLCB0aGlzLl9heGlzTW9kZWwsIHRoaXMuX2F4aXNQb2ludGVyTW9kZWwpKSk7XG4gIH07XG4gIEJhc2VBeGlzUG9pbnRlci5wcm90b3R5cGUuX29uSGFuZGxlRHJhZ01vdmUgPSBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kcmFnZ2luZyA9IHRydWU7XG4gICAgLy8gUGVyc2lzdGVudCBmb3IgdGhyb3R0bGUuXG4gICAgdmFyIHRyYW5zID0gdGhpcy51cGRhdGVIYW5kbGVUcmFuc2Zvcm0oZ2V0SGFuZGxlVHJhbnNQcm9wcyhoYW5kbGUpLCBbZHgsIGR5XSwgdGhpcy5fYXhpc01vZGVsLCB0aGlzLl9heGlzUG9pbnRlck1vZGVsKTtcbiAgICB0aGlzLl9wYXlsb2FkSW5mbyA9IHRyYW5zO1xuICAgIGhhbmRsZS5zdG9wQW5pbWF0aW9uKCk7XG4gICAgaGFuZGxlLmF0dHIoZ2V0SGFuZGxlVHJhbnNQcm9wcyh0cmFucykpO1xuICAgIGlubmVyKGhhbmRsZSkubGFzdFByb3AgPSBudWxsO1xuICAgIHRoaXMuX2RvRGlzcGF0Y2hBeGlzUG9pbnRlcigpO1xuICB9O1xuICAvKipcclxuICAgKiBUaHJvdHRsZWQgbWV0aG9kLlxyXG4gICAqL1xuICBCYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlLl9kb0Rpc3BhdGNoQXhpc1BvaW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGF5bG9hZEluZm8gPSB0aGlzLl9wYXlsb2FkSW5mbztcbiAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5fYXhpc01vZGVsO1xuICAgIHRoaXMuX2FwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgeDogcGF5bG9hZEluZm8uY3Vyc29yUG9pbnRbMF0sXG4gICAgICB5OiBwYXlsb2FkSW5mby5jdXJzb3JQb2ludFsxXSxcbiAgICAgIHRvb2x0aXBPcHRpb246IHBheWxvYWRJbmZvLnRvb2x0aXBPcHRpb24sXG4gICAgICBheGVzSW5mbzogW3tcbiAgICAgICAgYXhpc0RpbTogYXhpc01vZGVsLmF4aXMuZGltLFxuICAgICAgICBheGlzSW5kZXg6IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleFxuICAgICAgfV1cbiAgICB9KTtcbiAgfTtcbiAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5fb25IYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSB0aGlzLl9heGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTtcbiAgICAvLyBDb25zaWRlciBzbmFwIG9yIGNhdGVncm95IGF4aXMsIGhhbmRsZSBtYXkgYmUgbm90IGNvbnNpc3RlbnQgd2l0aFxuICAgIC8vIGF4aXNQb2ludGVyLiBTbyBtb3ZlIGhhbmRsZSB0byBhbGlnbiB0aGUgZXhhY3QgdmFsdWUgcG9zaXRpb24gd2hlblxuICAgIC8vIGRyYWcgZW5kZWQuXG4gICAgdGhpcy5fbW92ZUhhbmRsZVRvVmFsdWUodmFsdWUpO1xuICAgIC8vIEZvciB0aGUgZWZmZWN0OiB0b29sdGlwIHdpbGwgYmUgc2hvd24gd2hlbiBmaW5nZXIgaG9sZGluZyBvbiBoYW5kbGVcbiAgICAvLyBidXR0b24sIGFuZCB3aWxsIGJlIGhpZGRlbiBhZnRlciBmaW5nZXIgbGVmdCBoYW5kbGUgYnV0dG9uLlxuICAgIHRoaXMuX2FwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnaGlkZVRpcCdcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB0aGlzLl9sYXN0VmFsdWUgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RTdGF0dXMgPSBudWxsO1xuICAgIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICAgIHZhciBncm91cCA9IHRoaXMuX2dyb3VwO1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG4gICAgaWYgKHpyICYmIGdyb3VwKSB7XG4gICAgICB0aGlzLl9sYXN0R3JhcGhpY0tleSA9IG51bGw7XG4gICAgICBncm91cCAmJiB6ci5yZW1vdmUoZ3JvdXApO1xuICAgICAgaGFuZGxlICYmIHpyLnJlbW92ZShoYW5kbGUpO1xuICAgICAgdGhpcy5fZ3JvdXAgPSBudWxsO1xuICAgICAgdGhpcy5faGFuZGxlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BheWxvYWRJbmZvID0gbnVsbDtcbiAgICB9XG4gICAgdGhyb3R0bGVVdGlsLmNsZWFyKHRoaXMsICdfZG9EaXNwYXRjaEF4aXNQb2ludGVyJyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cbiAgQmFzZUF4aXNQb2ludGVyLnByb3RvdHlwZS5kb0NsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzcyBpZiBuZWNlc3NhcnkuXG4gIH07XG4gIEJhc2VBeGlzUG9pbnRlci5wcm90b3R5cGUuYnVpbGRMYWJlbCA9IGZ1bmN0aW9uICh4eSwgd2gsIHhEaW1JbmRleCkge1xuICAgIHhEaW1JbmRleCA9IHhEaW1JbmRleCB8fCAwO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4eVt4RGltSW5kZXhdLFxuICAgICAgeTogeHlbMSAtIHhEaW1JbmRleF0sXG4gICAgICB3aWR0aDogd2hbeERpbUluZGV4XSxcbiAgICAgIGhlaWdodDogd2hbMSAtIHhEaW1JbmRleF1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gQmFzZUF4aXNQb2ludGVyO1xufSgpO1xuZnVuY3Rpb24gdXBkYXRlUHJvcHMoYW5pbWF0aW9uTW9kZWwsIG1vdmVBbmltYXRpb24sIGVsLCBwcm9wcykge1xuICAvLyBBbmltYXRpb24gb3B0aW1pemUuXG4gIGlmICghcHJvcHNFcXVhbChpbm5lcihlbCkubGFzdFByb3AsIHByb3BzKSkge1xuICAgIGlubmVyKGVsKS5sYXN0UHJvcCA9IHByb3BzO1xuICAgIG1vdmVBbmltYXRpb24gPyBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCBwcm9wcywgYW5pbWF0aW9uTW9kZWwpIDogKGVsLnN0b3BBbmltYXRpb24oKSwgZWwuYXR0cihwcm9wcykpO1xuICB9XG59XG5mdW5jdGlvbiBwcm9wc0VxdWFsKGxhc3RQcm9wcywgbmV3UHJvcHMpIHtcbiAgaWYgKHpyVXRpbC5pc09iamVjdChsYXN0UHJvcHMpICYmIHpyVXRpbC5pc09iamVjdChuZXdQcm9wcykpIHtcbiAgICB2YXIgZXF1YWxzXzEgPSB0cnVlO1xuICAgIHpyVXRpbC5lYWNoKG5ld1Byb3BzLCBmdW5jdGlvbiAoaXRlbSwga2V5KSB7XG4gICAgICBlcXVhbHNfMSA9IGVxdWFsc18xICYmIHByb3BzRXF1YWwobGFzdFByb3BzW2tleV0sIGl0ZW0pO1xuICAgIH0pO1xuICAgIHJldHVybiAhIWVxdWFsc18xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXN0UHJvcHMgPT09IG5ld1Byb3BzO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVMYWJlbFNob3dIaWRlKGxhYmVsRWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgbGFiZWxFbFtheGlzUG9pbnRlck1vZGVsLmdldChbJ2xhYmVsJywgJ3Nob3cnXSkgPyAnc2hvdycgOiAnaGlkZSddKCk7XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVUcmFuc1Byb3BzKHRyYW5zKSB7XG4gIHJldHVybiB7XG4gICAgeDogdHJhbnMueCB8fCAwLFxuICAgIHk6IHRyYW5zLnkgfHwgMCxcbiAgICByb3RhdGlvbjogdHJhbnMucm90YXRpb24gfHwgMFxuICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlTWFuZGF0b3J5UHJvcHMoZ3JvdXAsIGF4aXNQb2ludGVyTW9kZWwsIHNpbGVudCkge1xuICB2YXIgeiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd6Jyk7XG4gIHZhciB6bGV2ZWwgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnemxldmVsJyk7XG4gIGdyb3VwICYmIGdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICB6ICE9IG51bGwgJiYgKGVsLnogPSB6KTtcbiAgICAgIHpsZXZlbCAhPSBudWxsICYmIChlbC56bGV2ZWwgPSB6bGV2ZWwpO1xuICAgICAgZWwuc2lsZW50ID0gc2lsZW50O1xuICAgIH1cbiAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBCYXNlQXhpc1BvaW50ZXI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///53226\n")},59481:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43199);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(42933);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82861);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(32322);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(25014);\n/* harmony import */ var _label_labelStyle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(89632);\n/* harmony import */ var _model_Model_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(43172);\n/* harmony import */ var _AxisView_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22480);\n/* harmony import */ var _AxisBuilder_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(89598);\n/* harmony import */ var _util_innerStore_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(69622);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nvar elementList = ['axisLine', 'axisLabel', 'axisTick', 'minorTick', 'splitLine', 'minorSplitLine', 'splitArea'];\nfunction getAxisLineShape(polar, rExtent, angle) {\n  rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());\n  var start = polar.coordToPoint([rExtent[0], angle]);\n  var end = polar.coordToPoint([rExtent[1], angle]);\n  return {\n    x1: start[0],\n    y1: start[1],\n    x2: end[0],\n    y2: end[1]\n  };\n}\nfunction getRadiusIdx(polar) {\n  var radiusAxis = polar.getRadiusAxis();\n  return radiusAxis.inverse ? 0 : 1;\n}\n// Remove the last tick which will overlap the first tick\nfunction fixAngleOverlap(list) {\n  var firstItem = list[0];\n  var lastItem = list[list.length - 1];\n  if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {\n    list.pop();\n  }\n}\nvar AngleAxisView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(AngleAxisView, _super);\n  function AngleAxisView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = AngleAxisView.type;\n    _this.axisPointerClass = 'PolarAxisPointer';\n    return _this;\n  }\n  AngleAxisView.prototype.render = function (angleAxisModel, ecModel) {\n    this.group.removeAll();\n    if (!angleAxisModel.get('show')) {\n      return;\n    }\n    var angleAxis = angleAxisModel.axis;\n    var polar = angleAxis.polar;\n    var radiusExtent = polar.getRadiusAxis().getExtent();\n    var ticksAngles = angleAxis.getTicksCoords();\n    var minorTickAngles = angleAxis.getMinorTicksCoords();\n    var labels = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map(angleAxis.getViewLabels(), function (labelItem) {\n      labelItem = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.clone(labelItem);\n      var scale = angleAxis.scale;\n      var tickValue = scale.type === 'ordinal' ? scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;\n      labelItem.coord = angleAxis.dataToCoord(tickValue);\n      return labelItem;\n    });\n    fixAngleOverlap(labels);\n    fixAngleOverlap(ticksAngles);\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(elementList, function (name) {\n      if (angleAxisModel.get([name, 'show']) && (!angleAxis.scale.isBlank() || name === 'axisLine')) {\n        angelAxisElementsBuilders[name](this.group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels);\n      }\n    }, this);\n  };\n  AngleAxisView.type = 'angleAxis';\n  return AngleAxisView;\n}(_AxisView_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A);\nvar angelAxisElementsBuilders = {\n  axisLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n    var lineStyleModel = angleAxisModel.getModel(['axisLine', 'lineStyle']);\n    var angleAxis = polar.getAngleAxis();\n    var RADIAN = Math.PI / 180;\n    var angleExtent = angleAxis.getExtent();\n    // extent id of the axis radius (r0 and r)\n    var rId = getRadiusIdx(polar);\n    var r0Id = rId ? 0 : 1;\n    var shape;\n    var shapeType = Math.abs(angleExtent[1] - angleExtent[0]) === 360 ? 'Circle' : 'Arc';\n    if (radiusExtent[r0Id] === 0) {\n      shape = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__[shapeType]({\n        shape: {\n          cx: polar.cx,\n          cy: polar.cy,\n          r: radiusExtent[rId],\n          startAngle: -angleExtent[0] * RADIAN,\n          endAngle: -angleExtent[1] * RADIAN,\n          clockwise: angleAxis.inverse\n        },\n        style: lineStyleModel.getLineStyle(),\n        z2: 1,\n        silent: true\n      });\n    } else {\n      shape = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A({\n        shape: {\n          cx: polar.cx,\n          cy: polar.cy,\n          r: radiusExtent[rId],\n          r0: radiusExtent[r0Id]\n        },\n        style: lineStyleModel.getLineStyle(),\n        z2: 1,\n        silent: true\n      });\n    }\n    shape.style.fill = null;\n    group.add(shape);\n  },\n  axisTick: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n    var tickModel = angleAxisModel.getModel('axisTick');\n    var tickLen = (tickModel.get('inside') ? -1 : 1) * tickModel.get('length');\n    var radius = radiusExtent[getRadiusIdx(polar)];\n    var lines = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map(ticksAngles, function (tickAngleItem) {\n      return new _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A({\n        shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)\n      });\n    });\n    group.add(_util_graphic_js__WEBPACK_IMPORTED_MODULE_3__.mergePath(lines, {\n      style: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults(tickModel.getModel('lineStyle').getLineStyle(), {\n        stroke: angleAxisModel.get(['axisLine', 'lineStyle', 'color'])\n      })\n    }));\n  },\n  minorTick: function (group, angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {\n    if (!minorTickAngles.length) {\n      return;\n    }\n    var tickModel = angleAxisModel.getModel('axisTick');\n    var minorTickModel = angleAxisModel.getModel('minorTick');\n    var tickLen = (tickModel.get('inside') ? -1 : 1) * minorTickModel.get('length');\n    var radius = radiusExtent[getRadiusIdx(polar)];\n    var lines = [];\n    for (var i = 0; i < minorTickAngles.length; i++) {\n      for (var k = 0; k < minorTickAngles[i].length; k++) {\n        lines.push(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A({\n          shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i][k].coord)\n        }));\n      }\n    }\n    group.add(_util_graphic_js__WEBPACK_IMPORTED_MODULE_3__.mergePath(lines, {\n      style: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults(minorTickModel.getModel('lineStyle').getLineStyle(), zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults(tickModel.getLineStyle(), {\n        stroke: angleAxisModel.get(['axisLine', 'lineStyle', 'color'])\n      }))\n    }));\n  },\n  axisLabel: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {\n    var rawCategoryData = angleAxisModel.getCategories(true);\n    var commonLabelModel = angleAxisModel.getModel('axisLabel');\n    var labelMargin = commonLabelModel.get('margin');\n    var triggerEvent = angleAxisModel.get('triggerEvent');\n    // Use length of ticksAngles because it may remove the last tick to avoid overlapping\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(labels, function (labelItem, idx) {\n      var labelModel = commonLabelModel;\n      var tickValue = labelItem.tickValue;\n      var r = radiusExtent[getRadiusIdx(polar)];\n      var p = polar.coordToPoint([r + labelMargin, labelItem.coord]);\n      var cx = polar.cx;\n      var cy = polar.cy;\n      var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? 'center' : p[0] > cx ? 'left' : 'right';\n      var labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? 'middle' : p[1] > cy ? 'top' : 'bottom';\n      if (rawCategoryData && rawCategoryData[tickValue]) {\n        var rawCategoryItem = rawCategoryData[tickValue];\n        if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject(rawCategoryItem) && rawCategoryItem.textStyle) {\n          labelModel = new _model_Model_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A(rawCategoryItem.textStyle, commonLabelModel, commonLabelModel.ecModel);\n        }\n      }\n      var textEl = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .Ay({\n        silent: _AxisBuilder_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .A.isLabelSilent(angleAxisModel),\n        style: (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_9__/* .createTextStyle */ .VB)(labelModel, {\n          x: p[0],\n          y: p[1],\n          fill: labelModel.getTextColor() || angleAxisModel.get(['axisLine', 'lineStyle', 'color']),\n          text: labelItem.formattedLabel,\n          align: labelTextAlign,\n          verticalAlign: labelTextVerticalAlign\n        })\n      });\n      group.add(textEl);\n      // Pack data for mouse event\n      if (triggerEvent) {\n        var eventData = _AxisBuilder_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .A.makeAxisEventDataBase(angleAxisModel);\n        eventData.targetType = 'axisLabel';\n        eventData.value = labelItem.rawLabel;\n        (0,_util_innerStore_js__WEBPACK_IMPORTED_MODULE_10__/* .getECData */ .z)(textEl).eventData = eventData;\n      }\n    }, this);\n  },\n  splitLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n    var splitLineModel = angleAxisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineCount = 0;\n    lineColors = lineColors instanceof Array ? lineColors : [lineColors];\n    var splitLines = [];\n    for (var i = 0; i < ticksAngles.length; i++) {\n      var colorIndex = lineCount++ % lineColors.length;\n      splitLines[colorIndex] = splitLines[colorIndex] || [];\n      splitLines[colorIndex].push(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A({\n        shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)\n      }));\n    }\n    // Simple optimization\n    // Batching the lines if color are the same\n    for (var i = 0; i < splitLines.length; i++) {\n      group.add(_util_graphic_js__WEBPACK_IMPORTED_MODULE_3__.mergePath(splitLines[i], {\n        style: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults({\n          stroke: lineColors[i % lineColors.length]\n        }, lineStyleModel.getLineStyle()),\n        silent: true,\n        z: angleAxisModel.get('z')\n      }));\n    }\n  },\n  minorSplitLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n    if (!minorTickAngles.length) {\n      return;\n    }\n    var minorSplitLineModel = angleAxisModel.getModel('minorSplitLine');\n    var lineStyleModel = minorSplitLineModel.getModel('lineStyle');\n    var lines = [];\n    for (var i = 0; i < minorTickAngles.length; i++) {\n      for (var k = 0; k < minorTickAngles[i].length; k++) {\n        lines.push(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A({\n          shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i][k].coord)\n        }));\n      }\n    }\n    group.add(_util_graphic_js__WEBPACK_IMPORTED_MODULE_3__.mergePath(lines, {\n      style: lineStyleModel.getLineStyle(),\n      silent: true,\n      z: angleAxisModel.get('z')\n    }));\n  },\n  splitArea: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n    if (!ticksAngles.length) {\n      return;\n    }\n    var splitAreaModel = angleAxisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var lineCount = 0;\n    areaColors = areaColors instanceof Array ? areaColors : [areaColors];\n    var splitAreas = [];\n    var RADIAN = Math.PI / 180;\n    var prevAngle = -ticksAngles[0].coord * RADIAN;\n    var r0 = Math.min(radiusExtent[0], radiusExtent[1]);\n    var r1 = Math.max(radiusExtent[0], radiusExtent[1]);\n    var clockwise = angleAxisModel.get('clockwise');\n    for (var i = 1, len = ticksAngles.length; i <= len; i++) {\n      var coord = i === len ? ticksAngles[0].coord : ticksAngles[i].coord;\n      var colorIndex = lineCount++ % areaColors.length;\n      splitAreas[colorIndex] = splitAreas[colorIndex] || [];\n      splitAreas[colorIndex].push(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_11__/* [\"default\"] */ .A({\n        shape: {\n          cx: polar.cx,\n          cy: polar.cy,\n          r0: r0,\n          r: r1,\n          startAngle: prevAngle,\n          endAngle: -coord * RADIAN,\n          clockwise: clockwise\n        },\n        silent: true\n      }));\n      prevAngle = -coord * RADIAN;\n    }\n    // Simple optimization\n    // Batching the lines if color are the same\n    for (var i = 0; i < splitAreas.length; i++) {\n      group.add(_util_graphic_js__WEBPACK_IMPORTED_MODULE_3__.mergePath(splitAreas[i], {\n        style: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults({\n          fill: areaColors[i % areaColors.length]\n        }, areaStyleModel.getAreaStyle()),\n        silent: true\n      }));\n    }\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AngleAxisView);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTk0ODEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9BbmdsZUF4aXNWaWV3LmpzPzNiNDEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IHsgY3JlYXRlVGV4dFN0eWxlIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvTW9kZWwuanMnO1xuaW1wb3J0IEF4aXNWaWV3IGZyb20gJy4vQXhpc1ZpZXcuanMnO1xuaW1wb3J0IEF4aXNCdWlsZGVyIGZyb20gJy4vQXhpc0J1aWxkZXIuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlLmpzJztcbnZhciBlbGVtZW50TGlzdCA9IFsnYXhpc0xpbmUnLCAnYXhpc0xhYmVsJywgJ2F4aXNUaWNrJywgJ21pbm9yVGljaycsICdzcGxpdExpbmUnLCAnbWlub3JTcGxpdExpbmUnLCAnc3BsaXRBcmVhJ107XG5mdW5jdGlvbiBnZXRBeGlzTGluZVNoYXBlKHBvbGFyLCByRXh0ZW50LCBhbmdsZSkge1xuICByRXh0ZW50WzFdID4gckV4dGVudFswXSAmJiAockV4dGVudCA9IHJFeHRlbnQuc2xpY2UoKS5yZXZlcnNlKCkpO1xuICB2YXIgc3RhcnQgPSBwb2xhci5jb29yZFRvUG9pbnQoW3JFeHRlbnRbMF0sIGFuZ2xlXSk7XG4gIHZhciBlbmQgPSBwb2xhci5jb29yZFRvUG9pbnQoW3JFeHRlbnRbMV0sIGFuZ2xlXSk7XG4gIHJldHVybiB7XG4gICAgeDE6IHN0YXJ0WzBdLFxuICAgIHkxOiBzdGFydFsxXSxcbiAgICB4MjogZW5kWzBdLFxuICAgIHkyOiBlbmRbMV1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJhZGl1c0lkeChwb2xhcikge1xuICB2YXIgcmFkaXVzQXhpcyA9IHBvbGFyLmdldFJhZGl1c0F4aXMoKTtcbiAgcmV0dXJuIHJhZGl1c0F4aXMuaW52ZXJzZSA/IDAgOiAxO1xufVxuLy8gUmVtb3ZlIHRoZSBsYXN0IHRpY2sgd2hpY2ggd2lsbCBvdmVybGFwIHRoZSBmaXJzdCB0aWNrXG5mdW5jdGlvbiBmaXhBbmdsZU92ZXJsYXAobGlzdCkge1xuICB2YXIgZmlyc3RJdGVtID0gbGlzdFswXTtcbiAgdmFyIGxhc3RJdGVtID0gbGlzdFtsaXN0Lmxlbmd0aCAtIDFdO1xuICBpZiAoZmlyc3RJdGVtICYmIGxhc3RJdGVtICYmIE1hdGguYWJzKE1hdGguYWJzKGZpcnN0SXRlbS5jb29yZCAtIGxhc3RJdGVtLmNvb3JkKSAtIDM2MCkgPCAxZS00KSB7XG4gICAgbGlzdC5wb3AoKTtcbiAgfVxufVxudmFyIEFuZ2xlQXhpc1ZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQW5nbGVBeGlzVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gQW5nbGVBeGlzVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gQW5nbGVBeGlzVmlldy50eXBlO1xuICAgIF90aGlzLmF4aXNQb2ludGVyQ2xhc3MgPSAnUG9sYXJBeGlzUG9pbnRlcic7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEFuZ2xlQXhpc1ZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChhbmdsZUF4aXNNb2RlbCwgZWNNb2RlbCkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgaWYgKCFhbmdsZUF4aXNNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYW5nbGVBeGlzID0gYW5nbGVBeGlzTW9kZWwuYXhpcztcbiAgICB2YXIgcG9sYXIgPSBhbmdsZUF4aXMucG9sYXI7XG4gICAgdmFyIHJhZGl1c0V4dGVudCA9IHBvbGFyLmdldFJhZGl1c0F4aXMoKS5nZXRFeHRlbnQoKTtcbiAgICB2YXIgdGlja3NBbmdsZXMgPSBhbmdsZUF4aXMuZ2V0VGlja3NDb29yZHMoKTtcbiAgICB2YXIgbWlub3JUaWNrQW5nbGVzID0gYW5nbGVBeGlzLmdldE1pbm9yVGlja3NDb29yZHMoKTtcbiAgICB2YXIgbGFiZWxzID0genJVdGlsLm1hcChhbmdsZUF4aXMuZ2V0Vmlld0xhYmVscygpLCBmdW5jdGlvbiAobGFiZWxJdGVtKSB7XG4gICAgICBsYWJlbEl0ZW0gPSB6clV0aWwuY2xvbmUobGFiZWxJdGVtKTtcbiAgICAgIHZhciBzY2FsZSA9IGFuZ2xlQXhpcy5zY2FsZTtcbiAgICAgIHZhciB0aWNrVmFsdWUgPSBzY2FsZS50eXBlID09PSAnb3JkaW5hbCcgPyBzY2FsZS5nZXRSYXdPcmRpbmFsTnVtYmVyKGxhYmVsSXRlbS50aWNrVmFsdWUpIDogbGFiZWxJdGVtLnRpY2tWYWx1ZTtcbiAgICAgIGxhYmVsSXRlbS5jb29yZCA9IGFuZ2xlQXhpcy5kYXRhVG9Db29yZCh0aWNrVmFsdWUpO1xuICAgICAgcmV0dXJuIGxhYmVsSXRlbTtcbiAgICB9KTtcbiAgICBmaXhBbmdsZU92ZXJsYXAobGFiZWxzKTtcbiAgICBmaXhBbmdsZU92ZXJsYXAodGlja3NBbmdsZXMpO1xuICAgIHpyVXRpbC5lYWNoKGVsZW1lbnRMaXN0LCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKGFuZ2xlQXhpc01vZGVsLmdldChbbmFtZSwgJ3Nob3cnXSkgJiYgKCFhbmdsZUF4aXMuc2NhbGUuaXNCbGFuaygpIHx8IG5hbWUgPT09ICdheGlzTGluZScpKSB7XG4gICAgICAgIGFuZ2VsQXhpc0VsZW1lbnRzQnVpbGRlcnNbbmFtZV0odGhpcy5ncm91cCwgYW5nbGVBeGlzTW9kZWwsIHBvbGFyLCB0aWNrc0FuZ2xlcywgbWlub3JUaWNrQW5nbGVzLCByYWRpdXNFeHRlbnQsIGxhYmVscyk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIEFuZ2xlQXhpc1ZpZXcudHlwZSA9ICdhbmdsZUF4aXMnO1xuICByZXR1cm4gQW5nbGVBeGlzVmlldztcbn0oQXhpc1ZpZXcpO1xudmFyIGFuZ2VsQXhpc0VsZW1lbnRzQnVpbGRlcnMgPSB7XG4gIGF4aXNMaW5lOiBmdW5jdGlvbiAoZ3JvdXAsIGFuZ2xlQXhpc01vZGVsLCBwb2xhciwgdGlja3NBbmdsZXMsIG1pbm9yVGlja0FuZ2xlcywgcmFkaXVzRXh0ZW50KSB7XG4gICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gYW5nbGVBeGlzTW9kZWwuZ2V0TW9kZWwoWydheGlzTGluZScsICdsaW5lU3R5bGUnXSk7XG4gICAgdmFyIGFuZ2xlQXhpcyA9IHBvbGFyLmdldEFuZ2xlQXhpcygpO1xuICAgIHZhciBSQURJQU4gPSBNYXRoLlBJIC8gMTgwO1xuICAgIHZhciBhbmdsZUV4dGVudCA9IGFuZ2xlQXhpcy5nZXRFeHRlbnQoKTtcbiAgICAvLyBleHRlbnQgaWQgb2YgdGhlIGF4aXMgcmFkaXVzIChyMCBhbmQgcilcbiAgICB2YXIgcklkID0gZ2V0UmFkaXVzSWR4KHBvbGFyKTtcbiAgICB2YXIgcjBJZCA9IHJJZCA/IDAgOiAxO1xuICAgIHZhciBzaGFwZTtcbiAgICB2YXIgc2hhcGVUeXBlID0gTWF0aC5hYnMoYW5nbGVFeHRlbnRbMV0gLSBhbmdsZUV4dGVudFswXSkgPT09IDM2MCA/ICdDaXJjbGUnIDogJ0FyYyc7XG4gICAgaWYgKHJhZGl1c0V4dGVudFtyMElkXSA9PT0gMCkge1xuICAgICAgc2hhcGUgPSBuZXcgZ3JhcGhpY1tzaGFwZVR5cGVdKHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICBjeDogcG9sYXIuY3gsXG4gICAgICAgICAgY3k6IHBvbGFyLmN5LFxuICAgICAgICAgIHI6IHJhZGl1c0V4dGVudFtySWRdLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IC1hbmdsZUV4dGVudFswXSAqIFJBRElBTixcbiAgICAgICAgICBlbmRBbmdsZTogLWFuZ2xlRXh0ZW50WzFdICogUkFESUFOLFxuICAgICAgICAgIGNsb2Nrd2lzZTogYW5nbGVBeGlzLmludmVyc2VcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpLFxuICAgICAgICB6MjogMSxcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hhcGUgPSBuZXcgZ3JhcGhpYy5SaW5nKHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICBjeDogcG9sYXIuY3gsXG4gICAgICAgICAgY3k6IHBvbGFyLmN5LFxuICAgICAgICAgIHI6IHJhZGl1c0V4dGVudFtySWRdLFxuICAgICAgICAgIHIwOiByYWRpdXNFeHRlbnRbcjBJZF1cbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpLFxuICAgICAgICB6MjogMSxcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgc2hhcGUuc3R5bGUuZmlsbCA9IG51bGw7XG4gICAgZ3JvdXAuYWRkKHNoYXBlKTtcbiAgfSxcbiAgYXhpc1RpY2s6IGZ1bmN0aW9uIChncm91cCwgYW5nbGVBeGlzTW9kZWwsIHBvbGFyLCB0aWNrc0FuZ2xlcywgbWlub3JUaWNrQW5nbGVzLCByYWRpdXNFeHRlbnQpIHtcbiAgICB2YXIgdGlja01vZGVsID0gYW5nbGVBeGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNUaWNrJyk7XG4gICAgdmFyIHRpY2tMZW4gPSAodGlja01vZGVsLmdldCgnaW5zaWRlJykgPyAtMSA6IDEpICogdGlja01vZGVsLmdldCgnbGVuZ3RoJyk7XG4gICAgdmFyIHJhZGl1cyA9IHJhZGl1c0V4dGVudFtnZXRSYWRpdXNJZHgocG9sYXIpXTtcbiAgICB2YXIgbGluZXMgPSB6clV0aWwubWFwKHRpY2tzQW5nbGVzLCBmdW5jdGlvbiAodGlja0FuZ2xlSXRlbSkge1xuICAgICAgcmV0dXJuIG5ldyBncmFwaGljLkxpbmUoe1xuICAgICAgICBzaGFwZTogZ2V0QXhpc0xpbmVTaGFwZShwb2xhciwgW3JhZGl1cywgcmFkaXVzICsgdGlja0xlbl0sIHRpY2tBbmdsZUl0ZW0uY29vcmQpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBncm91cC5hZGQoZ3JhcGhpYy5tZXJnZVBhdGgobGluZXMsIHtcbiAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHModGlja01vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKSwge1xuICAgICAgICBzdHJva2U6IGFuZ2xlQXhpc01vZGVsLmdldChbJ2F4aXNMaW5lJywgJ2xpbmVTdHlsZScsICdjb2xvciddKVxuICAgICAgfSlcbiAgICB9KSk7XG4gIH0sXG4gIG1pbm9yVGljazogZnVuY3Rpb24gKGdyb3VwLCBhbmdsZUF4aXNNb2RlbCwgcG9sYXIsIHRpY2tBbmdsZXMsIG1pbm9yVGlja0FuZ2xlcywgcmFkaXVzRXh0ZW50KSB7XG4gICAgaWYgKCFtaW5vclRpY2tBbmdsZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aWNrTW9kZWwgPSBhbmdsZUF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc1RpY2snKTtcbiAgICB2YXIgbWlub3JUaWNrTW9kZWwgPSBhbmdsZUF4aXNNb2RlbC5nZXRNb2RlbCgnbWlub3JUaWNrJyk7XG4gICAgdmFyIHRpY2tMZW4gPSAodGlja01vZGVsLmdldCgnaW5zaWRlJykgPyAtMSA6IDEpICogbWlub3JUaWNrTW9kZWwuZ2V0KCdsZW5ndGgnKTtcbiAgICB2YXIgcmFkaXVzID0gcmFkaXVzRXh0ZW50W2dldFJhZGl1c0lkeChwb2xhcildO1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWlub3JUaWNrQW5nbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IG1pbm9yVGlja0FuZ2xlc1tpXS5sZW5ndGg7IGsrKykge1xuICAgICAgICBsaW5lcy5wdXNoKG5ldyBncmFwaGljLkxpbmUoe1xuICAgICAgICAgIHNoYXBlOiBnZXRBeGlzTGluZVNoYXBlKHBvbGFyLCBbcmFkaXVzLCByYWRpdXMgKyB0aWNrTGVuXSwgbWlub3JUaWNrQW5nbGVzW2ldW2tdLmNvb3JkKVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGdyb3VwLmFkZChncmFwaGljLm1lcmdlUGF0aChsaW5lcywge1xuICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyhtaW5vclRpY2tNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCksIHpyVXRpbC5kZWZhdWx0cyh0aWNrTW9kZWwuZ2V0TGluZVN0eWxlKCksIHtcbiAgICAgICAgc3Ryb2tlOiBhbmdsZUF4aXNNb2RlbC5nZXQoWydheGlzTGluZScsICdsaW5lU3R5bGUnLCAnY29sb3InXSlcbiAgICAgIH0pKVxuICAgIH0pKTtcbiAgfSxcbiAgYXhpc0xhYmVsOiBmdW5jdGlvbiAoZ3JvdXAsIGFuZ2xlQXhpc01vZGVsLCBwb2xhciwgdGlja3NBbmdsZXMsIG1pbm9yVGlja0FuZ2xlcywgcmFkaXVzRXh0ZW50LCBsYWJlbHMpIHtcbiAgICB2YXIgcmF3Q2F0ZWdvcnlEYXRhID0gYW5nbGVBeGlzTW9kZWwuZ2V0Q2F0ZWdvcmllcyh0cnVlKTtcbiAgICB2YXIgY29tbW9uTGFiZWxNb2RlbCA9IGFuZ2xlQXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKTtcbiAgICB2YXIgbGFiZWxNYXJnaW4gPSBjb21tb25MYWJlbE1vZGVsLmdldCgnbWFyZ2luJyk7XG4gICAgdmFyIHRyaWdnZXJFdmVudCA9IGFuZ2xlQXhpc01vZGVsLmdldCgndHJpZ2dlckV2ZW50Jyk7XG4gICAgLy8gVXNlIGxlbmd0aCBvZiB0aWNrc0FuZ2xlcyBiZWNhdXNlIGl0IG1heSByZW1vdmUgdGhlIGxhc3QgdGljayB0byBhdm9pZCBvdmVybGFwcGluZ1xuICAgIHpyVXRpbC5lYWNoKGxhYmVscywgZnVuY3Rpb24gKGxhYmVsSXRlbSwgaWR4KSB7XG4gICAgICB2YXIgbGFiZWxNb2RlbCA9IGNvbW1vbkxhYmVsTW9kZWw7XG4gICAgICB2YXIgdGlja1ZhbHVlID0gbGFiZWxJdGVtLnRpY2tWYWx1ZTtcbiAgICAgIHZhciByID0gcmFkaXVzRXh0ZW50W2dldFJhZGl1c0lkeChwb2xhcildO1xuICAgICAgdmFyIHAgPSBwb2xhci5jb29yZFRvUG9pbnQoW3IgKyBsYWJlbE1hcmdpbiwgbGFiZWxJdGVtLmNvb3JkXSk7XG4gICAgICB2YXIgY3ggPSBwb2xhci5jeDtcbiAgICAgIHZhciBjeSA9IHBvbGFyLmN5O1xuICAgICAgdmFyIGxhYmVsVGV4dEFsaWduID0gTWF0aC5hYnMocFswXSAtIGN4KSAvIHIgPCAwLjMgPyAnY2VudGVyJyA6IHBbMF0gPiBjeCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICB2YXIgbGFiZWxUZXh0VmVydGljYWxBbGlnbiA9IE1hdGguYWJzKHBbMV0gLSBjeSkgLyByIDwgMC4zID8gJ21pZGRsZScgOiBwWzFdID4gY3kgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgaWYgKHJhd0NhdGVnb3J5RGF0YSAmJiByYXdDYXRlZ29yeURhdGFbdGlja1ZhbHVlXSkge1xuICAgICAgICB2YXIgcmF3Q2F0ZWdvcnlJdGVtID0gcmF3Q2F0ZWdvcnlEYXRhW3RpY2tWYWx1ZV07XG4gICAgICAgIGlmICh6clV0aWwuaXNPYmplY3QocmF3Q2F0ZWdvcnlJdGVtKSAmJiByYXdDYXRlZ29yeUl0ZW0udGV4dFN0eWxlKSB7XG4gICAgICAgICAgbGFiZWxNb2RlbCA9IG5ldyBNb2RlbChyYXdDYXRlZ29yeUl0ZW0udGV4dFN0eWxlLCBjb21tb25MYWJlbE1vZGVsLCBjb21tb25MYWJlbE1vZGVsLmVjTW9kZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdGV4dEVsID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgIHNpbGVudDogQXhpc0J1aWxkZXIuaXNMYWJlbFNpbGVudChhbmdsZUF4aXNNb2RlbCksXG4gICAgICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUobGFiZWxNb2RlbCwge1xuICAgICAgICAgIHg6IHBbMF0sXG4gICAgICAgICAgeTogcFsxXSxcbiAgICAgICAgICBmaWxsOiBsYWJlbE1vZGVsLmdldFRleHRDb2xvcigpIHx8IGFuZ2xlQXhpc01vZGVsLmdldChbJ2F4aXNMaW5lJywgJ2xpbmVTdHlsZScsICdjb2xvciddKSxcbiAgICAgICAgICB0ZXh0OiBsYWJlbEl0ZW0uZm9ybWF0dGVkTGFiZWwsXG4gICAgICAgICAgYWxpZ246IGxhYmVsVGV4dEFsaWduLFxuICAgICAgICAgIHZlcnRpY2FsQWxpZ246IGxhYmVsVGV4dFZlcnRpY2FsQWxpZ25cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgZ3JvdXAuYWRkKHRleHRFbCk7XG4gICAgICAvLyBQYWNrIGRhdGEgZm9yIG1vdXNlIGV2ZW50XG4gICAgICBpZiAodHJpZ2dlckV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudERhdGEgPSBBeGlzQnVpbGRlci5tYWtlQXhpc0V2ZW50RGF0YUJhc2UoYW5nbGVBeGlzTW9kZWwpO1xuICAgICAgICBldmVudERhdGEudGFyZ2V0VHlwZSA9ICdheGlzTGFiZWwnO1xuICAgICAgICBldmVudERhdGEudmFsdWUgPSBsYWJlbEl0ZW0ucmF3TGFiZWw7XG4gICAgICAgIGdldEVDRGF0YSh0ZXh0RWwpLmV2ZW50RGF0YSA9IGV2ZW50RGF0YTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfSxcbiAgc3BsaXRMaW5lOiBmdW5jdGlvbiAoZ3JvdXAsIGFuZ2xlQXhpc01vZGVsLCBwb2xhciwgdGlja3NBbmdsZXMsIG1pbm9yVGlja0FuZ2xlcywgcmFkaXVzRXh0ZW50KSB7XG4gICAgdmFyIHNwbGl0TGluZU1vZGVsID0gYW5nbGVBeGlzTW9kZWwuZ2V0TW9kZWwoJ3NwbGl0TGluZScpO1xuICAgIHZhciBsaW5lU3R5bGVNb2RlbCA9IHNwbGl0TGluZU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgICB2YXIgbGluZUNvbG9ycyA9IGxpbmVTdHlsZU1vZGVsLmdldCgnY29sb3InKTtcbiAgICB2YXIgbGluZUNvdW50ID0gMDtcbiAgICBsaW5lQ29sb3JzID0gbGluZUNvbG9ycyBpbnN0YW5jZW9mIEFycmF5ID8gbGluZUNvbG9ycyA6IFtsaW5lQ29sb3JzXTtcbiAgICB2YXIgc3BsaXRMaW5lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3NBbmdsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb2xvckluZGV4ID0gbGluZUNvdW50KysgJSBsaW5lQ29sb3JzLmxlbmd0aDtcbiAgICAgIHNwbGl0TGluZXNbY29sb3JJbmRleF0gPSBzcGxpdExpbmVzW2NvbG9ySW5kZXhdIHx8IFtdO1xuICAgICAgc3BsaXRMaW5lc1tjb2xvckluZGV4XS5wdXNoKG5ldyBncmFwaGljLkxpbmUoe1xuICAgICAgICBzaGFwZTogZ2V0QXhpc0xpbmVTaGFwZShwb2xhciwgcmFkaXVzRXh0ZW50LCB0aWNrc0FuZ2xlc1tpXS5jb29yZClcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxuICAgIC8vIEJhdGNoaW5nIHRoZSBsaW5lcyBpZiBjb2xvciBhcmUgdGhlIHNhbWVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdyb3VwLmFkZChncmFwaGljLm1lcmdlUGF0aChzcGxpdExpbmVzW2ldLCB7XG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIHN0cm9rZTogbGluZUNvbG9yc1tpICUgbGluZUNvbG9ycy5sZW5ndGhdXG4gICAgICAgIH0sIGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpKSxcbiAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICB6OiBhbmdsZUF4aXNNb2RlbC5nZXQoJ3onKVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSxcbiAgbWlub3JTcGxpdExpbmU6IGZ1bmN0aW9uIChncm91cCwgYW5nbGVBeGlzTW9kZWwsIHBvbGFyLCB0aWNrc0FuZ2xlcywgbWlub3JUaWNrQW5nbGVzLCByYWRpdXNFeHRlbnQpIHtcbiAgICBpZiAoIW1pbm9yVGlja0FuZ2xlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG1pbm9yU3BsaXRMaW5lTW9kZWwgPSBhbmdsZUF4aXNNb2RlbC5nZXRNb2RlbCgnbWlub3JTcGxpdExpbmUnKTtcbiAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSBtaW5vclNwbGl0TGluZU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbm9yVGlja0FuZ2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBtaW5vclRpY2tBbmdsZXNbaV0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgbGluZXMucHVzaChuZXcgZ3JhcGhpYy5MaW5lKHtcbiAgICAgICAgICBzaGFwZTogZ2V0QXhpc0xpbmVTaGFwZShwb2xhciwgcmFkaXVzRXh0ZW50LCBtaW5vclRpY2tBbmdsZXNbaV1ba10uY29vcmQpXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ3JvdXAuYWRkKGdyYXBoaWMubWVyZ2VQYXRoKGxpbmVzLCB7XG4gICAgICBzdHlsZTogbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCksXG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICB6OiBhbmdsZUF4aXNNb2RlbC5nZXQoJ3onKVxuICAgIH0pKTtcbiAgfSxcbiAgc3BsaXRBcmVhOiBmdW5jdGlvbiAoZ3JvdXAsIGFuZ2xlQXhpc01vZGVsLCBwb2xhciwgdGlja3NBbmdsZXMsIG1pbm9yVGlja0FuZ2xlcywgcmFkaXVzRXh0ZW50KSB7XG4gICAgaWYgKCF0aWNrc0FuZ2xlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNwbGl0QXJlYU1vZGVsID0gYW5nbGVBeGlzTW9kZWwuZ2V0TW9kZWwoJ3NwbGl0QXJlYScpO1xuICAgIHZhciBhcmVhU3R5bGVNb2RlbCA9IHNwbGl0QXJlYU1vZGVsLmdldE1vZGVsKCdhcmVhU3R5bGUnKTtcbiAgICB2YXIgYXJlYUNvbG9ycyA9IGFyZWFTdHlsZU1vZGVsLmdldCgnY29sb3InKTtcbiAgICB2YXIgbGluZUNvdW50ID0gMDtcbiAgICBhcmVhQ29sb3JzID0gYXJlYUNvbG9ycyBpbnN0YW5jZW9mIEFycmF5ID8gYXJlYUNvbG9ycyA6IFthcmVhQ29sb3JzXTtcbiAgICB2YXIgc3BsaXRBcmVhcyA9IFtdO1xuICAgIHZhciBSQURJQU4gPSBNYXRoLlBJIC8gMTgwO1xuICAgIHZhciBwcmV2QW5nbGUgPSAtdGlja3NBbmdsZXNbMF0uY29vcmQgKiBSQURJQU47XG4gICAgdmFyIHIwID0gTWF0aC5taW4ocmFkaXVzRXh0ZW50WzBdLCByYWRpdXNFeHRlbnRbMV0pO1xuICAgIHZhciByMSA9IE1hdGgubWF4KHJhZGl1c0V4dGVudFswXSwgcmFkaXVzRXh0ZW50WzFdKTtcbiAgICB2YXIgY2xvY2t3aXNlID0gYW5nbGVBeGlzTW9kZWwuZ2V0KCdjbG9ja3dpc2UnKTtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGlja3NBbmdsZXMubGVuZ3RoOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgY29vcmQgPSBpID09PSBsZW4gPyB0aWNrc0FuZ2xlc1swXS5jb29yZCA6IHRpY2tzQW5nbGVzW2ldLmNvb3JkO1xuICAgICAgdmFyIGNvbG9ySW5kZXggPSBsaW5lQ291bnQrKyAlIGFyZWFDb2xvcnMubGVuZ3RoO1xuICAgICAgc3BsaXRBcmVhc1tjb2xvckluZGV4XSA9IHNwbGl0QXJlYXNbY29sb3JJbmRleF0gfHwgW107XG4gICAgICBzcGxpdEFyZWFzW2NvbG9ySW5kZXhdLnB1c2gobmV3IGdyYXBoaWMuU2VjdG9yKHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICBjeDogcG9sYXIuY3gsXG4gICAgICAgICAgY3k6IHBvbGFyLmN5LFxuICAgICAgICAgIHIwOiByMCxcbiAgICAgICAgICByOiByMSxcbiAgICAgICAgICBzdGFydEFuZ2xlOiBwcmV2QW5nbGUsXG4gICAgICAgICAgZW5kQW5nbGU6IC1jb29yZCAqIFJBRElBTixcbiAgICAgICAgICBjbG9ja3dpc2U6IGNsb2Nrd2lzZVxuICAgICAgICB9LFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICAgIHByZXZBbmdsZSA9IC1jb29yZCAqIFJBRElBTjtcbiAgICB9XG4gICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxuICAgIC8vIEJhdGNoaW5nIHRoZSBsaW5lcyBpZiBjb2xvciBhcmUgdGhlIHNhbWVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0QXJlYXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdyb3VwLmFkZChncmFwaGljLm1lcmdlUGF0aChzcGxpdEFyZWFzW2ldLCB7XG4gICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgIGZpbGw6IGFyZWFDb2xvcnNbaSAlIGFyZWFDb2xvcnMubGVuZ3RoXVxuICAgICAgICB9LCBhcmVhU3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKSksXG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IEFuZ2xlQXhpc1ZpZXc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///59481\n")},60755:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _AxisBuilder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89598);\n/* harmony import */ var _helper_BrushController_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14403);\n/* harmony import */ var _helper_brushHelper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(25451);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43870);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(43199);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(29308);\n/* harmony import */ var _view_Component_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(59109);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar elementList = ['axisLine', 'axisTickLabel', 'axisName'];\nvar ParallelAxisView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(ParallelAxisView, _super);\n  function ParallelAxisView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ParallelAxisView.type;\n    return _this;\n  }\n  ParallelAxisView.prototype.init = function (ecModel, api) {\n    _super.prototype.init.apply(this, arguments);\n    (this._brushController = new _helper_BrushController_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A(api.getZr())).on('brush', zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.bind(this._onBrush, this));\n  };\n  ParallelAxisView.prototype.render = function (axisModel, ecModel, api, payload) {\n    if (fromAxisAreaSelect(axisModel, ecModel, payload)) {\n      return;\n    }\n    this.axisModel = axisModel;\n    this.api = api;\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A();\n    this.group.add(this._axisGroup);\n    if (!axisModel.get('show')) {\n      return;\n    }\n    var coordSysModel = getCoordSysModel(axisModel, ecModel);\n    var coordSys = coordSysModel.coordinateSystem;\n    var areaSelectStyle = axisModel.getAreaSelectStyle();\n    var areaWidth = areaSelectStyle.width;\n    var dim = axisModel.axis.dim;\n    var axisLayout = coordSys.getAxisLayout(dim);\n    var builderOpt = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.extend({\n      strokeContainThreshold: areaWidth\n    }, axisLayout);\n    var axisBuilder = new _AxisBuilder_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A(axisModel, builderOpt);\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each(elementList, axisBuilder.add, axisBuilder);\n    this._axisGroup.add(axisBuilder.getGroup());\n    this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api);\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n  };\n  // /**\n  //  * @override\n  //  */\n  // updateVisual(axisModel, ecModel, api, payload) {\n  //     this._brushController && this._brushController\n  //         .updateCovers(getCoverInfoList(axisModel));\n  // }\n  ParallelAxisView.prototype._refreshBrushController = function (builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api) {\n    // After filtering, axis may change, select area needs to be update.\n    var extent = axisModel.axis.getExtent();\n    var extentLen = extent[1] - extent[0];\n    var extra = Math.min(30, Math.abs(extentLen) * 0.1); // Arbitrary value.\n    // width/height might be negative, which will be\n    // normalized in BoundingRect.\n    var rect = _util_graphic_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A.create({\n      x: extent[0],\n      y: -areaWidth / 2,\n      width: extentLen,\n      height: areaWidth\n    });\n    rect.x -= extra;\n    rect.width += 2 * extra;\n    this._brushController.mount({\n      enableGlobalPan: true,\n      rotation: builderOpt.rotation,\n      x: builderOpt.position[0],\n      y: builderOpt.position[1]\n    }).setPanels([{\n      panelId: 'pl',\n      clipPath: _helper_brushHelper_js__WEBPACK_IMPORTED_MODULE_7__/* .makeRectPanelClipPath */ .wd(rect),\n      isTargetByCursor: _helper_brushHelper_js__WEBPACK_IMPORTED_MODULE_7__/* .makeRectIsTargetByCursor */ .x$(rect, api, coordSysModel),\n      getLinearBrushOtherExtent: _helper_brushHelper_js__WEBPACK_IMPORTED_MODULE_7__/* .makeLinearBrushOtherExtent */ .wx(rect, 0)\n    }]).enableBrush({\n      brushType: 'lineX',\n      brushStyle: areaSelectStyle,\n      removeOnClick: true\n    }).updateCovers(getCoverInfoList(axisModel));\n  };\n  ParallelAxisView.prototype._onBrush = function (eventParam) {\n    var coverInfoList = eventParam.areas;\n    // Do not cache these object, because the mey be changed.\n    var axisModel = this.axisModel;\n    var axis = axisModel.axis;\n    var intervals = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map(coverInfoList, function (coverInfo) {\n      return [axis.coordToData(coverInfo.range[0], true), axis.coordToData(coverInfo.range[1], true)];\n    });\n    // If realtime is true, action is not dispatched on drag end, because\n    // the drag end emits the same params with the last drag move event,\n    // and may have some delay when using touch pad.\n    if (!axisModel.option.realtime === eventParam.isEnd || eventParam.removeOnClick) {\n      // jshint ignore:line\n      this.api.dispatchAction({\n        type: 'axisAreaSelect',\n        parallelAxisId: axisModel.id,\n        intervals: intervals\n      });\n    }\n  };\n  ParallelAxisView.prototype.dispose = function () {\n    this._brushController.dispose();\n  };\n  ParallelAxisView.type = 'parallelAxis';\n  return ParallelAxisView;\n}(_view_Component_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .A);\nfunction fromAxisAreaSelect(axisModel, ecModel, payload) {\n  return payload && payload.type === 'axisAreaSelect' && ecModel.findComponents({\n    mainType: 'parallelAxis',\n    query: payload\n  })[0] === axisModel;\n}\nfunction getCoverInfoList(axisModel) {\n  var axis = axisModel.axis;\n  return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map(axisModel.activeIntervals, function (interval) {\n    return {\n      brushType: 'lineX',\n      panelId: 'pl',\n      range: [axis.dataToCoord(interval[0], true), axis.dataToCoord(interval[1], true)]\n    };\n  });\n}\nfunction getCoordSysModel(axisModel, ecModel) {\n  return ecModel.getComponent('parallel', axisModel.get('parallelIndex'));\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ParallelAxisView);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA3NTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL1BhcmFsbGVsQXhpc1ZpZXcuanM/YTY2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgQXhpc0J1aWxkZXIgZnJvbSAnLi9BeGlzQnVpbGRlci5qcyc7XG5pbXBvcnQgQnJ1c2hDb250cm9sbGVyIGZyb20gJy4uL2hlbHBlci9CcnVzaENvbnRyb2xsZXIuanMnO1xuaW1wb3J0ICogYXMgYnJ1c2hIZWxwZXIgZnJvbSAnLi4vaGVscGVyL2JydXNoSGVscGVyLmpzJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50LmpzJztcbnZhciBlbGVtZW50TGlzdCA9IFsnYXhpc0xpbmUnLCAnYXhpc1RpY2tMYWJlbCcsICdheGlzTmFtZSddO1xudmFyIFBhcmFsbGVsQXhpc1ZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUGFyYWxsZWxBeGlzVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gUGFyYWxsZWxBeGlzVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gUGFyYWxsZWxBeGlzVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBQYXJhbGxlbEF4aXNWaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICh0aGlzLl9icnVzaENvbnRyb2xsZXIgPSBuZXcgQnJ1c2hDb250cm9sbGVyKGFwaS5nZXRacigpKSkub24oJ2JydXNoJywgenJVdGlsLmJpbmQodGhpcy5fb25CcnVzaCwgdGhpcykpO1xuICB9O1xuICBQYXJhbGxlbEF4aXNWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICBpZiAoZnJvbUF4aXNBcmVhU2VsZWN0KGF4aXNNb2RlbCwgZWNNb2RlbCwgcGF5bG9hZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5heGlzTW9kZWwgPSBheGlzTW9kZWw7XG4gICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICB2YXIgb2xkQXhpc0dyb3VwID0gdGhpcy5fYXhpc0dyb3VwO1xuICAgIHRoaXMuX2F4aXNHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5fYXhpc0dyb3VwKTtcbiAgICBpZiAoIWF4aXNNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY29vcmRTeXNNb2RlbCA9IGdldENvb3JkU3lzTW9kZWwoYXhpc01vZGVsLCBlY01vZGVsKTtcbiAgICB2YXIgY29vcmRTeXMgPSBjb29yZFN5c01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGFyZWFTZWxlY3RTdHlsZSA9IGF4aXNNb2RlbC5nZXRBcmVhU2VsZWN0U3R5bGUoKTtcbiAgICB2YXIgYXJlYVdpZHRoID0gYXJlYVNlbGVjdFN0eWxlLndpZHRoO1xuICAgIHZhciBkaW0gPSBheGlzTW9kZWwuYXhpcy5kaW07XG4gICAgdmFyIGF4aXNMYXlvdXQgPSBjb29yZFN5cy5nZXRBeGlzTGF5b3V0KGRpbSk7XG4gICAgdmFyIGJ1aWxkZXJPcHQgPSB6clV0aWwuZXh0ZW5kKHtcbiAgICAgIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IGFyZWFXaWR0aFxuICAgIH0sIGF4aXNMYXlvdXQpO1xuICAgIHZhciBheGlzQnVpbGRlciA9IG5ldyBBeGlzQnVpbGRlcihheGlzTW9kZWwsIGJ1aWxkZXJPcHQpO1xuICAgIHpyVXRpbC5lYWNoKGVsZW1lbnRMaXN0LCBheGlzQnVpbGRlci5hZGQsIGF4aXNCdWlsZGVyKTtcbiAgICB0aGlzLl9heGlzR3JvdXAuYWRkKGF4aXNCdWlsZGVyLmdldEdyb3VwKCkpO1xuICAgIHRoaXMuX3JlZnJlc2hCcnVzaENvbnRyb2xsZXIoYnVpbGRlck9wdCwgYXJlYVNlbGVjdFN0eWxlLCBheGlzTW9kZWwsIGNvb3JkU3lzTW9kZWwsIGFyZWFXaWR0aCwgYXBpKTtcbiAgICBncmFwaGljLmdyb3VwVHJhbnNpdGlvbihvbGRBeGlzR3JvdXAsIHRoaXMuX2F4aXNHcm91cCwgYXhpc01vZGVsKTtcbiAgfTtcbiAgLy8gLyoqXG4gIC8vICAqIEBvdmVycmlkZVxuICAvLyAgKi9cbiAgLy8gdXBkYXRlVmlzdWFsKGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gIC8vICAgICB0aGlzLl9icnVzaENvbnRyb2xsZXIgJiYgdGhpcy5fYnJ1c2hDb250cm9sbGVyXG4gIC8vICAgICAgICAgLnVwZGF0ZUNvdmVycyhnZXRDb3ZlckluZm9MaXN0KGF4aXNNb2RlbCkpO1xuICAvLyB9XG4gIFBhcmFsbGVsQXhpc1ZpZXcucHJvdG90eXBlLl9yZWZyZXNoQnJ1c2hDb250cm9sbGVyID0gZnVuY3Rpb24gKGJ1aWxkZXJPcHQsIGFyZWFTZWxlY3RTdHlsZSwgYXhpc01vZGVsLCBjb29yZFN5c01vZGVsLCBhcmVhV2lkdGgsIGFwaSkge1xuICAgIC8vIEFmdGVyIGZpbHRlcmluZywgYXhpcyBtYXkgY2hhbmdlLCBzZWxlY3QgYXJlYSBuZWVkcyB0byBiZSB1cGRhdGUuXG4gICAgdmFyIGV4dGVudCA9IGF4aXNNb2RlbC5heGlzLmdldEV4dGVudCgpO1xuICAgIHZhciBleHRlbnRMZW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgdmFyIGV4dHJhID0gTWF0aC5taW4oMzAsIE1hdGguYWJzKGV4dGVudExlbikgKiAwLjEpOyAvLyBBcmJpdHJhcnkgdmFsdWUuXG4gICAgLy8gd2lkdGgvaGVpZ2h0IG1pZ2h0IGJlIG5lZ2F0aXZlLCB3aGljaCB3aWxsIGJlXG4gICAgLy8gbm9ybWFsaXplZCBpbiBCb3VuZGluZ1JlY3QuXG4gICAgdmFyIHJlY3QgPSBncmFwaGljLkJvdW5kaW5nUmVjdC5jcmVhdGUoe1xuICAgICAgeDogZXh0ZW50WzBdLFxuICAgICAgeTogLWFyZWFXaWR0aCAvIDIsXG4gICAgICB3aWR0aDogZXh0ZW50TGVuLFxuICAgICAgaGVpZ2h0OiBhcmVhV2lkdGhcbiAgICB9KTtcbiAgICByZWN0LnggLT0gZXh0cmE7XG4gICAgcmVjdC53aWR0aCArPSAyICogZXh0cmE7XG4gICAgdGhpcy5fYnJ1c2hDb250cm9sbGVyLm1vdW50KHtcbiAgICAgIGVuYWJsZUdsb2JhbFBhbjogdHJ1ZSxcbiAgICAgIHJvdGF0aW9uOiBidWlsZGVyT3B0LnJvdGF0aW9uLFxuICAgICAgeDogYnVpbGRlck9wdC5wb3NpdGlvblswXSxcbiAgICAgIHk6IGJ1aWxkZXJPcHQucG9zaXRpb25bMV1cbiAgICB9KS5zZXRQYW5lbHMoW3tcbiAgICAgIHBhbmVsSWQ6ICdwbCcsXG4gICAgICBjbGlwUGF0aDogYnJ1c2hIZWxwZXIubWFrZVJlY3RQYW5lbENsaXBQYXRoKHJlY3QpLFxuICAgICAgaXNUYXJnZXRCeUN1cnNvcjogYnJ1c2hIZWxwZXIubWFrZVJlY3RJc1RhcmdldEJ5Q3Vyc29yKHJlY3QsIGFwaSwgY29vcmRTeXNNb2RlbCksXG4gICAgICBnZXRMaW5lYXJCcnVzaE90aGVyRXh0ZW50OiBicnVzaEhlbHBlci5tYWtlTGluZWFyQnJ1c2hPdGhlckV4dGVudChyZWN0LCAwKVxuICAgIH1dKS5lbmFibGVCcnVzaCh7XG4gICAgICBicnVzaFR5cGU6ICdsaW5lWCcsXG4gICAgICBicnVzaFN0eWxlOiBhcmVhU2VsZWN0U3R5bGUsXG4gICAgICByZW1vdmVPbkNsaWNrOiB0cnVlXG4gICAgfSkudXBkYXRlQ292ZXJzKGdldENvdmVySW5mb0xpc3QoYXhpc01vZGVsKSk7XG4gIH07XG4gIFBhcmFsbGVsQXhpc1ZpZXcucHJvdG90eXBlLl9vbkJydXNoID0gZnVuY3Rpb24gKGV2ZW50UGFyYW0pIHtcbiAgICB2YXIgY292ZXJJbmZvTGlzdCA9IGV2ZW50UGFyYW0uYXJlYXM7XG4gICAgLy8gRG8gbm90IGNhY2hlIHRoZXNlIG9iamVjdCwgYmVjYXVzZSB0aGUgbWV5IGJlIGNoYW5nZWQuXG4gICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuYXhpc01vZGVsO1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIGludGVydmFscyA9IHpyVXRpbC5tYXAoY292ZXJJbmZvTGlzdCwgZnVuY3Rpb24gKGNvdmVySW5mbykge1xuICAgICAgcmV0dXJuIFtheGlzLmNvb3JkVG9EYXRhKGNvdmVySW5mby5yYW5nZVswXSwgdHJ1ZSksIGF4aXMuY29vcmRUb0RhdGEoY292ZXJJbmZvLnJhbmdlWzFdLCB0cnVlKV07XG4gICAgfSk7XG4gICAgLy8gSWYgcmVhbHRpbWUgaXMgdHJ1ZSwgYWN0aW9uIGlzIG5vdCBkaXNwYXRjaGVkIG9uIGRyYWcgZW5kLCBiZWNhdXNlXG4gICAgLy8gdGhlIGRyYWcgZW5kIGVtaXRzIHRoZSBzYW1lIHBhcmFtcyB3aXRoIHRoZSBsYXN0IGRyYWcgbW92ZSBldmVudCxcbiAgICAvLyBhbmQgbWF5IGhhdmUgc29tZSBkZWxheSB3aGVuIHVzaW5nIHRvdWNoIHBhZC5cbiAgICBpZiAoIWF4aXNNb2RlbC5vcHRpb24ucmVhbHRpbWUgPT09IGV2ZW50UGFyYW0uaXNFbmQgfHwgZXZlbnRQYXJhbS5yZW1vdmVPbkNsaWNrKSB7XG4gICAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ2F4aXNBcmVhU2VsZWN0JyxcbiAgICAgICAgcGFyYWxsZWxBeGlzSWQ6IGF4aXNNb2RlbC5pZCxcbiAgICAgICAgaW50ZXJ2YWxzOiBpbnRlcnZhbHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgUGFyYWxsZWxBeGlzVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9icnVzaENvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICB9O1xuICBQYXJhbGxlbEF4aXNWaWV3LnR5cGUgPSAncGFyYWxsZWxBeGlzJztcbiAgcmV0dXJuIFBhcmFsbGVsQXhpc1ZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuZnVuY3Rpb24gZnJvbUF4aXNBcmVhU2VsZWN0KGF4aXNNb2RlbCwgZWNNb2RlbCwgcGF5bG9hZCkge1xuICByZXR1cm4gcGF5bG9hZCAmJiBwYXlsb2FkLnR5cGUgPT09ICdheGlzQXJlYVNlbGVjdCcgJiYgZWNNb2RlbC5maW5kQ29tcG9uZW50cyh7XG4gICAgbWFpblR5cGU6ICdwYXJhbGxlbEF4aXMnLFxuICAgIHF1ZXJ5OiBwYXlsb2FkXG4gIH0pWzBdID09PSBheGlzTW9kZWw7XG59XG5mdW5jdGlvbiBnZXRDb3ZlckluZm9MaXN0KGF4aXNNb2RlbCkge1xuICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICByZXR1cm4genJVdGlsLm1hcChheGlzTW9kZWwuYWN0aXZlSW50ZXJ2YWxzLCBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnJ1c2hUeXBlOiAnbGluZVgnLFxuICAgICAgcGFuZWxJZDogJ3BsJyxcbiAgICAgIHJhbmdlOiBbYXhpcy5kYXRhVG9Db29yZChpbnRlcnZhbFswXSwgdHJ1ZSksIGF4aXMuZGF0YVRvQ29vcmQoaW50ZXJ2YWxbMV0sIHRydWUpXVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q29vcmRTeXNNb2RlbChheGlzTW9kZWwsIGVjTW9kZWwpIHtcbiAgcmV0dXJuIGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdwYXJhbGxlbCcsIGF4aXNNb2RlbC5nZXQoJ3BhcmFsbGVsSW5kZXgnKSk7XG59XG5leHBvcnQgZGVmYXVsdCBQYXJhbGxlbEF4aXNWaWV3OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///60755\n")},67688:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98026);\n/* harmony import */ var _AxisBuilder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89598);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43870);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(43199);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82861);\n/* harmony import */ var _coord_single_singleAxisHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85508);\n/* harmony import */ var _AxisView_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(22480);\n/* harmony import */ var _axisSplitHelper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(35369);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine'];\nvar SingleAxisView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(SingleAxisView, _super);\n  function SingleAxisView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = SingleAxisView.type;\n    _this.axisPointerClass = 'SingleAxisPointer';\n    return _this;\n  }\n  SingleAxisView.prototype.render = function (axisModel, ecModel, api, payload) {\n    var group = this.group;\n    group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A();\n    var layout = _coord_single_singleAxisHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .layout */ .Z(axisModel);\n    var axisBuilder = new _AxisBuilder_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A(axisModel, layout);\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n    group.add(this._axisGroup);\n    group.add(axisBuilder.getGroup());\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get([name, 'show'])) {\n        axisElementBuilders[name](this, this.group, this._axisGroup, axisModel);\n      }\n    }, this);\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    _super.prototype.render.call(this, axisModel, ecModel, api, payload);\n  };\n  SingleAxisView.prototype.remove = function () {\n    (0,_axisSplitHelper_js__WEBPACK_IMPORTED_MODULE_6__/* .rectCoordAxisHandleRemove */ .V)(this);\n  };\n  SingleAxisView.type = 'singleAxis';\n  return SingleAxisView;\n}(_AxisView_js__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .A);\nvar axisElementBuilders = {\n  splitLine: function (axisView, group, axisGroup, axisModel) {\n    var axis = axisModel.axis;\n    if (axis.scale.isBlank()) {\n      return;\n    }\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    lineColors = lineColors instanceof Array ? lineColors : [lineColors];\n    var lineWidth = lineStyleModel.get('width');\n    var gridRect = axisModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var splitLines = [];\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitLineModel\n    });\n    var p1 = [];\n    var p2 = [];\n    for (var i = 0; i < ticksCoords.length; ++i) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n      var line = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .A({\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        silent: true\n      });\n      _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__.subPixelOptimizeLine(line.shape, lineWidth);\n      var colorIndex = lineCount++ % lineColors.length;\n      splitLines[colorIndex] = splitLines[colorIndex] || [];\n      splitLines[colorIndex].push(line);\n    }\n    var lineStyle = lineStyleModel.getLineStyle(['color']);\n    for (var i = 0; i < splitLines.length; ++i) {\n      group.add(_util_graphic_js__WEBPACK_IMPORTED_MODULE_5__.mergePath(splitLines[i], {\n        style: zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.defaults({\n          stroke: lineColors[i % lineColors.length]\n        }, lineStyle),\n        silent: true\n      }));\n    }\n  },\n  splitArea: function (axisView, group, axisGroup, axisModel) {\n    (0,_axisSplitHelper_js__WEBPACK_IMPORTED_MODULE_6__/* .rectCoordAxisBuildSplitArea */ .Y)(axisView, axisGroup, axisModel, axisModel);\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SingleAxisView);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc2ODguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYXhpcy9TaW5nbGVBeGlzVmlldy5qcz83YmM2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBBeGlzQnVpbGRlciBmcm9tICcuL0F4aXNCdWlsZGVyLmpzJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCAqIGFzIHNpbmdsZUF4aXNIZWxwZXIgZnJvbSAnLi4vLi4vY29vcmQvc2luZ2xlL3NpbmdsZUF4aXNIZWxwZXIuanMnO1xuaW1wb3J0IEF4aXNWaWV3IGZyb20gJy4vQXhpc1ZpZXcuanMnO1xuaW1wb3J0IHsgcmVjdENvb3JkQXhpc0J1aWxkU3BsaXRBcmVhLCByZWN0Q29vcmRBeGlzSGFuZGxlUmVtb3ZlIH0gZnJvbSAnLi9heGlzU3BsaXRIZWxwZXIuanMnO1xudmFyIGF4aXNCdWlsZGVyQXR0cnMgPSBbJ2F4aXNMaW5lJywgJ2F4aXNUaWNrTGFiZWwnLCAnYXhpc05hbWUnXTtcbnZhciBzZWxmQnVpbGRlckF0dHJzID0gWydzcGxpdEFyZWEnLCAnc3BsaXRMaW5lJ107XG52YXIgU2luZ2xlQXhpc1ZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2luZ2xlQXhpc1ZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFNpbmdsZUF4aXNWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBTaW5nbGVBeGlzVmlldy50eXBlO1xuICAgIF90aGlzLmF4aXNQb2ludGVyQ2xhc3MgPSAnU2luZ2xlQXhpc1BvaW50ZXInO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBTaW5nbGVBeGlzVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgICB2YXIgb2xkQXhpc0dyb3VwID0gdGhpcy5fYXhpc0dyb3VwO1xuICAgIHRoaXMuX2F4aXNHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgdmFyIGxheW91dCA9IHNpbmdsZUF4aXNIZWxwZXIubGF5b3V0KGF4aXNNb2RlbCk7XG4gICAgdmFyIGF4aXNCdWlsZGVyID0gbmV3IEF4aXNCdWlsZGVyKGF4aXNNb2RlbCwgbGF5b3V0KTtcbiAgICB6clV0aWwuZWFjaChheGlzQnVpbGRlckF0dHJzLCBheGlzQnVpbGRlci5hZGQsIGF4aXNCdWlsZGVyKTtcbiAgICBncm91cC5hZGQodGhpcy5fYXhpc0dyb3VwKTtcbiAgICBncm91cC5hZGQoYXhpc0J1aWxkZXIuZ2V0R3JvdXAoKSk7XG4gICAgenJVdGlsLmVhY2goc2VsZkJ1aWxkZXJBdHRycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChheGlzTW9kZWwuZ2V0KFtuYW1lLCAnc2hvdyddKSkge1xuICAgICAgICBheGlzRWxlbWVudEJ1aWxkZXJzW25hbWVdKHRoaXMsIHRoaXMuZ3JvdXAsIHRoaXMuX2F4aXNHcm91cCwgYXhpc01vZGVsKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICBncmFwaGljLmdyb3VwVHJhbnNpdGlvbihvbGRBeGlzR3JvdXAsIHRoaXMuX2F4aXNHcm91cCwgYXhpc01vZGVsKTtcbiAgICBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMsIGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgfTtcbiAgU2luZ2xlQXhpc1ZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZWN0Q29vcmRBeGlzSGFuZGxlUmVtb3ZlKHRoaXMpO1xuICB9O1xuICBTaW5nbGVBeGlzVmlldy50eXBlID0gJ3NpbmdsZUF4aXMnO1xuICByZXR1cm4gU2luZ2xlQXhpc1ZpZXc7XG59KEF4aXNWaWV3KTtcbnZhciBheGlzRWxlbWVudEJ1aWxkZXJzID0ge1xuICBzcGxpdExpbmU6IGZ1bmN0aW9uIChheGlzVmlldywgZ3JvdXAsIGF4aXNHcm91cCwgYXhpc01vZGVsKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICBpZiAoYXhpcy5zY2FsZS5pc0JsYW5rKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNwbGl0TGluZU1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdzcGxpdExpbmUnKTtcbiAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSBzcGxpdExpbmVNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJyk7XG4gICAgdmFyIGxpbmVDb2xvcnMgPSBsaW5lU3R5bGVNb2RlbC5nZXQoJ2NvbG9yJyk7XG4gICAgbGluZUNvbG9ycyA9IGxpbmVDb2xvcnMgaW5zdGFuY2VvZiBBcnJheSA/IGxpbmVDb2xvcnMgOiBbbGluZUNvbG9yc107XG4gICAgdmFyIGxpbmVXaWR0aCA9IGxpbmVTdHlsZU1vZGVsLmdldCgnd2lkdGgnKTtcbiAgICB2YXIgZ3JpZFJlY3QgPSBheGlzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG4gICAgdmFyIGlzSG9yaXpvbnRhbCA9IGF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgdmFyIHNwbGl0TGluZXMgPSBbXTtcbiAgICB2YXIgbGluZUNvdW50ID0gMDtcbiAgICB2YXIgdGlja3NDb29yZHMgPSBheGlzLmdldFRpY2tzQ29vcmRzKHtcbiAgICAgIHRpY2tNb2RlbDogc3BsaXRMaW5lTW9kZWxcbiAgICB9KTtcbiAgICB2YXIgcDEgPSBbXTtcbiAgICB2YXIgcDIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzQ29vcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdGlja0Nvb3JkID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzW2ldLmNvb3JkKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgcDFbMF0gPSB0aWNrQ29vcmQ7XG4gICAgICAgIHAxWzFdID0gZ3JpZFJlY3QueTtcbiAgICAgICAgcDJbMF0gPSB0aWNrQ29vcmQ7XG4gICAgICAgIHAyWzFdID0gZ3JpZFJlY3QueSArIGdyaWRSZWN0LmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAxWzBdID0gZ3JpZFJlY3QueDtcbiAgICAgICAgcDFbMV0gPSB0aWNrQ29vcmQ7XG4gICAgICAgIHAyWzBdID0gZ3JpZFJlY3QueCArIGdyaWRSZWN0LndpZHRoO1xuICAgICAgICBwMlsxXSA9IHRpY2tDb29yZDtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gbmV3IGdyYXBoaWMuTGluZSh7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgeDE6IHAxWzBdLFxuICAgICAgICAgIHkxOiBwMVsxXSxcbiAgICAgICAgICB4MjogcDJbMF0sXG4gICAgICAgICAgeTI6IHAyWzFdXG4gICAgICAgIH0sXG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lKGxpbmUuc2hhcGUsIGxpbmVXaWR0aCk7XG4gICAgICB2YXIgY29sb3JJbmRleCA9IGxpbmVDb3VudCsrICUgbGluZUNvbG9ycy5sZW5ndGg7XG4gICAgICBzcGxpdExpbmVzW2NvbG9ySW5kZXhdID0gc3BsaXRMaW5lc1tjb2xvckluZGV4XSB8fCBbXTtcbiAgICAgIHNwbGl0TGluZXNbY29sb3JJbmRleF0ucHVzaChsaW5lKTtcbiAgICB9XG4gICAgdmFyIGxpbmVTdHlsZSA9IGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZShbJ2NvbG9yJ10pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXRMaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgZ3JvdXAuYWRkKGdyYXBoaWMubWVyZ2VQYXRoKHNwbGl0TGluZXNbaV0sIHtcbiAgICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgc3Ryb2tlOiBsaW5lQ29sb3JzW2kgJSBsaW5lQ29sb3JzLmxlbmd0aF1cbiAgICAgICAgfSwgbGluZVN0eWxlKSxcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KSk7XG4gICAgfVxuICB9LFxuICBzcGxpdEFyZWE6IGZ1bmN0aW9uIChheGlzVmlldywgZ3JvdXAsIGF4aXNHcm91cCwgYXhpc01vZGVsKSB7XG4gICAgcmVjdENvb3JkQXhpc0J1aWxkU3BsaXRBcmVhKGF4aXNWaWV3LCBheGlzR3JvdXAsIGF4aXNNb2RlbCwgYXhpc01vZGVsKTtcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IFNpbmdsZUF4aXNWaWV3OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///67688\n")},68520:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   o: () => (/* binding */ installParallelActions)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar actionInfo = {\n  type: 'axisAreaSelect',\n  event: 'axisAreaSelected'\n  // update: 'updateVisual'\n};\nfunction installParallelActions(registers) {\n  registers.registerAction(actionInfo, function (payload, ecModel) {\n    ecModel.eachComponent({\n      mainType: 'parallelAxis',\n      query: payload\n    }, function (parallelAxisModel) {\n      parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);\n    });\n  });\n  /**\r\n   * @payload\r\n   */\n  registers.registerAction('parallelAxisExpand', function (payload, ecModel) {\n    ecModel.eachComponent({\n      mainType: 'parallel',\n      query: payload\n    }, function (parallelModel) {\n      parallelModel.setAxisExpand(payload);\n    });\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg1MjAuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzL3BhcmFsbGVsQXhpc0FjdGlvbi5qcz9iZDZhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xudmFyIGFjdGlvbkluZm8gPSB7XG4gIHR5cGU6ICdheGlzQXJlYVNlbGVjdCcsXG4gIGV2ZW50OiAnYXhpc0FyZWFTZWxlY3RlZCdcbiAgLy8gdXBkYXRlOiAndXBkYXRlVmlzdWFsJ1xufTtcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsUGFyYWxsZWxBY3Rpb25zKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oYWN0aW9uSW5mbywgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6ICdwYXJhbGxlbEF4aXMnLFxuICAgICAgcXVlcnk6IHBheWxvYWRcbiAgICB9LCBmdW5jdGlvbiAocGFyYWxsZWxBeGlzTW9kZWwpIHtcbiAgICAgIHBhcmFsbGVsQXhpc01vZGVsLmF4aXMubW9kZWwuc2V0QWN0aXZlSW50ZXJ2YWxzKHBheWxvYWQuaW50ZXJ2YWxzKTtcbiAgICB9KTtcbiAgfSk7XG4gIC8qKlxyXG4gICAqIEBwYXlsb2FkXHJcbiAgICovXG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbigncGFyYWxsZWxBeGlzRXhwYW5kJywgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6ICdwYXJhbGxlbCcsXG4gICAgICBxdWVyeTogcGF5bG9hZFxuICAgIH0sIGZ1bmN0aW9uIChwYXJhbGxlbE1vZGVsKSB7XG4gICAgICBwYXJhbGxlbE1vZGVsLnNldEF4aXNFeHBhbmQocGF5bG9hZCk7XG4gICAgfSk7XG4gIH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///68520\n")},70816:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/aria.js\nvar aria = __webpack_require__(20546);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n;// ./node_modules/echarts/lib/component/aria/preprocessor.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction ariaPreprocessor(option) {\n  if (!option || !option.aria) {\n    return;\n  }\n  var aria = option.aria;\n  // aria.show is deprecated and should use aria.enabled instead\n  if (aria.show != null) {\n    aria.enabled = aria.show;\n  }\n  aria.label = aria.label || {};\n  // move description, general, series, data to be under aria.label\n  util.each([\'description\', \'general\', \'series\', \'data\'], function (name) {\n    if (aria[name] != null) {\n      aria.label[name] = aria[name];\n    }\n  });\n}\n;// ./node_modules/echarts/lib/component/aria/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction install(registers) {\n  registers.registerPreprocessor(ariaPreprocessor);\n  registers.registerVisual(registers.PRIORITY.VISUAL.ARIA, aria/* default */.A);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA4MTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2FyaWEvcHJlcHJvY2Vzc29yLmpzPzc0MTkiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9hcmlhL2luc3RhbGwuanM/M2MxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXJpYVByZXByb2Nlc3NvcihvcHRpb24pIHtcbiAgaWYgKCFvcHRpb24gfHwgIW9wdGlvbi5hcmlhKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBhcmlhID0gb3B0aW9uLmFyaWE7XG4gIC8vIGFyaWEuc2hvdyBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgdXNlIGFyaWEuZW5hYmxlZCBpbnN0ZWFkXG4gIGlmIChhcmlhLnNob3cgIT0gbnVsbCkge1xuICAgIGFyaWEuZW5hYmxlZCA9IGFyaWEuc2hvdztcbiAgfVxuICBhcmlhLmxhYmVsID0gYXJpYS5sYWJlbCB8fCB7fTtcbiAgLy8gbW92ZSBkZXNjcmlwdGlvbiwgZ2VuZXJhbCwgc2VyaWVzLCBkYXRhIHRvIGJlIHVuZGVyIGFyaWEubGFiZWxcbiAgenJVdGlsLmVhY2goWydkZXNjcmlwdGlvbicsICdnZW5lcmFsJywgJ3NlcmllcycsICdkYXRhJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKGFyaWFbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgYXJpYS5sYWJlbFtuYW1lXSA9IGFyaWFbbmFtZV07XG4gICAgfVxuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBhcmlhVmlzdWFsIGZyb20gJy4uLy4uL3Zpc3VhbC9hcmlhLmpzJztcbmltcG9ydCBhcmlhUHJlcHJvY2Vzc29yIGZyb20gJy4vcHJlcHJvY2Vzc29yLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJQcmVwcm9jZXNzb3IoYXJpYVByZXByb2Nlc3Nvcik7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclZpc3VhbChyZWdpc3RlcnMuUFJJT1JJVFkuVklTVUFMLkFSSUEsIGFyaWFWaXN1YWwpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///70816\n')},76081:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _BaseAxisPointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(53226);\n/* harmony import */ var _viewHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3686);\n/* harmony import */ var _coord_single_singleAxisHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85508);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar XY = ['x', 'y'];\nvar WH = ['width', 'height'];\nvar SingleAxisPointer = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(SingleAxisPointer, _super);\n  function SingleAxisPointer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * @override\r\n   */\n  SingleAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {\n    var axis = axisModel.axis;\n    var coordSys = axis.coordinateSystem;\n    var otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis));\n    var pixelValue = coordSys.dataToPoint(value)[0];\n    var axisPointerType = axisPointerModel.get('type');\n    if (axisPointerType && axisPointerType !== 'none') {\n      var elStyle = _viewHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .buildElStyle */ .bY(axisPointerModel);\n      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);\n      pointerOption.style = elStyle;\n      elOption.graphicKey = pointerOption.type;\n      elOption.pointer = pointerOption;\n    }\n    var layoutInfo = _coord_single_singleAxisHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .layout */ .Z(axisModel);\n    _viewHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .buildCartesianSingleLabelElOption */ .DA(\n    // @ts-ignore\n    value, elOption, layoutInfo, axisModel, axisPointerModel, api);\n  };\n  /**\r\n   * @override\r\n   */\n  SingleAxisPointer.prototype.getHandleTransform = function (value, axisModel, axisPointerModel) {\n    var layoutInfo = _coord_single_singleAxisHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .layout */ .Z(axisModel, {\n      labelInside: false\n    });\n    // @ts-ignore\n    layoutInfo.labelMargin = axisPointerModel.get(['handle', 'margin']);\n    var position = _viewHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .getTransformedPosition */ .Tc(axisModel.axis, value, layoutInfo);\n    return {\n      x: position[0],\n      y: position[1],\n      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n    };\n  };\n  /**\r\n   * @override\r\n   */\n  SingleAxisPointer.prototype.updateHandleTransform = function (transform, delta, axisModel, axisPointerModel) {\n    var axis = axisModel.axis;\n    var coordSys = axis.coordinateSystem;\n    var dimIndex = getPointDimIndex(axis);\n    var axisExtent = getGlobalExtent(coordSys, dimIndex);\n    var currPosition = [transform.x, transform.y];\n    currPosition[dimIndex] += delta[dimIndex];\n    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n    var otherExtent = getGlobalExtent(coordSys, 1 - dimIndex);\n    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n    var cursorPoint = [cursorOtherValue, cursorOtherValue];\n    cursorPoint[dimIndex] = currPosition[dimIndex];\n    return {\n      x: currPosition[0],\n      y: currPosition[1],\n      rotation: transform.rotation,\n      cursorPoint: cursorPoint,\n      tooltipOption: {\n        verticalAlign: 'middle'\n      }\n    };\n  };\n  return SingleAxisPointer;\n}(_BaseAxisPointer_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A);\nvar pointerShapeBuilder = {\n  line: function (axis, pixelValue, otherExtent) {\n    var targetShape = _viewHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .makeLineShape */ .MU([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis));\n    return {\n      type: 'Line',\n      subPixelOptimize: true,\n      shape: targetShape\n    };\n  },\n  shadow: function (axis, pixelValue, otherExtent) {\n    var bandWidth = axis.getBandWidth();\n    var span = otherExtent[1] - otherExtent[0];\n    return {\n      type: 'Rect',\n      shape: _viewHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .makeRectShape */ .cU([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis))\n    };\n  }\n};\nfunction getPointDimIndex(axis) {\n  return axis.isHorizontal() ? 0 : 1;\n}\nfunction getGlobalExtent(coordSys, dimIndex) {\n  var rect = coordSys.getRect();\n  return [rect[XY[dimIndex]], rect[XY[dimIndex]] + rect[WH[dimIndex]]];\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SingleAxisPointer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYwODEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9TaW5nbGVBeGlzUG9pbnRlci5qcz9hNTBkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQmFzZUF4aXNQb2ludGVyIGZyb20gJy4vQmFzZUF4aXNQb2ludGVyLmpzJztcbmltcG9ydCAqIGFzIHZpZXdIZWxwZXIgZnJvbSAnLi92aWV3SGVscGVyLmpzJztcbmltcG9ydCAqIGFzIHNpbmdsZUF4aXNIZWxwZXIgZnJvbSAnLi4vLi4vY29vcmQvc2luZ2xlL3NpbmdsZUF4aXNIZWxwZXIuanMnO1xudmFyIFhZID0gWyd4JywgJ3knXTtcbnZhciBXSCA9IFsnd2lkdGgnLCAnaGVpZ2h0J107XG52YXIgU2luZ2xlQXhpc1BvaW50ZXIgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2luZ2xlQXhpc1BvaW50ZXIsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFNpbmdsZUF4aXNQb2ludGVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgU2luZ2xlQXhpc1BvaW50ZXIucHJvdG90eXBlLm1ha2VFbE9wdGlvbiA9IGZ1bmN0aW9uIChlbE9wdGlvbiwgdmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgY29vcmRTeXMgPSBheGlzLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIG90aGVyRXh0ZW50ID0gZ2V0R2xvYmFsRXh0ZW50KGNvb3JkU3lzLCAxIC0gZ2V0UG9pbnREaW1JbmRleChheGlzKSk7XG4gICAgdmFyIHBpeGVsVmFsdWUgPSBjb29yZFN5cy5kYXRhVG9Qb2ludCh2YWx1ZSlbMF07XG4gICAgdmFyIGF4aXNQb2ludGVyVHlwZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJyk7XG4gICAgaWYgKGF4aXNQb2ludGVyVHlwZSAmJiBheGlzUG9pbnRlclR5cGUgIT09ICdub25lJykge1xuICAgICAgdmFyIGVsU3R5bGUgPSB2aWV3SGVscGVyLmJ1aWxkRWxTdHlsZShheGlzUG9pbnRlck1vZGVsKTtcbiAgICAgIHZhciBwb2ludGVyT3B0aW9uID0gcG9pbnRlclNoYXBlQnVpbGRlcltheGlzUG9pbnRlclR5cGVdKGF4aXMsIHBpeGVsVmFsdWUsIG90aGVyRXh0ZW50KTtcbiAgICAgIHBvaW50ZXJPcHRpb24uc3R5bGUgPSBlbFN0eWxlO1xuICAgICAgZWxPcHRpb24uZ3JhcGhpY0tleSA9IHBvaW50ZXJPcHRpb24udHlwZTtcbiAgICAgIGVsT3B0aW9uLnBvaW50ZXIgPSBwb2ludGVyT3B0aW9uO1xuICAgIH1cbiAgICB2YXIgbGF5b3V0SW5mbyA9IHNpbmdsZUF4aXNIZWxwZXIubGF5b3V0KGF4aXNNb2RlbCk7XG4gICAgdmlld0hlbHBlci5idWlsZENhcnRlc2lhblNpbmdsZUxhYmVsRWxPcHRpb24oXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhbHVlLCBlbE9wdGlvbiwgbGF5b3V0SW5mbywgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGkpO1xuICB9O1xuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgU2luZ2xlQXhpc1BvaW50ZXIucHJvdG90eXBlLmdldEhhbmRsZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsKSB7XG4gICAgdmFyIGxheW91dEluZm8gPSBzaW5nbGVBeGlzSGVscGVyLmxheW91dChheGlzTW9kZWwsIHtcbiAgICAgIGxhYmVsSW5zaWRlOiBmYWxzZVxuICAgIH0pO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBsYXlvdXRJbmZvLmxhYmVsTWFyZ2luID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoWydoYW5kbGUnLCAnbWFyZ2luJ10pO1xuICAgIHZhciBwb3NpdGlvbiA9IHZpZXdIZWxwZXIuZ2V0VHJhbnNmb3JtZWRQb3NpdGlvbihheGlzTW9kZWwuYXhpcywgdmFsdWUsIGxheW91dEluZm8pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwb3NpdGlvblswXSxcbiAgICAgIHk6IHBvc2l0aW9uWzFdLFxuICAgICAgcm90YXRpb246IGxheW91dEluZm8ucm90YXRpb24gKyAobGF5b3V0SW5mby5sYWJlbERpcmVjdGlvbiA8IDAgPyBNYXRoLlBJIDogMClcbiAgICB9O1xuICB9O1xuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgU2luZ2xlQXhpc1BvaW50ZXIucHJvdG90eXBlLnVwZGF0ZUhhbmRsZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIGRlbHRhLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgIHZhciBjb29yZFN5cyA9IGF4aXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgZGltSW5kZXggPSBnZXRQb2ludERpbUluZGV4KGF4aXMpO1xuICAgIHZhciBheGlzRXh0ZW50ID0gZ2V0R2xvYmFsRXh0ZW50KGNvb3JkU3lzLCBkaW1JbmRleCk7XG4gICAgdmFyIGN1cnJQb3NpdGlvbiA9IFt0cmFuc2Zvcm0ueCwgdHJhbnNmb3JtLnldO1xuICAgIGN1cnJQb3NpdGlvbltkaW1JbmRleF0gKz0gZGVsdGFbZGltSW5kZXhdO1xuICAgIGN1cnJQb3NpdGlvbltkaW1JbmRleF0gPSBNYXRoLm1pbihheGlzRXh0ZW50WzFdLCBjdXJyUG9zaXRpb25bZGltSW5kZXhdKTtcbiAgICBjdXJyUG9zaXRpb25bZGltSW5kZXhdID0gTWF0aC5tYXgoYXhpc0V4dGVudFswXSwgY3VyclBvc2l0aW9uW2RpbUluZGV4XSk7XG4gICAgdmFyIG90aGVyRXh0ZW50ID0gZ2V0R2xvYmFsRXh0ZW50KGNvb3JkU3lzLCAxIC0gZGltSW5kZXgpO1xuICAgIHZhciBjdXJzb3JPdGhlclZhbHVlID0gKG90aGVyRXh0ZW50WzFdICsgb3RoZXJFeHRlbnRbMF0pIC8gMjtcbiAgICB2YXIgY3Vyc29yUG9pbnQgPSBbY3Vyc29yT3RoZXJWYWx1ZSwgY3Vyc29yT3RoZXJWYWx1ZV07XG4gICAgY3Vyc29yUG9pbnRbZGltSW5kZXhdID0gY3VyclBvc2l0aW9uW2RpbUluZGV4XTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogY3VyclBvc2l0aW9uWzBdLFxuICAgICAgeTogY3VyclBvc2l0aW9uWzFdLFxuICAgICAgcm90YXRpb246IHRyYW5zZm9ybS5yb3RhdGlvbixcbiAgICAgIGN1cnNvclBvaW50OiBjdXJzb3JQb2ludCxcbiAgICAgIHRvb2x0aXBPcHRpb246IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gU2luZ2xlQXhpc1BvaW50ZXI7XG59KEJhc2VBeGlzUG9pbnRlcik7XG52YXIgcG9pbnRlclNoYXBlQnVpbGRlciA9IHtcbiAgbGluZTogZnVuY3Rpb24gKGF4aXMsIHBpeGVsVmFsdWUsIG90aGVyRXh0ZW50KSB7XG4gICAgdmFyIHRhcmdldFNoYXBlID0gdmlld0hlbHBlci5tYWtlTGluZVNoYXBlKFtwaXhlbFZhbHVlLCBvdGhlckV4dGVudFswXV0sIFtwaXhlbFZhbHVlLCBvdGhlckV4dGVudFsxXV0sIGdldFBvaW50RGltSW5kZXgoYXhpcykpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnTGluZScsXG4gICAgICBzdWJQaXhlbE9wdGltaXplOiB0cnVlLFxuICAgICAgc2hhcGU6IHRhcmdldFNoYXBlXG4gICAgfTtcbiAgfSxcbiAgc2hhZG93OiBmdW5jdGlvbiAoYXhpcywgcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnQpIHtcbiAgICB2YXIgYmFuZFdpZHRoID0gYXhpcy5nZXRCYW5kV2lkdGgoKTtcbiAgICB2YXIgc3BhbiA9IG90aGVyRXh0ZW50WzFdIC0gb3RoZXJFeHRlbnRbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdSZWN0JyxcbiAgICAgIHNoYXBlOiB2aWV3SGVscGVyLm1ha2VSZWN0U2hhcGUoW3BpeGVsVmFsdWUgLSBiYW5kV2lkdGggLyAyLCBvdGhlckV4dGVudFswXV0sIFtiYW5kV2lkdGgsIHNwYW5dLCBnZXRQb2ludERpbUluZGV4KGF4aXMpKVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRQb2ludERpbUluZGV4KGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMuaXNIb3Jpem9udGFsKCkgPyAwIDogMTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbEV4dGVudChjb29yZFN5cywgZGltSW5kZXgpIHtcbiAgdmFyIHJlY3QgPSBjb29yZFN5cy5nZXRSZWN0KCk7XG4gIHJldHVybiBbcmVjdFtYWVtkaW1JbmRleF1dLCByZWN0W1hZW2RpbUluZGV4XV0gKyByZWN0W1dIW2RpbUluZGV4XV1dO1xufVxuZXhwb3J0IGRlZmF1bHQgU2luZ2xlQXhpc1BvaW50ZXI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///76081\n")},89598:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43870);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82861);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(43199);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(32322);\n/* harmony import */ var _util_innerStore_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(69622);\n/* harmony import */ var _label_labelStyle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(89632);\n/* harmony import */ var _model_Model_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(43172);\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24326);\n/* harmony import */ var _util_symbol_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(62103);\n/* harmony import */ var zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(45587);\n/* harmony import */ var zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(83509);\n/* harmony import */ var _coord_axisHelper_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(99031);\n/* harmony import */ var _label_labelLayoutHelper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(77175);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\nvar PI = Math.PI;\n/**\r\n * A final axis is translated and rotated from a \"standard axis\".\r\n * So opt.position and opt.rotation is required.\r\n *\r\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\r\n * for example: (0, 0) ------------\x3e (0, 50)\r\n *\r\n * nameDirection or tickDirection or labelDirection is 1 means tick\r\n * or label is below the standard axis, whereas is -1 means above\r\n * the standard axis. labelOffset means offset between label and axis,\r\n * which is useful when 'onZero', where axisLabel is in the grid and\r\n * label in outside grid.\r\n *\r\n * Tips: like always,\r\n * positive rotation represents anticlockwise, and negative rotation\r\n * represents clockwise.\r\n * The direction of position coordinate is the same as the direction\r\n * of screen coordinate.\r\n *\r\n * Do not need to consider axis 'inverse', which is auto processed by\r\n * axis extent.\r\n */\nvar AxisBuilder = /** @class */function () {\n  function AxisBuilder(axisModel, opt) {\n    this.group = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A();\n    this.opt = opt;\n    this.axisModel = axisModel;\n    // Default value\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults)(opt, {\n      labelOffset: 0,\n      nameDirection: 1,\n      tickDirection: 1,\n      labelDirection: 1,\n      silent: true,\n      handleAutoShown: function () {\n        return true;\n      }\n    });\n    // FIXME Not use a separate text group?\n    var transformGroup = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A({\n      x: opt.position[0],\n      y: opt.position[1],\n      rotation: opt.rotation\n    });\n    // this.group.add(transformGroup);\n    // this._transformGroup = transformGroup;\n    transformGroup.updateTransform();\n    this._transformGroup = transformGroup;\n  }\n  AxisBuilder.prototype.hasBuilder = function (name) {\n    return !!builders[name];\n  };\n  AxisBuilder.prototype.add = function (name) {\n    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);\n  };\n  AxisBuilder.prototype.getGroup = function () {\n    return this.group;\n  };\n  AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n    var rotationDiff = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .remRadian */ ._7)(textRotation - axisRotation);\n    var textAlign;\n    var textVerticalAlign;\n    if ((0,_util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .isRadianAroundZero */ .dh)(rotationDiff)) {\n      // Label is parallel with axis line.\n      textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n      textAlign = 'center';\n    } else if ((0,_util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .isRadianAroundZero */ .dh)(rotationDiff - PI)) {\n      // Label is inverse parallel with axis line.\n      textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n      textAlign = 'center';\n    } else {\n      textVerticalAlign = 'middle';\n      if (rotationDiff > 0 && rotationDiff < PI) {\n        textAlign = direction > 0 ? 'right' : 'left';\n      } else {\n        textAlign = direction > 0 ? 'left' : 'right';\n      }\n    }\n    return {\n      rotation: rotationDiff,\n      textAlign: textAlign,\n      textVerticalAlign: textVerticalAlign\n    };\n  };\n  AxisBuilder.makeAxisEventDataBase = function (axisModel) {\n    var eventData = {\n      componentType: axisModel.mainType,\n      componentIndex: axisModel.componentIndex\n    };\n    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n    return eventData;\n  };\n  AxisBuilder.isLabelSilent = function (axisModel) {\n    var tooltipOpt = axisModel.get('tooltip');\n    return axisModel.get('silent')\n    // Consider mouse cursor, add these restrictions.\n    || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n  };\n  return AxisBuilder;\n}();\n;\nvar builders = {\n  axisLine: function (opt, axisModel, group, transformGroup) {\n    var shown = axisModel.get(['axisLine', 'show']);\n    if (shown === 'auto' && opt.handleAutoShown) {\n      shown = opt.handleAutoShown('axisLine');\n    }\n    if (!shown) {\n      return;\n    }\n    var extent = axisModel.axis.getExtent();\n    var matrix = transformGroup.transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n    var inverse = pt1[0] > pt2[0];\n    if (matrix) {\n      (0,zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_3__.applyTransform)(pt1, pt1, matrix);\n      (0,zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_3__.applyTransform)(pt2, pt2, matrix);\n    }\n    var lineStyle = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({\n      lineCap: 'round'\n    }, axisModel.getModel(['axisLine', 'lineStyle']).getLineStyle());\n    var line = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A({\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    });\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__.subPixelOptimizeLine(line.shape, line.style.lineWidth);\n    line.anid = 'line';\n    group.add(line);\n    var arrows = axisModel.get(['axisLine', 'symbol']);\n    if (arrows != null) {\n      var arrowSize = axisModel.get(['axisLine', 'symbolSize']);\n      if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString)(arrows)) {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n      if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString)(arrowSize) || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(arrowSize)) {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n      var arrowOffset = (0,_util_symbol_js__WEBPACK_IMPORTED_MODULE_6__/* .normalizeSymbolOffset */ .hV)(axisModel.get(['axisLine', 'symbolOffset']) || 0, arrowSize);\n      var symbolWidth_1 = arrowSize[0];\n      var symbolHeight_1 = arrowSize[1];\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = (0,_util_symbol_js__WEBPACK_IMPORTED_MODULE_6__/* .createSymbol */ .v5)(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true);\n          // Calculate arrow position with offset\n          var r = point.r + point.offset;\n          var pt = inverse ? pt2 : pt1;\n          symbol.attr({\n            rotation: point.rotate,\n            x: pt[0] + r * Math.cos(opt.rotation),\n            y: pt[1] - r * Math.sin(opt.rotation),\n            silent: true,\n            z2: 11\n          });\n          group.add(symbol);\n        }\n      });\n    }\n  },\n  axisTickLabel: function (opt, axisModel, group, transformGroup) {\n    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);\n    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);\n    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection);\n    // This bit fixes the label overlap issue for the time chart.\n    // See https://github.com/apache/echarts/issues/14266 for more.\n    if (axisModel.get(['axisLabel', 'hideOverlap'])) {\n      var labelList = (0,_label_labelLayoutHelper_js__WEBPACK_IMPORTED_MODULE_7__/* .prepareLayoutList */ .os)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map)(labelEls, function (label) {\n        return {\n          label: label,\n          priority: label.z2,\n          defaultAttr: {\n            ignore: label.ignore\n          }\n        };\n      }));\n      (0,_label_labelLayoutHelper_js__WEBPACK_IMPORTED_MODULE_7__/* .hideOverlap */ .If)(labelList);\n    }\n  },\n  axisName: function (opt, axisModel, group, transformGroup) {\n    var name = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve)(opt.axisName, axisModel.get('name'));\n    if (!name) {\n      return;\n    }\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2,\n    // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n    var axisNameAvailableWidth;\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation,\n      // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve)(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);\n    var textEl = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .Ay({\n      x: pos[0],\n      y: pos[1],\n      rotation: labelLayout.rotation,\n      silent: AxisBuilder.isLabelSilent(axisModel),\n      style: (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_9__/* .createTextStyle */ .VB)(textStyleModel, {\n        text: name,\n        font: textFont,\n        overflow: 'truncate',\n        width: maxWidth,\n        ellipsis: ellipsis,\n        fill: textStyleModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']),\n        align: textStyleModel.get('align') || labelLayout.textAlign,\n        verticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign\n      }),\n      z2: 1\n    });\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__.setTooltipConfig({\n      el: textEl,\n      componentModel: axisModel,\n      itemName: name\n    });\n    textEl.__fullText = name;\n    // Id for animation\n    textEl.anid = 'name';\n    if (axisModel.get('triggerEvent')) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisName';\n      eventData.name = name;\n      (0,_util_innerStore_js__WEBPACK_IMPORTED_MODULE_10__/* .getECData */ .z)(textEl).eventData = eventData;\n    }\n    // FIXME\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\nfunction endTextLayout(rotation, textPosition, textRotate, extent) {\n  var rotationDiff = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .remRadian */ ._7)(textRotate - rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n  if ((0,_util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .isRadianAroundZero */ .dh)(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if ((0,_util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .isRadianAroundZero */ .dh)(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  if ((0,_coord_axisHelper_js__WEBPACK_IMPORTED_MODULE_11__/* .shouldShowAllLabels */ .PJ)(axisModel.axis)) {\n    return;\n  }\n  // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n  var showMinLabel = axisModel.get(['axisLabel', 'showMinLabel']);\n  var showMaxLabel = axisModel.get(['axisLabel', 'showMaxLabel']);\n  // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\nfunction isTwoLabelOverlapped(current, next) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n  if (!firstRect || !nextRect) {\n    return;\n  }\n  // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n  var mRotationBack = zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_12__.identity([]);\n  zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_12__.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_12__.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_12__.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\nfunction createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {\n  var tickEls = [];\n  var pt1 = [];\n  var pt2 = [];\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = tickEndCoord;\n    if (tickTransform) {\n      (0,zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_3__.applyTransform)(pt1, pt1, tickTransform);\n      (0,zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_3__.applyTransform)(pt2, pt2, tickTransform);\n    }\n    // Tick line, Not use group transform to have better line draw\n    var tickEl = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A({\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: tickLineStyle,\n      z2: 2,\n      autoBatch: true,\n      silent: true\n    });\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__.subPixelOptimizeLine(tickEl.shape, tickEl.style.lineWidth);\n    tickEl.anid = anidPrefix + '_' + ticksCoords[i].tickValue;\n    tickEls.push(tickEl);\n  }\n  return tickEls;\n}\nfunction buildAxisMajorTicks(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var tickModel = axisModel.getModel('axisTick');\n  var shown = tickModel.get('show');\n  if (shown === 'auto' && opt.handleAutoShown) {\n    shown = opt.handleAutoShown('axisTick');\n  }\n  if (!shown || axis.scale.isBlank()) {\n    return;\n  }\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickEndCoord = opt.tickDirection * tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults)(lineStyleModel.getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }), 'ticks');\n  for (var i = 0; i < ticksEls.length; i++) {\n    group.add(ticksEls[i]);\n  }\n  return ticksEls;\n}\nfunction buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {\n  var axis = axisModel.axis;\n  var minorTickModel = axisModel.getModel('minorTick');\n  if (!minorTickModel.get('show') || axis.scale.isBlank()) {\n    return;\n  }\n  var minorTicksCoords = axis.getMinorTicksCoords();\n  if (!minorTicksCoords.length) {\n    return;\n  }\n  var lineStyleModel = minorTickModel.getModel('lineStyle');\n  var tickEndCoord = tickDirection * minorTickModel.get('length');\n  var minorTickLineStyle = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults)(lineStyleModel.getLineStyle(), (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults)(axisModel.getModel('axisTick').getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }));\n  for (var i = 0; i < minorTicksCoords.length; i++) {\n    var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);\n    for (var k = 0; k < minorTicksEls.length; k++) {\n      group.add(minorTicksEls[k]);\n    }\n  }\n}\nfunction buildAxisLabel(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve)(opt.axisLabelShow, axisModel.get(['axisLabel', 'show']));\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels();\n  // Special label rotate.\n  var labelRotation = ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve)(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = AxisBuilder.isLabelSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(labels, function (labelItem, index) {\n    var tickValue = axis.scale.type === 'ordinal' ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n    if (rawCategoryData && rawCategoryData[tickValue]) {\n      var rawCategoryItem = rawCategoryData[tickValue];\n      if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(rawCategoryItem) && rawCategoryItem.textStyle) {\n        itemLabelModel = new _model_Model_js__WEBPACK_IMPORTED_MODULE_13__/* [\"default\"] */ .A(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);\n      }\n    }\n    var textColor = itemLabelModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']);\n    var tickCoord = axis.dataToCoord(tickValue);\n    var align = itemLabelModel.getShallow('align', true) || labelLayout.textAlign;\n    var alignMin = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(itemLabelModel.getShallow('alignMinLabel', true), align);\n    var alignMax = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(itemLabelModel.getShallow('alignMaxLabel', true), align);\n    var verticalAlign = itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign;\n    var verticalAlignMin = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(itemLabelModel.getShallow('verticalAlignMinLabel', true), verticalAlign);\n    var verticalAlignMax = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(itemLabelModel.getShallow('verticalAlignMaxLabel', true), verticalAlign);\n    var textEl = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .Ay({\n      x: tickCoord,\n      y: opt.labelOffset + opt.labelDirection * labelMargin,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10 + (labelItem.level || 0),\n      style: (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_9__/* .createTextStyle */ .VB)(itemLabelModel, {\n        text: formattedLabel,\n        align: index === 0 ? alignMin : index === labels.length - 1 ? alignMax : align,\n        verticalAlign: index === 0 ? verticalAlignMin : index === labels.length - 1 ? verticalAlignMax : verticalAlign,\n        fill: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(textColor) ? textColor(\n        // (1) In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        // (2) Compatible with previous version, which always use formatted label as\n        // input. But in interval scale the formatted label is like '223,445', which\n        // maked user replace ','. So we modify it to return original val but remain\n        // it as 'string' to avoid error in replacing.\n        axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n      })\n    });\n    textEl.anid = 'label_' + tickValue;\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__.setTooltipConfig({\n      el: textEl,\n      componentModel: axisModel,\n      itemName: formattedLabel,\n      formatterParamsExtra: {\n        isTruncated: function () {\n          return textEl.isTruncated;\n        },\n        value: rawLabel,\n        tickIndex: index\n      }\n    });\n    // Pack data for mouse event\n    if (triggerEvent) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisLabel';\n      eventData.value = rawLabel;\n      eventData.tickIndex = index;\n      if (axis.type === 'category') {\n        eventData.dataIndex = tickValue;\n      }\n      (0,_util_innerStore_js__WEBPACK_IMPORTED_MODULE_10__/* .getECData */ .z)(textEl).eventData = eventData;\n    }\n    // FIXME\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxisBuilder);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk1OTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQXhpc0J1aWxkZXIuanM/YmYwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IHJldHJpZXZlLCBkZWZhdWx0cywgZXh0ZW5kLCBlYWNoLCBpc09iamVjdCwgbWFwLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRnVuY3Rpb24sIHJldHJpZXZlMiB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBnZXRFQ0RhdGEgfSBmcm9tICcuLi8uLi91dGlsL2lubmVyU3RvcmUuanMnO1xuaW1wb3J0IHsgY3JlYXRlVGV4dFN0eWxlIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvTW9kZWwuanMnO1xuaW1wb3J0IHsgaXNSYWRpYW5Bcm91bmRaZXJvLCByZW1SYWRpYW4gfSBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTeW1ib2wsIG5vcm1hbGl6ZVN5bWJvbE9mZnNldCB9IGZyb20gJy4uLy4uL3V0aWwvc3ltYm9sLmpzJztcbmltcG9ydCAqIGFzIG1hdHJpeFV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS9tYXRyaXguanMnO1xuaW1wb3J0IHsgYXBwbHlUcmFuc2Zvcm0gYXMgdjJBcHBseVRyYW5zZm9ybSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzJztcbmltcG9ydCB7IHNob3VsZFNob3dBbGxMYWJlbHMgfSBmcm9tICcuLi8uLi9jb29yZC9heGlzSGVscGVyLmpzJztcbmltcG9ydCB7IHByZXBhcmVMYXlvdXRMaXN0LCBoaWRlT3ZlcmxhcCB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsTGF5b3V0SGVscGVyLmpzJztcbnZhciBQSSA9IE1hdGguUEk7XG4vKipcclxuICogQSBmaW5hbCBheGlzIGlzIHRyYW5zbGF0ZWQgYW5kIHJvdGF0ZWQgZnJvbSBhIFwic3RhbmRhcmQgYXhpc1wiLlxyXG4gKiBTbyBvcHQucG9zaXRpb24gYW5kIG9wdC5yb3RhdGlvbiBpcyByZXF1aXJlZC5cclxuICpcclxuICogQSBzdGFuZGFyZCBheGlzIGlzIGFuZCBheGlzIGZyb20gWzAsIDBdIHRvIFswLCBheGlzRXh0ZW50WzFdXSxcclxuICogZm9yIGV4YW1wbGU6ICgwLCAwKSAtLS0tLS0tLS0tLS0+ICgwLCA1MClcclxuICpcclxuICogbmFtZURpcmVjdGlvbiBvciB0aWNrRGlyZWN0aW9uIG9yIGxhYmVsRGlyZWN0aW9uIGlzIDEgbWVhbnMgdGlja1xyXG4gKiBvciBsYWJlbCBpcyBiZWxvdyB0aGUgc3RhbmRhcmQgYXhpcywgd2hlcmVhcyBpcyAtMSBtZWFucyBhYm92ZVxyXG4gKiB0aGUgc3RhbmRhcmQgYXhpcy4gbGFiZWxPZmZzZXQgbWVhbnMgb2Zmc2V0IGJldHdlZW4gbGFiZWwgYW5kIGF4aXMsXHJcbiAqIHdoaWNoIGlzIHVzZWZ1bCB3aGVuICdvblplcm8nLCB3aGVyZSBheGlzTGFiZWwgaXMgaW4gdGhlIGdyaWQgYW5kXHJcbiAqIGxhYmVsIGluIG91dHNpZGUgZ3JpZC5cclxuICpcclxuICogVGlwczogbGlrZSBhbHdheXMsXHJcbiAqIHBvc2l0aXZlIHJvdGF0aW9uIHJlcHJlc2VudHMgYW50aWNsb2Nrd2lzZSwgYW5kIG5lZ2F0aXZlIHJvdGF0aW9uXHJcbiAqIHJlcHJlc2VudHMgY2xvY2t3aXNlLlxyXG4gKiBUaGUgZGlyZWN0aW9uIG9mIHBvc2l0aW9uIGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgdGhlIGRpcmVjdGlvblxyXG4gKiBvZiBzY3JlZW4gY29vcmRpbmF0ZS5cclxuICpcclxuICogRG8gbm90IG5lZWQgdG8gY29uc2lkZXIgYXhpcyAnaW52ZXJzZScsIHdoaWNoIGlzIGF1dG8gcHJvY2Vzc2VkIGJ5XHJcbiAqIGF4aXMgZXh0ZW50LlxyXG4gKi9cbnZhciBBeGlzQnVpbGRlciA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF4aXNCdWlsZGVyKGF4aXNNb2RlbCwgb3B0KSB7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgdGhpcy5vcHQgPSBvcHQ7XG4gICAgdGhpcy5heGlzTW9kZWwgPSBheGlzTW9kZWw7XG4gICAgLy8gRGVmYXVsdCB2YWx1ZVxuICAgIGRlZmF1bHRzKG9wdCwge1xuICAgICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgICBuYW1lRGlyZWN0aW9uOiAxLFxuICAgICAgdGlja0RpcmVjdGlvbjogMSxcbiAgICAgIGxhYmVsRGlyZWN0aW9uOiAxLFxuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgaGFuZGxlQXV0b1Nob3duOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEZJWE1FIE5vdCB1c2UgYSBzZXBhcmF0ZSB0ZXh0IGdyb3VwP1xuICAgIHZhciB0cmFuc2Zvcm1Hcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKHtcbiAgICAgIHg6IG9wdC5wb3NpdGlvblswXSxcbiAgICAgIHk6IG9wdC5wb3NpdGlvblsxXSxcbiAgICAgIHJvdGF0aW9uOiBvcHQucm90YXRpb25cbiAgICB9KTtcbiAgICAvLyB0aGlzLmdyb3VwLmFkZCh0cmFuc2Zvcm1Hcm91cCk7XG4gICAgLy8gdGhpcy5fdHJhbnNmb3JtR3JvdXAgPSB0cmFuc2Zvcm1Hcm91cDtcbiAgICB0cmFuc2Zvcm1Hcm91cC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLl90cmFuc2Zvcm1Hcm91cCA9IHRyYW5zZm9ybUdyb3VwO1xuICB9XG4gIEF4aXNCdWlsZGVyLnByb3RvdHlwZS5oYXNCdWlsZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gISFidWlsZGVyc1tuYW1lXTtcbiAgfTtcbiAgQXhpc0J1aWxkZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgYnVpbGRlcnNbbmFtZV0odGhpcy5vcHQsIHRoaXMuYXhpc01vZGVsLCB0aGlzLmdyb3VwLCB0aGlzLl90cmFuc2Zvcm1Hcm91cCk7XG4gIH07XG4gIEF4aXNCdWlsZGVyLnByb3RvdHlwZS5nZXRHcm91cCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cDtcbiAgfTtcbiAgQXhpc0J1aWxkZXIuaW5uZXJUZXh0TGF5b3V0ID0gZnVuY3Rpb24gKGF4aXNSb3RhdGlvbiwgdGV4dFJvdGF0aW9uLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgcm90YXRpb25EaWZmID0gcmVtUmFkaWFuKHRleHRSb3RhdGlvbiAtIGF4aXNSb3RhdGlvbik7XG4gICAgdmFyIHRleHRBbGlnbjtcbiAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ247XG4gICAgaWYgKGlzUmFkaWFuQXJvdW5kWmVybyhyb3RhdGlvbkRpZmYpKSB7XG4gICAgICAvLyBMYWJlbCBpcyBwYXJhbGxlbCB3aXRoIGF4aXMgbGluZS5cbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gZGlyZWN0aW9uID4gMCA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICB9IGVsc2UgaWYgKGlzUmFkaWFuQXJvdW5kWmVybyhyb3RhdGlvbkRpZmYgLSBQSSkpIHtcbiAgICAgIC8vIExhYmVsIGlzIGludmVyc2UgcGFyYWxsZWwgd2l0aCBheGlzIGxpbmUuXG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IGRpcmVjdGlvbiA+IDAgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBpZiAocm90YXRpb25EaWZmID4gMCAmJiByb3RhdGlvbkRpZmYgPCBQSSkge1xuICAgICAgICB0ZXh0QWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHRBbGlnbiA9IGRpcmVjdGlvbiA+IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IHJvdGF0aW9uRGlmZixcbiAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gICAgfTtcbiAgfTtcbiAgQXhpc0J1aWxkZXIubWFrZUF4aXNFdmVudERhdGFCYXNlID0gZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgIHZhciBldmVudERhdGEgPSB7XG4gICAgICBjb21wb25lbnRUeXBlOiBheGlzTW9kZWwubWFpblR5cGUsXG4gICAgICBjb21wb25lbnRJbmRleDogYXhpc01vZGVsLmNvbXBvbmVudEluZGV4XG4gICAgfTtcbiAgICBldmVudERhdGFbYXhpc01vZGVsLm1haW5UeXBlICsgJ0luZGV4J10gPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG4gICAgcmV0dXJuIGV2ZW50RGF0YTtcbiAgfTtcbiAgQXhpc0J1aWxkZXIuaXNMYWJlbFNpbGVudCA9IGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICB2YXIgdG9vbHRpcE9wdCA9IGF4aXNNb2RlbC5nZXQoJ3Rvb2x0aXAnKTtcbiAgICByZXR1cm4gYXhpc01vZGVsLmdldCgnc2lsZW50JylcbiAgICAvLyBDb25zaWRlciBtb3VzZSBjdXJzb3IsIGFkZCB0aGVzZSByZXN0cmljdGlvbnMuXG4gICAgfHwgIShheGlzTW9kZWwuZ2V0KCd0cmlnZ2VyRXZlbnQnKSB8fCB0b29sdGlwT3B0ICYmIHRvb2x0aXBPcHQuc2hvdyk7XG4gIH07XG4gIHJldHVybiBBeGlzQnVpbGRlcjtcbn0oKTtcbjtcbnZhciBidWlsZGVycyA9IHtcbiAgYXhpc0xpbmU6IGZ1bmN0aW9uIChvcHQsIGF4aXNNb2RlbCwgZ3JvdXAsIHRyYW5zZm9ybUdyb3VwKSB7XG4gICAgdmFyIHNob3duID0gYXhpc01vZGVsLmdldChbJ2F4aXNMaW5lJywgJ3Nob3cnXSk7XG4gICAgaWYgKHNob3duID09PSAnYXV0bycgJiYgb3B0LmhhbmRsZUF1dG9TaG93bikge1xuICAgICAgc2hvd24gPSBvcHQuaGFuZGxlQXV0b1Nob3duKCdheGlzTGluZScpO1xuICAgIH1cbiAgICBpZiAoIXNob3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBleHRlbnQgPSBheGlzTW9kZWwuYXhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgbWF0cml4ID0gdHJhbnNmb3JtR3JvdXAudHJhbnNmb3JtO1xuICAgIHZhciBwdDEgPSBbZXh0ZW50WzBdLCAwXTtcbiAgICB2YXIgcHQyID0gW2V4dGVudFsxXSwgMF07XG4gICAgdmFyIGludmVyc2UgPSBwdDFbMF0gPiBwdDJbMF07XG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShwdDEsIHB0MSwgbWF0cml4KTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQyLCBwdDIsIG1hdHJpeCk7XG4gICAgfVxuICAgIHZhciBsaW5lU3R5bGUgPSBleHRlbmQoe1xuICAgICAgbGluZUNhcDogJ3JvdW5kJ1xuICAgIH0sIGF4aXNNb2RlbC5nZXRNb2RlbChbJ2F4aXNMaW5lJywgJ2xpbmVTdHlsZSddKS5nZXRMaW5lU3R5bGUoKSk7XG4gICAgdmFyIGxpbmUgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHgxOiBwdDFbMF0sXG4gICAgICAgIHkxOiBwdDFbMV0sXG4gICAgICAgIHgyOiBwdDJbMF0sXG4gICAgICAgIHkyOiBwdDJbMV1cbiAgICAgIH0sXG4gICAgICBzdHlsZTogbGluZVN0eWxlLFxuICAgICAgc3Ryb2tlQ29udGFpblRocmVzaG9sZDogb3B0LnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQgfHwgNSxcbiAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgIHoyOiAxXG4gICAgfSk7XG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZShsaW5lLnNoYXBlLCBsaW5lLnN0eWxlLmxpbmVXaWR0aCk7XG4gICAgbGluZS5hbmlkID0gJ2xpbmUnO1xuICAgIGdyb3VwLmFkZChsaW5lKTtcbiAgICB2YXIgYXJyb3dzID0gYXhpc01vZGVsLmdldChbJ2F4aXNMaW5lJywgJ3N5bWJvbCddKTtcbiAgICBpZiAoYXJyb3dzICE9IG51bGwpIHtcbiAgICAgIHZhciBhcnJvd1NpemUgPSBheGlzTW9kZWwuZ2V0KFsnYXhpc0xpbmUnLCAnc3ltYm9sU2l6ZSddKTtcbiAgICAgIGlmIChpc1N0cmluZyhhcnJvd3MpKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgc2FtZSBhcnJvdyBmb3Igc3RhcnQgYW5kIGVuZCBwb2ludFxuICAgICAgICBhcnJvd3MgPSBbYXJyb3dzLCBhcnJvd3NdO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3RyaW5nKGFycm93U2l6ZSkgfHwgaXNOdW1iZXIoYXJyb3dTaXplKSkge1xuICAgICAgICAvLyBVc2UgdGhlIHNhbWUgc2l6ZSBmb3Igd2lkdGggYW5kIGhlaWdodFxuICAgICAgICBhcnJvd1NpemUgPSBbYXJyb3dTaXplLCBhcnJvd1NpemVdO1xuICAgICAgfVxuICAgICAgdmFyIGFycm93T2Zmc2V0ID0gbm9ybWFsaXplU3ltYm9sT2Zmc2V0KGF4aXNNb2RlbC5nZXQoWydheGlzTGluZScsICdzeW1ib2xPZmZzZXQnXSkgfHwgMCwgYXJyb3dTaXplKTtcbiAgICAgIHZhciBzeW1ib2xXaWR0aF8xID0gYXJyb3dTaXplWzBdO1xuICAgICAgdmFyIHN5bWJvbEhlaWdodF8xID0gYXJyb3dTaXplWzFdO1xuICAgICAgZWFjaChbe1xuICAgICAgICByb3RhdGU6IG9wdC5yb3RhdGlvbiArIE1hdGguUEkgLyAyLFxuICAgICAgICBvZmZzZXQ6IGFycm93T2Zmc2V0WzBdLFxuICAgICAgICByOiAwXG4gICAgICB9LCB7XG4gICAgICAgIHJvdGF0ZTogb3B0LnJvdGF0aW9uIC0gTWF0aC5QSSAvIDIsXG4gICAgICAgIG9mZnNldDogYXJyb3dPZmZzZXRbMV0sXG4gICAgICAgIHI6IE1hdGguc3FydCgocHQxWzBdIC0gcHQyWzBdKSAqIChwdDFbMF0gLSBwdDJbMF0pICsgKHB0MVsxXSAtIHB0MlsxXSkgKiAocHQxWzFdIC0gcHQyWzFdKSlcbiAgICAgIH1dLCBmdW5jdGlvbiAocG9pbnQsIGluZGV4KSB7XG4gICAgICAgIGlmIChhcnJvd3NbaW5kZXhdICE9PSAnbm9uZScgJiYgYXJyb3dzW2luZGV4XSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHN5bWJvbCA9IGNyZWF0ZVN5bWJvbChhcnJvd3NbaW5kZXhdLCAtc3ltYm9sV2lkdGhfMSAvIDIsIC1zeW1ib2xIZWlnaHRfMSAvIDIsIHN5bWJvbFdpZHRoXzEsIHN5bWJvbEhlaWdodF8xLCBsaW5lU3R5bGUuc3Ryb2tlLCB0cnVlKTtcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgYXJyb3cgcG9zaXRpb24gd2l0aCBvZmZzZXRcbiAgICAgICAgICB2YXIgciA9IHBvaW50LnIgKyBwb2ludC5vZmZzZXQ7XG4gICAgICAgICAgdmFyIHB0ID0gaW52ZXJzZSA/IHB0MiA6IHB0MTtcbiAgICAgICAgICBzeW1ib2wuYXR0cih7XG4gICAgICAgICAgICByb3RhdGlvbjogcG9pbnQucm90YXRlLFxuICAgICAgICAgICAgeDogcHRbMF0gKyByICogTWF0aC5jb3Mob3B0LnJvdGF0aW9uKSxcbiAgICAgICAgICAgIHk6IHB0WzFdIC0gciAqIE1hdGguc2luKG9wdC5yb3RhdGlvbiksXG4gICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICB6MjogMTFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBncm91cC5hZGQoc3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBheGlzVGlja0xhYmVsOiBmdW5jdGlvbiAob3B0LCBheGlzTW9kZWwsIGdyb3VwLCB0cmFuc2Zvcm1Hcm91cCkge1xuICAgIHZhciB0aWNrc0VscyA9IGJ1aWxkQXhpc01ham9yVGlja3MoZ3JvdXAsIHRyYW5zZm9ybUdyb3VwLCBheGlzTW9kZWwsIG9wdCk7XG4gICAgdmFyIGxhYmVsRWxzID0gYnVpbGRBeGlzTGFiZWwoZ3JvdXAsIHRyYW5zZm9ybUdyb3VwLCBheGlzTW9kZWwsIG9wdCk7XG4gICAgZml4TWluTWF4TGFiZWxTaG93KGF4aXNNb2RlbCwgbGFiZWxFbHMsIHRpY2tzRWxzKTtcbiAgICBidWlsZEF4aXNNaW5vclRpY2tzKGdyb3VwLCB0cmFuc2Zvcm1Hcm91cCwgYXhpc01vZGVsLCBvcHQudGlja0RpcmVjdGlvbik7XG4gICAgLy8gVGhpcyBiaXQgZml4ZXMgdGhlIGxhYmVsIG92ZXJsYXAgaXNzdWUgZm9yIHRoZSB0aW1lIGNoYXJ0LlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYXBhY2hlL2VjaGFydHMvaXNzdWVzLzE0MjY2IGZvciBtb3JlLlxuICAgIGlmIChheGlzTW9kZWwuZ2V0KFsnYXhpc0xhYmVsJywgJ2hpZGVPdmVybGFwJ10pKSB7XG4gICAgICB2YXIgbGFiZWxMaXN0ID0gcHJlcGFyZUxheW91dExpc3QobWFwKGxhYmVsRWxzLCBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgcHJpb3JpdHk6IGxhYmVsLnoyLFxuICAgICAgICAgIGRlZmF1bHRBdHRyOiB7XG4gICAgICAgICAgICBpZ25vcmU6IGxhYmVsLmlnbm9yZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKTtcbiAgICAgIGhpZGVPdmVybGFwKGxhYmVsTGlzdCk7XG4gICAgfVxuICB9LFxuICBheGlzTmFtZTogZnVuY3Rpb24gKG9wdCwgYXhpc01vZGVsLCBncm91cCwgdHJhbnNmb3JtR3JvdXApIHtcbiAgICB2YXIgbmFtZSA9IHJldHJpZXZlKG9wdC5heGlzTmFtZSwgYXhpc01vZGVsLmdldCgnbmFtZScpKTtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hbWVMb2NhdGlvbiA9IGF4aXNNb2RlbC5nZXQoJ25hbWVMb2NhdGlvbicpO1xuICAgIHZhciBuYW1lRGlyZWN0aW9uID0gb3B0Lm5hbWVEaXJlY3Rpb247XG4gICAgdmFyIHRleHRTdHlsZU1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCduYW1lVGV4dFN0eWxlJyk7XG4gICAgdmFyIGdhcCA9IGF4aXNNb2RlbC5nZXQoJ25hbWVHYXAnKSB8fCAwO1xuICAgIHZhciBleHRlbnQgPSBheGlzTW9kZWwuYXhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgZ2FwU2lnbmFsID0gZXh0ZW50WzBdID4gZXh0ZW50WzFdID8gLTEgOiAxO1xuICAgIHZhciBwb3MgPSBbbmFtZUxvY2F0aW9uID09PSAnc3RhcnQnID8gZXh0ZW50WzBdIC0gZ2FwU2lnbmFsICogZ2FwIDogbmFtZUxvY2F0aW9uID09PSAnZW5kJyA/IGV4dGVudFsxXSArIGdhcFNpZ25hbCAqIGdhcCA6IChleHRlbnRbMF0gKyBleHRlbnRbMV0pIC8gMixcbiAgICAvLyBSZXVzZSBsYWJlbE9mZnNldC5cbiAgICBpc05hbWVMb2NhdGlvbkNlbnRlcihuYW1lTG9jYXRpb24pID8gb3B0LmxhYmVsT2Zmc2V0ICsgbmFtZURpcmVjdGlvbiAqIGdhcCA6IDBdO1xuICAgIHZhciBsYWJlbExheW91dDtcbiAgICB2YXIgbmFtZVJvdGF0aW9uID0gYXhpc01vZGVsLmdldCgnbmFtZVJvdGF0ZScpO1xuICAgIGlmIChuYW1lUm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgbmFtZVJvdGF0aW9uID0gbmFtZVJvdGF0aW9uICogUEkgLyAxODA7IC8vIFRvIHJhZGlhbi5cbiAgICB9XG4gICAgdmFyIGF4aXNOYW1lQXZhaWxhYmxlV2lkdGg7XG4gICAgaWYgKGlzTmFtZUxvY2F0aW9uQ2VudGVyKG5hbWVMb2NhdGlvbikpIHtcbiAgICAgIGxhYmVsTGF5b3V0ID0gQXhpc0J1aWxkZXIuaW5uZXJUZXh0TGF5b3V0KG9wdC5yb3RhdGlvbiwgbmFtZVJvdGF0aW9uICE9IG51bGwgPyBuYW1lUm90YXRpb24gOiBvcHQucm90YXRpb24sXG4gICAgICAvLyBBZGFwdCB0byBheGlzLlxuICAgICAgbmFtZURpcmVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsTGF5b3V0ID0gZW5kVGV4dExheW91dChvcHQucm90YXRpb24sIG5hbWVMb2NhdGlvbiwgbmFtZVJvdGF0aW9uIHx8IDAsIGV4dGVudCk7XG4gICAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoID0gb3B0LmF4aXNOYW1lQXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoYXhpc05hbWVBdmFpbGFibGVXaWR0aCAhPSBudWxsKSB7XG4gICAgICAgIGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggPSBNYXRoLmFicyhheGlzTmFtZUF2YWlsYWJsZVdpZHRoIC8gTWF0aC5zaW4obGFiZWxMYXlvdXQucm90YXRpb24pKTtcbiAgICAgICAgIWlzRmluaXRlKGF4aXNOYW1lQXZhaWxhYmxlV2lkdGgpICYmIChheGlzTmFtZUF2YWlsYWJsZVdpZHRoID0gbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0ZXh0Rm9udCA9IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKTtcbiAgICB2YXIgdHJ1bmNhdGVPcHQgPSBheGlzTW9kZWwuZ2V0KCduYW1lVHJ1bmNhdGUnLCB0cnVlKSB8fCB7fTtcbiAgICB2YXIgZWxsaXBzaXMgPSB0cnVuY2F0ZU9wdC5lbGxpcHNpcztcbiAgICB2YXIgbWF4V2lkdGggPSByZXRyaWV2ZShvcHQubmFtZVRydW5jYXRlTWF4V2lkdGgsIHRydW5jYXRlT3B0Lm1heFdpZHRoLCBheGlzTmFtZUF2YWlsYWJsZVdpZHRoKTtcbiAgICB2YXIgdGV4dEVsID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICB4OiBwb3NbMF0sXG4gICAgICB5OiBwb3NbMV0sXG4gICAgICByb3RhdGlvbjogbGFiZWxMYXlvdXQucm90YXRpb24sXG4gICAgICBzaWxlbnQ6IEF4aXNCdWlsZGVyLmlzTGFiZWxTaWxlbnQoYXhpc01vZGVsKSxcbiAgICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUodGV4dFN0eWxlTW9kZWwsIHtcbiAgICAgICAgdGV4dDogbmFtZSxcbiAgICAgICAgZm9udDogdGV4dEZvbnQsXG4gICAgICAgIG92ZXJmbG93OiAndHJ1bmNhdGUnLFxuICAgICAgICB3aWR0aDogbWF4V2lkdGgsXG4gICAgICAgIGVsbGlwc2lzOiBlbGxpcHNpcyxcbiAgICAgICAgZmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCkgfHwgYXhpc01vZGVsLmdldChbJ2F4aXNMaW5lJywgJ2xpbmVTdHlsZScsICdjb2xvciddKSxcbiAgICAgICAgYWxpZ246IHRleHRTdHlsZU1vZGVsLmdldCgnYWxpZ24nKSB8fCBsYWJlbExheW91dC50ZXh0QWxpZ24sXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IHRleHRTdHlsZU1vZGVsLmdldCgndmVydGljYWxBbGlnbicpIHx8IGxhYmVsTGF5b3V0LnRleHRWZXJ0aWNhbEFsaWduXG4gICAgICB9KSxcbiAgICAgIHoyOiAxXG4gICAgfSk7XG4gICAgZ3JhcGhpYy5zZXRUb29sdGlwQ29uZmlnKHtcbiAgICAgIGVsOiB0ZXh0RWwsXG4gICAgICBjb21wb25lbnRNb2RlbDogYXhpc01vZGVsLFxuICAgICAgaXRlbU5hbWU6IG5hbWVcbiAgICB9KTtcbiAgICB0ZXh0RWwuX19mdWxsVGV4dCA9IG5hbWU7XG4gICAgLy8gSWQgZm9yIGFuaW1hdGlvblxuICAgIHRleHRFbC5hbmlkID0gJ25hbWUnO1xuICAgIGlmIChheGlzTW9kZWwuZ2V0KCd0cmlnZ2VyRXZlbnQnKSkge1xuICAgICAgdmFyIGV2ZW50RGF0YSA9IEF4aXNCdWlsZGVyLm1ha2VBeGlzRXZlbnREYXRhQmFzZShheGlzTW9kZWwpO1xuICAgICAgZXZlbnREYXRhLnRhcmdldFR5cGUgPSAnYXhpc05hbWUnO1xuICAgICAgZXZlbnREYXRhLm5hbWUgPSBuYW1lO1xuICAgICAgZ2V0RUNEYXRhKHRleHRFbCkuZXZlbnREYXRhID0gZXZlbnREYXRhO1xuICAgIH1cbiAgICAvLyBGSVhNRVxuICAgIHRyYW5zZm9ybUdyb3VwLmFkZCh0ZXh0RWwpO1xuICAgIHRleHRFbC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICBncm91cC5hZGQodGV4dEVsKTtcbiAgICB0ZXh0RWwuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gIH1cbn07XG5mdW5jdGlvbiBlbmRUZXh0TGF5b3V0KHJvdGF0aW9uLCB0ZXh0UG9zaXRpb24sIHRleHRSb3RhdGUsIGV4dGVudCkge1xuICB2YXIgcm90YXRpb25EaWZmID0gcmVtUmFkaWFuKHRleHRSb3RhdGUgLSByb3RhdGlvbik7XG4gIHZhciB0ZXh0QWxpZ247XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbjtcbiAgdmFyIGludmVyc2UgPSBleHRlbnRbMF0gPiBleHRlbnRbMV07XG4gIHZhciBvbkxlZnQgPSB0ZXh0UG9zaXRpb24gPT09ICdzdGFydCcgJiYgIWludmVyc2UgfHwgdGV4dFBvc2l0aW9uICE9PSAnc3RhcnQnICYmIGludmVyc2U7XG4gIGlmIChpc1JhZGlhbkFyb3VuZFplcm8ocm90YXRpb25EaWZmIC0gUEkgLyAyKSkge1xuICAgIHRleHRWZXJ0aWNhbEFsaWduID0gb25MZWZ0ID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgfSBlbHNlIGlmIChpc1JhZGlhbkFyb3VuZFplcm8ocm90YXRpb25EaWZmIC0gUEkgKiAxLjUpKSB7XG4gICAgdGV4dFZlcnRpY2FsQWxpZ24gPSBvbkxlZnQgPyAndG9wJyA6ICdib3R0b20nO1xuICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICB9IGVsc2Uge1xuICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgaWYgKHJvdGF0aW9uRGlmZiA8IFBJICogMS41ICYmIHJvdGF0aW9uRGlmZiA+IFBJIC8gMikge1xuICAgICAgdGV4dEFsaWduID0gb25MZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gb25MZWZ0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByb3RhdGlvbjogcm90YXRpb25EaWZmLFxuICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgIHRleHRWZXJ0aWNhbEFsaWduOiB0ZXh0VmVydGljYWxBbGlnblxuICB9O1xufVxuZnVuY3Rpb24gZml4TWluTWF4TGFiZWxTaG93KGF4aXNNb2RlbCwgbGFiZWxFbHMsIHRpY2tFbHMpIHtcbiAgaWYgKHNob3VsZFNob3dBbGxMYWJlbHMoYXhpc01vZGVsLmF4aXMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIElmIG1pbiBvciBtYXggYXJlIHVzZXIgc2V0LCB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIElmIHRoZSB0aWNrIG9uIG1pbihtYXgpIGFyZSBvdmVybGFwIG9uIHRoZWlyIG5laWdoYm91ciB0aWNrXG4gIC8vIElmIHRoZXkgYXJlIG92ZXJsYXBwZWQsIHdlIG5lZWQgdG8gaGlkZSB0aGUgbWluKG1heCkgdGljayBsYWJlbFxuICB2YXIgc2hvd01pbkxhYmVsID0gYXhpc01vZGVsLmdldChbJ2F4aXNMYWJlbCcsICdzaG93TWluTGFiZWwnXSk7XG4gIHZhciBzaG93TWF4TGFiZWwgPSBheGlzTW9kZWwuZ2V0KFsnYXhpc0xhYmVsJywgJ3Nob3dNYXhMYWJlbCddKTtcbiAgLy8gRklYTUVcbiAgLy8gSGF2ZSBub3QgY29uc2lkZXIgb25CYW5kIHlldCwgd2hlcmUgdGljayBlbHMgaXMgbW9yZSB0aGFuIGxhYmVsIGVscy5cbiAgbGFiZWxFbHMgPSBsYWJlbEVscyB8fCBbXTtcbiAgdGlja0VscyA9IHRpY2tFbHMgfHwgW107XG4gIHZhciBmaXJzdExhYmVsID0gbGFiZWxFbHNbMF07XG4gIHZhciBuZXh0TGFiZWwgPSBsYWJlbEVsc1sxXTtcbiAgdmFyIGxhc3RMYWJlbCA9IGxhYmVsRWxzW2xhYmVsRWxzLmxlbmd0aCAtIDFdO1xuICB2YXIgcHJldkxhYmVsID0gbGFiZWxFbHNbbGFiZWxFbHMubGVuZ3RoIC0gMl07XG4gIHZhciBmaXJzdFRpY2sgPSB0aWNrRWxzWzBdO1xuICB2YXIgbmV4dFRpY2sgPSB0aWNrRWxzWzFdO1xuICB2YXIgbGFzdFRpY2sgPSB0aWNrRWxzW3RpY2tFbHMubGVuZ3RoIC0gMV07XG4gIHZhciBwcmV2VGljayA9IHRpY2tFbHNbdGlja0Vscy5sZW5ndGggLSAyXTtcbiAgaWYgKHNob3dNaW5MYWJlbCA9PT0gZmFsc2UpIHtcbiAgICBpZ25vcmVFbChmaXJzdExhYmVsKTtcbiAgICBpZ25vcmVFbChmaXJzdFRpY2spO1xuICB9IGVsc2UgaWYgKGlzVHdvTGFiZWxPdmVybGFwcGVkKGZpcnN0TGFiZWwsIG5leHRMYWJlbCkpIHtcbiAgICBpZiAoc2hvd01pbkxhYmVsKSB7XG4gICAgICBpZ25vcmVFbChuZXh0TGFiZWwpO1xuICAgICAgaWdub3JlRWwobmV4dFRpY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZ25vcmVFbChmaXJzdExhYmVsKTtcbiAgICAgIGlnbm9yZUVsKGZpcnN0VGljayk7XG4gICAgfVxuICB9XG4gIGlmIChzaG93TWF4TGFiZWwgPT09IGZhbHNlKSB7XG4gICAgaWdub3JlRWwobGFzdExhYmVsKTtcbiAgICBpZ25vcmVFbChsYXN0VGljayk7XG4gIH0gZWxzZSBpZiAoaXNUd29MYWJlbE92ZXJsYXBwZWQocHJldkxhYmVsLCBsYXN0TGFiZWwpKSB7XG4gICAgaWYgKHNob3dNYXhMYWJlbCkge1xuICAgICAgaWdub3JlRWwocHJldkxhYmVsKTtcbiAgICAgIGlnbm9yZUVsKHByZXZUaWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWdub3JlRWwobGFzdExhYmVsKTtcbiAgICAgIGlnbm9yZUVsKGxhc3RUaWNrKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlnbm9yZUVsKGVsKSB7XG4gIGVsICYmIChlbC5pZ25vcmUgPSB0cnVlKTtcbn1cbmZ1bmN0aW9uIGlzVHdvTGFiZWxPdmVybGFwcGVkKGN1cnJlbnQsIG5leHQpIHtcbiAgLy8gY3VycmVudCBhbmQgbmV4dCBoYXMgdGhlIHNhbWUgcm90YXRpb24uXG4gIHZhciBmaXJzdFJlY3QgPSBjdXJyZW50ICYmIGN1cnJlbnQuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgdmFyIG5leHRSZWN0ID0gbmV4dCAmJiBuZXh0LmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gIGlmICghZmlyc3RSZWN0IHx8ICFuZXh0UmVjdCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBXaGVuIGNoZWNraW5nIGludGVyc2VjdCBvZiB0d28gcm90YXRlZCBsYWJlbHMsIHdlIHVzZSBtUm90YXRpb25CYWNrXG4gIC8vIHRvIGF2b2lkIHRoYXQgYm91bmRpbmdSZWN0IGlzIGVubGFyZ2Ugd2hlbiB1c2luZyBgYm91bmRpbmdSZWN0LmFwcGx5VHJhbnNmb3JtYC5cbiAgdmFyIG1Sb3RhdGlvbkJhY2sgPSBtYXRyaXhVdGlsLmlkZW50aXR5KFtdKTtcbiAgbWF0cml4VXRpbC5yb3RhdGUobVJvdGF0aW9uQmFjaywgbVJvdGF0aW9uQmFjaywgLWN1cnJlbnQucm90YXRpb24pO1xuICBmaXJzdFJlY3QuYXBwbHlUcmFuc2Zvcm0obWF0cml4VXRpbC5tdWwoW10sIG1Sb3RhdGlvbkJhY2ssIGN1cnJlbnQuZ2V0TG9jYWxUcmFuc2Zvcm0oKSkpO1xuICBuZXh0UmVjdC5hcHBseVRyYW5zZm9ybShtYXRyaXhVdGlsLm11bChbXSwgbVJvdGF0aW9uQmFjaywgbmV4dC5nZXRMb2NhbFRyYW5zZm9ybSgpKSk7XG4gIHJldHVybiBmaXJzdFJlY3QuaW50ZXJzZWN0KG5leHRSZWN0KTtcbn1cbmZ1bmN0aW9uIGlzTmFtZUxvY2F0aW9uQ2VudGVyKG5hbWVMb2NhdGlvbikge1xuICByZXR1cm4gbmFtZUxvY2F0aW9uID09PSAnbWlkZGxlJyB8fCBuYW1lTG9jYXRpb24gPT09ICdjZW50ZXInO1xufVxuZnVuY3Rpb24gY3JlYXRlVGlja3ModGlja3NDb29yZHMsIHRpY2tUcmFuc2Zvcm0sIHRpY2tFbmRDb29yZCwgdGlja0xpbmVTdHlsZSwgYW5pZFByZWZpeCkge1xuICB2YXIgdGlja0VscyA9IFtdO1xuICB2YXIgcHQxID0gW107XG4gIHZhciBwdDIgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0aWNrQ29vcmQgPSB0aWNrc0Nvb3Jkc1tpXS5jb29yZDtcbiAgICBwdDFbMF0gPSB0aWNrQ29vcmQ7XG4gICAgcHQxWzFdID0gMDtcbiAgICBwdDJbMF0gPSB0aWNrQ29vcmQ7XG4gICAgcHQyWzFdID0gdGlja0VuZENvb3JkO1xuICAgIGlmICh0aWNrVHJhbnNmb3JtKSB7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHB0MSwgcHQxLCB0aWNrVHJhbnNmb3JtKTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQyLCBwdDIsIHRpY2tUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICAvLyBUaWNrIGxpbmUsIE5vdCB1c2UgZ3JvdXAgdHJhbnNmb3JtIHRvIGhhdmUgYmV0dGVyIGxpbmUgZHJhd1xuICAgIHZhciB0aWNrRWwgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHgxOiBwdDFbMF0sXG4gICAgICAgIHkxOiBwdDFbMV0sXG4gICAgICAgIHgyOiBwdDJbMF0sXG4gICAgICAgIHkyOiBwdDJbMV1cbiAgICAgIH0sXG4gICAgICBzdHlsZTogdGlja0xpbmVTdHlsZSxcbiAgICAgIHoyOiAyLFxuICAgICAgYXV0b0JhdGNoOiB0cnVlLFxuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSk7XG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSh0aWNrRWwuc2hhcGUsIHRpY2tFbC5zdHlsZS5saW5lV2lkdGgpO1xuICAgIHRpY2tFbC5hbmlkID0gYW5pZFByZWZpeCArICdfJyArIHRpY2tzQ29vcmRzW2ldLnRpY2tWYWx1ZTtcbiAgICB0aWNrRWxzLnB1c2godGlja0VsKTtcbiAgfVxuICByZXR1cm4gdGlja0Vscztcbn1cbmZ1bmN0aW9uIGJ1aWxkQXhpc01ham9yVGlja3MoZ3JvdXAsIHRyYW5zZm9ybUdyb3VwLCBheGlzTW9kZWwsIG9wdCkge1xuICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICB2YXIgdGlja01vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzVGljaycpO1xuICB2YXIgc2hvd24gPSB0aWNrTW9kZWwuZ2V0KCdzaG93Jyk7XG4gIGlmIChzaG93biA9PT0gJ2F1dG8nICYmIG9wdC5oYW5kbGVBdXRvU2hvd24pIHtcbiAgICBzaG93biA9IG9wdC5oYW5kbGVBdXRvU2hvd24oJ2F4aXNUaWNrJyk7XG4gIH1cbiAgaWYgKCFzaG93biB8fCBheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbGluZVN0eWxlTW9kZWwgPSB0aWNrTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICB2YXIgdGlja0VuZENvb3JkID0gb3B0LnRpY2tEaXJlY3Rpb24gKiB0aWNrTW9kZWwuZ2V0KCdsZW5ndGgnKTtcbiAgdmFyIHRpY2tzQ29vcmRzID0gYXhpcy5nZXRUaWNrc0Nvb3JkcygpO1xuICB2YXIgdGlja3NFbHMgPSBjcmVhdGVUaWNrcyh0aWNrc0Nvb3JkcywgdHJhbnNmb3JtR3JvdXAudHJhbnNmb3JtLCB0aWNrRW5kQ29vcmQsIGRlZmF1bHRzKGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpLCB7XG4gICAgc3Ryb2tlOiBheGlzTW9kZWwuZ2V0KFsnYXhpc0xpbmUnLCAnbGluZVN0eWxlJywgJ2NvbG9yJ10pXG4gIH0pLCAndGlja3MnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc0Vscy5sZW5ndGg7IGkrKykge1xuICAgIGdyb3VwLmFkZCh0aWNrc0Vsc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHRpY2tzRWxzO1xufVxuZnVuY3Rpb24gYnVpbGRBeGlzTWlub3JUaWNrcyhncm91cCwgdHJhbnNmb3JtR3JvdXAsIGF4aXNNb2RlbCwgdGlja0RpcmVjdGlvbikge1xuICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICB2YXIgbWlub3JUaWNrTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ21pbm9yVGljaycpO1xuICBpZiAoIW1pbm9yVGlja01vZGVsLmdldCgnc2hvdycpIHx8IGF4aXMuc2NhbGUuaXNCbGFuaygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtaW5vclRpY2tzQ29vcmRzID0gYXhpcy5nZXRNaW5vclRpY2tzQ29vcmRzKCk7XG4gIGlmICghbWlub3JUaWNrc0Nvb3Jkcy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGxpbmVTdHlsZU1vZGVsID0gbWlub3JUaWNrTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICB2YXIgdGlja0VuZENvb3JkID0gdGlja0RpcmVjdGlvbiAqIG1pbm9yVGlja01vZGVsLmdldCgnbGVuZ3RoJyk7XG4gIHZhciBtaW5vclRpY2tMaW5lU3R5bGUgPSBkZWZhdWx0cyhsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKSwgZGVmYXVsdHMoYXhpc01vZGVsLmdldE1vZGVsKCdheGlzVGljaycpLmdldExpbmVTdHlsZSgpLCB7XG4gICAgc3Ryb2tlOiBheGlzTW9kZWwuZ2V0KFsnYXhpc0xpbmUnLCAnbGluZVN0eWxlJywgJ2NvbG9yJ10pXG4gIH0pKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5vclRpY2tzQ29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1pbm9yVGlja3NFbHMgPSBjcmVhdGVUaWNrcyhtaW5vclRpY2tzQ29vcmRzW2ldLCB0cmFuc2Zvcm1Hcm91cC50cmFuc2Zvcm0sIHRpY2tFbmRDb29yZCwgbWlub3JUaWNrTGluZVN0eWxlLCAnbWlub3J0aWNrc18nICsgaSk7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBtaW5vclRpY2tzRWxzLmxlbmd0aDsgaysrKSB7XG4gICAgICBncm91cC5hZGQobWlub3JUaWNrc0Vsc1trXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBidWlsZEF4aXNMYWJlbChncm91cCwgdHJhbnNmb3JtR3JvdXAsIGF4aXNNb2RlbCwgb3B0KSB7XG4gIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gIHZhciBzaG93ID0gcmV0cmlldmUob3B0LmF4aXNMYWJlbFNob3csIGF4aXNNb2RlbC5nZXQoWydheGlzTGFiZWwnLCAnc2hvdyddKSk7XG4gIGlmICghc2hvdyB8fCBheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbGFiZWxNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc0xhYmVsJyk7XG4gIHZhciBsYWJlbE1hcmdpbiA9IGxhYmVsTW9kZWwuZ2V0KCdtYXJnaW4nKTtcbiAgdmFyIGxhYmVscyA9IGF4aXMuZ2V0Vmlld0xhYmVscygpO1xuICAvLyBTcGVjaWFsIGxhYmVsIHJvdGF0ZS5cbiAgdmFyIGxhYmVsUm90YXRpb24gPSAocmV0cmlldmUob3B0LmxhYmVsUm90YXRlLCBsYWJlbE1vZGVsLmdldCgncm90YXRlJykpIHx8IDApICogUEkgLyAxODA7XG4gIHZhciBsYWJlbExheW91dCA9IEF4aXNCdWlsZGVyLmlubmVyVGV4dExheW91dChvcHQucm90YXRpb24sIGxhYmVsUm90YXRpb24sIG9wdC5sYWJlbERpcmVjdGlvbik7XG4gIHZhciByYXdDYXRlZ29yeURhdGEgPSBheGlzTW9kZWwuZ2V0Q2F0ZWdvcmllcyAmJiBheGlzTW9kZWwuZ2V0Q2F0ZWdvcmllcyh0cnVlKTtcbiAgdmFyIGxhYmVsRWxzID0gW107XG4gIHZhciBzaWxlbnQgPSBBeGlzQnVpbGRlci5pc0xhYmVsU2lsZW50KGF4aXNNb2RlbCk7XG4gIHZhciB0cmlnZ2VyRXZlbnQgPSBheGlzTW9kZWwuZ2V0KCd0cmlnZ2VyRXZlbnQnKTtcbiAgZWFjaChsYWJlbHMsIGZ1bmN0aW9uIChsYWJlbEl0ZW0sIGluZGV4KSB7XG4gICAgdmFyIHRpY2tWYWx1ZSA9IGF4aXMuc2NhbGUudHlwZSA9PT0gJ29yZGluYWwnID8gYXhpcy5zY2FsZS5nZXRSYXdPcmRpbmFsTnVtYmVyKGxhYmVsSXRlbS50aWNrVmFsdWUpIDogbGFiZWxJdGVtLnRpY2tWYWx1ZTtcbiAgICB2YXIgZm9ybWF0dGVkTGFiZWwgPSBsYWJlbEl0ZW0uZm9ybWF0dGVkTGFiZWw7XG4gICAgdmFyIHJhd0xhYmVsID0gbGFiZWxJdGVtLnJhd0xhYmVsO1xuICAgIHZhciBpdGVtTGFiZWxNb2RlbCA9IGxhYmVsTW9kZWw7XG4gICAgaWYgKHJhd0NhdGVnb3J5RGF0YSAmJiByYXdDYXRlZ29yeURhdGFbdGlja1ZhbHVlXSkge1xuICAgICAgdmFyIHJhd0NhdGVnb3J5SXRlbSA9IHJhd0NhdGVnb3J5RGF0YVt0aWNrVmFsdWVdO1xuICAgICAgaWYgKGlzT2JqZWN0KHJhd0NhdGVnb3J5SXRlbSkgJiYgcmF3Q2F0ZWdvcnlJdGVtLnRleHRTdHlsZSkge1xuICAgICAgICBpdGVtTGFiZWxNb2RlbCA9IG5ldyBNb2RlbChyYXdDYXRlZ29yeUl0ZW0udGV4dFN0eWxlLCBsYWJlbE1vZGVsLCBheGlzTW9kZWwuZWNNb2RlbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0ZXh0Q29sb3IgPSBpdGVtTGFiZWxNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBheGlzTW9kZWwuZ2V0KFsnYXhpc0xpbmUnLCAnbGluZVN0eWxlJywgJ2NvbG9yJ10pO1xuICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLmRhdGFUb0Nvb3JkKHRpY2tWYWx1ZSk7XG4gICAgdmFyIGFsaWduID0gaXRlbUxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnYWxpZ24nLCB0cnVlKSB8fCBsYWJlbExheW91dC50ZXh0QWxpZ247XG4gICAgdmFyIGFsaWduTWluID0gcmV0cmlldmUyKGl0ZW1MYWJlbE1vZGVsLmdldFNoYWxsb3coJ2FsaWduTWluTGFiZWwnLCB0cnVlKSwgYWxpZ24pO1xuICAgIHZhciBhbGlnbk1heCA9IHJldHJpZXZlMihpdGVtTGFiZWxNb2RlbC5nZXRTaGFsbG93KCdhbGlnbk1heExhYmVsJywgdHJ1ZSksIGFsaWduKTtcbiAgICB2YXIgdmVydGljYWxBbGlnbiA9IGl0ZW1MYWJlbE1vZGVsLmdldFNoYWxsb3coJ3ZlcnRpY2FsQWxpZ24nLCB0cnVlKSB8fCBpdGVtTGFiZWxNb2RlbC5nZXRTaGFsbG93KCdiYXNlbGluZScsIHRydWUpIHx8IGxhYmVsTGF5b3V0LnRleHRWZXJ0aWNhbEFsaWduO1xuICAgIHZhciB2ZXJ0aWNhbEFsaWduTWluID0gcmV0cmlldmUyKGl0ZW1MYWJlbE1vZGVsLmdldFNoYWxsb3coJ3ZlcnRpY2FsQWxpZ25NaW5MYWJlbCcsIHRydWUpLCB2ZXJ0aWNhbEFsaWduKTtcbiAgICB2YXIgdmVydGljYWxBbGlnbk1heCA9IHJldHJpZXZlMihpdGVtTGFiZWxNb2RlbC5nZXRTaGFsbG93KCd2ZXJ0aWNhbEFsaWduTWF4TGFiZWwnLCB0cnVlKSwgdmVydGljYWxBbGlnbik7XG4gICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgeDogdGlja0Nvb3JkLFxuICAgICAgeTogb3B0LmxhYmVsT2Zmc2V0ICsgb3B0LmxhYmVsRGlyZWN0aW9uICogbGFiZWxNYXJnaW4sXG4gICAgICByb3RhdGlvbjogbGFiZWxMYXlvdXQucm90YXRpb24sXG4gICAgICBzaWxlbnQ6IHNpbGVudCxcbiAgICAgIHoyOiAxMCArIChsYWJlbEl0ZW0ubGV2ZWwgfHwgMCksXG4gICAgICBzdHlsZTogY3JlYXRlVGV4dFN0eWxlKGl0ZW1MYWJlbE1vZGVsLCB7XG4gICAgICAgIHRleHQ6IGZvcm1hdHRlZExhYmVsLFxuICAgICAgICBhbGlnbjogaW5kZXggPT09IDAgPyBhbGlnbk1pbiA6IGluZGV4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSA/IGFsaWduTWF4IDogYWxpZ24sXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IGluZGV4ID09PSAwID8gdmVydGljYWxBbGlnbk1pbiA6IGluZGV4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSA/IHZlcnRpY2FsQWxpZ25NYXggOiB2ZXJ0aWNhbEFsaWduLFxuICAgICAgICBmaWxsOiBpc0Z1bmN0aW9uKHRleHRDb2xvcikgPyB0ZXh0Q29sb3IoXG4gICAgICAgIC8vICgxKSBJbiBjYXRlZ29yeSBheGlzIHdpdGggZGF0YSB6b29tLCB0aWNrIGlzIG5vdCB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gaW5kZXggb2YgYXhpcy5kYXRhLiBTbyB0aWNrIHNob3VsZCBub3QgYmUgZXhwb3NlZCB0byB1c2VyXG4gICAgICAgIC8vIGluIGNhdGVnb3J5IGF4aXMuXG4gICAgICAgIC8vICgyKSBDb21wYXRpYmxlIHdpdGggcHJldmlvdXMgdmVyc2lvbiwgd2hpY2ggYWx3YXlzIHVzZSBmb3JtYXR0ZWQgbGFiZWwgYXNcbiAgICAgICAgLy8gaW5wdXQuIEJ1dCBpbiBpbnRlcnZhbCBzY2FsZSB0aGUgZm9ybWF0dGVkIGxhYmVsIGlzIGxpa2UgJzIyMyw0NDUnLCB3aGljaFxuICAgICAgICAvLyBtYWtlZCB1c2VyIHJlcGxhY2UgJywnLiBTbyB3ZSBtb2RpZnkgaXQgdG8gcmV0dXJuIG9yaWdpbmFsIHZhbCBidXQgcmVtYWluXG4gICAgICAgIC8vIGl0IGFzICdzdHJpbmcnIHRvIGF2b2lkIGVycm9yIGluIHJlcGxhY2luZy5cbiAgICAgICAgYXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gcmF3TGFiZWwgOiBheGlzLnR5cGUgPT09ICd2YWx1ZScgPyB0aWNrVmFsdWUgKyAnJyA6IHRpY2tWYWx1ZSwgaW5kZXgpIDogdGV4dENvbG9yXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHRleHRFbC5hbmlkID0gJ2xhYmVsXycgKyB0aWNrVmFsdWU7XG4gICAgZ3JhcGhpYy5zZXRUb29sdGlwQ29uZmlnKHtcbiAgICAgIGVsOiB0ZXh0RWwsXG4gICAgICBjb21wb25lbnRNb2RlbDogYXhpc01vZGVsLFxuICAgICAgaXRlbU5hbWU6IGZvcm1hdHRlZExhYmVsLFxuICAgICAgZm9ybWF0dGVyUGFyYW1zRXh0cmE6IHtcbiAgICAgICAgaXNUcnVuY2F0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dEVsLmlzVHJ1bmNhdGVkO1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZTogcmF3TGFiZWwsXG4gICAgICAgIHRpY2tJbmRleDogaW5kZXhcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBQYWNrIGRhdGEgZm9yIG1vdXNlIGV2ZW50XG4gICAgaWYgKHRyaWdnZXJFdmVudCkge1xuICAgICAgdmFyIGV2ZW50RGF0YSA9IEF4aXNCdWlsZGVyLm1ha2VBeGlzRXZlbnREYXRhQmFzZShheGlzTW9kZWwpO1xuICAgICAgZXZlbnREYXRhLnRhcmdldFR5cGUgPSAnYXhpc0xhYmVsJztcbiAgICAgIGV2ZW50RGF0YS52YWx1ZSA9IHJhd0xhYmVsO1xuICAgICAgZXZlbnREYXRhLnRpY2tJbmRleCA9IGluZGV4O1xuICAgICAgaWYgKGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICBldmVudERhdGEuZGF0YUluZGV4ID0gdGlja1ZhbHVlO1xuICAgICAgfVxuICAgICAgZ2V0RUNEYXRhKHRleHRFbCkuZXZlbnREYXRhID0gZXZlbnREYXRhO1xuICAgIH1cbiAgICAvLyBGSVhNRVxuICAgIHRyYW5zZm9ybUdyb3VwLmFkZCh0ZXh0RWwpO1xuICAgIHRleHRFbC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICBsYWJlbEVscy5wdXNoKHRleHRFbCk7XG4gICAgZ3JvdXAuYWRkKHRleHRFbCk7XG4gICAgdGV4dEVsLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICB9KTtcbiAgcmV0dXJuIGxhYmVsRWxzO1xufVxuZXhwb3J0IGRlZmF1bHQgQXhpc0J1aWxkZXI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///89598\n")}}]);