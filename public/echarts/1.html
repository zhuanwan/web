<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <div id="main" style="width: 1400px; height: 670px; border: 1px solid black"></div>
</body>

<script src="https://cdn.ucyber.cn/common/echarts@5.4.0.min.js"></script>
<script type="text/javascript">

  // 计算两个点的斜率
  function calculateSlope(point1, point2) {
    if (point2.x - point1.x === 0) {
      return Infinity; // 垂直线段的斜率为无穷大
    }
    return (point2.y - point1.y) / (point2.x - point1.x);
  }

  // 计算线段的 y 截距
  function calculateYIntercept(point, slope) {
    // 对于垂直线段，没有 y 截距
    if (slope === Infinity) {
      return null;
    }
    return point.y - slope * point.x;
  }

  // 判断两条线段是否相交，并返回相交点
  function findIntersectionPoint(segment1, segment2) {
    const slope1 = calculateSlope(segment1.start, segment1.end);
    const slope2 = calculateSlope(segment2.start, segment2.end);

    // 检查是否平行
    if (slope1 === slope2) {
      return null;
    }

    const yIntercept1 = calculateYIntercept(segment1.start, slope1);
    const yIntercept2 = calculateYIntercept(segment2.start, slope2);

    let intersectionX, intersectionY;

    // 如果其中一个线段垂直于 x 轴
    if (slope1 === Infinity) {
      intersectionX = segment1.start.x;
      intersectionY = slope2 * intersectionX + yIntercept2;
    } else if (slope2 === Infinity) {
      intersectionX = segment2.start.x;
      intersectionY = slope1 * intersectionX + yIntercept1;
    } else {
      // 计算相交点的 x 坐标
      intersectionX = (yIntercept2 - yIntercept1) / (slope1 - slope2);
      // 计算相交点的 y 坐标
      intersectionY = slope1 * intersectionX + yIntercept1;
    }

    // 检查相交点是否在两条线段的范围内
    if (
      isPointWithinSegment(segment1.start, segment1.end, { x: intersectionX, y: intersectionY }) &&
      isPointWithinSegment(segment2.start, segment2.end, { x: intersectionX, y: intersectionY })
    ) {
      return { x: intersectionX, y: intersectionY };
    }

    return null;
  }

  // 检查点是否在线段的范围内
  function isPointWithinSegment(start, end, point) {
    const minX = Math.min(start.x, end.x);
    const maxX = Math.max(start.x, end.x);
    const minY = Math.min(start.y, end.y);
    const maxY = Math.max(start.y, end.y);

    return (
      point.x >= minX &&
      point.x <= maxX &&
      point.y >= minY &&
      point.y <= maxY
    );
  }


  //////////////// 以上方法来自AI //////////////////


  const xData = ['00:00', '01:00', '02:00', '03:00', '04:00', '05:00', '06:00', '07:00',
    '08:00', '09:00', '10:00', '11:00', '12:00', '13:00', '14:00', '15:00', '16:00', '17:00', '18:00', '19:00', '20:00', '21:00', '22:00', '23:00']
  const yData = [
    {
      name: '实际负荷',
      value: [5, 8, 4, 3, 6, 9, 4, 6, 8, 7, 9, 4, 6, 7, 5, 8, 4, 4, 6, 8, 4, 6, 8, 7]
    },
    {
      name: '基线负荷',
      value: [9, 6, 6, 4, 2, 8, 4, 6, 8, 7, 5, 8, 4, 4, 6, 8, 4, 6, 8, 7, 9, 4, 6, 7]
    }
  ]
  color = ['#f30', '#0f0']
  markAreaData = [
    ['01:00', '08:00'],
    ['12:00', '16:00']
  ]

  //////// 以上数据是传入数据 ////////////////


  const padZero = (num) => {
    return num < 10 ? `0${num}` : num
  }
  var myChart = echarts.init(document.getElementById('main'));



  function renderItem(params, api) {
    if (params.context.rendered) {
      return;
    }
    params.context.rendered = true;


    // 拿到时段
    const times = []
    markAreaData.forEach(element => {
      const [start, end] = element
      const startNum = +start.substring(0, 2)
      const endNum = +end.substring(0, 2)
      let before = startNum
      for (let i = startNum + 1; i <= endNum; i++) {
        times.push([`${padZero(before)}:00`, `${padZero(i)}:00`])
        before = i
      }
    });

    const allPoints = []
    // 拿到时段下两条线的值
    times.forEach(element => {
      const [start, end] = element
      const startIndex = xData.findIndex(ele => ele === start)
      const endIndex = xData.findIndex(ele => ele === end)
      // 第一条线的两个Y轴端点
      const lineOneStarY = yData[0].value[startIndex]
      const lineOneEndY = yData[0].value[endIndex]
      // 第二条线的两个Y轴端点
      const lineTwoStarY = yData[1].value[startIndex]
      const lineTwoEndY = yData[1].value[endIndex]

      let points = []
      const lineOneStart = api.coord([start, lineOneStarY])
      const lineOneEnd = api.coord([end, lineOneEndY])
      const lineTwoStart = api.coord([start, lineTwoStarY])
      const lineTwoEnd = api.coord([end, lineTwoEndY])

      const segment1 = { start: { x: lineOneStart[0], y: lineOneStart[1] }, end: { x: lineOneEnd[0], y: lineOneEnd[1] } };
      const segment2 = { start: { x: lineTwoStart[0], y: lineTwoStart[1] }, end: { x: lineTwoEnd[0], y: lineTwoEnd[1] } };

      const intersectionPoint = findIntersectionPoint(segment1, segment2);
      if (intersectionPoint) {
        // 如果有交点
        if (lineOneStart[1] > lineTwoStart[1]) {
          points.push(lineOneEnd);
          points.push(lineTwoEnd);
        } else {
          points.push(lineOneStart);
          points.push(lineTwoStart);
        }
        points.push([intersectionPoint.x, intersectionPoint.y]);
        allPoints.push(points)
      } else if (lineOneStarY >= lineTwoStarY && lineOneEndY >= lineTwoEndY) {
        // 如果第一条线的起始点和终点  都大于 第二条线的起始点和终点
        points.push(lineOneStart);
        points.push(lineOneEnd);
        points.push(lineTwoEnd);
        points.push(lineTwoStart);
        allPoints.push(points)
      }
    })

    return {
      type: 'group',
      children: allPoints.map(points => {
        return {
          type: 'polygon',
          shape: {
            points: echarts.graphic.clipPointsByRect(points, {
              x: params.coordSys.x,
              y: params.coordSys.y,
              width: params.coordSys.width,
              height: params.coordSys.height
            })
          },
          style: api.style({
            fill: '#864',
            stroke: '#864',
          })
        }
      })
    }
  }

  option = {
    tooltip: {
      confine: true,
      trigger: 'axis',
      formatter: (params) => {
        let time = '';
        time = xData[params[0].dataIndex];

        const h = params.reduce((prev, cur) => {
          if (cur.componentSubType === "custom") {
            return prev
          }
          return `${prev}<div>${cur.marker}${cur.seriesName}：${cur.value}</div>`;
        }, '');
        return `<div>${time}</div>${h}`;
      },
    },
    xAxis: {
      type: 'category',
      boundaryGap: false,
      data: xData
    },
    yAxis: {
      type: 'value',
      boundaryGap: [0, '30%']
    },
    series: [
      ...yData.map((ele, index) => {
        const item = {
          name: ele.name,
          type: 'line',
          symbol: 'none',
          itemStyle: {
            normal: {
              color: color[index],
              lineStyle: {
                color: color[index],
              },
            }
          },
          data: ele.value
        }
        if (index === 1) {
          item.markArea = {
            itemStyle: {
              color: 'rgba(255, 173, 177, 0.4)'
            },
            data: markAreaData.map(ele => {
              return [
                {
                  name: `${ele[0]}-${ele[1]}`,
                  xAxis: ele[0]
                },
                {
                  xAxis: ele[1]
                }
              ]
            })

          }
        }
        return item
      }),
      {
        type: 'custom',
        renderItem: renderItem,
        data: xData
      }
    ],
  };

  myChart.setOption(option)
</script>

</html>