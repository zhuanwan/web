"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[1505],{27288:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createSeriesData.js\nvar createSeriesData = __webpack_require__(13637);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n;// ./node_modules/echarts/lib/chart/custom/CustomSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n// Also compat with ec4, where\n// `visual('color') visual('borderColor')` is supported.\nvar STYLE_VISUAL_TYPE = {\n  color: 'fill',\n  borderColor: 'stroke'\n};\nvar NON_STYLE_VISUAL_PROPS = {\n  symbol: 1,\n  symbolSize: 1,\n  symbolKeepAspect: 1,\n  legendIcon: 1,\n  visualMeta: 1,\n  liftZ: 1,\n  decal: 1\n};\n;\nvar customInnerStore = (0,model/* makeInner */.$r)();\nvar CustomSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(CustomSeriesModel, _super);\n  function CustomSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = CustomSeriesModel.type;\n    return _this;\n  }\n  CustomSeriesModel.prototype.optionUpdated = function () {\n    this.currentZLevel = this.get('zlevel', true);\n    this.currentZ = this.get('z', true);\n  };\n  CustomSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    return (0,createSeriesData/* default */.A)(null, this);\n  };\n  CustomSeriesModel.prototype.getDataParams = function (dataIndex, dataType, el) {\n    var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);\n    el && (params.info = customInnerStore(el).info);\n    return params;\n  };\n  CustomSeriesModel.type = 'series.custom';\n  CustomSeriesModel.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar'];\n  CustomSeriesModel.defaultOption = {\n    coordinateSystem: 'cartesian2d',\n    // zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    // Custom series will not clip by default.\n    // Some case will use custom series to draw label\n    // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight\n    clip: false\n    // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // Polar coordinate system\n    // polarIndex: 0,\n    // Geo coordinate system\n    // geoIndex: 0,\n  };\n  return CustomSeriesModel;\n}(Series/* default */.A);\n/* harmony default export */ const CustomSeries = (CustomSeriesModel);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Path.js\nvar Path = __webpack_require__(59482);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Image.js\nvar Image = __webpack_require__(90540);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/labelHelper.js\nvar labelHelper = __webpack_require__(44532);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/layout/barGrid.js\nvar barGrid = __webpack_require__(62536);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/DataDiffer.js\nvar DataDiffer = __webpack_require__(16563);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js\nvar createClipPathFromCoordSys = __webpack_require__(95235);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/cartesian/prepareCustom.js\nvar prepareCustom = __webpack_require__(84557);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/geo/prepareCustom.js\nvar geo_prepareCustom = __webpack_require__(79798);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/single/prepareCustom.js\nvar single_prepareCustom = __webpack_require__(76953);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/polar/prepareCustom.js\nvar polar_prepareCustom = __webpack_require__(68971);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/calendar/prepareCustom.js\nvar calendar_prepareCustom = __webpack_require__(36915);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Displayable.js\nvar Displayable = __webpack_require__(71519);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/styleCompat.js\nvar styleCompat = __webpack_require__(9848);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/log.js\nvar log = __webpack_require__(41025);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/decal.js\nvar decal = __webpack_require__(23538);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/customGraphicTransition.js\nvar customGraphicTransition = __webpack_require__(57625);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/customGraphicKeyframeAnimation.js\nvar customGraphicKeyframeAnimation = __webpack_require__(92606);\n;// ./node_modules/echarts/lib/chart/custom/CustomView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar EMPHASIS = 'emphasis';\nvar NORMAL = 'normal';\nvar BLUR = 'blur';\nvar SELECT = 'select';\nvar STATES = [NORMAL, EMPHASIS, BLUR, SELECT];\nvar PATH_ITEM_STYLE = {\n  normal: ['itemStyle'],\n  emphasis: [EMPHASIS, 'itemStyle'],\n  blur: [BLUR, 'itemStyle'],\n  select: [SELECT, 'itemStyle']\n};\nvar PATH_LABEL = {\n  normal: ['label'],\n  emphasis: [EMPHASIS, 'label'],\n  blur: [BLUR, 'label'],\n  select: [SELECT, 'label']\n};\nvar DEFAULT_TRANSITION = ['x', 'y'];\n// Use prefix to avoid index to be the same as el.name,\n// which will cause weird update animation.\nvar GROUP_DIFF_PREFIX = 'e\\0\\0';\nvar attachedTxInfoTmp = {\n  normal: {},\n  emphasis: {},\n  blur: {},\n  select: {}\n};\n/**\r\n * To reduce total package size of each coordinate systems, the modules `prepareCustom`\r\n * of each coordinate systems are not required by each coordinate systems directly, but\r\n * required by the module `custom`.\r\n *\r\n * prepareInfoForCustomSeries {Function}: optional\r\n *     @return {Object} {coordSys: {...}, api: {\r\n *         coord: function (data, clamp) {}, // return point in global.\r\n *         size: function (dataSize, dataItem) {} // return size of each axis in coordSys.\r\n *     }}\r\n */\nvar prepareCustoms = {\n  cartesian2d: prepareCustom/* default */.A,\n  geo: geo_prepareCustom/* default */.A,\n  single: single_prepareCustom/* default */.A,\n  polar: polar_prepareCustom/* default */.A,\n  calendar: calendar_prepareCustom/* default */.A\n};\nfunction isPath(el) {\n  return el instanceof Path/* default */.Ay;\n}\nfunction isDisplayable(el) {\n  return el instanceof Displayable/* default */.Ay;\n}\nfunction copyElement(sourceEl, targetEl) {\n  targetEl.copyTransform(sourceEl);\n  if (isDisplayable(targetEl) && isDisplayable(sourceEl)) {\n    targetEl.setStyle(sourceEl.style);\n    targetEl.z = sourceEl.z;\n    targetEl.z2 = sourceEl.z2;\n    targetEl.zlevel = sourceEl.zlevel;\n    targetEl.invisible = sourceEl.invisible;\n    targetEl.ignore = sourceEl.ignore;\n    if (isPath(targetEl) && isPath(sourceEl)) {\n      targetEl.setShape(sourceEl.shape);\n    }\n  }\n}\nvar CustomChartView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(CustomChartView, _super);\n  function CustomChartView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = CustomChartView.type;\n    return _this;\n  }\n  CustomChartView.prototype.render = function (customSeries, ecModel, api, payload) {\n    // Clear previously rendered progressive elements.\n    this._progressiveEls = null;\n    var oldData = this._data;\n    var data = customSeries.getData();\n    var group = this.group;\n    var renderItem = makeRenderItem(customSeries, data, ecModel, api);\n    if (!oldData) {\n      // Previous render is incremental render or first render.\n      // Needs remove the incremental rendered elements.\n      group.removeAll();\n    }\n    data.diff(oldData).add(function (newIdx) {\n      createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data);\n    }).remove(function (oldIdx) {\n      var el = oldData.getItemGraphicEl(oldIdx);\n      el && (0,customGraphicTransition/* applyLeaveTransition */.h8)(el, customInnerStore(el).option, customSeries);\n    }).update(function (newIdx, oldIdx) {\n      var oldEl = oldData.getItemGraphicEl(oldIdx);\n      createOrUpdateItem(api, oldEl, newIdx, renderItem(newIdx, payload), customSeries, group, data);\n    }).execute();\n    // Do clipping\n    var clipPath = customSeries.get('clip', true) ? (0,createClipPathFromCoordSys/* createClipPath */.Ip)(customSeries.coordinateSystem, false, customSeries) : null;\n    if (clipPath) {\n      group.setClipPath(clipPath);\n    } else {\n      group.removeClipPath();\n    }\n    this._data = data;\n  };\n  CustomChartView.prototype.incrementalPrepareRender = function (customSeries, ecModel, api) {\n    this.group.removeAll();\n    this._data = null;\n  };\n  CustomChartView.prototype.incrementalRender = function (params, customSeries, ecModel, api, payload) {\n    var data = customSeries.getData();\n    var renderItem = makeRenderItem(customSeries, data, ecModel, api);\n    var progressiveEls = this._progressiveEls = [];\n    function setIncrementalAndHoverLayer(el) {\n      if (!el.isGroup) {\n        el.incremental = true;\n        el.ensureState('emphasis').hoverLayer = true;\n      }\n    }\n    for (var idx = params.start; idx < params.end; idx++) {\n      var el = createOrUpdateItem(null, null, idx, renderItem(idx, payload), customSeries, this.group, data);\n      if (el) {\n        el.traverse(setIncrementalAndHoverLayer);\n        progressiveEls.push(el);\n      }\n    }\n  };\n  CustomChartView.prototype.eachRendered = function (cb) {\n    graphic.traverseElements(this._progressiveEls || this.group, cb);\n  };\n  CustomChartView.prototype.filterForExposedEvent = function (eventType, query, targetEl, packedEvent) {\n    var elementName = query.element;\n    if (elementName == null || targetEl.name === elementName) {\n      return true;\n    }\n    // Enable to give a name on a group made by `renderItem`, and listen\n    // events that are triggered by its descendents.\n    while ((targetEl = targetEl.__hostTarget || targetEl.parent) && targetEl !== this.group) {\n      if (targetEl.name === elementName) {\n        return true;\n      }\n    }\n    return false;\n  };\n  CustomChartView.type = 'custom';\n  return CustomChartView;\n}(Chart/* default */.A);\n/* harmony default export */ const CustomView = (CustomChartView);\nfunction createEl(elOption) {\n  var graphicType = elOption.type;\n  var el;\n  // Those graphic elements are not shapes. They should not be\n  // overwritten by users, so do them first.\n  if (graphicType === 'path') {\n    var shape = elOption.shape;\n    // Using pathRect brings convenience to users sacle svg path.\n    var pathRect = shape.width != null && shape.height != null ? {\n      x: shape.x || 0,\n      y: shape.y || 0,\n      width: shape.width,\n      height: shape.height\n    } : null;\n    var pathData = getPathData(shape);\n    // Path is also used for icon, so layout 'center' by default.\n    el = graphic.makePath(pathData, null, pathRect, shape.layout || 'center');\n    customInnerStore(el).customPathData = pathData;\n  } else if (graphicType === 'image') {\n    el = new Image/* default */.Ay({});\n    customInnerStore(el).customImagePath = elOption.style.image;\n  } else if (graphicType === 'text') {\n    el = new Text/* default */.Ay({});\n    // customInnerStore(el).customText = (elOption.style as TextStyleProps).text;\n  } else if (graphicType === 'group') {\n    el = new Group/* default */.A();\n  } else if (graphicType === 'compoundPath') {\n    throw new Error('\"compoundPath\" is not supported yet.');\n  } else {\n    var Clz = graphic.getShapeClass(graphicType);\n    if (!Clz) {\n      var errMsg = '';\n      if (false) {}\n      (0,log/* throwError */.$8)(errMsg);\n    }\n    el = new Clz();\n  }\n  customInnerStore(el).customGraphicType = graphicType;\n  el.name = elOption.name;\n  // Compat ec4: the default z2 lift is 1. If changing the number,\n  // some cases probably be broken: hierarchy layout along z, like circle packing,\n  // where emphasis only intending to modify color/border rather than lift z2.\n  el.z2EmphasisLift = 1;\n  el.z2SelectLift = 1;\n  return el;\n}\nfunction updateElNormal(\n// Can be null/undefined\napi, el, dataIndex, elOption, attachedTxInfo, seriesModel, isInit) {\n  // Stop and restore before update any other attributes.\n  (0,customGraphicKeyframeAnimation/* stopPreviousKeyframeAnimationAndRestore */.$)(el);\n  var txCfgOpt = attachedTxInfo && attachedTxInfo.normal.cfg;\n  if (txCfgOpt) {\n    // PENDING: whether use user object directly rather than clone?\n    // TODO:5.0 textConfig transition animation?\n    el.setTextConfig(txCfgOpt);\n  }\n  // Default transition ['x', 'y']\n  if (elOption && elOption.transition == null) {\n    elOption.transition = DEFAULT_TRANSITION;\n  }\n  // Do some normalization on style.\n  var styleOpt = elOption && elOption.style;\n  if (styleOpt) {\n    if (el.type === 'text') {\n      var textOptionStyle = styleOpt;\n      // Compatible with ec4: if `textFill` or `textStroke` exists use them.\n      (0,util.hasOwn)(textOptionStyle, 'textFill') && (textOptionStyle.fill = textOptionStyle.textFill);\n      (0,util.hasOwn)(textOptionStyle, 'textStroke') && (textOptionStyle.stroke = textOptionStyle.textStroke);\n    }\n    var decalPattern = void 0;\n    var decalObj = isPath(el) ? styleOpt.decal : null;\n    if (api && decalObj) {\n      decalObj.dirty = true;\n      decalPattern = (0,decal/* createOrUpdatePatternFromDecal */.w)(decalObj, api);\n    }\n    // Always overwrite in case user specify this prop.\n    styleOpt.__decalPattern = decalPattern;\n  }\n  if (isDisplayable(el)) {\n    if (styleOpt) {\n      var decalPattern = styleOpt.__decalPattern;\n      if (decalPattern) {\n        styleOpt.decal = decalPattern;\n      }\n    }\n  }\n  (0,customGraphicTransition/* applyUpdateTransition */.rh)(el, elOption, seriesModel, {\n    dataIndex: dataIndex,\n    isInit: isInit,\n    clearStyle: true\n  });\n  (0,customGraphicKeyframeAnimation/* applyKeyframeAnimation */.L)(el, elOption.keyframeAnimation, seriesModel);\n}\nfunction updateElOnState(state, el, elStateOpt, styleOpt, attachedTxInfo) {\n  var elDisplayable = el.isGroup ? null : el;\n  var txCfgOpt = attachedTxInfo && attachedTxInfo[state].cfg;\n  // PENDING:5.0 support customize scale change and transition animation?\n  if (elDisplayable) {\n    // By default support auto lift color when hover whether `emphasis` specified.\n    var stateObj = elDisplayable.ensureState(state);\n    if (styleOpt === false) {\n      var existingEmphasisState = elDisplayable.getState(state);\n      if (existingEmphasisState) {\n        existingEmphasisState.style = null;\n      }\n    } else {\n      // style is needed to enable default emphasis.\n      stateObj.style = styleOpt || null;\n    }\n    // If `elOption.styleEmphasis` or `elOption.emphasis.style` is `false`,\n    // remove hover style.\n    // If `elOption.textConfig` or `elOption.emphasis.textConfig` is null/undefined, it does not\n    // make sense. So for simplicity, we do not ditinguish `hasOwnProperty` and null/undefined.\n    if (txCfgOpt) {\n      stateObj.textConfig = txCfgOpt;\n    }\n    (0,states/* setDefaultStateProxy */.DW)(elDisplayable);\n  }\n}\nfunction updateZ(el, elOption, seriesModel) {\n  // Group not support textContent and not support z yet.\n  if (el.isGroup) {\n    return;\n  }\n  var elDisplayable = el;\n  var currentZ = seriesModel.currentZ;\n  var currentZLevel = seriesModel.currentZLevel;\n  // Always erase.\n  elDisplayable.z = currentZ;\n  elDisplayable.zlevel = currentZLevel;\n  // z2 must not be null/undefined, otherwise sort error may occur.\n  var optZ2 = elOption.z2;\n  optZ2 != null && (elDisplayable.z2 = optZ2 || 0);\n  for (var i = 0; i < STATES.length; i++) {\n    updateZForEachState(elDisplayable, elOption, STATES[i]);\n  }\n}\nfunction updateZForEachState(elDisplayable, elOption, state) {\n  var isNormal = state === NORMAL;\n  var elStateOpt = isNormal ? elOption : retrieveStateOption(elOption, state);\n  var optZ2 = elStateOpt ? elStateOpt.z2 : null;\n  var stateObj;\n  if (optZ2 != null) {\n    // Do not `ensureState` until required.\n    stateObj = isNormal ? elDisplayable : elDisplayable.ensureState(state);\n    stateObj.z2 = optZ2 || 0;\n  }\n}\nfunction makeRenderItem(customSeries, data, ecModel, api) {\n  var renderItem = customSeries.get('renderItem');\n  var coordSys = customSeries.coordinateSystem;\n  var prepareResult = {};\n  if (coordSys) {\n    if (false) {}\n    // `coordSys.prepareCustoms` is used for external coord sys like bmap.\n    prepareResult = coordSys.prepareCustoms ? coordSys.prepareCustoms(coordSys) : prepareCustoms[coordSys.type](coordSys);\n  }\n  var userAPI = (0,util.defaults)({\n    getWidth: api.getWidth,\n    getHeight: api.getHeight,\n    getZr: api.getZr,\n    getDevicePixelRatio: api.getDevicePixelRatio,\n    value: value,\n    style: style,\n    ordinalRawValue: ordinalRawValue,\n    styleEmphasis: styleEmphasis,\n    visual: visual,\n    barLayout: barLayout,\n    currentSeriesIndices: currentSeriesIndices,\n    font: font\n  }, prepareResult.api || {});\n  var userParams = {\n    // The life cycle of context: current round of rendering.\n    // The global life cycle is probably not necessary, because\n    // user can store global status by themselves.\n    context: {},\n    seriesId: customSeries.id,\n    seriesName: customSeries.name,\n    seriesIndex: customSeries.seriesIndex,\n    coordSys: prepareResult.coordSys,\n    dataInsideLength: data.count(),\n    encode: wrapEncodeDef(customSeries.getData())\n  };\n  // If someday intending to refactor them to a class, should consider do not\n  // break change: currently these attribute member are encapsulated in a closure\n  // so that do not need to force user to call these method with a scope.\n  // Do not support call `api` asynchronously without dataIndexInside input.\n  var currDataIndexInside;\n  var currItemModel;\n  var currItemStyleModels = {};\n  var currLabelModels = {};\n  var seriesItemStyleModels = {};\n  var seriesLabelModels = {};\n  for (var i = 0; i < STATES.length; i++) {\n    var stateName = STATES[i];\n    seriesItemStyleModels[stateName] = customSeries.getModel(PATH_ITEM_STYLE[stateName]);\n    seriesLabelModels[stateName] = customSeries.getModel(PATH_LABEL[stateName]);\n  }\n  function getItemModel(dataIndexInside) {\n    return dataIndexInside === currDataIndexInside ? currItemModel || (currItemModel = data.getItemModel(dataIndexInside)) : data.getItemModel(dataIndexInside);\n  }\n  function getItemStyleModel(dataIndexInside, state) {\n    return !data.hasItemOption ? seriesItemStyleModels[state] : dataIndexInside === currDataIndexInside ? currItemStyleModels[state] || (currItemStyleModels[state] = getItemModel(dataIndexInside).getModel(PATH_ITEM_STYLE[state])) : getItemModel(dataIndexInside).getModel(PATH_ITEM_STYLE[state]);\n  }\n  function getLabelModel(dataIndexInside, state) {\n    return !data.hasItemOption ? seriesLabelModels[state] : dataIndexInside === currDataIndexInside ? currLabelModels[state] || (currLabelModels[state] = getItemModel(dataIndexInside).getModel(PATH_LABEL[state])) : getItemModel(dataIndexInside).getModel(PATH_LABEL[state]);\n  }\n  return function (dataIndexInside, payload) {\n    currDataIndexInside = dataIndexInside;\n    currItemModel = null;\n    currItemStyleModels = {};\n    currLabelModels = {};\n    return renderItem && renderItem((0,util.defaults)({\n      dataIndexInside: dataIndexInside,\n      dataIndex: data.getRawIndex(dataIndexInside),\n      // Can be used for optimization when zoom or roam.\n      actionType: payload ? payload.type : null\n    }, userParams), userAPI);\n  };\n  /**\r\n   * @public\r\n   * @param dim by default 0.\r\n   * @param dataIndexInside by default `currDataIndexInside`.\r\n   */\n  function value(dim, dataIndexInside) {\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n    return data.getStore().get(data.getDimensionIndex(dim || 0), dataIndexInside);\n  }\n  /**\r\n   * @public\r\n   * @param dim by default 0.\r\n   * @param dataIndexInside by default `currDataIndexInside`.\r\n   */\n  function ordinalRawValue(dim, dataIndexInside) {\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n    dim = dim || 0;\n    var dimInfo = data.getDimensionInfo(dim);\n    if (!dimInfo) {\n      var dimIndex = data.getDimensionIndex(dim);\n      return dimIndex >= 0 ? data.getStore().get(dimIndex, dataIndexInside) : undefined;\n    }\n    var val = data.get(dimInfo.name, dataIndexInside);\n    var ordinalMeta = dimInfo && dimInfo.ordinalMeta;\n    return ordinalMeta ? ordinalMeta.categories[val] : val;\n  }\n  /**\r\n   * @deprecated The original intention of `api.style` is enable to set itemStyle\r\n   * like other series. But it is not necessary and not easy to give a strict definition\r\n   * of what it returns. And since echarts5 it needs to be make compat work. So\r\n   * deprecates it since echarts5.\r\n   *\r\n   * By default, `visual` is applied to style (to support visualMap).\r\n   * `visual.color` is applied at `fill`. If user want apply visual.color on `stroke`,\r\n   * it can be implemented as:\r\n   * `api.style({stroke: api.visual('color'), fill: null})`;\r\n   *\r\n   * [Compat]: since ec5, RectText has been separated from its hosts el.\r\n   * so `api.style()` will only return the style from `itemStyle` but not handle `label`\r\n   * any more. But `series.label` config is never published in doc.\r\n   * We still compat it in `api.style()`. But not encourage to use it and will still not\r\n   * to pulish it to doc.\r\n   * @public\r\n   * @param dataIndexInside by default `currDataIndexInside`.\r\n   */\n  function style(userProps, dataIndexInside) {\n    if (false) {}\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n    var style = data.getItemVisual(dataIndexInside, 'style');\n    var visualColor = style && style.fill;\n    var opacity = style && style.opacity;\n    var itemStyle = getItemStyleModel(dataIndexInside, NORMAL).getItemStyle();\n    visualColor != null && (itemStyle.fill = visualColor);\n    opacity != null && (itemStyle.opacity = opacity);\n    var opt = {\n      inheritColor: (0,util.isString)(visualColor) ? visualColor : '#000'\n    };\n    var labelModel = getLabelModel(dataIndexInside, NORMAL);\n    // Now that the feature of \"auto adjust text fill/stroke\" has been migrated to zrender\n    // since ec5, we should set `isAttached` as `false` here and make compat in\n    // `convertToEC4StyleForCustomSerise`.\n    var textStyle = labelStyle/* createTextStyle */.VB(labelModel, null, opt, false, true);\n    textStyle.text = labelModel.getShallow('show') ? (0,util.retrieve2)(customSeries.getFormattedLabel(dataIndexInside, NORMAL), (0,labelHelper/* getDefaultLabel */.i)(data, dataIndexInside)) : null;\n    var textConfig = labelStyle/* createTextConfig */.sD(labelModel, opt, false);\n    preFetchFromExtra(userProps, itemStyle);\n    itemStyle = (0,styleCompat/* convertToEC4StyleForCustomSerise */.Fs)(itemStyle, textStyle, textConfig);\n    userProps && applyUserPropsAfter(itemStyle, userProps);\n    itemStyle.legacy = true;\n    return itemStyle;\n  }\n  /**\r\n   * @deprecated The reason see `api.style()`\r\n   * @public\r\n   * @param dataIndexInside by default `currDataIndexInside`.\r\n   */\n  function styleEmphasis(userProps, dataIndexInside) {\n    if (false) {}\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n    var itemStyle = getItemStyleModel(dataIndexInside, EMPHASIS).getItemStyle();\n    var labelModel = getLabelModel(dataIndexInside, EMPHASIS);\n    var textStyle = labelStyle/* createTextStyle */.VB(labelModel, null, null, true, true);\n    textStyle.text = labelModel.getShallow('show') ? (0,util.retrieve3)(customSeries.getFormattedLabel(dataIndexInside, EMPHASIS), customSeries.getFormattedLabel(dataIndexInside, NORMAL), (0,labelHelper/* getDefaultLabel */.i)(data, dataIndexInside)) : null;\n    var textConfig = labelStyle/* createTextConfig */.sD(labelModel, null, true);\n    preFetchFromExtra(userProps, itemStyle);\n    itemStyle = (0,styleCompat/* convertToEC4StyleForCustomSerise */.Fs)(itemStyle, textStyle, textConfig);\n    userProps && applyUserPropsAfter(itemStyle, userProps);\n    itemStyle.legacy = true;\n    return itemStyle;\n  }\n  function applyUserPropsAfter(itemStyle, extra) {\n    for (var key in extra) {\n      if ((0,util.hasOwn)(extra, key)) {\n        itemStyle[key] = extra[key];\n      }\n    }\n  }\n  function preFetchFromExtra(extra, itemStyle) {\n    // A trick to retrieve those props firstly, which are used to\n    // apply auto inside fill/stroke in `convertToEC4StyleForCustomSerise`.\n    // (It's not reasonable but only for a degree of compat)\n    if (extra) {\n      extra.textFill && (itemStyle.textFill = extra.textFill);\n      extra.textPosition && (itemStyle.textPosition = extra.textPosition);\n    }\n  }\n  /**\r\n   * @public\r\n   * @param dataIndexInside by default `currDataIndexInside`.\r\n   */\n  function visual(visualType, dataIndexInside) {\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n    if ((0,util.hasOwn)(STYLE_VISUAL_TYPE, visualType)) {\n      var style_1 = data.getItemVisual(dataIndexInside, 'style');\n      return style_1 ? style_1[STYLE_VISUAL_TYPE[visualType]] : null;\n    }\n    // Only support these visuals. Other visual might be inner tricky\n    // for performance (like `style`), do not expose to users.\n    if ((0,util.hasOwn)(NON_STYLE_VISUAL_PROPS, visualType)) {\n      return data.getItemVisual(dataIndexInside, visualType);\n    }\n  }\n  /**\r\n   * @public\r\n   * @return If not support, return undefined.\r\n   */\n  function barLayout(opt) {\n    if (coordSys.type === 'cartesian2d') {\n      var baseAxis = coordSys.getBaseAxis();\n      return (0,barGrid/* getLayoutOnAxis */.DL)((0,util.defaults)({\n        axis: baseAxis\n      }, opt));\n    }\n  }\n  /**\r\n   * @public\r\n   */\n  function currentSeriesIndices() {\n    return ecModel.getCurrentSeriesIndices();\n  }\n  /**\r\n   * @public\r\n   * @return font string\r\n   */\n  function font(opt) {\n    return labelStyle/* getFont */.c8(opt, ecModel);\n  }\n}\nfunction wrapEncodeDef(data) {\n  var encodeDef = {};\n  (0,util.each)(data.dimensions, function (dimName) {\n    var dimInfo = data.getDimensionInfo(dimName);\n    if (!dimInfo.isExtraCoord) {\n      var coordDim = dimInfo.coordDim;\n      var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];\n      dataDims[dimInfo.coordDimIndex] = data.getDimensionIndex(dimName);\n    }\n  });\n  return encodeDef;\n}\nfunction createOrUpdateItem(api, existsEl, dataIndex, elOption, seriesModel, group, data) {\n  // [Rule]\n  // If `renderItem` returns `null`/`undefined`/`false`, remove the previous el if existing.\n  //     (It seems that violate the \"merge\" principle, but most of users probably intuitively\n  //     regard \"return;\" as \"show nothing element whatever\", so make a exception to meet the\n  //     most cases.)\n  // The rule or \"merge\" see [STRATEGY_MERGE].\n  // If `elOption` is `null`/`undefined`/`false` (when `renderItem` returns nothing).\n  if (!elOption) {\n    group.remove(existsEl);\n    return;\n  }\n  var el = doCreateOrUpdateEl(api, existsEl, dataIndex, elOption, seriesModel, group);\n  el && data.setItemGraphicEl(dataIndex, el);\n  el && (0,states/* toggleHoverEmphasis */.Lm)(el, elOption.focus, elOption.blurScope, elOption.emphasisDisabled);\n  return el;\n}\nfunction doCreateOrUpdateEl(api, existsEl, dataIndex, elOption, seriesModel, group) {\n  if (false) {}\n  var toBeReplacedIdx = -1;\n  var oldEl = existsEl;\n  if (existsEl && doesElNeedRecreate(existsEl, elOption, seriesModel)\n  // || (\n  //     // PENDING: even in one-to-one mapping case, if el is marked as morph,\n  //     // do not sure whether the el will be mapped to another el with different\n  //     // hierarchy in Group tree. So always recreate el rather than reuse the el.\n  //     morphHelper && morphHelper.isOneToOneFrom(el)\n  // )\n  ) {\n    // Should keep at the original index, otherwise \"merge by index\" will be incorrect.\n    toBeReplacedIdx = (0,util.indexOf)(group.childrenRef(), existsEl);\n    existsEl = null;\n  }\n  var isInit = !existsEl;\n  var el = existsEl;\n  if (!el) {\n    el = createEl(elOption);\n    if (oldEl) {\n      copyElement(oldEl, el);\n    }\n  } else {\n    // FIMXE:NEXT unified clearState?\n    // If in some case the performance issue arised, consider\n    // do not clearState but update cached normal state directly.\n    el.clearStates();\n  }\n  // Need to set morph: false explictly to disable automatically morphing.\n  if (elOption.morph === false) {\n    el.disableMorphing = true;\n  } else if (el.disableMorphing) {\n    el.disableMorphing = false;\n  }\n  attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null;\n  attachedTxInfoTmp.isLegacy = false;\n  doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfoTmp);\n  doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit);\n  updateElNormal(api, el, dataIndex, elOption, attachedTxInfoTmp, seriesModel, isInit);\n  // `elOption.info` enables user to mount some info on\n  // elements and use them in event handlers.\n  // Update them only when user specified, otherwise, remain.\n  (0,util.hasOwn)(elOption, 'info') && (customInnerStore(el).info = elOption.info);\n  for (var i = 0; i < STATES.length; i++) {\n    var stateName = STATES[i];\n    if (stateName !== NORMAL) {\n      var otherStateOpt = retrieveStateOption(elOption, stateName);\n      var otherStyleOpt = retrieveStyleOptionOnState(elOption, otherStateOpt, stateName);\n      updateElOnState(stateName, el, otherStateOpt, otherStyleOpt, attachedTxInfoTmp);\n    }\n  }\n  updateZ(el, elOption, seriesModel);\n  if (elOption.type === 'group') {\n    mergeChildren(api, el, dataIndex, elOption, seriesModel);\n  }\n  if (toBeReplacedIdx >= 0) {\n    group.replaceAt(el, toBeReplacedIdx);\n  } else {\n    group.add(el);\n  }\n  return el;\n}\n// `el` must not be null/undefined.\nfunction doesElNeedRecreate(el, elOption, seriesModel) {\n  var elInner = customInnerStore(el);\n  var elOptionType = elOption.type;\n  var elOptionShape = elOption.shape;\n  var elOptionStyle = elOption.style;\n  return (\n    // Always create new if universal transition is enabled.\n    // Because we do transition after render. It needs to know what old element is. Replacement will loose it.\n    seriesModel.isUniversalTransitionEnabled()\n    // If `elOptionType` is `null`, follow the merge principle.\n    || elOptionType != null && elOptionType !== elInner.customGraphicType || elOptionType === 'path' && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== elInner.customPathData || elOptionType === 'image' && (0,util.hasOwn)(elOptionStyle, 'image') && elOptionStyle.image !== elInner.customImagePath\n    // // FIXME test and remove this restriction?\n    // || (elOptionType === 'text'\n    //     && hasOwn(elOptionStyle, 'text')\n    //     && (elOptionStyle as TextStyleProps).text !== elInner.customText\n    // )\n  );\n}\nfunction doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit) {\n  // Based on the \"merge\" principle, if no clipPath provided,\n  // do nothing. The exists clip will be totally removed only if\n  // `el.clipPath` is `false`. Otherwise it will be merged/replaced.\n  var clipPathOpt = elOption.clipPath;\n  if (clipPathOpt === false) {\n    if (el && el.getClipPath()) {\n      el.removeClipPath();\n    }\n  } else if (clipPathOpt) {\n    var clipPath = el.getClipPath();\n    if (clipPath && doesElNeedRecreate(clipPath, clipPathOpt, seriesModel)) {\n      clipPath = null;\n    }\n    if (!clipPath) {\n      clipPath = createEl(clipPathOpt);\n      if (false) {}\n      el.setClipPath(clipPath);\n    }\n    updateElNormal(null, clipPath, dataIndex, clipPathOpt, null, seriesModel, isInit);\n  }\n  // If not define `clipPath` in option, do nothing unnecessary.\n}\nfunction doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfo) {\n  // Group does not support textContent temporarily until necessary.\n  if (el.isGroup) {\n    return;\n  }\n  // Normal must be called before emphasis, for `isLegacy` detection.\n  processTxInfo(elOption, null, attachedTxInfo);\n  processTxInfo(elOption, EMPHASIS, attachedTxInfo);\n  // If `elOption.textConfig` or `elOption.textContent` is null/undefined, it does not make sense.\n  // So for simplicity, if \"elOption hasOwnProperty of them but be null/undefined\", we do not\n  // trade them as set to null to el.\n  // Especially:\n  // `elOption.textContent: false` means remove textContent.\n  // `elOption.textContent.emphasis.style: false` means remove the style from emphasis state.\n  var txConOptNormal = attachedTxInfo.normal.conOpt;\n  var txConOptEmphasis = attachedTxInfo.emphasis.conOpt;\n  var txConOptBlur = attachedTxInfo.blur.conOpt;\n  var txConOptSelect = attachedTxInfo.select.conOpt;\n  if (txConOptNormal != null || txConOptEmphasis != null || txConOptSelect != null || txConOptBlur != null) {\n    var textContent = el.getTextContent();\n    if (txConOptNormal === false) {\n      textContent && el.removeTextContent();\n    } else {\n      txConOptNormal = attachedTxInfo.normal.conOpt = txConOptNormal || {\n        type: 'text'\n      };\n      if (!textContent) {\n        textContent = createEl(txConOptNormal);\n        el.setTextContent(textContent);\n      } else {\n        // If in some case the performance issue arised, consider\n        // do not clearState but update cached normal state directly.\n        textContent.clearStates();\n      }\n      updateElNormal(null, textContent, dataIndex, txConOptNormal, null, seriesModel, isInit);\n      var txConStlOptNormal = txConOptNormal && txConOptNormal.style;\n      for (var i = 0; i < STATES.length; i++) {\n        var stateName = STATES[i];\n        if (stateName !== NORMAL) {\n          var txConOptOtherState = attachedTxInfo[stateName].conOpt;\n          updateElOnState(stateName, textContent, txConOptOtherState, retrieveStyleOptionOnState(txConOptNormal, txConOptOtherState, stateName), null);\n        }\n      }\n      txConStlOptNormal ? textContent.dirty() : textContent.markRedraw();\n    }\n  }\n}\nfunction processTxInfo(elOption, state, attachedTxInfo) {\n  var stateOpt = !state ? elOption : retrieveStateOption(elOption, state);\n  var styleOpt = !state ? elOption.style : retrieveStyleOptionOnState(elOption, stateOpt, EMPHASIS);\n  var elType = elOption.type;\n  var txCfg = stateOpt ? stateOpt.textConfig : null;\n  var txConOptNormal = elOption.textContent;\n  var txConOpt = !txConOptNormal ? null : !state ? txConOptNormal : retrieveStateOption(txConOptNormal, state);\n  if (styleOpt && (\n  // Because emphasis style has little info to detect legacy,\n  // if normal is legacy, emphasis is trade as legacy.\n  attachedTxInfo.isLegacy || (0,styleCompat/* isEC4CompatibleStyle */.ex)(styleOpt, elType, !!txCfg, !!txConOpt))) {\n    attachedTxInfo.isLegacy = true;\n    var convertResult = (0,styleCompat/* convertFromEC4CompatibleStyle */.lH)(styleOpt, elType, !state);\n    // Explicitly specified `textConfig` and `textContent` has higher priority than\n    // the ones generated by legacy style. Otherwise if users use them and `api.style`\n    // at the same time, they not both work and hardly to known why.\n    if (!txCfg && convertResult.textConfig) {\n      txCfg = convertResult.textConfig;\n    }\n    if (!txConOpt && convertResult.textContent) {\n      txConOpt = convertResult.textContent;\n    }\n  }\n  if (!state && txConOpt) {\n    var txConOptNormal_1 = txConOpt;\n    // `textContent: {type: 'text'}`, the \"type\" is easy to be missing. So we tolerate it.\n    !txConOptNormal_1.type && (txConOptNormal_1.type = 'text');\n    if (false) {}\n  }\n  var info = !state ? attachedTxInfo.normal : attachedTxInfo[state];\n  info.cfg = txCfg;\n  info.conOpt = txConOpt;\n}\nfunction retrieveStateOption(elOption, state) {\n  return !state ? elOption : elOption ? elOption[state] : null;\n}\nfunction retrieveStyleOptionOnState(stateOptionNormal, stateOption, state) {\n  var style = stateOption && stateOption.style;\n  if (style == null && state === EMPHASIS && stateOptionNormal) {\n    style = stateOptionNormal.styleEmphasis;\n  }\n  return style;\n}\n// Usage:\n// (1) By default, `elOption.$mergeChildren` is `'byIndex'`, which indicates\n//     that the existing children will not be removed, and enables the feature\n//     that update some of the props of some of the children simply by construct\n//     the returned children of `renderItem` like:\n//     `var children = group.children = []; children[3] = {opacity: 0.5};`\n// (2) If `elOption.$mergeChildren` is `'byName'`, add/update/remove children\n//     by child.name. But that might be lower performance.\n// (3) If `elOption.$mergeChildren` is `false`, the existing children will be\n//     replaced totally.\n// (4) If `!elOption.children`, following the \"merge\" principle, nothing will\n//     happen.\n// (5) If `elOption.$mergeChildren` is not `false` neither `'byName'` and the\n//     `el` is a group, and if any of the new child is null, it means to remove\n//     the element at the same index, if exists. On the other hand, if the new\n//     child is and empty object `{}`, it means to keep the element not changed.\n//\n// For implementation simpleness, do not provide a direct way to remove single\n// child (otherwise the total indices of the children array have to be modified).\n// User can remove a single child by setting its `ignore` to `true`.\nfunction mergeChildren(api, el, dataIndex, elOption, seriesModel) {\n  var newChildren = elOption.children;\n  var newLen = newChildren ? newChildren.length : 0;\n  var mergeChildren = elOption.$mergeChildren;\n  // `diffChildrenByName` has been deprecated.\n  var byName = mergeChildren === 'byName' || elOption.diffChildrenByName;\n  var notMerge = mergeChildren === false;\n  // For better performance on roam update, only enter if necessary.\n  if (!newLen && !byName && !notMerge) {\n    return;\n  }\n  if (byName) {\n    diffGroupChildren({\n      api: api,\n      oldChildren: el.children() || [],\n      newChildren: newChildren || [],\n      dataIndex: dataIndex,\n      seriesModel: seriesModel,\n      group: el\n    });\n    return;\n  }\n  notMerge && el.removeAll();\n  // Mapping children of a group simply by index, which\n  // might be better performance.\n  var index = 0;\n  for (; index < newLen; index++) {\n    var newChild = newChildren[index];\n    var oldChild = el.childAt(index);\n    if (newChild) {\n      if (newChild.ignore == null) {\n        // The old child is set to be ignored if null (see comments\n        // below). So we need to set ignore to be false back.\n        newChild.ignore = false;\n      }\n      doCreateOrUpdateEl(api, oldChild, dataIndex, newChild, seriesModel, el);\n    } else {\n      if (false) {}\n      // If the new element option is null, it means to remove the old\n      // element. But we cannot really remove the element from the group\n      // directly, because the element order may not be stable when this\n      // element is added back. So we set the element to be ignored.\n      oldChild.ignore = true;\n    }\n  }\n  for (var i = el.childCount() - 1; i >= index; i--) {\n    var child = el.childAt(i);\n    removeChildFromGroup(el, child, seriesModel);\n  }\n}\nfunction removeChildFromGroup(group, child, seriesModel) {\n  // Do not support leave elements that are not mentioned in the latest\n  // `renderItem` return. Otherwise users may not have a clear and simple\n  // concept that how to control all of the elements.\n  child && (0,customGraphicTransition/* applyLeaveTransition */.h8)(child, customInnerStore(group).option, seriesModel);\n}\nfunction diffGroupChildren(context) {\n  new DataDiffer/* default */.A(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();\n}\nfunction getKey(item, idx) {\n  var name = item && item.name;\n  return name != null ? name : GROUP_DIFF_PREFIX + idx;\n}\nfunction processAddUpdate(newIndex, oldIndex) {\n  var context = this.context;\n  var childOption = newIndex != null ? context.newChildren[newIndex] : null;\n  var child = oldIndex != null ? context.oldChildren[oldIndex] : null;\n  doCreateOrUpdateEl(context.api, child, context.dataIndex, childOption, context.seriesModel, context.group);\n}\nfunction processRemove(oldIndex) {\n  var context = this.context;\n  var child = context.oldChildren[oldIndex];\n  child && (0,customGraphicTransition/* applyLeaveTransition */.h8)(child, customInnerStore(child).option, context.seriesModel);\n}\n/**\r\n * @return SVG Path data.\r\n */\nfunction getPathData(shape) {\n  // \"d\" follows the SVG convention.\n  return shape && (shape.pathData || shape.d);\n}\nfunction hasOwnPathData(shape) {\n  return shape && ((0,util.hasOwn)(shape, 'pathData') || (0,util.hasOwn)(shape, 'd'));\n}\n;// ./node_modules/echarts/lib/chart/custom/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction install(registers) {\n  registers.registerChartView(CustomView);\n  registers.registerSeriesModel(CustomSeries);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcyODguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzE1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvY3VzdG9tL0N1c3RvbVNlcmllcy5qcz8zMTIxIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9jdXN0b20vQ3VzdG9tVmlldy5qcz83NmY1Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9jdXN0b20vaW5zdGFsbC5qcz9hNDMyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgY3JlYXRlU2VyaWVzRGF0YSBmcm9tICcuLi9oZWxwZXIvY3JlYXRlU2VyaWVzRGF0YS5qcyc7XG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMuanMnO1xuLy8gQWxzbyBjb21wYXQgd2l0aCBlYzQsIHdoZXJlXG4vLyBgdmlzdWFsKCdjb2xvcicpIHZpc3VhbCgnYm9yZGVyQ29sb3InKWAgaXMgc3VwcG9ydGVkLlxuZXhwb3J0IHZhciBTVFlMRV9WSVNVQUxfVFlQRSA9IHtcbiAgY29sb3I6ICdmaWxsJyxcbiAgYm9yZGVyQ29sb3I6ICdzdHJva2UnXG59O1xuZXhwb3J0IHZhciBOT05fU1RZTEVfVklTVUFMX1BST1BTID0ge1xuICBzeW1ib2w6IDEsXG4gIHN5bWJvbFNpemU6IDEsXG4gIHN5bWJvbEtlZXBBc3BlY3Q6IDEsXG4gIGxlZ2VuZEljb246IDEsXG4gIHZpc3VhbE1ldGE6IDEsXG4gIGxpZnRaOiAxLFxuICBkZWNhbDogMVxufTtcbjtcbmV4cG9ydCB2YXIgY3VzdG9tSW5uZXJTdG9yZSA9IG1ha2VJbm5lcigpO1xudmFyIEN1c3RvbVNlcmllc01vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEN1c3RvbVNlcmllc01vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBDdXN0b21TZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gQ3VzdG9tU2VyaWVzTW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgQ3VzdG9tU2VyaWVzTW9kZWwucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdXJyZW50WkxldmVsID0gdGhpcy5nZXQoJ3psZXZlbCcsIHRydWUpO1xuICAgIHRoaXMuY3VycmVudFogPSB0aGlzLmdldCgneicsIHRydWUpO1xuICB9O1xuICBDdXN0b21TZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGEgPSBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVNlcmllc0RhdGEobnVsbCwgdGhpcyk7XG4gIH07XG4gIEN1c3RvbVNlcmllc01vZGVsLnByb3RvdHlwZS5nZXREYXRhUGFyYW1zID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgZGF0YVR5cGUsIGVsKSB7XG4gICAgdmFyIHBhcmFtcyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0RGF0YVBhcmFtcy5jYWxsKHRoaXMsIGRhdGFJbmRleCwgZGF0YVR5cGUpO1xuICAgIGVsICYmIChwYXJhbXMuaW5mbyA9IGN1c3RvbUlubmVyU3RvcmUoZWwpLmluZm8pO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH07XG4gIEN1c3RvbVNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLmN1c3RvbSc7XG4gIEN1c3RvbVNlcmllc01vZGVsLmRlcGVuZGVuY2llcyA9IFsnZ3JpZCcsICdwb2xhcicsICdnZW8nLCAnc2luZ2xlQXhpcycsICdjYWxlbmRhciddO1xuICBDdXN0b21TZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdjYXJ0ZXNpYW4yZCcsXG4gICAgLy8gemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIC8vIEN1c3RvbSBzZXJpZXMgd2lsbCBub3QgY2xpcCBieSBkZWZhdWx0LlxuICAgIC8vIFNvbWUgY2FzZSB3aWxsIHVzZSBjdXN0b20gc2VyaWVzIHRvIGRyYXcgbGFiZWxcbiAgICAvLyBGb3IgZXhhbXBsZSBodHRwczovL2VjaGFydHMuYXBhY2hlLm9yZy9leGFtcGxlcy9lbi9lZGl0b3IuaHRtbD9jPWN1c3RvbS1nYW50dC1mbGlnaHRcbiAgICBjbGlwOiBmYWxzZVxuICAgIC8vIENhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbVxuICAgIC8vIHhBeGlzSW5kZXg6IDAsXG4gICAgLy8geUF4aXNJbmRleDogMCxcbiAgICAvLyBQb2xhciBjb29yZGluYXRlIHN5c3RlbVxuICAgIC8vIHBvbGFySW5kZXg6IDAsXG4gICAgLy8gR2VvIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgLy8gZ2VvSW5kZXg6IDAsXG4gIH07XG4gIHJldHVybiBDdXN0b21TZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuZXhwb3J0IGRlZmF1bHQgQ3VzdG9tU2VyaWVzTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGhhc093biwgYXNzZXJ0LCBpc1N0cmluZywgcmV0cmlldmUyLCByZXRyaWV2ZTMsIGRlZmF1bHRzLCBlYWNoLCBpbmRleE9mIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIGdyYXBoaWNVdGlsIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBzZXREZWZhdWx0U3RhdGVQcm94eSwgdG9nZ2xlSG92ZXJFbXBoYXNpcyB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdGVzLmpzJztcbmltcG9ydCAqIGFzIGxhYmVsU3R5bGVIZWxwZXIgZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG5pbXBvcnQgeyBnZXREZWZhdWx0TGFiZWwgfSBmcm9tICcuLi9oZWxwZXIvbGFiZWxIZWxwZXIuanMnO1xuaW1wb3J0IHsgZ2V0TGF5b3V0T25BeGlzIH0gZnJvbSAnLi4vLi4vbGF5b3V0L2JhckdyaWQuanMnO1xuaW1wb3J0IERhdGFEaWZmZXIgZnJvbSAnLi4vLi4vZGF0YS9EYXRhRGlmZmVyLmpzJztcbmltcG9ydCBDaGFydFZpZXcgZnJvbSAnLi4vLi4vdmlldy9DaGFydC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDbGlwUGF0aCB9IGZyb20gJy4uL2hlbHBlci9jcmVhdGVDbGlwUGF0aEZyb21Db29yZFN5cy5qcyc7XG5pbXBvcnQgcHJlcGFyZUNhcnRlc2lhbjJkIGZyb20gJy4uLy4uL2Nvb3JkL2NhcnRlc2lhbi9wcmVwYXJlQ3VzdG9tLmpzJztcbmltcG9ydCBwcmVwYXJlR2VvIGZyb20gJy4uLy4uL2Nvb3JkL2dlby9wcmVwYXJlQ3VzdG9tLmpzJztcbmltcG9ydCBwcmVwYXJlU2luZ2xlQXhpcyBmcm9tICcuLi8uLi9jb29yZC9zaW5nbGUvcHJlcGFyZUN1c3RvbS5qcyc7XG5pbXBvcnQgcHJlcGFyZVBvbGFyIGZyb20gJy4uLy4uL2Nvb3JkL3BvbGFyL3ByZXBhcmVDdXN0b20uanMnO1xuaW1wb3J0IHByZXBhcmVDYWxlbmRhciBmcm9tICcuLi8uLi9jb29yZC9jYWxlbmRhci9wcmVwYXJlQ3VzdG9tLmpzJztcbmltcG9ydCBEaXNwbGF5YWJsZSBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL0Rpc3BsYXlhYmxlLmpzJztcbmltcG9ydCB7IGNvbnZlcnRUb0VDNFN0eWxlRm9yQ3VzdG9tU2VyaXNlLCBpc0VDNENvbXBhdGlibGVTdHlsZSwgY29udmVydEZyb21FQzRDb21wYXRpYmxlU3R5bGUsIHdhcm5EZXByZWNhdGVkIH0gZnJvbSAnLi4vLi4vdXRpbC9zdHlsZUNvbXBhdC5qcyc7XG5pbXBvcnQgeyB0aHJvd0Vycm9yIH0gZnJvbSAnLi4vLi4vdXRpbC9sb2cuanMnO1xuaW1wb3J0IHsgY3JlYXRlT3JVcGRhdGVQYXR0ZXJuRnJvbURlY2FsIH0gZnJvbSAnLi4vLi4vdXRpbC9kZWNhbC5qcyc7XG5pbXBvcnQgeyBTVFlMRV9WSVNVQUxfVFlQRSwgTk9OX1NUWUxFX1ZJU1VBTF9QUk9QUywgY3VzdG9tSW5uZXJTdG9yZSB9IGZyb20gJy4vQ3VzdG9tU2VyaWVzLmpzJztcbmltcG9ydCB7IGFwcGx5TGVhdmVUcmFuc2l0aW9uLCBhcHBseVVwZGF0ZVRyYW5zaXRpb24gfSBmcm9tICcuLi8uLi9hbmltYXRpb24vY3VzdG9tR3JhcGhpY1RyYW5zaXRpb24uanMnO1xuaW1wb3J0IHsgYXBwbHlLZXlmcmFtZUFuaW1hdGlvbiwgc3RvcFByZXZpb3VzS2V5ZnJhbWVBbmltYXRpb25BbmRSZXN0b3JlIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL2N1c3RvbUdyYXBoaWNLZXlmcmFtZUFuaW1hdGlvbi5qcyc7XG52YXIgRU1QSEFTSVMgPSAnZW1waGFzaXMnO1xudmFyIE5PUk1BTCA9ICdub3JtYWwnO1xudmFyIEJMVVIgPSAnYmx1cic7XG52YXIgU0VMRUNUID0gJ3NlbGVjdCc7XG52YXIgU1RBVEVTID0gW05PUk1BTCwgRU1QSEFTSVMsIEJMVVIsIFNFTEVDVF07XG52YXIgUEFUSF9JVEVNX1NUWUxFID0ge1xuICBub3JtYWw6IFsnaXRlbVN0eWxlJ10sXG4gIGVtcGhhc2lzOiBbRU1QSEFTSVMsICdpdGVtU3R5bGUnXSxcbiAgYmx1cjogW0JMVVIsICdpdGVtU3R5bGUnXSxcbiAgc2VsZWN0OiBbU0VMRUNULCAnaXRlbVN0eWxlJ11cbn07XG52YXIgUEFUSF9MQUJFTCA9IHtcbiAgbm9ybWFsOiBbJ2xhYmVsJ10sXG4gIGVtcGhhc2lzOiBbRU1QSEFTSVMsICdsYWJlbCddLFxuICBibHVyOiBbQkxVUiwgJ2xhYmVsJ10sXG4gIHNlbGVjdDogW1NFTEVDVCwgJ2xhYmVsJ11cbn07XG52YXIgREVGQVVMVF9UUkFOU0lUSU9OID0gWyd4JywgJ3knXTtcbi8vIFVzZSBwcmVmaXggdG8gYXZvaWQgaW5kZXggdG8gYmUgdGhlIHNhbWUgYXMgZWwubmFtZSxcbi8vIHdoaWNoIHdpbGwgY2F1c2Ugd2VpcmQgdXBkYXRlIGFuaW1hdGlvbi5cbnZhciBHUk9VUF9ESUZGX1BSRUZJWCA9ICdlXFwwXFwwJztcbnZhciBhdHRhY2hlZFR4SW5mb1RtcCA9IHtcbiAgbm9ybWFsOiB7fSxcbiAgZW1waGFzaXM6IHt9LFxuICBibHVyOiB7fSxcbiAgc2VsZWN0OiB7fVxufTtcbi8qKlxyXG4gKiBUbyByZWR1Y2UgdG90YWwgcGFja2FnZSBzaXplIG9mIGVhY2ggY29vcmRpbmF0ZSBzeXN0ZW1zLCB0aGUgbW9kdWxlcyBgcHJlcGFyZUN1c3RvbWBcclxuICogb2YgZWFjaCBjb29yZGluYXRlIHN5c3RlbXMgYXJlIG5vdCByZXF1aXJlZCBieSBlYWNoIGNvb3JkaW5hdGUgc3lzdGVtcyBkaXJlY3RseSwgYnV0XHJcbiAqIHJlcXVpcmVkIGJ5IHRoZSBtb2R1bGUgYGN1c3RvbWAuXHJcbiAqXHJcbiAqIHByZXBhcmVJbmZvRm9yQ3VzdG9tU2VyaWVzIHtGdW5jdGlvbn06IG9wdGlvbmFsXHJcbiAqICAgICBAcmV0dXJuIHtPYmplY3R9IHtjb29yZFN5czogey4uLn0sIGFwaToge1xyXG4gKiAgICAgICAgIGNvb3JkOiBmdW5jdGlvbiAoZGF0YSwgY2xhbXApIHt9LCAvLyByZXR1cm4gcG9pbnQgaW4gZ2xvYmFsLlxyXG4gKiAgICAgICAgIHNpemU6IGZ1bmN0aW9uIChkYXRhU2l6ZSwgZGF0YUl0ZW0pIHt9IC8vIHJldHVybiBzaXplIG9mIGVhY2ggYXhpcyBpbiBjb29yZFN5cy5cclxuICogICAgIH19XHJcbiAqL1xudmFyIHByZXBhcmVDdXN0b21zID0ge1xuICBjYXJ0ZXNpYW4yZDogcHJlcGFyZUNhcnRlc2lhbjJkLFxuICBnZW86IHByZXBhcmVHZW8sXG4gIHNpbmdsZTogcHJlcGFyZVNpbmdsZUF4aXMsXG4gIHBvbGFyOiBwcmVwYXJlUG9sYXIsXG4gIGNhbGVuZGFyOiBwcmVwYXJlQ2FsZW5kYXJcbn07XG5mdW5jdGlvbiBpc1BhdGgoZWwpIHtcbiAgcmV0dXJuIGVsIGluc3RhbmNlb2YgZ3JhcGhpY1V0aWwuUGF0aDtcbn1cbmZ1bmN0aW9uIGlzRGlzcGxheWFibGUoZWwpIHtcbiAgcmV0dXJuIGVsIGluc3RhbmNlb2YgRGlzcGxheWFibGU7XG59XG5mdW5jdGlvbiBjb3B5RWxlbWVudChzb3VyY2VFbCwgdGFyZ2V0RWwpIHtcbiAgdGFyZ2V0RWwuY29weVRyYW5zZm9ybShzb3VyY2VFbCk7XG4gIGlmIChpc0Rpc3BsYXlhYmxlKHRhcmdldEVsKSAmJiBpc0Rpc3BsYXlhYmxlKHNvdXJjZUVsKSkge1xuICAgIHRhcmdldEVsLnNldFN0eWxlKHNvdXJjZUVsLnN0eWxlKTtcbiAgICB0YXJnZXRFbC56ID0gc291cmNlRWwuejtcbiAgICB0YXJnZXRFbC56MiA9IHNvdXJjZUVsLnoyO1xuICAgIHRhcmdldEVsLnpsZXZlbCA9IHNvdXJjZUVsLnpsZXZlbDtcbiAgICB0YXJnZXRFbC5pbnZpc2libGUgPSBzb3VyY2VFbC5pbnZpc2libGU7XG4gICAgdGFyZ2V0RWwuaWdub3JlID0gc291cmNlRWwuaWdub3JlO1xuICAgIGlmIChpc1BhdGgodGFyZ2V0RWwpICYmIGlzUGF0aChzb3VyY2VFbCkpIHtcbiAgICAgIHRhcmdldEVsLnNldFNoYXBlKHNvdXJjZUVsLnNoYXBlKTtcbiAgICB9XG4gIH1cbn1cbnZhciBDdXN0b21DaGFydFZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ3VzdG9tQ2hhcnRWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBDdXN0b21DaGFydFZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IEN1c3RvbUNoYXJ0Vmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBDdXN0b21DaGFydFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjdXN0b21TZXJpZXMsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIC8vIENsZWFyIHByZXZpb3VzbHkgcmVuZGVyZWQgcHJvZ3Jlc3NpdmUgZWxlbWVudHMuXG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVFbHMgPSBudWxsO1xuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgZGF0YSA9IGN1c3RvbVNlcmllcy5nZXREYXRhKCk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgcmVuZGVySXRlbSA9IG1ha2VSZW5kZXJJdGVtKGN1c3RvbVNlcmllcywgZGF0YSwgZWNNb2RlbCwgYXBpKTtcbiAgICBpZiAoIW9sZERhdGEpIHtcbiAgICAgIC8vIFByZXZpb3VzIHJlbmRlciBpcyBpbmNyZW1lbnRhbCByZW5kZXIgb3IgZmlyc3QgcmVuZGVyLlxuICAgICAgLy8gTmVlZHMgcmVtb3ZlIHRoZSBpbmNyZW1lbnRhbCByZW5kZXJlZCBlbGVtZW50cy5cbiAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIH1cbiAgICBkYXRhLmRpZmYob2xkRGF0YSkuYWRkKGZ1bmN0aW9uIChuZXdJZHgpIHtcbiAgICAgIGNyZWF0ZU9yVXBkYXRlSXRlbShhcGksIG51bGwsIG5ld0lkeCwgcmVuZGVySXRlbShuZXdJZHgsIHBheWxvYWQpLCBjdXN0b21TZXJpZXMsIGdyb3VwLCBkYXRhKTtcbiAgICB9KS5yZW1vdmUoZnVuY3Rpb24gKG9sZElkeCkge1xuICAgICAgdmFyIGVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICBlbCAmJiBhcHBseUxlYXZlVHJhbnNpdGlvbihlbCwgY3VzdG9tSW5uZXJTdG9yZShlbCkub3B0aW9uLCBjdXN0b21TZXJpZXMpO1xuICAgIH0pLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICAgIHZhciBvbGRFbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuICAgICAgY3JlYXRlT3JVcGRhdGVJdGVtKGFwaSwgb2xkRWwsIG5ld0lkeCwgcmVuZGVySXRlbShuZXdJZHgsIHBheWxvYWQpLCBjdXN0b21TZXJpZXMsIGdyb3VwLCBkYXRhKTtcbiAgICB9KS5leGVjdXRlKCk7XG4gICAgLy8gRG8gY2xpcHBpbmdcbiAgICB2YXIgY2xpcFBhdGggPSBjdXN0b21TZXJpZXMuZ2V0KCdjbGlwJywgdHJ1ZSkgPyBjcmVhdGVDbGlwUGF0aChjdXN0b21TZXJpZXMuY29vcmRpbmF0ZVN5c3RlbSwgZmFsc2UsIGN1c3RvbVNlcmllcykgOiBudWxsO1xuICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgZ3JvdXAuc2V0Q2xpcFBhdGgoY2xpcFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cC5yZW1vdmVDbGlwUGF0aCgpO1xuICAgIH1cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfTtcbiAgQ3VzdG9tQ2hhcnRWaWV3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFByZXBhcmVSZW5kZXIgPSBmdW5jdGlvbiAoY3VzdG9tU2VyaWVzLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICB9O1xuICBDdXN0b21DaGFydFZpZXcucHJvdG90eXBlLmluY3JlbWVudGFsUmVuZGVyID0gZnVuY3Rpb24gKHBhcmFtcywgY3VzdG9tU2VyaWVzLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgZGF0YSA9IGN1c3RvbVNlcmllcy5nZXREYXRhKCk7XG4gICAgdmFyIHJlbmRlckl0ZW0gPSBtYWtlUmVuZGVySXRlbShjdXN0b21TZXJpZXMsIGRhdGEsIGVjTW9kZWwsIGFwaSk7XG4gICAgdmFyIHByb2dyZXNzaXZlRWxzID0gdGhpcy5fcHJvZ3Jlc3NpdmVFbHMgPSBbXTtcbiAgICBmdW5jdGlvbiBzZXRJbmNyZW1lbnRhbEFuZEhvdmVyTGF5ZXIoZWwpIHtcbiAgICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgICBlbC5pbmNyZW1lbnRhbCA9IHRydWU7XG4gICAgICAgIGVsLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpLmhvdmVyTGF5ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpZHggPSBwYXJhbXMuc3RhcnQ7IGlkeCA8IHBhcmFtcy5lbmQ7IGlkeCsrKSB7XG4gICAgICB2YXIgZWwgPSBjcmVhdGVPclVwZGF0ZUl0ZW0obnVsbCwgbnVsbCwgaWR4LCByZW5kZXJJdGVtKGlkeCwgcGF5bG9hZCksIGN1c3RvbVNlcmllcywgdGhpcy5ncm91cCwgZGF0YSk7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgZWwudHJhdmVyc2Uoc2V0SW5jcmVtZW50YWxBbmRIb3ZlckxheWVyKTtcbiAgICAgICAgcHJvZ3Jlc3NpdmVFbHMucHVzaChlbCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBDdXN0b21DaGFydFZpZXcucHJvdG90eXBlLmVhY2hSZW5kZXJlZCA9IGZ1bmN0aW9uIChjYikge1xuICAgIGdyYXBoaWNVdGlsLnRyYXZlcnNlRWxlbWVudHModGhpcy5fcHJvZ3Jlc3NpdmVFbHMgfHwgdGhpcy5ncm91cCwgY2IpO1xuICB9O1xuICBDdXN0b21DaGFydFZpZXcucHJvdG90eXBlLmZpbHRlckZvckV4cG9zZWRFdmVudCA9IGZ1bmN0aW9uIChldmVudFR5cGUsIHF1ZXJ5LCB0YXJnZXRFbCwgcGFja2VkRXZlbnQpIHtcbiAgICB2YXIgZWxlbWVudE5hbWUgPSBxdWVyeS5lbGVtZW50O1xuICAgIGlmIChlbGVtZW50TmFtZSA9PSBudWxsIHx8IHRhcmdldEVsLm5hbWUgPT09IGVsZW1lbnROYW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRW5hYmxlIHRvIGdpdmUgYSBuYW1lIG9uIGEgZ3JvdXAgbWFkZSBieSBgcmVuZGVySXRlbWAsIGFuZCBsaXN0ZW5cbiAgICAvLyBldmVudHMgdGhhdCBhcmUgdHJpZ2dlcmVkIGJ5IGl0cyBkZXNjZW5kZW50cy5cbiAgICB3aGlsZSAoKHRhcmdldEVsID0gdGFyZ2V0RWwuX19ob3N0VGFyZ2V0IHx8IHRhcmdldEVsLnBhcmVudCkgJiYgdGFyZ2V0RWwgIT09IHRoaXMuZ3JvdXApIHtcbiAgICAgIGlmICh0YXJnZXRFbC5uYW1lID09PSBlbGVtZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBDdXN0b21DaGFydFZpZXcudHlwZSA9ICdjdXN0b20nO1xuICByZXR1cm4gQ3VzdG9tQ2hhcnRWaWV3O1xufShDaGFydFZpZXcpO1xuZXhwb3J0IGRlZmF1bHQgQ3VzdG9tQ2hhcnRWaWV3O1xuZnVuY3Rpb24gY3JlYXRlRWwoZWxPcHRpb24pIHtcbiAgdmFyIGdyYXBoaWNUeXBlID0gZWxPcHRpb24udHlwZTtcbiAgdmFyIGVsO1xuICAvLyBUaG9zZSBncmFwaGljIGVsZW1lbnRzIGFyZSBub3Qgc2hhcGVzLiBUaGV5IHNob3VsZCBub3QgYmVcbiAgLy8gb3ZlcndyaXR0ZW4gYnkgdXNlcnMsIHNvIGRvIHRoZW0gZmlyc3QuXG4gIGlmIChncmFwaGljVHlwZSA9PT0gJ3BhdGgnKSB7XG4gICAgdmFyIHNoYXBlID0gZWxPcHRpb24uc2hhcGU7XG4gICAgLy8gVXNpbmcgcGF0aFJlY3QgYnJpbmdzIGNvbnZlbmllbmNlIHRvIHVzZXJzIHNhY2xlIHN2ZyBwYXRoLlxuICAgIHZhciBwYXRoUmVjdCA9IHNoYXBlLndpZHRoICE9IG51bGwgJiYgc2hhcGUuaGVpZ2h0ICE9IG51bGwgPyB7XG4gICAgICB4OiBzaGFwZS54IHx8IDAsXG4gICAgICB5OiBzaGFwZS55IHx8IDAsXG4gICAgICB3aWR0aDogc2hhcGUud2lkdGgsXG4gICAgICBoZWlnaHQ6IHNoYXBlLmhlaWdodFxuICAgIH0gOiBudWxsO1xuICAgIHZhciBwYXRoRGF0YSA9IGdldFBhdGhEYXRhKHNoYXBlKTtcbiAgICAvLyBQYXRoIGlzIGFsc28gdXNlZCBmb3IgaWNvbiwgc28gbGF5b3V0ICdjZW50ZXInIGJ5IGRlZmF1bHQuXG4gICAgZWwgPSBncmFwaGljVXRpbC5tYWtlUGF0aChwYXRoRGF0YSwgbnVsbCwgcGF0aFJlY3QsIHNoYXBlLmxheW91dCB8fCAnY2VudGVyJyk7XG4gICAgY3VzdG9tSW5uZXJTdG9yZShlbCkuY3VzdG9tUGF0aERhdGEgPSBwYXRoRGF0YTtcbiAgfSBlbHNlIGlmIChncmFwaGljVHlwZSA9PT0gJ2ltYWdlJykge1xuICAgIGVsID0gbmV3IGdyYXBoaWNVdGlsLkltYWdlKHt9KTtcbiAgICBjdXN0b21Jbm5lclN0b3JlKGVsKS5jdXN0b21JbWFnZVBhdGggPSBlbE9wdGlvbi5zdHlsZS5pbWFnZTtcbiAgfSBlbHNlIGlmIChncmFwaGljVHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgZWwgPSBuZXcgZ3JhcGhpY1V0aWwuVGV4dCh7fSk7XG4gICAgLy8gY3VzdG9tSW5uZXJTdG9yZShlbCkuY3VzdG9tVGV4dCA9IChlbE9wdGlvbi5zdHlsZSBhcyBUZXh0U3R5bGVQcm9wcykudGV4dDtcbiAgfSBlbHNlIGlmIChncmFwaGljVHlwZSA9PT0gJ2dyb3VwJykge1xuICAgIGVsID0gbmV3IGdyYXBoaWNVdGlsLkdyb3VwKCk7XG4gIH0gZWxzZSBpZiAoZ3JhcGhpY1R5cGUgPT09ICdjb21wb3VuZFBhdGgnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImNvbXBvdW5kUGF0aFwiIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LicpO1xuICB9IGVsc2Uge1xuICAgIHZhciBDbHogPSBncmFwaGljVXRpbC5nZXRTaGFwZUNsYXNzKGdyYXBoaWNUeXBlKTtcbiAgICBpZiAoIUNseikge1xuICAgICAgdmFyIGVyck1zZyA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyTXNnID0gJ2dyYXBoaWMgdHlwZSBcIicgKyBncmFwaGljVHlwZSArICdcIiBjYW4gbm90IGJlIGZvdW5kLic7XG4gICAgICB9XG4gICAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gICAgfVxuICAgIGVsID0gbmV3IENseigpO1xuICB9XG4gIGN1c3RvbUlubmVyU3RvcmUoZWwpLmN1c3RvbUdyYXBoaWNUeXBlID0gZ3JhcGhpY1R5cGU7XG4gIGVsLm5hbWUgPSBlbE9wdGlvbi5uYW1lO1xuICAvLyBDb21wYXQgZWM0OiB0aGUgZGVmYXVsdCB6MiBsaWZ0IGlzIDEuIElmIGNoYW5naW5nIHRoZSBudW1iZXIsXG4gIC8vIHNvbWUgY2FzZXMgcHJvYmFibHkgYmUgYnJva2VuOiBoaWVyYXJjaHkgbGF5b3V0IGFsb25nIHosIGxpa2UgY2lyY2xlIHBhY2tpbmcsXG4gIC8vIHdoZXJlIGVtcGhhc2lzIG9ubHkgaW50ZW5kaW5nIHRvIG1vZGlmeSBjb2xvci9ib3JkZXIgcmF0aGVyIHRoYW4gbGlmdCB6Mi5cbiAgZWwuejJFbXBoYXNpc0xpZnQgPSAxO1xuICBlbC56MlNlbGVjdExpZnQgPSAxO1xuICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiB1cGRhdGVFbE5vcm1hbChcbi8vIENhbiBiZSBudWxsL3VuZGVmaW5lZFxuYXBpLCBlbCwgZGF0YUluZGV4LCBlbE9wdGlvbiwgYXR0YWNoZWRUeEluZm8sIHNlcmllc01vZGVsLCBpc0luaXQpIHtcbiAgLy8gU3RvcCBhbmQgcmVzdG9yZSBiZWZvcmUgdXBkYXRlIGFueSBvdGhlciBhdHRyaWJ1dGVzLlxuICBzdG9wUHJldmlvdXNLZXlmcmFtZUFuaW1hdGlvbkFuZFJlc3RvcmUoZWwpO1xuICB2YXIgdHhDZmdPcHQgPSBhdHRhY2hlZFR4SW5mbyAmJiBhdHRhY2hlZFR4SW5mby5ub3JtYWwuY2ZnO1xuICBpZiAodHhDZmdPcHQpIHtcbiAgICAvLyBQRU5ESU5HOiB3aGV0aGVyIHVzZSB1c2VyIG9iamVjdCBkaXJlY3RseSByYXRoZXIgdGhhbiBjbG9uZT9cbiAgICAvLyBUT0RPOjUuMCB0ZXh0Q29uZmlnIHRyYW5zaXRpb24gYW5pbWF0aW9uP1xuICAgIGVsLnNldFRleHRDb25maWcodHhDZmdPcHQpO1xuICB9XG4gIC8vIERlZmF1bHQgdHJhbnNpdGlvbiBbJ3gnLCAneSddXG4gIGlmIChlbE9wdGlvbiAmJiBlbE9wdGlvbi50cmFuc2l0aW9uID09IG51bGwpIHtcbiAgICBlbE9wdGlvbi50cmFuc2l0aW9uID0gREVGQVVMVF9UUkFOU0lUSU9OO1xuICB9XG4gIC8vIERvIHNvbWUgbm9ybWFsaXphdGlvbiBvbiBzdHlsZS5cbiAgdmFyIHN0eWxlT3B0ID0gZWxPcHRpb24gJiYgZWxPcHRpb24uc3R5bGU7XG4gIGlmIChzdHlsZU9wdCkge1xuICAgIGlmIChlbC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHZhciB0ZXh0T3B0aW9uU3R5bGUgPSBzdHlsZU9wdDtcbiAgICAgIC8vIENvbXBhdGlibGUgd2l0aCBlYzQ6IGlmIGB0ZXh0RmlsbGAgb3IgYHRleHRTdHJva2VgIGV4aXN0cyB1c2UgdGhlbS5cbiAgICAgIGhhc093bih0ZXh0T3B0aW9uU3R5bGUsICd0ZXh0RmlsbCcpICYmICh0ZXh0T3B0aW9uU3R5bGUuZmlsbCA9IHRleHRPcHRpb25TdHlsZS50ZXh0RmlsbCk7XG4gICAgICBoYXNPd24odGV4dE9wdGlvblN0eWxlLCAndGV4dFN0cm9rZScpICYmICh0ZXh0T3B0aW9uU3R5bGUuc3Ryb2tlID0gdGV4dE9wdGlvblN0eWxlLnRleHRTdHJva2UpO1xuICAgIH1cbiAgICB2YXIgZGVjYWxQYXR0ZXJuID0gdm9pZCAwO1xuICAgIHZhciBkZWNhbE9iaiA9IGlzUGF0aChlbCkgPyBzdHlsZU9wdC5kZWNhbCA6IG51bGw7XG4gICAgaWYgKGFwaSAmJiBkZWNhbE9iaikge1xuICAgICAgZGVjYWxPYmouZGlydHkgPSB0cnVlO1xuICAgICAgZGVjYWxQYXR0ZXJuID0gY3JlYXRlT3JVcGRhdGVQYXR0ZXJuRnJvbURlY2FsKGRlY2FsT2JqLCBhcGkpO1xuICAgIH1cbiAgICAvLyBBbHdheXMgb3ZlcndyaXRlIGluIGNhc2UgdXNlciBzcGVjaWZ5IHRoaXMgcHJvcC5cbiAgICBzdHlsZU9wdC5fX2RlY2FsUGF0dGVybiA9IGRlY2FsUGF0dGVybjtcbiAgfVxuICBpZiAoaXNEaXNwbGF5YWJsZShlbCkpIHtcbiAgICBpZiAoc3R5bGVPcHQpIHtcbiAgICAgIHZhciBkZWNhbFBhdHRlcm4gPSBzdHlsZU9wdC5fX2RlY2FsUGF0dGVybjtcbiAgICAgIGlmIChkZWNhbFBhdHRlcm4pIHtcbiAgICAgICAgc3R5bGVPcHQuZGVjYWwgPSBkZWNhbFBhdHRlcm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFwcGx5VXBkYXRlVHJhbnNpdGlvbihlbCwgZWxPcHRpb24sIHNlcmllc01vZGVsLCB7XG4gICAgZGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgaXNJbml0OiBpc0luaXQsXG4gICAgY2xlYXJTdHlsZTogdHJ1ZVxuICB9KTtcbiAgYXBwbHlLZXlmcmFtZUFuaW1hdGlvbihlbCwgZWxPcHRpb24ua2V5ZnJhbWVBbmltYXRpb24sIHNlcmllc01vZGVsKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUVsT25TdGF0ZShzdGF0ZSwgZWwsIGVsU3RhdGVPcHQsIHN0eWxlT3B0LCBhdHRhY2hlZFR4SW5mbykge1xuICB2YXIgZWxEaXNwbGF5YWJsZSA9IGVsLmlzR3JvdXAgPyBudWxsIDogZWw7XG4gIHZhciB0eENmZ09wdCA9IGF0dGFjaGVkVHhJbmZvICYmIGF0dGFjaGVkVHhJbmZvW3N0YXRlXS5jZmc7XG4gIC8vIFBFTkRJTkc6NS4wIHN1cHBvcnQgY3VzdG9taXplIHNjYWxlIGNoYW5nZSBhbmQgdHJhbnNpdGlvbiBhbmltYXRpb24/XG4gIGlmIChlbERpc3BsYXlhYmxlKSB7XG4gICAgLy8gQnkgZGVmYXVsdCBzdXBwb3J0IGF1dG8gbGlmdCBjb2xvciB3aGVuIGhvdmVyIHdoZXRoZXIgYGVtcGhhc2lzYCBzcGVjaWZpZWQuXG4gICAgdmFyIHN0YXRlT2JqID0gZWxEaXNwbGF5YWJsZS5lbnN1cmVTdGF0ZShzdGF0ZSk7XG4gICAgaWYgKHN0eWxlT3B0ID09PSBmYWxzZSkge1xuICAgICAgdmFyIGV4aXN0aW5nRW1waGFzaXNTdGF0ZSA9IGVsRGlzcGxheWFibGUuZ2V0U3RhdGUoc3RhdGUpO1xuICAgICAgaWYgKGV4aXN0aW5nRW1waGFzaXNTdGF0ZSkge1xuICAgICAgICBleGlzdGluZ0VtcGhhc2lzU3RhdGUuc3R5bGUgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdHlsZSBpcyBuZWVkZWQgdG8gZW5hYmxlIGRlZmF1bHQgZW1waGFzaXMuXG4gICAgICBzdGF0ZU9iai5zdHlsZSA9IHN0eWxlT3B0IHx8IG51bGw7XG4gICAgfVxuICAgIC8vIElmIGBlbE9wdGlvbi5zdHlsZUVtcGhhc2lzYCBvciBgZWxPcHRpb24uZW1waGFzaXMuc3R5bGVgIGlzIGBmYWxzZWAsXG4gICAgLy8gcmVtb3ZlIGhvdmVyIHN0eWxlLlxuICAgIC8vIElmIGBlbE9wdGlvbi50ZXh0Q29uZmlnYCBvciBgZWxPcHRpb24uZW1waGFzaXMudGV4dENvbmZpZ2AgaXMgbnVsbC91bmRlZmluZWQsIGl0IGRvZXMgbm90XG4gICAgLy8gbWFrZSBzZW5zZS4gU28gZm9yIHNpbXBsaWNpdHksIHdlIGRvIG5vdCBkaXRpbmd1aXNoIGBoYXNPd25Qcm9wZXJ0eWAgYW5kIG51bGwvdW5kZWZpbmVkLlxuICAgIGlmICh0eENmZ09wdCkge1xuICAgICAgc3RhdGVPYmoudGV4dENvbmZpZyA9IHR4Q2ZnT3B0O1xuICAgIH1cbiAgICBzZXREZWZhdWx0U3RhdGVQcm94eShlbERpc3BsYXlhYmxlKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlWihlbCwgZWxPcHRpb24sIHNlcmllc01vZGVsKSB7XG4gIC8vIEdyb3VwIG5vdCBzdXBwb3J0IHRleHRDb250ZW50IGFuZCBub3Qgc3VwcG9ydCB6IHlldC5cbiAgaWYgKGVsLmlzR3JvdXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGVsRGlzcGxheWFibGUgPSBlbDtcbiAgdmFyIGN1cnJlbnRaID0gc2VyaWVzTW9kZWwuY3VycmVudFo7XG4gIHZhciBjdXJyZW50WkxldmVsID0gc2VyaWVzTW9kZWwuY3VycmVudFpMZXZlbDtcbiAgLy8gQWx3YXlzIGVyYXNlLlxuICBlbERpc3BsYXlhYmxlLnogPSBjdXJyZW50WjtcbiAgZWxEaXNwbGF5YWJsZS56bGV2ZWwgPSBjdXJyZW50WkxldmVsO1xuICAvLyB6MiBtdXN0IG5vdCBiZSBudWxsL3VuZGVmaW5lZCwgb3RoZXJ3aXNlIHNvcnQgZXJyb3IgbWF5IG9jY3VyLlxuICB2YXIgb3B0WjIgPSBlbE9wdGlvbi56MjtcbiAgb3B0WjIgIT0gbnVsbCAmJiAoZWxEaXNwbGF5YWJsZS56MiA9IG9wdFoyIHx8IDApO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IFNUQVRFUy5sZW5ndGg7IGkrKykge1xuICAgIHVwZGF0ZVpGb3JFYWNoU3RhdGUoZWxEaXNwbGF5YWJsZSwgZWxPcHRpb24sIFNUQVRFU1tpXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVpGb3JFYWNoU3RhdGUoZWxEaXNwbGF5YWJsZSwgZWxPcHRpb24sIHN0YXRlKSB7XG4gIHZhciBpc05vcm1hbCA9IHN0YXRlID09PSBOT1JNQUw7XG4gIHZhciBlbFN0YXRlT3B0ID0gaXNOb3JtYWwgPyBlbE9wdGlvbiA6IHJldHJpZXZlU3RhdGVPcHRpb24oZWxPcHRpb24sIHN0YXRlKTtcbiAgdmFyIG9wdFoyID0gZWxTdGF0ZU9wdCA/IGVsU3RhdGVPcHQuejIgOiBudWxsO1xuICB2YXIgc3RhdGVPYmo7XG4gIGlmIChvcHRaMiAhPSBudWxsKSB7XG4gICAgLy8gRG8gbm90IGBlbnN1cmVTdGF0ZWAgdW50aWwgcmVxdWlyZWQuXG4gICAgc3RhdGVPYmogPSBpc05vcm1hbCA/IGVsRGlzcGxheWFibGUgOiBlbERpc3BsYXlhYmxlLmVuc3VyZVN0YXRlKHN0YXRlKTtcbiAgICBzdGF0ZU9iai56MiA9IG9wdFoyIHx8IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIG1ha2VSZW5kZXJJdGVtKGN1c3RvbVNlcmllcywgZGF0YSwgZWNNb2RlbCwgYXBpKSB7XG4gIHZhciByZW5kZXJJdGVtID0gY3VzdG9tU2VyaWVzLmdldCgncmVuZGVySXRlbScpO1xuICB2YXIgY29vcmRTeXMgPSBjdXN0b21TZXJpZXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgdmFyIHByZXBhcmVSZXN1bHQgPSB7fTtcbiAgaWYgKGNvb3JkU3lzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChyZW5kZXJJdGVtLCAnc2VyaWVzLnJlbmRlciBpcyByZXF1aXJlZC4nKTtcbiAgICAgIGFzc2VydChjb29yZFN5cy5wcmVwYXJlQ3VzdG9tcyB8fCBwcmVwYXJlQ3VzdG9tc1tjb29yZFN5cy50eXBlXSwgJ1RoaXMgY29vcmRTeXMgZG9lcyBub3Qgc3VwcG9ydCBjdXN0b20gc2VyaWVzLicpO1xuICAgIH1cbiAgICAvLyBgY29vcmRTeXMucHJlcGFyZUN1c3RvbXNgIGlzIHVzZWQgZm9yIGV4dGVybmFsIGNvb3JkIHN5cyBsaWtlIGJtYXAuXG4gICAgcHJlcGFyZVJlc3VsdCA9IGNvb3JkU3lzLnByZXBhcmVDdXN0b21zID8gY29vcmRTeXMucHJlcGFyZUN1c3RvbXMoY29vcmRTeXMpIDogcHJlcGFyZUN1c3RvbXNbY29vcmRTeXMudHlwZV0oY29vcmRTeXMpO1xuICB9XG4gIHZhciB1c2VyQVBJID0gZGVmYXVsdHMoe1xuICAgIGdldFdpZHRoOiBhcGkuZ2V0V2lkdGgsXG4gICAgZ2V0SGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0LFxuICAgIGdldFpyOiBhcGkuZ2V0WnIsXG4gICAgZ2V0RGV2aWNlUGl4ZWxSYXRpbzogYXBpLmdldERldmljZVBpeGVsUmF0aW8sXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHN0eWxlOiBzdHlsZSxcbiAgICBvcmRpbmFsUmF3VmFsdWU6IG9yZGluYWxSYXdWYWx1ZSxcbiAgICBzdHlsZUVtcGhhc2lzOiBzdHlsZUVtcGhhc2lzLFxuICAgIHZpc3VhbDogdmlzdWFsLFxuICAgIGJhckxheW91dDogYmFyTGF5b3V0LFxuICAgIGN1cnJlbnRTZXJpZXNJbmRpY2VzOiBjdXJyZW50U2VyaWVzSW5kaWNlcyxcbiAgICBmb250OiBmb250XG4gIH0sIHByZXBhcmVSZXN1bHQuYXBpIHx8IHt9KTtcbiAgdmFyIHVzZXJQYXJhbXMgPSB7XG4gICAgLy8gVGhlIGxpZmUgY3ljbGUgb2YgY29udGV4dDogY3VycmVudCByb3VuZCBvZiByZW5kZXJpbmcuXG4gICAgLy8gVGhlIGdsb2JhbCBsaWZlIGN5Y2xlIGlzIHByb2JhYmx5IG5vdCBuZWNlc3NhcnksIGJlY2F1c2VcbiAgICAvLyB1c2VyIGNhbiBzdG9yZSBnbG9iYWwgc3RhdHVzIGJ5IHRoZW1zZWx2ZXMuXG4gICAgY29udGV4dDoge30sXG4gICAgc2VyaWVzSWQ6IGN1c3RvbVNlcmllcy5pZCxcbiAgICBzZXJpZXNOYW1lOiBjdXN0b21TZXJpZXMubmFtZSxcbiAgICBzZXJpZXNJbmRleDogY3VzdG9tU2VyaWVzLnNlcmllc0luZGV4LFxuICAgIGNvb3JkU3lzOiBwcmVwYXJlUmVzdWx0LmNvb3JkU3lzLFxuICAgIGRhdGFJbnNpZGVMZW5ndGg6IGRhdGEuY291bnQoKSxcbiAgICBlbmNvZGU6IHdyYXBFbmNvZGVEZWYoY3VzdG9tU2VyaWVzLmdldERhdGEoKSlcbiAgfTtcbiAgLy8gSWYgc29tZWRheSBpbnRlbmRpbmcgdG8gcmVmYWN0b3IgdGhlbSB0byBhIGNsYXNzLCBzaG91bGQgY29uc2lkZXIgZG8gbm90XG4gIC8vIGJyZWFrIGNoYW5nZTogY3VycmVudGx5IHRoZXNlIGF0dHJpYnV0ZSBtZW1iZXIgYXJlIGVuY2Fwc3VsYXRlZCBpbiBhIGNsb3N1cmVcbiAgLy8gc28gdGhhdCBkbyBub3QgbmVlZCB0byBmb3JjZSB1c2VyIHRvIGNhbGwgdGhlc2UgbWV0aG9kIHdpdGggYSBzY29wZS5cbiAgLy8gRG8gbm90IHN1cHBvcnQgY2FsbCBgYXBpYCBhc3luY2hyb25vdXNseSB3aXRob3V0IGRhdGFJbmRleEluc2lkZSBpbnB1dC5cbiAgdmFyIGN1cnJEYXRhSW5kZXhJbnNpZGU7XG4gIHZhciBjdXJySXRlbU1vZGVsO1xuICB2YXIgY3Vyckl0ZW1TdHlsZU1vZGVscyA9IHt9O1xuICB2YXIgY3VyckxhYmVsTW9kZWxzID0ge307XG4gIHZhciBzZXJpZXNJdGVtU3R5bGVNb2RlbHMgPSB7fTtcbiAgdmFyIHNlcmllc0xhYmVsTW9kZWxzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgU1RBVEVTLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN0YXRlTmFtZSA9IFNUQVRFU1tpXTtcbiAgICBzZXJpZXNJdGVtU3R5bGVNb2RlbHNbc3RhdGVOYW1lXSA9IGN1c3RvbVNlcmllcy5nZXRNb2RlbChQQVRIX0lURU1fU1RZTEVbc3RhdGVOYW1lXSk7XG4gICAgc2VyaWVzTGFiZWxNb2RlbHNbc3RhdGVOYW1lXSA9IGN1c3RvbVNlcmllcy5nZXRNb2RlbChQQVRIX0xBQkVMW3N0YXRlTmFtZV0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEl0ZW1Nb2RlbChkYXRhSW5kZXhJbnNpZGUpIHtcbiAgICByZXR1cm4gZGF0YUluZGV4SW5zaWRlID09PSBjdXJyRGF0YUluZGV4SW5zaWRlID8gY3Vyckl0ZW1Nb2RlbCB8fCAoY3Vyckl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleEluc2lkZSkpIDogZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4SW5zaWRlKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRJdGVtU3R5bGVNb2RlbChkYXRhSW5kZXhJbnNpZGUsIHN0YXRlKSB7XG4gICAgcmV0dXJuICFkYXRhLmhhc0l0ZW1PcHRpb24gPyBzZXJpZXNJdGVtU3R5bGVNb2RlbHNbc3RhdGVdIDogZGF0YUluZGV4SW5zaWRlID09PSBjdXJyRGF0YUluZGV4SW5zaWRlID8gY3Vyckl0ZW1TdHlsZU1vZGVsc1tzdGF0ZV0gfHwgKGN1cnJJdGVtU3R5bGVNb2RlbHNbc3RhdGVdID0gZ2V0SXRlbU1vZGVsKGRhdGFJbmRleEluc2lkZSkuZ2V0TW9kZWwoUEFUSF9JVEVNX1NUWUxFW3N0YXRlXSkpIDogZ2V0SXRlbU1vZGVsKGRhdGFJbmRleEluc2lkZSkuZ2V0TW9kZWwoUEFUSF9JVEVNX1NUWUxFW3N0YXRlXSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TGFiZWxNb2RlbChkYXRhSW5kZXhJbnNpZGUsIHN0YXRlKSB7XG4gICAgcmV0dXJuICFkYXRhLmhhc0l0ZW1PcHRpb24gPyBzZXJpZXNMYWJlbE1vZGVsc1tzdGF0ZV0gOiBkYXRhSW5kZXhJbnNpZGUgPT09IGN1cnJEYXRhSW5kZXhJbnNpZGUgPyBjdXJyTGFiZWxNb2RlbHNbc3RhdGVdIHx8IChjdXJyTGFiZWxNb2RlbHNbc3RhdGVdID0gZ2V0SXRlbU1vZGVsKGRhdGFJbmRleEluc2lkZSkuZ2V0TW9kZWwoUEFUSF9MQUJFTFtzdGF0ZV0pKSA6IGdldEl0ZW1Nb2RlbChkYXRhSW5kZXhJbnNpZGUpLmdldE1vZGVsKFBBVEhfTEFCRUxbc3RhdGVdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGFJbmRleEluc2lkZSwgcGF5bG9hZCkge1xuICAgIGN1cnJEYXRhSW5kZXhJbnNpZGUgPSBkYXRhSW5kZXhJbnNpZGU7XG4gICAgY3Vyckl0ZW1Nb2RlbCA9IG51bGw7XG4gICAgY3Vyckl0ZW1TdHlsZU1vZGVscyA9IHt9O1xuICAgIGN1cnJMYWJlbE1vZGVscyA9IHt9O1xuICAgIHJldHVybiByZW5kZXJJdGVtICYmIHJlbmRlckl0ZW0oZGVmYXVsdHMoe1xuICAgICAgZGF0YUluZGV4SW5zaWRlOiBkYXRhSW5kZXhJbnNpZGUsXG4gICAgICBkYXRhSW5kZXg6IGRhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4SW5zaWRlKSxcbiAgICAgIC8vIENhbiBiZSB1c2VkIGZvciBvcHRpbWl6YXRpb24gd2hlbiB6b29tIG9yIHJvYW0uXG4gICAgICBhY3Rpb25UeXBlOiBwYXlsb2FkID8gcGF5bG9hZC50eXBlIDogbnVsbFxuICAgIH0sIHVzZXJQYXJhbXMpLCB1c2VyQVBJKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSBkaW0gYnkgZGVmYXVsdCAwLlxyXG4gICAqIEBwYXJhbSBkYXRhSW5kZXhJbnNpZGUgYnkgZGVmYXVsdCBgY3VyckRhdGFJbmRleEluc2lkZWAuXHJcbiAgICovXG4gIGZ1bmN0aW9uIHZhbHVlKGRpbSwgZGF0YUluZGV4SW5zaWRlKSB7XG4gICAgZGF0YUluZGV4SW5zaWRlID09IG51bGwgJiYgKGRhdGFJbmRleEluc2lkZSA9IGN1cnJEYXRhSW5kZXhJbnNpZGUpO1xuICAgIHJldHVybiBkYXRhLmdldFN0b3JlKCkuZ2V0KGRhdGEuZ2V0RGltZW5zaW9uSW5kZXgoZGltIHx8IDApLCBkYXRhSW5kZXhJbnNpZGUpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gZGltIGJ5IGRlZmF1bHQgMC5cclxuICAgKiBAcGFyYW0gZGF0YUluZGV4SW5zaWRlIGJ5IGRlZmF1bHQgYGN1cnJEYXRhSW5kZXhJbnNpZGVgLlxyXG4gICAqL1xuICBmdW5jdGlvbiBvcmRpbmFsUmF3VmFsdWUoZGltLCBkYXRhSW5kZXhJbnNpZGUpIHtcbiAgICBkYXRhSW5kZXhJbnNpZGUgPT0gbnVsbCAmJiAoZGF0YUluZGV4SW5zaWRlID0gY3VyckRhdGFJbmRleEluc2lkZSk7XG4gICAgZGltID0gZGltIHx8IDA7XG4gICAgdmFyIGRpbUluZm8gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oZGltKTtcbiAgICBpZiAoIWRpbUluZm8pIHtcbiAgICAgIHZhciBkaW1JbmRleCA9IGRhdGEuZ2V0RGltZW5zaW9uSW5kZXgoZGltKTtcbiAgICAgIHJldHVybiBkaW1JbmRleCA+PSAwID8gZGF0YS5nZXRTdG9yZSgpLmdldChkaW1JbmRleCwgZGF0YUluZGV4SW5zaWRlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHZhbCA9IGRhdGEuZ2V0KGRpbUluZm8ubmFtZSwgZGF0YUluZGV4SW5zaWRlKTtcbiAgICB2YXIgb3JkaW5hbE1ldGEgPSBkaW1JbmZvICYmIGRpbUluZm8ub3JkaW5hbE1ldGE7XG4gICAgcmV0dXJuIG9yZGluYWxNZXRhID8gb3JkaW5hbE1ldGEuY2F0ZWdvcmllc1t2YWxdIDogdmFsO1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXByZWNhdGVkIFRoZSBvcmlnaW5hbCBpbnRlbnRpb24gb2YgYGFwaS5zdHlsZWAgaXMgZW5hYmxlIHRvIHNldCBpdGVtU3R5bGVcclxuICAgKiBsaWtlIG90aGVyIHNlcmllcy4gQnV0IGl0IGlzIG5vdCBuZWNlc3NhcnkgYW5kIG5vdCBlYXN5IHRvIGdpdmUgYSBzdHJpY3QgZGVmaW5pdGlvblxyXG4gICAqIG9mIHdoYXQgaXQgcmV0dXJucy4gQW5kIHNpbmNlIGVjaGFydHM1IGl0IG5lZWRzIHRvIGJlIG1ha2UgY29tcGF0IHdvcmsuIFNvXHJcbiAgICogZGVwcmVjYXRlcyBpdCBzaW5jZSBlY2hhcnRzNS5cclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQsIGB2aXN1YWxgIGlzIGFwcGxpZWQgdG8gc3R5bGUgKHRvIHN1cHBvcnQgdmlzdWFsTWFwKS5cclxuICAgKiBgdmlzdWFsLmNvbG9yYCBpcyBhcHBsaWVkIGF0IGBmaWxsYC4gSWYgdXNlciB3YW50IGFwcGx5IHZpc3VhbC5jb2xvciBvbiBgc3Ryb2tlYCxcclxuICAgKiBpdCBjYW4gYmUgaW1wbGVtZW50ZWQgYXM6XHJcbiAgICogYGFwaS5zdHlsZSh7c3Ryb2tlOiBhcGkudmlzdWFsKCdjb2xvcicpLCBmaWxsOiBudWxsfSlgO1xyXG4gICAqXHJcbiAgICogW0NvbXBhdF06IHNpbmNlIGVjNSwgUmVjdFRleHQgaGFzIGJlZW4gc2VwYXJhdGVkIGZyb20gaXRzIGhvc3RzIGVsLlxyXG4gICAqIHNvIGBhcGkuc3R5bGUoKWAgd2lsbCBvbmx5IHJldHVybiB0aGUgc3R5bGUgZnJvbSBgaXRlbVN0eWxlYCBidXQgbm90IGhhbmRsZSBgbGFiZWxgXHJcbiAgICogYW55IG1vcmUuIEJ1dCBgc2VyaWVzLmxhYmVsYCBjb25maWcgaXMgbmV2ZXIgcHVibGlzaGVkIGluIGRvYy5cclxuICAgKiBXZSBzdGlsbCBjb21wYXQgaXQgaW4gYGFwaS5zdHlsZSgpYC4gQnV0IG5vdCBlbmNvdXJhZ2UgdG8gdXNlIGl0IGFuZCB3aWxsIHN0aWxsIG5vdFxyXG4gICAqIHRvIHB1bGlzaCBpdCB0byBkb2MuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSBkYXRhSW5kZXhJbnNpZGUgYnkgZGVmYXVsdCBgY3VyckRhdGFJbmRleEluc2lkZWAuXHJcbiAgICovXG4gIGZ1bmN0aW9uIHN0eWxlKHVzZXJQcm9wcywgZGF0YUluZGV4SW5zaWRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5EZXByZWNhdGVkKCdhcGkuc3R5bGUnLCAnUGxlYXNlIHdyaXRlIGxpdGVyYWwgc3R5bGUgZGlyZWN0bHkgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgZGF0YUluZGV4SW5zaWRlID09IG51bGwgJiYgKGRhdGFJbmRleEluc2lkZSA9IGN1cnJEYXRhSW5kZXhJbnNpZGUpO1xuICAgIHZhciBzdHlsZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXhJbnNpZGUsICdzdHlsZScpO1xuICAgIHZhciB2aXN1YWxDb2xvciA9IHN0eWxlICYmIHN0eWxlLmZpbGw7XG4gICAgdmFyIG9wYWNpdHkgPSBzdHlsZSAmJiBzdHlsZS5vcGFjaXR5O1xuICAgIHZhciBpdGVtU3R5bGUgPSBnZXRJdGVtU3R5bGVNb2RlbChkYXRhSW5kZXhJbnNpZGUsIE5PUk1BTCkuZ2V0SXRlbVN0eWxlKCk7XG4gICAgdmlzdWFsQ29sb3IgIT0gbnVsbCAmJiAoaXRlbVN0eWxlLmZpbGwgPSB2aXN1YWxDb2xvcik7XG4gICAgb3BhY2l0eSAhPSBudWxsICYmIChpdGVtU3R5bGUub3BhY2l0eSA9IG9wYWNpdHkpO1xuICAgIHZhciBvcHQgPSB7XG4gICAgICBpbmhlcml0Q29sb3I6IGlzU3RyaW5nKHZpc3VhbENvbG9yKSA/IHZpc3VhbENvbG9yIDogJyMwMDAnXG4gICAgfTtcbiAgICB2YXIgbGFiZWxNb2RlbCA9IGdldExhYmVsTW9kZWwoZGF0YUluZGV4SW5zaWRlLCBOT1JNQUwpO1xuICAgIC8vIE5vdyB0aGF0IHRoZSBmZWF0dXJlIG9mIFwiYXV0byBhZGp1c3QgdGV4dCBmaWxsL3N0cm9rZVwiIGhhcyBiZWVuIG1pZ3JhdGVkIHRvIHpyZW5kZXJcbiAgICAvLyBzaW5jZSBlYzUsIHdlIHNob3VsZCBzZXQgYGlzQXR0YWNoZWRgIGFzIGBmYWxzZWAgaGVyZSBhbmQgbWFrZSBjb21wYXQgaW5cbiAgICAvLyBgY29udmVydFRvRUM0U3R5bGVGb3JDdXN0b21TZXJpc2VgLlxuICAgIHZhciB0ZXh0U3R5bGUgPSBsYWJlbFN0eWxlSGVscGVyLmNyZWF0ZVRleHRTdHlsZShsYWJlbE1vZGVsLCBudWxsLCBvcHQsIGZhbHNlLCB0cnVlKTtcbiAgICB0ZXh0U3R5bGUudGV4dCA9IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnc2hvdycpID8gcmV0cmlldmUyKGN1c3RvbVNlcmllcy5nZXRGb3JtYXR0ZWRMYWJlbChkYXRhSW5kZXhJbnNpZGUsIE5PUk1BTCksIGdldERlZmF1bHRMYWJlbChkYXRhLCBkYXRhSW5kZXhJbnNpZGUpKSA6IG51bGw7XG4gICAgdmFyIHRleHRDb25maWcgPSBsYWJlbFN0eWxlSGVscGVyLmNyZWF0ZVRleHRDb25maWcobGFiZWxNb2RlbCwgb3B0LCBmYWxzZSk7XG4gICAgcHJlRmV0Y2hGcm9tRXh0cmEodXNlclByb3BzLCBpdGVtU3R5bGUpO1xuICAgIGl0ZW1TdHlsZSA9IGNvbnZlcnRUb0VDNFN0eWxlRm9yQ3VzdG9tU2VyaXNlKGl0ZW1TdHlsZSwgdGV4dFN0eWxlLCB0ZXh0Q29uZmlnKTtcbiAgICB1c2VyUHJvcHMgJiYgYXBwbHlVc2VyUHJvcHNBZnRlcihpdGVtU3R5bGUsIHVzZXJQcm9wcyk7XG4gICAgaXRlbVN0eWxlLmxlZ2FjeSA9IHRydWU7XG4gICAgcmV0dXJuIGl0ZW1TdHlsZTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVwcmVjYXRlZCBUaGUgcmVhc29uIHNlZSBgYXBpLnN0eWxlKClgXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSBkYXRhSW5kZXhJbnNpZGUgYnkgZGVmYXVsdCBgY3VyckRhdGFJbmRleEluc2lkZWAuXHJcbiAgICovXG4gIGZ1bmN0aW9uIHN0eWxlRW1waGFzaXModXNlclByb3BzLCBkYXRhSW5kZXhJbnNpZGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybkRlcHJlY2F0ZWQoJ2FwaS5zdHlsZUVtcGhhc2lzJywgJ1BsZWFzZSB3cml0ZSBsaXRlcmFsIHN0eWxlIGRpcmVjdGx5IGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGRhdGFJbmRleEluc2lkZSA9PSBudWxsICYmIChkYXRhSW5kZXhJbnNpZGUgPSBjdXJyRGF0YUluZGV4SW5zaWRlKTtcbiAgICB2YXIgaXRlbVN0eWxlID0gZ2V0SXRlbVN0eWxlTW9kZWwoZGF0YUluZGV4SW5zaWRlLCBFTVBIQVNJUykuZ2V0SXRlbVN0eWxlKCk7XG4gICAgdmFyIGxhYmVsTW9kZWwgPSBnZXRMYWJlbE1vZGVsKGRhdGFJbmRleEluc2lkZSwgRU1QSEFTSVMpO1xuICAgIHZhciB0ZXh0U3R5bGUgPSBsYWJlbFN0eWxlSGVscGVyLmNyZWF0ZVRleHRTdHlsZShsYWJlbE1vZGVsLCBudWxsLCBudWxsLCB0cnVlLCB0cnVlKTtcbiAgICB0ZXh0U3R5bGUudGV4dCA9IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnc2hvdycpID8gcmV0cmlldmUzKGN1c3RvbVNlcmllcy5nZXRGb3JtYXR0ZWRMYWJlbChkYXRhSW5kZXhJbnNpZGUsIEVNUEhBU0lTKSwgY3VzdG9tU2VyaWVzLmdldEZvcm1hdHRlZExhYmVsKGRhdGFJbmRleEluc2lkZSwgTk9STUFMKSwgZ2V0RGVmYXVsdExhYmVsKGRhdGEsIGRhdGFJbmRleEluc2lkZSkpIDogbnVsbDtcbiAgICB2YXIgdGV4dENvbmZpZyA9IGxhYmVsU3R5bGVIZWxwZXIuY3JlYXRlVGV4dENvbmZpZyhsYWJlbE1vZGVsLCBudWxsLCB0cnVlKTtcbiAgICBwcmVGZXRjaEZyb21FeHRyYSh1c2VyUHJvcHMsIGl0ZW1TdHlsZSk7XG4gICAgaXRlbVN0eWxlID0gY29udmVydFRvRUM0U3R5bGVGb3JDdXN0b21TZXJpc2UoaXRlbVN0eWxlLCB0ZXh0U3R5bGUsIHRleHRDb25maWcpO1xuICAgIHVzZXJQcm9wcyAmJiBhcHBseVVzZXJQcm9wc0FmdGVyKGl0ZW1TdHlsZSwgdXNlclByb3BzKTtcbiAgICBpdGVtU3R5bGUubGVnYWN5ID0gdHJ1ZTtcbiAgICByZXR1cm4gaXRlbVN0eWxlO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5VXNlclByb3BzQWZ0ZXIoaXRlbVN0eWxlLCBleHRyYSkge1xuICAgIGZvciAodmFyIGtleSBpbiBleHRyYSkge1xuICAgICAgaWYgKGhhc093bihleHRyYSwga2V5KSkge1xuICAgICAgICBpdGVtU3R5bGVba2V5XSA9IGV4dHJhW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByZUZldGNoRnJvbUV4dHJhKGV4dHJhLCBpdGVtU3R5bGUpIHtcbiAgICAvLyBBIHRyaWNrIHRvIHJldHJpZXZlIHRob3NlIHByb3BzIGZpcnN0bHksIHdoaWNoIGFyZSB1c2VkIHRvXG4gICAgLy8gYXBwbHkgYXV0byBpbnNpZGUgZmlsbC9zdHJva2UgaW4gYGNvbnZlcnRUb0VDNFN0eWxlRm9yQ3VzdG9tU2VyaXNlYC5cbiAgICAvLyAoSXQncyBub3QgcmVhc29uYWJsZSBidXQgb25seSBmb3IgYSBkZWdyZWUgb2YgY29tcGF0KVxuICAgIGlmIChleHRyYSkge1xuICAgICAgZXh0cmEudGV4dEZpbGwgJiYgKGl0ZW1TdHlsZS50ZXh0RmlsbCA9IGV4dHJhLnRleHRGaWxsKTtcbiAgICAgIGV4dHJhLnRleHRQb3NpdGlvbiAmJiAoaXRlbVN0eWxlLnRleHRQb3NpdGlvbiA9IGV4dHJhLnRleHRQb3NpdGlvbik7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gZGF0YUluZGV4SW5zaWRlIGJ5IGRlZmF1bHQgYGN1cnJEYXRhSW5kZXhJbnNpZGVgLlxyXG4gICAqL1xuICBmdW5jdGlvbiB2aXN1YWwodmlzdWFsVHlwZSwgZGF0YUluZGV4SW5zaWRlKSB7XG4gICAgZGF0YUluZGV4SW5zaWRlID09IG51bGwgJiYgKGRhdGFJbmRleEluc2lkZSA9IGN1cnJEYXRhSW5kZXhJbnNpZGUpO1xuICAgIGlmIChoYXNPd24oU1RZTEVfVklTVUFMX1RZUEUsIHZpc3VhbFR5cGUpKSB7XG4gICAgICB2YXIgc3R5bGVfMSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXhJbnNpZGUsICdzdHlsZScpO1xuICAgICAgcmV0dXJuIHN0eWxlXzEgPyBzdHlsZV8xW1NUWUxFX1ZJU1VBTF9UWVBFW3Zpc3VhbFR5cGVdXSA6IG51bGw7XG4gICAgfVxuICAgIC8vIE9ubHkgc3VwcG9ydCB0aGVzZSB2aXN1YWxzLiBPdGhlciB2aXN1YWwgbWlnaHQgYmUgaW5uZXIgdHJpY2t5XG4gICAgLy8gZm9yIHBlcmZvcm1hbmNlIChsaWtlIGBzdHlsZWApLCBkbyBub3QgZXhwb3NlIHRvIHVzZXJzLlxuICAgIGlmIChoYXNPd24oTk9OX1NUWUxFX1ZJU1VBTF9QUk9QUywgdmlzdWFsVHlwZSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4SW5zaWRlLCB2aXN1YWxUeXBlKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm4gSWYgbm90IHN1cHBvcnQsIHJldHVybiB1bmRlZmluZWQuXHJcbiAgICovXG4gIGZ1bmN0aW9uIGJhckxheW91dChvcHQpIHtcbiAgICBpZiAoY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgIHJldHVybiBnZXRMYXlvdXRPbkF4aXMoZGVmYXVsdHMoe1xuICAgICAgICBheGlzOiBiYXNlQXhpc1xuICAgICAgfSwgb3B0KSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cbiAgZnVuY3Rpb24gY3VycmVudFNlcmllc0luZGljZXMoKSB7XG4gICAgcmV0dXJuIGVjTW9kZWwuZ2V0Q3VycmVudFNlcmllc0luZGljZXMoKTtcbiAgfVxuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybiBmb250IHN0cmluZ1xyXG4gICAqL1xuICBmdW5jdGlvbiBmb250KG9wdCkge1xuICAgIHJldHVybiBsYWJlbFN0eWxlSGVscGVyLmdldEZvbnQob3B0LCBlY01vZGVsKTtcbiAgfVxufVxuZnVuY3Rpb24gd3JhcEVuY29kZURlZihkYXRhKSB7XG4gIHZhciBlbmNvZGVEZWYgPSB7fTtcbiAgZWFjaChkYXRhLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW1OYW1lKSB7XG4gICAgdmFyIGRpbUluZm8gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oZGltTmFtZSk7XG4gICAgaWYgKCFkaW1JbmZvLmlzRXh0cmFDb29yZCkge1xuICAgICAgdmFyIGNvb3JkRGltID0gZGltSW5mby5jb29yZERpbTtcbiAgICAgIHZhciBkYXRhRGltcyA9IGVuY29kZURlZltjb29yZERpbV0gPSBlbmNvZGVEZWZbY29vcmREaW1dIHx8IFtdO1xuICAgICAgZGF0YURpbXNbZGltSW5mby5jb29yZERpbUluZGV4XSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5kZXgoZGltTmFtZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZURlZjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlSXRlbShhcGksIGV4aXN0c0VsLCBkYXRhSW5kZXgsIGVsT3B0aW9uLCBzZXJpZXNNb2RlbCwgZ3JvdXAsIGRhdGEpIHtcbiAgLy8gW1J1bGVdXG4gIC8vIElmIGByZW5kZXJJdGVtYCByZXR1cm5zIGBudWxsYC9gdW5kZWZpbmVkYC9gZmFsc2VgLCByZW1vdmUgdGhlIHByZXZpb3VzIGVsIGlmIGV4aXN0aW5nLlxuICAvLyAgICAgKEl0IHNlZW1zIHRoYXQgdmlvbGF0ZSB0aGUgXCJtZXJnZVwiIHByaW5jaXBsZSwgYnV0IG1vc3Qgb2YgdXNlcnMgcHJvYmFibHkgaW50dWl0aXZlbHlcbiAgLy8gICAgIHJlZ2FyZCBcInJldHVybjtcIiBhcyBcInNob3cgbm90aGluZyBlbGVtZW50IHdoYXRldmVyXCIsIHNvIG1ha2UgYSBleGNlcHRpb24gdG8gbWVldCB0aGVcbiAgLy8gICAgIG1vc3QgY2FzZXMuKVxuICAvLyBUaGUgcnVsZSBvciBcIm1lcmdlXCIgc2VlIFtTVFJBVEVHWV9NRVJHRV0uXG4gIC8vIElmIGBlbE9wdGlvbmAgaXMgYG51bGxgL2B1bmRlZmluZWRgL2BmYWxzZWAgKHdoZW4gYHJlbmRlckl0ZW1gIHJldHVybnMgbm90aGluZykuXG4gIGlmICghZWxPcHRpb24pIHtcbiAgICBncm91cC5yZW1vdmUoZXhpc3RzRWwpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZWwgPSBkb0NyZWF0ZU9yVXBkYXRlRWwoYXBpLCBleGlzdHNFbCwgZGF0YUluZGV4LCBlbE9wdGlvbiwgc2VyaWVzTW9kZWwsIGdyb3VwKTtcbiAgZWwgJiYgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgZWwpO1xuICBlbCAmJiB0b2dnbGVIb3ZlckVtcGhhc2lzKGVsLCBlbE9wdGlvbi5mb2N1cywgZWxPcHRpb24uYmx1clNjb3BlLCBlbE9wdGlvbi5lbXBoYXNpc0Rpc2FibGVkKTtcbiAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gZG9DcmVhdGVPclVwZGF0ZUVsKGFwaSwgZXhpc3RzRWwsIGRhdGFJbmRleCwgZWxPcHRpb24sIHNlcmllc01vZGVsLCBncm91cCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChlbE9wdGlvbiwgJ3Nob3VsZCBub3QgaGF2ZSBhbiBudWxsL3VuZGVmaW5lZCBlbGVtZW50IHNldHRpbmcnKTtcbiAgfVxuICB2YXIgdG9CZVJlcGxhY2VkSWR4ID0gLTE7XG4gIHZhciBvbGRFbCA9IGV4aXN0c0VsO1xuICBpZiAoZXhpc3RzRWwgJiYgZG9lc0VsTmVlZFJlY3JlYXRlKGV4aXN0c0VsLCBlbE9wdGlvbiwgc2VyaWVzTW9kZWwpXG4gIC8vIHx8IChcbiAgLy8gICAgIC8vIFBFTkRJTkc6IGV2ZW4gaW4gb25lLXRvLW9uZSBtYXBwaW5nIGNhc2UsIGlmIGVsIGlzIG1hcmtlZCBhcyBtb3JwaCxcbiAgLy8gICAgIC8vIGRvIG5vdCBzdXJlIHdoZXRoZXIgdGhlIGVsIHdpbGwgYmUgbWFwcGVkIHRvIGFub3RoZXIgZWwgd2l0aCBkaWZmZXJlbnRcbiAgLy8gICAgIC8vIGhpZXJhcmNoeSBpbiBHcm91cCB0cmVlLiBTbyBhbHdheXMgcmVjcmVhdGUgZWwgcmF0aGVyIHRoYW4gcmV1c2UgdGhlIGVsLlxuICAvLyAgICAgbW9ycGhIZWxwZXIgJiYgbW9ycGhIZWxwZXIuaXNPbmVUb09uZUZyb20oZWwpXG4gIC8vIClcbiAgKSB7XG4gICAgLy8gU2hvdWxkIGtlZXAgYXQgdGhlIG9yaWdpbmFsIGluZGV4LCBvdGhlcndpc2UgXCJtZXJnZSBieSBpbmRleFwiIHdpbGwgYmUgaW5jb3JyZWN0LlxuICAgIHRvQmVSZXBsYWNlZElkeCA9IGluZGV4T2YoZ3JvdXAuY2hpbGRyZW5SZWYoKSwgZXhpc3RzRWwpO1xuICAgIGV4aXN0c0VsID0gbnVsbDtcbiAgfVxuICB2YXIgaXNJbml0ID0gIWV4aXN0c0VsO1xuICB2YXIgZWwgPSBleGlzdHNFbDtcbiAgaWYgKCFlbCkge1xuICAgIGVsID0gY3JlYXRlRWwoZWxPcHRpb24pO1xuICAgIGlmIChvbGRFbCkge1xuICAgICAgY29weUVsZW1lbnQob2xkRWwsIGVsKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRklNWEU6TkVYVCB1bmlmaWVkIGNsZWFyU3RhdGU/XG4gICAgLy8gSWYgaW4gc29tZSBjYXNlIHRoZSBwZXJmb3JtYW5jZSBpc3N1ZSBhcmlzZWQsIGNvbnNpZGVyXG4gICAgLy8gZG8gbm90IGNsZWFyU3RhdGUgYnV0IHVwZGF0ZSBjYWNoZWQgbm9ybWFsIHN0YXRlIGRpcmVjdGx5LlxuICAgIGVsLmNsZWFyU3RhdGVzKCk7XG4gIH1cbiAgLy8gTmVlZCB0byBzZXQgbW9ycGg6IGZhbHNlIGV4cGxpY3RseSB0byBkaXNhYmxlIGF1dG9tYXRpY2FsbHkgbW9ycGhpbmcuXG4gIGlmIChlbE9wdGlvbi5tb3JwaCA9PT0gZmFsc2UpIHtcbiAgICBlbC5kaXNhYmxlTW9ycGhpbmcgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGVsLmRpc2FibGVNb3JwaGluZykge1xuICAgIGVsLmRpc2FibGVNb3JwaGluZyA9IGZhbHNlO1xuICB9XG4gIGF0dGFjaGVkVHhJbmZvVG1wLm5vcm1hbC5jZmcgPSBhdHRhY2hlZFR4SW5mb1RtcC5ub3JtYWwuY29uT3B0ID0gYXR0YWNoZWRUeEluZm9UbXAuZW1waGFzaXMuY2ZnID0gYXR0YWNoZWRUeEluZm9UbXAuZW1waGFzaXMuY29uT3B0ID0gYXR0YWNoZWRUeEluZm9UbXAuYmx1ci5jZmcgPSBhdHRhY2hlZFR4SW5mb1RtcC5ibHVyLmNvbk9wdCA9IGF0dGFjaGVkVHhJbmZvVG1wLnNlbGVjdC5jZmcgPSBhdHRhY2hlZFR4SW5mb1RtcC5zZWxlY3QuY29uT3B0ID0gbnVsbDtcbiAgYXR0YWNoZWRUeEluZm9UbXAuaXNMZWdhY3kgPSBmYWxzZTtcbiAgZG9DcmVhdGVPclVwZGF0ZUF0dGFjaGVkVHgoZWwsIGRhdGFJbmRleCwgZWxPcHRpb24sIHNlcmllc01vZGVsLCBpc0luaXQsIGF0dGFjaGVkVHhJbmZvVG1wKTtcbiAgZG9DcmVhdGVPclVwZGF0ZUNsaXBQYXRoKGVsLCBkYXRhSW5kZXgsIGVsT3B0aW9uLCBzZXJpZXNNb2RlbCwgaXNJbml0KTtcbiAgdXBkYXRlRWxOb3JtYWwoYXBpLCBlbCwgZGF0YUluZGV4LCBlbE9wdGlvbiwgYXR0YWNoZWRUeEluZm9UbXAsIHNlcmllc01vZGVsLCBpc0luaXQpO1xuICAvLyBgZWxPcHRpb24uaW5mb2AgZW5hYmxlcyB1c2VyIHRvIG1vdW50IHNvbWUgaW5mbyBvblxuICAvLyBlbGVtZW50cyBhbmQgdXNlIHRoZW0gaW4gZXZlbnQgaGFuZGxlcnMuXG4gIC8vIFVwZGF0ZSB0aGVtIG9ubHkgd2hlbiB1c2VyIHNwZWNpZmllZCwgb3RoZXJ3aXNlLCByZW1haW4uXG4gIGhhc093bihlbE9wdGlvbiwgJ2luZm8nKSAmJiAoY3VzdG9tSW5uZXJTdG9yZShlbCkuaW5mbyA9IGVsT3B0aW9uLmluZm8pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IFNUQVRFUy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGF0ZU5hbWUgPSBTVEFURVNbaV07XG4gICAgaWYgKHN0YXRlTmFtZSAhPT0gTk9STUFMKSB7XG4gICAgICB2YXIgb3RoZXJTdGF0ZU9wdCA9IHJldHJpZXZlU3RhdGVPcHRpb24oZWxPcHRpb24sIHN0YXRlTmFtZSk7XG4gICAgICB2YXIgb3RoZXJTdHlsZU9wdCA9IHJldHJpZXZlU3R5bGVPcHRpb25PblN0YXRlKGVsT3B0aW9uLCBvdGhlclN0YXRlT3B0LCBzdGF0ZU5hbWUpO1xuICAgICAgdXBkYXRlRWxPblN0YXRlKHN0YXRlTmFtZSwgZWwsIG90aGVyU3RhdGVPcHQsIG90aGVyU3R5bGVPcHQsIGF0dGFjaGVkVHhJbmZvVG1wKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlWihlbCwgZWxPcHRpb24sIHNlcmllc01vZGVsKTtcbiAgaWYgKGVsT3B0aW9uLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICBtZXJnZUNoaWxkcmVuKGFwaSwgZWwsIGRhdGFJbmRleCwgZWxPcHRpb24sIHNlcmllc01vZGVsKTtcbiAgfVxuICBpZiAodG9CZVJlcGxhY2VkSWR4ID49IDApIHtcbiAgICBncm91cC5yZXBsYWNlQXQoZWwsIHRvQmVSZXBsYWNlZElkeCk7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAuYWRkKGVsKTtcbiAgfVxuICByZXR1cm4gZWw7XG59XG4vLyBgZWxgIG11c3Qgbm90IGJlIG51bGwvdW5kZWZpbmVkLlxuZnVuY3Rpb24gZG9lc0VsTmVlZFJlY3JlYXRlKGVsLCBlbE9wdGlvbiwgc2VyaWVzTW9kZWwpIHtcbiAgdmFyIGVsSW5uZXIgPSBjdXN0b21Jbm5lclN0b3JlKGVsKTtcbiAgdmFyIGVsT3B0aW9uVHlwZSA9IGVsT3B0aW9uLnR5cGU7XG4gIHZhciBlbE9wdGlvblNoYXBlID0gZWxPcHRpb24uc2hhcGU7XG4gIHZhciBlbE9wdGlvblN0eWxlID0gZWxPcHRpb24uc3R5bGU7XG4gIHJldHVybiAoXG4gICAgLy8gQWx3YXlzIGNyZWF0ZSBuZXcgaWYgdW5pdmVyc2FsIHRyYW5zaXRpb24gaXMgZW5hYmxlZC5cbiAgICAvLyBCZWNhdXNlIHdlIGRvIHRyYW5zaXRpb24gYWZ0ZXIgcmVuZGVyLiBJdCBuZWVkcyB0byBrbm93IHdoYXQgb2xkIGVsZW1lbnQgaXMuIFJlcGxhY2VtZW50IHdpbGwgbG9vc2UgaXQuXG4gICAgc2VyaWVzTW9kZWwuaXNVbml2ZXJzYWxUcmFuc2l0aW9uRW5hYmxlZCgpXG4gICAgLy8gSWYgYGVsT3B0aW9uVHlwZWAgaXMgYG51bGxgLCBmb2xsb3cgdGhlIG1lcmdlIHByaW5jaXBsZS5cbiAgICB8fCBlbE9wdGlvblR5cGUgIT0gbnVsbCAmJiBlbE9wdGlvblR5cGUgIT09IGVsSW5uZXIuY3VzdG9tR3JhcGhpY1R5cGUgfHwgZWxPcHRpb25UeXBlID09PSAncGF0aCcgJiYgaGFzT3duUGF0aERhdGEoZWxPcHRpb25TaGFwZSkgJiYgZ2V0UGF0aERhdGEoZWxPcHRpb25TaGFwZSkgIT09IGVsSW5uZXIuY3VzdG9tUGF0aERhdGEgfHwgZWxPcHRpb25UeXBlID09PSAnaW1hZ2UnICYmIGhhc093bihlbE9wdGlvblN0eWxlLCAnaW1hZ2UnKSAmJiBlbE9wdGlvblN0eWxlLmltYWdlICE9PSBlbElubmVyLmN1c3RvbUltYWdlUGF0aFxuICAgIC8vIC8vIEZJWE1FIHRlc3QgYW5kIHJlbW92ZSB0aGlzIHJlc3RyaWN0aW9uP1xuICAgIC8vIHx8IChlbE9wdGlvblR5cGUgPT09ICd0ZXh0J1xuICAgIC8vICAgICAmJiBoYXNPd24oZWxPcHRpb25TdHlsZSwgJ3RleHQnKVxuICAgIC8vICAgICAmJiAoZWxPcHRpb25TdHlsZSBhcyBUZXh0U3R5bGVQcm9wcykudGV4dCAhPT0gZWxJbm5lci5jdXN0b21UZXh0XG4gICAgLy8gKVxuICApO1xufVxuZnVuY3Rpb24gZG9DcmVhdGVPclVwZGF0ZUNsaXBQYXRoKGVsLCBkYXRhSW5kZXgsIGVsT3B0aW9uLCBzZXJpZXNNb2RlbCwgaXNJbml0KSB7XG4gIC8vIEJhc2VkIG9uIHRoZSBcIm1lcmdlXCIgcHJpbmNpcGxlLCBpZiBubyBjbGlwUGF0aCBwcm92aWRlZCxcbiAgLy8gZG8gbm90aGluZy4gVGhlIGV4aXN0cyBjbGlwIHdpbGwgYmUgdG90YWxseSByZW1vdmVkIG9ubHkgaWZcbiAgLy8gYGVsLmNsaXBQYXRoYCBpcyBgZmFsc2VgLiBPdGhlcndpc2UgaXQgd2lsbCBiZSBtZXJnZWQvcmVwbGFjZWQuXG4gIHZhciBjbGlwUGF0aE9wdCA9IGVsT3B0aW9uLmNsaXBQYXRoO1xuICBpZiAoY2xpcFBhdGhPcHQgPT09IGZhbHNlKSB7XG4gICAgaWYgKGVsICYmIGVsLmdldENsaXBQYXRoKCkpIHtcbiAgICAgIGVsLnJlbW92ZUNsaXBQYXRoKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNsaXBQYXRoT3B0KSB7XG4gICAgdmFyIGNsaXBQYXRoID0gZWwuZ2V0Q2xpcFBhdGgoKTtcbiAgICBpZiAoY2xpcFBhdGggJiYgZG9lc0VsTmVlZFJlY3JlYXRlKGNsaXBQYXRoLCBjbGlwUGF0aE9wdCwgc2VyaWVzTW9kZWwpKSB7XG4gICAgICBjbGlwUGF0aCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghY2xpcFBhdGgpIHtcbiAgICAgIGNsaXBQYXRoID0gY3JlYXRlRWwoY2xpcFBhdGhPcHQpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KGlzUGF0aChjbGlwUGF0aCksICdPbmx5IGFueSB0eXBlIG9mIGBwYXRoYCBjYW4gYmUgdXNlZCBpbiBgY2xpcFBhdGhgLCByYXRoZXIgdGhhbiAnICsgY2xpcFBhdGgudHlwZSArICcuJyk7XG4gICAgICB9XG4gICAgICBlbC5zZXRDbGlwUGF0aChjbGlwUGF0aCk7XG4gICAgfVxuICAgIHVwZGF0ZUVsTm9ybWFsKG51bGwsIGNsaXBQYXRoLCBkYXRhSW5kZXgsIGNsaXBQYXRoT3B0LCBudWxsLCBzZXJpZXNNb2RlbCwgaXNJbml0KTtcbiAgfVxuICAvLyBJZiBub3QgZGVmaW5lIGBjbGlwUGF0aGAgaW4gb3B0aW9uLCBkbyBub3RoaW5nIHVubmVjZXNzYXJ5LlxufVxuZnVuY3Rpb24gZG9DcmVhdGVPclVwZGF0ZUF0dGFjaGVkVHgoZWwsIGRhdGFJbmRleCwgZWxPcHRpb24sIHNlcmllc01vZGVsLCBpc0luaXQsIGF0dGFjaGVkVHhJbmZvKSB7XG4gIC8vIEdyb3VwIGRvZXMgbm90IHN1cHBvcnQgdGV4dENvbnRlbnQgdGVtcG9yYXJpbHkgdW50aWwgbmVjZXNzYXJ5LlxuICBpZiAoZWwuaXNHcm91cCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3JtYWwgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGVtcGhhc2lzLCBmb3IgYGlzTGVnYWN5YCBkZXRlY3Rpb24uXG4gIHByb2Nlc3NUeEluZm8oZWxPcHRpb24sIG51bGwsIGF0dGFjaGVkVHhJbmZvKTtcbiAgcHJvY2Vzc1R4SW5mbyhlbE9wdGlvbiwgRU1QSEFTSVMsIGF0dGFjaGVkVHhJbmZvKTtcbiAgLy8gSWYgYGVsT3B0aW9uLnRleHRDb25maWdgIG9yIGBlbE9wdGlvbi50ZXh0Q29udGVudGAgaXMgbnVsbC91bmRlZmluZWQsIGl0IGRvZXMgbm90IG1ha2Ugc2Vuc2UuXG4gIC8vIFNvIGZvciBzaW1wbGljaXR5LCBpZiBcImVsT3B0aW9uIGhhc093blByb3BlcnR5IG9mIHRoZW0gYnV0IGJlIG51bGwvdW5kZWZpbmVkXCIsIHdlIGRvIG5vdFxuICAvLyB0cmFkZSB0aGVtIGFzIHNldCB0byBudWxsIHRvIGVsLlxuICAvLyBFc3BlY2lhbGx5OlxuICAvLyBgZWxPcHRpb24udGV4dENvbnRlbnQ6IGZhbHNlYCBtZWFucyByZW1vdmUgdGV4dENvbnRlbnQuXG4gIC8vIGBlbE9wdGlvbi50ZXh0Q29udGVudC5lbXBoYXNpcy5zdHlsZTogZmFsc2VgIG1lYW5zIHJlbW92ZSB0aGUgc3R5bGUgZnJvbSBlbXBoYXNpcyBzdGF0ZS5cbiAgdmFyIHR4Q29uT3B0Tm9ybWFsID0gYXR0YWNoZWRUeEluZm8ubm9ybWFsLmNvbk9wdDtcbiAgdmFyIHR4Q29uT3B0RW1waGFzaXMgPSBhdHRhY2hlZFR4SW5mby5lbXBoYXNpcy5jb25PcHQ7XG4gIHZhciB0eENvbk9wdEJsdXIgPSBhdHRhY2hlZFR4SW5mby5ibHVyLmNvbk9wdDtcbiAgdmFyIHR4Q29uT3B0U2VsZWN0ID0gYXR0YWNoZWRUeEluZm8uc2VsZWN0LmNvbk9wdDtcbiAgaWYgKHR4Q29uT3B0Tm9ybWFsICE9IG51bGwgfHwgdHhDb25PcHRFbXBoYXNpcyAhPSBudWxsIHx8IHR4Q29uT3B0U2VsZWN0ICE9IG51bGwgfHwgdHhDb25PcHRCbHVyICE9IG51bGwpIHtcbiAgICB2YXIgdGV4dENvbnRlbnQgPSBlbC5nZXRUZXh0Q29udGVudCgpO1xuICAgIGlmICh0eENvbk9wdE5vcm1hbCA9PT0gZmFsc2UpIHtcbiAgICAgIHRleHRDb250ZW50ICYmIGVsLnJlbW92ZVRleHRDb250ZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR4Q29uT3B0Tm9ybWFsID0gYXR0YWNoZWRUeEluZm8ubm9ybWFsLmNvbk9wdCA9IHR4Q29uT3B0Tm9ybWFsIHx8IHtcbiAgICAgICAgdHlwZTogJ3RleHQnXG4gICAgICB9O1xuICAgICAgaWYgKCF0ZXh0Q29udGVudCkge1xuICAgICAgICB0ZXh0Q29udGVudCA9IGNyZWF0ZUVsKHR4Q29uT3B0Tm9ybWFsKTtcbiAgICAgICAgZWwuc2V0VGV4dENvbnRlbnQodGV4dENvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgaW4gc29tZSBjYXNlIHRoZSBwZXJmb3JtYW5jZSBpc3N1ZSBhcmlzZWQsIGNvbnNpZGVyXG4gICAgICAgIC8vIGRvIG5vdCBjbGVhclN0YXRlIGJ1dCB1cGRhdGUgY2FjaGVkIG5vcm1hbCBzdGF0ZSBkaXJlY3RseS5cbiAgICAgICAgdGV4dENvbnRlbnQuY2xlYXJTdGF0ZXMoKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZUVsTm9ybWFsKG51bGwsIHRleHRDb250ZW50LCBkYXRhSW5kZXgsIHR4Q29uT3B0Tm9ybWFsLCBudWxsLCBzZXJpZXNNb2RlbCwgaXNJbml0KTtcbiAgICAgIHZhciB0eENvblN0bE9wdE5vcm1hbCA9IHR4Q29uT3B0Tm9ybWFsICYmIHR4Q29uT3B0Tm9ybWFsLnN0eWxlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTVEFURVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN0YXRlTmFtZSA9IFNUQVRFU1tpXTtcbiAgICAgICAgaWYgKHN0YXRlTmFtZSAhPT0gTk9STUFMKSB7XG4gICAgICAgICAgdmFyIHR4Q29uT3B0T3RoZXJTdGF0ZSA9IGF0dGFjaGVkVHhJbmZvW3N0YXRlTmFtZV0uY29uT3B0O1xuICAgICAgICAgIHVwZGF0ZUVsT25TdGF0ZShzdGF0ZU5hbWUsIHRleHRDb250ZW50LCB0eENvbk9wdE90aGVyU3RhdGUsIHJldHJpZXZlU3R5bGVPcHRpb25PblN0YXRlKHR4Q29uT3B0Tm9ybWFsLCB0eENvbk9wdE90aGVyU3RhdGUsIHN0YXRlTmFtZSksIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0eENvblN0bE9wdE5vcm1hbCA/IHRleHRDb250ZW50LmRpcnR5KCkgOiB0ZXh0Q29udGVudC5tYXJrUmVkcmF3KCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzVHhJbmZvKGVsT3B0aW9uLCBzdGF0ZSwgYXR0YWNoZWRUeEluZm8pIHtcbiAgdmFyIHN0YXRlT3B0ID0gIXN0YXRlID8gZWxPcHRpb24gOiByZXRyaWV2ZVN0YXRlT3B0aW9uKGVsT3B0aW9uLCBzdGF0ZSk7XG4gIHZhciBzdHlsZU9wdCA9ICFzdGF0ZSA/IGVsT3B0aW9uLnN0eWxlIDogcmV0cmlldmVTdHlsZU9wdGlvbk9uU3RhdGUoZWxPcHRpb24sIHN0YXRlT3B0LCBFTVBIQVNJUyk7XG4gIHZhciBlbFR5cGUgPSBlbE9wdGlvbi50eXBlO1xuICB2YXIgdHhDZmcgPSBzdGF0ZU9wdCA/IHN0YXRlT3B0LnRleHRDb25maWcgOiBudWxsO1xuICB2YXIgdHhDb25PcHROb3JtYWwgPSBlbE9wdGlvbi50ZXh0Q29udGVudDtcbiAgdmFyIHR4Q29uT3B0ID0gIXR4Q29uT3B0Tm9ybWFsID8gbnVsbCA6ICFzdGF0ZSA/IHR4Q29uT3B0Tm9ybWFsIDogcmV0cmlldmVTdGF0ZU9wdGlvbih0eENvbk9wdE5vcm1hbCwgc3RhdGUpO1xuICBpZiAoc3R5bGVPcHQgJiYgKFxuICAvLyBCZWNhdXNlIGVtcGhhc2lzIHN0eWxlIGhhcyBsaXR0bGUgaW5mbyB0byBkZXRlY3QgbGVnYWN5LFxuICAvLyBpZiBub3JtYWwgaXMgbGVnYWN5LCBlbXBoYXNpcyBpcyB0cmFkZSBhcyBsZWdhY3kuXG4gIGF0dGFjaGVkVHhJbmZvLmlzTGVnYWN5IHx8IGlzRUM0Q29tcGF0aWJsZVN0eWxlKHN0eWxlT3B0LCBlbFR5cGUsICEhdHhDZmcsICEhdHhDb25PcHQpKSkge1xuICAgIGF0dGFjaGVkVHhJbmZvLmlzTGVnYWN5ID0gdHJ1ZTtcbiAgICB2YXIgY29udmVydFJlc3VsdCA9IGNvbnZlcnRGcm9tRUM0Q29tcGF0aWJsZVN0eWxlKHN0eWxlT3B0LCBlbFR5cGUsICFzdGF0ZSk7XG4gICAgLy8gRXhwbGljaXRseSBzcGVjaWZpZWQgYHRleHRDb25maWdgIGFuZCBgdGV4dENvbnRlbnRgIGhhcyBoaWdoZXIgcHJpb3JpdHkgdGhhblxuICAgIC8vIHRoZSBvbmVzIGdlbmVyYXRlZCBieSBsZWdhY3kgc3R5bGUuIE90aGVyd2lzZSBpZiB1c2VycyB1c2UgdGhlbSBhbmQgYGFwaS5zdHlsZWBcbiAgICAvLyBhdCB0aGUgc2FtZSB0aW1lLCB0aGV5IG5vdCBib3RoIHdvcmsgYW5kIGhhcmRseSB0byBrbm93biB3aHkuXG4gICAgaWYgKCF0eENmZyAmJiBjb252ZXJ0UmVzdWx0LnRleHRDb25maWcpIHtcbiAgICAgIHR4Q2ZnID0gY29udmVydFJlc3VsdC50ZXh0Q29uZmlnO1xuICAgIH1cbiAgICBpZiAoIXR4Q29uT3B0ICYmIGNvbnZlcnRSZXN1bHQudGV4dENvbnRlbnQpIHtcbiAgICAgIHR4Q29uT3B0ID0gY29udmVydFJlc3VsdC50ZXh0Q29udGVudDtcbiAgICB9XG4gIH1cbiAgaWYgKCFzdGF0ZSAmJiB0eENvbk9wdCkge1xuICAgIHZhciB0eENvbk9wdE5vcm1hbF8xID0gdHhDb25PcHQ7XG4gICAgLy8gYHRleHRDb250ZW50OiB7dHlwZTogJ3RleHQnfWAsIHRoZSBcInR5cGVcIiBpcyBlYXN5IHRvIGJlIG1pc3NpbmcuIFNvIHdlIHRvbGVyYXRlIGl0LlxuICAgICF0eENvbk9wdE5vcm1hbF8xLnR5cGUgJiYgKHR4Q29uT3B0Tm9ybWFsXzEudHlwZSA9ICd0ZXh0Jyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIERvIG5vdCB0b2xlcmF0ZSBpbmNvcnJjZXQgdHlwZSBmb3IgZm9yd2FyZCBjb21wYXQuXG4gICAgICBhc3NlcnQodHhDb25PcHROb3JtYWxfMS50eXBlID09PSAndGV4dCcsICd0ZXh0Q29udGVudC50eXBlIG11c3QgYmUgXCJ0ZXh0XCInKTtcbiAgICB9XG4gIH1cbiAgdmFyIGluZm8gPSAhc3RhdGUgPyBhdHRhY2hlZFR4SW5mby5ub3JtYWwgOiBhdHRhY2hlZFR4SW5mb1tzdGF0ZV07XG4gIGluZm8uY2ZnID0gdHhDZmc7XG4gIGluZm8uY29uT3B0ID0gdHhDb25PcHQ7XG59XG5mdW5jdGlvbiByZXRyaWV2ZVN0YXRlT3B0aW9uKGVsT3B0aW9uLCBzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlID8gZWxPcHRpb24gOiBlbE9wdGlvbiA/IGVsT3B0aW9uW3N0YXRlXSA6IG51bGw7XG59XG5mdW5jdGlvbiByZXRyaWV2ZVN0eWxlT3B0aW9uT25TdGF0ZShzdGF0ZU9wdGlvbk5vcm1hbCwgc3RhdGVPcHRpb24sIHN0YXRlKSB7XG4gIHZhciBzdHlsZSA9IHN0YXRlT3B0aW9uICYmIHN0YXRlT3B0aW9uLnN0eWxlO1xuICBpZiAoc3R5bGUgPT0gbnVsbCAmJiBzdGF0ZSA9PT0gRU1QSEFTSVMgJiYgc3RhdGVPcHRpb25Ob3JtYWwpIHtcbiAgICBzdHlsZSA9IHN0YXRlT3B0aW9uTm9ybWFsLnN0eWxlRW1waGFzaXM7XG4gIH1cbiAgcmV0dXJuIHN0eWxlO1xufVxuLy8gVXNhZ2U6XG4vLyAoMSkgQnkgZGVmYXVsdCwgYGVsT3B0aW9uLiRtZXJnZUNoaWxkcmVuYCBpcyBgJ2J5SW5kZXgnYCwgd2hpY2ggaW5kaWNhdGVzXG4vLyAgICAgdGhhdCB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gd2lsbCBub3QgYmUgcmVtb3ZlZCwgYW5kIGVuYWJsZXMgdGhlIGZlYXR1cmVcbi8vICAgICB0aGF0IHVwZGF0ZSBzb21lIG9mIHRoZSBwcm9wcyBvZiBzb21lIG9mIHRoZSBjaGlsZHJlbiBzaW1wbHkgYnkgY29uc3RydWN0XG4vLyAgICAgdGhlIHJldHVybmVkIGNoaWxkcmVuIG9mIGByZW5kZXJJdGVtYCBsaWtlOlxuLy8gICAgIGB2YXIgY2hpbGRyZW4gPSBncm91cC5jaGlsZHJlbiA9IFtdOyBjaGlsZHJlblszXSA9IHtvcGFjaXR5OiAwLjV9O2Bcbi8vICgyKSBJZiBgZWxPcHRpb24uJG1lcmdlQ2hpbGRyZW5gIGlzIGAnYnlOYW1lJ2AsIGFkZC91cGRhdGUvcmVtb3ZlIGNoaWxkcmVuXG4vLyAgICAgYnkgY2hpbGQubmFtZS4gQnV0IHRoYXQgbWlnaHQgYmUgbG93ZXIgcGVyZm9ybWFuY2UuXG4vLyAoMykgSWYgYGVsT3B0aW9uLiRtZXJnZUNoaWxkcmVuYCBpcyBgZmFsc2VgLCB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gd2lsbCBiZVxuLy8gICAgIHJlcGxhY2VkIHRvdGFsbHkuXG4vLyAoNCkgSWYgYCFlbE9wdGlvbi5jaGlsZHJlbmAsIGZvbGxvd2luZyB0aGUgXCJtZXJnZVwiIHByaW5jaXBsZSwgbm90aGluZyB3aWxsXG4vLyAgICAgaGFwcGVuLlxuLy8gKDUpIElmIGBlbE9wdGlvbi4kbWVyZ2VDaGlsZHJlbmAgaXMgbm90IGBmYWxzZWAgbmVpdGhlciBgJ2J5TmFtZSdgIGFuZCB0aGVcbi8vICAgICBgZWxgIGlzIGEgZ3JvdXAsIGFuZCBpZiBhbnkgb2YgdGhlIG5ldyBjaGlsZCBpcyBudWxsLCBpdCBtZWFucyB0byByZW1vdmVcbi8vICAgICB0aGUgZWxlbWVudCBhdCB0aGUgc2FtZSBpbmRleCwgaWYgZXhpc3RzLiBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgdGhlIG5ld1xuLy8gICAgIGNoaWxkIGlzIGFuZCBlbXB0eSBvYmplY3QgYHt9YCwgaXQgbWVhbnMgdG8ga2VlcCB0aGUgZWxlbWVudCBub3QgY2hhbmdlZC5cbi8vXG4vLyBGb3IgaW1wbGVtZW50YXRpb24gc2ltcGxlbmVzcywgZG8gbm90IHByb3ZpZGUgYSBkaXJlY3Qgd2F5IHRvIHJlbW92ZSBzaW5nbGVcbi8vIGNoaWxkIChvdGhlcndpc2UgdGhlIHRvdGFsIGluZGljZXMgb2YgdGhlIGNoaWxkcmVuIGFycmF5IGhhdmUgdG8gYmUgbW9kaWZpZWQpLlxuLy8gVXNlciBjYW4gcmVtb3ZlIGEgc2luZ2xlIGNoaWxkIGJ5IHNldHRpbmcgaXRzIGBpZ25vcmVgIHRvIGB0cnVlYC5cbmZ1bmN0aW9uIG1lcmdlQ2hpbGRyZW4oYXBpLCBlbCwgZGF0YUluZGV4LCBlbE9wdGlvbiwgc2VyaWVzTW9kZWwpIHtcbiAgdmFyIG5ld0NoaWxkcmVuID0gZWxPcHRpb24uY2hpbGRyZW47XG4gIHZhciBuZXdMZW4gPSBuZXdDaGlsZHJlbiA/IG5ld0NoaWxkcmVuLmxlbmd0aCA6IDA7XG4gIHZhciBtZXJnZUNoaWxkcmVuID0gZWxPcHRpb24uJG1lcmdlQ2hpbGRyZW47XG4gIC8vIGBkaWZmQ2hpbGRyZW5CeU5hbWVgIGhhcyBiZWVuIGRlcHJlY2F0ZWQuXG4gIHZhciBieU5hbWUgPSBtZXJnZUNoaWxkcmVuID09PSAnYnlOYW1lJyB8fCBlbE9wdGlvbi5kaWZmQ2hpbGRyZW5CeU5hbWU7XG4gIHZhciBub3RNZXJnZSA9IG1lcmdlQ2hpbGRyZW4gPT09IGZhbHNlO1xuICAvLyBGb3IgYmV0dGVyIHBlcmZvcm1hbmNlIG9uIHJvYW0gdXBkYXRlLCBvbmx5IGVudGVyIGlmIG5lY2Vzc2FyeS5cbiAgaWYgKCFuZXdMZW4gJiYgIWJ5TmFtZSAmJiAhbm90TWVyZ2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGJ5TmFtZSkge1xuICAgIGRpZmZHcm91cENoaWxkcmVuKHtcbiAgICAgIGFwaTogYXBpLFxuICAgICAgb2xkQ2hpbGRyZW46IGVsLmNoaWxkcmVuKCkgfHwgW10sXG4gICAgICBuZXdDaGlsZHJlbjogbmV3Q2hpbGRyZW4gfHwgW10sXG4gICAgICBkYXRhSW5kZXg6IGRhdGFJbmRleCxcbiAgICAgIHNlcmllc01vZGVsOiBzZXJpZXNNb2RlbCxcbiAgICAgIGdyb3VwOiBlbFxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBub3RNZXJnZSAmJiBlbC5yZW1vdmVBbGwoKTtcbiAgLy8gTWFwcGluZyBjaGlsZHJlbiBvZiBhIGdyb3VwIHNpbXBseSBieSBpbmRleCwgd2hpY2hcbiAgLy8gbWlnaHQgYmUgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICB2YXIgaW5kZXggPSAwO1xuICBmb3IgKDsgaW5kZXggPCBuZXdMZW47IGluZGV4KyspIHtcbiAgICB2YXIgbmV3Q2hpbGQgPSBuZXdDaGlsZHJlbltpbmRleF07XG4gICAgdmFyIG9sZENoaWxkID0gZWwuY2hpbGRBdChpbmRleCk7XG4gICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICBpZiAobmV3Q2hpbGQuaWdub3JlID09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlIG9sZCBjaGlsZCBpcyBzZXQgdG8gYmUgaWdub3JlZCBpZiBudWxsIChzZWUgY29tbWVudHNcbiAgICAgICAgLy8gYmVsb3cpLiBTbyB3ZSBuZWVkIHRvIHNldCBpZ25vcmUgdG8gYmUgZmFsc2UgYmFjay5cbiAgICAgICAgbmV3Q2hpbGQuaWdub3JlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBkb0NyZWF0ZU9yVXBkYXRlRWwoYXBpLCBvbGRDaGlsZCwgZGF0YUluZGV4LCBuZXdDaGlsZCwgc2VyaWVzTW9kZWwsIGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KG9sZENoaWxkLCAncmVuZGVySXRlbSBzaG91bGQgbm90IHJldHVybiBhIGdyb3VwIGNvbnRhaW5pbmcgZWxlbWVudHMnICsgJyBhcyBudWxsL3VuZGVmaW5lZC97fSBpZiB0aGV5IGRvIG5vdCBleGlzdCBiZWZvcmUuJyk7XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgbmV3IGVsZW1lbnQgb3B0aW9uIGlzIG51bGwsIGl0IG1lYW5zIHRvIHJlbW92ZSB0aGUgb2xkXG4gICAgICAvLyBlbGVtZW50LiBCdXQgd2UgY2Fubm90IHJlYWxseSByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgZ3JvdXBcbiAgICAgIC8vIGRpcmVjdGx5LCBiZWNhdXNlIHRoZSBlbGVtZW50IG9yZGVyIG1heSBub3QgYmUgc3RhYmxlIHdoZW4gdGhpc1xuICAgICAgLy8gZWxlbWVudCBpcyBhZGRlZCBiYWNrLiBTbyB3ZSBzZXQgdGhlIGVsZW1lbnQgdG8gYmUgaWdub3JlZC5cbiAgICAgIG9sZENoaWxkLmlnbm9yZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSBlbC5jaGlsZENvdW50KCkgLSAxOyBpID49IGluZGV4OyBpLS0pIHtcbiAgICB2YXIgY2hpbGQgPSBlbC5jaGlsZEF0KGkpO1xuICAgIHJlbW92ZUNoaWxkRnJvbUdyb3VwKGVsLCBjaGlsZCwgc2VyaWVzTW9kZWwpO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVDaGlsZEZyb21Hcm91cChncm91cCwgY2hpbGQsIHNlcmllc01vZGVsKSB7XG4gIC8vIERvIG5vdCBzdXBwb3J0IGxlYXZlIGVsZW1lbnRzIHRoYXQgYXJlIG5vdCBtZW50aW9uZWQgaW4gdGhlIGxhdGVzdFxuICAvLyBgcmVuZGVySXRlbWAgcmV0dXJuLiBPdGhlcndpc2UgdXNlcnMgbWF5IG5vdCBoYXZlIGEgY2xlYXIgYW5kIHNpbXBsZVxuICAvLyBjb25jZXB0IHRoYXQgaG93IHRvIGNvbnRyb2wgYWxsIG9mIHRoZSBlbGVtZW50cy5cbiAgY2hpbGQgJiYgYXBwbHlMZWF2ZVRyYW5zaXRpb24oY2hpbGQsIGN1c3RvbUlubmVyU3RvcmUoZ3JvdXApLm9wdGlvbiwgc2VyaWVzTW9kZWwpO1xufVxuZnVuY3Rpb24gZGlmZkdyb3VwQ2hpbGRyZW4oY29udGV4dCkge1xuICBuZXcgRGF0YURpZmZlcihjb250ZXh0Lm9sZENoaWxkcmVuLCBjb250ZXh0Lm5ld0NoaWxkcmVuLCBnZXRLZXksIGdldEtleSwgY29udGV4dCkuYWRkKHByb2Nlc3NBZGRVcGRhdGUpLnVwZGF0ZShwcm9jZXNzQWRkVXBkYXRlKS5yZW1vdmUocHJvY2Vzc1JlbW92ZSkuZXhlY3V0ZSgpO1xufVxuZnVuY3Rpb24gZ2V0S2V5KGl0ZW0sIGlkeCkge1xuICB2YXIgbmFtZSA9IGl0ZW0gJiYgaXRlbS5uYW1lO1xuICByZXR1cm4gbmFtZSAhPSBudWxsID8gbmFtZSA6IEdST1VQX0RJRkZfUFJFRklYICsgaWR4O1xufVxuZnVuY3Rpb24gcHJvY2Vzc0FkZFVwZGF0ZShuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gIHZhciBjaGlsZE9wdGlvbiA9IG5ld0luZGV4ICE9IG51bGwgPyBjb250ZXh0Lm5ld0NoaWxkcmVuW25ld0luZGV4XSA6IG51bGw7XG4gIHZhciBjaGlsZCA9IG9sZEluZGV4ICE9IG51bGwgPyBjb250ZXh0Lm9sZENoaWxkcmVuW29sZEluZGV4XSA6IG51bGw7XG4gIGRvQ3JlYXRlT3JVcGRhdGVFbChjb250ZXh0LmFwaSwgY2hpbGQsIGNvbnRleHQuZGF0YUluZGV4LCBjaGlsZE9wdGlvbiwgY29udGV4dC5zZXJpZXNNb2RlbCwgY29udGV4dC5ncm91cCk7XG59XG5mdW5jdGlvbiBwcm9jZXNzUmVtb3ZlKG9sZEluZGV4KSB7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICB2YXIgY2hpbGQgPSBjb250ZXh0Lm9sZENoaWxkcmVuW29sZEluZGV4XTtcbiAgY2hpbGQgJiYgYXBwbHlMZWF2ZVRyYW5zaXRpb24oY2hpbGQsIGN1c3RvbUlubmVyU3RvcmUoY2hpbGQpLm9wdGlvbiwgY29udGV4dC5zZXJpZXNNb2RlbCk7XG59XG4vKipcclxuICogQHJldHVybiBTVkcgUGF0aCBkYXRhLlxyXG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhEYXRhKHNoYXBlKSB7XG4gIC8vIFwiZFwiIGZvbGxvd3MgdGhlIFNWRyBjb252ZW50aW9uLlxuICByZXR1cm4gc2hhcGUgJiYgKHNoYXBlLnBhdGhEYXRhIHx8IHNoYXBlLmQpO1xufVxuZnVuY3Rpb24gaGFzT3duUGF0aERhdGEoc2hhcGUpIHtcbiAgcmV0dXJuIHNoYXBlICYmIChoYXNPd24oc2hhcGUsICdwYXRoRGF0YScpIHx8IGhhc093bihzaGFwZSwgJ2QnKSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgQ3VzdG9tU2VyaWVzTW9kZWwgZnJvbSAnLi9DdXN0b21TZXJpZXMuanMnO1xuaW1wb3J0IEN1c3RvbUNoYXJ0VmlldyBmcm9tICcuL0N1c3RvbVZpZXcuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhDdXN0b21DaGFydFZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChDdXN0b21TZXJpZXNNb2RlbCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///27288\n")},51719:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js\nvar whiskerBoxCommon = __webpack_require__(15501);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n;// ./node_modules/echarts/lib/chart/boxplot/BoxplotSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar BoxplotSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(BoxplotSeriesModel, _super);\n  function BoxplotSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = BoxplotSeriesModel.type;\n    // TODO\n    // box width represents group size, so dimension should have 'size'.\n    /**\r\n     * @see <https://en.wikipedia.org/wiki/Box_plot>\r\n     * The meanings of 'min' and 'max' depend on user,\r\n     * and echarts do not need to know it.\r\n     * @readOnly\r\n     */\n    _this.defaultValueDimensions = [{\n      name: 'min',\n      defaultTooltip: true\n    }, {\n      name: 'Q1',\n      defaultTooltip: true\n    }, {\n      name: 'median',\n      defaultTooltip: true\n    }, {\n      name: 'Q3',\n      defaultTooltip: true\n    }, {\n      name: 'max',\n      defaultTooltip: true\n    }];\n    _this.visualDrawType = 'stroke';\n    return _this;\n  }\n  BoxplotSeriesModel.type = 'series.boxplot';\n  BoxplotSeriesModel.dependencies = ['xAxis', 'yAxis', 'grid'];\n  BoxplotSeriesModel.defaultOption = {\n    // zlevel: 0,\n    z: 2,\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    layout: null,\n    boxWidth: [7, 50],\n    itemStyle: {\n      color: '#fff',\n      borderWidth: 1\n    },\n    emphasis: {\n      scale: true,\n      itemStyle: {\n        borderWidth: 2,\n        shadowBlur: 5,\n        shadowOffsetX: 1,\n        shadowOffsetY: 1,\n        shadowColor: 'rgba(0,0,0,0.2)'\n      }\n    },\n    animationDuration: 800\n  };\n  return BoxplotSeriesModel;\n}(Series/* default */.A);\n(0,util.mixin)(BoxplotSeriesModel, whiskerBoxCommon/* WhiskerBoxCommonMixin */.n, true);\n/* harmony default export */ const BoxplotSeries = (BoxplotSeriesModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Path.js\nvar Path = __webpack_require__(59482);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n;// ./node_modules/echarts/lib/chart/boxplot/BoxplotView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar BoxplotView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(BoxplotView, _super);\n  function BoxplotView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = BoxplotView.type;\n    return _this;\n  }\n  BoxplotView.prototype.render = function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    var group = this.group;\n    var oldData = this._data;\n    // There is no old data only when first rendering or switching from\n    // stream mode to normal mode, where previous elements should be removed.\n    if (!this._data) {\n      group.removeAll();\n    }\n    var constDim = seriesModel.get('layout') === 'horizontal' ? 1 : 0;\n    data.diff(oldData).add(function (newIdx) {\n      if (data.hasValue(newIdx)) {\n        var itemLayout = data.getItemLayout(newIdx);\n        var symbolEl = createNormalBox(itemLayout, data, newIdx, constDim, true);\n        data.setItemGraphicEl(newIdx, symbolEl);\n        group.add(symbolEl);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var symbolEl = oldData.getItemGraphicEl(oldIdx);\n      // Empty data\n      if (!data.hasValue(newIdx)) {\n        group.remove(symbolEl);\n        return;\n      }\n      var itemLayout = data.getItemLayout(newIdx);\n      if (!symbolEl) {\n        symbolEl = createNormalBox(itemLayout, data, newIdx, constDim);\n      } else {\n        (0,basicTransition/* saveOldStyle */.ap)(symbolEl);\n        updateNormalBoxData(itemLayout, symbolEl, data, newIdx);\n      }\n      group.add(symbolEl);\n      data.setItemGraphicEl(newIdx, symbolEl);\n    }).remove(function (oldIdx) {\n      var el = oldData.getItemGraphicEl(oldIdx);\n      el && group.remove(el);\n    }).execute();\n    this._data = data;\n  };\n  BoxplotView.prototype.remove = function (ecModel) {\n    var group = this.group;\n    var data = this._data;\n    this._data = null;\n    data && data.eachItemGraphicEl(function (el) {\n      el && group.remove(el);\n    });\n  };\n  BoxplotView.type = 'boxplot';\n  return BoxplotView;\n}(Chart/* default */.A);\nvar BoxPathShape = /** @class */function () {\n  function BoxPathShape() {}\n  return BoxPathShape;\n}();\nvar BoxPath = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(BoxPath, _super);\n  function BoxPath(opts) {\n    var _this = _super.call(this, opts) || this;\n    _this.type = 'boxplotBoxPath';\n    return _this;\n  }\n  BoxPath.prototype.getDefaultShape = function () {\n    return new BoxPathShape();\n  };\n  BoxPath.prototype.buildPath = function (ctx, shape) {\n    var ends = shape.points;\n    var i = 0;\n    ctx.moveTo(ends[i][0], ends[i][1]);\n    i++;\n    for (; i < 4; i++) {\n      ctx.lineTo(ends[i][0], ends[i][1]);\n    }\n    ctx.closePath();\n    for (; i < ends.length; i++) {\n      ctx.moveTo(ends[i][0], ends[i][1]);\n      i++;\n      ctx.lineTo(ends[i][0], ends[i][1]);\n    }\n  };\n  return BoxPath;\n}(Path/* default */.Ay);\nfunction createNormalBox(itemLayout, data, dataIndex, constDim, isInit) {\n  var ends = itemLayout.ends;\n  var el = new BoxPath({\n    shape: {\n      points: isInit ? transInit(ends, constDim, itemLayout) : ends\n    }\n  });\n  updateNormalBoxData(itemLayout, el, data, dataIndex, isInit);\n  return el;\n}\nfunction updateNormalBoxData(itemLayout, el, data, dataIndex, isInit) {\n  var seriesModel = data.hostModel;\n  var updateMethod = graphic[isInit ? 'initProps' : 'updateProps'];\n  updateMethod(el, {\n    shape: {\n      points: itemLayout.ends\n    }\n  }, seriesModel, dataIndex);\n  el.useStyle(data.getItemVisual(dataIndex, 'style'));\n  el.style.strokeNoScale = true;\n  el.z2 = 100;\n  var itemModel = data.getItemModel(dataIndex);\n  var emphasisModel = itemModel.getModel('emphasis');\n  (0,states/* setStatesStylesFromModel */.Mx)(el, itemModel);\n  (0,states/* toggleHoverEmphasis */.Lm)(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n}\nfunction transInit(points, dim, itemLayout) {\n  return util.map(points, function (point) {\n    point = point.slice();\n    point[dim] = itemLayout.initBaseline;\n    return point;\n  });\n}\n/* harmony default export */ const boxplot_BoxplotView = (BoxplotView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n;// ./node_modules/echarts/lib/chart/boxplot/boxplotLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar each = util.each;\nfunction boxplotLayout(ecModel) {\n  var groupResult = groupSeriesByAxis(ecModel);\n  each(groupResult, function (groupItem) {\n    var seriesModels = groupItem.seriesModels;\n    if (!seriesModels.length) {\n      return;\n    }\n    calculateBase(groupItem);\n    each(seriesModels, function (seriesModel, idx) {\n      layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);\n    });\n  });\n}\n/**\r\n * Group series by axis.\r\n */\nfunction groupSeriesByAxis(ecModel) {\n  var result = [];\n  var axisList = [];\n  ecModel.eachSeriesByType('boxplot', function (seriesModel) {\n    var baseAxis = seriesModel.getBaseAxis();\n    var idx = util.indexOf(axisList, baseAxis);\n    if (idx < 0) {\n      idx = axisList.length;\n      axisList[idx] = baseAxis;\n      result[idx] = {\n        axis: baseAxis,\n        seriesModels: []\n      };\n    }\n    result[idx].seriesModels.push(seriesModel);\n  });\n  return result;\n}\n/**\r\n * Calculate offset and box width for each series.\r\n */\nfunction calculateBase(groupItem) {\n  var baseAxis = groupItem.axis;\n  var seriesModels = groupItem.seriesModels;\n  var seriesCount = seriesModels.length;\n  var boxWidthList = groupItem.boxWidthList = [];\n  var boxOffsetList = groupItem.boxOffsetList = [];\n  var boundList = [];\n  var bandWidth;\n  if (baseAxis.type === 'category') {\n    bandWidth = baseAxis.getBandWidth();\n  } else {\n    var maxDataCount_1 = 0;\n    each(seriesModels, function (seriesModel) {\n      maxDataCount_1 = Math.max(maxDataCount_1, seriesModel.getData().count());\n    });\n    var extent = baseAxis.getExtent();\n    bandWidth = Math.abs(extent[1] - extent[0]) / maxDataCount_1;\n  }\n  each(seriesModels, function (seriesModel) {\n    var boxWidthBound = seriesModel.get('boxWidth');\n    if (!util.isArray(boxWidthBound)) {\n      boxWidthBound = [boxWidthBound, boxWidthBound];\n    }\n    boundList.push([(0,number/* parsePercent */.lo)(boxWidthBound[0], bandWidth) || 0, (0,number/* parsePercent */.lo)(boxWidthBound[1], bandWidth) || 0]);\n  });\n  var availableWidth = bandWidth * 0.8 - 2;\n  var boxGap = availableWidth / seriesCount * 0.3;\n  var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;\n  var base = boxWidth / 2 - availableWidth / 2;\n  each(seriesModels, function (seriesModel, idx) {\n    boxOffsetList.push(base);\n    base += boxGap + boxWidth;\n    boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));\n  });\n}\n/**\r\n * Calculate points location for each series.\r\n */\nfunction layoutSingleSeries(seriesModel, offset, boxWidth) {\n  var coordSys = seriesModel.coordinateSystem;\n  var data = seriesModel.getData();\n  var halfWidth = boxWidth / 2;\n  var cDimIdx = seriesModel.get('layout') === 'horizontal' ? 0 : 1;\n  var vDimIdx = 1 - cDimIdx;\n  var coordDims = ['x', 'y'];\n  var cDim = data.mapDimension(coordDims[cDimIdx]);\n  var vDims = data.mapDimensionsAll(coordDims[vDimIdx]);\n  if (cDim == null || vDims.length < 5) {\n    return;\n  }\n  for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {\n    var axisDimVal = data.get(cDim, dataIndex);\n    var median = getPoint(axisDimVal, vDims[2], dataIndex);\n    var end1 = getPoint(axisDimVal, vDims[0], dataIndex);\n    var end2 = getPoint(axisDimVal, vDims[1], dataIndex);\n    var end4 = getPoint(axisDimVal, vDims[3], dataIndex);\n    var end5 = getPoint(axisDimVal, vDims[4], dataIndex);\n    var ends = [];\n    addBodyEnd(ends, end2, false);\n    addBodyEnd(ends, end4, true);\n    ends.push(end1, end2, end5, end4);\n    layEndLine(ends, end1);\n    layEndLine(ends, end5);\n    layEndLine(ends, median);\n    data.setItemLayout(dataIndex, {\n      initBaseline: median[vDimIdx],\n      ends: ends\n    });\n  }\n  function getPoint(axisDimVal, dim, dataIndex) {\n    var val = data.get(dim, dataIndex);\n    var p = [];\n    p[cDimIdx] = axisDimVal;\n    p[vDimIdx] = val;\n    var point;\n    if (isNaN(axisDimVal) || isNaN(val)) {\n      point = [NaN, NaN];\n    } else {\n      point = coordSys.dataToPoint(p);\n      point[cDimIdx] += offset;\n    }\n    return point;\n  }\n  function addBodyEnd(ends, point, start) {\n    var point1 = point.slice();\n    var point2 = point.slice();\n    point1[cDimIdx] += halfWidth;\n    point2[cDimIdx] -= halfWidth;\n    start ? ends.push(point1, point2) : ends.push(point2, point1);\n  }\n  function layEndLine(ends, endCenter) {\n    var from = endCenter.slice();\n    var to = endCenter.slice();\n    from[cDimIdx] -= halfWidth;\n    to[cDimIdx] += halfWidth;\n    ends.push(from, to);\n  }\n}\n;// ./node_modules/echarts/lib/chart/boxplot/prepareBoxplotData.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n/**\r\n * See:\r\n *  <https://en.wikipedia.org/wiki/Box_plot#cite_note-frigge_hoaglin_iglewicz-2>\r\n *  <http://stat.ethz.ch/R-manual/R-devel/library/grDevices/html/boxplot.stats.html>\r\n *\r\n * Helper method for preparing data.\r\n *\r\n * @param rawData like\r\n *        [\r\n *            [12,232,443], (raw data set for the first box)\r\n *            [3843,5545,1232], (raw data set for the second box)\r\n *            ...\r\n *        ]\r\n * @param opt.boundIQR=1.5 Data less than min bound is outlier.\r\n *      default 1.5, means Q1 - 1.5 * (Q3 - Q1).\r\n *      If 'none'/0 passed, min bound will not be used.\r\n */\nfunction prepareBoxplotData(rawData, opt) {\n  opt = opt || {};\n  var boxData = [];\n  var outliers = [];\n  var boundIQR = opt.boundIQR;\n  var useExtreme = boundIQR === 'none' || boundIQR === 0;\n  for (var i = 0; i < rawData.length; i++) {\n    var ascList = (0,number/* asc */.Y6)(rawData[i].slice());\n    var Q1 = (0,number/* quantile */.YV)(ascList, 0.25);\n    var Q2 = (0,number/* quantile */.YV)(ascList, 0.5);\n    var Q3 = (0,number/* quantile */.YV)(ascList, 0.75);\n    var min = ascList[0];\n    var max = ascList[ascList.length - 1];\n    var bound = (boundIQR == null ? 1.5 : boundIQR) * (Q3 - Q1);\n    var low = useExtreme ? min : Math.max(min, Q1 - bound);\n    var high = useExtreme ? max : Math.min(max, Q3 + bound);\n    var itemNameFormatter = opt.itemNameFormatter;\n    var itemName = (0,util.isFunction)(itemNameFormatter) ? itemNameFormatter({\n      value: i\n    }) : (0,util.isString)(itemNameFormatter) ? itemNameFormatter.replace('{value}', i + '') : i + '';\n    boxData.push([itemName, low, Q1, Q2, Q3, high]);\n    for (var j = 0; j < ascList.length; j++) {\n      var dataItem = ascList[j];\n      if (dataItem < low || dataItem > high) {\n        var outlier = [itemName, dataItem];\n        outliers.push(outlier);\n      }\n    }\n  }\n  return {\n    boxData: boxData,\n    outliers: outliers\n  };\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/log.js\nvar log = __webpack_require__(41025);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/types.js\nvar types = __webpack_require__(13430);\n;// ./node_modules/echarts/lib/chart/boxplot/boxplotTransform.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar boxplotTransform = {\n  type: 'echarts:boxplot',\n  transform: function transform(params) {\n    var upstream = params.upstream;\n    if (upstream.sourceFormat !== types/* SOURCE_FORMAT_ARRAY_ROWS */.Km) {\n      var errMsg = '';\n      if (false) {}\n      (0,log/* throwError */.$8)(errMsg);\n    }\n    var result = prepareBoxplotData(upstream.getRawData(), params.config);\n    return [{\n      dimensions: ['ItemName', 'Low', 'Q1', 'Q2', 'Q3', 'High'],\n      data: result.boxData\n    }, {\n      data: result.outliers\n    }];\n  }\n};\n;// ./node_modules/echarts/lib/chart/boxplot/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nfunction install(registers) {\n  registers.registerSeriesModel(BoxplotSeries);\n  registers.registerChartView(boxplot_BoxplotView);\n  registers.registerLayout(boxplotLayout);\n  registers.registerTransform(boxplotTransform);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE3MTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2JveHBsb3QvQm94cGxvdFNlcmllcy5qcz80ZDllIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ib3hwbG90L0JveHBsb3RWaWV3LmpzPzYzMjgiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2JveHBsb3QvYm94cGxvdExheW91dC5qcz9hMzZkIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ib3hwbG90L3ByZXBhcmVCb3hwbG90RGF0YS5qcz9lN2UzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9ib3hwbG90L2JveHBsb3RUcmFuc2Zvcm0uanM/MjMxZCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYm94cGxvdC9pbnN0YWxsLmpzP2I4OGUiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMuanMnO1xuaW1wb3J0IHsgV2hpc2tlckJveENvbW1vbk1peGluIH0gZnJvbSAnLi4vaGVscGVyL3doaXNrZXJCb3hDb21tb24uanMnO1xuaW1wb3J0IHsgbWl4aW4gfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xudmFyIEJveHBsb3RTZXJpZXNNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhCb3hwbG90U2VyaWVzTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEJveHBsb3RTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gQm94cGxvdFNlcmllc01vZGVsLnR5cGU7XG4gICAgLy8gVE9ET1xuICAgIC8vIGJveCB3aWR0aCByZXByZXNlbnRzIGdyb3VwIHNpemUsIHNvIGRpbWVuc2lvbiBzaG91bGQgaGF2ZSAnc2l6ZScuXG4gICAgLyoqXHJcbiAgICAgKiBAc2VlIDxodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cb3hfcGxvdD5cclxuICAgICAqIFRoZSBtZWFuaW5ncyBvZiAnbWluJyBhbmQgJ21heCcgZGVwZW5kIG9uIHVzZXIsXHJcbiAgICAgKiBhbmQgZWNoYXJ0cyBkbyBub3QgbmVlZCB0byBrbm93IGl0LlxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKi9cbiAgICBfdGhpcy5kZWZhdWx0VmFsdWVEaW1lbnNpb25zID0gW3tcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZGVmYXVsdFRvb2x0aXA6IHRydWVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnUTEnLFxuICAgICAgZGVmYXVsdFRvb2x0aXA6IHRydWVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWVkaWFuJyxcbiAgICAgIGRlZmF1bHRUb29sdGlwOiB0cnVlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1EzJyxcbiAgICAgIGRlZmF1bHRUb29sdGlwOiB0cnVlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ21heCcsXG4gICAgICBkZWZhdWx0VG9vbHRpcDogdHJ1ZVxuICAgIH1dO1xuICAgIF90aGlzLnZpc3VhbERyYXdUeXBlID0gJ3N0cm9rZSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEJveHBsb3RTZXJpZXNNb2RlbC50eXBlID0gJ3Nlcmllcy5ib3hwbG90JztcbiAgQm94cGxvdFNlcmllc01vZGVsLmRlcGVuZGVuY2llcyA9IFsneEF4aXMnLCAneUF4aXMnLCAnZ3JpZCddO1xuICBCb3hwbG90U2VyaWVzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAvLyB6bGV2ZWw6IDAsXG4gICAgejogMixcbiAgICBjb29yZGluYXRlU3lzdGVtOiAnY2FydGVzaWFuMmQnLFxuICAgIGxlZ2VuZEhvdmVyTGluazogdHJ1ZSxcbiAgICBsYXlvdXQ6IG51bGwsXG4gICAgYm94V2lkdGg6IFs3LCA1MF0sXG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICB9LFxuICAgIGVtcGhhc2lzOiB7XG4gICAgICBzY2FsZTogdHJ1ZSxcbiAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgICAgc2hhZG93Qmx1cjogNSxcbiAgICAgICAgc2hhZG93T2Zmc2V0WDogMSxcbiAgICAgICAgc2hhZG93T2Zmc2V0WTogMSxcbiAgICAgICAgc2hhZG93Q29sb3I6ICdyZ2JhKDAsMCwwLDAuMiknXG4gICAgICB9XG4gICAgfSxcbiAgICBhbmltYXRpb25EdXJhdGlvbjogODAwXG4gIH07XG4gIHJldHVybiBCb3hwbG90U2VyaWVzTW9kZWw7XG59KFNlcmllc01vZGVsKTtcbm1peGluKEJveHBsb3RTZXJpZXNNb2RlbCwgV2hpc2tlckJveENvbW1vbk1peGluLCB0cnVlKTtcbmV4cG9ydCBkZWZhdWx0IEJveHBsb3RTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IHsgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsLCB0b2dnbGVIb3ZlckVtcGhhc2lzIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMuanMnO1xuaW1wb3J0IFBhdGggZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzJztcbmltcG9ydCB7IHNhdmVPbGRTdHlsZSB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi9iYXNpY1RyYW5zaXRpb24uanMnO1xudmFyIEJveHBsb3RWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEJveHBsb3RWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBCb3hwbG90VmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gQm94cGxvdFZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgQm94cGxvdFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgLy8gVGhlcmUgaXMgbm8gb2xkIGRhdGEgb25seSB3aGVuIGZpcnN0IHJlbmRlcmluZyBvciBzd2l0Y2hpbmcgZnJvbVxuICAgIC8vIHN0cmVhbSBtb2RlIHRvIG5vcm1hbCBtb2RlLCB3aGVyZSBwcmV2aW91cyBlbGVtZW50cyBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIH1cbiAgICB2YXIgY29uc3REaW0gPSBzZXJpZXNNb2RlbC5nZXQoJ2xheW91dCcpID09PSAnaG9yaXpvbnRhbCcgPyAxIDogMDtcbiAgICBkYXRhLmRpZmYob2xkRGF0YSkuYWRkKGZ1bmN0aW9uIChuZXdJZHgpIHtcbiAgICAgIGlmIChkYXRhLmhhc1ZhbHVlKG5ld0lkeCkpIHtcbiAgICAgICAgdmFyIGl0ZW1MYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KTtcbiAgICAgICAgdmFyIHN5bWJvbEVsID0gY3JlYXRlTm9ybWFsQm94KGl0ZW1MYXlvdXQsIGRhdGEsIG5ld0lkeCwgY29uc3REaW0sIHRydWUpO1xuICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBzeW1ib2xFbCk7XG4gICAgICAgIGdyb3VwLmFkZChzeW1ib2xFbCk7XG4gICAgICB9XG4gICAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgdmFyIHN5bWJvbEVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICAvLyBFbXB0eSBkYXRhXG4gICAgICBpZiAoIWRhdGEuaGFzVmFsdWUobmV3SWR4KSkge1xuICAgICAgICBncm91cC5yZW1vdmUoc3ltYm9sRWwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaXRlbUxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpO1xuICAgICAgaWYgKCFzeW1ib2xFbCkge1xuICAgICAgICBzeW1ib2xFbCA9IGNyZWF0ZU5vcm1hbEJveChpdGVtTGF5b3V0LCBkYXRhLCBuZXdJZHgsIGNvbnN0RGltKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNhdmVPbGRTdHlsZShzeW1ib2xFbCk7XG4gICAgICAgIHVwZGF0ZU5vcm1hbEJveERhdGEoaXRlbUxheW91dCwgc3ltYm9sRWwsIGRhdGEsIG5ld0lkeCk7XG4gICAgICB9XG4gICAgICBncm91cC5hZGQoc3ltYm9sRWwpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgc3ltYm9sRWwpO1xuICAgIH0pLnJlbW92ZShmdW5jdGlvbiAob2xkSWR4KSB7XG4gICAgICB2YXIgZWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICAgIGVsICYmIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgfSkuZXhlY3V0ZSgpO1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9O1xuICBCb3hwbG90Vmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICBkYXRhICYmIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbCAmJiBncm91cC5yZW1vdmUoZWwpO1xuICAgIH0pO1xuICB9O1xuICBCb3hwbG90Vmlldy50eXBlID0gJ2JveHBsb3QnO1xuICByZXR1cm4gQm94cGxvdFZpZXc7XG59KENoYXJ0Vmlldyk7XG52YXIgQm94UGF0aFNoYXBlID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQm94UGF0aFNoYXBlKCkge31cbiAgcmV0dXJuIEJveFBhdGhTaGFwZTtcbn0oKTtcbnZhciBCb3hQYXRoID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEJveFBhdGgsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEJveFBhdGgob3B0cykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9ICdib3hwbG90Qm94UGF0aCc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEJveFBhdGgucHJvdG90eXBlLmdldERlZmF1bHRTaGFwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEJveFBhdGhTaGFwZSgpO1xuICB9O1xuICBCb3hQYXRoLnByb3RvdHlwZS5idWlsZFBhdGggPSBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciBlbmRzID0gc2hhcGUucG9pbnRzO1xuICAgIHZhciBpID0gMDtcbiAgICBjdHgubW92ZVRvKGVuZHNbaV1bMF0sIGVuZHNbaV1bMV0pO1xuICAgIGkrKztcbiAgICBmb3IgKDsgaSA8IDQ7IGkrKykge1xuICAgICAgY3R4LmxpbmVUbyhlbmRzW2ldWzBdLCBlbmRzW2ldWzFdKTtcbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGZvciAoOyBpIDwgZW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgY3R4Lm1vdmVUbyhlbmRzW2ldWzBdLCBlbmRzW2ldWzFdKTtcbiAgICAgIGkrKztcbiAgICAgIGN0eC5saW5lVG8oZW5kc1tpXVswXSwgZW5kc1tpXVsxXSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gQm94UGF0aDtcbn0oUGF0aCk7XG5mdW5jdGlvbiBjcmVhdGVOb3JtYWxCb3goaXRlbUxheW91dCwgZGF0YSwgZGF0YUluZGV4LCBjb25zdERpbSwgaXNJbml0KSB7XG4gIHZhciBlbmRzID0gaXRlbUxheW91dC5lbmRzO1xuICB2YXIgZWwgPSBuZXcgQm94UGF0aCh7XG4gICAgc2hhcGU6IHtcbiAgICAgIHBvaW50czogaXNJbml0ID8gdHJhbnNJbml0KGVuZHMsIGNvbnN0RGltLCBpdGVtTGF5b3V0KSA6IGVuZHNcbiAgICB9XG4gIH0pO1xuICB1cGRhdGVOb3JtYWxCb3hEYXRhKGl0ZW1MYXlvdXQsIGVsLCBkYXRhLCBkYXRhSW5kZXgsIGlzSW5pdCk7XG4gIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU5vcm1hbEJveERhdGEoaXRlbUxheW91dCwgZWwsIGRhdGEsIGRhdGFJbmRleCwgaXNJbml0KSB7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICB2YXIgdXBkYXRlTWV0aG9kID0gZ3JhcGhpY1tpc0luaXQgPyAnaW5pdFByb3BzJyA6ICd1cGRhdGVQcm9wcyddO1xuICB1cGRhdGVNZXRob2QoZWwsIHtcbiAgICBzaGFwZToge1xuICAgICAgcG9pbnRzOiBpdGVtTGF5b3V0LmVuZHNcbiAgICB9XG4gIH0sIHNlcmllc01vZGVsLCBkYXRhSW5kZXgpO1xuICBlbC51c2VTdHlsZShkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnc3R5bGUnKSk7XG4gIGVsLnN0eWxlLnN0cm9rZU5vU2NhbGUgPSB0cnVlO1xuICBlbC56MiA9IDEwMDtcbiAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG4gIHZhciBlbXBoYXNpc01vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdlbXBoYXNpcycpO1xuICBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwoZWwsIGl0ZW1Nb2RlbCk7XG4gIHRvZ2dsZUhvdmVyRW1waGFzaXMoZWwsIGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpLCBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJyksIGVtcGhhc2lzTW9kZWwuZ2V0KCdkaXNhYmxlZCcpKTtcbn1cbmZ1bmN0aW9uIHRyYW5zSW5pdChwb2ludHMsIGRpbSwgaXRlbUxheW91dCkge1xuICByZXR1cm4genJVdGlsLm1hcChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHBvaW50ID0gcG9pbnQuc2xpY2UoKTtcbiAgICBwb2ludFtkaW1dID0gaXRlbUxheW91dC5pbml0QmFzZWxpbmU7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IEJveHBsb3RWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBwYXJzZVBlcmNlbnQgfSBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYm94cGxvdExheW91dChlY01vZGVsKSB7XG4gIHZhciBncm91cFJlc3VsdCA9IGdyb3VwU2VyaWVzQnlBeGlzKGVjTW9kZWwpO1xuICBlYWNoKGdyb3VwUmVzdWx0LCBmdW5jdGlvbiAoZ3JvdXBJdGVtKSB7XG4gICAgdmFyIHNlcmllc01vZGVscyA9IGdyb3VwSXRlbS5zZXJpZXNNb2RlbHM7XG4gICAgaWYgKCFzZXJpZXNNb2RlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGN1bGF0ZUJhc2UoZ3JvdXBJdGVtKTtcbiAgICBlYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsLCBpZHgpIHtcbiAgICAgIGxheW91dFNpbmdsZVNlcmllcyhzZXJpZXNNb2RlbCwgZ3JvdXBJdGVtLmJveE9mZnNldExpc3RbaWR4XSwgZ3JvdXBJdGVtLmJveFdpZHRoTGlzdFtpZHhdKTtcbiAgICB9KTtcbiAgfSk7XG59XG4vKipcclxuICogR3JvdXAgc2VyaWVzIGJ5IGF4aXMuXHJcbiAqL1xuZnVuY3Rpb24gZ3JvdXBTZXJpZXNCeUF4aXMoZWNNb2RlbCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBheGlzTGlzdCA9IFtdO1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ2JveHBsb3QnLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgYmFzZUF4aXMgPSBzZXJpZXNNb2RlbC5nZXRCYXNlQXhpcygpO1xuICAgIHZhciBpZHggPSB6clV0aWwuaW5kZXhPZihheGlzTGlzdCwgYmFzZUF4aXMpO1xuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICBpZHggPSBheGlzTGlzdC5sZW5ndGg7XG4gICAgICBheGlzTGlzdFtpZHhdID0gYmFzZUF4aXM7XG4gICAgICByZXN1bHRbaWR4XSA9IHtcbiAgICAgICAgYXhpczogYmFzZUF4aXMsXG4gICAgICAgIHNlcmllc01vZGVsczogW11cbiAgICAgIH07XG4gICAgfVxuICAgIHJlc3VsdFtpZHhdLnNlcmllc01vZGVscy5wdXNoKHNlcmllc01vZGVsKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlIG9mZnNldCBhbmQgYm94IHdpZHRoIGZvciBlYWNoIHNlcmllcy5cclxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVCYXNlKGdyb3VwSXRlbSkge1xuICB2YXIgYmFzZUF4aXMgPSBncm91cEl0ZW0uYXhpcztcbiAgdmFyIHNlcmllc01vZGVscyA9IGdyb3VwSXRlbS5zZXJpZXNNb2RlbHM7XG4gIHZhciBzZXJpZXNDb3VudCA9IHNlcmllc01vZGVscy5sZW5ndGg7XG4gIHZhciBib3hXaWR0aExpc3QgPSBncm91cEl0ZW0uYm94V2lkdGhMaXN0ID0gW107XG4gIHZhciBib3hPZmZzZXRMaXN0ID0gZ3JvdXBJdGVtLmJveE9mZnNldExpc3QgPSBbXTtcbiAgdmFyIGJvdW5kTGlzdCA9IFtdO1xuICB2YXIgYmFuZFdpZHRoO1xuICBpZiAoYmFzZUF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgIGJhbmRXaWR0aCA9IGJhc2VBeGlzLmdldEJhbmRXaWR0aCgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtYXhEYXRhQ291bnRfMSA9IDA7XG4gICAgZWFjaChzZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgbWF4RGF0YUNvdW50XzEgPSBNYXRoLm1heChtYXhEYXRhQ291bnRfMSwgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmNvdW50KCkpO1xuICAgIH0pO1xuICAgIHZhciBleHRlbnQgPSBiYXNlQXhpcy5nZXRFeHRlbnQoKTtcbiAgICBiYW5kV2lkdGggPSBNYXRoLmFicyhleHRlbnRbMV0gLSBleHRlbnRbMF0pIC8gbWF4RGF0YUNvdW50XzE7XG4gIH1cbiAgZWFjaChzZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBib3hXaWR0aEJvdW5kID0gc2VyaWVzTW9kZWwuZ2V0KCdib3hXaWR0aCcpO1xuICAgIGlmICghenJVdGlsLmlzQXJyYXkoYm94V2lkdGhCb3VuZCkpIHtcbiAgICAgIGJveFdpZHRoQm91bmQgPSBbYm94V2lkdGhCb3VuZCwgYm94V2lkdGhCb3VuZF07XG4gICAgfVxuICAgIGJvdW5kTGlzdC5wdXNoKFtwYXJzZVBlcmNlbnQoYm94V2lkdGhCb3VuZFswXSwgYmFuZFdpZHRoKSB8fCAwLCBwYXJzZVBlcmNlbnQoYm94V2lkdGhCb3VuZFsxXSwgYmFuZFdpZHRoKSB8fCAwXSk7XG4gIH0pO1xuICB2YXIgYXZhaWxhYmxlV2lkdGggPSBiYW5kV2lkdGggKiAwLjggLSAyO1xuICB2YXIgYm94R2FwID0gYXZhaWxhYmxlV2lkdGggLyBzZXJpZXNDb3VudCAqIDAuMztcbiAgdmFyIGJveFdpZHRoID0gKGF2YWlsYWJsZVdpZHRoIC0gYm94R2FwICogKHNlcmllc0NvdW50IC0gMSkpIC8gc2VyaWVzQ291bnQ7XG4gIHZhciBiYXNlID0gYm94V2lkdGggLyAyIC0gYXZhaWxhYmxlV2lkdGggLyAyO1xuICBlYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsLCBpZHgpIHtcbiAgICBib3hPZmZzZXRMaXN0LnB1c2goYmFzZSk7XG4gICAgYmFzZSArPSBib3hHYXAgKyBib3hXaWR0aDtcbiAgICBib3hXaWR0aExpc3QucHVzaChNYXRoLm1pbihNYXRoLm1heChib3hXaWR0aCwgYm91bmRMaXN0W2lkeF1bMF0pLCBib3VuZExpc3RbaWR4XVsxXSkpO1xuICB9KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGUgcG9pbnRzIGxvY2F0aW9uIGZvciBlYWNoIHNlcmllcy5cclxuICovXG5mdW5jdGlvbiBsYXlvdXRTaW5nbGVTZXJpZXMoc2VyaWVzTW9kZWwsIG9mZnNldCwgYm94V2lkdGgpIHtcbiAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gIHZhciBoYWxmV2lkdGggPSBib3hXaWR0aCAvIDI7XG4gIHZhciBjRGltSWR4ID0gc2VyaWVzTW9kZWwuZ2V0KCdsYXlvdXQnKSA9PT0gJ2hvcml6b250YWwnID8gMCA6IDE7XG4gIHZhciB2RGltSWR4ID0gMSAtIGNEaW1JZHg7XG4gIHZhciBjb29yZERpbXMgPSBbJ3gnLCAneSddO1xuICB2YXIgY0RpbSA9IGRhdGEubWFwRGltZW5zaW9uKGNvb3JkRGltc1tjRGltSWR4XSk7XG4gIHZhciB2RGltcyA9IGRhdGEubWFwRGltZW5zaW9uc0FsbChjb29yZERpbXNbdkRpbUlkeF0pO1xuICBpZiAoY0RpbSA9PSBudWxsIHx8IHZEaW1zLmxlbmd0aCA8IDUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgZGF0YUluZGV4ID0gMDsgZGF0YUluZGV4IDwgZGF0YS5jb3VudCgpOyBkYXRhSW5kZXgrKykge1xuICAgIHZhciBheGlzRGltVmFsID0gZGF0YS5nZXQoY0RpbSwgZGF0YUluZGV4KTtcbiAgICB2YXIgbWVkaWFuID0gZ2V0UG9pbnQoYXhpc0RpbVZhbCwgdkRpbXNbMl0sIGRhdGFJbmRleCk7XG4gICAgdmFyIGVuZDEgPSBnZXRQb2ludChheGlzRGltVmFsLCB2RGltc1swXSwgZGF0YUluZGV4KTtcbiAgICB2YXIgZW5kMiA9IGdldFBvaW50KGF4aXNEaW1WYWwsIHZEaW1zWzFdLCBkYXRhSW5kZXgpO1xuICAgIHZhciBlbmQ0ID0gZ2V0UG9pbnQoYXhpc0RpbVZhbCwgdkRpbXNbM10sIGRhdGFJbmRleCk7XG4gICAgdmFyIGVuZDUgPSBnZXRQb2ludChheGlzRGltVmFsLCB2RGltc1s0XSwgZGF0YUluZGV4KTtcbiAgICB2YXIgZW5kcyA9IFtdO1xuICAgIGFkZEJvZHlFbmQoZW5kcywgZW5kMiwgZmFsc2UpO1xuICAgIGFkZEJvZHlFbmQoZW5kcywgZW5kNCwgdHJ1ZSk7XG4gICAgZW5kcy5wdXNoKGVuZDEsIGVuZDIsIGVuZDUsIGVuZDQpO1xuICAgIGxheUVuZExpbmUoZW5kcywgZW5kMSk7XG4gICAgbGF5RW5kTGluZShlbmRzLCBlbmQ1KTtcbiAgICBsYXlFbmRMaW5lKGVuZHMsIG1lZGlhbik7XG4gICAgZGF0YS5zZXRJdGVtTGF5b3V0KGRhdGFJbmRleCwge1xuICAgICAgaW5pdEJhc2VsaW5lOiBtZWRpYW5bdkRpbUlkeF0sXG4gICAgICBlbmRzOiBlbmRzXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UG9pbnQoYXhpc0RpbVZhbCwgZGltLCBkYXRhSW5kZXgpIHtcbiAgICB2YXIgdmFsID0gZGF0YS5nZXQoZGltLCBkYXRhSW5kZXgpO1xuICAgIHZhciBwID0gW107XG4gICAgcFtjRGltSWR4XSA9IGF4aXNEaW1WYWw7XG4gICAgcFt2RGltSWR4XSA9IHZhbDtcbiAgICB2YXIgcG9pbnQ7XG4gICAgaWYgKGlzTmFOKGF4aXNEaW1WYWwpIHx8IGlzTmFOKHZhbCkpIHtcbiAgICAgIHBvaW50ID0gW05hTiwgTmFOXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnQgPSBjb29yZFN5cy5kYXRhVG9Qb2ludChwKTtcbiAgICAgIHBvaW50W2NEaW1JZHhdICs9IG9mZnNldDtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG4gIGZ1bmN0aW9uIGFkZEJvZHlFbmQoZW5kcywgcG9pbnQsIHN0YXJ0KSB7XG4gICAgdmFyIHBvaW50MSA9IHBvaW50LnNsaWNlKCk7XG4gICAgdmFyIHBvaW50MiA9IHBvaW50LnNsaWNlKCk7XG4gICAgcG9pbnQxW2NEaW1JZHhdICs9IGhhbGZXaWR0aDtcbiAgICBwb2ludDJbY0RpbUlkeF0gLT0gaGFsZldpZHRoO1xuICAgIHN0YXJ0ID8gZW5kcy5wdXNoKHBvaW50MSwgcG9pbnQyKSA6IGVuZHMucHVzaChwb2ludDIsIHBvaW50MSk7XG4gIH1cbiAgZnVuY3Rpb24gbGF5RW5kTGluZShlbmRzLCBlbmRDZW50ZXIpIHtcbiAgICB2YXIgZnJvbSA9IGVuZENlbnRlci5zbGljZSgpO1xuICAgIHZhciB0byA9IGVuZENlbnRlci5zbGljZSgpO1xuICAgIGZyb21bY0RpbUlkeF0gLT0gaGFsZldpZHRoO1xuICAgIHRvW2NEaW1JZHhdICs9IGhhbGZXaWR0aDtcbiAgICBlbmRzLnB1c2goZnJvbSwgdG8pO1xuICB9XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBxdWFudGlsZSwgYXNjIH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNTdHJpbmcgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuLyoqXHJcbiAqIFNlZTpcclxuICogIDxodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cb3hfcGxvdCNjaXRlX25vdGUtZnJpZ2dlX2hvYWdsaW5faWdsZXdpY3otMj5cclxuICogIDxodHRwOi8vc3RhdC5ldGh6LmNoL1ItbWFudWFsL1ItZGV2ZWwvbGlicmFyeS9nckRldmljZXMvaHRtbC9ib3hwbG90LnN0YXRzLmh0bWw+XHJcbiAqXHJcbiAqIEhlbHBlciBtZXRob2QgZm9yIHByZXBhcmluZyBkYXRhLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmF3RGF0YSBsaWtlXHJcbiAqICAgICAgICBbXHJcbiAqICAgICAgICAgICAgWzEyLDIzMiw0NDNdLCAocmF3IGRhdGEgc2V0IGZvciB0aGUgZmlyc3QgYm94KVxyXG4gKiAgICAgICAgICAgIFszODQzLDU1NDUsMTIzMl0sIChyYXcgZGF0YSBzZXQgZm9yIHRoZSBzZWNvbmQgYm94KVxyXG4gKiAgICAgICAgICAgIC4uLlxyXG4gKiAgICAgICAgXVxyXG4gKiBAcGFyYW0gb3B0LmJvdW5kSVFSPTEuNSBEYXRhIGxlc3MgdGhhbiBtaW4gYm91bmQgaXMgb3V0bGllci5cclxuICogICAgICBkZWZhdWx0IDEuNSwgbWVhbnMgUTEgLSAxLjUgKiAoUTMgLSBRMSkuXHJcbiAqICAgICAgSWYgJ25vbmUnLzAgcGFzc2VkLCBtaW4gYm91bmQgd2lsbCBub3QgYmUgdXNlZC5cclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcmVwYXJlQm94cGxvdERhdGEocmF3RGF0YSwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIGJveERhdGEgPSBbXTtcbiAgdmFyIG91dGxpZXJzID0gW107XG4gIHZhciBib3VuZElRUiA9IG9wdC5ib3VuZElRUjtcbiAgdmFyIHVzZUV4dHJlbWUgPSBib3VuZElRUiA9PT0gJ25vbmUnIHx8IGJvdW5kSVFSID09PSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXNjTGlzdCA9IGFzYyhyYXdEYXRhW2ldLnNsaWNlKCkpO1xuICAgIHZhciBRMSA9IHF1YW50aWxlKGFzY0xpc3QsIDAuMjUpO1xuICAgIHZhciBRMiA9IHF1YW50aWxlKGFzY0xpc3QsIDAuNSk7XG4gICAgdmFyIFEzID0gcXVhbnRpbGUoYXNjTGlzdCwgMC43NSk7XG4gICAgdmFyIG1pbiA9IGFzY0xpc3RbMF07XG4gICAgdmFyIG1heCA9IGFzY0xpc3RbYXNjTGlzdC5sZW5ndGggLSAxXTtcbiAgICB2YXIgYm91bmQgPSAoYm91bmRJUVIgPT0gbnVsbCA/IDEuNSA6IGJvdW5kSVFSKSAqIChRMyAtIFExKTtcbiAgICB2YXIgbG93ID0gdXNlRXh0cmVtZSA/IG1pbiA6IE1hdGgubWF4KG1pbiwgUTEgLSBib3VuZCk7XG4gICAgdmFyIGhpZ2ggPSB1c2VFeHRyZW1lID8gbWF4IDogTWF0aC5taW4obWF4LCBRMyArIGJvdW5kKTtcbiAgICB2YXIgaXRlbU5hbWVGb3JtYXR0ZXIgPSBvcHQuaXRlbU5hbWVGb3JtYXR0ZXI7XG4gICAgdmFyIGl0ZW1OYW1lID0gaXNGdW5jdGlvbihpdGVtTmFtZUZvcm1hdHRlcikgPyBpdGVtTmFtZUZvcm1hdHRlcih7XG4gICAgICB2YWx1ZTogaVxuICAgIH0pIDogaXNTdHJpbmcoaXRlbU5hbWVGb3JtYXR0ZXIpID8gaXRlbU5hbWVGb3JtYXR0ZXIucmVwbGFjZSgne3ZhbHVlfScsIGkgKyAnJykgOiBpICsgJyc7XG4gICAgYm94RGF0YS5wdXNoKFtpdGVtTmFtZSwgbG93LCBRMSwgUTIsIFEzLCBoaWdoXSk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhc2NMaXN0Lmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZGF0YUl0ZW0gPSBhc2NMaXN0W2pdO1xuICAgICAgaWYgKGRhdGFJdGVtIDwgbG93IHx8IGRhdGFJdGVtID4gaGlnaCkge1xuICAgICAgICB2YXIgb3V0bGllciA9IFtpdGVtTmFtZSwgZGF0YUl0ZW1dO1xuICAgICAgICBvdXRsaWVycy5wdXNoKG91dGxpZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGJveERhdGE6IGJveERhdGEsXG4gICAgb3V0bGllcnM6IG91dGxpZXJzXG4gIH07XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgcHJlcGFyZUJveHBsb3REYXRhIGZyb20gJy4vcHJlcGFyZUJveHBsb3REYXRhLmpzJztcbmltcG9ydCB7IHRocm93RXJyb3IsIG1ha2VQcmludGFibGUgfSBmcm9tICcuLi8uLi91dGlsL2xvZy5qcyc7XG5pbXBvcnQgeyBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MgfSBmcm9tICcuLi8uLi91dGlsL3R5cGVzLmpzJztcbmV4cG9ydCB2YXIgYm94cGxvdFRyYW5zZm9ybSA9IHtcbiAgdHlwZTogJ2VjaGFydHM6Ym94cGxvdCcsXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHBhcmFtcykge1xuICAgIHZhciB1cHN0cmVhbSA9IHBhcmFtcy51cHN0cmVhbTtcbiAgICBpZiAodXBzdHJlYW0uc291cmNlRm9ybWF0ICE9PSBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MpIHtcbiAgICAgIHZhciBlcnJNc2cgPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVyck1zZyA9IG1ha2VQcmludGFibGUoJ3NvdXJjZSBkYXRhIGlzIG5vdCBhcHBsaWNhYmxlIGZvciB0aGlzIGJveHBsb3QgdHJhbnNmb3JtLiBFeHBlY3QgbnVtYmVyW11bXS4nKTtcbiAgICAgIH1cbiAgICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHByZXBhcmVCb3hwbG90RGF0YSh1cHN0cmVhbS5nZXRSYXdEYXRhKCksIHBhcmFtcy5jb25maWcpO1xuICAgIHJldHVybiBbe1xuICAgICAgZGltZW5zaW9uczogWydJdGVtTmFtZScsICdMb3cnLCAnUTEnLCAnUTInLCAnUTMnLCAnSGlnaCddLFxuICAgICAgZGF0YTogcmVzdWx0LmJveERhdGFcbiAgICB9LCB7XG4gICAgICBkYXRhOiByZXN1bHQub3V0bGllcnNcbiAgICB9XTtcbiAgfVxufTsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBCb3hwbG90U2VyaWVzTW9kZWwgZnJvbSAnLi9Cb3hwbG90U2VyaWVzLmpzJztcbmltcG9ydCBCb3hwbG90VmlldyBmcm9tICcuL0JveHBsb3RWaWV3LmpzJztcbmltcG9ydCBib3hwbG90TGF5b3V0IGZyb20gJy4vYm94cGxvdExheW91dC5qcyc7XG5pbXBvcnQgeyBib3hwbG90VHJhbnNmb3JtIH0gZnJvbSAnLi9ib3hwbG90VHJhbnNmb3JtLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChCb3hwbG90U2VyaWVzTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDaGFydFZpZXcoQm94cGxvdFZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQoYm94cGxvdExheW91dCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclRyYW5zZm9ybShib3hwbG90VHJhbnNmb3JtKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///51719\n")},56699:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Path.js\nvar Path = __webpack_require__(59482);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js\nvar createClipPathFromCoordSys = __webpack_require__(95235);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createRenderPlanner.js\nvar createRenderPlanner = __webpack_require__(87582);\n;// ./node_modules/echarts/lib/chart/candlestick/candlestickVisual.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar positiveBorderColorQuery = ['itemStyle', 'borderColor'];\nvar negativeBorderColorQuery = ['itemStyle', 'borderColor0'];\nvar dojiBorderColorQuery = ['itemStyle', 'borderColorDoji'];\nvar positiveColorQuery = ['itemStyle', 'color'];\nvar negativeColorQuery = ['itemStyle', 'color0'];\nfunction getColor(sign, model) {\n  return model.get(sign > 0 ? positiveColorQuery : negativeColorQuery);\n}\nfunction getBorderColor(sign, model) {\n  return model.get(sign === 0 ? dojiBorderColorQuery : sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);\n}\nvar candlestickVisual = {\n  seriesType: 'candlestick',\n  plan: (0,createRenderPlanner/* default */.A)(),\n  // For legend.\n  performRawSeries: true,\n  reset: function (seriesModel, ecModel) {\n    // Only visible series has each data be visual encoded\n    if (ecModel.isSeriesFiltered(seriesModel)) {\n      return;\n    }\n    var isLargeRender = seriesModel.pipelineContext.large;\n    return !isLargeRender && {\n      progress: function (params, data) {\n        var dataIndex;\n        while ((dataIndex = params.next()) != null) {\n          var itemModel = data.getItemModel(dataIndex);\n          var sign = data.getItemLayout(dataIndex).sign;\n          var style = itemModel.getItemStyle();\n          style.fill = getColor(sign, itemModel);\n          style.stroke = getBorderColor(sign, itemModel) || style.fill;\n          var existsStyle = data.ensureUniqueItemVisual(dataIndex, 'style');\n          (0,util.extend)(existsStyle, style);\n        }\n      }\n    };\n  }\n};\n/* harmony default export */ const candlestick_candlestickVisual = (candlestickVisual);\n;// ./node_modules/echarts/lib/chart/candlestick/CandlestickView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\nvar SKIP_PROPS = ['color', 'borderColor'];\nvar CandlestickView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(CandlestickView, _super);\n  function CandlestickView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = CandlestickView.type;\n    return _this;\n  }\n  CandlestickView.prototype.render = function (seriesModel, ecModel, api) {\n    // If there is clipPath created in large mode. Remove it.\n    this.group.removeClipPath();\n    // Clear previously rendered progressive elements.\n    this._progressiveEls = null;\n    this._updateDrawMode(seriesModel);\n    this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);\n  };\n  CandlestickView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {\n    this._clear();\n    this._updateDrawMode(seriesModel);\n  };\n  CandlestickView.prototype.incrementalRender = function (params, seriesModel, ecModel, api) {\n    this._progressiveEls = [];\n    this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);\n  };\n  CandlestickView.prototype.eachRendered = function (cb) {\n    graphic.traverseElements(this._progressiveEls || this.group, cb);\n  };\n  CandlestickView.prototype._updateDrawMode = function (seriesModel) {\n    var isLargeDraw = seriesModel.pipelineContext.large;\n    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {\n      this._isLargeDraw = isLargeDraw;\n      this._clear();\n    }\n  };\n  CandlestickView.prototype._renderNormal = function (seriesModel) {\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var isSimpleBox = data.getLayout('isSimpleBox');\n    var needsClip = seriesModel.get('clip', true);\n    var coord = seriesModel.coordinateSystem;\n    var clipArea = coord.getArea && coord.getArea();\n    // There is no old data only when first rendering or switching from\n    // stream mode to normal mode, where previous elements should be removed.\n    if (!this._data) {\n      group.removeAll();\n    }\n    data.diff(oldData).add(function (newIdx) {\n      if (data.hasValue(newIdx)) {\n        var itemLayout = data.getItemLayout(newIdx);\n        if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {\n          return;\n        }\n        var el = createNormalBox(itemLayout, newIdx, true);\n        basicTransition/* initProps */.LW(el, {\n          shape: {\n            points: itemLayout.ends\n          }\n        }, seriesModel, newIdx);\n        setBoxCommon(el, data, newIdx, isSimpleBox);\n        group.add(el);\n        data.setItemGraphicEl(newIdx, el);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var el = oldData.getItemGraphicEl(oldIdx);\n      // Empty data\n      if (!data.hasValue(newIdx)) {\n        group.remove(el);\n        return;\n      }\n      var itemLayout = data.getItemLayout(newIdx);\n      if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {\n        group.remove(el);\n        return;\n      }\n      if (!el) {\n        el = createNormalBox(itemLayout, newIdx);\n      } else {\n        basicTransition/* updateProps */.oi(el, {\n          shape: {\n            points: itemLayout.ends\n          }\n        }, seriesModel, newIdx);\n        (0,basicTransition/* saveOldStyle */.ap)(el);\n      }\n      setBoxCommon(el, data, newIdx, isSimpleBox);\n      group.add(el);\n      data.setItemGraphicEl(newIdx, el);\n    }).remove(function (oldIdx) {\n      var el = oldData.getItemGraphicEl(oldIdx);\n      el && group.remove(el);\n    }).execute();\n    this._data = data;\n  };\n  CandlestickView.prototype._renderLarge = function (seriesModel) {\n    this._clear();\n    createLarge(seriesModel, this.group);\n    var clipPath = seriesModel.get('clip', true) ? (0,createClipPathFromCoordSys/* createClipPath */.Ip)(seriesModel.coordinateSystem, false, seriesModel) : null;\n    if (clipPath) {\n      this.group.setClipPath(clipPath);\n    } else {\n      this.group.removeClipPath();\n    }\n  };\n  CandlestickView.prototype._incrementalRenderNormal = function (params, seriesModel) {\n    var data = seriesModel.getData();\n    var isSimpleBox = data.getLayout('isSimpleBox');\n    var dataIndex;\n    while ((dataIndex = params.next()) != null) {\n      var itemLayout = data.getItemLayout(dataIndex);\n      var el = createNormalBox(itemLayout, dataIndex);\n      setBoxCommon(el, data, dataIndex, isSimpleBox);\n      el.incremental = true;\n      this.group.add(el);\n      this._progressiveEls.push(el);\n    }\n  };\n  CandlestickView.prototype._incrementalRenderLarge = function (params, seriesModel) {\n    createLarge(seriesModel, this.group, this._progressiveEls, true);\n  };\n  CandlestickView.prototype.remove = function (ecModel) {\n    this._clear();\n  };\n  CandlestickView.prototype._clear = function () {\n    this.group.removeAll();\n    this._data = null;\n  };\n  CandlestickView.type = 'candlestick';\n  return CandlestickView;\n}(Chart/* default */.A);\nvar NormalBoxPathShape = /** @class */function () {\n  function NormalBoxPathShape() {}\n  return NormalBoxPathShape;\n}();\nvar NormalBoxPath = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(NormalBoxPath, _super);\n  function NormalBoxPath(opts) {\n    var _this = _super.call(this, opts) || this;\n    _this.type = 'normalCandlestickBox';\n    return _this;\n  }\n  NormalBoxPath.prototype.getDefaultShape = function () {\n    return new NormalBoxPathShape();\n  };\n  NormalBoxPath.prototype.buildPath = function (ctx, shape) {\n    var ends = shape.points;\n    if (this.__simpleBox) {\n      ctx.moveTo(ends[4][0], ends[4][1]);\n      ctx.lineTo(ends[6][0], ends[6][1]);\n    } else {\n      ctx.moveTo(ends[0][0], ends[0][1]);\n      ctx.lineTo(ends[1][0], ends[1][1]);\n      ctx.lineTo(ends[2][0], ends[2][1]);\n      ctx.lineTo(ends[3][0], ends[3][1]);\n      ctx.closePath();\n      ctx.moveTo(ends[4][0], ends[4][1]);\n      ctx.lineTo(ends[5][0], ends[5][1]);\n      ctx.moveTo(ends[6][0], ends[6][1]);\n      ctx.lineTo(ends[7][0], ends[7][1]);\n    }\n  };\n  return NormalBoxPath;\n}(Path/* default */.Ay);\nfunction createNormalBox(itemLayout, dataIndex, isInit) {\n  var ends = itemLayout.ends;\n  return new NormalBoxPath({\n    shape: {\n      points: isInit ? transInit(ends, itemLayout) : ends\n    },\n    z2: 100\n  });\n}\nfunction isNormalBoxClipped(clipArea, itemLayout) {\n  var clipped = true;\n  for (var i = 0; i < itemLayout.ends.length; i++) {\n    // If any point are in the region.\n    if (clipArea.contain(itemLayout.ends[i][0], itemLayout.ends[i][1])) {\n      clipped = false;\n      break;\n    }\n  }\n  return clipped;\n}\nfunction setBoxCommon(el, data, dataIndex, isSimpleBox) {\n  var itemModel = data.getItemModel(dataIndex);\n  el.useStyle(data.getItemVisual(dataIndex, 'style'));\n  el.style.strokeNoScale = true;\n  el.__simpleBox = isSimpleBox;\n  (0,states/* setStatesStylesFromModel */.Mx)(el, itemModel);\n  var sign = data.getItemLayout(dataIndex).sign;\n  util.each(el.states, function (state, stateName) {\n    var stateModel = itemModel.getModel(stateName);\n    var color = getColor(sign, stateModel);\n    var borderColor = getBorderColor(sign, stateModel) || color;\n    var stateStyle = state.style || (state.style = {});\n    color && (stateStyle.fill = color);\n    borderColor && (stateStyle.stroke = borderColor);\n  });\n  var emphasisModel = itemModel.getModel('emphasis');\n  (0,states/* toggleHoverEmphasis */.Lm)(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n}\nfunction transInit(points, itemLayout) {\n  return util.map(points, function (point) {\n    point = point.slice();\n    point[1] = itemLayout.initBaseline;\n    return point;\n  });\n}\nvar LargeBoxPathShape = /** @class */function () {\n  function LargeBoxPathShape() {}\n  return LargeBoxPathShape;\n}();\nvar LargeBoxPath = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(LargeBoxPath, _super);\n  function LargeBoxPath(opts) {\n    var _this = _super.call(this, opts) || this;\n    _this.type = 'largeCandlestickBox';\n    return _this;\n  }\n  LargeBoxPath.prototype.getDefaultShape = function () {\n    return new LargeBoxPathShape();\n  };\n  LargeBoxPath.prototype.buildPath = function (ctx, shape) {\n    // Drawing lines is more efficient than drawing\n    // a whole line or drawing rects.\n    var points = shape.points;\n    for (var i = 0; i < points.length;) {\n      if (this.__sign === points[i++]) {\n        var x = points[i++];\n        ctx.moveTo(x, points[i++]);\n        ctx.lineTo(x, points[i++]);\n      } else {\n        i += 3;\n      }\n    }\n  };\n  return LargeBoxPath;\n}(Path/* default */.Ay);\nfunction createLarge(seriesModel, group, progressiveEls, incremental) {\n  var data = seriesModel.getData();\n  var largePoints = data.getLayout('largePoints');\n  var elP = new LargeBoxPath({\n    shape: {\n      points: largePoints\n    },\n    __sign: 1,\n    ignoreCoarsePointer: true\n  });\n  group.add(elP);\n  var elN = new LargeBoxPath({\n    shape: {\n      points: largePoints\n    },\n    __sign: -1,\n    ignoreCoarsePointer: true\n  });\n  group.add(elN);\n  var elDoji = new LargeBoxPath({\n    shape: {\n      points: largePoints\n    },\n    __sign: 0,\n    ignoreCoarsePointer: true\n  });\n  group.add(elDoji);\n  setLargeStyle(1, elP, seriesModel, data);\n  setLargeStyle(-1, elN, seriesModel, data);\n  setLargeStyle(0, elDoji, seriesModel, data);\n  if (incremental) {\n    elP.incremental = true;\n    elN.incremental = true;\n  }\n  if (progressiveEls) {\n    progressiveEls.push(elP, elN);\n  }\n}\nfunction setLargeStyle(sign, el, seriesModel, data) {\n  // TODO put in visual?\n  var borderColor = getBorderColor(sign, seriesModel)\n  // Use color for border color by default.\n  || getColor(sign, seriesModel);\n  // Color must be excluded.\n  // Because symbol provide setColor individually to set fill and stroke\n  var itemStyle = seriesModel.getModel('itemStyle').getItemStyle(SKIP_PROPS);\n  el.useStyle(itemStyle);\n  el.style.fill = null;\n  el.style.stroke = borderColor;\n}\n/* harmony default export */ const candlestick_CandlestickView = (CandlestickView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js\nvar whiskerBoxCommon = __webpack_require__(15501);\n;// ./node_modules/echarts/lib/chart/candlestick/CandlestickSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar CandlestickSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(CandlestickSeriesModel, _super);\n  function CandlestickSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = CandlestickSeriesModel.type;\n    _this.defaultValueDimensions = [{\n      name: 'open',\n      defaultTooltip: true\n    }, {\n      name: 'close',\n      defaultTooltip: true\n    }, {\n      name: 'lowest',\n      defaultTooltip: true\n    }, {\n      name: 'highest',\n      defaultTooltip: true\n    }];\n    return _this;\n  }\n  /**\r\n   * Get dimension for shadow in dataZoom\r\n   * @return dimension name\r\n   */\n  CandlestickSeriesModel.prototype.getShadowDim = function () {\n    return 'open';\n  };\n  CandlestickSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {\n    var itemLayout = data.getItemLayout(dataIndex);\n    return itemLayout && selectors.rect(itemLayout.brushRect);\n  };\n  CandlestickSeriesModel.type = 'series.candlestick';\n  CandlestickSeriesModel.dependencies = ['xAxis', 'yAxis', 'grid'];\n  CandlestickSeriesModel.defaultOption = {\n    // zlevel: 0,\n    z: 2,\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    layout: null,\n    clip: true,\n    itemStyle: {\n      color: '#eb5454',\n      color0: '#47b262',\n      borderColor: '#eb5454',\n      borderColor0: '#47b262',\n      borderColorDoji: null,\n      // borderColor: '#d24040',\n      // borderColor0: '#398f4f',\n      borderWidth: 1\n    },\n    emphasis: {\n      itemStyle: {\n        borderWidth: 2\n      }\n    },\n    barMaxWidth: null,\n    barMinWidth: null,\n    barWidth: null,\n    large: true,\n    largeThreshold: 600,\n    progressive: 3e3,\n    progressiveThreshold: 1e4,\n    progressiveChunkMode: 'mod',\n    animationEasing: 'linear',\n    animationDuration: 300\n  };\n  return CandlestickSeriesModel;\n}(Series/* default */.A);\n(0,util.mixin)(CandlestickSeriesModel, whiskerBoxCommon/* WhiskerBoxCommonMixin */.n, true);\n/* harmony default export */ const CandlestickSeries = (CandlestickSeriesModel);\n;// ./node_modules/echarts/lib/chart/candlestick/preprocessor.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction candlestickPreprocessor(option) {\n  if (!option || !util.isArray(option.series)) {\n    return;\n  }\n  // Translate 'k' to 'candlestick'.\n  util.each(option.series, function (seriesItem) {\n    if (util.isObject(seriesItem) && seriesItem.type === 'k') {\n      seriesItem.type = 'candlestick';\n    }\n  });\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/vendor.js\nvar vendor = __webpack_require__(8957);\n;// ./node_modules/echarts/lib/chart/candlestick/candlestickLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar candlestickLayout = {\n  seriesType: 'candlestick',\n  plan: (0,createRenderPlanner/* default */.A)(),\n  reset: function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n    var data = seriesModel.getData();\n    var candleWidth = calculateCandleWidth(seriesModel, data);\n    var cDimIdx = 0;\n    var vDimIdx = 1;\n    var coordDims = ['x', 'y'];\n    var cDimI = data.getDimensionIndex(data.mapDimension(coordDims[cDimIdx]));\n    var vDimsI = (0,util.map)(data.mapDimensionsAll(coordDims[vDimIdx]), data.getDimensionIndex, data);\n    var openDimI = vDimsI[0];\n    var closeDimI = vDimsI[1];\n    var lowestDimI = vDimsI[2];\n    var highestDimI = vDimsI[3];\n    data.setLayout({\n      candleWidth: candleWidth,\n      // The value is experimented visually.\n      isSimpleBox: candleWidth <= 1.3\n    });\n    if (cDimI < 0 || vDimsI.length < 4) {\n      return;\n    }\n    return {\n      progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress\n    };\n    function normalProgress(params, data) {\n      var dataIndex;\n      var store = data.getStore();\n      while ((dataIndex = params.next()) != null) {\n        var axisDimVal = store.get(cDimI, dataIndex);\n        var openVal = store.get(openDimI, dataIndex);\n        var closeVal = store.get(closeDimI, dataIndex);\n        var lowestVal = store.get(lowestDimI, dataIndex);\n        var highestVal = store.get(highestDimI, dataIndex);\n        var ocLow = Math.min(openVal, closeVal);\n        var ocHigh = Math.max(openVal, closeVal);\n        var ocLowPoint = getPoint(ocLow, axisDimVal);\n        var ocHighPoint = getPoint(ocHigh, axisDimVal);\n        var lowestPoint = getPoint(lowestVal, axisDimVal);\n        var highestPoint = getPoint(highestVal, axisDimVal);\n        var ends = [];\n        addBodyEnd(ends, ocHighPoint, 0);\n        addBodyEnd(ends, ocLowPoint, 1);\n        ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));\n        var itemModel = data.getItemModel(dataIndex);\n        var hasDojiColor = !!itemModel.get(['itemStyle', 'borderColorDoji']);\n        data.setItemLayout(dataIndex, {\n          sign: getSign(store, dataIndex, openVal, closeVal, closeDimI, hasDojiColor),\n          initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],\n          ends: ends,\n          brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)\n        });\n      }\n      function getPoint(val, axisDimVal) {\n        var p = [];\n        p[cDimIdx] = axisDimVal;\n        p[vDimIdx] = val;\n        return isNaN(axisDimVal) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p);\n      }\n      function addBodyEnd(ends, point, start) {\n        var point1 = point.slice();\n        var point2 = point.slice();\n        point1[cDimIdx] = (0,graphic.subPixelOptimize)(point1[cDimIdx] + candleWidth / 2, 1, false);\n        point2[cDimIdx] = (0,graphic.subPixelOptimize)(point2[cDimIdx] - candleWidth / 2, 1, true);\n        start ? ends.push(point1, point2) : ends.push(point2, point1);\n      }\n      function makeBrushRect(lowestVal, highestVal, axisDimVal) {\n        var pmin = getPoint(lowestVal, axisDimVal);\n        var pmax = getPoint(highestVal, axisDimVal);\n        pmin[cDimIdx] -= candleWidth / 2;\n        pmax[cDimIdx] -= candleWidth / 2;\n        return {\n          x: pmin[0],\n          y: pmin[1],\n          width: vDimIdx ? candleWidth : pmax[0] - pmin[0],\n          height: vDimIdx ? pmax[1] - pmin[1] : candleWidth\n        };\n      }\n      function subPixelOptimizePoint(point) {\n        point[cDimIdx] = (0,graphic.subPixelOptimize)(point[cDimIdx], 1);\n        return point;\n      }\n    }\n    function largeProgress(params, data) {\n      // Structure: [sign, x, yhigh, ylow, sign, x, yhigh, ylow, ...]\n      var points = (0,vendor/* createFloat32Array */.J)(params.count * 4);\n      var offset = 0;\n      var point;\n      var tmpIn = [];\n      var tmpOut = [];\n      var dataIndex;\n      var store = data.getStore();\n      var hasDojiColor = !!seriesModel.get(['itemStyle', 'borderColorDoji']);\n      while ((dataIndex = params.next()) != null) {\n        var axisDimVal = store.get(cDimI, dataIndex);\n        var openVal = store.get(openDimI, dataIndex);\n        var closeVal = store.get(closeDimI, dataIndex);\n        var lowestVal = store.get(lowestDimI, dataIndex);\n        var highestVal = store.get(highestDimI, dataIndex);\n        if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {\n          points[offset++] = NaN;\n          offset += 3;\n          continue;\n        }\n        points[offset++] = getSign(store, dataIndex, openVal, closeVal, closeDimI, hasDojiColor);\n        tmpIn[cDimIdx] = axisDimVal;\n        tmpIn[vDimIdx] = lowestVal;\n        point = coordSys.dataToPoint(tmpIn, null, tmpOut);\n        points[offset++] = point ? point[0] : NaN;\n        points[offset++] = point ? point[1] : NaN;\n        tmpIn[vDimIdx] = highestVal;\n        point = coordSys.dataToPoint(tmpIn, null, tmpOut);\n        points[offset++] = point ? point[1] : NaN;\n      }\n      data.setLayout('largePoints', points);\n    }\n  }\n};\n/**\r\n * Get the sign of a single data.\r\n *\r\n * @returns 0 for doji with hasDojiColor: true,\r\n *          1 for positive,\r\n *          -1 for negative.\r\n */\nfunction getSign(store, dataIndex, openVal, closeVal, closeDimI, hasDojiColor) {\n  var sign;\n  if (openVal > closeVal) {\n    sign = -1;\n  } else if (openVal < closeVal) {\n    sign = 1;\n  } else {\n    sign = hasDojiColor\n    // When doji color is set, use it instead of color/color0.\n    ? 0 : dataIndex > 0\n    // If close === open, compare with close of last record\n    ? store.get(closeDimI, dataIndex - 1) <= closeVal ? 1 : -1\n    // No record of previous, set to be positive\n    : 1;\n  }\n  return sign;\n}\nfunction calculateCandleWidth(seriesModel, data) {\n  var baseAxis = seriesModel.getBaseAxis();\n  var extent;\n  var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : (extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / data.count());\n  var barMaxWidth = (0,number/* parsePercent */.lo)((0,util.retrieve2)(seriesModel.get('barMaxWidth'), bandWidth), bandWidth);\n  var barMinWidth = (0,number/* parsePercent */.lo)((0,util.retrieve2)(seriesModel.get('barMinWidth'), 1), bandWidth);\n  var barWidth = seriesModel.get('barWidth');\n  return barWidth != null ? (0,number/* parsePercent */.lo)(barWidth, bandWidth)\n  // Put max outer to ensure bar visible in spite of overlap.\n  : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);\n}\n/* harmony default export */ const candlestick_candlestickLayout = (candlestickLayout);\n;// ./node_modules/echarts/lib/chart/candlestick/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nfunction install(registers) {\n  registers.registerChartView(candlestick_CandlestickView);\n  registers.registerSeriesModel(CandlestickSeries);\n  registers.registerPreprocessor(candlestickPreprocessor);\n  registers.registerVisual(candlestick_candlestickVisual);\n  registers.registerLayout(candlestick_candlestickLayout);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY2OTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDcFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9jYW5kbGVzdGljay9jYW5kbGVzdGlja1Zpc3VhbC5qcz80NGEwIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9jYW5kbGVzdGljay9DYW5kbGVzdGlja1ZpZXcuanM/NWUxOSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvY2FuZGxlc3RpY2svQ2FuZGxlc3RpY2tTZXJpZXMuanM/NDZkZiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvY2FuZGxlc3RpY2svcHJlcHJvY2Vzc29yLmpzPzM2NzYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2NhbmRsZXN0aWNrL2NhbmRsZXN0aWNrTGF5b3V0LmpzP2NjN2IiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2NhbmRsZXN0aWNrL2luc3RhbGwuanM/MmQ2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBjcmVhdGVSZW5kZXJQbGFubmVyIGZyb20gJy4uL2hlbHBlci9jcmVhdGVSZW5kZXJQbGFubmVyLmpzJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG52YXIgcG9zaXRpdmVCb3JkZXJDb2xvclF1ZXJ5ID0gWydpdGVtU3R5bGUnLCAnYm9yZGVyQ29sb3InXTtcbnZhciBuZWdhdGl2ZUJvcmRlckNvbG9yUXVlcnkgPSBbJ2l0ZW1TdHlsZScsICdib3JkZXJDb2xvcjAnXTtcbnZhciBkb2ppQm9yZGVyQ29sb3JRdWVyeSA9IFsnaXRlbVN0eWxlJywgJ2JvcmRlckNvbG9yRG9qaSddO1xudmFyIHBvc2l0aXZlQ29sb3JRdWVyeSA9IFsnaXRlbVN0eWxlJywgJ2NvbG9yJ107XG52YXIgbmVnYXRpdmVDb2xvclF1ZXJ5ID0gWydpdGVtU3R5bGUnLCAnY29sb3IwJ107XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sb3Ioc2lnbiwgbW9kZWwpIHtcbiAgcmV0dXJuIG1vZGVsLmdldChzaWduID4gMCA/IHBvc2l0aXZlQ29sb3JRdWVyeSA6IG5lZ2F0aXZlQ29sb3JRdWVyeSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm9yZGVyQ29sb3Ioc2lnbiwgbW9kZWwpIHtcbiAgcmV0dXJuIG1vZGVsLmdldChzaWduID09PSAwID8gZG9qaUJvcmRlckNvbG9yUXVlcnkgOiBzaWduID4gMCA/IHBvc2l0aXZlQm9yZGVyQ29sb3JRdWVyeSA6IG5lZ2F0aXZlQm9yZGVyQ29sb3JRdWVyeSk7XG59XG52YXIgY2FuZGxlc3RpY2tWaXN1YWwgPSB7XG4gIHNlcmllc1R5cGU6ICdjYW5kbGVzdGljaycsXG4gIHBsYW46IGNyZWF0ZVJlbmRlclBsYW5uZXIoKSxcbiAgLy8gRm9yIGxlZ2VuZC5cbiAgcGVyZm9ybVJhd1NlcmllczogdHJ1ZSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgIC8vIE9ubHkgdmlzaWJsZSBzZXJpZXMgaGFzIGVhY2ggZGF0YSBiZSB2aXN1YWwgZW5jb2RlZFxuICAgIGlmIChlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpc0xhcmdlUmVuZGVyID0gc2VyaWVzTW9kZWwucGlwZWxpbmVDb250ZXh0LmxhcmdlO1xuICAgIHJldHVybiAhaXNMYXJnZVJlbmRlciAmJiB7XG4gICAgICBwcm9ncmVzczogZnVuY3Rpb24gKHBhcmFtcywgZGF0YSkge1xuICAgICAgICB2YXIgZGF0YUluZGV4O1xuICAgICAgICB3aGlsZSAoKGRhdGFJbmRleCA9IHBhcmFtcy5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KTtcbiAgICAgICAgICB2YXIgc2lnbiA9IGRhdGEuZ2V0SXRlbUxheW91dChkYXRhSW5kZXgpLnNpZ247XG4gICAgICAgICAgdmFyIHN0eWxlID0gaXRlbU1vZGVsLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgICAgIHN0eWxlLmZpbGwgPSBnZXRDb2xvcihzaWduLCBpdGVtTW9kZWwpO1xuICAgICAgICAgIHN0eWxlLnN0cm9rZSA9IGdldEJvcmRlckNvbG9yKHNpZ24sIGl0ZW1Nb2RlbCkgfHwgc3R5bGUuZmlsbDtcbiAgICAgICAgICB2YXIgZXhpc3RzU3R5bGUgPSBkYXRhLmVuc3VyZVVuaXF1ZUl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnc3R5bGUnKTtcbiAgICAgICAgICBleHRlbmQoZXhpc3RzU3R5bGUsIHN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBjYW5kbGVzdGlja1Zpc3VhbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IHsgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsLCB0b2dnbGVIb3ZlckVtcGhhc2lzIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMuanMnO1xuaW1wb3J0IFBhdGggZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzJztcbmltcG9ydCB7IGNyZWF0ZUNsaXBQYXRoIH0gZnJvbSAnLi4vaGVscGVyL2NyZWF0ZUNsaXBQYXRoRnJvbUNvb3JkU3lzLmpzJztcbmltcG9ydCB7IHNhdmVPbGRTdHlsZSB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi9iYXNpY1RyYW5zaXRpb24uanMnO1xuaW1wb3J0IHsgZ2V0Qm9yZGVyQ29sb3IsIGdldENvbG9yIH0gZnJvbSAnLi9jYW5kbGVzdGlja1Zpc3VhbC5qcyc7XG52YXIgU0tJUF9QUk9QUyA9IFsnY29sb3InLCAnYm9yZGVyQ29sb3InXTtcbnZhciBDYW5kbGVzdGlja1ZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ2FuZGxlc3RpY2tWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBDYW5kbGVzdGlja1ZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IENhbmRsZXN0aWNrVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBDYW5kbGVzdGlja1ZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgY2xpcFBhdGggY3JlYXRlZCBpbiBsYXJnZSBtb2RlLiBSZW1vdmUgaXQuXG4gICAgdGhpcy5ncm91cC5yZW1vdmVDbGlwUGF0aCgpO1xuICAgIC8vIENsZWFyIHByZXZpb3VzbHkgcmVuZGVyZWQgcHJvZ3Jlc3NpdmUgZWxlbWVudHMuXG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVFbHMgPSBudWxsO1xuICAgIHRoaXMuX3VwZGF0ZURyYXdNb2RlKHNlcmllc01vZGVsKTtcbiAgICB0aGlzLl9pc0xhcmdlRHJhdyA/IHRoaXMuX3JlbmRlckxhcmdlKHNlcmllc01vZGVsKSA6IHRoaXMuX3JlbmRlck5vcm1hbChzZXJpZXNNb2RlbCk7XG4gIH07XG4gIENhbmRsZXN0aWNrVmlldy5wcm90b3R5cGUuaW5jcmVtZW50YWxQcmVwYXJlUmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLl9jbGVhcigpO1xuICAgIHRoaXMuX3VwZGF0ZURyYXdNb2RlKHNlcmllc01vZGVsKTtcbiAgfTtcbiAgQ2FuZGxlc3RpY2tWaWV3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFJlbmRlciA9IGZ1bmN0aW9uIChwYXJhbXMsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZUVscyA9IFtdO1xuICAgIHRoaXMuX2lzTGFyZ2VEcmF3ID8gdGhpcy5faW5jcmVtZW50YWxSZW5kZXJMYXJnZShwYXJhbXMsIHNlcmllc01vZGVsKSA6IHRoaXMuX2luY3JlbWVudGFsUmVuZGVyTm9ybWFsKHBhcmFtcywgc2VyaWVzTW9kZWwpO1xuICB9O1xuICBDYW5kbGVzdGlja1ZpZXcucHJvdG90eXBlLmVhY2hSZW5kZXJlZCA9IGZ1bmN0aW9uIChjYikge1xuICAgIGdyYXBoaWMudHJhdmVyc2VFbGVtZW50cyh0aGlzLl9wcm9ncmVzc2l2ZUVscyB8fCB0aGlzLmdyb3VwLCBjYik7XG4gIH07XG4gIENhbmRsZXN0aWNrVmlldy5wcm90b3R5cGUuX3VwZGF0ZURyYXdNb2RlID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGlzTGFyZ2VEcmF3ID0gc2VyaWVzTW9kZWwucGlwZWxpbmVDb250ZXh0LmxhcmdlO1xuICAgIGlmICh0aGlzLl9pc0xhcmdlRHJhdyA9PSBudWxsIHx8IGlzTGFyZ2VEcmF3ICE9PSB0aGlzLl9pc0xhcmdlRHJhdykge1xuICAgICAgdGhpcy5faXNMYXJnZURyYXcgPSBpc0xhcmdlRHJhdztcbiAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgfVxuICB9O1xuICBDYW5kbGVzdGlja1ZpZXcucHJvdG90eXBlLl9yZW5kZXJOb3JtYWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgaXNTaW1wbGVCb3ggPSBkYXRhLmdldExheW91dCgnaXNTaW1wbGVCb3gnKTtcbiAgICB2YXIgbmVlZHNDbGlwID0gc2VyaWVzTW9kZWwuZ2V0KCdjbGlwJywgdHJ1ZSk7XG4gICAgdmFyIGNvb3JkID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgY2xpcEFyZWEgPSBjb29yZC5nZXRBcmVhICYmIGNvb3JkLmdldEFyZWEoKTtcbiAgICAvLyBUaGVyZSBpcyBubyBvbGQgZGF0YSBvbmx5IHdoZW4gZmlyc3QgcmVuZGVyaW5nIG9yIHN3aXRjaGluZyBmcm9tXG4gICAgLy8gc3RyZWFtIG1vZGUgdG8gbm9ybWFsIG1vZGUsIHdoZXJlIHByZXZpb3VzIGVsZW1lbnRzIHNob3VsZCBiZSByZW1vdmVkLlxuICAgIGlmICghdGhpcy5fZGF0YSkge1xuICAgICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgfVxuICAgIGRhdGEuZGlmZihvbGREYXRhKS5hZGQoZnVuY3Rpb24gKG5ld0lkeCkge1xuICAgICAgaWYgKGRhdGEuaGFzVmFsdWUobmV3SWR4KSkge1xuICAgICAgICB2YXIgaXRlbUxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpO1xuICAgICAgICBpZiAobmVlZHNDbGlwICYmIGlzTm9ybWFsQm94Q2xpcHBlZChjbGlwQXJlYSwgaXRlbUxheW91dCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsID0gY3JlYXRlTm9ybWFsQm94KGl0ZW1MYXlvdXQsIG5ld0lkeCwgdHJ1ZSk7XG4gICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKGVsLCB7XG4gICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHBvaW50czogaXRlbUxheW91dC5lbmRzXG4gICAgICAgICAgfVxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgbmV3SWR4KTtcbiAgICAgICAgc2V0Qm94Q29tbW9uKGVsLCBkYXRhLCBuZXdJZHgsIGlzU2ltcGxlQm94KTtcbiAgICAgICAgZ3JvdXAuYWRkKGVsKTtcbiAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgZWwpO1xuICAgICAgfVxuICAgIH0pLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICAgIHZhciBlbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuICAgICAgLy8gRW1wdHkgZGF0YVxuICAgICAgaWYgKCFkYXRhLmhhc1ZhbHVlKG5ld0lkeCkpIHtcbiAgICAgICAgZ3JvdXAucmVtb3ZlKGVsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZW1MYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KTtcbiAgICAgIGlmIChuZWVkc0NsaXAgJiYgaXNOb3JtYWxCb3hDbGlwcGVkKGNsaXBBcmVhLCBpdGVtTGF5b3V0KSkge1xuICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIGVsID0gY3JlYXRlTm9ybWFsQm94KGl0ZW1MYXlvdXQsIG5ld0lkeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCB7XG4gICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHBvaW50czogaXRlbUxheW91dC5lbmRzXG4gICAgICAgICAgfVxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgbmV3SWR4KTtcbiAgICAgICAgc2F2ZU9sZFN0eWxlKGVsKTtcbiAgICAgIH1cbiAgICAgIHNldEJveENvbW1vbihlbCwgZGF0YSwgbmV3SWR4LCBpc1NpbXBsZUJveCk7XG4gICAgICBncm91cC5hZGQoZWwpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgZWwpO1xuICAgIH0pLnJlbW92ZShmdW5jdGlvbiAob2xkSWR4KSB7XG4gICAgICB2YXIgZWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICAgIGVsICYmIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgfSkuZXhlY3V0ZSgpO1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9O1xuICBDYW5kbGVzdGlja1ZpZXcucHJvdG90eXBlLl9yZW5kZXJMYXJnZSA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgY3JlYXRlTGFyZ2Uoc2VyaWVzTW9kZWwsIHRoaXMuZ3JvdXApO1xuICAgIHZhciBjbGlwUGF0aCA9IHNlcmllc01vZGVsLmdldCgnY2xpcCcsIHRydWUpID8gY3JlYXRlQ2xpcFBhdGgoc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSwgZmFsc2UsIHNlcmllc01vZGVsKSA6IG51bGw7XG4gICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICB0aGlzLmdyb3VwLnNldENsaXBQYXRoKGNsaXBQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ncm91cC5yZW1vdmVDbGlwUGF0aCgpO1xuICAgIH1cbiAgfTtcbiAgQ2FuZGxlc3RpY2tWaWV3LnByb3RvdHlwZS5faW5jcmVtZW50YWxSZW5kZXJOb3JtYWwgPSBmdW5jdGlvbiAocGFyYW1zLCBzZXJpZXNNb2RlbCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBpc1NpbXBsZUJveCA9IGRhdGEuZ2V0TGF5b3V0KCdpc1NpbXBsZUJveCcpO1xuICAgIHZhciBkYXRhSW5kZXg7XG4gICAgd2hpbGUgKChkYXRhSW5kZXggPSBwYXJhbXMubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICB2YXIgaXRlbUxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChkYXRhSW5kZXgpO1xuICAgICAgdmFyIGVsID0gY3JlYXRlTm9ybWFsQm94KGl0ZW1MYXlvdXQsIGRhdGFJbmRleCk7XG4gICAgICBzZXRCb3hDb21tb24oZWwsIGRhdGEsIGRhdGFJbmRleCwgaXNTaW1wbGVCb3gpO1xuICAgICAgZWwuaW5jcmVtZW50YWwgPSB0cnVlO1xuICAgICAgdGhpcy5ncm91cC5hZGQoZWwpO1xuICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVFbHMucHVzaChlbCk7XG4gICAgfVxuICB9O1xuICBDYW5kbGVzdGlja1ZpZXcucHJvdG90eXBlLl9pbmNyZW1lbnRhbFJlbmRlckxhcmdlID0gZnVuY3Rpb24gKHBhcmFtcywgc2VyaWVzTW9kZWwpIHtcbiAgICBjcmVhdGVMYXJnZShzZXJpZXNNb2RlbCwgdGhpcy5ncm91cCwgdGhpcy5fcHJvZ3Jlc3NpdmVFbHMsIHRydWUpO1xuICB9O1xuICBDYW5kbGVzdGlja1ZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdGhpcy5fY2xlYXIoKTtcbiAgfTtcbiAgQ2FuZGxlc3RpY2tWaWV3LnByb3RvdHlwZS5fY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgfTtcbiAgQ2FuZGxlc3RpY2tWaWV3LnR5cGUgPSAnY2FuZGxlc3RpY2snO1xuICByZXR1cm4gQ2FuZGxlc3RpY2tWaWV3O1xufShDaGFydFZpZXcpO1xudmFyIE5vcm1hbEJveFBhdGhTaGFwZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vcm1hbEJveFBhdGhTaGFwZSgpIHt9XG4gIHJldHVybiBOb3JtYWxCb3hQYXRoU2hhcGU7XG59KCk7XG52YXIgTm9ybWFsQm94UGF0aCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhOb3JtYWxCb3hQYXRoLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBOb3JtYWxCb3hQYXRoKG9wdHMpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSAnbm9ybWFsQ2FuZGxlc3RpY2tCb3gnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBOb3JtYWxCb3hQYXRoLnByb3RvdHlwZS5nZXREZWZhdWx0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBOb3JtYWxCb3hQYXRoU2hhcGUoKTtcbiAgfTtcbiAgTm9ybWFsQm94UGF0aC5wcm90b3R5cGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgZW5kcyA9IHNoYXBlLnBvaW50cztcbiAgICBpZiAodGhpcy5fX3NpbXBsZUJveCkge1xuICAgICAgY3R4Lm1vdmVUbyhlbmRzWzRdWzBdLCBlbmRzWzRdWzFdKTtcbiAgICAgIGN0eC5saW5lVG8oZW5kc1s2XVswXSwgZW5kc1s2XVsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5tb3ZlVG8oZW5kc1swXVswXSwgZW5kc1swXVsxXSk7XG4gICAgICBjdHgubGluZVRvKGVuZHNbMV1bMF0sIGVuZHNbMV1bMV0pO1xuICAgICAgY3R4LmxpbmVUbyhlbmRzWzJdWzBdLCBlbmRzWzJdWzFdKTtcbiAgICAgIGN0eC5saW5lVG8oZW5kc1szXVswXSwgZW5kc1szXVsxXSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKGVuZHNbNF1bMF0sIGVuZHNbNF1bMV0pO1xuICAgICAgY3R4LmxpbmVUbyhlbmRzWzVdWzBdLCBlbmRzWzVdWzFdKTtcbiAgICAgIGN0eC5tb3ZlVG8oZW5kc1s2XVswXSwgZW5kc1s2XVsxXSk7XG4gICAgICBjdHgubGluZVRvKGVuZHNbN11bMF0sIGVuZHNbN11bMV0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE5vcm1hbEJveFBhdGg7XG59KFBhdGgpO1xuZnVuY3Rpb24gY3JlYXRlTm9ybWFsQm94KGl0ZW1MYXlvdXQsIGRhdGFJbmRleCwgaXNJbml0KSB7XG4gIHZhciBlbmRzID0gaXRlbUxheW91dC5lbmRzO1xuICByZXR1cm4gbmV3IE5vcm1hbEJveFBhdGgoe1xuICAgIHNoYXBlOiB7XG4gICAgICBwb2ludHM6IGlzSW5pdCA/IHRyYW5zSW5pdChlbmRzLCBpdGVtTGF5b3V0KSA6IGVuZHNcbiAgICB9LFxuICAgIHoyOiAxMDBcbiAgfSk7XG59XG5mdW5jdGlvbiBpc05vcm1hbEJveENsaXBwZWQoY2xpcEFyZWEsIGl0ZW1MYXlvdXQpIHtcbiAgdmFyIGNsaXBwZWQgPSB0cnVlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1MYXlvdXQuZW5kcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIElmIGFueSBwb2ludCBhcmUgaW4gdGhlIHJlZ2lvbi5cbiAgICBpZiAoY2xpcEFyZWEuY29udGFpbihpdGVtTGF5b3V0LmVuZHNbaV1bMF0sIGl0ZW1MYXlvdXQuZW5kc1tpXVsxXSkpIHtcbiAgICAgIGNsaXBwZWQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xpcHBlZDtcbn1cbmZ1bmN0aW9uIHNldEJveENvbW1vbihlbCwgZGF0YSwgZGF0YUluZGV4LCBpc1NpbXBsZUJveCkge1xuICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KTtcbiAgZWwudXNlU3R5bGUoZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ3N0eWxlJykpO1xuICBlbC5zdHlsZS5zdHJva2VOb1NjYWxlID0gdHJ1ZTtcbiAgZWwuX19zaW1wbGVCb3ggPSBpc1NpbXBsZUJveDtcbiAgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsKGVsLCBpdGVtTW9kZWwpO1xuICB2YXIgc2lnbiA9IGRhdGEuZ2V0SXRlbUxheW91dChkYXRhSW5kZXgpLnNpZ247XG4gIHpyVXRpbC5lYWNoKGVsLnN0YXRlcywgZnVuY3Rpb24gKHN0YXRlLCBzdGF0ZU5hbWUpIHtcbiAgICB2YXIgc3RhdGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChzdGF0ZU5hbWUpO1xuICAgIHZhciBjb2xvciA9IGdldENvbG9yKHNpZ24sIHN0YXRlTW9kZWwpO1xuICAgIHZhciBib3JkZXJDb2xvciA9IGdldEJvcmRlckNvbG9yKHNpZ24sIHN0YXRlTW9kZWwpIHx8IGNvbG9yO1xuICAgIHZhciBzdGF0ZVN0eWxlID0gc3RhdGUuc3R5bGUgfHwgKHN0YXRlLnN0eWxlID0ge30pO1xuICAgIGNvbG9yICYmIChzdGF0ZVN0eWxlLmZpbGwgPSBjb2xvcik7XG4gICAgYm9yZGVyQ29sb3IgJiYgKHN0YXRlU3R5bGUuc3Ryb2tlID0gYm9yZGVyQ29sb3IpO1xuICB9KTtcbiAgdmFyIGVtcGhhc2lzTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJyk7XG4gIHRvZ2dsZUhvdmVyRW1waGFzaXMoZWwsIGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpLCBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJyksIGVtcGhhc2lzTW9kZWwuZ2V0KCdkaXNhYmxlZCcpKTtcbn1cbmZ1bmN0aW9uIHRyYW5zSW5pdChwb2ludHMsIGl0ZW1MYXlvdXQpIHtcbiAgcmV0dXJuIHpyVXRpbC5tYXAocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICBwb2ludCA9IHBvaW50LnNsaWNlKCk7XG4gICAgcG9pbnRbMV0gPSBpdGVtTGF5b3V0LmluaXRCYXNlbGluZTtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH0pO1xufVxudmFyIExhcmdlQm94UGF0aFNoYXBlID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGFyZ2VCb3hQYXRoU2hhcGUoKSB7fVxuICByZXR1cm4gTGFyZ2VCb3hQYXRoU2hhcGU7XG59KCk7XG52YXIgTGFyZ2VCb3hQYXRoID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKExhcmdlQm94UGF0aCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gTGFyZ2VCb3hQYXRoKG9wdHMpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSAnbGFyZ2VDYW5kbGVzdGlja0JveCc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIExhcmdlQm94UGF0aC5wcm90b3R5cGUuZ2V0RGVmYXVsdFNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgTGFyZ2VCb3hQYXRoU2hhcGUoKTtcbiAgfTtcbiAgTGFyZ2VCb3hQYXRoLnByb3RvdHlwZS5idWlsZFBhdGggPSBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIC8vIERyYXdpbmcgbGluZXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBkcmF3aW5nXG4gICAgLy8gYSB3aG9sZSBsaW5lIG9yIGRyYXdpbmcgcmVjdHMuXG4gICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7KSB7XG4gICAgICBpZiAodGhpcy5fX3NpZ24gPT09IHBvaW50c1tpKytdKSB7XG4gICAgICAgIHZhciB4ID0gcG9pbnRzW2krK107XG4gICAgICAgIGN0eC5tb3ZlVG8oeCwgcG9pbnRzW2krK10pO1xuICAgICAgICBjdHgubGluZVRvKHgsIHBvaW50c1tpKytdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkgKz0gMztcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBMYXJnZUJveFBhdGg7XG59KFBhdGgpO1xuZnVuY3Rpb24gY3JlYXRlTGFyZ2Uoc2VyaWVzTW9kZWwsIGdyb3VwLCBwcm9ncmVzc2l2ZUVscywgaW5jcmVtZW50YWwpIHtcbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gIHZhciBsYXJnZVBvaW50cyA9IGRhdGEuZ2V0TGF5b3V0KCdsYXJnZVBvaW50cycpO1xuICB2YXIgZWxQID0gbmV3IExhcmdlQm94UGF0aCh7XG4gICAgc2hhcGU6IHtcbiAgICAgIHBvaW50czogbGFyZ2VQb2ludHNcbiAgICB9LFxuICAgIF9fc2lnbjogMSxcbiAgICBpZ25vcmVDb2Fyc2VQb2ludGVyOiB0cnVlXG4gIH0pO1xuICBncm91cC5hZGQoZWxQKTtcbiAgdmFyIGVsTiA9IG5ldyBMYXJnZUJveFBhdGgoe1xuICAgIHNoYXBlOiB7XG4gICAgICBwb2ludHM6IGxhcmdlUG9pbnRzXG4gICAgfSxcbiAgICBfX3NpZ246IC0xLFxuICAgIGlnbm9yZUNvYXJzZVBvaW50ZXI6IHRydWVcbiAgfSk7XG4gIGdyb3VwLmFkZChlbE4pO1xuICB2YXIgZWxEb2ppID0gbmV3IExhcmdlQm94UGF0aCh7XG4gICAgc2hhcGU6IHtcbiAgICAgIHBvaW50czogbGFyZ2VQb2ludHNcbiAgICB9LFxuICAgIF9fc2lnbjogMCxcbiAgICBpZ25vcmVDb2Fyc2VQb2ludGVyOiB0cnVlXG4gIH0pO1xuICBncm91cC5hZGQoZWxEb2ppKTtcbiAgc2V0TGFyZ2VTdHlsZSgxLCBlbFAsIHNlcmllc01vZGVsLCBkYXRhKTtcbiAgc2V0TGFyZ2VTdHlsZSgtMSwgZWxOLCBzZXJpZXNNb2RlbCwgZGF0YSk7XG4gIHNldExhcmdlU3R5bGUoMCwgZWxEb2ppLCBzZXJpZXNNb2RlbCwgZGF0YSk7XG4gIGlmIChpbmNyZW1lbnRhbCkge1xuICAgIGVsUC5pbmNyZW1lbnRhbCA9IHRydWU7XG4gICAgZWxOLmluY3JlbWVudGFsID0gdHJ1ZTtcbiAgfVxuICBpZiAocHJvZ3Jlc3NpdmVFbHMpIHtcbiAgICBwcm9ncmVzc2l2ZUVscy5wdXNoKGVsUCwgZWxOKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0TGFyZ2VTdHlsZShzaWduLCBlbCwgc2VyaWVzTW9kZWwsIGRhdGEpIHtcbiAgLy8gVE9ETyBwdXQgaW4gdmlzdWFsP1xuICB2YXIgYm9yZGVyQ29sb3IgPSBnZXRCb3JkZXJDb2xvcihzaWduLCBzZXJpZXNNb2RlbClcbiAgLy8gVXNlIGNvbG9yIGZvciBib3JkZXIgY29sb3IgYnkgZGVmYXVsdC5cbiAgfHwgZ2V0Q29sb3Ioc2lnbiwgc2VyaWVzTW9kZWwpO1xuICAvLyBDb2xvciBtdXN0IGJlIGV4Y2x1ZGVkLlxuICAvLyBCZWNhdXNlIHN5bWJvbCBwcm92aWRlIHNldENvbG9yIGluZGl2aWR1YWxseSB0byBzZXQgZmlsbCBhbmQgc3Ryb2tlXG4gIHZhciBpdGVtU3R5bGUgPSBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJykuZ2V0SXRlbVN0eWxlKFNLSVBfUFJPUFMpO1xuICBlbC51c2VTdHlsZShpdGVtU3R5bGUpO1xuICBlbC5zdHlsZS5maWxsID0gbnVsbDtcbiAgZWwuc3R5bGUuc3Ryb2tlID0gYm9yZGVyQ29sb3I7XG59XG5leHBvcnQgZGVmYXVsdCBDYW5kbGVzdGlja1ZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMuanMnO1xuaW1wb3J0IHsgV2hpc2tlckJveENvbW1vbk1peGluIH0gZnJvbSAnLi4vaGVscGVyL3doaXNrZXJCb3hDb21tb24uanMnO1xuaW1wb3J0IHsgbWl4aW4gfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xudmFyIENhbmRsZXN0aWNrU2VyaWVzTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ2FuZGxlc3RpY2tTZXJpZXNNb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gQ2FuZGxlc3RpY2tTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gQ2FuZGxlc3RpY2tTZXJpZXNNb2RlbC50eXBlO1xuICAgIF90aGlzLmRlZmF1bHRWYWx1ZURpbWVuc2lvbnMgPSBbe1xuICAgICAgbmFtZTogJ29wZW4nLFxuICAgICAgZGVmYXVsdFRvb2x0aXA6IHRydWVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnY2xvc2UnLFxuICAgICAgZGVmYXVsdFRvb2x0aXA6IHRydWVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbG93ZXN0JyxcbiAgICAgIGRlZmF1bHRUb29sdGlwOiB0cnVlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2hpZ2hlc3QnLFxuICAgICAgZGVmYXVsdFRvb2x0aXA6IHRydWVcbiAgICB9XTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGRpbWVuc2lvbiBmb3Igc2hhZG93IGluIGRhdGFab29tXHJcbiAgICogQHJldHVybiBkaW1lbnNpb24gbmFtZVxyXG4gICAqL1xuICBDYW5kbGVzdGlja1Nlcmllc01vZGVsLnByb3RvdHlwZS5nZXRTaGFkb3dEaW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdvcGVuJztcbiAgfTtcbiAgQ2FuZGxlc3RpY2tTZXJpZXNNb2RlbC5wcm90b3R5cGUuYnJ1c2hTZWxlY3RvciA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIGRhdGEsIHNlbGVjdG9ycykge1xuICAgIHZhciBpdGVtTGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGRhdGFJbmRleCk7XG4gICAgcmV0dXJuIGl0ZW1MYXlvdXQgJiYgc2VsZWN0b3JzLnJlY3QoaXRlbUxheW91dC5icnVzaFJlY3QpO1xuICB9O1xuICBDYW5kbGVzdGlja1Nlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLmNhbmRsZXN0aWNrJztcbiAgQ2FuZGxlc3RpY2tTZXJpZXNNb2RlbC5kZXBlbmRlbmNpZXMgPSBbJ3hBeGlzJywgJ3lBeGlzJywgJ2dyaWQnXTtcbiAgQ2FuZGxlc3RpY2tTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIC8vIHpsZXZlbDogMCxcbiAgICB6OiAyLFxuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdjYXJ0ZXNpYW4yZCcsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIC8vIHhBeGlzSW5kZXg6IDAsXG4gICAgLy8geUF4aXNJbmRleDogMCxcbiAgICBsYXlvdXQ6IG51bGwsXG4gICAgY2xpcDogdHJ1ZSxcbiAgICBpdGVtU3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnI2ViNTQ1NCcsXG4gICAgICBjb2xvcjA6ICcjNDdiMjYyJyxcbiAgICAgIGJvcmRlckNvbG9yOiAnI2ViNTQ1NCcsXG4gICAgICBib3JkZXJDb2xvcjA6ICcjNDdiMjYyJyxcbiAgICAgIGJvcmRlckNvbG9yRG9qaTogbnVsbCxcbiAgICAgIC8vIGJvcmRlckNvbG9yOiAnI2QyNDA0MCcsXG4gICAgICAvLyBib3JkZXJDb2xvcjA6ICcjMzk4ZjRmJyxcbiAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGJvcmRlcldpZHRoOiAyXG4gICAgICB9XG4gICAgfSxcbiAgICBiYXJNYXhXaWR0aDogbnVsbCxcbiAgICBiYXJNaW5XaWR0aDogbnVsbCxcbiAgICBiYXJXaWR0aDogbnVsbCxcbiAgICBsYXJnZTogdHJ1ZSxcbiAgICBsYXJnZVRocmVzaG9sZDogNjAwLFxuICAgIHByb2dyZXNzaXZlOiAzZTMsXG4gICAgcHJvZ3Jlc3NpdmVUaHJlc2hvbGQ6IDFlNCxcbiAgICBwcm9ncmVzc2l2ZUNodW5rTW9kZTogJ21vZCcsXG4gICAgYW5pbWF0aW9uRWFzaW5nOiAnbGluZWFyJyxcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMzAwXG4gIH07XG4gIHJldHVybiBDYW5kbGVzdGlja1Nlcmllc01vZGVsO1xufShTZXJpZXNNb2RlbCk7XG5taXhpbihDYW5kbGVzdGlja1Nlcmllc01vZGVsLCBXaGlza2VyQm94Q29tbW9uTWl4aW4sIHRydWUpO1xuZXhwb3J0IGRlZmF1bHQgQ2FuZGxlc3RpY2tTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2FuZGxlc3RpY2tQcmVwcm9jZXNzb3Iob3B0aW9uKSB7XG4gIGlmICghb3B0aW9uIHx8ICF6clV0aWwuaXNBcnJheShvcHRpb24uc2VyaWVzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBUcmFuc2xhdGUgJ2snIHRvICdjYW5kbGVzdGljaycuXG4gIHpyVXRpbC5lYWNoKG9wdGlvbi5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNJdGVtKSB7XG4gICAgaWYgKHpyVXRpbC5pc09iamVjdChzZXJpZXNJdGVtKSAmJiBzZXJpZXNJdGVtLnR5cGUgPT09ICdrJykge1xuICAgICAgc2VyaWVzSXRlbS50eXBlID0gJ2NhbmRsZXN0aWNrJztcbiAgICB9XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgc3ViUGl4ZWxPcHRpbWl6ZSB9IGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgY3JlYXRlUmVuZGVyUGxhbm5lciBmcm9tICcuLi9oZWxwZXIvY3JlYXRlUmVuZGVyUGxhbm5lci5qcyc7XG5pbXBvcnQgeyBwYXJzZVBlcmNlbnQgfSBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7XG5pbXBvcnQgeyBtYXAsIHJldHJpZXZlMiB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVGbG9hdDMyQXJyYXkgfSBmcm9tICcuLi8uLi91dGlsL3ZlbmRvci5qcyc7XG52YXIgY2FuZGxlc3RpY2tMYXlvdXQgPSB7XG4gIHNlcmllc1R5cGU6ICdjYW5kbGVzdGljaycsXG4gIHBsYW46IGNyZWF0ZVJlbmRlclBsYW5uZXIoKSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGNhbmRsZVdpZHRoID0gY2FsY3VsYXRlQ2FuZGxlV2lkdGgoc2VyaWVzTW9kZWwsIGRhdGEpO1xuICAgIHZhciBjRGltSWR4ID0gMDtcbiAgICB2YXIgdkRpbUlkeCA9IDE7XG4gICAgdmFyIGNvb3JkRGltcyA9IFsneCcsICd5J107XG4gICAgdmFyIGNEaW1JID0gZGF0YS5nZXREaW1lbnNpb25JbmRleChkYXRhLm1hcERpbWVuc2lvbihjb29yZERpbXNbY0RpbUlkeF0pKTtcbiAgICB2YXIgdkRpbXNJID0gbWFwKGRhdGEubWFwRGltZW5zaW9uc0FsbChjb29yZERpbXNbdkRpbUlkeF0pLCBkYXRhLmdldERpbWVuc2lvbkluZGV4LCBkYXRhKTtcbiAgICB2YXIgb3BlbkRpbUkgPSB2RGltc0lbMF07XG4gICAgdmFyIGNsb3NlRGltSSA9IHZEaW1zSVsxXTtcbiAgICB2YXIgbG93ZXN0RGltSSA9IHZEaW1zSVsyXTtcbiAgICB2YXIgaGlnaGVzdERpbUkgPSB2RGltc0lbM107XG4gICAgZGF0YS5zZXRMYXlvdXQoe1xuICAgICAgY2FuZGxlV2lkdGg6IGNhbmRsZVdpZHRoLFxuICAgICAgLy8gVGhlIHZhbHVlIGlzIGV4cGVyaW1lbnRlZCB2aXN1YWxseS5cbiAgICAgIGlzU2ltcGxlQm94OiBjYW5kbGVXaWR0aCA8PSAxLjNcbiAgICB9KTtcbiAgICBpZiAoY0RpbUkgPCAwIHx8IHZEaW1zSS5sZW5ndGggPCA0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwcm9ncmVzczogc2VyaWVzTW9kZWwucGlwZWxpbmVDb250ZXh0LmxhcmdlID8gbGFyZ2VQcm9ncmVzcyA6IG5vcm1hbFByb2dyZXNzXG4gICAgfTtcbiAgICBmdW5jdGlvbiBub3JtYWxQcm9ncmVzcyhwYXJhbXMsIGRhdGEpIHtcbiAgICAgIHZhciBkYXRhSW5kZXg7XG4gICAgICB2YXIgc3RvcmUgPSBkYXRhLmdldFN0b3JlKCk7XG4gICAgICB3aGlsZSAoKGRhdGFJbmRleCA9IHBhcmFtcy5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGF4aXNEaW1WYWwgPSBzdG9yZS5nZXQoY0RpbUksIGRhdGFJbmRleCk7XG4gICAgICAgIHZhciBvcGVuVmFsID0gc3RvcmUuZ2V0KG9wZW5EaW1JLCBkYXRhSW5kZXgpO1xuICAgICAgICB2YXIgY2xvc2VWYWwgPSBzdG9yZS5nZXQoY2xvc2VEaW1JLCBkYXRhSW5kZXgpO1xuICAgICAgICB2YXIgbG93ZXN0VmFsID0gc3RvcmUuZ2V0KGxvd2VzdERpbUksIGRhdGFJbmRleCk7XG4gICAgICAgIHZhciBoaWdoZXN0VmFsID0gc3RvcmUuZ2V0KGhpZ2hlc3REaW1JLCBkYXRhSW5kZXgpO1xuICAgICAgICB2YXIgb2NMb3cgPSBNYXRoLm1pbihvcGVuVmFsLCBjbG9zZVZhbCk7XG4gICAgICAgIHZhciBvY0hpZ2ggPSBNYXRoLm1heChvcGVuVmFsLCBjbG9zZVZhbCk7XG4gICAgICAgIHZhciBvY0xvd1BvaW50ID0gZ2V0UG9pbnQob2NMb3csIGF4aXNEaW1WYWwpO1xuICAgICAgICB2YXIgb2NIaWdoUG9pbnQgPSBnZXRQb2ludChvY0hpZ2gsIGF4aXNEaW1WYWwpO1xuICAgICAgICB2YXIgbG93ZXN0UG9pbnQgPSBnZXRQb2ludChsb3dlc3RWYWwsIGF4aXNEaW1WYWwpO1xuICAgICAgICB2YXIgaGlnaGVzdFBvaW50ID0gZ2V0UG9pbnQoaGlnaGVzdFZhbCwgYXhpc0RpbVZhbCk7XG4gICAgICAgIHZhciBlbmRzID0gW107XG4gICAgICAgIGFkZEJvZHlFbmQoZW5kcywgb2NIaWdoUG9pbnQsIDApO1xuICAgICAgICBhZGRCb2R5RW5kKGVuZHMsIG9jTG93UG9pbnQsIDEpO1xuICAgICAgICBlbmRzLnB1c2goc3ViUGl4ZWxPcHRpbWl6ZVBvaW50KGhpZ2hlc3RQb2ludCksIHN1YlBpeGVsT3B0aW1pemVQb2ludChvY0hpZ2hQb2ludCksIHN1YlBpeGVsT3B0aW1pemVQb2ludChsb3dlc3RQb2ludCksIHN1YlBpeGVsT3B0aW1pemVQb2ludChvY0xvd1BvaW50KSk7XG4gICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChkYXRhSW5kZXgpO1xuICAgICAgICB2YXIgaGFzRG9qaUNvbG9yID0gISFpdGVtTW9kZWwuZ2V0KFsnaXRlbVN0eWxlJywgJ2JvcmRlckNvbG9yRG9qaSddKTtcbiAgICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KGRhdGFJbmRleCwge1xuICAgICAgICAgIHNpZ246IGdldFNpZ24oc3RvcmUsIGRhdGFJbmRleCwgb3BlblZhbCwgY2xvc2VWYWwsIGNsb3NlRGltSSwgaGFzRG9qaUNvbG9yKSxcbiAgICAgICAgICBpbml0QmFzZWxpbmU6IG9wZW5WYWwgPiBjbG9zZVZhbCA/IG9jSGlnaFBvaW50W3ZEaW1JZHhdIDogb2NMb3dQb2ludFt2RGltSWR4XSxcbiAgICAgICAgICBlbmRzOiBlbmRzLFxuICAgICAgICAgIGJydXNoUmVjdDogbWFrZUJydXNoUmVjdChsb3dlc3RWYWwsIGhpZ2hlc3RWYWwsIGF4aXNEaW1WYWwpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0UG9pbnQodmFsLCBheGlzRGltVmFsKSB7XG4gICAgICAgIHZhciBwID0gW107XG4gICAgICAgIHBbY0RpbUlkeF0gPSBheGlzRGltVmFsO1xuICAgICAgICBwW3ZEaW1JZHhdID0gdmFsO1xuICAgICAgICByZXR1cm4gaXNOYU4oYXhpc0RpbVZhbCkgfHwgaXNOYU4odmFsKSA/IFtOYU4sIE5hTl0gOiBjb29yZFN5cy5kYXRhVG9Qb2ludChwKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGFkZEJvZHlFbmQoZW5kcywgcG9pbnQsIHN0YXJ0KSB7XG4gICAgICAgIHZhciBwb2ludDEgPSBwb2ludC5zbGljZSgpO1xuICAgICAgICB2YXIgcG9pbnQyID0gcG9pbnQuc2xpY2UoKTtcbiAgICAgICAgcG9pbnQxW2NEaW1JZHhdID0gc3ViUGl4ZWxPcHRpbWl6ZShwb2ludDFbY0RpbUlkeF0gKyBjYW5kbGVXaWR0aCAvIDIsIDEsIGZhbHNlKTtcbiAgICAgICAgcG9pbnQyW2NEaW1JZHhdID0gc3ViUGl4ZWxPcHRpbWl6ZShwb2ludDJbY0RpbUlkeF0gLSBjYW5kbGVXaWR0aCAvIDIsIDEsIHRydWUpO1xuICAgICAgICBzdGFydCA/IGVuZHMucHVzaChwb2ludDEsIHBvaW50MikgOiBlbmRzLnB1c2gocG9pbnQyLCBwb2ludDEpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbWFrZUJydXNoUmVjdChsb3dlc3RWYWwsIGhpZ2hlc3RWYWwsIGF4aXNEaW1WYWwpIHtcbiAgICAgICAgdmFyIHBtaW4gPSBnZXRQb2ludChsb3dlc3RWYWwsIGF4aXNEaW1WYWwpO1xuICAgICAgICB2YXIgcG1heCA9IGdldFBvaW50KGhpZ2hlc3RWYWwsIGF4aXNEaW1WYWwpO1xuICAgICAgICBwbWluW2NEaW1JZHhdIC09IGNhbmRsZVdpZHRoIC8gMjtcbiAgICAgICAgcG1heFtjRGltSWR4XSAtPSBjYW5kbGVXaWR0aCAvIDI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcG1pblswXSxcbiAgICAgICAgICB5OiBwbWluWzFdLFxuICAgICAgICAgIHdpZHRoOiB2RGltSWR4ID8gY2FuZGxlV2lkdGggOiBwbWF4WzBdIC0gcG1pblswXSxcbiAgICAgICAgICBoZWlnaHQ6IHZEaW1JZHggPyBwbWF4WzFdIC0gcG1pblsxXSA6IGNhbmRsZVdpZHRoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzdWJQaXhlbE9wdGltaXplUG9pbnQocG9pbnQpIHtcbiAgICAgICAgcG9pbnRbY0RpbUlkeF0gPSBzdWJQaXhlbE9wdGltaXplKHBvaW50W2NEaW1JZHhdLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsYXJnZVByb2dyZXNzKHBhcmFtcywgZGF0YSkge1xuICAgICAgLy8gU3RydWN0dXJlOiBbc2lnbiwgeCwgeWhpZ2gsIHlsb3csIHNpZ24sIHgsIHloaWdoLCB5bG93LCAuLi5dXG4gICAgICB2YXIgcG9pbnRzID0gY3JlYXRlRmxvYXQzMkFycmF5KHBhcmFtcy5jb3VudCAqIDQpO1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICB2YXIgcG9pbnQ7XG4gICAgICB2YXIgdG1wSW4gPSBbXTtcbiAgICAgIHZhciB0bXBPdXQgPSBbXTtcbiAgICAgIHZhciBkYXRhSW5kZXg7XG4gICAgICB2YXIgc3RvcmUgPSBkYXRhLmdldFN0b3JlKCk7XG4gICAgICB2YXIgaGFzRG9qaUNvbG9yID0gISFzZXJpZXNNb2RlbC5nZXQoWydpdGVtU3R5bGUnLCAnYm9yZGVyQ29sb3JEb2ppJ10pO1xuICAgICAgd2hpbGUgKChkYXRhSW5kZXggPSBwYXJhbXMubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBheGlzRGltVmFsID0gc3RvcmUuZ2V0KGNEaW1JLCBkYXRhSW5kZXgpO1xuICAgICAgICB2YXIgb3BlblZhbCA9IHN0b3JlLmdldChvcGVuRGltSSwgZGF0YUluZGV4KTtcbiAgICAgICAgdmFyIGNsb3NlVmFsID0gc3RvcmUuZ2V0KGNsb3NlRGltSSwgZGF0YUluZGV4KTtcbiAgICAgICAgdmFyIGxvd2VzdFZhbCA9IHN0b3JlLmdldChsb3dlc3REaW1JLCBkYXRhSW5kZXgpO1xuICAgICAgICB2YXIgaGlnaGVzdFZhbCA9IHN0b3JlLmdldChoaWdoZXN0RGltSSwgZGF0YUluZGV4KTtcbiAgICAgICAgaWYgKGlzTmFOKGF4aXNEaW1WYWwpIHx8IGlzTmFOKGxvd2VzdFZhbCkgfHwgaXNOYU4oaGlnaGVzdFZhbCkpIHtcbiAgICAgICAgICBwb2ludHNbb2Zmc2V0KytdID0gTmFOO1xuICAgICAgICAgIG9mZnNldCArPSAzO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHBvaW50c1tvZmZzZXQrK10gPSBnZXRTaWduKHN0b3JlLCBkYXRhSW5kZXgsIG9wZW5WYWwsIGNsb3NlVmFsLCBjbG9zZURpbUksIGhhc0RvamlDb2xvcik7XG4gICAgICAgIHRtcEluW2NEaW1JZHhdID0gYXhpc0RpbVZhbDtcbiAgICAgICAgdG1wSW5bdkRpbUlkeF0gPSBsb3dlc3RWYWw7XG4gICAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQodG1wSW4sIG51bGwsIHRtcE91dCk7XG4gICAgICAgIHBvaW50c1tvZmZzZXQrK10gPSBwb2ludCA/IHBvaW50WzBdIDogTmFOO1xuICAgICAgICBwb2ludHNbb2Zmc2V0KytdID0gcG9pbnQgPyBwb2ludFsxXSA6IE5hTjtcbiAgICAgICAgdG1wSW5bdkRpbUlkeF0gPSBoaWdoZXN0VmFsO1xuICAgICAgICBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KHRtcEluLCBudWxsLCB0bXBPdXQpO1xuICAgICAgICBwb2ludHNbb2Zmc2V0KytdID0gcG9pbnQgPyBwb2ludFsxXSA6IE5hTjtcbiAgICAgIH1cbiAgICAgIGRhdGEuc2V0TGF5b3V0KCdsYXJnZVBvaW50cycsIHBvaW50cyk7XG4gICAgfVxuICB9XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgc2lnbiBvZiBhIHNpbmdsZSBkYXRhLlxyXG4gKlxyXG4gKiBAcmV0dXJucyAwIGZvciBkb2ppIHdpdGggaGFzRG9qaUNvbG9yOiB0cnVlLFxyXG4gKiAgICAgICAgICAxIGZvciBwb3NpdGl2ZSxcclxuICogICAgICAgICAgLTEgZm9yIG5lZ2F0aXZlLlxyXG4gKi9cbmZ1bmN0aW9uIGdldFNpZ24oc3RvcmUsIGRhdGFJbmRleCwgb3BlblZhbCwgY2xvc2VWYWwsIGNsb3NlRGltSSwgaGFzRG9qaUNvbG9yKSB7XG4gIHZhciBzaWduO1xuICBpZiAob3BlblZhbCA+IGNsb3NlVmFsKSB7XG4gICAgc2lnbiA9IC0xO1xuICB9IGVsc2UgaWYgKG9wZW5WYWwgPCBjbG9zZVZhbCkge1xuICAgIHNpZ24gPSAxO1xuICB9IGVsc2Uge1xuICAgIHNpZ24gPSBoYXNEb2ppQ29sb3JcbiAgICAvLyBXaGVuIGRvamkgY29sb3IgaXMgc2V0LCB1c2UgaXQgaW5zdGVhZCBvZiBjb2xvci9jb2xvcjAuXG4gICAgPyAwIDogZGF0YUluZGV4ID4gMFxuICAgIC8vIElmIGNsb3NlID09PSBvcGVuLCBjb21wYXJlIHdpdGggY2xvc2Ugb2YgbGFzdCByZWNvcmRcbiAgICA/IHN0b3JlLmdldChjbG9zZURpbUksIGRhdGFJbmRleCAtIDEpIDw9IGNsb3NlVmFsID8gMSA6IC0xXG4gICAgLy8gTm8gcmVjb3JkIG9mIHByZXZpb3VzLCBzZXQgdG8gYmUgcG9zaXRpdmVcbiAgICA6IDE7XG4gIH1cbiAgcmV0dXJuIHNpZ247XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVDYW5kbGVXaWR0aChzZXJpZXNNb2RlbCwgZGF0YSkge1xuICB2YXIgYmFzZUF4aXMgPSBzZXJpZXNNb2RlbC5nZXRCYXNlQXhpcygpO1xuICB2YXIgZXh0ZW50O1xuICB2YXIgYmFuZFdpZHRoID0gYmFzZUF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IGJhc2VBeGlzLmdldEJhbmRXaWR0aCgpIDogKGV4dGVudCA9IGJhc2VBeGlzLmdldEV4dGVudCgpLCBNYXRoLmFicyhleHRlbnRbMV0gLSBleHRlbnRbMF0pIC8gZGF0YS5jb3VudCgpKTtcbiAgdmFyIGJhck1heFdpZHRoID0gcGFyc2VQZXJjZW50KHJldHJpZXZlMihzZXJpZXNNb2RlbC5nZXQoJ2Jhck1heFdpZHRoJyksIGJhbmRXaWR0aCksIGJhbmRXaWR0aCk7XG4gIHZhciBiYXJNaW5XaWR0aCA9IHBhcnNlUGVyY2VudChyZXRyaWV2ZTIoc2VyaWVzTW9kZWwuZ2V0KCdiYXJNaW5XaWR0aCcpLCAxKSwgYmFuZFdpZHRoKTtcbiAgdmFyIGJhcldpZHRoID0gc2VyaWVzTW9kZWwuZ2V0KCdiYXJXaWR0aCcpO1xuICByZXR1cm4gYmFyV2lkdGggIT0gbnVsbCA/IHBhcnNlUGVyY2VudChiYXJXaWR0aCwgYmFuZFdpZHRoKVxuICAvLyBQdXQgbWF4IG91dGVyIHRvIGVuc3VyZSBiYXIgdmlzaWJsZSBpbiBzcGl0ZSBvZiBvdmVybGFwLlxuICA6IE1hdGgubWF4KE1hdGgubWluKGJhbmRXaWR0aCAvIDIsIGJhck1heFdpZHRoKSwgYmFyTWluV2lkdGgpO1xufVxuZXhwb3J0IGRlZmF1bHQgY2FuZGxlc3RpY2tMYXlvdXQ7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgQ2FuZGxlc3RpY2tWaWV3IGZyb20gJy4vQ2FuZGxlc3RpY2tWaWV3LmpzJztcbmltcG9ydCBDYW5kbGVzdGlja1Nlcmllc01vZGVsIGZyb20gJy4vQ2FuZGxlc3RpY2tTZXJpZXMuanMnO1xuaW1wb3J0IHByZXByb2Nlc3NvciBmcm9tICcuL3ByZXByb2Nlc3Nvci5qcyc7XG5pbXBvcnQgY2FuZGxlc3RpY2tWaXN1YWwgZnJvbSAnLi9jYW5kbGVzdGlja1Zpc3VhbC5qcyc7XG5pbXBvcnQgY2FuZGxlc3RpY2tMYXlvdXQgZnJvbSAnLi9jYW5kbGVzdGlja0xheW91dC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ2hhcnRWaWV3KENhbmRsZXN0aWNrVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclNlcmllc01vZGVsKENhbmRsZXN0aWNrU2VyaWVzTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJQcmVwcm9jZXNzb3IocHJlcHJvY2Vzc29yKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyVmlzdWFsKGNhbmRsZXN0aWNrVmlzdWFsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KGNhbmRsZXN0aWNrTGF5b3V0KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///56699\n")},61152:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Circle.js\nvar Circle = __webpack_require__(31571);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/symbol.js\nvar symbol = __webpack_require__(62103);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/labelHelper.js\nvar labelHelper = __webpack_require__(44532);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Image.js\nvar Image = __webpack_require__(90540);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js\nvar createClipPathFromCoordSys = __webpack_require__(95235);\n;// ./node_modules/echarts/lib/chart/bar/PictorialBarView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'borderWidth'];\n// index: +isHorizontal\nvar LAYOUT_ATTRS = [{\n  xy: 'x',\n  wh: 'width',\n  index: 0,\n  posDesc: ['left', 'right']\n}, {\n  xy: 'y',\n  wh: 'height',\n  index: 1,\n  posDesc: ['top', 'bottom']\n}];\nvar pathForLineWidth = new Circle/* default */.A();\nvar PictorialBarView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(PictorialBarView, _super);\n  function PictorialBarView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = PictorialBarView.type;\n    return _this;\n  }\n  PictorialBarView.prototype.render = function (seriesModel, ecModel, api) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var isHorizontal = baseAxis.isHorizontal();\n    var coordSysRect = cartesian.master.getRect();\n    var opt = {\n      ecSize: {\n        width: api.getWidth(),\n        height: api.getHeight()\n      },\n      seriesModel: seriesModel,\n      coordSys: cartesian,\n      coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],\n      isHorizontal: isHorizontal,\n      valueDim: LAYOUT_ATTRS[+isHorizontal],\n      categoryDim: LAYOUT_ATTRS[1 - +isHorizontal]\n    };\n    data.diff(oldData).add(function (dataIndex) {\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n      var itemModel = getItemModel(data, dataIndex);\n      var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);\n      var bar = createBar(data, opt, symbolMeta);\n      data.setItemGraphicEl(dataIndex, bar);\n      group.add(bar);\n      updateCommon(bar, opt, symbolMeta);\n    }).update(function (newIndex, oldIndex) {\n      var bar = oldData.getItemGraphicEl(oldIndex);\n      if (!data.hasValue(newIndex)) {\n        group.remove(bar);\n        return;\n      }\n      var itemModel = getItemModel(data, newIndex);\n      var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);\n      var pictorialShapeStr = getShapeStr(data, symbolMeta);\n      if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {\n        group.remove(bar);\n        data.setItemGraphicEl(newIndex, null);\n        bar = null;\n      }\n      if (bar) {\n        updateBar(bar, opt, symbolMeta);\n      } else {\n        bar = createBar(data, opt, symbolMeta, true);\n      }\n      data.setItemGraphicEl(newIndex, bar);\n      bar.__pictorialSymbolMeta = symbolMeta;\n      // Add back\n      group.add(bar);\n      updateCommon(bar, opt, symbolMeta);\n    }).remove(function (dataIndex) {\n      var bar = oldData.getItemGraphicEl(dataIndex);\n      bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);\n    }).execute();\n    // Do clipping\n    var clipPath = seriesModel.get('clip', true) ? (0,createClipPathFromCoordSys/* createClipPath */.Ip)(seriesModel.coordinateSystem, false, seriesModel) : null;\n    if (clipPath) {\n      group.setClipPath(clipPath);\n    } else {\n      group.removeClipPath();\n    }\n    this._data = data;\n    return this.group;\n  };\n  PictorialBarView.prototype.remove = function (ecModel, api) {\n    var group = this.group;\n    var data = this._data;\n    if (ecModel.get('animation')) {\n      if (data) {\n        data.eachItemGraphicEl(function (bar) {\n          removeBar(data, (0,innerStore/* getECData */.z)(bar).dataIndex, ecModel, bar);\n        });\n      }\n    } else {\n      group.removeAll();\n    }\n  };\n  PictorialBarView.type = 'pictorialBar';\n  return PictorialBarView;\n}(Chart/* default */.A);\n// Set or calculate default value about symbol, and calculate layout info.\nfunction getSymbolMeta(data, dataIndex, itemModel, opt) {\n  var layout = data.getItemLayout(dataIndex);\n  var symbolRepeat = itemModel.get('symbolRepeat');\n  var symbolClip = itemModel.get('symbolClip');\n  var symbolPosition = itemModel.get('symbolPosition') || 'start';\n  var symbolRotate = itemModel.get('symbolRotate');\n  var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n  var symbolPatternSize = itemModel.get('symbolPatternSize') || 2;\n  var isAnimationEnabled = itemModel.isAnimationEnabled();\n  var symbolMeta = {\n    dataIndex: dataIndex,\n    layout: layout,\n    itemModel: itemModel,\n    symbolType: data.getItemVisual(dataIndex, 'symbol') || 'circle',\n    style: data.getItemVisual(dataIndex, 'style'),\n    symbolClip: symbolClip,\n    symbolRepeat: symbolRepeat,\n    symbolRepeatDirection: itemModel.get('symbolRepeatDirection'),\n    symbolPatternSize: symbolPatternSize,\n    rotation: rotation,\n    animationModel: isAnimationEnabled ? itemModel : null,\n    hoverScale: isAnimationEnabled && itemModel.get(['emphasis', 'scale']),\n    z2: itemModel.getShallow('z', true) || 0\n  };\n  prepareBarLength(itemModel, symbolRepeat, layout, opt, symbolMeta);\n  prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);\n  prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);\n  var symbolSize = symbolMeta.symbolSize;\n  var symbolOffset = (0,symbol/* normalizeSymbolOffset */.hV)(itemModel.get('symbolOffset'), symbolSize);\n  prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);\n  return symbolMeta;\n}\n// bar length can be negative.\nfunction prepareBarLength(itemModel, symbolRepeat, layout, opt, outputSymbolMeta) {\n  var valueDim = opt.valueDim;\n  var symbolBoundingData = itemModel.get('symbolBoundingData');\n  var valueAxis = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());\n  var zeroPx = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));\n  var pxSignIdx = 1 - +(layout[valueDim.wh] <= 0);\n  var boundingLength;\n  if (util.isArray(symbolBoundingData)) {\n    var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis, symbolBoundingData[1]) - zeroPx];\n    symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();\n    boundingLength = symbolBoundingExtent[pxSignIdx];\n  } else if (symbolBoundingData != null) {\n    boundingLength = convertToCoordOnAxis(valueAxis, symbolBoundingData) - zeroPx;\n  } else if (symbolRepeat) {\n    boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;\n  } else {\n    boundingLength = layout[valueDim.wh];\n  }\n  outputSymbolMeta.boundingLength = boundingLength;\n  if (symbolRepeat) {\n    outputSymbolMeta.repeatCutLength = layout[valueDim.wh];\n  }\n  // if 'pxSign' means sign of pixel,  it can't be zero, or symbolScale will be zero\n  // and when borderWidth be settled, the actual linewidth will be NaN\n  var isXAxis = valueDim.xy === 'x';\n  var isInverse = valueAxis.inverse;\n  outputSymbolMeta.pxSign = isXAxis && !isInverse || !isXAxis && isInverse ? boundingLength >= 0 ? 1 : -1 : boundingLength > 0 ? 1 : -1;\n}\nfunction convertToCoordOnAxis(axis, value) {\n  return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));\n}\n// Support ['100%', '100%']\nfunction prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, outputSymbolMeta) {\n  var valueDim = opt.valueDim;\n  var categoryDim = opt.categoryDim;\n  var categorySize = Math.abs(layout[categoryDim.wh]);\n  var symbolSize = data.getItemVisual(dataIndex, 'symbolSize');\n  var parsedSymbolSize;\n  if (util.isArray(symbolSize)) {\n    parsedSymbolSize = symbolSize.slice();\n  } else {\n    if (symbolSize == null) {\n      // will parse to number below\n      parsedSymbolSize = ['100%', '100%'];\n    } else {\n      parsedSymbolSize = [symbolSize, symbolSize];\n    }\n  }\n  // Note: percentage symbolSize (like '100%') do not consider lineWidth, because it is\n  // to complicated to calculate real percent value if considering scaled lineWidth.\n  // So the actual size will bigger than layout size if lineWidth is bigger than zero,\n  // which can be tolerated in pictorial chart.\n  parsedSymbolSize[categoryDim.index] = (0,number/* parsePercent */.lo)(parsedSymbolSize[categoryDim.index], categorySize);\n  parsedSymbolSize[valueDim.index] = (0,number/* parsePercent */.lo)(parsedSymbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));\n  outputSymbolMeta.symbolSize = parsedSymbolSize;\n  // If x or y is less than zero, show reversed shape.\n  var symbolScale = outputSymbolMeta.symbolScale = [parsedSymbolSize[0] / symbolPatternSize, parsedSymbolSize[1] / symbolPatternSize];\n  // Follow convention, 'right' and 'top' is the normal scale.\n  symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;\n}\nfunction prepareLineWidth(itemModel, symbolScale, rotation, opt, outputSymbolMeta) {\n  // In symbols are drawn with scale, so do not need to care about the case that width\n  // or height are too small. But symbol use strokeNoScale, where acture lineWidth should\n  // be calculated.\n  var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n  if (valueLineWidth) {\n    pathForLineWidth.attr({\n      scaleX: symbolScale[0],\n      scaleY: symbolScale[1],\n      rotation: rotation\n    });\n    pathForLineWidth.updateTransform();\n    valueLineWidth /= pathForLineWidth.getLineScale();\n    valueLineWidth *= symbolScale[opt.valueDim.index];\n  }\n  outputSymbolMeta.valueLineWidth = valueLineWidth || 0;\n}\nfunction prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, outputSymbolMeta) {\n  var categoryDim = opt.categoryDim;\n  var valueDim = opt.valueDim;\n  var pxSign = outputSymbolMeta.pxSign;\n  var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);\n  var pathLen = unitLength;\n  // Note: rotation will not effect the layout of symbols, because user may\n  // want symbols to rotate on its center, which should not be translated\n  // when rotating.\n  if (symbolRepeat) {\n    var absBoundingLength = Math.abs(boundingLength);\n    var symbolMargin = util.retrieve(itemModel.get('symbolMargin'), '15%') + '';\n    var hasEndGap = false;\n    if (symbolMargin.lastIndexOf('!') === symbolMargin.length - 1) {\n      hasEndGap = true;\n      symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);\n    }\n    var symbolMarginNumeric = (0,number/* parsePercent */.lo)(symbolMargin, symbolSize[valueDim.index]);\n    var uLenWithMargin = Math.max(unitLength + symbolMarginNumeric * 2, 0);\n    // When symbol margin is less than 0, margin at both ends will be subtracted\n    // to ensure that all of the symbols will not be overflow the given area.\n    var endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;\n    // Both final repeatTimes and final symbolMarginNumeric area calculated based on\n    // boundingLength.\n    var repeatSpecified = (0,number/* isNumeric */.kf)(symbolRepeat);\n    var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin);\n    // Adjust calculate margin, to ensure each symbol is displayed\n    // entirely in the given layout area.\n    var mDiff = absBoundingLength - repeatTimes * unitLength;\n    symbolMarginNumeric = mDiff / 2 / (hasEndGap ? repeatTimes : Math.max(repeatTimes - 1, 1));\n    uLenWithMargin = unitLength + symbolMarginNumeric * 2;\n    endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;\n    // Update repeatTimes when not all symbol will be shown.\n    if (!repeatSpecified && symbolRepeat !== 'fixed') {\n      repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;\n    }\n    pathLen = repeatTimes * uLenWithMargin - endFix;\n    outputSymbolMeta.repeatTimes = repeatTimes;\n    outputSymbolMeta.symbolMargin = symbolMarginNumeric;\n  }\n  var sizeFix = pxSign * (pathLen / 2);\n  var pathPosition = outputSymbolMeta.pathPosition = [];\n  pathPosition[categoryDim.index] = layout[categoryDim.wh] / 2;\n  pathPosition[valueDim.index] = symbolPosition === 'start' ? sizeFix : symbolPosition === 'end' ? boundingLength - sizeFix : boundingLength / 2; // 'center'\n  if (symbolOffset) {\n    pathPosition[0] += symbolOffset[0];\n    pathPosition[1] += symbolOffset[1];\n  }\n  var bundlePosition = outputSymbolMeta.bundlePosition = [];\n  bundlePosition[categoryDim.index] = layout[categoryDim.xy];\n  bundlePosition[valueDim.index] = layout[valueDim.xy];\n  var barRectShape = outputSymbolMeta.barRectShape = util.extend({}, layout);\n  barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));\n  barRectShape[categoryDim.wh] = layout[categoryDim.wh];\n  var clipShape = outputSymbolMeta.clipShape = {};\n  // Consider that symbol may be overflow layout rect.\n  clipShape[categoryDim.xy] = -layout[categoryDim.xy];\n  clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];\n  clipShape[valueDim.xy] = 0;\n  clipShape[valueDim.wh] = layout[valueDim.wh];\n}\nfunction createPath(symbolMeta) {\n  var symbolPatternSize = symbolMeta.symbolPatternSize;\n  var path = (0,symbol/* createSymbol */.v5)(\n  // Consider texture img, make a big size.\n  symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize);\n  path.attr({\n    culling: true\n  });\n  path.type !== 'image' && path.setStyle({\n    strokeNoScale: true\n  });\n  return path;\n}\nfunction createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {\n  var bundle = bar.__pictorialBundle;\n  var symbolSize = symbolMeta.symbolSize;\n  var valueLineWidth = symbolMeta.valueLineWidth;\n  var pathPosition = symbolMeta.pathPosition;\n  var valueDim = opt.valueDim;\n  var repeatTimes = symbolMeta.repeatTimes || 0;\n  var index = 0;\n  var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;\n  eachPath(bar, function (path) {\n    path.__pictorialAnimationIndex = index;\n    path.__pictorialRepeatTimes = repeatTimes;\n    if (index < repeatTimes) {\n      updateAttr(path, null, makeTarget(index), symbolMeta, isUpdate);\n    } else {\n      updateAttr(path, null, {\n        scaleX: 0,\n        scaleY: 0\n      }, symbolMeta, isUpdate, function () {\n        bundle.remove(path);\n      });\n    }\n    // updateHoverAnimation(path, symbolMeta);\n    index++;\n  });\n  for (; index < repeatTimes; index++) {\n    var path = createPath(symbolMeta);\n    path.__pictorialAnimationIndex = index;\n    path.__pictorialRepeatTimes = repeatTimes;\n    bundle.add(path);\n    var target = makeTarget(index);\n    updateAttr(path, {\n      x: target.x,\n      y: target.y,\n      scaleX: 0,\n      scaleY: 0\n    }, {\n      scaleX: target.scaleX,\n      scaleY: target.scaleY,\n      rotation: target.rotation\n    }, symbolMeta, isUpdate);\n  }\n  function makeTarget(index) {\n    var position = pathPosition.slice();\n    // (start && pxSign > 0) || (end && pxSign < 0): i = repeatTimes - index\n    // Otherwise: i = index;\n    var pxSign = symbolMeta.pxSign;\n    var i = index;\n    if (symbolMeta.symbolRepeatDirection === 'start' ? pxSign > 0 : pxSign < 0) {\n      i = repeatTimes - 1 - index;\n    }\n    position[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];\n    return {\n      x: position[0],\n      y: position[1],\n      scaleX: symbolMeta.symbolScale[0],\n      scaleY: symbolMeta.symbolScale[1],\n      rotation: symbolMeta.rotation\n    };\n  }\n}\nfunction createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {\n  var bundle = bar.__pictorialBundle;\n  var mainPath = bar.__pictorialMainPath;\n  if (!mainPath) {\n    mainPath = bar.__pictorialMainPath = createPath(symbolMeta);\n    bundle.add(mainPath);\n    updateAttr(mainPath, {\n      x: symbolMeta.pathPosition[0],\n      y: symbolMeta.pathPosition[1],\n      scaleX: 0,\n      scaleY: 0,\n      rotation: symbolMeta.rotation\n    }, {\n      scaleX: symbolMeta.symbolScale[0],\n      scaleY: symbolMeta.symbolScale[1]\n    }, symbolMeta, isUpdate);\n  } else {\n    updateAttr(mainPath, null, {\n      x: symbolMeta.pathPosition[0],\n      y: symbolMeta.pathPosition[1],\n      scaleX: symbolMeta.symbolScale[0],\n      scaleY: symbolMeta.symbolScale[1],\n      rotation: symbolMeta.rotation\n    }, symbolMeta, isUpdate);\n  }\n}\n// bar rect is used for label.\nfunction createOrUpdateBarRect(bar, symbolMeta, isUpdate) {\n  var rectShape = util.extend({}, symbolMeta.barRectShape);\n  var barRect = bar.__pictorialBarRect;\n  if (!barRect) {\n    barRect = bar.__pictorialBarRect = new Rect/* default */.A({\n      z2: 2,\n      shape: rectShape,\n      silent: true,\n      style: {\n        stroke: 'transparent',\n        fill: 'transparent',\n        lineWidth: 0\n      }\n    });\n    barRect.disableMorphing = true;\n    bar.add(barRect);\n  } else {\n    updateAttr(barRect, null, {\n      shape: rectShape\n    }, symbolMeta, isUpdate);\n  }\n}\nfunction createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {\n  // If not clip, symbol will be remove and rebuilt.\n  if (symbolMeta.symbolClip) {\n    var clipPath = bar.__pictorialClipPath;\n    var clipShape = util.extend({}, symbolMeta.clipShape);\n    var valueDim = opt.valueDim;\n    var animationModel = symbolMeta.animationModel;\n    var dataIndex = symbolMeta.dataIndex;\n    if (clipPath) {\n      basicTransition/* updateProps */.oi(clipPath, {\n        shape: clipShape\n      }, animationModel, dataIndex);\n    } else {\n      clipShape[valueDim.wh] = 0;\n      clipPath = new Rect/* default */.A({\n        shape: clipShape\n      });\n      bar.__pictorialBundle.setClipPath(clipPath);\n      bar.__pictorialClipPath = clipPath;\n      var target = {};\n      target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](clipPath, {\n        shape: target\n      }, animationModel, dataIndex);\n    }\n  }\n}\nfunction getItemModel(data, dataIndex) {\n  var itemModel = data.getItemModel(dataIndex);\n  itemModel.getAnimationDelayParams = getAnimationDelayParams;\n  itemModel.isAnimationEnabled = isAnimationEnabled;\n  return itemModel;\n}\nfunction getAnimationDelayParams(path) {\n  // The order is the same as the z-order, see `symbolRepeatDiretion`.\n  return {\n    index: path.__pictorialAnimationIndex,\n    count: path.__pictorialRepeatTimes\n  };\n}\nfunction isAnimationEnabled() {\n  // `animation` prop can be set on itemModel in pictorial bar chart.\n  return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation');\n}\nfunction createBar(data, opt, symbolMeta, isUpdate) {\n  // bar is the main element for each data.\n  var bar = new Group/* default */.A();\n  // bundle is used for location and clip.\n  var bundle = new Group/* default */.A();\n  bar.add(bundle);\n  bar.__pictorialBundle = bundle;\n  bundle.x = symbolMeta.bundlePosition[0];\n  bundle.y = symbolMeta.bundlePosition[1];\n  if (symbolMeta.symbolRepeat) {\n    createOrUpdateRepeatSymbols(bar, opt, symbolMeta);\n  } else {\n    createOrUpdateSingleSymbol(bar, opt, symbolMeta);\n  }\n  createOrUpdateBarRect(bar, symbolMeta, isUpdate);\n  createOrUpdateClip(bar, opt, symbolMeta, isUpdate);\n  bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);\n  bar.__pictorialSymbolMeta = symbolMeta;\n  return bar;\n}\nfunction updateBar(bar, opt, symbolMeta) {\n  var animationModel = symbolMeta.animationModel;\n  var dataIndex = symbolMeta.dataIndex;\n  var bundle = bar.__pictorialBundle;\n  basicTransition/* updateProps */.oi(bundle, {\n    x: symbolMeta.bundlePosition[0],\n    y: symbolMeta.bundlePosition[1]\n  }, animationModel, dataIndex);\n  if (symbolMeta.symbolRepeat) {\n    createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);\n  } else {\n    createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);\n  }\n  createOrUpdateBarRect(bar, symbolMeta, true);\n  createOrUpdateClip(bar, opt, symbolMeta, true);\n}\nfunction removeBar(data, dataIndex, animationModel, bar) {\n  // Not show text when animating\n  var labelRect = bar.__pictorialBarRect;\n  labelRect && labelRect.removeTextContent();\n  var paths = [];\n  eachPath(bar, function (path) {\n    paths.push(path);\n  });\n  bar.__pictorialMainPath && paths.push(bar.__pictorialMainPath);\n  // I do not find proper remove animation for clip yet.\n  bar.__pictorialClipPath && (animationModel = null);\n  util.each(paths, function (path) {\n    basicTransition/* removeElement */.Nz(path, {\n      scaleX: 0,\n      scaleY: 0\n    }, animationModel, dataIndex, function () {\n      bar.parent && bar.parent.remove(bar);\n    });\n  });\n  data.setItemGraphicEl(dataIndex, null);\n}\nfunction getShapeStr(data, symbolMeta) {\n  return [data.getItemVisual(symbolMeta.dataIndex, 'symbol') || 'none', !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(':');\n}\nfunction eachPath(bar, cb, context) {\n  // Do not use Group#eachChild, because it do not support remove.\n  util.each(bar.__pictorialBundle.children(), function (el) {\n    el !== bar.__pictorialBarRect && cb.call(context, el);\n  });\n}\nfunction updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {\n  immediateAttrs && el.attr(immediateAttrs);\n  // when symbolCip used, only clip path has init animation, otherwise it would be weird effect.\n  if (symbolMeta.symbolClip && !isUpdate) {\n    animationAttrs && el.attr(animationAttrs);\n  } else {\n    animationAttrs && graphic[isUpdate ? 'updateProps' : 'initProps'](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);\n  }\n}\nfunction updateCommon(bar, opt, symbolMeta) {\n  var dataIndex = symbolMeta.dataIndex;\n  var itemModel = symbolMeta.itemModel;\n  // Color must be excluded.\n  // Because symbol provide setColor individually to set fill and stroke\n  var emphasisModel = itemModel.getModel('emphasis');\n  var emphasisStyle = emphasisModel.getModel('itemStyle').getItemStyle();\n  var blurStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();\n  var selectStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  var focus = emphasisModel.get('focus');\n  var blurScope = emphasisModel.get('blurScope');\n  var hoverScale = emphasisModel.get('scale');\n  eachPath(bar, function (path) {\n    if (path instanceof Image/* default */.Ay) {\n      var pathStyle = path.style;\n      path.useStyle(util.extend({\n        // TODO other properties like dx, dy ?\n        image: pathStyle.image,\n        x: pathStyle.x,\n        y: pathStyle.y,\n        width: pathStyle.width,\n        height: pathStyle.height\n      }, symbolMeta.style));\n    } else {\n      path.useStyle(symbolMeta.style);\n    }\n    var emphasisState = path.ensureState('emphasis');\n    emphasisState.style = emphasisStyle;\n    if (hoverScale) {\n      // NOTE: Must after scale is set after updateAttr\n      emphasisState.scaleX = path.scaleX * 1.1;\n      emphasisState.scaleY = path.scaleY * 1.1;\n    }\n    path.ensureState('blur').style = blurStyle;\n    path.ensureState('select').style = selectStyle;\n    cursorStyle && (path.cursor = cursorStyle);\n    path.z2 = symbolMeta.z2;\n  });\n  var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];\n  var barRect = bar.__pictorialBarRect;\n  barRect.ignoreClip = true;\n  (0,labelStyle/* setLabelStyle */.qM)(barRect, (0,labelStyle/* getLabelStatesModels */.lx)(itemModel), {\n    labelFetcher: opt.seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: (0,labelHelper/* getDefaultLabel */.i)(opt.seriesModel.getData(), dataIndex),\n    inheritColor: symbolMeta.style.fill,\n    defaultOpacity: symbolMeta.style.opacity,\n    defaultOutsidePosition: barPositionOutside\n  });\n  (0,states/* toggleHoverEmphasis */.Lm)(bar, focus, blurScope, emphasisModel.get('disabled'));\n}\nfunction toIntTimes(times) {\n  var roundedTimes = Math.round(times);\n  // Escapse accurate error\n  return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);\n}\n/* harmony default export */ const bar_PictorialBarView = (PictorialBarView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/bar/BaseBarSeries.js\nvar BaseBarSeries = __webpack_require__(98908);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/component.js\nvar component = __webpack_require__(12616);\n;// ./node_modules/echarts/lib/chart/bar/PictorialBarSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar PictorialBarSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(PictorialBarSeriesModel, _super);\n  function PictorialBarSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = PictorialBarSeriesModel.type;\n    _this.hasSymbolVisual = true;\n    _this.defaultSymbol = 'roundRect';\n    return _this;\n  }\n  PictorialBarSeriesModel.prototype.getInitialData = function (option) {\n    // Disable stack.\n    option.stack = null;\n    return _super.prototype.getInitialData.apply(this, arguments);\n  };\n  PictorialBarSeriesModel.type = 'series.pictorialBar';\n  PictorialBarSeriesModel.dependencies = ['grid'];\n  PictorialBarSeriesModel.defaultOption = (0,component/* inheritDefaultOption */.G_)(BaseBarSeries/* default */.A.defaultOption, {\n    symbol: 'circle',\n    symbolSize: null,\n    symbolRotate: null,\n    symbolPosition: null,\n    symbolOffset: null,\n    symbolMargin: null,\n    symbolRepeat: false,\n    symbolRepeatDirection: 'end',\n    symbolClip: false,\n    symbolBoundingData: null,\n    symbolPatternSize: 400,\n    barGap: '-100%',\n    // Pictorial bar do not clip by default because in many cases\n    // xAxis and yAxis are not displayed and it's expected not to clip\n    clip: false,\n    // z can be set in data item, which is z2 actually.\n    // Disable progressive\n    progressive: 0,\n    emphasis: {\n      // By default pictorialBar do not hover scale. Hover scale is not suitable\n      // for the case that both has foreground and background.\n      scale: false\n    },\n    select: {\n      itemStyle: {\n        borderColor: '#212121'\n      }\n    }\n  });\n  return PictorialBarSeriesModel;\n}(BaseBarSeries/* default */.A);\n/* harmony default export */ const PictorialBarSeries = (PictorialBarSeriesModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/layout/barGrid.js\nvar barGrid = __webpack_require__(62536);\n;// ./node_modules/echarts/lib/chart/bar/installPictorialBar.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nfunction install(registers) {\n  registers.registerChartView(bar_PictorialBarView);\n  registers.registerSeriesModel(PictorialBarSeries);\n  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, (0,util.curry)(barGrid/* layout */.Zp, 'pictorialBar'));\n  // Do layout after other overall layout, which can prepare some information.\n  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, (0,barGrid/* createProgressiveLayout */.KF)('pictorialBar'));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjExNTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdm5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvUGljdG9yaWFsQmFyVmlldy5qcz9iNDdlIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvUGljdG9yaWFsQmFyU2VyaWVzLmpzP2E0MDMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9pbnN0YWxsUGljdG9yaWFsQmFyLmpzPzk2MTEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IHsgdG9nZ2xlSG92ZXJFbXBoYXNpcyB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdGVzLmpzJztcbmltcG9ydCB7IGNyZWF0ZVN5bWJvbCwgbm9ybWFsaXplU3ltYm9sT2Zmc2V0IH0gZnJvbSAnLi4vLi4vdXRpbC9zeW1ib2wuanMnO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50LCBpc051bWVyaWMgfSBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQuanMnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdExhYmVsIH0gZnJvbSAnLi4vaGVscGVyL2xhYmVsSGVscGVyLmpzJztcbmltcG9ydCB7IHNldExhYmVsU3R5bGUsIGdldExhYmVsU3RhdGVzTW9kZWxzIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG5pbXBvcnQgWlJJbWFnZSBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzJztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDbGlwUGF0aCB9IGZyb20gJy4uL2hlbHBlci9jcmVhdGVDbGlwUGF0aEZyb21Db29yZFN5cy5qcyc7XG52YXIgQkFSX0JPUkRFUl9XSURUSF9RVUVSWSA9IFsnaXRlbVN0eWxlJywgJ2JvcmRlcldpZHRoJ107XG4vLyBpbmRleDogK2lzSG9yaXpvbnRhbFxudmFyIExBWU9VVF9BVFRSUyA9IFt7XG4gIHh5OiAneCcsXG4gIHdoOiAnd2lkdGgnLFxuICBpbmRleDogMCxcbiAgcG9zRGVzYzogWydsZWZ0JywgJ3JpZ2h0J11cbn0sIHtcbiAgeHk6ICd5JyxcbiAgd2g6ICdoZWlnaHQnLFxuICBpbmRleDogMSxcbiAgcG9zRGVzYzogWyd0b3AnLCAnYm90dG9tJ11cbn1dO1xudmFyIHBhdGhGb3JMaW5lV2lkdGggPSBuZXcgZ3JhcGhpYy5DaXJjbGUoKTtcbnZhciBQaWN0b3JpYWxCYXJWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBpY3RvcmlhbEJhclZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFBpY3RvcmlhbEJhclZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IFBpY3RvcmlhbEJhclZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgUGljdG9yaWFsQmFyVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgY2FydGVzaWFuID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgYmFzZUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKTtcbiAgICB2YXIgaXNIb3Jpem9udGFsID0gYmFzZUF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgdmFyIGNvb3JkU3lzUmVjdCA9IGNhcnRlc2lhbi5tYXN0ZXIuZ2V0UmVjdCgpO1xuICAgIHZhciBvcHQgPSB7XG4gICAgICBlY1NpemU6IHtcbiAgICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgICAgfSxcbiAgICAgIHNlcmllc01vZGVsOiBzZXJpZXNNb2RlbCxcbiAgICAgIGNvb3JkU3lzOiBjYXJ0ZXNpYW4sXG4gICAgICBjb29yZFN5c0V4dGVudDogW1tjb29yZFN5c1JlY3QueCwgY29vcmRTeXNSZWN0LnggKyBjb29yZFN5c1JlY3Qud2lkdGhdLCBbY29vcmRTeXNSZWN0LnksIGNvb3JkU3lzUmVjdC55ICsgY29vcmRTeXNSZWN0LmhlaWdodF1dLFxuICAgICAgaXNIb3Jpem9udGFsOiBpc0hvcml6b250YWwsXG4gICAgICB2YWx1ZURpbTogTEFZT1VUX0FUVFJTWytpc0hvcml6b250YWxdLFxuICAgICAgY2F0ZWdvcnlEaW06IExBWU9VVF9BVFRSU1sxIC0gK2lzSG9yaXpvbnRhbF1cbiAgICB9O1xuICAgIGRhdGEuZGlmZihvbGREYXRhKS5hZGQoZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgaWYgKCFkYXRhLmhhc1ZhbHVlKGRhdGFJbmRleCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGdldEl0ZW1Nb2RlbChkYXRhLCBkYXRhSW5kZXgpO1xuICAgICAgdmFyIHN5bWJvbE1ldGEgPSBnZXRTeW1ib2xNZXRhKGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBvcHQpO1xuICAgICAgdmFyIGJhciA9IGNyZWF0ZUJhcihkYXRhLCBvcHQsIHN5bWJvbE1ldGEpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgYmFyKTtcbiAgICAgIGdyb3VwLmFkZChiYXIpO1xuICAgICAgdXBkYXRlQ29tbW9uKGJhciwgb3B0LCBzeW1ib2xNZXRhKTtcbiAgICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0luZGV4LCBvbGRJbmRleCkge1xuICAgICAgdmFyIGJhciA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJbmRleCk7XG4gICAgICBpZiAoIWRhdGEuaGFzVmFsdWUobmV3SW5kZXgpKSB7XG4gICAgICAgIGdyb3VwLnJlbW92ZShiYXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaXRlbU1vZGVsID0gZ2V0SXRlbU1vZGVsKGRhdGEsIG5ld0luZGV4KTtcbiAgICAgIHZhciBzeW1ib2xNZXRhID0gZ2V0U3ltYm9sTWV0YShkYXRhLCBuZXdJbmRleCwgaXRlbU1vZGVsLCBvcHQpO1xuICAgICAgdmFyIHBpY3RvcmlhbFNoYXBlU3RyID0gZ2V0U2hhcGVTdHIoZGF0YSwgc3ltYm9sTWV0YSk7XG4gICAgICBpZiAoYmFyICYmIHBpY3RvcmlhbFNoYXBlU3RyICE9PSBiYXIuX19waWN0b3JpYWxTaGFwZVN0cikge1xuICAgICAgICBncm91cC5yZW1vdmUoYmFyKTtcbiAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0luZGV4LCBudWxsKTtcbiAgICAgICAgYmFyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChiYXIpIHtcbiAgICAgICAgdXBkYXRlQmFyKGJhciwgb3B0LCBzeW1ib2xNZXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhciA9IGNyZWF0ZUJhcihkYXRhLCBvcHQsIHN5bWJvbE1ldGEsIHRydWUpO1xuICAgICAgfVxuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0luZGV4LCBiYXIpO1xuICAgICAgYmFyLl9fcGljdG9yaWFsU3ltYm9sTWV0YSA9IHN5bWJvbE1ldGE7XG4gICAgICAvLyBBZGQgYmFja1xuICAgICAgZ3JvdXAuYWRkKGJhcik7XG4gICAgICB1cGRhdGVDb21tb24oYmFyLCBvcHQsIHN5bWJvbE1ldGEpO1xuICAgIH0pLnJlbW92ZShmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICB2YXIgYmFyID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCk7XG4gICAgICBiYXIgJiYgcmVtb3ZlQmFyKG9sZERhdGEsIGRhdGFJbmRleCwgYmFyLl9fcGljdG9yaWFsU3ltYm9sTWV0YS5hbmltYXRpb25Nb2RlbCwgYmFyKTtcbiAgICB9KS5leGVjdXRlKCk7XG4gICAgLy8gRG8gY2xpcHBpbmdcbiAgICB2YXIgY2xpcFBhdGggPSBzZXJpZXNNb2RlbC5nZXQoJ2NsaXAnLCB0cnVlKSA/IGNyZWF0ZUNsaXBQYXRoKHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0sIGZhbHNlLCBzZXJpZXNNb2RlbCkgOiBudWxsO1xuICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgZ3JvdXAuc2V0Q2xpcFBhdGgoY2xpcFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cC5yZW1vdmVDbGlwUGF0aCgpO1xuICAgIH1cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICByZXR1cm4gdGhpcy5ncm91cDtcbiAgfTtcbiAgUGljdG9yaWFsQmFyVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGlmIChlY01vZGVsLmdldCgnYW5pbWF0aW9uJykpIHtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGJhcikge1xuICAgICAgICAgIHJlbW92ZUJhcihkYXRhLCBnZXRFQ0RhdGEoYmFyKS5kYXRhSW5kZXgsIGVjTW9kZWwsIGJhcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgICB9XG4gIH07XG4gIFBpY3RvcmlhbEJhclZpZXcudHlwZSA9ICdwaWN0b3JpYWxCYXInO1xuICByZXR1cm4gUGljdG9yaWFsQmFyVmlldztcbn0oQ2hhcnRWaWV3KTtcbi8vIFNldCBvciBjYWxjdWxhdGUgZGVmYXVsdCB2YWx1ZSBhYm91dCBzeW1ib2wsIGFuZCBjYWxjdWxhdGUgbGF5b3V0IGluZm8uXG5mdW5jdGlvbiBnZXRTeW1ib2xNZXRhKGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBvcHQpIHtcbiAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChkYXRhSW5kZXgpO1xuICB2YXIgc3ltYm9sUmVwZWF0ID0gaXRlbU1vZGVsLmdldCgnc3ltYm9sUmVwZWF0Jyk7XG4gIHZhciBzeW1ib2xDbGlwID0gaXRlbU1vZGVsLmdldCgnc3ltYm9sQ2xpcCcpO1xuICB2YXIgc3ltYm9sUG9zaXRpb24gPSBpdGVtTW9kZWwuZ2V0KCdzeW1ib2xQb3NpdGlvbicpIHx8ICdzdGFydCc7XG4gIHZhciBzeW1ib2xSb3RhdGUgPSBpdGVtTW9kZWwuZ2V0KCdzeW1ib2xSb3RhdGUnKTtcbiAgdmFyIHJvdGF0aW9uID0gKHN5bWJvbFJvdGF0ZSB8fCAwKSAqIE1hdGguUEkgLyAxODAgfHwgMDtcbiAgdmFyIHN5bWJvbFBhdHRlcm5TaXplID0gaXRlbU1vZGVsLmdldCgnc3ltYm9sUGF0dGVyblNpemUnKSB8fCAyO1xuICB2YXIgaXNBbmltYXRpb25FbmFibGVkID0gaXRlbU1vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpO1xuICB2YXIgc3ltYm9sTWV0YSA9IHtcbiAgICBkYXRhSW5kZXg6IGRhdGFJbmRleCxcbiAgICBsYXlvdXQ6IGxheW91dCxcbiAgICBpdGVtTW9kZWw6IGl0ZW1Nb2RlbCxcbiAgICBzeW1ib2xUeXBlOiBkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnc3ltYm9sJykgfHwgJ2NpcmNsZScsXG4gICAgc3R5bGU6IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdzdHlsZScpLFxuICAgIHN5bWJvbENsaXA6IHN5bWJvbENsaXAsXG4gICAgc3ltYm9sUmVwZWF0OiBzeW1ib2xSZXBlYXQsXG4gICAgc3ltYm9sUmVwZWF0RGlyZWN0aW9uOiBpdGVtTW9kZWwuZ2V0KCdzeW1ib2xSZXBlYXREaXJlY3Rpb24nKSxcbiAgICBzeW1ib2xQYXR0ZXJuU2l6ZTogc3ltYm9sUGF0dGVyblNpemUsXG4gICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgIGFuaW1hdGlvbk1vZGVsOiBpc0FuaW1hdGlvbkVuYWJsZWQgPyBpdGVtTW9kZWwgOiBudWxsLFxuICAgIGhvdmVyU2NhbGU6IGlzQW5pbWF0aW9uRW5hYmxlZCAmJiBpdGVtTW9kZWwuZ2V0KFsnZW1waGFzaXMnLCAnc2NhbGUnXSksXG4gICAgejI6IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCd6JywgdHJ1ZSkgfHwgMFxuICB9O1xuICBwcmVwYXJlQmFyTGVuZ3RoKGl0ZW1Nb2RlbCwgc3ltYm9sUmVwZWF0LCBsYXlvdXQsIG9wdCwgc3ltYm9sTWV0YSk7XG4gIHByZXBhcmVTeW1ib2xTaXplKGRhdGEsIGRhdGFJbmRleCwgbGF5b3V0LCBzeW1ib2xSZXBlYXQsIHN5bWJvbENsaXAsIHN5bWJvbE1ldGEuYm91bmRpbmdMZW5ndGgsIHN5bWJvbE1ldGEucHhTaWduLCBzeW1ib2xQYXR0ZXJuU2l6ZSwgb3B0LCBzeW1ib2xNZXRhKTtcbiAgcHJlcGFyZUxpbmVXaWR0aChpdGVtTW9kZWwsIHN5bWJvbE1ldGEuc3ltYm9sU2NhbGUsIHJvdGF0aW9uLCBvcHQsIHN5bWJvbE1ldGEpO1xuICB2YXIgc3ltYm9sU2l6ZSA9IHN5bWJvbE1ldGEuc3ltYm9sU2l6ZTtcbiAgdmFyIHN5bWJvbE9mZnNldCA9IG5vcm1hbGl6ZVN5bWJvbE9mZnNldChpdGVtTW9kZWwuZ2V0KCdzeW1ib2xPZmZzZXQnKSwgc3ltYm9sU2l6ZSk7XG4gIHByZXBhcmVMYXlvdXRJbmZvKGl0ZW1Nb2RlbCwgc3ltYm9sU2l6ZSwgbGF5b3V0LCBzeW1ib2xSZXBlYXQsIHN5bWJvbENsaXAsIHN5bWJvbE9mZnNldCwgc3ltYm9sUG9zaXRpb24sIHN5bWJvbE1ldGEudmFsdWVMaW5lV2lkdGgsIHN5bWJvbE1ldGEuYm91bmRpbmdMZW5ndGgsIHN5bWJvbE1ldGEucmVwZWF0Q3V0TGVuZ3RoLCBvcHQsIHN5bWJvbE1ldGEpO1xuICByZXR1cm4gc3ltYm9sTWV0YTtcbn1cbi8vIGJhciBsZW5ndGggY2FuIGJlIG5lZ2F0aXZlLlxuZnVuY3Rpb24gcHJlcGFyZUJhckxlbmd0aChpdGVtTW9kZWwsIHN5bWJvbFJlcGVhdCwgbGF5b3V0LCBvcHQsIG91dHB1dFN5bWJvbE1ldGEpIHtcbiAgdmFyIHZhbHVlRGltID0gb3B0LnZhbHVlRGltO1xuICB2YXIgc3ltYm9sQm91bmRpbmdEYXRhID0gaXRlbU1vZGVsLmdldCgnc3ltYm9sQm91bmRpbmdEYXRhJyk7XG4gIHZhciB2YWx1ZUF4aXMgPSBvcHQuY29vcmRTeXMuZ2V0T3RoZXJBeGlzKG9wdC5jb29yZFN5cy5nZXRCYXNlQXhpcygpKTtcbiAgdmFyIHplcm9QeCA9IHZhbHVlQXhpcy50b0dsb2JhbENvb3JkKHZhbHVlQXhpcy5kYXRhVG9Db29yZCgwKSk7XG4gIHZhciBweFNpZ25JZHggPSAxIC0gKyhsYXlvdXRbdmFsdWVEaW0ud2hdIDw9IDApO1xuICB2YXIgYm91bmRpbmdMZW5ndGg7XG4gIGlmICh6clV0aWwuaXNBcnJheShzeW1ib2xCb3VuZGluZ0RhdGEpKSB7XG4gICAgdmFyIHN5bWJvbEJvdW5kaW5nRXh0ZW50ID0gW2NvbnZlcnRUb0Nvb3JkT25BeGlzKHZhbHVlQXhpcywgc3ltYm9sQm91bmRpbmdEYXRhWzBdKSAtIHplcm9QeCwgY29udmVydFRvQ29vcmRPbkF4aXModmFsdWVBeGlzLCBzeW1ib2xCb3VuZGluZ0RhdGFbMV0pIC0gemVyb1B4XTtcbiAgICBzeW1ib2xCb3VuZGluZ0V4dGVudFsxXSA8IHN5bWJvbEJvdW5kaW5nRXh0ZW50WzBdICYmIHN5bWJvbEJvdW5kaW5nRXh0ZW50LnJldmVyc2UoKTtcbiAgICBib3VuZGluZ0xlbmd0aCA9IHN5bWJvbEJvdW5kaW5nRXh0ZW50W3B4U2lnbklkeF07XG4gIH0gZWxzZSBpZiAoc3ltYm9sQm91bmRpbmdEYXRhICE9IG51bGwpIHtcbiAgICBib3VuZGluZ0xlbmd0aCA9IGNvbnZlcnRUb0Nvb3JkT25BeGlzKHZhbHVlQXhpcywgc3ltYm9sQm91bmRpbmdEYXRhKSAtIHplcm9QeDtcbiAgfSBlbHNlIGlmIChzeW1ib2xSZXBlYXQpIHtcbiAgICBib3VuZGluZ0xlbmd0aCA9IG9wdC5jb29yZFN5c0V4dGVudFt2YWx1ZURpbS5pbmRleF1bcHhTaWduSWR4XSAtIHplcm9QeDtcbiAgfSBlbHNlIHtcbiAgICBib3VuZGluZ0xlbmd0aCA9IGxheW91dFt2YWx1ZURpbS53aF07XG4gIH1cbiAgb3V0cHV0U3ltYm9sTWV0YS5ib3VuZGluZ0xlbmd0aCA9IGJvdW5kaW5nTGVuZ3RoO1xuICBpZiAoc3ltYm9sUmVwZWF0KSB7XG4gICAgb3V0cHV0U3ltYm9sTWV0YS5yZXBlYXRDdXRMZW5ndGggPSBsYXlvdXRbdmFsdWVEaW0ud2hdO1xuICB9XG4gIC8vIGlmICdweFNpZ24nIG1lYW5zIHNpZ24gb2YgcGl4ZWwsICBpdCBjYW4ndCBiZSB6ZXJvLCBvciBzeW1ib2xTY2FsZSB3aWxsIGJlIHplcm9cbiAgLy8gYW5kIHdoZW4gYm9yZGVyV2lkdGggYmUgc2V0dGxlZCwgdGhlIGFjdHVhbCBsaW5ld2lkdGggd2lsbCBiZSBOYU5cbiAgdmFyIGlzWEF4aXMgPSB2YWx1ZURpbS54eSA9PT0gJ3gnO1xuICB2YXIgaXNJbnZlcnNlID0gdmFsdWVBeGlzLmludmVyc2U7XG4gIG91dHB1dFN5bWJvbE1ldGEucHhTaWduID0gaXNYQXhpcyAmJiAhaXNJbnZlcnNlIHx8ICFpc1hBeGlzICYmIGlzSW52ZXJzZSA/IGJvdW5kaW5nTGVuZ3RoID49IDAgPyAxIDogLTEgOiBib3VuZGluZ0xlbmd0aCA+IDAgPyAxIDogLTE7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Db29yZE9uQXhpcyhheGlzLCB2YWx1ZSkge1xuICByZXR1cm4gYXhpcy50b0dsb2JhbENvb3JkKGF4aXMuZGF0YVRvQ29vcmQoYXhpcy5zY2FsZS5wYXJzZSh2YWx1ZSkpKTtcbn1cbi8vIFN1cHBvcnQgWycxMDAlJywgJzEwMCUnXVxuZnVuY3Rpb24gcHJlcGFyZVN5bWJvbFNpemUoZGF0YSwgZGF0YUluZGV4LCBsYXlvdXQsIHN5bWJvbFJlcGVhdCwgc3ltYm9sQ2xpcCwgYm91bmRpbmdMZW5ndGgsIHB4U2lnbiwgc3ltYm9sUGF0dGVyblNpemUsIG9wdCwgb3V0cHV0U3ltYm9sTWV0YSkge1xuICB2YXIgdmFsdWVEaW0gPSBvcHQudmFsdWVEaW07XG4gIHZhciBjYXRlZ29yeURpbSA9IG9wdC5jYXRlZ29yeURpbTtcbiAgdmFyIGNhdGVnb3J5U2l6ZSA9IE1hdGguYWJzKGxheW91dFtjYXRlZ29yeURpbS53aF0pO1xuICB2YXIgc3ltYm9sU2l6ZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdzeW1ib2xTaXplJyk7XG4gIHZhciBwYXJzZWRTeW1ib2xTaXplO1xuICBpZiAoenJVdGlsLmlzQXJyYXkoc3ltYm9sU2l6ZSkpIHtcbiAgICBwYXJzZWRTeW1ib2xTaXplID0gc3ltYm9sU2l6ZS5zbGljZSgpO1xuICB9IGVsc2Uge1xuICAgIGlmIChzeW1ib2xTaXplID09IG51bGwpIHtcbiAgICAgIC8vIHdpbGwgcGFyc2UgdG8gbnVtYmVyIGJlbG93XG4gICAgICBwYXJzZWRTeW1ib2xTaXplID0gWycxMDAlJywgJzEwMCUnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkU3ltYm9sU2l6ZSA9IFtzeW1ib2xTaXplLCBzeW1ib2xTaXplXTtcbiAgICB9XG4gIH1cbiAgLy8gTm90ZTogcGVyY2VudGFnZSBzeW1ib2xTaXplIChsaWtlICcxMDAlJykgZG8gbm90IGNvbnNpZGVyIGxpbmVXaWR0aCwgYmVjYXVzZSBpdCBpc1xuICAvLyB0byBjb21wbGljYXRlZCB0byBjYWxjdWxhdGUgcmVhbCBwZXJjZW50IHZhbHVlIGlmIGNvbnNpZGVyaW5nIHNjYWxlZCBsaW5lV2lkdGguXG4gIC8vIFNvIHRoZSBhY3R1YWwgc2l6ZSB3aWxsIGJpZ2dlciB0aGFuIGxheW91dCBzaXplIGlmIGxpbmVXaWR0aCBpcyBiaWdnZXIgdGhhbiB6ZXJvLFxuICAvLyB3aGljaCBjYW4gYmUgdG9sZXJhdGVkIGluIHBpY3RvcmlhbCBjaGFydC5cbiAgcGFyc2VkU3ltYm9sU2l6ZVtjYXRlZ29yeURpbS5pbmRleF0gPSBwYXJzZVBlcmNlbnQocGFyc2VkU3ltYm9sU2l6ZVtjYXRlZ29yeURpbS5pbmRleF0sIGNhdGVnb3J5U2l6ZSk7XG4gIHBhcnNlZFN5bWJvbFNpemVbdmFsdWVEaW0uaW5kZXhdID0gcGFyc2VQZXJjZW50KHBhcnNlZFN5bWJvbFNpemVbdmFsdWVEaW0uaW5kZXhdLCBzeW1ib2xSZXBlYXQgPyBjYXRlZ29yeVNpemUgOiBNYXRoLmFicyhib3VuZGluZ0xlbmd0aCkpO1xuICBvdXRwdXRTeW1ib2xNZXRhLnN5bWJvbFNpemUgPSBwYXJzZWRTeW1ib2xTaXplO1xuICAvLyBJZiB4IG9yIHkgaXMgbGVzcyB0aGFuIHplcm8sIHNob3cgcmV2ZXJzZWQgc2hhcGUuXG4gIHZhciBzeW1ib2xTY2FsZSA9IG91dHB1dFN5bWJvbE1ldGEuc3ltYm9sU2NhbGUgPSBbcGFyc2VkU3ltYm9sU2l6ZVswXSAvIHN5bWJvbFBhdHRlcm5TaXplLCBwYXJzZWRTeW1ib2xTaXplWzFdIC8gc3ltYm9sUGF0dGVyblNpemVdO1xuICAvLyBGb2xsb3cgY29udmVudGlvbiwgJ3JpZ2h0JyBhbmQgJ3RvcCcgaXMgdGhlIG5vcm1hbCBzY2FsZS5cbiAgc3ltYm9sU2NhbGVbdmFsdWVEaW0uaW5kZXhdICo9IChvcHQuaXNIb3Jpem9udGFsID8gLTEgOiAxKSAqIHB4U2lnbjtcbn1cbmZ1bmN0aW9uIHByZXBhcmVMaW5lV2lkdGgoaXRlbU1vZGVsLCBzeW1ib2xTY2FsZSwgcm90YXRpb24sIG9wdCwgb3V0cHV0U3ltYm9sTWV0YSkge1xuICAvLyBJbiBzeW1ib2xzIGFyZSBkcmF3biB3aXRoIHNjYWxlLCBzbyBkbyBub3QgbmVlZCB0byBjYXJlIGFib3V0IHRoZSBjYXNlIHRoYXQgd2lkdGhcbiAgLy8gb3IgaGVpZ2h0IGFyZSB0b28gc21hbGwuIEJ1dCBzeW1ib2wgdXNlIHN0cm9rZU5vU2NhbGUsIHdoZXJlIGFjdHVyZSBsaW5lV2lkdGggc2hvdWxkXG4gIC8vIGJlIGNhbGN1bGF0ZWQuXG4gIHZhciB2YWx1ZUxpbmVXaWR0aCA9IGl0ZW1Nb2RlbC5nZXQoQkFSX0JPUkRFUl9XSURUSF9RVUVSWSkgfHwgMDtcbiAgaWYgKHZhbHVlTGluZVdpZHRoKSB7XG4gICAgcGF0aEZvckxpbmVXaWR0aC5hdHRyKHtcbiAgICAgIHNjYWxlWDogc3ltYm9sU2NhbGVbMF0sXG4gICAgICBzY2FsZVk6IHN5bWJvbFNjYWxlWzFdLFxuICAgICAgcm90YXRpb246IHJvdGF0aW9uXG4gICAgfSk7XG4gICAgcGF0aEZvckxpbmVXaWR0aC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICB2YWx1ZUxpbmVXaWR0aCAvPSBwYXRoRm9yTGluZVdpZHRoLmdldExpbmVTY2FsZSgpO1xuICAgIHZhbHVlTGluZVdpZHRoICo9IHN5bWJvbFNjYWxlW29wdC52YWx1ZURpbS5pbmRleF07XG4gIH1cbiAgb3V0cHV0U3ltYm9sTWV0YS52YWx1ZUxpbmVXaWR0aCA9IHZhbHVlTGluZVdpZHRoIHx8IDA7XG59XG5mdW5jdGlvbiBwcmVwYXJlTGF5b3V0SW5mbyhpdGVtTW9kZWwsIHN5bWJvbFNpemUsIGxheW91dCwgc3ltYm9sUmVwZWF0LCBzeW1ib2xDbGlwLCBzeW1ib2xPZmZzZXQsIHN5bWJvbFBvc2l0aW9uLCB2YWx1ZUxpbmVXaWR0aCwgYm91bmRpbmdMZW5ndGgsIHJlcGVhdEN1dExlbmd0aCwgb3B0LCBvdXRwdXRTeW1ib2xNZXRhKSB7XG4gIHZhciBjYXRlZ29yeURpbSA9IG9wdC5jYXRlZ29yeURpbTtcbiAgdmFyIHZhbHVlRGltID0gb3B0LnZhbHVlRGltO1xuICB2YXIgcHhTaWduID0gb3V0cHV0U3ltYm9sTWV0YS5weFNpZ247XG4gIHZhciB1bml0TGVuZ3RoID0gTWF0aC5tYXgoc3ltYm9sU2l6ZVt2YWx1ZURpbS5pbmRleF0gKyB2YWx1ZUxpbmVXaWR0aCwgMCk7XG4gIHZhciBwYXRoTGVuID0gdW5pdExlbmd0aDtcbiAgLy8gTm90ZTogcm90YXRpb24gd2lsbCBub3QgZWZmZWN0IHRoZSBsYXlvdXQgb2Ygc3ltYm9scywgYmVjYXVzZSB1c2VyIG1heVxuICAvLyB3YW50IHN5bWJvbHMgdG8gcm90YXRlIG9uIGl0cyBjZW50ZXIsIHdoaWNoIHNob3VsZCBub3QgYmUgdHJhbnNsYXRlZFxuICAvLyB3aGVuIHJvdGF0aW5nLlxuICBpZiAoc3ltYm9sUmVwZWF0KSB7XG4gICAgdmFyIGFic0JvdW5kaW5nTGVuZ3RoID0gTWF0aC5hYnMoYm91bmRpbmdMZW5ndGgpO1xuICAgIHZhciBzeW1ib2xNYXJnaW4gPSB6clV0aWwucmV0cmlldmUoaXRlbU1vZGVsLmdldCgnc3ltYm9sTWFyZ2luJyksICcxNSUnKSArICcnO1xuICAgIHZhciBoYXNFbmRHYXAgPSBmYWxzZTtcbiAgICBpZiAoc3ltYm9sTWFyZ2luLmxhc3RJbmRleE9mKCchJykgPT09IHN5bWJvbE1hcmdpbi5sZW5ndGggLSAxKSB7XG4gICAgICBoYXNFbmRHYXAgPSB0cnVlO1xuICAgICAgc3ltYm9sTWFyZ2luID0gc3ltYm9sTWFyZ2luLnNsaWNlKDAsIHN5bWJvbE1hcmdpbi5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgdmFyIHN5bWJvbE1hcmdpbk51bWVyaWMgPSBwYXJzZVBlcmNlbnQoc3ltYm9sTWFyZ2luLCBzeW1ib2xTaXplW3ZhbHVlRGltLmluZGV4XSk7XG4gICAgdmFyIHVMZW5XaXRoTWFyZ2luID0gTWF0aC5tYXgodW5pdExlbmd0aCArIHN5bWJvbE1hcmdpbk51bWVyaWMgKiAyLCAwKTtcbiAgICAvLyBXaGVuIHN5bWJvbCBtYXJnaW4gaXMgbGVzcyB0aGFuIDAsIG1hcmdpbiBhdCBib3RoIGVuZHMgd2lsbCBiZSBzdWJ0cmFjdGVkXG4gICAgLy8gdG8gZW5zdXJlIHRoYXQgYWxsIG9mIHRoZSBzeW1ib2xzIHdpbGwgbm90IGJlIG92ZXJmbG93IHRoZSBnaXZlbiBhcmVhLlxuICAgIHZhciBlbmRGaXggPSBoYXNFbmRHYXAgPyAwIDogc3ltYm9sTWFyZ2luTnVtZXJpYyAqIDI7XG4gICAgLy8gQm90aCBmaW5hbCByZXBlYXRUaW1lcyBhbmQgZmluYWwgc3ltYm9sTWFyZ2luTnVtZXJpYyBhcmVhIGNhbGN1bGF0ZWQgYmFzZWQgb25cbiAgICAvLyBib3VuZGluZ0xlbmd0aC5cbiAgICB2YXIgcmVwZWF0U3BlY2lmaWVkID0gaXNOdW1lcmljKHN5bWJvbFJlcGVhdCk7XG4gICAgdmFyIHJlcGVhdFRpbWVzID0gcmVwZWF0U3BlY2lmaWVkID8gc3ltYm9sUmVwZWF0IDogdG9JbnRUaW1lcygoYWJzQm91bmRpbmdMZW5ndGggKyBlbmRGaXgpIC8gdUxlbldpdGhNYXJnaW4pO1xuICAgIC8vIEFkanVzdCBjYWxjdWxhdGUgbWFyZ2luLCB0byBlbnN1cmUgZWFjaCBzeW1ib2wgaXMgZGlzcGxheWVkXG4gICAgLy8gZW50aXJlbHkgaW4gdGhlIGdpdmVuIGxheW91dCBhcmVhLlxuICAgIHZhciBtRGlmZiA9IGFic0JvdW5kaW5nTGVuZ3RoIC0gcmVwZWF0VGltZXMgKiB1bml0TGVuZ3RoO1xuICAgIHN5bWJvbE1hcmdpbk51bWVyaWMgPSBtRGlmZiAvIDIgLyAoaGFzRW5kR2FwID8gcmVwZWF0VGltZXMgOiBNYXRoLm1heChyZXBlYXRUaW1lcyAtIDEsIDEpKTtcbiAgICB1TGVuV2l0aE1hcmdpbiA9IHVuaXRMZW5ndGggKyBzeW1ib2xNYXJnaW5OdW1lcmljICogMjtcbiAgICBlbmRGaXggPSBoYXNFbmRHYXAgPyAwIDogc3ltYm9sTWFyZ2luTnVtZXJpYyAqIDI7XG4gICAgLy8gVXBkYXRlIHJlcGVhdFRpbWVzIHdoZW4gbm90IGFsbCBzeW1ib2wgd2lsbCBiZSBzaG93bi5cbiAgICBpZiAoIXJlcGVhdFNwZWNpZmllZCAmJiBzeW1ib2xSZXBlYXQgIT09ICdmaXhlZCcpIHtcbiAgICAgIHJlcGVhdFRpbWVzID0gcmVwZWF0Q3V0TGVuZ3RoID8gdG9JbnRUaW1lcygoTWF0aC5hYnMocmVwZWF0Q3V0TGVuZ3RoKSArIGVuZEZpeCkgLyB1TGVuV2l0aE1hcmdpbikgOiAwO1xuICAgIH1cbiAgICBwYXRoTGVuID0gcmVwZWF0VGltZXMgKiB1TGVuV2l0aE1hcmdpbiAtIGVuZEZpeDtcbiAgICBvdXRwdXRTeW1ib2xNZXRhLnJlcGVhdFRpbWVzID0gcmVwZWF0VGltZXM7XG4gICAgb3V0cHV0U3ltYm9sTWV0YS5zeW1ib2xNYXJnaW4gPSBzeW1ib2xNYXJnaW5OdW1lcmljO1xuICB9XG4gIHZhciBzaXplRml4ID0gcHhTaWduICogKHBhdGhMZW4gLyAyKTtcbiAgdmFyIHBhdGhQb3NpdGlvbiA9IG91dHB1dFN5bWJvbE1ldGEucGF0aFBvc2l0aW9uID0gW107XG4gIHBhdGhQb3NpdGlvbltjYXRlZ29yeURpbS5pbmRleF0gPSBsYXlvdXRbY2F0ZWdvcnlEaW0ud2hdIC8gMjtcbiAgcGF0aFBvc2l0aW9uW3ZhbHVlRGltLmluZGV4XSA9IHN5bWJvbFBvc2l0aW9uID09PSAnc3RhcnQnID8gc2l6ZUZpeCA6IHN5bWJvbFBvc2l0aW9uID09PSAnZW5kJyA/IGJvdW5kaW5nTGVuZ3RoIC0gc2l6ZUZpeCA6IGJvdW5kaW5nTGVuZ3RoIC8gMjsgLy8gJ2NlbnRlcidcbiAgaWYgKHN5bWJvbE9mZnNldCkge1xuICAgIHBhdGhQb3NpdGlvblswXSArPSBzeW1ib2xPZmZzZXRbMF07XG4gICAgcGF0aFBvc2l0aW9uWzFdICs9IHN5bWJvbE9mZnNldFsxXTtcbiAgfVxuICB2YXIgYnVuZGxlUG9zaXRpb24gPSBvdXRwdXRTeW1ib2xNZXRhLmJ1bmRsZVBvc2l0aW9uID0gW107XG4gIGJ1bmRsZVBvc2l0aW9uW2NhdGVnb3J5RGltLmluZGV4XSA9IGxheW91dFtjYXRlZ29yeURpbS54eV07XG4gIGJ1bmRsZVBvc2l0aW9uW3ZhbHVlRGltLmluZGV4XSA9IGxheW91dFt2YWx1ZURpbS54eV07XG4gIHZhciBiYXJSZWN0U2hhcGUgPSBvdXRwdXRTeW1ib2xNZXRhLmJhclJlY3RTaGFwZSA9IHpyVXRpbC5leHRlbmQoe30sIGxheW91dCk7XG4gIGJhclJlY3RTaGFwZVt2YWx1ZURpbS53aF0gPSBweFNpZ24gKiBNYXRoLm1heChNYXRoLmFicyhsYXlvdXRbdmFsdWVEaW0ud2hdKSwgTWF0aC5hYnMocGF0aFBvc2l0aW9uW3ZhbHVlRGltLmluZGV4XSArIHNpemVGaXgpKTtcbiAgYmFyUmVjdFNoYXBlW2NhdGVnb3J5RGltLndoXSA9IGxheW91dFtjYXRlZ29yeURpbS53aF07XG4gIHZhciBjbGlwU2hhcGUgPSBvdXRwdXRTeW1ib2xNZXRhLmNsaXBTaGFwZSA9IHt9O1xuICAvLyBDb25zaWRlciB0aGF0IHN5bWJvbCBtYXkgYmUgb3ZlcmZsb3cgbGF5b3V0IHJlY3QuXG4gIGNsaXBTaGFwZVtjYXRlZ29yeURpbS54eV0gPSAtbGF5b3V0W2NhdGVnb3J5RGltLnh5XTtcbiAgY2xpcFNoYXBlW2NhdGVnb3J5RGltLndoXSA9IG9wdC5lY1NpemVbY2F0ZWdvcnlEaW0ud2hdO1xuICBjbGlwU2hhcGVbdmFsdWVEaW0ueHldID0gMDtcbiAgY2xpcFNoYXBlW3ZhbHVlRGltLndoXSA9IGxheW91dFt2YWx1ZURpbS53aF07XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoKHN5bWJvbE1ldGEpIHtcbiAgdmFyIHN5bWJvbFBhdHRlcm5TaXplID0gc3ltYm9sTWV0YS5zeW1ib2xQYXR0ZXJuU2l6ZTtcbiAgdmFyIHBhdGggPSBjcmVhdGVTeW1ib2woXG4gIC8vIENvbnNpZGVyIHRleHR1cmUgaW1nLCBtYWtlIGEgYmlnIHNpemUuXG4gIHN5bWJvbE1ldGEuc3ltYm9sVHlwZSwgLXN5bWJvbFBhdHRlcm5TaXplIC8gMiwgLXN5bWJvbFBhdHRlcm5TaXplIC8gMiwgc3ltYm9sUGF0dGVyblNpemUsIHN5bWJvbFBhdHRlcm5TaXplKTtcbiAgcGF0aC5hdHRyKHtcbiAgICBjdWxsaW5nOiB0cnVlXG4gIH0pO1xuICBwYXRoLnR5cGUgIT09ICdpbWFnZScgJiYgcGF0aC5zZXRTdHlsZSh7XG4gICAgc3Ryb2tlTm9TY2FsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBjcmVhdGVPclVwZGF0ZVJlcGVhdFN5bWJvbHMoYmFyLCBvcHQsIHN5bWJvbE1ldGEsIGlzVXBkYXRlKSB7XG4gIHZhciBidW5kbGUgPSBiYXIuX19waWN0b3JpYWxCdW5kbGU7XG4gIHZhciBzeW1ib2xTaXplID0gc3ltYm9sTWV0YS5zeW1ib2xTaXplO1xuICB2YXIgdmFsdWVMaW5lV2lkdGggPSBzeW1ib2xNZXRhLnZhbHVlTGluZVdpZHRoO1xuICB2YXIgcGF0aFBvc2l0aW9uID0gc3ltYm9sTWV0YS5wYXRoUG9zaXRpb247XG4gIHZhciB2YWx1ZURpbSA9IG9wdC52YWx1ZURpbTtcbiAgdmFyIHJlcGVhdFRpbWVzID0gc3ltYm9sTWV0YS5yZXBlYXRUaW1lcyB8fCAwO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgdW5pdCA9IHN5bWJvbFNpemVbb3B0LnZhbHVlRGltLmluZGV4XSArIHZhbHVlTGluZVdpZHRoICsgc3ltYm9sTWV0YS5zeW1ib2xNYXJnaW4gKiAyO1xuICBlYWNoUGF0aChiYXIsIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcGF0aC5fX3BpY3RvcmlhbEFuaW1hdGlvbkluZGV4ID0gaW5kZXg7XG4gICAgcGF0aC5fX3BpY3RvcmlhbFJlcGVhdFRpbWVzID0gcmVwZWF0VGltZXM7XG4gICAgaWYgKGluZGV4IDwgcmVwZWF0VGltZXMpIHtcbiAgICAgIHVwZGF0ZUF0dHIocGF0aCwgbnVsbCwgbWFrZVRhcmdldChpbmRleCksIHN5bWJvbE1ldGEsIGlzVXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlQXR0cihwYXRoLCBudWxsLCB7XG4gICAgICAgIHNjYWxlWDogMCxcbiAgICAgICAgc2NhbGVZOiAwXG4gICAgICB9LCBzeW1ib2xNZXRhLCBpc1VwZGF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBidW5kbGUucmVtb3ZlKHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHVwZGF0ZUhvdmVyQW5pbWF0aW9uKHBhdGgsIHN5bWJvbE1ldGEpO1xuICAgIGluZGV4Kys7XG4gIH0pO1xuICBmb3IgKDsgaW5kZXggPCByZXBlYXRUaW1lczsgaW5kZXgrKykge1xuICAgIHZhciBwYXRoID0gY3JlYXRlUGF0aChzeW1ib2xNZXRhKTtcbiAgICBwYXRoLl9fcGljdG9yaWFsQW5pbWF0aW9uSW5kZXggPSBpbmRleDtcbiAgICBwYXRoLl9fcGljdG9yaWFsUmVwZWF0VGltZXMgPSByZXBlYXRUaW1lcztcbiAgICBidW5kbGUuYWRkKHBhdGgpO1xuICAgIHZhciB0YXJnZXQgPSBtYWtlVGFyZ2V0KGluZGV4KTtcbiAgICB1cGRhdGVBdHRyKHBhdGgsIHtcbiAgICAgIHg6IHRhcmdldC54LFxuICAgICAgeTogdGFyZ2V0LnksXG4gICAgICBzY2FsZVg6IDAsXG4gICAgICBzY2FsZVk6IDBcbiAgICB9LCB7XG4gICAgICBzY2FsZVg6IHRhcmdldC5zY2FsZVgsXG4gICAgICBzY2FsZVk6IHRhcmdldC5zY2FsZVksXG4gICAgICByb3RhdGlvbjogdGFyZ2V0LnJvdGF0aW9uXG4gICAgfSwgc3ltYm9sTWV0YSwgaXNVcGRhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIG1ha2VUYXJnZXQoaW5kZXgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBwYXRoUG9zaXRpb24uc2xpY2UoKTtcbiAgICAvLyAoc3RhcnQgJiYgcHhTaWduID4gMCkgfHwgKGVuZCAmJiBweFNpZ24gPCAwKTogaSA9IHJlcGVhdFRpbWVzIC0gaW5kZXhcbiAgICAvLyBPdGhlcndpc2U6IGkgPSBpbmRleDtcbiAgICB2YXIgcHhTaWduID0gc3ltYm9sTWV0YS5weFNpZ247XG4gICAgdmFyIGkgPSBpbmRleDtcbiAgICBpZiAoc3ltYm9sTWV0YS5zeW1ib2xSZXBlYXREaXJlY3Rpb24gPT09ICdzdGFydCcgPyBweFNpZ24gPiAwIDogcHhTaWduIDwgMCkge1xuICAgICAgaSA9IHJlcGVhdFRpbWVzIC0gMSAtIGluZGV4O1xuICAgIH1cbiAgICBwb3NpdGlvblt2YWx1ZURpbS5pbmRleF0gPSB1bml0ICogKGkgLSByZXBlYXRUaW1lcyAvIDIgKyAwLjUpICsgcGF0aFBvc2l0aW9uW3ZhbHVlRGltLmluZGV4XTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcG9zaXRpb25bMF0sXG4gICAgICB5OiBwb3NpdGlvblsxXSxcbiAgICAgIHNjYWxlWDogc3ltYm9sTWV0YS5zeW1ib2xTY2FsZVswXSxcbiAgICAgIHNjYWxlWTogc3ltYm9sTWV0YS5zeW1ib2xTY2FsZVsxXSxcbiAgICAgIHJvdGF0aW9uOiBzeW1ib2xNZXRhLnJvdGF0aW9uXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVTaW5nbGVTeW1ib2woYmFyLCBvcHQsIHN5bWJvbE1ldGEsIGlzVXBkYXRlKSB7XG4gIHZhciBidW5kbGUgPSBiYXIuX19waWN0b3JpYWxCdW5kbGU7XG4gIHZhciBtYWluUGF0aCA9IGJhci5fX3BpY3RvcmlhbE1haW5QYXRoO1xuICBpZiAoIW1haW5QYXRoKSB7XG4gICAgbWFpblBhdGggPSBiYXIuX19waWN0b3JpYWxNYWluUGF0aCA9IGNyZWF0ZVBhdGgoc3ltYm9sTWV0YSk7XG4gICAgYnVuZGxlLmFkZChtYWluUGF0aCk7XG4gICAgdXBkYXRlQXR0cihtYWluUGF0aCwge1xuICAgICAgeDogc3ltYm9sTWV0YS5wYXRoUG9zaXRpb25bMF0sXG4gICAgICB5OiBzeW1ib2xNZXRhLnBhdGhQb3NpdGlvblsxXSxcbiAgICAgIHNjYWxlWDogMCxcbiAgICAgIHNjYWxlWTogMCxcbiAgICAgIHJvdGF0aW9uOiBzeW1ib2xNZXRhLnJvdGF0aW9uXG4gICAgfSwge1xuICAgICAgc2NhbGVYOiBzeW1ib2xNZXRhLnN5bWJvbFNjYWxlWzBdLFxuICAgICAgc2NhbGVZOiBzeW1ib2xNZXRhLnN5bWJvbFNjYWxlWzFdXG4gICAgfSwgc3ltYm9sTWV0YSwgaXNVcGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUF0dHIobWFpblBhdGgsIG51bGwsIHtcbiAgICAgIHg6IHN5bWJvbE1ldGEucGF0aFBvc2l0aW9uWzBdLFxuICAgICAgeTogc3ltYm9sTWV0YS5wYXRoUG9zaXRpb25bMV0sXG4gICAgICBzY2FsZVg6IHN5bWJvbE1ldGEuc3ltYm9sU2NhbGVbMF0sXG4gICAgICBzY2FsZVk6IHN5bWJvbE1ldGEuc3ltYm9sU2NhbGVbMV0sXG4gICAgICByb3RhdGlvbjogc3ltYm9sTWV0YS5yb3RhdGlvblxuICAgIH0sIHN5bWJvbE1ldGEsIGlzVXBkYXRlKTtcbiAgfVxufVxuLy8gYmFyIHJlY3QgaXMgdXNlZCBmb3IgbGFiZWwuXG5mdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUJhclJlY3QoYmFyLCBzeW1ib2xNZXRhLCBpc1VwZGF0ZSkge1xuICB2YXIgcmVjdFNoYXBlID0genJVdGlsLmV4dGVuZCh7fSwgc3ltYm9sTWV0YS5iYXJSZWN0U2hhcGUpO1xuICB2YXIgYmFyUmVjdCA9IGJhci5fX3BpY3RvcmlhbEJhclJlY3Q7XG4gIGlmICghYmFyUmVjdCkge1xuICAgIGJhclJlY3QgPSBiYXIuX19waWN0b3JpYWxCYXJSZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICB6MjogMixcbiAgICAgIHNoYXBlOiByZWN0U2hhcGUsXG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICBzdHlsZToge1xuICAgICAgICBzdHJva2U6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIGxpbmVXaWR0aDogMFxuICAgICAgfVxuICAgIH0pO1xuICAgIGJhclJlY3QuZGlzYWJsZU1vcnBoaW5nID0gdHJ1ZTtcbiAgICBiYXIuYWRkKGJhclJlY3QpO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUF0dHIoYmFyUmVjdCwgbnVsbCwge1xuICAgICAgc2hhcGU6IHJlY3RTaGFwZVxuICAgIH0sIHN5bWJvbE1ldGEsIGlzVXBkYXRlKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVDbGlwKGJhciwgb3B0LCBzeW1ib2xNZXRhLCBpc1VwZGF0ZSkge1xuICAvLyBJZiBub3QgY2xpcCwgc3ltYm9sIHdpbGwgYmUgcmVtb3ZlIGFuZCByZWJ1aWx0LlxuICBpZiAoc3ltYm9sTWV0YS5zeW1ib2xDbGlwKSB7XG4gICAgdmFyIGNsaXBQYXRoID0gYmFyLl9fcGljdG9yaWFsQ2xpcFBhdGg7XG4gICAgdmFyIGNsaXBTaGFwZSA9IHpyVXRpbC5leHRlbmQoe30sIHN5bWJvbE1ldGEuY2xpcFNoYXBlKTtcbiAgICB2YXIgdmFsdWVEaW0gPSBvcHQudmFsdWVEaW07XG4gICAgdmFyIGFuaW1hdGlvbk1vZGVsID0gc3ltYm9sTWV0YS5hbmltYXRpb25Nb2RlbDtcbiAgICB2YXIgZGF0YUluZGV4ID0gc3ltYm9sTWV0YS5kYXRhSW5kZXg7XG4gICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGNsaXBQYXRoLCB7XG4gICAgICAgIHNoYXBlOiBjbGlwU2hhcGVcbiAgICAgIH0sIGFuaW1hdGlvbk1vZGVsLCBkYXRhSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGlwU2hhcGVbdmFsdWVEaW0ud2hdID0gMDtcbiAgICAgIGNsaXBQYXRoID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgIHNoYXBlOiBjbGlwU2hhcGVcbiAgICAgIH0pO1xuICAgICAgYmFyLl9fcGljdG9yaWFsQnVuZGxlLnNldENsaXBQYXRoKGNsaXBQYXRoKTtcbiAgICAgIGJhci5fX3BpY3RvcmlhbENsaXBQYXRoID0gY2xpcFBhdGg7XG4gICAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgICB0YXJnZXRbdmFsdWVEaW0ud2hdID0gc3ltYm9sTWV0YS5jbGlwU2hhcGVbdmFsdWVEaW0ud2hdO1xuICAgICAgZ3JhcGhpY1tpc1VwZGF0ZSA/ICd1cGRhdGVQcm9wcycgOiAnaW5pdFByb3BzJ10oY2xpcFBhdGgsIHtcbiAgICAgICAgc2hhcGU6IHRhcmdldFxuICAgICAgfSwgYW5pbWF0aW9uTW9kZWwsIGRhdGFJbmRleCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRJdGVtTW9kZWwoZGF0YSwgZGF0YUluZGV4KSB7XG4gIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChkYXRhSW5kZXgpO1xuICBpdGVtTW9kZWwuZ2V0QW5pbWF0aW9uRGVsYXlQYXJhbXMgPSBnZXRBbmltYXRpb25EZWxheVBhcmFtcztcbiAgaXRlbU1vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCA9IGlzQW5pbWF0aW9uRW5hYmxlZDtcbiAgcmV0dXJuIGl0ZW1Nb2RlbDtcbn1cbmZ1bmN0aW9uIGdldEFuaW1hdGlvbkRlbGF5UGFyYW1zKHBhdGgpIHtcbiAgLy8gVGhlIG9yZGVyIGlzIHRoZSBzYW1lIGFzIHRoZSB6LW9yZGVyLCBzZWUgYHN5bWJvbFJlcGVhdERpcmV0aW9uYC5cbiAgcmV0dXJuIHtcbiAgICBpbmRleDogcGF0aC5fX3BpY3RvcmlhbEFuaW1hdGlvbkluZGV4LFxuICAgIGNvdW50OiBwYXRoLl9fcGljdG9yaWFsUmVwZWF0VGltZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQW5pbWF0aW9uRW5hYmxlZCgpIHtcbiAgLy8gYGFuaW1hdGlvbmAgcHJvcCBjYW4gYmUgc2V0IG9uIGl0ZW1Nb2RlbCBpbiBwaWN0b3JpYWwgYmFyIGNoYXJ0LlxuICByZXR1cm4gdGhpcy5wYXJlbnRNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKSAmJiAhIXRoaXMuZ2V0U2hhbGxvdygnYW5pbWF0aW9uJyk7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXIoZGF0YSwgb3B0LCBzeW1ib2xNZXRhLCBpc1VwZGF0ZSkge1xuICAvLyBiYXIgaXMgdGhlIG1haW4gZWxlbWVudCBmb3IgZWFjaCBkYXRhLlxuICB2YXIgYmFyID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgLy8gYnVuZGxlIGlzIHVzZWQgZm9yIGxvY2F0aW9uIGFuZCBjbGlwLlxuICB2YXIgYnVuZGxlID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgYmFyLmFkZChidW5kbGUpO1xuICBiYXIuX19waWN0b3JpYWxCdW5kbGUgPSBidW5kbGU7XG4gIGJ1bmRsZS54ID0gc3ltYm9sTWV0YS5idW5kbGVQb3NpdGlvblswXTtcbiAgYnVuZGxlLnkgPSBzeW1ib2xNZXRhLmJ1bmRsZVBvc2l0aW9uWzFdO1xuICBpZiAoc3ltYm9sTWV0YS5zeW1ib2xSZXBlYXQpIHtcbiAgICBjcmVhdGVPclVwZGF0ZVJlcGVhdFN5bWJvbHMoYmFyLCBvcHQsIHN5bWJvbE1ldGEpO1xuICB9IGVsc2Uge1xuICAgIGNyZWF0ZU9yVXBkYXRlU2luZ2xlU3ltYm9sKGJhciwgb3B0LCBzeW1ib2xNZXRhKTtcbiAgfVxuICBjcmVhdGVPclVwZGF0ZUJhclJlY3QoYmFyLCBzeW1ib2xNZXRhLCBpc1VwZGF0ZSk7XG4gIGNyZWF0ZU9yVXBkYXRlQ2xpcChiYXIsIG9wdCwgc3ltYm9sTWV0YSwgaXNVcGRhdGUpO1xuICBiYXIuX19waWN0b3JpYWxTaGFwZVN0ciA9IGdldFNoYXBlU3RyKGRhdGEsIHN5bWJvbE1ldGEpO1xuICBiYXIuX19waWN0b3JpYWxTeW1ib2xNZXRhID0gc3ltYm9sTWV0YTtcbiAgcmV0dXJuIGJhcjtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUJhcihiYXIsIG9wdCwgc3ltYm9sTWV0YSkge1xuICB2YXIgYW5pbWF0aW9uTW9kZWwgPSBzeW1ib2xNZXRhLmFuaW1hdGlvbk1vZGVsO1xuICB2YXIgZGF0YUluZGV4ID0gc3ltYm9sTWV0YS5kYXRhSW5kZXg7XG4gIHZhciBidW5kbGUgPSBiYXIuX19waWN0b3JpYWxCdW5kbGU7XG4gIGdyYXBoaWMudXBkYXRlUHJvcHMoYnVuZGxlLCB7XG4gICAgeDogc3ltYm9sTWV0YS5idW5kbGVQb3NpdGlvblswXSxcbiAgICB5OiBzeW1ib2xNZXRhLmJ1bmRsZVBvc2l0aW9uWzFdXG4gIH0sIGFuaW1hdGlvbk1vZGVsLCBkYXRhSW5kZXgpO1xuICBpZiAoc3ltYm9sTWV0YS5zeW1ib2xSZXBlYXQpIHtcbiAgICBjcmVhdGVPclVwZGF0ZVJlcGVhdFN5bWJvbHMoYmFyLCBvcHQsIHN5bWJvbE1ldGEsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGNyZWF0ZU9yVXBkYXRlU2luZ2xlU3ltYm9sKGJhciwgb3B0LCBzeW1ib2xNZXRhLCB0cnVlKTtcbiAgfVxuICBjcmVhdGVPclVwZGF0ZUJhclJlY3QoYmFyLCBzeW1ib2xNZXRhLCB0cnVlKTtcbiAgY3JlYXRlT3JVcGRhdGVDbGlwKGJhciwgb3B0LCBzeW1ib2xNZXRhLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUJhcihkYXRhLCBkYXRhSW5kZXgsIGFuaW1hdGlvbk1vZGVsLCBiYXIpIHtcbiAgLy8gTm90IHNob3cgdGV4dCB3aGVuIGFuaW1hdGluZ1xuICB2YXIgbGFiZWxSZWN0ID0gYmFyLl9fcGljdG9yaWFsQmFyUmVjdDtcbiAgbGFiZWxSZWN0ICYmIGxhYmVsUmVjdC5yZW1vdmVUZXh0Q29udGVudCgpO1xuICB2YXIgcGF0aHMgPSBbXTtcbiAgZWFjaFBhdGgoYmFyLCBmdW5jdGlvbiAocGF0aCkge1xuICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gIH0pO1xuICBiYXIuX19waWN0b3JpYWxNYWluUGF0aCAmJiBwYXRocy5wdXNoKGJhci5fX3BpY3RvcmlhbE1haW5QYXRoKTtcbiAgLy8gSSBkbyBub3QgZmluZCBwcm9wZXIgcmVtb3ZlIGFuaW1hdGlvbiBmb3IgY2xpcCB5ZXQuXG4gIGJhci5fX3BpY3RvcmlhbENsaXBQYXRoICYmIChhbmltYXRpb25Nb2RlbCA9IG51bGwpO1xuICB6clV0aWwuZWFjaChwYXRocywgZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBncmFwaGljLnJlbW92ZUVsZW1lbnQocGF0aCwge1xuICAgICAgc2NhbGVYOiAwLFxuICAgICAgc2NhbGVZOiAwXG4gICAgfSwgYW5pbWF0aW9uTW9kZWwsIGRhdGFJbmRleCwgZnVuY3Rpb24gKCkge1xuICAgICAgYmFyLnBhcmVudCAmJiBiYXIucGFyZW50LnJlbW92ZShiYXIpO1xuICAgIH0pO1xuICB9KTtcbiAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgbnVsbCk7XG59XG5mdW5jdGlvbiBnZXRTaGFwZVN0cihkYXRhLCBzeW1ib2xNZXRhKSB7XG4gIHJldHVybiBbZGF0YS5nZXRJdGVtVmlzdWFsKHN5bWJvbE1ldGEuZGF0YUluZGV4LCAnc3ltYm9sJykgfHwgJ25vbmUnLCAhIXN5bWJvbE1ldGEuc3ltYm9sUmVwZWF0LCAhIXN5bWJvbE1ldGEuc3ltYm9sQ2xpcF0uam9pbignOicpO1xufVxuZnVuY3Rpb24gZWFjaFBhdGgoYmFyLCBjYiwgY29udGV4dCkge1xuICAvLyBEbyBub3QgdXNlIEdyb3VwI2VhY2hDaGlsZCwgYmVjYXVzZSBpdCBkbyBub3Qgc3VwcG9ydCByZW1vdmUuXG4gIHpyVXRpbC5lYWNoKGJhci5fX3BpY3RvcmlhbEJ1bmRsZS5jaGlsZHJlbigpLCBmdW5jdGlvbiAoZWwpIHtcbiAgICBlbCAhPT0gYmFyLl9fcGljdG9yaWFsQmFyUmVjdCAmJiBjYi5jYWxsKGNvbnRleHQsIGVsKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVBdHRyKGVsLCBpbW1lZGlhdGVBdHRycywgYW5pbWF0aW9uQXR0cnMsIHN5bWJvbE1ldGEsIGlzVXBkYXRlLCBjYikge1xuICBpbW1lZGlhdGVBdHRycyAmJiBlbC5hdHRyKGltbWVkaWF0ZUF0dHJzKTtcbiAgLy8gd2hlbiBzeW1ib2xDaXAgdXNlZCwgb25seSBjbGlwIHBhdGggaGFzIGluaXQgYW5pbWF0aW9uLCBvdGhlcndpc2UgaXQgd291bGQgYmUgd2VpcmQgZWZmZWN0LlxuICBpZiAoc3ltYm9sTWV0YS5zeW1ib2xDbGlwICYmICFpc1VwZGF0ZSkge1xuICAgIGFuaW1hdGlvbkF0dHJzICYmIGVsLmF0dHIoYW5pbWF0aW9uQXR0cnMpO1xuICB9IGVsc2Uge1xuICAgIGFuaW1hdGlvbkF0dHJzICYmIGdyYXBoaWNbaXNVcGRhdGUgPyAndXBkYXRlUHJvcHMnIDogJ2luaXRQcm9wcyddKGVsLCBhbmltYXRpb25BdHRycywgc3ltYm9sTWV0YS5hbmltYXRpb25Nb2RlbCwgc3ltYm9sTWV0YS5kYXRhSW5kZXgsIGNiKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQ29tbW9uKGJhciwgb3B0LCBzeW1ib2xNZXRhKSB7XG4gIHZhciBkYXRhSW5kZXggPSBzeW1ib2xNZXRhLmRhdGFJbmRleDtcbiAgdmFyIGl0ZW1Nb2RlbCA9IHN5bWJvbE1ldGEuaXRlbU1vZGVsO1xuICAvLyBDb2xvciBtdXN0IGJlIGV4Y2x1ZGVkLlxuICAvLyBCZWNhdXNlIHN5bWJvbCBwcm92aWRlIHNldENvbG9yIGluZGl2aWR1YWxseSB0byBzZXQgZmlsbCBhbmQgc3Ryb2tlXG4gIHZhciBlbXBoYXNpc01vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdlbXBoYXNpcycpO1xuICB2YXIgZW1waGFzaXNTdHlsZSA9IGVtcGhhc2lzTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZSgpO1xuICB2YXIgYmx1clN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKFsnYmx1cicsICdpdGVtU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCk7XG4gIHZhciBzZWxlY3RTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChbJ3NlbGVjdCcsICdpdGVtU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCk7XG4gIHZhciBjdXJzb3JTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdjdXJzb3InKTtcbiAgdmFyIGZvY3VzID0gZW1waGFzaXNNb2RlbC5nZXQoJ2ZvY3VzJyk7XG4gIHZhciBibHVyU2NvcGUgPSBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJyk7XG4gIHZhciBob3ZlclNjYWxlID0gZW1waGFzaXNNb2RlbC5nZXQoJ3NjYWxlJyk7XG4gIGVhY2hQYXRoKGJhciwgZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFpSSW1hZ2UpIHtcbiAgICAgIHZhciBwYXRoU3R5bGUgPSBwYXRoLnN0eWxlO1xuICAgICAgcGF0aC51c2VTdHlsZSh6clV0aWwuZXh0ZW5kKHtcbiAgICAgICAgLy8gVE9ETyBvdGhlciBwcm9wZXJ0aWVzIGxpa2UgZHgsIGR5ID9cbiAgICAgICAgaW1hZ2U6IHBhdGhTdHlsZS5pbWFnZSxcbiAgICAgICAgeDogcGF0aFN0eWxlLngsXG4gICAgICAgIHk6IHBhdGhTdHlsZS55LFxuICAgICAgICB3aWR0aDogcGF0aFN0eWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHBhdGhTdHlsZS5oZWlnaHRcbiAgICAgIH0sIHN5bWJvbE1ldGEuc3R5bGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC51c2VTdHlsZShzeW1ib2xNZXRhLnN0eWxlKTtcbiAgICB9XG4gICAgdmFyIGVtcGhhc2lzU3RhdGUgPSBwYXRoLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpO1xuICAgIGVtcGhhc2lzU3RhdGUuc3R5bGUgPSBlbXBoYXNpc1N0eWxlO1xuICAgIGlmIChob3ZlclNjYWxlKSB7XG4gICAgICAvLyBOT1RFOiBNdXN0IGFmdGVyIHNjYWxlIGlzIHNldCBhZnRlciB1cGRhdGVBdHRyXG4gICAgICBlbXBoYXNpc1N0YXRlLnNjYWxlWCA9IHBhdGguc2NhbGVYICogMS4xO1xuICAgICAgZW1waGFzaXNTdGF0ZS5zY2FsZVkgPSBwYXRoLnNjYWxlWSAqIDEuMTtcbiAgICB9XG4gICAgcGF0aC5lbnN1cmVTdGF0ZSgnYmx1cicpLnN0eWxlID0gYmx1clN0eWxlO1xuICAgIHBhdGguZW5zdXJlU3RhdGUoJ3NlbGVjdCcpLnN0eWxlID0gc2VsZWN0U3R5bGU7XG4gICAgY3Vyc29yU3R5bGUgJiYgKHBhdGguY3Vyc29yID0gY3Vyc29yU3R5bGUpO1xuICAgIHBhdGguejIgPSBzeW1ib2xNZXRhLnoyO1xuICB9KTtcbiAgdmFyIGJhclBvc2l0aW9uT3V0c2lkZSA9IG9wdC52YWx1ZURpbS5wb3NEZXNjWysoc3ltYm9sTWV0YS5ib3VuZGluZ0xlbmd0aCA+IDApXTtcbiAgdmFyIGJhclJlY3QgPSBiYXIuX19waWN0b3JpYWxCYXJSZWN0O1xuICBiYXJSZWN0Lmlnbm9yZUNsaXAgPSB0cnVlO1xuICBzZXRMYWJlbFN0eWxlKGJhclJlY3QsIGdldExhYmVsU3RhdGVzTW9kZWxzKGl0ZW1Nb2RlbCksIHtcbiAgICBsYWJlbEZldGNoZXI6IG9wdC5zZXJpZXNNb2RlbCxcbiAgICBsYWJlbERhdGFJbmRleDogZGF0YUluZGV4LFxuICAgIGRlZmF1bHRUZXh0OiBnZXREZWZhdWx0TGFiZWwob3B0LnNlcmllc01vZGVsLmdldERhdGEoKSwgZGF0YUluZGV4KSxcbiAgICBpbmhlcml0Q29sb3I6IHN5bWJvbE1ldGEuc3R5bGUuZmlsbCxcbiAgICBkZWZhdWx0T3BhY2l0eTogc3ltYm9sTWV0YS5zdHlsZS5vcGFjaXR5LFxuICAgIGRlZmF1bHRPdXRzaWRlUG9zaXRpb246IGJhclBvc2l0aW9uT3V0c2lkZVxuICB9KTtcbiAgdG9nZ2xlSG92ZXJFbXBoYXNpcyhiYXIsIGZvY3VzLCBibHVyU2NvcGUsIGVtcGhhc2lzTW9kZWwuZ2V0KCdkaXNhYmxlZCcpKTtcbn1cbmZ1bmN0aW9uIHRvSW50VGltZXModGltZXMpIHtcbiAgdmFyIHJvdW5kZWRUaW1lcyA9IE1hdGgucm91bmQodGltZXMpO1xuICAvLyBFc2NhcHNlIGFjY3VyYXRlIGVycm9yXG4gIHJldHVybiBNYXRoLmFicyh0aW1lcyAtIHJvdW5kZWRUaW1lcykgPCAxZS00ID8gcm91bmRlZFRpbWVzIDogTWF0aC5jZWlsKHRpbWVzKTtcbn1cbmV4cG9ydCBkZWZhdWx0IFBpY3RvcmlhbEJhclZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBCYXNlQmFyU2VyaWVzTW9kZWwgZnJvbSAnLi9CYXNlQmFyU2VyaWVzLmpzJztcbmltcG9ydCB7IGluaGVyaXREZWZhdWx0T3B0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbC9jb21wb25lbnQuanMnO1xudmFyIFBpY3RvcmlhbEJhclNlcmllc01vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBpY3RvcmlhbEJhclNlcmllc01vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBQaWN0b3JpYWxCYXJTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gUGljdG9yaWFsQmFyU2VyaWVzTW9kZWwudHlwZTtcbiAgICBfdGhpcy5oYXNTeW1ib2xWaXN1YWwgPSB0cnVlO1xuICAgIF90aGlzLmRlZmF1bHRTeW1ib2wgPSAncm91bmRSZWN0JztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgUGljdG9yaWFsQmFyU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIC8vIERpc2FibGUgc3RhY2suXG4gICAgb3B0aW9uLnN0YWNrID0gbnVsbDtcbiAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBQaWN0b3JpYWxCYXJTZXJpZXNNb2RlbC50eXBlID0gJ3Nlcmllcy5waWN0b3JpYWxCYXInO1xuICBQaWN0b3JpYWxCYXJTZXJpZXNNb2RlbC5kZXBlbmRlbmNpZXMgPSBbJ2dyaWQnXTtcbiAgUGljdG9yaWFsQmFyU2VyaWVzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IGluaGVyaXREZWZhdWx0T3B0aW9uKEJhc2VCYXJTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uLCB7XG4gICAgc3ltYm9sOiAnY2lyY2xlJyxcbiAgICBzeW1ib2xTaXplOiBudWxsLFxuICAgIHN5bWJvbFJvdGF0ZTogbnVsbCxcbiAgICBzeW1ib2xQb3NpdGlvbjogbnVsbCxcbiAgICBzeW1ib2xPZmZzZXQ6IG51bGwsXG4gICAgc3ltYm9sTWFyZ2luOiBudWxsLFxuICAgIHN5bWJvbFJlcGVhdDogZmFsc2UsXG4gICAgc3ltYm9sUmVwZWF0RGlyZWN0aW9uOiAnZW5kJyxcbiAgICBzeW1ib2xDbGlwOiBmYWxzZSxcbiAgICBzeW1ib2xCb3VuZGluZ0RhdGE6IG51bGwsXG4gICAgc3ltYm9sUGF0dGVyblNpemU6IDQwMCxcbiAgICBiYXJHYXA6ICctMTAwJScsXG4gICAgLy8gUGljdG9yaWFsIGJhciBkbyBub3QgY2xpcCBieSBkZWZhdWx0IGJlY2F1c2UgaW4gbWFueSBjYXNlc1xuICAgIC8vIHhBeGlzIGFuZCB5QXhpcyBhcmUgbm90IGRpc3BsYXllZCBhbmQgaXQncyBleHBlY3RlZCBub3QgdG8gY2xpcFxuICAgIGNsaXA6IGZhbHNlLFxuICAgIC8vIHogY2FuIGJlIHNldCBpbiBkYXRhIGl0ZW0sIHdoaWNoIGlzIHoyIGFjdHVhbGx5LlxuICAgIC8vIERpc2FibGUgcHJvZ3Jlc3NpdmVcbiAgICBwcm9ncmVzc2l2ZTogMCxcbiAgICBlbXBoYXNpczoge1xuICAgICAgLy8gQnkgZGVmYXVsdCBwaWN0b3JpYWxCYXIgZG8gbm90IGhvdmVyIHNjYWxlLiBIb3ZlciBzY2FsZSBpcyBub3Qgc3VpdGFibGVcbiAgICAgIC8vIGZvciB0aGUgY2FzZSB0aGF0IGJvdGggaGFzIGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQuXG4gICAgICBzY2FsZTogZmFsc2VcbiAgICB9LFxuICAgIHNlbGVjdDoge1xuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzIxMjEyMSdcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gUGljdG9yaWFsQmFyU2VyaWVzTW9kZWw7XG59KEJhc2VCYXJTZXJpZXNNb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBQaWN0b3JpYWxCYXJTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBQaWN0b3JpYWxCYXJWaWV3IGZyb20gJy4vUGljdG9yaWFsQmFyVmlldy5qcyc7XG5pbXBvcnQgUGljdG9yaWFsQmFyU2VyaWVzTW9kZWwgZnJvbSAnLi9QaWN0b3JpYWxCYXJTZXJpZXMuanMnO1xuaW1wb3J0IHsgY3JlYXRlUHJvZ3Jlc3NpdmVMYXlvdXQsIGxheW91dCB9IGZyb20gJy4uLy4uL2xheW91dC9iYXJHcmlkLmpzJztcbmltcG9ydCB7IGN1cnJ5IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDaGFydFZpZXcoUGljdG9yaWFsQmFyVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclNlcmllc01vZGVsKFBpY3RvcmlhbEJhclNlcmllc01vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KHJlZ2lzdGVycy5QUklPUklUWS5WSVNVQUwuTEFZT1VULCBjdXJyeShsYXlvdXQsICdwaWN0b3JpYWxCYXInKSk7XG4gIC8vIERvIGxheW91dCBhZnRlciBvdGhlciBvdmVyYWxsIGxheW91dCwgd2hpY2ggY2FuIHByZXBhcmUgc29tZSBpbmZvcm1hdGlvbi5cbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KHJlZ2lzdGVycy5QUklPUklUWS5WSVNVQUwuUFJPR1JFU1NJVkVfTEFZT1VULCBjcmVhdGVQcm9ncmVzc2l2ZUxheW91dCgncGljdG9yaWFsQmFyJykpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///61152\n")},72108:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ install)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _layout_barGrid_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62536);\n/* harmony import */ var _processor_dataSample_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(37959);\n/* harmony import */ var _BarSeries_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47987);\n/* harmony import */ var _BarView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60859);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nfunction install(registers) {\n  registers.registerChartView(_BarView_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A);\n  registers.registerSeriesModel(_BarSeries_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A);\n  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.curry(_layout_barGrid_js__WEBPACK_IMPORTED_MODULE_3__/* .layout */ .Zp, 'bar'));\n  // Do layout after other overall layout, which can prepare some information.\n  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, (0,_layout_barGrid_js__WEBPACK_IMPORTED_MODULE_3__/* .createProgressiveLayout */ .KF)('bar'));\n  // Down sample after filter\n  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, (0,_processor_dataSample_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A)('bar'));\n  /**\r\n   * @payload\r\n   * @property {string} [componentType=series]\r\n   * @property {number} [dx]\r\n   * @property {number} [dy]\r\n   * @property {number} [zoom]\r\n   * @property {number} [originX]\r\n   * @property {number} [originY]\r\n   */\n  registers.registerAction({\n    type: 'changeAxisOrder',\n    event: 'changeAxisOrder',\n    update: 'update'\n  }, function (payload, ecModel) {\n    var componentType = payload.componentType || 'series';\n    ecModel.eachComponent({\n      mainType: componentType,\n      query: payload\n    }, function (componentModel) {\n      if (payload.sortInfo) {\n        componentModel.axis.setCategorySortInfo(payload.sortInfo);\n      }\n    });\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIxMDguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL2luc3RhbGwuanM/ZGY0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgbGF5b3V0LCBjcmVhdGVQcm9ncmVzc2l2ZUxheW91dCB9IGZyb20gJy4uLy4uL2xheW91dC9iYXJHcmlkLmpzJztcbmltcG9ydCBkYXRhU2FtcGxlIGZyb20gJy4uLy4uL3Byb2Nlc3Nvci9kYXRhU2FtcGxlLmpzJztcbmltcG9ydCBCYXJTZXJpZXMgZnJvbSAnLi9CYXJTZXJpZXMuanMnO1xuaW1wb3J0IEJhclZpZXcgZnJvbSAnLi9CYXJWaWV3LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDaGFydFZpZXcoQmFyVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclNlcmllc01vZGVsKEJhclNlcmllcyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckxheW91dChyZWdpc3RlcnMuUFJJT1JJVFkuVklTVUFMLkxBWU9VVCwgenJVdGlsLmN1cnJ5KGxheW91dCwgJ2JhcicpKTtcbiAgLy8gRG8gbGF5b3V0IGFmdGVyIG90aGVyIG92ZXJhbGwgbGF5b3V0LCB3aGljaCBjYW4gcHJlcGFyZSBzb21lIGluZm9ybWF0aW9uLlxuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQocmVnaXN0ZXJzLlBSSU9SSVRZLlZJU1VBTC5QUk9HUkVTU0lWRV9MQVlPVVQsIGNyZWF0ZVByb2dyZXNzaXZlTGF5b3V0KCdiYXInKSk7XG4gIC8vIERvd24gc2FtcGxlIGFmdGVyIGZpbHRlclxuICByZWdpc3RlcnMucmVnaXN0ZXJQcm9jZXNzb3IocmVnaXN0ZXJzLlBSSU9SSVRZLlBST0NFU1NPUi5TVEFUSVNUSUMsIGRhdGFTYW1wbGUoJ2JhcicpKTtcbiAgLyoqXHJcbiAgICogQHBheWxvYWRcclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbXBvbmVudFR5cGU9c2VyaWVzXVxyXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHhdXHJcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtkeV1cclxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3pvb21dXHJcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcmlnaW5YXVxyXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3JpZ2luWV1cclxuICAgKi9cbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICB0eXBlOiAnY2hhbmdlQXhpc09yZGVyJyxcbiAgICBldmVudDogJ2NoYW5nZUF4aXNPcmRlcicsXG4gICAgdXBkYXRlOiAndXBkYXRlJ1xuICB9LCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICAgIHZhciBjb21wb25lbnRUeXBlID0gcGF5bG9hZC5jb21wb25lbnRUeXBlIHx8ICdzZXJpZXMnO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICBtYWluVHlwZTogY29tcG9uZW50VHlwZSxcbiAgICAgIHF1ZXJ5OiBwYXlsb2FkXG4gICAgfSwgZnVuY3Rpb24gKGNvbXBvbmVudE1vZGVsKSB7XG4gICAgICBpZiAocGF5bG9hZC5zb3J0SW5mbykge1xuICAgICAgICBjb21wb25lbnRNb2RlbC5heGlzLnNldENhdGVnb3J5U29ydEluZm8ocGF5bG9hZC5zb3J0SW5mbyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///72108\n")}}]);