"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[9150],{4270:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install_install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/extension.js\nvar extension = __webpack_require__(3087);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Circle.js\nvar Circle = __webpack_require__(31571);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/MapDraw.js\nvar MapDraw = __webpack_require__(8027);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n;// ./node_modules/echarts/lib/chart/map/MapView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\nvar MapView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(MapView, _super);\n  function MapView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = MapView.type;\n    return _this;\n  }\n  MapView.prototype.render = function (mapModel, ecModel, api, payload) {\n    // Not render if it is an toggleSelect action from self\n    if (payload && payload.type === 'mapToggleSelect' && payload.from === this.uid) {\n      return;\n    }\n    var group = this.group;\n    group.removeAll();\n    if (mapModel.getHostGeoModel()) {\n      return;\n    }\n    if (this._mapDraw && payload && payload.type === 'geoRoam') {\n      this._mapDraw.resetForLabelLayout();\n    }\n    // Not update map if it is an roam action from self\n    if (!(payload && payload.type === 'geoRoam' && payload.componentType === 'series' && payload.seriesId === mapModel.id)) {\n      if (mapModel.needsDrawMap) {\n        var mapDraw = this._mapDraw || new MapDraw/* default */.A(api);\n        group.add(mapDraw.group);\n        mapDraw.draw(mapModel, ecModel, api, this, payload);\n        this._mapDraw = mapDraw;\n      } else {\n        // Remove drawn map\n        this._mapDraw && this._mapDraw.remove();\n        this._mapDraw = null;\n      }\n    } else {\n      var mapDraw = this._mapDraw;\n      mapDraw && group.add(mapDraw.group);\n    }\n    mapModel.get('showLegendSymbol') && ecModel.getComponent('legend') && this._renderSymbols(mapModel, ecModel, api);\n  };\n  MapView.prototype.remove = function () {\n    this._mapDraw && this._mapDraw.remove();\n    this._mapDraw = null;\n    this.group.removeAll();\n  };\n  MapView.prototype.dispose = function () {\n    this._mapDraw && this._mapDraw.remove();\n    this._mapDraw = null;\n  };\n  MapView.prototype._renderSymbols = function (mapModel, ecModel, api) {\n    var originalData = mapModel.originalData;\n    var group = this.group;\n    originalData.each(originalData.mapDimension('value'), function (value, originalDataIndex) {\n      if (isNaN(value)) {\n        return;\n      }\n      var layout = originalData.getItemLayout(originalDataIndex);\n      if (!layout || !layout.point) {\n        // Not exists in map\n        return;\n      }\n      var point = layout.point;\n      var offset = layout.offset;\n      var circle = new Circle/* default */.A({\n        style: {\n          // Because the special of map draw.\n          // Which needs statistic of multiple series and draw on one map.\n          // And each series also need a symbol with legend color\n          //\n          // Layout and visual are put one the different data\n          // TODO\n          fill: mapModel.getData().getVisual('style').fill\n        },\n        shape: {\n          cx: point[0] + offset * 9,\n          cy: point[1],\n          r: 3\n        },\n        silent: true,\n        // Do not overlap the first series, on which labels are displayed.\n        z2: 8 + (!offset ? states/* Z2_EMPHASIS_LIFT */.CA + 1 : 0)\n      });\n      // Only the series that has the first value on the same region is in charge of rendering the label.\n      // But consider the case:\n      // series: [\n      //     {id: 'X', type: 'map', map: 'm', {data: [{name: 'A', value: 11}, {name: 'B', {value: 22}]},\n      //     {id: 'Y', type: 'map', map: 'm', {data: [{name: 'A', value: 21}, {name: 'C', {value: 33}]}\n      // ]\n      // The offset `0` of item `A` is at series `X`, but of item `C` is at series `Y`.\n      // For backward compatibility, we follow the rule that render label `A` by the\n      // settings on series `X` but render label `C` by the settings on series `Y`.\n      if (!offset) {\n        var fullData = mapModel.mainSeries.getData();\n        var name_1 = originalData.getName(originalDataIndex);\n        var fullIndex_1 = fullData.indexOfName(name_1);\n        var itemModel = originalData.getItemModel(originalDataIndex);\n        var labelModel = itemModel.getModel('label');\n        var regionGroup = fullData.getItemGraphicEl(fullIndex_1);\n        // `getFormattedLabel` needs to use `getData` inside. Here\n        // `mapModel.getData()` is shallow cloned from `mainSeries.getData()`.\n        // FIXME\n        // If this is not the `mainSeries`, the item model (like label formatter)\n        // set on original data item will never get. But it has been working\n        // like that from the beginning, and this scenario is rarely encountered.\n        // So it won't be fixed until we have to.\n        (0,labelStyle/* setLabelStyle */.qM)(circle, (0,labelStyle/* getLabelStatesModels */.lx)(itemModel), {\n          labelFetcher: {\n            getFormattedLabel: function (idx, state) {\n              return mapModel.getFormattedLabel(fullIndex_1, state);\n            }\n          },\n          defaultText: name_1\n        });\n        circle.disableLabelAnimation = true;\n        if (!labelModel.get('position')) {\n          circle.setTextConfig({\n            position: 'bottom'\n          });\n        }\n        regionGroup.onHoverStateChange = function (toState) {\n          (0,states/* setStatesFlag */.Pk)(circle, toState);\n        };\n      }\n      group.add(circle);\n    });\n  };\n  MapView.type = 'map';\n  return MapView;\n}(Chart/* default */.A);\n/* harmony default export */ const map_MapView = (MapView);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createSeriesDataSimply.js\nvar createSeriesDataSimply = __webpack_require__(72731);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/geo/geoSourceManager.js + 5 modules\nvar geoSourceManager = __webpack_require__(76311);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/sourceHelper.js\nvar sourceHelper = __webpack_require__(23071);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js\nvar tooltipMarkup = __webpack_require__(3961);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/symbol.js\nvar symbol = __webpack_require__(62103);\n;// ./node_modules/echarts/lib/chart/map/MapSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nvar MapSeries = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(MapSeries, _super);\n  function MapSeries() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = MapSeries.type;\n    // Only first map series of same mapType will drawMap.\n    _this.needsDrawMap = false;\n    // Group of all map series with same mapType\n    _this.seriesGroup = [];\n    _this.getTooltipPosition = function (dataIndex) {\n      if (dataIndex != null) {\n        var name_1 = this.getData().getName(dataIndex);\n        var geo = this.coordinateSystem;\n        var region = geo.getRegion(name_1);\n        return region && geo.dataToPoint(region.getCenter());\n      }\n    };\n    return _this;\n  }\n  MapSeries.prototype.getInitialData = function (option) {\n    var data = (0,createSeriesDataSimply/* default */.A)(this, {\n      coordDimensions: ['value'],\n      encodeDefaulter: util.curry(sourceHelper/* makeSeriesEncodeForNameBased */.ln, this)\n    });\n    var dataNameIndexMap = util.createHashMap();\n    var toAppendItems = [];\n    for (var i = 0, len = data.count(); i < len; i++) {\n      var name_2 = data.getName(i);\n      dataNameIndexMap.set(name_2, i);\n    }\n    var geoSource = geoSourceManager/* default */.A.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);\n    util.each(geoSource.regions, function (region) {\n      var name = region.name;\n      var dataNameIdx = dataNameIndexMap.get(name);\n      // apply specified echarts style in GeoJSON data\n      var specifiedGeoJSONRegionStyle = region.properties && region.properties.echartsStyle;\n      var dataItem;\n      if (dataNameIdx == null) {\n        dataItem = {\n          name: name\n        };\n        toAppendItems.push(dataItem);\n      } else {\n        dataItem = data.getRawDataItem(dataNameIdx);\n      }\n      specifiedGeoJSONRegionStyle && util.merge(dataItem, specifiedGeoJSONRegionStyle);\n    });\n    // Complete data with missing regions. The consequent processes (like visual\n    // map and render) can not be performed without a \"full data\". For example,\n    // find `dataIndex` by name.\n    data.appendData(toAppendItems);\n    return data;\n  };\n  /**\r\n   * If no host geo model, return null, which means using a\r\n   * inner exclusive geo model.\r\n   */\n  MapSeries.prototype.getHostGeoModel = function () {\n    var geoIndex = this.option.geoIndex;\n    return geoIndex != null ? this.ecModel.getComponent('geo', geoIndex) : null;\n  };\n  MapSeries.prototype.getMapType = function () {\n    return (this.getHostGeoModel() || this).option.map;\n  };\n  // _fillOption(option, mapName) {\n  // Shallow clone\n  // option = zrUtil.extend({}, option);\n  // option.data = geoCreator.getFilledRegions(option.data, mapName, option.nameMap);\n  // return option;\n  // }\n  MapSeries.prototype.getRawValue = function (dataIndex) {\n    // Use value stored in data instead because it is calculated from multiple series\n    // FIXME Provide all value of multiple series ?\n    var data = this.getData();\n    return data.get(data.mapDimension('value'), dataIndex);\n  };\n  /**\r\n   * Get model of region\r\n   */\n  MapSeries.prototype.getRegionModel = function (regionName) {\n    var data = this.getData();\n    return data.getItemModel(data.indexOfName(regionName));\n  };\n  /**\r\n   * Map tooltip formatter\r\n   */\n  MapSeries.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n    // FIXME orignalData and data is a bit confusing\n    var data = this.getData();\n    var value = this.getRawValue(dataIndex);\n    var name = data.getName(dataIndex);\n    var seriesGroup = this.seriesGroup;\n    var seriesNames = [];\n    for (var i = 0; i < seriesGroup.length; i++) {\n      var otherIndex = seriesGroup[i].originalData.indexOfName(name);\n      var valueDim = data.mapDimension('value');\n      if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {\n        seriesNames.push(seriesGroup[i].name);\n      }\n    }\n    return (0,tooltipMarkup/* createTooltipMarkup */.Qx)('section', {\n      header: seriesNames.join(', '),\n      noHeader: !seriesNames.length,\n      blocks: [(0,tooltipMarkup/* createTooltipMarkup */.Qx)('nameValue', {\n        name: name,\n        value: value\n      })]\n    });\n  };\n  MapSeries.prototype.setZoom = function (zoom) {\n    this.option.zoom = zoom;\n  };\n  MapSeries.prototype.setCenter = function (center) {\n    this.option.center = center;\n  };\n  MapSeries.prototype.getLegendIcon = function (opt) {\n    var iconType = opt.icon || 'roundRect';\n    var icon = (0,symbol/* createSymbol */.v5)(iconType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill);\n    icon.setStyle(opt.itemStyle);\n    // Map do not use itemStyle.borderWidth as border width\n    icon.style.stroke = 'none';\n    // No rotation because no series visual symbol for map\n    if (iconType.indexOf('empty') > -1) {\n      icon.style.stroke = icon.style.fill;\n      icon.style.fill = '#fff';\n      icon.style.lineWidth = 2;\n    }\n    return icon;\n  };\n  MapSeries.type = 'series.map';\n  MapSeries.dependencies = ['geo'];\n  MapSeries.layoutMode = 'box';\n  MapSeries.defaultOption = {\n    // 一级层叠\n    // zlevel: 0,\n    // 二级层叠\n    z: 2,\n    coordinateSystem: 'geo',\n    // map should be explicitly specified since ec3.\n    map: '',\n    // If `geoIndex` is not specified, a exclusive geo will be\n    // created. Otherwise use the specified geo component, and\n    // `map` and `mapType` are ignored.\n    // geoIndex: 0,\n    // 'center' | 'left' | 'right' | 'x%' | {number}\n    left: 'center',\n    // 'center' | 'top' | 'bottom' | 'x%' | {number}\n    top: 'center',\n    // right\n    // bottom\n    // width:\n    // height\n    // Aspect is width / height. Inited to be geoJson bbox aspect\n    // This parameter is used for scale this aspect\n    // Default value:\n    // for geoSVG source: 1,\n    // for geoJSON source: 0.75.\n    aspectScale: null,\n    // Layout with center and size\n    // If you want to put map in a fixed size box with right aspect ratio\n    // This two properties may be more convenient.\n    // layoutCenter: [50%, 50%]\n    // layoutSize: 100\n    showLegendSymbol: true,\n    // Define left-top, right-bottom coords to control view\n    // For example, [ [180, 90], [-180, -90] ],\n    // higher priority than center and zoom\n    boundingCoords: null,\n    // Default on center of map\n    center: null,\n    zoom: 1,\n    scaleLimit: null,\n    selectedMode: true,\n    label: {\n      show: false,\n      color: '#000'\n    },\n    // scaleLimit: null,\n    itemStyle: {\n      borderWidth: 0.5,\n      borderColor: '#444',\n      areaColor: '#eee'\n    },\n    emphasis: {\n      label: {\n        show: true,\n        color: 'rgb(100,0,0)'\n      },\n      itemStyle: {\n        areaColor: 'rgba(255,215,0,0.8)'\n      }\n    },\n    select: {\n      label: {\n        show: true,\n        color: 'rgb(100,0,0)'\n      },\n      itemStyle: {\n        color: 'rgba(255,215,0,0.8)'\n      }\n    },\n    nameProperty: 'name'\n  };\n  return MapSeries;\n}(Series/* default */.A);\n/* harmony default export */ const map_MapSeries = (MapSeries);\n;// ./node_modules/echarts/lib/chart/map/mapDataStatistic.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n// FIXME 公用？\nfunction dataStatistics(datas, statisticType) {\n  var dataNameMap = {};\n  util.each(datas, function (data) {\n    data.each(data.mapDimension('value'), function (value, idx) {\n      // Add prefix to avoid conflict with Object.prototype.\n      var mapKey = 'ec-' + data.getName(idx);\n      dataNameMap[mapKey] = dataNameMap[mapKey] || [];\n      if (!isNaN(value)) {\n        dataNameMap[mapKey].push(value);\n      }\n    });\n  });\n  return datas[0].map(datas[0].mapDimension('value'), function (value, idx) {\n    var mapKey = 'ec-' + datas[0].getName(idx);\n    var sum = 0;\n    var min = Infinity;\n    var max = -Infinity;\n    var len = dataNameMap[mapKey].length;\n    for (var i = 0; i < len; i++) {\n      min = Math.min(min, dataNameMap[mapKey][i]);\n      max = Math.max(max, dataNameMap[mapKey][i]);\n      sum += dataNameMap[mapKey][i];\n    }\n    var result;\n    if (statisticType === 'min') {\n      result = min;\n    } else if (statisticType === 'max') {\n      result = max;\n    } else if (statisticType === 'average') {\n      result = sum / len;\n    } else {\n      result = sum;\n    }\n    return len === 0 ? NaN : result;\n  });\n}\nfunction mapDataStatistic(ecModel) {\n  var seriesGroups = {};\n  ecModel.eachSeriesByType('map', function (seriesModel) {\n    var hostGeoModel = seriesModel.getHostGeoModel();\n    var key = hostGeoModel ? 'o' + hostGeoModel.id : 'i' + seriesModel.getMapType();\n    (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel);\n  });\n  util.each(seriesGroups, function (seriesList, key) {\n    var data = dataStatistics(util.map(seriesList, function (seriesModel) {\n      return seriesModel.getData();\n    }), seriesList[0].get('mapValueCalculation'));\n    for (var i = 0; i < seriesList.length; i++) {\n      seriesList[i].originalData = seriesList[i].getData();\n    }\n    // FIXME Put where?\n    for (var i = 0; i < seriesList.length; i++) {\n      seriesList[i].seriesGroup = seriesList;\n      seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();\n      seriesList[i].setData(data.cloneShallow());\n      seriesList[i].mainSeries = seriesList[0];\n    }\n  });\n}\n;// ./node_modules/echarts/lib/chart/map/mapSymbolLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction mapSymbolLayout(ecModel) {\n  var processedMapType = {};\n  ecModel.eachSeriesByType('map', function (mapSeries) {\n    var mapType = mapSeries.getMapType();\n    if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {\n      return;\n    }\n    var mapSymbolOffsets = {};\n    util.each(mapSeries.seriesGroup, function (subMapSeries) {\n      var geo = subMapSeries.coordinateSystem;\n      var data = subMapSeries.originalData;\n      if (subMapSeries.get('showLegendSymbol') && ecModel.getComponent('legend')) {\n        data.each(data.mapDimension('value'), function (value, idx) {\n          var name = data.getName(idx);\n          var region = geo.getRegion(name);\n          // If input series.data is [11, 22, '-'/null/undefined, 44],\n          // it will be filled with NaN: [11, 22, NaN, 44] and NaN will\n          // not be drawn. So here must validate if value is NaN.\n          if (!region || isNaN(value)) {\n            return;\n          }\n          var offset = mapSymbolOffsets[name] || 0;\n          var point = geo.dataToPoint(region.getCenter());\n          mapSymbolOffsets[name] = offset + 1;\n          data.setItemLayout(idx, {\n            point: point,\n            offset: offset\n          });\n        });\n      }\n    });\n    // Show label of those region not has legendIcon (which is offset 0)\n    var data = mapSeries.getData();\n    data.each(function (idx) {\n      var name = data.getName(idx);\n      var layout = data.getItemLayout(idx) || {};\n      layout.showLabel = !mapSymbolOffsets[name];\n      data.setItemLayout(idx, layout);\n    });\n    processedMapType[mapType] = true;\n  });\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/legacy/dataSelectAction.js\nvar dataSelectAction = __webpack_require__(16884);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/geo/install.js + 1 modules\nvar install = __webpack_require__(363);\n;// ./node_modules/echarts/lib/chart/map/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nfunction install_install(registers) {\n  (0,extension/* use */.Y)(install/* install */.a);\n  registers.registerChartView(map_MapView);\n  registers.registerSeriesModel(map_MapSeries);\n  registers.registerLayout(mapSymbolLayout);\n  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic);\n  (0,dataSelectAction/* createLegacyDataSelectAction */.I)('map', registers.registerAction);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI3MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L21hcC9NYXBWaWV3LmpzPzMxMzMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L21hcC9NYXBTZXJpZXMuanM/Yzc5MiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbWFwL21hcERhdGFTdGF0aXN0aWMuanM/MzhiOCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbWFwL21hcFN5bWJvbExheW91dC5qcz8zZWE0Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9tYXAvaW5zdGFsbC5qcz9jYTg2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgTWFwRHJhdyBmcm9tICcuLi8uLi9jb21wb25lbnQvaGVscGVyL01hcERyYXcuanMnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0LmpzJztcbmltcG9ydCB7IHNldExhYmVsU3R5bGUsIGdldExhYmVsU3RhdGVzTW9kZWxzIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG5pbXBvcnQgeyBzZXRTdGF0ZXNGbGFnLCBaMl9FTVBIQVNJU19MSUZUIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMuanMnO1xudmFyIE1hcFZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTWFwVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gTWFwVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gTWFwVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBNYXBWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAobWFwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIC8vIE5vdCByZW5kZXIgaWYgaXQgaXMgYW4gdG9nZ2xlU2VsZWN0IGFjdGlvbiBmcm9tIHNlbGZcbiAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLnR5cGUgPT09ICdtYXBUb2dnbGVTZWxlY3QnICYmIHBheWxvYWQuZnJvbSA9PT0gdGhpcy51aWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICBncm91cC5yZW1vdmVBbGwoKTtcbiAgICBpZiAobWFwTW9kZWwuZ2V0SG9zdEdlb01vZGVsKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX21hcERyYXcgJiYgcGF5bG9hZCAmJiBwYXlsb2FkLnR5cGUgPT09ICdnZW9Sb2FtJykge1xuICAgICAgdGhpcy5fbWFwRHJhdy5yZXNldEZvckxhYmVsTGF5b3V0KCk7XG4gICAgfVxuICAgIC8vIE5vdCB1cGRhdGUgbWFwIGlmIGl0IGlzIGFuIHJvYW0gYWN0aW9uIGZyb20gc2VsZlxuICAgIGlmICghKHBheWxvYWQgJiYgcGF5bG9hZC50eXBlID09PSAnZ2VvUm9hbScgJiYgcGF5bG9hZC5jb21wb25lbnRUeXBlID09PSAnc2VyaWVzJyAmJiBwYXlsb2FkLnNlcmllc0lkID09PSBtYXBNb2RlbC5pZCkpIHtcbiAgICAgIGlmIChtYXBNb2RlbC5uZWVkc0RyYXdNYXApIHtcbiAgICAgICAgdmFyIG1hcERyYXcgPSB0aGlzLl9tYXBEcmF3IHx8IG5ldyBNYXBEcmF3KGFwaSk7XG4gICAgICAgIGdyb3VwLmFkZChtYXBEcmF3Lmdyb3VwKTtcbiAgICAgICAgbWFwRHJhdy5kcmF3KG1hcE1vZGVsLCBlY01vZGVsLCBhcGksIHRoaXMsIHBheWxvYWQpO1xuICAgICAgICB0aGlzLl9tYXBEcmF3ID0gbWFwRHJhdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbW92ZSBkcmF3biBtYXBcbiAgICAgICAgdGhpcy5fbWFwRHJhdyAmJiB0aGlzLl9tYXBEcmF3LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLl9tYXBEcmF3ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcERyYXcgPSB0aGlzLl9tYXBEcmF3O1xuICAgICAgbWFwRHJhdyAmJiBncm91cC5hZGQobWFwRHJhdy5ncm91cCk7XG4gICAgfVxuICAgIG1hcE1vZGVsLmdldCgnc2hvd0xlZ2VuZFN5bWJvbCcpICYmIGVjTW9kZWwuZ2V0Q29tcG9uZW50KCdsZWdlbmQnKSAmJiB0aGlzLl9yZW5kZXJTeW1ib2xzKG1hcE1vZGVsLCBlY01vZGVsLCBhcGkpO1xuICB9O1xuICBNYXBWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbWFwRHJhdyAmJiB0aGlzLl9tYXBEcmF3LnJlbW92ZSgpO1xuICAgIHRoaXMuX21hcERyYXcgPSBudWxsO1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gIH07XG4gIE1hcFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbWFwRHJhdyAmJiB0aGlzLl9tYXBEcmF3LnJlbW92ZSgpO1xuICAgIHRoaXMuX21hcERyYXcgPSBudWxsO1xuICB9O1xuICBNYXBWaWV3LnByb3RvdHlwZS5fcmVuZGVyU3ltYm9scyA9IGZ1bmN0aW9uIChtYXBNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIG9yaWdpbmFsRGF0YSA9IG1hcE1vZGVsLm9yaWdpbmFsRGF0YTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIG9yaWdpbmFsRGF0YS5lYWNoKG9yaWdpbmFsRGF0YS5tYXBEaW1lbnNpb24oJ3ZhbHVlJyksIGZ1bmN0aW9uICh2YWx1ZSwgb3JpZ2luYWxEYXRhSW5kZXgpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGxheW91dCA9IG9yaWdpbmFsRGF0YS5nZXRJdGVtTGF5b3V0KG9yaWdpbmFsRGF0YUluZGV4KTtcbiAgICAgIGlmICghbGF5b3V0IHx8ICFsYXlvdXQucG9pbnQpIHtcbiAgICAgICAgLy8gTm90IGV4aXN0cyBpbiBtYXBcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50ID0gbGF5b3V0LnBvaW50O1xuICAgICAgdmFyIG9mZnNldCA9IGxheW91dC5vZmZzZXQ7XG4gICAgICB2YXIgY2lyY2xlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBzcGVjaWFsIG9mIG1hcCBkcmF3LlxuICAgICAgICAgIC8vIFdoaWNoIG5lZWRzIHN0YXRpc3RpYyBvZiBtdWx0aXBsZSBzZXJpZXMgYW5kIGRyYXcgb24gb25lIG1hcC5cbiAgICAgICAgICAvLyBBbmQgZWFjaCBzZXJpZXMgYWxzbyBuZWVkIGEgc3ltYm9sIHdpdGggbGVnZW5kIGNvbG9yXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBMYXlvdXQgYW5kIHZpc3VhbCBhcmUgcHV0IG9uZSB0aGUgZGlmZmVyZW50IGRhdGFcbiAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgZmlsbDogbWFwTW9kZWwuZ2V0RGF0YSgpLmdldFZpc3VhbCgnc3R5bGUnKS5maWxsXG4gICAgICAgIH0sXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgY3g6IHBvaW50WzBdICsgb2Zmc2V0ICogOSxcbiAgICAgICAgICBjeTogcG9pbnRbMV0sXG4gICAgICAgICAgcjogM1xuICAgICAgICB9LFxuICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgIC8vIERvIG5vdCBvdmVybGFwIHRoZSBmaXJzdCBzZXJpZXMsIG9uIHdoaWNoIGxhYmVscyBhcmUgZGlzcGxheWVkLlxuICAgICAgICB6MjogOCArICghb2Zmc2V0ID8gWjJfRU1QSEFTSVNfTElGVCArIDEgOiAwKVxuICAgICAgfSk7XG4gICAgICAvLyBPbmx5IHRoZSBzZXJpZXMgdGhhdCBoYXMgdGhlIGZpcnN0IHZhbHVlIG9uIHRoZSBzYW1lIHJlZ2lvbiBpcyBpbiBjaGFyZ2Ugb2YgcmVuZGVyaW5nIHRoZSBsYWJlbC5cbiAgICAgIC8vIEJ1dCBjb25zaWRlciB0aGUgY2FzZTpcbiAgICAgIC8vIHNlcmllczogW1xuICAgICAgLy8gICAgIHtpZDogJ1gnLCB0eXBlOiAnbWFwJywgbWFwOiAnbScsIHtkYXRhOiBbe25hbWU6ICdBJywgdmFsdWU6IDExfSwge25hbWU6ICdCJywge3ZhbHVlOiAyMn1dfSxcbiAgICAgIC8vICAgICB7aWQ6ICdZJywgdHlwZTogJ21hcCcsIG1hcDogJ20nLCB7ZGF0YTogW3tuYW1lOiAnQScsIHZhbHVlOiAyMX0sIHtuYW1lOiAnQycsIHt2YWx1ZTogMzN9XX1cbiAgICAgIC8vIF1cbiAgICAgIC8vIFRoZSBvZmZzZXQgYDBgIG9mIGl0ZW0gYEFgIGlzIGF0IHNlcmllcyBgWGAsIGJ1dCBvZiBpdGVtIGBDYCBpcyBhdCBzZXJpZXMgYFlgLlxuICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHdlIGZvbGxvdyB0aGUgcnVsZSB0aGF0IHJlbmRlciBsYWJlbCBgQWAgYnkgdGhlXG4gICAgICAvLyBzZXR0aW5ncyBvbiBzZXJpZXMgYFhgIGJ1dCByZW5kZXIgbGFiZWwgYENgIGJ5IHRoZSBzZXR0aW5ncyBvbiBzZXJpZXMgYFlgLlxuICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgdmFyIGZ1bGxEYXRhID0gbWFwTW9kZWwubWFpblNlcmllcy5nZXREYXRhKCk7XG4gICAgICAgIHZhciBuYW1lXzEgPSBvcmlnaW5hbERhdGEuZ2V0TmFtZShvcmlnaW5hbERhdGFJbmRleCk7XG4gICAgICAgIHZhciBmdWxsSW5kZXhfMSA9IGZ1bGxEYXRhLmluZGV4T2ZOYW1lKG5hbWVfMSk7XG4gICAgICAgIHZhciBpdGVtTW9kZWwgPSBvcmlnaW5hbERhdGEuZ2V0SXRlbU1vZGVsKG9yaWdpbmFsRGF0YUluZGV4KTtcbiAgICAgICAgdmFyIGxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsJyk7XG4gICAgICAgIHZhciByZWdpb25Hcm91cCA9IGZ1bGxEYXRhLmdldEl0ZW1HcmFwaGljRWwoZnVsbEluZGV4XzEpO1xuICAgICAgICAvLyBgZ2V0Rm9ybWF0dGVkTGFiZWxgIG5lZWRzIHRvIHVzZSBgZ2V0RGF0YWAgaW5zaWRlLiBIZXJlXG4gICAgICAgIC8vIGBtYXBNb2RlbC5nZXREYXRhKClgIGlzIHNoYWxsb3cgY2xvbmVkIGZyb20gYG1haW5TZXJpZXMuZ2V0RGF0YSgpYC5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIGBtYWluU2VyaWVzYCwgdGhlIGl0ZW0gbW9kZWwgKGxpa2UgbGFiZWwgZm9ybWF0dGVyKVxuICAgICAgICAvLyBzZXQgb24gb3JpZ2luYWwgZGF0YSBpdGVtIHdpbGwgbmV2ZXIgZ2V0LiBCdXQgaXQgaGFzIGJlZW4gd29ya2luZ1xuICAgICAgICAvLyBsaWtlIHRoYXQgZnJvbSB0aGUgYmVnaW5uaW5nLCBhbmQgdGhpcyBzY2VuYXJpbyBpcyByYXJlbHkgZW5jb3VudGVyZWQuXG4gICAgICAgIC8vIFNvIGl0IHdvbid0IGJlIGZpeGVkIHVudGlsIHdlIGhhdmUgdG8uXG4gICAgICAgIHNldExhYmVsU3R5bGUoY2lyY2xlLCBnZXRMYWJlbFN0YXRlc01vZGVscyhpdGVtTW9kZWwpLCB7XG4gICAgICAgICAgbGFiZWxGZXRjaGVyOiB7XG4gICAgICAgICAgICBnZXRGb3JtYXR0ZWRMYWJlbDogZnVuY3Rpb24gKGlkeCwgc3RhdGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcE1vZGVsLmdldEZvcm1hdHRlZExhYmVsKGZ1bGxJbmRleF8xLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0VGV4dDogbmFtZV8xXG4gICAgICAgIH0pO1xuICAgICAgICBjaXJjbGUuZGlzYWJsZUxhYmVsQW5pbWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFsYWJlbE1vZGVsLmdldCgncG9zaXRpb24nKSkge1xuICAgICAgICAgIGNpcmNsZS5zZXRUZXh0Q29uZmlnKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYm90dG9tJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lvbkdyb3VwLm9uSG92ZXJTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICh0b1N0YXRlKSB7XG4gICAgICAgICAgc2V0U3RhdGVzRmxhZyhjaXJjbGUsIHRvU3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZ3JvdXAuYWRkKGNpcmNsZSk7XG4gICAgfSk7XG4gIH07XG4gIE1hcFZpZXcudHlwZSA9ICdtYXAnO1xuICByZXR1cm4gTWFwVmlldztcbn0oQ2hhcnRWaWV3KTtcbmV4cG9ydCBkZWZhdWx0IE1hcFZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IGNyZWF0ZVNlcmllc0RhdGFTaW1wbHkgZnJvbSAnLi4vaGVscGVyL2NyZWF0ZVNlcmllc0RhdGFTaW1wbHkuanMnO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcy5qcyc7XG5pbXBvcnQgZ2VvU291cmNlTWFuYWdlciBmcm9tICcuLi8uLi9jb29yZC9nZW8vZ2VvU291cmNlTWFuYWdlci5qcyc7XG5pbXBvcnQgeyBtYWtlU2VyaWVzRW5jb2RlRm9yTmFtZUJhc2VkIH0gZnJvbSAnLi4vLi4vZGF0YS9oZWxwZXIvc291cmNlSGVscGVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZVRvb2x0aXBNYXJrdXAgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvdG9vbHRpcC90b29sdGlwTWFya3VwLmpzJztcbmltcG9ydCB7IGNyZWF0ZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvc3ltYm9sLmpzJztcbnZhciBNYXBTZXJpZXMgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTWFwU2VyaWVzLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBNYXBTZXJpZXMoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IE1hcFNlcmllcy50eXBlO1xuICAgIC8vIE9ubHkgZmlyc3QgbWFwIHNlcmllcyBvZiBzYW1lIG1hcFR5cGUgd2lsbCBkcmF3TWFwLlxuICAgIF90aGlzLm5lZWRzRHJhd01hcCA9IGZhbHNlO1xuICAgIC8vIEdyb3VwIG9mIGFsbCBtYXAgc2VyaWVzIHdpdGggc2FtZSBtYXBUeXBlXG4gICAgX3RoaXMuc2VyaWVzR3JvdXAgPSBbXTtcbiAgICBfdGhpcy5nZXRUb29sdGlwUG9zaXRpb24gPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICBpZiAoZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG5hbWVfMSA9IHRoaXMuZ2V0RGF0YSgpLmdldE5hbWUoZGF0YUluZGV4KTtcbiAgICAgICAgdmFyIGdlbyA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IGdlby5nZXRSZWdpb24obmFtZV8xKTtcbiAgICAgICAgcmV0dXJuIHJlZ2lvbiAmJiBnZW8uZGF0YVRvUG9pbnQocmVnaW9uLmdldENlbnRlcigpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBNYXBTZXJpZXMucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIHZhciBkYXRhID0gY3JlYXRlU2VyaWVzRGF0YVNpbXBseSh0aGlzLCB7XG4gICAgICBjb29yZERpbWVuc2lvbnM6IFsndmFsdWUnXSxcbiAgICAgIGVuY29kZURlZmF1bHRlcjogenJVdGlsLmN1cnJ5KG1ha2VTZXJpZXNFbmNvZGVGb3JOYW1lQmFzZWQsIHRoaXMpXG4gICAgfSk7XG4gICAgdmFyIGRhdGFOYW1lSW5kZXhNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICAgIHZhciB0b0FwcGVuZEl0ZW1zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgbmFtZV8yID0gZGF0YS5nZXROYW1lKGkpO1xuICAgICAgZGF0YU5hbWVJbmRleE1hcC5zZXQobmFtZV8yLCBpKTtcbiAgICB9XG4gICAgdmFyIGdlb1NvdXJjZSA9IGdlb1NvdXJjZU1hbmFnZXIubG9hZCh0aGlzLmdldE1hcFR5cGUoKSwgdGhpcy5vcHRpb24ubmFtZU1hcCwgdGhpcy5vcHRpb24ubmFtZVByb3BlcnR5KTtcbiAgICB6clV0aWwuZWFjaChnZW9Tb3VyY2UucmVnaW9ucywgZnVuY3Rpb24gKHJlZ2lvbikge1xuICAgICAgdmFyIG5hbWUgPSByZWdpb24ubmFtZTtcbiAgICAgIHZhciBkYXRhTmFtZUlkeCA9IGRhdGFOYW1lSW5kZXhNYXAuZ2V0KG5hbWUpO1xuICAgICAgLy8gYXBwbHkgc3BlY2lmaWVkIGVjaGFydHMgc3R5bGUgaW4gR2VvSlNPTiBkYXRhXG4gICAgICB2YXIgc3BlY2lmaWVkR2VvSlNPTlJlZ2lvblN0eWxlID0gcmVnaW9uLnByb3BlcnRpZXMgJiYgcmVnaW9uLnByb3BlcnRpZXMuZWNoYXJ0c1N0eWxlO1xuICAgICAgdmFyIGRhdGFJdGVtO1xuICAgICAgaWYgKGRhdGFOYW1lSWR4ID09IG51bGwpIHtcbiAgICAgICAgZGF0YUl0ZW0gPSB7XG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgICAgICB0b0FwcGVuZEl0ZW1zLnB1c2goZGF0YUl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YUl0ZW0gPSBkYXRhLmdldFJhd0RhdGFJdGVtKGRhdGFOYW1lSWR4KTtcbiAgICAgIH1cbiAgICAgIHNwZWNpZmllZEdlb0pTT05SZWdpb25TdHlsZSAmJiB6clV0aWwubWVyZ2UoZGF0YUl0ZW0sIHNwZWNpZmllZEdlb0pTT05SZWdpb25TdHlsZSk7XG4gICAgfSk7XG4gICAgLy8gQ29tcGxldGUgZGF0YSB3aXRoIG1pc3NpbmcgcmVnaW9ucy4gVGhlIGNvbnNlcXVlbnQgcHJvY2Vzc2VzIChsaWtlIHZpc3VhbFxuICAgIC8vIG1hcCBhbmQgcmVuZGVyKSBjYW4gbm90IGJlIHBlcmZvcm1lZCB3aXRob3V0IGEgXCJmdWxsIGRhdGFcIi4gRm9yIGV4YW1wbGUsXG4gICAgLy8gZmluZCBgZGF0YUluZGV4YCBieSBuYW1lLlxuICAgIGRhdGEuYXBwZW5kRGF0YSh0b0FwcGVuZEl0ZW1zKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbiAgLyoqXHJcbiAgICogSWYgbm8gaG9zdCBnZW8gbW9kZWwsIHJldHVybiBudWxsLCB3aGljaCBtZWFucyB1c2luZyBhXHJcbiAgICogaW5uZXIgZXhjbHVzaXZlIGdlbyBtb2RlbC5cclxuICAgKi9cbiAgTWFwU2VyaWVzLnByb3RvdHlwZS5nZXRIb3N0R2VvTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdlb0luZGV4ID0gdGhpcy5vcHRpb24uZ2VvSW5kZXg7XG4gICAgcmV0dXJuIGdlb0luZGV4ICE9IG51bGwgPyB0aGlzLmVjTW9kZWwuZ2V0Q29tcG9uZW50KCdnZW8nLCBnZW9JbmRleCkgOiBudWxsO1xuICB9O1xuICBNYXBTZXJpZXMucHJvdG90eXBlLmdldE1hcFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmdldEhvc3RHZW9Nb2RlbCgpIHx8IHRoaXMpLm9wdGlvbi5tYXA7XG4gIH07XG4gIC8vIF9maWxsT3B0aW9uKG9wdGlvbiwgbWFwTmFtZSkge1xuICAvLyBTaGFsbG93IGNsb25lXG4gIC8vIG9wdGlvbiA9IHpyVXRpbC5leHRlbmQoe30sIG9wdGlvbik7XG4gIC8vIG9wdGlvbi5kYXRhID0gZ2VvQ3JlYXRvci5nZXRGaWxsZWRSZWdpb25zKG9wdGlvbi5kYXRhLCBtYXBOYW1lLCBvcHRpb24ubmFtZU1hcCk7XG4gIC8vIHJldHVybiBvcHRpb247XG4gIC8vIH1cbiAgTWFwU2VyaWVzLnByb3RvdHlwZS5nZXRSYXdWYWx1ZSA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAvLyBVc2UgdmFsdWUgc3RvcmVkIGluIGRhdGEgaW5zdGVhZCBiZWNhdXNlIGl0IGlzIGNhbGN1bGF0ZWQgZnJvbSBtdWx0aXBsZSBzZXJpZXNcbiAgICAvLyBGSVhNRSBQcm92aWRlIGFsbCB2YWx1ZSBvZiBtdWx0aXBsZSBzZXJpZXMgP1xuICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgcmV0dXJuIGRhdGEuZ2V0KGRhdGEubWFwRGltZW5zaW9uKCd2YWx1ZScpLCBkYXRhSW5kZXgpO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgbW9kZWwgb2YgcmVnaW9uXHJcbiAgICovXG4gIE1hcFNlcmllcy5wcm90b3R5cGUuZ2V0UmVnaW9uTW9kZWwgPSBmdW5jdGlvbiAocmVnaW9uTmFtZSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgcmV0dXJuIGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGEuaW5kZXhPZk5hbWUocmVnaW9uTmFtZSkpO1xuICB9O1xuICAvKipcclxuICAgKiBNYXAgdG9vbHRpcCBmb3JtYXR0ZXJcclxuICAgKi9cbiAgTWFwU2VyaWVzLnByb3RvdHlwZS5mb3JtYXRUb29sdGlwID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgbXVsdGlwbGVTZXJpZXMsIGRhdGFUeXBlKSB7XG4gICAgLy8gRklYTUUgb3JpZ25hbERhdGEgYW5kIGRhdGEgaXMgYSBiaXQgY29uZnVzaW5nXG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFJhd1ZhbHVlKGRhdGFJbmRleCk7XG4gICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4KTtcbiAgICB2YXIgc2VyaWVzR3JvdXAgPSB0aGlzLnNlcmllc0dyb3VwO1xuICAgIHZhciBzZXJpZXNOYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyaWVzR3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlckluZGV4ID0gc2VyaWVzR3JvdXBbaV0ub3JpZ2luYWxEYXRhLmluZGV4T2ZOYW1lKG5hbWUpO1xuICAgICAgdmFyIHZhbHVlRGltID0gZGF0YS5tYXBEaW1lbnNpb24oJ3ZhbHVlJyk7XG4gICAgICBpZiAoIWlzTmFOKHNlcmllc0dyb3VwW2ldLm9yaWdpbmFsRGF0YS5nZXQodmFsdWVEaW0sIG90aGVySW5kZXgpKSkge1xuICAgICAgICBzZXJpZXNOYW1lcy5wdXNoKHNlcmllc0dyb3VwW2ldLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVG9vbHRpcE1hcmt1cCgnc2VjdGlvbicsIHtcbiAgICAgIGhlYWRlcjogc2VyaWVzTmFtZXMuam9pbignLCAnKSxcbiAgICAgIG5vSGVhZGVyOiAhc2VyaWVzTmFtZXMubGVuZ3RoLFxuICAgICAgYmxvY2tzOiBbY3JlYXRlVG9vbHRpcE1hcmt1cCgnbmFtZVZhbHVlJywge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pXVxuICAgIH0pO1xuICB9O1xuICBNYXBTZXJpZXMucHJvdG90eXBlLnNldFpvb20gPSBmdW5jdGlvbiAoem9vbSkge1xuICAgIHRoaXMub3B0aW9uLnpvb20gPSB6b29tO1xuICB9O1xuICBNYXBTZXJpZXMucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uIChjZW50ZXIpIHtcbiAgICB0aGlzLm9wdGlvbi5jZW50ZXIgPSBjZW50ZXI7XG4gIH07XG4gIE1hcFNlcmllcy5wcm90b3R5cGUuZ2V0TGVnZW5kSWNvbiA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgaWNvblR5cGUgPSBvcHQuaWNvbiB8fCAncm91bmRSZWN0JztcbiAgICB2YXIgaWNvbiA9IGNyZWF0ZVN5bWJvbChpY29uVHlwZSwgMCwgMCwgb3B0Lml0ZW1XaWR0aCwgb3B0Lml0ZW1IZWlnaHQsIG9wdC5pdGVtU3R5bGUuZmlsbCk7XG4gICAgaWNvbi5zZXRTdHlsZShvcHQuaXRlbVN0eWxlKTtcbiAgICAvLyBNYXAgZG8gbm90IHVzZSBpdGVtU3R5bGUuYm9yZGVyV2lkdGggYXMgYm9yZGVyIHdpZHRoXG4gICAgaWNvbi5zdHlsZS5zdHJva2UgPSAnbm9uZSc7XG4gICAgLy8gTm8gcm90YXRpb24gYmVjYXVzZSBubyBzZXJpZXMgdmlzdWFsIHN5bWJvbCBmb3IgbWFwXG4gICAgaWYgKGljb25UeXBlLmluZGV4T2YoJ2VtcHR5JykgPiAtMSkge1xuICAgICAgaWNvbi5zdHlsZS5zdHJva2UgPSBpY29uLnN0eWxlLmZpbGw7XG4gICAgICBpY29uLnN0eWxlLmZpbGwgPSAnI2ZmZic7XG4gICAgICBpY29uLnN0eWxlLmxpbmVXaWR0aCA9IDI7XG4gICAgfVxuICAgIHJldHVybiBpY29uO1xuICB9O1xuICBNYXBTZXJpZXMudHlwZSA9ICdzZXJpZXMubWFwJztcbiAgTWFwU2VyaWVzLmRlcGVuZGVuY2llcyA9IFsnZ2VvJ107XG4gIE1hcFNlcmllcy5sYXlvdXRNb2RlID0gJ2JveCc7XG4gIE1hcFNlcmllcy5kZWZhdWx0T3B0aW9uID0ge1xuICAgIC8vIOS4gOe6p+WxguWPoFxuICAgIC8vIHpsZXZlbDogMCxcbiAgICAvLyDkuoznuqflsYLlj6BcbiAgICB6OiAyLFxuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdnZW8nLFxuICAgIC8vIG1hcCBzaG91bGQgYmUgZXhwbGljaXRseSBzcGVjaWZpZWQgc2luY2UgZWMzLlxuICAgIG1hcDogJycsXG4gICAgLy8gSWYgYGdlb0luZGV4YCBpcyBub3Qgc3BlY2lmaWVkLCBhIGV4Y2x1c2l2ZSBnZW8gd2lsbCBiZVxuICAgIC8vIGNyZWF0ZWQuIE90aGVyd2lzZSB1c2UgdGhlIHNwZWNpZmllZCBnZW8gY29tcG9uZW50LCBhbmRcbiAgICAvLyBgbWFwYCBhbmQgYG1hcFR5cGVgIGFyZSBpZ25vcmVkLlxuICAgIC8vIGdlb0luZGV4OiAwLFxuICAgIC8vICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0JyB8ICd4JScgfCB7bnVtYmVyfVxuICAgIGxlZnQ6ICdjZW50ZXInLFxuICAgIC8vICdjZW50ZXInIHwgJ3RvcCcgfCAnYm90dG9tJyB8ICd4JScgfCB7bnVtYmVyfVxuICAgIHRvcDogJ2NlbnRlcicsXG4gICAgLy8gcmlnaHRcbiAgICAvLyBib3R0b21cbiAgICAvLyB3aWR0aDpcbiAgICAvLyBoZWlnaHRcbiAgICAvLyBBc3BlY3QgaXMgd2lkdGggLyBoZWlnaHQuIEluaXRlZCB0byBiZSBnZW9Kc29uIGJib3ggYXNwZWN0XG4gICAgLy8gVGhpcyBwYXJhbWV0ZXIgaXMgdXNlZCBmb3Igc2NhbGUgdGhpcyBhc3BlY3RcbiAgICAvLyBEZWZhdWx0IHZhbHVlOlxuICAgIC8vIGZvciBnZW9TVkcgc291cmNlOiAxLFxuICAgIC8vIGZvciBnZW9KU09OIHNvdXJjZTogMC43NS5cbiAgICBhc3BlY3RTY2FsZTogbnVsbCxcbiAgICAvLyBMYXlvdXQgd2l0aCBjZW50ZXIgYW5kIHNpemVcbiAgICAvLyBJZiB5b3Ugd2FudCB0byBwdXQgbWFwIGluIGEgZml4ZWQgc2l6ZSBib3ggd2l0aCByaWdodCBhc3BlY3QgcmF0aW9cbiAgICAvLyBUaGlzIHR3byBwcm9wZXJ0aWVzIG1heSBiZSBtb3JlIGNvbnZlbmllbnQuXG4gICAgLy8gbGF5b3V0Q2VudGVyOiBbNTAlLCA1MCVdXG4gICAgLy8gbGF5b3V0U2l6ZTogMTAwXG4gICAgc2hvd0xlZ2VuZFN5bWJvbDogdHJ1ZSxcbiAgICAvLyBEZWZpbmUgbGVmdC10b3AsIHJpZ2h0LWJvdHRvbSBjb29yZHMgdG8gY29udHJvbCB2aWV3XG4gICAgLy8gRm9yIGV4YW1wbGUsIFsgWzE4MCwgOTBdLCBbLTE4MCwgLTkwXSBdLFxuICAgIC8vIGhpZ2hlciBwcmlvcml0eSB0aGFuIGNlbnRlciBhbmQgem9vbVxuICAgIGJvdW5kaW5nQ29vcmRzOiBudWxsLFxuICAgIC8vIERlZmF1bHQgb24gY2VudGVyIG9mIG1hcFxuICAgIGNlbnRlcjogbnVsbCxcbiAgICB6b29tOiAxLFxuICAgIHNjYWxlTGltaXQ6IG51bGwsXG4gICAgc2VsZWN0ZWRNb2RlOiB0cnVlLFxuICAgIGxhYmVsOiB7XG4gICAgICBzaG93OiBmYWxzZSxcbiAgICAgIGNvbG9yOiAnIzAwMCdcbiAgICB9LFxuICAgIC8vIHNjYWxlTGltaXQ6IG51bGwsXG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICBib3JkZXJXaWR0aDogMC41LFxuICAgICAgYm9yZGVyQ29sb3I6ICcjNDQ0JyxcbiAgICAgIGFyZWFDb2xvcjogJyNlZWUnXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgY29sb3I6ICdyZ2IoMTAwLDAsMCknXG4gICAgICB9LFxuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGFyZWFDb2xvcjogJ3JnYmEoMjU1LDIxNSwwLDAuOCknXG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3Q6IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIGNvbG9yOiAncmdiKDEwMCwwLDApJ1xuICAgICAgfSxcbiAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICBjb2xvcjogJ3JnYmEoMjU1LDIxNSwwLDAuOCknXG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lUHJvcGVydHk6ICduYW1lJ1xuICB9O1xuICByZXR1cm4gTWFwU2VyaWVzO1xufShTZXJpZXNNb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBNYXBTZXJpZXM7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbi8vIEZJWE1FIOWFrOeUqO+8n1xuZnVuY3Rpb24gZGF0YVN0YXRpc3RpY3MoZGF0YXMsIHN0YXRpc3RpY1R5cGUpIHtcbiAgdmFyIGRhdGFOYW1lTWFwID0ge307XG4gIHpyVXRpbC5lYWNoKGRhdGFzLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRhdGEuZWFjaChkYXRhLm1hcERpbWVuc2lvbigndmFsdWUnKSwgZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICAgIC8vIEFkZCBwcmVmaXggdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlLlxuICAgICAgdmFyIG1hcEtleSA9ICdlYy0nICsgZGF0YS5nZXROYW1lKGlkeCk7XG4gICAgICBkYXRhTmFtZU1hcFttYXBLZXldID0gZGF0YU5hbWVNYXBbbWFwS2V5XSB8fCBbXTtcbiAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIGRhdGFOYW1lTWFwW21hcEtleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZGF0YXNbMF0ubWFwKGRhdGFzWzBdLm1hcERpbWVuc2lvbigndmFsdWUnKSwgZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICB2YXIgbWFwS2V5ID0gJ2VjLScgKyBkYXRhc1swXS5nZXROYW1lKGlkeCk7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG4gICAgdmFyIGxlbiA9IGRhdGFOYW1lTWFwW21hcEtleV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgZGF0YU5hbWVNYXBbbWFwS2V5XVtpXSk7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFOYW1lTWFwW21hcEtleV1baV0pO1xuICAgICAgc3VtICs9IGRhdGFOYW1lTWFwW21hcEtleV1baV07XG4gICAgfVxuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKHN0YXRpc3RpY1R5cGUgPT09ICdtaW4nKSB7XG4gICAgICByZXN1bHQgPSBtaW47XG4gICAgfSBlbHNlIGlmIChzdGF0aXN0aWNUeXBlID09PSAnbWF4Jykge1xuICAgICAgcmVzdWx0ID0gbWF4O1xuICAgIH0gZWxzZSBpZiAoc3RhdGlzdGljVHlwZSA9PT0gJ2F2ZXJhZ2UnKSB7XG4gICAgICByZXN1bHQgPSBzdW0gLyBsZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHN1bTtcbiAgICB9XG4gICAgcmV0dXJuIGxlbiA9PT0gMCA/IE5hTiA6IHJlc3VsdDtcbiAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXBEYXRhU3RhdGlzdGljKGVjTW9kZWwpIHtcbiAgdmFyIHNlcmllc0dyb3VwcyA9IHt9O1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ21hcCcsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBob3N0R2VvTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRIb3N0R2VvTW9kZWwoKTtcbiAgICB2YXIga2V5ID0gaG9zdEdlb01vZGVsID8gJ28nICsgaG9zdEdlb01vZGVsLmlkIDogJ2knICsgc2VyaWVzTW9kZWwuZ2V0TWFwVHlwZSgpO1xuICAgIChzZXJpZXNHcm91cHNba2V5XSA9IHNlcmllc0dyb3Vwc1trZXldIHx8IFtdKS5wdXNoKHNlcmllc01vZGVsKTtcbiAgfSk7XG4gIHpyVXRpbC5lYWNoKHNlcmllc0dyb3VwcywgZnVuY3Rpb24gKHNlcmllc0xpc3QsIGtleSkge1xuICAgIHZhciBkYXRhID0gZGF0YVN0YXRpc3RpY3MoenJVdGlsLm1hcChzZXJpZXNMaXN0LCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHJldHVybiBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgfSksIHNlcmllc0xpc3RbMF0uZ2V0KCdtYXBWYWx1ZUNhbGN1bGF0aW9uJykpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyaWVzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgc2VyaWVzTGlzdFtpXS5vcmlnaW5hbERhdGEgPSBzZXJpZXNMaXN0W2ldLmdldERhdGEoKTtcbiAgICB9XG4gICAgLy8gRklYTUUgUHV0IHdoZXJlP1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyaWVzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgc2VyaWVzTGlzdFtpXS5zZXJpZXNHcm91cCA9IHNlcmllc0xpc3Q7XG4gICAgICBzZXJpZXNMaXN0W2ldLm5lZWRzRHJhd01hcCA9IGkgPT09IDAgJiYgIXNlcmllc0xpc3RbaV0uZ2V0SG9zdEdlb01vZGVsKCk7XG4gICAgICBzZXJpZXNMaXN0W2ldLnNldERhdGEoZGF0YS5jbG9uZVNoYWxsb3coKSk7XG4gICAgICBzZXJpZXNMaXN0W2ldLm1haW5TZXJpZXMgPSBzZXJpZXNMaXN0WzBdO1xuICAgIH1cbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1hcFN5bWJvbExheW91dChlY01vZGVsKSB7XG4gIHZhciBwcm9jZXNzZWRNYXBUeXBlID0ge307XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgnbWFwJywgZnVuY3Rpb24gKG1hcFNlcmllcykge1xuICAgIHZhciBtYXBUeXBlID0gbWFwU2VyaWVzLmdldE1hcFR5cGUoKTtcbiAgICBpZiAobWFwU2VyaWVzLmdldEhvc3RHZW9Nb2RlbCgpIHx8IHByb2Nlc3NlZE1hcFR5cGVbbWFwVHlwZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG1hcFN5bWJvbE9mZnNldHMgPSB7fTtcbiAgICB6clV0aWwuZWFjaChtYXBTZXJpZXMuc2VyaWVzR3JvdXAsIGZ1bmN0aW9uIChzdWJNYXBTZXJpZXMpIHtcbiAgICAgIHZhciBnZW8gPSBzdWJNYXBTZXJpZXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgIHZhciBkYXRhID0gc3ViTWFwU2VyaWVzLm9yaWdpbmFsRGF0YTtcbiAgICAgIGlmIChzdWJNYXBTZXJpZXMuZ2V0KCdzaG93TGVnZW5kU3ltYm9sJykgJiYgZWNNb2RlbC5nZXRDb21wb25lbnQoJ2xlZ2VuZCcpKSB7XG4gICAgICAgIGRhdGEuZWFjaChkYXRhLm1hcERpbWVuc2lvbigndmFsdWUnKSwgZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IGRhdGEuZ2V0TmFtZShpZHgpO1xuICAgICAgICAgIHZhciByZWdpb24gPSBnZW8uZ2V0UmVnaW9uKG5hbWUpO1xuICAgICAgICAgIC8vIElmIGlucHV0IHNlcmllcy5kYXRhIGlzIFsxMSwgMjIsICctJy9udWxsL3VuZGVmaW5lZCwgNDRdLFxuICAgICAgICAgIC8vIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggTmFOOiBbMTEsIDIyLCBOYU4sIDQ0XSBhbmQgTmFOIHdpbGxcbiAgICAgICAgICAvLyBub3QgYmUgZHJhd24uIFNvIGhlcmUgbXVzdCB2YWxpZGF0ZSBpZiB2YWx1ZSBpcyBOYU4uXG4gICAgICAgICAgaWYgKCFyZWdpb24gfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvZmZzZXQgPSBtYXBTeW1ib2xPZmZzZXRzW25hbWVdIHx8IDA7XG4gICAgICAgICAgdmFyIHBvaW50ID0gZ2VvLmRhdGFUb1BvaW50KHJlZ2lvbi5nZXRDZW50ZXIoKSk7XG4gICAgICAgICAgbWFwU3ltYm9sT2Zmc2V0c1tuYW1lXSA9IG9mZnNldCArIDE7XG4gICAgICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwge1xuICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gU2hvdyBsYWJlbCBvZiB0aG9zZSByZWdpb24gbm90IGhhcyBsZWdlbmRJY29uICh3aGljaCBpcyBvZmZzZXQgMClcbiAgICB2YXIgZGF0YSA9IG1hcFNlcmllcy5nZXREYXRhKCk7XG4gICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGlkeCk7XG4gICAgICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCkgfHwge307XG4gICAgICBsYXlvdXQuc2hvd0xhYmVsID0gIW1hcFN5bWJvbE9mZnNldHNbbmFtZV07XG4gICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBsYXlvdXQpO1xuICAgIH0pO1xuICAgIHByb2Nlc3NlZE1hcFR5cGVbbWFwVHlwZV0gPSB0cnVlO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IHVzZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbi5qcyc7XG5pbXBvcnQgTWFwVmlldyBmcm9tICcuL01hcFZpZXcuanMnO1xuaW1wb3J0IE1hcFNlcmllcyBmcm9tICcuL01hcFNlcmllcy5qcyc7XG5pbXBvcnQgbWFwRGF0YVN0YXRpc3RpYyBmcm9tICcuL21hcERhdGFTdGF0aXN0aWMuanMnO1xuaW1wb3J0IG1hcFN5bWJvbExheW91dCBmcm9tICcuL21hcFN5bWJvbExheW91dC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVMZWdhY3lEYXRhU2VsZWN0QWN0aW9uIH0gZnJvbSAnLi4vLi4vbGVnYWN5L2RhdGFTZWxlY3RBY3Rpb24uanMnO1xuaW1wb3J0IHsgaW5zdGFsbCBhcyBpbnN0YWxsR2VvIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50L2dlby9pbnN0YWxsLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICB1c2UoaW5zdGFsbEdlbyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhNYXBWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU2VyaWVzTW9kZWwoTWFwU2VyaWVzKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KG1hcFN5bWJvbExheW91dCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByb2Nlc3NvcihyZWdpc3RlcnMuUFJJT1JJVFkuUFJPQ0VTU09SLlNUQVRJU1RJQywgbWFwRGF0YVN0YXRpc3RpYyk7XG4gIGNyZWF0ZUxlZ2FjeURhdGFTZWxlY3RBY3Rpb24oJ21hcCcsIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbik7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4270\n")},4391:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install_install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/extension.js\nvar extension = __webpack_require__(3087);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n;// ./node_modules/echarts/lib/chart/radar/radarLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction radarLayout(ecModel) {\n  ecModel.eachSeriesByType('radar', function (seriesModel) {\n    var data = seriesModel.getData();\n    var points = [];\n    var coordSys = seriesModel.coordinateSystem;\n    if (!coordSys) {\n      return;\n    }\n    var axes = coordSys.getIndicatorAxes();\n    util.each(axes, function (axis, axisIndex) {\n      data.each(data.mapDimension(axes[axisIndex].dim), function (val, dataIndex) {\n        points[dataIndex] = points[dataIndex] || [];\n        var point = coordSys.dataToPoint(val, axisIndex);\n        points[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);\n      });\n    });\n    // Close polygon\n    data.each(function (idx) {\n      // TODO\n      // Is it appropriate to connect to the next data when some data is missing?\n      // Or, should trade it like `connectNull` in line chart?\n      var firstPoint = util.find(points[idx], function (point) {\n        return isValidPoint(point);\n      }) || getValueMissingPoint(coordSys);\n      // Copy the first actual point to the end of the array\n      points[idx].push(firstPoint.slice());\n      data.setItemLayout(idx, points[idx]);\n    });\n  });\n}\nfunction isValidPoint(point) {\n  return !isNaN(point[0]) && !isNaN(point[1]);\n}\nfunction getValueMissingPoint(coordSys) {\n  // It is error-prone to input [NaN, NaN] into polygon, polygon.\n  // (probably cause problem when refreshing or animating)\n  return [coordSys.cx, coordSys.cy];\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/processor/dataFilter.js\nvar dataFilter = __webpack_require__(78587);\n;// ./node_modules/echarts/lib/chart/radar/backwardCompat.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// @ts-nocheck\n// Backward compat for radar chart in 2\n\nfunction radarBackwardCompat(option) {\n  var polarOptArr = option.polar;\n  if (polarOptArr) {\n    if (!util.isArray(polarOptArr)) {\n      polarOptArr = [polarOptArr];\n    }\n    var polarNotRadar_1 = [];\n    util.each(polarOptArr, function (polarOpt, idx) {\n      if (polarOpt.indicator) {\n        if (polarOpt.type && !polarOpt.shape) {\n          polarOpt.shape = polarOpt.type;\n        }\n        option.radar = option.radar || [];\n        if (!util.isArray(option.radar)) {\n          option.radar = [option.radar];\n        }\n        option.radar.push(polarOpt);\n      } else {\n        polarNotRadar_1.push(polarOpt);\n      }\n    });\n    option.polar = polarNotRadar_1;\n  }\n  util.each(option.series, function (seriesOpt) {\n    if (seriesOpt && seriesOpt.type === 'radar' && seriesOpt.polarIndex) {\n      seriesOpt.radarIndex = seriesOpt.polarIndex;\n    }\n  });\n}\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polygon.js\nvar Polygon = __webpack_require__(52505);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polyline.js\nvar Polyline = __webpack_require__(39195);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/symbol.js\nvar symbol = __webpack_require__(62103);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Image.js\nvar Image = __webpack_require__(90540);\n;// ./node_modules/echarts/lib/chart/radar/RadarView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\nvar RadarView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(RadarView, _super);\n  function RadarView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = RadarView.type;\n    return _this;\n  }\n  RadarView.prototype.render = function (seriesModel, ecModel, api) {\n    var polar = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    function createSymbol(data, idx) {\n      var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n      if (symbolType === 'none') {\n        return;\n      }\n      var symbolSize = symbol/* normalizeSymbolSize */.xU(data.getItemVisual(idx, 'symbolSize'));\n      var symbolPath = symbol/* createSymbol */.v5(symbolType, -1, -1, 2, 2);\n      var symbolRotate = data.getItemVisual(idx, 'symbolRotate') || 0;\n      symbolPath.attr({\n        style: {\n          strokeNoScale: true\n        },\n        z2: 100,\n        scaleX: symbolSize[0] / 2,\n        scaleY: symbolSize[1] / 2,\n        rotation: symbolRotate * Math.PI / 180 || 0\n      });\n      return symbolPath;\n    }\n    function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {\n      // Simply rerender all\n      symbolGroup.removeAll();\n      for (var i = 0; i < newPoints.length - 1; i++) {\n        var symbolPath = createSymbol(data, idx);\n        if (symbolPath) {\n          symbolPath.__dimIdx = i;\n          if (oldPoints[i]) {\n            symbolPath.setPosition(oldPoints[i]);\n            graphic[isInit ? 'initProps' : 'updateProps'](symbolPath, {\n              x: newPoints[i][0],\n              y: newPoints[i][1]\n            }, seriesModel, idx);\n          } else {\n            symbolPath.setPosition(newPoints[i]);\n          }\n          symbolGroup.add(symbolPath);\n        }\n      }\n    }\n    function getInitialPoints(points) {\n      return util.map(points, function (pt) {\n        return [polar.cx, polar.cy];\n      });\n    }\n    data.diff(oldData).add(function (idx) {\n      var points = data.getItemLayout(idx);\n      if (!points) {\n        return;\n      }\n      var polygon = new Polygon/* default */.A();\n      var polyline = new Polyline/* default */.A();\n      var target = {\n        shape: {\n          points: points\n        }\n      };\n      polygon.shape.points = getInitialPoints(points);\n      polyline.shape.points = getInitialPoints(points);\n      basicTransition/* initProps */.LW(polygon, target, seriesModel, idx);\n      basicTransition/* initProps */.LW(polyline, target, seriesModel, idx);\n      var itemGroup = new Group/* default */.A();\n      var symbolGroup = new Group/* default */.A();\n      itemGroup.add(polyline);\n      itemGroup.add(polygon);\n      itemGroup.add(symbolGroup);\n      updateSymbols(polyline.shape.points, points, symbolGroup, data, idx, true);\n      data.setItemGraphicEl(idx, itemGroup);\n    }).update(function (newIdx, oldIdx) {\n      var itemGroup = oldData.getItemGraphicEl(oldIdx);\n      var polyline = itemGroup.childAt(0);\n      var polygon = itemGroup.childAt(1);\n      var symbolGroup = itemGroup.childAt(2);\n      var target = {\n        shape: {\n          points: data.getItemLayout(newIdx)\n        }\n      };\n      if (!target.shape.points) {\n        return;\n      }\n      updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);\n      (0,basicTransition/* saveOldStyle */.ap)(polygon);\n      (0,basicTransition/* saveOldStyle */.ap)(polyline);\n      basicTransition/* updateProps */.oi(polyline, target, seriesModel);\n      basicTransition/* updateProps */.oi(polygon, target, seriesModel);\n      data.setItemGraphicEl(newIdx, itemGroup);\n    }).remove(function (idx) {\n      group.remove(oldData.getItemGraphicEl(idx));\n    }).execute();\n    data.eachItemGraphicEl(function (itemGroup, idx) {\n      var itemModel = data.getItemModel(idx);\n      var polyline = itemGroup.childAt(0);\n      var polygon = itemGroup.childAt(1);\n      var symbolGroup = itemGroup.childAt(2);\n      // Radar uses the visual encoded from itemStyle.\n      var itemStyle = data.getItemVisual(idx, 'style');\n      var color = itemStyle.fill;\n      group.add(itemGroup);\n      polyline.useStyle(util.defaults(itemModel.getModel('lineStyle').getLineStyle(), {\n        fill: 'none',\n        stroke: color\n      }));\n      (0,states/* setStatesStylesFromModel */.Mx)(polyline, itemModel, 'lineStyle');\n      (0,states/* setStatesStylesFromModel */.Mx)(polygon, itemModel, 'areaStyle');\n      var areaStyleModel = itemModel.getModel('areaStyle');\n      var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();\n      polygon.ignore = polygonIgnore;\n      util.each(['emphasis', 'select', 'blur'], function (stateName) {\n        var stateModel = itemModel.getModel([stateName, 'areaStyle']);\n        var stateIgnore = stateModel.isEmpty() && stateModel.parentModel.isEmpty();\n        // Won't be ignore if normal state is not ignore.\n        polygon.ensureState(stateName).ignore = stateIgnore && polygonIgnore;\n      });\n      polygon.useStyle(util.defaults(areaStyleModel.getAreaStyle(), {\n        fill: color,\n        opacity: 0.7,\n        decal: itemStyle.decal\n      }));\n      var emphasisModel = itemModel.getModel('emphasis');\n      var itemHoverStyle = emphasisModel.getModel('itemStyle').getItemStyle();\n      symbolGroup.eachChild(function (symbolPath) {\n        if (symbolPath instanceof Image/* default */.Ay) {\n          var pathStyle = symbolPath.style;\n          symbolPath.useStyle(util.extend({\n            // TODO other properties like x, y ?\n            image: pathStyle.image,\n            x: pathStyle.x,\n            y: pathStyle.y,\n            width: pathStyle.width,\n            height: pathStyle.height\n          }, itemStyle));\n        } else {\n          symbolPath.useStyle(itemStyle);\n          symbolPath.setColor(color);\n          symbolPath.style.strokeNoScale = true;\n        }\n        var pathEmphasisState = symbolPath.ensureState('emphasis');\n        pathEmphasisState.style = util.clone(itemHoverStyle);\n        var defaultText = data.getStore().get(data.getDimensionIndex(symbolPath.__dimIdx), idx);\n        (defaultText == null || isNaN(defaultText)) && (defaultText = '');\n        (0,labelStyle/* setLabelStyle */.qM)(symbolPath, (0,labelStyle/* getLabelStatesModels */.lx)(itemModel), {\n          labelFetcher: data.hostModel,\n          labelDataIndex: idx,\n          labelDimIndex: symbolPath.__dimIdx,\n          defaultText: defaultText,\n          inheritColor: color,\n          defaultOpacity: itemStyle.opacity\n        });\n      });\n      (0,states/* toggleHoverEmphasis */.Lm)(itemGroup, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n    });\n    this._data = data;\n  };\n  RadarView.prototype.remove = function () {\n    this.group.removeAll();\n    this._data = null;\n  };\n  RadarView.type = 'radar';\n  return RadarView;\n}(Chart/* default */.A);\n/* harmony default export */ const radar_RadarView = (RadarView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createSeriesDataSimply.js\nvar createSeriesDataSimply = __webpack_require__(72731);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/LegendVisualProvider.js\nvar LegendVisualProvider = __webpack_require__(58239);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js\nvar tooltipMarkup = __webpack_require__(3961);\n;// ./node_modules/echarts/lib/chart/radar/RadarSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\nvar RadarSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(RadarSeriesModel, _super);\n  function RadarSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = RadarSeriesModel.type;\n    _this.hasSymbolVisual = true;\n    return _this;\n  }\n  // Overwrite\n  RadarSeriesModel.prototype.init = function (option) {\n    _super.prototype.init.apply(this, arguments);\n    // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n    this.legendVisualProvider = new LegendVisualProvider/* default */.A(util.bind(this.getData, this), util.bind(this.getRawData, this));\n  };\n  RadarSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    return (0,createSeriesDataSimply/* default */.A)(this, {\n      generateCoord: 'indicator_',\n      generateCoordCount: Infinity\n    });\n  };\n  RadarSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n    var data = this.getData();\n    var coordSys = this.coordinateSystem;\n    var indicatorAxes = coordSys.getIndicatorAxes();\n    var name = this.getData().getName(dataIndex);\n    var nameToDisplay = name === '' ? this.name : name;\n    var markerColor = (0,tooltipMarkup/* retrieveVisualColorForTooltipMarker */.aw)(this, dataIndex);\n    return (0,tooltipMarkup/* createTooltipMarkup */.Qx)('section', {\n      header: nameToDisplay,\n      sortBlocks: true,\n      blocks: util.map(indicatorAxes, function (axis) {\n        var val = data.get(data.mapDimension(axis.dim), dataIndex);\n        return (0,tooltipMarkup/* createTooltipMarkup */.Qx)('nameValue', {\n          markerType: 'subItem',\n          markerColor: markerColor,\n          name: axis.name,\n          value: val,\n          sortParam: val\n        });\n      })\n    });\n  };\n  RadarSeriesModel.prototype.getTooltipPosition = function (dataIndex) {\n    if (dataIndex != null) {\n      var data_1 = this.getData();\n      var coordSys = this.coordinateSystem;\n      var values = data_1.getValues(util.map(coordSys.dimensions, function (dim) {\n        return data_1.mapDimension(dim);\n      }), dataIndex);\n      for (var i = 0, len = values.length; i < len; i++) {\n        if (!isNaN(values[i])) {\n          var indicatorAxes = coordSys.getIndicatorAxes();\n          return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values[i]), i);\n        }\n      }\n    }\n  };\n  RadarSeriesModel.type = 'series.radar';\n  RadarSeriesModel.dependencies = ['radar'];\n  RadarSeriesModel.defaultOption = {\n    // zlevel: 0,\n    z: 2,\n    colorBy: 'data',\n    coordinateSystem: 'radar',\n    legendHoverLink: true,\n    radarIndex: 0,\n    lineStyle: {\n      width: 2,\n      type: 'solid',\n      join: 'round'\n    },\n    label: {\n      position: 'top'\n    },\n    // areaStyle: {\n    // },\n    // itemStyle: {}\n    symbolSize: 8\n    // symbolRotate: null\n  };\n  return RadarSeriesModel;\n}(Series/* default */.A);\n/* harmony default export */ const RadarSeries = (RadarSeriesModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/radar/install.js + 1 modules\nvar install = __webpack_require__(18909);\n;// ./node_modules/echarts/lib/chart/radar/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nfunction install_install(registers) {\n  (0,extension/* use */.Y)(install/* install */.a);\n  registers.registerChartView(radar_RadarView);\n  registers.registerSeriesModel(RadarSeries);\n  registers.registerLayout(radarLayout);\n  registers.registerProcessor((0,dataFilter/* default */.A)('radar'));\n  registers.registerPreprocessor(radarBackwardCompat);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM5MS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9yYWRhci9yYWRhckxheW91dC5qcz81OTM5Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9yYWRhci9iYWNrd2FyZENvbXBhdC5qcz8xZGU3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9yYWRhci9SYWRhclZpZXcuanM/ZDlmNCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvcmFkYXIvUmFkYXJTZXJpZXMuanM/OTBjMiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvcmFkYXIvaW5zdGFsbC5qcz8zYTAxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByYWRhckxheW91dChlY01vZGVsKSB7XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgncmFkYXInLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICBpZiAoIWNvb3JkU3lzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBheGVzID0gY29vcmRTeXMuZ2V0SW5kaWNhdG9yQXhlcygpO1xuICAgIHpyVXRpbC5lYWNoKGF4ZXMsIGZ1bmN0aW9uIChheGlzLCBheGlzSW5kZXgpIHtcbiAgICAgIGRhdGEuZWFjaChkYXRhLm1hcERpbWVuc2lvbihheGVzW2F4aXNJbmRleF0uZGltKSwgZnVuY3Rpb24gKHZhbCwgZGF0YUluZGV4KSB7XG4gICAgICAgIHBvaW50c1tkYXRhSW5kZXhdID0gcG9pbnRzW2RhdGFJbmRleF0gfHwgW107XG4gICAgICAgIHZhciBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KHZhbCwgYXhpc0luZGV4KTtcbiAgICAgICAgcG9pbnRzW2RhdGFJbmRleF1bYXhpc0luZGV4XSA9IGlzVmFsaWRQb2ludChwb2ludCkgPyBwb2ludCA6IGdldFZhbHVlTWlzc2luZ1BvaW50KGNvb3JkU3lzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIENsb3NlIHBvbHlnb25cbiAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgLy8gVE9ET1xuICAgICAgLy8gSXMgaXQgYXBwcm9wcmlhdGUgdG8gY29ubmVjdCB0byB0aGUgbmV4dCBkYXRhIHdoZW4gc29tZSBkYXRhIGlzIG1pc3Npbmc/XG4gICAgICAvLyBPciwgc2hvdWxkIHRyYWRlIGl0IGxpa2UgYGNvbm5lY3ROdWxsYCBpbiBsaW5lIGNoYXJ0P1xuICAgICAgdmFyIGZpcnN0UG9pbnQgPSB6clV0aWwuZmluZChwb2ludHNbaWR4XSwgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkUG9pbnQocG9pbnQpO1xuICAgICAgfSkgfHwgZ2V0VmFsdWVNaXNzaW5nUG9pbnQoY29vcmRTeXMpO1xuICAgICAgLy8gQ29weSB0aGUgZmlyc3QgYWN0dWFsIHBvaW50IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5XG4gICAgICBwb2ludHNbaWR4XS5wdXNoKGZpcnN0UG9pbnQuc2xpY2UoKSk7XG4gICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBwb2ludHNbaWR4XSk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNWYWxpZFBvaW50KHBvaW50KSB7XG4gIHJldHVybiAhaXNOYU4ocG9pbnRbMF0pICYmICFpc05hTihwb2ludFsxXSk7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZU1pc3NpbmdQb2ludChjb29yZFN5cykge1xuICAvLyBJdCBpcyBlcnJvci1wcm9uZSB0byBpbnB1dCBbTmFOLCBOYU5dIGludG8gcG9seWdvbiwgcG9seWdvbi5cbiAgLy8gKHByb2JhYmx5IGNhdXNlIHByb2JsZW0gd2hlbiByZWZyZXNoaW5nIG9yIGFuaW1hdGluZylcbiAgcmV0dXJuIFtjb29yZFN5cy5jeCwgY29vcmRTeXMuY3ldO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLy8gQHRzLW5vY2hlY2tcbi8vIEJhY2t3YXJkIGNvbXBhdCBmb3IgcmFkYXIgY2hhcnQgaW4gMlxuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByYWRhckJhY2t3YXJkQ29tcGF0KG9wdGlvbikge1xuICB2YXIgcG9sYXJPcHRBcnIgPSBvcHRpb24ucG9sYXI7XG4gIGlmIChwb2xhck9wdEFycikge1xuICAgIGlmICghenJVdGlsLmlzQXJyYXkocG9sYXJPcHRBcnIpKSB7XG4gICAgICBwb2xhck9wdEFyciA9IFtwb2xhck9wdEFycl07XG4gICAgfVxuICAgIHZhciBwb2xhck5vdFJhZGFyXzEgPSBbXTtcbiAgICB6clV0aWwuZWFjaChwb2xhck9wdEFyciwgZnVuY3Rpb24gKHBvbGFyT3B0LCBpZHgpIHtcbiAgICAgIGlmIChwb2xhck9wdC5pbmRpY2F0b3IpIHtcbiAgICAgICAgaWYgKHBvbGFyT3B0LnR5cGUgJiYgIXBvbGFyT3B0LnNoYXBlKSB7XG4gICAgICAgICAgcG9sYXJPcHQuc2hhcGUgPSBwb2xhck9wdC50eXBlO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbi5yYWRhciA9IG9wdGlvbi5yYWRhciB8fCBbXTtcbiAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShvcHRpb24ucmFkYXIpKSB7XG4gICAgICAgICAgb3B0aW9uLnJhZGFyID0gW29wdGlvbi5yYWRhcl07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9uLnJhZGFyLnB1c2gocG9sYXJPcHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9sYXJOb3RSYWRhcl8xLnB1c2gocG9sYXJPcHQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG9wdGlvbi5wb2xhciA9IHBvbGFyTm90UmFkYXJfMTtcbiAgfVxuICB6clV0aWwuZWFjaChvcHRpb24uc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzT3B0KSB7XG4gICAgaWYgKHNlcmllc09wdCAmJiBzZXJpZXNPcHQudHlwZSA9PT0gJ3JhZGFyJyAmJiBzZXJpZXNPcHQucG9sYXJJbmRleCkge1xuICAgICAgc2VyaWVzT3B0LnJhZGFySW5kZXggPSBzZXJpZXNPcHQucG9sYXJJbmRleDtcbiAgICB9XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwsIHRvZ2dsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIHN5bWJvbFV0aWwgZnJvbSAnLi4vLi4vdXRpbC9zeW1ib2wuanMnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0LmpzJztcbmltcG9ydCB7IHNldExhYmVsU3R5bGUsIGdldExhYmVsU3RhdGVzTW9kZWxzIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG5pbXBvcnQgWlJJbWFnZSBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzJztcbmltcG9ydCB7IHNhdmVPbGRTdHlsZSB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi9iYXNpY1RyYW5zaXRpb24uanMnO1xudmFyIFJhZGFyVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhSYWRhclZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFJhZGFyVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gUmFkYXJWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFJhZGFyVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgcG9sYXIgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVN5bWJvbChkYXRhLCBpZHgpIHtcbiAgICAgIHZhciBzeW1ib2xUeXBlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbCcpIHx8ICdjaXJjbGUnO1xuICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc3ltYm9sU2l6ZSA9IHN5bWJvbFV0aWwubm9ybWFsaXplU3ltYm9sU2l6ZShkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScpKTtcbiAgICAgIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgLTEsIC0xLCAyLCAyKTtcbiAgICAgIHZhciBzeW1ib2xSb3RhdGUgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sUm90YXRlJykgfHwgMDtcbiAgICAgIHN5bWJvbFBhdGguYXR0cih7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgc3Ryb2tlTm9TY2FsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB6MjogMTAwLFxuICAgICAgICBzY2FsZVg6IHN5bWJvbFNpemVbMF0gLyAyLFxuICAgICAgICBzY2FsZVk6IHN5bWJvbFNpemVbMV0gLyAyLFxuICAgICAgICByb3RhdGlvbjogc3ltYm9sUm90YXRlICogTWF0aC5QSSAvIDE4MCB8fCAwXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzeW1ib2xQYXRoO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTeW1ib2xzKG9sZFBvaW50cywgbmV3UG9pbnRzLCBzeW1ib2xHcm91cCwgZGF0YSwgaWR4LCBpc0luaXQpIHtcbiAgICAgIC8vIFNpbXBseSByZXJlbmRlciBhbGxcbiAgICAgIHN5bWJvbEdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdQb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gY3JlYXRlU3ltYm9sKGRhdGEsIGlkeCk7XG4gICAgICAgIGlmIChzeW1ib2xQYXRoKSB7XG4gICAgICAgICAgc3ltYm9sUGF0aC5fX2RpbUlkeCA9IGk7XG4gICAgICAgICAgaWYgKG9sZFBvaW50c1tpXSkge1xuICAgICAgICAgICAgc3ltYm9sUGF0aC5zZXRQb3NpdGlvbihvbGRQb2ludHNbaV0pO1xuICAgICAgICAgICAgZ3JhcGhpY1tpc0luaXQgPyAnaW5pdFByb3BzJyA6ICd1cGRhdGVQcm9wcyddKHN5bWJvbFBhdGgsIHtcbiAgICAgICAgICAgICAgeDogbmV3UG9pbnRzW2ldWzBdLFxuICAgICAgICAgICAgICB5OiBuZXdQb2ludHNbaV1bMV1cbiAgICAgICAgICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzeW1ib2xQYXRoLnNldFBvc2l0aW9uKG5ld1BvaW50c1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN5bWJvbEdyb3VwLmFkZChzeW1ib2xQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsUG9pbnRzKHBvaW50cykge1xuICAgICAgcmV0dXJuIHpyVXRpbC5tYXAocG9pbnRzLCBmdW5jdGlvbiAocHQpIHtcbiAgICAgICAgcmV0dXJuIFtwb2xhci5jeCwgcG9sYXIuY3ldO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGEuZGlmZihvbGREYXRhKS5hZGQoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIHBvaW50cyA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBvbHlnb24gPSBuZXcgZ3JhcGhpYy5Qb2x5Z29uKCk7XG4gICAgICB2YXIgcG9seWxpbmUgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSgpO1xuICAgICAgdmFyIHRhcmdldCA9IHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcG9seWdvbi5zaGFwZS5wb2ludHMgPSBnZXRJbml0aWFsUG9pbnRzKHBvaW50cyk7XG4gICAgICBwb2x5bGluZS5zaGFwZS5wb2ludHMgPSBnZXRJbml0aWFsUG9pbnRzKHBvaW50cyk7XG4gICAgICBncmFwaGljLmluaXRQcm9wcyhwb2x5Z29uLCB0YXJnZXQsIHNlcmllc01vZGVsLCBpZHgpO1xuICAgICAgZ3JhcGhpYy5pbml0UHJvcHMocG9seWxpbmUsIHRhcmdldCwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgICB2YXIgaXRlbUdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICAgIHZhciBzeW1ib2xHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgICBpdGVtR3JvdXAuYWRkKHBvbHlsaW5lKTtcbiAgICAgIGl0ZW1Hcm91cC5hZGQocG9seWdvbik7XG4gICAgICBpdGVtR3JvdXAuYWRkKHN5bWJvbEdyb3VwKTtcbiAgICAgIHVwZGF0ZVN5bWJvbHMocG9seWxpbmUuc2hhcGUucG9pbnRzLCBwb2ludHMsIHN5bWJvbEdyb3VwLCBkYXRhLCBpZHgsIHRydWUpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgaXRlbUdyb3VwKTtcbiAgICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICB2YXIgaXRlbUdyb3VwID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICB2YXIgcG9seWxpbmUgPSBpdGVtR3JvdXAuY2hpbGRBdCgwKTtcbiAgICAgIHZhciBwb2x5Z29uID0gaXRlbUdyb3VwLmNoaWxkQXQoMSk7XG4gICAgICB2YXIgc3ltYm9sR3JvdXAgPSBpdGVtR3JvdXAuY2hpbGRBdCgyKTtcbiAgICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgcG9pbnRzOiBkYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKCF0YXJnZXQuc2hhcGUucG9pbnRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZVN5bWJvbHMocG9seWxpbmUuc2hhcGUucG9pbnRzLCB0YXJnZXQuc2hhcGUucG9pbnRzLCBzeW1ib2xHcm91cCwgZGF0YSwgbmV3SWR4LCBmYWxzZSk7XG4gICAgICBzYXZlT2xkU3R5bGUocG9seWdvbik7XG4gICAgICBzYXZlT2xkU3R5bGUocG9seWxpbmUpO1xuICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2x5bGluZSwgdGFyZ2V0LCBzZXJpZXNNb2RlbCk7XG4gICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvbHlnb24sIHRhcmdldCwgc2VyaWVzTW9kZWwpO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgaXRlbUdyb3VwKTtcbiAgICB9KS5yZW1vdmUoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgZ3JvdXAucmVtb3ZlKG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpKTtcbiAgICB9KS5leGVjdXRlKCk7XG4gICAgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoaXRlbUdyb3VwLCBpZHgpIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgdmFyIHBvbHlsaW5lID0gaXRlbUdyb3VwLmNoaWxkQXQoMCk7XG4gICAgICB2YXIgcG9seWdvbiA9IGl0ZW1Hcm91cC5jaGlsZEF0KDEpO1xuICAgICAgdmFyIHN5bWJvbEdyb3VwID0gaXRlbUdyb3VwLmNoaWxkQXQoMik7XG4gICAgICAvLyBSYWRhciB1c2VzIHRoZSB2aXN1YWwgZW5jb2RlZCBmcm9tIGl0ZW1TdHlsZS5cbiAgICAgIHZhciBpdGVtU3R5bGUgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3R5bGUnKTtcbiAgICAgIHZhciBjb2xvciA9IGl0ZW1TdHlsZS5maWxsO1xuICAgICAgZ3JvdXAuYWRkKGl0ZW1Hcm91cCk7XG4gICAgICBwb2x5bGluZS51c2VTdHlsZSh6clV0aWwuZGVmYXVsdHMoaXRlbU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKSwge1xuICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgIHN0cm9rZTogY29sb3JcbiAgICAgIH0pKTtcbiAgICAgIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChwb2x5bGluZSwgaXRlbU1vZGVsLCAnbGluZVN0eWxlJyk7XG4gICAgICBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwocG9seWdvbiwgaXRlbU1vZGVsLCAnYXJlYVN0eWxlJyk7XG4gICAgICB2YXIgYXJlYVN0eWxlTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZScpO1xuICAgICAgdmFyIHBvbHlnb25JZ25vcmUgPSBhcmVhU3R5bGVNb2RlbC5pc0VtcHR5KCkgJiYgYXJlYVN0eWxlTW9kZWwucGFyZW50TW9kZWwuaXNFbXB0eSgpO1xuICAgICAgcG9seWdvbi5pZ25vcmUgPSBwb2x5Z29uSWdub3JlO1xuICAgICAgenJVdGlsLmVhY2goWydlbXBoYXNpcycsICdzZWxlY3QnLCAnYmx1ciddLCBmdW5jdGlvbiAoc3RhdGVOYW1lKSB7XG4gICAgICAgIHZhciBzdGF0ZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKFtzdGF0ZU5hbWUsICdhcmVhU3R5bGUnXSk7XG4gICAgICAgIHZhciBzdGF0ZUlnbm9yZSA9IHN0YXRlTW9kZWwuaXNFbXB0eSgpICYmIHN0YXRlTW9kZWwucGFyZW50TW9kZWwuaXNFbXB0eSgpO1xuICAgICAgICAvLyBXb24ndCBiZSBpZ25vcmUgaWYgbm9ybWFsIHN0YXRlIGlzIG5vdCBpZ25vcmUuXG4gICAgICAgIHBvbHlnb24uZW5zdXJlU3RhdGUoc3RhdGVOYW1lKS5pZ25vcmUgPSBzdGF0ZUlnbm9yZSAmJiBwb2x5Z29uSWdub3JlO1xuICAgICAgfSk7XG4gICAgICBwb2x5Z29uLnVzZVN0eWxlKHpyVXRpbC5kZWZhdWx0cyhhcmVhU3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKSwge1xuICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgb3BhY2l0eTogMC43LFxuICAgICAgICBkZWNhbDogaXRlbVN0eWxlLmRlY2FsXG4gICAgICB9KSk7XG4gICAgICB2YXIgZW1waGFzaXNNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKTtcbiAgICAgIHZhciBpdGVtSG92ZXJTdHlsZSA9IGVtcGhhc2lzTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgc3ltYm9sR3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChzeW1ib2xQYXRoKSB7XG4gICAgICAgIGlmIChzeW1ib2xQYXRoIGluc3RhbmNlb2YgWlJJbWFnZSkge1xuICAgICAgICAgIHZhciBwYXRoU3R5bGUgPSBzeW1ib2xQYXRoLnN0eWxlO1xuICAgICAgICAgIHN5bWJvbFBhdGgudXNlU3R5bGUoenJVdGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAvLyBUT0RPIG90aGVyIHByb3BlcnRpZXMgbGlrZSB4LCB5ID9cbiAgICAgICAgICAgIGltYWdlOiBwYXRoU3R5bGUuaW1hZ2UsXG4gICAgICAgICAgICB4OiBwYXRoU3R5bGUueCxcbiAgICAgICAgICAgIHk6IHBhdGhTdHlsZS55LFxuICAgICAgICAgICAgd2lkdGg6IHBhdGhTdHlsZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogcGF0aFN0eWxlLmhlaWdodFxuICAgICAgICAgIH0sIGl0ZW1TdHlsZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN5bWJvbFBhdGgudXNlU3R5bGUoaXRlbVN0eWxlKTtcbiAgICAgICAgICBzeW1ib2xQYXRoLnNldENvbG9yKGNvbG9yKTtcbiAgICAgICAgICBzeW1ib2xQYXRoLnN0eWxlLnN0cm9rZU5vU2NhbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRoRW1waGFzaXNTdGF0ZSA9IHN5bWJvbFBhdGguZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJyk7XG4gICAgICAgIHBhdGhFbXBoYXNpc1N0YXRlLnN0eWxlID0genJVdGlsLmNsb25lKGl0ZW1Ib3ZlclN0eWxlKTtcbiAgICAgICAgdmFyIGRlZmF1bHRUZXh0ID0gZGF0YS5nZXRTdG9yZSgpLmdldChkYXRhLmdldERpbWVuc2lvbkluZGV4KHN5bWJvbFBhdGguX19kaW1JZHgpLCBpZHgpO1xuICAgICAgICAoZGVmYXVsdFRleHQgPT0gbnVsbCB8fCBpc05hTihkZWZhdWx0VGV4dCkpICYmIChkZWZhdWx0VGV4dCA9ICcnKTtcbiAgICAgICAgc2V0TGFiZWxTdHlsZShzeW1ib2xQYXRoLCBnZXRMYWJlbFN0YXRlc01vZGVscyhpdGVtTW9kZWwpLCB7XG4gICAgICAgICAgbGFiZWxGZXRjaGVyOiBkYXRhLmhvc3RNb2RlbCxcbiAgICAgICAgICBsYWJlbERhdGFJbmRleDogaWR4LFxuICAgICAgICAgIGxhYmVsRGltSW5kZXg6IHN5bWJvbFBhdGguX19kaW1JZHgsXG4gICAgICAgICAgZGVmYXVsdFRleHQ6IGRlZmF1bHRUZXh0LFxuICAgICAgICAgIGluaGVyaXRDb2xvcjogY29sb3IsXG4gICAgICAgICAgZGVmYXVsdE9wYWNpdHk6IGl0ZW1TdHlsZS5vcGFjaXR5XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0b2dnbGVIb3ZlckVtcGhhc2lzKGl0ZW1Hcm91cCwgZW1waGFzaXNNb2RlbC5nZXQoJ2ZvY3VzJyksIGVtcGhhc2lzTW9kZWwuZ2V0KCdibHVyU2NvcGUnKSwgZW1waGFzaXNNb2RlbC5nZXQoJ2Rpc2FibGVkJykpO1xuICAgIH0pO1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9O1xuICBSYWRhclZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICB9O1xuICBSYWRhclZpZXcudHlwZSA9ICdyYWRhcic7XG4gIHJldHVybiBSYWRhclZpZXc7XG59KENoYXJ0Vmlldyk7XG5leHBvcnQgZGVmYXVsdCBSYWRhclZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMuanMnO1xuaW1wb3J0IGNyZWF0ZVNlcmllc0RhdGFTaW1wbHkgZnJvbSAnLi4vaGVscGVyL2NyZWF0ZVNlcmllc0RhdGFTaW1wbHkuanMnO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgTGVnZW5kVmlzdWFsUHJvdmlkZXIgZnJvbSAnLi4vLi4vdmlzdWFsL0xlZ2VuZFZpc3VhbFByb3ZpZGVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZVRvb2x0aXBNYXJrdXAsIHJldHJpZXZlVmlzdWFsQ29sb3JGb3JUb29sdGlwTWFya2VyIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50L3Rvb2x0aXAvdG9vbHRpcE1hcmt1cC5qcyc7XG52YXIgUmFkYXJTZXJpZXNNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhSYWRhclNlcmllc01vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBSYWRhclNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBSYWRhclNlcmllc01vZGVsLnR5cGU7XG4gICAgX3RoaXMuaGFzU3ltYm9sVmlzdWFsID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLy8gT3ZlcndyaXRlXG4gIFJhZGFyU2VyaWVzTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gRW5hYmxlIGxlZ2VuZCBzZWxlY3Rpb24gZm9yIGVhY2ggZGF0YSBpdGVtXG4gICAgLy8gVXNlIGEgZnVuY3Rpb24gaW5zdGVhZCBvZiBkaXJlY3QgYWNjZXNzIGJlY2F1c2UgZGF0YSByZWZlcmVuY2UgbWF5IGNoYW5nZWRcbiAgICB0aGlzLmxlZ2VuZFZpc3VhbFByb3ZpZGVyID0gbmV3IExlZ2VuZFZpc3VhbFByb3ZpZGVyKHpyVXRpbC5iaW5kKHRoaXMuZ2V0RGF0YSwgdGhpcyksIHpyVXRpbC5iaW5kKHRoaXMuZ2V0UmF3RGF0YSwgdGhpcykpO1xuICB9O1xuICBSYWRhclNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICByZXR1cm4gY3JlYXRlU2VyaWVzRGF0YVNpbXBseSh0aGlzLCB7XG4gICAgICBnZW5lcmF0ZUNvb3JkOiAnaW5kaWNhdG9yXycsXG4gICAgICBnZW5lcmF0ZUNvb3JkQ291bnQ6IEluZmluaXR5XG4gICAgfSk7XG4gIH07XG4gIFJhZGFyU2VyaWVzTW9kZWwucHJvdG90eXBlLmZvcm1hdFRvb2x0aXAgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBtdWx0aXBsZVNlcmllcywgZGF0YVR5cGUpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIHZhciBjb29yZFN5cyA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgaW5kaWNhdG9yQXhlcyA9IGNvb3JkU3lzLmdldEluZGljYXRvckF4ZXMoKTtcbiAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0RGF0YSgpLmdldE5hbWUoZGF0YUluZGV4KTtcbiAgICB2YXIgbmFtZVRvRGlzcGxheSA9IG5hbWUgPT09ICcnID8gdGhpcy5uYW1lIDogbmFtZTtcbiAgICB2YXIgbWFya2VyQ29sb3IgPSByZXRyaWV2ZVZpc3VhbENvbG9yRm9yVG9vbHRpcE1hcmtlcih0aGlzLCBkYXRhSW5kZXgpO1xuICAgIHJldHVybiBjcmVhdGVUb29sdGlwTWFya3VwKCdzZWN0aW9uJywge1xuICAgICAgaGVhZGVyOiBuYW1lVG9EaXNwbGF5LFxuICAgICAgc29ydEJsb2NrczogdHJ1ZSxcbiAgICAgIGJsb2NrczogenJVdGlsLm1hcChpbmRpY2F0b3JBeGVzLCBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICB2YXIgdmFsID0gZGF0YS5nZXQoZGF0YS5tYXBEaW1lbnNpb24oYXhpcy5kaW0pLCBkYXRhSW5kZXgpO1xuICAgICAgICByZXR1cm4gY3JlYXRlVG9vbHRpcE1hcmt1cCgnbmFtZVZhbHVlJywge1xuICAgICAgICAgIG1hcmtlclR5cGU6ICdzdWJJdGVtJyxcbiAgICAgICAgICBtYXJrZXJDb2xvcjogbWFya2VyQ29sb3IsXG4gICAgICAgICAgbmFtZTogYXhpcy5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgICAgc29ydFBhcmFtOiB2YWxcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgIH0pO1xuICB9O1xuICBSYWRhclNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRUb29sdGlwUG9zaXRpb24gPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgaWYgKGRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgICB2YXIgZGF0YV8xID0gdGhpcy5nZXREYXRhKCk7XG4gICAgICB2YXIgY29vcmRTeXMgPSB0aGlzLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICB2YXIgdmFsdWVzID0gZGF0YV8xLmdldFZhbHVlcyh6clV0aWwubWFwKGNvb3JkU3lzLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfMS5tYXBEaW1lbnNpb24oZGltKTtcbiAgICAgIH0pLCBkYXRhSW5kZXgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIWlzTmFOKHZhbHVlc1tpXSkpIHtcbiAgICAgICAgICB2YXIgaW5kaWNhdG9yQXhlcyA9IGNvb3JkU3lzLmdldEluZGljYXRvckF4ZXMoKTtcbiAgICAgICAgICByZXR1cm4gY29vcmRTeXMuY29vcmRUb1BvaW50KGluZGljYXRvckF4ZXNbaV0uZGF0YVRvQ29vcmQodmFsdWVzW2ldKSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFJhZGFyU2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMucmFkYXInO1xuICBSYWRhclNlcmllc01vZGVsLmRlcGVuZGVuY2llcyA9IFsncmFkYXInXTtcbiAgUmFkYXJTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIC8vIHpsZXZlbDogMCxcbiAgICB6OiAyLFxuICAgIGNvbG9yQnk6ICdkYXRhJyxcbiAgICBjb29yZGluYXRlU3lzdGVtOiAncmFkYXInLFxuICAgIGxlZ2VuZEhvdmVyTGluazogdHJ1ZSxcbiAgICByYWRhckluZGV4OiAwLFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgd2lkdGg6IDIsXG4gICAgICB0eXBlOiAnc29saWQnLFxuICAgICAgam9pbjogJ3JvdW5kJ1xuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgIHBvc2l0aW9uOiAndG9wJ1xuICAgIH0sXG4gICAgLy8gYXJlYVN0eWxlOiB7XG4gICAgLy8gfSxcbiAgICAvLyBpdGVtU3R5bGU6IHt9XG4gICAgc3ltYm9sU2l6ZTogOFxuICAgIC8vIHN5bWJvbFJvdGF0ZTogbnVsbFxuICB9O1xuICByZXR1cm4gUmFkYXJTZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuZXhwb3J0IGRlZmF1bHQgUmFkYXJTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IHVzZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbi5qcyc7XG5pbXBvcnQgcmFkYXJMYXlvdXQgZnJvbSAnLi4vcmFkYXIvcmFkYXJMYXlvdXQuanMnO1xuaW1wb3J0IGRhdGFGaWx0ZXIgZnJvbSAnLi4vLi4vcHJvY2Vzc29yL2RhdGFGaWx0ZXIuanMnO1xuaW1wb3J0IGJhY2t3YXJkQ29tcGF0IGZyb20gJy4uL3JhZGFyL2JhY2t3YXJkQ29tcGF0LmpzJztcbmltcG9ydCBSYWRhclZpZXcgZnJvbSAnLi9SYWRhclZpZXcuanMnO1xuaW1wb3J0IFJhZGFyU2VyaWVzTW9kZWwgZnJvbSAnLi9SYWRhclNlcmllcy5qcyc7XG5pbXBvcnQgeyBpbnN0YWxsIGFzIGluc3RhbGxSYWRhckNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudC9yYWRhci9pbnN0YWxsLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICB1c2UoaW5zdGFsbFJhZGFyQ29tcG9uZW50KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ2hhcnRWaWV3KFJhZGFyVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclNlcmllc01vZGVsKFJhZGFyU2VyaWVzTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQocmFkYXJMYXlvdXQpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJQcm9jZXNzb3IoZGF0YUZpbHRlcigncmFkYXInKSk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByZXByb2Nlc3NvcihiYWNrd2FyZENvbXBhdCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4391\n")},31966:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install_install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/extension.js\nvar extension = __webpack_require__(3087);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polyline.js\nvar Polyline = __webpack_require__(39195);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n;// ./node_modules/echarts/lib/chart/parallel/ParallelView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar DEFAULT_SMOOTH = 0.3;\nvar ParallelView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ParallelView, _super);\n  function ParallelView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ParallelView.type;\n    _this._dataGroup = new Group/* default */.A();\n    _this._initialized = false;\n    return _this;\n  }\n  ParallelView.prototype.init = function () {\n    this.group.add(this._dataGroup);\n  };\n  /**\r\n   * @override\r\n   */\n  ParallelView.prototype.render = function (seriesModel, ecModel, api, payload) {\n    // Clear previously rendered progressive elements.\n    this._progressiveEls = null;\n    var dataGroup = this._dataGroup;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coordSys = seriesModel.coordinateSystem;\n    var dimensions = coordSys.dimensions;\n    var seriesScope = makeSeriesScope(seriesModel);\n    data.diff(oldData).add(add).update(update).remove(remove).execute();\n    function add(newDataIndex) {\n      var line = addEl(data, dataGroup, newDataIndex, dimensions, coordSys);\n      updateElCommon(line, data, newDataIndex, seriesScope);\n    }\n    function update(newDataIndex, oldDataIndex) {\n      var line = oldData.getItemGraphicEl(oldDataIndex);\n      var points = createLinePoints(data, newDataIndex, dimensions, coordSys);\n      data.setItemGraphicEl(newDataIndex, line);\n      basicTransition/* updateProps */.oi(line, {\n        shape: {\n          points: points\n        }\n      }, seriesModel, newDataIndex);\n      (0,basicTransition/* saveOldStyle */.ap)(line);\n      updateElCommon(line, data, newDataIndex, seriesScope);\n    }\n    function remove(oldDataIndex) {\n      var line = oldData.getItemGraphicEl(oldDataIndex);\n      dataGroup.remove(line);\n    }\n    // First create\n    if (!this._initialized) {\n      this._initialized = true;\n      var clipPath = createGridClipShape(coordSys, seriesModel, function () {\n        // Callback will be invoked immediately if there is no animation\n        setTimeout(function () {\n          dataGroup.removeClipPath();\n        });\n      });\n      dataGroup.setClipPath(clipPath);\n    }\n    this._data = data;\n  };\n  ParallelView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {\n    this._initialized = true;\n    this._data = null;\n    this._dataGroup.removeAll();\n  };\n  ParallelView.prototype.incrementalRender = function (taskParams, seriesModel, ecModel) {\n    var data = seriesModel.getData();\n    var coordSys = seriesModel.coordinateSystem;\n    var dimensions = coordSys.dimensions;\n    var seriesScope = makeSeriesScope(seriesModel);\n    var progressiveEls = this._progressiveEls = [];\n    for (var dataIndex = taskParams.start; dataIndex < taskParams.end; dataIndex++) {\n      var line = addEl(data, this._dataGroup, dataIndex, dimensions, coordSys);\n      line.incremental = true;\n      updateElCommon(line, data, dataIndex, seriesScope);\n      progressiveEls.push(line);\n    }\n  };\n  ParallelView.prototype.remove = function () {\n    this._dataGroup && this._dataGroup.removeAll();\n    this._data = null;\n  };\n  ParallelView.type = 'parallel';\n  return ParallelView;\n}(Chart/* default */.A);\nfunction createGridClipShape(coordSys, seriesModel, cb) {\n  var parallelModel = coordSys.model;\n  var rect = coordSys.getRect();\n  var rectEl = new Rect/* default */.A({\n    shape: {\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    }\n  });\n  var dim = parallelModel.get('layout') === 'horizontal' ? 'width' : 'height';\n  rectEl.setShape(dim, 0);\n  basicTransition/* initProps */.LW(rectEl, {\n    shape: {\n      width: rect.width,\n      height: rect.height\n    }\n  }, seriesModel, cb);\n  return rectEl;\n}\nfunction createLinePoints(data, dataIndex, dimensions, coordSys) {\n  var points = [];\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimName = dimensions[i];\n    var value = data.get(data.mapDimension(dimName), dataIndex);\n    if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {\n      points.push(coordSys.dataToPoint(value, dimName));\n    }\n  }\n  return points;\n}\nfunction addEl(data, dataGroup, dataIndex, dimensions, coordSys) {\n  var points = createLinePoints(data, dataIndex, dimensions, coordSys);\n  var line = new Polyline/* default */.A({\n    shape: {\n      points: points\n    },\n    // silent: true,\n    z2: 10\n  });\n  dataGroup.add(line);\n  data.setItemGraphicEl(dataIndex, line);\n  return line;\n}\nfunction makeSeriesScope(seriesModel) {\n  var smooth = seriesModel.get('smooth', true);\n  smooth === true && (smooth = DEFAULT_SMOOTH);\n  smooth = (0,number/* numericToNumber */.Sm)(smooth);\n  (0,util.eqNaN)(smooth) && (smooth = 0);\n  return {\n    smooth: smooth\n  };\n}\nfunction updateElCommon(el, data, dataIndex, seriesScope) {\n  el.useStyle(data.getItemVisual(dataIndex, 'style'));\n  el.style.fill = null;\n  el.setShape('smooth', seriesScope.smooth);\n  var itemModel = data.getItemModel(dataIndex);\n  var emphasisModel = itemModel.getModel('emphasis');\n  (0,states/* setStatesStylesFromModel */.Mx)(el, itemModel, 'lineStyle');\n  (0,states/* toggleHoverEmphasis */.Lm)(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n}\n// function simpleDiff(oldData, newData, dimensions) {\n//     let oldLen;\n//     if (!oldData\n//         || !oldData.__plProgressive\n//         || (oldLen = oldData.count()) !== newData.count()\n//     ) {\n//         return true;\n//     }\n//     let dimLen = dimensions.length;\n//     for (let i = 0; i < oldLen; i++) {\n//         for (let j = 0; j < dimLen; j++) {\n//             if (oldData.get(dimensions[j], i) !== newData.get(dimensions[j], i)) {\n//                 return true;\n//             }\n//         }\n//     }\n//     return false;\n// }\n// FIXME put in common util?\nfunction isEmptyValue(val, axisType) {\n  return axisType === 'category' ? val == null : val == null || isNaN(val); // axisType === 'value'\n}\n/* harmony default export */ const parallel_ParallelView = (ParallelView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createSeriesData.js\nvar createSeriesData = __webpack_require__(13637);\n;// ./node_modules/echarts/lib/chart/parallel/ParallelSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar ParallelSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ParallelSeriesModel, _super);\n  function ParallelSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ParallelSeriesModel.type;\n    _this.visualStyleAccessPath = 'lineStyle';\n    _this.visualDrawType = 'stroke';\n    return _this;\n  }\n  ParallelSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    return (0,createSeriesData/* default */.A)(null, this, {\n      useEncodeDefaulter: (0,util.bind)(makeDefaultEncode, null, this)\n    });\n  };\n  /**\r\n   * User can get data raw indices on 'axisAreaSelected' event received.\r\n   *\r\n   * @return Raw indices\r\n   */\n  ParallelSeriesModel.prototype.getRawIndicesByActiveState = function (activeState) {\n    var coordSys = this.coordinateSystem;\n    var data = this.getData();\n    var indices = [];\n    coordSys.eachActiveState(data, function (theActiveState, dataIndex) {\n      if (activeState === theActiveState) {\n        indices.push(data.getRawIndex(dataIndex));\n      }\n    });\n    return indices;\n  };\n  ParallelSeriesModel.type = 'series.parallel';\n  ParallelSeriesModel.dependencies = ['parallel'];\n  ParallelSeriesModel.defaultOption = {\n    // zlevel: 0,\n    z: 2,\n    coordinateSystem: 'parallel',\n    parallelIndex: 0,\n    label: {\n      show: false\n    },\n    inactiveOpacity: 0.05,\n    activeOpacity: 1,\n    lineStyle: {\n      width: 1,\n      opacity: 0.45,\n      type: 'solid'\n    },\n    emphasis: {\n      label: {\n        show: false\n      }\n    },\n    progressive: 500,\n    smooth: false,\n    animationEasing: 'linear'\n  };\n  return ParallelSeriesModel;\n}(Series/* default */.A);\nfunction makeDefaultEncode(seriesModel) {\n  // The mapping of parallelAxis dimension to data dimension can\n  // be specified in parallelAxis.option.dim. For example, if\n  // parallelAxis.option.dim is 'dim3', it mapping to the third\n  // dimension of data. But `data.encode` has higher priority.\n  // Moreover, parallelModel.dimension should not be regarded as data\n  // dimensions. Consider dimensions = ['dim4', 'dim2', 'dim6'];\n  var parallelModel = seriesModel.ecModel.getComponent('parallel', seriesModel.get('parallelIndex'));\n  if (!parallelModel) {\n    return;\n  }\n  var encodeDefine = {};\n  (0,util.each)(parallelModel.dimensions, function (axisDim) {\n    var dataDimIndex = convertDimNameToNumber(axisDim);\n    encodeDefine[axisDim] = dataDimIndex;\n  });\n  return encodeDefine;\n}\nfunction convertDimNameToNumber(dimName) {\n  return +dimName.replace('dim', '');\n}\n/* harmony default export */ const ParallelSeries = (ParallelSeriesModel);\n;// ./node_modules/echarts/lib/chart/parallel/parallelVisual.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar opacityAccessPath = ['lineStyle', 'opacity'];\nvar parallelVisual = {\n  seriesType: 'parallel',\n  reset: function (seriesModel, ecModel) {\n    var coordSys = seriesModel.coordinateSystem;\n    var opacityMap = {\n      normal: seriesModel.get(['lineStyle', 'opacity']),\n      active: seriesModel.get('activeOpacity'),\n      inactive: seriesModel.get('inactiveOpacity')\n    };\n    return {\n      progress: function (params, data) {\n        coordSys.eachActiveState(data, function (activeState, dataIndex) {\n          var opacity = opacityMap[activeState];\n          if (activeState === 'normal' && data.hasItemOption) {\n            var itemOpacity = data.getItemModel(dataIndex).get(opacityAccessPath, true);\n            itemOpacity != null && (opacity = itemOpacity);\n          }\n          var existsStyle = data.ensureUniqueItemVisual(dataIndex, 'style');\n          existsStyle.opacity = opacity;\n        }, params.start, params.end);\n      }\n    };\n  }\n};\n/* harmony default export */ const parallel_parallelVisual = (parallelVisual);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/parallel/install.js + 1 modules\nvar install = __webpack_require__(46105);\n;// ./node_modules/echarts/lib/chart/parallel/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nfunction install_install(registers) {\n  (0,extension/* use */.Y)(install/* install */.a);\n  registers.registerChartView(parallel_ParallelView);\n  registers.registerSeriesModel(ParallelSeries);\n  registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, parallel_parallelVisual);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE5NjYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9wYXJhbGxlbC9QYXJhbGxlbFZpZXcuanM/OTU2NyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvcGFyYWxsZWwvUGFyYWxsZWxTZXJpZXMuanM/MWNmOSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvcGFyYWxsZWwvcGFyYWxsZWxWaXN1YWwuanM/OGE3NSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvcGFyYWxsZWwvaW5zdGFsbC5qcz8xZDE2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwsIHRvZ2dsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQuanMnO1xuaW1wb3J0IHsgbnVtZXJpY1RvTnVtYmVyIH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IHsgZXFOYU4gfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgc2F2ZU9sZFN0eWxlIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL2Jhc2ljVHJhbnNpdGlvbi5qcyc7XG52YXIgREVGQVVMVF9TTU9PVEggPSAwLjM7XG52YXIgUGFyYWxsZWxWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFBhcmFsbGVsVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gUGFyYWxsZWxWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBQYXJhbGxlbFZpZXcudHlwZTtcbiAgICBfdGhpcy5fZGF0YUdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICBfdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgUGFyYWxsZWxWaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2RhdGFHcm91cCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBQYXJhbGxlbFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgLy8gQ2xlYXIgcHJldmlvdXNseSByZW5kZXJlZCBwcm9ncmVzc2l2ZSBlbGVtZW50cy5cbiAgICB0aGlzLl9wcm9ncmVzc2l2ZUVscyA9IG51bGw7XG4gICAgdmFyIGRhdGFHcm91cCA9IHRoaXMuX2RhdGFHcm91cDtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgZGltZW5zaW9ucyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7XG4gICAgdmFyIHNlcmllc1Njb3BlID0gbWFrZVNlcmllc1Njb3BlKHNlcmllc01vZGVsKTtcbiAgICBkYXRhLmRpZmYob2xkRGF0YSkuYWRkKGFkZCkudXBkYXRlKHVwZGF0ZSkucmVtb3ZlKHJlbW92ZSkuZXhlY3V0ZSgpO1xuICAgIGZ1bmN0aW9uIGFkZChuZXdEYXRhSW5kZXgpIHtcbiAgICAgIHZhciBsaW5lID0gYWRkRWwoZGF0YSwgZGF0YUdyb3VwLCBuZXdEYXRhSW5kZXgsIGRpbWVuc2lvbnMsIGNvb3JkU3lzKTtcbiAgICAgIHVwZGF0ZUVsQ29tbW9uKGxpbmUsIGRhdGEsIG5ld0RhdGFJbmRleCwgc2VyaWVzU2NvcGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGUobmV3RGF0YUluZGV4LCBvbGREYXRhSW5kZXgpIHtcbiAgICAgIHZhciBsaW5lID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZERhdGFJbmRleCk7XG4gICAgICB2YXIgcG9pbnRzID0gY3JlYXRlTGluZVBvaW50cyhkYXRhLCBuZXdEYXRhSW5kZXgsIGRpbWVuc2lvbnMsIGNvb3JkU3lzKTtcbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdEYXRhSW5kZXgsIGxpbmUpO1xuICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhsaW5lLCB7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgfVxuICAgICAgfSwgc2VyaWVzTW9kZWwsIG5ld0RhdGFJbmRleCk7XG4gICAgICBzYXZlT2xkU3R5bGUobGluZSk7XG4gICAgICB1cGRhdGVFbENvbW1vbihsaW5lLCBkYXRhLCBuZXdEYXRhSW5kZXgsIHNlcmllc1Njb3BlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlKG9sZERhdGFJbmRleCkge1xuICAgICAgdmFyIGxpbmUgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkRGF0YUluZGV4KTtcbiAgICAgIGRhdGFHcm91cC5yZW1vdmUobGluZSk7XG4gICAgfVxuICAgIC8vIEZpcnN0IGNyZWF0ZVxuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHZhciBjbGlwUGF0aCA9IGNyZWF0ZUdyaWRDbGlwU2hhcGUoY29vcmRTeXMsIHNlcmllc01vZGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCBpbW1lZGlhdGVseSBpZiB0aGVyZSBpcyBubyBhbmltYXRpb25cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGF0YUdyb3VwLnJlbW92ZUNsaXBQYXRoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBkYXRhR3JvdXAuc2V0Q2xpcFBhdGgoY2xpcFBhdGgpO1xuICAgIH1cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfTtcbiAgUGFyYWxsZWxWaWV3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFByZXBhcmVSZW5kZXIgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICB0aGlzLl9kYXRhR3JvdXAucmVtb3ZlQWxsKCk7XG4gIH07XG4gIFBhcmFsbGVsVmlldy5wcm90b3R5cGUuaW5jcmVtZW50YWxSZW5kZXIgPSBmdW5jdGlvbiAodGFza1BhcmFtcywgc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBkaW1lbnNpb25zID0gY29vcmRTeXMuZGltZW5zaW9ucztcbiAgICB2YXIgc2VyaWVzU2NvcGUgPSBtYWtlU2VyaWVzU2NvcGUoc2VyaWVzTW9kZWwpO1xuICAgIHZhciBwcm9ncmVzc2l2ZUVscyA9IHRoaXMuX3Byb2dyZXNzaXZlRWxzID0gW107XG4gICAgZm9yICh2YXIgZGF0YUluZGV4ID0gdGFza1BhcmFtcy5zdGFydDsgZGF0YUluZGV4IDwgdGFza1BhcmFtcy5lbmQ7IGRhdGFJbmRleCsrKSB7XG4gICAgICB2YXIgbGluZSA9IGFkZEVsKGRhdGEsIHRoaXMuX2RhdGFHcm91cCwgZGF0YUluZGV4LCBkaW1lbnNpb25zLCBjb29yZFN5cyk7XG4gICAgICBsaW5lLmluY3JlbWVudGFsID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZUVsQ29tbW9uKGxpbmUsIGRhdGEsIGRhdGFJbmRleCwgc2VyaWVzU2NvcGUpO1xuICAgICAgcHJvZ3Jlc3NpdmVFbHMucHVzaChsaW5lKTtcbiAgICB9XG4gIH07XG4gIFBhcmFsbGVsVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2RhdGFHcm91cCAmJiB0aGlzLl9kYXRhR3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gIH07XG4gIFBhcmFsbGVsVmlldy50eXBlID0gJ3BhcmFsbGVsJztcbiAgcmV0dXJuIFBhcmFsbGVsVmlldztcbn0oQ2hhcnRWaWV3KTtcbmZ1bmN0aW9uIGNyZWF0ZUdyaWRDbGlwU2hhcGUoY29vcmRTeXMsIHNlcmllc01vZGVsLCBjYikge1xuICB2YXIgcGFyYWxsZWxNb2RlbCA9IGNvb3JkU3lzLm1vZGVsO1xuICB2YXIgcmVjdCA9IGNvb3JkU3lzLmdldFJlY3QoKTtcbiAgdmFyIHJlY3RFbCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgIHNoYXBlOiB7XG4gICAgICB4OiByZWN0LngsXG4gICAgICB5OiByZWN0LnksXG4gICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICB9XG4gIH0pO1xuICB2YXIgZGltID0gcGFyYWxsZWxNb2RlbC5nZXQoJ2xheW91dCcpID09PSAnaG9yaXpvbnRhbCcgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gIHJlY3RFbC5zZXRTaGFwZShkaW0sIDApO1xuICBncmFwaGljLmluaXRQcm9wcyhyZWN0RWwsIHtcbiAgICBzaGFwZToge1xuICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgfVxuICB9LCBzZXJpZXNNb2RlbCwgY2IpO1xuICByZXR1cm4gcmVjdEVsO1xufVxuZnVuY3Rpb24gY3JlYXRlTGluZVBvaW50cyhkYXRhLCBkYXRhSW5kZXgsIGRpbWVuc2lvbnMsIGNvb3JkU3lzKSB7XG4gIHZhciBwb2ludHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpbU5hbWUgPSBkaW1lbnNpb25zW2ldO1xuICAgIHZhciB2YWx1ZSA9IGRhdGEuZ2V0KGRhdGEubWFwRGltZW5zaW9uKGRpbU5hbWUpLCBkYXRhSW5kZXgpO1xuICAgIGlmICghaXNFbXB0eVZhbHVlKHZhbHVlLCBjb29yZFN5cy5nZXRBeGlzKGRpbU5hbWUpLnR5cGUpKSB7XG4gICAgICBwb2ludHMucHVzaChjb29yZFN5cy5kYXRhVG9Qb2ludCh2YWx1ZSwgZGltTmFtZSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcG9pbnRzO1xufVxuZnVuY3Rpb24gYWRkRWwoZGF0YSwgZGF0YUdyb3VwLCBkYXRhSW5kZXgsIGRpbWVuc2lvbnMsIGNvb3JkU3lzKSB7XG4gIHZhciBwb2ludHMgPSBjcmVhdGVMaW5lUG9pbnRzKGRhdGEsIGRhdGFJbmRleCwgZGltZW5zaW9ucywgY29vcmRTeXMpO1xuICB2YXIgbGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHtcbiAgICBzaGFwZToge1xuICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICB9LFxuICAgIC8vIHNpbGVudDogdHJ1ZSxcbiAgICB6MjogMTBcbiAgfSk7XG4gIGRhdGFHcm91cC5hZGQobGluZSk7XG4gIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIGxpbmUpO1xuICByZXR1cm4gbGluZTtcbn1cbmZ1bmN0aW9uIG1ha2VTZXJpZXNTY29wZShzZXJpZXNNb2RlbCkge1xuICB2YXIgc21vb3RoID0gc2VyaWVzTW9kZWwuZ2V0KCdzbW9vdGgnLCB0cnVlKTtcbiAgc21vb3RoID09PSB0cnVlICYmIChzbW9vdGggPSBERUZBVUxUX1NNT09USCk7XG4gIHNtb290aCA9IG51bWVyaWNUb051bWJlcihzbW9vdGgpO1xuICBlcU5hTihzbW9vdGgpICYmIChzbW9vdGggPSAwKTtcbiAgcmV0dXJuIHtcbiAgICBzbW9vdGg6IHNtb290aFxuICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlRWxDb21tb24oZWwsIGRhdGEsIGRhdGFJbmRleCwgc2VyaWVzU2NvcGUpIHtcbiAgZWwudXNlU3R5bGUoZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ3N0eWxlJykpO1xuICBlbC5zdHlsZS5maWxsID0gbnVsbDtcbiAgZWwuc2V0U2hhcGUoJ3Ntb290aCcsIHNlcmllc1Njb3BlLnNtb290aCk7XG4gIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChkYXRhSW5kZXgpO1xuICB2YXIgZW1waGFzaXNNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKTtcbiAgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsKGVsLCBpdGVtTW9kZWwsICdsaW5lU3R5bGUnKTtcbiAgdG9nZ2xlSG92ZXJFbXBoYXNpcyhlbCwgZW1waGFzaXNNb2RlbC5nZXQoJ2ZvY3VzJyksIGVtcGhhc2lzTW9kZWwuZ2V0KCdibHVyU2NvcGUnKSwgZW1waGFzaXNNb2RlbC5nZXQoJ2Rpc2FibGVkJykpO1xufVxuLy8gZnVuY3Rpb24gc2ltcGxlRGlmZihvbGREYXRhLCBuZXdEYXRhLCBkaW1lbnNpb25zKSB7XG4vLyAgICAgbGV0IG9sZExlbjtcbi8vICAgICBpZiAoIW9sZERhdGFcbi8vICAgICAgICAgfHwgIW9sZERhdGEuX19wbFByb2dyZXNzaXZlXG4vLyAgICAgICAgIHx8IChvbGRMZW4gPSBvbGREYXRhLmNvdW50KCkpICE9PSBuZXdEYXRhLmNvdW50KClcbi8vICAgICApIHtcbi8vICAgICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICAgfVxuLy8gICAgIGxldCBkaW1MZW4gPSBkaW1lbnNpb25zLmxlbmd0aDtcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9sZExlbjsgaSsrKSB7XG4vLyAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGltTGVuOyBqKyspIHtcbi8vICAgICAgICAgICAgIGlmIChvbGREYXRhLmdldChkaW1lbnNpb25zW2pdLCBpKSAhPT0gbmV3RGF0YS5nZXQoZGltZW5zaW9uc1tqXSwgaSkpIHtcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vICAgICByZXR1cm4gZmFsc2U7XG4vLyB9XG4vLyBGSVhNRSBwdXQgaW4gY29tbW9uIHV0aWw/XG5mdW5jdGlvbiBpc0VtcHR5VmFsdWUodmFsLCBheGlzVHlwZSkge1xuICByZXR1cm4gYXhpc1R5cGUgPT09ICdjYXRlZ29yeScgPyB2YWwgPT0gbnVsbCA6IHZhbCA9PSBudWxsIHx8IGlzTmFOKHZhbCk7IC8vIGF4aXNUeXBlID09PSAndmFsdWUnXG59XG5leHBvcnQgZGVmYXVsdCBQYXJhbGxlbFZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGVhY2gsIGJpbmQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcy5qcyc7XG5pbXBvcnQgY3JlYXRlU2VyaWVzRGF0YSBmcm9tICcuLi9oZWxwZXIvY3JlYXRlU2VyaWVzRGF0YS5qcyc7XG52YXIgUGFyYWxsZWxTZXJpZXNNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQYXJhbGxlbFNlcmllc01vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBQYXJhbGxlbFNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBQYXJhbGxlbFNlcmllc01vZGVsLnR5cGU7XG4gICAgX3RoaXMudmlzdWFsU3R5bGVBY2Nlc3NQYXRoID0gJ2xpbmVTdHlsZSc7XG4gICAgX3RoaXMudmlzdWFsRHJhd1R5cGUgPSAnc3Ryb2tlJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgUGFyYWxsZWxTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGEgPSBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVNlcmllc0RhdGEobnVsbCwgdGhpcywge1xuICAgICAgdXNlRW5jb2RlRGVmYXVsdGVyOiBiaW5kKG1ha2VEZWZhdWx0RW5jb2RlLCBudWxsLCB0aGlzKVxuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBVc2VyIGNhbiBnZXQgZGF0YSByYXcgaW5kaWNlcyBvbiAnYXhpc0FyZWFTZWxlY3RlZCcgZXZlbnQgcmVjZWl2ZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIFJhdyBpbmRpY2VzXHJcbiAgICovXG4gIFBhcmFsbGVsU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldFJhd0luZGljZXNCeUFjdGl2ZVN0YXRlID0gZnVuY3Rpb24gKGFjdGl2ZVN0YXRlKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gdGhpcy5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICBjb29yZFN5cy5lYWNoQWN0aXZlU3RhdGUoZGF0YSwgZnVuY3Rpb24gKHRoZUFjdGl2ZVN0YXRlLCBkYXRhSW5kZXgpIHtcbiAgICAgIGlmIChhY3RpdmVTdGF0ZSA9PT0gdGhlQWN0aXZlU3RhdGUpIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGRhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH07XG4gIFBhcmFsbGVsU2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMucGFyYWxsZWwnO1xuICBQYXJhbGxlbFNlcmllc01vZGVsLmRlcGVuZGVuY2llcyA9IFsncGFyYWxsZWwnXTtcbiAgUGFyYWxsZWxTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIC8vIHpsZXZlbDogMCxcbiAgICB6OiAyLFxuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdwYXJhbGxlbCcsXG4gICAgcGFyYWxsZWxJbmRleDogMCxcbiAgICBsYWJlbDoge1xuICAgICAgc2hvdzogZmFsc2VcbiAgICB9LFxuICAgIGluYWN0aXZlT3BhY2l0eTogMC4wNSxcbiAgICBhY3RpdmVPcGFjaXR5OiAxLFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgd2lkdGg6IDEsXG4gICAgICBvcGFjaXR5OiAwLjQ1LFxuICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIHNob3c6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9ncmVzc2l2ZTogNTAwLFxuICAgIHNtb290aDogZmFsc2UsXG4gICAgYW5pbWF0aW9uRWFzaW5nOiAnbGluZWFyJ1xuICB9O1xuICByZXR1cm4gUGFyYWxsZWxTZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuZnVuY3Rpb24gbWFrZURlZmF1bHRFbmNvZGUoc2VyaWVzTW9kZWwpIHtcbiAgLy8gVGhlIG1hcHBpbmcgb2YgcGFyYWxsZWxBeGlzIGRpbWVuc2lvbiB0byBkYXRhIGRpbWVuc2lvbiBjYW5cbiAgLy8gYmUgc3BlY2lmaWVkIGluIHBhcmFsbGVsQXhpcy5vcHRpb24uZGltLiBGb3IgZXhhbXBsZSwgaWZcbiAgLy8gcGFyYWxsZWxBeGlzLm9wdGlvbi5kaW0gaXMgJ2RpbTMnLCBpdCBtYXBwaW5nIHRvIHRoZSB0aGlyZFxuICAvLyBkaW1lbnNpb24gb2YgZGF0YS4gQnV0IGBkYXRhLmVuY29kZWAgaGFzIGhpZ2hlciBwcmlvcml0eS5cbiAgLy8gTW9yZW92ZXIsIHBhcmFsbGVsTW9kZWwuZGltZW5zaW9uIHNob3VsZCBub3QgYmUgcmVnYXJkZWQgYXMgZGF0YVxuICAvLyBkaW1lbnNpb25zLiBDb25zaWRlciBkaW1lbnNpb25zID0gWydkaW00JywgJ2RpbTInLCAnZGltNiddO1xuICB2YXIgcGFyYWxsZWxNb2RlbCA9IHNlcmllc01vZGVsLmVjTW9kZWwuZ2V0Q29tcG9uZW50KCdwYXJhbGxlbCcsIHNlcmllc01vZGVsLmdldCgncGFyYWxsZWxJbmRleCcpKTtcbiAgaWYgKCFwYXJhbGxlbE1vZGVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBlbmNvZGVEZWZpbmUgPSB7fTtcbiAgZWFjaChwYXJhbGxlbE1vZGVsLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChheGlzRGltKSB7XG4gICAgdmFyIGRhdGFEaW1JbmRleCA9IGNvbnZlcnREaW1OYW1lVG9OdW1iZXIoYXhpc0RpbSk7XG4gICAgZW5jb2RlRGVmaW5lW2F4aXNEaW1dID0gZGF0YURpbUluZGV4O1xuICB9KTtcbiAgcmV0dXJuIGVuY29kZURlZmluZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREaW1OYW1lVG9OdW1iZXIoZGltTmFtZSkge1xuICByZXR1cm4gK2RpbU5hbWUucmVwbGFjZSgnZGltJywgJycpO1xufVxuZXhwb3J0IGRlZmF1bHQgUGFyYWxsZWxTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbnZhciBvcGFjaXR5QWNjZXNzUGF0aCA9IFsnbGluZVN0eWxlJywgJ29wYWNpdHknXTtcbnZhciBwYXJhbGxlbFZpc3VhbCA9IHtcbiAgc2VyaWVzVHlwZTogJ3BhcmFsbGVsJyxcbiAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIG9wYWNpdHlNYXAgPSB7XG4gICAgICBub3JtYWw6IHNlcmllc01vZGVsLmdldChbJ2xpbmVTdHlsZScsICdvcGFjaXR5J10pLFxuICAgICAgYWN0aXZlOiBzZXJpZXNNb2RlbC5nZXQoJ2FjdGl2ZU9wYWNpdHknKSxcbiAgICAgIGluYWN0aXZlOiBzZXJpZXNNb2RlbC5nZXQoJ2luYWN0aXZlT3BhY2l0eScpXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIChwYXJhbXMsIGRhdGEpIHtcbiAgICAgICAgY29vcmRTeXMuZWFjaEFjdGl2ZVN0YXRlKGRhdGEsIGZ1bmN0aW9uIChhY3RpdmVTdGF0ZSwgZGF0YUluZGV4KSB7XG4gICAgICAgICAgdmFyIG9wYWNpdHkgPSBvcGFjaXR5TWFwW2FjdGl2ZVN0YXRlXTtcbiAgICAgICAgICBpZiAoYWN0aXZlU3RhdGUgPT09ICdub3JtYWwnICYmIGRhdGEuaGFzSXRlbU9wdGlvbikge1xuICAgICAgICAgICAgdmFyIGl0ZW1PcGFjaXR5ID0gZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KS5nZXQob3BhY2l0eUFjY2Vzc1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgaXRlbU9wYWNpdHkgIT0gbnVsbCAmJiAob3BhY2l0eSA9IGl0ZW1PcGFjaXR5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGV4aXN0c1N0eWxlID0gZGF0YS5lbnN1cmVVbmlxdWVJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ3N0eWxlJyk7XG4gICAgICAgICAgZXhpc3RzU3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIH0sIHBhcmFtcy5zdGFydCwgcGFyYW1zLmVuZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IHBhcmFsbGVsVmlzdWFsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgdXNlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9uLmpzJztcbmltcG9ydCBQYXJhbGxlbFZpZXcgZnJvbSAnLi9QYXJhbGxlbFZpZXcuanMnO1xuaW1wb3J0IFBhcmFsbGVsU2VyaWVzTW9kZWwgZnJvbSAnLi9QYXJhbGxlbFNlcmllcy5qcyc7XG5pbXBvcnQgcGFyYWxsZWxWaXN1YWwgZnJvbSAnLi9wYXJhbGxlbFZpc3VhbC5qcyc7XG5pbXBvcnQgeyBpbnN0YWxsIGFzIGluc3RhbGxQYXJhbGxlbENvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudC9wYXJhbGxlbC9pbnN0YWxsLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICB1c2UoaW5zdGFsbFBhcmFsbGVsQ29tcG9uZW50KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ2hhcnRWaWV3KFBhcmFsbGVsVmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclNlcmllc01vZGVsKFBhcmFsbGVsU2VyaWVzTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJWaXN1YWwocmVnaXN0ZXJzLlBSSU9SSVRZLlZJU1VBTC5CUlVTSCwgcGFyYWxsZWxWaXN1YWwpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///31966\n")},73900:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Path.js\nvar Path = __webpack_require__(59482);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/LinearGradient.js\nvar LinearGradient = __webpack_require__(29668);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n;// ./node_modules/echarts/lib/chart/sankey/SankeyView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar SankeyPathShape = /** @class */function () {\n  function SankeyPathShape() {\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.cpx1 = 0;\n    this.cpy1 = 0;\n    this.cpx2 = 0;\n    this.cpy2 = 0;\n    this.extent = 0;\n  }\n  return SankeyPathShape;\n}();\nvar SankeyPath = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(SankeyPath, _super);\n  function SankeyPath(opts) {\n    return _super.call(this, opts) || this;\n  }\n  SankeyPath.prototype.getDefaultShape = function () {\n    return new SankeyPathShape();\n  };\n  SankeyPath.prototype.buildPath = function (ctx, shape) {\n    var extent = shape.extent;\n    ctx.moveTo(shape.x1, shape.y1);\n    ctx.bezierCurveTo(shape.cpx1, shape.cpy1, shape.cpx2, shape.cpy2, shape.x2, shape.y2);\n    if (shape.orient === 'vertical') {\n      ctx.lineTo(shape.x2 + extent, shape.y2);\n      ctx.bezierCurveTo(shape.cpx2 + extent, shape.cpy2, shape.cpx1 + extent, shape.cpy1, shape.x1 + extent, shape.y1);\n    } else {\n      ctx.lineTo(shape.x2, shape.y2 + extent);\n      ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + extent, shape.cpx1, shape.cpy1 + extent, shape.x1, shape.y1 + extent);\n    }\n    ctx.closePath();\n  };\n  SankeyPath.prototype.highlight = function () {\n    (0,states/* enterEmphasis */.HY)(this);\n  };\n  SankeyPath.prototype.downplay = function () {\n    (0,states/* leaveEmphasis */.SD)(this);\n  };\n  return SankeyPath;\n}(Path/* default */.Ay);\nvar SankeyView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(SankeyView, _super);\n  function SankeyView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = SankeyView.type;\n    _this._focusAdjacencyDisabled = false;\n    return _this;\n  }\n  SankeyView.prototype.render = function (seriesModel, ecModel, api) {\n    var sankeyView = this;\n    var graph = seriesModel.getGraph();\n    var group = this.group;\n    var layoutInfo = seriesModel.layoutInfo;\n    // view width\n    var width = layoutInfo.width;\n    // view height\n    var height = layoutInfo.height;\n    var nodeData = seriesModel.getData();\n    var edgeData = seriesModel.getData('edge');\n    var orient = seriesModel.get('orient');\n    this._model = seriesModel;\n    group.removeAll();\n    group.x = layoutInfo.x;\n    group.y = layoutInfo.y;\n    // generate a bezire Curve for each edge\n    graph.eachEdge(function (edge) {\n      var curve = new SankeyPath();\n      var ecData = (0,innerStore/* getECData */.z)(curve);\n      ecData.dataIndex = edge.dataIndex;\n      ecData.seriesIndex = seriesModel.seriesIndex;\n      ecData.dataType = 'edge';\n      var edgeModel = edge.getModel();\n      var lineStyleModel = edgeModel.getModel('lineStyle');\n      var curvature = lineStyleModel.get('curveness');\n      var n1Layout = edge.node1.getLayout();\n      var node1Model = edge.node1.getModel();\n      var dragX1 = node1Model.get('localX');\n      var dragY1 = node1Model.get('localY');\n      var n2Layout = edge.node2.getLayout();\n      var node2Model = edge.node2.getModel();\n      var dragX2 = node2Model.get('localX');\n      var dragY2 = node2Model.get('localY');\n      var edgeLayout = edge.getLayout();\n      var x1;\n      var y1;\n      var x2;\n      var y2;\n      var cpx1;\n      var cpy1;\n      var cpx2;\n      var cpy2;\n      curve.shape.extent = Math.max(1, edgeLayout.dy);\n      curve.shape.orient = orient;\n      if (orient === 'vertical') {\n        x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + edgeLayout.sy;\n        y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + n1Layout.dy;\n        x2 = (dragX2 != null ? dragX2 * width : n2Layout.x) + edgeLayout.ty;\n        y2 = dragY2 != null ? dragY2 * height : n2Layout.y;\n        cpx1 = x1;\n        cpy1 = y1 * (1 - curvature) + y2 * curvature;\n        cpx2 = x2;\n        cpy2 = y1 * curvature + y2 * (1 - curvature);\n      } else {\n        x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + n1Layout.dx;\n        y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + edgeLayout.sy;\n        x2 = dragX2 != null ? dragX2 * width : n2Layout.x;\n        y2 = (dragY2 != null ? dragY2 * height : n2Layout.y) + edgeLayout.ty;\n        cpx1 = x1 * (1 - curvature) + x2 * curvature;\n        cpy1 = y1;\n        cpx2 = x1 * curvature + x2 * (1 - curvature);\n        cpy2 = y2;\n      }\n      curve.setShape({\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        cpx1: cpx1,\n        cpy1: cpy1,\n        cpx2: cpx2,\n        cpy2: cpy2\n      });\n      curve.useStyle(lineStyleModel.getItemStyle());\n      // Special color, use source node color or target node color\n      applyCurveStyle(curve.style, orient, edge);\n      var defaultEdgeLabelText = \"\" + edgeModel.get('value');\n      var edgeLabelStateModels = (0,labelStyle/* getLabelStatesModels */.lx)(edgeModel, 'edgeLabel');\n      (0,labelStyle/* setLabelStyle */.qM)(curve, edgeLabelStateModels, {\n        labelFetcher: {\n          getFormattedLabel: function (dataIndex, stateName, dataType, labelDimIndex, formatter, extendParams) {\n            return seriesModel.getFormattedLabel(dataIndex, stateName, 'edge', labelDimIndex,\n            // ensure edgeLabel formatter is provided\n            // to prevent the inheritance from `label.formatter` of the series\n            (0,util.retrieve3)(formatter, edgeLabelStateModels.normal && edgeLabelStateModels.normal.get('formatter'), defaultEdgeLabelText), extendParams);\n          }\n        },\n        labelDataIndex: edge.dataIndex,\n        defaultText: defaultEdgeLabelText\n      });\n      curve.setTextConfig({\n        position: 'inside'\n      });\n      var emphasisModel = edgeModel.getModel('emphasis');\n      (0,states/* setStatesStylesFromModel */.Mx)(curve, edgeModel, 'lineStyle', function (model) {\n        var style = model.getItemStyle();\n        applyCurveStyle(style, orient, edge);\n        return style;\n      });\n      group.add(curve);\n      edgeData.setItemGraphicEl(edge.dataIndex, curve);\n      var focus = emphasisModel.get('focus');\n      (0,states/* toggleHoverEmphasis */.Lm)(curve, focus === 'adjacency' ? edge.getAdjacentDataIndices() : focus === 'trajectory' ? edge.getTrajectoryDataIndices() : focus, emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n    });\n    // Generate a rect for each node\n    graph.eachNode(function (node) {\n      var layout = node.getLayout();\n      var itemModel = node.getModel();\n      var dragX = itemModel.get('localX');\n      var dragY = itemModel.get('localY');\n      var emphasisModel = itemModel.getModel('emphasis');\n      var borderRadius = itemModel.get(['itemStyle', 'borderRadius']) || 0;\n      var rect = new Rect/* default */.A({\n        shape: {\n          x: dragX != null ? dragX * width : layout.x,\n          y: dragY != null ? dragY * height : layout.y,\n          width: layout.dx,\n          height: layout.dy,\n          r: borderRadius\n        },\n        style: itemModel.getModel('itemStyle').getItemStyle(),\n        z2: 10\n      });\n      (0,labelStyle/* setLabelStyle */.qM)(rect, (0,labelStyle/* getLabelStatesModels */.lx)(itemModel), {\n        labelFetcher: {\n          getFormattedLabel: function (dataIndex, stateName) {\n            return seriesModel.getFormattedLabel(dataIndex, stateName, 'node');\n          }\n        },\n        labelDataIndex: node.dataIndex,\n        defaultText: node.id\n      });\n      rect.disableLabelAnimation = true;\n      rect.setStyle('fill', node.getVisual('color'));\n      rect.setStyle('decal', node.getVisual('style').decal);\n      (0,states/* setStatesStylesFromModel */.Mx)(rect, itemModel);\n      group.add(rect);\n      nodeData.setItemGraphicEl(node.dataIndex, rect);\n      (0,innerStore/* getECData */.z)(rect).dataType = 'node';\n      var focus = emphasisModel.get('focus');\n      (0,states/* toggleHoverEmphasis */.Lm)(rect, focus === 'adjacency' ? node.getAdjacentDataIndices() : focus === 'trajectory' ? node.getTrajectoryDataIndices() : focus, emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n    });\n    nodeData.eachItemGraphicEl(function (el, dataIndex) {\n      var itemModel = nodeData.getItemModel(dataIndex);\n      if (itemModel.get('draggable')) {\n        el.drift = function (dx, dy) {\n          sankeyView._focusAdjacencyDisabled = true;\n          this.shape.x += dx;\n          this.shape.y += dy;\n          this.dirty();\n          api.dispatchAction({\n            type: 'dragNode',\n            seriesId: seriesModel.id,\n            dataIndex: nodeData.getRawIndex(dataIndex),\n            localX: this.shape.x / width,\n            localY: this.shape.y / height\n          });\n        };\n        el.ondragend = function () {\n          sankeyView._focusAdjacencyDisabled = false;\n        };\n        el.draggable = true;\n        el.cursor = 'move';\n      }\n    });\n    if (!this._data && seriesModel.isAnimationEnabled()) {\n      group.setClipPath(createGridClipShape(group.getBoundingRect(), seriesModel, function () {\n        group.removeClipPath();\n      }));\n    }\n    this._data = seriesModel.getData();\n  };\n  SankeyView.prototype.dispose = function () {};\n  SankeyView.type = 'sankey';\n  return SankeyView;\n}(Chart/* default */.A);\n/**\r\n * Special color, use source node color or target node color\r\n * @param curveProps curve's style to parse\r\n * @param orient direction\r\n * @param edge current curve data\r\n */\nfunction applyCurveStyle(curveProps, orient, edge) {\n  switch (curveProps.fill) {\n    case 'source':\n      curveProps.fill = edge.node1.getVisual('color');\n      curveProps.decal = edge.node1.getVisual('style').decal;\n      break;\n    case 'target':\n      curveProps.fill = edge.node2.getVisual('color');\n      curveProps.decal = edge.node2.getVisual('style').decal;\n      break;\n    case 'gradient':\n      var sourceColor = edge.node1.getVisual('color');\n      var targetColor = edge.node2.getVisual('color');\n      if ((0,util.isString)(sourceColor) && (0,util.isString)(targetColor)) {\n        curveProps.fill = new LinearGradient/* default */.A(0, 0, +(orient === 'horizontal'), +(orient === 'vertical'), [{\n          color: sourceColor,\n          offset: 0\n        }, {\n          color: targetColor,\n          offset: 1\n        }]);\n      }\n  }\n}\n// Add animation to the view\nfunction createGridClipShape(rect, seriesModel, cb) {\n  var rectEl = new Rect/* default */.A({\n    shape: {\n      x: rect.x - 10,\n      y: rect.y - 10,\n      width: 0,\n      height: rect.height + 20\n    }\n  });\n  basicTransition/* initProps */.LW(rectEl, {\n    shape: {\n      width: rect.width + 20\n    }\n  }, seriesModel, cb);\n  return rectEl;\n}\n/* harmony default export */ const sankey_SankeyView = (SankeyView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createGraphFromNodeEdge.js\nvar createGraphFromNodeEdge = __webpack_require__(62695);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Model.js + 2 modules\nvar Model = __webpack_require__(43172);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js\nvar tooltipMarkup = __webpack_require__(3961);\n;// ./node_modules/echarts/lib/chart/sankey/SankeySeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar SankeySeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(SankeySeriesModel, _super);\n  function SankeySeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = SankeySeriesModel.type;\n    return _this;\n  }\n  /**\r\n   * Init a graph data structure from data in option series\r\n   */\n  SankeySeriesModel.prototype.getInitialData = function (option, ecModel) {\n    var links = option.edges || option.links || [];\n    var nodes = option.data || option.nodes || [];\n    var levels = option.levels || [];\n    this.levelModels = [];\n    var levelModels = this.levelModels;\n    for (var i = 0; i < levels.length; i++) {\n      if (levels[i].depth != null && levels[i].depth >= 0) {\n        levelModels[levels[i].depth] = new Model/* default */.A(levels[i], this, ecModel);\n      } else {\n        if (false) {}\n      }\n    }\n    var graph = (0,createGraphFromNodeEdge/* default */.A)(nodes, links, this, true, beforeLink);\n    return graph.data;\n    function beforeLink(nodeData, edgeData) {\n      nodeData.wrapMethod('getItemModel', function (model, idx) {\n        var seriesModel = model.parentModel;\n        var layout = seriesModel.getData().getItemLayout(idx);\n        if (layout) {\n          var nodeDepth = layout.depth;\n          var levelModel = seriesModel.levelModels[nodeDepth];\n          if (levelModel) {\n            model.parentModel = levelModel;\n          }\n        }\n        return model;\n      });\n      edgeData.wrapMethod('getItemModel', function (model, idx) {\n        var seriesModel = model.parentModel;\n        var edge = seriesModel.getGraph().getEdgeByIndex(idx);\n        var layout = edge.node1.getLayout();\n        if (layout) {\n          var depth = layout.depth;\n          var levelModel = seriesModel.levelModels[depth];\n          if (levelModel) {\n            model.parentModel = levelModel;\n          }\n        }\n        return model;\n      });\n    }\n  };\n  SankeySeriesModel.prototype.setNodePosition = function (dataIndex, localPosition) {\n    var nodes = this.option.data || this.option.nodes;\n    var dataItem = nodes[dataIndex];\n    dataItem.localX = localPosition[0];\n    dataItem.localY = localPosition[1];\n  };\n  /**\r\n   * Return the graphic data structure\r\n   *\r\n   * @return graphic data structure\r\n   */\n  SankeySeriesModel.prototype.getGraph = function () {\n    return this.getData().graph;\n  };\n  /**\r\n   * Get edge data of graphic data structure\r\n   *\r\n   * @return data structure of list\r\n   */\n  SankeySeriesModel.prototype.getEdgeData = function () {\n    return this.getGraph().edgeData;\n  };\n  SankeySeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n    function noValue(val) {\n      return isNaN(val) || val == null;\n    }\n    // dataType === 'node' or empty do not show tooltip by default\n    if (dataType === 'edge') {\n      var params = this.getDataParams(dataIndex, dataType);\n      var rawDataOpt = params.data;\n      var edgeValue = params.value;\n      var edgeName = rawDataOpt.source + ' -- ' + rawDataOpt.target;\n      return (0,tooltipMarkup/* createTooltipMarkup */.Qx)('nameValue', {\n        name: edgeName,\n        value: edgeValue,\n        noValue: noValue(edgeValue)\n      });\n    }\n    // dataType === 'node'\n    else {\n      var node = this.getGraph().getNodeByIndex(dataIndex);\n      var value = node.getLayout().value;\n      var name_1 = this.getDataParams(dataIndex, dataType).data.name;\n      return (0,tooltipMarkup/* createTooltipMarkup */.Qx)('nameValue', {\n        name: name_1 != null ? name_1 + '' : null,\n        value: value,\n        noValue: noValue(value)\n      });\n    }\n  };\n  SankeySeriesModel.prototype.optionUpdated = function () {};\n  // Override Series.getDataParams()\n  SankeySeriesModel.prototype.getDataParams = function (dataIndex, dataType) {\n    var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);\n    if (params.value == null && dataType === 'node') {\n      var node = this.getGraph().getNodeByIndex(dataIndex);\n      var nodeValue = node.getLayout().value;\n      params.value = nodeValue;\n    }\n    return params;\n  };\n  SankeySeriesModel.type = 'series.sankey';\n  SankeySeriesModel.defaultOption = {\n    // zlevel: 0,\n    z: 2,\n    coordinateSystem: 'view',\n    left: '5%',\n    top: '5%',\n    right: '20%',\n    bottom: '5%',\n    orient: 'horizontal',\n    nodeWidth: 20,\n    nodeGap: 8,\n    draggable: true,\n    layoutIterations: 32,\n    label: {\n      show: true,\n      position: 'right',\n      fontSize: 12\n    },\n    edgeLabel: {\n      show: false,\n      fontSize: 12\n    },\n    levels: [],\n    nodeAlign: 'justify',\n    lineStyle: {\n      color: '#314656',\n      opacity: 0.2,\n      curveness: 0.5\n    },\n    emphasis: {\n      label: {\n        show: true\n      },\n      lineStyle: {\n        opacity: 0.5\n      }\n    },\n    select: {\n      itemStyle: {\n        borderColor: '#212121'\n      }\n    },\n    animationEasing: 'linear',\n    animationDuration: 1000\n  };\n  return SankeySeriesModel;\n}(Series/* default */.A);\n/* harmony default export */ const SankeySeries = (SankeySeriesModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n;// ./node_modules/echarts/lib/chart/sankey/sankeyLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction sankeyLayout(ecModel, api) {\n  ecModel.eachSeriesByType('sankey', function (seriesModel) {\n    var nodeWidth = seriesModel.get('nodeWidth');\n    var nodeGap = seriesModel.get('nodeGap');\n    var layoutInfo = getViewRect(seriesModel, api);\n    seriesModel.layoutInfo = layoutInfo;\n    var width = layoutInfo.width;\n    var height = layoutInfo.height;\n    var graph = seriesModel.getGraph();\n    var nodes = graph.nodes;\n    var edges = graph.edges;\n    computeNodeValues(nodes);\n    var filteredNodes = util.filter(nodes, function (node) {\n      return node.getLayout().value === 0;\n    });\n    var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get('layoutIterations');\n    var orient = seriesModel.get('orient');\n    var nodeAlign = seriesModel.get('nodeAlign');\n    layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);\n  });\n}\n/**\r\n * Get the layout position of the whole view\r\n */\nfunction getViewRect(seriesModel, api) {\n  return layout/* getLayoutRect */.dV(seriesModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n}\nfunction layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {\n  computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);\n  computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);\n  computeEdgeDepths(nodes, orient);\n}\n/**\r\n * Compute the value of each node by summing the associated edge's value\r\n */\nfunction computeNodeValues(nodes) {\n  util.each(nodes, function (node) {\n    var value1 = sum(node.outEdges, getEdgeValue);\n    var value2 = sum(node.inEdges, getEdgeValue);\n    var nodeRawValue = node.getValue() || 0;\n    var value = Math.max(value1, value2, nodeRawValue);\n    node.setLayout({\n      value: value\n    }, true);\n  });\n}\n/**\r\n * Compute the x-position for each node.\r\n *\r\n * Here we use Kahn algorithm to detect cycle when we traverse\r\n * the node to computer the initial x position.\r\n */\nfunction computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {\n  // Used to mark whether the edge is deleted. if it is deleted,\n  // the value is 0, otherwise it is 1.\n  var remainEdges = [];\n  // Storage each node's indegree.\n  var indegreeArr = [];\n  // Used to storage the node with indegree is equal to 0.\n  var zeroIndegrees = [];\n  var nextTargetNode = [];\n  var x = 0;\n  // let kx = 0;\n  for (var i = 0; i < edges.length; i++) {\n    remainEdges[i] = 1;\n  }\n  for (var i = 0; i < nodes.length; i++) {\n    indegreeArr[i] = nodes[i].inEdges.length;\n    if (indegreeArr[i] === 0) {\n      zeroIndegrees.push(nodes[i]);\n    }\n  }\n  var maxNodeDepth = -1;\n  // Traversing nodes using topological sorting to calculate the\n  // horizontal(if orient === 'horizontal') or vertical(if orient === 'vertical')\n  // position of the nodes.\n  while (zeroIndegrees.length) {\n    for (var idx = 0; idx < zeroIndegrees.length; idx++) {\n      var node = zeroIndegrees[idx];\n      var item = node.hostGraph.data.getRawDataItem(node.dataIndex);\n      var isItemDepth = item.depth != null && item.depth >= 0;\n      if (isItemDepth && item.depth > maxNodeDepth) {\n        maxNodeDepth = item.depth;\n      }\n      node.setLayout({\n        depth: isItemDepth ? item.depth : x\n      }, true);\n      orient === 'vertical' ? node.setLayout({\n        dy: nodeWidth\n      }, true) : node.setLayout({\n        dx: nodeWidth\n      }, true);\n      for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {\n        var edge = node.outEdges[edgeIdx];\n        var indexEdge = edges.indexOf(edge);\n        remainEdges[indexEdge] = 0;\n        var targetNode = edge.node2;\n        var nodeIndex = nodes.indexOf(targetNode);\n        if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {\n          nextTargetNode.push(targetNode);\n        }\n      }\n    }\n    ++x;\n    zeroIndegrees = nextTargetNode;\n    nextTargetNode = [];\n  }\n  for (var i = 0; i < remainEdges.length; i++) {\n    if (remainEdges[i] === 1) {\n      throw new Error('Sankey is a DAG, the original data has cycle!');\n    }\n  }\n  var maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;\n  if (nodeAlign && nodeAlign !== 'left') {\n    adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);\n  }\n  var kx = orient === 'vertical' ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;\n  scaleNodeBreadths(nodes, kx, orient);\n}\nfunction isNodeDepth(node) {\n  var item = node.hostGraph.data.getRawDataItem(node.dataIndex);\n  return item.depth != null && item.depth >= 0;\n}\nfunction adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {\n  if (nodeAlign === 'right') {\n    var nextSourceNode = [];\n    var remainNodes = nodes;\n    var nodeHeight = 0;\n    while (remainNodes.length) {\n      for (var i = 0; i < remainNodes.length; i++) {\n        var node = remainNodes[i];\n        node.setLayout({\n          skNodeHeight: nodeHeight\n        }, true);\n        for (var j = 0; j < node.inEdges.length; j++) {\n          var edge = node.inEdges[j];\n          if (nextSourceNode.indexOf(edge.node1) < 0) {\n            nextSourceNode.push(edge.node1);\n          }\n        }\n      }\n      remainNodes = nextSourceNode;\n      nextSourceNode = [];\n      ++nodeHeight;\n    }\n    util.each(nodes, function (node) {\n      if (!isNodeDepth(node)) {\n        node.setLayout({\n          depth: Math.max(0, maxDepth - node.getLayout().skNodeHeight)\n        }, true);\n      }\n    });\n  } else if (nodeAlign === 'justify') {\n    moveSinksRight(nodes, maxDepth);\n  }\n}\n/**\r\n * All the node without outEgdes are assigned maximum x-position and\r\n *     be aligned in the last column.\r\n *\r\n * @param nodes.  node of sankey view.\r\n * @param maxDepth.  use to assign to node without outEdges as x-position.\r\n */\nfunction moveSinksRight(nodes, maxDepth) {\n  util.each(nodes, function (node) {\n    if (!isNodeDepth(node) && !node.outEdges.length) {\n      node.setLayout({\n        depth: maxDepth\n      }, true);\n    }\n  });\n}\n/**\r\n * Scale node x-position to the width\r\n *\r\n * @param nodes  node of sankey view\r\n * @param kx   multiple used to scale nodes\r\n */\nfunction scaleNodeBreadths(nodes, kx, orient) {\n  util.each(nodes, function (node) {\n    var nodeDepth = node.getLayout().depth * kx;\n    orient === 'vertical' ? node.setLayout({\n      y: nodeDepth\n    }, true) : node.setLayout({\n      x: nodeDepth\n    }, true);\n  });\n}\n/**\r\n * Using Gauss-Seidel iterations method to compute the node depth(y-position)\r\n *\r\n * @param nodes  node of sankey view\r\n * @param edges  edge of sankey view\r\n * @param height  the whole height of the area to draw the view\r\n * @param nodeGap  the vertical distance between two nodes\r\n *     in the same column.\r\n * @param iterations  the number of iterations for the algorithm\r\n */\nfunction computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {\n  var nodesByBreadth = prepareNodesByBreadth(nodes, orient);\n  initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);\n  resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n  for (var alpha = 1; iterations > 0; iterations--) {\n    // 0.99 is a experience parameter, ensure that each iterations of\n    // changes as small as possible.\n    alpha *= 0.99;\n    relaxRightToLeft(nodesByBreadth, alpha, orient);\n    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n    relaxLeftToRight(nodesByBreadth, alpha, orient);\n    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n  }\n}\nfunction prepareNodesByBreadth(nodes, orient) {\n  var nodesByBreadth = [];\n  var keyAttr = orient === 'vertical' ? 'y' : 'x';\n  var groupResult = (0,model/* groupData */.Sq)(nodes, function (node) {\n    return node.getLayout()[keyAttr];\n  });\n  groupResult.keys.sort(function (a, b) {\n    return a - b;\n  });\n  util.each(groupResult.keys, function (key) {\n    nodesByBreadth.push(groupResult.buckets.get(key));\n  });\n  return nodesByBreadth;\n}\n/**\r\n * Compute the original y-position for each node\r\n */\nfunction initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {\n  var minKy = Infinity;\n  util.each(nodesByBreadth, function (nodes) {\n    var n = nodes.length;\n    var sum = 0;\n    util.each(nodes, function (node) {\n      sum += node.getLayout().value;\n    });\n    var ky = orient === 'vertical' ? (width - (n - 1) * nodeGap) / sum : (height - (n - 1) * nodeGap) / sum;\n    if (ky < minKy) {\n      minKy = ky;\n    }\n  });\n  util.each(nodesByBreadth, function (nodes) {\n    util.each(nodes, function (node, i) {\n      var nodeDy = node.getLayout().value * minKy;\n      if (orient === 'vertical') {\n        node.setLayout({\n          x: i\n        }, true);\n        node.setLayout({\n          dx: nodeDy\n        }, true);\n      } else {\n        node.setLayout({\n          y: i\n        }, true);\n        node.setLayout({\n          dy: nodeDy\n        }, true);\n      }\n    });\n  });\n  util.each(edges, function (edge) {\n    var edgeDy = +edge.getValue() * minKy;\n    edge.setLayout({\n      dy: edgeDy\n    }, true);\n  });\n}\n/**\r\n * Resolve the collision of initialized depth (y-position)\r\n */\nfunction resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {\n  var keyAttr = orient === 'vertical' ? 'x' : 'y';\n  util.each(nodesByBreadth, function (nodes) {\n    nodes.sort(function (a, b) {\n      return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];\n    });\n    var nodeX;\n    var node;\n    var dy;\n    var y0 = 0;\n    var n = nodes.length;\n    var nodeDyAttr = orient === 'vertical' ? 'dx' : 'dy';\n    for (var i = 0; i < n; i++) {\n      node = nodes[i];\n      dy = y0 - node.getLayout()[keyAttr];\n      if (dy > 0) {\n        nodeX = node.getLayout()[keyAttr] + dy;\n        orient === 'vertical' ? node.setLayout({\n          x: nodeX\n        }, true) : node.setLayout({\n          y: nodeX\n        }, true);\n      }\n      y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;\n    }\n    var viewWidth = orient === 'vertical' ? width : height;\n    // If the bottommost node goes outside the bounds, push it back up\n    dy = y0 - nodeGap - viewWidth;\n    if (dy > 0) {\n      nodeX = node.getLayout()[keyAttr] - dy;\n      orient === 'vertical' ? node.setLayout({\n        x: nodeX\n      }, true) : node.setLayout({\n        y: nodeX\n      }, true);\n      y0 = nodeX;\n      for (var i = n - 2; i >= 0; --i) {\n        node = nodes[i];\n        dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;\n        if (dy > 0) {\n          nodeX = node.getLayout()[keyAttr] - dy;\n          orient === 'vertical' ? node.setLayout({\n            x: nodeX\n          }, true) : node.setLayout({\n            y: nodeX\n          }, true);\n        }\n        y0 = node.getLayout()[keyAttr];\n      }\n    }\n  });\n}\n/**\r\n * Change the y-position of the nodes, except most the right side nodes\r\n * @param nodesByBreadth\r\n * @param alpha  parameter used to adjust the nodes y-position\r\n */\nfunction relaxRightToLeft(nodesByBreadth, alpha, orient) {\n  util.each(nodesByBreadth.slice().reverse(), function (nodes) {\n    util.each(nodes, function (node) {\n      if (node.outEdges.length) {\n        var y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue);\n        if (isNaN(y)) {\n          var len = node.outEdges.length;\n          y = len ? sum(node.outEdges, centerTarget, orient) / len : 0;\n        }\n        if (orient === 'vertical') {\n          var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            x: nodeX\n          }, true);\n        } else {\n          var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            y: nodeY\n          }, true);\n        }\n      }\n    });\n  });\n}\nfunction weightedTarget(edge, orient) {\n  return center(edge.node2, orient) * edge.getValue();\n}\nfunction centerTarget(edge, orient) {\n  return center(edge.node2, orient);\n}\nfunction weightedSource(edge, orient) {\n  return center(edge.node1, orient) * edge.getValue();\n}\nfunction centerSource(edge, orient) {\n  return center(edge.node1, orient);\n}\nfunction center(node, orient) {\n  return orient === 'vertical' ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;\n}\nfunction getEdgeValue(edge) {\n  return edge.getValue();\n}\nfunction sum(array, cb, orient) {\n  var sum = 0;\n  var len = array.length;\n  var i = -1;\n  while (++i < len) {\n    var value = +cb(array[i], orient);\n    if (!isNaN(value)) {\n      sum += value;\n    }\n  }\n  return sum;\n}\n/**\r\n * Change the y-position of the nodes, except most the left side nodes\r\n */\nfunction relaxLeftToRight(nodesByBreadth, alpha, orient) {\n  util.each(nodesByBreadth, function (nodes) {\n    util.each(nodes, function (node) {\n      if (node.inEdges.length) {\n        var y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue);\n        if (isNaN(y)) {\n          var len = node.inEdges.length;\n          y = len ? sum(node.inEdges, centerSource, orient) / len : 0;\n        }\n        if (orient === 'vertical') {\n          var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            x: nodeX\n          }, true);\n        } else {\n          var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            y: nodeY\n          }, true);\n        }\n      }\n    });\n  });\n}\n/**\r\n * Compute the depth(y-position) of each edge\r\n */\nfunction computeEdgeDepths(nodes, orient) {\n  var keyAttr = orient === 'vertical' ? 'x' : 'y';\n  util.each(nodes, function (node) {\n    node.outEdges.sort(function (a, b) {\n      return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];\n    });\n    node.inEdges.sort(function (a, b) {\n      return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];\n    });\n  });\n  util.each(nodes, function (node) {\n    var sy = 0;\n    var ty = 0;\n    util.each(node.outEdges, function (edge) {\n      edge.setLayout({\n        sy: sy\n      }, true);\n      sy += edge.getLayout().dy;\n    });\n    util.each(node.inEdges, function (edge) {\n      edge.setLayout({\n        ty: ty\n      }, true);\n      ty += edge.getLayout().dy;\n    });\n  });\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/VisualMapping.js\nvar VisualMapping = __webpack_require__(7857);\n;// ./node_modules/echarts/lib/chart/sankey/sankeyVisual.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction sankeyVisual(ecModel) {\n  ecModel.eachSeriesByType('sankey', function (seriesModel) {\n    var graph = seriesModel.getGraph();\n    var nodes = graph.nodes;\n    var edges = graph.edges;\n    if (nodes.length) {\n      var minValue_1 = Infinity;\n      var maxValue_1 = -Infinity;\n      util.each(nodes, function (node) {\n        var nodeValue = node.getLayout().value;\n        if (nodeValue < minValue_1) {\n          minValue_1 = nodeValue;\n        }\n        if (nodeValue > maxValue_1) {\n          maxValue_1 = nodeValue;\n        }\n      });\n      util.each(nodes, function (node) {\n        var mapping = new VisualMapping/* default */.A({\n          type: 'color',\n          mappingMethod: 'linear',\n          dataExtent: [minValue_1, maxValue_1],\n          visual: seriesModel.get('color')\n        });\n        var mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);\n        var customColor = node.getModel().get(['itemStyle', 'color']);\n        if (customColor != null) {\n          node.setVisual('color', customColor);\n          node.setVisual('style', {\n            fill: customColor\n          });\n        } else {\n          node.setVisual('color', mapValueToColor);\n          node.setVisual('style', {\n            fill: mapValueToColor\n          });\n        }\n      });\n    }\n    if (edges.length) {\n      util.each(edges, function (edge) {\n        var edgeStyle = edge.getModel().get('lineStyle');\n        edge.setVisual('style', edgeStyle);\n      });\n    }\n  });\n}\n;// ./node_modules/echarts/lib/chart/sankey/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nfunction install(registers) {\n  registers.registerChartView(sankey_SankeyView);\n  registers.registerSeriesModel(SankeySeries);\n  registers.registerLayout(sankeyLayout);\n  registers.registerVisual(sankeyVisual);\n  registers.registerAction({\n    type: 'dragNode',\n    event: 'dragnode',\n    // here can only use 'update' now, other value is not support in echarts.\n    update: 'update'\n  }, function (payload, ecModel) {\n    ecModel.eachComponent({\n      mainType: 'series',\n      subType: 'sankey',\n      query: payload\n    }, function (seriesModel) {\n      seriesModel.setNodePosition(payload.dataIndex, [payload.localX, payload.localY]);\n    });\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM5MDAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ3JVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9zYW5rZXkvU2Fua2V5Vmlldy5qcz84YjZhIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9zYW5rZXkvU2Fua2V5U2VyaWVzLmpzP2RiZmUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3NhbmtleS9zYW5rZXlMYXlvdXQuanM/NjJhYiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvc2Fua2V5L3NhbmtleVZpc3VhbC5qcz9jZWYwIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9zYW5rZXkvaW5zdGFsbC5qcz80ZTgyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBlbnRlckVtcGhhc2lzLCBsZWF2ZUVtcGhhc2lzLCB0b2dnbGVIb3ZlckVtcGhhc2lzLCBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQuanMnO1xuaW1wb3J0IHsgc2V0TGFiZWxTdHlsZSwgZ2V0TGFiZWxTdGF0ZXNNb2RlbHMgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlLmpzJztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZS5qcyc7XG5pbXBvcnQgeyBpc1N0cmluZywgcmV0cmlldmUzIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbnZhciBTYW5rZXlQYXRoU2hhcGUgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTYW5rZXlQYXRoU2hhcGUoKSB7XG4gICAgdGhpcy54MSA9IDA7XG4gICAgdGhpcy55MSA9IDA7XG4gICAgdGhpcy54MiA9IDA7XG4gICAgdGhpcy55MiA9IDA7XG4gICAgdGhpcy5jcHgxID0gMDtcbiAgICB0aGlzLmNweTEgPSAwO1xuICAgIHRoaXMuY3B4MiA9IDA7XG4gICAgdGhpcy5jcHkyID0gMDtcbiAgICB0aGlzLmV4dGVudCA9IDA7XG4gIH1cbiAgcmV0dXJuIFNhbmtleVBhdGhTaGFwZTtcbn0oKTtcbnZhciBTYW5rZXlQYXRoID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNhbmtleVBhdGgsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFNhbmtleVBhdGgob3B0cykge1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICB9XG4gIFNhbmtleVBhdGgucHJvdG90eXBlLmdldERlZmF1bHRTaGFwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNhbmtleVBhdGhTaGFwZSgpO1xuICB9O1xuICBTYW5rZXlQYXRoLnByb3RvdHlwZS5idWlsZFBhdGggPSBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciBleHRlbnQgPSBzaGFwZS5leHRlbnQ7XG4gICAgY3R4Lm1vdmVUbyhzaGFwZS54MSwgc2hhcGUueTEpO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHNoYXBlLmNweDEsIHNoYXBlLmNweTEsIHNoYXBlLmNweDIsIHNoYXBlLmNweTIsIHNoYXBlLngyLCBzaGFwZS55Mik7XG4gICAgaWYgKHNoYXBlLm9yaWVudCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgY3R4LmxpbmVUbyhzaGFwZS54MiArIGV4dGVudCwgc2hhcGUueTIpO1xuICAgICAgY3R4LmJlemllckN1cnZlVG8oc2hhcGUuY3B4MiArIGV4dGVudCwgc2hhcGUuY3B5Miwgc2hhcGUuY3B4MSArIGV4dGVudCwgc2hhcGUuY3B5MSwgc2hhcGUueDEgKyBleHRlbnQsIHNoYXBlLnkxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhzaGFwZS54Miwgc2hhcGUueTIgKyBleHRlbnQpO1xuICAgICAgY3R4LmJlemllckN1cnZlVG8oc2hhcGUuY3B4Miwgc2hhcGUuY3B5MiArIGV4dGVudCwgc2hhcGUuY3B4MSwgc2hhcGUuY3B5MSArIGV4dGVudCwgc2hhcGUueDEsIHNoYXBlLnkxICsgZXh0ZW50KTtcbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICB9O1xuICBTYW5rZXlQYXRoLnByb3RvdHlwZS5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZW50ZXJFbXBoYXNpcyh0aGlzKTtcbiAgfTtcbiAgU2Fua2V5UGF0aC5wcm90b3R5cGUuZG93bnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGVhdmVFbXBoYXNpcyh0aGlzKTtcbiAgfTtcbiAgcmV0dXJuIFNhbmtleVBhdGg7XG59KGdyYXBoaWMuUGF0aCk7XG52YXIgU2Fua2V5VmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTYW5rZXlWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBTYW5rZXlWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBTYW5rZXlWaWV3LnR5cGU7XG4gICAgX3RoaXMuX2ZvY3VzQWRqYWNlbmN5RGlzYWJsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgU2Fua2V5Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgc2Fua2V5VmlldyA9IHRoaXM7XG4gICAgdmFyIGdyYXBoID0gc2VyaWVzTW9kZWwuZ2V0R3JhcGgoKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBsYXlvdXRJbmZvID0gc2VyaWVzTW9kZWwubGF5b3V0SW5mbztcbiAgICAvLyB2aWV3IHdpZHRoXG4gICAgdmFyIHdpZHRoID0gbGF5b3V0SW5mby53aWR0aDtcbiAgICAvLyB2aWV3IGhlaWdodFxuICAgIHZhciBoZWlnaHQgPSBsYXlvdXRJbmZvLmhlaWdodDtcbiAgICB2YXIgbm9kZURhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGVkZ2VEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgnZWRnZScpO1xuICAgIHZhciBvcmllbnQgPSBzZXJpZXNNb2RlbC5nZXQoJ29yaWVudCcpO1xuICAgIHRoaXMuX21vZGVsID0gc2VyaWVzTW9kZWw7XG4gICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgZ3JvdXAueCA9IGxheW91dEluZm8ueDtcbiAgICBncm91cC55ID0gbGF5b3V0SW5mby55O1xuICAgIC8vIGdlbmVyYXRlIGEgYmV6aXJlIEN1cnZlIGZvciBlYWNoIGVkZ2VcbiAgICBncmFwaC5lYWNoRWRnZShmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgdmFyIGN1cnZlID0gbmV3IFNhbmtleVBhdGgoKTtcbiAgICAgIHZhciBlY0RhdGEgPSBnZXRFQ0RhdGEoY3VydmUpO1xuICAgICAgZWNEYXRhLmRhdGFJbmRleCA9IGVkZ2UuZGF0YUluZGV4O1xuICAgICAgZWNEYXRhLnNlcmllc0luZGV4ID0gc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXg7XG4gICAgICBlY0RhdGEuZGF0YVR5cGUgPSAnZWRnZSc7XG4gICAgICB2YXIgZWRnZU1vZGVsID0gZWRnZS5nZXRNb2RlbCgpO1xuICAgICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gZWRnZU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgICAgIHZhciBjdXJ2YXR1cmUgPSBsaW5lU3R5bGVNb2RlbC5nZXQoJ2N1cnZlbmVzcycpO1xuICAgICAgdmFyIG4xTGF5b3V0ID0gZWRnZS5ub2RlMS5nZXRMYXlvdXQoKTtcbiAgICAgIHZhciBub2RlMU1vZGVsID0gZWRnZS5ub2RlMS5nZXRNb2RlbCgpO1xuICAgICAgdmFyIGRyYWdYMSA9IG5vZGUxTW9kZWwuZ2V0KCdsb2NhbFgnKTtcbiAgICAgIHZhciBkcmFnWTEgPSBub2RlMU1vZGVsLmdldCgnbG9jYWxZJyk7XG4gICAgICB2YXIgbjJMYXlvdXQgPSBlZGdlLm5vZGUyLmdldExheW91dCgpO1xuICAgICAgdmFyIG5vZGUyTW9kZWwgPSBlZGdlLm5vZGUyLmdldE1vZGVsKCk7XG4gICAgICB2YXIgZHJhZ1gyID0gbm9kZTJNb2RlbC5nZXQoJ2xvY2FsWCcpO1xuICAgICAgdmFyIGRyYWdZMiA9IG5vZGUyTW9kZWwuZ2V0KCdsb2NhbFknKTtcbiAgICAgIHZhciBlZGdlTGF5b3V0ID0gZWRnZS5nZXRMYXlvdXQoKTtcbiAgICAgIHZhciB4MTtcbiAgICAgIHZhciB5MTtcbiAgICAgIHZhciB4MjtcbiAgICAgIHZhciB5MjtcbiAgICAgIHZhciBjcHgxO1xuICAgICAgdmFyIGNweTE7XG4gICAgICB2YXIgY3B4MjtcbiAgICAgIHZhciBjcHkyO1xuICAgICAgY3VydmUuc2hhcGUuZXh0ZW50ID0gTWF0aC5tYXgoMSwgZWRnZUxheW91dC5keSk7XG4gICAgICBjdXJ2ZS5zaGFwZS5vcmllbnQgPSBvcmllbnQ7XG4gICAgICBpZiAob3JpZW50ID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIHgxID0gKGRyYWdYMSAhPSBudWxsID8gZHJhZ1gxICogd2lkdGggOiBuMUxheW91dC54KSArIGVkZ2VMYXlvdXQuc3k7XG4gICAgICAgIHkxID0gKGRyYWdZMSAhPSBudWxsID8gZHJhZ1kxICogaGVpZ2h0IDogbjFMYXlvdXQueSkgKyBuMUxheW91dC5keTtcbiAgICAgICAgeDIgPSAoZHJhZ1gyICE9IG51bGwgPyBkcmFnWDIgKiB3aWR0aCA6IG4yTGF5b3V0LngpICsgZWRnZUxheW91dC50eTtcbiAgICAgICAgeTIgPSBkcmFnWTIgIT0gbnVsbCA/IGRyYWdZMiAqIGhlaWdodCA6IG4yTGF5b3V0Lnk7XG4gICAgICAgIGNweDEgPSB4MTtcbiAgICAgICAgY3B5MSA9IHkxICogKDEgLSBjdXJ2YXR1cmUpICsgeTIgKiBjdXJ2YXR1cmU7XG4gICAgICAgIGNweDIgPSB4MjtcbiAgICAgICAgY3B5MiA9IHkxICogY3VydmF0dXJlICsgeTIgKiAoMSAtIGN1cnZhdHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MSA9IChkcmFnWDEgIT0gbnVsbCA/IGRyYWdYMSAqIHdpZHRoIDogbjFMYXlvdXQueCkgKyBuMUxheW91dC5keDtcbiAgICAgICAgeTEgPSAoZHJhZ1kxICE9IG51bGwgPyBkcmFnWTEgKiBoZWlnaHQgOiBuMUxheW91dC55KSArIGVkZ2VMYXlvdXQuc3k7XG4gICAgICAgIHgyID0gZHJhZ1gyICE9IG51bGwgPyBkcmFnWDIgKiB3aWR0aCA6IG4yTGF5b3V0Lng7XG4gICAgICAgIHkyID0gKGRyYWdZMiAhPSBudWxsID8gZHJhZ1kyICogaGVpZ2h0IDogbjJMYXlvdXQueSkgKyBlZGdlTGF5b3V0LnR5O1xuICAgICAgICBjcHgxID0geDEgKiAoMSAtIGN1cnZhdHVyZSkgKyB4MiAqIGN1cnZhdHVyZTtcbiAgICAgICAgY3B5MSA9IHkxO1xuICAgICAgICBjcHgyID0geDEgKiBjdXJ2YXR1cmUgKyB4MiAqICgxIC0gY3VydmF0dXJlKTtcbiAgICAgICAgY3B5MiA9IHkyO1xuICAgICAgfVxuICAgICAgY3VydmUuc2V0U2hhcGUoe1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeDI6IHgyLFxuICAgICAgICB5MjogeTIsXG4gICAgICAgIGNweDE6IGNweDEsXG4gICAgICAgIGNweTE6IGNweTEsXG4gICAgICAgIGNweDI6IGNweDIsXG4gICAgICAgIGNweTI6IGNweTJcbiAgICAgIH0pO1xuICAgICAgY3VydmUudXNlU3R5bGUobGluZVN0eWxlTW9kZWwuZ2V0SXRlbVN0eWxlKCkpO1xuICAgICAgLy8gU3BlY2lhbCBjb2xvciwgdXNlIHNvdXJjZSBub2RlIGNvbG9yIG9yIHRhcmdldCBub2RlIGNvbG9yXG4gICAgICBhcHBseUN1cnZlU3R5bGUoY3VydmUuc3R5bGUsIG9yaWVudCwgZWRnZSk7XG4gICAgICB2YXIgZGVmYXVsdEVkZ2VMYWJlbFRleHQgPSBcIlwiICsgZWRnZU1vZGVsLmdldCgndmFsdWUnKTtcbiAgICAgIHZhciBlZGdlTGFiZWxTdGF0ZU1vZGVscyA9IGdldExhYmVsU3RhdGVzTW9kZWxzKGVkZ2VNb2RlbCwgJ2VkZ2VMYWJlbCcpO1xuICAgICAgc2V0TGFiZWxTdHlsZShjdXJ2ZSwgZWRnZUxhYmVsU3RhdGVNb2RlbHMsIHtcbiAgICAgICAgbGFiZWxGZXRjaGVyOiB7XG4gICAgICAgICAgZ2V0Rm9ybWF0dGVkTGFiZWw6IGZ1bmN0aW9uIChkYXRhSW5kZXgsIHN0YXRlTmFtZSwgZGF0YVR5cGUsIGxhYmVsRGltSW5kZXgsIGZvcm1hdHRlciwgZXh0ZW5kUGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWwoZGF0YUluZGV4LCBzdGF0ZU5hbWUsICdlZGdlJywgbGFiZWxEaW1JbmRleCxcbiAgICAgICAgICAgIC8vIGVuc3VyZSBlZGdlTGFiZWwgZm9ybWF0dGVyIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAvLyB0byBwcmV2ZW50IHRoZSBpbmhlcml0YW5jZSBmcm9tIGBsYWJlbC5mb3JtYXR0ZXJgIG9mIHRoZSBzZXJpZXNcbiAgICAgICAgICAgIHJldHJpZXZlMyhmb3JtYXR0ZXIsIGVkZ2VMYWJlbFN0YXRlTW9kZWxzLm5vcm1hbCAmJiBlZGdlTGFiZWxTdGF0ZU1vZGVscy5ub3JtYWwuZ2V0KCdmb3JtYXR0ZXInKSwgZGVmYXVsdEVkZ2VMYWJlbFRleHQpLCBleHRlbmRQYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWxEYXRhSW5kZXg6IGVkZ2UuZGF0YUluZGV4LFxuICAgICAgICBkZWZhdWx0VGV4dDogZGVmYXVsdEVkZ2VMYWJlbFRleHRcbiAgICAgIH0pO1xuICAgICAgY3VydmUuc2V0VGV4dENvbmZpZyh7XG4gICAgICAgIHBvc2l0aW9uOiAnaW5zaWRlJ1xuICAgICAgfSk7XG4gICAgICB2YXIgZW1waGFzaXNNb2RlbCA9IGVkZ2VNb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKTtcbiAgICAgIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChjdXJ2ZSwgZWRnZU1vZGVsLCAnbGluZVN0eWxlJywgZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IG1vZGVsLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgICBhcHBseUN1cnZlU3R5bGUoc3R5bGUsIG9yaWVudCwgZWRnZSk7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0pO1xuICAgICAgZ3JvdXAuYWRkKGN1cnZlKTtcbiAgICAgIGVkZ2VEYXRhLnNldEl0ZW1HcmFwaGljRWwoZWRnZS5kYXRhSW5kZXgsIGN1cnZlKTtcbiAgICAgIHZhciBmb2N1cyA9IGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpO1xuICAgICAgdG9nZ2xlSG92ZXJFbXBoYXNpcyhjdXJ2ZSwgZm9jdXMgPT09ICdhZGphY2VuY3knID8gZWRnZS5nZXRBZGphY2VudERhdGFJbmRpY2VzKCkgOiBmb2N1cyA9PT0gJ3RyYWplY3RvcnknID8gZWRnZS5nZXRUcmFqZWN0b3J5RGF0YUluZGljZXMoKSA6IGZvY3VzLCBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJyksIGVtcGhhc2lzTW9kZWwuZ2V0KCdkaXNhYmxlZCcpKTtcbiAgICB9KTtcbiAgICAvLyBHZW5lcmF0ZSBhIHJlY3QgZm9yIGVhY2ggbm9kZVxuICAgIGdyYXBoLmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gbm9kZS5nZXRMYXlvdXQoKTtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBub2RlLmdldE1vZGVsKCk7XG4gICAgICB2YXIgZHJhZ1ggPSBpdGVtTW9kZWwuZ2V0KCdsb2NhbFgnKTtcbiAgICAgIHZhciBkcmFnWSA9IGl0ZW1Nb2RlbC5nZXQoJ2xvY2FsWScpO1xuICAgICAgdmFyIGVtcGhhc2lzTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJyk7XG4gICAgICB2YXIgYm9yZGVyUmFkaXVzID0gaXRlbU1vZGVsLmdldChbJ2l0ZW1TdHlsZScsICdib3JkZXJSYWRpdXMnXSkgfHwgMDtcbiAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgeDogZHJhZ1ggIT0gbnVsbCA/IGRyYWdYICogd2lkdGggOiBsYXlvdXQueCxcbiAgICAgICAgICB5OiBkcmFnWSAhPSBudWxsID8gZHJhZ1kgKiBoZWlnaHQgOiBsYXlvdXQueSxcbiAgICAgICAgICB3aWR0aDogbGF5b3V0LmR4LFxuICAgICAgICAgIGhlaWdodDogbGF5b3V0LmR5LFxuICAgICAgICAgIHI6IGJvcmRlclJhZGl1c1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKS5nZXRJdGVtU3R5bGUoKSxcbiAgICAgICAgejI6IDEwXG4gICAgICB9KTtcbiAgICAgIHNldExhYmVsU3R5bGUocmVjdCwgZ2V0TGFiZWxTdGF0ZXNNb2RlbHMoaXRlbU1vZGVsKSwge1xuICAgICAgICBsYWJlbEZldGNoZXI6IHtcbiAgICAgICAgICBnZXRGb3JtYXR0ZWRMYWJlbDogZnVuY3Rpb24gKGRhdGFJbmRleCwgc3RhdGVOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWwoZGF0YUluZGV4LCBzdGF0ZU5hbWUsICdub2RlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbERhdGFJbmRleDogbm9kZS5kYXRhSW5kZXgsXG4gICAgICAgIGRlZmF1bHRUZXh0OiBub2RlLmlkXG4gICAgICB9KTtcbiAgICAgIHJlY3QuZGlzYWJsZUxhYmVsQW5pbWF0aW9uID0gdHJ1ZTtcbiAgICAgIHJlY3Quc2V0U3R5bGUoJ2ZpbGwnLCBub2RlLmdldFZpc3VhbCgnY29sb3InKSk7XG4gICAgICByZWN0LnNldFN0eWxlKCdkZWNhbCcsIG5vZGUuZ2V0VmlzdWFsKCdzdHlsZScpLmRlY2FsKTtcbiAgICAgIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChyZWN0LCBpdGVtTW9kZWwpO1xuICAgICAgZ3JvdXAuYWRkKHJlY3QpO1xuICAgICAgbm9kZURhdGEuc2V0SXRlbUdyYXBoaWNFbChub2RlLmRhdGFJbmRleCwgcmVjdCk7XG4gICAgICBnZXRFQ0RhdGEocmVjdCkuZGF0YVR5cGUgPSAnbm9kZSc7XG4gICAgICB2YXIgZm9jdXMgPSBlbXBoYXNpc01vZGVsLmdldCgnZm9jdXMnKTtcbiAgICAgIHRvZ2dsZUhvdmVyRW1waGFzaXMocmVjdCwgZm9jdXMgPT09ICdhZGphY2VuY3knID8gbm9kZS5nZXRBZGphY2VudERhdGFJbmRpY2VzKCkgOiBmb2N1cyA9PT0gJ3RyYWplY3RvcnknID8gbm9kZS5nZXRUcmFqZWN0b3J5RGF0YUluZGljZXMoKSA6IGZvY3VzLCBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJyksIGVtcGhhc2lzTW9kZWwuZ2V0KCdkaXNhYmxlZCcpKTtcbiAgICB9KTtcbiAgICBub2RlRGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwsIGRhdGFJbmRleCkge1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IG5vZGVEYXRhLmdldEl0ZW1Nb2RlbChkYXRhSW5kZXgpO1xuICAgICAgaWYgKGl0ZW1Nb2RlbC5nZXQoJ2RyYWdnYWJsZScpKSB7XG4gICAgICAgIGVsLmRyaWZ0ID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgICAgIHNhbmtleVZpZXcuX2ZvY3VzQWRqYWNlbmN5RGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc2hhcGUueCArPSBkeDtcbiAgICAgICAgICB0aGlzLnNoYXBlLnkgKz0gZHk7XG4gICAgICAgICAgdGhpcy5kaXJ0eSgpO1xuICAgICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAnZHJhZ05vZGUnLFxuICAgICAgICAgICAgc2VyaWVzSWQ6IHNlcmllc01vZGVsLmlkLFxuICAgICAgICAgICAgZGF0YUluZGV4OiBub2RlRGF0YS5nZXRSYXdJbmRleChkYXRhSW5kZXgpLFxuICAgICAgICAgICAgbG9jYWxYOiB0aGlzLnNoYXBlLnggLyB3aWR0aCxcbiAgICAgICAgICAgIGxvY2FsWTogdGhpcy5zaGFwZS55IC8gaGVpZ2h0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGVsLm9uZHJhZ2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzYW5rZXlWaWV3Ll9mb2N1c0FkamFjZW5jeURpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGVsLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIGVsLmN1cnNvciA9ICdtb3ZlJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXRoaXMuX2RhdGEgJiYgc2VyaWVzTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCkpIHtcbiAgICAgIGdyb3VwLnNldENsaXBQYXRoKGNyZWF0ZUdyaWRDbGlwU2hhcGUoZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCksIHNlcmllc01vZGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdyb3VwLnJlbW92ZUNsaXBQYXRoKCk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHRoaXMuX2RhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gIH07XG4gIFNhbmtleVZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcbiAgU2Fua2V5Vmlldy50eXBlID0gJ3NhbmtleSc7XG4gIHJldHVybiBTYW5rZXlWaWV3O1xufShDaGFydFZpZXcpO1xuLyoqXHJcbiAqIFNwZWNpYWwgY29sb3IsIHVzZSBzb3VyY2Ugbm9kZSBjb2xvciBvciB0YXJnZXQgbm9kZSBjb2xvclxyXG4gKiBAcGFyYW0gY3VydmVQcm9wcyBjdXJ2ZSdzIHN0eWxlIHRvIHBhcnNlXHJcbiAqIEBwYXJhbSBvcmllbnQgZGlyZWN0aW9uXHJcbiAqIEBwYXJhbSBlZGdlIGN1cnJlbnQgY3VydmUgZGF0YVxyXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Q3VydmVTdHlsZShjdXJ2ZVByb3BzLCBvcmllbnQsIGVkZ2UpIHtcbiAgc3dpdGNoIChjdXJ2ZVByb3BzLmZpbGwpIHtcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgY3VydmVQcm9wcy5maWxsID0gZWRnZS5ub2RlMS5nZXRWaXN1YWwoJ2NvbG9yJyk7XG4gICAgICBjdXJ2ZVByb3BzLmRlY2FsID0gZWRnZS5ub2RlMS5nZXRWaXN1YWwoJ3N0eWxlJykuZGVjYWw7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgY3VydmVQcm9wcy5maWxsID0gZWRnZS5ub2RlMi5nZXRWaXN1YWwoJ2NvbG9yJyk7XG4gICAgICBjdXJ2ZVByb3BzLmRlY2FsID0gZWRnZS5ub2RlMi5nZXRWaXN1YWwoJ3N0eWxlJykuZGVjYWw7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdncmFkaWVudCc6XG4gICAgICB2YXIgc291cmNlQ29sb3IgPSBlZGdlLm5vZGUxLmdldFZpc3VhbCgnY29sb3InKTtcbiAgICAgIHZhciB0YXJnZXRDb2xvciA9IGVkZ2Uubm9kZTIuZ2V0VmlzdWFsKCdjb2xvcicpO1xuICAgICAgaWYgKGlzU3RyaW5nKHNvdXJjZUNvbG9yKSAmJiBpc1N0cmluZyh0YXJnZXRDb2xvcikpIHtcbiAgICAgICAgY3VydmVQcm9wcy5maWxsID0gbmV3IGdyYXBoaWMuTGluZWFyR3JhZGllbnQoMCwgMCwgKyhvcmllbnQgPT09ICdob3Jpem9udGFsJyksICsob3JpZW50ID09PSAndmVydGljYWwnKSwgW3tcbiAgICAgICAgICBjb2xvcjogc291cmNlQ29sb3IsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjb2xvcjogdGFyZ2V0Q29sb3IsXG4gICAgICAgICAgb2Zmc2V0OiAxXG4gICAgICAgIH1dKTtcbiAgICAgIH1cbiAgfVxufVxuLy8gQWRkIGFuaW1hdGlvbiB0byB0aGUgdmlld1xuZnVuY3Rpb24gY3JlYXRlR3JpZENsaXBTaGFwZShyZWN0LCBzZXJpZXNNb2RlbCwgY2IpIHtcbiAgdmFyIHJlY3RFbCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgIHNoYXBlOiB7XG4gICAgICB4OiByZWN0LnggLSAxMCxcbiAgICAgIHk6IHJlY3QueSAtIDEwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICsgMjBcbiAgICB9XG4gIH0pO1xuICBncmFwaGljLmluaXRQcm9wcyhyZWN0RWwsIHtcbiAgICBzaGFwZToge1xuICAgICAgd2lkdGg6IHJlY3Qud2lkdGggKyAyMFxuICAgIH1cbiAgfSwgc2VyaWVzTW9kZWwsIGNiKTtcbiAgcmV0dXJuIHJlY3RFbDtcbn1cbmV4cG9ydCBkZWZhdWx0IFNhbmtleVZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMuanMnO1xuaW1wb3J0IGNyZWF0ZUdyYXBoRnJvbU5vZGVFZGdlIGZyb20gJy4uL2hlbHBlci9jcmVhdGVHcmFwaEZyb21Ob2RlRWRnZS5qcyc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvTW9kZWwuanMnO1xuaW1wb3J0IHsgY3JlYXRlVG9vbHRpcE1hcmt1cCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudC90b29sdGlwL3Rvb2x0aXBNYXJrdXAuanMnO1xudmFyIFNhbmtleVNlcmllc01vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNhbmtleVNlcmllc01vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBTYW5rZXlTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gU2Fua2V5U2VyaWVzTW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogSW5pdCBhIGdyYXBoIGRhdGEgc3RydWN0dXJlIGZyb20gZGF0YSBpbiBvcHRpb24gc2VyaWVzXHJcbiAgICovXG4gIFNhbmtleVNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICB2YXIgbGlua3MgPSBvcHRpb24uZWRnZXMgfHwgb3B0aW9uLmxpbmtzIHx8IFtdO1xuICAgIHZhciBub2RlcyA9IG9wdGlvbi5kYXRhIHx8IG9wdGlvbi5ub2RlcyB8fCBbXTtcbiAgICB2YXIgbGV2ZWxzID0gb3B0aW9uLmxldmVscyB8fCBbXTtcbiAgICB0aGlzLmxldmVsTW9kZWxzID0gW107XG4gICAgdmFyIGxldmVsTW9kZWxzID0gdGhpcy5sZXZlbE1vZGVscztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxldmVsc1tpXS5kZXB0aCAhPSBudWxsICYmIGxldmVsc1tpXS5kZXB0aCA+PSAwKSB7XG4gICAgICAgIGxldmVsTW9kZWxzW2xldmVsc1tpXS5kZXB0aF0gPSBuZXcgTW9kZWwobGV2ZWxzW2ldLCB0aGlzLCBlY01vZGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZXZlbHNbaV0uZGVwdGggaXMgbWFuZGF0b3J5IGFuZCBzaG91bGQgYmUgbmF0dXJhbCBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZ3JhcGggPSBjcmVhdGVHcmFwaEZyb21Ob2RlRWRnZShub2RlcywgbGlua3MsIHRoaXMsIHRydWUsIGJlZm9yZUxpbmspO1xuICAgIHJldHVybiBncmFwaC5kYXRhO1xuICAgIGZ1bmN0aW9uIGJlZm9yZUxpbmsobm9kZURhdGEsIGVkZ2VEYXRhKSB7XG4gICAgICBub2RlRGF0YS53cmFwTWV0aG9kKCdnZXRJdGVtTW9kZWwnLCBmdW5jdGlvbiAobW9kZWwsIGlkeCkge1xuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBtb2RlbC5wYXJlbnRNb2RlbDtcbiAgICAgICAgdmFyIGxheW91dCA9IHNlcmllc01vZGVsLmdldERhdGEoKS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgICB2YXIgbm9kZURlcHRoID0gbGF5b3V0LmRlcHRoO1xuICAgICAgICAgIHZhciBsZXZlbE1vZGVsID0gc2VyaWVzTW9kZWwubGV2ZWxNb2RlbHNbbm9kZURlcHRoXTtcbiAgICAgICAgICBpZiAobGV2ZWxNb2RlbCkge1xuICAgICAgICAgICAgbW9kZWwucGFyZW50TW9kZWwgPSBsZXZlbE1vZGVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICB9KTtcbiAgICAgIGVkZ2VEYXRhLndyYXBNZXRob2QoJ2dldEl0ZW1Nb2RlbCcsIGZ1bmN0aW9uIChtb2RlbCwgaWR4KSB7XG4gICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IG1vZGVsLnBhcmVudE1vZGVsO1xuICAgICAgICB2YXIgZWRnZSA9IHNlcmllc01vZGVsLmdldEdyYXBoKCkuZ2V0RWRnZUJ5SW5kZXgoaWR4KTtcbiAgICAgICAgdmFyIGxheW91dCA9IGVkZ2Uubm9kZTEuZ2V0TGF5b3V0KCk7XG4gICAgICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgICB2YXIgZGVwdGggPSBsYXlvdXQuZGVwdGg7XG4gICAgICAgICAgdmFyIGxldmVsTW9kZWwgPSBzZXJpZXNNb2RlbC5sZXZlbE1vZGVsc1tkZXB0aF07XG4gICAgICAgICAgaWYgKGxldmVsTW9kZWwpIHtcbiAgICAgICAgICAgIG1vZGVsLnBhcmVudE1vZGVsID0gbGV2ZWxNb2RlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBTYW5rZXlTZXJpZXNNb2RlbC5wcm90b3R5cGUuc2V0Tm9kZVBvc2l0aW9uID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgbG9jYWxQb3NpdGlvbikge1xuICAgIHZhciBub2RlcyA9IHRoaXMub3B0aW9uLmRhdGEgfHwgdGhpcy5vcHRpb24ubm9kZXM7XG4gICAgdmFyIGRhdGFJdGVtID0gbm9kZXNbZGF0YUluZGV4XTtcbiAgICBkYXRhSXRlbS5sb2NhbFggPSBsb2NhbFBvc2l0aW9uWzBdO1xuICAgIGRhdGFJdGVtLmxvY2FsWSA9IGxvY2FsUG9zaXRpb25bMV07XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgZ3JhcGhpYyBkYXRhIHN0cnVjdHVyZVxyXG4gICAqXHJcbiAgICogQHJldHVybiBncmFwaGljIGRhdGEgc3RydWN0dXJlXHJcbiAgICovXG4gIFNhbmtleVNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRHcmFwaCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREYXRhKCkuZ3JhcGg7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCBlZGdlIGRhdGEgb2YgZ3JhcGhpYyBkYXRhIHN0cnVjdHVyZVxyXG4gICAqXHJcbiAgICogQHJldHVybiBkYXRhIHN0cnVjdHVyZSBvZiBsaXN0XHJcbiAgICovXG4gIFNhbmtleVNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRFZGdlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRHcmFwaCgpLmVkZ2VEYXRhO1xuICB9O1xuICBTYW5rZXlTZXJpZXNNb2RlbC5wcm90b3R5cGUuZm9ybWF0VG9vbHRpcCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIG11bHRpcGxlU2VyaWVzLCBkYXRhVHlwZSkge1xuICAgIGZ1bmN0aW9uIG5vVmFsdWUodmFsKSB7XG4gICAgICByZXR1cm4gaXNOYU4odmFsKSB8fCB2YWwgPT0gbnVsbDtcbiAgICB9XG4gICAgLy8gZGF0YVR5cGUgPT09ICdub2RlJyBvciBlbXB0eSBkbyBub3Qgc2hvdyB0b29sdGlwIGJ5IGRlZmF1bHRcbiAgICBpZiAoZGF0YVR5cGUgPT09ICdlZGdlJykge1xuICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgsIGRhdGFUeXBlKTtcbiAgICAgIHZhciByYXdEYXRhT3B0ID0gcGFyYW1zLmRhdGE7XG4gICAgICB2YXIgZWRnZVZhbHVlID0gcGFyYW1zLnZhbHVlO1xuICAgICAgdmFyIGVkZ2VOYW1lID0gcmF3RGF0YU9wdC5zb3VyY2UgKyAnIC0tICcgKyByYXdEYXRhT3B0LnRhcmdldDtcbiAgICAgIHJldHVybiBjcmVhdGVUb29sdGlwTWFya3VwKCduYW1lVmFsdWUnLCB7XG4gICAgICAgIG5hbWU6IGVkZ2VOYW1lLFxuICAgICAgICB2YWx1ZTogZWRnZVZhbHVlLFxuICAgICAgICBub1ZhbHVlOiBub1ZhbHVlKGVkZ2VWYWx1ZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBkYXRhVHlwZSA9PT0gJ25vZGUnXG4gICAgZWxzZSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0R3JhcGgoKS5nZXROb2RlQnlJbmRleChkYXRhSW5kZXgpO1xuICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRMYXlvdXQoKS52YWx1ZTtcbiAgICAgIHZhciBuYW1lXzEgPSB0aGlzLmdldERhdGFQYXJhbXMoZGF0YUluZGV4LCBkYXRhVHlwZSkuZGF0YS5uYW1lO1xuICAgICAgcmV0dXJuIGNyZWF0ZVRvb2x0aXBNYXJrdXAoJ25hbWVWYWx1ZScsIHtcbiAgICAgICAgbmFtZTogbmFtZV8xICE9IG51bGwgPyBuYW1lXzEgKyAnJyA6IG51bGwsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbm9WYWx1ZTogbm9WYWx1ZSh2YWx1ZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgU2Fua2V5U2VyaWVzTW9kZWwucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgLy8gT3ZlcnJpZGUgU2VyaWVzLmdldERhdGFQYXJhbXMoKVxuICBTYW5rZXlTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0RGF0YVBhcmFtcyA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIGRhdGFUeXBlKSB7XG4gICAgdmFyIHBhcmFtcyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0RGF0YVBhcmFtcy5jYWxsKHRoaXMsIGRhdGFJbmRleCwgZGF0YVR5cGUpO1xuICAgIGlmIChwYXJhbXMudmFsdWUgPT0gbnVsbCAmJiBkYXRhVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0R3JhcGgoKS5nZXROb2RlQnlJbmRleChkYXRhSW5kZXgpO1xuICAgICAgdmFyIG5vZGVWYWx1ZSA9IG5vZGUuZ2V0TGF5b3V0KCkudmFsdWU7XG4gICAgICBwYXJhbXMudmFsdWUgPSBub2RlVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG4gIH07XG4gIFNhbmtleVNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLnNhbmtleSc7XG4gIFNhbmtleVNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgLy8gemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgY29vcmRpbmF0ZVN5c3RlbTogJ3ZpZXcnLFxuICAgIGxlZnQ6ICc1JScsXG4gICAgdG9wOiAnNSUnLFxuICAgIHJpZ2h0OiAnMjAlJyxcbiAgICBib3R0b206ICc1JScsXG4gICAgb3JpZW50OiAnaG9yaXpvbnRhbCcsXG4gICAgbm9kZVdpZHRoOiAyMCxcbiAgICBub2RlR2FwOiA4LFxuICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICBsYXlvdXRJdGVyYXRpb25zOiAzMixcbiAgICBsYWJlbDoge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgZm9udFNpemU6IDEyXG4gICAgfSxcbiAgICBlZGdlTGFiZWw6IHtcbiAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgZm9udFNpemU6IDEyXG4gICAgfSxcbiAgICBsZXZlbHM6IFtdLFxuICAgIG5vZGVBbGlnbjogJ2p1c3RpZnknLFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgY29sb3I6ICcjMzE0NjU2JyxcbiAgICAgIG9wYWNpdHk6IDAuMixcbiAgICAgIGN1cnZlbmVzczogMC41XG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBvcGFjaXR5OiAwLjVcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdDoge1xuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzIxMjEyMSdcbiAgICAgIH1cbiAgICB9LFxuICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcicsXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDEwMDBcbiAgfTtcbiAgcmV0dXJuIFNhbmtleVNlcmllc01vZGVsO1xufShTZXJpZXNNb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBTYW5rZXlTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIGxheW91dCBmcm9tICcuLi8uLi91dGlsL2xheW91dC5qcyc7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGdyb3VwRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2Fua2V5TGF5b3V0KGVjTW9kZWwsIGFwaSkge1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ3NhbmtleScsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBub2RlV2lkdGggPSBzZXJpZXNNb2RlbC5nZXQoJ25vZGVXaWR0aCcpO1xuICAgIHZhciBub2RlR2FwID0gc2VyaWVzTW9kZWwuZ2V0KCdub2RlR2FwJyk7XG4gICAgdmFyIGxheW91dEluZm8gPSBnZXRWaWV3UmVjdChzZXJpZXNNb2RlbCwgYXBpKTtcbiAgICBzZXJpZXNNb2RlbC5sYXlvdXRJbmZvID0gbGF5b3V0SW5mbztcbiAgICB2YXIgd2lkdGggPSBsYXlvdXRJbmZvLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBsYXlvdXRJbmZvLmhlaWdodDtcbiAgICB2YXIgZ3JhcGggPSBzZXJpZXNNb2RlbC5nZXRHcmFwaCgpO1xuICAgIHZhciBub2RlcyA9IGdyYXBoLm5vZGVzO1xuICAgIHZhciBlZGdlcyA9IGdyYXBoLmVkZ2VzO1xuICAgIGNvbXB1dGVOb2RlVmFsdWVzKG5vZGVzKTtcbiAgICB2YXIgZmlsdGVyZWROb2RlcyA9IHpyVXRpbC5maWx0ZXIobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5nZXRMYXlvdXQoKS52YWx1ZSA9PT0gMDtcbiAgICB9KTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IGZpbHRlcmVkTm9kZXMubGVuZ3RoICE9PSAwID8gMCA6IHNlcmllc01vZGVsLmdldCgnbGF5b3V0SXRlcmF0aW9ucycpO1xuICAgIHZhciBvcmllbnQgPSBzZXJpZXNNb2RlbC5nZXQoJ29yaWVudCcpO1xuICAgIHZhciBub2RlQWxpZ24gPSBzZXJpZXNNb2RlbC5nZXQoJ25vZGVBbGlnbicpO1xuICAgIGxheW91dFNhbmtleShub2RlcywgZWRnZXMsIG5vZGVXaWR0aCwgbm9kZUdhcCwgd2lkdGgsIGhlaWdodCwgaXRlcmF0aW9ucywgb3JpZW50LCBub2RlQWxpZ24pO1xuICB9KTtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIGxheW91dCBwb3NpdGlvbiBvZiB0aGUgd2hvbGUgdmlld1xyXG4gKi9cbmZ1bmN0aW9uIGdldFZpZXdSZWN0KHNlcmllc01vZGVsLCBhcGkpIHtcbiAgcmV0dXJuIGxheW91dC5nZXRMYXlvdXRSZWN0KHNlcmllc01vZGVsLmdldEJveExheW91dFBhcmFtcygpLCB7XG4gICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gIH0pO1xufVxuZnVuY3Rpb24gbGF5b3V0U2Fua2V5KG5vZGVzLCBlZGdlcywgbm9kZVdpZHRoLCBub2RlR2FwLCB3aWR0aCwgaGVpZ2h0LCBpdGVyYXRpb25zLCBvcmllbnQsIG5vZGVBbGlnbikge1xuICBjb21wdXRlTm9kZUJyZWFkdGhzKG5vZGVzLCBlZGdlcywgbm9kZVdpZHRoLCB3aWR0aCwgaGVpZ2h0LCBvcmllbnQsIG5vZGVBbGlnbik7XG4gIGNvbXB1dGVOb2RlRGVwdGhzKG5vZGVzLCBlZGdlcywgaGVpZ2h0LCB3aWR0aCwgbm9kZUdhcCwgaXRlcmF0aW9ucywgb3JpZW50KTtcbiAgY29tcHV0ZUVkZ2VEZXB0aHMobm9kZXMsIG9yaWVudCk7XG59XG4vKipcclxuICogQ29tcHV0ZSB0aGUgdmFsdWUgb2YgZWFjaCBub2RlIGJ5IHN1bW1pbmcgdGhlIGFzc29jaWF0ZWQgZWRnZSdzIHZhbHVlXHJcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZU5vZGVWYWx1ZXMobm9kZXMpIHtcbiAgenJVdGlsLmVhY2gobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIHZhbHVlMSA9IHN1bShub2RlLm91dEVkZ2VzLCBnZXRFZGdlVmFsdWUpO1xuICAgIHZhciB2YWx1ZTIgPSBzdW0obm9kZS5pbkVkZ2VzLCBnZXRFZGdlVmFsdWUpO1xuICAgIHZhciBub2RlUmF3VmFsdWUgPSBub2RlLmdldFZhbHVlKCkgfHwgMDtcbiAgICB2YXIgdmFsdWUgPSBNYXRoLm1heCh2YWx1ZTEsIHZhbHVlMiwgbm9kZVJhd1ZhbHVlKTtcbiAgICBub2RlLnNldExheW91dCh7XG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9LCB0cnVlKTtcbiAgfSk7XG59XG4vKipcclxuICogQ29tcHV0ZSB0aGUgeC1wb3NpdGlvbiBmb3IgZWFjaCBub2RlLlxyXG4gKlxyXG4gKiBIZXJlIHdlIHVzZSBLYWhuIGFsZ29yaXRobSB0byBkZXRlY3QgY3ljbGUgd2hlbiB3ZSB0cmF2ZXJzZVxyXG4gKiB0aGUgbm9kZSB0byBjb21wdXRlciB0aGUgaW5pdGlhbCB4IHBvc2l0aW9uLlxyXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVOb2RlQnJlYWR0aHMobm9kZXMsIGVkZ2VzLCBub2RlV2lkdGgsIHdpZHRoLCBoZWlnaHQsIG9yaWVudCwgbm9kZUFsaWduKSB7XG4gIC8vIFVzZWQgdG8gbWFyayB3aGV0aGVyIHRoZSBlZGdlIGlzIGRlbGV0ZWQuIGlmIGl0IGlzIGRlbGV0ZWQsXG4gIC8vIHRoZSB2YWx1ZSBpcyAwLCBvdGhlcndpc2UgaXQgaXMgMS5cbiAgdmFyIHJlbWFpbkVkZ2VzID0gW107XG4gIC8vIFN0b3JhZ2UgZWFjaCBub2RlJ3MgaW5kZWdyZWUuXG4gIHZhciBpbmRlZ3JlZUFyciA9IFtdO1xuICAvLyBVc2VkIHRvIHN0b3JhZ2UgdGhlIG5vZGUgd2l0aCBpbmRlZ3JlZSBpcyBlcXVhbCB0byAwLlxuICB2YXIgemVyb0luZGVncmVlcyA9IFtdO1xuICB2YXIgbmV4dFRhcmdldE5vZGUgPSBbXTtcbiAgdmFyIHggPSAwO1xuICAvLyBsZXQga3ggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVtYWluRWRnZXNbaV0gPSAxO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpbmRlZ3JlZUFycltpXSA9IG5vZGVzW2ldLmluRWRnZXMubGVuZ3RoO1xuICAgIGlmIChpbmRlZ3JlZUFycltpXSA9PT0gMCkge1xuICAgICAgemVyb0luZGVncmVlcy5wdXNoKG5vZGVzW2ldKTtcbiAgICB9XG4gIH1cbiAgdmFyIG1heE5vZGVEZXB0aCA9IC0xO1xuICAvLyBUcmF2ZXJzaW5nIG5vZGVzIHVzaW5nIHRvcG9sb2dpY2FsIHNvcnRpbmcgdG8gY2FsY3VsYXRlIHRoZVxuICAvLyBob3Jpem9udGFsKGlmIG9yaWVudCA9PT0gJ2hvcml6b250YWwnKSBvciB2ZXJ0aWNhbChpZiBvcmllbnQgPT09ICd2ZXJ0aWNhbCcpXG4gIC8vIHBvc2l0aW9uIG9mIHRoZSBub2Rlcy5cbiAgd2hpbGUgKHplcm9JbmRlZ3JlZXMubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgemVyb0luZGVncmVlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICB2YXIgbm9kZSA9IHplcm9JbmRlZ3JlZXNbaWR4XTtcbiAgICAgIHZhciBpdGVtID0gbm9kZS5ob3N0R3JhcGguZGF0YS5nZXRSYXdEYXRhSXRlbShub2RlLmRhdGFJbmRleCk7XG4gICAgICB2YXIgaXNJdGVtRGVwdGggPSBpdGVtLmRlcHRoICE9IG51bGwgJiYgaXRlbS5kZXB0aCA+PSAwO1xuICAgICAgaWYgKGlzSXRlbURlcHRoICYmIGl0ZW0uZGVwdGggPiBtYXhOb2RlRGVwdGgpIHtcbiAgICAgICAgbWF4Tm9kZURlcHRoID0gaXRlbS5kZXB0aDtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgZGVwdGg6IGlzSXRlbURlcHRoID8gaXRlbS5kZXB0aCA6IHhcbiAgICAgIH0sIHRydWUpO1xuICAgICAgb3JpZW50ID09PSAndmVydGljYWwnID8gbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgICBkeTogbm9kZVdpZHRoXG4gICAgICB9LCB0cnVlKSA6IG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgZHg6IG5vZGVXaWR0aFxuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBmb3IgKHZhciBlZGdlSWR4ID0gMDsgZWRnZUlkeCA8IG5vZGUub3V0RWRnZXMubGVuZ3RoOyBlZGdlSWR4KyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBub2RlLm91dEVkZ2VzW2VkZ2VJZHhdO1xuICAgICAgICB2YXIgaW5kZXhFZGdlID0gZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICAgICAgcmVtYWluRWRnZXNbaW5kZXhFZGdlXSA9IDA7XG4gICAgICAgIHZhciB0YXJnZXROb2RlID0gZWRnZS5ub2RlMjtcbiAgICAgICAgdmFyIG5vZGVJbmRleCA9IG5vZGVzLmluZGV4T2YodGFyZ2V0Tm9kZSk7XG4gICAgICAgIGlmICgtLWluZGVncmVlQXJyW25vZGVJbmRleF0gPT09IDAgJiYgbmV4dFRhcmdldE5vZGUuaW5kZXhPZih0YXJnZXROb2RlKSA8IDApIHtcbiAgICAgICAgICBuZXh0VGFyZ2V0Tm9kZS5wdXNoKHRhcmdldE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgICsreDtcbiAgICB6ZXJvSW5kZWdyZWVzID0gbmV4dFRhcmdldE5vZGU7XG4gICAgbmV4dFRhcmdldE5vZGUgPSBbXTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbWFpbkVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlbWFpbkVkZ2VzW2ldID09PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NhbmtleSBpcyBhIERBRywgdGhlIG9yaWdpbmFsIGRhdGEgaGFzIGN5Y2xlIScpO1xuICAgIH1cbiAgfVxuICB2YXIgbWF4RGVwdGggPSBtYXhOb2RlRGVwdGggPiB4IC0gMSA/IG1heE5vZGVEZXB0aCA6IHggLSAxO1xuICBpZiAobm9kZUFsaWduICYmIG5vZGVBbGlnbiAhPT0gJ2xlZnQnKSB7XG4gICAgYWRqdXN0Tm9kZVdpdGhOb2RlQWxpZ24obm9kZXMsIG5vZGVBbGlnbiwgb3JpZW50LCBtYXhEZXB0aCk7XG4gIH1cbiAgdmFyIGt4ID0gb3JpZW50ID09PSAndmVydGljYWwnID8gKGhlaWdodCAtIG5vZGVXaWR0aCkgLyBtYXhEZXB0aCA6ICh3aWR0aCAtIG5vZGVXaWR0aCkgLyBtYXhEZXB0aDtcbiAgc2NhbGVOb2RlQnJlYWR0aHMobm9kZXMsIGt4LCBvcmllbnQpO1xufVxuZnVuY3Rpb24gaXNOb2RlRGVwdGgobm9kZSkge1xuICB2YXIgaXRlbSA9IG5vZGUuaG9zdEdyYXBoLmRhdGEuZ2V0UmF3RGF0YUl0ZW0obm9kZS5kYXRhSW5kZXgpO1xuICByZXR1cm4gaXRlbS5kZXB0aCAhPSBudWxsICYmIGl0ZW0uZGVwdGggPj0gMDtcbn1cbmZ1bmN0aW9uIGFkanVzdE5vZGVXaXRoTm9kZUFsaWduKG5vZGVzLCBub2RlQWxpZ24sIG9yaWVudCwgbWF4RGVwdGgpIHtcbiAgaWYgKG5vZGVBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHZhciBuZXh0U291cmNlTm9kZSA9IFtdO1xuICAgIHZhciByZW1haW5Ob2RlcyA9IG5vZGVzO1xuICAgIHZhciBub2RlSGVpZ2h0ID0gMDtcbiAgICB3aGlsZSAocmVtYWluTm9kZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbWFpbk5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gcmVtYWluTm9kZXNbaV07XG4gICAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgICBza05vZGVIZWlnaHQ6IG5vZGVIZWlnaHRcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZS5pbkVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmluRWRnZXNbal07XG4gICAgICAgICAgaWYgKG5leHRTb3VyY2VOb2RlLmluZGV4T2YoZWRnZS5ub2RlMSkgPCAwKSB7XG4gICAgICAgICAgICBuZXh0U291cmNlTm9kZS5wdXNoKGVkZ2Uubm9kZTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVtYWluTm9kZXMgPSBuZXh0U291cmNlTm9kZTtcbiAgICAgIG5leHRTb3VyY2VOb2RlID0gW107XG4gICAgICArK25vZGVIZWlnaHQ7XG4gICAgfVxuICAgIHpyVXRpbC5lYWNoKG5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKCFpc05vZGVEZXB0aChub2RlKSkge1xuICAgICAgICBub2RlLnNldExheW91dCh7XG4gICAgICAgICAgZGVwdGg6IE1hdGgubWF4KDAsIG1heERlcHRoIC0gbm9kZS5nZXRMYXlvdXQoKS5za05vZGVIZWlnaHQpXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKG5vZGVBbGlnbiA9PT0gJ2p1c3RpZnknKSB7XG4gICAgbW92ZVNpbmtzUmlnaHQobm9kZXMsIG1heERlcHRoKTtcbiAgfVxufVxuLyoqXHJcbiAqIEFsbCB0aGUgbm9kZSB3aXRob3V0IG91dEVnZGVzIGFyZSBhc3NpZ25lZCBtYXhpbXVtIHgtcG9zaXRpb24gYW5kXHJcbiAqICAgICBiZSBhbGlnbmVkIGluIHRoZSBsYXN0IGNvbHVtbi5cclxuICpcclxuICogQHBhcmFtIG5vZGVzLiAgbm9kZSBvZiBzYW5rZXkgdmlldy5cclxuICogQHBhcmFtIG1heERlcHRoLiAgdXNlIHRvIGFzc2lnbiB0byBub2RlIHdpdGhvdXQgb3V0RWRnZXMgYXMgeC1wb3NpdGlvbi5cclxuICovXG5mdW5jdGlvbiBtb3ZlU2lua3NSaWdodChub2RlcywgbWF4RGVwdGgpIHtcbiAgenJVdGlsLmVhY2gobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKCFpc05vZGVEZXB0aChub2RlKSAmJiAhbm9kZS5vdXRFZGdlcy5sZW5ndGgpIHtcbiAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgZGVwdGg6IG1heERlcHRoXG4gICAgICB9LCB0cnVlKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXHJcbiAqIFNjYWxlIG5vZGUgeC1wb3NpdGlvbiB0byB0aGUgd2lkdGhcclxuICpcclxuICogQHBhcmFtIG5vZGVzICBub2RlIG9mIHNhbmtleSB2aWV3XHJcbiAqIEBwYXJhbSBreCAgIG11bHRpcGxlIHVzZWQgdG8gc2NhbGUgbm9kZXNcclxuICovXG5mdW5jdGlvbiBzY2FsZU5vZGVCcmVhZHRocyhub2Rlcywga3gsIG9yaWVudCkge1xuICB6clV0aWwuZWFjaChub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgbm9kZURlcHRoID0gbm9kZS5nZXRMYXlvdXQoKS5kZXB0aCAqIGt4O1xuICAgIG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/IG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgIHk6IG5vZGVEZXB0aFxuICAgIH0sIHRydWUpIDogbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgeDogbm9kZURlcHRoXG4gICAgfSwgdHJ1ZSk7XG4gIH0pO1xufVxuLyoqXHJcbiAqIFVzaW5nIEdhdXNzLVNlaWRlbCBpdGVyYXRpb25zIG1ldGhvZCB0byBjb21wdXRlIHRoZSBub2RlIGRlcHRoKHktcG9zaXRpb24pXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlcyAgbm9kZSBvZiBzYW5rZXkgdmlld1xyXG4gKiBAcGFyYW0gZWRnZXMgIGVkZ2Ugb2Ygc2Fua2V5IHZpZXdcclxuICogQHBhcmFtIGhlaWdodCAgdGhlIHdob2xlIGhlaWdodCBvZiB0aGUgYXJlYSB0byBkcmF3IHRoZSB2aWV3XHJcbiAqIEBwYXJhbSBub2RlR2FwICB0aGUgdmVydGljYWwgZGlzdGFuY2UgYmV0d2VlbiB0d28gbm9kZXNcclxuICogICAgIGluIHRoZSBzYW1lIGNvbHVtbi5cclxuICogQHBhcmFtIGl0ZXJhdGlvbnMgIHRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyBmb3IgdGhlIGFsZ29yaXRobVxyXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVOb2RlRGVwdGhzKG5vZGVzLCBlZGdlcywgaGVpZ2h0LCB3aWR0aCwgbm9kZUdhcCwgaXRlcmF0aW9ucywgb3JpZW50KSB7XG4gIHZhciBub2Rlc0J5QnJlYWR0aCA9IHByZXBhcmVOb2Rlc0J5QnJlYWR0aChub2Rlcywgb3JpZW50KTtcbiAgaW5pdGlhbGl6ZU5vZGVEZXB0aChub2Rlc0J5QnJlYWR0aCwgZWRnZXMsIGhlaWdodCwgd2lkdGgsIG5vZGVHYXAsIG9yaWVudCk7XG4gIHJlc29sdmVDb2xsaXNpb25zKG5vZGVzQnlCcmVhZHRoLCBub2RlR2FwLCBoZWlnaHQsIHdpZHRoLCBvcmllbnQpO1xuICBmb3IgKHZhciBhbHBoYSA9IDE7IGl0ZXJhdGlvbnMgPiAwOyBpdGVyYXRpb25zLS0pIHtcbiAgICAvLyAwLjk5IGlzIGEgZXhwZXJpZW5jZSBwYXJhbWV0ZXIsIGVuc3VyZSB0aGF0IGVhY2ggaXRlcmF0aW9ucyBvZlxuICAgIC8vIGNoYW5nZXMgYXMgc21hbGwgYXMgcG9zc2libGUuXG4gICAgYWxwaGEgKj0gMC45OTtcbiAgICByZWxheFJpZ2h0VG9MZWZ0KG5vZGVzQnlCcmVhZHRoLCBhbHBoYSwgb3JpZW50KTtcbiAgICByZXNvbHZlQ29sbGlzaW9ucyhub2Rlc0J5QnJlYWR0aCwgbm9kZUdhcCwgaGVpZ2h0LCB3aWR0aCwgb3JpZW50KTtcbiAgICByZWxheExlZnRUb1JpZ2h0KG5vZGVzQnlCcmVhZHRoLCBhbHBoYSwgb3JpZW50KTtcbiAgICByZXNvbHZlQ29sbGlzaW9ucyhub2Rlc0J5QnJlYWR0aCwgbm9kZUdhcCwgaGVpZ2h0LCB3aWR0aCwgb3JpZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZU5vZGVzQnlCcmVhZHRoKG5vZGVzLCBvcmllbnQpIHtcbiAgdmFyIG5vZGVzQnlCcmVhZHRoID0gW107XG4gIHZhciBrZXlBdHRyID0gb3JpZW50ID09PSAndmVydGljYWwnID8gJ3knIDogJ3gnO1xuICB2YXIgZ3JvdXBSZXN1bHQgPSBncm91cERhdGEobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuZ2V0TGF5b3V0KClba2V5QXR0cl07XG4gIH0pO1xuICBncm91cFJlc3VsdC5rZXlzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pO1xuICB6clV0aWwuZWFjaChncm91cFJlc3VsdC5rZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgbm9kZXNCeUJyZWFkdGgucHVzaChncm91cFJlc3VsdC5idWNrZXRzLmdldChrZXkpKTtcbiAgfSk7XG4gIHJldHVybiBub2Rlc0J5QnJlYWR0aDtcbn1cbi8qKlxyXG4gKiBDb21wdXRlIHRoZSBvcmlnaW5hbCB5LXBvc2l0aW9uIGZvciBlYWNoIG5vZGVcclxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplTm9kZURlcHRoKG5vZGVzQnlCcmVhZHRoLCBlZGdlcywgaGVpZ2h0LCB3aWR0aCwgbm9kZUdhcCwgb3JpZW50KSB7XG4gIHZhciBtaW5LeSA9IEluZmluaXR5O1xuICB6clV0aWwuZWFjaChub2Rlc0J5QnJlYWR0aCwgZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgdmFyIG4gPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgenJVdGlsLmVhY2gobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBzdW0gKz0gbm9kZS5nZXRMYXlvdXQoKS52YWx1ZTtcbiAgICB9KTtcbiAgICB2YXIga3kgPSBvcmllbnQgPT09ICd2ZXJ0aWNhbCcgPyAod2lkdGggLSAobiAtIDEpICogbm9kZUdhcCkgLyBzdW0gOiAoaGVpZ2h0IC0gKG4gLSAxKSAqIG5vZGVHYXApIC8gc3VtO1xuICAgIGlmIChreSA8IG1pbkt5KSB7XG4gICAgICBtaW5LeSA9IGt5O1xuICAgIH1cbiAgfSk7XG4gIHpyVXRpbC5lYWNoKG5vZGVzQnlCcmVhZHRoLCBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICB6clV0aWwuZWFjaChub2RlcywgZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgIHZhciBub2RlRHkgPSBub2RlLmdldExheW91dCgpLnZhbHVlICogbWluS3k7XG4gICAgICBpZiAob3JpZW50ID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgICB4OiBpXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBub2RlLnNldExheW91dCh7XG4gICAgICAgICAgZHg6IG5vZGVEeVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgICB5OiBpXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBub2RlLnNldExheW91dCh7XG4gICAgICAgICAgZHk6IG5vZGVEeVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHpyVXRpbC5lYWNoKGVkZ2VzLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciBlZGdlRHkgPSArZWRnZS5nZXRWYWx1ZSgpICogbWluS3k7XG4gICAgZWRnZS5zZXRMYXlvdXQoe1xuICAgICAgZHk6IGVkZ2VEeVxuICAgIH0sIHRydWUpO1xuICB9KTtcbn1cbi8qKlxyXG4gKiBSZXNvbHZlIHRoZSBjb2xsaXNpb24gb2YgaW5pdGlhbGl6ZWQgZGVwdGggKHktcG9zaXRpb24pXHJcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUNvbGxpc2lvbnMobm9kZXNCeUJyZWFkdGgsIG5vZGVHYXAsIGhlaWdodCwgd2lkdGgsIG9yaWVudCkge1xuICB2YXIga2V5QXR0ciA9IG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/ICd4JyA6ICd5JztcbiAgenJVdGlsLmVhY2gobm9kZXNCeUJyZWFkdGgsIGZ1bmN0aW9uIChub2Rlcykge1xuICAgIG5vZGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmdldExheW91dCgpW2tleUF0dHJdIC0gYi5nZXRMYXlvdXQoKVtrZXlBdHRyXTtcbiAgICB9KTtcbiAgICB2YXIgbm9kZVg7XG4gICAgdmFyIG5vZGU7XG4gICAgdmFyIGR5O1xuICAgIHZhciB5MCA9IDA7XG4gICAgdmFyIG4gPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIG5vZGVEeUF0dHIgPSBvcmllbnQgPT09ICd2ZXJ0aWNhbCcgPyAnZHgnIDogJ2R5JztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgZHkgPSB5MCAtIG5vZGUuZ2V0TGF5b3V0KClba2V5QXR0cl07XG4gICAgICBpZiAoZHkgPiAwKSB7XG4gICAgICAgIG5vZGVYID0gbm9kZS5nZXRMYXlvdXQoKVtrZXlBdHRyXSArIGR5O1xuICAgICAgICBvcmllbnQgPT09ICd2ZXJ0aWNhbCcgPyBub2RlLnNldExheW91dCh7XG4gICAgICAgICAgeDogbm9kZVhcbiAgICAgICAgfSwgdHJ1ZSkgOiBub2RlLnNldExheW91dCh7XG4gICAgICAgICAgeTogbm9kZVhcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB5MCA9IG5vZGUuZ2V0TGF5b3V0KClba2V5QXR0cl0gKyBub2RlLmdldExheW91dCgpW25vZGVEeUF0dHJdICsgbm9kZUdhcDtcbiAgICB9XG4gICAgdmFyIHZpZXdXaWR0aCA9IG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/IHdpZHRoIDogaGVpZ2h0O1xuICAgIC8vIElmIHRoZSBib3R0b21tb3N0IG5vZGUgZ29lcyBvdXRzaWRlIHRoZSBib3VuZHMsIHB1c2ggaXQgYmFjayB1cFxuICAgIGR5ID0geTAgLSBub2RlR2FwIC0gdmlld1dpZHRoO1xuICAgIGlmIChkeSA+IDApIHtcbiAgICAgIG5vZGVYID0gbm9kZS5nZXRMYXlvdXQoKVtrZXlBdHRyXSAtIGR5O1xuICAgICAgb3JpZW50ID09PSAndmVydGljYWwnID8gbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgICB4OiBub2RlWFxuICAgICAgfSwgdHJ1ZSkgOiBub2RlLnNldExheW91dCh7XG4gICAgICAgIHk6IG5vZGVYXG4gICAgICB9LCB0cnVlKTtcbiAgICAgIHkwID0gbm9kZVg7XG4gICAgICBmb3IgKHZhciBpID0gbiAtIDI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgZHkgPSBub2RlLmdldExheW91dCgpW2tleUF0dHJdICsgbm9kZS5nZXRMYXlvdXQoKVtub2RlRHlBdHRyXSArIG5vZGVHYXAgLSB5MDtcbiAgICAgICAgaWYgKGR5ID4gMCkge1xuICAgICAgICAgIG5vZGVYID0gbm9kZS5nZXRMYXlvdXQoKVtrZXlBdHRyXSAtIGR5O1xuICAgICAgICAgIG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/IG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgICAgIHg6IG5vZGVYXG4gICAgICAgICAgfSwgdHJ1ZSkgOiBub2RlLnNldExheW91dCh7XG4gICAgICAgICAgICB5OiBub2RlWFxuICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHkwID0gbm9kZS5nZXRMYXlvdXQoKVtrZXlBdHRyXTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuLyoqXHJcbiAqIENoYW5nZSB0aGUgeS1wb3NpdGlvbiBvZiB0aGUgbm9kZXMsIGV4Y2VwdCBtb3N0IHRoZSByaWdodCBzaWRlIG5vZGVzXHJcbiAqIEBwYXJhbSBub2Rlc0J5QnJlYWR0aFxyXG4gKiBAcGFyYW0gYWxwaGEgIHBhcmFtZXRlciB1c2VkIHRvIGFkanVzdCB0aGUgbm9kZXMgeS1wb3NpdGlvblxyXG4gKi9cbmZ1bmN0aW9uIHJlbGF4UmlnaHRUb0xlZnQobm9kZXNCeUJyZWFkdGgsIGFscGhhLCBvcmllbnQpIHtcbiAgenJVdGlsLmVhY2gobm9kZXNCeUJyZWFkdGguc2xpY2UoKS5yZXZlcnNlKCksIGZ1bmN0aW9uIChub2Rlcykge1xuICAgIHpyVXRpbC5lYWNoKG5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKG5vZGUub3V0RWRnZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB5ID0gc3VtKG5vZGUub3V0RWRnZXMsIHdlaWdodGVkVGFyZ2V0LCBvcmllbnQpIC8gc3VtKG5vZGUub3V0RWRnZXMsIGdldEVkZ2VWYWx1ZSk7XG4gICAgICAgIGlmIChpc05hTih5KSkge1xuICAgICAgICAgIHZhciBsZW4gPSBub2RlLm91dEVkZ2VzLmxlbmd0aDtcbiAgICAgICAgICB5ID0gbGVuID8gc3VtKG5vZGUub3V0RWRnZXMsIGNlbnRlclRhcmdldCwgb3JpZW50KSAvIGxlbiA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWVudCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgIHZhciBub2RlWCA9IG5vZGUuZ2V0TGF5b3V0KCkueCArICh5IC0gY2VudGVyKG5vZGUsIG9yaWVudCkpICogYWxwaGE7XG4gICAgICAgICAgbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgICAgICAgeDogbm9kZVhcbiAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbm9kZVkgPSBub2RlLmdldExheW91dCgpLnkgKyAoeSAtIGNlbnRlcihub2RlLCBvcmllbnQpKSAqIGFscGhhO1xuICAgICAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgICAgIHk6IG5vZGVZXG4gICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiB3ZWlnaHRlZFRhcmdldChlZGdlLCBvcmllbnQpIHtcbiAgcmV0dXJuIGNlbnRlcihlZGdlLm5vZGUyLCBvcmllbnQpICogZWRnZS5nZXRWYWx1ZSgpO1xufVxuZnVuY3Rpb24gY2VudGVyVGFyZ2V0KGVkZ2UsIG9yaWVudCkge1xuICByZXR1cm4gY2VudGVyKGVkZ2Uubm9kZTIsIG9yaWVudCk7XG59XG5mdW5jdGlvbiB3ZWlnaHRlZFNvdXJjZShlZGdlLCBvcmllbnQpIHtcbiAgcmV0dXJuIGNlbnRlcihlZGdlLm5vZGUxLCBvcmllbnQpICogZWRnZS5nZXRWYWx1ZSgpO1xufVxuZnVuY3Rpb24gY2VudGVyU291cmNlKGVkZ2UsIG9yaWVudCkge1xuICByZXR1cm4gY2VudGVyKGVkZ2Uubm9kZTEsIG9yaWVudCk7XG59XG5mdW5jdGlvbiBjZW50ZXIobm9kZSwgb3JpZW50KSB7XG4gIHJldHVybiBvcmllbnQgPT09ICd2ZXJ0aWNhbCcgPyBub2RlLmdldExheW91dCgpLnggKyBub2RlLmdldExheW91dCgpLmR4IC8gMiA6IG5vZGUuZ2V0TGF5b3V0KCkueSArIG5vZGUuZ2V0TGF5b3V0KCkuZHkgLyAyO1xufVxuZnVuY3Rpb24gZ2V0RWRnZVZhbHVlKGVkZ2UpIHtcbiAgcmV0dXJuIGVkZ2UuZ2V0VmFsdWUoKTtcbn1cbmZ1bmN0aW9uIHN1bShhcnJheSwgY2IsIG9yaWVudCkge1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHZhciB2YWx1ZSA9ICtjYihhcnJheVtpXSwgb3JpZW50KTtcbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgc3VtICs9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3VtO1xufVxuLyoqXHJcbiAqIENoYW5nZSB0aGUgeS1wb3NpdGlvbiBvZiB0aGUgbm9kZXMsIGV4Y2VwdCBtb3N0IHRoZSBsZWZ0IHNpZGUgbm9kZXNcclxuICovXG5mdW5jdGlvbiByZWxheExlZnRUb1JpZ2h0KG5vZGVzQnlCcmVhZHRoLCBhbHBoYSwgb3JpZW50KSB7XG4gIHpyVXRpbC5lYWNoKG5vZGVzQnlCcmVhZHRoLCBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICB6clV0aWwuZWFjaChub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmluRWRnZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB5ID0gc3VtKG5vZGUuaW5FZGdlcywgd2VpZ2h0ZWRTb3VyY2UsIG9yaWVudCkgLyBzdW0obm9kZS5pbkVkZ2VzLCBnZXRFZGdlVmFsdWUpO1xuICAgICAgICBpZiAoaXNOYU4oeSkpIHtcbiAgICAgICAgICB2YXIgbGVuID0gbm9kZS5pbkVkZ2VzLmxlbmd0aDtcbiAgICAgICAgICB5ID0gbGVuID8gc3VtKG5vZGUuaW5FZGdlcywgY2VudGVyU291cmNlLCBvcmllbnQpIC8gbGVuIDogMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZW50ID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgdmFyIG5vZGVYID0gbm9kZS5nZXRMYXlvdXQoKS54ICsgKHkgLSBjZW50ZXIobm9kZSwgb3JpZW50KSkgKiBhbHBoYTtcbiAgICAgICAgICBub2RlLnNldExheW91dCh7XG4gICAgICAgICAgICB4OiBub2RlWFxuICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBub2RlWSA9IG5vZGUuZ2V0TGF5b3V0KCkueSArICh5IC0gY2VudGVyKG5vZGUsIG9yaWVudCkpICogYWxwaGE7XG4gICAgICAgICAgbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgICAgICAgeTogbm9kZVlcbiAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cbi8qKlxyXG4gKiBDb21wdXRlIHRoZSBkZXB0aCh5LXBvc2l0aW9uKSBvZiBlYWNoIGVkZ2VcclxuICovXG5mdW5jdGlvbiBjb21wdXRlRWRnZURlcHRocyhub2Rlcywgb3JpZW50KSB7XG4gIHZhciBrZXlBdHRyID0gb3JpZW50ID09PSAndmVydGljYWwnID8gJ3gnIDogJ3knO1xuICB6clV0aWwuZWFjaChub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBub2RlLm91dEVkZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm5vZGUyLmdldExheW91dCgpW2tleUF0dHJdIC0gYi5ub2RlMi5nZXRMYXlvdXQoKVtrZXlBdHRyXTtcbiAgICB9KTtcbiAgICBub2RlLmluRWRnZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEubm9kZTEuZ2V0TGF5b3V0KClba2V5QXR0cl0gLSBiLm5vZGUxLmdldExheW91dCgpW2tleUF0dHJdO1xuICAgIH0pO1xuICB9KTtcbiAgenJVdGlsLmVhY2gobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIHN5ID0gMDtcbiAgICB2YXIgdHkgPSAwO1xuICAgIHpyVXRpbC5lYWNoKG5vZGUub3V0RWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICBlZGdlLnNldExheW91dCh7XG4gICAgICAgIHN5OiBzeVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBzeSArPSBlZGdlLmdldExheW91dCgpLmR5O1xuICAgIH0pO1xuICAgIHpyVXRpbC5lYWNoKG5vZGUuaW5FZGdlcywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIGVkZ2Uuc2V0TGF5b3V0KHtcbiAgICAgICAgdHk6IHR5XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIHR5ICs9IGVkZ2UuZ2V0TGF5b3V0KCkuZHk7XG4gICAgfSk7XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgVmlzdWFsTWFwcGluZyBmcm9tICcuLi8uLi92aXN1YWwvVmlzdWFsTWFwcGluZy5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzYW5rZXlWaXN1YWwoZWNNb2RlbCkge1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ3NhbmtleScsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBncmFwaCA9IHNlcmllc01vZGVsLmdldEdyYXBoKCk7XG4gICAgdmFyIG5vZGVzID0gZ3JhcGgubm9kZXM7XG4gICAgdmFyIGVkZ2VzID0gZ3JhcGguZWRnZXM7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgdmFyIG1pblZhbHVlXzEgPSBJbmZpbml0eTtcbiAgICAgIHZhciBtYXhWYWx1ZV8xID0gLUluZmluaXR5O1xuICAgICAgenJVdGlsLmVhY2gobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBub2RlVmFsdWUgPSBub2RlLmdldExheW91dCgpLnZhbHVlO1xuICAgICAgICBpZiAobm9kZVZhbHVlIDwgbWluVmFsdWVfMSkge1xuICAgICAgICAgIG1pblZhbHVlXzEgPSBub2RlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVWYWx1ZSA+IG1heFZhbHVlXzEpIHtcbiAgICAgICAgICBtYXhWYWx1ZV8xID0gbm9kZVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHpyVXRpbC5lYWNoKG5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IG5ldyBWaXN1YWxNYXBwaW5nKHtcbiAgICAgICAgICB0eXBlOiAnY29sb3InLFxuICAgICAgICAgIG1hcHBpbmdNZXRob2Q6ICdsaW5lYXInLFxuICAgICAgICAgIGRhdGFFeHRlbnQ6IFttaW5WYWx1ZV8xLCBtYXhWYWx1ZV8xXSxcbiAgICAgICAgICB2aXN1YWw6IHNlcmllc01vZGVsLmdldCgnY29sb3InKVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1hcFZhbHVlVG9Db2xvciA9IG1hcHBpbmcubWFwVmFsdWVUb1Zpc3VhbChub2RlLmdldExheW91dCgpLnZhbHVlKTtcbiAgICAgICAgdmFyIGN1c3RvbUNvbG9yID0gbm9kZS5nZXRNb2RlbCgpLmdldChbJ2l0ZW1TdHlsZScsICdjb2xvciddKTtcbiAgICAgICAgaWYgKGN1c3RvbUNvbG9yICE9IG51bGwpIHtcbiAgICAgICAgICBub2RlLnNldFZpc3VhbCgnY29sb3InLCBjdXN0b21Db2xvcik7XG4gICAgICAgICAgbm9kZS5zZXRWaXN1YWwoJ3N0eWxlJywge1xuICAgICAgICAgICAgZmlsbDogY3VzdG9tQ29sb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnNldFZpc3VhbCgnY29sb3InLCBtYXBWYWx1ZVRvQ29sb3IpO1xuICAgICAgICAgIG5vZGUuc2V0VmlzdWFsKCdzdHlsZScsIHtcbiAgICAgICAgICAgIGZpbGw6IG1hcFZhbHVlVG9Db2xvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVkZ2VzLmxlbmd0aCkge1xuICAgICAgenJVdGlsLmVhY2goZWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHZhciBlZGdlU3R5bGUgPSBlZGdlLmdldE1vZGVsKCkuZ2V0KCdsaW5lU3R5bGUnKTtcbiAgICAgICAgZWRnZS5zZXRWaXN1YWwoJ3N0eWxlJywgZWRnZVN0eWxlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgU2Fua2V5VmlldyBmcm9tICcuL1NhbmtleVZpZXcuanMnO1xuaW1wb3J0IFNhbmtleVNlcmllc01vZGVsIGZyb20gJy4vU2Fua2V5U2VyaWVzLmpzJztcbmltcG9ydCBzYW5rZXlMYXlvdXQgZnJvbSAnLi9zYW5rZXlMYXlvdXQuanMnO1xuaW1wb3J0IHNhbmtleVZpc3VhbCBmcm9tICcuL3NhbmtleVZpc3VhbC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ2hhcnRWaWV3KFNhbmtleVZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChTYW5rZXlTZXJpZXNNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckxheW91dChzYW5rZXlMYXlvdXQpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJWaXN1YWwoc2Fua2V5VmlzdWFsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICB0eXBlOiAnZHJhZ05vZGUnLFxuICAgIGV2ZW50OiAnZHJhZ25vZGUnLFxuICAgIC8vIGhlcmUgY2FuIG9ubHkgdXNlICd1cGRhdGUnIG5vdywgb3RoZXIgdmFsdWUgaXMgbm90IHN1cHBvcnQgaW4gZWNoYXJ0cy5cbiAgICB1cGRhdGU6ICd1cGRhdGUnXG4gIH0sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiAnc2VyaWVzJyxcbiAgICAgIHN1YlR5cGU6ICdzYW5rZXknLFxuICAgICAgcXVlcnk6IHBheWxvYWRcbiAgICB9LCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHNlcmllc01vZGVsLnNldE5vZGVQb3NpdGlvbihwYXlsb2FkLmRhdGFJbmRleCwgW3BheWxvYWQubG9jYWxYLCBwYXlsb2FkLmxvY2FsWV0pO1xuICAgIH0pO1xuICB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///73900\n")},74625:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/legacy/dataSelectAction.js\nvar dataSelectAction = __webpack_require__(16884);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/PathProxy.js\nvar PathProxy = __webpack_require__(68717);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n;// ./node_modules/echarts/lib/chart/pie/pieLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\nfunction getViewRect(seriesModel, api) {\n  return layout/* getLayoutRect */.dV(seriesModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n}\nfunction getBasicPieLayout(seriesModel, api) {\n  var viewRect = getViewRect(seriesModel, api);\n  // center can be string or number when coordinateSystem is specified\n  var center = seriesModel.get('center');\n  var radius = seriesModel.get('radius');\n  if (!util.isArray(radius)) {\n    radius = [0, radius];\n  }\n  var width = (0,number/* parsePercent */.lo)(viewRect.width, api.getWidth());\n  var height = (0,number/* parsePercent */.lo)(viewRect.height, api.getHeight());\n  var size = Math.min(width, height);\n  var r0 = (0,number/* parsePercent */.lo)(radius[0], size / 2);\n  var r = (0,number/* parsePercent */.lo)(radius[1], size / 2);\n  var cx;\n  var cy;\n  var coordSys = seriesModel.coordinateSystem;\n  if (coordSys) {\n    // percentage is not allowed when coordinate system is specified\n    var point = coordSys.dataToPoint(center);\n    cx = point[0] || 0;\n    cy = point[1] || 0;\n  } else {\n    if (!util.isArray(center)) {\n      center = [center, center];\n    }\n    cx = (0,number/* parsePercent */.lo)(center[0], width) + viewRect.x;\n    cy = (0,number/* parsePercent */.lo)(center[1], height) + viewRect.y;\n  }\n  return {\n    cx: cx,\n    cy: cy,\n    r0: r0,\n    r: r\n  };\n}\nfunction pieLayout(seriesType, ecModel, api) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var viewRect = getViewRect(seriesModel, api);\n    var _a = getBasicPieLayout(seriesModel, api),\n      cx = _a.cx,\n      cy = _a.cy,\n      r = _a.r,\n      r0 = _a.r0;\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var endAngle = seriesModel.get('endAngle');\n    var padAngle = seriesModel.get('padAngle') * RADIAN;\n    endAngle = endAngle === 'auto' ? startAngle - PI2 : -endAngle * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var minAndPadAngle = minAngle + padAngle;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim);\n    // Sum may be 0\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum');\n    // [0...max]\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0;\n    var dir = clockwise ? 1 : -1;\n    var angles = [startAngle, endAngle];\n    var halfPadAngle = dir * padAngle / 2;\n    (0,PathProxy/* normalizeArcAngles */.q)(angles, !clockwise);\n    startAngle = angles[0], endAngle = angles[1];\n    var layoutData = getSeriesLayoutData(seriesModel);\n    layoutData.startAngle = startAngle;\n    layoutData.endAngle = endAngle;\n    layoutData.clockwise = clockwise;\n    var angleRange = Math.abs(endAngle - startAngle);\n    // In the case some sector angle is smaller than minAngle\n    var restAngle = angleRange;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    data.setLayout({\n      viewRect: viewRect,\n      r: r\n    });\n    data.each(valueDim, function (value, idx) {\n      var angle;\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      }\n      // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = angleRange / validDataCount;\n      }\n      if (angle < minAndPadAngle) {\n        angle = minAndPadAngle;\n        restAngle -= minAndPadAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n      var endAngle = currentAngle + dir * angle;\n      // calculate display angle\n      var actualStartAngle = 0;\n      var actualEndAngle = 0;\n      if (padAngle > angle) {\n        actualStartAngle = currentAngle + dir * angle / 2;\n        actualEndAngle = actualStartAngle;\n      } else {\n        actualStartAngle = currentAngle + halfPadAngle;\n        actualEndAngle = endAngle - halfPadAngle;\n      }\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: actualStartAngle,\n        endAngle: actualEndAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? (0,number/* linearMap */.Cb)(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    });\n    // Some sector is constrained by minAngle and padAngle\n    // Rest sectors needs recalculate angle\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle and padAngle\n      if (restAngle <= 1e-3) {\n        var angle_1 = angleRange / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout_1 = data.getItemLayout(idx);\n            layout_1.angle = angle_1;\n            var actualStartAngle = 0;\n            var actualEndAngle = 0;\n            if (angle_1 < padAngle) {\n              actualStartAngle = startAngle + dir * (idx + 1 / 2) * angle_1;\n              actualEndAngle = actualStartAngle;\n            } else {\n              actualStartAngle = startAngle + dir * idx * angle_1 + halfPadAngle;\n              actualEndAngle = startAngle + dir * (idx + 1) * angle_1 - halfPadAngle;\n            }\n            layout_1.startAngle = actualStartAngle;\n            layout_1.endAngle = actualEndAngle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout_2 = data.getItemLayout(idx);\n            var angle = layout_2.angle === minAndPadAngle ? minAndPadAngle : value * unitRadian;\n            var actualStartAngle = 0;\n            var actualEndAngle = 0;\n            if (angle < padAngle) {\n              actualStartAngle = currentAngle + dir * angle / 2;\n              actualEndAngle = actualStartAngle;\n            } else {\n              actualStartAngle = currentAngle + halfPadAngle;\n              actualEndAngle = currentAngle + dir * angle - halfPadAngle;\n            }\n            layout_2.startAngle = actualStartAngle;\n            layout_2.endAngle = actualEndAngle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n  });\n}\nvar getSeriesLayoutData = (0,model/* makeInner */.$r)();\n// EXTERNAL MODULE: ./node_modules/echarts/lib/processor/dataFilter.js\nvar dataFilter = __webpack_require__(78587);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polyline.js\nvar Polyline = __webpack_require__(39195);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Sector.js + 1 modules\nvar Sector = __webpack_require__(25014);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/Point.js\nvar Point = __webpack_require__(26346);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelGuideHelper.js\nvar labelGuideHelper = __webpack_require__(92621);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelLayoutHelper.js\nvar labelLayoutHelper = __webpack_require__(77175);\n;// ./node_modules/echarts/lib/chart/pie/labelLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// FIXME emphasis label position is not same with normal label position\n\n\n\n\n\nvar labelLayout_RADIAN = Math.PI / 180;\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {\n  if (list.length < 2) {\n    return;\n  }\n  ;\n  function recalculateXOnSemiToAlignOnEllipseCurve(semi) {\n    var rB = semi.rB;\n    var rB2 = rB * rB;\n    for (var i = 0; i < semi.list.length; i++) {\n      var item = semi.list[i];\n      var dy = Math.abs(item.label.y - cy);\n      // horizontal r is always same with original r because x is not changed.\n      var rA = r + item.len;\n      var rA2 = rA * rA;\n      // Use ellipse implicit function to calculate x\n      var dx = Math.sqrt(Math.abs((1 - dy * dy / rB2) * rA2));\n      var newX = cx + (dx + item.len2) * dir;\n      var deltaX = newX - item.label.x;\n      var newTargetWidth = item.targetTextWidth - deltaX * dir;\n      // text x is changed, so need to recalculate width.\n      constrainTextWidth(item, newTargetWidth, true);\n      item.label.x = newX;\n    }\n  }\n  // Adjust X based on the shifted y. Make tight labels aligned on an ellipse curve.\n  function recalculateX(items) {\n    // Extremes of\n    var topSemi = {\n      list: [],\n      maxY: 0\n    };\n    var bottomSemi = {\n      list: [],\n      maxY: 0\n    };\n    for (var i = 0; i < items.length; i++) {\n      if (items[i].labelAlignTo !== 'none') {\n        continue;\n      }\n      var item = items[i];\n      var semi = item.label.y > cy ? bottomSemi : topSemi;\n      var dy = Math.abs(item.label.y - cy);\n      if (dy >= semi.maxY) {\n        var dx = item.label.x - cx - item.len2 * dir;\n        // horizontal r is always same with original r because x is not changed.\n        var rA = r + item.len;\n        // Canculate rB based on the topest / bottemest label.\n        var rB = Math.abs(dx) < rA ? Math.sqrt(dy * dy / (1 - dx * dx / rA / rA)) : rA;\n        semi.rB = rB;\n        semi.maxY = dy;\n      }\n      semi.list.push(item);\n    }\n    recalculateXOnSemiToAlignOnEllipseCurve(topSemi);\n    recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);\n  }\n  var len = list.length;\n  for (var i = 0; i < len; i++) {\n    if (list[i].position === 'outer' && list[i].labelAlignTo === 'labelLine') {\n      var dx = list[i].label.x - farthestX;\n      list[i].linePoints[1][0] += dx;\n      list[i].label.x = farthestX;\n    }\n  }\n  if ((0,labelLayoutHelper/* shiftLayoutOnY */.Xe)(list, viewTop, viewTop + viewHeight)) {\n    recalculateX(list);\n  }\n}\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {\n  var leftList = [];\n  var rightList = [];\n  var leftmostX = Number.MAX_VALUE;\n  var rightmostX = -Number.MAX_VALUE;\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var label = labelLayoutList[i].label;\n    if (isPositionCenter(labelLayoutList[i])) {\n      continue;\n    }\n    if (label.x < cx) {\n      leftmostX = Math.min(leftmostX, label.x);\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightmostX = Math.max(rightmostX, label.x);\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var layout = labelLayoutList[i];\n    if (!isPositionCenter(layout) && layout.linePoints) {\n      if (layout.labelStyleWidth != null) {\n        continue;\n      }\n      var label = layout.label;\n      var linePoints = layout.linePoints;\n      var targetTextWidth = void 0;\n      if (layout.labelAlignTo === 'edge') {\n        if (label.x < cx) {\n          targetTextWidth = linePoints[2][0] - layout.labelDistance - viewLeft - layout.edgeDistance;\n        } else {\n          targetTextWidth = viewLeft + viewWidth - layout.edgeDistance - linePoints[2][0] - layout.labelDistance;\n        }\n      } else if (layout.labelAlignTo === 'labelLine') {\n        if (label.x < cx) {\n          targetTextWidth = leftmostX - viewLeft - layout.bleedMargin;\n        } else {\n          targetTextWidth = viewLeft + viewWidth - rightmostX - layout.bleedMargin;\n        }\n      } else {\n        if (label.x < cx) {\n          targetTextWidth = label.x - viewLeft - layout.bleedMargin;\n        } else {\n          targetTextWidth = viewLeft + viewWidth - label.x - layout.bleedMargin;\n        }\n      }\n      layout.targetTextWidth = targetTextWidth;\n      constrainTextWidth(layout, targetTextWidth);\n    }\n  }\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var layout = labelLayoutList[i];\n    if (!isPositionCenter(layout) && layout.linePoints) {\n      var label = layout.label;\n      var linePoints = layout.linePoints;\n      var isAlignToEdge = layout.labelAlignTo === 'edge';\n      var padding = label.style.padding;\n      var paddingH = padding ? padding[1] + padding[3] : 0;\n      // textRect.width already contains paddingH if bgColor is set\n      var extraPaddingH = label.style.backgroundColor ? 0 : paddingH;\n      var realTextWidth = layout.rect.width + extraPaddingH;\n      var dist = linePoints[1][0] - linePoints[2][0];\n      if (isAlignToEdge) {\n        if (label.x < cx) {\n          linePoints[2][0] = viewLeft + layout.edgeDistance + realTextWidth + layout.labelDistance;\n        } else {\n          linePoints[2][0] = viewLeft + viewWidth - layout.edgeDistance - realTextWidth - layout.labelDistance;\n        }\n      } else {\n        if (label.x < cx) {\n          linePoints[2][0] = label.x + layout.labelDistance;\n        } else {\n          linePoints[2][0] = label.x - layout.labelDistance;\n        }\n        linePoints[1][0] = linePoints[2][0] + dist;\n      }\n      linePoints[1][1] = linePoints[2][1] = label.y;\n    }\n  }\n}\n/**\r\n * Set max width of each label, and then wrap each label to the max width.\r\n *\r\n * @param layout label layout\r\n * @param availableWidth max width for the label to display\r\n * @param forceRecalculate recaculate the text layout even if the current width\r\n * is smaller than `availableWidth`. This is useful when the text was previously\r\n * wrapped by calling `constrainTextWidth` but now `availableWidth` changed, in\r\n * which case, previous wrapping should be redo.\r\n */\nfunction constrainTextWidth(layout, availableWidth, forceRecalculate) {\n  if (forceRecalculate === void 0) {\n    forceRecalculate = false;\n  }\n  if (layout.labelStyleWidth != null) {\n    // User-defined style.width has the highest priority.\n    return;\n  }\n  var label = layout.label;\n  var style = label.style;\n  var textRect = layout.rect;\n  var bgColor = style.backgroundColor;\n  var padding = style.padding;\n  var paddingH = padding ? padding[1] + padding[3] : 0;\n  var overflow = style.overflow;\n  // textRect.width already contains paddingH if bgColor is set\n  var oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH);\n  if (availableWidth < oldOuterWidth || forceRecalculate) {\n    var oldHeight = textRect.height;\n    if (overflow && overflow.match('break')) {\n      // Temporarily set background to be null to calculate\n      // the bounding box without background.\n      label.setStyle('backgroundColor', null);\n      // Set constraining width\n      label.setStyle('width', availableWidth - paddingH);\n      // This is the real bounding box of the text without padding.\n      var innerRect = label.getBoundingRect();\n      label.setStyle('width', Math.ceil(innerRect.width));\n      label.setStyle('backgroundColor', bgColor);\n    } else {\n      var availableInnerWidth = availableWidth - paddingH;\n      var newWidth = availableWidth < oldOuterWidth\n      // Current text is too wide, use `availableWidth` as max width.\n      ? availableInnerWidth :\n      // Current available width is enough, but the text may have\n      // already been wrapped with a smaller available width.\n      forceRecalculate ? availableInnerWidth > layout.unconstrainedWidth\n      // Current available is larger than text width,\n      // so don't constrain width (otherwise it may have\n      // empty space in the background).\n      ? null\n      // Current available is smaller than text width, so\n      // use the current available width as constraining\n      // width.\n      : availableInnerWidth\n      // Current available width is enough, so no need to\n      // constrain.\n      : null;\n      label.setStyle('width', newWidth);\n    }\n    var newRect = label.getBoundingRect();\n    textRect.width = newRect.width;\n    var margin = (label.style.margin || 0) + 2.1;\n    textRect.height = newRect.height + margin;\n    textRect.y -= (textRect.height - oldHeight) / 2;\n  }\n}\nfunction isPositionCenter(sectorShape) {\n  // Not change x for center label\n  return sectorShape.position === 'center';\n}\nfunction pieLabelLayout(seriesModel) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  var minShowLabelRadian = (seriesModel.get('minShowLabelAngle') || 0) * labelLayout_RADIAN;\n  var viewRect = data.getLayout('viewRect');\n  var r = data.getLayout('r');\n  var viewWidth = viewRect.width;\n  var viewLeft = viewRect.x;\n  var viewTop = viewRect.y;\n  var viewHeight = viewRect.height;\n  function setNotShow(el) {\n    el.ignore = true;\n  }\n  function isLabelShown(label) {\n    if (!label.ignore) {\n      return true;\n    }\n    for (var key in label.states) {\n      if (label.states[key].ignore === false) {\n        return true;\n      }\n    }\n    return false;\n  }\n  data.each(function (idx) {\n    var sector = data.getItemGraphicEl(idx);\n    var sectorShape = sector.shape;\n    var label = sector.getTextContent();\n    var labelLine = sector.getTextGuideLine();\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label');\n    // Use position in normal or emphasis\n    var labelPosition = labelModel.get('position') || itemModel.get(['emphasis', 'label', 'position']);\n    var labelDistance = labelModel.get('distanceToLabelLine');\n    var labelAlignTo = labelModel.get('alignTo');\n    var edgeDistance = (0,number/* parsePercent */.lo)(labelModel.get('edgeDistance'), viewWidth);\n    var bleedMargin = labelModel.get('bleedMargin');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    labelLineLen = (0,number/* parsePercent */.lo)(labelLineLen, viewWidth);\n    var labelLineLen2 = labelLineModel.get('length2');\n    labelLineLen2 = (0,number/* parsePercent */.lo)(labelLineLen2, viewWidth);\n    if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {\n      (0,util.each)(label.states, setNotShow);\n      label.ignore = true;\n      if (labelLine) {\n        (0,util.each)(labelLine.states, setNotShow);\n        labelLine.ignore = true;\n      }\n      return;\n    }\n    if (!isLabelShown(label)) {\n      return;\n    }\n    var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;\n    var nx = Math.cos(midAngle);\n    var ny = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = sectorShape.cx;\n    cy = sectorShape.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n    if (labelPosition === 'center') {\n      textX = sectorShape.cx;\n      textY = sectorShape.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;\n      var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;\n      textX = x1 + nx * 3;\n      textY = y1 + ny * 3;\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + nx * (labelLineLen + r - sectorShape.r);\n        var y2 = y1 + ny * (labelLineLen + r - sectorShape.r);\n        var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        if (labelAlignTo === 'edge') {\n          // Adjust textX because text align of edge is opposite\n          textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;\n        } else {\n          textX = x3 + (nx < 0 ? -labelDistance : labelDistance);\n        }\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n      textAlign = isLabelInside ? 'center' : labelAlignTo === 'edge' ? nx > 0 ? 'right' : 'left' : nx > 0 ? 'left' : 'right';\n    }\n    var PI = Math.PI;\n    var labelRotate = 0;\n    var rotate = labelModel.get('rotate');\n    if ((0,util.isNumber)(rotate)) {\n      labelRotate = rotate * (PI / 180);\n    } else if (labelPosition === 'center') {\n      labelRotate = 0;\n    } else if (rotate === 'radial' || rotate === true) {\n      var radialAngle = nx < 0 ? -midAngle + PI : -midAngle;\n      labelRotate = radialAngle;\n    } else if (rotate === 'tangential' && labelPosition !== 'outside' && labelPosition !== 'outer') {\n      var rad = Math.atan2(nx, ny);\n      if (rad < 0) {\n        rad = PI * 2 + rad;\n      }\n      var isDown = ny > 0;\n      if (isDown) {\n        rad = PI + rad;\n      }\n      labelRotate = rad - PI;\n    }\n    hasLabelRotate = !!labelRotate;\n    label.x = textX;\n    label.y = textY;\n    label.rotation = labelRotate;\n    label.setStyle({\n      verticalAlign: 'middle'\n    });\n    // Not sectorShape the inside label\n    if (!isLabelInside) {\n      var textRect = label.getBoundingRect().clone();\n      textRect.applyTransform(label.getComputedTransform());\n      // Text has a default 1px stroke. Exclude this.\n      var margin = (label.style.margin || 0) + 2.1;\n      textRect.y -= margin / 2;\n      textRect.height += margin;\n      labelLayoutList.push({\n        label: label,\n        labelLine: labelLine,\n        position: labelPosition,\n        len: labelLineLen,\n        len2: labelLineLen2,\n        minTurnAngle: labelLineModel.get('minTurnAngle'),\n        maxSurfaceAngle: labelLineModel.get('maxSurfaceAngle'),\n        surfaceNormal: new Point/* default */.A(nx, ny),\n        linePoints: linePoints,\n        textAlign: textAlign,\n        labelDistance: labelDistance,\n        labelAlignTo: labelAlignTo,\n        edgeDistance: edgeDistance,\n        bleedMargin: bleedMargin,\n        rect: textRect,\n        unconstrainedWidth: textRect.width,\n        labelStyleWidth: label.style.width\n      });\n    } else {\n      label.setStyle({\n        align: textAlign\n      });\n      var selectState = label.states.select;\n      if (selectState) {\n        selectState.x += label.x;\n        selectState.y += label.y;\n      }\n    }\n    sector.setTextConfig({\n      inside: isLabelInside\n    });\n  });\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);\n  }\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var layout = labelLayoutList[i];\n    var label = layout.label;\n    var labelLine = layout.labelLine;\n    var notShowLabel = isNaN(label.x) || isNaN(label.y);\n    if (label) {\n      label.setStyle({\n        align: layout.textAlign\n      });\n      if (notShowLabel) {\n        (0,util.each)(label.states, setNotShow);\n        label.ignore = true;\n      }\n      var selectState = label.states.select;\n      if (selectState) {\n        selectState.x += label.x;\n        selectState.y += label.y;\n      }\n    }\n    if (labelLine) {\n      var linePoints = layout.linePoints;\n      if (notShowLabel || !linePoints) {\n        (0,util.each)(labelLine.states, setNotShow);\n        labelLine.ignore = true;\n      } else {\n        (0,labelGuideHelper/* limitTurnAngle */.YI)(linePoints, layout.minTurnAngle);\n        (0,labelGuideHelper/* limitSurfaceAngle */.QK)(linePoints, layout.surfaceNormal, layout.maxSurfaceAngle);\n        labelLine.setShape({\n          points: linePoints\n        });\n        // Set the anchor to the midpoint of sector\n        label.__hostTarget.textGuideLineConfig = {\n          anchor: new Point/* default */.A(linePoints[0][0], linePoints[0][1])\n        };\n      }\n    }\n  }\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/sectorHelper.js\nvar sectorHelper = __webpack_require__(79446);\n;// ./node_modules/echarts/lib/chart/pie/PieView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * Piece of pie including Sector, Label, LabelLine\r\n */\nvar PiePiece = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(PiePiece, _super);\n  function PiePiece(data, idx, startAngle) {\n    var _this = _super.call(this) || this;\n    _this.z2 = 2;\n    var text = new Text/* default */.Ay();\n    _this.setTextContent(text);\n    _this.updateData(data, idx, startAngle, true);\n    return _this;\n  }\n  PiePiece.prototype.updateData = function (data, idx, startAngle, firstCreate) {\n    var sector = this;\n    var seriesModel = data.hostModel;\n    var itemModel = data.getItemModel(idx);\n    var emphasisModel = itemModel.getModel('emphasis');\n    var layout = data.getItemLayout(idx);\n    // cornerRadius & innerCornerRadius doesn't exist in the item layout. Use `0` if null value is specified.\n    // see `setItemLayout` in `pieLayout.ts`.\n    var sectorShape = (0,util.extend)((0,sectorHelper/* getSectorCornerRadius */.i)(itemModel.getModel('itemStyle'), layout, true), layout);\n    // Ignore NaN data.\n    if (isNaN(sectorShape.startAngle)) {\n      // Use NaN shape to avoid drawing shape.\n      sector.setShape(sectorShape);\n      return;\n    }\n    if (firstCreate) {\n      sector.setShape(sectorShape);\n      var animationType = seriesModel.getShallow('animationType');\n      if (seriesModel.ecModel.ssr) {\n        // Use scale animation in SSR mode(opacity?)\n        // Because CSS SVG animation doesn't support very customized shape animation.\n        basicTransition/* initProps */.LW(sector, {\n          scaleX: 0,\n          scaleY: 0\n        }, seriesModel, {\n          dataIndex: idx,\n          isFrom: true\n        });\n        sector.originX = sectorShape.cx;\n        sector.originY = sectorShape.cy;\n      } else if (animationType === 'scale') {\n        sector.shape.r = layout.r0;\n        basicTransition/* initProps */.LW(sector, {\n          shape: {\n            r: layout.r\n          }\n        }, seriesModel, idx);\n      }\n      // Expansion\n      else {\n        if (startAngle != null) {\n          sector.setShape({\n            startAngle: startAngle,\n            endAngle: startAngle\n          });\n          basicTransition/* initProps */.LW(sector, {\n            shape: {\n              startAngle: layout.startAngle,\n              endAngle: layout.endAngle\n            }\n          }, seriesModel, idx);\n        } else {\n          sector.shape.endAngle = layout.startAngle;\n          basicTransition/* updateProps */.oi(sector, {\n            shape: {\n              endAngle: layout.endAngle\n            }\n          }, seriesModel, idx);\n        }\n      }\n    } else {\n      (0,basicTransition/* saveOldStyle */.ap)(sector);\n      // Transition animation from the old shape\n      basicTransition/* updateProps */.oi(sector, {\n        shape: sectorShape\n      }, seriesModel, idx);\n    }\n    sector.useStyle(data.getItemVisual(idx, 'style'));\n    (0,states/* setStatesStylesFromModel */.Mx)(sector, itemModel);\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var offset = seriesModel.get('selectedOffset');\n    var dx = Math.cos(midAngle) * offset;\n    var dy = Math.sin(midAngle) * offset;\n    var cursorStyle = itemModel.getShallow('cursor');\n    cursorStyle && sector.attr('cursor', cursorStyle);\n    this._updateLabel(seriesModel, data, idx);\n    sector.ensureState('emphasis').shape = (0,util.extend)({\n      r: layout.r + (emphasisModel.get('scale') ? emphasisModel.get('scaleSize') || 0 : 0)\n    }, (0,sectorHelper/* getSectorCornerRadius */.i)(emphasisModel.getModel('itemStyle'), layout));\n    (0,util.extend)(sector.ensureState('select'), {\n      x: dx,\n      y: dy,\n      shape: (0,sectorHelper/* getSectorCornerRadius */.i)(itemModel.getModel(['select', 'itemStyle']), layout)\n    });\n    (0,util.extend)(sector.ensureState('blur'), {\n      shape: (0,sectorHelper/* getSectorCornerRadius */.i)(itemModel.getModel(['blur', 'itemStyle']), layout)\n    });\n    var labelLine = sector.getTextGuideLine();\n    var labelText = sector.getTextContent();\n    labelLine && (0,util.extend)(labelLine.ensureState('select'), {\n      x: dx,\n      y: dy\n    });\n    // TODO: needs dx, dy in zrender?\n    (0,util.extend)(labelText.ensureState('select'), {\n      x: dx,\n      y: dy\n    });\n    (0,states/* toggleHoverEmphasis */.Lm)(this, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n  };\n  PiePiece.prototype._updateLabel = function (seriesModel, data, idx) {\n    var sector = this;\n    var itemModel = data.getItemModel(idx);\n    var labelLineModel = itemModel.getModel('labelLine');\n    var style = data.getItemVisual(idx, 'style');\n    var visualColor = style && style.fill;\n    var visualOpacity = style && style.opacity;\n    (0,labelStyle/* setLabelStyle */.qM)(sector, (0,labelStyle/* getLabelStatesModels */.lx)(itemModel), {\n      labelFetcher: data.hostModel,\n      labelDataIndex: idx,\n      inheritColor: visualColor,\n      defaultOpacity: visualOpacity,\n      defaultText: seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx)\n    });\n    var labelText = sector.getTextContent();\n    // Set textConfig on sector.\n    sector.setTextConfig({\n      // reset position, rotation\n      position: null,\n      rotation: null\n    });\n    // Make sure update style on labelText after setLabelStyle.\n    // Because setLabelStyle will replace a new style on it.\n    labelText.attr({\n      z2: 10\n    });\n    var labelPosition = seriesModel.get(['label', 'position']);\n    if (labelPosition !== 'outside' && labelPosition !== 'outer') {\n      sector.removeTextGuideLine();\n    } else {\n      var polyline = this.getTextGuideLine();\n      if (!polyline) {\n        polyline = new Polyline/* default */.A();\n        this.setTextGuideLine(polyline);\n      }\n      // Default use item visual color\n      (0,labelGuideHelper/* setLabelLineStyle */.eR)(this, (0,labelGuideHelper/* getLabelLineStatesModels */.rv)(itemModel), {\n        stroke: visualColor,\n        opacity: (0,util.retrieve3)(labelLineModel.get(['lineStyle', 'opacity']), visualOpacity, 1)\n      });\n    }\n  };\n  return PiePiece;\n}(Sector/* default */.A);\n// Pie view\nvar PieView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(PieView, _super);\n  function PieView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.ignoreLabelLineUpdate = true;\n    return _this;\n  }\n  PieView.prototype.render = function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var startAngle;\n    // First render\n    if (!oldData && data.count() > 0) {\n      var shape = data.getItemLayout(0);\n      for (var s = 1; isNaN(shape && shape.startAngle) && s < data.count(); ++s) {\n        shape = data.getItemLayout(s);\n      }\n      if (shape) {\n        startAngle = shape.startAngle;\n      }\n    }\n    // remove empty-circle if it exists\n    if (this._emptyCircleSector) {\n      group.remove(this._emptyCircleSector);\n    }\n    // when all data are filtered, show lightgray empty circle\n    if (data.count() === 0 && seriesModel.get('showEmptyCircle')) {\n      var layoutData = getSeriesLayoutData(seriesModel);\n      var sector = new Sector/* default */.A({\n        shape: (0,util.extend)(getBasicPieLayout(seriesModel, api), layoutData)\n      });\n      sector.useStyle(seriesModel.getModel('emptyCircleStyle').getItemStyle());\n      this._emptyCircleSector = sector;\n      group.add(sector);\n    }\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx, startAngle);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx, startAngle);\n      piePiece.off('click');\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      basicTransition/* removeElementWithFadeOut */.t5(piePiece, seriesModel, idx);\n    }).execute();\n    pieLabelLayout(seriesModel);\n    // Always use initial animation.\n    if (seriesModel.get('animationTypeUpdate') !== 'expansion') {\n      this._data = data;\n    }\n  };\n  PieView.prototype.dispose = function () {};\n  PieView.prototype.containPoint = function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  };\n  PieView.type = 'pie';\n  return PieView;\n}(Chart/* default */.A);\n/* harmony default export */ const pie_PieView = (PieView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createSeriesDataSimply.js\nvar createSeriesDataSimply = __webpack_require__(72731);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/sourceHelper.js\nvar sourceHelper = __webpack_require__(23071);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/LegendVisualProvider.js\nvar LegendVisualProvider = __webpack_require__(58239);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n;// ./node_modules/echarts/lib/chart/pie/PieSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nvar innerData = model/* makeInner */.$r();\nvar PieSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(PieSeriesModel, _super);\n  function PieSeriesModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * @overwrite\r\n   */\n  PieSeriesModel.prototype.init = function (option) {\n    _super.prototype.init.apply(this, arguments);\n    // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n    this.legendVisualProvider = new LegendVisualProvider/* default */.A(util.bind(this.getData, this), util.bind(this.getRawData, this));\n    this._defaultLabelLine(option);\n  };\n  /**\r\n   * @overwrite\r\n   */\n  PieSeriesModel.prototype.mergeOption = function () {\n    _super.prototype.mergeOption.apply(this, arguments);\n  };\n  /**\r\n   * @overwrite\r\n   */\n  PieSeriesModel.prototype.getInitialData = function () {\n    return (0,createSeriesDataSimply/* default */.A)(this, {\n      coordDimensions: ['value'],\n      encodeDefaulter: util.curry(sourceHelper/* makeSeriesEncodeForNameBased */.ln, this)\n    });\n  };\n  /**\r\n   * @overwrite\r\n   */\n  PieSeriesModel.prototype.getDataParams = function (dataIndex) {\n    var data = this.getData();\n    // update seats when data is changed\n    var dataInner = innerData(data);\n    var seats = dataInner.seats;\n    if (!seats) {\n      var valueList_1 = [];\n      data.each(data.mapDimension('value'), function (value) {\n        valueList_1.push(value);\n      });\n      seats = dataInner.seats = (0,number/* getPercentSeats */.kM)(valueList_1, data.hostModel.get('percentPrecision'));\n    }\n    var params = _super.prototype.getDataParams.call(this, dataIndex);\n    // seats may be empty when sum is 0\n    params.percent = seats[dataIndex] || 0;\n    params.$vars.push('percent');\n    return params;\n  };\n  PieSeriesModel.prototype._defaultLabelLine = function (option) {\n    // Extend labelLine emphasis\n    model/* defaultEmphasis */.M5(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine;\n    // Not show label line if `label.normal.show = false`\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  };\n  PieSeriesModel.type = 'series.pie';\n  PieSeriesModel.defaultOption = {\n    // zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    colorBy: 'data',\n    // 默认全局居中\n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // 默认顺时针\n    clockwise: true,\n    startAngle: 90,\n    endAngle: 'auto',\n    padAngle: 0,\n    // 最小角度改为0\n    minAngle: 0,\n    // If the angle of a sector less than `minShowLabelAngle`,\n    // the label will not be displayed.\n    minShowLabelAngle: 0,\n    // 选中时扇区偏移量\n    selectedOffset: 10,\n    // 选择模式，默认关闭，可选single，multiple\n    // selectedMode: false,\n    // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    width: null,\n    height: null,\n    label: {\n      // color: 'inherit',\n      // If rotate around circle\n      rotate: 0,\n      show: true,\n      overflow: 'truncate',\n      // 'outer', 'inside', 'center'\n      position: 'outer',\n      // 'none', 'labelLine', 'edge'. Works only when position is 'outer'\n      alignTo: 'none',\n      // Closest distance between label and chart edge.\n      // Works only position is 'outer' and alignTo is 'edge'.\n      edgeDistance: '25%',\n      // Works only position is 'outer' and alignTo is not 'edge'.\n      bleedMargin: 10,\n      // Distance between text and label line.\n      distanceToLabelLine: 5\n      // formatter: 标签文本格式器，同 tooltip.formatter，不支持异步回调\n      // 默认使用全局文本样式，详见 textStyle\n      // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // 引导线两段中的第一段长度\n      length: 15,\n      // 引导线两段中的第二段长度\n      length2: 15,\n      smooth: false,\n      minTurnAngle: 90,\n      maxSurfaceAngle: 90,\n      lineStyle: {\n        // color: 各异,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1,\n      borderJoin: 'round'\n    },\n    showEmptyCircle: true,\n    emptyCircleStyle: {\n      color: 'lightgray',\n      opacity: 1\n    },\n    labelLayout: {\n      // Hide the overlapped label.\n      hideOverlap: true\n    },\n    emphasis: {\n      scale: true,\n      scaleSize: 5\n    },\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // Animation type. Valid values: expansion, scale\n    animationType: 'expansion',\n    animationDuration: 1000,\n    // Animation type when update. Valid values: transition, expansion\n    animationTypeUpdate: 'transition',\n    animationEasingUpdate: 'cubicInOut',\n    animationDurationUpdate: 500,\n    animationEasing: 'cubicInOut'\n  };\n  return PieSeriesModel;\n}(Series/* default */.A);\n/* harmony default export */ const PieSeries = (PieSeriesModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/processor/negativeDataFilter.js\nvar negativeDataFilter = __webpack_require__(82796);\n;// ./node_modules/echarts/lib/chart/pie/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nfunction install(registers) {\n  registers.registerChartView(pie_PieView);\n  registers.registerSeriesModel(PieSeries);\n  (0,dataSelectAction/* createLegacyDataSelectAction */.I)('pie', registers.registerAction);\n  registers.registerLayout((0,util.curry)(pieLayout, 'pie'));\n  registers.registerProcessor((0,dataFilter/* default */.A)('pie'));\n  registers.registerProcessor((0,negativeDataFilter/* default */.A)('pie'));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ2MjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUMxUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9waWUvcGllTGF5b3V0LmpzPzRiYjEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3BpZS9sYWJlbExheW91dC5qcz8wZGVmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9waWUvUGllVmlldy5qcz9iMjRiIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9waWUvUGllU2VyaWVzLmpzP2Y0MGMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3BpZS9pbnN0YWxsLmpzPzEyMjIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBwYXJzZVBlcmNlbnQsIGxpbmVhck1hcCB9IGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyLmpzJztcbmltcG9ydCAqIGFzIGxheW91dCBmcm9tICcuLi8uLi91dGlsL2xheW91dC5qcyc7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZUFyY0FuZ2xlcyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzJztcbmltcG9ydCB7IG1ha2VJbm5lciB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xudmFyIFBJMiA9IE1hdGguUEkgKiAyO1xudmFyIFJBRElBTiA9IE1hdGguUEkgLyAxODA7XG5mdW5jdGlvbiBnZXRWaWV3UmVjdChzZXJpZXNNb2RlbCwgYXBpKSB7XG4gIHJldHVybiBsYXlvdXQuZ2V0TGF5b3V0UmVjdChzZXJpZXNNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSwge1xuICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRCYXNpY1BpZUxheW91dChzZXJpZXNNb2RlbCwgYXBpKSB7XG4gIHZhciB2aWV3UmVjdCA9IGdldFZpZXdSZWN0KHNlcmllc01vZGVsLCBhcGkpO1xuICAvLyBjZW50ZXIgY2FuIGJlIHN0cmluZyBvciBudW1iZXIgd2hlbiBjb29yZGluYXRlU3lzdGVtIGlzIHNwZWNpZmllZFxuICB2YXIgY2VudGVyID0gc2VyaWVzTW9kZWwuZ2V0KCdjZW50ZXInKTtcbiAgdmFyIHJhZGl1cyA9IHNlcmllc01vZGVsLmdldCgncmFkaXVzJyk7XG4gIGlmICghenJVdGlsLmlzQXJyYXkocmFkaXVzKSkge1xuICAgIHJhZGl1cyA9IFswLCByYWRpdXNdO1xuICB9XG4gIHZhciB3aWR0aCA9IHBhcnNlUGVyY2VudCh2aWV3UmVjdC53aWR0aCwgYXBpLmdldFdpZHRoKCkpO1xuICB2YXIgaGVpZ2h0ID0gcGFyc2VQZXJjZW50KHZpZXdSZWN0LmhlaWdodCwgYXBpLmdldEhlaWdodCgpKTtcbiAgdmFyIHNpemUgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHIwID0gcGFyc2VQZXJjZW50KHJhZGl1c1swXSwgc2l6ZSAvIDIpO1xuICB2YXIgciA9IHBhcnNlUGVyY2VudChyYWRpdXNbMV0sIHNpemUgLyAyKTtcbiAgdmFyIGN4O1xuICB2YXIgY3k7XG4gIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gIGlmIChjb29yZFN5cykge1xuICAgIC8vIHBlcmNlbnRhZ2UgaXMgbm90IGFsbG93ZWQgd2hlbiBjb29yZGluYXRlIHN5c3RlbSBpcyBzcGVjaWZpZWRcbiAgICB2YXIgcG9pbnQgPSBjb29yZFN5cy5kYXRhVG9Qb2ludChjZW50ZXIpO1xuICAgIGN4ID0gcG9pbnRbMF0gfHwgMDtcbiAgICBjeSA9IHBvaW50WzFdIHx8IDA7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCF6clV0aWwuaXNBcnJheShjZW50ZXIpKSB7XG4gICAgICBjZW50ZXIgPSBbY2VudGVyLCBjZW50ZXJdO1xuICAgIH1cbiAgICBjeCA9IHBhcnNlUGVyY2VudChjZW50ZXJbMF0sIHdpZHRoKSArIHZpZXdSZWN0Lng7XG4gICAgY3kgPSBwYXJzZVBlcmNlbnQoY2VudGVyWzFdLCBoZWlnaHQpICsgdmlld1JlY3QueTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGN4OiBjeCxcbiAgICBjeTogY3ksXG4gICAgcjA6IHIwLFxuICAgIHI6IHJcbiAgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBpZUxheW91dChzZXJpZXNUeXBlLCBlY01vZGVsLCBhcGkpIHtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciB2YWx1ZURpbSA9IGRhdGEubWFwRGltZW5zaW9uKCd2YWx1ZScpO1xuICAgIHZhciB2aWV3UmVjdCA9IGdldFZpZXdSZWN0KHNlcmllc01vZGVsLCBhcGkpO1xuICAgIHZhciBfYSA9IGdldEJhc2ljUGllTGF5b3V0KHNlcmllc01vZGVsLCBhcGkpLFxuICAgICAgY3ggPSBfYS5jeCxcbiAgICAgIGN5ID0gX2EuY3ksXG4gICAgICByID0gX2EucixcbiAgICAgIHIwID0gX2EucjA7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSAtc2VyaWVzTW9kZWwuZ2V0KCdzdGFydEFuZ2xlJykgKiBSQURJQU47XG4gICAgdmFyIGVuZEFuZ2xlID0gc2VyaWVzTW9kZWwuZ2V0KCdlbmRBbmdsZScpO1xuICAgIHZhciBwYWRBbmdsZSA9IHNlcmllc01vZGVsLmdldCgncGFkQW5nbGUnKSAqIFJBRElBTjtcbiAgICBlbmRBbmdsZSA9IGVuZEFuZ2xlID09PSAnYXV0bycgPyBzdGFydEFuZ2xlIC0gUEkyIDogLWVuZEFuZ2xlICogUkFESUFOO1xuICAgIHZhciBtaW5BbmdsZSA9IHNlcmllc01vZGVsLmdldCgnbWluQW5nbGUnKSAqIFJBRElBTjtcbiAgICB2YXIgbWluQW5kUGFkQW5nbGUgPSBtaW5BbmdsZSArIHBhZEFuZ2xlO1xuICAgIHZhciB2YWxpZERhdGFDb3VudCA9IDA7XG4gICAgZGF0YS5lYWNoKHZhbHVlRGltLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICFpc05hTih2YWx1ZSkgJiYgdmFsaWREYXRhQ291bnQrKztcbiAgICB9KTtcbiAgICB2YXIgc3VtID0gZGF0YS5nZXRTdW0odmFsdWVEaW0pO1xuICAgIC8vIFN1bSBtYXkgYmUgMFxuICAgIHZhciB1bml0UmFkaWFuID0gTWF0aC5QSSAvIChzdW0gfHwgdmFsaWREYXRhQ291bnQpICogMjtcbiAgICB2YXIgY2xvY2t3aXNlID0gc2VyaWVzTW9kZWwuZ2V0KCdjbG9ja3dpc2UnKTtcbiAgICB2YXIgcm9zZVR5cGUgPSBzZXJpZXNNb2RlbC5nZXQoJ3Jvc2VUeXBlJyk7XG4gICAgdmFyIHN0aWxsU2hvd1plcm9TdW0gPSBzZXJpZXNNb2RlbC5nZXQoJ3N0aWxsU2hvd1plcm9TdW0nKTtcbiAgICAvLyBbMC4uLm1heF1cbiAgICB2YXIgZXh0ZW50ID0gZGF0YS5nZXREYXRhRXh0ZW50KHZhbHVlRGltKTtcbiAgICBleHRlbnRbMF0gPSAwO1xuICAgIHZhciBkaXIgPSBjbG9ja3dpc2UgPyAxIDogLTE7XG4gICAgdmFyIGFuZ2xlcyA9IFtzdGFydEFuZ2xlLCBlbmRBbmdsZV07XG4gICAgdmFyIGhhbGZQYWRBbmdsZSA9IGRpciAqIHBhZEFuZ2xlIC8gMjtcbiAgICBub3JtYWxpemVBcmNBbmdsZXMoYW5nbGVzLCAhY2xvY2t3aXNlKTtcbiAgICBzdGFydEFuZ2xlID0gYW5nbGVzWzBdLCBlbmRBbmdsZSA9IGFuZ2xlc1sxXTtcbiAgICB2YXIgbGF5b3V0RGF0YSA9IGdldFNlcmllc0xheW91dERhdGEoc2VyaWVzTW9kZWwpO1xuICAgIGxheW91dERhdGEuc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgbGF5b3V0RGF0YS5lbmRBbmdsZSA9IGVuZEFuZ2xlO1xuICAgIGxheW91dERhdGEuY2xvY2t3aXNlID0gY2xvY2t3aXNlO1xuICAgIHZhciBhbmdsZVJhbmdlID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICAvLyBJbiB0aGUgY2FzZSBzb21lIHNlY3RvciBhbmdsZSBpcyBzbWFsbGVyIHRoYW4gbWluQW5nbGVcbiAgICB2YXIgcmVzdEFuZ2xlID0gYW5nbGVSYW5nZTtcbiAgICB2YXIgdmFsdWVTdW1MYXJnZXJUaGFuTWluQW5nbGUgPSAwO1xuICAgIHZhciBjdXJyZW50QW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgIGRhdGEuc2V0TGF5b3V0KHtcbiAgICAgIHZpZXdSZWN0OiB2aWV3UmVjdCxcbiAgICAgIHI6IHJcbiAgICB9KTtcbiAgICBkYXRhLmVhY2godmFsdWVEaW0sIGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICB2YXIgYW5nbGU7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHtcbiAgICAgICAgICBhbmdsZTogTmFOLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IE5hTixcbiAgICAgICAgICBlbmRBbmdsZTogTmFOLFxuICAgICAgICAgIGNsb2Nrd2lzZTogY2xvY2t3aXNlLFxuICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgcjA6IHIwLFxuICAgICAgICAgIHI6IHJvc2VUeXBlID8gTmFOIDogclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gRklYTUUg5YW85a65IDIuMCDkvYbmmK8gcm9zZVR5cGUg5pivIGFyZWEg55qE5pe25YCZ5omN5piv6L+Z5qC377yfXG4gICAgICBpZiAocm9zZVR5cGUgIT09ICdhcmVhJykge1xuICAgICAgICBhbmdsZSA9IHN1bSA9PT0gMCAmJiBzdGlsbFNob3daZXJvU3VtID8gdW5pdFJhZGlhbiA6IHZhbHVlICogdW5pdFJhZGlhbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuZ2xlID0gYW5nbGVSYW5nZSAvIHZhbGlkRGF0YUNvdW50O1xuICAgICAgfVxuICAgICAgaWYgKGFuZ2xlIDwgbWluQW5kUGFkQW5nbGUpIHtcbiAgICAgICAgYW5nbGUgPSBtaW5BbmRQYWRBbmdsZTtcbiAgICAgICAgcmVzdEFuZ2xlIC09IG1pbkFuZFBhZEFuZ2xlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVTdW1MYXJnZXJUaGFuTWluQW5nbGUgKz0gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgZW5kQW5nbGUgPSBjdXJyZW50QW5nbGUgKyBkaXIgKiBhbmdsZTtcbiAgICAgIC8vIGNhbGN1bGF0ZSBkaXNwbGF5IGFuZ2xlXG4gICAgICB2YXIgYWN0dWFsU3RhcnRBbmdsZSA9IDA7XG4gICAgICB2YXIgYWN0dWFsRW5kQW5nbGUgPSAwO1xuICAgICAgaWYgKHBhZEFuZ2xlID4gYW5nbGUpIHtcbiAgICAgICAgYWN0dWFsU3RhcnRBbmdsZSA9IGN1cnJlbnRBbmdsZSArIGRpciAqIGFuZ2xlIC8gMjtcbiAgICAgICAgYWN0dWFsRW5kQW5nbGUgPSBhY3R1YWxTdGFydEFuZ2xlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0dWFsU3RhcnRBbmdsZSA9IGN1cnJlbnRBbmdsZSArIGhhbGZQYWRBbmdsZTtcbiAgICAgICAgYWN0dWFsRW5kQW5nbGUgPSBlbmRBbmdsZSAtIGhhbGZQYWRBbmdsZTtcbiAgICAgIH1cbiAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHtcbiAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICBzdGFydEFuZ2xlOiBhY3R1YWxTdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZTogYWN0dWFsRW5kQW5nbGUsXG4gICAgICAgIGNsb2Nrd2lzZTogY2xvY2t3aXNlLFxuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeSxcbiAgICAgICAgcjA6IHIwLFxuICAgICAgICByOiByb3NlVHlwZSA/IGxpbmVhck1hcCh2YWx1ZSwgZXh0ZW50LCBbcjAsIHJdKSA6IHJcbiAgICAgIH0pO1xuICAgICAgY3VycmVudEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgfSk7XG4gICAgLy8gU29tZSBzZWN0b3IgaXMgY29uc3RyYWluZWQgYnkgbWluQW5nbGUgYW5kIHBhZEFuZ2xlXG4gICAgLy8gUmVzdCBzZWN0b3JzIG5lZWRzIHJlY2FsY3VsYXRlIGFuZ2xlXG4gICAgaWYgKHJlc3RBbmdsZSA8IFBJMiAmJiB2YWxpZERhdGFDb3VudCkge1xuICAgICAgLy8gQXZlcmFnZSB0aGUgYW5nbGUgaWYgcmVzdCBhbmdsZSBpcyBub3QgZW5vdWdoIGFmdGVyIGFsbCBhbmdsZXMgaXNcbiAgICAgIC8vIENvbnN0cmFpbmVkIGJ5IG1pbkFuZ2xlIGFuZCBwYWRBbmdsZVxuICAgICAgaWYgKHJlc3RBbmdsZSA8PSAxZS0zKSB7XG4gICAgICAgIHZhciBhbmdsZV8xID0gYW5nbGVSYW5nZSAvIHZhbGlkRGF0YUNvdW50O1xuICAgICAgICBkYXRhLmVhY2godmFsdWVEaW0sIGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBsYXlvdXRfMSA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgICAgICAgbGF5b3V0XzEuYW5nbGUgPSBhbmdsZV8xO1xuICAgICAgICAgICAgdmFyIGFjdHVhbFN0YXJ0QW5nbGUgPSAwO1xuICAgICAgICAgICAgdmFyIGFjdHVhbEVuZEFuZ2xlID0gMDtcbiAgICAgICAgICAgIGlmIChhbmdsZV8xIDwgcGFkQW5nbGUpIHtcbiAgICAgICAgICAgICAgYWN0dWFsU3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBkaXIgKiAoaWR4ICsgMSAvIDIpICogYW5nbGVfMTtcbiAgICAgICAgICAgICAgYWN0dWFsRW5kQW5nbGUgPSBhY3R1YWxTdGFydEFuZ2xlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWN0dWFsU3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBkaXIgKiBpZHggKiBhbmdsZV8xICsgaGFsZlBhZEFuZ2xlO1xuICAgICAgICAgICAgICBhY3R1YWxFbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBkaXIgKiAoaWR4ICsgMSkgKiBhbmdsZV8xIC0gaGFsZlBhZEFuZ2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5b3V0XzEuc3RhcnRBbmdsZSA9IGFjdHVhbFN0YXJ0QW5nbGU7XG4gICAgICAgICAgICBsYXlvdXRfMS5lbmRBbmdsZSA9IGFjdHVhbEVuZEFuZ2xlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bml0UmFkaWFuID0gcmVzdEFuZ2xlIC8gdmFsdWVTdW1MYXJnZXJUaGFuTWluQW5nbGU7XG4gICAgICAgIGN1cnJlbnRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgICAgIGRhdGEuZWFjaCh2YWx1ZURpbSwgZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIGxheW91dF8yID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBsYXlvdXRfMi5hbmdsZSA9PT0gbWluQW5kUGFkQW5nbGUgPyBtaW5BbmRQYWRBbmdsZSA6IHZhbHVlICogdW5pdFJhZGlhbjtcbiAgICAgICAgICAgIHZhciBhY3R1YWxTdGFydEFuZ2xlID0gMDtcbiAgICAgICAgICAgIHZhciBhY3R1YWxFbmRBbmdsZSA9IDA7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPCBwYWRBbmdsZSkge1xuICAgICAgICAgICAgICBhY3R1YWxTdGFydEFuZ2xlID0gY3VycmVudEFuZ2xlICsgZGlyICogYW5nbGUgLyAyO1xuICAgICAgICAgICAgICBhY3R1YWxFbmRBbmdsZSA9IGFjdHVhbFN0YXJ0QW5nbGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhY3R1YWxTdGFydEFuZ2xlID0gY3VycmVudEFuZ2xlICsgaGFsZlBhZEFuZ2xlO1xuICAgICAgICAgICAgICBhY3R1YWxFbmRBbmdsZSA9IGN1cnJlbnRBbmdsZSArIGRpciAqIGFuZ2xlIC0gaGFsZlBhZEFuZ2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5b3V0XzIuc3RhcnRBbmdsZSA9IGFjdHVhbFN0YXJ0QW5nbGU7XG4gICAgICAgICAgICBsYXlvdXRfMi5lbmRBbmdsZSA9IGFjdHVhbEVuZEFuZ2xlO1xuICAgICAgICAgICAgY3VycmVudEFuZ2xlICs9IGRpciAqIGFuZ2xlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydCB2YXIgZ2V0U2VyaWVzTGF5b3V0RGF0YSA9IG1ha2VJbm5lcigpOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLy8gRklYTUUgZW1waGFzaXMgbGFiZWwgcG9zaXRpb24gaXMgbm90IHNhbWUgd2l0aCBub3JtYWwgbGFiZWwgcG9zaXRpb25cbmltcG9ydCB7IHBhcnNlUGVyY2VudCB9IGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyLmpzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCB7IGVhY2gsIGlzTnVtYmVyIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGxpbWl0VHVybkFuZ2xlLCBsaW1pdFN1cmZhY2VBbmdsZSB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsR3VpZGVIZWxwZXIuanMnO1xuaW1wb3J0IHsgc2hpZnRMYXlvdXRPblkgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbExheW91dEhlbHBlci5qcyc7XG52YXIgUkFESUFOID0gTWF0aC5QSSAvIDE4MDtcbmZ1bmN0aW9uIGFkanVzdFNpbmdsZVNpZGUobGlzdCwgY3gsIGN5LCByLCBkaXIsIHZpZXdXaWR0aCwgdmlld0hlaWdodCwgdmlld0xlZnQsIHZpZXdUb3AsIGZhcnRoZXN0WCkge1xuICBpZiAobGlzdC5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIDtcbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVYT25TZW1pVG9BbGlnbk9uRWxsaXBzZUN1cnZlKHNlbWkpIHtcbiAgICB2YXIgckIgPSBzZW1pLnJCO1xuICAgIHZhciByQjIgPSByQiAqIHJCO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VtaS5saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHNlbWkubGlzdFtpXTtcbiAgICAgIHZhciBkeSA9IE1hdGguYWJzKGl0ZW0ubGFiZWwueSAtIGN5KTtcbiAgICAgIC8vIGhvcml6b250YWwgciBpcyBhbHdheXMgc2FtZSB3aXRoIG9yaWdpbmFsIHIgYmVjYXVzZSB4IGlzIG5vdCBjaGFuZ2VkLlxuICAgICAgdmFyIHJBID0gciArIGl0ZW0ubGVuO1xuICAgICAgdmFyIHJBMiA9IHJBICogckE7XG4gICAgICAvLyBVc2UgZWxsaXBzZSBpbXBsaWNpdCBmdW5jdGlvbiB0byBjYWxjdWxhdGUgeFxuICAgICAgdmFyIGR4ID0gTWF0aC5zcXJ0KE1hdGguYWJzKCgxIC0gZHkgKiBkeSAvIHJCMikgKiByQTIpKTtcbiAgICAgIHZhciBuZXdYID0gY3ggKyAoZHggKyBpdGVtLmxlbjIpICogZGlyO1xuICAgICAgdmFyIGRlbHRhWCA9IG5ld1ggLSBpdGVtLmxhYmVsLng7XG4gICAgICB2YXIgbmV3VGFyZ2V0V2lkdGggPSBpdGVtLnRhcmdldFRleHRXaWR0aCAtIGRlbHRhWCAqIGRpcjtcbiAgICAgIC8vIHRleHQgeCBpcyBjaGFuZ2VkLCBzbyBuZWVkIHRvIHJlY2FsY3VsYXRlIHdpZHRoLlxuICAgICAgY29uc3RyYWluVGV4dFdpZHRoKGl0ZW0sIG5ld1RhcmdldFdpZHRoLCB0cnVlKTtcbiAgICAgIGl0ZW0ubGFiZWwueCA9IG5ld1g7XG4gICAgfVxuICB9XG4gIC8vIEFkanVzdCBYIGJhc2VkIG9uIHRoZSBzaGlmdGVkIHkuIE1ha2UgdGlnaHQgbGFiZWxzIGFsaWduZWQgb24gYW4gZWxsaXBzZSBjdXJ2ZS5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVYKGl0ZW1zKSB7XG4gICAgLy8gRXh0cmVtZXMgb2ZcbiAgICB2YXIgdG9wU2VtaSA9IHtcbiAgICAgIGxpc3Q6IFtdLFxuICAgICAgbWF4WTogMFxuICAgIH07XG4gICAgdmFyIGJvdHRvbVNlbWkgPSB7XG4gICAgICBsaXN0OiBbXSxcbiAgICAgIG1heFk6IDBcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpdGVtc1tpXS5sYWJlbEFsaWduVG8gIT09ICdub25lJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICB2YXIgc2VtaSA9IGl0ZW0ubGFiZWwueSA+IGN5ID8gYm90dG9tU2VtaSA6IHRvcFNlbWk7XG4gICAgICB2YXIgZHkgPSBNYXRoLmFicyhpdGVtLmxhYmVsLnkgLSBjeSk7XG4gICAgICBpZiAoZHkgPj0gc2VtaS5tYXhZKSB7XG4gICAgICAgIHZhciBkeCA9IGl0ZW0ubGFiZWwueCAtIGN4IC0gaXRlbS5sZW4yICogZGlyO1xuICAgICAgICAvLyBob3Jpem9udGFsIHIgaXMgYWx3YXlzIHNhbWUgd2l0aCBvcmlnaW5hbCByIGJlY2F1c2UgeCBpcyBub3QgY2hhbmdlZC5cbiAgICAgICAgdmFyIHJBID0gciArIGl0ZW0ubGVuO1xuICAgICAgICAvLyBDYW5jdWxhdGUgckIgYmFzZWQgb24gdGhlIHRvcGVzdCAvIGJvdHRlbWVzdCBsYWJlbC5cbiAgICAgICAgdmFyIHJCID0gTWF0aC5hYnMoZHgpIDwgckEgPyBNYXRoLnNxcnQoZHkgKiBkeSAvICgxIC0gZHggKiBkeCAvIHJBIC8gckEpKSA6IHJBO1xuICAgICAgICBzZW1pLnJCID0gckI7XG4gICAgICAgIHNlbWkubWF4WSA9IGR5O1xuICAgICAgfVxuICAgICAgc2VtaS5saXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJlY2FsY3VsYXRlWE9uU2VtaVRvQWxpZ25PbkVsbGlwc2VDdXJ2ZSh0b3BTZW1pKTtcbiAgICByZWNhbGN1bGF0ZVhPblNlbWlUb0FsaWduT25FbGxpcHNlQ3VydmUoYm90dG9tU2VtaSk7XG4gIH1cbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGxpc3RbaV0ucG9zaXRpb24gPT09ICdvdXRlcicgJiYgbGlzdFtpXS5sYWJlbEFsaWduVG8gPT09ICdsYWJlbExpbmUnKSB7XG4gICAgICB2YXIgZHggPSBsaXN0W2ldLmxhYmVsLnggLSBmYXJ0aGVzdFg7XG4gICAgICBsaXN0W2ldLmxpbmVQb2ludHNbMV1bMF0gKz0gZHg7XG4gICAgICBsaXN0W2ldLmxhYmVsLnggPSBmYXJ0aGVzdFg7XG4gICAgfVxuICB9XG4gIGlmIChzaGlmdExheW91dE9uWShsaXN0LCB2aWV3VG9wLCB2aWV3VG9wICsgdmlld0hlaWdodCkpIHtcbiAgICByZWNhbGN1bGF0ZVgobGlzdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGF2b2lkT3ZlcmxhcChsYWJlbExheW91dExpc3QsIGN4LCBjeSwgciwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0LCB2aWV3TGVmdCwgdmlld1RvcCkge1xuICB2YXIgbGVmdExpc3QgPSBbXTtcbiAgdmFyIHJpZ2h0TGlzdCA9IFtdO1xuICB2YXIgbGVmdG1vc3RYID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgdmFyIHJpZ2h0bW9zdFggPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbExheW91dExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGFiZWwgPSBsYWJlbExheW91dExpc3RbaV0ubGFiZWw7XG4gICAgaWYgKGlzUG9zaXRpb25DZW50ZXIobGFiZWxMYXlvdXRMaXN0W2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChsYWJlbC54IDwgY3gpIHtcbiAgICAgIGxlZnRtb3N0WCA9IE1hdGgubWluKGxlZnRtb3N0WCwgbGFiZWwueCk7XG4gICAgICBsZWZ0TGlzdC5wdXNoKGxhYmVsTGF5b3V0TGlzdFtpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJpZ2h0bW9zdFggPSBNYXRoLm1heChyaWdodG1vc3RYLCBsYWJlbC54KTtcbiAgICAgIHJpZ2h0TGlzdC5wdXNoKGxhYmVsTGF5b3V0TGlzdFtpXSk7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxMYXlvdXRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxheW91dCA9IGxhYmVsTGF5b3V0TGlzdFtpXTtcbiAgICBpZiAoIWlzUG9zaXRpb25DZW50ZXIobGF5b3V0KSAmJiBsYXlvdXQubGluZVBvaW50cykge1xuICAgICAgaWYgKGxheW91dC5sYWJlbFN0eWxlV2lkdGggIT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYWJlbCA9IGxheW91dC5sYWJlbDtcbiAgICAgIHZhciBsaW5lUG9pbnRzID0gbGF5b3V0LmxpbmVQb2ludHM7XG4gICAgICB2YXIgdGFyZ2V0VGV4dFdpZHRoID0gdm9pZCAwO1xuICAgICAgaWYgKGxheW91dC5sYWJlbEFsaWduVG8gPT09ICdlZGdlJykge1xuICAgICAgICBpZiAobGFiZWwueCA8IGN4KSB7XG4gICAgICAgICAgdGFyZ2V0VGV4dFdpZHRoID0gbGluZVBvaW50c1syXVswXSAtIGxheW91dC5sYWJlbERpc3RhbmNlIC0gdmlld0xlZnQgLSBsYXlvdXQuZWRnZURpc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFRleHRXaWR0aCA9IHZpZXdMZWZ0ICsgdmlld1dpZHRoIC0gbGF5b3V0LmVkZ2VEaXN0YW5jZSAtIGxpbmVQb2ludHNbMl1bMF0gLSBsYXlvdXQubGFiZWxEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsYXlvdXQubGFiZWxBbGlnblRvID09PSAnbGFiZWxMaW5lJykge1xuICAgICAgICBpZiAobGFiZWwueCA8IGN4KSB7XG4gICAgICAgICAgdGFyZ2V0VGV4dFdpZHRoID0gbGVmdG1vc3RYIC0gdmlld0xlZnQgLSBsYXlvdXQuYmxlZWRNYXJnaW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0VGV4dFdpZHRoID0gdmlld0xlZnQgKyB2aWV3V2lkdGggLSByaWdodG1vc3RYIC0gbGF5b3V0LmJsZWVkTWFyZ2luO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGFiZWwueCA8IGN4KSB7XG4gICAgICAgICAgdGFyZ2V0VGV4dFdpZHRoID0gbGFiZWwueCAtIHZpZXdMZWZ0IC0gbGF5b3V0LmJsZWVkTWFyZ2luO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFRleHRXaWR0aCA9IHZpZXdMZWZ0ICsgdmlld1dpZHRoIC0gbGFiZWwueCAtIGxheW91dC5ibGVlZE1hcmdpbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGF5b3V0LnRhcmdldFRleHRXaWR0aCA9IHRhcmdldFRleHRXaWR0aDtcbiAgICAgIGNvbnN0cmFpblRleHRXaWR0aChsYXlvdXQsIHRhcmdldFRleHRXaWR0aCk7XG4gICAgfVxuICB9XG4gIGFkanVzdFNpbmdsZVNpZGUocmlnaHRMaXN0LCBjeCwgY3ksIHIsIDEsIHZpZXdXaWR0aCwgdmlld0hlaWdodCwgdmlld0xlZnQsIHZpZXdUb3AsIHJpZ2h0bW9zdFgpO1xuICBhZGp1c3RTaW5nbGVTaWRlKGxlZnRMaXN0LCBjeCwgY3ksIHIsIC0xLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQsIHZpZXdMZWZ0LCB2aWV3VG9wLCBsZWZ0bW9zdFgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVsTGF5b3V0TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsYXlvdXQgPSBsYWJlbExheW91dExpc3RbaV07XG4gICAgaWYgKCFpc1Bvc2l0aW9uQ2VudGVyKGxheW91dCkgJiYgbGF5b3V0LmxpbmVQb2ludHMpIHtcbiAgICAgIHZhciBsYWJlbCA9IGxheW91dC5sYWJlbDtcbiAgICAgIHZhciBsaW5lUG9pbnRzID0gbGF5b3V0LmxpbmVQb2ludHM7XG4gICAgICB2YXIgaXNBbGlnblRvRWRnZSA9IGxheW91dC5sYWJlbEFsaWduVG8gPT09ICdlZGdlJztcbiAgICAgIHZhciBwYWRkaW5nID0gbGFiZWwuc3R5bGUucGFkZGluZztcbiAgICAgIHZhciBwYWRkaW5nSCA9IHBhZGRpbmcgPyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXSA6IDA7XG4gICAgICAvLyB0ZXh0UmVjdC53aWR0aCBhbHJlYWR5IGNvbnRhaW5zIHBhZGRpbmdIIGlmIGJnQ29sb3IgaXMgc2V0XG4gICAgICB2YXIgZXh0cmFQYWRkaW5nSCA9IGxhYmVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA/IDAgOiBwYWRkaW5nSDtcbiAgICAgIHZhciByZWFsVGV4dFdpZHRoID0gbGF5b3V0LnJlY3Qud2lkdGggKyBleHRyYVBhZGRpbmdIO1xuICAgICAgdmFyIGRpc3QgPSBsaW5lUG9pbnRzWzFdWzBdIC0gbGluZVBvaW50c1syXVswXTtcbiAgICAgIGlmIChpc0FsaWduVG9FZGdlKSB7XG4gICAgICAgIGlmIChsYWJlbC54IDwgY3gpIHtcbiAgICAgICAgICBsaW5lUG9pbnRzWzJdWzBdID0gdmlld0xlZnQgKyBsYXlvdXQuZWRnZURpc3RhbmNlICsgcmVhbFRleHRXaWR0aCArIGxheW91dC5sYWJlbERpc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVQb2ludHNbMl1bMF0gPSB2aWV3TGVmdCArIHZpZXdXaWR0aCAtIGxheW91dC5lZGdlRGlzdGFuY2UgLSByZWFsVGV4dFdpZHRoIC0gbGF5b3V0LmxhYmVsRGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsYWJlbC54IDwgY3gpIHtcbiAgICAgICAgICBsaW5lUG9pbnRzWzJdWzBdID0gbGFiZWwueCArIGxheW91dC5sYWJlbERpc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVQb2ludHNbMl1bMF0gPSBsYWJlbC54IC0gbGF5b3V0LmxhYmVsRGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgbGluZVBvaW50c1sxXVswXSA9IGxpbmVQb2ludHNbMl1bMF0gKyBkaXN0O1xuICAgICAgfVxuICAgICAgbGluZVBvaW50c1sxXVsxXSA9IGxpbmVQb2ludHNbMl1bMV0gPSBsYWJlbC55O1xuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIFNldCBtYXggd2lkdGggb2YgZWFjaCBsYWJlbCwgYW5kIHRoZW4gd3JhcCBlYWNoIGxhYmVsIHRvIHRoZSBtYXggd2lkdGguXHJcbiAqXHJcbiAqIEBwYXJhbSBsYXlvdXQgbGFiZWwgbGF5b3V0XHJcbiAqIEBwYXJhbSBhdmFpbGFibGVXaWR0aCBtYXggd2lkdGggZm9yIHRoZSBsYWJlbCB0byBkaXNwbGF5XHJcbiAqIEBwYXJhbSBmb3JjZVJlY2FsY3VsYXRlIHJlY2FjdWxhdGUgdGhlIHRleHQgbGF5b3V0IGV2ZW4gaWYgdGhlIGN1cnJlbnQgd2lkdGhcclxuICogaXMgc21hbGxlciB0aGFuIGBhdmFpbGFibGVXaWR0aGAuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdGhlIHRleHQgd2FzIHByZXZpb3VzbHlcclxuICogd3JhcHBlZCBieSBjYWxsaW5nIGBjb25zdHJhaW5UZXh0V2lkdGhgIGJ1dCBub3cgYGF2YWlsYWJsZVdpZHRoYCBjaGFuZ2VkLCBpblxyXG4gKiB3aGljaCBjYXNlLCBwcmV2aW91cyB3cmFwcGluZyBzaG91bGQgYmUgcmVkby5cclxuICovXG5mdW5jdGlvbiBjb25zdHJhaW5UZXh0V2lkdGgobGF5b3V0LCBhdmFpbGFibGVXaWR0aCwgZm9yY2VSZWNhbGN1bGF0ZSkge1xuICBpZiAoZm9yY2VSZWNhbGN1bGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgZm9yY2VSZWNhbGN1bGF0ZSA9IGZhbHNlO1xuICB9XG4gIGlmIChsYXlvdXQubGFiZWxTdHlsZVdpZHRoICE9IG51bGwpIHtcbiAgICAvLyBVc2VyLWRlZmluZWQgc3R5bGUud2lkdGggaGFzIHRoZSBoaWdoZXN0IHByaW9yaXR5LlxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbGFiZWwgPSBsYXlvdXQubGFiZWw7XG4gIHZhciBzdHlsZSA9IGxhYmVsLnN0eWxlO1xuICB2YXIgdGV4dFJlY3QgPSBsYXlvdXQucmVjdDtcbiAgdmFyIGJnQ29sb3IgPSBzdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XG4gIHZhciBwYWRkaW5nID0gc3R5bGUucGFkZGluZztcbiAgdmFyIHBhZGRpbmdIID0gcGFkZGluZyA/IHBhZGRpbmdbMV0gKyBwYWRkaW5nWzNdIDogMDtcbiAgdmFyIG92ZXJmbG93ID0gc3R5bGUub3ZlcmZsb3c7XG4gIC8vIHRleHRSZWN0LndpZHRoIGFscmVhZHkgY29udGFpbnMgcGFkZGluZ0ggaWYgYmdDb2xvciBpcyBzZXRcbiAgdmFyIG9sZE91dGVyV2lkdGggPSB0ZXh0UmVjdC53aWR0aCArIChiZ0NvbG9yID8gMCA6IHBhZGRpbmdIKTtcbiAgaWYgKGF2YWlsYWJsZVdpZHRoIDwgb2xkT3V0ZXJXaWR0aCB8fCBmb3JjZVJlY2FsY3VsYXRlKSB7XG4gICAgdmFyIG9sZEhlaWdodCA9IHRleHRSZWN0LmhlaWdodDtcbiAgICBpZiAob3ZlcmZsb3cgJiYgb3ZlcmZsb3cubWF0Y2goJ2JyZWFrJykpIHtcbiAgICAgIC8vIFRlbXBvcmFyaWx5IHNldCBiYWNrZ3JvdW5kIHRvIGJlIG51bGwgdG8gY2FsY3VsYXRlXG4gICAgICAvLyB0aGUgYm91bmRpbmcgYm94IHdpdGhvdXQgYmFja2dyb3VuZC5cbiAgICAgIGxhYmVsLnNldFN0eWxlKCdiYWNrZ3JvdW5kQ29sb3InLCBudWxsKTtcbiAgICAgIC8vIFNldCBjb25zdHJhaW5pbmcgd2lkdGhcbiAgICAgIGxhYmVsLnNldFN0eWxlKCd3aWR0aCcsIGF2YWlsYWJsZVdpZHRoIC0gcGFkZGluZ0gpO1xuICAgICAgLy8gVGhpcyBpcyB0aGUgcmVhbCBib3VuZGluZyBib3ggb2YgdGhlIHRleHQgd2l0aG91dCBwYWRkaW5nLlxuICAgICAgdmFyIGlubmVyUmVjdCA9IGxhYmVsLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgbGFiZWwuc2V0U3R5bGUoJ3dpZHRoJywgTWF0aC5jZWlsKGlubmVyUmVjdC53aWR0aCkpO1xuICAgICAgbGFiZWwuc2V0U3R5bGUoJ2JhY2tncm91bmRDb2xvcicsIGJnQ29sb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXZhaWxhYmxlSW5uZXJXaWR0aCA9IGF2YWlsYWJsZVdpZHRoIC0gcGFkZGluZ0g7XG4gICAgICB2YXIgbmV3V2lkdGggPSBhdmFpbGFibGVXaWR0aCA8IG9sZE91dGVyV2lkdGhcbiAgICAgIC8vIEN1cnJlbnQgdGV4dCBpcyB0b28gd2lkZSwgdXNlIGBhdmFpbGFibGVXaWR0aGAgYXMgbWF4IHdpZHRoLlxuICAgICAgPyBhdmFpbGFibGVJbm5lcldpZHRoIDpcbiAgICAgIC8vIEN1cnJlbnQgYXZhaWxhYmxlIHdpZHRoIGlzIGVub3VnaCwgYnV0IHRoZSB0ZXh0IG1heSBoYXZlXG4gICAgICAvLyBhbHJlYWR5IGJlZW4gd3JhcHBlZCB3aXRoIGEgc21hbGxlciBhdmFpbGFibGUgd2lkdGguXG4gICAgICBmb3JjZVJlY2FsY3VsYXRlID8gYXZhaWxhYmxlSW5uZXJXaWR0aCA+IGxheW91dC51bmNvbnN0cmFpbmVkV2lkdGhcbiAgICAgIC8vIEN1cnJlbnQgYXZhaWxhYmxlIGlzIGxhcmdlciB0aGFuIHRleHQgd2lkdGgsXG4gICAgICAvLyBzbyBkb24ndCBjb25zdHJhaW4gd2lkdGggKG90aGVyd2lzZSBpdCBtYXkgaGF2ZVxuICAgICAgLy8gZW1wdHkgc3BhY2UgaW4gdGhlIGJhY2tncm91bmQpLlxuICAgICAgPyBudWxsXG4gICAgICAvLyBDdXJyZW50IGF2YWlsYWJsZSBpcyBzbWFsbGVyIHRoYW4gdGV4dCB3aWR0aCwgc29cbiAgICAgIC8vIHVzZSB0aGUgY3VycmVudCBhdmFpbGFibGUgd2lkdGggYXMgY29uc3RyYWluaW5nXG4gICAgICAvLyB3aWR0aC5cbiAgICAgIDogYXZhaWxhYmxlSW5uZXJXaWR0aFxuICAgICAgLy8gQ3VycmVudCBhdmFpbGFibGUgd2lkdGggaXMgZW5vdWdoLCBzbyBubyBuZWVkIHRvXG4gICAgICAvLyBjb25zdHJhaW4uXG4gICAgICA6IG51bGw7XG4gICAgICBsYWJlbC5zZXRTdHlsZSgnd2lkdGgnLCBuZXdXaWR0aCk7XG4gICAgfVxuICAgIHZhciBuZXdSZWN0ID0gbGFiZWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdGV4dFJlY3Qud2lkdGggPSBuZXdSZWN0LndpZHRoO1xuICAgIHZhciBtYXJnaW4gPSAobGFiZWwuc3R5bGUubWFyZ2luIHx8IDApICsgMi4xO1xuICAgIHRleHRSZWN0LmhlaWdodCA9IG5ld1JlY3QuaGVpZ2h0ICsgbWFyZ2luO1xuICAgIHRleHRSZWN0LnkgLT0gKHRleHRSZWN0LmhlaWdodCAtIG9sZEhlaWdodCkgLyAyO1xuICB9XG59XG5mdW5jdGlvbiBpc1Bvc2l0aW9uQ2VudGVyKHNlY3RvclNoYXBlKSB7XG4gIC8vIE5vdCBjaGFuZ2UgeCBmb3IgY2VudGVyIGxhYmVsXG4gIHJldHVybiBzZWN0b3JTaGFwZS5wb3NpdGlvbiA9PT0gJ2NlbnRlcic7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwaWVMYWJlbExheW91dChzZXJpZXNNb2RlbCkge1xuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGxhYmVsTGF5b3V0TGlzdCA9IFtdO1xuICB2YXIgY3g7XG4gIHZhciBjeTtcbiAgdmFyIGhhc0xhYmVsUm90YXRlID0gZmFsc2U7XG4gIHZhciBtaW5TaG93TGFiZWxSYWRpYW4gPSAoc2VyaWVzTW9kZWwuZ2V0KCdtaW5TaG93TGFiZWxBbmdsZScpIHx8IDApICogUkFESUFOO1xuICB2YXIgdmlld1JlY3QgPSBkYXRhLmdldExheW91dCgndmlld1JlY3QnKTtcbiAgdmFyIHIgPSBkYXRhLmdldExheW91dCgncicpO1xuICB2YXIgdmlld1dpZHRoID0gdmlld1JlY3Qud2lkdGg7XG4gIHZhciB2aWV3TGVmdCA9IHZpZXdSZWN0Lng7XG4gIHZhciB2aWV3VG9wID0gdmlld1JlY3QueTtcbiAgdmFyIHZpZXdIZWlnaHQgPSB2aWV3UmVjdC5oZWlnaHQ7XG4gIGZ1bmN0aW9uIHNldE5vdFNob3coZWwpIHtcbiAgICBlbC5pZ25vcmUgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGlzTGFiZWxTaG93bihsYWJlbCkge1xuICAgIGlmICghbGFiZWwuaWdub3JlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIGxhYmVsLnN0YXRlcykge1xuICAgICAgaWYgKGxhYmVsLnN0YXRlc1trZXldLmlnbm9yZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgIHZhciBzZWN0b3IgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoaWR4KTtcbiAgICB2YXIgc2VjdG9yU2hhcGUgPSBzZWN0b3Iuc2hhcGU7XG4gICAgdmFyIGxhYmVsID0gc2VjdG9yLmdldFRleHRDb250ZW50KCk7XG4gICAgdmFyIGxhYmVsTGluZSA9IHNlY3Rvci5nZXRUZXh0R3VpZGVMaW5lKCk7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgdmFyIGxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsJyk7XG4gICAgLy8gVXNlIHBvc2l0aW9uIGluIG5vcm1hbCBvciBlbXBoYXNpc1xuICAgIHZhciBsYWJlbFBvc2l0aW9uID0gbGFiZWxNb2RlbC5nZXQoJ3Bvc2l0aW9uJykgfHwgaXRlbU1vZGVsLmdldChbJ2VtcGhhc2lzJywgJ2xhYmVsJywgJ3Bvc2l0aW9uJ10pO1xuICAgIHZhciBsYWJlbERpc3RhbmNlID0gbGFiZWxNb2RlbC5nZXQoJ2Rpc3RhbmNlVG9MYWJlbExpbmUnKTtcbiAgICB2YXIgbGFiZWxBbGlnblRvID0gbGFiZWxNb2RlbC5nZXQoJ2FsaWduVG8nKTtcbiAgICB2YXIgZWRnZURpc3RhbmNlID0gcGFyc2VQZXJjZW50KGxhYmVsTW9kZWwuZ2V0KCdlZGdlRGlzdGFuY2UnKSwgdmlld1dpZHRoKTtcbiAgICB2YXIgYmxlZWRNYXJnaW4gPSBsYWJlbE1vZGVsLmdldCgnYmxlZWRNYXJnaW4nKTtcbiAgICB2YXIgbGFiZWxMaW5lTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsTGluZScpO1xuICAgIHZhciBsYWJlbExpbmVMZW4gPSBsYWJlbExpbmVNb2RlbC5nZXQoJ2xlbmd0aCcpO1xuICAgIGxhYmVsTGluZUxlbiA9IHBhcnNlUGVyY2VudChsYWJlbExpbmVMZW4sIHZpZXdXaWR0aCk7XG4gICAgdmFyIGxhYmVsTGluZUxlbjIgPSBsYWJlbExpbmVNb2RlbC5nZXQoJ2xlbmd0aDInKTtcbiAgICBsYWJlbExpbmVMZW4yID0gcGFyc2VQZXJjZW50KGxhYmVsTGluZUxlbjIsIHZpZXdXaWR0aCk7XG4gICAgaWYgKE1hdGguYWJzKHNlY3RvclNoYXBlLmVuZEFuZ2xlIC0gc2VjdG9yU2hhcGUuc3RhcnRBbmdsZSkgPCBtaW5TaG93TGFiZWxSYWRpYW4pIHtcbiAgICAgIGVhY2gobGFiZWwuc3RhdGVzLCBzZXROb3RTaG93KTtcbiAgICAgIGxhYmVsLmlnbm9yZSA9IHRydWU7XG4gICAgICBpZiAobGFiZWxMaW5lKSB7XG4gICAgICAgIGVhY2gobGFiZWxMaW5lLnN0YXRlcywgc2V0Tm90U2hvdyk7XG4gICAgICAgIGxhYmVsTGluZS5pZ25vcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzTGFiZWxTaG93bihsYWJlbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG1pZEFuZ2xlID0gKHNlY3RvclNoYXBlLnN0YXJ0QW5nbGUgKyBzZWN0b3JTaGFwZS5lbmRBbmdsZSkgLyAyO1xuICAgIHZhciBueCA9IE1hdGguY29zKG1pZEFuZ2xlKTtcbiAgICB2YXIgbnkgPSBNYXRoLnNpbihtaWRBbmdsZSk7XG4gICAgdmFyIHRleHRYO1xuICAgIHZhciB0ZXh0WTtcbiAgICB2YXIgbGluZVBvaW50cztcbiAgICB2YXIgdGV4dEFsaWduO1xuICAgIGN4ID0gc2VjdG9yU2hhcGUuY3g7XG4gICAgY3kgPSBzZWN0b3JTaGFwZS5jeTtcbiAgICB2YXIgaXNMYWJlbEluc2lkZSA9IGxhYmVsUG9zaXRpb24gPT09ICdpbnNpZGUnIHx8IGxhYmVsUG9zaXRpb24gPT09ICdpbm5lcic7XG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0ZXh0WCA9IHNlY3RvclNoYXBlLmN4O1xuICAgICAgdGV4dFkgPSBzZWN0b3JTaGFwZS5jeTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeDEgPSAoaXNMYWJlbEluc2lkZSA/IChzZWN0b3JTaGFwZS5yICsgc2VjdG9yU2hhcGUucjApIC8gMiAqIG54IDogc2VjdG9yU2hhcGUuciAqIG54KSArIGN4O1xuICAgICAgdmFyIHkxID0gKGlzTGFiZWxJbnNpZGUgPyAoc2VjdG9yU2hhcGUuciArIHNlY3RvclNoYXBlLnIwKSAvIDIgKiBueSA6IHNlY3RvclNoYXBlLnIgKiBueSkgKyBjeTtcbiAgICAgIHRleHRYID0geDEgKyBueCAqIDM7XG4gICAgICB0ZXh0WSA9IHkxICsgbnkgKiAzO1xuICAgICAgaWYgKCFpc0xhYmVsSW5zaWRlKSB7XG4gICAgICAgIC8vIEZvciByb3NlVHlwZVxuICAgICAgICB2YXIgeDIgPSB4MSArIG54ICogKGxhYmVsTGluZUxlbiArIHIgLSBzZWN0b3JTaGFwZS5yKTtcbiAgICAgICAgdmFyIHkyID0geTEgKyBueSAqIChsYWJlbExpbmVMZW4gKyByIC0gc2VjdG9yU2hhcGUucik7XG4gICAgICAgIHZhciB4MyA9IHgyICsgKG54IDwgMCA/IC0xIDogMSkgKiBsYWJlbExpbmVMZW4yO1xuICAgICAgICB2YXIgeTMgPSB5MjtcbiAgICAgICAgaWYgKGxhYmVsQWxpZ25UbyA9PT0gJ2VkZ2UnKSB7XG4gICAgICAgICAgLy8gQWRqdXN0IHRleHRYIGJlY2F1c2UgdGV4dCBhbGlnbiBvZiBlZGdlIGlzIG9wcG9zaXRlXG4gICAgICAgICAgdGV4dFggPSBueCA8IDAgPyB2aWV3TGVmdCArIGVkZ2VEaXN0YW5jZSA6IHZpZXdMZWZ0ICsgdmlld1dpZHRoIC0gZWRnZURpc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRYID0geDMgKyAobnggPCAwID8gLWxhYmVsRGlzdGFuY2UgOiBsYWJlbERpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0WSA9IHkzO1xuICAgICAgICBsaW5lUG9pbnRzID0gW1t4MSwgeTFdLCBbeDIsIHkyXSwgW3gzLCB5M11dO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gaXNMYWJlbEluc2lkZSA/ICdjZW50ZXInIDogbGFiZWxBbGlnblRvID09PSAnZWRnZScgPyBueCA+IDAgPyAncmlnaHQnIDogJ2xlZnQnIDogbnggPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG4gICAgdmFyIFBJID0gTWF0aC5QSTtcbiAgICB2YXIgbGFiZWxSb3RhdGUgPSAwO1xuICAgIHZhciByb3RhdGUgPSBsYWJlbE1vZGVsLmdldCgncm90YXRlJyk7XG4gICAgaWYgKGlzTnVtYmVyKHJvdGF0ZSkpIHtcbiAgICAgIGxhYmVsUm90YXRlID0gcm90YXRlICogKFBJIC8gMTgwKTtcbiAgICB9IGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICBsYWJlbFJvdGF0ZSA9IDA7XG4gICAgfSBlbHNlIGlmIChyb3RhdGUgPT09ICdyYWRpYWwnIHx8IHJvdGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIHJhZGlhbEFuZ2xlID0gbnggPCAwID8gLW1pZEFuZ2xlICsgUEkgOiAtbWlkQW5nbGU7XG4gICAgICBsYWJlbFJvdGF0ZSA9IHJhZGlhbEFuZ2xlO1xuICAgIH0gZWxzZSBpZiAocm90YXRlID09PSAndGFuZ2VudGlhbCcgJiYgbGFiZWxQb3NpdGlvbiAhPT0gJ291dHNpZGUnICYmIGxhYmVsUG9zaXRpb24gIT09ICdvdXRlcicpIHtcbiAgICAgIHZhciByYWQgPSBNYXRoLmF0YW4yKG54LCBueSk7XG4gICAgICBpZiAocmFkIDwgMCkge1xuICAgICAgICByYWQgPSBQSSAqIDIgKyByYWQ7XG4gICAgICB9XG4gICAgICB2YXIgaXNEb3duID0gbnkgPiAwO1xuICAgICAgaWYgKGlzRG93bikge1xuICAgICAgICByYWQgPSBQSSArIHJhZDtcbiAgICAgIH1cbiAgICAgIGxhYmVsUm90YXRlID0gcmFkIC0gUEk7XG4gICAgfVxuICAgIGhhc0xhYmVsUm90YXRlID0gISFsYWJlbFJvdGF0ZTtcbiAgICBsYWJlbC54ID0gdGV4dFg7XG4gICAgbGFiZWwueSA9IHRleHRZO1xuICAgIGxhYmVsLnJvdGF0aW9uID0gbGFiZWxSb3RhdGU7XG4gICAgbGFiZWwuc2V0U3R5bGUoe1xuICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICB9KTtcbiAgICAvLyBOb3Qgc2VjdG9yU2hhcGUgdGhlIGluc2lkZSBsYWJlbFxuICAgIGlmICghaXNMYWJlbEluc2lkZSkge1xuICAgICAgdmFyIHRleHRSZWN0ID0gbGFiZWwuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgICAgIHRleHRSZWN0LmFwcGx5VHJhbnNmb3JtKGxhYmVsLmdldENvbXB1dGVkVHJhbnNmb3JtKCkpO1xuICAgICAgLy8gVGV4dCBoYXMgYSBkZWZhdWx0IDFweCBzdHJva2UuIEV4Y2x1ZGUgdGhpcy5cbiAgICAgIHZhciBtYXJnaW4gPSAobGFiZWwuc3R5bGUubWFyZ2luIHx8IDApICsgMi4xO1xuICAgICAgdGV4dFJlY3QueSAtPSBtYXJnaW4gLyAyO1xuICAgICAgdGV4dFJlY3QuaGVpZ2h0ICs9IG1hcmdpbjtcbiAgICAgIGxhYmVsTGF5b3V0TGlzdC5wdXNoKHtcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBsYWJlbExpbmU6IGxhYmVsTGluZSxcbiAgICAgICAgcG9zaXRpb246IGxhYmVsUG9zaXRpb24sXG4gICAgICAgIGxlbjogbGFiZWxMaW5lTGVuLFxuICAgICAgICBsZW4yOiBsYWJlbExpbmVMZW4yLFxuICAgICAgICBtaW5UdXJuQW5nbGU6IGxhYmVsTGluZU1vZGVsLmdldCgnbWluVHVybkFuZ2xlJyksXG4gICAgICAgIG1heFN1cmZhY2VBbmdsZTogbGFiZWxMaW5lTW9kZWwuZ2V0KCdtYXhTdXJmYWNlQW5nbGUnKSxcbiAgICAgICAgc3VyZmFjZU5vcm1hbDogbmV3IFBvaW50KG54LCBueSksXG4gICAgICAgIGxpbmVQb2ludHM6IGxpbmVQb2ludHMsXG4gICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICBsYWJlbERpc3RhbmNlOiBsYWJlbERpc3RhbmNlLFxuICAgICAgICBsYWJlbEFsaWduVG86IGxhYmVsQWxpZ25UbyxcbiAgICAgICAgZWRnZURpc3RhbmNlOiBlZGdlRGlzdGFuY2UsXG4gICAgICAgIGJsZWVkTWFyZ2luOiBibGVlZE1hcmdpbixcbiAgICAgICAgcmVjdDogdGV4dFJlY3QsXG4gICAgICAgIHVuY29uc3RyYWluZWRXaWR0aDogdGV4dFJlY3Qud2lkdGgsXG4gICAgICAgIGxhYmVsU3R5bGVXaWR0aDogbGFiZWwuc3R5bGUud2lkdGhcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYWJlbC5zZXRTdHlsZSh7XG4gICAgICAgIGFsaWduOiB0ZXh0QWxpZ25cbiAgICAgIH0pO1xuICAgICAgdmFyIHNlbGVjdFN0YXRlID0gbGFiZWwuc3RhdGVzLnNlbGVjdDtcbiAgICAgIGlmIChzZWxlY3RTdGF0ZSkge1xuICAgICAgICBzZWxlY3RTdGF0ZS54ICs9IGxhYmVsLng7XG4gICAgICAgIHNlbGVjdFN0YXRlLnkgKz0gbGFiZWwueTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VjdG9yLnNldFRleHRDb25maWcoe1xuICAgICAgaW5zaWRlOiBpc0xhYmVsSW5zaWRlXG4gICAgfSk7XG4gIH0pO1xuICBpZiAoIWhhc0xhYmVsUm90YXRlICYmIHNlcmllc01vZGVsLmdldCgnYXZvaWRMYWJlbE92ZXJsYXAnKSkge1xuICAgIGF2b2lkT3ZlcmxhcChsYWJlbExheW91dExpc3QsIGN4LCBjeSwgciwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0LCB2aWV3TGVmdCwgdmlld1RvcCk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbExheW91dExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGF5b3V0ID0gbGFiZWxMYXlvdXRMaXN0W2ldO1xuICAgIHZhciBsYWJlbCA9IGxheW91dC5sYWJlbDtcbiAgICB2YXIgbGFiZWxMaW5lID0gbGF5b3V0LmxhYmVsTGluZTtcbiAgICB2YXIgbm90U2hvd0xhYmVsID0gaXNOYU4obGFiZWwueCkgfHwgaXNOYU4obGFiZWwueSk7XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICBsYWJlbC5zZXRTdHlsZSh7XG4gICAgICAgIGFsaWduOiBsYXlvdXQudGV4dEFsaWduXG4gICAgICB9KTtcbiAgICAgIGlmIChub3RTaG93TGFiZWwpIHtcbiAgICAgICAgZWFjaChsYWJlbC5zdGF0ZXMsIHNldE5vdFNob3cpO1xuICAgICAgICBsYWJlbC5pZ25vcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHNlbGVjdFN0YXRlID0gbGFiZWwuc3RhdGVzLnNlbGVjdDtcbiAgICAgIGlmIChzZWxlY3RTdGF0ZSkge1xuICAgICAgICBzZWxlY3RTdGF0ZS54ICs9IGxhYmVsLng7XG4gICAgICAgIHNlbGVjdFN0YXRlLnkgKz0gbGFiZWwueTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhYmVsTGluZSkge1xuICAgICAgdmFyIGxpbmVQb2ludHMgPSBsYXlvdXQubGluZVBvaW50cztcbiAgICAgIGlmIChub3RTaG93TGFiZWwgfHwgIWxpbmVQb2ludHMpIHtcbiAgICAgICAgZWFjaChsYWJlbExpbmUuc3RhdGVzLCBzZXROb3RTaG93KTtcbiAgICAgICAgbGFiZWxMaW5lLmlnbm9yZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW1pdFR1cm5BbmdsZShsaW5lUG9pbnRzLCBsYXlvdXQubWluVHVybkFuZ2xlKTtcbiAgICAgICAgbGltaXRTdXJmYWNlQW5nbGUobGluZVBvaW50cywgbGF5b3V0LnN1cmZhY2VOb3JtYWwsIGxheW91dC5tYXhTdXJmYWNlQW5nbGUpO1xuICAgICAgICBsYWJlbExpbmUuc2V0U2hhcGUoe1xuICAgICAgICAgIHBvaW50czogbGluZVBvaW50c1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IHRoZSBhbmNob3IgdG8gdGhlIG1pZHBvaW50IG9mIHNlY3RvclxuICAgICAgICBsYWJlbC5fX2hvc3RUYXJnZXQudGV4dEd1aWRlTGluZUNvbmZpZyA9IHtcbiAgICAgICAgICBhbmNob3I6IG5ldyBQb2ludChsaW5lUG9pbnRzWzBdWzBdLCBsaW5lUG9pbnRzWzBdWzFdKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBleHRlbmQsIHJldHJpZXZlMyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwsIHRvZ2dsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQuanMnO1xuaW1wb3J0IGxhYmVsTGF5b3V0IGZyb20gJy4vbGFiZWxMYXlvdXQuanMnO1xuaW1wb3J0IHsgc2V0TGFiZWxMaW5lU3R5bGUsIGdldExhYmVsTGluZVN0YXRlc01vZGVscyB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsR3VpZGVIZWxwZXIuanMnO1xuaW1wb3J0IHsgc2V0TGFiZWxTdHlsZSwgZ2V0TGFiZWxTdGF0ZXNNb2RlbHMgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlLmpzJztcbmltcG9ydCB7IGdldFNlY3RvckNvcm5lclJhZGl1cyB9IGZyb20gJy4uL2hlbHBlci9zZWN0b3JIZWxwZXIuanMnO1xuaW1wb3J0IHsgc2F2ZU9sZFN0eWxlIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL2Jhc2ljVHJhbnNpdGlvbi5qcyc7XG5pbXBvcnQgeyBnZXRCYXNpY1BpZUxheW91dCwgZ2V0U2VyaWVzTGF5b3V0RGF0YSB9IGZyb20gJy4vcGllTGF5b3V0LmpzJztcbi8qKlxyXG4gKiBQaWVjZSBvZiBwaWUgaW5jbHVkaW5nIFNlY3RvciwgTGFiZWwsIExhYmVsTGluZVxyXG4gKi9cbnZhciBQaWVQaWVjZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQaWVQaWVjZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gUGllUGllY2UoZGF0YSwgaWR4LCBzdGFydEFuZ2xlKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy56MiA9IDI7XG4gICAgdmFyIHRleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KCk7XG4gICAgX3RoaXMuc2V0VGV4dENvbnRlbnQodGV4dCk7XG4gICAgX3RoaXMudXBkYXRlRGF0YShkYXRhLCBpZHgsIHN0YXJ0QW5nbGUsIHRydWUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBQaWVQaWVjZS5wcm90b3R5cGUudXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBpZHgsIHN0YXJ0QW5nbGUsIGZpcnN0Q3JlYXRlKSB7XG4gICAgdmFyIHNlY3RvciA9IHRoaXM7XG4gICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgdmFyIGVtcGhhc2lzTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJyk7XG4gICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgIC8vIGNvcm5lclJhZGl1cyAmIGlubmVyQ29ybmVyUmFkaXVzIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGl0ZW0gbGF5b3V0LiBVc2UgYDBgIGlmIG51bGwgdmFsdWUgaXMgc3BlY2lmaWVkLlxuICAgIC8vIHNlZSBgc2V0SXRlbUxheW91dGAgaW4gYHBpZUxheW91dC50c2AuXG4gICAgdmFyIHNlY3RvclNoYXBlID0gZXh0ZW5kKGdldFNlY3RvckNvcm5lclJhZGl1cyhpdGVtTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLCBsYXlvdXQsIHRydWUpLCBsYXlvdXQpO1xuICAgIC8vIElnbm9yZSBOYU4gZGF0YS5cbiAgICBpZiAoaXNOYU4oc2VjdG9yU2hhcGUuc3RhcnRBbmdsZSkpIHtcbiAgICAgIC8vIFVzZSBOYU4gc2hhcGUgdG8gYXZvaWQgZHJhd2luZyBzaGFwZS5cbiAgICAgIHNlY3Rvci5zZXRTaGFwZShzZWN0b3JTaGFwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmaXJzdENyZWF0ZSkge1xuICAgICAgc2VjdG9yLnNldFNoYXBlKHNlY3RvclNoYXBlKTtcbiAgICAgIHZhciBhbmltYXRpb25UeXBlID0gc2VyaWVzTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uVHlwZScpO1xuICAgICAgaWYgKHNlcmllc01vZGVsLmVjTW9kZWwuc3NyKSB7XG4gICAgICAgIC8vIFVzZSBzY2FsZSBhbmltYXRpb24gaW4gU1NSIG1vZGUob3BhY2l0eT8pXG4gICAgICAgIC8vIEJlY2F1c2UgQ1NTIFNWRyBhbmltYXRpb24gZG9lc24ndCBzdXBwb3J0IHZlcnkgY3VzdG9taXplZCBzaGFwZSBhbmltYXRpb24uXG4gICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKHNlY3Rvciwge1xuICAgICAgICAgIHNjYWxlWDogMCxcbiAgICAgICAgICBzY2FsZVk6IDBcbiAgICAgICAgfSwgc2VyaWVzTW9kZWwsIHtcbiAgICAgICAgICBkYXRhSW5kZXg6IGlkeCxcbiAgICAgICAgICBpc0Zyb206IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHNlY3Rvci5vcmlnaW5YID0gc2VjdG9yU2hhcGUuY3g7XG4gICAgICAgIHNlY3Rvci5vcmlnaW5ZID0gc2VjdG9yU2hhcGUuY3k7XG4gICAgICB9IGVsc2UgaWYgKGFuaW1hdGlvblR5cGUgPT09ICdzY2FsZScpIHtcbiAgICAgICAgc2VjdG9yLnNoYXBlLnIgPSBsYXlvdXQucjA7XG4gICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKHNlY3Rvciwge1xuICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICByOiBsYXlvdXQuclxuICAgICAgICAgIH1cbiAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgICB9XG4gICAgICAvLyBFeHBhbnNpb25cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc3RhcnRBbmdsZSAhPSBudWxsKSB7XG4gICAgICAgICAgc2VjdG9yLnNldFNoYXBlKHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKHNlY3Rvciwge1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgc3RhcnRBbmdsZTogbGF5b3V0LnN0YXJ0QW5nbGUsXG4gICAgICAgICAgICAgIGVuZEFuZ2xlOiBsYXlvdXQuZW5kQW5nbGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWN0b3Iuc2hhcGUuZW5kQW5nbGUgPSBsYXlvdXQuc3RhcnRBbmdsZTtcbiAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHNlY3Rvciwge1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgZW5kQW5nbGU6IGxheW91dC5lbmRBbmdsZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNhdmVPbGRTdHlsZShzZWN0b3IpO1xuICAgICAgLy8gVHJhbnNpdGlvbiBhbmltYXRpb24gZnJvbSB0aGUgb2xkIHNoYXBlXG4gICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHNlY3Rvciwge1xuICAgICAgICBzaGFwZTogc2VjdG9yU2hhcGVcbiAgICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICAgIH1cbiAgICBzZWN0b3IudXNlU3R5bGUoZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJykpO1xuICAgIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChzZWN0b3IsIGl0ZW1Nb2RlbCk7XG4gICAgdmFyIG1pZEFuZ2xlID0gKGxheW91dC5zdGFydEFuZ2xlICsgbGF5b3V0LmVuZEFuZ2xlKSAvIDI7XG4gICAgdmFyIG9mZnNldCA9IHNlcmllc01vZGVsLmdldCgnc2VsZWN0ZWRPZmZzZXQnKTtcbiAgICB2YXIgZHggPSBNYXRoLmNvcyhtaWRBbmdsZSkgKiBvZmZzZXQ7XG4gICAgdmFyIGR5ID0gTWF0aC5zaW4obWlkQW5nbGUpICogb2Zmc2V0O1xuICAgIHZhciBjdXJzb3JTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdjdXJzb3InKTtcbiAgICBjdXJzb3JTdHlsZSAmJiBzZWN0b3IuYXR0cignY3Vyc29yJywgY3Vyc29yU3R5bGUpO1xuICAgIHRoaXMuX3VwZGF0ZUxhYmVsKHNlcmllc01vZGVsLCBkYXRhLCBpZHgpO1xuICAgIHNlY3Rvci5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKS5zaGFwZSA9IGV4dGVuZCh7XG4gICAgICByOiBsYXlvdXQuciArIChlbXBoYXNpc01vZGVsLmdldCgnc2NhbGUnKSA/IGVtcGhhc2lzTW9kZWwuZ2V0KCdzY2FsZVNpemUnKSB8fCAwIDogMClcbiAgICB9LCBnZXRTZWN0b3JDb3JuZXJSYWRpdXMoZW1waGFzaXNNb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJyksIGxheW91dCkpO1xuICAgIGV4dGVuZChzZWN0b3IuZW5zdXJlU3RhdGUoJ3NlbGVjdCcpLCB7XG4gICAgICB4OiBkeCxcbiAgICAgIHk6IGR5LFxuICAgICAgc2hhcGU6IGdldFNlY3RvckNvcm5lclJhZGl1cyhpdGVtTW9kZWwuZ2V0TW9kZWwoWydzZWxlY3QnLCAnaXRlbVN0eWxlJ10pLCBsYXlvdXQpXG4gICAgfSk7XG4gICAgZXh0ZW5kKHNlY3Rvci5lbnN1cmVTdGF0ZSgnYmx1cicpLCB7XG4gICAgICBzaGFwZTogZ2V0U2VjdG9yQ29ybmVyUmFkaXVzKGl0ZW1Nb2RlbC5nZXRNb2RlbChbJ2JsdXInLCAnaXRlbVN0eWxlJ10pLCBsYXlvdXQpXG4gICAgfSk7XG4gICAgdmFyIGxhYmVsTGluZSA9IHNlY3Rvci5nZXRUZXh0R3VpZGVMaW5lKCk7XG4gICAgdmFyIGxhYmVsVGV4dCA9IHNlY3Rvci5nZXRUZXh0Q29udGVudCgpO1xuICAgIGxhYmVsTGluZSAmJiBleHRlbmQobGFiZWxMaW5lLmVuc3VyZVN0YXRlKCdzZWxlY3QnKSwge1xuICAgICAgeDogZHgsXG4gICAgICB5OiBkeVxuICAgIH0pO1xuICAgIC8vIFRPRE86IG5lZWRzIGR4LCBkeSBpbiB6cmVuZGVyP1xuICAgIGV4dGVuZChsYWJlbFRleHQuZW5zdXJlU3RhdGUoJ3NlbGVjdCcpLCB7XG4gICAgICB4OiBkeCxcbiAgICAgIHk6IGR5XG4gICAgfSk7XG4gICAgdG9nZ2xlSG92ZXJFbXBoYXNpcyh0aGlzLCBlbXBoYXNpc01vZGVsLmdldCgnZm9jdXMnKSwgZW1waGFzaXNNb2RlbC5nZXQoJ2JsdXJTY29wZScpLCBlbXBoYXNpc01vZGVsLmdldCgnZGlzYWJsZWQnKSk7XG4gIH07XG4gIFBpZVBpZWNlLnByb3RvdHlwZS5fdXBkYXRlTGFiZWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGRhdGEsIGlkeCkge1xuICAgIHZhciBzZWN0b3IgPSB0aGlzO1xuICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgIHZhciBsYWJlbExpbmVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWxMaW5lJyk7XG4gICAgdmFyIHN0eWxlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N0eWxlJyk7XG4gICAgdmFyIHZpc3VhbENvbG9yID0gc3R5bGUgJiYgc3R5bGUuZmlsbDtcbiAgICB2YXIgdmlzdWFsT3BhY2l0eSA9IHN0eWxlICYmIHN0eWxlLm9wYWNpdHk7XG4gICAgc2V0TGFiZWxTdHlsZShzZWN0b3IsIGdldExhYmVsU3RhdGVzTW9kZWxzKGl0ZW1Nb2RlbCksIHtcbiAgICAgIGxhYmVsRmV0Y2hlcjogZGF0YS5ob3N0TW9kZWwsXG4gICAgICBsYWJlbERhdGFJbmRleDogaWR4LFxuICAgICAgaW5oZXJpdENvbG9yOiB2aXN1YWxDb2xvcixcbiAgICAgIGRlZmF1bHRPcGFjaXR5OiB2aXN1YWxPcGFjaXR5LFxuICAgICAgZGVmYXVsdFRleHQ6IHNlcmllc01vZGVsLmdldEZvcm1hdHRlZExhYmVsKGlkeCwgJ25vcm1hbCcpIHx8IGRhdGEuZ2V0TmFtZShpZHgpXG4gICAgfSk7XG4gICAgdmFyIGxhYmVsVGV4dCA9IHNlY3Rvci5nZXRUZXh0Q29udGVudCgpO1xuICAgIC8vIFNldCB0ZXh0Q29uZmlnIG9uIHNlY3Rvci5cbiAgICBzZWN0b3Iuc2V0VGV4dENvbmZpZyh7XG4gICAgICAvLyByZXNldCBwb3NpdGlvbiwgcm90YXRpb25cbiAgICAgIHBvc2l0aW9uOiBudWxsLFxuICAgICAgcm90YXRpb246IG51bGxcbiAgICB9KTtcbiAgICAvLyBNYWtlIHN1cmUgdXBkYXRlIHN0eWxlIG9uIGxhYmVsVGV4dCBhZnRlciBzZXRMYWJlbFN0eWxlLlxuICAgIC8vIEJlY2F1c2Ugc2V0TGFiZWxTdHlsZSB3aWxsIHJlcGxhY2UgYSBuZXcgc3R5bGUgb24gaXQuXG4gICAgbGFiZWxUZXh0LmF0dHIoe1xuICAgICAgejI6IDEwXG4gICAgfSk7XG4gICAgdmFyIGxhYmVsUG9zaXRpb24gPSBzZXJpZXNNb2RlbC5nZXQoWydsYWJlbCcsICdwb3NpdGlvbiddKTtcbiAgICBpZiAobGFiZWxQb3NpdGlvbiAhPT0gJ291dHNpZGUnICYmIGxhYmVsUG9zaXRpb24gIT09ICdvdXRlcicpIHtcbiAgICAgIHNlY3Rvci5yZW1vdmVUZXh0R3VpZGVMaW5lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwb2x5bGluZSA9IHRoaXMuZ2V0VGV4dEd1aWRlTGluZSgpO1xuICAgICAgaWYgKCFwb2x5bGluZSkge1xuICAgICAgICBwb2x5bGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKCk7XG4gICAgICAgIHRoaXMuc2V0VGV4dEd1aWRlTGluZShwb2x5bGluZSk7XG4gICAgICB9XG4gICAgICAvLyBEZWZhdWx0IHVzZSBpdGVtIHZpc3VhbCBjb2xvclxuICAgICAgc2V0TGFiZWxMaW5lU3R5bGUodGhpcywgZ2V0TGFiZWxMaW5lU3RhdGVzTW9kZWxzKGl0ZW1Nb2RlbCksIHtcbiAgICAgICAgc3Ryb2tlOiB2aXN1YWxDb2xvcixcbiAgICAgICAgb3BhY2l0eTogcmV0cmlldmUzKGxhYmVsTGluZU1vZGVsLmdldChbJ2xpbmVTdHlsZScsICdvcGFjaXR5J10pLCB2aXN1YWxPcGFjaXR5LCAxKVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gUGllUGllY2U7XG59KGdyYXBoaWMuU2VjdG9yKTtcbi8vIFBpZSB2aWV3XG52YXIgUGllVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQaWVWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBQaWVWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLmlnbm9yZUxhYmVsTGluZVVwZGF0ZSA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFBpZVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIHN0YXJ0QW5nbGU7XG4gICAgLy8gRmlyc3QgcmVuZGVyXG4gICAgaWYgKCFvbGREYXRhICYmIGRhdGEuY291bnQoKSA+IDApIHtcbiAgICAgIHZhciBzaGFwZSA9IGRhdGEuZ2V0SXRlbUxheW91dCgwKTtcbiAgICAgIGZvciAodmFyIHMgPSAxOyBpc05hTihzaGFwZSAmJiBzaGFwZS5zdGFydEFuZ2xlKSAmJiBzIDwgZGF0YS5jb3VudCgpOyArK3MpIHtcbiAgICAgICAgc2hhcGUgPSBkYXRhLmdldEl0ZW1MYXlvdXQocyk7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJlbW92ZSBlbXB0eS1jaXJjbGUgaWYgaXQgZXhpc3RzXG4gICAgaWYgKHRoaXMuX2VtcHR5Q2lyY2xlU2VjdG9yKSB7XG4gICAgICBncm91cC5yZW1vdmUodGhpcy5fZW1wdHlDaXJjbGVTZWN0b3IpO1xuICAgIH1cbiAgICAvLyB3aGVuIGFsbCBkYXRhIGFyZSBmaWx0ZXJlZCwgc2hvdyBsaWdodGdyYXkgZW1wdHkgY2lyY2xlXG4gICAgaWYgKGRhdGEuY291bnQoKSA9PT0gMCAmJiBzZXJpZXNNb2RlbC5nZXQoJ3Nob3dFbXB0eUNpcmNsZScpKSB7XG4gICAgICB2YXIgbGF5b3V0RGF0YSA9IGdldFNlcmllc0xheW91dERhdGEoc2VyaWVzTW9kZWwpO1xuICAgICAgdmFyIHNlY3RvciA9IG5ldyBncmFwaGljLlNlY3Rvcih7XG4gICAgICAgIHNoYXBlOiBleHRlbmQoZ2V0QmFzaWNQaWVMYXlvdXQoc2VyaWVzTW9kZWwsIGFwaSksIGxheW91dERhdGEpXG4gICAgICB9KTtcbiAgICAgIHNlY3Rvci51c2VTdHlsZShzZXJpZXNNb2RlbC5nZXRNb2RlbCgnZW1wdHlDaXJjbGVTdHlsZScpLmdldEl0ZW1TdHlsZSgpKTtcbiAgICAgIHRoaXMuX2VtcHR5Q2lyY2xlU2VjdG9yID0gc2VjdG9yO1xuICAgICAgZ3JvdXAuYWRkKHNlY3Rvcik7XG4gICAgfVxuICAgIGRhdGEuZGlmZihvbGREYXRhKS5hZGQoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIHBpZVBpZWNlID0gbmV3IFBpZVBpZWNlKGRhdGEsIGlkeCwgc3RhcnRBbmdsZSk7XG4gICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBwaWVQaWVjZSk7XG4gICAgICBncm91cC5hZGQocGllUGllY2UpO1xuICAgIH0pLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICAgIHZhciBwaWVQaWVjZSA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuICAgICAgcGllUGllY2UudXBkYXRlRGF0YShkYXRhLCBuZXdJZHgsIHN0YXJ0QW5nbGUpO1xuICAgICAgcGllUGllY2Uub2ZmKCdjbGljaycpO1xuICAgICAgZ3JvdXAuYWRkKHBpZVBpZWNlKTtcbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIHBpZVBpZWNlKTtcbiAgICB9KS5yZW1vdmUoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIHBpZVBpZWNlID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKGlkeCk7XG4gICAgICBncmFwaGljLnJlbW92ZUVsZW1lbnRXaXRoRmFkZU91dChwaWVQaWVjZSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgfSkuZXhlY3V0ZSgpO1xuICAgIGxhYmVsTGF5b3V0KHNlcmllc01vZGVsKTtcbiAgICAvLyBBbHdheXMgdXNlIGluaXRpYWwgYW5pbWF0aW9uLlxuICAgIGlmIChzZXJpZXNNb2RlbC5nZXQoJ2FuaW1hdGlvblR5cGVVcGRhdGUnKSAhPT0gJ2V4cGFuc2lvbicpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgfTtcbiAgUGllVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9O1xuICBQaWVWaWV3LnByb3RvdHlwZS5jb250YWluUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQsIHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGl0ZW1MYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoMCk7XG4gICAgaWYgKGl0ZW1MYXlvdXQpIHtcbiAgICAgIHZhciBkeCA9IHBvaW50WzBdIC0gaXRlbUxheW91dC5jeDtcbiAgICAgIHZhciBkeSA9IHBvaW50WzFdIC0gaXRlbUxheW91dC5jeTtcbiAgICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgcmV0dXJuIHJhZGl1cyA8PSBpdGVtTGF5b3V0LnIgJiYgcmFkaXVzID49IGl0ZW1MYXlvdXQucjA7XG4gICAgfVxuICB9O1xuICBQaWVWaWV3LnR5cGUgPSAncGllJztcbiAgcmV0dXJuIFBpZVZpZXc7XG59KENoYXJ0Vmlldyk7XG5leHBvcnQgZGVmYXVsdCBQaWVWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgY3JlYXRlU2VyaWVzRGF0YVNpbXBseSBmcm9tICcuLi9oZWxwZXIvY3JlYXRlU2VyaWVzRGF0YVNpbXBseS5qcyc7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIG1vZGVsVXRpbCBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCB7IGdldFBlcmNlbnRTZWF0cyB9IGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyLmpzJztcbmltcG9ydCB7IG1ha2VTZXJpZXNFbmNvZGVGb3JOYW1lQmFzZWQgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9zb3VyY2VIZWxwZXIuanMnO1xuaW1wb3J0IExlZ2VuZFZpc3VhbFByb3ZpZGVyIGZyb20gJy4uLy4uL3Zpc3VhbC9MZWdlbmRWaXN1YWxQcm92aWRlci5qcyc7XG5pbXBvcnQgU2VyaWVzTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvU2VyaWVzLmpzJztcbnZhciBpbm5lckRhdGEgPSBtb2RlbFV0aWwubWFrZUlubmVyKCk7XG52YXIgUGllU2VyaWVzTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUGllU2VyaWVzTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFBpZVNlcmllc01vZGVsKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBAb3ZlcndyaXRlXHJcbiAgICovXG4gIFBpZVNlcmllc01vZGVsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIEVuYWJsZSBsZWdlbmQgc2VsZWN0aW9uIGZvciBlYWNoIGRhdGEgaXRlbVxuICAgIC8vIFVzZSBhIGZ1bmN0aW9uIGluc3RlYWQgb2YgZGlyZWN0IGFjY2VzcyBiZWNhdXNlIGRhdGEgcmVmZXJlbmNlIG1heSBjaGFuZ2VkXG4gICAgdGhpcy5sZWdlbmRWaXN1YWxQcm92aWRlciA9IG5ldyBMZWdlbmRWaXN1YWxQcm92aWRlcih6clV0aWwuYmluZCh0aGlzLmdldERhdGEsIHRoaXMpLCB6clV0aWwuYmluZCh0aGlzLmdldFJhd0RhdGEsIHRoaXMpKTtcbiAgICB0aGlzLl9kZWZhdWx0TGFiZWxMaW5lKG9wdGlvbik7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBvdmVyd3JpdGVcclxuICAgKi9cbiAgUGllU2VyaWVzTW9kZWwucHJvdG90eXBlLm1lcmdlT3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUubWVyZ2VPcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQG92ZXJ3cml0ZVxyXG4gICAqL1xuICBQaWVTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVNlcmllc0RhdGFTaW1wbHkodGhpcywge1xuICAgICAgY29vcmREaW1lbnNpb25zOiBbJ3ZhbHVlJ10sXG4gICAgICBlbmNvZGVEZWZhdWx0ZXI6IHpyVXRpbC5jdXJyeShtYWtlU2VyaWVzRW5jb2RlRm9yTmFtZUJhc2VkLCB0aGlzKVxuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBAb3ZlcndyaXRlXHJcbiAgICovXG4gIFBpZVNlcmllc01vZGVsLnByb3RvdHlwZS5nZXREYXRhUGFyYW1zID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgLy8gdXBkYXRlIHNlYXRzIHdoZW4gZGF0YSBpcyBjaGFuZ2VkXG4gICAgdmFyIGRhdGFJbm5lciA9IGlubmVyRGF0YShkYXRhKTtcbiAgICB2YXIgc2VhdHMgPSBkYXRhSW5uZXIuc2VhdHM7XG4gICAgaWYgKCFzZWF0cykge1xuICAgICAgdmFyIHZhbHVlTGlzdF8xID0gW107XG4gICAgICBkYXRhLmVhY2goZGF0YS5tYXBEaW1lbnNpb24oJ3ZhbHVlJyksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZUxpc3RfMS5wdXNoKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgc2VhdHMgPSBkYXRhSW5uZXIuc2VhdHMgPSBnZXRQZXJjZW50U2VhdHModmFsdWVMaXN0XzEsIGRhdGEuaG9zdE1vZGVsLmdldCgncGVyY2VudFByZWNpc2lvbicpKTtcbiAgICB9XG4gICAgdmFyIHBhcmFtcyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0RGF0YVBhcmFtcy5jYWxsKHRoaXMsIGRhdGFJbmRleCk7XG4gICAgLy8gc2VhdHMgbWF5IGJlIGVtcHR5IHdoZW4gc3VtIGlzIDBcbiAgICBwYXJhbXMucGVyY2VudCA9IHNlYXRzW2RhdGFJbmRleF0gfHwgMDtcbiAgICBwYXJhbXMuJHZhcnMucHVzaCgncGVyY2VudCcpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH07XG4gIFBpZVNlcmllc01vZGVsLnByb3RvdHlwZS5fZGVmYXVsdExhYmVsTGluZSA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAvLyBFeHRlbmQgbGFiZWxMaW5lIGVtcGhhc2lzXG4gICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyhvcHRpb24sICdsYWJlbExpbmUnLCBbJ3Nob3cnXSk7XG4gICAgdmFyIGxhYmVsTGluZU5vcm1hbE9wdCA9IG9wdGlvbi5sYWJlbExpbmU7XG4gICAgdmFyIGxhYmVsTGluZUVtcGhhc2lzT3B0ID0gb3B0aW9uLmVtcGhhc2lzLmxhYmVsTGluZTtcbiAgICAvLyBOb3Qgc2hvdyBsYWJlbCBsaW5lIGlmIGBsYWJlbC5ub3JtYWwuc2hvdyA9IGZhbHNlYFxuICAgIGxhYmVsTGluZU5vcm1hbE9wdC5zaG93ID0gbGFiZWxMaW5lTm9ybWFsT3B0LnNob3cgJiYgb3B0aW9uLmxhYmVsLnNob3c7XG4gICAgbGFiZWxMaW5lRW1waGFzaXNPcHQuc2hvdyA9IGxhYmVsTGluZUVtcGhhc2lzT3B0LnNob3cgJiYgb3B0aW9uLmVtcGhhc2lzLmxhYmVsLnNob3c7XG4gIH07XG4gIFBpZVNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLnBpZSc7XG4gIFBpZVNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgLy8gemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIGNvbG9yQnk6ICdkYXRhJyxcbiAgICAvLyDpu5jorqTlhajlsYDlsYXkuK1cbiAgICBjZW50ZXI6IFsnNTAlJywgJzUwJSddLFxuICAgIHJhZGl1czogWzAsICc3NSUnXSxcbiAgICAvLyDpu5jorqTpobrml7bpkohcbiAgICBjbG9ja3dpc2U6IHRydWUsXG4gICAgc3RhcnRBbmdsZTogOTAsXG4gICAgZW5kQW5nbGU6ICdhdXRvJyxcbiAgICBwYWRBbmdsZTogMCxcbiAgICAvLyDmnIDlsI/op5LluqbmlLnkuLowXG4gICAgbWluQW5nbGU6IDAsXG4gICAgLy8gSWYgdGhlIGFuZ2xlIG9mIGEgc2VjdG9yIGxlc3MgdGhhbiBgbWluU2hvd0xhYmVsQW5nbGVgLFxuICAgIC8vIHRoZSBsYWJlbCB3aWxsIG5vdCBiZSBkaXNwbGF5ZWQuXG4gICAgbWluU2hvd0xhYmVsQW5nbGU6IDAsXG4gICAgLy8g6YCJ5Lit5pe25omH5Yy65YGP56e76YePXG4gICAgc2VsZWN0ZWRPZmZzZXQ6IDEwLFxuICAgIC8vIOmAieaLqeaooeW8j++8jOm7mOiupOWFs+mXre+8jOWPr+mAiXNpbmdsZe+8jG11bHRpcGxlXG4gICAgLy8gc2VsZWN0ZWRNb2RlOiBmYWxzZSxcbiAgICAvLyDljZfkuIHmoLzlsJTnjqvnkbDlm77mqKHlvI/vvIwncmFkaXVzJ++8iOWNiuW+hO+8iSB8ICdhcmVhJ++8iOmdouenr++8iVxuICAgIC8vIHJvc2VUeXBlOiBudWxsLFxuICAgIHBlcmNlbnRQcmVjaXNpb246IDIsXG4gICAgLy8gSWYgc3RpbGwgc2hvdyB3aGVuIGFsbCBkYXRhIHplcm8uXG4gICAgc3RpbGxTaG93WmVyb1N1bTogdHJ1ZSxcbiAgICAvLyBjdXJzb3I6IG51bGwsXG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIHdpZHRoOiBudWxsLFxuICAgIGhlaWdodDogbnVsbCxcbiAgICBsYWJlbDoge1xuICAgICAgLy8gY29sb3I6ICdpbmhlcml0JyxcbiAgICAgIC8vIElmIHJvdGF0ZSBhcm91bmQgY2lyY2xlXG4gICAgICByb3RhdGU6IDAsXG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgb3ZlcmZsb3c6ICd0cnVuY2F0ZScsXG4gICAgICAvLyAnb3V0ZXInLCAnaW5zaWRlJywgJ2NlbnRlcidcbiAgICAgIHBvc2l0aW9uOiAnb3V0ZXInLFxuICAgICAgLy8gJ25vbmUnLCAnbGFiZWxMaW5lJywgJ2VkZ2UnLiBXb3JrcyBvbmx5IHdoZW4gcG9zaXRpb24gaXMgJ291dGVyJ1xuICAgICAgYWxpZ25UbzogJ25vbmUnLFxuICAgICAgLy8gQ2xvc2VzdCBkaXN0YW5jZSBiZXR3ZWVuIGxhYmVsIGFuZCBjaGFydCBlZGdlLlxuICAgICAgLy8gV29ya3Mgb25seSBwb3NpdGlvbiBpcyAnb3V0ZXInIGFuZCBhbGlnblRvIGlzICdlZGdlJy5cbiAgICAgIGVkZ2VEaXN0YW5jZTogJzI1JScsXG4gICAgICAvLyBXb3JrcyBvbmx5IHBvc2l0aW9uIGlzICdvdXRlcicgYW5kIGFsaWduVG8gaXMgbm90ICdlZGdlJy5cbiAgICAgIGJsZWVkTWFyZ2luOiAxMCxcbiAgICAgIC8vIERpc3RhbmNlIGJldHdlZW4gdGV4dCBhbmQgbGFiZWwgbGluZS5cbiAgICAgIGRpc3RhbmNlVG9MYWJlbExpbmU6IDVcbiAgICAgIC8vIGZvcm1hdHRlcjog5qCH562+5paH5pys5qC85byP5Zmo77yM5ZCMIHRvb2x0aXAuZm9ybWF0dGVy77yM5LiN5pSv5oyB5byC5q2l5Zue6LCDXG4gICAgICAvLyDpu5jorqTkvb/nlKjlhajlsYDmlofmnKzmoLflvI/vvIzor6bop4EgdGV4dFN0eWxlXG4gICAgICAvLyBkaXN0YW5jZTog5b2TcG9zaXRpb27kuLppbm5lcuaXtuacieaViO+8jOS4umxhYmVs5L2N572u5Yiw5ZyG5b+D55qE6Led56a75LiO5ZyG5Y2K5b6EKOeOr+eKtuWbvuS4uuWGheWkluWNiuW+hOWSjCnnmoTmr5Tkvovns7vmlbBcbiAgICB9LFxuICAgIC8vIEVuYWJsZWQgd2hlbiBsYWJlbC5ub3JtYWwucG9zaXRpb24gaXMgJ291dGVyJ1xuICAgIGxhYmVsTGluZToge1xuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIC8vIOW8leWvvOe6v+S4pOauteS4reeahOesrOS4gOautemVv+W6plxuICAgICAgbGVuZ3RoOiAxNSxcbiAgICAgIC8vIOW8leWvvOe6v+S4pOauteS4reeahOesrOS6jOautemVv+W6plxuICAgICAgbGVuZ3RoMjogMTUsXG4gICAgICBzbW9vdGg6IGZhbHNlLFxuICAgICAgbWluVHVybkFuZ2xlOiA5MCxcbiAgICAgIG1heFN1cmZhY2VBbmdsZTogOTAsXG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgLy8gY29sb3I6IOWQhOW8gixcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgIH1cbiAgICB9LFxuICAgIGl0ZW1TdHlsZToge1xuICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICBib3JkZXJKb2luOiAncm91bmQnXG4gICAgfSxcbiAgICBzaG93RW1wdHlDaXJjbGU6IHRydWUsXG4gICAgZW1wdHlDaXJjbGVTdHlsZToge1xuICAgICAgY29sb3I6ICdsaWdodGdyYXknLFxuICAgICAgb3BhY2l0eTogMVxuICAgIH0sXG4gICAgbGFiZWxMYXlvdXQ6IHtcbiAgICAgIC8vIEhpZGUgdGhlIG92ZXJsYXBwZWQgbGFiZWwuXG4gICAgICBoaWRlT3ZlcmxhcDogdHJ1ZVxuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIHNjYWxlOiB0cnVlLFxuICAgICAgc2NhbGVTaXplOiA1XG4gICAgfSxcbiAgICAvLyBJZiB1c2Ugc3RyYXRlZ3kgdG8gYXZvaWQgbGFiZWwgb3ZlcmxhcHBpbmdcbiAgICBhdm9pZExhYmVsT3ZlcmxhcDogdHJ1ZSxcbiAgICAvLyBBbmltYXRpb24gdHlwZS4gVmFsaWQgdmFsdWVzOiBleHBhbnNpb24sIHNjYWxlXG4gICAgYW5pbWF0aW9uVHlwZTogJ2V4cGFuc2lvbicsXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDEwMDAsXG4gICAgLy8gQW5pbWF0aW9uIHR5cGUgd2hlbiB1cGRhdGUuIFZhbGlkIHZhbHVlczogdHJhbnNpdGlvbiwgZXhwYW5zaW9uXG4gICAgYW5pbWF0aW9uVHlwZVVwZGF0ZTogJ3RyYW5zaXRpb24nLFxuICAgIGFuaW1hdGlvbkVhc2luZ1VwZGF0ZTogJ2N1YmljSW5PdXQnLFxuICAgIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlOiA1MDAsXG4gICAgYW5pbWF0aW9uRWFzaW5nOiAnY3ViaWNJbk91dCdcbiAgfTtcbiAgcmV0dXJuIFBpZVNlcmllc01vZGVsO1xufShTZXJpZXNNb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBQaWVTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGNyZWF0ZUxlZ2FjeURhdGFTZWxlY3RBY3Rpb24gfSBmcm9tICcuLi8uLi9sZWdhY3kvZGF0YVNlbGVjdEFjdGlvbi5qcyc7XG5pbXBvcnQgcGllTGF5b3V0IGZyb20gJy4uL3BpZS9waWVMYXlvdXQuanMnO1xuaW1wb3J0IGRhdGFGaWx0ZXIgZnJvbSAnLi4vLi4vcHJvY2Vzc29yL2RhdGFGaWx0ZXIuanMnO1xuaW1wb3J0IHsgY3VycnkgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IFBpZVZpZXcgZnJvbSAnLi9QaWVWaWV3LmpzJztcbmltcG9ydCBQaWVTZXJpZXNNb2RlbCBmcm9tICcuL1BpZVNlcmllcy5qcyc7XG5pbXBvcnQgbmVnYXRpdmVEYXRhRmlsdGVyIGZyb20gJy4uLy4uL3Byb2Nlc3Nvci9uZWdhdGl2ZURhdGFGaWx0ZXIuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhQaWVWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU2VyaWVzTW9kZWwoUGllU2VyaWVzTW9kZWwpO1xuICBjcmVhdGVMZWdhY3lEYXRhU2VsZWN0QWN0aW9uKCdwaWUnLCByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24pO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQoY3VycnkocGllTGF5b3V0LCAncGllJykpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJQcm9jZXNzb3IoZGF0YUZpbHRlcigncGllJykpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJQcm9jZXNzb3IobmVnYXRpdmVEYXRhRmlsdGVyKCdwaWUnKSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///74625\n")}}]);