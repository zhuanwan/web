"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[8550],{29571:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   V$: () => (/* binding */ brush),\n/* harmony export */   Xi: () => (/* binding */ brushSingle),\n/* harmony export */   ZQ: () => (/* binding */ createCanvasPattern)\n/* harmony export */ });\n/* harmony import */ var _graphic_Displayable_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(71519);\n/* harmony import */ var _core_PathProxy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68717);\n/* harmony import */ var _graphic_helper_image_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12191);\n/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(53479);\n/* harmony import */ var _graphic_Path_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(59482);\n/* harmony import */ var _graphic_Image_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(90540);\n/* harmony import */ var _graphic_TSpan_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(19845);\n/* harmony import */ var _core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _dashStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(76050);\n/* harmony import */ var _graphic_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56448);\n/* harmony import */ var _core_platform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(59741);\n\n\n\n\n\n\n\n\n\n\n\nvar pathProxyForDraw = new _core_PathProxy_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A(true);\nfunction styleHasStroke(style) {\n    var stroke = style.stroke;\n    return !(stroke == null || stroke === 'none' || !(style.lineWidth > 0));\n}\nfunction isValidStrokeFillStyle(strokeOrFill) {\n    return typeof strokeOrFill === 'string' && strokeOrFill !== 'none';\n}\nfunction styleHasFill(style) {\n    var fill = style.fill;\n    return fill != null && fill !== 'none';\n}\nfunction doFillPath(ctx, style) {\n    if (style.fillOpacity != null && style.fillOpacity !== 1) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.fillOpacity * style.opacity;\n        ctx.fill();\n        ctx.globalAlpha = originalGlobalAlpha;\n    }\n    else {\n        ctx.fill();\n    }\n}\nfunction doStrokePath(ctx, style) {\n    if (style.strokeOpacity != null && style.strokeOpacity !== 1) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.strokeOpacity * style.opacity;\n        ctx.stroke();\n        ctx.globalAlpha = originalGlobalAlpha;\n    }\n    else {\n        ctx.stroke();\n    }\n}\nfunction createCanvasPattern(ctx, pattern, el) {\n    var image = (0,_graphic_helper_image_js__WEBPACK_IMPORTED_MODULE_1__/* .createOrUpdateImage */ .OD)(pattern.image, pattern.__image, el);\n    if ((0,_graphic_helper_image_js__WEBPACK_IMPORTED_MODULE_1__/* .isImageReady */ .xA)(image)) {\n        var canvasPattern = ctx.createPattern(image, pattern.repeat || 'repeat');\n        if (typeof DOMMatrix === 'function'\n            && canvasPattern\n            && canvasPattern.setTransform) {\n            var matrix = new DOMMatrix();\n            matrix.translateSelf((pattern.x || 0), (pattern.y || 0));\n            matrix.rotateSelf(0, 0, (pattern.rotation || 0) * _core_util_js__WEBPACK_IMPORTED_MODULE_2__.RADIAN_TO_DEGREE);\n            matrix.scaleSelf((pattern.scaleX || 1), (pattern.scaleY || 1));\n            canvasPattern.setTransform(matrix);\n        }\n        return canvasPattern;\n    }\n}\nfunction brushPath(ctx, el, style, inBatch) {\n    var _a;\n    var hasStroke = styleHasStroke(style);\n    var hasFill = styleHasFill(style);\n    var strokePercent = style.strokePercent;\n    var strokePart = strokePercent < 1;\n    var firstDraw = !el.path;\n    if ((!el.silent || strokePart) && firstDraw) {\n        el.createPathProxy();\n    }\n    var path = el.path || pathProxyForDraw;\n    var dirtyFlag = el.__dirty;\n    if (!inBatch) {\n        var fill = style.fill;\n        var stroke = style.stroke;\n        var hasFillGradient = hasFill && !!fill.colorStops;\n        var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n        var hasFillPattern = hasFill && !!fill.image;\n        var hasStrokePattern = hasStroke && !!stroke.image;\n        var fillGradient = void 0;\n        var strokeGradient = void 0;\n        var fillPattern = void 0;\n        var strokePattern = void 0;\n        var rect = void 0;\n        if (hasFillGradient || hasStrokeGradient) {\n            rect = el.getBoundingRect();\n        }\n        if (hasFillGradient) {\n            fillGradient = dirtyFlag\n                ? (0,_helper_js__WEBPACK_IMPORTED_MODULE_3__/* .getCanvasGradient */ .Ff)(ctx, fill, rect)\n                : el.__canvasFillGradient;\n            el.__canvasFillGradient = fillGradient;\n        }\n        if (hasStrokeGradient) {\n            strokeGradient = dirtyFlag\n                ? (0,_helper_js__WEBPACK_IMPORTED_MODULE_3__/* .getCanvasGradient */ .Ff)(ctx, stroke, rect)\n                : el.__canvasStrokeGradient;\n            el.__canvasStrokeGradient = strokeGradient;\n        }\n        if (hasFillPattern) {\n            fillPattern = (dirtyFlag || !el.__canvasFillPattern)\n                ? createCanvasPattern(ctx, fill, el)\n                : el.__canvasFillPattern;\n            el.__canvasFillPattern = fillPattern;\n        }\n        if (hasStrokePattern) {\n            strokePattern = (dirtyFlag || !el.__canvasStrokePattern)\n                ? createCanvasPattern(ctx, stroke, el)\n                : el.__canvasStrokePattern;\n            el.__canvasStrokePattern = fillPattern;\n        }\n        if (hasFillGradient) {\n            ctx.fillStyle = fillGradient;\n        }\n        else if (hasFillPattern) {\n            if (fillPattern) {\n                ctx.fillStyle = fillPattern;\n            }\n            else {\n                hasFill = false;\n            }\n        }\n        if (hasStrokeGradient) {\n            ctx.strokeStyle = strokeGradient;\n        }\n        else if (hasStrokePattern) {\n            if (strokePattern) {\n                ctx.strokeStyle = strokePattern;\n            }\n            else {\n                hasStroke = false;\n            }\n        }\n    }\n    var scale = el.getGlobalScale();\n    path.setScale(scale[0], scale[1], el.segmentIgnoreThreshold);\n    var lineDash;\n    var lineDashOffset;\n    if (ctx.setLineDash && style.lineDash) {\n        _a = (0,_dashStyle_js__WEBPACK_IMPORTED_MODULE_4__/* .getLineDash */ .V)(el), lineDash = _a[0], lineDashOffset = _a[1];\n    }\n    var needsRebuild = true;\n    if (firstDraw || (dirtyFlag & _graphic_constants_js__WEBPACK_IMPORTED_MODULE_5__/* .SHAPE_CHANGED_BIT */ .Dl)) {\n        path.setDPR(ctx.dpr);\n        if (strokePart) {\n            path.setContext(null);\n        }\n        else {\n            path.setContext(ctx);\n            needsRebuild = false;\n        }\n        path.reset();\n        el.buildPath(path, el.shape, inBatch);\n        path.toStatic();\n        el.pathUpdated();\n    }\n    if (needsRebuild) {\n        path.rebuildPath(ctx, strokePart ? strokePercent : 1);\n    }\n    if (lineDash) {\n        ctx.setLineDash(lineDash);\n        ctx.lineDashOffset = lineDashOffset;\n    }\n    if (!inBatch) {\n        if (style.strokeFirst) {\n            if (hasStroke) {\n                doStrokePath(ctx, style);\n            }\n            if (hasFill) {\n                doFillPath(ctx, style);\n            }\n        }\n        else {\n            if (hasFill) {\n                doFillPath(ctx, style);\n            }\n            if (hasStroke) {\n                doStrokePath(ctx, style);\n            }\n        }\n    }\n    if (lineDash) {\n        ctx.setLineDash([]);\n    }\n}\nfunction brushImage(ctx, el, style) {\n    var image = el.__image = (0,_graphic_helper_image_js__WEBPACK_IMPORTED_MODULE_1__/* .createOrUpdateImage */ .OD)(style.image, el.__image, el, el.onload);\n    if (!image || !(0,_graphic_helper_image_js__WEBPACK_IMPORTED_MODULE_1__/* .isImageReady */ .xA)(image)) {\n        return;\n    }\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var width = el.getWidth();\n    var height = el.getHeight();\n    var aspect = image.width / image.height;\n    if (width == null && height != null) {\n        width = height * aspect;\n    }\n    else if (height == null && width != null) {\n        height = width / aspect;\n    }\n    else if (width == null && height == null) {\n        width = image.width;\n        height = image.height;\n    }\n    if (style.sWidth && style.sHeight) {\n        var sx = style.sx || 0;\n        var sy = style.sy || 0;\n        ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n    }\n    else if (style.sx && style.sy) {\n        var sx = style.sx;\n        var sy = style.sy;\n        var sWidth = width - sx;\n        var sHeight = height - sy;\n        ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n    }\n    else {\n        ctx.drawImage(image, x, y, width, height);\n    }\n}\nfunction brushText(ctx, el, style) {\n    var _a;\n    var text = style.text;\n    text != null && (text += '');\n    if (text) {\n        ctx.font = style.font || _core_platform_js__WEBPACK_IMPORTED_MODULE_6__/* .DEFAULT_FONT */ .OH;\n        ctx.textAlign = style.textAlign;\n        ctx.textBaseline = style.textBaseline;\n        var lineDash = void 0;\n        var lineDashOffset = void 0;\n        if (ctx.setLineDash && style.lineDash) {\n            _a = (0,_dashStyle_js__WEBPACK_IMPORTED_MODULE_4__/* .getLineDash */ .V)(el), lineDash = _a[0], lineDashOffset = _a[1];\n        }\n        if (lineDash) {\n            ctx.setLineDash(lineDash);\n            ctx.lineDashOffset = lineDashOffset;\n        }\n        if (style.strokeFirst) {\n            if (styleHasStroke(style)) {\n                ctx.strokeText(text, style.x, style.y);\n            }\n            if (styleHasFill(style)) {\n                ctx.fillText(text, style.x, style.y);\n            }\n        }\n        else {\n            if (styleHasFill(style)) {\n                ctx.fillText(text, style.x, style.y);\n            }\n            if (styleHasStroke(style)) {\n                ctx.strokeText(text, style.x, style.y);\n            }\n        }\n        if (lineDash) {\n            ctx.setLineDash([]);\n        }\n    }\n}\nvar SHADOW_NUMBER_PROPS = ['shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\nvar STROKE_PROPS = [\n    ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n];\nfunction bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {\n    var styleChanged = false;\n    if (!forceSetAll) {\n        prevStyle = prevStyle || {};\n        if (style === prevStyle) {\n            return false;\n        }\n    }\n    if (forceSetAll || style.opacity !== prevStyle.opacity) {\n        flushPathDrawn(ctx, scope);\n        styleChanged = true;\n        var opacity = Math.max(Math.min(style.opacity, 1), 0);\n        ctx.globalAlpha = isNaN(opacity) ? _graphic_Displayable_js__WEBPACK_IMPORTED_MODULE_7__/* .DEFAULT_COMMON_STYLE */ .oN.opacity : opacity;\n    }\n    if (forceSetAll || style.blend !== prevStyle.blend) {\n        if (!styleChanged) {\n            flushPathDrawn(ctx, scope);\n            styleChanged = true;\n        }\n        ctx.globalCompositeOperation = style.blend || _graphic_Displayable_js__WEBPACK_IMPORTED_MODULE_7__/* .DEFAULT_COMMON_STYLE */ .oN.blend;\n    }\n    for (var i = 0; i < SHADOW_NUMBER_PROPS.length; i++) {\n        var propName = SHADOW_NUMBER_PROPS[i];\n        if (forceSetAll || style[propName] !== prevStyle[propName]) {\n            if (!styleChanged) {\n                flushPathDrawn(ctx, scope);\n                styleChanged = true;\n            }\n            ctx[propName] = ctx.dpr * (style[propName] || 0);\n        }\n    }\n    if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {\n        if (!styleChanged) {\n            flushPathDrawn(ctx, scope);\n            styleChanged = true;\n        }\n        ctx.shadowColor = style.shadowColor || _graphic_Displayable_js__WEBPACK_IMPORTED_MODULE_7__/* .DEFAULT_COMMON_STYLE */ .oN.shadowColor;\n    }\n    return styleChanged;\n}\nfunction bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {\n    var style = getStyle(el, scope.inHover);\n    var prevStyle = forceSetAll\n        ? null\n        : (prevEl && getStyle(prevEl, scope.inHover) || {});\n    if (style === prevStyle) {\n        return false;\n    }\n    var styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);\n    if (forceSetAll || style.fill !== prevStyle.fill) {\n        if (!styleChanged) {\n            flushPathDrawn(ctx, scope);\n            styleChanged = true;\n        }\n        isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill);\n    }\n    if (forceSetAll || style.stroke !== prevStyle.stroke) {\n        if (!styleChanged) {\n            flushPathDrawn(ctx, scope);\n            styleChanged = true;\n        }\n        isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke);\n    }\n    if (forceSetAll || style.opacity !== prevStyle.opacity) {\n        if (!styleChanged) {\n            flushPathDrawn(ctx, scope);\n            styleChanged = true;\n        }\n        ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n    }\n    if (el.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var newLineWidth = lineWidth / ((style.strokeNoScale && el.getLineScale) ? el.getLineScale() : 1);\n        if (ctx.lineWidth !== newLineWidth) {\n            if (!styleChanged) {\n                flushPathDrawn(ctx, scope);\n                styleChanged = true;\n            }\n            ctx.lineWidth = newLineWidth;\n        }\n    }\n    for (var i = 0; i < STROKE_PROPS.length; i++) {\n        var prop = STROKE_PROPS[i];\n        var propName = prop[0];\n        if (forceSetAll || style[propName] !== prevStyle[propName]) {\n            if (!styleChanged) {\n                flushPathDrawn(ctx, scope);\n                styleChanged = true;\n            }\n            ctx[propName] = style[propName] || prop[1];\n        }\n    }\n    return styleChanged;\n}\nfunction bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {\n    return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);\n}\nfunction setContextTransform(ctx, el) {\n    var m = el.transform;\n    var dpr = ctx.dpr || 1;\n    if (m) {\n        ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n    }\n    else {\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n}\nfunction updateClipStatus(clipPaths, ctx, scope) {\n    var allClipped = false;\n    for (var i = 0; i < clipPaths.length; i++) {\n        var clipPath = clipPaths[i];\n        allClipped = allClipped || clipPath.isZeroArea();\n        setContextTransform(ctx, clipPath);\n        ctx.beginPath();\n        clipPath.buildPath(ctx, clipPath.shape);\n        ctx.clip();\n    }\n    scope.allClipped = allClipped;\n}\nfunction isTransformChanged(m0, m1) {\n    if (m0 && m1) {\n        return m0[0] !== m1[0]\n            || m0[1] !== m1[1]\n            || m0[2] !== m1[2]\n            || m0[3] !== m1[3]\n            || m0[4] !== m1[4]\n            || m0[5] !== m1[5];\n    }\n    else if (!m0 && !m1) {\n        return false;\n    }\n    return true;\n}\nvar DRAW_TYPE_PATH = 1;\nvar DRAW_TYPE_IMAGE = 2;\nvar DRAW_TYPE_TEXT = 3;\nvar DRAW_TYPE_INCREMENTAL = 4;\nfunction canPathBatch(style) {\n    var hasFill = styleHasFill(style);\n    var hasStroke = styleHasStroke(style);\n    return !(style.lineDash\n        || !(+hasFill ^ +hasStroke)\n        || (hasFill && typeof style.fill !== 'string')\n        || (hasStroke && typeof style.stroke !== 'string')\n        || style.strokePercent < 1\n        || style.strokeOpacity < 1\n        || style.fillOpacity < 1);\n}\nfunction flushPathDrawn(ctx, scope) {\n    scope.batchFill && ctx.fill();\n    scope.batchStroke && ctx.stroke();\n    scope.batchFill = '';\n    scope.batchStroke = '';\n}\nfunction getStyle(el, inHover) {\n    return inHover ? (el.__hoverStyle || el.style) : el.style;\n}\nfunction brushSingle(ctx, el) {\n    brush(ctx, el, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);\n}\nfunction brush(ctx, el, scope, isLast) {\n    var m = el.transform;\n    if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {\n        el.__dirty &= ~_graphic_constants_js__WEBPACK_IMPORTED_MODULE_5__/* .REDRAW_BIT */ .M;\n        el.__isRendered = false;\n        return;\n    }\n    var clipPaths = el.__clipPaths;\n    var prevElClipPaths = scope.prevElClipPaths;\n    var forceSetTransform = false;\n    var forceSetStyle = false;\n    if (!prevElClipPaths || (0,_helper_js__WEBPACK_IMPORTED_MODULE_3__/* .isClipPathChanged */ .KU)(clipPaths, prevElClipPaths)) {\n        if (prevElClipPaths && prevElClipPaths.length) {\n            flushPathDrawn(ctx, scope);\n            ctx.restore();\n            forceSetStyle = forceSetTransform = true;\n            scope.prevElClipPaths = null;\n            scope.allClipped = false;\n            scope.prevEl = null;\n        }\n        if (clipPaths && clipPaths.length) {\n            flushPathDrawn(ctx, scope);\n            ctx.save();\n            updateClipStatus(clipPaths, ctx, scope);\n            forceSetTransform = true;\n        }\n        scope.prevElClipPaths = clipPaths;\n    }\n    if (scope.allClipped) {\n        el.__isRendered = false;\n        return;\n    }\n    el.beforeBrush && el.beforeBrush();\n    el.innerBeforeBrush();\n    var prevEl = scope.prevEl;\n    if (!prevEl) {\n        forceSetStyle = forceSetTransform = true;\n    }\n    var canBatchPath = el instanceof _graphic_Path_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .Ay\n        && el.autoBatch\n        && canPathBatch(el.style);\n    if (forceSetTransform || isTransformChanged(m, prevEl.transform)) {\n        flushPathDrawn(ctx, scope);\n        setContextTransform(ctx, el);\n    }\n    else if (!canBatchPath) {\n        flushPathDrawn(ctx, scope);\n    }\n    var style = getStyle(el, scope.inHover);\n    if (el instanceof _graphic_Path_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .Ay) {\n        if (scope.lastDrawType !== DRAW_TYPE_PATH) {\n            forceSetStyle = true;\n            scope.lastDrawType = DRAW_TYPE_PATH;\n        }\n        bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);\n        if (!canBatchPath || (!scope.batchFill && !scope.batchStroke)) {\n            ctx.beginPath();\n        }\n        brushPath(ctx, el, style, canBatchPath);\n        if (canBatchPath) {\n            scope.batchFill = style.fill || '';\n            scope.batchStroke = style.stroke || '';\n        }\n    }\n    else {\n        if (el instanceof _graphic_TSpan_js__WEBPACK_IMPORTED_MODULE_9__/* [\"default\"] */ .A) {\n            if (scope.lastDrawType !== DRAW_TYPE_TEXT) {\n                forceSetStyle = true;\n                scope.lastDrawType = DRAW_TYPE_TEXT;\n            }\n            bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);\n            brushText(ctx, el, style);\n        }\n        else if (el instanceof _graphic_Image_js__WEBPACK_IMPORTED_MODULE_10__/* [\"default\"] */ .Ay) {\n            if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {\n                forceSetStyle = true;\n                scope.lastDrawType = DRAW_TYPE_IMAGE;\n            }\n            bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);\n            brushImage(ctx, el, style);\n        }\n        else if (el.getTemporalDisplayables) {\n            if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {\n                forceSetStyle = true;\n                scope.lastDrawType = DRAW_TYPE_INCREMENTAL;\n            }\n            brushIncremental(ctx, el, scope);\n        }\n    }\n    if (canBatchPath && isLast) {\n        flushPathDrawn(ctx, scope);\n    }\n    el.innerAfterBrush();\n    el.afterBrush && el.afterBrush();\n    scope.prevEl = el;\n    el.__dirty = 0;\n    el.__isRendered = true;\n}\nfunction brushIncremental(ctx, el, scope) {\n    var displayables = el.getDisplayables();\n    var temporalDisplayables = el.getTemporalDisplayables();\n    ctx.save();\n    var innerScope = {\n        prevElClipPaths: null,\n        prevEl: null,\n        allClipped: false,\n        viewWidth: scope.viewWidth,\n        viewHeight: scope.viewHeight,\n        inHover: scope.inHover\n    };\n    var i;\n    var len;\n    for (i = el.getCursor(), len = displayables.length; i < len; i++) {\n        var displayable = displayables[i];\n        displayable.beforeBrush && displayable.beforeBrush();\n        displayable.innerBeforeBrush();\n        brush(ctx, displayable, innerScope, i === len - 1);\n        displayable.innerAfterBrush();\n        displayable.afterBrush && displayable.afterBrush();\n        innerScope.prevEl = displayable;\n    }\n    for (var i_1 = 0, len_1 = temporalDisplayables.length; i_1 < len_1; i_1++) {\n        var displayable = temporalDisplayables[i_1];\n        displayable.beforeBrush && displayable.beforeBrush();\n        displayable.innerBeforeBrush();\n        brush(ctx, displayable, innerScope, i_1 === len_1 - 1);\n        displayable.innerAfterBrush();\n        displayable.afterBrush && displayable.afterBrush();\n        innerScope.prevEl = displayable;\n    }\n    el.clearTemporalDisplayables();\n    el.notClear = true;\n    ctx.restore();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk1NzEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jYW52YXMvZ3JhcGhpYy5qcz9iYjg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFRkFVTFRfQ09NTU9OX1NUWUxFIH0gZnJvbSAnLi4vZ3JhcGhpYy9EaXNwbGF5YWJsZS5qcyc7XG5pbXBvcnQgUGF0aFByb3h5IGZyb20gJy4uL2NvcmUvUGF0aFByb3h5LmpzJztcbmltcG9ydCB7IGNyZWF0ZU9yVXBkYXRlSW1hZ2UsIGlzSW1hZ2VSZWFkeSB9IGZyb20gJy4uL2dyYXBoaWMvaGVscGVyL2ltYWdlLmpzJztcbmltcG9ydCB7IGdldENhbnZhc0dyYWRpZW50LCBpc0NsaXBQYXRoQ2hhbmdlZCB9IGZyb20gJy4vaGVscGVyLmpzJztcbmltcG9ydCBQYXRoIGZyb20gJy4uL2dyYXBoaWMvUGF0aC5qcyc7XG5pbXBvcnQgWlJJbWFnZSBmcm9tICcuLi9ncmFwaGljL0ltYWdlLmpzJztcbmltcG9ydCBUU3BhbiBmcm9tICcuLi9ncmFwaGljL1RTcGFuLmpzJztcbmltcG9ydCB7IFJBRElBTl9UT19ERUdSRUUgfSBmcm9tICcuLi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgZ2V0TGluZURhc2ggfSBmcm9tICcuL2Rhc2hTdHlsZS5qcyc7XG5pbXBvcnQgeyBSRURSQVdfQklULCBTSEFQRV9DSEFOR0VEX0JJVCB9IGZyb20gJy4uL2dyYXBoaWMvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IERFRkFVTFRfRk9OVCB9IGZyb20gJy4uL2NvcmUvcGxhdGZvcm0uanMnO1xudmFyIHBhdGhQcm94eUZvckRyYXcgPSBuZXcgUGF0aFByb3h5KHRydWUpO1xuZnVuY3Rpb24gc3R5bGVIYXNTdHJva2Uoc3R5bGUpIHtcbiAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgIHJldHVybiAhKHN0cm9rZSA9PSBudWxsIHx8IHN0cm9rZSA9PT0gJ25vbmUnIHx8ICEoc3R5bGUubGluZVdpZHRoID4gMCkpO1xufVxuZnVuY3Rpb24gaXNWYWxpZFN0cm9rZUZpbGxTdHlsZShzdHJva2VPckZpbGwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHN0cm9rZU9yRmlsbCA9PT0gJ3N0cmluZycgJiYgc3Ryb2tlT3JGaWxsICE9PSAnbm9uZSc7XG59XG5mdW5jdGlvbiBzdHlsZUhhc0ZpbGwoc3R5bGUpIHtcbiAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGw7XG4gICAgcmV0dXJuIGZpbGwgIT0gbnVsbCAmJiBmaWxsICE9PSAnbm9uZSc7XG59XG5mdW5jdGlvbiBkb0ZpbGxQYXRoKGN0eCwgc3R5bGUpIHtcbiAgICBpZiAoc3R5bGUuZmlsbE9wYWNpdHkgIT0gbnVsbCAmJiBzdHlsZS5maWxsT3BhY2l0eSAhPT0gMSkge1xuICAgICAgICB2YXIgb3JpZ2luYWxHbG9iYWxBbHBoYSA9IGN0eC5nbG9iYWxBbHBoYTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3R5bGUuZmlsbE9wYWNpdHkgKiBzdHlsZS5vcGFjaXR5O1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcmlnaW5hbEdsb2JhbEFscGhhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkb1N0cm9rZVBhdGgoY3R4LCBzdHlsZSkge1xuICAgIGlmIChzdHlsZS5zdHJva2VPcGFjaXR5ICE9IG51bGwgJiYgc3R5bGUuc3Ryb2tlT3BhY2l0eSAhPT0gMSkge1xuICAgICAgICB2YXIgb3JpZ2luYWxHbG9iYWxBbHBoYSA9IGN0eC5nbG9iYWxBbHBoYTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3R5bGUuc3Ryb2tlT3BhY2l0eSAqIHN0eWxlLm9wYWNpdHk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3JpZ2luYWxHbG9iYWxBbHBoYTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FudmFzUGF0dGVybihjdHgsIHBhdHRlcm4sIGVsKSB7XG4gICAgdmFyIGltYWdlID0gY3JlYXRlT3JVcGRhdGVJbWFnZShwYXR0ZXJuLmltYWdlLCBwYXR0ZXJuLl9faW1hZ2UsIGVsKTtcbiAgICBpZiAoaXNJbWFnZVJlYWR5KGltYWdlKSkge1xuICAgICAgICB2YXIgY2FudmFzUGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKGltYWdlLCBwYXR0ZXJuLnJlcGVhdCB8fCAncmVwZWF0Jyk7XG4gICAgICAgIGlmICh0eXBlb2YgRE9NTWF0cml4ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAmJiBjYW52YXNQYXR0ZXJuXG4gICAgICAgICAgICAmJiBjYW52YXNQYXR0ZXJuLnNldFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBET01NYXRyaXgoKTtcbiAgICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGVTZWxmKChwYXR0ZXJuLnggfHwgMCksIChwYXR0ZXJuLnkgfHwgMCkpO1xuICAgICAgICAgICAgbWF0cml4LnJvdGF0ZVNlbGYoMCwgMCwgKHBhdHRlcm4ucm90YXRpb24gfHwgMCkgKiBSQURJQU5fVE9fREVHUkVFKTtcbiAgICAgICAgICAgIG1hdHJpeC5zY2FsZVNlbGYoKHBhdHRlcm4uc2NhbGVYIHx8IDEpLCAocGF0dGVybi5zY2FsZVkgfHwgMSkpO1xuICAgICAgICAgICAgY2FudmFzUGF0dGVybi5zZXRUcmFuc2Zvcm0obWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FudmFzUGF0dGVybjtcbiAgICB9XG59XG5mdW5jdGlvbiBicnVzaFBhdGgoY3R4LCBlbCwgc3R5bGUsIGluQmF0Y2gpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGhhc1N0cm9rZSA9IHN0eWxlSGFzU3Ryb2tlKHN0eWxlKTtcbiAgICB2YXIgaGFzRmlsbCA9IHN0eWxlSGFzRmlsbChzdHlsZSk7XG4gICAgdmFyIHN0cm9rZVBlcmNlbnQgPSBzdHlsZS5zdHJva2VQZXJjZW50O1xuICAgIHZhciBzdHJva2VQYXJ0ID0gc3Ryb2tlUGVyY2VudCA8IDE7XG4gICAgdmFyIGZpcnN0RHJhdyA9ICFlbC5wYXRoO1xuICAgIGlmICgoIWVsLnNpbGVudCB8fCBzdHJva2VQYXJ0KSAmJiBmaXJzdERyYXcpIHtcbiAgICAgICAgZWwuY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgfVxuICAgIHZhciBwYXRoID0gZWwucGF0aCB8fCBwYXRoUHJveHlGb3JEcmF3O1xuICAgIHZhciBkaXJ0eUZsYWcgPSBlbC5fX2RpcnR5O1xuICAgIGlmICghaW5CYXRjaCkge1xuICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGw7XG4gICAgICAgIHZhciBzdHJva2UgPSBzdHlsZS5zdHJva2U7XG4gICAgICAgIHZhciBoYXNGaWxsR3JhZGllbnQgPSBoYXNGaWxsICYmICEhZmlsbC5jb2xvclN0b3BzO1xuICAgICAgICB2YXIgaGFzU3Ryb2tlR3JhZGllbnQgPSBoYXNTdHJva2UgJiYgISFzdHJva2UuY29sb3JTdG9wcztcbiAgICAgICAgdmFyIGhhc0ZpbGxQYXR0ZXJuID0gaGFzRmlsbCAmJiAhIWZpbGwuaW1hZ2U7XG4gICAgICAgIHZhciBoYXNTdHJva2VQYXR0ZXJuID0gaGFzU3Ryb2tlICYmICEhc3Ryb2tlLmltYWdlO1xuICAgICAgICB2YXIgZmlsbEdyYWRpZW50ID0gdm9pZCAwO1xuICAgICAgICB2YXIgc3Ryb2tlR3JhZGllbnQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBmaWxsUGF0dGVybiA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHN0cm9rZVBhdHRlcm4gPSB2b2lkIDA7XG4gICAgICAgIHZhciByZWN0ID0gdm9pZCAwO1xuICAgICAgICBpZiAoaGFzRmlsbEdyYWRpZW50IHx8IGhhc1N0cm9rZUdyYWRpZW50KSB7XG4gICAgICAgICAgICByZWN0ID0gZWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0ZpbGxHcmFkaWVudCkge1xuICAgICAgICAgICAgZmlsbEdyYWRpZW50ID0gZGlydHlGbGFnXG4gICAgICAgICAgICAgICAgPyBnZXRDYW52YXNHcmFkaWVudChjdHgsIGZpbGwsIHJlY3QpXG4gICAgICAgICAgICAgICAgOiBlbC5fX2NhbnZhc0ZpbGxHcmFkaWVudDtcbiAgICAgICAgICAgIGVsLl9fY2FudmFzRmlsbEdyYWRpZW50ID0gZmlsbEdyYWRpZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICAgICAgc3Ryb2tlR3JhZGllbnQgPSBkaXJ0eUZsYWdcbiAgICAgICAgICAgICAgICA/IGdldENhbnZhc0dyYWRpZW50KGN0eCwgc3Ryb2tlLCByZWN0KVxuICAgICAgICAgICAgICAgIDogZWwuX19jYW52YXNTdHJva2VHcmFkaWVudDtcbiAgICAgICAgICAgIGVsLl9fY2FudmFzU3Ryb2tlR3JhZGllbnQgPSBzdHJva2VHcmFkaWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRmlsbFBhdHRlcm4pIHtcbiAgICAgICAgICAgIGZpbGxQYXR0ZXJuID0gKGRpcnR5RmxhZyB8fCAhZWwuX19jYW52YXNGaWxsUGF0dGVybilcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNhbnZhc1BhdHRlcm4oY3R4LCBmaWxsLCBlbClcbiAgICAgICAgICAgICAgICA6IGVsLl9fY2FudmFzRmlsbFBhdHRlcm47XG4gICAgICAgICAgICBlbC5fX2NhbnZhc0ZpbGxQYXR0ZXJuID0gZmlsbFBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1N0cm9rZVBhdHRlcm4pIHtcbiAgICAgICAgICAgIHN0cm9rZVBhdHRlcm4gPSAoZGlydHlGbGFnIHx8ICFlbC5fX2NhbnZhc1N0cm9rZVBhdHRlcm4pXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDYW52YXNQYXR0ZXJuKGN0eCwgc3Ryb2tlLCBlbClcbiAgICAgICAgICAgICAgICA6IGVsLl9fY2FudmFzU3Ryb2tlUGF0dGVybjtcbiAgICAgICAgICAgIGVsLl9fY2FudmFzU3Ryb2tlUGF0dGVybiA9IGZpbGxQYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNGaWxsR3JhZGllbnQpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsR3JhZGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzRmlsbFBhdHRlcm4pIHtcbiAgICAgICAgICAgIGlmIChmaWxsUGF0dGVybikge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsUGF0dGVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhc0ZpbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUdyYWRpZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc1N0cm9rZVBhdHRlcm4pIHtcbiAgICAgICAgICAgIGlmIChzdHJva2VQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlUGF0dGVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhc1N0cm9rZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzY2FsZSA9IGVsLmdldEdsb2JhbFNjYWxlKCk7XG4gICAgcGF0aC5zZXRTY2FsZShzY2FsZVswXSwgc2NhbGVbMV0sIGVsLnNlZ21lbnRJZ25vcmVUaHJlc2hvbGQpO1xuICAgIHZhciBsaW5lRGFzaDtcbiAgICB2YXIgbGluZURhc2hPZmZzZXQ7XG4gICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAmJiBzdHlsZS5saW5lRGFzaCkge1xuICAgICAgICBfYSA9IGdldExpbmVEYXNoKGVsKSwgbGluZURhc2ggPSBfYVswXSwgbGluZURhc2hPZmZzZXQgPSBfYVsxXTtcbiAgICB9XG4gICAgdmFyIG5lZWRzUmVidWlsZCA9IHRydWU7XG4gICAgaWYgKGZpcnN0RHJhdyB8fCAoZGlydHlGbGFnICYgU0hBUEVfQ0hBTkdFRF9CSVQpKSB7XG4gICAgICAgIHBhdGguc2V0RFBSKGN0eC5kcHIpO1xuICAgICAgICBpZiAoc3Ryb2tlUGFydCkge1xuICAgICAgICAgICAgcGF0aC5zZXRDb250ZXh0KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5zZXRDb250ZXh0KGN0eCk7XG4gICAgICAgICAgICBuZWVkc1JlYnVpbGQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoLnJlc2V0KCk7XG4gICAgICAgIGVsLmJ1aWxkUGF0aChwYXRoLCBlbC5zaGFwZSwgaW5CYXRjaCk7XG4gICAgICAgIHBhdGgudG9TdGF0aWMoKTtcbiAgICAgICAgZWwucGF0aFVwZGF0ZWQoKTtcbiAgICB9XG4gICAgaWYgKG5lZWRzUmVidWlsZCkge1xuICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCwgc3Ryb2tlUGFydCA/IHN0cm9rZVBlcmNlbnQgOiAxKTtcbiAgICB9XG4gICAgaWYgKGxpbmVEYXNoKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgIH1cbiAgICBpZiAoIWluQmF0Y2gpIHtcbiAgICAgICAgaWYgKHN0eWxlLnN0cm9rZUZpcnN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgZG9TdHJva2VQYXRoKGN0eCwgc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0ZpbGwpIHtcbiAgICAgICAgICAgICAgICBkb0ZpbGxQYXRoKGN0eCwgc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhc0ZpbGwpIHtcbiAgICAgICAgICAgICAgICBkb0ZpbGxQYXRoKGN0eCwgc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgIGRvU3Ryb2tlUGF0aChjdHgsIHN0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGluZURhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBicnVzaEltYWdlKGN0eCwgZWwsIHN0eWxlKSB7XG4gICAgdmFyIGltYWdlID0gZWwuX19pbWFnZSA9IGNyZWF0ZU9yVXBkYXRlSW1hZ2Uoc3R5bGUuaW1hZ2UsIGVsLl9faW1hZ2UsIGVsLCBlbC5vbmxvYWQpO1xuICAgIGlmICghaW1hZ2UgfHwgIWlzSW1hZ2VSZWFkeShpbWFnZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgICB2YXIgd2lkdGggPSBlbC5nZXRXaWR0aCgpO1xuICAgIHZhciBoZWlnaHQgPSBlbC5nZXRIZWlnaHQoKTtcbiAgICB2YXIgYXNwZWN0ID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQ7XG4gICAgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3Q7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhlaWdodCA9PSBudWxsICYmIHdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIH1cbiAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcbiAgICAgICAgdmFyIHN4ID0gc3R5bGUuc3ggfHwgMDtcbiAgICAgICAgdmFyIHN5ID0gc3R5bGUuc3kgfHwgMDtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHlsZS5zeCAmJiBzdHlsZS5zeSkge1xuICAgICAgICB2YXIgc3ggPSBzdHlsZS5zeDtcbiAgICAgICAgdmFyIHN5ID0gc3R5bGUuc3k7XG4gICAgICAgIHZhciBzV2lkdGggPSB3aWR0aCAtIHN4O1xuICAgICAgICB2YXIgc0hlaWdodCA9IGhlaWdodCAtIHN5O1xuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBzeCwgc3ksIHNXaWR0aCwgc0hlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBicnVzaFRleHQoY3R4LCBlbCwgc3R5bGUpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0O1xuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG4gICAgaWYgKHRleHQpIHtcbiAgICAgICAgY3R4LmZvbnQgPSBzdHlsZS5mb250IHx8IERFRkFVTFRfRk9OVDtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgICAgICAgdmFyIGxpbmVEYXNoID0gdm9pZCAwO1xuICAgICAgICB2YXIgbGluZURhc2hPZmZzZXQgPSB2b2lkIDA7XG4gICAgICAgIGlmIChjdHguc2V0TGluZURhc2ggJiYgc3R5bGUubGluZURhc2gpIHtcbiAgICAgICAgICAgIF9hID0gZ2V0TGluZURhc2goZWwpLCBsaW5lRGFzaCA9IF9hWzBdLCBsaW5lRGFzaE9mZnNldCA9IF9hWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lRGFzaCkge1xuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZS5zdHJva2VGaXJzdCkge1xuICAgICAgICAgICAgaWYgKHN0eWxlSGFzU3Ryb2tlKHN0eWxlKSkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHRleHQsIHN0eWxlLngsIHN0eWxlLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0eWxlSGFzRmlsbChzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgc3R5bGUueCwgc3R5bGUueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3R5bGVIYXNGaWxsKHN0eWxlKSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBzdHlsZS54LCBzdHlsZS55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHlsZUhhc1N0cm9rZShzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlVGV4dCh0ZXh0LCBzdHlsZS54LCBzdHlsZS55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZURhc2gpIHtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgU0hBRE9XX05VTUJFUl9QUk9QUyA9IFsnc2hhZG93Qmx1cicsICdzaGFkb3dPZmZzZXRYJywgJ3NoYWRvd09mZnNldFknXTtcbnZhciBTVFJPS0VfUFJPUFMgPSBbXG4gICAgWydsaW5lQ2FwJywgJ2J1dHQnXSwgWydsaW5lSm9pbicsICdtaXRlciddLCBbJ21pdGVyTGltaXQnLCAxMF1cbl07XG5mdW5jdGlvbiBiaW5kQ29tbW9uUHJvcHMoY3R4LCBzdHlsZSwgcHJldlN0eWxlLCBmb3JjZVNldEFsbCwgc2NvcGUpIHtcbiAgICB2YXIgc3R5bGVDaGFuZ2VkID0gZmFsc2U7XG4gICAgaWYgKCFmb3JjZVNldEFsbCkge1xuICAgICAgICBwcmV2U3R5bGUgPSBwcmV2U3R5bGUgfHwge307XG4gICAgICAgIGlmIChzdHlsZSA9PT0gcHJldlN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvcmNlU2V0QWxsIHx8IHN0eWxlLm9wYWNpdHkgIT09IHByZXZTdHlsZS5vcGFjaXR5KSB7XG4gICAgICAgIGZsdXNoUGF0aERyYXduKGN0eCwgc2NvcGUpO1xuICAgICAgICBzdHlsZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB2YXIgb3BhY2l0eSA9IE1hdGgubWF4KE1hdGgubWluKHN0eWxlLm9wYWNpdHksIDEpLCAwKTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gaXNOYU4ob3BhY2l0eSkgPyBERUZBVUxUX0NPTU1PTl9TVFlMRS5vcGFjaXR5IDogb3BhY2l0eTtcbiAgICB9XG4gICAgaWYgKGZvcmNlU2V0QWxsIHx8IHN0eWxlLmJsZW5kICE9PSBwcmV2U3R5bGUuYmxlbmQpIHtcbiAgICAgICAgaWYgKCFzdHlsZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGZsdXNoUGF0aERyYXduKGN0eCwgc2NvcGUpO1xuICAgICAgICAgICAgc3R5bGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gc3R5bGUuYmxlbmQgfHwgREVGQVVMVF9DT01NT05fU1RZTEUuYmxlbmQ7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU0hBRE9XX05VTUJFUl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBTSEFET1dfTlVNQkVSX1BST1BTW2ldO1xuICAgICAgICBpZiAoZm9yY2VTZXRBbGwgfHwgc3R5bGVbcHJvcE5hbWVdICE9PSBwcmV2U3R5bGVbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGZsdXNoUGF0aERyYXduKGN0eCwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIHN0eWxlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHhbcHJvcE5hbWVdID0gY3R4LmRwciAqIChzdHlsZVtwcm9wTmFtZV0gfHwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvcmNlU2V0QWxsIHx8IHN0eWxlLnNoYWRvd0NvbG9yICE9PSBwcmV2U3R5bGUuc2hhZG93Q29sb3IpIHtcbiAgICAgICAgaWYgKCFzdHlsZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGZsdXNoUGF0aERyYXduKGN0eCwgc2NvcGUpO1xuICAgICAgICAgICAgc3R5bGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBzdHlsZS5zaGFkb3dDb2xvciB8fCBERUZBVUxUX0NPTU1PTl9TVFlMRS5zaGFkb3dDb2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlQ2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGJpbmRQYXRoQW5kVGV4dENvbW1vblN0eWxlKGN0eCwgZWwsIHByZXZFbCwgZm9yY2VTZXRBbGwsIHNjb3BlKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0U3R5bGUoZWwsIHNjb3BlLmluSG92ZXIpO1xuICAgIHZhciBwcmV2U3R5bGUgPSBmb3JjZVNldEFsbFxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiAocHJldkVsICYmIGdldFN0eWxlKHByZXZFbCwgc2NvcGUuaW5Ib3ZlcikgfHwge30pO1xuICAgIGlmIChzdHlsZSA9PT0gcHJldlN0eWxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHN0eWxlQ2hhbmdlZCA9IGJpbmRDb21tb25Qcm9wcyhjdHgsIHN0eWxlLCBwcmV2U3R5bGUsIGZvcmNlU2V0QWxsLCBzY29wZSk7XG4gICAgaWYgKGZvcmNlU2V0QWxsIHx8IHN0eWxlLmZpbGwgIT09IHByZXZTdHlsZS5maWxsKSB7XG4gICAgICAgIGlmICghc3R5bGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBmbHVzaFBhdGhEcmF3bihjdHgsIHNjb3BlKTtcbiAgICAgICAgICAgIHN0eWxlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaXNWYWxpZFN0cm9rZUZpbGxTdHlsZShzdHlsZS5maWxsKSAmJiAoY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmZpbGwpO1xuICAgIH1cbiAgICBpZiAoZm9yY2VTZXRBbGwgfHwgc3R5bGUuc3Ryb2tlICE9PSBwcmV2U3R5bGUuc3Ryb2tlKSB7XG4gICAgICAgIGlmICghc3R5bGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBmbHVzaFBhdGhEcmF3bihjdHgsIHNjb3BlKTtcbiAgICAgICAgICAgIHN0eWxlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaXNWYWxpZFN0cm9rZUZpbGxTdHlsZShzdHlsZS5zdHJva2UpICYmIChjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2UpO1xuICAgIH1cbiAgICBpZiAoZm9yY2VTZXRBbGwgfHwgc3R5bGUub3BhY2l0eSAhPT0gcHJldlN0eWxlLm9wYWNpdHkpIHtcbiAgICAgICAgaWYgKCFzdHlsZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGZsdXNoUGF0aERyYXduKGN0eCwgc2NvcGUpO1xuICAgICAgICAgICAgc3R5bGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdHlsZS5vcGFjaXR5ID09IG51bGwgPyAxIDogc3R5bGUub3BhY2l0eTtcbiAgICB9XG4gICAgaWYgKGVsLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgIHZhciBuZXdMaW5lV2lkdGggPSBsaW5lV2lkdGggLyAoKHN0eWxlLnN0cm9rZU5vU2NhbGUgJiYgZWwuZ2V0TGluZVNjYWxlKSA/IGVsLmdldExpbmVTY2FsZSgpIDogMSk7XG4gICAgICAgIGlmIChjdHgubGluZVdpZHRoICE9PSBuZXdMaW5lV2lkdGgpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hQYXRoRHJhd24oY3R4LCBzY29wZSk7XG4gICAgICAgICAgICAgICAgc3R5bGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBuZXdMaW5lV2lkdGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTVFJPS0VfUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBTVFJPS0VfUFJPUFNbaV07XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BbMF07XG4gICAgICAgIGlmIChmb3JjZVNldEFsbCB8fCBzdHlsZVtwcm9wTmFtZV0gIT09IHByZXZTdHlsZVtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hQYXRoRHJhd24oY3R4LCBzY29wZSk7XG4gICAgICAgICAgICAgICAgc3R5bGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eFtwcm9wTmFtZV0gPSBzdHlsZVtwcm9wTmFtZV0gfHwgcHJvcFsxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVDaGFuZ2VkO1xufVxuZnVuY3Rpb24gYmluZEltYWdlU3R5bGUoY3R4LCBlbCwgcHJldkVsLCBmb3JjZVNldEFsbCwgc2NvcGUpIHtcbiAgICByZXR1cm4gYmluZENvbW1vblByb3BzKGN0eCwgZ2V0U3R5bGUoZWwsIHNjb3BlLmluSG92ZXIpLCBwcmV2RWwgJiYgZ2V0U3R5bGUocHJldkVsLCBzY29wZS5pbkhvdmVyKSwgZm9yY2VTZXRBbGwsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIHNldENvbnRleHRUcmFuc2Zvcm0oY3R4LCBlbCkge1xuICAgIHZhciBtID0gZWwudHJhbnNmb3JtO1xuICAgIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybShkcHIgKiBtWzBdLCBkcHIgKiBtWzFdLCBkcHIgKiBtWzJdLCBkcHIgKiBtWzNdLCBkcHIgKiBtWzRdLCBkcHIgKiBtWzVdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNsaXBTdGF0dXMoY2xpcFBhdGhzLCBjdHgsIHNjb3BlKSB7XG4gICAgdmFyIGFsbENsaXBwZWQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgICAgIGFsbENsaXBwZWQgPSBhbGxDbGlwcGVkIHx8IGNsaXBQYXRoLmlzWmVyb0FyZWEoKTtcbiAgICAgICAgc2V0Q29udGV4dFRyYW5zZm9ybShjdHgsIGNsaXBQYXRoKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjbGlwUGF0aC5idWlsZFBhdGgoY3R4LCBjbGlwUGF0aC5zaGFwZSk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgfVxuICAgIHNjb3BlLmFsbENsaXBwZWQgPSBhbGxDbGlwcGVkO1xufVxuZnVuY3Rpb24gaXNUcmFuc2Zvcm1DaGFuZ2VkKG0wLCBtMSkge1xuICAgIGlmIChtMCAmJiBtMSkge1xuICAgICAgICByZXR1cm4gbTBbMF0gIT09IG0xWzBdXG4gICAgICAgICAgICB8fCBtMFsxXSAhPT0gbTFbMV1cbiAgICAgICAgICAgIHx8IG0wWzJdICE9PSBtMVsyXVxuICAgICAgICAgICAgfHwgbTBbM10gIT09IG0xWzNdXG4gICAgICAgICAgICB8fCBtMFs0XSAhPT0gbTFbNF1cbiAgICAgICAgICAgIHx8IG0wWzVdICE9PSBtMVs1XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIW0wICYmICFtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxudmFyIERSQVdfVFlQRV9QQVRIID0gMTtcbnZhciBEUkFXX1RZUEVfSU1BR0UgPSAyO1xudmFyIERSQVdfVFlQRV9URVhUID0gMztcbnZhciBEUkFXX1RZUEVfSU5DUkVNRU5UQUwgPSA0O1xuZnVuY3Rpb24gY2FuUGF0aEJhdGNoKHN0eWxlKSB7XG4gICAgdmFyIGhhc0ZpbGwgPSBzdHlsZUhhc0ZpbGwoc3R5bGUpO1xuICAgIHZhciBoYXNTdHJva2UgPSBzdHlsZUhhc1N0cm9rZShzdHlsZSk7XG4gICAgcmV0dXJuICEoc3R5bGUubGluZURhc2hcbiAgICAgICAgfHwgISgraGFzRmlsbCBeICtoYXNTdHJva2UpXG4gICAgICAgIHx8IChoYXNGaWxsICYmIHR5cGVvZiBzdHlsZS5maWxsICE9PSAnc3RyaW5nJylcbiAgICAgICAgfHwgKGhhc1N0cm9rZSAmJiB0eXBlb2Ygc3R5bGUuc3Ryb2tlICE9PSAnc3RyaW5nJylcbiAgICAgICAgfHwgc3R5bGUuc3Ryb2tlUGVyY2VudCA8IDFcbiAgICAgICAgfHwgc3R5bGUuc3Ryb2tlT3BhY2l0eSA8IDFcbiAgICAgICAgfHwgc3R5bGUuZmlsbE9wYWNpdHkgPCAxKTtcbn1cbmZ1bmN0aW9uIGZsdXNoUGF0aERyYXduKGN0eCwgc2NvcGUpIHtcbiAgICBzY29wZS5iYXRjaEZpbGwgJiYgY3R4LmZpbGwoKTtcbiAgICBzY29wZS5iYXRjaFN0cm9rZSAmJiBjdHguc3Ryb2tlKCk7XG4gICAgc2NvcGUuYmF0Y2hGaWxsID0gJyc7XG4gICAgc2NvcGUuYmF0Y2hTdHJva2UgPSAnJztcbn1cbmZ1bmN0aW9uIGdldFN0eWxlKGVsLCBpbkhvdmVyKSB7XG4gICAgcmV0dXJuIGluSG92ZXIgPyAoZWwuX19ob3ZlclN0eWxlIHx8IGVsLnN0eWxlKSA6IGVsLnN0eWxlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJydXNoU2luZ2xlKGN0eCwgZWwpIHtcbiAgICBicnVzaChjdHgsIGVsLCB7IGluSG92ZXI6IGZhbHNlLCB2aWV3V2lkdGg6IDAsIHZpZXdIZWlnaHQ6IDAgfSwgdHJ1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnJ1c2goY3R4LCBlbCwgc2NvcGUsIGlzTGFzdCkge1xuICAgIHZhciBtID0gZWwudHJhbnNmb3JtO1xuICAgIGlmICghZWwuc2hvdWxkQmVQYWludGVkKHNjb3BlLnZpZXdXaWR0aCwgc2NvcGUudmlld0hlaWdodCwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgICBlbC5fX2RpcnR5ICY9IH5SRURSQVdfQklUO1xuICAgICAgICBlbC5fX2lzUmVuZGVyZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2xpcFBhdGhzID0gZWwuX19jbGlwUGF0aHM7XG4gICAgdmFyIHByZXZFbENsaXBQYXRocyA9IHNjb3BlLnByZXZFbENsaXBQYXRocztcbiAgICB2YXIgZm9yY2VTZXRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICB2YXIgZm9yY2VTZXRTdHlsZSA9IGZhbHNlO1xuICAgIGlmICghcHJldkVsQ2xpcFBhdGhzIHx8IGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgcHJldkVsQ2xpcFBhdGhzKSkge1xuICAgICAgICBpZiAocHJldkVsQ2xpcFBhdGhzICYmIHByZXZFbENsaXBQYXRocy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZsdXNoUGF0aERyYXduKGN0eCwgc2NvcGUpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIGZvcmNlU2V0U3R5bGUgPSBmb3JjZVNldFRyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgICBzY29wZS5wcmV2RWxDbGlwUGF0aHMgPSBudWxsO1xuICAgICAgICAgICAgc2NvcGUuYWxsQ2xpcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2NvcGUucHJldkVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpcFBhdGhzICYmIGNsaXBQYXRocy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZsdXNoUGF0aERyYXduKGN0eCwgc2NvcGUpO1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIHVwZGF0ZUNsaXBTdGF0dXMoY2xpcFBhdGhzLCBjdHgsIHNjb3BlKTtcbiAgICAgICAgICAgIGZvcmNlU2V0VHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzY29wZS5wcmV2RWxDbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG4gICAgfVxuICAgIGlmIChzY29wZS5hbGxDbGlwcGVkKSB7XG4gICAgICAgIGVsLl9faXNSZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsLmJlZm9yZUJydXNoICYmIGVsLmJlZm9yZUJydXNoKCk7XG4gICAgZWwuaW5uZXJCZWZvcmVCcnVzaCgpO1xuICAgIHZhciBwcmV2RWwgPSBzY29wZS5wcmV2RWw7XG4gICAgaWYgKCFwcmV2RWwpIHtcbiAgICAgICAgZm9yY2VTZXRTdHlsZSA9IGZvcmNlU2V0VHJhbnNmb3JtID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGNhbkJhdGNoUGF0aCA9IGVsIGluc3RhbmNlb2YgUGF0aFxuICAgICAgICAmJiBlbC5hdXRvQmF0Y2hcbiAgICAgICAgJiYgY2FuUGF0aEJhdGNoKGVsLnN0eWxlKTtcbiAgICBpZiAoZm9yY2VTZXRUcmFuc2Zvcm0gfHwgaXNUcmFuc2Zvcm1DaGFuZ2VkKG0sIHByZXZFbC50cmFuc2Zvcm0pKSB7XG4gICAgICAgIGZsdXNoUGF0aERyYXduKGN0eCwgc2NvcGUpO1xuICAgICAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGN0eCwgZWwpO1xuICAgIH1cbiAgICBlbHNlIGlmICghY2FuQmF0Y2hQYXRoKSB7XG4gICAgICAgIGZsdXNoUGF0aERyYXduKGN0eCwgc2NvcGUpO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSBnZXRTdHlsZShlbCwgc2NvcGUuaW5Ib3Zlcik7XG4gICAgaWYgKGVsIGluc3RhbmNlb2YgUGF0aCkge1xuICAgICAgICBpZiAoc2NvcGUubGFzdERyYXdUeXBlICE9PSBEUkFXX1RZUEVfUEFUSCkge1xuICAgICAgICAgICAgZm9yY2VTZXRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgICBzY29wZS5sYXN0RHJhd1R5cGUgPSBEUkFXX1RZUEVfUEFUSDtcbiAgICAgICAgfVxuICAgICAgICBiaW5kUGF0aEFuZFRleHRDb21tb25TdHlsZShjdHgsIGVsLCBwcmV2RWwsIGZvcmNlU2V0U3R5bGUsIHNjb3BlKTtcbiAgICAgICAgaWYgKCFjYW5CYXRjaFBhdGggfHwgKCFzY29wZS5iYXRjaEZpbGwgJiYgIXNjb3BlLmJhdGNoU3Ryb2tlKSkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGJydXNoUGF0aChjdHgsIGVsLCBzdHlsZSwgY2FuQmF0Y2hQYXRoKTtcbiAgICAgICAgaWYgKGNhbkJhdGNoUGF0aCkge1xuICAgICAgICAgICAgc2NvcGUuYmF0Y2hGaWxsID0gc3R5bGUuZmlsbCB8fCAnJztcbiAgICAgICAgICAgIHNjb3BlLmJhdGNoU3Ryb2tlID0gc3R5bGUuc3Ryb2tlIHx8ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBUU3Bhbikge1xuICAgICAgICAgICAgaWYgKHNjb3BlLmxhc3REcmF3VHlwZSAhPT0gRFJBV19UWVBFX1RFWFQpIHtcbiAgICAgICAgICAgICAgICBmb3JjZVNldFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzY29wZS5sYXN0RHJhd1R5cGUgPSBEUkFXX1RZUEVfVEVYVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpbmRQYXRoQW5kVGV4dENvbW1vblN0eWxlKGN0eCwgZWwsIHByZXZFbCwgZm9yY2VTZXRTdHlsZSwgc2NvcGUpO1xuICAgICAgICAgICAgYnJ1c2hUZXh0KGN0eCwgZWwsIHN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbCBpbnN0YW5jZW9mIFpSSW1hZ2UpIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5sYXN0RHJhd1R5cGUgIT09IERSQVdfVFlQRV9JTUFHRSkge1xuICAgICAgICAgICAgICAgIGZvcmNlU2V0U3R5bGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNjb3BlLmxhc3REcmF3VHlwZSA9IERSQVdfVFlQRV9JTUFHRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpbmRJbWFnZVN0eWxlKGN0eCwgZWwsIHByZXZFbCwgZm9yY2VTZXRTdHlsZSwgc2NvcGUpO1xuICAgICAgICAgICAgYnJ1c2hJbWFnZShjdHgsIGVsLCBzdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWwuZ2V0VGVtcG9yYWxEaXNwbGF5YWJsZXMpIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5sYXN0RHJhd1R5cGUgIT09IERSQVdfVFlQRV9JTkNSRU1FTlRBTCkge1xuICAgICAgICAgICAgICAgIGZvcmNlU2V0U3R5bGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNjb3BlLmxhc3REcmF3VHlwZSA9IERSQVdfVFlQRV9JTkNSRU1FTlRBTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJydXNoSW5jcmVtZW50YWwoY3R4LCBlbCwgc2NvcGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjYW5CYXRjaFBhdGggJiYgaXNMYXN0KSB7XG4gICAgICAgIGZsdXNoUGF0aERyYXduKGN0eCwgc2NvcGUpO1xuICAgIH1cbiAgICBlbC5pbm5lckFmdGVyQnJ1c2goKTtcbiAgICBlbC5hZnRlckJydXNoICYmIGVsLmFmdGVyQnJ1c2goKTtcbiAgICBzY29wZS5wcmV2RWwgPSBlbDtcbiAgICBlbC5fX2RpcnR5ID0gMDtcbiAgICBlbC5fX2lzUmVuZGVyZWQgPSB0cnVlO1xufVxuZnVuY3Rpb24gYnJ1c2hJbmNyZW1lbnRhbChjdHgsIGVsLCBzY29wZSkge1xuICAgIHZhciBkaXNwbGF5YWJsZXMgPSBlbC5nZXREaXNwbGF5YWJsZXMoKTtcbiAgICB2YXIgdGVtcG9yYWxEaXNwbGF5YWJsZXMgPSBlbC5nZXRUZW1wb3JhbERpc3BsYXlhYmxlcygpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgdmFyIGlubmVyU2NvcGUgPSB7XG4gICAgICAgIHByZXZFbENsaXBQYXRoczogbnVsbCxcbiAgICAgICAgcHJldkVsOiBudWxsLFxuICAgICAgICBhbGxDbGlwcGVkOiBmYWxzZSxcbiAgICAgICAgdmlld1dpZHRoOiBzY29wZS52aWV3V2lkdGgsXG4gICAgICAgIHZpZXdIZWlnaHQ6IHNjb3BlLnZpZXdIZWlnaHQsXG4gICAgICAgIGluSG92ZXI6IHNjb3BlLmluSG92ZXJcbiAgICB9O1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgZm9yIChpID0gZWwuZ2V0Q3Vyc29yKCksIGxlbiA9IGRpc3BsYXlhYmxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZGlzcGxheWFibGUgPSBkaXNwbGF5YWJsZXNbaV07XG4gICAgICAgIGRpc3BsYXlhYmxlLmJlZm9yZUJydXNoICYmIGRpc3BsYXlhYmxlLmJlZm9yZUJydXNoKCk7XG4gICAgICAgIGRpc3BsYXlhYmxlLmlubmVyQmVmb3JlQnJ1c2goKTtcbiAgICAgICAgYnJ1c2goY3R4LCBkaXNwbGF5YWJsZSwgaW5uZXJTY29wZSwgaSA9PT0gbGVuIC0gMSk7XG4gICAgICAgIGRpc3BsYXlhYmxlLmlubmVyQWZ0ZXJCcnVzaCgpO1xuICAgICAgICBkaXNwbGF5YWJsZS5hZnRlckJydXNoICYmIGRpc3BsYXlhYmxlLmFmdGVyQnJ1c2goKTtcbiAgICAgICAgaW5uZXJTY29wZS5wcmV2RWwgPSBkaXNwbGF5YWJsZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaV8xID0gMCwgbGVuXzEgPSB0ZW1wb3JhbERpc3BsYXlhYmxlcy5sZW5ndGg7IGlfMSA8IGxlbl8xOyBpXzErKykge1xuICAgICAgICB2YXIgZGlzcGxheWFibGUgPSB0ZW1wb3JhbERpc3BsYXlhYmxlc1tpXzFdO1xuICAgICAgICBkaXNwbGF5YWJsZS5iZWZvcmVCcnVzaCAmJiBkaXNwbGF5YWJsZS5iZWZvcmVCcnVzaCgpO1xuICAgICAgICBkaXNwbGF5YWJsZS5pbm5lckJlZm9yZUJydXNoKCk7XG4gICAgICAgIGJydXNoKGN0eCwgZGlzcGxheWFibGUsIGlubmVyU2NvcGUsIGlfMSA9PT0gbGVuXzEgLSAxKTtcbiAgICAgICAgZGlzcGxheWFibGUuaW5uZXJBZnRlckJydXNoKCk7XG4gICAgICAgIGRpc3BsYXlhYmxlLmFmdGVyQnJ1c2ggJiYgZGlzcGxheWFibGUuYWZ0ZXJCcnVzaCgpO1xuICAgICAgICBpbm5lclNjb3BlLnByZXZFbCA9IGRpc3BsYXlhYmxlO1xuICAgIH1cbiAgICBlbC5jbGVhclRlbXBvcmFsRGlzcGxheWFibGVzKCk7XG4gICAgZWwubm90Q2xlYXIgPSB0cnVlO1xuICAgIGN0eC5yZXN0b3JlKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29571\n")},30536:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ Painter)\n});\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/config.js\nvar config = __webpack_require__(73098);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(15727);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/Eventful.js\nvar Eventful = __webpack_require__(57861);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/canvas/helper.js\nvar helper = __webpack_require__(53479);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/canvas/graphic.js\nvar graphic = __webpack_require__(29571);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/BoundingRect.js\nvar BoundingRect = __webpack_require__(29308);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/constants.js\nvar constants = __webpack_require__(56448);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/platform.js\nvar platform = __webpack_require__(59741);\n;// ./node_modules/zrender/lib/canvas/Layer.js\n\n\n\n\n\n\n\n\n\nfunction createDom(id, painter, dpr) {\n    var newDom = platform/* platformApi */.yh.createCanvas();\n    var width = painter.getWidth();\n    var height = painter.getHeight();\n    var newDomStyle = newDom.style;\n    if (newDomStyle) {\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = '0';\n        newDomStyle.top = '0';\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.setAttribute('data-zr-dom-id', id);\n    }\n    newDom.width = width * dpr;\n    newDom.height = height * dpr;\n    return newDom;\n}\n;\nvar Layer = (function (_super) {\n    (0,tslib_es6/* __extends */.C6)(Layer, _super);\n    function Layer(id, painter, dpr) {\n        var _this = _super.call(this) || this;\n        _this.motionBlur = false;\n        _this.lastFrameAlpha = 0.7;\n        _this.dpr = 1;\n        _this.virtual = false;\n        _this.config = {};\n        _this.incremental = false;\n        _this.zlevel = 0;\n        _this.maxRepaintRectCount = 5;\n        _this.__dirty = true;\n        _this.__firstTimePaint = true;\n        _this.__used = false;\n        _this.__drawIndex = 0;\n        _this.__startIndex = 0;\n        _this.__endIndex = 0;\n        _this.__prevStartIndex = null;\n        _this.__prevEndIndex = null;\n        var dom;\n        dpr = dpr || config/* devicePixelRatio */.Y5;\n        if (typeof id === 'string') {\n            dom = createDom(id, painter, dpr);\n        }\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        _this.id = id;\n        _this.dom = dom;\n        var domStyle = dom.style;\n        if (domStyle) {\n            util.disableUserSelect(dom);\n            dom.onselectstart = function () { return false; };\n            domStyle.padding = '0';\n            domStyle.margin = '0';\n            domStyle.borderWidth = '0';\n        }\n        _this.painter = painter;\n        _this.dpr = dpr;\n        return _this;\n    }\n    Layer.prototype.getElementCount = function () {\n        return this.__endIndex - this.__startIndex;\n    };\n    Layer.prototype.afterBrush = function () {\n        this.__prevStartIndex = this.__startIndex;\n        this.__prevEndIndex = this.__endIndex;\n    };\n    Layer.prototype.initContext = function () {\n        this.ctx = this.dom.getContext('2d');\n        this.ctx.dpr = this.dpr;\n    };\n    Layer.prototype.setUnpainted = function () {\n        this.__firstTimePaint = true;\n    };\n    Layer.prototype.createBackBuffer = function () {\n        var dpr = this.dpr;\n        this.domBack = createDom('back-' + this.id, this.painter, dpr);\n        this.ctxBack = this.domBack.getContext('2d');\n        if (dpr !== 1) {\n            this.ctxBack.scale(dpr, dpr);\n        }\n    };\n    Layer.prototype.createRepaintRects = function (displayList, prevList, viewWidth, viewHeight) {\n        if (this.__firstTimePaint) {\n            this.__firstTimePaint = false;\n            return null;\n        }\n        var mergedRepaintRects = [];\n        var maxRepaintRectCount = this.maxRepaintRectCount;\n        var full = false;\n        var pendingRect = new BoundingRect/* default */.A(0, 0, 0, 0);\n        function addRectToMergePool(rect) {\n            if (!rect.isFinite() || rect.isZero()) {\n                return;\n            }\n            if (mergedRepaintRects.length === 0) {\n                var boundingRect = new BoundingRect/* default */.A(0, 0, 0, 0);\n                boundingRect.copy(rect);\n                mergedRepaintRects.push(boundingRect);\n            }\n            else {\n                var isMerged = false;\n                var minDeltaArea = Infinity;\n                var bestRectToMergeIdx = 0;\n                for (var i = 0; i < mergedRepaintRects.length; ++i) {\n                    var mergedRect = mergedRepaintRects[i];\n                    if (mergedRect.intersect(rect)) {\n                        var pendingRect_1 = new BoundingRect/* default */.A(0, 0, 0, 0);\n                        pendingRect_1.copy(mergedRect);\n                        pendingRect_1.union(rect);\n                        mergedRepaintRects[i] = pendingRect_1;\n                        isMerged = true;\n                        break;\n                    }\n                    else if (full) {\n                        pendingRect.copy(rect);\n                        pendingRect.union(mergedRect);\n                        var aArea = rect.width * rect.height;\n                        var bArea = mergedRect.width * mergedRect.height;\n                        var pendingArea = pendingRect.width * pendingRect.height;\n                        var deltaArea = pendingArea - aArea - bArea;\n                        if (deltaArea < minDeltaArea) {\n                            minDeltaArea = deltaArea;\n                            bestRectToMergeIdx = i;\n                        }\n                    }\n                }\n                if (full) {\n                    mergedRepaintRects[bestRectToMergeIdx].union(rect);\n                    isMerged = true;\n                }\n                if (!isMerged) {\n                    var boundingRect = new BoundingRect/* default */.A(0, 0, 0, 0);\n                    boundingRect.copy(rect);\n                    mergedRepaintRects.push(boundingRect);\n                }\n                if (!full) {\n                    full = mergedRepaintRects.length >= maxRepaintRectCount;\n                }\n            }\n        }\n        for (var i = this.__startIndex; i < this.__endIndex; ++i) {\n            var el = displayList[i];\n            if (el) {\n                var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);\n                var prevRect = el.__isRendered && ((el.__dirty & constants/* REDRAW_BIT */.M) || !shouldPaint)\n                    ? el.getPrevPaintRect()\n                    : null;\n                if (prevRect) {\n                    addRectToMergePool(prevRect);\n                }\n                var curRect = shouldPaint && ((el.__dirty & constants/* REDRAW_BIT */.M) || !el.__isRendered)\n                    ? el.getPaintRect()\n                    : null;\n                if (curRect) {\n                    addRectToMergePool(curRect);\n                }\n            }\n        }\n        for (var i = this.__prevStartIndex; i < this.__prevEndIndex; ++i) {\n            var el = prevList[i];\n            var shouldPaint = el && el.shouldBePainted(viewWidth, viewHeight, true, true);\n            if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {\n                var prevRect = el.getPrevPaintRect();\n                if (prevRect) {\n                    addRectToMergePool(prevRect);\n                }\n            }\n        }\n        var hasIntersections;\n        do {\n            hasIntersections = false;\n            for (var i = 0; i < mergedRepaintRects.length;) {\n                if (mergedRepaintRects[i].isZero()) {\n                    mergedRepaintRects.splice(i, 1);\n                    continue;\n                }\n                for (var j = i + 1; j < mergedRepaintRects.length;) {\n                    if (mergedRepaintRects[i].intersect(mergedRepaintRects[j])) {\n                        hasIntersections = true;\n                        mergedRepaintRects[i].union(mergedRepaintRects[j]);\n                        mergedRepaintRects.splice(j, 1);\n                    }\n                    else {\n                        j++;\n                    }\n                }\n                i++;\n            }\n        } while (hasIntersections);\n        this._paintRects = mergedRepaintRects;\n        return mergedRepaintRects;\n    };\n    Layer.prototype.debugGetPaintRects = function () {\n        return (this._paintRects || []).slice();\n    };\n    Layer.prototype.resize = function (width, height) {\n        var dpr = this.dpr;\n        var dom = this.dom;\n        var domStyle = dom.style;\n        var domBack = this.domBack;\n        if (domStyle) {\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n        }\n        dom.width = width * dpr;\n        dom.height = height * dpr;\n        if (domBack) {\n            domBack.width = width * dpr;\n            domBack.height = height * dpr;\n            if (dpr !== 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        }\n    };\n    Layer.prototype.clear = function (clearAll, clearColor, repaintRects) {\n        var dom = this.dom;\n        var ctx = this.ctx;\n        var width = dom.width;\n        var height = dom.height;\n        clearColor = clearColor || this.clearColor;\n        var haveMotionBLur = this.motionBlur && !clearAll;\n        var lastFrameAlpha = this.lastFrameAlpha;\n        var dpr = this.dpr;\n        var self = this;\n        if (haveMotionBLur) {\n            if (!this.domBack) {\n                this.createBackBuffer();\n            }\n            this.ctxBack.globalCompositeOperation = 'copy';\n            this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n        }\n        var domBack = this.domBack;\n        function doClear(x, y, width, height) {\n            ctx.clearRect(x, y, width, height);\n            if (clearColor && clearColor !== 'transparent') {\n                var clearColorGradientOrPattern = void 0;\n                if (util.isGradientObject(clearColor)) {\n                    var shouldCache = clearColor.global || (clearColor.__width === width\n                        && clearColor.__height === height);\n                    clearColorGradientOrPattern = shouldCache\n                        && clearColor.__canvasGradient\n                        || (0,helper/* getCanvasGradient */.Ff)(ctx, clearColor, {\n                            x: 0,\n                            y: 0,\n                            width: width,\n                            height: height\n                        });\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                    clearColor.__width = width;\n                    clearColor.__height = height;\n                }\n                else if (util.isImagePatternObject(clearColor)) {\n                    clearColor.scaleX = clearColor.scaleX || dpr;\n                    clearColor.scaleY = clearColor.scaleY || dpr;\n                    clearColorGradientOrPattern = (0,graphic/* createCanvasPattern */.ZQ)(ctx, clearColor, {\n                        dirty: function () {\n                            self.setUnpainted();\n                            self.painter.refresh();\n                        }\n                    });\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(x, y, width, height);\n                ctx.restore();\n            }\n            if (haveMotionBLur) {\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, x, y, width, height);\n                ctx.restore();\n            }\n        }\n        ;\n        if (!repaintRects || haveMotionBLur) {\n            doClear(0, 0, width, height);\n        }\n        else if (repaintRects.length) {\n            util.each(repaintRects, function (rect) {\n                doClear(rect.x * dpr, rect.y * dpr, rect.width * dpr, rect.height * dpr);\n            });\n        }\n    };\n    return Layer;\n}(Eventful/* default */.A));\n/* harmony default export */ const canvas_Layer = (Layer);\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/animation/requestAnimationFrame.js\nvar requestAnimationFrame = __webpack_require__(45825);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/env.js\nvar env = __webpack_require__(38123);\n;// ./node_modules/zrender/lib/canvas/Painter.js\n\n\n\n\n\n\n\n\nvar HOVER_LAYER_ZLEVEL = 1e5;\nvar CANVAS_ZLEVEL = 314159;\nvar EL_AFTER_INCREMENTAL_INC = 0.01;\nvar INCREMENTAL_INC = 0.001;\nfunction isLayerValid(layer) {\n    if (!layer) {\n        return false;\n    }\n    if (layer.__builtin__) {\n        return true;\n    }\n    if (typeof (layer.resize) !== 'function'\n        || typeof (layer.refresh) !== 'function') {\n        return false;\n    }\n    return true;\n}\nfunction createRoot(width, height) {\n    var domRoot = document.createElement('div');\n    domRoot.style.cssText = [\n        'position:relative',\n        'width:' + width + 'px',\n        'height:' + height + 'px',\n        'padding:0',\n        'margin:0',\n        'border-width:0'\n    ].join(';') + ';';\n    return domRoot;\n}\nvar CanvasPainter = (function () {\n    function CanvasPainter(root, storage, opts, id) {\n        this.type = 'canvas';\n        this._zlevelList = [];\n        this._prevDisplayList = [];\n        this._layers = {};\n        this._layerConfig = {};\n        this._needsManuallyCompositing = false;\n        this.type = 'canvas';\n        var singleCanvas = !root.nodeName\n            || root.nodeName.toUpperCase() === 'CANVAS';\n        this._opts = opts = util.extend({}, opts || {});\n        this.dpr = opts.devicePixelRatio || config/* devicePixelRatio */.Y5;\n        this._singleCanvas = singleCanvas;\n        this.root = root;\n        var rootStyle = root.style;\n        if (rootStyle) {\n            util.disableUserSelect(root);\n            root.innerHTML = '';\n        }\n        this.storage = storage;\n        var zlevelList = this._zlevelList;\n        this._prevDisplayList = [];\n        var layers = this._layers;\n        if (!singleCanvas) {\n            this._width = (0,helper/* getSize */.YC)(root, 0, opts);\n            this._height = (0,helper/* getSize */.YC)(root, 1, opts);\n            var domRoot = this._domRoot = createRoot(this._width, this._height);\n            root.appendChild(domRoot);\n        }\n        else {\n            var rootCanvas = root;\n            var width = rootCanvas.width;\n            var height = rootCanvas.height;\n            if (opts.width != null) {\n                width = opts.width;\n            }\n            if (opts.height != null) {\n                height = opts.height;\n            }\n            this.dpr = opts.devicePixelRatio || 1;\n            rootCanvas.width = width * this.dpr;\n            rootCanvas.height = height * this.dpr;\n            this._width = width;\n            this._height = height;\n            var mainLayer = new canvas_Layer(rootCanvas, this, this.dpr);\n            mainLayer.__builtin__ = true;\n            mainLayer.initContext();\n            layers[CANVAS_ZLEVEL] = mainLayer;\n            mainLayer.zlevel = CANVAS_ZLEVEL;\n            zlevelList.push(CANVAS_ZLEVEL);\n            this._domRoot = root;\n        }\n    }\n    CanvasPainter.prototype.getType = function () {\n        return 'canvas';\n    };\n    CanvasPainter.prototype.isSingleCanvas = function () {\n        return this._singleCanvas;\n    };\n    CanvasPainter.prototype.getViewportRoot = function () {\n        return this._domRoot;\n    };\n    CanvasPainter.prototype.getViewportRootOffset = function () {\n        var viewportRoot = this.getViewportRoot();\n        if (viewportRoot) {\n            return {\n                offsetLeft: viewportRoot.offsetLeft || 0,\n                offsetTop: viewportRoot.offsetTop || 0\n            };\n        }\n    };\n    CanvasPainter.prototype.refresh = function (paintAll) {\n        var list = this.storage.getDisplayList(true);\n        var prevList = this._prevDisplayList;\n        var zlevelList = this._zlevelList;\n        this._redrawId = Math.random();\n        this._paintList(list, prevList, paintAll, this._redrawId);\n        for (var i = 0; i < zlevelList.length; i++) {\n            var z = zlevelList[i];\n            var layer = this._layers[z];\n            if (!layer.__builtin__ && layer.refresh) {\n                var clearColor = i === 0 ? this._backgroundColor : null;\n                layer.refresh(clearColor);\n            }\n        }\n        if (this._opts.useDirtyRect) {\n            this._prevDisplayList = list.slice();\n        }\n        return this;\n    };\n    CanvasPainter.prototype.refreshHover = function () {\n        this._paintHoverList(this.storage.getDisplayList(false));\n    };\n    CanvasPainter.prototype._paintHoverList = function (list) {\n        var len = list.length;\n        var hoverLayer = this._hoverlayer;\n        hoverLayer && hoverLayer.clear();\n        if (!len) {\n            return;\n        }\n        var scope = {\n            inHover: true,\n            viewWidth: this._width,\n            viewHeight: this._height\n        };\n        var ctx;\n        for (var i = 0; i < len; i++) {\n            var el = list[i];\n            if (el.__inHover) {\n                if (!hoverLayer) {\n                    hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);\n                }\n                if (!ctx) {\n                    ctx = hoverLayer.ctx;\n                    ctx.save();\n                }\n                (0,graphic/* brush */.V$)(ctx, el, scope, i === len - 1);\n            }\n        }\n        if (ctx) {\n            ctx.restore();\n        }\n    };\n    CanvasPainter.prototype.getHoverLayer = function () {\n        return this.getLayer(HOVER_LAYER_ZLEVEL);\n    };\n    CanvasPainter.prototype.paintOne = function (ctx, el) {\n        (0,graphic/* brushSingle */.Xi)(ctx, el);\n    };\n    CanvasPainter.prototype._paintList = function (list, prevList, paintAll, redrawId) {\n        if (this._redrawId !== redrawId) {\n            return;\n        }\n        paintAll = paintAll || false;\n        this._updateLayerStatus(list);\n        var _a = this._doPaintList(list, prevList, paintAll), finished = _a.finished, needsRefreshHover = _a.needsRefreshHover;\n        if (this._needsManuallyCompositing) {\n            this._compositeManually();\n        }\n        if (needsRefreshHover) {\n            this._paintHoverList(list);\n        }\n        if (!finished) {\n            var self_1 = this;\n            (0,requestAnimationFrame/* default */.A)(function () {\n                self_1._paintList(list, prevList, paintAll, redrawId);\n            });\n        }\n        else {\n            this.eachLayer(function (layer) {\n                layer.afterBrush && layer.afterBrush();\n            });\n        }\n    };\n    CanvasPainter.prototype._compositeManually = function () {\n        var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;\n        var width = this._domRoot.width;\n        var height = this._domRoot.height;\n        ctx.clearRect(0, 0, width, height);\n        this.eachBuiltinLayer(function (layer) {\n            if (layer.virtual) {\n                ctx.drawImage(layer.dom, 0, 0, width, height);\n            }\n        });\n    };\n    CanvasPainter.prototype._doPaintList = function (list, prevList, paintAll) {\n        var _this = this;\n        var layerList = [];\n        var useDirtyRect = this._opts.useDirtyRect;\n        for (var zi = 0; zi < this._zlevelList.length; zi++) {\n            var zlevel = this._zlevelList[zi];\n            var layer = this._layers[zlevel];\n            if (layer.__builtin__\n                && layer !== this._hoverlayer\n                && (layer.__dirty || paintAll)) {\n                layerList.push(layer);\n            }\n        }\n        var finished = true;\n        var needsRefreshHover = false;\n        var _loop_1 = function (k) {\n            var layer = layerList[k];\n            var ctx = layer.ctx;\n            var repaintRects = useDirtyRect\n                && layer.createRepaintRects(list, prevList, this_1._width, this_1._height);\n            var start = paintAll ? layer.__startIndex : layer.__drawIndex;\n            var useTimer = !paintAll && layer.incremental && Date.now;\n            var startTime = useTimer && Date.now();\n            var clearColor = layer.zlevel === this_1._zlevelList[0]\n                ? this_1._backgroundColor : null;\n            if (layer.__startIndex === layer.__endIndex) {\n                layer.clear(false, clearColor, repaintRects);\n            }\n            else if (start === layer.__startIndex) {\n                var firstEl = list[start];\n                if (!firstEl.incremental || !firstEl.notClear || paintAll) {\n                    layer.clear(false, clearColor, repaintRects);\n                }\n            }\n            if (start === -1) {\n                console.error('For some unknown reason. drawIndex is -1');\n                start = layer.__startIndex;\n            }\n            var i;\n            var repaint = function (repaintRect) {\n                var scope = {\n                    inHover: false,\n                    allClipped: false,\n                    prevEl: null,\n                    viewWidth: _this._width,\n                    viewHeight: _this._height\n                };\n                for (i = start; i < layer.__endIndex; i++) {\n                    var el = list[i];\n                    if (el.__inHover) {\n                        needsRefreshHover = true;\n                    }\n                    _this._doPaintEl(el, layer, useDirtyRect, repaintRect, scope, i === layer.__endIndex - 1);\n                    if (useTimer) {\n                        var dTime = Date.now() - startTime;\n                        if (dTime > 15) {\n                            break;\n                        }\n                    }\n                }\n                if (scope.prevElClipPaths) {\n                    ctx.restore();\n                }\n            };\n            if (repaintRects) {\n                if (repaintRects.length === 0) {\n                    i = layer.__endIndex;\n                }\n                else {\n                    var dpr = this_1.dpr;\n                    for (var r = 0; r < repaintRects.length; ++r) {\n                        var rect = repaintRects[r];\n                        ctx.save();\n                        ctx.beginPath();\n                        ctx.rect(rect.x * dpr, rect.y * dpr, rect.width * dpr, rect.height * dpr);\n                        ctx.clip();\n                        repaint(rect);\n                        ctx.restore();\n                    }\n                }\n            }\n            else {\n                ctx.save();\n                repaint();\n                ctx.restore();\n            }\n            layer.__drawIndex = i;\n            if (layer.__drawIndex < layer.__endIndex) {\n                finished = false;\n            }\n        };\n        var this_1 = this;\n        for (var k = 0; k < layerList.length; k++) {\n            _loop_1(k);\n        }\n        if (env/* default */.A.wxa) {\n            util.each(this._layers, function (layer) {\n                if (layer && layer.ctx && layer.ctx.draw) {\n                    layer.ctx.draw();\n                }\n            });\n        }\n        return {\n            finished: finished,\n            needsRefreshHover: needsRefreshHover\n        };\n    };\n    CanvasPainter.prototype._doPaintEl = function (el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {\n        var ctx = currentLayer.ctx;\n        if (useDirtyRect) {\n            var paintRect = el.getPaintRect();\n            if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {\n                (0,graphic/* brush */.V$)(ctx, el, scope, isLast);\n                el.setPrevPaintRect(paintRect);\n            }\n        }\n        else {\n            (0,graphic/* brush */.V$)(ctx, el, scope, isLast);\n        }\n    };\n    CanvasPainter.prototype.getLayer = function (zlevel, virtual) {\n        if (this._singleCanvas && !this._needsManuallyCompositing) {\n            zlevel = CANVAS_ZLEVEL;\n        }\n        var layer = this._layers[zlevel];\n        if (!layer) {\n            layer = new canvas_Layer('zr_' + zlevel, this, this.dpr);\n            layer.zlevel = zlevel;\n            layer.__builtin__ = true;\n            if (this._layerConfig[zlevel]) {\n                util.merge(layer, this._layerConfig[zlevel], true);\n            }\n            else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {\n                util.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);\n            }\n            if (virtual) {\n                layer.virtual = virtual;\n            }\n            this.insertLayer(zlevel, layer);\n            layer.initContext();\n        }\n        return layer;\n    };\n    CanvasPainter.prototype.insertLayer = function (zlevel, layer) {\n        var layersMap = this._layers;\n        var zlevelList = this._zlevelList;\n        var len = zlevelList.length;\n        var domRoot = this._domRoot;\n        var prevLayer = null;\n        var i = -1;\n        if (layersMap[zlevel]) {\n            if (false) {}\n            return;\n        }\n        if (!isLayerValid(layer)) {\n            if (false) {}\n            return;\n        }\n        if (len > 0 && zlevel > zlevelList[0]) {\n            for (i = 0; i < len - 1; i++) {\n                if (zlevelList[i] < zlevel\n                    && zlevelList[i + 1] > zlevel) {\n                    break;\n                }\n            }\n            prevLayer = layersMap[zlevelList[i]];\n        }\n        zlevelList.splice(i + 1, 0, zlevel);\n        layersMap[zlevel] = layer;\n        if (!layer.virtual) {\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n        }\n        layer.painter || (layer.painter = this);\n    };\n    CanvasPainter.prototype.eachLayer = function (cb, context) {\n        var zlevelList = this._zlevelList;\n        for (var i = 0; i < zlevelList.length; i++) {\n            var z = zlevelList[i];\n            cb.call(context, this._layers[z], z);\n        }\n    };\n    CanvasPainter.prototype.eachBuiltinLayer = function (cb, context) {\n        var zlevelList = this._zlevelList;\n        for (var i = 0; i < zlevelList.length; i++) {\n            var z = zlevelList[i];\n            var layer = this._layers[z];\n            if (layer.__builtin__) {\n                cb.call(context, layer, z);\n            }\n        }\n    };\n    CanvasPainter.prototype.eachOtherLayer = function (cb, context) {\n        var zlevelList = this._zlevelList;\n        for (var i = 0; i < zlevelList.length; i++) {\n            var z = zlevelList[i];\n            var layer = this._layers[z];\n            if (!layer.__builtin__) {\n                cb.call(context, layer, z);\n            }\n        }\n    };\n    CanvasPainter.prototype.getLayers = function () {\n        return this._layers;\n    };\n    CanvasPainter.prototype._updateLayerStatus = function (list) {\n        this.eachBuiltinLayer(function (layer, z) {\n            layer.__dirty = layer.__used = false;\n        });\n        function updatePrevLayer(idx) {\n            if (prevLayer) {\n                if (prevLayer.__endIndex !== idx) {\n                    prevLayer.__dirty = true;\n                }\n                prevLayer.__endIndex = idx;\n            }\n        }\n        if (this._singleCanvas) {\n            for (var i_1 = 1; i_1 < list.length; i_1++) {\n                var el = list[i_1];\n                if (el.zlevel !== list[i_1 - 1].zlevel || el.incremental) {\n                    this._needsManuallyCompositing = true;\n                    break;\n                }\n            }\n        }\n        var prevLayer = null;\n        var incrementalLayerCount = 0;\n        var prevZlevel;\n        var i;\n        for (i = 0; i < list.length; i++) {\n            var el = list[i];\n            var zlevel = el.zlevel;\n            var layer = void 0;\n            if (prevZlevel !== zlevel) {\n                prevZlevel = zlevel;\n                incrementalLayerCount = 0;\n            }\n            if (el.incremental) {\n                layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);\n                layer.incremental = true;\n                incrementalLayerCount = 1;\n            }\n            else {\n                layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);\n            }\n            if (!layer.__builtin__) {\n                util.logError('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);\n            }\n            if (layer !== prevLayer) {\n                layer.__used = true;\n                if (layer.__startIndex !== i) {\n                    layer.__dirty = true;\n                }\n                layer.__startIndex = i;\n                if (!layer.incremental) {\n                    layer.__drawIndex = i;\n                }\n                else {\n                    layer.__drawIndex = -1;\n                }\n                updatePrevLayer(i);\n                prevLayer = layer;\n            }\n            if ((el.__dirty & constants/* REDRAW_BIT */.M) && !el.__inHover) {\n                layer.__dirty = true;\n                if (layer.incremental && layer.__drawIndex < 0) {\n                    layer.__drawIndex = i;\n                }\n            }\n        }\n        updatePrevLayer(i);\n        this.eachBuiltinLayer(function (layer, z) {\n            if (!layer.__used && layer.getElementCount() > 0) {\n                layer.__dirty = true;\n                layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;\n            }\n            if (layer.__dirty && layer.__drawIndex < 0) {\n                layer.__drawIndex = layer.__startIndex;\n            }\n        });\n    };\n    CanvasPainter.prototype.clear = function () {\n        this.eachBuiltinLayer(this._clearLayer);\n        return this;\n    };\n    CanvasPainter.prototype._clearLayer = function (layer) {\n        layer.clear();\n    };\n    CanvasPainter.prototype.setBackgroundColor = function (backgroundColor) {\n        this._backgroundColor = backgroundColor;\n        util.each(this._layers, function (layer) {\n            layer.setUnpainted();\n        });\n    };\n    CanvasPainter.prototype.configLayer = function (zlevel, config) {\n        if (config) {\n            var layerConfig = this._layerConfig;\n            if (!layerConfig[zlevel]) {\n                layerConfig[zlevel] = config;\n            }\n            else {\n                util.merge(layerConfig[zlevel], config, true);\n            }\n            for (var i = 0; i < this._zlevelList.length; i++) {\n                var _zlevel = this._zlevelList[i];\n                if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {\n                    var layer = this._layers[_zlevel];\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        }\n    };\n    CanvasPainter.prototype.delLayer = function (zlevel) {\n        var layers = this._layers;\n        var zlevelList = this._zlevelList;\n        var layer = layers[zlevel];\n        if (!layer) {\n            return;\n        }\n        layer.dom.parentNode.removeChild(layer.dom);\n        delete layers[zlevel];\n        zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n    };\n    CanvasPainter.prototype.resize = function (width, height) {\n        if (!this._domRoot.style) {\n            if (width == null || height == null) {\n                return;\n            }\n            this._width = width;\n            this._height = height;\n            this.getLayer(CANVAS_ZLEVEL).resize(width, height);\n        }\n        else {\n            var domRoot = this._domRoot;\n            domRoot.style.display = 'none';\n            var opts = this._opts;\n            var root = this.root;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n            width = (0,helper/* getSize */.YC)(root, 0, opts);\n            height = (0,helper/* getSize */.YC)(root, 1, opts);\n            domRoot.style.display = '';\n            if (this._width !== width || height !== this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                this.refresh(true);\n            }\n            this._width = width;\n            this._height = height;\n        }\n        return this;\n    };\n    CanvasPainter.prototype.clearLayer = function (zlevel) {\n        var layer = this._layers[zlevel];\n        if (layer) {\n            layer.clear();\n        }\n    };\n    CanvasPainter.prototype.dispose = function () {\n        this.root.innerHTML = '';\n        this.root =\n            this.storage =\n                this._domRoot =\n                    this._layers = null;\n    };\n    CanvasPainter.prototype.getRenderedCanvas = function (opts) {\n        opts = opts || {};\n        if (this._singleCanvas && !this._compositeManually) {\n            return this._layers[CANVAS_ZLEVEL].dom;\n        }\n        var imageLayer = new canvas_Layer('image', this, opts.pixelRatio || this.dpr);\n        imageLayer.initContext();\n        imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);\n        var ctx = imageLayer.ctx;\n        if (opts.pixelRatio <= this.dpr) {\n            this.refresh();\n            var width_1 = imageLayer.dom.width;\n            var height_1 = imageLayer.dom.height;\n            this.eachLayer(function (layer) {\n                if (layer.__builtin__) {\n                    ctx.drawImage(layer.dom, 0, 0, width_1, height_1);\n                }\n                else if (layer.renderToCanvas) {\n                    ctx.save();\n                    layer.renderToCanvas(ctx);\n                    ctx.restore();\n                }\n            });\n        }\n        else {\n            var scope = {\n                inHover: false,\n                viewWidth: this._width,\n                viewHeight: this._height\n            };\n            var displayList = this.storage.getDisplayList(true);\n            for (var i = 0, len = displayList.length; i < len; i++) {\n                var el = displayList[i];\n                (0,graphic/* brush */.V$)(ctx, el, scope, i === len - 1);\n            }\n        }\n        return imageLayer.dom;\n    };\n    CanvasPainter.prototype.getWidth = function () {\n        return this._width;\n    };\n    CanvasPainter.prototype.getHeight = function () {\n        return this._height;\n    };\n    return CanvasPainter;\n}());\n/* harmony default export */ const Painter = (CanvasPainter);\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA1MzYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jYW52YXMvTGF5ZXIuanM/MzU4YSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY2FudmFzL1BhaW50ZXIuanM/YmViOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGRldmljZVBpeGVsUmF0aW8gfSBmcm9tICcuLi9jb25maWcuanMnO1xuaW1wb3J0IEV2ZW50ZnVsIGZyb20gJy4uL2NvcmUvRXZlbnRmdWwuanMnO1xuaW1wb3J0IHsgZ2V0Q2FudmFzR3JhZGllbnQgfSBmcm9tICcuL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDYW52YXNQYXR0ZXJuIH0gZnJvbSAnLi9ncmFwaGljLmpzJztcbmltcG9ydCBCb3VuZGluZ1JlY3QgZnJvbSAnLi4vY29yZS9Cb3VuZGluZ1JlY3QuanMnO1xuaW1wb3J0IHsgUkVEUkFXX0JJVCB9IGZyb20gJy4uL2dyYXBoaWMvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHBsYXRmb3JtQXBpIH0gZnJvbSAnLi4vY29yZS9wbGF0Zm9ybS5qcyc7XG5mdW5jdGlvbiBjcmVhdGVEb20oaWQsIHBhaW50ZXIsIGRwcikge1xuICAgIHZhciBuZXdEb20gPSBwbGF0Zm9ybUFwaS5jcmVhdGVDYW52YXMoKTtcbiAgICB2YXIgd2lkdGggPSBwYWludGVyLmdldFdpZHRoKCk7XG4gICAgdmFyIGhlaWdodCA9IHBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gICAgdmFyIG5ld0RvbVN0eWxlID0gbmV3RG9tLnN0eWxlO1xuICAgIGlmIChuZXdEb21TdHlsZSkge1xuICAgICAgICBuZXdEb21TdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIG5ld0RvbVN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIG5ld0RvbVN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgbmV3RG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIG5ld0RvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIG5ld0RvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtenItZG9tLWlkJywgaWQpO1xuICAgIH1cbiAgICBuZXdEb20ud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICBuZXdEb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuICAgIHJldHVybiBuZXdEb207XG59XG47XG52YXIgTGF5ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMYXllciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYXllcihpZCwgcGFpbnRlciwgZHByKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubGFzdEZyYW1lQWxwaGEgPSAwLjc7XG4gICAgICAgIF90aGlzLmRwciA9IDE7XG4gICAgICAgIF90aGlzLnZpcnR1YWwgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuY29uZmlnID0ge307XG4gICAgICAgIF90aGlzLmluY3JlbWVudGFsID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnpsZXZlbCA9IDA7XG4gICAgICAgIF90aGlzLm1heFJlcGFpbnRSZWN0Q291bnQgPSA1O1xuICAgICAgICBfdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuX19maXJzdFRpbWVQYWludCA9IHRydWU7XG4gICAgICAgIF90aGlzLl9fdXNlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fX2RyYXdJbmRleCA9IDA7XG4gICAgICAgIF90aGlzLl9fc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIF90aGlzLl9fZW5kSW5kZXggPSAwO1xuICAgICAgICBfdGhpcy5fX3ByZXZTdGFydEluZGV4ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX19wcmV2RW5kSW5kZXggPSBudWxsO1xuICAgICAgICB2YXIgZG9tO1xuICAgICAgICBkcHIgPSBkcHIgfHwgZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRvbSA9IGNyZWF0ZURvbShpZCwgcGFpbnRlciwgZHByKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGlkKSkge1xuICAgICAgICAgICAgZG9tID0gaWQ7XG4gICAgICAgICAgICBpZCA9IGRvbS5pZDtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5pZCA9IGlkO1xuICAgICAgICBfdGhpcy5kb20gPSBkb207XG4gICAgICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICAgICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICAgICAgICB1dGlsLmRpc2FibGVVc2VyU2VsZWN0KGRvbSk7XG4gICAgICAgICAgICBkb20ub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICAgICAgICAgZG9tU3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgICAgIGRvbVN0eWxlLm1hcmdpbiA9ICcwJztcbiAgICAgICAgICAgIGRvbVN0eWxlLmJvcmRlcldpZHRoID0gJzAnO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuICAgICAgICBfdGhpcy5kcHIgPSBkcHI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGF5ZXIucHJvdG90eXBlLmdldEVsZW1lbnRDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19lbmRJbmRleCAtIHRoaXMuX19zdGFydEluZGV4O1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmFmdGVyQnJ1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX19wcmV2U3RhcnRJbmRleCA9IHRoaXMuX19zdGFydEluZGV4O1xuICAgICAgICB0aGlzLl9fcHJldkVuZEluZGV4ID0gdGhpcy5fX2VuZEluZGV4O1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmluaXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmN0eCA9IHRoaXMuZG9tLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuY3R4LmRwciA9IHRoaXMuZHByO1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLnNldFVucGFpbnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fX2ZpcnN0VGltZVBhaW50ID0gdHJ1ZTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5jcmVhdGVCYWNrQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZHByID0gdGhpcy5kcHI7XG4gICAgICAgIHRoaXMuZG9tQmFjayA9IGNyZWF0ZURvbSgnYmFjay0nICsgdGhpcy5pZCwgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgICAgICB0aGlzLmN0eEJhY2sgPSB0aGlzLmRvbUJhY2suZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKGRwciAhPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmNyZWF0ZVJlcGFpbnRSZWN0cyA9IGZ1bmN0aW9uIChkaXNwbGF5TGlzdCwgcHJldkxpc3QsIHZpZXdXaWR0aCwgdmlld0hlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5fX2ZpcnN0VGltZVBhaW50KSB7XG4gICAgICAgICAgICB0aGlzLl9fZmlyc3RUaW1lUGFpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXJnZWRSZXBhaW50UmVjdHMgPSBbXTtcbiAgICAgICAgdmFyIG1heFJlcGFpbnRSZWN0Q291bnQgPSB0aGlzLm1heFJlcGFpbnRSZWN0Q291bnQ7XG4gICAgICAgIHZhciBmdWxsID0gZmFsc2U7XG4gICAgICAgIHZhciBwZW5kaW5nUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgICAgIGZ1bmN0aW9uIGFkZFJlY3RUb01lcmdlUG9vbChyZWN0KSB7XG4gICAgICAgICAgICBpZiAoIXJlY3QuaXNGaW5pdGUoKSB8fCByZWN0LmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lcmdlZFJlcGFpbnRSZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3QuY29weShyZWN0KTtcbiAgICAgICAgICAgICAgICBtZXJnZWRSZXBhaW50UmVjdHMucHVzaChib3VuZGluZ1JlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzTWVyZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIG1pbkRlbHRhQXJlYSA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIHZhciBiZXN0UmVjdFRvTWVyZ2VJZHggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVyZ2VkUmVwYWludFJlY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXJnZWRSZWN0ID0gbWVyZ2VkUmVwYWludFJlY3RzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVyZ2VkUmVjdC5pbnRlcnNlY3QocmVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZW5kaW5nUmVjdF8xID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdSZWN0XzEuY29weShtZXJnZWRSZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdSZWN0XzEudW5pb24ocmVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRSZXBhaW50UmVjdHNbaV0gPSBwZW5kaW5nUmVjdF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNNZXJnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1JlY3QuY29weShyZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdSZWN0LnVuaW9uKG1lcmdlZFJlY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFBcmVhID0gcmVjdC53aWR0aCAqIHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJBcmVhID0gbWVyZ2VkUmVjdC53aWR0aCAqIG1lcmdlZFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlbmRpbmdBcmVhID0gcGVuZGluZ1JlY3Qud2lkdGggKiBwZW5kaW5nUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFBcmVhID0gcGVuZGluZ0FyZWEgLSBhQXJlYSAtIGJBcmVhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhQXJlYSA8IG1pbkRlbHRhQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRlbHRhQXJlYSA9IGRlbHRhQXJlYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0UmVjdFRvTWVyZ2VJZHggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmdWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFJlcGFpbnRSZWN0c1tiZXN0UmVjdFRvTWVyZ2VJZHhdLnVuaW9uKHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICBpc01lcmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNNZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nUmVjdC5jb3B5KHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRSZXBhaW50UmVjdHMucHVzaChib3VuZGluZ1JlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWZ1bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVsbCA9IG1lcmdlZFJlcGFpbnRSZWN0cy5sZW5ndGggPj0gbWF4UmVwYWludFJlY3RDb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX19zdGFydEluZGV4OyBpIDwgdGhpcy5fX2VuZEluZGV4OyArK2kpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGRpc3BsYXlMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNob3VsZFBhaW50ID0gZWwuc2hvdWxkQmVQYWludGVkKHZpZXdXaWR0aCwgdmlld0hlaWdodCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZSZWN0ID0gZWwuX19pc1JlbmRlcmVkICYmICgoZWwuX19kaXJ0eSAmIFJFRFJBV19CSVQpIHx8ICFzaG91bGRQYWludClcbiAgICAgICAgICAgICAgICAgICAgPyBlbC5nZXRQcmV2UGFpbnRSZWN0KClcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRSZWN0VG9NZXJnZVBvb2wocHJldlJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3VyUmVjdCA9IHNob3VsZFBhaW50ICYmICgoZWwuX19kaXJ0eSAmIFJFRFJBV19CSVQpIHx8ICFlbC5fX2lzUmVuZGVyZWQpXG4gICAgICAgICAgICAgICAgICAgID8gZWwuZ2V0UGFpbnRSZWN0KClcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChjdXJSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFJlY3RUb01lcmdlUG9vbChjdXJSZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX19wcmV2U3RhcnRJbmRleDsgaSA8IHRoaXMuX19wcmV2RW5kSW5kZXg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGVsID0gcHJldkxpc3RbaV07XG4gICAgICAgICAgICB2YXIgc2hvdWxkUGFpbnQgPSBlbCAmJiBlbC5zaG91bGRCZVBhaW50ZWQodmlld1dpZHRoLCB2aWV3SGVpZ2h0LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChlbCAmJiAoIXNob3VsZFBhaW50IHx8ICFlbC5fX3pyKSAmJiBlbC5fX2lzUmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlJlY3QgPSBlbC5nZXRQcmV2UGFpbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFJlY3RUb01lcmdlUG9vbChwcmV2UmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNJbnRlcnNlY3Rpb25zO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBoYXNJbnRlcnNlY3Rpb25zID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lcmdlZFJlcGFpbnRSZWN0cy5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlZFJlcGFpbnRSZWN0c1tpXS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRSZXBhaW50UmVjdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbWVyZ2VkUmVwYWludFJlY3RzLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lcmdlZFJlcGFpbnRSZWN0c1tpXS5pbnRlcnNlY3QobWVyZ2VkUmVwYWludFJlY3RzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzSW50ZXJzZWN0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRSZXBhaW50UmVjdHNbaV0udW5pb24obWVyZ2VkUmVwYWludFJlY3RzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZFJlcGFpbnRSZWN0cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChoYXNJbnRlcnNlY3Rpb25zKTtcbiAgICAgICAgdGhpcy5fcGFpbnRSZWN0cyA9IG1lcmdlZFJlcGFpbnRSZWN0cztcbiAgICAgICAgcmV0dXJuIG1lcmdlZFJlcGFpbnRSZWN0cztcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5kZWJ1Z0dldFBhaW50UmVjdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fcGFpbnRSZWN0cyB8fCBbXSkuc2xpY2UoKTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgZHByID0gdGhpcy5kcHI7XG4gICAgICAgIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgICAgICAgdmFyIGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuICAgICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICAgICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICAgICAgICBkb21TdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIGRvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgZG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgIGRvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG4gICAgICAgIGlmIChkb21CYWNrKSB7XG4gICAgICAgICAgICBkb21CYWNrLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgICAgICBkb21CYWNrLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcbiAgICAgICAgICAgIGlmIChkcHIgIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXllci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoY2xlYXJBbGwsIGNsZWFyQ29sb3IsIHJlcGFpbnRSZWN0cykge1xuICAgICAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgdmFyIHdpZHRoID0gZG9tLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZG9tLmhlaWdodDtcbiAgICAgICAgY2xlYXJDb2xvciA9IGNsZWFyQ29sb3IgfHwgdGhpcy5jbGVhckNvbG9yO1xuICAgICAgICB2YXIgaGF2ZU1vdGlvbkJMdXIgPSB0aGlzLm1vdGlvbkJsdXIgJiYgIWNsZWFyQWxsO1xuICAgICAgICB2YXIgbGFzdEZyYW1lQWxwaGEgPSB0aGlzLmxhc3RGcmFtZUFscGhhO1xuICAgICAgICB2YXIgZHByID0gdGhpcy5kcHI7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGhhdmVNb3Rpb25CTHVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZG9tQmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlQmFja0J1ZmZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdHhCYWNrLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICAgICAgICAgIHRoaXMuY3R4QmFjay5kcmF3SW1hZ2UoZG9tLCAwLCAwLCB3aWR0aCAvIGRwciwgaGVpZ2h0IC8gZHByKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICAgICAgZnVuY3Rpb24gZG9DbGVhcih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgaWYgKGNsZWFyQ29sb3IgJiYgY2xlYXJDb2xvciAhPT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICAgICAgICAgIHZhciBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNHcmFkaWVudE9iamVjdChjbGVhckNvbG9yKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hvdWxkQ2FjaGUgPSBjbGVhckNvbG9yLmdsb2JhbCB8fCAoY2xlYXJDb2xvci5fX3dpZHRoID09PSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2xlYXJDb2xvci5fX2hlaWdodCA9PT0gaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gc2hvdWxkQ2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgZ2V0Q2FudmFzR3JhZGllbnQoY3R4LCBjbGVhckNvbG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvci5fX3dpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3IuX19oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNJbWFnZVBhdHRlcm5PYmplY3QoY2xlYXJDb2xvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvci5zY2FsZVggPSBjbGVhckNvbG9yLnNjYWxlWCB8fCBkcHI7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3Iuc2NhbGVZID0gY2xlYXJDb2xvci5zY2FsZVkgfHwgZHByO1xuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBjcmVhdGVDYW52YXNQYXR0ZXJuKGN0eCwgY2xlYXJDb2xvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNldFVucGFpbnRlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGFpbnRlci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gfHwgY2xlYXJDb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gbGFzdEZyYW1lQWxwaGE7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShkb21CYWNrLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKCFyZXBhaW50UmVjdHMgfHwgaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgIGRvQ2xlYXIoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVwYWludFJlY3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgdXRpbC5lYWNoKHJlcGFpbnRSZWN0cywgZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgICAgICAgICBkb0NsZWFyKHJlY3QueCAqIGRwciwgcmVjdC55ICogZHByLCByZWN0LndpZHRoICogZHByLCByZWN0LmhlaWdodCAqIGRwcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIExheWVyO1xufShFdmVudGZ1bCkpO1xuZXhwb3J0IGRlZmF1bHQgTGF5ZXI7XG4iLCJpbXBvcnQgeyBkZXZpY2VQaXhlbFJhdGlvIH0gZnJvbSAnLi4vY29uZmlnLmpzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vY29yZS91dGlsLmpzJztcbmltcG9ydCBMYXllciBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnJvbSAnLi4vYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyc7XG5pbXBvcnQgZW52IGZyb20gJy4uL2NvcmUvZW52LmpzJztcbmltcG9ydCB7IGJydXNoLCBicnVzaFNpbmdsZSB9IGZyb20gJy4vZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBSRURSQVdfQklUIH0gZnJvbSAnLi4vZ3JhcGhpYy9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZ2V0U2l6ZSB9IGZyb20gJy4vaGVscGVyLmpzJztcbnZhciBIT1ZFUl9MQVlFUl9aTEVWRUwgPSAxZTU7XG52YXIgQ0FOVkFTX1pMRVZFTCA9IDMxNDE1OTtcbnZhciBFTF9BRlRFUl9JTkNSRU1FTlRBTF9JTkMgPSAwLjAxO1xudmFyIElOQ1JFTUVOVEFMX0lOQyA9IDAuMDAxO1xuZnVuY3Rpb24gaXNMYXllclZhbGlkKGxheWVyKSB7XG4gICAgaWYgKCFsYXllcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobGF5ZXIucmVzaXplKSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICB8fCB0eXBlb2YgKGxheWVyLnJlZnJlc2gpICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjcmVhdGVSb290KHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZG9tUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbVJvb3Quc3R5bGUuY3NzVGV4dCA9IFtcbiAgICAgICAgJ3Bvc2l0aW9uOnJlbGF0aXZlJyxcbiAgICAgICAgJ3dpZHRoOicgKyB3aWR0aCArICdweCcsXG4gICAgICAgICdoZWlnaHQ6JyArIGhlaWdodCArICdweCcsXG4gICAgICAgICdwYWRkaW5nOjAnLFxuICAgICAgICAnbWFyZ2luOjAnLFxuICAgICAgICAnYm9yZGVyLXdpZHRoOjAnXG4gICAgXS5qb2luKCc7JykgKyAnOyc7XG4gICAgcmV0dXJuIGRvbVJvb3Q7XG59XG52YXIgQ2FudmFzUGFpbnRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FudmFzUGFpbnRlcihyb290LCBzdG9yYWdlLCBvcHRzLCBpZCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnY2FudmFzJztcbiAgICAgICAgdGhpcy5femxldmVsTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9wcmV2RGlzcGxheUxpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fbGF5ZXJzID0ge307XG4gICAgICAgIHRoaXMuX2xheWVyQ29uZmlnID0ge307XG4gICAgICAgIHRoaXMuX25lZWRzTWFudWFsbHlDb21wb3NpdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY2FudmFzJztcbiAgICAgICAgdmFyIHNpbmdsZUNhbnZhcyA9ICFyb290Lm5vZGVOYW1lXG4gICAgICAgICAgICB8fCByb290Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnO1xuICAgICAgICB0aGlzLl9vcHRzID0gb3B0cyA9IHV0aWwuZXh0ZW5kKHt9LCBvcHRzIHx8IHt9KTtcbiAgICAgICAgdGhpcy5kcHIgPSBvcHRzLmRldmljZVBpeGVsUmF0aW8gfHwgZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5fc2luZ2xlQ2FudmFzID0gc2luZ2xlQ2FudmFzO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB2YXIgcm9vdFN0eWxlID0gcm9vdC5zdHlsZTtcbiAgICAgICAgaWYgKHJvb3RTdHlsZSkge1xuICAgICAgICAgICAgdXRpbC5kaXNhYmxlVXNlclNlbGVjdChyb290KTtcbiAgICAgICAgICAgIHJvb3QuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICB0aGlzLl9wcmV2RGlzcGxheUxpc3QgPSBbXTtcbiAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgaWYgKCFzaW5nbGVDYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gZ2V0U2l6ZShyb290LCAwLCBvcHRzKTtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGdldFNpemUocm9vdCwgMSwgb3B0cyk7XG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3QgPSBjcmVhdGVSb290KHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChkb21Sb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByb290Q2FudmFzID0gcm9vdDtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJvb3RDYW52YXMud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcm9vdENhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAob3B0cy53aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBvcHRzLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBvcHRzLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHByID0gb3B0cy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgICAgICByb290Q2FudmFzLndpZHRoID0gd2lkdGggKiB0aGlzLmRwcjtcbiAgICAgICAgICAgIHJvb3RDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5kcHI7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290Q2FudmFzLCB0aGlzLCB0aGlzLmRwcik7XG4gICAgICAgICAgICBtYWluTGF5ZXIuX19idWlsdGluX18gPSB0cnVlO1xuICAgICAgICAgICAgbWFpbkxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgICBsYXllcnNbQ0FOVkFTX1pMRVZFTF0gPSBtYWluTGF5ZXI7XG4gICAgICAgICAgICBtYWluTGF5ZXIuemxldmVsID0gQ0FOVkFTX1pMRVZFTDtcbiAgICAgICAgICAgIHpsZXZlbExpc3QucHVzaChDQU5WQVNfWkxFVkVMKTtcbiAgICAgICAgICAgIHRoaXMuX2RvbVJvb3QgPSByb290O1xuICAgICAgICB9XG4gICAgfVxuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnY2FudmFzJztcbiAgICB9O1xuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLmlzU2luZ2xlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2luZ2xlQ2FudmFzO1xuICAgIH07XG4gICAgQ2FudmFzUGFpbnRlci5wcm90b3R5cGUuZ2V0Vmlld3BvcnRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9tUm9vdDtcbiAgICB9O1xuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLmdldFZpZXdwb3J0Um9vdE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZpZXdwb3J0Um9vdCA9IHRoaXMuZ2V0Vmlld3BvcnRSb290KCk7XG4gICAgICAgIGlmICh2aWV3cG9ydFJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0TGVmdDogdmlld3BvcnRSb290Lm9mZnNldExlZnQgfHwgMCxcbiAgICAgICAgICAgICAgICBvZmZzZXRUb3A6IHZpZXdwb3J0Um9vdC5vZmZzZXRUb3AgfHwgMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FudmFzUGFpbnRlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIChwYWludEFsbCkge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcbiAgICAgICAgdmFyIHByZXZMaXN0ID0gdGhpcy5fcHJldkRpc3BsYXlMaXN0O1xuICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgICAgIHRoaXMuX3JlZHJhd0lkID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgdGhpcy5fcGFpbnRMaXN0KGxpc3QsIHByZXZMaXN0LCBwYWludEFsbCwgdGhpcy5fcmVkcmF3SWQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcbiAgICAgICAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18gJiYgbGF5ZXIucmVmcmVzaCkge1xuICAgICAgICAgICAgICAgIHZhciBjbGVhckNvbG9yID0gaSA9PT0gMCA/IHRoaXMuX2JhY2tncm91bmRDb2xvciA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGF5ZXIucmVmcmVzaChjbGVhckNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0cy51c2VEaXJ0eVJlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZEaXNwbGF5TGlzdCA9IGxpc3Quc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLnJlZnJlc2hIb3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcGFpbnRIb3Zlckxpc3QodGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KGZhbHNlKSk7XG4gICAgfTtcbiAgICBDYW52YXNQYWludGVyLnByb3RvdHlwZS5fcGFpbnRIb3Zlckxpc3QgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllcjtcbiAgICAgICAgaG92ZXJMYXllciAmJiBob3ZlckxheWVyLmNsZWFyKCk7XG4gICAgICAgIGlmICghbGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjb3BlID0ge1xuICAgICAgICAgICAgaW5Ib3ZlcjogdHJ1ZSxcbiAgICAgICAgICAgIHZpZXdXaWR0aDogdGhpcy5fd2lkdGgsXG4gICAgICAgICAgICB2aWV3SGVpZ2h0OiB0aGlzLl9oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGN0eDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChlbC5fX2luSG92ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhvdmVyTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXIgPSB0aGlzLmdldExheWVyKEhPVkVSX0xBWUVSX1pMRVZFTCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IGhvdmVyTGF5ZXIuY3R4O1xuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicnVzaChjdHgsIGVsLCBzY29wZSwgaSA9PT0gbGVuIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FudmFzUGFpbnRlci5wcm90b3R5cGUuZ2V0SG92ZXJMYXllciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXIoSE9WRVJfTEFZRVJfWkxFVkVMKTtcbiAgICB9O1xuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLnBhaW50T25lID0gZnVuY3Rpb24gKGN0eCwgZWwpIHtcbiAgICAgICAgYnJ1c2hTaW5nbGUoY3R4LCBlbCk7XG4gICAgfTtcbiAgICBDYW52YXNQYWludGVyLnByb3RvdHlwZS5fcGFpbnRMaXN0ID0gZnVuY3Rpb24gKGxpc3QsIHByZXZMaXN0LCBwYWludEFsbCwgcmVkcmF3SWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlZHJhd0lkICE9PSByZWRyYXdJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhaW50QWxsID0gcGFpbnRBbGwgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyU3RhdHVzKGxpc3QpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9kb1BhaW50TGlzdChsaXN0LCBwcmV2TGlzdCwgcGFpbnRBbGwpLCBmaW5pc2hlZCA9IF9hLmZpbmlzaGVkLCBuZWVkc1JlZnJlc2hIb3ZlciA9IF9hLm5lZWRzUmVmcmVzaEhvdmVyO1xuICAgICAgICBpZiAodGhpcy5fbmVlZHNNYW51YWxseUNvbXBvc2l0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21wb3NpdGVNYW51YWxseSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc1JlZnJlc2hIb3Zlcikge1xuICAgICAgICAgICAgdGhpcy5fcGFpbnRIb3Zlckxpc3QobGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaW5pc2hlZCkge1xuICAgICAgICAgICAgdmFyIHNlbGZfMSA9IHRoaXM7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGZfMS5fcGFpbnRMaXN0KGxpc3QsIHByZXZMaXN0LCBwYWludEFsbCwgcmVkcmF3SWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsYXllci5hZnRlckJydXNoICYmIGxheWVyLmFmdGVyQnJ1c2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYW52YXNQYWludGVyLnByb3RvdHlwZS5fY29tcG9zaXRlTWFudWFsbHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmdldExheWVyKENBTlZBU19aTEVWRUwpLmN0eDtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5fZG9tUm9vdC53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuX2RvbVJvb3QuaGVpZ2h0O1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICBpZiAobGF5ZXIudmlydHVhbCkge1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXIuZG9tLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYW52YXNQYWludGVyLnByb3RvdHlwZS5fZG9QYWludExpc3QgPSBmdW5jdGlvbiAobGlzdCwgcHJldkxpc3QsIHBhaW50QWxsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsYXllckxpc3QgPSBbXTtcbiAgICAgICAgdmFyIHVzZURpcnR5UmVjdCA9IHRoaXMuX29wdHMudXNlRGlydHlSZWN0O1xuICAgICAgICBmb3IgKHZhciB6aSA9IDA7IHppIDwgdGhpcy5femxldmVsTGlzdC5sZW5ndGg7IHppKyspIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWwgPSB0aGlzLl96bGV2ZWxMaXN0W3ppXTtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKGxheWVyLl9fYnVpbHRpbl9fXG4gICAgICAgICAgICAgICAgJiYgbGF5ZXIgIT09IHRoaXMuX2hvdmVybGF5ZXJcbiAgICAgICAgICAgICAgICAmJiAobGF5ZXIuX19kaXJ0eSB8fCBwYWludEFsbCkpIHtcbiAgICAgICAgICAgICAgICBsYXllckxpc3QucHVzaChsYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG5lZWRzUmVmcmVzaEhvdmVyID0gZmFsc2U7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyTGlzdFtrXTtcbiAgICAgICAgICAgIHZhciBjdHggPSBsYXllci5jdHg7XG4gICAgICAgICAgICB2YXIgcmVwYWludFJlY3RzID0gdXNlRGlydHlSZWN0XG4gICAgICAgICAgICAgICAgJiYgbGF5ZXIuY3JlYXRlUmVwYWludFJlY3RzKGxpc3QsIHByZXZMaXN0LCB0aGlzXzEuX3dpZHRoLCB0aGlzXzEuX2hlaWdodCk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBwYWludEFsbCA/IGxheWVyLl9fc3RhcnRJbmRleCA6IGxheWVyLl9fZHJhd0luZGV4O1xuICAgICAgICAgICAgdmFyIHVzZVRpbWVyID0gIXBhaW50QWxsICYmIGxheWVyLmluY3JlbWVudGFsICYmIERhdGUubm93O1xuICAgICAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHVzZVRpbWVyICYmIERhdGUubm93KCk7XG4gICAgICAgICAgICB2YXIgY2xlYXJDb2xvciA9IGxheWVyLnpsZXZlbCA9PT0gdGhpc18xLl96bGV2ZWxMaXN0WzBdXG4gICAgICAgICAgICAgICAgPyB0aGlzXzEuX2JhY2tncm91bmRDb2xvciA6IG51bGw7XG4gICAgICAgICAgICBpZiAobGF5ZXIuX19zdGFydEluZGV4ID09PSBsYXllci5fX2VuZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuY2xlYXIoZmFsc2UsIGNsZWFyQ29sb3IsIHJlcGFpbnRSZWN0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydCA9PT0gbGF5ZXIuX19zdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0RWwgPSBsaXN0W3N0YXJ0XTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0RWwuaW5jcmVtZW50YWwgfHwgIWZpcnN0RWwubm90Q2xlYXIgfHwgcGFpbnRBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuY2xlYXIoZmFsc2UsIGNsZWFyQ29sb3IsIHJlcGFpbnRSZWN0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZvciBzb21lIHVua25vd24gcmVhc29uLiBkcmF3SW5kZXggaXMgLTEnKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGxheWVyLl9fc3RhcnRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIHJlcGFpbnQgPSBmdW5jdGlvbiAocmVwYWludFJlY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NvcGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGluSG92ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGxDbGlwcGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcHJldkVsOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB2aWV3V2lkdGg6IF90aGlzLl93aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgdmlld0hlaWdodDogX3RoaXMuX2hlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBsYXllci5fX2VuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLl9faW5Ib3Zlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNSZWZyZXNoSG92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9kb1BhaW50RWwoZWwsIGxheWVyLCB1c2VEaXJ0eVJlY3QsIHJlcGFpbnRSZWN0LCBzY29wZSwgaSA9PT0gbGF5ZXIuX19lbmRJbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlVGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZFRpbWUgPiAxNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlcGFpbnRSZWN0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXBhaW50UmVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBsYXllci5fX2VuZEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRwciA9IHRoaXNfMS5kcHI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcmVwYWludFJlY3RzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHJlcGFpbnRSZWN0c1tyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChyZWN0LnggKiBkcHIsIHJlY3QueSAqIGRwciwgcmVjdC53aWR0aCAqIGRwciwgcmVjdC5oZWlnaHQgKiBkcHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGFpbnQocmVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICByZXBhaW50KCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheWVyLl9fZHJhd0luZGV4ID0gaTtcbiAgICAgICAgICAgIGlmIChsYXllci5fX2RyYXdJbmRleCA8IGxheWVyLl9fZW5kSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsYXllckxpc3QubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudi53eGEpIHtcbiAgICAgICAgICAgIHV0aWwuZWFjaCh0aGlzLl9sYXllcnMsIGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChsYXllciAmJiBsYXllci5jdHggJiYgbGF5ZXIuY3R4LmRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuY3R4LmRyYXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmluaXNoZWQ6IGZpbmlzaGVkLFxuICAgICAgICAgICAgbmVlZHNSZWZyZXNoSG92ZXI6IG5lZWRzUmVmcmVzaEhvdmVyXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDYW52YXNQYWludGVyLnByb3RvdHlwZS5fZG9QYWludEVsID0gZnVuY3Rpb24gKGVsLCBjdXJyZW50TGF5ZXIsIHVzZURpcnR5UmVjdCwgcmVwYWludFJlY3QsIHNjb3BlLCBpc0xhc3QpIHtcbiAgICAgICAgdmFyIGN0eCA9IGN1cnJlbnRMYXllci5jdHg7XG4gICAgICAgIGlmICh1c2VEaXJ0eVJlY3QpIHtcbiAgICAgICAgICAgIHZhciBwYWludFJlY3QgPSBlbC5nZXRQYWludFJlY3QoKTtcbiAgICAgICAgICAgIGlmICghcmVwYWludFJlY3QgfHwgcGFpbnRSZWN0ICYmIHBhaW50UmVjdC5pbnRlcnNlY3QocmVwYWludFJlY3QpKSB7XG4gICAgICAgICAgICAgICAgYnJ1c2goY3R4LCBlbCwgc2NvcGUsIGlzTGFzdCk7XG4gICAgICAgICAgICAgICAgZWwuc2V0UHJldlBhaW50UmVjdChwYWludFJlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJ1c2goY3R4LCBlbCwgc2NvcGUsIGlzTGFzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLmdldExheWVyID0gZnVuY3Rpb24gKHpsZXZlbCwgdmlydHVhbCkge1xuICAgICAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzICYmICF0aGlzLl9uZWVkc01hbnVhbGx5Q29tcG9zaXRpbmcpIHtcbiAgICAgICAgICAgIHpsZXZlbCA9IENBTlZBU19aTEVWRUw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG4gICAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyID0gbmV3IExheWVyKCd6cl8nICsgemxldmVsLCB0aGlzLCB0aGlzLmRwcik7XG4gICAgICAgICAgICBsYXllci56bGV2ZWwgPSB6bGV2ZWw7XG4gICAgICAgICAgICBsYXllci5fX2J1aWx0aW5fXyA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fbGF5ZXJDb25maWdbemxldmVsIC0gRUxfQUZURVJfSU5DUkVNRU5UQUxfSU5DXSkge1xuICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbCAtIEVMX0FGVEVSX0lOQ1JFTUVOVEFMX0lOQ10sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpcnR1YWwpIHtcbiAgICAgICAgICAgICAgICBsYXllci52aXJ0dWFsID0gdmlydHVhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0TGF5ZXIoemxldmVsLCBsYXllcik7XG4gICAgICAgICAgICBsYXllci5pbml0Q29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLmluc2VydExheWVyID0gZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcbiAgICAgICAgdmFyIGxheWVyc01hcCA9IHRoaXMuX2xheWVycztcbiAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICB2YXIgbGVuID0gemxldmVsTGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDtcbiAgICAgICAgdmFyIHByZXZMYXllciA9IG51bGw7XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIGlmIChsYXllcnNNYXBbemxldmVsXSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICB1dGlsLmxvZ0Vycm9yKCdaTGV2ZWwgJyArIHpsZXZlbCArICcgaGFzIGJlZW4gdXNlZCBhbHJlYWR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0xheWVyVmFsaWQobGF5ZXIpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHV0aWwubG9nRXJyb3IoJ0xheWVyIG9mIHpsZXZlbCAnICsgemxldmVsICsgJyBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID4gMCAmJiB6bGV2ZWwgPiB6bGV2ZWxMaXN0WzBdKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHpsZXZlbExpc3RbaV0gPCB6bGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgJiYgemxldmVsTGlzdFtpICsgMV0gPiB6bGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldkxheWVyID0gbGF5ZXJzTWFwW3psZXZlbExpc3RbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKGkgKyAxLCAwLCB6bGV2ZWwpO1xuICAgICAgICBsYXllcnNNYXBbemxldmVsXSA9IGxheWVyO1xuICAgICAgICBpZiAoIWxheWVyLnZpcnR1YWwpIHtcbiAgICAgICAgICAgIGlmIChwcmV2TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldkRvbSA9IHByZXZMYXllci5kb207XG4gICAgICAgICAgICAgICAgaWYgKHByZXZEb20ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUobGF5ZXIuZG9tLCBwcmV2RG9tLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tUm9vdC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgZG9tUm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXIucGFpbnRlciB8fCAobGF5ZXIucGFpbnRlciA9IHRoaXMpO1xuICAgIH07XG4gICAgQ2FudmFzUGFpbnRlci5wcm90b3R5cGUuZWFjaExheWVyID0gZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1t6XSwgeik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLmVhY2hCdWlsdGluTGF5ZXIgPSBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcbiAgICAgICAgICAgIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDYW52YXNQYWludGVyLnByb3RvdHlwZS5lYWNoT3RoZXJMYXllciA9IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgaWYgKCFsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDYW52YXNQYWludGVyLnByb3RvdHlwZS5nZXRMYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcnM7XG4gICAgfTtcbiAgICBDYW52YXNQYWludGVyLnByb3RvdHlwZS5fdXBkYXRlTGF5ZXJTdGF0dXMgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICAgICAgICBsYXllci5fX2RpcnR5ID0gbGF5ZXIuX191c2VkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVQcmV2TGF5ZXIoaWR4KSB7XG4gICAgICAgICAgICBpZiAocHJldkxheWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZMYXllci5fX2VuZEluZGV4ICE9PSBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldkxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2TGF5ZXIuX19lbmRJbmRleCA9IGlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpXzEgPSAxOyBpXzEgPCBsaXN0Lmxlbmd0aDsgaV8xKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBsaXN0W2lfMV07XG4gICAgICAgICAgICAgICAgaWYgKGVsLnpsZXZlbCAhPT0gbGlzdFtpXzEgLSAxXS56bGV2ZWwgfHwgZWwuaW5jcmVtZW50YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNNYW51YWxseUNvbXBvc2l0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2TGF5ZXIgPSBudWxsO1xuICAgICAgICB2YXIgaW5jcmVtZW50YWxMYXllckNvdW50ID0gMDtcbiAgICAgICAgdmFyIHByZXZabGV2ZWw7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgIHZhciB6bGV2ZWwgPSBlbC56bGV2ZWw7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAocHJldlpsZXZlbCAhPT0gemxldmVsKSB7XG4gICAgICAgICAgICAgICAgcHJldlpsZXZlbCA9IHpsZXZlbDtcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnRhbExheWVyQ291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsLmluY3JlbWVudGFsKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIgPSB0aGlzLmdldExheWVyKHpsZXZlbCArIElOQ1JFTUVOVEFMX0lOQywgdGhpcy5fbmVlZHNNYW51YWxseUNvbXBvc2l0aW5nKTtcbiAgICAgICAgICAgICAgICBsYXllci5pbmNyZW1lbnRhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50YWxMYXllckNvdW50ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGhpcy5nZXRMYXllcih6bGV2ZWwgKyAoaW5jcmVtZW50YWxMYXllckNvdW50ID4gMCA/IEVMX0FGVEVSX0lOQ1JFTUVOVEFMX0lOQyA6IDApLCB0aGlzLl9uZWVkc01hbnVhbGx5Q29tcG9zaXRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICAgICAgICAgIHV0aWwubG9nRXJyb3IoJ1pMZXZlbCAnICsgemxldmVsICsgJyBoYXMgYmVlbiB1c2VkIGJ5IHVua293biBsYXllciAnICsgbGF5ZXIuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheWVyICE9PSBwcmV2TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsYXllci5fX3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5fX3N0YXJ0SW5kZXggIT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxheWVyLl9fc3RhcnRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci5pbmNyZW1lbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5fX2RyYXdJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5fX2RyYXdJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVQcmV2TGF5ZXIoaSk7XG4gICAgICAgICAgICAgICAgcHJldkxheWVyID0gbGF5ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGVsLl9fZGlydHkgJiBSRURSQVdfQklUKSAmJiAhZWwuX19pbkhvdmVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLmluY3JlbWVudGFsICYmIGxheWVyLl9fZHJhd0luZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5fX2RyYXdJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVByZXZMYXllcihpKTtcbiAgICAgICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKGZ1bmN0aW9uIChsYXllciwgeikge1xuICAgICAgICAgICAgaWYgKCFsYXllci5fX3VzZWQgJiYgbGF5ZXIuZ2V0RWxlbWVudENvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19zdGFydEluZGV4ID0gbGF5ZXIuX19lbmRJbmRleCA9IGxheWVyLl9fZHJhd0luZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXllci5fX2RpcnR5ICYmIGxheWVyLl9fZHJhd0luZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIGxheWVyLl9fZHJhd0luZGV4ID0gbGF5ZXIuX19zdGFydEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIodGhpcy5fY2xlYXJMYXllcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ2FudmFzUGFpbnRlci5wcm90b3R5cGUuX2NsZWFyTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICB9O1xuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLnNldEJhY2tncm91bmRDb2xvciA9IGZ1bmN0aW9uIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB1dGlsLmVhY2godGhpcy5fbGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLnNldFVucGFpbnRlZCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLmNvbmZpZ0xheWVyID0gZnVuY3Rpb24gKHpsZXZlbCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBsYXllckNvbmZpZyA9IHRoaXMuX2xheWVyQ29uZmlnO1xuICAgICAgICAgICAgaWYgKCFsYXllckNvbmZpZ1t6bGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJDb25maWdbemxldmVsXSA9IGNvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXJDb25maWdbemxldmVsXSwgY29uZmlnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5femxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBfemxldmVsID0gdGhpcy5femxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoX3psZXZlbCA9PT0gemxldmVsIHx8IF96bGV2ZWwgPT09IHpsZXZlbCArIEVMX0FGVEVSX0lOQ1JFTUVOVEFMX0lOQykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbX3psZXZlbF07XG4gICAgICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FudmFzUGFpbnRlci5wcm90b3R5cGUuZGVsTGF5ZXIgPSBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW3psZXZlbF07XG4gICAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsYXllci5kb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsYXllci5kb20pO1xuICAgICAgICBkZWxldGUgbGF5ZXJzW3psZXZlbF07XG4gICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgICB9O1xuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICghdGhpcy5fZG9tUm9vdC5zdHlsZSkge1xuICAgICAgICAgICAgaWYgKHdpZHRoID09IG51bGwgfHwgaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5nZXRMYXllcihDQU5WQVNfWkxFVkVMKS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG4gICAgICAgICAgICBkb21Sb290LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIHdpZHRoICE9IG51bGwgJiYgKG9wdHMud2lkdGggPSB3aWR0aCk7XG4gICAgICAgICAgICBoZWlnaHQgIT0gbnVsbCAmJiAob3B0cy5oZWlnaHQgPSBoZWlnaHQpO1xuICAgICAgICAgICAgd2lkdGggPSBnZXRTaXplKHJvb3QsIDAsIG9wdHMpO1xuICAgICAgICAgICAgaGVpZ2h0ID0gZ2V0U2l6ZShyb290LCAxLCBvcHRzKTtcbiAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dpZHRoICE9PSB3aWR0aCB8fCBoZWlnaHQgIT09IHRoaXMuX2hlaWdodCkge1xuICAgICAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGF5ZXJzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLmNsZWFyTGF5ZXIgPSBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucm9vdC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgdGhpcy5yb290ID1cbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9tUm9vdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheWVycyA9IG51bGw7XG4gICAgfTtcbiAgICBDYW52YXNQYWludGVyLnByb3RvdHlwZS5nZXRSZW5kZXJlZENhbnZhcyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzICYmICF0aGlzLl9jb21wb3NpdGVNYW51YWxseSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1tDQU5WQVNfWkxFVkVMXS5kb207XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGltYWdlTGF5ZXIgPSBuZXcgTGF5ZXIoJ2ltYWdlJywgdGhpcywgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZHByKTtcbiAgICAgICAgaW1hZ2VMYXllci5pbml0Q29udGV4dCgpO1xuICAgICAgICBpbWFnZUxheWVyLmNsZWFyKGZhbHNlLCBvcHRzLmJhY2tncm91bmRDb2xvciB8fCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICB2YXIgY3R4ID0gaW1hZ2VMYXllci5jdHg7XG4gICAgICAgIGlmIChvcHRzLnBpeGVsUmF0aW8gPD0gdGhpcy5kcHIpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgdmFyIHdpZHRoXzEgPSBpbWFnZUxheWVyLmRvbS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHRfMSA9IGltYWdlTGF5ZXIuZG9tLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGxheWVyLmRvbSwgMCwgMCwgd2lkdGhfMSwgaGVpZ2h0XzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsYXllci5yZW5kZXJUb0NhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsYXllci5yZW5kZXJUb0NhbnZhcyhjdHgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNjb3BlID0ge1xuICAgICAgICAgICAgICAgIGluSG92ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZpZXdXaWR0aDogdGhpcy5fd2lkdGgsXG4gICAgICAgICAgICAgICAgdmlld0hlaWdodDogdGhpcy5faGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZGlzcGxheUxpc3RbaV07XG4gICAgICAgICAgICAgICAgYnJ1c2goY3R4LCBlbCwgc2NvcGUsIGkgPT09IGxlbiAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbWFnZUxheWVyLmRvbTtcbiAgICB9O1xuICAgIENhbnZhc1BhaW50ZXIucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfTtcbiAgICBDYW52YXNQYWludGVyLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FudmFzUGFpbnRlcjtcbn0oKSk7XG5leHBvcnQgZGVmYXVsdCBDYW52YXNQYWludGVyO1xuO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30536\n")},53479:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ff: () => (/* binding */ getCanvasGradient),\n/* harmony export */   KU: () => (/* binding */ isClipPathChanged),\n/* harmony export */   YC: () => (/* binding */ getSize)\n/* harmony export */ });\n/* unused harmony exports createLinearGradient, createRadialGradient */\nfunction isSafeNum(num) {\n    return isFinite(num);\n}\nfunction createLinearGradient(ctx, obj, rect) {\n    var x = obj.x == null ? 0 : obj.x;\n    var x2 = obj.x2 == null ? 1 : obj.x2;\n    var y = obj.y == null ? 0 : obj.y;\n    var y2 = obj.y2 == null ? 0 : obj.y2;\n    if (!obj.global) {\n        x = x * rect.width + rect.x;\n        x2 = x2 * rect.width + rect.x;\n        y = y * rect.height + rect.y;\n        y2 = y2 * rect.height + rect.y;\n    }\n    x = isSafeNum(x) ? x : 0;\n    x2 = isSafeNum(x2) ? x2 : 1;\n    y = isSafeNum(y) ? y : 0;\n    y2 = isSafeNum(y2) ? y2 : 0;\n    var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n    return canvasGradient;\n}\nfunction createRadialGradient(ctx, obj, rect) {\n    var width = rect.width;\n    var height = rect.height;\n    var min = Math.min(width, height);\n    var x = obj.x == null ? 0.5 : obj.x;\n    var y = obj.y == null ? 0.5 : obj.y;\n    var r = obj.r == null ? 0.5 : obj.r;\n    if (!obj.global) {\n        x = x * width + rect.x;\n        y = y * height + rect.y;\n        r = r * min;\n    }\n    x = isSafeNum(x) ? x : 0.5;\n    y = isSafeNum(y) ? y : 0.5;\n    r = r >= 0 && isSafeNum(r) ? r : 0.5;\n    var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n    return canvasGradient;\n}\nfunction getCanvasGradient(ctx, obj, rect) {\n    var canvasGradient = obj.type === 'radial'\n        ? createRadialGradient(ctx, obj, rect)\n        : createLinearGradient(ctx, obj, rect);\n    var colorStops = obj.colorStops;\n    for (var i = 0; i < colorStops.length; i++) {\n        canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n    }\n    return canvasGradient;\n}\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n    if (clipPaths === prevClipPaths || (!clipPaths && !prevClipPaths)) {\n        return false;\n    }\n    if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n        return true;\n    }\n    for (var i = 0; i < clipPaths.length; i++) {\n        if (clipPaths[i] !== prevClipPaths[i]) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction parseInt10(val) {\n    return parseInt(val, 10);\n}\nfunction getSize(root, whIdx, opts) {\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n        return parseFloat(opts[wh]);\n    }\n    var stl = document.defaultView.getComputedStyle(root);\n    return ((root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n        - (parseInt10(stl[plt]) || 0)\n        - (parseInt10(stl[prb]) || 0)) | 0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM0NzkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY2FudmFzL2hlbHBlci5qcz84NzJjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGlzU2FmZU51bShudW0pIHtcbiAgICByZXR1cm4gaXNGaW5pdGUobnVtKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMaW5lYXJHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICAgIHZhciB4ID0gb2JqLnggPT0gbnVsbCA/IDAgOiBvYmoueDtcbiAgICB2YXIgeDIgPSBvYmoueDIgPT0gbnVsbCA/IDEgOiBvYmoueDI7XG4gICAgdmFyIHkgPSBvYmoueSA9PSBudWxsID8gMCA6IG9iai55O1xuICAgIHZhciB5MiA9IG9iai55MiA9PSBudWxsID8gMCA6IG9iai55MjtcbiAgICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICAgICAgeCA9IHggKiByZWN0LndpZHRoICsgcmVjdC54O1xuICAgICAgICB4MiA9IHgyICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICAgICAgeSA9IHkgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgICAgICAgeTIgPSB5MiAqIHJlY3QuaGVpZ2h0ICsgcmVjdC55O1xuICAgIH1cbiAgICB4ID0gaXNTYWZlTnVtKHgpID8geCA6IDA7XG4gICAgeDIgPSBpc1NhZmVOdW0oeDIpID8geDIgOiAxO1xuICAgIHkgPSBpc1NhZmVOdW0oeSkgPyB5IDogMDtcbiAgICB5MiA9IGlzU2FmZU51bSh5MikgPyB5MiA6IDA7XG4gICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgyLCB5Mik7XG4gICAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJhZGlhbEdyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciB4ID0gb2JqLnggPT0gbnVsbCA/IDAuNSA6IG9iai54O1xuICAgIHZhciB5ID0gb2JqLnkgPT0gbnVsbCA/IDAuNSA6IG9iai55O1xuICAgIHZhciByID0gb2JqLnIgPT0gbnVsbCA/IDAuNSA6IG9iai5yO1xuICAgIGlmICghb2JqLmdsb2JhbCkge1xuICAgICAgICB4ID0geCAqIHdpZHRoICsgcmVjdC54O1xuICAgICAgICB5ID0geSAqIGhlaWdodCArIHJlY3QueTtcbiAgICAgICAgciA9IHIgKiBtaW47XG4gICAgfVxuICAgIHggPSBpc1NhZmVOdW0oeCkgPyB4IDogMC41O1xuICAgIHkgPSBpc1NhZmVOdW0oeSkgPyB5IDogMC41O1xuICAgIHIgPSByID49IDAgJiYgaXNTYWZlTnVtKHIpID8gciA6IDAuNTtcbiAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoeCwgeSwgMCwgeCwgeSwgcik7XG4gICAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENhbnZhc0dyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gb2JqLnR5cGUgPT09ICdyYWRpYWwnXG4gICAgICAgID8gY3JlYXRlUmFkaWFsR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpXG4gICAgICAgIDogY3JlYXRlTGluZWFyR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpO1xuICAgIHZhciBjb2xvclN0b3BzID0gb2JqLmNvbG9yU3RvcHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvclN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbnZhc0dyYWRpZW50LmFkZENvbG9yU3RvcChjb2xvclN0b3BzW2ldLm9mZnNldCwgY29sb3JTdG9wc1tpXS5jb2xvcik7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NsaXBQYXRoQ2hhbmdlZChjbGlwUGF0aHMsIHByZXZDbGlwUGF0aHMpIHtcbiAgICBpZiAoY2xpcFBhdGhzID09PSBwcmV2Q2xpcFBhdGhzIHx8ICghY2xpcFBhdGhzICYmICFwcmV2Q2xpcFBhdGhzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY2xpcFBhdGhzIHx8ICFwcmV2Q2xpcFBhdGhzIHx8IChjbGlwUGF0aHMubGVuZ3RoICE9PSBwcmV2Q2xpcFBhdGhzLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhcnNlSW50MTAodmFsKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpemUocm9vdCwgd2hJZHgsIG9wdHMpIHtcbiAgICB2YXIgd2ggPSBbJ3dpZHRoJywgJ2hlaWdodCddW3doSWR4XTtcbiAgICB2YXIgY3doID0gWydjbGllbnRXaWR0aCcsICdjbGllbnRIZWlnaHQnXVt3aElkeF07XG4gICAgdmFyIHBsdCA9IFsncGFkZGluZ0xlZnQnLCAncGFkZGluZ1RvcCddW3doSWR4XTtcbiAgICB2YXIgcHJiID0gWydwYWRkaW5nUmlnaHQnLCAncGFkZGluZ0JvdHRvbSddW3doSWR4XTtcbiAgICBpZiAob3B0c1t3aF0gIT0gbnVsbCAmJiBvcHRzW3doXSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG9wdHNbd2hdKTtcbiAgICB9XG4gICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocm9vdCk7XG4gICAgcmV0dXJuICgocm9vdFtjd2hdIHx8IHBhcnNlSW50MTAoc3RsW3doXSkgfHwgcGFyc2VJbnQxMChyb290LnN0eWxlW3doXSkpXG4gICAgICAgIC0gKHBhcnNlSW50MTAoc3RsW3BsdF0pIHx8IDApXG4gICAgICAgIC0gKHBhcnNlSW50MTAoc3RsW3ByYl0pIHx8IDApKSB8IDA7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///53479\n")},76050:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   V: () => (/* binding */ getLineDash)\n/* harmony export */ });\n/* unused harmony export normalizeLineDash */\n/* harmony import */ var _core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\nfunction normalizeLineDash(lineType, lineWidth) {\n    if (!lineType || lineType === 'solid' || !(lineWidth > 0)) {\n        return null;\n    }\n    return lineType === 'dashed'\n        ? [4 * lineWidth, 2 * lineWidth]\n        : lineType === 'dotted'\n            ? [lineWidth]\n            : (0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(lineType)\n                ? [lineType] : (0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(lineType) ? lineType : null;\n}\nfunction getLineDash(el) {\n    var style = el.style;\n    var lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);\n    var lineDashOffset = style.lineDashOffset;\n    if (lineDash) {\n        var lineScale_1 = (style.strokeNoScale && el.getLineScale) ? el.getLineScale() : 1;\n        if (lineScale_1 && lineScale_1 !== 1) {\n            lineDash = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)(lineDash, function (rawVal) {\n                return rawVal / lineScale_1;\n            });\n            lineDashOffset /= lineScale_1;\n        }\n    }\n    return [lineDash, lineDashOffset];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYwNTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY2FudmFzL2Rhc2hTdHlsZS5qcz8xNjE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzQXJyYXksIGlzTnVtYmVyLCBtYXAgfSBmcm9tICcuLi9jb3JlL3V0aWwuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmVEYXNoKGxpbmVUeXBlLCBsaW5lV2lkdGgpIHtcbiAgICBpZiAoIWxpbmVUeXBlIHx8IGxpbmVUeXBlID09PSAnc29saWQnIHx8ICEobGluZVdpZHRoID4gMCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsaW5lVHlwZSA9PT0gJ2Rhc2hlZCdcbiAgICAgICAgPyBbNCAqIGxpbmVXaWR0aCwgMiAqIGxpbmVXaWR0aF1cbiAgICAgICAgOiBsaW5lVHlwZSA9PT0gJ2RvdHRlZCdcbiAgICAgICAgICAgID8gW2xpbmVXaWR0aF1cbiAgICAgICAgICAgIDogaXNOdW1iZXIobGluZVR5cGUpXG4gICAgICAgICAgICAgICAgPyBbbGluZVR5cGVdIDogaXNBcnJheShsaW5lVHlwZSkgPyBsaW5lVHlwZSA6IG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TGluZURhc2goZWwpIHtcbiAgICB2YXIgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICB2YXIgbGluZURhc2ggPSBzdHlsZS5saW5lRGFzaCAmJiBzdHlsZS5saW5lV2lkdGggPiAwICYmIG5vcm1hbGl6ZUxpbmVEYXNoKHN0eWxlLmxpbmVEYXNoLCBzdHlsZS5saW5lV2lkdGgpO1xuICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0O1xuICAgIGlmIChsaW5lRGFzaCkge1xuICAgICAgICB2YXIgbGluZVNjYWxlXzEgPSAoc3R5bGUuc3Ryb2tlTm9TY2FsZSAmJiBlbC5nZXRMaW5lU2NhbGUpID8gZWwuZ2V0TGluZVNjYWxlKCkgOiAxO1xuICAgICAgICBpZiAobGluZVNjYWxlXzEgJiYgbGluZVNjYWxlXzEgIT09IDEpIHtcbiAgICAgICAgICAgIGxpbmVEYXNoID0gbWFwKGxpbmVEYXNoLCBmdW5jdGlvbiAocmF3VmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1ZhbCAvIGxpbmVTY2FsZV8xO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsaW5lRGFzaE9mZnNldCAvPSBsaW5lU2NhbGVfMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2xpbmVEYXNoLCBsaW5lRGFzaE9mZnNldF07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///76050\n")}}]);