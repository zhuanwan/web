"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[9645],{13976:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   m: () => (/* binding */ registerImpl),\n/* harmony export */   v: () => (/* binding */ getImpl)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n// Implementation of exported APIs. For example registerMap, getMap.\n// The implementations will be registered when installing the component.\n// Avoid these code being bundled to the core module.\nvar implsStore = {};\n// TODO Type\nfunction registerImpl(name, impl) {\n  if (false) {}\n  implsStore[name] = impl;\n}\nfunction getImpl(name) {\n  if (false) {}\n  return implsStore[name];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM5NzYuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb3JlL2ltcGwuanM/NTI0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGVycm9yIH0gZnJvbSAnLi4vdXRpbC9sb2cuanMnO1xuLy8gSW1wbGVtZW50YXRpb24gb2YgZXhwb3J0ZWQgQVBJcy4gRm9yIGV4YW1wbGUgcmVnaXN0ZXJNYXAsIGdldE1hcC5cbi8vIFRoZSBpbXBsZW1lbnRhdGlvbnMgd2lsbCBiZSByZWdpc3RlcmVkIHdoZW4gaW5zdGFsbGluZyB0aGUgY29tcG9uZW50LlxuLy8gQXZvaWQgdGhlc2UgY29kZSBiZWluZyBidW5kbGVkIHRvIHRoZSBjb3JlIG1vZHVsZS5cbnZhciBpbXBsc1N0b3JlID0ge307XG4vLyBUT0RPIFR5cGVcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckltcGwobmFtZSwgaW1wbCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChpbXBsc1N0b3JlW25hbWVdKSB7XG4gICAgICBlcnJvcihcIkFscmVhZHkgaGFzIGFuIGltcGxlbWVudGF0aW9uIG9mIFwiICsgbmFtZSArIFwiLlwiKTtcbiAgICB9XG4gIH1cbiAgaW1wbHNTdG9yZVtuYW1lXSA9IGltcGw7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW1wbChuYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCFpbXBsc1N0b3JlW25hbWVdKSB7XG4gICAgICBlcnJvcihcIkltcGxlbWVudGF0aW9uIG9mIFwiICsgbmFtZSArIFwiIGRvZXNuJ3QgZXhpc3RzLlwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGltcGxzU3RvcmVbbmFtZV07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13976\n')},49431:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   U: () => (/* binding */ createTask)\n/* harmony export */ });\n/* unused harmony export Task */\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n;\n/**\r\n * @param {Object} define\r\n * @return See the return of `createTask`.\r\n */\nfunction createTask(define) {\n  return new Task(define);\n}\nvar Task = /** @class */function () {\n  function Task(define) {\n    define = define || {};\n    this._reset = define.reset;\n    this._plan = define.plan;\n    this._count = define.count;\n    this._onDirty = define.onDirty;\n    this._dirty = true;\n  }\n  /**\r\n   * @param step Specified step.\r\n   * @param skip Skip customer perform call.\r\n   * @param modBy Sampling window size.\r\n   * @param modDataCount Sampling count.\r\n   * @return whether unfinished.\r\n   */\n  Task.prototype.perform = function (performArgs) {\n    var upTask = this._upstream;\n    var skip = performArgs && performArgs.skip;\n    // TODO some refactor.\n    // Pull data. Must pull data each time, because context.data\n    // may be updated by Series.setData.\n    if (this._dirty && upTask) {\n      var context = this.context;\n      context.data = context.outputData = upTask.context.outputData;\n    }\n    if (this.__pipeline) {\n      this.__pipeline.currentTask = this;\n    }\n    var planResult;\n    if (this._plan && !skip) {\n      planResult = this._plan(this.context);\n    }\n    // Support sharding by mod, which changes the render sequence and makes the rendered graphic\n    // elements uniformed distributed when progress, especially when moving or zooming.\n    var lastModBy = normalizeModBy(this._modBy);\n    var lastModDataCount = this._modDataCount || 0;\n    var modBy = normalizeModBy(performArgs && performArgs.modBy);\n    var modDataCount = performArgs && performArgs.modDataCount || 0;\n    if (lastModBy !== modBy || lastModDataCount !== modDataCount) {\n      planResult = 'reset';\n    }\n    function normalizeModBy(val) {\n      !(val >= 1) && (val = 1); // jshint ignore:line\n      return val;\n    }\n    var forceFirstProgress;\n    if (this._dirty || planResult === 'reset') {\n      this._dirty = false;\n      forceFirstProgress = this._doReset(skip);\n    }\n    this._modBy = modBy;\n    this._modDataCount = modDataCount;\n    var step = performArgs && performArgs.step;\n    if (upTask) {\n      if (false) {}\n      this._dueEnd = upTask._outputDueEnd;\n    }\n    // DataTask or overallTask\n    else {\n      if (false) {}\n      this._dueEnd = this._count ? this._count(this.context) : Infinity;\n    }\n    // Note: Stubs, that its host overall task let it has progress, has progress.\n    // If no progress, pass index from upstream to downstream each time plan called.\n    if (this._progress) {\n      var start = this._dueIndex;\n      var end = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);\n      if (!skip && (forceFirstProgress || start < end)) {\n        var progress = this._progress;\n        if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(progress)) {\n          for (var i = 0; i < progress.length; i++) {\n            this._doProgress(progress[i], start, end, modBy, modDataCount);\n          }\n        } else {\n          this._doProgress(progress, start, end, modBy, modDataCount);\n        }\n      }\n      this._dueIndex = end;\n      // If no `outputDueEnd`, assume that output data and\n      // input data is the same, so use `dueIndex` as `outputDueEnd`.\n      var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end;\n      if (false) {}\n      this._outputDueEnd = outputDueEnd;\n    } else {\n      // (1) Some overall task has no progress.\n      // (2) Stubs, that its host overall task do not let it has progress, has no progress.\n      // This should always be performed so it can be passed to downstream.\n      this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;\n    }\n    return this.unfinished();\n  };\n  Task.prototype.dirty = function () {\n    this._dirty = true;\n    this._onDirty && this._onDirty(this.context);\n  };\n  Task.prototype._doProgress = function (progress, start, end, modBy, modDataCount) {\n    iterator.reset(start, end, modBy, modDataCount);\n    this._callingProgress = progress;\n    this._callingProgress({\n      start: start,\n      end: end,\n      count: end - start,\n      next: iterator.next\n    }, this.context);\n  };\n  Task.prototype._doReset = function (skip) {\n    this._dueIndex = this._outputDueEnd = this._dueEnd = 0;\n    this._settedOutputEnd = null;\n    var progress;\n    var forceFirstProgress;\n    if (!skip && this._reset) {\n      progress = this._reset(this.context);\n      if (progress && progress.progress) {\n        forceFirstProgress = progress.forceFirstProgress;\n        progress = progress.progress;\n      }\n      // To simplify no progress checking, array must has item.\n      if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(progress) && !progress.length) {\n        progress = null;\n      }\n    }\n    this._progress = progress;\n    this._modBy = this._modDataCount = null;\n    var downstream = this._downstream;\n    downstream && downstream.dirty();\n    return forceFirstProgress;\n  };\n  Task.prototype.unfinished = function () {\n    return this._progress && this._dueIndex < this._dueEnd;\n  };\n  /**\r\n   * @param downTask The downstream task.\r\n   * @return The downstream task.\r\n   */\n  Task.prototype.pipe = function (downTask) {\n    if (false) {}\n    // If already downstream, do not dirty downTask.\n    if (this._downstream !== downTask || this._dirty) {\n      this._downstream = downTask;\n      downTask._upstream = this;\n      downTask.dirty();\n    }\n  };\n  Task.prototype.dispose = function () {\n    if (this._disposed) {\n      return;\n    }\n    this._upstream && (this._upstream._downstream = null);\n    this._downstream && (this._downstream._upstream = null);\n    this._dirty = false;\n    this._disposed = true;\n  };\n  Task.prototype.getUpstream = function () {\n    return this._upstream;\n  };\n  Task.prototype.getDownstream = function () {\n    return this._downstream;\n  };\n  Task.prototype.setOutputEnd = function (end) {\n    // This only happens in dataTask, dataZoom, map, currently.\n    // where dataZoom do not set end each time, but only set\n    // when reset. So we should record the set end, in case\n    // that the stub of dataZoom perform again and earse the\n    // set end by upstream.\n    this._outputDueEnd = this._settedOutputEnd = end;\n  };\n  return Task;\n}();\n\nvar iterator = function () {\n  var end;\n  var current;\n  var modBy;\n  var modDataCount;\n  var winCount;\n  var it = {\n    reset: function (s, e, sStep, sCount) {\n      current = s;\n      end = e;\n      modBy = sStep;\n      modDataCount = sCount;\n      winCount = Math.ceil(modDataCount / modBy);\n      it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;\n    }\n  };\n  return it;\n  function sequentialNext() {\n    return current < end ? current++ : null;\n  }\n  function modNext() {\n    var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);\n    var result = current >= end ? null : dataIndex < modDataCount ? dataIndex\n    // If modDataCount is smaller than data.count() (consider `appendData` case),\n    // Use normal linear rendering mode.\n    : current;\n    current++;\n    return result;\n  }\n}();\n// -----------------------------------------------------------------------------\n// For stream debug (Should be commented out after used!)\n// @usage: printTask(this, 'begin');\n// @usage: printTask(this, null, {someExtraProp});\n// @usage: Use `__idxInPipeline` as conditional breakpiont.\n//\n// window.printTask = function (task: any, prefix: string, extra: { [key: string]: unknown }): void {\n//     window.ecTaskUID == null && (window.ecTaskUID = 0);\n//     task.uidDebug == null && (task.uidDebug = `task_${window.ecTaskUID++}`);\n//     task.agent && task.agent.uidDebug == null && (task.agent.uidDebug = `task_${window.ecTaskUID++}`);\n//     let props = [];\n//     if (task.__pipeline) {\n//         let val = `${task.__idxInPipeline}/${task.__pipeline.tail.__idxInPipeline} ${task.agent ? '(stub)' : ''}`;\n//         props.push({text: '__idxInPipeline/total', value: val});\n//     } else {\n//         let stubCount = 0;\n//         task.agentStubMap.each(() => stubCount++);\n//         props.push({text: 'idx', value: `overall (stubs: ${stubCount})`});\n//     }\n//     props.push({text: 'uid', value: task.uidDebug});\n//     if (task.__pipeline) {\n//         props.push({text: 'pipelineId', value: task.__pipeline.id});\n//         task.agent && props.push(\n//             {text: 'stubFor', value: task.agent.uidDebug}\n//         );\n//     }\n//     props.push(\n//         {text: 'dirty', value: task._dirty},\n//         {text: 'dueIndex', value: task._dueIndex},\n//         {text: 'dueEnd', value: task._dueEnd},\n//         {text: 'outputDueEnd', value: task._outputDueEnd}\n//     );\n//     if (extra) {\n//         Object.keys(extra).forEach(key => {\n//             props.push({text: key, value: extra[key]});\n//         });\n//     }\n//     let args = ['color: blue'];\n//     let msg = `%c[${prefix || 'T'}] %c` + props.map(item => (\n//         args.push('color: green', 'color: red'),\n//         `${item.text}: %c${item.value}`\n//     )).join('%c, ');\n//     console.log.apply(console, [msg].concat(args));\n//     // console.log(this);\n// };\n// window.printPipeline = function (task: any, prefix: string) {\n//     const pipeline = task.__pipeline;\n//     let currTask = pipeline.head;\n//     while (currTask) {\n//         window.printTask(currTask, prefix);\n//         currTask = currTask._downstream;\n//     }\n// };\n// window.showChain = function (chainHeadTask) {\n//     var chain = [];\n//     var task = chainHeadTask;\n//     while (task) {\n//         chain.push({\n//             task: task,\n//             up: task._upstream,\n//             down: task._downstream,\n//             idxInPipeline: task.__idxInPipeline\n//         });\n//         task = task._downstream;\n//     }\n//     return chain;\n// };\n// window.findTaskInChain = function (task, chainHeadTask) {\n//     let chain = window.showChain(chainHeadTask);\n//     let result = [];\n//     for (let i = 0; i < chain.length; i++) {\n//         let chainItem = chain[i];\n//         if (chainItem.task === task) {\n//             result.push(i);\n//         }\n//     }\n//     return result;\n// };\n// window.printChainAEachInChainB = function (chainHeadTaskA, chainHeadTaskB) {\n//     let chainA = window.showChain(chainHeadTaskA);\n//     for (let i = 0; i < chainA.length; i++) {\n//         console.log('chainAIdx:', i, 'inChainB:', window.findTaskInChain(chainA[i].task, chainHeadTaskB));\n//     }\n// };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk0MzEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29yZS90YXNrLmpzP2ZlNjQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBhc3NlcnQsIGlzQXJyYXkgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuO1xuLyoqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbmVcclxuICogQHJldHVybiBTZWUgdGhlIHJldHVybiBvZiBgY3JlYXRlVGFza2AuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhc2soZGVmaW5lKSB7XG4gIHJldHVybiBuZXcgVGFzayhkZWZpbmUpO1xufVxudmFyIFRhc2sgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUYXNrKGRlZmluZSkge1xuICAgIGRlZmluZSA9IGRlZmluZSB8fCB7fTtcbiAgICB0aGlzLl9yZXNldCA9IGRlZmluZS5yZXNldDtcbiAgICB0aGlzLl9wbGFuID0gZGVmaW5lLnBsYW47XG4gICAgdGhpcy5fY291bnQgPSBkZWZpbmUuY291bnQ7XG4gICAgdGhpcy5fb25EaXJ0eSA9IGRlZmluZS5vbkRpcnR5O1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0gc3RlcCBTcGVjaWZpZWQgc3RlcC5cclxuICAgKiBAcGFyYW0gc2tpcCBTa2lwIGN1c3RvbWVyIHBlcmZvcm0gY2FsbC5cclxuICAgKiBAcGFyYW0gbW9kQnkgU2FtcGxpbmcgd2luZG93IHNpemUuXHJcbiAgICogQHBhcmFtIG1vZERhdGFDb3VudCBTYW1wbGluZyBjb3VudC5cclxuICAgKiBAcmV0dXJuIHdoZXRoZXIgdW5maW5pc2hlZC5cclxuICAgKi9cbiAgVGFzay5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIChwZXJmb3JtQXJncykge1xuICAgIHZhciB1cFRhc2sgPSB0aGlzLl91cHN0cmVhbTtcbiAgICB2YXIgc2tpcCA9IHBlcmZvcm1BcmdzICYmIHBlcmZvcm1BcmdzLnNraXA7XG4gICAgLy8gVE9ETyBzb21lIHJlZmFjdG9yLlxuICAgIC8vIFB1bGwgZGF0YS4gTXVzdCBwdWxsIGRhdGEgZWFjaCB0aW1lLCBiZWNhdXNlIGNvbnRleHQuZGF0YVxuICAgIC8vIG1heSBiZSB1cGRhdGVkIGJ5IFNlcmllcy5zZXREYXRhLlxuICAgIGlmICh0aGlzLl9kaXJ0eSAmJiB1cFRhc2spIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgY29udGV4dC5kYXRhID0gY29udGV4dC5vdXRwdXREYXRhID0gdXBUYXNrLmNvbnRleHQub3V0cHV0RGF0YTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19waXBlbGluZSkge1xuICAgICAgdGhpcy5fX3BpcGVsaW5lLmN1cnJlbnRUYXNrID0gdGhpcztcbiAgICB9XG4gICAgdmFyIHBsYW5SZXN1bHQ7XG4gICAgaWYgKHRoaXMuX3BsYW4gJiYgIXNraXApIHtcbiAgICAgIHBsYW5SZXN1bHQgPSB0aGlzLl9wbGFuKHRoaXMuY29udGV4dCk7XG4gICAgfVxuICAgIC8vIFN1cHBvcnQgc2hhcmRpbmcgYnkgbW9kLCB3aGljaCBjaGFuZ2VzIHRoZSByZW5kZXIgc2VxdWVuY2UgYW5kIG1ha2VzIHRoZSByZW5kZXJlZCBncmFwaGljXG4gICAgLy8gZWxlbWVudHMgdW5pZm9ybWVkIGRpc3RyaWJ1dGVkIHdoZW4gcHJvZ3Jlc3MsIGVzcGVjaWFsbHkgd2hlbiBtb3Zpbmcgb3Igem9vbWluZy5cbiAgICB2YXIgbGFzdE1vZEJ5ID0gbm9ybWFsaXplTW9kQnkodGhpcy5fbW9kQnkpO1xuICAgIHZhciBsYXN0TW9kRGF0YUNvdW50ID0gdGhpcy5fbW9kRGF0YUNvdW50IHx8IDA7XG4gICAgdmFyIG1vZEJ5ID0gbm9ybWFsaXplTW9kQnkocGVyZm9ybUFyZ3MgJiYgcGVyZm9ybUFyZ3MubW9kQnkpO1xuICAgIHZhciBtb2REYXRhQ291bnQgPSBwZXJmb3JtQXJncyAmJiBwZXJmb3JtQXJncy5tb2REYXRhQ291bnQgfHwgMDtcbiAgICBpZiAobGFzdE1vZEJ5ICE9PSBtb2RCeSB8fCBsYXN0TW9kRGF0YUNvdW50ICE9PSBtb2REYXRhQ291bnQpIHtcbiAgICAgIHBsYW5SZXN1bHQgPSAncmVzZXQnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVNb2RCeSh2YWwpIHtcbiAgICAgICEodmFsID49IDEpICYmICh2YWwgPSAxKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICB2YXIgZm9yY2VGaXJzdFByb2dyZXNzO1xuICAgIGlmICh0aGlzLl9kaXJ0eSB8fCBwbGFuUmVzdWx0ID09PSAncmVzZXQnKSB7XG4gICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgZm9yY2VGaXJzdFByb2dyZXNzID0gdGhpcy5fZG9SZXNldChza2lwKTtcbiAgICB9XG4gICAgdGhpcy5fbW9kQnkgPSBtb2RCeTtcbiAgICB0aGlzLl9tb2REYXRhQ291bnQgPSBtb2REYXRhQ291bnQ7XG4gICAgdmFyIHN0ZXAgPSBwZXJmb3JtQXJncyAmJiBwZXJmb3JtQXJncy5zdGVwO1xuICAgIGlmICh1cFRhc2spIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydCh1cFRhc2suX291dHB1dER1ZUVuZCAhPSBudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2R1ZUVuZCA9IHVwVGFzay5fb3V0cHV0RHVlRW5kO1xuICAgIH1cbiAgICAvLyBEYXRhVGFzayBvciBvdmVyYWxsVGFza1xuICAgIGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLl9wcm9ncmVzcyB8fCB0aGlzLl9jb3VudCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kdWVFbmQgPSB0aGlzLl9jb3VudCA/IHRoaXMuX2NvdW50KHRoaXMuY29udGV4dCkgOiBJbmZpbml0eTtcbiAgICB9XG4gICAgLy8gTm90ZTogU3R1YnMsIHRoYXQgaXRzIGhvc3Qgb3ZlcmFsbCB0YXNrIGxldCBpdCBoYXMgcHJvZ3Jlc3MsIGhhcyBwcm9ncmVzcy5cbiAgICAvLyBJZiBubyBwcm9ncmVzcywgcGFzcyBpbmRleCBmcm9tIHVwc3RyZWFtIHRvIGRvd25zdHJlYW0gZWFjaCB0aW1lIHBsYW4gY2FsbGVkLlxuICAgIGlmICh0aGlzLl9wcm9ncmVzcykge1xuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fZHVlSW5kZXg7XG4gICAgICB2YXIgZW5kID0gTWF0aC5taW4oc3RlcCAhPSBudWxsID8gdGhpcy5fZHVlSW5kZXggKyBzdGVwIDogSW5maW5pdHksIHRoaXMuX2R1ZUVuZCk7XG4gICAgICBpZiAoIXNraXAgJiYgKGZvcmNlRmlyc3RQcm9ncmVzcyB8fCBzdGFydCA8IGVuZCkpIHtcbiAgICAgICAgdmFyIHByb2dyZXNzID0gdGhpcy5fcHJvZ3Jlc3M7XG4gICAgICAgIGlmIChpc0FycmF5KHByb2dyZXNzKSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZ3Jlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2RvUHJvZ3Jlc3MocHJvZ3Jlc3NbaV0sIHN0YXJ0LCBlbmQsIG1vZEJ5LCBtb2REYXRhQ291bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kb1Byb2dyZXNzKHByb2dyZXNzLCBzdGFydCwgZW5kLCBtb2RCeSwgbW9kRGF0YUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZHVlSW5kZXggPSBlbmQ7XG4gICAgICAvLyBJZiBubyBgb3V0cHV0RHVlRW5kYCwgYXNzdW1lIHRoYXQgb3V0cHV0IGRhdGEgYW5kXG4gICAgICAvLyBpbnB1dCBkYXRhIGlzIHRoZSBzYW1lLCBzbyB1c2UgYGR1ZUluZGV4YCBhcyBgb3V0cHV0RHVlRW5kYC5cbiAgICAgIHZhciBvdXRwdXREdWVFbmQgPSB0aGlzLl9zZXR0ZWRPdXRwdXRFbmQgIT0gbnVsbCA/IHRoaXMuX3NldHRlZE91dHB1dEVuZCA6IGVuZDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vID8/PyBDYW4gbm90IHJvbGxiYWNrLlxuICAgICAgICBhc3NlcnQob3V0cHV0RHVlRW5kID49IHRoaXMuX291dHB1dER1ZUVuZCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9vdXRwdXREdWVFbmQgPSBvdXRwdXREdWVFbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICgxKSBTb21lIG92ZXJhbGwgdGFzayBoYXMgbm8gcHJvZ3Jlc3MuXG4gICAgICAvLyAoMikgU3R1YnMsIHRoYXQgaXRzIGhvc3Qgb3ZlcmFsbCB0YXNrIGRvIG5vdCBsZXQgaXQgaGFzIHByb2dyZXNzLCBoYXMgbm8gcHJvZ3Jlc3MuXG4gICAgICAvLyBUaGlzIHNob3VsZCBhbHdheXMgYmUgcGVyZm9ybWVkIHNvIGl0IGNhbiBiZSBwYXNzZWQgdG8gZG93bnN0cmVhbS5cbiAgICAgIHRoaXMuX2R1ZUluZGV4ID0gdGhpcy5fb3V0cHV0RHVlRW5kID0gdGhpcy5fc2V0dGVkT3V0cHV0RW5kICE9IG51bGwgPyB0aGlzLl9zZXR0ZWRPdXRwdXRFbmQgOiB0aGlzLl9kdWVFbmQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVuZmluaXNoZWQoKTtcbiAgfTtcbiAgVGFzay5wcm90b3R5cGUuZGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX29uRGlydHkgJiYgdGhpcy5fb25EaXJ0eSh0aGlzLmNvbnRleHQpO1xuICB9O1xuICBUYXNrLnByb3RvdHlwZS5fZG9Qcm9ncmVzcyA9IGZ1bmN0aW9uIChwcm9ncmVzcywgc3RhcnQsIGVuZCwgbW9kQnksIG1vZERhdGFDb3VudCkge1xuICAgIGl0ZXJhdG9yLnJlc2V0KHN0YXJ0LCBlbmQsIG1vZEJ5LCBtb2REYXRhQ291bnQpO1xuICAgIHRoaXMuX2NhbGxpbmdQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgIHRoaXMuX2NhbGxpbmdQcm9ncmVzcyh7XG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGVuZCxcbiAgICAgIGNvdW50OiBlbmQgLSBzdGFydCxcbiAgICAgIG5leHQ6IGl0ZXJhdG9yLm5leHRcbiAgICB9LCB0aGlzLmNvbnRleHQpO1xuICB9O1xuICBUYXNrLnByb3RvdHlwZS5fZG9SZXNldCA9IGZ1bmN0aW9uIChza2lwKSB7XG4gICAgdGhpcy5fZHVlSW5kZXggPSB0aGlzLl9vdXRwdXREdWVFbmQgPSB0aGlzLl9kdWVFbmQgPSAwO1xuICAgIHRoaXMuX3NldHRlZE91dHB1dEVuZCA9IG51bGw7XG4gICAgdmFyIHByb2dyZXNzO1xuICAgIHZhciBmb3JjZUZpcnN0UHJvZ3Jlc3M7XG4gICAgaWYgKCFza2lwICYmIHRoaXMuX3Jlc2V0KSB7XG4gICAgICBwcm9ncmVzcyA9IHRoaXMuX3Jlc2V0KHRoaXMuY29udGV4dCk7XG4gICAgICBpZiAocHJvZ3Jlc3MgJiYgcHJvZ3Jlc3MucHJvZ3Jlc3MpIHtcbiAgICAgICAgZm9yY2VGaXJzdFByb2dyZXNzID0gcHJvZ3Jlc3MuZm9yY2VGaXJzdFByb2dyZXNzO1xuICAgICAgICBwcm9ncmVzcyA9IHByb2dyZXNzLnByb2dyZXNzO1xuICAgICAgfVxuICAgICAgLy8gVG8gc2ltcGxpZnkgbm8gcHJvZ3Jlc3MgY2hlY2tpbmcsIGFycmF5IG11c3QgaGFzIGl0ZW0uXG4gICAgICBpZiAoaXNBcnJheShwcm9ncmVzcykgJiYgIXByb2dyZXNzLmxlbmd0aCkge1xuICAgICAgICBwcm9ncmVzcyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3Byb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgdGhpcy5fbW9kQnkgPSB0aGlzLl9tb2REYXRhQ291bnQgPSBudWxsO1xuICAgIHZhciBkb3duc3RyZWFtID0gdGhpcy5fZG93bnN0cmVhbTtcbiAgICBkb3duc3RyZWFtICYmIGRvd25zdHJlYW0uZGlydHkoKTtcbiAgICByZXR1cm4gZm9yY2VGaXJzdFByb2dyZXNzO1xuICB9O1xuICBUYXNrLnByb3RvdHlwZS51bmZpbmlzaGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9ncmVzcyAmJiB0aGlzLl9kdWVJbmRleCA8IHRoaXMuX2R1ZUVuZDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHBhcmFtIGRvd25UYXNrIFRoZSBkb3duc3RyZWFtIHRhc2suXHJcbiAgICogQHJldHVybiBUaGUgZG93bnN0cmVhbSB0YXNrLlxyXG4gICAqL1xuICBUYXNrLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRvd25UYXNrKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChkb3duVGFzayAmJiAhZG93blRhc2suX2Rpc3Bvc2VkICYmIGRvd25UYXNrICE9PSB0aGlzKTtcbiAgICB9XG4gICAgLy8gSWYgYWxyZWFkeSBkb3duc3RyZWFtLCBkbyBub3QgZGlydHkgZG93blRhc2suXG4gICAgaWYgKHRoaXMuX2Rvd25zdHJlYW0gIT09IGRvd25UYXNrIHx8IHRoaXMuX2RpcnR5KSB7XG4gICAgICB0aGlzLl9kb3duc3RyZWFtID0gZG93blRhc2s7XG4gICAgICBkb3duVGFzay5fdXBzdHJlYW0gPSB0aGlzO1xuICAgICAgZG93blRhc2suZGlydHkoKTtcbiAgICB9XG4gIH07XG4gIFRhc2sucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3Vwc3RyZWFtICYmICh0aGlzLl91cHN0cmVhbS5fZG93bnN0cmVhbSA9IG51bGwpO1xuICAgIHRoaXMuX2Rvd25zdHJlYW0gJiYgKHRoaXMuX2Rvd25zdHJlYW0uX3Vwc3RyZWFtID0gbnVsbCk7XG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gIH07XG4gIFRhc2sucHJvdG90eXBlLmdldFVwc3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl91cHN0cmVhbTtcbiAgfTtcbiAgVGFzay5wcm90b3R5cGUuZ2V0RG93bnN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZG93bnN0cmVhbTtcbiAgfTtcbiAgVGFzay5wcm90b3R5cGUuc2V0T3V0cHV0RW5kID0gZnVuY3Rpb24gKGVuZCkge1xuICAgIC8vIFRoaXMgb25seSBoYXBwZW5zIGluIGRhdGFUYXNrLCBkYXRhWm9vbSwgbWFwLCBjdXJyZW50bHkuXG4gICAgLy8gd2hlcmUgZGF0YVpvb20gZG8gbm90IHNldCBlbmQgZWFjaCB0aW1lLCBidXQgb25seSBzZXRcbiAgICAvLyB3aGVuIHJlc2V0LiBTbyB3ZSBzaG91bGQgcmVjb3JkIHRoZSBzZXQgZW5kLCBpbiBjYXNlXG4gICAgLy8gdGhhdCB0aGUgc3R1YiBvZiBkYXRhWm9vbSBwZXJmb3JtIGFnYWluIGFuZCBlYXJzZSB0aGVcbiAgICAvLyBzZXQgZW5kIGJ5IHVwc3RyZWFtLlxuICAgIHRoaXMuX291dHB1dER1ZUVuZCA9IHRoaXMuX3NldHRlZE91dHB1dEVuZCA9IGVuZDtcbiAgfTtcbiAgcmV0dXJuIFRhc2s7XG59KCk7XG5leHBvcnQgeyBUYXNrIH07XG52YXIgaXRlcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbmQ7XG4gIHZhciBjdXJyZW50O1xuICB2YXIgbW9kQnk7XG4gIHZhciBtb2REYXRhQ291bnQ7XG4gIHZhciB3aW5Db3VudDtcbiAgdmFyIGl0ID0ge1xuICAgIHJlc2V0OiBmdW5jdGlvbiAocywgZSwgc1N0ZXAsIHNDb3VudCkge1xuICAgICAgY3VycmVudCA9IHM7XG4gICAgICBlbmQgPSBlO1xuICAgICAgbW9kQnkgPSBzU3RlcDtcbiAgICAgIG1vZERhdGFDb3VudCA9IHNDb3VudDtcbiAgICAgIHdpbkNvdW50ID0gTWF0aC5jZWlsKG1vZERhdGFDb3VudCAvIG1vZEJ5KTtcbiAgICAgIGl0Lm5leHQgPSBtb2RCeSA+IDEgJiYgbW9kRGF0YUNvdW50ID4gMCA/IG1vZE5leHQgOiBzZXF1ZW50aWFsTmV4dDtcbiAgICB9XG4gIH07XG4gIHJldHVybiBpdDtcbiAgZnVuY3Rpb24gc2VxdWVudGlhbE5leHQoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnQgPCBlbmQgPyBjdXJyZW50KysgOiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIG1vZE5leHQoKSB7XG4gICAgdmFyIGRhdGFJbmRleCA9IGN1cnJlbnQgJSB3aW5Db3VudCAqIG1vZEJ5ICsgTWF0aC5jZWlsKGN1cnJlbnQgLyB3aW5Db3VudCk7XG4gICAgdmFyIHJlc3VsdCA9IGN1cnJlbnQgPj0gZW5kID8gbnVsbCA6IGRhdGFJbmRleCA8IG1vZERhdGFDb3VudCA/IGRhdGFJbmRleFxuICAgIC8vIElmIG1vZERhdGFDb3VudCBpcyBzbWFsbGVyIHRoYW4gZGF0YS5jb3VudCgpIChjb25zaWRlciBgYXBwZW5kRGF0YWAgY2FzZSksXG4gICAgLy8gVXNlIG5vcm1hbCBsaW5lYXIgcmVuZGVyaW5nIG1vZGUuXG4gICAgOiBjdXJyZW50O1xuICAgIGN1cnJlbnQrKztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KCk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRm9yIHN0cmVhbSBkZWJ1ZyAoU2hvdWxkIGJlIGNvbW1lbnRlZCBvdXQgYWZ0ZXIgdXNlZCEpXG4vLyBAdXNhZ2U6IHByaW50VGFzayh0aGlzLCAnYmVnaW4nKTtcbi8vIEB1c2FnZTogcHJpbnRUYXNrKHRoaXMsIG51bGwsIHtzb21lRXh0cmFQcm9wfSk7XG4vLyBAdXNhZ2U6IFVzZSBgX19pZHhJblBpcGVsaW5lYCBhcyBjb25kaXRpb25hbCBicmVha3Bpb250LlxuLy9cbi8vIHdpbmRvdy5wcmludFRhc2sgPSBmdW5jdGlvbiAodGFzazogYW55LCBwcmVmaXg6IHN0cmluZywgZXh0cmE6IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9KTogdm9pZCB7XG4vLyAgICAgd2luZG93LmVjVGFza1VJRCA9PSBudWxsICYmICh3aW5kb3cuZWNUYXNrVUlEID0gMCk7XG4vLyAgICAgdGFzay51aWREZWJ1ZyA9PSBudWxsICYmICh0YXNrLnVpZERlYnVnID0gYHRhc2tfJHt3aW5kb3cuZWNUYXNrVUlEKyt9YCk7XG4vLyAgICAgdGFzay5hZ2VudCAmJiB0YXNrLmFnZW50LnVpZERlYnVnID09IG51bGwgJiYgKHRhc2suYWdlbnQudWlkRGVidWcgPSBgdGFza18ke3dpbmRvdy5lY1Rhc2tVSUQrK31gKTtcbi8vICAgICBsZXQgcHJvcHMgPSBbXTtcbi8vICAgICBpZiAodGFzay5fX3BpcGVsaW5lKSB7XG4vLyAgICAgICAgIGxldCB2YWwgPSBgJHt0YXNrLl9faWR4SW5QaXBlbGluZX0vJHt0YXNrLl9fcGlwZWxpbmUudGFpbC5fX2lkeEluUGlwZWxpbmV9ICR7dGFzay5hZ2VudCA/ICcoc3R1YiknIDogJyd9YDtcbi8vICAgICAgICAgcHJvcHMucHVzaCh7dGV4dDogJ19faWR4SW5QaXBlbGluZS90b3RhbCcsIHZhbHVlOiB2YWx9KTtcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgICBsZXQgc3R1YkNvdW50ID0gMDtcbi8vICAgICAgICAgdGFzay5hZ2VudFN0dWJNYXAuZWFjaCgoKSA9PiBzdHViQ291bnQrKyk7XG4vLyAgICAgICAgIHByb3BzLnB1c2goe3RleHQ6ICdpZHgnLCB2YWx1ZTogYG92ZXJhbGwgKHN0dWJzOiAke3N0dWJDb3VudH0pYH0pO1xuLy8gICAgIH1cbi8vICAgICBwcm9wcy5wdXNoKHt0ZXh0OiAndWlkJywgdmFsdWU6IHRhc2sudWlkRGVidWd9KTtcbi8vICAgICBpZiAodGFzay5fX3BpcGVsaW5lKSB7XG4vLyAgICAgICAgIHByb3BzLnB1c2goe3RleHQ6ICdwaXBlbGluZUlkJywgdmFsdWU6IHRhc2suX19waXBlbGluZS5pZH0pO1xuLy8gICAgICAgICB0YXNrLmFnZW50ICYmIHByb3BzLnB1c2goXG4vLyAgICAgICAgICAgICB7dGV4dDogJ3N0dWJGb3InLCB2YWx1ZTogdGFzay5hZ2VudC51aWREZWJ1Z31cbi8vICAgICAgICAgKTtcbi8vICAgICB9XG4vLyAgICAgcHJvcHMucHVzaChcbi8vICAgICAgICAge3RleHQ6ICdkaXJ0eScsIHZhbHVlOiB0YXNrLl9kaXJ0eX0sXG4vLyAgICAgICAgIHt0ZXh0OiAnZHVlSW5kZXgnLCB2YWx1ZTogdGFzay5fZHVlSW5kZXh9LFxuLy8gICAgICAgICB7dGV4dDogJ2R1ZUVuZCcsIHZhbHVlOiB0YXNrLl9kdWVFbmR9LFxuLy8gICAgICAgICB7dGV4dDogJ291dHB1dER1ZUVuZCcsIHZhbHVlOiB0YXNrLl9vdXRwdXREdWVFbmR9XG4vLyAgICAgKTtcbi8vICAgICBpZiAoZXh0cmEpIHtcbi8vICAgICAgICAgT2JqZWN0LmtleXMoZXh0cmEpLmZvckVhY2goa2V5ID0+IHtcbi8vICAgICAgICAgICAgIHByb3BzLnB1c2goe3RleHQ6IGtleSwgdmFsdWU6IGV4dHJhW2tleV19KTtcbi8vICAgICAgICAgfSk7XG4vLyAgICAgfVxuLy8gICAgIGxldCBhcmdzID0gWydjb2xvcjogYmx1ZSddO1xuLy8gICAgIGxldCBtc2cgPSBgJWNbJHtwcmVmaXggfHwgJ1QnfV0gJWNgICsgcHJvcHMubWFwKGl0ZW0gPT4gKFxuLy8gICAgICAgICBhcmdzLnB1c2goJ2NvbG9yOiBncmVlbicsICdjb2xvcjogcmVkJyksXG4vLyAgICAgICAgIGAke2l0ZW0udGV4dH06ICVjJHtpdGVtLnZhbHVlfWBcbi8vICAgICApKS5qb2luKCclYywgJyk7XG4vLyAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgW21zZ10uY29uY2F0KGFyZ3MpKTtcbi8vICAgICAvLyBjb25zb2xlLmxvZyh0aGlzKTtcbi8vIH07XG4vLyB3aW5kb3cucHJpbnRQaXBlbGluZSA9IGZ1bmN0aW9uICh0YXNrOiBhbnksIHByZWZpeDogc3RyaW5nKSB7XG4vLyAgICAgY29uc3QgcGlwZWxpbmUgPSB0YXNrLl9fcGlwZWxpbmU7XG4vLyAgICAgbGV0IGN1cnJUYXNrID0gcGlwZWxpbmUuaGVhZDtcbi8vICAgICB3aGlsZSAoY3VyclRhc2spIHtcbi8vICAgICAgICAgd2luZG93LnByaW50VGFzayhjdXJyVGFzaywgcHJlZml4KTtcbi8vICAgICAgICAgY3VyclRhc2sgPSBjdXJyVGFzay5fZG93bnN0cmVhbTtcbi8vICAgICB9XG4vLyB9O1xuLy8gd2luZG93LnNob3dDaGFpbiA9IGZ1bmN0aW9uIChjaGFpbkhlYWRUYXNrKSB7XG4vLyAgICAgdmFyIGNoYWluID0gW107XG4vLyAgICAgdmFyIHRhc2sgPSBjaGFpbkhlYWRUYXNrO1xuLy8gICAgIHdoaWxlICh0YXNrKSB7XG4vLyAgICAgICAgIGNoYWluLnB1c2goe1xuLy8gICAgICAgICAgICAgdGFzazogdGFzayxcbi8vICAgICAgICAgICAgIHVwOiB0YXNrLl91cHN0cmVhbSxcbi8vICAgICAgICAgICAgIGRvd246IHRhc2suX2Rvd25zdHJlYW0sXG4vLyAgICAgICAgICAgICBpZHhJblBpcGVsaW5lOiB0YXNrLl9faWR4SW5QaXBlbGluZVxuLy8gICAgICAgICB9KTtcbi8vICAgICAgICAgdGFzayA9IHRhc2suX2Rvd25zdHJlYW07XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBjaGFpbjtcbi8vIH07XG4vLyB3aW5kb3cuZmluZFRhc2tJbkNoYWluID0gZnVuY3Rpb24gKHRhc2ssIGNoYWluSGVhZFRhc2spIHtcbi8vICAgICBsZXQgY2hhaW4gPSB3aW5kb3cuc2hvd0NoYWluKGNoYWluSGVhZFRhc2spO1xuLy8gICAgIGxldCByZXN1bHQgPSBbXTtcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYWluLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgIGxldCBjaGFpbkl0ZW0gPSBjaGFpbltpXTtcbi8vICAgICAgICAgaWYgKGNoYWluSXRlbS50YXNrID09PSB0YXNrKSB7XG4vLyAgICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vICAgICByZXR1cm4gcmVzdWx0O1xuLy8gfTtcbi8vIHdpbmRvdy5wcmludENoYWluQUVhY2hJbkNoYWluQiA9IGZ1bmN0aW9uIChjaGFpbkhlYWRUYXNrQSwgY2hhaW5IZWFkVGFza0IpIHtcbi8vICAgICBsZXQgY2hhaW5BID0gd2luZG93LnNob3dDaGFpbihjaGFpbkhlYWRUYXNrQSk7XG4vLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFpbkEubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgY29uc29sZS5sb2coJ2NoYWluQUlkeDonLCBpLCAnaW5DaGFpbkI6Jywgd2luZG93LmZpbmRUYXNrSW5DaGFpbihjaGFpbkFbaV0udGFzaywgY2hhaW5IZWFkVGFza0IpKTtcbi8vICAgICB9XG4vLyB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///49431\n")},53080:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A$: () => (/* binding */ createLocaleObject),\n/* harmony export */   A4: () => (/* binding */ getLocaleModel),\n/* harmony export */   E: () => (/* binding */ registerLocale),\n/* harmony export */   Lv: () => (/* binding */ SYSTEM_LANG),\n/* harmony export */   pr: () => (/* binding */ getDefaultLocaleModel)\n/* harmony export */ });\n/* harmony import */ var _model_Model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43172);\n/* harmony import */ var zrender_lib_core_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38123);\n/* harmony import */ var _i18n_langEN_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45764);\n/* harmony import */ var _i18n_langZH_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23073);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n// default import ZH and EN lang\n\n\n\nvar LOCALE_ZH = \'ZH\';\nvar LOCALE_EN = \'EN\';\nvar DEFAULT_LOCALE = LOCALE_EN;\nvar localeStorage = {};\nvar localeModels = {};\nvar SYSTEM_LANG = !zrender_lib_core_env_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.domSupported ? DEFAULT_LOCALE : function () {\n  var langStr = (/* eslint-disable-next-line */\n  document.documentElement.lang || navigator.language || navigator.browserLanguage || DEFAULT_LOCALE).toUpperCase();\n  return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;\n}();\nfunction registerLocale(locale, localeObj) {\n  locale = locale.toUpperCase();\n  localeModels[locale] = new _model_Model_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A(localeObj);\n  localeStorage[locale] = localeObj;\n}\n// export function getLocale(locale: string) {\n//     return localeStorage[locale];\n// }\nfunction createLocaleObject(locale) {\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isString)(locale)) {\n    var localeObj = localeStorage[locale.toUpperCase()] || {};\n    if (locale === LOCALE_ZH || locale === LOCALE_EN) {\n      return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone)(localeObj);\n    } else {\n      return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.merge)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone)(localeObj), (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone)(localeStorage[DEFAULT_LOCALE]), false);\n    }\n  } else {\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.merge)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone)(locale), (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone)(localeStorage[DEFAULT_LOCALE]), false);\n  }\n}\nfunction getLocaleModel(lang) {\n  return localeModels[lang];\n}\nfunction getDefaultLocaleModel() {\n  return localeModels[DEFAULT_LOCALE];\n}\n// Default locale\nregisterLocale(LOCALE_EN, _i18n_langEN_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A);\nregisterLocale(LOCALE_ZH, _i18n_langZH_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMwODAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29yZS9sb2NhbGUuanM/NDcyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBNb2RlbCBmcm9tICcuLi9tb2RlbC9Nb2RlbC5qcyc7XG5pbXBvcnQgZW52IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvZW52LmpzJztcbi8vIGRlZmF1bHQgaW1wb3J0IFpIIGFuZCBFTiBsYW5nXG5pbXBvcnQgbGFuZ0VOIGZyb20gJy4uL2kxOG4vbGFuZ0VOLmpzJztcbmltcG9ydCBsYW5nWkggZnJvbSAnLi4vaTE4bi9sYW5nWkguanMnO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGNsb25lLCBtZXJnZSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG52YXIgTE9DQUxFX1pIID0gJ1pIJztcbnZhciBMT0NBTEVfRU4gPSAnRU4nO1xudmFyIERFRkFVTFRfTE9DQUxFID0gTE9DQUxFX0VOO1xudmFyIGxvY2FsZVN0b3JhZ2UgPSB7fTtcbnZhciBsb2NhbGVNb2RlbHMgPSB7fTtcbmV4cG9ydCB2YXIgU1lTVEVNX0xBTkcgPSAhZW52LmRvbVN1cHBvcnRlZCA/IERFRkFVTFRfTE9DQUxFIDogZnVuY3Rpb24gKCkge1xuICB2YXIgbGFuZ1N0ciA9ICgvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgKi9cbiAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgfHwgbmF2aWdhdG9yLmxhbmd1YWdlIHx8IG5hdmlnYXRvci5icm93c2VyTGFuZ3VhZ2UgfHwgREVGQVVMVF9MT0NBTEUpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiBsYW5nU3RyLmluZGV4T2YoTE9DQUxFX1pIKSA+IC0xID8gTE9DQUxFX1pIIDogREVGQVVMVF9MT0NBTEU7XG59KCk7XG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJMb2NhbGUobG9jYWxlLCBsb2NhbGVPYmopIHtcbiAgbG9jYWxlID0gbG9jYWxlLnRvVXBwZXJDYXNlKCk7XG4gIGxvY2FsZU1vZGVsc1tsb2NhbGVdID0gbmV3IE1vZGVsKGxvY2FsZU9iaik7XG4gIGxvY2FsZVN0b3JhZ2VbbG9jYWxlXSA9IGxvY2FsZU9iajtcbn1cbi8vIGV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhbGUobG9jYWxlOiBzdHJpbmcpIHtcbi8vICAgICByZXR1cm4gbG9jYWxlU3RvcmFnZVtsb2NhbGVdO1xuLy8gfVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxvY2FsZU9iamVjdChsb2NhbGUpIHtcbiAgaWYgKGlzU3RyaW5nKGxvY2FsZSkpIHtcbiAgICB2YXIgbG9jYWxlT2JqID0gbG9jYWxlU3RvcmFnZVtsb2NhbGUudG9VcHBlckNhc2UoKV0gfHwge307XG4gICAgaWYgKGxvY2FsZSA9PT0gTE9DQUxFX1pIIHx8IGxvY2FsZSA9PT0gTE9DQUxFX0VOKSB7XG4gICAgICByZXR1cm4gY2xvbmUobG9jYWxlT2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1lcmdlKGNsb25lKGxvY2FsZU9iaiksIGNsb25lKGxvY2FsZVN0b3JhZ2VbREVGQVVMVF9MT0NBTEVdKSwgZmFsc2UpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWVyZ2UoY2xvbmUobG9jYWxlKSwgY2xvbmUobG9jYWxlU3RvcmFnZVtERUZBVUxUX0xPQ0FMRV0pLCBmYWxzZSk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhbGVNb2RlbChsYW5nKSB7XG4gIHJldHVybiBsb2NhbGVNb2RlbHNbbGFuZ107XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdExvY2FsZU1vZGVsKCkge1xuICByZXR1cm4gbG9jYWxlTW9kZWxzW0RFRkFVTFRfTE9DQUxFXTtcbn1cbi8vIERlZmF1bHQgbG9jYWxlXG5yZWdpc3RlckxvY2FsZShMT0NBTEVfRU4sIGxhbmdFTik7XG5yZWdpc3RlckxvY2FsZShMT0NBTEVfWkgsIGxhbmdaSCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///53080\n')},95383:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  FQ: () => (/* binding */ PRIORITY),\n  Ng: () => (/* binding */ connect),\n  p5: () => (/* binding */ dataTool),\n  El: () => (/* binding */ dependencies),\n  zm: () => (/* binding */ disConnect),\n  Zf: () => (/* binding */ disconnect),\n  AS: () => (/* binding */ dispose),\n  Bo: () => (/* binding */ getCoordinateSystemDimensions),\n  FP: () => (/* binding */ getInstanceByDom),\n  aQ: () => (/* binding */ getInstanceById),\n  ZB: () => (/* binding */ getMap),\n  Ts: () => (/* binding */ init),\n  OH: () => (/* binding */ registerAction),\n  pX: () => (/* binding */ registerCoordinateSystem),\n  Oh: () => (/* binding */ registerLayout),\n  Ej: () => (/* binding */ registerLoading),\n  E: () => (/* reexport */ locale/* registerLocale */.E),\n  mz: () => (/* binding */ registerMap),\n  cf: () => (/* binding */ registerPostInit),\n  tb: () => (/* binding */ registerPostUpdate),\n  lP: () => (/* binding */ registerPreprocessor),\n  qg: () => (/* binding */ registerProcessor),\n  bf: () => (/* binding */ registerTheme),\n  iY: () => (/* binding */ registerTransform),\n  xV: () => (/* binding */ registerUpdateLifecycle),\n  AF: () => (/* binding */ registerVisual),\n  vV: () => (/* binding */ setCanvasCreator),\n  rE: () => (/* binding */ version)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/zrender.js\nvar zrender = __webpack_require__(33572);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/env.js\nvar env = __webpack_require__(38123);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/timsort.js\nvar timsort = __webpack_require__(83470);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/Eventful.js\nvar Eventful = __webpack_require__(57861);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Global.js + 1 modules\nvar Global = __webpack_require__(73100);\n;// ./node_modules/echarts/lib/core/ExtensionAPI.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar availableMethods = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isSSR', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL',\n// 'getModel',\n'getOption',\n// 'getViewOfComponentModel',\n// 'getViewOfSeriesModel',\n'getId', 'updateLabelLayout'];\nvar ExtensionAPI = /** @class */function () {\n  function ExtensionAPI(ecInstance) {\n    util.each(availableMethods, function (methodName) {\n      this[methodName] = util.bind(ecInstance[methodName], ecInstance);\n    }, this);\n  }\n  return ExtensionAPI;\n}();\n/* harmony default export */ const core_ExtensionAPI = (ExtensionAPI);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/core/CoordinateSystem.js\nvar CoordinateSystem = __webpack_require__(89737);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/OptionManager.js\nvar OptionManager = __webpack_require__(8348);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/preprocessor/backwardCompat.js + 1 modules\nvar backwardCompat = __webpack_require__(74065);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/processor/dataStack.js\nvar dataStack = __webpack_require__(7213);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar Component = __webpack_require__(59109);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Image.js\nvar Image = __webpack_require__(90540);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Path.js\nvar Path = __webpack_require__(59482);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/throttle.js\nvar throttle = __webpack_require__(24711);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/style.js\nvar style = __webpack_require__(20074);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/loading/default.js\nvar loading_default = __webpack_require__(14716);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/core/task.js\nvar core_task = __webpack_require__(49431);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/component.js\nvar component = __webpack_require__(12616);\n;// ./node_modules/echarts/lib/core/Scheduler.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n;\nvar Scheduler = /** @class */function () {\n  function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n    // key: handlerUID\n    this._stageTaskMap = (0,util.createHashMap)();\n    this.ecInstance = ecInstance;\n    this.api = api;\n    // Fix current processors in case that in some rear cases that\n    // processors might be registered after echarts instance created.\n    // Register processors incrementally for a echarts instance is\n    // not supported by this stream architecture.\n    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n    visualHandlers = this._visualHandlers = visualHandlers.slice();\n    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n  }\n  Scheduler.prototype.restoreData = function (ecModel, payload) {\n    // TODO: Only restore needed series and components, but not all components.\n    // Currently `restoreData` of all of the series and component will be called.\n    // But some independent components like `title`, `legend`, `graphic`, `toolbox`,\n    // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,\n    // and some components like coordinate system, axes, dataZoom, visualMap only\n    // need their target series refresh.\n    // (1) If we are implementing this feature some day, we should consider these cases:\n    // if a data processor depends on a component (e.g., dataZoomProcessor depends\n    // on the settings of `dataZoom`), it should be re-performed if the component\n    // is modified by `setOption`.\n    // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,\n    // it should be re-performed when the result array of `getTargetSeries` changed.\n    // We use `dependencies` to cover these issues.\n    // (3) How to update target series when coordinate system related components modified.\n    // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,\n    // and this case all of the tasks will be set as dirty.\n    ecModel.restoreData(payload);\n    // Theoretically an overall task not only depends on each of its target series, but also\n    // depends on all of the series.\n    // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks\n    // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure\n    // that the overall task is set as dirty and to be performed, otherwise it probably cause\n    // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it\n    // probably cause state chaos (consider `dataZoomProcessor`).\n    this._stageTaskMap.each(function (taskRecord) {\n      var overallTask = taskRecord.overallTask;\n      overallTask && overallTask.dirty();\n    });\n  };\n  // If seriesModel provided, incremental threshold is check by series data.\n  Scheduler.prototype.getPerformArgs = function (task, isBlock) {\n    // For overall task\n    if (!task.__pipeline) {\n      return;\n    }\n    var pipeline = this._pipelineMap.get(task.__pipeline.id);\n    var pCtx = pipeline.context;\n    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n    var step = incremental ? pipeline.step : null;\n    var modDataCount = pCtx && pCtx.modDataCount;\n    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n    return {\n      step: step,\n      modBy: modBy,\n      modDataCount: modDataCount\n    };\n  };\n  Scheduler.prototype.getPipeline = function (pipelineId) {\n    return this._pipelineMap.get(pipelineId);\n  };\n  /**\r\n   * Current, progressive rendering starts from visual and layout.\r\n   * Always detect render mode in the same stage, avoiding that incorrect\r\n   * detection caused by data filtering.\r\n   * Caution:\r\n   * `updateStreamModes` use `seriesModel.getData()`.\r\n   */\n  Scheduler.prototype.updateStreamModes = function (seriesModel, view) {\n    var pipeline = this._pipelineMap.get(seriesModel.uid);\n    var data = seriesModel.getData();\n    var dataLen = data.count();\n    // `progressiveRender` means that can render progressively in each\n    // animation frame. Note that some types of series do not provide\n    // `view.incrementalPrepareRender` but support `chart.appendData`. We\n    // use the term `incremental` but not `progressive` to describe the\n    // case that `chart.appendData`.\n    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n    var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold');\n    // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.\n    // see `test/candlestick-large3.html`\n    var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n    seriesModel.pipelineContext = pipeline.context = {\n      progressiveRender: progressiveRender,\n      modDataCount: modDataCount,\n      large: large\n    };\n  };\n  Scheduler.prototype.restorePipelines = function (ecModel) {\n    var scheduler = this;\n    var pipelineMap = scheduler._pipelineMap = (0,util.createHashMap)();\n    ecModel.eachSeries(function (seriesModel) {\n      var progressive = seriesModel.getProgressive();\n      var pipelineId = seriesModel.uid;\n      pipelineMap.set(pipelineId, {\n        id: pipelineId,\n        head: null,\n        tail: null,\n        threshold: seriesModel.getProgressiveThreshold(),\n        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n        blockIndex: -1,\n        step: Math.round(progressive || 700),\n        count: 0\n      });\n      scheduler._pipe(seriesModel, seriesModel.dataTask);\n    });\n  };\n  Scheduler.prototype.prepareStageTasks = function () {\n    var stageTaskMap = this._stageTaskMap;\n    var ecModel = this.api.getModel();\n    var api = this.api;\n    (0,util.each)(this._allHandlers, function (handler) {\n      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});\n      var errMsg = '';\n      if (false) {}\n      (0,util.assert)(!(handler.reset && handler.overallReset), errMsg);\n      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);\n      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);\n    }, this);\n  };\n  Scheduler.prototype.prepareView = function (view, model, ecModel, api) {\n    var renderTask = view.renderTask;\n    var context = renderTask.context;\n    context.model = model;\n    context.ecModel = ecModel;\n    context.api = api;\n    renderTask.__block = !view.incrementalPrepareRender;\n    this._pipe(model, renderTask);\n  };\n  Scheduler.prototype.performDataProcessorTasks = function (ecModel, payload) {\n    // If we do not use `block` here, it should be considered when to update modes.\n    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {\n      block: true\n    });\n  };\n  Scheduler.prototype.performVisualTasks = function (ecModel, payload, opt) {\n    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);\n  };\n  Scheduler.prototype._performStageTasks = function (stageHandlers, ecModel, payload, opt) {\n    opt = opt || {};\n    var unfinished = false;\n    var scheduler = this;\n    (0,util.each)(stageHandlers, function (stageHandler, idx) {\n      if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n        return;\n      }\n      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n      var overallTask = stageHandlerRecord.overallTask;\n      if (overallTask) {\n        var overallNeedDirty_1;\n        var agentStubMap = overallTask.agentStubMap;\n        agentStubMap.each(function (stub) {\n          if (needSetDirty(opt, stub)) {\n            stub.dirty();\n            overallNeedDirty_1 = true;\n          }\n        });\n        overallNeedDirty_1 && overallTask.dirty();\n        scheduler.updatePayload(overallTask, payload);\n        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);\n        // Execute stubs firstly, which may set the overall task dirty,\n        // then execute the overall task. And stub will call seriesModel.setData,\n        // which ensures that in the overallTask seriesModel.getData() will not\n        // return incorrect data.\n        agentStubMap.each(function (stub) {\n          stub.perform(performArgs_1);\n        });\n        if (overallTask.perform(performArgs_1)) {\n          unfinished = true;\n        }\n      } else if (seriesTaskMap) {\n        seriesTaskMap.each(function (task, pipelineId) {\n          if (needSetDirty(opt, task)) {\n            task.dirty();\n          }\n          var performArgs = scheduler.getPerformArgs(task, opt.block);\n          // FIXME\n          // if intending to declare `performRawSeries` in handlers, only\n          // stream-independent (specifically, data item independent) operations can be\n          // performed. Because if a series is filtered, most of the tasks will not\n          // be performed. A stream-dependent operation probably cause wrong biz logic.\n          // Perhaps we should not provide a separate callback for this case instead\n          // of providing the config `performRawSeries`. The stream-dependent operations\n          // and stream-independent operations should better not be mixed.\n          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n          scheduler.updatePayload(task, payload);\n          if (task.perform(performArgs)) {\n            unfinished = true;\n          }\n        });\n      }\n    });\n    function needSetDirty(opt, task) {\n      return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n    }\n    this.unfinished = unfinished || this.unfinished;\n  };\n  Scheduler.prototype.performSeriesTasks = function (ecModel) {\n    var unfinished;\n    ecModel.eachSeries(function (seriesModel) {\n      // Progress to the end for dataInit and dataRestore.\n      unfinished = seriesModel.dataTask.perform() || unfinished;\n    });\n    this.unfinished = unfinished || this.unfinished;\n  };\n  Scheduler.prototype.plan = function () {\n    // Travel pipelines, check block.\n    this._pipelineMap.each(function (pipeline) {\n      var task = pipeline.tail;\n      do {\n        if (task.__block) {\n          pipeline.blockIndex = task.__idxInPipeline;\n          break;\n        }\n        task = task.getUpstream();\n      } while (task);\n    });\n  };\n  Scheduler.prototype.updatePayload = function (task, payload) {\n    payload !== 'remain' && (task.context.payload = payload);\n  };\n  Scheduler.prototype._createSeriesStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;\n    // The count of stages are totally about only several dozen, so\n    // do not need to reuse the map.\n    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = (0,util.createHashMap)();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries;\n    // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,\n    // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,\n    // it works but it may cause other irrelevant charts blocked.\n    if (stageHandler.createOnAllSeries) {\n      ecModel.eachRawSeries(create);\n    } else if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, create);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(create);\n    }\n    function create(seriesModel) {\n      var pipelineId = seriesModel.uid;\n      // Init tasks for each seriesModel only once.\n      // Reuse original task instance.\n      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || (0,core_task/* createTask */.U)({\n        plan: seriesTaskPlan,\n        reset: seriesTaskReset,\n        count: seriesTaskCount\n      }));\n      task.context = {\n        model: seriesModel,\n        ecModel: ecModel,\n        api: api,\n        // PENDING: `useClearVisual` not used?\n        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n        plan: stageHandler.plan,\n        reset: stageHandler.reset,\n        scheduler: scheduler\n      };\n      scheduler._pipe(seriesModel, task);\n    }\n  };\n  Scheduler.prototype._createOverallStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask\n    // For overall task, the function only be called on reset stage.\n    || (0,core_task/* createTask */.U)({\n      reset: overallTaskReset\n    });\n    overallTask.context = {\n      ecModel: ecModel,\n      api: api,\n      overallReset: stageHandler.overallReset,\n      scheduler: scheduler\n    };\n    var oldAgentStubMap = overallTask.agentStubMap;\n    // The count of stages are totally about only several dozen, so\n    // do not need to reuse the map.\n    var newAgentStubMap = overallTask.agentStubMap = (0,util.createHashMap)();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries;\n    var overallProgress = true;\n    var shouldOverallTaskDirty = false;\n    // FIXME:TS never used, so comment it\n    // let modifyOutputEnd = stageHandler.modifyOutputEnd;\n    // An overall task with seriesType detected or has `getTargetSeries`, we add\n    // stub in each pipelines, it will set the overall task dirty when the pipeline\n    // progress. Moreover, to avoid call the overall task each frame (too frequent),\n    // we set the pipeline block.\n    var errMsg = '';\n    if (false) {}\n    (0,util.assert)(!stageHandler.createOnAllSeries, errMsg);\n    if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, createStub);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(createStub);\n    }\n    // Otherwise, (usually it is legacy case), the overall task will only be\n    // executed when upstream is dirty. Otherwise the progressive rendering of all\n    // pipelines will be disabled unexpectedly. But it still needs stubs to receive\n    // dirty info from upstream.\n    else {\n      overallProgress = false;\n      (0,util.each)(ecModel.getSeries(), createStub);\n    }\n    function createStub(seriesModel) {\n      var pipelineId = seriesModel.uid;\n      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (\n      // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n      shouldOverallTaskDirty = true, (0,core_task/* createTask */.U)({\n        reset: stubReset,\n        onDirty: stubOnDirty\n      })));\n      stub.context = {\n        model: seriesModel,\n        overallProgress: overallProgress\n        // FIXME:TS never used, so comment it\n        // modifyOutputEnd: modifyOutputEnd\n      };\n      stub.agent = overallTask;\n      stub.__block = overallProgress;\n      scheduler._pipe(seriesModel, stub);\n    }\n    if (shouldOverallTaskDirty) {\n      overallTask.dirty();\n    }\n  };\n  Scheduler.prototype._pipe = function (seriesModel, task) {\n    var pipelineId = seriesModel.uid;\n    var pipeline = this._pipelineMap.get(pipelineId);\n    !pipeline.head && (pipeline.head = task);\n    pipeline.tail && pipeline.tail.pipe(task);\n    pipeline.tail = task;\n    task.__idxInPipeline = pipeline.count++;\n    task.__pipeline = pipeline;\n  };\n  Scheduler.wrapStageHandler = function (stageHandler, visualType) {\n    if ((0,util.isFunction)(stageHandler)) {\n      stageHandler = {\n        overallReset: stageHandler,\n        seriesType: detectSeriseType(stageHandler)\n      };\n    }\n    stageHandler.uid = (0,component/* getUID */.$Q)('stageHandler');\n    visualType && (stageHandler.visualType = visualType);\n    return stageHandler;\n  };\n  ;\n  return Scheduler;\n}();\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\nfunction stubReset(context) {\n  return context.overallProgress && stubProgress;\n}\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\nfunction seriesTaskPlan(context) {\n  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;\n}\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n  var resetDefines = context.resetDefines = (0,model/* normalizeToArray */.qB)(context.reset(context.model, context.ecModel, context.api, context.payload));\n  return resetDefines.length > 1 ? (0,util.map)(resetDefines, function (v, idx) {\n    return makeSeriesTaskProgress(idx);\n  }) : singleSeriesTaskProgress;\n}\nvar singleSeriesTaskProgress = makeSeriesTaskProgress(0);\nfunction makeSeriesTaskProgress(resetDefineIdx) {\n  return function (params, context) {\n    var data = context.data;\n    var resetDefine = context.resetDefines[resetDefineIdx];\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  };\n}\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\n/**\r\n * Only some legacy stage handlers (usually in echarts extensions) are pure function.\r\n * To ensure that they can work normally, they should work in block mode, that is,\r\n * they should not be started util the previous tasks finished. So they cause the\r\n * progressive rendering disabled. We try to detect the series type, to narrow down\r\n * the block range to only the series type they concern, but not all series.\r\n */\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n  try {\n    // Assume there is no async when calling `eachSeriesByType`.\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n  return seriesType;\n}\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, Global/* default */.A);\nmockMethods(apiMock, core_ExtensionAPI);\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\nfunction mockMethods(target, Clz) {\n  /* eslint-disable */\n  for (var name_1 in Clz.prototype) {\n    // Do not use hasOwnProperty\n    target[name_1] = util.noop;\n  }\n  /* eslint-enable */\n}\n/* harmony default export */ const core_Scheduler = (Scheduler);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/theme/light.js\nvar light = __webpack_require__(412);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/theme/dark.js\nvar dark = __webpack_require__(47006);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/clazz.js\nvar clazz = __webpack_require__(30693);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/ECEventProcessor.js\nvar ECEventProcessor = __webpack_require__(81075);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/symbol.js\nvar symbol = __webpack_require__(58287);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/helper.js\nvar helper = __webpack_require__(37395);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/log.js\nvar log = __webpack_require__(41025);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/legacy/dataSelectAction.js\nvar dataSelectAction = __webpack_require__(16884);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/transform.js\nvar transform = __webpack_require__(17752);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/core/locale.js\nvar locale = __webpack_require__(53080);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/event.js\nvar util_event = __webpack_require__(47411);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/decal.js\nvar decal = __webpack_require__(56970);\n;// ./node_modules/echarts/lib/core/lifecycle.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n;\nvar lifecycle = new Eventful/* default */.A();\n/* harmony default export */ const core_lifecycle = (lifecycle);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/platform.js\nvar platform = __webpack_require__(59741);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/core/impl.js\nvar impl = __webpack_require__(13976);\n;// ./node_modules/echarts/lib/core/echarts.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar version = '5.6.0';\nvar dependencies = {\n  zrender: '5.6.1'\n};\nvar TEST_FRAME_REMAIN_TIME = 1;\nvar PRIORITY_PROCESSOR_SERIES_FILTER = 800;\n// Some data processors depends on the stack result dimension (to calculate data extent).\n// So data stack stage should be in front of data processing stage.\nvar PRIORITY_PROCESSOR_DATASTACK = 900;\n// \"Data filter\" will block the stream, so it should be\n// put at the beginning of data processing.\nvar PRIORITY_PROCESSOR_FILTER = 1000;\nvar PRIORITY_PROCESSOR_DEFAULT = 2000;\nvar PRIORITY_PROCESSOR_STATISTIC = 5000;\nvar PRIORITY_VISUAL_LAYOUT = 1000;\nvar PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;\nvar PRIORITY_VISUAL_GLOBAL = 2000;\nvar PRIORITY_VISUAL_CHART = 3000;\nvar PRIORITY_VISUAL_COMPONENT = 4000;\n// Visual property in data. Greater than `PRIORITY_VISUAL_COMPONENT` to enable to\n// overwrite the viusal result of component (like `visualMap`)\n// using data item specific setting (like itemStyle.xxx on data item)\nvar PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;\n// Greater than `PRIORITY_VISUAL_CHART_DATA_CUSTOM` to enable to layout based on\n// visual result like `symbolSize`.\nvar PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;\nvar PRIORITY_VISUAL_BRUSH = 5000;\nvar PRIORITY_VISUAL_ARIA = 6000;\nvar PRIORITY_VISUAL_DECAL = 7000;\nvar PRIORITY = {\n  PROCESSOR: {\n    FILTER: PRIORITY_PROCESSOR_FILTER,\n    SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,\n    STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n  },\n  VISUAL: {\n    LAYOUT: PRIORITY_VISUAL_LAYOUT,\n    PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,\n    GLOBAL: PRIORITY_VISUAL_GLOBAL,\n    CHART: PRIORITY_VISUAL_CHART,\n    POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,\n    COMPONENT: PRIORITY_VISUAL_COMPONENT,\n    BRUSH: PRIORITY_VISUAL_BRUSH,\n    CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,\n    ARIA: PRIORITY_VISUAL_ARIA,\n    DECAL: PRIORITY_VISUAL_DECAL\n  }\n};\n// Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n// where they must not be invoked nestedly, except the only case: invoke\n// dispatchAction with updateMethod \"none\" in main process.\n// This flag is used to carry out this rule.\n// All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\nvar IN_MAIN_PROCESS_KEY = '__flagInMainProcess';\nvar PENDING_UPDATE = '__pendingUpdate';\nvar STATUS_NEEDS_UPDATE_KEY = '__needsUpdateStatus';\nvar ACTION_REG = /^[a-zA-Z0-9_]+$/;\nvar CONNECT_STATUS_KEY = '__connectUpdateStatus';\nvar CONNECT_STATUS_PENDING = 0;\nvar CONNECT_STATUS_UPDATING = 1;\nvar CONNECT_STATUS_UPDATED = 2;\n;\n;\nfunction createRegisterEventWithLowercaseECharts(method) {\n  return function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (this.isDisposed()) {\n      disposedWarning(this.id);\n      return;\n    }\n    return toLowercaseNameAndCallEventful(this, method, args);\n  };\n}\nfunction createRegisterEventWithLowercaseMessageCenter(method) {\n  return function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return toLowercaseNameAndCallEventful(this, method, args);\n  };\n}\nfunction toLowercaseNameAndCallEventful(host, method, args) {\n  // `args[0]` is event name. Event name is all lowercase.\n  args[0] = args[0] && args[0].toLowerCase();\n  return Eventful/* default */.A.prototype[method].apply(host, args);\n}\nvar MessageCenter = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(MessageCenter, _super);\n  function MessageCenter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  return MessageCenter;\n}(Eventful/* default */.A);\nvar messageCenterProto = MessageCenter.prototype;\nmessageCenterProto.on = createRegisterEventWithLowercaseMessageCenter('on');\nmessageCenterProto.off = createRegisterEventWithLowercaseMessageCenter('off');\n// ---------------------------------------\n// Internal method names for class ECharts\n// ---------------------------------------\nvar prepare;\nvar prepareView;\nvar updateDirectly;\nvar updateMethods;\nvar doConvertPixel;\nvar updateStreamModes;\nvar doDispatchAction;\nvar flushPendingActions;\nvar triggerUpdatedEvent;\nvar bindRenderedEvent;\nvar bindMouseEvent;\nvar render;\nvar renderComponents;\nvar renderSeries;\nvar createExtensionAPI;\nvar enableConnect;\nvar markStatusToUpdate;\nvar applyChangedStates;\nvar ECharts = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ECharts, _super);\n  function ECharts(dom,\n  // Theme name or themeOption.\n  theme, opts) {\n    var _this = _super.call(this, new ECEventProcessor/* ECEventProcessor */.d()) || this;\n    _this._chartsViews = [];\n    _this._chartsMap = {};\n    _this._componentsViews = [];\n    _this._componentsMap = {};\n    // Can't dispatch action during rendering procedure\n    _this._pendingActions = [];\n    opts = opts || {};\n    // Get theme by name\n    if ((0,util.isString)(theme)) {\n      theme = themeStorage[theme];\n    }\n    _this._dom = dom;\n    var defaultRenderer = 'canvas';\n    var defaultCoarsePointer = 'auto';\n    var defaultUseDirtyRect = false;\n    if (false) { var root; }\n    if (opts.ssr) {\n      zrender.registerSSRDataGetter(function (el) {\n        var ecData = (0,innerStore/* getECData */.z)(el);\n        var dataIndex = ecData.dataIndex;\n        if (dataIndex == null) {\n          return;\n        }\n        var hashMap = (0,util.createHashMap)();\n        hashMap.set('series_index', ecData.seriesIndex);\n        hashMap.set('data_index', dataIndex);\n        ecData.ssrType && hashMap.set('ssr_type', ecData.ssrType);\n        return hashMap;\n      });\n    }\n    var zr = _this._zr = zrender.init(dom, {\n      renderer: opts.renderer || defaultRenderer,\n      devicePixelRatio: opts.devicePixelRatio,\n      width: opts.width,\n      height: opts.height,\n      ssr: opts.ssr,\n      useDirtyRect: (0,util.retrieve2)(opts.useDirtyRect, defaultUseDirtyRect),\n      useCoarsePointer: (0,util.retrieve2)(opts.useCoarsePointer, defaultCoarsePointer),\n      pointerSize: opts.pointerSize\n    });\n    _this._ssr = opts.ssr;\n    // Expect 60 fps.\n    _this._throttledZrFlush = (0,throttle/* throttle */.nF)((0,util.bind)(zr.flush, zr), 17);\n    theme = (0,util.clone)(theme);\n    theme && (0,backwardCompat/* default */.A)(theme, true);\n    _this._theme = theme;\n    _this._locale = (0,locale/* createLocaleObject */.A$)(opts.locale || locale/* SYSTEM_LANG */.Lv);\n    _this._coordSysMgr = new CoordinateSystem/* default */.A();\n    var api = _this._api = createExtensionAPI(_this);\n    // Sort on demand\n    function prioritySortFunc(a, b) {\n      return a.__prio - b.__prio;\n    }\n    (0,timsort/* default */.A)(visualFuncs, prioritySortFunc);\n    (0,timsort/* default */.A)(dataProcessorFuncs, prioritySortFunc);\n    _this._scheduler = new core_Scheduler(_this, api, dataProcessorFuncs, visualFuncs);\n    _this._messageCenter = new MessageCenter();\n    // Init mouse events\n    _this._initEvents();\n    // In case some people write `window.onresize = chart.resize`\n    _this.resize = (0,util.bind)(_this.resize, _this);\n    zr.animation.on('frame', _this._onframe, _this);\n    bindRenderedEvent(zr, _this);\n    bindMouseEvent(zr, _this);\n    // ECharts instance can be used as value.\n    (0,util.setAsPrimitive)(_this);\n    return _this;\n  }\n  ECharts.prototype._onframe = function () {\n    if (this._disposed) {\n      return;\n    }\n    applyChangedStates(this);\n    var scheduler = this._scheduler;\n    // Lazy update\n    if (this[PENDING_UPDATE]) {\n      var silent = this[PENDING_UPDATE].silent;\n      this[IN_MAIN_PROCESS_KEY] = true;\n      try {\n        prepare(this);\n        updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);\n      } catch (e) {\n        this[IN_MAIN_PROCESS_KEY] = false;\n        this[PENDING_UPDATE] = null;\n        throw e;\n      }\n      // At present, in each frame, zrender performs:\n      //   (1) animation step forward.\n      //   (2) trigger('frame') (where this `_onframe` is called)\n      //   (3) zrender flush (render).\n      // If we do nothing here, since we use `setToFinal: true`, the step (3) above\n      // will render the final state of the elements before the real animation started.\n      this._zr.flush();\n      this[IN_MAIN_PROCESS_KEY] = false;\n      this[PENDING_UPDATE] = null;\n      flushPendingActions.call(this, silent);\n      triggerUpdatedEvent.call(this, silent);\n    }\n    // Avoid do both lazy update and progress in one frame.\n    else if (scheduler.unfinished) {\n      // Stream progress.\n      var remainTime = TEST_FRAME_REMAIN_TIME;\n      var ecModel = this._model;\n      var api = this._api;\n      scheduler.unfinished = false;\n      do {\n        var startTime = +new Date();\n        scheduler.performSeriesTasks(ecModel);\n        // Currently dataProcessorFuncs do not check threshold.\n        scheduler.performDataProcessorTasks(ecModel);\n        updateStreamModes(this, ecModel);\n        // Do not update coordinate system here. Because that coord system update in\n        // each frame is not a good user experience. So we follow the rule that\n        // the extent of the coordinate system is determined in the first frame (the\n        // frame is executed immediately after task reset.\n        // this._coordSysMgr.update(ecModel, api);\n        // console.log('--- ec frame visual ---', remainTime);\n        scheduler.performVisualTasks(ecModel);\n        renderSeries(this, this._model, api, 'remain', {});\n        remainTime -= +new Date() - startTime;\n      } while (remainTime > 0 && scheduler.unfinished);\n      // Call flush explicitly for trigger finished event.\n      if (!scheduler.unfinished) {\n        this._zr.flush();\n      }\n      // Else, zr flushing be ensue within the same frame,\n      // because zr flushing is after onframe event.\n    }\n  };\n  ECharts.prototype.getDom = function () {\n    return this._dom;\n  };\n  ECharts.prototype.getId = function () {\n    return this.id;\n  };\n  ECharts.prototype.getZr = function () {\n    return this._zr;\n  };\n  ECharts.prototype.isSSR = function () {\n    return this._ssr;\n  };\n  /* eslint-disable-next-line */\n  ECharts.prototype.setOption = function (option, notMerge, lazyUpdate) {\n    if (this[IN_MAIN_PROCESS_KEY]) {\n      if (false) {}\n      return;\n    }\n    if (this._disposed) {\n      disposedWarning(this.id);\n      return;\n    }\n    var silent;\n    var replaceMerge;\n    var transitionOpt;\n    if ((0,util.isObject)(notMerge)) {\n      lazyUpdate = notMerge.lazyUpdate;\n      silent = notMerge.silent;\n      replaceMerge = notMerge.replaceMerge;\n      transitionOpt = notMerge.transition;\n      notMerge = notMerge.notMerge;\n    }\n    this[IN_MAIN_PROCESS_KEY] = true;\n    if (!this._model || notMerge) {\n      var optionManager = new OptionManager/* default */.A(this._api);\n      var theme = this._theme;\n      var ecModel = this._model = new Global/* default */.A();\n      ecModel.scheduler = this._scheduler;\n      ecModel.ssr = this._ssr;\n      ecModel.init(null, null, null, theme, this._locale, optionManager);\n    }\n    this._model.setOption(option, {\n      replaceMerge: replaceMerge\n    }, optionPreprocessorFuncs);\n    var updateParams = {\n      seriesTransition: transitionOpt,\n      optionChanged: true\n    };\n    if (lazyUpdate) {\n      this[PENDING_UPDATE] = {\n        silent: silent,\n        updateParams: updateParams\n      };\n      this[IN_MAIN_PROCESS_KEY] = false;\n      // `setOption(option, {lazyMode: true})` may be called when zrender has been slept.\n      // It should wake it up to make sure zrender start to render at the next frame.\n      this.getZr().wakeUp();\n    } else {\n      try {\n        prepare(this);\n        updateMethods.update.call(this, null, updateParams);\n      } catch (e) {\n        this[PENDING_UPDATE] = null;\n        this[IN_MAIN_PROCESS_KEY] = false;\n        throw e;\n      }\n      // Ensure zr refresh sychronously, and then pixel in canvas can be\n      // fetched after `setOption`.\n      if (!this._ssr) {\n        // not use flush when using ssr mode.\n        this._zr.flush();\n      }\n      this[PENDING_UPDATE] = null;\n      this[IN_MAIN_PROCESS_KEY] = false;\n      flushPendingActions.call(this, silent);\n      triggerUpdatedEvent.call(this, silent);\n    }\n  };\n  /**\r\n   * @deprecated\r\n   */\n  ECharts.prototype.setTheme = function () {\n    (0,log/* deprecateLog */.aT)('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n  };\n  // We don't want developers to use getModel directly.\n  ECharts.prototype.getModel = function () {\n    return this._model;\n  };\n  ECharts.prototype.getOption = function () {\n    return this._model && this._model.getOption();\n  };\n  ECharts.prototype.getWidth = function () {\n    return this._zr.getWidth();\n  };\n  ECharts.prototype.getHeight = function () {\n    return this._zr.getHeight();\n  };\n  ECharts.prototype.getDevicePixelRatio = function () {\n    return this._zr.painter.dpr\n    /* eslint-disable-next-line */ || env/* default */.A.hasGlobalWindow && window.devicePixelRatio || 1;\n  };\n  /**\r\n   * Get canvas which has all thing rendered\r\n   * @deprecated Use renderToCanvas instead.\r\n   */\n  ECharts.prototype.getRenderedCanvas = function (opts) {\n    if (false) {}\n    return this.renderToCanvas(opts);\n  };\n  ECharts.prototype.renderToCanvas = function (opts) {\n    opts = opts || {};\n    var painter = this._zr.painter;\n    if (false) {}\n    return painter.getRenderedCanvas({\n      backgroundColor: opts.backgroundColor || this._model.get('backgroundColor'),\n      pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()\n    });\n  };\n  ECharts.prototype.renderToSVGString = function (opts) {\n    opts = opts || {};\n    var painter = this._zr.painter;\n    if (false) {}\n    return painter.renderToString({\n      useViewBox: opts.useViewBox\n    });\n  };\n  /**\r\n   * Get svg data url\r\n   */\n  ECharts.prototype.getSvgDataURL = function () {\n    if (!env/* default */.A.svgSupported) {\n      return;\n    }\n    var zr = this._zr;\n    var list = zr.storage.getDisplayList();\n    // Stop animations\n    (0,util.each)(list, function (el) {\n      el.stopAnimation(null, true);\n    });\n    return zr.painter.toDataURL();\n  };\n  ECharts.prototype.getDataURL = function (opts) {\n    if (this._disposed) {\n      disposedWarning(this.id);\n      return;\n    }\n    opts = opts || {};\n    var excludeComponents = opts.excludeComponents;\n    var ecModel = this._model;\n    var excludesComponentViews = [];\n    var self = this;\n    (0,util.each)(excludeComponents, function (componentType) {\n      ecModel.eachComponent({\n        mainType: componentType\n      }, function (component) {\n        var view = self._componentsMap[component.__viewId];\n        if (!view.group.ignore) {\n          excludesComponentViews.push(view);\n          view.group.ignore = true;\n        }\n      });\n    });\n    var url = this._zr.painter.getType() === 'svg' ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));\n    (0,util.each)(excludesComponentViews, function (view) {\n      view.group.ignore = false;\n    });\n    return url;\n  };\n  ECharts.prototype.getConnectedDataURL = function (opts) {\n    if (this._disposed) {\n      disposedWarning(this.id);\n      return;\n    }\n    var isSvg = opts.type === 'svg';\n    var groupId = this.group;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var MAX_NUMBER = Infinity;\n    if (connectedGroups[groupId]) {\n      var left_1 = MAX_NUMBER;\n      var top_1 = MAX_NUMBER;\n      var right_1 = -MAX_NUMBER;\n      var bottom_1 = -MAX_NUMBER;\n      var canvasList_1 = [];\n      var dpr_1 = opts && opts.pixelRatio || this.getDevicePixelRatio();\n      (0,util.each)(instances, function (chart, id) {\n        if (chart.group === groupId) {\n          var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas((0,util.clone)(opts));\n          var boundingRect = chart.getDom().getBoundingClientRect();\n          left_1 = mathMin(boundingRect.left, left_1);\n          top_1 = mathMin(boundingRect.top, top_1);\n          right_1 = mathMax(boundingRect.right, right_1);\n          bottom_1 = mathMax(boundingRect.bottom, bottom_1);\n          canvasList_1.push({\n            dom: canvas,\n            left: boundingRect.left,\n            top: boundingRect.top\n          });\n        }\n      });\n      left_1 *= dpr_1;\n      top_1 *= dpr_1;\n      right_1 *= dpr_1;\n      bottom_1 *= dpr_1;\n      var width = right_1 - left_1;\n      var height = bottom_1 - top_1;\n      var targetCanvas = platform/* platformApi */.yh.createCanvas();\n      var zr_1 = zrender.init(targetCanvas, {\n        renderer: isSvg ? 'svg' : 'canvas'\n      });\n      zr_1.resize({\n        width: width,\n        height: height\n      });\n      if (isSvg) {\n        var content_1 = '';\n        (0,util.each)(canvasList_1, function (item) {\n          var x = item.left - left_1;\n          var y = item.top - top_1;\n          content_1 += '<g transform=\"translate(' + x + ',' + y + ')\">' + item.dom + '</g>';\n        });\n        zr_1.painter.getSvgRoot().innerHTML = content_1;\n        if (opts.connectedBackgroundColor) {\n          zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor);\n        }\n        zr_1.refreshImmediately();\n        return zr_1.painter.toDataURL();\n      } else {\n        // Background between the charts\n        if (opts.connectedBackgroundColor) {\n          zr_1.add(new Rect/* default */.A({\n            shape: {\n              x: 0,\n              y: 0,\n              width: width,\n              height: height\n            },\n            style: {\n              fill: opts.connectedBackgroundColor\n            }\n          }));\n        }\n        (0,util.each)(canvasList_1, function (item) {\n          var img = new Image/* default */.Ay({\n            style: {\n              x: item.left * dpr_1 - left_1,\n              y: item.top * dpr_1 - top_1,\n              image: item.dom\n            }\n          });\n          zr_1.add(img);\n        });\n        zr_1.refreshImmediately();\n        return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n      }\n    } else {\n      return this.getDataURL(opts);\n    }\n  };\n  ECharts.prototype.convertToPixel = function (finder, value) {\n    return doConvertPixel(this, 'convertToPixel', finder, value);\n  };\n  ECharts.prototype.convertFromPixel = function (finder, value) {\n    return doConvertPixel(this, 'convertFromPixel', finder, value);\n  };\n  /**\r\n   * Is the specified coordinate systems or components contain the given pixel point.\r\n   * @param {Array|number} value\r\n   * @return {boolean} result\r\n   */\n  ECharts.prototype.containPixel = function (finder, value) {\n    if (this._disposed) {\n      disposedWarning(this.id);\n      return;\n    }\n    var ecModel = this._model;\n    var result;\n    var findResult = model/* parseFinder */._e(ecModel, finder);\n    (0,util.each)(findResult, function (models, key) {\n      key.indexOf('Models') >= 0 && (0,util.each)(models, function (model) {\n        var coordSys = model.coordinateSystem;\n        if (coordSys && coordSys.containPoint) {\n          result = result || !!coordSys.containPoint(value);\n        } else if (key === 'seriesModels') {\n          var view = this._chartsMap[model.__viewId];\n          if (view && view.containPoint) {\n            result = result || view.containPoint(value, model);\n          } else {\n            if (false) {}\n          }\n        } else {\n          if (false) {}\n        }\n      }, this);\n    }, this);\n    return !!result;\n  };\n  /**\r\n   * Get visual from series or data.\r\n   * @param finder\r\n   *        If string, e.g., 'series', means {seriesIndex: 0}.\r\n   *        If Object, could contain some of these properties below:\r\n   *        {\r\n   *            seriesIndex / seriesId / seriesName,\r\n   *            dataIndex / dataIndexInside\r\n   *        }\r\n   *        If dataIndex is not specified, series visual will be fetched,\r\n   *        but not data item visual.\r\n   *        If all of seriesIndex, seriesId, seriesName are not specified,\r\n   *        visual will be fetched from first series.\r\n   * @param visualType 'color', 'symbol', 'symbolSize'\r\n   */\n  ECharts.prototype.getVisual = function (finder, visualType) {\n    var ecModel = this._model;\n    var parsedFinder = model/* parseFinder */._e(ecModel, finder, {\n      defaultMainType: 'series'\n    });\n    var seriesModel = parsedFinder.seriesModel;\n    if (false) {}\n    var data = seriesModel.getData();\n    var dataIndexInside = parsedFinder.hasOwnProperty('dataIndexInside') ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;\n    return dataIndexInside != null ? (0,helper/* getItemVisualFromData */.Ez)(data, dataIndexInside, visualType) : (0,helper/* getVisualFromData */.rI)(data, visualType);\n  };\n  /**\r\n   * Get view of corresponding component model\r\n   */\n  ECharts.prototype.getViewOfComponentModel = function (componentModel) {\n    return this._componentsMap[componentModel.__viewId];\n  };\n  /**\r\n   * Get view of corresponding series model\r\n   */\n  ECharts.prototype.getViewOfSeriesModel = function (seriesModel) {\n    return this._chartsMap[seriesModel.__viewId];\n  };\n  ECharts.prototype._initEvents = function () {\n    var _this = this;\n    (0,util.each)(MOUSE_EVENT_NAMES, function (eveName) {\n      var handler = function (e) {\n        var ecModel = _this.getModel();\n        var el = e.target;\n        var params;\n        var isGlobalOut = eveName === 'globalout';\n        // no e.target when 'globalout'.\n        if (isGlobalOut) {\n          params = {};\n        } else {\n          el && (0,util_event/* findEventDispatcher */.R)(el, function (parent) {\n            var ecData = (0,innerStore/* getECData */.z)(parent);\n            if (ecData && ecData.dataIndex != null) {\n              var dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);\n              params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType, el) || {};\n              return true;\n            }\n            // If element has custom eventData of components\n            else if (ecData.eventData) {\n              params = (0,util.extend)({}, ecData.eventData);\n              return true;\n            }\n          }, true);\n        }\n        // Contract: if params prepared in mouse event,\n        // these properties must be specified:\n        // {\n        //    componentType: string (component main type)\n        //    componentIndex: number\n        // }\n        // Otherwise event query can not work.\n        if (params) {\n          var componentType = params.componentType;\n          var componentIndex = params.componentIndex;\n          // Special handling for historic reason: when trigger by\n          // markLine/markPoint/markArea, the componentType is\n          // 'markLine'/'markPoint'/'markArea', but we should better\n          // enable them to be queried by seriesIndex, since their\n          // option is set in each series.\n          if (componentType === 'markLine' || componentType === 'markPoint' || componentType === 'markArea') {\n            componentType = 'series';\n            componentIndex = params.seriesIndex;\n          }\n          var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);\n          var view = model && _this[model.mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId];\n          if (false) {}\n          params.event = e;\n          params.type = eveName;\n          _this._$eventProcessor.eventInfo = {\n            targetEl: el,\n            packedEvent: params,\n            model: model,\n            view: view\n          };\n          _this.trigger(eveName, params);\n        }\n      };\n      // Consider that some component (like tooltip, brush, ...)\n      // register zr event handler, but user event handler might\n      // do anything, such as call `setOption` or `dispatchAction`,\n      // which probably update any of the content and probably\n      // cause problem if it is called previous other inner handlers.\n      handler.zrEventfulCallAtLast = true;\n      _this._zr.on(eveName, handler, _this);\n    });\n    (0,util.each)(eventActionMap, function (actionType, eventType) {\n      _this._messageCenter.on(eventType, function (event) {\n        this.trigger(eventType, event);\n      }, _this);\n    });\n    // Extra events\n    // TODO register?\n    (0,util.each)(['selectchanged'], function (eventType) {\n      _this._messageCenter.on(eventType, function (event) {\n        this.trigger(eventType, event);\n      }, _this);\n    });\n    (0,dataSelectAction/* handleLegacySelectEvents */.l)(this._messageCenter, this, this._api);\n  };\n  ECharts.prototype.isDisposed = function () {\n    return this._disposed;\n  };\n  ECharts.prototype.clear = function () {\n    if (this._disposed) {\n      disposedWarning(this.id);\n      return;\n    }\n    this.setOption({\n      series: []\n    }, true);\n  };\n  ECharts.prototype.dispose = function () {\n    if (this._disposed) {\n      disposedWarning(this.id);\n      return;\n    }\n    this._disposed = true;\n    var dom = this.getDom();\n    if (dom) {\n      model/* setAttribute */.Bq(this.getDom(), DOM_ATTRIBUTE_KEY, '');\n    }\n    var chart = this;\n    var api = chart._api;\n    var ecModel = chart._model;\n    (0,util.each)(chart._componentsViews, function (component) {\n      component.dispose(ecModel, api);\n    });\n    (0,util.each)(chart._chartsViews, function (chart) {\n      chart.dispose(ecModel, api);\n    });\n    // Dispose after all views disposed\n    chart._zr.dispose();\n    // Set properties to null.\n    // To reduce the memory cost in case the top code still holds this instance unexpectedly.\n    chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null;\n    delete instances[chart.id];\n  };\n  /**\r\n   * Resize the chart\r\n   */\n  ECharts.prototype.resize = function (opts) {\n    if (this[IN_MAIN_PROCESS_KEY]) {\n      if (false) {}\n      return;\n    }\n    if (this._disposed) {\n      disposedWarning(this.id);\n      return;\n    }\n    this._zr.resize(opts);\n    var ecModel = this._model;\n    // Resize loading effect\n    this._loadingFX && this._loadingFX.resize();\n    if (!ecModel) {\n      return;\n    }\n    var needPrepare = ecModel.resetOption('media');\n    var silent = opts && opts.silent;\n    // There is some real cases that:\n    // chart.setOption(option, { lazyUpdate: true });\n    // chart.resize();\n    if (this[PENDING_UPDATE]) {\n      if (silent == null) {\n        silent = this[PENDING_UPDATE].silent;\n      }\n      needPrepare = true;\n      this[PENDING_UPDATE] = null;\n    }\n    this[IN_MAIN_PROCESS_KEY] = true;\n    try {\n      needPrepare && prepare(this);\n      updateMethods.update.call(this, {\n        type: 'resize',\n        animation: (0,util.extend)({\n          // Disable animation\n          duration: 0\n        }, opts && opts.animation)\n      });\n    } catch (e) {\n      this[IN_MAIN_PROCESS_KEY] = false;\n      throw e;\n    }\n    this[IN_MAIN_PROCESS_KEY] = false;\n    flushPendingActions.call(this, silent);\n    triggerUpdatedEvent.call(this, silent);\n  };\n  ECharts.prototype.showLoading = function (name, cfg) {\n    if (this._disposed) {\n      disposedWarning(this.id);\n      return;\n    }\n    if ((0,util.isObject)(name)) {\n      cfg = name;\n      name = '';\n    }\n    name = name || 'default';\n    this.hideLoading();\n    if (!loadingEffects[name]) {\n      if (false) {}\n      return;\n    }\n    var el = loadingEffects[name](this._api, cfg);\n    var zr = this._zr;\n    this._loadingFX = el;\n    zr.add(el);\n  };\n  /**\r\n   * Hide loading effect\r\n   */\n  ECharts.prototype.hideLoading = function () {\n    if (this._disposed) {\n      disposedWarning(this.id);\n      return;\n    }\n    this._loadingFX && this._zr.remove(this._loadingFX);\n    this._loadingFX = null;\n  };\n  ECharts.prototype.makeActionFromEvent = function (eventObj) {\n    var payload = (0,util.extend)({}, eventObj);\n    payload.type = eventActionMap[eventObj.type];\n    return payload;\n  };\n  /**\r\n   * @param opt If pass boolean, means opt.silent\r\n   * @param opt.silent Default `false`. Whether trigger events.\r\n   * @param opt.flush Default `undefined`.\r\n   *        true: Flush immediately, and then pixel in canvas can be fetched\r\n   *            immediately. Caution: it might affect performance.\r\n   *        false: Not flush.\r\n   *        undefined: Auto decide whether perform flush.\r\n   */\n  ECharts.prototype.dispatchAction = function (payload, opt) {\n    if (this._disposed) {\n      disposedWarning(this.id);\n      return;\n    }\n    if (!(0,util.isObject)(opt)) {\n      opt = {\n        silent: !!opt\n      };\n    }\n    if (!actions[payload.type]) {\n      return;\n    }\n    // Avoid dispatch action before setOption. Especially in `connect`.\n    if (!this._model) {\n      return;\n    }\n    // May dispatchAction in rendering procedure\n    if (this[IN_MAIN_PROCESS_KEY]) {\n      this._pendingActions.push(payload);\n      return;\n    }\n    var silent = opt.silent;\n    doDispatchAction.call(this, payload, silent);\n    var flush = opt.flush;\n    if (flush) {\n      this._zr.flush();\n    } else if (flush !== false && env/* default */.A.browser.weChat) {\n      // In WeChat embedded browser, `requestAnimationFrame` and `setInterval`\n      // hang when sliding page (on touch event), which cause that zr does not\n      // refresh until user interaction finished, which is not expected.\n      // But `dispatchAction` may be called too frequently when pan on touch\n      // screen, which impacts performance if do not throttle them.\n      this._throttledZrFlush();\n    }\n    flushPendingActions.call(this, silent);\n    triggerUpdatedEvent.call(this, silent);\n  };\n  ECharts.prototype.updateLabelLayout = function () {\n    core_lifecycle.trigger('series:layoutlabels', this._model, this._api, {\n      // Not adding series labels.\n      // TODO\n      updatedSeries: []\n    });\n  };\n  ECharts.prototype.appendData = function (params) {\n    if (this._disposed) {\n      disposedWarning(this.id);\n      return;\n    }\n    var seriesIndex = params.seriesIndex;\n    var ecModel = this.getModel();\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n    if (false) {}\n    seriesModel.appendData(params);\n    // Note: `appendData` does not support that update extent of coordinate\n    // system, util some scenario require that. In the expected usage of\n    // `appendData`, the initial extent of coordinate system should better\n    // be fixed by axis `min`/`max` setting or initial data, otherwise if\n    // the extent changed while `appendData`, the location of the painted\n    // graphic elements have to be changed, which make the usage of\n    // `appendData` meaningless.\n    this._scheduler.unfinished = true;\n    this.getZr().wakeUp();\n  };\n  // A work around for no `internal` modifier in ts yet but\n  // need to strictly hide private methods to JS users.\n  ECharts.internalField = function () {\n    prepare = function (ecIns) {\n      var scheduler = ecIns._scheduler;\n      scheduler.restorePipelines(ecIns._model);\n      scheduler.prepareStageTasks();\n      prepareView(ecIns, true);\n      prepareView(ecIns, false);\n      scheduler.plan();\n    };\n    /**\r\n     * Prepare view instances of charts and components\r\n     */\n    prepareView = function (ecIns, isComponent) {\n      var ecModel = ecIns._model;\n      var scheduler = ecIns._scheduler;\n      var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;\n      var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;\n      var zr = ecIns._zr;\n      var api = ecIns._api;\n      for (var i = 0; i < viewList.length; i++) {\n        viewList[i].__alive = false;\n      }\n      isComponent ? ecModel.eachComponent(function (componentType, model) {\n        componentType !== 'series' && doPrepare(model);\n      }) : ecModel.eachSeries(doPrepare);\n      function doPrepare(model) {\n        // By default view will be reused if possible for the case that `setOption` with \"notMerge\"\n        // mode and need to enable transition animation. (Usually, when they have the same id, or\n        // especially no id but have the same type & name & index. See the `model.id` generation\n        // rule in `makeIdAndName` and `viewId` generation rule here).\n        // But in `replaceMerge` mode, this feature should be able to disabled when it is clear that\n        // the new model has nothing to do with the old model.\n        var requireNewView = model.__requireNewView;\n        // This command should not work twice.\n        model.__requireNewView = false;\n        // Consider: id same and type changed.\n        var viewId = '_ec_' + model.id + '_' + model.type;\n        var view = !requireNewView && viewMap[viewId];\n        if (!view) {\n          var classType = (0,clazz/* parseClassType */.CC)(model.type);\n          var Clazz = isComponent ? Component/* default */.A.getClass(classType.main, classType.sub) :\n          // FIXME:TS\n          // (ChartView as ChartViewConstructor).getClass('series', classType.sub)\n          // For backward compat, still support a chart type declared as only subType\n          // like \"liquidfill\", but recommend \"series.liquidfill\"\n          // But need a base class to make a type series.\n          Chart/* default */.A.getClass(classType.sub);\n          if (false) {}\n          view = new Clazz();\n          view.init(ecModel, api);\n          viewMap[viewId] = view;\n          viewList.push(view);\n          zr.add(view.group);\n        }\n        model.__viewId = view.__id = viewId;\n        view.__alive = true;\n        view.__model = model;\n        view.group.__ecComponentInfo = {\n          mainType: model.mainType,\n          index: model.componentIndex\n        };\n        !isComponent && scheduler.prepareView(view, model, ecModel, api);\n      }\n      for (var i = 0; i < viewList.length;) {\n        var view = viewList[i];\n        if (!view.__alive) {\n          !isComponent && view.renderTask.dispose();\n          zr.remove(view.group);\n          view.dispose(ecModel, api);\n          viewList.splice(i, 1);\n          if (viewMap[view.__id] === view) {\n            delete viewMap[view.__id];\n          }\n          view.__id = view.group.__ecComponentInfo = null;\n        } else {\n          i++;\n        }\n      }\n    };\n    updateDirectly = function (ecIns, method, payload, mainType, subType) {\n      var ecModel = ecIns._model;\n      ecModel.setUpdatePayload(payload);\n      // broadcast\n      if (!mainType) {\n        // FIXME\n        // Chart will not be update directly here, except set dirty.\n        // But there is no such scenario now.\n        (0,util.each)([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);\n        return;\n      }\n      var query = {};\n      query[mainType + 'Id'] = payload[mainType + 'Id'];\n      query[mainType + 'Index'] = payload[mainType + 'Index'];\n      query[mainType + 'Name'] = payload[mainType + 'Name'];\n      var condition = {\n        mainType: mainType,\n        query: query\n      };\n      subType && (condition.subType = subType); // subType may be '' by parseClassType;\n      var excludeSeriesId = payload.excludeSeriesId;\n      var excludeSeriesIdMap;\n      if (excludeSeriesId != null) {\n        excludeSeriesIdMap = (0,util.createHashMap)();\n        (0,util.each)(model/* normalizeToArray */.qB(excludeSeriesId), function (id) {\n          var modelId = model/* convertOptionIdName */.vS(id, null);\n          if (modelId != null) {\n            excludeSeriesIdMap.set(modelId, true);\n          }\n        });\n      }\n      // If dispatchAction before setOption, do nothing.\n      ecModel && ecModel.eachComponent(condition, function (model) {\n        var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null;\n        if (isExcluded) {\n          return;\n        }\n        ;\n        if ((0,states/* isHighDownPayload */.T$)(payload)) {\n          if (model instanceof Series/* default */.A) {\n            if (payload.type === states/* HIGHLIGHT_ACTION_TYPE */.h5 && !payload.notBlur && !model.get(['emphasis', 'disabled'])) {\n              (0,states/* blurSeriesFromHighlightPayload */.lV)(model, payload, ecIns._api);\n            }\n          } else {\n            var _a = (0,states/* findComponentHighDownDispatchers */.Tl)(model.mainType, model.componentIndex, payload.name, ecIns._api),\n              focusSelf = _a.focusSelf,\n              dispatchers = _a.dispatchers;\n            if (payload.type === states/* HIGHLIGHT_ACTION_TYPE */.h5 && focusSelf && !payload.notBlur) {\n              (0,states/* blurComponent */.Du)(model.mainType, model.componentIndex, ecIns._api);\n            }\n            // PENDING:\n            // Whether to put this \"enter emphasis\" code in `ComponentView`,\n            // which will be the same as `ChartView` but might be not necessary\n            // and will be far from this logic.\n            if (dispatchers) {\n              (0,util.each)(dispatchers, function (dispatcher) {\n                payload.type === states/* HIGHLIGHT_ACTION_TYPE */.h5 ? (0,states/* enterEmphasis */.HY)(dispatcher) : (0,states/* leaveEmphasis */.SD)(dispatcher);\n              });\n            }\n          }\n        } else if ((0,states/* isSelectChangePayload */.Lx)(payload)) {\n          // TODO geo\n          if (model instanceof Series/* default */.A) {\n            (0,states/* toggleSelectionFromPayload */.t6)(model, payload, ecIns._api);\n            (0,states/* updateSeriesElementSelection */.jA)(model);\n            markStatusToUpdate(ecIns);\n          }\n        }\n      }, ecIns);\n      ecModel && ecModel.eachComponent(condition, function (model) {\n        var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null;\n        if (isExcluded) {\n          return;\n        }\n        ;\n        callView(ecIns[mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId]);\n      }, ecIns);\n      function callView(view) {\n        view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);\n      }\n    };\n    updateMethods = {\n      prepareAndUpdate: function (payload) {\n        prepare(this);\n        updateMethods.update.call(this, payload, {\n          // Needs to mark option changed if newOption is given.\n          // It's from MagicType.\n          // TODO If use a separate flag optionChanged in payload?\n          optionChanged: payload.newOption != null\n        });\n      },\n      update: function (payload, updateParams) {\n        var ecModel = this._model;\n        var api = this._api;\n        var zr = this._zr;\n        var coordSysMgr = this._coordSysMgr;\n        var scheduler = this._scheduler;\n        // update before setOption\n        if (!ecModel) {\n          return;\n        }\n        ecModel.setUpdatePayload(payload);\n        scheduler.restoreData(ecModel, payload);\n        scheduler.performSeriesTasks(ecModel);\n        // TODO\n        // Save total ecModel here for undo/redo (after restoring data and before processing data).\n        // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n        // Create new coordinate system each update\n        // In LineView may save the old coordinate system and use it to get the original point.\n        coordSysMgr.create(ecModel, api);\n        scheduler.performDataProcessorTasks(ecModel, payload);\n        // Current stream render is not supported in data process. So we can update\n        // stream modes after data processing, where the filtered data is used to\n        // determine whether to use progressive rendering.\n        updateStreamModes(this, ecModel);\n        // We update stream modes before coordinate system updated, then the modes info\n        // can be fetched when coord sys updating (consider the barGrid extent fix). But\n        // the drawback is the full coord info can not be fetched. Fortunately this full\n        // coord is not required in stream mode updater currently.\n        coordSysMgr.update(ecModel, api);\n        clearColorPalette(ecModel);\n        scheduler.performVisualTasks(ecModel, payload);\n        render(this, ecModel, api, payload, updateParams);\n        // Set background\n        var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n        var darkMode = ecModel.get('darkMode');\n        zr.setBackgroundColor(backgroundColor);\n        // Force set dark mode.\n        if (darkMode != null && darkMode !== 'auto') {\n          zr.setDarkMode(darkMode);\n        }\n        core_lifecycle.trigger('afterupdate', ecModel, api);\n      },\n      updateTransform: function (payload) {\n        var _this = this;\n        var ecModel = this._model;\n        var api = this._api;\n        // update before setOption\n        if (!ecModel) {\n          return;\n        }\n        ecModel.setUpdatePayload(payload);\n        // ChartView.markUpdateMethod(payload, 'updateTransform');\n        var componentDirtyList = [];\n        ecModel.eachComponent(function (componentType, componentModel) {\n          if (componentType === 'series') {\n            return;\n          }\n          var componentView = _this.getViewOfComponentModel(componentModel);\n          if (componentView && componentView.__alive) {\n            if (componentView.updateTransform) {\n              var result = componentView.updateTransform(componentModel, ecModel, api, payload);\n              result && result.update && componentDirtyList.push(componentView);\n            } else {\n              componentDirtyList.push(componentView);\n            }\n          }\n        });\n        var seriesDirtyMap = (0,util.createHashMap)();\n        ecModel.eachSeries(function (seriesModel) {\n          var chartView = _this._chartsMap[seriesModel.__viewId];\n          if (chartView.updateTransform) {\n            var result = chartView.updateTransform(seriesModel, ecModel, api, payload);\n            result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);\n          } else {\n            seriesDirtyMap.set(seriesModel.uid, 1);\n          }\n        });\n        clearColorPalette(ecModel);\n        // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.\n        // this._scheduler.performVisualTasks(ecModel, payload, 'layout', true);\n        this._scheduler.performVisualTasks(ecModel, payload, {\n          setDirty: true,\n          dirtyMap: seriesDirtyMap\n        });\n        // Currently, not call render of components. Geo render cost a lot.\n        // renderComponents(ecIns, ecModel, api, payload, componentDirtyList);\n        renderSeries(this, ecModel, api, payload, {}, seriesDirtyMap);\n        core_lifecycle.trigger('afterupdate', ecModel, api);\n      },\n      updateView: function (payload) {\n        var ecModel = this._model;\n        // update before setOption\n        if (!ecModel) {\n          return;\n        }\n        ecModel.setUpdatePayload(payload);\n        Chart/* default */.A.markUpdateMethod(payload, 'updateView');\n        clearColorPalette(ecModel);\n        // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.\n        this._scheduler.performVisualTasks(ecModel, payload, {\n          setDirty: true\n        });\n        render(this, ecModel, this._api, payload, {});\n        core_lifecycle.trigger('afterupdate', ecModel, this._api);\n      },\n      updateVisual: function (payload) {\n        // updateMethods.update.call(this, payload);\n        var _this = this;\n        var ecModel = this._model;\n        // update before setOption\n        if (!ecModel) {\n          return;\n        }\n        ecModel.setUpdatePayload(payload);\n        // clear all visual\n        ecModel.eachSeries(function (seriesModel) {\n          seriesModel.getData().clearAllVisual();\n        });\n        // Perform visual\n        Chart/* default */.A.markUpdateMethod(payload, 'updateVisual');\n        clearColorPalette(ecModel);\n        // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.\n        this._scheduler.performVisualTasks(ecModel, payload, {\n          visualType: 'visual',\n          setDirty: true\n        });\n        ecModel.eachComponent(function (componentType, componentModel) {\n          if (componentType !== 'series') {\n            var componentView = _this.getViewOfComponentModel(componentModel);\n            componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload);\n          }\n        });\n        ecModel.eachSeries(function (seriesModel) {\n          var chartView = _this._chartsMap[seriesModel.__viewId];\n          chartView.updateVisual(seriesModel, ecModel, _this._api, payload);\n        });\n        core_lifecycle.trigger('afterupdate', ecModel, this._api);\n      },\n      updateLayout: function (payload) {\n        updateMethods.update.call(this, payload);\n      }\n    };\n    doConvertPixel = function (ecIns, methodName, finder, value) {\n      if (ecIns._disposed) {\n        disposedWarning(ecIns.id);\n        return;\n      }\n      var ecModel = ecIns._model;\n      var coordSysList = ecIns._coordSysMgr.getCoordinateSystems();\n      var result;\n      var parsedFinder = model/* parseFinder */._e(ecModel, finder);\n      for (var i = 0; i < coordSysList.length; i++) {\n        var coordSys = coordSysList[i];\n        if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value)) != null) {\n          return result;\n        }\n      }\n      if (false) {}\n    };\n    updateStreamModes = function (ecIns, ecModel) {\n      var chartsMap = ecIns._chartsMap;\n      var scheduler = ecIns._scheduler;\n      ecModel.eachSeries(function (seriesModel) {\n        scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);\n      });\n    };\n    doDispatchAction = function (payload, silent) {\n      var _this = this;\n      var ecModel = this.getModel();\n      var payloadType = payload.type;\n      var escapeConnect = payload.escapeConnect;\n      var actionWrap = actions[payloadType];\n      var actionInfo = actionWrap.actionInfo;\n      var cptTypeTmp = (actionInfo.update || 'update').split(':');\n      var updateMethod = cptTypeTmp.pop();\n      var cptType = cptTypeTmp[0] != null && (0,clazz/* parseClassType */.CC)(cptTypeTmp[0]);\n      this[IN_MAIN_PROCESS_KEY] = true;\n      var payloads = [payload];\n      var batched = false;\n      // Batch action\n      if (payload.batch) {\n        batched = true;\n        payloads = (0,util.map)(payload.batch, function (item) {\n          item = (0,util.defaults)((0,util.extend)({}, item), payload);\n          item.batch = null;\n          return item;\n        });\n      }\n      var eventObjBatch = [];\n      var eventObj;\n      var isSelectChange = (0,states/* isSelectChangePayload */.Lx)(payload);\n      var isHighDown = (0,states/* isHighDownPayload */.T$)(payload);\n      // Only leave blur once if there are multiple batches.\n      if (isHighDown) {\n        (0,states/* allLeaveBlur */.qR)(this._api);\n      }\n      (0,util.each)(payloads, function (batchItem) {\n        // Action can specify the event by return it.\n        eventObj = actionWrap.action(batchItem, _this._model, _this._api);\n        // Emit event outside\n        eventObj = eventObj || (0,util.extend)({}, batchItem);\n        // Convert type to eventType\n        eventObj.type = actionInfo.event || eventObj.type;\n        eventObjBatch.push(eventObj);\n        // light update does not perform data process, layout and visual.\n        if (isHighDown) {\n          var _a = model/* preParseFinder */.HB(payload),\n            queryOptionMap = _a.queryOptionMap,\n            mainTypeSpecified = _a.mainTypeSpecified;\n          var componentMainType = mainTypeSpecified ? queryOptionMap.keys()[0] : 'series';\n          updateDirectly(_this, updateMethod, batchItem, componentMainType);\n          markStatusToUpdate(_this);\n        } else if (isSelectChange) {\n          // At present `dispatchAction({ type: 'select', ... })` is not supported on components.\n          // geo still use 'geoselect'.\n          updateDirectly(_this, updateMethod, batchItem, 'series');\n          markStatusToUpdate(_this);\n        } else if (cptType) {\n          updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub);\n        }\n      });\n      if (updateMethod !== 'none' && !isHighDown && !isSelectChange && !cptType) {\n        try {\n          // Still dirty\n          if (this[PENDING_UPDATE]) {\n            prepare(this);\n            updateMethods.update.call(this, payload);\n            this[PENDING_UPDATE] = null;\n          } else {\n            updateMethods[updateMethod].call(this, payload);\n          }\n        } catch (e) {\n          this[IN_MAIN_PROCESS_KEY] = false;\n          throw e;\n        }\n      }\n      // Follow the rule of action batch\n      if (batched) {\n        eventObj = {\n          type: actionInfo.event || payloadType,\n          escapeConnect: escapeConnect,\n          batch: eventObjBatch\n        };\n      } else {\n        eventObj = eventObjBatch[0];\n      }\n      this[IN_MAIN_PROCESS_KEY] = false;\n      if (!silent) {\n        var messageCenter = this._messageCenter;\n        messageCenter.trigger(eventObj.type, eventObj);\n        // Extra triggered 'selectchanged' event\n        if (isSelectChange) {\n          var newObj = {\n            type: 'selectchanged',\n            escapeConnect: escapeConnect,\n            selected: (0,states/* getAllSelectedIndices */.mc)(ecModel),\n            isFromClick: payload.isFromClick || false,\n            fromAction: payload.type,\n            fromActionPayload: payload\n          };\n          messageCenter.trigger(newObj.type, newObj);\n        }\n      }\n    };\n    flushPendingActions = function (silent) {\n      var pendingActions = this._pendingActions;\n      while (pendingActions.length) {\n        var payload = pendingActions.shift();\n        doDispatchAction.call(this, payload, silent);\n      }\n    };\n    triggerUpdatedEvent = function (silent) {\n      !silent && this.trigger('updated');\n    };\n    /**\r\n     * Event `rendered` is triggered when zr\r\n     * rendered. It is useful for realtime\r\n     * snapshot (reflect animation).\r\n     *\r\n     * Event `finished` is triggered when:\r\n     * (1) zrender rendering finished.\r\n     * (2) initial animation finished.\r\n     * (3) progressive rendering finished.\r\n     * (4) no pending action.\r\n     * (5) no delayed setOption needs to be processed.\r\n     */\n    bindRenderedEvent = function (zr, ecIns) {\n      zr.on('rendered', function (params) {\n        ecIns.trigger('rendered', params);\n        // The `finished` event should not be triggered repeatedly,\n        // so it should only be triggered when rendering indeed happens\n        // in zrender. (Consider the case that dipatchAction is keep\n        // triggering when mouse move).\n        if (\n        // Although zr is dirty if initial animation is not finished\n        // and this checking is called on frame, we also check\n        // animation finished for robustness.\n        zr.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {\n          ecIns.trigger('finished');\n        }\n      });\n    };\n    bindMouseEvent = function (zr, ecIns) {\n      zr.on('mouseover', function (e) {\n        var el = e.target;\n        var dispatcher = (0,util_event/* findEventDispatcher */.R)(el, states/* isHighDownDispatcher */.u6);\n        if (dispatcher) {\n          (0,states/* handleGlobalMouseOverForHighDown */._m)(dispatcher, e, ecIns._api);\n          markStatusToUpdate(ecIns);\n        }\n      }).on('mouseout', function (e) {\n        var el = e.target;\n        var dispatcher = (0,util_event/* findEventDispatcher */.R)(el, states/* isHighDownDispatcher */.u6);\n        if (dispatcher) {\n          (0,states/* handleGlobalMouseOutForHighDown */.Iz)(dispatcher, e, ecIns._api);\n          markStatusToUpdate(ecIns);\n        }\n      }).on('click', function (e) {\n        var el = e.target;\n        var dispatcher = (0,util_event/* findEventDispatcher */.R)(el, function (target) {\n          return (0,innerStore/* getECData */.z)(target).dataIndex != null;\n        }, true);\n        if (dispatcher) {\n          var actionType = dispatcher.selected ? 'unselect' : 'select';\n          var ecData = (0,innerStore/* getECData */.z)(dispatcher);\n          ecIns._api.dispatchAction({\n            type: actionType,\n            dataType: ecData.dataType,\n            dataIndexInside: ecData.dataIndex,\n            seriesIndex: ecData.seriesIndex,\n            isFromClick: true\n          });\n        }\n      });\n    };\n    function clearColorPalette(ecModel) {\n      ecModel.clearColorPalette();\n      ecModel.eachSeries(function (seriesModel) {\n        seriesModel.clearColorPalette();\n      });\n    }\n    ;\n    // Allocate zlevels for series and components\n    function allocateZlevels(ecModel) {\n      ;\n      var componentZLevels = [];\n      var seriesZLevels = [];\n      var hasSeparateZLevel = false;\n      ecModel.eachComponent(function (componentType, componentModel) {\n        var zlevel = componentModel.get('zlevel') || 0;\n        var z = componentModel.get('z') || 0;\n        var zlevelKey = componentModel.getZLevelKey();\n        hasSeparateZLevel = hasSeparateZLevel || !!zlevelKey;\n        (componentType === 'series' ? seriesZLevels : componentZLevels).push({\n          zlevel: zlevel,\n          z: z,\n          idx: componentModel.componentIndex,\n          type: componentType,\n          key: zlevelKey\n        });\n      });\n      if (hasSeparateZLevel) {\n        // Series after component\n        var zLevels = componentZLevels.concat(seriesZLevels);\n        var lastSeriesZLevel_1;\n        var lastSeriesKey_1;\n        (0,timsort/* default */.A)(zLevels, function (a, b) {\n          if (a.zlevel === b.zlevel) {\n            return a.z - b.z;\n          }\n          return a.zlevel - b.zlevel;\n        });\n        (0,util.each)(zLevels, function (item) {\n          var componentModel = ecModel.getComponent(item.type, item.idx);\n          var zlevel = item.zlevel;\n          var key = item.key;\n          if (lastSeriesZLevel_1 != null) {\n            zlevel = Math.max(lastSeriesZLevel_1, zlevel);\n          }\n          if (key) {\n            if (zlevel === lastSeriesZLevel_1 && key !== lastSeriesKey_1) {\n              zlevel++;\n            }\n            lastSeriesKey_1 = key;\n          } else if (lastSeriesKey_1) {\n            if (zlevel === lastSeriesZLevel_1) {\n              zlevel++;\n            }\n            lastSeriesKey_1 = '';\n          }\n          lastSeriesZLevel_1 = zlevel;\n          componentModel.setZLevel(zlevel);\n        });\n      }\n    }\n    render = function (ecIns, ecModel, api, payload, updateParams) {\n      allocateZlevels(ecModel);\n      renderComponents(ecIns, ecModel, api, payload, updateParams);\n      (0,util.each)(ecIns._chartsViews, function (chart) {\n        chart.__alive = false;\n      });\n      renderSeries(ecIns, ecModel, api, payload, updateParams);\n      // Remove groups of unrendered charts\n      (0,util.each)(ecIns._chartsViews, function (chart) {\n        if (!chart.__alive) {\n          chart.remove(ecModel, api);\n        }\n      });\n    };\n    renderComponents = function (ecIns, ecModel, api, payload, updateParams, dirtyList) {\n      (0,util.each)(dirtyList || ecIns._componentsViews, function (componentView) {\n        var componentModel = componentView.__model;\n        clearStates(componentModel, componentView);\n        componentView.render(componentModel, ecModel, api, payload);\n        updateZ(componentModel, componentView);\n        updateStates(componentModel, componentView);\n      });\n    };\n    /**\r\n     * Render each chart and component\r\n     */\n    renderSeries = function (ecIns, ecModel, api, payload, updateParams, dirtyMap) {\n      // Render all charts\n      var scheduler = ecIns._scheduler;\n      updateParams = (0,util.extend)(updateParams || {}, {\n        updatedSeries: ecModel.getSeries()\n      });\n      // TODO progressive?\n      core_lifecycle.trigger('series:beforeupdate', ecModel, api, updateParams);\n      var unfinished = false;\n      ecModel.eachSeries(function (seriesModel) {\n        var chartView = ecIns._chartsMap[seriesModel.__viewId];\n        chartView.__alive = true;\n        var renderTask = chartView.renderTask;\n        scheduler.updatePayload(renderTask, payload);\n        // TODO states on marker.\n        clearStates(seriesModel, chartView);\n        if (dirtyMap && dirtyMap.get(seriesModel.uid)) {\n          renderTask.dirty();\n        }\n        if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {\n          unfinished = true;\n        }\n        chartView.group.silent = !!seriesModel.get('silent');\n        // Should not call markRedraw on group, because it will disable zrender\n        // incremental render (always render from the __startIndex each frame)\n        // chartView.group.markRedraw();\n        updateBlend(seriesModel, chartView);\n        (0,states/* updateSeriesElementSelection */.jA)(seriesModel);\n      });\n      scheduler.unfinished = unfinished || scheduler.unfinished;\n      core_lifecycle.trigger('series:layoutlabels', ecModel, api, updateParams);\n      // transition after label is layouted.\n      core_lifecycle.trigger('series:transition', ecModel, api, updateParams);\n      ecModel.eachSeries(function (seriesModel) {\n        var chartView = ecIns._chartsMap[seriesModel.__viewId];\n        // Update Z after labels updated. Before applying states.\n        updateZ(seriesModel, chartView);\n        // NOTE: Update states after label is updated.\n        // label should be in normal status when layouting.\n        updateStates(seriesModel, chartView);\n      });\n      // If use hover layer\n      updateHoverLayerStatus(ecIns, ecModel);\n      core_lifecycle.trigger('series:afterupdate', ecModel, api, updateParams);\n    };\n    markStatusToUpdate = function (ecIns) {\n      ecIns[STATUS_NEEDS_UPDATE_KEY] = true;\n      // Wake up zrender if it's sleep. Let it update states in the next frame.\n      ecIns.getZr().wakeUp();\n    };\n    applyChangedStates = function (ecIns) {\n      if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {\n        return;\n      }\n      ecIns.getZr().storage.traverse(function (el) {\n        // Not applied on removed elements, it may still in fading.\n        if (basicTransition/* isElementRemoved */.LR(el)) {\n          return;\n        }\n        applyElementStates(el);\n      });\n      ecIns[STATUS_NEEDS_UPDATE_KEY] = false;\n    };\n    function applyElementStates(el) {\n      var newStates = [];\n      var oldStates = el.currentStates;\n      // Keep other states.\n      for (var i = 0; i < oldStates.length; i++) {\n        var stateName = oldStates[i];\n        if (!(stateName === 'emphasis' || stateName === 'blur' || stateName === 'select')) {\n          newStates.push(stateName);\n        }\n      }\n      // Only use states when it's exists.\n      if (el.selected && el.states.select) {\n        newStates.push('select');\n      }\n      if (el.hoverState === states/* HOVER_STATE_EMPHASIS */.e3 && el.states.emphasis) {\n        newStates.push('emphasis');\n      } else if (el.hoverState === states/* HOVER_STATE_BLUR */.zX && el.states.blur) {\n        newStates.push('blur');\n      }\n      el.useStates(newStates);\n    }\n    function updateHoverLayerStatus(ecIns, ecModel) {\n      var zr = ecIns._zr;\n      var storage = zr.storage;\n      var elCount = 0;\n      storage.traverse(function (el) {\n        if (!el.isGroup) {\n          elCount++;\n        }\n      });\n      if (elCount > ecModel.get('hoverLayerThreshold') && !env/* default */.A.node && !env/* default */.A.worker) {\n        ecModel.eachSeries(function (seriesModel) {\n          if (seriesModel.preventUsingHoverLayer) {\n            return;\n          }\n          var chartView = ecIns._chartsMap[seriesModel.__viewId];\n          if (chartView.__alive) {\n            chartView.eachRendered(function (el) {\n              if (el.states.emphasis) {\n                el.states.emphasis.hoverLayer = true;\n              }\n            });\n          }\n        });\n      }\n    }\n    ;\n    /**\r\n     * Update chart and blend.\r\n     */\n    function updateBlend(seriesModel, chartView) {\n      var blendMode = seriesModel.get('blendMode') || null;\n      chartView.eachRendered(function (el) {\n        // FIXME marker and other components\n        if (!el.isGroup) {\n          // DON'T mark the element dirty. In case element is incremental and don't want to rerender.\n          el.style.blend = blendMode;\n        }\n      });\n    }\n    ;\n    function updateZ(model, view) {\n      if (model.preventAutoZ) {\n        return;\n      }\n      var z = model.get('z') || 0;\n      var zlevel = model.get('zlevel') || 0;\n      // Set z and zlevel\n      view.eachRendered(function (el) {\n        doUpdateZ(el, z, zlevel, -Infinity);\n        // Don't traverse the children because it has been traversed in _updateZ.\n        return true;\n      });\n    }\n    ;\n    function doUpdateZ(el, z, zlevel, maxZ2) {\n      // Group may also have textContent\n      var label = el.getTextContent();\n      var labelLine = el.getTextGuideLine();\n      var isGroup = el.isGroup;\n      if (isGroup) {\n        // set z & zlevel of children elements of Group\n        var children = el.childrenRef();\n        for (var i = 0; i < children.length; i++) {\n          maxZ2 = Math.max(doUpdateZ(children[i], z, zlevel, maxZ2), maxZ2);\n        }\n      } else {\n        // not Group\n        el.z = z;\n        el.zlevel = zlevel;\n        maxZ2 = Math.max(el.z2, maxZ2);\n      }\n      // always set z and zlevel if label/labelLine exists\n      if (label) {\n        label.z = z;\n        label.zlevel = zlevel;\n        // lift z2 of text content\n        // TODO if el.emphasis.z2 is spcefied, what about textContent.\n        isFinite(maxZ2) && (label.z2 = maxZ2 + 2);\n      }\n      if (labelLine) {\n        var textGuideLineConfig = el.textGuideLineConfig;\n        labelLine.z = z;\n        labelLine.zlevel = zlevel;\n        isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));\n      }\n      return maxZ2;\n    }\n    // Clear states without animation.\n    // TODO States on component.\n    function clearStates(model, view) {\n      view.eachRendered(function (el) {\n        // Not applied on removed elements, it may still in fading.\n        if (basicTransition/* isElementRemoved */.LR(el)) {\n          return;\n        }\n        var textContent = el.getTextContent();\n        var textGuide = el.getTextGuideLine();\n        if (el.stateTransition) {\n          el.stateTransition = null;\n        }\n        if (textContent && textContent.stateTransition) {\n          textContent.stateTransition = null;\n        }\n        if (textGuide && textGuide.stateTransition) {\n          textGuide.stateTransition = null;\n        }\n        // TODO If el is incremental.\n        if (el.hasState()) {\n          el.prevStates = el.currentStates;\n          el.clearStates();\n        } else if (el.prevStates) {\n          el.prevStates = null;\n        }\n      });\n    }\n    function updateStates(model, view) {\n      var stateAnimationModel = model.getModel('stateAnimation');\n      var enableAnimation = model.isAnimationEnabled();\n      var duration = stateAnimationModel.get('duration');\n      var stateTransition = duration > 0 ? {\n        duration: duration,\n        delay: stateAnimationModel.get('delay'),\n        easing: stateAnimationModel.get('easing')\n        // additive: stateAnimationModel.get('additive')\n      } : null;\n      view.eachRendered(function (el) {\n        if (el.states && el.states.emphasis) {\n          // Not applied on removed elements, it may still in fading.\n          if (basicTransition/* isElementRemoved */.LR(el)) {\n            return;\n          }\n          if (el instanceof Path/* default */.Ay) {\n            (0,states/* savePathStates */.fz)(el);\n          }\n          // Only updated on changed element. In case element is incremental and don't want to rerender.\n          // TODO, a more proper way?\n          if (el.__dirty) {\n            var prevStates = el.prevStates;\n            // Restore states without animation\n            if (prevStates) {\n              el.useStates(prevStates);\n            }\n          }\n          // Update state transition and enable animation again.\n          if (enableAnimation) {\n            el.stateTransition = stateTransition;\n            var textContent = el.getTextContent();\n            var textGuide = el.getTextGuideLine();\n            // TODO Is it necessary to animate label?\n            if (textContent) {\n              textContent.stateTransition = stateTransition;\n            }\n            if (textGuide) {\n              textGuide.stateTransition = stateTransition;\n            }\n          }\n          // Use highlighted and selected flag to toggle states.\n          if (el.__dirty) {\n            applyElementStates(el);\n          }\n        }\n      });\n    }\n    ;\n    createExtensionAPI = function (ecIns) {\n      return new (/** @class */function (_super) {\n        (0,tslib_es6/* __extends */.C6)(class_1, _super);\n        function class_1() {\n          return _super !== null && _super.apply(this, arguments) || this;\n        }\n        class_1.prototype.getCoordinateSystems = function () {\n          return ecIns._coordSysMgr.getCoordinateSystems();\n        };\n        class_1.prototype.getComponentByElement = function (el) {\n          while (el) {\n            var modelInfo = el.__ecComponentInfo;\n            if (modelInfo != null) {\n              return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);\n            }\n            el = el.parent;\n          }\n        };\n        class_1.prototype.enterEmphasis = function (el, highlightDigit) {\n          (0,states/* enterEmphasis */.HY)(el, highlightDigit);\n          markStatusToUpdate(ecIns);\n        };\n        class_1.prototype.leaveEmphasis = function (el, highlightDigit) {\n          (0,states/* leaveEmphasis */.SD)(el, highlightDigit);\n          markStatusToUpdate(ecIns);\n        };\n        class_1.prototype.enterBlur = function (el) {\n          (0,states/* enterBlur */.QX)(el);\n          markStatusToUpdate(ecIns);\n        };\n        class_1.prototype.leaveBlur = function (el) {\n          (0,states/* leaveBlur */.JC)(el);\n          markStatusToUpdate(ecIns);\n        };\n        class_1.prototype.enterSelect = function (el) {\n          (0,states/* enterSelect */.JI)(el);\n          markStatusToUpdate(ecIns);\n        };\n        class_1.prototype.leaveSelect = function (el) {\n          (0,states/* leaveSelect */.gd)(el);\n          markStatusToUpdate(ecIns);\n        };\n        class_1.prototype.getModel = function () {\n          return ecIns.getModel();\n        };\n        class_1.prototype.getViewOfComponentModel = function (componentModel) {\n          return ecIns.getViewOfComponentModel(componentModel);\n        };\n        class_1.prototype.getViewOfSeriesModel = function (seriesModel) {\n          return ecIns.getViewOfSeriesModel(seriesModel);\n        };\n        return class_1;\n      }(core_ExtensionAPI))(ecIns);\n    };\n    enableConnect = function (chart) {\n      function updateConnectedChartsStatus(charts, status) {\n        for (var i = 0; i < charts.length; i++) {\n          var otherChart = charts[i];\n          otherChart[CONNECT_STATUS_KEY] = status;\n        }\n      }\n      (0,util.each)(eventActionMap, function (actionType, eventType) {\n        chart._messageCenter.on(eventType, function (event) {\n          if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {\n            if (event && event.escapeConnect) {\n              return;\n            }\n            var action_1 = chart.makeActionFromEvent(event);\n            var otherCharts_1 = [];\n            (0,util.each)(instances, function (otherChart) {\n              if (otherChart !== chart && otherChart.group === chart.group) {\n                otherCharts_1.push(otherChart);\n              }\n            });\n            updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_PENDING);\n            (0,util.each)(otherCharts_1, function (otherChart) {\n              if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) {\n                otherChart.dispatchAction(action_1);\n              }\n            });\n            updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_UPDATED);\n          }\n        });\n      });\n    };\n  }();\n  return ECharts;\n}(Eventful/* default */.A);\nvar echartsProto = ECharts.prototype;\nechartsProto.on = createRegisterEventWithLowercaseECharts('on');\nechartsProto.off = createRegisterEventWithLowercaseECharts('off');\n/**\r\n * @deprecated\r\n */\n// @ts-ignore\nechartsProto.one = function (eventName, cb, ctx) {\n  var self = this;\n  (0,log/* deprecateLog */.aT)('ECharts#one is deprecated.');\n  function wrapped() {\n    var args2 = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args2[_i] = arguments[_i];\n    }\n    cb && cb.apply && cb.apply(this, args2);\n    // @ts-ignore\n    self.off(eventName, wrapped);\n  }\n  ;\n  // @ts-ignore\n  this.on.call(this, eventName, wrapped, ctx);\n};\nvar MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu'];\nfunction disposedWarning(id) {\n  if (false) {}\n}\nvar actions = {};\n/**\r\n * Map eventType to actionType\r\n */\nvar eventActionMap = {};\nvar dataProcessorFuncs = [];\nvar optionPreprocessorFuncs = [];\nvar visualFuncs = [];\nvar themeStorage = {};\nvar loadingEffects = {};\nvar instances = {};\nvar connectedGroups = {};\nvar idBase = +new Date() - 0;\nvar groupIdBase = +new Date() - 0;\nvar DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n/**\r\n * @param opts.devicePixelRatio Use window.devicePixelRatio by default\r\n * @param opts.renderer Can choose 'canvas' or 'svg' to render the chart.\r\n * @param opts.width Use clientWidth of the input `dom` by default.\r\n *        Can be 'auto' (the same as null/undefined)\r\n * @param opts.height Use clientHeight of the input `dom` by default.\r\n *        Can be 'auto' (the same as null/undefined)\r\n * @param opts.locale Specify the locale.\r\n * @param opts.useDirtyRect Enable dirty rectangle rendering or not.\r\n */\nfunction init(dom, theme, opts) {\n  var isClient = !(opts && opts.ssr);\n  if (isClient) {\n    if (false) {}\n    var existInstance = getInstanceByDom(dom);\n    if (existInstance) {\n      if (false) {}\n      return existInstance;\n    }\n    if (false) {}\n  }\n  var chart = new ECharts(dom, theme, opts);\n  chart.id = 'ec_' + idBase++;\n  instances[chart.id] = chart;\n  isClient && model/* setAttribute */.Bq(dom, DOM_ATTRIBUTE_KEY, chart.id);\n  enableConnect(chart);\n  core_lifecycle.trigger('afterinit', chart);\n  return chart;\n}\n/**\r\n * @usage\r\n * (A)\r\n * ```js\r\n * let chart1 = echarts.init(dom1);\r\n * let chart2 = echarts.init(dom2);\r\n * chart1.group = 'xxx';\r\n * chart2.group = 'xxx';\r\n * echarts.connect('xxx');\r\n * ```\r\n * (B)\r\n * ```js\r\n * let chart1 = echarts.init(dom1);\r\n * let chart2 = echarts.init(dom2);\r\n * echarts.connect('xxx', [chart1, chart2]);\r\n * ```\r\n */\nfunction connect(groupId) {\n  // Is array of charts\n  if ((0,util.isArray)(groupId)) {\n    var charts = groupId;\n    groupId = null;\n    // If any chart has group\n    (0,util.each)(charts, function (chart) {\n      if (chart.group != null) {\n        groupId = chart.group;\n      }\n    });\n    groupId = groupId || 'g_' + groupIdBase++;\n    (0,util.each)(charts, function (chart) {\n      chart.group = groupId;\n    });\n  }\n  connectedGroups[groupId] = true;\n  return groupId;\n}\nfunction disconnect(groupId) {\n  connectedGroups[groupId] = false;\n}\n/**\r\n * Alias and backward compatibility\r\n * @deprecated\r\n */\nvar disConnect = disconnect;\n/**\r\n * Dispose a chart instance\r\n */\nfunction dispose(chart) {\n  if ((0,util.isString)(chart)) {\n    chart = instances[chart];\n  } else if (!(chart instanceof ECharts)) {\n    // Try to treat as dom\n    chart = getInstanceByDom(chart);\n  }\n  if (chart instanceof ECharts && !chart.isDisposed()) {\n    chart.dispose();\n  }\n}\nfunction getInstanceByDom(dom) {\n  return instances[model/* getAttribute */.D$(dom, DOM_ATTRIBUTE_KEY)];\n}\nfunction getInstanceById(key) {\n  return instances[key];\n}\n/**\r\n * Register theme\r\n */\nfunction registerTheme(name, theme) {\n  themeStorage[name] = theme;\n}\n/**\r\n * Register option preprocessor\r\n */\nfunction registerPreprocessor(preprocessorFunc) {\n  if ((0,util.indexOf)(optionPreprocessorFuncs, preprocessorFunc) < 0) {\n    optionPreprocessorFuncs.push(preprocessorFunc);\n  }\n}\nfunction registerProcessor(priority, processor) {\n  normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);\n}\n/**\r\n * Register postIniter\r\n * @param {Function} postInitFunc\r\n */\nfunction registerPostInit(postInitFunc) {\n  registerUpdateLifecycle('afterinit', postInitFunc);\n}\n/**\r\n * Register postUpdater\r\n * @param {Function} postUpdateFunc\r\n */\nfunction registerPostUpdate(postUpdateFunc) {\n  registerUpdateLifecycle('afterupdate', postUpdateFunc);\n}\nfunction registerUpdateLifecycle(name, cb) {\n  core_lifecycle.on(name, cb);\n}\nfunction registerAction(actionInfo, eventName, action) {\n  if ((0,util.isFunction)(eventName)) {\n    action = eventName;\n    eventName = '';\n  }\n  var actionType = (0,util.isObject)(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {\n    event: eventName\n  }][0];\n  // Event name is all lowercase\n  actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n  eventName = actionInfo.event;\n  if (eventActionMap[eventName]) {\n    // Already registered.\n    return;\n  }\n  // Validate action type and event name.\n  (0,util.assert)(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n  if (!actions[actionType]) {\n    actions[actionType] = {\n      action: action,\n      actionInfo: actionInfo\n    };\n  }\n  eventActionMap[eventName] = actionType;\n}\nfunction registerCoordinateSystem(type, coordSysCreator) {\n  CoordinateSystem/* default */.A.register(type, coordSysCreator);\n}\n/**\r\n * Get dimensions of specified coordinate system.\r\n * @param {string} type\r\n * @return {Array.<string|Object>}\r\n */\nfunction getCoordinateSystemDimensions(type) {\n  var coordSysCreator = CoordinateSystem/* default */.A.get(type);\n  if (coordSysCreator) {\n    return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();\n  }\n}\n\nfunction registerLayout(priority, layoutTask) {\n  normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, 'layout');\n}\nfunction registerVisual(priority, visualTask) {\n  normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, 'visual');\n}\n\nvar registeredTasks = [];\nfunction normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {\n  if ((0,util.isFunction)(priority) || (0,util.isObject)(priority)) {\n    fn = priority;\n    priority = defaultPriority;\n  }\n  if (false) {}\n  // Already registered\n  if ((0,util.indexOf)(registeredTasks, fn) >= 0) {\n    return;\n  }\n  registeredTasks.push(fn);\n  var stageHandler = core_Scheduler.wrapStageHandler(fn, visualType);\n  stageHandler.__prio = priority;\n  stageHandler.__raw = fn;\n  targetList.push(stageHandler);\n}\nfunction registerLoading(name, loadingFx) {\n  loadingEffects[name] = loadingFx;\n}\n/**\r\n * ZRender need a canvas context to do measureText.\r\n * But in node environment canvas may be created by node-canvas.\r\n * So we need to specify how to create a canvas instead of using document.createElement('canvas')\r\n *\r\n *\r\n * @deprecated use setPlatformAPI({ createCanvas }) instead.\r\n *\r\n * @example\r\n *     let Canvas = require('canvas');\r\n *     let echarts = require('echarts');\r\n *     echarts.setCanvasCreator(function () {\r\n *         // Small size is enough.\r\n *         return new Canvas(32, 32);\r\n *     });\r\n */\nfunction setCanvasCreator(creator) {\n  if (false) {}\n  (0,platform/* setPlatformAPI */.Gs)({\n    createCanvas: creator\n  });\n}\n/**\r\n * The parameters and usage: see `geoSourceManager.registerMap`.\r\n * Compatible with previous `echarts.registerMap`.\r\n */\nfunction registerMap(mapName, geoJson, specialAreas) {\n  var registerMap = (0,impl/* getImpl */.v)('registerMap');\n  registerMap && registerMap(mapName, geoJson, specialAreas);\n}\nfunction getMap(mapName) {\n  var getMap = (0,impl/* getImpl */.v)('getMap');\n  return getMap && getMap(mapName);\n}\nvar registerTransform = transform/* registerExternalTransform */.v5;\n/**\r\n * Globa dispatchAction to a specified chart instance.\r\n */\n// export function dispatchAction(payload: { chartId: string } & Payload, opt?: Parameters<ECharts['dispatchAction']>[1]) {\n//     if (!payload || !payload.chartId) {\n//         // Must have chartId to find chart\n//         return;\n//     }\n//     const chart = instances[payload.chartId];\n//     if (chart) {\n//         chart.dispatchAction(payload, opt);\n//     }\n// }\n// Builtin global visual\nregisterVisual(PRIORITY_VISUAL_GLOBAL, style/* seriesStyleTask */.mK);\nregisterVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, style/* dataStyleTask */.HG);\nregisterVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, style/* dataColorPaletteTask */.EY);\nregisterVisual(PRIORITY_VISUAL_GLOBAL, symbol/* seriesSymbolTask */.P);\nregisterVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, symbol/* dataSymbolTask */.e);\nregisterVisual(PRIORITY_VISUAL_DECAL, decal/* default */.A);\nregisterPreprocessor(backwardCompat/* default */.A);\nregisterProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack/* default */.A);\nregisterLoading('default', loading_default/* default */.A);\n// Default actions\nregisterAction({\n  type: states/* HIGHLIGHT_ACTION_TYPE */.h5,\n  event: states/* HIGHLIGHT_ACTION_TYPE */.h5,\n  update: states/* HIGHLIGHT_ACTION_TYPE */.h5\n}, util.noop);\nregisterAction({\n  type: states/* DOWNPLAY_ACTION_TYPE */.PW,\n  event: states/* DOWNPLAY_ACTION_TYPE */.PW,\n  update: states/* DOWNPLAY_ACTION_TYPE */.PW\n}, util.noop);\nregisterAction({\n  type: states/* SELECT_ACTION_TYPE */.Lv,\n  event: states/* SELECT_ACTION_TYPE */.Lv,\n  update: states/* SELECT_ACTION_TYPE */.Lv\n}, util.noop);\nregisterAction({\n  type: states/* UNSELECT_ACTION_TYPE */.U2,\n  event: states/* UNSELECT_ACTION_TYPE */.U2,\n  update: states/* UNSELECT_ACTION_TYPE */.U2\n}, util.noop);\nregisterAction({\n  type: states/* TOGGLE_SELECT_ACTION_TYPE */.Q6,\n  event: states/* TOGGLE_SELECT_ACTION_TYPE */.Q6,\n  update: states/* TOGGLE_SELECT_ACTION_TYPE */.Q6\n}, util.noop);\n// Default theme\nregisterTheme('light', light/* default */.A);\nregisterTheme('dark', dark/* default */.A);\n// For backward compatibility, where the namespace `dataTool` will\n// be mounted on `echarts` is the extension `dataTool` is imported.\nvar dataTool = {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUzODMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb3JlL0V4dGVuc2lvbkFQSS5qcz83ZGMxIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb3JlL1NjaGVkdWxlci5qcz8zMGI5Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb3JlL2xpZmVjeWNsZS5qcz8wYWExIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb3JlL2VjaGFydHMuanM/ZWQ2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xudmFyIGF2YWlsYWJsZU1ldGhvZHMgPSBbJ2dldERvbScsICdnZXRacicsICdnZXRXaWR0aCcsICdnZXRIZWlnaHQnLCAnZ2V0RGV2aWNlUGl4ZWxSYXRpbycsICdkaXNwYXRjaEFjdGlvbicsICdpc1NTUicsICdpc0Rpc3Bvc2VkJywgJ29uJywgJ29mZicsICdnZXREYXRhVVJMJywgJ2dldENvbm5lY3RlZERhdGFVUkwnLFxuLy8gJ2dldE1vZGVsJyxcbidnZXRPcHRpb24nLFxuLy8gJ2dldFZpZXdPZkNvbXBvbmVudE1vZGVsJyxcbi8vICdnZXRWaWV3T2ZTZXJpZXNNb2RlbCcsXG4nZ2V0SWQnLCAndXBkYXRlTGFiZWxMYXlvdXQnXTtcbnZhciBFeHRlbnNpb25BUEkgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFeHRlbnNpb25BUEkoZWNJbnN0YW5jZSkge1xuICAgIHpyVXRpbC5lYWNoKGF2YWlsYWJsZU1ldGhvZHMsIGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgICB0aGlzW21ldGhvZE5hbWVdID0genJVdGlsLmJpbmQoZWNJbnN0YW5jZVttZXRob2ROYW1lXSwgZWNJbnN0YW5jZSk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIEV4dGVuc2lvbkFQSTtcbn0oKTtcbmV4cG9ydCBkZWZhdWx0IEV4dGVuc2lvbkFQSTsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGVhY2gsIG1hcCwgaXNGdW5jdGlvbiwgY3JlYXRlSGFzaE1hcCwgbm9vcCwgYXNzZXJ0IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGNyZWF0ZVRhc2sgfSBmcm9tICcuL3Rhc2suanMnO1xuaW1wb3J0IHsgZ2V0VUlEIH0gZnJvbSAnLi4vdXRpbC9jb21wb25lbnQuanMnO1xuaW1wb3J0IEdsb2JhbE1vZGVsIGZyb20gJy4uL21vZGVsL0dsb2JhbC5qcyc7XG5pbXBvcnQgRXh0ZW5zaW9uQVBJIGZyb20gJy4vRXh0ZW5zaW9uQVBJLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZVRvQXJyYXkgfSBmcm9tICcuLi91dGlsL21vZGVsLmpzJztcbjtcbnZhciBTY2hlZHVsZXIgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY2hlZHVsZXIoZWNJbnN0YW5jZSwgYXBpLCBkYXRhUHJvY2Vzc29ySGFuZGxlcnMsIHZpc3VhbEhhbmRsZXJzKSB7XG4gICAgLy8ga2V5OiBoYW5kbGVyVUlEXG4gICAgdGhpcy5fc3RhZ2VUYXNrTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuICAgIHRoaXMuZWNJbnN0YW5jZSA9IGVjSW5zdGFuY2U7XG4gICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgLy8gRml4IGN1cnJlbnQgcHJvY2Vzc29ycyBpbiBjYXNlIHRoYXQgaW4gc29tZSByZWFyIGNhc2VzIHRoYXRcbiAgICAvLyBwcm9jZXNzb3JzIG1pZ2h0IGJlIHJlZ2lzdGVyZWQgYWZ0ZXIgZWNoYXJ0cyBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIC8vIFJlZ2lzdGVyIHByb2Nlc3NvcnMgaW5jcmVtZW50YWxseSBmb3IgYSBlY2hhcnRzIGluc3RhbmNlIGlzXG4gICAgLy8gbm90IHN1cHBvcnRlZCBieSB0aGlzIHN0cmVhbSBhcmNoaXRlY3R1cmUuXG4gICAgZGF0YVByb2Nlc3NvckhhbmRsZXJzID0gdGhpcy5fZGF0YVByb2Nlc3NvckhhbmRsZXJzID0gZGF0YVByb2Nlc3NvckhhbmRsZXJzLnNsaWNlKCk7XG4gICAgdmlzdWFsSGFuZGxlcnMgPSB0aGlzLl92aXN1YWxIYW5kbGVycyA9IHZpc3VhbEhhbmRsZXJzLnNsaWNlKCk7XG4gICAgdGhpcy5fYWxsSGFuZGxlcnMgPSBkYXRhUHJvY2Vzc29ySGFuZGxlcnMuY29uY2F0KHZpc3VhbEhhbmRsZXJzKTtcbiAgfVxuICBTY2hlZHVsZXIucHJvdG90eXBlLnJlc3RvcmVEYXRhID0gZnVuY3Rpb24gKGVjTW9kZWwsIHBheWxvYWQpIHtcbiAgICAvLyBUT0RPOiBPbmx5IHJlc3RvcmUgbmVlZGVkIHNlcmllcyBhbmQgY29tcG9uZW50cywgYnV0IG5vdCBhbGwgY29tcG9uZW50cy5cbiAgICAvLyBDdXJyZW50bHkgYHJlc3RvcmVEYXRhYCBvZiBhbGwgb2YgdGhlIHNlcmllcyBhbmQgY29tcG9uZW50IHdpbGwgYmUgY2FsbGVkLlxuICAgIC8vIEJ1dCBzb21lIGluZGVwZW5kZW50IGNvbXBvbmVudHMgbGlrZSBgdGl0bGVgLCBgbGVnZW5kYCwgYGdyYXBoaWNgLCBgdG9vbGJveGAsXG4gICAgLy8gYHRvb2x0aXBgLCBgYXhpc1BvaW50ZXJgLCBldGMsIGRvIG5vdCBuZWVkIHNlcmllcyByZWZyZXNoIHdoZW4gYHNldE9wdGlvbmAsXG4gICAgLy8gYW5kIHNvbWUgY29tcG9uZW50cyBsaWtlIGNvb3JkaW5hdGUgc3lzdGVtLCBheGVzLCBkYXRhWm9vbSwgdmlzdWFsTWFwIG9ubHlcbiAgICAvLyBuZWVkIHRoZWlyIHRhcmdldCBzZXJpZXMgcmVmcmVzaC5cbiAgICAvLyAoMSkgSWYgd2UgYXJlIGltcGxlbWVudGluZyB0aGlzIGZlYXR1cmUgc29tZSBkYXksIHdlIHNob3VsZCBjb25zaWRlciB0aGVzZSBjYXNlczpcbiAgICAvLyBpZiBhIGRhdGEgcHJvY2Vzc29yIGRlcGVuZHMgb24gYSBjb21wb25lbnQgKGUuZy4sIGRhdGFab29tUHJvY2Vzc29yIGRlcGVuZHNcbiAgICAvLyBvbiB0aGUgc2V0dGluZ3Mgb2YgYGRhdGFab29tYCksIGl0IHNob3VsZCBiZSByZS1wZXJmb3JtZWQgaWYgdGhlIGNvbXBvbmVudFxuICAgIC8vIGlzIG1vZGlmaWVkIGJ5IGBzZXRPcHRpb25gLlxuICAgIC8vICgyKSBJZiBhIHByb2Nlc3NvciBkZXBlbmRzIG9uIHNldnJhbCBzZXJpZXMsIHNwZWljaWZpZWQgYnkgaXRzIGBnZXRUYXJnZXRTZXJpZXNgLFxuICAgIC8vIGl0IHNob3VsZCBiZSByZS1wZXJmb3JtZWQgd2hlbiB0aGUgcmVzdWx0IGFycmF5IG9mIGBnZXRUYXJnZXRTZXJpZXNgIGNoYW5nZWQuXG4gICAgLy8gV2UgdXNlIGBkZXBlbmRlbmNpZXNgIHRvIGNvdmVyIHRoZXNlIGlzc3Vlcy5cbiAgICAvLyAoMykgSG93IHRvIHVwZGF0ZSB0YXJnZXQgc2VyaWVzIHdoZW4gY29vcmRpbmF0ZSBzeXN0ZW0gcmVsYXRlZCBjb21wb25lbnRzIG1vZGlmaWVkLlxuICAgIC8vIFRPRE86IHNpbXBseSB0aGUgZGlydHkgbWVjaGFuaXNtPyBDaGVjayB3aGV0aGVyIG9ubHkgdGhlIGNhc2UgaGVyZSBjYW4gc2V0IHRhc2tzIGRpcnR5LFxuICAgIC8vIGFuZCB0aGlzIGNhc2UgYWxsIG9mIHRoZSB0YXNrcyB3aWxsIGJlIHNldCBhcyBkaXJ0eS5cbiAgICBlY01vZGVsLnJlc3RvcmVEYXRhKHBheWxvYWQpO1xuICAgIC8vIFRoZW9yZXRpY2FsbHkgYW4gb3ZlcmFsbCB0YXNrIG5vdCBvbmx5IGRlcGVuZHMgb24gZWFjaCBvZiBpdHMgdGFyZ2V0IHNlcmllcywgYnV0IGFsc29cbiAgICAvLyBkZXBlbmRzIG9uIGFsbCBvZiB0aGUgc2VyaWVzLlxuICAgIC8vIFRoZSBvdmVyYWxsIHRhc2sgaXMgbm90IGluIHBpcGVsaW5lLCBhbmQgYGVjTW9kZWwucmVzdG9yZURhdGFgIG9ubHkgc2V0IHBpcGVsaW5lIHRhc2tzXG4gICAgLy8gZGlydHkuIElmIGBnZXRUYXJnZXRTZXJpZXNgIG9mIGFuIG92ZXJhbGwgdGFzayByZXR1cm5zIG5vdGhpbmcsIHdlIHNob3VsZCBhbHNvIGVuc3VyZVxuICAgIC8vIHRoYXQgdGhlIG92ZXJhbGwgdGFzayBpcyBzZXQgYXMgZGlydHkgYW5kIHRvIGJlIHBlcmZvcm1lZCwgb3RoZXJ3aXNlIGl0IHByb2JhYmx5IGNhdXNlXG4gICAgLy8gc3RhdGUgY2hhb3MuIFNvIHdlIGhhdmUgdG8gc2V0IGRpcnR5IG9mIGFsbCBvZiB0aGUgb3ZlcmFsbCB0YXNrcyBtYW51YWxseSwgb3RoZXJ3aXNlIGl0XG4gICAgLy8gcHJvYmFibHkgY2F1c2Ugc3RhdGUgY2hhb3MgKGNvbnNpZGVyIGBkYXRhWm9vbVByb2Nlc3NvcmApLlxuICAgIHRoaXMuX3N0YWdlVGFza01hcC5lYWNoKGZ1bmN0aW9uICh0YXNrUmVjb3JkKSB7XG4gICAgICB2YXIgb3ZlcmFsbFRhc2sgPSB0YXNrUmVjb3JkLm92ZXJhbGxUYXNrO1xuICAgICAgb3ZlcmFsbFRhc2sgJiYgb3ZlcmFsbFRhc2suZGlydHkoKTtcbiAgICB9KTtcbiAgfTtcbiAgLy8gSWYgc2VyaWVzTW9kZWwgcHJvdmlkZWQsIGluY3JlbWVudGFsIHRocmVzaG9sZCBpcyBjaGVjayBieSBzZXJpZXMgZGF0YS5cbiAgU2NoZWR1bGVyLnByb3RvdHlwZS5nZXRQZXJmb3JtQXJncyA9IGZ1bmN0aW9uICh0YXNrLCBpc0Jsb2NrKSB7XG4gICAgLy8gRm9yIG92ZXJhbGwgdGFza1xuICAgIGlmICghdGFzay5fX3BpcGVsaW5lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwaXBlbGluZSA9IHRoaXMuX3BpcGVsaW5lTWFwLmdldCh0YXNrLl9fcGlwZWxpbmUuaWQpO1xuICAgIHZhciBwQ3R4ID0gcGlwZWxpbmUuY29udGV4dDtcbiAgICB2YXIgaW5jcmVtZW50YWwgPSAhaXNCbG9jayAmJiBwaXBlbGluZS5wcm9ncmVzc2l2ZUVuYWJsZWQgJiYgKCFwQ3R4IHx8IHBDdHgucHJvZ3Jlc3NpdmVSZW5kZXIpICYmIHRhc2suX19pZHhJblBpcGVsaW5lID4gcGlwZWxpbmUuYmxvY2tJbmRleDtcbiAgICB2YXIgc3RlcCA9IGluY3JlbWVudGFsID8gcGlwZWxpbmUuc3RlcCA6IG51bGw7XG4gICAgdmFyIG1vZERhdGFDb3VudCA9IHBDdHggJiYgcEN0eC5tb2REYXRhQ291bnQ7XG4gICAgdmFyIG1vZEJ5ID0gbW9kRGF0YUNvdW50ICE9IG51bGwgPyBNYXRoLmNlaWwobW9kRGF0YUNvdW50IC8gc3RlcCkgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBzdGVwOiBzdGVwLFxuICAgICAgbW9kQnk6IG1vZEJ5LFxuICAgICAgbW9kRGF0YUNvdW50OiBtb2REYXRhQ291bnRcbiAgICB9O1xuICB9O1xuICBTY2hlZHVsZXIucHJvdG90eXBlLmdldFBpcGVsaW5lID0gZnVuY3Rpb24gKHBpcGVsaW5lSWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcGlwZWxpbmVNYXAuZ2V0KHBpcGVsaW5lSWQpO1xuICB9O1xuICAvKipcclxuICAgKiBDdXJyZW50LCBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgc3RhcnRzIGZyb20gdmlzdWFsIGFuZCBsYXlvdXQuXHJcbiAgICogQWx3YXlzIGRldGVjdCByZW5kZXIgbW9kZSBpbiB0aGUgc2FtZSBzdGFnZSwgYXZvaWRpbmcgdGhhdCBpbmNvcnJlY3RcclxuICAgKiBkZXRlY3Rpb24gY2F1c2VkIGJ5IGRhdGEgZmlsdGVyaW5nLlxyXG4gICAqIENhdXRpb246XHJcbiAgICogYHVwZGF0ZVN0cmVhbU1vZGVzYCB1c2UgYHNlcmllc01vZGVsLmdldERhdGEoKWAuXHJcbiAgICovXG4gIFNjaGVkdWxlci5wcm90b3R5cGUudXBkYXRlU3RyZWFtTW9kZXMgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIHZpZXcpIHtcbiAgICB2YXIgcGlwZWxpbmUgPSB0aGlzLl9waXBlbGluZU1hcC5nZXQoc2VyaWVzTW9kZWwudWlkKTtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgZGF0YUxlbiA9IGRhdGEuY291bnQoKTtcbiAgICAvLyBgcHJvZ3Jlc3NpdmVSZW5kZXJgIG1lYW5zIHRoYXQgY2FuIHJlbmRlciBwcm9ncmVzc2l2ZWx5IGluIGVhY2hcbiAgICAvLyBhbmltYXRpb24gZnJhbWUuIE5vdGUgdGhhdCBzb21lIHR5cGVzIG9mIHNlcmllcyBkbyBub3QgcHJvdmlkZVxuICAgIC8vIGB2aWV3LmluY3JlbWVudGFsUHJlcGFyZVJlbmRlcmAgYnV0IHN1cHBvcnQgYGNoYXJ0LmFwcGVuZERhdGFgLiBXZVxuICAgIC8vIHVzZSB0aGUgdGVybSBgaW5jcmVtZW50YWxgIGJ1dCBub3QgYHByb2dyZXNzaXZlYCB0byBkZXNjcmliZSB0aGVcbiAgICAvLyBjYXNlIHRoYXQgYGNoYXJ0LmFwcGVuZERhdGFgLlxuICAgIHZhciBwcm9ncmVzc2l2ZVJlbmRlciA9IHBpcGVsaW5lLnByb2dyZXNzaXZlRW5hYmxlZCAmJiB2aWV3LmluY3JlbWVudGFsUHJlcGFyZVJlbmRlciAmJiBkYXRhTGVuID49IHBpcGVsaW5lLnRocmVzaG9sZDtcbiAgICB2YXIgbGFyZ2UgPSBzZXJpZXNNb2RlbC5nZXQoJ2xhcmdlJykgJiYgZGF0YUxlbiA+PSBzZXJpZXNNb2RlbC5nZXQoJ2xhcmdlVGhyZXNob2xkJyk7XG4gICAgLy8gVE9ETzogbW9kRGF0YUNvdW50IHNob3VsZCBub3QgdXBkYXRlZCBpZiBgYXBwZW5kRGF0YWAsIG90aGVyd2lzZSBjYXVzZSB3aG9sZSByZXBhaW50LlxuICAgIC8vIHNlZSBgdGVzdC9jYW5kbGVzdGljay1sYXJnZTMuaHRtbGBcbiAgICB2YXIgbW9kRGF0YUNvdW50ID0gc2VyaWVzTW9kZWwuZ2V0KCdwcm9ncmVzc2l2ZUNodW5rTW9kZScpID09PSAnbW9kJyA/IGRhdGFMZW4gOiBudWxsO1xuICAgIHNlcmllc01vZGVsLnBpcGVsaW5lQ29udGV4dCA9IHBpcGVsaW5lLmNvbnRleHQgPSB7XG4gICAgICBwcm9ncmVzc2l2ZVJlbmRlcjogcHJvZ3Jlc3NpdmVSZW5kZXIsXG4gICAgICBtb2REYXRhQ291bnQ6IG1vZERhdGFDb3VudCxcbiAgICAgIGxhcmdlOiBsYXJnZVxuICAgIH07XG4gIH07XG4gIFNjaGVkdWxlci5wcm90b3R5cGUucmVzdG9yZVBpcGVsaW5lcyA9IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIHNjaGVkdWxlciA9IHRoaXM7XG4gICAgdmFyIHBpcGVsaW5lTWFwID0gc2NoZWR1bGVyLl9waXBlbGluZU1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgcHJvZ3Jlc3NpdmUgPSBzZXJpZXNNb2RlbC5nZXRQcm9ncmVzc2l2ZSgpO1xuICAgICAgdmFyIHBpcGVsaW5lSWQgPSBzZXJpZXNNb2RlbC51aWQ7XG4gICAgICBwaXBlbGluZU1hcC5zZXQocGlwZWxpbmVJZCwge1xuICAgICAgICBpZDogcGlwZWxpbmVJZCxcbiAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgdGFpbDogbnVsbCxcbiAgICAgICAgdGhyZXNob2xkOiBzZXJpZXNNb2RlbC5nZXRQcm9ncmVzc2l2ZVRocmVzaG9sZCgpLFxuICAgICAgICBwcm9ncmVzc2l2ZUVuYWJsZWQ6IHByb2dyZXNzaXZlICYmICEoc2VyaWVzTW9kZWwucHJldmVudEluY3JlbWVudGFsICYmIHNlcmllc01vZGVsLnByZXZlbnRJbmNyZW1lbnRhbCgpKSxcbiAgICAgICAgYmxvY2tJbmRleDogLTEsXG4gICAgICAgIHN0ZXA6IE1hdGgucm91bmQocHJvZ3Jlc3NpdmUgfHwgNzAwKSxcbiAgICAgICAgY291bnQ6IDBcbiAgICAgIH0pO1xuICAgICAgc2NoZWR1bGVyLl9waXBlKHNlcmllc01vZGVsLCBzZXJpZXNNb2RlbC5kYXRhVGFzayk7XG4gICAgfSk7XG4gIH07XG4gIFNjaGVkdWxlci5wcm90b3R5cGUucHJlcGFyZVN0YWdlVGFza3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWdlVGFza01hcCA9IHRoaXMuX3N0YWdlVGFza01hcDtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuYXBpLmdldE1vZGVsKCk7XG4gICAgdmFyIGFwaSA9IHRoaXMuYXBpO1xuICAgIGVhY2godGhpcy5fYWxsSGFuZGxlcnMsIGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICB2YXIgcmVjb3JkID0gc3RhZ2VUYXNrTWFwLmdldChoYW5kbGVyLnVpZCkgfHwgc3RhZ2VUYXNrTWFwLnNldChoYW5kbGVyLnVpZCwge30pO1xuICAgICAgdmFyIGVyck1zZyA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gQ3VycmVudGx5IGRvIG5vdCBuZWVkIHRvIHN1cHBvcnQgdG8gc2VwZWNpZnkgdGhlbSBib3RoLlxuICAgICAgICBlcnJNc2cgPSAnXCJyZXNldFwiIGFuZCBcIm92ZXJhbGxSZXNldFwiIG11c3Qgbm90IGJlIGJvdGggc3BlY2lmaWVkLic7XG4gICAgICB9XG4gICAgICBhc3NlcnQoIShoYW5kbGVyLnJlc2V0ICYmIGhhbmRsZXIub3ZlcmFsbFJlc2V0KSwgZXJyTXNnKTtcbiAgICAgIGhhbmRsZXIucmVzZXQgJiYgdGhpcy5fY3JlYXRlU2VyaWVzU3RhZ2VUYXNrKGhhbmRsZXIsIHJlY29yZCwgZWNNb2RlbCwgYXBpKTtcbiAgICAgIGhhbmRsZXIub3ZlcmFsbFJlc2V0ICYmIHRoaXMuX2NyZWF0ZU92ZXJhbGxTdGFnZVRhc2soaGFuZGxlciwgcmVjb3JkLCBlY01vZGVsLCBhcGkpO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuICBTY2hlZHVsZXIucHJvdG90eXBlLnByZXBhcmVWaWV3ID0gZnVuY3Rpb24gKHZpZXcsIG1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgcmVuZGVyVGFzayA9IHZpZXcucmVuZGVyVGFzaztcbiAgICB2YXIgY29udGV4dCA9IHJlbmRlclRhc2suY29udGV4dDtcbiAgICBjb250ZXh0Lm1vZGVsID0gbW9kZWw7XG4gICAgY29udGV4dC5lY01vZGVsID0gZWNNb2RlbDtcbiAgICBjb250ZXh0LmFwaSA9IGFwaTtcbiAgICByZW5kZXJUYXNrLl9fYmxvY2sgPSAhdmlldy5pbmNyZW1lbnRhbFByZXBhcmVSZW5kZXI7XG4gICAgdGhpcy5fcGlwZShtb2RlbCwgcmVuZGVyVGFzayk7XG4gIH07XG4gIFNjaGVkdWxlci5wcm90b3R5cGUucGVyZm9ybURhdGFQcm9jZXNzb3JUYXNrcyA9IGZ1bmN0aW9uIChlY01vZGVsLCBwYXlsb2FkKSB7XG4gICAgLy8gSWYgd2UgZG8gbm90IHVzZSBgYmxvY2tgIGhlcmUsIGl0IHNob3VsZCBiZSBjb25zaWRlcmVkIHdoZW4gdG8gdXBkYXRlIG1vZGVzLlxuICAgIHRoaXMuX3BlcmZvcm1TdGFnZVRhc2tzKHRoaXMuX2RhdGFQcm9jZXNzb3JIYW5kbGVycywgZWNNb2RlbCwgcGF5bG9hZCwge1xuICAgICAgYmxvY2s6IHRydWVcbiAgICB9KTtcbiAgfTtcbiAgU2NoZWR1bGVyLnByb3RvdHlwZS5wZXJmb3JtVmlzdWFsVGFza3MgPSBmdW5jdGlvbiAoZWNNb2RlbCwgcGF5bG9hZCwgb3B0KSB7XG4gICAgdGhpcy5fcGVyZm9ybVN0YWdlVGFza3ModGhpcy5fdmlzdWFsSGFuZGxlcnMsIGVjTW9kZWwsIHBheWxvYWQsIG9wdCk7XG4gIH07XG4gIFNjaGVkdWxlci5wcm90b3R5cGUuX3BlcmZvcm1TdGFnZVRhc2tzID0gZnVuY3Rpb24gKHN0YWdlSGFuZGxlcnMsIGVjTW9kZWwsIHBheWxvYWQsIG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICB2YXIgdW5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzO1xuICAgIGVhY2goc3RhZ2VIYW5kbGVycywgZnVuY3Rpb24gKHN0YWdlSGFuZGxlciwgaWR4KSB7XG4gICAgICBpZiAob3B0LnZpc3VhbFR5cGUgJiYgb3B0LnZpc3VhbFR5cGUgIT09IHN0YWdlSGFuZGxlci52aXN1YWxUeXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdGFnZUhhbmRsZXJSZWNvcmQgPSBzY2hlZHVsZXIuX3N0YWdlVGFza01hcC5nZXQoc3RhZ2VIYW5kbGVyLnVpZCk7XG4gICAgICB2YXIgc2VyaWVzVGFza01hcCA9IHN0YWdlSGFuZGxlclJlY29yZC5zZXJpZXNUYXNrTWFwO1xuICAgICAgdmFyIG92ZXJhbGxUYXNrID0gc3RhZ2VIYW5kbGVyUmVjb3JkLm92ZXJhbGxUYXNrO1xuICAgICAgaWYgKG92ZXJhbGxUYXNrKSB7XG4gICAgICAgIHZhciBvdmVyYWxsTmVlZERpcnR5XzE7XG4gICAgICAgIHZhciBhZ2VudFN0dWJNYXAgPSBvdmVyYWxsVGFzay5hZ2VudFN0dWJNYXA7XG4gICAgICAgIGFnZW50U3R1Yk1hcC5lYWNoKGZ1bmN0aW9uIChzdHViKSB7XG4gICAgICAgICAgaWYgKG5lZWRTZXREaXJ0eShvcHQsIHN0dWIpKSB7XG4gICAgICAgICAgICBzdHViLmRpcnR5KCk7XG4gICAgICAgICAgICBvdmVyYWxsTmVlZERpcnR5XzEgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG92ZXJhbGxOZWVkRGlydHlfMSAmJiBvdmVyYWxsVGFzay5kaXJ0eSgpO1xuICAgICAgICBzY2hlZHVsZXIudXBkYXRlUGF5bG9hZChvdmVyYWxsVGFzaywgcGF5bG9hZCk7XG4gICAgICAgIHZhciBwZXJmb3JtQXJnc18xID0gc2NoZWR1bGVyLmdldFBlcmZvcm1BcmdzKG92ZXJhbGxUYXNrLCBvcHQuYmxvY2spO1xuICAgICAgICAvLyBFeGVjdXRlIHN0dWJzIGZpcnN0bHksIHdoaWNoIG1heSBzZXQgdGhlIG92ZXJhbGwgdGFzayBkaXJ0eSxcbiAgICAgICAgLy8gdGhlbiBleGVjdXRlIHRoZSBvdmVyYWxsIHRhc2suIEFuZCBzdHViIHdpbGwgY2FsbCBzZXJpZXNNb2RlbC5zZXREYXRhLFxuICAgICAgICAvLyB3aGljaCBlbnN1cmVzIHRoYXQgaW4gdGhlIG92ZXJhbGxUYXNrIHNlcmllc01vZGVsLmdldERhdGEoKSB3aWxsIG5vdFxuICAgICAgICAvLyByZXR1cm4gaW5jb3JyZWN0IGRhdGEuXG4gICAgICAgIGFnZW50U3R1Yk1hcC5lYWNoKGZ1bmN0aW9uIChzdHViKSB7XG4gICAgICAgICAgc3R1Yi5wZXJmb3JtKHBlcmZvcm1BcmdzXzEpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG92ZXJhbGxUYXNrLnBlcmZvcm0ocGVyZm9ybUFyZ3NfMSkpIHtcbiAgICAgICAgICB1bmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzZXJpZXNUYXNrTWFwKSB7XG4gICAgICAgIHNlcmllc1Rhc2tNYXAuZWFjaChmdW5jdGlvbiAodGFzaywgcGlwZWxpbmVJZCkge1xuICAgICAgICAgIGlmIChuZWVkU2V0RGlydHkob3B0LCB0YXNrKSkge1xuICAgICAgICAgICAgdGFzay5kaXJ0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcGVyZm9ybUFyZ3MgPSBzY2hlZHVsZXIuZ2V0UGVyZm9ybUFyZ3ModGFzaywgb3B0LmJsb2NrKTtcbiAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgIC8vIGlmIGludGVuZGluZyB0byBkZWNsYXJlIGBwZXJmb3JtUmF3U2VyaWVzYCBpbiBoYW5kbGVycywgb25seVxuICAgICAgICAgIC8vIHN0cmVhbS1pbmRlcGVuZGVudCAoc3BlY2lmaWNhbGx5LCBkYXRhIGl0ZW0gaW5kZXBlbmRlbnQpIG9wZXJhdGlvbnMgY2FuIGJlXG4gICAgICAgICAgLy8gcGVyZm9ybWVkLiBCZWNhdXNlIGlmIGEgc2VyaWVzIGlzIGZpbHRlcmVkLCBtb3N0IG9mIHRoZSB0YXNrcyB3aWxsIG5vdFxuICAgICAgICAgIC8vIGJlIHBlcmZvcm1lZC4gQSBzdHJlYW0tZGVwZW5kZW50IG9wZXJhdGlvbiBwcm9iYWJseSBjYXVzZSB3cm9uZyBiaXogbG9naWMuXG4gICAgICAgICAgLy8gUGVyaGFwcyB3ZSBzaG91bGQgbm90IHByb3ZpZGUgYSBzZXBhcmF0ZSBjYWxsYmFjayBmb3IgdGhpcyBjYXNlIGluc3RlYWRcbiAgICAgICAgICAvLyBvZiBwcm92aWRpbmcgdGhlIGNvbmZpZyBgcGVyZm9ybVJhd1Nlcmllc2AuIFRoZSBzdHJlYW0tZGVwZW5kZW50IG9wZXJhdGlvbnNcbiAgICAgICAgICAvLyBhbmQgc3RyZWFtLWluZGVwZW5kZW50IG9wZXJhdGlvbnMgc2hvdWxkIGJldHRlciBub3QgYmUgbWl4ZWQuXG4gICAgICAgICAgcGVyZm9ybUFyZ3Muc2tpcCA9ICFzdGFnZUhhbmRsZXIucGVyZm9ybVJhd1NlcmllcyAmJiBlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQodGFzay5jb250ZXh0Lm1vZGVsKTtcbiAgICAgICAgICBzY2hlZHVsZXIudXBkYXRlUGF5bG9hZCh0YXNrLCBwYXlsb2FkKTtcbiAgICAgICAgICBpZiAodGFzay5wZXJmb3JtKHBlcmZvcm1BcmdzKSkge1xuICAgICAgICAgICAgdW5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBuZWVkU2V0RGlydHkob3B0LCB0YXNrKSB7XG4gICAgICByZXR1cm4gb3B0LnNldERpcnR5ICYmICghb3B0LmRpcnR5TWFwIHx8IG9wdC5kaXJ0eU1hcC5nZXQodGFzay5fX3BpcGVsaW5lLmlkKSk7XG4gICAgfVxuICAgIHRoaXMudW5maW5pc2hlZCA9IHVuZmluaXNoZWQgfHwgdGhpcy51bmZpbmlzaGVkO1xuICB9O1xuICBTY2hlZHVsZXIucHJvdG90eXBlLnBlcmZvcm1TZXJpZXNUYXNrcyA9IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgdmFyIHVuZmluaXNoZWQ7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgLy8gUHJvZ3Jlc3MgdG8gdGhlIGVuZCBmb3IgZGF0YUluaXQgYW5kIGRhdGFSZXN0b3JlLlxuICAgICAgdW5maW5pc2hlZCA9IHNlcmllc01vZGVsLmRhdGFUYXNrLnBlcmZvcm0oKSB8fCB1bmZpbmlzaGVkO1xuICAgIH0pO1xuICAgIHRoaXMudW5maW5pc2hlZCA9IHVuZmluaXNoZWQgfHwgdGhpcy51bmZpbmlzaGVkO1xuICB9O1xuICBTY2hlZHVsZXIucHJvdG90eXBlLnBsYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVHJhdmVsIHBpcGVsaW5lcywgY2hlY2sgYmxvY2suXG4gICAgdGhpcy5fcGlwZWxpbmVNYXAuZWFjaChmdW5jdGlvbiAocGlwZWxpbmUpIHtcbiAgICAgIHZhciB0YXNrID0gcGlwZWxpbmUudGFpbDtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHRhc2suX19ibG9jaykge1xuICAgICAgICAgIHBpcGVsaW5lLmJsb2NrSW5kZXggPSB0YXNrLl9faWR4SW5QaXBlbGluZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0YXNrID0gdGFzay5nZXRVcHN0cmVhbSgpO1xuICAgICAgfSB3aGlsZSAodGFzayk7XG4gICAgfSk7XG4gIH07XG4gIFNjaGVkdWxlci5wcm90b3R5cGUudXBkYXRlUGF5bG9hZCA9IGZ1bmN0aW9uICh0YXNrLCBwYXlsb2FkKSB7XG4gICAgcGF5bG9hZCAhPT0gJ3JlbWFpbicgJiYgKHRhc2suY29udGV4dC5wYXlsb2FkID0gcGF5bG9hZCk7XG4gIH07XG4gIFNjaGVkdWxlci5wcm90b3R5cGUuX2NyZWF0ZVNlcmllc1N0YWdlVGFzayA9IGZ1bmN0aW9uIChzdGFnZUhhbmRsZXIsIHN0YWdlSGFuZGxlclJlY29yZCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIHNjaGVkdWxlciA9IHRoaXM7XG4gICAgdmFyIG9sZFNlcmllc1Rhc2tNYXAgPSBzdGFnZUhhbmRsZXJSZWNvcmQuc2VyaWVzVGFza01hcDtcbiAgICAvLyBUaGUgY291bnQgb2Ygc3RhZ2VzIGFyZSB0b3RhbGx5IGFib3V0IG9ubHkgc2V2ZXJhbCBkb3plbiwgc29cbiAgICAvLyBkbyBub3QgbmVlZCB0byByZXVzZSB0aGUgbWFwLlxuICAgIHZhciBuZXdTZXJpZXNUYXNrTWFwID0gc3RhZ2VIYW5kbGVyUmVjb3JkLnNlcmllc1Rhc2tNYXAgPSBjcmVhdGVIYXNoTWFwKCk7XG4gICAgdmFyIHNlcmllc1R5cGUgPSBzdGFnZUhhbmRsZXIuc2VyaWVzVHlwZTtcbiAgICB2YXIgZ2V0VGFyZ2V0U2VyaWVzID0gc3RhZ2VIYW5kbGVyLmdldFRhcmdldFNlcmllcztcbiAgICAvLyBJZiBhIHN0YWdlSGFuZGxlciBzaG91bGQgY292ZXIgYWxsIHNlcmllcywgYGNyZWF0ZU9uQWxsU2VyaWVzYCBzaG91bGQgYmUgZGVjbGFyZWQgbWFuZGF0b3JpbHksXG4gICAgLy8gdG8gYXZvaWQgc29tZSB0eXBvIG9yIGFidXNlLiBPdGhlcndpc2UgaWYgYW4gZXh0ZW5zaW9uIGRvIG5vdCBzcGVjaWZ5IGEgYHNlcmllc1R5cGVgLFxuICAgIC8vIGl0IHdvcmtzIGJ1dCBpdCBtYXkgY2F1c2Ugb3RoZXIgaXJyZWxldmFudCBjaGFydHMgYmxvY2tlZC5cbiAgICBpZiAoc3RhZ2VIYW5kbGVyLmNyZWF0ZU9uQWxsU2VyaWVzKSB7XG4gICAgICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoY3JlYXRlKTtcbiAgICB9IGVsc2UgaWYgKHNlcmllc1R5cGUpIHtcbiAgICAgIGVjTW9kZWwuZWFjaFJhd1Nlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBjcmVhdGUpO1xuICAgIH0gZWxzZSBpZiAoZ2V0VGFyZ2V0U2VyaWVzKSB7XG4gICAgICBnZXRUYXJnZXRTZXJpZXMoZWNNb2RlbCwgYXBpKS5lYWNoKGNyZWF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZShzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIHBpcGVsaW5lSWQgPSBzZXJpZXNNb2RlbC51aWQ7XG4gICAgICAvLyBJbml0IHRhc2tzIGZvciBlYWNoIHNlcmllc01vZGVsIG9ubHkgb25jZS5cbiAgICAgIC8vIFJldXNlIG9yaWdpbmFsIHRhc2sgaW5zdGFuY2UuXG4gICAgICB2YXIgdGFzayA9IG5ld1Nlcmllc1Rhc2tNYXAuc2V0KHBpcGVsaW5lSWQsIG9sZFNlcmllc1Rhc2tNYXAgJiYgb2xkU2VyaWVzVGFza01hcC5nZXQocGlwZWxpbmVJZCkgfHwgY3JlYXRlVGFzayh7XG4gICAgICAgIHBsYW46IHNlcmllc1Rhc2tQbGFuLFxuICAgICAgICByZXNldDogc2VyaWVzVGFza1Jlc2V0LFxuICAgICAgICBjb3VudDogc2VyaWVzVGFza0NvdW50XG4gICAgICB9KSk7XG4gICAgICB0YXNrLmNvbnRleHQgPSB7XG4gICAgICAgIG1vZGVsOiBzZXJpZXNNb2RlbCxcbiAgICAgICAgZWNNb2RlbDogZWNNb2RlbCxcbiAgICAgICAgYXBpOiBhcGksXG4gICAgICAgIC8vIFBFTkRJTkc6IGB1c2VDbGVhclZpc3VhbGAgbm90IHVzZWQ/XG4gICAgICAgIHVzZUNsZWFyVmlzdWFsOiBzdGFnZUhhbmRsZXIuaXNWaXN1YWwgJiYgIXN0YWdlSGFuZGxlci5pc0xheW91dCxcbiAgICAgICAgcGxhbjogc3RhZ2VIYW5kbGVyLnBsYW4sXG4gICAgICAgIHJlc2V0OiBzdGFnZUhhbmRsZXIucmVzZXQsXG4gICAgICAgIHNjaGVkdWxlcjogc2NoZWR1bGVyXG4gICAgICB9O1xuICAgICAgc2NoZWR1bGVyLl9waXBlKHNlcmllc01vZGVsLCB0YXNrKTtcbiAgICB9XG4gIH07XG4gIFNjaGVkdWxlci5wcm90b3R5cGUuX2NyZWF0ZU92ZXJhbGxTdGFnZVRhc2sgPSBmdW5jdGlvbiAoc3RhZ2VIYW5kbGVyLCBzdGFnZUhhbmRsZXJSZWNvcmQsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzO1xuICAgIHZhciBvdmVyYWxsVGFzayA9IHN0YWdlSGFuZGxlclJlY29yZC5vdmVyYWxsVGFzayA9IHN0YWdlSGFuZGxlclJlY29yZC5vdmVyYWxsVGFza1xuICAgIC8vIEZvciBvdmVyYWxsIHRhc2ssIHRoZSBmdW5jdGlvbiBvbmx5IGJlIGNhbGxlZCBvbiByZXNldCBzdGFnZS5cbiAgICB8fCBjcmVhdGVUYXNrKHtcbiAgICAgIHJlc2V0OiBvdmVyYWxsVGFza1Jlc2V0XG4gICAgfSk7XG4gICAgb3ZlcmFsbFRhc2suY29udGV4dCA9IHtcbiAgICAgIGVjTW9kZWw6IGVjTW9kZWwsXG4gICAgICBhcGk6IGFwaSxcbiAgICAgIG92ZXJhbGxSZXNldDogc3RhZ2VIYW5kbGVyLm92ZXJhbGxSZXNldCxcbiAgICAgIHNjaGVkdWxlcjogc2NoZWR1bGVyXG4gICAgfTtcbiAgICB2YXIgb2xkQWdlbnRTdHViTWFwID0gb3ZlcmFsbFRhc2suYWdlbnRTdHViTWFwO1xuICAgIC8vIFRoZSBjb3VudCBvZiBzdGFnZXMgYXJlIHRvdGFsbHkgYWJvdXQgb25seSBzZXZlcmFsIGRvemVuLCBzb1xuICAgIC8vIGRvIG5vdCBuZWVkIHRvIHJldXNlIHRoZSBtYXAuXG4gICAgdmFyIG5ld0FnZW50U3R1Yk1hcCA9IG92ZXJhbGxUYXNrLmFnZW50U3R1Yk1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgICB2YXIgc2VyaWVzVHlwZSA9IHN0YWdlSGFuZGxlci5zZXJpZXNUeXBlO1xuICAgIHZhciBnZXRUYXJnZXRTZXJpZXMgPSBzdGFnZUhhbmRsZXIuZ2V0VGFyZ2V0U2VyaWVzO1xuICAgIHZhciBvdmVyYWxsUHJvZ3Jlc3MgPSB0cnVlO1xuICAgIHZhciBzaG91bGRPdmVyYWxsVGFza0RpcnR5ID0gZmFsc2U7XG4gICAgLy8gRklYTUU6VFMgbmV2ZXIgdXNlZCwgc28gY29tbWVudCBpdFxuICAgIC8vIGxldCBtb2RpZnlPdXRwdXRFbmQgPSBzdGFnZUhhbmRsZXIubW9kaWZ5T3V0cHV0RW5kO1xuICAgIC8vIEFuIG92ZXJhbGwgdGFzayB3aXRoIHNlcmllc1R5cGUgZGV0ZWN0ZWQgb3IgaGFzIGBnZXRUYXJnZXRTZXJpZXNgLCB3ZSBhZGRcbiAgICAvLyBzdHViIGluIGVhY2ggcGlwZWxpbmVzLCBpdCB3aWxsIHNldCB0aGUgb3ZlcmFsbCB0YXNrIGRpcnR5IHdoZW4gdGhlIHBpcGVsaW5lXG4gICAgLy8gcHJvZ3Jlc3MuIE1vcmVvdmVyLCB0byBhdm9pZCBjYWxsIHRoZSBvdmVyYWxsIHRhc2sgZWFjaCBmcmFtZSAodG9vIGZyZXF1ZW50KSxcbiAgICAvLyB3ZSBzZXQgdGhlIHBpcGVsaW5lIGJsb2NrLlxuICAgIHZhciBlcnJNc2cgPSAnJztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZXJyTXNnID0gJ1wiY3JlYXRlT25BbGxTZXJpZXNcIiBpcyBub3Qgc3VwcG9ydGVkIGZvciBcIm92ZXJhbGxSZXNldFwiLCAnICsgJ2JlY2F1c2UgaXQgd2lsbCBibG9jayBhbGwgc3RyZWFtcy4nO1xuICAgIH1cbiAgICBhc3NlcnQoIXN0YWdlSGFuZGxlci5jcmVhdGVPbkFsbFNlcmllcywgZXJyTXNnKTtcbiAgICBpZiAoc2VyaWVzVHlwZSkge1xuICAgICAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGNyZWF0ZVN0dWIpO1xuICAgIH0gZWxzZSBpZiAoZ2V0VGFyZ2V0U2VyaWVzKSB7XG4gICAgICBnZXRUYXJnZXRTZXJpZXMoZWNNb2RlbCwgYXBpKS5lYWNoKGNyZWF0ZVN0dWIpO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsICh1c3VhbGx5IGl0IGlzIGxlZ2FjeSBjYXNlKSwgdGhlIG92ZXJhbGwgdGFzayB3aWxsIG9ubHkgYmVcbiAgICAvLyBleGVjdXRlZCB3aGVuIHVwc3RyZWFtIGlzIGRpcnR5LiBPdGhlcndpc2UgdGhlIHByb2dyZXNzaXZlIHJlbmRlcmluZyBvZiBhbGxcbiAgICAvLyBwaXBlbGluZXMgd2lsbCBiZSBkaXNhYmxlZCB1bmV4cGVjdGVkbHkuIEJ1dCBpdCBzdGlsbCBuZWVkcyBzdHVicyB0byByZWNlaXZlXG4gICAgLy8gZGlydHkgaW5mbyBmcm9tIHVwc3RyZWFtLlxuICAgIGVsc2Uge1xuICAgICAgb3ZlcmFsbFByb2dyZXNzID0gZmFsc2U7XG4gICAgICBlYWNoKGVjTW9kZWwuZ2V0U2VyaWVzKCksIGNyZWF0ZVN0dWIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVTdHViKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgcGlwZWxpbmVJZCA9IHNlcmllc01vZGVsLnVpZDtcbiAgICAgIHZhciBzdHViID0gbmV3QWdlbnRTdHViTWFwLnNldChwaXBlbGluZUlkLCBvbGRBZ2VudFN0dWJNYXAgJiYgb2xkQWdlbnRTdHViTWFwLmdldChwaXBlbGluZUlkKSB8fCAoXG4gICAgICAvLyBXaGVuIHRoZSByZXN1bHQgb2YgYGdldFRhcmdldFNlcmllc2AgY2hhbmdlZCwgdGhlIG92ZXJhbGxUYXNrXG4gICAgICAvLyBzaG91bGQgYmUgc2V0IGFzIGRpcnR5IGFuZCByZS1wZXJmb3JtZWQuXG4gICAgICBzaG91bGRPdmVyYWxsVGFza0RpcnR5ID0gdHJ1ZSwgY3JlYXRlVGFzayh7XG4gICAgICAgIHJlc2V0OiBzdHViUmVzZXQsXG4gICAgICAgIG9uRGlydHk6IHN0dWJPbkRpcnR5XG4gICAgICB9KSkpO1xuICAgICAgc3R1Yi5jb250ZXh0ID0ge1xuICAgICAgICBtb2RlbDogc2VyaWVzTW9kZWwsXG4gICAgICAgIG92ZXJhbGxQcm9ncmVzczogb3ZlcmFsbFByb2dyZXNzXG4gICAgICAgIC8vIEZJWE1FOlRTIG5ldmVyIHVzZWQsIHNvIGNvbW1lbnQgaXRcbiAgICAgICAgLy8gbW9kaWZ5T3V0cHV0RW5kOiBtb2RpZnlPdXRwdXRFbmRcbiAgICAgIH07XG4gICAgICBzdHViLmFnZW50ID0gb3ZlcmFsbFRhc2s7XG4gICAgICBzdHViLl9fYmxvY2sgPSBvdmVyYWxsUHJvZ3Jlc3M7XG4gICAgICBzY2hlZHVsZXIuX3BpcGUoc2VyaWVzTW9kZWwsIHN0dWIpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkT3ZlcmFsbFRhc2tEaXJ0eSkge1xuICAgICAgb3ZlcmFsbFRhc2suZGlydHkoKTtcbiAgICB9XG4gIH07XG4gIFNjaGVkdWxlci5wcm90b3R5cGUuX3BpcGUgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIHRhc2spIHtcbiAgICB2YXIgcGlwZWxpbmVJZCA9IHNlcmllc01vZGVsLnVpZDtcbiAgICB2YXIgcGlwZWxpbmUgPSB0aGlzLl9waXBlbGluZU1hcC5nZXQocGlwZWxpbmVJZCk7XG4gICAgIXBpcGVsaW5lLmhlYWQgJiYgKHBpcGVsaW5lLmhlYWQgPSB0YXNrKTtcbiAgICBwaXBlbGluZS50YWlsICYmIHBpcGVsaW5lLnRhaWwucGlwZSh0YXNrKTtcbiAgICBwaXBlbGluZS50YWlsID0gdGFzaztcbiAgICB0YXNrLl9faWR4SW5QaXBlbGluZSA9IHBpcGVsaW5lLmNvdW50Kys7XG4gICAgdGFzay5fX3BpcGVsaW5lID0gcGlwZWxpbmU7XG4gIH07XG4gIFNjaGVkdWxlci53cmFwU3RhZ2VIYW5kbGVyID0gZnVuY3Rpb24gKHN0YWdlSGFuZGxlciwgdmlzdWFsVHlwZSkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHN0YWdlSGFuZGxlcikpIHtcbiAgICAgIHN0YWdlSGFuZGxlciA9IHtcbiAgICAgICAgb3ZlcmFsbFJlc2V0OiBzdGFnZUhhbmRsZXIsXG4gICAgICAgIHNlcmllc1R5cGU6IGRldGVjdFNlcmlzZVR5cGUoc3RhZ2VIYW5kbGVyKVxuICAgICAgfTtcbiAgICB9XG4gICAgc3RhZ2VIYW5kbGVyLnVpZCA9IGdldFVJRCgnc3RhZ2VIYW5kbGVyJyk7XG4gICAgdmlzdWFsVHlwZSAmJiAoc3RhZ2VIYW5kbGVyLnZpc3VhbFR5cGUgPSB2aXN1YWxUeXBlKTtcbiAgICByZXR1cm4gc3RhZ2VIYW5kbGVyO1xuICB9O1xuICA7XG4gIHJldHVybiBTY2hlZHVsZXI7XG59KCk7XG5mdW5jdGlvbiBvdmVyYWxsVGFza1Jlc2V0KGNvbnRleHQpIHtcbiAgY29udGV4dC5vdmVyYWxsUmVzZXQoY29udGV4dC5lY01vZGVsLCBjb250ZXh0LmFwaSwgY29udGV4dC5wYXlsb2FkKTtcbn1cbmZ1bmN0aW9uIHN0dWJSZXNldChjb250ZXh0KSB7XG4gIHJldHVybiBjb250ZXh0Lm92ZXJhbGxQcm9ncmVzcyAmJiBzdHViUHJvZ3Jlc3M7XG59XG5mdW5jdGlvbiBzdHViUHJvZ3Jlc3MoKSB7XG4gIHRoaXMuYWdlbnQuZGlydHkoKTtcbiAgdGhpcy5nZXREb3duc3RyZWFtKCkuZGlydHkoKTtcbn1cbmZ1bmN0aW9uIHN0dWJPbkRpcnR5KCkge1xuICB0aGlzLmFnZW50ICYmIHRoaXMuYWdlbnQuZGlydHkoKTtcbn1cbmZ1bmN0aW9uIHNlcmllc1Rhc2tQbGFuKGNvbnRleHQpIHtcbiAgcmV0dXJuIGNvbnRleHQucGxhbiA/IGNvbnRleHQucGxhbihjb250ZXh0Lm1vZGVsLCBjb250ZXh0LmVjTW9kZWwsIGNvbnRleHQuYXBpLCBjb250ZXh0LnBheWxvYWQpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHNlcmllc1Rhc2tSZXNldChjb250ZXh0KSB7XG4gIGlmIChjb250ZXh0LnVzZUNsZWFyVmlzdWFsKSB7XG4gICAgY29udGV4dC5kYXRhLmNsZWFyQWxsVmlzdWFsKCk7XG4gIH1cbiAgdmFyIHJlc2V0RGVmaW5lcyA9IGNvbnRleHQucmVzZXREZWZpbmVzID0gbm9ybWFsaXplVG9BcnJheShjb250ZXh0LnJlc2V0KGNvbnRleHQubW9kZWwsIGNvbnRleHQuZWNNb2RlbCwgY29udGV4dC5hcGksIGNvbnRleHQucGF5bG9hZCkpO1xuICByZXR1cm4gcmVzZXREZWZpbmVzLmxlbmd0aCA+IDEgPyBtYXAocmVzZXREZWZpbmVzLCBmdW5jdGlvbiAodiwgaWR4KSB7XG4gICAgcmV0dXJuIG1ha2VTZXJpZXNUYXNrUHJvZ3Jlc3MoaWR4KTtcbiAgfSkgOiBzaW5nbGVTZXJpZXNUYXNrUHJvZ3Jlc3M7XG59XG52YXIgc2luZ2xlU2VyaWVzVGFza1Byb2dyZXNzID0gbWFrZVNlcmllc1Rhc2tQcm9ncmVzcygwKTtcbmZ1bmN0aW9uIG1ha2VTZXJpZXNUYXNrUHJvZ3Jlc3MocmVzZXREZWZpbmVJZHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwYXJhbXMsIGNvbnRleHQpIHtcbiAgICB2YXIgZGF0YSA9IGNvbnRleHQuZGF0YTtcbiAgICB2YXIgcmVzZXREZWZpbmUgPSBjb250ZXh0LnJlc2V0RGVmaW5lc1tyZXNldERlZmluZUlkeF07XG4gICAgaWYgKHJlc2V0RGVmaW5lICYmIHJlc2V0RGVmaW5lLmRhdGFFYWNoKSB7XG4gICAgICBmb3IgKHZhciBpID0gcGFyYW1zLnN0YXJ0OyBpIDwgcGFyYW1zLmVuZDsgaSsrKSB7XG4gICAgICAgIHJlc2V0RGVmaW5lLmRhdGFFYWNoKGRhdGEsIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVzZXREZWZpbmUgJiYgcmVzZXREZWZpbmUucHJvZ3Jlc3MpIHtcbiAgICAgIHJlc2V0RGVmaW5lLnByb2dyZXNzKHBhcmFtcywgZGF0YSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc2VyaWVzVGFza0NvdW50KGNvbnRleHQpIHtcbiAgcmV0dXJuIGNvbnRleHQuZGF0YS5jb3VudCgpO1xufVxuLyoqXHJcbiAqIE9ubHkgc29tZSBsZWdhY3kgc3RhZ2UgaGFuZGxlcnMgKHVzdWFsbHkgaW4gZWNoYXJ0cyBleHRlbnNpb25zKSBhcmUgcHVyZSBmdW5jdGlvbi5cclxuICogVG8gZW5zdXJlIHRoYXQgdGhleSBjYW4gd29yayBub3JtYWxseSwgdGhleSBzaG91bGQgd29yayBpbiBibG9jayBtb2RlLCB0aGF0IGlzLFxyXG4gKiB0aGV5IHNob3VsZCBub3QgYmUgc3RhcnRlZCB1dGlsIHRoZSBwcmV2aW91cyB0YXNrcyBmaW5pc2hlZC4gU28gdGhleSBjYXVzZSB0aGVcclxuICogcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGRpc2FibGVkLiBXZSB0cnkgdG8gZGV0ZWN0IHRoZSBzZXJpZXMgdHlwZSwgdG8gbmFycm93IGRvd25cclxuICogdGhlIGJsb2NrIHJhbmdlIHRvIG9ubHkgdGhlIHNlcmllcyB0eXBlIHRoZXkgY29uY2VybiwgYnV0IG5vdCBhbGwgc2VyaWVzLlxyXG4gKi9cbmZ1bmN0aW9uIGRldGVjdFNlcmlzZVR5cGUobGVnYWN5RnVuYykge1xuICBzZXJpZXNUeXBlID0gbnVsbDtcbiAgdHJ5IHtcbiAgICAvLyBBc3N1bWUgdGhlcmUgaXMgbm8gYXN5bmMgd2hlbiBjYWxsaW5nIGBlYWNoU2VyaWVzQnlUeXBlYC5cbiAgICBsZWdhY3lGdW5jKGVjTW9kZWxNb2NrLCBhcGlNb2NrKTtcbiAgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIHNlcmllc1R5cGU7XG59XG52YXIgZWNNb2RlbE1vY2sgPSB7fTtcbnZhciBhcGlNb2NrID0ge307XG52YXIgc2VyaWVzVHlwZTtcbm1vY2tNZXRob2RzKGVjTW9kZWxNb2NrLCBHbG9iYWxNb2RlbCk7XG5tb2NrTWV0aG9kcyhhcGlNb2NrLCBFeHRlbnNpb25BUEkpO1xuZWNNb2RlbE1vY2suZWFjaFNlcmllc0J5VHlwZSA9IGVjTW9kZWxNb2NrLmVhY2hSYXdTZXJpZXNCeVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICBzZXJpZXNUeXBlID0gdHlwZTtcbn07XG5lY01vZGVsTW9jay5lYWNoQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbmQpIHtcbiAgaWYgKGNvbmQubWFpblR5cGUgPT09ICdzZXJpZXMnICYmIGNvbmQuc3ViVHlwZSkge1xuICAgIHNlcmllc1R5cGUgPSBjb25kLnN1YlR5cGU7XG4gIH1cbn07XG5mdW5jdGlvbiBtb2NrTWV0aG9kcyh0YXJnZXQsIENseikge1xuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICBmb3IgKHZhciBuYW1lXzEgaW4gQ2x6LnByb3RvdHlwZSkge1xuICAgIC8vIERvIG5vdCB1c2UgaGFzT3duUHJvcGVydHlcbiAgICB0YXJnZXRbbmFtZV8xXSA9IG5vb3A7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSAqL1xufVxuZXhwb3J0IGRlZmF1bHQgU2NoZWR1bGVyOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IEV2ZW50ZnVsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvRXZlbnRmdWwuanMnO1xuO1xudmFyIGxpZmVjeWNsZSA9IG5ldyBFdmVudGZ1bCgpO1xuZXhwb3J0IGRlZmF1bHQgbGlmZWN5Y2xlOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6cmVuZGVyIGZyb20gJ3pyZW5kZXIvbGliL3pyZW5kZXIuanMnO1xuaW1wb3J0IHsgYXNzZXJ0LCBlYWNoLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaW5kZXhPZiwgYmluZCwgY2xvbmUsIHNldEFzUHJpbWl0aXZlLCBleHRlbmQsIGNyZWF0ZUhhc2hNYXAsIG1hcCwgZGVmYXVsdHMsIGlzRG9tLCBpc0FycmF5LCBub29wLCBpc1N0cmluZywgcmV0cmlldmUyIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBlbnYgZnJvbSAnenJlbmRlci9saWIvY29yZS9lbnYuanMnO1xuaW1wb3J0IHRpbXNvcnQgZnJvbSAnenJlbmRlci9saWIvY29yZS90aW1zb3J0LmpzJztcbmltcG9ydCBFdmVudGZ1bCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL0V2ZW50ZnVsLmpzJztcbmltcG9ydCBHbG9iYWxNb2RlbCBmcm9tICcuLi9tb2RlbC9HbG9iYWwuanMnO1xuaW1wb3J0IEV4dGVuc2lvbkFQSSBmcm9tICcuL0V4dGVuc2lvbkFQSS5qcyc7XG5pbXBvcnQgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIgZnJvbSAnLi9Db29yZGluYXRlU3lzdGVtLmpzJztcbmltcG9ydCBPcHRpb25NYW5hZ2VyIGZyb20gJy4uL21vZGVsL09wdGlvbk1hbmFnZXIuanMnO1xuaW1wb3J0IGJhY2t3YXJkQ29tcGF0IGZyb20gJy4uL3ByZXByb2Nlc3Nvci9iYWNrd2FyZENvbXBhdC5qcyc7XG5pbXBvcnQgZGF0YVN0YWNrIGZyb20gJy4uL3Byb2Nlc3Nvci9kYXRhU3RhY2suanMnO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uL21vZGVsL1Nlcmllcy5qcyc7XG5pbXBvcnQgQ29tcG9uZW50VmlldyBmcm9tICcuLi92aWV3L0NvbXBvbmVudC5qcyc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uL3ZpZXcvQ2hhcnQuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vdXRpbC9pbm5lclN0b3JlLmpzJztcbmltcG9ydCB7IGlzSGlnaERvd25EaXNwYXRjaGVyLCBIT1ZFUl9TVEFURV9FTVBIQVNJUywgSE9WRVJfU1RBVEVfQkxVUiwgYmx1clNlcmllc0Zyb21IaWdobGlnaHRQYXlsb2FkLCB0b2dnbGVTZWxlY3Rpb25Gcm9tUGF5bG9hZCwgdXBkYXRlU2VyaWVzRWxlbWVudFNlbGVjdGlvbiwgZ2V0QWxsU2VsZWN0ZWRJbmRpY2VzLCBpc1NlbGVjdENoYW5nZVBheWxvYWQsIGlzSGlnaERvd25QYXlsb2FkLCBISUdITElHSFRfQUNUSU9OX1RZUEUsIERPV05QTEFZX0FDVElPTl9UWVBFLCBTRUxFQ1RfQUNUSU9OX1RZUEUsIFVOU0VMRUNUX0FDVElPTl9UWVBFLCBUT0dHTEVfU0VMRUNUX0FDVElPTl9UWVBFLCBzYXZlUGF0aFN0YXRlcywgZW50ZXJFbXBoYXNpcywgbGVhdmVFbXBoYXNpcywgbGVhdmVCbHVyLCBlbnRlclNlbGVjdCwgbGVhdmVTZWxlY3QsIGVudGVyQmx1ciwgYWxsTGVhdmVCbHVyLCBmaW5kQ29tcG9uZW50SGlnaERvd25EaXNwYXRjaGVycywgYmx1ckNvbXBvbmVudCwgaGFuZGxlR2xvYmFsTW91c2VPdmVyRm9ySGlnaERvd24sIGhhbmRsZUdsb2JhbE1vdXNlT3V0Rm9ySGlnaERvd24gfSBmcm9tICcuLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBtb2RlbFV0aWwgZnJvbSAnLi4vdXRpbC9tb2RlbC5qcyc7XG5pbXBvcnQgeyB0aHJvdHRsZSB9IGZyb20gJy4uL3V0aWwvdGhyb3R0bGUuanMnO1xuaW1wb3J0IHsgc2VyaWVzU3R5bGVUYXNrLCBkYXRhU3R5bGVUYXNrLCBkYXRhQ29sb3JQYWxldHRlVGFzayB9IGZyb20gJy4uL3Zpc3VhbC9zdHlsZS5qcyc7XG5pbXBvcnQgbG9hZGluZ0RlZmF1bHQgZnJvbSAnLi4vbG9hZGluZy9kZWZhdWx0LmpzJztcbmltcG9ydCBTY2hlZHVsZXIgZnJvbSAnLi9TY2hlZHVsZXIuanMnO1xuaW1wb3J0IGxpZ2h0VGhlbWUgZnJvbSAnLi4vdGhlbWUvbGlnaHQuanMnO1xuaW1wb3J0IGRhcmtUaGVtZSBmcm9tICcuLi90aGVtZS9kYXJrLmpzJztcbmltcG9ydCB7IHBhcnNlQ2xhc3NUeXBlIH0gZnJvbSAnLi4vdXRpbC9jbGF6ei5qcyc7XG5pbXBvcnQgeyBFQ0V2ZW50UHJvY2Vzc29yIH0gZnJvbSAnLi4vdXRpbC9FQ0V2ZW50UHJvY2Vzc29yLmpzJztcbmltcG9ydCB7IHNlcmllc1N5bWJvbFRhc2ssIGRhdGFTeW1ib2xUYXNrIH0gZnJvbSAnLi4vdmlzdWFsL3N5bWJvbC5qcyc7XG5pbXBvcnQgeyBnZXRWaXN1YWxGcm9tRGF0YSwgZ2V0SXRlbVZpc3VhbEZyb21EYXRhIH0gZnJvbSAnLi4vdmlzdWFsL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGVMb2csIGRlcHJlY2F0ZVJlcGxhY2VMb2csIGVycm9yLCB3YXJuIH0gZnJvbSAnLi4vdXRpbC9sb2cuanMnO1xuaW1wb3J0IHsgaGFuZGxlTGVnYWN5U2VsZWN0RXZlbnRzIH0gZnJvbSAnLi4vbGVnYWN5L2RhdGFTZWxlY3RBY3Rpb24uanMnO1xuaW1wb3J0IHsgcmVnaXN0ZXJFeHRlcm5hbFRyYW5zZm9ybSB9IGZyb20gJy4uL2RhdGEvaGVscGVyL3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVMb2NhbGVPYmplY3QsIFNZU1RFTV9MQU5HIH0gZnJvbSAnLi9sb2NhbGUuanMnO1xuaW1wb3J0IHsgZmluZEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4uL3V0aWwvZXZlbnQuanMnO1xuaW1wb3J0IGRlY2FsIGZyb20gJy4uL3Zpc3VhbC9kZWNhbC5qcyc7XG5pbXBvcnQgbGlmZWN5Y2xlIGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IHBsYXRmb3JtQXBpLCBzZXRQbGF0Zm9ybUFQSSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvcGxhdGZvcm0uanMnO1xuaW1wb3J0IHsgZ2V0SW1wbCB9IGZyb20gJy4vaW1wbC5qcyc7XG5leHBvcnQgdmFyIHZlcnNpb24gPSAnNS42LjAnO1xuZXhwb3J0IHZhciBkZXBlbmRlbmNpZXMgPSB7XG4gIHpyZW5kZXI6ICc1LjYuMSdcbn07XG52YXIgVEVTVF9GUkFNRV9SRU1BSU5fVElNRSA9IDE7XG52YXIgUFJJT1JJVFlfUFJPQ0VTU09SX1NFUklFU19GSUxURVIgPSA4MDA7XG4vLyBTb21lIGRhdGEgcHJvY2Vzc29ycyBkZXBlbmRzIG9uIHRoZSBzdGFjayByZXN1bHQgZGltZW5zaW9uICh0byBjYWxjdWxhdGUgZGF0YSBleHRlbnQpLlxuLy8gU28gZGF0YSBzdGFjayBzdGFnZSBzaG91bGQgYmUgaW4gZnJvbnQgb2YgZGF0YSBwcm9jZXNzaW5nIHN0YWdlLlxudmFyIFBSSU9SSVRZX1BST0NFU1NPUl9EQVRBU1RBQ0sgPSA5MDA7XG4vLyBcIkRhdGEgZmlsdGVyXCIgd2lsbCBibG9jayB0aGUgc3RyZWFtLCBzbyBpdCBzaG91bGQgYmVcbi8vIHB1dCBhdCB0aGUgYmVnaW5uaW5nIG9mIGRhdGEgcHJvY2Vzc2luZy5cbnZhciBQUklPUklUWV9QUk9DRVNTT1JfRklMVEVSID0gMTAwMDtcbnZhciBQUklPUklUWV9QUk9DRVNTT1JfREVGQVVMVCA9IDIwMDA7XG52YXIgUFJJT1JJVFlfUFJPQ0VTU09SX1NUQVRJU1RJQyA9IDUwMDA7XG52YXIgUFJJT1JJVFlfVklTVUFMX0xBWU9VVCA9IDEwMDA7XG52YXIgUFJJT1JJVFlfVklTVUFMX1BST0dSRVNTSVZFX0xBWU9VVCA9IDExMDA7XG52YXIgUFJJT1JJVFlfVklTVUFMX0dMT0JBTCA9IDIwMDA7XG52YXIgUFJJT1JJVFlfVklTVUFMX0NIQVJUID0gMzAwMDtcbnZhciBQUklPUklUWV9WSVNVQUxfQ09NUE9ORU5UID0gNDAwMDtcbi8vIFZpc3VhbCBwcm9wZXJ0eSBpbiBkYXRhLiBHcmVhdGVyIHRoYW4gYFBSSU9SSVRZX1ZJU1VBTF9DT01QT05FTlRgIHRvIGVuYWJsZSB0b1xuLy8gb3ZlcndyaXRlIHRoZSB2aXVzYWwgcmVzdWx0IG9mIGNvbXBvbmVudCAobGlrZSBgdmlzdWFsTWFwYClcbi8vIHVzaW5nIGRhdGEgaXRlbSBzcGVjaWZpYyBzZXR0aW5nIChsaWtlIGl0ZW1TdHlsZS54eHggb24gZGF0YSBpdGVtKVxudmFyIFBSSU9SSVRZX1ZJU1VBTF9DSEFSVF9EQVRBX0NVU1RPTSA9IDQ1MDA7XG4vLyBHcmVhdGVyIHRoYW4gYFBSSU9SSVRZX1ZJU1VBTF9DSEFSVF9EQVRBX0NVU1RPTWAgdG8gZW5hYmxlIHRvIGxheW91dCBiYXNlZCBvblxuLy8gdmlzdWFsIHJlc3VsdCBsaWtlIGBzeW1ib2xTaXplYC5cbnZhciBQUklPUklUWV9WSVNVQUxfUE9TVF9DSEFSVF9MQVlPVVQgPSA0NjAwO1xudmFyIFBSSU9SSVRZX1ZJU1VBTF9CUlVTSCA9IDUwMDA7XG52YXIgUFJJT1JJVFlfVklTVUFMX0FSSUEgPSA2MDAwO1xudmFyIFBSSU9SSVRZX1ZJU1VBTF9ERUNBTCA9IDcwMDA7XG5leHBvcnQgdmFyIFBSSU9SSVRZID0ge1xuICBQUk9DRVNTT1I6IHtcbiAgICBGSUxURVI6IFBSSU9SSVRZX1BST0NFU1NPUl9GSUxURVIsXG4gICAgU0VSSUVTX0ZJTFRFUjogUFJJT1JJVFlfUFJPQ0VTU09SX1NFUklFU19GSUxURVIsXG4gICAgU1RBVElTVElDOiBQUklPUklUWV9QUk9DRVNTT1JfU1RBVElTVElDXG4gIH0sXG4gIFZJU1VBTDoge1xuICAgIExBWU9VVDogUFJJT1JJVFlfVklTVUFMX0xBWU9VVCxcbiAgICBQUk9HUkVTU0lWRV9MQVlPVVQ6IFBSSU9SSVRZX1ZJU1VBTF9QUk9HUkVTU0lWRV9MQVlPVVQsXG4gICAgR0xPQkFMOiBQUklPUklUWV9WSVNVQUxfR0xPQkFMLFxuICAgIENIQVJUOiBQUklPUklUWV9WSVNVQUxfQ0hBUlQsXG4gICAgUE9TVF9DSEFSVF9MQVlPVVQ6IFBSSU9SSVRZX1ZJU1VBTF9QT1NUX0NIQVJUX0xBWU9VVCxcbiAgICBDT01QT05FTlQ6IFBSSU9SSVRZX1ZJU1VBTF9DT01QT05FTlQsXG4gICAgQlJVU0g6IFBSSU9SSVRZX1ZJU1VBTF9CUlVTSCxcbiAgICBDSEFSVF9JVEVNOiBQUklPUklUWV9WSVNVQUxfQ0hBUlRfREFUQV9DVVNUT00sXG4gICAgQVJJQTogUFJJT1JJVFlfVklTVUFMX0FSSUEsXG4gICAgREVDQUw6IFBSSU9SSVRZX1ZJU1VBTF9ERUNBTFxuICB9XG59O1xuLy8gTWFpbiBwcm9jZXNzIGhhdmUgdGhyZWUgZW50cmllczogYHNldE9wdGlvbmAsIGBkaXNwYXRjaEFjdGlvbmAgYW5kIGByZXNpemVgLFxuLy8gd2hlcmUgdGhleSBtdXN0IG5vdCBiZSBpbnZva2VkIG5lc3RlZGx5LCBleGNlcHQgdGhlIG9ubHkgY2FzZTogaW52b2tlXG4vLyBkaXNwYXRjaEFjdGlvbiB3aXRoIHVwZGF0ZU1ldGhvZCBcIm5vbmVcIiBpbiBtYWluIHByb2Nlc3MuXG4vLyBUaGlzIGZsYWcgaXMgdXNlZCB0byBjYXJyeSBvdXQgdGhpcyBydWxlLlxuLy8gQWxsIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCBvdXQgc2lkZSBtYWluIHByb2Nlc3MgKGkuZS4gd2hlbiAhdGhpc1tJTl9NQUlOX1BST0NFU1NdKS5cbnZhciBJTl9NQUlOX1BST0NFU1NfS0VZID0gJ19fZmxhZ0luTWFpblByb2Nlc3MnO1xudmFyIFBFTkRJTkdfVVBEQVRFID0gJ19fcGVuZGluZ1VwZGF0ZSc7XG52YXIgU1RBVFVTX05FRURTX1VQREFURV9LRVkgPSAnX19uZWVkc1VwZGF0ZVN0YXR1cyc7XG52YXIgQUNUSU9OX1JFRyA9IC9eW2EtekEtWjAtOV9dKyQvO1xudmFyIENPTk5FQ1RfU1RBVFVTX0tFWSA9ICdfX2Nvbm5lY3RVcGRhdGVTdGF0dXMnO1xudmFyIENPTk5FQ1RfU1RBVFVTX1BFTkRJTkcgPSAwO1xudmFyIENPTk5FQ1RfU1RBVFVTX1VQREFUSU5HID0gMTtcbnZhciBDT05ORUNUX1NUQVRVU19VUERBVEVEID0gMjtcbjtcbjtcbmZ1bmN0aW9uIGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlRUNoYXJ0cyhtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRGlzcG9zZWQoKSkge1xuICAgICAgZGlzcG9zZWRXYXJuaW5nKHRoaXMuaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdG9Mb3dlcmNhc2VOYW1lQW5kQ2FsbEV2ZW50ZnVsKHRoaXMsIG1ldGhvZCwgYXJncyk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU1lc3NhZ2VDZW50ZXIobWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gdG9Mb3dlcmNhc2VOYW1lQW5kQ2FsbEV2ZW50ZnVsKHRoaXMsIG1ldGhvZCwgYXJncyk7XG4gIH07XG59XG5mdW5jdGlvbiB0b0xvd2VyY2FzZU5hbWVBbmRDYWxsRXZlbnRmdWwoaG9zdCwgbWV0aG9kLCBhcmdzKSB7XG4gIC8vIGBhcmdzWzBdYCBpcyBldmVudCBuYW1lLiBFdmVudCBuYW1lIGlzIGFsbCBsb3dlcmNhc2UuXG4gIGFyZ3NbMF0gPSBhcmdzWzBdICYmIGFyZ3NbMF0udG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIEV2ZW50ZnVsLnByb3RvdHlwZVttZXRob2RdLmFwcGx5KGhvc3QsIGFyZ3MpO1xufVxudmFyIE1lc3NhZ2VDZW50ZXIgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTWVzc2FnZUNlbnRlciwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gTWVzc2FnZUNlbnRlcigpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgcmV0dXJuIE1lc3NhZ2VDZW50ZXI7XG59KEV2ZW50ZnVsKTtcbnZhciBtZXNzYWdlQ2VudGVyUHJvdG8gPSBNZXNzYWdlQ2VudGVyLnByb3RvdHlwZTtcbm1lc3NhZ2VDZW50ZXJQcm90by5vbiA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTWVzc2FnZUNlbnRlcignb24nKTtcbm1lc3NhZ2VDZW50ZXJQcm90by5vZmYgPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU1lc3NhZ2VDZW50ZXIoJ29mZicpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbnRlcm5hbCBtZXRob2QgbmFtZXMgZm9yIGNsYXNzIEVDaGFydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHByZXBhcmU7XG52YXIgcHJlcGFyZVZpZXc7XG52YXIgdXBkYXRlRGlyZWN0bHk7XG52YXIgdXBkYXRlTWV0aG9kcztcbnZhciBkb0NvbnZlcnRQaXhlbDtcbnZhciB1cGRhdGVTdHJlYW1Nb2RlcztcbnZhciBkb0Rpc3BhdGNoQWN0aW9uO1xudmFyIGZsdXNoUGVuZGluZ0FjdGlvbnM7XG52YXIgdHJpZ2dlclVwZGF0ZWRFdmVudDtcbnZhciBiaW5kUmVuZGVyZWRFdmVudDtcbnZhciBiaW5kTW91c2VFdmVudDtcbnZhciByZW5kZXI7XG52YXIgcmVuZGVyQ29tcG9uZW50cztcbnZhciByZW5kZXJTZXJpZXM7XG52YXIgY3JlYXRlRXh0ZW5zaW9uQVBJO1xudmFyIGVuYWJsZUNvbm5lY3Q7XG52YXIgbWFya1N0YXR1c1RvVXBkYXRlO1xudmFyIGFwcGx5Q2hhbmdlZFN0YXRlcztcbnZhciBFQ2hhcnRzID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEVDaGFydHMsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEVDaGFydHMoZG9tLFxuICAvLyBUaGVtZSBuYW1lIG9yIHRoZW1lT3B0aW9uLlxuICB0aGVtZSwgb3B0cykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5ldyBFQ0V2ZW50UHJvY2Vzc29yKCkpIHx8IHRoaXM7XG4gICAgX3RoaXMuX2NoYXJ0c1ZpZXdzID0gW107XG4gICAgX3RoaXMuX2NoYXJ0c01hcCA9IHt9O1xuICAgIF90aGlzLl9jb21wb25lbnRzVmlld3MgPSBbXTtcbiAgICBfdGhpcy5fY29tcG9uZW50c01hcCA9IHt9O1xuICAgIC8vIENhbid0IGRpc3BhdGNoIGFjdGlvbiBkdXJpbmcgcmVuZGVyaW5nIHByb2NlZHVyZVxuICAgIF90aGlzLl9wZW5kaW5nQWN0aW9ucyA9IFtdO1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIC8vIEdldCB0aGVtZSBieSBuYW1lXG4gICAgaWYgKGlzU3RyaW5nKHRoZW1lKSkge1xuICAgICAgdGhlbWUgPSB0aGVtZVN0b3JhZ2VbdGhlbWVdO1xuICAgIH1cbiAgICBfdGhpcy5fZG9tID0gZG9tO1xuICAgIHZhciBkZWZhdWx0UmVuZGVyZXIgPSAnY2FudmFzJztcbiAgICB2YXIgZGVmYXVsdENvYXJzZVBvaW50ZXIgPSAnYXV0byc7XG4gICAgdmFyIGRlZmF1bHRVc2VEaXJ0eVJlY3QgPSBmYWxzZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHJvb3QgPSAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgKi9cbiAgICAgIGVudi5oYXNHbG9iYWxXaW5kb3cgPyB3aW5kb3cgOiBnbG9iYWw7XG4gICAgICBpZiAocm9vdCkge1xuICAgICAgICBkZWZhdWx0UmVuZGVyZXIgPSByZXRyaWV2ZTIocm9vdC5fX0VDSEFSVFNfX0RFRkFVTFRfX1JFTkRFUkVSX18sIGRlZmF1bHRSZW5kZXJlcik7XG4gICAgICAgIGRlZmF1bHRDb2Fyc2VQb2ludGVyID0gcmV0cmlldmUyKHJvb3QuX19FQ0hBUlRTX19ERUZBVUxUX19DT0FSU0VfUE9JTlRFUiwgZGVmYXVsdENvYXJzZVBvaW50ZXIpO1xuICAgICAgICBkZWZhdWx0VXNlRGlydHlSZWN0ID0gcmV0cmlldmUyKHJvb3QuX19FQ0hBUlRTX19ERUZBVUxUX19VU0VfRElSVFlfUkVDVF9fLCBkZWZhdWx0VXNlRGlydHlSZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdHMuc3NyKSB7XG4gICAgICB6cmVuZGVyLnJlZ2lzdGVyU1NSRGF0YUdldHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIGVjRGF0YSA9IGdldEVDRGF0YShlbCk7XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSBlY0RhdGEuZGF0YUluZGV4O1xuICAgICAgICBpZiAoZGF0YUluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc2hNYXAgPSBjcmVhdGVIYXNoTWFwKCk7XG4gICAgICAgIGhhc2hNYXAuc2V0KCdzZXJpZXNfaW5kZXgnLCBlY0RhdGEuc2VyaWVzSW5kZXgpO1xuICAgICAgICBoYXNoTWFwLnNldCgnZGF0YV9pbmRleCcsIGRhdGFJbmRleCk7XG4gICAgICAgIGVjRGF0YS5zc3JUeXBlICYmIGhhc2hNYXAuc2V0KCdzc3JfdHlwZScsIGVjRGF0YS5zc3JUeXBlKTtcbiAgICAgICAgcmV0dXJuIGhhc2hNYXA7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHpyID0gX3RoaXMuX3pyID0genJlbmRlci5pbml0KGRvbSwge1xuICAgICAgcmVuZGVyZXI6IG9wdHMucmVuZGVyZXIgfHwgZGVmYXVsdFJlbmRlcmVyLFxuICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogb3B0cy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgd2lkdGg6IG9wdHMud2lkdGgsXG4gICAgICBoZWlnaHQ6IG9wdHMuaGVpZ2h0LFxuICAgICAgc3NyOiBvcHRzLnNzcixcbiAgICAgIHVzZURpcnR5UmVjdDogcmV0cmlldmUyKG9wdHMudXNlRGlydHlSZWN0LCBkZWZhdWx0VXNlRGlydHlSZWN0KSxcbiAgICAgIHVzZUNvYXJzZVBvaW50ZXI6IHJldHJpZXZlMihvcHRzLnVzZUNvYXJzZVBvaW50ZXIsIGRlZmF1bHRDb2Fyc2VQb2ludGVyKSxcbiAgICAgIHBvaW50ZXJTaXplOiBvcHRzLnBvaW50ZXJTaXplXG4gICAgfSk7XG4gICAgX3RoaXMuX3NzciA9IG9wdHMuc3NyO1xuICAgIC8vIEV4cGVjdCA2MCBmcHMuXG4gICAgX3RoaXMuX3Rocm90dGxlZFpyRmx1c2ggPSB0aHJvdHRsZShiaW5kKHpyLmZsdXNoLCB6ciksIDE3KTtcbiAgICB0aGVtZSA9IGNsb25lKHRoZW1lKTtcbiAgICB0aGVtZSAmJiBiYWNrd2FyZENvbXBhdCh0aGVtZSwgdHJ1ZSk7XG4gICAgX3RoaXMuX3RoZW1lID0gdGhlbWU7XG4gICAgX3RoaXMuX2xvY2FsZSA9IGNyZWF0ZUxvY2FsZU9iamVjdChvcHRzLmxvY2FsZSB8fCBTWVNURU1fTEFORyk7XG4gICAgX3RoaXMuX2Nvb3JkU3lzTWdyID0gbmV3IENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyKCk7XG4gICAgdmFyIGFwaSA9IF90aGlzLl9hcGkgPSBjcmVhdGVFeHRlbnNpb25BUEkoX3RoaXMpO1xuICAgIC8vIFNvcnQgb24gZGVtYW5kXG4gICAgZnVuY3Rpb24gcHJpb3JpdHlTb3J0RnVuYyhhLCBiKSB7XG4gICAgICByZXR1cm4gYS5fX3ByaW8gLSBiLl9fcHJpbztcbiAgICB9XG4gICAgdGltc29ydCh2aXN1YWxGdW5jcywgcHJpb3JpdHlTb3J0RnVuYyk7XG4gICAgdGltc29ydChkYXRhUHJvY2Vzc29yRnVuY3MsIHByaW9yaXR5U29ydEZ1bmMpO1xuICAgIF90aGlzLl9zY2hlZHVsZXIgPSBuZXcgU2NoZWR1bGVyKF90aGlzLCBhcGksIGRhdGFQcm9jZXNzb3JGdW5jcywgdmlzdWFsRnVuY3MpO1xuICAgIF90aGlzLl9tZXNzYWdlQ2VudGVyID0gbmV3IE1lc3NhZ2VDZW50ZXIoKTtcbiAgICAvLyBJbml0IG1vdXNlIGV2ZW50c1xuICAgIF90aGlzLl9pbml0RXZlbnRzKCk7XG4gICAgLy8gSW4gY2FzZSBzb21lIHBlb3BsZSB3cml0ZSBgd2luZG93Lm9ucmVzaXplID0gY2hhcnQucmVzaXplYFxuICAgIF90aGlzLnJlc2l6ZSA9IGJpbmQoX3RoaXMucmVzaXplLCBfdGhpcyk7XG4gICAgenIuYW5pbWF0aW9uLm9uKCdmcmFtZScsIF90aGlzLl9vbmZyYW1lLCBfdGhpcyk7XG4gICAgYmluZFJlbmRlcmVkRXZlbnQoenIsIF90aGlzKTtcbiAgICBiaW5kTW91c2VFdmVudCh6ciwgX3RoaXMpO1xuICAgIC8vIEVDaGFydHMgaW5zdGFuY2UgY2FuIGJlIHVzZWQgYXMgdmFsdWUuXG4gICAgc2V0QXNQcmltaXRpdmUoX3RoaXMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBFQ2hhcnRzLnByb3RvdHlwZS5fb25mcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXBwbHlDaGFuZ2VkU3RhdGVzKHRoaXMpO1xuICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLl9zY2hlZHVsZXI7XG4gICAgLy8gTGF6eSB1cGRhdGVcbiAgICBpZiAodGhpc1tQRU5ESU5HX1VQREFURV0pIHtcbiAgICAgIHZhciBzaWxlbnQgPSB0aGlzW1BFTkRJTkdfVVBEQVRFXS5zaWxlbnQ7XG4gICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU19LRVldID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHByZXBhcmUodGhpcyk7XG4gICAgICAgIHVwZGF0ZU1ldGhvZHMudXBkYXRlLmNhbGwodGhpcywgbnVsbCwgdGhpc1tQRU5ESU5HX1VQREFURV0udXBkYXRlUGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NfS0VZXSA9IGZhbHNlO1xuICAgICAgICB0aGlzW1BFTkRJTkdfVVBEQVRFXSA9IG51bGw7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICAvLyBBdCBwcmVzZW50LCBpbiBlYWNoIGZyYW1lLCB6cmVuZGVyIHBlcmZvcm1zOlxuICAgICAgLy8gICAoMSkgYW5pbWF0aW9uIHN0ZXAgZm9yd2FyZC5cbiAgICAgIC8vICAgKDIpIHRyaWdnZXIoJ2ZyYW1lJykgKHdoZXJlIHRoaXMgYF9vbmZyYW1lYCBpcyBjYWxsZWQpXG4gICAgICAvLyAgICgzKSB6cmVuZGVyIGZsdXNoIChyZW5kZXIpLlxuICAgICAgLy8gSWYgd2UgZG8gbm90aGluZyBoZXJlLCBzaW5jZSB3ZSB1c2UgYHNldFRvRmluYWw6IHRydWVgLCB0aGUgc3RlcCAoMykgYWJvdmVcbiAgICAgIC8vIHdpbGwgcmVuZGVyIHRoZSBmaW5hbCBzdGF0ZSBvZiB0aGUgZWxlbWVudHMgYmVmb3JlIHRoZSByZWFsIGFuaW1hdGlvbiBzdGFydGVkLlxuICAgICAgdGhpcy5fenIuZmx1c2goKTtcbiAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTX0tFWV0gPSBmYWxzZTtcbiAgICAgIHRoaXNbUEVORElOR19VUERBVEVdID0gbnVsbDtcbiAgICAgIGZsdXNoUGVuZGluZ0FjdGlvbnMuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICAgICAgdHJpZ2dlclVwZGF0ZWRFdmVudC5jYWxsKHRoaXMsIHNpbGVudCk7XG4gICAgfVxuICAgIC8vIEF2b2lkIGRvIGJvdGggbGF6eSB1cGRhdGUgYW5kIHByb2dyZXNzIGluIG9uZSBmcmFtZS5cbiAgICBlbHNlIGlmIChzY2hlZHVsZXIudW5maW5pc2hlZCkge1xuICAgICAgLy8gU3RyZWFtIHByb2dyZXNzLlxuICAgICAgdmFyIHJlbWFpblRpbWUgPSBURVNUX0ZSQU1FX1JFTUFJTl9USU1FO1xuICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICBzY2hlZHVsZXIudW5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgICAgIHNjaGVkdWxlci5wZXJmb3JtU2VyaWVzVGFza3MoZWNNb2RlbCk7XG4gICAgICAgIC8vIEN1cnJlbnRseSBkYXRhUHJvY2Vzc29yRnVuY3MgZG8gbm90IGNoZWNrIHRocmVzaG9sZC5cbiAgICAgICAgc2NoZWR1bGVyLnBlcmZvcm1EYXRhUHJvY2Vzc29yVGFza3MoZWNNb2RlbCk7XG4gICAgICAgIHVwZGF0ZVN0cmVhbU1vZGVzKHRoaXMsIGVjTW9kZWwpO1xuICAgICAgICAvLyBEbyBub3QgdXBkYXRlIGNvb3JkaW5hdGUgc3lzdGVtIGhlcmUuIEJlY2F1c2UgdGhhdCBjb29yZCBzeXN0ZW0gdXBkYXRlIGluXG4gICAgICAgIC8vIGVhY2ggZnJhbWUgaXMgbm90IGEgZ29vZCB1c2VyIGV4cGVyaWVuY2UuIFNvIHdlIGZvbGxvdyB0aGUgcnVsZSB0aGF0XG4gICAgICAgIC8vIHRoZSBleHRlbnQgb2YgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIGlzIGRldGVybWluZWQgaW4gdGhlIGZpcnN0IGZyYW1lICh0aGVcbiAgICAgICAgLy8gZnJhbWUgaXMgZXhlY3V0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGFzayByZXNldC5cbiAgICAgICAgLy8gdGhpcy5fY29vcmRTeXNNZ3IudXBkYXRlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0gZWMgZnJhbWUgdmlzdWFsIC0tLScsIHJlbWFpblRpbWUpO1xuICAgICAgICBzY2hlZHVsZXIucGVyZm9ybVZpc3VhbFRhc2tzKGVjTW9kZWwpO1xuICAgICAgICByZW5kZXJTZXJpZXModGhpcywgdGhpcy5fbW9kZWwsIGFwaSwgJ3JlbWFpbicsIHt9KTtcbiAgICAgICAgcmVtYWluVGltZSAtPSArbmV3IERhdGUoKSAtIHN0YXJ0VGltZTtcbiAgICAgIH0gd2hpbGUgKHJlbWFpblRpbWUgPiAwICYmIHNjaGVkdWxlci51bmZpbmlzaGVkKTtcbiAgICAgIC8vIENhbGwgZmx1c2ggZXhwbGljaXRseSBmb3IgdHJpZ2dlciBmaW5pc2hlZCBldmVudC5cbiAgICAgIGlmICghc2NoZWR1bGVyLnVuZmluaXNoZWQpIHtcbiAgICAgICAgdGhpcy5fenIuZmx1c2goKTtcbiAgICAgIH1cbiAgICAgIC8vIEVsc2UsIHpyIGZsdXNoaW5nIGJlIGVuc3VlIHdpdGhpbiB0aGUgc2FtZSBmcmFtZSxcbiAgICAgIC8vIGJlY2F1c2UgenIgZmx1c2hpbmcgaXMgYWZ0ZXIgb25mcmFtZSBldmVudC5cbiAgICB9XG4gIH07XG4gIEVDaGFydHMucHJvdG90eXBlLmdldERvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZG9tO1xuICB9O1xuICBFQ2hhcnRzLnByb3RvdHlwZS5nZXRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfTtcbiAgRUNoYXJ0cy5wcm90b3R5cGUuZ2V0WnIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pyO1xuICB9O1xuICBFQ2hhcnRzLnByb3RvdHlwZS5pc1NTUiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3NyO1xuICB9O1xuICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgKi9cbiAgRUNoYXJ0cy5wcm90b3R5cGUuc2V0T3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbiwgbm90TWVyZ2UsIGxhenlVcGRhdGUpIHtcbiAgICBpZiAodGhpc1tJTl9NQUlOX1BST0NFU1NfS0VZXSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ2BzZXRPcHRpb25gIHNob3VsZCBub3QgYmUgY2FsbGVkIGR1cmluZyBtYWluIHByb2Nlc3MuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgZGlzcG9zZWRXYXJuaW5nKHRoaXMuaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc2lsZW50O1xuICAgIHZhciByZXBsYWNlTWVyZ2U7XG4gICAgdmFyIHRyYW5zaXRpb25PcHQ7XG4gICAgaWYgKGlzT2JqZWN0KG5vdE1lcmdlKSkge1xuICAgICAgbGF6eVVwZGF0ZSA9IG5vdE1lcmdlLmxhenlVcGRhdGU7XG4gICAgICBzaWxlbnQgPSBub3RNZXJnZS5zaWxlbnQ7XG4gICAgICByZXBsYWNlTWVyZ2UgPSBub3RNZXJnZS5yZXBsYWNlTWVyZ2U7XG4gICAgICB0cmFuc2l0aW9uT3B0ID0gbm90TWVyZ2UudHJhbnNpdGlvbjtcbiAgICAgIG5vdE1lcmdlID0gbm90TWVyZ2Uubm90TWVyZ2U7XG4gICAgfVxuICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTX0tFWV0gPSB0cnVlO1xuICAgIGlmICghdGhpcy5fbW9kZWwgfHwgbm90TWVyZ2UpIHtcbiAgICAgIHZhciBvcHRpb25NYW5hZ2VyID0gbmV3IE9wdGlvbk1hbmFnZXIodGhpcy5fYXBpKTtcbiAgICAgIHZhciB0aGVtZSA9IHRoaXMuX3RoZW1lO1xuICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbCA9IG5ldyBHbG9iYWxNb2RlbCgpO1xuICAgICAgZWNNb2RlbC5zY2hlZHVsZXIgPSB0aGlzLl9zY2hlZHVsZXI7XG4gICAgICBlY01vZGVsLnNzciA9IHRoaXMuX3NzcjtcbiAgICAgIGVjTW9kZWwuaW5pdChudWxsLCBudWxsLCBudWxsLCB0aGVtZSwgdGhpcy5fbG9jYWxlLCBvcHRpb25NYW5hZ2VyKTtcbiAgICB9XG4gICAgdGhpcy5fbW9kZWwuc2V0T3B0aW9uKG9wdGlvbiwge1xuICAgICAgcmVwbGFjZU1lcmdlOiByZXBsYWNlTWVyZ2VcbiAgICB9LCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcyk7XG4gICAgdmFyIHVwZGF0ZVBhcmFtcyA9IHtcbiAgICAgIHNlcmllc1RyYW5zaXRpb246IHRyYW5zaXRpb25PcHQsXG4gICAgICBvcHRpb25DaGFuZ2VkOiB0cnVlXG4gICAgfTtcbiAgICBpZiAobGF6eVVwZGF0ZSkge1xuICAgICAgdGhpc1tQRU5ESU5HX1VQREFURV0gPSB7XG4gICAgICAgIHNpbGVudDogc2lsZW50LFxuICAgICAgICB1cGRhdGVQYXJhbXM6IHVwZGF0ZVBhcmFtc1xuICAgICAgfTtcbiAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTX0tFWV0gPSBmYWxzZTtcbiAgICAgIC8vIGBzZXRPcHRpb24ob3B0aW9uLCB7bGF6eU1vZGU6IHRydWV9KWAgbWF5IGJlIGNhbGxlZCB3aGVuIHpyZW5kZXIgaGFzIGJlZW4gc2xlcHQuXG4gICAgICAvLyBJdCBzaG91bGQgd2FrZSBpdCB1cCB0byBtYWtlIHN1cmUgenJlbmRlciBzdGFydCB0byByZW5kZXIgYXQgdGhlIG5leHQgZnJhbWUuXG4gICAgICB0aGlzLmdldFpyKCkud2FrZVVwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHByZXBhcmUodGhpcyk7XG4gICAgICAgIHVwZGF0ZU1ldGhvZHMudXBkYXRlLmNhbGwodGhpcywgbnVsbCwgdXBkYXRlUGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpc1tQRU5ESU5HX1VQREFURV0gPSBudWxsO1xuICAgICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU19LRVldID0gZmFsc2U7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICAvLyBFbnN1cmUgenIgcmVmcmVzaCBzeWNocm9ub3VzbHksIGFuZCB0aGVuIHBpeGVsIGluIGNhbnZhcyBjYW4gYmVcbiAgICAgIC8vIGZldGNoZWQgYWZ0ZXIgYHNldE9wdGlvbmAuXG4gICAgICBpZiAoIXRoaXMuX3Nzcikge1xuICAgICAgICAvLyBub3QgdXNlIGZsdXNoIHdoZW4gdXNpbmcgc3NyIG1vZGUuXG4gICAgICAgIHRoaXMuX3pyLmZsdXNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzW1BFTkRJTkdfVVBEQVRFXSA9IG51bGw7XG4gICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU19LRVldID0gZmFsc2U7XG4gICAgICBmbHVzaFBlbmRpbmdBY3Rpb25zLmNhbGwodGhpcywgc2lsZW50KTtcbiAgICAgIHRyaWdnZXJVcGRhdGVkRXZlbnQuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQGRlcHJlY2F0ZWRcclxuICAgKi9cbiAgRUNoYXJ0cy5wcm90b3R5cGUuc2V0VGhlbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVwcmVjYXRlTG9nKCdFQ2hhcnRzI3NldFRoZW1lKCkgaXMgREVQUkVDQVRFRCBpbiBFQ2hhcnRzIDMuMCcpO1xuICB9O1xuICAvLyBXZSBkb24ndCB3YW50IGRldmVsb3BlcnMgdG8gdXNlIGdldE1vZGVsIGRpcmVjdGx5LlxuICBFQ2hhcnRzLnByb3RvdHlwZS5nZXRNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIH07XG4gIEVDaGFydHMucHJvdG90eXBlLmdldE9wdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwgJiYgdGhpcy5fbW9kZWwuZ2V0T3B0aW9uKCk7XG4gIH07XG4gIEVDaGFydHMucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl96ci5nZXRXaWR0aCgpO1xuICB9O1xuICBFQ2hhcnRzLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pyLmdldEhlaWdodCgpO1xuICB9O1xuICBFQ2hhcnRzLnByb3RvdHlwZS5nZXREZXZpY2VQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl96ci5wYWludGVyLmRwclxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAqLyB8fCBlbnYuaGFzR2xvYmFsV2luZG93ICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxyXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZW5kZXJUb0NhbnZhcyBpbnN0ZWFkLlxyXG4gICAqL1xuICBFQ2hhcnRzLnByb3RvdHlwZS5nZXRSZW5kZXJlZENhbnZhcyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlcHJlY2F0ZVJlcGxhY2VMb2coJ2dldFJlbmRlcmVkQ2FudmFzJywgJ3JlbmRlclRvQ2FudmFzJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlclRvQ2FudmFzKG9wdHMpO1xuICB9O1xuICBFQ2hhcnRzLnByb3RvdHlwZS5yZW5kZXJUb0NhbnZhcyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIHBhaW50ZXIgPSB0aGlzLl96ci5wYWludGVyO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAocGFpbnRlci50eXBlICE9PSAnY2FudmFzJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbmRlclRvQ2FudmFzIGNhbiBvbmx5IGJlIHVzZWQgaW4gdGhlIGNhbnZhcyByZW5kZXJlci4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhaW50ZXIuZ2V0UmVuZGVyZWRDYW52YXMoe1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRzLmJhY2tncm91bmRDb2xvciB8fCB0aGlzLl9tb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpLFxuICAgICAgcGl4ZWxSYXRpbzogb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZ2V0RGV2aWNlUGl4ZWxSYXRpbygpXG4gICAgfSk7XG4gIH07XG4gIEVDaGFydHMucHJvdG90eXBlLnJlbmRlclRvU1ZHU3RyaW5nID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgcGFpbnRlciA9IHRoaXMuX3pyLnBhaW50ZXI7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChwYWludGVyLnR5cGUgIT09ICdzdmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVuZGVyVG9TVkdTdHJpbmcgY2FuIG9ubHkgYmUgdXNlZCBpbiB0aGUgc3ZnIHJlbmRlcmVyLicpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFpbnRlci5yZW5kZXJUb1N0cmluZyh7XG4gICAgICB1c2VWaWV3Qm94OiBvcHRzLnVzZVZpZXdCb3hcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IHN2ZyBkYXRhIHVybFxyXG4gICAqL1xuICBFQ2hhcnRzLnByb3RvdHlwZS5nZXRTdmdEYXRhVVJMID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghZW52LnN2Z1N1cHBvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgenIgPSB0aGlzLl96cjtcbiAgICB2YXIgbGlzdCA9IHpyLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTtcbiAgICAvLyBTdG9wIGFuaW1hdGlvbnNcbiAgICBlYWNoKGxpc3QsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwuc3RvcEFuaW1hdGlvbihudWxsLCB0cnVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4genIucGFpbnRlci50b0RhdGFVUkwoKTtcbiAgfTtcbiAgRUNoYXJ0cy5wcm90b3R5cGUuZ2V0RGF0YVVSTCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICBkaXNwb3NlZFdhcm5pbmcodGhpcy5pZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBleGNsdWRlQ29tcG9uZW50cyA9IG9wdHMuZXhjbHVkZUNvbXBvbmVudHM7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgICB2YXIgZXhjbHVkZXNDb21wb25lbnRWaWV3cyA9IFtdO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBlYWNoKGV4Y2x1ZGVDb21wb25lbnRzLCBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgICAgbWFpblR5cGU6IGNvbXBvbmVudFR5cGVcbiAgICAgIH0sIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBzZWxmLl9jb21wb25lbnRzTWFwW2NvbXBvbmVudC5fX3ZpZXdJZF07XG4gICAgICAgIGlmICghdmlldy5ncm91cC5pZ25vcmUpIHtcbiAgICAgICAgICBleGNsdWRlc0NvbXBvbmVudFZpZXdzLnB1c2godmlldyk7XG4gICAgICAgICAgdmlldy5ncm91cC5pZ25vcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgdXJsID0gdGhpcy5fenIucGFpbnRlci5nZXRUeXBlKCkgPT09ICdzdmcnID8gdGhpcy5nZXRTdmdEYXRhVVJMKCkgOiB0aGlzLnJlbmRlclRvQ2FudmFzKG9wdHMpLnRvRGF0YVVSTCgnaW1hZ2UvJyArIChvcHRzICYmIG9wdHMudHlwZSB8fCAncG5nJykpO1xuICAgIGVhY2goZXhjbHVkZXNDb21wb25lbnRWaWV3cywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgIHZpZXcuZ3JvdXAuaWdub3JlID0gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVybDtcbiAgfTtcbiAgRUNoYXJ0cy5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkRGF0YVVSTCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICBkaXNwb3NlZFdhcm5pbmcodGhpcy5pZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpc1N2ZyA9IG9wdHMudHlwZSA9PT0gJ3N2Zyc7XG4gICAgdmFyIGdyb3VwSWQgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICB2YXIgTUFYX05VTUJFUiA9IEluZmluaXR5O1xuICAgIGlmIChjb25uZWN0ZWRHcm91cHNbZ3JvdXBJZF0pIHtcbiAgICAgIHZhciBsZWZ0XzEgPSBNQVhfTlVNQkVSO1xuICAgICAgdmFyIHRvcF8xID0gTUFYX05VTUJFUjtcbiAgICAgIHZhciByaWdodF8xID0gLU1BWF9OVU1CRVI7XG4gICAgICB2YXIgYm90dG9tXzEgPSAtTUFYX05VTUJFUjtcbiAgICAgIHZhciBjYW52YXNMaXN0XzEgPSBbXTtcbiAgICAgIHZhciBkcHJfMSA9IG9wdHMgJiYgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgICAgZWFjaChpbnN0YW5jZXMsIGZ1bmN0aW9uIChjaGFydCwgaWQpIHtcbiAgICAgICAgaWYgKGNoYXJ0Lmdyb3VwID09PSBncm91cElkKSB7XG4gICAgICAgICAgdmFyIGNhbnZhcyA9IGlzU3ZnID8gY2hhcnQuZ2V0WnIoKS5wYWludGVyLmdldFN2Z0RvbSgpLmlubmVySFRNTCA6IGNoYXJ0LnJlbmRlclRvQ2FudmFzKGNsb25lKG9wdHMpKTtcbiAgICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gY2hhcnQuZ2V0RG9tKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgbGVmdF8xID0gbWF0aE1pbihib3VuZGluZ1JlY3QubGVmdCwgbGVmdF8xKTtcbiAgICAgICAgICB0b3BfMSA9IG1hdGhNaW4oYm91bmRpbmdSZWN0LnRvcCwgdG9wXzEpO1xuICAgICAgICAgIHJpZ2h0XzEgPSBtYXRoTWF4KGJvdW5kaW5nUmVjdC5yaWdodCwgcmlnaHRfMSk7XG4gICAgICAgICAgYm90dG9tXzEgPSBtYXRoTWF4KGJvdW5kaW5nUmVjdC5ib3R0b20sIGJvdHRvbV8xKTtcbiAgICAgICAgICBjYW52YXNMaXN0XzEucHVzaCh7XG4gICAgICAgICAgICBkb206IGNhbnZhcyxcbiAgICAgICAgICAgIGxlZnQ6IGJvdW5kaW5nUmVjdC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBib3VuZGluZ1JlY3QudG9wXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGVmdF8xICo9IGRwcl8xO1xuICAgICAgdG9wXzEgKj0gZHByXzE7XG4gICAgICByaWdodF8xICo9IGRwcl8xO1xuICAgICAgYm90dG9tXzEgKj0gZHByXzE7XG4gICAgICB2YXIgd2lkdGggPSByaWdodF8xIC0gbGVmdF8xO1xuICAgICAgdmFyIGhlaWdodCA9IGJvdHRvbV8xIC0gdG9wXzE7XG4gICAgICB2YXIgdGFyZ2V0Q2FudmFzID0gcGxhdGZvcm1BcGkuY3JlYXRlQ2FudmFzKCk7XG4gICAgICB2YXIgenJfMSA9IHpyZW5kZXIuaW5pdCh0YXJnZXRDYW52YXMsIHtcbiAgICAgICAgcmVuZGVyZXI6IGlzU3ZnID8gJ3N2ZycgOiAnY2FudmFzJ1xuICAgICAgfSk7XG4gICAgICB6cl8xLnJlc2l6ZSh7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzU3ZnKSB7XG4gICAgICAgIHZhciBjb250ZW50XzEgPSAnJztcbiAgICAgICAgZWFjaChjYW52YXNMaXN0XzEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgdmFyIHggPSBpdGVtLmxlZnQgLSBsZWZ0XzE7XG4gICAgICAgICAgdmFyIHkgPSBpdGVtLnRvcCAtIHRvcF8xO1xuICAgICAgICAgIGNvbnRlbnRfMSArPSAnPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKCcgKyB4ICsgJywnICsgeSArICcpXCI+JyArIGl0ZW0uZG9tICsgJzwvZz4nO1xuICAgICAgICB9KTtcbiAgICAgICAgenJfMS5wYWludGVyLmdldFN2Z1Jvb3QoKS5pbm5lckhUTUwgPSBjb250ZW50XzE7XG4gICAgICAgIGlmIChvcHRzLmNvbm5lY3RlZEJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgIHpyXzEucGFpbnRlci5zZXRCYWNrZ3JvdW5kQ29sb3Iob3B0cy5jb25uZWN0ZWRCYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIHpyXzEucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG4gICAgICAgIHJldHVybiB6cl8xLnBhaW50ZXIudG9EYXRhVVJMKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCYWNrZ3JvdW5kIGJldHdlZW4gdGhlIGNoYXJ0c1xuICAgICAgICBpZiAob3B0cy5jb25uZWN0ZWRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICB6cl8xLmFkZChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBmaWxsOiBvcHRzLmNvbm5lY3RlZEJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlYWNoKGNhbnZhc0xpc3RfMSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgaW1nID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgeDogaXRlbS5sZWZ0ICogZHByXzEgLSBsZWZ0XzEsXG4gICAgICAgICAgICAgIHk6IGl0ZW0udG9wICogZHByXzEgLSB0b3BfMSxcbiAgICAgICAgICAgICAgaW1hZ2U6IGl0ZW0uZG9tXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgenJfMS5hZGQoaW1nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHpyXzEucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG4gICAgICAgIHJldHVybiB0YXJnZXRDYW52YXMudG9EYXRhVVJMKCdpbWFnZS8nICsgKG9wdHMgJiYgb3B0cy50eXBlIHx8ICdwbmcnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldERhdGFVUkwob3B0cyk7XG4gICAgfVxuICB9O1xuICBFQ2hhcnRzLnByb3RvdHlwZS5jb252ZXJ0VG9QaXhlbCA9IGZ1bmN0aW9uIChmaW5kZXIsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGRvQ29udmVydFBpeGVsKHRoaXMsICdjb252ZXJ0VG9QaXhlbCcsIGZpbmRlciwgdmFsdWUpO1xuICB9O1xuICBFQ2hhcnRzLnByb3RvdHlwZS5jb252ZXJ0RnJvbVBpeGVsID0gZnVuY3Rpb24gKGZpbmRlciwgdmFsdWUpIHtcbiAgICByZXR1cm4gZG9Db252ZXJ0UGl4ZWwodGhpcywgJ2NvbnZlcnRGcm9tUGl4ZWwnLCBmaW5kZXIsIHZhbHVlKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogSXMgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlIHN5c3RlbXMgb3IgY29tcG9uZW50cyBjb250YWluIHRoZSBnaXZlbiBwaXhlbCBwb2ludC5cclxuICAgKiBAcGFyYW0ge0FycmF5fG51bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSByZXN1bHRcclxuICAgKi9cbiAgRUNoYXJ0cy5wcm90b3R5cGUuY29udGFpblBpeGVsID0gZnVuY3Rpb24gKGZpbmRlciwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgIGRpc3Bvc2VkV2FybmluZyh0aGlzLmlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBmaW5kUmVzdWx0ID0gbW9kZWxVdGlsLnBhcnNlRmluZGVyKGVjTW9kZWwsIGZpbmRlcik7XG4gICAgZWFjaChmaW5kUmVzdWx0LCBmdW5jdGlvbiAobW9kZWxzLCBrZXkpIHtcbiAgICAgIGtleS5pbmRleE9mKCdNb2RlbHMnKSA+PSAwICYmIGVhY2gobW9kZWxzLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdmFyIGNvb3JkU3lzID0gbW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgaWYgKGNvb3JkU3lzICYmIGNvb3JkU3lzLmNvbnRhaW5Qb2ludCkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCAhIWNvb3JkU3lzLmNvbnRhaW5Qb2ludCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc2VyaWVzTW9kZWxzJykge1xuICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5fY2hhcnRzTWFwW21vZGVsLl9fdmlld0lkXTtcbiAgICAgICAgICBpZiAodmlldyAmJiB2aWV3LmNvbnRhaW5Qb2ludCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IHZpZXcuY29udGFpblBvaW50KHZhbHVlLCBtb2RlbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oa2V5ICsgJzogJyArICh2aWV3ID8gJ1RoZSBmb3VuZCBjb21wb25lbnQgZG8gbm90IHN1cHBvcnQgY29udGFpblBvaW50LicgOiAnTm8gdmlldyBtYXBwaW5nIHRvIHRoZSBmb3VuZCBjb21wb25lbnQuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgd2FybihrZXkgKyAnOiBjb250YWluUG9pbnQgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuICEhcmVzdWx0O1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgdmlzdWFsIGZyb20gc2VyaWVzIG9yIGRhdGEuXHJcbiAgICogQHBhcmFtIGZpbmRlclxyXG4gICAqICAgICAgICBJZiBzdHJpbmcsIGUuZy4sICdzZXJpZXMnLCBtZWFucyB7c2VyaWVzSW5kZXg6IDB9LlxyXG4gICAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxyXG4gICAqICAgICAgICB7XHJcbiAgICogICAgICAgICAgICBzZXJpZXNJbmRleCAvIHNlcmllc0lkIC8gc2VyaWVzTmFtZSxcclxuICAgKiAgICAgICAgICAgIGRhdGFJbmRleCAvIGRhdGFJbmRleEluc2lkZVxyXG4gICAqICAgICAgICB9XHJcbiAgICogICAgICAgIElmIGRhdGFJbmRleCBpcyBub3Qgc3BlY2lmaWVkLCBzZXJpZXMgdmlzdWFsIHdpbGwgYmUgZmV0Y2hlZCxcclxuICAgKiAgICAgICAgYnV0IG5vdCBkYXRhIGl0ZW0gdmlzdWFsLlxyXG4gICAqICAgICAgICBJZiBhbGwgb2Ygc2VyaWVzSW5kZXgsIHNlcmllc0lkLCBzZXJpZXNOYW1lIGFyZSBub3Qgc3BlY2lmaWVkLFxyXG4gICAqICAgICAgICB2aXN1YWwgd2lsbCBiZSBmZXRjaGVkIGZyb20gZmlyc3Qgc2VyaWVzLlxyXG4gICAqIEBwYXJhbSB2aXN1YWxUeXBlICdjb2xvcicsICdzeW1ib2wnLCAnc3ltYm9sU2l6ZSdcclxuICAgKi9cbiAgRUNoYXJ0cy5wcm90b3R5cGUuZ2V0VmlzdWFsID0gZnVuY3Rpb24gKGZpbmRlciwgdmlzdWFsVHlwZSkge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgdmFyIHBhcnNlZEZpbmRlciA9IG1vZGVsVXRpbC5wYXJzZUZpbmRlcihlY01vZGVsLCBmaW5kZXIsIHtcbiAgICAgIGRlZmF1bHRNYWluVHlwZTogJ3NlcmllcydcbiAgICB9KTtcbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBwYXJzZWRGaW5kZXIuc2VyaWVzTW9kZWw7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgd2FybignVGhlcmUgaXMgbm8gc3BlY2lmaWVkIHNlcmllcyBtb2RlbCcpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgZGF0YUluZGV4SW5zaWRlID0gcGFyc2VkRmluZGVyLmhhc093blByb3BlcnR5KCdkYXRhSW5kZXhJbnNpZGUnKSA/IHBhcnNlZEZpbmRlci5kYXRhSW5kZXhJbnNpZGUgOiBwYXJzZWRGaW5kZXIuaGFzT3duUHJvcGVydHkoJ2RhdGFJbmRleCcpID8gZGF0YS5pbmRleE9mUmF3SW5kZXgocGFyc2VkRmluZGVyLmRhdGFJbmRleCkgOiBudWxsO1xuICAgIHJldHVybiBkYXRhSW5kZXhJbnNpZGUgIT0gbnVsbCA/IGdldEl0ZW1WaXN1YWxGcm9tRGF0YShkYXRhLCBkYXRhSW5kZXhJbnNpZGUsIHZpc3VhbFR5cGUpIDogZ2V0VmlzdWFsRnJvbURhdGEoZGF0YSwgdmlzdWFsVHlwZSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCB2aWV3IG9mIGNvcnJlc3BvbmRpbmcgY29tcG9uZW50IG1vZGVsXHJcbiAgICovXG4gIEVDaGFydHMucHJvdG90eXBlLmdldFZpZXdPZkNvbXBvbmVudE1vZGVsID0gZnVuY3Rpb24gKGNvbXBvbmVudE1vZGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNNYXBbY29tcG9uZW50TW9kZWwuX192aWV3SWRdO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgdmlldyBvZiBjb3JyZXNwb25kaW5nIHNlcmllcyBtb2RlbFxyXG4gICAqL1xuICBFQ2hhcnRzLnByb3RvdHlwZS5nZXRWaWV3T2ZTZXJpZXNNb2RlbCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuICB9O1xuICBFQ2hhcnRzLnByb3RvdHlwZS5faW5pdEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBlY01vZGVsID0gX3RoaXMuZ2V0TW9kZWwoKTtcbiAgICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciBwYXJhbXM7XG4gICAgICAgIHZhciBpc0dsb2JhbE91dCA9IGV2ZU5hbWUgPT09ICdnbG9iYWxvdXQnO1xuICAgICAgICAvLyBubyBlLnRhcmdldCB3aGVuICdnbG9iYWxvdXQnLlxuICAgICAgICBpZiAoaXNHbG9iYWxPdXQpIHtcbiAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbCAmJiBmaW5kRXZlbnREaXNwYXRjaGVyKGVsLCBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgZWNEYXRhID0gZ2V0RUNEYXRhKHBhcmVudCk7XG4gICAgICAgICAgICBpZiAoZWNEYXRhICYmIGVjRGF0YS5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgZGF0YU1vZGVsID0gZWNEYXRhLmRhdGFNb2RlbCB8fCBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoZWNEYXRhLnNlcmllc0luZGV4KTtcbiAgICAgICAgICAgICAgcGFyYW1zID0gZGF0YU1vZGVsICYmIGRhdGFNb2RlbC5nZXREYXRhUGFyYW1zKGVjRGF0YS5kYXRhSW5kZXgsIGVjRGF0YS5kYXRhVHlwZSwgZWwpIHx8IHt9O1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIGN1c3RvbSBldmVudERhdGEgb2YgY29tcG9uZW50c1xuICAgICAgICAgICAgZWxzZSBpZiAoZWNEYXRhLmV2ZW50RGF0YSkge1xuICAgICAgICAgICAgICBwYXJhbXMgPSBleHRlbmQoe30sIGVjRGF0YS5ldmVudERhdGEpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb250cmFjdDogaWYgcGFyYW1zIHByZXBhcmVkIGluIG1vdXNlIGV2ZW50LFxuICAgICAgICAvLyB0aGVzZSBwcm9wZXJ0aWVzIG11c3QgYmUgc3BlY2lmaWVkOlxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgIGNvbXBvbmVudFR5cGU6IHN0cmluZyAoY29tcG9uZW50IG1haW4gdHlwZSlcbiAgICAgICAgLy8gICAgY29tcG9uZW50SW5kZXg6IG51bWJlclxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIE90aGVyd2lzZSBldmVudCBxdWVyeSBjYW4gbm90IHdvcmsuXG4gICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICB2YXIgY29tcG9uZW50VHlwZSA9IHBhcmFtcy5jb21wb25lbnRUeXBlO1xuICAgICAgICAgIHZhciBjb21wb25lbnRJbmRleCA9IHBhcmFtcy5jb21wb25lbnRJbmRleDtcbiAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBoaXN0b3JpYyByZWFzb246IHdoZW4gdHJpZ2dlciBieVxuICAgICAgICAgIC8vIG1hcmtMaW5lL21hcmtQb2ludC9tYXJrQXJlYSwgdGhlIGNvbXBvbmVudFR5cGUgaXNcbiAgICAgICAgICAvLyAnbWFya0xpbmUnLydtYXJrUG9pbnQnLydtYXJrQXJlYScsIGJ1dCB3ZSBzaG91bGQgYmV0dGVyXG4gICAgICAgICAgLy8gZW5hYmxlIHRoZW0gdG8gYmUgcXVlcmllZCBieSBzZXJpZXNJbmRleCwgc2luY2UgdGhlaXJcbiAgICAgICAgICAvLyBvcHRpb24gaXMgc2V0IGluIGVhY2ggc2VyaWVzLlxuICAgICAgICAgIGlmIChjb21wb25lbnRUeXBlID09PSAnbWFya0xpbmUnIHx8IGNvbXBvbmVudFR5cGUgPT09ICdtYXJrUG9pbnQnIHx8IGNvbXBvbmVudFR5cGUgPT09ICdtYXJrQXJlYScpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSAnc2VyaWVzJztcbiAgICAgICAgICAgIGNvbXBvbmVudEluZGV4ID0gcGFyYW1zLnNlcmllc0luZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbW9kZWwgPSBjb21wb25lbnRUeXBlICYmIGNvbXBvbmVudEluZGV4ICE9IG51bGwgJiYgZWNNb2RlbC5nZXRDb21wb25lbnQoY29tcG9uZW50VHlwZSwgY29tcG9uZW50SW5kZXgpO1xuICAgICAgICAgIHZhciB2aWV3ID0gbW9kZWwgJiYgX3RoaXNbbW9kZWwubWFpblR5cGUgPT09ICdzZXJpZXMnID8gJ19jaGFydHNNYXAnIDogJ19jb21wb25lbnRzTWFwJ11bbW9kZWwuX192aWV3SWRdO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBgZXZlbnQuY29tcG9uZW50VHlwZWAgYW5kIGBldmVudFtjb21wb25lbnRUcHlwZSArICdJbmRleCddYCBtdXN0IG5vdFxuICAgICAgICAgICAgLy8gYmUgbWlzc2VkLCBvdGhlcndpc2UgdGhlcmUgaXMgbm8gd2F5IHRvIGRpc3Rpbmd1aXNoIHNvdXJjZSBjb21wb25lbnQuXG4gICAgICAgICAgICAvLyBTZWUgYGRhdGFGb3JtYXQuZ2V0RGF0YVBhcmFtc2AuXG4gICAgICAgICAgICBpZiAoIWlzR2xvYmFsT3V0ICYmICEobW9kZWwgJiYgdmlldykpIHtcbiAgICAgICAgICAgICAgd2FybignbW9kZWwgb3IgdmlldyBjYW4gbm90IGJlIGZvdW5kIGJ5IHBhcmFtcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xuICAgICAgICAgIHBhcmFtcy50eXBlID0gZXZlTmFtZTtcbiAgICAgICAgICBfdGhpcy5fJGV2ZW50UHJvY2Vzc29yLmV2ZW50SW5mbyA9IHtcbiAgICAgICAgICAgIHRhcmdldEVsOiBlbCxcbiAgICAgICAgICAgIHBhY2tlZEV2ZW50OiBwYXJhbXMsXG4gICAgICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICAgICB2aWV3OiB2aWV3XG4gICAgICAgICAgfTtcbiAgICAgICAgICBfdGhpcy50cmlnZ2VyKGV2ZU5hbWUsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAvLyBDb25zaWRlciB0aGF0IHNvbWUgY29tcG9uZW50IChsaWtlIHRvb2x0aXAsIGJydXNoLCAuLi4pXG4gICAgICAvLyByZWdpc3RlciB6ciBldmVudCBoYW5kbGVyLCBidXQgdXNlciBldmVudCBoYW5kbGVyIG1pZ2h0XG4gICAgICAvLyBkbyBhbnl0aGluZywgc3VjaCBhcyBjYWxsIGBzZXRPcHRpb25gIG9yIGBkaXNwYXRjaEFjdGlvbmAsXG4gICAgICAvLyB3aGljaCBwcm9iYWJseSB1cGRhdGUgYW55IG9mIHRoZSBjb250ZW50IGFuZCBwcm9iYWJseVxuICAgICAgLy8gY2F1c2UgcHJvYmxlbSBpZiBpdCBpcyBjYWxsZWQgcHJldmlvdXMgb3RoZXIgaW5uZXIgaGFuZGxlcnMuXG4gICAgICBoYW5kbGVyLnpyRXZlbnRmdWxDYWxsQXRMYXN0ID0gdHJ1ZTtcbiAgICAgIF90aGlzLl96ci5vbihldmVOYW1lLCBoYW5kbGVyLCBfdGhpcyk7XG4gICAgfSk7XG4gICAgZWFjaChldmVudEFjdGlvbk1hcCwgZnVuY3Rpb24gKGFjdGlvblR5cGUsIGV2ZW50VHlwZSkge1xuICAgICAgX3RoaXMuX21lc3NhZ2VDZW50ZXIub24oZXZlbnRUeXBlLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50VHlwZSwgZXZlbnQpO1xuICAgICAgfSwgX3RoaXMpO1xuICAgIH0pO1xuICAgIC8vIEV4dHJhIGV2ZW50c1xuICAgIC8vIFRPRE8gcmVnaXN0ZXI/XG4gICAgZWFjaChbJ3NlbGVjdGNoYW5nZWQnXSwgZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgX3RoaXMuX21lc3NhZ2VDZW50ZXIub24oZXZlbnRUeXBlLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50VHlwZSwgZXZlbnQpO1xuICAgICAgfSwgX3RoaXMpO1xuICAgIH0pO1xuICAgIGhhbmRsZUxlZ2FjeVNlbGVjdEV2ZW50cyh0aGlzLl9tZXNzYWdlQ2VudGVyLCB0aGlzLCB0aGlzLl9hcGkpO1xuICB9O1xuICBFQ2hhcnRzLnByb3RvdHlwZS5pc0Rpc3Bvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcbiAgfTtcbiAgRUNoYXJ0cy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICBkaXNwb3NlZFdhcm5pbmcodGhpcy5pZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0T3B0aW9uKHtcbiAgICAgIHNlcmllczogW11cbiAgICB9LCB0cnVlKTtcbiAgfTtcbiAgRUNoYXJ0cy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgIGRpc3Bvc2VkV2FybmluZyh0aGlzLmlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xuICAgIHZhciBkb20gPSB0aGlzLmdldERvbSgpO1xuICAgIGlmIChkb20pIHtcbiAgICAgIG1vZGVsVXRpbC5zZXRBdHRyaWJ1dGUodGhpcy5nZXREb20oKSwgRE9NX0FUVFJJQlVURV9LRVksICcnKTtcbiAgICB9XG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcbiAgICB2YXIgYXBpID0gY2hhcnQuX2FwaTtcbiAgICB2YXIgZWNNb2RlbCA9IGNoYXJ0Ll9tb2RlbDtcbiAgICBlYWNoKGNoYXJ0Ll9jb21wb25lbnRzVmlld3MsIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIGNvbXBvbmVudC5kaXNwb3NlKGVjTW9kZWwsIGFwaSk7XG4gICAgfSk7XG4gICAgZWFjaChjaGFydC5fY2hhcnRzVmlld3MsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgY2hhcnQuZGlzcG9zZShlY01vZGVsLCBhcGkpO1xuICAgIH0pO1xuICAgIC8vIERpc3Bvc2UgYWZ0ZXIgYWxsIHZpZXdzIGRpc3Bvc2VkXG4gICAgY2hhcnQuX3pyLmRpc3Bvc2UoKTtcbiAgICAvLyBTZXQgcHJvcGVydGllcyB0byBudWxsLlxuICAgIC8vIFRvIHJlZHVjZSB0aGUgbWVtb3J5IGNvc3QgaW4gY2FzZSB0aGUgdG9wIGNvZGUgc3RpbGwgaG9sZHMgdGhpcyBpbnN0YW5jZSB1bmV4cGVjdGVkbHkuXG4gICAgY2hhcnQuX2RvbSA9IGNoYXJ0Ll9tb2RlbCA9IGNoYXJ0Ll9jaGFydHNNYXAgPSBjaGFydC5fY29tcG9uZW50c01hcCA9IGNoYXJ0Ll9jaGFydHNWaWV3cyA9IGNoYXJ0Ll9jb21wb25lbnRzVmlld3MgPSBjaGFydC5fc2NoZWR1bGVyID0gY2hhcnQuX2FwaSA9IGNoYXJ0Ll96ciA9IGNoYXJ0Ll90aHJvdHRsZWRackZsdXNoID0gY2hhcnQuX3RoZW1lID0gY2hhcnQuX2Nvb3JkU3lzTWdyID0gY2hhcnQuX21lc3NhZ2VDZW50ZXIgPSBudWxsO1xuICAgIGRlbGV0ZSBpbnN0YW5jZXNbY2hhcnQuaWRdO1xuICB9O1xuICAvKipcclxuICAgKiBSZXNpemUgdGhlIGNoYXJ0XHJcbiAgICovXG4gIEVDaGFydHMucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgaWYgKHRoaXNbSU5fTUFJTl9QUk9DRVNTX0tFWV0pIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdgcmVzaXplYCBzaG91bGQgbm90IGJlIGNhbGxlZCBkdXJpbmcgbWFpbiBwcm9jZXNzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgIGRpc3Bvc2VkV2FybmluZyh0aGlzLmlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fenIucmVzaXplKG9wdHMpO1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgLy8gUmVzaXplIGxvYWRpbmcgZWZmZWN0XG4gICAgdGhpcy5fbG9hZGluZ0ZYICYmIHRoaXMuX2xvYWRpbmdGWC5yZXNpemUoKTtcbiAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5lZWRQcmVwYXJlID0gZWNNb2RlbC5yZXNldE9wdGlvbignbWVkaWEnKTtcbiAgICB2YXIgc2lsZW50ID0gb3B0cyAmJiBvcHRzLnNpbGVudDtcbiAgICAvLyBUaGVyZSBpcyBzb21lIHJlYWwgY2FzZXMgdGhhdDpcbiAgICAvLyBjaGFydC5zZXRPcHRpb24ob3B0aW9uLCB7IGxhenlVcGRhdGU6IHRydWUgfSk7XG4gICAgLy8gY2hhcnQucmVzaXplKCk7XG4gICAgaWYgKHRoaXNbUEVORElOR19VUERBVEVdKSB7XG4gICAgICBpZiAoc2lsZW50ID09IG51bGwpIHtcbiAgICAgICAgc2lsZW50ID0gdGhpc1tQRU5ESU5HX1VQREFURV0uc2lsZW50O1xuICAgICAgfVxuICAgICAgbmVlZFByZXBhcmUgPSB0cnVlO1xuICAgICAgdGhpc1tQRU5ESU5HX1VQREFURV0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU19LRVldID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgbmVlZFByZXBhcmUgJiYgcHJlcGFyZSh0aGlzKTtcbiAgICAgIHVwZGF0ZU1ldGhvZHMudXBkYXRlLmNhbGwodGhpcywge1xuICAgICAgICB0eXBlOiAncmVzaXplJyxcbiAgICAgICAgYW5pbWF0aW9uOiBleHRlbmQoe1xuICAgICAgICAgIC8vIERpc2FibGUgYW5pbWF0aW9uXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSwgb3B0cyAmJiBvcHRzLmFuaW1hdGlvbilcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTX0tFWV0gPSBmYWxzZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTX0tFWV0gPSBmYWxzZTtcbiAgICBmbHVzaFBlbmRpbmdBY3Rpb25zLmNhbGwodGhpcywgc2lsZW50KTtcbiAgICB0cmlnZ2VyVXBkYXRlZEV2ZW50LmNhbGwodGhpcywgc2lsZW50KTtcbiAgfTtcbiAgRUNoYXJ0cy5wcm90b3R5cGUuc2hvd0xvYWRpbmcgPSBmdW5jdGlvbiAobmFtZSwgY2ZnKSB7XG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICBkaXNwb3NlZFdhcm5pbmcodGhpcy5pZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgICAgY2ZnID0gbmFtZTtcbiAgICAgIG5hbWUgPSAnJztcbiAgICB9XG4gICAgbmFtZSA9IG5hbWUgfHwgJ2RlZmF1bHQnO1xuICAgIHRoaXMuaGlkZUxvYWRpbmcoKTtcbiAgICBpZiAoIWxvYWRpbmdFZmZlY3RzW25hbWVdKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdMb2FkaW5nIGVmZmVjdHMgJyArIG5hbWUgKyAnIG5vdCBleGlzdHMuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlbCA9IGxvYWRpbmdFZmZlY3RzW25hbWVdKHRoaXMuX2FwaSwgY2ZnKTtcbiAgICB2YXIgenIgPSB0aGlzLl96cjtcbiAgICB0aGlzLl9sb2FkaW5nRlggPSBlbDtcbiAgICB6ci5hZGQoZWwpO1xuICB9O1xuICAvKipcclxuICAgKiBIaWRlIGxvYWRpbmcgZWZmZWN0XHJcbiAgICovXG4gIEVDaGFydHMucHJvdG90eXBlLmhpZGVMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgZGlzcG9zZWRXYXJuaW5nKHRoaXMuaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkaW5nRlggJiYgdGhpcy5fenIucmVtb3ZlKHRoaXMuX2xvYWRpbmdGWCk7XG4gICAgdGhpcy5fbG9hZGluZ0ZYID0gbnVsbDtcbiAgfTtcbiAgRUNoYXJ0cy5wcm90b3R5cGUubWFrZUFjdGlvbkZyb21FdmVudCA9IGZ1bmN0aW9uIChldmVudE9iaikge1xuICAgIHZhciBwYXlsb2FkID0gZXh0ZW5kKHt9LCBldmVudE9iaik7XG4gICAgcGF5bG9hZC50eXBlID0gZXZlbnRBY3Rpb25NYXBbZXZlbnRPYmoudHlwZV07XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwYXJhbSBvcHQgSWYgcGFzcyBib29sZWFuLCBtZWFucyBvcHQuc2lsZW50XHJcbiAgICogQHBhcmFtIG9wdC5zaWxlbnQgRGVmYXVsdCBgZmFsc2VgLiBXaGV0aGVyIHRyaWdnZXIgZXZlbnRzLlxyXG4gICAqIEBwYXJhbSBvcHQuZmx1c2ggRGVmYXVsdCBgdW5kZWZpbmVkYC5cclxuICAgKiAgICAgICAgdHJ1ZTogRmx1c2ggaW1tZWRpYXRlbHksIGFuZCB0aGVuIHBpeGVsIGluIGNhbnZhcyBjYW4gYmUgZmV0Y2hlZFxyXG4gICAqICAgICAgICAgICAgaW1tZWRpYXRlbHkuIENhdXRpb246IGl0IG1pZ2h0IGFmZmVjdCBwZXJmb3JtYW5jZS5cclxuICAgKiAgICAgICAgZmFsc2U6IE5vdCBmbHVzaC5cclxuICAgKiAgICAgICAgdW5kZWZpbmVkOiBBdXRvIGRlY2lkZSB3aGV0aGVyIHBlcmZvcm0gZmx1c2guXHJcbiAgICovXG4gIEVDaGFydHMucHJvdG90eXBlLmRpc3BhdGNoQWN0aW9uID0gZnVuY3Rpb24gKHBheWxvYWQsIG9wdCkge1xuICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgZGlzcG9zZWRXYXJuaW5nKHRoaXMuaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzT2JqZWN0KG9wdCkpIHtcbiAgICAgIG9wdCA9IHtcbiAgICAgICAgc2lsZW50OiAhIW9wdFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFhY3Rpb25zW3BheWxvYWQudHlwZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQXZvaWQgZGlzcGF0Y2ggYWN0aW9uIGJlZm9yZSBzZXRPcHRpb24uIEVzcGVjaWFsbHkgaW4gYGNvbm5lY3RgLlxuICAgIGlmICghdGhpcy5fbW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gTWF5IGRpc3BhdGNoQWN0aW9uIGluIHJlbmRlcmluZyBwcm9jZWR1cmVcbiAgICBpZiAodGhpc1tJTl9NQUlOX1BST0NFU1NfS0VZXSkge1xuICAgICAgdGhpcy5fcGVuZGluZ0FjdGlvbnMucHVzaChwYXlsb2FkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNpbGVudCA9IG9wdC5zaWxlbnQ7XG4gICAgZG9EaXNwYXRjaEFjdGlvbi5jYWxsKHRoaXMsIHBheWxvYWQsIHNpbGVudCk7XG4gICAgdmFyIGZsdXNoID0gb3B0LmZsdXNoO1xuICAgIGlmIChmbHVzaCkge1xuICAgICAgdGhpcy5fenIuZmx1c2goKTtcbiAgICB9IGVsc2UgaWYgKGZsdXNoICE9PSBmYWxzZSAmJiBlbnYuYnJvd3Nlci53ZUNoYXQpIHtcbiAgICAgIC8vIEluIFdlQ2hhdCBlbWJlZGRlZCBicm93c2VyLCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBhbmQgYHNldEludGVydmFsYFxuICAgICAgLy8gaGFuZyB3aGVuIHNsaWRpbmcgcGFnZSAob24gdG91Y2ggZXZlbnQpLCB3aGljaCBjYXVzZSB0aGF0IHpyIGRvZXMgbm90XG4gICAgICAvLyByZWZyZXNoIHVudGlsIHVzZXIgaW50ZXJhY3Rpb24gZmluaXNoZWQsIHdoaWNoIGlzIG5vdCBleHBlY3RlZC5cbiAgICAgIC8vIEJ1dCBgZGlzcGF0Y2hBY3Rpb25gIG1heSBiZSBjYWxsZWQgdG9vIGZyZXF1ZW50bHkgd2hlbiBwYW4gb24gdG91Y2hcbiAgICAgIC8vIHNjcmVlbiwgd2hpY2ggaW1wYWN0cyBwZXJmb3JtYW5jZSBpZiBkbyBub3QgdGhyb3R0bGUgdGhlbS5cbiAgICAgIHRoaXMuX3Rocm90dGxlZFpyRmx1c2goKTtcbiAgICB9XG4gICAgZmx1c2hQZW5kaW5nQWN0aW9ucy5jYWxsKHRoaXMsIHNpbGVudCk7XG4gICAgdHJpZ2dlclVwZGF0ZWRFdmVudC5jYWxsKHRoaXMsIHNpbGVudCk7XG4gIH07XG4gIEVDaGFydHMucHJvdG90eXBlLnVwZGF0ZUxhYmVsTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGxpZmVjeWNsZS50cmlnZ2VyKCdzZXJpZXM6bGF5b3V0bGFiZWxzJywgdGhpcy5fbW9kZWwsIHRoaXMuX2FwaSwge1xuICAgICAgLy8gTm90IGFkZGluZyBzZXJpZXMgbGFiZWxzLlxuICAgICAgLy8gVE9ET1xuICAgICAgdXBkYXRlZFNlcmllczogW11cbiAgICB9KTtcbiAgfTtcbiAgRUNoYXJ0cy5wcm90b3R5cGUuYXBwZW5kRGF0YSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgIGRpc3Bvc2VkV2FybmluZyh0aGlzLmlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNlcmllc0luZGV4ID0gcGFyYW1zLnNlcmllc0luZGV4O1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5nZXRNb2RlbCgpO1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChzZXJpZXNJbmRleCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChwYXJhbXMuZGF0YSAmJiBzZXJpZXNNb2RlbCk7XG4gICAgfVxuICAgIHNlcmllc01vZGVsLmFwcGVuZERhdGEocGFyYW1zKTtcbiAgICAvLyBOb3RlOiBgYXBwZW5kRGF0YWAgZG9lcyBub3Qgc3VwcG9ydCB0aGF0IHVwZGF0ZSBleHRlbnQgb2YgY29vcmRpbmF0ZVxuICAgIC8vIHN5c3RlbSwgdXRpbCBzb21lIHNjZW5hcmlvIHJlcXVpcmUgdGhhdC4gSW4gdGhlIGV4cGVjdGVkIHVzYWdlIG9mXG4gICAgLy8gYGFwcGVuZERhdGFgLCB0aGUgaW5pdGlhbCBleHRlbnQgb2YgY29vcmRpbmF0ZSBzeXN0ZW0gc2hvdWxkIGJldHRlclxuICAgIC8vIGJlIGZpeGVkIGJ5IGF4aXMgYG1pbmAvYG1heGAgc2V0dGluZyBvciBpbml0aWFsIGRhdGEsIG90aGVyd2lzZSBpZlxuICAgIC8vIHRoZSBleHRlbnQgY2hhbmdlZCB3aGlsZSBgYXBwZW5kRGF0YWAsIHRoZSBsb2NhdGlvbiBvZiB0aGUgcGFpbnRlZFxuICAgIC8vIGdyYXBoaWMgZWxlbWVudHMgaGF2ZSB0byBiZSBjaGFuZ2VkLCB3aGljaCBtYWtlIHRoZSB1c2FnZSBvZlxuICAgIC8vIGBhcHBlbmREYXRhYCBtZWFuaW5nbGVzcy5cbiAgICB0aGlzLl9zY2hlZHVsZXIudW5maW5pc2hlZCA9IHRydWU7XG4gICAgdGhpcy5nZXRacigpLndha2VVcCgpO1xuICB9O1xuICAvLyBBIHdvcmsgYXJvdW5kIGZvciBubyBgaW50ZXJuYWxgIG1vZGlmaWVyIGluIHRzIHlldCBidXRcbiAgLy8gbmVlZCB0byBzdHJpY3RseSBoaWRlIHByaXZhdGUgbWV0aG9kcyB0byBKUyB1c2Vycy5cbiAgRUNoYXJ0cy5pbnRlcm5hbEZpZWxkID0gZnVuY3Rpb24gKCkge1xuICAgIHByZXBhcmUgPSBmdW5jdGlvbiAoZWNJbnMpIHtcbiAgICAgIHZhciBzY2hlZHVsZXIgPSBlY0lucy5fc2NoZWR1bGVyO1xuICAgICAgc2NoZWR1bGVyLnJlc3RvcmVQaXBlbGluZXMoZWNJbnMuX21vZGVsKTtcbiAgICAgIHNjaGVkdWxlci5wcmVwYXJlU3RhZ2VUYXNrcygpO1xuICAgICAgcHJlcGFyZVZpZXcoZWNJbnMsIHRydWUpO1xuICAgICAgcHJlcGFyZVZpZXcoZWNJbnMsIGZhbHNlKTtcbiAgICAgIHNjaGVkdWxlci5wbGFuKCk7XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIFByZXBhcmUgdmlldyBpbnN0YW5jZXMgb2YgY2hhcnRzIGFuZCBjb21wb25lbnRzXHJcbiAgICAgKi9cbiAgICBwcmVwYXJlVmlldyA9IGZ1bmN0aW9uIChlY0lucywgaXNDb21wb25lbnQpIHtcbiAgICAgIHZhciBlY01vZGVsID0gZWNJbnMuX21vZGVsO1xuICAgICAgdmFyIHNjaGVkdWxlciA9IGVjSW5zLl9zY2hlZHVsZXI7XG4gICAgICB2YXIgdmlld0xpc3QgPSBpc0NvbXBvbmVudCA/IGVjSW5zLl9jb21wb25lbnRzVmlld3MgOiBlY0lucy5fY2hhcnRzVmlld3M7XG4gICAgICB2YXIgdmlld01hcCA9IGlzQ29tcG9uZW50ID8gZWNJbnMuX2NvbXBvbmVudHNNYXAgOiBlY0lucy5fY2hhcnRzTWFwO1xuICAgICAgdmFyIHpyID0gZWNJbnMuX3pyO1xuICAgICAgdmFyIGFwaSA9IGVjSW5zLl9hcGk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZpZXdMaXN0W2ldLl9fYWxpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlzQ29tcG9uZW50ID8gZWNNb2RlbC5lYWNoQ29tcG9uZW50KGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBtb2RlbCkge1xuICAgICAgICBjb21wb25lbnRUeXBlICE9PSAnc2VyaWVzJyAmJiBkb1ByZXBhcmUobW9kZWwpO1xuICAgICAgfSkgOiBlY01vZGVsLmVhY2hTZXJpZXMoZG9QcmVwYXJlKTtcbiAgICAgIGZ1bmN0aW9uIGRvUHJlcGFyZShtb2RlbCkge1xuICAgICAgICAvLyBCeSBkZWZhdWx0IHZpZXcgd2lsbCBiZSByZXVzZWQgaWYgcG9zc2libGUgZm9yIHRoZSBjYXNlIHRoYXQgYHNldE9wdGlvbmAgd2l0aCBcIm5vdE1lcmdlXCJcbiAgICAgICAgLy8gbW9kZSBhbmQgbmVlZCB0byBlbmFibGUgdHJhbnNpdGlvbiBhbmltYXRpb24uIChVc3VhbGx5LCB3aGVuIHRoZXkgaGF2ZSB0aGUgc2FtZSBpZCwgb3JcbiAgICAgICAgLy8gZXNwZWNpYWxseSBubyBpZCBidXQgaGF2ZSB0aGUgc2FtZSB0eXBlICYgbmFtZSAmIGluZGV4LiBTZWUgdGhlIGBtb2RlbC5pZGAgZ2VuZXJhdGlvblxuICAgICAgICAvLyBydWxlIGluIGBtYWtlSWRBbmROYW1lYCBhbmQgYHZpZXdJZGAgZ2VuZXJhdGlvbiBydWxlIGhlcmUpLlxuICAgICAgICAvLyBCdXQgaW4gYHJlcGxhY2VNZXJnZWAgbW9kZSwgdGhpcyBmZWF0dXJlIHNob3VsZCBiZSBhYmxlIHRvIGRpc2FibGVkIHdoZW4gaXQgaXMgY2xlYXIgdGhhdFxuICAgICAgICAvLyB0aGUgbmV3IG1vZGVsIGhhcyBub3RoaW5nIHRvIGRvIHdpdGggdGhlIG9sZCBtb2RlbC5cbiAgICAgICAgdmFyIHJlcXVpcmVOZXdWaWV3ID0gbW9kZWwuX19yZXF1aXJlTmV3VmlldztcbiAgICAgICAgLy8gVGhpcyBjb21tYW5kIHNob3VsZCBub3Qgd29yayB0d2ljZS5cbiAgICAgICAgbW9kZWwuX19yZXF1aXJlTmV3VmlldyA9IGZhbHNlO1xuICAgICAgICAvLyBDb25zaWRlcjogaWQgc2FtZSBhbmQgdHlwZSBjaGFuZ2VkLlxuICAgICAgICB2YXIgdmlld0lkID0gJ19lY18nICsgbW9kZWwuaWQgKyAnXycgKyBtb2RlbC50eXBlO1xuICAgICAgICB2YXIgdmlldyA9ICFyZXF1aXJlTmV3VmlldyAmJiB2aWV3TWFwW3ZpZXdJZF07XG4gICAgICAgIGlmICghdmlldykge1xuICAgICAgICAgIHZhciBjbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZShtb2RlbC50eXBlKTtcbiAgICAgICAgICB2YXIgQ2xhenogPSBpc0NvbXBvbmVudCA/IENvbXBvbmVudFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIGNsYXNzVHlwZS5zdWIpIDpcbiAgICAgICAgICAvLyBGSVhNRTpUU1xuICAgICAgICAgIC8vIChDaGFydFZpZXcgYXMgQ2hhcnRWaWV3Q29uc3RydWN0b3IpLmdldENsYXNzKCdzZXJpZXMnLCBjbGFzc1R5cGUuc3ViKVxuICAgICAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXQsIHN0aWxsIHN1cHBvcnQgYSBjaGFydCB0eXBlIGRlY2xhcmVkIGFzIG9ubHkgc3ViVHlwZVxuICAgICAgICAgIC8vIGxpa2UgXCJsaXF1aWRmaWxsXCIsIGJ1dCByZWNvbW1lbmQgXCJzZXJpZXMubGlxdWlkZmlsbFwiXG4gICAgICAgICAgLy8gQnV0IG5lZWQgYSBiYXNlIGNsYXNzIHRvIG1ha2UgYSB0eXBlIHNlcmllcy5cbiAgICAgICAgICBDaGFydFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLnN1Yik7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydChDbGF6eiwgY2xhc3NUeXBlLnN1YiArICcgZG9lcyBub3QgZXhpc3QuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZpZXcgPSBuZXcgQ2xhenooKTtcbiAgICAgICAgICB2aWV3LmluaXQoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICB2aWV3TWFwW3ZpZXdJZF0gPSB2aWV3O1xuICAgICAgICAgIHZpZXdMaXN0LnB1c2godmlldyk7XG4gICAgICAgICAgenIuYWRkKHZpZXcuZ3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLl9fdmlld0lkID0gdmlldy5fX2lkID0gdmlld0lkO1xuICAgICAgICB2aWV3Ll9fYWxpdmUgPSB0cnVlO1xuICAgICAgICB2aWV3Ll9fbW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdmlldy5ncm91cC5fX2VjQ29tcG9uZW50SW5mbyA9IHtcbiAgICAgICAgICBtYWluVHlwZTogbW9kZWwubWFpblR5cGUsXG4gICAgICAgICAgaW5kZXg6IG1vZGVsLmNvbXBvbmVudEluZGV4XG4gICAgICAgIH07XG4gICAgICAgICFpc0NvbXBvbmVudCAmJiBzY2hlZHVsZXIucHJlcGFyZVZpZXcodmlldywgbW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdMaXN0Lmxlbmd0aDspIHtcbiAgICAgICAgdmFyIHZpZXcgPSB2aWV3TGlzdFtpXTtcbiAgICAgICAgaWYgKCF2aWV3Ll9fYWxpdmUpIHtcbiAgICAgICAgICAhaXNDb21wb25lbnQgJiYgdmlldy5yZW5kZXJUYXNrLmRpc3Bvc2UoKTtcbiAgICAgICAgICB6ci5yZW1vdmUodmlldy5ncm91cCk7XG4gICAgICAgICAgdmlldy5kaXNwb3NlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgdmlld0xpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGlmICh2aWV3TWFwW3ZpZXcuX19pZF0gPT09IHZpZXcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB2aWV3TWFwW3ZpZXcuX19pZF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZpZXcuX19pZCA9IHZpZXcuZ3JvdXAuX19lY0NvbXBvbmVudEluZm8gPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlRGlyZWN0bHkgPSBmdW5jdGlvbiAoZWNJbnMsIG1ldGhvZCwgcGF5bG9hZCwgbWFpblR5cGUsIHN1YlR5cGUpIHtcbiAgICAgIHZhciBlY01vZGVsID0gZWNJbnMuX21vZGVsO1xuICAgICAgZWNNb2RlbC5zZXRVcGRhdGVQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgLy8gYnJvYWRjYXN0XG4gICAgICBpZiAoIW1haW5UeXBlKSB7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIENoYXJ0IHdpbGwgbm90IGJlIHVwZGF0ZSBkaXJlY3RseSBoZXJlLCBleGNlcHQgc2V0IGRpcnR5LlxuICAgICAgICAvLyBCdXQgdGhlcmUgaXMgbm8gc3VjaCBzY2VuYXJpbyBub3cuXG4gICAgICAgIGVhY2goW10uY29uY2F0KGVjSW5zLl9jb21wb25lbnRzVmlld3MpLmNvbmNhdChlY0lucy5fY2hhcnRzVmlld3MpLCBjYWxsVmlldyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBxdWVyeSA9IHt9O1xuICAgICAgcXVlcnlbbWFpblR5cGUgKyAnSWQnXSA9IHBheWxvYWRbbWFpblR5cGUgKyAnSWQnXTtcbiAgICAgIHF1ZXJ5W21haW5UeXBlICsgJ0luZGV4J10gPSBwYXlsb2FkW21haW5UeXBlICsgJ0luZGV4J107XG4gICAgICBxdWVyeVttYWluVHlwZSArICdOYW1lJ10gPSBwYXlsb2FkW21haW5UeXBlICsgJ05hbWUnXTtcbiAgICAgIHZhciBjb25kaXRpb24gPSB7XG4gICAgICAgIG1haW5UeXBlOiBtYWluVHlwZSxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICB9O1xuICAgICAgc3ViVHlwZSAmJiAoY29uZGl0aW9uLnN1YlR5cGUgPSBzdWJUeXBlKTsgLy8gc3ViVHlwZSBtYXkgYmUgJycgYnkgcGFyc2VDbGFzc1R5cGU7XG4gICAgICB2YXIgZXhjbHVkZVNlcmllc0lkID0gcGF5bG9hZC5leGNsdWRlU2VyaWVzSWQ7XG4gICAgICB2YXIgZXhjbHVkZVNlcmllc0lkTWFwO1xuICAgICAgaWYgKGV4Y2x1ZGVTZXJpZXNJZCAhPSBudWxsKSB7XG4gICAgICAgIGV4Y2x1ZGVTZXJpZXNJZE1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgICAgICAgZWFjaChtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShleGNsdWRlU2VyaWVzSWQpLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICB2YXIgbW9kZWxJZCA9IG1vZGVsVXRpbC5jb252ZXJ0T3B0aW9uSWROYW1lKGlkLCBudWxsKTtcbiAgICAgICAgICBpZiAobW9kZWxJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBleGNsdWRlU2VyaWVzSWRNYXAuc2V0KG1vZGVsSWQsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBJZiBkaXNwYXRjaEFjdGlvbiBiZWZvcmUgc2V0T3B0aW9uLCBkbyBub3RoaW5nLlxuICAgICAgZWNNb2RlbCAmJiBlY01vZGVsLmVhY2hDb21wb25lbnQoY29uZGl0aW9uLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdmFyIGlzRXhjbHVkZWQgPSBleGNsdWRlU2VyaWVzSWRNYXAgJiYgZXhjbHVkZVNlcmllc0lkTWFwLmdldChtb2RlbC5pZCkgIT0gbnVsbDtcbiAgICAgICAgaWYgKGlzRXhjbHVkZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAoaXNIaWdoRG93blBheWxvYWQocGF5bG9hZCkpIHtcbiAgICAgICAgICBpZiAobW9kZWwgaW5zdGFuY2VvZiBTZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQudHlwZSA9PT0gSElHSExJR0hUX0FDVElPTl9UWVBFICYmICFwYXlsb2FkLm5vdEJsdXIgJiYgIW1vZGVsLmdldChbJ2VtcGhhc2lzJywgJ2Rpc2FibGVkJ10pKSB7XG4gICAgICAgICAgICAgIGJsdXJTZXJpZXNGcm9tSGlnaGxpZ2h0UGF5bG9hZChtb2RlbCwgcGF5bG9hZCwgZWNJbnMuX2FwaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGZpbmRDb21wb25lbnRIaWdoRG93bkRpc3BhdGNoZXJzKG1vZGVsLm1haW5UeXBlLCBtb2RlbC5jb21wb25lbnRJbmRleCwgcGF5bG9hZC5uYW1lLCBlY0lucy5fYXBpKSxcbiAgICAgICAgICAgICAgZm9jdXNTZWxmID0gX2EuZm9jdXNTZWxmLFxuICAgICAgICAgICAgICBkaXNwYXRjaGVycyA9IF9hLmRpc3BhdGNoZXJzO1xuICAgICAgICAgICAgaWYgKHBheWxvYWQudHlwZSA9PT0gSElHSExJR0hUX0FDVElPTl9UWVBFICYmIGZvY3VzU2VsZiAmJiAhcGF5bG9hZC5ub3RCbHVyKSB7XG4gICAgICAgICAgICAgIGJsdXJDb21wb25lbnQobW9kZWwubWFpblR5cGUsIG1vZGVsLmNvbXBvbmVudEluZGV4LCBlY0lucy5fYXBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBFTkRJTkc6XG4gICAgICAgICAgICAvLyBXaGV0aGVyIHRvIHB1dCB0aGlzIFwiZW50ZXIgZW1waGFzaXNcIiBjb2RlIGluIGBDb21wb25lbnRWaWV3YCxcbiAgICAgICAgICAgIC8vIHdoaWNoIHdpbGwgYmUgdGhlIHNhbWUgYXMgYENoYXJ0Vmlld2AgYnV0IG1pZ2h0IGJlIG5vdCBuZWNlc3NhcnlcbiAgICAgICAgICAgIC8vIGFuZCB3aWxsIGJlIGZhciBmcm9tIHRoaXMgbG9naWMuXG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2hlcnMpIHtcbiAgICAgICAgICAgICAgZWFjaChkaXNwYXRjaGVycywgZnVuY3Rpb24gKGRpc3BhdGNoZXIpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnR5cGUgPT09IEhJR0hMSUdIVF9BQ1RJT05fVFlQRSA/IGVudGVyRW1waGFzaXMoZGlzcGF0Y2hlcikgOiBsZWF2ZUVtcGhhc2lzKGRpc3BhdGNoZXIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTZWxlY3RDaGFuZ2VQYXlsb2FkKHBheWxvYWQpKSB7XG4gICAgICAgICAgLy8gVE9ETyBnZW9cbiAgICAgICAgICBpZiAobW9kZWwgaW5zdGFuY2VvZiBTZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgdG9nZ2xlU2VsZWN0aW9uRnJvbVBheWxvYWQobW9kZWwsIHBheWxvYWQsIGVjSW5zLl9hcGkpO1xuICAgICAgICAgICAgdXBkYXRlU2VyaWVzRWxlbWVudFNlbGVjdGlvbihtb2RlbCk7XG4gICAgICAgICAgICBtYXJrU3RhdHVzVG9VcGRhdGUoZWNJbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgZWNJbnMpO1xuICAgICAgZWNNb2RlbCAmJiBlY01vZGVsLmVhY2hDb21wb25lbnQoY29uZGl0aW9uLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdmFyIGlzRXhjbHVkZWQgPSBleGNsdWRlU2VyaWVzSWRNYXAgJiYgZXhjbHVkZVNlcmllc0lkTWFwLmdldChtb2RlbC5pZCkgIT0gbnVsbDtcbiAgICAgICAgaWYgKGlzRXhjbHVkZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBjYWxsVmlldyhlY0luc1ttYWluVHlwZSA9PT0gJ3NlcmllcycgPyAnX2NoYXJ0c01hcCcgOiAnX2NvbXBvbmVudHNNYXAnXVttb2RlbC5fX3ZpZXdJZF0pO1xuICAgICAgfSwgZWNJbnMpO1xuICAgICAgZnVuY3Rpb24gY2FsbFZpZXcodmlldykge1xuICAgICAgICB2aWV3ICYmIHZpZXcuX19hbGl2ZSAmJiB2aWV3W21ldGhvZF0gJiYgdmlld1ttZXRob2RdKHZpZXcuX19tb2RlbCwgZWNNb2RlbCwgZWNJbnMuX2FwaSwgcGF5bG9hZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGRhdGVNZXRob2RzID0ge1xuICAgICAgcHJlcGFyZUFuZFVwZGF0ZTogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgcHJlcGFyZSh0aGlzKTtcbiAgICAgICAgdXBkYXRlTWV0aG9kcy51cGRhdGUuY2FsbCh0aGlzLCBwYXlsb2FkLCB7XG4gICAgICAgICAgLy8gTmVlZHMgdG8gbWFyayBvcHRpb24gY2hhbmdlZCBpZiBuZXdPcHRpb24gaXMgZ2l2ZW4uXG4gICAgICAgICAgLy8gSXQncyBmcm9tIE1hZ2ljVHlwZS5cbiAgICAgICAgICAvLyBUT0RPIElmIHVzZSBhIHNlcGFyYXRlIGZsYWcgb3B0aW9uQ2hhbmdlZCBpbiBwYXlsb2FkP1xuICAgICAgICAgIG9wdGlvbkNoYW5nZWQ6IHBheWxvYWQubmV3T3B0aW9uICE9IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiAocGF5bG9hZCwgdXBkYXRlUGFyYW1zKSB7XG4gICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgIHZhciB6ciA9IHRoaXMuX3pyO1xuICAgICAgICB2YXIgY29vcmRTeXNNZ3IgPSB0aGlzLl9jb29yZFN5c01ncjtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuX3NjaGVkdWxlcjtcbiAgICAgICAgLy8gdXBkYXRlIGJlZm9yZSBzZXRPcHRpb25cbiAgICAgICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVjTW9kZWwuc2V0VXBkYXRlUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgICAgc2NoZWR1bGVyLnJlc3RvcmVEYXRhKGVjTW9kZWwsIHBheWxvYWQpO1xuICAgICAgICBzY2hlZHVsZXIucGVyZm9ybVNlcmllc1Rhc2tzKGVjTW9kZWwpO1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIFNhdmUgdG90YWwgZWNNb2RlbCBoZXJlIGZvciB1bmRvL3JlZG8gKGFmdGVyIHJlc3RvcmluZyBkYXRhIGFuZCBiZWZvcmUgcHJvY2Vzc2luZyBkYXRhKS5cbiAgICAgICAgLy8gVW5kbyAocmVzdG9yYXRpb24gb2YgdG90YWwgZWNNb2RlbCkgY2FuIGJlIGNhcnJpZWQgb3V0IGluICdhY3Rpb24nIG9yIG91dHNpZGUgQVBJIGNhbGwuXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgY29vcmRpbmF0ZSBzeXN0ZW0gZWFjaCB1cGRhdGVcbiAgICAgICAgLy8gSW4gTGluZVZpZXcgbWF5IHNhdmUgdGhlIG9sZCBjb29yZGluYXRlIHN5c3RlbSBhbmQgdXNlIGl0IHRvIGdldCB0aGUgb3JpZ2luYWwgcG9pbnQuXG4gICAgICAgIGNvb3JkU3lzTWdyLmNyZWF0ZShlY01vZGVsLCBhcGkpO1xuICAgICAgICBzY2hlZHVsZXIucGVyZm9ybURhdGFQcm9jZXNzb3JUYXNrcyhlY01vZGVsLCBwYXlsb2FkKTtcbiAgICAgICAgLy8gQ3VycmVudCBzdHJlYW0gcmVuZGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGF0YSBwcm9jZXNzLiBTbyB3ZSBjYW4gdXBkYXRlXG4gICAgICAgIC8vIHN0cmVhbSBtb2RlcyBhZnRlciBkYXRhIHByb2Nlc3NpbmcsIHdoZXJlIHRoZSBmaWx0ZXJlZCBkYXRhIGlzIHVzZWQgdG9cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gdXNlIHByb2dyZXNzaXZlIHJlbmRlcmluZy5cbiAgICAgICAgdXBkYXRlU3RyZWFtTW9kZXModGhpcywgZWNNb2RlbCk7XG4gICAgICAgIC8vIFdlIHVwZGF0ZSBzdHJlYW0gbW9kZXMgYmVmb3JlIGNvb3JkaW5hdGUgc3lzdGVtIHVwZGF0ZWQsIHRoZW4gdGhlIG1vZGVzIGluZm9cbiAgICAgICAgLy8gY2FuIGJlIGZldGNoZWQgd2hlbiBjb29yZCBzeXMgdXBkYXRpbmcgKGNvbnNpZGVyIHRoZSBiYXJHcmlkIGV4dGVudCBmaXgpLiBCdXRcbiAgICAgICAgLy8gdGhlIGRyYXdiYWNrIGlzIHRoZSBmdWxsIGNvb3JkIGluZm8gY2FuIG5vdCBiZSBmZXRjaGVkLiBGb3J0dW5hdGVseSB0aGlzIGZ1bGxcbiAgICAgICAgLy8gY29vcmQgaXMgbm90IHJlcXVpcmVkIGluIHN0cmVhbSBtb2RlIHVwZGF0ZXIgY3VycmVudGx5LlxuICAgICAgICBjb29yZFN5c01nci51cGRhdGUoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgY2xlYXJDb2xvclBhbGV0dGUoZWNNb2RlbCk7XG4gICAgICAgIHNjaGVkdWxlci5wZXJmb3JtVmlzdWFsVGFza3MoZWNNb2RlbCwgcGF5bG9hZCk7XG4gICAgICAgIHJlbmRlcih0aGlzLCBlY01vZGVsLCBhcGksIHBheWxvYWQsIHVwZGF0ZVBhcmFtcyk7XG4gICAgICAgIC8vIFNldCBiYWNrZ3JvdW5kXG4gICAgICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBlY01vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJykgfHwgJ3RyYW5zcGFyZW50JztcbiAgICAgICAgdmFyIGRhcmtNb2RlID0gZWNNb2RlbC5nZXQoJ2RhcmtNb2RlJyk7XG4gICAgICAgIHpyLnNldEJhY2tncm91bmRDb2xvcihiYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAvLyBGb3JjZSBzZXQgZGFyayBtb2RlLlxuICAgICAgICBpZiAoZGFya01vZGUgIT0gbnVsbCAmJiBkYXJrTW9kZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgenIuc2V0RGFya01vZGUoZGFya01vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGxpZmVjeWNsZS50cmlnZ2VyKCdhZnRlcnVwZGF0ZScsIGVjTW9kZWwsIGFwaSk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgICAgICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuICAgICAgICAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuICAgICAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWNNb2RlbC5zZXRVcGRhdGVQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICAvLyBDaGFydFZpZXcubWFya1VwZGF0ZU1ldGhvZChwYXlsb2FkLCAndXBkYXRlVHJhbnNmb3JtJyk7XG4gICAgICAgIHZhciBjb21wb25lbnREaXJ0eUxpc3QgPSBbXTtcbiAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBjb21wb25lbnRNb2RlbCkge1xuICAgICAgICAgIGlmIChjb21wb25lbnRUeXBlID09PSAnc2VyaWVzJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY29tcG9uZW50VmlldyA9IF90aGlzLmdldFZpZXdPZkNvbXBvbmVudE1vZGVsKGNvbXBvbmVudE1vZGVsKTtcbiAgICAgICAgICBpZiAoY29tcG9uZW50VmlldyAmJiBjb21wb25lbnRWaWV3Ll9fYWxpdmUpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRWaWV3LnVwZGF0ZVRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29tcG9uZW50Vmlldy51cGRhdGVUcmFuc2Zvcm0oY29tcG9uZW50TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgIHJlc3VsdCAmJiByZXN1bHQudXBkYXRlICYmIGNvbXBvbmVudERpcnR5TGlzdC5wdXNoKGNvbXBvbmVudFZpZXcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50RGlydHlMaXN0LnB1c2goY29tcG9uZW50Vmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNlcmllc0RpcnR5TWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgdmFyIGNoYXJ0VmlldyA9IF90aGlzLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuICAgICAgICAgIGlmIChjaGFydFZpZXcudXBkYXRlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2hhcnRWaWV3LnVwZGF0ZVRyYW5zZm9ybShzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIHJlc3VsdCAmJiByZXN1bHQudXBkYXRlICYmIHNlcmllc0RpcnR5TWFwLnNldChzZXJpZXNNb2RlbC51aWQsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXJpZXNEaXJ0eU1hcC5zZXQoc2VyaWVzTW9kZWwudWlkLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhckNvbG9yUGFsZXR0ZShlY01vZGVsKTtcbiAgICAgICAgLy8gS2VlcCBwaXBlIHRvIHRoZSBleGlzdCBwaXBlbGluZSBiZWNhdXNlIGl0IGRlcGVuZHMgb24gdGhlIHJlbmRlciB0YXNrIG9mIHRoZSBmdWxsIHBpcGVsaW5lLlxuICAgICAgICAvLyB0aGlzLl9zY2hlZHVsZXIucGVyZm9ybVZpc3VhbFRhc2tzKGVjTW9kZWwsIHBheWxvYWQsICdsYXlvdXQnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVyLnBlcmZvcm1WaXN1YWxUYXNrcyhlY01vZGVsLCBwYXlsb2FkLCB7XG4gICAgICAgICAgc2V0RGlydHk6IHRydWUsXG4gICAgICAgICAgZGlydHlNYXA6IHNlcmllc0RpcnR5TWFwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDdXJyZW50bHksIG5vdCBjYWxsIHJlbmRlciBvZiBjb21wb25lbnRzLiBHZW8gcmVuZGVyIGNvc3QgYSBsb3QuXG4gICAgICAgIC8vIHJlbmRlckNvbXBvbmVudHMoZWNJbnMsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCwgY29tcG9uZW50RGlydHlMaXN0KTtcbiAgICAgICAgcmVuZGVyU2VyaWVzKHRoaXMsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCwge30sIHNlcmllc0RpcnR5TWFwKTtcbiAgICAgICAgbGlmZWN5Y2xlLnRyaWdnZXIoJ2FmdGVydXBkYXRlJywgZWNNb2RlbCwgYXBpKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVWaWV3OiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgICAgICAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuICAgICAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWNNb2RlbC5zZXRVcGRhdGVQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICBDaGFydFZpZXcubWFya1VwZGF0ZU1ldGhvZChwYXlsb2FkLCAndXBkYXRlVmlldycpO1xuICAgICAgICBjbGVhckNvbG9yUGFsZXR0ZShlY01vZGVsKTtcbiAgICAgICAgLy8gS2VlcCBwaXBlIHRvIHRoZSBleGlzdCBwaXBlbGluZSBiZWNhdXNlIGl0IGRlcGVuZHMgb24gdGhlIHJlbmRlciB0YXNrIG9mIHRoZSBmdWxsIHBpcGVsaW5lLlxuICAgICAgICB0aGlzLl9zY2hlZHVsZXIucGVyZm9ybVZpc3VhbFRhc2tzKGVjTW9kZWwsIHBheWxvYWQsIHtcbiAgICAgICAgICBzZXREaXJ0eTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmVuZGVyKHRoaXMsIGVjTW9kZWwsIHRoaXMuX2FwaSwgcGF5bG9hZCwge30pO1xuICAgICAgICBsaWZlY3ljbGUudHJpZ2dlcignYWZ0ZXJ1cGRhdGUnLCBlY01vZGVsLCB0aGlzLl9hcGkpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZVZpc3VhbDogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgLy8gdXBkYXRlTWV0aG9kcy51cGRhdGUuY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgICAgICAgLy8gdXBkYXRlIGJlZm9yZSBzZXRPcHRpb25cbiAgICAgICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVjTW9kZWwuc2V0VXBkYXRlUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgICAgLy8gY2xlYXIgYWxsIHZpc3VhbFxuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmNsZWFyQWxsVmlzdWFsKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBQZXJmb3JtIHZpc3VhbFxuICAgICAgICBDaGFydFZpZXcubWFya1VwZGF0ZU1ldGhvZChwYXlsb2FkLCAndXBkYXRlVmlzdWFsJyk7XG4gICAgICAgIGNsZWFyQ29sb3JQYWxldHRlKGVjTW9kZWwpO1xuICAgICAgICAvLyBLZWVwIHBpcGUgdG8gdGhlIGV4aXN0IHBpcGVsaW5lIGJlY2F1c2UgaXQgZGVwZW5kcyBvbiB0aGUgcmVuZGVyIHRhc2sgb2YgdGhlIGZ1bGwgcGlwZWxpbmUuXG4gICAgICAgIHRoaXMuX3NjaGVkdWxlci5wZXJmb3JtVmlzdWFsVGFza3MoZWNNb2RlbCwgcGF5bG9hZCwge1xuICAgICAgICAgIHZpc3VhbFR5cGU6ICd2aXN1YWwnLFxuICAgICAgICAgIHNldERpcnR5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIGNvbXBvbmVudE1vZGVsKSB7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGUgIT09ICdzZXJpZXMnKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50VmlldyA9IF90aGlzLmdldFZpZXdPZkNvbXBvbmVudE1vZGVsKGNvbXBvbmVudE1vZGVsKTtcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXcgJiYgY29tcG9uZW50Vmlldy5fX2FsaXZlICYmIGNvbXBvbmVudFZpZXcudXBkYXRlVmlzdWFsKGNvbXBvbmVudE1vZGVsLCBlY01vZGVsLCBfdGhpcy5fYXBpLCBwYXlsb2FkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgdmFyIGNoYXJ0VmlldyA9IF90aGlzLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuICAgICAgICAgIGNoYXJ0Vmlldy51cGRhdGVWaXN1YWwoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIF90aGlzLl9hcGksIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGlmZWN5Y2xlLnRyaWdnZXIoJ2FmdGVydXBkYXRlJywgZWNNb2RlbCwgdGhpcy5fYXBpKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHVwZGF0ZU1ldGhvZHMudXBkYXRlLmNhbGwodGhpcywgcGF5bG9hZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBkb0NvbnZlcnRQaXhlbCA9IGZ1bmN0aW9uIChlY0lucywgbWV0aG9kTmFtZSwgZmluZGVyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVjSW5zLl9kaXNwb3NlZCkge1xuICAgICAgICBkaXNwb3NlZFdhcm5pbmcoZWNJbnMuaWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZWNNb2RlbCA9IGVjSW5zLl9tb2RlbDtcbiAgICAgIHZhciBjb29yZFN5c0xpc3QgPSBlY0lucy5fY29vcmRTeXNNZ3IuZ2V0Q29vcmRpbmF0ZVN5c3RlbXMoKTtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICB2YXIgcGFyc2VkRmluZGVyID0gbW9kZWxVdGlsLnBhcnNlRmluZGVyKGVjTW9kZWwsIGZpbmRlcik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkU3lzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29vcmRTeXMgPSBjb29yZFN5c0xpc3RbaV07XG4gICAgICAgIGlmIChjb29yZFN5c1ttZXRob2ROYW1lXSAmJiAocmVzdWx0ID0gY29vcmRTeXNbbWV0aG9kTmFtZV0oZWNNb2RlbCwgcGFyc2VkRmluZGVyLCB2YWx1ZSkpICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdObyBjb29yZGluYXRlIHN5c3RlbSB0aGF0IHN1cHBvcnRzICcgKyBtZXRob2ROYW1lICsgJyBmb3VuZCBieSB0aGUgZ2l2ZW4gZmluZGVyLicpO1xuICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlU3RyZWFtTW9kZXMgPSBmdW5jdGlvbiAoZWNJbnMsIGVjTW9kZWwpIHtcbiAgICAgIHZhciBjaGFydHNNYXAgPSBlY0lucy5fY2hhcnRzTWFwO1xuICAgICAgdmFyIHNjaGVkdWxlciA9IGVjSW5zLl9zY2hlZHVsZXI7XG4gICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgIHNjaGVkdWxlci51cGRhdGVTdHJlYW1Nb2RlcyhzZXJpZXNNb2RlbCwgY2hhcnRzTWFwW3Nlcmllc01vZGVsLl9fdmlld0lkXSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGRvRGlzcGF0Y2hBY3Rpb24gPSBmdW5jdGlvbiAocGF5bG9hZCwgc2lsZW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLmdldE1vZGVsKCk7XG4gICAgICB2YXIgcGF5bG9hZFR5cGUgPSBwYXlsb2FkLnR5cGU7XG4gICAgICB2YXIgZXNjYXBlQ29ubmVjdCA9IHBheWxvYWQuZXNjYXBlQ29ubmVjdDtcbiAgICAgIHZhciBhY3Rpb25XcmFwID0gYWN0aW9uc1twYXlsb2FkVHlwZV07XG4gICAgICB2YXIgYWN0aW9uSW5mbyA9IGFjdGlvbldyYXAuYWN0aW9uSW5mbztcbiAgICAgIHZhciBjcHRUeXBlVG1wID0gKGFjdGlvbkluZm8udXBkYXRlIHx8ICd1cGRhdGUnKS5zcGxpdCgnOicpO1xuICAgICAgdmFyIHVwZGF0ZU1ldGhvZCA9IGNwdFR5cGVUbXAucG9wKCk7XG4gICAgICB2YXIgY3B0VHlwZSA9IGNwdFR5cGVUbXBbMF0gIT0gbnVsbCAmJiBwYXJzZUNsYXNzVHlwZShjcHRUeXBlVG1wWzBdKTtcbiAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTX0tFWV0gPSB0cnVlO1xuICAgICAgdmFyIHBheWxvYWRzID0gW3BheWxvYWRdO1xuICAgICAgdmFyIGJhdGNoZWQgPSBmYWxzZTtcbiAgICAgIC8vIEJhdGNoIGFjdGlvblxuICAgICAgaWYgKHBheWxvYWQuYmF0Y2gpIHtcbiAgICAgICAgYmF0Y2hlZCA9IHRydWU7XG4gICAgICAgIHBheWxvYWRzID0gbWFwKHBheWxvYWQuYmF0Y2gsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaXRlbSA9IGRlZmF1bHRzKGV4dGVuZCh7fSwgaXRlbSksIHBheWxvYWQpO1xuICAgICAgICAgIGl0ZW0uYmF0Y2ggPSBudWxsO1xuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBldmVudE9iakJhdGNoID0gW107XG4gICAgICB2YXIgZXZlbnRPYmo7XG4gICAgICB2YXIgaXNTZWxlY3RDaGFuZ2UgPSBpc1NlbGVjdENoYW5nZVBheWxvYWQocGF5bG9hZCk7XG4gICAgICB2YXIgaXNIaWdoRG93biA9IGlzSGlnaERvd25QYXlsb2FkKHBheWxvYWQpO1xuICAgICAgLy8gT25seSBsZWF2ZSBibHVyIG9uY2UgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGJhdGNoZXMuXG4gICAgICBpZiAoaXNIaWdoRG93bikge1xuICAgICAgICBhbGxMZWF2ZUJsdXIodGhpcy5fYXBpKTtcbiAgICAgIH1cbiAgICAgIGVhY2gocGF5bG9hZHMsIGZ1bmN0aW9uIChiYXRjaEl0ZW0pIHtcbiAgICAgICAgLy8gQWN0aW9uIGNhbiBzcGVjaWZ5IHRoZSBldmVudCBieSByZXR1cm4gaXQuXG4gICAgICAgIGV2ZW50T2JqID0gYWN0aW9uV3JhcC5hY3Rpb24oYmF0Y2hJdGVtLCBfdGhpcy5fbW9kZWwsIF90aGlzLl9hcGkpO1xuICAgICAgICAvLyBFbWl0IGV2ZW50IG91dHNpZGVcbiAgICAgICAgZXZlbnRPYmogPSBldmVudE9iaiB8fCBleHRlbmQoe30sIGJhdGNoSXRlbSk7XG4gICAgICAgIC8vIENvbnZlcnQgdHlwZSB0byBldmVudFR5cGVcbiAgICAgICAgZXZlbnRPYmoudHlwZSA9IGFjdGlvbkluZm8uZXZlbnQgfHwgZXZlbnRPYmoudHlwZTtcbiAgICAgICAgZXZlbnRPYmpCYXRjaC5wdXNoKGV2ZW50T2JqKTtcbiAgICAgICAgLy8gbGlnaHQgdXBkYXRlIGRvZXMgbm90IHBlcmZvcm0gZGF0YSBwcm9jZXNzLCBsYXlvdXQgYW5kIHZpc3VhbC5cbiAgICAgICAgaWYgKGlzSGlnaERvd24pIHtcbiAgICAgICAgICB2YXIgX2EgPSBtb2RlbFV0aWwucHJlUGFyc2VGaW5kZXIocGF5bG9hZCksXG4gICAgICAgICAgICBxdWVyeU9wdGlvbk1hcCA9IF9hLnF1ZXJ5T3B0aW9uTWFwLFxuICAgICAgICAgICAgbWFpblR5cGVTcGVjaWZpZWQgPSBfYS5tYWluVHlwZVNwZWNpZmllZDtcbiAgICAgICAgICB2YXIgY29tcG9uZW50TWFpblR5cGUgPSBtYWluVHlwZVNwZWNpZmllZCA/IHF1ZXJ5T3B0aW9uTWFwLmtleXMoKVswXSA6ICdzZXJpZXMnO1xuICAgICAgICAgIHVwZGF0ZURpcmVjdGx5KF90aGlzLCB1cGRhdGVNZXRob2QsIGJhdGNoSXRlbSwgY29tcG9uZW50TWFpblR5cGUpO1xuICAgICAgICAgIG1hcmtTdGF0dXNUb1VwZGF0ZShfdGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTZWxlY3RDaGFuZ2UpIHtcbiAgICAgICAgICAvLyBBdCBwcmVzZW50IGBkaXNwYXRjaEFjdGlvbih7IHR5cGU6ICdzZWxlY3QnLCAuLi4gfSlgIGlzIG5vdCBzdXBwb3J0ZWQgb24gY29tcG9uZW50cy5cbiAgICAgICAgICAvLyBnZW8gc3RpbGwgdXNlICdnZW9zZWxlY3QnLlxuICAgICAgICAgIHVwZGF0ZURpcmVjdGx5KF90aGlzLCB1cGRhdGVNZXRob2QsIGJhdGNoSXRlbSwgJ3NlcmllcycpO1xuICAgICAgICAgIG1hcmtTdGF0dXNUb1VwZGF0ZShfdGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3B0VHlwZSkge1xuICAgICAgICAgIHVwZGF0ZURpcmVjdGx5KF90aGlzLCB1cGRhdGVNZXRob2QsIGJhdGNoSXRlbSwgY3B0VHlwZS5tYWluLCBjcHRUeXBlLnN1Yik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHVwZGF0ZU1ldGhvZCAhPT0gJ25vbmUnICYmICFpc0hpZ2hEb3duICYmICFpc1NlbGVjdENoYW5nZSAmJiAhY3B0VHlwZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFN0aWxsIGRpcnR5XG4gICAgICAgICAgaWYgKHRoaXNbUEVORElOR19VUERBVEVdKSB7XG4gICAgICAgICAgICBwcmVwYXJlKHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlTWV0aG9kcy51cGRhdGUuY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIHRoaXNbUEVORElOR19VUERBVEVdID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlTWV0aG9kc1t1cGRhdGVNZXRob2RdLmNhbGwodGhpcywgcGF5bG9hZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NfS0VZXSA9IGZhbHNlO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZvbGxvdyB0aGUgcnVsZSBvZiBhY3Rpb24gYmF0Y2hcbiAgICAgIGlmIChiYXRjaGVkKSB7XG4gICAgICAgIGV2ZW50T2JqID0ge1xuICAgICAgICAgIHR5cGU6IGFjdGlvbkluZm8uZXZlbnQgfHwgcGF5bG9hZFR5cGUsXG4gICAgICAgICAgZXNjYXBlQ29ubmVjdDogZXNjYXBlQ29ubmVjdCxcbiAgICAgICAgICBiYXRjaDogZXZlbnRPYmpCYXRjaFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnRPYmogPSBldmVudE9iakJhdGNoWzBdO1xuICAgICAgfVxuICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NfS0VZXSA9IGZhbHNlO1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VDZW50ZXIgPSB0aGlzLl9tZXNzYWdlQ2VudGVyO1xuICAgICAgICBtZXNzYWdlQ2VudGVyLnRyaWdnZXIoZXZlbnRPYmoudHlwZSwgZXZlbnRPYmopO1xuICAgICAgICAvLyBFeHRyYSB0cmlnZ2VyZWQgJ3NlbGVjdGNoYW5nZWQnIGV2ZW50XG4gICAgICAgIGlmIChpc1NlbGVjdENoYW5nZSkge1xuICAgICAgICAgIHZhciBuZXdPYmogPSB7XG4gICAgICAgICAgICB0eXBlOiAnc2VsZWN0Y2hhbmdlZCcsXG4gICAgICAgICAgICBlc2NhcGVDb25uZWN0OiBlc2NhcGVDb25uZWN0LFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IGdldEFsbFNlbGVjdGVkSW5kaWNlcyhlY01vZGVsKSxcbiAgICAgICAgICAgIGlzRnJvbUNsaWNrOiBwYXlsb2FkLmlzRnJvbUNsaWNrIHx8IGZhbHNlLFxuICAgICAgICAgICAgZnJvbUFjdGlvbjogcGF5bG9hZC50eXBlLFxuICAgICAgICAgICAgZnJvbUFjdGlvblBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1lc3NhZ2VDZW50ZXIudHJpZ2dlcihuZXdPYmoudHlwZSwgbmV3T2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZmx1c2hQZW5kaW5nQWN0aW9ucyA9IGZ1bmN0aW9uIChzaWxlbnQpIHtcbiAgICAgIHZhciBwZW5kaW5nQWN0aW9ucyA9IHRoaXMuX3BlbmRpbmdBY3Rpb25zO1xuICAgICAgd2hpbGUgKHBlbmRpbmdBY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IHBlbmRpbmdBY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgIGRvRGlzcGF0Y2hBY3Rpb24uY2FsbCh0aGlzLCBwYXlsb2FkLCBzaWxlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdHJpZ2dlclVwZGF0ZWRFdmVudCA9IGZ1bmN0aW9uIChzaWxlbnQpIHtcbiAgICAgICFzaWxlbnQgJiYgdGhpcy50cmlnZ2VyKCd1cGRhdGVkJyk7XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIEV2ZW50IGByZW5kZXJlZGAgaXMgdHJpZ2dlcmVkIHdoZW4genJcclxuICAgICAqIHJlbmRlcmVkLiBJdCBpcyB1c2VmdWwgZm9yIHJlYWx0aW1lXHJcbiAgICAgKiBzbmFwc2hvdCAocmVmbGVjdCBhbmltYXRpb24pLlxyXG4gICAgICpcclxuICAgICAqIEV2ZW50IGBmaW5pc2hlZGAgaXMgdHJpZ2dlcmVkIHdoZW46XHJcbiAgICAgKiAoMSkgenJlbmRlciByZW5kZXJpbmcgZmluaXNoZWQuXHJcbiAgICAgKiAoMikgaW5pdGlhbCBhbmltYXRpb24gZmluaXNoZWQuXHJcbiAgICAgKiAoMykgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGZpbmlzaGVkLlxyXG4gICAgICogKDQpIG5vIHBlbmRpbmcgYWN0aW9uLlxyXG4gICAgICogKDUpIG5vIGRlbGF5ZWQgc2V0T3B0aW9uIG5lZWRzIHRvIGJlIHByb2Nlc3NlZC5cclxuICAgICAqL1xuICAgIGJpbmRSZW5kZXJlZEV2ZW50ID0gZnVuY3Rpb24gKHpyLCBlY0lucykge1xuICAgICAgenIub24oJ3JlbmRlcmVkJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBlY0lucy50cmlnZ2VyKCdyZW5kZXJlZCcsIHBhcmFtcyk7XG4gICAgICAgIC8vIFRoZSBgZmluaXNoZWRgIGV2ZW50IHNob3VsZCBub3QgYmUgdHJpZ2dlcmVkIHJlcGVhdGVkbHksXG4gICAgICAgIC8vIHNvIGl0IHNob3VsZCBvbmx5IGJlIHRyaWdnZXJlZCB3aGVuIHJlbmRlcmluZyBpbmRlZWQgaGFwcGVuc1xuICAgICAgICAvLyBpbiB6cmVuZGVyLiAoQ29uc2lkZXIgdGhlIGNhc2UgdGhhdCBkaXBhdGNoQWN0aW9uIGlzIGtlZXBcbiAgICAgICAgLy8gdHJpZ2dlcmluZyB3aGVuIG1vdXNlIG1vdmUpLlxuICAgICAgICBpZiAoXG4gICAgICAgIC8vIEFsdGhvdWdoIHpyIGlzIGRpcnR5IGlmIGluaXRpYWwgYW5pbWF0aW9uIGlzIG5vdCBmaW5pc2hlZFxuICAgICAgICAvLyBhbmQgdGhpcyBjaGVja2luZyBpcyBjYWxsZWQgb24gZnJhbWUsIHdlIGFsc28gY2hlY2tcbiAgICAgICAgLy8gYW5pbWF0aW9uIGZpbmlzaGVkIGZvciByb2J1c3RuZXNzLlxuICAgICAgICB6ci5hbmltYXRpb24uaXNGaW5pc2hlZCgpICYmICFlY0luc1tQRU5ESU5HX1VQREFURV0gJiYgIWVjSW5zLl9zY2hlZHVsZXIudW5maW5pc2hlZCAmJiAhZWNJbnMuX3BlbmRpbmdBY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgIGVjSW5zLnRyaWdnZXIoJ2ZpbmlzaGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgYmluZE1vdXNlRXZlbnQgPSBmdW5jdGlvbiAoenIsIGVjSW5zKSB7XG4gICAgICB6ci5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciBkaXNwYXRjaGVyID0gZmluZEV2ZW50RGlzcGF0Y2hlcihlbCwgaXNIaWdoRG93bkRpc3BhdGNoZXIpO1xuICAgICAgICBpZiAoZGlzcGF0Y2hlcikge1xuICAgICAgICAgIGhhbmRsZUdsb2JhbE1vdXNlT3ZlckZvckhpZ2hEb3duKGRpc3BhdGNoZXIsIGUsIGVjSW5zLl9hcGkpO1xuICAgICAgICAgIG1hcmtTdGF0dXNUb1VwZGF0ZShlY0lucyk7XG4gICAgICAgIH1cbiAgICAgIH0pLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgZGlzcGF0Y2hlciA9IGZpbmRFdmVudERpc3BhdGNoZXIoZWwsIGlzSGlnaERvd25EaXNwYXRjaGVyKTtcbiAgICAgICAgaWYgKGRpc3BhdGNoZXIpIHtcbiAgICAgICAgICBoYW5kbGVHbG9iYWxNb3VzZU91dEZvckhpZ2hEb3duKGRpc3BhdGNoZXIsIGUsIGVjSW5zLl9hcGkpO1xuICAgICAgICAgIG1hcmtTdGF0dXNUb1VwZGF0ZShlY0lucyk7XG4gICAgICAgIH1cbiAgICAgIH0pLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgZGlzcGF0Y2hlciA9IGZpbmRFdmVudERpc3BhdGNoZXIoZWwsIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RUNEYXRhKHRhcmdldCkuZGF0YUluZGV4ICE9IG51bGw7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBpZiAoZGlzcGF0Y2hlcikge1xuICAgICAgICAgIHZhciBhY3Rpb25UeXBlID0gZGlzcGF0Y2hlci5zZWxlY3RlZCA/ICd1bnNlbGVjdCcgOiAnc2VsZWN0JztcbiAgICAgICAgICB2YXIgZWNEYXRhID0gZ2V0RUNEYXRhKGRpc3BhdGNoZXIpO1xuICAgICAgICAgIGVjSW5zLl9hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgdHlwZTogYWN0aW9uVHlwZSxcbiAgICAgICAgICAgIGRhdGFUeXBlOiBlY0RhdGEuZGF0YVR5cGUsXG4gICAgICAgICAgICBkYXRhSW5kZXhJbnNpZGU6IGVjRGF0YS5kYXRhSW5kZXgsXG4gICAgICAgICAgICBzZXJpZXNJbmRleDogZWNEYXRhLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgaXNGcm9tQ2xpY2s6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjbGVhckNvbG9yUGFsZXR0ZShlY01vZGVsKSB7XG4gICAgICBlY01vZGVsLmNsZWFyQ29sb3JQYWxldHRlKCk7XG4gICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgIHNlcmllc01vZGVsLmNsZWFyQ29sb3JQYWxldHRlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgO1xuICAgIC8vIEFsbG9jYXRlIHpsZXZlbHMgZm9yIHNlcmllcyBhbmQgY29tcG9uZW50c1xuICAgIGZ1bmN0aW9uIGFsbG9jYXRlWmxldmVscyhlY01vZGVsKSB7XG4gICAgICA7XG4gICAgICB2YXIgY29tcG9uZW50WkxldmVscyA9IFtdO1xuICAgICAgdmFyIHNlcmllc1pMZXZlbHMgPSBbXTtcbiAgICAgIHZhciBoYXNTZXBhcmF0ZVpMZXZlbCA9IGZhbHNlO1xuICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBjb21wb25lbnRNb2RlbCkge1xuICAgICAgICB2YXIgemxldmVsID0gY29tcG9uZW50TW9kZWwuZ2V0KCd6bGV2ZWwnKSB8fCAwO1xuICAgICAgICB2YXIgeiA9IGNvbXBvbmVudE1vZGVsLmdldCgneicpIHx8IDA7XG4gICAgICAgIHZhciB6bGV2ZWxLZXkgPSBjb21wb25lbnRNb2RlbC5nZXRaTGV2ZWxLZXkoKTtcbiAgICAgICAgaGFzU2VwYXJhdGVaTGV2ZWwgPSBoYXNTZXBhcmF0ZVpMZXZlbCB8fCAhIXpsZXZlbEtleTtcbiAgICAgICAgKGNvbXBvbmVudFR5cGUgPT09ICdzZXJpZXMnID8gc2VyaWVzWkxldmVscyA6IGNvbXBvbmVudFpMZXZlbHMpLnB1c2goe1xuICAgICAgICAgIHpsZXZlbDogemxldmVsLFxuICAgICAgICAgIHo6IHosXG4gICAgICAgICAgaWR4OiBjb21wb25lbnRNb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgICAgICB0eXBlOiBjb21wb25lbnRUeXBlLFxuICAgICAgICAgIGtleTogemxldmVsS2V5XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzU2VwYXJhdGVaTGV2ZWwpIHtcbiAgICAgICAgLy8gU2VyaWVzIGFmdGVyIGNvbXBvbmVudFxuICAgICAgICB2YXIgekxldmVscyA9IGNvbXBvbmVudFpMZXZlbHMuY29uY2F0KHNlcmllc1pMZXZlbHMpO1xuICAgICAgICB2YXIgbGFzdFNlcmllc1pMZXZlbF8xO1xuICAgICAgICB2YXIgbGFzdFNlcmllc0tleV8xO1xuICAgICAgICB0aW1zb3J0KHpMZXZlbHMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgaWYgKGEuemxldmVsID09PSBiLnpsZXZlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGEueiAtIGIuejtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGEuemxldmVsIC0gYi56bGV2ZWw7XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoKHpMZXZlbHMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudE1vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoaXRlbS50eXBlLCBpdGVtLmlkeCk7XG4gICAgICAgICAgdmFyIHpsZXZlbCA9IGl0ZW0uemxldmVsO1xuICAgICAgICAgIHZhciBrZXkgPSBpdGVtLmtleTtcbiAgICAgICAgICBpZiAobGFzdFNlcmllc1pMZXZlbF8xICE9IG51bGwpIHtcbiAgICAgICAgICAgIHpsZXZlbCA9IE1hdGgubWF4KGxhc3RTZXJpZXNaTGV2ZWxfMSwgemxldmVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKHpsZXZlbCA9PT0gbGFzdFNlcmllc1pMZXZlbF8xICYmIGtleSAhPT0gbGFzdFNlcmllc0tleV8xKSB7XG4gICAgICAgICAgICAgIHpsZXZlbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFNlcmllc0tleV8xID0ga2V5O1xuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdFNlcmllc0tleV8xKSB7XG4gICAgICAgICAgICBpZiAoemxldmVsID09PSBsYXN0U2VyaWVzWkxldmVsXzEpIHtcbiAgICAgICAgICAgICAgemxldmVsKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0U2VyaWVzS2V5XzEgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdFNlcmllc1pMZXZlbF8xID0gemxldmVsO1xuICAgICAgICAgIGNvbXBvbmVudE1vZGVsLnNldFpMZXZlbCh6bGV2ZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyID0gZnVuY3Rpb24gKGVjSW5zLCBlY01vZGVsLCBhcGksIHBheWxvYWQsIHVwZGF0ZVBhcmFtcykge1xuICAgICAgYWxsb2NhdGVabGV2ZWxzKGVjTW9kZWwpO1xuICAgICAgcmVuZGVyQ29tcG9uZW50cyhlY0lucywgZWNNb2RlbCwgYXBpLCBwYXlsb2FkLCB1cGRhdGVQYXJhbXMpO1xuICAgICAgZWFjaChlY0lucy5fY2hhcnRzVmlld3MsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICBjaGFydC5fX2FsaXZlID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHJlbmRlclNlcmllcyhlY0lucywgZWNNb2RlbCwgYXBpLCBwYXlsb2FkLCB1cGRhdGVQYXJhbXMpO1xuICAgICAgLy8gUmVtb3ZlIGdyb3VwcyBvZiB1bnJlbmRlcmVkIGNoYXJ0c1xuICAgICAgZWFjaChlY0lucy5fY2hhcnRzVmlld3MsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICBpZiAoIWNoYXJ0Ll9fYWxpdmUpIHtcbiAgICAgICAgICBjaGFydC5yZW1vdmUoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZW5kZXJDb21wb25lbnRzID0gZnVuY3Rpb24gKGVjSW5zLCBlY01vZGVsLCBhcGksIHBheWxvYWQsIHVwZGF0ZVBhcmFtcywgZGlydHlMaXN0KSB7XG4gICAgICBlYWNoKGRpcnR5TGlzdCB8fCBlY0lucy5fY29tcG9uZW50c1ZpZXdzLCBmdW5jdGlvbiAoY29tcG9uZW50Vmlldykge1xuICAgICAgICB2YXIgY29tcG9uZW50TW9kZWwgPSBjb21wb25lbnRWaWV3Ll9fbW9kZWw7XG4gICAgICAgIGNsZWFyU3RhdGVzKGNvbXBvbmVudE1vZGVsLCBjb21wb25lbnRWaWV3KTtcbiAgICAgICAgY29tcG9uZW50Vmlldy5yZW5kZXIoY29tcG9uZW50TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgICAgIHVwZGF0ZVooY29tcG9uZW50TW9kZWwsIGNvbXBvbmVudFZpZXcpO1xuICAgICAgICB1cGRhdGVTdGF0ZXMoY29tcG9uZW50TW9kZWwsIGNvbXBvbmVudFZpZXcpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIFJlbmRlciBlYWNoIGNoYXJ0IGFuZCBjb21wb25lbnRcclxuICAgICAqL1xuICAgIHJlbmRlclNlcmllcyA9IGZ1bmN0aW9uIChlY0lucywgZWNNb2RlbCwgYXBpLCBwYXlsb2FkLCB1cGRhdGVQYXJhbXMsIGRpcnR5TWFwKSB7XG4gICAgICAvLyBSZW5kZXIgYWxsIGNoYXJ0c1xuICAgICAgdmFyIHNjaGVkdWxlciA9IGVjSW5zLl9zY2hlZHVsZXI7XG4gICAgICB1cGRhdGVQYXJhbXMgPSBleHRlbmQodXBkYXRlUGFyYW1zIHx8IHt9LCB7XG4gICAgICAgIHVwZGF0ZWRTZXJpZXM6IGVjTW9kZWwuZ2V0U2VyaWVzKClcbiAgICAgIH0pO1xuICAgICAgLy8gVE9ETyBwcm9ncmVzc2l2ZT9cbiAgICAgIGxpZmVjeWNsZS50cmlnZ2VyKCdzZXJpZXM6YmVmb3JldXBkYXRlJywgZWNNb2RlbCwgYXBpLCB1cGRhdGVQYXJhbXMpO1xuICAgICAgdmFyIHVuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgdmFyIGNoYXJ0VmlldyA9IGVjSW5zLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuICAgICAgICBjaGFydFZpZXcuX19hbGl2ZSA9IHRydWU7XG4gICAgICAgIHZhciByZW5kZXJUYXNrID0gY2hhcnRWaWV3LnJlbmRlclRhc2s7XG4gICAgICAgIHNjaGVkdWxlci51cGRhdGVQYXlsb2FkKHJlbmRlclRhc2ssIHBheWxvYWQpO1xuICAgICAgICAvLyBUT0RPIHN0YXRlcyBvbiBtYXJrZXIuXG4gICAgICAgIGNsZWFyU3RhdGVzKHNlcmllc01vZGVsLCBjaGFydFZpZXcpO1xuICAgICAgICBpZiAoZGlydHlNYXAgJiYgZGlydHlNYXAuZ2V0KHNlcmllc01vZGVsLnVpZCkpIHtcbiAgICAgICAgICByZW5kZXJUYXNrLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbmRlclRhc2sucGVyZm9ybShzY2hlZHVsZXIuZ2V0UGVyZm9ybUFyZ3MocmVuZGVyVGFzaykpKSB7XG4gICAgICAgICAgdW5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hhcnRWaWV3Lmdyb3VwLnNpbGVudCA9ICEhc2VyaWVzTW9kZWwuZ2V0KCdzaWxlbnQnKTtcbiAgICAgICAgLy8gU2hvdWxkIG5vdCBjYWxsIG1hcmtSZWRyYXcgb24gZ3JvdXAsIGJlY2F1c2UgaXQgd2lsbCBkaXNhYmxlIHpyZW5kZXJcbiAgICAgICAgLy8gaW5jcmVtZW50YWwgcmVuZGVyIChhbHdheXMgcmVuZGVyIGZyb20gdGhlIF9fc3RhcnRJbmRleCBlYWNoIGZyYW1lKVxuICAgICAgICAvLyBjaGFydFZpZXcuZ3JvdXAubWFya1JlZHJhdygpO1xuICAgICAgICB1cGRhdGVCbGVuZChzZXJpZXNNb2RlbCwgY2hhcnRWaWV3KTtcbiAgICAgICAgdXBkYXRlU2VyaWVzRWxlbWVudFNlbGVjdGlvbihzZXJpZXNNb2RlbCk7XG4gICAgICB9KTtcbiAgICAgIHNjaGVkdWxlci51bmZpbmlzaGVkID0gdW5maW5pc2hlZCB8fCBzY2hlZHVsZXIudW5maW5pc2hlZDtcbiAgICAgIGxpZmVjeWNsZS50cmlnZ2VyKCdzZXJpZXM6bGF5b3V0bGFiZWxzJywgZWNNb2RlbCwgYXBpLCB1cGRhdGVQYXJhbXMpO1xuICAgICAgLy8gdHJhbnNpdGlvbiBhZnRlciBsYWJlbCBpcyBsYXlvdXRlZC5cbiAgICAgIGxpZmVjeWNsZS50cmlnZ2VyKCdzZXJpZXM6dHJhbnNpdGlvbicsIGVjTW9kZWwsIGFwaSwgdXBkYXRlUGFyYW1zKTtcbiAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgdmFyIGNoYXJ0VmlldyA9IGVjSW5zLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuICAgICAgICAvLyBVcGRhdGUgWiBhZnRlciBsYWJlbHMgdXBkYXRlZC4gQmVmb3JlIGFwcGx5aW5nIHN0YXRlcy5cbiAgICAgICAgdXBkYXRlWihzZXJpZXNNb2RlbCwgY2hhcnRWaWV3KTtcbiAgICAgICAgLy8gTk9URTogVXBkYXRlIHN0YXRlcyBhZnRlciBsYWJlbCBpcyB1cGRhdGVkLlxuICAgICAgICAvLyBsYWJlbCBzaG91bGQgYmUgaW4gbm9ybWFsIHN0YXR1cyB3aGVuIGxheW91dGluZy5cbiAgICAgICAgdXBkYXRlU3RhdGVzKHNlcmllc01vZGVsLCBjaGFydFZpZXcpO1xuICAgICAgfSk7XG4gICAgICAvLyBJZiB1c2UgaG92ZXIgbGF5ZXJcbiAgICAgIHVwZGF0ZUhvdmVyTGF5ZXJTdGF0dXMoZWNJbnMsIGVjTW9kZWwpO1xuICAgICAgbGlmZWN5Y2xlLnRyaWdnZXIoJ3NlcmllczphZnRlcnVwZGF0ZScsIGVjTW9kZWwsIGFwaSwgdXBkYXRlUGFyYW1zKTtcbiAgICB9O1xuICAgIG1hcmtTdGF0dXNUb1VwZGF0ZSA9IGZ1bmN0aW9uIChlY0lucykge1xuICAgICAgZWNJbnNbU1RBVFVTX05FRURTX1VQREFURV9LRVldID0gdHJ1ZTtcbiAgICAgIC8vIFdha2UgdXAgenJlbmRlciBpZiBpdCdzIHNsZWVwLiBMZXQgaXQgdXBkYXRlIHN0YXRlcyBpbiB0aGUgbmV4dCBmcmFtZS5cbiAgICAgIGVjSW5zLmdldFpyKCkud2FrZVVwKCk7XG4gICAgfTtcbiAgICBhcHBseUNoYW5nZWRTdGF0ZXMgPSBmdW5jdGlvbiAoZWNJbnMpIHtcbiAgICAgIGlmICghZWNJbnNbU1RBVFVTX05FRURTX1VQREFURV9LRVldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVjSW5zLmdldFpyKCkuc3RvcmFnZS50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgLy8gTm90IGFwcGxpZWQgb24gcmVtb3ZlZCBlbGVtZW50cywgaXQgbWF5IHN0aWxsIGluIGZhZGluZy5cbiAgICAgICAgaWYgKGdyYXBoaWMuaXNFbGVtZW50UmVtb3ZlZChlbCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXBwbHlFbGVtZW50U3RhdGVzKGVsKTtcbiAgICAgIH0pO1xuICAgICAgZWNJbnNbU1RBVFVTX05FRURTX1VQREFURV9LRVldID0gZmFsc2U7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBhcHBseUVsZW1lbnRTdGF0ZXMoZWwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZXMgPSBbXTtcbiAgICAgIHZhciBvbGRTdGF0ZXMgPSBlbC5jdXJyZW50U3RhdGVzO1xuICAgICAgLy8gS2VlcCBvdGhlciBzdGF0ZXMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZFN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3RhdGVOYW1lID0gb2xkU3RhdGVzW2ldO1xuICAgICAgICBpZiAoIShzdGF0ZU5hbWUgPT09ICdlbXBoYXNpcycgfHwgc3RhdGVOYW1lID09PSAnYmx1cicgfHwgc3RhdGVOYW1lID09PSAnc2VsZWN0JykpIHtcbiAgICAgICAgICBuZXdTdGF0ZXMucHVzaChzdGF0ZU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBPbmx5IHVzZSBzdGF0ZXMgd2hlbiBpdCdzIGV4aXN0cy5cbiAgICAgIGlmIChlbC5zZWxlY3RlZCAmJiBlbC5zdGF0ZXMuc2VsZWN0KSB7XG4gICAgICAgIG5ld1N0YXRlcy5wdXNoKCdzZWxlY3QnKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbC5ob3ZlclN0YXRlID09PSBIT1ZFUl9TVEFURV9FTVBIQVNJUyAmJiBlbC5zdGF0ZXMuZW1waGFzaXMpIHtcbiAgICAgICAgbmV3U3RhdGVzLnB1c2goJ2VtcGhhc2lzJyk7XG4gICAgICB9IGVsc2UgaWYgKGVsLmhvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX0JMVVIgJiYgZWwuc3RhdGVzLmJsdXIpIHtcbiAgICAgICAgbmV3U3RhdGVzLnB1c2goJ2JsdXInKTtcbiAgICAgIH1cbiAgICAgIGVsLnVzZVN0YXRlcyhuZXdTdGF0ZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVIb3ZlckxheWVyU3RhdHVzKGVjSW5zLCBlY01vZGVsKSB7XG4gICAgICB2YXIgenIgPSBlY0lucy5fenI7XG4gICAgICB2YXIgc3RvcmFnZSA9IHpyLnN0b3JhZ2U7XG4gICAgICB2YXIgZWxDb3VudCA9IDA7XG4gICAgICBzdG9yYWdlLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBpZiAoIWVsLmlzR3JvdXApIHtcbiAgICAgICAgICBlbENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGVsQ291bnQgPiBlY01vZGVsLmdldCgnaG92ZXJMYXllclRocmVzaG9sZCcpICYmICFlbnYubm9kZSAmJiAhZW52Lndvcmtlcikge1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgaWYgKHNlcmllc01vZGVsLnByZXZlbnRVc2luZ0hvdmVyTGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNoYXJ0VmlldyA9IGVjSW5zLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuICAgICAgICAgIGlmIChjaGFydFZpZXcuX19hbGl2ZSkge1xuICAgICAgICAgICAgY2hhcnRWaWV3LmVhY2hSZW5kZXJlZChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgaWYgKGVsLnN0YXRlcy5lbXBoYXNpcykge1xuICAgICAgICAgICAgICAgIGVsLnN0YXRlcy5lbXBoYXNpcy5ob3ZlckxheWVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGNoYXJ0IGFuZCBibGVuZC5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUJsZW5kKHNlcmllc01vZGVsLCBjaGFydFZpZXcpIHtcbiAgICAgIHZhciBibGVuZE1vZGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2JsZW5kTW9kZScpIHx8IG51bGw7XG4gICAgICBjaGFydFZpZXcuZWFjaFJlbmRlcmVkKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAvLyBGSVhNRSBtYXJrZXIgYW5kIG90aGVyIGNvbXBvbmVudHNcbiAgICAgICAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgICAgICAgLy8gRE9OJ1QgbWFyayB0aGUgZWxlbWVudCBkaXJ0eS4gSW4gY2FzZSBlbGVtZW50IGlzIGluY3JlbWVudGFsIGFuZCBkb24ndCB3YW50IHRvIHJlcmVuZGVyLlxuICAgICAgICAgIGVsLnN0eWxlLmJsZW5kID0gYmxlbmRNb2RlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVoobW9kZWwsIHZpZXcpIHtcbiAgICAgIGlmIChtb2RlbC5wcmV2ZW50QXV0b1opIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHogPSBtb2RlbC5nZXQoJ3onKSB8fCAwO1xuICAgICAgdmFyIHpsZXZlbCA9IG1vZGVsLmdldCgnemxldmVsJykgfHwgMDtcbiAgICAgIC8vIFNldCB6IGFuZCB6bGV2ZWxcbiAgICAgIHZpZXcuZWFjaFJlbmRlcmVkKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBkb1VwZGF0ZVooZWwsIHosIHpsZXZlbCwgLUluZmluaXR5KTtcbiAgICAgICAgLy8gRG9uJ3QgdHJhdmVyc2UgdGhlIGNoaWxkcmVuIGJlY2F1c2UgaXQgaGFzIGJlZW4gdHJhdmVyc2VkIGluIF91cGRhdGVaLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICA7XG4gICAgZnVuY3Rpb24gZG9VcGRhdGVaKGVsLCB6LCB6bGV2ZWwsIG1heFoyKSB7XG4gICAgICAvLyBHcm91cCBtYXkgYWxzbyBoYXZlIHRleHRDb250ZW50XG4gICAgICB2YXIgbGFiZWwgPSBlbC5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgdmFyIGxhYmVsTGluZSA9IGVsLmdldFRleHRHdWlkZUxpbmUoKTtcbiAgICAgIHZhciBpc0dyb3VwID0gZWwuaXNHcm91cDtcbiAgICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgIC8vIHNldCB6ICYgemxldmVsIG9mIGNoaWxkcmVuIGVsZW1lbnRzIG9mIEdyb3VwXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuUmVmKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtYXhaMiA9IE1hdGgubWF4KGRvVXBkYXRlWihjaGlsZHJlbltpXSwgeiwgemxldmVsLCBtYXhaMiksIG1heFoyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90IEdyb3VwXG4gICAgICAgIGVsLnogPSB6O1xuICAgICAgICBlbC56bGV2ZWwgPSB6bGV2ZWw7XG4gICAgICAgIG1heFoyID0gTWF0aC5tYXgoZWwuejIsIG1heFoyKTtcbiAgICAgIH1cbiAgICAgIC8vIGFsd2F5cyBzZXQgeiBhbmQgemxldmVsIGlmIGxhYmVsL2xhYmVsTGluZSBleGlzdHNcbiAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICBsYWJlbC56ID0gejtcbiAgICAgICAgbGFiZWwuemxldmVsID0gemxldmVsO1xuICAgICAgICAvLyBsaWZ0IHoyIG9mIHRleHQgY29udGVudFxuICAgICAgICAvLyBUT0RPIGlmIGVsLmVtcGhhc2lzLnoyIGlzIHNwY2VmaWVkLCB3aGF0IGFib3V0IHRleHRDb250ZW50LlxuICAgICAgICBpc0Zpbml0ZShtYXhaMikgJiYgKGxhYmVsLnoyID0gbWF4WjIgKyAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChsYWJlbExpbmUpIHtcbiAgICAgICAgdmFyIHRleHRHdWlkZUxpbmVDb25maWcgPSBlbC50ZXh0R3VpZGVMaW5lQ29uZmlnO1xuICAgICAgICBsYWJlbExpbmUueiA9IHo7XG4gICAgICAgIGxhYmVsTGluZS56bGV2ZWwgPSB6bGV2ZWw7XG4gICAgICAgIGlzRmluaXRlKG1heFoyKSAmJiAobGFiZWxMaW5lLnoyID0gbWF4WjIgKyAodGV4dEd1aWRlTGluZUNvbmZpZyAmJiB0ZXh0R3VpZGVMaW5lQ29uZmlnLnNob3dBYm92ZSA/IDEgOiAtMSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1heFoyO1xuICAgIH1cbiAgICAvLyBDbGVhciBzdGF0ZXMgd2l0aG91dCBhbmltYXRpb24uXG4gICAgLy8gVE9ETyBTdGF0ZXMgb24gY29tcG9uZW50LlxuICAgIGZ1bmN0aW9uIGNsZWFyU3RhdGVzKG1vZGVsLCB2aWV3KSB7XG4gICAgICB2aWV3LmVhY2hSZW5kZXJlZChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgLy8gTm90IGFwcGxpZWQgb24gcmVtb3ZlZCBlbGVtZW50cywgaXQgbWF5IHN0aWxsIGluIGZhZGluZy5cbiAgICAgICAgaWYgKGdyYXBoaWMuaXNFbGVtZW50UmVtb3ZlZChlbCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHRDb250ZW50ID0gZWwuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgdmFyIHRleHRHdWlkZSA9IGVsLmdldFRleHRHdWlkZUxpbmUoKTtcbiAgICAgICAgaWYgKGVsLnN0YXRlVHJhbnNpdGlvbikge1xuICAgICAgICAgIGVsLnN0YXRlVHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHRDb250ZW50ICYmIHRleHRDb250ZW50LnN0YXRlVHJhbnNpdGlvbikge1xuICAgICAgICAgIHRleHRDb250ZW50LnN0YXRlVHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHRHdWlkZSAmJiB0ZXh0R3VpZGUuc3RhdGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgdGV4dEd1aWRlLnN0YXRlVHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBJZiBlbCBpcyBpbmNyZW1lbnRhbC5cbiAgICAgICAgaWYgKGVsLmhhc1N0YXRlKCkpIHtcbiAgICAgICAgICBlbC5wcmV2U3RhdGVzID0gZWwuY3VycmVudFN0YXRlcztcbiAgICAgICAgICBlbC5jbGVhclN0YXRlcygpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsLnByZXZTdGF0ZXMpIHtcbiAgICAgICAgICBlbC5wcmV2U3RhdGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlcyhtb2RlbCwgdmlldykge1xuICAgICAgdmFyIHN0YXRlQW5pbWF0aW9uTW9kZWwgPSBtb2RlbC5nZXRNb2RlbCgnc3RhdGVBbmltYXRpb24nKTtcbiAgICAgIHZhciBlbmFibGVBbmltYXRpb24gPSBtb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKTtcbiAgICAgIHZhciBkdXJhdGlvbiA9IHN0YXRlQW5pbWF0aW9uTW9kZWwuZ2V0KCdkdXJhdGlvbicpO1xuICAgICAgdmFyIHN0YXRlVHJhbnNpdGlvbiA9IGR1cmF0aW9uID4gMCA/IHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBkZWxheTogc3RhdGVBbmltYXRpb25Nb2RlbC5nZXQoJ2RlbGF5JyksXG4gICAgICAgIGVhc2luZzogc3RhdGVBbmltYXRpb25Nb2RlbC5nZXQoJ2Vhc2luZycpXG4gICAgICAgIC8vIGFkZGl0aXZlOiBzdGF0ZUFuaW1hdGlvbk1vZGVsLmdldCgnYWRkaXRpdmUnKVxuICAgICAgfSA6IG51bGw7XG4gICAgICB2aWV3LmVhY2hSZW5kZXJlZChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsLnN0YXRlcyAmJiBlbC5zdGF0ZXMuZW1waGFzaXMpIHtcbiAgICAgICAgICAvLyBOb3QgYXBwbGllZCBvbiByZW1vdmVkIGVsZW1lbnRzLCBpdCBtYXkgc3RpbGwgaW4gZmFkaW5nLlxuICAgICAgICAgIGlmIChncmFwaGljLmlzRWxlbWVudFJlbW92ZWQoZWwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIGdyYXBoaWMuUGF0aCkge1xuICAgICAgICAgICAgc2F2ZVBhdGhTdGF0ZXMoZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPbmx5IHVwZGF0ZWQgb24gY2hhbmdlZCBlbGVtZW50LiBJbiBjYXNlIGVsZW1lbnQgaXMgaW5jcmVtZW50YWwgYW5kIGRvbid0IHdhbnQgdG8gcmVyZW5kZXIuXG4gICAgICAgICAgLy8gVE9ETywgYSBtb3JlIHByb3BlciB3YXk/XG4gICAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICAgIHZhciBwcmV2U3RhdGVzID0gZWwucHJldlN0YXRlcztcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgc3RhdGVzIHdpdGhvdXQgYW5pbWF0aW9uXG4gICAgICAgICAgICBpZiAocHJldlN0YXRlcykge1xuICAgICAgICAgICAgICBlbC51c2VTdGF0ZXMocHJldlN0YXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZSB0cmFuc2l0aW9uIGFuZCBlbmFibGUgYW5pbWF0aW9uIGFnYWluLlxuICAgICAgICAgIGlmIChlbmFibGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgIGVsLnN0YXRlVHJhbnNpdGlvbiA9IHN0YXRlVHJhbnNpdGlvbjtcbiAgICAgICAgICAgIHZhciB0ZXh0Q29udGVudCA9IGVsLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgICAgICB2YXIgdGV4dEd1aWRlID0gZWwuZ2V0VGV4dEd1aWRlTGluZSgpO1xuICAgICAgICAgICAgLy8gVE9ETyBJcyBpdCBuZWNlc3NhcnkgdG8gYW5pbWF0ZSBsYWJlbD9cbiAgICAgICAgICAgIGlmICh0ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICB0ZXh0Q29udGVudC5zdGF0ZVRyYW5zaXRpb24gPSBzdGF0ZVRyYW5zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGV4dEd1aWRlKSB7XG4gICAgICAgICAgICAgIHRleHRHdWlkZS5zdGF0ZVRyYW5zaXRpb24gPSBzdGF0ZVRyYW5zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVzZSBoaWdobGlnaHRlZCBhbmQgc2VsZWN0ZWQgZmxhZyB0byB0b2dnbGUgc3RhdGVzLlxuICAgICAgICAgIGlmIChlbC5fX2RpcnR5KSB7XG4gICAgICAgICAgICBhcHBseUVsZW1lbnRTdGF0ZXMoZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIDtcbiAgICBjcmVhdGVFeHRlbnNpb25BUEkgPSBmdW5jdGlvbiAoZWNJbnMpIHtcbiAgICAgIHJldHVybiBuZXcgKC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRDb29yZGluYXRlU3lzdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZWNJbnMuX2Nvb3JkU3lzTWdyLmdldENvb3JkaW5hdGVTeXN0ZW1zKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldENvbXBvbmVudEJ5RWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgdmFyIG1vZGVsSW5mbyA9IGVsLl9fZWNDb21wb25lbnRJbmZvO1xuICAgICAgICAgICAgaWYgKG1vZGVsSW5mbyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlY0lucy5fbW9kZWwuZ2V0Q29tcG9uZW50KG1vZGVsSW5mby5tYWluVHlwZSwgbW9kZWxJbmZvLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsID0gZWwucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZW50ZXJFbXBoYXNpcyA9IGZ1bmN0aW9uIChlbCwgaGlnaGxpZ2h0RGlnaXQpIHtcbiAgICAgICAgICBlbnRlckVtcGhhc2lzKGVsLCBoaWdobGlnaHREaWdpdCk7XG4gICAgICAgICAgbWFya1N0YXR1c1RvVXBkYXRlKGVjSW5zKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUubGVhdmVFbXBoYXNpcyA9IGZ1bmN0aW9uIChlbCwgaGlnaGxpZ2h0RGlnaXQpIHtcbiAgICAgICAgICBsZWF2ZUVtcGhhc2lzKGVsLCBoaWdobGlnaHREaWdpdCk7XG4gICAgICAgICAgbWFya1N0YXR1c1RvVXBkYXRlKGVjSW5zKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZW50ZXJCbHVyID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgZW50ZXJCbHVyKGVsKTtcbiAgICAgICAgICBtYXJrU3RhdHVzVG9VcGRhdGUoZWNJbnMpO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5sZWF2ZUJsdXIgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBsZWF2ZUJsdXIoZWwpO1xuICAgICAgICAgIG1hcmtTdGF0dXNUb1VwZGF0ZShlY0lucyk7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmVudGVyU2VsZWN0ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgZW50ZXJTZWxlY3QoZWwpO1xuICAgICAgICAgIG1hcmtTdGF0dXNUb1VwZGF0ZShlY0lucyk7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmxlYXZlU2VsZWN0ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgbGVhdmVTZWxlY3QoZWwpO1xuICAgICAgICAgIG1hcmtTdGF0dXNUb1VwZGF0ZShlY0lucyk7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldE1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBlY0lucy5nZXRNb2RlbCgpO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXRWaWV3T2ZDb21wb25lbnRNb2RlbCA9IGZ1bmN0aW9uIChjb21wb25lbnRNb2RlbCkge1xuICAgICAgICAgIHJldHVybiBlY0lucy5nZXRWaWV3T2ZDb21wb25lbnRNb2RlbChjb21wb25lbnRNb2RlbCk7XG4gICAgICAgIH07XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldFZpZXdPZlNlcmllc01vZGVsID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGVjSW5zLmdldFZpZXdPZlNlcmllc01vZGVsKHNlcmllc01vZGVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgICB9KEV4dGVuc2lvbkFQSSkpKGVjSW5zKTtcbiAgICB9O1xuICAgIGVuYWJsZUNvbm5lY3QgPSBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbm5lY3RlZENoYXJ0c1N0YXR1cyhjaGFydHMsIHN0YXR1cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBvdGhlckNoYXJ0ID0gY2hhcnRzW2ldO1xuICAgICAgICAgIG90aGVyQ2hhcnRbQ09OTkVDVF9TVEFUVVNfS0VZXSA9IHN0YXR1cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWFjaChldmVudEFjdGlvbk1hcCwgZnVuY3Rpb24gKGFjdGlvblR5cGUsIGV2ZW50VHlwZSkge1xuICAgICAgICBjaGFydC5fbWVzc2FnZUNlbnRlci5vbihldmVudFR5cGUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmIChjb25uZWN0ZWRHcm91cHNbY2hhcnQuZ3JvdXBdICYmIGNoYXJ0W0NPTk5FQ1RfU1RBVFVTX0tFWV0gIT09IENPTk5FQ1RfU1RBVFVTX1BFTkRJTkcpIHtcbiAgICAgICAgICAgIGlmIChldmVudCAmJiBldmVudC5lc2NhcGVDb25uZWN0KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhY3Rpb25fMSA9IGNoYXJ0Lm1ha2VBY3Rpb25Gcm9tRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgdmFyIG90aGVyQ2hhcnRzXzEgPSBbXTtcbiAgICAgICAgICAgIGVhY2goaW5zdGFuY2VzLCBmdW5jdGlvbiAob3RoZXJDaGFydCkge1xuICAgICAgICAgICAgICBpZiAob3RoZXJDaGFydCAhPT0gY2hhcnQgJiYgb3RoZXJDaGFydC5ncm91cCA9PT0gY2hhcnQuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICBvdGhlckNoYXJ0c18xLnB1c2gob3RoZXJDaGFydCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGVkQ2hhcnRzU3RhdHVzKG90aGVyQ2hhcnRzXzEsIENPTk5FQ1RfU1RBVFVTX1BFTkRJTkcpO1xuICAgICAgICAgICAgZWFjaChvdGhlckNoYXJ0c18xLCBmdW5jdGlvbiAob3RoZXJDaGFydCkge1xuICAgICAgICAgICAgICBpZiAob3RoZXJDaGFydFtDT05ORUNUX1NUQVRVU19LRVldICE9PSBDT05ORUNUX1NUQVRVU19VUERBVElORykge1xuICAgICAgICAgICAgICAgIG90aGVyQ2hhcnQuZGlzcGF0Y2hBY3Rpb24oYWN0aW9uXzEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3RlZENoYXJ0c1N0YXR1cyhvdGhlckNoYXJ0c18xLCBDT05ORUNUX1NUQVRVU19VUERBVEVEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSgpO1xuICByZXR1cm4gRUNoYXJ0cztcbn0oRXZlbnRmdWwpO1xudmFyIGVjaGFydHNQcm90byA9IEVDaGFydHMucHJvdG90eXBlO1xuZWNoYXJ0c1Byb3RvLm9uID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VFQ2hhcnRzKCdvbicpO1xuZWNoYXJ0c1Byb3RvLm9mZiA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlRUNoYXJ0cygnb2ZmJyk7XG4vKipcclxuICogQGRlcHJlY2F0ZWRcclxuICovXG4vLyBAdHMtaWdub3JlXG5lY2hhcnRzUHJvdG8ub25lID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2IsIGN0eCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlcHJlY2F0ZUxvZygnRUNoYXJ0cyNvbmUgaXMgZGVwcmVjYXRlZC4nKTtcbiAgZnVuY3Rpb24gd3JhcHBlZCgpIHtcbiAgICB2YXIgYXJnczIgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgYXJnczJbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgY2IgJiYgY2IuYXBwbHkgJiYgY2IuYXBwbHkodGhpcywgYXJnczIpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBzZWxmLm9mZihldmVudE5hbWUsIHdyYXBwZWQpO1xuICB9XG4gIDtcbiAgLy8gQHRzLWlnbm9yZVxuICB0aGlzLm9uLmNhbGwodGhpcywgZXZlbnROYW1lLCB3cmFwcGVkLCBjdHgpO1xufTtcbnZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ21vdXNlbW92ZScsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdnbG9iYWxvdXQnLCAnY29udGV4dG1lbnUnXTtcbmZ1bmN0aW9uIGRpc3Bvc2VkV2FybmluZyhpZCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oJ0luc3RhbmNlICcgKyBpZCArICcgaGFzIGJlZW4gZGlzcG9zZWQnKTtcbiAgfVxufVxudmFyIGFjdGlvbnMgPSB7fTtcbi8qKlxyXG4gKiBNYXAgZXZlbnRUeXBlIHRvIGFjdGlvblR5cGVcclxuICovXG52YXIgZXZlbnRBY3Rpb25NYXAgPSB7fTtcbnZhciBkYXRhUHJvY2Vzc29yRnVuY3MgPSBbXTtcbnZhciBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcyA9IFtdO1xudmFyIHZpc3VhbEZ1bmNzID0gW107XG52YXIgdGhlbWVTdG9yYWdlID0ge307XG52YXIgbG9hZGluZ0VmZmVjdHMgPSB7fTtcbnZhciBpbnN0YW5jZXMgPSB7fTtcbnZhciBjb25uZWN0ZWRHcm91cHMgPSB7fTtcbnZhciBpZEJhc2UgPSArbmV3IERhdGUoKSAtIDA7XG52YXIgZ3JvdXBJZEJhc2UgPSArbmV3IERhdGUoKSAtIDA7XG52YXIgRE9NX0FUVFJJQlVURV9LRVkgPSAnX2VjaGFydHNfaW5zdGFuY2VfJztcbi8qKlxyXG4gKiBAcGFyYW0gb3B0cy5kZXZpY2VQaXhlbFJhdGlvIFVzZSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyBieSBkZWZhdWx0XHJcbiAqIEBwYXJhbSBvcHRzLnJlbmRlcmVyIENhbiBjaG9vc2UgJ2NhbnZhcycgb3IgJ3N2ZycgdG8gcmVuZGVyIHRoZSBjaGFydC5cclxuICogQHBhcmFtIG9wdHMud2lkdGggVXNlIGNsaWVudFdpZHRoIG9mIHRoZSBpbnB1dCBgZG9tYCBieSBkZWZhdWx0LlxyXG4gKiAgICAgICAgQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXHJcbiAqIEBwYXJhbSBvcHRzLmhlaWdodCBVc2UgY2xpZW50SGVpZ2h0IG9mIHRoZSBpbnB1dCBgZG9tYCBieSBkZWZhdWx0LlxyXG4gKiAgICAgICAgQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXHJcbiAqIEBwYXJhbSBvcHRzLmxvY2FsZSBTcGVjaWZ5IHRoZSBsb2NhbGUuXHJcbiAqIEBwYXJhbSBvcHRzLnVzZURpcnR5UmVjdCBFbmFibGUgZGlydHkgcmVjdGFuZ2xlIHJlbmRlcmluZyBvciBub3QuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXQoZG9tLCB0aGVtZSwgb3B0cykge1xuICB2YXIgaXNDbGllbnQgPSAhKG9wdHMgJiYgb3B0cy5zc3IpO1xuICBpZiAoaXNDbGllbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFkb20pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbml0aWFsaXplIGZhaWxlZDogaW52YWxpZCBkb20uJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBleGlzdEluc3RhbmNlID0gZ2V0SW5zdGFuY2VCeURvbShkb20pO1xuICAgIGlmIChleGlzdEluc3RhbmNlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdUaGVyZSBpcyBhIGNoYXJ0IGluc3RhbmNlIGFscmVhZHkgaW5pdGlhbGl6ZWQgb24gdGhlIGRvbS4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdEluc3RhbmNlO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzRG9tKGRvbSkgJiYgZG9tLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdDQU5WQVMnICYmICghZG9tLmNsaWVudFdpZHRoICYmICghb3B0cyB8fCBvcHRzLndpZHRoID09IG51bGwpIHx8ICFkb20uY2xpZW50SGVpZ2h0ICYmICghb3B0cyB8fCBvcHRzLmhlaWdodCA9PSBudWxsKSkpIHtcbiAgICAgICAgd2FybignQ2FuXFwndCBnZXQgRE9NIHdpZHRoIG9yIGhlaWdodC4gUGxlYXNlIGNoZWNrICcgKyAnZG9tLmNsaWVudFdpZHRoIGFuZCBkb20uY2xpZW50SGVpZ2h0LiBUaGV5IHNob3VsZCBub3QgYmUgMC4nICsgJ0ZvciBleGFtcGxlLCB5b3UgbWF5IG5lZWQgdG8gY2FsbCB0aGlzIGluIHRoZSBjYWxsYmFjayAnICsgJ29mIHdpbmRvdy5vbmxvYWQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBjaGFydCA9IG5ldyBFQ2hhcnRzKGRvbSwgdGhlbWUsIG9wdHMpO1xuICBjaGFydC5pZCA9ICdlY18nICsgaWRCYXNlKys7XG4gIGluc3RhbmNlc1tjaGFydC5pZF0gPSBjaGFydDtcbiAgaXNDbGllbnQgJiYgbW9kZWxVdGlsLnNldEF0dHJpYnV0ZShkb20sIERPTV9BVFRSSUJVVEVfS0VZLCBjaGFydC5pZCk7XG4gIGVuYWJsZUNvbm5lY3QoY2hhcnQpO1xuICBsaWZlY3ljbGUudHJpZ2dlcignYWZ0ZXJpbml0JywgY2hhcnQpO1xuICByZXR1cm4gY2hhcnQ7XG59XG4vKipcclxuICogQHVzYWdlXHJcbiAqIChBKVxyXG4gKiBgYGBqc1xyXG4gKiBsZXQgY2hhcnQxID0gZWNoYXJ0cy5pbml0KGRvbTEpO1xyXG4gKiBsZXQgY2hhcnQyID0gZWNoYXJ0cy5pbml0KGRvbTIpO1xyXG4gKiBjaGFydDEuZ3JvdXAgPSAneHh4JztcclxuICogY2hhcnQyLmdyb3VwID0gJ3h4eCc7XHJcbiAqIGVjaGFydHMuY29ubmVjdCgneHh4Jyk7XHJcbiAqIGBgYFxyXG4gKiAoQilcclxuICogYGBganNcclxuICogbGV0IGNoYXJ0MSA9IGVjaGFydHMuaW5pdChkb20xKTtcclxuICogbGV0IGNoYXJ0MiA9IGVjaGFydHMuaW5pdChkb20yKTtcclxuICogZWNoYXJ0cy5jb25uZWN0KCd4eHgnLCBbY2hhcnQxLCBjaGFydDJdKTtcclxuICogYGBgXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3QoZ3JvdXBJZCkge1xuICAvLyBJcyBhcnJheSBvZiBjaGFydHNcbiAgaWYgKGlzQXJyYXkoZ3JvdXBJZCkpIHtcbiAgICB2YXIgY2hhcnRzID0gZ3JvdXBJZDtcbiAgICBncm91cElkID0gbnVsbDtcbiAgICAvLyBJZiBhbnkgY2hhcnQgaGFzIGdyb3VwXG4gICAgZWFjaChjaGFydHMsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgaWYgKGNoYXJ0Lmdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgZ3JvdXBJZCA9IGNoYXJ0Lmdyb3VwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGdyb3VwSWQgPSBncm91cElkIHx8ICdnXycgKyBncm91cElkQmFzZSsrO1xuICAgIGVhY2goY2hhcnRzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICAgIGNoYXJ0Lmdyb3VwID0gZ3JvdXBJZDtcbiAgICB9KTtcbiAgfVxuICBjb25uZWN0ZWRHcm91cHNbZ3JvdXBJZF0gPSB0cnVlO1xuICByZXR1cm4gZ3JvdXBJZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkaXNjb25uZWN0KGdyb3VwSWQpIHtcbiAgY29ubmVjdGVkR3JvdXBzW2dyb3VwSWRdID0gZmFsc2U7XG59XG4vKipcclxuICogQWxpYXMgYW5kIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuICogQGRlcHJlY2F0ZWRcclxuICovXG5leHBvcnQgdmFyIGRpc0Nvbm5lY3QgPSBkaXNjb25uZWN0O1xuLyoqXHJcbiAqIERpc3Bvc2UgYSBjaGFydCBpbnN0YW5jZVxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlKGNoYXJ0KSB7XG4gIGlmIChpc1N0cmluZyhjaGFydCkpIHtcbiAgICBjaGFydCA9IGluc3RhbmNlc1tjaGFydF07XG4gIH0gZWxzZSBpZiAoIShjaGFydCBpbnN0YW5jZW9mIEVDaGFydHMpKSB7XG4gICAgLy8gVHJ5IHRvIHRyZWF0IGFzIGRvbVxuICAgIGNoYXJ0ID0gZ2V0SW5zdGFuY2VCeURvbShjaGFydCk7XG4gIH1cbiAgaWYgKGNoYXJ0IGluc3RhbmNlb2YgRUNoYXJ0cyAmJiAhY2hhcnQuaXNEaXNwb3NlZCgpKSB7XG4gICAgY2hhcnQuZGlzcG9zZSgpO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5zdGFuY2VCeURvbShkb20pIHtcbiAgcmV0dXJuIGluc3RhbmNlc1ttb2RlbFV0aWwuZ2V0QXR0cmlidXRlKGRvbSwgRE9NX0FUVFJJQlVURV9LRVkpXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnN0YW5jZUJ5SWQoa2V5KSB7XG4gIHJldHVybiBpbnN0YW5jZXNba2V5XTtcbn1cbi8qKlxyXG4gKiBSZWdpc3RlciB0aGVtZVxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclRoZW1lKG5hbWUsIHRoZW1lKSB7XG4gIHRoZW1lU3RvcmFnZVtuYW1lXSA9IHRoZW1lO1xufVxuLyoqXHJcbiAqIFJlZ2lzdGVyIG9wdGlvbiBwcmVwcm9jZXNzb3JcclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJQcmVwcm9jZXNzb3IocHJlcHJvY2Vzc29yRnVuYykge1xuICBpZiAoaW5kZXhPZihvcHRpb25QcmVwcm9jZXNzb3JGdW5jcywgcHJlcHJvY2Vzc29yRnVuYykgPCAwKSB7XG4gICAgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MucHVzaChwcmVwcm9jZXNzb3JGdW5jKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyUHJvY2Vzc29yKHByaW9yaXR5LCBwcm9jZXNzb3IpIHtcbiAgbm9ybWFsaXplUmVnaXN0ZXIoZGF0YVByb2Nlc3NvckZ1bmNzLCBwcmlvcml0eSwgcHJvY2Vzc29yLCBQUklPUklUWV9QUk9DRVNTT1JfREVGQVVMVCk7XG59XG4vKipcclxuICogUmVnaXN0ZXIgcG9zdEluaXRlclxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb3N0SW5pdEZ1bmNcclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJQb3N0SW5pdChwb3N0SW5pdEZ1bmMpIHtcbiAgcmVnaXN0ZXJVcGRhdGVMaWZlY3ljbGUoJ2FmdGVyaW5pdCcsIHBvc3RJbml0RnVuYyk7XG59XG4vKipcclxuICogUmVnaXN0ZXIgcG9zdFVwZGF0ZXJcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcG9zdFVwZGF0ZUZ1bmNcclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJQb3N0VXBkYXRlKHBvc3RVcGRhdGVGdW5jKSB7XG4gIHJlZ2lzdGVyVXBkYXRlTGlmZWN5Y2xlKCdhZnRlcnVwZGF0ZScsIHBvc3RVcGRhdGVGdW5jKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclVwZGF0ZUxpZmVjeWNsZShuYW1lLCBjYikge1xuICBsaWZlY3ljbGUub24obmFtZSwgY2IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyQWN0aW9uKGFjdGlvbkluZm8sIGV2ZW50TmFtZSwgYWN0aW9uKSB7XG4gIGlmIChpc0Z1bmN0aW9uKGV2ZW50TmFtZSkpIHtcbiAgICBhY3Rpb24gPSBldmVudE5hbWU7XG4gICAgZXZlbnROYW1lID0gJyc7XG4gIH1cbiAgdmFyIGFjdGlvblR5cGUgPSBpc09iamVjdChhY3Rpb25JbmZvKSA/IGFjdGlvbkluZm8udHlwZSA6IFthY3Rpb25JbmZvLCBhY3Rpb25JbmZvID0ge1xuICAgIGV2ZW50OiBldmVudE5hbWVcbiAgfV1bMF07XG4gIC8vIEV2ZW50IG5hbWUgaXMgYWxsIGxvd2VyY2FzZVxuICBhY3Rpb25JbmZvLmV2ZW50ID0gKGFjdGlvbkluZm8uZXZlbnQgfHwgYWN0aW9uVHlwZSkudG9Mb3dlckNhc2UoKTtcbiAgZXZlbnROYW1lID0gYWN0aW9uSW5mby5ldmVudDtcbiAgaWYgKGV2ZW50QWN0aW9uTWFwW2V2ZW50TmFtZV0pIHtcbiAgICAvLyBBbHJlYWR5IHJlZ2lzdGVyZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFZhbGlkYXRlIGFjdGlvbiB0eXBlIGFuZCBldmVudCBuYW1lLlxuICBhc3NlcnQoQUNUSU9OX1JFRy50ZXN0KGFjdGlvblR5cGUpICYmIEFDVElPTl9SRUcudGVzdChldmVudE5hbWUpKTtcbiAgaWYgKCFhY3Rpb25zW2FjdGlvblR5cGVdKSB7XG4gICAgYWN0aW9uc1thY3Rpb25UeXBlXSA9IHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgYWN0aW9uSW5mbzogYWN0aW9uSW5mb1xuICAgIH07XG4gIH1cbiAgZXZlbnRBY3Rpb25NYXBbZXZlbnROYW1lXSA9IGFjdGlvblR5cGU7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJDb29yZGluYXRlU3lzdGVtKHR5cGUsIGNvb3JkU3lzQ3JlYXRvcikge1xuICBDb29yZGluYXRlU3lzdGVtTWFuYWdlci5yZWdpc3Rlcih0eXBlLCBjb29yZFN5c0NyZWF0b3IpO1xufVxuLyoqXHJcbiAqIEdldCBkaW1lbnNpb25zIG9mIHNwZWNpZmllZCBjb29yZGluYXRlIHN5c3RlbS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcclxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZ3xPYmplY3Q+fVxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb29yZGluYXRlU3lzdGVtRGltZW5zaW9ucyh0eXBlKSB7XG4gIHZhciBjb29yZFN5c0NyZWF0b3IgPSBDb29yZGluYXRlU3lzdGVtTWFuYWdlci5nZXQodHlwZSk7XG4gIGlmIChjb29yZFN5c0NyZWF0b3IpIHtcbiAgICByZXR1cm4gY29vcmRTeXNDcmVhdG9yLmdldERpbWVuc2lvbnNJbmZvID8gY29vcmRTeXNDcmVhdG9yLmdldERpbWVuc2lvbnNJbmZvKCkgOiBjb29yZFN5c0NyZWF0b3IuZGltZW5zaW9ucy5zbGljZSgpO1xuICB9XG59XG5leHBvcnQgeyByZWdpc3RlckxvY2FsZSB9IGZyb20gJy4vbG9jYWxlLmpzJztcbmZ1bmN0aW9uIHJlZ2lzdGVyTGF5b3V0KHByaW9yaXR5LCBsYXlvdXRUYXNrKSB7XG4gIG5vcm1hbGl6ZVJlZ2lzdGVyKHZpc3VhbEZ1bmNzLCBwcmlvcml0eSwgbGF5b3V0VGFzaywgUFJJT1JJVFlfVklTVUFMX0xBWU9VVCwgJ2xheW91dCcpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJWaXN1YWwocHJpb3JpdHksIHZpc3VhbFRhc2spIHtcbiAgbm9ybWFsaXplUmVnaXN0ZXIodmlzdWFsRnVuY3MsIHByaW9yaXR5LCB2aXN1YWxUYXNrLCBQUklPUklUWV9WSVNVQUxfQ0hBUlQsICd2aXN1YWwnKTtcbn1cbmV4cG9ydCB7IHJlZ2lzdGVyTGF5b3V0LCByZWdpc3RlclZpc3VhbCB9O1xudmFyIHJlZ2lzdGVyZWRUYXNrcyA9IFtdO1xuZnVuY3Rpb24gbm9ybWFsaXplUmVnaXN0ZXIodGFyZ2V0TGlzdCwgcHJpb3JpdHksIGZuLCBkZWZhdWx0UHJpb3JpdHksIHZpc3VhbFR5cGUpIHtcbiAgaWYgKGlzRnVuY3Rpb24ocHJpb3JpdHkpIHx8IGlzT2JqZWN0KHByaW9yaXR5KSkge1xuICAgIGZuID0gcHJpb3JpdHk7XG4gICAgcHJpb3JpdHkgPSBkZWZhdWx0UHJpb3JpdHk7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaXNOYU4ocHJpb3JpdHkpIHx8IHByaW9yaXR5ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBwcmlvcml0eScpO1xuICAgIH1cbiAgICAvLyBDaGVjayBkdXBsaWNhdGVcbiAgICBlYWNoKHRhcmdldExpc3QsIGZ1bmN0aW9uICh3cmFwKSB7XG4gICAgICBhc3NlcnQod3JhcC5fX3JhdyAhPT0gZm4pO1xuICAgIH0pO1xuICB9XG4gIC8vIEFscmVhZHkgcmVnaXN0ZXJlZFxuICBpZiAoaW5kZXhPZihyZWdpc3RlcmVkVGFza3MsIGZuKSA+PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlZ2lzdGVyZWRUYXNrcy5wdXNoKGZuKTtcbiAgdmFyIHN0YWdlSGFuZGxlciA9IFNjaGVkdWxlci53cmFwU3RhZ2VIYW5kbGVyKGZuLCB2aXN1YWxUeXBlKTtcbiAgc3RhZ2VIYW5kbGVyLl9fcHJpbyA9IHByaW9yaXR5O1xuICBzdGFnZUhhbmRsZXIuX19yYXcgPSBmbjtcbiAgdGFyZ2V0TGlzdC5wdXNoKHN0YWdlSGFuZGxlcik7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJMb2FkaW5nKG5hbWUsIGxvYWRpbmdGeCkge1xuICBsb2FkaW5nRWZmZWN0c1tuYW1lXSA9IGxvYWRpbmdGeDtcbn1cbi8qKlxyXG4gKiBaUmVuZGVyIG5lZWQgYSBjYW52YXMgY29udGV4dCB0byBkbyBtZWFzdXJlVGV4dC5cclxuICogQnV0IGluIG5vZGUgZW52aXJvbm1lbnQgY2FudmFzIG1heSBiZSBjcmVhdGVkIGJ5IG5vZGUtY2FudmFzLlxyXG4gKiBTbyB3ZSBuZWVkIHRvIHNwZWNpZnkgaG93IHRvIGNyZWF0ZSBhIGNhbnZhcyBpbnN0ZWFkIG9mIHVzaW5nIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXHJcbiAqXHJcbiAqXHJcbiAqIEBkZXByZWNhdGVkIHVzZSBzZXRQbGF0Zm9ybUFQSSh7IGNyZWF0ZUNhbnZhcyB9KSBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgbGV0IENhbnZhcyA9IHJlcXVpcmUoJ2NhbnZhcycpO1xyXG4gKiAgICAgbGV0IGVjaGFydHMgPSByZXF1aXJlKCdlY2hhcnRzJyk7XHJcbiAqICAgICBlY2hhcnRzLnNldENhbnZhc0NyZWF0b3IoZnVuY3Rpb24gKCkge1xyXG4gKiAgICAgICAgIC8vIFNtYWxsIHNpemUgaXMgZW5vdWdoLlxyXG4gKiAgICAgICAgIHJldHVybiBuZXcgQ2FudmFzKDMyLCAzMik7XHJcbiAqICAgICB9KTtcclxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q2FudmFzQ3JlYXRvcihjcmVhdG9yKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGVwcmVjYXRlTG9nKCdzZXRDYW52YXNDcmVhdG9yIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXRQbGF0Zm9ybUFQSSh7IGNyZWF0ZUNhbnZhcyB9KSBpbnN0ZWFkLicpO1xuICB9XG4gIHNldFBsYXRmb3JtQVBJKHtcbiAgICBjcmVhdGVDYW52YXM6IGNyZWF0b3JcbiAgfSk7XG59XG4vKipcclxuICogVGhlIHBhcmFtZXRlcnMgYW5kIHVzYWdlOiBzZWUgYGdlb1NvdXJjZU1hbmFnZXIucmVnaXN0ZXJNYXBgLlxyXG4gKiBDb21wYXRpYmxlIHdpdGggcHJldmlvdXMgYGVjaGFydHMucmVnaXN0ZXJNYXBgLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlck1hcChtYXBOYW1lLCBnZW9Kc29uLCBzcGVjaWFsQXJlYXMpIHtcbiAgdmFyIHJlZ2lzdGVyTWFwID0gZ2V0SW1wbCgncmVnaXN0ZXJNYXAnKTtcbiAgcmVnaXN0ZXJNYXAgJiYgcmVnaXN0ZXJNYXAobWFwTmFtZSwgZ2VvSnNvbiwgc3BlY2lhbEFyZWFzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXAobWFwTmFtZSkge1xuICB2YXIgZ2V0TWFwID0gZ2V0SW1wbCgnZ2V0TWFwJyk7XG4gIHJldHVybiBnZXRNYXAgJiYgZ2V0TWFwKG1hcE5hbWUpO1xufVxuZXhwb3J0IHZhciByZWdpc3RlclRyYW5zZm9ybSA9IHJlZ2lzdGVyRXh0ZXJuYWxUcmFuc2Zvcm07XG4vKipcclxuICogR2xvYmEgZGlzcGF0Y2hBY3Rpb24gdG8gYSBzcGVjaWZpZWQgY2hhcnQgaW5zdGFuY2UuXHJcbiAqL1xuLy8gZXhwb3J0IGZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uKHBheWxvYWQ6IHsgY2hhcnRJZDogc3RyaW5nIH0gJiBQYXlsb2FkLCBvcHQ/OiBQYXJhbWV0ZXJzPEVDaGFydHNbJ2Rpc3BhdGNoQWN0aW9uJ10+WzFdKSB7XG4vLyAgICAgaWYgKCFwYXlsb2FkIHx8ICFwYXlsb2FkLmNoYXJ0SWQpIHtcbi8vICAgICAgICAgLy8gTXVzdCBoYXZlIGNoYXJ0SWQgdG8gZmluZCBjaGFydFxuLy8gICAgICAgICByZXR1cm47XG4vLyAgICAgfVxuLy8gICAgIGNvbnN0IGNoYXJ0ID0gaW5zdGFuY2VzW3BheWxvYWQuY2hhcnRJZF07XG4vLyAgICAgaWYgKGNoYXJ0KSB7XG4vLyAgICAgICAgIGNoYXJ0LmRpc3BhdGNoQWN0aW9uKHBheWxvYWQsIG9wdCk7XG4vLyAgICAgfVxuLy8gfVxuLy8gQnVpbHRpbiBnbG9iYWwgdmlzdWFsXG5yZWdpc3RlclZpc3VhbChQUklPUklUWV9WSVNVQUxfR0xPQkFMLCBzZXJpZXNTdHlsZVRhc2spO1xucmVnaXN0ZXJWaXN1YWwoUFJJT1JJVFlfVklTVUFMX0NIQVJUX0RBVEFfQ1VTVE9NLCBkYXRhU3R5bGVUYXNrKTtcbnJlZ2lzdGVyVmlzdWFsKFBSSU9SSVRZX1ZJU1VBTF9DSEFSVF9EQVRBX0NVU1RPTSwgZGF0YUNvbG9yUGFsZXR0ZVRhc2spO1xucmVnaXN0ZXJWaXN1YWwoUFJJT1JJVFlfVklTVUFMX0dMT0JBTCwgc2VyaWVzU3ltYm9sVGFzayk7XG5yZWdpc3RlclZpc3VhbChQUklPUklUWV9WSVNVQUxfQ0hBUlRfREFUQV9DVVNUT00sIGRhdGFTeW1ib2xUYXNrKTtcbnJlZ2lzdGVyVmlzdWFsKFBSSU9SSVRZX1ZJU1VBTF9ERUNBTCwgZGVjYWwpO1xucmVnaXN0ZXJQcmVwcm9jZXNzb3IoYmFja3dhcmRDb21wYXQpO1xucmVnaXN0ZXJQcm9jZXNzb3IoUFJJT1JJVFlfUFJPQ0VTU09SX0RBVEFTVEFDSywgZGF0YVN0YWNrKTtcbnJlZ2lzdGVyTG9hZGluZygnZGVmYXVsdCcsIGxvYWRpbmdEZWZhdWx0KTtcbi8vIERlZmF1bHQgYWN0aW9uc1xucmVnaXN0ZXJBY3Rpb24oe1xuICB0eXBlOiBISUdITElHSFRfQUNUSU9OX1RZUEUsXG4gIGV2ZW50OiBISUdITElHSFRfQUNUSU9OX1RZUEUsXG4gIHVwZGF0ZTogSElHSExJR0hUX0FDVElPTl9UWVBFXG59LCBub29wKTtcbnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogRE9XTlBMQVlfQUNUSU9OX1RZUEUsXG4gIGV2ZW50OiBET1dOUExBWV9BQ1RJT05fVFlQRSxcbiAgdXBkYXRlOiBET1dOUExBWV9BQ1RJT05fVFlQRVxufSwgbm9vcCk7XG5yZWdpc3RlckFjdGlvbih7XG4gIHR5cGU6IFNFTEVDVF9BQ1RJT05fVFlQRSxcbiAgZXZlbnQ6IFNFTEVDVF9BQ1RJT05fVFlQRSxcbiAgdXBkYXRlOiBTRUxFQ1RfQUNUSU9OX1RZUEVcbn0sIG5vb3ApO1xucmVnaXN0ZXJBY3Rpb24oe1xuICB0eXBlOiBVTlNFTEVDVF9BQ1RJT05fVFlQRSxcbiAgZXZlbnQ6IFVOU0VMRUNUX0FDVElPTl9UWVBFLFxuICB1cGRhdGU6IFVOU0VMRUNUX0FDVElPTl9UWVBFXG59LCBub29wKTtcbnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogVE9HR0xFX1NFTEVDVF9BQ1RJT05fVFlQRSxcbiAgZXZlbnQ6IFRPR0dMRV9TRUxFQ1RfQUNUSU9OX1RZUEUsXG4gIHVwZGF0ZTogVE9HR0xFX1NFTEVDVF9BQ1RJT05fVFlQRVxufSwgbm9vcCk7XG4vLyBEZWZhdWx0IHRoZW1lXG5yZWdpc3RlclRoZW1lKCdsaWdodCcsIGxpZ2h0VGhlbWUpO1xucmVnaXN0ZXJUaGVtZSgnZGFyaycsIGRhcmtUaGVtZSk7XG4vLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgd2hlcmUgdGhlIG5hbWVzcGFjZSBgZGF0YVRvb2xgIHdpbGxcbi8vIGJlIG1vdW50ZWQgb24gYGVjaGFydHNgIGlzIHRoZSBleHRlbnNpb24gYGRhdGFUb29sYCBpcyBpbXBvcnRlZC5cbmV4cG9ydCB2YXIgZGF0YVRvb2wgPSB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///95383\n")}}]);