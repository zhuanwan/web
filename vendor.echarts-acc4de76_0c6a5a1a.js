"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[6413],{42751:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Component.js\nvar Component = __webpack_require__(15915);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/SeriesData.js\nvar SeriesData = __webpack_require__(6006);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n;// ./node_modules/echarts/lib/component/timeline/TimelineModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar TimelineModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(TimelineModel, _super);\n  function TimelineModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = TimelineModel.type;\n    _this.layoutMode = 'box';\n    return _this;\n  }\n  /**\r\n   * @override\r\n   */\n  TimelineModel.prototype.init = function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    this._initData();\n  };\n  /**\r\n   * @override\r\n   */\n  TimelineModel.prototype.mergeOption = function (option) {\n    _super.prototype.mergeOption.apply(this, arguments);\n    this._initData();\n  };\n  TimelineModel.prototype.setCurrentIndex = function (currentIndex) {\n    if (currentIndex == null) {\n      currentIndex = this.option.currentIndex;\n    }\n    var count = this._data.count();\n    if (this.option.loop) {\n      currentIndex = (currentIndex % count + count) % count;\n    } else {\n      currentIndex >= count && (currentIndex = count - 1);\n      currentIndex < 0 && (currentIndex = 0);\n    }\n    this.option.currentIndex = currentIndex;\n  };\n  /**\r\n   * @return {number} currentIndex\r\n   */\n  TimelineModel.prototype.getCurrentIndex = function () {\n    return this.option.currentIndex;\n  };\n  /**\r\n   * @return {boolean}\r\n   */\n  TimelineModel.prototype.isIndexMax = function () {\n    return this.getCurrentIndex() >= this._data.count() - 1;\n  };\n  /**\r\n   * @param {boolean} state true: play, false: stop\r\n   */\n  TimelineModel.prototype.setPlayState = function (state) {\n    this.option.autoPlay = !!state;\n  };\n  /**\r\n   * @return {boolean} true: play, false: stop\r\n   */\n  TimelineModel.prototype.getPlayState = function () {\n    return !!this.option.autoPlay;\n  };\n  /**\r\n   * @private\r\n   */\n  TimelineModel.prototype._initData = function () {\n    var thisOption = this.option;\n    var dataArr = thisOption.data || [];\n    var axisType = thisOption.axisType;\n    var names = this._names = [];\n    var processedDataArr;\n    if (axisType === 'category') {\n      processedDataArr = [];\n      (0,util.each)(dataArr, function (item, index) {\n        var value = (0,model/* convertOptionIdName */.vS)((0,model/* getDataItemValue */.vj)(item), '');\n        var newItem;\n        if ((0,util.isObject)(item)) {\n          newItem = (0,util.clone)(item);\n          newItem.value = index;\n        } else {\n          newItem = index;\n        }\n        processedDataArr.push(newItem);\n        names.push(value);\n      });\n    } else {\n      processedDataArr = dataArr;\n    }\n    var dimType = {\n      category: 'ordinal',\n      time: 'time',\n      value: 'number'\n    }[axisType] || 'number';\n    var data = this._data = new SeriesData/* default */.A([{\n      name: 'value',\n      type: dimType\n    }], this);\n    data.initData(processedDataArr, names);\n  };\n  TimelineModel.prototype.getData = function () {\n    return this._data;\n  };\n  /**\r\n   * @public\r\n   * @return {Array.<string>} categoreis\r\n   */\n  TimelineModel.prototype.getCategories = function () {\n    if (this.get('axisType') === 'category') {\n      return this._names.slice();\n    }\n  };\n  TimelineModel.type = 'timeline';\n  /**\r\n   * @protected\r\n   */\n  TimelineModel.defaultOption = {\n    // zlevel: 0,                  // 一级层叠\n    z: 4,\n    show: true,\n    axisType: 'time',\n    realtime: true,\n    left: '20%',\n    top: null,\n    right: '20%',\n    bottom: 0,\n    width: null,\n    height: 40,\n    padding: 5,\n    controlPosition: 'left',\n    autoPlay: false,\n    rewind: false,\n    loop: true,\n    playInterval: 2000,\n    currentIndex: 0,\n    itemStyle: {},\n    label: {\n      color: '#000'\n    },\n    data: []\n  };\n  return TimelineModel;\n}(Component/* default */.A);\n/* harmony default export */ const timeline_TimelineModel = (TimelineModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/mixin/dataFormat.js\nvar dataFormat = __webpack_require__(9427);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/component.js\nvar component = __webpack_require__(12616);\n;// ./node_modules/echarts/lib/component/timeline/SliderTimelineModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar SliderTimelineModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(SliderTimelineModel, _super);\n  function SliderTimelineModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = SliderTimelineModel.type;\n    return _this;\n  }\n  SliderTimelineModel.type = 'timeline.slider';\n  /**\r\n   * @protected\r\n   */\n  SliderTimelineModel.defaultOption = (0,component/* inheritDefaultOption */.G_)(timeline_TimelineModel.defaultOption, {\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderColor: '#ccc',\n    borderWidth: 0,\n    orient: 'horizontal',\n    inverse: false,\n    tooltip: {\n      trigger: 'item' // data item may also have tootip attr.\n    },\n    symbol: 'circle',\n    symbolSize: 12,\n    lineStyle: {\n      show: true,\n      width: 2,\n      color: '#DAE1F5'\n    },\n    label: {\n      position: 'auto',\n      // When using number, label position is not\n      // restricted by viewRect.\n      // positive: right/bottom, negative: left/top\n      show: true,\n      interval: 'auto',\n      rotate: 0,\n      // formatter: null,\n      // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n      color: '#A4B1D7'\n    },\n    itemStyle: {\n      color: '#A4B1D7',\n      borderWidth: 1\n    },\n    checkpointStyle: {\n      symbol: 'circle',\n      symbolSize: 15,\n      color: '#316bf3',\n      borderColor: '#fff',\n      borderWidth: 2,\n      shadowBlur: 2,\n      shadowOffsetX: 1,\n      shadowOffsetY: 1,\n      shadowColor: 'rgba(0, 0, 0, 0.3)',\n      // borderColor: 'rgba(194,53,49, 0.5)',\n      animation: true,\n      animationDuration: 300,\n      animationEasing: 'quinticInOut'\n    },\n    controlStyle: {\n      show: true,\n      showPlayBtn: true,\n      showPrevBtn: true,\n      showNextBtn: true,\n      itemSize: 24,\n      itemGap: 12,\n      position: 'left',\n      playIcon: 'path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z',\n      stopIcon: 'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z',\n      // eslint-disable-next-line max-len\n      nextIcon: 'M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z',\n      // eslint-disable-next-line max-len\n      prevIcon: 'M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z',\n      prevBtnSize: 18,\n      nextBtnSize: 18,\n      color: '#A4B1D7',\n      borderColor: '#A4B1D7',\n      borderWidth: 1\n    },\n    emphasis: {\n      label: {\n        show: true,\n        // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n        color: '#6f778d'\n      },\n      itemStyle: {\n        color: '#316BF3'\n      },\n      controlStyle: {\n        color: '#316BF3',\n        borderColor: '#316BF3',\n        borderWidth: 2\n      }\n    },\n    progress: {\n      lineStyle: {\n        color: '#316BF3'\n      },\n      itemStyle: {\n        color: '#316BF3'\n      },\n      label: {\n        color: '#6f778d'\n      }\n    },\n    data: []\n  });\n  return SliderTimelineModel;\n}(timeline_TimelineModel);\n(0,util.mixin)(SliderTimelineModel, dataFormat/* DataFormatMixin */.J.prototype);\n/* harmony default export */ const timeline_SliderTimelineModel = (SliderTimelineModel);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/BoundingRect.js\nvar BoundingRect = __webpack_require__(29308);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/matrix.js\nvar matrix = __webpack_require__(45587);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Line.js\nvar Line = __webpack_require__(82861);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar view_Component = __webpack_require__(59109);\n;// ./node_modules/echarts/lib/component/timeline/TimelineView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar TimelineView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(TimelineView, _super);\n  function TimelineView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = TimelineView.type;\n    return _this;\n  }\n  TimelineView.type = 'timeline';\n  return TimelineView;\n}(view_Component/* default */.A);\n/* harmony default export */ const timeline_TimelineView = (TimelineView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/Axis.js\nvar Axis = __webpack_require__(1727);\n;// ./node_modules/echarts/lib/component/timeline/TimelineAxis.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n/**\r\n * Extend axis 2d\r\n */\nvar TimelineAxis = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(TimelineAxis, _super);\n  function TimelineAxis(dim, scale, coordExtent, axisType) {\n    var _this = _super.call(this, dim, scale, coordExtent) || this;\n    _this.type = axisType || 'value';\n    return _this;\n  }\n  /**\r\n   * @override\r\n   */\n  TimelineAxis.prototype.getLabelModel = function () {\n    // Force override\n    return this.model.getModel('label');\n  };\n  /**\r\n   * @override\r\n   */\n  TimelineAxis.prototype.isHorizontal = function () {\n    return this.model.get('orient') === 'horizontal';\n  };\n  return TimelineAxis;\n}(Axis/* default */.A);\n/* harmony default export */ const timeline_TimelineAxis = (TimelineAxis);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/symbol.js\nvar util_symbol = __webpack_require__(62103);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/scale/Ordinal.js\nvar Ordinal = __webpack_require__(18550);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/scale/Time.js\nvar Time = __webpack_require__(12706);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/scale/Interval.js\nvar Interval = __webpack_require__(74562);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/contain/text.js\nvar contain_text = __webpack_require__(45558);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js\nvar tooltipMarkup = __webpack_require__(3961);\n;// ./node_modules/echarts/lib/component/timeline/SliderTimelineView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar PI = Math.PI;\nvar labelDataIndexStore = (0,model/* makeInner */.$r)();\nvar SliderTimelineView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(SliderTimelineView, _super);\n  function SliderTimelineView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = SliderTimelineView.type;\n    return _this;\n  }\n  SliderTimelineView.prototype.init = function (ecModel, api) {\n    this.api = api;\n  };\n  /**\r\n   * @override\r\n   */\n  SliderTimelineView.prototype.render = function (timelineModel, ecModel, api) {\n    this.model = timelineModel;\n    this.api = api;\n    this.ecModel = ecModel;\n    this.group.removeAll();\n    if (timelineModel.get('show', true)) {\n      var layoutInfo_1 = this._layout(timelineModel, api);\n      var mainGroup_1 = this._createGroup('_mainGroup');\n      var labelGroup = this._createGroup('_labelGroup');\n      var axis_1 = this._axis = this._createAxis(layoutInfo_1, timelineModel);\n      timelineModel.formatTooltip = function (dataIndex) {\n        var name = axis_1.scale.getLabel({\n          value: dataIndex\n        });\n        return (0,tooltipMarkup/* createTooltipMarkup */.Qx)('nameValue', {\n          noName: true,\n          value: name\n        });\n      };\n      (0,util.each)(['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'], function (name) {\n        this['_render' + name](layoutInfo_1, mainGroup_1, axis_1, timelineModel);\n      }, this);\n      this._renderAxisLabel(layoutInfo_1, labelGroup, axis_1, timelineModel);\n      this._position(layoutInfo_1, timelineModel);\n    }\n    this._doPlayStop();\n    this._updateTicksStatus();\n  };\n  /**\r\n   * @override\r\n   */\n  SliderTimelineView.prototype.remove = function () {\n    this._clearTimer();\n    this.group.removeAll();\n  };\n  /**\r\n   * @override\r\n   */\n  SliderTimelineView.prototype.dispose = function () {\n    this._clearTimer();\n  };\n  SliderTimelineView.prototype._layout = function (timelineModel, api) {\n    var labelPosOpt = timelineModel.get(['label', 'position']);\n    var orient = timelineModel.get('orient');\n    var viewRect = getViewRect(timelineModel, api);\n    var parsedLabelPos;\n    // Auto label offset.\n    if (labelPosOpt == null || labelPosOpt === 'auto') {\n      parsedLabelPos = orient === 'horizontal' ? viewRect.y + viewRect.height / 2 < api.getHeight() / 2 ? '-' : '+' : viewRect.x + viewRect.width / 2 < api.getWidth() / 2 ? '+' : '-';\n    } else if ((0,util.isString)(labelPosOpt)) {\n      parsedLabelPos = {\n        horizontal: {\n          top: '-',\n          bottom: '+'\n        },\n        vertical: {\n          left: '-',\n          right: '+'\n        }\n      }[orient][labelPosOpt];\n    } else {\n      // is number\n      parsedLabelPos = labelPosOpt;\n    }\n    var labelAlignMap = {\n      horizontal: 'center',\n      vertical: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'left' : 'right'\n    };\n    var labelBaselineMap = {\n      horizontal: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'top' : 'bottom',\n      vertical: 'middle'\n    };\n    var rotationMap = {\n      horizontal: 0,\n      vertical: PI / 2\n    };\n    // Position\n    var mainLength = orient === 'vertical' ? viewRect.height : viewRect.width;\n    var controlModel = timelineModel.getModel('controlStyle');\n    var showControl = controlModel.get('show', true);\n    var controlSize = showControl ? controlModel.get('itemSize') : 0;\n    var controlGap = showControl ? controlModel.get('itemGap') : 0;\n    var sizePlusGap = controlSize + controlGap;\n    // Special label rotate.\n    var labelRotation = timelineModel.get(['label', 'rotate']) || 0;\n    labelRotation = labelRotation * PI / 180; // To radian.\n    var playPosition;\n    var prevBtnPosition;\n    var nextBtnPosition;\n    var controlPosition = controlModel.get('position', true);\n    var showPlayBtn = showControl && controlModel.get('showPlayBtn', true);\n    var showPrevBtn = showControl && controlModel.get('showPrevBtn', true);\n    var showNextBtn = showControl && controlModel.get('showNextBtn', true);\n    var xLeft = 0;\n    var xRight = mainLength;\n    // position[0] means left, position[1] means middle.\n    if (controlPosition === 'left' || controlPosition === 'bottom') {\n      showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);\n      showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);\n      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n    } else {\n      // 'top' 'right'\n      showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n      showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);\n      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n    }\n    var axisExtent = [xLeft, xRight];\n    if (timelineModel.get('inverse')) {\n      axisExtent.reverse();\n    }\n    return {\n      viewRect: viewRect,\n      mainLength: mainLength,\n      orient: orient,\n      rotation: rotationMap[orient],\n      labelRotation: labelRotation,\n      labelPosOpt: parsedLabelPos,\n      labelAlign: timelineModel.get(['label', 'align']) || labelAlignMap[orient],\n      labelBaseline: timelineModel.get(['label', 'verticalAlign']) || timelineModel.get(['label', 'baseline']) || labelBaselineMap[orient],\n      // Based on mainGroup.\n      playPosition: playPosition,\n      prevBtnPosition: prevBtnPosition,\n      nextBtnPosition: nextBtnPosition,\n      axisExtent: axisExtent,\n      controlSize: controlSize,\n      controlGap: controlGap\n    };\n  };\n  SliderTimelineView.prototype._position = function (layoutInfo, timelineModel) {\n    // Position is be called finally, because bounding rect is needed for\n    // adapt content to fill viewRect (auto adapt offset).\n    // Timeline may be not all in the viewRect when 'offset' is specified\n    // as a number, because it is more appropriate that label aligns at\n    // 'offset' but not the other edge defined by viewRect.\n    var mainGroup = this._mainGroup;\n    var labelGroup = this._labelGroup;\n    var viewRect = layoutInfo.viewRect;\n    if (layoutInfo.orient === 'vertical') {\n      // transform to horizontal, inverse rotate by left-top point.\n      var m = matrix.create();\n      var rotateOriginX = viewRect.x;\n      var rotateOriginY = viewRect.y + viewRect.height;\n      matrix.translate(m, m, [-rotateOriginX, -rotateOriginY]);\n      matrix.rotate(m, m, -PI / 2);\n      matrix.translate(m, m, [rotateOriginX, rotateOriginY]);\n      viewRect = viewRect.clone();\n      viewRect.applyTransform(m);\n    }\n    var viewBound = getBound(viewRect);\n    var mainBound = getBound(mainGroup.getBoundingRect());\n    var labelBound = getBound(labelGroup.getBoundingRect());\n    var mainPosition = [mainGroup.x, mainGroup.y];\n    var labelsPosition = [labelGroup.x, labelGroup.y];\n    labelsPosition[0] = mainPosition[0] = viewBound[0][0];\n    var labelPosOpt = layoutInfo.labelPosOpt;\n    if (labelPosOpt == null || (0,util.isString)(labelPosOpt)) {\n      // '+' or '-'\n      var mainBoundIdx = labelPosOpt === '+' ? 0 : 1;\n      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);\n      toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);\n    } else {\n      var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;\n      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);\n      labelsPosition[1] = mainPosition[1] + labelPosOpt;\n    }\n    mainGroup.setPosition(mainPosition);\n    labelGroup.setPosition(labelsPosition);\n    mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;\n    setOrigin(mainGroup);\n    setOrigin(labelGroup);\n    function setOrigin(targetGroup) {\n      targetGroup.originX = viewBound[0][0] - targetGroup.x;\n      targetGroup.originY = viewBound[1][0] - targetGroup.y;\n    }\n    function getBound(rect) {\n      // [[xmin, xmax], [ymin, ymax]]\n      return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];\n    }\n    function toBound(fromPos, from, to, dimIdx, boundIdx) {\n      fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];\n    }\n  };\n  SliderTimelineView.prototype._createAxis = function (layoutInfo, timelineModel) {\n    var data = timelineModel.getData();\n    var axisType = timelineModel.get('axisType');\n    var scale = createScaleByModel(timelineModel, axisType);\n    // Customize scale. The `tickValue` is `dataIndex`.\n    scale.getTicks = function () {\n      return data.mapArray(['value'], function (value) {\n        return {\n          value: value\n        };\n      });\n    };\n    var dataExtent = data.getDataExtent('value');\n    scale.setExtent(dataExtent[0], dataExtent[1]);\n    scale.calcNiceTicks();\n    var axis = new timeline_TimelineAxis('value', scale, layoutInfo.axisExtent, axisType);\n    axis.model = timelineModel;\n    return axis;\n  };\n  SliderTimelineView.prototype._createGroup = function (key) {\n    var newGroup = this[key] = new Group/* default */.A();\n    this.group.add(newGroup);\n    return newGroup;\n  };\n  SliderTimelineView.prototype._renderAxisLine = function (layoutInfo, group, axis, timelineModel) {\n    var axisExtent = axis.getExtent();\n    if (!timelineModel.get(['lineStyle', 'show'])) {\n      return;\n    }\n    var line = new Line/* default */.A({\n      shape: {\n        x1: axisExtent[0],\n        y1: 0,\n        x2: axisExtent[1],\n        y2: 0\n      },\n      style: (0,util.extend)({\n        lineCap: 'round'\n      }, timelineModel.getModel('lineStyle').getLineStyle()),\n      silent: true,\n      z2: 1\n    });\n    group.add(line);\n    var progressLine = this._progressLine = new Line/* default */.A({\n      shape: {\n        x1: axisExtent[0],\n        x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],\n        y1: 0,\n        y2: 0\n      },\n      style: (0,util.defaults)({\n        lineCap: 'round',\n        lineWidth: line.style.lineWidth\n      }, timelineModel.getModel(['progress', 'lineStyle']).getLineStyle()),\n      silent: true,\n      z2: 1\n    });\n    group.add(progressLine);\n  };\n  SliderTimelineView.prototype._renderAxisTick = function (layoutInfo, group, axis, timelineModel) {\n    var _this = this;\n    var data = timelineModel.getData();\n    // Show all ticks, despite ignoring strategy.\n    var ticks = axis.scale.getTicks();\n    this._tickSymbols = [];\n    // The value is dataIndex, see the customized scale.\n    (0,util.each)(ticks, function (tick) {\n      var tickCoord = axis.dataToCoord(tick.value);\n      var itemModel = data.getItemModel(tick.value);\n      var itemStyleModel = itemModel.getModel('itemStyle');\n      var hoverStyleModel = itemModel.getModel(['emphasis', 'itemStyle']);\n      var progressStyleModel = itemModel.getModel(['progress', 'itemStyle']);\n      var symbolOpt = {\n        x: tickCoord,\n        y: 0,\n        onclick: (0,util.bind)(_this._changeTimeline, _this, tick.value)\n      };\n      var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);\n      el.ensureState('emphasis').style = hoverStyleModel.getItemStyle();\n      el.ensureState('progress').style = progressStyleModel.getItemStyle();\n      (0,states/* enableHoverEmphasis */.iJ)(el);\n      var ecData = (0,innerStore/* getECData */.z)(el);\n      if (itemModel.get('tooltip')) {\n        ecData.dataIndex = tick.value;\n        ecData.dataModel = timelineModel;\n      } else {\n        ecData.dataIndex = ecData.dataModel = null;\n      }\n      _this._tickSymbols.push(el);\n    });\n  };\n  SliderTimelineView.prototype._renderAxisLabel = function (layoutInfo, group, axis, timelineModel) {\n    var _this = this;\n    var labelModel = axis.getLabelModel();\n    if (!labelModel.get('show')) {\n      return;\n    }\n    var data = timelineModel.getData();\n    var labels = axis.getViewLabels();\n    this._tickLabels = [];\n    (0,util.each)(labels, function (labelItem) {\n      // The tickValue is dataIndex, see the customized scale.\n      var dataIndex = labelItem.tickValue;\n      var itemModel = data.getItemModel(dataIndex);\n      var normalLabelModel = itemModel.getModel('label');\n      var hoverLabelModel = itemModel.getModel(['emphasis', 'label']);\n      var progressLabelModel = itemModel.getModel(['progress', 'label']);\n      var tickCoord = axis.dataToCoord(labelItem.tickValue);\n      var textEl = new Text/* default */.Ay({\n        x: tickCoord,\n        y: 0,\n        rotation: layoutInfo.labelRotation - layoutInfo.rotation,\n        onclick: (0,util.bind)(_this._changeTimeline, _this, dataIndex),\n        silent: false,\n        style: (0,labelStyle/* createTextStyle */.VB)(normalLabelModel, {\n          text: labelItem.formattedLabel,\n          align: layoutInfo.labelAlign,\n          verticalAlign: layoutInfo.labelBaseline\n        })\n      });\n      textEl.ensureState('emphasis').style = (0,labelStyle/* createTextStyle */.VB)(hoverLabelModel);\n      textEl.ensureState('progress').style = (0,labelStyle/* createTextStyle */.VB)(progressLabelModel);\n      group.add(textEl);\n      (0,states/* enableHoverEmphasis */.iJ)(textEl);\n      labelDataIndexStore(textEl).dataIndex = dataIndex;\n      _this._tickLabels.push(textEl);\n    });\n  };\n  SliderTimelineView.prototype._renderControl = function (layoutInfo, group, axis, timelineModel) {\n    var controlSize = layoutInfo.controlSize;\n    var rotation = layoutInfo.rotation;\n    var itemStyle = timelineModel.getModel('controlStyle').getItemStyle();\n    var hoverStyle = timelineModel.getModel(['emphasis', 'controlStyle']).getItemStyle();\n    var playState = timelineModel.getPlayState();\n    var inverse = timelineModel.get('inverse', true);\n    makeBtn(layoutInfo.nextBtnPosition, 'next', (0,util.bind)(this._changeTimeline, this, inverse ? '-' : '+'));\n    makeBtn(layoutInfo.prevBtnPosition, 'prev', (0,util.bind)(this._changeTimeline, this, inverse ? '+' : '-'));\n    makeBtn(layoutInfo.playPosition, playState ? 'stop' : 'play', (0,util.bind)(this._handlePlayClick, this, !playState), true);\n    function makeBtn(position, iconName, onclick, willRotate) {\n      if (!position) {\n        return;\n      }\n      var iconSize = (0,contain_text/* parsePercent */.lo)((0,util.retrieve2)(timelineModel.get(['controlStyle', iconName + 'BtnSize']), controlSize), controlSize);\n      var rect = [0, -iconSize / 2, iconSize, iconSize];\n      var btn = makeControlIcon(timelineModel, iconName + 'Icon', rect, {\n        x: position[0],\n        y: position[1],\n        originX: controlSize / 2,\n        originY: 0,\n        rotation: willRotate ? -rotation : 0,\n        rectHover: true,\n        style: itemStyle,\n        onclick: onclick\n      });\n      btn.ensureState('emphasis').style = hoverStyle;\n      group.add(btn);\n      (0,states/* enableHoverEmphasis */.iJ)(btn);\n    }\n  };\n  SliderTimelineView.prototype._renderCurrentPointer = function (layoutInfo, group, axis, timelineModel) {\n    var data = timelineModel.getData();\n    var currentIndex = timelineModel.getCurrentIndex();\n    var pointerModel = data.getItemModel(currentIndex).getModel('checkpointStyle');\n    var me = this;\n    var callback = {\n      onCreate: function (pointer) {\n        pointer.draggable = true;\n        pointer.drift = (0,util.bind)(me._handlePointerDrag, me);\n        pointer.ondragend = (0,util.bind)(me._handlePointerDragend, me);\n        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel, true);\n      },\n      onUpdate: function (pointer) {\n        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel);\n      }\n    };\n    // Reuse when exists, for animation and drag.\n    this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);\n  };\n  SliderTimelineView.prototype._handlePlayClick = function (nextState) {\n    this._clearTimer();\n    this.api.dispatchAction({\n      type: 'timelinePlayChange',\n      playState: nextState,\n      from: this.uid\n    });\n  };\n  SliderTimelineView.prototype._handlePointerDrag = function (dx, dy, e) {\n    this._clearTimer();\n    this._pointerChangeTimeline([e.offsetX, e.offsetY]);\n  };\n  SliderTimelineView.prototype._handlePointerDragend = function (e) {\n    this._pointerChangeTimeline([e.offsetX, e.offsetY], true);\n  };\n  SliderTimelineView.prototype._pointerChangeTimeline = function (mousePos, trigger) {\n    var toCoord = this._toAxisCoord(mousePos)[0];\n    var axis = this._axis;\n    var axisExtent = number/* asc */.Y6(axis.getExtent().slice());\n    toCoord > axisExtent[1] && (toCoord = axisExtent[1]);\n    toCoord < axisExtent[0] && (toCoord = axisExtent[0]);\n    this._currentPointer.x = toCoord;\n    this._currentPointer.markRedraw();\n    var progressLine = this._progressLine;\n    if (progressLine) {\n      progressLine.shape.x2 = toCoord;\n      progressLine.dirty();\n    }\n    var targetDataIndex = this._findNearestTick(toCoord);\n    var timelineModel = this.model;\n    if (trigger || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get('realtime')) {\n      this._changeTimeline(targetDataIndex);\n    }\n  };\n  SliderTimelineView.prototype._doPlayStop = function () {\n    var _this = this;\n    this._clearTimer();\n    if (this.model.getPlayState()) {\n      this._timer = setTimeout(function () {\n        // Do not cache\n        var timelineModel = _this.model;\n        _this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get('rewind', true) ? -1 : 1));\n      }, this.model.get('playInterval'));\n    }\n  };\n  SliderTimelineView.prototype._toAxisCoord = function (vertex) {\n    var trans = this._mainGroup.getLocalTransform();\n    return graphic.applyTransform(vertex, trans, true);\n  };\n  SliderTimelineView.prototype._findNearestTick = function (axisCoord) {\n    var data = this.model.getData();\n    var dist = Infinity;\n    var targetDataIndex;\n    var axis = this._axis;\n    data.each(['value'], function (value, dataIndex) {\n      var coord = axis.dataToCoord(value);\n      var d = Math.abs(coord - axisCoord);\n      if (d < dist) {\n        dist = d;\n        targetDataIndex = dataIndex;\n      }\n    });\n    return targetDataIndex;\n  };\n  SliderTimelineView.prototype._clearTimer = function () {\n    if (this._timer) {\n      clearTimeout(this._timer);\n      this._timer = null;\n    }\n  };\n  SliderTimelineView.prototype._changeTimeline = function (nextIndex) {\n    var currentIndex = this.model.getCurrentIndex();\n    if (nextIndex === '+') {\n      nextIndex = currentIndex + 1;\n    } else if (nextIndex === '-') {\n      nextIndex = currentIndex - 1;\n    }\n    this.api.dispatchAction({\n      type: 'timelineChange',\n      currentIndex: nextIndex,\n      from: this.uid\n    });\n  };\n  SliderTimelineView.prototype._updateTicksStatus = function () {\n    var currentIndex = this.model.getCurrentIndex();\n    var tickSymbols = this._tickSymbols;\n    var tickLabels = this._tickLabels;\n    if (tickSymbols) {\n      for (var i = 0; i < tickSymbols.length; i++) {\n        tickSymbols && tickSymbols[i] && tickSymbols[i].toggleState('progress', i < currentIndex);\n      }\n    }\n    if (tickLabels) {\n      for (var i = 0; i < tickLabels.length; i++) {\n        tickLabels && tickLabels[i] && tickLabels[i].toggleState('progress', labelDataIndexStore(tickLabels[i]).dataIndex <= currentIndex);\n      }\n    }\n  };\n  SliderTimelineView.type = 'timeline.slider';\n  return SliderTimelineView;\n}(timeline_TimelineView);\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new Ordinal/* default */.A({\n          ordinalMeta: model.getCategories(),\n          extent: [Infinity, -Infinity]\n        });\n      case 'time':\n        return new Time/* default */.A({\n          locale: model.ecModel.getLocaleModel(),\n          useUTC: model.ecModel.get('useUTC')\n        });\n      default:\n        // default to be value\n        return new Interval/* default */.A();\n    }\n  }\n}\nfunction getViewRect(model, api) {\n  return layout/* getLayoutRect */.dV(model.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  }, model.get('padding'));\n}\nfunction makeControlIcon(timelineModel, objPath, rect, opts) {\n  var style = opts.style;\n  var icon = graphic.createIcon(timelineModel.get(['controlStyle', objPath]), opts || {}, new BoundingRect/* default */.A(rect[0], rect[1], rect[2], rect[3]));\n  // TODO createIcon won't use style in opt.\n  if (style) {\n    icon.setStyle(style);\n  }\n  return icon;\n}\n/**\r\n * Create symbol or update symbol\r\n * opt: basic position and event handlers\r\n */\nfunction giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {\n  var color = itemStyleModel.get('color');\n  if (!symbol) {\n    var symbolType = hostModel.get('symbol');\n    symbol = (0,util_symbol/* createSymbol */.v5)(symbolType, -1, -1, 2, 2, color);\n    symbol.setStyle('strokeNoScale', true);\n    group.add(symbol);\n    callback && callback.onCreate(symbol);\n  } else {\n    symbol.setColor(color);\n    group.add(symbol); // Group may be new, also need to add.\n    callback && callback.onUpdate(symbol);\n  }\n  // Style\n  var itemStyle = itemStyleModel.getItemStyle(['color']);\n  symbol.setStyle(itemStyle);\n  // Transform and events.\n  opt = (0,util.merge)({\n    rectHover: true,\n    z2: 100\n  }, opt, true);\n  var symbolSize = (0,util_symbol/* normalizeSymbolSize */.xU)(hostModel.get('symbolSize'));\n  opt.scaleX = symbolSize[0] / 2;\n  opt.scaleY = symbolSize[1] / 2;\n  var symbolOffset = (0,util_symbol/* normalizeSymbolOffset */.hV)(hostModel.get('symbolOffset'), symbolSize);\n  if (symbolOffset) {\n    opt.x = (opt.x || 0) + symbolOffset[0];\n    opt.y = (opt.y || 0) + symbolOffset[1];\n  }\n  var symbolRotate = hostModel.get('symbolRotate');\n  opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n  symbol.attr(opt);\n  // FIXME\n  // (1) When symbol.style.strokeNoScale is true and updateTransform is not performed,\n  // getBoundingRect will return wrong result.\n  // (This is supposed to be resolved in zrender, but it is a little difficult to\n  // leverage performance and auto updateTransform)\n  // (2) All of ancesters of symbol do not scale, so we can just updateTransform symbol.\n  symbol.updateTransform();\n  return symbol;\n}\nfunction pointerMoveTo(pointer, progressLine, dataIndex, axis, timelineModel, noAnimation) {\n  if (pointer.dragging) {\n    return;\n  }\n  var pointerModel = timelineModel.getModel('checkpointStyle');\n  var toCoord = axis.dataToCoord(timelineModel.getData().get('value', dataIndex));\n  if (noAnimation || !pointerModel.get('animation', true)) {\n    pointer.attr({\n      x: toCoord,\n      y: 0\n    });\n    progressLine && progressLine.attr({\n      shape: {\n        x2: toCoord\n      }\n    });\n  } else {\n    var animationCfg = {\n      duration: pointerModel.get('animationDuration', true),\n      easing: pointerModel.get('animationEasing', true)\n    };\n    pointer.stopAnimation(null, true);\n    pointer.animateTo({\n      x: toCoord,\n      y: 0\n    }, animationCfg);\n    progressLine && progressLine.animateTo({\n      shape: {\n        x2: toCoord\n      }\n    }, animationCfg);\n  }\n}\n/* harmony default export */ const timeline_SliderTimelineView = (SliderTimelineView);\n;// ./node_modules/echarts/lib/component/timeline/timelineAction.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction installTimelineAction(registers) {\n  registers.registerAction({\n    type: 'timelineChange',\n    event: 'timelineChanged',\n    update: 'prepareAndUpdate'\n  }, function (payload, ecModel, api) {\n    var timelineModel = ecModel.getComponent('timeline');\n    if (timelineModel && payload.currentIndex != null) {\n      timelineModel.setCurrentIndex(payload.currentIndex);\n      if (!timelineModel.get('loop', true) && timelineModel.isIndexMax() && timelineModel.getPlayState()) {\n        timelineModel.setPlayState(false);\n        // The timeline has played to the end, trigger event\n        api.dispatchAction({\n          type: 'timelinePlayChange',\n          playState: false,\n          from: payload.from\n        });\n      }\n    }\n    // Set normalized currentIndex to payload.\n    ecModel.resetOption('timeline', {\n      replaceMerge: timelineModel.get('replaceMerge', true)\n    });\n    return (0,util.defaults)({\n      currentIndex: timelineModel.option.currentIndex\n    }, payload);\n  });\n  registers.registerAction({\n    type: 'timelinePlayChange',\n    event: 'timelinePlayChanged',\n    update: 'update'\n  }, function (payload, ecModel) {\n    var timelineModel = ecModel.getComponent('timeline');\n    if (timelineModel && payload.playState != null) {\n      timelineModel.setPlayState(payload.playState);\n    }\n  });\n}\n;// ./node_modules/echarts/lib/component/timeline/preprocessor.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// @ts-nocheck\n\nfunction timelinePreprocessor(option) {\n  var timelineOpt = option && option.timeline;\n  if (!util.isArray(timelineOpt)) {\n    timelineOpt = timelineOpt ? [timelineOpt] : [];\n  }\n  util.each(timelineOpt, function (opt) {\n    if (!opt) {\n      return;\n    }\n    compatibleEC2(opt);\n  });\n}\nfunction compatibleEC2(opt) {\n  var type = opt.type;\n  var ec2Types = {\n    'number': 'value',\n    'time': 'time'\n  };\n  // Compatible with ec2\n  if (ec2Types[type]) {\n    opt.axisType = ec2Types[type];\n    delete opt.type;\n  }\n  transferItem(opt);\n  if (has(opt, 'controlPosition')) {\n    var controlStyle = opt.controlStyle || (opt.controlStyle = {});\n    if (!has(controlStyle, 'position')) {\n      controlStyle.position = opt.controlPosition;\n    }\n    if (controlStyle.position === 'none' && !has(controlStyle, 'show')) {\n      controlStyle.show = false;\n      delete controlStyle.position;\n    }\n    delete opt.controlPosition;\n  }\n  util.each(opt.data || [], function (dataItem) {\n    if (util.isObject(dataItem) && !util.isArray(dataItem)) {\n      if (!has(dataItem, 'value') && has(dataItem, 'name')) {\n        // In ec2, using name as value.\n        dataItem.value = dataItem.name;\n      }\n      transferItem(dataItem);\n    }\n  });\n}\nfunction transferItem(opt) {\n  var itemStyle = opt.itemStyle || (opt.itemStyle = {});\n  var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {});\n  // Transfer label out\n  var label = opt.label || opt.label || {};\n  var labelNormal = label.normal || (label.normal = {});\n  var excludeLabelAttr = {\n    normal: 1,\n    emphasis: 1\n  };\n  util.each(label, function (value, name) {\n    if (!excludeLabelAttr[name] && !has(labelNormal, name)) {\n      labelNormal[name] = value;\n    }\n  });\n  if (itemStyleEmphasis.label && !has(label, 'emphasis')) {\n    label.emphasis = itemStyleEmphasis.label;\n    delete itemStyleEmphasis.label;\n  }\n}\nfunction has(obj, attr) {\n  return obj.hasOwnProperty(attr);\n}\n;// ./node_modules/echarts/lib/component/timeline/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\n\n\n\nfunction install(registers) {\n  registers.registerComponentModel(timeline_SliderTimelineModel);\n  registers.registerComponentView(timeline_SliderTimelineView);\n  registers.registerSubTypeDefaulter('timeline', function () {\n    // Only slider now.\n    return 'slider';\n  });\n  installTimelineAction(registers);\n  registers.registerPreprocessor(timelinePreprocessor);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI3NTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdGltZWxpbmUvVGltZWxpbmVNb2RlbC5qcz9jNjM4Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdGltZWxpbmUvU2xpZGVyVGltZWxpbmVNb2RlbC5qcz9iMTRhIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdGltZWxpbmUvVGltZWxpbmVWaWV3LmpzPzkwMzEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90aW1lbGluZS9UaW1lbGluZUF4aXMuanM/OTExOCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3RpbWVsaW5lL1NsaWRlclRpbWVsaW5lVmlldy5qcz8wNjM2Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdGltZWxpbmUvdGltZWxpbmVBY3Rpb24uanM/Y2JlMSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3RpbWVsaW5lL3ByZXByb2Nlc3Nvci5qcz9lNGI1Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdGltZWxpbmUvaW5zdGFsbC5qcz9lYjE3Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50LmpzJztcbmltcG9ydCBTZXJpZXNEYXRhIGZyb20gJy4uLy4uL2RhdGEvU2VyaWVzRGF0YS5qcyc7XG5pbXBvcnQgeyBlYWNoLCBpc09iamVjdCwgY2xvbmUgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgY29udmVydE9wdGlvbklkTmFtZSwgZ2V0RGF0YUl0ZW1WYWx1ZSB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xudmFyIFRpbWVsaW5lTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVGltZWxpbmVNb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gVGltZWxpbmVNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gVGltZWxpbmVNb2RlbC50eXBlO1xuICAgIF90aGlzLmxheW91dE1vZGUgPSAnYm94JztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXG4gIFRpbWVsaW5lTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCkge1xuICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcbiAgICB0aGlzLl9pbml0RGF0YSgpO1xuICB9O1xuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgVGltZWxpbmVNb2RlbC5wcm90b3R5cGUubWVyZ2VPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5tZXJnZU9wdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuX2luaXREYXRhKCk7XG4gIH07XG4gIFRpbWVsaW5lTW9kZWwucHJvdG90eXBlLnNldEN1cnJlbnRJbmRleCA9IGZ1bmN0aW9uIChjdXJyZW50SW5kZXgpIHtcbiAgICBpZiAoY3VycmVudEluZGV4ID09IG51bGwpIHtcbiAgICAgIGN1cnJlbnRJbmRleCA9IHRoaXMub3B0aW9uLmN1cnJlbnRJbmRleDtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gdGhpcy5fZGF0YS5jb3VudCgpO1xuICAgIGlmICh0aGlzLm9wdGlvbi5sb29wKSB7XG4gICAgICBjdXJyZW50SW5kZXggPSAoY3VycmVudEluZGV4ICUgY291bnQgKyBjb3VudCkgJSBjb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudEluZGV4ID49IGNvdW50ICYmIChjdXJyZW50SW5kZXggPSBjb3VudCAtIDEpO1xuICAgICAgY3VycmVudEluZGV4IDwgMCAmJiAoY3VycmVudEluZGV4ID0gMCk7XG4gICAgfVxuICAgIHRoaXMub3B0aW9uLmN1cnJlbnRJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBjdXJyZW50SW5kZXhcclxuICAgKi9cbiAgVGltZWxpbmVNb2RlbC5wcm90b3R5cGUuZ2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbi5jdXJyZW50SW5kZXg7XG4gIH07XG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXG4gIFRpbWVsaW5lTW9kZWwucHJvdG90eXBlLmlzSW5kZXhNYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudEluZGV4KCkgPj0gdGhpcy5fZGF0YS5jb3VudCgpIC0gMTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSB0cnVlOiBwbGF5LCBmYWxzZTogc3RvcFxyXG4gICAqL1xuICBUaW1lbGluZU1vZGVsLnByb3RvdHlwZS5zZXRQbGF5U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB0aGlzLm9wdGlvbi5hdXRvUGxheSA9ICEhc3RhdGU7XG4gIH07XG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWU6IHBsYXksIGZhbHNlOiBzdG9wXHJcbiAgICovXG4gIFRpbWVsaW5lTW9kZWwucHJvdG90eXBlLmdldFBsYXlTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLm9wdGlvbi5hdXRvUGxheTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgVGltZWxpbmVNb2RlbC5wcm90b3R5cGUuX2luaXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIGRhdGFBcnIgPSB0aGlzT3B0aW9uLmRhdGEgfHwgW107XG4gICAgdmFyIGF4aXNUeXBlID0gdGhpc09wdGlvbi5heGlzVHlwZTtcbiAgICB2YXIgbmFtZXMgPSB0aGlzLl9uYW1lcyA9IFtdO1xuICAgIHZhciBwcm9jZXNzZWREYXRhQXJyO1xuICAgIGlmIChheGlzVHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgcHJvY2Vzc2VkRGF0YUFyciA9IFtdO1xuICAgICAgZWFjaChkYXRhQXJyLCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gY29udmVydE9wdGlvbklkTmFtZShnZXREYXRhSXRlbVZhbHVlKGl0ZW0pLCAnJyk7XG4gICAgICAgIHZhciBuZXdJdGVtO1xuICAgICAgICBpZiAoaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICBuZXdJdGVtID0gY2xvbmUoaXRlbSk7XG4gICAgICAgICAgbmV3SXRlbS52YWx1ZSA9IGluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0l0ZW0gPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzZWREYXRhQXJyLnB1c2gobmV3SXRlbSk7XG4gICAgICAgIG5hbWVzLnB1c2godmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3NlZERhdGFBcnIgPSBkYXRhQXJyO1xuICAgIH1cbiAgICB2YXIgZGltVHlwZSA9IHtcbiAgICAgIGNhdGVnb3J5OiAnb3JkaW5hbCcsXG4gICAgICB0aW1lOiAndGltZScsXG4gICAgICB2YWx1ZTogJ251bWJlcidcbiAgICB9W2F4aXNUeXBlXSB8fCAnbnVtYmVyJztcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEgPSBuZXcgU2VyaWVzRGF0YShbe1xuICAgICAgbmFtZTogJ3ZhbHVlJyxcbiAgICAgIHR5cGU6IGRpbVR5cGVcbiAgICB9XSwgdGhpcyk7XG4gICAgZGF0YS5pbml0RGF0YShwcm9jZXNzZWREYXRhQXJyLCBuYW1lcyk7XG4gIH07XG4gIFRpbWVsaW5lTW9kZWwucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gY2F0ZWdvcmVpc1xyXG4gICAqL1xuICBUaW1lbGluZU1vZGVsLnByb3RvdHlwZS5nZXRDYXRlZ29yaWVzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmdldCgnYXhpc1R5cGUnKSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWVzLnNsaWNlKCk7XG4gICAgfVxuICB9O1xuICBUaW1lbGluZU1vZGVsLnR5cGUgPSAndGltZWxpbmUnO1xuICAvKipcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXG4gIFRpbWVsaW5lTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAvLyB6bGV2ZWw6IDAsICAgICAgICAgICAgICAgICAgLy8g5LiA57qn5bGC5Y+gXG4gICAgejogNCxcbiAgICBzaG93OiB0cnVlLFxuICAgIGF4aXNUeXBlOiAndGltZScsXG4gICAgcmVhbHRpbWU6IHRydWUsXG4gICAgbGVmdDogJzIwJScsXG4gICAgdG9wOiBudWxsLFxuICAgIHJpZ2h0OiAnMjAlJyxcbiAgICBib3R0b206IDAsXG4gICAgd2lkdGg6IG51bGwsXG4gICAgaGVpZ2h0OiA0MCxcbiAgICBwYWRkaW5nOiA1LFxuICAgIGNvbnRyb2xQb3NpdGlvbjogJ2xlZnQnLFxuICAgIGF1dG9QbGF5OiBmYWxzZSxcbiAgICByZXdpbmQ6IGZhbHNlLFxuICAgIGxvb3A6IHRydWUsXG4gICAgcGxheUludGVydmFsOiAyMDAwLFxuICAgIGN1cnJlbnRJbmRleDogMCxcbiAgICBpdGVtU3R5bGU6IHt9LFxuICAgIGxhYmVsOiB7XG4gICAgICBjb2xvcjogJyMwMDAnXG4gICAgfSxcbiAgICBkYXRhOiBbXVxuICB9O1xuICByZXR1cm4gVGltZWxpbmVNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuZXhwb3J0IGRlZmF1bHQgVGltZWxpbmVNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFRpbWVsaW5lTW9kZWwgZnJvbSAnLi9UaW1lbGluZU1vZGVsLmpzJztcbmltcG9ydCB7IERhdGFGb3JtYXRNaXhpbiB9IGZyb20gJy4uLy4uL21vZGVsL21peGluL2RhdGFGb3JtYXQuanMnO1xuaW1wb3J0IHsgbWl4aW4gfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgaW5oZXJpdERlZmF1bHRPcHRpb24gfSBmcm9tICcuLi8uLi91dGlsL2NvbXBvbmVudC5qcyc7XG52YXIgU2xpZGVyVGltZWxpbmVNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTbGlkZXJUaW1lbGluZU1vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBTbGlkZXJUaW1lbGluZU1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBTbGlkZXJUaW1lbGluZU1vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFNsaWRlclRpbWVsaW5lTW9kZWwudHlwZSA9ICd0aW1lbGluZS5zbGlkZXInO1xuICAvKipcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXG4gIFNsaWRlclRpbWVsaW5lTW9kZWwuZGVmYXVsdE9wdGlvbiA9IGluaGVyaXREZWZhdWx0T3B0aW9uKFRpbWVsaW5lTW9kZWwuZGVmYXVsdE9wdGlvbiwge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgb3JpZW50OiAnaG9yaXpvbnRhbCcsXG4gICAgaW52ZXJzZTogZmFsc2UsXG4gICAgdG9vbHRpcDoge1xuICAgICAgdHJpZ2dlcjogJ2l0ZW0nIC8vIGRhdGEgaXRlbSBtYXkgYWxzbyBoYXZlIHRvb3RpcCBhdHRyLlxuICAgIH0sXG4gICAgc3ltYm9sOiAnY2lyY2xlJyxcbiAgICBzeW1ib2xTaXplOiAxMixcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICB3aWR0aDogMixcbiAgICAgIGNvbG9yOiAnI0RBRTFGNSdcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBwb3NpdGlvbjogJ2F1dG8nLFxuICAgICAgLy8gV2hlbiB1c2luZyBudW1iZXIsIGxhYmVsIHBvc2l0aW9uIGlzIG5vdFxuICAgICAgLy8gcmVzdHJpY3RlZCBieSB2aWV3UmVjdC5cbiAgICAgIC8vIHBvc2l0aXZlOiByaWdodC9ib3R0b20sIG5lZ2F0aXZlOiBsZWZ0L3RvcFxuICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgIGludGVydmFsOiAnYXV0bycsXG4gICAgICByb3RhdGU6IDAsXG4gICAgICAvLyBmb3JtYXR0ZXI6IG51bGwsXG4gICAgICAvLyDlhbbkvZnlsZ7mgKfpu5jorqTkvb/nlKjlhajlsYDmlofmnKzmoLflvI/vvIzor6bop4FURVhUU1RZTEVcbiAgICAgIGNvbG9yOiAnI0E0QjFENydcbiAgICB9LFxuICAgIGl0ZW1TdHlsZToge1xuICAgICAgY29sb3I6ICcjQTRCMUQ3JyxcbiAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgfSxcbiAgICBjaGVja3BvaW50U3R5bGU6IHtcbiAgICAgIHN5bWJvbDogJ2NpcmNsZScsXG4gICAgICBzeW1ib2xTaXplOiAxNSxcbiAgICAgIGNvbG9yOiAnIzMxNmJmMycsXG4gICAgICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICBzaGFkb3dCbHVyOiAyLFxuICAgICAgc2hhZG93T2Zmc2V0WDogMSxcbiAgICAgIHNoYWRvd09mZnNldFk6IDEsXG4gICAgICBzaGFkb3dDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4zKScsXG4gICAgICAvLyBib3JkZXJDb2xvcjogJ3JnYmEoMTk0LDUzLDQ5LCAwLjUpJyxcbiAgICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAzMDAsXG4gICAgICBhbmltYXRpb25FYXNpbmc6ICdxdWludGljSW5PdXQnXG4gICAgfSxcbiAgICBjb250cm9sU3R5bGU6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBzaG93UGxheUJ0bjogdHJ1ZSxcbiAgICAgIHNob3dQcmV2QnRuOiB0cnVlLFxuICAgICAgc2hvd05leHRCdG46IHRydWUsXG4gICAgICBpdGVtU2l6ZTogMjQsXG4gICAgICBpdGVtR2FwOiAxMixcbiAgICAgIHBvc2l0aW9uOiAnbGVmdCcsXG4gICAgICBwbGF5SWNvbjogJ3BhdGg6Ly9NMzEuNiw1M0MxNy41LDUzLDYsNDEuNSw2LDI3LjRTMTcuNSwxLjgsMzEuNiwxLjhDNDUuNywxLjgsNTcuMiwxMy4zLDU3LjIsMjcuNFM0NS43LDUzLDMxLjYsNTN6IE0zMS42LDMuMyBDMTguNCwzLjMsNy41LDE0LjEsNy41LDI3LjRjMCwxMy4zLDEwLjgsMjQuMSwyNC4xLDI0LjFDNDQuOSw1MS41LDU1LjcsNDAuNyw1NS43LDI3LjRDNTUuNywxNC4xLDQ0LjksMy4zLDMxLjYsMy4zeiBNMjQuOSwyMS4zIGMwLTIuMiwxLjYtMy4xLDMuNS0ybDEwLjUsNi4xYzEuODk5LDEuMSwxLjg5OSwyLjksMCw0bC0xMC41LDYuMWMtMS45LDEuMS0zLjUsMC4yLTMuNS0yVjIxLjN6JyxcbiAgICAgIHN0b3BJY29uOiAncGF0aDovL00zMC45LDUzLjJDMTYuOCw1My4yLDUuMyw0MS43LDUuMywyNy42UzE2LjgsMiwzMC45LDJDNDUsMiw1Ni40LDEzLjUsNTYuNCwyNy42UzQ1LDUzLjIsMzAuOSw1My4yeiBNMzAuOSwzLjVDMTcuNiwzLjUsNi44LDE0LjQsNi44LDI3LjZjMCwxMy4zLDEwLjgsMjQuMSwyNC4xMDEsMjQuMUM0NC4yLDUxLjcsNTUsNDAuOSw1NSwyNy42QzU0LjksMTQuNCw0NC4xLDMuNSwzMC45LDMuNXogTTM2LjksMzUuOGMwLDAuNjAxLTAuNCwxLTAuOSwxaC0xLjNjLTAuNSwwLTAuOS0wLjM5OS0wLjktMVYxOS41YzAtMC42LDAuNC0xLDAuOS0xSDM2YzAuNSwwLDAuOSwwLjQsMC45LDFWMzUuOHogTTI3LjgsMzUuOCBjMCwwLjYwMS0wLjQsMS0wLjksMWgtMS4zYy0wLjUsMC0wLjktMC4zOTktMC45LTFWMTkuNWMwLTAuNiwwLjQtMSwwLjktMUgyN2MwLjUsMCwwLjksMC40LDAuOSwxTDI3LjgsMzUuOEwyNy44LDM1Ljh6JyxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICBuZXh0SWNvbjogJ00yLDE4LjVBMS41MiwxLjUyLDAsMCwxLC45MiwxOGExLjQ5LDEuNDksMCwwLDEsMC0yLjEyTDcuODEsOS4zNiwxLDMuMTFBMS41LDEuNSwwLDEsMSwzLC44OWw4LDcuMzRhMS40OCwxLjQ4LDAsMCwxLC40OSwxLjA5LDEuNTEsMS41MSwwLDAsMS0uNDYsMS4xTDMsMTguMDhBMS41LDEuNSwwLDAsMSwyLDE4LjVaJyxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICBwcmV2SWNvbjogJ00xMCwuNUExLjUyLDEuNTIsMCwwLDEsMTEuMDgsMWExLjQ5LDEuNDksMCwwLDEsMCwyLjEyTDQuMTksOS42NCwxMSwxNS44OWExLjUsMS41LDAsMSwxLTIsMi4yMkwxLDEwLjc3QTEuNDgsMS40OCwwLDAsMSwuNSw5LjY4LDEuNTEsMS41MSwwLDAsMSwxLDguNThMOSwuOTJBMS41LDEuNSwwLDAsMSwxMCwuNVonLFxuICAgICAgcHJldkJ0blNpemU6IDE4LFxuICAgICAgbmV4dEJ0blNpemU6IDE4LFxuICAgICAgY29sb3I6ICcjQTRCMUQ3JyxcbiAgICAgIGJvcmRlckNvbG9yOiAnI0E0QjFENycsXG4gICAgICBib3JkZXJXaWR0aDogMVxuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIC8vIOWFtuS9meWxnuaAp+m7mOiupOS9v+eUqOWFqOWxgOaWh+acrOagt+W8j++8jOivpuingVRFWFRTVFlMRVxuICAgICAgICBjb2xvcjogJyM2Zjc3OGQnXG4gICAgICB9LFxuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzMxNkJGMydcbiAgICAgIH0sXG4gICAgICBjb250cm9sU3R5bGU6IHtcbiAgICAgICAgY29sb3I6ICcjMzE2QkYzJyxcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMzE2QkYzJyxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDJcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb2dyZXNzOiB7XG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgY29sb3I6ICcjMzE2QkYzJ1xuICAgICAgfSxcbiAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICBjb2xvcjogJyMzMTZCRjMnXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgY29sb3I6ICcjNmY3NzhkJ1xuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogW11cbiAgfSk7XG4gIHJldHVybiBTbGlkZXJUaW1lbGluZU1vZGVsO1xufShUaW1lbGluZU1vZGVsKTtcbm1peGluKFNsaWRlclRpbWVsaW5lTW9kZWwsIERhdGFGb3JtYXRNaXhpbi5wcm90b3R5cGUpO1xuZXhwb3J0IGRlZmF1bHQgU2xpZGVyVGltZWxpbmVNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IENvbXBvbmVudFZpZXcgZnJvbSAnLi4vLi4vdmlldy9Db21wb25lbnQuanMnO1xudmFyIFRpbWVsaW5lVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUaW1lbGluZVZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFRpbWVsaW5lVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gVGltZWxpbmVWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFRpbWVsaW5lVmlldy50eXBlID0gJ3RpbWVsaW5lJztcbiAgcmV0dXJuIFRpbWVsaW5lVmlldztcbn0oQ29tcG9uZW50Vmlldyk7XG5leHBvcnQgZGVmYXVsdCBUaW1lbGluZVZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBBeGlzIGZyb20gJy4uLy4uL2Nvb3JkL0F4aXMuanMnO1xuLyoqXHJcbiAqIEV4dGVuZCBheGlzIDJkXHJcbiAqL1xudmFyIFRpbWVsaW5lQXhpcyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUaW1lbGluZUF4aXMsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFRpbWVsaW5lQXhpcyhkaW0sIHNjYWxlLCBjb29yZEV4dGVudCwgYXhpc1R5cGUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkaW0sIHNjYWxlLCBjb29yZEV4dGVudCkgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gYXhpc1R5cGUgfHwgJ3ZhbHVlJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXG4gIFRpbWVsaW5lQXhpcy5wcm90b3R5cGUuZ2V0TGFiZWxNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBGb3JjZSBvdmVycmlkZVxuICAgIHJldHVybiB0aGlzLm1vZGVsLmdldE1vZGVsKCdsYWJlbCcpO1xuICB9O1xuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgVGltZWxpbmVBeGlzLnByb3RvdHlwZS5pc0hvcml6b250YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWwuZ2V0KCdvcmllbnQnKSA9PT0gJ2hvcml6b250YWwnO1xuICB9O1xuICByZXR1cm4gVGltZWxpbmVBeGlzO1xufShBeGlzKTtcbmV4cG9ydCBkZWZhdWx0IFRpbWVsaW5lQXhpczsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IEJvdW5kaW5nUmVjdCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcyc7XG5pbXBvcnQgKiBhcyBtYXRyaXggZnJvbSAnenJlbmRlci9saWIvY29yZS9tYXRyaXguanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IHsgY3JlYXRlVGV4dFN0eWxlIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG5pbXBvcnQgKiBhcyBsYXlvdXQgZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQuanMnO1xuaW1wb3J0IFRpbWVsaW5lVmlldyBmcm9tICcuL1RpbWVsaW5lVmlldy5qcyc7XG5pbXBvcnQgVGltZWxpbmVBeGlzIGZyb20gJy4vVGltZWxpbmVBeGlzLmpzJztcbmltcG9ydCB7IGNyZWF0ZVN5bWJvbCwgbm9ybWFsaXplU3ltYm9sT2Zmc2V0LCBub3JtYWxpemVTeW1ib2xTaXplIH0gZnJvbSAnLi4vLi4vdXRpbC9zeW1ib2wuanMnO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7XG5pbXBvcnQgeyBtZXJnZSwgZWFjaCwgZXh0ZW5kLCBpc1N0cmluZywgYmluZCwgZGVmYXVsdHMsIHJldHJpZXZlMiB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgT3JkaW5hbFNjYWxlIGZyb20gJy4uLy4uL3NjYWxlL09yZGluYWwuanMnO1xuaW1wb3J0IFRpbWVTY2FsZSBmcm9tICcuLi8uLi9zY2FsZS9UaW1lLmpzJztcbmltcG9ydCBJbnRlcnZhbFNjYWxlIGZyb20gJy4uLy4uL3NjYWxlL0ludGVydmFsLmpzJztcbmltcG9ydCB7IHBhcnNlUGVyY2VudCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcyc7XG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZS5qcyc7XG5pbXBvcnQgeyBlbmFibGVIb3ZlckVtcGhhc2lzIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMuanMnO1xuaW1wb3J0IHsgY3JlYXRlVG9vbHRpcE1hcmt1cCB9IGZyb20gJy4uL3Rvb2x0aXAvdG9vbHRpcE1hcmt1cC5qcyc7XG52YXIgUEkgPSBNYXRoLlBJO1xudmFyIGxhYmVsRGF0YUluZGV4U3RvcmUgPSBtYWtlSW5uZXIoKTtcbnZhciBTbGlkZXJUaW1lbGluZVZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2xpZGVyVGltZWxpbmVWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBTbGlkZXJUaW1lbGluZVZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IFNsaWRlclRpbWVsaW5lVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5hcGkgPSBhcGk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICh0aW1lbGluZU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLm1vZGVsID0gdGltZWxpbmVNb2RlbDtcbiAgICB0aGlzLmFwaSA9IGFwaTtcbiAgICB0aGlzLmVjTW9kZWwgPSBlY01vZGVsO1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgaWYgKHRpbWVsaW5lTW9kZWwuZ2V0KCdzaG93JywgdHJ1ZSkpIHtcbiAgICAgIHZhciBsYXlvdXRJbmZvXzEgPSB0aGlzLl9sYXlvdXQodGltZWxpbmVNb2RlbCwgYXBpKTtcbiAgICAgIHZhciBtYWluR3JvdXBfMSA9IHRoaXMuX2NyZWF0ZUdyb3VwKCdfbWFpbkdyb3VwJyk7XG4gICAgICB2YXIgbGFiZWxHcm91cCA9IHRoaXMuX2NyZWF0ZUdyb3VwKCdfbGFiZWxHcm91cCcpO1xuICAgICAgdmFyIGF4aXNfMSA9IHRoaXMuX2F4aXMgPSB0aGlzLl9jcmVhdGVBeGlzKGxheW91dEluZm9fMSwgdGltZWxpbmVNb2RlbCk7XG4gICAgICB0aW1lbGluZU1vZGVsLmZvcm1hdFRvb2x0aXAgPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgIHZhciBuYW1lID0gYXhpc18xLnNjYWxlLmdldExhYmVsKHtcbiAgICAgICAgICB2YWx1ZTogZGF0YUluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlVG9vbHRpcE1hcmt1cCgnbmFtZVZhbHVlJywge1xuICAgICAgICAgIG5vTmFtZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogbmFtZVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBlYWNoKFsnQXhpc0xpbmUnLCAnQXhpc1RpY2snLCAnQ29udHJvbCcsICdDdXJyZW50UG9pbnRlciddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzWydfcmVuZGVyJyArIG5hbWVdKGxheW91dEluZm9fMSwgbWFpbkdyb3VwXzEsIGF4aXNfMSwgdGltZWxpbmVNb2RlbCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMuX3JlbmRlckF4aXNMYWJlbChsYXlvdXRJbmZvXzEsIGxhYmVsR3JvdXAsIGF4aXNfMSwgdGltZWxpbmVNb2RlbCk7XG4gICAgICB0aGlzLl9wb3NpdGlvbihsYXlvdXRJbmZvXzEsIHRpbWVsaW5lTW9kZWwpO1xuICAgIH1cbiAgICB0aGlzLl9kb1BsYXlTdG9wKCk7XG4gICAgdGhpcy5fdXBkYXRlVGlja3NTdGF0dXMoKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXG4gIFNsaWRlclRpbWVsaW5lVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NsZWFyVGltZXIoKTtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICB9O1xuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NsZWFyVGltZXIoKTtcbiAgfTtcbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5fbGF5b3V0ID0gZnVuY3Rpb24gKHRpbWVsaW5lTW9kZWwsIGFwaSkge1xuICAgIHZhciBsYWJlbFBvc09wdCA9IHRpbWVsaW5lTW9kZWwuZ2V0KFsnbGFiZWwnLCAncG9zaXRpb24nXSk7XG4gICAgdmFyIG9yaWVudCA9IHRpbWVsaW5lTW9kZWwuZ2V0KCdvcmllbnQnKTtcbiAgICB2YXIgdmlld1JlY3QgPSBnZXRWaWV3UmVjdCh0aW1lbGluZU1vZGVsLCBhcGkpO1xuICAgIHZhciBwYXJzZWRMYWJlbFBvcztcbiAgICAvLyBBdXRvIGxhYmVsIG9mZnNldC5cbiAgICBpZiAobGFiZWxQb3NPcHQgPT0gbnVsbCB8fCBsYWJlbFBvc09wdCA9PT0gJ2F1dG8nKSB7XG4gICAgICBwYXJzZWRMYWJlbFBvcyA9IG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gdmlld1JlY3QueSArIHZpZXdSZWN0LmhlaWdodCAvIDIgPCBhcGkuZ2V0SGVpZ2h0KCkgLyAyID8gJy0nIDogJysnIDogdmlld1JlY3QueCArIHZpZXdSZWN0LndpZHRoIC8gMiA8IGFwaS5nZXRXaWR0aCgpIC8gMiA/ICcrJyA6ICctJztcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGxhYmVsUG9zT3B0KSkge1xuICAgICAgcGFyc2VkTGFiZWxQb3MgPSB7XG4gICAgICAgIGhvcml6b250YWw6IHtcbiAgICAgICAgICB0b3A6ICctJyxcbiAgICAgICAgICBib3R0b206ICcrJ1xuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbDoge1xuICAgICAgICAgIGxlZnQ6ICctJyxcbiAgICAgICAgICByaWdodDogJysnXG4gICAgICAgIH1cbiAgICAgIH1bb3JpZW50XVtsYWJlbFBvc09wdF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlzIG51bWJlclxuICAgICAgcGFyc2VkTGFiZWxQb3MgPSBsYWJlbFBvc09wdDtcbiAgICB9XG4gICAgdmFyIGxhYmVsQWxpZ25NYXAgPSB7XG4gICAgICBob3Jpem9udGFsOiAnY2VudGVyJyxcbiAgICAgIHZlcnRpY2FsOiBwYXJzZWRMYWJlbFBvcyA+PSAwIHx8IHBhcnNlZExhYmVsUG9zID09PSAnKycgPyAnbGVmdCcgOiAncmlnaHQnXG4gICAgfTtcbiAgICB2YXIgbGFiZWxCYXNlbGluZU1hcCA9IHtcbiAgICAgIGhvcml6b250YWw6IHBhcnNlZExhYmVsUG9zID49IDAgfHwgcGFyc2VkTGFiZWxQb3MgPT09ICcrJyA/ICd0b3AnIDogJ2JvdHRvbScsXG4gICAgICB2ZXJ0aWNhbDogJ21pZGRsZSdcbiAgICB9O1xuICAgIHZhciByb3RhdGlvbk1hcCA9IHtcbiAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICB2ZXJ0aWNhbDogUEkgLyAyXG4gICAgfTtcbiAgICAvLyBQb3NpdGlvblxuICAgIHZhciBtYWluTGVuZ3RoID0gb3JpZW50ID09PSAndmVydGljYWwnID8gdmlld1JlY3QuaGVpZ2h0IDogdmlld1JlY3Qud2lkdGg7XG4gICAgdmFyIGNvbnRyb2xNb2RlbCA9IHRpbWVsaW5lTW9kZWwuZ2V0TW9kZWwoJ2NvbnRyb2xTdHlsZScpO1xuICAgIHZhciBzaG93Q29udHJvbCA9IGNvbnRyb2xNb2RlbC5nZXQoJ3Nob3cnLCB0cnVlKTtcbiAgICB2YXIgY29udHJvbFNpemUgPSBzaG93Q29udHJvbCA/IGNvbnRyb2xNb2RlbC5nZXQoJ2l0ZW1TaXplJykgOiAwO1xuICAgIHZhciBjb250cm9sR2FwID0gc2hvd0NvbnRyb2wgPyBjb250cm9sTW9kZWwuZ2V0KCdpdGVtR2FwJykgOiAwO1xuICAgIHZhciBzaXplUGx1c0dhcCA9IGNvbnRyb2xTaXplICsgY29udHJvbEdhcDtcbiAgICAvLyBTcGVjaWFsIGxhYmVsIHJvdGF0ZS5cbiAgICB2YXIgbGFiZWxSb3RhdGlvbiA9IHRpbWVsaW5lTW9kZWwuZ2V0KFsnbGFiZWwnLCAncm90YXRlJ10pIHx8IDA7XG4gICAgbGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb24gKiBQSSAvIDE4MDsgLy8gVG8gcmFkaWFuLlxuICAgIHZhciBwbGF5UG9zaXRpb247XG4gICAgdmFyIHByZXZCdG5Qb3NpdGlvbjtcbiAgICB2YXIgbmV4dEJ0blBvc2l0aW9uO1xuICAgIHZhciBjb250cm9sUG9zaXRpb24gPSBjb250cm9sTW9kZWwuZ2V0KCdwb3NpdGlvbicsIHRydWUpO1xuICAgIHZhciBzaG93UGxheUJ0biA9IHNob3dDb250cm9sICYmIGNvbnRyb2xNb2RlbC5nZXQoJ3Nob3dQbGF5QnRuJywgdHJ1ZSk7XG4gICAgdmFyIHNob3dQcmV2QnRuID0gc2hvd0NvbnRyb2wgJiYgY29udHJvbE1vZGVsLmdldCgnc2hvd1ByZXZCdG4nLCB0cnVlKTtcbiAgICB2YXIgc2hvd05leHRCdG4gPSBzaG93Q29udHJvbCAmJiBjb250cm9sTW9kZWwuZ2V0KCdzaG93TmV4dEJ0bicsIHRydWUpO1xuICAgIHZhciB4TGVmdCA9IDA7XG4gICAgdmFyIHhSaWdodCA9IG1haW5MZW5ndGg7XG4gICAgLy8gcG9zaXRpb25bMF0gbWVhbnMgbGVmdCwgcG9zaXRpb25bMV0gbWVhbnMgbWlkZGxlLlxuICAgIGlmIChjb250cm9sUG9zaXRpb24gPT09ICdsZWZ0JyB8fCBjb250cm9sUG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICBzaG93UGxheUJ0biAmJiAocGxheVBvc2l0aW9uID0gWzAsIDBdLCB4TGVmdCArPSBzaXplUGx1c0dhcCk7XG4gICAgICBzaG93UHJldkJ0biAmJiAocHJldkJ0blBvc2l0aW9uID0gW3hMZWZ0LCAwXSwgeExlZnQgKz0gc2l6ZVBsdXNHYXApO1xuICAgICAgc2hvd05leHRCdG4gJiYgKG5leHRCdG5Qb3NpdGlvbiA9IFt4UmlnaHQgLSBjb250cm9sU2l6ZSwgMF0sIHhSaWdodCAtPSBzaXplUGx1c0dhcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICd0b3AnICdyaWdodCdcbiAgICAgIHNob3dQbGF5QnRuICYmIChwbGF5UG9zaXRpb24gPSBbeFJpZ2h0IC0gY29udHJvbFNpemUsIDBdLCB4UmlnaHQgLT0gc2l6ZVBsdXNHYXApO1xuICAgICAgc2hvd1ByZXZCdG4gJiYgKHByZXZCdG5Qb3NpdGlvbiA9IFswLCAwXSwgeExlZnQgKz0gc2l6ZVBsdXNHYXApO1xuICAgICAgc2hvd05leHRCdG4gJiYgKG5leHRCdG5Qb3NpdGlvbiA9IFt4UmlnaHQgLSBjb250cm9sU2l6ZSwgMF0sIHhSaWdodCAtPSBzaXplUGx1c0dhcCk7XG4gICAgfVxuICAgIHZhciBheGlzRXh0ZW50ID0gW3hMZWZ0LCB4UmlnaHRdO1xuICAgIGlmICh0aW1lbGluZU1vZGVsLmdldCgnaW52ZXJzZScpKSB7XG4gICAgICBheGlzRXh0ZW50LnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZXdSZWN0OiB2aWV3UmVjdCxcbiAgICAgIG1haW5MZW5ndGg6IG1haW5MZW5ndGgsXG4gICAgICBvcmllbnQ6IG9yaWVudCxcbiAgICAgIHJvdGF0aW9uOiByb3RhdGlvbk1hcFtvcmllbnRdLFxuICAgICAgbGFiZWxSb3RhdGlvbjogbGFiZWxSb3RhdGlvbixcbiAgICAgIGxhYmVsUG9zT3B0OiBwYXJzZWRMYWJlbFBvcyxcbiAgICAgIGxhYmVsQWxpZ246IHRpbWVsaW5lTW9kZWwuZ2V0KFsnbGFiZWwnLCAnYWxpZ24nXSkgfHwgbGFiZWxBbGlnbk1hcFtvcmllbnRdLFxuICAgICAgbGFiZWxCYXNlbGluZTogdGltZWxpbmVNb2RlbC5nZXQoWydsYWJlbCcsICd2ZXJ0aWNhbEFsaWduJ10pIHx8IHRpbWVsaW5lTW9kZWwuZ2V0KFsnbGFiZWwnLCAnYmFzZWxpbmUnXSkgfHwgbGFiZWxCYXNlbGluZU1hcFtvcmllbnRdLFxuICAgICAgLy8gQmFzZWQgb24gbWFpbkdyb3VwLlxuICAgICAgcGxheVBvc2l0aW9uOiBwbGF5UG9zaXRpb24sXG4gICAgICBwcmV2QnRuUG9zaXRpb246IHByZXZCdG5Qb3NpdGlvbixcbiAgICAgIG5leHRCdG5Qb3NpdGlvbjogbmV4dEJ0blBvc2l0aW9uLFxuICAgICAgYXhpc0V4dGVudDogYXhpc0V4dGVudCxcbiAgICAgIGNvbnRyb2xTaXplOiBjb250cm9sU2l6ZSxcbiAgICAgIGNvbnRyb2xHYXA6IGNvbnRyb2xHYXBcbiAgICB9O1xuICB9O1xuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLl9wb3NpdGlvbiA9IGZ1bmN0aW9uIChsYXlvdXRJbmZvLCB0aW1lbGluZU1vZGVsKSB7XG4gICAgLy8gUG9zaXRpb24gaXMgYmUgY2FsbGVkIGZpbmFsbHksIGJlY2F1c2UgYm91bmRpbmcgcmVjdCBpcyBuZWVkZWQgZm9yXG4gICAgLy8gYWRhcHQgY29udGVudCB0byBmaWxsIHZpZXdSZWN0IChhdXRvIGFkYXB0IG9mZnNldCkuXG4gICAgLy8gVGltZWxpbmUgbWF5IGJlIG5vdCBhbGwgaW4gdGhlIHZpZXdSZWN0IHdoZW4gJ29mZnNldCcgaXMgc3BlY2lmaWVkXG4gICAgLy8gYXMgYSBudW1iZXIsIGJlY2F1c2UgaXQgaXMgbW9yZSBhcHByb3ByaWF0ZSB0aGF0IGxhYmVsIGFsaWducyBhdFxuICAgIC8vICdvZmZzZXQnIGJ1dCBub3QgdGhlIG90aGVyIGVkZ2UgZGVmaW5lZCBieSB2aWV3UmVjdC5cbiAgICB2YXIgbWFpbkdyb3VwID0gdGhpcy5fbWFpbkdyb3VwO1xuICAgIHZhciBsYWJlbEdyb3VwID0gdGhpcy5fbGFiZWxHcm91cDtcbiAgICB2YXIgdmlld1JlY3QgPSBsYXlvdXRJbmZvLnZpZXdSZWN0O1xuICAgIGlmIChsYXlvdXRJbmZvLm9yaWVudCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgLy8gdHJhbnNmb3JtIHRvIGhvcml6b250YWwsIGludmVyc2Ugcm90YXRlIGJ5IGxlZnQtdG9wIHBvaW50LlxuICAgICAgdmFyIG0gPSBtYXRyaXguY3JlYXRlKCk7XG4gICAgICB2YXIgcm90YXRlT3JpZ2luWCA9IHZpZXdSZWN0Lng7XG4gICAgICB2YXIgcm90YXRlT3JpZ2luWSA9IHZpZXdSZWN0LnkgKyB2aWV3UmVjdC5oZWlnaHQ7XG4gICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstcm90YXRlT3JpZ2luWCwgLXJvdGF0ZU9yaWdpblldKTtcbiAgICAgIG1hdHJpeC5yb3RhdGUobSwgbSwgLVBJIC8gMik7XG4gICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFtyb3RhdGVPcmlnaW5YLCByb3RhdGVPcmlnaW5ZXSk7XG4gICAgICB2aWV3UmVjdCA9IHZpZXdSZWN0LmNsb25lKCk7XG4gICAgICB2aWV3UmVjdC5hcHBseVRyYW5zZm9ybShtKTtcbiAgICB9XG4gICAgdmFyIHZpZXdCb3VuZCA9IGdldEJvdW5kKHZpZXdSZWN0KTtcbiAgICB2YXIgbWFpbkJvdW5kID0gZ2V0Qm91bmQobWFpbkdyb3VwLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICB2YXIgbGFiZWxCb3VuZCA9IGdldEJvdW5kKGxhYmVsR3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgIHZhciBtYWluUG9zaXRpb24gPSBbbWFpbkdyb3VwLngsIG1haW5Hcm91cC55XTtcbiAgICB2YXIgbGFiZWxzUG9zaXRpb24gPSBbbGFiZWxHcm91cC54LCBsYWJlbEdyb3VwLnldO1xuICAgIGxhYmVsc1Bvc2l0aW9uWzBdID0gbWFpblBvc2l0aW9uWzBdID0gdmlld0JvdW5kWzBdWzBdO1xuICAgIHZhciBsYWJlbFBvc09wdCA9IGxheW91dEluZm8ubGFiZWxQb3NPcHQ7XG4gICAgaWYgKGxhYmVsUG9zT3B0ID09IG51bGwgfHwgaXNTdHJpbmcobGFiZWxQb3NPcHQpKSB7XG4gICAgICAvLyAnKycgb3IgJy0nXG4gICAgICB2YXIgbWFpbkJvdW5kSWR4ID0gbGFiZWxQb3NPcHQgPT09ICcrJyA/IDAgOiAxO1xuICAgICAgdG9Cb3VuZChtYWluUG9zaXRpb24sIG1haW5Cb3VuZCwgdmlld0JvdW5kLCAxLCBtYWluQm91bmRJZHgpO1xuICAgICAgdG9Cb3VuZChsYWJlbHNQb3NpdGlvbiwgbGFiZWxCb3VuZCwgdmlld0JvdW5kLCAxLCAxIC0gbWFpbkJvdW5kSWR4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1haW5Cb3VuZElkeCA9IGxhYmVsUG9zT3B0ID49IDAgPyAwIDogMTtcbiAgICAgIHRvQm91bmQobWFpblBvc2l0aW9uLCBtYWluQm91bmQsIHZpZXdCb3VuZCwgMSwgbWFpbkJvdW5kSWR4KTtcbiAgICAgIGxhYmVsc1Bvc2l0aW9uWzFdID0gbWFpblBvc2l0aW9uWzFdICsgbGFiZWxQb3NPcHQ7XG4gICAgfVxuICAgIG1haW5Hcm91cC5zZXRQb3NpdGlvbihtYWluUG9zaXRpb24pO1xuICAgIGxhYmVsR3JvdXAuc2V0UG9zaXRpb24obGFiZWxzUG9zaXRpb24pO1xuICAgIG1haW5Hcm91cC5yb3RhdGlvbiA9IGxhYmVsR3JvdXAucm90YXRpb24gPSBsYXlvdXRJbmZvLnJvdGF0aW9uO1xuICAgIHNldE9yaWdpbihtYWluR3JvdXApO1xuICAgIHNldE9yaWdpbihsYWJlbEdyb3VwKTtcbiAgICBmdW5jdGlvbiBzZXRPcmlnaW4odGFyZ2V0R3JvdXApIHtcbiAgICAgIHRhcmdldEdyb3VwLm9yaWdpblggPSB2aWV3Qm91bmRbMF1bMF0gLSB0YXJnZXRHcm91cC54O1xuICAgICAgdGFyZ2V0R3JvdXAub3JpZ2luWSA9IHZpZXdCb3VuZFsxXVswXSAtIHRhcmdldEdyb3VwLnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEJvdW5kKHJlY3QpIHtcbiAgICAgIC8vIFtbeG1pbiwgeG1heF0sIFt5bWluLCB5bWF4XV1cbiAgICAgIHJldHVybiBbW3JlY3QueCwgcmVjdC54ICsgcmVjdC53aWR0aF0sIFtyZWN0LnksIHJlY3QueSArIHJlY3QuaGVpZ2h0XV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvQm91bmQoZnJvbVBvcywgZnJvbSwgdG8sIGRpbUlkeCwgYm91bmRJZHgpIHtcbiAgICAgIGZyb21Qb3NbZGltSWR4XSArPSB0b1tkaW1JZHhdW2JvdW5kSWR4XSAtIGZyb21bZGltSWR4XVtib3VuZElkeF07XG4gICAgfVxuICB9O1xuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLl9jcmVhdGVBeGlzID0gZnVuY3Rpb24gKGxheW91dEluZm8sIHRpbWVsaW5lTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHRpbWVsaW5lTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBheGlzVHlwZSA9IHRpbWVsaW5lTW9kZWwuZ2V0KCdheGlzVHlwZScpO1xuICAgIHZhciBzY2FsZSA9IGNyZWF0ZVNjYWxlQnlNb2RlbCh0aW1lbGluZU1vZGVsLCBheGlzVHlwZSk7XG4gICAgLy8gQ3VzdG9taXplIHNjYWxlLiBUaGUgYHRpY2tWYWx1ZWAgaXMgYGRhdGFJbmRleGAuXG4gICAgc2NhbGUuZ2V0VGlja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGF0YS5tYXBBcnJheShbJ3ZhbHVlJ10sIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgZGF0YUV4dGVudCA9IGRhdGEuZ2V0RGF0YUV4dGVudCgndmFsdWUnKTtcbiAgICBzY2FsZS5zZXRFeHRlbnQoZGF0YUV4dGVudFswXSwgZGF0YUV4dGVudFsxXSk7XG4gICAgc2NhbGUuY2FsY05pY2VUaWNrcygpO1xuICAgIHZhciBheGlzID0gbmV3IFRpbWVsaW5lQXhpcygndmFsdWUnLCBzY2FsZSwgbGF5b3V0SW5mby5heGlzRXh0ZW50LCBheGlzVHlwZSk7XG4gICAgYXhpcy5tb2RlbCA9IHRpbWVsaW5lTW9kZWw7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG4gIFNsaWRlclRpbWVsaW5lVmlldy5wcm90b3R5cGUuX2NyZWF0ZUdyb3VwID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBuZXdHcm91cCA9IHRoaXNba2V5XSA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgdGhpcy5ncm91cC5hZGQobmV3R3JvdXApO1xuICAgIHJldHVybiBuZXdHcm91cDtcbiAgfTtcbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5fcmVuZGVyQXhpc0xpbmUgPSBmdW5jdGlvbiAobGF5b3V0SW5mbywgZ3JvdXAsIGF4aXMsIHRpbWVsaW5lTW9kZWwpIHtcbiAgICB2YXIgYXhpc0V4dGVudCA9IGF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgaWYgKCF0aW1lbGluZU1vZGVsLmdldChbJ2xpbmVTdHlsZScsICdzaG93J10pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsaW5lID0gbmV3IGdyYXBoaWMuTGluZSh7XG4gICAgICBzaGFwZToge1xuICAgICAgICB4MTogYXhpc0V4dGVudFswXSxcbiAgICAgICAgeTE6IDAsXG4gICAgICAgIHgyOiBheGlzRXh0ZW50WzFdLFxuICAgICAgICB5MjogMFxuICAgICAgfSxcbiAgICAgIHN0eWxlOiBleHRlbmQoe1xuICAgICAgICBsaW5lQ2FwOiAncm91bmQnXG4gICAgICB9LCB0aW1lbGluZU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKSksXG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICB6MjogMVxuICAgIH0pO1xuICAgIGdyb3VwLmFkZChsaW5lKTtcbiAgICB2YXIgcHJvZ3Jlc3NMaW5lID0gdGhpcy5fcHJvZ3Jlc3NMaW5lID0gbmV3IGdyYXBoaWMuTGluZSh7XG4gICAgICBzaGFwZToge1xuICAgICAgICB4MTogYXhpc0V4dGVudFswXSxcbiAgICAgICAgeDI6IHRoaXMuX2N1cnJlbnRQb2ludGVyID8gdGhpcy5fY3VycmVudFBvaW50ZXIueCA6IGF4aXNFeHRlbnRbMF0sXG4gICAgICAgIHkxOiAwLFxuICAgICAgICB5MjogMFxuICAgICAgfSxcbiAgICAgIHN0eWxlOiBkZWZhdWx0cyh7XG4gICAgICAgIGxpbmVDYXA6ICdyb3VuZCcsXG4gICAgICAgIGxpbmVXaWR0aDogbGluZS5zdHlsZS5saW5lV2lkdGhcbiAgICAgIH0sIHRpbWVsaW5lTW9kZWwuZ2V0TW9kZWwoWydwcm9ncmVzcycsICdsaW5lU3R5bGUnXSkuZ2V0TGluZVN0eWxlKCkpLFxuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgejI6IDFcbiAgICB9KTtcbiAgICBncm91cC5hZGQocHJvZ3Jlc3NMaW5lKTtcbiAgfTtcbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5fcmVuZGVyQXhpc1RpY2sgPSBmdW5jdGlvbiAobGF5b3V0SW5mbywgZ3JvdXAsIGF4aXMsIHRpbWVsaW5lTW9kZWwpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBkYXRhID0gdGltZWxpbmVNb2RlbC5nZXREYXRhKCk7XG4gICAgLy8gU2hvdyBhbGwgdGlja3MsIGRlc3BpdGUgaWdub3Jpbmcgc3RyYXRlZ3kuXG4gICAgdmFyIHRpY2tzID0gYXhpcy5zY2FsZS5nZXRUaWNrcygpO1xuICAgIHRoaXMuX3RpY2tTeW1ib2xzID0gW107XG4gICAgLy8gVGhlIHZhbHVlIGlzIGRhdGFJbmRleCwgc2VlIHRoZSBjdXN0b21pemVkIHNjYWxlLlxuICAgIGVhY2godGlja3MsIGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICB2YXIgdGlja0Nvb3JkID0gYXhpcy5kYXRhVG9Db29yZCh0aWNrLnZhbHVlKTtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbCh0aWNrLnZhbHVlKTtcbiAgICAgIHZhciBpdGVtU3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJyk7XG4gICAgICB2YXIgaG92ZXJTdHlsZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKFsnZW1waGFzaXMnLCAnaXRlbVN0eWxlJ10pO1xuICAgICAgdmFyIHByb2dyZXNzU3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChbJ3Byb2dyZXNzJywgJ2l0ZW1TdHlsZSddKTtcbiAgICAgIHZhciBzeW1ib2xPcHQgPSB7XG4gICAgICAgIHg6IHRpY2tDb29yZCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgb25jbGljazogYmluZChfdGhpcy5fY2hhbmdlVGltZWxpbmUsIF90aGlzLCB0aWNrLnZhbHVlKVxuICAgICAgfTtcbiAgICAgIHZhciBlbCA9IGdpdmVTeW1ib2woaXRlbU1vZGVsLCBpdGVtU3R5bGVNb2RlbCwgZ3JvdXAsIHN5bWJvbE9wdCk7XG4gICAgICBlbC5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKS5zdHlsZSA9IGhvdmVyU3R5bGVNb2RlbC5nZXRJdGVtU3R5bGUoKTtcbiAgICAgIGVsLmVuc3VyZVN0YXRlKCdwcm9ncmVzcycpLnN0eWxlID0gcHJvZ3Jlc3NTdHlsZU1vZGVsLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgZW5hYmxlSG92ZXJFbXBoYXNpcyhlbCk7XG4gICAgICB2YXIgZWNEYXRhID0gZ2V0RUNEYXRhKGVsKTtcbiAgICAgIGlmIChpdGVtTW9kZWwuZ2V0KCd0b29sdGlwJykpIHtcbiAgICAgICAgZWNEYXRhLmRhdGFJbmRleCA9IHRpY2sudmFsdWU7XG4gICAgICAgIGVjRGF0YS5kYXRhTW9kZWwgPSB0aW1lbGluZU1vZGVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWNEYXRhLmRhdGFJbmRleCA9IGVjRGF0YS5kYXRhTW9kZWwgPSBudWxsO1xuICAgICAgfVxuICAgICAgX3RoaXMuX3RpY2tTeW1ib2xzLnB1c2goZWwpO1xuICAgIH0pO1xuICB9O1xuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLl9yZW5kZXJBeGlzTGFiZWwgPSBmdW5jdGlvbiAobGF5b3V0SW5mbywgZ3JvdXAsIGF4aXMsIHRpbWVsaW5lTW9kZWwpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBsYWJlbE1vZGVsID0gYXhpcy5nZXRMYWJlbE1vZGVsKCk7XG4gICAgaWYgKCFsYWJlbE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGltZWxpbmVNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGxhYmVscyA9IGF4aXMuZ2V0Vmlld0xhYmVscygpO1xuICAgIHRoaXMuX3RpY2tMYWJlbHMgPSBbXTtcbiAgICBlYWNoKGxhYmVscywgZnVuY3Rpb24gKGxhYmVsSXRlbSkge1xuICAgICAgLy8gVGhlIHRpY2tWYWx1ZSBpcyBkYXRhSW5kZXgsIHNlZSB0aGUgY3VzdG9taXplZCBzY2FsZS5cbiAgICAgIHZhciBkYXRhSW5kZXggPSBsYWJlbEl0ZW0udGlja1ZhbHVlO1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG4gICAgICB2YXIgbm9ybWFsTGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwnKTtcbiAgICAgIHZhciBob3ZlckxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoWydlbXBoYXNpcycsICdsYWJlbCddKTtcbiAgICAgIHZhciBwcm9ncmVzc0xhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoWydwcm9ncmVzcycsICdsYWJlbCddKTtcbiAgICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLmRhdGFUb0Nvb3JkKGxhYmVsSXRlbS50aWNrVmFsdWUpO1xuICAgICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgICB4OiB0aWNrQ29vcmQsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHJvdGF0aW9uOiBsYXlvdXRJbmZvLmxhYmVsUm90YXRpb24gLSBsYXlvdXRJbmZvLnJvdGF0aW9uLFxuICAgICAgICBvbmNsaWNrOiBiaW5kKF90aGlzLl9jaGFuZ2VUaW1lbGluZSwgX3RoaXMsIGRhdGFJbmRleCksXG4gICAgICAgIHNpbGVudDogZmFsc2UsXG4gICAgICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUobm9ybWFsTGFiZWxNb2RlbCwge1xuICAgICAgICAgIHRleHQ6IGxhYmVsSXRlbS5mb3JtYXR0ZWRMYWJlbCxcbiAgICAgICAgICBhbGlnbjogbGF5b3V0SW5mby5sYWJlbEFsaWduLFxuICAgICAgICAgIHZlcnRpY2FsQWxpZ246IGxheW91dEluZm8ubGFiZWxCYXNlbGluZVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICB0ZXh0RWwuZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJykuc3R5bGUgPSBjcmVhdGVUZXh0U3R5bGUoaG92ZXJMYWJlbE1vZGVsKTtcbiAgICAgIHRleHRFbC5lbnN1cmVTdGF0ZSgncHJvZ3Jlc3MnKS5zdHlsZSA9IGNyZWF0ZVRleHRTdHlsZShwcm9ncmVzc0xhYmVsTW9kZWwpO1xuICAgICAgZ3JvdXAuYWRkKHRleHRFbCk7XG4gICAgICBlbmFibGVIb3ZlckVtcGhhc2lzKHRleHRFbCk7XG4gICAgICBsYWJlbERhdGFJbmRleFN0b3JlKHRleHRFbCkuZGF0YUluZGV4ID0gZGF0YUluZGV4O1xuICAgICAgX3RoaXMuX3RpY2tMYWJlbHMucHVzaCh0ZXh0RWwpO1xuICAgIH0pO1xuICB9O1xuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLl9yZW5kZXJDb250cm9sID0gZnVuY3Rpb24gKGxheW91dEluZm8sIGdyb3VwLCBheGlzLCB0aW1lbGluZU1vZGVsKSB7XG4gICAgdmFyIGNvbnRyb2xTaXplID0gbGF5b3V0SW5mby5jb250cm9sU2l6ZTtcbiAgICB2YXIgcm90YXRpb24gPSBsYXlvdXRJbmZvLnJvdGF0aW9uO1xuICAgIHZhciBpdGVtU3R5bGUgPSB0aW1lbGluZU1vZGVsLmdldE1vZGVsKCdjb250cm9sU3R5bGUnKS5nZXRJdGVtU3R5bGUoKTtcbiAgICB2YXIgaG92ZXJTdHlsZSA9IHRpbWVsaW5lTW9kZWwuZ2V0TW9kZWwoWydlbXBoYXNpcycsICdjb250cm9sU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCk7XG4gICAgdmFyIHBsYXlTdGF0ZSA9IHRpbWVsaW5lTW9kZWwuZ2V0UGxheVN0YXRlKCk7XG4gICAgdmFyIGludmVyc2UgPSB0aW1lbGluZU1vZGVsLmdldCgnaW52ZXJzZScsIHRydWUpO1xuICAgIG1ha2VCdG4obGF5b3V0SW5mby5uZXh0QnRuUG9zaXRpb24sICduZXh0JywgYmluZCh0aGlzLl9jaGFuZ2VUaW1lbGluZSwgdGhpcywgaW52ZXJzZSA/ICctJyA6ICcrJykpO1xuICAgIG1ha2VCdG4obGF5b3V0SW5mby5wcmV2QnRuUG9zaXRpb24sICdwcmV2JywgYmluZCh0aGlzLl9jaGFuZ2VUaW1lbGluZSwgdGhpcywgaW52ZXJzZSA/ICcrJyA6ICctJykpO1xuICAgIG1ha2VCdG4obGF5b3V0SW5mby5wbGF5UG9zaXRpb24sIHBsYXlTdGF0ZSA/ICdzdG9wJyA6ICdwbGF5JywgYmluZCh0aGlzLl9oYW5kbGVQbGF5Q2xpY2ssIHRoaXMsICFwbGF5U3RhdGUpLCB0cnVlKTtcbiAgICBmdW5jdGlvbiBtYWtlQnRuKHBvc2l0aW9uLCBpY29uTmFtZSwgb25jbGljaywgd2lsbFJvdGF0ZSkge1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaWNvblNpemUgPSBwYXJzZVBlcmNlbnQocmV0cmlldmUyKHRpbWVsaW5lTW9kZWwuZ2V0KFsnY29udHJvbFN0eWxlJywgaWNvbk5hbWUgKyAnQnRuU2l6ZSddKSwgY29udHJvbFNpemUpLCBjb250cm9sU2l6ZSk7XG4gICAgICB2YXIgcmVjdCA9IFswLCAtaWNvblNpemUgLyAyLCBpY29uU2l6ZSwgaWNvblNpemVdO1xuICAgICAgdmFyIGJ0biA9IG1ha2VDb250cm9sSWNvbih0aW1lbGluZU1vZGVsLCBpY29uTmFtZSArICdJY29uJywgcmVjdCwge1xuICAgICAgICB4OiBwb3NpdGlvblswXSxcbiAgICAgICAgeTogcG9zaXRpb25bMV0sXG4gICAgICAgIG9yaWdpblg6IGNvbnRyb2xTaXplIC8gMixcbiAgICAgICAgb3JpZ2luWTogMCxcbiAgICAgICAgcm90YXRpb246IHdpbGxSb3RhdGUgPyAtcm90YXRpb24gOiAwLFxuICAgICAgICByZWN0SG92ZXI6IHRydWUsXG4gICAgICAgIHN0eWxlOiBpdGVtU3R5bGUsXG4gICAgICAgIG9uY2xpY2s6IG9uY2xpY2tcbiAgICAgIH0pO1xuICAgICAgYnRuLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpLnN0eWxlID0gaG92ZXJTdHlsZTtcbiAgICAgIGdyb3VwLmFkZChidG4pO1xuICAgICAgZW5hYmxlSG92ZXJFbXBoYXNpcyhidG4pO1xuICAgIH1cbiAgfTtcbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5fcmVuZGVyQ3VycmVudFBvaW50ZXIgPSBmdW5jdGlvbiAobGF5b3V0SW5mbywgZ3JvdXAsIGF4aXMsIHRpbWVsaW5lTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHRpbWVsaW5lTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBjdXJyZW50SW5kZXggPSB0aW1lbGluZU1vZGVsLmdldEN1cnJlbnRJbmRleCgpO1xuICAgIHZhciBwb2ludGVyTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChjdXJyZW50SW5kZXgpLmdldE1vZGVsKCdjaGVja3BvaW50U3R5bGUnKTtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBjYWxsYmFjayA9IHtcbiAgICAgIG9uQ3JlYXRlOiBmdW5jdGlvbiAocG9pbnRlcikge1xuICAgICAgICBwb2ludGVyLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIHBvaW50ZXIuZHJpZnQgPSBiaW5kKG1lLl9oYW5kbGVQb2ludGVyRHJhZywgbWUpO1xuICAgICAgICBwb2ludGVyLm9uZHJhZ2VuZCA9IGJpbmQobWUuX2hhbmRsZVBvaW50ZXJEcmFnZW5kLCBtZSk7XG4gICAgICAgIHBvaW50ZXJNb3ZlVG8ocG9pbnRlciwgbWUuX3Byb2dyZXNzTGluZSwgY3VycmVudEluZGV4LCBheGlzLCB0aW1lbGluZU1vZGVsLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBvblVwZGF0ZTogZnVuY3Rpb24gKHBvaW50ZXIpIHtcbiAgICAgICAgcG9pbnRlck1vdmVUbyhwb2ludGVyLCBtZS5fcHJvZ3Jlc3NMaW5lLCBjdXJyZW50SW5kZXgsIGF4aXMsIHRpbWVsaW5lTW9kZWwpO1xuICAgICAgfVxuICAgIH07XG4gICAgLy8gUmV1c2Ugd2hlbiBleGlzdHMsIGZvciBhbmltYXRpb24gYW5kIGRyYWcuXG4gICAgdGhpcy5fY3VycmVudFBvaW50ZXIgPSBnaXZlU3ltYm9sKHBvaW50ZXJNb2RlbCwgcG9pbnRlck1vZGVsLCB0aGlzLl9tYWluR3JvdXAsIHt9LCB0aGlzLl9jdXJyZW50UG9pbnRlciwgY2FsbGJhY2spO1xuICB9O1xuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLl9oYW5kbGVQbGF5Q2xpY2sgPSBmdW5jdGlvbiAobmV4dFN0YXRlKSB7XG4gICAgdGhpcy5fY2xlYXJUaW1lcigpO1xuICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICd0aW1lbGluZVBsYXlDaGFuZ2UnLFxuICAgICAgcGxheVN0YXRlOiBuZXh0U3RhdGUsXG4gICAgICBmcm9tOiB0aGlzLnVpZFxuICAgIH0pO1xuICB9O1xuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLl9oYW5kbGVQb2ludGVyRHJhZyA9IGZ1bmN0aW9uIChkeCwgZHksIGUpIHtcbiAgICB0aGlzLl9jbGVhclRpbWVyKCk7XG4gICAgdGhpcy5fcG9pbnRlckNoYW5nZVRpbWVsaW5lKFtlLm9mZnNldFgsIGUub2Zmc2V0WV0pO1xuICB9O1xuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLl9oYW5kbGVQb2ludGVyRHJhZ2VuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdGhpcy5fcG9pbnRlckNoYW5nZVRpbWVsaW5lKFtlLm9mZnNldFgsIGUub2Zmc2V0WV0sIHRydWUpO1xuICB9O1xuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLl9wb2ludGVyQ2hhbmdlVGltZWxpbmUgPSBmdW5jdGlvbiAobW91c2VQb3MsIHRyaWdnZXIpIHtcbiAgICB2YXIgdG9Db29yZCA9IHRoaXMuX3RvQXhpc0Nvb3JkKG1vdXNlUG9zKVswXTtcbiAgICB2YXIgYXhpcyA9IHRoaXMuX2F4aXM7XG4gICAgdmFyIGF4aXNFeHRlbnQgPSBudW1iZXJVdGlsLmFzYyhheGlzLmdldEV4dGVudCgpLnNsaWNlKCkpO1xuICAgIHRvQ29vcmQgPiBheGlzRXh0ZW50WzFdICYmICh0b0Nvb3JkID0gYXhpc0V4dGVudFsxXSk7XG4gICAgdG9Db29yZCA8IGF4aXNFeHRlbnRbMF0gJiYgKHRvQ29vcmQgPSBheGlzRXh0ZW50WzBdKTtcbiAgICB0aGlzLl9jdXJyZW50UG9pbnRlci54ID0gdG9Db29yZDtcbiAgICB0aGlzLl9jdXJyZW50UG9pbnRlci5tYXJrUmVkcmF3KCk7XG4gICAgdmFyIHByb2dyZXNzTGluZSA9IHRoaXMuX3Byb2dyZXNzTGluZTtcbiAgICBpZiAocHJvZ3Jlc3NMaW5lKSB7XG4gICAgICBwcm9ncmVzc0xpbmUuc2hhcGUueDIgPSB0b0Nvb3JkO1xuICAgICAgcHJvZ3Jlc3NMaW5lLmRpcnR5KCk7XG4gICAgfVxuICAgIHZhciB0YXJnZXREYXRhSW5kZXggPSB0aGlzLl9maW5kTmVhcmVzdFRpY2sodG9Db29yZCk7XG4gICAgdmFyIHRpbWVsaW5lTW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgIGlmICh0cmlnZ2VyIHx8IHRhcmdldERhdGFJbmRleCAhPT0gdGltZWxpbmVNb2RlbC5nZXRDdXJyZW50SW5kZXgoKSAmJiB0aW1lbGluZU1vZGVsLmdldCgncmVhbHRpbWUnKSkge1xuICAgICAgdGhpcy5fY2hhbmdlVGltZWxpbmUodGFyZ2V0RGF0YUluZGV4KTtcbiAgICB9XG4gIH07XG4gIFNsaWRlclRpbWVsaW5lVmlldy5wcm90b3R5cGUuX2RvUGxheVN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9jbGVhclRpbWVyKCk7XG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0UGxheVN0YXRlKCkpIHtcbiAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERvIG5vdCBjYWNoZVxuICAgICAgICB2YXIgdGltZWxpbmVNb2RlbCA9IF90aGlzLm1vZGVsO1xuICAgICAgICBfdGhpcy5fY2hhbmdlVGltZWxpbmUodGltZWxpbmVNb2RlbC5nZXRDdXJyZW50SW5kZXgoKSArICh0aW1lbGluZU1vZGVsLmdldCgncmV3aW5kJywgdHJ1ZSkgPyAtMSA6IDEpKTtcbiAgICAgIH0sIHRoaXMubW9kZWwuZ2V0KCdwbGF5SW50ZXJ2YWwnKSk7XG4gICAgfVxuICB9O1xuICBTbGlkZXJUaW1lbGluZVZpZXcucHJvdG90eXBlLl90b0F4aXNDb29yZCA9IGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICB2YXIgdHJhbnMgPSB0aGlzLl9tYWluR3JvdXAuZ2V0TG9jYWxUcmFuc2Zvcm0oKTtcbiAgICByZXR1cm4gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSh2ZXJ0ZXgsIHRyYW5zLCB0cnVlKTtcbiAgfTtcbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5fZmluZE5lYXJlc3RUaWNrID0gZnVuY3Rpb24gKGF4aXNDb29yZCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGRpc3QgPSBJbmZpbml0eTtcbiAgICB2YXIgdGFyZ2V0RGF0YUluZGV4O1xuICAgIHZhciBheGlzID0gdGhpcy5fYXhpcztcbiAgICBkYXRhLmVhY2goWyd2YWx1ZSddLCBmdW5jdGlvbiAodmFsdWUsIGRhdGFJbmRleCkge1xuICAgICAgdmFyIGNvb3JkID0gYXhpcy5kYXRhVG9Db29yZCh2YWx1ZSk7XG4gICAgICB2YXIgZCA9IE1hdGguYWJzKGNvb3JkIC0gYXhpc0Nvb3JkKTtcbiAgICAgIGlmIChkIDwgZGlzdCkge1xuICAgICAgICBkaXN0ID0gZDtcbiAgICAgICAgdGFyZ2V0RGF0YUluZGV4ID0gZGF0YUluZGV4O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXREYXRhSW5kZXg7XG4gIH07XG4gIFNsaWRlclRpbWVsaW5lVmlldy5wcm90b3R5cGUuX2NsZWFyVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgU2xpZGVyVGltZWxpbmVWaWV3LnByb3RvdHlwZS5fY2hhbmdlVGltZWxpbmUgPSBmdW5jdGlvbiAobmV4dEluZGV4KSB7XG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IHRoaXMubW9kZWwuZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgaWYgKG5leHRJbmRleCA9PT0gJysnKSB7XG4gICAgICBuZXh0SW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgIH0gZWxzZSBpZiAobmV4dEluZGV4ID09PSAnLScpIHtcbiAgICAgIG5leHRJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgfVxuICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICd0aW1lbGluZUNoYW5nZScsXG4gICAgICBjdXJyZW50SW5kZXg6IG5leHRJbmRleCxcbiAgICAgIGZyb206IHRoaXMudWlkXG4gICAgfSk7XG4gIH07XG4gIFNsaWRlclRpbWVsaW5lVmlldy5wcm90b3R5cGUuX3VwZGF0ZVRpY2tzU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLm1vZGVsLmdldEN1cnJlbnRJbmRleCgpO1xuICAgIHZhciB0aWNrU3ltYm9scyA9IHRoaXMuX3RpY2tTeW1ib2xzO1xuICAgIHZhciB0aWNrTGFiZWxzID0gdGhpcy5fdGlja0xhYmVscztcbiAgICBpZiAodGlja1N5bWJvbHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja1N5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGlja1N5bWJvbHMgJiYgdGlja1N5bWJvbHNbaV0gJiYgdGlja1N5bWJvbHNbaV0udG9nZ2xlU3RhdGUoJ3Byb2dyZXNzJywgaSA8IGN1cnJlbnRJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aWNrTGFiZWxzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tMYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGlja0xhYmVscyAmJiB0aWNrTGFiZWxzW2ldICYmIHRpY2tMYWJlbHNbaV0udG9nZ2xlU3RhdGUoJ3Byb2dyZXNzJywgbGFiZWxEYXRhSW5kZXhTdG9yZSh0aWNrTGFiZWxzW2ldKS5kYXRhSW5kZXggPD0gY3VycmVudEluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFNsaWRlclRpbWVsaW5lVmlldy50eXBlID0gJ3RpbWVsaW5lLnNsaWRlcic7XG4gIHJldHVybiBTbGlkZXJUaW1lbGluZVZpZXc7XG59KFRpbWVsaW5lVmlldyk7XG5mdW5jdGlvbiBjcmVhdGVTY2FsZUJ5TW9kZWwobW9kZWwsIGF4aXNUeXBlKSB7XG4gIGF4aXNUeXBlID0gYXhpc1R5cGUgfHwgbW9kZWwuZ2V0KCd0eXBlJyk7XG4gIGlmIChheGlzVHlwZSkge1xuICAgIHN3aXRjaCAoYXhpc1R5cGUpIHtcbiAgICAgIC8vIEJ1aWxkaW4gc2NhbGVcbiAgICAgIGNhc2UgJ2NhdGVnb3J5JzpcbiAgICAgICAgcmV0dXJuIG5ldyBPcmRpbmFsU2NhbGUoe1xuICAgICAgICAgIG9yZGluYWxNZXRhOiBtb2RlbC5nZXRDYXRlZ29yaWVzKCksXG4gICAgICAgICAgZXh0ZW50OiBbSW5maW5pdHksIC1JbmZpbml0eV1cbiAgICAgICAgfSk7XG4gICAgICBjYXNlICd0aW1lJzpcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lU2NhbGUoe1xuICAgICAgICAgIGxvY2FsZTogbW9kZWwuZWNNb2RlbC5nZXRMb2NhbGVNb2RlbCgpLFxuICAgICAgICAgIHVzZVVUQzogbW9kZWwuZWNNb2RlbC5nZXQoJ3VzZVVUQycpXG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gZGVmYXVsdCB0byBiZSB2YWx1ZVxuICAgICAgICByZXR1cm4gbmV3IEludGVydmFsU2NhbGUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZpZXdSZWN0KG1vZGVsLCBhcGkpIHtcbiAgcmV0dXJuIGxheW91dC5nZXRMYXlvdXRSZWN0KG1vZGVsLmdldEJveExheW91dFBhcmFtcygpLCB7XG4gICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gIH0sIG1vZGVsLmdldCgncGFkZGluZycpKTtcbn1cbmZ1bmN0aW9uIG1ha2VDb250cm9sSWNvbih0aW1lbGluZU1vZGVsLCBvYmpQYXRoLCByZWN0LCBvcHRzKSB7XG4gIHZhciBzdHlsZSA9IG9wdHMuc3R5bGU7XG4gIHZhciBpY29uID0gZ3JhcGhpYy5jcmVhdGVJY29uKHRpbWVsaW5lTW9kZWwuZ2V0KFsnY29udHJvbFN0eWxlJywgb2JqUGF0aF0pLCBvcHRzIHx8IHt9LCBuZXcgQm91bmRpbmdSZWN0KHJlY3RbMF0sIHJlY3RbMV0sIHJlY3RbMl0sIHJlY3RbM10pKTtcbiAgLy8gVE9ETyBjcmVhdGVJY29uIHdvbid0IHVzZSBzdHlsZSBpbiBvcHQuXG4gIGlmIChzdHlsZSkge1xuICAgIGljb24uc2V0U3R5bGUoc3R5bGUpO1xuICB9XG4gIHJldHVybiBpY29uO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBzeW1ib2wgb3IgdXBkYXRlIHN5bWJvbFxyXG4gKiBvcHQ6IGJhc2ljIHBvc2l0aW9uIGFuZCBldmVudCBoYW5kbGVyc1xyXG4gKi9cbmZ1bmN0aW9uIGdpdmVTeW1ib2woaG9zdE1vZGVsLCBpdGVtU3R5bGVNb2RlbCwgZ3JvdXAsIG9wdCwgc3ltYm9sLCBjYWxsYmFjaykge1xuICB2YXIgY29sb3IgPSBpdGVtU3R5bGVNb2RlbC5nZXQoJ2NvbG9yJyk7XG4gIGlmICghc3ltYm9sKSB7XG4gICAgdmFyIHN5bWJvbFR5cGUgPSBob3N0TW9kZWwuZ2V0KCdzeW1ib2wnKTtcbiAgICBzeW1ib2wgPSBjcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgLTEsIC0xLCAyLCAyLCBjb2xvcik7XG4gICAgc3ltYm9sLnNldFN0eWxlKCdzdHJva2VOb1NjYWxlJywgdHJ1ZSk7XG4gICAgZ3JvdXAuYWRkKHN5bWJvbCk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sub25DcmVhdGUoc3ltYm9sKTtcbiAgfSBlbHNlIHtcbiAgICBzeW1ib2wuc2V0Q29sb3IoY29sb3IpO1xuICAgIGdyb3VwLmFkZChzeW1ib2wpOyAvLyBHcm91cCBtYXkgYmUgbmV3LCBhbHNvIG5lZWQgdG8gYWRkLlxuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLm9uVXBkYXRlKHN5bWJvbCk7XG4gIH1cbiAgLy8gU3R5bGVcbiAgdmFyIGl0ZW1TdHlsZSA9IGl0ZW1TdHlsZU1vZGVsLmdldEl0ZW1TdHlsZShbJ2NvbG9yJ10pO1xuICBzeW1ib2wuc2V0U3R5bGUoaXRlbVN0eWxlKTtcbiAgLy8gVHJhbnNmb3JtIGFuZCBldmVudHMuXG4gIG9wdCA9IG1lcmdlKHtcbiAgICByZWN0SG92ZXI6IHRydWUsXG4gICAgejI6IDEwMFxuICB9LCBvcHQsIHRydWUpO1xuICB2YXIgc3ltYm9sU2l6ZSA9IG5vcm1hbGl6ZVN5bWJvbFNpemUoaG9zdE1vZGVsLmdldCgnc3ltYm9sU2l6ZScpKTtcbiAgb3B0LnNjYWxlWCA9IHN5bWJvbFNpemVbMF0gLyAyO1xuICBvcHQuc2NhbGVZID0gc3ltYm9sU2l6ZVsxXSAvIDI7XG4gIHZhciBzeW1ib2xPZmZzZXQgPSBub3JtYWxpemVTeW1ib2xPZmZzZXQoaG9zdE1vZGVsLmdldCgnc3ltYm9sT2Zmc2V0JyksIHN5bWJvbFNpemUpO1xuICBpZiAoc3ltYm9sT2Zmc2V0KSB7XG4gICAgb3B0LnggPSAob3B0LnggfHwgMCkgKyBzeW1ib2xPZmZzZXRbMF07XG4gICAgb3B0LnkgPSAob3B0LnkgfHwgMCkgKyBzeW1ib2xPZmZzZXRbMV07XG4gIH1cbiAgdmFyIHN5bWJvbFJvdGF0ZSA9IGhvc3RNb2RlbC5nZXQoJ3N5bWJvbFJvdGF0ZScpO1xuICBvcHQucm90YXRpb24gPSAoc3ltYm9sUm90YXRlIHx8IDApICogTWF0aC5QSSAvIDE4MCB8fCAwO1xuICBzeW1ib2wuYXR0cihvcHQpO1xuICAvLyBGSVhNRVxuICAvLyAoMSkgV2hlbiBzeW1ib2wuc3R5bGUuc3Ryb2tlTm9TY2FsZSBpcyB0cnVlIGFuZCB1cGRhdGVUcmFuc2Zvcm0gaXMgbm90IHBlcmZvcm1lZCxcbiAgLy8gZ2V0Qm91bmRpbmdSZWN0IHdpbGwgcmV0dXJuIHdyb25nIHJlc3VsdC5cbiAgLy8gKFRoaXMgaXMgc3VwcG9zZWQgdG8gYmUgcmVzb2x2ZWQgaW4genJlbmRlciwgYnV0IGl0IGlzIGEgbGl0dGxlIGRpZmZpY3VsdCB0b1xuICAvLyBsZXZlcmFnZSBwZXJmb3JtYW5jZSBhbmQgYXV0byB1cGRhdGVUcmFuc2Zvcm0pXG4gIC8vICgyKSBBbGwgb2YgYW5jZXN0ZXJzIG9mIHN5bWJvbCBkbyBub3Qgc2NhbGUsIHNvIHdlIGNhbiBqdXN0IHVwZGF0ZVRyYW5zZm9ybSBzeW1ib2wuXG4gIHN5bWJvbC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgcmV0dXJuIHN5bWJvbDtcbn1cbmZ1bmN0aW9uIHBvaW50ZXJNb3ZlVG8ocG9pbnRlciwgcHJvZ3Jlc3NMaW5lLCBkYXRhSW5kZXgsIGF4aXMsIHRpbWVsaW5lTW9kZWwsIG5vQW5pbWF0aW9uKSB7XG4gIGlmIChwb2ludGVyLmRyYWdnaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwb2ludGVyTW9kZWwgPSB0aW1lbGluZU1vZGVsLmdldE1vZGVsKCdjaGVja3BvaW50U3R5bGUnKTtcbiAgdmFyIHRvQ29vcmQgPSBheGlzLmRhdGFUb0Nvb3JkKHRpbWVsaW5lTW9kZWwuZ2V0RGF0YSgpLmdldCgndmFsdWUnLCBkYXRhSW5kZXgpKTtcbiAgaWYgKG5vQW5pbWF0aW9uIHx8ICFwb2ludGVyTW9kZWwuZ2V0KCdhbmltYXRpb24nLCB0cnVlKSkge1xuICAgIHBvaW50ZXIuYXR0cih7XG4gICAgICB4OiB0b0Nvb3JkLFxuICAgICAgeTogMFxuICAgIH0pO1xuICAgIHByb2dyZXNzTGluZSAmJiBwcm9ncmVzc0xpbmUuYXR0cih7XG4gICAgICBzaGFwZToge1xuICAgICAgICB4MjogdG9Db29yZFxuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBhbmltYXRpb25DZmcgPSB7XG4gICAgICBkdXJhdGlvbjogcG9pbnRlck1vZGVsLmdldCgnYW5pbWF0aW9uRHVyYXRpb24nLCB0cnVlKSxcbiAgICAgIGVhc2luZzogcG9pbnRlck1vZGVsLmdldCgnYW5pbWF0aW9uRWFzaW5nJywgdHJ1ZSlcbiAgICB9O1xuICAgIHBvaW50ZXIuc3RvcEFuaW1hdGlvbihudWxsLCB0cnVlKTtcbiAgICBwb2ludGVyLmFuaW1hdGVUbyh7XG4gICAgICB4OiB0b0Nvb3JkLFxuICAgICAgeTogMFxuICAgIH0sIGFuaW1hdGlvbkNmZyk7XG4gICAgcHJvZ3Jlc3NMaW5lICYmIHByb2dyZXNzTGluZS5hbmltYXRlVG8oe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgeDI6IHRvQ29vcmRcbiAgICAgIH1cbiAgICB9LCBhbmltYXRpb25DZmcpO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBTbGlkZXJUaW1lbGluZVZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBkZWZhdWx0cyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbFRpbWVsaW5lQWN0aW9uKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgIHR5cGU6ICd0aW1lbGluZUNoYW5nZScsXG4gICAgZXZlbnQ6ICd0aW1lbGluZUNoYW5nZWQnLFxuICAgIHVwZGF0ZTogJ3ByZXBhcmVBbmRVcGRhdGUnXG4gIH0sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgdGltZWxpbmVNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0aW1lbGluZScpO1xuICAgIGlmICh0aW1lbGluZU1vZGVsICYmIHBheWxvYWQuY3VycmVudEluZGV4ICE9IG51bGwpIHtcbiAgICAgIHRpbWVsaW5lTW9kZWwuc2V0Q3VycmVudEluZGV4KHBheWxvYWQuY3VycmVudEluZGV4KTtcbiAgICAgIGlmICghdGltZWxpbmVNb2RlbC5nZXQoJ2xvb3AnLCB0cnVlKSAmJiB0aW1lbGluZU1vZGVsLmlzSW5kZXhNYXgoKSAmJiB0aW1lbGluZU1vZGVsLmdldFBsYXlTdGF0ZSgpKSB7XG4gICAgICAgIHRpbWVsaW5lTW9kZWwuc2V0UGxheVN0YXRlKGZhbHNlKTtcbiAgICAgICAgLy8gVGhlIHRpbWVsaW5lIGhhcyBwbGF5ZWQgdG8gdGhlIGVuZCwgdHJpZ2dlciBldmVudFxuICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgIHR5cGU6ICd0aW1lbGluZVBsYXlDaGFuZ2UnLFxuICAgICAgICAgIHBsYXlTdGF0ZTogZmFsc2UsXG4gICAgICAgICAgZnJvbTogcGF5bG9hZC5mcm9tXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXQgbm9ybWFsaXplZCBjdXJyZW50SW5kZXggdG8gcGF5bG9hZC5cbiAgICBlY01vZGVsLnJlc2V0T3B0aW9uKCd0aW1lbGluZScsIHtcbiAgICAgIHJlcGxhY2VNZXJnZTogdGltZWxpbmVNb2RlbC5nZXQoJ3JlcGxhY2VNZXJnZScsIHRydWUpXG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmF1bHRzKHtcbiAgICAgIGN1cnJlbnRJbmRleDogdGltZWxpbmVNb2RlbC5vcHRpb24uY3VycmVudEluZGV4XG4gICAgfSwgcGF5bG9hZCk7XG4gIH0pO1xuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgIHR5cGU6ICd0aW1lbGluZVBsYXlDaGFuZ2UnLFxuICAgIGV2ZW50OiAndGltZWxpbmVQbGF5Q2hhbmdlZCcsXG4gICAgdXBkYXRlOiAndXBkYXRlJ1xuICB9LCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICAgIHZhciB0aW1lbGluZU1vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3RpbWVsaW5lJyk7XG4gICAgaWYgKHRpbWVsaW5lTW9kZWwgJiYgcGF5bG9hZC5wbGF5U3RhdGUgIT0gbnVsbCkge1xuICAgICAgdGltZWxpbmVNb2RlbC5zZXRQbGF5U3RhdGUocGF5bG9hZC5wbGF5U3RhdGUpO1xuICAgIH1cbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG4vLyBAdHMtbm9jaGVja1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aW1lbGluZVByZXByb2Nlc3NvcihvcHRpb24pIHtcbiAgdmFyIHRpbWVsaW5lT3B0ID0gb3B0aW9uICYmIG9wdGlvbi50aW1lbGluZTtcbiAgaWYgKCF6clV0aWwuaXNBcnJheSh0aW1lbGluZU9wdCkpIHtcbiAgICB0aW1lbGluZU9wdCA9IHRpbWVsaW5lT3B0ID8gW3RpbWVsaW5lT3B0XSA6IFtdO1xuICB9XG4gIHpyVXRpbC5lYWNoKHRpbWVsaW5lT3B0LCBmdW5jdGlvbiAob3B0KSB7XG4gICAgaWYgKCFvcHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29tcGF0aWJsZUVDMihvcHQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNvbXBhdGlibGVFQzIob3B0KSB7XG4gIHZhciB0eXBlID0gb3B0LnR5cGU7XG4gIHZhciBlYzJUeXBlcyA9IHtcbiAgICAnbnVtYmVyJzogJ3ZhbHVlJyxcbiAgICAndGltZSc6ICd0aW1lJ1xuICB9O1xuICAvLyBDb21wYXRpYmxlIHdpdGggZWMyXG4gIGlmIChlYzJUeXBlc1t0eXBlXSkge1xuICAgIG9wdC5heGlzVHlwZSA9IGVjMlR5cGVzW3R5cGVdO1xuICAgIGRlbGV0ZSBvcHQudHlwZTtcbiAgfVxuICB0cmFuc2Zlckl0ZW0ob3B0KTtcbiAgaWYgKGhhcyhvcHQsICdjb250cm9sUG9zaXRpb24nKSkge1xuICAgIHZhciBjb250cm9sU3R5bGUgPSBvcHQuY29udHJvbFN0eWxlIHx8IChvcHQuY29udHJvbFN0eWxlID0ge30pO1xuICAgIGlmICghaGFzKGNvbnRyb2xTdHlsZSwgJ3Bvc2l0aW9uJykpIHtcbiAgICAgIGNvbnRyb2xTdHlsZS5wb3NpdGlvbiA9IG9wdC5jb250cm9sUG9zaXRpb247XG4gICAgfVxuICAgIGlmIChjb250cm9sU3R5bGUucG9zaXRpb24gPT09ICdub25lJyAmJiAhaGFzKGNvbnRyb2xTdHlsZSwgJ3Nob3cnKSkge1xuICAgICAgY29udHJvbFN0eWxlLnNob3cgPSBmYWxzZTtcbiAgICAgIGRlbGV0ZSBjb250cm9sU3R5bGUucG9zaXRpb247XG4gICAgfVxuICAgIGRlbGV0ZSBvcHQuY29udHJvbFBvc2l0aW9uO1xuICB9XG4gIHpyVXRpbC5lYWNoKG9wdC5kYXRhIHx8IFtdLCBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcbiAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGRhdGFJdGVtKSAmJiAhenJVdGlsLmlzQXJyYXkoZGF0YUl0ZW0pKSB7XG4gICAgICBpZiAoIWhhcyhkYXRhSXRlbSwgJ3ZhbHVlJykgJiYgaGFzKGRhdGFJdGVtLCAnbmFtZScpKSB7XG4gICAgICAgIC8vIEluIGVjMiwgdXNpbmcgbmFtZSBhcyB2YWx1ZS5cbiAgICAgICAgZGF0YUl0ZW0udmFsdWUgPSBkYXRhSXRlbS5uYW1lO1xuICAgICAgfVxuICAgICAgdHJhbnNmZXJJdGVtKGRhdGFJdGVtKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdHJhbnNmZXJJdGVtKG9wdCkge1xuICB2YXIgaXRlbVN0eWxlID0gb3B0Lml0ZW1TdHlsZSB8fCAob3B0Lml0ZW1TdHlsZSA9IHt9KTtcbiAgdmFyIGl0ZW1TdHlsZUVtcGhhc2lzID0gaXRlbVN0eWxlLmVtcGhhc2lzIHx8IChpdGVtU3R5bGUuZW1waGFzaXMgPSB7fSk7XG4gIC8vIFRyYW5zZmVyIGxhYmVsIG91dFxuICB2YXIgbGFiZWwgPSBvcHQubGFiZWwgfHwgb3B0LmxhYmVsIHx8IHt9O1xuICB2YXIgbGFiZWxOb3JtYWwgPSBsYWJlbC5ub3JtYWwgfHwgKGxhYmVsLm5vcm1hbCA9IHt9KTtcbiAgdmFyIGV4Y2x1ZGVMYWJlbEF0dHIgPSB7XG4gICAgbm9ybWFsOiAxLFxuICAgIGVtcGhhc2lzOiAxXG4gIH07XG4gIHpyVXRpbC5lYWNoKGxhYmVsLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAoIWV4Y2x1ZGVMYWJlbEF0dHJbbmFtZV0gJiYgIWhhcyhsYWJlbE5vcm1hbCwgbmFtZSkpIHtcbiAgICAgIGxhYmVsTm9ybWFsW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKGl0ZW1TdHlsZUVtcGhhc2lzLmxhYmVsICYmICFoYXMobGFiZWwsICdlbXBoYXNpcycpKSB7XG4gICAgbGFiZWwuZW1waGFzaXMgPSBpdGVtU3R5bGVFbXBoYXNpcy5sYWJlbDtcbiAgICBkZWxldGUgaXRlbVN0eWxlRW1waGFzaXMubGFiZWw7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhcyhvYmosIGF0dHIpIHtcbiAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShhdHRyKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuaW1wb3J0IFNsaWRlclRpbWVsaW5lTW9kZWwgZnJvbSAnLi9TbGlkZXJUaW1lbGluZU1vZGVsLmpzJztcbmltcG9ydCBTbGlkZXJUaW1lbGluZVZpZXcgZnJvbSAnLi9TbGlkZXJUaW1lbGluZVZpZXcuanMnO1xuaW1wb3J0IHsgaW5zdGFsbFRpbWVsaW5lQWN0aW9uIH0gZnJvbSAnLi90aW1lbGluZUFjdGlvbi5qcyc7XG5pbXBvcnQgcHJlcHJvY2Vzc29yIGZyb20gJy4vcHJlcHJvY2Vzc29yLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChTbGlkZXJUaW1lbGluZU1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhTbGlkZXJUaW1lbGluZVZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyKCd0aW1lbGluZScsIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBPbmx5IHNsaWRlciBub3cuXG4gICAgcmV0dXJuICdzbGlkZXInO1xuICB9KTtcbiAgaW5zdGFsbFRpbWVsaW5lQWN0aW9uKHJlZ2lzdGVycyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByZXByb2Nlc3NvcihwcmVwcm9jZXNzb3IpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///42751\n")},68241:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ install)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _extension_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3087);\n/* harmony import */ var _view_Component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59109);\n/* harmony import */ var _axis_SingleAxisView_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(67688);\n/* harmony import */ var _coord_axisModelCreator_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(59470);\n/* harmony import */ var _coord_single_AxisModel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(86351);\n/* harmony import */ var _coord_single_singleCreator_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(15787);\n/* harmony import */ var _axisPointer_install_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(46524);\n/* harmony import */ var _axis_AxisView_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(22480);\n/* harmony import */ var _axisPointer_SingleAxisPointer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(76081);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\nvar SingleView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(SingleView, _super);\n  function SingleView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = SingleView.type;\n    return _this;\n  }\n  SingleView.type = \'single\';\n  return SingleView;\n}(_view_Component_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);\nfunction install(registers) {\n  (0,_extension_js__WEBPACK_IMPORTED_MODULE_2__/* .use */ .Y)(_axisPointer_install_js__WEBPACK_IMPORTED_MODULE_3__/* .install */ .a);\n  _axis_AxisView_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.registerAxisPointerClass(\'SingleAxisPointer\', _axisPointer_SingleAxisPointer_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A);\n  registers.registerComponentView(SingleView);\n  // Axis\n  registers.registerComponentView(_axis_SingleAxisView_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A);\n  registers.registerComponentModel(_coord_single_AxisModel_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A);\n  (0,_coord_axisModelCreator_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(registers, \'single\', _coord_single_AxisModel_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A, _coord_single_AxisModel_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.defaultOption);\n  registers.registerCoordinateSystem(\'single\', _coord_single_singleCreator_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjgyNDEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9zaW5nbGVBeGlzL2luc3RhbGwuanM/NDhmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgdXNlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9uLmpzJztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50LmpzJztcbmltcG9ydCBTaW5nbGVBeGlzVmlldyBmcm9tICcuLi9heGlzL1NpbmdsZUF4aXNWaWV3LmpzJztcbmltcG9ydCBheGlzTW9kZWxDcmVhdG9yIGZyb20gJy4uLy4uL2Nvb3JkL2F4aXNNb2RlbENyZWF0b3IuanMnO1xuaW1wb3J0IFNpbmdsZUF4aXNNb2RlbCBmcm9tICcuLi8uLi9jb29yZC9zaW5nbGUvQXhpc01vZGVsLmpzJztcbmltcG9ydCBzaW5nbGVDcmVhdG9yIGZyb20gJy4uLy4uL2Nvb3JkL3NpbmdsZS9zaW5nbGVDcmVhdG9yLmpzJztcbmltcG9ydCB7IGluc3RhbGwgYXMgaW5zdGFsbEF4aXNQb2ludGVyIH0gZnJvbSAnLi4vYXhpc1BvaW50ZXIvaW5zdGFsbC5qcyc7XG5pbXBvcnQgQXhpc1ZpZXcgZnJvbSAnLi4vYXhpcy9BeGlzVmlldy5qcyc7XG5pbXBvcnQgU2luZ2xlQXhpc1BvaW50ZXIgZnJvbSAnLi4vYXhpc1BvaW50ZXIvU2luZ2xlQXhpc1BvaW50ZXIuanMnO1xudmFyIFNpbmdsZVZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2luZ2xlVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gU2luZ2xlVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gU2luZ2xlVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBTaW5nbGVWaWV3LnR5cGUgPSAnc2luZ2xlJztcbiAgcmV0dXJuIFNpbmdsZVZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHVzZShpbnN0YWxsQXhpc1BvaW50ZXIpO1xuICBBeGlzVmlldy5yZWdpc3RlckF4aXNQb2ludGVyQ2xhc3MoJ1NpbmdsZUF4aXNQb2ludGVyJywgU2luZ2xlQXhpc1BvaW50ZXIpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KFNpbmdsZVZpZXcpO1xuICAvLyBBeGlzXG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoU2luZ2xlQXhpc1ZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChTaW5nbGVBeGlzTW9kZWwpO1xuICBheGlzTW9kZWxDcmVhdG9yKHJlZ2lzdGVycywgJ3NpbmdsZScsIFNpbmdsZUF4aXNNb2RlbCwgU2luZ2xlQXhpc01vZGVsLmRlZmF1bHRPcHRpb24pO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb29yZGluYXRlU3lzdGVtKCdzaW5nbGUnLCBzaW5nbGVDcmVhdG9yKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///68241\n')},74064:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ install)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32322);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(30010);\n/* harmony import */ var _util_innerStore_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(69622);\n/* harmony import */ var _label_labelStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89632);\n/* harmony import */ var _util_layout_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(34253);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15915);\n/* harmony import */ var _view_Component_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(59109);\n/* harmony import */ var _util_format_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(83412);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\nvar TitleModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(TitleModel, _super);\n  function TitleModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = TitleModel.type;\n    _this.layoutMode = {\n      type: 'box',\n      ignoreSize: true\n    };\n    return _this;\n  }\n  TitleModel.type = 'title';\n  TitleModel.defaultOption = {\n    // zlevel: 0,\n    z: 6,\n    show: true,\n    text: '',\n    target: 'blank',\n    subtext: '',\n    subtarget: 'blank',\n    left: 0,\n    top: 0,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderColor: '#ccc',\n    borderWidth: 0,\n    padding: 5,\n    itemGap: 10,\n    textStyle: {\n      fontSize: 18,\n      fontWeight: 'bold',\n      color: '#464646'\n    },\n    subtextStyle: {\n      fontSize: 12,\n      color: '#6E7079'\n    }\n  };\n  return TitleModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A);\n// View\nvar TitleView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(TitleView, _super);\n  function TitleView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = TitleView.type;\n    return _this;\n  }\n  TitleView.prototype.render = function (titleModel, ecModel, api) {\n    this.group.removeAll();\n    if (!titleModel.get('show')) {\n      return;\n    }\n    var group = this.group;\n    var textStyleModel = titleModel.getModel('textStyle');\n    var subtextStyleModel = titleModel.getModel('subtextStyle');\n    var textAlign = titleModel.get('textAlign');\n    var textVerticalAlign = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.retrieve2(titleModel.get('textBaseline'), titleModel.get('textVerticalAlign'));\n    var textEl = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .Ay({\n      style: (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_4__/* .createTextStyle */ .VB)(textStyleModel, {\n        text: titleModel.get('text'),\n        fill: textStyleModel.getTextColor()\n      }, {\n        disableBox: true\n      }),\n      z2: 10\n    });\n    var textRect = textEl.getBoundingRect();\n    var subText = titleModel.get('subtext');\n    var subTextEl = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .Ay({\n      style: (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_4__/* .createTextStyle */ .VB)(subtextStyleModel, {\n        text: subText,\n        fill: subtextStyleModel.getTextColor(),\n        y: textRect.height + titleModel.get('itemGap'),\n        verticalAlign: 'top'\n      }, {\n        disableBox: true\n      }),\n      z2: 10\n    });\n    var link = titleModel.get('link');\n    var sublink = titleModel.get('sublink');\n    var triggerEvent = titleModel.get('triggerEvent', true);\n    textEl.silent = !link && !triggerEvent;\n    subTextEl.silent = !sublink && !triggerEvent;\n    if (link) {\n      textEl.on('click', function () {\n        (0,_util_format_js__WEBPACK_IMPORTED_MODULE_5__/* .windowOpen */ .JW)(link, '_' + titleModel.get('target'));\n      });\n    }\n    if (sublink) {\n      subTextEl.on('click', function () {\n        (0,_util_format_js__WEBPACK_IMPORTED_MODULE_5__/* .windowOpen */ .JW)(sublink, '_' + titleModel.get('subtarget'));\n      });\n    }\n    (0,_util_innerStore_js__WEBPACK_IMPORTED_MODULE_6__/* .getECData */ .z)(textEl).eventData = (0,_util_innerStore_js__WEBPACK_IMPORTED_MODULE_6__/* .getECData */ .z)(subTextEl).eventData = triggerEvent ? {\n      componentType: 'title',\n      componentIndex: titleModel.componentIndex\n    } : null;\n    group.add(textEl);\n    subText && group.add(subTextEl);\n    // If no subText, but add subTextEl, there will be an empty line.\n    var groupRect = group.getBoundingRect();\n    var layoutOption = titleModel.getBoxLayoutParams();\n    layoutOption.width = groupRect.width;\n    layoutOption.height = groupRect.height;\n    var layoutRect = (0,_util_layout_js__WEBPACK_IMPORTED_MODULE_7__/* .getLayoutRect */ .dV)(layoutOption, {\n      width: api.getWidth(),\n      height: api.getHeight()\n    }, titleModel.get('padding'));\n    // Adjust text align based on position\n    if (!textAlign) {\n      // Align left if title is on the left. center and right is same\n      textAlign = titleModel.get('left') || titleModel.get('right');\n      // @ts-ignore\n      if (textAlign === 'middle') {\n        textAlign = 'center';\n      }\n      // Adjust layout by text align\n      if (textAlign === 'right') {\n        layoutRect.x += layoutRect.width;\n      } else if (textAlign === 'center') {\n        layoutRect.x += layoutRect.width / 2;\n      }\n    }\n    if (!textVerticalAlign) {\n      textVerticalAlign = titleModel.get('top') || titleModel.get('bottom');\n      // @ts-ignore\n      if (textVerticalAlign === 'center') {\n        textVerticalAlign = 'middle';\n      }\n      if (textVerticalAlign === 'bottom') {\n        layoutRect.y += layoutRect.height;\n      } else if (textVerticalAlign === 'middle') {\n        layoutRect.y += layoutRect.height / 2;\n      }\n      textVerticalAlign = textVerticalAlign || 'top';\n    }\n    group.x = layoutRect.x;\n    group.y = layoutRect.y;\n    group.markRedraw();\n    var alignStyle = {\n      align: textAlign,\n      verticalAlign: textVerticalAlign\n    };\n    textEl.setStyle(alignStyle);\n    subTextEl.setStyle(alignStyle);\n    // Render background\n    // Get groupRect again because textAlign has been changed\n    groupRect = group.getBoundingRect();\n    var padding = layoutRect.margin;\n    var style = titleModel.getItemStyle(['color', 'opacity']);\n    style.fill = titleModel.get('backgroundColor');\n    var rect = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .A({\n      shape: {\n        x: groupRect.x - padding[3],\n        y: groupRect.y - padding[0],\n        width: groupRect.width + padding[1] + padding[3],\n        height: groupRect.height + padding[0] + padding[2],\n        r: titleModel.get('borderRadius')\n      },\n      style: style,\n      subPixelOptimize: true,\n      silent: true\n    });\n    group.add(rect);\n  };\n  TitleView.type = 'title';\n  return TitleView;\n}(_view_Component_js__WEBPACK_IMPORTED_MODULE_9__/* [\"default\"] */ .A);\nfunction install(registers) {\n  registers.registerComponentModel(TitleModel);\n  registers.registerComponentView(TitleView);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQwNjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdGl0bGUvaW5zdGFsbC5qcz84OTIyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVUZXh0U3R5bGUgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlLmpzJztcbmltcG9ydCB7IGdldExheW91dFJlY3QgfSBmcm9tICcuLi8uLi91dGlsL2xheW91dC5qcyc7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvQ29tcG9uZW50LmpzJztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50LmpzJztcbmltcG9ydCB7IHdpbmRvd09wZW4gfSBmcm9tICcuLi8uLi91dGlsL2Zvcm1hdC5qcyc7XG52YXIgVGl0bGVNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUaXRsZU1vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBUaXRsZU1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBUaXRsZU1vZGVsLnR5cGU7XG4gICAgX3RoaXMubGF5b3V0TW9kZSA9IHtcbiAgICAgIHR5cGU6ICdib3gnLFxuICAgICAgaWdub3JlU2l6ZTogdHJ1ZVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFRpdGxlTW9kZWwudHlwZSA9ICd0aXRsZSc7XG4gIFRpdGxlTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAvLyB6bGV2ZWw6IDAsXG4gICAgejogNixcbiAgICBzaG93OiB0cnVlLFxuICAgIHRleHQ6ICcnLFxuICAgIHRhcmdldDogJ2JsYW5rJyxcbiAgICBzdWJ0ZXh0OiAnJyxcbiAgICBzdWJ0YXJnZXQ6ICdibGFuaycsXG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgYm9yZGVyQ29sb3I6ICcjY2NjJyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBwYWRkaW5nOiA1LFxuICAgIGl0ZW1HYXA6IDEwLFxuICAgIHRleHRTdHlsZToge1xuICAgICAgZm9udFNpemU6IDE4LFxuICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgY29sb3I6ICcjNDY0NjQ2J1xuICAgIH0sXG4gICAgc3VidGV4dFN0eWxlOiB7XG4gICAgICBmb250U2l6ZTogMTIsXG4gICAgICBjb2xvcjogJyM2RTcwNzknXG4gICAgfVxuICB9O1xuICByZXR1cm4gVGl0bGVNb2RlbDtcbn0oQ29tcG9uZW50TW9kZWwpO1xuLy8gVmlld1xudmFyIFRpdGxlVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUaXRsZVZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFRpdGxlVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gVGl0bGVWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFRpdGxlVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHRpdGxlTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgaWYgKCF0aXRsZU1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdGl0bGVNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgdmFyIHN1YnRleHRTdHlsZU1vZGVsID0gdGl0bGVNb2RlbC5nZXRNb2RlbCgnc3VidGV4dFN0eWxlJyk7XG4gICAgdmFyIHRleHRBbGlnbiA9IHRpdGxlTW9kZWwuZ2V0KCd0ZXh0QWxpZ24nKTtcbiAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSB6clV0aWwucmV0cmlldmUyKHRpdGxlTW9kZWwuZ2V0KCd0ZXh0QmFzZWxpbmUnKSwgdGl0bGVNb2RlbC5nZXQoJ3RleHRWZXJ0aWNhbEFsaWduJykpO1xuICAgIHZhciB0ZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUodGV4dFN0eWxlTW9kZWwsIHtcbiAgICAgICAgdGV4dDogdGl0bGVNb2RlbC5nZXQoJ3RleHQnKSxcbiAgICAgICAgZmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKClcbiAgICAgIH0sIHtcbiAgICAgICAgZGlzYWJsZUJveDogdHJ1ZVxuICAgICAgfSksXG4gICAgICB6MjogMTBcbiAgICB9KTtcbiAgICB2YXIgdGV4dFJlY3QgPSB0ZXh0RWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIHN1YlRleHQgPSB0aXRsZU1vZGVsLmdldCgnc3VidGV4dCcpO1xuICAgIHZhciBzdWJUZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUoc3VidGV4dFN0eWxlTW9kZWwsIHtcbiAgICAgICAgdGV4dDogc3ViVGV4dCxcbiAgICAgICAgZmlsbDogc3VidGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCksXG4gICAgICAgIHk6IHRleHRSZWN0LmhlaWdodCArIHRpdGxlTW9kZWwuZ2V0KCdpdGVtR2FwJyksXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnXG4gICAgICB9LCB7XG4gICAgICAgIGRpc2FibGVCb3g6IHRydWVcbiAgICAgIH0pLFxuICAgICAgejI6IDEwXG4gICAgfSk7XG4gICAgdmFyIGxpbmsgPSB0aXRsZU1vZGVsLmdldCgnbGluaycpO1xuICAgIHZhciBzdWJsaW5rID0gdGl0bGVNb2RlbC5nZXQoJ3N1YmxpbmsnKTtcbiAgICB2YXIgdHJpZ2dlckV2ZW50ID0gdGl0bGVNb2RlbC5nZXQoJ3RyaWdnZXJFdmVudCcsIHRydWUpO1xuICAgIHRleHRFbC5zaWxlbnQgPSAhbGluayAmJiAhdHJpZ2dlckV2ZW50O1xuICAgIHN1YlRleHRFbC5zaWxlbnQgPSAhc3VibGluayAmJiAhdHJpZ2dlckV2ZW50O1xuICAgIGlmIChsaW5rKSB7XG4gICAgICB0ZXh0RWwub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3dPcGVuKGxpbmssICdfJyArIHRpdGxlTW9kZWwuZ2V0KCd0YXJnZXQnKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN1YmxpbmspIHtcbiAgICAgIHN1YlRleHRFbC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvd09wZW4oc3VibGluaywgJ18nICsgdGl0bGVNb2RlbC5nZXQoJ3N1YnRhcmdldCcpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRFQ0RhdGEodGV4dEVsKS5ldmVudERhdGEgPSBnZXRFQ0RhdGEoc3ViVGV4dEVsKS5ldmVudERhdGEgPSB0cmlnZ2VyRXZlbnQgPyB7XG4gICAgICBjb21wb25lbnRUeXBlOiAndGl0bGUnLFxuICAgICAgY29tcG9uZW50SW5kZXg6IHRpdGxlTW9kZWwuY29tcG9uZW50SW5kZXhcbiAgICB9IDogbnVsbDtcbiAgICBncm91cC5hZGQodGV4dEVsKTtcbiAgICBzdWJUZXh0ICYmIGdyb3VwLmFkZChzdWJUZXh0RWwpO1xuICAgIC8vIElmIG5vIHN1YlRleHQsIGJ1dCBhZGQgc3ViVGV4dEVsLCB0aGVyZSB3aWxsIGJlIGFuIGVtcHR5IGxpbmUuXG4gICAgdmFyIGdyb3VwUmVjdCA9IGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBsYXlvdXRPcHRpb24gPSB0aXRsZU1vZGVsLmdldEJveExheW91dFBhcmFtcygpO1xuICAgIGxheW91dE9wdGlvbi53aWR0aCA9IGdyb3VwUmVjdC53aWR0aDtcbiAgICBsYXlvdXRPcHRpb24uaGVpZ2h0ID0gZ3JvdXBSZWN0LmhlaWdodDtcbiAgICB2YXIgbGF5b3V0UmVjdCA9IGdldExheW91dFJlY3QobGF5b3V0T3B0aW9uLCB7XG4gICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgIH0sIHRpdGxlTW9kZWwuZ2V0KCdwYWRkaW5nJykpO1xuICAgIC8vIEFkanVzdCB0ZXh0IGFsaWduIGJhc2VkIG9uIHBvc2l0aW9uXG4gICAgaWYgKCF0ZXh0QWxpZ24pIHtcbiAgICAgIC8vIEFsaWduIGxlZnQgaWYgdGl0bGUgaXMgb24gdGhlIGxlZnQuIGNlbnRlciBhbmQgcmlnaHQgaXMgc2FtZVxuICAgICAgdGV4dEFsaWduID0gdGl0bGVNb2RlbC5nZXQoJ2xlZnQnKSB8fCB0aXRsZU1vZGVsLmdldCgncmlnaHQnKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdtaWRkbGUnKSB7XG4gICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgfVxuICAgICAgLy8gQWRqdXN0IGxheW91dCBieSB0ZXh0IGFsaWduXG4gICAgICBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIGxheW91dFJlY3QueCArPSBsYXlvdXRSZWN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGxheW91dFJlY3QueCArPSBsYXlvdXRSZWN0LndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0ZXh0VmVydGljYWxBbGlnbikge1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSB0aXRsZU1vZGVsLmdldCgndG9wJykgfHwgdGl0bGVNb2RlbC5nZXQoJ2JvdHRvbScpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgfVxuICAgICAgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICBsYXlvdXRSZWN0LnkgKz0gbGF5b3V0UmVjdC5oZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnbWlkZGxlJykge1xuICAgICAgICBsYXlvdXRSZWN0LnkgKz0gbGF5b3V0UmVjdC5oZWlnaHQgLyAyO1xuICAgICAgfVxuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSB0ZXh0VmVydGljYWxBbGlnbiB8fCAndG9wJztcbiAgICB9XG4gICAgZ3JvdXAueCA9IGxheW91dFJlY3QueDtcbiAgICBncm91cC55ID0gbGF5b3V0UmVjdC55O1xuICAgIGdyb3VwLm1hcmtSZWRyYXcoKTtcbiAgICB2YXIgYWxpZ25TdHlsZSA9IHtcbiAgICAgIGFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICB2ZXJ0aWNhbEFsaWduOiB0ZXh0VmVydGljYWxBbGlnblxuICAgIH07XG4gICAgdGV4dEVsLnNldFN0eWxlKGFsaWduU3R5bGUpO1xuICAgIHN1YlRleHRFbC5zZXRTdHlsZShhbGlnblN0eWxlKTtcbiAgICAvLyBSZW5kZXIgYmFja2dyb3VuZFxuICAgIC8vIEdldCBncm91cFJlY3QgYWdhaW4gYmVjYXVzZSB0ZXh0QWxpZ24gaGFzIGJlZW4gY2hhbmdlZFxuICAgIGdyb3VwUmVjdCA9IGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBwYWRkaW5nID0gbGF5b3V0UmVjdC5tYXJnaW47XG4gICAgdmFyIHN0eWxlID0gdGl0bGVNb2RlbC5nZXRJdGVtU3R5bGUoWydjb2xvcicsICdvcGFjaXR5J10pO1xuICAgIHN0eWxlLmZpbGwgPSB0aXRsZU1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG4gICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHg6IGdyb3VwUmVjdC54IC0gcGFkZGluZ1szXSxcbiAgICAgICAgeTogZ3JvdXBSZWN0LnkgLSBwYWRkaW5nWzBdLFxuICAgICAgICB3aWR0aDogZ3JvdXBSZWN0LndpZHRoICsgcGFkZGluZ1sxXSArIHBhZGRpbmdbM10sXG4gICAgICAgIGhlaWdodDogZ3JvdXBSZWN0LmhlaWdodCArIHBhZGRpbmdbMF0gKyBwYWRkaW5nWzJdLFxuICAgICAgICByOiB0aXRsZU1vZGVsLmdldCgnYm9yZGVyUmFkaXVzJylcbiAgICAgIH0sXG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICBzdWJQaXhlbE9wdGltaXplOiB0cnVlLFxuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSk7XG4gICAgZ3JvdXAuYWRkKHJlY3QpO1xuICB9O1xuICBUaXRsZVZpZXcudHlwZSA9ICd0aXRsZSc7XG4gIHJldHVybiBUaXRsZVZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudE1vZGVsKFRpdGxlTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KFRpdGxlVmlldyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///74064\n")}}]);