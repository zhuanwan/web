"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[6392],{6754:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ es_progress)\n});\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(96540);\n// EXTERNAL MODULE: ./node_modules/@ant-design/fast-color/es/index.js + 1 modules\nvar es = __webpack_require__(2616);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/CheckCircleFilled.js + 1 modules\nvar CheckCircleFilled = __webpack_require__(38811);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/CheckOutlined.js + 1 modules\nvar CheckOutlined = __webpack_require__(26067);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/CloseCircleFilled.js + 1 modules\nvar CloseCircleFilled = __webpack_require__(36029);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/CloseOutlined.js + 1 modules\nvar CloseOutlined = __webpack_require__(47852);\n// EXTERNAL MODULE: ./node_modules/classnames/index.js\nvar classnames = __webpack_require__(46942);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n// EXTERNAL MODULE: ./node_modules/rc-util/es/omit.js\nvar omit = __webpack_require__(19853);\n// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js\nvar context = __webpack_require__(62279);\n// EXTERNAL MODULE: ./node_modules/rc-progress/es/index.js + 6 modules\nvar rc_progress_es = __webpack_require__(71559);\n// EXTERNAL MODULE: ./node_modules/antd/es/tooltip/index.js + 4 modules\nvar tooltip = __webpack_require__(30485);\n// EXTERNAL MODULE: ./node_modules/@ant-design/colors/es/index.js + 2 modules\nvar colors_es = __webpack_require__(45748);\n;// ./node_modules/antd/es/progress/utils.js\n\nfunction validProgress(progress) {\n  if (!progress || progress < 0) {\n    return 0;\n  }\n  if (progress > 100) {\n    return 100;\n  }\n  return progress;\n}\nfunction getSuccessPercent(_ref) {\n  let {\n    success,\n    successPercent\n  } = _ref;\n  let percent = successPercent;\n  /** @deprecated Use `percent` instead */\n  if (success && 'progress' in success) {\n    percent = success.progress;\n  }\n  if (success && 'percent' in success) {\n    percent = success.percent;\n  }\n  return percent;\n}\nconst getPercentage = _ref2 => {\n  let {\n    percent,\n    success,\n    successPercent\n  } = _ref2;\n  const realSuccessPercent = validProgress(getSuccessPercent({\n    success,\n    successPercent\n  }));\n  return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];\n};\nconst getStrokeColor = _ref3 => {\n  let {\n    success = {},\n    strokeColor\n  } = _ref3;\n  const {\n    strokeColor: successColor\n  } = success;\n  return [successColor || colors_es/* presetPrimaryColors */.uy.green, strokeColor || null];\n};\nconst getSize = (size, type, extra) => {\n  var _a, _b, _c, _d;\n  let width = -1;\n  let height = -1;\n  if (type === 'step') {\n    const steps = extra.steps;\n    const strokeWidth = extra.strokeWidth;\n    if (typeof size === 'string' || typeof size === 'undefined') {\n      width = size === 'small' ? 2 : 14;\n      height = strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 8;\n    } else if (typeof size === 'number') {\n      [width, height] = [size, size];\n    } else {\n      [width = 14, height = 8] = Array.isArray(size) ? size : [size.width, size.height];\n    }\n    width *= steps;\n  } else if (type === 'line') {\n    const strokeWidth = extra === null || extra === void 0 ? void 0 : extra.strokeWidth;\n    if (typeof size === 'string' || typeof size === 'undefined') {\n      height = strokeWidth || (size === 'small' ? 6 : 8);\n    } else if (typeof size === 'number') {\n      [width, height] = [size, size];\n    } else {\n      [width = -1, height = 8] = Array.isArray(size) ? size : [size.width, size.height];\n    }\n  } else if (type === 'circle' || type === 'dashboard') {\n    if (typeof size === 'string' || typeof size === 'undefined') {\n      [width, height] = size === 'small' ? [60, 60] : [120, 120];\n    } else if (typeof size === 'number') {\n      [width, height] = [size, size];\n    } else if (Array.isArray(size)) {\n      width = (_b = (_a = size[0]) !== null && _a !== void 0 ? _a : size[1]) !== null && _b !== void 0 ? _b : 120;\n      height = (_d = (_c = size[0]) !== null && _c !== void 0 ? _c : size[1]) !== null && _d !== void 0 ? _d : 120;\n    }\n  }\n  return [width, height];\n};\n;// ./node_modules/antd/es/progress/Circle.js\n\"use client\";\n\n\n\n\n\n\nconst CIRCLE_MIN_STROKE_WIDTH = 3;\nconst getMinPercent = width => CIRCLE_MIN_STROKE_WIDTH / width * 100;\nconst Circle = props => {\n  const {\n    prefixCls,\n    trailColor = null,\n    strokeLinecap = 'round',\n    gapPosition,\n    gapDegree,\n    width: originWidth = 120,\n    type,\n    children,\n    success,\n    size = originWidth,\n    steps\n  } = props;\n  const [width, height] = getSize(size, 'circle');\n  let {\n    strokeWidth\n  } = props;\n  if (strokeWidth === undefined) {\n    strokeWidth = Math.max(getMinPercent(width), 6);\n  }\n  const circleStyle = {\n    width,\n    height,\n    fontSize: width * 0.15 + 6\n  };\n  const realGapDegree = react.useMemo(() => {\n    // Support gapDeg = 0 when type = 'dashboard'\n    if (gapDegree || gapDegree === 0) {\n      return gapDegree;\n    }\n    if (type === 'dashboard') {\n      return 75;\n    }\n    return undefined;\n  }, [gapDegree, type]);\n  const percentArray = getPercentage(props);\n  const gapPos = gapPosition || type === 'dashboard' && 'bottom' || undefined;\n  // using className to style stroke color\n  const isGradient = Object.prototype.toString.call(props.strokeColor) === '[object Object]';\n  const strokeColor = getStrokeColor({\n    success,\n    strokeColor: props.strokeColor\n  });\n  const wrapperClassName = classnames_default()(`${prefixCls}-inner`, {\n    [`${prefixCls}-circle-gradient`]: isGradient\n  });\n  const circleContent = /*#__PURE__*/react.createElement(rc_progress_es/* Circle */.jl, {\n    steps: steps,\n    percent: steps ? percentArray[1] : percentArray,\n    strokeWidth: strokeWidth,\n    trailWidth: strokeWidth,\n    strokeColor: steps ? strokeColor[1] : strokeColor,\n    strokeLinecap: strokeLinecap,\n    trailColor: trailColor,\n    prefixCls: prefixCls,\n    gapDegree: realGapDegree,\n    gapPosition: gapPos\n  });\n  const smallCircle = width <= 20;\n  const node = /*#__PURE__*/react.createElement(\"div\", {\n    className: wrapperClassName,\n    style: circleStyle\n  }, circleContent, !smallCircle && children);\n  if (smallCircle) {\n    return /*#__PURE__*/react.createElement(tooltip/* default */.A, {\n      title: children\n    }, node);\n  }\n  return node;\n};\n/* harmony default export */ const progress_Circle = (Circle);\n// EXTERNAL MODULE: ./node_modules/@ant-design/cssinjs/es/index.js + 30 modules\nvar cssinjs_es = __webpack_require__(67466);\n// EXTERNAL MODULE: ./node_modules/antd/es/style/index.js\nvar style = __webpack_require__(25905);\n// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/genStyleUtils.js\nvar genStyleUtils = __webpack_require__(37358);\n// EXTERNAL MODULE: ./node_modules/@ant-design/cssinjs-utils/es/index.js + 12 modules\nvar cssinjs_utils_es = __webpack_require__(14277);\n;// ./node_modules/antd/es/progress/style/index.js\n\n\n\nconst LineStrokeColorVar = '--progress-line-stroke-color';\nconst Percent = '--progress-percent';\nconst genAntProgressActive = isRtl => {\n  const direction = isRtl ? '100%' : '-100%';\n  return new cssinjs_es/* Keyframes */.Mo(`antProgress${isRtl ? 'RTL' : 'LTR'}Active`, {\n    '0%': {\n      transform: `translateX(${direction}) scaleX(0)`,\n      opacity: 0.1\n    },\n    '20%': {\n      transform: `translateX(${direction}) scaleX(0)`,\n      opacity: 0.5\n    },\n    to: {\n      transform: 'translateX(0) scaleX(1)',\n      opacity: 0\n    }\n  });\n};\nconst genBaseStyle = token => {\n  const {\n    componentCls: progressCls,\n    iconCls: iconPrefixCls\n  } = token;\n  return {\n    [progressCls]: Object.assign(Object.assign({}, (0,style/* resetComponent */.dF)(token)), {\n      display: 'inline-block',\n      '&-rtl': {\n        direction: 'rtl'\n      },\n      '&-line': {\n        position: 'relative',\n        width: '100%',\n        fontSize: token.fontSize\n      },\n      [`${progressCls}-outer`]: {\n        display: 'inline-flex',\n        alignItems: 'center',\n        width: '100%'\n      },\n      [`${progressCls}-inner`]: {\n        position: 'relative',\n        display: 'inline-block',\n        width: '100%',\n        flex: 1,\n        overflow: 'hidden',\n        verticalAlign: 'middle',\n        backgroundColor: token.remainingColor,\n        borderRadius: token.lineBorderRadius\n      },\n      [`${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {\n        [`${progressCls}-circle-path`]: {\n          stroke: token.defaultColor\n        }\n      },\n      [`${progressCls}-success-bg, ${progressCls}-bg`]: {\n        position: 'relative',\n        background: token.defaultColor,\n        borderRadius: token.lineBorderRadius,\n        transition: `all ${token.motionDurationSlow} ${token.motionEaseInOutCirc}`\n      },\n      [`${progressCls}-layout-bottom`]: {\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        justifyContent: 'center',\n        [`${progressCls}-text`]: {\n          width: 'max-content',\n          marginInlineStart: 0,\n          marginTop: token.marginXXS\n        }\n      },\n      [`${progressCls}-bg`]: {\n        overflow: 'hidden',\n        '&::after': {\n          content: '\"\"',\n          background: {\n            _multi_value_: true,\n            value: ['inherit', `var(${LineStrokeColorVar})`]\n          },\n          height: '100%',\n          width: `calc(1 / var(${Percent}) * 100%)`,\n          display: 'block'\n        },\n        [`&${progressCls}-bg-inner`]: {\n          minWidth: 'max-content',\n          '&::after': {\n            content: 'none'\n          },\n          [`${progressCls}-text-inner`]: {\n            color: token.colorWhite,\n            [`&${progressCls}-text-bright`]: {\n              color: 'rgba(0, 0, 0, 0.45)'\n            }\n          }\n        }\n      },\n      [`${progressCls}-success-bg`]: {\n        position: 'absolute',\n        insetBlockStart: 0,\n        insetInlineStart: 0,\n        backgroundColor: token.colorSuccess\n      },\n      [`${progressCls}-text`]: {\n        display: 'inline-block',\n        marginInlineStart: token.marginXS,\n        color: token.colorText,\n        lineHeight: 1,\n        width: '2em',\n        whiteSpace: 'nowrap',\n        textAlign: 'start',\n        verticalAlign: 'middle',\n        wordBreak: 'normal',\n        [iconPrefixCls]: {\n          fontSize: token.fontSize\n        },\n        [`&${progressCls}-text-outer`]: {\n          width: 'max-content'\n        },\n        [`&${progressCls}-text-outer${progressCls}-text-start`]: {\n          width: 'max-content',\n          marginInlineStart: 0,\n          marginInlineEnd: token.marginXS\n        }\n      },\n      [`${progressCls}-text-inner`]: {\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        width: '100%',\n        height: '100%',\n        marginInlineStart: 0,\n        padding: `0 ${(0,cssinjs_es/* unit */.zA)(token.paddingXXS)}`,\n        [`&${progressCls}-text-start`]: {\n          justifyContent: 'start'\n        },\n        [`&${progressCls}-text-end`]: {\n          justifyContent: 'end'\n        }\n      },\n      [`&${progressCls}-status-active`]: {\n        [`${progressCls}-bg::before`]: {\n          position: 'absolute',\n          inset: 0,\n          backgroundColor: token.colorBgContainer,\n          borderRadius: token.lineBorderRadius,\n          opacity: 0,\n          animationName: genAntProgressActive(),\n          animationDuration: token.progressActiveMotionDuration,\n          animationTimingFunction: token.motionEaseOutQuint,\n          animationIterationCount: 'infinite',\n          content: '\"\"'\n        }\n      },\n      [`&${progressCls}-rtl${progressCls}-status-active`]: {\n        [`${progressCls}-bg::before`]: {\n          animationName: genAntProgressActive(true)\n        }\n      },\n      [`&${progressCls}-status-exception`]: {\n        [`${progressCls}-bg`]: {\n          backgroundColor: token.colorError\n        },\n        [`${progressCls}-text`]: {\n          color: token.colorError\n        }\n      },\n      [`&${progressCls}-status-exception ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {\n        [`${progressCls}-circle-path`]: {\n          stroke: token.colorError\n        }\n      },\n      [`&${progressCls}-status-success`]: {\n        [`${progressCls}-bg`]: {\n          backgroundColor: token.colorSuccess\n        },\n        [`${progressCls}-text`]: {\n          color: token.colorSuccess\n        }\n      },\n      [`&${progressCls}-status-success ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {\n        [`${progressCls}-circle-path`]: {\n          stroke: token.colorSuccess\n        }\n      }\n    })\n  };\n};\nconst genCircleStyle = token => {\n  const {\n    componentCls: progressCls,\n    iconCls: iconPrefixCls\n  } = token;\n  return {\n    [progressCls]: {\n      [`${progressCls}-circle-trail`]: {\n        stroke: token.remainingColor\n      },\n      [`&${progressCls}-circle ${progressCls}-inner`]: {\n        position: 'relative',\n        lineHeight: 1,\n        backgroundColor: 'transparent'\n      },\n      [`&${progressCls}-circle ${progressCls}-text`]: {\n        position: 'absolute',\n        insetBlockStart: '50%',\n        insetInlineStart: 0,\n        width: '100%',\n        margin: 0,\n        padding: 0,\n        color: token.circleTextColor,\n        fontSize: token.circleTextFontSize,\n        lineHeight: 1,\n        whiteSpace: 'normal',\n        textAlign: 'center',\n        transform: 'translateY(-50%)',\n        [iconPrefixCls]: {\n          fontSize: token.circleIconFontSize\n        }\n      },\n      [`${progressCls}-circle&-status-exception`]: {\n        [`${progressCls}-text`]: {\n          color: token.colorError\n        }\n      },\n      [`${progressCls}-circle&-status-success`]: {\n        [`${progressCls}-text`]: {\n          color: token.colorSuccess\n        }\n      }\n    },\n    [`${progressCls}-inline-circle`]: {\n      lineHeight: 1,\n      [`${progressCls}-inner`]: {\n        verticalAlign: 'bottom'\n      }\n    }\n  };\n};\nconst genStepStyle = token => {\n  const {\n    componentCls: progressCls\n  } = token;\n  return {\n    [progressCls]: {\n      [`${progressCls}-steps`]: {\n        display: 'inline-block',\n        '&-outer': {\n          display: 'flex',\n          flexDirection: 'row',\n          alignItems: 'center'\n        },\n        '&-item': {\n          flexShrink: 0,\n          minWidth: token.progressStepMinWidth,\n          marginInlineEnd: token.progressStepMarginInlineEnd,\n          backgroundColor: token.remainingColor,\n          transition: `all ${token.motionDurationSlow}`,\n          '&-active': {\n            backgroundColor: token.defaultColor\n          }\n        }\n      }\n    }\n  };\n};\nconst genSmallLine = token => {\n  const {\n    componentCls: progressCls,\n    iconCls: iconPrefixCls\n  } = token;\n  return {\n    [progressCls]: {\n      [`${progressCls}-small&-line, ${progressCls}-small&-line ${progressCls}-text ${iconPrefixCls}`]: {\n        fontSize: token.fontSizeSM\n      }\n    }\n  };\n};\nconst prepareComponentToken = token => ({\n  circleTextColor: token.colorText,\n  defaultColor: token.colorInfo,\n  remainingColor: token.colorFillSecondary,\n  lineBorderRadius: 100,\n  // magic for capsule shape, should be a very large number\n  circleTextFontSize: '1em',\n  circleIconFontSize: `${token.fontSize / token.fontSizeSM}em`\n});\n/* harmony default export */ const progress_style = ((0,genStyleUtils/* genStyleHooks */.OF)('Progress', token => {\n  const progressStepMarginInlineEnd = token.calc(token.marginXXS).div(2).equal();\n  const progressToken = (0,cssinjs_utils_es/* mergeToken */.oX)(token, {\n    progressStepMarginInlineEnd,\n    progressStepMinWidth: progressStepMarginInlineEnd,\n    progressActiveMotionDuration: '2.4s'\n  });\n  return [genBaseStyle(progressToken), genCircleStyle(progressToken), genStepStyle(progressToken), genSmallLine(progressToken)];\n}, prepareComponentToken));\n;// ./node_modules/antd/es/progress/Line.js\n\"use client\";\n\nvar __rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\n\n\n\n\n\n/**\n * @example\n *   {\n *     \"0%\": \"#afc163\",\n *     \"75%\": \"#009900\",\n *     \"50%\": \"green\", // ====> '#afc163 0%, #66FF00 25%, #00CC00 50%, #009900 75%, #ffffff 100%'\n *     \"25%\": \"#66FF00\",\n *     \"100%\": \"#ffffff\"\n *   }\n */\nconst sortGradient = gradients => {\n  let tempArr = [];\n  Object.keys(gradients).forEach(key => {\n    const formattedKey = parseFloat(key.replace(/%/g, ''));\n    if (!Number.isNaN(formattedKey)) {\n      tempArr.push({\n        key: formattedKey,\n        value: gradients[key]\n      });\n    }\n  });\n  tempArr = tempArr.sort((a, b) => a.key - b.key);\n  return tempArr.map(_ref => {\n    let {\n      key,\n      value\n    } = _ref;\n    return `${value} ${key}%`;\n  }).join(', ');\n};\n/**\n * Then this man came to realize the truth: Besides six pence, there is the moon. Besides bread and\n * butter, there is the bug. And... Besides women, there is the code.\n *\n * @example\n *   {\n *     \"0%\": \"#afc163\",\n *     \"25%\": \"#66FF00\",\n *     \"50%\": \"#00CC00\", // ====>  linear-gradient(to right, #afc163 0%, #66FF00 25%,\n *     \"75%\": \"#009900\", //        #00CC00 50%, #009900 75%, #ffffff 100%)\n *     \"100%\": \"#ffffff\"\n *   }\n */\nconst handleGradient = (strokeColor, directionConfig) => {\n  const {\n      from = colors_es/* presetPrimaryColors */.uy.blue,\n      to = colors_es/* presetPrimaryColors */.uy.blue,\n      direction = directionConfig === 'rtl' ? 'to left' : 'to right'\n    } = strokeColor,\n    rest = __rest(strokeColor, [\"from\", \"to\", \"direction\"]);\n  if (Object.keys(rest).length !== 0) {\n    const sortedGradients = sortGradient(rest);\n    const background = `linear-gradient(${direction}, ${sortedGradients})`;\n    return {\n      background,\n      [LineStrokeColorVar]: background\n    };\n  }\n  const background = `linear-gradient(${direction}, ${from}, ${to})`;\n  return {\n    background,\n    [LineStrokeColorVar]: background\n  };\n};\nconst Line = props => {\n  const {\n    prefixCls,\n    direction: directionConfig,\n    percent,\n    size,\n    strokeWidth,\n    strokeColor,\n    strokeLinecap = 'round',\n    children,\n    trailColor = null,\n    percentPosition,\n    success\n  } = props;\n  const {\n    align: infoAlign,\n    type: infoPosition\n  } = percentPosition;\n  const backgroundProps = strokeColor && typeof strokeColor !== 'string' ? handleGradient(strokeColor, directionConfig) : {\n    [LineStrokeColorVar]: strokeColor,\n    background: strokeColor\n  };\n  const borderRadius = strokeLinecap === 'square' || strokeLinecap === 'butt' ? 0 : undefined;\n  const mergedSize = size !== null && size !== void 0 ? size : [-1, strokeWidth || (size === 'small' ? 6 : 8)];\n  const [width, height] = getSize(mergedSize, 'line', {\n    strokeWidth\n  });\n  if (false) {}\n  const trailStyle = {\n    backgroundColor: trailColor || undefined,\n    borderRadius\n  };\n  const percentStyle = Object.assign(Object.assign({\n    width: `${validProgress(percent)}%`,\n    height,\n    borderRadius\n  }, backgroundProps), {\n    [Percent]: validProgress(percent) / 100\n  });\n  const successPercent = getSuccessPercent(props);\n  const successPercentStyle = {\n    width: `${validProgress(successPercent)}%`,\n    height,\n    borderRadius,\n    backgroundColor: success === null || success === void 0 ? void 0 : success.strokeColor\n  };\n  const outerStyle = {\n    width: width < 0 ? '100%' : width\n  };\n  const lineInner = /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefixCls}-inner`,\n    style: trailStyle\n  }, /*#__PURE__*/react.createElement(\"div\", {\n    className: classnames_default()(`${prefixCls}-bg`, `${prefixCls}-bg-${infoPosition}`),\n    style: percentStyle\n  }, infoPosition === 'inner' && children), successPercent !== undefined && (/*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefixCls}-success-bg`,\n    style: successPercentStyle\n  })));\n  const isOuterStart = infoPosition === 'outer' && infoAlign === 'start';\n  const isOuterEnd = infoPosition === 'outer' && infoAlign === 'end';\n  return infoPosition === 'outer' && infoAlign === 'center' ? (/*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefixCls}-layout-bottom`\n  }, lineInner, children)) : (/*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefixCls}-outer`,\n    style: outerStyle\n  }, isOuterStart && children, lineInner, isOuterEnd && children));\n};\n/* harmony default export */ const progress_Line = (Line);\n;// ./node_modules/antd/es/progress/Steps.js\n\"use client\";\n\n\n\n\nconst Steps = props => {\n  const {\n    size,\n    steps,\n    rounding: customRounding = Math.round,\n    percent = 0,\n    strokeWidth = 8,\n    strokeColor,\n    trailColor = null,\n    prefixCls,\n    children\n  } = props;\n  const current = customRounding(steps * (percent / 100));\n  const stepWidth = size === 'small' ? 2 : 14;\n  const mergedSize = size !== null && size !== void 0 ? size : [stepWidth, strokeWidth];\n  const [width, height] = getSize(mergedSize, 'step', {\n    steps,\n    strokeWidth\n  });\n  const unitWidth = width / steps;\n  const styledSteps = Array.from({\n    length: steps\n  });\n  for (let i = 0; i < steps; i++) {\n    const color = Array.isArray(strokeColor) ? strokeColor[i] : strokeColor;\n    styledSteps[i] = /*#__PURE__*/react.createElement(\"div\", {\n      key: i,\n      className: classnames_default()(`${prefixCls}-steps-item`, {\n        [`${prefixCls}-steps-item-active`]: i <= current - 1\n      }),\n      style: {\n        backgroundColor: i <= current - 1 ? color : trailColor,\n        width: unitWidth,\n        height\n      }\n    });\n  }\n  return /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefixCls}-steps-outer`\n  }, styledSteps, children);\n};\n/* harmony default export */ const progress_Steps = (Steps);\n;// ./node_modules/antd/es/progress/progress.js\n\"use client\";\n\nvar progress_rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst ProgressTypes = (/* unused pure expression or super */ null && (['line', 'circle', 'dashboard']));\nconst ProgressStatuses = ['normal', 'exception', 'active', 'success'];\nconst Progress = /*#__PURE__*/react.forwardRef((props, ref) => {\n  const {\n      prefixCls: customizePrefixCls,\n      className,\n      rootClassName,\n      steps,\n      strokeColor,\n      percent = 0,\n      size = 'default',\n      showInfo = true,\n      type = 'line',\n      status,\n      format,\n      style,\n      percentPosition = {}\n    } = props,\n    restProps = progress_rest(props, [\"prefixCls\", \"className\", \"rootClassName\", \"steps\", \"strokeColor\", \"percent\", \"size\", \"showInfo\", \"type\", \"status\", \"format\", \"style\", \"percentPosition\"]);\n  const {\n    align: infoAlign = 'end',\n    type: infoPosition = 'outer'\n  } = percentPosition;\n  const strokeColorNotArray = Array.isArray(strokeColor) ? strokeColor[0] : strokeColor;\n  const strokeColorNotGradient = typeof strokeColor === 'string' || Array.isArray(strokeColor) ? strokeColor : undefined;\n  const strokeColorIsBright = react.useMemo(() => {\n    if (strokeColorNotArray) {\n      const color = typeof strokeColorNotArray === 'string' ? strokeColorNotArray : Object.values(strokeColorNotArray)[0];\n      return new es/* FastColor */.Y(color).isLight();\n    }\n    return false;\n  }, [strokeColor]);\n  const percentNumber = react.useMemo(() => {\n    var _a, _b;\n    const successPercent = getSuccessPercent(props);\n    return parseInt(successPercent !== undefined ? (_a = successPercent !== null && successPercent !== void 0 ? successPercent : 0) === null || _a === void 0 ? void 0 : _a.toString() : (_b = percent !== null && percent !== void 0 ? percent : 0) === null || _b === void 0 ? void 0 : _b.toString(), 10);\n  }, [percent, props.success, props.successPercent]);\n  const progressStatus = react.useMemo(() => {\n    if (!ProgressStatuses.includes(status) && percentNumber >= 100) {\n      return 'success';\n    }\n    return status || 'normal';\n  }, [status, percentNumber]);\n  const {\n    getPrefixCls,\n    direction,\n    progress: progressStyle\n  } = react.useContext(context/* ConfigContext */.QO);\n  const prefixCls = getPrefixCls('progress', customizePrefixCls);\n  const [wrapCSSVar, hashId, cssVarCls] = progress_style(prefixCls);\n  const isLineType = type === 'line';\n  const isPureLineType = isLineType && !steps;\n  const progressInfo = react.useMemo(() => {\n    if (!showInfo) {\n      return null;\n    }\n    const successPercent = getSuccessPercent(props);\n    let text;\n    const textFormatter = format || (number => `${number}%`);\n    const isBrightInnerColor = isLineType && strokeColorIsBright && infoPosition === 'inner';\n    if (infoPosition === 'inner' || format || progressStatus !== 'exception' && progressStatus !== 'success') {\n      text = textFormatter(validProgress(percent), validProgress(successPercent));\n    } else if (progressStatus === 'exception') {\n      text = isLineType ? /*#__PURE__*/react.createElement(CloseCircleFilled/* default */.A, null) : /*#__PURE__*/react.createElement(CloseOutlined/* default */.A, null);\n    } else if (progressStatus === 'success') {\n      text = isLineType ? /*#__PURE__*/react.createElement(CheckCircleFilled/* default */.A, null) : /*#__PURE__*/react.createElement(CheckOutlined/* default */.A, null);\n    }\n    return /*#__PURE__*/react.createElement(\"span\", {\n      className: classnames_default()(`${prefixCls}-text`, {\n        [`${prefixCls}-text-bright`]: isBrightInnerColor,\n        [`${prefixCls}-text-${infoAlign}`]: isPureLineType,\n        [`${prefixCls}-text-${infoPosition}`]: isPureLineType\n      }),\n      title: typeof text === 'string' ? text : undefined\n    }, text);\n  }, [showInfo, percent, percentNumber, progressStatus, type, prefixCls, format]);\n  if (false) {}\n  let progress;\n  // Render progress shape\n  if (type === 'line') {\n    progress = steps ? (/*#__PURE__*/react.createElement(progress_Steps, Object.assign({}, props, {\n      strokeColor: strokeColorNotGradient,\n      prefixCls: prefixCls,\n      steps: typeof steps === 'object' ? steps.count : steps\n    }), progressInfo)) : (/*#__PURE__*/react.createElement(progress_Line, Object.assign({}, props, {\n      strokeColor: strokeColorNotArray,\n      prefixCls: prefixCls,\n      direction: direction,\n      percentPosition: {\n        align: infoAlign,\n        type: infoPosition\n      }\n    }), progressInfo));\n  } else if (type === 'circle' || type === 'dashboard') {\n    progress = /*#__PURE__*/react.createElement(progress_Circle, Object.assign({}, props, {\n      strokeColor: strokeColorNotArray,\n      prefixCls: prefixCls,\n      progressStatus: progressStatus\n    }), progressInfo);\n  }\n  const classString = classnames_default()(prefixCls, `${prefixCls}-status-${progressStatus}`, {\n    [`${prefixCls}-${type === 'dashboard' && 'circle' || type}`]: type !== 'line',\n    [`${prefixCls}-inline-circle`]: type === 'circle' && getSize(size, 'circle')[0] <= 20,\n    [`${prefixCls}-line`]: isPureLineType,\n    [`${prefixCls}-line-align-${infoAlign}`]: isPureLineType,\n    [`${prefixCls}-line-position-${infoPosition}`]: isPureLineType,\n    [`${prefixCls}-steps`]: steps,\n    [`${prefixCls}-show-info`]: showInfo,\n    [`${prefixCls}-${size}`]: typeof size === 'string',\n    [`${prefixCls}-rtl`]: direction === 'rtl'\n  }, progressStyle === null || progressStyle === void 0 ? void 0 : progressStyle.className, className, rootClassName, hashId, cssVarCls);\n  return wrapCSSVar(/*#__PURE__*/react.createElement(\"div\", Object.assign({\n    ref: ref,\n    style: Object.assign(Object.assign({}, progressStyle === null || progressStyle === void 0 ? void 0 : progressStyle.style), style),\n    className: classString,\n    role: \"progressbar\",\n    \"aria-valuenow\": percentNumber,\n    \"aria-valuemin\": 0,\n    \"aria-valuemax\": 100\n  }, (0,omit/* default */.A)(restProps, ['trailColor', 'strokeWidth', 'width', 'gapDegree', 'gapPosition', 'strokeLinecap', 'success', 'successPercent'])), progress));\n});\nif (false) {}\n/* harmony default export */ const progress = (Progress);\n;// ./node_modules/antd/es/progress/index.js\n\"use client\";\n\n\n/* harmony default export */ const es_progress = (progress);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc1NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2FudGQvZXMvcHJvZ3Jlc3MvdXRpbHMuanM/NWJlNCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYW50ZC9lcy9wcm9ncmVzcy9DaXJjbGUuanM/YTk1ZCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYW50ZC9lcy9wcm9ncmVzcy9zdHlsZS9pbmRleC5qcz8zMTcwIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL3Byb2dyZXNzL0xpbmUuanM/MjEwMyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYW50ZC9lcy9wcm9ncmVzcy9TdGVwcy5qcz8zM2EwIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL3Byb2dyZXNzL3Byb2dyZXNzLmpzPzgyNDQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2FudGQvZXMvcHJvZ3Jlc3MvaW5kZXguanM/MDg1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcmVzZXRQcmltYXJ5Q29sb3JzIH0gZnJvbSAnQGFudC1kZXNpZ24vY29sb3JzJztcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZFByb2dyZXNzKHByb2dyZXNzKSB7XG4gIGlmICghcHJvZ3Jlc3MgfHwgcHJvZ3Jlc3MgPCAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHByb2dyZXNzID4gMTAwKSB7XG4gICAgcmV0dXJuIDEwMDtcbiAgfVxuICByZXR1cm4gcHJvZ3Jlc3M7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VjY2Vzc1BlcmNlbnQoX3JlZikge1xuICBsZXQge1xuICAgIHN1Y2Nlc3MsXG4gICAgc3VjY2Vzc1BlcmNlbnRcbiAgfSA9IF9yZWY7XG4gIGxldCBwZXJjZW50ID0gc3VjY2Vzc1BlcmNlbnQ7XG4gIC8qKiBAZGVwcmVjYXRlZCBVc2UgYHBlcmNlbnRgIGluc3RlYWQgKi9cbiAgaWYgKHN1Y2Nlc3MgJiYgJ3Byb2dyZXNzJyBpbiBzdWNjZXNzKSB7XG4gICAgcGVyY2VudCA9IHN1Y2Nlc3MucHJvZ3Jlc3M7XG4gIH1cbiAgaWYgKHN1Y2Nlc3MgJiYgJ3BlcmNlbnQnIGluIHN1Y2Nlc3MpIHtcbiAgICBwZXJjZW50ID0gc3VjY2Vzcy5wZXJjZW50O1xuICB9XG4gIHJldHVybiBwZXJjZW50O1xufVxuZXhwb3J0IGNvbnN0IGdldFBlcmNlbnRhZ2UgPSBfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgcGVyY2VudCxcbiAgICBzdWNjZXNzLFxuICAgIHN1Y2Nlc3NQZXJjZW50XG4gIH0gPSBfcmVmMjtcbiAgY29uc3QgcmVhbFN1Y2Nlc3NQZXJjZW50ID0gdmFsaWRQcm9ncmVzcyhnZXRTdWNjZXNzUGVyY2VudCh7XG4gICAgc3VjY2VzcyxcbiAgICBzdWNjZXNzUGVyY2VudFxuICB9KSk7XG4gIHJldHVybiBbcmVhbFN1Y2Nlc3NQZXJjZW50LCB2YWxpZFByb2dyZXNzKHZhbGlkUHJvZ3Jlc3MocGVyY2VudCkgLSByZWFsU3VjY2Vzc1BlcmNlbnQpXTtcbn07XG5leHBvcnQgY29uc3QgZ2V0U3Ryb2tlQ29sb3IgPSBfcmVmMyA9PiB7XG4gIGxldCB7XG4gICAgc3VjY2VzcyA9IHt9LFxuICAgIHN0cm9rZUNvbG9yXG4gIH0gPSBfcmVmMztcbiAgY29uc3Qge1xuICAgIHN0cm9rZUNvbG9yOiBzdWNjZXNzQ29sb3JcbiAgfSA9IHN1Y2Nlc3M7XG4gIHJldHVybiBbc3VjY2Vzc0NvbG9yIHx8IHByZXNldFByaW1hcnlDb2xvcnMuZ3JlZW4sIHN0cm9rZUNvbG9yIHx8IG51bGxdO1xufTtcbmV4cG9ydCBjb25zdCBnZXRTaXplID0gKHNpemUsIHR5cGUsIGV4dHJhKSA9PiB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgbGV0IHdpZHRoID0gLTE7XG4gIGxldCBoZWlnaHQgPSAtMTtcbiAgaWYgKHR5cGUgPT09ICdzdGVwJykge1xuICAgIGNvbnN0IHN0ZXBzID0gZXh0cmEuc3RlcHM7XG4gICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBleHRyYS5zdHJva2VXaWR0aDtcbiAgICBpZiAodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBzaXplID09PSAndW5kZWZpbmVkJykge1xuICAgICAgd2lkdGggPSBzaXplID09PSAnc21hbGwnID8gMiA6IDE0O1xuICAgICAgaGVpZ2h0ID0gc3Ryb2tlV2lkdGggIT09IG51bGwgJiYgc3Ryb2tlV2lkdGggIT09IHZvaWQgMCA/IHN0cm9rZVdpZHRoIDogODtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgW3dpZHRoLCBoZWlnaHRdID0gW3NpemUsIHNpemVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBbd2lkdGggPSAxNCwgaGVpZ2h0ID0gOF0gPSBBcnJheS5pc0FycmF5KHNpemUpID8gc2l6ZSA6IFtzaXplLndpZHRoLCBzaXplLmhlaWdodF07XG4gICAgfVxuICAgIHdpZHRoICo9IHN0ZXBzO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsaW5lJykge1xuICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gZXh0cmEgPT09IG51bGwgfHwgZXh0cmEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dHJhLnN0cm9rZVdpZHRoO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHNpemUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBoZWlnaHQgPSBzdHJva2VXaWR0aCB8fCAoc2l6ZSA9PT0gJ3NtYWxsJyA/IDYgOiA4KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgW3dpZHRoLCBoZWlnaHRdID0gW3NpemUsIHNpemVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBbd2lkdGggPSAtMSwgaGVpZ2h0ID0gOF0gPSBBcnJheS5pc0FycmF5KHNpemUpID8gc2l6ZSA6IFtzaXplLndpZHRoLCBzaXplLmhlaWdodF07XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjaXJjbGUnIHx8IHR5cGUgPT09ICdkYXNoYm9hcmQnKSB7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc2l6ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIFt3aWR0aCwgaGVpZ2h0XSA9IHNpemUgPT09ICdzbWFsbCcgPyBbNjAsIDYwXSA6IFsxMjAsIDEyMF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIFt3aWR0aCwgaGVpZ2h0XSA9IFtzaXplLCBzaXplXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2l6ZSkpIHtcbiAgICAgIHdpZHRoID0gKF9iID0gKF9hID0gc2l6ZVswXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2l6ZVsxXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTIwO1xuICAgICAgaGVpZ2h0ID0gKF9kID0gKF9jID0gc2l6ZVswXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogc2l6ZVsxXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMTIwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3dpZHRoLCBoZWlnaHRdO1xufTsiLCJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBDaXJjbGUgYXMgUkNDaXJjbGUgfSBmcm9tICdyYy1wcm9ncmVzcyc7XG5pbXBvcnQgVG9vbHRpcCBmcm9tICcuLi90b29sdGlwJztcbmltcG9ydCB7IGdldFBlcmNlbnRhZ2UsIGdldFNpemUsIGdldFN0cm9rZUNvbG9yIH0gZnJvbSAnLi91dGlscyc7XG5jb25zdCBDSVJDTEVfTUlOX1NUUk9LRV9XSURUSCA9IDM7XG5jb25zdCBnZXRNaW5QZXJjZW50ID0gd2lkdGggPT4gQ0lSQ0xFX01JTl9TVFJPS0VfV0lEVEggLyB3aWR0aCAqIDEwMDtcbmNvbnN0IENpcmNsZSA9IHByb3BzID0+IHtcbiAgY29uc3Qge1xuICAgIHByZWZpeENscyxcbiAgICB0cmFpbENvbG9yID0gbnVsbCxcbiAgICBzdHJva2VMaW5lY2FwID0gJ3JvdW5kJyxcbiAgICBnYXBQb3NpdGlvbixcbiAgICBnYXBEZWdyZWUsXG4gICAgd2lkdGg6IG9yaWdpbldpZHRoID0gMTIwLFxuICAgIHR5cGUsXG4gICAgY2hpbGRyZW4sXG4gICAgc3VjY2VzcyxcbiAgICBzaXplID0gb3JpZ2luV2lkdGgsXG4gICAgc3RlcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSBnZXRTaXplKHNpemUsICdjaXJjbGUnKTtcbiAgbGV0IHtcbiAgICBzdHJva2VXaWR0aFxuICB9ID0gcHJvcHM7XG4gIGlmIChzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3Ryb2tlV2lkdGggPSBNYXRoLm1heChnZXRNaW5QZXJjZW50KHdpZHRoKSwgNik7XG4gIH1cbiAgY29uc3QgY2lyY2xlU3R5bGUgPSB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGZvbnRTaXplOiB3aWR0aCAqIDAuMTUgKyA2XG4gIH07XG4gIGNvbnN0IHJlYWxHYXBEZWdyZWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAvLyBTdXBwb3J0IGdhcERlZyA9IDAgd2hlbiB0eXBlID0gJ2Rhc2hib2FyZCdcbiAgICBpZiAoZ2FwRGVncmVlIHx8IGdhcERlZ3JlZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGdhcERlZ3JlZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdkYXNoYm9hcmQnKSB7XG4gICAgICByZXR1cm4gNzU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sIFtnYXBEZWdyZWUsIHR5cGVdKTtcbiAgY29uc3QgcGVyY2VudEFycmF5ID0gZ2V0UGVyY2VudGFnZShwcm9wcyk7XG4gIGNvbnN0IGdhcFBvcyA9IGdhcFBvc2l0aW9uIHx8IHR5cGUgPT09ICdkYXNoYm9hcmQnICYmICdib3R0b20nIHx8IHVuZGVmaW5lZDtcbiAgLy8gdXNpbmcgY2xhc3NOYW1lIHRvIHN0eWxlIHN0cm9rZSBjb2xvclxuICBjb25zdCBpc0dyYWRpZW50ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb3BzLnN0cm9rZUNvbG9yKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gIGNvbnN0IHN0cm9rZUNvbG9yID0gZ2V0U3Ryb2tlQ29sb3Ioe1xuICAgIHN1Y2Nlc3MsXG4gICAgc3Ryb2tlQ29sb3I6IHByb3BzLnN0cm9rZUNvbG9yXG4gIH0pO1xuICBjb25zdCB3cmFwcGVyQ2xhc3NOYW1lID0gY2xhc3NOYW1lcyhgJHtwcmVmaXhDbHN9LWlubmVyYCwge1xuICAgIFtgJHtwcmVmaXhDbHN9LWNpcmNsZS1ncmFkaWVudGBdOiBpc0dyYWRpZW50XG4gIH0pO1xuICBjb25zdCBjaXJjbGVDb250ZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUkNDaXJjbGUsIHtcbiAgICBzdGVwczogc3RlcHMsXG4gICAgcGVyY2VudDogc3RlcHMgPyBwZXJjZW50QXJyYXlbMV0gOiBwZXJjZW50QXJyYXksXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgIHRyYWlsV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZUNvbG9yOiBzdGVwcyA/IHN0cm9rZUNvbG9yWzFdIDogc3Ryb2tlQ29sb3IsXG4gICAgc3Ryb2tlTGluZWNhcDogc3Ryb2tlTGluZWNhcCxcbiAgICB0cmFpbENvbG9yOiB0cmFpbENvbG9yLFxuICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgIGdhcERlZ3JlZTogcmVhbEdhcERlZ3JlZSxcbiAgICBnYXBQb3NpdGlvbjogZ2FwUG9zXG4gIH0pO1xuICBjb25zdCBzbWFsbENpcmNsZSA9IHdpZHRoIDw9IDIwO1xuICBjb25zdCBub2RlID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogd3JhcHBlckNsYXNzTmFtZSxcbiAgICBzdHlsZTogY2lyY2xlU3R5bGVcbiAgfSwgY2lyY2xlQ29udGVudCwgIXNtYWxsQ2lyY2xlICYmIGNoaWxkcmVuKTtcbiAgaWYgKHNtYWxsQ2lyY2xlKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICAgIHRpdGxlOiBjaGlsZHJlblxuICAgIH0sIG5vZGUpO1xuICB9XG4gIHJldHVybiBub2RlO1xufTtcbmV4cG9ydCBkZWZhdWx0IENpcmNsZTsiLCJpbXBvcnQgeyBLZXlmcmFtZXMsIHVuaXQgfSBmcm9tICdAYW50LWRlc2lnbi9jc3NpbmpzJztcbmltcG9ydCB7IHJlc2V0Q29tcG9uZW50IH0gZnJvbSAnLi4vLi4vc3R5bGUnO1xuaW1wb3J0IHsgZ2VuU3R5bGVIb29rcywgbWVyZ2VUb2tlbiB9IGZyb20gJy4uLy4uL3RoZW1lL2ludGVybmFsJztcbmV4cG9ydCBjb25zdCBMaW5lU3Ryb2tlQ29sb3JWYXIgPSAnLS1wcm9ncmVzcy1saW5lLXN0cm9rZS1jb2xvcic7XG5leHBvcnQgY29uc3QgUGVyY2VudCA9ICctLXByb2dyZXNzLXBlcmNlbnQnO1xuY29uc3QgZ2VuQW50UHJvZ3Jlc3NBY3RpdmUgPSBpc1J0bCA9PiB7XG4gIGNvbnN0IGRpcmVjdGlvbiA9IGlzUnRsID8gJzEwMCUnIDogJy0xMDAlJztcbiAgcmV0dXJuIG5ldyBLZXlmcmFtZXMoYGFudFByb2dyZXNzJHtpc1J0bCA/ICdSVEwnIDogJ0xUUid9QWN0aXZlYCwge1xuICAgICcwJSc6IHtcbiAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtkaXJlY3Rpb259KSBzY2FsZVgoMClgLFxuICAgICAgb3BhY2l0eTogMC4xXG4gICAgfSxcbiAgICAnMjAlJzoge1xuICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2RpcmVjdGlvbn0pIHNjYWxlWCgwKWAsXG4gICAgICBvcGFjaXR5OiAwLjVcbiAgICB9LFxuICAgIHRvOiB7XG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDApIHNjYWxlWCgxKScsXG4gICAgICBvcGFjaXR5OiAwXG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBnZW5CYXNlU3R5bGUgPSB0b2tlbiA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb21wb25lbnRDbHM6IHByb2dyZXNzQ2xzLFxuICAgIGljb25DbHM6IGljb25QcmVmaXhDbHNcbiAgfSA9IHRva2VuO1xuICByZXR1cm4ge1xuICAgIFtwcm9ncmVzc0Nsc106IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzZXRDb21wb25lbnQodG9rZW4pKSwge1xuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAnJi1ydGwnOiB7XG4gICAgICAgIGRpcmVjdGlvbjogJ3J0bCdcbiAgICAgIH0sXG4gICAgICAnJi1saW5lJzoge1xuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgZm9udFNpemU6IHRva2VuLmZvbnRTaXplXG4gICAgICB9LFxuICAgICAgW2Ake3Byb2dyZXNzQ2xzfS1vdXRlcmBdOiB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtZmxleCcsXG4gICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICB3aWR0aDogJzEwMCUnXG4gICAgICB9LFxuICAgICAgW2Ake3Byb2dyZXNzQ2xzfS1pbm5lcmBdOiB7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgZmxleDogMSxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0b2tlbi5yZW1haW5pbmdDb2xvcixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiB0b2tlbi5saW5lQm9yZGVyUmFkaXVzXG4gICAgICB9LFxuICAgICAgW2Ake3Byb2dyZXNzQ2xzfS1pbm5lcjpub3QoJHtwcm9ncmVzc0Nsc30tY2lyY2xlLWdyYWRpZW50KWBdOiB7XG4gICAgICAgIFtgJHtwcm9ncmVzc0Nsc30tY2lyY2xlLXBhdGhgXToge1xuICAgICAgICAgIHN0cm9rZTogdG9rZW4uZGVmYXVsdENvbG9yXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbYCR7cHJvZ3Jlc3NDbHN9LXN1Y2Nlc3MtYmcsICR7cHJvZ3Jlc3NDbHN9LWJnYF06IHtcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIGJhY2tncm91bmQ6IHRva2VuLmRlZmF1bHRDb2xvcixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiB0b2tlbi5saW5lQm9yZGVyUmFkaXVzLFxuICAgICAgICB0cmFuc2l0aW9uOiBgYWxsICR7dG9rZW4ubW90aW9uRHVyYXRpb25TbG93fSAke3Rva2VuLm1vdGlvbkVhc2VJbk91dENpcmN9YFxuICAgICAgfSxcbiAgICAgIFtgJHtwcm9ncmVzc0Nsc30tbGF5b3V0LWJvdHRvbWBdOiB7XG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgIFtgJHtwcm9ncmVzc0Nsc30tdGV4dGBdOiB7XG4gICAgICAgICAgd2lkdGg6ICdtYXgtY29udGVudCcsXG4gICAgICAgICAgbWFyZ2luSW5saW5lU3RhcnQ6IDAsXG4gICAgICAgICAgbWFyZ2luVG9wOiB0b2tlbi5tYXJnaW5YWFNcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtgJHtwcm9ncmVzc0Nsc30tYmdgXToge1xuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICcmOjphZnRlcic6IHtcbiAgICAgICAgICBjb250ZW50OiAnXCJcIicsXG4gICAgICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICAgICAgX211bHRpX3ZhbHVlXzogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbJ2luaGVyaXQnLCBgdmFyKCR7TGluZVN0cm9rZUNvbG9yVmFyfSlgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgd2lkdGg6IGBjYWxjKDEgLyB2YXIoJHtQZXJjZW50fSkgKiAxMDAlKWAsXG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9LFxuICAgICAgICBbYCYke3Byb2dyZXNzQ2xzfS1iZy1pbm5lcmBdOiB7XG4gICAgICAgICAgbWluV2lkdGg6ICdtYXgtY29udGVudCcsXG4gICAgICAgICAgJyY6OmFmdGVyJzoge1xuICAgICAgICAgICAgY29udGVudDogJ25vbmUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBbYCR7cHJvZ3Jlc3NDbHN9LXRleHQtaW5uZXJgXToge1xuICAgICAgICAgICAgY29sb3I6IHRva2VuLmNvbG9yV2hpdGUsXG4gICAgICAgICAgICBbYCYke3Byb2dyZXNzQ2xzfS10ZXh0LWJyaWdodGBdOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjQ1KSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbYCR7cHJvZ3Jlc3NDbHN9LXN1Y2Nlc3MtYmdgXToge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgaW5zZXRCbG9ja1N0YXJ0OiAwLFxuICAgICAgICBpbnNldElubGluZVN0YXJ0OiAwLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRva2VuLmNvbG9yU3VjY2Vzc1xuICAgICAgfSxcbiAgICAgIFtgJHtwcm9ncmVzc0Nsc30tdGV4dGBdOiB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICBtYXJnaW5JbmxpbmVTdGFydDogdG9rZW4ubWFyZ2luWFMsXG4gICAgICAgIGNvbG9yOiB0b2tlbi5jb2xvclRleHQsXG4gICAgICAgIGxpbmVIZWlnaHQ6IDEsXG4gICAgICAgIHdpZHRoOiAnMmVtJyxcbiAgICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgICAgIHRleHRBbGlnbjogJ3N0YXJ0JyxcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICAgIHdvcmRCcmVhazogJ25vcm1hbCcsXG4gICAgICAgIFtpY29uUHJlZml4Q2xzXToge1xuICAgICAgICAgIGZvbnRTaXplOiB0b2tlbi5mb250U2l6ZVxuICAgICAgICB9LFxuICAgICAgICBbYCYke3Byb2dyZXNzQ2xzfS10ZXh0LW91dGVyYF06IHtcbiAgICAgICAgICB3aWR0aDogJ21heC1jb250ZW50J1xuICAgICAgICB9LFxuICAgICAgICBbYCYke3Byb2dyZXNzQ2xzfS10ZXh0LW91dGVyJHtwcm9ncmVzc0Nsc30tdGV4dC1zdGFydGBdOiB7XG4gICAgICAgICAgd2lkdGg6ICdtYXgtY29udGVudCcsXG4gICAgICAgICAgbWFyZ2luSW5saW5lU3RhcnQ6IDAsXG4gICAgICAgICAgbWFyZ2luSW5saW5lRW5kOiB0b2tlbi5tYXJnaW5YU1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2Ake3Byb2dyZXNzQ2xzfS10ZXh0LWlubmVyYF06IHtcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgbWFyZ2luSW5saW5lU3RhcnQ6IDAsXG4gICAgICAgIHBhZGRpbmc6IGAwICR7dW5pdCh0b2tlbi5wYWRkaW5nWFhTKX1gLFxuICAgICAgICBbYCYke3Byb2dyZXNzQ2xzfS10ZXh0LXN0YXJ0YF06IHtcbiAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ3N0YXJ0J1xuICAgICAgICB9LFxuICAgICAgICBbYCYke3Byb2dyZXNzQ2xzfS10ZXh0LWVuZGBdOiB7XG4gICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdlbmQnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbYCYke3Byb2dyZXNzQ2xzfS1zdGF0dXMtYWN0aXZlYF06IHtcbiAgICAgICAgW2Ake3Byb2dyZXNzQ2xzfS1iZzo6YmVmb3JlYF06IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICBpbnNldDogMCxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRva2VuLmNvbG9yQmdDb250YWluZXIsXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiB0b2tlbi5saW5lQm9yZGVyUmFkaXVzLFxuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZTogZ2VuQW50UHJvZ3Jlc3NBY3RpdmUoKSxcbiAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogdG9rZW4ucHJvZ3Jlc3NBY3RpdmVNb3Rpb25EdXJhdGlvbixcbiAgICAgICAgICBhbmltYXRpb25UaW1pbmdGdW5jdGlvbjogdG9rZW4ubW90aW9uRWFzZU91dFF1aW50LFxuICAgICAgICAgIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiAnaW5maW5pdGUnLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIlwiJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2AmJHtwcm9ncmVzc0Nsc30tcnRsJHtwcm9ncmVzc0Nsc30tc3RhdHVzLWFjdGl2ZWBdOiB7XG4gICAgICAgIFtgJHtwcm9ncmVzc0Nsc30tYmc6OmJlZm9yZWBdOiB7XG4gICAgICAgICAgYW5pbWF0aW9uTmFtZTogZ2VuQW50UHJvZ3Jlc3NBY3RpdmUodHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtgJiR7cHJvZ3Jlc3NDbHN9LXN0YXR1cy1leGNlcHRpb25gXToge1xuICAgICAgICBbYCR7cHJvZ3Jlc3NDbHN9LWJnYF06IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRva2VuLmNvbG9yRXJyb3JcbiAgICAgICAgfSxcbiAgICAgICAgW2Ake3Byb2dyZXNzQ2xzfS10ZXh0YF06IHtcbiAgICAgICAgICBjb2xvcjogdG9rZW4uY29sb3JFcnJvclxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2AmJHtwcm9ncmVzc0Nsc30tc3RhdHVzLWV4Y2VwdGlvbiAke3Byb2dyZXNzQ2xzfS1pbm5lcjpub3QoJHtwcm9ncmVzc0Nsc30tY2lyY2xlLWdyYWRpZW50KWBdOiB7XG4gICAgICAgIFtgJHtwcm9ncmVzc0Nsc30tY2lyY2xlLXBhdGhgXToge1xuICAgICAgICAgIHN0cm9rZTogdG9rZW4uY29sb3JFcnJvclxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2AmJHtwcm9ncmVzc0Nsc30tc3RhdHVzLXN1Y2Nlc3NgXToge1xuICAgICAgICBbYCR7cHJvZ3Jlc3NDbHN9LWJnYF06IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRva2VuLmNvbG9yU3VjY2Vzc1xuICAgICAgICB9LFxuICAgICAgICBbYCR7cHJvZ3Jlc3NDbHN9LXRleHRgXToge1xuICAgICAgICAgIGNvbG9yOiB0b2tlbi5jb2xvclN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtgJiR7cHJvZ3Jlc3NDbHN9LXN0YXR1cy1zdWNjZXNzICR7cHJvZ3Jlc3NDbHN9LWlubmVyOm5vdCgke3Byb2dyZXNzQ2xzfS1jaXJjbGUtZ3JhZGllbnQpYF06IHtcbiAgICAgICAgW2Ake3Byb2dyZXNzQ2xzfS1jaXJjbGUtcGF0aGBdOiB7XG4gICAgICAgICAgc3Ryb2tlOiB0b2tlbi5jb2xvclN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH07XG59O1xuY29uc3QgZ2VuQ2lyY2xlU3R5bGUgPSB0b2tlbiA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb21wb25lbnRDbHM6IHByb2dyZXNzQ2xzLFxuICAgIGljb25DbHM6IGljb25QcmVmaXhDbHNcbiAgfSA9IHRva2VuO1xuICByZXR1cm4ge1xuICAgIFtwcm9ncmVzc0Nsc106IHtcbiAgICAgIFtgJHtwcm9ncmVzc0Nsc30tY2lyY2xlLXRyYWlsYF06IHtcbiAgICAgICAgc3Ryb2tlOiB0b2tlbi5yZW1haW5pbmdDb2xvclxuICAgICAgfSxcbiAgICAgIFtgJiR7cHJvZ3Jlc3NDbHN9LWNpcmNsZSAke3Byb2dyZXNzQ2xzfS1pbm5lcmBdOiB7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICAgIH0sXG4gICAgICBbYCYke3Byb2dyZXNzQ2xzfS1jaXJjbGUgJHtwcm9ncmVzc0Nsc30tdGV4dGBdOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBpbnNldEJsb2NrU3RhcnQ6ICc1MCUnLFxuICAgICAgICBpbnNldElubGluZVN0YXJ0OiAwLFxuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIGNvbG9yOiB0b2tlbi5jaXJjbGVUZXh0Q29sb3IsXG4gICAgICAgIGZvbnRTaXplOiB0b2tlbi5jaXJjbGVUZXh0Rm9udFNpemUsXG4gICAgICAgIGxpbmVIZWlnaHQ6IDEsXG4gICAgICAgIHdoaXRlU3BhY2U6ICdub3JtYWwnLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MCUpJyxcbiAgICAgICAgW2ljb25QcmVmaXhDbHNdOiB7XG4gICAgICAgICAgZm9udFNpemU6IHRva2VuLmNpcmNsZUljb25Gb250U2l6ZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2Ake3Byb2dyZXNzQ2xzfS1jaXJjbGUmLXN0YXR1cy1leGNlcHRpb25gXToge1xuICAgICAgICBbYCR7cHJvZ3Jlc3NDbHN9LXRleHRgXToge1xuICAgICAgICAgIGNvbG9yOiB0b2tlbi5jb2xvckVycm9yXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbYCR7cHJvZ3Jlc3NDbHN9LWNpcmNsZSYtc3RhdHVzLXN1Y2Nlc3NgXToge1xuICAgICAgICBbYCR7cHJvZ3Jlc3NDbHN9LXRleHRgXToge1xuICAgICAgICAgIGNvbG9yOiB0b2tlbi5jb2xvclN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW2Ake3Byb2dyZXNzQ2xzfS1pbmxpbmUtY2lyY2xlYF06IHtcbiAgICAgIGxpbmVIZWlnaHQ6IDEsXG4gICAgICBbYCR7cHJvZ3Jlc3NDbHN9LWlubmVyYF06IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ2JvdHRvbSdcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuY29uc3QgZ2VuU3RlcFN0eWxlID0gdG9rZW4gPT4ge1xuICBjb25zdCB7XG4gICAgY29tcG9uZW50Q2xzOiBwcm9ncmVzc0Nsc1xuICB9ID0gdG9rZW47XG4gIHJldHVybiB7XG4gICAgW3Byb2dyZXNzQ2xzXToge1xuICAgICAgW2Ake3Byb2dyZXNzQ2xzfS1zdGVwc2BdOiB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAnJi1vdXRlcic6IHtcbiAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgZmxleERpcmVjdGlvbjogJ3JvdycsXG4gICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcidcbiAgICAgICAgfSxcbiAgICAgICAgJyYtaXRlbSc6IHtcbiAgICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICAgIG1pbldpZHRoOiB0b2tlbi5wcm9ncmVzc1N0ZXBNaW5XaWR0aCxcbiAgICAgICAgICBtYXJnaW5JbmxpbmVFbmQ6IHRva2VuLnByb2dyZXNzU3RlcE1hcmdpbklubGluZUVuZCxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRva2VuLnJlbWFpbmluZ0NvbG9yLFxuICAgICAgICAgIHRyYW5zaXRpb246IGBhbGwgJHt0b2tlbi5tb3Rpb25EdXJhdGlvblNsb3d9YCxcbiAgICAgICAgICAnJi1hY3RpdmUnOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRva2VuLmRlZmF1bHRDb2xvclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5jb25zdCBnZW5TbWFsbExpbmUgPSB0b2tlbiA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb21wb25lbnRDbHM6IHByb2dyZXNzQ2xzLFxuICAgIGljb25DbHM6IGljb25QcmVmaXhDbHNcbiAgfSA9IHRva2VuO1xuICByZXR1cm4ge1xuICAgIFtwcm9ncmVzc0Nsc106IHtcbiAgICAgIFtgJHtwcm9ncmVzc0Nsc30tc21hbGwmLWxpbmUsICR7cHJvZ3Jlc3NDbHN9LXNtYWxsJi1saW5lICR7cHJvZ3Jlc3NDbHN9LXRleHQgJHtpY29uUHJlZml4Q2xzfWBdOiB7XG4gICAgICAgIGZvbnRTaXplOiB0b2tlbi5mb250U2l6ZVNNXG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbmV4cG9ydCBjb25zdCBwcmVwYXJlQ29tcG9uZW50VG9rZW4gPSB0b2tlbiA9PiAoe1xuICBjaXJjbGVUZXh0Q29sb3I6IHRva2VuLmNvbG9yVGV4dCxcbiAgZGVmYXVsdENvbG9yOiB0b2tlbi5jb2xvckluZm8sXG4gIHJlbWFpbmluZ0NvbG9yOiB0b2tlbi5jb2xvckZpbGxTZWNvbmRhcnksXG4gIGxpbmVCb3JkZXJSYWRpdXM6IDEwMCxcbiAgLy8gbWFnaWMgZm9yIGNhcHN1bGUgc2hhcGUsIHNob3VsZCBiZSBhIHZlcnkgbGFyZ2UgbnVtYmVyXG4gIGNpcmNsZVRleHRGb250U2l6ZTogJzFlbScsXG4gIGNpcmNsZUljb25Gb250U2l6ZTogYCR7dG9rZW4uZm9udFNpemUgLyB0b2tlbi5mb250U2l6ZVNNfWVtYFxufSk7XG5leHBvcnQgZGVmYXVsdCBnZW5TdHlsZUhvb2tzKCdQcm9ncmVzcycsIHRva2VuID0+IHtcbiAgY29uc3QgcHJvZ3Jlc3NTdGVwTWFyZ2luSW5saW5lRW5kID0gdG9rZW4uY2FsYyh0b2tlbi5tYXJnaW5YWFMpLmRpdigyKS5lcXVhbCgpO1xuICBjb25zdCBwcm9ncmVzc1Rva2VuID0gbWVyZ2VUb2tlbih0b2tlbiwge1xuICAgIHByb2dyZXNzU3RlcE1hcmdpbklubGluZUVuZCxcbiAgICBwcm9ncmVzc1N0ZXBNaW5XaWR0aDogcHJvZ3Jlc3NTdGVwTWFyZ2luSW5saW5lRW5kLFxuICAgIHByb2dyZXNzQWN0aXZlTW90aW9uRHVyYXRpb246ICcyLjRzJ1xuICB9KTtcbiAgcmV0dXJuIFtnZW5CYXNlU3R5bGUocHJvZ3Jlc3NUb2tlbiksIGdlbkNpcmNsZVN0eWxlKHByb2dyZXNzVG9rZW4pLCBnZW5TdGVwU3R5bGUocHJvZ3Jlc3NUb2tlbiksIGdlblNtYWxsTGluZShwcm9ncmVzc1Rva2VuKV07XG59LCBwcmVwYXJlQ29tcG9uZW50VG9rZW4pOyIsIlwidXNlIGNsaWVudFwiO1xuXG52YXIgX19yZXN0ID0gdGhpcyAmJiB0aGlzLl9fcmVzdCB8fCBmdW5jdGlvbiAocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMCkgdFtwXSA9IHNbcF07XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSkgdFtwW2ldXSA9IHNbcFtpXV07XG4gIH1cbiAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcHJlc2V0UHJpbWFyeUNvbG9ycyB9IGZyb20gJ0BhbnQtZGVzaWduL2NvbG9ycyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IGRldlVzZVdhcm5pbmcgfSBmcm9tICcuLi9fdXRpbC93YXJuaW5nJztcbmltcG9ydCB7IExpbmVTdHJva2VDb2xvclZhciwgUGVyY2VudCB9IGZyb20gJy4vc3R5bGUnO1xuaW1wb3J0IHsgZ2V0U2l6ZSwgZ2V0U3VjY2Vzc1BlcmNlbnQsIHZhbGlkUHJvZ3Jlc3MgfSBmcm9tICcuL3V0aWxzJztcbi8qKlxuICogQGV4YW1wbGVcbiAqICAge1xuICogICAgIFwiMCVcIjogXCIjYWZjMTYzXCIsXG4gKiAgICAgXCI3NSVcIjogXCIjMDA5OTAwXCIsXG4gKiAgICAgXCI1MCVcIjogXCJncmVlblwiLCAvLyA9PT09PiAnI2FmYzE2MyAwJSwgIzY2RkYwMCAyNSUsICMwMENDMDAgNTAlLCAjMDA5OTAwIDc1JSwgI2ZmZmZmZiAxMDAlJ1xuICogICAgIFwiMjUlXCI6IFwiIzY2RkYwMFwiLFxuICogICAgIFwiMTAwJVwiOiBcIiNmZmZmZmZcIlxuICogICB9XG4gKi9cbmV4cG9ydCBjb25zdCBzb3J0R3JhZGllbnQgPSBncmFkaWVudHMgPT4ge1xuICBsZXQgdGVtcEFyciA9IFtdO1xuICBPYmplY3Qua2V5cyhncmFkaWVudHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCBmb3JtYXR0ZWRLZXkgPSBwYXJzZUZsb2F0KGtleS5yZXBsYWNlKC8lL2csICcnKSk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4oZm9ybWF0dGVkS2V5KSkge1xuICAgICAgdGVtcEFyci5wdXNoKHtcbiAgICAgICAga2V5OiBmb3JtYXR0ZWRLZXksXG4gICAgICAgIHZhbHVlOiBncmFkaWVudHNba2V5XVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgdGVtcEFyciA9IHRlbXBBcnIuc29ydCgoYSwgYikgPT4gYS5rZXkgLSBiLmtleSk7XG4gIHJldHVybiB0ZW1wQXJyLm1hcChfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgdmFsdWVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gYCR7dmFsdWV9ICR7a2V5fSVgO1xuICB9KS5qb2luKCcsICcpO1xufTtcbi8qKlxuICogVGhlbiB0aGlzIG1hbiBjYW1lIHRvIHJlYWxpemUgdGhlIHRydXRoOiBCZXNpZGVzIHNpeCBwZW5jZSwgdGhlcmUgaXMgdGhlIG1vb24uIEJlc2lkZXMgYnJlYWQgYW5kXG4gKiBidXR0ZXIsIHRoZXJlIGlzIHRoZSBidWcuIEFuZC4uLiBCZXNpZGVzIHdvbWVuLCB0aGVyZSBpcyB0aGUgY29kZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogICB7XG4gKiAgICAgXCIwJVwiOiBcIiNhZmMxNjNcIixcbiAqICAgICBcIjI1JVwiOiBcIiM2NkZGMDBcIixcbiAqICAgICBcIjUwJVwiOiBcIiMwMENDMDBcIiwgLy8gPT09PT4gIGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgI2FmYzE2MyAwJSwgIzY2RkYwMCAyNSUsXG4gKiAgICAgXCI3NSVcIjogXCIjMDA5OTAwXCIsIC8vICAgICAgICAjMDBDQzAwIDUwJSwgIzAwOTkwMCA3NSUsICNmZmZmZmYgMTAwJSlcbiAqICAgICBcIjEwMCVcIjogXCIjZmZmZmZmXCJcbiAqICAgfVxuICovXG5leHBvcnQgY29uc3QgaGFuZGxlR3JhZGllbnQgPSAoc3Ryb2tlQ29sb3IsIGRpcmVjdGlvbkNvbmZpZykgPT4ge1xuICBjb25zdCB7XG4gICAgICBmcm9tID0gcHJlc2V0UHJpbWFyeUNvbG9ycy5ibHVlLFxuICAgICAgdG8gPSBwcmVzZXRQcmltYXJ5Q29sb3JzLmJsdWUsXG4gICAgICBkaXJlY3Rpb24gPSBkaXJlY3Rpb25Db25maWcgPT09ICdydGwnID8gJ3RvIGxlZnQnIDogJ3RvIHJpZ2h0J1xuICAgIH0gPSBzdHJva2VDb2xvcixcbiAgICByZXN0ID0gX19yZXN0KHN0cm9rZUNvbG9yLCBbXCJmcm9tXCIsIFwidG9cIiwgXCJkaXJlY3Rpb25cIl0pO1xuICBpZiAoT2JqZWN0LmtleXMocmVzdCkubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3Qgc29ydGVkR3JhZGllbnRzID0gc29ydEdyYWRpZW50KHJlc3QpO1xuICAgIGNvbnN0IGJhY2tncm91bmQgPSBgbGluZWFyLWdyYWRpZW50KCR7ZGlyZWN0aW9ufSwgJHtzb3J0ZWRHcmFkaWVudHN9KWA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhY2tncm91bmQsXG4gICAgICBbTGluZVN0cm9rZUNvbG9yVmFyXTogYmFja2dyb3VuZFxuICAgIH07XG4gIH1cbiAgY29uc3QgYmFja2dyb3VuZCA9IGBsaW5lYXItZ3JhZGllbnQoJHtkaXJlY3Rpb259LCAke2Zyb219LCAke3RvfSlgO1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmQsXG4gICAgW0xpbmVTdHJva2VDb2xvclZhcl06IGJhY2tncm91bmRcbiAgfTtcbn07XG5jb25zdCBMaW5lID0gcHJvcHMgPT4ge1xuICBjb25zdCB7XG4gICAgcHJlZml4Q2xzLFxuICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uQ29uZmlnLFxuICAgIHBlcmNlbnQsXG4gICAgc2l6ZSxcbiAgICBzdHJva2VXaWR0aCxcbiAgICBzdHJva2VDb2xvcixcbiAgICBzdHJva2VMaW5lY2FwID0gJ3JvdW5kJyxcbiAgICBjaGlsZHJlbixcbiAgICB0cmFpbENvbG9yID0gbnVsbCxcbiAgICBwZXJjZW50UG9zaXRpb24sXG4gICAgc3VjY2Vzc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHtcbiAgICBhbGlnbjogaW5mb0FsaWduLFxuICAgIHR5cGU6IGluZm9Qb3NpdGlvblxuICB9ID0gcGVyY2VudFBvc2l0aW9uO1xuICBjb25zdCBiYWNrZ3JvdW5kUHJvcHMgPSBzdHJva2VDb2xvciAmJiB0eXBlb2Ygc3Ryb2tlQ29sb3IgIT09ICdzdHJpbmcnID8gaGFuZGxlR3JhZGllbnQoc3Ryb2tlQ29sb3IsIGRpcmVjdGlvbkNvbmZpZykgOiB7XG4gICAgW0xpbmVTdHJva2VDb2xvclZhcl06IHN0cm9rZUNvbG9yLFxuICAgIGJhY2tncm91bmQ6IHN0cm9rZUNvbG9yXG4gIH07XG4gIGNvbnN0IGJvcmRlclJhZGl1cyA9IHN0cm9rZUxpbmVjYXAgPT09ICdzcXVhcmUnIHx8IHN0cm9rZUxpbmVjYXAgPT09ICdidXR0JyA/IDAgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG1lcmdlZFNpemUgPSBzaXplICE9PSBudWxsICYmIHNpemUgIT09IHZvaWQgMCA/IHNpemUgOiBbLTEsIHN0cm9rZVdpZHRoIHx8IChzaXplID09PSAnc21hbGwnID8gNiA6IDgpXTtcbiAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gZ2V0U2l6ZShtZXJnZWRTaXplLCAnbGluZScsIHtcbiAgICBzdHJva2VXaWR0aFxuICB9KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCB3YXJuaW5nID0gZGV2VXNlV2FybmluZygnUHJvZ3Jlc3MnKTtcbiAgICB3YXJuaW5nLmRlcHJlY2F0ZWQoISgnc3Ryb2tlV2lkdGgnIGluIHByb3BzKSwgJ3N0cm9rZVdpZHRoJywgJ3NpemUnKTtcbiAgfVxuICBjb25zdCB0cmFpbFN0eWxlID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogdHJhaWxDb2xvciB8fCB1bmRlZmluZWQsXG4gICAgYm9yZGVyUmFkaXVzXG4gIH07XG4gIGNvbnN0IHBlcmNlbnRTdHlsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7XG4gICAgd2lkdGg6IGAke3ZhbGlkUHJvZ3Jlc3MocGVyY2VudCl9JWAsXG4gICAgaGVpZ2h0LFxuICAgIGJvcmRlclJhZGl1c1xuICB9LCBiYWNrZ3JvdW5kUHJvcHMpLCB7XG4gICAgW1BlcmNlbnRdOiB2YWxpZFByb2dyZXNzKHBlcmNlbnQpIC8gMTAwXG4gIH0pO1xuICBjb25zdCBzdWNjZXNzUGVyY2VudCA9IGdldFN1Y2Nlc3NQZXJjZW50KHByb3BzKTtcbiAgY29uc3Qgc3VjY2Vzc1BlcmNlbnRTdHlsZSA9IHtcbiAgICB3aWR0aDogYCR7dmFsaWRQcm9ncmVzcyhzdWNjZXNzUGVyY2VudCl9JWAsXG4gICAgaGVpZ2h0LFxuICAgIGJvcmRlclJhZGl1cyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHN1Y2Nlc3MgPT09IG51bGwgfHwgc3VjY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3VjY2Vzcy5zdHJva2VDb2xvclxuICB9O1xuICBjb25zdCBvdXRlclN0eWxlID0ge1xuICAgIHdpZHRoOiB3aWR0aCA8IDAgPyAnMTAwJScgOiB3aWR0aFxuICB9O1xuICBjb25zdCBsaW5lSW5uZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXhDbHN9LWlubmVyYCxcbiAgICBzdHlsZTogdHJhaWxTdHlsZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGAke3ByZWZpeENsc30tYmdgLCBgJHtwcmVmaXhDbHN9LWJnLSR7aW5mb1Bvc2l0aW9ufWApLFxuICAgIHN0eWxlOiBwZXJjZW50U3R5bGVcbiAgfSwgaW5mb1Bvc2l0aW9uID09PSAnaW5uZXInICYmIGNoaWxkcmVuKSwgc3VjY2Vzc1BlcmNlbnQgIT09IHVuZGVmaW5lZCAmJiAoLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4Q2xzfS1zdWNjZXNzLWJnYCxcbiAgICBzdHlsZTogc3VjY2Vzc1BlcmNlbnRTdHlsZVxuICB9KSkpO1xuICBjb25zdCBpc091dGVyU3RhcnQgPSBpbmZvUG9zaXRpb24gPT09ICdvdXRlcicgJiYgaW5mb0FsaWduID09PSAnc3RhcnQnO1xuICBjb25zdCBpc091dGVyRW5kID0gaW5mb1Bvc2l0aW9uID09PSAnb3V0ZXInICYmIGluZm9BbGlnbiA9PT0gJ2VuZCc7XG4gIHJldHVybiBpbmZvUG9zaXRpb24gPT09ICdvdXRlcicgJiYgaW5mb0FsaWduID09PSAnY2VudGVyJyA/ICgvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXhDbHN9LWxheW91dC1ib3R0b21gXG4gIH0sIGxpbmVJbm5lciwgY2hpbGRyZW4pKSA6ICgvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXhDbHN9LW91dGVyYCxcbiAgICBzdHlsZTogb3V0ZXJTdHlsZVxuICB9LCBpc091dGVyU3RhcnQgJiYgY2hpbGRyZW4sIGxpbmVJbm5lciwgaXNPdXRlckVuZCAmJiBjaGlsZHJlbikpO1xufTtcbmV4cG9ydCBkZWZhdWx0IExpbmU7IiwiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgZ2V0U2l6ZSB9IGZyb20gJy4vdXRpbHMnO1xuY29uc3QgU3RlcHMgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IHtcbiAgICBzaXplLFxuICAgIHN0ZXBzLFxuICAgIHJvdW5kaW5nOiBjdXN0b21Sb3VuZGluZyA9IE1hdGgucm91bmQsXG4gICAgcGVyY2VudCA9IDAsXG4gICAgc3Ryb2tlV2lkdGggPSA4LFxuICAgIHN0cm9rZUNvbG9yLFxuICAgIHRyYWlsQ29sb3IgPSBudWxsLFxuICAgIHByZWZpeENscyxcbiAgICBjaGlsZHJlblxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGN1cnJlbnQgPSBjdXN0b21Sb3VuZGluZyhzdGVwcyAqIChwZXJjZW50IC8gMTAwKSk7XG4gIGNvbnN0IHN0ZXBXaWR0aCA9IHNpemUgPT09ICdzbWFsbCcgPyAyIDogMTQ7XG4gIGNvbnN0IG1lcmdlZFNpemUgPSBzaXplICE9PSBudWxsICYmIHNpemUgIT09IHZvaWQgMCA/IHNpemUgOiBbc3RlcFdpZHRoLCBzdHJva2VXaWR0aF07XG4gIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IGdldFNpemUobWVyZ2VkU2l6ZSwgJ3N0ZXAnLCB7XG4gICAgc3RlcHMsXG4gICAgc3Ryb2tlV2lkdGhcbiAgfSk7XG4gIGNvbnN0IHVuaXRXaWR0aCA9IHdpZHRoIC8gc3RlcHM7XG4gIGNvbnN0IHN0eWxlZFN0ZXBzID0gQXJyYXkuZnJvbSh7XG4gICAgbGVuZ3RoOiBzdGVwc1xuICB9KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwczsgaSsrKSB7XG4gICAgY29uc3QgY29sb3IgPSBBcnJheS5pc0FycmF5KHN0cm9rZUNvbG9yKSA/IHN0cm9rZUNvbG9yW2ldIDogc3Ryb2tlQ29sb3I7XG4gICAgc3R5bGVkU3RlcHNbaV0gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBrZXk6IGksXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoYCR7cHJlZml4Q2xzfS1zdGVwcy1pdGVtYCwge1xuICAgICAgICBbYCR7cHJlZml4Q2xzfS1zdGVwcy1pdGVtLWFjdGl2ZWBdOiBpIDw9IGN1cnJlbnQgLSAxXG4gICAgICB9KSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaSA8PSBjdXJyZW50IC0gMSA/IGNvbG9yIDogdHJhaWxDb2xvcixcbiAgICAgICAgd2lkdGg6IHVuaXRXaWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeENsc30tc3RlcHMtb3V0ZXJgXG4gIH0sIHN0eWxlZFN0ZXBzLCBjaGlsZHJlbik7XG59O1xuZXhwb3J0IGRlZmF1bHQgU3RlcHM7IiwiXCJ1c2UgY2xpZW50XCI7XG5cbnZhciBfX3Jlc3QgPSB0aGlzICYmIHRoaXMuX19yZXN0IHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKSB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKSB0W3BbaV1dID0gc1twW2ldXTtcbiAgfVxuICByZXR1cm4gdDtcbn07XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBGYXN0Q29sb3IgfSBmcm9tICdAYW50LWRlc2lnbi9mYXN0LWNvbG9yJztcbmltcG9ydCBDaGVja0NpcmNsZUZpbGxlZCBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvQ2hlY2tDaXJjbGVGaWxsZWRcIjtcbmltcG9ydCBDaGVja091dGxpbmVkIGZyb20gXCJAYW50LWRlc2lnbi9pY29ucy9lcy9pY29ucy9DaGVja091dGxpbmVkXCI7XG5pbXBvcnQgQ2xvc2VDaXJjbGVGaWxsZWQgZnJvbSBcIkBhbnQtZGVzaWduL2ljb25zL2VzL2ljb25zL0Nsb3NlQ2lyY2xlRmlsbGVkXCI7XG5pbXBvcnQgQ2xvc2VPdXRsaW5lZCBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvQ2xvc2VPdXRsaW5lZFwiO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgb21pdCBmcm9tIFwicmMtdXRpbC9lcy9vbWl0XCI7XG5pbXBvcnQgeyBkZXZVc2VXYXJuaW5nIH0gZnJvbSAnLi4vX3V0aWwvd2FybmluZyc7XG5pbXBvcnQgeyBDb25maWdDb250ZXh0IH0gZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCBDaXJjbGUgZnJvbSAnLi9DaXJjbGUnO1xuaW1wb3J0IExpbmUgZnJvbSAnLi9MaW5lJztcbmltcG9ydCBTdGVwcyBmcm9tICcuL1N0ZXBzJztcbmltcG9ydCB1c2VTdHlsZSBmcm9tICcuL3N0eWxlJztcbmltcG9ydCB7IGdldFNpemUsIGdldFN1Y2Nlc3NQZXJjZW50LCB2YWxpZFByb2dyZXNzIH0gZnJvbSAnLi91dGlscyc7XG5leHBvcnQgY29uc3QgUHJvZ3Jlc3NUeXBlcyA9IFsnbGluZScsICdjaXJjbGUnLCAnZGFzaGJvYXJkJ107XG5jb25zdCBQcm9ncmVzc1N0YXR1c2VzID0gWydub3JtYWwnLCAnZXhjZXB0aW9uJywgJ2FjdGl2ZScsICdzdWNjZXNzJ107XG5jb25zdCBQcm9ncmVzcyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICAgIHByZWZpeENsczogY3VzdG9taXplUHJlZml4Q2xzLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgcm9vdENsYXNzTmFtZSxcbiAgICAgIHN0ZXBzLFxuICAgICAgc3Ryb2tlQ29sb3IsXG4gICAgICBwZXJjZW50ID0gMCxcbiAgICAgIHNpemUgPSAnZGVmYXVsdCcsXG4gICAgICBzaG93SW5mbyA9IHRydWUsXG4gICAgICB0eXBlID0gJ2xpbmUnLFxuICAgICAgc3RhdHVzLFxuICAgICAgZm9ybWF0LFxuICAgICAgc3R5bGUsXG4gICAgICBwZXJjZW50UG9zaXRpb24gPSB7fVxuICAgIH0gPSBwcm9wcyxcbiAgICByZXN0UHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcInByZWZpeENsc1wiLCBcImNsYXNzTmFtZVwiLCBcInJvb3RDbGFzc05hbWVcIiwgXCJzdGVwc1wiLCBcInN0cm9rZUNvbG9yXCIsIFwicGVyY2VudFwiLCBcInNpemVcIiwgXCJzaG93SW5mb1wiLCBcInR5cGVcIiwgXCJzdGF0dXNcIiwgXCJmb3JtYXRcIiwgXCJzdHlsZVwiLCBcInBlcmNlbnRQb3NpdGlvblwiXSk7XG4gIGNvbnN0IHtcbiAgICBhbGlnbjogaW5mb0FsaWduID0gJ2VuZCcsXG4gICAgdHlwZTogaW5mb1Bvc2l0aW9uID0gJ291dGVyJ1xuICB9ID0gcGVyY2VudFBvc2l0aW9uO1xuICBjb25zdCBzdHJva2VDb2xvck5vdEFycmF5ID0gQXJyYXkuaXNBcnJheShzdHJva2VDb2xvcikgPyBzdHJva2VDb2xvclswXSA6IHN0cm9rZUNvbG9yO1xuICBjb25zdCBzdHJva2VDb2xvck5vdEdyYWRpZW50ID0gdHlwZW9mIHN0cm9rZUNvbG9yID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KHN0cm9rZUNvbG9yKSA/IHN0cm9rZUNvbG9yIDogdW5kZWZpbmVkO1xuICBjb25zdCBzdHJva2VDb2xvcklzQnJpZ2h0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHN0cm9rZUNvbG9yTm90QXJyYXkpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gdHlwZW9mIHN0cm9rZUNvbG9yTm90QXJyYXkgPT09ICdzdHJpbmcnID8gc3Ryb2tlQ29sb3JOb3RBcnJheSA6IE9iamVjdC52YWx1ZXMoc3Ryb2tlQ29sb3JOb3RBcnJheSlbMF07XG4gICAgICByZXR1cm4gbmV3IEZhc3RDb2xvcihjb2xvcikuaXNMaWdodCgpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIFtzdHJva2VDb2xvcl0pO1xuICBjb25zdCBwZXJjZW50TnVtYmVyID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBzdWNjZXNzUGVyY2VudCA9IGdldFN1Y2Nlc3NQZXJjZW50KHByb3BzKTtcbiAgICByZXR1cm4gcGFyc2VJbnQoc3VjY2Vzc1BlcmNlbnQgIT09IHVuZGVmaW5lZCA/IChfYSA9IHN1Y2Nlc3NQZXJjZW50ICE9PSBudWxsICYmIHN1Y2Nlc3NQZXJjZW50ICE9PSB2b2lkIDAgPyBzdWNjZXNzUGVyY2VudCA6IDApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpIDogKF9iID0gcGVyY2VudCAhPT0gbnVsbCAmJiBwZXJjZW50ICE9PSB2b2lkIDAgPyBwZXJjZW50IDogMCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvU3RyaW5nKCksIDEwKTtcbiAgfSwgW3BlcmNlbnQsIHByb3BzLnN1Y2Nlc3MsIHByb3BzLnN1Y2Nlc3NQZXJjZW50XSk7XG4gIGNvbnN0IHByb2dyZXNzU3RhdHVzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFQcm9ncmVzc1N0YXR1c2VzLmluY2x1ZGVzKHN0YXR1cykgJiYgcGVyY2VudE51bWJlciA+PSAxMDApIHtcbiAgICAgIHJldHVybiAnc3VjY2Vzcyc7XG4gICAgfVxuICAgIHJldHVybiBzdGF0dXMgfHwgJ25vcm1hbCc7XG4gIH0sIFtzdGF0dXMsIHBlcmNlbnROdW1iZXJdKTtcbiAgY29uc3Qge1xuICAgIGdldFByZWZpeENscyxcbiAgICBkaXJlY3Rpb24sXG4gICAgcHJvZ3Jlc3M6IHByb2dyZXNzU3R5bGVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoQ29uZmlnQ29udGV4dCk7XG4gIGNvbnN0IHByZWZpeENscyA9IGdldFByZWZpeENscygncHJvZ3Jlc3MnLCBjdXN0b21pemVQcmVmaXhDbHMpO1xuICBjb25zdCBbd3JhcENTU1ZhciwgaGFzaElkLCBjc3NWYXJDbHNdID0gdXNlU3R5bGUocHJlZml4Q2xzKTtcbiAgY29uc3QgaXNMaW5lVHlwZSA9IHR5cGUgPT09ICdsaW5lJztcbiAgY29uc3QgaXNQdXJlTGluZVR5cGUgPSBpc0xpbmVUeXBlICYmICFzdGVwcztcbiAgY29uc3QgcHJvZ3Jlc3NJbmZvID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFzaG93SW5mbykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN1Y2Nlc3NQZXJjZW50ID0gZ2V0U3VjY2Vzc1BlcmNlbnQocHJvcHMpO1xuICAgIGxldCB0ZXh0O1xuICAgIGNvbnN0IHRleHRGb3JtYXR0ZXIgPSBmb3JtYXQgfHwgKG51bWJlciA9PiBgJHtudW1iZXJ9JWApO1xuICAgIGNvbnN0IGlzQnJpZ2h0SW5uZXJDb2xvciA9IGlzTGluZVR5cGUgJiYgc3Ryb2tlQ29sb3JJc0JyaWdodCAmJiBpbmZvUG9zaXRpb24gPT09ICdpbm5lcic7XG4gICAgaWYgKGluZm9Qb3NpdGlvbiA9PT0gJ2lubmVyJyB8fCBmb3JtYXQgfHwgcHJvZ3Jlc3NTdGF0dXMgIT09ICdleGNlcHRpb24nICYmIHByb2dyZXNzU3RhdHVzICE9PSAnc3VjY2VzcycpIHtcbiAgICAgIHRleHQgPSB0ZXh0Rm9ybWF0dGVyKHZhbGlkUHJvZ3Jlc3MocGVyY2VudCksIHZhbGlkUHJvZ3Jlc3Moc3VjY2Vzc1BlcmNlbnQpKTtcbiAgICB9IGVsc2UgaWYgKHByb2dyZXNzU3RhdHVzID09PSAnZXhjZXB0aW9uJykge1xuICAgICAgdGV4dCA9IGlzTGluZVR5cGUgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDbG9zZUNpcmNsZUZpbGxlZCwgbnVsbCkgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDbG9zZU91dGxpbmVkLCBudWxsKTtcbiAgICB9IGVsc2UgaWYgKHByb2dyZXNzU3RhdHVzID09PSAnc3VjY2VzcycpIHtcbiAgICAgIHRleHQgPSBpc0xpbmVUeXBlID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hlY2tDaXJjbGVGaWxsZWQsIG51bGwpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hlY2tPdXRsaW5lZCwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGAke3ByZWZpeENsc30tdGV4dGAsIHtcbiAgICAgICAgW2Ake3ByZWZpeENsc30tdGV4dC1icmlnaHRgXTogaXNCcmlnaHRJbm5lckNvbG9yLFxuICAgICAgICBbYCR7cHJlZml4Q2xzfS10ZXh0LSR7aW5mb0FsaWdufWBdOiBpc1B1cmVMaW5lVHlwZSxcbiAgICAgICAgW2Ake3ByZWZpeENsc30tdGV4dC0ke2luZm9Qb3NpdGlvbn1gXTogaXNQdXJlTGluZVR5cGVcbiAgICAgIH0pLFxuICAgICAgdGl0bGU6IHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJyA/IHRleHQgOiB1bmRlZmluZWRcbiAgICB9LCB0ZXh0KTtcbiAgfSwgW3Nob3dJbmZvLCBwZXJjZW50LCBwZXJjZW50TnVtYmVyLCBwcm9ncmVzc1N0YXR1cywgdHlwZSwgcHJlZml4Q2xzLCBmb3JtYXRdKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCB3YXJuaW5nID0gZGV2VXNlV2FybmluZygnUHJvZ3Jlc3MnKTtcbiAgICB3YXJuaW5nLmRlcHJlY2F0ZWQoISgnc3VjY2Vzc1BlcmNlbnQnIGluIHByb3BzKSwgJ3N1Y2Nlc3NQZXJjZW50JywgJ3N1Y2Nlc3MucGVyY2VudCcpO1xuICAgIHdhcm5pbmcuZGVwcmVjYXRlZCghKCd3aWR0aCcgaW4gcHJvcHMpLCAnd2lkdGgnLCAnc2l6ZScpO1xuICAgIGlmICh0eXBlID09PSAnY2lyY2xlJyB8fCB0eXBlID09PSAnZGFzaGJvYXJkJykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2l6ZSkpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ3VzYWdlJywgJ1R5cGUgXCJjaXJjbGVcIiBhbmQgXCJkYXNoYm9hcmRcIiBkbyBub3QgYWNjZXB0IGFycmF5IGFzIGBzaXplYCwgcGxlYXNlIHVzZSBudW1iZXIgb3IgcHJlc2V0IHNpemUgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNpemUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICd1c2FnZScsICdUeXBlIFwiY2lyY2xlXCIgYW5kIFwiZGFzaGJvYXJkXCIgZG8gbm90IGFjY2VwdCBvYmplY3QgYXMgYHNpemVgLCBwbGVhc2UgdXNlIG51bWJlciBvciBwcmVzZXQgc2l6ZSBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMuc3VjY2VzcyAmJiAncHJvZ3Jlc3MnIGluIHByb3BzLnN1Y2Nlc3MpIHtcbiAgICAgIHdhcm5pbmcuZGVwcmVjYXRlZChmYWxzZSwgJ3N1Y2Nlc3MucHJvZ3Jlc3MnLCAnc3VjY2Vzcy5wZXJjZW50Jyk7XG4gICAgfVxuICB9XG4gIGxldCBwcm9ncmVzcztcbiAgLy8gUmVuZGVyIHByb2dyZXNzIHNoYXBlXG4gIGlmICh0eXBlID09PSAnbGluZScpIHtcbiAgICBwcm9ncmVzcyA9IHN0ZXBzID8gKC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFN0ZXBzLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgc3Ryb2tlQ29sb3I6IHN0cm9rZUNvbG9yTm90R3JhZGllbnQsXG4gICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgIHN0ZXBzOiB0eXBlb2Ygc3RlcHMgPT09ICdvYmplY3QnID8gc3RlcHMuY291bnQgOiBzdGVwc1xuICAgIH0pLCBwcm9ncmVzc0luZm8pKSA6ICgvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5lLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgc3Ryb2tlQ29sb3I6IHN0cm9rZUNvbG9yTm90QXJyYXksXG4gICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgcGVyY2VudFBvc2l0aW9uOiB7XG4gICAgICAgIGFsaWduOiBpbmZvQWxpZ24sXG4gICAgICAgIHR5cGU6IGluZm9Qb3NpdGlvblxuICAgICAgfVxuICAgIH0pLCBwcm9ncmVzc0luZm8pKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnY2lyY2xlJyB8fCB0eXBlID09PSAnZGFzaGJvYXJkJykge1xuICAgIHByb2dyZXNzID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2lyY2xlLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgc3Ryb2tlQ29sb3I6IHN0cm9rZUNvbG9yTm90QXJyYXksXG4gICAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICAgIHByb2dyZXNzU3RhdHVzOiBwcm9ncmVzc1N0YXR1c1xuICAgIH0pLCBwcm9ncmVzc0luZm8pO1xuICB9XG4gIGNvbnN0IGNsYXNzU3RyaW5nID0gY2xhc3NOYW1lcyhwcmVmaXhDbHMsIGAke3ByZWZpeENsc30tc3RhdHVzLSR7cHJvZ3Jlc3NTdGF0dXN9YCwge1xuICAgIFtgJHtwcmVmaXhDbHN9LSR7dHlwZSA9PT0gJ2Rhc2hib2FyZCcgJiYgJ2NpcmNsZScgfHwgdHlwZX1gXTogdHlwZSAhPT0gJ2xpbmUnLFxuICAgIFtgJHtwcmVmaXhDbHN9LWlubGluZS1jaXJjbGVgXTogdHlwZSA9PT0gJ2NpcmNsZScgJiYgZ2V0U2l6ZShzaXplLCAnY2lyY2xlJylbMF0gPD0gMjAsXG4gICAgW2Ake3ByZWZpeENsc30tbGluZWBdOiBpc1B1cmVMaW5lVHlwZSxcbiAgICBbYCR7cHJlZml4Q2xzfS1saW5lLWFsaWduLSR7aW5mb0FsaWdufWBdOiBpc1B1cmVMaW5lVHlwZSxcbiAgICBbYCR7cHJlZml4Q2xzfS1saW5lLXBvc2l0aW9uLSR7aW5mb1Bvc2l0aW9ufWBdOiBpc1B1cmVMaW5lVHlwZSxcbiAgICBbYCR7cHJlZml4Q2xzfS1zdGVwc2BdOiBzdGVwcyxcbiAgICBbYCR7cHJlZml4Q2xzfS1zaG93LWluZm9gXTogc2hvd0luZm8sXG4gICAgW2Ake3ByZWZpeENsc30tJHtzaXplfWBdOiB0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycsXG4gICAgW2Ake3ByZWZpeENsc30tcnRsYF06IGRpcmVjdGlvbiA9PT0gJ3J0bCdcbiAgfSwgcHJvZ3Jlc3NTdHlsZSA9PT0gbnVsbCB8fCBwcm9ncmVzc1N0eWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9ncmVzc1N0eWxlLmNsYXNzTmFtZSwgY2xhc3NOYW1lLCByb290Q2xhc3NOYW1lLCBoYXNoSWQsIGNzc1ZhckNscyk7XG4gIHJldHVybiB3cmFwQ1NTVmFyKC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHJlZjogcmVmLFxuICAgIHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb2dyZXNzU3R5bGUgPT09IG51bGwgfHwgcHJvZ3Jlc3NTdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvZ3Jlc3NTdHlsZS5zdHlsZSksIHN0eWxlKSxcbiAgICBjbGFzc05hbWU6IGNsYXNzU3RyaW5nLFxuICAgIHJvbGU6IFwicHJvZ3Jlc3NiYXJcIixcbiAgICBcImFyaWEtdmFsdWVub3dcIjogcGVyY2VudE51bWJlcixcbiAgICBcImFyaWEtdmFsdWVtaW5cIjogMCxcbiAgICBcImFyaWEtdmFsdWVtYXhcIjogMTAwXG4gIH0sIG9taXQocmVzdFByb3BzLCBbJ3RyYWlsQ29sb3InLCAnc3Ryb2tlV2lkdGgnLCAnd2lkdGgnLCAnZ2FwRGVncmVlJywgJ2dhcFBvc2l0aW9uJywgJ3N0cm9rZUxpbmVjYXAnLCAnc3VjY2VzcycsICdzdWNjZXNzUGVyY2VudCddKSksIHByb2dyZXNzKSk7XG59KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFByb2dyZXNzLmRpc3BsYXlOYW1lID0gJ1Byb2dyZXNzJztcbn1cbmV4cG9ydCBkZWZhdWx0IFByb2dyZXNzOyIsIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUHJvZ3Jlc3MgZnJvbSAnLi9wcm9ncmVzcyc7XG5leHBvcnQgZGVmYXVsdCBQcm9ncmVzczsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6754\n")},21815:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   L: () => (/* binding */ changeConfirmLocale),\n/* harmony export */   l: () => (/* binding */ getConfirmLocale)\n/* harmony export */ });\n/* harmony import */ var _locale_en_US__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3078);\n\nlet runtimeLocale = Object.assign({}, _locale_en_US__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Modal);\nlet localeList = [];\nconst generateLocale = () => localeList.reduce((merged, locale) => Object.assign(Object.assign({}, merged), locale), _locale_en_US__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Modal);\nfunction changeConfirmLocale(newLocale) {\n  if (newLocale) {\n    const cloneLocale = Object.assign({}, newLocale);\n    localeList.push(cloneLocale);\n    runtimeLocale = generateLocale();\n    return () => {\n      localeList = localeList.filter(locale => locale !== cloneLocale);\n      runtimeLocale = generateLocale();\n    };\n  }\n  runtimeLocale = Object.assign({}, _locale_en_US__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Modal);\n}\nfunction getConfirmLocale() {\n  return runtimeLocale;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE4MTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL21vZGFsL2xvY2FsZS5qcz9iYTVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWZhdWx0TG9jYWxlIGZyb20gJy4uL2xvY2FsZS9lbl9VUyc7XG5sZXQgcnVudGltZUxvY2FsZSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRMb2NhbGUuTW9kYWwpO1xubGV0IGxvY2FsZUxpc3QgPSBbXTtcbmNvbnN0IGdlbmVyYXRlTG9jYWxlID0gKCkgPT4gbG9jYWxlTGlzdC5yZWR1Y2UoKG1lcmdlZCwgbG9jYWxlKSA9PiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1lcmdlZCksIGxvY2FsZSksIGRlZmF1bHRMb2NhbGUuTW9kYWwpO1xuZXhwb3J0IGZ1bmN0aW9uIGNoYW5nZUNvbmZpcm1Mb2NhbGUobmV3TG9jYWxlKSB7XG4gIGlmIChuZXdMb2NhbGUpIHtcbiAgICBjb25zdCBjbG9uZUxvY2FsZSA9IE9iamVjdC5hc3NpZ24oe30sIG5ld0xvY2FsZSk7XG4gICAgbG9jYWxlTGlzdC5wdXNoKGNsb25lTG9jYWxlKTtcbiAgICBydW50aW1lTG9jYWxlID0gZ2VuZXJhdGVMb2NhbGUoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbG9jYWxlTGlzdCA9IGxvY2FsZUxpc3QuZmlsdGVyKGxvY2FsZSA9PiBsb2NhbGUgIT09IGNsb25lTG9jYWxlKTtcbiAgICAgIHJ1bnRpbWVMb2NhbGUgPSBnZW5lcmF0ZUxvY2FsZSgpO1xuICAgIH07XG4gIH1cbiAgcnVudGltZUxvY2FsZSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRMb2NhbGUuTW9kYWwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbmZpcm1Mb2NhbGUoKSB7XG4gIHJldHVybiBydW50aW1lTG9jYWxlO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21815\n')},51288:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ useNotification)\n});\n\n// UNUSED EXPORTS: useInternalNotification\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(96540);\n// EXTERNAL MODULE: ./node_modules/classnames/index.js\nvar classnames = __webpack_require__(46942);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n// EXTERNAL MODULE: ./node_modules/rc-notification/es/index.js + 6 modules\nvar es = __webpack_require__(22370);\n// EXTERNAL MODULE: ./node_modules/antd/es/_util/warning.js\nvar _util_warning = __webpack_require__(18877);\n// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js\nvar context = __webpack_require__(62279);\n// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/hooks/useCSSVarCls.js\nvar hooks_useCSSVarCls = __webpack_require__(20934);\n// EXTERNAL MODULE: ./node_modules/antd/es/theme/useToken.js + 3 modules\nvar useToken = __webpack_require__(39319);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/CheckCircleFilled.js + 1 modules\nvar CheckCircleFilled = __webpack_require__(38811);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/CloseCircleFilled.js + 1 modules\nvar CloseCircleFilled = __webpack_require__(36029);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/CloseOutlined.js + 1 modules\nvar CloseOutlined = __webpack_require__(47852);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/ExclamationCircleFilled.js + 1 modules\nvar ExclamationCircleFilled = __webpack_require__(7541);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/InfoCircleFilled.js + 1 modules\nvar InfoCircleFilled = __webpack_require__(17850);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/LoadingOutlined.js + 1 modules\nvar LoadingOutlined = __webpack_require__(93567);\n;// ./node_modules/antd/es/notification/PurePanel.js\n\"use client\";\n\nvar __rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst TypeIcon = {\n  info: /*#__PURE__*/react.createElement(InfoCircleFilled/* default */.A, null),\n  success: /*#__PURE__*/react.createElement(CheckCircleFilled/* default */.A, null),\n  error: /*#__PURE__*/react.createElement(CloseCircleFilled/* default */.A, null),\n  warning: /*#__PURE__*/react.createElement(ExclamationCircleFilled/* default */.A, null),\n  loading: /*#__PURE__*/react.createElement(LoadingOutlined/* default */.A, null)\n};\nfunction getCloseIcon(prefixCls, closeIcon) {\n  if (closeIcon === null || closeIcon === false) {\n    return null;\n  }\n  return closeIcon || /*#__PURE__*/react.createElement(CloseOutlined/* default */.A, {\n    className: `${prefixCls}-close-icon`\n  });\n}\nconst typeToIcon = {\n  success: CheckCircleFilled/* default */.A,\n  info: InfoCircleFilled/* default */.A,\n  error: CloseCircleFilled/* default */.A,\n  warning: ExclamationCircleFilled/* default */.A\n};\nconst PureContent = props => {\n  const {\n    prefixCls,\n    icon,\n    type,\n    message,\n    description,\n    actions,\n    role = 'alert'\n  } = props;\n  let iconNode = null;\n  if (icon) {\n    iconNode = /*#__PURE__*/react.createElement(\"span\", {\n      className: `${prefixCls}-icon`\n    }, icon);\n  } else if (type) {\n    iconNode = /*#__PURE__*/react.createElement(typeToIcon[type] || null, {\n      className: classnames_default()(`${prefixCls}-icon`, `${prefixCls}-icon-${type}`)\n    });\n  }\n  return /*#__PURE__*/react.createElement(\"div\", {\n    className: classnames_default()({\n      [`${prefixCls}-with-icon`]: iconNode\n    }),\n    role: role\n  }, iconNode, /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefixCls}-message`\n  }, message), /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefixCls}-description`\n  }, description), actions && /*#__PURE__*/react.createElement(\"div\", {\n    className: `${prefixCls}-actions`\n  }, actions));\n};\n/** @private Internal Component. Do not use in your production. */\nconst PurePanel = props => {\n  const {\n      prefixCls: staticPrefixCls,\n      className,\n      icon,\n      type,\n      message,\n      description,\n      btn,\n      actions,\n      closable = true,\n      closeIcon,\n      className: notificationClassName\n    } = props,\n    restProps = __rest(props, [\"prefixCls\", \"className\", \"icon\", \"type\", \"message\", \"description\", \"btn\", \"actions\", \"closable\", \"closeIcon\", \"className\"]);\n  const {\n    getPrefixCls\n  } = React.useContext(ConfigContext);\n  const mergedActions = actions !== null && actions !== void 0 ? actions : btn;\n  if (false) {}\n  const prefixCls = staticPrefixCls || getPrefixCls('notification');\n  const noticePrefixCls = `${prefixCls}-notice`;\n  const rootCls = useCSSVarCls(prefixCls);\n  const [wrapCSSVar, hashId, cssVarCls] = useStyle(prefixCls, rootCls);\n  return wrapCSSVar(/*#__PURE__*/React.createElement(\"div\", {\n    className: classNames(`${noticePrefixCls}-pure-panel`, hashId, className, cssVarCls, rootCls)\n  }, /*#__PURE__*/React.createElement(PurePanelStyle, {\n    prefixCls: prefixCls\n  }), /*#__PURE__*/React.createElement(Notice, Object.assign({}, restProps, {\n    prefixCls: prefixCls,\n    eventKey: \"pure\",\n    duration: null,\n    closable: closable,\n    className: classNames({\n      notificationClassName\n    }),\n    closeIcon: getCloseIcon(prefixCls, closeIcon),\n    content: /*#__PURE__*/React.createElement(PureContent, {\n      prefixCls: noticePrefixCls,\n      icon: icon,\n      type: type,\n      message: message,\n      description: description,\n      actions: mergedActions\n    })\n  }))));\n};\n/* harmony default export */ const notification_PurePanel = ((/* unused pure expression or super */ null && (PurePanel)));\n// EXTERNAL MODULE: ./node_modules/@ant-design/cssinjs/es/index.js + 30 modules\nvar cssinjs_es = __webpack_require__(67466);\n// EXTERNAL MODULE: ./node_modules/antd/es/_util/hooks/useZIndex.js\nvar useZIndex = __webpack_require__(60275);\n// EXTERNAL MODULE: ./node_modules/antd/es/style/index.js\nvar style = __webpack_require__(25905);\n// EXTERNAL MODULE: ./node_modules/@ant-design/cssinjs-utils/es/index.js + 12 modules\nvar cssinjs_utils_es = __webpack_require__(14277);\n// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/genStyleUtils.js\nvar genStyleUtils = __webpack_require__(37358);\n;// ./node_modules/antd/es/notification/style/placement.js\n\nconst genNotificationPlacementStyle = token => {\n  const {\n    componentCls,\n    notificationMarginEdge,\n    animationMaxHeight\n  } = token;\n  const noticeCls = `${componentCls}-notice`;\n  const rightFadeIn = new cssinjs_es/* Keyframes */.Mo('antNotificationFadeIn', {\n    '0%': {\n      transform: `translate3d(100%, 0, 0)`,\n      opacity: 0\n    },\n    '100%': {\n      transform: `translate3d(0, 0, 0)`,\n      opacity: 1\n    }\n  });\n  const topFadeIn = new cssinjs_es/* Keyframes */.Mo('antNotificationTopFadeIn', {\n    '0%': {\n      top: -animationMaxHeight,\n      opacity: 0\n    },\n    '100%': {\n      top: 0,\n      opacity: 1\n    }\n  });\n  const bottomFadeIn = new cssinjs_es/* Keyframes */.Mo('antNotificationBottomFadeIn', {\n    '0%': {\n      bottom: token.calc(animationMaxHeight).mul(-1).equal(),\n      opacity: 0\n    },\n    '100%': {\n      bottom: 0,\n      opacity: 1\n    }\n  });\n  const leftFadeIn = new cssinjs_es/* Keyframes */.Mo('antNotificationLeftFadeIn', {\n    '0%': {\n      transform: `translate3d(-100%, 0, 0)`,\n      opacity: 0\n    },\n    '100%': {\n      transform: `translate3d(0, 0, 0)`,\n      opacity: 1\n    }\n  });\n  return {\n    [componentCls]: {\n      [`&${componentCls}-top, &${componentCls}-bottom`]: {\n        marginInline: 0,\n        [noticeCls]: {\n          marginInline: 'auto auto'\n        }\n      },\n      [`&${componentCls}-top`]: {\n        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {\n          animationName: topFadeIn\n        }\n      },\n      [`&${componentCls}-bottom`]: {\n        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {\n          animationName: bottomFadeIn\n        }\n      },\n      [`&${componentCls}-topRight, &${componentCls}-bottomRight`]: {\n        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {\n          animationName: rightFadeIn\n        }\n      },\n      [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {\n        marginRight: {\n          value: 0,\n          _skip_check_: true\n        },\n        marginLeft: {\n          value: notificationMarginEdge,\n          _skip_check_: true\n        },\n        [noticeCls]: {\n          marginInlineEnd: 'auto',\n          marginInlineStart: 0\n        },\n        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {\n          animationName: leftFadeIn\n        }\n      }\n    }\n  };\n};\n/* harmony default export */ const placement = (genNotificationPlacementStyle);\n;// ./node_modules/antd/es/notification/interface.js\nconst NotificationPlacements = ['top', 'topLeft', 'topRight', 'bottom', 'bottomLeft', 'bottomRight'];\n;// ./node_modules/antd/es/notification/style/stack.js\n\nconst placementAlignProperty = {\n  topLeft: 'left',\n  topRight: 'right',\n  bottomLeft: 'left',\n  bottomRight: 'right',\n  top: 'left',\n  bottom: 'left'\n};\nconst genPlacementStackStyle = (token, placement) => {\n  const {\n    componentCls\n  } = token;\n  return {\n    [`${componentCls}-${placement}`]: {\n      [`&${componentCls}-stack > ${componentCls}-notice-wrapper`]: {\n        [placement.startsWith('top') ? 'top' : 'bottom']: 0,\n        [placementAlignProperty[placement]]: {\n          value: 0,\n          _skip_check_: true\n        }\n      }\n    }\n  };\n};\nconst genStackChildrenStyle = token => {\n  const childrenStyle = {};\n  for (let i = 1; i < token.notificationStackLayer; i++) {\n    childrenStyle[`&:nth-last-child(${i + 1})`] = {\n      overflow: 'hidden',\n      [`& > ${token.componentCls}-notice`]: {\n        opacity: 0,\n        transition: `opacity ${token.motionDurationMid}`\n      }\n    };\n  }\n  return Object.assign({\n    [`&:not(:nth-last-child(-n+${token.notificationStackLayer}))`]: {\n      opacity: 0,\n      overflow: 'hidden',\n      color: 'transparent',\n      pointerEvents: 'none'\n    }\n  }, childrenStyle);\n};\nconst genStackedNoticeStyle = token => {\n  const childrenStyle = {};\n  for (let i = 1; i < token.notificationStackLayer; i++) {\n    childrenStyle[`&:nth-last-child(${i + 1})`] = {\n      background: token.colorBgBlur,\n      backdropFilter: 'blur(10px)',\n      '-webkit-backdrop-filter': 'blur(10px)'\n    };\n  }\n  return Object.assign({}, childrenStyle);\n};\nconst genStackStyle = token => {\n  const {\n    componentCls\n  } = token;\n  return Object.assign({\n    [`${componentCls}-stack`]: {\n      [`& > ${componentCls}-notice-wrapper`]: Object.assign({\n        transition: `transform ${token.motionDurationSlow}, backdrop-filter 0s`,\n        willChange: 'transform, opacity',\n        position: 'absolute'\n      }, genStackChildrenStyle(token))\n    },\n    [`${componentCls}-stack:not(${componentCls}-stack-expanded)`]: {\n      [`& > ${componentCls}-notice-wrapper`]: Object.assign({}, genStackedNoticeStyle(token))\n    },\n    [`${componentCls}-stack${componentCls}-stack-expanded`]: {\n      [`& > ${componentCls}-notice-wrapper`]: {\n        '&:not(:nth-last-child(-n + 1))': {\n          opacity: 1,\n          overflow: 'unset',\n          color: 'inherit',\n          pointerEvents: 'auto',\n          [`& > ${token.componentCls}-notice`]: {\n            opacity: 1\n          }\n        },\n        '&:after': {\n          content: '\"\"',\n          position: 'absolute',\n          height: token.margin,\n          width: '100%',\n          insetInline: 0,\n          bottom: token.calc(token.margin).mul(-1).equal(),\n          background: 'transparent',\n          pointerEvents: 'auto'\n        }\n      }\n    }\n  }, NotificationPlacements.map(placement => genPlacementStackStyle(token, placement)).reduce((acc, cur) => Object.assign(Object.assign({}, acc), cur), {}));\n};\n/* harmony default export */ const stack = (genStackStyle);\n;// ./node_modules/antd/es/notification/style/index.js\n\n\n\n\n\n\nconst genNoticeStyle = token => {\n  const {\n    iconCls,\n    componentCls,\n    // .ant-notification\n    boxShadow,\n    fontSizeLG,\n    notificationMarginBottom,\n    borderRadiusLG,\n    colorSuccess,\n    colorInfo,\n    colorWarning,\n    colorError,\n    colorTextHeading,\n    notificationBg,\n    notificationPadding,\n    notificationMarginEdge,\n    notificationProgressBg,\n    notificationProgressHeight,\n    fontSize,\n    lineHeight,\n    width,\n    notificationIconSize,\n    colorText\n  } = token;\n  const noticeCls = `${componentCls}-notice`;\n  return {\n    position: 'relative',\n    marginBottom: notificationMarginBottom,\n    marginInlineStart: 'auto',\n    background: notificationBg,\n    borderRadius: borderRadiusLG,\n    boxShadow,\n    [noticeCls]: {\n      padding: notificationPadding,\n      width,\n      maxWidth: `calc(100vw - ${(0,cssinjs_es/* unit */.zA)(token.calc(notificationMarginEdge).mul(2).equal())})`,\n      overflow: 'hidden',\n      lineHeight,\n      wordWrap: 'break-word'\n    },\n    [`${noticeCls}-message`]: {\n      marginBottom: token.marginXS,\n      color: colorTextHeading,\n      fontSize: fontSizeLG,\n      lineHeight: token.lineHeightLG\n    },\n    [`${noticeCls}-description`]: {\n      fontSize,\n      color: colorText\n    },\n    [`${noticeCls}-closable ${noticeCls}-message`]: {\n      paddingInlineEnd: token.paddingLG\n    },\n    [`${noticeCls}-with-icon ${noticeCls}-message`]: {\n      marginBottom: token.marginXS,\n      marginInlineStart: token.calc(token.marginSM).add(notificationIconSize).equal(),\n      fontSize: fontSizeLG\n    },\n    [`${noticeCls}-with-icon ${noticeCls}-description`]: {\n      marginInlineStart: token.calc(token.marginSM).add(notificationIconSize).equal(),\n      fontSize\n    },\n    // Icon & color style in different selector level\n    // https://github.com/ant-design/ant-design/issues/16503\n    // https://github.com/ant-design/ant-design/issues/15512\n    [`${noticeCls}-icon`]: {\n      position: 'absolute',\n      fontSize: notificationIconSize,\n      lineHeight: 1,\n      // icon-font\n      [`&-success${iconCls}`]: {\n        color: colorSuccess\n      },\n      [`&-info${iconCls}`]: {\n        color: colorInfo\n      },\n      [`&-warning${iconCls}`]: {\n        color: colorWarning\n      },\n      [`&-error${iconCls}`]: {\n        color: colorError\n      }\n    },\n    [`${noticeCls}-close`]: Object.assign({\n      position: 'absolute',\n      top: token.notificationPaddingVertical,\n      insetInlineEnd: token.notificationPaddingHorizontal,\n      color: token.colorIcon,\n      outline: 'none',\n      width: token.notificationCloseButtonSize,\n      height: token.notificationCloseButtonSize,\n      borderRadius: token.borderRadiusSM,\n      transition: `background-color ${token.motionDurationMid}, color ${token.motionDurationMid}`,\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      background: 'none',\n      border: 'none',\n      '&:hover': {\n        color: token.colorIconHover,\n        backgroundColor: token.colorBgTextHover\n      },\n      '&:active': {\n        backgroundColor: token.colorBgTextActive\n      }\n    }, (0,style/* genFocusStyle */.K8)(token)),\n    [`${noticeCls}-progress`]: {\n      position: 'absolute',\n      display: 'block',\n      appearance: 'none',\n      inlineSize: `calc(100% - ${(0,cssinjs_es/* unit */.zA)(borderRadiusLG)} * 2)`,\n      left: {\n        _skip_check_: true,\n        value: borderRadiusLG\n      },\n      right: {\n        _skip_check_: true,\n        value: borderRadiusLG\n      },\n      bottom: 0,\n      blockSize: notificationProgressHeight,\n      border: 0,\n      '&, &::-webkit-progress-bar': {\n        borderRadius: borderRadiusLG,\n        backgroundColor: `rgba(0, 0, 0, 0.04)`\n      },\n      '&::-moz-progress-bar': {\n        background: notificationProgressBg\n      },\n      '&::-webkit-progress-value': {\n        borderRadius: borderRadiusLG,\n        background: notificationProgressBg\n      }\n    },\n    [`${noticeCls}-actions`]: {\n      float: 'right',\n      marginTop: token.marginSM\n    }\n  };\n};\nconst genNotificationStyle = token => {\n  const {\n    componentCls,\n    // .ant-notification\n    notificationMarginBottom,\n    notificationMarginEdge,\n    motionDurationMid,\n    motionEaseInOut\n  } = token;\n  const noticeCls = `${componentCls}-notice`;\n  const fadeOut = new cssinjs_es/* Keyframes */.Mo('antNotificationFadeOut', {\n    '0%': {\n      maxHeight: token.animationMaxHeight,\n      marginBottom: notificationMarginBottom\n    },\n    '100%': {\n      maxHeight: 0,\n      marginBottom: 0,\n      paddingTop: 0,\n      paddingBottom: 0,\n      opacity: 0\n    }\n  });\n  return [\n  // ============================ Holder ============================\n  {\n    [componentCls]: Object.assign(Object.assign({}, (0,style/* resetComponent */.dF)(token)), {\n      position: 'fixed',\n      zIndex: token.zIndexPopup,\n      marginRight: {\n        value: notificationMarginEdge,\n        _skip_check_: true\n      },\n      [`${componentCls}-hook-holder`]: {\n        position: 'relative'\n      },\n      //  animation\n      [`${componentCls}-fade-appear-prepare`]: {\n        opacity: '0 !important'\n      },\n      [`${componentCls}-fade-enter, ${componentCls}-fade-appear`]: {\n        animationDuration: token.motionDurationMid,\n        animationTimingFunction: motionEaseInOut,\n        animationFillMode: 'both',\n        opacity: 0,\n        animationPlayState: 'paused'\n      },\n      [`${componentCls}-fade-leave`]: {\n        animationTimingFunction: motionEaseInOut,\n        animationFillMode: 'both',\n        animationDuration: motionDurationMid,\n        animationPlayState: 'paused'\n      },\n      [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {\n        animationPlayState: 'running'\n      },\n      [`${componentCls}-fade-leave${componentCls}-fade-leave-active`]: {\n        animationName: fadeOut,\n        animationPlayState: 'running'\n      },\n      // RTL\n      '&-rtl': {\n        direction: 'rtl',\n        [`${noticeCls}-actions`]: {\n          float: 'left'\n        }\n      }\n    })\n  },\n  // ============================ Notice ============================\n  {\n    [componentCls]: {\n      [`${noticeCls}-wrapper`]: Object.assign({}, genNoticeStyle(token))\n    }\n  }];\n};\n// ============================== Export ==============================\nconst prepareComponentToken = token => ({\n  zIndexPopup: token.zIndexPopupBase + useZIndex/* CONTAINER_MAX_OFFSET */.jH + 50,\n  width: 384\n});\nconst prepareNotificationToken = token => {\n  const notificationPaddingVertical = token.paddingMD;\n  const notificationPaddingHorizontal = token.paddingLG;\n  const notificationToken = (0,cssinjs_utils_es/* mergeToken */.oX)(token, {\n    notificationBg: token.colorBgElevated,\n    notificationPaddingVertical,\n    notificationPaddingHorizontal,\n    notificationIconSize: token.calc(token.fontSizeLG).mul(token.lineHeightLG).equal(),\n    notificationCloseButtonSize: token.calc(token.controlHeightLG).mul(0.55).equal(),\n    notificationMarginBottom: token.margin,\n    notificationPadding: `${(0,cssinjs_es/* unit */.zA)(token.paddingMD)} ${(0,cssinjs_es/* unit */.zA)(token.paddingContentHorizontalLG)}`,\n    notificationMarginEdge: token.marginLG,\n    animationMaxHeight: 150,\n    notificationStackLayer: 3,\n    notificationProgressHeight: 2,\n    notificationProgressBg: `linear-gradient(90deg, ${token.colorPrimaryBorderHover}, ${token.colorPrimary})`\n  });\n  return notificationToken;\n};\n/* harmony default export */ const notification_style = ((0,genStyleUtils/* genStyleHooks */.OF)('Notification', token => {\n  const notificationToken = prepareNotificationToken(token);\n  return [genNotificationStyle(notificationToken), placement(notificationToken), stack(notificationToken)];\n}, prepareComponentToken));\n;// ./node_modules/antd/es/notification/util.js\nfunction getPlacementStyle(placement, top, bottom) {\n  let style;\n  switch (placement) {\n    case 'top':\n      style = {\n        left: '50%',\n        transform: 'translateX(-50%)',\n        right: 'auto',\n        top,\n        bottom: 'auto'\n      };\n      break;\n    case 'topLeft':\n      style = {\n        left: 0,\n        top,\n        bottom: 'auto'\n      };\n      break;\n    case 'topRight':\n      style = {\n        right: 0,\n        top,\n        bottom: 'auto'\n      };\n      break;\n    case 'bottom':\n      style = {\n        left: '50%',\n        transform: 'translateX(-50%)',\n        right: 'auto',\n        top: 'auto',\n        bottom\n      };\n      break;\n    case 'bottomLeft':\n      style = {\n        left: 0,\n        top: 'auto',\n        bottom\n      };\n      break;\n    default:\n      style = {\n        right: 0,\n        top: 'auto',\n        bottom\n      };\n      break;\n  }\n  return style;\n}\nfunction getMotion(prefixCls) {\n  return {\n    motionName: `${prefixCls}-fade`\n  };\n}\nfunction getCloseIconConfig(closeIcon, notificationConfig, notification) {\n  if (typeof closeIcon !== 'undefined') {\n    return closeIcon;\n  }\n  if (typeof (notificationConfig === null || notificationConfig === void 0 ? void 0 : notificationConfig.closeIcon) !== 'undefined') {\n    return notificationConfig.closeIcon;\n  }\n  return notification === null || notification === void 0 ? void 0 : notification.closeIcon;\n}\n;// ./node_modules/antd/es/notification/useNotification.js\n\"use client\";\n\nvar useNotification_rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_OFFSET = 24;\nconst DEFAULT_DURATION = 4.5;\nconst DEFAULT_PLACEMENT = 'topRight';\nconst Wrapper = _ref => {\n  let {\n    children,\n    prefixCls\n  } = _ref;\n  const rootCls = (0,hooks_useCSSVarCls/* default */.A)(prefixCls);\n  const [wrapCSSVar, hashId, cssVarCls] = notification_style(prefixCls, rootCls);\n  return wrapCSSVar(/*#__PURE__*/react.createElement(es/* NotificationProvider */.ph, {\n    classNames: {\n      list: classnames_default()(hashId, cssVarCls, rootCls)\n    }\n  }, children));\n};\nconst renderNotifications = (node, _ref2) => {\n  let {\n    prefixCls,\n    key\n  } = _ref2;\n  return /*#__PURE__*/react.createElement(Wrapper, {\n    prefixCls: prefixCls,\n    key: key\n  }, node);\n};\nconst Holder = /*#__PURE__*/react.forwardRef((props, ref) => {\n  const {\n    top,\n    bottom,\n    prefixCls: staticPrefixCls,\n    getContainer: staticGetContainer,\n    maxCount,\n    rtl,\n    onAllRemoved,\n    stack,\n    duration,\n    pauseOnHover = true,\n    showProgress\n  } = props;\n  const {\n    getPrefixCls,\n    getPopupContainer,\n    notification,\n    direction\n  } = (0,react.useContext)(context/* ConfigContext */.QO);\n  const [, token] = (0,useToken/* default */.Ay)();\n  const prefixCls = staticPrefixCls || getPrefixCls('notification');\n  // =============================== Style ===============================\n  const getStyle = placement => getPlacementStyle(placement, top !== null && top !== void 0 ? top : DEFAULT_OFFSET, bottom !== null && bottom !== void 0 ? bottom : DEFAULT_OFFSET);\n  const getClassName = () => classnames_default()({\n    [`${prefixCls}-rtl`]: rtl !== null && rtl !== void 0 ? rtl : direction === 'rtl'\n  });\n  // ============================== Motion ===============================\n  const getNotificationMotion = () => getMotion(prefixCls);\n  // ============================== Origin ===============================\n  const [api, holder] = (0,es/* useNotification */.hN)({\n    prefixCls,\n    style: getStyle,\n    className: getClassName,\n    motion: getNotificationMotion,\n    closable: true,\n    closeIcon: getCloseIcon(prefixCls),\n    duration: duration !== null && duration !== void 0 ? duration : DEFAULT_DURATION,\n    getContainer: () => (staticGetContainer === null || staticGetContainer === void 0 ? void 0 : staticGetContainer()) || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer()) || document.body,\n    maxCount,\n    pauseOnHover,\n    showProgress,\n    onAllRemoved,\n    renderNotifications,\n    stack: stack === false ? false : {\n      threshold: typeof stack === 'object' ? stack === null || stack === void 0 ? void 0 : stack.threshold : undefined,\n      offset: 8,\n      gap: token.margin\n    }\n  });\n  // ================================ Ref ================================\n  react.useImperativeHandle(ref, () => Object.assign(Object.assign({}, api), {\n    prefixCls,\n    notification\n  }));\n  return holder;\n});\n// ==============================================================================\n// ==                                   Hook                                   ==\n// ==============================================================================\nfunction useInternalNotification(notificationConfig) {\n  const holderRef = react.useRef(null);\n  const warning = (0,_util_warning/* devUseWarning */.rJ)('Notification');\n  // ================================ API ================================\n  const wrapAPI = react.useMemo(() => {\n    // Wrap with notification content\n    // >>> Open\n    const open = config => {\n      var _a;\n      if (!holderRef.current) {\n         false ? 0 : void 0;\n        return;\n      }\n      const {\n        open: originOpen,\n        prefixCls,\n        notification\n      } = holderRef.current;\n      const noticePrefixCls = `${prefixCls}-notice`;\n      const {\n          message,\n          description,\n          icon,\n          type,\n          btn,\n          actions,\n          className,\n          style,\n          role = 'alert',\n          closeIcon,\n          closable\n        } = config,\n        restConfig = useNotification_rest(config, [\"message\", \"description\", \"icon\", \"type\", \"btn\", \"actions\", \"className\", \"style\", \"role\", \"closeIcon\", \"closable\"]);\n      if (false) {}\n      const mergedActions = actions !== null && actions !== void 0 ? actions : btn;\n      const realCloseIcon = getCloseIcon(noticePrefixCls, getCloseIconConfig(closeIcon, notificationConfig, notification));\n      return originOpen(Object.assign(Object.assign({\n        // use placement from props instead of hard-coding \"topRight\"\n        placement: (_a = notificationConfig === null || notificationConfig === void 0 ? void 0 : notificationConfig.placement) !== null && _a !== void 0 ? _a : DEFAULT_PLACEMENT\n      }, restConfig), {\n        content: (/*#__PURE__*/react.createElement(PureContent, {\n          prefixCls: noticePrefixCls,\n          icon: icon,\n          type: type,\n          message: message,\n          description: description,\n          actions: mergedActions,\n          role: role\n        })),\n        className: classnames_default()(type && `${noticePrefixCls}-${type}`, className, notification === null || notification === void 0 ? void 0 : notification.className),\n        style: Object.assign(Object.assign({}, notification === null || notification === void 0 ? void 0 : notification.style), style),\n        closeIcon: realCloseIcon,\n        closable: closable !== null && closable !== void 0 ? closable : !!realCloseIcon\n      }));\n    };\n    // >>> destroy\n    const destroy = key => {\n      var _a, _b;\n      if (key !== undefined) {\n        (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.close(key);\n      } else {\n        (_b = holderRef.current) === null || _b === void 0 ? void 0 : _b.destroy();\n      }\n    };\n    const clone = {\n      open,\n      destroy\n    };\n    const keys = ['success', 'info', 'warning', 'error'];\n    keys.forEach(type => {\n      clone[type] = config => open(Object.assign(Object.assign({}, config), {\n        type\n      }));\n    });\n    return clone;\n  }, []);\n  // ============================== Return ===============================\n  return [wrapAPI, /*#__PURE__*/react.createElement(Holder, Object.assign({\n    key: \"notification-holder\"\n  }, notificationConfig, {\n    ref: holderRef\n  }))];\n}\nfunction useNotification(notificationConfig) {\n  return useInternalNotification(notificationConfig);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEyODguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYW50ZC9lcy9ub3RpZmljYXRpb24vUHVyZVBhbmVsLmpzPzQyMmUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2FudGQvZXMvbm90aWZpY2F0aW9uL3N0eWxlL3BsYWNlbWVudC5qcz83YTA0Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL25vdGlmaWNhdGlvbi9pbnRlcmZhY2UuanM/NDljOCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYW50ZC9lcy9ub3RpZmljYXRpb24vc3R5bGUvc3RhY2suanM/Zjc2YiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYW50ZC9lcy9ub3RpZmljYXRpb24vc3R5bGUvaW5kZXguanM/ZmYxOSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYW50ZC9lcy9ub3RpZmljYXRpb24vdXRpbC5qcz8wZTY3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL25vdGlmaWNhdGlvbi91c2VOb3RpZmljYXRpb24uanM/M2E1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxudmFyIF9fcmVzdCA9IHRoaXMgJiYgdGhpcy5fX3Jlc3QgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpIHRbcFtpXV0gPSBzW3BbaV1dO1xuICB9XG4gIHJldHVybiB0O1xufTtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBDaGVja0NpcmNsZUZpbGxlZCBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvQ2hlY2tDaXJjbGVGaWxsZWRcIjtcbmltcG9ydCBDbG9zZUNpcmNsZUZpbGxlZCBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvQ2xvc2VDaXJjbGVGaWxsZWRcIjtcbmltcG9ydCBDbG9zZU91dGxpbmVkIGZyb20gXCJAYW50LWRlc2lnbi9pY29ucy9lcy9pY29ucy9DbG9zZU91dGxpbmVkXCI7XG5pbXBvcnQgRXhjbGFtYXRpb25DaXJjbGVGaWxsZWQgZnJvbSBcIkBhbnQtZGVzaWduL2ljb25zL2VzL2ljb25zL0V4Y2xhbWF0aW9uQ2lyY2xlRmlsbGVkXCI7XG5pbXBvcnQgSW5mb0NpcmNsZUZpbGxlZCBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvSW5mb0NpcmNsZUZpbGxlZFwiO1xuaW1wb3J0IExvYWRpbmdPdXRsaW5lZCBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvTG9hZGluZ091dGxpbmVkXCI7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IE5vdGljZSB9IGZyb20gJ3JjLW5vdGlmaWNhdGlvbic7XG5pbXBvcnQgeyBkZXZVc2VXYXJuaW5nIH0gZnJvbSAnLi4vX3V0aWwvd2FybmluZyc7XG5pbXBvcnQgeyBDb25maWdDb250ZXh0IH0gZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCB1c2VDU1NWYXJDbHMgZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyL2hvb2tzL3VzZUNTU1ZhckNscyc7XG5pbXBvcnQgdXNlU3R5bGUgZnJvbSAnLi9zdHlsZSc7XG5pbXBvcnQgUHVyZVBhbmVsU3R5bGUgZnJvbSAnLi9zdHlsZS9wdXJlLXBhbmVsJztcbmV4cG9ydCBjb25zdCBUeXBlSWNvbiA9IHtcbiAgaW5mbzogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSW5mb0NpcmNsZUZpbGxlZCwgbnVsbCksXG4gIHN1Y2Nlc3M6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENoZWNrQ2lyY2xlRmlsbGVkLCBudWxsKSxcbiAgZXJyb3I6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENsb3NlQ2lyY2xlRmlsbGVkLCBudWxsKSxcbiAgd2FybmluZzogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRXhjbGFtYXRpb25DaXJjbGVGaWxsZWQsIG51bGwpLFxuICBsb2FkaW5nOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMb2FkaW5nT3V0bGluZWQsIG51bGwpXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGdldENsb3NlSWNvbihwcmVmaXhDbHMsIGNsb3NlSWNvbikge1xuICBpZiAoY2xvc2VJY29uID09PSBudWxsIHx8IGNsb3NlSWNvbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY2xvc2VJY29uIHx8IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENsb3NlT3V0bGluZWQsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeENsc30tY2xvc2UtaWNvbmBcbiAgfSk7XG59XG5jb25zdCB0eXBlVG9JY29uID0ge1xuICBzdWNjZXNzOiBDaGVja0NpcmNsZUZpbGxlZCxcbiAgaW5mbzogSW5mb0NpcmNsZUZpbGxlZCxcbiAgZXJyb3I6IENsb3NlQ2lyY2xlRmlsbGVkLFxuICB3YXJuaW5nOiBFeGNsYW1hdGlvbkNpcmNsZUZpbGxlZFxufTtcbmV4cG9ydCBjb25zdCBQdXJlQ29udGVudCA9IHByb3BzID0+IHtcbiAgY29uc3Qge1xuICAgIHByZWZpeENscyxcbiAgICBpY29uLFxuICAgIHR5cGUsXG4gICAgbWVzc2FnZSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBhY3Rpb25zLFxuICAgIHJvbGUgPSAnYWxlcnQnXG4gIH0gPSBwcm9wcztcbiAgbGV0IGljb25Ob2RlID0gbnVsbDtcbiAgaWYgKGljb24pIHtcbiAgICBpY29uTm9kZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICBjbGFzc05hbWU6IGAke3ByZWZpeENsc30taWNvbmBcbiAgICB9LCBpY29uKTtcbiAgfSBlbHNlIGlmICh0eXBlKSB7XG4gICAgaWNvbk5vZGUgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudCh0eXBlVG9JY29uW3R5cGVdIHx8IG51bGwsIHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhgJHtwcmVmaXhDbHN9LWljb25gLCBgJHtwcmVmaXhDbHN9LWljb24tJHt0eXBlfWApXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgW2Ake3ByZWZpeENsc30td2l0aC1pY29uYF06IGljb25Ob2RlXG4gICAgfSksXG4gICAgcm9sZTogcm9sZVxuICB9LCBpY29uTm9kZSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4Q2xzfS1tZXNzYWdlYFxuICB9LCBtZXNzYWdlKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7cHJlZml4Q2xzfS1kZXNjcmlwdGlvbmBcbiAgfSwgZGVzY3JpcHRpb24pLCBhY3Rpb25zICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeENsc30tYWN0aW9uc2BcbiAgfSwgYWN0aW9ucykpO1xufTtcbi8qKiBAcHJpdmF0ZSBJbnRlcm5hbCBDb21wb25lbnQuIERvIG5vdCB1c2UgaW4geW91ciBwcm9kdWN0aW9uLiAqL1xuY29uc3QgUHVyZVBhbmVsID0gcHJvcHMgPT4ge1xuICBjb25zdCB7XG4gICAgICBwcmVmaXhDbHM6IHN0YXRpY1ByZWZpeENscyxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIGljb24sXG4gICAgICB0eXBlLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgYnRuLFxuICAgICAgYWN0aW9ucyxcbiAgICAgIGNsb3NhYmxlID0gdHJ1ZSxcbiAgICAgIGNsb3NlSWNvbixcbiAgICAgIGNsYXNzTmFtZTogbm90aWZpY2F0aW9uQ2xhc3NOYW1lXG4gICAgfSA9IHByb3BzLFxuICAgIHJlc3RQcm9wcyA9IF9fcmVzdChwcm9wcywgW1wicHJlZml4Q2xzXCIsIFwiY2xhc3NOYW1lXCIsIFwiaWNvblwiLCBcInR5cGVcIiwgXCJtZXNzYWdlXCIsIFwiZGVzY3JpcHRpb25cIiwgXCJidG5cIiwgXCJhY3Rpb25zXCIsIFwiY2xvc2FibGVcIiwgXCJjbG9zZUljb25cIiwgXCJjbGFzc05hbWVcIl0pO1xuICBjb25zdCB7XG4gICAgZ2V0UHJlZml4Q2xzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KENvbmZpZ0NvbnRleHQpO1xuICBjb25zdCBtZXJnZWRBY3Rpb25zID0gYWN0aW9ucyAhPT0gbnVsbCAmJiBhY3Rpb25zICE9PSB2b2lkIDAgPyBhY3Rpb25zIDogYnRuO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IHdhcm5pbmcgPSBkZXZVc2VXYXJuaW5nKCdOb3RpZmljYXRpb24nKTtcbiAgICB3YXJuaW5nLmRlcHJlY2F0ZWQoIWJ0biwgJ2J0bicsICdhY3Rpb25zJyk7XG4gIH1cbiAgY29uc3QgcHJlZml4Q2xzID0gc3RhdGljUHJlZml4Q2xzIHx8IGdldFByZWZpeENscygnbm90aWZpY2F0aW9uJyk7XG4gIGNvbnN0IG5vdGljZVByZWZpeENscyA9IGAke3ByZWZpeENsc30tbm90aWNlYDtcbiAgY29uc3Qgcm9vdENscyA9IHVzZUNTU1ZhckNscyhwcmVmaXhDbHMpO1xuICBjb25zdCBbd3JhcENTU1ZhciwgaGFzaElkLCBjc3NWYXJDbHNdID0gdXNlU3R5bGUocHJlZml4Q2xzLCByb290Q2xzKTtcbiAgcmV0dXJuIHdyYXBDU1NWYXIoLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhgJHtub3RpY2VQcmVmaXhDbHN9LXB1cmUtcGFuZWxgLCBoYXNoSWQsIGNsYXNzTmFtZSwgY3NzVmFyQ2xzLCByb290Q2xzKVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQdXJlUGFuZWxTdHlsZSwge1xuICAgIHByZWZpeENsczogcHJlZml4Q2xzXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChOb3RpY2UsIE9iamVjdC5hc3NpZ24oe30sIHJlc3RQcm9wcywge1xuICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgIGV2ZW50S2V5OiBcInB1cmVcIixcbiAgICBkdXJhdGlvbjogbnVsbCxcbiAgICBjbG9zYWJsZTogY2xvc2FibGUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgIG5vdGlmaWNhdGlvbkNsYXNzTmFtZVxuICAgIH0pLFxuICAgIGNsb3NlSWNvbjogZ2V0Q2xvc2VJY29uKHByZWZpeENscywgY2xvc2VJY29uKSxcbiAgICBjb250ZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQdXJlQ29udGVudCwge1xuICAgICAgcHJlZml4Q2xzOiBub3RpY2VQcmVmaXhDbHMsXG4gICAgICBpY29uOiBpY29uLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICBhY3Rpb25zOiBtZXJnZWRBY3Rpb25zXG4gICAgfSlcbiAgfSkpKSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgUHVyZVBhbmVsOyIsImltcG9ydCB7IEtleWZyYW1lcyB9IGZyb20gJ0BhbnQtZGVzaWduL2Nzc2luanMnO1xuY29uc3QgZ2VuTm90aWZpY2F0aW9uUGxhY2VtZW50U3R5bGUgPSB0b2tlbiA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb21wb25lbnRDbHMsXG4gICAgbm90aWZpY2F0aW9uTWFyZ2luRWRnZSxcbiAgICBhbmltYXRpb25NYXhIZWlnaHRcbiAgfSA9IHRva2VuO1xuICBjb25zdCBub3RpY2VDbHMgPSBgJHtjb21wb25lbnRDbHN9LW5vdGljZWA7XG4gIGNvbnN0IHJpZ2h0RmFkZUluID0gbmV3IEtleWZyYW1lcygnYW50Tm90aWZpY2F0aW9uRmFkZUluJywge1xuICAgICcwJSc6IHtcbiAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDEwMCUsIDAsIDApYCxcbiAgICAgIG9wYWNpdHk6IDBcbiAgICB9LFxuICAgICcxMDAlJzoge1xuICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgMCwgMClgLFxuICAgICAgb3BhY2l0eTogMVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHRvcEZhZGVJbiA9IG5ldyBLZXlmcmFtZXMoJ2FudE5vdGlmaWNhdGlvblRvcEZhZGVJbicsIHtcbiAgICAnMCUnOiB7XG4gICAgICB0b3A6IC1hbmltYXRpb25NYXhIZWlnaHQsXG4gICAgICBvcGFjaXR5OiAwXG4gICAgfSxcbiAgICAnMTAwJSc6IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIG9wYWNpdHk6IDFcbiAgICB9XG4gIH0pO1xuICBjb25zdCBib3R0b21GYWRlSW4gPSBuZXcgS2V5ZnJhbWVzKCdhbnROb3RpZmljYXRpb25Cb3R0b21GYWRlSW4nLCB7XG4gICAgJzAlJzoge1xuICAgICAgYm90dG9tOiB0b2tlbi5jYWxjKGFuaW1hdGlvbk1heEhlaWdodCkubXVsKC0xKS5lcXVhbCgpLFxuICAgICAgb3BhY2l0eTogMFxuICAgIH0sXG4gICAgJzEwMCUnOiB7XG4gICAgICBib3R0b206IDAsXG4gICAgICBvcGFjaXR5OiAxXG4gICAgfVxuICB9KTtcbiAgY29uc3QgbGVmdEZhZGVJbiA9IG5ldyBLZXlmcmFtZXMoJ2FudE5vdGlmaWNhdGlvbkxlZnRGYWRlSW4nLCB7XG4gICAgJzAlJzoge1xuICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApYCxcbiAgICAgIG9wYWNpdHk6IDBcbiAgICB9LFxuICAgICcxMDAlJzoge1xuICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgMCwgMClgLFxuICAgICAgb3BhY2l0eTogMVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgW2NvbXBvbmVudENsc106IHtcbiAgICAgIFtgJiR7Y29tcG9uZW50Q2xzfS10b3AsICYke2NvbXBvbmVudENsc30tYm90dG9tYF06IHtcbiAgICAgICAgbWFyZ2luSW5saW5lOiAwLFxuICAgICAgICBbbm90aWNlQ2xzXToge1xuICAgICAgICAgIG1hcmdpbklubGluZTogJ2F1dG8gYXV0bydcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtgJiR7Y29tcG9uZW50Q2xzfS10b3BgXToge1xuICAgICAgICBbYCR7Y29tcG9uZW50Q2xzfS1mYWRlLWVudGVyJHtjb21wb25lbnRDbHN9LWZhZGUtZW50ZXItYWN0aXZlLCAke2NvbXBvbmVudENsc30tZmFkZS1hcHBlYXIke2NvbXBvbmVudENsc30tZmFkZS1hcHBlYXItYWN0aXZlYF06IHtcbiAgICAgICAgICBhbmltYXRpb25OYW1lOiB0b3BGYWRlSW5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtgJiR7Y29tcG9uZW50Q2xzfS1ib3R0b21gXToge1xuICAgICAgICBbYCR7Y29tcG9uZW50Q2xzfS1mYWRlLWVudGVyJHtjb21wb25lbnRDbHN9LWZhZGUtZW50ZXItYWN0aXZlLCAke2NvbXBvbmVudENsc30tZmFkZS1hcHBlYXIke2NvbXBvbmVudENsc30tZmFkZS1hcHBlYXItYWN0aXZlYF06IHtcbiAgICAgICAgICBhbmltYXRpb25OYW1lOiBib3R0b21GYWRlSW5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtgJiR7Y29tcG9uZW50Q2xzfS10b3BSaWdodCwgJiR7Y29tcG9uZW50Q2xzfS1ib3R0b21SaWdodGBdOiB7XG4gICAgICAgIFtgJHtjb21wb25lbnRDbHN9LWZhZGUtZW50ZXIke2NvbXBvbmVudENsc30tZmFkZS1lbnRlci1hY3RpdmUsICR7Y29tcG9uZW50Q2xzfS1mYWRlLWFwcGVhciR7Y29tcG9uZW50Q2xzfS1mYWRlLWFwcGVhci1hY3RpdmVgXToge1xuICAgICAgICAgIGFuaW1hdGlvbk5hbWU6IHJpZ2h0RmFkZUluXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbYCYke2NvbXBvbmVudENsc30tdG9wTGVmdCwgJiR7Y29tcG9uZW50Q2xzfS1ib3R0b21MZWZ0YF06IHtcbiAgICAgICAgbWFyZ2luUmlnaHQ6IHtcbiAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICBfc2tpcF9jaGVja186IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbWFyZ2luTGVmdDoge1xuICAgICAgICAgIHZhbHVlOiBub3RpZmljYXRpb25NYXJnaW5FZGdlLFxuICAgICAgICAgIF9za2lwX2NoZWNrXzogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBbbm90aWNlQ2xzXToge1xuICAgICAgICAgIG1hcmdpbklubGluZUVuZDogJ2F1dG8nLFxuICAgICAgICAgIG1hcmdpbklubGluZVN0YXJ0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIFtgJHtjb21wb25lbnRDbHN9LWZhZGUtZW50ZXIke2NvbXBvbmVudENsc30tZmFkZS1lbnRlci1hY3RpdmUsICR7Y29tcG9uZW50Q2xzfS1mYWRlLWFwcGVhciR7Y29tcG9uZW50Q2xzfS1mYWRlLWFwcGVhci1hY3RpdmVgXToge1xuICAgICAgICAgIGFuaW1hdGlvbk5hbWU6IGxlZnRGYWRlSW5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5leHBvcnQgZGVmYXVsdCBnZW5Ob3RpZmljYXRpb25QbGFjZW1lbnRTdHlsZTsiLCJleHBvcnQgY29uc3QgTm90aWZpY2F0aW9uUGxhY2VtZW50cyA9IFsndG9wJywgJ3RvcExlZnQnLCAndG9wUmlnaHQnLCAnYm90dG9tJywgJ2JvdHRvbUxlZnQnLCAnYm90dG9tUmlnaHQnXTsiLCJpbXBvcnQgeyBOb3RpZmljYXRpb25QbGFjZW1lbnRzIH0gZnJvbSAnLi4vaW50ZXJmYWNlJztcbmNvbnN0IHBsYWNlbWVudEFsaWduUHJvcGVydHkgPSB7XG4gIHRvcExlZnQ6ICdsZWZ0JyxcbiAgdG9wUmlnaHQ6ICdyaWdodCcsXG4gIGJvdHRvbUxlZnQ6ICdsZWZ0JyxcbiAgYm90dG9tUmlnaHQ6ICdyaWdodCcsXG4gIHRvcDogJ2xlZnQnLFxuICBib3R0b206ICdsZWZ0J1xufTtcbmNvbnN0IGdlblBsYWNlbWVudFN0YWNrU3R5bGUgPSAodG9rZW4sIHBsYWNlbWVudCkgPT4ge1xuICBjb25zdCB7XG4gICAgY29tcG9uZW50Q2xzXG4gIH0gPSB0b2tlbjtcbiAgcmV0dXJuIHtcbiAgICBbYCR7Y29tcG9uZW50Q2xzfS0ke3BsYWNlbWVudH1gXToge1xuICAgICAgW2AmJHtjb21wb25lbnRDbHN9LXN0YWNrID4gJHtjb21wb25lbnRDbHN9LW5vdGljZS13cmFwcGVyYF06IHtcbiAgICAgICAgW3BsYWNlbWVudC5zdGFydHNXaXRoKCd0b3AnKSA/ICd0b3AnIDogJ2JvdHRvbSddOiAwLFxuICAgICAgICBbcGxhY2VtZW50QWxpZ25Qcm9wZXJ0eVtwbGFjZW1lbnRdXToge1xuICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgIF9za2lwX2NoZWNrXzogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbmNvbnN0IGdlblN0YWNrQ2hpbGRyZW5TdHlsZSA9IHRva2VuID0+IHtcbiAgY29uc3QgY2hpbGRyZW5TdHlsZSA9IHt9O1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHRva2VuLm5vdGlmaWNhdGlvblN0YWNrTGF5ZXI7IGkrKykge1xuICAgIGNoaWxkcmVuU3R5bGVbYCY6bnRoLWxhc3QtY2hpbGQoJHtpICsgMX0pYF0gPSB7XG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICBbYCYgPiAke3Rva2VuLmNvbXBvbmVudENsc30tbm90aWNlYF06IHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHt0b2tlbi5tb3Rpb25EdXJhdGlvbk1pZH1gXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgW2AmOm5vdCg6bnRoLWxhc3QtY2hpbGQoLW4rJHt0b2tlbi5ub3RpZmljYXRpb25TdGFja0xheWVyfSkpYF06IHtcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgIH1cbiAgfSwgY2hpbGRyZW5TdHlsZSk7XG59O1xuY29uc3QgZ2VuU3RhY2tlZE5vdGljZVN0eWxlID0gdG9rZW4gPT4ge1xuICBjb25zdCBjaGlsZHJlblN0eWxlID0ge307XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdG9rZW4ubm90aWZpY2F0aW9uU3RhY2tMYXllcjsgaSsrKSB7XG4gICAgY2hpbGRyZW5TdHlsZVtgJjpudGgtbGFzdC1jaGlsZCgke2kgKyAxfSlgXSA9IHtcbiAgICAgIGJhY2tncm91bmQ6IHRva2VuLmNvbG9yQmdCbHVyLFxuICAgICAgYmFja2Ryb3BGaWx0ZXI6ICdibHVyKDEwcHgpJyxcbiAgICAgICctd2Via2l0LWJhY2tkcm9wLWZpbHRlcic6ICdibHVyKDEwcHgpJ1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNoaWxkcmVuU3R5bGUpO1xufTtcbmNvbnN0IGdlblN0YWNrU3R5bGUgPSB0b2tlbiA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb21wb25lbnRDbHNcbiAgfSA9IHRva2VuO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgW2Ake2NvbXBvbmVudENsc30tc3RhY2tgXToge1xuICAgICAgW2AmID4gJHtjb21wb25lbnRDbHN9LW5vdGljZS13cmFwcGVyYF06IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB0cmFuc2l0aW9uOiBgdHJhbnNmb3JtICR7dG9rZW4ubW90aW9uRHVyYXRpb25TbG93fSwgYmFja2Ryb3AtZmlsdGVyIDBzYCxcbiAgICAgICAgd2lsbENoYW5nZTogJ3RyYW5zZm9ybSwgb3BhY2l0eScsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgICB9LCBnZW5TdGFja0NoaWxkcmVuU3R5bGUodG9rZW4pKVxuICAgIH0sXG4gICAgW2Ake2NvbXBvbmVudENsc30tc3RhY2s6bm90KCR7Y29tcG9uZW50Q2xzfS1zdGFjay1leHBhbmRlZClgXToge1xuICAgICAgW2AmID4gJHtjb21wb25lbnRDbHN9LW5vdGljZS13cmFwcGVyYF06IE9iamVjdC5hc3NpZ24oe30sIGdlblN0YWNrZWROb3RpY2VTdHlsZSh0b2tlbikpXG4gICAgfSxcbiAgICBbYCR7Y29tcG9uZW50Q2xzfS1zdGFjayR7Y29tcG9uZW50Q2xzfS1zdGFjay1leHBhbmRlZGBdOiB7XG4gICAgICBbYCYgPiAke2NvbXBvbmVudENsc30tbm90aWNlLXdyYXBwZXJgXToge1xuICAgICAgICAnJjpub3QoOm50aC1sYXN0LWNoaWxkKC1uICsgMSkpJzoge1xuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgb3ZlcmZsb3c6ICd1bnNldCcsXG4gICAgICAgICAgY29sb3I6ICdpbmhlcml0JyxcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnYXV0bycsXG4gICAgICAgICAgW2AmID4gJHt0b2tlbi5jb21wb25lbnRDbHN9LW5vdGljZWBdOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAnJjphZnRlcic6IHtcbiAgICAgICAgICBjb250ZW50OiAnXCJcIicsXG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgaGVpZ2h0OiB0b2tlbi5tYXJnaW4sXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBpbnNldElubGluZTogMCxcbiAgICAgICAgICBib3R0b206IHRva2VuLmNhbGModG9rZW4ubWFyZ2luKS5tdWwoLTEpLmVxdWFsKCksXG4gICAgICAgICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnYXV0bydcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgTm90aWZpY2F0aW9uUGxhY2VtZW50cy5tYXAocGxhY2VtZW50ID0+IGdlblBsYWNlbWVudFN0YWNrU3R5bGUodG9rZW4sIHBsYWNlbWVudCkpLnJlZHVjZSgoYWNjLCBjdXIpID0+IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjKSwgY3VyKSwge30pKTtcbn07XG5leHBvcnQgZGVmYXVsdCBnZW5TdGFja1N0eWxlOyIsImltcG9ydCB7IEtleWZyYW1lcywgdW5pdCB9IGZyb20gJ0BhbnQtZGVzaWduL2Nzc2luanMnO1xuaW1wb3J0IHsgQ09OVEFJTkVSX01BWF9PRkZTRVQgfSBmcm9tICcuLi8uLi9fdXRpbC9ob29rcy91c2VaSW5kZXgnO1xuaW1wb3J0IHsgZ2VuRm9jdXNTdHlsZSwgcmVzZXRDb21wb25lbnQgfSBmcm9tICcuLi8uLi9zdHlsZSc7XG5pbXBvcnQgeyBnZW5TdHlsZUhvb2tzLCBtZXJnZVRva2VuIH0gZnJvbSAnLi4vLi4vdGhlbWUvaW50ZXJuYWwnO1xuaW1wb3J0IGdlbk5vdGlmaWNhdGlvblBsYWNlbWVudFN0eWxlIGZyb20gJy4vcGxhY2VtZW50JztcbmltcG9ydCBnZW5TdGFja1N0eWxlIGZyb20gJy4vc3RhY2snO1xuZXhwb3J0IGNvbnN0IGdlbk5vdGljZVN0eWxlID0gdG9rZW4gPT4ge1xuICBjb25zdCB7XG4gICAgaWNvbkNscyxcbiAgICBjb21wb25lbnRDbHMsXG4gICAgLy8gLmFudC1ub3RpZmljYXRpb25cbiAgICBib3hTaGFkb3csXG4gICAgZm9udFNpemVMRyxcbiAgICBub3RpZmljYXRpb25NYXJnaW5Cb3R0b20sXG4gICAgYm9yZGVyUmFkaXVzTEcsXG4gICAgY29sb3JTdWNjZXNzLFxuICAgIGNvbG9ySW5mbyxcbiAgICBjb2xvcldhcm5pbmcsXG4gICAgY29sb3JFcnJvcixcbiAgICBjb2xvclRleHRIZWFkaW5nLFxuICAgIG5vdGlmaWNhdGlvbkJnLFxuICAgIG5vdGlmaWNhdGlvblBhZGRpbmcsXG4gICAgbm90aWZpY2F0aW9uTWFyZ2luRWRnZSxcbiAgICBub3RpZmljYXRpb25Qcm9ncmVzc0JnLFxuICAgIG5vdGlmaWNhdGlvblByb2dyZXNzSGVpZ2h0LFxuICAgIGZvbnRTaXplLFxuICAgIGxpbmVIZWlnaHQsXG4gICAgd2lkdGgsXG4gICAgbm90aWZpY2F0aW9uSWNvblNpemUsXG4gICAgY29sb3JUZXh0XG4gIH0gPSB0b2tlbjtcbiAgY29uc3Qgbm90aWNlQ2xzID0gYCR7Y29tcG9uZW50Q2xzfS1ub3RpY2VgO1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIG1hcmdpbkJvdHRvbTogbm90aWZpY2F0aW9uTWFyZ2luQm90dG9tLFxuICAgIG1hcmdpbklubGluZVN0YXJ0OiAnYXV0bycsXG4gICAgYmFja2dyb3VuZDogbm90aWZpY2F0aW9uQmcsXG4gICAgYm9yZGVyUmFkaXVzOiBib3JkZXJSYWRpdXNMRyxcbiAgICBib3hTaGFkb3csXG4gICAgW25vdGljZUNsc106IHtcbiAgICAgIHBhZGRpbmc6IG5vdGlmaWNhdGlvblBhZGRpbmcsXG4gICAgICB3aWR0aCxcbiAgICAgIG1heFdpZHRoOiBgY2FsYygxMDB2dyAtICR7dW5pdCh0b2tlbi5jYWxjKG5vdGlmaWNhdGlvbk1hcmdpbkVkZ2UpLm11bCgyKS5lcXVhbCgpKX0pYCxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIGxpbmVIZWlnaHQsXG4gICAgICB3b3JkV3JhcDogJ2JyZWFrLXdvcmQnXG4gICAgfSxcbiAgICBbYCR7bm90aWNlQ2xzfS1tZXNzYWdlYF06IHtcbiAgICAgIG1hcmdpbkJvdHRvbTogdG9rZW4ubWFyZ2luWFMsXG4gICAgICBjb2xvcjogY29sb3JUZXh0SGVhZGluZyxcbiAgICAgIGZvbnRTaXplOiBmb250U2l6ZUxHLFxuICAgICAgbGluZUhlaWdodDogdG9rZW4ubGluZUhlaWdodExHXG4gICAgfSxcbiAgICBbYCR7bm90aWNlQ2xzfS1kZXNjcmlwdGlvbmBdOiB7XG4gICAgICBmb250U2l6ZSxcbiAgICAgIGNvbG9yOiBjb2xvclRleHRcbiAgICB9LFxuICAgIFtgJHtub3RpY2VDbHN9LWNsb3NhYmxlICR7bm90aWNlQ2xzfS1tZXNzYWdlYF06IHtcbiAgICAgIHBhZGRpbmdJbmxpbmVFbmQ6IHRva2VuLnBhZGRpbmdMR1xuICAgIH0sXG4gICAgW2Ake25vdGljZUNsc30td2l0aC1pY29uICR7bm90aWNlQ2xzfS1tZXNzYWdlYF06IHtcbiAgICAgIG1hcmdpbkJvdHRvbTogdG9rZW4ubWFyZ2luWFMsXG4gICAgICBtYXJnaW5JbmxpbmVTdGFydDogdG9rZW4uY2FsYyh0b2tlbi5tYXJnaW5TTSkuYWRkKG5vdGlmaWNhdGlvbkljb25TaXplKS5lcXVhbCgpLFxuICAgICAgZm9udFNpemU6IGZvbnRTaXplTEdcbiAgICB9LFxuICAgIFtgJHtub3RpY2VDbHN9LXdpdGgtaWNvbiAke25vdGljZUNsc30tZGVzY3JpcHRpb25gXToge1xuICAgICAgbWFyZ2luSW5saW5lU3RhcnQ6IHRva2VuLmNhbGModG9rZW4ubWFyZ2luU00pLmFkZChub3RpZmljYXRpb25JY29uU2l6ZSkuZXF1YWwoKSxcbiAgICAgIGZvbnRTaXplXG4gICAgfSxcbiAgICAvLyBJY29uICYgY29sb3Igc3R5bGUgaW4gZGlmZmVyZW50IHNlbGVjdG9yIGxldmVsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FudC1kZXNpZ24vYW50LWRlc2lnbi9pc3N1ZXMvMTY1MDNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW50LWRlc2lnbi9hbnQtZGVzaWduL2lzc3Vlcy8xNTUxMlxuICAgIFtgJHtub3RpY2VDbHN9LWljb25gXToge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBmb250U2l6ZTogbm90aWZpY2F0aW9uSWNvblNpemUsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgLy8gaWNvbi1mb250XG4gICAgICBbYCYtc3VjY2VzcyR7aWNvbkNsc31gXToge1xuICAgICAgICBjb2xvcjogY29sb3JTdWNjZXNzXG4gICAgICB9LFxuICAgICAgW2AmLWluZm8ke2ljb25DbHN9YF06IHtcbiAgICAgICAgY29sb3I6IGNvbG9ySW5mb1xuICAgICAgfSxcbiAgICAgIFtgJi13YXJuaW5nJHtpY29uQ2xzfWBdOiB7XG4gICAgICAgIGNvbG9yOiBjb2xvcldhcm5pbmdcbiAgICAgIH0sXG4gICAgICBbYCYtZXJyb3Ike2ljb25DbHN9YF06IHtcbiAgICAgICAgY29sb3I6IGNvbG9yRXJyb3JcbiAgICAgIH1cbiAgICB9LFxuICAgIFtgJHtub3RpY2VDbHN9LWNsb3NlYF06IE9iamVjdC5hc3NpZ24oe1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB0b3A6IHRva2VuLm5vdGlmaWNhdGlvblBhZGRpbmdWZXJ0aWNhbCxcbiAgICAgIGluc2V0SW5saW5lRW5kOiB0b2tlbi5ub3RpZmljYXRpb25QYWRkaW5nSG9yaXpvbnRhbCxcbiAgICAgIGNvbG9yOiB0b2tlbi5jb2xvckljb24sXG4gICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICB3aWR0aDogdG9rZW4ubm90aWZpY2F0aW9uQ2xvc2VCdXR0b25TaXplLFxuICAgICAgaGVpZ2h0OiB0b2tlbi5ub3RpZmljYXRpb25DbG9zZUJ1dHRvblNpemUsXG4gICAgICBib3JkZXJSYWRpdXM6IHRva2VuLmJvcmRlclJhZGl1c1NNLFxuICAgICAgdHJhbnNpdGlvbjogYGJhY2tncm91bmQtY29sb3IgJHt0b2tlbi5tb3Rpb25EdXJhdGlvbk1pZH0sIGNvbG9yICR7dG9rZW4ubW90aW9uRHVyYXRpb25NaWR9YCxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgYmFja2dyb3VuZDogJ25vbmUnLFxuICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgY29sb3I6IHRva2VuLmNvbG9ySWNvbkhvdmVyLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRva2VuLmNvbG9yQmdUZXh0SG92ZXJcbiAgICAgIH0sXG4gICAgICAnJjphY3RpdmUnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdG9rZW4uY29sb3JCZ1RleHRBY3RpdmVcbiAgICAgIH1cbiAgICB9LCBnZW5Gb2N1c1N0eWxlKHRva2VuKSksXG4gICAgW2Ake25vdGljZUNsc30tcHJvZ3Jlc3NgXToge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgYXBwZWFyYW5jZTogJ25vbmUnLFxuICAgICAgaW5saW5lU2l6ZTogYGNhbGMoMTAwJSAtICR7dW5pdChib3JkZXJSYWRpdXNMRyl9ICogMilgLFxuICAgICAgbGVmdDoge1xuICAgICAgICBfc2tpcF9jaGVja186IHRydWUsXG4gICAgICAgIHZhbHVlOiBib3JkZXJSYWRpdXNMR1xuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7XG4gICAgICAgIF9za2lwX2NoZWNrXzogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGJvcmRlclJhZGl1c0xHXG4gICAgICB9LFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgYmxvY2tTaXplOiBub3RpZmljYXRpb25Qcm9ncmVzc0hlaWdodCxcbiAgICAgIGJvcmRlcjogMCxcbiAgICAgICcmLCAmOjotd2Via2l0LXByb2dyZXNzLWJhcic6IHtcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBib3JkZXJSYWRpdXNMRyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBgcmdiYSgwLCAwLCAwLCAwLjA0KWBcbiAgICAgIH0sXG4gICAgICAnJjo6LW1vei1wcm9ncmVzcy1iYXInOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IG5vdGlmaWNhdGlvblByb2dyZXNzQmdcbiAgICAgIH0sXG4gICAgICAnJjo6LXdlYmtpdC1wcm9ncmVzcy12YWx1ZSc6IHtcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBib3JkZXJSYWRpdXNMRyxcbiAgICAgICAgYmFja2dyb3VuZDogbm90aWZpY2F0aW9uUHJvZ3Jlc3NCZ1xuICAgICAgfVxuICAgIH0sXG4gICAgW2Ake25vdGljZUNsc30tYWN0aW9uc2BdOiB7XG4gICAgICBmbG9hdDogJ3JpZ2h0JyxcbiAgICAgIG1hcmdpblRvcDogdG9rZW4ubWFyZ2luU01cbiAgICB9XG4gIH07XG59O1xuY29uc3QgZ2VuTm90aWZpY2F0aW9uU3R5bGUgPSB0b2tlbiA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb21wb25lbnRDbHMsXG4gICAgLy8gLmFudC1ub3RpZmljYXRpb25cbiAgICBub3RpZmljYXRpb25NYXJnaW5Cb3R0b20sXG4gICAgbm90aWZpY2F0aW9uTWFyZ2luRWRnZSxcbiAgICBtb3Rpb25EdXJhdGlvbk1pZCxcbiAgICBtb3Rpb25FYXNlSW5PdXRcbiAgfSA9IHRva2VuO1xuICBjb25zdCBub3RpY2VDbHMgPSBgJHtjb21wb25lbnRDbHN9LW5vdGljZWA7XG4gIGNvbnN0IGZhZGVPdXQgPSBuZXcgS2V5ZnJhbWVzKCdhbnROb3RpZmljYXRpb25GYWRlT3V0Jywge1xuICAgICcwJSc6IHtcbiAgICAgIG1heEhlaWdodDogdG9rZW4uYW5pbWF0aW9uTWF4SGVpZ2h0LFxuICAgICAgbWFyZ2luQm90dG9tOiBub3RpZmljYXRpb25NYXJnaW5Cb3R0b21cbiAgICB9LFxuICAgICcxMDAlJzoge1xuICAgICAgbWF4SGVpZ2h0OiAwLFxuICAgICAgbWFyZ2luQm90dG9tOiAwLFxuICAgICAgcGFkZGluZ1RvcDogMCxcbiAgICAgIHBhZGRpbmdCb3R0b206IDAsXG4gICAgICBvcGFjaXR5OiAwXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PSBIb2xkZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB7XG4gICAgW2NvbXBvbmVudENsc106IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzZXRDb21wb25lbnQodG9rZW4pKSwge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICB6SW5kZXg6IHRva2VuLnpJbmRleFBvcHVwLFxuICAgICAgbWFyZ2luUmlnaHQ6IHtcbiAgICAgICAgdmFsdWU6IG5vdGlmaWNhdGlvbk1hcmdpbkVkZ2UsXG4gICAgICAgIF9za2lwX2NoZWNrXzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIFtgJHtjb21wb25lbnRDbHN9LWhvb2staG9sZGVyYF06IHtcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgIH0sXG4gICAgICAvLyAgYW5pbWF0aW9uXG4gICAgICBbYCR7Y29tcG9uZW50Q2xzfS1mYWRlLWFwcGVhci1wcmVwYXJlYF06IHtcbiAgICAgICAgb3BhY2l0eTogJzAgIWltcG9ydGFudCdcbiAgICAgIH0sXG4gICAgICBbYCR7Y29tcG9uZW50Q2xzfS1mYWRlLWVudGVyLCAke2NvbXBvbmVudENsc30tZmFkZS1hcHBlYXJgXToge1xuICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogdG9rZW4ubW90aW9uRHVyYXRpb25NaWQsXG4gICAgICAgIGFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uOiBtb3Rpb25FYXNlSW5PdXQsXG4gICAgICAgIGFuaW1hdGlvbkZpbGxNb2RlOiAnYm90aCcsXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIGFuaW1hdGlvblBsYXlTdGF0ZTogJ3BhdXNlZCdcbiAgICAgIH0sXG4gICAgICBbYCR7Y29tcG9uZW50Q2xzfS1mYWRlLWxlYXZlYF06IHtcbiAgICAgICAgYW5pbWF0aW9uVGltaW5nRnVuY3Rpb246IG1vdGlvbkVhc2VJbk91dCxcbiAgICAgICAgYW5pbWF0aW9uRmlsbE1vZGU6ICdib3RoJyxcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IG1vdGlvbkR1cmF0aW9uTWlkLFxuICAgICAgICBhbmltYXRpb25QbGF5U3RhdGU6ICdwYXVzZWQnXG4gICAgICB9LFxuICAgICAgW2Ake2NvbXBvbmVudENsc30tZmFkZS1lbnRlciR7Y29tcG9uZW50Q2xzfS1mYWRlLWVudGVyLWFjdGl2ZSwgJHtjb21wb25lbnRDbHN9LWZhZGUtYXBwZWFyJHtjb21wb25lbnRDbHN9LWZhZGUtYXBwZWFyLWFjdGl2ZWBdOiB7XG4gICAgICAgIGFuaW1hdGlvblBsYXlTdGF0ZTogJ3J1bm5pbmcnXG4gICAgICB9LFxuICAgICAgW2Ake2NvbXBvbmVudENsc30tZmFkZS1sZWF2ZSR7Y29tcG9uZW50Q2xzfS1mYWRlLWxlYXZlLWFjdGl2ZWBdOiB7XG4gICAgICAgIGFuaW1hdGlvbk5hbWU6IGZhZGVPdXQsXG4gICAgICAgIGFuaW1hdGlvblBsYXlTdGF0ZTogJ3J1bm5pbmcnXG4gICAgICB9LFxuICAgICAgLy8gUlRMXG4gICAgICAnJi1ydGwnOiB7XG4gICAgICAgIGRpcmVjdGlvbjogJ3J0bCcsXG4gICAgICAgIFtgJHtub3RpY2VDbHN9LWFjdGlvbnNgXToge1xuICAgICAgICAgIGZsb2F0OiAnbGVmdCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT0gTm90aWNlID09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAge1xuICAgIFtjb21wb25lbnRDbHNdOiB7XG4gICAgICBbYCR7bm90aWNlQ2xzfS13cmFwcGVyYF06IE9iamVjdC5hc3NpZ24oe30sIGdlbk5vdGljZVN0eWxlKHRva2VuKSlcbiAgICB9XG4gIH1dO1xufTtcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBFeHBvcnQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5leHBvcnQgY29uc3QgcHJlcGFyZUNvbXBvbmVudFRva2VuID0gdG9rZW4gPT4gKHtcbiAgekluZGV4UG9wdXA6IHRva2VuLnpJbmRleFBvcHVwQmFzZSArIENPTlRBSU5FUl9NQVhfT0ZGU0VUICsgNTAsXG4gIHdpZHRoOiAzODRcbn0pO1xuZXhwb3J0IGNvbnN0IHByZXBhcmVOb3RpZmljYXRpb25Ub2tlbiA9IHRva2VuID0+IHtcbiAgY29uc3Qgbm90aWZpY2F0aW9uUGFkZGluZ1ZlcnRpY2FsID0gdG9rZW4ucGFkZGluZ01EO1xuICBjb25zdCBub3RpZmljYXRpb25QYWRkaW5nSG9yaXpvbnRhbCA9IHRva2VuLnBhZGRpbmdMRztcbiAgY29uc3Qgbm90aWZpY2F0aW9uVG9rZW4gPSBtZXJnZVRva2VuKHRva2VuLCB7XG4gICAgbm90aWZpY2F0aW9uQmc6IHRva2VuLmNvbG9yQmdFbGV2YXRlZCxcbiAgICBub3RpZmljYXRpb25QYWRkaW5nVmVydGljYWwsXG4gICAgbm90aWZpY2F0aW9uUGFkZGluZ0hvcml6b250YWwsXG4gICAgbm90aWZpY2F0aW9uSWNvblNpemU6IHRva2VuLmNhbGModG9rZW4uZm9udFNpemVMRykubXVsKHRva2VuLmxpbmVIZWlnaHRMRykuZXF1YWwoKSxcbiAgICBub3RpZmljYXRpb25DbG9zZUJ1dHRvblNpemU6IHRva2VuLmNhbGModG9rZW4uY29udHJvbEhlaWdodExHKS5tdWwoMC41NSkuZXF1YWwoKSxcbiAgICBub3RpZmljYXRpb25NYXJnaW5Cb3R0b206IHRva2VuLm1hcmdpbixcbiAgICBub3RpZmljYXRpb25QYWRkaW5nOiBgJHt1bml0KHRva2VuLnBhZGRpbmdNRCl9ICR7dW5pdCh0b2tlbi5wYWRkaW5nQ29udGVudEhvcml6b250YWxMRyl9YCxcbiAgICBub3RpZmljYXRpb25NYXJnaW5FZGdlOiB0b2tlbi5tYXJnaW5MRyxcbiAgICBhbmltYXRpb25NYXhIZWlnaHQ6IDE1MCxcbiAgICBub3RpZmljYXRpb25TdGFja0xheWVyOiAzLFxuICAgIG5vdGlmaWNhdGlvblByb2dyZXNzSGVpZ2h0OiAyLFxuICAgIG5vdGlmaWNhdGlvblByb2dyZXNzQmc6IGBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICR7dG9rZW4uY29sb3JQcmltYXJ5Qm9yZGVySG92ZXJ9LCAke3Rva2VuLmNvbG9yUHJpbWFyeX0pYFxuICB9KTtcbiAgcmV0dXJuIG5vdGlmaWNhdGlvblRva2VuO1xufTtcbmV4cG9ydCBkZWZhdWx0IGdlblN0eWxlSG9va3MoJ05vdGlmaWNhdGlvbicsIHRva2VuID0+IHtcbiAgY29uc3Qgbm90aWZpY2F0aW9uVG9rZW4gPSBwcmVwYXJlTm90aWZpY2F0aW9uVG9rZW4odG9rZW4pO1xuICByZXR1cm4gW2dlbk5vdGlmaWNhdGlvblN0eWxlKG5vdGlmaWNhdGlvblRva2VuKSwgZ2VuTm90aWZpY2F0aW9uUGxhY2VtZW50U3R5bGUobm90aWZpY2F0aW9uVG9rZW4pLCBnZW5TdGFja1N0eWxlKG5vdGlmaWNhdGlvblRva2VuKV07XG59LCBwcmVwYXJlQ29tcG9uZW50VG9rZW4pOyIsImV4cG9ydCBmdW5jdGlvbiBnZXRQbGFjZW1lbnRTdHlsZShwbGFjZW1lbnQsIHRvcCwgYm90dG9tKSB7XG4gIGxldCBzdHlsZTtcbiAgc3dpdGNoIChwbGFjZW1lbnQpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgc3R5bGUgPSB7XG4gICAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpJyxcbiAgICAgICAgcmlnaHQ6ICdhdXRvJyxcbiAgICAgICAgdG9wLFxuICAgICAgICBib3R0b206ICdhdXRvJ1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RvcExlZnQnOlxuICAgICAgc3R5bGUgPSB7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcCxcbiAgICAgICAgYm90dG9tOiAnYXV0bydcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0b3BSaWdodCc6XG4gICAgICBzdHlsZSA9IHtcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHRvcCxcbiAgICAgICAgYm90dG9tOiAnYXV0bydcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgc3R5bGUgPSB7XG4gICAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpJyxcbiAgICAgICAgcmlnaHQ6ICdhdXRvJyxcbiAgICAgICAgdG9wOiAnYXV0bycsXG4gICAgICAgIGJvdHRvbVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JvdHRvbUxlZnQnOlxuICAgICAgc3R5bGUgPSB7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogJ2F1dG8nLFxuICAgICAgICBib3R0b21cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3R5bGUgPSB7XG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB0b3A6ICdhdXRvJyxcbiAgICAgICAgYm90dG9tXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHN0eWxlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vdGlvbihwcmVmaXhDbHMpIHtcbiAgcmV0dXJuIHtcbiAgICBtb3Rpb25OYW1lOiBgJHtwcmVmaXhDbHN9LWZhZGVgXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xvc2VJY29uQ29uZmlnKGNsb3NlSWNvbiwgbm90aWZpY2F0aW9uQ29uZmlnLCBub3RpZmljYXRpb24pIHtcbiAgaWYgKHR5cGVvZiBjbG9zZUljb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGNsb3NlSWNvbjtcbiAgfVxuICBpZiAodHlwZW9mIChub3RpZmljYXRpb25Db25maWcgPT09IG51bGwgfHwgbm90aWZpY2F0aW9uQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub3RpZmljYXRpb25Db25maWcuY2xvc2VJY29uKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbm90aWZpY2F0aW9uQ29uZmlnLmNsb3NlSWNvbjtcbiAgfVxuICByZXR1cm4gbm90aWZpY2F0aW9uID09PSBudWxsIHx8IG5vdGlmaWNhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm90aWZpY2F0aW9uLmNsb3NlSWNvbjtcbn0iLCJcInVzZSBjbGllbnRcIjtcblxudmFyIF9fcmVzdCA9IHRoaXMgJiYgdGhpcy5fX3Jlc3QgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpIHRbcFtpXV0gPSBzW3BbaV1dO1xuICB9XG4gIHJldHVybiB0O1xufTtcbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBOb3RpZmljYXRpb25Qcm92aWRlciwgdXNlTm90aWZpY2F0aW9uIGFzIHVzZVJjTm90aWZpY2F0aW9uIH0gZnJvbSAncmMtbm90aWZpY2F0aW9uJztcbmltcG9ydCB7IGRldlVzZVdhcm5pbmcgfSBmcm9tICcuLi9fdXRpbC93YXJuaW5nJztcbmltcG9ydCB7IENvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IHVzZUNTU1ZhckNscyBmcm9tICcuLi9jb25maWctcHJvdmlkZXIvaG9va3MvdXNlQ1NTVmFyQ2xzJztcbmltcG9ydCB7IHVzZVRva2VuIH0gZnJvbSAnLi4vdGhlbWUvaW50ZXJuYWwnO1xuaW1wb3J0IHsgZ2V0Q2xvc2VJY29uLCBQdXJlQ29udGVudCB9IGZyb20gJy4vUHVyZVBhbmVsJztcbmltcG9ydCB1c2VTdHlsZSBmcm9tICcuL3N0eWxlJztcbmltcG9ydCB7IGdldE1vdGlvbiwgZ2V0UGxhY2VtZW50U3R5bGUsIGdldENsb3NlSWNvbkNvbmZpZyB9IGZyb20gJy4vdXRpbCc7XG5jb25zdCBERUZBVUxUX09GRlNFVCA9IDI0O1xuY29uc3QgREVGQVVMVF9EVVJBVElPTiA9IDQuNTtcbmNvbnN0IERFRkFVTFRfUExBQ0VNRU5UID0gJ3RvcFJpZ2h0JztcbmNvbnN0IFdyYXBwZXIgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBwcmVmaXhDbHNcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHJvb3RDbHMgPSB1c2VDU1NWYXJDbHMocHJlZml4Q2xzKTtcbiAgY29uc3QgW3dyYXBDU1NWYXIsIGhhc2hJZCwgY3NzVmFyQ2xzXSA9IHVzZVN0eWxlKHByZWZpeENscywgcm9vdENscyk7XG4gIHJldHVybiB3cmFwQ1NTVmFyKC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE5vdGlmaWNhdGlvblByb3ZpZGVyLCB7XG4gICAgY2xhc3NOYW1lczoge1xuICAgICAgbGlzdDogY2xhc3NOYW1lcyhoYXNoSWQsIGNzc1ZhckNscywgcm9vdENscylcbiAgICB9XG4gIH0sIGNoaWxkcmVuKSk7XG59O1xuY29uc3QgcmVuZGVyTm90aWZpY2F0aW9ucyA9IChub2RlLCBfcmVmMikgPT4ge1xuICBsZXQge1xuICAgIHByZWZpeENscyxcbiAgICBrZXlcbiAgfSA9IF9yZWYyO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlciwge1xuICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgIGtleToga2V5XG4gIH0sIG5vZGUpO1xufTtcbmNvbnN0IEhvbGRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0b3AsXG4gICAgYm90dG9tLFxuICAgIHByZWZpeENsczogc3RhdGljUHJlZml4Q2xzLFxuICAgIGdldENvbnRhaW5lcjogc3RhdGljR2V0Q29udGFpbmVyLFxuICAgIG1heENvdW50LFxuICAgIHJ0bCxcbiAgICBvbkFsbFJlbW92ZWQsXG4gICAgc3RhY2ssXG4gICAgZHVyYXRpb24sXG4gICAgcGF1c2VPbkhvdmVyID0gdHJ1ZSxcbiAgICBzaG93UHJvZ3Jlc3NcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgZ2V0UHJlZml4Q2xzLFxuICAgIGdldFBvcHVwQ29udGFpbmVyLFxuICAgIG5vdGlmaWNhdGlvbixcbiAgICBkaXJlY3Rpb25cbiAgfSA9IHVzZUNvbnRleHQoQ29uZmlnQ29udGV4dCk7XG4gIGNvbnN0IFssIHRva2VuXSA9IHVzZVRva2VuKCk7XG4gIGNvbnN0IHByZWZpeENscyA9IHN0YXRpY1ByZWZpeENscyB8fCBnZXRQcmVmaXhDbHMoJ25vdGlmaWNhdGlvbicpO1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IFN0eWxlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgZ2V0U3R5bGUgPSBwbGFjZW1lbnQgPT4gZ2V0UGxhY2VtZW50U3R5bGUocGxhY2VtZW50LCB0b3AgIT09IG51bGwgJiYgdG9wICE9PSB2b2lkIDAgPyB0b3AgOiBERUZBVUxUX09GRlNFVCwgYm90dG9tICE9PSBudWxsICYmIGJvdHRvbSAhPT0gdm9pZCAwID8gYm90dG9tIDogREVGQVVMVF9PRkZTRVQpO1xuICBjb25zdCBnZXRDbGFzc05hbWUgPSAoKSA9PiBjbGFzc05hbWVzKHtcbiAgICBbYCR7cHJlZml4Q2xzfS1ydGxgXTogcnRsICE9PSBudWxsICYmIHJ0bCAhPT0gdm9pZCAwID8gcnRsIDogZGlyZWN0aW9uID09PSAncnRsJ1xuICB9KTtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IE1vdGlvbiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IGdldE5vdGlmaWNhdGlvbk1vdGlvbiA9ICgpID0+IGdldE1vdGlvbihwcmVmaXhDbHMpO1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gT3JpZ2luID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgW2FwaSwgaG9sZGVyXSA9IHVzZVJjTm90aWZpY2F0aW9uKHtcbiAgICBwcmVmaXhDbHMsXG4gICAgc3R5bGU6IGdldFN0eWxlLFxuICAgIGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lLFxuICAgIG1vdGlvbjogZ2V0Tm90aWZpY2F0aW9uTW90aW9uLFxuICAgIGNsb3NhYmxlOiB0cnVlLFxuICAgIGNsb3NlSWNvbjogZ2V0Q2xvc2VJY29uKHByZWZpeENscyksXG4gICAgZHVyYXRpb246IGR1cmF0aW9uICE9PSBudWxsICYmIGR1cmF0aW9uICE9PSB2b2lkIDAgPyBkdXJhdGlvbiA6IERFRkFVTFRfRFVSQVRJT04sXG4gICAgZ2V0Q29udGFpbmVyOiAoKSA9PiAoc3RhdGljR2V0Q29udGFpbmVyID09PSBudWxsIHx8IHN0YXRpY0dldENvbnRhaW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdGljR2V0Q29udGFpbmVyKCkpIHx8IChnZXRQb3B1cENvbnRhaW5lciA9PT0gbnVsbCB8fCBnZXRQb3B1cENvbnRhaW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0UG9wdXBDb250YWluZXIoKSkgfHwgZG9jdW1lbnQuYm9keSxcbiAgICBtYXhDb3VudCxcbiAgICBwYXVzZU9uSG92ZXIsXG4gICAgc2hvd1Byb2dyZXNzLFxuICAgIG9uQWxsUmVtb3ZlZCxcbiAgICByZW5kZXJOb3RpZmljYXRpb25zLFxuICAgIHN0YWNrOiBzdGFjayA9PT0gZmFsc2UgPyBmYWxzZSA6IHtcbiAgICAgIHRocmVzaG9sZDogdHlwZW9mIHN0YWNrID09PSAnb2JqZWN0JyA/IHN0YWNrID09PSBudWxsIHx8IHN0YWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGFjay50aHJlc2hvbGQgOiB1bmRlZmluZWQsXG4gICAgICBvZmZzZXQ6IDgsXG4gICAgICBnYXA6IHRva2VuLm1hcmdpblxuICAgIH1cbiAgfSk7XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IFJlZiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhcGkpLCB7XG4gICAgcHJlZml4Q2xzLFxuICAgIG5vdGlmaWNhdGlvblxuICB9KSk7XG4gIHJldHVybiBob2xkZXI7XG59KTtcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhvb2sgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnRlcm5hbE5vdGlmaWNhdGlvbihub3RpZmljYXRpb25Db25maWcpIHtcbiAgY29uc3QgaG9sZGVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCB3YXJuaW5nID0gZGV2VXNlV2FybmluZygnTm90aWZpY2F0aW9uJyk7XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IEFQSSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCB3cmFwQVBJID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgLy8gV3JhcCB3aXRoIG5vdGlmaWNhdGlvbiBjb250ZW50XG4gICAgLy8gPj4+IE9wZW5cbiAgICBjb25zdCBvcGVuID0gY29uZmlnID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghaG9sZGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ3VzYWdlJywgJ1lvdSBhcmUgY2FsbGluZyBub3RpY2UgaW4gcmVuZGVyIHdoaWNoIHdpbGwgYnJlYWsgaW4gUmVhY3QgMTggY29uY3VycmVudCBtb2RlLiBQbGVhc2UgdHJpZ2dlciBpbiBlZmZlY3QgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBvcGVuOiBvcmlnaW5PcGVuLFxuICAgICAgICBwcmVmaXhDbHMsXG4gICAgICAgIG5vdGlmaWNhdGlvblxuICAgICAgfSA9IGhvbGRlclJlZi5jdXJyZW50O1xuICAgICAgY29uc3Qgbm90aWNlUHJlZml4Q2xzID0gYCR7cHJlZml4Q2xzfS1ub3RpY2VgO1xuICAgICAgY29uc3Qge1xuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgaWNvbixcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGJ0bixcbiAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICByb2xlID0gJ2FsZXJ0JyxcbiAgICAgICAgICBjbG9zZUljb24sXG4gICAgICAgICAgY2xvc2FibGVcbiAgICAgICAgfSA9IGNvbmZpZyxcbiAgICAgICAgcmVzdENvbmZpZyA9IF9fcmVzdChjb25maWcsIFtcIm1lc3NhZ2VcIiwgXCJkZXNjcmlwdGlvblwiLCBcImljb25cIiwgXCJ0eXBlXCIsIFwiYnRuXCIsIFwiYWN0aW9uc1wiLCBcImNsYXNzTmFtZVwiLCBcInN0eWxlXCIsIFwicm9sZVwiLCBcImNsb3NlSWNvblwiLCBcImNsb3NhYmxlXCJdKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcuZGVwcmVjYXRlZCghYnRuLCAnYnRuJywgJ2FjdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lcmdlZEFjdGlvbnMgPSBhY3Rpb25zICE9PSBudWxsICYmIGFjdGlvbnMgIT09IHZvaWQgMCA/IGFjdGlvbnMgOiBidG47XG4gICAgICBjb25zdCByZWFsQ2xvc2VJY29uID0gZ2V0Q2xvc2VJY29uKG5vdGljZVByZWZpeENscywgZ2V0Q2xvc2VJY29uQ29uZmlnKGNsb3NlSWNvbiwgbm90aWZpY2F0aW9uQ29uZmlnLCBub3RpZmljYXRpb24pKTtcbiAgICAgIHJldHVybiBvcmlnaW5PcGVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIC8vIHVzZSBwbGFjZW1lbnQgZnJvbSBwcm9wcyBpbnN0ZWFkIG9mIGhhcmQtY29kaW5nIFwidG9wUmlnaHRcIlxuICAgICAgICBwbGFjZW1lbnQ6IChfYSA9IG5vdGlmaWNhdGlvbkNvbmZpZyA9PT0gbnVsbCB8fCBub3RpZmljYXRpb25Db25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vdGlmaWNhdGlvbkNvbmZpZy5wbGFjZW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERFRkFVTFRfUExBQ0VNRU5UXG4gICAgICB9LCByZXN0Q29uZmlnKSwge1xuICAgICAgICBjb250ZW50OiAoLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUHVyZUNvbnRlbnQsIHtcbiAgICAgICAgICBwcmVmaXhDbHM6IG5vdGljZVByZWZpeENscyxcbiAgICAgICAgICBpY29uOiBpY29uLFxuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgICAgYWN0aW9uczogbWVyZ2VkQWN0aW9ucyxcbiAgICAgICAgICByb2xlOiByb2xlXG4gICAgICAgIH0pKSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHR5cGUgJiYgYCR7bm90aWNlUHJlZml4Q2xzfS0ke3R5cGV9YCwgY2xhc3NOYW1lLCBub3RpZmljYXRpb24gPT09IG51bGwgfHwgbm90aWZpY2F0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub3RpZmljYXRpb24uY2xhc3NOYW1lKSxcbiAgICAgICAgc3R5bGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbm90aWZpY2F0aW9uID09PSBudWxsIHx8IG5vdGlmaWNhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm90aWZpY2F0aW9uLnN0eWxlKSwgc3R5bGUpLFxuICAgICAgICBjbG9zZUljb246IHJlYWxDbG9zZUljb24sXG4gICAgICAgIGNsb3NhYmxlOiBjbG9zYWJsZSAhPT0gbnVsbCAmJiBjbG9zYWJsZSAhPT0gdm9pZCAwID8gY2xvc2FibGUgOiAhIXJlYWxDbG9zZUljb25cbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIC8vID4+PiBkZXN0cm95XG4gICAgY29uc3QgZGVzdHJveSA9IGtleSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIChfYSA9IGhvbGRlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2Uoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChfYiA9IGhvbGRlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2xvbmUgPSB7XG4gICAgICBvcGVuLFxuICAgICAgZGVzdHJveVxuICAgIH07XG4gICAgY29uc3Qga2V5cyA9IFsnc3VjY2VzcycsICdpbmZvJywgJ3dhcm5pbmcnLCAnZXJyb3InXTtcbiAgICBrZXlzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICBjbG9uZVt0eXBlXSA9IGNvbmZpZyA9PiBvcGVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwge1xuICAgICAgICB0eXBlXG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9LCBbXSk7XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBSZXR1cm4gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICByZXR1cm4gW3dyYXBBUEksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEhvbGRlciwgT2JqZWN0LmFzc2lnbih7XG4gICAga2V5OiBcIm5vdGlmaWNhdGlvbi1ob2xkZXJcIlxuICB9LCBub3RpZmljYXRpb25Db25maWcsIHtcbiAgICByZWY6IGhvbGRlclJlZlxuICB9KSldO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbkNvbmZpZykge1xuICByZXR1cm4gdXNlSW50ZXJuYWxOb3RpZmljYXRpb24obm90aWZpY2F0aW9uQ29uZmlnKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///51288\n")},94691:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ modal_useModal)\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 2 modules\nvar toConsumableArray = __webpack_require__(60436);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(96540);\n// EXTERNAL MODULE: ./node_modules/antd/es/_util/hooks/usePatchElement.js\nvar usePatchElement = __webpack_require__(16799);\n;// ./node_modules/antd/es/modal/confirm.js\n\"use client\";\n\n\n\n\n\n\n\n\n\nlet defaultRootPrefixCls = '';\nfunction getRootPrefixCls() {\n  return defaultRootPrefixCls;\n}\nconst ConfirmDialogWrapper = props => {\n  var _a, _b;\n  const {\n    prefixCls: customizePrefixCls,\n    getContainer,\n    direction\n  } = props;\n  const runtimeLocale = getConfirmLocale();\n  const config = useContext(ConfigContext);\n  const rootPrefixCls = getRootPrefixCls() || config.getPrefixCls();\n  // because Modal.config set rootPrefixCls, which is different from other components\n  const prefixCls = customizePrefixCls || `${rootPrefixCls}-modal`;\n  let mergedGetContainer = getContainer;\n  if (mergedGetContainer === false) {\n    mergedGetContainer = undefined;\n    if (false) {}\n  }\n  return /*#__PURE__*/React.createElement(ConfirmDialog, Object.assign({}, props, {\n    rootPrefixCls: rootPrefixCls,\n    prefixCls: prefixCls,\n    iconPrefixCls: config.iconPrefixCls,\n    theme: config.theme,\n    direction: direction !== null && direction !== void 0 ? direction : config.direction,\n    locale: (_b = (_a = config.locale) === null || _a === void 0 ? void 0 : _a.Modal) !== null && _b !== void 0 ? _b : runtimeLocale,\n    getContainer: mergedGetContainer\n  }));\n};\nfunction confirm_confirm(config) {\n  const global = globalConfig();\n  if (false) {}\n  const container = document.createDocumentFragment();\n  let currentConfig = Object.assign(Object.assign({}, config), {\n    close,\n    open: true\n  });\n  let timeoutId;\n  let reactUnmount;\n  function destroy() {\n    var _a;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const triggerCancel = args.some(param => param === null || param === void 0 ? void 0 : param.triggerCancel);\n    if (triggerCancel) {\n      var _a2;\n      (_a = config.onCancel) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [config, () => {}].concat(_toConsumableArray(args.slice(1))));\n    }\n    for (let i = 0; i < destroyFns.length; i++) {\n      const fn = destroyFns[i];\n      if (fn === close) {\n        destroyFns.splice(i, 1);\n        break;\n      }\n    }\n    reactUnmount();\n  }\n  function render(props) {\n    clearTimeout(timeoutId);\n    /**\n     * https://github.com/ant-design/ant-design/issues/23623\n     *\n     * Sync render blocks React event. Let's make this async.\n     */\n    timeoutId = setTimeout(() => {\n      const rootPrefixCls = global.getPrefixCls(undefined, getRootPrefixCls());\n      const iconPrefixCls = global.getIconPrefixCls();\n      const theme = global.getTheme();\n      const dom = /*#__PURE__*/React.createElement(ConfirmDialogWrapper, Object.assign({}, props));\n      const reactRender = getReactRender();\n      reactUnmount = reactRender(/*#__PURE__*/React.createElement(ConfigProvider, {\n        prefixCls: rootPrefixCls,\n        iconPrefixCls: iconPrefixCls,\n        theme: theme\n      }, global.holderRender ? global.holderRender(dom) : dom), container);\n    });\n  }\n  function close() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    currentConfig = Object.assign(Object.assign({}, currentConfig), {\n      open: false,\n      afterClose: () => {\n        if (typeof config.afterClose === 'function') {\n          config.afterClose();\n        }\n        // @ts-ignore\n        destroy.apply(this, args);\n      }\n    });\n    // Legacy support\n    if (currentConfig.visible) {\n      delete currentConfig.visible;\n    }\n    render(currentConfig);\n  }\n  function update(configUpdate) {\n    if (typeof configUpdate === 'function') {\n      currentConfig = configUpdate(currentConfig);\n    } else {\n      currentConfig = Object.assign(Object.assign({}, currentConfig), configUpdate);\n    }\n    render(currentConfig);\n  }\n  render(currentConfig);\n  destroyFns.push(close);\n  return {\n    destroy: close,\n    update\n  };\n}\nfunction withWarn(props) {\n  return Object.assign(Object.assign({}, props), {\n    type: 'warning'\n  });\n}\nfunction withInfo(props) {\n  return Object.assign(Object.assign({}, props), {\n    type: 'info'\n  });\n}\nfunction withSuccess(props) {\n  return Object.assign(Object.assign({}, props), {\n    type: 'success'\n  });\n}\nfunction withError(props) {\n  return Object.assign(Object.assign({}, props), {\n    type: 'error'\n  });\n}\nfunction withConfirm(props) {\n  return Object.assign(Object.assign({}, props), {\n    type: 'confirm'\n  });\n}\nfunction modalGlobalConfig(_ref) {\n  let {\n    rootPrefixCls\n  } = _ref;\n   false ? 0 : void 0;\n  defaultRootPrefixCls = rootPrefixCls;\n}\n;// ./node_modules/antd/es/modal/destroyFns.js\nconst destroyFns_destroyFns = [];\n/* harmony default export */ const modal_destroyFns = (destroyFns_destroyFns);\n// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js\nvar context = __webpack_require__(62279);\n// EXTERNAL MODULE: ./node_modules/antd/es/locale/en_US.js + 2 modules\nvar en_US = __webpack_require__(3078);\n// EXTERNAL MODULE: ./node_modules/antd/es/locale/useLocale.js\nvar useLocale = __webpack_require__(19155);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/CheckCircleFilled.js + 1 modules\nvar CheckCircleFilled = __webpack_require__(38811);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/CloseCircleFilled.js + 1 modules\nvar CloseCircleFilled = __webpack_require__(36029);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/ExclamationCircleFilled.js + 1 modules\nvar ExclamationCircleFilled = __webpack_require__(7541);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/InfoCircleFilled.js + 1 modules\nvar InfoCircleFilled = __webpack_require__(17850);\n// EXTERNAL MODULE: ./node_modules/classnames/index.js\nvar classnames = __webpack_require__(46942);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n// EXTERNAL MODULE: ./node_modules/antd/es/_util/hooks/useZIndex.js\nvar useZIndex = __webpack_require__(60275);\n// EXTERNAL MODULE: ./node_modules/antd/es/_util/motion.js\nvar motion = __webpack_require__(23723);\n// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/index.js + 8 modules\nvar config_provider = __webpack_require__(78407);\n// EXTERNAL MODULE: ./node_modules/antd/es/theme/useToken.js + 3 modules\nvar useToken = __webpack_require__(39319);\n// EXTERNAL MODULE: ./node_modules/antd/es/_util/ActionButton.js\nvar ActionButton = __webpack_require__(58431);\n;// ./node_modules/antd/es/modal/context.js\n\nconst ModalContext = /*#__PURE__*/react.createContext({});\nconst {\n  Provider: ModalContextProvider\n} = ModalContext;\n;// ./node_modules/antd/es/modal/components/ConfirmCancelBtn.js\n\"use client\";\n\n\n\n\nconst ConfirmCancelBtn = () => {\n  const {\n    autoFocusButton,\n    cancelButtonProps,\n    cancelTextLocale,\n    isSilent,\n    mergedOkCancel,\n    rootPrefixCls,\n    close,\n    onCancel,\n    onConfirm\n  } = (0,react.useContext)(ModalContext);\n  return mergedOkCancel ? (/*#__PURE__*/react.createElement(ActionButton/* default */.A, {\n    isSilent: isSilent,\n    actionFn: onCancel,\n    close: function () {\n      close === null || close === void 0 ? void 0 : close.apply(void 0, arguments);\n      onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(false);\n    },\n    autoFocus: autoFocusButton === 'cancel',\n    buttonProps: cancelButtonProps,\n    prefixCls: `${rootPrefixCls}-btn`\n  }, cancelTextLocale)) : null;\n};\n/* harmony default export */ const components_ConfirmCancelBtn = (ConfirmCancelBtn);\n;// ./node_modules/antd/es/modal/components/ConfirmOkBtn.js\n\"use client\";\n\n\n\n\nconst ConfirmOkBtn = () => {\n  const {\n    autoFocusButton,\n    close,\n    isSilent,\n    okButtonProps,\n    rootPrefixCls,\n    okTextLocale,\n    okType,\n    onConfirm,\n    onOk\n  } = (0,react.useContext)(ModalContext);\n  return /*#__PURE__*/react.createElement(ActionButton/* default */.A, {\n    isSilent: isSilent,\n    type: okType || 'primary',\n    actionFn: onOk,\n    close: function () {\n      close === null || close === void 0 ? void 0 : close.apply(void 0, arguments);\n      onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(true);\n    },\n    autoFocus: autoFocusButton === 'ok',\n    buttonProps: okButtonProps,\n    prefixCls: `${rootPrefixCls}-btn`\n  }, okTextLocale);\n};\n/* harmony default export */ const components_ConfirmOkBtn = (ConfirmOkBtn);\n// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/CloseOutlined.js + 1 modules\nvar CloseOutlined = __webpack_require__(47852);\n// EXTERNAL MODULE: ./node_modules/rc-dialog/es/index.js + 8 modules\nvar es = __webpack_require__(33766);\n// EXTERNAL MODULE: ./node_modules/antd/es/_util/ContextIsolator.js\nvar ContextIsolator = __webpack_require__(62897);\n// EXTERNAL MODULE: ./node_modules/antd/es/_util/hooks/useClosable.js\nvar useClosable = __webpack_require__(70064);\n// EXTERNAL MODULE: ./node_modules/antd/es/_util/styleChecker.js\nvar styleChecker = __webpack_require__(75945);\n// EXTERNAL MODULE: ./node_modules/antd/es/_util/zindexContext.js\nvar zindexContext = __webpack_require__(72616);\n// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/hooks/useCSSVarCls.js\nvar useCSSVarCls = __webpack_require__(20934);\n// EXTERNAL MODULE: ./node_modules/antd/es/skeleton/index.js + 10 modules\nvar skeleton = __webpack_require__(97072);\n// EXTERNAL MODULE: ./node_modules/antd/es/watermark/context.js\nvar watermark_context = __webpack_require__(28557);\n// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/DisabledContext.js\nvar DisabledContext = __webpack_require__(98119);\n// EXTERNAL MODULE: ./node_modules/antd/es/button/index.js + 11 modules\nvar es_button = __webpack_require__(32365);\n;// ./node_modules/antd/es/modal/components/NormalCancelBtn.js\n\"use client\";\n\n\n\n\nconst NormalCancelBtn = () => {\n  const {\n    cancelButtonProps,\n    cancelTextLocale,\n    onCancel\n  } = (0,react.useContext)(ModalContext);\n  return /*#__PURE__*/react.createElement(es_button/* default */.Ay, Object.assign({\n    onClick: onCancel\n  }, cancelButtonProps), cancelTextLocale);\n};\n/* harmony default export */ const components_NormalCancelBtn = (NormalCancelBtn);\n// EXTERNAL MODULE: ./node_modules/antd/es/button/buttonHelpers.js\nvar buttonHelpers = __webpack_require__(39449);\n;// ./node_modules/antd/es/modal/components/NormalOkBtn.js\n\"use client\";\n\n\n\n\n\nconst NormalOkBtn = () => {\n  const {\n    confirmLoading,\n    okButtonProps,\n    okType,\n    okTextLocale,\n    onOk\n  } = (0,react.useContext)(ModalContext);\n  return /*#__PURE__*/react.createElement(es_button/* default */.Ay, Object.assign({}, (0,buttonHelpers/* convertLegacyProps */.DU)(okType), {\n    loading: confirmLoading,\n    onClick: onOk\n  }, okButtonProps), okTextLocale);\n};\n/* harmony default export */ const components_NormalOkBtn = (NormalOkBtn);\n// EXTERNAL MODULE: ./node_modules/antd/es/modal/locale.js\nvar modal_locale = __webpack_require__(21815);\n;// ./node_modules/antd/es/modal/shared.js\n\"use client\";\n\n\n\n\n\n\n\n\n\n\nfunction renderCloseIcon(prefixCls, closeIcon) {\n  return /*#__PURE__*/react.createElement(\"span\", {\n    className: `${prefixCls}-close-x`\n  }, closeIcon || /*#__PURE__*/react.createElement(CloseOutlined/* default */.A, {\n    className: `${prefixCls}-close-icon`\n  }));\n}\nconst Footer = props => {\n  const {\n    okText,\n    okType = 'primary',\n    cancelText,\n    confirmLoading,\n    onOk,\n    onCancel,\n    okButtonProps,\n    cancelButtonProps,\n    footer\n  } = props;\n  const [locale] = (0,useLocale/* default */.A)('Modal', (0,modal_locale/* getConfirmLocale */.l)());\n  // ================== Locale Text ==================\n  const okTextLocale = okText || (locale === null || locale === void 0 ? void 0 : locale.okText);\n  const cancelTextLocale = cancelText || (locale === null || locale === void 0 ? void 0 : locale.cancelText);\n  // ================= Context Value =================\n  const btnCtxValue = {\n    confirmLoading,\n    okButtonProps,\n    cancelButtonProps,\n    okTextLocale,\n    cancelTextLocale,\n    okType,\n    onOk,\n    onCancel\n  };\n  const btnCtxValueMemo = react.useMemo(() => btnCtxValue, (0,toConsumableArray/* default */.A)(Object.values(btnCtxValue)));\n  let footerNode;\n  if (typeof footer === 'function' || typeof footer === 'undefined') {\n    footerNode = /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(components_NormalCancelBtn, null), /*#__PURE__*/react.createElement(components_NormalOkBtn, null));\n    if (typeof footer === 'function') {\n      footerNode = footer(footerNode, {\n        OkBtn: components_NormalOkBtn,\n        CancelBtn: components_NormalCancelBtn\n      });\n    }\n    footerNode = /*#__PURE__*/react.createElement(ModalContextProvider, {\n      value: btnCtxValueMemo\n    }, footerNode);\n  } else {\n    footerNode = footer;\n  }\n  return /*#__PURE__*/react.createElement(DisabledContext/* DisabledContextProvider */.X, {\n    disabled: false\n  }, footerNode);\n};\n// EXTERNAL MODULE: ./node_modules/@ant-design/cssinjs/es/index.js + 30 modules\nvar cssinjs_es = __webpack_require__(67466);\n// EXTERNAL MODULE: ./node_modules/antd/es/grid/style/index.js\nvar style = __webpack_require__(25006);\n// EXTERNAL MODULE: ./node_modules/antd/es/style/index.js\nvar es_style = __webpack_require__(25905);\n// EXTERNAL MODULE: ./node_modules/antd/es/style/motion/fade.js\nvar fade = __webpack_require__(28680);\n// EXTERNAL MODULE: ./node_modules/antd/es/style/motion/zoom.js\nvar zoom = __webpack_require__(99077);\n// EXTERNAL MODULE: ./node_modules/@ant-design/cssinjs-utils/es/index.js + 12 modules\nvar cssinjs_utils_es = __webpack_require__(14277);\n// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/genStyleUtils.js\nvar genStyleUtils = __webpack_require__(37358);\n;// ./node_modules/antd/es/modal/style/index.js\n\n\n\n\n\n\nfunction box(position) {\n  return {\n    position,\n    inset: 0\n  };\n}\nconst genModalMaskStyle = token => {\n  const {\n    componentCls,\n    antCls\n  } = token;\n  return [{\n    [`${componentCls}-root`]: {\n      [`${componentCls}${antCls}-zoom-enter, ${componentCls}${antCls}-zoom-appear`]: {\n        // reset scale avoid mousePosition bug\n        transform: 'none',\n        opacity: 0,\n        animationDuration: token.motionDurationSlow,\n        // https://github.com/ant-design/ant-design/issues/11777\n        userSelect: 'none'\n      },\n      // https://github.com/ant-design/ant-design/issues/37329\n      // https://github.com/ant-design/ant-design/issues/40272\n      [`${componentCls}${antCls}-zoom-leave ${componentCls}-content`]: {\n        pointerEvents: 'none'\n      },\n      [`${componentCls}-mask`]: Object.assign(Object.assign({}, box('fixed')), {\n        zIndex: token.zIndexPopupBase,\n        height: '100%',\n        backgroundColor: token.colorBgMask,\n        pointerEvents: 'none',\n        [`${componentCls}-hidden`]: {\n          display: 'none'\n        }\n      }),\n      [`${componentCls}-wrap`]: Object.assign(Object.assign({}, box('fixed')), {\n        zIndex: token.zIndexPopupBase,\n        overflow: 'auto',\n        outline: 0,\n        WebkitOverflowScrolling: 'touch'\n      })\n    }\n  }, {\n    [`${componentCls}-root`]: (0,fade/* initFadeMotion */.p9)(token)\n  }];\n};\nconst genModalStyle = token => {\n  const {\n    componentCls\n  } = token;\n  return [\n  // ======================== Root =========================\n  {\n    [`${componentCls}-root`]: {\n      [`${componentCls}-wrap-rtl`]: {\n        direction: 'rtl'\n      },\n      [`${componentCls}-centered`]: {\n        textAlign: 'center',\n        '&::before': {\n          display: 'inline-block',\n          width: 0,\n          height: '100%',\n          verticalAlign: 'middle',\n          content: '\"\"'\n        },\n        [componentCls]: {\n          top: 0,\n          display: 'inline-block',\n          paddingBottom: 0,\n          textAlign: 'start',\n          verticalAlign: 'middle'\n        }\n      },\n      [`@media (max-width: ${token.screenSMMax}px)`]: {\n        [componentCls]: {\n          maxWidth: 'calc(100vw - 16px)',\n          margin: `${(0,cssinjs_es/* unit */.zA)(token.marginXS)} auto`\n        },\n        [`${componentCls}-centered`]: {\n          [componentCls]: {\n            flex: 1\n          }\n        }\n      }\n    }\n  },\n  // ======================== Modal ========================\n  {\n    [componentCls]: Object.assign(Object.assign({}, (0,es_style/* resetComponent */.dF)(token)), {\n      pointerEvents: 'none',\n      position: 'relative',\n      top: 100,\n      width: 'auto',\n      maxWidth: `calc(100vw - ${(0,cssinjs_es/* unit */.zA)(token.calc(token.margin).mul(2).equal())})`,\n      margin: '0 auto',\n      paddingBottom: token.paddingLG,\n      [`${componentCls}-title`]: {\n        margin: 0,\n        color: token.titleColor,\n        fontWeight: token.fontWeightStrong,\n        fontSize: token.titleFontSize,\n        lineHeight: token.titleLineHeight,\n        wordWrap: 'break-word'\n      },\n      [`${componentCls}-content`]: {\n        position: 'relative',\n        backgroundColor: token.contentBg,\n        backgroundClip: 'padding-box',\n        border: 0,\n        borderRadius: token.borderRadiusLG,\n        boxShadow: token.boxShadow,\n        pointerEvents: 'auto',\n        padding: token.contentPadding\n      },\n      [`${componentCls}-close`]: Object.assign({\n        position: 'absolute',\n        top: token.calc(token.modalHeaderHeight).sub(token.modalCloseBtnSize).div(2).equal(),\n        insetInlineEnd: token.calc(token.modalHeaderHeight).sub(token.modalCloseBtnSize).div(2).equal(),\n        zIndex: token.calc(token.zIndexPopupBase).add(10).equal(),\n        padding: 0,\n        color: token.modalCloseIconColor,\n        fontWeight: token.fontWeightStrong,\n        lineHeight: 1,\n        textDecoration: 'none',\n        background: 'transparent',\n        borderRadius: token.borderRadiusSM,\n        width: token.modalCloseBtnSize,\n        height: token.modalCloseBtnSize,\n        border: 0,\n        outline: 0,\n        cursor: 'pointer',\n        transition: `color ${token.motionDurationMid}, background-color ${token.motionDurationMid}`,\n        '&-x': {\n          display: 'flex',\n          fontSize: token.fontSizeLG,\n          fontStyle: 'normal',\n          lineHeight: (0,cssinjs_es/* unit */.zA)(token.modalCloseBtnSize),\n          justifyContent: 'center',\n          textTransform: 'none',\n          textRendering: 'auto'\n        },\n        '&:disabled': {\n          pointerEvents: 'none'\n        },\n        '&:hover': {\n          color: token.modalCloseIconHoverColor,\n          backgroundColor: token.colorBgTextHover,\n          textDecoration: 'none'\n        },\n        '&:active': {\n          backgroundColor: token.colorBgTextActive\n        }\n      }, (0,es_style/* genFocusStyle */.K8)(token)),\n      [`${componentCls}-header`]: {\n        color: token.colorText,\n        background: token.headerBg,\n        borderRadius: `${(0,cssinjs_es/* unit */.zA)(token.borderRadiusLG)} ${(0,cssinjs_es/* unit */.zA)(token.borderRadiusLG)} 0 0`,\n        marginBottom: token.headerMarginBottom,\n        padding: token.headerPadding,\n        borderBottom: token.headerBorderBottom\n      },\n      [`${componentCls}-body`]: {\n        fontSize: token.fontSize,\n        lineHeight: token.lineHeight,\n        wordWrap: 'break-word',\n        padding: token.bodyPadding,\n        [`${componentCls}-body-skeleton`]: {\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          justifyContent: 'center',\n          alignItems: 'center',\n          margin: `${(0,cssinjs_es/* unit */.zA)(token.margin)} auto`\n        }\n      },\n      [`${componentCls}-footer`]: {\n        textAlign: 'end',\n        background: token.footerBg,\n        marginTop: token.footerMarginTop,\n        padding: token.footerPadding,\n        borderTop: token.footerBorderTop,\n        borderRadius: token.footerBorderRadius,\n        [`> ${token.antCls}-btn + ${token.antCls}-btn`]: {\n          marginInlineStart: token.marginXS\n        }\n      },\n      [`${componentCls}-open`]: {\n        overflow: 'hidden'\n      }\n    })\n  },\n  // ======================== Pure =========================\n  {\n    [`${componentCls}-pure-panel`]: {\n      top: 'auto',\n      padding: 0,\n      display: 'flex',\n      flexDirection: 'column',\n      [`${componentCls}-content,\n          ${componentCls}-body,\n          ${componentCls}-confirm-body-wrapper`]: {\n        display: 'flex',\n        flexDirection: 'column',\n        flex: 'auto'\n      },\n      [`${componentCls}-confirm-body`]: {\n        marginBottom: 'auto'\n      }\n    }\n  }];\n};\nconst genRTLStyle = token => {\n  const {\n    componentCls\n  } = token;\n  return {\n    [`${componentCls}-root`]: {\n      [`${componentCls}-wrap-rtl`]: {\n        direction: 'rtl',\n        [`${componentCls}-confirm-body`]: {\n          direction: 'rtl'\n        }\n      }\n    }\n  };\n};\nconst genResponsiveWidthStyle = token => {\n  const {\n    componentCls\n  } = token;\n  const gridMediaSizesMap = (0,style/* getMediaSize */.i4)(token);\n  delete gridMediaSizesMap.xs;\n  const responsiveStyles = Object.keys(gridMediaSizesMap).map(key => ({\n    [`@media (min-width: ${(0,cssinjs_es/* unit */.zA)(gridMediaSizesMap[key])})`]: {\n      width: `var(--${componentCls.replace('.', '')}-${key}-width)`\n    }\n  }));\n  return {\n    [`${componentCls}-root`]: {\n      [componentCls]: [{\n        width: `var(--${componentCls.replace('.', '')}-xs-width)`\n      }].concat((0,toConsumableArray/* default */.A)(responsiveStyles))\n    }\n  };\n};\n// ============================== Export ==============================\nconst prepareToken = token => {\n  const headerPaddingVertical = token.padding;\n  const headerFontSize = token.fontSizeHeading5;\n  const headerLineHeight = token.lineHeightHeading5;\n  const modalToken = (0,cssinjs_utils_es/* mergeToken */.oX)(token, {\n    modalHeaderHeight: token.calc(token.calc(headerLineHeight).mul(headerFontSize).equal()).add(token.calc(headerPaddingVertical).mul(2).equal()).equal(),\n    modalFooterBorderColorSplit: token.colorSplit,\n    modalFooterBorderStyle: token.lineType,\n    modalFooterBorderWidth: token.lineWidth,\n    modalCloseIconColor: token.colorIcon,\n    modalCloseIconHoverColor: token.colorIconHover,\n    modalCloseBtnSize: token.controlHeight,\n    modalConfirmIconSize: token.fontHeight,\n    modalTitleHeight: token.calc(token.titleFontSize).mul(token.titleLineHeight).equal()\n  });\n  return modalToken;\n};\nconst prepareComponentToken = token => ({\n  footerBg: 'transparent',\n  headerBg: token.colorBgElevated,\n  titleLineHeight: token.lineHeightHeading5,\n  titleFontSize: token.fontSizeHeading5,\n  contentBg: token.colorBgElevated,\n  titleColor: token.colorTextHeading,\n  // internal\n  contentPadding: token.wireframe ? 0 : `${(0,cssinjs_es/* unit */.zA)(token.paddingMD)} ${(0,cssinjs_es/* unit */.zA)(token.paddingContentHorizontalLG)}`,\n  headerPadding: token.wireframe ? `${(0,cssinjs_es/* unit */.zA)(token.padding)} ${(0,cssinjs_es/* unit */.zA)(token.paddingLG)}` : 0,\n  headerBorderBottom: token.wireframe ? `${(0,cssinjs_es/* unit */.zA)(token.lineWidth)} ${token.lineType} ${token.colorSplit}` : 'none',\n  headerMarginBottom: token.wireframe ? 0 : token.marginXS,\n  bodyPadding: token.wireframe ? token.paddingLG : 0,\n  footerPadding: token.wireframe ? `${(0,cssinjs_es/* unit */.zA)(token.paddingXS)} ${(0,cssinjs_es/* unit */.zA)(token.padding)}` : 0,\n  footerBorderTop: token.wireframe ? `${(0,cssinjs_es/* unit */.zA)(token.lineWidth)} ${token.lineType} ${token.colorSplit}` : 'none',\n  footerBorderRadius: token.wireframe ? `0 0 ${(0,cssinjs_es/* unit */.zA)(token.borderRadiusLG)} ${(0,cssinjs_es/* unit */.zA)(token.borderRadiusLG)}` : 0,\n  footerMarginTop: token.wireframe ? 0 : token.marginSM,\n  confirmBodyPadding: token.wireframe ? `${(0,cssinjs_es/* unit */.zA)(token.padding * 2)} ${(0,cssinjs_es/* unit */.zA)(token.padding * 2)} ${(0,cssinjs_es/* unit */.zA)(token.paddingLG)}` : 0,\n  confirmIconMarginInlineEnd: token.wireframe ? token.margin : token.marginSM,\n  confirmBtnsMarginTop: token.wireframe ? token.marginLG : token.marginSM\n});\n/* harmony default export */ const modal_style = ((0,genStyleUtils/* genStyleHooks */.OF)('Modal', token => {\n  const modalToken = prepareToken(token);\n  return [genModalStyle(modalToken), genRTLStyle(modalToken), genModalMaskStyle(modalToken), (0,zoom/* initZoomMotion */.aB)(modalToken, 'zoom'), genResponsiveWidthStyle(modalToken)];\n}, prepareComponentToken, {\n  unitless: {\n    titleLineHeight: true\n  }\n}));\n;// ./node_modules/antd/es/modal/Modal.js\n\"use client\";\n\nvar __rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlet mousePosition;\n// ref: https://github.com/ant-design/ant-design/issues/15795\nconst getClickPosition = e => {\n  mousePosition = {\n    x: e.pageX,\n    y: e.pageY\n  };\n  // 100ms 内发生过点击事件，则从点击位置动画展示\n  // 否则直接 zoom 展示\n  // 这样可以兼容非点击方式展开\n  setTimeout(() => {\n    mousePosition = null;\n  }, 100);\n};\n// 只有点击事件支持从鼠标位置动画展开\nif ((0,styleChecker/* canUseDocElement */.q)()) {\n  document.documentElement.addEventListener('click', getClickPosition, true);\n}\nconst Modal = props => {\n  const {\n      prefixCls: customizePrefixCls,\n      className,\n      rootClassName,\n      open,\n      wrapClassName,\n      centered,\n      getContainer,\n      focusTriggerAfterClose = true,\n      style,\n      // Deprecated\n      visible,\n      width = 520,\n      footer,\n      classNames: modalClassNames,\n      styles: modalStyles,\n      children,\n      loading,\n      confirmLoading,\n      zIndex: customizeZIndex,\n      mousePosition: customizeMousePosition,\n      onOk,\n      onCancel\n    } = props,\n    restProps = __rest(props, [\"prefixCls\", \"className\", \"rootClassName\", \"open\", \"wrapClassName\", \"centered\", \"getContainer\", \"focusTriggerAfterClose\", \"style\", \"visible\", \"width\", \"footer\", \"classNames\", \"styles\", \"children\", \"loading\", \"confirmLoading\", \"zIndex\", \"mousePosition\", \"onOk\", \"onCancel\"]);\n  const {\n    getPopupContainer: getContextPopupContainer,\n    getPrefixCls,\n    direction,\n    modal: modalContext\n  } = react.useContext(context/* ConfigContext */.QO);\n  const handleCancel = e => {\n    if (confirmLoading) {\n      return;\n    }\n    onCancel === null || onCancel === void 0 ? void 0 : onCancel(e);\n  };\n  const handleOk = e => {\n    onOk === null || onOk === void 0 ? void 0 : onOk(e);\n  };\n  if (false) {}\n  const prefixCls = getPrefixCls('modal', customizePrefixCls);\n  const rootPrefixCls = getPrefixCls();\n  // Style\n  const rootCls = (0,useCSSVarCls/* default */.A)(prefixCls);\n  const [wrapCSSVar, hashId, cssVarCls] = modal_style(prefixCls, rootCls);\n  const wrapClassNameExtended = classnames_default()(wrapClassName, {\n    [`${prefixCls}-centered`]: centered !== null && centered !== void 0 ? centered : modalContext === null || modalContext === void 0 ? void 0 : modalContext.centered,\n    [`${prefixCls}-wrap-rtl`]: direction === 'rtl'\n  });\n  const dialogFooter = footer !== null && !loading ? (/*#__PURE__*/react.createElement(Footer, Object.assign({}, props, {\n    onOk: handleOk,\n    onCancel: handleCancel\n  }))) : null;\n  const [mergedClosable, mergedCloseIcon, closeBtnIsDisabled] = (0,useClosable/* default */.A)((0,useClosable/* pickClosable */.d)(props), (0,useClosable/* pickClosable */.d)(modalContext), {\n    closable: true,\n    closeIcon: /*#__PURE__*/react.createElement(CloseOutlined/* default */.A, {\n      className: `${prefixCls}-close-icon`\n    }),\n    closeIconRender: icon => renderCloseIcon(prefixCls, icon)\n  });\n  // ============================ Refs ============================\n  // Select `ant-modal-content` by `panelRef`\n  const panelRef = (0,watermark_context/* usePanelRef */.f)(`.${prefixCls}-content`);\n  // ============================ zIndex ============================\n  const [zIndex, contextZIndex] = (0,useZIndex/* useZIndex */.YK)('Modal', customizeZIndex);\n  // =========================== Width ============================\n  const [numWidth, responsiveWidth] = react.useMemo(() => {\n    if (width && typeof width === 'object') {\n      return [undefined, width];\n    }\n    return [width, undefined];\n  }, [width]);\n  const responsiveWidthVars = react.useMemo(() => {\n    const vars = {};\n    if (responsiveWidth) {\n      Object.keys(responsiveWidth).forEach(breakpoint => {\n        const breakpointWidth = responsiveWidth[breakpoint];\n        if (breakpointWidth !== undefined) {\n          vars[`--${prefixCls}-${breakpoint}-width`] = typeof breakpointWidth === 'number' ? `${breakpointWidth}px` : breakpointWidth;\n        }\n      });\n    }\n    return vars;\n  }, [responsiveWidth]);\n  // =========================== Render ===========================\n  return wrapCSSVar(/*#__PURE__*/react.createElement(ContextIsolator/* default */.A, {\n    form: true,\n    space: true\n  }, /*#__PURE__*/react.createElement(zindexContext/* default */.A.Provider, {\n    value: contextZIndex\n  }, /*#__PURE__*/react.createElement(es/* default */.A, Object.assign({\n    width: numWidth\n  }, restProps, {\n    zIndex: zIndex,\n    getContainer: getContainer === undefined ? getContextPopupContainer : getContainer,\n    prefixCls: prefixCls,\n    rootClassName: classnames_default()(hashId, rootClassName, cssVarCls, rootCls),\n    footer: dialogFooter,\n    visible: open !== null && open !== void 0 ? open : visible,\n    mousePosition: customizeMousePosition !== null && customizeMousePosition !== void 0 ? customizeMousePosition : mousePosition,\n    onClose: handleCancel,\n    closable: mergedClosable ? {\n      disabled: closeBtnIsDisabled,\n      closeIcon: mergedCloseIcon\n    } : mergedClosable,\n    closeIcon: mergedCloseIcon,\n    focusTriggerAfterClose: focusTriggerAfterClose,\n    transitionName: (0,motion/* getTransitionName */.b)(rootPrefixCls, 'zoom', props.transitionName),\n    maskTransitionName: (0,motion/* getTransitionName */.b)(rootPrefixCls, 'fade', props.maskTransitionName),\n    className: classnames_default()(hashId, className, modalContext === null || modalContext === void 0 ? void 0 : modalContext.className),\n    style: Object.assign(Object.assign(Object.assign({}, modalContext === null || modalContext === void 0 ? void 0 : modalContext.style), style), responsiveWidthVars),\n    classNames: Object.assign(Object.assign(Object.assign({}, modalContext === null || modalContext === void 0 ? void 0 : modalContext.classNames), modalClassNames), {\n      wrapper: classnames_default()(wrapClassNameExtended, modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.wrapper)\n    }),\n    styles: Object.assign(Object.assign({}, modalContext === null || modalContext === void 0 ? void 0 : modalContext.styles), modalStyles),\n    panelRef: panelRef\n  }), loading ? (/*#__PURE__*/react.createElement(skeleton/* default */.A, {\n    active: true,\n    title: false,\n    paragraph: {\n      rows: 4\n    },\n    className: `${prefixCls}-body-skeleton`\n  })) : children))));\n};\n/* harmony default export */ const modal_Modal = (Modal);\n;// ./node_modules/antd/es/modal/style/confirm.js\n// Style as confirm component\n\n\n\n\n// ============================= Confirm ==============================\nconst genModalConfirmStyle = token => {\n  const {\n    componentCls,\n    titleFontSize,\n    titleLineHeight,\n    modalConfirmIconSize,\n    fontSize,\n    lineHeight,\n    modalTitleHeight,\n    fontHeight,\n    confirmBodyPadding\n  } = token;\n  const confirmComponentCls = `${componentCls}-confirm`;\n  return {\n    [confirmComponentCls]: {\n      '&-rtl': {\n        direction: 'rtl'\n      },\n      [`${token.antCls}-modal-header`]: {\n        display: 'none'\n      },\n      [`${confirmComponentCls}-body-wrapper`]: Object.assign({}, (0,es_style/* clearFix */.t6)()),\n      [`&${componentCls} ${componentCls}-body`]: {\n        padding: confirmBodyPadding\n      },\n      // ====================== Body ======================\n      [`${confirmComponentCls}-body`]: {\n        display: 'flex',\n        flexWrap: 'nowrap',\n        alignItems: 'start',\n        [`> ${token.iconCls}`]: {\n          flex: 'none',\n          fontSize: modalConfirmIconSize,\n          marginInlineEnd: token.confirmIconMarginInlineEnd,\n          marginTop: token.calc(token.calc(fontHeight).sub(modalConfirmIconSize).equal()).div(2).equal()\n        },\n        [`&-has-title > ${token.iconCls}`]: {\n          marginTop: token.calc(token.calc(modalTitleHeight).sub(modalConfirmIconSize).equal()).div(2).equal()\n        }\n      },\n      [`${confirmComponentCls}-paragraph`]: {\n        display: 'flex',\n        flexDirection: 'column',\n        flex: 'auto',\n        rowGap: token.marginXS,\n        // https://github.com/ant-design/ant-design/issues/51912\n        maxWidth: `calc(100% - ${(0,cssinjs_es/* unit */.zA)(token.marginSM)})`\n      },\n      // https://github.com/ant-design/ant-design/issues/48159\n      [`${token.iconCls} + ${confirmComponentCls}-paragraph`]: {\n        maxWidth: `calc(100% - ${(0,cssinjs_es/* unit */.zA)(token.calc(token.modalConfirmIconSize).add(token.marginSM).equal())})`\n      },\n      [`${confirmComponentCls}-title`]: {\n        color: token.colorTextHeading,\n        fontWeight: token.fontWeightStrong,\n        fontSize: titleFontSize,\n        lineHeight: titleLineHeight\n      },\n      [`${confirmComponentCls}-content`]: {\n        color: token.colorText,\n        fontSize,\n        lineHeight\n      },\n      // ===================== Footer =====================\n      [`${confirmComponentCls}-btns`]: {\n        textAlign: 'end',\n        marginTop: token.confirmBtnsMarginTop,\n        [`${token.antCls}-btn + ${token.antCls}-btn`]: {\n          marginBottom: 0,\n          marginInlineStart: token.marginXS\n        }\n      }\n    },\n    [`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token.iconCls}`]: {\n      color: token.colorError\n    },\n    [`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token.iconCls},\n        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token.iconCls}`]: {\n      color: token.colorWarning\n    },\n    [`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token.iconCls}`]: {\n      color: token.colorInfo\n    },\n    [`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token.iconCls}`]: {\n      color: token.colorSuccess\n    }\n  };\n};\n// ============================== Export ==============================\n/* harmony default export */ const style_confirm = ((0,genStyleUtils/* genSubStyleComponent */.bf)(['Modal', 'confirm'], token => {\n  const modalToken = prepareToken(token);\n  return [genModalConfirmStyle(modalToken)];\n}, prepareComponentToken, {\n  // confirm is weak than modal since no conflict here\n  order: -1000\n}));\n;// ./node_modules/antd/es/modal/ConfirmDialog.js\n\"use client\";\n\n\nvar ConfirmDialog_rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ConfirmContent(props) {\n  const {\n      prefixCls,\n      icon,\n      okText,\n      cancelText,\n      confirmPrefixCls,\n      type,\n      okCancel,\n      footer,\n      // Legacy for static function usage\n      locale: staticLocale\n    } = props,\n    resetProps = ConfirmDialog_rest(props, [\"prefixCls\", \"icon\", \"okText\", \"cancelText\", \"confirmPrefixCls\", \"type\", \"okCancel\", \"footer\", \"locale\"]);\n  if (false) {}\n  // Icon\n  let mergedIcon = icon;\n  // 支持传入{ icon: null }来隐藏`Modal.confirm`默认的Icon\n  if (!icon && icon !== null) {\n    switch (type) {\n      case 'info':\n        mergedIcon = /*#__PURE__*/react.createElement(InfoCircleFilled/* default */.A, null);\n        break;\n      case 'success':\n        mergedIcon = /*#__PURE__*/react.createElement(CheckCircleFilled/* default */.A, null);\n        break;\n      case 'error':\n        mergedIcon = /*#__PURE__*/react.createElement(CloseCircleFilled/* default */.A, null);\n        break;\n      default:\n        mergedIcon = /*#__PURE__*/react.createElement(ExclamationCircleFilled/* default */.A, null);\n    }\n  }\n  // 默认为 true，保持向下兼容\n  const mergedOkCancel = okCancel !== null && okCancel !== void 0 ? okCancel : type === 'confirm';\n  const autoFocusButton = props.autoFocusButton === null ? false : props.autoFocusButton || 'ok';\n  const [locale] = (0,useLocale/* default */.A)('Modal');\n  const mergedLocale = staticLocale || locale;\n  // ================== Locale Text ==================\n  const okTextLocale = okText || (mergedOkCancel ? mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.okText : mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.justOkText);\n  const cancelTextLocale = cancelText || (mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.cancelText);\n  // ================= Context Value =================\n  const btnCtxValue = Object.assign({\n    autoFocusButton,\n    cancelTextLocale,\n    okTextLocale,\n    mergedOkCancel\n  }, resetProps);\n  const btnCtxValueMemo = react.useMemo(() => btnCtxValue, (0,toConsumableArray/* default */.A)(Object.values(btnCtxValue)));\n  // ====================== Footer Origin Node ======================\n  const footerOriginNode = /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(components_ConfirmCancelBtn, null), /*#__PURE__*/react.createElement(components_ConfirmOkBtn, null));\n  const hasTitle = props.title !== undefined && props.title !== null;\n  const bodyCls = `${confirmPrefixCls}-body`;\n  return /*#__PURE__*/react.createElement(\"div\", {\n    className: `${confirmPrefixCls}-body-wrapper`\n  }, /*#__PURE__*/react.createElement(\"div\", {\n    className: classnames_default()(bodyCls, {\n      [`${bodyCls}-has-title`]: hasTitle\n    })\n  }, mergedIcon, /*#__PURE__*/react.createElement(\"div\", {\n    className: `${confirmPrefixCls}-paragraph`\n  }, hasTitle && /*#__PURE__*/react.createElement(\"span\", {\n    className: `${confirmPrefixCls}-title`\n  }, props.title), /*#__PURE__*/react.createElement(\"div\", {\n    className: `${confirmPrefixCls}-content`\n  }, props.content))), footer === undefined || typeof footer === 'function' ? (/*#__PURE__*/react.createElement(ModalContextProvider, {\n    value: btnCtxValueMemo\n  }, /*#__PURE__*/react.createElement(\"div\", {\n    className: `${confirmPrefixCls}-btns`\n  }, typeof footer === 'function' ? footer(footerOriginNode, {\n    OkBtn: components_ConfirmOkBtn,\n    CancelBtn: components_ConfirmCancelBtn\n  }) : footerOriginNode))) : footer, /*#__PURE__*/react.createElement(style_confirm, {\n    prefixCls: prefixCls\n  }));\n}\nconst ConfirmDialog_ConfirmDialog = props => {\n  const {\n    close,\n    zIndex,\n    maskStyle,\n    direction,\n    prefixCls,\n    wrapClassName,\n    rootPrefixCls,\n    bodyStyle,\n    closable = false,\n    onConfirm,\n    styles\n  } = props;\n  if (false) {}\n  const confirmPrefixCls = `${prefixCls}-confirm`;\n  const width = props.width || 416;\n  const style = props.style || {};\n  const mask = props.mask === undefined ? true : props.mask;\n  // 默认为 false，保持旧版默认行为\n  const maskClosable = props.maskClosable === undefined ? false : props.maskClosable;\n  const classString = classnames_default()(confirmPrefixCls, `${confirmPrefixCls}-${props.type}`, {\n    [`${confirmPrefixCls}-rtl`]: direction === 'rtl'\n  }, props.className);\n  // ========================= zIndex =========================\n  const [, token] = (0,useToken/* default */.Ay)();\n  const mergedZIndex = react.useMemo(() => {\n    if (zIndex !== undefined) {\n      return zIndex;\n    }\n    // Static always use max zIndex\n    return token.zIndexPopupBase + useZIndex/* CONTAINER_MAX_OFFSET */.jH;\n  }, [zIndex, token]);\n  // ========================= Render =========================\n  return /*#__PURE__*/react.createElement(modal_Modal, Object.assign({}, props, {\n    className: classString,\n    wrapClassName: classnames_default()({\n      [`${confirmPrefixCls}-centered`]: !!props.centered\n    }, wrapClassName),\n    onCancel: () => {\n      close === null || close === void 0 ? void 0 : close({\n        triggerCancel: true\n      });\n      onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(false);\n    },\n    title: \"\",\n    footer: null,\n    transitionName: (0,motion/* getTransitionName */.b)(rootPrefixCls || '', 'zoom', props.transitionName),\n    maskTransitionName: (0,motion/* getTransitionName */.b)(rootPrefixCls || '', 'fade', props.maskTransitionName),\n    mask: mask,\n    maskClosable: maskClosable,\n    style: style,\n    styles: Object.assign({\n      body: bodyStyle,\n      mask: maskStyle\n    }, styles),\n    width: width,\n    zIndex: mergedZIndex,\n    closable: closable\n  }), /*#__PURE__*/react.createElement(ConfirmContent, Object.assign({}, props, {\n    confirmPrefixCls: confirmPrefixCls\n  })));\n};\nconst ConfirmDialog_ConfirmDialogWrapper = props => {\n  const {\n    rootPrefixCls,\n    iconPrefixCls,\n    direction,\n    theme\n  } = props;\n  return /*#__PURE__*/react.createElement(config_provider/* default */.Ay, {\n    prefixCls: rootPrefixCls,\n    iconPrefixCls: iconPrefixCls,\n    direction: direction,\n    theme: theme\n  }, /*#__PURE__*/react.createElement(ConfirmDialog_ConfirmDialog, Object.assign({}, props)));\n};\nif (false) {}\n/* harmony default export */ const modal_ConfirmDialog = (ConfirmDialog_ConfirmDialogWrapper);\n;// ./node_modules/antd/es/modal/useModal/HookModal.js\n\"use client\";\n\n\nvar HookModal_rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\n\n\n\n\nconst HookModal = (_a, ref) => {\n  var _b;\n  var {\n      afterClose: hookAfterClose,\n      config\n    } = _a,\n    restProps = HookModal_rest(_a, [\"afterClose\", \"config\"]);\n  const [open, setOpen] = react.useState(true);\n  const [innerConfig, setInnerConfig] = react.useState(config);\n  const {\n    direction,\n    getPrefixCls\n  } = react.useContext(context/* ConfigContext */.QO);\n  const prefixCls = getPrefixCls('modal');\n  const rootPrefixCls = getPrefixCls();\n  const afterClose = () => {\n    var _a;\n    hookAfterClose();\n    (_a = innerConfig.afterClose) === null || _a === void 0 ? void 0 : _a.call(innerConfig);\n  };\n  const close = function () {\n    var _a;\n    setOpen(false);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const triggerCancel = args.some(param => param === null || param === void 0 ? void 0 : param.triggerCancel);\n    if (triggerCancel) {\n      var _a2;\n      (_a = innerConfig.onCancel) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [innerConfig, () => {}].concat((0,toConsumableArray/* default */.A)(args.slice(1))));\n    }\n  };\n  react.useImperativeHandle(ref, () => ({\n    destroy: close,\n    update: newConfig => {\n      setInnerConfig(originConfig => Object.assign(Object.assign({}, originConfig), newConfig));\n    }\n  }));\n  const mergedOkCancel = (_b = innerConfig.okCancel) !== null && _b !== void 0 ? _b : innerConfig.type === 'confirm';\n  const [contextLocale] = (0,useLocale/* default */.A)('Modal', en_US/* default */.A.Modal);\n  return /*#__PURE__*/react.createElement(modal_ConfirmDialog, Object.assign({\n    prefixCls: prefixCls,\n    rootPrefixCls: rootPrefixCls\n  }, innerConfig, {\n    close: close,\n    open: open,\n    afterClose: afterClose,\n    okText: innerConfig.okText || (mergedOkCancel ? contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.okText : contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.justOkText),\n    direction: innerConfig.direction || direction,\n    cancelText: innerConfig.cancelText || (contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.cancelText)\n  }, restProps));\n};\n/* harmony default export */ const useModal_HookModal = (/*#__PURE__*/react.forwardRef(HookModal));\n;// ./node_modules/antd/es/modal/useModal/index.js\n\"use client\";\n\n\n\n\n\n\n\nlet uuid = 0;\nconst ElementsHolder = /*#__PURE__*/react.memo(/*#__PURE__*/react.forwardRef((_props, ref) => {\n  const [elements, patchElement] = (0,usePatchElement/* default */.A)();\n  react.useImperativeHandle(ref, () => ({\n    patchElement\n  }), []);\n  return /*#__PURE__*/react.createElement(react.Fragment, null, elements);\n}));\nfunction useModal() {\n  const holderRef = react.useRef(null);\n  // ========================== Effect ==========================\n  const [actionQueue, setActionQueue] = react.useState([]);\n  react.useEffect(() => {\n    if (actionQueue.length) {\n      const cloneQueue = (0,toConsumableArray/* default */.A)(actionQueue);\n      cloneQueue.forEach(action => {\n        action();\n      });\n      setActionQueue([]);\n    }\n  }, [actionQueue]);\n  // =========================== Hook ===========================\n  const getConfirmFunc = react.useCallback(withFunc => function hookConfirm(config) {\n    var _a;\n    uuid += 1;\n    const modalRef = /*#__PURE__*/react.createRef();\n    // Proxy to promise with `onClose`\n    let resolvePromise;\n    const promise = new Promise(resolve => {\n      resolvePromise = resolve;\n    });\n    let silent = false;\n    let closeFunc;\n    const modal = /*#__PURE__*/react.createElement(useModal_HookModal, {\n      key: `modal-${uuid}`,\n      config: withFunc(config),\n      ref: modalRef,\n      afterClose: () => {\n        closeFunc === null || closeFunc === void 0 ? void 0 : closeFunc();\n      },\n      isSilent: () => silent,\n      onConfirm: confirmed => {\n        resolvePromise(confirmed);\n      }\n    });\n    closeFunc = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.patchElement(modal);\n    if (closeFunc) {\n      modal_destroyFns.push(closeFunc);\n    }\n    const instance = {\n      destroy: () => {\n        function destroyAction() {\n          var _a;\n          (_a = modalRef.current) === null || _a === void 0 ? void 0 : _a.destroy();\n        }\n        if (modalRef.current) {\n          destroyAction();\n        } else {\n          setActionQueue(prev => [].concat((0,toConsumableArray/* default */.A)(prev), [destroyAction]));\n        }\n      },\n      update: newConfig => {\n        function updateAction() {\n          var _a;\n          (_a = modalRef.current) === null || _a === void 0 ? void 0 : _a.update(newConfig);\n        }\n        if (modalRef.current) {\n          updateAction();\n        } else {\n          setActionQueue(prev => [].concat((0,toConsumableArray/* default */.A)(prev), [updateAction]));\n        }\n      },\n      then: resolve => {\n        silent = true;\n        return promise.then(resolve);\n      }\n    };\n    return instance;\n  }, []);\n  const fns = react.useMemo(() => ({\n    info: getConfirmFunc(withInfo),\n    success: getConfirmFunc(withSuccess),\n    error: getConfirmFunc(withError),\n    warning: getConfirmFunc(withWarn),\n    confirm: getConfirmFunc(withConfirm)\n  }), []);\n  return [fns, /*#__PURE__*/react.createElement(ElementsHolder, {\n    key: \"modal-holder\",\n    ref: holderRef\n  })];\n}\n/* harmony default export */ const modal_useModal = (useModal);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ2OTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2FudGQvZXMvbW9kYWwvY29uZmlybS5qcz81N2NlIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL21vZGFsL2Rlc3Ryb3lGbnMuanM/NWFiNCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYW50ZC9lcy9tb2RhbC9jb250ZXh0LmpzP2NjY2IiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2FudGQvZXMvbW9kYWwvY29tcG9uZW50cy9Db25maXJtQ2FuY2VsQnRuLmpzPzU0MWMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2FudGQvZXMvbW9kYWwvY29tcG9uZW50cy9Db25maXJtT2tCdG4uanM/NGJhMCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYW50ZC9lcy9tb2RhbC9jb21wb25lbnRzL05vcm1hbENhbmNlbEJ0bi5qcz8yYmEzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL21vZGFsL2NvbXBvbmVudHMvTm9ybWFsT2tCdG4uanM/MjI2NSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYW50ZC9lcy9tb2RhbC9zaGFyZWQuanM/ODk5NyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYW50ZC9lcy9tb2RhbC9zdHlsZS9pbmRleC5qcz9kYWFiIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL21vZGFsL01vZGFsLmpzPzhlYjkiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2FudGQvZXMvbW9kYWwvc3R5bGUvY29uZmlybS5qcz83YjI0Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9hbnRkL2VzL21vZGFsL0NvbmZpcm1EaWFsb2cuanM/MDlmZiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYW50ZC9lcy9tb2RhbC91c2VNb2RhbC9Ib29rTW9kYWwuanM/YTJjYiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvYW50ZC9lcy9tb2RhbC91c2VNb2RhbC9pbmRleC5qcz83M2ZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheVwiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuLi9fdXRpbC93YXJuaW5nJztcbmltcG9ydCBDb25maWdQcm92aWRlciwgeyBDb25maWdDb250ZXh0LCBnbG9iYWxDb25maWcsIHdhcm5Db250ZXh0IH0gZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCB7IGdldFJlYWN0UmVuZGVyIH0gZnJvbSAnLi4vY29uZmlnLXByb3ZpZGVyL1Vuc3RhYmxlQ29udGV4dCc7XG5pbXBvcnQgQ29uZmlybURpYWxvZyBmcm9tICcuL0NvbmZpcm1EaWFsb2cnO1xuaW1wb3J0IGRlc3Ryb3lGbnMgZnJvbSAnLi9kZXN0cm95Rm5zJztcbmltcG9ydCB7IGdldENvbmZpcm1Mb2NhbGUgfSBmcm9tICcuL2xvY2FsZSc7XG5sZXQgZGVmYXVsdFJvb3RQcmVmaXhDbHMgPSAnJztcbmZ1bmN0aW9uIGdldFJvb3RQcmVmaXhDbHMoKSB7XG4gIHJldHVybiBkZWZhdWx0Um9vdFByZWZpeENscztcbn1cbmNvbnN0IENvbmZpcm1EaWFsb2dXcmFwcGVyID0gcHJvcHMgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB7XG4gICAgcHJlZml4Q2xzOiBjdXN0b21pemVQcmVmaXhDbHMsXG4gICAgZ2V0Q29udGFpbmVyLFxuICAgIGRpcmVjdGlvblxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJ1bnRpbWVMb2NhbGUgPSBnZXRDb25maXJtTG9jYWxlKCk7XG4gIGNvbnN0IGNvbmZpZyA9IHVzZUNvbnRleHQoQ29uZmlnQ29udGV4dCk7XG4gIGNvbnN0IHJvb3RQcmVmaXhDbHMgPSBnZXRSb290UHJlZml4Q2xzKCkgfHwgY29uZmlnLmdldFByZWZpeENscygpO1xuICAvLyBiZWNhdXNlIE1vZGFsLmNvbmZpZyBzZXQgcm9vdFByZWZpeENscywgd2hpY2ggaXMgZGlmZmVyZW50IGZyb20gb3RoZXIgY29tcG9uZW50c1xuICBjb25zdCBwcmVmaXhDbHMgPSBjdXN0b21pemVQcmVmaXhDbHMgfHwgYCR7cm9vdFByZWZpeENsc30tbW9kYWxgO1xuICBsZXQgbWVyZ2VkR2V0Q29udGFpbmVyID0gZ2V0Q29udGFpbmVyO1xuICBpZiAobWVyZ2VkR2V0Q29udGFpbmVyID09PSBmYWxzZSkge1xuICAgIG1lcmdlZEdldENvbnRhaW5lciA9IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ01vZGFsJywgJ1N0YXRpYyBtZXRob2Qgbm90IHN1cHBvcnQgYGdldENvbnRhaW5lcmAgdG8gYmUgYGZhbHNlYCBzaW5jZSBpdCBkbyBub3QgaGF2ZSBjb250ZXh0IGVudi4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbmZpcm1EaWFsb2csIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgcm9vdFByZWZpeENsczogcm9vdFByZWZpeENscyxcbiAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICBpY29uUHJlZml4Q2xzOiBjb25maWcuaWNvblByZWZpeENscyxcbiAgICB0aGVtZTogY29uZmlnLnRoZW1lLFxuICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uICE9PSBudWxsICYmIGRpcmVjdGlvbiAhPT0gdm9pZCAwID8gZGlyZWN0aW9uIDogY29uZmlnLmRpcmVjdGlvbixcbiAgICBsb2NhbGU6IChfYiA9IChfYSA9IGNvbmZpZy5sb2NhbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5Nb2RhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcnVudGltZUxvY2FsZSxcbiAgICBnZXRDb250YWluZXI6IG1lcmdlZEdldENvbnRhaW5lclxuICB9KSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29uZmlybShjb25maWcpIHtcbiAgY29uc3QgZ2xvYmFsID0gZ2xvYmFsQ29uZmlnKCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFnbG9iYWwuaG9sZGVyUmVuZGVyKSB7XG4gICAgd2FybkNvbnRleHQoJ01vZGFsJyk7XG4gIH1cbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBsZXQgY3VycmVudENvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwge1xuICAgIGNsb3NlLFxuICAgIG9wZW46IHRydWVcbiAgfSk7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIGxldCByZWFjdFVubW91bnQ7XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIF9hO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgY29uc3QgdHJpZ2dlckNhbmNlbCA9IGFyZ3Muc29tZShwYXJhbSA9PiBwYXJhbSA9PT0gbnVsbCB8fCBwYXJhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW0udHJpZ2dlckNhbmNlbCk7XG4gICAgaWYgKHRyaWdnZXJDYW5jZWwpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICAoX2EgPSBjb25maWcub25DYW5jZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2EyID0gX2EpLmNhbGwuYXBwbHkoX2EyLCBbY29uZmlnLCAoKSA9PiB7fV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhcmdzLnNsaWNlKDEpKSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc3Ryb3lGbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZuID0gZGVzdHJveUZuc1tpXTtcbiAgICAgIGlmIChmbiA9PT0gY2xvc2UpIHtcbiAgICAgICAgZGVzdHJveUZucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZWFjdFVubW91bnQoKTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXIocHJvcHMpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAvKipcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vYW50LWRlc2lnbi9hbnQtZGVzaWduL2lzc3Vlcy8yMzYyM1xuICAgICAqXG4gICAgICogU3luYyByZW5kZXIgYmxvY2tzIFJlYWN0IGV2ZW50LiBMZXQncyBtYWtlIHRoaXMgYXN5bmMuXG4gICAgICovXG4gICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCByb290UHJlZml4Q2xzID0gZ2xvYmFsLmdldFByZWZpeENscyh1bmRlZmluZWQsIGdldFJvb3RQcmVmaXhDbHMoKSk7XG4gICAgICBjb25zdCBpY29uUHJlZml4Q2xzID0gZ2xvYmFsLmdldEljb25QcmVmaXhDbHMoKTtcbiAgICAgIGNvbnN0IHRoZW1lID0gZ2xvYmFsLmdldFRoZW1lKCk7XG4gICAgICBjb25zdCBkb20gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb25maXJtRGlhbG9nV3JhcHBlciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKTtcbiAgICAgIGNvbnN0IHJlYWN0UmVuZGVyID0gZ2V0UmVhY3RSZW5kZXIoKTtcbiAgICAgIHJlYWN0VW5tb3VudCA9IHJlYWN0UmVuZGVyKC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbmZpZ1Byb3ZpZGVyLCB7XG4gICAgICAgIHByZWZpeENsczogcm9vdFByZWZpeENscyxcbiAgICAgICAgaWNvblByZWZpeENsczogaWNvblByZWZpeENscyxcbiAgICAgICAgdGhlbWU6IHRoZW1lXG4gICAgICB9LCBnbG9iYWwuaG9sZGVyUmVuZGVyID8gZ2xvYmFsLmhvbGRlclJlbmRlcihkb20pIDogZG9tKSwgY29udGFpbmVyKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgY3VycmVudENvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudENvbmZpZyksIHtcbiAgICAgIG9wZW46IGZhbHNlLFxuICAgICAgYWZ0ZXJDbG9zZTogKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5hZnRlckNsb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29uZmlnLmFmdGVyQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRlc3Ryb3kuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gTGVnYWN5IHN1cHBvcnRcbiAgICBpZiAoY3VycmVudENvbmZpZy52aXNpYmxlKSB7XG4gICAgICBkZWxldGUgY3VycmVudENvbmZpZy52aXNpYmxlO1xuICAgIH1cbiAgICByZW5kZXIoY3VycmVudENvbmZpZyk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlKGNvbmZpZ1VwZGF0ZSkge1xuICAgIGlmICh0eXBlb2YgY29uZmlnVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXJyZW50Q29uZmlnID0gY29uZmlnVXBkYXRlKGN1cnJlbnRDb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Q29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjdXJyZW50Q29uZmlnKSwgY29uZmlnVXBkYXRlKTtcbiAgICB9XG4gICAgcmVuZGVyKGN1cnJlbnRDb25maWcpO1xuICB9XG4gIHJlbmRlcihjdXJyZW50Q29uZmlnKTtcbiAgZGVzdHJveUZucy5wdXNoKGNsb3NlKTtcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBjbG9zZSxcbiAgICB1cGRhdGVcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aXRoV2Fybihwcm9wcykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHtcbiAgICB0eXBlOiAnd2FybmluZydcbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aEluZm8ocHJvcHMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCB7XG4gICAgdHlwZTogJ2luZm8nXG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhTdWNjZXNzKHByb3BzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwge1xuICAgIHR5cGU6ICdzdWNjZXNzJ1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aXRoRXJyb3IocHJvcHMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCB7XG4gICAgdHlwZTogJ2Vycm9yJ1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aXRoQ29uZmlybShwcm9wcykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHtcbiAgICB0eXBlOiAnY29uZmlybSdcbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbW9kYWxHbG9iYWxDb25maWcoX3JlZikge1xuICBsZXQge1xuICAgIHJvb3RQcmVmaXhDbHNcbiAgfSA9IF9yZWY7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdNb2RhbCcsICdNb2RhbC5jb25maWcgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBDb25maWdQcm92aWRlci5jb25maWcgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgZGVmYXVsdFJvb3RQcmVmaXhDbHMgPSByb290UHJlZml4Q2xzO1xufSIsImNvbnN0IGRlc3Ryb3lGbnMgPSBbXTtcbmV4cG9ydCBkZWZhdWx0IGRlc3Ryb3lGbnM7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBjb25zdCBNb2RhbENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG5leHBvcnQgY29uc3Qge1xuICBQcm92aWRlcjogTW9kYWxDb250ZXh0UHJvdmlkZXJcbn0gPSBNb2RhbENvbnRleHQ7IiwiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEFjdGlvbkJ1dHRvbiBmcm9tICcuLi8uLi9fdXRpbC9BY3Rpb25CdXR0b24nO1xuaW1wb3J0IHsgTW9kYWxDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dCc7XG5jb25zdCBDb25maXJtQ2FuY2VsQnRuID0gKCkgPT4ge1xuICBjb25zdCB7XG4gICAgYXV0b0ZvY3VzQnV0dG9uLFxuICAgIGNhbmNlbEJ1dHRvblByb3BzLFxuICAgIGNhbmNlbFRleHRMb2NhbGUsXG4gICAgaXNTaWxlbnQsXG4gICAgbWVyZ2VkT2tDYW5jZWwsXG4gICAgcm9vdFByZWZpeENscyxcbiAgICBjbG9zZSxcbiAgICBvbkNhbmNlbCxcbiAgICBvbkNvbmZpcm1cbiAgfSA9IHVzZUNvbnRleHQoTW9kYWxDb250ZXh0KTtcbiAgcmV0dXJuIG1lcmdlZE9rQ2FuY2VsID8gKC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFjdGlvbkJ1dHRvbiwge1xuICAgIGlzU2lsZW50OiBpc1NpbGVudCxcbiAgICBhY3Rpb25Gbjogb25DYW5jZWwsXG4gICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsb3NlID09PSBudWxsIHx8IGNsb3NlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZS5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgICBvbkNvbmZpcm0gPT09IG51bGwgfHwgb25Db25maXJtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNvbmZpcm0oZmFsc2UpO1xuICAgIH0sXG4gICAgYXV0b0ZvY3VzOiBhdXRvRm9jdXNCdXR0b24gPT09ICdjYW5jZWwnLFxuICAgIGJ1dHRvblByb3BzOiBjYW5jZWxCdXR0b25Qcm9wcyxcbiAgICBwcmVmaXhDbHM6IGAke3Jvb3RQcmVmaXhDbHN9LWJ0bmBcbiAgfSwgY2FuY2VsVGV4dExvY2FsZSkpIDogbnVsbDtcbn07XG5leHBvcnQgZGVmYXVsdCBDb25maXJtQ2FuY2VsQnRuOyIsIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBBY3Rpb25CdXR0b24gZnJvbSAnLi4vLi4vX3V0aWwvQWN0aW9uQnV0dG9uJztcbmltcG9ydCB7IE1vZGFsQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQnO1xuY29uc3QgQ29uZmlybU9rQnRuID0gKCkgPT4ge1xuICBjb25zdCB7XG4gICAgYXV0b0ZvY3VzQnV0dG9uLFxuICAgIGNsb3NlLFxuICAgIGlzU2lsZW50LFxuICAgIG9rQnV0dG9uUHJvcHMsXG4gICAgcm9vdFByZWZpeENscyxcbiAgICBva1RleHRMb2NhbGUsXG4gICAgb2tUeXBlLFxuICAgIG9uQ29uZmlybSxcbiAgICBvbk9rXG4gIH0gPSB1c2VDb250ZXh0KE1vZGFsQ29udGV4dCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBY3Rpb25CdXR0b24sIHtcbiAgICBpc1NpbGVudDogaXNTaWxlbnQsXG4gICAgdHlwZTogb2tUeXBlIHx8ICdwcmltYXJ5JyxcbiAgICBhY3Rpb25Gbjogb25PayxcbiAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgY2xvc2UgPT09IG51bGwgfHwgY2xvc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3NlLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICAgIG9uQ29uZmlybSA9PT0gbnVsbCB8fCBvbkNvbmZpcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ29uZmlybSh0cnVlKTtcbiAgICB9LFxuICAgIGF1dG9Gb2N1czogYXV0b0ZvY3VzQnV0dG9uID09PSAnb2snLFxuICAgIGJ1dHRvblByb3BzOiBva0J1dHRvblByb3BzLFxuICAgIHByZWZpeENsczogYCR7cm9vdFByZWZpeENsc30tYnRuYFxuICB9LCBva1RleHRMb2NhbGUpO1xufTtcbmV4cG9ydCBkZWZhdWx0IENvbmZpcm1Pa0J0bjsiLCJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQnV0dG9uIGZyb20gJy4uLy4uL2J1dHRvbic7XG5pbXBvcnQgeyBNb2RhbENvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0JztcbmNvbnN0IE5vcm1hbENhbmNlbEJ0biA9ICgpID0+IHtcbiAgY29uc3Qge1xuICAgIGNhbmNlbEJ1dHRvblByb3BzLFxuICAgIGNhbmNlbFRleHRMb2NhbGUsXG4gICAgb25DYW5jZWxcbiAgfSA9IHVzZUNvbnRleHQoTW9kYWxDb250ZXh0KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbiwgT2JqZWN0LmFzc2lnbih7XG4gICAgb25DbGljazogb25DYW5jZWxcbiAgfSwgY2FuY2VsQnV0dG9uUHJvcHMpLCBjYW5jZWxUZXh0TG9jYWxlKTtcbn07XG5leHBvcnQgZGVmYXVsdCBOb3JtYWxDYW5jZWxCdG47IiwiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi8uLi9idXR0b24nO1xuaW1wb3J0IHsgY29udmVydExlZ2FjeVByb3BzIH0gZnJvbSAnLi4vLi4vYnV0dG9uL2J1dHRvbkhlbHBlcnMnO1xuaW1wb3J0IHsgTW9kYWxDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dCc7XG5jb25zdCBOb3JtYWxPa0J0biA9ICgpID0+IHtcbiAgY29uc3Qge1xuICAgIGNvbmZpcm1Mb2FkaW5nLFxuICAgIG9rQnV0dG9uUHJvcHMsXG4gICAgb2tUeXBlLFxuICAgIG9rVGV4dExvY2FsZSxcbiAgICBvbk9rXG4gIH0gPSB1c2VDb250ZXh0KE1vZGFsQ29udGV4dCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChCdXR0b24sIE9iamVjdC5hc3NpZ24oe30sIGNvbnZlcnRMZWdhY3lQcm9wcyhva1R5cGUpLCB7XG4gICAgbG9hZGluZzogY29uZmlybUxvYWRpbmcsXG4gICAgb25DbGljazogb25Pa1xuICB9LCBva0J1dHRvblByb3BzKSwgb2tUZXh0TG9jYWxlKTtcbn07XG5leHBvcnQgZGVmYXVsdCBOb3JtYWxPa0J0bjsiLCJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXlcIjtcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQ2xvc2VPdXRsaW5lZCBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvQ2xvc2VPdXRsaW5lZFwiO1xuaW1wb3J0IHsgRGlzYWJsZWRDb250ZXh0UHJvdmlkZXIgfSBmcm9tICcuLi9jb25maWctcHJvdmlkZXIvRGlzYWJsZWRDb250ZXh0JztcbmltcG9ydCB7IHVzZUxvY2FsZSB9IGZyb20gJy4uL2xvY2FsZSc7XG5pbXBvcnQgTm9ybWFsQ2FuY2VsQnRuIGZyb20gJy4vY29tcG9uZW50cy9Ob3JtYWxDYW5jZWxCdG4nO1xuaW1wb3J0IE5vcm1hbE9rQnRuIGZyb20gJy4vY29tcG9uZW50cy9Ob3JtYWxPa0J0bic7XG5pbXBvcnQgeyBNb2RhbENvbnRleHRQcm92aWRlciB9IGZyb20gJy4vY29udGV4dCc7XG5pbXBvcnQgeyBnZXRDb25maXJtTG9jYWxlIH0gZnJvbSAnLi9sb2NhbGUnO1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckNsb3NlSWNvbihwcmVmaXhDbHMsIGNsb3NlSWNvbikge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeENsc30tY2xvc2UteGBcbiAgfSwgY2xvc2VJY29uIHx8IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENsb3NlT3V0bGluZWQsIHtcbiAgICBjbGFzc05hbWU6IGAke3ByZWZpeENsc30tY2xvc2UtaWNvbmBcbiAgfSkpO1xufVxuZXhwb3J0IGNvbnN0IEZvb3RlciA9IHByb3BzID0+IHtcbiAgY29uc3Qge1xuICAgIG9rVGV4dCxcbiAgICBva1R5cGUgPSAncHJpbWFyeScsXG4gICAgY2FuY2VsVGV4dCxcbiAgICBjb25maXJtTG9hZGluZyxcbiAgICBvbk9rLFxuICAgIG9uQ2FuY2VsLFxuICAgIG9rQnV0dG9uUHJvcHMsXG4gICAgY2FuY2VsQnV0dG9uUHJvcHMsXG4gICAgZm9vdGVyXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgW2xvY2FsZV0gPSB1c2VMb2NhbGUoJ01vZGFsJywgZ2V0Q29uZmlybUxvY2FsZSgpKTtcbiAgLy8gPT09PT09PT09PT09PT09PT09IExvY2FsZSBUZXh0ID09PT09PT09PT09PT09PT09PVxuICBjb25zdCBva1RleHRMb2NhbGUgPSBva1RleHQgfHwgKGxvY2FsZSA9PT0gbnVsbCB8fCBsb2NhbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvY2FsZS5va1RleHQpO1xuICBjb25zdCBjYW5jZWxUZXh0TG9jYWxlID0gY2FuY2VsVGV4dCB8fCAobG9jYWxlID09PSBudWxsIHx8IGxvY2FsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9jYWxlLmNhbmNlbFRleHQpO1xuICAvLyA9PT09PT09PT09PT09PT09PSBDb250ZXh0IFZhbHVlID09PT09PT09PT09PT09PT09XG4gIGNvbnN0IGJ0bkN0eFZhbHVlID0ge1xuICAgIGNvbmZpcm1Mb2FkaW5nLFxuICAgIG9rQnV0dG9uUHJvcHMsXG4gICAgY2FuY2VsQnV0dG9uUHJvcHMsXG4gICAgb2tUZXh0TG9jYWxlLFxuICAgIGNhbmNlbFRleHRMb2NhbGUsXG4gICAgb2tUeXBlLFxuICAgIG9uT2ssXG4gICAgb25DYW5jZWxcbiAgfTtcbiAgY29uc3QgYnRuQ3R4VmFsdWVNZW1vID0gUmVhY3QudXNlTWVtbygoKSA9PiBidG5DdHhWYWx1ZSwgX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC52YWx1ZXMoYnRuQ3R4VmFsdWUpKSk7XG4gIGxldCBmb290ZXJOb2RlO1xuICBpZiAodHlwZW9mIGZvb3RlciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZm9vdGVyID09PSAndW5kZWZpbmVkJykge1xuICAgIGZvb3Rlck5vZGUgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTm9ybWFsQ2FuY2VsQnRuLCBudWxsKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTm9ybWFsT2tCdG4sIG51bGwpKTtcbiAgICBpZiAodHlwZW9mIGZvb3RlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm9vdGVyTm9kZSA9IGZvb3Rlcihmb290ZXJOb2RlLCB7XG4gICAgICAgIE9rQnRuOiBOb3JtYWxPa0J0bixcbiAgICAgICAgQ2FuY2VsQnRuOiBOb3JtYWxDYW5jZWxCdG5cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb290ZXJOb2RlID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTW9kYWxDb250ZXh0UHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBidG5DdHhWYWx1ZU1lbW9cbiAgICB9LCBmb290ZXJOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICBmb290ZXJOb2RlID0gZm9vdGVyO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEaXNhYmxlZENvbnRleHRQcm92aWRlciwge1xuICAgIGRpc2FibGVkOiBmYWxzZVxuICB9LCBmb290ZXJOb2RlKTtcbn07IiwiaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXlcIjtcbmltcG9ydCB7IHVuaXQgfSBmcm9tICdAYW50LWRlc2lnbi9jc3NpbmpzJztcbmltcG9ydCB7IGdldE1lZGlhU2l6ZSB9IGZyb20gJy4uLy4uL2dyaWQvc3R5bGUnO1xuaW1wb3J0IHsgZ2VuRm9jdXNTdHlsZSwgcmVzZXRDb21wb25lbnQgfSBmcm9tICcuLi8uLi9zdHlsZSc7XG5pbXBvcnQgeyBpbml0RmFkZU1vdGlvbiwgaW5pdFpvb21Nb3Rpb24gfSBmcm9tICcuLi8uLi9zdHlsZS9tb3Rpb24nO1xuaW1wb3J0IHsgZ2VuU3R5bGVIb29rcywgbWVyZ2VUb2tlbiB9IGZyb20gJy4uLy4uL3RoZW1lL2ludGVybmFsJztcbmZ1bmN0aW9uIGJveChwb3NpdGlvbikge1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uLFxuICAgIGluc2V0OiAwXG4gIH07XG59XG5leHBvcnQgY29uc3QgZ2VuTW9kYWxNYXNrU3R5bGUgPSB0b2tlbiA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb21wb25lbnRDbHMsXG4gICAgYW50Q2xzXG4gIH0gPSB0b2tlbjtcbiAgcmV0dXJuIFt7XG4gICAgW2Ake2NvbXBvbmVudENsc30tcm9vdGBdOiB7XG4gICAgICBbYCR7Y29tcG9uZW50Q2xzfSR7YW50Q2xzfS16b29tLWVudGVyLCAke2NvbXBvbmVudENsc30ke2FudENsc30tem9vbS1hcHBlYXJgXToge1xuICAgICAgICAvLyByZXNldCBzY2FsZSBhdm9pZCBtb3VzZVBvc2l0aW9uIGJ1Z1xuICAgICAgICB0cmFuc2Zvcm06ICdub25lJyxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IHRva2VuLm1vdGlvbkR1cmF0aW9uU2xvdyxcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FudC1kZXNpZ24vYW50LWRlc2lnbi9pc3N1ZXMvMTE3NzdcbiAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnXG4gICAgICB9LFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FudC1kZXNpZ24vYW50LWRlc2lnbi9pc3N1ZXMvMzczMjlcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnQtZGVzaWduL2FudC1kZXNpZ24vaXNzdWVzLzQwMjcyXG4gICAgICBbYCR7Y29tcG9uZW50Q2xzfSR7YW50Q2xzfS16b29tLWxlYXZlICR7Y29tcG9uZW50Q2xzfS1jb250ZW50YF06IHtcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICB9LFxuICAgICAgW2Ake2NvbXBvbmVudENsc30tbWFza2BdOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJveCgnZml4ZWQnKSksIHtcbiAgICAgICAgekluZGV4OiB0b2tlbi56SW5kZXhQb3B1cEJhc2UsXG4gICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRva2VuLmNvbG9yQmdNYXNrLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgIFtgJHtjb21wb25lbnRDbHN9LWhpZGRlbmBdOiB7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgW2Ake2NvbXBvbmVudENsc30td3JhcGBdOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJveCgnZml4ZWQnKSksIHtcbiAgICAgICAgekluZGV4OiB0b2tlbi56SW5kZXhQb3B1cEJhc2UsXG4gICAgICAgIG92ZXJmbG93OiAnYXV0bycsXG4gICAgICAgIG91dGxpbmU6IDAsXG4gICAgICAgIFdlYmtpdE92ZXJmbG93U2Nyb2xsaW5nOiAndG91Y2gnXG4gICAgICB9KVxuICAgIH1cbiAgfSwge1xuICAgIFtgJHtjb21wb25lbnRDbHN9LXJvb3RgXTogaW5pdEZhZGVNb3Rpb24odG9rZW4pXG4gIH1dO1xufTtcbmNvbnN0IGdlbk1vZGFsU3R5bGUgPSB0b2tlbiA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb21wb25lbnRDbHNcbiAgfSA9IHRva2VuO1xuICByZXR1cm4gW1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT0gUm9vdCA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHtcbiAgICBbYCR7Y29tcG9uZW50Q2xzfS1yb290YF06IHtcbiAgICAgIFtgJHtjb21wb25lbnRDbHN9LXdyYXAtcnRsYF06IHtcbiAgICAgICAgZGlyZWN0aW9uOiAncnRsJ1xuICAgICAgfSxcbiAgICAgIFtgJHtjb21wb25lbnRDbHN9LWNlbnRlcmVkYF06IHtcbiAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgJyY6OmJlZm9yZSc6IHtcbiAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgICBjb250ZW50OiAnXCJcIidcbiAgICAgICAgfSxcbiAgICAgICAgW2NvbXBvbmVudENsc106IHtcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgcGFkZGluZ0JvdHRvbTogMCxcbiAgICAgICAgICB0ZXh0QWxpZ246ICdzdGFydCcsXG4gICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtgQG1lZGlhIChtYXgtd2lkdGg6ICR7dG9rZW4uc2NyZWVuU01NYXh9cHgpYF06IHtcbiAgICAgICAgW2NvbXBvbmVudENsc106IHtcbiAgICAgICAgICBtYXhXaWR0aDogJ2NhbGMoMTAwdncgLSAxNnB4KScsXG4gICAgICAgICAgbWFyZ2luOiBgJHt1bml0KHRva2VuLm1hcmdpblhTKX0gYXV0b2BcbiAgICAgICAgfSxcbiAgICAgICAgW2Ake2NvbXBvbmVudENsc30tY2VudGVyZWRgXToge1xuICAgICAgICAgIFtjb21wb25lbnRDbHNdOiB7XG4gICAgICAgICAgICBmbGV4OiAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT0gTW9kYWwgPT09PT09PT09PT09PT09PT09PT09PT09XG4gIHtcbiAgICBbY29tcG9uZW50Q2xzXTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXNldENvbXBvbmVudCh0b2tlbikpLCB7XG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHRvcDogMTAwLFxuICAgICAgd2lkdGg6ICdhdXRvJyxcbiAgICAgIG1heFdpZHRoOiBgY2FsYygxMDB2dyAtICR7dW5pdCh0b2tlbi5jYWxjKHRva2VuLm1hcmdpbikubXVsKDIpLmVxdWFsKCkpfSlgLFxuICAgICAgbWFyZ2luOiAnMCBhdXRvJyxcbiAgICAgIHBhZGRpbmdCb3R0b206IHRva2VuLnBhZGRpbmdMRyxcbiAgICAgIFtgJHtjb21wb25lbnRDbHN9LXRpdGxlYF06IHtcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBjb2xvcjogdG9rZW4udGl0bGVDb2xvcixcbiAgICAgICAgZm9udFdlaWdodDogdG9rZW4uZm9udFdlaWdodFN0cm9uZyxcbiAgICAgICAgZm9udFNpemU6IHRva2VuLnRpdGxlRm9udFNpemUsXG4gICAgICAgIGxpbmVIZWlnaHQ6IHRva2VuLnRpdGxlTGluZUhlaWdodCxcbiAgICAgICAgd29yZFdyYXA6ICdicmVhay13b3JkJ1xuICAgICAgfSxcbiAgICAgIFtgJHtjb21wb25lbnRDbHN9LWNvbnRlbnRgXToge1xuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0b2tlbi5jb250ZW50QmcsXG4gICAgICAgIGJhY2tncm91bmRDbGlwOiAncGFkZGluZy1ib3gnLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIGJvcmRlclJhZGl1czogdG9rZW4uYm9yZGVyUmFkaXVzTEcsXG4gICAgICAgIGJveFNoYWRvdzogdG9rZW4uYm94U2hhZG93LFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnYXV0bycsXG4gICAgICAgIHBhZGRpbmc6IHRva2VuLmNvbnRlbnRQYWRkaW5nXG4gICAgICB9LFxuICAgICAgW2Ake2NvbXBvbmVudENsc30tY2xvc2VgXTogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IHRva2VuLmNhbGModG9rZW4ubW9kYWxIZWFkZXJIZWlnaHQpLnN1Yih0b2tlbi5tb2RhbENsb3NlQnRuU2l6ZSkuZGl2KDIpLmVxdWFsKCksXG4gICAgICAgIGluc2V0SW5saW5lRW5kOiB0b2tlbi5jYWxjKHRva2VuLm1vZGFsSGVhZGVySGVpZ2h0KS5zdWIodG9rZW4ubW9kYWxDbG9zZUJ0blNpemUpLmRpdigyKS5lcXVhbCgpLFxuICAgICAgICB6SW5kZXg6IHRva2VuLmNhbGModG9rZW4uekluZGV4UG9wdXBCYXNlKS5hZGQoMTApLmVxdWFsKCksXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIGNvbG9yOiB0b2tlbi5tb2RhbENsb3NlSWNvbkNvbG9yLFxuICAgICAgICBmb250V2VpZ2h0OiB0b2tlbi5mb250V2VpZ2h0U3Ryb25nLFxuICAgICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnLFxuICAgICAgICBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBib3JkZXJSYWRpdXM6IHRva2VuLmJvcmRlclJhZGl1c1NNLFxuICAgICAgICB3aWR0aDogdG9rZW4ubW9kYWxDbG9zZUJ0blNpemUsXG4gICAgICAgIGhlaWdodDogdG9rZW4ubW9kYWxDbG9zZUJ0blNpemUsXG4gICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgb3V0bGluZTogMCxcbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgIHRyYW5zaXRpb246IGBjb2xvciAke3Rva2VuLm1vdGlvbkR1cmF0aW9uTWlkfSwgYmFja2dyb3VuZC1jb2xvciAke3Rva2VuLm1vdGlvbkR1cmF0aW9uTWlkfWAsXG4gICAgICAgICcmLXgnOiB7XG4gICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgIGZvbnRTaXplOiB0b2tlbi5mb250U2l6ZUxHLFxuICAgICAgICAgIGZvbnRTdHlsZTogJ25vcm1hbCcsXG4gICAgICAgICAgbGluZUhlaWdodDogdW5pdCh0b2tlbi5tb2RhbENsb3NlQnRuU2l6ZSksXG4gICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICAgIHRleHRUcmFuc2Zvcm06ICdub25lJyxcbiAgICAgICAgICB0ZXh0UmVuZGVyaW5nOiAnYXV0bydcbiAgICAgICAgfSxcbiAgICAgICAgJyY6ZGlzYWJsZWQnOiB7XG4gICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICAgIH0sXG4gICAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICAgIGNvbG9yOiB0b2tlbi5tb2RhbENsb3NlSWNvbkhvdmVyQ29sb3IsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0b2tlbi5jb2xvckJnVGV4dEhvdmVyLFxuICAgICAgICAgIHRleHREZWNvcmF0aW9uOiAnbm9uZSdcbiAgICAgICAgfSxcbiAgICAgICAgJyY6YWN0aXZlJzoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdG9rZW4uY29sb3JCZ1RleHRBY3RpdmVcbiAgICAgICAgfVxuICAgICAgfSwgZ2VuRm9jdXNTdHlsZSh0b2tlbikpLFxuICAgICAgW2Ake2NvbXBvbmVudENsc30taGVhZGVyYF06IHtcbiAgICAgICAgY29sb3I6IHRva2VuLmNvbG9yVGV4dCxcbiAgICAgICAgYmFja2dyb3VuZDogdG9rZW4uaGVhZGVyQmcsXG4gICAgICAgIGJvcmRlclJhZGl1czogYCR7dW5pdCh0b2tlbi5ib3JkZXJSYWRpdXNMRyl9ICR7dW5pdCh0b2tlbi5ib3JkZXJSYWRpdXNMRyl9IDAgMGAsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogdG9rZW4uaGVhZGVyTWFyZ2luQm90dG9tLFxuICAgICAgICBwYWRkaW5nOiB0b2tlbi5oZWFkZXJQYWRkaW5nLFxuICAgICAgICBib3JkZXJCb3R0b206IHRva2VuLmhlYWRlckJvcmRlckJvdHRvbVxuICAgICAgfSxcbiAgICAgIFtgJHtjb21wb25lbnRDbHN9LWJvZHlgXToge1xuICAgICAgICBmb250U2l6ZTogdG9rZW4uZm9udFNpemUsXG4gICAgICAgIGxpbmVIZWlnaHQ6IHRva2VuLmxpbmVIZWlnaHQsXG4gICAgICAgIHdvcmRXcmFwOiAnYnJlYWstd29yZCcsXG4gICAgICAgIHBhZGRpbmc6IHRva2VuLmJvZHlQYWRkaW5nLFxuICAgICAgICBbYCR7Y29tcG9uZW50Q2xzfS1ib2R5LXNrZWxldG9uYF06IHtcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgbWFyZ2luOiBgJHt1bml0KHRva2VuLm1hcmdpbil9IGF1dG9gXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbYCR7Y29tcG9uZW50Q2xzfS1mb290ZXJgXToge1xuICAgICAgICB0ZXh0QWxpZ246ICdlbmQnLFxuICAgICAgICBiYWNrZ3JvdW5kOiB0b2tlbi5mb290ZXJCZyxcbiAgICAgICAgbWFyZ2luVG9wOiB0b2tlbi5mb290ZXJNYXJnaW5Ub3AsXG4gICAgICAgIHBhZGRpbmc6IHRva2VuLmZvb3RlclBhZGRpbmcsXG4gICAgICAgIGJvcmRlclRvcDogdG9rZW4uZm9vdGVyQm9yZGVyVG9wLFxuICAgICAgICBib3JkZXJSYWRpdXM6IHRva2VuLmZvb3RlckJvcmRlclJhZGl1cyxcbiAgICAgICAgW2A+ICR7dG9rZW4uYW50Q2xzfS1idG4gKyAke3Rva2VuLmFudENsc30tYnRuYF06IHtcbiAgICAgICAgICBtYXJnaW5JbmxpbmVTdGFydDogdG9rZW4ubWFyZ2luWFNcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtgJHtjb21wb25lbnRDbHN9LW9wZW5gXToge1xuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT0gUHVyZSA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHtcbiAgICBbYCR7Y29tcG9uZW50Q2xzfS1wdXJlLXBhbmVsYF06IHtcbiAgICAgIHRvcDogJ2F1dG8nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgW2Ake2NvbXBvbmVudENsc30tY29udGVudCxcbiAgICAgICAgICAke2NvbXBvbmVudENsc30tYm9keSxcbiAgICAgICAgICAke2NvbXBvbmVudENsc30tY29uZmlybS1ib2R5LXdyYXBwZXJgXToge1xuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICBmbGV4OiAnYXV0bydcbiAgICAgIH0sXG4gICAgICBbYCR7Y29tcG9uZW50Q2xzfS1jb25maXJtLWJvZHlgXToge1xuICAgICAgICBtYXJnaW5Cb3R0b206ICdhdXRvJ1xuICAgICAgfVxuICAgIH1cbiAgfV07XG59O1xuY29uc3QgZ2VuUlRMU3R5bGUgPSB0b2tlbiA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb21wb25lbnRDbHNcbiAgfSA9IHRva2VuO1xuICByZXR1cm4ge1xuICAgIFtgJHtjb21wb25lbnRDbHN9LXJvb3RgXToge1xuICAgICAgW2Ake2NvbXBvbmVudENsc30td3JhcC1ydGxgXToge1xuICAgICAgICBkaXJlY3Rpb246ICdydGwnLFxuICAgICAgICBbYCR7Y29tcG9uZW50Q2xzfS1jb25maXJtLWJvZHlgXToge1xuICAgICAgICAgIGRpcmVjdGlvbjogJ3J0bCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5jb25zdCBnZW5SZXNwb25zaXZlV2lkdGhTdHlsZSA9IHRva2VuID0+IHtcbiAgY29uc3Qge1xuICAgIGNvbXBvbmVudENsc1xuICB9ID0gdG9rZW47XG4gIGNvbnN0IGdyaWRNZWRpYVNpemVzTWFwID0gZ2V0TWVkaWFTaXplKHRva2VuKTtcbiAgZGVsZXRlIGdyaWRNZWRpYVNpemVzTWFwLnhzO1xuICBjb25zdCByZXNwb25zaXZlU3R5bGVzID0gT2JqZWN0LmtleXMoZ3JpZE1lZGlhU2l6ZXNNYXApLm1hcChrZXkgPT4gKHtcbiAgICBbYEBtZWRpYSAobWluLXdpZHRoOiAke3VuaXQoZ3JpZE1lZGlhU2l6ZXNNYXBba2V5XSl9KWBdOiB7XG4gICAgICB3aWR0aDogYHZhcigtLSR7Y29tcG9uZW50Q2xzLnJlcGxhY2UoJy4nLCAnJyl9LSR7a2V5fS13aWR0aClgXG4gICAgfVxuICB9KSk7XG4gIHJldHVybiB7XG4gICAgW2Ake2NvbXBvbmVudENsc30tcm9vdGBdOiB7XG4gICAgICBbY29tcG9uZW50Q2xzXTogW3tcbiAgICAgICAgd2lkdGg6IGB2YXIoLS0ke2NvbXBvbmVudENscy5yZXBsYWNlKCcuJywgJycpfS14cy13aWR0aClgXG4gICAgICB9XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlc3BvbnNpdmVTdHlsZXMpKVxuICAgIH1cbiAgfTtcbn07XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gRXhwb3J0ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuZXhwb3J0IGNvbnN0IHByZXBhcmVUb2tlbiA9IHRva2VuID0+IHtcbiAgY29uc3QgaGVhZGVyUGFkZGluZ1ZlcnRpY2FsID0gdG9rZW4ucGFkZGluZztcbiAgY29uc3QgaGVhZGVyRm9udFNpemUgPSB0b2tlbi5mb250U2l6ZUhlYWRpbmc1O1xuICBjb25zdCBoZWFkZXJMaW5lSGVpZ2h0ID0gdG9rZW4ubGluZUhlaWdodEhlYWRpbmc1O1xuICBjb25zdCBtb2RhbFRva2VuID0gbWVyZ2VUb2tlbih0b2tlbiwge1xuICAgIG1vZGFsSGVhZGVySGVpZ2h0OiB0b2tlbi5jYWxjKHRva2VuLmNhbGMoaGVhZGVyTGluZUhlaWdodCkubXVsKGhlYWRlckZvbnRTaXplKS5lcXVhbCgpKS5hZGQodG9rZW4uY2FsYyhoZWFkZXJQYWRkaW5nVmVydGljYWwpLm11bCgyKS5lcXVhbCgpKS5lcXVhbCgpLFxuICAgIG1vZGFsRm9vdGVyQm9yZGVyQ29sb3JTcGxpdDogdG9rZW4uY29sb3JTcGxpdCxcbiAgICBtb2RhbEZvb3RlckJvcmRlclN0eWxlOiB0b2tlbi5saW5lVHlwZSxcbiAgICBtb2RhbEZvb3RlckJvcmRlcldpZHRoOiB0b2tlbi5saW5lV2lkdGgsXG4gICAgbW9kYWxDbG9zZUljb25Db2xvcjogdG9rZW4uY29sb3JJY29uLFxuICAgIG1vZGFsQ2xvc2VJY29uSG92ZXJDb2xvcjogdG9rZW4uY29sb3JJY29uSG92ZXIsXG4gICAgbW9kYWxDbG9zZUJ0blNpemU6IHRva2VuLmNvbnRyb2xIZWlnaHQsXG4gICAgbW9kYWxDb25maXJtSWNvblNpemU6IHRva2VuLmZvbnRIZWlnaHQsXG4gICAgbW9kYWxUaXRsZUhlaWdodDogdG9rZW4uY2FsYyh0b2tlbi50aXRsZUZvbnRTaXplKS5tdWwodG9rZW4udGl0bGVMaW5lSGVpZ2h0KS5lcXVhbCgpXG4gIH0pO1xuICByZXR1cm4gbW9kYWxUb2tlbjtcbn07XG5leHBvcnQgY29uc3QgcHJlcGFyZUNvbXBvbmVudFRva2VuID0gdG9rZW4gPT4gKHtcbiAgZm9vdGVyQmc6ICd0cmFuc3BhcmVudCcsXG4gIGhlYWRlckJnOiB0b2tlbi5jb2xvckJnRWxldmF0ZWQsXG4gIHRpdGxlTGluZUhlaWdodDogdG9rZW4ubGluZUhlaWdodEhlYWRpbmc1LFxuICB0aXRsZUZvbnRTaXplOiB0b2tlbi5mb250U2l6ZUhlYWRpbmc1LFxuICBjb250ZW50Qmc6IHRva2VuLmNvbG9yQmdFbGV2YXRlZCxcbiAgdGl0bGVDb2xvcjogdG9rZW4uY29sb3JUZXh0SGVhZGluZyxcbiAgLy8gaW50ZXJuYWxcbiAgY29udGVudFBhZGRpbmc6IHRva2VuLndpcmVmcmFtZSA/IDAgOiBgJHt1bml0KHRva2VuLnBhZGRpbmdNRCl9ICR7dW5pdCh0b2tlbi5wYWRkaW5nQ29udGVudEhvcml6b250YWxMRyl9YCxcbiAgaGVhZGVyUGFkZGluZzogdG9rZW4ud2lyZWZyYW1lID8gYCR7dW5pdCh0b2tlbi5wYWRkaW5nKX0gJHt1bml0KHRva2VuLnBhZGRpbmdMRyl9YCA6IDAsXG4gIGhlYWRlckJvcmRlckJvdHRvbTogdG9rZW4ud2lyZWZyYW1lID8gYCR7dW5pdCh0b2tlbi5saW5lV2lkdGgpfSAke3Rva2VuLmxpbmVUeXBlfSAke3Rva2VuLmNvbG9yU3BsaXR9YCA6ICdub25lJyxcbiAgaGVhZGVyTWFyZ2luQm90dG9tOiB0b2tlbi53aXJlZnJhbWUgPyAwIDogdG9rZW4ubWFyZ2luWFMsXG4gIGJvZHlQYWRkaW5nOiB0b2tlbi53aXJlZnJhbWUgPyB0b2tlbi5wYWRkaW5nTEcgOiAwLFxuICBmb290ZXJQYWRkaW5nOiB0b2tlbi53aXJlZnJhbWUgPyBgJHt1bml0KHRva2VuLnBhZGRpbmdYUyl9ICR7dW5pdCh0b2tlbi5wYWRkaW5nKX1gIDogMCxcbiAgZm9vdGVyQm9yZGVyVG9wOiB0b2tlbi53aXJlZnJhbWUgPyBgJHt1bml0KHRva2VuLmxpbmVXaWR0aCl9ICR7dG9rZW4ubGluZVR5cGV9ICR7dG9rZW4uY29sb3JTcGxpdH1gIDogJ25vbmUnLFxuICBmb290ZXJCb3JkZXJSYWRpdXM6IHRva2VuLndpcmVmcmFtZSA/IGAwIDAgJHt1bml0KHRva2VuLmJvcmRlclJhZGl1c0xHKX0gJHt1bml0KHRva2VuLmJvcmRlclJhZGl1c0xHKX1gIDogMCxcbiAgZm9vdGVyTWFyZ2luVG9wOiB0b2tlbi53aXJlZnJhbWUgPyAwIDogdG9rZW4ubWFyZ2luU00sXG4gIGNvbmZpcm1Cb2R5UGFkZGluZzogdG9rZW4ud2lyZWZyYW1lID8gYCR7dW5pdCh0b2tlbi5wYWRkaW5nICogMil9ICR7dW5pdCh0b2tlbi5wYWRkaW5nICogMil9ICR7dW5pdCh0b2tlbi5wYWRkaW5nTEcpfWAgOiAwLFxuICBjb25maXJtSWNvbk1hcmdpbklubGluZUVuZDogdG9rZW4ud2lyZWZyYW1lID8gdG9rZW4ubWFyZ2luIDogdG9rZW4ubWFyZ2luU00sXG4gIGNvbmZpcm1CdG5zTWFyZ2luVG9wOiB0b2tlbi53aXJlZnJhbWUgPyB0b2tlbi5tYXJnaW5MRyA6IHRva2VuLm1hcmdpblNNXG59KTtcbmV4cG9ydCBkZWZhdWx0IGdlblN0eWxlSG9va3MoJ01vZGFsJywgdG9rZW4gPT4ge1xuICBjb25zdCBtb2RhbFRva2VuID0gcHJlcGFyZVRva2VuKHRva2VuKTtcbiAgcmV0dXJuIFtnZW5Nb2RhbFN0eWxlKG1vZGFsVG9rZW4pLCBnZW5SVExTdHlsZShtb2RhbFRva2VuKSwgZ2VuTW9kYWxNYXNrU3R5bGUobW9kYWxUb2tlbiksIGluaXRab29tTW90aW9uKG1vZGFsVG9rZW4sICd6b29tJyksIGdlblJlc3BvbnNpdmVXaWR0aFN0eWxlKG1vZGFsVG9rZW4pXTtcbn0sIHByZXBhcmVDb21wb25lbnRUb2tlbiwge1xuICB1bml0bGVzczoge1xuICAgIHRpdGxlTGluZUhlaWdodDogdHJ1ZVxuICB9XG59KTsiLCJcInVzZSBjbGllbnRcIjtcblxudmFyIF9fcmVzdCA9IHRoaXMgJiYgdGhpcy5fX3Jlc3QgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpIHRbcFtpXV0gPSBzW3BbaV1dO1xuICB9XG4gIHJldHVybiB0O1xufTtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBDbG9zZU91dGxpbmVkIGZyb20gXCJAYW50LWRlc2lnbi9pY29ucy9lcy9pY29ucy9DbG9zZU91dGxpbmVkXCI7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBEaWFsb2cgZnJvbSAncmMtZGlhbG9nJztcbmltcG9ydCBDb250ZXh0SXNvbGF0b3IgZnJvbSAnLi4vX3V0aWwvQ29udGV4dElzb2xhdG9yJztcbmltcG9ydCB1c2VDbG9zYWJsZSwgeyBwaWNrQ2xvc2FibGUgfSBmcm9tICcuLi9fdXRpbC9ob29rcy91c2VDbG9zYWJsZSc7XG5pbXBvcnQgeyB1c2VaSW5kZXggfSBmcm9tICcuLi9fdXRpbC9ob29rcy91c2VaSW5kZXgnO1xuaW1wb3J0IHsgZ2V0VHJhbnNpdGlvbk5hbWUgfSBmcm9tICcuLi9fdXRpbC9tb3Rpb24nO1xuaW1wb3J0IHsgY2FuVXNlRG9jRWxlbWVudCB9IGZyb20gJy4uL191dGlsL3N0eWxlQ2hlY2tlcic7XG5pbXBvcnQgeyBkZXZVc2VXYXJuaW5nIH0gZnJvbSAnLi4vX3V0aWwvd2FybmluZyc7XG5pbXBvcnQgekluZGV4Q29udGV4dCBmcm9tICcuLi9fdXRpbC96aW5kZXhDb250ZXh0JztcbmltcG9ydCB7IENvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IHVzZUNTU1ZhckNscyBmcm9tICcuLi9jb25maWctcHJvdmlkZXIvaG9va3MvdXNlQ1NTVmFyQ2xzJztcbmltcG9ydCBTa2VsZXRvbiBmcm9tICcuLi9za2VsZXRvbic7XG5pbXBvcnQgeyB1c2VQYW5lbFJlZiB9IGZyb20gJy4uL3dhdGVybWFyay9jb250ZXh0JztcbmltcG9ydCB7IEZvb3RlciwgcmVuZGVyQ2xvc2VJY29uIH0gZnJvbSAnLi9zaGFyZWQnO1xuaW1wb3J0IHVzZVN0eWxlIGZyb20gJy4vc3R5bGUnO1xubGV0IG1vdXNlUG9zaXRpb247XG4vLyByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbnQtZGVzaWduL2FudC1kZXNpZ24vaXNzdWVzLzE1Nzk1XG5jb25zdCBnZXRDbGlja1Bvc2l0aW9uID0gZSA9PiB7XG4gIG1vdXNlUG9zaXRpb24gPSB7XG4gICAgeDogZS5wYWdlWCxcbiAgICB5OiBlLnBhZ2VZXG4gIH07XG4gIC8vIDEwMG1zIOWGheWPkeeUn+i/h+eCueWHu+S6i+S7tu+8jOWImeS7jueCueWHu+S9jee9ruWKqOeUu+WxleekulxuICAvLyDlkKbliJnnm7TmjqUgem9vbSDlsZXnpLpcbiAgLy8g6L+Z5qC35Y+v5Lul5YW85a656Z2e54K55Ye75pa55byP5bGV5byAXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIG1vdXNlUG9zaXRpb24gPSBudWxsO1xuICB9LCAxMDApO1xufTtcbi8vIOWPquacieeCueWHu+S6i+S7tuaUr+aMgeS7jum8oOagh+S9jee9ruWKqOeUu+WxleW8gFxuaWYgKGNhblVzZURvY0VsZW1lbnQoKSkge1xuICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBnZXRDbGlja1Bvc2l0aW9uLCB0cnVlKTtcbn1cbmNvbnN0IE1vZGFsID0gcHJvcHMgPT4ge1xuICBjb25zdCB7XG4gICAgICBwcmVmaXhDbHM6IGN1c3RvbWl6ZVByZWZpeENscyxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIHJvb3RDbGFzc05hbWUsXG4gICAgICBvcGVuLFxuICAgICAgd3JhcENsYXNzTmFtZSxcbiAgICAgIGNlbnRlcmVkLFxuICAgICAgZ2V0Q29udGFpbmVyLFxuICAgICAgZm9jdXNUcmlnZ2VyQWZ0ZXJDbG9zZSA9IHRydWUsXG4gICAgICBzdHlsZSxcbiAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgIHZpc2libGUsXG4gICAgICB3aWR0aCA9IDUyMCxcbiAgICAgIGZvb3RlcixcbiAgICAgIGNsYXNzTmFtZXM6IG1vZGFsQ2xhc3NOYW1lcyxcbiAgICAgIHN0eWxlczogbW9kYWxTdHlsZXMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGxvYWRpbmcsXG4gICAgICBjb25maXJtTG9hZGluZyxcbiAgICAgIHpJbmRleDogY3VzdG9taXplWkluZGV4LFxuICAgICAgbW91c2VQb3NpdGlvbjogY3VzdG9taXplTW91c2VQb3NpdGlvbixcbiAgICAgIG9uT2ssXG4gICAgICBvbkNhbmNlbFxuICAgIH0gPSBwcm9wcyxcbiAgICByZXN0UHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcInByZWZpeENsc1wiLCBcImNsYXNzTmFtZVwiLCBcInJvb3RDbGFzc05hbWVcIiwgXCJvcGVuXCIsIFwid3JhcENsYXNzTmFtZVwiLCBcImNlbnRlcmVkXCIsIFwiZ2V0Q29udGFpbmVyXCIsIFwiZm9jdXNUcmlnZ2VyQWZ0ZXJDbG9zZVwiLCBcInN0eWxlXCIsIFwidmlzaWJsZVwiLCBcIndpZHRoXCIsIFwiZm9vdGVyXCIsIFwiY2xhc3NOYW1lc1wiLCBcInN0eWxlc1wiLCBcImNoaWxkcmVuXCIsIFwibG9hZGluZ1wiLCBcImNvbmZpcm1Mb2FkaW5nXCIsIFwiekluZGV4XCIsIFwibW91c2VQb3NpdGlvblwiLCBcIm9uT2tcIiwgXCJvbkNhbmNlbFwiXSk7XG4gIGNvbnN0IHtcbiAgICBnZXRQb3B1cENvbnRhaW5lcjogZ2V0Q29udGV4dFBvcHVwQ29udGFpbmVyLFxuICAgIGdldFByZWZpeENscyxcbiAgICBkaXJlY3Rpb24sXG4gICAgbW9kYWw6IG1vZGFsQ29udGV4dFxuICB9ID0gUmVhY3QudXNlQ29udGV4dChDb25maWdDb250ZXh0KTtcbiAgY29uc3QgaGFuZGxlQ2FuY2VsID0gZSA9PiB7XG4gICAgaWYgKGNvbmZpcm1Mb2FkaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uQ2FuY2VsID09PSBudWxsIHx8IG9uQ2FuY2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNhbmNlbChlKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlT2sgPSBlID0+IHtcbiAgICBvbk9rID09PSBudWxsIHx8IG9uT2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uT2soZSk7XG4gIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3Qgd2FybmluZyA9IGRldlVzZVdhcm5pbmcoJ01vZGFsJyk7XG4gICAgW1sndmlzaWJsZScsICdvcGVuJ10sIFsnYm9keVN0eWxlJywgJ3N0eWxlcy5ib2R5J10sIFsnbWFza1N0eWxlJywgJ3N0eWxlcy5tYXNrJ11dLmZvckVhY2goX3JlZiA9PiB7XG4gICAgICBsZXQgW2RlcHJlY2F0ZWROYW1lLCBuZXdOYW1lXSA9IF9yZWY7XG4gICAgICB3YXJuaW5nLmRlcHJlY2F0ZWQoIShkZXByZWNhdGVkTmFtZSBpbiBwcm9wcyksIGRlcHJlY2F0ZWROYW1lLCBuZXdOYW1lKTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBwcmVmaXhDbHMgPSBnZXRQcmVmaXhDbHMoJ21vZGFsJywgY3VzdG9taXplUHJlZml4Q2xzKTtcbiAgY29uc3Qgcm9vdFByZWZpeENscyA9IGdldFByZWZpeENscygpO1xuICAvLyBTdHlsZVxuICBjb25zdCByb290Q2xzID0gdXNlQ1NTVmFyQ2xzKHByZWZpeENscyk7XG4gIGNvbnN0IFt3cmFwQ1NTVmFyLCBoYXNoSWQsIGNzc1ZhckNsc10gPSB1c2VTdHlsZShwcmVmaXhDbHMsIHJvb3RDbHMpO1xuICBjb25zdCB3cmFwQ2xhc3NOYW1lRXh0ZW5kZWQgPSBjbGFzc05hbWVzKHdyYXBDbGFzc05hbWUsIHtcbiAgICBbYCR7cHJlZml4Q2xzfS1jZW50ZXJlZGBdOiBjZW50ZXJlZCAhPT0gbnVsbCAmJiBjZW50ZXJlZCAhPT0gdm9pZCAwID8gY2VudGVyZWQgOiBtb2RhbENvbnRleHQgPT09IG51bGwgfHwgbW9kYWxDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2RhbENvbnRleHQuY2VudGVyZWQsXG4gICAgW2Ake3ByZWZpeENsc30td3JhcC1ydGxgXTogZGlyZWN0aW9uID09PSAncnRsJ1xuICB9KTtcbiAgY29uc3QgZGlhbG9nRm9vdGVyID0gZm9vdGVyICE9PSBudWxsICYmICFsb2FkaW5nID8gKC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvb3RlciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICBvbk9rOiBoYW5kbGVPayxcbiAgICBvbkNhbmNlbDogaGFuZGxlQ2FuY2VsXG4gIH0pKSkgOiBudWxsO1xuICBjb25zdCBbbWVyZ2VkQ2xvc2FibGUsIG1lcmdlZENsb3NlSWNvbiwgY2xvc2VCdG5Jc0Rpc2FibGVkXSA9IHVzZUNsb3NhYmxlKHBpY2tDbG9zYWJsZShwcm9wcyksIHBpY2tDbG9zYWJsZShtb2RhbENvbnRleHQpLCB7XG4gICAgY2xvc2FibGU6IHRydWUsXG4gICAgY2xvc2VJY29uOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDbG9zZU91dGxpbmVkLCB7XG4gICAgICBjbGFzc05hbWU6IGAke3ByZWZpeENsc30tY2xvc2UtaWNvbmBcbiAgICB9KSxcbiAgICBjbG9zZUljb25SZW5kZXI6IGljb24gPT4gcmVuZGVyQ2xvc2VJY29uKHByZWZpeENscywgaWNvbilcbiAgfSk7XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT0gUmVmcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNlbGVjdCBgYW50LW1vZGFsLWNvbnRlbnRgIGJ5IGBwYW5lbFJlZmBcbiAgY29uc3QgcGFuZWxSZWYgPSB1c2VQYW5lbFJlZihgLiR7cHJlZml4Q2xzfS1jb250ZW50YCk7XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT0gekluZGV4ID09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgW3pJbmRleCwgY29udGV4dFpJbmRleF0gPSB1c2VaSW5kZXgoJ01vZGFsJywgY3VzdG9taXplWkluZGV4KTtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09IFdpZHRoID09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgW251bVdpZHRoLCByZXNwb25zaXZlV2lkdGhdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHdpZHRoICYmIHR5cGVvZiB3aWR0aCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB3aWR0aF07XG4gICAgfVxuICAgIHJldHVybiBbd2lkdGgsIHVuZGVmaW5lZF07XG4gIH0sIFt3aWR0aF0pO1xuICBjb25zdCByZXNwb25zaXZlV2lkdGhWYXJzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgdmFycyA9IHt9O1xuICAgIGlmIChyZXNwb25zaXZlV2lkdGgpIHtcbiAgICAgIE9iamVjdC5rZXlzKHJlc3BvbnNpdmVXaWR0aCkuZm9yRWFjaChicmVha3BvaW50ID0+IHtcbiAgICAgICAgY29uc3QgYnJlYWtwb2ludFdpZHRoID0gcmVzcG9uc2l2ZVdpZHRoW2JyZWFrcG9pbnRdO1xuICAgICAgICBpZiAoYnJlYWtwb2ludFdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXJzW2AtLSR7cHJlZml4Q2xzfS0ke2JyZWFrcG9pbnR9LXdpZHRoYF0gPSB0eXBlb2YgYnJlYWtwb2ludFdpZHRoID09PSAnbnVtYmVyJyA/IGAke2JyZWFrcG9pbnRXaWR0aH1weGAgOiBicmVha3BvaW50V2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFycztcbiAgfSwgW3Jlc3BvbnNpdmVXaWR0aF0pO1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT0gUmVuZGVyID09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICByZXR1cm4gd3JhcENTU1ZhcigvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0SXNvbGF0b3IsIHtcbiAgICBmb3JtOiB0cnVlLFxuICAgIHNwYWNlOiB0cnVlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KHpJbmRleENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFpJbmRleFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEaWFsb2csIE9iamVjdC5hc3NpZ24oe1xuICAgIHdpZHRoOiBudW1XaWR0aFxuICB9LCByZXN0UHJvcHMsIHtcbiAgICB6SW5kZXg6IHpJbmRleCxcbiAgICBnZXRDb250YWluZXI6IGdldENvbnRhaW5lciA9PT0gdW5kZWZpbmVkID8gZ2V0Q29udGV4dFBvcHVwQ29udGFpbmVyIDogZ2V0Q29udGFpbmVyLFxuICAgIHByZWZpeENsczogcHJlZml4Q2xzLFxuICAgIHJvb3RDbGFzc05hbWU6IGNsYXNzTmFtZXMoaGFzaElkLCByb290Q2xhc3NOYW1lLCBjc3NWYXJDbHMsIHJvb3RDbHMpLFxuICAgIGZvb3RlcjogZGlhbG9nRm9vdGVyLFxuICAgIHZpc2libGU6IG9wZW4gIT09IG51bGwgJiYgb3BlbiAhPT0gdm9pZCAwID8gb3BlbiA6IHZpc2libGUsXG4gICAgbW91c2VQb3NpdGlvbjogY3VzdG9taXplTW91c2VQb3NpdGlvbiAhPT0gbnVsbCAmJiBjdXN0b21pemVNb3VzZVBvc2l0aW9uICE9PSB2b2lkIDAgPyBjdXN0b21pemVNb3VzZVBvc2l0aW9uIDogbW91c2VQb3NpdGlvbixcbiAgICBvbkNsb3NlOiBoYW5kbGVDYW5jZWwsXG4gICAgY2xvc2FibGU6IG1lcmdlZENsb3NhYmxlID8ge1xuICAgICAgZGlzYWJsZWQ6IGNsb3NlQnRuSXNEaXNhYmxlZCxcbiAgICAgIGNsb3NlSWNvbjogbWVyZ2VkQ2xvc2VJY29uXG4gICAgfSA6IG1lcmdlZENsb3NhYmxlLFxuICAgIGNsb3NlSWNvbjogbWVyZ2VkQ2xvc2VJY29uLFxuICAgIGZvY3VzVHJpZ2dlckFmdGVyQ2xvc2U6IGZvY3VzVHJpZ2dlckFmdGVyQ2xvc2UsXG4gICAgdHJhbnNpdGlvbk5hbWU6IGdldFRyYW5zaXRpb25OYW1lKHJvb3RQcmVmaXhDbHMsICd6b29tJywgcHJvcHMudHJhbnNpdGlvbk5hbWUpLFxuICAgIG1hc2tUcmFuc2l0aW9uTmFtZTogZ2V0VHJhbnNpdGlvbk5hbWUocm9vdFByZWZpeENscywgJ2ZhZGUnLCBwcm9wcy5tYXNrVHJhbnNpdGlvbk5hbWUpLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhoYXNoSWQsIGNsYXNzTmFtZSwgbW9kYWxDb250ZXh0ID09PSBudWxsIHx8IG1vZGFsQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kYWxDb250ZXh0LmNsYXNzTmFtZSksXG4gICAgc3R5bGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtb2RhbENvbnRleHQgPT09IG51bGwgfHwgbW9kYWxDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2RhbENvbnRleHQuc3R5bGUpLCBzdHlsZSksIHJlc3BvbnNpdmVXaWR0aFZhcnMpLFxuICAgIGNsYXNzTmFtZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtb2RhbENvbnRleHQgPT09IG51bGwgfHwgbW9kYWxDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2RhbENvbnRleHQuY2xhc3NOYW1lcyksIG1vZGFsQ2xhc3NOYW1lcyksIHtcbiAgICAgIHdyYXBwZXI6IGNsYXNzTmFtZXMod3JhcENsYXNzTmFtZUV4dGVuZGVkLCBtb2RhbENsYXNzTmFtZXMgPT09IG51bGwgfHwgbW9kYWxDbGFzc05hbWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2RhbENsYXNzTmFtZXMud3JhcHBlcilcbiAgICB9KSxcbiAgICBzdHlsZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbW9kYWxDb250ZXh0ID09PSBudWxsIHx8IG1vZGFsQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kYWxDb250ZXh0LnN0eWxlcyksIG1vZGFsU3R5bGVzKSxcbiAgICBwYW5lbFJlZjogcGFuZWxSZWZcbiAgfSksIGxvYWRpbmcgPyAoLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU2tlbGV0b24sIHtcbiAgICBhY3RpdmU6IHRydWUsXG4gICAgdGl0bGU6IGZhbHNlLFxuICAgIHBhcmFncmFwaDoge1xuICAgICAgcm93czogNFxuICAgIH0sXG4gICAgY2xhc3NOYW1lOiBgJHtwcmVmaXhDbHN9LWJvZHktc2tlbGV0b25gXG4gIH0pKSA6IGNoaWxkcmVuKSkpKTtcbn07XG5leHBvcnQgZGVmYXVsdCBNb2RhbDsiLCIvLyBTdHlsZSBhcyBjb25maXJtIGNvbXBvbmVudFxuaW1wb3J0IHsgdW5pdCB9IGZyb20gJ0BhbnQtZGVzaWduL2Nzc2luanMnO1xuaW1wb3J0IHsgcHJlcGFyZUNvbXBvbmVudFRva2VuLCBwcmVwYXJlVG9rZW4gfSBmcm9tICcuJztcbmltcG9ydCB7IGNsZWFyRml4IH0gZnJvbSAnLi4vLi4vc3R5bGUnO1xuaW1wb3J0IHsgZ2VuU3ViU3R5bGVDb21wb25lbnQgfSBmcm9tICcuLi8uLi90aGVtZS9pbnRlcm5hbCc7XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBDb25maXJtID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgZ2VuTW9kYWxDb25maXJtU3R5bGUgPSB0b2tlbiA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb21wb25lbnRDbHMsXG4gICAgdGl0bGVGb250U2l6ZSxcbiAgICB0aXRsZUxpbmVIZWlnaHQsXG4gICAgbW9kYWxDb25maXJtSWNvblNpemUsXG4gICAgZm9udFNpemUsXG4gICAgbGluZUhlaWdodCxcbiAgICBtb2RhbFRpdGxlSGVpZ2h0LFxuICAgIGZvbnRIZWlnaHQsXG4gICAgY29uZmlybUJvZHlQYWRkaW5nXG4gIH0gPSB0b2tlbjtcbiAgY29uc3QgY29uZmlybUNvbXBvbmVudENscyA9IGAke2NvbXBvbmVudENsc30tY29uZmlybWA7XG4gIHJldHVybiB7XG4gICAgW2NvbmZpcm1Db21wb25lbnRDbHNdOiB7XG4gICAgICAnJi1ydGwnOiB7XG4gICAgICAgIGRpcmVjdGlvbjogJ3J0bCdcbiAgICAgIH0sXG4gICAgICBbYCR7dG9rZW4uYW50Q2xzfS1tb2RhbC1oZWFkZXJgXToge1xuICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICBbYCR7Y29uZmlybUNvbXBvbmVudENsc30tYm9keS13cmFwcGVyYF06IE9iamVjdC5hc3NpZ24oe30sIGNsZWFyRml4KCkpLFxuICAgICAgW2AmJHtjb21wb25lbnRDbHN9ICR7Y29tcG9uZW50Q2xzfS1ib2R5YF06IHtcbiAgICAgICAgcGFkZGluZzogY29uZmlybUJvZHlQYWRkaW5nXG4gICAgICB9LFxuICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PSBCb2R5ID09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgIFtgJHtjb25maXJtQ29tcG9uZW50Q2xzfS1ib2R5YF06IHtcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBmbGV4V3JhcDogJ25vd3JhcCcsXG4gICAgICAgIGFsaWduSXRlbXM6ICdzdGFydCcsXG4gICAgICAgIFtgPiAke3Rva2VuLmljb25DbHN9YF06IHtcbiAgICAgICAgICBmbGV4OiAnbm9uZScsXG4gICAgICAgICAgZm9udFNpemU6IG1vZGFsQ29uZmlybUljb25TaXplLFxuICAgICAgICAgIG1hcmdpbklubGluZUVuZDogdG9rZW4uY29uZmlybUljb25NYXJnaW5JbmxpbmVFbmQsXG4gICAgICAgICAgbWFyZ2luVG9wOiB0b2tlbi5jYWxjKHRva2VuLmNhbGMoZm9udEhlaWdodCkuc3ViKG1vZGFsQ29uZmlybUljb25TaXplKS5lcXVhbCgpKS5kaXYoMikuZXF1YWwoKVxuICAgICAgICB9LFxuICAgICAgICBbYCYtaGFzLXRpdGxlID4gJHt0b2tlbi5pY29uQ2xzfWBdOiB7XG4gICAgICAgICAgbWFyZ2luVG9wOiB0b2tlbi5jYWxjKHRva2VuLmNhbGMobW9kYWxUaXRsZUhlaWdodCkuc3ViKG1vZGFsQ29uZmlybUljb25TaXplKS5lcXVhbCgpKS5kaXYoMikuZXF1YWwoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2Ake2NvbmZpcm1Db21wb25lbnRDbHN9LXBhcmFncmFwaGBdOiB7XG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgIGZsZXg6ICdhdXRvJyxcbiAgICAgICAgcm93R2FwOiB0b2tlbi5tYXJnaW5YUyxcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FudC1kZXNpZ24vYW50LWRlc2lnbi9pc3N1ZXMvNTE5MTJcbiAgICAgICAgbWF4V2lkdGg6IGBjYWxjKDEwMCUgLSAke3VuaXQodG9rZW4ubWFyZ2luU00pfSlgXG4gICAgICB9LFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FudC1kZXNpZ24vYW50LWRlc2lnbi9pc3N1ZXMvNDgxNTlcbiAgICAgIFtgJHt0b2tlbi5pY29uQ2xzfSArICR7Y29uZmlybUNvbXBvbmVudENsc30tcGFyYWdyYXBoYF06IHtcbiAgICAgICAgbWF4V2lkdGg6IGBjYWxjKDEwMCUgLSAke3VuaXQodG9rZW4uY2FsYyh0b2tlbi5tb2RhbENvbmZpcm1JY29uU2l6ZSkuYWRkKHRva2VuLm1hcmdpblNNKS5lcXVhbCgpKX0pYFxuICAgICAgfSxcbiAgICAgIFtgJHtjb25maXJtQ29tcG9uZW50Q2xzfS10aXRsZWBdOiB7XG4gICAgICAgIGNvbG9yOiB0b2tlbi5jb2xvclRleHRIZWFkaW5nLFxuICAgICAgICBmb250V2VpZ2h0OiB0b2tlbi5mb250V2VpZ2h0U3Ryb25nLFxuICAgICAgICBmb250U2l6ZTogdGl0bGVGb250U2l6ZSxcbiAgICAgICAgbGluZUhlaWdodDogdGl0bGVMaW5lSGVpZ2h0XG4gICAgICB9LFxuICAgICAgW2Ake2NvbmZpcm1Db21wb25lbnRDbHN9LWNvbnRlbnRgXToge1xuICAgICAgICBjb2xvcjogdG9rZW4uY29sb3JUZXh0LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgbGluZUhlaWdodFxuICAgICAgfSxcbiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PSBGb290ZXIgPT09PT09PT09PT09PT09PT09PT09XG4gICAgICBbYCR7Y29uZmlybUNvbXBvbmVudENsc30tYnRuc2BdOiB7XG4gICAgICAgIHRleHRBbGlnbjogJ2VuZCcsXG4gICAgICAgIG1hcmdpblRvcDogdG9rZW4uY29uZmlybUJ0bnNNYXJnaW5Ub3AsXG4gICAgICAgIFtgJHt0b2tlbi5hbnRDbHN9LWJ0biArICR7dG9rZW4uYW50Q2xzfS1idG5gXToge1xuICAgICAgICAgIG1hcmdpbkJvdHRvbTogMCxcbiAgICAgICAgICBtYXJnaW5JbmxpbmVTdGFydDogdG9rZW4ubWFyZ2luWFNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW2Ake2NvbmZpcm1Db21wb25lbnRDbHN9LWVycm9yICR7Y29uZmlybUNvbXBvbmVudENsc30tYm9keSA+ICR7dG9rZW4uaWNvbkNsc31gXToge1xuICAgICAgY29sb3I6IHRva2VuLmNvbG9yRXJyb3JcbiAgICB9LFxuICAgIFtgJHtjb25maXJtQ29tcG9uZW50Q2xzfS13YXJuaW5nICR7Y29uZmlybUNvbXBvbmVudENsc30tYm9keSA+ICR7dG9rZW4uaWNvbkNsc30sXG4gICAgICAgICR7Y29uZmlybUNvbXBvbmVudENsc30tY29uZmlybSAke2NvbmZpcm1Db21wb25lbnRDbHN9LWJvZHkgPiAke3Rva2VuLmljb25DbHN9YF06IHtcbiAgICAgIGNvbG9yOiB0b2tlbi5jb2xvcldhcm5pbmdcbiAgICB9LFxuICAgIFtgJHtjb25maXJtQ29tcG9uZW50Q2xzfS1pbmZvICR7Y29uZmlybUNvbXBvbmVudENsc30tYm9keSA+ICR7dG9rZW4uaWNvbkNsc31gXToge1xuICAgICAgY29sb3I6IHRva2VuLmNvbG9ySW5mb1xuICAgIH0sXG4gICAgW2Ake2NvbmZpcm1Db21wb25lbnRDbHN9LXN1Y2Nlc3MgJHtjb25maXJtQ29tcG9uZW50Q2xzfS1ib2R5ID4gJHt0b2tlbi5pY29uQ2xzfWBdOiB7XG4gICAgICBjb2xvcjogdG9rZW4uY29sb3JTdWNjZXNzXG4gICAgfVxuICB9O1xufTtcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBFeHBvcnQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5leHBvcnQgZGVmYXVsdCBnZW5TdWJTdHlsZUNvbXBvbmVudChbJ01vZGFsJywgJ2NvbmZpcm0nXSwgdG9rZW4gPT4ge1xuICBjb25zdCBtb2RhbFRva2VuID0gcHJlcGFyZVRva2VuKHRva2VuKTtcbiAgcmV0dXJuIFtnZW5Nb2RhbENvbmZpcm1TdHlsZShtb2RhbFRva2VuKV07XG59LCBwcmVwYXJlQ29tcG9uZW50VG9rZW4sIHtcbiAgLy8gY29uZmlybSBpcyB3ZWFrIHRoYW4gbW9kYWwgc2luY2Ugbm8gY29uZmxpY3QgaGVyZVxuICBvcmRlcjogLTEwMDBcbn0pOyIsIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheVwiO1xudmFyIF9fcmVzdCA9IHRoaXMgJiYgdGhpcy5fX3Jlc3QgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpIHRbcFtpXV0gPSBzW3BbaV1dO1xuICB9XG4gIHJldHVybiB0O1xufTtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBDaGVja0NpcmNsZUZpbGxlZCBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvQ2hlY2tDaXJjbGVGaWxsZWRcIjtcbmltcG9ydCBDbG9zZUNpcmNsZUZpbGxlZCBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvQ2xvc2VDaXJjbGVGaWxsZWRcIjtcbmltcG9ydCBFeGNsYW1hdGlvbkNpcmNsZUZpbGxlZCBmcm9tIFwiQGFudC1kZXNpZ24vaWNvbnMvZXMvaWNvbnMvRXhjbGFtYXRpb25DaXJjbGVGaWxsZWRcIjtcbmltcG9ydCBJbmZvQ2lyY2xlRmlsbGVkIGZyb20gXCJAYW50LWRlc2lnbi9pY29ucy9lcy9pY29ucy9JbmZvQ2lyY2xlRmlsbGVkXCI7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IENPTlRBSU5FUl9NQVhfT0ZGU0VUIH0gZnJvbSAnLi4vX3V0aWwvaG9va3MvdXNlWkluZGV4JztcbmltcG9ydCB7IGdldFRyYW5zaXRpb25OYW1lIH0gZnJvbSAnLi4vX3V0aWwvbW90aW9uJztcbmltcG9ydCB7IGRldlVzZVdhcm5pbmcgfSBmcm9tICcuLi9fdXRpbC93YXJuaW5nJztcbmltcG9ydCBDb25maWdQcm92aWRlciBmcm9tICcuLi9jb25maWctcHJvdmlkZXInO1xuaW1wb3J0IHsgdXNlTG9jYWxlIH0gZnJvbSAnLi4vbG9jYWxlJztcbmltcG9ydCB1c2VUb2tlbiBmcm9tICcuLi90aGVtZS91c2VUb2tlbic7XG5pbXBvcnQgQ2FuY2VsQnRuIGZyb20gJy4vY29tcG9uZW50cy9Db25maXJtQ2FuY2VsQnRuJztcbmltcG9ydCBPa0J0biBmcm9tICcuL2NvbXBvbmVudHMvQ29uZmlybU9rQnRuJztcbmltcG9ydCB7IE1vZGFsQ29udGV4dFByb3ZpZGVyIH0gZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCBNb2RhbCBmcm9tICcuL01vZGFsJztcbmltcG9ydCBDb25maXJtIGZyb20gJy4vc3R5bGUvY29uZmlybSc7XG5leHBvcnQgZnVuY3Rpb24gQ29uZmlybUNvbnRlbnQocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgICAgcHJlZml4Q2xzLFxuICAgICAgaWNvbixcbiAgICAgIG9rVGV4dCxcbiAgICAgIGNhbmNlbFRleHQsXG4gICAgICBjb25maXJtUHJlZml4Q2xzLFxuICAgICAgdHlwZSxcbiAgICAgIG9rQ2FuY2VsLFxuICAgICAgZm9vdGVyLFxuICAgICAgLy8gTGVnYWN5IGZvciBzdGF0aWMgZnVuY3Rpb24gdXNhZ2VcbiAgICAgIGxvY2FsZTogc3RhdGljTG9jYWxlXG4gICAgfSA9IHByb3BzLFxuICAgIHJlc2V0UHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcInByZWZpeENsc1wiLCBcImljb25cIiwgXCJva1RleHRcIiwgXCJjYW5jZWxUZXh0XCIsIFwiY29uZmlybVByZWZpeENsc1wiLCBcInR5cGVcIiwgXCJva0NhbmNlbFwiLCBcImZvb3RlclwiLCBcImxvY2FsZVwiXSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3Qgd2FybmluZyA9IGRldlVzZVdhcm5pbmcoJ01vZGFsJyk7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHR5cGVvZiBpY29uID09PSAnc3RyaW5nJyAmJiBpY29uLmxlbmd0aCA+IDIpLCAnYnJlYWtpbmcnLCBgXFxgaWNvblxcYCBpcyB1c2luZyBSZWFjdE5vZGUgaW5zdGVhZCBvZiBzdHJpbmcgbmFtaW5nIGluIHY0LiBQbGVhc2UgY2hlY2sgXFxgJHtpY29ufVxcYCBhdCBodHRwczovL2FudC5kZXNpZ24vY29tcG9uZW50cy9pY29uYCkgOiB2b2lkIDA7XG4gIH1cbiAgLy8gSWNvblxuICBsZXQgbWVyZ2VkSWNvbiA9IGljb247XG4gIC8vIOaUr+aMgeS8oOWFpXsgaWNvbjogbnVsbCB95p2l6ZqQ6JePYE1vZGFsLmNvbmZpcm1g6buY6K6k55qESWNvblxuICBpZiAoIWljb24gJiYgaWNvbiAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnaW5mbyc6XG4gICAgICAgIG1lcmdlZEljb24gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbmZvQ2lyY2xlRmlsbGVkLCBudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdWNjZXNzJzpcbiAgICAgICAgbWVyZ2VkSWNvbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENoZWNrQ2lyY2xlRmlsbGVkLCBudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIG1lcmdlZEljb24gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDbG9zZUNpcmNsZUZpbGxlZCwgbnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbWVyZ2VkSWNvbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEV4Y2xhbWF0aW9uQ2lyY2xlRmlsbGVkLCBudWxsKTtcbiAgICB9XG4gIH1cbiAgLy8g6buY6K6k5Li6IHRydWXvvIzkv53mjIHlkJHkuIvlhbzlrrlcbiAgY29uc3QgbWVyZ2VkT2tDYW5jZWwgPSBva0NhbmNlbCAhPT0gbnVsbCAmJiBva0NhbmNlbCAhPT0gdm9pZCAwID8gb2tDYW5jZWwgOiB0eXBlID09PSAnY29uZmlybSc7XG4gIGNvbnN0IGF1dG9Gb2N1c0J1dHRvbiA9IHByb3BzLmF1dG9Gb2N1c0J1dHRvbiA9PT0gbnVsbCA/IGZhbHNlIDogcHJvcHMuYXV0b0ZvY3VzQnV0dG9uIHx8ICdvayc7XG4gIGNvbnN0IFtsb2NhbGVdID0gdXNlTG9jYWxlKCdNb2RhbCcpO1xuICBjb25zdCBtZXJnZWRMb2NhbGUgPSBzdGF0aWNMb2NhbGUgfHwgbG9jYWxlO1xuICAvLyA9PT09PT09PT09PT09PT09PT0gTG9jYWxlIFRleHQgPT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IG9rVGV4dExvY2FsZSA9IG9rVGV4dCB8fCAobWVyZ2VkT2tDYW5jZWwgPyBtZXJnZWRMb2NhbGUgPT09IG51bGwgfHwgbWVyZ2VkTG9jYWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXJnZWRMb2NhbGUub2tUZXh0IDogbWVyZ2VkTG9jYWxlID09PSBudWxsIHx8IG1lcmdlZExvY2FsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVyZ2VkTG9jYWxlLmp1c3RPa1RleHQpO1xuICBjb25zdCBjYW5jZWxUZXh0TG9jYWxlID0gY2FuY2VsVGV4dCB8fCAobWVyZ2VkTG9jYWxlID09PSBudWxsIHx8IG1lcmdlZExvY2FsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVyZ2VkTG9jYWxlLmNhbmNlbFRleHQpO1xuICAvLyA9PT09PT09PT09PT09PT09PSBDb250ZXh0IFZhbHVlID09PT09PT09PT09PT09PT09XG4gIGNvbnN0IGJ0bkN0eFZhbHVlID0gT2JqZWN0LmFzc2lnbih7XG4gICAgYXV0b0ZvY3VzQnV0dG9uLFxuICAgIGNhbmNlbFRleHRMb2NhbGUsXG4gICAgb2tUZXh0TG9jYWxlLFxuICAgIG1lcmdlZE9rQ2FuY2VsXG4gIH0sIHJlc2V0UHJvcHMpO1xuICBjb25zdCBidG5DdHhWYWx1ZU1lbW8gPSBSZWFjdC51c2VNZW1vKCgpID0+IGJ0bkN0eFZhbHVlLCBfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LnZhbHVlcyhidG5DdHhWYWx1ZSkpKTtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PSBGb290ZXIgT3JpZ2luIE5vZGUgPT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCBmb290ZXJPcmlnaW5Ob2RlID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENhbmNlbEJ0biwgbnVsbCksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE9rQnRuLCBudWxsKSk7XG4gIGNvbnN0IGhhc1RpdGxlID0gcHJvcHMudGl0bGUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy50aXRsZSAhPT0gbnVsbDtcbiAgY29uc3QgYm9keUNscyA9IGAke2NvbmZpcm1QcmVmaXhDbHN9LWJvZHlgO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogYCR7Y29uZmlybVByZWZpeENsc30tYm9keS13cmFwcGVyYFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGJvZHlDbHMsIHtcbiAgICAgIFtgJHtib2R5Q2xzfS1oYXMtdGl0bGVgXTogaGFzVGl0bGVcbiAgICB9KVxuICB9LCBtZXJnZWRJY29uLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtjb25maXJtUHJlZml4Q2xzfS1wYXJhZ3JhcGhgXG4gIH0sIGhhc1RpdGxlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtjb25maXJtUHJlZml4Q2xzfS10aXRsZWBcbiAgfSwgcHJvcHMudGl0bGUpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtjb25maXJtUHJlZml4Q2xzfS1jb250ZW50YFxuICB9LCBwcm9wcy5jb250ZW50KSkpLCBmb290ZXIgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgZm9vdGVyID09PSAnZnVuY3Rpb24nID8gKC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1vZGFsQ29udGV4dFByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGJ0bkN0eFZhbHVlTWVtb1xuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBgJHtjb25maXJtUHJlZml4Q2xzfS1idG5zYFxuICB9LCB0eXBlb2YgZm9vdGVyID09PSAnZnVuY3Rpb24nID8gZm9vdGVyKGZvb3Rlck9yaWdpbk5vZGUsIHtcbiAgICBPa0J0bixcbiAgICBDYW5jZWxCdG5cbiAgfSkgOiBmb290ZXJPcmlnaW5Ob2RlKSkpIDogZm9vdGVyLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb25maXJtLCB7XG4gICAgcHJlZml4Q2xzOiBwcmVmaXhDbHNcbiAgfSkpO1xufVxuY29uc3QgQ29uZmlybURpYWxvZyA9IHByb3BzID0+IHtcbiAgY29uc3Qge1xuICAgIGNsb3NlLFxuICAgIHpJbmRleCxcbiAgICBtYXNrU3R5bGUsXG4gICAgZGlyZWN0aW9uLFxuICAgIHByZWZpeENscyxcbiAgICB3cmFwQ2xhc3NOYW1lLFxuICAgIHJvb3RQcmVmaXhDbHMsXG4gICAgYm9keVN0eWxlLFxuICAgIGNsb3NhYmxlID0gZmFsc2UsXG4gICAgb25Db25maXJtLFxuICAgIHN0eWxlc1xuICB9ID0gcHJvcHM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3Qgd2FybmluZyA9IGRldlVzZVdhcm5pbmcoJ01vZGFsJyk7XG4gICAgW1sndmlzaWJsZScsICdvcGVuJ10sIFsnYm9keVN0eWxlJywgJ3N0eWxlcy5ib2R5J10sIFsnbWFza1N0eWxlJywgJ3N0eWxlcy5tYXNrJ11dLmZvckVhY2goX3JlZiA9PiB7XG4gICAgICBsZXQgW2RlcHJlY2F0ZWROYW1lLCBuZXdOYW1lXSA9IF9yZWY7XG4gICAgICB3YXJuaW5nLmRlcHJlY2F0ZWQoIShkZXByZWNhdGVkTmFtZSBpbiBwcm9wcyksIGRlcHJlY2F0ZWROYW1lLCBuZXdOYW1lKTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBjb25maXJtUHJlZml4Q2xzID0gYCR7cHJlZml4Q2xzfS1jb25maXJtYDtcbiAgY29uc3Qgd2lkdGggPSBwcm9wcy53aWR0aCB8fCA0MTY7XG4gIGNvbnN0IHN0eWxlID0gcHJvcHMuc3R5bGUgfHwge307XG4gIGNvbnN0IG1hc2sgPSBwcm9wcy5tYXNrID09PSB1bmRlZmluZWQgPyB0cnVlIDogcHJvcHMubWFzaztcbiAgLy8g6buY6K6k5Li6IGZhbHNl77yM5L+d5oyB5pen54mI6buY6K6k6KGM5Li6XG4gIGNvbnN0IG1hc2tDbG9zYWJsZSA9IHByb3BzLm1hc2tDbG9zYWJsZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBwcm9wcy5tYXNrQ2xvc2FibGU7XG4gIGNvbnN0IGNsYXNzU3RyaW5nID0gY2xhc3NOYW1lcyhjb25maXJtUHJlZml4Q2xzLCBgJHtjb25maXJtUHJlZml4Q2xzfS0ke3Byb3BzLnR5cGV9YCwge1xuICAgIFtgJHtjb25maXJtUHJlZml4Q2xzfS1ydGxgXTogZGlyZWN0aW9uID09PSAncnRsJ1xuICB9LCBwcm9wcy5jbGFzc05hbWUpO1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09IHpJbmRleCA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IFssIHRva2VuXSA9IHVzZVRva2VuKCk7XG4gIGNvbnN0IG1lcmdlZFpJbmRleCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICh6SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHpJbmRleDtcbiAgICB9XG4gICAgLy8gU3RhdGljIGFsd2F5cyB1c2UgbWF4IHpJbmRleFxuICAgIHJldHVybiB0b2tlbi56SW5kZXhQb3B1cEJhc2UgKyBDT05UQUlORVJfTUFYX09GRlNFVDtcbiAgfSwgW3pJbmRleCwgdG9rZW5dKTtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBSZW5kZXIgPT09PT09PT09PT09PT09PT09PT09PT09PVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTW9kYWwsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc1N0cmluZyxcbiAgICB3cmFwQ2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgIFtgJHtjb25maXJtUHJlZml4Q2xzfS1jZW50ZXJlZGBdOiAhIXByb3BzLmNlbnRlcmVkXG4gICAgfSwgd3JhcENsYXNzTmFtZSksXG4gICAgb25DYW5jZWw6ICgpID0+IHtcbiAgICAgIGNsb3NlID09PSBudWxsIHx8IGNsb3NlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZSh7XG4gICAgICAgIHRyaWdnZXJDYW5jZWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgb25Db25maXJtID09PSBudWxsIHx8IG9uQ29uZmlybSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Db25maXJtKGZhbHNlKTtcbiAgICB9LFxuICAgIHRpdGxlOiBcIlwiLFxuICAgIGZvb3RlcjogbnVsbCxcbiAgICB0cmFuc2l0aW9uTmFtZTogZ2V0VHJhbnNpdGlvbk5hbWUocm9vdFByZWZpeENscyB8fCAnJywgJ3pvb20nLCBwcm9wcy50cmFuc2l0aW9uTmFtZSksXG4gICAgbWFza1RyYW5zaXRpb25OYW1lOiBnZXRUcmFuc2l0aW9uTmFtZShyb290UHJlZml4Q2xzIHx8ICcnLCAnZmFkZScsIHByb3BzLm1hc2tUcmFuc2l0aW9uTmFtZSksXG4gICAgbWFzazogbWFzayxcbiAgICBtYXNrQ2xvc2FibGU6IG1hc2tDbG9zYWJsZSxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgc3R5bGVzOiBPYmplY3QuYXNzaWduKHtcbiAgICAgIGJvZHk6IGJvZHlTdHlsZSxcbiAgICAgIG1hc2s6IG1hc2tTdHlsZVxuICAgIH0sIHN0eWxlcyksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIHpJbmRleDogbWVyZ2VkWkluZGV4LFxuICAgIGNsb3NhYmxlOiBjbG9zYWJsZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29uZmlybUNvbnRlbnQsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgY29uZmlybVByZWZpeENsczogY29uZmlybVByZWZpeENsc1xuICB9KSkpO1xufTtcbmNvbnN0IENvbmZpcm1EaWFsb2dXcmFwcGVyID0gcHJvcHMgPT4ge1xuICBjb25zdCB7XG4gICAgcm9vdFByZWZpeENscyxcbiAgICBpY29uUHJlZml4Q2xzLFxuICAgIGRpcmVjdGlvbixcbiAgICB0aGVtZVxuICB9ID0gcHJvcHM7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb25maWdQcm92aWRlciwge1xuICAgIHByZWZpeENsczogcm9vdFByZWZpeENscyxcbiAgICBpY29uUHJlZml4Q2xzOiBpY29uUHJlZml4Q2xzLFxuICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgIHRoZW1lOiB0aGVtZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb25maXJtRGlhbG9nLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpKTtcbn07XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBDb25maXJtRGlhbG9nLmRpc3BsYXlOYW1lID0gJ0NvbmZpcm1EaWFsb2cnO1xuICBDb25maXJtRGlhbG9nV3JhcHBlci5kaXNwbGF5TmFtZSA9ICdDb25maXJtRGlhbG9nV3JhcHBlcic7XG59XG5leHBvcnQgZGVmYXVsdCBDb25maXJtRGlhbG9nV3JhcHBlcjsiLCJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXlcIjtcbnZhciBfX3Jlc3QgPSB0aGlzICYmIHRoaXMuX19yZXN0IHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKSB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKSB0W3BbaV1dID0gc1twW2ldXTtcbiAgfVxuICByZXR1cm4gdDtcbn07XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDb25maWdDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29uZmlnLXByb3ZpZGVyJztcbmltcG9ydCBkZWZhdWx0TG9jYWxlIGZyb20gJy4uLy4uL2xvY2FsZS9lbl9VUyc7XG5pbXBvcnQgdXNlTG9jYWxlIGZyb20gJy4uLy4uL2xvY2FsZS91c2VMb2NhbGUnO1xuaW1wb3J0IENvbmZpcm1EaWFsb2cgZnJvbSAnLi4vQ29uZmlybURpYWxvZyc7XG5jb25zdCBIb29rTW9kYWwgPSAoX2EsIHJlZikgPT4ge1xuICB2YXIgX2I7XG4gIHZhciB7XG4gICAgICBhZnRlckNsb3NlOiBob29rQWZ0ZXJDbG9zZSxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBfYSxcbiAgICByZXN0UHJvcHMgPSBfX3Jlc3QoX2EsIFtcImFmdGVyQ2xvc2VcIiwgXCJjb25maWdcIl0pO1xuICBjb25zdCBbb3Blbiwgc2V0T3Blbl0gPSBSZWFjdC51c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2lubmVyQ29uZmlnLCBzZXRJbm5lckNvbmZpZ10gPSBSZWFjdC51c2VTdGF0ZShjb25maWcpO1xuICBjb25zdCB7XG4gICAgZGlyZWN0aW9uLFxuICAgIGdldFByZWZpeENsc1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChDb25maWdDb250ZXh0KTtcbiAgY29uc3QgcHJlZml4Q2xzID0gZ2V0UHJlZml4Q2xzKCdtb2RhbCcpO1xuICBjb25zdCByb290UHJlZml4Q2xzID0gZ2V0UHJlZml4Q2xzKCk7XG4gIGNvbnN0IGFmdGVyQ2xvc2UgPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGhvb2tBZnRlckNsb3NlKCk7XG4gICAgKF9hID0gaW5uZXJDb25maWcuYWZ0ZXJDbG9zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW5uZXJDb25maWcpO1xuICB9O1xuICBjb25zdCBjbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG4gICAgc2V0T3BlbihmYWxzZSk7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBjb25zdCB0cmlnZ2VyQ2FuY2VsID0gYXJncy5zb21lKHBhcmFtID0+IHBhcmFtID09PSBudWxsIHx8IHBhcmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbS50cmlnZ2VyQ2FuY2VsKTtcbiAgICBpZiAodHJpZ2dlckNhbmNlbCkge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIChfYSA9IGlubmVyQ29uZmlnLm9uQ2FuY2VsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9hMiA9IF9hKS5jYWxsLmFwcGx5KF9hMiwgW2lubmVyQ29uZmlnLCAoKSA9PiB7fV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhcmdzLnNsaWNlKDEpKSkpO1xuICAgIH1cbiAgfTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+ICh7XG4gICAgZGVzdHJveTogY2xvc2UsXG4gICAgdXBkYXRlOiBuZXdDb25maWcgPT4ge1xuICAgICAgc2V0SW5uZXJDb25maWcob3JpZ2luQ29uZmlnID0+IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luQ29uZmlnKSwgbmV3Q29uZmlnKSk7XG4gICAgfVxuICB9KSk7XG4gIGNvbnN0IG1lcmdlZE9rQ2FuY2VsID0gKF9iID0gaW5uZXJDb25maWcub2tDYW5jZWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGlubmVyQ29uZmlnLnR5cGUgPT09ICdjb25maXJtJztcbiAgY29uc3QgW2NvbnRleHRMb2NhbGVdID0gdXNlTG9jYWxlKCdNb2RhbCcsIGRlZmF1bHRMb2NhbGUuTW9kYWwpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29uZmlybURpYWxvZywgT2JqZWN0LmFzc2lnbih7XG4gICAgcHJlZml4Q2xzOiBwcmVmaXhDbHMsXG4gICAgcm9vdFByZWZpeENsczogcm9vdFByZWZpeENsc1xuICB9LCBpbm5lckNvbmZpZywge1xuICAgIGNsb3NlOiBjbG9zZSxcbiAgICBvcGVuOiBvcGVuLFxuICAgIGFmdGVyQ2xvc2U6IGFmdGVyQ2xvc2UsXG4gICAgb2tUZXh0OiBpbm5lckNvbmZpZy5va1RleHQgfHwgKG1lcmdlZE9rQ2FuY2VsID8gY29udGV4dExvY2FsZSA9PT0gbnVsbCB8fCBjb250ZXh0TG9jYWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0TG9jYWxlLm9rVGV4dCA6IGNvbnRleHRMb2NhbGUgPT09IG51bGwgfHwgY29udGV4dExvY2FsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dExvY2FsZS5qdXN0T2tUZXh0KSxcbiAgICBkaXJlY3Rpb246IGlubmVyQ29uZmlnLmRpcmVjdGlvbiB8fCBkaXJlY3Rpb24sXG4gICAgY2FuY2VsVGV4dDogaW5uZXJDb25maWcuY2FuY2VsVGV4dCB8fCAoY29udGV4dExvY2FsZSA9PT0gbnVsbCB8fCBjb250ZXh0TG9jYWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0TG9jYWxlLmNhbmNlbFRleHQpXG4gIH0sIHJlc3RQcm9wcykpO1xufTtcbmV4cG9ydCBkZWZhdWx0IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKEhvb2tNb2RhbCk7IiwiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlUGF0Y2hFbGVtZW50IGZyb20gJy4uLy4uL191dGlsL2hvb2tzL3VzZVBhdGNoRWxlbWVudCc7XG5pbXBvcnQgeyB3aXRoQ29uZmlybSwgd2l0aEVycm9yLCB3aXRoSW5mbywgd2l0aFN1Y2Nlc3MsIHdpdGhXYXJuIH0gZnJvbSAnLi4vY29uZmlybSc7XG5pbXBvcnQgZGVzdHJveUZucyBmcm9tICcuLi9kZXN0cm95Rm5zJztcbmltcG9ydCBIb29rTW9kYWwgZnJvbSAnLi9Ib29rTW9kYWwnO1xubGV0IHV1aWQgPSAwO1xuY29uc3QgRWxlbWVudHNIb2xkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbygvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoX3Byb3BzLCByZWYpID0+IHtcbiAgY29uc3QgW2VsZW1lbnRzLCBwYXRjaEVsZW1lbnRdID0gdXNlUGF0Y2hFbGVtZW50KCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiAoe1xuICAgIHBhdGNoRWxlbWVudFxuICB9KSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGVsZW1lbnRzKTtcbn0pKTtcbmZ1bmN0aW9uIHVzZU1vZGFsKCkge1xuICBjb25zdCBob2xkZXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09IEVmZmVjdCA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCBbYWN0aW9uUXVldWUsIHNldEFjdGlvblF1ZXVlXSA9IFJlYWN0LnVzZVN0YXRlKFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYWN0aW9uUXVldWUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjbG9uZVF1ZXVlID0gX3RvQ29uc3VtYWJsZUFycmF5KGFjdGlvblF1ZXVlKTtcbiAgICAgIGNsb25lUXVldWUuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgICBhY3Rpb24oKTtcbiAgICAgIH0pO1xuICAgICAgc2V0QWN0aW9uUXVldWUoW10pO1xuICAgIH1cbiAgfSwgW2FjdGlvblF1ZXVlXSk7XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PSBIb29rID09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCBnZXRDb25maXJtRnVuYyA9IFJlYWN0LnVzZUNhbGxiYWNrKHdpdGhGdW5jID0+IGZ1bmN0aW9uIGhvb2tDb25maXJtKGNvbmZpZykge1xuICAgIHZhciBfYTtcbiAgICB1dWlkICs9IDE7XG4gICAgY29uc3QgbW9kYWxSZWYgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgLy8gUHJveHkgdG8gcHJvbWlzZSB3aXRoIGBvbkNsb3NlYFxuICAgIGxldCByZXNvbHZlUHJvbWlzZTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgbGV0IHNpbGVudCA9IGZhbHNlO1xuICAgIGxldCBjbG9zZUZ1bmM7XG4gICAgY29uc3QgbW9kYWwgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChIb29rTW9kYWwsIHtcbiAgICAgIGtleTogYG1vZGFsLSR7dXVpZH1gLFxuICAgICAgY29uZmlnOiB3aXRoRnVuYyhjb25maWcpLFxuICAgICAgcmVmOiBtb2RhbFJlZixcbiAgICAgIGFmdGVyQ2xvc2U6ICgpID0+IHtcbiAgICAgICAgY2xvc2VGdW5jID09PSBudWxsIHx8IGNsb3NlRnVuYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VGdW5jKCk7XG4gICAgICB9LFxuICAgICAgaXNTaWxlbnQ6ICgpID0+IHNpbGVudCxcbiAgICAgIG9uQ29uZmlybTogY29uZmlybWVkID0+IHtcbiAgICAgICAgcmVzb2x2ZVByb21pc2UoY29uZmlybWVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjbG9zZUZ1bmMgPSAoX2EgPSBob2xkZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdGNoRWxlbWVudChtb2RhbCk7XG4gICAgaWYgKGNsb3NlRnVuYykge1xuICAgICAgZGVzdHJveUZucy5wdXNoKGNsb3NlRnVuYyk7XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlID0ge1xuICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICBmdW5jdGlvbiBkZXN0cm95QWN0aW9uKCkge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAoX2EgPSBtb2RhbFJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RhbFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgZGVzdHJveUFjdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldEFjdGlvblF1ZXVlKHByZXYgPT4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwcmV2KSwgW2Rlc3Ryb3lBY3Rpb25dKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1cGRhdGU6IG5ld0NvbmZpZyA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUFjdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgKF9hID0gbW9kYWxSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZShuZXdDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RhbFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgdXBkYXRlQWN0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0QWN0aW9uUXVldWUocHJldiA9PiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHByZXYpLCBbdXBkYXRlQWN0aW9uXSkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGhlbjogcmVzb2x2ZSA9PiB7XG4gICAgICAgIHNpbGVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4ocmVzb2x2ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0sIFtdKTtcbiAgY29uc3QgZm5zID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGluZm86IGdldENvbmZpcm1GdW5jKHdpdGhJbmZvKSxcbiAgICBzdWNjZXNzOiBnZXRDb25maXJtRnVuYyh3aXRoU3VjY2VzcyksXG4gICAgZXJyb3I6IGdldENvbmZpcm1GdW5jKHdpdGhFcnJvciksXG4gICAgd2FybmluZzogZ2V0Q29uZmlybUZ1bmMod2l0aFdhcm4pLFxuICAgIGNvbmZpcm06IGdldENvbmZpcm1GdW5jKHdpdGhDb25maXJtKVxuICB9KSwgW10pO1xuICByZXR1cm4gW2ZucywgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRWxlbWVudHNIb2xkZXIsIHtcbiAgICBrZXk6IFwibW9kYWwtaG9sZGVyXCIsXG4gICAgcmVmOiBob2xkZXJSZWZcbiAgfSldO1xufVxuZXhwb3J0IGRlZmF1bHQgdXNlTW9kYWw7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///94691\n")}}]);