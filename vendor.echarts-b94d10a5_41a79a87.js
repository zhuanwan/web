"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[84],{47987:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _BaseBarSeries_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98908);\n/* harmony import */ var _helper_createSeriesData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13637);\n/* harmony import */ var _util_component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12616);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar BarSeriesModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(BarSeriesModel, _super);\n  function BarSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = BarSeriesModel.type;\n    return _this;\n  }\n  BarSeriesModel.prototype.getInitialData = function () {\n    return (0,_helper_createSeriesData_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)(null, this, {\n      useEncodeDefaulter: true,\n      createInvertedIndices: !!this.get('realtimeSort', true) || null\n    });\n  };\n  /**\r\n   * @override\r\n   */\n  BarSeriesModel.prototype.getProgressive = function () {\n    // Do not support progressive in normal mode.\n    return this.get('large') ? this.get('progressive') : false;\n  };\n  /**\r\n   * @override\r\n   */\n  BarSeriesModel.prototype.getProgressiveThreshold = function () {\n    // Do not support progressive in normal mode.\n    var progressiveThreshold = this.get('progressiveThreshold');\n    var largeThreshold = this.get('largeThreshold');\n    if (largeThreshold > progressiveThreshold) {\n      progressiveThreshold = largeThreshold;\n    }\n    return progressiveThreshold;\n  };\n  BarSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {\n    return selectors.rect(data.getItemLayout(dataIndex));\n  };\n  BarSeriesModel.type = 'series.bar';\n  BarSeriesModel.dependencies = ['grid', 'polar'];\n  BarSeriesModel.defaultOption = (0,_util_component_js__WEBPACK_IMPORTED_MODULE_2__/* .inheritDefaultOption */ .G_)(_BaseBarSeries_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A.defaultOption, {\n    // If clipped\n    // Only available on cartesian2d\n    clip: true,\n    roundCap: false,\n    showBackground: false,\n    backgroundStyle: {\n      color: 'rgba(180, 180, 180, 0.2)',\n      borderColor: null,\n      borderWidth: 0,\n      borderType: 'solid',\n      borderRadius: 0,\n      shadowBlur: 0,\n      shadowColor: null,\n      shadowOffsetX: 0,\n      shadowOffsetY: 0,\n      opacity: 1\n    },\n    select: {\n      itemStyle: {\n        borderColor: '#212121'\n      }\n    },\n    realtimeSort: false\n  });\n  return BarSeriesModel;\n}(_BaseBarSeries_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BarSeriesModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc5ODcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXJTZXJpZXMuanM/ZjE5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IEJhc2VCYXJTZXJpZXNNb2RlbCBmcm9tICcuL0Jhc2VCYXJTZXJpZXMuanMnO1xuaW1wb3J0IGNyZWF0ZVNlcmllc0RhdGEgZnJvbSAnLi4vaGVscGVyL2NyZWF0ZVNlcmllc0RhdGEuanMnO1xuaW1wb3J0IHsgaW5oZXJpdERlZmF1bHRPcHRpb24gfSBmcm9tICcuLi8uLi91dGlsL2NvbXBvbmVudC5qcyc7XG52YXIgQmFyU2VyaWVzTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQmFyU2VyaWVzTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEJhclNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBCYXJTZXJpZXNNb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBCYXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVNlcmllc0RhdGEobnVsbCwgdGhpcywge1xuICAgICAgdXNlRW5jb2RlRGVmYXVsdGVyOiB0cnVlLFxuICAgICAgY3JlYXRlSW52ZXJ0ZWRJbmRpY2VzOiAhIXRoaXMuZ2V0KCdyZWFsdGltZVNvcnQnLCB0cnVlKSB8fCBudWxsXG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBCYXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0UHJvZ3Jlc3NpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRG8gbm90IHN1cHBvcnQgcHJvZ3Jlc3NpdmUgaW4gbm9ybWFsIG1vZGUuXG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdsYXJnZScpID8gdGhpcy5nZXQoJ3Byb2dyZXNzaXZlJykgOiBmYWxzZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXG4gIEJhclNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRQcm9ncmVzc2l2ZVRocmVzaG9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEbyBub3Qgc3VwcG9ydCBwcm9ncmVzc2l2ZSBpbiBub3JtYWwgbW9kZS5cbiAgICB2YXIgcHJvZ3Jlc3NpdmVUaHJlc2hvbGQgPSB0aGlzLmdldCgncHJvZ3Jlc3NpdmVUaHJlc2hvbGQnKTtcbiAgICB2YXIgbGFyZ2VUaHJlc2hvbGQgPSB0aGlzLmdldCgnbGFyZ2VUaHJlc2hvbGQnKTtcbiAgICBpZiAobGFyZ2VUaHJlc2hvbGQgPiBwcm9ncmVzc2l2ZVRocmVzaG9sZCkge1xuICAgICAgcHJvZ3Jlc3NpdmVUaHJlc2hvbGQgPSBsYXJnZVRocmVzaG9sZDtcbiAgICB9XG4gICAgcmV0dXJuIHByb2dyZXNzaXZlVGhyZXNob2xkO1xuICB9O1xuICBCYXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuYnJ1c2hTZWxlY3RvciA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIGRhdGEsIHNlbGVjdG9ycykge1xuICAgIHJldHVybiBzZWxlY3RvcnMucmVjdChkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KSk7XG4gIH07XG4gIEJhclNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLmJhcic7XG4gIEJhclNlcmllc01vZGVsLmRlcGVuZGVuY2llcyA9IFsnZ3JpZCcsICdwb2xhciddO1xuICBCYXJTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0gaW5oZXJpdERlZmF1bHRPcHRpb24oQmFzZUJhclNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24sIHtcbiAgICAvLyBJZiBjbGlwcGVkXG4gICAgLy8gT25seSBhdmFpbGFibGUgb24gY2FydGVzaWFuMmRcbiAgICBjbGlwOiB0cnVlLFxuICAgIHJvdW5kQ2FwOiBmYWxzZSxcbiAgICBzaG93QmFja2dyb3VuZDogZmFsc2UsXG4gICAgYmFja2dyb3VuZFN0eWxlOiB7XG4gICAgICBjb2xvcjogJ3JnYmEoMTgwLCAxODAsIDE4MCwgMC4yKScsXG4gICAgICBib3JkZXJDb2xvcjogbnVsbCxcbiAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgYm9yZGVyVHlwZTogJ3NvbGlkJyxcbiAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgIHNoYWRvd0JsdXI6IDAsXG4gICAgICBzaGFkb3dDb2xvcjogbnVsbCxcbiAgICAgIHNoYWRvd09mZnNldFg6IDAsXG4gICAgICBzaGFkb3dPZmZzZXRZOiAwLFxuICAgICAgb3BhY2l0eTogMVxuICAgIH0sXG4gICAgc2VsZWN0OiB7XG4gICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6ICcjMjEyMTIxJ1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVhbHRpbWVTb3J0OiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIEJhclNlcmllc01vZGVsO1xufShCYXNlQmFyU2VyaWVzTW9kZWwpO1xuZXhwb3J0IGRlZmF1bHQgQmFyU2VyaWVzTW9kZWw7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///47987\n")},60859:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_graphic_Path_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(59482);\n/* harmony import */ var zrender_lib_graphic_Group_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(43870);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(98026);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43199);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5638);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(30010);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(25014);\n/* harmony import */ var _util_innerStore_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(69622);\n/* harmony import */ var _util_states_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(34833);\n/* harmony import */ var _label_labelStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89632);\n/* harmony import */ var _util_throttle_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(24711);\n/* harmony import */ var _helper_createClipPathFromCoordSys_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(95235);\n/* harmony import */ var _util_shape_sausage_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(84618);\n/* harmony import */ var _view_Chart_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(6666);\n/* harmony import */ var _coord_CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41849);\n/* harmony import */ var _helper_labelHelper_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(44532);\n/* harmony import */ var _label_sectorLabel_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(94327);\n/* harmony import */ var _helper_sectorHelper_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(79446);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nfunction getClipArea(coord, data) {\n  var coordSysClipArea = coord.getArea && coord.getArea();\n  if ((0,_coord_CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__/* .isCoordinateSystemType */ .g)(coord, 'cartesian2d')) {\n    var baseAxis = coord.getBaseAxis();\n    // When boundaryGap is false or using time axis. bar may exceed the grid.\n    // We should not clip this part.\n    // See test/bar2.html\n    if (baseAxis.type !== 'category' || !baseAxis.onBand) {\n      var expandWidth = data.getLayout('bandWidth');\n      if (baseAxis.isHorizontal()) {\n        coordSysClipArea.x -= expandWidth;\n        coordSysClipArea.width += expandWidth * 2;\n      } else {\n        coordSysClipArea.y -= expandWidth;\n        coordSysClipArea.height += expandWidth * 2;\n      }\n    }\n  }\n  return coordSysClipArea;\n}\nvar BarView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .C6)(BarView, _super);\n  function BarView() {\n    var _this = _super.call(this) || this;\n    _this.type = BarView.type;\n    _this._isFirstFrame = true;\n    return _this;\n  }\n  BarView.prototype.render = function (seriesModel, ecModel, api, payload) {\n    this._model = seriesModel;\n    this._removeOnRenderedListener(api);\n    this._updateDrawMode(seriesModel);\n    var coordinateSystemType = seriesModel.get('coordinateSystem');\n    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n      // Clear previously rendered progressive elements.\n      this._progressiveEls = null;\n      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);\n    } else if (false) {}\n  };\n  BarView.prototype.incrementalPrepareRender = function (seriesModel) {\n    this._clear();\n    this._updateDrawMode(seriesModel);\n    // incremental also need to clip, otherwise might be overlow.\n    // But must not set clip in each frame, otherwise all of the children will be marked redraw.\n    this._updateLargeClip(seriesModel);\n  };\n  BarView.prototype.incrementalRender = function (params, seriesModel) {\n    // Reset\n    this._progressiveEls = [];\n    // Do not support progressive in normal mode.\n    this._incrementalRenderLarge(params, seriesModel);\n  };\n  BarView.prototype.eachRendered = function (cb) {\n    (0,_util_graphic_js__WEBPACK_IMPORTED_MODULE_2__.traverseElements)(this._progressiveEls || this.group, cb);\n  };\n  BarView.prototype._updateDrawMode = function (seriesModel) {\n    var isLargeDraw = seriesModel.pipelineContext.large;\n    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {\n      this._isLargeDraw = isLargeDraw;\n      this._clear();\n    }\n  };\n  BarView.prototype._renderNormal = function (seriesModel, ecModel, api, payload) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coord = seriesModel.coordinateSystem;\n    var baseAxis = coord.getBaseAxis();\n    var isHorizontalOrRadial;\n    if (coord.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n    } else if (coord.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n    }\n    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n    var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);\n    if (realtimeSortCfg) {\n      this._enableRealtimeSort(realtimeSortCfg, data, api);\n    }\n    var needsClip = seriesModel.get('clip', true) || realtimeSortCfg;\n    var coordSysClipArea = getClipArea(coord, data);\n    // If there is clipPath created in large mode. Remove it.\n    group.removeClipPath();\n    // We don't use clipPath in normal mode because we needs a perfect animation\n    // And don't want the label are clipped.\n    var roundCap = seriesModel.get('roundCap', true);\n    var drawBackground = seriesModel.get('showBackground', true);\n    var backgroundModel = seriesModel.getModel('backgroundStyle');\n    var barBorderRadius = backgroundModel.get('borderRadius') || 0;\n    var bgEls = [];\n    var oldBgEls = this._backgroundEls;\n    var isInitSort = payload && payload.isInitSort;\n    var isChangeOrder = payload && payload.type === 'changeAxisOrder';\n    function createBackground(dataIndex) {\n      var bgLayout = getLayout[coord.type](data, dataIndex);\n      var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);\n      bgEl.useStyle(backgroundModel.getItemStyle());\n      // Only cartesian2d support borderRadius.\n      if (coord.type === 'cartesian2d') {\n        bgEl.setShape('r', barBorderRadius);\n      } else {\n        bgEl.setShape('cornerRadius', barBorderRadius);\n      }\n      bgEls[dataIndex] = bgEl;\n      return bgEl;\n    }\n    ;\n    data.diff(oldData).add(function (dataIndex) {\n      var itemModel = data.getItemModel(dataIndex);\n      var layout = getLayout[coord.type](data, dataIndex, itemModel);\n      if (drawBackground) {\n        createBackground(dataIndex);\n      }\n      // If dataZoom in filteMode: 'empty', the baseValue can be set as NaN in \"axisProxy\".\n      if (!data.hasValue(dataIndex) || !isValidLayout[coord.type](layout)) {\n        return;\n      }\n      var isClipped = false;\n      if (needsClip) {\n        // Clip will modify the layout params.\n        // And return a boolean to determine if the shape are fully clipped.\n        isClipped = clip[coord.type](coordSysClipArea, layout);\n      }\n      var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);\n      if (realtimeSortCfg) {\n        /**\r\n         * Force label animation because even if the element is\r\n         * ignored because it's clipped, it may not be clipped after\r\n         * changing order. Then, if not using forceLabelAnimation,\r\n         * the label animation was never started, in which case,\r\n         * the label will be the final value and doesn't have label\r\n         * animation.\r\n         */\n        el.forceLabelAnimation = true;\n      }\n      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n      if (isInitSort) {\n        el.attr({\n          shape: layout\n        });\n      } else if (realtimeSortCfg) {\n        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, dataIndex, isHorizontalOrRadial, false, false);\n      } else {\n        (0,_util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .initProps */ .LW)(el, {\n          shape: layout\n        }, seriesModel, dataIndex);\n      }\n      data.setItemGraphicEl(dataIndex, el);\n      group.add(el);\n      el.ignore = isClipped;\n    }).update(function (newIndex, oldIndex) {\n      var itemModel = data.getItemModel(newIndex);\n      var layout = getLayout[coord.type](data, newIndex, itemModel);\n      if (drawBackground) {\n        var bgEl = void 0;\n        if (oldBgEls.length === 0) {\n          bgEl = createBackground(oldIndex);\n        } else {\n          bgEl = oldBgEls[oldIndex];\n          bgEl.useStyle(backgroundModel.getItemStyle());\n          // Only cartesian2d support borderRadius.\n          if (coord.type === 'cartesian2d') {\n            bgEl.setShape('r', barBorderRadius);\n          } else {\n            bgEl.setShape('cornerRadius', barBorderRadius);\n          }\n          bgEls[newIndex] = bgEl;\n        }\n        var bgLayout = getLayout[coord.type](data, newIndex);\n        var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);\n        (0,_util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .updateProps */ .oi)(bgEl, {\n          shape: shape\n        }, animationModel, newIndex);\n      }\n      var el = oldData.getItemGraphicEl(oldIndex);\n      if (!data.hasValue(newIndex) || !isValidLayout[coord.type](layout)) {\n        group.remove(el);\n        return;\n      }\n      var isClipped = false;\n      if (needsClip) {\n        isClipped = clip[coord.type](coordSysClipArea, layout);\n        if (isClipped) {\n          group.remove(el);\n        }\n      }\n      if (!el) {\n        el = elementCreator[coord.type](seriesModel, data, newIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap);\n      } else {\n        (0,_util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .saveOldStyle */ .ap)(el);\n      }\n      if (realtimeSortCfg) {\n        el.forceLabelAnimation = true;\n      }\n      if (isChangeOrder) {\n        var textEl = el.getTextContent();\n        if (textEl) {\n          var labelInnerStore = (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_4__/* .labelInner */ .Lu)(textEl);\n          if (labelInnerStore.prevValue != null) {\n            /**\r\n             * Set preValue to be value so that no new label\r\n             * should be started, otherwise, it will take a full\r\n             * `animationDurationUpdate` time to finish the\r\n             * animation, which is not expected.\r\n             */\n            labelInnerStore.prevValue = labelInnerStore.value;\n          }\n        }\n      }\n      // Not change anything if only order changed.\n      // Especially not change label.\n      else {\n        updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n      }\n      if (isInitSort) {\n        el.attr({\n          shape: layout\n        });\n      } else if (realtimeSortCfg) {\n        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, newIndex, isHorizontalOrRadial, true, isChangeOrder);\n      } else {\n        (0,_util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .updateProps */ .oi)(el, {\n          shape: layout\n        }, seriesModel, newIndex, null);\n      }\n      data.setItemGraphicEl(newIndex, el);\n      el.ignore = isClipped;\n      group.add(el);\n    }).remove(function (dataIndex) {\n      var el = oldData.getItemGraphicEl(dataIndex);\n      el && (0,_util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .removeElementWithFadeOut */ .t5)(el, seriesModel, dataIndex);\n    }).execute();\n    var bgGroup = this._backgroundGroup || (this._backgroundGroup = new zrender_lib_graphic_Group_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A());\n    bgGroup.removeAll();\n    for (var i = 0; i < bgEls.length; ++i) {\n      bgGroup.add(bgEls[i]);\n    }\n    group.add(bgGroup);\n    this._backgroundEls = bgEls;\n    this._data = data;\n  };\n  BarView.prototype._renderLarge = function (seriesModel, ecModel, api) {\n    this._clear();\n    createLarge(seriesModel, this.group);\n    this._updateLargeClip(seriesModel);\n  };\n  BarView.prototype._incrementalRenderLarge = function (params, seriesModel) {\n    this._removeBackground();\n    createLarge(seriesModel, this.group, this._progressiveEls, true);\n  };\n  BarView.prototype._updateLargeClip = function (seriesModel) {\n    // Use clipPath in large mode.\n    var clipPath = seriesModel.get('clip', true) && (0,_helper_createClipPathFromCoordSys_js__WEBPACK_IMPORTED_MODULE_6__/* .createClipPath */ .Ip)(seriesModel.coordinateSystem, false, seriesModel);\n    var group = this.group;\n    if (clipPath) {\n      group.setClipPath(clipPath);\n    } else {\n      group.removeClipPath();\n    }\n  };\n  BarView.prototype._enableRealtimeSort = function (realtimeSortCfg, data, api) {\n    var _this = this;\n    // If no data in the first frame, wait for data to initSort\n    if (!data.count()) {\n      return;\n    }\n    var baseAxis = realtimeSortCfg.baseAxis;\n    if (this._isFirstFrame) {\n      this._dispatchInitSort(data, realtimeSortCfg, api);\n      this._isFirstFrame = false;\n    } else {\n      var orderMapping_1 = function (idx) {\n        var el = data.getItemGraphicEl(idx);\n        var shape = el && el.shape;\n        return shape &&\n        // The result should be consistent with the initial sort by data value.\n        // Do not support the case that both positive and negative exist.\n        Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width)\n        // If data is NaN, shape.xxx may be NaN, so use || 0 here in case\n        || 0;\n      };\n      this._onRendered = function () {\n        _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api);\n      };\n      api.getZr().on('rendered', this._onRendered);\n    }\n  };\n  BarView.prototype._dataSort = function (data, baseAxis, orderMapping) {\n    var info = [];\n    data.each(data.mapDimension(baseAxis.dim), function (ordinalNumber, dataIdx) {\n      var mappedValue = orderMapping(dataIdx);\n      mappedValue = mappedValue == null ? NaN : mappedValue;\n      info.push({\n        dataIndex: dataIdx,\n        mappedValue: mappedValue,\n        ordinalNumber: ordinalNumber\n      });\n    });\n    info.sort(function (a, b) {\n      // If NaN, it will be treated as min val.\n      return b.mappedValue - a.mappedValue;\n    });\n    return {\n      ordinalNumbers: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_7__.map)(info, function (item) {\n        return item.ordinalNumber;\n      })\n    };\n  };\n  BarView.prototype._isOrderChangedWithinSameData = function (data, orderMapping, baseAxis) {\n    var scale = baseAxis.scale;\n    var ordinalDataDim = data.mapDimension(baseAxis.dim);\n    var lastValue = Number.MAX_VALUE;\n    for (var tickNum = 0, len = scale.getOrdinalMeta().categories.length; tickNum < len; ++tickNum) {\n      var rawIdx = data.rawIndexOf(ordinalDataDim, scale.getRawOrdinalNumber(tickNum));\n      var value = rawIdx < 0\n      // If some tick have no bar, the tick will be treated as min.\n      ? Number.MIN_VALUE\n      // PENDING: if dataZoom on baseAxis exits, is it a performance issue?\n      : orderMapping(data.indexOfRawIndex(rawIdx));\n      if (value > lastValue) {\n        return true;\n      }\n      lastValue = value;\n    }\n    return false;\n  };\n  /*\r\n   * Consider the case when A and B changed order, whose representing\r\n   * bars are both out of sight, we don't wish to trigger reorder action\r\n   * as long as the order in the view doesn't change.\r\n   */\n  BarView.prototype._isOrderDifferentInView = function (orderInfo, baseAxis) {\n    var scale = baseAxis.scale;\n    var extent = scale.getExtent();\n    var tickNum = Math.max(0, extent[0]);\n    var tickMax = Math.min(extent[1], scale.getOrdinalMeta().categories.length - 1);\n    for (; tickNum <= tickMax; ++tickNum) {\n      if (orderInfo.ordinalNumbers[tickNum] !== scale.getRawOrdinalNumber(tickNum)) {\n        return true;\n      }\n    }\n  };\n  BarView.prototype._updateSortWithinSameData = function (data, orderMapping, baseAxis, api) {\n    if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {\n      return;\n    }\n    var sortInfo = this._dataSort(data, baseAxis, orderMapping);\n    if (this._isOrderDifferentInView(sortInfo, baseAxis)) {\n      this._removeOnRenderedListener(api);\n      api.dispatchAction({\n        type: 'changeAxisOrder',\n        componentType: baseAxis.dim + 'Axis',\n        axisId: baseAxis.index,\n        sortInfo: sortInfo\n      });\n    }\n  };\n  BarView.prototype._dispatchInitSort = function (data, realtimeSortCfg, api) {\n    var baseAxis = realtimeSortCfg.baseAxis;\n    var sortResult = this._dataSort(data, baseAxis, function (dataIdx) {\n      return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);\n    });\n    api.dispatchAction({\n      type: 'changeAxisOrder',\n      componentType: baseAxis.dim + 'Axis',\n      isInitSort: true,\n      axisId: baseAxis.index,\n      sortInfo: sortResult\n    });\n  };\n  BarView.prototype.remove = function (ecModel, api) {\n    this._clear(this._model);\n    this._removeOnRenderedListener(api);\n  };\n  BarView.prototype.dispose = function (ecModel, api) {\n    this._removeOnRenderedListener(api);\n  };\n  BarView.prototype._removeOnRenderedListener = function (api) {\n    if (this._onRendered) {\n      api.getZr().off('rendered', this._onRendered);\n      this._onRendered = null;\n    }\n  };\n  BarView.prototype._clear = function (model) {\n    var group = this.group;\n    var data = this._data;\n    if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {\n      this._removeBackground();\n      this._backgroundEls = [];\n      data.eachItemGraphicEl(function (el) {\n        (0,_util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .removeElementWithFadeOut */ .t5)(el, model, (0,_util_innerStore_js__WEBPACK_IMPORTED_MODULE_8__/* .getECData */ .z)(el).dataIndex);\n      });\n    } else {\n      group.removeAll();\n    }\n    this._data = null;\n    this._isFirstFrame = true;\n  };\n  BarView.prototype._removeBackground = function () {\n    this.group.remove(this._backgroundGroup);\n    this._backgroundGroup = null;\n  };\n  BarView.type = 'bar';\n  return BarView;\n}(_view_Chart_js__WEBPACK_IMPORTED_MODULE_9__/* [\"default\"] */ .A);\nvar clip = {\n  cartesian2d: function (coordSysBoundingRect, layout) {\n    var signWidth = layout.width < 0 ? -1 : 1;\n    var signHeight = layout.height < 0 ? -1 : 1;\n    // Needs positive width and height\n    if (signWidth < 0) {\n      layout.x += layout.width;\n      layout.width = -layout.width;\n    }\n    if (signHeight < 0) {\n      layout.y += layout.height;\n      layout.height = -layout.height;\n    }\n    var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;\n    var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;\n    var x = mathMax(layout.x, coordSysBoundingRect.x);\n    var x2 = mathMin(layout.x + layout.width, coordSysX2);\n    var y = mathMax(layout.y, coordSysBoundingRect.y);\n    var y2 = mathMin(layout.y + layout.height, coordSysY2);\n    var xClipped = x2 < x;\n    var yClipped = y2 < y;\n    // When xClipped or yClipped, the element will be marked as `ignore`.\n    // But we should also place the element at the edge of the coord sys bounding rect.\n    // Because if data changed and the bar shows again, its transition animation\n    // will begin at this place.\n    layout.x = xClipped && x > coordSysX2 ? x2 : x;\n    layout.y = yClipped && y > coordSysY2 ? y2 : y;\n    layout.width = xClipped ? 0 : x2 - x;\n    layout.height = yClipped ? 0 : y2 - y;\n    // Reverse back\n    if (signWidth < 0) {\n      layout.x += layout.width;\n      layout.width = -layout.width;\n    }\n    if (signHeight < 0) {\n      layout.y += layout.height;\n      layout.height = -layout.height;\n    }\n    return xClipped || yClipped;\n  },\n  polar: function (coordSysClipArea, layout) {\n    var signR = layout.r0 <= layout.r ? 1 : -1;\n    // Make sure r is larger than r0\n    if (signR < 0) {\n      var tmp = layout.r;\n      layout.r = layout.r0;\n      layout.r0 = tmp;\n    }\n    var r = mathMin(layout.r, coordSysClipArea.r);\n    var r0 = mathMax(layout.r0, coordSysClipArea.r0);\n    layout.r = r;\n    layout.r0 = r0;\n    var clipped = r - r0 < 0;\n    // Reverse back\n    if (signR < 0) {\n      var tmp = layout.r;\n      layout.r = layout.r0;\n      layout.r0 = tmp;\n    }\n    return clipped;\n  }\n};\nvar elementCreator = {\n  cartesian2d: function (seriesModel, data, newIndex, layout, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {\n    var rect = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_10__/* [\"default\"] */ .A({\n      shape: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_7__.extend)({}, layout),\n      z2: 1\n    });\n    rect.__dataIndex = newIndex;\n    rect.name = 'item';\n    if (animationModel) {\n      var rectShape = rect.shape;\n      var animateProperty = isHorizontal ? 'height' : 'width';\n      rectShape[animateProperty] = 0;\n    }\n    return rect;\n  },\n  polar: function (seriesModel, data, newIndex, layout, isRadial, animationModel, axisModel, isUpdate, roundCap) {\n    var ShapeClass = !isRadial && roundCap ? _util_shape_sausage_js__WEBPACK_IMPORTED_MODULE_11__/* [\"default\"] */ .A : _util_graphic_js__WEBPACK_IMPORTED_MODULE_12__/* [\"default\"] */ .A;\n    var sector = new ShapeClass({\n      shape: layout,\n      z2: 1\n    });\n    sector.name = 'item';\n    var positionMap = createPolarPositionMapping(isRadial);\n    sector.calculateTextPosition = (0,_label_sectorLabel_js__WEBPACK_IMPORTED_MODULE_13__/* .createSectorCalculateTextPosition */ .r)(positionMap, {\n      isRoundCap: ShapeClass === _util_shape_sausage_js__WEBPACK_IMPORTED_MODULE_11__/* [\"default\"] */ .A\n    });\n    // Animation\n    if (animationModel) {\n      var sectorShape = sector.shape;\n      var animateProperty = isRadial ? 'r' : 'endAngle';\n      var animateTarget = {};\n      sectorShape[animateProperty] = isRadial ? layout.r0 : layout.startAngle;\n      animateTarget[animateProperty] = layout[animateProperty];\n      (isUpdate ? _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .updateProps */ .oi : _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .initProps */ .LW)(sector, {\n        shape: animateTarget\n        // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue\n      }, animationModel);\n    }\n    return sector;\n  }\n};\nfunction shouldRealtimeSort(seriesModel, coordSys) {\n  var realtimeSortOption = seriesModel.get('realtimeSort', true);\n  var baseAxis = coordSys.getBaseAxis();\n  if (false) {}\n  if (realtimeSortOption && baseAxis.type === 'category' && coordSys.type === 'cartesian2d') {\n    return {\n      baseAxis: baseAxis,\n      otherAxis: coordSys.getOtherAxis(baseAxis)\n    };\n  }\n}\nfunction updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout, newIndex, isHorizontal, isUpdate, isChangeOrder) {\n  var seriesTarget;\n  var axisTarget;\n  if (isHorizontal) {\n    axisTarget = {\n      x: layout.x,\n      width: layout.width\n    };\n    seriesTarget = {\n      y: layout.y,\n      height: layout.height\n    };\n  } else {\n    axisTarget = {\n      y: layout.y,\n      height: layout.height\n    };\n    seriesTarget = {\n      x: layout.x,\n      width: layout.width\n    };\n  }\n  if (!isChangeOrder) {\n    // Keep the original growth animation if only axis order changed.\n    // Not start a new animation.\n    (isUpdate ? _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .updateProps */ .oi : _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .initProps */ .LW)(el, {\n      shape: seriesTarget\n    }, seriesAnimationModel, newIndex, null);\n  }\n  var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;\n  (isUpdate ? _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .updateProps */ .oi : _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* .initProps */ .LW)(el, {\n    shape: axisTarget\n  }, axisAnimationModel, newIndex);\n}\nfunction checkPropertiesNotValid(obj, props) {\n  for (var i = 0; i < props.length; i++) {\n    if (!isFinite(obj[props[i]])) {\n      return true;\n    }\n  }\n  return false;\n}\nvar rectPropties = ['x', 'y', 'width', 'height'];\nvar polarPropties = ['cx', 'cy', 'r', 'startAngle', 'endAngle'];\nvar isValidLayout = {\n  cartesian2d: function (layout) {\n    return !checkPropertiesNotValid(layout, rectPropties);\n  },\n  polar: function (layout) {\n    return !checkPropertiesNotValid(layout, polarPropties);\n  }\n};\nvar getLayout = {\n  // itemModel is only used to get borderWidth, which is not needed\n  // when calculating bar background layout.\n  cartesian2d: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0;\n    // fix layout with lineWidth\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n    return {\n      x: layout.x + signX * fixedLineWidth / 2,\n      y: layout.y + signY * fixedLineWidth / 2,\n      width: layout.width - signX * fixedLineWidth,\n      height: layout.height - signY * fixedLineWidth\n    };\n  },\n  polar: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    return {\n      cx: layout.cx,\n      cy: layout.cy,\n      r0: layout.r0,\n      r: layout.r,\n      startAngle: layout.startAngle,\n      endAngle: layout.endAngle,\n      clockwise: layout.clockwise\n    };\n  }\n};\nfunction isZeroOnPolar(layout) {\n  return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle;\n}\nfunction createPolarPositionMapping(isRadial) {\n  return function (isRadial) {\n    var arcOrAngle = isRadial ? 'Arc' : 'Angle';\n    return function (position) {\n      switch (position) {\n        case 'start':\n        case 'insideStart':\n        case 'end':\n        case 'insideEnd':\n          return position + arcOrAngle;\n        default:\n          return position;\n      }\n    };\n  }(isRadial);\n}\nfunction updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, isPolar) {\n  var style = data.getItemVisual(dataIndex, 'style');\n  if (!isPolar) {\n    var borderRadius = itemModel.get(['itemStyle', 'borderRadius']) || 0;\n    el.setShape('r', borderRadius);\n  } else if (!seriesModel.get('roundCap')) {\n    var sectorShape = el.shape;\n    var cornerRadius = (0,_helper_sectorHelper_js__WEBPACK_IMPORTED_MODULE_14__/* .getSectorCornerRadius */ .i)(itemModel.getModel('itemStyle'), sectorShape, true);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_7__.extend)(sectorShape, cornerRadius);\n    el.setShape(sectorShape);\n  }\n  el.useStyle(style);\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && el.attr('cursor', cursorStyle);\n  var labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout.r >= layout.r0 ? 'endArc' : 'startArc' : layout.endAngle >= layout.startAngle ? 'endAngle' : 'startAngle' : isHorizontalOrRadial ? layout.height >= 0 ? 'bottom' : 'top' : layout.width >= 0 ? 'right' : 'left';\n  var labelStatesModels = (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_4__/* .getLabelStatesModels */ .lx)(itemModel);\n  (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_4__/* .setLabelStyle */ .qM)(el, labelStatesModels, {\n    labelFetcher: seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: (0,_helper_labelHelper_js__WEBPACK_IMPORTED_MODULE_15__/* .getDefaultLabel */ .i)(seriesModel.getData(), dataIndex),\n    inheritColor: style.fill,\n    defaultOpacity: style.opacity,\n    defaultOutsidePosition: labelPositionOutside\n  });\n  var label = el.getTextContent();\n  if (isPolar && label) {\n    var position = itemModel.get(['label', 'position']);\n    el.textConfig.inside = position === 'middle' ? true : null;\n    (0,_label_sectorLabel_js__WEBPACK_IMPORTED_MODULE_13__/* .setSectorTextRotation */ .W)(el, position === 'outside' ? labelPositionOutside : position, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(['label', 'rotate']));\n  }\n  (0,_label_labelStyle_js__WEBPACK_IMPORTED_MODULE_4__/* .setLabelValueAnimation */ .Oh)(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function (value) {\n    return (0,_helper_labelHelper_js__WEBPACK_IMPORTED_MODULE_15__/* .getDefaultInterpolatedLabel */ .T)(data, value);\n  });\n  var emphasisModel = itemModel.getModel(['emphasis']);\n  (0,_util_states_js__WEBPACK_IMPORTED_MODULE_16__/* .toggleHoverEmphasis */ .Lm)(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n  (0,_util_states_js__WEBPACK_IMPORTED_MODULE_16__/* .setStatesStylesFromModel */ .Mx)(el, itemModel);\n  if (isZeroOnPolar(layout)) {\n    el.style.fill = 'none';\n    el.style.stroke = 'none';\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_7__.each)(el.states, function (state) {\n      if (state.style) {\n        state.style.fill = state.style.stroke = 'none';\n      }\n    });\n  }\n}\n// In case width or height are too small.\nfunction getLineWidth(itemModel, rawLayout) {\n  // Has no border.\n  var borderColor = itemModel.get(['itemStyle', 'borderColor']);\n  if (!borderColor || borderColor === 'none') {\n    return 0;\n  }\n  var lineWidth = itemModel.get(['itemStyle', 'borderWidth']) || 0;\n  // width or height may be NaN for empty data\n  var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);\n  var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);\n  return Math.min(lineWidth, width, height);\n}\nvar LagePathShape = /** @class */function () {\n  function LagePathShape() {}\n  return LagePathShape;\n}();\nvar LargePath = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .C6)(LargePath, _super);\n  function LargePath(opts) {\n    var _this = _super.call(this, opts) || this;\n    _this.type = 'largeBar';\n    return _this;\n  }\n  LargePath.prototype.getDefaultShape = function () {\n    return new LagePathShape();\n  };\n  LargePath.prototype.buildPath = function (ctx, shape) {\n    // Drawing lines is more efficient than drawing\n    // a whole line or drawing rects.\n    var points = shape.points;\n    var baseDimIdx = this.baseDimIdx;\n    var valueDimIdx = 1 - this.baseDimIdx;\n    var startPoint = [];\n    var size = [];\n    var barWidth = this.barWidth;\n    for (var i = 0; i < points.length; i += 3) {\n      size[baseDimIdx] = barWidth;\n      size[valueDimIdx] = points[i + 2];\n      startPoint[baseDimIdx] = points[i + baseDimIdx];\n      startPoint[valueDimIdx] = points[i + valueDimIdx];\n      ctx.rect(startPoint[0], startPoint[1], size[0], size[1]);\n    }\n  };\n  return LargePath;\n}(zrender_lib_graphic_Path_js__WEBPACK_IMPORTED_MODULE_17__/* [\"default\"] */ .Ay);\nfunction createLarge(seriesModel, group, progressiveEls, incremental) {\n  // TODO support polar\n  var data = seriesModel.getData();\n  var baseDimIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;\n  var largeDataIndices = data.getLayout('largeDataIndices');\n  var barWidth = data.getLayout('size');\n  var backgroundModel = seriesModel.getModel('backgroundStyle');\n  var bgPoints = data.getLayout('largeBackgroundPoints');\n  if (bgPoints) {\n    var bgEl = new LargePath({\n      shape: {\n        points: bgPoints\n      },\n      incremental: !!incremental,\n      silent: true,\n      z2: 0\n    });\n    bgEl.baseDimIdx = baseDimIdx;\n    bgEl.largeDataIndices = largeDataIndices;\n    bgEl.barWidth = barWidth;\n    bgEl.useStyle(backgroundModel.getItemStyle());\n    group.add(bgEl);\n    progressiveEls && progressiveEls.push(bgEl);\n  }\n  var el = new LargePath({\n    shape: {\n      points: data.getLayout('largePoints')\n    },\n    incremental: !!incremental,\n    ignoreCoarsePointer: true,\n    z2: 1\n  });\n  el.baseDimIdx = baseDimIdx;\n  el.largeDataIndices = largeDataIndices;\n  el.barWidth = barWidth;\n  group.add(el);\n  el.useStyle(data.getVisual('style'));\n  // Stroke is rendered first to avoid overlapping with fill\n  el.style.stroke = null;\n  // Enable tooltip and user mouse/touch event handlers.\n  (0,_util_innerStore_js__WEBPACK_IMPORTED_MODULE_8__/* .getECData */ .z)(el).seriesIndex = seriesModel.seriesIndex;\n  if (!seriesModel.get('silent')) {\n    el.on('mousedown', largePathUpdateDataIndex);\n    el.on('mousemove', largePathUpdateDataIndex);\n  }\n  progressiveEls && progressiveEls.push(el);\n}\n// Use throttle to avoid frequently traverse to find dataIndex.\nvar largePathUpdateDataIndex = (0,_util_throttle_js__WEBPACK_IMPORTED_MODULE_18__/* .throttle */ .nF)(function (event) {\n  var largePath = this;\n  var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);\n  (0,_util_innerStore_js__WEBPACK_IMPORTED_MODULE_8__/* .getECData */ .z)(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;\n}, 30, false);\nfunction largePathFindDataIndex(largePath, x, y) {\n  var baseDimIdx = largePath.baseDimIdx;\n  var valueDimIdx = 1 - baseDimIdx;\n  var points = largePath.shape.points;\n  var largeDataIndices = largePath.largeDataIndices;\n  var startPoint = [];\n  var size = [];\n  var barWidth = largePath.barWidth;\n  for (var i = 0, len = points.length / 3; i < len; i++) {\n    var ii = i * 3;\n    size[baseDimIdx] = barWidth;\n    size[valueDimIdx] = points[ii + 2];\n    startPoint[baseDimIdx] = points[ii + baseDimIdx];\n    startPoint[valueDimIdx] = points[ii + valueDimIdx];\n    if (size[valueDimIdx] < 0) {\n      startPoint[valueDimIdx] += size[valueDimIdx];\n      size[valueDimIdx] = -size[valueDimIdx];\n    }\n    if (x >= startPoint[0] && x <= startPoint[0] + size[0] && y >= startPoint[1] && y <= startPoint[1] + size[1]) {\n      return largeDataIndices[i];\n    }\n  }\n  return -1;\n}\nfunction createBackgroundShape(isHorizontalOrRadial, layout, coord) {\n  if ((0,_coord_CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__/* .isCoordinateSystemType */ .g)(coord, 'cartesian2d')) {\n    var rectShape = layout;\n    var coordLayout = coord.getArea();\n    return {\n      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,\n      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,\n      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,\n      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height\n    };\n  } else {\n    var coordLayout = coord.getArea();\n    var sectorShape = layout;\n    return {\n      cx: coordLayout.cx,\n      cy: coordLayout.cy,\n      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,\n      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,\n      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,\n      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2\n    };\n  }\n}\nfunction createBackgroundEl(coord, isHorizontalOrRadial, layout) {\n  var ElementClz = coord.type === 'polar' ? _util_graphic_js__WEBPACK_IMPORTED_MODULE_12__/* [\"default\"] */ .A : _util_graphic_js__WEBPACK_IMPORTED_MODULE_10__/* [\"default\"] */ .A;\n  return new ElementClz({\n    shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),\n    silent: true,\n    z2: 0\n  });\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BarView);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA4NTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXJWaWV3LmpzPzRhMzUiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBQYXRoIGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qcyc7XG5pbXBvcnQgR3JvdXAgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9Hcm91cC5qcyc7XG5pbXBvcnQgeyBleHRlbmQsIGVhY2gsIG1hcCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBSZWN0LCBTZWN0b3IsIHVwZGF0ZVByb3BzLCBpbml0UHJvcHMsIHJlbW92ZUVsZW1lbnRXaXRoRmFkZU91dCwgdHJhdmVyc2VFbGVtZW50cyB9IGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBnZXRFQ0RhdGEgfSBmcm9tICcuLi8uLi91dGlsL2lubmVyU3RvcmUuanMnO1xuaW1wb3J0IHsgc2V0U3RhdGVzU3R5bGVzRnJvbU1vZGVsLCB0b2dnbGVIb3ZlckVtcGhhc2lzIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMuanMnO1xuaW1wb3J0IHsgc2V0TGFiZWxTdHlsZSwgZ2V0TGFiZWxTdGF0ZXNNb2RlbHMsIHNldExhYmVsVmFsdWVBbmltYXRpb24sIGxhYmVsSW5uZXIgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlLmpzJztcbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnLi4vLi4vdXRpbC90aHJvdHRsZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDbGlwUGF0aCB9IGZyb20gJy4uL2hlbHBlci9jcmVhdGVDbGlwUGF0aEZyb21Db29yZFN5cy5qcyc7XG5pbXBvcnQgU2F1c2FnZSBmcm9tICcuLi8uLi91dGlsL3NoYXBlL3NhdXNhZ2UuanMnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0LmpzJztcbmltcG9ydCB7IGlzQ29vcmRpbmF0ZVN5c3RlbVR5cGUgfSBmcm9tICcuLi8uLi9jb29yZC9Db29yZGluYXRlU3lzdGVtLmpzJztcbmltcG9ydCB7IGdldERlZmF1bHRMYWJlbCwgZ2V0RGVmYXVsdEludGVycG9sYXRlZExhYmVsIH0gZnJvbSAnLi4vaGVscGVyL2xhYmVsSGVscGVyLmpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi91dGlsL2xvZy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTZWN0b3JDYWxjdWxhdGVUZXh0UG9zaXRpb24sIHNldFNlY3RvclRleHRSb3RhdGlvbiB9IGZyb20gJy4uLy4uL2xhYmVsL3NlY3RvckxhYmVsLmpzJztcbmltcG9ydCB7IHNhdmVPbGRTdHlsZSB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi9iYXNpY1RyYW5zaXRpb24uanMnO1xuaW1wb3J0IHsgZ2V0U2VjdG9yQ29ybmVyUmFkaXVzIH0gZnJvbSAnLi4vaGVscGVyL3NlY3RvckhlbHBlci5qcyc7XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbmZ1bmN0aW9uIGdldENsaXBBcmVhKGNvb3JkLCBkYXRhKSB7XG4gIHZhciBjb29yZFN5c0NsaXBBcmVhID0gY29vcmQuZ2V0QXJlYSAmJiBjb29yZC5nZXRBcmVhKCk7XG4gIGlmIChpc0Nvb3JkaW5hdGVTeXN0ZW1UeXBlKGNvb3JkLCAnY2FydGVzaWFuMmQnKSkge1xuICAgIHZhciBiYXNlQXhpcyA9IGNvb3JkLmdldEJhc2VBeGlzKCk7XG4gICAgLy8gV2hlbiBib3VuZGFyeUdhcCBpcyBmYWxzZSBvciB1c2luZyB0aW1lIGF4aXMuIGJhciBtYXkgZXhjZWVkIHRoZSBncmlkLlxuICAgIC8vIFdlIHNob3VsZCBub3QgY2xpcCB0aGlzIHBhcnQuXG4gICAgLy8gU2VlIHRlc3QvYmFyMi5odG1sXG4gICAgaWYgKGJhc2VBeGlzLnR5cGUgIT09ICdjYXRlZ29yeScgfHwgIWJhc2VBeGlzLm9uQmFuZCkge1xuICAgICAgdmFyIGV4cGFuZFdpZHRoID0gZGF0YS5nZXRMYXlvdXQoJ2JhbmRXaWR0aCcpO1xuICAgICAgaWYgKGJhc2VBeGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgIGNvb3JkU3lzQ2xpcEFyZWEueCAtPSBleHBhbmRXaWR0aDtcbiAgICAgICAgY29vcmRTeXNDbGlwQXJlYS53aWR0aCArPSBleHBhbmRXaWR0aCAqIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb29yZFN5c0NsaXBBcmVhLnkgLT0gZXhwYW5kV2lkdGg7XG4gICAgICAgIGNvb3JkU3lzQ2xpcEFyZWEuaGVpZ2h0ICs9IGV4cGFuZFdpZHRoICogMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvb3JkU3lzQ2xpcEFyZWE7XG59XG52YXIgQmFyVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhCYXJWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBCYXJWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IEJhclZpZXcudHlwZTtcbiAgICBfdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgQmFyVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB0aGlzLl9tb2RlbCA9IHNlcmllc01vZGVsO1xuICAgIHRoaXMuX3JlbW92ZU9uUmVuZGVyZWRMaXN0ZW5lcihhcGkpO1xuICAgIHRoaXMuX3VwZGF0ZURyYXdNb2RlKHNlcmllc01vZGVsKTtcbiAgICB2YXIgY29vcmRpbmF0ZVN5c3RlbVR5cGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKTtcbiAgICBpZiAoY29vcmRpbmF0ZVN5c3RlbVR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgfHwgY29vcmRpbmF0ZVN5c3RlbVR5cGUgPT09ICdwb2xhcicpIHtcbiAgICAgIC8vIENsZWFyIHByZXZpb3VzbHkgcmVuZGVyZWQgcHJvZ3Jlc3NpdmUgZWxlbWVudHMuXG4gICAgICB0aGlzLl9wcm9ncmVzc2l2ZUVscyA9IG51bGw7XG4gICAgICB0aGlzLl9pc0xhcmdlRHJhdyA/IHRoaXMuX3JlbmRlckxhcmdlKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIDogdGhpcy5fcmVuZGVyTm9ybWFsKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybignT25seSBjYXJ0ZXNpYW4yZCBhbmQgcG9sYXIgc3VwcG9ydGVkIGZvciBiYXIuJyk7XG4gICAgfVxuICB9O1xuICBCYXJWaWV3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFByZXBhcmVSZW5kZXIgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB0aGlzLl9jbGVhcigpO1xuICAgIHRoaXMuX3VwZGF0ZURyYXdNb2RlKHNlcmllc01vZGVsKTtcbiAgICAvLyBpbmNyZW1lbnRhbCBhbHNvIG5lZWQgdG8gY2xpcCwgb3RoZXJ3aXNlIG1pZ2h0IGJlIG92ZXJsb3cuXG4gICAgLy8gQnV0IG11c3Qgbm90IHNldCBjbGlwIGluIGVhY2ggZnJhbWUsIG90aGVyd2lzZSBhbGwgb2YgdGhlIGNoaWxkcmVuIHdpbGwgYmUgbWFya2VkIHJlZHJhdy5cbiAgICB0aGlzLl91cGRhdGVMYXJnZUNsaXAoc2VyaWVzTW9kZWwpO1xuICB9O1xuICBCYXJWaWV3LnByb3RvdHlwZS5pbmNyZW1lbnRhbFJlbmRlciA9IGZ1bmN0aW9uIChwYXJhbXMsIHNlcmllc01vZGVsKSB7XG4gICAgLy8gUmVzZXRcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZUVscyA9IFtdO1xuICAgIC8vIERvIG5vdCBzdXBwb3J0IHByb2dyZXNzaXZlIGluIG5vcm1hbCBtb2RlLlxuICAgIHRoaXMuX2luY3JlbWVudGFsUmVuZGVyTGFyZ2UocGFyYW1zLCBzZXJpZXNNb2RlbCk7XG4gIH07XG4gIEJhclZpZXcucHJvdG90eXBlLmVhY2hSZW5kZXJlZCA9IGZ1bmN0aW9uIChjYikge1xuICAgIHRyYXZlcnNlRWxlbWVudHModGhpcy5fcHJvZ3Jlc3NpdmVFbHMgfHwgdGhpcy5ncm91cCwgY2IpO1xuICB9O1xuICBCYXJWaWV3LnByb3RvdHlwZS5fdXBkYXRlRHJhd01vZGUgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgaXNMYXJnZURyYXcgPSBzZXJpZXNNb2RlbC5waXBlbGluZUNvbnRleHQubGFyZ2U7XG4gICAgaWYgKHRoaXMuX2lzTGFyZ2VEcmF3ID09IG51bGwgfHwgaXNMYXJnZURyYXcgIT09IHRoaXMuX2lzTGFyZ2VEcmF3KSB7XG4gICAgICB0aGlzLl9pc0xhcmdlRHJhdyA9IGlzTGFyZ2VEcmF3O1xuICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICB9XG4gIH07XG4gIEJhclZpZXcucHJvdG90eXBlLl9yZW5kZXJOb3JtYWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBjb29yZCA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGJhc2VBeGlzID0gY29vcmQuZ2V0QmFzZUF4aXMoKTtcbiAgICB2YXIgaXNIb3Jpem9udGFsT3JSYWRpYWw7XG4gICAgaWYgKGNvb3JkLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgIGlzSG9yaXpvbnRhbE9yUmFkaWFsID0gYmFzZUF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgfSBlbHNlIGlmIChjb29yZC50eXBlID09PSAncG9sYXInKSB7XG4gICAgICBpc0hvcml6b250YWxPclJhZGlhbCA9IGJhc2VBeGlzLmRpbSA9PT0gJ2FuZ2xlJztcbiAgICB9XG4gICAgdmFyIGFuaW1hdGlvbk1vZGVsID0gc2VyaWVzTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCkgPyBzZXJpZXNNb2RlbCA6IG51bGw7XG4gICAgdmFyIHJlYWx0aW1lU29ydENmZyA9IHNob3VsZFJlYWx0aW1lU29ydChzZXJpZXNNb2RlbCwgY29vcmQpO1xuICAgIGlmIChyZWFsdGltZVNvcnRDZmcpIHtcbiAgICAgIHRoaXMuX2VuYWJsZVJlYWx0aW1lU29ydChyZWFsdGltZVNvcnRDZmcsIGRhdGEsIGFwaSk7XG4gICAgfVxuICAgIHZhciBuZWVkc0NsaXAgPSBzZXJpZXNNb2RlbC5nZXQoJ2NsaXAnLCB0cnVlKSB8fCByZWFsdGltZVNvcnRDZmc7XG4gICAgdmFyIGNvb3JkU3lzQ2xpcEFyZWEgPSBnZXRDbGlwQXJlYShjb29yZCwgZGF0YSk7XG4gICAgLy8gSWYgdGhlcmUgaXMgY2xpcFBhdGggY3JlYXRlZCBpbiBsYXJnZSBtb2RlLiBSZW1vdmUgaXQuXG4gICAgZ3JvdXAucmVtb3ZlQ2xpcFBhdGgoKTtcbiAgICAvLyBXZSBkb24ndCB1c2UgY2xpcFBhdGggaW4gbm9ybWFsIG1vZGUgYmVjYXVzZSB3ZSBuZWVkcyBhIHBlcmZlY3QgYW5pbWF0aW9uXG4gICAgLy8gQW5kIGRvbid0IHdhbnQgdGhlIGxhYmVsIGFyZSBjbGlwcGVkLlxuICAgIHZhciByb3VuZENhcCA9IHNlcmllc01vZGVsLmdldCgncm91bmRDYXAnLCB0cnVlKTtcbiAgICB2YXIgZHJhd0JhY2tncm91bmQgPSBzZXJpZXNNb2RlbC5nZXQoJ3Nob3dCYWNrZ3JvdW5kJywgdHJ1ZSk7XG4gICAgdmFyIGJhY2tncm91bmRNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdiYWNrZ3JvdW5kU3R5bGUnKTtcbiAgICB2YXIgYmFyQm9yZGVyUmFkaXVzID0gYmFja2dyb3VuZE1vZGVsLmdldCgnYm9yZGVyUmFkaXVzJykgfHwgMDtcbiAgICB2YXIgYmdFbHMgPSBbXTtcbiAgICB2YXIgb2xkQmdFbHMgPSB0aGlzLl9iYWNrZ3JvdW5kRWxzO1xuICAgIHZhciBpc0luaXRTb3J0ID0gcGF5bG9hZCAmJiBwYXlsb2FkLmlzSW5pdFNvcnQ7XG4gICAgdmFyIGlzQ2hhbmdlT3JkZXIgPSBwYXlsb2FkICYmIHBheWxvYWQudHlwZSA9PT0gJ2NoYW5nZUF4aXNPcmRlcic7XG4gICAgZnVuY3Rpb24gY3JlYXRlQmFja2dyb3VuZChkYXRhSW5kZXgpIHtcbiAgICAgIHZhciBiZ0xheW91dCA9IGdldExheW91dFtjb29yZC50eXBlXShkYXRhLCBkYXRhSW5kZXgpO1xuICAgICAgdmFyIGJnRWwgPSBjcmVhdGVCYWNrZ3JvdW5kRWwoY29vcmQsIGlzSG9yaXpvbnRhbE9yUmFkaWFsLCBiZ0xheW91dCk7XG4gICAgICBiZ0VsLnVzZVN0eWxlKGJhY2tncm91bmRNb2RlbC5nZXRJdGVtU3R5bGUoKSk7XG4gICAgICAvLyBPbmx5IGNhcnRlc2lhbjJkIHN1cHBvcnQgYm9yZGVyUmFkaXVzLlxuICAgICAgaWYgKGNvb3JkLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgICAgYmdFbC5zZXRTaGFwZSgncicsIGJhckJvcmRlclJhZGl1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZ0VsLnNldFNoYXBlKCdjb3JuZXJSYWRpdXMnLCBiYXJCb3JkZXJSYWRpdXMpO1xuICAgICAgfVxuICAgICAgYmdFbHNbZGF0YUluZGV4XSA9IGJnRWw7XG4gICAgICByZXR1cm4gYmdFbDtcbiAgICB9XG4gICAgO1xuICAgIGRhdGEuZGlmZihvbGREYXRhKS5hZGQoZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG4gICAgICB2YXIgbGF5b3V0ID0gZ2V0TGF5b3V0W2Nvb3JkLnR5cGVdKGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsKTtcbiAgICAgIGlmIChkcmF3QmFja2dyb3VuZCkge1xuICAgICAgICBjcmVhdGVCYWNrZ3JvdW5kKGRhdGFJbmRleCk7XG4gICAgICB9XG4gICAgICAvLyBJZiBkYXRhWm9vbSBpbiBmaWx0ZU1vZGU6ICdlbXB0eScsIHRoZSBiYXNlVmFsdWUgY2FuIGJlIHNldCBhcyBOYU4gaW4gXCJheGlzUHJveHlcIi5cbiAgICAgIGlmICghZGF0YS5oYXNWYWx1ZShkYXRhSW5kZXgpIHx8ICFpc1ZhbGlkTGF5b3V0W2Nvb3JkLnR5cGVdKGxheW91dCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGlzQ2xpcHBlZCA9IGZhbHNlO1xuICAgICAgaWYgKG5lZWRzQ2xpcCkge1xuICAgICAgICAvLyBDbGlwIHdpbGwgbW9kaWZ5IHRoZSBsYXlvdXQgcGFyYW1zLlxuICAgICAgICAvLyBBbmQgcmV0dXJuIGEgYm9vbGVhbiB0byBkZXRlcm1pbmUgaWYgdGhlIHNoYXBlIGFyZSBmdWxseSBjbGlwcGVkLlxuICAgICAgICBpc0NsaXBwZWQgPSBjbGlwW2Nvb3JkLnR5cGVdKGNvb3JkU3lzQ2xpcEFyZWEsIGxheW91dCk7XG4gICAgICB9XG4gICAgICB2YXIgZWwgPSBlbGVtZW50Q3JlYXRvcltjb29yZC50eXBlXShzZXJpZXNNb2RlbCwgZGF0YSwgZGF0YUluZGV4LCBsYXlvdXQsIGlzSG9yaXpvbnRhbE9yUmFkaWFsLCBhbmltYXRpb25Nb2RlbCwgYmFzZUF4aXMubW9kZWwsIGZhbHNlLCByb3VuZENhcCk7XG4gICAgICBpZiAocmVhbHRpbWVTb3J0Q2ZnKSB7XG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZvcmNlIGxhYmVsIGFuaW1hdGlvbiBiZWNhdXNlIGV2ZW4gaWYgdGhlIGVsZW1lbnQgaXNcclxuICAgICAgICAgKiBpZ25vcmVkIGJlY2F1c2UgaXQncyBjbGlwcGVkLCBpdCBtYXkgbm90IGJlIGNsaXBwZWQgYWZ0ZXJcclxuICAgICAgICAgKiBjaGFuZ2luZyBvcmRlci4gVGhlbiwgaWYgbm90IHVzaW5nIGZvcmNlTGFiZWxBbmltYXRpb24sXHJcbiAgICAgICAgICogdGhlIGxhYmVsIGFuaW1hdGlvbiB3YXMgbmV2ZXIgc3RhcnRlZCwgaW4gd2hpY2ggY2FzZSxcclxuICAgICAgICAgKiB0aGUgbGFiZWwgd2lsbCBiZSB0aGUgZmluYWwgdmFsdWUgYW5kIGRvZXNuJ3QgaGF2ZSBsYWJlbFxyXG4gICAgICAgICAqIGFuaW1hdGlvbi5cclxuICAgICAgICAgKi9cbiAgICAgICAgZWwuZm9yY2VMYWJlbEFuaW1hdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICB1cGRhdGVTdHlsZShlbCwgZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgc2VyaWVzTW9kZWwsIGlzSG9yaXpvbnRhbE9yUmFkaWFsLCBjb29yZC50eXBlID09PSAncG9sYXInKTtcbiAgICAgIGlmIChpc0luaXRTb3J0KSB7XG4gICAgICAgIGVsLmF0dHIoe1xuICAgICAgICAgIHNoYXBlOiBsYXlvdXRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHJlYWx0aW1lU29ydENmZykge1xuICAgICAgICB1cGRhdGVSZWFsdGltZUFuaW1hdGlvbihyZWFsdGltZVNvcnRDZmcsIGFuaW1hdGlvbk1vZGVsLCBlbCwgbGF5b3V0LCBkYXRhSW5kZXgsIGlzSG9yaXpvbnRhbE9yUmFkaWFsLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdFByb3BzKGVsLCB7XG4gICAgICAgICAgc2hhcGU6IGxheW91dFxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgZGF0YUluZGV4KTtcbiAgICAgIH1cbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIGVsKTtcbiAgICAgIGdyb3VwLmFkZChlbCk7XG4gICAgICBlbC5pZ25vcmUgPSBpc0NsaXBwZWQ7XG4gICAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChuZXdJbmRleCk7XG4gICAgICB2YXIgbGF5b3V0ID0gZ2V0TGF5b3V0W2Nvb3JkLnR5cGVdKGRhdGEsIG5ld0luZGV4LCBpdGVtTW9kZWwpO1xuICAgICAgaWYgKGRyYXdCYWNrZ3JvdW5kKSB7XG4gICAgICAgIHZhciBiZ0VsID0gdm9pZCAwO1xuICAgICAgICBpZiAob2xkQmdFbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgYmdFbCA9IGNyZWF0ZUJhY2tncm91bmQob2xkSW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJnRWwgPSBvbGRCZ0Vsc1tvbGRJbmRleF07XG4gICAgICAgICAgYmdFbC51c2VTdHlsZShiYWNrZ3JvdW5kTW9kZWwuZ2V0SXRlbVN0eWxlKCkpO1xuICAgICAgICAgIC8vIE9ubHkgY2FydGVzaWFuMmQgc3VwcG9ydCBib3JkZXJSYWRpdXMuXG4gICAgICAgICAgaWYgKGNvb3JkLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgICAgICAgIGJnRWwuc2V0U2hhcGUoJ3InLCBiYXJCb3JkZXJSYWRpdXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZ0VsLnNldFNoYXBlKCdjb3JuZXJSYWRpdXMnLCBiYXJCb3JkZXJSYWRpdXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiZ0Vsc1tuZXdJbmRleF0gPSBiZ0VsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZ0xheW91dCA9IGdldExheW91dFtjb29yZC50eXBlXShkYXRhLCBuZXdJbmRleCk7XG4gICAgICAgIHZhciBzaGFwZSA9IGNyZWF0ZUJhY2tncm91bmRTaGFwZShpc0hvcml6b250YWxPclJhZGlhbCwgYmdMYXlvdXQsIGNvb3JkKTtcbiAgICAgICAgdXBkYXRlUHJvcHMoYmdFbCwge1xuICAgICAgICAgIHNoYXBlOiBzaGFwZVxuICAgICAgICB9LCBhbmltYXRpb25Nb2RlbCwgbmV3SW5kZXgpO1xuICAgICAgfVxuICAgICAgdmFyIGVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZEluZGV4KTtcbiAgICAgIGlmICghZGF0YS5oYXNWYWx1ZShuZXdJbmRleCkgfHwgIWlzVmFsaWRMYXlvdXRbY29vcmQudHlwZV0obGF5b3V0KSkge1xuICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaXNDbGlwcGVkID0gZmFsc2U7XG4gICAgICBpZiAobmVlZHNDbGlwKSB7XG4gICAgICAgIGlzQ2xpcHBlZCA9IGNsaXBbY29vcmQudHlwZV0oY29vcmRTeXNDbGlwQXJlYSwgbGF5b3V0KTtcbiAgICAgICAgaWYgKGlzQ2xpcHBlZCkge1xuICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZWwpIHtcbiAgICAgICAgZWwgPSBlbGVtZW50Q3JlYXRvcltjb29yZC50eXBlXShzZXJpZXNNb2RlbCwgZGF0YSwgbmV3SW5kZXgsIGxheW91dCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGFuaW1hdGlvbk1vZGVsLCBiYXNlQXhpcy5tb2RlbCwgISFlbCwgcm91bmRDYXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2F2ZU9sZFN0eWxlKGVsKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFsdGltZVNvcnRDZmcpIHtcbiAgICAgICAgZWwuZm9yY2VMYWJlbEFuaW1hdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNDaGFuZ2VPcmRlcikge1xuICAgICAgICB2YXIgdGV4dEVsID0gZWwuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgaWYgKHRleHRFbCkge1xuICAgICAgICAgIHZhciBsYWJlbElubmVyU3RvcmUgPSBsYWJlbElubmVyKHRleHRFbCk7XG4gICAgICAgICAgaWYgKGxhYmVsSW5uZXJTdG9yZS5wcmV2VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldCBwcmVWYWx1ZSB0byBiZSB2YWx1ZSBzbyB0aGF0IG5vIG5ldyBsYWJlbFxyXG4gICAgICAgICAgICAgKiBzaG91bGQgYmUgc3RhcnRlZCwgb3RoZXJ3aXNlLCBpdCB3aWxsIHRha2UgYSBmdWxsXHJcbiAgICAgICAgICAgICAqIGBhbmltYXRpb25EdXJhdGlvblVwZGF0ZWAgdGltZSB0byBmaW5pc2ggdGhlXHJcbiAgICAgICAgICAgICAqIGFuaW1hdGlvbiwgd2hpY2ggaXMgbm90IGV4cGVjdGVkLlxyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxhYmVsSW5uZXJTdG9yZS5wcmV2VmFsdWUgPSBsYWJlbElubmVyU3RvcmUudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBOb3QgY2hhbmdlIGFueXRoaW5nIGlmIG9ubHkgb3JkZXIgY2hhbmdlZC5cbiAgICAgIC8vIEVzcGVjaWFsbHkgbm90IGNoYW5nZSBsYWJlbC5cbiAgICAgIGVsc2Uge1xuICAgICAgICB1cGRhdGVTdHlsZShlbCwgZGF0YSwgbmV3SW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBzZXJpZXNNb2RlbCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGNvb3JkLnR5cGUgPT09ICdwb2xhcicpO1xuICAgICAgfVxuICAgICAgaWYgKGlzSW5pdFNvcnQpIHtcbiAgICAgICAgZWwuYXR0cih7XG4gICAgICAgICAgc2hhcGU6IGxheW91dFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocmVhbHRpbWVTb3J0Q2ZnKSB7XG4gICAgICAgIHVwZGF0ZVJlYWx0aW1lQW5pbWF0aW9uKHJlYWx0aW1lU29ydENmZywgYW5pbWF0aW9uTW9kZWwsIGVsLCBsYXlvdXQsIG5ld0luZGV4LCBpc0hvcml6b250YWxPclJhZGlhbCwgdHJ1ZSwgaXNDaGFuZ2VPcmRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVQcm9wcyhlbCwge1xuICAgICAgICAgIHNoYXBlOiBsYXlvdXRcbiAgICAgICAgfSwgc2VyaWVzTW9kZWwsIG5ld0luZGV4LCBudWxsKTtcbiAgICAgIH1cbiAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJbmRleCwgZWwpO1xuICAgICAgZWwuaWdub3JlID0gaXNDbGlwcGVkO1xuICAgICAgZ3JvdXAuYWRkKGVsKTtcbiAgICB9KS5yZW1vdmUoZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgdmFyIGVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCk7XG4gICAgICBlbCAmJiByZW1vdmVFbGVtZW50V2l0aEZhZGVPdXQoZWwsIHNlcmllc01vZGVsLCBkYXRhSW5kZXgpO1xuICAgIH0pLmV4ZWN1dGUoKTtcbiAgICB2YXIgYmdHcm91cCA9IHRoaXMuX2JhY2tncm91bmRHcm91cCB8fCAodGhpcy5fYmFja2dyb3VuZEdyb3VwID0gbmV3IEdyb3VwKCkpO1xuICAgIGJnR3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiZ0Vscy5sZW5ndGg7ICsraSkge1xuICAgICAgYmdHcm91cC5hZGQoYmdFbHNbaV0pO1xuICAgIH1cbiAgICBncm91cC5hZGQoYmdHcm91cCk7XG4gICAgdGhpcy5fYmFja2dyb3VuZEVscyA9IGJnRWxzO1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9O1xuICBCYXJWaWV3LnByb3RvdHlwZS5fcmVuZGVyTGFyZ2UgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgY3JlYXRlTGFyZ2Uoc2VyaWVzTW9kZWwsIHRoaXMuZ3JvdXApO1xuICAgIHRoaXMuX3VwZGF0ZUxhcmdlQ2xpcChzZXJpZXNNb2RlbCk7XG4gIH07XG4gIEJhclZpZXcucHJvdG90eXBlLl9pbmNyZW1lbnRhbFJlbmRlckxhcmdlID0gZnVuY3Rpb24gKHBhcmFtcywgc2VyaWVzTW9kZWwpIHtcbiAgICB0aGlzLl9yZW1vdmVCYWNrZ3JvdW5kKCk7XG4gICAgY3JlYXRlTGFyZ2Uoc2VyaWVzTW9kZWwsIHRoaXMuZ3JvdXAsIHRoaXMuX3Byb2dyZXNzaXZlRWxzLCB0cnVlKTtcbiAgfTtcbiAgQmFyVmlldy5wcm90b3R5cGUuX3VwZGF0ZUxhcmdlQ2xpcCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIC8vIFVzZSBjbGlwUGF0aCBpbiBsYXJnZSBtb2RlLlxuICAgIHZhciBjbGlwUGF0aCA9IHNlcmllc01vZGVsLmdldCgnY2xpcCcsIHRydWUpICYmIGNyZWF0ZUNsaXBQYXRoKHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0sIGZhbHNlLCBzZXJpZXNNb2RlbCk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgIGdyb3VwLnNldENsaXBQYXRoKGNsaXBQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAucmVtb3ZlQ2xpcFBhdGgoKTtcbiAgICB9XG4gIH07XG4gIEJhclZpZXcucHJvdG90eXBlLl9lbmFibGVSZWFsdGltZVNvcnQgPSBmdW5jdGlvbiAocmVhbHRpbWVTb3J0Q2ZnLCBkYXRhLCBhcGkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIElmIG5vIGRhdGEgaW4gdGhlIGZpcnN0IGZyYW1lLCB3YWl0IGZvciBkYXRhIHRvIGluaXRTb3J0XG4gICAgaWYgKCFkYXRhLmNvdW50KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGJhc2VBeGlzID0gcmVhbHRpbWVTb3J0Q2ZnLmJhc2VBeGlzO1xuICAgIGlmICh0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoSW5pdFNvcnQoZGF0YSwgcmVhbHRpbWVTb3J0Q2ZnLCBhcGkpO1xuICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvcmRlck1hcHBpbmdfMSA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGlkeCk7XG4gICAgICAgIHZhciBzaGFwZSA9IGVsICYmIGVsLnNoYXBlO1xuICAgICAgICByZXR1cm4gc2hhcGUgJiZcbiAgICAgICAgLy8gVGhlIHJlc3VsdCBzaG91bGQgYmUgY29uc2lzdGVudCB3aXRoIHRoZSBpbml0aWFsIHNvcnQgYnkgZGF0YSB2YWx1ZS5cbiAgICAgICAgLy8gRG8gbm90IHN1cHBvcnQgdGhlIGNhc2UgdGhhdCBib3RoIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSBleGlzdC5cbiAgICAgICAgTWF0aC5hYnMoYmFzZUF4aXMuaXNIb3Jpem9udGFsKCkgPyBzaGFwZS5oZWlnaHQgOiBzaGFwZS53aWR0aClcbiAgICAgICAgLy8gSWYgZGF0YSBpcyBOYU4sIHNoYXBlLnh4eCBtYXkgYmUgTmFOLCBzbyB1c2UgfHwgMCBoZXJlIGluIGNhc2VcbiAgICAgICAgfHwgMDtcbiAgICAgIH07XG4gICAgICB0aGlzLl9vblJlbmRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fdXBkYXRlU29ydFdpdGhpblNhbWVEYXRhKGRhdGEsIG9yZGVyTWFwcGluZ18xLCBiYXNlQXhpcywgYXBpKTtcbiAgICAgIH07XG4gICAgICBhcGkuZ2V0WnIoKS5vbigncmVuZGVyZWQnLCB0aGlzLl9vblJlbmRlcmVkKTtcbiAgICB9XG4gIH07XG4gIEJhclZpZXcucHJvdG90eXBlLl9kYXRhU29ydCA9IGZ1bmN0aW9uIChkYXRhLCBiYXNlQXhpcywgb3JkZXJNYXBwaW5nKSB7XG4gICAgdmFyIGluZm8gPSBbXTtcbiAgICBkYXRhLmVhY2goZGF0YS5tYXBEaW1lbnNpb24oYmFzZUF4aXMuZGltKSwgZnVuY3Rpb24gKG9yZGluYWxOdW1iZXIsIGRhdGFJZHgpIHtcbiAgICAgIHZhciBtYXBwZWRWYWx1ZSA9IG9yZGVyTWFwcGluZyhkYXRhSWR4KTtcbiAgICAgIG1hcHBlZFZhbHVlID0gbWFwcGVkVmFsdWUgPT0gbnVsbCA/IE5hTiA6IG1hcHBlZFZhbHVlO1xuICAgICAgaW5mby5wdXNoKHtcbiAgICAgICAgZGF0YUluZGV4OiBkYXRhSWR4LFxuICAgICAgICBtYXBwZWRWYWx1ZTogbWFwcGVkVmFsdWUsXG4gICAgICAgIG9yZGluYWxOdW1iZXI6IG9yZGluYWxOdW1iZXJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGluZm8uc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gSWYgTmFOLCBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgbWluIHZhbC5cbiAgICAgIHJldHVybiBiLm1hcHBlZFZhbHVlIC0gYS5tYXBwZWRWYWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgb3JkaW5hbE51bWJlcnM6IG1hcChpbmZvLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5vcmRpbmFsTnVtYmVyO1xuICAgICAgfSlcbiAgICB9O1xuICB9O1xuICBCYXJWaWV3LnByb3RvdHlwZS5faXNPcmRlckNoYW5nZWRXaXRoaW5TYW1lRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBvcmRlck1hcHBpbmcsIGJhc2VBeGlzKSB7XG4gICAgdmFyIHNjYWxlID0gYmFzZUF4aXMuc2NhbGU7XG4gICAgdmFyIG9yZGluYWxEYXRhRGltID0gZGF0YS5tYXBEaW1lbnNpb24oYmFzZUF4aXMuZGltKTtcbiAgICB2YXIgbGFzdFZhbHVlID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBmb3IgKHZhciB0aWNrTnVtID0gMCwgbGVuID0gc2NhbGUuZ2V0T3JkaW5hbE1ldGEoKS5jYXRlZ29yaWVzLmxlbmd0aDsgdGlja051bSA8IGxlbjsgKyt0aWNrTnVtKSB7XG4gICAgICB2YXIgcmF3SWR4ID0gZGF0YS5yYXdJbmRleE9mKG9yZGluYWxEYXRhRGltLCBzY2FsZS5nZXRSYXdPcmRpbmFsTnVtYmVyKHRpY2tOdW0pKTtcbiAgICAgIHZhciB2YWx1ZSA9IHJhd0lkeCA8IDBcbiAgICAgIC8vIElmIHNvbWUgdGljayBoYXZlIG5vIGJhciwgdGhlIHRpY2sgd2lsbCBiZSB0cmVhdGVkIGFzIG1pbi5cbiAgICAgID8gTnVtYmVyLk1JTl9WQUxVRVxuICAgICAgLy8gUEVORElORzogaWYgZGF0YVpvb20gb24gYmFzZUF4aXMgZXhpdHMsIGlzIGl0IGEgcGVyZm9ybWFuY2UgaXNzdWU/XG4gICAgICA6IG9yZGVyTWFwcGluZyhkYXRhLmluZGV4T2ZSYXdJbmRleChyYXdJZHgpKTtcbiAgICAgIGlmICh2YWx1ZSA+IGxhc3RWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIC8qXHJcbiAgICogQ29uc2lkZXIgdGhlIGNhc2Ugd2hlbiBBIGFuZCBCIGNoYW5nZWQgb3JkZXIsIHdob3NlIHJlcHJlc2VudGluZ1xyXG4gICAqIGJhcnMgYXJlIGJvdGggb3V0IG9mIHNpZ2h0LCB3ZSBkb24ndCB3aXNoIHRvIHRyaWdnZXIgcmVvcmRlciBhY3Rpb25cclxuICAgKiBhcyBsb25nIGFzIHRoZSBvcmRlciBpbiB0aGUgdmlldyBkb2Vzbid0IGNoYW5nZS5cclxuICAgKi9cbiAgQmFyVmlldy5wcm90b3R5cGUuX2lzT3JkZXJEaWZmZXJlbnRJblZpZXcgPSBmdW5jdGlvbiAob3JkZXJJbmZvLCBiYXNlQXhpcykge1xuICAgIHZhciBzY2FsZSA9IGJhc2VBeGlzLnNjYWxlO1xuICAgIHZhciBleHRlbnQgPSBzY2FsZS5nZXRFeHRlbnQoKTtcbiAgICB2YXIgdGlja051bSA9IE1hdGgubWF4KDAsIGV4dGVudFswXSk7XG4gICAgdmFyIHRpY2tNYXggPSBNYXRoLm1pbihleHRlbnRbMV0sIHNjYWxlLmdldE9yZGluYWxNZXRhKCkuY2F0ZWdvcmllcy5sZW5ndGggLSAxKTtcbiAgICBmb3IgKDsgdGlja051bSA8PSB0aWNrTWF4OyArK3RpY2tOdW0pIHtcbiAgICAgIGlmIChvcmRlckluZm8ub3JkaW5hbE51bWJlcnNbdGlja051bV0gIT09IHNjYWxlLmdldFJhd09yZGluYWxOdW1iZXIodGlja051bSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBCYXJWaWV3LnByb3RvdHlwZS5fdXBkYXRlU29ydFdpdGhpblNhbWVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIG9yZGVyTWFwcGluZywgYmFzZUF4aXMsIGFwaSkge1xuICAgIGlmICghdGhpcy5faXNPcmRlckNoYW5nZWRXaXRoaW5TYW1lRGF0YShkYXRhLCBvcmRlck1hcHBpbmcsIGJhc2VBeGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc29ydEluZm8gPSB0aGlzLl9kYXRhU29ydChkYXRhLCBiYXNlQXhpcywgb3JkZXJNYXBwaW5nKTtcbiAgICBpZiAodGhpcy5faXNPcmRlckRpZmZlcmVudEluVmlldyhzb3J0SW5mbywgYmFzZUF4aXMpKSB7XG4gICAgICB0aGlzLl9yZW1vdmVPblJlbmRlcmVkTGlzdGVuZXIoYXBpKTtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHR5cGU6ICdjaGFuZ2VBeGlzT3JkZXInLFxuICAgICAgICBjb21wb25lbnRUeXBlOiBiYXNlQXhpcy5kaW0gKyAnQXhpcycsXG4gICAgICAgIGF4aXNJZDogYmFzZUF4aXMuaW5kZXgsXG4gICAgICAgIHNvcnRJbmZvOiBzb3J0SW5mb1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBCYXJWaWV3LnByb3RvdHlwZS5fZGlzcGF0Y2hJbml0U29ydCA9IGZ1bmN0aW9uIChkYXRhLCByZWFsdGltZVNvcnRDZmcsIGFwaSkge1xuICAgIHZhciBiYXNlQXhpcyA9IHJlYWx0aW1lU29ydENmZy5iYXNlQXhpcztcbiAgICB2YXIgc29ydFJlc3VsdCA9IHRoaXMuX2RhdGFTb3J0KGRhdGEsIGJhc2VBeGlzLCBmdW5jdGlvbiAoZGF0YUlkeCkge1xuICAgICAgcmV0dXJuIGRhdGEuZ2V0KGRhdGEubWFwRGltZW5zaW9uKHJlYWx0aW1lU29ydENmZy5vdGhlckF4aXMuZGltKSwgZGF0YUlkeCk7XG4gICAgfSk7XG4gICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdjaGFuZ2VBeGlzT3JkZXInLFxuICAgICAgY29tcG9uZW50VHlwZTogYmFzZUF4aXMuZGltICsgJ0F4aXMnLFxuICAgICAgaXNJbml0U29ydDogdHJ1ZSxcbiAgICAgIGF4aXNJZDogYmFzZUF4aXMuaW5kZXgsXG4gICAgICBzb3J0SW5mbzogc29ydFJlc3VsdFxuICAgIH0pO1xuICB9O1xuICBCYXJWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5fY2xlYXIodGhpcy5fbW9kZWwpO1xuICAgIHRoaXMuX3JlbW92ZU9uUmVuZGVyZWRMaXN0ZW5lcihhcGkpO1xuICB9O1xuICBCYXJWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuX3JlbW92ZU9uUmVuZGVyZWRMaXN0ZW5lcihhcGkpO1xuICB9O1xuICBCYXJWaWV3LnByb3RvdHlwZS5fcmVtb3ZlT25SZW5kZXJlZExpc3RlbmVyID0gZnVuY3Rpb24gKGFwaSkge1xuICAgIGlmICh0aGlzLl9vblJlbmRlcmVkKSB7XG4gICAgICBhcGkuZ2V0WnIoKS5vZmYoJ3JlbmRlcmVkJywgdGhpcy5fb25SZW5kZXJlZCk7XG4gICAgICB0aGlzLl9vblJlbmRlcmVkID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIEJhclZpZXcucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGlmIChtb2RlbCAmJiBtb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKSAmJiBkYXRhICYmICF0aGlzLl9pc0xhcmdlRHJhdykge1xuICAgICAgdGhpcy5fcmVtb3ZlQmFja2dyb3VuZCgpO1xuICAgICAgdGhpcy5fYmFja2dyb3VuZEVscyA9IFtdO1xuICAgICAgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmVtb3ZlRWxlbWVudFdpdGhGYWRlT3V0KGVsLCBtb2RlbCwgZ2V0RUNEYXRhKGVsKS5kYXRhSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIH1cbiAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xuICB9O1xuICBCYXJWaWV3LnByb3RvdHlwZS5fcmVtb3ZlQmFja2dyb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZSh0aGlzLl9iYWNrZ3JvdW5kR3JvdXApO1xuICAgIHRoaXMuX2JhY2tncm91bmRHcm91cCA9IG51bGw7XG4gIH07XG4gIEJhclZpZXcudHlwZSA9ICdiYXInO1xuICByZXR1cm4gQmFyVmlldztcbn0oQ2hhcnRWaWV3KTtcbnZhciBjbGlwID0ge1xuICBjYXJ0ZXNpYW4yZDogZnVuY3Rpb24gKGNvb3JkU3lzQm91bmRpbmdSZWN0LCBsYXlvdXQpIHtcbiAgICB2YXIgc2lnbldpZHRoID0gbGF5b3V0LndpZHRoIDwgMCA/IC0xIDogMTtcbiAgICB2YXIgc2lnbkhlaWdodCA9IGxheW91dC5oZWlnaHQgPCAwID8gLTEgOiAxO1xuICAgIC8vIE5lZWRzIHBvc2l0aXZlIHdpZHRoIGFuZCBoZWlnaHRcbiAgICBpZiAoc2lnbldpZHRoIDwgMCkge1xuICAgICAgbGF5b3V0LnggKz0gbGF5b3V0LndpZHRoO1xuICAgICAgbGF5b3V0LndpZHRoID0gLWxheW91dC53aWR0aDtcbiAgICB9XG4gICAgaWYgKHNpZ25IZWlnaHQgPCAwKSB7XG4gICAgICBsYXlvdXQueSArPSBsYXlvdXQuaGVpZ2h0O1xuICAgICAgbGF5b3V0LmhlaWdodCA9IC1sYXlvdXQuaGVpZ2h0O1xuICAgIH1cbiAgICB2YXIgY29vcmRTeXNYMiA9IGNvb3JkU3lzQm91bmRpbmdSZWN0LnggKyBjb29yZFN5c0JvdW5kaW5nUmVjdC53aWR0aDtcbiAgICB2YXIgY29vcmRTeXNZMiA9IGNvb3JkU3lzQm91bmRpbmdSZWN0LnkgKyBjb29yZFN5c0JvdW5kaW5nUmVjdC5oZWlnaHQ7XG4gICAgdmFyIHggPSBtYXRoTWF4KGxheW91dC54LCBjb29yZFN5c0JvdW5kaW5nUmVjdC54KTtcbiAgICB2YXIgeDIgPSBtYXRoTWluKGxheW91dC54ICsgbGF5b3V0LndpZHRoLCBjb29yZFN5c1gyKTtcbiAgICB2YXIgeSA9IG1hdGhNYXgobGF5b3V0LnksIGNvb3JkU3lzQm91bmRpbmdSZWN0LnkpO1xuICAgIHZhciB5MiA9IG1hdGhNaW4obGF5b3V0LnkgKyBsYXlvdXQuaGVpZ2h0LCBjb29yZFN5c1kyKTtcbiAgICB2YXIgeENsaXBwZWQgPSB4MiA8IHg7XG4gICAgdmFyIHlDbGlwcGVkID0geTIgPCB5O1xuICAgIC8vIFdoZW4geENsaXBwZWQgb3IgeUNsaXBwZWQsIHRoZSBlbGVtZW50IHdpbGwgYmUgbWFya2VkIGFzIGBpZ25vcmVgLlxuICAgIC8vIEJ1dCB3ZSBzaG91bGQgYWxzbyBwbGFjZSB0aGUgZWxlbWVudCBhdCB0aGUgZWRnZSBvZiB0aGUgY29vcmQgc3lzIGJvdW5kaW5nIHJlY3QuXG4gICAgLy8gQmVjYXVzZSBpZiBkYXRhIGNoYW5nZWQgYW5kIHRoZSBiYXIgc2hvd3MgYWdhaW4sIGl0cyB0cmFuc2l0aW9uIGFuaW1hdGlvblxuICAgIC8vIHdpbGwgYmVnaW4gYXQgdGhpcyBwbGFjZS5cbiAgICBsYXlvdXQueCA9IHhDbGlwcGVkICYmIHggPiBjb29yZFN5c1gyID8geDIgOiB4O1xuICAgIGxheW91dC55ID0geUNsaXBwZWQgJiYgeSA+IGNvb3JkU3lzWTIgPyB5MiA6IHk7XG4gICAgbGF5b3V0LndpZHRoID0geENsaXBwZWQgPyAwIDogeDIgLSB4O1xuICAgIGxheW91dC5oZWlnaHQgPSB5Q2xpcHBlZCA/IDAgOiB5MiAtIHk7XG4gICAgLy8gUmV2ZXJzZSBiYWNrXG4gICAgaWYgKHNpZ25XaWR0aCA8IDApIHtcbiAgICAgIGxheW91dC54ICs9IGxheW91dC53aWR0aDtcbiAgICAgIGxheW91dC53aWR0aCA9IC1sYXlvdXQud2lkdGg7XG4gICAgfVxuICAgIGlmIChzaWduSGVpZ2h0IDwgMCkge1xuICAgICAgbGF5b3V0LnkgKz0gbGF5b3V0LmhlaWdodDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSAtbGF5b3V0LmhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIHhDbGlwcGVkIHx8IHlDbGlwcGVkO1xuICB9LFxuICBwb2xhcjogZnVuY3Rpb24gKGNvb3JkU3lzQ2xpcEFyZWEsIGxheW91dCkge1xuICAgIHZhciBzaWduUiA9IGxheW91dC5yMCA8PSBsYXlvdXQuciA/IDEgOiAtMTtcbiAgICAvLyBNYWtlIHN1cmUgciBpcyBsYXJnZXIgdGhhbiByMFxuICAgIGlmIChzaWduUiA8IDApIHtcbiAgICAgIHZhciB0bXAgPSBsYXlvdXQucjtcbiAgICAgIGxheW91dC5yID0gbGF5b3V0LnIwO1xuICAgICAgbGF5b3V0LnIwID0gdG1wO1xuICAgIH1cbiAgICB2YXIgciA9IG1hdGhNaW4obGF5b3V0LnIsIGNvb3JkU3lzQ2xpcEFyZWEucik7XG4gICAgdmFyIHIwID0gbWF0aE1heChsYXlvdXQucjAsIGNvb3JkU3lzQ2xpcEFyZWEucjApO1xuICAgIGxheW91dC5yID0gcjtcbiAgICBsYXlvdXQucjAgPSByMDtcbiAgICB2YXIgY2xpcHBlZCA9IHIgLSByMCA8IDA7XG4gICAgLy8gUmV2ZXJzZSBiYWNrXG4gICAgaWYgKHNpZ25SIDwgMCkge1xuICAgICAgdmFyIHRtcCA9IGxheW91dC5yO1xuICAgICAgbGF5b3V0LnIgPSBsYXlvdXQucjA7XG4gICAgICBsYXlvdXQucjAgPSB0bXA7XG4gICAgfVxuICAgIHJldHVybiBjbGlwcGVkO1xuICB9XG59O1xudmFyIGVsZW1lbnRDcmVhdG9yID0ge1xuICBjYXJ0ZXNpYW4yZDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBkYXRhLCBuZXdJbmRleCwgbGF5b3V0LCBpc0hvcml6b250YWwsIGFuaW1hdGlvbk1vZGVsLCBheGlzTW9kZWwsIGlzVXBkYXRlLCByb3VuZENhcCkge1xuICAgIHZhciByZWN0ID0gbmV3IFJlY3Qoe1xuICAgICAgc2hhcGU6IGV4dGVuZCh7fSwgbGF5b3V0KSxcbiAgICAgIHoyOiAxXG4gICAgfSk7XG4gICAgcmVjdC5fX2RhdGFJbmRleCA9IG5ld0luZGV4O1xuICAgIHJlY3QubmFtZSA9ICdpdGVtJztcbiAgICBpZiAoYW5pbWF0aW9uTW9kZWwpIHtcbiAgICAgIHZhciByZWN0U2hhcGUgPSByZWN0LnNoYXBlO1xuICAgICAgdmFyIGFuaW1hdGVQcm9wZXJ0eSA9IGlzSG9yaXpvbnRhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgIHJlY3RTaGFwZVthbmltYXRlUHJvcGVydHldID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH0sXG4gIHBvbGFyOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGRhdGEsIG5ld0luZGV4LCBsYXlvdXQsIGlzUmFkaWFsLCBhbmltYXRpb25Nb2RlbCwgYXhpc01vZGVsLCBpc1VwZGF0ZSwgcm91bmRDYXApIHtcbiAgICB2YXIgU2hhcGVDbGFzcyA9ICFpc1JhZGlhbCAmJiByb3VuZENhcCA/IFNhdXNhZ2UgOiBTZWN0b3I7XG4gICAgdmFyIHNlY3RvciA9IG5ldyBTaGFwZUNsYXNzKHtcbiAgICAgIHNoYXBlOiBsYXlvdXQsXG4gICAgICB6MjogMVxuICAgIH0pO1xuICAgIHNlY3Rvci5uYW1lID0gJ2l0ZW0nO1xuICAgIHZhciBwb3NpdGlvbk1hcCA9IGNyZWF0ZVBvbGFyUG9zaXRpb25NYXBwaW5nKGlzUmFkaWFsKTtcbiAgICBzZWN0b3IuY2FsY3VsYXRlVGV4dFBvc2l0aW9uID0gY3JlYXRlU2VjdG9yQ2FsY3VsYXRlVGV4dFBvc2l0aW9uKHBvc2l0aW9uTWFwLCB7XG4gICAgICBpc1JvdW5kQ2FwOiBTaGFwZUNsYXNzID09PSBTYXVzYWdlXG4gICAgfSk7XG4gICAgLy8gQW5pbWF0aW9uXG4gICAgaWYgKGFuaW1hdGlvbk1vZGVsKSB7XG4gICAgICB2YXIgc2VjdG9yU2hhcGUgPSBzZWN0b3Iuc2hhcGU7XG4gICAgICB2YXIgYW5pbWF0ZVByb3BlcnR5ID0gaXNSYWRpYWwgPyAncicgOiAnZW5kQW5nbGUnO1xuICAgICAgdmFyIGFuaW1hdGVUYXJnZXQgPSB7fTtcbiAgICAgIHNlY3RvclNoYXBlW2FuaW1hdGVQcm9wZXJ0eV0gPSBpc1JhZGlhbCA/IGxheW91dC5yMCA6IGxheW91dC5zdGFydEFuZ2xlO1xuICAgICAgYW5pbWF0ZVRhcmdldFthbmltYXRlUHJvcGVydHldID0gbGF5b3V0W2FuaW1hdGVQcm9wZXJ0eV07XG4gICAgICAoaXNVcGRhdGUgPyB1cGRhdGVQcm9wcyA6IGluaXRQcm9wcykoc2VjdG9yLCB7XG4gICAgICAgIHNoYXBlOiBhbmltYXRlVGFyZ2V0XG4gICAgICAgIC8vIF9fdmFsdWU6IHR5cGVvZiBkYXRhVmFsdWUgPT09ICdzdHJpbmcnID8gcGFyc2VJbnQoZGF0YVZhbHVlLCAxMCkgOiBkYXRhVmFsdWVcbiAgICAgIH0sIGFuaW1hdGlvbk1vZGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlY3RvcjtcbiAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZFJlYWx0aW1lU29ydChzZXJpZXNNb2RlbCwgY29vcmRTeXMpIHtcbiAgdmFyIHJlYWx0aW1lU29ydE9wdGlvbiA9IHNlcmllc01vZGVsLmdldCgncmVhbHRpbWVTb3J0JywgdHJ1ZSk7XG4gIHZhciBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHJlYWx0aW1lU29ydE9wdGlvbikge1xuICAgICAgaWYgKGJhc2VBeGlzLnR5cGUgIT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgd2FybignYHJlYWx0aW1lU29ydGAgd2lsbCBub3Qgd29yayBiZWNhdXNlIHRoaXMgYmFyIHNlcmllcyBpcyBub3QgYmFzZWQgb24gYSBjYXRlZ29yeSBheGlzLicpO1xuICAgICAgfVxuICAgICAgaWYgKGNvb3JkU3lzLnR5cGUgIT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgICAgd2FybignYHJlYWx0aW1lU29ydGAgd2lsbCBub3Qgd29yayBiZWNhdXNlIHRoaXMgYmFyIHNlcmllcyBpcyBub3Qgb24gY2FydGVzaWFuMmQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZWFsdGltZVNvcnRPcHRpb24gJiYgYmFzZUF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyAmJiBjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2VBeGlzOiBiYXNlQXhpcyxcbiAgICAgIG90aGVyQXhpczogY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVJlYWx0aW1lQW5pbWF0aW9uKHJlYWx0aW1lU29ydENmZywgc2VyaWVzQW5pbWF0aW9uTW9kZWwsIGVsLCBsYXlvdXQsIG5ld0luZGV4LCBpc0hvcml6b250YWwsIGlzVXBkYXRlLCBpc0NoYW5nZU9yZGVyKSB7XG4gIHZhciBzZXJpZXNUYXJnZXQ7XG4gIHZhciBheGlzVGFyZ2V0O1xuICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgYXhpc1RhcmdldCA9IHtcbiAgICAgIHg6IGxheW91dC54LFxuICAgICAgd2lkdGg6IGxheW91dC53aWR0aFxuICAgIH07XG4gICAgc2VyaWVzVGFyZ2V0ID0ge1xuICAgICAgeTogbGF5b3V0LnksXG4gICAgICBoZWlnaHQ6IGxheW91dC5oZWlnaHRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGF4aXNUYXJnZXQgPSB7XG4gICAgICB5OiBsYXlvdXQueSxcbiAgICAgIGhlaWdodDogbGF5b3V0LmhlaWdodFxuICAgIH07XG4gICAgc2VyaWVzVGFyZ2V0ID0ge1xuICAgICAgeDogbGF5b3V0LngsXG4gICAgICB3aWR0aDogbGF5b3V0LndpZHRoXG4gICAgfTtcbiAgfVxuICBpZiAoIWlzQ2hhbmdlT3JkZXIpIHtcbiAgICAvLyBLZWVwIHRoZSBvcmlnaW5hbCBncm93dGggYW5pbWF0aW9uIGlmIG9ubHkgYXhpcyBvcmRlciBjaGFuZ2VkLlxuICAgIC8vIE5vdCBzdGFydCBhIG5ldyBhbmltYXRpb24uXG4gICAgKGlzVXBkYXRlID8gdXBkYXRlUHJvcHMgOiBpbml0UHJvcHMpKGVsLCB7XG4gICAgICBzaGFwZTogc2VyaWVzVGFyZ2V0XG4gICAgfSwgc2VyaWVzQW5pbWF0aW9uTW9kZWwsIG5ld0luZGV4LCBudWxsKTtcbiAgfVxuICB2YXIgYXhpc0FuaW1hdGlvbk1vZGVsID0gc2VyaWVzQW5pbWF0aW9uTW9kZWwgPyByZWFsdGltZVNvcnRDZmcuYmFzZUF4aXMubW9kZWwgOiBudWxsO1xuICAoaXNVcGRhdGUgPyB1cGRhdGVQcm9wcyA6IGluaXRQcm9wcykoZWwsIHtcbiAgICBzaGFwZTogYXhpc1RhcmdldFxuICB9LCBheGlzQW5pbWF0aW9uTW9kZWwsIG5ld0luZGV4KTtcbn1cbmZ1bmN0aW9uIGNoZWNrUHJvcGVydGllc05vdFZhbGlkKG9iaiwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaXNGaW5pdGUob2JqW3Byb3BzW2ldXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgcmVjdFByb3B0aWVzID0gWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0J107XG52YXIgcG9sYXJQcm9wdGllcyA9IFsnY3gnLCAnY3knLCAncicsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ107XG52YXIgaXNWYWxpZExheW91dCA9IHtcbiAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChsYXlvdXQpIHtcbiAgICByZXR1cm4gIWNoZWNrUHJvcGVydGllc05vdFZhbGlkKGxheW91dCwgcmVjdFByb3B0aWVzKTtcbiAgfSxcbiAgcG9sYXI6IGZ1bmN0aW9uIChsYXlvdXQpIHtcbiAgICByZXR1cm4gIWNoZWNrUHJvcGVydGllc05vdFZhbGlkKGxheW91dCwgcG9sYXJQcm9wdGllcyk7XG4gIH1cbn07XG52YXIgZ2V0TGF5b3V0ID0ge1xuICAvLyBpdGVtTW9kZWwgaXMgb25seSB1c2VkIHRvIGdldCBib3JkZXJXaWR0aCwgd2hpY2ggaXMgbm90IG5lZWRlZFxuICAvLyB3aGVuIGNhbGN1bGF0aW5nIGJhciBiYWNrZ3JvdW5kIGxheW91dC5cbiAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCkge1xuICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KTtcbiAgICB2YXIgZml4ZWRMaW5lV2lkdGggPSBpdGVtTW9kZWwgPyBnZXRMaW5lV2lkdGgoaXRlbU1vZGVsLCBsYXlvdXQpIDogMDtcbiAgICAvLyBmaXggbGF5b3V0IHdpdGggbGluZVdpZHRoXG4gICAgdmFyIHNpZ25YID0gbGF5b3V0LndpZHRoID4gMCA/IDEgOiAtMTtcbiAgICB2YXIgc2lnblkgPSBsYXlvdXQuaGVpZ2h0ID4gMCA/IDEgOiAtMTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogbGF5b3V0LnggKyBzaWduWCAqIGZpeGVkTGluZVdpZHRoIC8gMixcbiAgICAgIHk6IGxheW91dC55ICsgc2lnblkgKiBmaXhlZExpbmVXaWR0aCAvIDIsXG4gICAgICB3aWR0aDogbGF5b3V0LndpZHRoIC0gc2lnblggKiBmaXhlZExpbmVXaWR0aCxcbiAgICAgIGhlaWdodDogbGF5b3V0LmhlaWdodCAtIHNpZ25ZICogZml4ZWRMaW5lV2lkdGhcbiAgICB9O1xuICB9LFxuICBwb2xhcjogZnVuY3Rpb24gKGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsKSB7XG4gICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChkYXRhSW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBjeDogbGF5b3V0LmN4LFxuICAgICAgY3k6IGxheW91dC5jeSxcbiAgICAgIHIwOiBsYXlvdXQucjAsXG4gICAgICByOiBsYXlvdXQucixcbiAgICAgIHN0YXJ0QW5nbGU6IGxheW91dC5zdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGU6IGxheW91dC5lbmRBbmdsZSxcbiAgICAgIGNsb2Nrd2lzZTogbGF5b3V0LmNsb2Nrd2lzZVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBpc1plcm9PblBvbGFyKGxheW91dCkge1xuICByZXR1cm4gbGF5b3V0LnN0YXJ0QW5nbGUgIT0gbnVsbCAmJiBsYXlvdXQuZW5kQW5nbGUgIT0gbnVsbCAmJiBsYXlvdXQuc3RhcnRBbmdsZSA9PT0gbGF5b3V0LmVuZEFuZ2xlO1xufVxuZnVuY3Rpb24gY3JlYXRlUG9sYXJQb3NpdGlvbk1hcHBpbmcoaXNSYWRpYWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpc1JhZGlhbCkge1xuICAgIHZhciBhcmNPckFuZ2xlID0gaXNSYWRpYWwgPyAnQXJjJyA6ICdBbmdsZSc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgIGNhc2UgJ2luc2lkZVN0YXJ0JzpcbiAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgY2FzZSAnaW5zaWRlRW5kJzpcbiAgICAgICAgICByZXR1cm4gcG9zaXRpb24gKyBhcmNPckFuZ2xlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9O1xuICB9KGlzUmFkaWFsKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlKGVsLCBkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBzZXJpZXNNb2RlbCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGlzUG9sYXIpIHtcbiAgdmFyIHN0eWxlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ3N0eWxlJyk7XG4gIGlmICghaXNQb2xhcikge1xuICAgIHZhciBib3JkZXJSYWRpdXMgPSBpdGVtTW9kZWwuZ2V0KFsnaXRlbVN0eWxlJywgJ2JvcmRlclJhZGl1cyddKSB8fCAwO1xuICAgIGVsLnNldFNoYXBlKCdyJywgYm9yZGVyUmFkaXVzKTtcbiAgfSBlbHNlIGlmICghc2VyaWVzTW9kZWwuZ2V0KCdyb3VuZENhcCcpKSB7XG4gICAgdmFyIHNlY3RvclNoYXBlID0gZWwuc2hhcGU7XG4gICAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFNlY3RvckNvcm5lclJhZGl1cyhpdGVtTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLCBzZWN0b3JTaGFwZSwgdHJ1ZSk7XG4gICAgZXh0ZW5kKHNlY3RvclNoYXBlLCBjb3JuZXJSYWRpdXMpO1xuICAgIGVsLnNldFNoYXBlKHNlY3RvclNoYXBlKTtcbiAgfVxuICBlbC51c2VTdHlsZShzdHlsZSk7XG4gIHZhciBjdXJzb3JTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdjdXJzb3InKTtcbiAgY3Vyc29yU3R5bGUgJiYgZWwuYXR0cignY3Vyc29yJywgY3Vyc29yU3R5bGUpO1xuICB2YXIgbGFiZWxQb3NpdGlvbk91dHNpZGUgPSBpc1BvbGFyID8gaXNIb3Jpem9udGFsT3JSYWRpYWwgPyBsYXlvdXQuciA+PSBsYXlvdXQucjAgPyAnZW5kQXJjJyA6ICdzdGFydEFyYycgOiBsYXlvdXQuZW5kQW5nbGUgPj0gbGF5b3V0LnN0YXJ0QW5nbGUgPyAnZW5kQW5nbGUnIDogJ3N0YXJ0QW5nbGUnIDogaXNIb3Jpem9udGFsT3JSYWRpYWwgPyBsYXlvdXQuaGVpZ2h0ID49IDAgPyAnYm90dG9tJyA6ICd0b3AnIDogbGF5b3V0LndpZHRoID49IDAgPyAncmlnaHQnIDogJ2xlZnQnO1xuICB2YXIgbGFiZWxTdGF0ZXNNb2RlbHMgPSBnZXRMYWJlbFN0YXRlc01vZGVscyhpdGVtTW9kZWwpO1xuICBzZXRMYWJlbFN0eWxlKGVsLCBsYWJlbFN0YXRlc01vZGVscywge1xuICAgIGxhYmVsRmV0Y2hlcjogc2VyaWVzTW9kZWwsXG4gICAgbGFiZWxEYXRhSW5kZXg6IGRhdGFJbmRleCxcbiAgICBkZWZhdWx0VGV4dDogZ2V0RGVmYXVsdExhYmVsKHNlcmllc01vZGVsLmdldERhdGEoKSwgZGF0YUluZGV4KSxcbiAgICBpbmhlcml0Q29sb3I6IHN0eWxlLmZpbGwsXG4gICAgZGVmYXVsdE9wYWNpdHk6IHN0eWxlLm9wYWNpdHksXG4gICAgZGVmYXVsdE91dHNpZGVQb3NpdGlvbjogbGFiZWxQb3NpdGlvbk91dHNpZGVcbiAgfSk7XG4gIHZhciBsYWJlbCA9IGVsLmdldFRleHRDb250ZW50KCk7XG4gIGlmIChpc1BvbGFyICYmIGxhYmVsKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gaXRlbU1vZGVsLmdldChbJ2xhYmVsJywgJ3Bvc2l0aW9uJ10pO1xuICAgIGVsLnRleHRDb25maWcuaW5zaWRlID0gcG9zaXRpb24gPT09ICdtaWRkbGUnID8gdHJ1ZSA6IG51bGw7XG4gICAgc2V0U2VjdG9yVGV4dFJvdGF0aW9uKGVsLCBwb3NpdGlvbiA9PT0gJ291dHNpZGUnID8gbGFiZWxQb3NpdGlvbk91dHNpZGUgOiBwb3NpdGlvbiwgY3JlYXRlUG9sYXJQb3NpdGlvbk1hcHBpbmcoaXNIb3Jpem9udGFsT3JSYWRpYWwpLCBpdGVtTW9kZWwuZ2V0KFsnbGFiZWwnLCAncm90YXRlJ10pKTtcbiAgfVxuICBzZXRMYWJlbFZhbHVlQW5pbWF0aW9uKGxhYmVsLCBsYWJlbFN0YXRlc01vZGVscywgc2VyaWVzTW9kZWwuZ2V0UmF3VmFsdWUoZGF0YUluZGV4KSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldERlZmF1bHRJbnRlcnBvbGF0ZWRMYWJlbChkYXRhLCB2YWx1ZSk7XG4gIH0pO1xuICB2YXIgZW1waGFzaXNNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChbJ2VtcGhhc2lzJ10pO1xuICB0b2dnbGVIb3ZlckVtcGhhc2lzKGVsLCBlbXBoYXNpc01vZGVsLmdldCgnZm9jdXMnKSwgZW1waGFzaXNNb2RlbC5nZXQoJ2JsdXJTY29wZScpLCBlbXBoYXNpc01vZGVsLmdldCgnZGlzYWJsZWQnKSk7XG4gIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChlbCwgaXRlbU1vZGVsKTtcbiAgaWYgKGlzWmVyb09uUG9sYXIobGF5b3V0KSkge1xuICAgIGVsLnN0eWxlLmZpbGwgPSAnbm9uZSc7XG4gICAgZWwuc3R5bGUuc3Ryb2tlID0gJ25vbmUnO1xuICAgIGVhY2goZWwuc3RhdGVzLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5zdHlsZSkge1xuICAgICAgICBzdGF0ZS5zdHlsZS5maWxsID0gc3RhdGUuc3R5bGUuc3Ryb2tlID0gJ25vbmUnO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4vLyBJbiBjYXNlIHdpZHRoIG9yIGhlaWdodCBhcmUgdG9vIHNtYWxsLlxuZnVuY3Rpb24gZ2V0TGluZVdpZHRoKGl0ZW1Nb2RlbCwgcmF3TGF5b3V0KSB7XG4gIC8vIEhhcyBubyBib3JkZXIuXG4gIHZhciBib3JkZXJDb2xvciA9IGl0ZW1Nb2RlbC5nZXQoWydpdGVtU3R5bGUnLCAnYm9yZGVyQ29sb3InXSk7XG4gIGlmICghYm9yZGVyQ29sb3IgfHwgYm9yZGVyQ29sb3IgPT09ICdub25lJykge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBsaW5lV2lkdGggPSBpdGVtTW9kZWwuZ2V0KFsnaXRlbVN0eWxlJywgJ2JvcmRlcldpZHRoJ10pIHx8IDA7XG4gIC8vIHdpZHRoIG9yIGhlaWdodCBtYXkgYmUgTmFOIGZvciBlbXB0eSBkYXRhXG4gIHZhciB3aWR0aCA9IGlzTmFOKHJhd0xheW91dC53aWR0aCkgPyBOdW1iZXIuTUFYX1ZBTFVFIDogTWF0aC5hYnMocmF3TGF5b3V0LndpZHRoKTtcbiAgdmFyIGhlaWdodCA9IGlzTmFOKHJhd0xheW91dC5oZWlnaHQpID8gTnVtYmVyLk1BWF9WQUxVRSA6IE1hdGguYWJzKHJhd0xheW91dC5oZWlnaHQpO1xuICByZXR1cm4gTWF0aC5taW4obGluZVdpZHRoLCB3aWR0aCwgaGVpZ2h0KTtcbn1cbnZhciBMYWdlUGF0aFNoYXBlID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGFnZVBhdGhTaGFwZSgpIHt9XG4gIHJldHVybiBMYWdlUGF0aFNoYXBlO1xufSgpO1xudmFyIExhcmdlUGF0aCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhMYXJnZVBhdGgsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIExhcmdlUGF0aChvcHRzKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gJ2xhcmdlQmFyJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgTGFyZ2VQYXRoLnByb3RvdHlwZS5nZXREZWZhdWx0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBMYWdlUGF0aFNoYXBlKCk7XG4gIH07XG4gIExhcmdlUGF0aC5wcm90b3R5cGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAvLyBEcmF3aW5nIGxpbmVzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gZHJhd2luZ1xuICAgIC8vIGEgd2hvbGUgbGluZSBvciBkcmF3aW5nIHJlY3RzLlxuICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gICAgdmFyIGJhc2VEaW1JZHggPSB0aGlzLmJhc2VEaW1JZHg7XG4gICAgdmFyIHZhbHVlRGltSWR4ID0gMSAtIHRoaXMuYmFzZURpbUlkeDtcbiAgICB2YXIgc3RhcnRQb2ludCA9IFtdO1xuICAgIHZhciBzaXplID0gW107XG4gICAgdmFyIGJhcldpZHRoID0gdGhpcy5iYXJXaWR0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgc2l6ZVtiYXNlRGltSWR4XSA9IGJhcldpZHRoO1xuICAgICAgc2l6ZVt2YWx1ZURpbUlkeF0gPSBwb2ludHNbaSArIDJdO1xuICAgICAgc3RhcnRQb2ludFtiYXNlRGltSWR4XSA9IHBvaW50c1tpICsgYmFzZURpbUlkeF07XG4gICAgICBzdGFydFBvaW50W3ZhbHVlRGltSWR4XSA9IHBvaW50c1tpICsgdmFsdWVEaW1JZHhdO1xuICAgICAgY3R4LnJlY3Qoc3RhcnRQb2ludFswXSwgc3RhcnRQb2ludFsxXSwgc2l6ZVswXSwgc2l6ZVsxXSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gTGFyZ2VQYXRoO1xufShQYXRoKTtcbmZ1bmN0aW9uIGNyZWF0ZUxhcmdlKHNlcmllc01vZGVsLCBncm91cCwgcHJvZ3Jlc3NpdmVFbHMsIGluY3JlbWVudGFsKSB7XG4gIC8vIFRPRE8gc3VwcG9ydCBwb2xhclxuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGJhc2VEaW1JZHggPSBkYXRhLmdldExheW91dCgndmFsdWVBeGlzSG9yaXpvbnRhbCcpID8gMSA6IDA7XG4gIHZhciBsYXJnZURhdGFJbmRpY2VzID0gZGF0YS5nZXRMYXlvdXQoJ2xhcmdlRGF0YUluZGljZXMnKTtcbiAgdmFyIGJhcldpZHRoID0gZGF0YS5nZXRMYXlvdXQoJ3NpemUnKTtcbiAgdmFyIGJhY2tncm91bmRNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdiYWNrZ3JvdW5kU3R5bGUnKTtcbiAgdmFyIGJnUG9pbnRzID0gZGF0YS5nZXRMYXlvdXQoJ2xhcmdlQmFja2dyb3VuZFBvaW50cycpO1xuICBpZiAoYmdQb2ludHMpIHtcbiAgICB2YXIgYmdFbCA9IG5ldyBMYXJnZVBhdGgoe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBiZ1BvaW50c1xuICAgICAgfSxcbiAgICAgIGluY3JlbWVudGFsOiAhIWluY3JlbWVudGFsLFxuICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgejI6IDBcbiAgICB9KTtcbiAgICBiZ0VsLmJhc2VEaW1JZHggPSBiYXNlRGltSWR4O1xuICAgIGJnRWwubGFyZ2VEYXRhSW5kaWNlcyA9IGxhcmdlRGF0YUluZGljZXM7XG4gICAgYmdFbC5iYXJXaWR0aCA9IGJhcldpZHRoO1xuICAgIGJnRWwudXNlU3R5bGUoYmFja2dyb3VuZE1vZGVsLmdldEl0ZW1TdHlsZSgpKTtcbiAgICBncm91cC5hZGQoYmdFbCk7XG4gICAgcHJvZ3Jlc3NpdmVFbHMgJiYgcHJvZ3Jlc3NpdmVFbHMucHVzaChiZ0VsKTtcbiAgfVxuICB2YXIgZWwgPSBuZXcgTGFyZ2VQYXRoKHtcbiAgICBzaGFwZToge1xuICAgICAgcG9pbnRzOiBkYXRhLmdldExheW91dCgnbGFyZ2VQb2ludHMnKVxuICAgIH0sXG4gICAgaW5jcmVtZW50YWw6ICEhaW5jcmVtZW50YWwsXG4gICAgaWdub3JlQ29hcnNlUG9pbnRlcjogdHJ1ZSxcbiAgICB6MjogMVxuICB9KTtcbiAgZWwuYmFzZURpbUlkeCA9IGJhc2VEaW1JZHg7XG4gIGVsLmxhcmdlRGF0YUluZGljZXMgPSBsYXJnZURhdGFJbmRpY2VzO1xuICBlbC5iYXJXaWR0aCA9IGJhcldpZHRoO1xuICBncm91cC5hZGQoZWwpO1xuICBlbC51c2VTdHlsZShkYXRhLmdldFZpc3VhbCgnc3R5bGUnKSk7XG4gIC8vIFN0cm9rZSBpcyByZW5kZXJlZCBmaXJzdCB0byBhdm9pZCBvdmVybGFwcGluZyB3aXRoIGZpbGxcbiAgZWwuc3R5bGUuc3Ryb2tlID0gbnVsbDtcbiAgLy8gRW5hYmxlIHRvb2x0aXAgYW5kIHVzZXIgbW91c2UvdG91Y2ggZXZlbnQgaGFuZGxlcnMuXG4gIGdldEVDRGF0YShlbCkuc2VyaWVzSW5kZXggPSBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleDtcbiAgaWYgKCFzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpKSB7XG4gICAgZWwub24oJ21vdXNlZG93bicsIGxhcmdlUGF0aFVwZGF0ZURhdGFJbmRleCk7XG4gICAgZWwub24oJ21vdXNlbW92ZScsIGxhcmdlUGF0aFVwZGF0ZURhdGFJbmRleCk7XG4gIH1cbiAgcHJvZ3Jlc3NpdmVFbHMgJiYgcHJvZ3Jlc3NpdmVFbHMucHVzaChlbCk7XG59XG4vLyBVc2UgdGhyb3R0bGUgdG8gYXZvaWQgZnJlcXVlbnRseSB0cmF2ZXJzZSB0byBmaW5kIGRhdGFJbmRleC5cbnZhciBsYXJnZVBhdGhVcGRhdGVEYXRhSW5kZXggPSB0aHJvdHRsZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGxhcmdlUGF0aCA9IHRoaXM7XG4gIHZhciBkYXRhSW5kZXggPSBsYXJnZVBhdGhGaW5kRGF0YUluZGV4KGxhcmdlUGF0aCwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gIGdldEVDRGF0YShsYXJnZVBhdGgpLmRhdGFJbmRleCA9IGRhdGFJbmRleCA+PSAwID8gZGF0YUluZGV4IDogbnVsbDtcbn0sIDMwLCBmYWxzZSk7XG5mdW5jdGlvbiBsYXJnZVBhdGhGaW5kRGF0YUluZGV4KGxhcmdlUGF0aCwgeCwgeSkge1xuICB2YXIgYmFzZURpbUlkeCA9IGxhcmdlUGF0aC5iYXNlRGltSWR4O1xuICB2YXIgdmFsdWVEaW1JZHggPSAxIC0gYmFzZURpbUlkeDtcbiAgdmFyIHBvaW50cyA9IGxhcmdlUGF0aC5zaGFwZS5wb2ludHM7XG4gIHZhciBsYXJnZURhdGFJbmRpY2VzID0gbGFyZ2VQYXRoLmxhcmdlRGF0YUluZGljZXM7XG4gIHZhciBzdGFydFBvaW50ID0gW107XG4gIHZhciBzaXplID0gW107XG4gIHZhciBiYXJXaWR0aCA9IGxhcmdlUGF0aC5iYXJXaWR0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGggLyAzOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgaWkgPSBpICogMztcbiAgICBzaXplW2Jhc2VEaW1JZHhdID0gYmFyV2lkdGg7XG4gICAgc2l6ZVt2YWx1ZURpbUlkeF0gPSBwb2ludHNbaWkgKyAyXTtcbiAgICBzdGFydFBvaW50W2Jhc2VEaW1JZHhdID0gcG9pbnRzW2lpICsgYmFzZURpbUlkeF07XG4gICAgc3RhcnRQb2ludFt2YWx1ZURpbUlkeF0gPSBwb2ludHNbaWkgKyB2YWx1ZURpbUlkeF07XG4gICAgaWYgKHNpemVbdmFsdWVEaW1JZHhdIDwgMCkge1xuICAgICAgc3RhcnRQb2ludFt2YWx1ZURpbUlkeF0gKz0gc2l6ZVt2YWx1ZURpbUlkeF07XG4gICAgICBzaXplW3ZhbHVlRGltSWR4XSA9IC1zaXplW3ZhbHVlRGltSWR4XTtcbiAgICB9XG4gICAgaWYgKHggPj0gc3RhcnRQb2ludFswXSAmJiB4IDw9IHN0YXJ0UG9pbnRbMF0gKyBzaXplWzBdICYmIHkgPj0gc3RhcnRQb2ludFsxXSAmJiB5IDw9IHN0YXJ0UG9pbnRbMV0gKyBzaXplWzFdKSB7XG4gICAgICByZXR1cm4gbGFyZ2VEYXRhSW5kaWNlc1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gY3JlYXRlQmFja2dyb3VuZFNoYXBlKGlzSG9yaXpvbnRhbE9yUmFkaWFsLCBsYXlvdXQsIGNvb3JkKSB7XG4gIGlmIChpc0Nvb3JkaW5hdGVTeXN0ZW1UeXBlKGNvb3JkLCAnY2FydGVzaWFuMmQnKSkge1xuICAgIHZhciByZWN0U2hhcGUgPSBsYXlvdXQ7XG4gICAgdmFyIGNvb3JkTGF5b3V0ID0gY29vcmQuZ2V0QXJlYSgpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBpc0hvcml6b250YWxPclJhZGlhbCA/IHJlY3RTaGFwZS54IDogY29vcmRMYXlvdXQueCxcbiAgICAgIHk6IGlzSG9yaXpvbnRhbE9yUmFkaWFsID8gY29vcmRMYXlvdXQueSA6IHJlY3RTaGFwZS55LFxuICAgICAgd2lkdGg6IGlzSG9yaXpvbnRhbE9yUmFkaWFsID8gcmVjdFNoYXBlLndpZHRoIDogY29vcmRMYXlvdXQud2lkdGgsXG4gICAgICBoZWlnaHQ6IGlzSG9yaXpvbnRhbE9yUmFkaWFsID8gY29vcmRMYXlvdXQuaGVpZ2h0IDogcmVjdFNoYXBlLmhlaWdodFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvb3JkTGF5b3V0ID0gY29vcmQuZ2V0QXJlYSgpO1xuICAgIHZhciBzZWN0b3JTaGFwZSA9IGxheW91dDtcbiAgICByZXR1cm4ge1xuICAgICAgY3g6IGNvb3JkTGF5b3V0LmN4LFxuICAgICAgY3k6IGNvb3JkTGF5b3V0LmN5LFxuICAgICAgcjA6IGlzSG9yaXpvbnRhbE9yUmFkaWFsID8gY29vcmRMYXlvdXQucjAgOiBzZWN0b3JTaGFwZS5yMCxcbiAgICAgIHI6IGlzSG9yaXpvbnRhbE9yUmFkaWFsID8gY29vcmRMYXlvdXQuciA6IHNlY3RvclNoYXBlLnIsXG4gICAgICBzdGFydEFuZ2xlOiBpc0hvcml6b250YWxPclJhZGlhbCA/IHNlY3RvclNoYXBlLnN0YXJ0QW5nbGUgOiAwLFxuICAgICAgZW5kQW5nbGU6IGlzSG9yaXpvbnRhbE9yUmFkaWFsID8gc2VjdG9yU2hhcGUuZW5kQW5nbGUgOiBNYXRoLlBJICogMlxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhY2tncm91bmRFbChjb29yZCwgaXNIb3Jpem9udGFsT3JSYWRpYWwsIGxheW91dCkge1xuICB2YXIgRWxlbWVudENseiA9IGNvb3JkLnR5cGUgPT09ICdwb2xhcicgPyBTZWN0b3IgOiBSZWN0O1xuICByZXR1cm4gbmV3IEVsZW1lbnRDbHooe1xuICAgIHNoYXBlOiBjcmVhdGVCYWNrZ3JvdW5kU2hhcGUoaXNIb3Jpem9udGFsT3JSYWRpYWwsIGxheW91dCwgY29vcmQpLFxuICAgIHNpbGVudDogdHJ1ZSxcbiAgICB6MjogMFxuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IEJhclZpZXc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///60859\n")},98908:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _model_Series_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47355);\n/* harmony import */ var _helper_createSeriesData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13637);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar BaseBarSeriesModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(BaseBarSeriesModel, _super);\n  function BaseBarSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = BaseBarSeriesModel.type;\n    return _this;\n  }\n  BaseBarSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    return (0,_helper_createSeriesData_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)(null, this, {\n      useEncodeDefaulter: true\n    });\n  };\n  BaseBarSeriesModel.prototype.getMarkerPosition = function (value, dims, startingAtTick) {\n    var coordSys = this.coordinateSystem;\n    if (coordSys && coordSys.clampData) {\n      // PENDING if clamp ?\n      var clampData_1 = coordSys.clampData(value);\n      var pt_1 = coordSys.dataToPoint(clampData_1);\n      if (startingAtTick) {\n        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(coordSys.getAxes(), function (axis, idx) {\n          // If axis type is category, use tick coords instead\n          if (axis.type === 'category' && dims != null) {\n            var tickCoords = axis.getTicksCoords();\n            var alignTicksWithLabel = axis.getTickModel().get('alignWithLabel');\n            var targetTickId = clampData_1[idx];\n            // The index of rightmost tick of markArea is 1 larger than x1/y1 index\n            var isEnd = dims[idx] === 'x1' || dims[idx] === 'y1';\n            if (isEnd && !alignTicksWithLabel) {\n              targetTickId += 1;\n            }\n            // The only contains one tick, tickCoords is\n            // like [{coord: 0, tickValue: 0}, {coord: 0}]\n            // to the length should always be larger than 1\n            if (tickCoords.length < 2) {\n              return;\n            } else if (tickCoords.length === 2) {\n              // The left value and right value of the axis are\n              // the same. coord is 0 in both items. Use the max\n              // value of the axis as the coord\n              pt_1[idx] = axis.toGlobalCoord(axis.getExtent()[isEnd ? 1 : 0]);\n              return;\n            }\n            var leftCoord = void 0;\n            var coord = void 0;\n            var stepTickValue = 1;\n            for (var i = 0; i < tickCoords.length; i++) {\n              var tickCoord = tickCoords[i].coord;\n              // The last item of tickCoords doesn't contain\n              // tickValue\n              var tickValue = i === tickCoords.length - 1 ? tickCoords[i - 1].tickValue + stepTickValue : tickCoords[i].tickValue;\n              if (tickValue === targetTickId) {\n                coord = tickCoord;\n                break;\n              } else if (tickValue < targetTickId) {\n                leftCoord = tickCoord;\n              } else if (leftCoord != null && tickValue > targetTickId) {\n                coord = (tickCoord + leftCoord) / 2;\n                break;\n              }\n              if (i === 1) {\n                // Here we assume the step of category axes is\n                // the same\n                stepTickValue = tickValue - tickCoords[0].tickValue;\n              }\n            }\n            if (coord == null) {\n              if (!leftCoord) {\n                // targetTickId is smaller than all tick ids in the\n                // visible area, use the leftmost tick coord\n                coord = tickCoords[0].coord;\n              } else if (leftCoord) {\n                // targetTickId is larger than all tick ids in the\n                // visible area, use the rightmost tick coord\n                coord = tickCoords[tickCoords.length - 1].coord;\n              }\n            }\n            pt_1[idx] = axis.toGlobalCoord(coord);\n          }\n        });\n      } else {\n        var data = this.getData();\n        var offset = data.getLayout('offset');\n        var size = data.getLayout('size');\n        var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n        pt_1[offsetIndex] += offset + size / 2;\n      }\n      return pt_1;\n    }\n    return [NaN, NaN];\n  };\n  BaseBarSeriesModel.type = 'series.__base_bar__';\n  BaseBarSeriesModel.defaultOption = {\n    // zlevel: 0,\n    z: 2,\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    // stack: null\n    // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    barMinHeight: 0,\n    barMinAngle: 0,\n    // cursor: null,\n    large: false,\n    largeThreshold: 400,\n    progressive: 3e3,\n    progressiveChunkMode: 'mod'\n  };\n  return BaseBarSeriesModel;\n}(_model_Series_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A);\n_model_Series_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A.registerClass(BaseBarSeriesModel);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseBarSeriesModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg5MDguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvQmFzZUJhclNlcmllcy5qcz80OGY4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgU2VyaWVzTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvU2VyaWVzLmpzJztcbmltcG9ydCBjcmVhdGVTZXJpZXNEYXRhIGZyb20gJy4uL2hlbHBlci9jcmVhdGVTZXJpZXNEYXRhLmpzJztcbmltcG9ydCB7IGVhY2ggfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xudmFyIEJhc2VCYXJTZXJpZXNNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhCYXNlQmFyU2VyaWVzTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEJhc2VCYXJTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gQmFzZUJhclNlcmllc01vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEJhc2VCYXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGEgPSBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVNlcmllc0RhdGEobnVsbCwgdGhpcywge1xuICAgICAgdXNlRW5jb2RlRGVmYXVsdGVyOiB0cnVlXG4gICAgfSk7XG4gIH07XG4gIEJhc2VCYXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0TWFya2VyUG9zaXRpb24gPSBmdW5jdGlvbiAodmFsdWUsIGRpbXMsIHN0YXJ0aW5nQXRUaWNrKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gdGhpcy5jb29yZGluYXRlU3lzdGVtO1xuICAgIGlmIChjb29yZFN5cyAmJiBjb29yZFN5cy5jbGFtcERhdGEpIHtcbiAgICAgIC8vIFBFTkRJTkcgaWYgY2xhbXAgP1xuICAgICAgdmFyIGNsYW1wRGF0YV8xID0gY29vcmRTeXMuY2xhbXBEYXRhKHZhbHVlKTtcbiAgICAgIHZhciBwdF8xID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoY2xhbXBEYXRhXzEpO1xuICAgICAgaWYgKHN0YXJ0aW5nQXRUaWNrKSB7XG4gICAgICAgIGVhY2goY29vcmRTeXMuZ2V0QXhlcygpLCBmdW5jdGlvbiAoYXhpcywgaWR4KSB7XG4gICAgICAgICAgLy8gSWYgYXhpcyB0eXBlIGlzIGNhdGVnb3J5LCB1c2UgdGljayBjb29yZHMgaW5zdGVhZFxuICAgICAgICAgIGlmIChheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgJiYgZGltcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgdGlja0Nvb3JkcyA9IGF4aXMuZ2V0VGlja3NDb29yZHMoKTtcbiAgICAgICAgICAgIHZhciBhbGlnblRpY2tzV2l0aExhYmVsID0gYXhpcy5nZXRUaWNrTW9kZWwoKS5nZXQoJ2FsaWduV2l0aExhYmVsJyk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0VGlja0lkID0gY2xhbXBEYXRhXzFbaWR4XTtcbiAgICAgICAgICAgIC8vIFRoZSBpbmRleCBvZiByaWdodG1vc3QgdGljayBvZiBtYXJrQXJlYSBpcyAxIGxhcmdlciB0aGFuIHgxL3kxIGluZGV4XG4gICAgICAgICAgICB2YXIgaXNFbmQgPSBkaW1zW2lkeF0gPT09ICd4MScgfHwgZGltc1tpZHhdID09PSAneTEnO1xuICAgICAgICAgICAgaWYgKGlzRW5kICYmICFhbGlnblRpY2tzV2l0aExhYmVsKSB7XG4gICAgICAgICAgICAgIHRhcmdldFRpY2tJZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIG9ubHkgY29udGFpbnMgb25lIHRpY2ssIHRpY2tDb29yZHMgaXNcbiAgICAgICAgICAgIC8vIGxpa2UgW3tjb29yZDogMCwgdGlja1ZhbHVlOiAwfSwge2Nvb3JkOiAwfV1cbiAgICAgICAgICAgIC8vIHRvIHRoZSBsZW5ndGggc2hvdWxkIGFsd2F5cyBiZSBsYXJnZXIgdGhhbiAxXG4gICAgICAgICAgICBpZiAodGlja0Nvb3Jkcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGlja0Nvb3Jkcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIGxlZnQgdmFsdWUgYW5kIHJpZ2h0IHZhbHVlIG9mIHRoZSBheGlzIGFyZVxuICAgICAgICAgICAgICAvLyB0aGUgc2FtZS4gY29vcmQgaXMgMCBpbiBib3RoIGl0ZW1zLiBVc2UgdGhlIG1heFxuICAgICAgICAgICAgICAvLyB2YWx1ZSBvZiB0aGUgYXhpcyBhcyB0aGUgY29vcmRcbiAgICAgICAgICAgICAgcHRfMVtpZHhdID0gYXhpcy50b0dsb2JhbENvb3JkKGF4aXMuZ2V0RXh0ZW50KClbaXNFbmQgPyAxIDogMF0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVmdENvb3JkID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGNvb3JkID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIHN0ZXBUaWNrVmFsdWUgPSAxO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrQ29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciB0aWNrQ29vcmQgPSB0aWNrQ29vcmRzW2ldLmNvb3JkO1xuICAgICAgICAgICAgICAvLyBUaGUgbGFzdCBpdGVtIG9mIHRpY2tDb29yZHMgZG9lc24ndCBjb250YWluXG4gICAgICAgICAgICAgIC8vIHRpY2tWYWx1ZVxuICAgICAgICAgICAgICB2YXIgdGlja1ZhbHVlID0gaSA9PT0gdGlja0Nvb3Jkcy5sZW5ndGggLSAxID8gdGlja0Nvb3Jkc1tpIC0gMV0udGlja1ZhbHVlICsgc3RlcFRpY2tWYWx1ZSA6IHRpY2tDb29yZHNbaV0udGlja1ZhbHVlO1xuICAgICAgICAgICAgICBpZiAodGlja1ZhbHVlID09PSB0YXJnZXRUaWNrSWQpIHtcbiAgICAgICAgICAgICAgICBjb29yZCA9IHRpY2tDb29yZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aWNrVmFsdWUgPCB0YXJnZXRUaWNrSWQpIHtcbiAgICAgICAgICAgICAgICBsZWZ0Q29vcmQgPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdENvb3JkICE9IG51bGwgJiYgdGlja1ZhbHVlID4gdGFyZ2V0VGlja0lkKSB7XG4gICAgICAgICAgICAgICAgY29vcmQgPSAodGlja0Nvb3JkICsgbGVmdENvb3JkKSAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBIZXJlIHdlIGFzc3VtZSB0aGUgc3RlcCBvZiBjYXRlZ29yeSBheGVzIGlzXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNhbWVcbiAgICAgICAgICAgICAgICBzdGVwVGlja1ZhbHVlID0gdGlja1ZhbHVlIC0gdGlja0Nvb3Jkc1swXS50aWNrVmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmICghbGVmdENvb3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0VGlja0lkIGlzIHNtYWxsZXIgdGhhbiBhbGwgdGljayBpZHMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gdmlzaWJsZSBhcmVhLCB1c2UgdGhlIGxlZnRtb3N0IHRpY2sgY29vcmRcbiAgICAgICAgICAgICAgICBjb29yZCA9IHRpY2tDb29yZHNbMF0uY29vcmQ7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdENvb3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0VGlja0lkIGlzIGxhcmdlciB0aGFuIGFsbCB0aWNrIGlkcyBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyB2aXNpYmxlIGFyZWEsIHVzZSB0aGUgcmlnaHRtb3N0IHRpY2sgY29vcmRcbiAgICAgICAgICAgICAgICBjb29yZCA9IHRpY2tDb29yZHNbdGlja0Nvb3Jkcy5sZW5ndGggLSAxXS5jb29yZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHRfMVtpZHhdID0gYXhpcy50b0dsb2JhbENvb3JkKGNvb3JkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IGRhdGEuZ2V0TGF5b3V0KCdvZmZzZXQnKTtcbiAgICAgICAgdmFyIHNpemUgPSBkYXRhLmdldExheW91dCgnc2l6ZScpO1xuICAgICAgICB2YXIgb2Zmc2V0SW5kZXggPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpLmlzSG9yaXpvbnRhbCgpID8gMCA6IDE7XG4gICAgICAgIHB0XzFbb2Zmc2V0SW5kZXhdICs9IG9mZnNldCArIHNpemUgLyAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB0XzE7XG4gICAgfVxuICAgIHJldHVybiBbTmFOLCBOYU5dO1xuICB9O1xuICBCYXNlQmFyU2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMuX19iYXNlX2Jhcl9fJztcbiAgQmFzZUJhclNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgLy8gemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgY29vcmRpbmF0ZVN5c3RlbTogJ2NhcnRlc2lhbjJkJyxcbiAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG4gICAgLy8gc3RhY2s6IG51bGxcbiAgICAvLyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAvLyB4QXhpc0luZGV4OiAwLFxuICAgIC8vIHlBeGlzSW5kZXg6IDAsXG4gICAgYmFyTWluSGVpZ2h0OiAwLFxuICAgIGJhck1pbkFuZ2xlOiAwLFxuICAgIC8vIGN1cnNvcjogbnVsbCxcbiAgICBsYXJnZTogZmFsc2UsXG4gICAgbGFyZ2VUaHJlc2hvbGQ6IDQwMCxcbiAgICBwcm9ncmVzc2l2ZTogM2UzLFxuICAgIHByb2dyZXNzaXZlQ2h1bmtNb2RlOiAnbW9kJ1xuICB9O1xuICByZXR1cm4gQmFzZUJhclNlcmllc01vZGVsO1xufShTZXJpZXNNb2RlbCk7XG5TZXJpZXNNb2RlbC5yZWdpc3RlckNsYXNzKEJhc2VCYXJTZXJpZXNNb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBCYXNlQmFyU2VyaWVzTW9kZWw7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///98908\n")}}]);