"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[5870],{6129:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ parseConditionalExpression)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41025);\n/* harmony import */ var _data_helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31825);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n;\nvar RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {\n  value: 'eq',\n  // PENDING: not good for literal semantic?\n  '<': 'lt',\n  '<=': 'lte',\n  '>': 'gt',\n  '>=': 'gte',\n  '=': 'eq',\n  '!=': 'ne',\n  '<>': 'ne'\n  // Might be misleading for sake of the difference between '==' and '===',\n  // so don't support them.\n  // '==': 'eq',\n  // '===': 'seq',\n  // '!==': 'sne'\n  // PENDING: Whether support some common alias \"ge\", \"le\", \"neq\"?\n  // ge: 'gte',\n  // le: 'lte',\n  // neq: 'ne',\n};\n// type RelationalExpressionOpEvaluate = (tarVal: unknown, condVal: unknown) => boolean;\nvar RegExpEvaluator = /** @class */function () {\n  function RegExpEvaluator(rVal) {\n    // Support condVal: RegExp | string\n    var condValue = this._condVal = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString)(rVal) ? new RegExp(rVal) : (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isRegExp)(rVal) ? rVal : null;\n    if (condValue == null) {\n      var errMsg = '';\n      if (false) {}\n      (0,_log_js__WEBPACK_IMPORTED_MODULE_1__/* .throwError */ .$8)(errMsg);\n    }\n  }\n  RegExpEvaluator.prototype.evaluate = function (lVal) {\n    var type = typeof lVal;\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString)(type) ? this._condVal.test(lVal) : (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(type) ? this._condVal.test(lVal + '') : false;\n  };\n  return RegExpEvaluator;\n}();\nvar ConstConditionInternal = /** @class */function () {\n  function ConstConditionInternal() {}\n  ConstConditionInternal.prototype.evaluate = function () {\n    return this.value;\n  };\n  return ConstConditionInternal;\n}();\nvar AndConditionInternal = /** @class */function () {\n  function AndConditionInternal() {}\n  AndConditionInternal.prototype.evaluate = function () {\n    var children = this.children;\n    for (var i = 0; i < children.length; i++) {\n      if (!children[i].evaluate()) {\n        return false;\n      }\n    }\n    return true;\n  };\n  return AndConditionInternal;\n}();\nvar OrConditionInternal = /** @class */function () {\n  function OrConditionInternal() {}\n  OrConditionInternal.prototype.evaluate = function () {\n    var children = this.children;\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].evaluate()) {\n        return true;\n      }\n    }\n    return false;\n  };\n  return OrConditionInternal;\n}();\nvar NotConditionInternal = /** @class */function () {\n  function NotConditionInternal() {}\n  NotConditionInternal.prototype.evaluate = function () {\n    return !this.child.evaluate();\n  };\n  return NotConditionInternal;\n}();\nvar RelationalConditionInternal = /** @class */function () {\n  function RelationalConditionInternal() {}\n  RelationalConditionInternal.prototype.evaluate = function () {\n    var needParse = !!this.valueParser;\n    // Call getValue with no `this`.\n    var getValue = this.getValue;\n    var tarValRaw = getValue(this.valueGetterParam);\n    var tarValParsed = needParse ? this.valueParser(tarValRaw) : null;\n    // Relational cond follow \"and\" logic internally.\n    for (var i = 0; i < this.subCondList.length; i++) {\n      if (!this.subCondList[i].evaluate(needParse ? tarValParsed : tarValRaw)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  return RelationalConditionInternal;\n}();\nfunction parseOption(exprOption, getters) {\n  if (exprOption === true || exprOption === false) {\n    var cond = new ConstConditionInternal();\n    cond.value = exprOption;\n    return cond;\n  }\n  var errMsg = '';\n  if (!isObjectNotArray(exprOption)) {\n    if (false) {}\n    (0,_log_js__WEBPACK_IMPORTED_MODULE_1__/* .throwError */ .$8)(errMsg);\n  }\n  if (exprOption.and) {\n    return parseAndOrOption('and', exprOption, getters);\n  } else if (exprOption.or) {\n    return parseAndOrOption('or', exprOption, getters);\n  } else if (exprOption.not) {\n    return parseNotOption(exprOption, getters);\n  }\n  return parseRelationalOption(exprOption, getters);\n}\nfunction parseAndOrOption(op, exprOption, getters) {\n  var subOptionArr = exprOption[op];\n  var errMsg = '';\n  if (false) {}\n  if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(subOptionArr)) {\n    (0,_log_js__WEBPACK_IMPORTED_MODULE_1__/* .throwError */ .$8)(errMsg);\n  }\n  if (!subOptionArr.length) {\n    (0,_log_js__WEBPACK_IMPORTED_MODULE_1__/* .throwError */ .$8)(errMsg);\n  }\n  var cond = op === 'and' ? new AndConditionInternal() : new OrConditionInternal();\n  cond.children = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)(subOptionArr, function (subOption) {\n    return parseOption(subOption, getters);\n  });\n  if (!cond.children.length) {\n    (0,_log_js__WEBPACK_IMPORTED_MODULE_1__/* .throwError */ .$8)(errMsg);\n  }\n  return cond;\n}\nfunction parseNotOption(exprOption, getters) {\n  var subOption = exprOption.not;\n  var errMsg = '';\n  if (false) {}\n  if (!isObjectNotArray(subOption)) {\n    (0,_log_js__WEBPACK_IMPORTED_MODULE_1__/* .throwError */ .$8)(errMsg);\n  }\n  var cond = new NotConditionInternal();\n  cond.child = parseOption(subOption, getters);\n  if (!cond.child) {\n    (0,_log_js__WEBPACK_IMPORTED_MODULE_1__/* .throwError */ .$8)(errMsg);\n  }\n  return cond;\n}\nfunction parseRelationalOption(exprOption, getters) {\n  var errMsg = '';\n  var valueGetterParam = getters.prepareGetValue(exprOption);\n  var subCondList = [];\n  var exprKeys = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys)(exprOption);\n  var parserName = exprOption.parser;\n  var valueParser = parserName ? (0,_data_helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .getRawValueParser */ .zC)(parserName) : null;\n  for (var i = 0; i < exprKeys.length; i++) {\n    var keyRaw = exprKeys[i];\n    if (keyRaw === 'parser' || getters.valueGetterAttrMap.get(keyRaw)) {\n      continue;\n    }\n    var op = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw;\n    var condValueRaw = exprOption[keyRaw];\n    var condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw;\n    var evaluator = (0,_data_helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .createFilterComparator */ .zs)(op, condValueParsed) || op === 'reg' && new RegExpEvaluator(condValueParsed);\n    if (!evaluator) {\n      if (false) {}\n      (0,_log_js__WEBPACK_IMPORTED_MODULE_1__/* .throwError */ .$8)(errMsg);\n    }\n    subCondList.push(evaluator);\n  }\n  if (!subCondList.length) {\n    if (false) {}\n    // No relational operator always disabled in case of dangers result.\n    (0,_log_js__WEBPACK_IMPORTED_MODULE_1__/* .throwError */ .$8)(errMsg);\n  }\n  var cond = new RelationalConditionInternal();\n  cond.valueGetterParam = valueGetterParam;\n  cond.valueParser = valueParser;\n  cond.getValue = getters.getValue;\n  cond.subCondList = subCondList;\n  return cond;\n}\nfunction isObjectNotArray(val) {\n  return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(val) && !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArrayLike)(val);\n}\nvar ConditionalExpressionParsed = /** @class */function () {\n  function ConditionalExpressionParsed(exprOption, getters) {\n    this._cond = parseOption(exprOption, getters);\n  }\n  ConditionalExpressionParsed.prototype.evaluate = function () {\n    return this._cond.evaluate();\n  };\n  return ConditionalExpressionParsed;\n}();\n;\nfunction parseConditionalExpression(exprOption, getters) {\n  return new ConditionalExpressionParsed(exprOption, getters);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEyOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvY29uZGl0aW9uYWxFeHByZXNzaW9uLmpzPzAxY2EiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBrZXlzLCBpc0FycmF5LCBtYXAsIGlzT2JqZWN0LCBpc1N0cmluZywgaXNSZWdFeHAsIGlzQXJyYXlMaWtlLCBoYXNPd24sIGlzTnVtYmVyIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IHRocm93RXJyb3IsIG1ha2VQcmludGFibGUgfSBmcm9tICcuL2xvZy5qcyc7XG5pbXBvcnQgeyBnZXRSYXdWYWx1ZVBhcnNlciwgY3JlYXRlRmlsdGVyQ29tcGFyYXRvciB9IGZyb20gJy4uL2RhdGEvaGVscGVyL2RhdGFWYWx1ZUhlbHBlci5qcyc7XG47XG52YXIgUkVMQVRJT05BTF9FWFBSRVNTSU9OX09QX0FMSUFTX01BUCA9IHtcbiAgdmFsdWU6ICdlcScsXG4gIC8vIFBFTkRJTkc6IG5vdCBnb29kIGZvciBsaXRlcmFsIHNlbWFudGljP1xuICAnPCc6ICdsdCcsXG4gICc8PSc6ICdsdGUnLFxuICAnPic6ICdndCcsXG4gICc+PSc6ICdndGUnLFxuICAnPSc6ICdlcScsXG4gICchPSc6ICduZScsXG4gICc8Pic6ICduZSdcbiAgLy8gTWlnaHQgYmUgbWlzbGVhZGluZyBmb3Igc2FrZSBvZiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuICc9PScgYW5kICc9PT0nLFxuICAvLyBzbyBkb24ndCBzdXBwb3J0IHRoZW0uXG4gIC8vICc9PSc6ICdlcScsXG4gIC8vICc9PT0nOiAnc2VxJyxcbiAgLy8gJyE9PSc6ICdzbmUnXG4gIC8vIFBFTkRJTkc6IFdoZXRoZXIgc3VwcG9ydCBzb21lIGNvbW1vbiBhbGlhcyBcImdlXCIsIFwibGVcIiwgXCJuZXFcIj9cbiAgLy8gZ2U6ICdndGUnLFxuICAvLyBsZTogJ2x0ZScsXG4gIC8vIG5lcTogJ25lJyxcbn07XG4vLyB0eXBlIFJlbGF0aW9uYWxFeHByZXNzaW9uT3BFdmFsdWF0ZSA9ICh0YXJWYWw6IHVua25vd24sIGNvbmRWYWw6IHVua25vd24pID0+IGJvb2xlYW47XG52YXIgUmVnRXhwRXZhbHVhdG9yID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVnRXhwRXZhbHVhdG9yKHJWYWwpIHtcbiAgICAvLyBTdXBwb3J0IGNvbmRWYWw6IFJlZ0V4cCB8IHN0cmluZ1xuICAgIHZhciBjb25kVmFsdWUgPSB0aGlzLl9jb25kVmFsID0gaXNTdHJpbmcoclZhbCkgPyBuZXcgUmVnRXhwKHJWYWwpIDogaXNSZWdFeHAoclZhbCkgPyByVmFsIDogbnVsbDtcbiAgICBpZiAoY29uZFZhbHVlID09IG51bGwpIHtcbiAgICAgIHZhciBlcnJNc2cgPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVyck1zZyA9IG1ha2VQcmludGFibGUoJ0lsbGVnYWwgcmVnZXhwJywgclZhbCwgJ2luJyk7XG4gICAgICB9XG4gICAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gICAgfVxuICB9XG4gIFJlZ0V4cEV2YWx1YXRvci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAobFZhbCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGxWYWw7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHR5cGUpID8gdGhpcy5fY29uZFZhbC50ZXN0KGxWYWwpIDogaXNOdW1iZXIodHlwZSkgPyB0aGlzLl9jb25kVmFsLnRlc3QobFZhbCArICcnKSA6IGZhbHNlO1xuICB9O1xuICByZXR1cm4gUmVnRXhwRXZhbHVhdG9yO1xufSgpO1xudmFyIENvbnN0Q29uZGl0aW9uSW50ZXJuYWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb25zdENvbmRpdGlvbkludGVybmFsKCkge31cbiAgQ29uc3RDb25kaXRpb25JbnRlcm5hbC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH07XG4gIHJldHVybiBDb25zdENvbmRpdGlvbkludGVybmFsO1xufSgpO1xudmFyIEFuZENvbmRpdGlvbkludGVybmFsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5kQ29uZGl0aW9uSW50ZXJuYWwoKSB7fVxuICBBbmRDb25kaXRpb25JbnRlcm5hbC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWNoaWxkcmVuW2ldLmV2YWx1YXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgcmV0dXJuIEFuZENvbmRpdGlvbkludGVybmFsO1xufSgpO1xudmFyIE9yQ29uZGl0aW9uSW50ZXJuYWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPckNvbmRpdGlvbkludGVybmFsKCkge31cbiAgT3JDb25kaXRpb25JbnRlcm5hbC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0uZXZhbHVhdGUoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICByZXR1cm4gT3JDb25kaXRpb25JbnRlcm5hbDtcbn0oKTtcbnZhciBOb3RDb25kaXRpb25JbnRlcm5hbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vdENvbmRpdGlvbkludGVybmFsKCkge31cbiAgTm90Q29uZGl0aW9uSW50ZXJuYWwucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhdGhpcy5jaGlsZC5ldmFsdWF0ZSgpO1xuICB9O1xuICByZXR1cm4gTm90Q29uZGl0aW9uSW50ZXJuYWw7XG59KCk7XG52YXIgUmVsYXRpb25hbENvbmRpdGlvbkludGVybmFsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVsYXRpb25hbENvbmRpdGlvbkludGVybmFsKCkge31cbiAgUmVsYXRpb25hbENvbmRpdGlvbkludGVybmFsLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmVlZFBhcnNlID0gISF0aGlzLnZhbHVlUGFyc2VyO1xuICAgIC8vIENhbGwgZ2V0VmFsdWUgd2l0aCBubyBgdGhpc2AuXG4gICAgdmFyIGdldFZhbHVlID0gdGhpcy5nZXRWYWx1ZTtcbiAgICB2YXIgdGFyVmFsUmF3ID0gZ2V0VmFsdWUodGhpcy52YWx1ZUdldHRlclBhcmFtKTtcbiAgICB2YXIgdGFyVmFsUGFyc2VkID0gbmVlZFBhcnNlID8gdGhpcy52YWx1ZVBhcnNlcih0YXJWYWxSYXcpIDogbnVsbDtcbiAgICAvLyBSZWxhdGlvbmFsIGNvbmQgZm9sbG93IFwiYW5kXCIgbG9naWMgaW50ZXJuYWxseS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3ViQ29uZExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5zdWJDb25kTGlzdFtpXS5ldmFsdWF0ZShuZWVkUGFyc2UgPyB0YXJWYWxQYXJzZWQgOiB0YXJWYWxSYXcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIHJldHVybiBSZWxhdGlvbmFsQ29uZGl0aW9uSW50ZXJuYWw7XG59KCk7XG5mdW5jdGlvbiBwYXJzZU9wdGlvbihleHByT3B0aW9uLCBnZXR0ZXJzKSB7XG4gIGlmIChleHByT3B0aW9uID09PSB0cnVlIHx8IGV4cHJPcHRpb24gPT09IGZhbHNlKSB7XG4gICAgdmFyIGNvbmQgPSBuZXcgQ29uc3RDb25kaXRpb25JbnRlcm5hbCgpO1xuICAgIGNvbmQudmFsdWUgPSBleHByT3B0aW9uO1xuICAgIHJldHVybiBjb25kO1xuICB9XG4gIHZhciBlcnJNc2cgPSAnJztcbiAgaWYgKCFpc09iamVjdE5vdEFycmF5KGV4cHJPcHRpb24pKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGVyck1zZyA9IG1ha2VQcmludGFibGUoJ0lsbGVnYWwgY29uZmlnLiBFeHBlY3QgYSBwbGFpbiBvYmplY3QgYnV0IGFjdHVhbGx5JywgZXhwck9wdGlvbik7XG4gICAgfVxuICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgfVxuICBpZiAoZXhwck9wdGlvbi5hbmQpIHtcbiAgICByZXR1cm4gcGFyc2VBbmRPck9wdGlvbignYW5kJywgZXhwck9wdGlvbiwgZ2V0dGVycyk7XG4gIH0gZWxzZSBpZiAoZXhwck9wdGlvbi5vcikge1xuICAgIHJldHVybiBwYXJzZUFuZE9yT3B0aW9uKCdvcicsIGV4cHJPcHRpb24sIGdldHRlcnMpO1xuICB9IGVsc2UgaWYgKGV4cHJPcHRpb24ubm90KSB7XG4gICAgcmV0dXJuIHBhcnNlTm90T3B0aW9uKGV4cHJPcHRpb24sIGdldHRlcnMpO1xuICB9XG4gIHJldHVybiBwYXJzZVJlbGF0aW9uYWxPcHRpb24oZXhwck9wdGlvbiwgZ2V0dGVycyk7XG59XG5mdW5jdGlvbiBwYXJzZUFuZE9yT3B0aW9uKG9wLCBleHByT3B0aW9uLCBnZXR0ZXJzKSB7XG4gIHZhciBzdWJPcHRpb25BcnIgPSBleHByT3B0aW9uW29wXTtcbiAgdmFyIGVyck1zZyA9ICcnO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGVyck1zZyA9IG1ha2VQcmludGFibGUoJ1wiYW5kXCIvXCJvclwiIGNvbmRpdGlvbiBzaG91bGQgb25seSBiZSBgJyArIG9wICsgJzogWy4uLl1gIGFuZCBtdXN0IG5vdCBiZSBlbXB0eSBhcnJheS4nLCAnSWxsZWdhbCBjb25kaXRpb246JywgZXhwck9wdGlvbik7XG4gIH1cbiAgaWYgKCFpc0FycmF5KHN1Yk9wdGlvbkFycikpIHtcbiAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gIH1cbiAgaWYgKCFzdWJPcHRpb25BcnIubGVuZ3RoKSB7XG4gICAgdGhyb3dFcnJvcihlcnJNc2cpO1xuICB9XG4gIHZhciBjb25kID0gb3AgPT09ICdhbmQnID8gbmV3IEFuZENvbmRpdGlvbkludGVybmFsKCkgOiBuZXcgT3JDb25kaXRpb25JbnRlcm5hbCgpO1xuICBjb25kLmNoaWxkcmVuID0gbWFwKHN1Yk9wdGlvbkFyciwgZnVuY3Rpb24gKHN1Yk9wdGlvbikge1xuICAgIHJldHVybiBwYXJzZU9wdGlvbihzdWJPcHRpb24sIGdldHRlcnMpO1xuICB9KTtcbiAgaWYgKCFjb25kLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgfVxuICByZXR1cm4gY29uZDtcbn1cbmZ1bmN0aW9uIHBhcnNlTm90T3B0aW9uKGV4cHJPcHRpb24sIGdldHRlcnMpIHtcbiAgdmFyIHN1Yk9wdGlvbiA9IGV4cHJPcHRpb24ubm90O1xuICB2YXIgZXJyTXNnID0gJyc7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZXJyTXNnID0gbWFrZVByaW50YWJsZSgnXCJub3RcIiBjb25kaXRpb24gc2hvdWxkIG9ubHkgYmUgYG5vdDoge31gLicsICdJbGxlZ2FsIGNvbmRpdGlvbjonLCBleHByT3B0aW9uKTtcbiAgfVxuICBpZiAoIWlzT2JqZWN0Tm90QXJyYXkoc3ViT3B0aW9uKSkge1xuICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgfVxuICB2YXIgY29uZCA9IG5ldyBOb3RDb25kaXRpb25JbnRlcm5hbCgpO1xuICBjb25kLmNoaWxkID0gcGFyc2VPcHRpb24oc3ViT3B0aW9uLCBnZXR0ZXJzKTtcbiAgaWYgKCFjb25kLmNoaWxkKSB7XG4gICAgdGhyb3dFcnJvcihlcnJNc2cpO1xuICB9XG4gIHJldHVybiBjb25kO1xufVxuZnVuY3Rpb24gcGFyc2VSZWxhdGlvbmFsT3B0aW9uKGV4cHJPcHRpb24sIGdldHRlcnMpIHtcbiAgdmFyIGVyck1zZyA9ICcnO1xuICB2YXIgdmFsdWVHZXR0ZXJQYXJhbSA9IGdldHRlcnMucHJlcGFyZUdldFZhbHVlKGV4cHJPcHRpb24pO1xuICB2YXIgc3ViQ29uZExpc3QgPSBbXTtcbiAgdmFyIGV4cHJLZXlzID0ga2V5cyhleHByT3B0aW9uKTtcbiAgdmFyIHBhcnNlck5hbWUgPSBleHByT3B0aW9uLnBhcnNlcjtcbiAgdmFyIHZhbHVlUGFyc2VyID0gcGFyc2VyTmFtZSA/IGdldFJhd1ZhbHVlUGFyc2VyKHBhcnNlck5hbWUpIDogbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXlSYXcgPSBleHByS2V5c1tpXTtcbiAgICBpZiAoa2V5UmF3ID09PSAncGFyc2VyJyB8fCBnZXR0ZXJzLnZhbHVlR2V0dGVyQXR0ck1hcC5nZXQoa2V5UmF3KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBvcCA9IGhhc093bihSRUxBVElPTkFMX0VYUFJFU1NJT05fT1BfQUxJQVNfTUFQLCBrZXlSYXcpID8gUkVMQVRJT05BTF9FWFBSRVNTSU9OX09QX0FMSUFTX01BUFtrZXlSYXddIDoga2V5UmF3O1xuICAgIHZhciBjb25kVmFsdWVSYXcgPSBleHByT3B0aW9uW2tleVJhd107XG4gICAgdmFyIGNvbmRWYWx1ZVBhcnNlZCA9IHZhbHVlUGFyc2VyID8gdmFsdWVQYXJzZXIoY29uZFZhbHVlUmF3KSA6IGNvbmRWYWx1ZVJhdztcbiAgICB2YXIgZXZhbHVhdG9yID0gY3JlYXRlRmlsdGVyQ29tcGFyYXRvcihvcCwgY29uZFZhbHVlUGFyc2VkKSB8fCBvcCA9PT0gJ3JlZycgJiYgbmV3IFJlZ0V4cEV2YWx1YXRvcihjb25kVmFsdWVQYXJzZWQpO1xuICAgIGlmICghZXZhbHVhdG9yKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBlcnJNc2cgPSBtYWtlUHJpbnRhYmxlKCdJbGxlZ2FsIHJlbGF0aW9uYWwgb3BlcmF0aW9uOiBcIicgKyBrZXlSYXcgKyAnXCIgaW4gY29uZGl0aW9uOicsIGV4cHJPcHRpb24pO1xuICAgICAgfVxuICAgICAgdGhyb3dFcnJvcihlcnJNc2cpO1xuICAgIH1cbiAgICBzdWJDb25kTGlzdC5wdXNoKGV2YWx1YXRvcik7XG4gIH1cbiAgaWYgKCFzdWJDb25kTGlzdC5sZW5ndGgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZXJyTXNnID0gbWFrZVByaW50YWJsZSgnUmVsYXRpb25hbCBjb25kaXRpb24gbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBvcGVyYXRvci4nLCAnSWxsZWdhbCBjb25kaXRpb246JywgZXhwck9wdGlvbik7XG4gICAgfVxuICAgIC8vIE5vIHJlbGF0aW9uYWwgb3BlcmF0b3IgYWx3YXlzIGRpc2FibGVkIGluIGNhc2Ugb2YgZGFuZ2VycyByZXN1bHQuXG4gICAgdGhyb3dFcnJvcihlcnJNc2cpO1xuICB9XG4gIHZhciBjb25kID0gbmV3IFJlbGF0aW9uYWxDb25kaXRpb25JbnRlcm5hbCgpO1xuICBjb25kLnZhbHVlR2V0dGVyUGFyYW0gPSB2YWx1ZUdldHRlclBhcmFtO1xuICBjb25kLnZhbHVlUGFyc2VyID0gdmFsdWVQYXJzZXI7XG4gIGNvbmQuZ2V0VmFsdWUgPSBnZXR0ZXJzLmdldFZhbHVlO1xuICBjb25kLnN1YkNvbmRMaXN0ID0gc3ViQ29uZExpc3Q7XG4gIHJldHVybiBjb25kO1xufVxuZnVuY3Rpb24gaXNPYmplY3ROb3RBcnJheSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXlMaWtlKHZhbCk7XG59XG52YXIgQ29uZGl0aW9uYWxFeHByZXNzaW9uUGFyc2VkID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByZXNzaW9uUGFyc2VkKGV4cHJPcHRpb24sIGdldHRlcnMpIHtcbiAgICB0aGlzLl9jb25kID0gcGFyc2VPcHRpb24oZXhwck9wdGlvbiwgZ2V0dGVycyk7XG4gIH1cbiAgQ29uZGl0aW9uYWxFeHByZXNzaW9uUGFyc2VkLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZC5ldmFsdWF0ZSgpO1xuICB9O1xuICByZXR1cm4gQ29uZGl0aW9uYWxFeHByZXNzaW9uUGFyc2VkO1xufSgpO1xuO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKGV4cHJPcHRpb24sIGdldHRlcnMpIHtcbiAgcmV0dXJuIG5ldyBDb25kaXRpb25hbEV4cHJlc3Npb25QYXJzZWQoZXhwck9wdGlvbiwgZ2V0dGVycyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6129\n")},6666:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(98026);\n/* harmony import */ var zrender_lib_graphic_Group_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43870);\n/* harmony import */ var _util_component_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12616);\n/* harmony import */ var _util_clazz_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(30693);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n/* harmony import */ var _util_states_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(34833);\n/* harmony import */ var _core_task_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49431);\n/* harmony import */ var _chart_helper_createRenderPlanner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87582);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(43199);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\nvar inner = _util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r();\nvar renderPlanner = (0,_chart_helper_createRenderPlanner_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)();\nvar ChartView = /** @class */function () {\n  function ChartView() {\n    this.group = new zrender_lib_graphic_Group_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A();\n    this.uid = _util_component_js__WEBPACK_IMPORTED_MODULE_3__/* .getUID */ .$Q('viewChart');\n    this.renderTask = (0,_core_task_js__WEBPACK_IMPORTED_MODULE_4__/* .createTask */ .U)({\n      plan: renderTaskPlan,\n      reset: renderTaskReset\n    });\n    this.renderTask.context = {\n      view: this\n    };\n  }\n  ChartView.prototype.init = function (ecModel, api) {};\n  ChartView.prototype.render = function (seriesModel, ecModel, api, payload) {\n    if (false) {}\n  };\n  /**\r\n   * Highlight series or specified data item.\r\n   */\n  ChartView.prototype.highlight = function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData(payload && payload.dataType);\n    if (!data) {\n      if (false) {}\n      return;\n    }\n    toggleHighlight(data, payload, 'emphasis');\n  };\n  /**\r\n   * Downplay series or specified data item.\r\n   */\n  ChartView.prototype.downplay = function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData(payload && payload.dataType);\n    if (!data) {\n      if (false) {}\n      return;\n    }\n    toggleHighlight(data, payload, 'normal');\n  };\n  /**\r\n   * Remove self.\r\n   */\n  ChartView.prototype.remove = function (ecModel, api) {\n    this.group.removeAll();\n  };\n  /**\r\n   * Dispose self.\r\n   */\n  ChartView.prototype.dispose = function (ecModel, api) {};\n  ChartView.prototype.updateView = function (seriesModel, ecModel, api, payload) {\n    this.render(seriesModel, ecModel, api, payload);\n  };\n  // FIXME never used?\n  ChartView.prototype.updateLayout = function (seriesModel, ecModel, api, payload) {\n    this.render(seriesModel, ecModel, api, payload);\n  };\n  // FIXME never used?\n  ChartView.prototype.updateVisual = function (seriesModel, ecModel, api, payload) {\n    this.render(seriesModel, ecModel, api, payload);\n  };\n  /**\r\n   * Traverse the new rendered elements.\r\n   *\r\n   * It will traverse the new added element in progressive rendering.\r\n   * And traverse all in normal rendering.\r\n   */\n  ChartView.prototype.eachRendered = function (cb) {\n    (0,_util_graphic_js__WEBPACK_IMPORTED_MODULE_5__.traverseElements)(this.group, cb);\n  };\n  ChartView.markUpdateMethod = function (payload, methodName) {\n    inner(payload).updateMethod = methodName;\n  };\n  ChartView.protoInitialize = function () {\n    var proto = ChartView.prototype;\n    proto.type = 'chart';\n  }();\n  return ChartView;\n}();\n;\n/**\r\n * Set state of single element\r\n */\nfunction elSetState(el, state, highlightDigit) {\n  if (el && (0,_util_states_js__WEBPACK_IMPORTED_MODULE_6__/* .isHighDownDispatcher */ .u6)(el)) {\n    (state === 'emphasis' ? _util_states_js__WEBPACK_IMPORTED_MODULE_6__/* .enterEmphasis */ .HY : _util_states_js__WEBPACK_IMPORTED_MODULE_6__/* .leaveEmphasis */ .SD)(el, highlightDigit);\n  }\n}\nfunction toggleHighlight(data, payload, state) {\n  var dataIndex = _util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .queryDataIndex */ .le(data, payload);\n  var highlightDigit = payload && payload.highlightKey != null ? (0,_util_states_js__WEBPACK_IMPORTED_MODULE_6__/* .getHighlightDigit */ ._n)(payload.highlightKey) : null;\n  if (dataIndex != null) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_7__.each)(_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .normalizeToArray */ .qB(dataIndex), function (dataIdx) {\n      elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);\n    });\n  } else {\n    data.eachItemGraphicEl(function (el) {\n      elSetState(el, state, highlightDigit);\n    });\n  }\n}\n_util_clazz_js__WEBPACK_IMPORTED_MODULE_8__/* .enableClassExtend */ .gq(ChartView, ['dispose']);\n_util_clazz_js__WEBPACK_IMPORTED_MODULE_8__/* .enableClassManagement */ .tQ(ChartView);\nfunction renderTaskPlan(context) {\n  return renderPlanner(context.model);\n}\nfunction renderTaskReset(context) {\n  var seriesModel = context.model;\n  var ecModel = context.ecModel;\n  var api = context.api;\n  var payload = context.payload;\n  // FIXME: remove updateView updateVisual\n  var progressiveRender = seriesModel.pipelineContext.progressiveRender;\n  var view = context.view;\n  var updateMethod = payload && inner(payload).updateMethod;\n  var methodName = progressiveRender ? 'incrementalPrepareRender' : updateMethod && view[updateMethod] ? updateMethod\n  // `appendData` is also supported when data amount\n  // is less than progressive threshold.\n  : 'render';\n  if (methodName !== 'render') {\n    view[methodName](seriesModel, ecModel, api, payload);\n  }\n  return progressMethodMap[methodName];\n}\nvar progressMethodMap = {\n  incrementalPrepareRender: {\n    progress: function (params, context) {\n      context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);\n    }\n  },\n  render: {\n    // Put view.render in `progress` to support appendData. But in this case\n    // view.render should not be called in reset, otherwise it will be called\n    // twise. Use `forceFirstProgress` to make sure that view.render is called\n    // in any cases.\n    forceFirstProgress: true,\n    progress: function (params, context) {\n      context.view.render(context.model, context.ecModel, context.api, context.payload);\n    }\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChartView);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjY2Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlldy9DaGFydC5qcz80ZTRiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgR3JvdXAgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9Hcm91cC5qcyc7XG5pbXBvcnQgKiBhcyBjb21wb25lbnRVdGlsIGZyb20gJy4uL3V0aWwvY29tcG9uZW50LmpzJztcbmltcG9ydCAqIGFzIGNsYXp6VXRpbCBmcm9tICcuLi91dGlsL2NsYXp6LmpzJztcbmltcG9ydCAqIGFzIG1vZGVsVXRpbCBmcm9tICcuLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCB7IGVudGVyRW1waGFzaXMsIGxlYXZlRW1waGFzaXMsIGdldEhpZ2hsaWdodERpZ2l0LCBpc0hpZ2hEb3duRGlzcGF0Y2hlciB9IGZyb20gJy4uL3V0aWwvc3RhdGVzLmpzJztcbmltcG9ydCB7IGNyZWF0ZVRhc2sgfSBmcm9tICcuLi9jb3JlL3Rhc2suanMnO1xuaW1wb3J0IGNyZWF0ZVJlbmRlclBsYW5uZXIgZnJvbSAnLi4vY2hhcnQvaGVscGVyL2NyZWF0ZVJlbmRlclBsYW5uZXIuanMnO1xuaW1wb3J0IHsgdHJhdmVyc2VFbGVtZW50cyB9IGZyb20gJy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBlcnJvciB9IGZyb20gJy4uL3V0aWwvbG9nLmpzJztcbnZhciBpbm5lciA9IG1vZGVsVXRpbC5tYWtlSW5uZXIoKTtcbnZhciByZW5kZXJQbGFubmVyID0gY3JlYXRlUmVuZGVyUGxhbm5lcigpO1xudmFyIENoYXJ0VmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENoYXJ0VmlldygpIHtcbiAgICB0aGlzLmdyb3VwID0gbmV3IEdyb3VwKCk7XG4gICAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgndmlld0NoYXJ0Jyk7XG4gICAgdGhpcy5yZW5kZXJUYXNrID0gY3JlYXRlVGFzayh7XG4gICAgICBwbGFuOiByZW5kZXJUYXNrUGxhbixcbiAgICAgIHJlc2V0OiByZW5kZXJUYXNrUmVzZXRcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlclRhc2suY29udGV4dCA9IHtcbiAgICAgIHZpZXc6IHRoaXNcbiAgICB9O1xuICB9XG4gIENoYXJ0Vmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHt9O1xuICBDaGFydFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVuZGVyIG1ldGhvZCBtdXN0IGJlZW4gaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEhpZ2hsaWdodCBzZXJpZXMgb3Igc3BlY2lmaWVkIGRhdGEgaXRlbS5cclxuICAgKi9cbiAgQ2hhcnRWaWV3LnByb3RvdHlwZS5oaWdobGlnaHQgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YShwYXlsb2FkICYmIHBheWxvYWQuZGF0YVR5cGUpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3IoXCJVbmtub3duIGRhdGFUeXBlIFwiICsgcGF5bG9hZC5kYXRhVHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRvZ2dsZUhpZ2hsaWdodChkYXRhLCBwYXlsb2FkLCAnZW1waGFzaXMnKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogRG93bnBsYXkgc2VyaWVzIG9yIHNwZWNpZmllZCBkYXRhIGl0ZW0uXHJcbiAgICovXG4gIENoYXJ0Vmlldy5wcm90b3R5cGUuZG93bnBsYXkgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YShwYXlsb2FkICYmIHBheWxvYWQuZGF0YVR5cGUpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3IoXCJVbmtub3duIGRhdGFUeXBlIFwiICsgcGF5bG9hZC5kYXRhVHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRvZ2dsZUhpZ2hsaWdodChkYXRhLCBwYXlsb2FkLCAnbm9ybWFsJyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbW92ZSBzZWxmLlxyXG4gICAqL1xuICBDaGFydFZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICB9O1xuICAvKipcclxuICAgKiBEaXNwb3NlIHNlbGYuXHJcbiAgICovXG4gIENoYXJ0Vmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHt9O1xuICBDaGFydFZpZXcucHJvdG90eXBlLnVwZGF0ZVZpZXcgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMucmVuZGVyKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICB9O1xuICAvLyBGSVhNRSBuZXZlciB1c2VkP1xuICBDaGFydFZpZXcucHJvdG90eXBlLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdGhpcy5yZW5kZXIoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gIH07XG4gIC8vIEZJWE1FIG5ldmVyIHVzZWQ/XG4gIENoYXJ0Vmlldy5wcm90b3R5cGUudXBkYXRlVmlzdWFsID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB0aGlzLnJlbmRlcihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVHJhdmVyc2UgdGhlIG5ldyByZW5kZXJlZCBlbGVtZW50cy5cclxuICAgKlxyXG4gICAqIEl0IHdpbGwgdHJhdmVyc2UgdGhlIG5ldyBhZGRlZCBlbGVtZW50IGluIHByb2dyZXNzaXZlIHJlbmRlcmluZy5cclxuICAgKiBBbmQgdHJhdmVyc2UgYWxsIGluIG5vcm1hbCByZW5kZXJpbmcuXHJcbiAgICovXG4gIENoYXJ0Vmlldy5wcm90b3R5cGUuZWFjaFJlbmRlcmVkID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgdHJhdmVyc2VFbGVtZW50cyh0aGlzLmdyb3VwLCBjYik7XG4gIH07XG4gIENoYXJ0Vmlldy5tYXJrVXBkYXRlTWV0aG9kID0gZnVuY3Rpb24gKHBheWxvYWQsIG1ldGhvZE5hbWUpIHtcbiAgICBpbm5lcihwYXlsb2FkKS51cGRhdGVNZXRob2QgPSBtZXRob2ROYW1lO1xuICB9O1xuICBDaGFydFZpZXcucHJvdG9Jbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm90byA9IENoYXJ0Vmlldy5wcm90b3R5cGU7XG4gICAgcHJvdG8udHlwZSA9ICdjaGFydCc7XG4gIH0oKTtcbiAgcmV0dXJuIENoYXJ0Vmlldztcbn0oKTtcbjtcbi8qKlxyXG4gKiBTZXQgc3RhdGUgb2Ygc2luZ2xlIGVsZW1lbnRcclxuICovXG5mdW5jdGlvbiBlbFNldFN0YXRlKGVsLCBzdGF0ZSwgaGlnaGxpZ2h0RGlnaXQpIHtcbiAgaWYgKGVsICYmIGlzSGlnaERvd25EaXNwYXRjaGVyKGVsKSkge1xuICAgIChzdGF0ZSA9PT0gJ2VtcGhhc2lzJyA/IGVudGVyRW1waGFzaXMgOiBsZWF2ZUVtcGhhc2lzKShlbCwgaGlnaGxpZ2h0RGlnaXQpO1xuICB9XG59XG5mdW5jdGlvbiB0b2dnbGVIaWdobGlnaHQoZGF0YSwgcGF5bG9hZCwgc3RhdGUpIHtcbiAgdmFyIGRhdGFJbmRleCA9IG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleChkYXRhLCBwYXlsb2FkKTtcbiAgdmFyIGhpZ2hsaWdodERpZ2l0ID0gcGF5bG9hZCAmJiBwYXlsb2FkLmhpZ2hsaWdodEtleSAhPSBudWxsID8gZ2V0SGlnaGxpZ2h0RGlnaXQocGF5bG9hZC5oaWdobGlnaHRLZXkpIDogbnVsbDtcbiAgaWYgKGRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgZWFjaChtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShkYXRhSW5kZXgpLCBmdW5jdGlvbiAoZGF0YUlkeCkge1xuICAgICAgZWxTZXRTdGF0ZShkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUlkeCksIHN0YXRlLCBoaWdobGlnaHREaWdpdCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsU2V0U3RhdGUoZWwsIHN0YXRlLCBoaWdobGlnaHREaWdpdCk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChDaGFydFZpZXcsIFsnZGlzcG9zZSddKTtcbmNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoQ2hhcnRWaWV3KTtcbmZ1bmN0aW9uIHJlbmRlclRhc2tQbGFuKGNvbnRleHQpIHtcbiAgcmV0dXJuIHJlbmRlclBsYW5uZXIoY29udGV4dC5tb2RlbCk7XG59XG5mdW5jdGlvbiByZW5kZXJUYXNrUmVzZXQoY29udGV4dCkge1xuICB2YXIgc2VyaWVzTW9kZWwgPSBjb250ZXh0Lm1vZGVsO1xuICB2YXIgZWNNb2RlbCA9IGNvbnRleHQuZWNNb2RlbDtcbiAgdmFyIGFwaSA9IGNvbnRleHQuYXBpO1xuICB2YXIgcGF5bG9hZCA9IGNvbnRleHQucGF5bG9hZDtcbiAgLy8gRklYTUU6IHJlbW92ZSB1cGRhdGVWaWV3IHVwZGF0ZVZpc3VhbFxuICB2YXIgcHJvZ3Jlc3NpdmVSZW5kZXIgPSBzZXJpZXNNb2RlbC5waXBlbGluZUNvbnRleHQucHJvZ3Jlc3NpdmVSZW5kZXI7XG4gIHZhciB2aWV3ID0gY29udGV4dC52aWV3O1xuICB2YXIgdXBkYXRlTWV0aG9kID0gcGF5bG9hZCAmJiBpbm5lcihwYXlsb2FkKS51cGRhdGVNZXRob2Q7XG4gIHZhciBtZXRob2ROYW1lID0gcHJvZ3Jlc3NpdmVSZW5kZXIgPyAnaW5jcmVtZW50YWxQcmVwYXJlUmVuZGVyJyA6IHVwZGF0ZU1ldGhvZCAmJiB2aWV3W3VwZGF0ZU1ldGhvZF0gPyB1cGRhdGVNZXRob2RcbiAgLy8gYGFwcGVuZERhdGFgIGlzIGFsc28gc3VwcG9ydGVkIHdoZW4gZGF0YSBhbW91bnRcbiAgLy8gaXMgbGVzcyB0aGFuIHByb2dyZXNzaXZlIHRocmVzaG9sZC5cbiAgOiAncmVuZGVyJztcbiAgaWYgKG1ldGhvZE5hbWUgIT09ICdyZW5kZXInKSB7XG4gICAgdmlld1ttZXRob2ROYW1lXShzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgfVxuICByZXR1cm4gcHJvZ3Jlc3NNZXRob2RNYXBbbWV0aG9kTmFtZV07XG59XG52YXIgcHJvZ3Jlc3NNZXRob2RNYXAgPSB7XG4gIGluY3JlbWVudGFsUHJlcGFyZVJlbmRlcjoge1xuICAgIHByb2dyZXNzOiBmdW5jdGlvbiAocGFyYW1zLCBjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LnZpZXcuaW5jcmVtZW50YWxSZW5kZXIocGFyYW1zLCBjb250ZXh0Lm1vZGVsLCBjb250ZXh0LmVjTW9kZWwsIGNvbnRleHQuYXBpLCBjb250ZXh0LnBheWxvYWQpO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiB7XG4gICAgLy8gUHV0IHZpZXcucmVuZGVyIGluIGBwcm9ncmVzc2AgdG8gc3VwcG9ydCBhcHBlbmREYXRhLiBCdXQgaW4gdGhpcyBjYXNlXG4gICAgLy8gdmlldy5yZW5kZXIgc2hvdWxkIG5vdCBiZSBjYWxsZWQgaW4gcmVzZXQsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGNhbGxlZFxuICAgIC8vIHR3aXNlLiBVc2UgYGZvcmNlRmlyc3RQcm9ncmVzc2AgdG8gbWFrZSBzdXJlIHRoYXQgdmlldy5yZW5kZXIgaXMgY2FsbGVkXG4gICAgLy8gaW4gYW55IGNhc2VzLlxuICAgIGZvcmNlRmlyc3RQcm9ncmVzczogdHJ1ZSxcbiAgICBwcm9ncmVzczogZnVuY3Rpb24gKHBhcmFtcywgY29udGV4dCkge1xuICAgICAgY29udGV4dC52aWV3LnJlbmRlcihjb250ZXh0Lm1vZGVsLCBjb250ZXh0LmVjTW9kZWwsIGNvbnRleHQuYXBpLCBjb250ZXh0LnBheWxvYWQpO1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IENoYXJ0VmlldzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6666\n")},8957:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   J: () => (/* binding */ createFloat32Array)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/* global Float32Array */\nvar supportFloat32Array = typeof Float32Array !== \'undefined\';\nvar Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;\nfunction createFloat32Array(arg) {\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(arg)) {\n    // Return self directly if don\'t support TypedArray.\n    return supportFloat32Array ? new Float32Array(arg) : arg;\n  }\n  // Else is number\n  return new Float32ArrayCtor(arg);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk1Ny5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC92ZW5kb3IuanM/YzdiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuLyogZ2xvYmFsIEZsb2F0MzJBcnJheSAqL1xudmFyIHN1cHBvcnRGbG9hdDMyQXJyYXkgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJztcbnZhciBGbG9hdDMyQXJyYXlDdG9yID0gIXN1cHBvcnRGbG9hdDMyQXJyYXkgPyBBcnJheSA6IEZsb2F0MzJBcnJheTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGbG9hdDMyQXJyYXkoYXJnKSB7XG4gIGlmIChpc0FycmF5KGFyZykpIHtcbiAgICAvLyBSZXR1cm4gc2VsZiBkaXJlY3RseSBpZiBkb24ndCBzdXBwb3J0IFR5cGVkQXJyYXkuXG4gICAgcmV0dXJuIHN1cHBvcnRGbG9hdDMyQXJyYXkgPyBuZXcgRmxvYXQzMkFycmF5KGFyZykgOiBhcmc7XG4gIH1cbiAgLy8gRWxzZSBpcyBudW1iZXJcbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXlDdG9yKGFyZyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8957\n')},9848:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fs: () => (/* binding */ convertToEC4StyleForCustomSerise),\n/* harmony export */   ex: () => (/* binding */ isEC4CompatibleStyle),\n/* harmony export */   lH: () => (/* binding */ convertFromEC4CompatibleStyle)\n/* harmony export */ });\n/* unused harmony export warnDeprecated */\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar deprecatedLogs = {};\n/**\r\n * Whether need to call `convertEC4CompatibleStyle`.\r\n */\nfunction isEC4CompatibleStyle(style, elType, hasOwnTextContentOption, hasOwnTextConfig) {\n  // Since echarts5, `RectText` is separated from its host element and style.text\n  // does not exist any more. The compat work brings some extra burden on performance.\n  // So we provide:\n  // `legacy: true` force make compat.\n  // `legacy: false`, force do not compat.\n  // `legacy` not set: auto detect whether legacy.\n  //     But in this case we do not compat (difficult to detect and rare case):\n  //     Becuse custom series and graphic component support \"merge\", users may firstly\n  //     only set `textStrokeWidth` style or secondly only set `text`.\n  return style && (style.legacy || style.legacy !== false && !hasOwnTextContentOption && !hasOwnTextConfig && elType !== 'tspan'\n  // Difficult to detect whether legacy for a \"text\" el.\n  && (elType === 'text' || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(style, 'text')));\n}\n/**\r\n * `EC4CompatibleStyle` is style that might be in echarts4 format or echarts5 format.\r\n * @param hostStyle The properties might be modified.\r\n * @return If be text el, `textContentStyle` and `textConfig` will not be returned.\r\n *         Otherwise a `textContentStyle` and `textConfig` will be created, whose props area\r\n *         retried from the `hostStyle`.\r\n */\nfunction convertFromEC4CompatibleStyle(hostStyle, elType, isNormal) {\n  var srcStyle = hostStyle;\n  var textConfig;\n  var textContent;\n  var textContentStyle;\n  if (elType === 'text') {\n    textContentStyle = srcStyle;\n  } else {\n    textContentStyle = {};\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'text') && (textContentStyle.text = srcStyle.text);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'rich') && (textContentStyle.rich = srcStyle.rich);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'textFill') && (textContentStyle.fill = srcStyle.textFill);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'textStroke') && (textContentStyle.stroke = srcStyle.textStroke);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'fontFamily') && (textContentStyle.fontFamily = srcStyle.fontFamily);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'fontSize') && (textContentStyle.fontSize = srcStyle.fontSize);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'fontStyle') && (textContentStyle.fontStyle = srcStyle.fontStyle);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'fontWeight') && (textContentStyle.fontWeight = srcStyle.fontWeight);\n    textContent = {\n      type: 'text',\n      style: textContentStyle,\n      // ec4 does not support rectText trigger.\n      // And when text position is different in normal and emphasis\n      // => hover text trigger emphasis;\n      // => text position changed, leave mouse pointer immediately;\n      // That might cause incorrect state.\n      silent: true\n    };\n    textConfig = {};\n    var hasOwnPos = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'textPosition');\n    if (isNormal) {\n      textConfig.position = hasOwnPos ? srcStyle.textPosition : 'inside';\n    } else {\n      hasOwnPos && (textConfig.position = srcStyle.textPosition);\n    }\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'textPosition') && (textConfig.position = srcStyle.textPosition);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'textOffset') && (textConfig.offset = srcStyle.textOffset);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'textRotation') && (textConfig.rotation = srcStyle.textRotation);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(srcStyle, 'textDistance') && (textConfig.distance = srcStyle.textDistance);\n  }\n  convertEC4CompatibleRichItem(textContentStyle, hostStyle);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(textContentStyle.rich, function (richItem) {\n    convertEC4CompatibleRichItem(richItem, richItem);\n  });\n  return {\n    textConfig: textConfig,\n    textContent: textContent\n  };\n}\n/**\r\n * The result will be set to `out`.\r\n */\nfunction convertEC4CompatibleRichItem(out, richItem) {\n  if (!richItem) {\n    return;\n  }\n  // (1) For simplicity, make textXXX properties (deprecated since ec5) has\n  // higher priority. For example, consider in ec4 `borderColor: 5, textBorderColor: 10`\n  // on a rect means `borderColor: 4` on the rect and `borderColor: 10` on an attached\n  // richText in ec5.\n  // (2) `out === richItem` if and only if `out` is text el or rich item.\n  // So we can overwrite existing props in `out` since textXXX has higher priority.\n  richItem.font = richItem.textFont || richItem.font;\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textStrokeWidth') && (out.lineWidth = richItem.textStrokeWidth);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textAlign') && (out.align = richItem.textAlign);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textVerticalAlign') && (out.verticalAlign = richItem.textVerticalAlign);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textLineHeight') && (out.lineHeight = richItem.textLineHeight);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textWidth') && (out.width = richItem.textWidth);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textHeight') && (out.height = richItem.textHeight);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBackgroundColor') && (out.backgroundColor = richItem.textBackgroundColor);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textPadding') && (out.padding = richItem.textPadding);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBorderColor') && (out.borderColor = richItem.textBorderColor);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBorderWidth') && (out.borderWidth = richItem.textBorderWidth);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBorderRadius') && (out.borderRadius = richItem.textBorderRadius);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBoxShadowColor') && (out.shadowColor = richItem.textBoxShadowColor);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBoxShadowBlur') && (out.shadowBlur = richItem.textBoxShadowBlur);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBoxShadowOffsetX') && (out.shadowOffsetX = richItem.textBoxShadowOffsetX);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textBoxShadowOffsetY') && (out.shadowOffsetY = richItem.textBoxShadowOffsetY);\n}\n/**\r\n * Convert to pure echarts4 format style.\r\n * `itemStyle` will be modified, added with ec4 style properties from\r\n * `textStyle` and `textConfig`.\r\n *\r\n * [Caveat]: For simplicity, `insideRollback` in ec4 does not compat, where\r\n * `styleEmphasis: {textFill: 'red'}` will remove the normal auto added stroke.\r\n */\nfunction convertToEC4StyleForCustomSerise(itemStl, txStl, txCfg) {\n  var out = itemStl;\n  // See `custom.ts`, a trick to set extra `textPosition` firstly.\n  out.textPosition = out.textPosition || txCfg.position || 'inside';\n  txCfg.offset != null && (out.textOffset = txCfg.offset);\n  txCfg.rotation != null && (out.textRotation = txCfg.rotation);\n  txCfg.distance != null && (out.textDistance = txCfg.distance);\n  var isInside = out.textPosition.indexOf('inside') >= 0;\n  var hostFill = itemStl.fill || '#000';\n  convertToEC4RichItem(out, txStl);\n  var textFillNotSet = out.textFill == null;\n  if (isInside) {\n    if (textFillNotSet) {\n      out.textFill = txCfg.insideFill || '#fff';\n      !out.textStroke && txCfg.insideStroke && (out.textStroke = txCfg.insideStroke);\n      !out.textStroke && (out.textStroke = hostFill);\n      out.textStrokeWidth == null && (out.textStrokeWidth = 2);\n    }\n  } else {\n    if (textFillNotSet) {\n      out.textFill = itemStl.fill || txCfg.outsideFill || '#000';\n    }\n    !out.textStroke && txCfg.outsideStroke && (out.textStroke = txCfg.outsideStroke);\n  }\n  out.text = txStl.text;\n  out.rich = txStl.rich;\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(txStl.rich, function (richItem) {\n    convertToEC4RichItem(richItem, richItem);\n  });\n  return out;\n}\nfunction convertToEC4RichItem(out, richItem) {\n  if (!richItem) {\n    return;\n  }\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'fill') && (out.textFill = richItem.fill);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'stroke') && (out.textStroke = richItem.fill);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'lineWidth') && (out.textStrokeWidth = richItem.lineWidth);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'font') && (out.font = richItem.font);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'fontStyle') && (out.fontStyle = richItem.fontStyle);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'fontWeight') && (out.fontWeight = richItem.fontWeight);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'fontSize') && (out.fontSize = richItem.fontSize);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'fontFamily') && (out.fontFamily = richItem.fontFamily);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'align') && (out.textAlign = richItem.align);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'verticalAlign') && (out.textVerticalAlign = richItem.verticalAlign);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'lineHeight') && (out.textLineHeight = richItem.lineHeight);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'width') && (out.textWidth = richItem.width);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'height') && (out.textHeight = richItem.height);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'backgroundColor') && (out.textBackgroundColor = richItem.backgroundColor);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'padding') && (out.textPadding = richItem.padding);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'borderColor') && (out.textBorderColor = richItem.borderColor);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'borderWidth') && (out.textBorderWidth = richItem.borderWidth);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'borderRadius') && (out.textBorderRadius = richItem.borderRadius);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'shadowColor') && (out.textBoxShadowColor = richItem.shadowColor);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'shadowBlur') && (out.textBoxShadowBlur = richItem.shadowBlur);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'shadowOffsetX') && (out.textBoxShadowOffsetX = richItem.shadowOffsetX);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'shadowOffsetY') && (out.textBoxShadowOffsetY = richItem.shadowOffsetY);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textShadowColor') && (out.textShadowColor = richItem.textShadowColor);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textShadowBlur') && (out.textShadowBlur = richItem.textShadowBlur);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textShadowOffsetX') && (out.textShadowOffsetX = richItem.textShadowOffsetX);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(richItem, 'textShadowOffsetY') && (out.textShadowOffsetY = richItem.textShadowOffsetY);\n}\nfunction warnDeprecated(deprecated, insteadApproach) {\n  if (false) { var key; }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg0OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9zdHlsZUNvbXBhdC5qcz8yZTczIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgZWFjaCwgaGFzT3duIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbnZhciBkZXByZWNhdGVkTG9ncyA9IHt9O1xuLyoqXHJcbiAqIFdoZXRoZXIgbmVlZCB0byBjYWxsIGBjb252ZXJ0RUM0Q29tcGF0aWJsZVN0eWxlYC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFQzRDb21wYXRpYmxlU3R5bGUoc3R5bGUsIGVsVHlwZSwgaGFzT3duVGV4dENvbnRlbnRPcHRpb24sIGhhc093blRleHRDb25maWcpIHtcbiAgLy8gU2luY2UgZWNoYXJ0czUsIGBSZWN0VGV4dGAgaXMgc2VwYXJhdGVkIGZyb20gaXRzIGhvc3QgZWxlbWVudCBhbmQgc3R5bGUudGV4dFxuICAvLyBkb2VzIG5vdCBleGlzdCBhbnkgbW9yZS4gVGhlIGNvbXBhdCB3b3JrIGJyaW5ncyBzb21lIGV4dHJhIGJ1cmRlbiBvbiBwZXJmb3JtYW5jZS5cbiAgLy8gU28gd2UgcHJvdmlkZTpcbiAgLy8gYGxlZ2FjeTogdHJ1ZWAgZm9yY2UgbWFrZSBjb21wYXQuXG4gIC8vIGBsZWdhY3k6IGZhbHNlYCwgZm9yY2UgZG8gbm90IGNvbXBhdC5cbiAgLy8gYGxlZ2FjeWAgbm90IHNldDogYXV0byBkZXRlY3Qgd2hldGhlciBsZWdhY3kuXG4gIC8vICAgICBCdXQgaW4gdGhpcyBjYXNlIHdlIGRvIG5vdCBjb21wYXQgKGRpZmZpY3VsdCB0byBkZXRlY3QgYW5kIHJhcmUgY2FzZSk6XG4gIC8vICAgICBCZWN1c2UgY3VzdG9tIHNlcmllcyBhbmQgZ3JhcGhpYyBjb21wb25lbnQgc3VwcG9ydCBcIm1lcmdlXCIsIHVzZXJzIG1heSBmaXJzdGx5XG4gIC8vICAgICBvbmx5IHNldCBgdGV4dFN0cm9rZVdpZHRoYCBzdHlsZSBvciBzZWNvbmRseSBvbmx5IHNldCBgdGV4dGAuXG4gIHJldHVybiBzdHlsZSAmJiAoc3R5bGUubGVnYWN5IHx8IHN0eWxlLmxlZ2FjeSAhPT0gZmFsc2UgJiYgIWhhc093blRleHRDb250ZW50T3B0aW9uICYmICFoYXNPd25UZXh0Q29uZmlnICYmIGVsVHlwZSAhPT0gJ3RzcGFuJ1xuICAvLyBEaWZmaWN1bHQgdG8gZGV0ZWN0IHdoZXRoZXIgbGVnYWN5IGZvciBhIFwidGV4dFwiIGVsLlxuICAmJiAoZWxUeXBlID09PSAndGV4dCcgfHwgaGFzT3duKHN0eWxlLCAndGV4dCcpKSk7XG59XG4vKipcclxuICogYEVDNENvbXBhdGlibGVTdHlsZWAgaXMgc3R5bGUgdGhhdCBtaWdodCBiZSBpbiBlY2hhcnRzNCBmb3JtYXQgb3IgZWNoYXJ0czUgZm9ybWF0LlxyXG4gKiBAcGFyYW0gaG9zdFN0eWxlIFRoZSBwcm9wZXJ0aWVzIG1pZ2h0IGJlIG1vZGlmaWVkLlxyXG4gKiBAcmV0dXJuIElmIGJlIHRleHQgZWwsIGB0ZXh0Q29udGVudFN0eWxlYCBhbmQgYHRleHRDb25maWdgIHdpbGwgbm90IGJlIHJldHVybmVkLlxyXG4gKiAgICAgICAgIE90aGVyd2lzZSBhIGB0ZXh0Q29udGVudFN0eWxlYCBhbmQgYHRleHRDb25maWdgIHdpbGwgYmUgY3JlYXRlZCwgd2hvc2UgcHJvcHMgYXJlYVxyXG4gKiAgICAgICAgIHJldHJpZWQgZnJvbSB0aGUgYGhvc3RTdHlsZWAuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRGcm9tRUM0Q29tcGF0aWJsZVN0eWxlKGhvc3RTdHlsZSwgZWxUeXBlLCBpc05vcm1hbCkge1xuICB2YXIgc3JjU3R5bGUgPSBob3N0U3R5bGU7XG4gIHZhciB0ZXh0Q29uZmlnO1xuICB2YXIgdGV4dENvbnRlbnQ7XG4gIHZhciB0ZXh0Q29udGVudFN0eWxlO1xuICBpZiAoZWxUeXBlID09PSAndGV4dCcpIHtcbiAgICB0ZXh0Q29udGVudFN0eWxlID0gc3JjU3R5bGU7XG4gIH0gZWxzZSB7XG4gICAgdGV4dENvbnRlbnRTdHlsZSA9IHt9O1xuICAgIGhhc093bihzcmNTdHlsZSwgJ3RleHQnKSAmJiAodGV4dENvbnRlbnRTdHlsZS50ZXh0ID0gc3JjU3R5bGUudGV4dCk7XG4gICAgaGFzT3duKHNyY1N0eWxlLCAncmljaCcpICYmICh0ZXh0Q29udGVudFN0eWxlLnJpY2ggPSBzcmNTdHlsZS5yaWNoKTtcbiAgICBoYXNPd24oc3JjU3R5bGUsICd0ZXh0RmlsbCcpICYmICh0ZXh0Q29udGVudFN0eWxlLmZpbGwgPSBzcmNTdHlsZS50ZXh0RmlsbCk7XG4gICAgaGFzT3duKHNyY1N0eWxlLCAndGV4dFN0cm9rZScpICYmICh0ZXh0Q29udGVudFN0eWxlLnN0cm9rZSA9IHNyY1N0eWxlLnRleHRTdHJva2UpO1xuICAgIGhhc093bihzcmNTdHlsZSwgJ2ZvbnRGYW1pbHknKSAmJiAodGV4dENvbnRlbnRTdHlsZS5mb250RmFtaWx5ID0gc3JjU3R5bGUuZm9udEZhbWlseSk7XG4gICAgaGFzT3duKHNyY1N0eWxlLCAnZm9udFNpemUnKSAmJiAodGV4dENvbnRlbnRTdHlsZS5mb250U2l6ZSA9IHNyY1N0eWxlLmZvbnRTaXplKTtcbiAgICBoYXNPd24oc3JjU3R5bGUsICdmb250U3R5bGUnKSAmJiAodGV4dENvbnRlbnRTdHlsZS5mb250U3R5bGUgPSBzcmNTdHlsZS5mb250U3R5bGUpO1xuICAgIGhhc093bihzcmNTdHlsZSwgJ2ZvbnRXZWlnaHQnKSAmJiAodGV4dENvbnRlbnRTdHlsZS5mb250V2VpZ2h0ID0gc3JjU3R5bGUuZm9udFdlaWdodCk7XG4gICAgdGV4dENvbnRlbnQgPSB7XG4gICAgICB0eXBlOiAndGV4dCcsXG4gICAgICBzdHlsZTogdGV4dENvbnRlbnRTdHlsZSxcbiAgICAgIC8vIGVjNCBkb2VzIG5vdCBzdXBwb3J0IHJlY3RUZXh0IHRyaWdnZXIuXG4gICAgICAvLyBBbmQgd2hlbiB0ZXh0IHBvc2l0aW9uIGlzIGRpZmZlcmVudCBpbiBub3JtYWwgYW5kIGVtcGhhc2lzXG4gICAgICAvLyA9PiBob3ZlciB0ZXh0IHRyaWdnZXIgZW1waGFzaXM7XG4gICAgICAvLyA9PiB0ZXh0IHBvc2l0aW9uIGNoYW5nZWQsIGxlYXZlIG1vdXNlIHBvaW50ZXIgaW1tZWRpYXRlbHk7XG4gICAgICAvLyBUaGF0IG1pZ2h0IGNhdXNlIGluY29ycmVjdCBzdGF0ZS5cbiAgICAgIHNpbGVudDogdHJ1ZVxuICAgIH07XG4gICAgdGV4dENvbmZpZyA9IHt9O1xuICAgIHZhciBoYXNPd25Qb3MgPSBoYXNPd24oc3JjU3R5bGUsICd0ZXh0UG9zaXRpb24nKTtcbiAgICBpZiAoaXNOb3JtYWwpIHtcbiAgICAgIHRleHRDb25maWcucG9zaXRpb24gPSBoYXNPd25Qb3MgPyBzcmNTdHlsZS50ZXh0UG9zaXRpb24gOiAnaW5zaWRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzT3duUG9zICYmICh0ZXh0Q29uZmlnLnBvc2l0aW9uID0gc3JjU3R5bGUudGV4dFBvc2l0aW9uKTtcbiAgICB9XG4gICAgaGFzT3duKHNyY1N0eWxlLCAndGV4dFBvc2l0aW9uJykgJiYgKHRleHRDb25maWcucG9zaXRpb24gPSBzcmNTdHlsZS50ZXh0UG9zaXRpb24pO1xuICAgIGhhc093bihzcmNTdHlsZSwgJ3RleHRPZmZzZXQnKSAmJiAodGV4dENvbmZpZy5vZmZzZXQgPSBzcmNTdHlsZS50ZXh0T2Zmc2V0KTtcbiAgICBoYXNPd24oc3JjU3R5bGUsICd0ZXh0Um90YXRpb24nKSAmJiAodGV4dENvbmZpZy5yb3RhdGlvbiA9IHNyY1N0eWxlLnRleHRSb3RhdGlvbik7XG4gICAgaGFzT3duKHNyY1N0eWxlLCAndGV4dERpc3RhbmNlJykgJiYgKHRleHRDb25maWcuZGlzdGFuY2UgPSBzcmNTdHlsZS50ZXh0RGlzdGFuY2UpO1xuICB9XG4gIGNvbnZlcnRFQzRDb21wYXRpYmxlUmljaEl0ZW0odGV4dENvbnRlbnRTdHlsZSwgaG9zdFN0eWxlKTtcbiAgZWFjaCh0ZXh0Q29udGVudFN0eWxlLnJpY2gsIGZ1bmN0aW9uIChyaWNoSXRlbSkge1xuICAgIGNvbnZlcnRFQzRDb21wYXRpYmxlUmljaEl0ZW0ocmljaEl0ZW0sIHJpY2hJdGVtKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdGV4dENvbmZpZzogdGV4dENvbmZpZyxcbiAgICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnRcbiAgfTtcbn1cbi8qKlxyXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgc2V0IHRvIGBvdXRgLlxyXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRFQzRDb21wYXRpYmxlUmljaEl0ZW0ob3V0LCByaWNoSXRlbSkge1xuICBpZiAoIXJpY2hJdGVtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vICgxKSBGb3Igc2ltcGxpY2l0eSwgbWFrZSB0ZXh0WFhYIHByb3BlcnRpZXMgKGRlcHJlY2F0ZWQgc2luY2UgZWM1KSBoYXNcbiAgLy8gaGlnaGVyIHByaW9yaXR5LiBGb3IgZXhhbXBsZSwgY29uc2lkZXIgaW4gZWM0IGBib3JkZXJDb2xvcjogNSwgdGV4dEJvcmRlckNvbG9yOiAxMGBcbiAgLy8gb24gYSByZWN0IG1lYW5zIGBib3JkZXJDb2xvcjogNGAgb24gdGhlIHJlY3QgYW5kIGBib3JkZXJDb2xvcjogMTBgIG9uIGFuIGF0dGFjaGVkXG4gIC8vIHJpY2hUZXh0IGluIGVjNS5cbiAgLy8gKDIpIGBvdXQgPT09IHJpY2hJdGVtYCBpZiBhbmQgb25seSBpZiBgb3V0YCBpcyB0ZXh0IGVsIG9yIHJpY2ggaXRlbS5cbiAgLy8gU28gd2UgY2FuIG92ZXJ3cml0ZSBleGlzdGluZyBwcm9wcyBpbiBgb3V0YCBzaW5jZSB0ZXh0WFhYIGhhcyBoaWdoZXIgcHJpb3JpdHkuXG4gIHJpY2hJdGVtLmZvbnQgPSByaWNoSXRlbS50ZXh0Rm9udCB8fCByaWNoSXRlbS5mb250O1xuICBoYXNPd24ocmljaEl0ZW0sICd0ZXh0U3Ryb2tlV2lkdGgnKSAmJiAob3V0LmxpbmVXaWR0aCA9IHJpY2hJdGVtLnRleHRTdHJva2VXaWR0aCk7XG4gIGhhc093bihyaWNoSXRlbSwgJ3RleHRBbGlnbicpICYmIChvdXQuYWxpZ24gPSByaWNoSXRlbS50ZXh0QWxpZ24pO1xuICBoYXNPd24ocmljaEl0ZW0sICd0ZXh0VmVydGljYWxBbGlnbicpICYmIChvdXQudmVydGljYWxBbGlnbiA9IHJpY2hJdGVtLnRleHRWZXJ0aWNhbEFsaWduKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAndGV4dExpbmVIZWlnaHQnKSAmJiAob3V0LmxpbmVIZWlnaHQgPSByaWNoSXRlbS50ZXh0TGluZUhlaWdodCk7XG4gIGhhc093bihyaWNoSXRlbSwgJ3RleHRXaWR0aCcpICYmIChvdXQud2lkdGggPSByaWNoSXRlbS50ZXh0V2lkdGgpO1xuICBoYXNPd24ocmljaEl0ZW0sICd0ZXh0SGVpZ2h0JykgJiYgKG91dC5oZWlnaHQgPSByaWNoSXRlbS50ZXh0SGVpZ2h0KTtcbiAgaGFzT3duKHJpY2hJdGVtLCAndGV4dEJhY2tncm91bmRDb2xvcicpICYmIChvdXQuYmFja2dyb3VuZENvbG9yID0gcmljaEl0ZW0udGV4dEJhY2tncm91bmRDb2xvcik7XG4gIGhhc093bihyaWNoSXRlbSwgJ3RleHRQYWRkaW5nJykgJiYgKG91dC5wYWRkaW5nID0gcmljaEl0ZW0udGV4dFBhZGRpbmcpO1xuICBoYXNPd24ocmljaEl0ZW0sICd0ZXh0Qm9yZGVyQ29sb3InKSAmJiAob3V0LmJvcmRlckNvbG9yID0gcmljaEl0ZW0udGV4dEJvcmRlckNvbG9yKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAndGV4dEJvcmRlcldpZHRoJykgJiYgKG91dC5ib3JkZXJXaWR0aCA9IHJpY2hJdGVtLnRleHRCb3JkZXJXaWR0aCk7XG4gIGhhc093bihyaWNoSXRlbSwgJ3RleHRCb3JkZXJSYWRpdXMnKSAmJiAob3V0LmJvcmRlclJhZGl1cyA9IHJpY2hJdGVtLnRleHRCb3JkZXJSYWRpdXMpO1xuICBoYXNPd24ocmljaEl0ZW0sICd0ZXh0Qm94U2hhZG93Q29sb3InKSAmJiAob3V0LnNoYWRvd0NvbG9yID0gcmljaEl0ZW0udGV4dEJveFNoYWRvd0NvbG9yKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAndGV4dEJveFNoYWRvd0JsdXInKSAmJiAob3V0LnNoYWRvd0JsdXIgPSByaWNoSXRlbS50ZXh0Qm94U2hhZG93Qmx1cik7XG4gIGhhc093bihyaWNoSXRlbSwgJ3RleHRCb3hTaGFkb3dPZmZzZXRYJykgJiYgKG91dC5zaGFkb3dPZmZzZXRYID0gcmljaEl0ZW0udGV4dEJveFNoYWRvd09mZnNldFgpO1xuICBoYXNPd24ocmljaEl0ZW0sICd0ZXh0Qm94U2hhZG93T2Zmc2V0WScpICYmIChvdXQuc2hhZG93T2Zmc2V0WSA9IHJpY2hJdGVtLnRleHRCb3hTaGFkb3dPZmZzZXRZKTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0IHRvIHB1cmUgZWNoYXJ0czQgZm9ybWF0IHN0eWxlLlxyXG4gKiBgaXRlbVN0eWxlYCB3aWxsIGJlIG1vZGlmaWVkLCBhZGRlZCB3aXRoIGVjNCBzdHlsZSBwcm9wZXJ0aWVzIGZyb21cclxuICogYHRleHRTdHlsZWAgYW5kIGB0ZXh0Q29uZmlnYC5cclxuICpcclxuICogW0NhdmVhdF06IEZvciBzaW1wbGljaXR5LCBgaW5zaWRlUm9sbGJhY2tgIGluIGVjNCBkb2VzIG5vdCBjb21wYXQsIHdoZXJlXHJcbiAqIGBzdHlsZUVtcGhhc2lzOiB7dGV4dEZpbGw6ICdyZWQnfWAgd2lsbCByZW1vdmUgdGhlIG5vcm1hbCBhdXRvIGFkZGVkIHN0cm9rZS5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvRUM0U3R5bGVGb3JDdXN0b21TZXJpc2UoaXRlbVN0bCwgdHhTdGwsIHR4Q2ZnKSB7XG4gIHZhciBvdXQgPSBpdGVtU3RsO1xuICAvLyBTZWUgYGN1c3RvbS50c2AsIGEgdHJpY2sgdG8gc2V0IGV4dHJhIGB0ZXh0UG9zaXRpb25gIGZpcnN0bHkuXG4gIG91dC50ZXh0UG9zaXRpb24gPSBvdXQudGV4dFBvc2l0aW9uIHx8IHR4Q2ZnLnBvc2l0aW9uIHx8ICdpbnNpZGUnO1xuICB0eENmZy5vZmZzZXQgIT0gbnVsbCAmJiAob3V0LnRleHRPZmZzZXQgPSB0eENmZy5vZmZzZXQpO1xuICB0eENmZy5yb3RhdGlvbiAhPSBudWxsICYmIChvdXQudGV4dFJvdGF0aW9uID0gdHhDZmcucm90YXRpb24pO1xuICB0eENmZy5kaXN0YW5jZSAhPSBudWxsICYmIChvdXQudGV4dERpc3RhbmNlID0gdHhDZmcuZGlzdGFuY2UpO1xuICB2YXIgaXNJbnNpZGUgPSBvdXQudGV4dFBvc2l0aW9uLmluZGV4T2YoJ2luc2lkZScpID49IDA7XG4gIHZhciBob3N0RmlsbCA9IGl0ZW1TdGwuZmlsbCB8fCAnIzAwMCc7XG4gIGNvbnZlcnRUb0VDNFJpY2hJdGVtKG91dCwgdHhTdGwpO1xuICB2YXIgdGV4dEZpbGxOb3RTZXQgPSBvdXQudGV4dEZpbGwgPT0gbnVsbDtcbiAgaWYgKGlzSW5zaWRlKSB7XG4gICAgaWYgKHRleHRGaWxsTm90U2V0KSB7XG4gICAgICBvdXQudGV4dEZpbGwgPSB0eENmZy5pbnNpZGVGaWxsIHx8ICcjZmZmJztcbiAgICAgICFvdXQudGV4dFN0cm9rZSAmJiB0eENmZy5pbnNpZGVTdHJva2UgJiYgKG91dC50ZXh0U3Ryb2tlID0gdHhDZmcuaW5zaWRlU3Ryb2tlKTtcbiAgICAgICFvdXQudGV4dFN0cm9rZSAmJiAob3V0LnRleHRTdHJva2UgPSBob3N0RmlsbCk7XG4gICAgICBvdXQudGV4dFN0cm9rZVdpZHRoID09IG51bGwgJiYgKG91dC50ZXh0U3Ryb2tlV2lkdGggPSAyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRleHRGaWxsTm90U2V0KSB7XG4gICAgICBvdXQudGV4dEZpbGwgPSBpdGVtU3RsLmZpbGwgfHwgdHhDZmcub3V0c2lkZUZpbGwgfHwgJyMwMDAnO1xuICAgIH1cbiAgICAhb3V0LnRleHRTdHJva2UgJiYgdHhDZmcub3V0c2lkZVN0cm9rZSAmJiAob3V0LnRleHRTdHJva2UgPSB0eENmZy5vdXRzaWRlU3Ryb2tlKTtcbiAgfVxuICBvdXQudGV4dCA9IHR4U3RsLnRleHQ7XG4gIG91dC5yaWNoID0gdHhTdGwucmljaDtcbiAgZWFjaCh0eFN0bC5yaWNoLCBmdW5jdGlvbiAocmljaEl0ZW0pIHtcbiAgICBjb252ZXJ0VG9FQzRSaWNoSXRlbShyaWNoSXRlbSwgcmljaEl0ZW0pO1xuICB9KTtcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0VDNFJpY2hJdGVtKG91dCwgcmljaEl0ZW0pIHtcbiAgaWYgKCFyaWNoSXRlbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBoYXNPd24ocmljaEl0ZW0sICdmaWxsJykgJiYgKG91dC50ZXh0RmlsbCA9IHJpY2hJdGVtLmZpbGwpO1xuICBoYXNPd24ocmljaEl0ZW0sICdzdHJva2UnKSAmJiAob3V0LnRleHRTdHJva2UgPSByaWNoSXRlbS5maWxsKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnbGluZVdpZHRoJykgJiYgKG91dC50ZXh0U3Ryb2tlV2lkdGggPSByaWNoSXRlbS5saW5lV2lkdGgpO1xuICBoYXNPd24ocmljaEl0ZW0sICdmb250JykgJiYgKG91dC5mb250ID0gcmljaEl0ZW0uZm9udCk7XG4gIGhhc093bihyaWNoSXRlbSwgJ2ZvbnRTdHlsZScpICYmIChvdXQuZm9udFN0eWxlID0gcmljaEl0ZW0uZm9udFN0eWxlKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnZm9udFdlaWdodCcpICYmIChvdXQuZm9udFdlaWdodCA9IHJpY2hJdGVtLmZvbnRXZWlnaHQpO1xuICBoYXNPd24ocmljaEl0ZW0sICdmb250U2l6ZScpICYmIChvdXQuZm9udFNpemUgPSByaWNoSXRlbS5mb250U2l6ZSk7XG4gIGhhc093bihyaWNoSXRlbSwgJ2ZvbnRGYW1pbHknKSAmJiAob3V0LmZvbnRGYW1pbHkgPSByaWNoSXRlbS5mb250RmFtaWx5KTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnYWxpZ24nKSAmJiAob3V0LnRleHRBbGlnbiA9IHJpY2hJdGVtLmFsaWduKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAndmVydGljYWxBbGlnbicpICYmIChvdXQudGV4dFZlcnRpY2FsQWxpZ24gPSByaWNoSXRlbS52ZXJ0aWNhbEFsaWduKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnbGluZUhlaWdodCcpICYmIChvdXQudGV4dExpbmVIZWlnaHQgPSByaWNoSXRlbS5saW5lSGVpZ2h0KTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnd2lkdGgnKSAmJiAob3V0LnRleHRXaWR0aCA9IHJpY2hJdGVtLndpZHRoKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnaGVpZ2h0JykgJiYgKG91dC50ZXh0SGVpZ2h0ID0gcmljaEl0ZW0uaGVpZ2h0KTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnYmFja2dyb3VuZENvbG9yJykgJiYgKG91dC50ZXh0QmFja2dyb3VuZENvbG9yID0gcmljaEl0ZW0uYmFja2dyb3VuZENvbG9yKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAncGFkZGluZycpICYmIChvdXQudGV4dFBhZGRpbmcgPSByaWNoSXRlbS5wYWRkaW5nKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnYm9yZGVyQ29sb3InKSAmJiAob3V0LnRleHRCb3JkZXJDb2xvciA9IHJpY2hJdGVtLmJvcmRlckNvbG9yKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnYm9yZGVyV2lkdGgnKSAmJiAob3V0LnRleHRCb3JkZXJXaWR0aCA9IHJpY2hJdGVtLmJvcmRlcldpZHRoKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnYm9yZGVyUmFkaXVzJykgJiYgKG91dC50ZXh0Qm9yZGVyUmFkaXVzID0gcmljaEl0ZW0uYm9yZGVyUmFkaXVzKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnc2hhZG93Q29sb3InKSAmJiAob3V0LnRleHRCb3hTaGFkb3dDb2xvciA9IHJpY2hJdGVtLnNoYWRvd0NvbG9yKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnc2hhZG93Qmx1cicpICYmIChvdXQudGV4dEJveFNoYWRvd0JsdXIgPSByaWNoSXRlbS5zaGFkb3dCbHVyKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnc2hhZG93T2Zmc2V0WCcpICYmIChvdXQudGV4dEJveFNoYWRvd09mZnNldFggPSByaWNoSXRlbS5zaGFkb3dPZmZzZXRYKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAnc2hhZG93T2Zmc2V0WScpICYmIChvdXQudGV4dEJveFNoYWRvd09mZnNldFkgPSByaWNoSXRlbS5zaGFkb3dPZmZzZXRZKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAndGV4dFNoYWRvd0NvbG9yJykgJiYgKG91dC50ZXh0U2hhZG93Q29sb3IgPSByaWNoSXRlbS50ZXh0U2hhZG93Q29sb3IpO1xuICBoYXNPd24ocmljaEl0ZW0sICd0ZXh0U2hhZG93Qmx1cicpICYmIChvdXQudGV4dFNoYWRvd0JsdXIgPSByaWNoSXRlbS50ZXh0U2hhZG93Qmx1cik7XG4gIGhhc093bihyaWNoSXRlbSwgJ3RleHRTaGFkb3dPZmZzZXRYJykgJiYgKG91dC50ZXh0U2hhZG93T2Zmc2V0WCA9IHJpY2hJdGVtLnRleHRTaGFkb3dPZmZzZXRYKTtcbiAgaGFzT3duKHJpY2hJdGVtLCAndGV4dFNoYWRvd09mZnNldFknKSAmJiAob3V0LnRleHRTaGFkb3dPZmZzZXRZID0gcmljaEl0ZW0udGV4dFNoYWRvd09mZnNldFkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdhcm5EZXByZWNhdGVkKGRlcHJlY2F0ZWQsIGluc3RlYWRBcHByb2FjaCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBrZXkgPSBkZXByZWNhdGVkICsgJ15fXicgKyBpbnN0ZWFkQXBwcm9hY2g7XG4gICAgaWYgKCFkZXByZWNhdGVkTG9nc1trZXldKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbRUNoYXJ0c10gREVQUkVDQVRFRDogXFxcIlwiICsgZGVwcmVjYXRlZCArIFwiXFxcIiBoYXMgYmVlbiBkZXByZWNhdGVkLiBcIiArIGluc3RlYWRBcHByb2FjaCk7XG4gICAgICBkZXByZWNhdGVkTG9nc1trZXldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9848\n")},12616:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $Q: () => (/* binding */ getUID),\n/* harmony export */   A6: () => (/* binding */ enableSubTypeDefaulter),\n/* harmony export */   G_: () => (/* binding */ inheritDefaultOption),\n/* harmony export */   vf: () => (/* binding */ enableTopologicalTravel)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _clazz_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30693);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n// A random offset\nvar base = Math.round(Math.random() * 10);\n/**\r\n * @public\r\n * @param {string} type\r\n * @return {string}\r\n */\nfunction getUID(type) {\n  // Considering the case of crossing js context,\n  // use Math.random to make id as unique as possible.\n  return [type || '', base++].join('_');\n}\n/**\r\n * Implements `SubTypeDefaulterManager` for `target`.\r\n */\nfunction enableSubTypeDefaulter(target) {\n  var subTypeDefaulters = {};\n  target.registerSubTypeDefaulter = function (componentType, defaulter) {\n    var componentTypeInfo = (0,_clazz_js__WEBPACK_IMPORTED_MODULE_0__/* .parseClassType */ .CC)(componentType);\n    subTypeDefaulters[componentTypeInfo.main] = defaulter;\n  };\n  target.determineSubType = function (componentType, option) {\n    var type = option.type;\n    if (!type) {\n      var componentTypeMain = (0,_clazz_js__WEBPACK_IMPORTED_MODULE_0__/* .parseClassType */ .CC)(componentType).main;\n      if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n        type = subTypeDefaulters[componentTypeMain](option);\n      }\n    }\n    return type;\n  };\n}\n/**\r\n * Implements `TopologicalTravelable<any>` for `entity`.\r\n *\r\n * Topological travel on Activity Network (Activity On Vertices).\r\n * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\r\n * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\r\n * If there is circular dependencey, Error will be thrown.\r\n */\nfunction enableTopologicalTravel(entity, dependencyGetter) {\n  /**\r\n   * @param targetNameList Target Component type list.\r\n   *                       Can be ['aa', 'bb', 'aa.xx']\r\n   * @param fullNameList By which we can build dependency graph.\r\n   * @param callback Params: componentType, dependencies.\r\n   * @param context Scope of callback.\r\n   */\n  entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n    if (!targetNameList.length) {\n      return;\n    }\n    var result = makeDepndencyGraph(fullNameList);\n    var graph = result.graph;\n    var noEntryList = result.noEntryList;\n    var targetNameSet = {};\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(targetNameList, function (name) {\n      targetNameSet[name] = true;\n    });\n    while (noEntryList.length) {\n      var currComponentType = noEntryList.pop();\n      var currVertex = graph[currComponentType];\n      var isInTargetNameSet = !!targetNameSet[currComponentType];\n      if (isInTargetNameSet) {\n        callback.call(context, currComponentType, currVertex.originalDeps.slice());\n        delete targetNameSet[currComponentType];\n      }\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n    }\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(targetNameSet, function () {\n      var errMsg = '';\n      if (false) {}\n      throw new Error(errMsg);\n    });\n    function removeEdge(succComponentType) {\n      graph[succComponentType].entryCount--;\n      if (graph[succComponentType].entryCount === 0) {\n        noEntryList.push(succComponentType);\n      }\n    }\n    // Consider this case: legend depends on series, and we call\n    // chart.setOption({series: [...]}), where only series is in option.\n    // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n    // not be called, but only sereis.mergeOption is called. Thus legend\n    // have no chance to update its local record about series (like which\n    // name of series is available in legend).\n    function removeEdgeAndAdd(succComponentType) {\n      targetNameSet[succComponentType] = true;\n      removeEdge(succComponentType);\n    }\n  };\n  function makeDepndencyGraph(fullNameList) {\n    var graph = {};\n    var noEntryList = [];\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(fullNameList, function (name) {\n      var thisItem = createDependencyGraphItem(graph, name);\n      var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n      thisItem.entryCount = availableDeps.length;\n      if (thisItem.entryCount === 0) {\n        noEntryList.push(name);\n      }\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(availableDeps, function (dependentName) {\n        if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.indexOf(thisItem.predecessor, dependentName) < 0) {\n          thisItem.predecessor.push(dependentName);\n        }\n        var thatItem = createDependencyGraphItem(graph, dependentName);\n        if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.indexOf(thatItem.successor, dependentName) < 0) {\n          thatItem.successor.push(name);\n        }\n      });\n    });\n    return {\n      graph: graph,\n      noEntryList: noEntryList\n    };\n  }\n  function createDependencyGraphItem(graph, name) {\n    if (!graph[name]) {\n      graph[name] = {\n        predecessor: [],\n        successor: []\n      };\n    }\n    return graph[name];\n  }\n  function getAvailableDependencies(originalDeps, fullNameList) {\n    var availableDeps = [];\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(originalDeps, function (dep) {\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n    });\n    return availableDeps;\n  }\n}\nfunction inheritDefaultOption(superOption, subOption) {\n  // See also `model/Component.ts#getDefaultOption`\n  return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.merge(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.merge({}, superOption, true), subOption, true);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2MTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2NvbXBvbmVudC5qcz80ZDNlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBwYXJzZUNsYXNzVHlwZSB9IGZyb20gJy4vY2xhenouanMnO1xuaW1wb3J0IHsgbWFrZVByaW50YWJsZSB9IGZyb20gJy4vbG9nLmpzJztcbi8vIEEgcmFuZG9tIG9mZnNldFxudmFyIGJhc2UgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMCk7XG4vKipcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVJRCh0eXBlKSB7XG4gIC8vIENvbnNpZGVyaW5nIHRoZSBjYXNlIG9mIGNyb3NzaW5nIGpzIGNvbnRleHQsXG4gIC8vIHVzZSBNYXRoLnJhbmRvbSB0byBtYWtlIGlkIGFzIHVuaXF1ZSBhcyBwb3NzaWJsZS5cbiAgcmV0dXJuIFt0eXBlIHx8ICcnLCBiYXNlKytdLmpvaW4oJ18nKTtcbn1cbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGBTdWJUeXBlRGVmYXVsdGVyTWFuYWdlcmAgZm9yIGB0YXJnZXRgLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVTdWJUeXBlRGVmYXVsdGVyKHRhcmdldCkge1xuICB2YXIgc3ViVHlwZURlZmF1bHRlcnMgPSB7fTtcbiAgdGFyZ2V0LnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlciA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBkZWZhdWx0ZXIpIHtcbiAgICB2YXIgY29tcG9uZW50VHlwZUluZm8gPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICBzdWJUeXBlRGVmYXVsdGVyc1tjb21wb25lbnRUeXBlSW5mby5tYWluXSA9IGRlZmF1bHRlcjtcbiAgfTtcbiAgdGFyZ2V0LmRldGVybWluZVN1YlR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgb3B0aW9uKSB7XG4gICAgdmFyIHR5cGUgPSBvcHRpb24udHlwZTtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHZhciBjb21wb25lbnRUeXBlTWFpbiA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpLm1haW47XG4gICAgICBpZiAodGFyZ2V0Lmhhc1N1YlR5cGVzKGNvbXBvbmVudFR5cGUpICYmIHN1YlR5cGVEZWZhdWx0ZXJzW2NvbXBvbmVudFR5cGVNYWluXSkge1xuICAgICAgICB0eXBlID0gc3ViVHlwZURlZmF1bHRlcnNbY29tcG9uZW50VHlwZU1haW5dKG9wdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9O1xufVxuLyoqXHJcbiAqIEltcGxlbWVudHMgYFRvcG9sb2dpY2FsVHJhdmVsYWJsZTxhbnk+YCBmb3IgYGVudGl0eWAuXHJcbiAqXHJcbiAqIFRvcG9sb2dpY2FsIHRyYXZlbCBvbiBBY3Rpdml0eSBOZXR3b3JrIChBY3Rpdml0eSBPbiBWZXJ0aWNlcykuXHJcbiAqIERlcGVuZGVuY2llcyBpcyBkZWZpbmVkIGluIE1vZGVsLnByb3RvdHlwZS5kZXBlbmRlbmNpZXMsIGxpa2UgWyd4QXhpcycsICd5QXhpcyddLlxyXG4gKiBJZiAneEF4aXMnIG9yICd5QXhpcycgaXMgYWJzZW50IGluIGNvbXBvbmVudFR5cGVMaXN0LCBqdXN0IGlnbm9yZSBpdCBpbiB0b3BvbG9neS5cclxuICogSWYgdGhlcmUgaXMgY2lyY3VsYXIgZGVwZW5kZW5jZXksIEVycm9yIHdpbGwgYmUgdGhyb3duLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVUb3BvbG9naWNhbFRyYXZlbChlbnRpdHksIGRlcGVuZGVuY3lHZXR0ZXIpIHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHRhcmdldE5hbWVMaXN0IFRhcmdldCBDb21wb25lbnQgdHlwZSBsaXN0LlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgWydhYScsICdiYicsICdhYS54eCddXHJcbiAgICogQHBhcmFtIGZ1bGxOYW1lTGlzdCBCeSB3aGljaCB3ZSBjYW4gYnVpbGQgZGVwZW5kZW5jeSBncmFwaC5cclxuICAgKiBAcGFyYW0gY2FsbGJhY2sgUGFyYW1zOiBjb21wb25lbnRUeXBlLCBkZXBlbmRlbmNpZXMuXHJcbiAgICogQHBhcmFtIGNvbnRleHQgU2NvcGUgb2YgY2FsbGJhY2suXHJcbiAgICovXG4gIGVudGl0eS50b3BvbG9naWNhbFRyYXZlbCA9IGZ1bmN0aW9uICh0YXJnZXROYW1lTGlzdCwgZnVsbE5hbWVMaXN0LCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGlmICghdGFyZ2V0TmFtZUxpc3QubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBtYWtlRGVwbmRlbmN5R3JhcGgoZnVsbE5hbWVMaXN0KTtcbiAgICB2YXIgZ3JhcGggPSByZXN1bHQuZ3JhcGg7XG4gICAgdmFyIG5vRW50cnlMaXN0ID0gcmVzdWx0Lm5vRW50cnlMaXN0O1xuICAgIHZhciB0YXJnZXROYW1lU2V0ID0ge307XG4gICAgenJVdGlsLmVhY2godGFyZ2V0TmFtZUxpc3QsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB0YXJnZXROYW1lU2V0W25hbWVdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICB3aGlsZSAobm9FbnRyeUxpc3QubGVuZ3RoKSB7XG4gICAgICB2YXIgY3VyckNvbXBvbmVudFR5cGUgPSBub0VudHJ5TGlzdC5wb3AoKTtcbiAgICAgIHZhciBjdXJyVmVydGV4ID0gZ3JhcGhbY3VyckNvbXBvbmVudFR5cGVdO1xuICAgICAgdmFyIGlzSW5UYXJnZXROYW1lU2V0ID0gISF0YXJnZXROYW1lU2V0W2N1cnJDb21wb25lbnRUeXBlXTtcbiAgICAgIGlmIChpc0luVGFyZ2V0TmFtZVNldCkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGN1cnJDb21wb25lbnRUeXBlLCBjdXJyVmVydGV4Lm9yaWdpbmFsRGVwcy5zbGljZSgpKTtcbiAgICAgICAgZGVsZXRlIHRhcmdldE5hbWVTZXRbY3VyckNvbXBvbmVudFR5cGVdO1xuICAgICAgfVxuICAgICAgenJVdGlsLmVhY2goY3VyclZlcnRleC5zdWNjZXNzb3IsIGlzSW5UYXJnZXROYW1lU2V0ID8gcmVtb3ZlRWRnZUFuZEFkZCA6IHJlbW92ZUVkZ2UpO1xuICAgIH1cbiAgICB6clV0aWwuZWFjaCh0YXJnZXROYW1lU2V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZXJyTXNnID0gJyc7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBlcnJNc2cgPSBtYWtlUHJpbnRhYmxlKCdDaXJjdWxhciBkZXBlbmRlbmN5IG1heSBleGlzdHM6ICcsIHRhcmdldE5hbWVTZXQsIHRhcmdldE5hbWVMaXN0LCBmdWxsTmFtZUxpc3QpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcmVtb3ZlRWRnZShzdWNjQ29tcG9uZW50VHlwZSkge1xuICAgICAgZ3JhcGhbc3VjY0NvbXBvbmVudFR5cGVdLmVudHJ5Q291bnQtLTtcbiAgICAgIGlmIChncmFwaFtzdWNjQ29tcG9uZW50VHlwZV0uZW50cnlDb3VudCA9PT0gMCkge1xuICAgICAgICBub0VudHJ5TGlzdC5wdXNoKHN1Y2NDb21wb25lbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiBsZWdlbmQgZGVwZW5kcyBvbiBzZXJpZXMsIGFuZCB3ZSBjYWxsXG4gICAgLy8gY2hhcnQuc2V0T3B0aW9uKHtzZXJpZXM6IFsuLi5dfSksIHdoZXJlIG9ubHkgc2VyaWVzIGlzIGluIG9wdGlvbi5cbiAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSAncmVtb3ZlRWRnZUFuZEFkZCcsIGxlZ2VuZE1vZGVsLm1lcmdlT3B0aW9uIHdpbGxcbiAgICAvLyBub3QgYmUgY2FsbGVkLCBidXQgb25seSBzZXJlaXMubWVyZ2VPcHRpb24gaXMgY2FsbGVkLiBUaHVzIGxlZ2VuZFxuICAgIC8vIGhhdmUgbm8gY2hhbmNlIHRvIHVwZGF0ZSBpdHMgbG9jYWwgcmVjb3JkIGFib3V0IHNlcmllcyAobGlrZSB3aGljaFxuICAgIC8vIG5hbWUgb2Ygc2VyaWVzIGlzIGF2YWlsYWJsZSBpbiBsZWdlbmQpLlxuICAgIGZ1bmN0aW9uIHJlbW92ZUVkZ2VBbmRBZGQoc3VjY0NvbXBvbmVudFR5cGUpIHtcbiAgICAgIHRhcmdldE5hbWVTZXRbc3VjY0NvbXBvbmVudFR5cGVdID0gdHJ1ZTtcbiAgICAgIHJlbW92ZUVkZ2Uoc3VjY0NvbXBvbmVudFR5cGUpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gbWFrZURlcG5kZW5jeUdyYXBoKGZ1bGxOYW1lTGlzdCkge1xuICAgIHZhciBncmFwaCA9IHt9O1xuICAgIHZhciBub0VudHJ5TGlzdCA9IFtdO1xuICAgIHpyVXRpbC5lYWNoKGZ1bGxOYW1lTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB0aGlzSXRlbSA9IGNyZWF0ZURlcGVuZGVuY3lHcmFwaEl0ZW0oZ3JhcGgsIG5hbWUpO1xuICAgICAgdmFyIG9yaWdpbmFsRGVwcyA9IHRoaXNJdGVtLm9yaWdpbmFsRGVwcyA9IGRlcGVuZGVuY3lHZXR0ZXIobmFtZSk7XG4gICAgICB2YXIgYXZhaWxhYmxlRGVwcyA9IGdldEF2YWlsYWJsZURlcGVuZGVuY2llcyhvcmlnaW5hbERlcHMsIGZ1bGxOYW1lTGlzdCk7XG4gICAgICB0aGlzSXRlbS5lbnRyeUNvdW50ID0gYXZhaWxhYmxlRGVwcy5sZW5ndGg7XG4gICAgICBpZiAodGhpc0l0ZW0uZW50cnlDb3VudCA9PT0gMCkge1xuICAgICAgICBub0VudHJ5TGlzdC5wdXNoKG5hbWUpO1xuICAgICAgfVxuICAgICAgenJVdGlsLmVhY2goYXZhaWxhYmxlRGVwcywgZnVuY3Rpb24gKGRlcGVuZGVudE5hbWUpIHtcbiAgICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKHRoaXNJdGVtLnByZWRlY2Vzc29yLCBkZXBlbmRlbnROYW1lKSA8IDApIHtcbiAgICAgICAgICB0aGlzSXRlbS5wcmVkZWNlc3Nvci5wdXNoKGRlcGVuZGVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGF0SXRlbSA9IGNyZWF0ZURlcGVuZGVuY3lHcmFwaEl0ZW0oZ3JhcGgsIGRlcGVuZGVudE5hbWUpO1xuICAgICAgICBpZiAoenJVdGlsLmluZGV4T2YodGhhdEl0ZW0uc3VjY2Vzc29yLCBkZXBlbmRlbnROYW1lKSA8IDApIHtcbiAgICAgICAgICB0aGF0SXRlbS5zdWNjZXNzb3IucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdyYXBoOiBncmFwaCxcbiAgICAgIG5vRW50cnlMaXN0OiBub0VudHJ5TGlzdFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRGVwZW5kZW5jeUdyYXBoSXRlbShncmFwaCwgbmFtZSkge1xuICAgIGlmICghZ3JhcGhbbmFtZV0pIHtcbiAgICAgIGdyYXBoW25hbWVdID0ge1xuICAgICAgICBwcmVkZWNlc3NvcjogW10sXG4gICAgICAgIHN1Y2Nlc3NvcjogW11cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBncmFwaFtuYW1lXTtcbiAgfVxuICBmdW5jdGlvbiBnZXRBdmFpbGFibGVEZXBlbmRlbmNpZXMob3JpZ2luYWxEZXBzLCBmdWxsTmFtZUxpc3QpIHtcbiAgICB2YXIgYXZhaWxhYmxlRGVwcyA9IFtdO1xuICAgIHpyVXRpbC5lYWNoKG9yaWdpbmFsRGVwcywgZnVuY3Rpb24gKGRlcCkge1xuICAgICAgenJVdGlsLmluZGV4T2YoZnVsbE5hbWVMaXN0LCBkZXApID49IDAgJiYgYXZhaWxhYmxlRGVwcy5wdXNoKGRlcCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGF2YWlsYWJsZURlcHM7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpbmhlcml0RGVmYXVsdE9wdGlvbihzdXBlck9wdGlvbiwgc3ViT3B0aW9uKSB7XG4gIC8vIFNlZSBhbHNvIGBtb2RlbC9Db21wb25lbnQudHMjZ2V0RGVmYXVsdE9wdGlvbmBcbiAgcmV0dXJuIHpyVXRpbC5tZXJnZSh6clV0aWwubWVyZ2Uoe30sIHN1cGVyT3B0aW9uLCB0cnVlKSwgc3ViT3B0aW9uLCB0cnVlKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12616\n")},13430:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Km: () => (/* binding */ SOURCE_FORMAT_ARRAY_ROWS),\n/* harmony export */   Pe: () => (/* binding */ VISUAL_DIMENSIONS),\n/* harmony export */   Wk: () => (/* binding */ SOURCE_FORMAT_OBJECT_ROWS),\n/* harmony export */   XO: () => (/* binding */ SOURCE_FORMAT_TYPED_ARRAY),\n/* harmony export */   i_: () => (/* binding */ SERIES_LAYOUT_BY_COLUMN),\n/* harmony export */   mK: () => (/* binding */ SOURCE_FORMAT_ORIGINAL),\n/* harmony export */   oC: () => (/* binding */ SERIES_LAYOUT_BY_ROW),\n/* harmony export */   t1: () => (/* binding */ SOURCE_FORMAT_KEYED_COLUMNS),\n/* harmony export */   vm: () => (/* binding */ SOURCE_FORMAT_UNKNOWN)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n;\n;\n;\nvar VISUAL_DIMENSIONS = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)(['tooltip', 'label', 'itemName', 'itemId', 'itemGroupId', 'itemChildGroupId', 'seriesName']);\nvar SOURCE_FORMAT_ORIGINAL = 'original';\nvar SOURCE_FORMAT_ARRAY_ROWS = 'arrayRows';\nvar SOURCE_FORMAT_OBJECT_ROWS = 'objectRows';\nvar SOURCE_FORMAT_KEYED_COLUMNS = 'keyedColumns';\nvar SOURCE_FORMAT_TYPED_ARRAY = 'typedArray';\nvar SOURCE_FORMAT_UNKNOWN = 'unknown';\nvar SERIES_LAYOUT_BY_COLUMN = 'column';\nvar SERIES_LAYOUT_BY_ROW = 'row';\n;\n;\n;\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM0MzAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvdHlwZXMuanM/YzU0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGNyZWF0ZUhhc2hNYXAgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuO1xuO1xuO1xuZXhwb3J0IHZhciBWSVNVQUxfRElNRU5TSU9OUyA9IGNyZWF0ZUhhc2hNYXAoWyd0b29sdGlwJywgJ2xhYmVsJywgJ2l0ZW1OYW1lJywgJ2l0ZW1JZCcsICdpdGVtR3JvdXBJZCcsICdpdGVtQ2hpbGRHcm91cElkJywgJ3Nlcmllc05hbWUnXSk7XG5leHBvcnQgdmFyIFNPVVJDRV9GT1JNQVRfT1JJR0lOQUwgPSAnb3JpZ2luYWwnO1xuZXhwb3J0IHZhciBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MgPSAnYXJyYXlSb3dzJztcbmV4cG9ydCB2YXIgU09VUkNFX0ZPUk1BVF9PQkpFQ1RfUk9XUyA9ICdvYmplY3RSb3dzJztcbmV4cG9ydCB2YXIgU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TID0gJ2tleWVkQ29sdW1ucyc7XG5leHBvcnQgdmFyIFNPVVJDRV9GT1JNQVRfVFlQRURfQVJSQVkgPSAndHlwZWRBcnJheSc7XG5leHBvcnQgdmFyIFNPVVJDRV9GT1JNQVRfVU5LTk9XTiA9ICd1bmtub3duJztcbmV4cG9ydCB2YXIgU0VSSUVTX0xBWU9VVF9CWV9DT0xVTU4gPSAnY29sdW1uJztcbmV4cG9ydCB2YXIgU0VSSUVTX0xBWU9VVF9CWV9ST1cgPSAncm93JztcbjtcbjtcbjtcbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13430\n")},23538:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   w: () => (/* binding */ createOrUpdatePatternFromDecal)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_WeakMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73430);\n/* harmony import */ var zrender_lib_core_LRU_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60501);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24326);\n/* harmony import */ var _symbol_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62103);\n/* harmony import */ var zrender_lib_canvas_graphic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(29571);\n/* harmony import */ var zrender_lib_core_platform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(59741);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar decalMap = new zrender_lib_core_WeakMap_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A();\nvar decalCache = new zrender_lib_core_LRU_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .Ay(100);\nvar decalKeys = ['symbol', 'symbolSize', 'symbolKeepAspect', 'color', 'backgroundColor', 'dashArrayX', 'dashArrayY', 'maxTileWidth', 'maxTileHeight'];\n/**\r\n * Create or update pattern image from decal options\r\n *\r\n * @param {InnerDecalObject | 'none'} decalObject decal options, 'none' if no decal\r\n * @return {Pattern} pattern with generated image, null if no decal\r\n */\nfunction createOrUpdatePatternFromDecal(decalObject, api) {\n  if (decalObject === 'none') {\n    return null;\n  }\n  var dpr = api.getDevicePixelRatio();\n  var zr = api.getZr();\n  var isSVG = zr.painter.type === 'svg';\n  if (decalObject.dirty) {\n    decalMap[\"delete\"](decalObject);\n  }\n  var oldPattern = decalMap.get(decalObject);\n  if (oldPattern) {\n    return oldPattern;\n  }\n  var decalOpt = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.defaults)(decalObject, {\n    symbol: 'rect',\n    symbolSize: 1,\n    symbolKeepAspect: true,\n    color: 'rgba(0, 0, 0, 0.2)',\n    backgroundColor: null,\n    dashArrayX: 5,\n    dashArrayY: 5,\n    rotation: 0,\n    maxTileWidth: 512,\n    maxTileHeight: 512\n  });\n  if (decalOpt.backgroundColor === 'none') {\n    decalOpt.backgroundColor = null;\n  }\n  var pattern = {\n    repeat: 'repeat'\n  };\n  setPatternnSource(pattern);\n  pattern.rotation = decalOpt.rotation;\n  pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr;\n  decalMap.set(decalObject, pattern);\n  decalObject.dirty = false;\n  return pattern;\n  function setPatternnSource(pattern) {\n    var keys = [dpr];\n    var isValidKey = true;\n    for (var i = 0; i < decalKeys.length; ++i) {\n      var value = decalOpt[decalKeys[i]];\n      if (value != null && !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(value) && !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isString)(value) && !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isNumber)(value) && typeof value !== 'boolean') {\n        isValidKey = false;\n        break;\n      }\n      keys.push(value);\n    }\n    var cacheKey;\n    if (isValidKey) {\n      cacheKey = keys.join(',') + (isSVG ? '-svg' : '');\n      var cache = decalCache.get(cacheKey);\n      if (cache) {\n        isSVG ? pattern.svgElement = cache : pattern.image = cache;\n      }\n    }\n    var dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);\n    var dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);\n    var symbolArray = normalizeSymbolArray(decalOpt.symbol);\n    var lineBlockLengthsX = getLineBlockLengthX(dashArrayX);\n    var lineBlockLengthY = getLineBlockLengthY(dashArrayY);\n    var canvas = !isSVG && zrender_lib_core_platform_js__WEBPACK_IMPORTED_MODULE_3__/* .platformApi */ .yh.createCanvas();\n    var svgRoot = isSVG && {\n      tag: 'g',\n      attrs: {},\n      key: 'dcl',\n      children: []\n    };\n    var pSize = getPatternSize();\n    var ctx;\n    if (canvas) {\n      canvas.width = pSize.width * dpr;\n      canvas.height = pSize.height * dpr;\n      ctx = canvas.getContext('2d');\n    }\n    brushDecal();\n    if (isValidKey) {\n      decalCache.put(cacheKey, canvas || svgRoot);\n    }\n    pattern.image = canvas;\n    pattern.svgElement = svgRoot;\n    pattern.svgWidth = pSize.width;\n    pattern.svgHeight = pSize.height;\n    /**\r\n     * Get minimum length that can make a repeatable pattern.\r\n     *\r\n     * @return {Object} pattern width and height\r\n     */\n    function getPatternSize() {\n      /**\r\n       * For example, if dash is [[3, 2], [2, 1]] for X, it looks like\r\n       * |---  ---  ---  ---  --- ...\r\n       * |-- -- -- -- -- -- -- -- ...\r\n       * |---  ---  ---  ---  --- ...\r\n       * |-- -- -- -- -- -- -- -- ...\r\n       * So the minimum length of X is 15,\r\n       * which is the least common multiple of `3 + 2` and `2 + 1`\r\n       * |---  ---  ---  |---  --- ...\r\n       * |-- -- -- -- -- |-- -- -- ...\r\n       */\n      var width = 1;\n      for (var i = 0, xlen = lineBlockLengthsX.length; i < xlen; ++i) {\n        width = (0,_number_js__WEBPACK_IMPORTED_MODULE_4__/* .getLeastCommonMultiple */ .lQ)(width, lineBlockLengthsX[i]);\n      }\n      var symbolRepeats = 1;\n      for (var i = 0, xlen = symbolArray.length; i < xlen; ++i) {\n        symbolRepeats = (0,_number_js__WEBPACK_IMPORTED_MODULE_4__/* .getLeastCommonMultiple */ .lQ)(symbolRepeats, symbolArray[i].length);\n      }\n      width *= symbolRepeats;\n      var height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;\n      if (false) { var warn; }\n      return {\n        width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),\n        height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))\n      };\n    }\n    function brushDecal() {\n      if (ctx) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        if (decalOpt.backgroundColor) {\n          ctx.fillStyle = decalOpt.backgroundColor;\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n      }\n      var ySum = 0;\n      for (var i = 0; i < dashArrayY.length; ++i) {\n        ySum += dashArrayY[i];\n      }\n      if (ySum <= 0) {\n        // dashArrayY is 0, draw nothing\n        return;\n      }\n      var y = -lineBlockLengthY;\n      var yId = 0;\n      var yIdTotal = 0;\n      var xId0 = 0;\n      while (y < pSize.height) {\n        if (yId % 2 === 0) {\n          var symbolYId = yIdTotal / 2 % symbolArray.length;\n          var x = 0;\n          var xId1 = 0;\n          var xId1Total = 0;\n          while (x < pSize.width * 2) {\n            var xSum = 0;\n            for (var i = 0; i < dashArrayX[xId0].length; ++i) {\n              xSum += dashArrayX[xId0][i];\n            }\n            if (xSum <= 0) {\n              // Skip empty line\n              break;\n            }\n            // E.g., [15, 5, 20, 5] draws only for 15 and 20\n            if (xId1 % 2 === 0) {\n              var size = (1 - decalOpt.symbolSize) * 0.5;\n              var left = x + dashArrayX[xId0][xId1] * size;\n              var top_1 = y + dashArrayY[yId] * size;\n              var width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;\n              var height = dashArrayY[yId] * decalOpt.symbolSize;\n              var symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;\n              brushSymbol(left, top_1, width, height, symbolArray[symbolYId][symbolXId]);\n            }\n            x += dashArrayX[xId0][xId1];\n            ++xId1Total;\n            ++xId1;\n            if (xId1 === dashArrayX[xId0].length) {\n              xId1 = 0;\n            }\n          }\n          ++xId0;\n          if (xId0 === dashArrayX.length) {\n            xId0 = 0;\n          }\n        }\n        y += dashArrayY[yId];\n        ++yIdTotal;\n        ++yId;\n        if (yId === dashArrayY.length) {\n          yId = 0;\n        }\n      }\n      function brushSymbol(x, y, width, height, symbolType) {\n        var scale = isSVG ? 1 : dpr;\n        var symbol = (0,_symbol_js__WEBPACK_IMPORTED_MODULE_5__/* .createSymbol */ .v5)(symbolType, x * scale, y * scale, width * scale, height * scale, decalOpt.color, decalOpt.symbolKeepAspect);\n        if (isSVG) {\n          var symbolVNode = zr.painter.renderOneToVNode(symbol);\n          if (symbolVNode) {\n            svgRoot.children.push(symbolVNode);\n          }\n        } else {\n          // Paint to canvas for all other renderers.\n          (0,zrender_lib_canvas_graphic_js__WEBPACK_IMPORTED_MODULE_6__/* .brushSingle */ .Xi)(ctx, symbol);\n        }\n      }\n    }\n  }\n}\n/**\r\n * Convert symbol array into normalized array\r\n *\r\n * @param {string | (string | string[])[]} symbol symbol input\r\n * @return {string[][]} normolized symbol array\r\n */\nfunction normalizeSymbolArray(symbol) {\n  if (!symbol || symbol.length === 0) {\n    return [['rect']];\n  }\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isString)(symbol)) {\n    return [[symbol]];\n  }\n  var isAllString = true;\n  for (var i = 0; i < symbol.length; ++i) {\n    if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isString)(symbol[i])) {\n      isAllString = false;\n      break;\n    }\n  }\n  if (isAllString) {\n    return normalizeSymbolArray([symbol]);\n  }\n  var result = [];\n  for (var i = 0; i < symbol.length; ++i) {\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isString)(symbol[i])) {\n      result.push([symbol[i]]);\n    } else {\n      result.push(symbol[i]);\n    }\n  }\n  return result;\n}\n/**\r\n * Convert dash input into dashArray\r\n *\r\n * @param {DecalDashArrayX} dash dash input\r\n * @return {number[][]} normolized dash array\r\n */\nfunction normalizeDashArrayX(dash) {\n  if (!dash || dash.length === 0) {\n    return [[0, 0]];\n  }\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isNumber)(dash)) {\n    var dashValue = Math.ceil(dash);\n    return [[dashValue, dashValue]];\n  }\n  /**\r\n   * [20, 5] should be normalized into [[20, 5]],\r\n   * while [20, [5, 10]] should be normalized into [[20, 20], [5, 10]]\r\n   */\n  var isAllNumber = true;\n  for (var i = 0; i < dash.length; ++i) {\n    if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isNumber)(dash[i])) {\n      isAllNumber = false;\n      break;\n    }\n  }\n  if (isAllNumber) {\n    return normalizeDashArrayX([dash]);\n  }\n  var result = [];\n  for (var i = 0; i < dash.length; ++i) {\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isNumber)(dash[i])) {\n      var dashValue = Math.ceil(dash[i]);\n      result.push([dashValue, dashValue]);\n    } else {\n      var dashValue = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(dash[i], function (n) {\n        return Math.ceil(n);\n      });\n      if (dashValue.length % 2 === 1) {\n        // [4, 2, 1] means |----  -    -- |----  -    -- |\n        // so normalize it to be [4, 2, 1, 4, 2, 1]\n        result.push(dashValue.concat(dashValue));\n      } else {\n        result.push(dashValue);\n      }\n    }\n  }\n  return result;\n}\n/**\r\n * Convert dash input into dashArray\r\n *\r\n * @param {DecalDashArrayY} dash dash input\r\n * @return {number[]} normolized dash array\r\n */\nfunction normalizeDashArrayY(dash) {\n  if (!dash || typeof dash === 'object' && dash.length === 0) {\n    return [0, 0];\n  }\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isNumber)(dash)) {\n    var dashValue_1 = Math.ceil(dash);\n    return [dashValue_1, dashValue_1];\n  }\n  var dashValue = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(dash, function (n) {\n    return Math.ceil(n);\n  });\n  return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;\n}\n/**\r\n * Get block length of each line. A block is the length of dash line and space.\r\n * For example, a line with [4, 1] has a dash line of 4 and a space of 1 after\r\n * that, so the block length of this line is 5.\r\n *\r\n * @param {number[][]} dash dash array of X or Y\r\n * @return {number[]} block length of each line\r\n */\nfunction getLineBlockLengthX(dash) {\n  return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(dash, function (line) {\n    return getLineBlockLengthY(line);\n  });\n}\nfunction getLineBlockLengthY(dash) {\n  var blockLength = 0;\n  for (var i = 0; i < dash.length; ++i) {\n    blockLength += dash[i];\n  }\n  if (dash.length % 2 === 1) {\n    // [4, 2, 1] means |----  -    -- |----  -    -- |\n    // So total length is (4 + 2 + 1) * 2\n    return blockLength * 2;\n  }\n  return blockLength;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM1MzguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2RlY2FsLmpzP2M4ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgV2Vha01hcCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL1dlYWtNYXAuanMnO1xuaW1wb3J0IExSVSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL0xSVS5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0cywgbWFwLCBpc0FycmF5LCBpc1N0cmluZywgaXNOdW1iZXIgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgZ2V0TGVhc3RDb21tb25NdWx0aXBsZSB9IGZyb20gJy4vbnVtYmVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZVN5bWJvbCB9IGZyb20gJy4vc3ltYm9sLmpzJztcbmltcG9ydCB7IGJydXNoU2luZ2xlIH0gZnJvbSAnenJlbmRlci9saWIvY2FudmFzL2dyYXBoaWMuanMnO1xuaW1wb3J0IHsgcGxhdGZvcm1BcGkgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3BsYXRmb3JtLmpzJztcbnZhciBkZWNhbE1hcCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgZGVjYWxDYWNoZSA9IG5ldyBMUlUoMTAwKTtcbnZhciBkZWNhbEtleXMgPSBbJ3N5bWJvbCcsICdzeW1ib2xTaXplJywgJ3N5bWJvbEtlZXBBc3BlY3QnLCAnY29sb3InLCAnYmFja2dyb3VuZENvbG9yJywgJ2Rhc2hBcnJheVgnLCAnZGFzaEFycmF5WScsICdtYXhUaWxlV2lkdGgnLCAnbWF4VGlsZUhlaWdodCddO1xuLyoqXHJcbiAqIENyZWF0ZSBvciB1cGRhdGUgcGF0dGVybiBpbWFnZSBmcm9tIGRlY2FsIG9wdGlvbnNcclxuICpcclxuICogQHBhcmFtIHtJbm5lckRlY2FsT2JqZWN0IHwgJ25vbmUnfSBkZWNhbE9iamVjdCBkZWNhbCBvcHRpb25zLCAnbm9uZScgaWYgbm8gZGVjYWxcclxuICogQHJldHVybiB7UGF0dGVybn0gcGF0dGVybiB3aXRoIGdlbmVyYXRlZCBpbWFnZSwgbnVsbCBpZiBubyBkZWNhbFxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZVBhdHRlcm5Gcm9tRGVjYWwoZGVjYWxPYmplY3QsIGFwaSkge1xuICBpZiAoZGVjYWxPYmplY3QgPT09ICdub25lJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBkcHIgPSBhcGkuZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgdmFyIGlzU1ZHID0genIucGFpbnRlci50eXBlID09PSAnc3ZnJztcbiAgaWYgKGRlY2FsT2JqZWN0LmRpcnR5KSB7XG4gICAgZGVjYWxNYXBbXCJkZWxldGVcIl0oZGVjYWxPYmplY3QpO1xuICB9XG4gIHZhciBvbGRQYXR0ZXJuID0gZGVjYWxNYXAuZ2V0KGRlY2FsT2JqZWN0KTtcbiAgaWYgKG9sZFBhdHRlcm4pIHtcbiAgICByZXR1cm4gb2xkUGF0dGVybjtcbiAgfVxuICB2YXIgZGVjYWxPcHQgPSBkZWZhdWx0cyhkZWNhbE9iamVjdCwge1xuICAgIHN5bWJvbDogJ3JlY3QnLFxuICAgIHN5bWJvbFNpemU6IDEsXG4gICAgc3ltYm9sS2VlcEFzcGVjdDogdHJ1ZSxcbiAgICBjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4yKScsXG4gICAgYmFja2dyb3VuZENvbG9yOiBudWxsLFxuICAgIGRhc2hBcnJheVg6IDUsXG4gICAgZGFzaEFycmF5WTogNSxcbiAgICByb3RhdGlvbjogMCxcbiAgICBtYXhUaWxlV2lkdGg6IDUxMixcbiAgICBtYXhUaWxlSGVpZ2h0OiA1MTJcbiAgfSk7XG4gIGlmIChkZWNhbE9wdC5iYWNrZ3JvdW5kQ29sb3IgPT09ICdub25lJykge1xuICAgIGRlY2FsT3B0LmJhY2tncm91bmRDb2xvciA9IG51bGw7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSB7XG4gICAgcmVwZWF0OiAncmVwZWF0J1xuICB9O1xuICBzZXRQYXR0ZXJublNvdXJjZShwYXR0ZXJuKTtcbiAgcGF0dGVybi5yb3RhdGlvbiA9IGRlY2FsT3B0LnJvdGF0aW9uO1xuICBwYXR0ZXJuLnNjYWxlWCA9IHBhdHRlcm4uc2NhbGVZID0gaXNTVkcgPyAxIDogMSAvIGRwcjtcbiAgZGVjYWxNYXAuc2V0KGRlY2FsT2JqZWN0LCBwYXR0ZXJuKTtcbiAgZGVjYWxPYmplY3QuZGlydHkgPSBmYWxzZTtcbiAgcmV0dXJuIHBhdHRlcm47XG4gIGZ1bmN0aW9uIHNldFBhdHRlcm5uU291cmNlKHBhdHRlcm4pIHtcbiAgICB2YXIga2V5cyA9IFtkcHJdO1xuICAgIHZhciBpc1ZhbGlkS2V5ID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlY2FsS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHZhbHVlID0gZGVjYWxPcHRbZGVjYWxLZXlzW2ldXTtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICFpc0FycmF5KHZhbHVlKSAmJiAhaXNTdHJpbmcodmFsdWUpICYmICFpc051bWJlcih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaXNWYWxpZEtleSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGtleXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHZhciBjYWNoZUtleTtcbiAgICBpZiAoaXNWYWxpZEtleSkge1xuICAgICAgY2FjaGVLZXkgPSBrZXlzLmpvaW4oJywnKSArIChpc1NWRyA/ICctc3ZnJyA6ICcnKTtcbiAgICAgIHZhciBjYWNoZSA9IGRlY2FsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBpc1NWRyA/IHBhdHRlcm4uc3ZnRWxlbWVudCA9IGNhY2hlIDogcGF0dGVybi5pbWFnZSA9IGNhY2hlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZGFzaEFycmF5WCA9IG5vcm1hbGl6ZURhc2hBcnJheVgoZGVjYWxPcHQuZGFzaEFycmF5WCk7XG4gICAgdmFyIGRhc2hBcnJheVkgPSBub3JtYWxpemVEYXNoQXJyYXlZKGRlY2FsT3B0LmRhc2hBcnJheVkpO1xuICAgIHZhciBzeW1ib2xBcnJheSA9IG5vcm1hbGl6ZVN5bWJvbEFycmF5KGRlY2FsT3B0LnN5bWJvbCk7XG4gICAgdmFyIGxpbmVCbG9ja0xlbmd0aHNYID0gZ2V0TGluZUJsb2NrTGVuZ3RoWChkYXNoQXJyYXlYKTtcbiAgICB2YXIgbGluZUJsb2NrTGVuZ3RoWSA9IGdldExpbmVCbG9ja0xlbmd0aFkoZGFzaEFycmF5WSk7XG4gICAgdmFyIGNhbnZhcyA9ICFpc1NWRyAmJiBwbGF0Zm9ybUFwaS5jcmVhdGVDYW52YXMoKTtcbiAgICB2YXIgc3ZnUm9vdCA9IGlzU1ZHICYmIHtcbiAgICAgIHRhZzogJ2cnLFxuICAgICAgYXR0cnM6IHt9LFxuICAgICAga2V5OiAnZGNsJyxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH07XG4gICAgdmFyIHBTaXplID0gZ2V0UGF0dGVyblNpemUoKTtcbiAgICB2YXIgY3R4O1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHBTaXplLndpZHRoICogZHByO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHBTaXplLmhlaWdodCAqIGRwcjtcbiAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH1cbiAgICBicnVzaERlY2FsKCk7XG4gICAgaWYgKGlzVmFsaWRLZXkpIHtcbiAgICAgIGRlY2FsQ2FjaGUucHV0KGNhY2hlS2V5LCBjYW52YXMgfHwgc3ZnUm9vdCk7XG4gICAgfVxuICAgIHBhdHRlcm4uaW1hZ2UgPSBjYW52YXM7XG4gICAgcGF0dGVybi5zdmdFbGVtZW50ID0gc3ZnUm9vdDtcbiAgICBwYXR0ZXJuLnN2Z1dpZHRoID0gcFNpemUud2lkdGg7XG4gICAgcGF0dGVybi5zdmdIZWlnaHQgPSBwU2l6ZS5oZWlnaHQ7XG4gICAgLyoqXHJcbiAgICAgKiBHZXQgbWluaW11bSBsZW5ndGggdGhhdCBjYW4gbWFrZSBhIHJlcGVhdGFibGUgcGF0dGVybi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBhdHRlcm4gd2lkdGggYW5kIGhlaWdodFxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UGF0dGVyblNpemUoKSB7XG4gICAgICAvKipcclxuICAgICAgICogRm9yIGV4YW1wbGUsIGlmIGRhc2ggaXMgW1szLCAyXSwgWzIsIDFdXSBmb3IgWCwgaXQgbG9va3MgbGlrZVxyXG4gICAgICAgKiB8LS0tICAtLS0gIC0tLSAgLS0tICAtLS0gLi4uXHJcbiAgICAgICAqIHwtLSAtLSAtLSAtLSAtLSAtLSAtLSAtLSAuLi5cclxuICAgICAgICogfC0tLSAgLS0tICAtLS0gIC0tLSAgLS0tIC4uLlxyXG4gICAgICAgKiB8LS0gLS0gLS0gLS0gLS0gLS0gLS0gLS0gLi4uXHJcbiAgICAgICAqIFNvIHRoZSBtaW5pbXVtIGxlbmd0aCBvZiBYIGlzIDE1LFxyXG4gICAgICAgKiB3aGljaCBpcyB0aGUgbGVhc3QgY29tbW9uIG11bHRpcGxlIG9mIGAzICsgMmAgYW5kIGAyICsgMWBcclxuICAgICAgICogfC0tLSAgLS0tICAtLS0gIHwtLS0gIC0tLSAuLi5cclxuICAgICAgICogfC0tIC0tIC0tIC0tIC0tIHwtLSAtLSAtLSAuLi5cclxuICAgICAgICovXG4gICAgICB2YXIgd2lkdGggPSAxO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHhsZW4gPSBsaW5lQmxvY2tMZW5ndGhzWC5sZW5ndGg7IGkgPCB4bGVuOyArK2kpIHtcbiAgICAgICAgd2lkdGggPSBnZXRMZWFzdENvbW1vbk11bHRpcGxlKHdpZHRoLCBsaW5lQmxvY2tMZW5ndGhzWFtpXSk7XG4gICAgICB9XG4gICAgICB2YXIgc3ltYm9sUmVwZWF0cyA9IDE7XG4gICAgICBmb3IgKHZhciBpID0gMCwgeGxlbiA9IHN5bWJvbEFycmF5Lmxlbmd0aDsgaSA8IHhsZW47ICsraSkge1xuICAgICAgICBzeW1ib2xSZXBlYXRzID0gZ2V0TGVhc3RDb21tb25NdWx0aXBsZShzeW1ib2xSZXBlYXRzLCBzeW1ib2xBcnJheVtpXS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgd2lkdGggKj0gc3ltYm9sUmVwZWF0cztcbiAgICAgIHZhciBoZWlnaHQgPSBsaW5lQmxvY2tMZW5ndGhZICogbGluZUJsb2NrTGVuZ3Roc1gubGVuZ3RoICogc3ltYm9sQXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHdhcm4gPSBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgKi9cbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJDYWxjdWxhdGVkIGRlY2FsIHNpemUgaXMgZ3JlYXRlciB0aGFuIFwiICsgYXR0ck5hbWUgKyBcIiBkdWUgdG8gZGVjYWwgb3B0aW9uIHNldHRpbmdzIHNvIFwiICsgYXR0ck5hbWUgKyBcIiBpcyB1c2VkIGZvciB0aGUgZGVjYWwgc2l6ZS4gUGxlYXNlIGNvbnNpZGVyIGNoYW5naW5nIHRoZSBkZWNhbCBvcHRpb24gdG8gbWFrZSBhIHNtYWxsZXIgZGVjYWwgb3Igc2V0IFwiICsgYXR0ck5hbWUgKyBcIiB0byBiZSBsYXJnZXIgdG8gYXZvaWQgaW5jb250aW51aXR5LlwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHdpZHRoID4gZGVjYWxPcHQubWF4VGlsZVdpZHRoKSB7XG4gICAgICAgICAgd2FybignbWF4VGlsZVdpZHRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodCA+IGRlY2FsT3B0Lm1heFRpbGVIZWlnaHQpIHtcbiAgICAgICAgICB3YXJuKCdtYXhUaWxlSGVpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBNYXRoLm1heCgxLCBNYXRoLm1pbih3aWR0aCwgZGVjYWxPcHQubWF4VGlsZVdpZHRoKSksXG4gICAgICAgIGhlaWdodDogTWF0aC5tYXgoMSwgTWF0aC5taW4oaGVpZ2h0LCBkZWNhbE9wdC5tYXhUaWxlSGVpZ2h0KSlcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJydXNoRGVjYWwoKSB7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgaWYgKGRlY2FsT3B0LmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBkZWNhbE9wdC5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB5U3VtID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGFzaEFycmF5WS5sZW5ndGg7ICsraSkge1xuICAgICAgICB5U3VtICs9IGRhc2hBcnJheVlbaV07XG4gICAgICB9XG4gICAgICBpZiAoeVN1bSA8PSAwKSB7XG4gICAgICAgIC8vIGRhc2hBcnJheVkgaXMgMCwgZHJhdyBub3RoaW5nXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB5ID0gLWxpbmVCbG9ja0xlbmd0aFk7XG4gICAgICB2YXIgeUlkID0gMDtcbiAgICAgIHZhciB5SWRUb3RhbCA9IDA7XG4gICAgICB2YXIgeElkMCA9IDA7XG4gICAgICB3aGlsZSAoeSA8IHBTaXplLmhlaWdodCkge1xuICAgICAgICBpZiAoeUlkICUgMiA9PT0gMCkge1xuICAgICAgICAgIHZhciBzeW1ib2xZSWQgPSB5SWRUb3RhbCAvIDIgJSBzeW1ib2xBcnJheS5sZW5ndGg7XG4gICAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICAgIHZhciB4SWQxID0gMDtcbiAgICAgICAgICB2YXIgeElkMVRvdGFsID0gMDtcbiAgICAgICAgICB3aGlsZSAoeCA8IHBTaXplLndpZHRoICogMikge1xuICAgICAgICAgICAgdmFyIHhTdW0gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXNoQXJyYXlYW3hJZDBdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHhTdW0gKz0gZGFzaEFycmF5WFt4SWQwXVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4U3VtIDw9IDApIHtcbiAgICAgICAgICAgICAgLy8gU2tpcCBlbXB0eSBsaW5lXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRS5nLiwgWzE1LCA1LCAyMCwgNV0gZHJhd3Mgb25seSBmb3IgMTUgYW5kIDIwXG4gICAgICAgICAgICBpZiAoeElkMSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgdmFyIHNpemUgPSAoMSAtIGRlY2FsT3B0LnN5bWJvbFNpemUpICogMC41O1xuICAgICAgICAgICAgICB2YXIgbGVmdCA9IHggKyBkYXNoQXJyYXlYW3hJZDBdW3hJZDFdICogc2l6ZTtcbiAgICAgICAgICAgICAgdmFyIHRvcF8xID0geSArIGRhc2hBcnJheVlbeUlkXSAqIHNpemU7XG4gICAgICAgICAgICAgIHZhciB3aWR0aCA9IGRhc2hBcnJheVhbeElkMF1beElkMV0gKiBkZWNhbE9wdC5zeW1ib2xTaXplO1xuICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZGFzaEFycmF5WVt5SWRdICogZGVjYWxPcHQuc3ltYm9sU2l6ZTtcbiAgICAgICAgICAgICAgdmFyIHN5bWJvbFhJZCA9IHhJZDFUb3RhbCAvIDIgJSBzeW1ib2xBcnJheVtzeW1ib2xZSWRdLmxlbmd0aDtcbiAgICAgICAgICAgICAgYnJ1c2hTeW1ib2wobGVmdCwgdG9wXzEsIHdpZHRoLCBoZWlnaHQsIHN5bWJvbEFycmF5W3N5bWJvbFlJZF1bc3ltYm9sWElkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ICs9IGRhc2hBcnJheVhbeElkMF1beElkMV07XG4gICAgICAgICAgICArK3hJZDFUb3RhbDtcbiAgICAgICAgICAgICsreElkMTtcbiAgICAgICAgICAgIGlmICh4SWQxID09PSBkYXNoQXJyYXlYW3hJZDBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICB4SWQxID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgKyt4SWQwO1xuICAgICAgICAgIGlmICh4SWQwID09PSBkYXNoQXJyYXlYLmxlbmd0aCkge1xuICAgICAgICAgICAgeElkMCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHkgKz0gZGFzaEFycmF5WVt5SWRdO1xuICAgICAgICArK3lJZFRvdGFsO1xuICAgICAgICArK3lJZDtcbiAgICAgICAgaWYgKHlJZCA9PT0gZGFzaEFycmF5WS5sZW5ndGgpIHtcbiAgICAgICAgICB5SWQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBicnVzaFN5bWJvbCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzeW1ib2xUeXBlKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IGlzU1ZHID8gMSA6IGRwcjtcbiAgICAgICAgdmFyIHN5bWJvbCA9IGNyZWF0ZVN5bWJvbChzeW1ib2xUeXBlLCB4ICogc2NhbGUsIHkgKiBzY2FsZSwgd2lkdGggKiBzY2FsZSwgaGVpZ2h0ICogc2NhbGUsIGRlY2FsT3B0LmNvbG9yLCBkZWNhbE9wdC5zeW1ib2xLZWVwQXNwZWN0KTtcbiAgICAgICAgaWYgKGlzU1ZHKSB7XG4gICAgICAgICAgdmFyIHN5bWJvbFZOb2RlID0genIucGFpbnRlci5yZW5kZXJPbmVUb1ZOb2RlKHN5bWJvbCk7XG4gICAgICAgICAgaWYgKHN5bWJvbFZOb2RlKSB7XG4gICAgICAgICAgICBzdmdSb290LmNoaWxkcmVuLnB1c2goc3ltYm9sVk5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBQYWludCB0byBjYW52YXMgZm9yIGFsbCBvdGhlciByZW5kZXJlcnMuXG4gICAgICAgICAgYnJ1c2hTaW5nbGUoY3R4LCBzeW1ib2wpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcclxuICogQ29udmVydCBzeW1ib2wgYXJyYXkgaW50byBub3JtYWxpemVkIGFycmF5XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgKHN0cmluZyB8IHN0cmluZ1tdKVtdfSBzeW1ib2wgc3ltYm9sIGlucHV0XHJcbiAqIEByZXR1cm4ge3N0cmluZ1tdW119IG5vcm1vbGl6ZWQgc3ltYm9sIGFycmF5XHJcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplU3ltYm9sQXJyYXkoc3ltYm9sKSB7XG4gIGlmICghc3ltYm9sIHx8IHN5bWJvbC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW1sncmVjdCddXTtcbiAgfVxuICBpZiAoaXNTdHJpbmcoc3ltYm9sKSkge1xuICAgIHJldHVybiBbW3N5bWJvbF1dO1xuICB9XG4gIHZhciBpc0FsbFN0cmluZyA9IHRydWU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9sLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFpc1N0cmluZyhzeW1ib2xbaV0pKSB7XG4gICAgICBpc0FsbFN0cmluZyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpc0FsbFN0cmluZykge1xuICAgIHJldHVybiBub3JtYWxpemVTeW1ib2xBcnJheShbc3ltYm9sXSk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbC5sZW5ndGg7ICsraSkge1xuICAgIGlmIChpc1N0cmluZyhzeW1ib2xbaV0pKSB7XG4gICAgICByZXN1bHQucHVzaChbc3ltYm9sW2ldXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKHN5bWJvbFtpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcclxuICogQ29udmVydCBkYXNoIGlucHV0IGludG8gZGFzaEFycmF5XHJcbiAqXHJcbiAqIEBwYXJhbSB7RGVjYWxEYXNoQXJyYXlYfSBkYXNoIGRhc2ggaW5wdXRcclxuICogQHJldHVybiB7bnVtYmVyW11bXX0gbm9ybW9saXplZCBkYXNoIGFycmF5XHJcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGFzaEFycmF5WChkYXNoKSB7XG4gIGlmICghZGFzaCB8fCBkYXNoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbWzAsIDBdXTtcbiAgfVxuICBpZiAoaXNOdW1iZXIoZGFzaCkpIHtcbiAgICB2YXIgZGFzaFZhbHVlID0gTWF0aC5jZWlsKGRhc2gpO1xuICAgIHJldHVybiBbW2Rhc2hWYWx1ZSwgZGFzaFZhbHVlXV07XG4gIH1cbiAgLyoqXHJcbiAgICogWzIwLCA1XSBzaG91bGQgYmUgbm9ybWFsaXplZCBpbnRvIFtbMjAsIDVdXSxcclxuICAgKiB3aGlsZSBbMjAsIFs1LCAxMF1dIHNob3VsZCBiZSBub3JtYWxpemVkIGludG8gW1syMCwgMjBdLCBbNSwgMTBdXVxyXG4gICAqL1xuICB2YXIgaXNBbGxOdW1iZXIgPSB0cnVlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhc2gubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIWlzTnVtYmVyKGRhc2hbaV0pKSB7XG4gICAgICBpc0FsbE51bWJlciA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpc0FsbE51bWJlcikge1xuICAgIHJldHVybiBub3JtYWxpemVEYXNoQXJyYXlYKFtkYXNoXSk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhc2gubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaXNOdW1iZXIoZGFzaFtpXSkpIHtcbiAgICAgIHZhciBkYXNoVmFsdWUgPSBNYXRoLmNlaWwoZGFzaFtpXSk7XG4gICAgICByZXN1bHQucHVzaChbZGFzaFZhbHVlLCBkYXNoVmFsdWVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhc2hWYWx1ZSA9IG1hcChkYXNoW2ldLCBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG4pO1xuICAgICAgfSk7XG4gICAgICBpZiAoZGFzaFZhbHVlLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgLy8gWzQsIDIsIDFdIG1lYW5zIHwtLS0tICAtICAgIC0tIHwtLS0tICAtICAgIC0tIHxcbiAgICAgICAgLy8gc28gbm9ybWFsaXplIGl0IHRvIGJlIFs0LCAyLCAxLCA0LCAyLCAxXVxuICAgICAgICByZXN1bHQucHVzaChkYXNoVmFsdWUuY29uY2F0KGRhc2hWYWx1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZGFzaFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0IGRhc2ggaW5wdXQgaW50byBkYXNoQXJyYXlcclxuICpcclxuICogQHBhcmFtIHtEZWNhbERhc2hBcnJheVl9IGRhc2ggZGFzaCBpbnB1dFxyXG4gKiBAcmV0dXJuIHtudW1iZXJbXX0gbm9ybW9saXplZCBkYXNoIGFycmF5XHJcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGFzaEFycmF5WShkYXNoKSB7XG4gIGlmICghZGFzaCB8fCB0eXBlb2YgZGFzaCA9PT0gJ29iamVjdCcgJiYgZGFzaC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gIGlmIChpc051bWJlcihkYXNoKSkge1xuICAgIHZhciBkYXNoVmFsdWVfMSA9IE1hdGguY2VpbChkYXNoKTtcbiAgICByZXR1cm4gW2Rhc2hWYWx1ZV8xLCBkYXNoVmFsdWVfMV07XG4gIH1cbiAgdmFyIGRhc2hWYWx1ZSA9IG1hcChkYXNoLCBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBNYXRoLmNlaWwobik7XG4gIH0pO1xuICByZXR1cm4gZGFzaC5sZW5ndGggJSAyID8gZGFzaFZhbHVlLmNvbmNhdChkYXNoVmFsdWUpIDogZGFzaFZhbHVlO1xufVxuLyoqXHJcbiAqIEdldCBibG9jayBsZW5ndGggb2YgZWFjaCBsaW5lLiBBIGJsb2NrIGlzIHRoZSBsZW5ndGggb2YgZGFzaCBsaW5lIGFuZCBzcGFjZS5cclxuICogRm9yIGV4YW1wbGUsIGEgbGluZSB3aXRoIFs0LCAxXSBoYXMgYSBkYXNoIGxpbmUgb2YgNCBhbmQgYSBzcGFjZSBvZiAxIGFmdGVyXHJcbiAqIHRoYXQsIHNvIHRoZSBibG9jayBsZW5ndGggb2YgdGhpcyBsaW5lIGlzIDUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyW11bXX0gZGFzaCBkYXNoIGFycmF5IG9mIFggb3IgWVxyXG4gKiBAcmV0dXJuIHtudW1iZXJbXX0gYmxvY2sgbGVuZ3RoIG9mIGVhY2ggbGluZVxyXG4gKi9cbmZ1bmN0aW9uIGdldExpbmVCbG9ja0xlbmd0aFgoZGFzaCkge1xuICByZXR1cm4gbWFwKGRhc2gsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgcmV0dXJuIGdldExpbmVCbG9ja0xlbmd0aFkobGluZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TGluZUJsb2NrTGVuZ3RoWShkYXNoKSB7XG4gIHZhciBibG9ja0xlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGFzaC5sZW5ndGg7ICsraSkge1xuICAgIGJsb2NrTGVuZ3RoICs9IGRhc2hbaV07XG4gIH1cbiAgaWYgKGRhc2gubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgIC8vIFs0LCAyLCAxXSBtZWFucyB8LS0tLSAgLSAgICAtLSB8LS0tLSAgLSAgICAtLSB8XG4gICAgLy8gU28gdG90YWwgbGVuZ3RoIGlzICg0ICsgMiArIDEpICogMlxuICAgIHJldHVybiBibG9ja0xlbmd0aCAqIDI7XG4gIH1cbiAgcmV0dXJuIGJsb2NrTGVuZ3RoO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///23538\n")},24326:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cb: () => (/* binding */ linearMap),\n/* harmony export */   Cm: () => (/* binding */ nice),\n/* harmony export */   IH: () => (/* binding */ getRandomIdBase),\n/* harmony export */   Is: () => (/* binding */ MAX_SAFE_INTEGER),\n/* harmony export */   LI: () => (/* binding */ round),\n/* harmony export */   NX: () => (/* binding */ quantityExponent),\n/* harmony export */   Sm: () => (/* binding */ numericToNumber),\n/* harmony export */   Tr: () => (/* binding */ addSafe),\n/* harmony export */   XV: () => (/* binding */ getPrecision),\n/* harmony export */   Y6: () => (/* binding */ asc),\n/* harmony export */   YV: () => (/* binding */ quantile),\n/* harmony export */   _7: () => (/* binding */ remRadian),\n/* harmony export */   _U: () => (/* binding */ parseDate),\n/* harmony export */   au: () => (/* binding */ quantity),\n/* harmony export */   dh: () => (/* binding */ isRadianAroundZero),\n/* harmony export */   hb: () => (/* binding */ getPixelPrecision),\n/* harmony export */   kM: () => (/* binding */ getPercentSeats),\n/* harmony export */   kf: () => (/* binding */ isNumeric),\n/* harmony export */   lQ: () => (/* binding */ getLeastCommonMultiple),\n/* harmony export */   lo: () => (/* binding */ parsePercent),\n/* harmony export */   sL: () => (/* binding */ reformIntervals),\n/* harmony export */   wp: () => (/* binding */ getPercentWithPrecision),\n/* harmony export */   y6: () => (/* binding */ getPrecisionSafe)\n/* harmony export */ });\n/* unused harmony export getGreatestCommonDividor */\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/*\r\n* A third-party license is embedded for some of the code in this file:\r\n* The method \"quantile\" was copied from \"d3.js\".\r\n* (See more details in the comment of the method below.)\r\n* The use of the source code of this file is also subject to the terms\r\n* and consitions of the license of \"d3.js\" (BSD-3Clause, see\r\n* </licenses/LICENSE-d3>).\r\n*/\n\nvar RADIAN_EPSILON = 1e-4;\n// Although chrome already enlarge this number to 100 for `toFixed`, but\n// we sill follow the spec for compatibility.\nvar ROUND_SUPPORTED_PRECISION_MAX = 20;\nfunction _trim(str) {\n  return str.replace(/^\\s+|\\s+$/g, '');\n}\n/**\r\n * Linear mapping a value from domain to range\r\n * @param  val\r\n * @param  domain Domain extent domain[0] can be bigger than domain[1]\r\n * @param  range  Range extent range[0] can be bigger than range[1]\r\n * @param  clamp Default to be false\r\n */\nfunction linearMap(val, domain, range, clamp) {\n  var d0 = domain[0];\n  var d1 = domain[1];\n  var r0 = range[0];\n  var r1 = range[1];\n  var subDomain = d1 - d0;\n  var subRange = r1 - r0;\n  if (subDomain === 0) {\n    return subRange === 0 ? r0 : (r0 + r1) / 2;\n  }\n  // Avoid accuracy problem in edge, such as\n  // 146.39 - 62.83 === 83.55999999999999.\n  // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n  // It is a little verbose for efficiency considering this method\n  // is a hotspot.\n  if (clamp) {\n    if (subDomain > 0) {\n      if (val <= d0) {\n        return r0;\n      } else if (val >= d1) {\n        return r1;\n      }\n    } else {\n      if (val >= d0) {\n        return r0;\n      } else if (val <= d1) {\n        return r1;\n      }\n    }\n  } else {\n    if (val === d0) {\n      return r0;\n    }\n    if (val === d1) {\n      return r1;\n    }\n  }\n  return (val - d0) / subDomain * subRange + r0;\n}\n/**\r\n * Convert a percent string to absolute number.\r\n * Returns NaN if percent is not a valid string or number\r\n */\nfunction parsePercent(percent, all) {\n  switch (percent) {\n    case 'center':\n    case 'middle':\n      percent = '50%';\n      break;\n    case 'left':\n    case 'top':\n      percent = '0%';\n      break;\n    case 'right':\n    case 'bottom':\n      percent = '100%';\n      break;\n  }\n  if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString(percent)) {\n    if (_trim(percent).match(/%$/)) {\n      return parseFloat(percent) / 100 * all;\n    }\n    return parseFloat(percent);\n  }\n  return percent == null ? NaN : +percent;\n}\nfunction round(x, precision, returnStr) {\n  if (precision == null) {\n    precision = 10;\n  }\n  // Avoid range error\n  precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX);\n  // PENDING: 1.005.toFixed(2) is '1.00' rather than '1.01'\n  x = (+x).toFixed(precision);\n  return returnStr ? x : +x;\n}\n/**\r\n * Inplacd asc sort arr.\r\n * The input arr will be modified.\r\n */\nfunction asc(arr) {\n  arr.sort(function (a, b) {\n    return a - b;\n  });\n  return arr;\n}\n/**\r\n * Get precision.\r\n */\nfunction getPrecision(val) {\n  val = +val;\n  if (isNaN(val)) {\n    return 0;\n  }\n  // It is much faster than methods converting number to string as follows\n  //      let tmp = val.toString();\n  //      return tmp.length - 1 - tmp.indexOf('.');\n  // especially when precision is low\n  // Notice:\n  // (1) If the loop count is over about 20, it is slower than `getPrecisionSafe`.\n  //     (see https://jsbench.me/2vkpcekkvw/1)\n  // (2) If the val is less than for example 1e-15, the result may be incorrect.\n  //     (see test/ut/spec/util/number.test.ts `getPrecision_equal_random`)\n  if (val > 1e-14) {\n    var e = 1;\n    for (var i = 0; i < 15; i++, e *= 10) {\n      if (Math.round(val * e) / e === val) {\n        return i;\n      }\n    }\n  }\n  return getPrecisionSafe(val);\n}\n/**\r\n * Get precision with slow but safe method\r\n */\nfunction getPrecisionSafe(val) {\n  // toLowerCase for: '3.4E-12'\n  var str = val.toString().toLowerCase();\n  // Consider scientific notation: '3.4e-12' '3.4e+12'\n  var eIndex = str.indexOf('e');\n  var exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;\n  var significandPartLen = eIndex > 0 ? eIndex : str.length;\n  var dotIndex = str.indexOf('.');\n  var decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;\n  return Math.max(0, decimalPartLen - exp);\n}\n/**\r\n * Minimal dicernible data precisioin according to a single pixel.\r\n */\nfunction getPixelPrecision(dataExtent, pixelExtent) {\n  var log = Math.log;\n  var LN10 = Math.LN10;\n  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n  // toFixed() digits argument must be between 0 and 20.\n  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n  return !isFinite(precision) ? 20 : precision;\n}\n/**\r\n * Get a data of given precision, assuring the sum of percentages\r\n * in valueList is 1.\r\n * The largest remainder method is used.\r\n * https://en.wikipedia.org/wiki/Largest_remainder_method\r\n *\r\n * @param valueList a list of all data\r\n * @param idx index of the data to be processed in valueList\r\n * @param precision integer number showing digits of precision\r\n * @return percent ranging from 0 to 100\r\n */\nfunction getPercentWithPrecision(valueList, idx, precision) {\n  if (!valueList[idx]) {\n    return 0;\n  }\n  var seats = getPercentSeats(valueList, precision);\n  return seats[idx] || 0;\n}\n/**\r\n * Get a data of given precision, assuring the sum of percentages\r\n * in valueList is 1.\r\n * The largest remainder method is used.\r\n * https://en.wikipedia.org/wiki/Largest_remainder_method\r\n *\r\n * @param valueList a list of all data\r\n * @param precision integer number showing digits of precision\r\n * @return {Array<number>}\r\n */\nfunction getPercentSeats(valueList, precision) {\n  var sum = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.reduce(valueList, function (acc, val) {\n    return acc + (isNaN(val) ? 0 : val);\n  }, 0);\n  if (sum === 0) {\n    return [];\n  }\n  var digits = Math.pow(10, precision);\n  var votesPerQuota = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map(valueList, function (val) {\n    return (isNaN(val) ? 0 : val) / sum * digits * 100;\n  });\n  var targetSeats = digits * 100;\n  var seats = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map(votesPerQuota, function (votes) {\n    // Assign automatic seats.\n    return Math.floor(votes);\n  });\n  var currentSum = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.reduce(seats, function (acc, val) {\n    return acc + val;\n  }, 0);\n  var remainder = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map(votesPerQuota, function (votes, idx) {\n    return votes - seats[idx];\n  });\n  // Has remainding votes.\n  while (currentSum < targetSeats) {\n    // Find next largest remainder.\n    var max = Number.NEGATIVE_INFINITY;\n    var maxId = null;\n    for (var i = 0, len = remainder.length; i < len; ++i) {\n      if (remainder[i] > max) {\n        max = remainder[i];\n        maxId = i;\n      }\n    }\n    // Add a vote to max remainder.\n    ++seats[maxId];\n    remainder[maxId] = 0;\n    ++currentSum;\n  }\n  return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map(seats, function (seat) {\n    return seat / digits;\n  });\n}\n/**\r\n * Solve the floating point adding problem like 0.1 + 0.2 === 0.30000000000000004\r\n * See <http://0.30000000000000004.com/>\r\n */\nfunction addSafe(val0, val1) {\n  var maxPrecision = Math.max(getPrecision(val0), getPrecision(val1));\n  // const multiplier = Math.pow(10, maxPrecision);\n  // return (Math.round(val0 * multiplier) + Math.round(val1 * multiplier)) / multiplier;\n  var sum = val0 + val1;\n  // // PENDING: support more?\n  return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum : round(sum, maxPrecision);\n}\n// Number.MAX_SAFE_INTEGER, ie do not support.\nvar MAX_SAFE_INTEGER = 9007199254740991;\n/**\r\n * To 0 - 2 * PI, considering negative radian.\r\n */\nfunction remRadian(radian) {\n  var pi2 = Math.PI * 2;\n  return (radian % pi2 + pi2) % pi2;\n}\n/**\r\n * @param {type} radian\r\n * @return {boolean}\r\n */\nfunction isRadianAroundZero(val) {\n  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n}\n// eslint-disable-next-line\nvar TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d{1,2})(?::(\\d{1,2})(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n/**\r\n * @param value valid type: number | string | Date, otherwise return `new Date(NaN)`\r\n *   These values can be accepted:\r\n *   + An instance of Date, represent a time in its own time zone.\r\n *   + Or string in a subset of ISO 8601, only including:\r\n *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\r\n *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\r\n *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\r\n *     all of which will be treated as local time if time zone is not specified\r\n *     (see <https://momentjs.com/>).\r\n *   + Or other string format, including (all of which will be treated as local time):\r\n *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\r\n *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\r\n *   + a timestamp, which represent a time in UTC.\r\n * @return date Never be null/undefined. If invalid, return `new Date(NaN)`.\r\n */\nfunction parseDate(value) {\n  if (value instanceof Date) {\n    return value;\n  } else if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString(value)) {\n    // Different browsers parse date in different way, so we parse it manually.\n    // Some other issues:\n    // new Date('1970-01-01') is UTC,\n    // new Date('1970/01/01') and new Date('1970-1-01') is local.\n    // See issue #3623\n    var match = TIME_REG.exec(value);\n    if (!match) {\n      // return Invalid Date.\n      return new Date(NaN);\n    }\n    // Use local time when no timezone offset is specified.\n    if (!match[8]) {\n      // match[n] can only be string or undefined.\n      // But take care of '12' + 1 => '121'.\n      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);\n    }\n    // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,\n    // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).\n    // For example, system timezone is set as \"Time Zone: America/Toronto\",\n    // then these code will get different result:\n    // `new Date(1478411999999).getTimezoneOffset();  // get 240`\n    // `new Date(1478412000000).getTimezoneOffset();  // get 300`\n    // So we should not use `new Date`, but use `Date.UTC`.\n    else {\n      var hour = +match[4] || 0;\n      if (match[8].toUpperCase() !== 'Z') {\n        hour -= +match[8].slice(0, 3);\n      }\n      return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));\n    }\n  } else if (value == null) {\n    return new Date(NaN);\n  }\n  return new Date(Math.round(value));\n}\n/**\r\n * Quantity of a number. e.g. 0.1, 1, 10, 100\r\n *\r\n * @param val\r\n * @return\r\n */\nfunction quantity(val) {\n  return Math.pow(10, quantityExponent(val));\n}\n/**\r\n * Exponent of the quantity of a number\r\n * e.g., 1234 equals to 1.234*10^3, so quantityExponent(1234) is 3\r\n *\r\n * @param val non-negative value\r\n * @return\r\n */\nfunction quantityExponent(val) {\n  if (val === 0) {\n    return 0;\n  }\n  var exp = Math.floor(Math.log(val) / Math.LN10);\n  /**\r\n   * exp is expected to be the rounded-down result of the base-10 log of val.\r\n   * But due to the precision loss with Math.log(val), we need to restore it\r\n   * using 10^exp to make sure we can get val back from exp. #11249\r\n   */\n  if (val / Math.pow(10, exp) >= 10) {\n    exp++;\n  }\n  return exp;\n}\n/**\r\n * find a nice number approximately equal to x. Round the number if round = true,\r\n * take ceiling if round = false. The primary observation is that the nicest\r\n * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\r\n *\r\n * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\r\n *\r\n * @param  val Non-negative value.\r\n * @param  round\r\n * @return Niced number\r\n */\nfunction nice(val, round) {\n  var exponent = quantityExponent(val);\n  var exp10 = Math.pow(10, exponent);\n  var f = val / exp10; // 1 <= f < 10\n  var nf;\n  if (round) {\n    if (f < 1.5) {\n      nf = 1;\n    } else if (f < 2.5) {\n      nf = 2;\n    } else if (f < 4) {\n      nf = 3;\n    } else if (f < 7) {\n      nf = 5;\n    } else {\n      nf = 10;\n    }\n  } else {\n    if (f < 1) {\n      nf = 1;\n    } else if (f < 2) {\n      nf = 2;\n    } else if (f < 3) {\n      nf = 3;\n    } else if (f < 5) {\n      nf = 5;\n    } else {\n      nf = 10;\n    }\n  }\n  val = nf * exp10;\n  // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n  // 20 is the uppper bound of toFixed.\n  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n}\n/**\r\n * This code was copied from \"d3.js\"\r\n * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/arrays/quantile.js>.\r\n * See the license statement at the head of this file.\r\n * @param ascArr\r\n */\nfunction quantile(ascArr, p) {\n  var H = (ascArr.length - 1) * p + 1;\n  var h = Math.floor(H);\n  var v = +ascArr[h - 1];\n  var e = H - h;\n  return e ? v + e * (ascArr[h] - v) : v;\n}\n/**\r\n * Order intervals asc, and split them when overlap.\r\n * expect(numberUtil.reformIntervals([\r\n *     {interval: [18, 62], close: [1, 1]},\r\n *     {interval: [-Infinity, -70], close: [0, 0]},\r\n *     {interval: [-70, -26], close: [1, 1]},\r\n *     {interval: [-26, 18], close: [1, 1]},\r\n *     {interval: [62, 150], close: [1, 1]},\r\n *     {interval: [106, 150], close: [1, 1]},\r\n *     {interval: [150, Infinity], close: [0, 0]}\r\n * ])).toEqual([\r\n *     {interval: [-Infinity, -70], close: [0, 0]},\r\n *     {interval: [-70, -26], close: [1, 1]},\r\n *     {interval: [-26, 18], close: [0, 1]},\r\n *     {interval: [18, 62], close: [0, 1]},\r\n *     {interval: [62, 150], close: [0, 1]},\r\n *     {interval: [150, Infinity], close: [0, 0]}\r\n * ]);\r\n * @param list, where `close` mean open or close\r\n *        of the interval, and Infinity can be used.\r\n * @return The origin list, which has been reformed.\r\n */\nfunction reformIntervals(list) {\n  list.sort(function (a, b) {\n    return littleThan(a, b, 0) ? -1 : 1;\n  });\n  var curr = -Infinity;\n  var currClose = 1;\n  for (var i = 0; i < list.length;) {\n    var interval = list[i].interval;\n    var close_1 = list[i].close;\n    for (var lg = 0; lg < 2; lg++) {\n      if (interval[lg] <= curr) {\n        interval[lg] = curr;\n        close_1[lg] = !lg ? 1 - currClose : 1;\n      }\n      curr = interval[lg];\n      currClose = close_1[lg];\n    }\n    if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) {\n      list.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n  return list;\n  function littleThan(a, b, lg) {\n    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));\n  }\n}\n/**\r\n * [Numeric is defined as]:\r\n *     `parseFloat(val) == val`\r\n * For example:\r\n * numeric:\r\n *     typeof number except NaN, '-123', '123', '2e3', '-2e3', '011', 'Infinity', Infinity,\r\n *     and they rounded by white-spaces or line-terminal like ' -123 \\n ' (see es spec)\r\n * not-numeric:\r\n *     null, undefined, [], {}, true, false, 'NaN', NaN, '123ab',\r\n *     empty string, string with only white-spaces or line-terminal (see es spec),\r\n *     0x12, '0x12', '-0x12', 012, '012', '-012',\r\n *     non-string, ...\r\n *\r\n * @test See full test cases in `test/ut/spec/util/number.js`.\r\n * @return Must be a typeof number. If not numeric, return NaN.\r\n */\nfunction numericToNumber(val) {\n  var valFloat = parseFloat(val);\n  return valFloat == val // eslint-disable-line eqeqeq\n  && (valFloat !== 0 || !zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString(val) || val.indexOf('x') <= 0) // For case ' 0x0 '.\n  ? valFloat : NaN;\n}\n/**\r\n * Definition of \"numeric\": see `numericToNumber`.\r\n */\nfunction isNumeric(val) {\n  return !isNaN(numericToNumber(val));\n}\n/**\r\n * Use random base to prevent users hard code depending on\r\n * this auto generated marker id.\r\n * @return An positive integer.\r\n */\nfunction getRandomIdBase() {\n  return Math.round(Math.random() * 9);\n}\n/**\r\n * Get the greatest common divisor.\r\n *\r\n * @param {number} a one number\r\n * @param {number} b the other number\r\n */\nfunction getGreatestCommonDividor(a, b) {\n  if (b === 0) {\n    return a;\n  }\n  return getGreatestCommonDividor(b, a % b);\n}\n/**\r\n * Get the least common multiple.\r\n *\r\n * @param {number} a one number\r\n * @param {number} b the other number\r\n */\nfunction getLeastCommonMultiple(a, b) {\n  if (a == null) {\n    return b;\n  }\n  if (b == null) {\n    return a;\n  }\n  return a * b / getGreatestCommonDividor(a, b);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQzMjYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL251bWJlci5qcz9mMGZiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLypcclxuKiBBIHRoaXJkLXBhcnR5IGxpY2Vuc2UgaXMgZW1iZWRkZWQgZm9yIHNvbWUgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlOlxyXG4qIFRoZSBtZXRob2QgXCJxdWFudGlsZVwiIHdhcyBjb3BpZWQgZnJvbSBcImQzLmpzXCIuXHJcbiogKFNlZSBtb3JlIGRldGFpbHMgaW4gdGhlIGNvbW1lbnQgb2YgdGhlIG1ldGhvZCBiZWxvdy4pXHJcbiogVGhlIHVzZSBvZiB0aGUgc291cmNlIGNvZGUgb2YgdGhpcyBmaWxlIGlzIGFsc28gc3ViamVjdCB0byB0aGUgdGVybXNcclxuKiBhbmQgY29uc2l0aW9ucyBvZiB0aGUgbGljZW5zZSBvZiBcImQzLmpzXCIgKEJTRC0zQ2xhdXNlLCBzZWVcclxuKiA8L2xpY2Vuc2VzL0xJQ0VOU0UtZDM+KS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xudmFyIFJBRElBTl9FUFNJTE9OID0gMWUtNDtcbi8vIEFsdGhvdWdoIGNocm9tZSBhbHJlYWR5IGVubGFyZ2UgdGhpcyBudW1iZXIgdG8gMTAwIGZvciBgdG9GaXhlZGAsIGJ1dFxuLy8gd2Ugc2lsbCBmb2xsb3cgdGhlIHNwZWMgZm9yIGNvbXBhdGliaWxpdHkuXG52YXIgUk9VTkRfU1VQUE9SVEVEX1BSRUNJU0lPTl9NQVggPSAyMDtcbmZ1bmN0aW9uIF90cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbn1cbi8qKlxyXG4gKiBMaW5lYXIgbWFwcGluZyBhIHZhbHVlIGZyb20gZG9tYWluIHRvIHJhbmdlXHJcbiAqIEBwYXJhbSAgdmFsXHJcbiAqIEBwYXJhbSAgZG9tYWluIERvbWFpbiBleHRlbnQgZG9tYWluWzBdIGNhbiBiZSBiaWdnZXIgdGhhbiBkb21haW5bMV1cclxuICogQHBhcmFtICByYW5nZSAgUmFuZ2UgZXh0ZW50IHJhbmdlWzBdIGNhbiBiZSBiaWdnZXIgdGhhbiByYW5nZVsxXVxyXG4gKiBAcGFyYW0gIGNsYW1wIERlZmF1bHQgdG8gYmUgZmFsc2VcclxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyTWFwKHZhbCwgZG9tYWluLCByYW5nZSwgY2xhbXApIHtcbiAgdmFyIGQwID0gZG9tYWluWzBdO1xuICB2YXIgZDEgPSBkb21haW5bMV07XG4gIHZhciByMCA9IHJhbmdlWzBdO1xuICB2YXIgcjEgPSByYW5nZVsxXTtcbiAgdmFyIHN1YkRvbWFpbiA9IGQxIC0gZDA7XG4gIHZhciBzdWJSYW5nZSA9IHIxIC0gcjA7XG4gIGlmIChzdWJEb21haW4gPT09IDApIHtcbiAgICByZXR1cm4gc3ViUmFuZ2UgPT09IDAgPyByMCA6IChyMCArIHIxKSAvIDI7XG4gIH1cbiAgLy8gQXZvaWQgYWNjdXJhY3kgcHJvYmxlbSBpbiBlZGdlLCBzdWNoIGFzXG4gIC8vIDE0Ni4zOSAtIDYyLjgzID09PSA4My41NTk5OTk5OTk5OTk5OS5cbiAgLy8gU2VlIGVjaGFydHMvdGVzdC91dC9zcGVjL3V0aWwvbnVtYmVyLmpzI2xpbmVhck1hcCNhY2N1cmFjeUVycm9yXG4gIC8vIEl0IGlzIGEgbGl0dGxlIHZlcmJvc2UgZm9yIGVmZmljaWVuY3kgY29uc2lkZXJpbmcgdGhpcyBtZXRob2RcbiAgLy8gaXMgYSBob3RzcG90LlxuICBpZiAoY2xhbXApIHtcbiAgICBpZiAoc3ViRG9tYWluID4gMCkge1xuICAgICAgaWYgKHZhbCA8PSBkMCkge1xuICAgICAgICByZXR1cm4gcjA7XG4gICAgICB9IGVsc2UgaWYgKHZhbCA+PSBkMSkge1xuICAgICAgICByZXR1cm4gcjE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWwgPj0gZDApIHtcbiAgICAgICAgcmV0dXJuIHIwO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPD0gZDEpIHtcbiAgICAgICAgcmV0dXJuIHIxO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID09PSBkMCkge1xuICAgICAgcmV0dXJuIHIwO1xuICAgIH1cbiAgICBpZiAodmFsID09PSBkMSkge1xuICAgICAgcmV0dXJuIHIxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKHZhbCAtIGQwKSAvIHN1YkRvbWFpbiAqIHN1YlJhbmdlICsgcjA7XG59XG4vKipcclxuICogQ29udmVydCBhIHBlcmNlbnQgc3RyaW5nIHRvIGFic29sdXRlIG51bWJlci5cclxuICogUmV0dXJucyBOYU4gaWYgcGVyY2VudCBpcyBub3QgYSB2YWxpZCBzdHJpbmcgb3IgbnVtYmVyXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGVyY2VudChwZXJjZW50LCBhbGwpIHtcbiAgc3dpdGNoIChwZXJjZW50KSB7XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgcGVyY2VudCA9ICc1MCUnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHBlcmNlbnQgPSAnMCUnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICBwZXJjZW50ID0gJzEwMCUnO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgaWYgKHpyVXRpbC5pc1N0cmluZyhwZXJjZW50KSkge1xuICAgIGlmIChfdHJpbShwZXJjZW50KS5tYXRjaCgvJSQvKSkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocGVyY2VudCkgLyAxMDAgKiBhbGw7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUZsb2F0KHBlcmNlbnQpO1xuICB9XG4gIHJldHVybiBwZXJjZW50ID09IG51bGwgPyBOYU4gOiArcGVyY2VudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiByb3VuZCh4LCBwcmVjaXNpb24sIHJldHVyblN0cikge1xuICBpZiAocHJlY2lzaW9uID09IG51bGwpIHtcbiAgICBwcmVjaXNpb24gPSAxMDtcbiAgfVxuICAvLyBBdm9pZCByYW5nZSBlcnJvclxuICBwcmVjaXNpb24gPSBNYXRoLm1pbihNYXRoLm1heCgwLCBwcmVjaXNpb24pLCBST1VORF9TVVBQT1JURURfUFJFQ0lTSU9OX01BWCk7XG4gIC8vIFBFTkRJTkc6IDEuMDA1LnRvRml4ZWQoMikgaXMgJzEuMDAnIHJhdGhlciB0aGFuICcxLjAxJ1xuICB4ID0gKCt4KS50b0ZpeGVkKHByZWNpc2lvbik7XG4gIHJldHVybiByZXR1cm5TdHIgPyB4IDogK3g7XG59XG4vKipcclxuICogSW5wbGFjZCBhc2Mgc29ydCBhcnIuXHJcbiAqIFRoZSBpbnB1dCBhcnIgd2lsbCBiZSBtb2RpZmllZC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNjKGFycikge1xuICBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSk7XG4gIHJldHVybiBhcnI7XG59XG4vKipcclxuICogR2V0IHByZWNpc2lvbi5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJlY2lzaW9uKHZhbCkge1xuICB2YWwgPSArdmFsO1xuICBpZiAoaXNOYU4odmFsKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIEl0IGlzIG11Y2ggZmFzdGVyIHRoYW4gbWV0aG9kcyBjb252ZXJ0aW5nIG51bWJlciB0byBzdHJpbmcgYXMgZm9sbG93c1xuICAvLyAgICAgIGxldCB0bXAgPSB2YWwudG9TdHJpbmcoKTtcbiAgLy8gICAgICByZXR1cm4gdG1wLmxlbmd0aCAtIDEgLSB0bXAuaW5kZXhPZignLicpO1xuICAvLyBlc3BlY2lhbGx5IHdoZW4gcHJlY2lzaW9uIGlzIGxvd1xuICAvLyBOb3RpY2U6XG4gIC8vICgxKSBJZiB0aGUgbG9vcCBjb3VudCBpcyBvdmVyIGFib3V0IDIwLCBpdCBpcyBzbG93ZXIgdGhhbiBgZ2V0UHJlY2lzaW9uU2FmZWAuXG4gIC8vICAgICAoc2VlIGh0dHBzOi8vanNiZW5jaC5tZS8ydmtwY2Vra3Z3LzEpXG4gIC8vICgyKSBJZiB0aGUgdmFsIGlzIGxlc3MgdGhhbiBmb3IgZXhhbXBsZSAxZS0xNSwgdGhlIHJlc3VsdCBtYXkgYmUgaW5jb3JyZWN0LlxuICAvLyAgICAgKHNlZSB0ZXN0L3V0L3NwZWMvdXRpbC9udW1iZXIudGVzdC50cyBgZ2V0UHJlY2lzaW9uX2VxdWFsX3JhbmRvbWApXG4gIGlmICh2YWwgPiAxZS0xNCkge1xuICAgIHZhciBlID0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE1OyBpKyssIGUgKj0gMTApIHtcbiAgICAgIGlmIChNYXRoLnJvdW5kKHZhbCAqIGUpIC8gZSA9PT0gdmFsKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZ2V0UHJlY2lzaW9uU2FmZSh2YWwpO1xufVxuLyoqXHJcbiAqIEdldCBwcmVjaXNpb24gd2l0aCBzbG93IGJ1dCBzYWZlIG1ldGhvZFxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcmVjaXNpb25TYWZlKHZhbCkge1xuICAvLyB0b0xvd2VyQ2FzZSBmb3I6ICczLjRFLTEyJ1xuICB2YXIgc3RyID0gdmFsLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgLy8gQ29uc2lkZXIgc2NpZW50aWZpYyBub3RhdGlvbjogJzMuNGUtMTInICczLjRlKzEyJ1xuICB2YXIgZUluZGV4ID0gc3RyLmluZGV4T2YoJ2UnKTtcbiAgdmFyIGV4cCA9IGVJbmRleCA+IDAgPyArc3RyLnNsaWNlKGVJbmRleCArIDEpIDogMDtcbiAgdmFyIHNpZ25pZmljYW5kUGFydExlbiA9IGVJbmRleCA+IDAgPyBlSW5kZXggOiBzdHIubGVuZ3RoO1xuICB2YXIgZG90SW5kZXggPSBzdHIuaW5kZXhPZignLicpO1xuICB2YXIgZGVjaW1hbFBhcnRMZW4gPSBkb3RJbmRleCA8IDAgPyAwIDogc2lnbmlmaWNhbmRQYXJ0TGVuIC0gMSAtIGRvdEluZGV4O1xuICByZXR1cm4gTWF0aC5tYXgoMCwgZGVjaW1hbFBhcnRMZW4gLSBleHApO1xufVxuLyoqXHJcbiAqIE1pbmltYWwgZGljZXJuaWJsZSBkYXRhIHByZWNpc2lvaW4gYWNjb3JkaW5nIHRvIGEgc2luZ2xlIHBpeGVsLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQaXhlbFByZWNpc2lvbihkYXRhRXh0ZW50LCBwaXhlbEV4dGVudCkge1xuICB2YXIgbG9nID0gTWF0aC5sb2c7XG4gIHZhciBMTjEwID0gTWF0aC5MTjEwO1xuICB2YXIgZGF0YVF1YW50aXR5ID0gTWF0aC5mbG9vcihsb2coZGF0YUV4dGVudFsxXSAtIGRhdGFFeHRlbnRbMF0pIC8gTE4xMCk7XG4gIHZhciBzaXplUXVhbnRpdHkgPSBNYXRoLnJvdW5kKGxvZyhNYXRoLmFicyhwaXhlbEV4dGVudFsxXSAtIHBpeGVsRXh0ZW50WzBdKSkgLyBMTjEwKTtcbiAgLy8gdG9GaXhlZCgpIGRpZ2l0cyBhcmd1bWVudCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjAuXG4gIHZhciBwcmVjaXNpb24gPSBNYXRoLm1pbihNYXRoLm1heCgtZGF0YVF1YW50aXR5ICsgc2l6ZVF1YW50aXR5LCAwKSwgMjApO1xuICByZXR1cm4gIWlzRmluaXRlKHByZWNpc2lvbikgPyAyMCA6IHByZWNpc2lvbjtcbn1cbi8qKlxyXG4gKiBHZXQgYSBkYXRhIG9mIGdpdmVuIHByZWNpc2lvbiwgYXNzdXJpbmcgdGhlIHN1bSBvZiBwZXJjZW50YWdlc1xyXG4gKiBpbiB2YWx1ZUxpc3QgaXMgMS5cclxuICogVGhlIGxhcmdlc3QgcmVtYWluZGVyIG1ldGhvZCBpcyB1c2VkLlxyXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXJnZXN0X3JlbWFpbmRlcl9tZXRob2RcclxuICpcclxuICogQHBhcmFtIHZhbHVlTGlzdCBhIGxpc3Qgb2YgYWxsIGRhdGFcclxuICogQHBhcmFtIGlkeCBpbmRleCBvZiB0aGUgZGF0YSB0byBiZSBwcm9jZXNzZWQgaW4gdmFsdWVMaXN0XHJcbiAqIEBwYXJhbSBwcmVjaXNpb24gaW50ZWdlciBudW1iZXIgc2hvd2luZyBkaWdpdHMgb2YgcHJlY2lzaW9uXHJcbiAqIEByZXR1cm4gcGVyY2VudCByYW5naW5nIGZyb20gMCB0byAxMDBcclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGVyY2VudFdpdGhQcmVjaXNpb24odmFsdWVMaXN0LCBpZHgsIHByZWNpc2lvbikge1xuICBpZiAoIXZhbHVlTGlzdFtpZHhdKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHNlYXRzID0gZ2V0UGVyY2VudFNlYXRzKHZhbHVlTGlzdCwgcHJlY2lzaW9uKTtcbiAgcmV0dXJuIHNlYXRzW2lkeF0gfHwgMDtcbn1cbi8qKlxyXG4gKiBHZXQgYSBkYXRhIG9mIGdpdmVuIHByZWNpc2lvbiwgYXNzdXJpbmcgdGhlIHN1bSBvZiBwZXJjZW50YWdlc1xyXG4gKiBpbiB2YWx1ZUxpc3QgaXMgMS5cclxuICogVGhlIGxhcmdlc3QgcmVtYWluZGVyIG1ldGhvZCBpcyB1c2VkLlxyXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXJnZXN0X3JlbWFpbmRlcl9tZXRob2RcclxuICpcclxuICogQHBhcmFtIHZhbHVlTGlzdCBhIGxpc3Qgb2YgYWxsIGRhdGFcclxuICogQHBhcmFtIHByZWNpc2lvbiBpbnRlZ2VyIG51bWJlciBzaG93aW5nIGRpZ2l0cyBvZiBwcmVjaXNpb25cclxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn1cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGVyY2VudFNlYXRzKHZhbHVlTGlzdCwgcHJlY2lzaW9uKSB7XG4gIHZhciBzdW0gPSB6clV0aWwucmVkdWNlKHZhbHVlTGlzdCwgZnVuY3Rpb24gKGFjYywgdmFsKSB7XG4gICAgcmV0dXJuIGFjYyArIChpc05hTih2YWwpID8gMCA6IHZhbCk7XG4gIH0sIDApO1xuICBpZiAoc3VtID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBkaWdpdHMgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgdmFyIHZvdGVzUGVyUXVvdGEgPSB6clV0aWwubWFwKHZhbHVlTGlzdCwgZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiAoaXNOYU4odmFsKSA/IDAgOiB2YWwpIC8gc3VtICogZGlnaXRzICogMTAwO1xuICB9KTtcbiAgdmFyIHRhcmdldFNlYXRzID0gZGlnaXRzICogMTAwO1xuICB2YXIgc2VhdHMgPSB6clV0aWwubWFwKHZvdGVzUGVyUXVvdGEsIGZ1bmN0aW9uICh2b3Rlcykge1xuICAgIC8vIEFzc2lnbiBhdXRvbWF0aWMgc2VhdHMuXG4gICAgcmV0dXJuIE1hdGguZmxvb3Iodm90ZXMpO1xuICB9KTtcbiAgdmFyIGN1cnJlbnRTdW0gPSB6clV0aWwucmVkdWNlKHNlYXRzLCBmdW5jdGlvbiAoYWNjLCB2YWwpIHtcbiAgICByZXR1cm4gYWNjICsgdmFsO1xuICB9LCAwKTtcbiAgdmFyIHJlbWFpbmRlciA9IHpyVXRpbC5tYXAodm90ZXNQZXJRdW90YSwgZnVuY3Rpb24gKHZvdGVzLCBpZHgpIHtcbiAgICByZXR1cm4gdm90ZXMgLSBzZWF0c1tpZHhdO1xuICB9KTtcbiAgLy8gSGFzIHJlbWFpbmRpbmcgdm90ZXMuXG4gIHdoaWxlIChjdXJyZW50U3VtIDwgdGFyZ2V0U2VhdHMpIHtcbiAgICAvLyBGaW5kIG5leHQgbGFyZ2VzdCByZW1haW5kZXIuXG4gICAgdmFyIG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWF4SWQgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZW1haW5kZXIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmIChyZW1haW5kZXJbaV0gPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gcmVtYWluZGVyW2ldO1xuICAgICAgICBtYXhJZCA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCBhIHZvdGUgdG8gbWF4IHJlbWFpbmRlci5cbiAgICArK3NlYXRzW21heElkXTtcbiAgICByZW1haW5kZXJbbWF4SWRdID0gMDtcbiAgICArK2N1cnJlbnRTdW07XG4gIH1cbiAgcmV0dXJuIHpyVXRpbC5tYXAoc2VhdHMsIGZ1bmN0aW9uIChzZWF0KSB7XG4gICAgcmV0dXJuIHNlYXQgLyBkaWdpdHM7XG4gIH0pO1xufVxuLyoqXHJcbiAqIFNvbHZlIHRoZSBmbG9hdGluZyBwb2ludCBhZGRpbmcgcHJvYmxlbSBsaWtlIDAuMSArIDAuMiA9PT0gMC4zMDAwMDAwMDAwMDAwMDAwNFxyXG4gKiBTZWUgPGh0dHA6Ly8wLjMwMDAwMDAwMDAwMDAwMDA0LmNvbS8+XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFNhZmUodmFsMCwgdmFsMSkge1xuICB2YXIgbWF4UHJlY2lzaW9uID0gTWF0aC5tYXgoZ2V0UHJlY2lzaW9uKHZhbDApLCBnZXRQcmVjaXNpb24odmFsMSkpO1xuICAvLyBjb25zdCBtdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIG1heFByZWNpc2lvbik7XG4gIC8vIHJldHVybiAoTWF0aC5yb3VuZCh2YWwwICogbXVsdGlwbGllcikgKyBNYXRoLnJvdW5kKHZhbDEgKiBtdWx0aXBsaWVyKSkgLyBtdWx0aXBsaWVyO1xuICB2YXIgc3VtID0gdmFsMCArIHZhbDE7XG4gIC8vIC8vIFBFTkRJTkc6IHN1cHBvcnQgbW9yZT9cbiAgcmV0dXJuIG1heFByZWNpc2lvbiA+IFJPVU5EX1NVUFBPUlRFRF9QUkVDSVNJT05fTUFYID8gc3VtIDogcm91bmQoc3VtLCBtYXhQcmVjaXNpb24pO1xufVxuLy8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIGllIGRvIG5vdCBzdXBwb3J0LlxuZXhwb3J0IHZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcbi8qKlxyXG4gKiBUbyAwIC0gMiAqIFBJLCBjb25zaWRlcmluZyBuZWdhdGl2ZSByYWRpYW4uXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbVJhZGlhbihyYWRpYW4pIHtcbiAgdmFyIHBpMiA9IE1hdGguUEkgKiAyO1xuICByZXR1cm4gKHJhZGlhbiAlIHBpMiArIHBpMikgJSBwaTI7XG59XG4vKipcclxuICogQHBhcmFtIHt0eXBlfSByYWRpYW5cclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNSYWRpYW5Bcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gLVJBRElBTl9FUFNJTE9OICYmIHZhbCA8IFJBRElBTl9FUFNJTE9OO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG52YXIgVElNRV9SRUcgPSAvXig/OihcXGR7NH0pKD86Wy1cXC9dKFxcZHsxLDJ9KSg/OlstXFwvXShcXGR7MSwyfSkoPzpbVCBdKFxcZHsxLDJ9KSg/OjooXFxkezEsMn0pKD86OihcXGR7MSwyfSkoPzpbLixdKFxcZCspKT8pPyk/KFp8W1xcK1xcLV1cXGRcXGQ6P1xcZFxcZCk/KT8pPyk/KT8kLzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4vKipcclxuICogQHBhcmFtIHZhbHVlIHZhbGlkIHR5cGU6IG51bWJlciB8IHN0cmluZyB8IERhdGUsIG90aGVyd2lzZSByZXR1cm4gYG5ldyBEYXRlKE5hTilgXHJcbiAqICAgVGhlc2UgdmFsdWVzIGNhbiBiZSBhY2NlcHRlZDpcclxuICogICArIEFuIGluc3RhbmNlIG9mIERhdGUsIHJlcHJlc2VudCBhIHRpbWUgaW4gaXRzIG93biB0aW1lIHpvbmUuXHJcbiAqICAgKyBPciBzdHJpbmcgaW4gYSBzdWJzZXQgb2YgSVNPIDg2MDEsIG9ubHkgaW5jbHVkaW5nOlxyXG4gKiAgICAgKyBvbmx5IHllYXIsIG1vbnRoLCBkYXRlOiAnMjAxMi0wMycsICcyMDEyLTAzLTAxJywgJzIwMTItMDMtMDEgMDUnLCAnMjAxMi0wMy0wMSAwNTowNicsXHJcbiAqICAgICArIHNlcGFyYXRlZCB3aXRoIFQgb3Igc3BhY2U6ICcyMDEyLTAzLTAxVDEyOjIyOjMzLjEyMycsICcyMDEyLTAzLTAxIDEyOjIyOjMzLjEyMycsXHJcbiAqICAgICArIHRpbWUgem9uZTogJzIwMTItMDMtMDFUMTI6MjI6MzNaJywgJzIwMTItMDMtMDFUMTI6MjI6MzMrODAwMCcsICcyMDEyLTAzLTAxVDEyOjIyOjMzLTA1OjAwJyxcclxuICogICAgIGFsbCBvZiB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgYXMgbG9jYWwgdGltZSBpZiB0aW1lIHpvbmUgaXMgbm90IHNwZWNpZmllZFxyXG4gKiAgICAgKHNlZSA8aHR0cHM6Ly9tb21lbnRqcy5jb20vPikuXHJcbiAqICAgKyBPciBvdGhlciBzdHJpbmcgZm9ybWF0LCBpbmNsdWRpbmcgKGFsbCBvZiB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgYXMgbG9jYWwgdGltZSk6XHJcbiAqICAgICAnMjAxMicsICcyMDEyLTMtMScsICcyMDEyLzMvMScsICcyMDEyLzAzLzAxJyxcclxuICogICAgICcyMDA5LzYvMTIgMjowMCcsICcyMDA5LzYvMTIgMjowNTowOCcsICcyMDA5LzYvMTIgMjowNTowOC4xMjMnXHJcbiAqICAgKyBhIHRpbWVzdGFtcCwgd2hpY2ggcmVwcmVzZW50IGEgdGltZSBpbiBVVEMuXHJcbiAqIEByZXR1cm4gZGF0ZSBOZXZlciBiZSBudWxsL3VuZGVmaW5lZC4gSWYgaW52YWxpZCwgcmV0dXJuIGBuZXcgRGF0ZShOYU4pYC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEYXRlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSBpZiAoenJVdGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIC8vIERpZmZlcmVudCBicm93c2VycyBwYXJzZSBkYXRlIGluIGRpZmZlcmVudCB3YXksIHNvIHdlIHBhcnNlIGl0IG1hbnVhbGx5LlxuICAgIC8vIFNvbWUgb3RoZXIgaXNzdWVzOlxuICAgIC8vIG5ldyBEYXRlKCcxOTcwLTAxLTAxJykgaXMgVVRDLFxuICAgIC8vIG5ldyBEYXRlKCcxOTcwLzAxLzAxJykgYW5kIG5ldyBEYXRlKCcxOTcwLTEtMDEnKSBpcyBsb2NhbC5cbiAgICAvLyBTZWUgaXNzdWUgIzM2MjNcbiAgICB2YXIgbWF0Y2ggPSBUSU1FX1JFRy5leGVjKHZhbHVlKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAvLyByZXR1cm4gSW52YWxpZCBEYXRlLlxuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuICAgIC8vIFVzZSBsb2NhbCB0aW1lIHdoZW4gbm8gdGltZXpvbmUgb2Zmc2V0IGlzIHNwZWNpZmllZC5cbiAgICBpZiAoIW1hdGNoWzhdKSB7XG4gICAgICAvLyBtYXRjaFtuXSBjYW4gb25seSBiZSBzdHJpbmcgb3IgdW5kZWZpbmVkLlxuICAgICAgLy8gQnV0IHRha2UgY2FyZSBvZiAnMTInICsgMSA9PiAnMTIxJy5cbiAgICAgIHJldHVybiBuZXcgRGF0ZSgrbWF0Y2hbMV0sICsobWF0Y2hbMl0gfHwgMSkgLSAxLCArbWF0Y2hbM10gfHwgMSwgK21hdGNoWzRdIHx8IDAsICsobWF0Y2hbNV0gfHwgMCksICttYXRjaFs2XSB8fCAwLCBtYXRjaFs3XSA/ICttYXRjaFs3XS5zdWJzdHJpbmcoMCwgMykgOiAwKTtcbiAgICB9XG4gICAgLy8gVGltZXpvbmVvZmZzZXQgb2YgSmF2YXNjcmlwdCBEYXRlIGhhcyBjb25zaWRlcmVkIERTVCAoRGF5bGlnaHQgU2F2aW5nIFRpbWUsXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGF5bGlnaHQtc2F2aW5nLXRpbWUtYWRqdXN0bWVudCkuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHN5c3RlbSB0aW1lem9uZSBpcyBzZXQgYXMgXCJUaW1lIFpvbmU6IEFtZXJpY2EvVG9yb250b1wiLFxuICAgIC8vIHRoZW4gdGhlc2UgY29kZSB3aWxsIGdldCBkaWZmZXJlbnQgcmVzdWx0OlxuICAgIC8vIGBuZXcgRGF0ZSgxNDc4NDExOTk5OTk5KS5nZXRUaW1lem9uZU9mZnNldCgpOyAgLy8gZ2V0IDI0MGBcbiAgICAvLyBgbmV3IERhdGUoMTQ3ODQxMjAwMDAwMCkuZ2V0VGltZXpvbmVPZmZzZXQoKTsgIC8vIGdldCAzMDBgXG4gICAgLy8gU28gd2Ugc2hvdWxkIG5vdCB1c2UgYG5ldyBEYXRlYCwgYnV0IHVzZSBgRGF0ZS5VVENgLlxuICAgIGVsc2Uge1xuICAgICAgdmFyIGhvdXIgPSArbWF0Y2hbNF0gfHwgMDtcbiAgICAgIGlmIChtYXRjaFs4XS50b1VwcGVyQ2FzZSgpICE9PSAnWicpIHtcbiAgICAgICAgaG91ciAtPSArbWF0Y2hbOF0uc2xpY2UoMCwgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoK21hdGNoWzFdLCArKG1hdGNoWzJdIHx8IDEpIC0gMSwgK21hdGNoWzNdIHx8IDEsIGhvdXIsICsobWF0Y2hbNV0gfHwgMCksICttYXRjaFs2XSB8fCAwLCBtYXRjaFs3XSA/ICttYXRjaFs3XS5zdWJzdHJpbmcoMCwgMykgOiAwKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUoTWF0aC5yb3VuZCh2YWx1ZSkpO1xufVxuLyoqXHJcbiAqIFF1YW50aXR5IG9mIGEgbnVtYmVyLiBlLmcuIDAuMSwgMSwgMTAsIDEwMFxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsXHJcbiAqIEByZXR1cm5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpdHkodmFsKSB7XG4gIHJldHVybiBNYXRoLnBvdygxMCwgcXVhbnRpdHlFeHBvbmVudCh2YWwpKTtcbn1cbi8qKlxyXG4gKiBFeHBvbmVudCBvZiB0aGUgcXVhbnRpdHkgb2YgYSBudW1iZXJcclxuICogZS5nLiwgMTIzNCBlcXVhbHMgdG8gMS4yMzQqMTBeMywgc28gcXVhbnRpdHlFeHBvbmVudCgxMjM0KSBpcyAzXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWwgbm9uLW5lZ2F0aXZlIHZhbHVlXHJcbiAqIEByZXR1cm5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpdHlFeHBvbmVudCh2YWwpIHtcbiAgaWYgKHZhbCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBleHAgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMTApO1xuICAvKipcclxuICAgKiBleHAgaXMgZXhwZWN0ZWQgdG8gYmUgdGhlIHJvdW5kZWQtZG93biByZXN1bHQgb2YgdGhlIGJhc2UtMTAgbG9nIG9mIHZhbC5cclxuICAgKiBCdXQgZHVlIHRvIHRoZSBwcmVjaXNpb24gbG9zcyB3aXRoIE1hdGgubG9nKHZhbCksIHdlIG5lZWQgdG8gcmVzdG9yZSBpdFxyXG4gICAqIHVzaW5nIDEwXmV4cCB0byBtYWtlIHN1cmUgd2UgY2FuIGdldCB2YWwgYmFjayBmcm9tIGV4cC4gIzExMjQ5XHJcbiAgICovXG4gIGlmICh2YWwgLyBNYXRoLnBvdygxMCwgZXhwKSA+PSAxMCkge1xuICAgIGV4cCsrO1xuICB9XG4gIHJldHVybiBleHA7XG59XG4vKipcclxuICogZmluZCBhIOKAnG5pY2XigJ0gbnVtYmVyIGFwcHJveGltYXRlbHkgZXF1YWwgdG8geC4gUm91bmQgdGhlIG51bWJlciBpZiByb3VuZCA9IHRydWUsXHJcbiAqIHRha2UgY2VpbGluZyBpZiByb3VuZCA9IGZhbHNlLiBUaGUgcHJpbWFyeSBvYnNlcnZhdGlvbiBpcyB0aGF0IHRoZSDigJxuaWNlc3TigJ1cclxuICogbnVtYmVycyBpbiBkZWNpbWFsIGFyZSAxLCAyLCBhbmQgNSwgYW5kIGFsbCBwb3dlci1vZi10ZW4gbXVsdGlwbGVzIG9mIHRoZXNlIG51bWJlcnMuXHJcbiAqXHJcbiAqIFNlZSBcIk5pY2UgTnVtYmVycyBmb3IgR3JhcGggTGFiZWxzXCIgb2YgR3JhcGhpYyBHZW1zLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHZhbCBOb24tbmVnYXRpdmUgdmFsdWUuXHJcbiAqIEBwYXJhbSAgcm91bmRcclxuICogQHJldHVybiBOaWNlZCBudW1iZXJcclxuICovXG5leHBvcnQgZnVuY3Rpb24gbmljZSh2YWwsIHJvdW5kKSB7XG4gIHZhciBleHBvbmVudCA9IHF1YW50aXR5RXhwb25lbnQodmFsKTtcbiAgdmFyIGV4cDEwID0gTWF0aC5wb3coMTAsIGV4cG9uZW50KTtcbiAgdmFyIGYgPSB2YWwgLyBleHAxMDsgLy8gMSA8PSBmIDwgMTBcbiAgdmFyIG5mO1xuICBpZiAocm91bmQpIHtcbiAgICBpZiAoZiA8IDEuNSkge1xuICAgICAgbmYgPSAxO1xuICAgIH0gZWxzZSBpZiAoZiA8IDIuNSkge1xuICAgICAgbmYgPSAyO1xuICAgIH0gZWxzZSBpZiAoZiA8IDQpIHtcbiAgICAgIG5mID0gMztcbiAgICB9IGVsc2UgaWYgKGYgPCA3KSB7XG4gICAgICBuZiA9IDU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5mID0gMTA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChmIDwgMSkge1xuICAgICAgbmYgPSAxO1xuICAgIH0gZWxzZSBpZiAoZiA8IDIpIHtcbiAgICAgIG5mID0gMjtcbiAgICB9IGVsc2UgaWYgKGYgPCAzKSB7XG4gICAgICBuZiA9IDM7XG4gICAgfSBlbHNlIGlmIChmIDwgNSkge1xuICAgICAgbmYgPSA1O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZiA9IDEwO1xuICAgIH1cbiAgfVxuICB2YWwgPSBuZiAqIGV4cDEwO1xuICAvLyBGaXggMyAqIDAuMSA9PT0gMC4zMDAwMDAwMDAwMDAwMDAwNCBpc3N1ZSAoc2VlIElFRUUgNzU0KS5cbiAgLy8gMjAgaXMgdGhlIHVwcHBlciBib3VuZCBvZiB0b0ZpeGVkLlxuICByZXR1cm4gZXhwb25lbnQgPj0gLTIwID8gK3ZhbC50b0ZpeGVkKGV4cG9uZW50IDwgMCA/IC1leHBvbmVudCA6IDApIDogdmFsO1xufVxuLyoqXHJcbiAqIFRoaXMgY29kZSB3YXMgY29waWVkIGZyb20gXCJkMy5qc1wiXHJcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vZDMvZDMvYmxvYi85Y2M5YTg3NWU2MzZhMWRjZjM2Y2MxZTA3YmRmNzdlMWFkNmUyYzc0L3NyYy9hcnJheXMvcXVhbnRpbGUuanM+LlxyXG4gKiBTZWUgdGhlIGxpY2Vuc2Ugc3RhdGVtZW50IGF0IHRoZSBoZWFkIG9mIHRoaXMgZmlsZS5cclxuICogQHBhcmFtIGFzY0FyclxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGlsZShhc2NBcnIsIHApIHtcbiAgdmFyIEggPSAoYXNjQXJyLmxlbmd0aCAtIDEpICogcCArIDE7XG4gIHZhciBoID0gTWF0aC5mbG9vcihIKTtcbiAgdmFyIHYgPSArYXNjQXJyW2ggLSAxXTtcbiAgdmFyIGUgPSBIIC0gaDtcbiAgcmV0dXJuIGUgPyB2ICsgZSAqIChhc2NBcnJbaF0gLSB2KSA6IHY7XG59XG4vKipcclxuICogT3JkZXIgaW50ZXJ2YWxzIGFzYywgYW5kIHNwbGl0IHRoZW0gd2hlbiBvdmVybGFwLlxyXG4gKiBleHBlY3QobnVtYmVyVXRpbC5yZWZvcm1JbnRlcnZhbHMoW1xyXG4gKiAgICAge2ludGVydmFsOiBbMTgsIDYyXSwgY2xvc2U6IFsxLCAxXX0sXHJcbiAqICAgICB7aW50ZXJ2YWw6IFstSW5maW5pdHksIC03MF0sIGNsb3NlOiBbMCwgMF19LFxyXG4gKiAgICAge2ludGVydmFsOiBbLTcwLCAtMjZdLCBjbG9zZTogWzEsIDFdfSxcclxuICogICAgIHtpbnRlcnZhbDogWy0yNiwgMThdLCBjbG9zZTogWzEsIDFdfSxcclxuICogICAgIHtpbnRlcnZhbDogWzYyLCAxNTBdLCBjbG9zZTogWzEsIDFdfSxcclxuICogICAgIHtpbnRlcnZhbDogWzEwNiwgMTUwXSwgY2xvc2U6IFsxLCAxXX0sXHJcbiAqICAgICB7aW50ZXJ2YWw6IFsxNTAsIEluZmluaXR5XSwgY2xvc2U6IFswLCAwXX1cclxuICogXSkpLnRvRXF1YWwoW1xyXG4gKiAgICAge2ludGVydmFsOiBbLUluZmluaXR5LCAtNzBdLCBjbG9zZTogWzAsIDBdfSxcclxuICogICAgIHtpbnRlcnZhbDogWy03MCwgLTI2XSwgY2xvc2U6IFsxLCAxXX0sXHJcbiAqICAgICB7aW50ZXJ2YWw6IFstMjYsIDE4XSwgY2xvc2U6IFswLCAxXX0sXHJcbiAqICAgICB7aW50ZXJ2YWw6IFsxOCwgNjJdLCBjbG9zZTogWzAsIDFdfSxcclxuICogICAgIHtpbnRlcnZhbDogWzYyLCAxNTBdLCBjbG9zZTogWzAsIDFdfSxcclxuICogICAgIHtpbnRlcnZhbDogWzE1MCwgSW5maW5pdHldLCBjbG9zZTogWzAsIDBdfVxyXG4gKiBdKTtcclxuICogQHBhcmFtIGxpc3QsIHdoZXJlIGBjbG9zZWAgbWVhbiBvcGVuIG9yIGNsb3NlXHJcbiAqICAgICAgICBvZiB0aGUgaW50ZXJ2YWwsIGFuZCBJbmZpbml0eSBjYW4gYmUgdXNlZC5cclxuICogQHJldHVybiBUaGUgb3JpZ2luIGxpc3QsIHdoaWNoIGhhcyBiZWVuIHJlZm9ybWVkLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWZvcm1JbnRlcnZhbHMobGlzdCkge1xuICBsaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gbGl0dGxlVGhhbihhLCBiLCAwKSA/IC0xIDogMTtcbiAgfSk7XG4gIHZhciBjdXJyID0gLUluZmluaXR5O1xuICB2YXIgY3VyckNsb3NlID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDspIHtcbiAgICB2YXIgaW50ZXJ2YWwgPSBsaXN0W2ldLmludGVydmFsO1xuICAgIHZhciBjbG9zZV8xID0gbGlzdFtpXS5jbG9zZTtcbiAgICBmb3IgKHZhciBsZyA9IDA7IGxnIDwgMjsgbGcrKykge1xuICAgICAgaWYgKGludGVydmFsW2xnXSA8PSBjdXJyKSB7XG4gICAgICAgIGludGVydmFsW2xnXSA9IGN1cnI7XG4gICAgICAgIGNsb3NlXzFbbGddID0gIWxnID8gMSAtIGN1cnJDbG9zZSA6IDE7XG4gICAgICB9XG4gICAgICBjdXJyID0gaW50ZXJ2YWxbbGddO1xuICAgICAgY3VyckNsb3NlID0gY2xvc2VfMVtsZ107XG4gICAgfVxuICAgIGlmIChpbnRlcnZhbFswXSA9PT0gaW50ZXJ2YWxbMV0gJiYgY2xvc2VfMVswXSAqIGNsb3NlXzFbMV0gIT09IDEpIHtcbiAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0O1xuICBmdW5jdGlvbiBsaXR0bGVUaGFuKGEsIGIsIGxnKSB7XG4gICAgcmV0dXJuIGEuaW50ZXJ2YWxbbGddIDwgYi5pbnRlcnZhbFtsZ10gfHwgYS5pbnRlcnZhbFtsZ10gPT09IGIuaW50ZXJ2YWxbbGddICYmIChhLmNsb3NlW2xnXSAtIGIuY2xvc2VbbGddID09PSAoIWxnID8gMSA6IC0xKSB8fCAhbGcgJiYgbGl0dGxlVGhhbihhLCBiLCAxKSk7XG4gIH1cbn1cbi8qKlxyXG4gKiBbTnVtZXJpYyBpcyBkZWZpbmVkIGFzXTpcclxuICogICAgIGBwYXJzZUZsb2F0KHZhbCkgPT0gdmFsYFxyXG4gKiBGb3IgZXhhbXBsZTpcclxuICogbnVtZXJpYzpcclxuICogICAgIHR5cGVvZiBudW1iZXIgZXhjZXB0IE5hTiwgJy0xMjMnLCAnMTIzJywgJzJlMycsICctMmUzJywgJzAxMScsICdJbmZpbml0eScsIEluZmluaXR5LFxyXG4gKiAgICAgYW5kIHRoZXkgcm91bmRlZCBieSB3aGl0ZS1zcGFjZXMgb3IgbGluZS10ZXJtaW5hbCBsaWtlICcgLTEyMyBcXG4gJyAoc2VlIGVzIHNwZWMpXHJcbiAqIG5vdC1udW1lcmljOlxyXG4gKiAgICAgbnVsbCwgdW5kZWZpbmVkLCBbXSwge30sIHRydWUsIGZhbHNlLCAnTmFOJywgTmFOLCAnMTIzYWInLFxyXG4gKiAgICAgZW1wdHkgc3RyaW5nLCBzdHJpbmcgd2l0aCBvbmx5IHdoaXRlLXNwYWNlcyBvciBsaW5lLXRlcm1pbmFsIChzZWUgZXMgc3BlYyksXHJcbiAqICAgICAweDEyLCAnMHgxMicsICctMHgxMicsIDAxMiwgJzAxMicsICctMDEyJyxcclxuICogICAgIG5vbi1zdHJpbmcsIC4uLlxyXG4gKlxyXG4gKiBAdGVzdCBTZWUgZnVsbCB0ZXN0IGNhc2VzIGluIGB0ZXN0L3V0L3NwZWMvdXRpbC9udW1iZXIuanNgLlxyXG4gKiBAcmV0dXJuIE11c3QgYmUgYSB0eXBlb2YgbnVtYmVyLiBJZiBub3QgbnVtZXJpYywgcmV0dXJuIE5hTi5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gbnVtZXJpY1RvTnVtYmVyKHZhbCkge1xuICB2YXIgdmFsRmxvYXQgPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiB2YWxGbG9hdCA9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgJiYgKHZhbEZsb2F0ICE9PSAwIHx8ICF6clV0aWwuaXNTdHJpbmcodmFsKSB8fCB2YWwuaW5kZXhPZigneCcpIDw9IDApIC8vIEZvciBjYXNlICcgMHgwICcuXG4gID8gdmFsRmxvYXQgOiBOYU47XG59XG4vKipcclxuICogRGVmaW5pdGlvbiBvZiBcIm51bWVyaWNcIjogc2VlIGBudW1lcmljVG9OdW1iZXJgLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bWVyaWModmFsKSB7XG4gIHJldHVybiAhaXNOYU4obnVtZXJpY1RvTnVtYmVyKHZhbCkpO1xufVxuLyoqXHJcbiAqIFVzZSByYW5kb20gYmFzZSB0byBwcmV2ZW50IHVzZXJzIGhhcmQgY29kZSBkZXBlbmRpbmcgb25cclxuICogdGhpcyBhdXRvIGdlbmVyYXRlZCBtYXJrZXIgaWQuXHJcbiAqIEByZXR1cm4gQW4gcG9zaXRpdmUgaW50ZWdlci5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZG9tSWRCYXNlKCkge1xuICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogOSk7XG59XG4vKipcclxuICogR2V0IHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvci5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGEgb25lIG51bWJlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gYiB0aGUgb3RoZXIgbnVtYmVyXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdyZWF0ZXN0Q29tbW9uRGl2aWRvcihhLCBiKSB7XG4gIGlmIChiID09PSAwKSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgcmV0dXJuIGdldEdyZWF0ZXN0Q29tbW9uRGl2aWRvcihiLCBhICUgYik7XG59XG4vKipcclxuICogR2V0IHRoZSBsZWFzdCBjb21tb24gbXVsdGlwbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIG9uZSBudW1iZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IGIgdGhlIG90aGVyIG51bWJlclxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWFzdENvbW1vbk11bHRpcGxlKGEsIGIpIHtcbiAgaWYgKGEgPT0gbnVsbCkge1xuICAgIHJldHVybiBiO1xuICB9XG4gIGlmIChiID09IG51bGwpIHtcbiAgICByZXR1cm4gYTtcbiAgfVxuICByZXR1cm4gYSAqIGIgLyBnZXRHcmVhdGVzdENvbW1vbkRpdmlkb3IoYSwgYik7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24326\n")},24711:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IU: () => (/* binding */ clear),\n/* harmony export */   N: () => (/* binding */ createOrUpdate),\n/* harmony export */   nF: () => (/* binding */ throttle)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar ORIGIN_METHOD = '\\0__throttleOriginMethod';\nvar RATE = '\\0__throttleRate';\nvar THROTTLE_TYPE = '\\0__throttleType';\n;\n/**\r\n * @public\r\n * @param {(Function)} fn\r\n * @param {number} [delay=0] Unit: ms.\r\n * @param {boolean} [debounce=false]\r\n *        true: If call interval less than `delay`, only the last call works.\r\n *        false: If call interval less than `delay, call works on fixed rate.\r\n * @return {(Function)} throttled fn.\r\n */\nfunction throttle(fn, delay, debounce) {\n  var currCall;\n  var lastCall = 0;\n  var lastExec = 0;\n  var timer = null;\n  var diff;\n  var scope;\n  var args;\n  var debounceNextCall;\n  delay = delay || 0;\n  function exec() {\n    lastExec = new Date().getTime();\n    timer = null;\n    fn.apply(scope, args || []);\n  }\n  var cb = function () {\n    var cbArgs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      cbArgs[_i] = arguments[_i];\n    }\n    currCall = new Date().getTime();\n    scope = this;\n    args = cbArgs;\n    var thisDelay = debounceNextCall || delay;\n    var thisDebounce = debounceNextCall || debounce;\n    debounceNextCall = null;\n    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n    clearTimeout(timer);\n    // Here we should make sure that: the `exec` SHOULD NOT be called later\n    // than a new call of `cb`, that is, preserving the command order. Consider\n    // calculating \"scale rate\" when roaming as an example. When a call of `cb`\n    // happens, either the `exec` is called dierectly, or the call is delayed.\n    // But the delayed call should never be later than next call of `cb`. Under\n    // this assurance, we can simply update view state each time `dispatchAction`\n    // triggered by user roaming, but not need to add extra code to avoid the\n    // state being \"rolled-back\".\n    if (thisDebounce) {\n      timer = setTimeout(exec, thisDelay);\n    } else {\n      if (diff >= 0) {\n        exec();\n      } else {\n        timer = setTimeout(exec, -diff);\n      }\n    }\n    lastCall = currCall;\n  };\n  /**\r\n   * Clear throttle.\r\n   * @public\r\n   */\n  cb.clear = function () {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  };\n  /**\r\n   * Enable debounce once.\r\n   */\n  cb.debounceNextCall = function (debounceDelay) {\n    debounceNextCall = debounceDelay;\n  };\n  return cb;\n}\n/**\r\n * Create throttle method or update throttle rate.\r\n *\r\n * @example\r\n * ComponentView.prototype.render = function () {\r\n *     ...\r\n *     throttle.createOrUpdate(\r\n *         this,\r\n *         '_dispatchAction',\r\n *         this.model.get('throttle'),\r\n *         'fixRate'\r\n *     );\r\n * };\r\n * ComponentView.prototype.remove = function () {\r\n *     throttle.clear(this, '_dispatchAction');\r\n * };\r\n * ComponentView.prototype.dispose = function () {\r\n *     throttle.clear(this, '_dispatchAction');\r\n * };\r\n *\r\n */\nfunction createOrUpdate(obj, fnAttr, rate, throttleType) {\n  var fn = obj[fnAttr];\n  if (!fn) {\n    return;\n  }\n  var originFn = fn[ORIGIN_METHOD] || fn;\n  var lastThrottleType = fn[THROTTLE_TYPE];\n  var lastRate = fn[RATE];\n  if (lastRate !== rate || lastThrottleType !== throttleType) {\n    if (rate == null || !throttleType) {\n      return obj[fnAttr] = originFn;\n    }\n    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === 'debounce');\n    fn[ORIGIN_METHOD] = originFn;\n    fn[THROTTLE_TYPE] = throttleType;\n    fn[RATE] = rate;\n  }\n  return fn;\n}\n/**\r\n * Clear throttle. Example see throttle.createOrUpdate.\r\n */\nfunction clear(obj, fnAttr) {\n  var fn = obj[fnAttr];\n  if (fn && fn[ORIGIN_METHOD]) {\n    // Clear throttle\n    fn.clear && fn.clear();\n    obj[fnAttr] = fn[ORIGIN_METHOD];\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ3MTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL3Rocm90dGxlLmpzP2ZmNjIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG52YXIgT1JJR0lOX01FVEhPRCA9ICdcXDBfX3Rocm90dGxlT3JpZ2luTWV0aG9kJztcbnZhciBSQVRFID0gJ1xcMF9fdGhyb3R0bGVSYXRlJztcbnZhciBUSFJPVFRMRV9UWVBFID0gJ1xcMF9fdGhyb3R0bGVUeXBlJztcbjtcbi8qKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7KEZ1bmN0aW9uKX0gZm5cclxuICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXSBVbml0OiBtcy5cclxuICogQHBhcmFtIHtib29sZWFufSBbZGVib3VuY2U9ZmFsc2VdXHJcbiAqICAgICAgICB0cnVlOiBJZiBjYWxsIGludGVydmFsIGxlc3MgdGhhbiBgZGVsYXlgLCBvbmx5IHRoZSBsYXN0IGNhbGwgd29ya3MuXHJcbiAqICAgICAgICBmYWxzZTogSWYgY2FsbCBpbnRlcnZhbCBsZXNzIHRoYW4gYGRlbGF5LCBjYWxsIHdvcmtzIG9uIGZpeGVkIHJhdGUuXHJcbiAqIEByZXR1cm4geyhGdW5jdGlvbil9IHRocm90dGxlZCBmbi5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUoZm4sIGRlbGF5LCBkZWJvdW5jZSkge1xuICB2YXIgY3VyckNhbGw7XG4gIHZhciBsYXN0Q2FsbCA9IDA7XG4gIHZhciBsYXN0RXhlYyA9IDA7XG4gIHZhciB0aW1lciA9IG51bGw7XG4gIHZhciBkaWZmO1xuICB2YXIgc2NvcGU7XG4gIHZhciBhcmdzO1xuICB2YXIgZGVib3VuY2VOZXh0Q2FsbDtcbiAgZGVsYXkgPSBkZWxheSB8fCAwO1xuICBmdW5jdGlvbiBleGVjKCkge1xuICAgIGxhc3RFeGVjID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGltZXIgPSBudWxsO1xuICAgIGZuLmFwcGx5KHNjb3BlLCBhcmdzIHx8IFtdKTtcbiAgfVxuICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNiQXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBjYkFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgY3VyckNhbGwgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBzY29wZSA9IHRoaXM7XG4gICAgYXJncyA9IGNiQXJncztcbiAgICB2YXIgdGhpc0RlbGF5ID0gZGVib3VuY2VOZXh0Q2FsbCB8fCBkZWxheTtcbiAgICB2YXIgdGhpc0RlYm91bmNlID0gZGVib3VuY2VOZXh0Q2FsbCB8fCBkZWJvdW5jZTtcbiAgICBkZWJvdW5jZU5leHRDYWxsID0gbnVsbDtcbiAgICBkaWZmID0gY3VyckNhbGwgLSAodGhpc0RlYm91bmNlID8gbGFzdENhbGwgOiBsYXN0RXhlYykgLSB0aGlzRGVsYXk7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAvLyBIZXJlIHdlIHNob3VsZCBtYWtlIHN1cmUgdGhhdDogdGhlIGBleGVjYCBTSE9VTEQgTk9UIGJlIGNhbGxlZCBsYXRlclxuICAgIC8vIHRoYW4gYSBuZXcgY2FsbCBvZiBgY2JgLCB0aGF0IGlzLCBwcmVzZXJ2aW5nIHRoZSBjb21tYW5kIG9yZGVyLiBDb25zaWRlclxuICAgIC8vIGNhbGN1bGF0aW5nIFwic2NhbGUgcmF0ZVwiIHdoZW4gcm9hbWluZyBhcyBhbiBleGFtcGxlLiBXaGVuIGEgY2FsbCBvZiBgY2JgXG4gICAgLy8gaGFwcGVucywgZWl0aGVyIHRoZSBgZXhlY2AgaXMgY2FsbGVkIGRpZXJlY3RseSwgb3IgdGhlIGNhbGwgaXMgZGVsYXllZC5cbiAgICAvLyBCdXQgdGhlIGRlbGF5ZWQgY2FsbCBzaG91bGQgbmV2ZXIgYmUgbGF0ZXIgdGhhbiBuZXh0IGNhbGwgb2YgYGNiYC4gVW5kZXJcbiAgICAvLyB0aGlzIGFzc3VyYW5jZSwgd2UgY2FuIHNpbXBseSB1cGRhdGUgdmlldyBzdGF0ZSBlYWNoIHRpbWUgYGRpc3BhdGNoQWN0aW9uYFxuICAgIC8vIHRyaWdnZXJlZCBieSB1c2VyIHJvYW1pbmcsIGJ1dCBub3QgbmVlZCB0byBhZGQgZXh0cmEgY29kZSB0byBhdm9pZCB0aGVcbiAgICAvLyBzdGF0ZSBiZWluZyBcInJvbGxlZC1iYWNrXCIuXG4gICAgaWYgKHRoaXNEZWJvdW5jZSkge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWMsIHRoaXNEZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaWZmID49IDApIHtcbiAgICAgICAgZXhlYygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWMsIC1kaWZmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGFzdENhbGwgPSBjdXJyQ2FsbDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2xlYXIgdGhyb3R0bGUuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xuICBjYi5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBFbmFibGUgZGVib3VuY2Ugb25jZS5cclxuICAgKi9cbiAgY2IuZGVib3VuY2VOZXh0Q2FsbCA9IGZ1bmN0aW9uIChkZWJvdW5jZURlbGF5KSB7XG4gICAgZGVib3VuY2VOZXh0Q2FsbCA9IGRlYm91bmNlRGVsYXk7XG4gIH07XG4gIHJldHVybiBjYjtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgdGhyb3R0bGUgbWV0aG9kIG9yIHVwZGF0ZSB0aHJvdHRsZSByYXRlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAqICAgICAuLi5cclxuICogICAgIHRocm90dGxlLmNyZWF0ZU9yVXBkYXRlKFxyXG4gKiAgICAgICAgIHRoaXMsXHJcbiAqICAgICAgICAgJ19kaXNwYXRjaEFjdGlvbicsXHJcbiAqICAgICAgICAgdGhpcy5tb2RlbC5nZXQoJ3Rocm90dGxlJyksXHJcbiAqICAgICAgICAgJ2ZpeFJhdGUnXHJcbiAqICAgICApO1xyXG4gKiB9O1xyXG4gKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAqICAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoQWN0aW9uJyk7XHJcbiAqIH07XHJcbiAqIENvbXBvbmVudFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAqICAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoQWN0aW9uJyk7XHJcbiAqIH07XHJcbiAqXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlKG9iaiwgZm5BdHRyLCByYXRlLCB0aHJvdHRsZVR5cGUpIHtcbiAgdmFyIGZuID0gb2JqW2ZuQXR0cl07XG4gIGlmICghZm4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9yaWdpbkZuID0gZm5bT1JJR0lOX01FVEhPRF0gfHwgZm47XG4gIHZhciBsYXN0VGhyb3R0bGVUeXBlID0gZm5bVEhST1RUTEVfVFlQRV07XG4gIHZhciBsYXN0UmF0ZSA9IGZuW1JBVEVdO1xuICBpZiAobGFzdFJhdGUgIT09IHJhdGUgfHwgbGFzdFRocm90dGxlVHlwZSAhPT0gdGhyb3R0bGVUeXBlKSB7XG4gICAgaWYgKHJhdGUgPT0gbnVsbCB8fCAhdGhyb3R0bGVUeXBlKSB7XG4gICAgICByZXR1cm4gb2JqW2ZuQXR0cl0gPSBvcmlnaW5GbjtcbiAgICB9XG4gICAgZm4gPSBvYmpbZm5BdHRyXSA9IHRocm90dGxlKG9yaWdpbkZuLCByYXRlLCB0aHJvdHRsZVR5cGUgPT09ICdkZWJvdW5jZScpO1xuICAgIGZuW09SSUdJTl9NRVRIT0RdID0gb3JpZ2luRm47XG4gICAgZm5bVEhST1RUTEVfVFlQRV0gPSB0aHJvdHRsZVR5cGU7XG4gICAgZm5bUkFURV0gPSByYXRlO1xuICB9XG4gIHJldHVybiBmbjtcbn1cbi8qKlxyXG4gKiBDbGVhciB0aHJvdHRsZS4gRXhhbXBsZSBzZWUgdGhyb3R0bGUuY3JlYXRlT3JVcGRhdGUuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKG9iaiwgZm5BdHRyKSB7XG4gIHZhciBmbiA9IG9ialtmbkF0dHJdO1xuICBpZiAoZm4gJiYgZm5bT1JJR0lOX01FVEhPRF0pIHtcbiAgICAvLyBDbGVhciB0aHJvdHRsZVxuICAgIGZuLmNsZWFyICYmIGZuLmNsZWFyKCk7XG4gICAgb2JqW2ZuQXR0cl0gPSBmbltPUklHSU5fTUVUSE9EXTtcbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///24711\n")},30693:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CC: () => (/* binding */ parseClassType),\n/* harmony export */   Od: () => (/* binding */ enableClassCheck),\n/* harmony export */   _E: () => (/* binding */ isExtendedClass),\n/* harmony export */   gq: () => (/* binding */ enableClassExtend),\n/* harmony export */   q7: () => (/* binding */ mountExtend),\n/* harmony export */   tQ: () => (/* binding */ enableClassManagement)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar TYPE_DELIMITER = '.';\nvar IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\nvar IS_EXTENDED_CLASS = '___EC__EXTENDED_CLASS___';\n/**\r\n * Notice, parseClassType('') should returns {main: '', sub: ''}\r\n * @public\r\n */\nfunction parseClassType(componentType) {\n  var ret = {\n    main: '',\n    sub: ''\n  };\n  if (componentType) {\n    var typeArr = componentType.split(TYPE_DELIMITER);\n    ret.main = typeArr[0] || '';\n    ret.sub = typeArr[1] || '';\n  }\n  return ret;\n}\n/**\r\n * @public\r\n */\nfunction checkClassType(componentType) {\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType \"' + componentType + '\" illegal');\n}\nfunction isExtendedClass(clz) {\n  return !!(clz && clz[IS_EXTENDED_CLASS]);\n}\n/**\r\n * Implements `ExtendableConstructor` for `rootClz`.\r\n *\r\n * @usage\r\n * ```ts\r\n * class Xxx {}\r\n * type XxxConstructor = typeof Xxx & ExtendableConstructor\r\n * enableClassExtend(Xxx as XxxConstructor);\r\n * ```\r\n */\nfunction enableClassExtend(rootClz, mandatoryMethods) {\n  rootClz.$constructor = rootClz; // FIXME: not necessary?\n  rootClz.extend = function (proto) {\n    if (false) {}\n    var superClass = this;\n    var ExtendedClass;\n    if (isESClass(superClass)) {\n      ExtendedClass = /** @class */function (_super) {\n        (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .C6)(class_1, _super);\n        function class_1() {\n          return _super.apply(this, arguments) || this;\n        }\n        return class_1;\n      }(superClass);\n    } else {\n      // For backward compat, we both support ts class inheritance and this\n      // \"extend\" approach.\n      // The constructor should keep the same behavior as ts class inheritance:\n      // If this constructor/$constructor is not declared, auto invoke the super\n      // constructor.\n      // If this constructor/$constructor is declared, it is responsible for\n      // calling the super constructor.\n      ExtendedClass = function () {\n        (proto.$constructor || superClass).apply(this, arguments);\n      };\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.inherits(ExtendedClass, this);\n    }\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend(ExtendedClass.prototype, proto);\n    ExtendedClass[IS_EXTENDED_CLASS] = true;\n    ExtendedClass.extend = this.extend;\n    ExtendedClass.superCall = superCall;\n    ExtendedClass.superApply = superApply;\n    ExtendedClass.superClass = superClass;\n    return ExtendedClass;\n  };\n}\nfunction isESClass(fn) {\n  return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isFunction(fn) && /^class\\s/.test(Function.prototype.toString.call(fn));\n}\n/**\r\n * A work around to both support ts extend and this extend mechanism.\r\n * on sub-class.\r\n * @usage\r\n * ```ts\r\n * class Component { ... }\r\n * classUtil.enableClassExtend(Component);\r\n * classUtil.enableClassManagement(Component, {registerWhenExtend: true});\r\n *\r\n * class Series extends Component { ... }\r\n * // Without calling `markExtend`, `registerWhenExtend` will not work.\r\n * Component.markExtend(Series);\r\n * ```\r\n */\nfunction mountExtend(SubClz, SupperClz) {\n  SubClz.extend = SupperClz.extend;\n}\n// A random offset.\nvar classBase = Math.round(Math.random() * 10);\n/**\r\n * Implements `CheckableConstructor` for `target`.\r\n * Can not use instanceof, consider different scope by\r\n * cross domain or es module import in ec extensions.\r\n * Mount a method \"isInstance()\" to Clz.\r\n *\r\n * @usage\r\n * ```ts\r\n * class Xxx {}\r\n * type XxxConstructor = typeof Xxx & CheckableConstructor;\r\n * enableClassCheck(Xxx as XxxConstructor)\r\n * ```\r\n */\nfunction enableClassCheck(target) {\n  var classAttr = ['__\\0is_clz', classBase++].join('_');\n  target.prototype[classAttr] = true;\n  if (false) {}\n  target.isInstance = function (obj) {\n    return !!(obj && obj[classAttr]);\n  };\n}\n// superCall should have class info, which can not be fetched from 'this'.\n// Consider this case:\n// class A has method f,\n// class B inherits class A, overrides method f, f call superApply('f'),\n// class C inherits class B, does not override method f,\n// then when method of class C is called, dead loop occurred.\nfunction superCall(context, methodName) {\n  var args = [];\n  for (var _i = 2; _i < arguments.length; _i++) {\n    args[_i - 2] = arguments[_i];\n  }\n  return this.superClass.prototype[methodName].apply(context, args);\n}\nfunction superApply(context, methodName, args) {\n  return this.superClass.prototype[methodName].apply(context, args);\n}\n/**\r\n * Implements `ClassManager` for `target`\r\n *\r\n * @usage\r\n * ```ts\r\n * class Xxx {}\r\n * type XxxConstructor = typeof Xxx & ClassManager\r\n * enableClassManagement(Xxx as XxxConstructor);\r\n * ```\r\n */\nfunction enableClassManagement(target) {\n  /**\r\n   * Component model classes\r\n   * key: componentType,\r\n   * value:\r\n   *     componentClass, when componentType is 'a'\r\n   *     or Object.<subKey, componentClass>, when componentType is 'a.b'\r\n   */\n  var storage = {};\n  target.registerClass = function (clz) {\n    // `type` should not be a \"instance member\".\n    // If using TS class, should better declared as `static type = 'series.pie'`.\n    // otherwise users have to mount `type` on prototype manually.\n    // For backward compat and enable instance visit type via `this.type`,\n    // we still support fetch `type` from prototype.\n    var componentFullType = clz.type || clz.prototype.type;\n    if (componentFullType) {\n      checkClassType(componentFullType);\n      // If only static type declared, we assign it to prototype mandatorily.\n      clz.prototype.type = componentFullType;\n      var componentTypeInfo = parseClassType(componentFullType);\n      if (!componentTypeInfo.sub) {\n        if (false) {}\n        storage[componentTypeInfo.main] = clz;\n      } else if (componentTypeInfo.sub !== IS_CONTAINER) {\n        var container = makeContainer(componentTypeInfo);\n        container[componentTypeInfo.sub] = clz;\n      }\n    }\n    return clz;\n  };\n  target.getClass = function (mainType, subType, throwWhenNotFound) {\n    var clz = storage[mainType];\n    if (clz && clz[IS_CONTAINER]) {\n      clz = subType ? clz[subType] : null;\n    }\n    if (throwWhenNotFound && !clz) {\n      throw new Error(!subType ? mainType + '.' + 'type should be specified.' : 'Component ' + mainType + '.' + (subType || '') + ' is used but not imported.');\n    }\n    return clz;\n  };\n  target.getClassesByMainType = function (componentType) {\n    var componentTypeInfo = parseClassType(componentType);\n    var result = [];\n    var obj = storage[componentTypeInfo.main];\n    if (obj && obj[IS_CONTAINER]) {\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(obj, function (o, type) {\n        type !== IS_CONTAINER && result.push(o);\n      });\n    } else {\n      result.push(obj);\n    }\n    return result;\n  };\n  target.hasClass = function (componentType) {\n    // Just consider componentType.main.\n    var componentTypeInfo = parseClassType(componentType);\n    return !!storage[componentTypeInfo.main];\n  };\n  /**\r\n   * @return Like ['aa', 'bb'], but can not be ['aa.xx']\r\n   */\n  target.getAllClassMainTypes = function () {\n    var types = [];\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(storage, function (obj, type) {\n      types.push(type);\n    });\n    return types;\n  };\n  /**\r\n   * If a main type is container and has sub types\r\n   */\n  target.hasSubTypes = function (componentType) {\n    var componentTypeInfo = parseClassType(componentType);\n    var obj = storage[componentTypeInfo.main];\n    return obj && obj[IS_CONTAINER];\n  };\n  function makeContainer(componentTypeInfo) {\n    var container = storage[componentTypeInfo.main];\n    if (!container || !container[IS_CONTAINER]) {\n      container = storage[componentTypeInfo.main] = {};\n      container[IS_CONTAINER] = true;\n    }\n    return container;\n  }\n}\n// /**\n//  * @param {string|Array.<string>} properties\n//  */\n// export function setReadOnly(obj, properties) {\n// FIXME It seems broken in IE8 simulation of IE11\n// if (!zrUtil.isArray(properties)) {\n//     properties = properties != null ? [properties] : [];\n// }\n// zrUtil.each(properties, function (prop) {\n//     let value = obj[prop];\n//     Object.defineProperty\n//         && Object.defineProperty(obj, prop, {\n//             value: value, writable: false\n//         });\n//     zrUtil.isArray(obj[prop])\n//         && Object.freeze\n//         && Object.freeze(obj[prop]);\n// });\n// }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA2OTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9jbGF6ei5qcz8yZDgwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbnZhciBUWVBFX0RFTElNSVRFUiA9ICcuJztcbnZhciBJU19DT05UQUlORVIgPSAnX19fRUNfX0NPTVBPTkVOVF9fQ09OVEFJTkVSX19fJztcbnZhciBJU19FWFRFTkRFRF9DTEFTUyA9ICdfX19FQ19fRVhURU5ERURfQ0xBU1NfX18nO1xuLyoqXHJcbiAqIE5vdGljZSwgcGFyc2VDbGFzc1R5cGUoJycpIHNob3VsZCByZXR1cm5zIHttYWluOiAnJywgc3ViOiAnJ31cclxuICogQHB1YmxpY1xyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKSB7XG4gIHZhciByZXQgPSB7XG4gICAgbWFpbjogJycsXG4gICAgc3ViOiAnJ1xuICB9O1xuICBpZiAoY29tcG9uZW50VHlwZSkge1xuICAgIHZhciB0eXBlQXJyID0gY29tcG9uZW50VHlwZS5zcGxpdChUWVBFX0RFTElNSVRFUik7XG4gICAgcmV0Lm1haW4gPSB0eXBlQXJyWzBdIHx8ICcnO1xuICAgIHJldC5zdWIgPSB0eXBlQXJyWzFdIHx8ICcnO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4vKipcclxuICogQHB1YmxpY1xyXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpIHtcbiAgenJVdGlsLmFzc2VydCgvXlthLXpBLVowLTlfXSsoWy5dW2EtekEtWjAtOV9dKyk/JC8udGVzdChjb21wb25lbnRUeXBlKSwgJ2NvbXBvbmVudFR5cGUgXCInICsgY29tcG9uZW50VHlwZSArICdcIiBpbGxlZ2FsJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlbmRlZENsYXNzKGNseikge1xuICByZXR1cm4gISEoY2x6ICYmIGNseltJU19FWFRFTkRFRF9DTEFTU10pO1xufVxuLyoqXHJcbiAqIEltcGxlbWVudHMgYEV4dGVuZGFibGVDb25zdHJ1Y3RvcmAgZm9yIGByb290Q2x6YC5cclxuICpcclxuICogQHVzYWdlXHJcbiAqIGBgYHRzXHJcbiAqIGNsYXNzIFh4eCB7fVxyXG4gKiB0eXBlIFh4eENvbnN0cnVjdG9yID0gdHlwZW9mIFh4eCAmIEV4dGVuZGFibGVDb25zdHJ1Y3RvclxyXG4gKiBlbmFibGVDbGFzc0V4dGVuZChYeHggYXMgWHh4Q29uc3RydWN0b3IpO1xyXG4gKiBgYGBcclxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlQ2xhc3NFeHRlbmQocm9vdENseiwgbWFuZGF0b3J5TWV0aG9kcykge1xuICByb290Q2x6LiRjb25zdHJ1Y3RvciA9IHJvb3RDbHo7IC8vIEZJWE1FOiBub3QgbmVjZXNzYXJ5P1xuICByb290Q2x6LmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB6clV0aWwuZWFjaChtYW5kYXRvcnlNZXRob2RzLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIGlmICghcHJvdG9bbWV0aG9kXSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignTWV0aG9kIGAnICsgbWV0aG9kICsgJ2Agc2hvdWxkIGJlIGltcGxlbWVudGVkJyArIChwcm90by50eXBlID8gJyBpbiAnICsgcHJvdG8udHlwZSA6ICcnKSArICcuJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgc3VwZXJDbGFzcyA9IHRoaXM7XG4gICAgdmFyIEV4dGVuZGVkQ2xhc3M7XG4gICAgaWYgKGlzRVNDbGFzcyhzdXBlckNsYXNzKSkge1xuICAgICAgRXh0ZW5kZWRDbGFzcyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgICAgfShzdXBlckNsYXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdCwgd2UgYm90aCBzdXBwb3J0IHRzIGNsYXNzIGluaGVyaXRhbmNlIGFuZCB0aGlzXG4gICAgICAvLyBcImV4dGVuZFwiIGFwcHJvYWNoLlxuICAgICAgLy8gVGhlIGNvbnN0cnVjdG9yIHNob3VsZCBrZWVwIHRoZSBzYW1lIGJlaGF2aW9yIGFzIHRzIGNsYXNzIGluaGVyaXRhbmNlOlxuICAgICAgLy8gSWYgdGhpcyBjb25zdHJ1Y3Rvci8kY29uc3RydWN0b3IgaXMgbm90IGRlY2xhcmVkLCBhdXRvIGludm9rZSB0aGUgc3VwZXJcbiAgICAgIC8vIGNvbnN0cnVjdG9yLlxuICAgICAgLy8gSWYgdGhpcyBjb25zdHJ1Y3Rvci8kY29uc3RydWN0b3IgaXMgZGVjbGFyZWQsIGl0IGlzIHJlc3BvbnNpYmxlIGZvclxuICAgICAgLy8gY2FsbGluZyB0aGUgc3VwZXIgY29uc3RydWN0b3IuXG4gICAgICBFeHRlbmRlZENsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAocHJvdG8uJGNvbnN0cnVjdG9yIHx8IHN1cGVyQ2xhc3MpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgenJVdGlsLmluaGVyaXRzKEV4dGVuZGVkQ2xhc3MsIHRoaXMpO1xuICAgIH1cbiAgICB6clV0aWwuZXh0ZW5kKEV4dGVuZGVkQ2xhc3MucHJvdG90eXBlLCBwcm90byk7XG4gICAgRXh0ZW5kZWRDbGFzc1tJU19FWFRFTkRFRF9DTEFTU10gPSB0cnVlO1xuICAgIEV4dGVuZGVkQ2xhc3MuZXh0ZW5kID0gdGhpcy5leHRlbmQ7XG4gICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNhbGwgPSBzdXBlckNhbGw7XG4gICAgRXh0ZW5kZWRDbGFzcy5zdXBlckFwcGx5ID0gc3VwZXJBcHBseTtcbiAgICBFeHRlbmRlZENsYXNzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xuICAgIHJldHVybiBFeHRlbmRlZENsYXNzO1xuICB9O1xufVxuZnVuY3Rpb24gaXNFU0NsYXNzKGZuKSB7XG4gIHJldHVybiB6clV0aWwuaXNGdW5jdGlvbihmbikgJiYgL15jbGFzc1xccy8udGVzdChGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmbikpO1xufVxuLyoqXHJcbiAqIEEgd29yayBhcm91bmQgdG8gYm90aCBzdXBwb3J0IHRzIGV4dGVuZCBhbmQgdGhpcyBleHRlbmQgbWVjaGFuaXNtLlxyXG4gKiBvbiBzdWItY2xhc3MuXHJcbiAqIEB1c2FnZVxyXG4gKiBgYGB0c1xyXG4gKiBjbGFzcyBDb21wb25lbnQgeyAuLi4gfVxyXG4gKiBjbGFzc1V0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoQ29tcG9uZW50KTtcclxuICogY2xhc3NVdGlsLmVuYWJsZUNsYXNzTWFuYWdlbWVudChDb21wb25lbnQsIHtyZWdpc3RlcldoZW5FeHRlbmQ6IHRydWV9KTtcclxuICpcclxuICogY2xhc3MgU2VyaWVzIGV4dGVuZHMgQ29tcG9uZW50IHsgLi4uIH1cclxuICogLy8gV2l0aG91dCBjYWxsaW5nIGBtYXJrRXh0ZW5kYCwgYHJlZ2lzdGVyV2hlbkV4dGVuZGAgd2lsbCBub3Qgd29yay5cclxuICogQ29tcG9uZW50Lm1hcmtFeHRlbmQoU2VyaWVzKTtcclxuICogYGBgXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdW50RXh0ZW5kKFN1YkNseiwgU3VwcGVyQ2x6KSB7XG4gIFN1YkNsei5leHRlbmQgPSBTdXBwZXJDbHouZXh0ZW5kO1xufVxuLy8gQSByYW5kb20gb2Zmc2V0LlxudmFyIGNsYXNzQmFzZSA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwKTtcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGBDaGVja2FibGVDb25zdHJ1Y3RvcmAgZm9yIGB0YXJnZXRgLlxyXG4gKiBDYW4gbm90IHVzZSBpbnN0YW5jZW9mLCBjb25zaWRlciBkaWZmZXJlbnQgc2NvcGUgYnlcclxuICogY3Jvc3MgZG9tYWluIG9yIGVzIG1vZHVsZSBpbXBvcnQgaW4gZWMgZXh0ZW5zaW9ucy5cclxuICogTW91bnQgYSBtZXRob2QgXCJpc0luc3RhbmNlKClcIiB0byBDbHouXHJcbiAqXHJcbiAqIEB1c2FnZVxyXG4gKiBgYGB0c1xyXG4gKiBjbGFzcyBYeHgge31cclxuICogdHlwZSBYeHhDb25zdHJ1Y3RvciA9IHR5cGVvZiBYeHggJiBDaGVja2FibGVDb25zdHJ1Y3RvcjtcclxuICogZW5hYmxlQ2xhc3NDaGVjayhYeHggYXMgWHh4Q29uc3RydWN0b3IpXHJcbiAqIGBgYFxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVDbGFzc0NoZWNrKHRhcmdldCkge1xuICB2YXIgY2xhc3NBdHRyID0gWydfX1xcMGlzX2NseicsIGNsYXNzQmFzZSsrXS5qb2luKCdfJyk7XG4gIHRhcmdldC5wcm90b3R5cGVbY2xhc3NBdHRyXSA9IHRydWU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgenJVdGlsLmFzc2VydCghdGFyZ2V0LmlzSW5zdGFuY2UsICdUaGUgbWV0aG9kIFwiaXNcIiBjYW4gbm90IGJlIGRlZmluZWQuJyk7XG4gIH1cbiAgdGFyZ2V0LmlzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmpbY2xhc3NBdHRyXSk7XG4gIH07XG59XG4vLyBzdXBlckNhbGwgc2hvdWxkIGhhdmUgY2xhc3MgaW5mbywgd2hpY2ggY2FuIG5vdCBiZSBmZXRjaGVkIGZyb20gJ3RoaXMnLlxuLy8gQ29uc2lkZXIgdGhpcyBjYXNlOlxuLy8gY2xhc3MgQSBoYXMgbWV0aG9kIGYsXG4vLyBjbGFzcyBCIGluaGVyaXRzIGNsYXNzIEEsIG92ZXJyaWRlcyBtZXRob2QgZiwgZiBjYWxsIHN1cGVyQXBwbHkoJ2YnKSxcbi8vIGNsYXNzIEMgaW5oZXJpdHMgY2xhc3MgQiwgZG9lcyBub3Qgb3ZlcnJpZGUgbWV0aG9kIGYsXG4vLyB0aGVuIHdoZW4gbWV0aG9kIG9mIGNsYXNzIEMgaXMgY2FsbGVkLCBkZWFkIGxvb3Agb2NjdXJyZWQuXG5mdW5jdGlvbiBzdXBlckNhbGwoY29udGV4dCwgbWV0aG9kTmFtZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cbiAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XG59XG5mdW5jdGlvbiBzdXBlckFwcGx5KGNvbnRleHQsIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XG59XG4vKipcclxuICogSW1wbGVtZW50cyBgQ2xhc3NNYW5hZ2VyYCBmb3IgYHRhcmdldGBcclxuICpcclxuICogQHVzYWdlXHJcbiAqIGBgYHRzXHJcbiAqIGNsYXNzIFh4eCB7fVxyXG4gKiB0eXBlIFh4eENvbnN0cnVjdG9yID0gdHlwZW9mIFh4eCAmIENsYXNzTWFuYWdlclxyXG4gKiBlbmFibGVDbGFzc01hbmFnZW1lbnQoWHh4IGFzIFh4eENvbnN0cnVjdG9yKTtcclxuICogYGBgXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUNsYXNzTWFuYWdlbWVudCh0YXJnZXQpIHtcbiAgLyoqXHJcbiAgICogQ29tcG9uZW50IG1vZGVsIGNsYXNzZXNcclxuICAgKiBrZXk6IGNvbXBvbmVudFR5cGUsXHJcbiAgICogdmFsdWU6XHJcbiAgICogICAgIGNvbXBvbmVudENsYXNzLCB3aGVuIGNvbXBvbmVudFR5cGUgaXMgJ2EnXHJcbiAgICogICAgIG9yIE9iamVjdC48c3ViS2V5LCBjb21wb25lbnRDbGFzcz4sIHdoZW4gY29tcG9uZW50VHlwZSBpcyAnYS5iJ1xyXG4gICAqL1xuICB2YXIgc3RvcmFnZSA9IHt9O1xuICB0YXJnZXQucmVnaXN0ZXJDbGFzcyA9IGZ1bmN0aW9uIChjbHopIHtcbiAgICAvLyBgdHlwZWAgc2hvdWxkIG5vdCBiZSBhIFwiaW5zdGFuY2UgbWVtYmVyXCIuXG4gICAgLy8gSWYgdXNpbmcgVFMgY2xhc3MsIHNob3VsZCBiZXR0ZXIgZGVjbGFyZWQgYXMgYHN0YXRpYyB0eXBlID0gJ3Nlcmllcy5waWUnYC5cbiAgICAvLyBvdGhlcndpc2UgdXNlcnMgaGF2ZSB0byBtb3VudCBgdHlwZWAgb24gcHJvdG90eXBlIG1hbnVhbGx5LlxuICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXQgYW5kIGVuYWJsZSBpbnN0YW5jZSB2aXNpdCB0eXBlIHZpYSBgdGhpcy50eXBlYCxcbiAgICAvLyB3ZSBzdGlsbCBzdXBwb3J0IGZldGNoIGB0eXBlYCBmcm9tIHByb3RvdHlwZS5cbiAgICB2YXIgY29tcG9uZW50RnVsbFR5cGUgPSBjbHoudHlwZSB8fCBjbHoucHJvdG90eXBlLnR5cGU7XG4gICAgaWYgKGNvbXBvbmVudEZ1bGxUeXBlKSB7XG4gICAgICBjaGVja0NsYXNzVHlwZShjb21wb25lbnRGdWxsVHlwZSk7XG4gICAgICAvLyBJZiBvbmx5IHN0YXRpYyB0eXBlIGRlY2xhcmVkLCB3ZSBhc3NpZ24gaXQgdG8gcHJvdG90eXBlIG1hbmRhdG9yaWx5LlxuICAgICAgY2x6LnByb3RvdHlwZS50eXBlID0gY29tcG9uZW50RnVsbFR5cGU7XG4gICAgICB2YXIgY29tcG9uZW50VHlwZUluZm8gPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRGdWxsVHlwZSk7XG4gICAgICBpZiAoIWNvbXBvbmVudFR5cGVJbmZvLnN1Yikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChzdG9yYWdlW2NvbXBvbmVudFR5cGVJbmZvLm1haW5dKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oY29tcG9uZW50VHlwZUluZm8ubWFpbiArICcgZXhpc3RzLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlW2NvbXBvbmVudFR5cGVJbmZvLm1haW5dID0gY2x6O1xuICAgICAgfSBlbHNlIGlmIChjb21wb25lbnRUeXBlSW5mby5zdWIgIT09IElTX0NPTlRBSU5FUikge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbWFrZUNvbnRhaW5lcihjb21wb25lbnRUeXBlSW5mbyk7XG4gICAgICAgIGNvbnRhaW5lcltjb21wb25lbnRUeXBlSW5mby5zdWJdID0gY2x6O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2x6O1xuICB9O1xuICB0YXJnZXQuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAobWFpblR5cGUsIHN1YlR5cGUsIHRocm93V2hlbk5vdEZvdW5kKSB7XG4gICAgdmFyIGNseiA9IHN0b3JhZ2VbbWFpblR5cGVdO1xuICAgIGlmIChjbHogJiYgY2x6W0lTX0NPTlRBSU5FUl0pIHtcbiAgICAgIGNseiA9IHN1YlR5cGUgPyBjbHpbc3ViVHlwZV0gOiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhyb3dXaGVuTm90Rm91bmQgJiYgIWNseikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCFzdWJUeXBlID8gbWFpblR5cGUgKyAnLicgKyAndHlwZSBzaG91bGQgYmUgc3BlY2lmaWVkLicgOiAnQ29tcG9uZW50ICcgKyBtYWluVHlwZSArICcuJyArIChzdWJUeXBlIHx8ICcnKSArICcgaXMgdXNlZCBidXQgbm90IGltcG9ydGVkLicpO1xuICAgIH1cbiAgICByZXR1cm4gY2x6O1xuICB9O1xuICB0YXJnZXQuZ2V0Q2xhc3Nlc0J5TWFpblR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgIHZhciBjb21wb25lbnRUeXBlSW5mbyA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlSW5mby5tYWluXTtcbiAgICBpZiAob2JqICYmIG9ialtJU19DT05UQUlORVJdKSB7XG4gICAgICB6clV0aWwuZWFjaChvYmosIGZ1bmN0aW9uIChvLCB0eXBlKSB7XG4gICAgICAgIHR5cGUgIT09IElTX0NPTlRBSU5FUiAmJiByZXN1bHQucHVzaChvKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICB0YXJnZXQuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgIC8vIEp1c3QgY29uc2lkZXIgY29tcG9uZW50VHlwZS5tYWluLlxuICAgIHZhciBjb21wb25lbnRUeXBlSW5mbyA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgIHJldHVybiAhIXN0b3JhZ2VbY29tcG9uZW50VHlwZUluZm8ubWFpbl07XG4gIH07XG4gIC8qKlxyXG4gICAqIEByZXR1cm4gTGlrZSBbJ2FhJywgJ2JiJ10sIGJ1dCBjYW4gbm90IGJlIFsnYWEueHgnXVxyXG4gICAqL1xuICB0YXJnZXQuZ2V0QWxsQ2xhc3NNYWluVHlwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGVzID0gW107XG4gICAgenJVdGlsLmVhY2goc3RvcmFnZSwgZnVuY3Rpb24gKG9iaiwgdHlwZSkge1xuICAgICAgdHlwZXMucHVzaCh0eXBlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHlwZXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIElmIGEgbWFpbiB0eXBlIGlzIGNvbnRhaW5lciBhbmQgaGFzIHN1YiB0eXBlc1xyXG4gICAqL1xuICB0YXJnZXQuaGFzU3ViVHlwZXMgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgIHZhciBjb21wb25lbnRUeXBlSW5mbyA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgIHZhciBvYmogPSBzdG9yYWdlW2NvbXBvbmVudFR5cGVJbmZvLm1haW5dO1xuICAgIHJldHVybiBvYmogJiYgb2JqW0lTX0NPTlRBSU5FUl07XG4gIH07XG4gIGZ1bmN0aW9uIG1ha2VDb250YWluZXIoY29tcG9uZW50VHlwZUluZm8pIHtcbiAgICB2YXIgY29udGFpbmVyID0gc3RvcmFnZVtjb21wb25lbnRUeXBlSW5mby5tYWluXTtcbiAgICBpZiAoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyW0lTX0NPTlRBSU5FUl0pIHtcbiAgICAgIGNvbnRhaW5lciA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZUluZm8ubWFpbl0gPSB7fTtcbiAgICAgIGNvbnRhaW5lcltJU19DT05UQUlORVJdID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxufVxuLy8gLyoqXG4vLyAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gcHJvcGVydGllc1xuLy8gICovXG4vLyBleHBvcnQgZnVuY3Rpb24gc2V0UmVhZE9ubHkob2JqLCBwcm9wZXJ0aWVzKSB7XG4vLyBGSVhNRSBJdCBzZWVtcyBicm9rZW4gaW4gSUU4IHNpbXVsYXRpb24gb2YgSUUxMVxuLy8gaWYgKCF6clV0aWwuaXNBcnJheShwcm9wZXJ0aWVzKSkge1xuLy8gICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzICE9IG51bGwgPyBbcHJvcGVydGllc10gOiBbXTtcbi8vIH1cbi8vIHpyVXRpbC5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uIChwcm9wKSB7XG4vLyAgICAgbGV0IHZhbHVlID0gb2JqW3Byb3BdO1xuLy8gICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuLy8gICAgICAgICAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4vLyAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsIHdyaXRhYmxlOiBmYWxzZVxuLy8gICAgICAgICB9KTtcbi8vICAgICB6clV0aWwuaXNBcnJheShvYmpbcHJvcF0pXG4vLyAgICAgICAgICYmIE9iamVjdC5mcmVlemVcbi8vICAgICAgICAgJiYgT2JqZWN0LmZyZWV6ZShvYmpbcHJvcF0pO1xuLy8gfSk7XG4vLyB9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30693\n")},34253:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HU: () => (/* binding */ getAvailableSize),\n/* harmony export */   Ir: () => (/* binding */ copyLayoutParams),\n/* harmony export */   Qf: () => (/* binding */ sizeCalculable),\n/* harmony export */   Tj: () => (/* binding */ LOCATION_PARAMS),\n/* harmony export */   YA: () => (/* binding */ mergeLayoutParam),\n/* harmony export */   aP: () => (/* binding */ box),\n/* harmony export */   ad: () => (/* binding */ fetchLayoutMode),\n/* harmony export */   dV: () => (/* binding */ getLayoutRect),\n/* harmony export */   m$: () => (/* binding */ positionElement),\n/* harmony export */   vs: () => (/* binding */ getLayoutParams)\n/* harmony export */ });\n/* unused harmony exports HV_NAMES, vbox, hbox */\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29308);\n/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24326);\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83412);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// Layout helpers for each component positioning\n\n\n\n\nvar each = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each;\n/**\r\n * @public\r\n */\nvar LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n/**\r\n * @public\r\n */\nvar HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];\nfunction boxLayout(orient, group, gap, maxWidth, maxHeight) {\n  var x = 0;\n  var y = 0;\n  if (maxWidth == null) {\n    maxWidth = Infinity;\n  }\n  if (maxHeight == null) {\n    maxHeight = Infinity;\n  }\n  var currentLineMaxSize = 0;\n  group.eachChild(function (child, idx) {\n    var rect = child.getBoundingRect();\n    var nextChild = group.childAt(idx + 1);\n    var nextChildRect = nextChild && nextChild.getBoundingRect();\n    var nextX;\n    var nextY;\n    if (orient === 'horizontal') {\n      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n      nextX = x + moveX;\n      // Wrap when width exceeds maxWidth or meet a `newline` group\n      // FIXME compare before adding gap?\n      if (nextX > maxWidth || child.newline) {\n        x = 0;\n        nextX = moveX;\n        y += currentLineMaxSize + gap;\n        currentLineMaxSize = rect.height;\n      } else {\n        // FIXME: consider rect.y is not `0`?\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n      }\n    } else {\n      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n      nextY = y + moveY;\n      // Wrap when width exceeds maxHeight or meet a `newline` group\n      if (nextY > maxHeight || child.newline) {\n        x += currentLineMaxSize + gap;\n        y = 0;\n        nextY = moveY;\n        currentLineMaxSize = rect.width;\n      } else {\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n      }\n    }\n    if (child.newline) {\n      return;\n    }\n    child.x = x;\n    child.y = y;\n    child.markRedraw();\n    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n  });\n}\n/**\r\n * VBox or HBox layouting\r\n * @param {string} orient\r\n * @param {module:zrender/graphic/Group} group\r\n * @param {number} gap\r\n * @param {number} [width=Infinity]\r\n * @param {number} [height=Infinity]\r\n */\nvar box = boxLayout;\n/**\r\n * VBox layouting\r\n * @param {module:zrender/graphic/Group} group\r\n * @param {number} gap\r\n * @param {number} [width=Infinity]\r\n * @param {number} [height=Infinity]\r\n */\nvar vbox = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.curry(boxLayout, 'vertical');\n/**\r\n * HBox layouting\r\n * @param {module:zrender/graphic/Group} group\r\n * @param {number} gap\r\n * @param {number} [width=Infinity]\r\n * @param {number} [height=Infinity]\r\n */\nvar hbox = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.curry(boxLayout, 'horizontal');\n/**\r\n * If x or x2 is not specified or 'center' 'left' 'right',\r\n * the width would be as long as possible.\r\n * If y or y2 is not specified or 'middle' 'top' 'bottom',\r\n * the height would be as long as possible.\r\n */\nfunction getAvailableSize(positionInfo, containerRect, margin) {\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var x = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(positionInfo.left, containerWidth);\n  var y = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(positionInfo.top, containerHeight);\n  var x2 = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(positionInfo.right, containerWidth);\n  var y2 = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(positionInfo.bottom, containerHeight);\n  (isNaN(x) || isNaN(parseFloat(positionInfo.left))) && (x = 0);\n  (isNaN(x2) || isNaN(parseFloat(positionInfo.right))) && (x2 = containerWidth);\n  (isNaN(y) || isNaN(parseFloat(positionInfo.top))) && (y = 0);\n  (isNaN(y2) || isNaN(parseFloat(positionInfo.bottom))) && (y2 = containerHeight);\n  margin = _format_js__WEBPACK_IMPORTED_MODULE_2__/* .normalizeCssArray */ .QX(margin || 0);\n  return {\n    width: Math.max(x2 - x - margin[1] - margin[3], 0),\n    height: Math.max(y2 - y - margin[0] - margin[2], 0)\n  };\n}\n/**\r\n * Parse position info.\r\n */\nfunction getLayoutRect(positionInfo, containerRect, margin) {\n  margin = _format_js__WEBPACK_IMPORTED_MODULE_2__/* .normalizeCssArray */ .QX(margin || 0);\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var left = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(positionInfo.left, containerWidth);\n  var top = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(positionInfo.top, containerHeight);\n  var right = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(positionInfo.right, containerWidth);\n  var bottom = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(positionInfo.bottom, containerHeight);\n  var width = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(positionInfo.width, containerWidth);\n  var height = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(positionInfo.height, containerHeight);\n  var verticalMargin = margin[2] + margin[0];\n  var horizontalMargin = margin[1] + margin[3];\n  var aspect = positionInfo.aspect;\n  // If width is not specified, calculate width from left and right\n  if (isNaN(width)) {\n    width = containerWidth - right - horizontalMargin - left;\n  }\n  if (isNaN(height)) {\n    height = containerHeight - bottom - verticalMargin - top;\n  }\n  if (aspect != null) {\n    // If width and height are not given\n    // 1. Graph should not exceeds the container\n    // 2. Aspect must be keeped\n    // 3. Graph should take the space as more as possible\n    // FIXME\n    // Margin is not considered, because there is no case that both\n    // using margin and aspect so far.\n    if (isNaN(width) && isNaN(height)) {\n      if (aspect > containerWidth / containerHeight) {\n        width = containerWidth * 0.8;\n      } else {\n        height = containerHeight * 0.8;\n      }\n    }\n    // Calculate width or height with given aspect\n    if (isNaN(width)) {\n      width = aspect * height;\n    }\n    if (isNaN(height)) {\n      height = width / aspect;\n    }\n  }\n  // If left is not specified, calculate left from right and width\n  if (isNaN(left)) {\n    left = containerWidth - right - width - horizontalMargin;\n  }\n  if (isNaN(top)) {\n    top = containerHeight - bottom - height - verticalMargin;\n  }\n  // Align left and top\n  switch (positionInfo.left || positionInfo.right) {\n    case 'center':\n      left = containerWidth / 2 - width / 2 - margin[3];\n      break;\n    case 'right':\n      left = containerWidth - width - horizontalMargin;\n      break;\n  }\n  switch (positionInfo.top || positionInfo.bottom) {\n    case 'middle':\n    case 'center':\n      top = containerHeight / 2 - height / 2 - margin[0];\n      break;\n    case 'bottom':\n      top = containerHeight - height - verticalMargin;\n      break;\n  }\n  // If something is wrong and left, top, width, height are calculated as NaN\n  left = left || 0;\n  top = top || 0;\n  if (isNaN(width)) {\n    // Width may be NaN if only one value is given except width\n    width = containerWidth - horizontalMargin - left - (right || 0);\n  }\n  if (isNaN(height)) {\n    // Height may be NaN if only one value is given except height\n    height = containerHeight - verticalMargin - top - (bottom || 0);\n  }\n  var rect = new zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A(left + margin[3], top + margin[0], width, height);\n  rect.margin = margin;\n  return rect;\n}\n/**\r\n * Position a zr element in viewport\r\n *  Group position is specified by either\r\n *  {left, top}, {right, bottom}\r\n *  If all properties exists, right and bottom will be igonred.\r\n *\r\n * Logic:\r\n *     1. Scale (against origin point in parent coord)\r\n *     2. Rotate (against origin point in parent coord)\r\n *     3. Translate (with el.position by this method)\r\n * So this method only fixes the last step 'Translate', which does not affect\r\n * scaling and rotating.\r\n *\r\n * If be called repeatedly with the same input el, the same result will be gotten.\r\n *\r\n * Return true if the layout happened.\r\n *\r\n * @param el Should have `getBoundingRect` method.\r\n * @param positionInfo\r\n * @param positionInfo.left\r\n * @param positionInfo.top\r\n * @param positionInfo.right\r\n * @param positionInfo.bottom\r\n * @param positionInfo.width Only for opt.boundingModel: 'raw'\r\n * @param positionInfo.height Only for opt.boundingModel: 'raw'\r\n * @param containerRect\r\n * @param margin\r\n * @param opt\r\n * @param opt.hv Only horizontal or only vertical. Default to be [1, 1]\r\n * @param opt.boundingMode\r\n *        Specify how to calculate boundingRect when locating.\r\n *        'all': Position the boundingRect that is transformed and uioned\r\n *               both itself and its descendants.\r\n *               This mode simplies confine the elements in the bounding\r\n *               of their container (e.g., using 'right: 0').\r\n *        'raw': Position the boundingRect that is not transformed and only itself.\r\n *               This mode is useful when you want a element can overflow its\r\n *               container. (Consider a rotated circle needs to be located in a corner.)\r\n *               In this mode positionInfo.width/height can only be number.\r\n */\nfunction positionElement(el, positionInfo, containerRect, margin, opt, out) {\n  var h = !opt || !opt.hv || opt.hv[0];\n  var v = !opt || !opt.hv || opt.hv[1];\n  var boundingMode = opt && opt.boundingMode || 'all';\n  out = out || el;\n  out.x = el.x;\n  out.y = el.y;\n  if (!h && !v) {\n    return false;\n  }\n  var rect;\n  if (boundingMode === 'raw') {\n    rect = el.type === 'group' ? new zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();\n  } else {\n    rect = el.getBoundingRect();\n    if (el.needLocalTransform()) {\n      var transform = el.getLocalTransform();\n      // Notice: raw rect may be inner object of el,\n      // which should not be modified.\n      rect = rect.clone();\n      rect.applyTransform(transform);\n    }\n  }\n  // The real width and height can not be specified but calculated by the given el.\n  var layoutRect = getLayoutRect(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.defaults({\n    width: rect.width,\n    height: rect.height\n  }, positionInfo), containerRect, margin);\n  // Because 'tranlate' is the last step in transform\n  // (see zrender/core/Transformable#getLocalTransform),\n  // we can just only modify el.position to get final result.\n  var dx = h ? layoutRect.x - rect.x : 0;\n  var dy = v ? layoutRect.y - rect.y : 0;\n  if (boundingMode === 'raw') {\n    out.x = dx;\n    out.y = dy;\n  } else {\n    out.x += dx;\n    out.y += dy;\n  }\n  if (out === el) {\n    el.markRedraw();\n  }\n  return true;\n}\n/**\r\n * @param option Contains some of the properties in HV_NAMES.\r\n * @param hvIdx 0: horizontal; 1: vertical.\r\n */\nfunction sizeCalculable(option, hvIdx) {\n  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;\n}\nfunction fetchLayoutMode(ins) {\n  var layoutMode = ins.layoutMode || ins.constructor.layoutMode;\n  return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject(layoutMode) ? layoutMode : layoutMode ? {\n    type: layoutMode\n  } : null;\n}\n/**\r\n * Consider Case:\r\n * When default option has {left: 0, width: 100}, and we set {right: 0}\r\n * through setOption or media query, using normal zrUtil.merge will cause\r\n * {right: 0} does not take effect.\r\n *\r\n * @example\r\n * ComponentModel.extend({\r\n *     init: function () {\r\n *         ...\r\n *         let inputPositionParams = layout.getLayoutParams(option);\r\n *         this.mergeOption(inputPositionParams);\r\n *     },\r\n *     mergeOption: function (newOption) {\r\n *         newOption && zrUtil.merge(thisOption, newOption, true);\r\n *         layout.mergeLayoutParam(thisOption, newOption);\r\n *     }\r\n * });\r\n *\r\n * @param targetOption\r\n * @param newOption\r\n * @param opt\r\n */\nfunction mergeLayoutParam(targetOption, newOption, opt) {\n  var ignoreSize = opt && opt.ignoreSize;\n  !zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n  var hResult = merge(HV_NAMES[0], 0);\n  var vResult = merge(HV_NAMES[1], 1);\n  copy(HV_NAMES[0], targetOption, hResult);\n  copy(HV_NAMES[1], targetOption, vResult);\n  function merge(names, hvIdx) {\n    var newParams = {};\n    var newValueCount = 0;\n    var merged = {};\n    var mergedValueCount = 0;\n    var enoughParamNumber = 2;\n    each(names, function (name) {\n      merged[name] = targetOption[name];\n    });\n    each(names, function (name) {\n      // Consider case: newOption.width is null, which is\n      // set by user for removing width setting.\n      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n      hasValue(newParams, name) && newValueCount++;\n      hasValue(merged, name) && mergedValueCount++;\n    });\n    if (ignoreSize[hvIdx]) {\n      // Only one of left/right is premitted to exist.\n      if (hasValue(newOption, names[1])) {\n        merged[names[2]] = null;\n      } else if (hasValue(newOption, names[2])) {\n        merged[names[1]] = null;\n      }\n      return merged;\n    }\n    // Case: newOption: {width: ..., right: ...},\n    // or targetOption: {right: ...} and newOption: {width: ...},\n    // There is no conflict when merged only has params count\n    // little than enoughParamNumber.\n    if (mergedValueCount === enoughParamNumber || !newValueCount) {\n      return merged;\n    }\n    // Case: newOption: {width: ..., right: ...},\n    // Than we can make sure user only want those two, and ignore\n    // all origin params in targetOption.\n    else if (newValueCount >= enoughParamNumber) {\n      return newParams;\n    } else {\n      // Chose another param from targetOption by priority.\n      for (var i = 0; i < names.length; i++) {\n        var name_1 = names[i];\n        if (!hasProp(newParams, name_1) && hasProp(targetOption, name_1)) {\n          newParams[name_1] = targetOption[name_1];\n          break;\n        }\n      }\n      return newParams;\n    }\n  }\n  function hasProp(obj, name) {\n    return obj.hasOwnProperty(name);\n  }\n  function hasValue(obj, name) {\n    return obj[name] != null && obj[name] !== 'auto';\n  }\n  function copy(names, target, source) {\n    each(names, function (name) {\n      target[name] = source[name];\n    });\n  }\n}\n/**\r\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\r\n */\nfunction getLayoutParams(source) {\n  return copyLayoutParams({}, source);\n}\n/**\r\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\r\n * @param {Object} source\r\n * @return {Object} Result contains those props.\r\n */\nfunction copyLayoutParams(target, source) {\n  source && target && each(LOCATION_PARAMS, function (name) {\n    source.hasOwnProperty(name) && (target[name] = source[name]);\n  });\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQyNTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvbGF5b3V0LmpzPzNkYWEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG4vLyBMYXlvdXQgaGVscGVycyBmb3IgZWFjaCBjb21wb25lbnQgcG9zaXRpb25pbmdcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IEJvdW5kaW5nUmVjdCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcyc7XG5pbXBvcnQgeyBwYXJzZVBlcmNlbnQgfSBmcm9tICcuL251bWJlci5qcyc7XG5pbXBvcnQgKiBhcyBmb3JtYXRVdGlsIGZyb20gJy4vZm9ybWF0LmpzJztcbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG4vKipcclxuICogQHB1YmxpY1xyXG4gKi9cbmV4cG9ydCB2YXIgTE9DQVRJT05fUEFSQU1TID0gWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nLCAnd2lkdGgnLCAnaGVpZ2h0J107XG4vKipcclxuICogQHB1YmxpY1xyXG4gKi9cbmV4cG9ydCB2YXIgSFZfTkFNRVMgPSBbWyd3aWR0aCcsICdsZWZ0JywgJ3JpZ2h0J10sIFsnaGVpZ2h0JywgJ3RvcCcsICdib3R0b20nXV07XG5mdW5jdGlvbiBib3hMYXlvdXQob3JpZW50LCBncm91cCwgZ2FwLCBtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwO1xuICBpZiAobWF4V2lkdGggPT0gbnVsbCkge1xuICAgIG1heFdpZHRoID0gSW5maW5pdHk7XG4gIH1cbiAgaWYgKG1heEhlaWdodCA9PSBudWxsKSB7XG4gICAgbWF4SGVpZ2h0ID0gSW5maW5pdHk7XG4gIH1cbiAgdmFyIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IDA7XG4gIGdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQsIGlkeCkge1xuICAgIHZhciByZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIG5leHRDaGlsZCA9IGdyb3VwLmNoaWxkQXQoaWR4ICsgMSk7XG4gICAgdmFyIG5leHRDaGlsZFJlY3QgPSBuZXh0Q2hpbGQgJiYgbmV4dENoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBuZXh0WDtcbiAgICB2YXIgbmV4dFk7XG4gICAgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICB2YXIgbW92ZVggPSByZWN0LndpZHRoICsgKG5leHRDaGlsZFJlY3QgPyAtbmV4dENoaWxkUmVjdC54ICsgcmVjdC54IDogMCk7XG4gICAgICBuZXh0WCA9IHggKyBtb3ZlWDtcbiAgICAgIC8vIFdyYXAgd2hlbiB3aWR0aCBleGNlZWRzIG1heFdpZHRoIG9yIG1lZXQgYSBgbmV3bGluZWAgZ3JvdXBcbiAgICAgIC8vIEZJWE1FIGNvbXBhcmUgYmVmb3JlIGFkZGluZyBnYXA/XG4gICAgICBpZiAobmV4dFggPiBtYXhXaWR0aCB8fCBjaGlsZC5uZXdsaW5lKSB7XG4gICAgICAgIHggPSAwO1xuICAgICAgICBuZXh0WCA9IG1vdmVYO1xuICAgICAgICB5ICs9IGN1cnJlbnRMaW5lTWF4U2l6ZSArIGdhcDtcbiAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gcmVjdC5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGSVhNRTogY29uc2lkZXIgcmVjdC55IGlzIG5vdCBgMGA/XG4gICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRMaW5lTWF4U2l6ZSwgcmVjdC5oZWlnaHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW92ZVkgPSByZWN0LmhlaWdodCArIChuZXh0Q2hpbGRSZWN0ID8gLW5leHRDaGlsZFJlY3QueSArIHJlY3QueSA6IDApO1xuICAgICAgbmV4dFkgPSB5ICsgbW92ZVk7XG4gICAgICAvLyBXcmFwIHdoZW4gd2lkdGggZXhjZWVkcyBtYXhIZWlnaHQgb3IgbWVldCBhIGBuZXdsaW5lYCBncm91cFxuICAgICAgaWYgKG5leHRZID4gbWF4SGVpZ2h0IHx8IGNoaWxkLm5ld2xpbmUpIHtcbiAgICAgICAgeCArPSBjdXJyZW50TGluZU1heFNpemUgKyBnYXA7XG4gICAgICAgIHkgPSAwO1xuICAgICAgICBuZXh0WSA9IG1vdmVZO1xuICAgICAgICBjdXJyZW50TGluZU1heFNpemUgPSByZWN0LndpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gTWF0aC5tYXgoY3VycmVudExpbmVNYXhTaXplLCByZWN0LndpZHRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoaWxkLm5ld2xpbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2hpbGQueCA9IHg7XG4gICAgY2hpbGQueSA9IHk7XG4gICAgY2hpbGQubWFya1JlZHJhdygpO1xuICAgIG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8geCA9IG5leHRYICsgZ2FwIDogeSA9IG5leHRZICsgZ2FwO1xuICB9KTtcbn1cbi8qKlxyXG4gKiBWQm94IG9yIEhCb3ggbGF5b3V0aW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcmllbnRcclxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwfSBncm91cFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZ2FwXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9SW5maW5pdHldXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PUluZmluaXR5XVxyXG4gKi9cbmV4cG9ydCB2YXIgYm94ID0gYm94TGF5b3V0O1xuLyoqXHJcbiAqIFZCb3ggbGF5b3V0aW5nXHJcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9Hcm91cH0gZ3JvdXBcclxuICogQHBhcmFtIHtudW1iZXJ9IGdhcFxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPUluZmluaXR5XVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD1JbmZpbml0eV1cclxuICovXG5leHBvcnQgdmFyIHZib3ggPSB6clV0aWwuY3VycnkoYm94TGF5b3V0LCAndmVydGljYWwnKTtcbi8qKlxyXG4gKiBIQm94IGxheW91dGluZ1xyXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXB9IGdyb3VwXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBnYXBcclxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9SW5maW5pdHldXHJcbiAqL1xuZXhwb3J0IHZhciBoYm94ID0genJVdGlsLmN1cnJ5KGJveExheW91dCwgJ2hvcml6b250YWwnKTtcbi8qKlxyXG4gKiBJZiB4IG9yIHgyIGlzIG5vdCBzcGVjaWZpZWQgb3IgJ2NlbnRlcicgJ2xlZnQnICdyaWdodCcsXHJcbiAqIHRoZSB3aWR0aCB3b3VsZCBiZSBhcyBsb25nIGFzIHBvc3NpYmxlLlxyXG4gKiBJZiB5IG9yIHkyIGlzIG5vdCBzcGVjaWZpZWQgb3IgJ21pZGRsZScgJ3RvcCcgJ2JvdHRvbScsXHJcbiAqIHRoZSBoZWlnaHQgd291bGQgYmUgYXMgbG9uZyBhcyBwb3NzaWJsZS5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXZhaWxhYmxlU2l6ZShwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbikge1xuICB2YXIgY29udGFpbmVyV2lkdGggPSBjb250YWluZXJSZWN0LndpZHRoO1xuICB2YXIgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyUmVjdC5oZWlnaHQ7XG4gIHZhciB4ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby5sZWZ0LCBjb250YWluZXJXaWR0aCk7XG4gIHZhciB5ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby50b3AsIGNvbnRhaW5lckhlaWdodCk7XG4gIHZhciB4MiA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ucmlnaHQsIGNvbnRhaW5lcldpZHRoKTtcbiAgdmFyIHkyID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby5ib3R0b20sIGNvbnRhaW5lckhlaWdodCk7XG4gIChpc05hTih4KSB8fCBpc05hTihwYXJzZUZsb2F0KHBvc2l0aW9uSW5mby5sZWZ0KSkpICYmICh4ID0gMCk7XG4gIChpc05hTih4MikgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ucmlnaHQpKSkgJiYgKHgyID0gY29udGFpbmVyV2lkdGgpO1xuICAoaXNOYU4oeSkgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8udG9wKSkpICYmICh5ID0gMCk7XG4gIChpc05hTih5MikgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8uYm90dG9tKSkpICYmICh5MiA9IGNvbnRhaW5lckhlaWdodCk7XG4gIG1hcmdpbiA9IGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkobWFyZ2luIHx8IDApO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBNYXRoLm1heCh4MiAtIHggLSBtYXJnaW5bMV0gLSBtYXJnaW5bM10sIDApLFxuICAgIGhlaWdodDogTWF0aC5tYXgoeTIgLSB5IC0gbWFyZ2luWzBdIC0gbWFyZ2luWzJdLCAwKVxuICB9O1xufVxuLyoqXHJcbiAqIFBhcnNlIHBvc2l0aW9uIGluZm8uXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExheW91dFJlY3QocG9zaXRpb25JbmZvLCBjb250YWluZXJSZWN0LCBtYXJnaW4pIHtcbiAgbWFyZ2luID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShtYXJnaW4gfHwgMCk7XG4gIHZhciBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lclJlY3Qud2lkdGg7XG4gIHZhciBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXJSZWN0LmhlaWdodDtcbiAgdmFyIGxlZnQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmxlZnQsIGNvbnRhaW5lcldpZHRoKTtcbiAgdmFyIHRvcCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8udG9wLCBjb250YWluZXJIZWlnaHQpO1xuICB2YXIgcmlnaHQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLnJpZ2h0LCBjb250YWluZXJXaWR0aCk7XG4gIHZhciBib3R0b20gPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmJvdHRvbSwgY29udGFpbmVySGVpZ2h0KTtcbiAgdmFyIHdpZHRoID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby53aWR0aCwgY29udGFpbmVyV2lkdGgpO1xuICB2YXIgaGVpZ2h0ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby5oZWlnaHQsIGNvbnRhaW5lckhlaWdodCk7XG4gIHZhciB2ZXJ0aWNhbE1hcmdpbiA9IG1hcmdpblsyXSArIG1hcmdpblswXTtcbiAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBtYXJnaW5bMV0gKyBtYXJnaW5bM107XG4gIHZhciBhc3BlY3QgPSBwb3NpdGlvbkluZm8uYXNwZWN0O1xuICAvLyBJZiB3aWR0aCBpcyBub3Qgc3BlY2lmaWVkLCBjYWxjdWxhdGUgd2lkdGggZnJvbSBsZWZ0IGFuZCByaWdodFxuICBpZiAoaXNOYU4od2lkdGgpKSB7XG4gICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAtIHJpZ2h0IC0gaG9yaXpvbnRhbE1hcmdpbiAtIGxlZnQ7XG4gIH1cbiAgaWYgKGlzTmFOKGhlaWdodCkpIHtcbiAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgLSBib3R0b20gLSB2ZXJ0aWNhbE1hcmdpbiAtIHRvcDtcbiAgfVxuICBpZiAoYXNwZWN0ICE9IG51bGwpIHtcbiAgICAvLyBJZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBub3QgZ2l2ZW5cbiAgICAvLyAxLiBHcmFwaCBzaG91bGQgbm90IGV4Y2VlZHMgdGhlIGNvbnRhaW5lclxuICAgIC8vIDIuIEFzcGVjdCBtdXN0IGJlIGtlZXBlZFxuICAgIC8vIDMuIEdyYXBoIHNob3VsZCB0YWtlIHRoZSBzcGFjZSBhcyBtb3JlIGFzIHBvc3NpYmxlXG4gICAgLy8gRklYTUVcbiAgICAvLyBNYXJnaW4gaXMgbm90IGNvbnNpZGVyZWQsIGJlY2F1c2UgdGhlcmUgaXMgbm8gY2FzZSB0aGF0IGJvdGhcbiAgICAvLyB1c2luZyBtYXJnaW4gYW5kIGFzcGVjdCBzbyBmYXIuXG4gICAgaWYgKGlzTmFOKHdpZHRoKSAmJiBpc05hTihoZWlnaHQpKSB7XG4gICAgICBpZiAoYXNwZWN0ID4gY29udGFpbmVyV2lkdGggLyBjb250YWluZXJIZWlnaHQpIHtcbiAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAqIDAuODtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckhlaWdodCAqIDAuODtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHdpZHRoIG9yIGhlaWdodCB3aXRoIGdpdmVuIGFzcGVjdFxuICAgIGlmIChpc05hTih3aWR0aCkpIHtcbiAgICAgIHdpZHRoID0gYXNwZWN0ICogaGVpZ2h0O1xuICAgIH1cbiAgICBpZiAoaXNOYU4oaGVpZ2h0KSkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfVxuICB9XG4gIC8vIElmIGxlZnQgaXMgbm90IHNwZWNpZmllZCwgY2FsY3VsYXRlIGxlZnQgZnJvbSByaWdodCBhbmQgd2lkdGhcbiAgaWYgKGlzTmFOKGxlZnQpKSB7XG4gICAgbGVmdCA9IGNvbnRhaW5lcldpZHRoIC0gcmlnaHQgLSB3aWR0aCAtIGhvcml6b250YWxNYXJnaW47XG4gIH1cbiAgaWYgKGlzTmFOKHRvcCkpIHtcbiAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLSBib3R0b20gLSBoZWlnaHQgLSB2ZXJ0aWNhbE1hcmdpbjtcbiAgfVxuICAvLyBBbGlnbiBsZWZ0IGFuZCB0b3BcbiAgc3dpdGNoIChwb3NpdGlvbkluZm8ubGVmdCB8fCBwb3NpdGlvbkluZm8ucmlnaHQpIHtcbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgbGVmdCA9IGNvbnRhaW5lcldpZHRoIC8gMiAtIHdpZHRoIC8gMiAtIG1hcmdpblszXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAtIHdpZHRoIC0gaG9yaXpvbnRhbE1hcmdpbjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN3aXRjaCAocG9zaXRpb25JbmZvLnRvcCB8fCBwb3NpdGlvbkluZm8uYm90dG9tKSB7XG4gICAgY2FzZSAnbWlkZGxlJzpcbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgdG9wID0gY29udGFpbmVySGVpZ2h0IC8gMiAtIGhlaWdodCAvIDIgLSBtYXJnaW5bMF07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgdG9wID0gY29udGFpbmVySGVpZ2h0IC0gaGVpZ2h0IC0gdmVydGljYWxNYXJnaW47XG4gICAgICBicmVhaztcbiAgfVxuICAvLyBJZiBzb21ldGhpbmcgaXMgd3JvbmcgYW5kIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCBhcmUgY2FsY3VsYXRlZCBhcyBOYU5cbiAgbGVmdCA9IGxlZnQgfHwgMDtcbiAgdG9wID0gdG9wIHx8IDA7XG4gIGlmIChpc05hTih3aWR0aCkpIHtcbiAgICAvLyBXaWR0aCBtYXkgYmUgTmFOIGlmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuIGV4Y2VwdCB3aWR0aFxuICAgIHdpZHRoID0gY29udGFpbmVyV2lkdGggLSBob3Jpem9udGFsTWFyZ2luIC0gbGVmdCAtIChyaWdodCB8fCAwKTtcbiAgfVxuICBpZiAoaXNOYU4oaGVpZ2h0KSkge1xuICAgIC8vIEhlaWdodCBtYXkgYmUgTmFOIGlmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuIGV4Y2VwdCBoZWlnaHRcbiAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgLSB2ZXJ0aWNhbE1hcmdpbiAtIHRvcCAtIChib3R0b20gfHwgMCk7XG4gIH1cbiAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KGxlZnQgKyBtYXJnaW5bM10sIHRvcCArIG1hcmdpblswXSwgd2lkdGgsIGhlaWdodCk7XG4gIHJlY3QubWFyZ2luID0gbWFyZ2luO1xuICByZXR1cm4gcmVjdDtcbn1cbi8qKlxyXG4gKiBQb3NpdGlvbiBhIHpyIGVsZW1lbnQgaW4gdmlld3BvcnRcclxuICogIEdyb3VwIHBvc2l0aW9uIGlzIHNwZWNpZmllZCBieSBlaXRoZXJcclxuICogIHtsZWZ0LCB0b3B9LCB7cmlnaHQsIGJvdHRvbX1cclxuICogIElmIGFsbCBwcm9wZXJ0aWVzIGV4aXN0cywgcmlnaHQgYW5kIGJvdHRvbSB3aWxsIGJlIGlnb25yZWQuXHJcbiAqXHJcbiAqIExvZ2ljOlxyXG4gKiAgICAgMS4gU2NhbGUgKGFnYWluc3Qgb3JpZ2luIHBvaW50IGluIHBhcmVudCBjb29yZClcclxuICogICAgIDIuIFJvdGF0ZSAoYWdhaW5zdCBvcmlnaW4gcG9pbnQgaW4gcGFyZW50IGNvb3JkKVxyXG4gKiAgICAgMy4gVHJhbnNsYXRlICh3aXRoIGVsLnBvc2l0aW9uIGJ5IHRoaXMgbWV0aG9kKVxyXG4gKiBTbyB0aGlzIG1ldGhvZCBvbmx5IGZpeGVzIHRoZSBsYXN0IHN0ZXAgJ1RyYW5zbGF0ZScsIHdoaWNoIGRvZXMgbm90IGFmZmVjdFxyXG4gKiBzY2FsaW5nIGFuZCByb3RhdGluZy5cclxuICpcclxuICogSWYgYmUgY2FsbGVkIHJlcGVhdGVkbHkgd2l0aCB0aGUgc2FtZSBpbnB1dCBlbCwgdGhlIHNhbWUgcmVzdWx0IHdpbGwgYmUgZ290dGVuLlxyXG4gKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgbGF5b3V0IGhhcHBlbmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gZWwgU2hvdWxkIGhhdmUgYGdldEJvdW5kaW5nUmVjdGAgbWV0aG9kLlxyXG4gKiBAcGFyYW0gcG9zaXRpb25JbmZvXHJcbiAqIEBwYXJhbSBwb3NpdGlvbkluZm8ubGVmdFxyXG4gKiBAcGFyYW0gcG9zaXRpb25JbmZvLnRvcFxyXG4gKiBAcGFyYW0gcG9zaXRpb25JbmZvLnJpZ2h0XHJcbiAqIEBwYXJhbSBwb3NpdGlvbkluZm8uYm90dG9tXHJcbiAqIEBwYXJhbSBwb3NpdGlvbkluZm8ud2lkdGggT25seSBmb3Igb3B0LmJvdW5kaW5nTW9kZWw6ICdyYXcnXHJcbiAqIEBwYXJhbSBwb3NpdGlvbkluZm8uaGVpZ2h0IE9ubHkgZm9yIG9wdC5ib3VuZGluZ01vZGVsOiAncmF3J1xyXG4gKiBAcGFyYW0gY29udGFpbmVyUmVjdFxyXG4gKiBAcGFyYW0gbWFyZ2luXHJcbiAqIEBwYXJhbSBvcHRcclxuICogQHBhcmFtIG9wdC5odiBPbmx5IGhvcml6b250YWwgb3Igb25seSB2ZXJ0aWNhbC4gRGVmYXVsdCB0byBiZSBbMSwgMV1cclxuICogQHBhcmFtIG9wdC5ib3VuZGluZ01vZGVcclxuICogICAgICAgIFNwZWNpZnkgaG93IHRvIGNhbGN1bGF0ZSBib3VuZGluZ1JlY3Qgd2hlbiBsb2NhdGluZy5cclxuICogICAgICAgICdhbGwnOiBQb3NpdGlvbiB0aGUgYm91bmRpbmdSZWN0IHRoYXQgaXMgdHJhbnNmb3JtZWQgYW5kIHVpb25lZFxyXG4gKiAgICAgICAgICAgICAgIGJvdGggaXRzZWxmIGFuZCBpdHMgZGVzY2VuZGFudHMuXHJcbiAqICAgICAgICAgICAgICAgVGhpcyBtb2RlIHNpbXBsaWVzIGNvbmZpbmUgdGhlIGVsZW1lbnRzIGluIHRoZSBib3VuZGluZ1xyXG4gKiAgICAgICAgICAgICAgIG9mIHRoZWlyIGNvbnRhaW5lciAoZS5nLiwgdXNpbmcgJ3JpZ2h0OiAwJykuXHJcbiAqICAgICAgICAncmF3JzogUG9zaXRpb24gdGhlIGJvdW5kaW5nUmVjdCB0aGF0IGlzIG5vdCB0cmFuc2Zvcm1lZCBhbmQgb25seSBpdHNlbGYuXHJcbiAqICAgICAgICAgICAgICAgVGhpcyBtb2RlIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IGEgZWxlbWVudCBjYW4gb3ZlcmZsb3cgaXRzXHJcbiAqICAgICAgICAgICAgICAgY29udGFpbmVyLiAoQ29uc2lkZXIgYSByb3RhdGVkIGNpcmNsZSBuZWVkcyB0byBiZSBsb2NhdGVkIGluIGEgY29ybmVyLilcclxuICogICAgICAgICAgICAgICBJbiB0aGlzIG1vZGUgcG9zaXRpb25JbmZvLndpZHRoL2hlaWdodCBjYW4gb25seSBiZSBudW1iZXIuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvc2l0aW9uRWxlbWVudChlbCwgcG9zaXRpb25JbmZvLCBjb250YWluZXJSZWN0LCBtYXJnaW4sIG9wdCwgb3V0KSB7XG4gIHZhciBoID0gIW9wdCB8fCAhb3B0Lmh2IHx8IG9wdC5odlswXTtcbiAgdmFyIHYgPSAhb3B0IHx8ICFvcHQuaHYgfHwgb3B0Lmh2WzFdO1xuICB2YXIgYm91bmRpbmdNb2RlID0gb3B0ICYmIG9wdC5ib3VuZGluZ01vZGUgfHwgJ2FsbCc7XG4gIG91dCA9IG91dCB8fCBlbDtcbiAgb3V0LnggPSBlbC54O1xuICBvdXQueSA9IGVsLnk7XG4gIGlmICghaCAmJiAhdikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcmVjdDtcbiAgaWYgKGJvdW5kaW5nTW9kZSA9PT0gJ3JhdycpIHtcbiAgICByZWN0ID0gZWwudHlwZSA9PT0gJ2dyb3VwJyA/IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgK3Bvc2l0aW9uSW5mby53aWR0aCB8fCAwLCArcG9zaXRpb25JbmZvLmhlaWdodCB8fCAwKSA6IGVsLmdldEJvdW5kaW5nUmVjdCgpO1xuICB9IGVsc2Uge1xuICAgIHJlY3QgPSBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICBpZiAoZWwubmVlZExvY2FsVHJhbnNmb3JtKCkpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBlbC5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuICAgICAgLy8gTm90aWNlOiByYXcgcmVjdCBtYXkgYmUgaW5uZXIgb2JqZWN0IG9mIGVsLFxuICAgICAgLy8gd2hpY2ggc2hvdWxkIG5vdCBiZSBtb2RpZmllZC5cbiAgICAgIHJlY3QgPSByZWN0LmNsb25lKCk7XG4gICAgICByZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG4gIC8vIFRoZSByZWFsIHdpZHRoIGFuZCBoZWlnaHQgY2FuIG5vdCBiZSBzcGVjaWZpZWQgYnV0IGNhbGN1bGF0ZWQgYnkgdGhlIGdpdmVuIGVsLlxuICB2YXIgbGF5b3V0UmVjdCA9IGdldExheW91dFJlY3QoenJVdGlsLmRlZmF1bHRzKHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH0sIHBvc2l0aW9uSW5mbyksIGNvbnRhaW5lclJlY3QsIG1hcmdpbik7XG4gIC8vIEJlY2F1c2UgJ3RyYW5sYXRlJyBpcyB0aGUgbGFzdCBzdGVwIGluIHRyYW5zZm9ybVxuICAvLyAoc2VlIHpyZW5kZXIvY29yZS9UcmFuc2Zvcm1hYmxlI2dldExvY2FsVHJhbnNmb3JtKSxcbiAgLy8gd2UgY2FuIGp1c3Qgb25seSBtb2RpZnkgZWwucG9zaXRpb24gdG8gZ2V0IGZpbmFsIHJlc3VsdC5cbiAgdmFyIGR4ID0gaCA/IGxheW91dFJlY3QueCAtIHJlY3QueCA6IDA7XG4gIHZhciBkeSA9IHYgPyBsYXlvdXRSZWN0LnkgLSByZWN0LnkgOiAwO1xuICBpZiAoYm91bmRpbmdNb2RlID09PSAncmF3Jykge1xuICAgIG91dC54ID0gZHg7XG4gICAgb3V0LnkgPSBkeTtcbiAgfSBlbHNlIHtcbiAgICBvdXQueCArPSBkeDtcbiAgICBvdXQueSArPSBkeTtcbiAgfVxuICBpZiAob3V0ID09PSBlbCkge1xuICAgIGVsLm1hcmtSZWRyYXcoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxyXG4gKiBAcGFyYW0gb3B0aW9uIENvbnRhaW5zIHNvbWUgb2YgdGhlIHByb3BlcnRpZXMgaW4gSFZfTkFNRVMuXHJcbiAqIEBwYXJhbSBodklkeCAwOiBob3Jpem9udGFsOyAxOiB2ZXJ0aWNhbC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gc2l6ZUNhbGN1bGFibGUob3B0aW9uLCBodklkeCkge1xuICByZXR1cm4gb3B0aW9uW0hWX05BTUVTW2h2SWR4XVswXV0gIT0gbnVsbCB8fCBvcHRpb25bSFZfTkFNRVNbaHZJZHhdWzFdXSAhPSBudWxsICYmIG9wdGlvbltIVl9OQU1FU1todklkeF1bMl1dICE9IG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hMYXlvdXRNb2RlKGlucykge1xuICB2YXIgbGF5b3V0TW9kZSA9IGlucy5sYXlvdXRNb2RlIHx8IGlucy5jb25zdHJ1Y3Rvci5sYXlvdXRNb2RlO1xuICByZXR1cm4genJVdGlsLmlzT2JqZWN0KGxheW91dE1vZGUpID8gbGF5b3V0TW9kZSA6IGxheW91dE1vZGUgPyB7XG4gICAgdHlwZTogbGF5b3V0TW9kZVxuICB9IDogbnVsbDtcbn1cbi8qKlxyXG4gKiBDb25zaWRlciBDYXNlOlxyXG4gKiBXaGVuIGRlZmF1bHQgb3B0aW9uIGhhcyB7bGVmdDogMCwgd2lkdGg6IDEwMH0sIGFuZCB3ZSBzZXQge3JpZ2h0OiAwfVxyXG4gKiB0aHJvdWdoIHNldE9wdGlvbiBvciBtZWRpYSBxdWVyeSwgdXNpbmcgbm9ybWFsIHpyVXRpbC5tZXJnZSB3aWxsIGNhdXNlXHJcbiAqIHtyaWdodDogMH0gZG9lcyBub3QgdGFrZSBlZmZlY3QuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIENvbXBvbmVudE1vZGVsLmV4dGVuZCh7XHJcbiAqICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcbiAqICAgICAgICAgLi4uXHJcbiAqICAgICAgICAgbGV0IGlucHV0UG9zaXRpb25QYXJhbXMgPSBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbik7XHJcbiAqICAgICAgICAgdGhpcy5tZXJnZU9wdGlvbihpbnB1dFBvc2l0aW9uUGFyYW1zKTtcclxuICogICAgIH0sXHJcbiAqICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld09wdGlvbikge1xyXG4gKiAgICAgICAgIG5ld09wdGlvbiAmJiB6clV0aWwubWVyZ2UodGhpc09wdGlvbiwgbmV3T3B0aW9uLCB0cnVlKTtcclxuICogICAgICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbSh0aGlzT3B0aW9uLCBuZXdPcHRpb24pO1xyXG4gKiAgICAgfVxyXG4gKiB9KTtcclxuICpcclxuICogQHBhcmFtIHRhcmdldE9wdGlvblxyXG4gKiBAcGFyYW0gbmV3T3B0aW9uXHJcbiAqIEBwYXJhbSBvcHRcclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VMYXlvdXRQYXJhbSh0YXJnZXRPcHRpb24sIG5ld09wdGlvbiwgb3B0KSB7XG4gIHZhciBpZ25vcmVTaXplID0gb3B0ICYmIG9wdC5pZ25vcmVTaXplO1xuICAhenJVdGlsLmlzQXJyYXkoaWdub3JlU2l6ZSkgJiYgKGlnbm9yZVNpemUgPSBbaWdub3JlU2l6ZSwgaWdub3JlU2l6ZV0pO1xuICB2YXIgaFJlc3VsdCA9IG1lcmdlKEhWX05BTUVTWzBdLCAwKTtcbiAgdmFyIHZSZXN1bHQgPSBtZXJnZShIVl9OQU1FU1sxXSwgMSk7XG4gIGNvcHkoSFZfTkFNRVNbMF0sIHRhcmdldE9wdGlvbiwgaFJlc3VsdCk7XG4gIGNvcHkoSFZfTkFNRVNbMV0sIHRhcmdldE9wdGlvbiwgdlJlc3VsdCk7XG4gIGZ1bmN0aW9uIG1lcmdlKG5hbWVzLCBodklkeCkge1xuICAgIHZhciBuZXdQYXJhbXMgPSB7fTtcbiAgICB2YXIgbmV3VmFsdWVDb3VudCA9IDA7XG4gICAgdmFyIG1lcmdlZCA9IHt9O1xuICAgIHZhciBtZXJnZWRWYWx1ZUNvdW50ID0gMDtcbiAgICB2YXIgZW5vdWdoUGFyYW1OdW1iZXIgPSAyO1xuICAgIGVhY2gobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBtZXJnZWRbbmFtZV0gPSB0YXJnZXRPcHRpb25bbmFtZV07XG4gICAgfSk7XG4gICAgZWFjaChuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIC8vIENvbnNpZGVyIGNhc2U6IG5ld09wdGlvbi53aWR0aCBpcyBudWxsLCB3aGljaCBpc1xuICAgICAgLy8gc2V0IGJ5IHVzZXIgZm9yIHJlbW92aW5nIHdpZHRoIHNldHRpbmcuXG4gICAgICBoYXNQcm9wKG5ld09wdGlvbiwgbmFtZSkgJiYgKG5ld1BhcmFtc1tuYW1lXSA9IG1lcmdlZFtuYW1lXSA9IG5ld09wdGlvbltuYW1lXSk7XG4gICAgICBoYXNWYWx1ZShuZXdQYXJhbXMsIG5hbWUpICYmIG5ld1ZhbHVlQ291bnQrKztcbiAgICAgIGhhc1ZhbHVlKG1lcmdlZCwgbmFtZSkgJiYgbWVyZ2VkVmFsdWVDb3VudCsrO1xuICAgIH0pO1xuICAgIGlmIChpZ25vcmVTaXplW2h2SWR4XSkge1xuICAgICAgLy8gT25seSBvbmUgb2YgbGVmdC9yaWdodCBpcyBwcmVtaXR0ZWQgdG8gZXhpc3QuXG4gICAgICBpZiAoaGFzVmFsdWUobmV3T3B0aW9uLCBuYW1lc1sxXSkpIHtcbiAgICAgICAgbWVyZ2VkW25hbWVzWzJdXSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGhhc1ZhbHVlKG5ld09wdGlvbiwgbmFtZXNbMl0pKSB7XG4gICAgICAgIG1lcmdlZFtuYW1lc1sxXV0gPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgLy8gQ2FzZTogbmV3T3B0aW9uOiB7d2lkdGg6IC4uLiwgcmlnaHQ6IC4uLn0sXG4gICAgLy8gb3IgdGFyZ2V0T3B0aW9uOiB7cmlnaHQ6IC4uLn0gYW5kIG5ld09wdGlvbjoge3dpZHRoOiAuLi59LFxuICAgIC8vIFRoZXJlIGlzIG5vIGNvbmZsaWN0IHdoZW4gbWVyZ2VkIG9ubHkgaGFzIHBhcmFtcyBjb3VudFxuICAgIC8vIGxpdHRsZSB0aGFuIGVub3VnaFBhcmFtTnVtYmVyLlxuICAgIGlmIChtZXJnZWRWYWx1ZUNvdW50ID09PSBlbm91Z2hQYXJhbU51bWJlciB8fCAhbmV3VmFsdWVDb3VudCkge1xuICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgLy8gQ2FzZTogbmV3T3B0aW9uOiB7d2lkdGg6IC4uLiwgcmlnaHQ6IC4uLn0sXG4gICAgLy8gVGhhbiB3ZSBjYW4gbWFrZSBzdXJlIHVzZXIgb25seSB3YW50IHRob3NlIHR3bywgYW5kIGlnbm9yZVxuICAgIC8vIGFsbCBvcmlnaW4gcGFyYW1zIGluIHRhcmdldE9wdGlvbi5cbiAgICBlbHNlIGlmIChuZXdWYWx1ZUNvdW50ID49IGVub3VnaFBhcmFtTnVtYmVyKSB7XG4gICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDaG9zZSBhbm90aGVyIHBhcmFtIGZyb20gdGFyZ2V0T3B0aW9uIGJ5IHByaW9yaXR5LlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZV8xID0gbmFtZXNbaV07XG4gICAgICAgIGlmICghaGFzUHJvcChuZXdQYXJhbXMsIG5hbWVfMSkgJiYgaGFzUHJvcCh0YXJnZXRPcHRpb24sIG5hbWVfMSkpIHtcbiAgICAgICAgICBuZXdQYXJhbXNbbmFtZV8xXSA9IHRhcmdldE9wdGlvbltuYW1lXzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYXNQcm9wKG9iaiwgbmFtZSkge1xuICAgIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gaGFzVmFsdWUob2JqLCBuYW1lKSB7XG4gICAgcmV0dXJuIG9ialtuYW1lXSAhPSBudWxsICYmIG9ialtuYW1lXSAhPT0gJ2F1dG8nO1xuICB9XG4gIGZ1bmN0aW9uIGNvcHkobmFtZXMsIHRhcmdldCwgc291cmNlKSB7XG4gICAgZWFjaChuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IHNvdXJjZVtuYW1lXTtcbiAgICB9KTtcbiAgfVxufVxuLyoqXHJcbiAqIFJldHJpZXZlICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nLCAnd2lkdGgnLCAnaGVpZ2h0JyBmcm9tIG9iamVjdC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGF5b3V0UGFyYW1zKHNvdXJjZSkge1xuICByZXR1cm4gY29weUxheW91dFBhcmFtcyh7fSwgc291cmNlKTtcbn1cbi8qKlxyXG4gKiBSZXRyaWV2ZSAnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJywgJ3dpZHRoJywgJ2hlaWdodCcgZnJvbSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcclxuICogQHJldHVybiB7T2JqZWN0fSBSZXN1bHQgY29udGFpbnMgdGhvc2UgcHJvcHMuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlMYXlvdXRQYXJhbXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgc291cmNlICYmIHRhcmdldCAmJiBlYWNoKExPQ0FUSU9OX1BBUkFNUywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBzb3VyY2UuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgKHRhcmdldFtuYW1lXSA9IHNvdXJjZVtuYW1lXSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34253\n")},34833:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BV: () => (/* binding */ SPECIAL_STATES),\n/* harmony export */   CA: () => (/* binding */ Z2_EMPHASIS_LIFT),\n/* harmony export */   DW: () => (/* binding */ setDefaultStateProxy),\n/* harmony export */   Du: () => (/* binding */ blurComponent),\n/* harmony export */   HY: () => (/* binding */ enterEmphasis),\n/* harmony export */   Iz: () => (/* binding */ handleGlobalMouseOutForHighDown),\n/* harmony export */   JC: () => (/* binding */ leaveBlur),\n/* harmony export */   JI: () => (/* binding */ enterSelect),\n/* harmony export */   Lm: () => (/* binding */ toggleHoverEmphasis),\n/* harmony export */   Lv: () => (/* binding */ SELECT_ACTION_TYPE),\n/* harmony export */   Lx: () => (/* binding */ isSelectChangePayload),\n/* harmony export */   Mx: () => (/* binding */ setStatesStylesFromModel),\n/* harmony export */   PW: () => (/* binding */ DOWNPLAY_ACTION_TYPE),\n/* harmony export */   Pk: () => (/* binding */ setStatesFlag),\n/* harmony export */   Q6: () => (/* binding */ TOGGLE_SELECT_ACTION_TYPE),\n/* harmony export */   QX: () => (/* binding */ enterBlur),\n/* harmony export */   SD: () => (/* binding */ leaveEmphasis),\n/* harmony export */   T$: () => (/* binding */ isHighDownPayload),\n/* harmony export */   Tl: () => (/* binding */ findComponentHighDownDispatchers),\n/* harmony export */   U2: () => (/* binding */ UNSELECT_ACTION_TYPE),\n/* harmony export */   _m: () => (/* binding */ handleGlobalMouseOverForHighDown),\n/* harmony export */   _n: () => (/* binding */ getHighlightDigit),\n/* harmony export */   e3: () => (/* binding */ HOVER_STATE_EMPHASIS),\n/* harmony export */   fz: () => (/* binding */ savePathStates),\n/* harmony export */   gR: () => (/* binding */ enableHoverFocus),\n/* harmony export */   gd: () => (/* binding */ leaveSelect),\n/* harmony export */   h5: () => (/* binding */ HIGHLIGHT_ACTION_TYPE),\n/* harmony export */   iJ: () => (/* binding */ enableHoverEmphasis),\n/* harmony export */   ix: () => (/* binding */ setAsHighDownDispatcher),\n/* harmony export */   jA: () => (/* binding */ updateSeriesElementSelection),\n/* harmony export */   lV: () => (/* binding */ blurSeriesFromHighlightPayload),\n/* harmony export */   mc: () => (/* binding */ getAllSelectedIndices),\n/* harmony export */   ml: () => (/* binding */ enableComponentHighDownFeatures),\n/* harmony export */   qR: () => (/* binding */ allLeaveBlur),\n/* harmony export */   t6: () => (/* binding */ toggleSelectionFromPayload),\n/* harmony export */   u6: () => (/* binding */ isHighDownDispatcher),\n/* harmony export */   wV: () => (/* binding */ DISPLAY_STATES),\n/* harmony export */   zX: () => (/* binding */ HOVER_STATE_BLUR)\n/* harmony export */ });\n/* unused harmony exports HOVER_STATE_NORMAL, Z2_SELECT_LIFT, clearStates, enterEmphasisWhenMouseOver, leaveEmphasisWhenMouseOut, blurSeries, disableHoverEmphasis */\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _innerStore_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(69622);\n/* harmony import */ var zrender_lib_tool_color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47698);\n/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n/* harmony import */ var zrender_lib_graphic_Path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(59482);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n// Reserve 0 as default.\nvar _highlightNextDigit = 1;\nvar _highlightKeyMap = {};\nvar getSavedStates = (0,_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nvar getComponentStates = (0,_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nvar HOVER_STATE_NORMAL = 0;\nvar HOVER_STATE_BLUR = 1;\nvar HOVER_STATE_EMPHASIS = 2;\nvar SPECIAL_STATES = ['emphasis', 'blur', 'select'];\nvar DISPLAY_STATES = ['normal', 'emphasis', 'blur', 'select'];\nvar Z2_EMPHASIS_LIFT = 10;\nvar Z2_SELECT_LIFT = 9;\nvar HIGHLIGHT_ACTION_TYPE = 'highlight';\nvar DOWNPLAY_ACTION_TYPE = 'downplay';\nvar SELECT_ACTION_TYPE = 'select';\nvar UNSELECT_ACTION_TYPE = 'unselect';\nvar TOGGLE_SELECT_ACTION_TYPE = 'toggleSelect';\nfunction hasFillOrStroke(fillOrStroke) {\n  return fillOrStroke != null && fillOrStroke !== 'none';\n}\nfunction doChangeHoverState(el, stateName, hoverStateEnum) {\n  if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) {\n    el.onHoverStateChange(stateName);\n  }\n  el.hoverState = hoverStateEnum;\n}\nfunction singleEnterEmphasis(el) {\n  // Only mark the flag.\n  // States will be applied in the echarts.ts in next frame.\n  doChangeHoverState(el, 'emphasis', HOVER_STATE_EMPHASIS);\n}\nfunction singleLeaveEmphasis(el) {\n  // Only mark the flag.\n  // States will be applied in the echarts.ts in next frame.\n  if (el.hoverState === HOVER_STATE_EMPHASIS) {\n    doChangeHoverState(el, 'normal', HOVER_STATE_NORMAL);\n  }\n}\nfunction singleEnterBlur(el) {\n  doChangeHoverState(el, 'blur', HOVER_STATE_BLUR);\n}\nfunction singleLeaveBlur(el) {\n  if (el.hoverState === HOVER_STATE_BLUR) {\n    doChangeHoverState(el, 'normal', HOVER_STATE_NORMAL);\n  }\n}\nfunction singleEnterSelect(el) {\n  el.selected = true;\n}\nfunction singleLeaveSelect(el) {\n  el.selected = false;\n}\nfunction updateElementState(el, updater, commonParam) {\n  updater(el, commonParam);\n}\nfunction traverseUpdateState(el, updater, commonParam) {\n  updateElementState(el, updater, commonParam);\n  el.isGroup && el.traverse(function (child) {\n    updateElementState(child, updater, commonParam);\n  });\n}\nfunction setStatesFlag(el, stateName) {\n  switch (stateName) {\n    case 'emphasis':\n      el.hoverState = HOVER_STATE_EMPHASIS;\n      break;\n    case 'normal':\n      el.hoverState = HOVER_STATE_NORMAL;\n      break;\n    case 'blur':\n      el.hoverState = HOVER_STATE_BLUR;\n      break;\n    case 'select':\n      el.selected = true;\n  }\n}\n/**\r\n * If we reuse elements when rerender.\r\n * DON'T forget to clearStates before we update the style and shape.\r\n * Or we may update on the wrong state instead of normal state.\r\n */\nfunction clearStates(el) {\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.clearStates();\n    });\n  } else {\n    el.clearStates();\n  }\n}\nfunction getFromStateStyle(el, props, toStateName, defaultValue) {\n  var style = el.style;\n  var fromState = {};\n  for (var i = 0; i < props.length; i++) {\n    var propName = props[i];\n    var val = style[propName];\n    fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;\n  }\n  for (var i = 0; i < el.animators.length; i++) {\n    var animator = el.animators[i];\n    if (animator.__fromStateTransition\n    // Don't consider the animation to emphasis state.\n    && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === 'style') {\n      animator.saveTo(fromState, props);\n    }\n  }\n  return fromState;\n}\nfunction createEmphasisDefaultState(el, stateName, targetStates, state) {\n  var hasSelect = targetStates && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.indexOf)(targetStates, 'select') >= 0;\n  var cloned = false;\n  if (el instanceof zrender_lib_graphic_Path_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .Ay) {\n    var store = getSavedStates(el);\n    var fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;\n    var fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;\n    if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {\n      state = state || {};\n      var emphasisStyle = state.style || {};\n      // inherit case\n      if (emphasisStyle.fill === 'inherit') {\n        cloned = true;\n        state = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, state);\n        emphasisStyle = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, emphasisStyle);\n        emphasisStyle.fill = fromFill;\n      }\n      // Apply default color lift\n      else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {\n        cloned = true;\n        // Not modify the original value.\n        state = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, state);\n        emphasisStyle = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, emphasisStyle);\n        // Already being applied 'emphasis'. DON'T lift color multiple times.\n        emphasisStyle.fill = (0,zrender_lib_tool_color_js__WEBPACK_IMPORTED_MODULE_3__.liftColor)(fromFill);\n      }\n      // Not highlight stroke if fill has been highlighted.\n      else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {\n        if (!cloned) {\n          state = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, state);\n          emphasisStyle = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, emphasisStyle);\n        }\n        emphasisStyle.stroke = (0,zrender_lib_tool_color_js__WEBPACK_IMPORTED_MODULE_3__.liftColor)(fromStroke);\n      }\n      state.style = emphasisStyle;\n    }\n  }\n  if (state) {\n    // TODO Share with textContent?\n    if (state.z2 == null) {\n      if (!cloned) {\n        state = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, state);\n      }\n      var z2EmphasisLift = el.z2EmphasisLift;\n      state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);\n    }\n  }\n  return state;\n}\nfunction createSelectDefaultState(el, stateName, state) {\n  // const hasSelect = indexOf(el.currentStates, stateName) >= 0;\n  if (state) {\n    // TODO Share with textContent?\n    if (state.z2 == null) {\n      state = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, state);\n      var z2SelectLift = el.z2SelectLift;\n      state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);\n    }\n  }\n  return state;\n}\nfunction createBlurDefaultState(el, stateName, state) {\n  var hasBlur = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.indexOf)(el.currentStates, stateName) >= 0;\n  var currentOpacity = el.style.opacity;\n  var fromState = !hasBlur ? getFromStateStyle(el, ['opacity'], stateName, {\n    opacity: 1\n  }) : null;\n  state = state || {};\n  var blurStyle = state.style || {};\n  if (blurStyle.opacity == null) {\n    // clone state\n    state = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, state);\n    blurStyle = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({\n      // Already being applied 'emphasis'. DON'T mul opacity multiple times.\n      opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1\n    }, blurStyle);\n    state.style = blurStyle;\n  }\n  return state;\n}\nfunction elementStateProxy(stateName, targetStates) {\n  var state = this.states[stateName];\n  if (this.style) {\n    if (stateName === 'emphasis') {\n      return createEmphasisDefaultState(this, stateName, targetStates, state);\n    } else if (stateName === 'blur') {\n      return createBlurDefaultState(this, stateName, state);\n    } else if (stateName === 'select') {\n      return createSelectDefaultState(this, stateName, state);\n    }\n  }\n  return state;\n}\n/**\r\n * Set hover style (namely \"emphasis style\") of element.\r\n * @param el Should not be `zrender/graphic/Group`.\r\n * @param focus 'self' | 'selfInSeries' | 'series'\r\n */\nfunction setDefaultStateProxy(el) {\n  el.stateProxy = elementStateProxy;\n  var textContent = el.getTextContent();\n  var textGuide = el.getTextGuideLine();\n  if (textContent) {\n    textContent.stateProxy = elementStateProxy;\n  }\n  if (textGuide) {\n    textGuide.stateProxy = elementStateProxy;\n  }\n}\nfunction enterEmphasisWhenMouseOver(el, e) {\n  !shouldSilent(el, e)\n  // \"emphasis\" event highlight has higher priority than mouse highlight.\n  && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);\n}\nfunction leaveEmphasisWhenMouseOut(el, e) {\n  !shouldSilent(el, e)\n  // \"emphasis\" event highlight has higher priority than mouse highlight.\n  && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);\n}\nfunction enterEmphasis(el, highlightDigit) {\n  el.__highByOuter |= 1 << (highlightDigit || 0);\n  traverseUpdateState(el, singleEnterEmphasis);\n}\nfunction leaveEmphasis(el, highlightDigit) {\n  !(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);\n}\nfunction enterBlur(el) {\n  traverseUpdateState(el, singleEnterBlur);\n}\nfunction leaveBlur(el) {\n  traverseUpdateState(el, singleLeaveBlur);\n}\nfunction enterSelect(el) {\n  traverseUpdateState(el, singleEnterSelect);\n}\nfunction leaveSelect(el) {\n  traverseUpdateState(el, singleLeaveSelect);\n}\nfunction shouldSilent(el, e) {\n  return el.__highDownSilentOnTouch && e.zrByTouch;\n}\nfunction allLeaveBlur(api) {\n  var model = api.getModel();\n  var leaveBlurredSeries = [];\n  var allComponentViews = [];\n  model.eachComponent(function (componentType, componentModel) {\n    var componentStates = getComponentStates(componentModel);\n    var isSeries = componentType === 'series';\n    var view = isSeries ? api.getViewOfSeriesModel(componentModel) : api.getViewOfComponentModel(componentModel);\n    !isSeries && allComponentViews.push(view);\n    if (componentStates.isBlured) {\n      // Leave blur anyway\n      view.group.traverse(function (child) {\n        singleLeaveBlur(child);\n      });\n      isSeries && leaveBlurredSeries.push(componentModel);\n    }\n    componentStates.isBlured = false;\n  });\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(allComponentViews, function (view) {\n    if (view && view.toggleBlurSeries) {\n      view.toggleBlurSeries(leaveBlurredSeries, false, model);\n    }\n  });\n}\nfunction blurSeries(targetSeriesIndex, focus, blurScope, api) {\n  var ecModel = api.getModel();\n  blurScope = blurScope || 'coordinateSystem';\n  function leaveBlurOfIndices(data, dataIndices) {\n    for (var i = 0; i < dataIndices.length; i++) {\n      var itemEl = data.getItemGraphicEl(dataIndices[i]);\n      itemEl && leaveBlur(itemEl);\n    }\n  }\n  if (targetSeriesIndex == null) {\n    return;\n  }\n  if (!focus || focus === 'none') {\n    return;\n  }\n  var targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);\n  var targetCoordSys = targetSeriesModel.coordinateSystem;\n  if (targetCoordSys && targetCoordSys.master) {\n    targetCoordSys = targetCoordSys.master;\n  }\n  var blurredSeries = [];\n  ecModel.eachSeries(function (seriesModel) {\n    var sameSeries = targetSeriesModel === seriesModel;\n    var coordSys = seriesModel.coordinateSystem;\n    if (coordSys && coordSys.master) {\n      coordSys = coordSys.master;\n    }\n    var sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries; // If there is no coordinate system. use sameSeries instead.\n    if (!(\n    // Not blur other series if blurScope series\n    blurScope === 'series' && !sameSeries\n    // Not blur other coordinate system if blurScope is coordinateSystem\n    || blurScope === 'coordinateSystem' && !sameCoordSys\n    // Not blur self series if focus is series.\n    || focus === 'series' && sameSeries\n    // TODO blurScope: coordinate system\n    )) {\n      var view = api.getViewOfSeriesModel(seriesModel);\n      view.group.traverse(function (child) {\n        // For the elements that have been triggered by other components,\n        // and are still required to be highlighted,\n        // because the current is directly forced to blur the element,\n        // it will cause the focus self to be unable to highlight, so skip the blur of this element.\n        if (child.__highByOuter && sameSeries && focus === 'self') {\n          return;\n        }\n        singleEnterBlur(child);\n      });\n      if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArrayLike)(focus)) {\n        leaveBlurOfIndices(seriesModel.getData(), focus);\n      } else if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(focus)) {\n        var dataTypes = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.keys)(focus);\n        for (var d = 0; d < dataTypes.length; d++) {\n          leaveBlurOfIndices(seriesModel.getData(dataTypes[d]), focus[dataTypes[d]]);\n        }\n      }\n      blurredSeries.push(seriesModel);\n      getComponentStates(seriesModel).isBlured = true;\n    }\n  });\n  ecModel.eachComponent(function (componentType, componentModel) {\n    if (componentType === 'series') {\n      return;\n    }\n    var view = api.getViewOfComponentModel(componentModel);\n    if (view && view.toggleBlurSeries) {\n      view.toggleBlurSeries(blurredSeries, true, ecModel);\n    }\n  });\n}\nfunction blurComponent(componentMainType, componentIndex, api) {\n  if (componentMainType == null || componentIndex == null) {\n    return;\n  }\n  var componentModel = api.getModel().getComponent(componentMainType, componentIndex);\n  if (!componentModel) {\n    return;\n  }\n  getComponentStates(componentModel).isBlured = true;\n  var view = api.getViewOfComponentModel(componentModel);\n  if (!view || !view.focusBlurEnabled) {\n    return;\n  }\n  view.group.traverse(function (child) {\n    singleEnterBlur(child);\n  });\n}\nfunction blurSeriesFromHighlightPayload(seriesModel, payload, api) {\n  var seriesIndex = seriesModel.seriesIndex;\n  var data = seriesModel.getData(payload.dataType);\n  if (!data) {\n    if (false) {}\n    return;\n  }\n  var dataIndex = (0,_model_js__WEBPACK_IMPORTED_MODULE_0__/* .queryDataIndex */ .le)(data, payload);\n  // Pick the first one if there is multiple/none exists.\n  dataIndex = ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(dataIndex) ? dataIndex[0] : dataIndex) || 0;\n  var el = data.getItemGraphicEl(dataIndex);\n  if (!el) {\n    var count = data.count();\n    var current = 0;\n    // If data on dataIndex is NaN.\n    while (!el && current < count) {\n      el = data.getItemGraphicEl(current++);\n    }\n  }\n  if (el) {\n    var ecData = (0,_innerStore_js__WEBPACK_IMPORTED_MODULE_4__/* .getECData */ .z)(el);\n    blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api);\n  } else {\n    // If there is no element put on the data. Try getting it from raw option\n    // TODO Should put it on seriesModel?\n    var focus_1 = seriesModel.get(['emphasis', 'focus']);\n    var blurScope = seriesModel.get(['emphasis', 'blurScope']);\n    if (focus_1 != null) {\n      blurSeries(seriesIndex, focus_1, blurScope, api);\n    }\n  }\n}\nfunction findComponentHighDownDispatchers(componentMainType, componentIndex, name, api) {\n  var ret = {\n    focusSelf: false,\n    dispatchers: null\n  };\n  if (componentMainType == null || componentMainType === 'series' || componentIndex == null || name == null) {\n    return ret;\n  }\n  var componentModel = api.getModel().getComponent(componentMainType, componentIndex);\n  if (!componentModel) {\n    return ret;\n  }\n  var view = api.getViewOfComponentModel(componentModel);\n  if (!view || !view.findHighDownDispatchers) {\n    return ret;\n  }\n  var dispatchers = view.findHighDownDispatchers(name);\n  // At presnet, the component (like Geo) only blur inside itself.\n  // So we do not use `blurScope` in component.\n  var focusSelf;\n  for (var i = 0; i < dispatchers.length; i++) {\n    if (false) {}\n    if ((0,_innerStore_js__WEBPACK_IMPORTED_MODULE_4__/* .getECData */ .z)(dispatchers[i]).focus === 'self') {\n      focusSelf = true;\n      break;\n    }\n  }\n  return {\n    focusSelf: focusSelf,\n    dispatchers: dispatchers\n  };\n}\nfunction handleGlobalMouseOverForHighDown(dispatcher, e, api) {\n  if (false) {}\n  var ecData = (0,_innerStore_js__WEBPACK_IMPORTED_MODULE_4__/* .getECData */ .z)(dispatcher);\n  var _a = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api),\n    dispatchers = _a.dispatchers,\n    focusSelf = _a.focusSelf;\n  // If `findHighDownDispatchers` is supported on the component,\n  // highlight/downplay elements with the same name.\n  if (dispatchers) {\n    if (focusSelf) {\n      blurComponent(ecData.componentMainType, ecData.componentIndex, api);\n    }\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(dispatchers, function (dispatcher) {\n      return enterEmphasisWhenMouseOver(dispatcher, e);\n    });\n  } else {\n    // Try blur all in the related series. Then emphasis the hoverred.\n    // TODO. progressive mode.\n    blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api);\n    if (ecData.focus === 'self') {\n      blurComponent(ecData.componentMainType, ecData.componentIndex, api);\n    }\n    // Other than series, component that not support `findHighDownDispatcher` will\n    // also use it. But in this case, highlight/downplay are only supported in\n    // mouse hover but not in dispatchAction.\n    enterEmphasisWhenMouseOver(dispatcher, e);\n  }\n}\nfunction handleGlobalMouseOutForHighDown(dispatcher, e, api) {\n  if (false) {}\n  allLeaveBlur(api);\n  var ecData = (0,_innerStore_js__WEBPACK_IMPORTED_MODULE_4__/* .getECData */ .z)(dispatcher);\n  var dispatchers = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api).dispatchers;\n  if (dispatchers) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(dispatchers, function (dispatcher) {\n      return leaveEmphasisWhenMouseOut(dispatcher, e);\n    });\n  } else {\n    leaveEmphasisWhenMouseOut(dispatcher, e);\n  }\n}\nfunction toggleSelectionFromPayload(seriesModel, payload, api) {\n  if (!isSelectChangePayload(payload)) {\n    return;\n  }\n  var dataType = payload.dataType;\n  var data = seriesModel.getData(dataType);\n  var dataIndex = (0,_model_js__WEBPACK_IMPORTED_MODULE_0__/* .queryDataIndex */ .le)(data, payload);\n  if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(dataIndex)) {\n    dataIndex = [dataIndex];\n  }\n  seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? 'toggleSelect' : payload.type === SELECT_ACTION_TYPE ? 'select' : 'unselect'](dataIndex, dataType);\n}\nfunction updateSeriesElementSelection(seriesModel) {\n  var allData = seriesModel.getAllData();\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(allData, function (_a) {\n    var data = _a.data,\n      type = _a.type;\n    data.eachItemGraphicEl(function (el, idx) {\n      seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);\n    });\n  });\n}\nfunction getAllSelectedIndices(ecModel) {\n  var ret = [];\n  ecModel.eachSeries(function (seriesModel) {\n    var allData = seriesModel.getAllData();\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(allData, function (_a) {\n      var data = _a.data,\n        type = _a.type;\n      var dataIndices = seriesModel.getSelectedDataIndices();\n      if (dataIndices.length > 0) {\n        var item = {\n          dataIndex: dataIndices,\n          seriesIndex: seriesModel.seriesIndex\n        };\n        if (type != null) {\n          item.dataType = type;\n        }\n        ret.push(item);\n      }\n    });\n  });\n  return ret;\n}\n/**\r\n * Enable the function that mouseover will trigger the emphasis state.\r\n *\r\n * NOTE:\r\n * This function should be used on the element with dataIndex, seriesIndex.\r\n *\r\n */\nfunction enableHoverEmphasis(el, focus, blurScope) {\n  setAsHighDownDispatcher(el, true);\n  traverseUpdateState(el, setDefaultStateProxy);\n  enableHoverFocus(el, focus, blurScope);\n}\nfunction disableHoverEmphasis(el) {\n  setAsHighDownDispatcher(el, false);\n}\nfunction toggleHoverEmphasis(el, focus, blurScope, isDisabled) {\n  isDisabled ? disableHoverEmphasis(el) : enableHoverEmphasis(el, focus, blurScope);\n}\nfunction enableHoverFocus(el, focus, blurScope) {\n  var ecData = (0,_innerStore_js__WEBPACK_IMPORTED_MODULE_4__/* .getECData */ .z)(el);\n  if (focus != null) {\n    // TODO dataIndex may be set after this function. This check is not useful.\n    // if (ecData.dataIndex == null) {\n    //     if (__DEV__) {\n    //         console.warn('focus can only been set on element with dataIndex');\n    //     }\n    // }\n    // else {\n    ecData.focus = focus;\n    ecData.blurScope = blurScope;\n    // }\n  } else if (ecData.focus) {\n    ecData.focus = null;\n  }\n}\nvar OTHER_STATES = ['emphasis', 'blur', 'select'];\nvar defaultStyleGetterMap = {\n  itemStyle: 'getItemStyle',\n  lineStyle: 'getLineStyle',\n  areaStyle: 'getAreaStyle'\n};\n/**\r\n * Set emphasis/blur/selected states of element.\r\n */\nfunction setStatesStylesFromModel(el, itemModel, styleType,\n// default itemStyle\ngetter) {\n  styleType = styleType || 'itemStyle';\n  for (var i = 0; i < OTHER_STATES.length; i++) {\n    var stateName = OTHER_STATES[i];\n    var model = itemModel.getModel([stateName, styleType]);\n    var state = el.ensureState(stateName);\n    // Let it throw error if getterType is not found.\n    state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]();\n  }\n}\n/**\r\n *\r\n * Set element as highlight / downplay dispatcher.\r\n * It will be checked when element received mouseover event or from highlight action.\r\n * It's in change of all highlight/downplay behavior of it's children.\r\n *\r\n * @param el\r\n * @param el.highDownSilentOnTouch\r\n *        In touch device, mouseover event will be trigger on touchstart event\r\n *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\r\n *        conveniently use hoverStyle when tap on touch screen without additional\r\n *        code for compatibility.\r\n *        But if the chart/component has select feature, which usually also use\r\n *        hoverStyle, there might be conflict between 'select-highlight' and\r\n *        'hover-highlight' especially when roam is enabled (see geo for example).\r\n *        In this case, `highDownSilentOnTouch` should be used to disable\r\n *        hover-highlight on touch device.\r\n * @param asDispatcher If `false`, do not set as \"highDownDispatcher\".\r\n */\nfunction setAsHighDownDispatcher(el, asDispatcher) {\n  var disable = asDispatcher === false;\n  var extendedEl = el;\n  // Make `highDownSilentOnTouch` and `onStateChange` only work after\n  // `setAsHighDownDispatcher` called. Avoid it is modified by user unexpectedly.\n  if (el.highDownSilentOnTouch) {\n    extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;\n  }\n  // Simple optimize, since this method might be\n  // called for each elements of a group in some cases.\n  if (!disable || extendedEl.__highDownDispatcher) {\n    // Emphasis, normal can be triggered manually by API or other components like hover link.\n    // el[method]('emphasis', onElementEmphasisEvent)[method]('normal', onElementNormalEvent);\n    // Also keep previous record.\n    extendedEl.__highByOuter = extendedEl.__highByOuter || 0;\n    extendedEl.__highDownDispatcher = !disable;\n  }\n}\nfunction isHighDownDispatcher(el) {\n  return !!(el && el.__highDownDispatcher);\n}\n/**\r\n * Enable component highlight/downplay features:\r\n * + hover link (within the same name)\r\n * + focus blur in component\r\n */\nfunction enableComponentHighDownFeatures(el, componentModel, componentHighDownName) {\n  var ecData = (0,_innerStore_js__WEBPACK_IMPORTED_MODULE_4__/* .getECData */ .z)(el);\n  ecData.componentMainType = componentModel.mainType;\n  ecData.componentIndex = componentModel.componentIndex;\n  ecData.componentHighDownName = componentHighDownName;\n}\n/**\r\n * Support highlight/downplay record on each elements.\r\n * For the case: hover highlight/downplay (legend, visualMap, ...) and\r\n * user triggered highlight/downplay should not conflict.\r\n * Only all of the highlightDigit cleared, return to normal.\r\n * @param {string} highlightKey\r\n * @return {number} highlightDigit\r\n */\nfunction getHighlightDigit(highlightKey) {\n  var highlightDigit = _highlightKeyMap[highlightKey];\n  if (highlightDigit == null && _highlightNextDigit <= 32) {\n    highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;\n  }\n  return highlightDigit;\n}\nfunction isSelectChangePayload(payload) {\n  var payloadType = payload.type;\n  return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;\n}\nfunction isHighDownPayload(payload) {\n  var payloadType = payload.type;\n  return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;\n}\nfunction savePathStates(el) {\n  var store = getSavedStates(el);\n  store.normalFill = el.style.fill;\n  store.normalStroke = el.style.stroke;\n  var selectState = el.states.select || {};\n  store.selectFill = selectState.style && selectState.style.fill || null;\n  store.selectStroke = selectState.style && selectState.style.stroke || null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ4MzMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL3N0YXRlcy5qcz81NzdhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgZXh0ZW5kLCBpbmRleE9mLCBpc0FycmF5TGlrZSwgaXNPYmplY3QsIGtleXMsIGlzQXJyYXksIGVhY2ggfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi9pbm5lclN0b3JlLmpzJztcbmltcG9ydCB7IGxpZnRDb2xvciB9IGZyb20gJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3IuanMnO1xuaW1wb3J0IHsgcXVlcnlEYXRhSW5kZXgsIG1ha2VJbm5lciB9IGZyb20gJy4vbW9kZWwuanMnO1xuaW1wb3J0IFBhdGggZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzJztcbmltcG9ydCB7IGVycm9yIH0gZnJvbSAnLi9sb2cuanMnO1xuLy8gUmVzZXJ2ZSAwIGFzIGRlZmF1bHQuXG52YXIgX2hpZ2hsaWdodE5leHREaWdpdCA9IDE7XG52YXIgX2hpZ2hsaWdodEtleU1hcCA9IHt9O1xudmFyIGdldFNhdmVkU3RhdGVzID0gbWFrZUlubmVyKCk7XG52YXIgZ2V0Q29tcG9uZW50U3RhdGVzID0gbWFrZUlubmVyKCk7XG5leHBvcnQgdmFyIEhPVkVSX1NUQVRFX05PUk1BTCA9IDA7XG5leHBvcnQgdmFyIEhPVkVSX1NUQVRFX0JMVVIgPSAxO1xuZXhwb3J0IHZhciBIT1ZFUl9TVEFURV9FTVBIQVNJUyA9IDI7XG5leHBvcnQgdmFyIFNQRUNJQUxfU1RBVEVTID0gWydlbXBoYXNpcycsICdibHVyJywgJ3NlbGVjdCddO1xuZXhwb3J0IHZhciBESVNQTEFZX1NUQVRFUyA9IFsnbm9ybWFsJywgJ2VtcGhhc2lzJywgJ2JsdXInLCAnc2VsZWN0J107XG5leHBvcnQgdmFyIFoyX0VNUEhBU0lTX0xJRlQgPSAxMDtcbmV4cG9ydCB2YXIgWjJfU0VMRUNUX0xJRlQgPSA5O1xuZXhwb3J0IHZhciBISUdITElHSFRfQUNUSU9OX1RZUEUgPSAnaGlnaGxpZ2h0JztcbmV4cG9ydCB2YXIgRE9XTlBMQVlfQUNUSU9OX1RZUEUgPSAnZG93bnBsYXknO1xuZXhwb3J0IHZhciBTRUxFQ1RfQUNUSU9OX1RZUEUgPSAnc2VsZWN0JztcbmV4cG9ydCB2YXIgVU5TRUxFQ1RfQUNUSU9OX1RZUEUgPSAndW5zZWxlY3QnO1xuZXhwb3J0IHZhciBUT0dHTEVfU0VMRUNUX0FDVElPTl9UWVBFID0gJ3RvZ2dsZVNlbGVjdCc7XG5mdW5jdGlvbiBoYXNGaWxsT3JTdHJva2UoZmlsbE9yU3Ryb2tlKSB7XG4gIHJldHVybiBmaWxsT3JTdHJva2UgIT0gbnVsbCAmJiBmaWxsT3JTdHJva2UgIT09ICdub25lJztcbn1cbmZ1bmN0aW9uIGRvQ2hhbmdlSG92ZXJTdGF0ZShlbCwgc3RhdGVOYW1lLCBob3ZlclN0YXRlRW51bSkge1xuICBpZiAoZWwub25Ib3ZlclN0YXRlQ2hhbmdlICYmIChlbC5ob3ZlclN0YXRlIHx8IDApICE9PSBob3ZlclN0YXRlRW51bSkge1xuICAgIGVsLm9uSG92ZXJTdGF0ZUNoYW5nZShzdGF0ZU5hbWUpO1xuICB9XG4gIGVsLmhvdmVyU3RhdGUgPSBob3ZlclN0YXRlRW51bTtcbn1cbmZ1bmN0aW9uIHNpbmdsZUVudGVyRW1waGFzaXMoZWwpIHtcbiAgLy8gT25seSBtYXJrIHRoZSBmbGFnLlxuICAvLyBTdGF0ZXMgd2lsbCBiZSBhcHBsaWVkIGluIHRoZSBlY2hhcnRzLnRzIGluIG5leHQgZnJhbWUuXG4gIGRvQ2hhbmdlSG92ZXJTdGF0ZShlbCwgJ2VtcGhhc2lzJywgSE9WRVJfU1RBVEVfRU1QSEFTSVMpO1xufVxuZnVuY3Rpb24gc2luZ2xlTGVhdmVFbXBoYXNpcyhlbCkge1xuICAvLyBPbmx5IG1hcmsgdGhlIGZsYWcuXG4gIC8vIFN0YXRlcyB3aWxsIGJlIGFwcGxpZWQgaW4gdGhlIGVjaGFydHMudHMgaW4gbmV4dCBmcmFtZS5cbiAgaWYgKGVsLmhvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX0VNUEhBU0lTKSB7XG4gICAgZG9DaGFuZ2VIb3ZlclN0YXRlKGVsLCAnbm9ybWFsJywgSE9WRVJfU1RBVEVfTk9STUFMKTtcbiAgfVxufVxuZnVuY3Rpb24gc2luZ2xlRW50ZXJCbHVyKGVsKSB7XG4gIGRvQ2hhbmdlSG92ZXJTdGF0ZShlbCwgJ2JsdXInLCBIT1ZFUl9TVEFURV9CTFVSKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZUxlYXZlQmx1cihlbCkge1xuICBpZiAoZWwuaG92ZXJTdGF0ZSA9PT0gSE9WRVJfU1RBVEVfQkxVUikge1xuICAgIGRvQ2hhbmdlSG92ZXJTdGF0ZShlbCwgJ25vcm1hbCcsIEhPVkVSX1NUQVRFX05PUk1BTCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNpbmdsZUVudGVyU2VsZWN0KGVsKSB7XG4gIGVsLnNlbGVjdGVkID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNpbmdsZUxlYXZlU2VsZWN0KGVsKSB7XG4gIGVsLnNlbGVjdGVkID0gZmFsc2U7XG59XG5mdW5jdGlvbiB1cGRhdGVFbGVtZW50U3RhdGUoZWwsIHVwZGF0ZXIsIGNvbW1vblBhcmFtKSB7XG4gIHVwZGF0ZXIoZWwsIGNvbW1vblBhcmFtKTtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlVXBkYXRlU3RhdGUoZWwsIHVwZGF0ZXIsIGNvbW1vblBhcmFtKSB7XG4gIHVwZGF0ZUVsZW1lbnRTdGF0ZShlbCwgdXBkYXRlciwgY29tbW9uUGFyYW0pO1xuICBlbC5pc0dyb3VwICYmIGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHVwZGF0ZUVsZW1lbnRTdGF0ZShjaGlsZCwgdXBkYXRlciwgY29tbW9uUGFyYW0pO1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRTdGF0ZXNGbGFnKGVsLCBzdGF0ZU5hbWUpIHtcbiAgc3dpdGNoIChzdGF0ZU5hbWUpIHtcbiAgICBjYXNlICdlbXBoYXNpcyc6XG4gICAgICBlbC5ob3ZlclN0YXRlID0gSE9WRVJfU1RBVEVfRU1QSEFTSVM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdub3JtYWwnOlxuICAgICAgZWwuaG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX05PUk1BTDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JsdXInOlxuICAgICAgZWwuaG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX0JMVVI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgZWwuc2VsZWN0ZWQgPSB0cnVlO1xuICB9XG59XG4vKipcclxuICogSWYgd2UgcmV1c2UgZWxlbWVudHMgd2hlbiByZXJlbmRlci5cclxuICogRE9OJ1QgZm9yZ2V0IHRvIGNsZWFyU3RhdGVzIGJlZm9yZSB3ZSB1cGRhdGUgdGhlIHN0eWxlIGFuZCBzaGFwZS5cclxuICogT3Igd2UgbWF5IHVwZGF0ZSBvbiB0aGUgd3Jvbmcgc3RhdGUgaW5zdGVhZCBvZiBub3JtYWwgc3RhdGUuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyU3RhdGVzKGVsKSB7XG4gIGlmIChlbC5pc0dyb3VwKSB7XG4gICAgZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBjaGlsZC5jbGVhclN0YXRlcygpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGVsLmNsZWFyU3RhdGVzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZyb21TdGF0ZVN0eWxlKGVsLCBwcm9wcywgdG9TdGF0ZU5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgc3R5bGUgPSBlbC5zdHlsZTtcbiAgdmFyIGZyb21TdGF0ZSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gcHJvcHNbaV07XG4gICAgdmFyIHZhbCA9IHN0eWxlW3Byb3BOYW1lXTtcbiAgICBmcm9tU3RhdGVbcHJvcE5hbWVdID0gdmFsID09IG51bGwgPyBkZWZhdWx0VmFsdWUgJiYgZGVmYXVsdFZhbHVlW3Byb3BOYW1lXSA6IHZhbDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsLmFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhbmltYXRvciA9IGVsLmFuaW1hdG9yc1tpXTtcbiAgICBpZiAoYW5pbWF0b3IuX19mcm9tU3RhdGVUcmFuc2l0aW9uXG4gICAgLy8gRG9uJ3QgY29uc2lkZXIgdGhlIGFuaW1hdGlvbiB0byBlbXBoYXNpcyBzdGF0ZS5cbiAgICAmJiBhbmltYXRvci5fX2Zyb21TdGF0ZVRyYW5zaXRpb24uaW5kZXhPZih0b1N0YXRlTmFtZSkgPCAwICYmIGFuaW1hdG9yLnRhcmdldE5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgIGFuaW1hdG9yLnNhdmVUbyhmcm9tU3RhdGUsIHByb3BzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyb21TdGF0ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcGhhc2lzRGVmYXVsdFN0YXRlKGVsLCBzdGF0ZU5hbWUsIHRhcmdldFN0YXRlcywgc3RhdGUpIHtcbiAgdmFyIGhhc1NlbGVjdCA9IHRhcmdldFN0YXRlcyAmJiBpbmRleE9mKHRhcmdldFN0YXRlcywgJ3NlbGVjdCcpID49IDA7XG4gIHZhciBjbG9uZWQgPSBmYWxzZTtcbiAgaWYgKGVsIGluc3RhbmNlb2YgUGF0aCkge1xuICAgIHZhciBzdG9yZSA9IGdldFNhdmVkU3RhdGVzKGVsKTtcbiAgICB2YXIgZnJvbUZpbGwgPSBoYXNTZWxlY3QgPyBzdG9yZS5zZWxlY3RGaWxsIHx8IHN0b3JlLm5vcm1hbEZpbGwgOiBzdG9yZS5ub3JtYWxGaWxsO1xuICAgIHZhciBmcm9tU3Ryb2tlID0gaGFzU2VsZWN0ID8gc3RvcmUuc2VsZWN0U3Ryb2tlIHx8IHN0b3JlLm5vcm1hbFN0cm9rZSA6IHN0b3JlLm5vcm1hbFN0cm9rZTtcbiAgICBpZiAoaGFzRmlsbE9yU3Ryb2tlKGZyb21GaWxsKSB8fCBoYXNGaWxsT3JTdHJva2UoZnJvbVN0cm9rZSkpIHtcbiAgICAgIHN0YXRlID0gc3RhdGUgfHwge307XG4gICAgICB2YXIgZW1waGFzaXNTdHlsZSA9IHN0YXRlLnN0eWxlIHx8IHt9O1xuICAgICAgLy8gaW5oZXJpdCBjYXNlXG4gICAgICBpZiAoZW1waGFzaXNTdHlsZS5maWxsID09PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgY2xvbmVkID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUgPSBleHRlbmQoe30sIHN0YXRlKTtcbiAgICAgICAgZW1waGFzaXNTdHlsZSA9IGV4dGVuZCh7fSwgZW1waGFzaXNTdHlsZSk7XG4gICAgICAgIGVtcGhhc2lzU3R5bGUuZmlsbCA9IGZyb21GaWxsO1xuICAgICAgfVxuICAgICAgLy8gQXBwbHkgZGVmYXVsdCBjb2xvciBsaWZ0XG4gICAgICBlbHNlIGlmICghaGFzRmlsbE9yU3Ryb2tlKGVtcGhhc2lzU3R5bGUuZmlsbCkgJiYgaGFzRmlsbE9yU3Ryb2tlKGZyb21GaWxsKSkge1xuICAgICAgICBjbG9uZWQgPSB0cnVlO1xuICAgICAgICAvLyBOb3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgICAgc3RhdGUgPSBleHRlbmQoe30sIHN0YXRlKTtcbiAgICAgICAgZW1waGFzaXNTdHlsZSA9IGV4dGVuZCh7fSwgZW1waGFzaXNTdHlsZSk7XG4gICAgICAgIC8vIEFscmVhZHkgYmVpbmcgYXBwbGllZCAnZW1waGFzaXMnLiBET04nVCBsaWZ0IGNvbG9yIG11bHRpcGxlIHRpbWVzLlxuICAgICAgICBlbXBoYXNpc1N0eWxlLmZpbGwgPSBsaWZ0Q29sb3IoZnJvbUZpbGwpO1xuICAgICAgfVxuICAgICAgLy8gTm90IGhpZ2hsaWdodCBzdHJva2UgaWYgZmlsbCBoYXMgYmVlbiBoaWdobGlnaHRlZC5cbiAgICAgIGVsc2UgaWYgKCFoYXNGaWxsT3JTdHJva2UoZW1waGFzaXNTdHlsZS5zdHJva2UpICYmIGhhc0ZpbGxPclN0cm9rZShmcm9tU3Ryb2tlKSkge1xuICAgICAgICBpZiAoIWNsb25lZCkge1xuICAgICAgICAgIHN0YXRlID0gZXh0ZW5kKHt9LCBzdGF0ZSk7XG4gICAgICAgICAgZW1waGFzaXNTdHlsZSA9IGV4dGVuZCh7fSwgZW1waGFzaXNTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZW1waGFzaXNTdHlsZS5zdHJva2UgPSBsaWZ0Q29sb3IoZnJvbVN0cm9rZSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5zdHlsZSA9IGVtcGhhc2lzU3R5bGU7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0ZSkge1xuICAgIC8vIFRPRE8gU2hhcmUgd2l0aCB0ZXh0Q29udGVudD9cbiAgICBpZiAoc3RhdGUuejIgPT0gbnVsbCkge1xuICAgICAgaWYgKCFjbG9uZWQpIHtcbiAgICAgICAgc3RhdGUgPSBleHRlbmQoe30sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHZhciB6MkVtcGhhc2lzTGlmdCA9IGVsLnoyRW1waGFzaXNMaWZ0O1xuICAgICAgc3RhdGUuejIgPSBlbC56MiArICh6MkVtcGhhc2lzTGlmdCAhPSBudWxsID8gejJFbXBoYXNpc0xpZnQgOiBaMl9FTVBIQVNJU19MSUZUKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VsZWN0RGVmYXVsdFN0YXRlKGVsLCBzdGF0ZU5hbWUsIHN0YXRlKSB7XG4gIC8vIGNvbnN0IGhhc1NlbGVjdCA9IGluZGV4T2YoZWwuY3VycmVudFN0YXRlcywgc3RhdGVOYW1lKSA+PSAwO1xuICBpZiAoc3RhdGUpIHtcbiAgICAvLyBUT0RPIFNoYXJlIHdpdGggdGV4dENvbnRlbnQ/XG4gICAgaWYgKHN0YXRlLnoyID09IG51bGwpIHtcbiAgICAgIHN0YXRlID0gZXh0ZW5kKHt9LCBzdGF0ZSk7XG4gICAgICB2YXIgejJTZWxlY3RMaWZ0ID0gZWwuejJTZWxlY3RMaWZ0O1xuICAgICAgc3RhdGUuejIgPSBlbC56MiArICh6MlNlbGVjdExpZnQgIT0gbnVsbCA/IHoyU2VsZWN0TGlmdCA6IFoyX1NFTEVDVF9MSUZUKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gY3JlYXRlQmx1ckRlZmF1bHRTdGF0ZShlbCwgc3RhdGVOYW1lLCBzdGF0ZSkge1xuICB2YXIgaGFzQmx1ciA9IGluZGV4T2YoZWwuY3VycmVudFN0YXRlcywgc3RhdGVOYW1lKSA+PSAwO1xuICB2YXIgY3VycmVudE9wYWNpdHkgPSBlbC5zdHlsZS5vcGFjaXR5O1xuICB2YXIgZnJvbVN0YXRlID0gIWhhc0JsdXIgPyBnZXRGcm9tU3RhdGVTdHlsZShlbCwgWydvcGFjaXR5J10sIHN0YXRlTmFtZSwge1xuICAgIG9wYWNpdHk6IDFcbiAgfSkgOiBudWxsO1xuICBzdGF0ZSA9IHN0YXRlIHx8IHt9O1xuICB2YXIgYmx1clN0eWxlID0gc3RhdGUuc3R5bGUgfHwge307XG4gIGlmIChibHVyU3R5bGUub3BhY2l0eSA9PSBudWxsKSB7XG4gICAgLy8gY2xvbmUgc3RhdGVcbiAgICBzdGF0ZSA9IGV4dGVuZCh7fSwgc3RhdGUpO1xuICAgIGJsdXJTdHlsZSA9IGV4dGVuZCh7XG4gICAgICAvLyBBbHJlYWR5IGJlaW5nIGFwcGxpZWQgJ2VtcGhhc2lzJy4gRE9OJ1QgbXVsIG9wYWNpdHkgbXVsdGlwbGUgdGltZXMuXG4gICAgICBvcGFjaXR5OiBoYXNCbHVyID8gY3VycmVudE9wYWNpdHkgOiBmcm9tU3RhdGUub3BhY2l0eSAqIDAuMVxuICAgIH0sIGJsdXJTdHlsZSk7XG4gICAgc3RhdGUuc3R5bGUgPSBibHVyU3R5bGU7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gZWxlbWVudFN0YXRlUHJveHkoc3RhdGVOYW1lLCB0YXJnZXRTdGF0ZXMpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZXNbc3RhdGVOYW1lXTtcbiAgaWYgKHRoaXMuc3R5bGUpIHtcbiAgICBpZiAoc3RhdGVOYW1lID09PSAnZW1waGFzaXMnKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRW1waGFzaXNEZWZhdWx0U3RhdGUodGhpcywgc3RhdGVOYW1lLCB0YXJnZXRTdGF0ZXMsIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlTmFtZSA9PT0gJ2JsdXInKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQmx1ckRlZmF1bHRTdGF0ZSh0aGlzLCBzdGF0ZU5hbWUsIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlTmFtZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybiBjcmVhdGVTZWxlY3REZWZhdWx0U3RhdGUodGhpcywgc3RhdGVOYW1lLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbi8qKlxyXG4gKiBTZXQgaG92ZXIgc3R5bGUgKG5hbWVseSBcImVtcGhhc2lzIHN0eWxlXCIpIG9mIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSBlbCBTaG91bGQgbm90IGJlIGB6cmVuZGVyL2dyYXBoaWMvR3JvdXBgLlxyXG4gKiBAcGFyYW0gZm9jdXMgJ3NlbGYnIHwgJ3NlbGZJblNlcmllcycgfCAnc2VyaWVzJ1xyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXREZWZhdWx0U3RhdGVQcm94eShlbCkge1xuICBlbC5zdGF0ZVByb3h5ID0gZWxlbWVudFN0YXRlUHJveHk7XG4gIHZhciB0ZXh0Q29udGVudCA9IGVsLmdldFRleHRDb250ZW50KCk7XG4gIHZhciB0ZXh0R3VpZGUgPSBlbC5nZXRUZXh0R3VpZGVMaW5lKCk7XG4gIGlmICh0ZXh0Q29udGVudCkge1xuICAgIHRleHRDb250ZW50LnN0YXRlUHJveHkgPSBlbGVtZW50U3RhdGVQcm94eTtcbiAgfVxuICBpZiAodGV4dEd1aWRlKSB7XG4gICAgdGV4dEd1aWRlLnN0YXRlUHJveHkgPSBlbGVtZW50U3RhdGVQcm94eTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGVudGVyRW1waGFzaXNXaGVuTW91c2VPdmVyKGVsLCBlKSB7XG4gICFzaG91bGRTaWxlbnQoZWwsIGUpXG4gIC8vIFwiZW1waGFzaXNcIiBldmVudCBoaWdobGlnaHQgaGFzIGhpZ2hlciBwcmlvcml0eSB0aGFuIG1vdXNlIGhpZ2hsaWdodC5cbiAgJiYgIWVsLl9faGlnaEJ5T3V0ZXIgJiYgdHJhdmVyc2VVcGRhdGVTdGF0ZShlbCwgc2luZ2xlRW50ZXJFbXBoYXNpcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gbGVhdmVFbXBoYXNpc1doZW5Nb3VzZU91dChlbCwgZSkge1xuICAhc2hvdWxkU2lsZW50KGVsLCBlKVxuICAvLyBcImVtcGhhc2lzXCIgZXZlbnQgaGlnaGxpZ2h0IGhhcyBoaWdoZXIgcHJpb3JpdHkgdGhhbiBtb3VzZSBoaWdobGlnaHQuXG4gICYmICFlbC5fX2hpZ2hCeU91dGVyICYmIHRyYXZlcnNlVXBkYXRlU3RhdGUoZWwsIHNpbmdsZUxlYXZlRW1waGFzaXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVudGVyRW1waGFzaXMoZWwsIGhpZ2hsaWdodERpZ2l0KSB7XG4gIGVsLl9faGlnaEJ5T3V0ZXIgfD0gMSA8PCAoaGlnaGxpZ2h0RGlnaXQgfHwgMCk7XG4gIHRyYXZlcnNlVXBkYXRlU3RhdGUoZWwsIHNpbmdsZUVudGVyRW1waGFzaXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxlYXZlRW1waGFzaXMoZWwsIGhpZ2hsaWdodERpZ2l0KSB7XG4gICEoZWwuX19oaWdoQnlPdXRlciAmPSB+KDEgPDwgKGhpZ2hsaWdodERpZ2l0IHx8IDApKSkgJiYgdHJhdmVyc2VVcGRhdGVTdGF0ZShlbCwgc2luZ2xlTGVhdmVFbXBoYXNpcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW50ZXJCbHVyKGVsKSB7XG4gIHRyYXZlcnNlVXBkYXRlU3RhdGUoZWwsIHNpbmdsZUVudGVyQmx1cik7XG59XG5leHBvcnQgZnVuY3Rpb24gbGVhdmVCbHVyKGVsKSB7XG4gIHRyYXZlcnNlVXBkYXRlU3RhdGUoZWwsIHNpbmdsZUxlYXZlQmx1cik7XG59XG5leHBvcnQgZnVuY3Rpb24gZW50ZXJTZWxlY3QoZWwpIHtcbiAgdHJhdmVyc2VVcGRhdGVTdGF0ZShlbCwgc2luZ2xlRW50ZXJTZWxlY3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxlYXZlU2VsZWN0KGVsKSB7XG4gIHRyYXZlcnNlVXBkYXRlU3RhdGUoZWwsIHNpbmdsZUxlYXZlU2VsZWN0KTtcbn1cbmZ1bmN0aW9uIHNob3VsZFNpbGVudChlbCwgZSkge1xuICByZXR1cm4gZWwuX19oaWdoRG93blNpbGVudE9uVG91Y2ggJiYgZS56ckJ5VG91Y2g7XG59XG5leHBvcnQgZnVuY3Rpb24gYWxsTGVhdmVCbHVyKGFwaSkge1xuICB2YXIgbW9kZWwgPSBhcGkuZ2V0TW9kZWwoKTtcbiAgdmFyIGxlYXZlQmx1cnJlZFNlcmllcyA9IFtdO1xuICB2YXIgYWxsQ29tcG9uZW50Vmlld3MgPSBbXTtcbiAgbW9kZWwuZWFjaENvbXBvbmVudChmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgY29tcG9uZW50TW9kZWwpIHtcbiAgICB2YXIgY29tcG9uZW50U3RhdGVzID0gZ2V0Q29tcG9uZW50U3RhdGVzKGNvbXBvbmVudE1vZGVsKTtcbiAgICB2YXIgaXNTZXJpZXMgPSBjb21wb25lbnRUeXBlID09PSAnc2VyaWVzJztcbiAgICB2YXIgdmlldyA9IGlzU2VyaWVzID8gYXBpLmdldFZpZXdPZlNlcmllc01vZGVsKGNvbXBvbmVudE1vZGVsKSA6IGFwaS5nZXRWaWV3T2ZDb21wb25lbnRNb2RlbChjb21wb25lbnRNb2RlbCk7XG4gICAgIWlzU2VyaWVzICYmIGFsbENvbXBvbmVudFZpZXdzLnB1c2godmlldyk7XG4gICAgaWYgKGNvbXBvbmVudFN0YXRlcy5pc0JsdXJlZCkge1xuICAgICAgLy8gTGVhdmUgYmx1ciBhbnl3YXlcbiAgICAgIHZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHNpbmdsZUxlYXZlQmx1cihjaGlsZCk7XG4gICAgICB9KTtcbiAgICAgIGlzU2VyaWVzICYmIGxlYXZlQmx1cnJlZFNlcmllcy5wdXNoKGNvbXBvbmVudE1vZGVsKTtcbiAgICB9XG4gICAgY29tcG9uZW50U3RhdGVzLmlzQmx1cmVkID0gZmFsc2U7XG4gIH0pO1xuICBlYWNoKGFsbENvbXBvbmVudFZpZXdzLCBmdW5jdGlvbiAodmlldykge1xuICAgIGlmICh2aWV3ICYmIHZpZXcudG9nZ2xlQmx1clNlcmllcykge1xuICAgICAgdmlldy50b2dnbGVCbHVyU2VyaWVzKGxlYXZlQmx1cnJlZFNlcmllcywgZmFsc2UsIG1vZGVsKTtcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJsdXJTZXJpZXModGFyZ2V0U2VyaWVzSW5kZXgsIGZvY3VzLCBibHVyU2NvcGUsIGFwaSkge1xuICB2YXIgZWNNb2RlbCA9IGFwaS5nZXRNb2RlbCgpO1xuICBibHVyU2NvcGUgPSBibHVyU2NvcGUgfHwgJ2Nvb3JkaW5hdGVTeXN0ZW0nO1xuICBmdW5jdGlvbiBsZWF2ZUJsdXJPZkluZGljZXMoZGF0YSwgZGF0YUluZGljZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbUVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRpY2VzW2ldKTtcbiAgICAgIGl0ZW1FbCAmJiBsZWF2ZUJsdXIoaXRlbUVsKTtcbiAgICB9XG4gIH1cbiAgaWYgKHRhcmdldFNlcmllc0luZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFmb2N1cyB8fCBmb2N1cyA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0YXJnZXRTZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleCh0YXJnZXRTZXJpZXNJbmRleCk7XG4gIHZhciB0YXJnZXRDb29yZFN5cyA9IHRhcmdldFNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gIGlmICh0YXJnZXRDb29yZFN5cyAmJiB0YXJnZXRDb29yZFN5cy5tYXN0ZXIpIHtcbiAgICB0YXJnZXRDb29yZFN5cyA9IHRhcmdldENvb3JkU3lzLm1hc3RlcjtcbiAgfVxuICB2YXIgYmx1cnJlZFNlcmllcyA9IFtdO1xuICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIHNhbWVTZXJpZXMgPSB0YXJnZXRTZXJpZXNNb2RlbCA9PT0gc2VyaWVzTW9kZWw7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMubWFzdGVyKSB7XG4gICAgICBjb29yZFN5cyA9IGNvb3JkU3lzLm1hc3RlcjtcbiAgICB9XG4gICAgdmFyIHNhbWVDb29yZFN5cyA9IGNvb3JkU3lzICYmIHRhcmdldENvb3JkU3lzID8gY29vcmRTeXMgPT09IHRhcmdldENvb3JkU3lzIDogc2FtZVNlcmllczsgLy8gSWYgdGhlcmUgaXMgbm8gY29vcmRpbmF0ZSBzeXN0ZW0uIHVzZSBzYW1lU2VyaWVzIGluc3RlYWQuXG4gICAgaWYgKCEoXG4gICAgLy8gTm90IGJsdXIgb3RoZXIgc2VyaWVzIGlmIGJsdXJTY29wZSBzZXJpZXNcbiAgICBibHVyU2NvcGUgPT09ICdzZXJpZXMnICYmICFzYW1lU2VyaWVzXG4gICAgLy8gTm90IGJsdXIgb3RoZXIgY29vcmRpbmF0ZSBzeXN0ZW0gaWYgYmx1clNjb3BlIGlzIGNvb3JkaW5hdGVTeXN0ZW1cbiAgICB8fCBibHVyU2NvcGUgPT09ICdjb29yZGluYXRlU3lzdGVtJyAmJiAhc2FtZUNvb3JkU3lzXG4gICAgLy8gTm90IGJsdXIgc2VsZiBzZXJpZXMgaWYgZm9jdXMgaXMgc2VyaWVzLlxuICAgIHx8IGZvY3VzID09PSAnc2VyaWVzJyAmJiBzYW1lU2VyaWVzXG4gICAgLy8gVE9ETyBibHVyU2NvcGU6IGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgKSkge1xuICAgICAgdmFyIHZpZXcgPSBhcGkuZ2V0Vmlld09mU2VyaWVzTW9kZWwoc2VyaWVzTW9kZWwpO1xuICAgICAgdmlldy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgLy8gRm9yIHRoZSBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiB0cmlnZ2VyZWQgYnkgb3RoZXIgY29tcG9uZW50cyxcbiAgICAgICAgLy8gYW5kIGFyZSBzdGlsbCByZXF1aXJlZCB0byBiZSBoaWdobGlnaHRlZCxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgY3VycmVudCBpcyBkaXJlY3RseSBmb3JjZWQgdG8gYmx1ciB0aGUgZWxlbWVudCxcbiAgICAgICAgLy8gaXQgd2lsbCBjYXVzZSB0aGUgZm9jdXMgc2VsZiB0byBiZSB1bmFibGUgdG8gaGlnaGxpZ2h0LCBzbyBza2lwIHRoZSBibHVyIG9mIHRoaXMgZWxlbWVudC5cbiAgICAgICAgaWYgKGNoaWxkLl9faGlnaEJ5T3V0ZXIgJiYgc2FtZVNlcmllcyAmJiBmb2N1cyA9PT0gJ3NlbGYnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNpbmdsZUVudGVyQmx1cihjaGlsZCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpc0FycmF5TGlrZShmb2N1cykpIHtcbiAgICAgICAgbGVhdmVCbHVyT2ZJbmRpY2VzKHNlcmllc01vZGVsLmdldERhdGEoKSwgZm9jdXMpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChmb2N1cykpIHtcbiAgICAgICAgdmFyIGRhdGFUeXBlcyA9IGtleXMoZm9jdXMpO1xuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRhdGFUeXBlcy5sZW5ndGg7IGQrKykge1xuICAgICAgICAgIGxlYXZlQmx1ck9mSW5kaWNlcyhzZXJpZXNNb2RlbC5nZXREYXRhKGRhdGFUeXBlc1tkXSksIGZvY3VzW2RhdGFUeXBlc1tkXV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBibHVycmVkU2VyaWVzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgICAgZ2V0Q29tcG9uZW50U3RhdGVzKHNlcmllc01vZGVsKS5pc0JsdXJlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBjb21wb25lbnRNb2RlbCkge1xuICAgIGlmIChjb21wb25lbnRUeXBlID09PSAnc2VyaWVzJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmlldyA9IGFwaS5nZXRWaWV3T2ZDb21wb25lbnRNb2RlbChjb21wb25lbnRNb2RlbCk7XG4gICAgaWYgKHZpZXcgJiYgdmlldy50b2dnbGVCbHVyU2VyaWVzKSB7XG4gICAgICB2aWV3LnRvZ2dsZUJsdXJTZXJpZXMoYmx1cnJlZFNlcmllcywgdHJ1ZSwgZWNNb2RlbCk7XG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBibHVyQ29tcG9uZW50KGNvbXBvbmVudE1haW5UeXBlLCBjb21wb25lbnRJbmRleCwgYXBpKSB7XG4gIGlmIChjb21wb25lbnRNYWluVHlwZSA9PSBudWxsIHx8IGNvbXBvbmVudEluZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNvbXBvbmVudE1vZGVsID0gYXBpLmdldE1vZGVsKCkuZ2V0Q29tcG9uZW50KGNvbXBvbmVudE1haW5UeXBlLCBjb21wb25lbnRJbmRleCk7XG4gIGlmICghY29tcG9uZW50TW9kZWwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZ2V0Q29tcG9uZW50U3RhdGVzKGNvbXBvbmVudE1vZGVsKS5pc0JsdXJlZCA9IHRydWU7XG4gIHZhciB2aWV3ID0gYXBpLmdldFZpZXdPZkNvbXBvbmVudE1vZGVsKGNvbXBvbmVudE1vZGVsKTtcbiAgaWYgKCF2aWV3IHx8ICF2aWV3LmZvY3VzQmx1ckVuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmlldy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBzaW5nbGVFbnRlckJsdXIoY2hpbGQpO1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBibHVyU2VyaWVzRnJvbUhpZ2hsaWdodFBheWxvYWQoc2VyaWVzTW9kZWwsIHBheWxvYWQsIGFwaSkge1xuICB2YXIgc2VyaWVzSW5kZXggPSBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleDtcbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKHBheWxvYWQuZGF0YVR5cGUpO1xuICBpZiAoIWRhdGEpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZXJyb3IoXCJVbmtub3duIGRhdGFUeXBlIFwiICsgcGF5bG9hZC5kYXRhVHlwZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZGF0YUluZGV4ID0gcXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG4gIC8vIFBpY2sgdGhlIGZpcnN0IG9uZSBpZiB0aGVyZSBpcyBtdWx0aXBsZS9ub25lIGV4aXN0cy5cbiAgZGF0YUluZGV4ID0gKGlzQXJyYXkoZGF0YUluZGV4KSA/IGRhdGFJbmRleFswXSA6IGRhdGFJbmRleCkgfHwgMDtcbiAgdmFyIGVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCk7XG4gIGlmICghZWwpIHtcbiAgICB2YXIgY291bnQgPSBkYXRhLmNvdW50KCk7XG4gICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgIC8vIElmIGRhdGEgb24gZGF0YUluZGV4IGlzIE5hTi5cbiAgICB3aGlsZSAoIWVsICYmIGN1cnJlbnQgPCBjb3VudCkge1xuICAgICAgZWwgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoY3VycmVudCsrKTtcbiAgICB9XG4gIH1cbiAgaWYgKGVsKSB7XG4gICAgdmFyIGVjRGF0YSA9IGdldEVDRGF0YShlbCk7XG4gICAgYmx1clNlcmllcyhzZXJpZXNJbmRleCwgZWNEYXRhLmZvY3VzLCBlY0RhdGEuYmx1clNjb3BlLCBhcGkpO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGVsZW1lbnQgcHV0IG9uIHRoZSBkYXRhLiBUcnkgZ2V0dGluZyBpdCBmcm9tIHJhdyBvcHRpb25cbiAgICAvLyBUT0RPIFNob3VsZCBwdXQgaXQgb24gc2VyaWVzTW9kZWw/XG4gICAgdmFyIGZvY3VzXzEgPSBzZXJpZXNNb2RlbC5nZXQoWydlbXBoYXNpcycsICdmb2N1cyddKTtcbiAgICB2YXIgYmx1clNjb3BlID0gc2VyaWVzTW9kZWwuZ2V0KFsnZW1waGFzaXMnLCAnYmx1clNjb3BlJ10pO1xuICAgIGlmIChmb2N1c18xICE9IG51bGwpIHtcbiAgICAgIGJsdXJTZXJpZXMoc2VyaWVzSW5kZXgsIGZvY3VzXzEsIGJsdXJTY29wZSwgYXBpKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ29tcG9uZW50SGlnaERvd25EaXNwYXRjaGVycyhjb21wb25lbnRNYWluVHlwZSwgY29tcG9uZW50SW5kZXgsIG5hbWUsIGFwaSkge1xuICB2YXIgcmV0ID0ge1xuICAgIGZvY3VzU2VsZjogZmFsc2UsXG4gICAgZGlzcGF0Y2hlcnM6IG51bGxcbiAgfTtcbiAgaWYgKGNvbXBvbmVudE1haW5UeXBlID09IG51bGwgfHwgY29tcG9uZW50TWFpblR5cGUgPT09ICdzZXJpZXMnIHx8IGNvbXBvbmVudEluZGV4ID09IG51bGwgfHwgbmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICB2YXIgY29tcG9uZW50TW9kZWwgPSBhcGkuZ2V0TW9kZWwoKS5nZXRDb21wb25lbnQoY29tcG9uZW50TWFpblR5cGUsIGNvbXBvbmVudEluZGV4KTtcbiAgaWYgKCFjb21wb25lbnRNb2RlbCkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgdmFyIHZpZXcgPSBhcGkuZ2V0Vmlld09mQ29tcG9uZW50TW9kZWwoY29tcG9uZW50TW9kZWwpO1xuICBpZiAoIXZpZXcgfHwgIXZpZXcuZmluZEhpZ2hEb3duRGlzcGF0Y2hlcnMpIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHZhciBkaXNwYXRjaGVycyA9IHZpZXcuZmluZEhpZ2hEb3duRGlzcGF0Y2hlcnMobmFtZSk7XG4gIC8vIEF0IHByZXNuZXQsIHRoZSBjb21wb25lbnQgKGxpa2UgR2VvKSBvbmx5IGJsdXIgaW5zaWRlIGl0c2VsZi5cbiAgLy8gU28gd2UgZG8gbm90IHVzZSBgYmx1clNjb3BlYCBpbiBjb21wb25lbnQuXG4gIHZhciBmb2N1c1NlbGY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNIaWdoRG93bkRpc3BhdGNoZXIoZGlzcGF0Y2hlcnNbaV0pKSB7XG4gICAgICBlcnJvcigncGFyYW0gc2hvdWxkIGJlIGhpZ2hEb3duRGlzcGF0Y2hlcicpO1xuICAgIH1cbiAgICBpZiAoZ2V0RUNEYXRhKGRpc3BhdGNoZXJzW2ldKS5mb2N1cyA9PT0gJ3NlbGYnKSB7XG4gICAgICBmb2N1c1NlbGYgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZm9jdXNTZWxmOiBmb2N1c1NlbGYsXG4gICAgZGlzcGF0Y2hlcnM6IGRpc3BhdGNoZXJzXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlR2xvYmFsTW91c2VPdmVyRm9ySGlnaERvd24oZGlzcGF0Y2hlciwgZSwgYXBpKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc0hpZ2hEb3duRGlzcGF0Y2hlcihkaXNwYXRjaGVyKSkge1xuICAgIGVycm9yKCdwYXJhbSBzaG91bGQgYmUgaGlnaERvd25EaXNwYXRjaGVyJyk7XG4gIH1cbiAgdmFyIGVjRGF0YSA9IGdldEVDRGF0YShkaXNwYXRjaGVyKTtcbiAgdmFyIF9hID0gZmluZENvbXBvbmVudEhpZ2hEb3duRGlzcGF0Y2hlcnMoZWNEYXRhLmNvbXBvbmVudE1haW5UeXBlLCBlY0RhdGEuY29tcG9uZW50SW5kZXgsIGVjRGF0YS5jb21wb25lbnRIaWdoRG93bk5hbWUsIGFwaSksXG4gICAgZGlzcGF0Y2hlcnMgPSBfYS5kaXNwYXRjaGVycyxcbiAgICBmb2N1c1NlbGYgPSBfYS5mb2N1c1NlbGY7XG4gIC8vIElmIGBmaW5kSGlnaERvd25EaXNwYXRjaGVyc2AgaXMgc3VwcG9ydGVkIG9uIHRoZSBjb21wb25lbnQsXG4gIC8vIGhpZ2hsaWdodC9kb3ducGxheSBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIG5hbWUuXG4gIGlmIChkaXNwYXRjaGVycykge1xuICAgIGlmIChmb2N1c1NlbGYpIHtcbiAgICAgIGJsdXJDb21wb25lbnQoZWNEYXRhLmNvbXBvbmVudE1haW5UeXBlLCBlY0RhdGEuY29tcG9uZW50SW5kZXgsIGFwaSk7XG4gICAgfVxuICAgIGVhY2goZGlzcGF0Y2hlcnMsIGZ1bmN0aW9uIChkaXNwYXRjaGVyKSB7XG4gICAgICByZXR1cm4gZW50ZXJFbXBoYXNpc1doZW5Nb3VzZU92ZXIoZGlzcGF0Y2hlciwgZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVHJ5IGJsdXIgYWxsIGluIHRoZSByZWxhdGVkIHNlcmllcy4gVGhlbiBlbXBoYXNpcyB0aGUgaG92ZXJyZWQuXG4gICAgLy8gVE9ETy4gcHJvZ3Jlc3NpdmUgbW9kZS5cbiAgICBibHVyU2VyaWVzKGVjRGF0YS5zZXJpZXNJbmRleCwgZWNEYXRhLmZvY3VzLCBlY0RhdGEuYmx1clNjb3BlLCBhcGkpO1xuICAgIGlmIChlY0RhdGEuZm9jdXMgPT09ICdzZWxmJykge1xuICAgICAgYmx1ckNvbXBvbmVudChlY0RhdGEuY29tcG9uZW50TWFpblR5cGUsIGVjRGF0YS5jb21wb25lbnRJbmRleCwgYXBpKTtcbiAgICB9XG4gICAgLy8gT3RoZXIgdGhhbiBzZXJpZXMsIGNvbXBvbmVudCB0aGF0IG5vdCBzdXBwb3J0IGBmaW5kSGlnaERvd25EaXNwYXRjaGVyYCB3aWxsXG4gICAgLy8gYWxzbyB1c2UgaXQuIEJ1dCBpbiB0aGlzIGNhc2UsIGhpZ2hsaWdodC9kb3ducGxheSBhcmUgb25seSBzdXBwb3J0ZWQgaW5cbiAgICAvLyBtb3VzZSBob3ZlciBidXQgbm90IGluIGRpc3BhdGNoQWN0aW9uLlxuICAgIGVudGVyRW1waGFzaXNXaGVuTW91c2VPdmVyKGRpc3BhdGNoZXIsIGUpO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlR2xvYmFsTW91c2VPdXRGb3JIaWdoRG93bihkaXNwYXRjaGVyLCBlLCBhcGkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzSGlnaERvd25EaXNwYXRjaGVyKGRpc3BhdGNoZXIpKSB7XG4gICAgZXJyb3IoJ3BhcmFtIHNob3VsZCBiZSBoaWdoRG93bkRpc3BhdGNoZXInKTtcbiAgfVxuICBhbGxMZWF2ZUJsdXIoYXBpKTtcbiAgdmFyIGVjRGF0YSA9IGdldEVDRGF0YShkaXNwYXRjaGVyKTtcbiAgdmFyIGRpc3BhdGNoZXJzID0gZmluZENvbXBvbmVudEhpZ2hEb3duRGlzcGF0Y2hlcnMoZWNEYXRhLmNvbXBvbmVudE1haW5UeXBlLCBlY0RhdGEuY29tcG9uZW50SW5kZXgsIGVjRGF0YS5jb21wb25lbnRIaWdoRG93bk5hbWUsIGFwaSkuZGlzcGF0Y2hlcnM7XG4gIGlmIChkaXNwYXRjaGVycykge1xuICAgIGVhY2goZGlzcGF0Y2hlcnMsIGZ1bmN0aW9uIChkaXNwYXRjaGVyKSB7XG4gICAgICByZXR1cm4gbGVhdmVFbXBoYXNpc1doZW5Nb3VzZU91dChkaXNwYXRjaGVyLCBlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBsZWF2ZUVtcGhhc2lzV2hlbk1vdXNlT3V0KGRpc3BhdGNoZXIsIGUpO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlU2VsZWN0aW9uRnJvbVBheWxvYWQoc2VyaWVzTW9kZWwsIHBheWxvYWQsIGFwaSkge1xuICBpZiAoIWlzU2VsZWN0Q2hhbmdlUGF5bG9hZChwYXlsb2FkKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZGF0YVR5cGUgPSBwYXlsb2FkLmRhdGFUeXBlO1xuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoZGF0YVR5cGUpO1xuICB2YXIgZGF0YUluZGV4ID0gcXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG4gIGlmICghaXNBcnJheShkYXRhSW5kZXgpKSB7XG4gICAgZGF0YUluZGV4ID0gW2RhdGFJbmRleF07XG4gIH1cbiAgc2VyaWVzTW9kZWxbcGF5bG9hZC50eXBlID09PSBUT0dHTEVfU0VMRUNUX0FDVElPTl9UWVBFID8gJ3RvZ2dsZVNlbGVjdCcgOiBwYXlsb2FkLnR5cGUgPT09IFNFTEVDVF9BQ1RJT05fVFlQRSA/ICdzZWxlY3QnIDogJ3Vuc2VsZWN0J10oZGF0YUluZGV4LCBkYXRhVHlwZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlU2VyaWVzRWxlbWVudFNlbGVjdGlvbihzZXJpZXNNb2RlbCkge1xuICB2YXIgYWxsRGF0YSA9IHNlcmllc01vZGVsLmdldEFsbERhdGEoKTtcbiAgZWFjaChhbGxEYXRhLCBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZGF0YSA9IF9hLmRhdGEsXG4gICAgICB0eXBlID0gX2EudHlwZTtcbiAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICBzZXJpZXNNb2RlbC5pc1NlbGVjdGVkKGlkeCwgdHlwZSkgPyBlbnRlclNlbGVjdChlbCkgOiBsZWF2ZVNlbGVjdChlbCk7XG4gICAgfSk7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFNlbGVjdGVkSW5kaWNlcyhlY01vZGVsKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBhbGxEYXRhID0gc2VyaWVzTW9kZWwuZ2V0QWxsRGF0YSgpO1xuICAgIGVhY2goYWxsRGF0YSwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgZGF0YSA9IF9hLmRhdGEsXG4gICAgICAgIHR5cGUgPSBfYS50eXBlO1xuICAgICAgdmFyIGRhdGFJbmRpY2VzID0gc2VyaWVzTW9kZWwuZ2V0U2VsZWN0ZWREYXRhSW5kaWNlcygpO1xuICAgICAgaWYgKGRhdGFJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgZGF0YUluZGV4OiBkYXRhSW5kaWNlcyxcbiAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgIGl0ZW0uZGF0YVR5cGUgPSB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cbi8qKlxyXG4gKiBFbmFibGUgdGhlIGZ1bmN0aW9uIHRoYXQgbW91c2VvdmVyIHdpbGwgdHJpZ2dlciB0aGUgZW1waGFzaXMgc3RhdGUuXHJcbiAqXHJcbiAqIE5PVEU6XHJcbiAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQgb24gdGhlIGVsZW1lbnQgd2l0aCBkYXRhSW5kZXgsIHNlcmllc0luZGV4LlxyXG4gKlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVIb3ZlckVtcGhhc2lzKGVsLCBmb2N1cywgYmx1clNjb3BlKSB7XG4gIHNldEFzSGlnaERvd25EaXNwYXRjaGVyKGVsLCB0cnVlKTtcbiAgdHJhdmVyc2VVcGRhdGVTdGF0ZShlbCwgc2V0RGVmYXVsdFN0YXRlUHJveHkpO1xuICBlbmFibGVIb3ZlckZvY3VzKGVsLCBmb2N1cywgYmx1clNjb3BlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlSG92ZXJFbXBoYXNpcyhlbCkge1xuICBzZXRBc0hpZ2hEb3duRGlzcGF0Y2hlcihlbCwgZmFsc2UpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZUhvdmVyRW1waGFzaXMoZWwsIGZvY3VzLCBibHVyU2NvcGUsIGlzRGlzYWJsZWQpIHtcbiAgaXNEaXNhYmxlZCA/IGRpc2FibGVIb3ZlckVtcGhhc2lzKGVsKSA6IGVuYWJsZUhvdmVyRW1waGFzaXMoZWwsIGZvY3VzLCBibHVyU2NvcGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUhvdmVyRm9jdXMoZWwsIGZvY3VzLCBibHVyU2NvcGUpIHtcbiAgdmFyIGVjRGF0YSA9IGdldEVDRGF0YShlbCk7XG4gIGlmIChmb2N1cyAhPSBudWxsKSB7XG4gICAgLy8gVE9ETyBkYXRhSW5kZXggbWF5IGJlIHNldCBhZnRlciB0aGlzIGZ1bmN0aW9uLiBUaGlzIGNoZWNrIGlzIG5vdCB1c2VmdWwuXG4gICAgLy8gaWYgKGVjRGF0YS5kYXRhSW5kZXggPT0gbnVsbCkge1xuICAgIC8vICAgICBpZiAoX19ERVZfXykge1xuICAgIC8vICAgICAgICAgY29uc29sZS53YXJuKCdmb2N1cyBjYW4gb25seSBiZWVuIHNldCBvbiBlbGVtZW50IHdpdGggZGF0YUluZGV4Jyk7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgLy8gZWxzZSB7XG4gICAgZWNEYXRhLmZvY3VzID0gZm9jdXM7XG4gICAgZWNEYXRhLmJsdXJTY29wZSA9IGJsdXJTY29wZTtcbiAgICAvLyB9XG4gIH0gZWxzZSBpZiAoZWNEYXRhLmZvY3VzKSB7XG4gICAgZWNEYXRhLmZvY3VzID0gbnVsbDtcbiAgfVxufVxudmFyIE9USEVSX1NUQVRFUyA9IFsnZW1waGFzaXMnLCAnYmx1cicsICdzZWxlY3QnXTtcbnZhciBkZWZhdWx0U3R5bGVHZXR0ZXJNYXAgPSB7XG4gIGl0ZW1TdHlsZTogJ2dldEl0ZW1TdHlsZScsXG4gIGxpbmVTdHlsZTogJ2dldExpbmVTdHlsZScsXG4gIGFyZWFTdHlsZTogJ2dldEFyZWFTdHlsZSdcbn07XG4vKipcclxuICogU2V0IGVtcGhhc2lzL2JsdXIvc2VsZWN0ZWQgc3RhdGVzIG9mIGVsZW1lbnQuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChlbCwgaXRlbU1vZGVsLCBzdHlsZVR5cGUsXG4vLyBkZWZhdWx0IGl0ZW1TdHlsZVxuZ2V0dGVyKSB7XG4gIHN0eWxlVHlwZSA9IHN0eWxlVHlwZSB8fCAnaXRlbVN0eWxlJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBPVEhFUl9TVEFURVMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RhdGVOYW1lID0gT1RIRVJfU1RBVEVTW2ldO1xuICAgIHZhciBtb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChbc3RhdGVOYW1lLCBzdHlsZVR5cGVdKTtcbiAgICB2YXIgc3RhdGUgPSBlbC5lbnN1cmVTdGF0ZShzdGF0ZU5hbWUpO1xuICAgIC8vIExldCBpdCB0aHJvdyBlcnJvciBpZiBnZXR0ZXJUeXBlIGlzIG5vdCBmb3VuZC5cbiAgICBzdGF0ZS5zdHlsZSA9IGdldHRlciA/IGdldHRlcihtb2RlbCkgOiBtb2RlbFtkZWZhdWx0U3R5bGVHZXR0ZXJNYXBbc3R5bGVUeXBlXV0oKTtcbiAgfVxufVxuLyoqXHJcbiAqXHJcbiAqIFNldCBlbGVtZW50IGFzIGhpZ2hsaWdodCAvIGRvd25wbGF5IGRpc3BhdGNoZXIuXHJcbiAqIEl0IHdpbGwgYmUgY2hlY2tlZCB3aGVuIGVsZW1lbnQgcmVjZWl2ZWQgbW91c2VvdmVyIGV2ZW50IG9yIGZyb20gaGlnaGxpZ2h0IGFjdGlvbi5cclxuICogSXQncyBpbiBjaGFuZ2Ugb2YgYWxsIGhpZ2hsaWdodC9kb3ducGxheSBiZWhhdmlvciBvZiBpdCdzIGNoaWxkcmVuLlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxcclxuICogQHBhcmFtIGVsLmhpZ2hEb3duU2lsZW50T25Ub3VjaFxyXG4gKiAgICAgICAgSW4gdG91Y2ggZGV2aWNlLCBtb3VzZW92ZXIgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyIG9uIHRvdWNoc3RhcnQgZXZlbnRcclxuICogICAgICAgIChzZWUgbW9kdWxlOnpyZW5kZXIvZG9tL0hhbmRsZXJQcm94eSkuIEJ5IHRoaXMgbWVjaGFuaXNtLCB3ZSBjYW5cclxuICogICAgICAgIGNvbnZlbmllbnRseSB1c2UgaG92ZXJTdHlsZSB3aGVuIHRhcCBvbiB0b3VjaCBzY3JlZW4gd2l0aG91dCBhZGRpdGlvbmFsXHJcbiAqICAgICAgICBjb2RlIGZvciBjb21wYXRpYmlsaXR5LlxyXG4gKiAgICAgICAgQnV0IGlmIHRoZSBjaGFydC9jb21wb25lbnQgaGFzIHNlbGVjdCBmZWF0dXJlLCB3aGljaCB1c3VhbGx5IGFsc28gdXNlXHJcbiAqICAgICAgICBob3ZlclN0eWxlLCB0aGVyZSBtaWdodCBiZSBjb25mbGljdCBiZXR3ZWVuICdzZWxlY3QtaGlnaGxpZ2h0JyBhbmRcclxuICogICAgICAgICdob3Zlci1oaWdobGlnaHQnIGVzcGVjaWFsbHkgd2hlbiByb2FtIGlzIGVuYWJsZWQgKHNlZSBnZW8gZm9yIGV4YW1wbGUpLlxyXG4gKiAgICAgICAgSW4gdGhpcyBjYXNlLCBgaGlnaERvd25TaWxlbnRPblRvdWNoYCBzaG91bGQgYmUgdXNlZCB0byBkaXNhYmxlXHJcbiAqICAgICAgICBob3Zlci1oaWdobGlnaHQgb24gdG91Y2ggZGV2aWNlLlxyXG4gKiBAcGFyYW0gYXNEaXNwYXRjaGVyIElmIGBmYWxzZWAsIGRvIG5vdCBzZXQgYXMgXCJoaWdoRG93bkRpc3BhdGNoZXJcIi5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0QXNIaWdoRG93bkRpc3BhdGNoZXIoZWwsIGFzRGlzcGF0Y2hlcikge1xuICB2YXIgZGlzYWJsZSA9IGFzRGlzcGF0Y2hlciA9PT0gZmFsc2U7XG4gIHZhciBleHRlbmRlZEVsID0gZWw7XG4gIC8vIE1ha2UgYGhpZ2hEb3duU2lsZW50T25Ub3VjaGAgYW5kIGBvblN0YXRlQ2hhbmdlYCBvbmx5IHdvcmsgYWZ0ZXJcbiAgLy8gYHNldEFzSGlnaERvd25EaXNwYXRjaGVyYCBjYWxsZWQuIEF2b2lkIGl0IGlzIG1vZGlmaWVkIGJ5IHVzZXIgdW5leHBlY3RlZGx5LlxuICBpZiAoZWwuaGlnaERvd25TaWxlbnRPblRvdWNoKSB7XG4gICAgZXh0ZW5kZWRFbC5fX2hpZ2hEb3duU2lsZW50T25Ub3VjaCA9IGVsLmhpZ2hEb3duU2lsZW50T25Ub3VjaDtcbiAgfVxuICAvLyBTaW1wbGUgb3B0aW1pemUsIHNpbmNlIHRoaXMgbWV0aG9kIG1pZ2h0IGJlXG4gIC8vIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50cyBvZiBhIGdyb3VwIGluIHNvbWUgY2FzZXMuXG4gIGlmICghZGlzYWJsZSB8fCBleHRlbmRlZEVsLl9faGlnaERvd25EaXNwYXRjaGVyKSB7XG4gICAgLy8gRW1waGFzaXMsIG5vcm1hbCBjYW4gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5IGJ5IEFQSSBvciBvdGhlciBjb21wb25lbnRzIGxpa2UgaG92ZXIgbGluay5cbiAgICAvLyBlbFttZXRob2RdKCdlbXBoYXNpcycsIG9uRWxlbWVudEVtcGhhc2lzRXZlbnQpW21ldGhvZF0oJ25vcm1hbCcsIG9uRWxlbWVudE5vcm1hbEV2ZW50KTtcbiAgICAvLyBBbHNvIGtlZXAgcHJldmlvdXMgcmVjb3JkLlxuICAgIGV4dGVuZGVkRWwuX19oaWdoQnlPdXRlciA9IGV4dGVuZGVkRWwuX19oaWdoQnlPdXRlciB8fCAwO1xuICAgIGV4dGVuZGVkRWwuX19oaWdoRG93bkRpc3BhdGNoZXIgPSAhZGlzYWJsZTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzSGlnaERvd25EaXNwYXRjaGVyKGVsKSB7XG4gIHJldHVybiAhIShlbCAmJiBlbC5fX2hpZ2hEb3duRGlzcGF0Y2hlcik7XG59XG4vKipcclxuICogRW5hYmxlIGNvbXBvbmVudCBoaWdobGlnaHQvZG93bnBsYXkgZmVhdHVyZXM6XHJcbiAqICsgaG92ZXIgbGluayAod2l0aGluIHRoZSBzYW1lIG5hbWUpXHJcbiAqICsgZm9jdXMgYmx1ciBpbiBjb21wb25lbnRcclxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlQ29tcG9uZW50SGlnaERvd25GZWF0dXJlcyhlbCwgY29tcG9uZW50TW9kZWwsIGNvbXBvbmVudEhpZ2hEb3duTmFtZSkge1xuICB2YXIgZWNEYXRhID0gZ2V0RUNEYXRhKGVsKTtcbiAgZWNEYXRhLmNvbXBvbmVudE1haW5UeXBlID0gY29tcG9uZW50TW9kZWwubWFpblR5cGU7XG4gIGVjRGF0YS5jb21wb25lbnRJbmRleCA9IGNvbXBvbmVudE1vZGVsLmNvbXBvbmVudEluZGV4O1xuICBlY0RhdGEuY29tcG9uZW50SGlnaERvd25OYW1lID0gY29tcG9uZW50SGlnaERvd25OYW1lO1xufVxuLyoqXHJcbiAqIFN1cHBvcnQgaGlnaGxpZ2h0L2Rvd25wbGF5IHJlY29yZCBvbiBlYWNoIGVsZW1lbnRzLlxyXG4gKiBGb3IgdGhlIGNhc2U6IGhvdmVyIGhpZ2hsaWdodC9kb3ducGxheSAobGVnZW5kLCB2aXN1YWxNYXAsIC4uLikgYW5kXHJcbiAqIHVzZXIgdHJpZ2dlcmVkIGhpZ2hsaWdodC9kb3ducGxheSBzaG91bGQgbm90IGNvbmZsaWN0LlxyXG4gKiBPbmx5IGFsbCBvZiB0aGUgaGlnaGxpZ2h0RGlnaXQgY2xlYXJlZCwgcmV0dXJuIHRvIG5vcm1hbC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGhpZ2hsaWdodEtleVxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGhpZ2hsaWdodERpZ2l0XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhpZ2hsaWdodERpZ2l0KGhpZ2hsaWdodEtleSkge1xuICB2YXIgaGlnaGxpZ2h0RGlnaXQgPSBfaGlnaGxpZ2h0S2V5TWFwW2hpZ2hsaWdodEtleV07XG4gIGlmIChoaWdobGlnaHREaWdpdCA9PSBudWxsICYmIF9oaWdobGlnaHROZXh0RGlnaXQgPD0gMzIpIHtcbiAgICBoaWdobGlnaHREaWdpdCA9IF9oaWdobGlnaHRLZXlNYXBbaGlnaGxpZ2h0S2V5XSA9IF9oaWdobGlnaHROZXh0RGlnaXQrKztcbiAgfVxuICByZXR1cm4gaGlnaGxpZ2h0RGlnaXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTZWxlY3RDaGFuZ2VQYXlsb2FkKHBheWxvYWQpIHtcbiAgdmFyIHBheWxvYWRUeXBlID0gcGF5bG9hZC50eXBlO1xuICByZXR1cm4gcGF5bG9hZFR5cGUgPT09IFNFTEVDVF9BQ1RJT05fVFlQRSB8fCBwYXlsb2FkVHlwZSA9PT0gVU5TRUxFQ1RfQUNUSU9OX1RZUEUgfHwgcGF5bG9hZFR5cGUgPT09IFRPR0dMRV9TRUxFQ1RfQUNUSU9OX1RZUEU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNIaWdoRG93blBheWxvYWQocGF5bG9hZCkge1xuICB2YXIgcGF5bG9hZFR5cGUgPSBwYXlsb2FkLnR5cGU7XG4gIHJldHVybiBwYXlsb2FkVHlwZSA9PT0gSElHSExJR0hUX0FDVElPTl9UWVBFIHx8IHBheWxvYWRUeXBlID09PSBET1dOUExBWV9BQ1RJT05fVFlQRTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzYXZlUGF0aFN0YXRlcyhlbCkge1xuICB2YXIgc3RvcmUgPSBnZXRTYXZlZFN0YXRlcyhlbCk7XG4gIHN0b3JlLm5vcm1hbEZpbGwgPSBlbC5zdHlsZS5maWxsO1xuICBzdG9yZS5ub3JtYWxTdHJva2UgPSBlbC5zdHlsZS5zdHJva2U7XG4gIHZhciBzZWxlY3RTdGF0ZSA9IGVsLnN0YXRlcy5zZWxlY3QgfHwge307XG4gIHN0b3JlLnNlbGVjdEZpbGwgPSBzZWxlY3RTdGF0ZS5zdHlsZSAmJiBzZWxlY3RTdGF0ZS5zdHlsZS5maWxsIHx8IG51bGw7XG4gIHN0b3JlLnNlbGVjdFN0cm9rZSA9IHNlbGVjdFN0YXRlLnN0eWxlICYmIHNlbGVjdFN0YXRlLnN0eWxlLnN0cm9rZSB8fCBudWxsO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34833\n")},41025:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $8: () => (/* binding */ throwError),\n/* harmony export */   R8: () => (/* binding */ warn),\n/* harmony export */   aT: () => (/* binding */ deprecateLog)\n/* harmony export */ });\n/* unused harmony exports log, error, deprecateReplaceLog, makePrintable */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar ECHARTS_PREFIX = '[ECharts] ';\nvar storedLogs = {};\nvar hasConsole = typeof console !== 'undefined'\n// eslint-disable-next-line\n&& console.warn && console.log;\nfunction outputLog(type, str, onlyOnce) {\n  if (hasConsole) {\n    if (onlyOnce) {\n      if (storedLogs[str]) {\n        return;\n      }\n      storedLogs[str] = true;\n    }\n    // eslint-disable-next-line\n    console[type](ECHARTS_PREFIX + str);\n  }\n}\nfunction log(str, onlyOnce) {\n  outputLog('log', str, onlyOnce);\n}\nfunction warn(str, onlyOnce) {\n  outputLog('warn', str, onlyOnce);\n}\nfunction error(str, onlyOnce) {\n  outputLog('error', str, onlyOnce);\n}\nfunction deprecateLog(str) {\n  if (false) {}\n}\nfunction deprecateReplaceLog(oldOpt, newOpt, scope) {\n  if (false) {}\n}\n/**\r\n * If in __DEV__ environment, get console printable message for users hint.\r\n * Parameters are separated by ' '.\r\n * @usage\r\n * makePrintable('This is an error on', someVar, someObj);\r\n *\r\n * @param hintInfo anything about the current execution context to hint users.\r\n * @throws Error\r\n */\nfunction makePrintable() {\n  var hintInfo = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    hintInfo[_i] = arguments[_i];\n  }\n  var msg = '';\n  if (false) { var makePrintableStringIfPossible_1; }\n  return msg;\n}\n/**\r\n * @throws Error\r\n */\nfunction throwError(msg) {\n  throw new Error(msg);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEwMjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvbG9nLmpzP2E3NGMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBtYXAsIGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBlcU5hTiwgaXNSZWdFeHAgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xudmFyIEVDSEFSVFNfUFJFRklYID0gJ1tFQ2hhcnRzXSAnO1xudmFyIHN0b3JlZExvZ3MgPSB7fTtcbnZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiYmIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLmxvZztcbmZ1bmN0aW9uIG91dHB1dExvZyh0eXBlLCBzdHIsIG9ubHlPbmNlKSB7XG4gIGlmIChoYXNDb25zb2xlKSB7XG4gICAgaWYgKG9ubHlPbmNlKSB7XG4gICAgICBpZiAoc3RvcmVkTG9nc1tzdHJdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0b3JlZExvZ3Nbc3RyXSA9IHRydWU7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGNvbnNvbGVbdHlwZV0oRUNIQVJUU19QUkVGSVggKyBzdHIpO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gbG9nKHN0ciwgb25seU9uY2UpIHtcbiAgb3V0cHV0TG9nKCdsb2cnLCBzdHIsIG9ubHlPbmNlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3YXJuKHN0ciwgb25seU9uY2UpIHtcbiAgb3V0cHV0TG9nKCd3YXJuJywgc3RyLCBvbmx5T25jZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZXJyb3Ioc3RyLCBvbmx5T25jZSkge1xuICBvdXRwdXRMb2coJ2Vycm9yJywgc3RyLCBvbmx5T25jZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVwcmVjYXRlTG9nKHN0cikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIE5vdCBkaXNwbGF5IGR1cGxpY2F0ZSBtZXNzYWdlLlxuICAgIG91dHB1dExvZygnd2FybicsICdERVBSRUNBVEVEOiAnICsgc3RyLCB0cnVlKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZVJlcGxhY2VMb2cob2xkT3B0LCBuZXdPcHQsIHNjb3BlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGVwcmVjYXRlTG9nKChzY29wZSA/IFwiW1wiICsgc2NvcGUgKyBcIl1cIiA6ICcnKSArIChvbGRPcHQgKyBcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCIgKyBuZXdPcHQgKyBcIiBpbnN0ZWFkLlwiKSk7XG4gIH1cbn1cbi8qKlxyXG4gKiBJZiBpbiBfX0RFVl9fIGVudmlyb25tZW50LCBnZXQgY29uc29sZSBwcmludGFibGUgbWVzc2FnZSBmb3IgdXNlcnMgaGludC5cclxuICogUGFyYW1ldGVycyBhcmUgc2VwYXJhdGVkIGJ5ICcgJy5cclxuICogQHVzYWdlXHJcbiAqIG1ha2VQcmludGFibGUoJ1RoaXMgaXMgYW4gZXJyb3Igb24nLCBzb21lVmFyLCBzb21lT2JqKTtcclxuICpcclxuICogQHBhcmFtIGhpbnRJbmZvIGFueXRoaW5nIGFib3V0IHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0IHRvIGhpbnQgdXNlcnMuXHJcbiAqIEB0aHJvd3MgRXJyb3JcclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVByaW50YWJsZSgpIHtcbiAgdmFyIGhpbnRJbmZvID0gW107XG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgaGludEluZm9bX2ldID0gYXJndW1lbnRzW19pXTtcbiAgfVxuICB2YXIgbXNnID0gJyc7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gRnV6enkgc3RyaW5naWZ5IGZvciBwcmludC5cbiAgICAvLyBUaGlzIGNvZGUgb25seSBleGlzdCBpbiBkZXYgZW52aXJvbm1lbnQuXG4gICAgdmFyIG1ha2VQcmludGFibGVTdHJpbmdJZlBvc3NpYmxlXzEgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gdmFsID09PSB2b2lkIDAgPyAndW5kZWZpbmVkJyA6IHZhbCA9PT0gSW5maW5pdHkgPyAnSW5maW5pdHknIDogdmFsID09PSAtSW5maW5pdHkgPyAnLUluZmluaXR5JyA6IGVxTmFOKHZhbCkgPyAnTmFOJyA6IHZhbCBpbnN0YW5jZW9mIERhdGUgPyAnRGF0ZSgnICsgdmFsLnRvSVNPU3RyaW5nKCkgKyAnKScgOiBpc0Z1bmN0aW9uKHZhbCkgPyAnZnVuY3Rpb24gKCkgeyAuLi4gfScgOiBpc1JlZ0V4cCh2YWwpID8gdmFsICsgJycgOiBudWxsO1xuICAgIH07XG4gICAgbXNnID0gbWFwKGhpbnRJbmZvLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICBpZiAoaXNTdHJpbmcoYXJnKSkge1xuICAgICAgICAvLyBQcmludCB3aXRob3V0IHF1b3RhdGlvbiBtYXJrIGZvciBzb21lIHN0YXRlbWVudC5cbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcmludGFibGVTdHIgPSBtYWtlUHJpbnRhYmxlU3RyaW5nSWZQb3NzaWJsZV8xKGFyZyk7XG4gICAgICAgIGlmIChwcmludGFibGVTdHIgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBwcmludGFibGVTdHI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnICYmIEpTT04uc3RyaW5naWZ5KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmcsIGZ1bmN0aW9uIChuLCB2YWwpIHtcbiAgICAgICAgICAgICAgdmFyIHByaW50YWJsZVN0ciA9IG1ha2VQcmludGFibGVTdHJpbmdJZlBvc3NpYmxlXzEodmFsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByaW50YWJsZVN0ciA9PSBudWxsID8gdmFsIDogcHJpbnRhYmxlU3RyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJbiBtb3N0IGNhc2VzIHRoZSBpbmZvIG9iamVjdCBpcyBzbWFsbCwgc28gZG8gbm90IGxpbmUgYnJlYWsuXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkuam9pbignICcpO1xuICB9XG4gIHJldHVybiBtc2c7XG59XG4vKipcclxuICogQHRocm93cyBFcnJvclxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd0Vycm9yKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///41025\n")},43199:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Arc: () => (/* reexport safe */ zrender_lib_graphic_shape_Arc_js__WEBPACK_IMPORTED_MODULE_19__.A),\n/* harmony export */   BezierCurve: () => (/* reexport safe */ zrender_lib_graphic_shape_BezierCurve_js__WEBPACK_IMPORTED_MODULE_18__.A),\n/* harmony export */   BoundingRect: () => (/* reexport safe */ zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_26__.A),\n/* harmony export */   Circle: () => (/* reexport safe */ zrender_lib_graphic_shape_Circle_js__WEBPACK_IMPORTED_MODULE_10__.A),\n/* harmony export */   CompoundPath: () => (/* reexport safe */ zrender_lib_graphic_CompoundPath_js__WEBPACK_IMPORTED_MODULE_23__.A),\n/* harmony export */   Ellipse: () => (/* reexport safe */ zrender_lib_graphic_shape_Ellipse_js__WEBPACK_IMPORTED_MODULE_11__.A),\n/* harmony export */   Group: () => (/* reexport safe */ zrender_lib_graphic_Group_js__WEBPACK_IMPORTED_MODULE_20__.A),\n/* harmony export */   Image: () => (/* reexport safe */ zrender_lib_graphic_Image_js__WEBPACK_IMPORTED_MODULE_3__.Ay),\n/* harmony export */   IncrementalDisplayable: () => (/* reexport safe */ zrender_lib_graphic_IncrementalDisplayable_js__WEBPACK_IMPORTED_MODULE_22__.A),\n/* harmony export */   Line: () => (/* reexport safe */ zrender_lib_graphic_shape_Line_js__WEBPACK_IMPORTED_MODULE_17__.A),\n/* harmony export */   LinearGradient: () => (/* reexport safe */ zrender_lib_graphic_LinearGradient_js__WEBPACK_IMPORTED_MODULE_24__.A),\n/* harmony export */   OrientedBoundingRect: () => (/* reexport safe */ zrender_lib_core_OrientedBoundingRect_js__WEBPACK_IMPORTED_MODULE_27__.A),\n/* harmony export */   Path: () => (/* reexport safe */ zrender_lib_graphic_Path_js__WEBPACK_IMPORTED_MODULE_1__.Ay),\n/* harmony export */   Point: () => (/* reexport safe */ zrender_lib_core_Point_js__WEBPACK_IMPORTED_MODULE_28__.A),\n/* harmony export */   Polygon: () => (/* reexport safe */ zrender_lib_graphic_shape_Polygon_js__WEBPACK_IMPORTED_MODULE_14__.A),\n/* harmony export */   Polyline: () => (/* reexport safe */ zrender_lib_graphic_shape_Polyline_js__WEBPACK_IMPORTED_MODULE_15__.A),\n/* harmony export */   RadialGradient: () => (/* reexport safe */ zrender_lib_graphic_RadialGradient_js__WEBPACK_IMPORTED_MODULE_25__.A),\n/* harmony export */   Rect: () => (/* reexport safe */ zrender_lib_graphic_shape_Rect_js__WEBPACK_IMPORTED_MODULE_16__.A),\n/* harmony export */   Ring: () => (/* reexport safe */ zrender_lib_graphic_shape_Ring_js__WEBPACK_IMPORTED_MODULE_13__.A),\n/* harmony export */   Sector: () => (/* reexport safe */ zrender_lib_graphic_shape_Sector_js__WEBPACK_IMPORTED_MODULE_12__.A),\n/* harmony export */   Text: () => (/* reexport safe */ zrender_lib_graphic_Text_js__WEBPACK_IMPORTED_MODULE_21__.Ay),\n/* harmony export */   applyTransform: () => (/* binding */ applyTransform),\n/* harmony export */   clipPointsByRect: () => (/* binding */ clipPointsByRect),\n/* harmony export */   clipRectByRect: () => (/* binding */ clipRectByRect),\n/* harmony export */   createIcon: () => (/* binding */ createIcon),\n/* harmony export */   extendPath: () => (/* binding */ extendPath),\n/* harmony export */   extendShape: () => (/* binding */ extendShape),\n/* harmony export */   getShapeClass: () => (/* binding */ getShapeClass),\n/* harmony export */   getTransform: () => (/* binding */ getTransform),\n/* harmony export */   groupTransition: () => (/* binding */ groupTransition),\n/* harmony export */   initProps: () => (/* reexport safe */ _animation_basicTransition_js__WEBPACK_IMPORTED_MODULE_0__.LW),\n/* harmony export */   isElementRemoved: () => (/* reexport safe */ _animation_basicTransition_js__WEBPACK_IMPORTED_MODULE_0__.LR),\n/* harmony export */   lineLineIntersect: () => (/* binding */ lineLineIntersect),\n/* harmony export */   linePolygonIntersect: () => (/* binding */ linePolygonIntersect),\n/* harmony export */   makeImage: () => (/* binding */ makeImage),\n/* harmony export */   makePath: () => (/* binding */ makePath),\n/* harmony export */   mergePath: () => (/* binding */ mergePath),\n/* harmony export */   registerShape: () => (/* binding */ registerShape),\n/* harmony export */   removeElement: () => (/* reexport safe */ _animation_basicTransition_js__WEBPACK_IMPORTED_MODULE_0__.Nz),\n/* harmony export */   removeElementWithFadeOut: () => (/* reexport safe */ _animation_basicTransition_js__WEBPACK_IMPORTED_MODULE_0__.t5),\n/* harmony export */   resizePath: () => (/* binding */ resizePath),\n/* harmony export */   setTooltipConfig: () => (/* binding */ setTooltipConfig),\n/* harmony export */   subPixelOptimize: () => (/* binding */ subPixelOptimize),\n/* harmony export */   subPixelOptimizeLine: () => (/* binding */ subPixelOptimizeLine),\n/* harmony export */   subPixelOptimizeRect: () => (/* binding */ subPixelOptimizeRect),\n/* harmony export */   transformDirection: () => (/* binding */ transformDirection),\n/* harmony export */   traverseElements: () => (/* binding */ traverseElements),\n/* harmony export */   updateProps: () => (/* reexport safe */ _animation_basicTransition_js__WEBPACK_IMPORTED_MODULE_0__.oi)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_tool_path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(59442);\n/* harmony import */ var zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45587);\n/* harmony import */ var zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(83509);\n/* harmony import */ var zrender_lib_graphic_Path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59482);\n/* harmony import */ var zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(92836);\n/* harmony import */ var zrender_lib_graphic_Image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(90540);\n/* harmony import */ var zrender_lib_graphic_Group_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(43870);\n/* harmony import */ var zrender_lib_graphic_Text_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(32322);\n/* harmony import */ var zrender_lib_graphic_shape_Circle_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(31571);\n/* harmony import */ var zrender_lib_graphic_shape_Ellipse_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(18393);\n/* harmony import */ var zrender_lib_graphic_shape_Sector_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(25014);\n/* harmony import */ var zrender_lib_graphic_shape_Ring_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(42933);\n/* harmony import */ var zrender_lib_graphic_shape_Polygon_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(52505);\n/* harmony import */ var zrender_lib_graphic_shape_Polyline_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(39195);\n/* harmony import */ var zrender_lib_graphic_shape_Rect_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(30010);\n/* harmony import */ var zrender_lib_graphic_shape_Line_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(82861);\n/* harmony import */ var zrender_lib_graphic_shape_BezierCurve_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(53849);\n/* harmony import */ var zrender_lib_graphic_shape_Arc_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(43471);\n/* harmony import */ var zrender_lib_graphic_CompoundPath_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(82591);\n/* harmony import */ var zrender_lib_graphic_LinearGradient_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(29668);\n/* harmony import */ var zrender_lib_graphic_RadialGradient_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(82250);\n/* harmony import */ var zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(29308);\n/* harmony import */ var zrender_lib_core_OrientedBoundingRect_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(84716);\n/* harmony import */ var zrender_lib_core_Point_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(26346);\n/* harmony import */ var zrender_lib_graphic_IncrementalDisplayable_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(2995);\n/* harmony import */ var zrender_lib_graphic_helper_subPixelOptimize_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14865);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(98026);\n/* harmony import */ var _innerStore_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(69622);\n/* harmony import */ var _animation_basicTransition_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5638);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * @deprecated export for compatitable reason\r\n */\n\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar _customShapeMap = {};\n/**\r\n * Extend shape with parameters\r\n */\nfunction extendShape(opts) {\n  return zrender_lib_graphic_Path_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .Ay.extend(opts);\n}\nvar extendPathFromString = zrender_lib_tool_path_js__WEBPACK_IMPORTED_MODULE_2__/* .extendFromString */ .Qh;\n/**\r\n * Extend path\r\n */\nfunction extendPath(pathData, opts) {\n  return extendPathFromString(pathData, opts);\n}\n/**\r\n * Register a user defined shape.\r\n * The shape class can be fetched by `getShapeClass`\r\n * This method will overwrite the registered shapes, including\r\n * the registered built-in shapes, if using the same `name`.\r\n * The shape can be used in `custom series` and\r\n * `graphic component` by declaring `{type: name}`.\r\n *\r\n * @param name\r\n * @param ShapeClass Can be generated by `extendShape`.\r\n */\nfunction registerShape(name, ShapeClass) {\n  _customShapeMap[name] = ShapeClass;\n}\n/**\r\n * Find shape class registered by `registerShape`. Usually used in\r\n * fetching user defined shape.\r\n *\r\n * [Caution]:\r\n * (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared\r\n * to use user registered shapes.\r\n * Because the built-in shape (see `getBuiltInShape`) will be registered by\r\n * `registerShape` by default. That enables users to get both built-in\r\n * shapes as well as the shapes belonging to themsleves. But users can overwrite\r\n * the built-in shapes by using names like 'circle', 'rect' via calling\r\n * `registerShape`. So the echarts inner featrues should not fetch shapes from here\r\n * in case that it is overwritten by users, except that some features, like\r\n * `custom series`, `graphic component`, do it deliberately.\r\n *\r\n * (2) In the features like `custom series`, `graphic component`, the user input\r\n * `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic\r\n * elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names\r\n * are reserved names, that is, if some user registers a shape named `'image'`,\r\n * the shape will not be used. If we intending to add some more reserved names\r\n * in feature, that might bring break changes (disable some existing user shape\r\n * names). But that case probably rarely happens. So we don't make more mechanism\r\n * to resolve this issue here.\r\n *\r\n * @param name\r\n * @return The shape class. If not found, return nothing.\r\n */\nfunction getShapeClass(name) {\n  if (_customShapeMap.hasOwnProperty(name)) {\n    return _customShapeMap[name];\n  }\n}\n/**\r\n * Create a path element from path data string\r\n * @param pathData\r\n * @param opts\r\n * @param rect\r\n * @param layout 'center' or 'cover' default to be cover\r\n */\nfunction makePath(pathData, opts, rect, layout) {\n  var path = zrender_lib_tool_path_js__WEBPACK_IMPORTED_MODULE_2__/* .createFromString */ .UJ(pathData, opts);\n  if (rect) {\n    if (layout === 'center') {\n      rect = centerGraphic(rect, path.getBoundingRect());\n    }\n    resizePath(path, rect);\n  }\n  return path;\n}\n/**\r\n * Create a image element from image url\r\n * @param imageUrl image url\r\n * @param opts options\r\n * @param rect constrain rect\r\n * @param layout 'center' or 'cover'. Default to be 'cover'\r\n */\nfunction makeImage(imageUrl, rect, layout) {\n  var zrImg = new zrender_lib_graphic_Image_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .Ay({\n    style: {\n      image: imageUrl,\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    },\n    onload: function (img) {\n      if (layout === 'center') {\n        var boundingRect = {\n          width: img.width,\n          height: img.height\n        };\n        zrImg.setStyle(centerGraphic(rect, boundingRect));\n      }\n    }\n  });\n  return zrImg;\n}\n/**\r\n * Get position of centered element in bounding box.\r\n *\r\n * @param  rect         element local bounding box\r\n * @param  boundingRect constraint bounding box\r\n * @return element position containing x, y, width, and height\r\n */\nfunction centerGraphic(rect, boundingRect) {\n  // Set rect to center, keep width / height ratio.\n  var aspect = boundingRect.width / boundingRect.height;\n  var width = rect.height * aspect;\n  var height;\n  if (width <= rect.width) {\n    height = rect.height;\n  } else {\n    width = rect.width;\n    height = width / aspect;\n  }\n  var cx = rect.x + rect.width / 2;\n  var cy = rect.y + rect.height / 2;\n  return {\n    x: cx - width / 2,\n    y: cy - height / 2,\n    width: width,\n    height: height\n  };\n}\nvar mergePath = zrender_lib_tool_path_js__WEBPACK_IMPORTED_MODULE_2__/* .mergePath */ .uc;\n/**\r\n * Resize a path to fit the rect\r\n * @param path\r\n * @param rect\r\n */\nfunction resizePath(path, rect) {\n  if (!path.applyTransform) {\n    return;\n  }\n  var pathRect = path.getBoundingRect();\n  var m = pathRect.calculateTransform(rect);\n  path.applyTransform(m);\n}\n/**\r\n * Sub pixel optimize line for canvas\r\n */\nfunction subPixelOptimizeLine(shape, lineWidth) {\n  zrender_lib_graphic_helper_subPixelOptimize_js__WEBPACK_IMPORTED_MODULE_4__/* .subPixelOptimizeLine */ .eB(shape, shape, {\n    lineWidth: lineWidth\n  });\n  return shape;\n}\n/**\r\n * Sub pixel optimize rect for canvas\r\n */\nfunction subPixelOptimizeRect(param) {\n  zrender_lib_graphic_helper_subPixelOptimize_js__WEBPACK_IMPORTED_MODULE_4__/* .subPixelOptimizeRect */ .Op(param.shape, param.shape, param.style);\n  return param;\n}\n/**\r\n * Sub pixel optimize for canvas\r\n *\r\n * @param position Coordinate, such as x, y\r\n * @param lineWidth Should be nonnegative integer.\r\n * @param positiveOrNegative Default false (negative).\r\n * @return Optimized position.\r\n */\nvar subPixelOptimize = zrender_lib_graphic_helper_subPixelOptimize_js__WEBPACK_IMPORTED_MODULE_4__/* .subPixelOptimize */ .M7;\n/**\r\n * Get transform matrix of target (param target),\r\n * in coordinate of its ancestor (param ancestor)\r\n *\r\n * @param target\r\n * @param [ancestor]\r\n */\nfunction getTransform(target, ancestor) {\n  var mat = zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__.identity([]);\n  while (target && target !== ancestor) {\n    zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__.mul(mat, target.getLocalTransform(), mat);\n    target = target.parent;\n  }\n  return mat;\n}\n/**\r\n * Apply transform to an vertex.\r\n * @param target [x, y]\r\n * @param transform Can be:\r\n *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n *      + {position, rotation, scale}, the same as `zrender/Transformable`.\r\n * @param invert Whether use invert matrix.\r\n * @return [x, y]\r\n */\nfunction applyTransform(target, transform, invert) {\n  if (transform && !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.isArrayLike)(transform)) {\n    transform = zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .Ay.getLocalTransform(transform);\n  }\n  if (invert) {\n    transform = zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_5__.invert([], transform);\n  }\n  return zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_8__.applyTransform([], target, transform);\n}\n/**\r\n * @param direction 'left' 'right' 'top' 'bottom'\r\n * @param transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n * @param invert Whether use invert matrix.\r\n * @return Transformed direction. 'left' 'right' 'top' 'bottom'\r\n */\nfunction transformDirection(direction, transform, invert) {\n  // Pick a base, ensure that transform result will not be (0, 0).\n  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];\n  vertex = applyTransform(vertex, transform, invert);\n  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n}\nfunction isNotGroup(el) {\n  return !el.isGroup;\n}\nfunction isPath(el) {\n  return el.shape != null;\n}\n/**\r\n * Apply group transition animation from g1 to g2.\r\n * If no animatableModel, no animation.\r\n */\nfunction groupTransition(g1, g2, animatableModel) {\n  if (!g1 || !g2) {\n    return;\n  }\n  function getElMap(g) {\n    var elMap = {};\n    g.traverse(function (el) {\n      if (isNotGroup(el) && el.anid) {\n        elMap[el.anid] = el;\n      }\n    });\n    return elMap;\n  }\n  function getAnimatableProps(el) {\n    var obj = {\n      x: el.x,\n      y: el.y,\n      rotation: el.rotation\n    };\n    if (isPath(el)) {\n      obj.shape = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.extend)({}, el.shape);\n    }\n    return obj;\n  }\n  var elMap1 = getElMap(g1);\n  g2.traverse(function (el) {\n    if (isNotGroup(el) && el.anid) {\n      var oldEl = elMap1[el.anid];\n      if (oldEl) {\n        var newProp = getAnimatableProps(el);\n        el.attr(getAnimatableProps(oldEl));\n        (0,_animation_basicTransition_js__WEBPACK_IMPORTED_MODULE_0__/* .updateProps */ .oi)(el, newProp, animatableModel, (0,_innerStore_js__WEBPACK_IMPORTED_MODULE_9__/* .getECData */ .z)(el).dataIndex);\n      }\n    }\n  });\n}\nfunction clipPointsByRect(points, rect) {\n  // FIXME: This way might be incorrect when graphic clipped by a corner\n  // and when element has a border.\n  return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.map)(points, function (point) {\n    var x = point[0];\n    x = mathMax(x, rect.x);\n    x = mathMin(x, rect.x + rect.width);\n    var y = point[1];\n    y = mathMax(y, rect.y);\n    y = mathMin(y, rect.y + rect.height);\n    return [x, y];\n  });\n}\n/**\r\n * Return a new clipped rect. If rect size are negative, return undefined.\r\n */\nfunction clipRectByRect(targetRect, rect) {\n  var x = mathMax(targetRect.x, rect.x);\n  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n  var y = mathMax(targetRect.y, rect.y);\n  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);\n  // If the total rect is cliped, nothing, including the border,\n  // should be painted. So return undefined.\n  if (x2 >= x && y2 >= y) {\n    return {\n      x: x,\n      y: y,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\nfunction createIcon(iconStr,\n// Support 'image://' or 'path://' or direct svg path.\nopt, rect) {\n  var innerOpts = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.extend)({\n    rectHover: true\n  }, opt);\n  var style = innerOpts.style = {\n    strokeNoScale: true\n  };\n  rect = rect || {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  };\n  if (iconStr) {\n    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.defaults)(style, rect), new zrender_lib_graphic_Image_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .Ay(innerOpts)) : makePath(iconStr.replace('path://', ''), innerOpts, rect, 'center');\n  }\n}\n/**\r\n * Return `true` if the given line (line `a`) and the given polygon\r\n * are intersect.\r\n * Note that we do not count colinear as intersect here because no\r\n * requirement for that. We could do that if required in future.\r\n */\nfunction linePolygonIntersect(a1x, a1y, a2x, a2y, points) {\n  for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {\n    var p = points[i];\n    if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {\n      return true;\n    }\n    p2 = p;\n  }\n}\n/**\r\n * Return `true` if the given two lines (line `a` and line `b`)\r\n * are intersect.\r\n * Note that we do not count colinear as intersect here because no\r\n * requirement for that. We could do that if required in future.\r\n */\nfunction lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n  // let `vec_m` to be `vec_a2 - vec_a1` and `vec_n` to be `vec_b2 - vec_b1`.\n  var mx = a2x - a1x;\n  var my = a2y - a1y;\n  var nx = b2x - b1x;\n  var ny = b2y - b1y;\n  // `vec_m` and `vec_n` are parallel iff\n  //     existing `k` such that `vec_m = k  vec_n`, equivalent to `vec_m X vec_n = 0`.\n  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n  if (nearZero(nmCrossProduct)) {\n    return false;\n  }\n  // `vec_m` and `vec_n` are intersect iff\n  //     existing `p` and `q` in [0, 1] such that `vec_a1 + p * vec_m = vec_b1 + q * vec_n`,\n  //     such that `q = ((vec_a1 - vec_b1) X vec_m) / (vec_n X vec_m)`\n  //           and `p = ((vec_a1 - vec_b1) X vec_n) / (vec_n X vec_m)`.\n  var b1a1x = a1x - b1x;\n  var b1a1y = a1y - b1y;\n  var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;\n  if (q < 0 || q > 1) {\n    return false;\n  }\n  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n  if (p < 0 || p > 1) {\n    return false;\n  }\n  return true;\n}\n/**\r\n * Cross product of 2-dimension vector.\r\n */\nfunction crossProduct2d(x1, y1, x2, y2) {\n  return x1 * y2 - x2 * y1;\n}\nfunction nearZero(val) {\n  return val <= 1e-6 && val >= -1e-6;\n}\nfunction setTooltipConfig(opt) {\n  var itemTooltipOption = opt.itemTooltipOption;\n  var componentModel = opt.componentModel;\n  var itemName = opt.itemName;\n  var itemTooltipOptionObj = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.isString)(itemTooltipOption) ? {\n    formatter: itemTooltipOption\n  } : itemTooltipOption;\n  var mainType = componentModel.mainType;\n  var componentIndex = componentModel.componentIndex;\n  var formatterParams = {\n    componentType: mainType,\n    name: itemName,\n    $vars: ['name']\n  };\n  formatterParams[mainType + 'Index'] = componentIndex;\n  var formatterParamsExtra = opt.formatterParamsExtra;\n  if (formatterParamsExtra) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.each)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.keys)(formatterParamsExtra), function (key) {\n      if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.hasOwn)(formatterParams, key)) {\n        formatterParams[key] = formatterParamsExtra[key];\n        formatterParams.$vars.push(key);\n      }\n    });\n  }\n  var ecData = (0,_innerStore_js__WEBPACK_IMPORTED_MODULE_9__/* .getECData */ .z)(opt.el);\n  ecData.componentMainType = mainType;\n  ecData.componentIndex = componentIndex;\n  ecData.tooltipConfig = {\n    name: itemName,\n    option: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.defaults)({\n      content: itemName,\n      encodeHTMLContent: true,\n      formatterParams: formatterParams\n    }, itemTooltipOptionObj)\n  };\n}\nfunction traverseElement(el, cb) {\n  var stopped;\n  // TODO\n  // Polyfill for fixing zrender group traverse don't visit it's root issue.\n  if (el.isGroup) {\n    stopped = cb(el);\n  }\n  if (!stopped) {\n    el.traverse(cb);\n  }\n}\nfunction traverseElements(els, cb) {\n  if (els) {\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_6__.isArray)(els)) {\n      for (var i = 0; i < els.length; i++) {\n        traverseElement(els[i], cb);\n      }\n    } else {\n      traverseElement(els, cb);\n    }\n  }\n}\n// Register built-in shapes. These shapes might be overwritten\n// by users, although we do not recommend that.\nregisterShape('circle', zrender_lib_graphic_shape_Circle_js__WEBPACK_IMPORTED_MODULE_10__/* [\"default\"] */ .A);\nregisterShape('ellipse', zrender_lib_graphic_shape_Ellipse_js__WEBPACK_IMPORTED_MODULE_11__/* [\"default\"] */ .A);\nregisterShape('sector', zrender_lib_graphic_shape_Sector_js__WEBPACK_IMPORTED_MODULE_12__/* [\"default\"] */ .A);\nregisterShape('ring', zrender_lib_graphic_shape_Ring_js__WEBPACK_IMPORTED_MODULE_13__/* [\"default\"] */ .A);\nregisterShape('polygon', zrender_lib_graphic_shape_Polygon_js__WEBPACK_IMPORTED_MODULE_14__/* [\"default\"] */ .A);\nregisterShape('polyline', zrender_lib_graphic_shape_Polyline_js__WEBPACK_IMPORTED_MODULE_15__/* [\"default\"] */ .A);\nregisterShape('rect', zrender_lib_graphic_shape_Rect_js__WEBPACK_IMPORTED_MODULE_16__/* [\"default\"] */ .A);\nregisterShape('line', zrender_lib_graphic_shape_Line_js__WEBPACK_IMPORTED_MODULE_17__/* [\"default\"] */ .A);\nregisterShape('bezierCurve', zrender_lib_graphic_shape_BezierCurve_js__WEBPACK_IMPORTED_MODULE_18__/* [\"default\"] */ .A);\nregisterShape('arc', zrender_lib_graphic_shape_Arc_js__WEBPACK_IMPORTED_MODULE_19__/* [\"default\"] */ .A);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMxOTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvZ3JhcGhpYy5qcz8wYTljIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgcGF0aFRvb2wgZnJvbSAnenJlbmRlci9saWIvdG9vbC9wYXRoLmpzJztcbmltcG9ydCAqIGFzIG1hdHJpeCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qcyc7XG5pbXBvcnQgKiBhcyB2ZWN0b3IgZnJvbSAnenJlbmRlci9saWIvY29yZS92ZWN0b3IuanMnO1xuaW1wb3J0IFBhdGggZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzJztcbmltcG9ydCBUcmFuc2Zvcm1hYmxlIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvVHJhbnNmb3JtYWJsZS5qcyc7XG5pbXBvcnQgWlJJbWFnZSBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzJztcbmltcG9ydCBHcm91cCBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL0dyb3VwLmpzJztcbmltcG9ydCBaUlRleHQgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0LmpzJztcbmltcG9ydCBDaXJjbGUgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanMnO1xuaW1wb3J0IEVsbGlwc2UgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9FbGxpcHNlLmpzJztcbmltcG9ydCBTZWN0b3IgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanMnO1xuaW1wb3J0IFJpbmcgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nLmpzJztcbmltcG9ydCBQb2x5Z29uIGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qcyc7XG5pbXBvcnQgUG9seWxpbmUgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qcyc7XG5pbXBvcnQgUmVjdCBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QuanMnO1xuaW1wb3J0IExpbmUgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lLmpzJztcbmltcG9ydCBCZXppZXJDdXJ2ZSBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlLmpzJztcbmltcG9ydCBBcmMgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMuanMnO1xuaW1wb3J0IENvbXBvdW5kUGF0aCBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL0NvbXBvdW5kUGF0aC5qcyc7XG5pbXBvcnQgTGluZWFyR3JhZGllbnQgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudC5qcyc7XG5pbXBvcnQgUmFkaWFsR3JhZGllbnQgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qcyc7XG5pbXBvcnQgQm91bmRpbmdSZWN0IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJztcbmltcG9ydCBPcmllbnRlZEJvdW5kaW5nUmVjdCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL09yaWVudGVkQm91bmRpbmdSZWN0LmpzJztcbmltcG9ydCBQb2ludCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL1BvaW50LmpzJztcbmltcG9ydCBJbmNyZW1lbnRhbERpc3BsYXlhYmxlIGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvSW5jcmVtZW50YWxEaXNwbGF5YWJsZS5qcyc7XG5pbXBvcnQgKiBhcyBzdWJQaXhlbE9wdGltaXplVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zdWJQaXhlbE9wdGltaXplLmpzJztcbmltcG9ydCB7IGV4dGVuZCwgaXNBcnJheUxpa2UsIG1hcCwgZGVmYXVsdHMsIGlzU3RyaW5nLCBrZXlzLCBlYWNoLCBoYXNPd24sIGlzQXJyYXkgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi9pbm5lclN0b3JlLmpzJztcbmltcG9ydCB7IHVwZGF0ZVByb3BzLCBpbml0UHJvcHMsIHJlbW92ZUVsZW1lbnQsIHJlbW92ZUVsZW1lbnRXaXRoRmFkZU91dCwgaXNFbGVtZW50UmVtb3ZlZCB9IGZyb20gJy4uL2FuaW1hdGlvbi9iYXNpY1RyYW5zaXRpb24uanMnO1xuLyoqXHJcbiAqIEBkZXByZWNhdGVkIGV4cG9ydCBmb3IgY29tcGF0aXRhYmxlIHJlYXNvblxyXG4gKi9cbmV4cG9ydCB7IHVwZGF0ZVByb3BzLCBpbml0UHJvcHMsIHJlbW92ZUVsZW1lbnQsIHJlbW92ZUVsZW1lbnRXaXRoRmFkZU91dCwgaXNFbGVtZW50UmVtb3ZlZCB9O1xudmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgX2N1c3RvbVNoYXBlTWFwID0ge307XG4vKipcclxuICogRXh0ZW5kIHNoYXBlIHdpdGggcGFyYW1ldGVyc1xyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRTaGFwZShvcHRzKSB7XG4gIHJldHVybiBQYXRoLmV4dGVuZChvcHRzKTtcbn1cbnZhciBleHRlbmRQYXRoRnJvbVN0cmluZyA9IHBhdGhUb29sLmV4dGVuZEZyb21TdHJpbmc7XG4vKipcclxuICogRXh0ZW5kIHBhdGhcclxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kUGF0aChwYXRoRGF0YSwgb3B0cykge1xuICByZXR1cm4gZXh0ZW5kUGF0aEZyb21TdHJpbmcocGF0aERhdGEsIG9wdHMpO1xufVxuLyoqXHJcbiAqIFJlZ2lzdGVyIGEgdXNlciBkZWZpbmVkIHNoYXBlLlxyXG4gKiBUaGUgc2hhcGUgY2xhc3MgY2FuIGJlIGZldGNoZWQgYnkgYGdldFNoYXBlQ2xhc3NgXHJcbiAqIFRoaXMgbWV0aG9kIHdpbGwgb3ZlcndyaXRlIHRoZSByZWdpc3RlcmVkIHNoYXBlcywgaW5jbHVkaW5nXHJcbiAqIHRoZSByZWdpc3RlcmVkIGJ1aWx0LWluIHNoYXBlcywgaWYgdXNpbmcgdGhlIHNhbWUgYG5hbWVgLlxyXG4gKiBUaGUgc2hhcGUgY2FuIGJlIHVzZWQgaW4gYGN1c3RvbSBzZXJpZXNgIGFuZFxyXG4gKiBgZ3JhcGhpYyBjb21wb25lbnRgIGJ5IGRlY2xhcmluZyBge3R5cGU6IG5hbWV9YC5cclxuICpcclxuICogQHBhcmFtIG5hbWVcclxuICogQHBhcmFtIFNoYXBlQ2xhc3MgQ2FuIGJlIGdlbmVyYXRlZCBieSBgZXh0ZW5kU2hhcGVgLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclNoYXBlKG5hbWUsIFNoYXBlQ2xhc3MpIHtcbiAgX2N1c3RvbVNoYXBlTWFwW25hbWVdID0gU2hhcGVDbGFzcztcbn1cbi8qKlxyXG4gKiBGaW5kIHNoYXBlIGNsYXNzIHJlZ2lzdGVyZWQgYnkgYHJlZ2lzdGVyU2hhcGVgLiBVc3VhbGx5IHVzZWQgaW5cclxuICogZmV0Y2hpbmcgdXNlciBkZWZpbmVkIHNoYXBlLlxyXG4gKlxyXG4gKiBbQ2F1dGlvbl06XHJcbiAqICgxKSBUaGlzIG1ldGhvZCAqKk1VU1QgTk9UIGJlIHVzZWQgaW5zaWRlIGVjaGFydHMgISEhKiosIHVubGVzcyBpdCBpcyBwcmVwYXJlZFxyXG4gKiB0byB1c2UgdXNlciByZWdpc3RlcmVkIHNoYXBlcy5cclxuICogQmVjYXVzZSB0aGUgYnVpbHQtaW4gc2hhcGUgKHNlZSBgZ2V0QnVpbHRJblNoYXBlYCkgd2lsbCBiZSByZWdpc3RlcmVkIGJ5XHJcbiAqIGByZWdpc3RlclNoYXBlYCBieSBkZWZhdWx0LiBUaGF0IGVuYWJsZXMgdXNlcnMgdG8gZ2V0IGJvdGggYnVpbHQtaW5cclxuICogc2hhcGVzIGFzIHdlbGwgYXMgdGhlIHNoYXBlcyBiZWxvbmdpbmcgdG8gdGhlbXNsZXZlcy4gQnV0IHVzZXJzIGNhbiBvdmVyd3JpdGVcclxuICogdGhlIGJ1aWx0LWluIHNoYXBlcyBieSB1c2luZyBuYW1lcyBsaWtlICdjaXJjbGUnLCAncmVjdCcgdmlhIGNhbGxpbmdcclxuICogYHJlZ2lzdGVyU2hhcGVgLiBTbyB0aGUgZWNoYXJ0cyBpbm5lciBmZWF0cnVlcyBzaG91bGQgbm90IGZldGNoIHNoYXBlcyBmcm9tIGhlcmVcclxuICogaW4gY2FzZSB0aGF0IGl0IGlzIG92ZXJ3cml0dGVuIGJ5IHVzZXJzLCBleGNlcHQgdGhhdCBzb21lIGZlYXR1cmVzLCBsaWtlXHJcbiAqIGBjdXN0b20gc2VyaWVzYCwgYGdyYXBoaWMgY29tcG9uZW50YCwgZG8gaXQgZGVsaWJlcmF0ZWx5LlxyXG4gKlxyXG4gKiAoMikgSW4gdGhlIGZlYXR1cmVzIGxpa2UgYGN1c3RvbSBzZXJpZXNgLCBgZ3JhcGhpYyBjb21wb25lbnRgLCB0aGUgdXNlciBpbnB1dFxyXG4gKiBge3RweWU6ICd4eHgnfWAgZG9lcyBub3Qgb25seSBzcGVjaWZ5IHNoYXBlcyBidXQgYWxzbyBzcGVjaWZ5IG90aGVyIGdyYXBoaWNcclxuICogZWxlbWVudHMgbGlrZSBgJ2dyb3VwJ2AsIGAndGV4dCdgLCBgJ2ltYWdlJ2Agb3IgZXZlbnQgYCdwYXRoJ2AuIFRob3NlIG5hbWVzXHJcbiAqIGFyZSByZXNlcnZlZCBuYW1lcywgdGhhdCBpcywgaWYgc29tZSB1c2VyIHJlZ2lzdGVycyBhIHNoYXBlIG5hbWVkIGAnaW1hZ2UnYCxcclxuICogdGhlIHNoYXBlIHdpbGwgbm90IGJlIHVzZWQuIElmIHdlIGludGVuZGluZyB0byBhZGQgc29tZSBtb3JlIHJlc2VydmVkIG5hbWVzXHJcbiAqIGluIGZlYXR1cmUsIHRoYXQgbWlnaHQgYnJpbmcgYnJlYWsgY2hhbmdlcyAoZGlzYWJsZSBzb21lIGV4aXN0aW5nIHVzZXIgc2hhcGVcclxuICogbmFtZXMpLiBCdXQgdGhhdCBjYXNlIHByb2JhYmx5IHJhcmVseSBoYXBwZW5zLiBTbyB3ZSBkb24ndCBtYWtlIG1vcmUgbWVjaGFuaXNtXHJcbiAqIHRvIHJlc29sdmUgdGhpcyBpc3N1ZSBoZXJlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZVxyXG4gKiBAcmV0dXJuIFRoZSBzaGFwZSBjbGFzcy4gSWYgbm90IGZvdW5kLCByZXR1cm4gbm90aGluZy5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2hhcGVDbGFzcyhuYW1lKSB7XG4gIGlmIChfY3VzdG9tU2hhcGVNYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gX2N1c3RvbVNoYXBlTWFwW25hbWVdO1xuICB9XG59XG4vKipcclxuICogQ3JlYXRlIGEgcGF0aCBlbGVtZW50IGZyb20gcGF0aCBkYXRhIHN0cmluZ1xyXG4gKiBAcGFyYW0gcGF0aERhdGFcclxuICogQHBhcmFtIG9wdHNcclxuICogQHBhcmFtIHJlY3RcclxuICogQHBhcmFtIGxheW91dCAnY2VudGVyJyBvciAnY292ZXInIGRlZmF1bHQgdG8gYmUgY292ZXJcclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVBhdGgocGF0aERhdGEsIG9wdHMsIHJlY3QsIGxheW91dCkge1xuICB2YXIgcGF0aCA9IHBhdGhUb29sLmNyZWF0ZUZyb21TdHJpbmcocGF0aERhdGEsIG9wdHMpO1xuICBpZiAocmVjdCkge1xuICAgIGlmIChsYXlvdXQgPT09ICdjZW50ZXInKSB7XG4gICAgICByZWN0ID0gY2VudGVyR3JhcGhpYyhyZWN0LCBwYXRoLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICB9XG4gICAgcmVzaXplUGF0aChwYXRoLCByZWN0KTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBpbWFnZSBlbGVtZW50IGZyb20gaW1hZ2UgdXJsXHJcbiAqIEBwYXJhbSBpbWFnZVVybCBpbWFnZSB1cmxcclxuICogQHBhcmFtIG9wdHMgb3B0aW9uc1xyXG4gKiBAcGFyYW0gcmVjdCBjb25zdHJhaW4gcmVjdFxyXG4gKiBAcGFyYW0gbGF5b3V0ICdjZW50ZXInIG9yICdjb3ZlcicuIERlZmF1bHQgdG8gYmUgJ2NvdmVyJ1xyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSW1hZ2UoaW1hZ2VVcmwsIHJlY3QsIGxheW91dCkge1xuICB2YXIgenJJbWcgPSBuZXcgWlJJbWFnZSh7XG4gICAgc3R5bGU6IHtcbiAgICAgIGltYWdlOiBpbWFnZVVybCxcbiAgICAgIHg6IHJlY3QueCxcbiAgICAgIHk6IHJlY3QueSxcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgIH0sXG4gICAgb25sb2FkOiBmdW5jdGlvbiAoaW1nKSB7XG4gICAgICBpZiAobGF5b3V0ID09PSAnY2VudGVyJykge1xuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0ge1xuICAgICAgICAgIHdpZHRoOiBpbWcud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBpbWcuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIHpySW1nLnNldFN0eWxlKGNlbnRlckdyYXBoaWMocmVjdCwgYm91bmRpbmdSZWN0KSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHpySW1nO1xufVxuLyoqXHJcbiAqIEdldCBwb3NpdGlvbiBvZiBjZW50ZXJlZCBlbGVtZW50IGluIGJvdW5kaW5nIGJveC5cclxuICpcclxuICogQHBhcmFtICByZWN0ICAgICAgICAgZWxlbWVudCBsb2NhbCBib3VuZGluZyBib3hcclxuICogQHBhcmFtICBib3VuZGluZ1JlY3QgY29uc3RyYWludCBib3VuZGluZyBib3hcclxuICogQHJldHVybiBlbGVtZW50IHBvc2l0aW9uIGNvbnRhaW5pbmcgeCwgeSwgd2lkdGgsIGFuZCBoZWlnaHRcclxuICovXG5mdW5jdGlvbiBjZW50ZXJHcmFwaGljKHJlY3QsIGJvdW5kaW5nUmVjdCkge1xuICAvLyBTZXQgcmVjdCB0byBjZW50ZXIsIGtlZXAgd2lkdGggLyBoZWlnaHQgcmF0aW8uXG4gIHZhciBhc3BlY3QgPSBib3VuZGluZ1JlY3Qud2lkdGggLyBib3VuZGluZ1JlY3QuaGVpZ2h0O1xuICB2YXIgd2lkdGggPSByZWN0LmhlaWdodCAqIGFzcGVjdDtcbiAgdmFyIGhlaWdodDtcbiAgaWYgKHdpZHRoIDw9IHJlY3Qud2lkdGgpIHtcbiAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gIH1cbiAgdmFyIGN4ID0gcmVjdC54ICsgcmVjdC53aWR0aCAvIDI7XG4gIHZhciBjeSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMjtcbiAgcmV0dXJuIHtcbiAgICB4OiBjeCAtIHdpZHRoIC8gMixcbiAgICB5OiBjeSAtIGhlaWdodCAvIDIsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG5leHBvcnQgdmFyIG1lcmdlUGF0aCA9IHBhdGhUb29sLm1lcmdlUGF0aDtcbi8qKlxyXG4gKiBSZXNpemUgYSBwYXRoIHRvIGZpdCB0aGUgcmVjdFxyXG4gKiBAcGFyYW0gcGF0aFxyXG4gKiBAcGFyYW0gcmVjdFxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNpemVQYXRoKHBhdGgsIHJlY3QpIHtcbiAgaWYgKCFwYXRoLmFwcGx5VHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwYXRoUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gIHZhciBtID0gcGF0aFJlY3QuY2FsY3VsYXRlVHJhbnNmb3JtKHJlY3QpO1xuICBwYXRoLmFwcGx5VHJhbnNmb3JtKG0pO1xufVxuLyoqXHJcbiAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBsaW5lIGZvciBjYW52YXNcclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ViUGl4ZWxPcHRpbWl6ZUxpbmUoc2hhcGUsIGxpbmVXaWR0aCkge1xuICBzdWJQaXhlbE9wdGltaXplVXRpbC5zdWJQaXhlbE9wdGltaXplTGluZShzaGFwZSwgc2hhcGUsIHtcbiAgICBsaW5lV2lkdGg6IGxpbmVXaWR0aFxuICB9KTtcbiAgcmV0dXJuIHNoYXBlO1xufVxuLyoqXHJcbiAqIFN1YiBwaXhlbCBvcHRpbWl6ZSByZWN0IGZvciBjYW52YXNcclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ViUGl4ZWxPcHRpbWl6ZVJlY3QocGFyYW0pIHtcbiAgc3ViUGl4ZWxPcHRpbWl6ZVV0aWwuc3ViUGl4ZWxPcHRpbWl6ZVJlY3QocGFyYW0uc2hhcGUsIHBhcmFtLnNoYXBlLCBwYXJhbS5zdHlsZSk7XG4gIHJldHVybiBwYXJhbTtcbn1cbi8qKlxyXG4gKiBTdWIgcGl4ZWwgb3B0aW1pemUgZm9yIGNhbnZhc1xyXG4gKlxyXG4gKiBAcGFyYW0gcG9zaXRpb24gQ29vcmRpbmF0ZSwgc3VjaCBhcyB4LCB5XHJcbiAqIEBwYXJhbSBsaW5lV2lkdGggU2hvdWxkIGJlIG5vbm5lZ2F0aXZlIGludGVnZXIuXHJcbiAqIEBwYXJhbSBwb3NpdGl2ZU9yTmVnYXRpdmUgRGVmYXVsdCBmYWxzZSAobmVnYXRpdmUpLlxyXG4gKiBAcmV0dXJuIE9wdGltaXplZCBwb3NpdGlvbi5cclxuICovXG5leHBvcnQgdmFyIHN1YlBpeGVsT3B0aW1pemUgPSBzdWJQaXhlbE9wdGltaXplVXRpbC5zdWJQaXhlbE9wdGltaXplO1xuLyoqXHJcbiAqIEdldCB0cmFuc2Zvcm0gbWF0cml4IG9mIHRhcmdldCAocGFyYW0gdGFyZ2V0KSxcclxuICogaW4gY29vcmRpbmF0ZSBvZiBpdHMgYW5jZXN0b3IgKHBhcmFtIGFuY2VzdG9yKVxyXG4gKlxyXG4gKiBAcGFyYW0gdGFyZ2V0XHJcbiAqIEBwYXJhbSBbYW5jZXN0b3JdXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZm9ybSh0YXJnZXQsIGFuY2VzdG9yKSB7XG4gIHZhciBtYXQgPSBtYXRyaXguaWRlbnRpdHkoW10pO1xuICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gYW5jZXN0b3IpIHtcbiAgICBtYXRyaXgubXVsKG1hdCwgdGFyZ2V0LmdldExvY2FsVHJhbnNmb3JtKCksIG1hdCk7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudDtcbiAgfVxuICByZXR1cm4gbWF0O1xufVxuLyoqXHJcbiAqIEFwcGx5IHRyYW5zZm9ybSB0byBhbiB2ZXJ0ZXguXHJcbiAqIEBwYXJhbSB0YXJnZXQgW3gsIHldXHJcbiAqIEBwYXJhbSB0cmFuc2Zvcm0gQ2FuIGJlOlxyXG4gKiAgICAgICsgVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICogICAgICArIHtwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlfSwgdGhlIHNhbWUgYXMgYHpyZW5kZXIvVHJhbnNmb3JtYWJsZWAuXHJcbiAqIEBwYXJhbSBpbnZlcnQgV2hldGhlciB1c2UgaW52ZXJ0IG1hdHJpeC5cclxuICogQHJldHVybiBbeCwgeV1cclxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0odGFyZ2V0LCB0cmFuc2Zvcm0sIGludmVydCkge1xuICBpZiAodHJhbnNmb3JtICYmICFpc0FycmF5TGlrZSh0cmFuc2Zvcm0pKSB7XG4gICAgdHJhbnNmb3JtID0gVHJhbnNmb3JtYWJsZS5nZXRMb2NhbFRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICB9XG4gIGlmIChpbnZlcnQpIHtcbiAgICB0cmFuc2Zvcm0gPSBtYXRyaXguaW52ZXJ0KFtdLCB0cmFuc2Zvcm0pO1xuICB9XG4gIHJldHVybiB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0oW10sIHRhcmdldCwgdHJhbnNmb3JtKTtcbn1cbi8qKlxyXG4gKiBAcGFyYW0gZGlyZWN0aW9uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAqIEBwYXJhbSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICogQHBhcmFtIGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gKiBAcmV0dXJuIFRyYW5zZm9ybWVkIGRpcmVjdGlvbi4gJ2xlZnQnICdyaWdodCcgJ3RvcCcgJ2JvdHRvbSdcclxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtRGlyZWN0aW9uKGRpcmVjdGlvbiwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcbiAgLy8gUGljayBhIGJhc2UsIGVuc3VyZSB0aGF0IHRyYW5zZm9ybSByZXN1bHQgd2lsbCBub3QgYmUgKDAsIDApLlxuICB2YXIgaEJhc2UgPSB0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVswXSA9PT0gMCA/IDEgOiBNYXRoLmFicygyICogdHJhbnNmb3JtWzRdIC8gdHJhbnNmb3JtWzBdKTtcbiAgdmFyIHZCYXNlID0gdHJhbnNmb3JtWzRdID09PSAwIHx8IHRyYW5zZm9ybVs1XSA9PT0gMCB8fCB0cmFuc2Zvcm1bMl0gPT09IDAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVsyXSk7XG4gIHZhciB2ZXJ0ZXggPSBbZGlyZWN0aW9uID09PSAnbGVmdCcgPyAtaEJhc2UgOiBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBoQmFzZSA6IDAsIGRpcmVjdGlvbiA9PT0gJ3RvcCcgPyAtdkJhc2UgOiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gdkJhc2UgOiAwXTtcbiAgdmVydGV4ID0gYXBwbHlUcmFuc2Zvcm0odmVydGV4LCB0cmFuc2Zvcm0sIGludmVydCk7XG4gIHJldHVybiBNYXRoLmFicyh2ZXJ0ZXhbMF0pID4gTWF0aC5hYnModmVydGV4WzFdKSA/IHZlcnRleFswXSA+IDAgPyAncmlnaHQnIDogJ2xlZnQnIDogdmVydGV4WzFdID4gMCA/ICdib3R0b20nIDogJ3RvcCc7XG59XG5mdW5jdGlvbiBpc05vdEdyb3VwKGVsKSB7XG4gIHJldHVybiAhZWwuaXNHcm91cDtcbn1cbmZ1bmN0aW9uIGlzUGF0aChlbCkge1xuICByZXR1cm4gZWwuc2hhcGUgIT0gbnVsbDtcbn1cbi8qKlxyXG4gKiBBcHBseSBncm91cCB0cmFuc2l0aW9uIGFuaW1hdGlvbiBmcm9tIGcxIHRvIGcyLlxyXG4gKiBJZiBubyBhbmltYXRhYmxlTW9kZWwsIG5vIGFuaW1hdGlvbi5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBUcmFuc2l0aW9uKGcxLCBnMiwgYW5pbWF0YWJsZU1vZGVsKSB7XG4gIGlmICghZzEgfHwgIWcyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZ1bmN0aW9uIGdldEVsTWFwKGcpIHtcbiAgICB2YXIgZWxNYXAgPSB7fTtcbiAgICBnLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgaWYgKGlzTm90R3JvdXAoZWwpICYmIGVsLmFuaWQpIHtcbiAgICAgICAgZWxNYXBbZWwuYW5pZF0gPSBlbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZWxNYXA7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZVByb3BzKGVsKSB7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIHg6IGVsLngsXG4gICAgICB5OiBlbC55LFxuICAgICAgcm90YXRpb246IGVsLnJvdGF0aW9uXG4gICAgfTtcbiAgICBpZiAoaXNQYXRoKGVsKSkge1xuICAgICAgb2JqLnNoYXBlID0gZXh0ZW5kKHt9LCBlbC5zaGFwZSk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgdmFyIGVsTWFwMSA9IGdldEVsTWFwKGcxKTtcbiAgZzIudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGlzTm90R3JvdXAoZWwpICYmIGVsLmFuaWQpIHtcbiAgICAgIHZhciBvbGRFbCA9IGVsTWFwMVtlbC5hbmlkXTtcbiAgICAgIGlmIChvbGRFbCkge1xuICAgICAgICB2YXIgbmV3UHJvcCA9IGdldEFuaW1hdGFibGVQcm9wcyhlbCk7XG4gICAgICAgIGVsLmF0dHIoZ2V0QW5pbWF0YWJsZVByb3BzKG9sZEVsKSk7XG4gICAgICAgIHVwZGF0ZVByb3BzKGVsLCBuZXdQcm9wLCBhbmltYXRhYmxlTW9kZWwsIGdldEVDRGF0YShlbCkuZGF0YUluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBQb2ludHNCeVJlY3QocG9pbnRzLCByZWN0KSB7XG4gIC8vIEZJWE1FOiBUaGlzIHdheSBtaWdodCBiZSBpbmNvcnJlY3Qgd2hlbiBncmFwaGljIGNsaXBwZWQgYnkgYSBjb3JuZXJcbiAgLy8gYW5kIHdoZW4gZWxlbWVudCBoYXMgYSBib3JkZXIuXG4gIHJldHVybiBtYXAocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgeCA9IHBvaW50WzBdO1xuICAgIHggPSBtYXRoTWF4KHgsIHJlY3QueCk7XG4gICAgeCA9IG1hdGhNaW4oeCwgcmVjdC54ICsgcmVjdC53aWR0aCk7XG4gICAgdmFyIHkgPSBwb2ludFsxXTtcbiAgICB5ID0gbWF0aE1heCh5LCByZWN0LnkpO1xuICAgIHkgPSBtYXRoTWluKHksIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9KTtcbn1cbi8qKlxyXG4gKiBSZXR1cm4gYSBuZXcgY2xpcHBlZCByZWN0LiBJZiByZWN0IHNpemUgYXJlIG5lZ2F0aXZlLCByZXR1cm4gdW5kZWZpbmVkLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGlwUmVjdEJ5UmVjdCh0YXJnZXRSZWN0LCByZWN0KSB7XG4gIHZhciB4ID0gbWF0aE1heCh0YXJnZXRSZWN0LngsIHJlY3QueCk7XG4gIHZhciB4MiA9IG1hdGhNaW4odGFyZ2V0UmVjdC54ICsgdGFyZ2V0UmVjdC53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCk7XG4gIHZhciB5ID0gbWF0aE1heCh0YXJnZXRSZWN0LnksIHJlY3QueSk7XG4gIHZhciB5MiA9IG1hdGhNaW4odGFyZ2V0UmVjdC55ICsgdGFyZ2V0UmVjdC5oZWlnaHQsIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcbiAgLy8gSWYgdGhlIHRvdGFsIHJlY3QgaXMgY2xpcGVkLCBub3RoaW5nLCBpbmNsdWRpbmcgdGhlIGJvcmRlcixcbiAgLy8gc2hvdWxkIGJlIHBhaW50ZWQuIFNvIHJldHVybiB1bmRlZmluZWQuXG4gIGlmICh4MiA+PSB4ICYmIHkyID49IHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB3aWR0aDogeDIgLSB4LFxuICAgICAgaGVpZ2h0OiB5MiAtIHlcbiAgICB9O1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSWNvbihpY29uU3RyLFxuLy8gU3VwcG9ydCAnaW1hZ2U6Ly8nIG9yICdwYXRoOi8vJyBvciBkaXJlY3Qgc3ZnIHBhdGguXG5vcHQsIHJlY3QpIHtcbiAgdmFyIGlubmVyT3B0cyA9IGV4dGVuZCh7XG4gICAgcmVjdEhvdmVyOiB0cnVlXG4gIH0sIG9wdCk7XG4gIHZhciBzdHlsZSA9IGlubmVyT3B0cy5zdHlsZSA9IHtcbiAgICBzdHJva2VOb1NjYWxlOiB0cnVlXG4gIH07XG4gIHJlY3QgPSByZWN0IHx8IHtcbiAgICB4OiAtMSxcbiAgICB5OiAtMSxcbiAgICB3aWR0aDogMixcbiAgICBoZWlnaHQ6IDJcbiAgfTtcbiAgaWYgKGljb25TdHIpIHtcbiAgICByZXR1cm4gaWNvblN0ci5pbmRleE9mKCdpbWFnZTovLycpID09PSAwID8gKHN0eWxlLmltYWdlID0gaWNvblN0ci5zbGljZSg4KSwgZGVmYXVsdHMoc3R5bGUsIHJlY3QpLCBuZXcgWlJJbWFnZShpbm5lck9wdHMpKSA6IG1ha2VQYXRoKGljb25TdHIucmVwbGFjZSgncGF0aDovLycsICcnKSwgaW5uZXJPcHRzLCByZWN0LCAnY2VudGVyJyk7XG4gIH1cbn1cbi8qKlxyXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBnaXZlbiBsaW5lIChsaW5lIGBhYCkgYW5kIHRoZSBnaXZlbiBwb2x5Z29uXHJcbiAqIGFyZSBpbnRlcnNlY3QuXHJcbiAqIE5vdGUgdGhhdCB3ZSBkbyBub3QgY291bnQgY29saW5lYXIgYXMgaW50ZXJzZWN0IGhlcmUgYmVjYXVzZSBub1xyXG4gKiByZXF1aXJlbWVudCBmb3IgdGhhdC4gV2UgY291bGQgZG8gdGhhdCBpZiByZXF1aXJlZCBpbiBmdXR1cmUuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVQb2x5Z29uSW50ZXJzZWN0KGExeCwgYTF5LCBhMngsIGEyeSwgcG9pbnRzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBwMiA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICBpZiAobGluZUxpbmVJbnRlcnNlY3QoYTF4LCBhMXksIGEyeCwgYTJ5LCBwWzBdLCBwWzFdLCBwMlswXSwgcDJbMV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcDIgPSBwO1xuICB9XG59XG4vKipcclxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdHdvIGxpbmVzIChsaW5lIGBhYCBhbmQgbGluZSBgYmApXHJcbiAqIGFyZSBpbnRlcnNlY3QuXHJcbiAqIE5vdGUgdGhhdCB3ZSBkbyBub3QgY291bnQgY29saW5lYXIgYXMgaW50ZXJzZWN0IGhlcmUgYmVjYXVzZSBub1xyXG4gKiByZXF1aXJlbWVudCBmb3IgdGhhdC4gV2UgY291bGQgZG8gdGhhdCBpZiByZXF1aXJlZCBpbiBmdXR1cmUuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVMaW5lSW50ZXJzZWN0KGExeCwgYTF5LCBhMngsIGEyeSwgYjF4LCBiMXksIGIyeCwgYjJ5KSB7XG4gIC8vIGxldCBgdmVjX21gIHRvIGJlIGB2ZWNfYTIgLSB2ZWNfYTFgIGFuZCBgdmVjX25gIHRvIGJlIGB2ZWNfYjIgLSB2ZWNfYjFgLlxuICB2YXIgbXggPSBhMnggLSBhMXg7XG4gIHZhciBteSA9IGEyeSAtIGExeTtcbiAgdmFyIG54ID0gYjJ4IC0gYjF4O1xuICB2YXIgbnkgPSBiMnkgLSBiMXk7XG4gIC8vIGB2ZWNfbWAgYW5kIGB2ZWNfbmAgYXJlIHBhcmFsbGVsIGlmZlxuICAvLyAgICAgZXhpc3RpbmcgYGtgIHN1Y2ggdGhhdCBgdmVjX20gPSBrIMK3IHZlY19uYCwgZXF1aXZhbGVudCB0byBgdmVjX20gWCB2ZWNfbiA9IDBgLlxuICB2YXIgbm1Dcm9zc1Byb2R1Y3QgPSBjcm9zc1Byb2R1Y3QyZChueCwgbnksIG14LCBteSk7XG4gIGlmIChuZWFyWmVybyhubUNyb3NzUHJvZHVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gYHZlY19tYCBhbmQgYHZlY19uYCBhcmUgaW50ZXJzZWN0IGlmZlxuICAvLyAgICAgZXhpc3RpbmcgYHBgIGFuZCBgcWAgaW4gWzAsIDFdIHN1Y2ggdGhhdCBgdmVjX2ExICsgcCAqIHZlY19tID0gdmVjX2IxICsgcSAqIHZlY19uYCxcbiAgLy8gICAgIHN1Y2ggdGhhdCBgcSA9ICgodmVjX2ExIC0gdmVjX2IxKSBYIHZlY19tKSAvICh2ZWNfbiBYIHZlY19tKWBcbiAgLy8gICAgICAgICAgIGFuZCBgcCA9ICgodmVjX2ExIC0gdmVjX2IxKSBYIHZlY19uKSAvICh2ZWNfbiBYIHZlY19tKWAuXG4gIHZhciBiMWExeCA9IGExeCAtIGIxeDtcbiAgdmFyIGIxYTF5ID0gYTF5IC0gYjF5O1xuICB2YXIgcSA9IGNyb3NzUHJvZHVjdDJkKGIxYTF4LCBiMWExeSwgbXgsIG15KSAvIG5tQ3Jvc3NQcm9kdWN0O1xuICBpZiAocSA8IDAgfHwgcSA+IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHAgPSBjcm9zc1Byb2R1Y3QyZChiMWExeCwgYjFhMXksIG54LCBueSkgLyBubUNyb3NzUHJvZHVjdDtcbiAgaWYgKHAgPCAwIHx8IHAgPiAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuLyoqXHJcbiAqIENyb3NzIHByb2R1Y3Qgb2YgMi1kaW1lbnNpb24gdmVjdG9yLlxyXG4gKi9cbmZ1bmN0aW9uIGNyb3NzUHJvZHVjdDJkKHgxLCB5MSwgeDIsIHkyKSB7XG4gIHJldHVybiB4MSAqIHkyIC0geDIgKiB5MTtcbn1cbmZ1bmN0aW9uIG5lYXJaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsIDw9IDFlLTYgJiYgdmFsID49IC0xZS02O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldFRvb2x0aXBDb25maWcob3B0KSB7XG4gIHZhciBpdGVtVG9vbHRpcE9wdGlvbiA9IG9wdC5pdGVtVG9vbHRpcE9wdGlvbjtcbiAgdmFyIGNvbXBvbmVudE1vZGVsID0gb3B0LmNvbXBvbmVudE1vZGVsO1xuICB2YXIgaXRlbU5hbWUgPSBvcHQuaXRlbU5hbWU7XG4gIHZhciBpdGVtVG9vbHRpcE9wdGlvbk9iaiA9IGlzU3RyaW5nKGl0ZW1Ub29sdGlwT3B0aW9uKSA/IHtcbiAgICBmb3JtYXR0ZXI6IGl0ZW1Ub29sdGlwT3B0aW9uXG4gIH0gOiBpdGVtVG9vbHRpcE9wdGlvbjtcbiAgdmFyIG1haW5UeXBlID0gY29tcG9uZW50TW9kZWwubWFpblR5cGU7XG4gIHZhciBjb21wb25lbnRJbmRleCA9IGNvbXBvbmVudE1vZGVsLmNvbXBvbmVudEluZGV4O1xuICB2YXIgZm9ybWF0dGVyUGFyYW1zID0ge1xuICAgIGNvbXBvbmVudFR5cGU6IG1haW5UeXBlLFxuICAgIG5hbWU6IGl0ZW1OYW1lLFxuICAgICR2YXJzOiBbJ25hbWUnXVxuICB9O1xuICBmb3JtYXR0ZXJQYXJhbXNbbWFpblR5cGUgKyAnSW5kZXgnXSA9IGNvbXBvbmVudEluZGV4O1xuICB2YXIgZm9ybWF0dGVyUGFyYW1zRXh0cmEgPSBvcHQuZm9ybWF0dGVyUGFyYW1zRXh0cmE7XG4gIGlmIChmb3JtYXR0ZXJQYXJhbXNFeHRyYSkge1xuICAgIGVhY2goa2V5cyhmb3JtYXR0ZXJQYXJhbXNFeHRyYSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghaGFzT3duKGZvcm1hdHRlclBhcmFtcywga2V5KSkge1xuICAgICAgICBmb3JtYXR0ZXJQYXJhbXNba2V5XSA9IGZvcm1hdHRlclBhcmFtc0V4dHJhW2tleV07XG4gICAgICAgIGZvcm1hdHRlclBhcmFtcy4kdmFycy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdmFyIGVjRGF0YSA9IGdldEVDRGF0YShvcHQuZWwpO1xuICBlY0RhdGEuY29tcG9uZW50TWFpblR5cGUgPSBtYWluVHlwZTtcbiAgZWNEYXRhLmNvbXBvbmVudEluZGV4ID0gY29tcG9uZW50SW5kZXg7XG4gIGVjRGF0YS50b29sdGlwQ29uZmlnID0ge1xuICAgIG5hbWU6IGl0ZW1OYW1lLFxuICAgIG9wdGlvbjogZGVmYXVsdHMoe1xuICAgICAgY29udGVudDogaXRlbU5hbWUsXG4gICAgICBlbmNvZGVIVE1MQ29udGVudDogdHJ1ZSxcbiAgICAgIGZvcm1hdHRlclBhcmFtczogZm9ybWF0dGVyUGFyYW1zXG4gICAgfSwgaXRlbVRvb2x0aXBPcHRpb25PYmopXG4gIH07XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUVsZW1lbnQoZWwsIGNiKSB7XG4gIHZhciBzdG9wcGVkO1xuICAvLyBUT0RPXG4gIC8vIFBvbHlmaWxsIGZvciBmaXhpbmcgenJlbmRlciBncm91cCB0cmF2ZXJzZSBkb24ndCB2aXNpdCBpdCdzIHJvb3QgaXNzdWUuXG4gIGlmIChlbC5pc0dyb3VwKSB7XG4gICAgc3RvcHBlZCA9IGNiKGVsKTtcbiAgfVxuICBpZiAoIXN0b3BwZWQpIHtcbiAgICBlbC50cmF2ZXJzZShjYik7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZUVsZW1lbnRzKGVscywgY2IpIHtcbiAgaWYgKGVscykge1xuICAgIGlmIChpc0FycmF5KGVscykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyYXZlcnNlRWxlbWVudChlbHNbaV0sIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJhdmVyc2VFbGVtZW50KGVscywgY2IpO1xuICAgIH1cbiAgfVxufVxuLy8gUmVnaXN0ZXIgYnVpbHQtaW4gc2hhcGVzLiBUaGVzZSBzaGFwZXMgbWlnaHQgYmUgb3ZlcndyaXR0ZW5cbi8vIGJ5IHVzZXJzLCBhbHRob3VnaCB3ZSBkbyBub3QgcmVjb21tZW5kIHRoYXQuXG5yZWdpc3RlclNoYXBlKCdjaXJjbGUnLCBDaXJjbGUpO1xucmVnaXN0ZXJTaGFwZSgnZWxsaXBzZScsIEVsbGlwc2UpO1xucmVnaXN0ZXJTaGFwZSgnc2VjdG9yJywgU2VjdG9yKTtcbnJlZ2lzdGVyU2hhcGUoJ3JpbmcnLCBSaW5nKTtcbnJlZ2lzdGVyU2hhcGUoJ3BvbHlnb24nLCBQb2x5Z29uKTtcbnJlZ2lzdGVyU2hhcGUoJ3BvbHlsaW5lJywgUG9seWxpbmUpO1xucmVnaXN0ZXJTaGFwZSgncmVjdCcsIFJlY3QpO1xucmVnaXN0ZXJTaGFwZSgnbGluZScsIExpbmUpO1xucmVnaXN0ZXJTaGFwZSgnYmV6aWVyQ3VydmUnLCBCZXppZXJDdXJ2ZSk7XG5yZWdpc3RlclNoYXBlKCdhcmMnLCBBcmMpO1xuZXhwb3J0IHsgR3JvdXAsIFpSSW1hZ2UgYXMgSW1hZ2UsIFpSVGV4dCBhcyBUZXh0LCBDaXJjbGUsIEVsbGlwc2UsIFNlY3RvciwgUmluZywgUG9seWdvbiwgUG9seWxpbmUsIFJlY3QsIExpbmUsIEJlemllckN1cnZlLCBBcmMsIEluY3JlbWVudGFsRGlzcGxheWFibGUsIENvbXBvdW5kUGF0aCwgTGluZWFyR3JhZGllbnQsIFJhZGlhbEdyYWRpZW50LCBCb3VuZGluZ1JlY3QsIE9yaWVudGVkQm91bmRpbmdSZWN0LCBQb2ludCwgUGF0aCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///43199\n")},47411:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   R: () => (/* binding */ findEventDispatcher)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nfunction findEventDispatcher(target, det, returnFirstMatch) {\n  var found;\n  while (target) {\n    if (det(target)) {\n      found = target;\n      if (returnFirstMatch) {\n        break;\n      }\n    }\n    target = target.__hostTarget || target.parent;\n  }\n  return found;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc0MTEuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL2V2ZW50LmpzP2IwMmQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5leHBvcnQgZnVuY3Rpb24gZmluZEV2ZW50RGlzcGF0Y2hlcih0YXJnZXQsIGRldCwgcmV0dXJuRmlyc3RNYXRjaCkge1xuICB2YXIgZm91bmQ7XG4gIHdoaWxlICh0YXJnZXQpIHtcbiAgICBpZiAoZGV0KHRhcmdldCkpIHtcbiAgICAgIGZvdW5kID0gdGFyZ2V0O1xuICAgICAgaWYgKHJldHVybkZpcnN0TWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRhcmdldCA9IHRhcmdldC5fX2hvc3RUYXJnZXQgfHwgdGFyZ2V0LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZm91bmQ7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///47411\n')},48170:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $r: () => (/* binding */ makeInner),\n/* harmony export */   Bq: () => (/* binding */ setAttribute),\n/* harmony export */   D$: () => (/* binding */ getAttribute),\n/* harmony export */   D6: () => (/* binding */ compressBatches),\n/* harmony export */   GX: () => (/* binding */ setComponentTypeToKeyInfo),\n/* harmony export */   HB: () => (/* binding */ preParseFinder),\n/* harmony export */   Il: () => (/* binding */ interpolateRawValues),\n/* harmony export */   JO: () => (/* binding */ queryReferringComponents),\n/* harmony export */   JS: () => (/* binding */ TEXT_STYLE_OPTIONS),\n/* harmony export */   M5: () => (/* binding */ defaultEmphasis),\n/* harmony export */   O0: () => (/* binding */ isNameSpecified),\n/* harmony export */   O2: () => (/* binding */ mappingToExists),\n/* harmony export */   S_: () => (/* binding */ makeInternalComponentId),\n/* harmony export */   Sq: () => (/* binding */ groupData),\n/* harmony export */   US: () => (/* binding */ SINGLE_REFERRING),\n/* harmony export */   UW: () => (/* binding */ MULTIPLE_REFERRING),\n/* harmony export */   XJ: () => (/* binding */ getTooltipRenderMode),\n/* harmony export */   _e: () => (/* binding */ parseFinder),\n/* harmony export */   le: () => (/* binding */ queryDataIndex),\n/* harmony export */   oh: () => (/* binding */ isComponentIdInternal),\n/* harmony export */   qB: () => (/* binding */ normalizeToArray),\n/* harmony export */   vS: () => (/* binding */ convertOptionIdName),\n/* harmony export */   vj: () => (/* binding */ getDataItemValue),\n/* harmony export */   zu: () => (/* binding */ isDataItemOption)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var zrender_lib_core_env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38123);\n/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24326);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n/**\r\n * Make the name displayable. But we should\r\n * make sure it is not duplicated with user\r\n * specified name, so use '\\0';\r\n */\nvar DUMMY_COMPONENT_NAME_PREFIX = 'series\\0';\nvar INTERNAL_COMPONENT_ID_PREFIX = '\\0_ec_\\0';\n/**\r\n * If value is not array, then translate it to array.\r\n * @param  {*} value\r\n * @return {Array} [value] or value\r\n */\nfunction normalizeToArray(value) {\n  return value instanceof Array ? value : value == null ? [] : [value];\n}\n/**\r\n * Sync default option between normal and emphasis like `position` and `show`\r\n * In case some one will write code like\r\n *     label: {\r\n *          show: false,\r\n *          position: 'outside',\r\n *          fontSize: 18\r\n *     },\r\n *     emphasis: {\r\n *          label: { show: true }\r\n *     }\r\n */\nfunction defaultEmphasis(opt, key, subOpts) {\n  // Caution: performance sensitive.\n  if (opt) {\n    opt[key] = opt[key] || {};\n    opt.emphasis = opt.emphasis || {};\n    opt.emphasis[key] = opt.emphasis[key] || {};\n    // Default emphasis option from normal\n    for (var i = 0, len = subOpts.length; i < len; i++) {\n      var subOptName = subOpts[i];\n      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {\n        opt.emphasis[key][subOptName] = opt[key][subOptName];\n      }\n    }\n  }\n}\nvar TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding'];\n// modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n//     // FIXME: deprecated, check and remove it.\n//     'textStyle'\n// ]);\n/**\r\n * The method does not ensure performance.\r\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\r\n * This helper method retrieves value from data.\r\n */\nfunction getDataItemValue(dataItem) {\n  return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(dataItem) && !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;\n}\n/**\r\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\r\n * This helper method determine if dataItem has extra option besides value\r\n */\nfunction isDataItemOption(dataItem) {\n  return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(dataItem) && !(dataItem instanceof Array);\n  // // markLine data can be array\n  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n}\n;\n/**\r\n * Mapping to existings for merge.\r\n *\r\n * Mode \"normalMege\":\r\n *     The mapping result (merge result) will keep the order of the existing\r\n *     component, rather than the order of new option. Because we should ensure\r\n *     some specified index reference (like xAxisIndex) keep work.\r\n *     And in most cases, \"merge option\" is used to update partial option but not\r\n *     be expected to change the order.\r\n *\r\n * Mode \"replaceMege\":\r\n *     (1) Only the id mapped components will be merged.\r\n *     (2) Other existing components (except internal components) will be removed.\r\n *     (3) Other new options will be used to create new component.\r\n *     (4) The index of the existing components will not be modified.\r\n *     That means their might be \"hole\" after the removal.\r\n *     The new components are created first at those available index.\r\n *\r\n * Mode \"replaceAll\":\r\n *     This mode try to support that reproduce an echarts instance from another\r\n *     echarts instance (via `getOption`) in some simple cases.\r\n *     In this scenario, the `result` index are exactly the consistent with the `newCmptOptions`,\r\n *     which ensures the component index referring (like `xAxisIndex: ?`) corrent. That is,\r\n *     the \"hole\" in `newCmptOptions` will also be kept.\r\n *     On the contrary, other modes try best to eliminate holes.\r\n *     PENDING: This is an experimental mode yet.\r\n *\r\n * @return See the comment of <MappingResult>.\r\n */\nfunction mappingToExists(existings, newCmptOptions, mode) {\n  var isNormalMergeMode = mode === 'normalMerge';\n  var isReplaceMergeMode = mode === 'replaceMerge';\n  var isReplaceAllMode = mode === 'replaceAll';\n  existings = existings || [];\n  newCmptOptions = (newCmptOptions || []).slice();\n  var existingIdIdxMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();\n  // Validate id and name on user input option.\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(newCmptOptions, function (cmptOption, index) {\n    if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(cmptOption)) {\n      newCmptOptions[index] = null;\n      return;\n    }\n    if (false) {}\n  });\n  var result = prepareResult(existings, existingIdIdxMap, mode);\n  if (isNormalMergeMode || isReplaceMergeMode) {\n    mappingById(result, existings, existingIdIdxMap, newCmptOptions);\n  }\n  if (isNormalMergeMode) {\n    mappingByName(result, newCmptOptions);\n  }\n  if (isNormalMergeMode || isReplaceMergeMode) {\n    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);\n  } else if (isReplaceAllMode) {\n    mappingInReplaceAllMode(result, newCmptOptions);\n  }\n  makeIdAndName(result);\n  // The array `result` MUST NOT contain elided items, otherwise the\n  // forEach will omit those items and result in incorrect result.\n  return result;\n}\nfunction prepareResult(existings, existingIdIdxMap, mode) {\n  var result = [];\n  if (mode === 'replaceAll') {\n    return result;\n  }\n  // Do not use native `map` to in case that the array `existings`\n  // contains elided items, which will be omitted.\n  for (var index = 0; index < existings.length; index++) {\n    var existing = existings[index];\n    // Because of replaceMerge, `existing` may be null/undefined.\n    if (existing && existing.id != null) {\n      existingIdIdxMap.set(existing.id, index);\n    }\n    // For non-internal-componnets:\n    //     Mode \"normalMerge\": all existings kept.\n    //     Mode \"replaceMerge\": all existing removed unless mapped by id.\n    // For internal-components:\n    //     go with \"replaceMerge\" approach in both mode.\n    result.push({\n      existing: mode === 'replaceMerge' || isComponentIdInternal(existing) ? null : existing,\n      newOption: null,\n      keyInfo: null,\n      brandNew: null\n    });\n  }\n  return result;\n}\nfunction mappingById(result, existings, existingIdIdxMap, newCmptOptions) {\n  // Mapping by id if specified.\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(newCmptOptions, function (cmptOption, index) {\n    if (!cmptOption || cmptOption.id == null) {\n      return;\n    }\n    var optionId = makeComparableKey(cmptOption.id);\n    var existingIdx = existingIdIdxMap.get(optionId);\n    if (existingIdx != null) {\n      var resultItem = result[existingIdx];\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!resultItem.newOption, 'Duplicated option on id \"' + optionId + '\".');\n      resultItem.newOption = cmptOption;\n      // In both mode, if id matched, new option will be merged to\n      // the existings rather than creating new component model.\n      resultItem.existing = existings[existingIdx];\n      newCmptOptions[index] = null;\n    }\n  });\n}\nfunction mappingByName(result, newCmptOptions) {\n  // Mapping by name if specified.\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(newCmptOptions, function (cmptOption, index) {\n    if (!cmptOption || cmptOption.name == null) {\n      return;\n    }\n    for (var i = 0; i < result.length; i++) {\n      var existing = result[i].existing;\n      if (!result[i].newOption // Consider name: two map to one.\n      // Can not match when both ids existing but different.\n      && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual('name', existing, cmptOption)) {\n        result[i].newOption = cmptOption;\n        newCmptOptions[index] = null;\n        return;\n      }\n    }\n  });\n}\nfunction mappingByIndex(result, newCmptOptions, brandNew) {\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(newCmptOptions, function (cmptOption) {\n    if (!cmptOption) {\n      return;\n    }\n    // Find the first place that not mapped by id and not internal component (consider the \"hole\").\n    var resultItem;\n    var nextIdx = 0;\n    while (\n    // Be `!resultItem` only when `nextIdx >= result.length`.\n    (resultItem = result[nextIdx]\n    // (1) Existing models that already have id should be able to mapped to. Because\n    // after mapping performed, model will always be assigned with an id if user not given.\n    // After that all models have id.\n    // (2) If new option has id, it can only set to a hole or append to the last. It should\n    // not be merged to the existings with different id. Because id should not be overwritten.\n    // (3) Name can be overwritten, because axis use name as 'show label text'.\n    ) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) ||\n    // In mode \"replaceMerge\", here no not-mapped-non-internal-existing.\n    resultItem.existing && cmptOption.id != null && !keyExistAndEqual('id', cmptOption, resultItem.existing))) {\n      nextIdx++;\n    }\n    if (resultItem) {\n      resultItem.newOption = cmptOption;\n      resultItem.brandNew = brandNew;\n    } else {\n      result.push({\n        newOption: cmptOption,\n        brandNew: brandNew,\n        existing: null,\n        keyInfo: null\n      });\n    }\n    nextIdx++;\n  });\n}\nfunction mappingInReplaceAllMode(result, newCmptOptions) {\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(newCmptOptions, function (cmptOption) {\n    // The feature \"reproduce\" requires \"hole\" will also reproduced\n    // in case that component index referring are broken.\n    result.push({\n      newOption: cmptOption,\n      brandNew: true,\n      existing: null,\n      keyInfo: null\n    });\n  });\n}\n/**\r\n * Make id and name for mapping result (result of mappingToExists)\r\n * into `keyInfo` field.\r\n */\nfunction makeIdAndName(mapResult) {\n  // We use this id to hash component models and view instances\n  // in echarts. id can be specified by user, or auto generated.\n  // The id generation rule ensures new view instance are able\n  // to mapped to old instance when setOption are called in\n  // no-merge mode. So we generate model id by name and plus\n  // type in view id.\n  // name can be duplicated among components, which is convenient\n  // to specify multi components (like series) by one name.\n  // Ensure that each id is distinct.\n  var idMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(mapResult, function (item) {\n    var existing = item.existing;\n    existing && idMap.set(existing.id, item);\n  });\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(mapResult, function (item) {\n    var opt = item.newOption;\n    // Force ensure id not duplicated.\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));\n    opt && opt.id != null && idMap.set(opt.id, item);\n    !item.keyInfo && (item.keyInfo = {});\n  });\n  // Make name and id.\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(mapResult, function (item, index) {\n    var existing = item.existing;\n    var opt = item.newOption;\n    var keyInfo = item.keyInfo;\n    if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(opt)) {\n      return;\n    }\n    // Name can be overwritten. Consider case: axis.name = '20km'.\n    // But id generated by name will not be changed, which affect\n    // only in that case: setOption with 'not merge mode' and view\n    // instance will be recreated, which can be accepted.\n    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name\n    // Avoid that different series has the same name,\n    // because name may be used like in color pallet.\n    : DUMMY_COMPONENT_NAME_PREFIX + index;\n    if (existing) {\n      keyInfo.id = makeComparableKey(existing.id);\n    } else if (opt.id != null) {\n      keyInfo.id = makeComparableKey(opt.id);\n    } else {\n      // Consider this situatoin:\n      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n      //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n      // Series with the same name between optionA and optionB\n      // should be mapped.\n      var idNum = 0;\n      do {\n        keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n      } while (idMap.get(keyInfo.id));\n    }\n    idMap.set(keyInfo.id, item);\n  });\n}\nfunction keyExistAndEqual(attr, obj1, obj2) {\n  var key1 = convertOptionIdName(obj1[attr], null);\n  var key2 = convertOptionIdName(obj2[attr], null);\n  // See `MappingExistingItem`. `id` and `name` trade string equals to number.\n  return key1 != null && key2 != null && key1 === key2;\n}\n/**\r\n * @return return null if not exist.\r\n */\nfunction makeComparableKey(val) {\n  if (false) {}\n  return convertOptionIdName(val, '');\n}\nfunction convertOptionIdName(idOrName, defaultValue) {\n  if (idOrName == null) {\n    return defaultValue;\n  }\n  return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString)(idOrName) ? idOrName : (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(idOrName) || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isStringSafe)(idOrName) ? idOrName + '' : defaultValue;\n}\nfunction warnInvalidateIdOrName(idOrName) {\n  if (false) {}\n}\nfunction isValidIdOrName(idOrName) {\n  return isStringSafe(idOrName) || isNumeric(idOrName);\n}\nfunction isNameSpecified(componentModel) {\n  var name = componentModel.name;\n  // Is specified when `indexOf` get -1 or > 0.\n  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));\n}\n/**\r\n * @public\r\n * @param {Object} cmptOption\r\n * @return {boolean}\r\n */\nfunction isComponentIdInternal(cmptOption) {\n  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;\n}\nfunction makeInternalComponentId(idSuffix) {\n  return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;\n}\nfunction setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {\n  // Set mainType and complete subType.\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(mappingResult, function (item) {\n    var newOption = item.newOption;\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(newOption)) {\n      item.keyInfo.mainType = mainType;\n      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);\n    }\n  });\n}\nfunction determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {\n  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType\n  // Use determineSubType only when there is no existComponent.\n  : componentModelCtor.determineSubType(mainType, newCmptOption);\n  // tooltip, markline, markpoint may always has no subType\n  return subType;\n}\n/**\r\n * A helper for removing duplicate items between batchA and batchB,\r\n * and in themselves, and categorize by series.\r\n *\r\n * @param batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\r\n * @param batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\r\n * @return result: [resultBatchA, resultBatchB]\r\n */\nfunction compressBatches(batchA, batchB) {\n  var mapA = {};\n  var mapB = {};\n  makeMap(batchA || [], mapA);\n  makeMap(batchB || [], mapB, mapA);\n  return [mapToArray(mapA), mapToArray(mapB)];\n  function makeMap(sourceBatch, map, otherMap) {\n    for (var i = 0, len = sourceBatch.length; i < len; i++) {\n      var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);\n      if (seriesId == null) {\n        return;\n      }\n      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\n      var otherDataIndices = otherMap && otherMap[seriesId];\n      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n        var dataIndex = dataIndices[j];\n        if (otherDataIndices && otherDataIndices[dataIndex]) {\n          otherDataIndices[dataIndex] = null;\n        } else {\n          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n        }\n      }\n    }\n  }\n  function mapToArray(map, isData) {\n    var result = [];\n    for (var i in map) {\n      if (map.hasOwnProperty(i) && map[i] != null) {\n        if (isData) {\n          result.push(+i);\n        } else {\n          var dataIndices = mapToArray(map[i], true);\n          dataIndices.length && result.push({\n            seriesId: i,\n            dataIndex: dataIndices\n          });\n        }\n      }\n    }\n    return result;\n  }\n}\n/**\r\n * @param payload Contains dataIndex (means rawIndex) / dataIndexInside / name\r\n *                         each of which can be Array or primary type.\r\n * @return dataIndex If not found, return undefined/null.\r\n */\nfunction queryDataIndex(data, payload) {\n  if (payload.dataIndexInside != null) {\n    return payload.dataIndexInside;\n  } else if (payload.dataIndex != null) {\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(payload.dataIndex) ? (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)(payload.dataIndex, function (value) {\n      return data.indexOfRawIndex(value);\n    }) : data.indexOfRawIndex(payload.dataIndex);\n  } else if (payload.name != null) {\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(payload.name) ? (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)(payload.name, function (value) {\n      return data.indexOfName(value);\n    }) : data.indexOfName(payload.name);\n  }\n}\n/**\r\n * Enable property storage to any host object.\r\n * Notice: Serialization is not supported.\r\n *\r\n * For example:\r\n * let inner = zrUitl.makeInner();\r\n *\r\n * function some1(hostObj) {\r\n *      inner(hostObj).someProperty = 1212;\r\n *      ...\r\n * }\r\n * function some2() {\r\n *      let fields = inner(this);\r\n *      fields.someProperty1 = 1212;\r\n *      fields.someProperty2 = 'xx';\r\n *      ...\r\n * }\r\n *\r\n * @return {Function}\r\n */\nfunction makeInner() {\n  var key = '__ec_inner_' + innerUniqueIndex++;\n  return function (hostObj) {\n    return hostObj[key] || (hostObj[key] = {});\n  };\n}\nvar innerUniqueIndex = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .getRandomIdBase */ .IH)();\n/**\r\n * The same behavior as `component.getReferringComponents`.\r\n */\nfunction parseFinder(ecModel, finderInput, opt) {\n  var _a = preParseFinder(finderInput, opt),\n    mainTypeSpecified = _a.mainTypeSpecified,\n    queryOptionMap = _a.queryOptionMap,\n    others = _a.others;\n  var result = others;\n  var defaultMainType = opt ? opt.defaultMainType : null;\n  if (!mainTypeSpecified && defaultMainType) {\n    queryOptionMap.set(defaultMainType, {});\n  }\n  queryOptionMap.each(function (queryOption, mainType) {\n    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {\n      useDefault: defaultMainType === mainType,\n      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,\n      enableNone: opt && opt.enableNone != null ? opt.enableNone : true\n    });\n    result[mainType + 'Models'] = queryResult.models;\n    result[mainType + 'Model'] = queryResult.models[0];\n  });\n  return result;\n}\nfunction preParseFinder(finderInput, opt) {\n  var finder;\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString)(finderInput)) {\n    var obj = {};\n    obj[finderInput + 'Index'] = 0;\n    finder = obj;\n  } else {\n    finder = finderInput;\n  }\n  var queryOptionMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();\n  var others = {};\n  var mainTypeSpecified = false;\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(finder, function (value, key) {\n    // Exclude 'dataIndex' and other illgal keys.\n    if (key === 'dataIndex' || key === 'dataIndexInside') {\n      others[key] = value;\n      return;\n    }\n    var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n    var mainType = parsedKey[1];\n    var queryType = (parsedKey[2] || '').toLowerCase();\n    if (!mainType || !queryType || opt && opt.includeMainTypes && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf)(opt.includeMainTypes, mainType) < 0) {\n      return;\n    }\n    mainTypeSpecified = mainTypeSpecified || !!mainType;\n    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});\n    queryOption[queryType] = value;\n  });\n  return {\n    mainTypeSpecified: mainTypeSpecified,\n    queryOptionMap: queryOptionMap,\n    others: others\n  };\n}\nvar SINGLE_REFERRING = {\n  useDefault: true,\n  enableAll: false,\n  enableNone: false\n};\nvar MULTIPLE_REFERRING = {\n  useDefault: false,\n  enableAll: true,\n  enableNone: true\n};\nfunction queryReferringComponents(ecModel, mainType, userOption, opt) {\n  opt = opt || SINGLE_REFERRING;\n  var indexOption = userOption.index;\n  var idOption = userOption.id;\n  var nameOption = userOption.name;\n  var result = {\n    models: null,\n    specified: indexOption != null || idOption != null || nameOption != null\n  };\n  if (!result.specified) {\n    // Use the first as default if `useDefault`.\n    var firstCmpt = void 0;\n    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];\n    return result;\n  }\n  if (indexOption === 'none' || indexOption === false) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(opt.enableNone, '`\"none\"` or `false` is not a valid value on index option.');\n    result.models = [];\n    return result;\n  }\n  // `queryComponents` will return all components if\n  // both all of index/id/name are null/undefined.\n  if (indexOption === 'all') {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)(opt.enableAll, '`\"all\"` is not a valid value on index option.');\n    indexOption = idOption = nameOption = null;\n  }\n  result.models = ecModel.queryComponents({\n    mainType: mainType,\n    index: indexOption,\n    id: idOption,\n    name: nameOption\n  });\n  return result;\n}\nfunction setAttribute(dom, key, value) {\n  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;\n}\nfunction getAttribute(dom, key) {\n  return dom.getAttribute ? dom.getAttribute(key) : dom[key];\n}\nfunction getTooltipRenderMode(renderModeOption) {\n  if (renderModeOption === 'auto') {\n    // Using html when `document` exists, use richText otherwise\n    return zrender_lib_core_env_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A.domSupported ? 'html' : 'richText';\n  } else {\n    return renderModeOption || 'html';\n  }\n}\n/**\r\n * Group a list by key.\r\n */\nfunction groupData(array, getKey // return key\n) {\n  var buckets = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();\n  var keys = [];\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(array, function (item) {\n    var key = getKey(item);\n    (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);\n  });\n  return {\n    keys: keys,\n    buckets: buckets\n  };\n}\n/**\r\n * Interpolate raw values of a series with percent\r\n *\r\n * @param data         data\r\n * @param labelModel   label model of the text element\r\n * @param sourceValue  start value. May be null/undefined when init.\r\n * @param targetValue  end value\r\n * @param percent      0~1 percentage; 0 uses start value while 1 uses end value\r\n * @return             interpolated values\r\n *                     If `sourceValue` and `targetValue` are `number`, return `number`.\r\n *                     If `sourceValue` and `targetValue` are `string`, return `string`.\r\n *                     If `sourceValue` and `targetValue` are `(string | number)[]`, return `(string | number)[]`.\r\n *                     Other cases do not supported.\r\n */\nfunction interpolateRawValues(data, precision, sourceValue, targetValue, percent) {\n  var isAutoPrecision = precision == null || precision === 'auto';\n  if (targetValue == null) {\n    return targetValue;\n  }\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(targetValue)) {\n    var value = interpolateNumber(sourceValue || 0, targetValue, percent);\n    return (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .round */ .LI)(value, isAutoPrecision ? Math.max((0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .getPrecision */ .XV)(sourceValue || 0), (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .getPrecision */ .XV)(targetValue)) : precision);\n  } else if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString)(targetValue)) {\n    return percent < 1 ? sourceValue : targetValue;\n  } else {\n    var interpolated = [];\n    var leftArr = sourceValue;\n    var rightArr = targetValue;\n    var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);\n    for (var i = 0; i < length_1; ++i) {\n      var info = data.getDimensionInfo(i);\n      // Don't interpolate ordinal dims\n      if (info && info.type === 'ordinal') {\n        // In init, there is no `sourceValue`, but should better not to get undefined result.\n        interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];\n      } else {\n        var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;\n        var rightVal = rightArr[i];\n        var value = interpolateNumber(leftVal, rightVal, percent);\n        interpolated[i] = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .round */ .LI)(value, isAutoPrecision ? Math.max((0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .getPrecision */ .XV)(leftVal), (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .getPrecision */ .XV)(rightVal)) : precision);\n      }\n    }\n    return interpolated;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDgxNzAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvbW9kZWwuanM/OGMwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGVhY2gsIGlzT2JqZWN0LCBpc0FycmF5LCBjcmVhdGVIYXNoTWFwLCBtYXAsIGFzc2VydCwgaXNTdHJpbmcsIGluZGV4T2YsIGlzU3RyaW5nU2FmZSwgaXNOdW1iZXIgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IGVudiBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL2Vudi5qcyc7XG5pbXBvcnQgeyBpc051bWVyaWMsIGdldFJhbmRvbUlkQmFzZSwgZ2V0UHJlY2lzaW9uLCByb3VuZCB9IGZyb20gJy4vbnVtYmVyLmpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuL2xvZy5qcyc7XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihwMCwgcDEsIHBlcmNlbnQpIHtcbiAgcmV0dXJuIChwMSAtIHAwKSAqIHBlcmNlbnQgKyBwMDtcbn1cbi8qKlxyXG4gKiBNYWtlIHRoZSBuYW1lIGRpc3BsYXlhYmxlLiBCdXQgd2Ugc2hvdWxkXHJcbiAqIG1ha2Ugc3VyZSBpdCBpcyBub3QgZHVwbGljYXRlZCB3aXRoIHVzZXJcclxuICogc3BlY2lmaWVkIG5hbWUsIHNvIHVzZSAnXFwwJztcclxuICovXG52YXIgRFVNTVlfQ09NUE9ORU5UX05BTUVfUFJFRklYID0gJ3Nlcmllc1xcMCc7XG52YXIgSU5URVJOQUxfQ09NUE9ORU5UX0lEX1BSRUZJWCA9ICdcXDBfZWNfXFwwJztcbi8qKlxyXG4gKiBJZiB2YWx1ZSBpcyBub3QgYXJyYXksIHRoZW4gdHJhbnNsYXRlIGl0IHRvIGFycmF5LlxyXG4gKiBAcGFyYW0gIHsqfSB2YWx1ZVxyXG4gKiBAcmV0dXJuIHtBcnJheX0gW3ZhbHVlXSBvciB2YWx1ZVxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVUb0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ID8gdmFsdWUgOiB2YWx1ZSA9PSBudWxsID8gW10gOiBbdmFsdWVdO1xufVxuLyoqXHJcbiAqIFN5bmMgZGVmYXVsdCBvcHRpb24gYmV0d2VlbiBub3JtYWwgYW5kIGVtcGhhc2lzIGxpa2UgYHBvc2l0aW9uYCBhbmQgYHNob3dgXHJcbiAqIEluIGNhc2Ugc29tZSBvbmUgd2lsbCB3cml0ZSBjb2RlIGxpa2VcclxuICogICAgIGxhYmVsOiB7XHJcbiAqICAgICAgICAgIHNob3c6IGZhbHNlLFxyXG4gKiAgICAgICAgICBwb3NpdGlvbjogJ291dHNpZGUnLFxyXG4gKiAgICAgICAgICBmb250U2l6ZTogMThcclxuICogICAgIH0sXHJcbiAqICAgICBlbXBoYXNpczoge1xyXG4gKiAgICAgICAgICBsYWJlbDogeyBzaG93OiB0cnVlIH1cclxuICogICAgIH1cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEVtcGhhc2lzKG9wdCwga2V5LCBzdWJPcHRzKSB7XG4gIC8vIENhdXRpb246IHBlcmZvcm1hbmNlIHNlbnNpdGl2ZS5cbiAgaWYgKG9wdCkge1xuICAgIG9wdFtrZXldID0gb3B0W2tleV0gfHwge307XG4gICAgb3B0LmVtcGhhc2lzID0gb3B0LmVtcGhhc2lzIHx8IHt9O1xuICAgIG9wdC5lbXBoYXNpc1trZXldID0gb3B0LmVtcGhhc2lzW2tleV0gfHwge307XG4gICAgLy8gRGVmYXVsdCBlbXBoYXNpcyBvcHRpb24gZnJvbSBub3JtYWxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3ViT3B0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHN1Yk9wdE5hbWUgPSBzdWJPcHRzW2ldO1xuICAgICAgaWYgKCFvcHQuZW1waGFzaXNba2V5XS5oYXNPd25Qcm9wZXJ0eShzdWJPcHROYW1lKSAmJiBvcHRba2V5XS5oYXNPd25Qcm9wZXJ0eShzdWJPcHROYW1lKSkge1xuICAgICAgICBvcHQuZW1waGFzaXNba2V5XVtzdWJPcHROYW1lXSA9IG9wdFtrZXldW3N1Yk9wdE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZXhwb3J0IHZhciBURVhUX1NUWUxFX09QVElPTlMgPSBbJ2ZvbnRTdHlsZScsICdmb250V2VpZ2h0JywgJ2ZvbnRTaXplJywgJ2ZvbnRGYW1pbHknLCAncmljaCcsICd0YWcnLCAnY29sb3InLCAndGV4dEJvcmRlckNvbG9yJywgJ3RleHRCb3JkZXJXaWR0aCcsICd3aWR0aCcsICdoZWlnaHQnLCAnbGluZUhlaWdodCcsICdhbGlnbicsICd2ZXJ0aWNhbEFsaWduJywgJ2Jhc2VsaW5lJywgJ3NoYWRvd0NvbG9yJywgJ3NoYWRvd0JsdXInLCAnc2hhZG93T2Zmc2V0WCcsICdzaGFkb3dPZmZzZXRZJywgJ3RleHRTaGFkb3dDb2xvcicsICd0ZXh0U2hhZG93Qmx1cicsICd0ZXh0U2hhZG93T2Zmc2V0WCcsICd0ZXh0U2hhZG93T2Zmc2V0WScsICdiYWNrZ3JvdW5kQ29sb3InLCAnYm9yZGVyQ29sb3InLCAnYm9yZGVyV2lkdGgnLCAnYm9yZGVyUmFkaXVzJywgJ3BhZGRpbmcnXTtcbi8vIG1vZGVsVXRpbC5MQUJFTF9PUFRJT05TID0gbW9kZWxVdGlsLlRFWFRfU1RZTEVfT1BUSU9OUy5jb25jYXQoW1xuLy8gICAgICdwb3NpdGlvbicsICdvZmZzZXQnLCAncm90YXRlJywgJ29yaWdpbicsICdzaG93JywgJ2Rpc3RhbmNlJywgJ2Zvcm1hdHRlcicsXG4vLyAgICAgJ2ZvbnRTdHlsZScsICdmb250V2VpZ2h0JywgJ2ZvbnRTaXplJywgJ2ZvbnRGYW1pbHknLFxuLy8gICAgIC8vIEZJWE1FOiBkZXByZWNhdGVkLCBjaGVjayBhbmQgcmVtb3ZlIGl0LlxuLy8gICAgICd0ZXh0U3R5bGUnXG4vLyBdKTtcbi8qKlxyXG4gKiBUaGUgbWV0aG9kIGRvZXMgbm90IGVuc3VyZSBwZXJmb3JtYW5jZS5cclxuICogZGF0YSBjb3VsZCBiZSBbMTIsIDIzMjMsIHt2YWx1ZTogMjIzfSwgWzEyMjEsIDIzXSwge3ZhbHVlOiBbMiwgMjNdfV1cclxuICogVGhpcyBoZWxwZXIgbWV0aG9kIHJldHJpZXZlcyB2YWx1ZSBmcm9tIGRhdGEuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFJdGVtVmFsdWUoZGF0YUl0ZW0pIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGRhdGFJdGVtKSAmJiAhaXNBcnJheShkYXRhSXRlbSkgJiYgIShkYXRhSXRlbSBpbnN0YW5jZW9mIERhdGUpID8gZGF0YUl0ZW0udmFsdWUgOiBkYXRhSXRlbTtcbn1cbi8qKlxyXG4gKiBkYXRhIGNvdWxkIGJlIFsxMiwgMjMyMywge3ZhbHVlOiAyMjN9LCBbMTIyMSwgMjNdLCB7dmFsdWU6IFsyLCAyM119XVxyXG4gKiBUaGlzIGhlbHBlciBtZXRob2QgZGV0ZXJtaW5lIGlmIGRhdGFJdGVtIGhhcyBleHRyYSBvcHRpb24gYmVzaWRlcyB2YWx1ZVxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGFJdGVtT3B0aW9uKGRhdGFJdGVtKSB7XG4gIHJldHVybiBpc09iamVjdChkYXRhSXRlbSkgJiYgIShkYXRhSXRlbSBpbnN0YW5jZW9mIEFycmF5KTtcbiAgLy8gLy8gbWFya0xpbmUgZGF0YSBjYW4gYmUgYXJyYXlcbiAgLy8gJiYgIShkYXRhSXRlbVswXSAmJiBpc09iamVjdChkYXRhSXRlbVswXSkgJiYgIShkYXRhSXRlbVswXSBpbnN0YW5jZW9mIEFycmF5KSk7XG59XG47XG4vKipcclxuICogTWFwcGluZyB0byBleGlzdGluZ3MgZm9yIG1lcmdlLlxyXG4gKlxyXG4gKiBNb2RlIFwibm9ybWFsTWVnZVwiOlxyXG4gKiAgICAgVGhlIG1hcHBpbmcgcmVzdWx0IChtZXJnZSByZXN1bHQpIHdpbGwga2VlcCB0aGUgb3JkZXIgb2YgdGhlIGV4aXN0aW5nXHJcbiAqICAgICBjb21wb25lbnQsIHJhdGhlciB0aGFuIHRoZSBvcmRlciBvZiBuZXcgb3B0aW9uLiBCZWNhdXNlIHdlIHNob3VsZCBlbnN1cmVcclxuICogICAgIHNvbWUgc3BlY2lmaWVkIGluZGV4IHJlZmVyZW5jZSAobGlrZSB4QXhpc0luZGV4KSBrZWVwIHdvcmsuXHJcbiAqICAgICBBbmQgaW4gbW9zdCBjYXNlcywgXCJtZXJnZSBvcHRpb25cIiBpcyB1c2VkIHRvIHVwZGF0ZSBwYXJ0aWFsIG9wdGlvbiBidXQgbm90XHJcbiAqICAgICBiZSBleHBlY3RlZCB0byBjaGFuZ2UgdGhlIG9yZGVyLlxyXG4gKlxyXG4gKiBNb2RlIFwicmVwbGFjZU1lZ2VcIjpcclxuICogICAgICgxKSBPbmx5IHRoZSBpZCBtYXBwZWQgY29tcG9uZW50cyB3aWxsIGJlIG1lcmdlZC5cclxuICogICAgICgyKSBPdGhlciBleGlzdGluZyBjb21wb25lbnRzIChleGNlcHQgaW50ZXJuYWwgY29tcG9uZW50cykgd2lsbCBiZSByZW1vdmVkLlxyXG4gKiAgICAgKDMpIE90aGVyIG5ldyBvcHRpb25zIHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgbmV3IGNvbXBvbmVudC5cclxuICogICAgICg0KSBUaGUgaW5kZXggb2YgdGhlIGV4aXN0aW5nIGNvbXBvbmVudHMgd2lsbCBub3QgYmUgbW9kaWZpZWQuXHJcbiAqICAgICBUaGF0IG1lYW5zIHRoZWlyIG1pZ2h0IGJlIFwiaG9sZVwiIGFmdGVyIHRoZSByZW1vdmFsLlxyXG4gKiAgICAgVGhlIG5ldyBjb21wb25lbnRzIGFyZSBjcmVhdGVkIGZpcnN0IGF0IHRob3NlIGF2YWlsYWJsZSBpbmRleC5cclxuICpcclxuICogTW9kZSBcInJlcGxhY2VBbGxcIjpcclxuICogICAgIFRoaXMgbW9kZSB0cnkgdG8gc3VwcG9ydCB0aGF0IHJlcHJvZHVjZSBhbiBlY2hhcnRzIGluc3RhbmNlIGZyb20gYW5vdGhlclxyXG4gKiAgICAgZWNoYXJ0cyBpbnN0YW5jZSAodmlhIGBnZXRPcHRpb25gKSBpbiBzb21lIHNpbXBsZSBjYXNlcy5cclxuICogICAgIEluIHRoaXMgc2NlbmFyaW8sIHRoZSBgcmVzdWx0YCBpbmRleCBhcmUgZXhhY3RseSB0aGUgY29uc2lzdGVudCB3aXRoIHRoZSBgbmV3Q21wdE9wdGlvbnNgLFxyXG4gKiAgICAgd2hpY2ggZW5zdXJlcyB0aGUgY29tcG9uZW50IGluZGV4IHJlZmVycmluZyAobGlrZSBgeEF4aXNJbmRleDogP2ApIGNvcnJlbnQuIFRoYXQgaXMsXHJcbiAqICAgICB0aGUgXCJob2xlXCIgaW4gYG5ld0NtcHRPcHRpb25zYCB3aWxsIGFsc28gYmUga2VwdC5cclxuICogICAgIE9uIHRoZSBjb250cmFyeSwgb3RoZXIgbW9kZXMgdHJ5IGJlc3QgdG8gZWxpbWluYXRlIGhvbGVzLlxyXG4gKiAgICAgUEVORElORzogVGhpcyBpcyBhbiBleHBlcmltZW50YWwgbW9kZSB5ZXQuXHJcbiAqXHJcbiAqIEByZXR1cm4gU2VlIHRoZSBjb21tZW50IG9mIDxNYXBwaW5nUmVzdWx0Pi5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwcGluZ1RvRXhpc3RzKGV4aXN0aW5ncywgbmV3Q21wdE9wdGlvbnMsIG1vZGUpIHtcbiAgdmFyIGlzTm9ybWFsTWVyZ2VNb2RlID0gbW9kZSA9PT0gJ25vcm1hbE1lcmdlJztcbiAgdmFyIGlzUmVwbGFjZU1lcmdlTW9kZSA9IG1vZGUgPT09ICdyZXBsYWNlTWVyZ2UnO1xuICB2YXIgaXNSZXBsYWNlQWxsTW9kZSA9IG1vZGUgPT09ICdyZXBsYWNlQWxsJztcbiAgZXhpc3RpbmdzID0gZXhpc3RpbmdzIHx8IFtdO1xuICBuZXdDbXB0T3B0aW9ucyA9IChuZXdDbXB0T3B0aW9ucyB8fCBbXSkuc2xpY2UoKTtcbiAgdmFyIGV4aXN0aW5nSWRJZHhNYXAgPSBjcmVhdGVIYXNoTWFwKCk7XG4gIC8vIFZhbGlkYXRlIGlkIGFuZCBuYW1lIG9uIHVzZXIgaW5wdXQgb3B0aW9uLlxuICBlYWNoKG5ld0NtcHRPcHRpb25zLCBmdW5jdGlvbiAoY21wdE9wdGlvbiwgaW5kZXgpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGNtcHRPcHRpb24pKSB7XG4gICAgICBuZXdDbXB0T3B0aW9uc1tpbmRleF0gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhlcmUgaXMgc29tZSBsZWdhY3kgY2FzZSB0aGF0IG5hbWUgaXMgc2V0IGFzIGBmYWxzZWAuXG4gICAgICAvLyBCdXQgc2hvdWxkIHdvcmsgbm9ybWFsbHkgcmF0aGVyIHRoYW4gdGhyb3cgZXJyb3IuXG4gICAgICBpZiAoY21wdE9wdGlvbi5pZCAhPSBudWxsICYmICFpc1ZhbGlkSWRPck5hbWUoY21wdE9wdGlvbi5pZCkpIHtcbiAgICAgICAgd2FybkludmFsaWRhdGVJZE9yTmFtZShjbXB0T3B0aW9uLmlkKTtcbiAgICAgIH1cbiAgICAgIGlmIChjbXB0T3B0aW9uLm5hbWUgIT0gbnVsbCAmJiAhaXNWYWxpZElkT3JOYW1lKGNtcHRPcHRpb24ubmFtZSkpIHtcbiAgICAgICAgd2FybkludmFsaWRhdGVJZE9yTmFtZShjbXB0T3B0aW9uLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciByZXN1bHQgPSBwcmVwYXJlUmVzdWx0KGV4aXN0aW5ncywgZXhpc3RpbmdJZElkeE1hcCwgbW9kZSk7XG4gIGlmIChpc05vcm1hbE1lcmdlTW9kZSB8fCBpc1JlcGxhY2VNZXJnZU1vZGUpIHtcbiAgICBtYXBwaW5nQnlJZChyZXN1bHQsIGV4aXN0aW5ncywgZXhpc3RpbmdJZElkeE1hcCwgbmV3Q21wdE9wdGlvbnMpO1xuICB9XG4gIGlmIChpc05vcm1hbE1lcmdlTW9kZSkge1xuICAgIG1hcHBpbmdCeU5hbWUocmVzdWx0LCBuZXdDbXB0T3B0aW9ucyk7XG4gIH1cbiAgaWYgKGlzTm9ybWFsTWVyZ2VNb2RlIHx8IGlzUmVwbGFjZU1lcmdlTW9kZSkge1xuICAgIG1hcHBpbmdCeUluZGV4KHJlc3VsdCwgbmV3Q21wdE9wdGlvbnMsIGlzUmVwbGFjZU1lcmdlTW9kZSk7XG4gIH0gZWxzZSBpZiAoaXNSZXBsYWNlQWxsTW9kZSkge1xuICAgIG1hcHBpbmdJblJlcGxhY2VBbGxNb2RlKHJlc3VsdCwgbmV3Q21wdE9wdGlvbnMpO1xuICB9XG4gIG1ha2VJZEFuZE5hbWUocmVzdWx0KTtcbiAgLy8gVGhlIGFycmF5IGByZXN1bHRgIE1VU1QgTk9UIGNvbnRhaW4gZWxpZGVkIGl0ZW1zLCBvdGhlcndpc2UgdGhlXG4gIC8vIGZvckVhY2ggd2lsbCBvbWl0IHRob3NlIGl0ZW1zIGFuZCByZXN1bHQgaW4gaW5jb3JyZWN0IHJlc3VsdC5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHByZXBhcmVSZXN1bHQoZXhpc3RpbmdzLCBleGlzdGluZ0lkSWR4TWFwLCBtb2RlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG1vZGUgPT09ICdyZXBsYWNlQWxsJykge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gRG8gbm90IHVzZSBuYXRpdmUgYG1hcGAgdG8gaW4gY2FzZSB0aGF0IHRoZSBhcnJheSBgZXhpc3RpbmdzYFxuICAvLyBjb250YWlucyBlbGlkZWQgaXRlbXMsIHdoaWNoIHdpbGwgYmUgb21pdHRlZC5cbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGV4aXN0aW5ncy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBleGlzdGluZ3NbaW5kZXhdO1xuICAgIC8vIEJlY2F1c2Ugb2YgcmVwbGFjZU1lcmdlLCBgZXhpc3RpbmdgIG1heSBiZSBudWxsL3VuZGVmaW5lZC5cbiAgICBpZiAoZXhpc3RpbmcgJiYgZXhpc3RpbmcuaWQgIT0gbnVsbCkge1xuICAgICAgZXhpc3RpbmdJZElkeE1hcC5zZXQoZXhpc3RpbmcuaWQsIGluZGV4KTtcbiAgICB9XG4gICAgLy8gRm9yIG5vbi1pbnRlcm5hbC1jb21wb25uZXRzOlxuICAgIC8vICAgICBNb2RlIFwibm9ybWFsTWVyZ2VcIjogYWxsIGV4aXN0aW5ncyBrZXB0LlxuICAgIC8vICAgICBNb2RlIFwicmVwbGFjZU1lcmdlXCI6IGFsbCBleGlzdGluZyByZW1vdmVkIHVubGVzcyBtYXBwZWQgYnkgaWQuXG4gICAgLy8gRm9yIGludGVybmFsLWNvbXBvbmVudHM6XG4gICAgLy8gICAgIGdvIHdpdGggXCJyZXBsYWNlTWVyZ2VcIiBhcHByb2FjaCBpbiBib3RoIG1vZGUuXG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgZXhpc3Rpbmc6IG1vZGUgPT09ICdyZXBsYWNlTWVyZ2UnIHx8IGlzQ29tcG9uZW50SWRJbnRlcm5hbChleGlzdGluZykgPyBudWxsIDogZXhpc3RpbmcsXG4gICAgICBuZXdPcHRpb246IG51bGwsXG4gICAgICBrZXlJbmZvOiBudWxsLFxuICAgICAgYnJhbmROZXc6IG51bGxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFwcGluZ0J5SWQocmVzdWx0LCBleGlzdGluZ3MsIGV4aXN0aW5nSWRJZHhNYXAsIG5ld0NtcHRPcHRpb25zKSB7XG4gIC8vIE1hcHBpbmcgYnkgaWQgaWYgc3BlY2lmaWVkLlxuICBlYWNoKG5ld0NtcHRPcHRpb25zLCBmdW5jdGlvbiAoY21wdE9wdGlvbiwgaW5kZXgpIHtcbiAgICBpZiAoIWNtcHRPcHRpb24gfHwgY21wdE9wdGlvbi5pZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBvcHRpb25JZCA9IG1ha2VDb21wYXJhYmxlS2V5KGNtcHRPcHRpb24uaWQpO1xuICAgIHZhciBleGlzdGluZ0lkeCA9IGV4aXN0aW5nSWRJZHhNYXAuZ2V0KG9wdGlvbklkKTtcbiAgICBpZiAoZXhpc3RpbmdJZHggIT0gbnVsbCkge1xuICAgICAgdmFyIHJlc3VsdEl0ZW0gPSByZXN1bHRbZXhpc3RpbmdJZHhdO1xuICAgICAgYXNzZXJ0KCFyZXN1bHRJdGVtLm5ld09wdGlvbiwgJ0R1cGxpY2F0ZWQgb3B0aW9uIG9uIGlkIFwiJyArIG9wdGlvbklkICsgJ1wiLicpO1xuICAgICAgcmVzdWx0SXRlbS5uZXdPcHRpb24gPSBjbXB0T3B0aW9uO1xuICAgICAgLy8gSW4gYm90aCBtb2RlLCBpZiBpZCBtYXRjaGVkLCBuZXcgb3B0aW9uIHdpbGwgYmUgbWVyZ2VkIHRvXG4gICAgICAvLyB0aGUgZXhpc3RpbmdzIHJhdGhlciB0aGFuIGNyZWF0aW5nIG5ldyBjb21wb25lbnQgbW9kZWwuXG4gICAgICByZXN1bHRJdGVtLmV4aXN0aW5nID0gZXhpc3RpbmdzW2V4aXN0aW5nSWR4XTtcbiAgICAgIG5ld0NtcHRPcHRpb25zW2luZGV4XSA9IG51bGw7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG1hcHBpbmdCeU5hbWUocmVzdWx0LCBuZXdDbXB0T3B0aW9ucykge1xuICAvLyBNYXBwaW5nIGJ5IG5hbWUgaWYgc3BlY2lmaWVkLlxuICBlYWNoKG5ld0NtcHRPcHRpb25zLCBmdW5jdGlvbiAoY21wdE9wdGlvbiwgaW5kZXgpIHtcbiAgICBpZiAoIWNtcHRPcHRpb24gfHwgY21wdE9wdGlvbi5uYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBleGlzdGluZyA9IHJlc3VsdFtpXS5leGlzdGluZztcbiAgICAgIGlmICghcmVzdWx0W2ldLm5ld09wdGlvbiAvLyBDb25zaWRlciBuYW1lOiB0d28gbWFwIHRvIG9uZS5cbiAgICAgIC8vIENhbiBub3QgbWF0Y2ggd2hlbiBib3RoIGlkcyBleGlzdGluZyBidXQgZGlmZmVyZW50LlxuICAgICAgJiYgZXhpc3RpbmcgJiYgKGV4aXN0aW5nLmlkID09IG51bGwgfHwgY21wdE9wdGlvbi5pZCA9PSBudWxsKSAmJiAhaXNDb21wb25lbnRJZEludGVybmFsKGNtcHRPcHRpb24pICYmICFpc0NvbXBvbmVudElkSW50ZXJuYWwoZXhpc3RpbmcpICYmIGtleUV4aXN0QW5kRXF1YWwoJ25hbWUnLCBleGlzdGluZywgY21wdE9wdGlvbikpIHtcbiAgICAgICAgcmVzdWx0W2ldLm5ld09wdGlvbiA9IGNtcHRPcHRpb247XG4gICAgICAgIG5ld0NtcHRPcHRpb25zW2luZGV4XSA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbWFwcGluZ0J5SW5kZXgocmVzdWx0LCBuZXdDbXB0T3B0aW9ucywgYnJhbmROZXcpIHtcbiAgZWFjaChuZXdDbXB0T3B0aW9ucywgZnVuY3Rpb24gKGNtcHRPcHRpb24pIHtcbiAgICBpZiAoIWNtcHRPcHRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgcGxhY2UgdGhhdCBub3QgbWFwcGVkIGJ5IGlkIGFuZCBub3QgaW50ZXJuYWwgY29tcG9uZW50IChjb25zaWRlciB0aGUgXCJob2xlXCIpLlxuICAgIHZhciByZXN1bHRJdGVtO1xuICAgIHZhciBuZXh0SWR4ID0gMDtcbiAgICB3aGlsZSAoXG4gICAgLy8gQmUgYCFyZXN1bHRJdGVtYCBvbmx5IHdoZW4gYG5leHRJZHggPj0gcmVzdWx0Lmxlbmd0aGAuXG4gICAgKHJlc3VsdEl0ZW0gPSByZXN1bHRbbmV4dElkeF1cbiAgICAvLyAoMSkgRXhpc3RpbmcgbW9kZWxzIHRoYXQgYWxyZWFkeSBoYXZlIGlkIHNob3VsZCBiZSBhYmxlIHRvIG1hcHBlZCB0by4gQmVjYXVzZVxuICAgIC8vIGFmdGVyIG1hcHBpbmcgcGVyZm9ybWVkLCBtb2RlbCB3aWxsIGFsd2F5cyBiZSBhc3NpZ25lZCB3aXRoIGFuIGlkIGlmIHVzZXIgbm90IGdpdmVuLlxuICAgIC8vIEFmdGVyIHRoYXQgYWxsIG1vZGVscyBoYXZlIGlkLlxuICAgIC8vICgyKSBJZiBuZXcgb3B0aW9uIGhhcyBpZCwgaXQgY2FuIG9ubHkgc2V0IHRvIGEgaG9sZSBvciBhcHBlbmQgdG8gdGhlIGxhc3QuIEl0IHNob3VsZFxuICAgIC8vIG5vdCBiZSBtZXJnZWQgdG8gdGhlIGV4aXN0aW5ncyB3aXRoIGRpZmZlcmVudCBpZC4gQmVjYXVzZSBpZCBzaG91bGQgbm90IGJlIG92ZXJ3cml0dGVuLlxuICAgIC8vICgzKSBOYW1lIGNhbiBiZSBvdmVyd3JpdHRlbiwgYmVjYXVzZSBheGlzIHVzZSBuYW1lIGFzICdzaG93IGxhYmVsIHRleHQnLlxuICAgICkgJiYgKHJlc3VsdEl0ZW0ubmV3T3B0aW9uIHx8IGlzQ29tcG9uZW50SWRJbnRlcm5hbChyZXN1bHRJdGVtLmV4aXN0aW5nKSB8fFxuICAgIC8vIEluIG1vZGUgXCJyZXBsYWNlTWVyZ2VcIiwgaGVyZSBubyBub3QtbWFwcGVkLW5vbi1pbnRlcm5hbC1leGlzdGluZy5cbiAgICByZXN1bHRJdGVtLmV4aXN0aW5nICYmIGNtcHRPcHRpb24uaWQgIT0gbnVsbCAmJiAha2V5RXhpc3RBbmRFcXVhbCgnaWQnLCBjbXB0T3B0aW9uLCByZXN1bHRJdGVtLmV4aXN0aW5nKSkpIHtcbiAgICAgIG5leHRJZHgrKztcbiAgICB9XG4gICAgaWYgKHJlc3VsdEl0ZW0pIHtcbiAgICAgIHJlc3VsdEl0ZW0ubmV3T3B0aW9uID0gY21wdE9wdGlvbjtcbiAgICAgIHJlc3VsdEl0ZW0uYnJhbmROZXcgPSBicmFuZE5ldztcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBuZXdPcHRpb246IGNtcHRPcHRpb24sXG4gICAgICAgIGJyYW5kTmV3OiBicmFuZE5ldyxcbiAgICAgICAgZXhpc3Rpbmc6IG51bGwsXG4gICAgICAgIGtleUluZm86IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBuZXh0SWR4Kys7XG4gIH0pO1xufVxuZnVuY3Rpb24gbWFwcGluZ0luUmVwbGFjZUFsbE1vZGUocmVzdWx0LCBuZXdDbXB0T3B0aW9ucykge1xuICBlYWNoKG5ld0NtcHRPcHRpb25zLCBmdW5jdGlvbiAoY21wdE9wdGlvbikge1xuICAgIC8vIFRoZSBmZWF0dXJlIFwicmVwcm9kdWNlXCIgcmVxdWlyZXMgXCJob2xlXCIgd2lsbCBhbHNvIHJlcHJvZHVjZWRcbiAgICAvLyBpbiBjYXNlIHRoYXQgY29tcG9uZW50IGluZGV4IHJlZmVycmluZyBhcmUgYnJva2VuLlxuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIG5ld09wdGlvbjogY21wdE9wdGlvbixcbiAgICAgIGJyYW5kTmV3OiB0cnVlLFxuICAgICAgZXhpc3Rpbmc6IG51bGwsXG4gICAgICBrZXlJbmZvOiBudWxsXG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXHJcbiAqIE1ha2UgaWQgYW5kIG5hbWUgZm9yIG1hcHBpbmcgcmVzdWx0IChyZXN1bHQgb2YgbWFwcGluZ1RvRXhpc3RzKVxyXG4gKiBpbnRvIGBrZXlJbmZvYCBmaWVsZC5cclxuICovXG5mdW5jdGlvbiBtYWtlSWRBbmROYW1lKG1hcFJlc3VsdCkge1xuICAvLyBXZSB1c2UgdGhpcyBpZCB0byBoYXNoIGNvbXBvbmVudCBtb2RlbHMgYW5kIHZpZXcgaW5zdGFuY2VzXG4gIC8vIGluIGVjaGFydHMuIGlkIGNhbiBiZSBzcGVjaWZpZWQgYnkgdXNlciwgb3IgYXV0byBnZW5lcmF0ZWQuXG4gIC8vIFRoZSBpZCBnZW5lcmF0aW9uIHJ1bGUgZW5zdXJlcyBuZXcgdmlldyBpbnN0YW5jZSBhcmUgYWJsZVxuICAvLyB0byBtYXBwZWQgdG8gb2xkIGluc3RhbmNlIHdoZW4gc2V0T3B0aW9uIGFyZSBjYWxsZWQgaW5cbiAgLy8gbm8tbWVyZ2UgbW9kZS4gU28gd2UgZ2VuZXJhdGUgbW9kZWwgaWQgYnkgbmFtZSBhbmQgcGx1c1xuICAvLyB0eXBlIGluIHZpZXcgaWQuXG4gIC8vIG5hbWUgY2FuIGJlIGR1cGxpY2F0ZWQgYW1vbmcgY29tcG9uZW50cywgd2hpY2ggaXMgY29udmVuaWVudFxuICAvLyB0byBzcGVjaWZ5IG11bHRpIGNvbXBvbmVudHMgKGxpa2Ugc2VyaWVzKSBieSBvbmUgbmFtZS5cbiAgLy8gRW5zdXJlIHRoYXQgZWFjaCBpZCBpcyBkaXN0aW5jdC5cbiAgdmFyIGlkTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBpdGVtLmV4aXN0aW5nO1xuICAgIGV4aXN0aW5nICYmIGlkTWFwLnNldChleGlzdGluZy5pZCwgaXRlbSk7XG4gIH0pO1xuICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgb3B0ID0gaXRlbS5uZXdPcHRpb247XG4gICAgLy8gRm9yY2UgZW5zdXJlIGlkIG5vdCBkdXBsaWNhdGVkLlxuICAgIGFzc2VydCghb3B0IHx8IG9wdC5pZCA9PSBudWxsIHx8ICFpZE1hcC5nZXQob3B0LmlkKSB8fCBpZE1hcC5nZXQob3B0LmlkKSA9PT0gaXRlbSwgJ2lkIGR1cGxpY2F0ZXM6ICcgKyAob3B0ICYmIG9wdC5pZCkpO1xuICAgIG9wdCAmJiBvcHQuaWQgIT0gbnVsbCAmJiBpZE1hcC5zZXQob3B0LmlkLCBpdGVtKTtcbiAgICAhaXRlbS5rZXlJbmZvICYmIChpdGVtLmtleUluZm8gPSB7fSk7XG4gIH0pO1xuICAvLyBNYWtlIG5hbWUgYW5kIGlkLlxuICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gaXRlbS5leGlzdGluZztcbiAgICB2YXIgb3B0ID0gaXRlbS5uZXdPcHRpb247XG4gICAgdmFyIGtleUluZm8gPSBpdGVtLmtleUluZm87XG4gICAgaWYgKCFpc09iamVjdChvcHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE5hbWUgY2FuIGJlIG92ZXJ3cml0dGVuLiBDb25zaWRlciBjYXNlOiBheGlzLm5hbWUgPSAnMjBrbScuXG4gICAgLy8gQnV0IGlkIGdlbmVyYXRlZCBieSBuYW1lIHdpbGwgbm90IGJlIGNoYW5nZWQsIHdoaWNoIGFmZmVjdFxuICAgIC8vIG9ubHkgaW4gdGhhdCBjYXNlOiBzZXRPcHRpb24gd2l0aCAnbm90IG1lcmdlIG1vZGUnIGFuZCB2aWV3XG4gICAgLy8gaW5zdGFuY2Ugd2lsbCBiZSByZWNyZWF0ZWQsIHdoaWNoIGNhbiBiZSBhY2NlcHRlZC5cbiAgICBrZXlJbmZvLm5hbWUgPSBvcHQubmFtZSAhPSBudWxsID8gbWFrZUNvbXBhcmFibGVLZXkob3B0Lm5hbWUpIDogZXhpc3RpbmcgPyBleGlzdGluZy5uYW1lXG4gICAgLy8gQXZvaWQgdGhhdCBkaWZmZXJlbnQgc2VyaWVzIGhhcyB0aGUgc2FtZSBuYW1lLFxuICAgIC8vIGJlY2F1c2UgbmFtZSBtYXkgYmUgdXNlZCBsaWtlIGluIGNvbG9yIHBhbGxldC5cbiAgICA6IERVTU1ZX0NPTVBPTkVOVF9OQU1FX1BSRUZJWCArIGluZGV4O1xuICAgIGlmIChleGlzdGluZykge1xuICAgICAga2V5SW5mby5pZCA9IG1ha2VDb21wYXJhYmxlS2V5KGV4aXN0aW5nLmlkKTtcbiAgICB9IGVsc2UgaWYgKG9wdC5pZCAhPSBudWxsKSB7XG4gICAgICBrZXlJbmZvLmlkID0gbWFrZUNvbXBhcmFibGVLZXkob3B0LmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29uc2lkZXIgdGhpcyBzaXR1YXRvaW46XG4gICAgICAvLyAgb3B0aW9uQTogW3tuYW1lOiAnYSd9LCB7bmFtZTogJ2EnfSwgey4ufV1cbiAgICAgIC8vICBvcHRpb25CIFt7Li59LCB7bmFtZTogJ2EnfSwge25hbWU6ICdhJ31dXG4gICAgICAvLyBTZXJpZXMgd2l0aCB0aGUgc2FtZSBuYW1lIGJldHdlZW4gb3B0aW9uQSBhbmQgb3B0aW9uQlxuICAgICAgLy8gc2hvdWxkIGJlIG1hcHBlZC5cbiAgICAgIHZhciBpZE51bSA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIGtleUluZm8uaWQgPSAnXFwwJyArIGtleUluZm8ubmFtZSArICdcXDAnICsgaWROdW0rKztcbiAgICAgIH0gd2hpbGUgKGlkTWFwLmdldChrZXlJbmZvLmlkKSk7XG4gICAgfVxuICAgIGlkTWFwLnNldChrZXlJbmZvLmlkLCBpdGVtKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBrZXlFeGlzdEFuZEVxdWFsKGF0dHIsIG9iajEsIG9iajIpIHtcbiAgdmFyIGtleTEgPSBjb252ZXJ0T3B0aW9uSWROYW1lKG9iajFbYXR0cl0sIG51bGwpO1xuICB2YXIga2V5MiA9IGNvbnZlcnRPcHRpb25JZE5hbWUob2JqMlthdHRyXSwgbnVsbCk7XG4gIC8vIFNlZSBgTWFwcGluZ0V4aXN0aW5nSXRlbWAuIGBpZGAgYW5kIGBuYW1lYCB0cmFkZSBzdHJpbmcgZXF1YWxzIHRvIG51bWJlci5cbiAgcmV0dXJuIGtleTEgIT0gbnVsbCAmJiBrZXkyICE9IG51bGwgJiYga2V5MSA9PT0ga2V5Mjtcbn1cbi8qKlxyXG4gKiBAcmV0dXJuIHJldHVybiBudWxsIGlmIG5vdCBleGlzdC5cclxuICovXG5mdW5jdGlvbiBtYWtlQ29tcGFyYWJsZUtleSh2YWwpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29udmVydE9wdGlvbklkTmFtZSh2YWwsICcnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0T3B0aW9uSWROYW1lKGlkT3JOYW1lLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGlkT3JOYW1lID09IG51bGwpIHtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9XG4gIHJldHVybiBpc1N0cmluZyhpZE9yTmFtZSkgPyBpZE9yTmFtZSA6IGlzTnVtYmVyKGlkT3JOYW1lKSB8fCBpc1N0cmluZ1NhZmUoaWRPck5hbWUpID8gaWRPck5hbWUgKyAnJyA6IGRlZmF1bHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkYXRlSWRPck5hbWUoaWRPck5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKCdgJyArIGlkT3JOYW1lICsgJ2AgaXMgaW52YWxpZCBpZCBvciBuYW1lLiBNdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlci4nKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWYWxpZElkT3JOYW1lKGlkT3JOYW1lKSB7XG4gIHJldHVybiBpc1N0cmluZ1NhZmUoaWRPck5hbWUpIHx8IGlzTnVtZXJpYyhpZE9yTmFtZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOYW1lU3BlY2lmaWVkKGNvbXBvbmVudE1vZGVsKSB7XG4gIHZhciBuYW1lID0gY29tcG9uZW50TW9kZWwubmFtZTtcbiAgLy8gSXMgc3BlY2lmaWVkIHdoZW4gYGluZGV4T2ZgIGdldCAtMSBvciA+IDAuXG4gIHJldHVybiAhIShuYW1lICYmIG5hbWUuaW5kZXhPZihEVU1NWV9DT01QT05FTlRfTkFNRV9QUkVGSVgpKTtcbn1cbi8qKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjbXB0T3B0aW9uXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29tcG9uZW50SWRJbnRlcm5hbChjbXB0T3B0aW9uKSB7XG4gIHJldHVybiBjbXB0T3B0aW9uICYmIGNtcHRPcHRpb24uaWQgIT0gbnVsbCAmJiBtYWtlQ29tcGFyYWJsZUtleShjbXB0T3B0aW9uLmlkKS5pbmRleE9mKElOVEVSTkFMX0NPTVBPTkVOVF9JRF9QUkVGSVgpID09PSAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VJbnRlcm5hbENvbXBvbmVudElkKGlkU3VmZml4KSB7XG4gIHJldHVybiBJTlRFUk5BTF9DT01QT05FTlRfSURfUFJFRklYICsgaWRTdWZmaXg7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0Q29tcG9uZW50VHlwZVRvS2V5SW5mbyhtYXBwaW5nUmVzdWx0LCBtYWluVHlwZSwgY29tcG9uZW50TW9kZWxDdG9yKSB7XG4gIC8vIFNldCBtYWluVHlwZSBhbmQgY29tcGxldGUgc3ViVHlwZS5cbiAgZWFjaChtYXBwaW5nUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBuZXdPcHRpb24gPSBpdGVtLm5ld09wdGlvbjtcbiAgICBpZiAoaXNPYmplY3QobmV3T3B0aW9uKSkge1xuICAgICAgaXRlbS5rZXlJbmZvLm1haW5UeXBlID0gbWFpblR5cGU7XG4gICAgICBpdGVtLmtleUluZm8uc3ViVHlwZSA9IGRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG5ld09wdGlvbiwgaXRlbS5leGlzdGluZywgY29tcG9uZW50TW9kZWxDdG9yKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lU3ViVHlwZShtYWluVHlwZSwgbmV3Q21wdE9wdGlvbiwgZXhpc3RDb21wb25lbnQsIGNvbXBvbmVudE1vZGVsQ3Rvcikge1xuICB2YXIgc3ViVHlwZSA9IG5ld0NtcHRPcHRpb24udHlwZSA/IG5ld0NtcHRPcHRpb24udHlwZSA6IGV4aXN0Q29tcG9uZW50ID8gZXhpc3RDb21wb25lbnQuc3ViVHlwZVxuICAvLyBVc2UgZGV0ZXJtaW5lU3ViVHlwZSBvbmx5IHdoZW4gdGhlcmUgaXMgbm8gZXhpc3RDb21wb25lbnQuXG4gIDogY29tcG9uZW50TW9kZWxDdG9yLmRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG5ld0NtcHRPcHRpb24pO1xuICAvLyB0b29sdGlwLCBtYXJrbGluZSwgbWFya3BvaW50IG1heSBhbHdheXMgaGFzIG5vIHN1YlR5cGVcbiAgcmV0dXJuIHN1YlR5cGU7XG59XG4vKipcclxuICogQSBoZWxwZXIgZm9yIHJlbW92aW5nIGR1cGxpY2F0ZSBpdGVtcyBiZXR3ZWVuIGJhdGNoQSBhbmQgYmF0Y2hCLFxyXG4gKiBhbmQgaW4gdGhlbXNlbHZlcywgYW5kIGNhdGVnb3JpemUgYnkgc2VyaWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYmF0Y2hBIExpa2U6IFt7c2VyaWVzSWQ6IDIsIGRhdGFJbmRleDogWzMyLCA0LCA1XX0sIC4uLl1cclxuICogQHBhcmFtIGJhdGNoQiBMaWtlOiBbe3Nlcmllc0lkOiAyLCBkYXRhSW5kZXg6IFszMiwgNCwgNV19LCAuLi5dXHJcbiAqIEByZXR1cm4gcmVzdWx0OiBbcmVzdWx0QmF0Y2hBLCByZXN1bHRCYXRjaEJdXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXByZXNzQmF0Y2hlcyhiYXRjaEEsIGJhdGNoQikge1xuICB2YXIgbWFwQSA9IHt9O1xuICB2YXIgbWFwQiA9IHt9O1xuICBtYWtlTWFwKGJhdGNoQSB8fCBbXSwgbWFwQSk7XG4gIG1ha2VNYXAoYmF0Y2hCIHx8IFtdLCBtYXBCLCBtYXBBKTtcbiAgcmV0dXJuIFttYXBUb0FycmF5KG1hcEEpLCBtYXBUb0FycmF5KG1hcEIpXTtcbiAgZnVuY3Rpb24gbWFrZU1hcChzb3VyY2VCYXRjaCwgbWFwLCBvdGhlck1hcCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VCYXRjaC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHNlcmllc0lkID0gY29udmVydE9wdGlvbklkTmFtZShzb3VyY2VCYXRjaFtpXS5zZXJpZXNJZCwgbnVsbCk7XG4gICAgICBpZiAoc2VyaWVzSWQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGF0YUluZGljZXMgPSBub3JtYWxpemVUb0FycmF5KHNvdXJjZUJhdGNoW2ldLmRhdGFJbmRleCk7XG4gICAgICB2YXIgb3RoZXJEYXRhSW5kaWNlcyA9IG90aGVyTWFwICYmIG90aGVyTWFwW3Nlcmllc0lkXTtcbiAgICAgIGZvciAodmFyIGogPSAwLCBsZW5qID0gZGF0YUluZGljZXMubGVuZ3RoOyBqIDwgbGVuajsgaisrKSB7XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSBkYXRhSW5kaWNlc1tqXTtcbiAgICAgICAgaWYgKG90aGVyRGF0YUluZGljZXMgJiYgb3RoZXJEYXRhSW5kaWNlc1tkYXRhSW5kZXhdKSB7XG4gICAgICAgICAgb3RoZXJEYXRhSW5kaWNlc1tkYXRhSW5kZXhdID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAobWFwW3Nlcmllc0lkXSB8fCAobWFwW3Nlcmllc0lkXSA9IHt9KSlbZGF0YUluZGV4XSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXAsIGlzRGF0YSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIG1hcCkge1xuICAgICAgaWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShpKSAmJiBtYXBbaV0gIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNEYXRhKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goK2kpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyA9IG1hcFRvQXJyYXkobWFwW2ldLCB0cnVlKTtcbiAgICAgICAgICBkYXRhSW5kaWNlcy5sZW5ndGggJiYgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgc2VyaWVzSWQ6IGksXG4gICAgICAgICAgICBkYXRhSW5kZXg6IGRhdGFJbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXHJcbiAqIEBwYXJhbSBwYXlsb2FkIENvbnRhaW5zIGRhdGFJbmRleCAobWVhbnMgcmF3SW5kZXgpIC8gZGF0YUluZGV4SW5zaWRlIC8gbmFtZVxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoIG9mIHdoaWNoIGNhbiBiZSBBcnJheSBvciBwcmltYXJ5IHR5cGUuXHJcbiAqIEByZXR1cm4gZGF0YUluZGV4IElmIG5vdCBmb3VuZCwgcmV0dXJuIHVuZGVmaW5lZC9udWxsLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeURhdGFJbmRleChkYXRhLCBwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLmRhdGFJbmRleEluc2lkZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBheWxvYWQuZGF0YUluZGV4SW5zaWRlO1xuICB9IGVsc2UgaWYgKHBheWxvYWQuZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICByZXR1cm4gaXNBcnJheShwYXlsb2FkLmRhdGFJbmRleCkgPyBtYXAocGF5bG9hZC5kYXRhSW5kZXgsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRhdGEuaW5kZXhPZlJhd0luZGV4KHZhbHVlKTtcbiAgICB9KSA6IGRhdGEuaW5kZXhPZlJhd0luZGV4KHBheWxvYWQuZGF0YUluZGV4KTtcbiAgfSBlbHNlIGlmIChwYXlsb2FkLm5hbWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBpc0FycmF5KHBheWxvYWQubmFtZSkgPyBtYXAocGF5bG9hZC5uYW1lLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBkYXRhLmluZGV4T2ZOYW1lKHZhbHVlKTtcbiAgICB9KSA6IGRhdGEuaW5kZXhPZk5hbWUocGF5bG9hZC5uYW1lKTtcbiAgfVxufVxuLyoqXHJcbiAqIEVuYWJsZSBwcm9wZXJ0eSBzdG9yYWdlIHRvIGFueSBob3N0IG9iamVjdC5cclxuICogTm90aWNlOiBTZXJpYWxpemF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlOlxyXG4gKiBsZXQgaW5uZXIgPSB6clVpdGwubWFrZUlubmVyKCk7XHJcbiAqXHJcbiAqIGZ1bmN0aW9uIHNvbWUxKGhvc3RPYmopIHtcclxuICogICAgICBpbm5lcihob3N0T2JqKS5zb21lUHJvcGVydHkgPSAxMjEyO1xyXG4gKiAgICAgIC4uLlxyXG4gKiB9XHJcbiAqIGZ1bmN0aW9uIHNvbWUyKCkge1xyXG4gKiAgICAgIGxldCBmaWVsZHMgPSBpbm5lcih0aGlzKTtcclxuICogICAgICBmaWVsZHMuc29tZVByb3BlcnR5MSA9IDEyMTI7XHJcbiAqICAgICAgZmllbGRzLnNvbWVQcm9wZXJ0eTIgPSAneHgnO1xyXG4gKiAgICAgIC4uLlxyXG4gKiB9XHJcbiAqXHJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSW5uZXIoKSB7XG4gIHZhciBrZXkgPSAnX19lY19pbm5lcl8nICsgaW5uZXJVbmlxdWVJbmRleCsrO1xuICByZXR1cm4gZnVuY3Rpb24gKGhvc3RPYmopIHtcbiAgICByZXR1cm4gaG9zdE9ialtrZXldIHx8IChob3N0T2JqW2tleV0gPSB7fSk7XG4gIH07XG59XG52YXIgaW5uZXJVbmlxdWVJbmRleCA9IGdldFJhbmRvbUlkQmFzZSgpO1xuLyoqXHJcbiAqIFRoZSBzYW1lIGJlaGF2aW9yIGFzIGBjb21wb25lbnQuZ2V0UmVmZXJyaW5nQ29tcG9uZW50c2AuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmluZGVyKGVjTW9kZWwsIGZpbmRlcklucHV0LCBvcHQpIHtcbiAgdmFyIF9hID0gcHJlUGFyc2VGaW5kZXIoZmluZGVySW5wdXQsIG9wdCksXG4gICAgbWFpblR5cGVTcGVjaWZpZWQgPSBfYS5tYWluVHlwZVNwZWNpZmllZCxcbiAgICBxdWVyeU9wdGlvbk1hcCA9IF9hLnF1ZXJ5T3B0aW9uTWFwLFxuICAgIG90aGVycyA9IF9hLm90aGVycztcbiAgdmFyIHJlc3VsdCA9IG90aGVycztcbiAgdmFyIGRlZmF1bHRNYWluVHlwZSA9IG9wdCA/IG9wdC5kZWZhdWx0TWFpblR5cGUgOiBudWxsO1xuICBpZiAoIW1haW5UeXBlU3BlY2lmaWVkICYmIGRlZmF1bHRNYWluVHlwZSkge1xuICAgIHF1ZXJ5T3B0aW9uTWFwLnNldChkZWZhdWx0TWFpblR5cGUsIHt9KTtcbiAgfVxuICBxdWVyeU9wdGlvbk1hcC5lYWNoKGZ1bmN0aW9uIChxdWVyeU9wdGlvbiwgbWFpblR5cGUpIHtcbiAgICB2YXIgcXVlcnlSZXN1bHQgPSBxdWVyeVJlZmVycmluZ0NvbXBvbmVudHMoZWNNb2RlbCwgbWFpblR5cGUsIHF1ZXJ5T3B0aW9uLCB7XG4gICAgICB1c2VEZWZhdWx0OiBkZWZhdWx0TWFpblR5cGUgPT09IG1haW5UeXBlLFxuICAgICAgZW5hYmxlQWxsOiBvcHQgJiYgb3B0LmVuYWJsZUFsbCAhPSBudWxsID8gb3B0LmVuYWJsZUFsbCA6IHRydWUsXG4gICAgICBlbmFibGVOb25lOiBvcHQgJiYgb3B0LmVuYWJsZU5vbmUgIT0gbnVsbCA/IG9wdC5lbmFibGVOb25lIDogdHJ1ZVxuICAgIH0pO1xuICAgIHJlc3VsdFttYWluVHlwZSArICdNb2RlbHMnXSA9IHF1ZXJ5UmVzdWx0Lm1vZGVscztcbiAgICByZXN1bHRbbWFpblR5cGUgKyAnTW9kZWwnXSA9IHF1ZXJ5UmVzdWx0Lm1vZGVsc1swXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJlUGFyc2VGaW5kZXIoZmluZGVySW5wdXQsIG9wdCkge1xuICB2YXIgZmluZGVyO1xuICBpZiAoaXNTdHJpbmcoZmluZGVySW5wdXQpKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIG9ialtmaW5kZXJJbnB1dCArICdJbmRleCddID0gMDtcbiAgICBmaW5kZXIgPSBvYmo7XG4gIH0gZWxzZSB7XG4gICAgZmluZGVyID0gZmluZGVySW5wdXQ7XG4gIH1cbiAgdmFyIHF1ZXJ5T3B0aW9uTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuICB2YXIgb3RoZXJzID0ge307XG4gIHZhciBtYWluVHlwZVNwZWNpZmllZCA9IGZhbHNlO1xuICBlYWNoKGZpbmRlciwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAvLyBFeGNsdWRlICdkYXRhSW5kZXgnIGFuZCBvdGhlciBpbGxnYWwga2V5cy5cbiAgICBpZiAoa2V5ID09PSAnZGF0YUluZGV4JyB8fCBrZXkgPT09ICdkYXRhSW5kZXhJbnNpZGUnKSB7XG4gICAgICBvdGhlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGFyc2VkS2V5ID0ga2V5Lm1hdGNoKC9eKFxcdyspKEluZGV4fElkfE5hbWUpJC8pIHx8IFtdO1xuICAgIHZhciBtYWluVHlwZSA9IHBhcnNlZEtleVsxXTtcbiAgICB2YXIgcXVlcnlUeXBlID0gKHBhcnNlZEtleVsyXSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIW1haW5UeXBlIHx8ICFxdWVyeVR5cGUgfHwgb3B0ICYmIG9wdC5pbmNsdWRlTWFpblR5cGVzICYmIGluZGV4T2Yob3B0LmluY2x1ZGVNYWluVHlwZXMsIG1haW5UeXBlKSA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWFpblR5cGVTcGVjaWZpZWQgPSBtYWluVHlwZVNwZWNpZmllZCB8fCAhIW1haW5UeXBlO1xuICAgIHZhciBxdWVyeU9wdGlvbiA9IHF1ZXJ5T3B0aW9uTWFwLmdldChtYWluVHlwZSkgfHwgcXVlcnlPcHRpb25NYXAuc2V0KG1haW5UeXBlLCB7fSk7XG4gICAgcXVlcnlPcHRpb25bcXVlcnlUeXBlXSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBtYWluVHlwZVNwZWNpZmllZDogbWFpblR5cGVTcGVjaWZpZWQsXG4gICAgcXVlcnlPcHRpb25NYXA6IHF1ZXJ5T3B0aW9uTWFwLFxuICAgIG90aGVyczogb3RoZXJzXG4gIH07XG59XG5leHBvcnQgdmFyIFNJTkdMRV9SRUZFUlJJTkcgPSB7XG4gIHVzZURlZmF1bHQ6IHRydWUsXG4gIGVuYWJsZUFsbDogZmFsc2UsXG4gIGVuYWJsZU5vbmU6IGZhbHNlXG59O1xuZXhwb3J0IHZhciBNVUxUSVBMRV9SRUZFUlJJTkcgPSB7XG4gIHVzZURlZmF1bHQ6IGZhbHNlLFxuICBlbmFibGVBbGw6IHRydWUsXG4gIGVuYWJsZU5vbmU6IHRydWVcbn07XG5leHBvcnQgZnVuY3Rpb24gcXVlcnlSZWZlcnJpbmdDb21wb25lbnRzKGVjTW9kZWwsIG1haW5UeXBlLCB1c2VyT3B0aW9uLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IFNJTkdMRV9SRUZFUlJJTkc7XG4gIHZhciBpbmRleE9wdGlvbiA9IHVzZXJPcHRpb24uaW5kZXg7XG4gIHZhciBpZE9wdGlvbiA9IHVzZXJPcHRpb24uaWQ7XG4gIHZhciBuYW1lT3B0aW9uID0gdXNlck9wdGlvbi5uYW1lO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIG1vZGVsczogbnVsbCxcbiAgICBzcGVjaWZpZWQ6IGluZGV4T3B0aW9uICE9IG51bGwgfHwgaWRPcHRpb24gIT0gbnVsbCB8fCBuYW1lT3B0aW9uICE9IG51bGxcbiAgfTtcbiAgaWYgKCFyZXN1bHQuc3BlY2lmaWVkKSB7XG4gICAgLy8gVXNlIHRoZSBmaXJzdCBhcyBkZWZhdWx0IGlmIGB1c2VEZWZhdWx0YC5cbiAgICB2YXIgZmlyc3RDbXB0ID0gdm9pZCAwO1xuICAgIHJlc3VsdC5tb2RlbHMgPSBvcHQudXNlRGVmYXVsdCAmJiAoZmlyc3RDbXB0ID0gZWNNb2RlbC5nZXRDb21wb25lbnQobWFpblR5cGUpKSA/IFtmaXJzdENtcHRdIDogW107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoaW5kZXhPcHRpb24gPT09ICdub25lJyB8fCBpbmRleE9wdGlvbiA9PT0gZmFsc2UpIHtcbiAgICBhc3NlcnQob3B0LmVuYWJsZU5vbmUsICdgXCJub25lXCJgIG9yIGBmYWxzZWAgaXMgbm90IGEgdmFsaWQgdmFsdWUgb24gaW5kZXggb3B0aW9uLicpO1xuICAgIHJlc3VsdC5tb2RlbHMgPSBbXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8vIGBxdWVyeUNvbXBvbmVudHNgIHdpbGwgcmV0dXJuIGFsbCBjb21wb25lbnRzIGlmXG4gIC8vIGJvdGggYWxsIG9mIGluZGV4L2lkL25hbWUgYXJlIG51bGwvdW5kZWZpbmVkLlxuICBpZiAoaW5kZXhPcHRpb24gPT09ICdhbGwnKSB7XG4gICAgYXNzZXJ0KG9wdC5lbmFibGVBbGwsICdgXCJhbGxcImAgaXMgbm90IGEgdmFsaWQgdmFsdWUgb24gaW5kZXggb3B0aW9uLicpO1xuICAgIGluZGV4T3B0aW9uID0gaWRPcHRpb24gPSBuYW1lT3B0aW9uID0gbnVsbDtcbiAgfVxuICByZXN1bHQubW9kZWxzID0gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgIG1haW5UeXBlOiBtYWluVHlwZSxcbiAgICBpbmRleDogaW5kZXhPcHRpb24sXG4gICAgaWQ6IGlkT3B0aW9uLFxuICAgIG5hbWU6IG5hbWVPcHRpb25cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0QXR0cmlidXRlKGRvbSwga2V5LCB2YWx1ZSkge1xuICBkb20uc2V0QXR0cmlidXRlID8gZG9tLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKSA6IGRvbVtrZXldID0gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGRvbSwga2V5KSB7XG4gIHJldHVybiBkb20uZ2V0QXR0cmlidXRlID8gZG9tLmdldEF0dHJpYnV0ZShrZXkpIDogZG9tW2tleV07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9vbHRpcFJlbmRlck1vZGUocmVuZGVyTW9kZU9wdGlvbikge1xuICBpZiAocmVuZGVyTW9kZU9wdGlvbiA9PT0gJ2F1dG8nKSB7XG4gICAgLy8gVXNpbmcgaHRtbCB3aGVuIGBkb2N1bWVudGAgZXhpc3RzLCB1c2UgcmljaFRleHQgb3RoZXJ3aXNlXG4gICAgcmV0dXJuIGVudi5kb21TdXBwb3J0ZWQgPyAnaHRtbCcgOiAncmljaFRleHQnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZW5kZXJNb2RlT3B0aW9uIHx8ICdodG1sJztcbiAgfVxufVxuLyoqXHJcbiAqIEdyb3VwIGEgbGlzdCBieSBrZXkuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwRGF0YShhcnJheSwgZ2V0S2V5IC8vIHJldHVybiBrZXlcbikge1xuICB2YXIgYnVja2V0cyA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZWFjaChhcnJheSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5KGl0ZW0pO1xuICAgIChidWNrZXRzLmdldChrZXkpIHx8IChrZXlzLnB1c2goa2V5KSwgYnVja2V0cy5zZXQoa2V5LCBbXSkpKS5wdXNoKGl0ZW0pO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBrZXlzOiBrZXlzLFxuICAgIGJ1Y2tldHM6IGJ1Y2tldHNcbiAgfTtcbn1cbi8qKlxyXG4gKiBJbnRlcnBvbGF0ZSByYXcgdmFsdWVzIG9mIGEgc2VyaWVzIHdpdGggcGVyY2VudFxyXG4gKlxyXG4gKiBAcGFyYW0gZGF0YSAgICAgICAgIGRhdGFcclxuICogQHBhcmFtIGxhYmVsTW9kZWwgICBsYWJlbCBtb2RlbCBvZiB0aGUgdGV4dCBlbGVtZW50XHJcbiAqIEBwYXJhbSBzb3VyY2VWYWx1ZSAgc3RhcnQgdmFsdWUuIE1heSBiZSBudWxsL3VuZGVmaW5lZCB3aGVuIGluaXQuXHJcbiAqIEBwYXJhbSB0YXJnZXRWYWx1ZSAgZW5kIHZhbHVlXHJcbiAqIEBwYXJhbSBwZXJjZW50ICAgICAgMH4xIHBlcmNlbnRhZ2U7IDAgdXNlcyBzdGFydCB2YWx1ZSB3aGlsZSAxIHVzZXMgZW5kIHZhbHVlXHJcbiAqIEByZXR1cm4gICAgICAgICAgICAgaW50ZXJwb2xhdGVkIHZhbHVlc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgIElmIGBzb3VyY2VWYWx1ZWAgYW5kIGB0YXJnZXRWYWx1ZWAgYXJlIGBudW1iZXJgLCByZXR1cm4gYG51bWJlcmAuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgSWYgYHNvdXJjZVZhbHVlYCBhbmQgYHRhcmdldFZhbHVlYCBhcmUgYHN0cmluZ2AsIHJldHVybiBgc3RyaW5nYC5cclxuICogICAgICAgICAgICAgICAgICAgICBJZiBgc291cmNlVmFsdWVgIGFuZCBgdGFyZ2V0VmFsdWVgIGFyZSBgKHN0cmluZyB8IG51bWJlcilbXWAsIHJldHVybiBgKHN0cmluZyB8IG51bWJlcilbXWAuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgT3RoZXIgY2FzZXMgZG8gbm90IHN1cHBvcnRlZC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwb2xhdGVSYXdWYWx1ZXMoZGF0YSwgcHJlY2lzaW9uLCBzb3VyY2VWYWx1ZSwgdGFyZ2V0VmFsdWUsIHBlcmNlbnQpIHtcbiAgdmFyIGlzQXV0b1ByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsIHx8IHByZWNpc2lvbiA9PT0gJ2F1dG8nO1xuICBpZiAodGFyZ2V0VmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0YXJnZXRWYWx1ZTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodGFyZ2V0VmFsdWUpKSB7XG4gICAgdmFyIHZhbHVlID0gaW50ZXJwb2xhdGVOdW1iZXIoc291cmNlVmFsdWUgfHwgMCwgdGFyZ2V0VmFsdWUsIHBlcmNlbnQpO1xuICAgIHJldHVybiByb3VuZCh2YWx1ZSwgaXNBdXRvUHJlY2lzaW9uID8gTWF0aC5tYXgoZ2V0UHJlY2lzaW9uKHNvdXJjZVZhbHVlIHx8IDApLCBnZXRQcmVjaXNpb24odGFyZ2V0VmFsdWUpKSA6IHByZWNpc2lvbik7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcodGFyZ2V0VmFsdWUpKSB7XG4gICAgcmV0dXJuIHBlcmNlbnQgPCAxID8gc291cmNlVmFsdWUgOiB0YXJnZXRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW50ZXJwb2xhdGVkID0gW107XG4gICAgdmFyIGxlZnRBcnIgPSBzb3VyY2VWYWx1ZTtcbiAgICB2YXIgcmlnaHRBcnIgPSB0YXJnZXRWYWx1ZTtcbiAgICB2YXIgbGVuZ3RoXzEgPSBNYXRoLm1heChsZWZ0QXJyID8gbGVmdEFyci5sZW5ndGggOiAwLCByaWdodEFyci5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzE7ICsraSkge1xuICAgICAgdmFyIGluZm8gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oaSk7XG4gICAgICAvLyBEb24ndCBpbnRlcnBvbGF0ZSBvcmRpbmFsIGRpbXNcbiAgICAgIGlmIChpbmZvICYmIGluZm8udHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgIC8vIEluIGluaXQsIHRoZXJlIGlzIG5vIGBzb3VyY2VWYWx1ZWAsIGJ1dCBzaG91bGQgYmV0dGVyIG5vdCB0byBnZXQgdW5kZWZpbmVkIHJlc3VsdC5cbiAgICAgICAgaW50ZXJwb2xhdGVkW2ldID0gKHBlcmNlbnQgPCAxICYmIGxlZnRBcnIgPyBsZWZ0QXJyIDogcmlnaHRBcnIpW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxlZnRWYWwgPSBsZWZ0QXJyICYmIGxlZnRBcnJbaV0gPyBsZWZ0QXJyW2ldIDogMDtcbiAgICAgICAgdmFyIHJpZ2h0VmFsID0gcmlnaHRBcnJbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGludGVycG9sYXRlTnVtYmVyKGxlZnRWYWwsIHJpZ2h0VmFsLCBwZXJjZW50KTtcbiAgICAgICAgaW50ZXJwb2xhdGVkW2ldID0gcm91bmQodmFsdWUsIGlzQXV0b1ByZWNpc2lvbiA/IE1hdGgubWF4KGdldFByZWNpc2lvbihsZWZ0VmFsKSwgZ2V0UHJlY2lzaW9uKHJpZ2h0VmFsKSkgOiBwcmVjaXNpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJwb2xhdGVkO1xuICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///48170\n")},55854:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $9: () => (/* binding */ getDefaultFormatPrecisionOfInterval),\n/* harmony export */   $H: () => (/* binding */ ONE_YEAR),\n/* harmony export */   CZ: () => (/* binding */ ONE_DAY),\n/* harmony export */   F7: () => (/* binding */ timeUnits),\n/* harmony export */   FP: () => (/* binding */ millisecondsSetterName),\n/* harmony export */   GP: () => (/* binding */ format),\n/* harmony export */   KF: () => (/* binding */ minutesSetterName),\n/* harmony export */   Lm: () => (/* binding */ fullLeveledFormatter),\n/* harmony export */   MA: () => (/* binding */ ONE_HOUR),\n/* harmony export */   OY: () => (/* binding */ ONE_SECOND),\n/* harmony export */   Wf: () => (/* binding */ secondsGetterName),\n/* harmony export */   X_: () => (/* binding */ leveledFormat),\n/* harmony export */   Yd: () => (/* binding */ hoursSetterName),\n/* harmony export */   Zz: () => (/* binding */ millisecondsGetterName),\n/* harmony export */   bP: () => (/* binding */ dateGetterName),\n/* harmony export */   ce: () => (/* binding */ isPrimaryTimeUnit),\n/* harmony export */   eV: () => (/* binding */ pad),\n/* harmony export */   g0: () => (/* binding */ getUnitValue),\n/* harmony export */   hY: () => (/* binding */ fullYearGetterName),\n/* harmony export */   iC: () => (/* binding */ hoursGetterName),\n/* harmony export */   iW: () => (/* binding */ ONE_MINUTE),\n/* harmony export */   jJ: () => (/* binding */ monthGetterName),\n/* harmony export */   tM: () => (/* binding */ fullYearSetterName),\n/* harmony export */   ti: () => (/* binding */ dateSetterName),\n/* harmony export */   ww: () => (/* binding */ secondsSetterName),\n/* harmony export */   xu: () => (/* binding */ monthSetterName),\n/* harmony export */   yB: () => (/* binding */ minutesGetterName),\n/* harmony export */   ym: () => (/* binding */ getPrimaryTimeUnit)\n/* harmony export */ });\n/* unused harmony exports defaultLeveledFormatter, primaryTimeUnits, getUnitFromValue */\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98026);\n/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24326);\n/* harmony import */ var _core_locale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53080);\n/* harmony import */ var _model_Model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43172);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar ONE_SECOND = 1000;\nvar ONE_MINUTE = ONE_SECOND * 60;\nvar ONE_HOUR = ONE_MINUTE * 60;\nvar ONE_DAY = ONE_HOUR * 24;\nvar ONE_YEAR = ONE_DAY * 365;\nvar defaultLeveledFormatter = {\n  year: '{yyyy}',\n  month: '{MMM}',\n  day: '{d}',\n  hour: '{HH}:{mm}',\n  minute: '{HH}:{mm}',\n  second: '{HH}:{mm}:{ss}',\n  millisecond: '{HH}:{mm}:{ss} {SSS}',\n  none: '{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}'\n};\nvar fullDayFormatter = '{yyyy}-{MM}-{dd}';\nvar fullLeveledFormatter = {\n  year: '{yyyy}',\n  month: '{yyyy}-{MM}',\n  day: fullDayFormatter,\n  hour: fullDayFormatter + ' ' + defaultLeveledFormatter.hour,\n  minute: fullDayFormatter + ' ' + defaultLeveledFormatter.minute,\n  second: fullDayFormatter + ' ' + defaultLeveledFormatter.second,\n  millisecond: defaultLeveledFormatter.none\n};\nvar primaryTimeUnits = ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond'];\nvar timeUnits = ['year', 'half-year', 'quarter', 'month', 'week', 'half-week', 'day', 'half-day', 'quarter-day', 'hour', 'minute', 'second', 'millisecond'];\nfunction pad(str, len) {\n  str += '';\n  return '0000'.substr(0, len - str.length) + str;\n}\nfunction getPrimaryTimeUnit(timeUnit) {\n  switch (timeUnit) {\n    case 'half-year':\n    case 'quarter':\n      return 'month';\n    case 'week':\n    case 'half-week':\n      return 'day';\n    case 'half-day':\n    case 'quarter-day':\n      return 'hour';\n    default:\n      // year, minutes, second, milliseconds\n      return timeUnit;\n  }\n}\nfunction isPrimaryTimeUnit(timeUnit) {\n  return timeUnit === getPrimaryTimeUnit(timeUnit);\n}\nfunction getDefaultFormatPrecisionOfInterval(timeUnit) {\n  switch (timeUnit) {\n    case 'year':\n    case 'month':\n      return 'day';\n    case 'millisecond':\n      return 'millisecond';\n    default:\n      // Also for day, hour, minute, second\n      return 'second';\n  }\n}\nfunction format(\n// Note: The result based on `isUTC` are totally different, which can not be just simply\n// substituted by the result without `isUTC`. So we make the param `isUTC` mandatory.\ntime, template, isUTC, lang) {\n  var date = _number_js__WEBPACK_IMPORTED_MODULE_0__/* .parseDate */ ._U(time);\n  var y = date[fullYearGetterName(isUTC)]();\n  var M = date[monthGetterName(isUTC)]() + 1;\n  var q = Math.floor((M - 1) / 3) + 1;\n  var d = date[dateGetterName(isUTC)]();\n  var e = date['get' + (isUTC ? 'UTC' : '') + 'Day']();\n  var H = date[hoursGetterName(isUTC)]();\n  var h = (H - 1) % 12 + 1;\n  var m = date[minutesGetterName(isUTC)]();\n  var s = date[secondsGetterName(isUTC)]();\n  var S = date[millisecondsGetterName(isUTC)]();\n  var a = H >= 12 ? 'pm' : 'am';\n  var A = a.toUpperCase();\n  var localeModel = lang instanceof _model_Model_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A ? lang : (0,_core_locale_js__WEBPACK_IMPORTED_MODULE_2__/* .getLocaleModel */ .A4)(lang || _core_locale_js__WEBPACK_IMPORTED_MODULE_2__/* .SYSTEM_LANG */ .Lv) || (0,_core_locale_js__WEBPACK_IMPORTED_MODULE_2__/* .getDefaultLocaleModel */ .pr)();\n  var timeModel = localeModel.getModel('time');\n  var month = timeModel.get('month');\n  var monthAbbr = timeModel.get('monthAbbr');\n  var dayOfWeek = timeModel.get('dayOfWeek');\n  var dayOfWeekAbbr = timeModel.get('dayOfWeekAbbr');\n  return (template || '').replace(/{a}/g, a + '').replace(/{A}/g, A + '').replace(/{yyyy}/g, y + '').replace(/{yy}/g, pad(y % 100 + '', 2)).replace(/{Q}/g, q + '').replace(/{MMMM}/g, month[M - 1]).replace(/{MMM}/g, monthAbbr[M - 1]).replace(/{MM}/g, pad(M, 2)).replace(/{M}/g, M + '').replace(/{dd}/g, pad(d, 2)).replace(/{d}/g, d + '').replace(/{eeee}/g, dayOfWeek[e]).replace(/{ee}/g, dayOfWeekAbbr[e]).replace(/{e}/g, e + '').replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + '').replace(/{hh}/g, pad(h + '', 2)).replace(/{h}/g, h + '').replace(/{mm}/g, pad(m, 2)).replace(/{m}/g, m + '').replace(/{ss}/g, pad(s, 2)).replace(/{s}/g, s + '').replace(/{SSS}/g, pad(S, 3)).replace(/{S}/g, S + '');\n}\nfunction leveledFormat(tick, idx, formatter, lang, isUTC) {\n  var template = null;\n  if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.isString(formatter)) {\n    // Single formatter for all units at all levels\n    template = formatter;\n  } else if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.isFunction(formatter)) {\n    // Callback formatter\n    template = formatter(tick.value, idx, {\n      level: tick.level\n    });\n  } else {\n    var defaults = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.extend({}, defaultLeveledFormatter);\n    if (tick.level > 0) {\n      for (var i = 0; i < primaryTimeUnits.length; ++i) {\n        defaults[primaryTimeUnits[i]] = \"{primary|\" + defaults[primaryTimeUnits[i]] + \"}\";\n      }\n    }\n    var mergedFormatter = formatter ? formatter.inherit === false ? formatter // Use formatter with bigger units\n    : zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.defaults(formatter, defaults) : defaults;\n    var unit = getUnitFromValue(tick.value, isUTC);\n    if (mergedFormatter[unit]) {\n      template = mergedFormatter[unit];\n    } else if (mergedFormatter.inherit) {\n      // Unit formatter is not defined and should inherit from bigger units\n      var targetId = timeUnits.indexOf(unit);\n      for (var i = targetId - 1; i >= 0; --i) {\n        if (mergedFormatter[unit]) {\n          template = mergedFormatter[unit];\n          break;\n        }\n      }\n      template = template || defaults.none;\n    }\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.isArray(template)) {\n      var levelId = tick.level == null ? 0 : tick.level >= 0 ? tick.level : template.length + tick.level;\n      levelId = Math.min(levelId, template.length - 1);\n      template = template[levelId];\n    }\n  }\n  return format(new Date(tick.value), template, isUTC, lang);\n}\nfunction getUnitFromValue(value, isUTC) {\n  var date = _number_js__WEBPACK_IMPORTED_MODULE_0__/* .parseDate */ ._U(value);\n  var M = date[monthGetterName(isUTC)]() + 1;\n  var d = date[dateGetterName(isUTC)]();\n  var h = date[hoursGetterName(isUTC)]();\n  var m = date[minutesGetterName(isUTC)]();\n  var s = date[secondsGetterName(isUTC)]();\n  var S = date[millisecondsGetterName(isUTC)]();\n  var isSecond = S === 0;\n  var isMinute = isSecond && s === 0;\n  var isHour = isMinute && m === 0;\n  var isDay = isHour && h === 0;\n  var isMonth = isDay && d === 1;\n  var isYear = isMonth && M === 1;\n  if (isYear) {\n    return 'year';\n  } else if (isMonth) {\n    return 'month';\n  } else if (isDay) {\n    return 'day';\n  } else if (isHour) {\n    return 'hour';\n  } else if (isMinute) {\n    return 'minute';\n  } else if (isSecond) {\n    return 'second';\n  } else {\n    return 'millisecond';\n  }\n}\nfunction getUnitValue(value, unit, isUTC) {\n  var date = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.isNumber(value) ? _number_js__WEBPACK_IMPORTED_MODULE_0__/* .parseDate */ ._U(value) : value;\n  unit = unit || getUnitFromValue(value, isUTC);\n  switch (unit) {\n    case 'year':\n      return date[fullYearGetterName(isUTC)]();\n    case 'half-year':\n      return date[monthGetterName(isUTC)]() >= 6 ? 1 : 0;\n    case 'quarter':\n      return Math.floor((date[monthGetterName(isUTC)]() + 1) / 4);\n    case 'month':\n      return date[monthGetterName(isUTC)]();\n    case 'day':\n      return date[dateGetterName(isUTC)]();\n    case 'half-day':\n      return date[hoursGetterName(isUTC)]() / 24;\n    case 'hour':\n      return date[hoursGetterName(isUTC)]();\n    case 'minute':\n      return date[minutesGetterName(isUTC)]();\n    case 'second':\n      return date[secondsGetterName(isUTC)]();\n    case 'millisecond':\n      return date[millisecondsGetterName(isUTC)]();\n  }\n}\nfunction fullYearGetterName(isUTC) {\n  return isUTC ? 'getUTCFullYear' : 'getFullYear';\n}\nfunction monthGetterName(isUTC) {\n  return isUTC ? 'getUTCMonth' : 'getMonth';\n}\nfunction dateGetterName(isUTC) {\n  return isUTC ? 'getUTCDate' : 'getDate';\n}\nfunction hoursGetterName(isUTC) {\n  return isUTC ? 'getUTCHours' : 'getHours';\n}\nfunction minutesGetterName(isUTC) {\n  return isUTC ? 'getUTCMinutes' : 'getMinutes';\n}\nfunction secondsGetterName(isUTC) {\n  return isUTC ? 'getUTCSeconds' : 'getSeconds';\n}\nfunction millisecondsGetterName(isUTC) {\n  return isUTC ? 'getUTCMilliseconds' : 'getMilliseconds';\n}\nfunction fullYearSetterName(isUTC) {\n  return isUTC ? 'setUTCFullYear' : 'setFullYear';\n}\nfunction monthSetterName(isUTC) {\n  return isUTC ? 'setUTCMonth' : 'setMonth';\n}\nfunction dateSetterName(isUTC) {\n  return isUTC ? 'setUTCDate' : 'setDate';\n}\nfunction hoursSetterName(isUTC) {\n  return isUTC ? 'setUTCHours' : 'setHours';\n}\nfunction minutesSetterName(isUTC) {\n  return isUTC ? 'setUTCMinutes' : 'setMinutes';\n}\nfunction secondsSetterName(isUTC) {\n  return isUTC ? 'setUTCSeconds' : 'setSeconds';\n}\nfunction millisecondsSetterName(isUTC) {\n  return isUTC ? 'setUTCMilliseconds' : 'setMilliseconds';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU4NTQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC90aW1lLmpzP2MyMWMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIG51bWJlclV0aWwgZnJvbSAnLi9udW1iZXIuanMnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdExvY2FsZU1vZGVsLCBnZXRMb2NhbGVNb2RlbCwgU1lTVEVNX0xBTkcgfSBmcm9tICcuLi9jb3JlL2xvY2FsZS5qcyc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vbW9kZWwvTW9kZWwuanMnO1xuZXhwb3J0IHZhciBPTkVfU0VDT05EID0gMTAwMDtcbmV4cG9ydCB2YXIgT05FX01JTlVURSA9IE9ORV9TRUNPTkQgKiA2MDtcbmV4cG9ydCB2YXIgT05FX0hPVVIgPSBPTkVfTUlOVVRFICogNjA7XG5leHBvcnQgdmFyIE9ORV9EQVkgPSBPTkVfSE9VUiAqIDI0O1xuZXhwb3J0IHZhciBPTkVfWUVBUiA9IE9ORV9EQVkgKiAzNjU7XG5leHBvcnQgdmFyIGRlZmF1bHRMZXZlbGVkRm9ybWF0dGVyID0ge1xuICB5ZWFyOiAne3l5eXl9JyxcbiAgbW9udGg6ICd7TU1NfScsXG4gIGRheTogJ3tkfScsXG4gIGhvdXI6ICd7SEh9OnttbX0nLFxuICBtaW51dGU6ICd7SEh9OnttbX0nLFxuICBzZWNvbmQ6ICd7SEh9OnttbX06e3NzfScsXG4gIG1pbGxpc2Vjb25kOiAne0hIfTp7bW19Ontzc30ge1NTU30nLFxuICBub25lOiAne3l5eXl9LXtNTX0te2RkfSB7SEh9OnttbX06e3NzfSB7U1NTfSdcbn07XG52YXIgZnVsbERheUZvcm1hdHRlciA9ICd7eXl5eX0te01NfS17ZGR9JztcbmV4cG9ydCB2YXIgZnVsbExldmVsZWRGb3JtYXR0ZXIgPSB7XG4gIHllYXI6ICd7eXl5eX0nLFxuICBtb250aDogJ3t5eXl5fS17TU19JyxcbiAgZGF5OiBmdWxsRGF5Rm9ybWF0dGVyLFxuICBob3VyOiBmdWxsRGF5Rm9ybWF0dGVyICsgJyAnICsgZGVmYXVsdExldmVsZWRGb3JtYXR0ZXIuaG91cixcbiAgbWludXRlOiBmdWxsRGF5Rm9ybWF0dGVyICsgJyAnICsgZGVmYXVsdExldmVsZWRGb3JtYXR0ZXIubWludXRlLFxuICBzZWNvbmQ6IGZ1bGxEYXlGb3JtYXR0ZXIgKyAnICcgKyBkZWZhdWx0TGV2ZWxlZEZvcm1hdHRlci5zZWNvbmQsXG4gIG1pbGxpc2Vjb25kOiBkZWZhdWx0TGV2ZWxlZEZvcm1hdHRlci5ub25lXG59O1xuZXhwb3J0IHZhciBwcmltYXJ5VGltZVVuaXRzID0gWyd5ZWFyJywgJ21vbnRoJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWNvbmQnXTtcbmV4cG9ydCB2YXIgdGltZVVuaXRzID0gWyd5ZWFyJywgJ2hhbGYteWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnaGFsZi13ZWVrJywgJ2RheScsICdoYWxmLWRheScsICdxdWFydGVyLWRheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWNvbmQnXTtcbmV4cG9ydCBmdW5jdGlvbiBwYWQoc3RyLCBsZW4pIHtcbiAgc3RyICs9ICcnO1xuICByZXR1cm4gJzAwMDAnLnN1YnN0cigwLCBsZW4gLSBzdHIubGVuZ3RoKSArIHN0cjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcmltYXJ5VGltZVVuaXQodGltZVVuaXQpIHtcbiAgc3dpdGNoICh0aW1lVW5pdCkge1xuICAgIGNhc2UgJ2hhbGYteWVhcic6XG4gICAgY2FzZSAncXVhcnRlcic6XG4gICAgICByZXR1cm4gJ21vbnRoJztcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICdoYWxmLXdlZWsnOlxuICAgICAgcmV0dXJuICdkYXknO1xuICAgIGNhc2UgJ2hhbGYtZGF5JzpcbiAgICBjYXNlICdxdWFydGVyLWRheSc6XG4gICAgICByZXR1cm4gJ2hvdXInO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyB5ZWFyLCBtaW51dGVzLCBzZWNvbmQsIG1pbGxpc2Vjb25kc1xuICAgICAgcmV0dXJuIHRpbWVVbml0O1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNQcmltYXJ5VGltZVVuaXQodGltZVVuaXQpIHtcbiAgcmV0dXJuIHRpbWVVbml0ID09PSBnZXRQcmltYXJ5VGltZVVuaXQodGltZVVuaXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRGb3JtYXRQcmVjaXNpb25PZkludGVydmFsKHRpbWVVbml0KSB7XG4gIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgICByZXR1cm4gJ2RheSc7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgcmV0dXJuICdtaWxsaXNlY29uZCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEFsc28gZm9yIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmRcbiAgICAgIHJldHVybiAnc2Vjb25kJztcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChcbi8vIE5vdGU6IFRoZSByZXN1bHQgYmFzZWQgb24gYGlzVVRDYCBhcmUgdG90YWxseSBkaWZmZXJlbnQsIHdoaWNoIGNhbiBub3QgYmUganVzdCBzaW1wbHlcbi8vIHN1YnN0aXR1dGVkIGJ5IHRoZSByZXN1bHQgd2l0aG91dCBgaXNVVENgLiBTbyB3ZSBtYWtlIHRoZSBwYXJhbSBgaXNVVENgIG1hbmRhdG9yeS5cbnRpbWUsIHRlbXBsYXRlLCBpc1VUQywgbGFuZykge1xuICB2YXIgZGF0ZSA9IG51bWJlclV0aWwucGFyc2VEYXRlKHRpbWUpO1xuICB2YXIgeSA9IGRhdGVbZnVsbFllYXJHZXR0ZXJOYW1lKGlzVVRDKV0oKTtcbiAgdmFyIE0gPSBkYXRlW21vbnRoR2V0dGVyTmFtZShpc1VUQyldKCkgKyAxO1xuICB2YXIgcSA9IE1hdGguZmxvb3IoKE0gLSAxKSAvIDMpICsgMTtcbiAgdmFyIGQgPSBkYXRlW2RhdGVHZXR0ZXJOYW1lKGlzVVRDKV0oKTtcbiAgdmFyIGUgPSBkYXRlWydnZXQnICsgKGlzVVRDID8gJ1VUQycgOiAnJykgKyAnRGF5J10oKTtcbiAgdmFyIEggPSBkYXRlW2hvdXJzR2V0dGVyTmFtZShpc1VUQyldKCk7XG4gIHZhciBoID0gKEggLSAxKSAlIDEyICsgMTtcbiAgdmFyIG0gPSBkYXRlW21pbnV0ZXNHZXR0ZXJOYW1lKGlzVVRDKV0oKTtcbiAgdmFyIHMgPSBkYXRlW3NlY29uZHNHZXR0ZXJOYW1lKGlzVVRDKV0oKTtcbiAgdmFyIFMgPSBkYXRlW21pbGxpc2Vjb25kc0dldHRlck5hbWUoaXNVVEMpXSgpO1xuICB2YXIgYSA9IEggPj0gMTIgPyAncG0nIDogJ2FtJztcbiAgdmFyIEEgPSBhLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBsb2NhbGVNb2RlbCA9IGxhbmcgaW5zdGFuY2VvZiBNb2RlbCA/IGxhbmcgOiBnZXRMb2NhbGVNb2RlbChsYW5nIHx8IFNZU1RFTV9MQU5HKSB8fCBnZXREZWZhdWx0TG9jYWxlTW9kZWwoKTtcbiAgdmFyIHRpbWVNb2RlbCA9IGxvY2FsZU1vZGVsLmdldE1vZGVsKCd0aW1lJyk7XG4gIHZhciBtb250aCA9IHRpbWVNb2RlbC5nZXQoJ21vbnRoJyk7XG4gIHZhciBtb250aEFiYnIgPSB0aW1lTW9kZWwuZ2V0KCdtb250aEFiYnInKTtcbiAgdmFyIGRheU9mV2VlayA9IHRpbWVNb2RlbC5nZXQoJ2RheU9mV2VlaycpO1xuICB2YXIgZGF5T2ZXZWVrQWJiciA9IHRpbWVNb2RlbC5nZXQoJ2RheU9mV2Vla0FiYnInKTtcbiAgcmV0dXJuICh0ZW1wbGF0ZSB8fCAnJykucmVwbGFjZSgve2F9L2csIGEgKyAnJykucmVwbGFjZSgve0F9L2csIEEgKyAnJykucmVwbGFjZSgve3l5eXl9L2csIHkgKyAnJykucmVwbGFjZSgve3l5fS9nLCBwYWQoeSAlIDEwMCArICcnLCAyKSkucmVwbGFjZSgve1F9L2csIHEgKyAnJykucmVwbGFjZSgve01NTU19L2csIG1vbnRoW00gLSAxXSkucmVwbGFjZSgve01NTX0vZywgbW9udGhBYmJyW00gLSAxXSkucmVwbGFjZSgve01NfS9nLCBwYWQoTSwgMikpLnJlcGxhY2UoL3tNfS9nLCBNICsgJycpLnJlcGxhY2UoL3tkZH0vZywgcGFkKGQsIDIpKS5yZXBsYWNlKC97ZH0vZywgZCArICcnKS5yZXBsYWNlKC97ZWVlZX0vZywgZGF5T2ZXZWVrW2VdKS5yZXBsYWNlKC97ZWV9L2csIGRheU9mV2Vla0FiYnJbZV0pLnJlcGxhY2UoL3tlfS9nLCBlICsgJycpLnJlcGxhY2UoL3tISH0vZywgcGFkKEgsIDIpKS5yZXBsYWNlKC97SH0vZywgSCArICcnKS5yZXBsYWNlKC97aGh9L2csIHBhZChoICsgJycsIDIpKS5yZXBsYWNlKC97aH0vZywgaCArICcnKS5yZXBsYWNlKC97bW19L2csIHBhZChtLCAyKSkucmVwbGFjZSgve219L2csIG0gKyAnJykucmVwbGFjZSgve3NzfS9nLCBwYWQocywgMikpLnJlcGxhY2UoL3tzfS9nLCBzICsgJycpLnJlcGxhY2UoL3tTU1N9L2csIHBhZChTLCAzKSkucmVwbGFjZSgve1N9L2csIFMgKyAnJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gbGV2ZWxlZEZvcm1hdCh0aWNrLCBpZHgsIGZvcm1hdHRlciwgbGFuZywgaXNVVEMpIHtcbiAgdmFyIHRlbXBsYXRlID0gbnVsbDtcbiAgaWYgKHpyVXRpbC5pc1N0cmluZyhmb3JtYXR0ZXIpKSB7XG4gICAgLy8gU2luZ2xlIGZvcm1hdHRlciBmb3IgYWxsIHVuaXRzIGF0IGFsbCBsZXZlbHNcbiAgICB0ZW1wbGF0ZSA9IGZvcm1hdHRlcjtcbiAgfSBlbHNlIGlmICh6clV0aWwuaXNGdW5jdGlvbihmb3JtYXR0ZXIpKSB7XG4gICAgLy8gQ2FsbGJhY2sgZm9ybWF0dGVyXG4gICAgdGVtcGxhdGUgPSBmb3JtYXR0ZXIodGljay52YWx1ZSwgaWR4LCB7XG4gICAgICBsZXZlbDogdGljay5sZXZlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWZhdWx0cyA9IHpyVXRpbC5leHRlbmQoe30sIGRlZmF1bHRMZXZlbGVkRm9ybWF0dGVyKTtcbiAgICBpZiAodGljay5sZXZlbCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpbWFyeVRpbWVVbml0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBkZWZhdWx0c1twcmltYXJ5VGltZVVuaXRzW2ldXSA9IFwie3ByaW1hcnl8XCIgKyBkZWZhdWx0c1twcmltYXJ5VGltZVVuaXRzW2ldXSArIFwifVwiO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWVyZ2VkRm9ybWF0dGVyID0gZm9ybWF0dGVyID8gZm9ybWF0dGVyLmluaGVyaXQgPT09IGZhbHNlID8gZm9ybWF0dGVyIC8vIFVzZSBmb3JtYXR0ZXIgd2l0aCBiaWdnZXIgdW5pdHNcbiAgICA6IHpyVXRpbC5kZWZhdWx0cyhmb3JtYXR0ZXIsIGRlZmF1bHRzKSA6IGRlZmF1bHRzO1xuICAgIHZhciB1bml0ID0gZ2V0VW5pdEZyb21WYWx1ZSh0aWNrLnZhbHVlLCBpc1VUQyk7XG4gICAgaWYgKG1lcmdlZEZvcm1hdHRlclt1bml0XSkge1xuICAgICAgdGVtcGxhdGUgPSBtZXJnZWRGb3JtYXR0ZXJbdW5pdF07XG4gICAgfSBlbHNlIGlmIChtZXJnZWRGb3JtYXR0ZXIuaW5oZXJpdCkge1xuICAgICAgLy8gVW5pdCBmb3JtYXR0ZXIgaXMgbm90IGRlZmluZWQgYW5kIHNob3VsZCBpbmhlcml0IGZyb20gYmlnZ2VyIHVuaXRzXG4gICAgICB2YXIgdGFyZ2V0SWQgPSB0aW1lVW5pdHMuaW5kZXhPZih1bml0KTtcbiAgICAgIGZvciAodmFyIGkgPSB0YXJnZXRJZCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChtZXJnZWRGb3JtYXR0ZXJbdW5pdF0pIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IG1lcmdlZEZvcm1hdHRlclt1bml0XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZSB8fCBkZWZhdWx0cy5ub25lO1xuICAgIH1cbiAgICBpZiAoenJVdGlsLmlzQXJyYXkodGVtcGxhdGUpKSB7XG4gICAgICB2YXIgbGV2ZWxJZCA9IHRpY2subGV2ZWwgPT0gbnVsbCA/IDAgOiB0aWNrLmxldmVsID49IDAgPyB0aWNrLmxldmVsIDogdGVtcGxhdGUubGVuZ3RoICsgdGljay5sZXZlbDtcbiAgICAgIGxldmVsSWQgPSBNYXRoLm1pbihsZXZlbElkLCB0ZW1wbGF0ZS5sZW5ndGggLSAxKTtcbiAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGVbbGV2ZWxJZF07XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXQobmV3IERhdGUodGljay52YWx1ZSksIHRlbXBsYXRlLCBpc1VUQywgbGFuZyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5pdEZyb21WYWx1ZSh2YWx1ZSwgaXNVVEMpIHtcbiAgdmFyIGRhdGUgPSBudW1iZXJVdGlsLnBhcnNlRGF0ZSh2YWx1ZSk7XG4gIHZhciBNID0gZGF0ZVttb250aEdldHRlck5hbWUoaXNVVEMpXSgpICsgMTtcbiAgdmFyIGQgPSBkYXRlW2RhdGVHZXR0ZXJOYW1lKGlzVVRDKV0oKTtcbiAgdmFyIGggPSBkYXRlW2hvdXJzR2V0dGVyTmFtZShpc1VUQyldKCk7XG4gIHZhciBtID0gZGF0ZVttaW51dGVzR2V0dGVyTmFtZShpc1VUQyldKCk7XG4gIHZhciBzID0gZGF0ZVtzZWNvbmRzR2V0dGVyTmFtZShpc1VUQyldKCk7XG4gIHZhciBTID0gZGF0ZVttaWxsaXNlY29uZHNHZXR0ZXJOYW1lKGlzVVRDKV0oKTtcbiAgdmFyIGlzU2Vjb25kID0gUyA9PT0gMDtcbiAgdmFyIGlzTWludXRlID0gaXNTZWNvbmQgJiYgcyA9PT0gMDtcbiAgdmFyIGlzSG91ciA9IGlzTWludXRlICYmIG0gPT09IDA7XG4gIHZhciBpc0RheSA9IGlzSG91ciAmJiBoID09PSAwO1xuICB2YXIgaXNNb250aCA9IGlzRGF5ICYmIGQgPT09IDE7XG4gIHZhciBpc1llYXIgPSBpc01vbnRoICYmIE0gPT09IDE7XG4gIGlmIChpc1llYXIpIHtcbiAgICByZXR1cm4gJ3llYXInO1xuICB9IGVsc2UgaWYgKGlzTW9udGgpIHtcbiAgICByZXR1cm4gJ21vbnRoJztcbiAgfSBlbHNlIGlmIChpc0RheSkge1xuICAgIHJldHVybiAnZGF5JztcbiAgfSBlbHNlIGlmIChpc0hvdXIpIHtcbiAgICByZXR1cm4gJ2hvdXInO1xuICB9IGVsc2UgaWYgKGlzTWludXRlKSB7XG4gICAgcmV0dXJuICdtaW51dGUnO1xuICB9IGVsc2UgaWYgKGlzU2Vjb25kKSB7XG4gICAgcmV0dXJuICdzZWNvbmQnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnbWlsbGlzZWNvbmQnO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5pdFZhbHVlKHZhbHVlLCB1bml0LCBpc1VUQykge1xuICB2YXIgZGF0ZSA9IHpyVXRpbC5pc051bWJlcih2YWx1ZSkgPyBudW1iZXJVdGlsLnBhcnNlRGF0ZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgdW5pdCA9IHVuaXQgfHwgZ2V0VW5pdEZyb21WYWx1ZSh2YWx1ZSwgaXNVVEMpO1xuICBzd2l0Y2ggKHVuaXQpIHtcbiAgICBjYXNlICd5ZWFyJzpcbiAgICAgIHJldHVybiBkYXRlW2Z1bGxZZWFyR2V0dGVyTmFtZShpc1VUQyldKCk7XG4gICAgY2FzZSAnaGFsZi15ZWFyJzpcbiAgICAgIHJldHVybiBkYXRlW21vbnRoR2V0dGVyTmFtZShpc1VUQyldKCkgPj0gNiA/IDEgOiAwO1xuICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGRhdGVbbW9udGhHZXR0ZXJOYW1lKGlzVVRDKV0oKSArIDEpIC8gNCk7XG4gICAgY2FzZSAnbW9udGgnOlxuICAgICAgcmV0dXJuIGRhdGVbbW9udGhHZXR0ZXJOYW1lKGlzVVRDKV0oKTtcbiAgICBjYXNlICdkYXknOlxuICAgICAgcmV0dXJuIGRhdGVbZGF0ZUdldHRlck5hbWUoaXNVVEMpXSgpO1xuICAgIGNhc2UgJ2hhbGYtZGF5JzpcbiAgICAgIHJldHVybiBkYXRlW2hvdXJzR2V0dGVyTmFtZShpc1VUQyldKCkgLyAyNDtcbiAgICBjYXNlICdob3VyJzpcbiAgICAgIHJldHVybiBkYXRlW2hvdXJzR2V0dGVyTmFtZShpc1VUQyldKCk7XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICAgIHJldHVybiBkYXRlW21pbnV0ZXNHZXR0ZXJOYW1lKGlzVVRDKV0oKTtcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgcmV0dXJuIGRhdGVbc2Vjb25kc0dldHRlck5hbWUoaXNVVEMpXSgpO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgIHJldHVybiBkYXRlW21pbGxpc2Vjb25kc0dldHRlck5hbWUoaXNVVEMpXSgpO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZnVsbFllYXJHZXR0ZXJOYW1lKGlzVVRDKSB7XG4gIHJldHVybiBpc1VUQyA/ICdnZXRVVENGdWxsWWVhcicgOiAnZ2V0RnVsbFllYXInO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1vbnRoR2V0dGVyTmFtZShpc1VUQykge1xuICByZXR1cm4gaXNVVEMgPyAnZ2V0VVRDTW9udGgnIDogJ2dldE1vbnRoJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBkYXRlR2V0dGVyTmFtZShpc1VUQykge1xuICByZXR1cm4gaXNVVEMgPyAnZ2V0VVRDRGF0ZScgOiAnZ2V0RGF0ZSc7XG59XG5leHBvcnQgZnVuY3Rpb24gaG91cnNHZXR0ZXJOYW1lKGlzVVRDKSB7XG4gIHJldHVybiBpc1VUQyA/ICdnZXRVVENIb3VycycgOiAnZ2V0SG91cnMnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1pbnV0ZXNHZXR0ZXJOYW1lKGlzVVRDKSB7XG4gIHJldHVybiBpc1VUQyA/ICdnZXRVVENNaW51dGVzJyA6ICdnZXRNaW51dGVzJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZWNvbmRzR2V0dGVyTmFtZShpc1VUQykge1xuICByZXR1cm4gaXNVVEMgPyAnZ2V0VVRDU2Vjb25kcycgOiAnZ2V0U2Vjb25kcyc7XG59XG5leHBvcnQgZnVuY3Rpb24gbWlsbGlzZWNvbmRzR2V0dGVyTmFtZShpc1VUQykge1xuICByZXR1cm4gaXNVVEMgPyAnZ2V0VVRDTWlsbGlzZWNvbmRzJyA6ICdnZXRNaWxsaXNlY29uZHMnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZ1bGxZZWFyU2V0dGVyTmFtZShpc1VUQykge1xuICByZXR1cm4gaXNVVEMgPyAnc2V0VVRDRnVsbFllYXInIDogJ3NldEZ1bGxZZWFyJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBtb250aFNldHRlck5hbWUoaXNVVEMpIHtcbiAgcmV0dXJuIGlzVVRDID8gJ3NldFVUQ01vbnRoJyA6ICdzZXRNb250aCc7XG59XG5leHBvcnQgZnVuY3Rpb24gZGF0ZVNldHRlck5hbWUoaXNVVEMpIHtcbiAgcmV0dXJuIGlzVVRDID8gJ3NldFVUQ0RhdGUnIDogJ3NldERhdGUnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhvdXJzU2V0dGVyTmFtZShpc1VUQykge1xuICByZXR1cm4gaXNVVEMgPyAnc2V0VVRDSG91cnMnIDogJ3NldEhvdXJzJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBtaW51dGVzU2V0dGVyTmFtZShpc1VUQykge1xuICByZXR1cm4gaXNVVEMgPyAnc2V0VVRDTWludXRlcycgOiAnc2V0TWludXRlcyc7XG59XG5leHBvcnQgZnVuY3Rpb24gc2Vjb25kc1NldHRlck5hbWUoaXNVVEMpIHtcbiAgcmV0dXJuIGlzVVRDID8gJ3NldFVUQ1NlY29uZHMnIDogJ3NldFNlY29uZHMnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1pbGxpc2Vjb25kc1NldHRlck5hbWUoaXNVVEMpIHtcbiAgcmV0dXJuIGlzVVRDID8gJ3NldFVUQ01pbGxpc2Vjb25kcycgOiAnc2V0TWlsbGlzZWNvbmRzJztcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///55854\n")},59109:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_graphic_Group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43870);\n/* harmony import */ var _util_component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12616);\n/* harmony import */ var _util_clazz_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30693);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar ComponentView = /** @class */function () {\n  function ComponentView() {\n    this.group = new zrender_lib_graphic_Group_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A();\n    this.uid = _util_component_js__WEBPACK_IMPORTED_MODULE_1__/* .getUID */ .$Q(\'viewComponent\');\n  }\n  ComponentView.prototype.init = function (ecModel, api) {};\n  ComponentView.prototype.render = function (model, ecModel, api, payload) {};\n  ComponentView.prototype.dispose = function (ecModel, api) {};\n  ComponentView.prototype.updateView = function (model, ecModel, api, payload) {\n    // Do nothing;\n  };\n  ComponentView.prototype.updateLayout = function (model, ecModel, api, payload) {\n    // Do nothing;\n  };\n  ComponentView.prototype.updateVisual = function (model, ecModel, api, payload) {\n    // Do nothing;\n  };\n  /**\r\n   * Hook for toggle blur target series.\r\n   * Can be used in marker for blur or leave blur the markers\r\n   */\n  ComponentView.prototype.toggleBlurSeries = function (seriesModels, isBlur, ecModel) {\n    // Do nothing;\n  };\n  /**\r\n   * Traverse the new rendered elements.\r\n   *\r\n   * It will traverse the new added element in progressive rendering.\r\n   * And traverse all in normal rendering.\r\n   */\n  ComponentView.prototype.eachRendered = function (cb) {\n    var group = this.group;\n    if (group) {\n      group.traverse(cb);\n    }\n  };\n  return ComponentView;\n}();\n;\n_util_clazz_js__WEBPACK_IMPORTED_MODULE_2__/* .enableClassExtend */ .gq(ComponentView);\n_util_clazz_js__WEBPACK_IMPORTED_MODULE_2__/* .enableClassManagement */ .tQ(ComponentView);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ComponentView);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkxMDkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlldy9Db21wb25lbnQuanM/ZjhmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBHcm91cCBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL0dyb3VwLmpzJztcbmltcG9ydCAqIGFzIGNvbXBvbmVudFV0aWwgZnJvbSAnLi4vdXRpbC9jb21wb25lbnQuanMnO1xuaW1wb3J0ICogYXMgY2xhenpVdGlsIGZyb20gJy4uL3V0aWwvY2xhenouanMnO1xudmFyIENvbXBvbmVudFZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb21wb25lbnRWaWV3KCkge1xuICAgIHRoaXMuZ3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgICB0aGlzLnVpZCA9IGNvbXBvbmVudFV0aWwuZ2V0VUlEKCd2aWV3Q29tcG9uZW50Jyk7XG4gIH1cbiAgQ29tcG9uZW50Vmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHt9O1xuICBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAobW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge307XG4gIENvbXBvbmVudFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7fTtcbiAgQ29tcG9uZW50Vmlldy5wcm90b3R5cGUudXBkYXRlVmlldyA9IGZ1bmN0aW9uIChtb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgLy8gRG8gbm90aGluZztcbiAgfTtcbiAgQ29tcG9uZW50Vmlldy5wcm90b3R5cGUudXBkYXRlTGF5b3V0ID0gZnVuY3Rpb24gKG1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAvLyBEbyBub3RoaW5nO1xuICB9O1xuICBDb21wb25lbnRWaWV3LnByb3RvdHlwZS51cGRhdGVWaXN1YWwgPSBmdW5jdGlvbiAobW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIC8vIERvIG5vdGhpbmc7XG4gIH07XG4gIC8qKlxyXG4gICAqIEhvb2sgZm9yIHRvZ2dsZSBibHVyIHRhcmdldCBzZXJpZXMuXHJcbiAgICogQ2FuIGJlIHVzZWQgaW4gbWFya2VyIGZvciBibHVyIG9yIGxlYXZlIGJsdXIgdGhlIG1hcmtlcnNcclxuICAgKi9cbiAgQ29tcG9uZW50Vmlldy5wcm90b3R5cGUudG9nZ2xlQmx1clNlcmllcyA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbHMsIGlzQmx1ciwgZWNNb2RlbCkge1xuICAgIC8vIERvIG5vdGhpbmc7XG4gIH07XG4gIC8qKlxyXG4gICAqIFRyYXZlcnNlIHRoZSBuZXcgcmVuZGVyZWQgZWxlbWVudHMuXHJcbiAgICpcclxuICAgKiBJdCB3aWxsIHRyYXZlcnNlIHRoZSBuZXcgYWRkZWQgZWxlbWVudCBpbiBwcm9ncmVzc2l2ZSByZW5kZXJpbmcuXHJcbiAgICogQW5kIHRyYXZlcnNlIGFsbCBpbiBub3JtYWwgcmVuZGVyaW5nLlxyXG4gICAqL1xuICBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5lYWNoUmVuZGVyZWQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIGlmIChncm91cCkge1xuICAgICAgZ3JvdXAudHJhdmVyc2UoY2IpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIENvbXBvbmVudFZpZXc7XG59KCk7XG47XG5jbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoQ29tcG9uZW50Vmlldyk7XG5jbGF6elV0aWwuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KENvbXBvbmVudFZpZXcpO1xuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50VmlldzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///59109\n')},62103:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $V: () => (/* binding */ symbolBuildProxies),\n/* harmony export */   hV: () => (/* binding */ normalizeSymbolOffset),\n/* harmony export */   v5: () => (/* binding */ createSymbol),\n/* harmony export */   xU: () => (/* binding */ normalizeSymbolSize)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98026);\n/* harmony import */ var _graphic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59482);\n/* harmony import */ var _graphic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82861);\n/* harmony import */ var _graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30010);\n/* harmony import */ var _graphic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31571);\n/* harmony import */ var _graphic_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(43199);\n/* harmony import */ var zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(29308);\n/* harmony import */ var zrender_lib_contain_text_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45558);\n/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(24326);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// Symbol factory\n\n\n\n\n\n/**\r\n * Triangle shape\r\n * @inner\r\n */\nvar Triangle = _graphic_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Ay.extend({\n  type: 'triangle',\n  shape: {\n    cx: 0,\n    cy: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (path, shape) {\n    var cx = shape.cx;\n    var cy = shape.cy;\n    var width = shape.width / 2;\n    var height = shape.height / 2;\n    path.moveTo(cx, cy - height);\n    path.lineTo(cx + width, cy + height);\n    path.lineTo(cx - width, cy + height);\n    path.closePath();\n  }\n});\n/**\r\n * Diamond shape\r\n * @inner\r\n */\nvar Diamond = _graphic_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Ay.extend({\n  type: 'diamond',\n  shape: {\n    cx: 0,\n    cy: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (path, shape) {\n    var cx = shape.cx;\n    var cy = shape.cy;\n    var width = shape.width / 2;\n    var height = shape.height / 2;\n    path.moveTo(cx, cy - height);\n    path.lineTo(cx + width, cy);\n    path.lineTo(cx, cy + height);\n    path.lineTo(cx - width, cy);\n    path.closePath();\n  }\n});\n/**\r\n * Pin shape\r\n * @inner\r\n */\nvar Pin = _graphic_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Ay.extend({\n  type: 'pin',\n  shape: {\n    // x, y on the cusp\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (path, shape) {\n    var x = shape.x;\n    var y = shape.y;\n    var w = shape.width / 5 * 3;\n    // Height must be larger than width\n    var h = Math.max(w, shape.height);\n    var r = w / 2;\n    // Dist on y with tangent point and circle center\n    var dy = r * r / (h - r);\n    var cy = y - h + r + dy;\n    var angle = Math.asin(dy / r);\n    // Dist on x with tangent point and circle center\n    var dx = Math.cos(angle) * r;\n    var tanX = Math.sin(angle);\n    var tanY = Math.cos(angle);\n    var cpLen = r * 0.6;\n    var cpLen2 = r * 0.7;\n    path.moveTo(x - dx, cy + dy);\n    path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);\n    path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);\n    path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);\n    path.closePath();\n  }\n});\n/**\r\n * Arrow shape\r\n * @inner\r\n */\nvar Arrow = _graphic_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Ay.extend({\n  type: 'arrow',\n  shape: {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (ctx, shape) {\n    var height = shape.height;\n    var width = shape.width;\n    var x = shape.x;\n    var y = shape.y;\n    var dx = width / 3 * 2;\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + dx, y + height);\n    ctx.lineTo(x, y + height / 4 * 3);\n    ctx.lineTo(x - dx, y + height);\n    ctx.lineTo(x, y);\n    ctx.closePath();\n  }\n});\n/**\r\n * Map of path constructors\r\n */\n// TODO Use function to build symbol path.\nvar symbolCtors = {\n  line: _graphic_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A,\n  rect: _graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A,\n  roundRect: _graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A,\n  square: _graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A,\n  circle: _graphic_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A,\n  diamond: Diamond,\n  pin: Pin,\n  arrow: Arrow,\n  triangle: Triangle\n};\nvar symbolShapeMakers = {\n  line: function (x, y, w, h, shape) {\n    shape.x1 = x;\n    shape.y1 = y + h / 2;\n    shape.x2 = x + w;\n    shape.y2 = y + h / 2;\n  },\n  rect: function (x, y, w, h, shape) {\n    shape.x = x;\n    shape.y = y;\n    shape.width = w;\n    shape.height = h;\n  },\n  roundRect: function (x, y, w, h, shape) {\n    shape.x = x;\n    shape.y = y;\n    shape.width = w;\n    shape.height = h;\n    shape.r = Math.min(w, h) / 4;\n  },\n  square: function (x, y, w, h, shape) {\n    var size = Math.min(w, h);\n    shape.x = x;\n    shape.y = y;\n    shape.width = size;\n    shape.height = size;\n  },\n  circle: function (x, y, w, h, shape) {\n    // Put circle in the center of square\n    shape.cx = x + w / 2;\n    shape.cy = y + h / 2;\n    shape.r = Math.min(w, h) / 2;\n  },\n  diamond: function (x, y, w, h, shape) {\n    shape.cx = x + w / 2;\n    shape.cy = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  },\n  pin: function (x, y, w, h, shape) {\n    shape.x = x + w / 2;\n    shape.y = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  },\n  arrow: function (x, y, w, h, shape) {\n    shape.x = x + w / 2;\n    shape.y = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  },\n  triangle: function (x, y, w, h, shape) {\n    shape.cx = x + w / 2;\n    shape.cy = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  }\n};\nvar symbolBuildProxies = {};\n(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.each)(symbolCtors, function (Ctor, name) {\n  symbolBuildProxies[name] = new Ctor();\n});\nvar SymbolClz = _graphic_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Ay.extend({\n  type: 'symbol',\n  shape: {\n    symbolType: '',\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  calculateTextPosition: function (out, config, rect) {\n    var res = (0,zrender_lib_contain_text_js__WEBPACK_IMPORTED_MODULE_5__/* .calculateTextPosition */ .X4)(out, config, rect);\n    var shape = this.shape;\n    if (shape && shape.symbolType === 'pin' && config.position === 'inside') {\n      res.y = rect.y + rect.height * 0.4;\n    }\n    return res;\n  },\n  buildPath: function (ctx, shape, inBundle) {\n    var symbolType = shape.symbolType;\n    if (symbolType !== 'none') {\n      var proxySymbol = symbolBuildProxies[symbolType];\n      if (!proxySymbol) {\n        // Default rect\n        symbolType = 'rect';\n        proxySymbol = symbolBuildProxies[symbolType];\n      }\n      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);\n      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n    }\n  }\n});\n// Provide setColor helper method to avoid determine if set the fill or stroke outside\nfunction symbolPathSetColor(color, innerColor) {\n  if (this.type !== 'image') {\n    var symbolStyle = this.style;\n    if (this.__isEmptyBrush) {\n      symbolStyle.stroke = color;\n      symbolStyle.fill = innerColor || '#fff';\n      // TODO Same width with lineStyle in LineView\n      symbolStyle.lineWidth = 2;\n    } else if (this.shape.symbolType === 'line') {\n      symbolStyle.stroke = color;\n    } else {\n      symbolStyle.fill = color;\n    }\n    this.markRedraw();\n  }\n}\n/**\r\n * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\r\n */\nfunction createSymbol(symbolType, x, y, w, h, color,\n// whether to keep the ratio of w/h,\nkeepAspect) {\n  // TODO Support image object, DynamicImage.\n  var isEmpty = symbolType.indexOf('empty') === 0;\n  if (isEmpty) {\n    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n  }\n  var symbolPath;\n  if (symbolType.indexOf('image://') === 0) {\n    symbolPath = _graphic_js__WEBPACK_IMPORTED_MODULE_6__.makeImage(symbolType.slice(8), new zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .A(x, y, w, h), keepAspect ? 'center' : 'cover');\n  } else if (symbolType.indexOf('path://') === 0) {\n    symbolPath = _graphic_js__WEBPACK_IMPORTED_MODULE_6__.makePath(symbolType.slice(7), {}, new zrender_lib_core_BoundingRect_js__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .A(x, y, w, h), keepAspect ? 'center' : 'cover');\n  } else {\n    symbolPath = new SymbolClz({\n      shape: {\n        symbolType: symbolType,\n        x: x,\n        y: y,\n        width: w,\n        height: h\n      }\n    });\n  }\n  symbolPath.__isEmptyBrush = isEmpty;\n  // TODO Should deprecate setColor\n  symbolPath.setColor = symbolPathSetColor;\n  if (color) {\n    symbolPath.setColor(color);\n  }\n  return symbolPath;\n}\nfunction normalizeSymbolSize(symbolSize) {\n  if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(symbolSize)) {\n    symbolSize = [+symbolSize, +symbolSize];\n  }\n  return [symbolSize[0] || 0, symbolSize[1] || 0];\n}\nfunction normalizeSymbolOffset(symbolOffset, symbolSize) {\n  if (symbolOffset == null) {\n    return;\n  }\n  if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(symbolOffset)) {\n    symbolOffset = [symbolOffset, symbolOffset];\n  }\n  return [(0,_number_js__WEBPACK_IMPORTED_MODULE_8__/* .parsePercent */ .lo)(symbolOffset[0], symbolSize[0]) || 0, (0,_number_js__WEBPACK_IMPORTED_MODULE_8__/* .parsePercent */ .lo)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.retrieve2)(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIxMDMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9zeW1ib2wuanM/ZGUzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbi8vIFN5bWJvbCBmYWN0b3J5XG5pbXBvcnQgeyBlYWNoLCBpc0FycmF5LCByZXRyaWV2ZTIgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuL2dyYXBoaWMuanMnO1xuaW1wb3J0IEJvdW5kaW5nUmVjdCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcyc7XG5pbXBvcnQgeyBjYWxjdWxhdGVUZXh0UG9zaXRpb24gfSBmcm9tICd6cmVuZGVyL2xpYi9jb250YWluL3RleHQuanMnO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50IH0gZnJvbSAnLi9udW1iZXIuanMnO1xuLyoqXHJcbiAqIFRyaWFuZ2xlIHNoYXBlXHJcbiAqIEBpbm5lclxyXG4gKi9cbnZhciBUcmlhbmdsZSA9IGdyYXBoaWMuUGF0aC5leHRlbmQoe1xuICB0eXBlOiAndHJpYW5nbGUnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xuICAgIHZhciBjeCA9IHNoYXBlLmN4O1xuICAgIHZhciBjeSA9IHNoYXBlLmN5O1xuICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoIC8gMjtcbiAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcbiAgICBwYXRoLm1vdmVUbyhjeCwgY3kgLSBoZWlnaHQpO1xuICAgIHBhdGgubGluZVRvKGN4ICsgd2lkdGgsIGN5ICsgaGVpZ2h0KTtcbiAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSArIGhlaWdodCk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufSk7XG4vKipcclxuICogRGlhbW9uZCBzaGFwZVxyXG4gKiBAaW5uZXJcclxuICovXG52YXIgRGlhbW9uZCA9IGdyYXBoaWMuUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnZGlhbW9uZCcsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XG4gICAgdmFyIGN4ID0gc2hhcGUuY3g7XG4gICAgdmFyIGN5ID0gc2hhcGUuY3k7XG4gICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xuICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQgLyAyO1xuICAgIHBhdGgubW92ZVRvKGN4LCBjeSAtIGhlaWdodCk7XG4gICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kpO1xuICAgIHBhdGgubGluZVRvKGN4LCBjeSArIGhlaWdodCk7XG4gICAgcGF0aC5saW5lVG8oY3ggLSB3aWR0aCwgY3kpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuLyoqXHJcbiAqIFBpbiBzaGFwZVxyXG4gKiBAaW5uZXJcclxuICovXG52YXIgUGluID0gZ3JhcGhpYy5QYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdwaW4nLFxuICBzaGFwZToge1xuICAgIC8vIHgsIHkgb24gdGhlIGN1c3BcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS54O1xuICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICB2YXIgdyA9IHNoYXBlLndpZHRoIC8gNSAqIDM7XG4gICAgLy8gSGVpZ2h0IG11c3QgYmUgbGFyZ2VyIHRoYW4gd2lkdGhcbiAgICB2YXIgaCA9IE1hdGgubWF4KHcsIHNoYXBlLmhlaWdodCk7XG4gICAgdmFyIHIgPSB3IC8gMjtcbiAgICAvLyBEaXN0IG9uIHkgd2l0aCB0YW5nZW50IHBvaW50IGFuZCBjaXJjbGUgY2VudGVyXG4gICAgdmFyIGR5ID0gciAqIHIgLyAoaCAtIHIpO1xuICAgIHZhciBjeSA9IHkgLSBoICsgciArIGR5O1xuICAgIHZhciBhbmdsZSA9IE1hdGguYXNpbihkeSAvIHIpO1xuICAgIC8vIERpc3Qgb24geCB3aXRoIHRhbmdlbnQgcG9pbnQgYW5kIGNpcmNsZSBjZW50ZXJcbiAgICB2YXIgZHggPSBNYXRoLmNvcyhhbmdsZSkgKiByO1xuICAgIHZhciB0YW5YID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciB0YW5ZID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIHZhciBjcExlbiA9IHIgKiAwLjY7XG4gICAgdmFyIGNwTGVuMiA9IHIgKiAwLjc7XG4gICAgcGF0aC5tb3ZlVG8oeCAtIGR4LCBjeSArIGR5KTtcbiAgICBwYXRoLmFyYyh4LCBjeSwgciwgTWF0aC5QSSAtIGFuZ2xlLCBNYXRoLlBJICogMiArIGFuZ2xlKTtcbiAgICBwYXRoLmJlemllckN1cnZlVG8oeCArIGR4IC0gdGFuWCAqIGNwTGVuLCBjeSArIGR5ICsgdGFuWSAqIGNwTGVuLCB4LCB5IC0gY3BMZW4yLCB4LCB5KTtcbiAgICBwYXRoLmJlemllckN1cnZlVG8oeCwgeSAtIGNwTGVuMiwgeCAtIGR4ICsgdGFuWCAqIGNwTGVuLCBjeSArIGR5ICsgdGFuWSAqIGNwTGVuLCB4IC0gZHgsIGN5ICsgZHkpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuLyoqXHJcbiAqIEFycm93IHNoYXBlXHJcbiAqIEBpbm5lclxyXG4gKi9cbnZhciBBcnJvdyA9IGdyYXBoaWMuUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnYXJyb3cnLFxuICBzaGFwZToge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgdmFyIHggPSBzaGFwZS54O1xuICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICB2YXIgZHggPSB3aWR0aCAvIDMgKiAyO1xuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgY3R4LmxpbmVUbyh4ICsgZHgsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8oeCwgeSArIGhlaWdodCAvIDQgKiAzKTtcbiAgICBjdHgubGluZVRvKHggLSBkeCwgeSArIGhlaWdodCk7XG4gICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuLyoqXHJcbiAqIE1hcCBvZiBwYXRoIGNvbnN0cnVjdG9yc1xyXG4gKi9cbi8vIFRPRE8gVXNlIGZ1bmN0aW9uIHRvIGJ1aWxkIHN5bWJvbCBwYXRoLlxudmFyIHN5bWJvbEN0b3JzID0ge1xuICBsaW5lOiBncmFwaGljLkxpbmUsXG4gIHJlY3Q6IGdyYXBoaWMuUmVjdCxcbiAgcm91bmRSZWN0OiBncmFwaGljLlJlY3QsXG4gIHNxdWFyZTogZ3JhcGhpYy5SZWN0LFxuICBjaXJjbGU6IGdyYXBoaWMuQ2lyY2xlLFxuICBkaWFtb25kOiBEaWFtb25kLFxuICBwaW46IFBpbixcbiAgYXJyb3c6IEFycm93LFxuICB0cmlhbmdsZTogVHJpYW5nbGVcbn07XG52YXIgc3ltYm9sU2hhcGVNYWtlcnMgPSB7XG4gIGxpbmU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIHNoYXBlLngxID0geDtcbiAgICBzaGFwZS55MSA9IHkgKyBoIC8gMjtcbiAgICBzaGFwZS54MiA9IHggKyB3O1xuICAgIHNoYXBlLnkyID0geSArIGggLyAyO1xuICB9LFxuICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICBzaGFwZS54ID0geDtcbiAgICBzaGFwZS55ID0geTtcbiAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgfSxcbiAgcm91bmRSZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICBzaGFwZS54ID0geDtcbiAgICBzaGFwZS55ID0geTtcbiAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyA0O1xuICB9LFxuICBzcXVhcmU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIHZhciBzaXplID0gTWF0aC5taW4odywgaCk7XG4gICAgc2hhcGUueCA9IHg7XG4gICAgc2hhcGUueSA9IHk7XG4gICAgc2hhcGUud2lkdGggPSBzaXplO1xuICAgIHNoYXBlLmhlaWdodCA9IHNpemU7XG4gIH0sXG4gIGNpcmNsZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgLy8gUHV0IGNpcmNsZSBpbiB0aGUgY2VudGVyIG9mIHNxdWFyZVxuICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xuICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xuICAgIHNoYXBlLnIgPSBNYXRoLm1pbih3LCBoKSAvIDI7XG4gIH0sXG4gIGRpYW1vbmQ6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xuICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xuICAgIHNoYXBlLndpZHRoID0gdztcbiAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICB9LFxuICBwaW46IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIHNoYXBlLnggPSB4ICsgdyAvIDI7XG4gICAgc2hhcGUueSA9IHkgKyBoIC8gMjtcbiAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgfSxcbiAgYXJyb3c6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIHNoYXBlLnggPSB4ICsgdyAvIDI7XG4gICAgc2hhcGUueSA9IHkgKyBoIC8gMjtcbiAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgfSxcbiAgdHJpYW5nbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xuICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xuICAgIHNoYXBlLndpZHRoID0gdztcbiAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICB9XG59O1xuZXhwb3J0IHZhciBzeW1ib2xCdWlsZFByb3hpZXMgPSB7fTtcbmVhY2goc3ltYm9sQ3RvcnMsIGZ1bmN0aW9uIChDdG9yLCBuYW1lKSB7XG4gIHN5bWJvbEJ1aWxkUHJveGllc1tuYW1lXSA9IG5ldyBDdG9yKCk7XG59KTtcbnZhciBTeW1ib2xDbHogPSBncmFwaGljLlBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3N5bWJvbCcsXG4gIHNoYXBlOiB7XG4gICAgc3ltYm9sVHlwZTogJycsXG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9LFxuICBjYWxjdWxhdGVUZXh0UG9zaXRpb246IGZ1bmN0aW9uIChvdXQsIGNvbmZpZywgcmVjdCkge1xuICAgIHZhciByZXMgPSBjYWxjdWxhdGVUZXh0UG9zaXRpb24ob3V0LCBjb25maWcsIHJlY3QpO1xuICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgaWYgKHNoYXBlICYmIHNoYXBlLnN5bWJvbFR5cGUgPT09ICdwaW4nICYmIGNvbmZpZy5wb3NpdGlvbiA9PT0gJ2luc2lkZScpIHtcbiAgICAgIHJlcy55ID0gcmVjdC55ICsgcmVjdC5oZWlnaHQgKiAwLjQ7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUsIGluQnVuZGxlKSB7XG4gICAgdmFyIHN5bWJvbFR5cGUgPSBzaGFwZS5zeW1ib2xUeXBlO1xuICAgIGlmIChzeW1ib2xUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgIHZhciBwcm94eVN5bWJvbCA9IHN5bWJvbEJ1aWxkUHJveGllc1tzeW1ib2xUeXBlXTtcbiAgICAgIGlmICghcHJveHlTeW1ib2wpIHtcbiAgICAgICAgLy8gRGVmYXVsdCByZWN0XG4gICAgICAgIHN5bWJvbFR5cGUgPSAncmVjdCc7XG4gICAgICAgIHByb3h5U3ltYm9sID0gc3ltYm9sQnVpbGRQcm94aWVzW3N5bWJvbFR5cGVdO1xuICAgICAgfVxuICAgICAgc3ltYm9sU2hhcGVNYWtlcnNbc3ltYm9sVHlwZV0oc2hhcGUueCwgc2hhcGUueSwgc2hhcGUud2lkdGgsIHNoYXBlLmhlaWdodCwgcHJveHlTeW1ib2wuc2hhcGUpO1xuICAgICAgcHJveHlTeW1ib2wuYnVpbGRQYXRoKGN0eCwgcHJveHlTeW1ib2wuc2hhcGUsIGluQnVuZGxlKTtcbiAgICB9XG4gIH1cbn0pO1xuLy8gUHJvdmlkZSBzZXRDb2xvciBoZWxwZXIgbWV0aG9kIHRvIGF2b2lkIGRldGVybWluZSBpZiBzZXQgdGhlIGZpbGwgb3Igc3Ryb2tlIG91dHNpZGVcbmZ1bmN0aW9uIHN5bWJvbFBhdGhTZXRDb2xvcihjb2xvciwgaW5uZXJDb2xvcikge1xuICBpZiAodGhpcy50eXBlICE9PSAnaW1hZ2UnKSB7XG4gICAgdmFyIHN5bWJvbFN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICBpZiAodGhpcy5fX2lzRW1wdHlCcnVzaCkge1xuICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XG4gICAgICBzeW1ib2xTdHlsZS5maWxsID0gaW5uZXJDb2xvciB8fCAnI2ZmZic7XG4gICAgICAvLyBUT0RPIFNhbWUgd2lkdGggd2l0aCBsaW5lU3R5bGUgaW4gTGluZVZpZXdcbiAgICAgIHN5bWJvbFN0eWxlLmxpbmVXaWR0aCA9IDI7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNoYXBlLnN5bWJvbFR5cGUgPT09ICdsaW5lJykge1xuICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN5bWJvbFN0eWxlLmZpbGwgPSBjb2xvcjtcbiAgICB9XG4gICAgdGhpcy5tYXJrUmVkcmF3KCk7XG4gIH1cbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBzeW1ib2wgZWxlbWVudCB3aXRoIGdpdmVuIHN5bWJvbCBjb25maWd1cmF0aW9uOiBzaGFwZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3JcclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3ltYm9sKHN5bWJvbFR5cGUsIHgsIHksIHcsIGgsIGNvbG9yLFxuLy8gd2hldGhlciB0byBrZWVwIHRoZSByYXRpbyBvZiB3L2gsXG5rZWVwQXNwZWN0KSB7XG4gIC8vIFRPRE8gU3VwcG9ydCBpbWFnZSBvYmplY3QsIER5bmFtaWNJbWFnZS5cbiAgdmFyIGlzRW1wdHkgPSBzeW1ib2xUeXBlLmluZGV4T2YoJ2VtcHR5JykgPT09IDA7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgc3ltYm9sVHlwZSA9IHN5bWJvbFR5cGUuc3Vic3RyKDUsIDEpLnRvTG93ZXJDYXNlKCkgKyBzeW1ib2xUeXBlLnN1YnN0cig2KTtcbiAgfVxuICB2YXIgc3ltYm9sUGF0aDtcbiAgaWYgKHN5bWJvbFR5cGUuaW5kZXhPZignaW1hZ2U6Ly8nKSA9PT0gMCkge1xuICAgIHN5bWJvbFBhdGggPSBncmFwaGljLm1ha2VJbWFnZShzeW1ib2xUeXBlLnNsaWNlKDgpLCBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHcsIGgpLCBrZWVwQXNwZWN0ID8gJ2NlbnRlcicgOiAnY292ZXInKTtcbiAgfSBlbHNlIGlmIChzeW1ib2xUeXBlLmluZGV4T2YoJ3BhdGg6Ly8nKSA9PT0gMCkge1xuICAgIHN5bWJvbFBhdGggPSBncmFwaGljLm1ha2VQYXRoKHN5bWJvbFR5cGUuc2xpY2UoNyksIHt9LCBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHcsIGgpLCBrZWVwQXNwZWN0ID8gJ2NlbnRlcicgOiAnY292ZXInKTtcbiAgfSBlbHNlIHtcbiAgICBzeW1ib2xQYXRoID0gbmV3IFN5bWJvbENseih7XG4gICAgICBzaGFwZToge1xuICAgICAgICBzeW1ib2xUeXBlOiBzeW1ib2xUeXBlLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgaGVpZ2h0OiBoXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3ltYm9sUGF0aC5fX2lzRW1wdHlCcnVzaCA9IGlzRW1wdHk7XG4gIC8vIFRPRE8gU2hvdWxkIGRlcHJlY2F0ZSBzZXRDb2xvclxuICBzeW1ib2xQYXRoLnNldENvbG9yID0gc3ltYm9sUGF0aFNldENvbG9yO1xuICBpZiAoY29sb3IpIHtcbiAgICBzeW1ib2xQYXRoLnNldENvbG9yKGNvbG9yKTtcbiAgfVxuICByZXR1cm4gc3ltYm9sUGF0aDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTeW1ib2xTaXplKHN5bWJvbFNpemUpIHtcbiAgaWYgKCFpc0FycmF5KHN5bWJvbFNpemUpKSB7XG4gICAgc3ltYm9sU2l6ZSA9IFsrc3ltYm9sU2l6ZSwgK3N5bWJvbFNpemVdO1xuICB9XG4gIHJldHVybiBbc3ltYm9sU2l6ZVswXSB8fCAwLCBzeW1ib2xTaXplWzFdIHx8IDBdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVN5bWJvbE9mZnNldChzeW1ib2xPZmZzZXQsIHN5bWJvbFNpemUpIHtcbiAgaWYgKHN5bWJvbE9mZnNldCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghaXNBcnJheShzeW1ib2xPZmZzZXQpKSB7XG4gICAgc3ltYm9sT2Zmc2V0ID0gW3N5bWJvbE9mZnNldCwgc3ltYm9sT2Zmc2V0XTtcbiAgfVxuICByZXR1cm4gW3BhcnNlUGVyY2VudChzeW1ib2xPZmZzZXRbMF0sIHN5bWJvbFNpemVbMF0pIHx8IDAsIHBhcnNlUGVyY2VudChyZXRyaWV2ZTIoc3ltYm9sT2Zmc2V0WzFdLCBzeW1ib2xPZmZzZXRbMF0pLCBzeW1ib2xTaXplWzFdKSB8fCAwXTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///62103\n")},63253:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   x: () => (/* binding */ createWrap)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * Animate multiple elements with a single done-callback.\r\n *\r\n * @example\r\n *  animation\r\n *      .createWrap()\r\n *      .add(el1, {x: 10, y: 10})\r\n *      .add(el2, {shape: {width: 500}, style: {fill: \'red\'}}, 400)\r\n *      .done(function () { // done })\r\n *      .start(\'cubicOut\');\r\n */\nvar AnimationWrap = /** @class */function () {\n  function AnimationWrap() {\n    this._storage = [];\n    this._elExistsMap = {};\n  }\n  /**\r\n   * Caution: a el can only be added once, otherwise \'done\'\r\n   * might not be called. This method checks this (by el.id),\r\n   * suppresses adding and returns false when existing el found.\r\n   *\r\n   * @return Whether adding succeeded.\r\n   */\n  AnimationWrap.prototype.add = function (el, target, duration, delay, easing) {\n    if (this._elExistsMap[el.id]) {\n      return false;\n    }\n    this._elExistsMap[el.id] = true;\n    this._storage.push({\n      el: el,\n      target: target,\n      duration: duration,\n      delay: delay,\n      easing: easing\n    });\n    return true;\n  };\n  /**\r\n   * Only execute when animation done/aborted.\r\n   */\n  AnimationWrap.prototype.finished = function (callback) {\n    this._finishedCallback = callback;\n    return this;\n  };\n  /**\r\n   * Will stop exist animation firstly.\r\n   */\n  AnimationWrap.prototype.start = function () {\n    var _this = this;\n    var count = this._storage.length;\n    var checkTerminate = function () {\n      count--;\n      if (count <= 0) {\n        // Guard.\n        _this._storage.length = 0;\n        _this._elExistsMap = {};\n        _this._finishedCallback && _this._finishedCallback();\n      }\n    };\n    for (var i = 0, len = this._storage.length; i < len; i++) {\n      var item = this._storage[i];\n      item.el.animateTo(item.target, {\n        duration: item.duration,\n        delay: item.delay,\n        easing: item.easing,\n        setToFinal: true,\n        done: checkTerminate,\n        aborted: checkTerminate\n      });\n    }\n    return this;\n  };\n  return AnimationWrap;\n}();\nfunction createWrap() {\n  return new AnimationWrap();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMyNTMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvYW5pbWF0aW9uLmpzP2ZiOWYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG4vKipcclxuICogQW5pbWF0ZSBtdWx0aXBsZSBlbGVtZW50cyB3aXRoIGEgc2luZ2xlIGRvbmUtY2FsbGJhY2suXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqICBhbmltYXRpb25cclxuICogICAgICAuY3JlYXRlV3JhcCgpXHJcbiAqICAgICAgLmFkZChlbDEsIHt4OiAxMCwgeTogMTB9KVxyXG4gKiAgICAgIC5hZGQoZWwyLCB7c2hhcGU6IHt3aWR0aDogNTAwfSwgc3R5bGU6IHtmaWxsOiAncmVkJ319LCA0MDApXHJcbiAqICAgICAgLmRvbmUoZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXHJcbiAqICAgICAgLnN0YXJ0KCdjdWJpY091dCcpO1xyXG4gKi9cbnZhciBBbmltYXRpb25XcmFwID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5pbWF0aW9uV3JhcCgpIHtcbiAgICB0aGlzLl9zdG9yYWdlID0gW107XG4gICAgdGhpcy5fZWxFeGlzdHNNYXAgPSB7fTtcbiAgfVxuICAvKipcclxuICAgKiBDYXV0aW9uOiBhIGVsIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UsIG90aGVyd2lzZSAnZG9uZSdcclxuICAgKiBtaWdodCBub3QgYmUgY2FsbGVkLiBUaGlzIG1ldGhvZCBjaGVja3MgdGhpcyAoYnkgZWwuaWQpLFxyXG4gICAqIHN1cHByZXNzZXMgYWRkaW5nIGFuZCByZXR1cm5zIGZhbHNlIHdoZW4gZXhpc3RpbmcgZWwgZm91bmQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIFdoZXRoZXIgYWRkaW5nIHN1Y2NlZWRlZC5cclxuICAgKi9cbiAgQW5pbWF0aW9uV3JhcC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGVsLCB0YXJnZXQsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKSB7XG4gICAgaWYgKHRoaXMuX2VsRXhpc3RzTWFwW2VsLmlkXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9lbEV4aXN0c01hcFtlbC5pZF0gPSB0cnVlO1xuICAgIHRoaXMuX3N0b3JhZ2UucHVzaCh7XG4gICAgICBlbDogZWwsXG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgIGVhc2luZzogZWFzaW5nXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIC8qKlxyXG4gICAqIE9ubHkgZXhlY3V0ZSB3aGVuIGFuaW1hdGlvbiBkb25lL2Fib3J0ZWQuXHJcbiAgICovXG4gIEFuaW1hdGlvbldyYXAucHJvdG90eXBlLmZpbmlzaGVkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fZmluaXNoZWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBXaWxsIHN0b3AgZXhpc3QgYW5pbWF0aW9uIGZpcnN0bHkuXHJcbiAgICovXG4gIEFuaW1hdGlvbldyYXAucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5fc3RvcmFnZS5sZW5ndGg7XG4gICAgdmFyIGNoZWNrVGVybWluYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnQtLTtcbiAgICAgIGlmIChjb3VudCA8PSAwKSB7XG4gICAgICAgIC8vIEd1YXJkLlxuICAgICAgICBfdGhpcy5fc3RvcmFnZS5sZW5ndGggPSAwO1xuICAgICAgICBfdGhpcy5fZWxFeGlzdHNNYXAgPSB7fTtcbiAgICAgICAgX3RoaXMuX2ZpbmlzaGVkQ2FsbGJhY2sgJiYgX3RoaXMuX2ZpbmlzaGVkQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9zdG9yYWdlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuX3N0b3JhZ2VbaV07XG4gICAgICBpdGVtLmVsLmFuaW1hdGVUbyhpdGVtLnRhcmdldCwge1xuICAgICAgICBkdXJhdGlvbjogaXRlbS5kdXJhdGlvbixcbiAgICAgICAgZGVsYXk6IGl0ZW0uZGVsYXksXG4gICAgICAgIGVhc2luZzogaXRlbS5lYXNpbmcsXG4gICAgICAgIHNldFRvRmluYWw6IHRydWUsXG4gICAgICAgIGRvbmU6IGNoZWNrVGVybWluYXRlLFxuICAgICAgICBhYm9ydGVkOiBjaGVja1Rlcm1pbmF0ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICByZXR1cm4gQW5pbWF0aW9uV3JhcDtcbn0oKTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVXcmFwKCkge1xuICByZXR1cm4gbmV3IEFuaW1hdGlvbldyYXAoKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///63253\n')},69622:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ setCommonECData),\n/* harmony export */   z: () => (/* binding */ getECData)\n/* harmony export */ });\n/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar getECData = (0,_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nvar setCommonECData = function (seriesIndex, dataType, dataIdx, el) {\n  if (el) {\n    var ecData = getECData(el);\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    ecData.dataIndex = dataIdx;\n    ecData.dataType = dataType;\n    ecData.seriesIndex = seriesIndex;\n    ecData.ssrType = \'chart\';\n    // TODO: not store dataIndex on children.\n    if (el.type === \'group\') {\n      el.traverse(function (child) {\n        var childECData = getECData(child);\n        childECData.seriesIndex = seriesIndex;\n        childECData.dataIndex = dataIdx;\n        childECData.dataType = dataType;\n        childECData.ssrType = \'chart\';\n      });\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk2MjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9pbm5lclN0b3JlLmpzPzRjZmUiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuL21vZGVsLmpzJztcbmV4cG9ydCB2YXIgZ2V0RUNEYXRhID0gbWFrZUlubmVyKCk7XG5leHBvcnQgdmFyIHNldENvbW1vbkVDRGF0YSA9IGZ1bmN0aW9uIChzZXJpZXNJbmRleCwgZGF0YVR5cGUsIGRhdGFJZHgsIGVsKSB7XG4gIGlmIChlbCkge1xuICAgIHZhciBlY0RhdGEgPSBnZXRFQ0RhdGEoZWwpO1xuICAgIC8vIEFkZCBkYXRhIGluZGV4IGFuZCBzZXJpZXMgaW5kZXggZm9yIGluZGV4aW5nIHRoZSBkYXRhIGJ5IGVsZW1lbnRcbiAgICAvLyBVc2VmdWwgaW4gdG9vbHRpcFxuICAgIGVjRGF0YS5kYXRhSW5kZXggPSBkYXRhSWR4O1xuICAgIGVjRGF0YS5kYXRhVHlwZSA9IGRhdGFUeXBlO1xuICAgIGVjRGF0YS5zZXJpZXNJbmRleCA9IHNlcmllc0luZGV4O1xuICAgIGVjRGF0YS5zc3JUeXBlID0gJ2NoYXJ0JztcbiAgICAvLyBUT0RPOiBub3Qgc3RvcmUgZGF0YUluZGV4IG9uIGNoaWxkcmVuLlxuICAgIGlmIChlbC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmFyIGNoaWxkRUNEYXRhID0gZ2V0RUNEYXRhKGNoaWxkKTtcbiAgICAgICAgY2hpbGRFQ0RhdGEuc2VyaWVzSW5kZXggPSBzZXJpZXNJbmRleDtcbiAgICAgICAgY2hpbGRFQ0RhdGEuZGF0YUluZGV4ID0gZGF0YUlkeDtcbiAgICAgICAgY2hpbGRFQ0RhdGEuZGF0YVR5cGUgPSBkYXRhVHlwZTtcbiAgICAgICAgY2hpbGRFQ0RhdGEuc3NyVHlwZSA9ICdjaGFydCc7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///69622\n')},81075:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   d: () => (/* binding */ ECEventProcessor)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _clazz_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30693);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n/**\r\n * Usage of query:\r\n * `chart.on('click', query, handler);`\r\n * The `query` can be:\r\n * + The component type query string, only `mainType` or `mainType.subType`,\r\n *   like: 'xAxis', 'series', 'xAxis.category' or 'series.line'.\r\n * + The component query object, like:\r\n *   `{seriesIndex: 2}`, `{seriesName: 'xx'}`, `{seriesId: 'some'}`,\r\n *   `{xAxisIndex: 2}`, `{xAxisName: 'xx'}`, `{xAxisId: 'some'}`.\r\n * + The data query object, like:\r\n *   `{dataIndex: 123}`, `{dataType: 'link'}`, `{name: 'some'}`.\r\n * + The other query object (cmponent customized query), like:\r\n *   `{element: 'some'}` (only available in custom series).\r\n *\r\n * Caveat: If a prop in the `query` object is `null/undefined`, it is the\r\n * same as there is no such prop in the `query` object.\r\n */\nvar ECEventProcessor = /** @class */function () {\n  function ECEventProcessor() {}\n  ECEventProcessor.prototype.normalizeQuery = function (query) {\n    var cptQuery = {};\n    var dataQuery = {};\n    var otherQuery = {};\n    // `query` is `mainType` or `mainType.subType` of component.\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString(query)) {\n      var condCptType = (0,_clazz_js__WEBPACK_IMPORTED_MODULE_1__/* .parseClassType */ .CC)(query);\n      // `.main` and `.sub` may be ''.\n      cptQuery.mainType = condCptType.main || null;\n      cptQuery.subType = condCptType.sub || null;\n    }\n    // `query` is an object, convert to {mainType, index, name, id}.\n    else {\n      // `xxxIndex`, `xxxName`, `xxxId`, `name`, `dataIndex`, `dataType` is reserved,\n      // can not be used in `compomentModel.filterForExposedEvent`.\n      var suffixes_1 = ['Index', 'Name', 'Id'];\n      var dataKeys_1 = {\n        name: 1,\n        dataIndex: 1,\n        dataType: 1\n      };\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(query, function (val, key) {\n        var reserved = false;\n        for (var i = 0; i < suffixes_1.length; i++) {\n          var propSuffix = suffixes_1[i];\n          var suffixPos = key.lastIndexOf(propSuffix);\n          if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {\n            var mainType = key.slice(0, suffixPos);\n            // Consider `dataIndex`.\n            if (mainType !== 'data') {\n              cptQuery.mainType = mainType;\n              cptQuery[propSuffix.toLowerCase()] = val;\n              reserved = true;\n            }\n          }\n        }\n        if (dataKeys_1.hasOwnProperty(key)) {\n          dataQuery[key] = val;\n          reserved = true;\n        }\n        if (!reserved) {\n          otherQuery[key] = val;\n        }\n      });\n    }\n    return {\n      cptQuery: cptQuery,\n      dataQuery: dataQuery,\n      otherQuery: otherQuery\n    };\n  };\n  ECEventProcessor.prototype.filter = function (eventType, query) {\n    // They should be assigned before each trigger call.\n    var eventInfo = this.eventInfo;\n    if (!eventInfo) {\n      return true;\n    }\n    var targetEl = eventInfo.targetEl;\n    var packedEvent = eventInfo.packedEvent;\n    var model = eventInfo.model;\n    var view = eventInfo.view;\n    // For event like 'globalout'.\n    if (!model || !view) {\n      return true;\n    }\n    var cptQuery = query.cptQuery;\n    var dataQuery = query.dataQuery;\n    return check(cptQuery, model, 'mainType') && check(cptQuery, model, 'subType') && check(cptQuery, model, 'index', 'componentIndex') && check(cptQuery, model, 'name') && check(cptQuery, model, 'id') && check(dataQuery, packedEvent, 'name') && check(dataQuery, packedEvent, 'dataIndex') && check(dataQuery, packedEvent, 'dataType') && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));\n    function check(query, host, prop, propOnHost) {\n      return query[prop] == null || host[propOnHost || prop] === query[prop];\n    }\n  };\n  ECEventProcessor.prototype.afterTrigger = function () {\n    // Make sure the eventInfo won't be used in next trigger.\n    this.eventInfo = null;\n  };\n  return ECEventProcessor;\n}();\n\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEwNzUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9FQ0V2ZW50UHJvY2Vzc29yLmpzPzZhMDgiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IHBhcnNlQ2xhc3NUeXBlIH0gZnJvbSAnLi9jbGF6ei5qcyc7XG4vKipcclxuICogVXNhZ2Ugb2YgcXVlcnk6XHJcbiAqIGBjaGFydC5vbignY2xpY2snLCBxdWVyeSwgaGFuZGxlcik7YFxyXG4gKiBUaGUgYHF1ZXJ5YCBjYW4gYmU6XHJcbiAqICsgVGhlIGNvbXBvbmVudCB0eXBlIHF1ZXJ5IHN0cmluZywgb25seSBgbWFpblR5cGVgIG9yIGBtYWluVHlwZS5zdWJUeXBlYCxcclxuICogICBsaWtlOiAneEF4aXMnLCAnc2VyaWVzJywgJ3hBeGlzLmNhdGVnb3J5JyBvciAnc2VyaWVzLmxpbmUnLlxyXG4gKiArIFRoZSBjb21wb25lbnQgcXVlcnkgb2JqZWN0LCBsaWtlOlxyXG4gKiAgIGB7c2VyaWVzSW5kZXg6IDJ9YCwgYHtzZXJpZXNOYW1lOiAneHgnfWAsIGB7c2VyaWVzSWQ6ICdzb21lJ31gLFxyXG4gKiAgIGB7eEF4aXNJbmRleDogMn1gLCBge3hBeGlzTmFtZTogJ3h4J31gLCBge3hBeGlzSWQ6ICdzb21lJ31gLlxyXG4gKiArIFRoZSBkYXRhIHF1ZXJ5IG9iamVjdCwgbGlrZTpcclxuICogICBge2RhdGFJbmRleDogMTIzfWAsIGB7ZGF0YVR5cGU6ICdsaW5rJ31gLCBge25hbWU6ICdzb21lJ31gLlxyXG4gKiArIFRoZSBvdGhlciBxdWVyeSBvYmplY3QgKGNtcG9uZW50IGN1c3RvbWl6ZWQgcXVlcnkpLCBsaWtlOlxyXG4gKiAgIGB7ZWxlbWVudDogJ3NvbWUnfWAgKG9ubHkgYXZhaWxhYmxlIGluIGN1c3RvbSBzZXJpZXMpLlxyXG4gKlxyXG4gKiBDYXZlYXQ6IElmIGEgcHJvcCBpbiB0aGUgYHF1ZXJ5YCBvYmplY3QgaXMgYG51bGwvdW5kZWZpbmVkYCwgaXQgaXMgdGhlXHJcbiAqIHNhbWUgYXMgdGhlcmUgaXMgbm8gc3VjaCBwcm9wIGluIHRoZSBgcXVlcnlgIG9iamVjdC5cclxuICovXG52YXIgRUNFdmVudFByb2Nlc3NvciA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVDRXZlbnRQcm9jZXNzb3IoKSB7fVxuICBFQ0V2ZW50UHJvY2Vzc29yLnByb3RvdHlwZS5ub3JtYWxpemVRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIHZhciBjcHRRdWVyeSA9IHt9O1xuICAgIHZhciBkYXRhUXVlcnkgPSB7fTtcbiAgICB2YXIgb3RoZXJRdWVyeSA9IHt9O1xuICAgIC8vIGBxdWVyeWAgaXMgYG1haW5UeXBlYCBvciBgbWFpblR5cGUuc3ViVHlwZWAgb2YgY29tcG9uZW50LlxuICAgIGlmICh6clV0aWwuaXNTdHJpbmcocXVlcnkpKSB7XG4gICAgICB2YXIgY29uZENwdFR5cGUgPSBwYXJzZUNsYXNzVHlwZShxdWVyeSk7XG4gICAgICAvLyBgLm1haW5gIGFuZCBgLnN1YmAgbWF5IGJlICcnLlxuICAgICAgY3B0UXVlcnkubWFpblR5cGUgPSBjb25kQ3B0VHlwZS5tYWluIHx8IG51bGw7XG4gICAgICBjcHRRdWVyeS5zdWJUeXBlID0gY29uZENwdFR5cGUuc3ViIHx8IG51bGw7XG4gICAgfVxuICAgIC8vIGBxdWVyeWAgaXMgYW4gb2JqZWN0LCBjb252ZXJ0IHRvIHttYWluVHlwZSwgaW5kZXgsIG5hbWUsIGlkfS5cbiAgICBlbHNlIHtcbiAgICAgIC8vIGB4eHhJbmRleGAsIGB4eHhOYW1lYCwgYHh4eElkYCwgYG5hbWVgLCBgZGF0YUluZGV4YCwgYGRhdGFUeXBlYCBpcyByZXNlcnZlZCxcbiAgICAgIC8vIGNhbiBub3QgYmUgdXNlZCBpbiBgY29tcG9tZW50TW9kZWwuZmlsdGVyRm9yRXhwb3NlZEV2ZW50YC5cbiAgICAgIHZhciBzdWZmaXhlc18xID0gWydJbmRleCcsICdOYW1lJywgJ0lkJ107XG4gICAgICB2YXIgZGF0YUtleXNfMSA9IHtcbiAgICAgICAgbmFtZTogMSxcbiAgICAgICAgZGF0YUluZGV4OiAxLFxuICAgICAgICBkYXRhVHlwZTogMVxuICAgICAgfTtcbiAgICAgIHpyVXRpbC5lYWNoKHF1ZXJ5LCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICAgICAgdmFyIHJlc2VydmVkID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VmZml4ZXNfMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wU3VmZml4ID0gc3VmZml4ZXNfMVtpXTtcbiAgICAgICAgICB2YXIgc3VmZml4UG9zID0ga2V5Lmxhc3RJbmRleE9mKHByb3BTdWZmaXgpO1xuICAgICAgICAgIGlmIChzdWZmaXhQb3MgPiAwICYmIHN1ZmZpeFBvcyA9PT0ga2V5Lmxlbmd0aCAtIHByb3BTdWZmaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbWFpblR5cGUgPSBrZXkuc2xpY2UoMCwgc3VmZml4UG9zKTtcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIGBkYXRhSW5kZXhgLlxuICAgICAgICAgICAgaWYgKG1haW5UeXBlICE9PSAnZGF0YScpIHtcbiAgICAgICAgICAgICAgY3B0UXVlcnkubWFpblR5cGUgPSBtYWluVHlwZTtcbiAgICAgICAgICAgICAgY3B0UXVlcnlbcHJvcFN1ZmZpeC50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgICAgICAgICAgICAgcmVzZXJ2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YUtleXNfMS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgZGF0YVF1ZXJ5W2tleV0gPSB2YWw7XG4gICAgICAgICAgcmVzZXJ2ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzZXJ2ZWQpIHtcbiAgICAgICAgICBvdGhlclF1ZXJ5W2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY3B0UXVlcnk6IGNwdFF1ZXJ5LFxuICAgICAgZGF0YVF1ZXJ5OiBkYXRhUXVlcnksXG4gICAgICBvdGhlclF1ZXJ5OiBvdGhlclF1ZXJ5XG4gICAgfTtcbiAgfTtcbiAgRUNFdmVudFByb2Nlc3Nvci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgcXVlcnkpIHtcbiAgICAvLyBUaGV5IHNob3VsZCBiZSBhc3NpZ25lZCBiZWZvcmUgZWFjaCB0cmlnZ2VyIGNhbGwuXG4gICAgdmFyIGV2ZW50SW5mbyA9IHRoaXMuZXZlbnRJbmZvO1xuICAgIGlmICghZXZlbnRJbmZvKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHRhcmdldEVsID0gZXZlbnRJbmZvLnRhcmdldEVsO1xuICAgIHZhciBwYWNrZWRFdmVudCA9IGV2ZW50SW5mby5wYWNrZWRFdmVudDtcbiAgICB2YXIgbW9kZWwgPSBldmVudEluZm8ubW9kZWw7XG4gICAgdmFyIHZpZXcgPSBldmVudEluZm8udmlldztcbiAgICAvLyBGb3IgZXZlbnQgbGlrZSAnZ2xvYmFsb3V0Jy5cbiAgICBpZiAoIW1vZGVsIHx8ICF2aWV3KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGNwdFF1ZXJ5ID0gcXVlcnkuY3B0UXVlcnk7XG4gICAgdmFyIGRhdGFRdWVyeSA9IHF1ZXJ5LmRhdGFRdWVyeTtcbiAgICByZXR1cm4gY2hlY2soY3B0UXVlcnksIG1vZGVsLCAnbWFpblR5cGUnKSAmJiBjaGVjayhjcHRRdWVyeSwgbW9kZWwsICdzdWJUeXBlJykgJiYgY2hlY2soY3B0UXVlcnksIG1vZGVsLCAnaW5kZXgnLCAnY29tcG9uZW50SW5kZXgnKSAmJiBjaGVjayhjcHRRdWVyeSwgbW9kZWwsICduYW1lJykgJiYgY2hlY2soY3B0UXVlcnksIG1vZGVsLCAnaWQnKSAmJiBjaGVjayhkYXRhUXVlcnksIHBhY2tlZEV2ZW50LCAnbmFtZScpICYmIGNoZWNrKGRhdGFRdWVyeSwgcGFja2VkRXZlbnQsICdkYXRhSW5kZXgnKSAmJiBjaGVjayhkYXRhUXVlcnksIHBhY2tlZEV2ZW50LCAnZGF0YVR5cGUnKSAmJiAoIXZpZXcuZmlsdGVyRm9yRXhwb3NlZEV2ZW50IHx8IHZpZXcuZmlsdGVyRm9yRXhwb3NlZEV2ZW50KGV2ZW50VHlwZSwgcXVlcnkub3RoZXJRdWVyeSwgdGFyZ2V0RWwsIHBhY2tlZEV2ZW50KSk7XG4gICAgZnVuY3Rpb24gY2hlY2socXVlcnksIGhvc3QsIHByb3AsIHByb3BPbkhvc3QpIHtcbiAgICAgIHJldHVybiBxdWVyeVtwcm9wXSA9PSBudWxsIHx8IGhvc3RbcHJvcE9uSG9zdCB8fCBwcm9wXSA9PT0gcXVlcnlbcHJvcF07XG4gICAgfVxuICB9O1xuICBFQ0V2ZW50UHJvY2Vzc29yLnByb3RvdHlwZS5hZnRlclRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBldmVudEluZm8gd29uJ3QgYmUgdXNlZCBpbiBuZXh0IHRyaWdnZXIuXG4gICAgdGhpcy5ldmVudEluZm8gPSBudWxsO1xuICB9O1xuICByZXR1cm4gRUNFdmVudFByb2Nlc3Nvcjtcbn0oKTtcbmV4cG9ydCB7IEVDRXZlbnRQcm9jZXNzb3IgfTtcbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///81075\n")},83412:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cb: () => (/* binding */ toCamelCase),\n/* harmony export */   JW: () => (/* binding */ windowOpen),\n/* harmony export */   QX: () => (/* binding */ normalizeCssArray),\n/* harmony export */   YK: () => (/* binding */ formatTpl),\n/* harmony export */   fU: () => (/* binding */ formatTime),\n/* harmony export */   he: () => (/* binding */ convertToColorString),\n/* harmony export */   io: () => (/* binding */ formatTplSimple),\n/* harmony export */   ob: () => (/* binding */ addCommas),\n/* harmony export */   qg: () => (/* binding */ getTooltipMarker),\n/* harmony export */   x5: () => (/* binding */ capitalFirst),\n/* harmony export */   yC: () => (/* binding */ makeValueReadable)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var zrender_lib_core_dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29687);\n/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24326);\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55854);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n/**\r\n * Add a comma each three digit.\r\n */\nfunction addCommas(x) {\n  if (!(0,_number_js__WEBPACK_IMPORTED_MODULE_0__/* .isNumeric */ .kf)(x)) {\n    return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString(x) ? x : '-';\n  }\n  var parts = (x + '').split('.');\n  return parts[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g, '$1,') + (parts.length > 1 ? '.' + parts[1] : '');\n}\nfunction toCamelCase(str, upperCaseFirst) {\n  str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {\n    return group1.toUpperCase();\n  });\n  if (upperCaseFirst && str) {\n    str = str.charAt(0).toUpperCase() + str.slice(1);\n  }\n  return str;\n}\nvar normalizeCssArray = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.normalizeCssArray;\n\n/**\r\n * Make value user readable for tooltip and label.\r\n * \"User readable\":\r\n *     Try to not print programmer-specific text like NaN, Infinity, null, undefined.\r\n *     Avoid to display an empty string, which users can not recognize there is\r\n *     a value and it might look like a bug.\r\n */\nfunction makeValueReadable(value, valueType, useUTC) {\n  var USER_READABLE_DEFUALT_TIME_PATTERN = '{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}';\n  function stringToUserReadable(str) {\n    return str && zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.trim(str) ? str : '-';\n  }\n  function isNumberUserReadable(num) {\n    return !!(num != null && !isNaN(num) && isFinite(num));\n  }\n  var isTypeTime = valueType === 'time';\n  var isValueDate = value instanceof Date;\n  if (isTypeTime || isValueDate) {\n    var date = isTypeTime ? (0,_number_js__WEBPACK_IMPORTED_MODULE_0__/* .parseDate */ ._U)(value) : value;\n    if (!isNaN(+date)) {\n      return (0,_time_js__WEBPACK_IMPORTED_MODULE_2__/* .format */ .GP)(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);\n    } else if (isValueDate) {\n      return '-';\n    }\n    // In other cases, continue to try to display the value in the following code.\n  }\n  if (valueType === 'ordinal') {\n    return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isStringSafe(value) ? stringToUserReadable(value) : zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isNumber(value) ? isNumberUserReadable(value) ? value + '' : '-' : '-';\n  }\n  // By default.\n  var numericResult = (0,_number_js__WEBPACK_IMPORTED_MODULE_0__/* .numericToNumber */ .Sm)(value);\n  return isNumberUserReadable(numericResult) ? addCommas(numericResult) : zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isStringSafe(value) ? stringToUserReadable(value) : typeof value === 'boolean' ? value + '' : '-';\n}\nvar TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\nvar wrapVar = function (varName, seriesIdx) {\n  return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n};\n/**\r\n * Template formatter\r\n * @param {Array.<Object>|Object} paramsList\r\n */\nfunction formatTpl(tpl, paramsList, encode) {\n  if (!zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray(paramsList)) {\n    paramsList = [paramsList];\n  }\n  var seriesLen = paramsList.length;\n  if (!seriesLen) {\n    return '';\n  }\n  var $vars = paramsList[0].$vars || [];\n  for (var i = 0; i < $vars.length; i++) {\n    var alias = TPL_VAR_ALIAS[i];\n    tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));\n  }\n  for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n    for (var k = 0; k < $vars.length; k++) {\n      var val = paramsList[seriesIdx][$vars[k]];\n      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? (0,zrender_lib_core_dom_js__WEBPACK_IMPORTED_MODULE_3__/* .encodeHTML */ .Me)(val) : val);\n    }\n  }\n  return tpl;\n}\n/**\r\n * simple Template formatter\r\n */\nfunction formatTplSimple(tpl, param, encode) {\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(param, function (value, key) {\n    tpl = tpl.replace('{' + key + '}', encode ? (0,zrender_lib_core_dom_js__WEBPACK_IMPORTED_MODULE_3__/* .encodeHTML */ .Me)(value) : value);\n  });\n  return tpl;\n}\nfunction getTooltipMarker(inOpt, extraCssText) {\n  var opt = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString(inOpt) ? {\n    color: inOpt,\n    extraCssText: extraCssText\n  } : inOpt || {};\n  var color = opt.color;\n  var type = opt.type;\n  extraCssText = opt.extraCssText;\n  var renderMode = opt.renderMode || 'html';\n  if (!color) {\n    return '';\n  }\n  if (renderMode === 'html') {\n    return type === 'subItem' ? '<span style=\"display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;' + 'border-radius:4px;width:4px;height:4px;background-color:'\n    // Only support string\n    + (0,zrender_lib_core_dom_js__WEBPACK_IMPORTED_MODULE_3__/* .encodeHTML */ .Me)(color) + ';' + (extraCssText || '') + '\"></span>' : '<span style=\"display:inline-block;margin-right:4px;' + 'border-radius:10px;width:10px;height:10px;background-color:' + (0,zrender_lib_core_dom_js__WEBPACK_IMPORTED_MODULE_3__/* .encodeHTML */ .Me)(color) + ';' + (extraCssText || '') + '\"></span>';\n  } else {\n    // Should better not to auto generate style name by auto-increment number here.\n    // Because this util is usually called in tooltip formatter, which is probably\n    // called repeatedly when mouse move and the auto-increment number increases fast.\n    // Users can make their own style name by theirselves, make it unique and readable.\n    var markerId = opt.markerId || 'markerX';\n    return {\n      renderMode: renderMode,\n      content: '{' + markerId + '|}  ',\n      style: type === 'subItem' ? {\n        width: 4,\n        height: 4,\n        borderRadius: 2,\n        backgroundColor: color\n      } : {\n        width: 10,\n        height: 10,\n        borderRadius: 5,\n        backgroundColor: color\n      }\n    };\n  }\n}\n/**\r\n * @deprecated Use `time/format` instead.\r\n * ISO Date format\r\n * @param {string} tpl\r\n * @param {number} value\r\n * @param {boolean} [isUTC=false] Default in local time.\r\n *           see `module:echarts/scale/Time`\r\n *           and `module:echarts/util/number#parseDate`.\r\n * @inner\r\n */\nfunction formatTime(tpl, value, isUTC) {\n  if (false) {}\n  if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {\n    tpl = 'MM-dd\\nyyyy';\n  }\n  var date = (0,_number_js__WEBPACK_IMPORTED_MODULE_0__/* .parseDate */ ._U)(value);\n  var getUTC = isUTC ? 'getUTC' : 'get';\n  var y = date[getUTC + 'FullYear']();\n  var M = date[getUTC + 'Month']() + 1;\n  var d = date[getUTC + 'Date']();\n  var h = date[getUTC + 'Hours']();\n  var m = date[getUTC + 'Minutes']();\n  var s = date[getUTC + 'Seconds']();\n  var S = date[getUTC + 'Milliseconds']();\n  tpl = tpl.replace('MM', (0,_time_js__WEBPACK_IMPORTED_MODULE_2__/* .pad */ .eV)(M, 2)).replace('M', M).replace('yyyy', y).replace('yy', (0,_time_js__WEBPACK_IMPORTED_MODULE_2__/* .pad */ .eV)(y % 100 + '', 2)).replace('dd', (0,_time_js__WEBPACK_IMPORTED_MODULE_2__/* .pad */ .eV)(d, 2)).replace('d', d).replace('hh', (0,_time_js__WEBPACK_IMPORTED_MODULE_2__/* .pad */ .eV)(h, 2)).replace('h', h).replace('mm', (0,_time_js__WEBPACK_IMPORTED_MODULE_2__/* .pad */ .eV)(m, 2)).replace('m', m).replace('ss', (0,_time_js__WEBPACK_IMPORTED_MODULE_2__/* .pad */ .eV)(s, 2)).replace('s', s).replace('SSS', (0,_time_js__WEBPACK_IMPORTED_MODULE_2__/* .pad */ .eV)(S, 3));\n  return tpl;\n}\n/**\r\n * Capital first\r\n * @param {string} str\r\n * @return {string}\r\n */\nfunction capitalFirst(str) {\n  return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n}\n/**\r\n * @return Never be null/undefined.\r\n */\nfunction convertToColorString(color, defaultColor) {\n  defaultColor = defaultColor || 'transparent';\n  return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString(color) ? color : zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject(color) ? color.colorStops && (color.colorStops[0] || {}).color || defaultColor : defaultColor;\n}\n\n/**\r\n * open new tab\r\n * @param link url\r\n * @param target blank or self\r\n */\nfunction windowOpen(link, target) {\n  /* global window */\n  if (target === '_blank' || target === 'blank') {\n    var blank = window.open();\n    blank.opener = null;\n    blank.location.href = link;\n  } else {\n    window.open(link, target);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODM0MTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9mb3JtYXQuanM/Y2Y4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgZW5jb2RlSFRNTCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvZG9tLmpzJztcbmltcG9ydCB7IHBhcnNlRGF0ZSwgaXNOdW1lcmljLCBudW1lcmljVG9OdW1iZXIgfSBmcm9tICcuL251bWJlci5qcyc7XG5pbXBvcnQgeyBmb3JtYXQgYXMgdGltZUZvcm1hdCwgcGFkIH0gZnJvbSAnLi90aW1lLmpzJztcbmltcG9ydCB7IGRlcHJlY2F0ZVJlcGxhY2VMb2cgfSBmcm9tICcuL2xvZy5qcyc7XG4vKipcclxuICogQWRkIGEgY29tbWEgZWFjaCB0aHJlZSBkaWdpdC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ29tbWFzKHgpIHtcbiAgaWYgKCFpc051bWVyaWMoeCkpIHtcbiAgICByZXR1cm4genJVdGlsLmlzU3RyaW5nKHgpID8geCA6ICctJztcbiAgfVxuICB2YXIgcGFydHMgPSAoeCArICcnKS5zcGxpdCgnLicpO1xuICByZXR1cm4gcGFydHNbMF0ucmVwbGFjZSgvKFxcZHsxLDN9KSg/PSg/OlxcZHszfSkrKD8hXFxkKSkvZywgJyQxLCcpICsgKHBhcnRzLmxlbmd0aCA+IDEgPyAnLicgKyBwYXJ0c1sxXSA6ICcnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0NhbWVsQ2FzZShzdHIsIHVwcGVyQ2FzZUZpcnN0KSB7XG4gIHN0ciA9IChzdHIgfHwgJycpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGdyb3VwMSkge1xuICAgIHJldHVybiBncm91cDEudG9VcHBlckNhc2UoKTtcbiAgfSk7XG4gIGlmICh1cHBlckNhc2VGaXJzdCAmJiBzdHIpIHtcbiAgICBzdHIgPSBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydCB2YXIgbm9ybWFsaXplQ3NzQXJyYXkgPSB6clV0aWwubm9ybWFsaXplQ3NzQXJyYXk7XG5leHBvcnQgeyBlbmNvZGVIVE1MIH07XG4vKipcclxuICogTWFrZSB2YWx1ZSB1c2VyIHJlYWRhYmxlIGZvciB0b29sdGlwIGFuZCBsYWJlbC5cclxuICogXCJVc2VyIHJlYWRhYmxlXCI6XHJcbiAqICAgICBUcnkgdG8gbm90IHByaW50IHByb2dyYW1tZXItc3BlY2lmaWMgdGV4dCBsaWtlIE5hTiwgSW5maW5pdHksIG51bGwsIHVuZGVmaW5lZC5cclxuICogICAgIEF2b2lkIHRvIGRpc3BsYXkgYW4gZW1wdHkgc3RyaW5nLCB3aGljaCB1c2VycyBjYW4gbm90IHJlY29nbml6ZSB0aGVyZSBpc1xyXG4gKiAgICAgYSB2YWx1ZSBhbmQgaXQgbWlnaHQgbG9vayBsaWtlIGEgYnVnLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlVmFsdWVSZWFkYWJsZSh2YWx1ZSwgdmFsdWVUeXBlLCB1c2VVVEMpIHtcbiAgdmFyIFVTRVJfUkVBREFCTEVfREVGVUFMVF9USU1FX1BBVFRFUk4gPSAne3l5eXl9LXtNTX0te2RkfSB7SEh9OnttbX06e3NzfSc7XG4gIGZ1bmN0aW9uIHN0cmluZ1RvVXNlclJlYWRhYmxlKHN0cikge1xuICAgIHJldHVybiBzdHIgJiYgenJVdGlsLnRyaW0oc3RyKSA/IHN0ciA6ICctJztcbiAgfVxuICBmdW5jdGlvbiBpc051bWJlclVzZXJSZWFkYWJsZShudW0pIHtcbiAgICByZXR1cm4gISEobnVtICE9IG51bGwgJiYgIWlzTmFOKG51bSkgJiYgaXNGaW5pdGUobnVtKSk7XG4gIH1cbiAgdmFyIGlzVHlwZVRpbWUgPSB2YWx1ZVR5cGUgPT09ICd0aW1lJztcbiAgdmFyIGlzVmFsdWVEYXRlID0gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xuICBpZiAoaXNUeXBlVGltZSB8fCBpc1ZhbHVlRGF0ZSkge1xuICAgIHZhciBkYXRlID0gaXNUeXBlVGltZSA/IHBhcnNlRGF0ZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICBpZiAoIWlzTmFOKCtkYXRlKSkge1xuICAgICAgcmV0dXJuIHRpbWVGb3JtYXQoZGF0ZSwgVVNFUl9SRUFEQUJMRV9ERUZVQUxUX1RJTUVfUEFUVEVSTiwgdXNlVVRDKTtcbiAgICB9IGVsc2UgaWYgKGlzVmFsdWVEYXRlKSB7XG4gICAgICByZXR1cm4gJy0nO1xuICAgIH1cbiAgICAvLyBJbiBvdGhlciBjYXNlcywgY29udGludWUgdG8gdHJ5IHRvIGRpc3BsYXkgdGhlIHZhbHVlIGluIHRoZSBmb2xsb3dpbmcgY29kZS5cbiAgfVxuICBpZiAodmFsdWVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICByZXR1cm4genJVdGlsLmlzU3RyaW5nU2FmZSh2YWx1ZSkgPyBzdHJpbmdUb1VzZXJSZWFkYWJsZSh2YWx1ZSkgOiB6clV0aWwuaXNOdW1iZXIodmFsdWUpID8gaXNOdW1iZXJVc2VyUmVhZGFibGUodmFsdWUpID8gdmFsdWUgKyAnJyA6ICctJyA6ICctJztcbiAgfVxuICAvLyBCeSBkZWZhdWx0LlxuICB2YXIgbnVtZXJpY1Jlc3VsdCA9IG51bWVyaWNUb051bWJlcih2YWx1ZSk7XG4gIHJldHVybiBpc051bWJlclVzZXJSZWFkYWJsZShudW1lcmljUmVzdWx0KSA/IGFkZENvbW1hcyhudW1lcmljUmVzdWx0KSA6IHpyVXRpbC5pc1N0cmluZ1NhZmUodmFsdWUpID8gc3RyaW5nVG9Vc2VyUmVhZGFibGUodmFsdWUpIDogdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgPyB2YWx1ZSArICcnIDogJy0nO1xufVxudmFyIFRQTF9WQVJfQUxJQVMgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnXTtcbnZhciB3cmFwVmFyID0gZnVuY3Rpb24gKHZhck5hbWUsIHNlcmllc0lkeCkge1xuICByZXR1cm4gJ3snICsgdmFyTmFtZSArIChzZXJpZXNJZHggPT0gbnVsbCA/ICcnIDogc2VyaWVzSWR4KSArICd9Jztcbn07XG4vKipcclxuICogVGVtcGxhdGUgZm9ybWF0dGVyXHJcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD58T2JqZWN0fSBwYXJhbXNMaXN0XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRwbCh0cGwsIHBhcmFtc0xpc3QsIGVuY29kZSkge1xuICBpZiAoIXpyVXRpbC5pc0FycmF5KHBhcmFtc0xpc3QpKSB7XG4gICAgcGFyYW1zTGlzdCA9IFtwYXJhbXNMaXN0XTtcbiAgfVxuICB2YXIgc2VyaWVzTGVuID0gcGFyYW1zTGlzdC5sZW5ndGg7XG4gIGlmICghc2VyaWVzTGVuKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciAkdmFycyA9IHBhcmFtc0xpc3RbMF0uJHZhcnMgfHwgW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgJHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYWxpYXMgPSBUUExfVkFSX0FMSUFTW2ldO1xuICAgIHRwbCA9IHRwbC5yZXBsYWNlKHdyYXBWYXIoYWxpYXMpLCB3cmFwVmFyKGFsaWFzLCAwKSk7XG4gIH1cbiAgZm9yICh2YXIgc2VyaWVzSWR4ID0gMDsgc2VyaWVzSWR4IDwgc2VyaWVzTGVuOyBzZXJpZXNJZHgrKykge1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgJHZhcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciB2YWwgPSBwYXJhbXNMaXN0W3Nlcmllc0lkeF1bJHZhcnNba11dO1xuICAgICAgdHBsID0gdHBsLnJlcGxhY2Uod3JhcFZhcihUUExfVkFSX0FMSUFTW2tdLCBzZXJpZXNJZHgpLCBlbmNvZGUgPyBlbmNvZGVIVE1MKHZhbCkgOiB2YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHBsO1xufVxuLyoqXHJcbiAqIHNpbXBsZSBUZW1wbGF0ZSBmb3JtYXR0ZXJcclxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VHBsU2ltcGxlKHRwbCwgcGFyYW0sIGVuY29kZSkge1xuICB6clV0aWwuZWFjaChwYXJhbSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICB0cGwgPSB0cGwucmVwbGFjZSgneycgKyBrZXkgKyAnfScsIGVuY29kZSA/IGVuY29kZUhUTUwodmFsdWUpIDogdmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIHRwbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb29sdGlwTWFya2VyKGluT3B0LCBleHRyYUNzc1RleHQpIHtcbiAgdmFyIG9wdCA9IHpyVXRpbC5pc1N0cmluZyhpbk9wdCkgPyB7XG4gICAgY29sb3I6IGluT3B0LFxuICAgIGV4dHJhQ3NzVGV4dDogZXh0cmFDc3NUZXh0XG4gIH0gOiBpbk9wdCB8fCB7fTtcbiAgdmFyIGNvbG9yID0gb3B0LmNvbG9yO1xuICB2YXIgdHlwZSA9IG9wdC50eXBlO1xuICBleHRyYUNzc1RleHQgPSBvcHQuZXh0cmFDc3NUZXh0O1xuICB2YXIgcmVuZGVyTW9kZSA9IG9wdC5yZW5kZXJNb2RlIHx8ICdodG1sJztcbiAgaWYgKCFjb2xvcikge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAocmVuZGVyTW9kZSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdzdWJJdGVtJyA/ICc8c3BhbiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTttYXJnaW4tcmlnaHQ6OHB4O21hcmdpbi1sZWZ0OjNweDsnICsgJ2JvcmRlci1yYWRpdXM6NHB4O3dpZHRoOjRweDtoZWlnaHQ6NHB4O2JhY2tncm91bmQtY29sb3I6J1xuICAgIC8vIE9ubHkgc3VwcG9ydCBzdHJpbmdcbiAgICArIGVuY29kZUhUTUwoY29sb3IpICsgJzsnICsgKGV4dHJhQ3NzVGV4dCB8fCAnJykgKyAnXCI+PC9zcGFuPicgOiAnPHNwYW4gc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tcmlnaHQ6NHB4OycgKyAnYm9yZGVyLXJhZGl1czoxMHB4O3dpZHRoOjEwcHg7aGVpZ2h0OjEwcHg7YmFja2dyb3VuZC1jb2xvcjonICsgZW5jb2RlSFRNTChjb2xvcikgKyAnOycgKyAoZXh0cmFDc3NUZXh0IHx8ICcnKSArICdcIj48L3NwYW4+JztcbiAgfSBlbHNlIHtcbiAgICAvLyBTaG91bGQgYmV0dGVyIG5vdCB0byBhdXRvIGdlbmVyYXRlIHN0eWxlIG5hbWUgYnkgYXV0by1pbmNyZW1lbnQgbnVtYmVyIGhlcmUuXG4gICAgLy8gQmVjYXVzZSB0aGlzIHV0aWwgaXMgdXN1YWxseSBjYWxsZWQgaW4gdG9vbHRpcCBmb3JtYXR0ZXIsIHdoaWNoIGlzIHByb2JhYmx5XG4gICAgLy8gY2FsbGVkIHJlcGVhdGVkbHkgd2hlbiBtb3VzZSBtb3ZlIGFuZCB0aGUgYXV0by1pbmNyZW1lbnQgbnVtYmVyIGluY3JlYXNlcyBmYXN0LlxuICAgIC8vIFVzZXJzIGNhbiBtYWtlIHRoZWlyIG93biBzdHlsZSBuYW1lIGJ5IHRoZWlyc2VsdmVzLCBtYWtlIGl0IHVuaXF1ZSBhbmQgcmVhZGFibGUuXG4gICAgdmFyIG1hcmtlcklkID0gb3B0Lm1hcmtlcklkIHx8ICdtYXJrZXJYJztcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyTW9kZTogcmVuZGVyTW9kZSxcbiAgICAgIGNvbnRlbnQ6ICd7JyArIG1hcmtlcklkICsgJ3x9ICAnLFxuICAgICAgc3R5bGU6IHR5cGUgPT09ICdzdWJJdGVtJyA/IHtcbiAgICAgICAgd2lkdGg6IDQsXG4gICAgICAgIGhlaWdodDogNCxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAyLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yXG4gICAgICB9IDoge1xuICAgICAgICB3aWR0aDogMTAsXG4gICAgICAgIGhlaWdodDogMTAsXG4gICAgICAgIGJvcmRlclJhZGl1czogNSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvclxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHRpbWUvZm9ybWF0YCBpbnN0ZWFkLlxyXG4gKiBJU08gRGF0ZSBmb3JtYXRcclxuICogQHBhcmFtIHtzdHJpbmd9IHRwbFxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFufSBbaXNVVEM9ZmFsc2VdIERlZmF1bHQgaW4gbG9jYWwgdGltZS5cclxuICogICAgICAgICAgIHNlZSBgbW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZWBcclxuICogICAgICAgICAgIGFuZCBgbW9kdWxlOmVjaGFydHMvdXRpbC9udW1iZXIjcGFyc2VEYXRlYC5cclxuICogQGlubmVyXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRpbWUodHBsLCB2YWx1ZSwgaXNVVEMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZXByZWNhdGVSZXBsYWNlTG9nKCdlY2hhcnRzLmZvcm1hdC5mb3JtYXRUaW1lJywgJ2VjaGFydHMudGltZS5mb3JtYXQnKTtcbiAgfVxuICBpZiAodHBsID09PSAnd2VlaycgfHwgdHBsID09PSAnbW9udGgnIHx8IHRwbCA9PT0gJ3F1YXJ0ZXInIHx8IHRwbCA9PT0gJ2hhbGYteWVhcicgfHwgdHBsID09PSAneWVhcicpIHtcbiAgICB0cGwgPSAnTU0tZGRcXG55eXl5JztcbiAgfVxuICB2YXIgZGF0ZSA9IHBhcnNlRGF0ZSh2YWx1ZSk7XG4gIHZhciBnZXRVVEMgPSBpc1VUQyA/ICdnZXRVVEMnIDogJ2dldCc7XG4gIHZhciB5ID0gZGF0ZVtnZXRVVEMgKyAnRnVsbFllYXInXSgpO1xuICB2YXIgTSA9IGRhdGVbZ2V0VVRDICsgJ01vbnRoJ10oKSArIDE7XG4gIHZhciBkID0gZGF0ZVtnZXRVVEMgKyAnRGF0ZSddKCk7XG4gIHZhciBoID0gZGF0ZVtnZXRVVEMgKyAnSG91cnMnXSgpO1xuICB2YXIgbSA9IGRhdGVbZ2V0VVRDICsgJ01pbnV0ZXMnXSgpO1xuICB2YXIgcyA9IGRhdGVbZ2V0VVRDICsgJ1NlY29uZHMnXSgpO1xuICB2YXIgUyA9IGRhdGVbZ2V0VVRDICsgJ01pbGxpc2Vjb25kcyddKCk7XG4gIHRwbCA9IHRwbC5yZXBsYWNlKCdNTScsIHBhZChNLCAyKSkucmVwbGFjZSgnTScsIE0pLnJlcGxhY2UoJ3l5eXknLCB5KS5yZXBsYWNlKCd5eScsIHBhZCh5ICUgMTAwICsgJycsIDIpKS5yZXBsYWNlKCdkZCcsIHBhZChkLCAyKSkucmVwbGFjZSgnZCcsIGQpLnJlcGxhY2UoJ2hoJywgcGFkKGgsIDIpKS5yZXBsYWNlKCdoJywgaCkucmVwbGFjZSgnbW0nLCBwYWQobSwgMikpLnJlcGxhY2UoJ20nLCBtKS5yZXBsYWNlKCdzcycsIHBhZChzLCAyKSkucmVwbGFjZSgncycsIHMpLnJlcGxhY2UoJ1NTUycsIHBhZChTLCAzKSk7XG4gIHJldHVybiB0cGw7XG59XG4vKipcclxuICogQ2FwaXRhbCBmaXJzdFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FwaXRhbEZpcnN0KHN0cikge1xuICByZXR1cm4gc3RyID8gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cigxKSA6IHN0cjtcbn1cbi8qKlxyXG4gKiBAcmV0dXJuIE5ldmVyIGJlIG51bGwvdW5kZWZpbmVkLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9Db2xvclN0cmluZyhjb2xvciwgZGVmYXVsdENvbG9yKSB7XG4gIGRlZmF1bHRDb2xvciA9IGRlZmF1bHRDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICByZXR1cm4genJVdGlsLmlzU3RyaW5nKGNvbG9yKSA/IGNvbG9yIDogenJVdGlsLmlzT2JqZWN0KGNvbG9yKSA/IGNvbG9yLmNvbG9yU3RvcHMgJiYgKGNvbG9yLmNvbG9yU3RvcHNbMF0gfHwge30pLmNvbG9yIHx8IGRlZmF1bHRDb2xvciA6IGRlZmF1bHRDb2xvcjtcbn1cbmV4cG9ydCB7IHRydW5jYXRlVGV4dCB9IGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BhcnNlVGV4dC5qcyc7XG4vKipcclxuICogb3BlbiBuZXcgdGFiXHJcbiAqIEBwYXJhbSBsaW5rIHVybFxyXG4gKiBAcGFyYW0gdGFyZ2V0IGJsYW5rIG9yIHNlbGZcclxuICovXG5leHBvcnQgZnVuY3Rpb24gd2luZG93T3BlbihsaW5rLCB0YXJnZXQpIHtcbiAgLyogZ2xvYmFsIHdpbmRvdyAqL1xuICBpZiAodGFyZ2V0ID09PSAnX2JsYW5rJyB8fCB0YXJnZXQgPT09ICdibGFuaycpIHtcbiAgICB2YXIgYmxhbmsgPSB3aW5kb3cub3BlbigpO1xuICAgIGJsYW5rLm9wZW5lciA9IG51bGw7XG4gICAgYmxhbmsubG9jYXRpb24uaHJlZiA9IGxpbms7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93Lm9wZW4obGluaywgdGFyZ2V0KTtcbiAgfVxufVxuZXhwb3J0IHsgZ2V0VGV4dFJlY3QgfSBmcm9tICcuLi9sZWdhY3kvZ2V0VGV4dFJlY3QuanMnOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///83412\n")},84618:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _graphic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59482);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n/**\r\n * Sausage: similar to sector, but have half circle on both sides\r\n */\nvar SausageShape = /** @class */function () {\n  function SausageShape() {\n    this.cx = 0;\n    this.cy = 0;\n    this.r0 = 0;\n    this.r = 0;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.clockwise = true;\n  }\n  return SausageShape;\n}();\nvar SausagePath = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(SausagePath, _super);\n  function SausagePath(opts) {\n    var _this = _super.call(this, opts) || this;\n    _this.type = \'sausage\';\n    return _this;\n  }\n  SausagePath.prototype.getDefaultShape = function () {\n    return new SausageShape();\n  };\n  SausagePath.prototype.buildPath = function (ctx, shape) {\n    var cx = shape.cx;\n    var cy = shape.cy;\n    var r0 = Math.max(shape.r0 || 0, 0);\n    var r = Math.max(shape.r, 0);\n    var dr = (r - r0) * 0.5;\n    var rCenter = r0 + dr;\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var PI2 = Math.PI * 2;\n    var lessThanCircle = clockwise ? endAngle - startAngle < PI2 : startAngle - endAngle < PI2;\n    if (!lessThanCircle) {\n      // Normalize angles\n      startAngle = endAngle - (clockwise ? PI2 : -PI2);\n    }\n    var unitStartX = Math.cos(startAngle);\n    var unitStartY = Math.sin(startAngle);\n    var unitEndX = Math.cos(endAngle);\n    var unitEndY = Math.sin(endAngle);\n    if (lessThanCircle) {\n      ctx.moveTo(unitStartX * r0 + cx, unitStartY * r0 + cy);\n      ctx.arc(unitStartX * rCenter + cx, unitStartY * rCenter + cy, dr, -Math.PI + startAngle, startAngle, !clockwise);\n    } else {\n      ctx.moveTo(unitStartX * r + cx, unitStartY * r + cy);\n    }\n    ctx.arc(cx, cy, r, startAngle, endAngle, !clockwise);\n    ctx.arc(unitEndX * rCenter + cx, unitEndY * rCenter + cy, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);\n    if (r0 !== 0) {\n      ctx.arc(cx, cy, r0, endAngle, startAngle, clockwise);\n    }\n    // ctx.closePath();\n  };\n  return SausagePath;\n}(_graphic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SausagePath);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ2MTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi91dGlsL3NoYXBlL3NhdXNhZ2UuanM/MjI4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uL2dyYXBoaWMuanMnO1xuLyoqXHJcbiAqIFNhdXNhZ2U6IHNpbWlsYXIgdG8gc2VjdG9yLCBidXQgaGF2ZSBoYWxmIGNpcmNsZSBvbiBib3RoIHNpZGVzXHJcbiAqL1xudmFyIFNhdXNhZ2VTaGFwZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNhdXNhZ2VTaGFwZSgpIHtcbiAgICB0aGlzLmN4ID0gMDtcbiAgICB0aGlzLmN5ID0gMDtcbiAgICB0aGlzLnIwID0gMDtcbiAgICB0aGlzLnIgPSAwO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IDA7XG4gICAgdGhpcy5lbmRBbmdsZSA9IE1hdGguUEkgKiAyO1xuICAgIHRoaXMuY2xvY2t3aXNlID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gU2F1c2FnZVNoYXBlO1xufSgpO1xudmFyIFNhdXNhZ2VQYXRoID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNhdXNhZ2VQYXRoLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBTYXVzYWdlUGF0aChvcHRzKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gJ3NhdXNhZ2UnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBTYXVzYWdlUGF0aC5wcm90b3R5cGUuZ2V0RGVmYXVsdFNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU2F1c2FnZVNoYXBlKCk7XG4gIH07XG4gIFNhdXNhZ2VQYXRoLnByb3RvdHlwZS5idWlsZFBhdGggPSBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciBjeCA9IHNoYXBlLmN4O1xuICAgIHZhciBjeSA9IHNoYXBlLmN5O1xuICAgIHZhciByMCA9IE1hdGgubWF4KHNoYXBlLnIwIHx8IDAsIDApO1xuICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgdmFyIGRyID0gKHIgLSByMCkgKiAwLjU7XG4gICAgdmFyIHJDZW50ZXIgPSByMCArIGRyO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICB2YXIgY2xvY2t3aXNlID0gc2hhcGUuY2xvY2t3aXNlO1xuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICB2YXIgbGVzc1RoYW5DaXJjbGUgPSBjbG9ja3dpc2UgPyBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPCBQSTIgOiBzdGFydEFuZ2xlIC0gZW5kQW5nbGUgPCBQSTI7XG4gICAgaWYgKCFsZXNzVGhhbkNpcmNsZSkge1xuICAgICAgLy8gTm9ybWFsaXplIGFuZ2xlc1xuICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlIC0gKGNsb2Nrd2lzZSA/IFBJMiA6IC1QSTIpO1xuICAgIH1cbiAgICB2YXIgdW5pdFN0YXJ0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIHZhciB1bml0U3RhcnRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgdmFyIHVuaXRFbmRYID0gTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgIHZhciB1bml0RW5kWSA9IE1hdGguc2luKGVuZEFuZ2xlKTtcbiAgICBpZiAobGVzc1RoYW5DaXJjbGUpIHtcbiAgICAgIGN0eC5tb3ZlVG8odW5pdFN0YXJ0WCAqIHIwICsgY3gsIHVuaXRTdGFydFkgKiByMCArIGN5KTtcbiAgICAgIGN0eC5hcmModW5pdFN0YXJ0WCAqIHJDZW50ZXIgKyBjeCwgdW5pdFN0YXJ0WSAqIHJDZW50ZXIgKyBjeSwgZHIsIC1NYXRoLlBJICsgc3RhcnRBbmdsZSwgc3RhcnRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5tb3ZlVG8odW5pdFN0YXJ0WCAqIHIgKyBjeCwgdW5pdFN0YXJ0WSAqIHIgKyBjeSk7XG4gICAgfVxuICAgIGN0eC5hcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gICAgY3R4LmFyYyh1bml0RW5kWCAqIHJDZW50ZXIgKyBjeCwgdW5pdEVuZFkgKiByQ2VudGVyICsgY3ksIGRyLCBlbmRBbmdsZSAtIE1hdGguUEkgKiAyLCBlbmRBbmdsZSAtIE1hdGguUEksICFjbG9ja3dpc2UpO1xuICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgY3R4LmFyYyhjeCwgY3ksIHIwLCBlbmRBbmdsZSwgc3RhcnRBbmdsZSwgY2xvY2t3aXNlKTtcbiAgICB9XG4gICAgLy8gY3R4LmNsb3NlUGF0aCgpO1xuICB9O1xuICByZXR1cm4gU2F1c2FnZVBhdGg7XG59KFBhdGgpO1xuZXhwb3J0IGRlZmF1bHQgU2F1c2FnZVBhdGg7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///84618\n')}}]);