"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[5165],{363:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/geo/GeoModel.js\nvar GeoModel = __webpack_require__(93074);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/geo/geoCreator.js + 1 modules\nvar geoCreator = __webpack_require__(98592);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/action/roamHelper.js\nvar roamHelper = __webpack_require__(78536);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/MapDraw.js\nvar MapDraw = __webpack_require__(8027);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar Component = __webpack_require__(59109);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/event.js\nvar util_event = __webpack_require__(47411);\n;// ./node_modules/echarts/lib/component/geo/GeoView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar GeoView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(GeoView, _super);\n  function GeoView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = GeoView.type;\n    _this.focusBlurEnabled = true;\n    return _this;\n  }\n  GeoView.prototype.init = function (ecModel, api) {\n    this._api = api;\n  };\n  GeoView.prototype.render = function (geoModel, ecModel, api, payload) {\n    this._model = geoModel;\n    if (!geoModel.get('show')) {\n      this._mapDraw && this._mapDraw.remove();\n      this._mapDraw = null;\n      return;\n    }\n    if (!this._mapDraw) {\n      this._mapDraw = new MapDraw/* default */.A(api);\n    }\n    var mapDraw = this._mapDraw;\n    mapDraw.draw(geoModel, ecModel, api, this, payload);\n    mapDraw.group.on('click', this._handleRegionClick, this);\n    mapDraw.group.silent = geoModel.get('silent');\n    this.group.add(mapDraw.group);\n    this.updateSelectStatus(geoModel, ecModel, api);\n  };\n  GeoView.prototype._handleRegionClick = function (e) {\n    var eventData;\n    (0,util_event/* findEventDispatcher */.R)(e.target, function (current) {\n      return (eventData = (0,innerStore/* getECData */.z)(current).eventData) != null;\n    }, true);\n    if (eventData) {\n      this._api.dispatchAction({\n        type: 'geoToggleSelect',\n        geoId: this._model.id,\n        name: eventData.name\n      });\n    }\n  };\n  GeoView.prototype.updateSelectStatus = function (model, ecModel, api) {\n    var _this = this;\n    this._mapDraw.group.traverse(function (node) {\n      var eventData = (0,innerStore/* getECData */.z)(node).eventData;\n      if (eventData) {\n        _this._model.isSelected(eventData.name) ? api.enterSelect(node) : api.leaveSelect(node);\n        // No need to traverse children.\n        return true;\n      }\n    });\n  };\n  GeoView.prototype.findHighDownDispatchers = function (name) {\n    return this._mapDraw && this._mapDraw.findHighDownDispatchers(name, this._model);\n  };\n  GeoView.prototype.dispose = function () {\n    this._mapDraw && this._mapDraw.remove();\n  };\n  GeoView.type = 'geo';\n  return GeoView;\n}(Component/* default */.A);\n/* harmony default export */ const geo_GeoView = (GeoView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/geo/geoSourceManager.js + 5 modules\nvar geoSourceManager = __webpack_require__(76311);\n;// ./node_modules/echarts/lib/component/geo/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\nfunction registerMap(mapName, geoJson, specialAreas) {\n  geoSourceManager/* default */.A.registerMap(mapName, geoJson, specialAreas);\n}\nfunction install(registers) {\n  registers.registerCoordinateSystem('geo', geoCreator/* default */.A);\n  registers.registerComponentModel(GeoModel/* default */.A);\n  registers.registerComponentView(geo_GeoView);\n  registers.registerImpl('registerMap', registerMap);\n  registers.registerImpl('getMap', function (mapName) {\n    return geoSourceManager/* default */.A.getMapForUser(mapName);\n  });\n  function makeAction(method, actionInfo) {\n    actionInfo.update = 'geo:updateSelectStatus';\n    registers.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      var allSelected = [];\n      ecModel.eachComponent({\n        mainType: 'geo',\n        query: payload\n      }, function (geoModel) {\n        geoModel[method](payload.name);\n        var geo = geoModel.coordinateSystem;\n        (0,util.each)(geo.regions, function (region) {\n          selected[region.name] = geoModel.isSelected(region.name) || false;\n        });\n        // Notice: there might be duplicated name in different regions.\n        var names = [];\n        (0,util.each)(selected, function (v, name) {\n          selected[name] && names.push(name);\n        });\n        allSelected.push({\n          geoIndex: geoModel.componentIndex,\n          // Use singular, the same naming convention as the event `selectchanged`.\n          name: names\n        });\n      });\n      return {\n        selected: selected,\n        allSelected: allSelected,\n        name: payload.name\n      };\n    });\n  }\n  makeAction('toggleSelected', {\n    type: 'geoToggleSelect',\n    event: 'geoselectchanged'\n  });\n  makeAction('select', {\n    type: 'geoSelect',\n    event: 'geoselected'\n  });\n  makeAction('unSelect', {\n    type: 'geoUnSelect',\n    event: 'geounselected'\n  });\n  /**\r\n   * @payload\r\n   * @property {string} [componentType=series]\r\n   * @property {number} [dx]\r\n   * @property {number} [dy]\r\n   * @property {number} [zoom]\r\n   * @property {number} [originX]\r\n   * @property {number} [originY]\r\n   */\n  registers.registerAction({\n    type: 'geoRoam',\n    event: 'geoRoam',\n    update: 'updateTransform'\n  }, function (payload, ecModel, api) {\n    var componentType = payload.componentType || 'series';\n    ecModel.eachComponent({\n      mainType: componentType,\n      query: payload\n    }, function (componentModel) {\n      var geo = componentModel.coordinateSystem;\n      if (geo.type !== 'geo') {\n        return;\n      }\n      var res = (0,roamHelper/* updateCenterAndZoom */.f)(geo, payload, componentModel.get('scaleLimit'), api);\n      componentModel.setCenter && componentModel.setCenter(res.center);\n      componentModel.setZoom && componentModel.setZoom(res.zoom);\n      // All map series with same `map` use the same geo coordinate system\n      // So the center and zoom must be in sync. Include the series not selected by legend\n      if (componentType === 'series') {\n        (0,util.each)(componentModel.seriesGroup, function (seriesModel) {\n          seriesModel.setCenter(res.center);\n          seriesModel.setZoom(res.zoom);\n        });\n      }\n    });\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZ2VvL0dlb1ZpZXcuanM/ZjhkYiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2dlby9pbnN0YWxsLmpzP2Y4YTkiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBNYXBEcmF3IGZyb20gJy4uL2hlbHBlci9NYXBEcmF3LmpzJztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50LmpzJztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZS5qcyc7XG5pbXBvcnQgeyBmaW5kRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi4vLi4vdXRpbC9ldmVudC5qcyc7XG52YXIgR2VvVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhHZW9WaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBHZW9WaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBHZW9WaWV3LnR5cGU7XG4gICAgX3RoaXMuZm9jdXNCbHVyRW5hYmxlZCA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEdlb1ZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5fYXBpID0gYXBpO1xuICB9O1xuICBHZW9WaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZ2VvTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMuX21vZGVsID0gZ2VvTW9kZWw7XG4gICAgaWYgKCFnZW9Nb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgdGhpcy5fbWFwRHJhdyAmJiB0aGlzLl9tYXBEcmF3LnJlbW92ZSgpO1xuICAgICAgdGhpcy5fbWFwRHJhdyA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5fbWFwRHJhdykge1xuICAgICAgdGhpcy5fbWFwRHJhdyA9IG5ldyBNYXBEcmF3KGFwaSk7XG4gICAgfVxuICAgIHZhciBtYXBEcmF3ID0gdGhpcy5fbWFwRHJhdztcbiAgICBtYXBEcmF3LmRyYXcoZ2VvTW9kZWwsIGVjTW9kZWwsIGFwaSwgdGhpcywgcGF5bG9hZCk7XG4gICAgbWFwRHJhdy5ncm91cC5vbignY2xpY2snLCB0aGlzLl9oYW5kbGVSZWdpb25DbGljaywgdGhpcyk7XG4gICAgbWFwRHJhdy5ncm91cC5zaWxlbnQgPSBnZW9Nb2RlbC5nZXQoJ3NpbGVudCcpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKG1hcERyYXcuZ3JvdXApO1xuICAgIHRoaXMudXBkYXRlU2VsZWN0U3RhdHVzKGdlb01vZGVsLCBlY01vZGVsLCBhcGkpO1xuICB9O1xuICBHZW9WaWV3LnByb3RvdHlwZS5faGFuZGxlUmVnaW9uQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBldmVudERhdGE7XG4gICAgZmluZEV2ZW50RGlzcGF0Y2hlcihlLnRhcmdldCwgZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgIHJldHVybiAoZXZlbnREYXRhID0gZ2V0RUNEYXRhKGN1cnJlbnQpLmV2ZW50RGF0YSkgIT0gbnVsbDtcbiAgICB9LCB0cnVlKTtcbiAgICBpZiAoZXZlbnREYXRhKSB7XG4gICAgICB0aGlzLl9hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICB0eXBlOiAnZ2VvVG9nZ2xlU2VsZWN0JyxcbiAgICAgICAgZ2VvSWQ6IHRoaXMuX21vZGVsLmlkLFxuICAgICAgICBuYW1lOiBldmVudERhdGEubmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBHZW9WaWV3LnByb3RvdHlwZS51cGRhdGVTZWxlY3RTdGF0dXMgPSBmdW5jdGlvbiAobW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fbWFwRHJhdy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGV2ZW50RGF0YSA9IGdldEVDRGF0YShub2RlKS5ldmVudERhdGE7XG4gICAgICBpZiAoZXZlbnREYXRhKSB7XG4gICAgICAgIF90aGlzLl9tb2RlbC5pc1NlbGVjdGVkKGV2ZW50RGF0YS5uYW1lKSA/IGFwaS5lbnRlclNlbGVjdChub2RlKSA6IGFwaS5sZWF2ZVNlbGVjdChub2RlKTtcbiAgICAgICAgLy8gTm8gbmVlZCB0byB0cmF2ZXJzZSBjaGlsZHJlbi5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIEdlb1ZpZXcucHJvdG90eXBlLmZpbmRIaWdoRG93bkRpc3BhdGNoZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwRHJhdyAmJiB0aGlzLl9tYXBEcmF3LmZpbmRIaWdoRG93bkRpc3BhdGNoZXJzKG5hbWUsIHRoaXMuX21vZGVsKTtcbiAgfTtcbiAgR2VvVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9tYXBEcmF3ICYmIHRoaXMuX21hcERyYXcucmVtb3ZlKCk7XG4gIH07XG4gIEdlb1ZpZXcudHlwZSA9ICdnZW8nO1xuICByZXR1cm4gR2VvVmlldztcbn0oQ29tcG9uZW50Vmlldyk7XG5leHBvcnQgZGVmYXVsdCBHZW9WaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IEdlb01vZGVsIGZyb20gJy4uLy4uL2Nvb3JkL2dlby9HZW9Nb2RlbC5qcyc7XG5pbXBvcnQgZ2VvQ3JlYXRvciBmcm9tICcuLi8uLi9jb29yZC9nZW8vZ2VvQ3JlYXRvci5qcyc7XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IHVwZGF0ZUNlbnRlckFuZFpvb20gfSBmcm9tICcuLi8uLi9hY3Rpb24vcm9hbUhlbHBlci5qcyc7XG5pbXBvcnQgR2VvVmlldyBmcm9tICcuL0dlb1ZpZXcuanMnO1xuaW1wb3J0IGdlb1NvdXJjZU1hbmFnZXIgZnJvbSAnLi4vLi4vY29vcmQvZ2VvL2dlb1NvdXJjZU1hbmFnZXIuanMnO1xuZnVuY3Rpb24gcmVnaXN0ZXJNYXAobWFwTmFtZSwgZ2VvSnNvbiwgc3BlY2lhbEFyZWFzKSB7XG4gIGdlb1NvdXJjZU1hbmFnZXIucmVnaXN0ZXJNYXAobWFwTmFtZSwgZ2VvSnNvbiwgc3BlY2lhbEFyZWFzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb29yZGluYXRlU3lzdGVtKCdnZW8nLCBnZW9DcmVhdG9yKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50TW9kZWwoR2VvTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KEdlb1ZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJJbXBsKCdyZWdpc3Rlck1hcCcsIHJlZ2lzdGVyTWFwKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVySW1wbCgnZ2V0TWFwJywgZnVuY3Rpb24gKG1hcE5hbWUpIHtcbiAgICByZXR1cm4gZ2VvU291cmNlTWFuYWdlci5nZXRNYXBGb3JVc2VyKG1hcE5hbWUpO1xuICB9KTtcbiAgZnVuY3Rpb24gbWFrZUFjdGlvbihtZXRob2QsIGFjdGlvbkluZm8pIHtcbiAgICBhY3Rpb25JbmZvLnVwZGF0ZSA9ICdnZW86dXBkYXRlU2VsZWN0U3RhdHVzJztcbiAgICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oYWN0aW9uSW5mbywgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHt9O1xuICAgICAgdmFyIGFsbFNlbGVjdGVkID0gW107XG4gICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgICBtYWluVHlwZTogJ2dlbycsXG4gICAgICAgIHF1ZXJ5OiBwYXlsb2FkXG4gICAgICB9LCBmdW5jdGlvbiAoZ2VvTW9kZWwpIHtcbiAgICAgICAgZ2VvTW9kZWxbbWV0aG9kXShwYXlsb2FkLm5hbWUpO1xuICAgICAgICB2YXIgZ2VvID0gZ2VvTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgZWFjaChnZW8ucmVnaW9ucywgZnVuY3Rpb24gKHJlZ2lvbikge1xuICAgICAgICAgIHNlbGVjdGVkW3JlZ2lvbi5uYW1lXSA9IGdlb01vZGVsLmlzU2VsZWN0ZWQocmVnaW9uLm5hbWUpIHx8IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTm90aWNlOiB0aGVyZSBtaWdodCBiZSBkdXBsaWNhdGVkIG5hbWUgaW4gZGlmZmVyZW50IHJlZ2lvbnMuXG4gICAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgICBlYWNoKHNlbGVjdGVkLCBmdW5jdGlvbiAodiwgbmFtZSkge1xuICAgICAgICAgIHNlbGVjdGVkW25hbWVdICYmIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhbGxTZWxlY3RlZC5wdXNoKHtcbiAgICAgICAgICBnZW9JbmRleDogZ2VvTW9kZWwuY29tcG9uZW50SW5kZXgsXG4gICAgICAgICAgLy8gVXNlIHNpbmd1bGFyLCB0aGUgc2FtZSBuYW1pbmcgY29udmVudGlvbiBhcyB0aGUgZXZlbnQgYHNlbGVjdGNoYW5nZWRgLlxuICAgICAgICAgIG5hbWU6IG5hbWVzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICAgIGFsbFNlbGVjdGVkOiBhbGxTZWxlY3RlZCxcbiAgICAgICAgbmFtZTogcGF5bG9hZC5uYW1lXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIG1ha2VBY3Rpb24oJ3RvZ2dsZVNlbGVjdGVkJywge1xuICAgIHR5cGU6ICdnZW9Ub2dnbGVTZWxlY3QnLFxuICAgIGV2ZW50OiAnZ2Vvc2VsZWN0Y2hhbmdlZCdcbiAgfSk7XG4gIG1ha2VBY3Rpb24oJ3NlbGVjdCcsIHtcbiAgICB0eXBlOiAnZ2VvU2VsZWN0JyxcbiAgICBldmVudDogJ2dlb3NlbGVjdGVkJ1xuICB9KTtcbiAgbWFrZUFjdGlvbigndW5TZWxlY3QnLCB7XG4gICAgdHlwZTogJ2dlb1VuU2VsZWN0JyxcbiAgICBldmVudDogJ2dlb3Vuc2VsZWN0ZWQnXG4gIH0pO1xuICAvKipcclxuICAgKiBAcGF5bG9hZFxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29tcG9uZW50VHlwZT1zZXJpZXNdXHJcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtkeF1cclxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2R5XVxyXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbV1cclxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW29yaWdpblhdXHJcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcmlnaW5ZXVxyXG4gICAqL1xuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgIHR5cGU6ICdnZW9Sb2FtJyxcbiAgICBldmVudDogJ2dlb1JvYW0nLFxuICAgIHVwZGF0ZTogJ3VwZGF0ZVRyYW5zZm9ybSdcbiAgfSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBjb21wb25lbnRUeXBlID0gcGF5bG9hZC5jb21wb25lbnRUeXBlIHx8ICdzZXJpZXMnO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICBtYWluVHlwZTogY29tcG9uZW50VHlwZSxcbiAgICAgIHF1ZXJ5OiBwYXlsb2FkXG4gICAgfSwgZnVuY3Rpb24gKGNvbXBvbmVudE1vZGVsKSB7XG4gICAgICB2YXIgZ2VvID0gY29tcG9uZW50TW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgIGlmIChnZW8udHlwZSAhPT0gJ2dlbycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJlcyA9IHVwZGF0ZUNlbnRlckFuZFpvb20oZ2VvLCBwYXlsb2FkLCBjb21wb25lbnRNb2RlbC5nZXQoJ3NjYWxlTGltaXQnKSwgYXBpKTtcbiAgICAgIGNvbXBvbmVudE1vZGVsLnNldENlbnRlciAmJiBjb21wb25lbnRNb2RlbC5zZXRDZW50ZXIocmVzLmNlbnRlcik7XG4gICAgICBjb21wb25lbnRNb2RlbC5zZXRab29tICYmIGNvbXBvbmVudE1vZGVsLnNldFpvb20ocmVzLnpvb20pO1xuICAgICAgLy8gQWxsIG1hcCBzZXJpZXMgd2l0aCBzYW1lIGBtYXBgIHVzZSB0aGUgc2FtZSBnZW8gY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgIC8vIFNvIHRoZSBjZW50ZXIgYW5kIHpvb20gbXVzdCBiZSBpbiBzeW5jLiBJbmNsdWRlIHRoZSBzZXJpZXMgbm90IHNlbGVjdGVkIGJ5IGxlZ2VuZFxuICAgICAgaWYgKGNvbXBvbmVudFR5cGUgPT09ICdzZXJpZXMnKSB7XG4gICAgICAgIGVhY2goY29tcG9uZW50TW9kZWwuc2VyaWVzR3JvdXAsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgIHNlcmllc01vZGVsLnNldENlbnRlcihyZXMuY2VudGVyKTtcbiAgICAgICAgICBzZXJpZXNNb2RlbC5zZXRab29tKHJlcy56b29tKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///363\n")},22379:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/calendar/CalendarModel.js\nvar CalendarModel = __webpack_require__(5196);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polyline.js\nvar Polyline = __webpack_require__(39195);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/format.js\nvar format = __webpack_require__(83412);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar Component = __webpack_require__(59109);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/core/locale.js\nvar locale = __webpack_require__(53080);\n;// ./node_modules/echarts/lib/component/calendar/CalendarView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nvar CalendarView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(CalendarView, _super);\n  function CalendarView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = CalendarView.type;\n    return _this;\n  }\n  CalendarView.prototype.render = function (calendarModel, ecModel, api) {\n    var group = this.group;\n    group.removeAll();\n    var coordSys = calendarModel.coordinateSystem;\n    // range info\n    var rangeData = coordSys.getRangeInfo();\n    var orient = coordSys.getOrient();\n    // locale\n    var localeModel = ecModel.getLocaleModel();\n    this._renderDayRect(calendarModel, rangeData, group);\n    // _renderLines must be called prior to following function\n    this._renderLines(calendarModel, rangeData, orient, group);\n    this._renderYearText(calendarModel, rangeData, orient, group);\n    this._renderMonthText(calendarModel, localeModel, orient, group);\n    this._renderWeekText(calendarModel, localeModel, rangeData, orient, group);\n  };\n  // render day rect\n  CalendarView.prototype._renderDayRect = function (calendarModel, rangeData, group) {\n    var coordSys = calendarModel.coordinateSystem;\n    var itemRectStyleModel = calendarModel.getModel('itemStyle').getItemStyle();\n    var sw = coordSys.getCellWidth();\n    var sh = coordSys.getCellHeight();\n    for (var i = rangeData.start.time; i <= rangeData.end.time; i = coordSys.getNextNDay(i, 1).time) {\n      var point = coordSys.dataToRect([i], false).tl;\n      // every rect\n      var rect = new Rect/* default */.A({\n        shape: {\n          x: point[0],\n          y: point[1],\n          width: sw,\n          height: sh\n        },\n        cursor: 'default',\n        style: itemRectStyleModel\n      });\n      group.add(rect);\n    }\n  };\n  // render separate line\n  CalendarView.prototype._renderLines = function (calendarModel, rangeData, orient, group) {\n    var self = this;\n    var coordSys = calendarModel.coordinateSystem;\n    var lineStyleModel = calendarModel.getModel(['splitLine', 'lineStyle']).getLineStyle();\n    var show = calendarModel.get(['splitLine', 'show']);\n    var lineWidth = lineStyleModel.lineWidth;\n    this._tlpoints = [];\n    this._blpoints = [];\n    this._firstDayOfMonth = [];\n    this._firstDayPoints = [];\n    var firstDay = rangeData.start;\n    for (var i = 0; firstDay.time <= rangeData.end.time; i++) {\n      addPoints(firstDay.formatedDate);\n      if (i === 0) {\n        firstDay = coordSys.getDateInfo(rangeData.start.y + '-' + rangeData.start.m);\n      }\n      var date = firstDay.date;\n      date.setMonth(date.getMonth() + 1);\n      firstDay = coordSys.getDateInfo(date);\n    }\n    addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);\n    function addPoints(date) {\n      self._firstDayOfMonth.push(coordSys.getDateInfo(date));\n      self._firstDayPoints.push(coordSys.dataToRect([date], false).tl);\n      var points = self._getLinePointsOfOneWeek(calendarModel, date, orient);\n      self._tlpoints.push(points[0]);\n      self._blpoints.push(points[points.length - 1]);\n      show && self._drawSplitline(points, lineStyleModel, group);\n    }\n    // render top/left line\n    show && this._drawSplitline(self._getEdgesPoints(self._tlpoints, lineWidth, orient), lineStyleModel, group);\n    // render bottom/right line\n    show && this._drawSplitline(self._getEdgesPoints(self._blpoints, lineWidth, orient), lineStyleModel, group);\n  };\n  // get points at both ends\n  CalendarView.prototype._getEdgesPoints = function (points, lineWidth, orient) {\n    var rs = [points[0].slice(), points[points.length - 1].slice()];\n    var idx = orient === 'horizontal' ? 0 : 1;\n    // both ends of the line are extend half lineWidth\n    rs[0][idx] = rs[0][idx] - lineWidth / 2;\n    rs[1][idx] = rs[1][idx] + lineWidth / 2;\n    return rs;\n  };\n  // render split line\n  CalendarView.prototype._drawSplitline = function (points, lineStyle, group) {\n    var poyline = new Polyline/* default */.A({\n      z2: 20,\n      shape: {\n        points: points\n      },\n      style: lineStyle\n    });\n    group.add(poyline);\n  };\n  // render month line of one week points\n  CalendarView.prototype._getLinePointsOfOneWeek = function (calendarModel, date, orient) {\n    var coordSys = calendarModel.coordinateSystem;\n    var parsedDate = coordSys.getDateInfo(date);\n    var points = [];\n    for (var i = 0; i < 7; i++) {\n      var tmpD = coordSys.getNextNDay(parsedDate.time, i);\n      var point = coordSys.dataToRect([tmpD.time], false);\n      points[2 * tmpD.day] = point.tl;\n      points[2 * tmpD.day + 1] = point[orient === 'horizontal' ? 'bl' : 'tr'];\n    }\n    return points;\n  };\n  CalendarView.prototype._formatterLabel = function (formatter, params) {\n    if ((0,util.isString)(formatter) && formatter) {\n      return (0,format/* formatTplSimple */.io)(formatter, params);\n    }\n    if ((0,util.isFunction)(formatter)) {\n      return formatter(params);\n    }\n    return params.nameMap;\n  };\n  CalendarView.prototype._yearTextPositionControl = function (textEl, point, orient, position, margin) {\n    var x = point[0];\n    var y = point[1];\n    var aligns = ['center', 'bottom'];\n    if (position === 'bottom') {\n      y += margin;\n      aligns = ['center', 'top'];\n    } else if (position === 'left') {\n      x -= margin;\n    } else if (position === 'right') {\n      x += margin;\n      aligns = ['center', 'top'];\n    } else {\n      // top\n      y -= margin;\n    }\n    var rotate = 0;\n    if (position === 'left' || position === 'right') {\n      rotate = Math.PI / 2;\n    }\n    return {\n      rotation: rotate,\n      x: x,\n      y: y,\n      style: {\n        align: aligns[0],\n        verticalAlign: aligns[1]\n      }\n    };\n  };\n  // render year\n  CalendarView.prototype._renderYearText = function (calendarModel, rangeData, orient, group) {\n    var yearLabel = calendarModel.getModel('yearLabel');\n    if (!yearLabel.get('show')) {\n      return;\n    }\n    var margin = yearLabel.get('margin');\n    var pos = yearLabel.get('position');\n    if (!pos) {\n      pos = orient !== 'horizontal' ? 'top' : 'left';\n    }\n    var points = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];\n    var xc = (points[0][0] + points[1][0]) / 2;\n    var yc = (points[0][1] + points[1][1]) / 2;\n    var idx = orient === 'horizontal' ? 0 : 1;\n    var posPoints = {\n      top: [xc, points[idx][1]],\n      bottom: [xc, points[1 - idx][1]],\n      left: [points[1 - idx][0], yc],\n      right: [points[idx][0], yc]\n    };\n    var name = rangeData.start.y;\n    if (+rangeData.end.y > +rangeData.start.y) {\n      name = name + '-' + rangeData.end.y;\n    }\n    var formatter = yearLabel.get('formatter');\n    var params = {\n      start: rangeData.start.y,\n      end: rangeData.end.y,\n      nameMap: name\n    };\n    var content = this._formatterLabel(formatter, params);\n    var yearText = new Text/* default */.Ay({\n      z2: 30,\n      style: (0,labelStyle/* createTextStyle */.VB)(yearLabel, {\n        text: content\n      }),\n      silent: yearLabel.get('silent')\n    });\n    yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));\n    group.add(yearText);\n  };\n  CalendarView.prototype._monthTextPositionControl = function (point, isCenter, orient, position, margin) {\n    var align = 'left';\n    var vAlign = 'top';\n    var x = point[0];\n    var y = point[1];\n    if (orient === 'horizontal') {\n      y = y + margin;\n      if (isCenter) {\n        align = 'center';\n      }\n      if (position === 'start') {\n        vAlign = 'bottom';\n      }\n    } else {\n      x = x + margin;\n      if (isCenter) {\n        vAlign = 'middle';\n      }\n      if (position === 'start') {\n        align = 'right';\n      }\n    }\n    return {\n      x: x,\n      y: y,\n      align: align,\n      verticalAlign: vAlign\n    };\n  };\n  // render month and year text\n  CalendarView.prototype._renderMonthText = function (calendarModel, localeModel, orient, group) {\n    var monthLabel = calendarModel.getModel('monthLabel');\n    if (!monthLabel.get('show')) {\n      return;\n    }\n    var nameMap = monthLabel.get('nameMap');\n    var margin = monthLabel.get('margin');\n    var pos = monthLabel.get('position');\n    var align = monthLabel.get('align');\n    var termPoints = [this._tlpoints, this._blpoints];\n    if (!nameMap || (0,util.isString)(nameMap)) {\n      if (nameMap) {\n        // case-sensitive\n        localeModel = (0,locale/* getLocaleModel */.A4)(nameMap) || localeModel;\n      }\n      // PENDING\n      // for ZH locale, original form is `一月` but current form is `1月`\n      nameMap = localeModel.get(['time', 'monthAbbr']) || [];\n    }\n    var idx = pos === 'start' ? 0 : 1;\n    var axis = orient === 'horizontal' ? 0 : 1;\n    margin = pos === 'start' ? -margin : margin;\n    var isCenter = align === 'center';\n    var labelSilent = monthLabel.get('silent');\n    for (var i = 0; i < termPoints[idx].length - 1; i++) {\n      var tmp = termPoints[idx][i].slice();\n      var firstDay = this._firstDayOfMonth[i];\n      if (isCenter) {\n        var firstDayPoints = this._firstDayPoints[i];\n        tmp[axis] = (firstDayPoints[axis] + termPoints[0][i + 1][axis]) / 2;\n      }\n      var formatter = monthLabel.get('formatter');\n      var name_1 = nameMap[+firstDay.m - 1];\n      var params = {\n        yyyy: firstDay.y,\n        yy: (firstDay.y + '').slice(2),\n        MM: firstDay.m,\n        M: +firstDay.m,\n        nameMap: name_1\n      };\n      var content = this._formatterLabel(formatter, params);\n      var monthText = new Text/* default */.Ay({\n        z2: 30,\n        style: (0,util.extend)((0,labelStyle/* createTextStyle */.VB)(monthLabel, {\n          text: content\n        }), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin)),\n        silent: labelSilent\n      });\n      group.add(monthText);\n    }\n  };\n  CalendarView.prototype._weekTextPositionControl = function (point, orient, position, margin, cellSize) {\n    var align = 'center';\n    var vAlign = 'middle';\n    var x = point[0];\n    var y = point[1];\n    var isStart = position === 'start';\n    if (orient === 'horizontal') {\n      x = x + margin + (isStart ? 1 : -1) * cellSize[0] / 2;\n      align = isStart ? 'right' : 'left';\n    } else {\n      y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2;\n      vAlign = isStart ? 'bottom' : 'top';\n    }\n    return {\n      x: x,\n      y: y,\n      align: align,\n      verticalAlign: vAlign\n    };\n  };\n  // render weeks\n  CalendarView.prototype._renderWeekText = function (calendarModel, localeModel, rangeData, orient, group) {\n    var dayLabel = calendarModel.getModel('dayLabel');\n    if (!dayLabel.get('show')) {\n      return;\n    }\n    var coordSys = calendarModel.coordinateSystem;\n    var pos = dayLabel.get('position');\n    var nameMap = dayLabel.get('nameMap');\n    var margin = dayLabel.get('margin');\n    var firstDayOfWeek = coordSys.getFirstDayOfWeek();\n    if (!nameMap || (0,util.isString)(nameMap)) {\n      if (nameMap) {\n        // case-sensitive\n        localeModel = (0,locale/* getLocaleModel */.A4)(nameMap) || localeModel;\n      }\n      // Use the first letter of `dayOfWeekAbbr` if `dayOfWeekShort` doesn't exist in the locale file\n      var dayOfWeekShort = localeModel.get(['time', 'dayOfWeekShort']);\n      nameMap = dayOfWeekShort || (0,util.map)(localeModel.get(['time', 'dayOfWeekAbbr']), function (val) {\n        return val[0];\n      });\n    }\n    var start = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;\n    var cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];\n    margin = (0,number/* parsePercent */.lo)(margin, Math.min(cellSize[1], cellSize[0]));\n    if (pos === 'start') {\n      start = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;\n      margin = -margin;\n    }\n    var labelSilent = dayLabel.get('silent');\n    for (var i = 0; i < 7; i++) {\n      var tmpD = coordSys.getNextNDay(start, i);\n      var point = coordSys.dataToRect([tmpD.time], false).center;\n      var day = i;\n      day = Math.abs((i + firstDayOfWeek) % 7);\n      var weekText = new Text/* default */.Ay({\n        z2: 30,\n        style: (0,util.extend)((0,labelStyle/* createTextStyle */.VB)(dayLabel, {\n          text: nameMap[day]\n        }), this._weekTextPositionControl(point, orient, pos, margin, cellSize)),\n        silent: labelSilent\n      });\n      group.add(weekText);\n    }\n  };\n  CalendarView.type = 'calendar';\n  return CalendarView;\n}(Component/* default */.A);\n/* harmony default export */ const calendar_CalendarView = (CalendarView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/calendar/Calendar.js\nvar Calendar = __webpack_require__(23509);\n;// ./node_modules/echarts/lib/component/calendar/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction install(registers) {\n  registers.registerComponentModel(CalendarModel/* default */.A);\n  registers.registerComponentView(calendar_CalendarView);\n  registers.registerCoordinateSystem('calendar', Calendar/* default */.A);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIzNzkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvY2FsZW5kYXIvQ2FsZW5kYXJWaWV3LmpzPzBjYzciLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9jYWxlbmRhci9pbnN0YWxsLmpzPzdiZDciXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGlzU3RyaW5nLCBleHRlbmQsIG1hcCwgaXNGdW5jdGlvbiB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVUZXh0U3R5bGUgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlLmpzJztcbmltcG9ydCB7IGZvcm1hdFRwbFNpbXBsZSB9IGZyb20gJy4uLy4uL3V0aWwvZm9ybWF0LmpzJztcbmltcG9ydCB7IHBhcnNlUGVyY2VudCB9IGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyLmpzJztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50LmpzJztcbmltcG9ydCB7IGdldExvY2FsZU1vZGVsIH0gZnJvbSAnLi4vLi4vY29yZS9sb2NhbGUuanMnO1xudmFyIENhbGVuZGFyVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDYWxlbmRhclZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIENhbGVuZGFyVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gQ2FsZW5kYXJWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIENhbGVuZGFyVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNhbGVuZGFyTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdmFyIGNvb3JkU3lzID0gY2FsZW5kYXJNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIC8vIHJhbmdlIGluZm9cbiAgICB2YXIgcmFuZ2VEYXRhID0gY29vcmRTeXMuZ2V0UmFuZ2VJbmZvKCk7XG4gICAgdmFyIG9yaWVudCA9IGNvb3JkU3lzLmdldE9yaWVudCgpO1xuICAgIC8vIGxvY2FsZVxuICAgIHZhciBsb2NhbGVNb2RlbCA9IGVjTW9kZWwuZ2V0TG9jYWxlTW9kZWwoKTtcbiAgICB0aGlzLl9yZW5kZXJEYXlSZWN0KGNhbGVuZGFyTW9kZWwsIHJhbmdlRGF0YSwgZ3JvdXApO1xuICAgIC8vIF9yZW5kZXJMaW5lcyBtdXN0IGJlIGNhbGxlZCBwcmlvciB0byBmb2xsb3dpbmcgZnVuY3Rpb25cbiAgICB0aGlzLl9yZW5kZXJMaW5lcyhjYWxlbmRhck1vZGVsLCByYW5nZURhdGEsIG9yaWVudCwgZ3JvdXApO1xuICAgIHRoaXMuX3JlbmRlclllYXJUZXh0KGNhbGVuZGFyTW9kZWwsIHJhbmdlRGF0YSwgb3JpZW50LCBncm91cCk7XG4gICAgdGhpcy5fcmVuZGVyTW9udGhUZXh0KGNhbGVuZGFyTW9kZWwsIGxvY2FsZU1vZGVsLCBvcmllbnQsIGdyb3VwKTtcbiAgICB0aGlzLl9yZW5kZXJXZWVrVGV4dChjYWxlbmRhck1vZGVsLCBsb2NhbGVNb2RlbCwgcmFuZ2VEYXRhLCBvcmllbnQsIGdyb3VwKTtcbiAgfTtcbiAgLy8gcmVuZGVyIGRheSByZWN0XG4gIENhbGVuZGFyVmlldy5wcm90b3R5cGUuX3JlbmRlckRheVJlY3QgPSBmdW5jdGlvbiAoY2FsZW5kYXJNb2RlbCwgcmFuZ2VEYXRhLCBncm91cCkge1xuICAgIHZhciBjb29yZFN5cyA9IGNhbGVuZGFyTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgaXRlbVJlY3RTdHlsZU1vZGVsID0gY2FsZW5kYXJNb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJykuZ2V0SXRlbVN0eWxlKCk7XG4gICAgdmFyIHN3ID0gY29vcmRTeXMuZ2V0Q2VsbFdpZHRoKCk7XG4gICAgdmFyIHNoID0gY29vcmRTeXMuZ2V0Q2VsbEhlaWdodCgpO1xuICAgIGZvciAodmFyIGkgPSByYW5nZURhdGEuc3RhcnQudGltZTsgaSA8PSByYW5nZURhdGEuZW5kLnRpbWU7IGkgPSBjb29yZFN5cy5nZXROZXh0TkRheShpLCAxKS50aW1lKSB7XG4gICAgICB2YXIgcG9pbnQgPSBjb29yZFN5cy5kYXRhVG9SZWN0KFtpXSwgZmFsc2UpLnRsO1xuICAgICAgLy8gZXZlcnkgcmVjdFxuICAgICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICB4OiBwb2ludFswXSxcbiAgICAgICAgICB5OiBwb2ludFsxXSxcbiAgICAgICAgICB3aWR0aDogc3csXG4gICAgICAgICAgaGVpZ2h0OiBzaFxuICAgICAgICB9LFxuICAgICAgICBjdXJzb3I6ICdkZWZhdWx0JyxcbiAgICAgICAgc3R5bGU6IGl0ZW1SZWN0U3R5bGVNb2RlbFxuICAgICAgfSk7XG4gICAgICBncm91cC5hZGQocmVjdCk7XG4gICAgfVxuICB9O1xuICAvLyByZW5kZXIgc2VwYXJhdGUgbGluZVxuICBDYWxlbmRhclZpZXcucHJvdG90eXBlLl9yZW5kZXJMaW5lcyA9IGZ1bmN0aW9uIChjYWxlbmRhck1vZGVsLCByYW5nZURhdGEsIG9yaWVudCwgZ3JvdXApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvb3JkU3lzID0gY2FsZW5kYXJNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBsaW5lU3R5bGVNb2RlbCA9IGNhbGVuZGFyTW9kZWwuZ2V0TW9kZWwoWydzcGxpdExpbmUnLCAnbGluZVN0eWxlJ10pLmdldExpbmVTdHlsZSgpO1xuICAgIHZhciBzaG93ID0gY2FsZW5kYXJNb2RlbC5nZXQoWydzcGxpdExpbmUnLCAnc2hvdyddKTtcbiAgICB2YXIgbGluZVdpZHRoID0gbGluZVN0eWxlTW9kZWwubGluZVdpZHRoO1xuICAgIHRoaXMuX3RscG9pbnRzID0gW107XG4gICAgdGhpcy5fYmxwb2ludHMgPSBbXTtcbiAgICB0aGlzLl9maXJzdERheU9mTW9udGggPSBbXTtcbiAgICB0aGlzLl9maXJzdERheVBvaW50cyA9IFtdO1xuICAgIHZhciBmaXJzdERheSA9IHJhbmdlRGF0YS5zdGFydDtcbiAgICBmb3IgKHZhciBpID0gMDsgZmlyc3REYXkudGltZSA8PSByYW5nZURhdGEuZW5kLnRpbWU7IGkrKykge1xuICAgICAgYWRkUG9pbnRzKGZpcnN0RGF5LmZvcm1hdGVkRGF0ZSk7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBmaXJzdERheSA9IGNvb3JkU3lzLmdldERhdGVJbmZvKHJhbmdlRGF0YS5zdGFydC55ICsgJy0nICsgcmFuZ2VEYXRhLnN0YXJ0Lm0pO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGUgPSBmaXJzdERheS5kYXRlO1xuICAgICAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyAxKTtcbiAgICAgIGZpcnN0RGF5ID0gY29vcmRTeXMuZ2V0RGF0ZUluZm8oZGF0ZSk7XG4gICAgfVxuICAgIGFkZFBvaW50cyhjb29yZFN5cy5nZXROZXh0TkRheShyYW5nZURhdGEuZW5kLnRpbWUsIDEpLmZvcm1hdGVkRGF0ZSk7XG4gICAgZnVuY3Rpb24gYWRkUG9pbnRzKGRhdGUpIHtcbiAgICAgIHNlbGYuX2ZpcnN0RGF5T2ZNb250aC5wdXNoKGNvb3JkU3lzLmdldERhdGVJbmZvKGRhdGUpKTtcbiAgICAgIHNlbGYuX2ZpcnN0RGF5UG9pbnRzLnB1c2goY29vcmRTeXMuZGF0YVRvUmVjdChbZGF0ZV0sIGZhbHNlKS50bCk7XG4gICAgICB2YXIgcG9pbnRzID0gc2VsZi5fZ2V0TGluZVBvaW50c09mT25lV2VlayhjYWxlbmRhck1vZGVsLCBkYXRlLCBvcmllbnQpO1xuICAgICAgc2VsZi5fdGxwb2ludHMucHVzaChwb2ludHNbMF0pO1xuICAgICAgc2VsZi5fYmxwb2ludHMucHVzaChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgIHNob3cgJiYgc2VsZi5fZHJhd1NwbGl0bGluZShwb2ludHMsIGxpbmVTdHlsZU1vZGVsLCBncm91cCk7XG4gICAgfVxuICAgIC8vIHJlbmRlciB0b3AvbGVmdCBsaW5lXG4gICAgc2hvdyAmJiB0aGlzLl9kcmF3U3BsaXRsaW5lKHNlbGYuX2dldEVkZ2VzUG9pbnRzKHNlbGYuX3RscG9pbnRzLCBsaW5lV2lkdGgsIG9yaWVudCksIGxpbmVTdHlsZU1vZGVsLCBncm91cCk7XG4gICAgLy8gcmVuZGVyIGJvdHRvbS9yaWdodCBsaW5lXG4gICAgc2hvdyAmJiB0aGlzLl9kcmF3U3BsaXRsaW5lKHNlbGYuX2dldEVkZ2VzUG9pbnRzKHNlbGYuX2JscG9pbnRzLCBsaW5lV2lkdGgsIG9yaWVudCksIGxpbmVTdHlsZU1vZGVsLCBncm91cCk7XG4gIH07XG4gIC8vIGdldCBwb2ludHMgYXQgYm90aCBlbmRzXG4gIENhbGVuZGFyVmlldy5wcm90b3R5cGUuX2dldEVkZ2VzUG9pbnRzID0gZnVuY3Rpb24gKHBvaW50cywgbGluZVdpZHRoLCBvcmllbnQpIHtcbiAgICB2YXIgcnMgPSBbcG9pbnRzWzBdLnNsaWNlKCksIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0uc2xpY2UoKV07XG4gICAgdmFyIGlkeCA9IG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gMCA6IDE7XG4gICAgLy8gYm90aCBlbmRzIG9mIHRoZSBsaW5lIGFyZSBleHRlbmQgaGFsZiBsaW5lV2lkdGhcbiAgICByc1swXVtpZHhdID0gcnNbMF1baWR4XSAtIGxpbmVXaWR0aCAvIDI7XG4gICAgcnNbMV1baWR4XSA9IHJzWzFdW2lkeF0gKyBsaW5lV2lkdGggLyAyO1xuICAgIHJldHVybiBycztcbiAgfTtcbiAgLy8gcmVuZGVyIHNwbGl0IGxpbmVcbiAgQ2FsZW5kYXJWaWV3LnByb3RvdHlwZS5fZHJhd1NwbGl0bGluZSA9IGZ1bmN0aW9uIChwb2ludHMsIGxpbmVTdHlsZSwgZ3JvdXApIHtcbiAgICB2YXIgcG95bGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHtcbiAgICAgIHoyOiAyMCxcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICB9LFxuICAgICAgc3R5bGU6IGxpbmVTdHlsZVxuICAgIH0pO1xuICAgIGdyb3VwLmFkZChwb3lsaW5lKTtcbiAgfTtcbiAgLy8gcmVuZGVyIG1vbnRoIGxpbmUgb2Ygb25lIHdlZWsgcG9pbnRzXG4gIENhbGVuZGFyVmlldy5wcm90b3R5cGUuX2dldExpbmVQb2ludHNPZk9uZVdlZWsgPSBmdW5jdGlvbiAoY2FsZW5kYXJNb2RlbCwgZGF0ZSwgb3JpZW50KSB7XG4gICAgdmFyIGNvb3JkU3lzID0gY2FsZW5kYXJNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBwYXJzZWREYXRlID0gY29vcmRTeXMuZ2V0RGF0ZUluZm8oZGF0ZSk7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICB2YXIgdG1wRCA9IGNvb3JkU3lzLmdldE5leHRORGF5KHBhcnNlZERhdGUudGltZSwgaSk7XG4gICAgICB2YXIgcG9pbnQgPSBjb29yZFN5cy5kYXRhVG9SZWN0KFt0bXBELnRpbWVdLCBmYWxzZSk7XG4gICAgICBwb2ludHNbMiAqIHRtcEQuZGF5XSA9IHBvaW50LnRsO1xuICAgICAgcG9pbnRzWzIgKiB0bXBELmRheSArIDFdID0gcG9pbnRbb3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyAnYmwnIDogJ3RyJ107XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH07XG4gIENhbGVuZGFyVmlldy5wcm90b3R5cGUuX2Zvcm1hdHRlckxhYmVsID0gZnVuY3Rpb24gKGZvcm1hdHRlciwgcGFyYW1zKSB7XG4gICAgaWYgKGlzU3RyaW5nKGZvcm1hdHRlcikgJiYgZm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gZm9ybWF0VHBsU2ltcGxlKGZvcm1hdHRlciwgcGFyYW1zKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24oZm9ybWF0dGVyKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcihwYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zLm5hbWVNYXA7XG4gIH07XG4gIENhbGVuZGFyVmlldy5wcm90b3R5cGUuX3llYXJUZXh0UG9zaXRpb25Db250cm9sID0gZnVuY3Rpb24gKHRleHRFbCwgcG9pbnQsIG9yaWVudCwgcG9zaXRpb24sIG1hcmdpbikge1xuICAgIHZhciB4ID0gcG9pbnRbMF07XG4gICAgdmFyIHkgPSBwb2ludFsxXTtcbiAgICB2YXIgYWxpZ25zID0gWydjZW50ZXInLCAnYm90dG9tJ107XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgeSArPSBtYXJnaW47XG4gICAgICBhbGlnbnMgPSBbJ2NlbnRlcicsICd0b3AnXTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIHggLT0gbWFyZ2luO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHggKz0gbWFyZ2luO1xuICAgICAgYWxpZ25zID0gWydjZW50ZXInLCAndG9wJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRvcFxuICAgICAgeSAtPSBtYXJnaW47XG4gICAgfVxuICAgIHZhciByb3RhdGUgPSAwO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICByb3RhdGUgPSBNYXRoLlBJIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiByb3RhdGUsXG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGFsaWduOiBhbGlnbnNbMF0sXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IGFsaWduc1sxXVxuICAgICAgfVxuICAgIH07XG4gIH07XG4gIC8vIHJlbmRlciB5ZWFyXG4gIENhbGVuZGFyVmlldy5wcm90b3R5cGUuX3JlbmRlclllYXJUZXh0ID0gZnVuY3Rpb24gKGNhbGVuZGFyTW9kZWwsIHJhbmdlRGF0YSwgb3JpZW50LCBncm91cCkge1xuICAgIHZhciB5ZWFyTGFiZWwgPSBjYWxlbmRhck1vZGVsLmdldE1vZGVsKCd5ZWFyTGFiZWwnKTtcbiAgICBpZiAoIXllYXJMYWJlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbWFyZ2luID0geWVhckxhYmVsLmdldCgnbWFyZ2luJyk7XG4gICAgdmFyIHBvcyA9IHllYXJMYWJlbC5nZXQoJ3Bvc2l0aW9uJyk7XG4gICAgaWYgKCFwb3MpIHtcbiAgICAgIHBvcyA9IG9yaWVudCAhPT0gJ2hvcml6b250YWwnID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgfVxuICAgIHZhciBwb2ludHMgPSBbdGhpcy5fdGxwb2ludHNbdGhpcy5fdGxwb2ludHMubGVuZ3RoIC0gMV0sIHRoaXMuX2JscG9pbnRzWzBdXTtcbiAgICB2YXIgeGMgPSAocG9pbnRzWzBdWzBdICsgcG9pbnRzWzFdWzBdKSAvIDI7XG4gICAgdmFyIHljID0gKHBvaW50c1swXVsxXSArIHBvaW50c1sxXVsxXSkgLyAyO1xuICAgIHZhciBpZHggPSBvcmllbnQgPT09ICdob3Jpem9udGFsJyA/IDAgOiAxO1xuICAgIHZhciBwb3NQb2ludHMgPSB7XG4gICAgICB0b3A6IFt4YywgcG9pbnRzW2lkeF1bMV1dLFxuICAgICAgYm90dG9tOiBbeGMsIHBvaW50c1sxIC0gaWR4XVsxXV0sXG4gICAgICBsZWZ0OiBbcG9pbnRzWzEgLSBpZHhdWzBdLCB5Y10sXG4gICAgICByaWdodDogW3BvaW50c1tpZHhdWzBdLCB5Y11cbiAgICB9O1xuICAgIHZhciBuYW1lID0gcmFuZ2VEYXRhLnN0YXJ0Lnk7XG4gICAgaWYgKCtyYW5nZURhdGEuZW5kLnkgPiArcmFuZ2VEYXRhLnN0YXJ0LnkpIHtcbiAgICAgIG5hbWUgPSBuYW1lICsgJy0nICsgcmFuZ2VEYXRhLmVuZC55O1xuICAgIH1cbiAgICB2YXIgZm9ybWF0dGVyID0geWVhckxhYmVsLmdldCgnZm9ybWF0dGVyJyk7XG4gICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgIHN0YXJ0OiByYW5nZURhdGEuc3RhcnQueSxcbiAgICAgIGVuZDogcmFuZ2VEYXRhLmVuZC55LFxuICAgICAgbmFtZU1hcDogbmFtZVxuICAgIH07XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9mb3JtYXR0ZXJMYWJlbChmb3JtYXR0ZXIsIHBhcmFtcyk7XG4gICAgdmFyIHllYXJUZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICB6MjogMzAsXG4gICAgICBzdHlsZTogY3JlYXRlVGV4dFN0eWxlKHllYXJMYWJlbCwge1xuICAgICAgICB0ZXh0OiBjb250ZW50XG4gICAgICB9KSxcbiAgICAgIHNpbGVudDogeWVhckxhYmVsLmdldCgnc2lsZW50JylcbiAgICB9KTtcbiAgICB5ZWFyVGV4dC5hdHRyKHRoaXMuX3llYXJUZXh0UG9zaXRpb25Db250cm9sKHllYXJUZXh0LCBwb3NQb2ludHNbcG9zXSwgb3JpZW50LCBwb3MsIG1hcmdpbikpO1xuICAgIGdyb3VwLmFkZCh5ZWFyVGV4dCk7XG4gIH07XG4gIENhbGVuZGFyVmlldy5wcm90b3R5cGUuX21vbnRoVGV4dFBvc2l0aW9uQ29udHJvbCA9IGZ1bmN0aW9uIChwb2ludCwgaXNDZW50ZXIsIG9yaWVudCwgcG9zaXRpb24sIG1hcmdpbikge1xuICAgIHZhciBhbGlnbiA9ICdsZWZ0JztcbiAgICB2YXIgdkFsaWduID0gJ3RvcCc7XG4gICAgdmFyIHggPSBwb2ludFswXTtcbiAgICB2YXIgeSA9IHBvaW50WzFdO1xuICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgeSA9IHkgKyBtYXJnaW47XG4gICAgICBpZiAoaXNDZW50ZXIpIHtcbiAgICAgICAgYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB2QWxpZ24gPSAnYm90dG9tJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHggKyBtYXJnaW47XG4gICAgICBpZiAoaXNDZW50ZXIpIHtcbiAgICAgICAgdkFsaWduID0gJ21pZGRsZSc7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICBhbGlnbjogYWxpZ24sXG4gICAgICB2ZXJ0aWNhbEFsaWduOiB2QWxpZ25cbiAgICB9O1xuICB9O1xuICAvLyByZW5kZXIgbW9udGggYW5kIHllYXIgdGV4dFxuICBDYWxlbmRhclZpZXcucHJvdG90eXBlLl9yZW5kZXJNb250aFRleHQgPSBmdW5jdGlvbiAoY2FsZW5kYXJNb2RlbCwgbG9jYWxlTW9kZWwsIG9yaWVudCwgZ3JvdXApIHtcbiAgICB2YXIgbW9udGhMYWJlbCA9IGNhbGVuZGFyTW9kZWwuZ2V0TW9kZWwoJ21vbnRoTGFiZWwnKTtcbiAgICBpZiAoIW1vbnRoTGFiZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hbWVNYXAgPSBtb250aExhYmVsLmdldCgnbmFtZU1hcCcpO1xuICAgIHZhciBtYXJnaW4gPSBtb250aExhYmVsLmdldCgnbWFyZ2luJyk7XG4gICAgdmFyIHBvcyA9IG1vbnRoTGFiZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgIHZhciBhbGlnbiA9IG1vbnRoTGFiZWwuZ2V0KCdhbGlnbicpO1xuICAgIHZhciB0ZXJtUG9pbnRzID0gW3RoaXMuX3RscG9pbnRzLCB0aGlzLl9ibHBvaW50c107XG4gICAgaWYgKCFuYW1lTWFwIHx8IGlzU3RyaW5nKG5hbWVNYXApKSB7XG4gICAgICBpZiAobmFtZU1hcCkge1xuICAgICAgICAvLyBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICBsb2NhbGVNb2RlbCA9IGdldExvY2FsZU1vZGVsKG5hbWVNYXApIHx8IGxvY2FsZU1vZGVsO1xuICAgICAgfVxuICAgICAgLy8gUEVORElOR1xuICAgICAgLy8gZm9yIFpIIGxvY2FsZSwgb3JpZ2luYWwgZm9ybSBpcyBg5LiA5pyIYCBidXQgY3VycmVudCBmb3JtIGlzIGAx5pyIYFxuICAgICAgbmFtZU1hcCA9IGxvY2FsZU1vZGVsLmdldChbJ3RpbWUnLCAnbW9udGhBYmJyJ10pIHx8IFtdO1xuICAgIH1cbiAgICB2YXIgaWR4ID0gcG9zID09PSAnc3RhcnQnID8gMCA6IDE7XG4gICAgdmFyIGF4aXMgPSBvcmllbnQgPT09ICdob3Jpem9udGFsJyA/IDAgOiAxO1xuICAgIG1hcmdpbiA9IHBvcyA9PT0gJ3N0YXJ0JyA/IC1tYXJnaW4gOiBtYXJnaW47XG4gICAgdmFyIGlzQ2VudGVyID0gYWxpZ24gPT09ICdjZW50ZXInO1xuICAgIHZhciBsYWJlbFNpbGVudCA9IG1vbnRoTGFiZWwuZ2V0KCdzaWxlbnQnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlcm1Qb2ludHNbaWR4XS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciB0bXAgPSB0ZXJtUG9pbnRzW2lkeF1baV0uc2xpY2UoKTtcbiAgICAgIHZhciBmaXJzdERheSA9IHRoaXMuX2ZpcnN0RGF5T2ZNb250aFtpXTtcbiAgICAgIGlmIChpc0NlbnRlcikge1xuICAgICAgICB2YXIgZmlyc3REYXlQb2ludHMgPSB0aGlzLl9maXJzdERheVBvaW50c1tpXTtcbiAgICAgICAgdG1wW2F4aXNdID0gKGZpcnN0RGF5UG9pbnRzW2F4aXNdICsgdGVybVBvaW50c1swXVtpICsgMV1bYXhpc10pIC8gMjtcbiAgICAgIH1cbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBtb250aExhYmVsLmdldCgnZm9ybWF0dGVyJyk7XG4gICAgICB2YXIgbmFtZV8xID0gbmFtZU1hcFsrZmlyc3REYXkubSAtIDFdO1xuICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgeXl5eTogZmlyc3REYXkueSxcbiAgICAgICAgeXk6IChmaXJzdERheS55ICsgJycpLnNsaWNlKDIpLFxuICAgICAgICBNTTogZmlyc3REYXkubSxcbiAgICAgICAgTTogK2ZpcnN0RGF5Lm0sXG4gICAgICAgIG5hbWVNYXA6IG5hbWVfMVxuICAgICAgfTtcbiAgICAgIHZhciBjb250ZW50ID0gdGhpcy5fZm9ybWF0dGVyTGFiZWwoZm9ybWF0dGVyLCBwYXJhbXMpO1xuICAgICAgdmFyIG1vbnRoVGV4dCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgICB6MjogMzAsXG4gICAgICAgIHN0eWxlOiBleHRlbmQoY3JlYXRlVGV4dFN0eWxlKG1vbnRoTGFiZWwsIHtcbiAgICAgICAgICB0ZXh0OiBjb250ZW50XG4gICAgICAgIH0pLCB0aGlzLl9tb250aFRleHRQb3NpdGlvbkNvbnRyb2wodG1wLCBpc0NlbnRlciwgb3JpZW50LCBwb3MsIG1hcmdpbikpLFxuICAgICAgICBzaWxlbnQ6IGxhYmVsU2lsZW50XG4gICAgICB9KTtcbiAgICAgIGdyb3VwLmFkZChtb250aFRleHQpO1xuICAgIH1cbiAgfTtcbiAgQ2FsZW5kYXJWaWV3LnByb3RvdHlwZS5fd2Vla1RleHRQb3NpdGlvbkNvbnRyb2wgPSBmdW5jdGlvbiAocG9pbnQsIG9yaWVudCwgcG9zaXRpb24sIG1hcmdpbiwgY2VsbFNpemUpIHtcbiAgICB2YXIgYWxpZ24gPSAnY2VudGVyJztcbiAgICB2YXIgdkFsaWduID0gJ21pZGRsZSc7XG4gICAgdmFyIHggPSBwb2ludFswXTtcbiAgICB2YXIgeSA9IHBvaW50WzFdO1xuICAgIHZhciBpc1N0YXJ0ID0gcG9zaXRpb24gPT09ICdzdGFydCc7XG4gICAgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICB4ID0geCArIG1hcmdpbiArIChpc1N0YXJ0ID8gMSA6IC0xKSAqIGNlbGxTaXplWzBdIC8gMjtcbiAgICAgIGFsaWduID0gaXNTdGFydCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSB5ICsgbWFyZ2luICsgKGlzU3RhcnQgPyAxIDogLTEpICogY2VsbFNpemVbMV0gLyAyO1xuICAgICAgdkFsaWduID0gaXNTdGFydCA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgIHZlcnRpY2FsQWxpZ246IHZBbGlnblxuICAgIH07XG4gIH07XG4gIC8vIHJlbmRlciB3ZWVrc1xuICBDYWxlbmRhclZpZXcucHJvdG90eXBlLl9yZW5kZXJXZWVrVGV4dCA9IGZ1bmN0aW9uIChjYWxlbmRhck1vZGVsLCBsb2NhbGVNb2RlbCwgcmFuZ2VEYXRhLCBvcmllbnQsIGdyb3VwKSB7XG4gICAgdmFyIGRheUxhYmVsID0gY2FsZW5kYXJNb2RlbC5nZXRNb2RlbCgnZGF5TGFiZWwnKTtcbiAgICBpZiAoIWRheUxhYmVsLmdldCgnc2hvdycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb29yZFN5cyA9IGNhbGVuZGFyTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgcG9zID0gZGF5TGFiZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgIHZhciBuYW1lTWFwID0gZGF5TGFiZWwuZ2V0KCduYW1lTWFwJyk7XG4gICAgdmFyIG1hcmdpbiA9IGRheUxhYmVsLmdldCgnbWFyZ2luJyk7XG4gICAgdmFyIGZpcnN0RGF5T2ZXZWVrID0gY29vcmRTeXMuZ2V0Rmlyc3REYXlPZldlZWsoKTtcbiAgICBpZiAoIW5hbWVNYXAgfHwgaXNTdHJpbmcobmFtZU1hcCkpIHtcbiAgICAgIGlmIChuYW1lTWFwKSB7XG4gICAgICAgIC8vIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgIGxvY2FsZU1vZGVsID0gZ2V0TG9jYWxlTW9kZWwobmFtZU1hcCkgfHwgbG9jYWxlTW9kZWw7XG4gICAgICB9XG4gICAgICAvLyBVc2UgdGhlIGZpcnN0IGxldHRlciBvZiBgZGF5T2ZXZWVrQWJicmAgaWYgYGRheU9mV2Vla1Nob3J0YCBkb2Vzbid0IGV4aXN0IGluIHRoZSBsb2NhbGUgZmlsZVxuICAgICAgdmFyIGRheU9mV2Vla1Nob3J0ID0gbG9jYWxlTW9kZWwuZ2V0KFsndGltZScsICdkYXlPZldlZWtTaG9ydCddKTtcbiAgICAgIG5hbWVNYXAgPSBkYXlPZldlZWtTaG9ydCB8fCBtYXAobG9jYWxlTW9kZWwuZ2V0KFsndGltZScsICdkYXlPZldlZWtBYmJyJ10pLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWxbMF07XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0ID0gY29vcmRTeXMuZ2V0TmV4dE5EYXkocmFuZ2VEYXRhLmVuZC50aW1lLCA3IC0gcmFuZ2VEYXRhLmx3ZWVrKS50aW1lO1xuICAgIHZhciBjZWxsU2l6ZSA9IFtjb29yZFN5cy5nZXRDZWxsV2lkdGgoKSwgY29vcmRTeXMuZ2V0Q2VsbEhlaWdodCgpXTtcbiAgICBtYXJnaW4gPSBwYXJzZVBlcmNlbnQobWFyZ2luLCBNYXRoLm1pbihjZWxsU2l6ZVsxXSwgY2VsbFNpemVbMF0pKTtcbiAgICBpZiAocG9zID09PSAnc3RhcnQnKSB7XG4gICAgICBzdGFydCA9IGNvb3JkU3lzLmdldE5leHRORGF5KHJhbmdlRGF0YS5zdGFydC50aW1lLCAtKDcgKyByYW5nZURhdGEuZndlZWspKS50aW1lO1xuICAgICAgbWFyZ2luID0gLW1hcmdpbjtcbiAgICB9XG4gICAgdmFyIGxhYmVsU2lsZW50ID0gZGF5TGFiZWwuZ2V0KCdzaWxlbnQnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgdmFyIHRtcEQgPSBjb29yZFN5cy5nZXROZXh0TkRheShzdGFydCwgaSk7XG4gICAgICB2YXIgcG9pbnQgPSBjb29yZFN5cy5kYXRhVG9SZWN0KFt0bXBELnRpbWVdLCBmYWxzZSkuY2VudGVyO1xuICAgICAgdmFyIGRheSA9IGk7XG4gICAgICBkYXkgPSBNYXRoLmFicygoaSArIGZpcnN0RGF5T2ZXZWVrKSAlIDcpO1xuICAgICAgdmFyIHdlZWtUZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgIHoyOiAzMCxcbiAgICAgICAgc3R5bGU6IGV4dGVuZChjcmVhdGVUZXh0U3R5bGUoZGF5TGFiZWwsIHtcbiAgICAgICAgICB0ZXh0OiBuYW1lTWFwW2RheV1cbiAgICAgICAgfSksIHRoaXMuX3dlZWtUZXh0UG9zaXRpb25Db250cm9sKHBvaW50LCBvcmllbnQsIHBvcywgbWFyZ2luLCBjZWxsU2l6ZSkpLFxuICAgICAgICBzaWxlbnQ6IGxhYmVsU2lsZW50XG4gICAgICB9KTtcbiAgICAgIGdyb3VwLmFkZCh3ZWVrVGV4dCk7XG4gICAgfVxuICB9O1xuICBDYWxlbmRhclZpZXcudHlwZSA9ICdjYWxlbmRhcic7XG4gIHJldHVybiBDYWxlbmRhclZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuZXhwb3J0IGRlZmF1bHQgQ2FsZW5kYXJWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IENhbGVuZGFyTW9kZWwgZnJvbSAnLi4vLi4vY29vcmQvY2FsZW5kYXIvQ2FsZW5kYXJNb2RlbC5qcyc7XG5pbXBvcnQgQ2FsZW5kYXJWaWV3IGZyb20gJy4vQ2FsZW5kYXJWaWV3LmpzJztcbmltcG9ydCBDYWxlbmRhciBmcm9tICcuLi8uLi9jb29yZC9jYWxlbmRhci9DYWxlbmRhci5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50TW9kZWwoQ2FsZW5kYXJNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoQ2FsZW5kYXJWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29vcmRpbmF0ZVN5c3RlbSgnY2FsZW5kYXInLCBDYWxlbmRhcik7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22379\n")},33820:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ installCommon)\n});\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/helper.js\nvar helper = __webpack_require__(68686);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/sliderMove.js\nvar sliderMove = __webpack_require__(98983);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/axisHelper.js\nvar axisHelper = __webpack_require__(99031);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/scaleRawExtentInfo.js\nvar scaleRawExtentInfo = __webpack_require__(42262);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n;// ./node_modules/echarts/lib/component/dataZoom/AxisProxy.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar each = util.each;\nvar asc = number/* asc */.Y6;\n/**\r\n * Operate single axis.\r\n * One axis can only operated by one axis operator.\r\n * Different dataZoomModels may be defined to operate the same axis.\r\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\r\n * So dataZoomModels share one axisProxy in that case.\r\n */\nvar AxisProxy = /** @class */function () {\n  function AxisProxy(dimName, axisIndex, dataZoomModel, ecModel) {\n    this._dimName = dimName;\n    this._axisIndex = axisIndex;\n    this.ecModel = ecModel;\n    this._dataZoomModel = dataZoomModel;\n    // /**\n    //  * @readOnly\n    //  * @private\n    //  */\n    // this.hasSeriesStacked;\n  }\n  /**\r\n   * Whether the axisProxy is hosted by dataZoomModel.\r\n   */\n  AxisProxy.prototype.hostedBy = function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  };\n  /**\r\n   * @return Value can only be NaN or finite value.\r\n   */\n  AxisProxy.prototype.getDataValueWindow = function () {\n    return this._valueWindow.slice();\n  };\n  /**\r\n   * @return {Array.<number>}\r\n   */\n  AxisProxy.prototype.getDataPercentWindow = function () {\n    return this._percentWindow.slice();\n  };\n  AxisProxy.prototype.getTargetSeriesModels = function () {\n    var seriesModels = [];\n    this.ecModel.eachSeries(function (seriesModel) {\n      if ((0,helper/* isCoordSupported */._u)(seriesModel)) {\n        var axisMainType = (0,helper/* getAxisMainType */.dX)(this._dimName);\n        var axisModel = seriesModel.getReferringComponents(axisMainType, model/* SINGLE_REFERRING */.US).models[0];\n        if (axisModel && this._axisIndex === axisModel.componentIndex) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  };\n  AxisProxy.prototype.getAxisModel = function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  };\n  AxisProxy.prototype.getMinMaxSpan = function () {\n    return util.clone(this._minMaxSpan);\n  };\n  /**\r\n   * Only calculate by given range and this._dataExtent, do not change anything.\r\n   */\n  AxisProxy.prototype.calculateDataWindow = function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n    var percentExtent = [0, 100];\n    var percentWindow = [];\n    var valueWindow = [];\n    var hasPropModeValue;\n    each(['start', 'end'], function (prop, idx) {\n      var boundPercent = opt[prop];\n      var boundValue = opt[prop + 'Value'];\n      // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). (They are based on the data extent\n      // but not min/max of axis, which will be calculated by data window then).\n      // The former one is suitable for cases that a dataZoom component controls multiple\n      // axes with different unit or extent, and the latter one is suitable for accurate\n      // zoom by pixel (e.g., in dataZoomSelect).\n      // we use `getRangePropMode()` to mark which prop is used. `rangePropMode` is updated\n      // only when setOption or dispatchAction, otherwise it remains its original value.\n      // (Why not only record `percentProp` and always map to `valueProp`? Because\n      // the map `valueProp` -> `percentProp` -> `valueProp` probably not the original\n      // `valueProp`. consider two axes constrolled by one dataZoom. They have different\n      // data extent. All of values that are overflow the `dataExtent` will be calculated\n      // to percent '100%').\n      if (rangePropMode[idx] === 'percent') {\n        boundPercent == null && (boundPercent = percentExtent[idx]);\n        // Use scale.parse to math round for category or time axis.\n        boundValue = scale.parse(number/* linearMap */.Cb(boundPercent, percentExtent, dataExtent));\n      } else {\n        hasPropModeValue = true;\n        boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue);\n        // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n        boundPercent = number/* linearMap */.Cb(boundValue, dataExtent, percentExtent);\n      }\n      // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n      // fallback to extent start/end when parsed value or percent is invalid\n      valueWindow[idx] = boundValue == null || isNaN(boundValue) ? dataExtent[idx] : boundValue;\n      percentWindow[idx] = boundPercent == null || isNaN(boundPercent) ? percentExtent[idx] : boundPercent;\n    });\n    asc(valueWindow);\n    asc(percentWindow);\n    // The windows from user calling of `dispatchAction` might be out of the extent,\n    // or do not obey the `min/maxSpan`, `min/maxValueSpan`. But we don't restrict window\n    // by `zoomLock` here, because we see `zoomLock` just as a interaction constraint,\n    // where API is able to initialize/modify the window size even though `zoomLock`\n    // specified.\n    var spans = this._minMaxSpan;\n    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);\n    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {\n      var suffix = toValue ? 'Span' : 'ValueSpan';\n      (0,sliderMove/* default */.A)(0, fromWindow, fromExtent, 'all', spans['min' + suffix], spans['max' + suffix]);\n      for (var i = 0; i < 2; i++) {\n        toWindow[i] = number/* linearMap */.Cb(fromWindow[i], fromExtent, toExtent, true);\n        toValue && (toWindow[i] = scale.parse(toWindow[i]));\n      }\n    }\n    return {\n      valueWindow: valueWindow,\n      percentWindow: percentWindow\n    };\n  };\n  /**\r\n   * Notice: reset should not be called before series.restoreData() is called,\r\n   * so it is recommended to be called in \"process stage\" but not \"model init\r\n   * stage\".\r\n   */\n  AxisProxy.prototype.reset = function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n    var targetSeries = this.getTargetSeriesModels();\n    // Culculate data window and data extent, and record them.\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);\n    // `calculateDataWindow` uses min/maxSpan.\n    this._updateMinMaxSpan();\n    var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow;\n    // Update axis setting then.\n    this._setAxisModel();\n  };\n  AxisProxy.prototype.filterData = function (dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n    if (filterMode === 'none') {\n      return;\n    }\n    // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // let otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get('$fromToolbox')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = 'empty';\n    // }\n    // TODO\n    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimensionsAll(axisDim);\n      if (!dataDims.length) {\n        return;\n      }\n      if (filterMode === 'weakFilter') {\n        var store_1 = seriesData.getStore();\n        var dataDimIndices_1 = util.map(dataDims, function (dim) {\n          return seriesData.getDimensionIndex(dim);\n        }, seriesData);\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = store_1.get(dataDimIndices_1[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          }\n          // If both left out and right out, do not filter.\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData = seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow;\n            // console.time('select');\n            seriesData.selectRange(range);\n            // console.timeEnd('select');\n          }\n        });\n      }\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  };\n  AxisProxy.prototype._updateMinMaxSpan = function () {\n    var minMaxSpan = this._minMaxSpan = {};\n    var dataZoomModel = this._dataZoomModel;\n    var dataExtent = this._dataExtent;\n    each(['min', 'max'], function (minMax) {\n      var percentSpan = dataZoomModel.get(minMax + 'Span');\n      var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n      valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan));\n      // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n      if (valueSpan != null) {\n        percentSpan = number/* linearMap */.Cb(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      } else if (percentSpan != null) {\n        valueSpan = number/* linearMap */.Cb(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];\n      }\n      minMaxSpan[minMax + 'Span'] = percentSpan;\n      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n    }, this);\n  };\n  AxisProxy.prototype._setAxisModel = function () {\n    var axisModel = this.getAxisModel();\n    var percentWindow = this._percentWindow;\n    var valueWindow = this._valueWindow;\n    if (!percentWindow) {\n      return;\n    }\n    // [0, 500]: arbitrary value, guess axis extent.\n    var precision = number/* getPixelPrecision */.hb(valueWindow, [0, 500]);\n    precision = Math.min(precision, 20);\n    // For value axis, if min/max/scale are not set, we just use the extent obtained\n    // by series data, which may be a little different from the extent calculated by\n    // `axisHelper.getScaleExtent`. But the different just affects the experience a\n    // little when zooming. So it will not be fixed until some users require it strongly.\n    var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;\n    if (percentWindow[0] !== 0) {\n      rawExtentInfo.setDeterminedMinMax('min', +valueWindow[0].toFixed(precision));\n    }\n    if (percentWindow[1] !== 100) {\n      rawExtentInfo.setDeterminedMinMax('max', +valueWindow[1].toFixed(precision));\n    }\n    rawExtentInfo.freeze();\n  };\n  return AxisProxy;\n}();\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    (0,axisHelper/* unionAxisExtentFromData */.PN)(dataExtent, seriesModel.getData(), axisDim);\n  });\n  // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n  var axisModel = axisProxy.getAxisModel();\n  var rawExtentResult = (0,scaleRawExtentInfo/* ensureScaleRawExtentInfo */.Tc)(axisModel.axis.scale, axisModel, dataExtent).calculate();\n  return [rawExtentResult.min, rawExtentResult.max];\n}\n/* harmony default export */ const dataZoom_AxisProxy = (AxisProxy);\n;// ./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar dataZoomProcessor = {\n  // `dataZoomProcessor` will only be performed in needed series. Consider if\n  // there is a line series and a pie series, it is better not to update the\n  // line series if only pie series is needed to be updated.\n  getTargetSeries: function (ecModel) {\n    function eachAxisModel(cb) {\n      ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n        dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n          var axisModel = ecModel.getComponent((0,helper/* getAxisMainType */.dX)(axisDim), axisIndex);\n          cb(axisDim, axisIndex, axisModel, dataZoomModel);\n        });\n      });\n    }\n    // FIXME: it brings side-effect to `getTargetSeries`.\n    // Prepare axis proxies.\n    eachAxisModel(function (axisDim, axisIndex, axisModel, dataZoomModel) {\n      // dispose all last axis proxy, in case that some axis are deleted.\n      axisModel.__dzAxisProxy = null;\n    });\n    var proxyList = [];\n    eachAxisModel(function (axisDim, axisIndex, axisModel, dataZoomModel) {\n      // Different dataZooms may constrol the same axis. In that case,\n      // an axisProxy serves both of them.\n      if (!axisModel.__dzAxisProxy) {\n        // Use the first dataZoomModel as the main model of axisProxy.\n        axisModel.__dzAxisProxy = new dataZoom_AxisProxy(axisDim, axisIndex, dataZoomModel, ecModel);\n        proxyList.push(axisModel.__dzAxisProxy);\n      }\n    });\n    var seriesModelMap = (0,util.createHashMap)();\n    (0,util.each)(proxyList, function (axisProxy) {\n      (0,util.each)(axisProxy.getTargetSeriesModels(), function (seriesModel) {\n        seriesModelMap.set(seriesModel.uid, seriesModel);\n      });\n    });\n    return seriesModelMap;\n  },\n  // Consider appendData, where filter should be performed. Because data process is\n  // in block mode currently, it is not need to worry about that the overallProgress\n  // execute every frame.\n  overallReset: function (ecModel, api) {\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      // We calculate window and reset axis here but not in model\n      // init stage and not after action dispatch handler, because\n      // reset should be called after seriesData.restoreData.\n      dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n        dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel);\n      });\n      // Caution: data zoom filtering is order sensitive when using\n      // percent range and no min/max/scale set on axis.\n      // For example, we have dataZoom definition:\n      // [\n      //      {xAxisIndex: 0, start: 30, end: 70},\n      //      {yAxisIndex: 0, start: 20, end: 80}\n      // ]\n      // In this case, [20, 80] of y-dataZoom should be based on data\n      // that have filtered by x-dataZoom using range of [30, 70],\n      // but should not be based on full raw data. Thus sliding\n      // x-dataZoom will change both ranges of xAxis and yAxis,\n      // while sliding y-dataZoom will only change the range of yAxis.\n      // So we should filter x-axis after reset x-axis immediately,\n      // and then reset y-axis and filter y-axis.\n      dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n        dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api);\n      });\n    });\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      // Fullfill all of the range props so that user\n      // is able to get them from chart.getOption().\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n      if (axisProxy) {\n        var percentRange = axisProxy.getDataPercentWindow();\n        var valueRange = axisProxy.getDataValueWindow();\n        dataZoomModel.setCalculatedRange({\n          start: percentRange[0],\n          end: percentRange[1],\n          startValue: valueRange[0],\n          endValue: valueRange[1]\n        });\n      }\n    });\n  }\n};\n/* harmony default export */ const dataZoom_dataZoomProcessor = (dataZoomProcessor);\n;// ./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction installDataZoomAction(registers) {\n  registers.registerAction('dataZoom', function (payload, ecModel) {\n    var effectedModels = (0,helper/* findEffectedDataZooms */.CN)(ecModel, payload);\n    (0,util.each)(effectedModels, function (dataZoomModel) {\n      dataZoomModel.setRawRange({\n        start: payload.start,\n        end: payload.end,\n        startValue: payload.startValue,\n        endValue: payload.endValue\n      });\n    });\n  });\n}\n;// ./node_modules/echarts/lib/component/dataZoom/installCommon.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar installed = false;\nfunction installCommon(registers) {\n  if (installed) {\n    return;\n  }\n  installed = true;\n  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, dataZoom_dataZoomProcessor);\n  installDataZoomAction(registers);\n  registers.registerSubTypeDefaulter('dataZoom', function () {\n    // Default 'slider' when no type specified.\n    return 'slider';\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM4MjAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vQXhpc1Byb3h5LmpzPzI0NGMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbVByb2Nlc3Nvci5qcz8xMGZhIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vZGF0YVpvb21BY3Rpb24uanM/Yzc0MCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2luc3RhbGxDb21tb24uanM/ODZkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7XG5pbXBvcnQgc2xpZGVyTW92ZSBmcm9tICcuLi9oZWxwZXIvc2xpZGVyTW92ZS5qcyc7XG5pbXBvcnQgeyB1bmlvbkF4aXNFeHRlbnRGcm9tRGF0YSB9IGZyb20gJy4uLy4uL2Nvb3JkL2F4aXNIZWxwZXIuanMnO1xuaW1wb3J0IHsgZW5zdXJlU2NhbGVSYXdFeHRlbnRJbmZvIH0gZnJvbSAnLi4vLi4vY29vcmQvc2NhbGVSYXdFeHRlbnRJbmZvLmpzJztcbmltcG9ydCB7IGdldEF4aXNNYWluVHlwZSwgaXNDb29yZFN1cHBvcnRlZCB9IGZyb20gJy4vaGVscGVyLmpzJztcbmltcG9ydCB7IFNJTkdMRV9SRUZFUlJJTkcgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgYXNjID0gbnVtYmVyVXRpbC5hc2M7XG4vKipcclxuICogT3BlcmF0ZSBzaW5nbGUgYXhpcy5cclxuICogT25lIGF4aXMgY2FuIG9ubHkgb3BlcmF0ZWQgYnkgb25lIGF4aXMgb3BlcmF0b3IuXHJcbiAqIERpZmZlcmVudCBkYXRhWm9vbU1vZGVscyBtYXkgYmUgZGVmaW5lZCB0byBvcGVyYXRlIHRoZSBzYW1lIGF4aXMuXHJcbiAqIChpLmUuICdpbnNpZGUnIGRhdGEgem9vbSBhbmQgJ3NsaWRlcicgZGF0YSB6b29tIGNvbXBvbmVudHMpXHJcbiAqIFNvIGRhdGFab29tTW9kZWxzIHNoYXJlIG9uZSBheGlzUHJveHkgaW4gdGhhdCBjYXNlLlxyXG4gKi9cbnZhciBBeGlzUHJveHkgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBeGlzUHJveHkoZGltTmFtZSwgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsLCBlY01vZGVsKSB7XG4gICAgdGhpcy5fZGltTmFtZSA9IGRpbU5hbWU7XG4gICAgdGhpcy5fYXhpc0luZGV4ID0gYXhpc0luZGV4O1xuICAgIHRoaXMuZWNNb2RlbCA9IGVjTW9kZWw7XG4gICAgdGhpcy5fZGF0YVpvb21Nb2RlbCA9IGRhdGFab29tTW9kZWw7XG4gICAgLy8gLyoqXG4gICAgLy8gICogQHJlYWRPbmx5XG4gICAgLy8gICogQHByaXZhdGVcbiAgICAvLyAgKi9cbiAgICAvLyB0aGlzLmhhc1Nlcmllc1N0YWNrZWQ7XG4gIH1cbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgYXhpc1Byb3h5IGlzIGhvc3RlZCBieSBkYXRhWm9vbU1vZGVsLlxyXG4gICAqL1xuICBBeGlzUHJveHkucHJvdG90eXBlLmhvc3RlZEJ5ID0gZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVpvb21Nb2RlbCA9PT0gZGF0YVpvb21Nb2RlbDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHJldHVybiBWYWx1ZSBjYW4gb25seSBiZSBOYU4gb3IgZmluaXRlIHZhbHVlLlxyXG4gICAqL1xuICBBeGlzUHJveHkucHJvdG90eXBlLmdldERhdGFWYWx1ZVdpbmRvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVXaW5kb3cuc2xpY2UoKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XHJcbiAgICovXG4gIEF4aXNQcm94eS5wcm90b3R5cGUuZ2V0RGF0YVBlcmNlbnRXaW5kb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlcmNlbnRXaW5kb3cuc2xpY2UoKTtcbiAgfTtcbiAgQXhpc1Byb3h5LnByb3RvdHlwZS5nZXRUYXJnZXRTZXJpZXNNb2RlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlcmllc01vZGVscyA9IFtdO1xuICAgIHRoaXMuZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgaWYgKGlzQ29vcmRTdXBwb3J0ZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgIHZhciBheGlzTWFpblR5cGUgPSBnZXRBeGlzTWFpblR5cGUodGhpcy5fZGltTmFtZSk7XG4gICAgICAgIHZhciBheGlzTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKGF4aXNNYWluVHlwZSwgU0lOR0xFX1JFRkVSUklORykubW9kZWxzWzBdO1xuICAgICAgICBpZiAoYXhpc01vZGVsICYmIHRoaXMuX2F4aXNJbmRleCA9PT0gYXhpc01vZGVsLmNvbXBvbmVudEluZGV4KSB7XG4gICAgICAgICAgc2VyaWVzTW9kZWxzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHNlcmllc01vZGVscztcbiAgfTtcbiAgQXhpc1Byb3h5LnByb3RvdHlwZS5nZXRBeGlzTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWNNb2RlbC5nZXRDb21wb25lbnQodGhpcy5fZGltTmFtZSArICdBeGlzJywgdGhpcy5fYXhpc0luZGV4KTtcbiAgfTtcbiAgQXhpc1Byb3h5LnByb3RvdHlwZS5nZXRNaW5NYXhTcGFuID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB6clV0aWwuY2xvbmUodGhpcy5fbWluTWF4U3Bhbik7XG4gIH07XG4gIC8qKlxyXG4gICAqIE9ubHkgY2FsY3VsYXRlIGJ5IGdpdmVuIHJhbmdlIGFuZCB0aGlzLl9kYXRhRXh0ZW50LCBkbyBub3QgY2hhbmdlIGFueXRoaW5nLlxyXG4gICAqL1xuICBBeGlzUHJveHkucHJvdG90eXBlLmNhbGN1bGF0ZURhdGFXaW5kb3cgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgdmFyIGRhdGFFeHRlbnQgPSB0aGlzLl9kYXRhRXh0ZW50O1xuICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmdldEF4aXNNb2RlbCgpO1xuICAgIHZhciBzY2FsZSA9IGF4aXNNb2RlbC5heGlzLnNjYWxlO1xuICAgIHZhciByYW5nZVByb3BNb2RlID0gdGhpcy5fZGF0YVpvb21Nb2RlbC5nZXRSYW5nZVByb3BNb2RlKCk7XG4gICAgdmFyIHBlcmNlbnRFeHRlbnQgPSBbMCwgMTAwXTtcbiAgICB2YXIgcGVyY2VudFdpbmRvdyA9IFtdO1xuICAgIHZhciB2YWx1ZVdpbmRvdyA9IFtdO1xuICAgIHZhciBoYXNQcm9wTW9kZVZhbHVlO1xuICAgIGVhY2goWydzdGFydCcsICdlbmQnXSwgZnVuY3Rpb24gKHByb3AsIGlkeCkge1xuICAgICAgdmFyIGJvdW5kUGVyY2VudCA9IG9wdFtwcm9wXTtcbiAgICAgIHZhciBib3VuZFZhbHVlID0gb3B0W3Byb3AgKyAnVmFsdWUnXTtcbiAgICAgIC8vIE5vdGljZTogZGF0YVpvb20gaXMgYmFzZWQgZWl0aGVyIG9uIGBwZXJjZW50UHJvcGAgKCdzdGFydCcsICdlbmQnKSBvclxuICAgICAgLy8gb24gYHZhbHVlUHJvcGAgKCdzdGFydFZhbHVlJywgJ2VuZFZhbHVlJykuIChUaGV5IGFyZSBiYXNlZCBvbiB0aGUgZGF0YSBleHRlbnRcbiAgICAgIC8vIGJ1dCBub3QgbWluL21heCBvZiBheGlzLCB3aGljaCB3aWxsIGJlIGNhbGN1bGF0ZWQgYnkgZGF0YSB3aW5kb3cgdGhlbikuXG4gICAgICAvLyBUaGUgZm9ybWVyIG9uZSBpcyBzdWl0YWJsZSBmb3IgY2FzZXMgdGhhdCBhIGRhdGFab29tIGNvbXBvbmVudCBjb250cm9scyBtdWx0aXBsZVxuICAgICAgLy8gYXhlcyB3aXRoIGRpZmZlcmVudCB1bml0IG9yIGV4dGVudCwgYW5kIHRoZSBsYXR0ZXIgb25lIGlzIHN1aXRhYmxlIGZvciBhY2N1cmF0ZVxuICAgICAgLy8gem9vbSBieSBwaXhlbCAoZS5nLiwgaW4gZGF0YVpvb21TZWxlY3QpLlxuICAgICAgLy8gd2UgdXNlIGBnZXRSYW5nZVByb3BNb2RlKClgIHRvIG1hcmsgd2hpY2ggcHJvcCBpcyB1c2VkLiBgcmFuZ2VQcm9wTW9kZWAgaXMgdXBkYXRlZFxuICAgICAgLy8gb25seSB3aGVuIHNldE9wdGlvbiBvciBkaXNwYXRjaEFjdGlvbiwgb3RoZXJ3aXNlIGl0IHJlbWFpbnMgaXRzIG9yaWdpbmFsIHZhbHVlLlxuICAgICAgLy8gKFdoeSBub3Qgb25seSByZWNvcmQgYHBlcmNlbnRQcm9wYCBhbmQgYWx3YXlzIG1hcCB0byBgdmFsdWVQcm9wYD8gQmVjYXVzZVxuICAgICAgLy8gdGhlIG1hcCBgdmFsdWVQcm9wYCAtPiBgcGVyY2VudFByb3BgIC0+IGB2YWx1ZVByb3BgIHByb2JhYmx5IG5vdCB0aGUgb3JpZ2luYWxcbiAgICAgIC8vIGB2YWx1ZVByb3BgLiBjb25zaWRlciB0d28gYXhlcyBjb25zdHJvbGxlZCBieSBvbmUgZGF0YVpvb20uIFRoZXkgaGF2ZSBkaWZmZXJlbnRcbiAgICAgIC8vIGRhdGEgZXh0ZW50LiBBbGwgb2YgdmFsdWVzIHRoYXQgYXJlIG92ZXJmbG93IHRoZSBgZGF0YUV4dGVudGAgd2lsbCBiZSBjYWxjdWxhdGVkXG4gICAgICAvLyB0byBwZXJjZW50ICcxMDAlJykuXG4gICAgICBpZiAocmFuZ2VQcm9wTW9kZVtpZHhdID09PSAncGVyY2VudCcpIHtcbiAgICAgICAgYm91bmRQZXJjZW50ID09IG51bGwgJiYgKGJvdW5kUGVyY2VudCA9IHBlcmNlbnRFeHRlbnRbaWR4XSk7XG4gICAgICAgIC8vIFVzZSBzY2FsZS5wYXJzZSB0byBtYXRoIHJvdW5kIGZvciBjYXRlZ29yeSBvciB0aW1lIGF4aXMuXG4gICAgICAgIGJvdW5kVmFsdWUgPSBzY2FsZS5wYXJzZShudW1iZXJVdGlsLmxpbmVhck1hcChib3VuZFBlcmNlbnQsIHBlcmNlbnRFeHRlbnQsIGRhdGFFeHRlbnQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1Byb3BNb2RlVmFsdWUgPSB0cnVlO1xuICAgICAgICBib3VuZFZhbHVlID0gYm91bmRWYWx1ZSA9PSBudWxsID8gZGF0YUV4dGVudFtpZHhdIDogc2NhbGUucGFyc2UoYm91bmRWYWx1ZSk7XG4gICAgICAgIC8vIENhbGN1bGF0aW5nIGBwZXJjZW50YCBmcm9tIGB2YWx1ZWAgbWF5IGJlIG5vdCBhY2N1cmF0ZSwgYmVjYXVzZVxuICAgICAgICAvLyBUaGlzIGNhbGN1bGF0aW9uIGNhbiBub3QgYmUgaW52ZXJzZWQsIGJlY2F1c2UgYWxsIG9mIHZhbHVlcyB0aGF0XG4gICAgICAgIC8vIGFyZSBvdmVyZmxvdyB0aGUgYGRhdGFFeHRlbnRgIHdpbGwgYmUgY2FsY3VsYXRlZCB0byBwZXJjZW50ICcxMDAlJ1xuICAgICAgICBib3VuZFBlcmNlbnQgPSBudW1iZXJVdGlsLmxpbmVhck1hcChib3VuZFZhbHVlLCBkYXRhRXh0ZW50LCBwZXJjZW50RXh0ZW50KTtcbiAgICAgIH1cbiAgICAgIC8vIHZhbHVlV2luZG93W2lkeF0gPSByb3VuZChib3VuZFZhbHVlKTtcbiAgICAgIC8vIHBlcmNlbnRXaW5kb3dbaWR4XSA9IHJvdW5kKGJvdW5kUGVyY2VudCk7XG4gICAgICAvLyBmYWxsYmFjayB0byBleHRlbnQgc3RhcnQvZW5kIHdoZW4gcGFyc2VkIHZhbHVlIG9yIHBlcmNlbnQgaXMgaW52YWxpZFxuICAgICAgdmFsdWVXaW5kb3dbaWR4XSA9IGJvdW5kVmFsdWUgPT0gbnVsbCB8fCBpc05hTihib3VuZFZhbHVlKSA/IGRhdGFFeHRlbnRbaWR4XSA6IGJvdW5kVmFsdWU7XG4gICAgICBwZXJjZW50V2luZG93W2lkeF0gPSBib3VuZFBlcmNlbnQgPT0gbnVsbCB8fCBpc05hTihib3VuZFBlcmNlbnQpID8gcGVyY2VudEV4dGVudFtpZHhdIDogYm91bmRQZXJjZW50O1xuICAgIH0pO1xuICAgIGFzYyh2YWx1ZVdpbmRvdyk7XG4gICAgYXNjKHBlcmNlbnRXaW5kb3cpO1xuICAgIC8vIFRoZSB3aW5kb3dzIGZyb20gdXNlciBjYWxsaW5nIG9mIGBkaXNwYXRjaEFjdGlvbmAgbWlnaHQgYmUgb3V0IG9mIHRoZSBleHRlbnQsXG4gICAgLy8gb3IgZG8gbm90IG9iZXkgdGhlIGBtaW4vbWF4U3BhbmAsIGBtaW4vbWF4VmFsdWVTcGFuYC4gQnV0IHdlIGRvbid0IHJlc3RyaWN0IHdpbmRvd1xuICAgIC8vIGJ5IGB6b29tTG9ja2AgaGVyZSwgYmVjYXVzZSB3ZSBzZWUgYHpvb21Mb2NrYCBqdXN0IGFzIGEgaW50ZXJhY3Rpb24gY29uc3RyYWludCxcbiAgICAvLyB3aGVyZSBBUEkgaXMgYWJsZSB0byBpbml0aWFsaXplL21vZGlmeSB0aGUgd2luZG93IHNpemUgZXZlbiB0aG91Z2ggYHpvb21Mb2NrYFxuICAgIC8vIHNwZWNpZmllZC5cbiAgICB2YXIgc3BhbnMgPSB0aGlzLl9taW5NYXhTcGFuO1xuICAgIGhhc1Byb3BNb2RlVmFsdWUgPyByZXN0cmljdFNldCh2YWx1ZVdpbmRvdywgcGVyY2VudFdpbmRvdywgZGF0YUV4dGVudCwgcGVyY2VudEV4dGVudCwgZmFsc2UpIDogcmVzdHJpY3RTZXQocGVyY2VudFdpbmRvdywgdmFsdWVXaW5kb3csIHBlcmNlbnRFeHRlbnQsIGRhdGFFeHRlbnQsIHRydWUpO1xuICAgIGZ1bmN0aW9uIHJlc3RyaWN0U2V0KGZyb21XaW5kb3csIHRvV2luZG93LCBmcm9tRXh0ZW50LCB0b0V4dGVudCwgdG9WYWx1ZSkge1xuICAgICAgdmFyIHN1ZmZpeCA9IHRvVmFsdWUgPyAnU3BhbicgOiAnVmFsdWVTcGFuJztcbiAgICAgIHNsaWRlck1vdmUoMCwgZnJvbVdpbmRvdywgZnJvbUV4dGVudCwgJ2FsbCcsIHNwYW5zWydtaW4nICsgc3VmZml4XSwgc3BhbnNbJ21heCcgKyBzdWZmaXhdKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgIHRvV2luZG93W2ldID0gbnVtYmVyVXRpbC5saW5lYXJNYXAoZnJvbVdpbmRvd1tpXSwgZnJvbUV4dGVudCwgdG9FeHRlbnQsIHRydWUpO1xuICAgICAgICB0b1ZhbHVlICYmICh0b1dpbmRvd1tpXSA9IHNjYWxlLnBhcnNlKHRvV2luZG93W2ldKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZVdpbmRvdzogdmFsdWVXaW5kb3csXG4gICAgICBwZXJjZW50V2luZG93OiBwZXJjZW50V2luZG93XG4gICAgfTtcbiAgfTtcbiAgLyoqXHJcbiAgICogTm90aWNlOiByZXNldCBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUgc2VyaWVzLnJlc3RvcmVEYXRhKCkgaXMgY2FsbGVkLFxyXG4gICAqIHNvIGl0IGlzIHJlY29tbWVuZGVkIHRvIGJlIGNhbGxlZCBpbiBcInByb2Nlc3Mgc3RhZ2VcIiBidXQgbm90IFwibW9kZWwgaW5pdFxyXG4gICAqIHN0YWdlXCIuXHJcbiAgICovXG4gIEF4aXNQcm94eS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgIGlmIChkYXRhWm9vbU1vZGVsICE9PSB0aGlzLl9kYXRhWm9vbU1vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0YXJnZXRTZXJpZXMgPSB0aGlzLmdldFRhcmdldFNlcmllc01vZGVscygpO1xuICAgIC8vIEN1bGN1bGF0ZSBkYXRhIHdpbmRvdyBhbmQgZGF0YSBleHRlbnQsIGFuZCByZWNvcmQgdGhlbS5cbiAgICB0aGlzLl9kYXRhRXh0ZW50ID0gY2FsY3VsYXRlRGF0YUV4dGVudCh0aGlzLCB0aGlzLl9kaW1OYW1lLCB0YXJnZXRTZXJpZXMpO1xuICAgIC8vIGBjYWxjdWxhdGVEYXRhV2luZG93YCB1c2VzIG1pbi9tYXhTcGFuLlxuICAgIHRoaXMuX3VwZGF0ZU1pbk1heFNwYW4oKTtcbiAgICB2YXIgZGF0YVdpbmRvdyA9IHRoaXMuY2FsY3VsYXRlRGF0YVdpbmRvdyhkYXRhWm9vbU1vZGVsLnNldHRsZWRPcHRpb24pO1xuICAgIHRoaXMuX3ZhbHVlV2luZG93ID0gZGF0YVdpbmRvdy52YWx1ZVdpbmRvdztcbiAgICB0aGlzLl9wZXJjZW50V2luZG93ID0gZGF0YVdpbmRvdy5wZXJjZW50V2luZG93O1xuICAgIC8vIFVwZGF0ZSBheGlzIHNldHRpbmcgdGhlbi5cbiAgICB0aGlzLl9zZXRBeGlzTW9kZWwoKTtcbiAgfTtcbiAgQXhpc1Byb3h5LnByb3RvdHlwZS5maWx0ZXJEYXRhID0gZnVuY3Rpb24gKGRhdGFab29tTW9kZWwsIGFwaSkge1xuICAgIGlmIChkYXRhWm9vbU1vZGVsICE9PSB0aGlzLl9kYXRhWm9vbU1vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBheGlzRGltID0gdGhpcy5fZGltTmFtZTtcbiAgICB2YXIgc2VyaWVzTW9kZWxzID0gdGhpcy5nZXRUYXJnZXRTZXJpZXNNb2RlbHMoKTtcbiAgICB2YXIgZmlsdGVyTW9kZSA9IGRhdGFab29tTW9kZWwuZ2V0KCdmaWx0ZXJNb2RlJyk7XG4gICAgdmFyIHZhbHVlV2luZG93ID0gdGhpcy5fdmFsdWVXaW5kb3c7XG4gICAgaWYgKGZpbHRlck1vZGUgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGSVhNRVxuICAgIC8vIFRvb2xib3ggbWF5IGhhcyBkYXRhWm9vbSBpbmplY3RlZC4gQW5kIGlmIHRoZXJlIGFyZSBzdGFja2VkIGJhciBjaGFydFxuICAgIC8vIHdpdGggTmFOIGRhdGEsIE5hTiB3aWxsIGJlIGZpbHRlcmVkIGFuZCBzdGFjayB3aWxsIGJlIHdyb25nLlxuICAgIC8vIFNvIHdlIG5lZWQgdG8gZm9yY2UgdGhlIG1vZGUgdG8gYmUgc2V0IGVtcHR5LlxuICAgIC8vIEluIGZlY3QsIGl0IGlzIG5vdCBhIGJpZyBkZWFsIHRoYXQgZG8gbm90IHN1cHBvcnQgZmlsdGVyTW9kZS0nZmlsdGVyJ1xuICAgIC8vIHdoZW4gdXNpbmcgdG9vbGJveCNkYXRhWm9vbSwgdXRpbGwgdG9vbHRpcCNkYXRhWm9vbSBzdXBwb3J0IFwic2luZ2xlIGF4aXNcbiAgICAvLyBzZWxlY3Rpb25cIiBzb21lIGRheSwgd2hpY2ggbWlnaHQgbmVlZCBcImFkYXB0IHRvIGRhdGEgZXh0ZW50IG9uIHRoZVxuICAgIC8vIG90aGVyQXhpc1wiLCB3aGljaCBpcyBkaXNhYmxlZCBieSBmaWx0ZXJNb2RlLSdlbXB0eScuXG4gICAgLy8gQnV0IGN1cnJlbnRseSwgc3RhY2sgaGFzIGJlZW4gZml4ZWQgdG8gYmFzZWQgb24gdmFsdWUgYnV0IG5vdCBpbmRleCxcbiAgICAvLyBzbyB0aGlzIGlzIG5vdCBhbiBpc3N1ZSBhbnkgbW9yZS5cbiAgICAvLyBsZXQgb3RoZXJBeGlzTW9kZWwgPSB0aGlzLmdldE90aGVyQXhpc01vZGVsKCk7XG4gICAgLy8gaWYgKGRhdGFab29tTW9kZWwuZ2V0KCckZnJvbVRvb2xib3gnKVxuICAgIC8vICAgICAmJiBvdGhlckF4aXNNb2RlbFxuICAgIC8vICAgICAmJiBvdGhlckF4aXNNb2RlbC5oYXNTZXJpZXNTdGFja2VkXG4gICAgLy8gKSB7XG4gICAgLy8gICAgIGZpbHRlck1vZGUgPSAnZW1wdHknO1xuICAgIC8vIH1cbiAgICAvLyBUT0RPXG4gICAgLy8gZmlsdGVyTW9kZSAnd2Vha0ZpbHRlcicgYW5kICdlbXB0eScgaXMgbm90IG9wdGltaXplZCBmb3IgaHVnZSBkYXRhIHlldC5cbiAgICBlYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgIHZhciBkYXRhRGltcyA9IHNlcmllc0RhdGEubWFwRGltZW5zaW9uc0FsbChheGlzRGltKTtcbiAgICAgIGlmICghZGF0YURpbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXJNb2RlID09PSAnd2Vha0ZpbHRlcicpIHtcbiAgICAgICAgdmFyIHN0b3JlXzEgPSBzZXJpZXNEYXRhLmdldFN0b3JlKCk7XG4gICAgICAgIHZhciBkYXRhRGltSW5kaWNlc18xID0genJVdGlsLm1hcChkYXRhRGltcywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgIHJldHVybiBzZXJpZXNEYXRhLmdldERpbWVuc2lvbkluZGV4KGRpbSk7XG4gICAgICAgIH0sIHNlcmllc0RhdGEpO1xuICAgICAgICBzZXJpZXNEYXRhLmZpbHRlclNlbGYoZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICAgIHZhciBsZWZ0T3V0O1xuICAgICAgICAgIHZhciByaWdodE91dDtcbiAgICAgICAgICB2YXIgaGFzVmFsdWU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhRGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc3RvcmVfMS5nZXQoZGF0YURpbUluZGljZXNfMVtpXSwgZGF0YUluZGV4KTtcbiAgICAgICAgICAgIHZhciB0aGlzSGFzVmFsdWUgPSAhaXNOYU4odmFsdWUpO1xuICAgICAgICAgICAgdmFyIHRoaXNMZWZ0T3V0ID0gdmFsdWUgPCB2YWx1ZVdpbmRvd1swXTtcbiAgICAgICAgICAgIHZhciB0aGlzUmlnaHRPdXQgPSB2YWx1ZSA+IHZhbHVlV2luZG93WzFdO1xuICAgICAgICAgICAgaWYgKHRoaXNIYXNWYWx1ZSAmJiAhdGhpc0xlZnRPdXQgJiYgIXRoaXNSaWdodE91dCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNIYXNWYWx1ZSAmJiAoaGFzVmFsdWUgPSB0cnVlKTtcbiAgICAgICAgICAgIHRoaXNMZWZ0T3V0ICYmIChsZWZ0T3V0ID0gdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzUmlnaHRPdXQgJiYgKHJpZ2h0T3V0ID0gdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIGJvdGggbGVmdCBvdXQgYW5kIHJpZ2h0IG91dCwgZG8gbm90IGZpbHRlci5cbiAgICAgICAgICByZXR1cm4gaGFzVmFsdWUgJiYgbGVmdE91dCAmJiByaWdodE91dDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYWNoKGRhdGFEaW1zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgICAgaWYgKGZpbHRlck1vZGUgPT09ICdlbXB0eScpIHtcbiAgICAgICAgICAgIHNlcmllc01vZGVsLnNldERhdGEoc2VyaWVzRGF0YSA9IHNlcmllc0RhdGEubWFwKGRpbSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhaXNJbldpbmRvdyh2YWx1ZSkgPyBOYU4gOiB2YWx1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0ge307XG4gICAgICAgICAgICByYW5nZVtkaW1dID0gdmFsdWVXaW5kb3c7XG4gICAgICAgICAgICAvLyBjb25zb2xlLnRpbWUoJ3NlbGVjdCcpO1xuICAgICAgICAgICAgc2VyaWVzRGF0YS5zZWxlY3RSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLnRpbWVFbmQoJ3NlbGVjdCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlYWNoKGRhdGFEaW1zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIHNlcmllc0RhdGEuc2V0QXBwcm94aW1hdGVFeHRlbnQodmFsdWVXaW5kb3csIGRpbSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpc0luV2luZG93KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gdmFsdWVXaW5kb3dbMF0gJiYgdmFsdWUgPD0gdmFsdWVXaW5kb3dbMV07XG4gICAgfVxuICB9O1xuICBBeGlzUHJveHkucHJvdG90eXBlLl91cGRhdGVNaW5NYXhTcGFuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtaW5NYXhTcGFuID0gdGhpcy5fbWluTWF4U3BhbiA9IHt9O1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5fZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHRoaXMuX2RhdGFFeHRlbnQ7XG4gICAgZWFjaChbJ21pbicsICdtYXgnXSwgZnVuY3Rpb24gKG1pbk1heCkge1xuICAgICAgdmFyIHBlcmNlbnRTcGFuID0gZGF0YVpvb21Nb2RlbC5nZXQobWluTWF4ICsgJ1NwYW4nKTtcbiAgICAgIHZhciB2YWx1ZVNwYW4gPSBkYXRhWm9vbU1vZGVsLmdldChtaW5NYXggKyAnVmFsdWVTcGFuJyk7XG4gICAgICB2YWx1ZVNwYW4gIT0gbnVsbCAmJiAodmFsdWVTcGFuID0gdGhpcy5nZXRBeGlzTW9kZWwoKS5heGlzLnNjYWxlLnBhcnNlKHZhbHVlU3BhbikpO1xuICAgICAgLy8gbWluVmFsdWVTcGFuIGFuZCBtYXhWYWx1ZVNwYW4gaGFzIGhpZ2hlciBwcmlvcml0eSB0aGFuIG1pblNwYW4gYW5kIG1heFNwYW5cbiAgICAgIGlmICh2YWx1ZVNwYW4gIT0gbnVsbCkge1xuICAgICAgICBwZXJjZW50U3BhbiA9IG51bWJlclV0aWwubGluZWFyTWFwKGRhdGFFeHRlbnRbMF0gKyB2YWx1ZVNwYW4sIGRhdGFFeHRlbnQsIFswLCAxMDBdLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAocGVyY2VudFNwYW4gIT0gbnVsbCkge1xuICAgICAgICB2YWx1ZVNwYW4gPSBudW1iZXJVdGlsLmxpbmVhck1hcChwZXJjZW50U3BhbiwgWzAsIDEwMF0sIGRhdGFFeHRlbnQsIHRydWUpIC0gZGF0YUV4dGVudFswXTtcbiAgICAgIH1cbiAgICAgIG1pbk1heFNwYW5bbWluTWF4ICsgJ1NwYW4nXSA9IHBlcmNlbnRTcGFuO1xuICAgICAgbWluTWF4U3BhblttaW5NYXggKyAnVmFsdWVTcGFuJ10gPSB2YWx1ZVNwYW47XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIEF4aXNQcm94eS5wcm90b3R5cGUuX3NldEF4aXNNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5nZXRBeGlzTW9kZWwoKTtcbiAgICB2YXIgcGVyY2VudFdpbmRvdyA9IHRoaXMuX3BlcmNlbnRXaW5kb3c7XG4gICAgdmFyIHZhbHVlV2luZG93ID0gdGhpcy5fdmFsdWVXaW5kb3c7XG4gICAgaWYgKCFwZXJjZW50V2luZG93KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFswLCA1MDBdOiBhcmJpdHJhcnkgdmFsdWUsIGd1ZXNzIGF4aXMgZXh0ZW50LlxuICAgIHZhciBwcmVjaXNpb24gPSBudW1iZXJVdGlsLmdldFBpeGVsUHJlY2lzaW9uKHZhbHVlV2luZG93LCBbMCwgNTAwXSk7XG4gICAgcHJlY2lzaW9uID0gTWF0aC5taW4ocHJlY2lzaW9uLCAyMCk7XG4gICAgLy8gRm9yIHZhbHVlIGF4aXMsIGlmIG1pbi9tYXgvc2NhbGUgYXJlIG5vdCBzZXQsIHdlIGp1c3QgdXNlIHRoZSBleHRlbnQgb2J0YWluZWRcbiAgICAvLyBieSBzZXJpZXMgZGF0YSwgd2hpY2ggbWF5IGJlIGEgbGl0dGxlIGRpZmZlcmVudCBmcm9tIHRoZSBleHRlbnQgY2FsY3VsYXRlZCBieVxuICAgIC8vIGBheGlzSGVscGVyLmdldFNjYWxlRXh0ZW50YC4gQnV0IHRoZSBkaWZmZXJlbnQganVzdCBhZmZlY3RzIHRoZSBleHBlcmllbmNlIGFcbiAgICAvLyBsaXR0bGUgd2hlbiB6b29taW5nLiBTbyBpdCB3aWxsIG5vdCBiZSBmaXhlZCB1bnRpbCBzb21lIHVzZXJzIHJlcXVpcmUgaXQgc3Ryb25nbHkuXG4gICAgdmFyIHJhd0V4dGVudEluZm8gPSBheGlzTW9kZWwuYXhpcy5zY2FsZS5yYXdFeHRlbnRJbmZvO1xuICAgIGlmIChwZXJjZW50V2luZG93WzBdICE9PSAwKSB7XG4gICAgICByYXdFeHRlbnRJbmZvLnNldERldGVybWluZWRNaW5NYXgoJ21pbicsICt2YWx1ZVdpbmRvd1swXS50b0ZpeGVkKHByZWNpc2lvbikpO1xuICAgIH1cbiAgICBpZiAocGVyY2VudFdpbmRvd1sxXSAhPT0gMTAwKSB7XG4gICAgICByYXdFeHRlbnRJbmZvLnNldERldGVybWluZWRNaW5NYXgoJ21heCcsICt2YWx1ZVdpbmRvd1sxXS50b0ZpeGVkKHByZWNpc2lvbikpO1xuICAgIH1cbiAgICByYXdFeHRlbnRJbmZvLmZyZWV6ZSgpO1xuICB9O1xuICByZXR1cm4gQXhpc1Byb3h5O1xufSgpO1xuZnVuY3Rpb24gY2FsY3VsYXRlRGF0YUV4dGVudChheGlzUHJveHksIGF4aXNEaW0sIHNlcmllc01vZGVscykge1xuICB2YXIgZGF0YUV4dGVudCA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgZWFjaChzZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHVuaW9uQXhpc0V4dGVudEZyb21EYXRhKGRhdGFFeHRlbnQsIHNlcmllc01vZGVsLmdldERhdGEoKSwgYXhpc0RpbSk7XG4gIH0pO1xuICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gZ2V0IFwiY29uc2lzdGVudFwiIGV4dGVudCB3aGVuIG1vcmUgdGhlbiBvbmUgYXhlcyBpc1xuICAvLyBjb250cm9sbGVkIGJ5IGEgYGRhdGFab29tYCwgb3RoZXJ3aXNlIHRob3NlIGF4ZXMgd2lsbCBub3QgYmUgc3luY2hyb25pemVkXG4gIC8vIHdoZW4gem9vbWluZy4gQnV0IGl0IGlzIGRpZmZpY3VsdCB0byBrbm93IHdoYXQgaXMgXCJjb25zaXN0ZW50XCIsIGNvbnNpZGVyaW5nXG4gIC8vIGF4ZXMgaGF2ZSBkaWZmZXJlbnQgdHlwZSBvciBldmVuIGRpZmZlcmVudCBtZWFuaW5ncyAoRm9yIGV4YW1wbGUsIHR3b1xuICAvLyB0aW1lIGF4ZXMgYXJlIHVzZWQgdG8gY29tcGFyZSBkYXRhIG9mIHRoZSBzYW1lIGRhdGUgaW4gZGlmZmVyZW50IHllYXJzKS5cbiAgLy8gU28gYmFzaWNhbGx5IGRhdGFab29tIGp1c3Qgb2J0YWlucyBleHRlbnQgYnkgc2VyaWVzLmRhdGEgKGluIGNhdGVnb3J5IGF4aXNcbiAgLy8gZXh0ZW50IGNhbiBiZSBvYnRhaW5lZCBmcm9tIGF4aXMuZGF0YSkuXG4gIC8vIE5ldmVydGhlbGVzcywgdXNlciBjYW4gc2V0IG1pbi9tYXgvc2NhbGUgb24gYXhlcyB0byBtYWtlIGV4dGVudCBvZiBheGVzXG4gIC8vIGNvbnNpc3RlbnQuXG4gIHZhciBheGlzTW9kZWwgPSBheGlzUHJveHkuZ2V0QXhpc01vZGVsKCk7XG4gIHZhciByYXdFeHRlbnRSZXN1bHQgPSBlbnN1cmVTY2FsZVJhd0V4dGVudEluZm8oYXhpc01vZGVsLmF4aXMuc2NhbGUsIGF4aXNNb2RlbCwgZGF0YUV4dGVudCkuY2FsY3VsYXRlKCk7XG4gIHJldHVybiBbcmF3RXh0ZW50UmVzdWx0Lm1pbiwgcmF3RXh0ZW50UmVzdWx0Lm1heF07XG59XG5leHBvcnQgZGVmYXVsdCBBeGlzUHJveHk7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBjcmVhdGVIYXNoTWFwLCBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGdldEF4aXNNYWluVHlwZSB9IGZyb20gJy4vaGVscGVyLmpzJztcbmltcG9ydCBBeGlzUHJveHkgZnJvbSAnLi9BeGlzUHJveHkuanMnO1xudmFyIGRhdGFab29tUHJvY2Vzc29yID0ge1xuICAvLyBgZGF0YVpvb21Qcm9jZXNzb3JgIHdpbGwgb25seSBiZSBwZXJmb3JtZWQgaW4gbmVlZGVkIHNlcmllcy4gQ29uc2lkZXIgaWZcbiAgLy8gdGhlcmUgaXMgYSBsaW5lIHNlcmllcyBhbmQgYSBwaWUgc2VyaWVzLCBpdCBpcyBiZXR0ZXIgbm90IHRvIHVwZGF0ZSB0aGVcbiAgLy8gbGluZSBzZXJpZXMgaWYgb25seSBwaWUgc2VyaWVzIGlzIG5lZWRlZCB0byBiZSB1cGRhdGVkLlxuICBnZXRUYXJnZXRTZXJpZXM6IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgZnVuY3Rpb24gZWFjaEF4aXNNb2RlbChjYikge1xuICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdkYXRhWm9vbScsIGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgIGRhdGFab29tTW9kZWwuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGF4aXNEaW0sIGF4aXNJbmRleCkge1xuICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudChnZXRBeGlzTWFpblR5cGUoYXhpc0RpbSksIGF4aXNJbmRleCk7XG4gICAgICAgICAgY2IoYXhpc0RpbSwgYXhpc0luZGV4LCBheGlzTW9kZWwsIGRhdGFab29tTW9kZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBGSVhNRTogaXQgYnJpbmdzIHNpZGUtZWZmZWN0IHRvIGBnZXRUYXJnZXRTZXJpZXNgLlxuICAgIC8vIFByZXBhcmUgYXhpcyBwcm94aWVzLlxuICAgIGVhY2hBeGlzTW9kZWwoZnVuY3Rpb24gKGF4aXNEaW0sIGF4aXNJbmRleCwgYXhpc01vZGVsLCBkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAvLyBkaXNwb3NlIGFsbCBsYXN0IGF4aXMgcHJveHksIGluIGNhc2UgdGhhdCBzb21lIGF4aXMgYXJlIGRlbGV0ZWQuXG4gICAgICBheGlzTW9kZWwuX19kekF4aXNQcm94eSA9IG51bGw7XG4gICAgfSk7XG4gICAgdmFyIHByb3h5TGlzdCA9IFtdO1xuICAgIGVhY2hBeGlzTW9kZWwoZnVuY3Rpb24gKGF4aXNEaW0sIGF4aXNJbmRleCwgYXhpc01vZGVsLCBkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAvLyBEaWZmZXJlbnQgZGF0YVpvb21zIG1heSBjb25zdHJvbCB0aGUgc2FtZSBheGlzLiBJbiB0aGF0IGNhc2UsXG4gICAgICAvLyBhbiBheGlzUHJveHkgc2VydmVzIGJvdGggb2YgdGhlbS5cbiAgICAgIGlmICghYXhpc01vZGVsLl9fZHpBeGlzUHJveHkpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBmaXJzdCBkYXRhWm9vbU1vZGVsIGFzIHRoZSBtYWluIG1vZGVsIG9mIGF4aXNQcm94eS5cbiAgICAgICAgYXhpc01vZGVsLl9fZHpBeGlzUHJveHkgPSBuZXcgQXhpc1Byb3h5KGF4aXNEaW0sIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCk7XG4gICAgICAgIHByb3h5TGlzdC5wdXNoKGF4aXNNb2RlbC5fX2R6QXhpc1Byb3h5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgc2VyaWVzTW9kZWxNYXAgPSBjcmVhdGVIYXNoTWFwKCk7XG4gICAgZWFjaChwcm94eUxpc3QsIGZ1bmN0aW9uIChheGlzUHJveHkpIHtcbiAgICAgIGVhY2goYXhpc1Byb3h5LmdldFRhcmdldFNlcmllc01vZGVscygpLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgc2VyaWVzTW9kZWxNYXAuc2V0KHNlcmllc01vZGVsLnVpZCwgc2VyaWVzTW9kZWwpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlcmllc01vZGVsTWFwO1xuICB9LFxuICAvLyBDb25zaWRlciBhcHBlbmREYXRhLCB3aGVyZSBmaWx0ZXIgc2hvdWxkIGJlIHBlcmZvcm1lZC4gQmVjYXVzZSBkYXRhIHByb2Nlc3MgaXNcbiAgLy8gaW4gYmxvY2sgbW9kZSBjdXJyZW50bHksIGl0IGlzIG5vdCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQgdGhlIG92ZXJhbGxQcm9ncmVzc1xuICAvLyBleGVjdXRlIGV2ZXJ5IGZyYW1lLlxuICBvdmVyYWxsUmVzZXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ2RhdGFab29tJywgZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICAgIC8vIFdlIGNhbGN1bGF0ZSB3aW5kb3cgYW5kIHJlc2V0IGF4aXMgaGVyZSBidXQgbm90IGluIG1vZGVsXG4gICAgICAvLyBpbml0IHN0YWdlIGFuZCBub3QgYWZ0ZXIgYWN0aW9uIGRpc3BhdGNoIGhhbmRsZXIsIGJlY2F1c2VcbiAgICAgIC8vIHJlc2V0IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgc2VyaWVzRGF0YS5yZXN0b3JlRGF0YS5cbiAgICAgIGRhdGFab29tTW9kZWwuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGF4aXNEaW0sIGF4aXNJbmRleCkge1xuICAgICAgICBkYXRhWm9vbU1vZGVsLmdldEF4aXNQcm94eShheGlzRGltLCBheGlzSW5kZXgpLnJlc2V0KGRhdGFab29tTW9kZWwpO1xuICAgICAgfSk7XG4gICAgICAvLyBDYXV0aW9uOiBkYXRhIHpvb20gZmlsdGVyaW5nIGlzIG9yZGVyIHNlbnNpdGl2ZSB3aGVuIHVzaW5nXG4gICAgICAvLyBwZXJjZW50IHJhbmdlIGFuZCBubyBtaW4vbWF4L3NjYWxlIHNldCBvbiBheGlzLlxuICAgICAgLy8gRm9yIGV4YW1wbGUsIHdlIGhhdmUgZGF0YVpvb20gZGVmaW5pdGlvbjpcbiAgICAgIC8vIFtcbiAgICAgIC8vICAgICAge3hBeGlzSW5kZXg6IDAsIHN0YXJ0OiAzMCwgZW5kOiA3MH0sXG4gICAgICAvLyAgICAgIHt5QXhpc0luZGV4OiAwLCBzdGFydDogMjAsIGVuZDogODB9XG4gICAgICAvLyBdXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIFsyMCwgODBdIG9mIHktZGF0YVpvb20gc2hvdWxkIGJlIGJhc2VkIG9uIGRhdGFcbiAgICAgIC8vIHRoYXQgaGF2ZSBmaWx0ZXJlZCBieSB4LWRhdGFab29tIHVzaW5nIHJhbmdlIG9mIFszMCwgNzBdLFxuICAgICAgLy8gYnV0IHNob3VsZCBub3QgYmUgYmFzZWQgb24gZnVsbCByYXcgZGF0YS4gVGh1cyBzbGlkaW5nXG4gICAgICAvLyB4LWRhdGFab29tIHdpbGwgY2hhbmdlIGJvdGggcmFuZ2VzIG9mIHhBeGlzIGFuZCB5QXhpcyxcbiAgICAgIC8vIHdoaWxlIHNsaWRpbmcgeS1kYXRhWm9vbSB3aWxsIG9ubHkgY2hhbmdlIHRoZSByYW5nZSBvZiB5QXhpcy5cbiAgICAgIC8vIFNvIHdlIHNob3VsZCBmaWx0ZXIgeC1heGlzIGFmdGVyIHJlc2V0IHgtYXhpcyBpbW1lZGlhdGVseSxcbiAgICAgIC8vIGFuZCB0aGVuIHJlc2V0IHktYXhpcyBhbmQgZmlsdGVyIHktYXhpcy5cbiAgICAgIGRhdGFab29tTW9kZWwuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGF4aXNEaW0sIGF4aXNJbmRleCkge1xuICAgICAgICBkYXRhWm9vbU1vZGVsLmdldEF4aXNQcm94eShheGlzRGltLCBheGlzSW5kZXgpLmZpbHRlckRhdGEoZGF0YVpvb21Nb2RlbCwgYXBpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnZGF0YVpvb20nLCBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgICAgLy8gRnVsbGZpbGwgYWxsIG9mIHRoZSByYW5nZSBwcm9wcyBzbyB0aGF0IHVzZXJcbiAgICAgIC8vIGlzIGFibGUgdG8gZ2V0IHRoZW0gZnJvbSBjaGFydC5nZXRPcHRpb24oKS5cbiAgICAgIHZhciBheGlzUHJveHkgPSBkYXRhWm9vbU1vZGVsLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuICAgICAgaWYgKGF4aXNQcm94eSkge1xuICAgICAgICB2YXIgcGVyY2VudFJhbmdlID0gYXhpc1Byb3h5LmdldERhdGFQZXJjZW50V2luZG93KCk7XG4gICAgICAgIHZhciB2YWx1ZVJhbmdlID0gYXhpc1Byb3h5LmdldERhdGFWYWx1ZVdpbmRvdygpO1xuICAgICAgICBkYXRhWm9vbU1vZGVsLnNldENhbGN1bGF0ZWRSYW5nZSh7XG4gICAgICAgICAgc3RhcnQ6IHBlcmNlbnRSYW5nZVswXSxcbiAgICAgICAgICBlbmQ6IHBlcmNlbnRSYW5nZVsxXSxcbiAgICAgICAgICBzdGFydFZhbHVlOiB2YWx1ZVJhbmdlWzBdLFxuICAgICAgICAgIGVuZFZhbHVlOiB2YWx1ZVJhbmdlWzFdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgZGF0YVpvb21Qcm9jZXNzb3I7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBmaW5kRWZmZWN0ZWREYXRhWm9vbXMgfSBmcm9tICcuL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluc3RhbGxEYXRhWm9vbUFjdGlvbihyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKCdkYXRhWm9vbScsIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgdmFyIGVmZmVjdGVkTW9kZWxzID0gZmluZEVmZmVjdGVkRGF0YVpvb21zKGVjTW9kZWwsIHBheWxvYWQpO1xuICAgIGVhY2goZWZmZWN0ZWRNb2RlbHMsIGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICBkYXRhWm9vbU1vZGVsLnNldFJhd1JhbmdlKHtcbiAgICAgICAgc3RhcnQ6IHBheWxvYWQuc3RhcnQsXG4gICAgICAgIGVuZDogcGF5bG9hZC5lbmQsXG4gICAgICAgIHN0YXJ0VmFsdWU6IHBheWxvYWQuc3RhcnRWYWx1ZSxcbiAgICAgICAgZW5kVmFsdWU6IHBheWxvYWQuZW5kVmFsdWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBkYXRhWm9vbVByb2Nlc3NvciBmcm9tICcuL2RhdGFab29tUHJvY2Vzc29yLmpzJztcbmltcG9ydCBpbnN0YWxsRGF0YVpvb21BY3Rpb24gZnJvbSAnLi9kYXRhWm9vbUFjdGlvbi5qcyc7XG52YXIgaW5zdGFsbGVkID0gZmFsc2U7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnN0YWxsQ29tbW9uKHJlZ2lzdGVycykge1xuICBpZiAoaW5zdGFsbGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGluc3RhbGxlZCA9IHRydWU7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByb2Nlc3NvcihyZWdpc3RlcnMuUFJJT1JJVFkuUFJPQ0VTU09SLkZJTFRFUiwgZGF0YVpvb21Qcm9jZXNzb3IpO1xuICBpbnN0YWxsRGF0YVpvb21BY3Rpb24ocmVnaXN0ZXJzKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlcignZGF0YVpvb20nLCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRGVmYXVsdCAnc2xpZGVyJyB3aGVuIG5vIHR5cGUgc3BlY2lmaWVkLlxuICAgIHJldHVybiAnc2xpZGVyJztcbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///33820\n")},35099:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js\nvar DataZoomModel = __webpack_require__(72012);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/component.js\nvar component = __webpack_require__(12616);\n;// ./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar SliderZoomModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(SliderZoomModel, _super);\n  function SliderZoomModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = SliderZoomModel.type;\n    return _this;\n  }\n  SliderZoomModel.type = 'dataZoom.slider';\n  SliderZoomModel.layoutMode = 'box';\n  SliderZoomModel.defaultOption = (0,component/* inheritDefaultOption */.G_)(DataZoomModel/* default */.A.defaultOption, {\n    show: true,\n    // deault value can only be drived in view stage.\n    right: 'ph',\n    top: 'ph',\n    width: 'ph',\n    height: 'ph',\n    left: null,\n    bottom: null,\n    borderColor: '#d2dbee',\n    borderRadius: 3,\n    backgroundColor: 'rgba(47,69,84,0)',\n    // dataBackgroundColor: '#ddd',\n    dataBackground: {\n      lineStyle: {\n        color: '#d2dbee',\n        width: 0.5\n      },\n      areaStyle: {\n        color: '#d2dbee',\n        opacity: 0.2\n      }\n    },\n    selectedDataBackground: {\n      lineStyle: {\n        color: '#8fb0f7',\n        width: 0.5\n      },\n      areaStyle: {\n        color: '#8fb0f7',\n        opacity: 0.2\n      }\n    },\n    // Color of selected window.\n    fillerColor: 'rgba(135,175,274,0.2)',\n    handleIcon: 'path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z',\n    // Percent of the slider height\n    handleSize: '100%',\n    handleStyle: {\n      color: '#fff',\n      borderColor: '#ACB8D1'\n    },\n    moveHandleSize: 7,\n    moveHandleIcon: 'path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z',\n    moveHandleStyle: {\n      color: '#D2DBEE',\n      opacity: 0.7\n    },\n    showDetail: true,\n    showDataShadow: 'auto',\n    realtime: true,\n    zoomLock: false,\n    textStyle: {\n      color: '#6E7079'\n    },\n    brushSelect: true,\n    brushStyle: {\n      color: 'rgba(135,175,274,0.15)'\n    },\n    emphasis: {\n      handleLabel: {\n        show: true\n      },\n      handleStyle: {\n        borderColor: '#8FB0F7'\n      },\n      moveHandleStyle: {\n        color: '#8FB0F7'\n      }\n    }\n  });\n  return SliderZoomModel;\n}(DataZoomModel/* default */.A);\n/* harmony default export */ const dataZoom_SliderZoomModel = (SliderZoomModel);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/event.js\nvar core_event = __webpack_require__(35452);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polygon.js\nvar Polygon = __webpack_require__(52505);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polyline.js\nvar Polyline = __webpack_require__(39195);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/Point.js\nvar Point = __webpack_require__(26346);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/throttle.js\nvar throttle = __webpack_require__(24711);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/DataZoomView.js\nvar DataZoomView = __webpack_require__(98248);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/sliderMove.js\nvar sliderMove = __webpack_require__(98983);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/helper.js\nvar helper = __webpack_require__(68686);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/symbol.js\nvar symbol = __webpack_require__(62103);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n;// ./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar SliderZoomView_Rect = Rect/* default */.A;\n// Constants\nvar DEFAULT_LOCATION_EDGE_GAP = 7;\nvar DEFAULT_FRAME_BORDER_WIDTH = 1;\nvar DEFAULT_FILLER_SIZE = 30;\nvar DEFAULT_MOVE_HANDLE_SIZE = 7;\nvar HORIZONTAL = 'horizontal';\nvar VERTICAL = 'vertical';\nvar LABEL_GAP = 5;\nvar SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];\nvar REALTIME_ANIMATION_CONFIG = {\n  easing: 'cubicOut',\n  duration: 100,\n  delay: 0\n};\nvar SliderZoomView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(SliderZoomView, _super);\n  function SliderZoomView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = SliderZoomView.type;\n    _this._displayables = {};\n    return _this;\n  }\n  SliderZoomView.prototype.init = function (ecModel, api) {\n    this.api = api;\n    // A unique handler for each dataZoom component\n    this._onBrush = (0,util.bind)(this._onBrush, this);\n    this._onBrushEnd = (0,util.bind)(this._onBrushEnd, this);\n  };\n  SliderZoomView.prototype.render = function (dataZoomModel, ecModel, api, payload) {\n    _super.prototype.render.apply(this, arguments);\n    throttle/* createOrUpdate */.N(this, '_dispatchZoomAction', dataZoomModel.get('throttle'), 'fixRate');\n    this._orient = dataZoomModel.getOrient();\n    if (dataZoomModel.get('show') === false) {\n      this.group.removeAll();\n      return;\n    }\n    if (dataZoomModel.noTarget()) {\n      this._clear();\n      this.group.removeAll();\n      return;\n    }\n    // Notice: this._resetInterval() should not be executed when payload.type\n    // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'\n    // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,\n    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {\n      this._buildView();\n    }\n    this._updateView();\n  };\n  SliderZoomView.prototype.dispose = function () {\n    this._clear();\n    _super.prototype.dispose.apply(this, arguments);\n  };\n  SliderZoomView.prototype._clear = function () {\n    throttle/* clear */.IU(this, '_dispatchZoomAction');\n    var zr = this.api.getZr();\n    zr.off('mousemove', this._onBrush);\n    zr.off('mouseup', this._onBrushEnd);\n  };\n  SliderZoomView.prototype._buildView = function () {\n    var thisGroup = this.group;\n    thisGroup.removeAll();\n    this._brushing = false;\n    this._displayables.brushRect = null;\n    this._resetLocation();\n    this._resetInterval();\n    var barGroup = this._displayables.sliderGroup = new Group/* default */.A();\n    this._renderBackground();\n    this._renderHandle();\n    this._renderDataShadow();\n    thisGroup.add(barGroup);\n    this._positionGroup();\n  };\n  SliderZoomView.prototype._resetLocation = function () {\n    var dataZoomModel = this.dataZoomModel;\n    var api = this.api;\n    var showMoveHandle = dataZoomModel.get('brushSelect');\n    var moveHandleSize = showMoveHandle ? DEFAULT_MOVE_HANDLE_SIZE : 0;\n    // If some of x/y/width/height are not specified,\n    // auto-adapt according to target grid.\n    var coordRect = this._findCoordRect();\n    var ecSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    // Default align by coordinate system rect.\n    var positionInfo = this._orient === HORIZONTAL ? {\n      // Why using 'right', because right should be used in vertical,\n      // and it is better to be consistent for dealing with position param merge.\n      right: ecSize.width - coordRect.x - coordRect.width,\n      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - moveHandleSize,\n      width: coordRect.width,\n      height: DEFAULT_FILLER_SIZE\n    } : {\n      right: DEFAULT_LOCATION_EDGE_GAP,\n      top: coordRect.y,\n      width: DEFAULT_FILLER_SIZE,\n      height: coordRect.height\n    };\n    // Do not write back to option and replace value 'ph', because\n    // the 'ph' value should be recalculated when resize.\n    var layoutParams = layout/* getLayoutParams */.vs(dataZoomModel.option);\n    // Replace the placeholder value.\n    (0,util.each)(['right', 'top', 'width', 'height'], function (name) {\n      if (layoutParams[name] === 'ph') {\n        layoutParams[name] = positionInfo[name];\n      }\n    });\n    var layoutRect = layout/* getLayoutRect */.dV(layoutParams, ecSize);\n    this._location = {\n      x: layoutRect.x,\n      y: layoutRect.y\n    };\n    this._size = [layoutRect.width, layoutRect.height];\n    this._orient === VERTICAL && this._size.reverse();\n  };\n  SliderZoomView.prototype._positionGroup = function () {\n    var thisGroup = this.group;\n    var location = this._location;\n    var orient = this._orient;\n    // Just use the first axis to determine mapping.\n    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();\n    var inverse = targetAxisModel && targetAxisModel.get('inverse');\n    var sliderGroup = this._displayables.sliderGroup;\n    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;\n    // Transform barGroup.\n    sliderGroup.attr(orient === HORIZONTAL && !inverse ? {\n      scaleY: otherAxisInverse ? 1 : -1,\n      scaleX: 1\n    } : orient === HORIZONTAL && inverse ? {\n      scaleY: otherAxisInverse ? 1 : -1,\n      scaleX: -1\n    } : orient === VERTICAL && !inverse ? {\n      scaleY: otherAxisInverse ? -1 : 1,\n      scaleX: 1,\n      rotation: Math.PI / 2\n    }\n    // Don't use Math.PI, considering shadow direction.\n    : {\n      scaleY: otherAxisInverse ? -1 : 1,\n      scaleX: -1,\n      rotation: Math.PI / 2\n    });\n    // Position barGroup\n    var rect = thisGroup.getBoundingRect([sliderGroup]);\n    thisGroup.x = location.x - rect.x;\n    thisGroup.y = location.y - rect.y;\n    thisGroup.markRedraw();\n  };\n  SliderZoomView.prototype._getViewExtent = function () {\n    return [0, this._size[0]];\n  };\n  SliderZoomView.prototype._renderBackground = function () {\n    var dataZoomModel = this.dataZoomModel;\n    var size = this._size;\n    var barGroup = this._displayables.sliderGroup;\n    var brushSelect = dataZoomModel.get('brushSelect');\n    barGroup.add(new SliderZoomView_Rect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: dataZoomModel.get('backgroundColor')\n      },\n      z2: -40\n    }));\n    // Click panel, over shadow, below handles.\n    var clickPanel = new SliderZoomView_Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: 'transparent'\n      },\n      z2: 0,\n      onclick: (0,util.bind)(this._onClickPanel, this)\n    });\n    var zr = this.api.getZr();\n    if (brushSelect) {\n      clickPanel.on('mousedown', this._onBrushStart, this);\n      clickPanel.cursor = 'crosshair';\n      zr.on('mousemove', this._onBrush);\n      zr.on('mouseup', this._onBrushEnd);\n    } else {\n      zr.off('mousemove', this._onBrush);\n      zr.off('mouseup', this._onBrushEnd);\n    }\n    barGroup.add(clickPanel);\n  };\n  SliderZoomView.prototype._renderDataShadow = function () {\n    var info = this._dataShadowInfo = this._prepareDataShadowInfo();\n    this._displayables.dataShadowSegs = [];\n    if (!info) {\n      return;\n    }\n    var size = this._size;\n    var oldSize = this._shadowSize || [];\n    var seriesModel = info.series;\n    var data = seriesModel.getRawData();\n    var candlestickDim = seriesModel.getShadowDim && seriesModel.getShadowDim();\n    var otherDim = candlestickDim && data.getDimensionInfo(candlestickDim) ? seriesModel.getShadowDim() // @see candlestick\n    : info.otherDim;\n    if (otherDim == null) {\n      return;\n    }\n    var polygonPts = this._shadowPolygonPts;\n    var polylinePts = this._shadowPolylinePts;\n    // Not re-render if data doesn't change.\n    if (data !== this._shadowData || otherDim !== this._shadowDim || size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n      var otherDataExtent_1 = data.getDataExtent(otherDim);\n      // Nice extent.\n      var otherOffset = (otherDataExtent_1[1] - otherDataExtent_1[0]) * 0.3;\n      otherDataExtent_1 = [otherDataExtent_1[0] - otherOffset, otherDataExtent_1[1] + otherOffset];\n      var otherShadowExtent_1 = [0, size[1]];\n      var thisShadowExtent = [0, size[0]];\n      var areaPoints_1 = [[size[0], 0], [0, 0]];\n      var linePoints_1 = [];\n      var step_1 = thisShadowExtent[1] / (data.count() - 1);\n      var thisCoord_1 = 0;\n      // Optimize for large data shadow\n      var stride_1 = Math.round(data.count() / size[0]);\n      var lastIsEmpty_1;\n      data.each([otherDim], function (value, index) {\n        if (stride_1 > 0 && index % stride_1) {\n          thisCoord_1 += step_1;\n          return;\n        }\n        // FIXME\n        // Should consider axis.min/axis.max when drawing dataShadow.\n        // FIXME\n        // 应该使用统一的空判断？还是在list里进行空判断？\n        var isEmpty = value == null || isNaN(value) || value === '';\n        // See #4235.\n        var otherCoord = isEmpty ? 0 : (0,number/* linearMap */.Cb)(value, otherDataExtent_1, otherShadowExtent_1, true);\n        // Attempt to draw data shadow precisely when there are empty value.\n        if (isEmpty && !lastIsEmpty_1 && index) {\n          areaPoints_1.push([areaPoints_1[areaPoints_1.length - 1][0], 0]);\n          linePoints_1.push([linePoints_1[linePoints_1.length - 1][0], 0]);\n        } else if (!isEmpty && lastIsEmpty_1) {\n          areaPoints_1.push([thisCoord_1, 0]);\n          linePoints_1.push([thisCoord_1, 0]);\n        }\n        areaPoints_1.push([thisCoord_1, otherCoord]);\n        linePoints_1.push([thisCoord_1, otherCoord]);\n        thisCoord_1 += step_1;\n        lastIsEmpty_1 = isEmpty;\n      });\n      polygonPts = this._shadowPolygonPts = areaPoints_1;\n      polylinePts = this._shadowPolylinePts = linePoints_1;\n    }\n    this._shadowData = data;\n    this._shadowDim = otherDim;\n    this._shadowSize = [size[0], size[1]];\n    var dataZoomModel = this.dataZoomModel;\n    function createDataShadowGroup(isSelectedArea) {\n      var model = dataZoomModel.getModel(isSelectedArea ? 'selectedDataBackground' : 'dataBackground');\n      var group = new Group/* default */.A();\n      var polygon = new Polygon/* default */.A({\n        shape: {\n          points: polygonPts\n        },\n        segmentIgnoreThreshold: 1,\n        style: model.getModel('areaStyle').getAreaStyle(),\n        silent: true,\n        z2: -20\n      });\n      var polyline = new Polyline/* default */.A({\n        shape: {\n          points: polylinePts\n        },\n        segmentIgnoreThreshold: 1,\n        style: model.getModel('lineStyle').getLineStyle(),\n        silent: true,\n        z2: -19\n      });\n      group.add(polygon);\n      group.add(polyline);\n      return group;\n    }\n    // let dataBackgroundModel = dataZoomModel.getModel('dataBackground');\n    for (var i = 0; i < 3; i++) {\n      var group = createDataShadowGroup(i === 1);\n      this._displayables.sliderGroup.add(group);\n      this._displayables.dataShadowSegs.push(group);\n    }\n  };\n  SliderZoomView.prototype._prepareDataShadowInfo = function () {\n    var dataZoomModel = this.dataZoomModel;\n    var showDataShadow = dataZoomModel.get('showDataShadow');\n    if (showDataShadow === false) {\n      return;\n    }\n    // Find a representative series.\n    var result;\n    var ecModel = this.ecModel;\n    dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n      var seriesModels = dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels();\n      (0,util.each)(seriesModels, function (seriesModel) {\n        if (result) {\n          return;\n        }\n        if (showDataShadow !== true && (0,util.indexOf)(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {\n          return;\n        }\n        var thisAxis = ecModel.getComponent((0,helper/* getAxisMainType */.dX)(axisDim), axisIndex).axis;\n        var otherDim = getOtherDim(axisDim);\n        var otherAxisInverse;\n        var coordSys = seriesModel.coordinateSystem;\n        if (otherDim != null && coordSys.getOtherAxis) {\n          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;\n        }\n        otherDim = seriesModel.getData().mapDimension(otherDim);\n        result = {\n          thisAxis: thisAxis,\n          series: seriesModel,\n          thisDim: axisDim,\n          otherDim: otherDim,\n          otherAxisInverse: otherAxisInverse\n        };\n      }, this);\n    }, this);\n    return result;\n  };\n  SliderZoomView.prototype._renderHandle = function () {\n    var thisGroup = this.group;\n    var displayables = this._displayables;\n    var handles = displayables.handles = [null, null];\n    var handleLabels = displayables.handleLabels = [null, null];\n    var sliderGroup = this._displayables.sliderGroup;\n    var size = this._size;\n    var dataZoomModel = this.dataZoomModel;\n    var api = this.api;\n    var borderRadius = dataZoomModel.get('borderRadius') || 0;\n    var brushSelect = dataZoomModel.get('brushSelect');\n    var filler = displayables.filler = new SliderZoomView_Rect({\n      silent: brushSelect,\n      style: {\n        fill: dataZoomModel.get('fillerColor')\n      },\n      textConfig: {\n        position: 'inside'\n      }\n    });\n    sliderGroup.add(filler);\n    // Frame border.\n    sliderGroup.add(new SliderZoomView_Rect({\n      silent: true,\n      subPixelOptimize: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1],\n        r: borderRadius\n      },\n      style: {\n        // deprecated option\n        stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),\n        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,\n        fill: 'rgba(0,0,0,0)'\n      }\n    }));\n    // Left and right handle to resize\n    (0,util.each)([0, 1], function (handleIndex) {\n      var iconStr = dataZoomModel.get('handleIcon');\n      if (!symbol/* symbolBuildProxies */.$V[iconStr] && iconStr.indexOf('path://') < 0 && iconStr.indexOf('image://') < 0) {\n        // Compatitable with the old icon parsers. Which can use a path string without path://\n        iconStr = 'path://' + iconStr;\n        if (false) {}\n      }\n      var path = (0,symbol/* createSymbol */.v5)(iconStr, -1, 0, 2, 2, null, true);\n      path.attr({\n        cursor: getCursor(this._orient),\n        draggable: true,\n        drift: (0,util.bind)(this._onDragMove, this, handleIndex),\n        ondragend: (0,util.bind)(this._onDragEnd, this),\n        onmouseover: (0,util.bind)(this._showDataInfo, this, true),\n        onmouseout: (0,util.bind)(this._showDataInfo, this, false),\n        z2: 5\n      });\n      var bRect = path.getBoundingRect();\n      var handleSize = dataZoomModel.get('handleSize');\n      this._handleHeight = (0,number/* parsePercent */.lo)(handleSize, this._size[1]);\n      this._handleWidth = bRect.width / bRect.height * this._handleHeight;\n      path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());\n      path.style.strokeNoScale = true;\n      path.rectHover = true;\n      path.ensureState('emphasis').style = dataZoomModel.getModel(['emphasis', 'handleStyle']).getItemStyle();\n      (0,states/* enableHoverEmphasis */.iJ)(path);\n      var handleColor = dataZoomModel.get('handleColor'); // deprecated option\n      // Compatitable with previous version\n      if (handleColor != null) {\n        path.style.fill = handleColor;\n      }\n      sliderGroup.add(handles[handleIndex] = path);\n      var textStyleModel = dataZoomModel.getModel('textStyle');\n      var handleLabel = dataZoomModel.get('handleLabel') || {};\n      var handleLabelShow = handleLabel.show || false;\n      thisGroup.add(handleLabels[handleIndex] = new Text/* default */.Ay({\n        silent: true,\n        invisible: !handleLabelShow,\n        style: (0,labelStyle/* createTextStyle */.VB)(textStyleModel, {\n          x: 0,\n          y: 0,\n          text: '',\n          verticalAlign: 'middle',\n          align: 'center',\n          fill: textStyleModel.getTextColor(),\n          font: textStyleModel.getFont()\n        }),\n        z2: 10\n      }));\n    }, this);\n    // Handle to move. Only visible when brushSelect is set true.\n    var actualMoveZone = filler;\n    if (brushSelect) {\n      var moveHandleHeight = (0,number/* parsePercent */.lo)(dataZoomModel.get('moveHandleSize'), size[1]);\n      var moveHandle_1 = displayables.moveHandle = new Rect/* default */.A({\n        style: dataZoomModel.getModel('moveHandleStyle').getItemStyle(),\n        silent: true,\n        shape: {\n          r: [0, 0, 2, 2],\n          y: size[1] - 0.5,\n          height: moveHandleHeight\n        }\n      });\n      var iconSize = moveHandleHeight * 0.8;\n      var moveHandleIcon = displayables.moveHandleIcon = (0,symbol/* createSymbol */.v5)(dataZoomModel.get('moveHandleIcon'), -iconSize / 2, -iconSize / 2, iconSize, iconSize, '#fff', true);\n      moveHandleIcon.silent = true;\n      moveHandleIcon.y = size[1] + moveHandleHeight / 2 - 0.5;\n      moveHandle_1.ensureState('emphasis').style = dataZoomModel.getModel(['emphasis', 'moveHandleStyle']).getItemStyle();\n      var moveZoneExpandSize = Math.min(size[1] / 2, Math.max(moveHandleHeight, 10));\n      actualMoveZone = displayables.moveZone = new Rect/* default */.A({\n        invisible: true,\n        shape: {\n          y: size[1] - moveZoneExpandSize,\n          height: moveHandleHeight + moveZoneExpandSize\n        }\n      });\n      actualMoveZone.on('mouseover', function () {\n        api.enterEmphasis(moveHandle_1);\n      }).on('mouseout', function () {\n        api.leaveEmphasis(moveHandle_1);\n      });\n      sliderGroup.add(moveHandle_1);\n      sliderGroup.add(moveHandleIcon);\n      sliderGroup.add(actualMoveZone);\n    }\n    actualMoveZone.attr({\n      draggable: true,\n      cursor: getCursor(this._orient),\n      drift: (0,util.bind)(this._onDragMove, this, 'all'),\n      ondragstart: (0,util.bind)(this._showDataInfo, this, true),\n      ondragend: (0,util.bind)(this._onDragEnd, this),\n      onmouseover: (0,util.bind)(this._showDataInfo, this, true),\n      onmouseout: (0,util.bind)(this._showDataInfo, this, false)\n    });\n  };\n  SliderZoomView.prototype._resetInterval = function () {\n    var range = this._range = this.dataZoomModel.getPercentRange();\n    var viewExtent = this._getViewExtent();\n    this._handleEnds = [(0,number/* linearMap */.Cb)(range[0], [0, 100], viewExtent, true), (0,number/* linearMap */.Cb)(range[1], [0, 100], viewExtent, true)];\n  };\n  SliderZoomView.prototype._updateInterval = function (handleIndex, delta) {\n    var dataZoomModel = this.dataZoomModel;\n    var handleEnds = this._handleEnds;\n    var viewExtend = this._getViewExtent();\n    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    var percentExtent = [0, 100];\n    (0,sliderMove/* default */.A)(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? (0,number/* linearMap */.Cb)(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? (0,number/* linearMap */.Cb)(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);\n    var lastRange = this._range;\n    var range = this._range = (0,number/* asc */.Y6)([(0,number/* linearMap */.Cb)(handleEnds[0], viewExtend, percentExtent, true), (0,number/* linearMap */.Cb)(handleEnds[1], viewExtend, percentExtent, true)]);\n    return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];\n  };\n  SliderZoomView.prototype._updateView = function (nonRealtime) {\n    var displaybles = this._displayables;\n    var handleEnds = this._handleEnds;\n    var handleInterval = (0,number/* asc */.Y6)(handleEnds.slice());\n    var size = this._size;\n    (0,util.each)([0, 1], function (handleIndex) {\n      // Handles\n      var handle = displaybles.handles[handleIndex];\n      var handleHeight = this._handleHeight;\n      handle.attr({\n        scaleX: handleHeight / 2,\n        scaleY: handleHeight / 2,\n        // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.\n        // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.\n        x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),\n        y: size[1] / 2 - handleHeight / 2\n      });\n    }, this);\n    // Filler\n    displaybles.filler.setShape({\n      x: handleInterval[0],\n      y: 0,\n      width: handleInterval[1] - handleInterval[0],\n      height: size[1]\n    });\n    var viewExtent = {\n      x: handleInterval[0],\n      width: handleInterval[1] - handleInterval[0]\n    };\n    // Move handle\n    if (displaybles.moveHandle) {\n      displaybles.moveHandle.setShape(viewExtent);\n      displaybles.moveZone.setShape(viewExtent);\n      // Force update path on the invisible object\n      displaybles.moveZone.getBoundingRect();\n      displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr('x', viewExtent.x + viewExtent.width / 2);\n    }\n    // update clip path of shadow.\n    var dataShadowSegs = displaybles.dataShadowSegs;\n    var segIntervals = [0, handleInterval[0], handleInterval[1], size[0]];\n    for (var i = 0; i < dataShadowSegs.length; i++) {\n      var segGroup = dataShadowSegs[i];\n      var clipPath = segGroup.getClipPath();\n      if (!clipPath) {\n        clipPath = new Rect/* default */.A();\n        segGroup.setClipPath(clipPath);\n      }\n      clipPath.setShape({\n        x: segIntervals[i],\n        y: 0,\n        width: segIntervals[i + 1] - segIntervals[i],\n        height: size[1]\n      });\n    }\n    this._updateDataInfo(nonRealtime);\n  };\n  SliderZoomView.prototype._updateDataInfo = function (nonRealtime) {\n    var dataZoomModel = this.dataZoomModel;\n    var displaybles = this._displayables;\n    var handleLabels = displaybles.handleLabels;\n    var orient = this._orient;\n    var labelTexts = ['', ''];\n    // FIXME\n    // date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）\n    if (dataZoomModel.get('showDetail')) {\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n      if (axisProxy) {\n        var axis = axisProxy.getAxisModel().axis;\n        var range = this._range;\n        var dataInterval = nonRealtime\n        // See #4434, data and axis are not processed and reset yet in non-realtime mode.\n        ? axisProxy.calculateDataWindow({\n          start: range[0],\n          end: range[1]\n        }).valueWindow : axisProxy.getDataValueWindow();\n        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];\n      }\n    }\n    var orderedHandleEnds = (0,number/* asc */.Y6)(this._handleEnds.slice());\n    setLabel.call(this, 0);\n    setLabel.call(this, 1);\n    function setLabel(handleIndex) {\n      // Label\n      // Text should not transform by barGroup.\n      // Ignore handlers transform\n      var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);\n      var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);\n      var offset = this._handleWidth / 2 + LABEL_GAP;\n      var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);\n      handleLabels[handleIndex].setStyle({\n        x: textPoint[0],\n        y: textPoint[1],\n        verticalAlign: orient === HORIZONTAL ? 'middle' : direction,\n        align: orient === HORIZONTAL ? direction : 'center',\n        text: labelTexts[handleIndex]\n      });\n    }\n  };\n  SliderZoomView.prototype._formatLabel = function (value, axis) {\n    var dataZoomModel = this.dataZoomModel;\n    var labelFormatter = dataZoomModel.get('labelFormatter');\n    var labelPrecision = dataZoomModel.get('labelPrecision');\n    if (labelPrecision == null || labelPrecision === 'auto') {\n      labelPrecision = axis.getPixelPrecision();\n    }\n    var valueStr = value == null || isNaN(value) ? ''\n    // FIXME Glue code\n    : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel({\n      value: Math.round(value)\n    })\n    // param of toFixed should less then 20.\n    : value.toFixed(Math.min(labelPrecision, 20));\n    return (0,util.isFunction)(labelFormatter) ? labelFormatter(value, valueStr) : (0,util.isString)(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;\n  };\n  /**\r\n   * @param isEmphasis true: show, false: hide\r\n   */\n  SliderZoomView.prototype._showDataInfo = function (isEmphasis) {\n    var handleLabel = this.dataZoomModel.get('handleLabel') || {};\n    var normalShow = handleLabel.show || false;\n    var emphasisHandleLabel = this.dataZoomModel.getModel(['emphasis', 'handleLabel']);\n    var emphasisShow = emphasisHandleLabel.get('show') || false;\n    // Dragging is considered as emphasis, unless emphasisShow is false\n    var toShow = isEmphasis || this._dragging ? emphasisShow : normalShow;\n    var displayables = this._displayables;\n    var handleLabels = displayables.handleLabels;\n    handleLabels[0].attr('invisible', !toShow);\n    handleLabels[1].attr('invisible', !toShow);\n    // Highlight move handle\n    displayables.moveHandle && this.api[toShow ? 'enterEmphasis' : 'leaveEmphasis'](displayables.moveHandle, 1);\n  };\n  SliderZoomView.prototype._onDragMove = function (handleIndex, dx, dy, event) {\n    this._dragging = true;\n    // For mobile device, prevent screen slider on the button.\n    core_event/* stop */.ds(event.event);\n    // Transform dx, dy to bar coordination.\n    var barTransform = this._displayables.sliderGroup.getLocalTransform();\n    var vertex = graphic.applyTransform([dx, dy], barTransform, true);\n    var changed = this._updateInterval(handleIndex, vertex[0]);\n    var realtime = this.dataZoomModel.get('realtime');\n    this._updateView(!realtime);\n    // Avoid dispatch dataZoom repeatly but range not changed,\n    // which cause bad visual effect when progressive enabled.\n    changed && realtime && this._dispatchZoomAction(true);\n  };\n  SliderZoomView.prototype._onDragEnd = function () {\n    this._dragging = false;\n    this._showDataInfo(false);\n    // While in realtime mode and stream mode, dispatch action when\n    // drag end will cause the whole view rerender, which is unnecessary.\n    var realtime = this.dataZoomModel.get('realtime');\n    !realtime && this._dispatchZoomAction(false);\n  };\n  SliderZoomView.prototype._onClickPanel = function (e) {\n    var size = this._size;\n    var localPoint = this._displayables.sliderGroup.transformCoordToLocal(e.offsetX, e.offsetY);\n    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {\n      return;\n    }\n    var handleEnds = this._handleEnds;\n    var center = (handleEnds[0] + handleEnds[1]) / 2;\n    var changed = this._updateInterval('all', localPoint[0] - center);\n    this._updateView();\n    changed && this._dispatchZoomAction(false);\n  };\n  SliderZoomView.prototype._onBrushStart = function (e) {\n    var x = e.offsetX;\n    var y = e.offsetY;\n    this._brushStart = new Point/* default */.A(x, y);\n    this._brushing = true;\n    this._brushStartTime = +new Date();\n    // this._updateBrushRect(x, y);\n  };\n  SliderZoomView.prototype._onBrushEnd = function (e) {\n    if (!this._brushing) {\n      return;\n    }\n    var brushRect = this._displayables.brushRect;\n    this._brushing = false;\n    if (!brushRect) {\n      return;\n    }\n    brushRect.attr('ignore', true);\n    var brushShape = brushRect.shape;\n    var brushEndTime = +new Date();\n    // console.log(brushEndTime - this._brushStartTime);\n    if (brushEndTime - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) {\n      // Will treat it as a click\n      return;\n    }\n    var viewExtend = this._getViewExtent();\n    var percentExtent = [0, 100];\n    this._range = (0,number/* asc */.Y6)([(0,number/* linearMap */.Cb)(brushShape.x, viewExtend, percentExtent, true), (0,number/* linearMap */.Cb)(brushShape.x + brushShape.width, viewExtend, percentExtent, true)]);\n    this._handleEnds = [brushShape.x, brushShape.x + brushShape.width];\n    this._updateView();\n    this._dispatchZoomAction(false);\n  };\n  SliderZoomView.prototype._onBrush = function (e) {\n    if (this._brushing) {\n      // For mobile device, prevent screen slider on the button.\n      core_event/* stop */.ds(e.event);\n      this._updateBrushRect(e.offsetX, e.offsetY);\n    }\n  };\n  SliderZoomView.prototype._updateBrushRect = function (mouseX, mouseY) {\n    var displayables = this._displayables;\n    var dataZoomModel = this.dataZoomModel;\n    var brushRect = displayables.brushRect;\n    if (!brushRect) {\n      brushRect = displayables.brushRect = new SliderZoomView_Rect({\n        silent: true,\n        style: dataZoomModel.getModel('brushStyle').getItemStyle()\n      });\n      displayables.sliderGroup.add(brushRect);\n    }\n    brushRect.attr('ignore', false);\n    var brushStart = this._brushStart;\n    var sliderGroup = this._displayables.sliderGroup;\n    var endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY);\n    var startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y);\n    var size = this._size;\n    endPoint[0] = Math.max(Math.min(size[0], endPoint[0]), 0);\n    brushRect.setShape({\n      x: startPoint[0],\n      y: 0,\n      width: endPoint[0] - startPoint[0],\n      height: size[1]\n    });\n  };\n  /**\r\n   * This action will be throttled.\r\n   */\n  SliderZoomView.prototype._dispatchZoomAction = function (realtime) {\n    var range = this._range;\n    this.api.dispatchAction({\n      type: 'dataZoom',\n      from: this.uid,\n      dataZoomId: this.dataZoomModel.id,\n      animation: realtime ? REALTIME_ANIMATION_CONFIG : null,\n      start: range[0],\n      end: range[1]\n    });\n  };\n  SliderZoomView.prototype._findCoordRect = function () {\n    // Find the grid corresponding to the first axis referred by dataZoom.\n    var rect;\n    var coordSysInfoList = (0,helper/* collectReferCoordSysModelInfo */.es)(this.dataZoomModel).infoList;\n    if (!rect && coordSysInfoList.length) {\n      var coordSys = coordSysInfoList[0].model.coordinateSystem;\n      rect = coordSys.getRect && coordSys.getRect();\n    }\n    if (!rect) {\n      var width = this.api.getWidth();\n      var height = this.api.getHeight();\n      rect = {\n        x: width * 0.2,\n        y: height * 0.2,\n        width: width * 0.6,\n        height: height * 0.6\n      };\n    }\n    return rect;\n  };\n  SliderZoomView.type = 'dataZoom.slider';\n  return SliderZoomView;\n}(DataZoomView/* default */.A);\nfunction getOtherDim(thisDim) {\n  // FIXME\n  // 这个逻辑和getOtherAxis里一致，但是写在这里是否不好\n  var map = {\n    x: 'y',\n    y: 'x',\n    radius: 'angle',\n    angle: 'radius'\n  };\n  return map[thisDim];\n}\nfunction getCursor(orient) {\n  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';\n}\n/* harmony default export */ const dataZoom_SliderZoomView = (SliderZoomView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/installCommon.js + 3 modules\nvar installCommon = __webpack_require__(33820);\n;// ./node_modules/echarts/lib/component/dataZoom/installDataZoomSlider.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction install(registers) {\n  registers.registerComponentModel(dataZoom_SliderZoomModel);\n  registers.registerComponentView(dataZoom_SliderZoomView);\n  (0,installCommon/* default */.A)(registers);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUwOTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2xpZGVyWm9vbU1vZGVsLmpzP2I2ZmUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TbGlkZXJab29tVmlldy5qcz8wODczIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaW5zdGFsbERhdGFab29tU2xpZGVyLmpzPzdjMGQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBEYXRhWm9vbU1vZGVsIGZyb20gJy4vRGF0YVpvb21Nb2RlbC5qcyc7XG5pbXBvcnQgeyBpbmhlcml0RGVmYXVsdE9wdGlvbiB9IGZyb20gJy4uLy4uL3V0aWwvY29tcG9uZW50LmpzJztcbnZhciBTbGlkZXJab29tTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2xpZGVyWm9vbU1vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBTbGlkZXJab29tTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IFNsaWRlclpvb21Nb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBTbGlkZXJab29tTW9kZWwudHlwZSA9ICdkYXRhWm9vbS5zbGlkZXInO1xuICBTbGlkZXJab29tTW9kZWwubGF5b3V0TW9kZSA9ICdib3gnO1xuICBTbGlkZXJab29tTW9kZWwuZGVmYXVsdE9wdGlvbiA9IGluaGVyaXREZWZhdWx0T3B0aW9uKERhdGFab29tTW9kZWwuZGVmYXVsdE9wdGlvbiwge1xuICAgIHNob3c6IHRydWUsXG4gICAgLy8gZGVhdWx0IHZhbHVlIGNhbiBvbmx5IGJlIGRyaXZlZCBpbiB2aWV3IHN0YWdlLlxuICAgIHJpZ2h0OiAncGgnLFxuICAgIHRvcDogJ3BoJyxcbiAgICB3aWR0aDogJ3BoJyxcbiAgICBoZWlnaHQ6ICdwaCcsXG4gICAgbGVmdDogbnVsbCxcbiAgICBib3R0b206IG51bGwsXG4gICAgYm9yZGVyQ29sb3I6ICcjZDJkYmVlJyxcbiAgICBib3JkZXJSYWRpdXM6IDMsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSg0Nyw2OSw4NCwwKScsXG4gICAgLy8gZGF0YUJhY2tncm91bmRDb2xvcjogJyNkZGQnLFxuICAgIGRhdGFCYWNrZ3JvdW5kOiB7XG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgY29sb3I6ICcjZDJkYmVlJyxcbiAgICAgICAgd2lkdGg6IDAuNVxuICAgICAgfSxcbiAgICAgIGFyZWFTdHlsZToge1xuICAgICAgICBjb2xvcjogJyNkMmRiZWUnLFxuICAgICAgICBvcGFjaXR5OiAwLjJcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdGVkRGF0YUJhY2tncm91bmQ6IHtcbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBjb2xvcjogJyM4ZmIwZjcnLFxuICAgICAgICB3aWR0aDogMC41XG4gICAgICB9LFxuICAgICAgYXJlYVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzhmYjBmNycsXG4gICAgICAgIG9wYWNpdHk6IDAuMlxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQ29sb3Igb2Ygc2VsZWN0ZWQgd2luZG93LlxuICAgIGZpbGxlckNvbG9yOiAncmdiYSgxMzUsMTc1LDI3NCwwLjIpJyxcbiAgICBoYW5kbGVJY29uOiAncGF0aDovL00tOS4zNSwzNC41NlY0Mm0wLTQwVjkuNW0tMiwwaDRhMiwyLDAsMCwxLDIsMnYyMWEyLDIsMCwwLDEtMiwyaC00YTIsMiwwLDAsMS0yLTJ2LTIxQTIsMiwwLDAsMS0xMS4zNSw5LjVaJyxcbiAgICAvLyBQZXJjZW50IG9mIHRoZSBzbGlkZXIgaGVpZ2h0XG4gICAgaGFuZGxlU2l6ZTogJzEwMCUnLFxuICAgIGhhbmRsZVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgYm9yZGVyQ29sb3I6ICcjQUNCOEQxJ1xuICAgIH0sXG4gICAgbW92ZUhhbmRsZVNpemU6IDcsXG4gICAgbW92ZUhhbmRsZUljb246ICdwYXRoOi8vTS0zMjAuOS01MEwtMzIwLjktNTBjMTguMSwwLDI3LjEsOSwyNy4xLDI3LjFWODUuN2MwLDE4LjEtOSwyNy4xLTI3LjEsMjcuMWwwLDBjLTE4LjEsMC0yNy4xLTktMjcuMS0yNy4xVi0yMi45Qy0zNDgtNDEtMzM5LTUwLTMyMC45LTUweiBNLTIxMi4zLTUwTC0yMTIuMy01MGMxOC4xLDAsMjcuMSw5LDI3LjEsMjcuMVY4NS43YzAsMTguMS05LDI3LjEtMjcuMSwyNy4xbDAsMGMtMTguMSwwLTI3LjEtOS0yNy4xLTI3LjFWLTIyLjlDLTIzOS40LTQxLTIzMC40LTUwLTIxMi4zLTUweiBNLTEwMy43LTUwTC0xMDMuNy01MGMxOC4xLDAsMjcuMSw5LDI3LjEsMjcuMVY4NS43YzAsMTguMS05LDI3LjEtMjcuMSwyNy4xbDAsMGMtMTguMSwwLTI3LjEtOS0yNy4xLTI3LjFWLTIyLjlDLTEzMC45LTQxLTEyMS44LTUwLTEwMy43LTUweicsXG4gICAgbW92ZUhhbmRsZVN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNEMkRCRUUnLFxuICAgICAgb3BhY2l0eTogMC43XG4gICAgfSxcbiAgICBzaG93RGV0YWlsOiB0cnVlLFxuICAgIHNob3dEYXRhU2hhZG93OiAnYXV0bycsXG4gICAgcmVhbHRpbWU6IHRydWUsXG4gICAgem9vbUxvY2s6IGZhbHNlLFxuICAgIHRleHRTdHlsZToge1xuICAgICAgY29sb3I6ICcjNkU3MDc5J1xuICAgIH0sXG4gICAgYnJ1c2hTZWxlY3Q6IHRydWUsXG4gICAgYnJ1c2hTdHlsZToge1xuICAgICAgY29sb3I6ICdyZ2JhKDEzNSwxNzUsMjc0LDAuMTUpJ1xuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIGhhbmRsZUxhYmVsOiB7XG4gICAgICAgIHNob3c6IHRydWVcbiAgICAgIH0sXG4gICAgICBoYW5kbGVTdHlsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyM4RkIwRjcnXG4gICAgICB9LFxuICAgICAgbW92ZUhhbmRsZVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAnIzhGQjBGNydcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gU2xpZGVyWm9vbU1vZGVsO1xufShEYXRhWm9vbU1vZGVsKTtcbmV4cG9ydCBkZWZhdWx0IFNsaWRlclpvb21Nb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgYmluZCwgZWFjaCwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGluZGV4T2YgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgZXZlbnRUb29sIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0ICogYXMgdGhyb3R0bGUgZnJvbSAnLi4vLi4vdXRpbC90aHJvdHRsZS5qcyc7XG5pbXBvcnQgRGF0YVpvb21WaWV3IGZyb20gJy4vRGF0YVpvb21WaWV3LmpzJztcbmltcG9ydCB7IGxpbmVhck1hcCwgYXNjLCBwYXJzZVBlcmNlbnQgfSBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7XG5pbXBvcnQgKiBhcyBsYXlvdXQgZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQuanMnO1xuaW1wb3J0IHNsaWRlck1vdmUgZnJvbSAnLi4vaGVscGVyL3NsaWRlck1vdmUuanMnO1xuaW1wb3J0IHsgZ2V0QXhpc01haW5UeXBlLCBjb2xsZWN0UmVmZXJDb29yZFN5c01vZGVsSW5mbyB9IGZyb20gJy4vaGVscGVyLmpzJztcbmltcG9ydCB7IGVuYWJsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTeW1ib2wsIHN5bWJvbEJ1aWxkUHJveGllcyB9IGZyb20gJy4uLy4uL3V0aWwvc3ltYm9sLmpzJztcbmltcG9ydCB7IGRlcHJlY2F0ZUxvZyB9IGZyb20gJy4uLy4uL3V0aWwvbG9nLmpzJztcbmltcG9ydCB7IGNyZWF0ZVRleHRTdHlsZSB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUuanMnO1xudmFyIFJlY3QgPSBncmFwaGljLlJlY3Q7XG4vLyBDb25zdGFudHNcbnZhciBERUZBVUxUX0xPQ0FUSU9OX0VER0VfR0FQID0gNztcbnZhciBERUZBVUxUX0ZSQU1FX0JPUkRFUl9XSURUSCA9IDE7XG52YXIgREVGQVVMVF9GSUxMRVJfU0laRSA9IDMwO1xudmFyIERFRkFVTFRfTU9WRV9IQU5ETEVfU0laRSA9IDc7XG52YXIgSE9SSVpPTlRBTCA9ICdob3Jpem9udGFsJztcbnZhciBWRVJUSUNBTCA9ICd2ZXJ0aWNhbCc7XG52YXIgTEFCRUxfR0FQID0gNTtcbnZhciBTSE9XX0RBVEFfU0hBRE9XX1NFUklFU19UWVBFID0gWydsaW5lJywgJ2JhcicsICdjYW5kbGVzdGljaycsICdzY2F0dGVyJ107XG52YXIgUkVBTFRJTUVfQU5JTUFUSU9OX0NPTkZJRyA9IHtcbiAgZWFzaW5nOiAnY3ViaWNPdXQnLFxuICBkdXJhdGlvbjogMTAwLFxuICBkZWxheTogMFxufTtcbnZhciBTbGlkZXJab29tVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTbGlkZXJab29tVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gU2xpZGVyWm9vbVZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IFNsaWRlclpvb21WaWV3LnR5cGU7XG4gICAgX3RoaXMuX2Rpc3BsYXlhYmxlcyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLmFwaSA9IGFwaTtcbiAgICAvLyBBIHVuaXF1ZSBoYW5kbGVyIGZvciBlYWNoIGRhdGFab29tIGNvbXBvbmVudFxuICAgIHRoaXMuX29uQnJ1c2ggPSBiaW5kKHRoaXMuX29uQnJ1c2gsIHRoaXMpO1xuICAgIHRoaXMuX29uQnJ1c2hFbmQgPSBiaW5kKHRoaXMuX29uQnJ1c2hFbmQsIHRoaXMpO1xuICB9O1xuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGRhdGFab29tTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhyb3R0bGUuY3JlYXRlT3JVcGRhdGUodGhpcywgJ19kaXNwYXRjaFpvb21BY3Rpb24nLCBkYXRhWm9vbU1vZGVsLmdldCgndGhyb3R0bGUnKSwgJ2ZpeFJhdGUnKTtcbiAgICB0aGlzLl9vcmllbnQgPSBkYXRhWm9vbU1vZGVsLmdldE9yaWVudCgpO1xuICAgIGlmIChkYXRhWm9vbU1vZGVsLmdldCgnc2hvdycpID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGFab29tTW9kZWwubm9UYXJnZXQoKSkge1xuICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE5vdGljZTogdGhpcy5fcmVzZXRJbnRlcnZhbCgpIHNob3VsZCBub3QgYmUgZXhlY3V0ZWQgd2hlbiBwYXlsb2FkLnR5cGVcbiAgICAvLyBpcyAnZGF0YVpvb20nLCBvcmlnaW4gdGhpcy5fcmFuZ2Ugc2hvdWxkIGJlIG1haW50YWluZWQsIG90aGVyd2lzZSAncGFuJ1xuICAgIC8vIG9yICd6b29tJyBpbmZvIHdpbGwgYmUgbWlzc2VkIGJlY2F1c2Ugb2YgJ3Rocm90dGxlJyBvZiB0aGlzLmRpc3BhdGNoQWN0aW9uLFxuICAgIGlmICghcGF5bG9hZCB8fCBwYXlsb2FkLnR5cGUgIT09ICdkYXRhWm9vbScgfHwgcGF5bG9hZC5mcm9tICE9PSB0aGlzLnVpZCkge1xuICAgICAgdGhpcy5fYnVpbGRWaWV3KCk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZVZpZXcoKTtcbiAgfTtcbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xlYXIoKTtcbiAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoWm9vbUFjdGlvbicpO1xuICAgIHZhciB6ciA9IHRoaXMuYXBpLmdldFpyKCk7XG4gICAgenIub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkJydXNoKTtcbiAgICB6ci5vZmYoJ21vdXNldXAnLCB0aGlzLl9vbkJydXNoRW5kKTtcbiAgfTtcbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl9idWlsZFZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoaXNHcm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdGhpc0dyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMuX2JydXNoaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fZGlzcGxheWFibGVzLmJydXNoUmVjdCA9IG51bGw7XG4gICAgdGhpcy5fcmVzZXRMb2NhdGlvbigpO1xuICAgIHRoaXMuX3Jlc2V0SW50ZXJ2YWwoKTtcbiAgICB2YXIgYmFyR3JvdXAgPSB0aGlzLl9kaXNwbGF5YWJsZXMuc2xpZGVyR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoKTtcbiAgICB0aGlzLl9yZW5kZXJIYW5kbGUoKTtcbiAgICB0aGlzLl9yZW5kZXJEYXRhU2hhZG93KCk7XG4gICAgdGhpc0dyb3VwLmFkZChiYXJHcm91cCk7XG4gICAgdGhpcy5fcG9zaXRpb25Hcm91cCgpO1xuICB9O1xuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuX3Jlc2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgdmFyIGFwaSA9IHRoaXMuYXBpO1xuICAgIHZhciBzaG93TW92ZUhhbmRsZSA9IGRhdGFab29tTW9kZWwuZ2V0KCdicnVzaFNlbGVjdCcpO1xuICAgIHZhciBtb3ZlSGFuZGxlU2l6ZSA9IHNob3dNb3ZlSGFuZGxlID8gREVGQVVMVF9NT1ZFX0hBTkRMRV9TSVpFIDogMDtcbiAgICAvLyBJZiBzb21lIG9mIHgveS93aWR0aC9oZWlnaHQgYXJlIG5vdCBzcGVjaWZpZWQsXG4gICAgLy8gYXV0by1hZGFwdCBhY2NvcmRpbmcgdG8gdGFyZ2V0IGdyaWQuXG4gICAgdmFyIGNvb3JkUmVjdCA9IHRoaXMuX2ZpbmRDb29yZFJlY3QoKTtcbiAgICB2YXIgZWNTaXplID0ge1xuICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICB9O1xuICAgIC8vIERlZmF1bHQgYWxpZ24gYnkgY29vcmRpbmF0ZSBzeXN0ZW0gcmVjdC5cbiAgICB2YXIgcG9zaXRpb25JbmZvID0gdGhpcy5fb3JpZW50ID09PSBIT1JJWk9OVEFMID8ge1xuICAgICAgLy8gV2h5IHVzaW5nICdyaWdodCcsIGJlY2F1c2UgcmlnaHQgc2hvdWxkIGJlIHVzZWQgaW4gdmVydGljYWwsXG4gICAgICAvLyBhbmQgaXQgaXMgYmV0dGVyIHRvIGJlIGNvbnNpc3RlbnQgZm9yIGRlYWxpbmcgd2l0aCBwb3NpdGlvbiBwYXJhbSBtZXJnZS5cbiAgICAgIHJpZ2h0OiBlY1NpemUud2lkdGggLSBjb29yZFJlY3QueCAtIGNvb3JkUmVjdC53aWR0aCxcbiAgICAgIHRvcDogZWNTaXplLmhlaWdodCAtIERFRkFVTFRfRklMTEVSX1NJWkUgLSBERUZBVUxUX0xPQ0FUSU9OX0VER0VfR0FQIC0gbW92ZUhhbmRsZVNpemUsXG4gICAgICB3aWR0aDogY29vcmRSZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBERUZBVUxUX0ZJTExFUl9TSVpFXG4gICAgfSA6IHtcbiAgICAgIHJpZ2h0OiBERUZBVUxUX0xPQ0FUSU9OX0VER0VfR0FQLFxuICAgICAgdG9wOiBjb29yZFJlY3QueSxcbiAgICAgIHdpZHRoOiBERUZBVUxUX0ZJTExFUl9TSVpFLFxuICAgICAgaGVpZ2h0OiBjb29yZFJlY3QuaGVpZ2h0XG4gICAgfTtcbiAgICAvLyBEbyBub3Qgd3JpdGUgYmFjayB0byBvcHRpb24gYW5kIHJlcGxhY2UgdmFsdWUgJ3BoJywgYmVjYXVzZVxuICAgIC8vIHRoZSAncGgnIHZhbHVlIHNob3VsZCBiZSByZWNhbGN1bGF0ZWQgd2hlbiByZXNpemUuXG4gICAgdmFyIGxheW91dFBhcmFtcyA9IGxheW91dC5nZXRMYXlvdXRQYXJhbXMoZGF0YVpvb21Nb2RlbC5vcHRpb24pO1xuICAgIC8vIFJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgIGVhY2goWydyaWdodCcsICd0b3AnLCAnd2lkdGgnLCAnaGVpZ2h0J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAobGF5b3V0UGFyYW1zW25hbWVdID09PSAncGgnKSB7XG4gICAgICAgIGxheW91dFBhcmFtc1tuYW1lXSA9IHBvc2l0aW9uSW5mb1tuYW1lXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbGF5b3V0UmVjdCA9IGxheW91dC5nZXRMYXlvdXRSZWN0KGxheW91dFBhcmFtcywgZWNTaXplKTtcbiAgICB0aGlzLl9sb2NhdGlvbiA9IHtcbiAgICAgIHg6IGxheW91dFJlY3QueCxcbiAgICAgIHk6IGxheW91dFJlY3QueVxuICAgIH07XG4gICAgdGhpcy5fc2l6ZSA9IFtsYXlvdXRSZWN0LndpZHRoLCBsYXlvdXRSZWN0LmhlaWdodF07XG4gICAgdGhpcy5fb3JpZW50ID09PSBWRVJUSUNBTCAmJiB0aGlzLl9zaXplLnJldmVyc2UoKTtcbiAgfTtcbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl9wb3NpdGlvbkdyb3VwID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGlzR3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuX2xvY2F0aW9uO1xuICAgIHZhciBvcmllbnQgPSB0aGlzLl9vcmllbnQ7XG4gICAgLy8gSnVzdCB1c2UgdGhlIGZpcnN0IGF4aXMgdG8gZGV0ZXJtaW5lIG1hcHBpbmcuXG4gICAgdmFyIHRhcmdldEF4aXNNb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbC5nZXRGaXJzdFRhcmdldEF4aXNNb2RlbCgpO1xuICAgIHZhciBpbnZlcnNlID0gdGFyZ2V0QXhpc01vZGVsICYmIHRhcmdldEF4aXNNb2RlbC5nZXQoJ2ludmVyc2UnKTtcbiAgICB2YXIgc2xpZGVyR3JvdXAgPSB0aGlzLl9kaXNwbGF5YWJsZXMuc2xpZGVyR3JvdXA7XG4gICAgdmFyIG90aGVyQXhpc0ludmVyc2UgPSAodGhpcy5fZGF0YVNoYWRvd0luZm8gfHwge30pLm90aGVyQXhpc0ludmVyc2U7XG4gICAgLy8gVHJhbnNmb3JtIGJhckdyb3VwLlxuICAgIHNsaWRlckdyb3VwLmF0dHIob3JpZW50ID09PSBIT1JJWk9OVEFMICYmICFpbnZlcnNlID8ge1xuICAgICAgc2NhbGVZOiBvdGhlckF4aXNJbnZlcnNlID8gMSA6IC0xLFxuICAgICAgc2NhbGVYOiAxXG4gICAgfSA6IG9yaWVudCA9PT0gSE9SSVpPTlRBTCAmJiBpbnZlcnNlID8ge1xuICAgICAgc2NhbGVZOiBvdGhlckF4aXNJbnZlcnNlID8gMSA6IC0xLFxuICAgICAgc2NhbGVYOiAtMVxuICAgIH0gOiBvcmllbnQgPT09IFZFUlRJQ0FMICYmICFpbnZlcnNlID8ge1xuICAgICAgc2NhbGVZOiBvdGhlckF4aXNJbnZlcnNlID8gLTEgOiAxLFxuICAgICAgc2NhbGVYOiAxLFxuICAgICAgcm90YXRpb246IE1hdGguUEkgLyAyXG4gICAgfVxuICAgIC8vIERvbid0IHVzZSBNYXRoLlBJLCBjb25zaWRlcmluZyBzaGFkb3cgZGlyZWN0aW9uLlxuICAgIDoge1xuICAgICAgc2NhbGVZOiBvdGhlckF4aXNJbnZlcnNlID8gLTEgOiAxLFxuICAgICAgc2NhbGVYOiAtMSxcbiAgICAgIHJvdGF0aW9uOiBNYXRoLlBJIC8gMlxuICAgIH0pO1xuICAgIC8vIFBvc2l0aW9uIGJhckdyb3VwXG4gICAgdmFyIHJlY3QgPSB0aGlzR3JvdXAuZ2V0Qm91bmRpbmdSZWN0KFtzbGlkZXJHcm91cF0pO1xuICAgIHRoaXNHcm91cC54ID0gbG9jYXRpb24ueCAtIHJlY3QueDtcbiAgICB0aGlzR3JvdXAueSA9IGxvY2F0aW9uLnkgLSByZWN0Lnk7XG4gICAgdGhpc0dyb3VwLm1hcmtSZWRyYXcoKTtcbiAgfTtcbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl9nZXRWaWV3RXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbMCwgdGhpcy5fc2l6ZVswXV07XG4gIH07XG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fcmVuZGVyQmFja2dyb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgdmFyIGJhckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLnNsaWRlckdyb3VwO1xuICAgIHZhciBicnVzaFNlbGVjdCA9IGRhdGFab29tTW9kZWwuZ2V0KCdicnVzaFNlbGVjdCcpO1xuICAgIGJhckdyb3VwLmFkZChuZXcgUmVjdCh7XG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICBzaGFwZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogc2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZmlsbDogZGF0YVpvb21Nb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpXG4gICAgICB9LFxuICAgICAgejI6IC00MFxuICAgIH0pKTtcbiAgICAvLyBDbGljayBwYW5lbCwgb3ZlciBzaGFkb3csIGJlbG93IGhhbmRsZXMuXG4gICAgdmFyIGNsaWNrUGFuZWwgPSBuZXcgUmVjdCh7XG4gICAgICBzaGFwZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogc2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50J1xuICAgICAgfSxcbiAgICAgIHoyOiAwLFxuICAgICAgb25jbGljazogYmluZCh0aGlzLl9vbkNsaWNrUGFuZWwsIHRoaXMpXG4gICAgfSk7XG4gICAgdmFyIHpyID0gdGhpcy5hcGkuZ2V0WnIoKTtcbiAgICBpZiAoYnJ1c2hTZWxlY3QpIHtcbiAgICAgIGNsaWNrUGFuZWwub24oJ21vdXNlZG93bicsIHRoaXMuX29uQnJ1c2hTdGFydCwgdGhpcyk7XG4gICAgICBjbGlja1BhbmVsLmN1cnNvciA9ICdjcm9zc2hhaXInO1xuICAgICAgenIub24oJ21vdXNlbW92ZScsIHRoaXMuX29uQnJ1c2gpO1xuICAgICAgenIub24oJ21vdXNldXAnLCB0aGlzLl9vbkJydXNoRW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgenIub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkJydXNoKTtcbiAgICAgIHpyLm9mZignbW91c2V1cCcsIHRoaXMuX29uQnJ1c2hFbmQpO1xuICAgIH1cbiAgICBiYXJHcm91cC5hZGQoY2xpY2tQYW5lbCk7XG4gIH07XG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fcmVuZGVyRGF0YVNoYWRvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMuX2RhdGFTaGFkb3dJbmZvID0gdGhpcy5fcHJlcGFyZURhdGFTaGFkb3dJbmZvKCk7XG4gICAgdGhpcy5fZGlzcGxheWFibGVzLmRhdGFTaGFkb3dTZWdzID0gW107XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICB2YXIgb2xkU2l6ZSA9IHRoaXMuX3NoYWRvd1NpemUgfHwgW107XG4gICAgdmFyIHNlcmllc01vZGVsID0gaW5mby5zZXJpZXM7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXRSYXdEYXRhKCk7XG4gICAgdmFyIGNhbmRsZXN0aWNrRGltID0gc2VyaWVzTW9kZWwuZ2V0U2hhZG93RGltICYmIHNlcmllc01vZGVsLmdldFNoYWRvd0RpbSgpO1xuICAgIHZhciBvdGhlckRpbSA9IGNhbmRsZXN0aWNrRGltICYmIGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhjYW5kbGVzdGlja0RpbSkgPyBzZXJpZXNNb2RlbC5nZXRTaGFkb3dEaW0oKSAvLyBAc2VlIGNhbmRsZXN0aWNrXG4gICAgOiBpbmZvLm90aGVyRGltO1xuICAgIGlmIChvdGhlckRpbSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwb2x5Z29uUHRzID0gdGhpcy5fc2hhZG93UG9seWdvblB0cztcbiAgICB2YXIgcG9seWxpbmVQdHMgPSB0aGlzLl9zaGFkb3dQb2x5bGluZVB0cztcbiAgICAvLyBOb3QgcmUtcmVuZGVyIGlmIGRhdGEgZG9lc24ndCBjaGFuZ2UuXG4gICAgaWYgKGRhdGEgIT09IHRoaXMuX3NoYWRvd0RhdGEgfHwgb3RoZXJEaW0gIT09IHRoaXMuX3NoYWRvd0RpbSB8fCBzaXplWzBdICE9PSBvbGRTaXplWzBdIHx8IHNpemVbMV0gIT09IG9sZFNpemVbMV0pIHtcbiAgICAgIHZhciBvdGhlckRhdGFFeHRlbnRfMSA9IGRhdGEuZ2V0RGF0YUV4dGVudChvdGhlckRpbSk7XG4gICAgICAvLyBOaWNlIGV4dGVudC5cbiAgICAgIHZhciBvdGhlck9mZnNldCA9IChvdGhlckRhdGFFeHRlbnRfMVsxXSAtIG90aGVyRGF0YUV4dGVudF8xWzBdKSAqIDAuMztcbiAgICAgIG90aGVyRGF0YUV4dGVudF8xID0gW290aGVyRGF0YUV4dGVudF8xWzBdIC0gb3RoZXJPZmZzZXQsIG90aGVyRGF0YUV4dGVudF8xWzFdICsgb3RoZXJPZmZzZXRdO1xuICAgICAgdmFyIG90aGVyU2hhZG93RXh0ZW50XzEgPSBbMCwgc2l6ZVsxXV07XG4gICAgICB2YXIgdGhpc1NoYWRvd0V4dGVudCA9IFswLCBzaXplWzBdXTtcbiAgICAgIHZhciBhcmVhUG9pbnRzXzEgPSBbW3NpemVbMF0sIDBdLCBbMCwgMF1dO1xuICAgICAgdmFyIGxpbmVQb2ludHNfMSA9IFtdO1xuICAgICAgdmFyIHN0ZXBfMSA9IHRoaXNTaGFkb3dFeHRlbnRbMV0gLyAoZGF0YS5jb3VudCgpIC0gMSk7XG4gICAgICB2YXIgdGhpc0Nvb3JkXzEgPSAwO1xuICAgICAgLy8gT3B0aW1pemUgZm9yIGxhcmdlIGRhdGEgc2hhZG93XG4gICAgICB2YXIgc3RyaWRlXzEgPSBNYXRoLnJvdW5kKGRhdGEuY291bnQoKSAvIHNpemVbMF0pO1xuICAgICAgdmFyIGxhc3RJc0VtcHR5XzE7XG4gICAgICBkYXRhLmVhY2goW290aGVyRGltXSwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICBpZiAoc3RyaWRlXzEgPiAwICYmIGluZGV4ICUgc3RyaWRlXzEpIHtcbiAgICAgICAgICB0aGlzQ29vcmRfMSArPSBzdGVwXzE7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIFNob3VsZCBjb25zaWRlciBheGlzLm1pbi9heGlzLm1heCB3aGVuIGRyYXdpbmcgZGF0YVNoYWRvdy5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLy8g5bqU6K+l5L2/55So57uf5LiA55qE56m65Yik5pat77yf6L+Y5piv5ZyobGlzdOmHjOi/m+ihjOepuuWIpOaWre+8n1xuICAgICAgICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSAnJztcbiAgICAgICAgLy8gU2VlICM0MjM1LlxuICAgICAgICB2YXIgb3RoZXJDb29yZCA9IGlzRW1wdHkgPyAwIDogbGluZWFyTWFwKHZhbHVlLCBvdGhlckRhdGFFeHRlbnRfMSwgb3RoZXJTaGFkb3dFeHRlbnRfMSwgdHJ1ZSk7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gZHJhdyBkYXRhIHNoYWRvdyBwcmVjaXNlbHkgd2hlbiB0aGVyZSBhcmUgZW1wdHkgdmFsdWUuXG4gICAgICAgIGlmIChpc0VtcHR5ICYmICFsYXN0SXNFbXB0eV8xICYmIGluZGV4KSB7XG4gICAgICAgICAgYXJlYVBvaW50c18xLnB1c2goW2FyZWFQb2ludHNfMVthcmVhUG9pbnRzXzEubGVuZ3RoIC0gMV1bMF0sIDBdKTtcbiAgICAgICAgICBsaW5lUG9pbnRzXzEucHVzaChbbGluZVBvaW50c18xW2xpbmVQb2ludHNfMS5sZW5ndGggLSAxXVswXSwgMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0VtcHR5ICYmIGxhc3RJc0VtcHR5XzEpIHtcbiAgICAgICAgICBhcmVhUG9pbnRzXzEucHVzaChbdGhpc0Nvb3JkXzEsIDBdKTtcbiAgICAgICAgICBsaW5lUG9pbnRzXzEucHVzaChbdGhpc0Nvb3JkXzEsIDBdKTtcbiAgICAgICAgfVxuICAgICAgICBhcmVhUG9pbnRzXzEucHVzaChbdGhpc0Nvb3JkXzEsIG90aGVyQ29vcmRdKTtcbiAgICAgICAgbGluZVBvaW50c18xLnB1c2goW3RoaXNDb29yZF8xLCBvdGhlckNvb3JkXSk7XG4gICAgICAgIHRoaXNDb29yZF8xICs9IHN0ZXBfMTtcbiAgICAgICAgbGFzdElzRW1wdHlfMSA9IGlzRW1wdHk7XG4gICAgICB9KTtcbiAgICAgIHBvbHlnb25QdHMgPSB0aGlzLl9zaGFkb3dQb2x5Z29uUHRzID0gYXJlYVBvaW50c18xO1xuICAgICAgcG9seWxpbmVQdHMgPSB0aGlzLl9zaGFkb3dQb2x5bGluZVB0cyA9IGxpbmVQb2ludHNfMTtcbiAgICB9XG4gICAgdGhpcy5fc2hhZG93RGF0YSA9IGRhdGE7XG4gICAgdGhpcy5fc2hhZG93RGltID0gb3RoZXJEaW07XG4gICAgdGhpcy5fc2hhZG93U2l6ZSA9IFtzaXplWzBdLCBzaXplWzFdXTtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRhU2hhZG93R3JvdXAoaXNTZWxlY3RlZEFyZWEpIHtcbiAgICAgIHZhciBtb2RlbCA9IGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoaXNTZWxlY3RlZEFyZWEgPyAnc2VsZWN0ZWREYXRhQmFja2dyb3VuZCcgOiAnZGF0YUJhY2tncm91bmQnKTtcbiAgICAgIHZhciBncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgICB2YXIgcG9seWdvbiA9IG5ldyBncmFwaGljLlBvbHlnb24oe1xuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIHBvaW50czogcG9seWdvblB0c1xuICAgICAgICB9LFxuICAgICAgICBzZWdtZW50SWdub3JlVGhyZXNob2xkOiAxLFxuICAgICAgICBzdHlsZTogbW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZScpLmdldEFyZWFTdHlsZSgpLFxuICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgIHoyOiAtMjBcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvbHlsaW5lID0gbmV3IGdyYXBoaWMuUG9seWxpbmUoe1xuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIHBvaW50czogcG9seWxpbmVQdHNcbiAgICAgICAgfSxcbiAgICAgICAgc2VnbWVudElnbm9yZVRocmVzaG9sZDogMSxcbiAgICAgICAgc3R5bGU6IG1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKSxcbiAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICB6MjogLTE5XG4gICAgICB9KTtcbiAgICAgIGdyb3VwLmFkZChwb2x5Z29uKTtcbiAgICAgIGdyb3VwLmFkZChwb2x5bGluZSk7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICAgIC8vIGxldCBkYXRhQmFja2dyb3VuZE1vZGVsID0gZGF0YVpvb21Nb2RlbC5nZXRNb2RlbCgnZGF0YUJhY2tncm91bmQnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgdmFyIGdyb3VwID0gY3JlYXRlRGF0YVNoYWRvd0dyb3VwKGkgPT09IDEpO1xuICAgICAgdGhpcy5fZGlzcGxheWFibGVzLnNsaWRlckdyb3VwLmFkZChncm91cCk7XG4gICAgICB0aGlzLl9kaXNwbGF5YWJsZXMuZGF0YVNoYWRvd1NlZ3MucHVzaChncm91cCk7XG4gICAgfVxuICB9O1xuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuX3ByZXBhcmVEYXRhU2hhZG93SW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgc2hvd0RhdGFTaGFkb3cgPSBkYXRhWm9vbU1vZGVsLmdldCgnc2hvd0RhdGFTaGFkb3cnKTtcbiAgICBpZiAoc2hvd0RhdGFTaGFkb3cgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEZpbmQgYSByZXByZXNlbnRhdGl2ZSBzZXJpZXMuXG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChheGlzRGltLCBheGlzSW5kZXgpIHtcbiAgICAgIHZhciBzZXJpZXNNb2RlbHMgPSBkYXRhWm9vbU1vZGVsLmdldEF4aXNQcm94eShheGlzRGltLCBheGlzSW5kZXgpLmdldFRhcmdldFNlcmllc01vZGVscygpO1xuICAgICAgZWFjaChzZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG93RGF0YVNoYWRvdyAhPT0gdHJ1ZSAmJiBpbmRleE9mKFNIT1dfREFUQV9TSEFET1dfU0VSSUVTX1RZUEUsIHNlcmllc01vZGVsLmdldCgndHlwZScpKSA8IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNBeGlzID0gZWNNb2RlbC5nZXRDb21wb25lbnQoZ2V0QXhpc01haW5UeXBlKGF4aXNEaW0pLCBheGlzSW5kZXgpLmF4aXM7XG4gICAgICAgIHZhciBvdGhlckRpbSA9IGdldE90aGVyRGltKGF4aXNEaW0pO1xuICAgICAgICB2YXIgb3RoZXJBeGlzSW52ZXJzZTtcbiAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgaWYgKG90aGVyRGltICE9IG51bGwgJiYgY29vcmRTeXMuZ2V0T3RoZXJBeGlzKSB7XG4gICAgICAgICAgb3RoZXJBeGlzSW52ZXJzZSA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyh0aGlzQXhpcykuaW52ZXJzZTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlckRpbSA9IHNlcmllc01vZGVsLmdldERhdGEoKS5tYXBEaW1lbnNpb24ob3RoZXJEaW0pO1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgdGhpc0F4aXM6IHRoaXNBeGlzLFxuICAgICAgICAgIHNlcmllczogc2VyaWVzTW9kZWwsXG4gICAgICAgICAgdGhpc0RpbTogYXhpc0RpbSxcbiAgICAgICAgICBvdGhlckRpbTogb3RoZXJEaW0sXG4gICAgICAgICAgb3RoZXJBeGlzSW52ZXJzZTogb3RoZXJBeGlzSW52ZXJzZVxuICAgICAgICB9O1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl9yZW5kZXJIYW5kbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoaXNHcm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIGRpc3BsYXlhYmxlcyA9IHRoaXMuX2Rpc3BsYXlhYmxlcztcbiAgICB2YXIgaGFuZGxlcyA9IGRpc3BsYXlhYmxlcy5oYW5kbGVzID0gW251bGwsIG51bGxdO1xuICAgIHZhciBoYW5kbGVMYWJlbHMgPSBkaXNwbGF5YWJsZXMuaGFuZGxlTGFiZWxzID0gW251bGwsIG51bGxdO1xuICAgIHZhciBzbGlkZXJHcm91cCA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5zbGlkZXJHcm91cDtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgdmFyIGFwaSA9IHRoaXMuYXBpO1xuICAgIHZhciBib3JkZXJSYWRpdXMgPSBkYXRhWm9vbU1vZGVsLmdldCgnYm9yZGVyUmFkaXVzJykgfHwgMDtcbiAgICB2YXIgYnJ1c2hTZWxlY3QgPSBkYXRhWm9vbU1vZGVsLmdldCgnYnJ1c2hTZWxlY3QnKTtcbiAgICB2YXIgZmlsbGVyID0gZGlzcGxheWFibGVzLmZpbGxlciA9IG5ldyBSZWN0KHtcbiAgICAgIHNpbGVudDogYnJ1c2hTZWxlY3QsXG4gICAgICBzdHlsZToge1xuICAgICAgICBmaWxsOiBkYXRhWm9vbU1vZGVsLmdldCgnZmlsbGVyQ29sb3InKVxuICAgICAgfSxcbiAgICAgIHRleHRDb25maWc6IHtcbiAgICAgICAgcG9zaXRpb246ICdpbnNpZGUnXG4gICAgICB9XG4gICAgfSk7XG4gICAgc2xpZGVyR3JvdXAuYWRkKGZpbGxlcik7XG4gICAgLy8gRnJhbWUgYm9yZGVyLlxuICAgIHNsaWRlckdyb3VwLmFkZChuZXcgUmVjdCh7XG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICBzdWJQaXhlbE9wdGltaXplOiB0cnVlLFxuICAgICAgc2hhcGU6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IHNpemVbMF0sXG4gICAgICAgIGhlaWdodDogc2l6ZVsxXSxcbiAgICAgICAgcjogYm9yZGVyUmFkaXVzXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgLy8gZGVwcmVjYXRlZCBvcHRpb25cbiAgICAgICAgc3Ryb2tlOiBkYXRhWm9vbU1vZGVsLmdldCgnZGF0YUJhY2tncm91bmRDb2xvcicpIHx8IGRhdGFab29tTW9kZWwuZ2V0KCdib3JkZXJDb2xvcicpLFxuICAgICAgICBsaW5lV2lkdGg6IERFRkFVTFRfRlJBTUVfQk9SREVSX1dJRFRILFxuICAgICAgICBmaWxsOiAncmdiYSgwLDAsMCwwKSdcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgLy8gTGVmdCBhbmQgcmlnaHQgaGFuZGxlIHRvIHJlc2l6ZVxuICAgIGVhY2goWzAsIDFdLCBmdW5jdGlvbiAoaGFuZGxlSW5kZXgpIHtcbiAgICAgIHZhciBpY29uU3RyID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2hhbmRsZUljb24nKTtcbiAgICAgIGlmICghc3ltYm9sQnVpbGRQcm94aWVzW2ljb25TdHJdICYmIGljb25TdHIuaW5kZXhPZigncGF0aDovLycpIDwgMCAmJiBpY29uU3RyLmluZGV4T2YoJ2ltYWdlOi8vJykgPCAwKSB7XG4gICAgICAgIC8vIENvbXBhdGl0YWJsZSB3aXRoIHRoZSBvbGQgaWNvbiBwYXJzZXJzLiBXaGljaCBjYW4gdXNlIGEgcGF0aCBzdHJpbmcgd2l0aG91dCBwYXRoOi8vXG4gICAgICAgIGljb25TdHIgPSAncGF0aDovLycgKyBpY29uU3RyO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGRlcHJlY2F0ZUxvZygnaGFuZGxlSWNvbiBub3cgbmVlZHMgXFwncGF0aDovL1xcJyBwcmVmaXggd2hlbiB1c2luZyBhIHBhdGggc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBwYXRoID0gY3JlYXRlU3ltYm9sKGljb25TdHIsIC0xLCAwLCAyLCAyLCBudWxsLCB0cnVlKTtcbiAgICAgIHBhdGguYXR0cih7XG4gICAgICAgIGN1cnNvcjogZ2V0Q3Vyc29yKHRoaXMuX29yaWVudCksXG4gICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgZHJpZnQ6IGJpbmQodGhpcy5fb25EcmFnTW92ZSwgdGhpcywgaGFuZGxlSW5kZXgpLFxuICAgICAgICBvbmRyYWdlbmQ6IGJpbmQodGhpcy5fb25EcmFnRW5kLCB0aGlzKSxcbiAgICAgICAgb25tb3VzZW92ZXI6IGJpbmQodGhpcy5fc2hvd0RhdGFJbmZvLCB0aGlzLCB0cnVlKSxcbiAgICAgICAgb25tb3VzZW91dDogYmluZCh0aGlzLl9zaG93RGF0YUluZm8sIHRoaXMsIGZhbHNlKSxcbiAgICAgICAgejI6IDVcbiAgICAgIH0pO1xuICAgICAgdmFyIGJSZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgIHZhciBoYW5kbGVTaXplID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2hhbmRsZVNpemUnKTtcbiAgICAgIHRoaXMuX2hhbmRsZUhlaWdodCA9IHBhcnNlUGVyY2VudChoYW5kbGVTaXplLCB0aGlzLl9zaXplWzFdKTtcbiAgICAgIHRoaXMuX2hhbmRsZVdpZHRoID0gYlJlY3Qud2lkdGggLyBiUmVjdC5oZWlnaHQgKiB0aGlzLl9oYW5kbGVIZWlnaHQ7XG4gICAgICBwYXRoLnNldFN0eWxlKGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ2hhbmRsZVN0eWxlJykuZ2V0SXRlbVN0eWxlKCkpO1xuICAgICAgcGF0aC5zdHlsZS5zdHJva2VOb1NjYWxlID0gdHJ1ZTtcbiAgICAgIHBhdGgucmVjdEhvdmVyID0gdHJ1ZTtcbiAgICAgIHBhdGguZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJykuc3R5bGUgPSBkYXRhWm9vbU1vZGVsLmdldE1vZGVsKFsnZW1waGFzaXMnLCAnaGFuZGxlU3R5bGUnXSkuZ2V0SXRlbVN0eWxlKCk7XG4gICAgICBlbmFibGVIb3ZlckVtcGhhc2lzKHBhdGgpO1xuICAgICAgdmFyIGhhbmRsZUNvbG9yID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2hhbmRsZUNvbG9yJyk7IC8vIGRlcHJlY2F0ZWQgb3B0aW9uXG4gICAgICAvLyBDb21wYXRpdGFibGUgd2l0aCBwcmV2aW91cyB2ZXJzaW9uXG4gICAgICBpZiAoaGFuZGxlQ29sb3IgIT0gbnVsbCkge1xuICAgICAgICBwYXRoLnN0eWxlLmZpbGwgPSBoYW5kbGVDb2xvcjtcbiAgICAgIH1cbiAgICAgIHNsaWRlckdyb3VwLmFkZChoYW5kbGVzW2hhbmRsZUluZGV4XSA9IHBhdGgpO1xuICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gZGF0YVpvb21Nb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgICB2YXIgaGFuZGxlTGFiZWwgPSBkYXRhWm9vbU1vZGVsLmdldCgnaGFuZGxlTGFiZWwnKSB8fCB7fTtcbiAgICAgIHZhciBoYW5kbGVMYWJlbFNob3cgPSBoYW5kbGVMYWJlbC5zaG93IHx8IGZhbHNlO1xuICAgICAgdGhpc0dyb3VwLmFkZChoYW5kbGVMYWJlbHNbaGFuZGxlSW5kZXhdID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgaW52aXNpYmxlOiAhaGFuZGxlTGFiZWxTaG93LFxuICAgICAgICBzdHlsZTogY3JlYXRlVGV4dFN0eWxlKHRleHRTdHlsZU1vZGVsLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICBmaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSxcbiAgICAgICAgICBmb250OiB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KClcbiAgICAgICAgfSksXG4gICAgICAgIHoyOiAxMFxuICAgICAgfSkpO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIEhhbmRsZSB0byBtb3ZlLiBPbmx5IHZpc2libGUgd2hlbiBicnVzaFNlbGVjdCBpcyBzZXQgdHJ1ZS5cbiAgICB2YXIgYWN0dWFsTW92ZVpvbmUgPSBmaWxsZXI7XG4gICAgaWYgKGJydXNoU2VsZWN0KSB7XG4gICAgICB2YXIgbW92ZUhhbmRsZUhlaWdodCA9IHBhcnNlUGVyY2VudChkYXRhWm9vbU1vZGVsLmdldCgnbW92ZUhhbmRsZVNpemUnKSwgc2l6ZVsxXSk7XG4gICAgICB2YXIgbW92ZUhhbmRsZV8xID0gZGlzcGxheWFibGVzLm1vdmVIYW5kbGUgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgc3R5bGU6IGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ21vdmVIYW5kbGVTdHlsZScpLmdldEl0ZW1TdHlsZSgpLFxuICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgcjogWzAsIDAsIDIsIDJdLFxuICAgICAgICAgIHk6IHNpemVbMV0gLSAwLjUsXG4gICAgICAgICAgaGVpZ2h0OiBtb3ZlSGFuZGxlSGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGljb25TaXplID0gbW92ZUhhbmRsZUhlaWdodCAqIDAuODtcbiAgICAgIHZhciBtb3ZlSGFuZGxlSWNvbiA9IGRpc3BsYXlhYmxlcy5tb3ZlSGFuZGxlSWNvbiA9IGNyZWF0ZVN5bWJvbChkYXRhWm9vbU1vZGVsLmdldCgnbW92ZUhhbmRsZUljb24nKSwgLWljb25TaXplIC8gMiwgLWljb25TaXplIC8gMiwgaWNvblNpemUsIGljb25TaXplLCAnI2ZmZicsIHRydWUpO1xuICAgICAgbW92ZUhhbmRsZUljb24uc2lsZW50ID0gdHJ1ZTtcbiAgICAgIG1vdmVIYW5kbGVJY29uLnkgPSBzaXplWzFdICsgbW92ZUhhbmRsZUhlaWdodCAvIDIgLSAwLjU7XG4gICAgICBtb3ZlSGFuZGxlXzEuZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJykuc3R5bGUgPSBkYXRhWm9vbU1vZGVsLmdldE1vZGVsKFsnZW1waGFzaXMnLCAnbW92ZUhhbmRsZVN0eWxlJ10pLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgdmFyIG1vdmVab25lRXhwYW5kU2l6ZSA9IE1hdGgubWluKHNpemVbMV0gLyAyLCBNYXRoLm1heChtb3ZlSGFuZGxlSGVpZ2h0LCAxMCkpO1xuICAgICAgYWN0dWFsTW92ZVpvbmUgPSBkaXNwbGF5YWJsZXMubW92ZVpvbmUgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgaW52aXNpYmxlOiB0cnVlLFxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIHk6IHNpemVbMV0gLSBtb3ZlWm9uZUV4cGFuZFNpemUsXG4gICAgICAgICAgaGVpZ2h0OiBtb3ZlSGFuZGxlSGVpZ2h0ICsgbW92ZVpvbmVFeHBhbmRTaXplXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYWN0dWFsTW92ZVpvbmUub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXBpLmVudGVyRW1waGFzaXMobW92ZUhhbmRsZV8xKTtcbiAgICAgIH0pLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXBpLmxlYXZlRW1waGFzaXMobW92ZUhhbmRsZV8xKTtcbiAgICAgIH0pO1xuICAgICAgc2xpZGVyR3JvdXAuYWRkKG1vdmVIYW5kbGVfMSk7XG4gICAgICBzbGlkZXJHcm91cC5hZGQobW92ZUhhbmRsZUljb24pO1xuICAgICAgc2xpZGVyR3JvdXAuYWRkKGFjdHVhbE1vdmVab25lKTtcbiAgICB9XG4gICAgYWN0dWFsTW92ZVpvbmUuYXR0cih7XG4gICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICBjdXJzb3I6IGdldEN1cnNvcih0aGlzLl9vcmllbnQpLFxuICAgICAgZHJpZnQ6IGJpbmQodGhpcy5fb25EcmFnTW92ZSwgdGhpcywgJ2FsbCcpLFxuICAgICAgb25kcmFnc3RhcnQ6IGJpbmQodGhpcy5fc2hvd0RhdGFJbmZvLCB0aGlzLCB0cnVlKSxcbiAgICAgIG9uZHJhZ2VuZDogYmluZCh0aGlzLl9vbkRyYWdFbmQsIHRoaXMpLFxuICAgICAgb25tb3VzZW92ZXI6IGJpbmQodGhpcy5fc2hvd0RhdGFJbmZvLCB0aGlzLCB0cnVlKSxcbiAgICAgIG9ubW91c2VvdXQ6IGJpbmQodGhpcy5fc2hvd0RhdGFJbmZvLCB0aGlzLCBmYWxzZSlcbiAgICB9KTtcbiAgfTtcbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl9yZXNldEludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlID0gdGhpcy5kYXRhWm9vbU1vZGVsLmdldFBlcmNlbnRSYW5nZSgpO1xuICAgIHZhciB2aWV3RXh0ZW50ID0gdGhpcy5fZ2V0Vmlld0V4dGVudCgpO1xuICAgIHRoaXMuX2hhbmRsZUVuZHMgPSBbbGluZWFyTWFwKHJhbmdlWzBdLCBbMCwgMTAwXSwgdmlld0V4dGVudCwgdHJ1ZSksIGxpbmVhck1hcChyYW5nZVsxXSwgWzAsIDEwMF0sIHZpZXdFeHRlbnQsIHRydWUpXTtcbiAgfTtcbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl91cGRhdGVJbnRlcnZhbCA9IGZ1bmN0aW9uIChoYW5kbGVJbmRleCwgZGVsdGEpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgaGFuZGxlRW5kcyA9IHRoaXMuX2hhbmRsZUVuZHM7XG4gICAgdmFyIHZpZXdFeHRlbmQgPSB0aGlzLl9nZXRWaWV3RXh0ZW50KCk7XG4gICAgdmFyIG1pbk1heFNwYW4gPSBkYXRhWm9vbU1vZGVsLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpLmdldE1pbk1heFNwYW4oKTtcbiAgICB2YXIgcGVyY2VudEV4dGVudCA9IFswLCAxMDBdO1xuICAgIHNsaWRlck1vdmUoZGVsdGEsIGhhbmRsZUVuZHMsIHZpZXdFeHRlbmQsIGRhdGFab29tTW9kZWwuZ2V0KCd6b29tTG9jaycpID8gJ2FsbCcgOiBoYW5kbGVJbmRleCwgbWluTWF4U3Bhbi5taW5TcGFuICE9IG51bGwgPyBsaW5lYXJNYXAobWluTWF4U3Bhbi5taW5TcGFuLCBwZXJjZW50RXh0ZW50LCB2aWV3RXh0ZW5kLCB0cnVlKSA6IG51bGwsIG1pbk1heFNwYW4ubWF4U3BhbiAhPSBudWxsID8gbGluZWFyTWFwKG1pbk1heFNwYW4ubWF4U3BhbiwgcGVyY2VudEV4dGVudCwgdmlld0V4dGVuZCwgdHJ1ZSkgOiBudWxsKTtcbiAgICB2YXIgbGFzdFJhbmdlID0gdGhpcy5fcmFuZ2U7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2UgPSBhc2MoW2xpbmVhck1hcChoYW5kbGVFbmRzWzBdLCB2aWV3RXh0ZW5kLCBwZXJjZW50RXh0ZW50LCB0cnVlKSwgbGluZWFyTWFwKGhhbmRsZUVuZHNbMV0sIHZpZXdFeHRlbmQsIHBlcmNlbnRFeHRlbnQsIHRydWUpXSk7XG4gICAgcmV0dXJuICFsYXN0UmFuZ2UgfHwgbGFzdFJhbmdlWzBdICE9PSByYW5nZVswXSB8fCBsYXN0UmFuZ2VbMV0gIT09IHJhbmdlWzFdO1xuICB9O1xuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuX3VwZGF0ZVZpZXcgPSBmdW5jdGlvbiAobm9uUmVhbHRpbWUpIHtcbiAgICB2YXIgZGlzcGxheWJsZXMgPSB0aGlzLl9kaXNwbGF5YWJsZXM7XG4gICAgdmFyIGhhbmRsZUVuZHMgPSB0aGlzLl9oYW5kbGVFbmRzO1xuICAgIHZhciBoYW5kbGVJbnRlcnZhbCA9IGFzYyhoYW5kbGVFbmRzLnNsaWNlKCkpO1xuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICBlYWNoKFswLCAxXSwgZnVuY3Rpb24gKGhhbmRsZUluZGV4KSB7XG4gICAgICAvLyBIYW5kbGVzXG4gICAgICB2YXIgaGFuZGxlID0gZGlzcGxheWJsZXMuaGFuZGxlc1toYW5kbGVJbmRleF07XG4gICAgICB2YXIgaGFuZGxlSGVpZ2h0ID0gdGhpcy5faGFuZGxlSGVpZ2h0O1xuICAgICAgaGFuZGxlLmF0dHIoe1xuICAgICAgICBzY2FsZVg6IGhhbmRsZUhlaWdodCAvIDIsXG4gICAgICAgIHNjYWxlWTogaGFuZGxlSGVpZ2h0IC8gMixcbiAgICAgICAgLy8gVGhpcyBpcyBhIHRyaWNrLCBieSBhZGRpbmcgYW4gZXh0cmEgdGlueSBvZmZzZXQgdG8gbGV0IHRoZSBkZWZhdWx0IGhhbmRsZSdzIGVuZCBwb2ludCBhbGlnbiB0byB0aGUgZHJhZyB3aW5kb3cuXG4gICAgICAgIC8vIE5PVEU6IEl0IG1heSBhZmZlY3Qgc29tZSBjdXN0b20gc2hhcGVzIGEgYml0LiBCdXQgd2UgcHJlZmVyIHRvIGhhdmUgYmV0dGVyIHJlc3VsdCBieSBkZWZhdWx0LlxuICAgICAgICB4OiBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XSArIChoYW5kbGVJbmRleCA/IC0xIDogMSksXG4gICAgICAgIHk6IHNpemVbMV0gLyAyIC0gaGFuZGxlSGVpZ2h0IC8gMlxuICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG4gICAgLy8gRmlsbGVyXG4gICAgZGlzcGxheWJsZXMuZmlsbGVyLnNldFNoYXBlKHtcbiAgICAgIHg6IGhhbmRsZUludGVydmFsWzBdLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiBoYW5kbGVJbnRlcnZhbFsxXSAtIGhhbmRsZUludGVydmFsWzBdLFxuICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgfSk7XG4gICAgdmFyIHZpZXdFeHRlbnQgPSB7XG4gICAgICB4OiBoYW5kbGVJbnRlcnZhbFswXSxcbiAgICAgIHdpZHRoOiBoYW5kbGVJbnRlcnZhbFsxXSAtIGhhbmRsZUludGVydmFsWzBdXG4gICAgfTtcbiAgICAvLyBNb3ZlIGhhbmRsZVxuICAgIGlmIChkaXNwbGF5Ymxlcy5tb3ZlSGFuZGxlKSB7XG4gICAgICBkaXNwbGF5Ymxlcy5tb3ZlSGFuZGxlLnNldFNoYXBlKHZpZXdFeHRlbnQpO1xuICAgICAgZGlzcGxheWJsZXMubW92ZVpvbmUuc2V0U2hhcGUodmlld0V4dGVudCk7XG4gICAgICAvLyBGb3JjZSB1cGRhdGUgcGF0aCBvbiB0aGUgaW52aXNpYmxlIG9iamVjdFxuICAgICAgZGlzcGxheWJsZXMubW92ZVpvbmUuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICBkaXNwbGF5Ymxlcy5tb3ZlSGFuZGxlSWNvbiAmJiBkaXNwbGF5Ymxlcy5tb3ZlSGFuZGxlSWNvbi5hdHRyKCd4Jywgdmlld0V4dGVudC54ICsgdmlld0V4dGVudC53aWR0aCAvIDIpO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgY2xpcCBwYXRoIG9mIHNoYWRvdy5cbiAgICB2YXIgZGF0YVNoYWRvd1NlZ3MgPSBkaXNwbGF5Ymxlcy5kYXRhU2hhZG93U2VncztcbiAgICB2YXIgc2VnSW50ZXJ2YWxzID0gWzAsIGhhbmRsZUludGVydmFsWzBdLCBoYW5kbGVJbnRlcnZhbFsxXSwgc2l6ZVswXV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhU2hhZG93U2Vncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlZ0dyb3VwID0gZGF0YVNoYWRvd1NlZ3NbaV07XG4gICAgICB2YXIgY2xpcFBhdGggPSBzZWdHcm91cC5nZXRDbGlwUGF0aCgpO1xuICAgICAgaWYgKCFjbGlwUGF0aCkge1xuICAgICAgICBjbGlwUGF0aCA9IG5ldyBncmFwaGljLlJlY3QoKTtcbiAgICAgICAgc2VnR3JvdXAuc2V0Q2xpcFBhdGgoY2xpcFBhdGgpO1xuICAgICAgfVxuICAgICAgY2xpcFBhdGguc2V0U2hhcGUoe1xuICAgICAgICB4OiBzZWdJbnRlcnZhbHNbaV0sXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiBzZWdJbnRlcnZhbHNbaSArIDFdIC0gc2VnSW50ZXJ2YWxzW2ldLFxuICAgICAgICBoZWlnaHQ6IHNpemVbMV1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVEYXRhSW5mbyhub25SZWFsdGltZSk7XG4gIH07XG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fdXBkYXRlRGF0YUluZm8gPSBmdW5jdGlvbiAobm9uUmVhbHRpbWUpIHtcbiAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICB2YXIgZGlzcGxheWJsZXMgPSB0aGlzLl9kaXNwbGF5YWJsZXM7XG4gICAgdmFyIGhhbmRsZUxhYmVscyA9IGRpc3BsYXlibGVzLmhhbmRsZUxhYmVscztcbiAgICB2YXIgb3JpZW50ID0gdGhpcy5fb3JpZW50O1xuICAgIHZhciBsYWJlbFRleHRzID0gWycnLCAnJ107XG4gICAgLy8gRklYTUVcbiAgICAvLyBkYXRl5Z6L77yM5pSv5oyBZm9ybWF0dGVy77yMYXV0b2Zvcm1hdHRlcu+8iGVjMiBkYXRlLmdldEF1dG9Gb3JtYXR0ZXLvvIlcbiAgICBpZiAoZGF0YVpvb21Nb2RlbC5nZXQoJ3Nob3dEZXRhaWwnKSkge1xuICAgICAgdmFyIGF4aXNQcm94eSA9IGRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCk7XG4gICAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICAgIHZhciBheGlzID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpLmF4aXM7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgICAgICB2YXIgZGF0YUludGVydmFsID0gbm9uUmVhbHRpbWVcbiAgICAgICAgLy8gU2VlICM0NDM0LCBkYXRhIGFuZCBheGlzIGFyZSBub3QgcHJvY2Vzc2VkIGFuZCByZXNldCB5ZXQgaW4gbm9uLXJlYWx0aW1lIG1vZGUuXG4gICAgICAgID8gYXhpc1Byb3h5LmNhbGN1bGF0ZURhdGFXaW5kb3coe1xuICAgICAgICAgIHN0YXJ0OiByYW5nZVswXSxcbiAgICAgICAgICBlbmQ6IHJhbmdlWzFdXG4gICAgICAgIH0pLnZhbHVlV2luZG93IDogYXhpc1Byb3h5LmdldERhdGFWYWx1ZVdpbmRvdygpO1xuICAgICAgICBsYWJlbFRleHRzID0gW3RoaXMuX2Zvcm1hdExhYmVsKGRhdGFJbnRlcnZhbFswXSwgYXhpcyksIHRoaXMuX2Zvcm1hdExhYmVsKGRhdGFJbnRlcnZhbFsxXSwgYXhpcyldO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3JkZXJlZEhhbmRsZUVuZHMgPSBhc2ModGhpcy5faGFuZGxlRW5kcy5zbGljZSgpKTtcbiAgICBzZXRMYWJlbC5jYWxsKHRoaXMsIDApO1xuICAgIHNldExhYmVsLmNhbGwodGhpcywgMSk7XG4gICAgZnVuY3Rpb24gc2V0TGFiZWwoaGFuZGxlSW5kZXgpIHtcbiAgICAgIC8vIExhYmVsXG4gICAgICAvLyBUZXh0IHNob3VsZCBub3QgdHJhbnNmb3JtIGJ5IGJhckdyb3VwLlxuICAgICAgLy8gSWdub3JlIGhhbmRsZXJzIHRyYW5zZm9ybVxuICAgICAgdmFyIGJhclRyYW5zZm9ybSA9IGdyYXBoaWMuZ2V0VHJhbnNmb3JtKGRpc3BsYXlibGVzLmhhbmRsZXNbaGFuZGxlSW5kZXhdLnBhcmVudCwgdGhpcy5ncm91cCk7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gZ3JhcGhpYy50cmFuc2Zvcm1EaXJlY3Rpb24oaGFuZGxlSW5kZXggPT09IDAgPyAncmlnaHQnIDogJ2xlZnQnLCBiYXJUcmFuc2Zvcm0pO1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2hhbmRsZVdpZHRoIC8gMiArIExBQkVMX0dBUDtcbiAgICAgIHZhciB0ZXh0UG9pbnQgPSBncmFwaGljLmFwcGx5VHJhbnNmb3JtKFtvcmRlcmVkSGFuZGxlRW5kc1toYW5kbGVJbmRleF0gKyAoaGFuZGxlSW5kZXggPT09IDAgPyAtb2Zmc2V0IDogb2Zmc2V0KSwgdGhpcy5fc2l6ZVsxXSAvIDJdLCBiYXJUcmFuc2Zvcm0pO1xuICAgICAgaGFuZGxlTGFiZWxzW2hhbmRsZUluZGV4XS5zZXRTdHlsZSh7XG4gICAgICAgIHg6IHRleHRQb2ludFswXSxcbiAgICAgICAgeTogdGV4dFBvaW50WzFdLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBvcmllbnQgPT09IEhPUklaT05UQUwgPyAnbWlkZGxlJyA6IGRpcmVjdGlvbixcbiAgICAgICAgYWxpZ246IG9yaWVudCA9PT0gSE9SSVpPTlRBTCA/IGRpcmVjdGlvbiA6ICdjZW50ZXInLFxuICAgICAgICB0ZXh0OiBsYWJlbFRleHRzW2hhbmRsZUluZGV4XVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuX2Zvcm1hdExhYmVsID0gZnVuY3Rpb24gKHZhbHVlLCBheGlzKSB7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgdmFyIGxhYmVsRm9ybWF0dGVyID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2xhYmVsRm9ybWF0dGVyJyk7XG4gICAgdmFyIGxhYmVsUHJlY2lzaW9uID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2xhYmVsUHJlY2lzaW9uJyk7XG4gICAgaWYgKGxhYmVsUHJlY2lzaW9uID09IG51bGwgfHwgbGFiZWxQcmVjaXNpb24gPT09ICdhdXRvJykge1xuICAgICAgbGFiZWxQcmVjaXNpb24gPSBheGlzLmdldFBpeGVsUHJlY2lzaW9uKCk7XG4gICAgfVxuICAgIHZhciB2YWx1ZVN0ciA9IHZhbHVlID09IG51bGwgfHwgaXNOYU4odmFsdWUpID8gJydcbiAgICAvLyBGSVhNRSBHbHVlIGNvZGVcbiAgICA6IGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyB8fCBheGlzLnR5cGUgPT09ICd0aW1lJyA/IGF4aXMuc2NhbGUuZ2V0TGFiZWwoe1xuICAgICAgdmFsdWU6IE1hdGgucm91bmQodmFsdWUpXG4gICAgfSlcbiAgICAvLyBwYXJhbSBvZiB0b0ZpeGVkIHNob3VsZCBsZXNzIHRoZW4gMjAuXG4gICAgOiB2YWx1ZS50b0ZpeGVkKE1hdGgubWluKGxhYmVsUHJlY2lzaW9uLCAyMCkpO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGxhYmVsRm9ybWF0dGVyKSA/IGxhYmVsRm9ybWF0dGVyKHZhbHVlLCB2YWx1ZVN0cikgOiBpc1N0cmluZyhsYWJlbEZvcm1hdHRlcikgPyBsYWJlbEZvcm1hdHRlci5yZXBsYWNlKCd7dmFsdWV9JywgdmFsdWVTdHIpIDogdmFsdWVTdHI7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwYXJhbSBpc0VtcGhhc2lzIHRydWU6IHNob3csIGZhbHNlOiBoaWRlXHJcbiAgICovXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fc2hvd0RhdGFJbmZvID0gZnVuY3Rpb24gKGlzRW1waGFzaXMpIHtcbiAgICB2YXIgaGFuZGxlTGFiZWwgPSB0aGlzLmRhdGFab29tTW9kZWwuZ2V0KCdoYW5kbGVMYWJlbCcpIHx8IHt9O1xuICAgIHZhciBub3JtYWxTaG93ID0gaGFuZGxlTGFiZWwuc2hvdyB8fCBmYWxzZTtcbiAgICB2YXIgZW1waGFzaXNIYW5kbGVMYWJlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbC5nZXRNb2RlbChbJ2VtcGhhc2lzJywgJ2hhbmRsZUxhYmVsJ10pO1xuICAgIHZhciBlbXBoYXNpc1Nob3cgPSBlbXBoYXNpc0hhbmRsZUxhYmVsLmdldCgnc2hvdycpIHx8IGZhbHNlO1xuICAgIC8vIERyYWdnaW5nIGlzIGNvbnNpZGVyZWQgYXMgZW1waGFzaXMsIHVubGVzcyBlbXBoYXNpc1Nob3cgaXMgZmFsc2VcbiAgICB2YXIgdG9TaG93ID0gaXNFbXBoYXNpcyB8fCB0aGlzLl9kcmFnZ2luZyA/IGVtcGhhc2lzU2hvdyA6IG5vcm1hbFNob3c7XG4gICAgdmFyIGRpc3BsYXlhYmxlcyA9IHRoaXMuX2Rpc3BsYXlhYmxlcztcbiAgICB2YXIgaGFuZGxlTGFiZWxzID0gZGlzcGxheWFibGVzLmhhbmRsZUxhYmVscztcbiAgICBoYW5kbGVMYWJlbHNbMF0uYXR0cignaW52aXNpYmxlJywgIXRvU2hvdyk7XG4gICAgaGFuZGxlTGFiZWxzWzFdLmF0dHIoJ2ludmlzaWJsZScsICF0b1Nob3cpO1xuICAgIC8vIEhpZ2hsaWdodCBtb3ZlIGhhbmRsZVxuICAgIGRpc3BsYXlhYmxlcy5tb3ZlSGFuZGxlICYmIHRoaXMuYXBpW3RvU2hvdyA/ICdlbnRlckVtcGhhc2lzJyA6ICdsZWF2ZUVtcGhhc2lzJ10oZGlzcGxheWFibGVzLm1vdmVIYW5kbGUsIDEpO1xuICB9O1xuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuX29uRHJhZ01vdmUgPSBmdW5jdGlvbiAoaGFuZGxlSW5kZXgsIGR4LCBkeSwgZXZlbnQpIHtcbiAgICB0aGlzLl9kcmFnZ2luZyA9IHRydWU7XG4gICAgLy8gRm9yIG1vYmlsZSBkZXZpY2UsIHByZXZlbnQgc2NyZWVuIHNsaWRlciBvbiB0aGUgYnV0dG9uLlxuICAgIGV2ZW50VG9vbC5zdG9wKGV2ZW50LmV2ZW50KTtcbiAgICAvLyBUcmFuc2Zvcm0gZHgsIGR5IHRvIGJhciBjb29yZGluYXRpb24uXG4gICAgdmFyIGJhclRyYW5zZm9ybSA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5zbGlkZXJHcm91cC5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuICAgIHZhciB2ZXJ0ZXggPSBncmFwaGljLmFwcGx5VHJhbnNmb3JtKFtkeCwgZHldLCBiYXJUcmFuc2Zvcm0sIHRydWUpO1xuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5fdXBkYXRlSW50ZXJ2YWwoaGFuZGxlSW5kZXgsIHZlcnRleFswXSk7XG4gICAgdmFyIHJlYWx0aW1lID0gdGhpcy5kYXRhWm9vbU1vZGVsLmdldCgncmVhbHRpbWUnKTtcbiAgICB0aGlzLl91cGRhdGVWaWV3KCFyZWFsdGltZSk7XG4gICAgLy8gQXZvaWQgZGlzcGF0Y2ggZGF0YVpvb20gcmVwZWF0bHkgYnV0IHJhbmdlIG5vdCBjaGFuZ2VkLFxuICAgIC8vIHdoaWNoIGNhdXNlIGJhZCB2aXN1YWwgZWZmZWN0IHdoZW4gcHJvZ3Jlc3NpdmUgZW5hYmxlZC5cbiAgICBjaGFuZ2VkICYmIHJlYWx0aW1lICYmIHRoaXMuX2Rpc3BhdGNoWm9vbUFjdGlvbih0cnVlKTtcbiAgfTtcbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl9vbkRyYWdFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9zaG93RGF0YUluZm8oZmFsc2UpO1xuICAgIC8vIFdoaWxlIGluIHJlYWx0aW1lIG1vZGUgYW5kIHN0cmVhbSBtb2RlLCBkaXNwYXRjaCBhY3Rpb24gd2hlblxuICAgIC8vIGRyYWcgZW5kIHdpbGwgY2F1c2UgdGhlIHdob2xlIHZpZXcgcmVyZW5kZXIsIHdoaWNoIGlzIHVubmVjZXNzYXJ5LlxuICAgIHZhciByZWFsdGltZSA9IHRoaXMuZGF0YVpvb21Nb2RlbC5nZXQoJ3JlYWx0aW1lJyk7XG4gICAgIXJlYWx0aW1lICYmIHRoaXMuX2Rpc3BhdGNoWm9vbUFjdGlvbihmYWxzZSk7XG4gIH07XG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fb25DbGlja1BhbmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgdmFyIGxvY2FsUG9pbnQgPSB0aGlzLl9kaXNwbGF5YWJsZXMuc2xpZGVyR3JvdXAudHJhbnNmb3JtQ29vcmRUb0xvY2FsKGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcbiAgICBpZiAobG9jYWxQb2ludFswXSA8IDAgfHwgbG9jYWxQb2ludFswXSA+IHNpemVbMF0gfHwgbG9jYWxQb2ludFsxXSA8IDAgfHwgbG9jYWxQb2ludFsxXSA+IHNpemVbMV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGhhbmRsZUVuZHMgPSB0aGlzLl9oYW5kbGVFbmRzO1xuICAgIHZhciBjZW50ZXIgPSAoaGFuZGxlRW5kc1swXSArIGhhbmRsZUVuZHNbMV0pIC8gMjtcbiAgICB2YXIgY2hhbmdlZCA9IHRoaXMuX3VwZGF0ZUludGVydmFsKCdhbGwnLCBsb2NhbFBvaW50WzBdIC0gY2VudGVyKTtcbiAgICB0aGlzLl91cGRhdGVWaWV3KCk7XG4gICAgY2hhbmdlZCAmJiB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oZmFsc2UpO1xuICB9O1xuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuX29uQnJ1c2hTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHggPSBlLm9mZnNldFg7XG4gICAgdmFyIHkgPSBlLm9mZnNldFk7XG4gICAgdGhpcy5fYnJ1c2hTdGFydCA9IG5ldyBncmFwaGljLlBvaW50KHgsIHkpO1xuICAgIHRoaXMuX2JydXNoaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9icnVzaFN0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgIC8vIHRoaXMuX3VwZGF0ZUJydXNoUmVjdCh4LCB5KTtcbiAgfTtcbiAgU2xpZGVyWm9vbVZpZXcucHJvdG90eXBlLl9vbkJydXNoRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIXRoaXMuX2JydXNoaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBicnVzaFJlY3QgPSB0aGlzLl9kaXNwbGF5YWJsZXMuYnJ1c2hSZWN0O1xuICAgIHRoaXMuX2JydXNoaW5nID0gZmFsc2U7XG4gICAgaWYgKCFicnVzaFJlY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYnJ1c2hSZWN0LmF0dHIoJ2lnbm9yZScsIHRydWUpO1xuICAgIHZhciBicnVzaFNoYXBlID0gYnJ1c2hSZWN0LnNoYXBlO1xuICAgIHZhciBicnVzaEVuZFRpbWUgPSArbmV3IERhdGUoKTtcbiAgICAvLyBjb25zb2xlLmxvZyhicnVzaEVuZFRpbWUgLSB0aGlzLl9icnVzaFN0YXJ0VGltZSk7XG4gICAgaWYgKGJydXNoRW5kVGltZSAtIHRoaXMuX2JydXNoU3RhcnRUaW1lIDwgMjAwICYmIE1hdGguYWJzKGJydXNoU2hhcGUud2lkdGgpIDwgNSkge1xuICAgICAgLy8gV2lsbCB0cmVhdCBpdCBhcyBhIGNsaWNrXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB2aWV3RXh0ZW5kID0gdGhpcy5fZ2V0Vmlld0V4dGVudCgpO1xuICAgIHZhciBwZXJjZW50RXh0ZW50ID0gWzAsIDEwMF07XG4gICAgdGhpcy5fcmFuZ2UgPSBhc2MoW2xpbmVhck1hcChicnVzaFNoYXBlLngsIHZpZXdFeHRlbmQsIHBlcmNlbnRFeHRlbnQsIHRydWUpLCBsaW5lYXJNYXAoYnJ1c2hTaGFwZS54ICsgYnJ1c2hTaGFwZS53aWR0aCwgdmlld0V4dGVuZCwgcGVyY2VudEV4dGVudCwgdHJ1ZSldKTtcbiAgICB0aGlzLl9oYW5kbGVFbmRzID0gW2JydXNoU2hhcGUueCwgYnJ1c2hTaGFwZS54ICsgYnJ1c2hTaGFwZS53aWR0aF07XG4gICAgdGhpcy5fdXBkYXRlVmlldygpO1xuICAgIHRoaXMuX2Rpc3BhdGNoWm9vbUFjdGlvbihmYWxzZSk7XG4gIH07XG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fb25CcnVzaCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHRoaXMuX2JydXNoaW5nKSB7XG4gICAgICAvLyBGb3IgbW9iaWxlIGRldmljZSwgcHJldmVudCBzY3JlZW4gc2xpZGVyIG9uIHRoZSBidXR0b24uXG4gICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgICAgIHRoaXMuX3VwZGF0ZUJydXNoUmVjdChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG4gICAgfVxuICB9O1xuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuX3VwZGF0ZUJydXNoUmVjdCA9IGZ1bmN0aW9uIChtb3VzZVgsIG1vdXNlWSkge1xuICAgIHZhciBkaXNwbGF5YWJsZXMgPSB0aGlzLl9kaXNwbGF5YWJsZXM7XG4gICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgdmFyIGJydXNoUmVjdCA9IGRpc3BsYXlhYmxlcy5icnVzaFJlY3Q7XG4gICAgaWYgKCFicnVzaFJlY3QpIHtcbiAgICAgIGJydXNoUmVjdCA9IGRpc3BsYXlhYmxlcy5icnVzaFJlY3QgPSBuZXcgUmVjdCh7XG4gICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ2JydXNoU3R5bGUnKS5nZXRJdGVtU3R5bGUoKVxuICAgICAgfSk7XG4gICAgICBkaXNwbGF5YWJsZXMuc2xpZGVyR3JvdXAuYWRkKGJydXNoUmVjdCk7XG4gICAgfVxuICAgIGJydXNoUmVjdC5hdHRyKCdpZ25vcmUnLCBmYWxzZSk7XG4gICAgdmFyIGJydXNoU3RhcnQgPSB0aGlzLl9icnVzaFN0YXJ0O1xuICAgIHZhciBzbGlkZXJHcm91cCA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5zbGlkZXJHcm91cDtcbiAgICB2YXIgZW5kUG9pbnQgPSBzbGlkZXJHcm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwobW91c2VYLCBtb3VzZVkpO1xuICAgIHZhciBzdGFydFBvaW50ID0gc2xpZGVyR3JvdXAudHJhbnNmb3JtQ29vcmRUb0xvY2FsKGJydXNoU3RhcnQueCwgYnJ1c2hTdGFydC55KTtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgZW5kUG9pbnRbMF0gPSBNYXRoLm1heChNYXRoLm1pbihzaXplWzBdLCBlbmRQb2ludFswXSksIDApO1xuICAgIGJydXNoUmVjdC5zZXRTaGFwZSh7XG4gICAgICB4OiBzdGFydFBvaW50WzBdLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiBlbmRQb2ludFswXSAtIHN0YXJ0UG9pbnRbMF0sXG4gICAgICBoZWlnaHQ6IHNpemVbMV1cbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVGhpcyBhY3Rpb24gd2lsbCBiZSB0aHJvdHRsZWQuXHJcbiAgICovXG4gIFNsaWRlclpvb21WaWV3LnByb3RvdHlwZS5fZGlzcGF0Y2hab29tQWN0aW9uID0gZnVuY3Rpb24gKHJlYWx0aW1lKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2U7XG4gICAgdGhpcy5hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2RhdGFab29tJyxcbiAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgZGF0YVpvb21JZDogdGhpcy5kYXRhWm9vbU1vZGVsLmlkLFxuICAgICAgYW5pbWF0aW9uOiByZWFsdGltZSA/IFJFQUxUSU1FX0FOSU1BVElPTl9DT05GSUcgOiBudWxsLFxuICAgICAgc3RhcnQ6IHJhbmdlWzBdLFxuICAgICAgZW5kOiByYW5nZVsxXVxuICAgIH0pO1xuICB9O1xuICBTbGlkZXJab29tVmlldy5wcm90b3R5cGUuX2ZpbmRDb29yZFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRmluZCB0aGUgZ3JpZCBjb3JyZXNwb25kaW5nIHRvIHRoZSBmaXJzdCBheGlzIHJlZmVycmVkIGJ5IGRhdGFab29tLlxuICAgIHZhciByZWN0O1xuICAgIHZhciBjb29yZFN5c0luZm9MaXN0ID0gY29sbGVjdFJlZmVyQ29vcmRTeXNNb2RlbEluZm8odGhpcy5kYXRhWm9vbU1vZGVsKS5pbmZvTGlzdDtcbiAgICBpZiAoIXJlY3QgJiYgY29vcmRTeXNJbmZvTGlzdC5sZW5ndGgpIHtcbiAgICAgIHZhciBjb29yZFN5cyA9IGNvb3JkU3lzSW5mb0xpc3RbMF0ubW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgIHJlY3QgPSBjb29yZFN5cy5nZXRSZWN0ICYmIGNvb3JkU3lzLmdldFJlY3QoKTtcbiAgICB9XG4gICAgaWYgKCFyZWN0KSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmFwaS5nZXRXaWR0aCgpO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuYXBpLmdldEhlaWdodCgpO1xuICAgICAgcmVjdCA9IHtcbiAgICAgICAgeDogd2lkdGggKiAwLjIsXG4gICAgICAgIHk6IGhlaWdodCAqIDAuMixcbiAgICAgICAgd2lkdGg6IHdpZHRoICogMC42LFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCAqIDAuNlxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH07XG4gIFNsaWRlclpvb21WaWV3LnR5cGUgPSAnZGF0YVpvb20uc2xpZGVyJztcbiAgcmV0dXJuIFNsaWRlclpvb21WaWV3O1xufShEYXRhWm9vbVZpZXcpO1xuZnVuY3Rpb24gZ2V0T3RoZXJEaW0odGhpc0RpbSkge1xuICAvLyBGSVhNRVxuICAvLyDov5nkuKrpgLvovpHlkoxnZXRPdGhlckF4aXPph4zkuIDoh7TvvIzkvYbmmK/lhpnlnKjov5nph4zmmK/lkKbkuI3lpb1cbiAgdmFyIG1hcCA9IHtcbiAgICB4OiAneScsXG4gICAgeTogJ3gnLFxuICAgIHJhZGl1czogJ2FuZ2xlJyxcbiAgICBhbmdsZTogJ3JhZGl1cydcbiAgfTtcbiAgcmV0dXJuIG1hcFt0aGlzRGltXTtcbn1cbmZ1bmN0aW9uIGdldEN1cnNvcihvcmllbnQpIHtcbiAgcmV0dXJuIG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/ICducy1yZXNpemUnIDogJ2V3LXJlc2l6ZSc7XG59XG5leHBvcnQgZGVmYXVsdCBTbGlkZXJab29tVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBTbGlkZXJab29tTW9kZWwgZnJvbSAnLi9TbGlkZXJab29tTW9kZWwuanMnO1xuaW1wb3J0IFNsaWRlclpvb21WaWV3IGZyb20gJy4vU2xpZGVyWm9vbVZpZXcuanMnO1xuaW1wb3J0IGluc3RhbGxDb21tb24gZnJvbSAnLi9pbnN0YWxsQ29tbW9uLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChTbGlkZXJab29tTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KFNsaWRlclpvb21WaWV3KTtcbiAgaW5zdGFsbENvbW1vbihyZWdpc3RlcnMpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35099\n")},45967:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ install)\n/* harmony export */ });\n/* harmony import */ var _extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3087);\n/* harmony import */ var _installDataZoomInside_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68667);\n/* harmony import */ var _installDataZoomSlider_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35099);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction install(registers) {\n  (0,_extension_js__WEBPACK_IMPORTED_MODULE_0__/* .use */ .Y)(_installDataZoomInside_js__WEBPACK_IMPORTED_MODULE_1__/* .install */ .a);\n  (0,_extension_js__WEBPACK_IMPORTED_MODULE_0__/* .use */ .Y)(_installDataZoomSlider_js__WEBPACK_IMPORTED_MODULE_2__/* .install */ .a);\n  // Do not install \'./dataZoomSelect\',\n  // since it only work for toolbox dataZoom.\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU5NjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2luc3RhbGwuanM/ZDU5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IHVzZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbi5qcyc7XG5pbXBvcnQgeyBpbnN0YWxsIGFzIGluc3RhbGxEYXRhWm9vbUluc2lkZSB9IGZyb20gJy4vaW5zdGFsbERhdGFab29tSW5zaWRlLmpzJztcbmltcG9ydCB7IGluc3RhbGwgYXMgaW5zdGFsbERhdGFab29tU2xpZGVyIH0gZnJvbSAnLi9pbnN0YWxsRGF0YVpvb21TbGlkZXIuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHVzZShpbnN0YWxsRGF0YVpvb21JbnNpZGUpO1xuICB1c2UoaW5zdGFsbERhdGFab29tU2xpZGVyKTtcbiAgLy8gRG8gbm90IGluc3RhbGwgJy4vZGF0YVpvb21TZWxlY3QnLFxuICAvLyBzaW5jZSBpdCBvbmx5IHdvcmsgZm9yIHRvb2xib3ggZGF0YVpvb20uXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///45967\n')},68667:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js\nvar DataZoomModel = __webpack_require__(72012);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/component.js\nvar component = __webpack_require__(12616);\n;// ./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar InsideZoomModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(InsideZoomModel, _super);\n  function InsideZoomModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = InsideZoomModel.type;\n    return _this;\n  }\n  InsideZoomModel.type = 'dataZoom.inside';\n  InsideZoomModel.defaultOption = (0,component/* inheritDefaultOption */.G_)(DataZoomModel/* default */.A.defaultOption, {\n    disabled: false,\n    zoomLock: false,\n    zoomOnMouseWheel: true,\n    moveOnMouseMove: true,\n    moveOnMouseWheel: false,\n    preventDefaultMouseMove: true\n  });\n  return InsideZoomModel;\n}(DataZoomModel/* default */.A);\n/* harmony default export */ const dataZoom_InsideZoomModel = (InsideZoomModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/DataZoomView.js\nvar DataZoomView = __webpack_require__(98248);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/sliderMove.js\nvar sliderMove = __webpack_require__(98983);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/RoamController.js\nvar RoamController = __webpack_require__(81722);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/throttle.js\nvar throttle = __webpack_require__(24711);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/helper.js\nvar helper = __webpack_require__(68686);\n;// ./node_modules/echarts/lib/component/dataZoom/roams.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// Only create one roam controller for each coordinate system.\n// one roam controller might be refered by two inside data zoom\n// components (for example, one for x and one for y). When user\n// pan or zoom, only dispatch one action for those data zoom\n// components.\n\n\n\n\n\nvar inner = (0,model/* makeInner */.$r)();\nfunction setViewInfoToCoordSysRecord(api, dataZoomModel, getRange) {\n  inner(api).coordSysRecordMap.each(function (coordSysRecord) {\n    var dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid);\n    if (dzInfo) {\n      dzInfo.getRange = getRange;\n    }\n  });\n}\nfunction disposeCoordSysRecordIfNeeded(api, dataZoomModel) {\n  var coordSysRecordMap = inner(api).coordSysRecordMap;\n  var coordSysKeyArr = coordSysRecordMap.keys();\n  for (var i = 0; i < coordSysKeyArr.length; i++) {\n    var coordSysKey = coordSysKeyArr[i];\n    var coordSysRecord = coordSysRecordMap.get(coordSysKey);\n    var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;\n    if (dataZoomInfoMap) {\n      var dzUid = dataZoomModel.uid;\n      var dzInfo = dataZoomInfoMap.get(dzUid);\n      if (dzInfo) {\n        dataZoomInfoMap.removeKey(dzUid);\n        if (!dataZoomInfoMap.keys().length) {\n          disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);\n        }\n      }\n    }\n  }\n}\nfunction disposeCoordSysRecord(coordSysRecordMap, coordSysRecord) {\n  if (coordSysRecord) {\n    coordSysRecordMap.removeKey(coordSysRecord.model.uid);\n    var controller = coordSysRecord.controller;\n    controller && controller.dispose();\n  }\n}\nfunction createCoordSysRecord(api, coordSysModel) {\n  // These init props will never change after record created.\n  var coordSysRecord = {\n    model: coordSysModel,\n    containsPoint: (0,util.curry)(containsPoint, coordSysModel),\n    dispatchAction: (0,util.curry)(dispatchAction, api),\n    dataZoomInfoMap: null,\n    controller: null\n  };\n  // Must not do anything depends on coordSysRecord outside the event handler here,\n  // because coordSysRecord not completed yet.\n  var controller = coordSysRecord.controller = new RoamController/* default */.A(api.getZr());\n  (0,util.each)(['pan', 'zoom', 'scrollMove'], function (eventName) {\n    controller.on(eventName, function (event) {\n      var batch = [];\n      coordSysRecord.dataZoomInfoMap.each(function (dzInfo) {\n        // Check whether the behaviors (zoomOnMouseWheel, moveOnMouseMove,\n        // moveOnMouseWheel, ...) enabled.\n        if (!event.isAvailableBehavior(dzInfo.model.option)) {\n          return;\n        }\n        var method = (dzInfo.getRange || {})[eventName];\n        var range = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event);\n        !dzInfo.model.get('disabled', true) && range && batch.push({\n          dataZoomId: dzInfo.model.id,\n          start: range[0],\n          end: range[1]\n        });\n      });\n      batch.length && coordSysRecord.dispatchAction(batch);\n    });\n  });\n  return coordSysRecord;\n}\n/**\r\n * This action will be throttled.\r\n */\nfunction dispatchAction(api, batch) {\n  if (!api.isDisposed()) {\n    api.dispatchAction({\n      type: 'dataZoom',\n      animation: {\n        easing: 'cubicOut',\n        duration: 100\n      },\n      batch: batch\n    });\n  }\n}\nfunction containsPoint(coordSysModel, e, x, y) {\n  return coordSysModel.coordinateSystem.containPoint([x, y]);\n}\n/**\r\n * Merge roamController settings when multiple dataZooms share one roamController.\r\n */\nfunction mergeControllerParams(dataZoomInfoMap) {\n  var controlType;\n  // DO NOT use reserved word (true, false, undefined) as key literally. Even if encapsulated\n  // as string, it is probably revert to reserved word by compress tool. See #7411.\n  var prefix = 'type_';\n  var typePriority = {\n    'type_true': 2,\n    'type_move': 1,\n    'type_false': 0,\n    'type_undefined': -1\n  };\n  var preventDefaultMouseMove = true;\n  dataZoomInfoMap.each(function (dataZoomInfo) {\n    var dataZoomModel = dataZoomInfo.model;\n    var oneType = dataZoomModel.get('disabled', true) ? false : dataZoomModel.get('zoomLock', true) ? 'move' : true;\n    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {\n      controlType = oneType;\n    }\n    // Prevent default move event by default. If one false, do not prevent. Otherwise\n    // users may be confused why it does not work when multiple insideZooms exist.\n    preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get('preventDefaultMouseMove', true);\n  });\n  return {\n    controlType: controlType,\n    opt: {\n      // RoamController will enable all of these functionalities,\n      // and the final behavior is determined by its event listener\n      // provided by each inside zoom.\n      zoomOnMouseWheel: true,\n      moveOnMouseMove: true,\n      moveOnMouseWheel: true,\n      preventDefaultMouseMove: !!preventDefaultMouseMove\n    }\n  };\n}\nfunction installDataZoomRoamProcessor(registers) {\n  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, function (ecModel, api) {\n    var apiInner = inner(api);\n    var coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = (0,util.createHashMap)());\n    coordSysRecordMap.each(function (coordSysRecord) {\n      // `coordSysRecordMap` always exists (because it holds the `roam controller`, which should\n      // better not re-create each time), but clear `dataZoomInfoMap` each round of the workflow.\n      coordSysRecord.dataZoomInfoMap = null;\n    });\n    ecModel.eachComponent({\n      mainType: 'dataZoom',\n      subType: 'inside'\n    }, function (dataZoomModel) {\n      var dzReferCoordSysWrap = (0,helper/* collectReferCoordSysModelInfo */.es)(dataZoomModel);\n      (0,util.each)(dzReferCoordSysWrap.infoList, function (dzCoordSysInfo) {\n        var coordSysUid = dzCoordSysInfo.model.uid;\n        var coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api, dzCoordSysInfo.model));\n        var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = (0,util.createHashMap)());\n        // Notice these props might be changed each time for a single dataZoomModel.\n        dataZoomInfoMap.set(dataZoomModel.uid, {\n          dzReferCoordSysInfo: dzCoordSysInfo,\n          model: dataZoomModel,\n          getRange: null\n        });\n      });\n    });\n    // (1) Merge dataZoom settings for each coord sys and set to the roam controller.\n    // (2) Clear coord sys if not refered by any dataZoom.\n    coordSysRecordMap.each(function (coordSysRecord) {\n      var controller = coordSysRecord.controller;\n      var firstDzInfo;\n      var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;\n      if (dataZoomInfoMap) {\n        var firstDzKey = dataZoomInfoMap.keys()[0];\n        if (firstDzKey != null) {\n          firstDzInfo = dataZoomInfoMap.get(firstDzKey);\n        }\n      }\n      if (!firstDzInfo) {\n        disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);\n        return;\n      }\n      var controllerParams = mergeControllerParams(dataZoomInfoMap);\n      controller.enable(controllerParams.controlType, controllerParams.opt);\n      controller.setPointerChecker(coordSysRecord.containsPoint);\n      throttle/* createOrUpdate */.N(coordSysRecord, 'dispatchAction', firstDzInfo.model.get('throttle', true), 'fixRate');\n    });\n  });\n}\n;// ./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar InsideZoomView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(InsideZoomView, _super);\n  function InsideZoomView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = 'dataZoom.inside';\n    return _this;\n  }\n  InsideZoomView.prototype.render = function (dataZoomModel, ecModel, api) {\n    _super.prototype.render.apply(this, arguments);\n    if (dataZoomModel.noTarget()) {\n      this._clear();\n      return;\n    }\n    // Hence the `throttle` util ensures to preserve command order,\n    // here simply updating range all the time will not cause missing\n    // any of the the roam change.\n    this.range = dataZoomModel.getPercentRange();\n    // Reset controllers.\n    setViewInfoToCoordSysRecord(api, dataZoomModel, {\n      pan: (0,util.bind)(getRangeHandlers.pan, this),\n      zoom: (0,util.bind)(getRangeHandlers.zoom, this),\n      scrollMove: (0,util.bind)(getRangeHandlers.scrollMove, this)\n    });\n  };\n  InsideZoomView.prototype.dispose = function () {\n    this._clear();\n    _super.prototype.dispose.apply(this, arguments);\n  };\n  InsideZoomView.prototype._clear = function () {\n    disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel);\n    this.range = null;\n  };\n  InsideZoomView.type = 'dataZoom.inside';\n  return InsideZoomView;\n}(DataZoomView/* default */.A);\nvar getRangeHandlers = {\n  zoom: function (coordSysInfo, coordSysMainType, controller, e) {\n    var lastRange = this.range;\n    var range = lastRange.slice();\n    // Calculate transform by the first axis.\n    var axisModel = coordSysInfo.axisModels[0];\n    if (!axisModel) {\n      return;\n    }\n    var directionInfo = getDirectionInfo[coordSysMainType](null, [e.originX, e.originY], axisModel, controller, coordSysInfo);\n    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n    var scale = Math.max(1 / e.scale, 0);\n    range[0] = (range[0] - percentPoint) * scale + percentPoint;\n    range[1] = (range[1] - percentPoint) * scale + percentPoint;\n    // Restrict range.\n    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    (0,sliderMove/* default */.A)(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);\n    this.range = range;\n    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {\n      return range;\n    }\n  },\n  pan: makeMover(function (range, axisModel, coordSysInfo, coordSysMainType, controller, e) {\n    var directionInfo = getDirectionInfo[coordSysMainType]([e.oldX, e.oldY], [e.newX, e.newY], axisModel, controller, coordSysInfo);\n    return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;\n  }),\n  scrollMove: makeMover(function (range, axisModel, coordSysInfo, coordSysMainType, controller, e) {\n    var directionInfo = getDirectionInfo[coordSysMainType]([0, 0], [e.scrollDelta, e.scrollDelta], axisModel, controller, coordSysInfo);\n    return directionInfo.signal * (range[1] - range[0]) * e.scrollDelta;\n  })\n};\nfunction makeMover(getPercentDelta) {\n  return function (coordSysInfo, coordSysMainType, controller, e) {\n    var lastRange = this.range;\n    var range = lastRange.slice();\n    // Calculate transform by the first axis.\n    var axisModel = coordSysInfo.axisModels[0];\n    if (!axisModel) {\n      return;\n    }\n    var percentDelta = getPercentDelta(range, axisModel, coordSysInfo, coordSysMainType, controller, e);\n    (0,sliderMove/* default */.A)(percentDelta, range, [0, 100], 'all');\n    this.range = range;\n    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {\n      return range;\n    }\n  };\n}\nvar getDirectionInfo = {\n  grid: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var rect = coordSysInfo.model.coordinateSystem.getRect();\n    oldPoint = oldPoint || [0, 0];\n    if (axis.dim === 'x') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // axis.dim === 'y'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n    return ret;\n  },\n  polar: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var polar = coordSysInfo.model.coordinateSystem;\n    var radiusExtent = polar.getRadiusAxis().getExtent();\n    var angleExtent = polar.getAngleAxis().getExtent();\n    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n    newPoint = polar.pointToCoord(newPoint);\n    if (axisModel.mainType === 'radiusAxis') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);\n      // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);\n      ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n      ret.pixelStart = radiusExtent[0];\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'angleAxis'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);\n      // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);\n      ret.pixelLength = angleExtent[1] - angleExtent[0];\n      ret.pixelStart = angleExtent[0];\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n    return ret;\n  },\n  singleAxis: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {\n    var axis = axisModel.axis;\n    var rect = coordSysInfo.model.coordinateSystem.getRect();\n    var ret = {};\n    oldPoint = oldPoint || [0, 0];\n    if (axis.orient === 'horizontal') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'vertical'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n    return ret;\n  }\n};\n/* harmony default export */ const dataZoom_InsideZoomView = (InsideZoomView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/installCommon.js + 3 modules\nvar installCommon = __webpack_require__(33820);\n;// ./node_modules/echarts/lib/component/dataZoom/installDataZoomInside.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nfunction install(registers) {\n  (0,installCommon/* default */.A)(registers);\n  registers.registerComponentModel(dataZoom_InsideZoomModel);\n  registers.registerComponentView(dataZoom_InsideZoomView);\n  installDataZoomRoamProcessor(registers);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg2NjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21Nb2RlbC5qcz81NjI3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vcm9hbXMuanM/Y2Q5NiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21WaWV3LmpzPzVmNmUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9pbnN0YWxsRGF0YVpvb21JbnNpZGUuanM/MTg0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IERhdGFab29tTW9kZWwgZnJvbSAnLi9EYXRhWm9vbU1vZGVsLmpzJztcbmltcG9ydCB7IGluaGVyaXREZWZhdWx0T3B0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbC9jb21wb25lbnQuanMnO1xudmFyIEluc2lkZVpvb21Nb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhJbnNpZGVab29tTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEluc2lkZVpvb21Nb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gSW5zaWRlWm9vbU1vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEluc2lkZVpvb21Nb2RlbC50eXBlID0gJ2RhdGFab29tLmluc2lkZSc7XG4gIEluc2lkZVpvb21Nb2RlbC5kZWZhdWx0T3B0aW9uID0gaW5oZXJpdERlZmF1bHRPcHRpb24oRGF0YVpvb21Nb2RlbC5kZWZhdWx0T3B0aW9uLCB7XG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIHpvb21Mb2NrOiBmYWxzZSxcbiAgICB6b29tT25Nb3VzZVdoZWVsOiB0cnVlLFxuICAgIG1vdmVPbk1vdXNlTW92ZTogdHJ1ZSxcbiAgICBtb3ZlT25Nb3VzZVdoZWVsOiBmYWxzZSxcbiAgICBwcmV2ZW50RGVmYXVsdE1vdXNlTW92ZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIEluc2lkZVpvb21Nb2RlbDtcbn0oRGF0YVpvb21Nb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBJbnNpZGVab29tTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG4vLyBPbmx5IGNyZWF0ZSBvbmUgcm9hbSBjb250cm9sbGVyIGZvciBlYWNoIGNvb3JkaW5hdGUgc3lzdGVtLlxuLy8gb25lIHJvYW0gY29udHJvbGxlciBtaWdodCBiZSByZWZlcmVkIGJ5IHR3byBpbnNpZGUgZGF0YSB6b29tXG4vLyBjb21wb25lbnRzIChmb3IgZXhhbXBsZSwgb25lIGZvciB4IGFuZCBvbmUgZm9yIHkpLiBXaGVuIHVzZXJcbi8vIHBhbiBvciB6b29tLCBvbmx5IGRpc3BhdGNoIG9uZSBhY3Rpb24gZm9yIHRob3NlIGRhdGEgem9vbVxuLy8gY29tcG9uZW50cy5cbmltcG9ydCBSb2FtQ29udHJvbGxlciBmcm9tICcuLi8uLi9jb21wb25lbnQvaGVscGVyL1JvYW1Db250cm9sbGVyLmpzJztcbmltcG9ydCAqIGFzIHRocm90dGxlVXRpbCBmcm9tICcuLi8uLi91dGlsL3Rocm90dGxlLmpzJztcbmltcG9ydCB7IG1ha2VJbm5lciB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xuaW1wb3J0IHsgZWFjaCwgY3VycnksIGNyZWF0ZUhhc2hNYXAgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgY29sbGVjdFJlZmVyQ29vcmRTeXNNb2RlbEluZm8gfSBmcm9tICcuL2hlbHBlci5qcyc7XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbmV4cG9ydCBmdW5jdGlvbiBzZXRWaWV3SW5mb1RvQ29vcmRTeXNSZWNvcmQoYXBpLCBkYXRhWm9vbU1vZGVsLCBnZXRSYW5nZSkge1xuICBpbm5lcihhcGkpLmNvb3JkU3lzUmVjb3JkTWFwLmVhY2goZnVuY3Rpb24gKGNvb3JkU3lzUmVjb3JkKSB7XG4gICAgdmFyIGR6SW5mbyA9IGNvb3JkU3lzUmVjb3JkLmRhdGFab29tSW5mb01hcC5nZXQoZGF0YVpvb21Nb2RlbC51aWQpO1xuICAgIGlmIChkekluZm8pIHtcbiAgICAgIGR6SW5mby5nZXRSYW5nZSA9IGdldFJhbmdlO1xuICAgIH1cbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGlzcG9zZUNvb3JkU3lzUmVjb3JkSWZOZWVkZWQoYXBpLCBkYXRhWm9vbU1vZGVsKSB7XG4gIHZhciBjb29yZFN5c1JlY29yZE1hcCA9IGlubmVyKGFwaSkuY29vcmRTeXNSZWNvcmRNYXA7XG4gIHZhciBjb29yZFN5c0tleUFyciA9IGNvb3JkU3lzUmVjb3JkTWFwLmtleXMoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZFN5c0tleUFyci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb29yZFN5c0tleSA9IGNvb3JkU3lzS2V5QXJyW2ldO1xuICAgIHZhciBjb29yZFN5c1JlY29yZCA9IGNvb3JkU3lzUmVjb3JkTWFwLmdldChjb29yZFN5c0tleSk7XG4gICAgdmFyIGRhdGFab29tSW5mb01hcCA9IGNvb3JkU3lzUmVjb3JkLmRhdGFab29tSW5mb01hcDtcbiAgICBpZiAoZGF0YVpvb21JbmZvTWFwKSB7XG4gICAgICB2YXIgZHpVaWQgPSBkYXRhWm9vbU1vZGVsLnVpZDtcbiAgICAgIHZhciBkekluZm8gPSBkYXRhWm9vbUluZm9NYXAuZ2V0KGR6VWlkKTtcbiAgICAgIGlmIChkekluZm8pIHtcbiAgICAgICAgZGF0YVpvb21JbmZvTWFwLnJlbW92ZUtleShkelVpZCk7XG4gICAgICAgIGlmICghZGF0YVpvb21JbmZvTWFwLmtleXMoKS5sZW5ndGgpIHtcbiAgICAgICAgICBkaXNwb3NlQ29vcmRTeXNSZWNvcmQoY29vcmRTeXNSZWNvcmRNYXAsIGNvb3JkU3lzUmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGlzcG9zZUNvb3JkU3lzUmVjb3JkKGNvb3JkU3lzUmVjb3JkTWFwLCBjb29yZFN5c1JlY29yZCkge1xuICBpZiAoY29vcmRTeXNSZWNvcmQpIHtcbiAgICBjb29yZFN5c1JlY29yZE1hcC5yZW1vdmVLZXkoY29vcmRTeXNSZWNvcmQubW9kZWwudWlkKTtcbiAgICB2YXIgY29udHJvbGxlciA9IGNvb3JkU3lzUmVjb3JkLmNvbnRyb2xsZXI7XG4gICAgY29udHJvbGxlciAmJiBjb250cm9sbGVyLmRpc3Bvc2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ29vcmRTeXNSZWNvcmQoYXBpLCBjb29yZFN5c01vZGVsKSB7XG4gIC8vIFRoZXNlIGluaXQgcHJvcHMgd2lsbCBuZXZlciBjaGFuZ2UgYWZ0ZXIgcmVjb3JkIGNyZWF0ZWQuXG4gIHZhciBjb29yZFN5c1JlY29yZCA9IHtcbiAgICBtb2RlbDogY29vcmRTeXNNb2RlbCxcbiAgICBjb250YWluc1BvaW50OiBjdXJyeShjb250YWluc1BvaW50LCBjb29yZFN5c01vZGVsKSxcbiAgICBkaXNwYXRjaEFjdGlvbjogY3VycnkoZGlzcGF0Y2hBY3Rpb24sIGFwaSksXG4gICAgZGF0YVpvb21JbmZvTWFwOiBudWxsLFxuICAgIGNvbnRyb2xsZXI6IG51bGxcbiAgfTtcbiAgLy8gTXVzdCBub3QgZG8gYW55dGhpbmcgZGVwZW5kcyBvbiBjb29yZFN5c1JlY29yZCBvdXRzaWRlIHRoZSBldmVudCBoYW5kbGVyIGhlcmUsXG4gIC8vIGJlY2F1c2UgY29vcmRTeXNSZWNvcmQgbm90IGNvbXBsZXRlZCB5ZXQuXG4gIHZhciBjb250cm9sbGVyID0gY29vcmRTeXNSZWNvcmQuY29udHJvbGxlciA9IG5ldyBSb2FtQ29udHJvbGxlcihhcGkuZ2V0WnIoKSk7XG4gIGVhY2goWydwYW4nLCAnem9vbScsICdzY3JvbGxNb3ZlJ10sIGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICBjb250cm9sbGVyLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgYmF0Y2ggPSBbXTtcbiAgICAgIGNvb3JkU3lzUmVjb3JkLmRhdGFab29tSW5mb01hcC5lYWNoKGZ1bmN0aW9uIChkekluZm8pIHtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgYmVoYXZpb3JzICh6b29tT25Nb3VzZVdoZWVsLCBtb3ZlT25Nb3VzZU1vdmUsXG4gICAgICAgIC8vIG1vdmVPbk1vdXNlV2hlZWwsIC4uLikgZW5hYmxlZC5cbiAgICAgICAgaWYgKCFldmVudC5pc0F2YWlsYWJsZUJlaGF2aW9yKGR6SW5mby5tb2RlbC5vcHRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXRob2QgPSAoZHpJbmZvLmdldFJhbmdlIHx8IHt9KVtldmVudE5hbWVdO1xuICAgICAgICB2YXIgcmFuZ2UgPSBtZXRob2QgJiYgbWV0aG9kKGR6SW5mby5kelJlZmVyQ29vcmRTeXNJbmZvLCBjb29yZFN5c1JlY29yZC5tb2RlbC5tYWluVHlwZSwgY29vcmRTeXNSZWNvcmQuY29udHJvbGxlciwgZXZlbnQpO1xuICAgICAgICAhZHpJbmZvLm1vZGVsLmdldCgnZGlzYWJsZWQnLCB0cnVlKSAmJiByYW5nZSAmJiBiYXRjaC5wdXNoKHtcbiAgICAgICAgICBkYXRhWm9vbUlkOiBkekluZm8ubW9kZWwuaWQsXG4gICAgICAgICAgc3RhcnQ6IHJhbmdlWzBdLFxuICAgICAgICAgIGVuZDogcmFuZ2VbMV1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGJhdGNoLmxlbmd0aCAmJiBjb29yZFN5c1JlY29yZC5kaXNwYXRjaEFjdGlvbihiYXRjaCk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gY29vcmRTeXNSZWNvcmQ7XG59XG4vKipcclxuICogVGhpcyBhY3Rpb24gd2lsbCBiZSB0aHJvdHRsZWQuXHJcbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oYXBpLCBiYXRjaCkge1xuICBpZiAoIWFwaS5pc0Rpc3Bvc2VkKCkpIHtcbiAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2RhdGFab29tJyxcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICBlYXNpbmc6ICdjdWJpY091dCcsXG4gICAgICAgIGR1cmF0aW9uOiAxMDBcbiAgICAgIH0sXG4gICAgICBiYXRjaDogYmF0Y2hcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY29udGFpbnNQb2ludChjb29yZFN5c01vZGVsLCBlLCB4LCB5KSB7XG4gIHJldHVybiBjb29yZFN5c01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uY29udGFpblBvaW50KFt4LCB5XSk7XG59XG4vKipcclxuICogTWVyZ2Ugcm9hbUNvbnRyb2xsZXIgc2V0dGluZ3Mgd2hlbiBtdWx0aXBsZSBkYXRhWm9vbXMgc2hhcmUgb25lIHJvYW1Db250cm9sbGVyLlxyXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQ29udHJvbGxlclBhcmFtcyhkYXRhWm9vbUluZm9NYXApIHtcbiAgdmFyIGNvbnRyb2xUeXBlO1xuICAvLyBETyBOT1QgdXNlIHJlc2VydmVkIHdvcmQgKHRydWUsIGZhbHNlLCB1bmRlZmluZWQpIGFzIGtleSBsaXRlcmFsbHkuIEV2ZW4gaWYgZW5jYXBzdWxhdGVkXG4gIC8vIGFzIHN0cmluZywgaXQgaXMgcHJvYmFibHkgcmV2ZXJ0IHRvIHJlc2VydmVkIHdvcmQgYnkgY29tcHJlc3MgdG9vbC4gU2VlICM3NDExLlxuICB2YXIgcHJlZml4ID0gJ3R5cGVfJztcbiAgdmFyIHR5cGVQcmlvcml0eSA9IHtcbiAgICAndHlwZV90cnVlJzogMixcbiAgICAndHlwZV9tb3ZlJzogMSxcbiAgICAndHlwZV9mYWxzZSc6IDAsXG4gICAgJ3R5cGVfdW5kZWZpbmVkJzogLTFcbiAgfTtcbiAgdmFyIHByZXZlbnREZWZhdWx0TW91c2VNb3ZlID0gdHJ1ZTtcbiAgZGF0YVpvb21JbmZvTWFwLmVhY2goZnVuY3Rpb24gKGRhdGFab29tSW5mbykge1xuICAgIHZhciBkYXRhWm9vbU1vZGVsID0gZGF0YVpvb21JbmZvLm1vZGVsO1xuICAgIHZhciBvbmVUeXBlID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2Rpc2FibGVkJywgdHJ1ZSkgPyBmYWxzZSA6IGRhdGFab29tTW9kZWwuZ2V0KCd6b29tTG9jaycsIHRydWUpID8gJ21vdmUnIDogdHJ1ZTtcbiAgICBpZiAodHlwZVByaW9yaXR5W3ByZWZpeCArIG9uZVR5cGVdID4gdHlwZVByaW9yaXR5W3ByZWZpeCArIGNvbnRyb2xUeXBlXSkge1xuICAgICAgY29udHJvbFR5cGUgPSBvbmVUeXBlO1xuICAgIH1cbiAgICAvLyBQcmV2ZW50IGRlZmF1bHQgbW92ZSBldmVudCBieSBkZWZhdWx0LiBJZiBvbmUgZmFsc2UsIGRvIG5vdCBwcmV2ZW50LiBPdGhlcndpc2VcbiAgICAvLyB1c2VycyBtYXkgYmUgY29uZnVzZWQgd2h5IGl0IGRvZXMgbm90IHdvcmsgd2hlbiBtdWx0aXBsZSBpbnNpZGVab29tcyBleGlzdC5cbiAgICBwcmV2ZW50RGVmYXVsdE1vdXNlTW92ZSA9IHByZXZlbnREZWZhdWx0TW91c2VNb3ZlICYmIGRhdGFab29tTW9kZWwuZ2V0KCdwcmV2ZW50RGVmYXVsdE1vdXNlTW92ZScsIHRydWUpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjb250cm9sVHlwZTogY29udHJvbFR5cGUsXG4gICAgb3B0OiB7XG4gICAgICAvLyBSb2FtQ29udHJvbGxlciB3aWxsIGVuYWJsZSBhbGwgb2YgdGhlc2UgZnVuY3Rpb25hbGl0aWVzLFxuICAgICAgLy8gYW5kIHRoZSBmaW5hbCBiZWhhdmlvciBpcyBkZXRlcm1pbmVkIGJ5IGl0cyBldmVudCBsaXN0ZW5lclxuICAgICAgLy8gcHJvdmlkZWQgYnkgZWFjaCBpbnNpZGUgem9vbS5cbiAgICAgIHpvb21Pbk1vdXNlV2hlZWw6IHRydWUsXG4gICAgICBtb3ZlT25Nb3VzZU1vdmU6IHRydWUsXG4gICAgICBtb3ZlT25Nb3VzZVdoZWVsOiB0cnVlLFxuICAgICAgcHJldmVudERlZmF1bHRNb3VzZU1vdmU6ICEhcHJldmVudERlZmF1bHRNb3VzZU1vdmVcbiAgICB9XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbERhdGFab29tUm9hbVByb2Nlc3NvcihyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJvY2Vzc29yKHJlZ2lzdGVycy5QUklPUklUWS5QUk9DRVNTT1IuRklMVEVSLCBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGFwaUlubmVyID0gaW5uZXIoYXBpKTtcbiAgICB2YXIgY29vcmRTeXNSZWNvcmRNYXAgPSBhcGlJbm5lci5jb29yZFN5c1JlY29yZE1hcCB8fCAoYXBpSW5uZXIuY29vcmRTeXNSZWNvcmRNYXAgPSBjcmVhdGVIYXNoTWFwKCkpO1xuICAgIGNvb3JkU3lzUmVjb3JkTWFwLmVhY2goZnVuY3Rpb24gKGNvb3JkU3lzUmVjb3JkKSB7XG4gICAgICAvLyBgY29vcmRTeXNSZWNvcmRNYXBgIGFsd2F5cyBleGlzdHMgKGJlY2F1c2UgaXQgaG9sZHMgdGhlIGByb2FtIGNvbnRyb2xsZXJgLCB3aGljaCBzaG91bGRcbiAgICAgIC8vIGJldHRlciBub3QgcmUtY3JlYXRlIGVhY2ggdGltZSksIGJ1dCBjbGVhciBgZGF0YVpvb21JbmZvTWFwYCBlYWNoIHJvdW5kIG9mIHRoZSB3b3JrZmxvdy5cbiAgICAgIGNvb3JkU3lzUmVjb3JkLmRhdGFab29tSW5mb01hcCA9IG51bGw7XG4gICAgfSk7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiAnZGF0YVpvb20nLFxuICAgICAgc3ViVHlwZTogJ2luc2lkZSdcbiAgICB9LCBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCkge1xuICAgICAgdmFyIGR6UmVmZXJDb29yZFN5c1dyYXAgPSBjb2xsZWN0UmVmZXJDb29yZFN5c01vZGVsSW5mbyhkYXRhWm9vbU1vZGVsKTtcbiAgICAgIGVhY2goZHpSZWZlckNvb3JkU3lzV3JhcC5pbmZvTGlzdCwgZnVuY3Rpb24gKGR6Q29vcmRTeXNJbmZvKSB7XG4gICAgICAgIHZhciBjb29yZFN5c1VpZCA9IGR6Q29vcmRTeXNJbmZvLm1vZGVsLnVpZDtcbiAgICAgICAgdmFyIGNvb3JkU3lzUmVjb3JkID0gY29vcmRTeXNSZWNvcmRNYXAuZ2V0KGNvb3JkU3lzVWlkKSB8fCBjb29yZFN5c1JlY29yZE1hcC5zZXQoY29vcmRTeXNVaWQsIGNyZWF0ZUNvb3JkU3lzUmVjb3JkKGFwaSwgZHpDb29yZFN5c0luZm8ubW9kZWwpKTtcbiAgICAgICAgdmFyIGRhdGFab29tSW5mb01hcCA9IGNvb3JkU3lzUmVjb3JkLmRhdGFab29tSW5mb01hcCB8fCAoY29vcmRTeXNSZWNvcmQuZGF0YVpvb21JbmZvTWFwID0gY3JlYXRlSGFzaE1hcCgpKTtcbiAgICAgICAgLy8gTm90aWNlIHRoZXNlIHByb3BzIG1pZ2h0IGJlIGNoYW5nZWQgZWFjaCB0aW1lIGZvciBhIHNpbmdsZSBkYXRhWm9vbU1vZGVsLlxuICAgICAgICBkYXRhWm9vbUluZm9NYXAuc2V0KGRhdGFab29tTW9kZWwudWlkLCB7XG4gICAgICAgICAgZHpSZWZlckNvb3JkU3lzSW5mbzogZHpDb29yZFN5c0luZm8sXG4gICAgICAgICAgbW9kZWw6IGRhdGFab29tTW9kZWwsXG4gICAgICAgICAgZ2V0UmFuZ2U6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyAoMSkgTWVyZ2UgZGF0YVpvb20gc2V0dGluZ3MgZm9yIGVhY2ggY29vcmQgc3lzIGFuZCBzZXQgdG8gdGhlIHJvYW0gY29udHJvbGxlci5cbiAgICAvLyAoMikgQ2xlYXIgY29vcmQgc3lzIGlmIG5vdCByZWZlcmVkIGJ5IGFueSBkYXRhWm9vbS5cbiAgICBjb29yZFN5c1JlY29yZE1hcC5lYWNoKGZ1bmN0aW9uIChjb29yZFN5c1JlY29yZCkge1xuICAgICAgdmFyIGNvbnRyb2xsZXIgPSBjb29yZFN5c1JlY29yZC5jb250cm9sbGVyO1xuICAgICAgdmFyIGZpcnN0RHpJbmZvO1xuICAgICAgdmFyIGRhdGFab29tSW5mb01hcCA9IGNvb3JkU3lzUmVjb3JkLmRhdGFab29tSW5mb01hcDtcbiAgICAgIGlmIChkYXRhWm9vbUluZm9NYXApIHtcbiAgICAgICAgdmFyIGZpcnN0RHpLZXkgPSBkYXRhWm9vbUluZm9NYXAua2V5cygpWzBdO1xuICAgICAgICBpZiAoZmlyc3REektleSAhPSBudWxsKSB7XG4gICAgICAgICAgZmlyc3REekluZm8gPSBkYXRhWm9vbUluZm9NYXAuZ2V0KGZpcnN0RHpLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZpcnN0RHpJbmZvKSB7XG4gICAgICAgIGRpc3Bvc2VDb29yZFN5c1JlY29yZChjb29yZFN5c1JlY29yZE1hcCwgY29vcmRTeXNSZWNvcmQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY29udHJvbGxlclBhcmFtcyA9IG1lcmdlQ29udHJvbGxlclBhcmFtcyhkYXRhWm9vbUluZm9NYXApO1xuICAgICAgY29udHJvbGxlci5lbmFibGUoY29udHJvbGxlclBhcmFtcy5jb250cm9sVHlwZSwgY29udHJvbGxlclBhcmFtcy5vcHQpO1xuICAgICAgY29udHJvbGxlci5zZXRQb2ludGVyQ2hlY2tlcihjb29yZFN5c1JlY29yZC5jb250YWluc1BvaW50KTtcbiAgICAgIHRocm90dGxlVXRpbC5jcmVhdGVPclVwZGF0ZShjb29yZFN5c1JlY29yZCwgJ2Rpc3BhdGNoQWN0aW9uJywgZmlyc3REekluZm8ubW9kZWwuZ2V0KCd0aHJvdHRsZScsIHRydWUpLCAnZml4UmF0ZScpO1xuICAgIH0pO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IERhdGFab29tVmlldyBmcm9tICcuL0RhdGFab29tVmlldy5qcyc7XG5pbXBvcnQgc2xpZGVyTW92ZSBmcm9tICcuLi9oZWxwZXIvc2xpZGVyTW92ZS5qcyc7XG5pbXBvcnQgKiBhcyByb2FtcyBmcm9tICcuL3JvYW1zLmpzJztcbmltcG9ydCB7IGJpbmQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xudmFyIEluc2lkZVpvb21WaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEluc2lkZVpvb21WaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBJbnNpZGVab29tVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gJ2RhdGFab29tLmluc2lkZSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEluc2lkZVpvb21WaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoZGF0YVpvb21Nb2RlbC5ub1RhcmdldCgpKSB7XG4gICAgICB0aGlzLl9jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBIZW5jZSB0aGUgYHRocm90dGxlYCB1dGlsIGVuc3VyZXMgdG8gcHJlc2VydmUgY29tbWFuZCBvcmRlcixcbiAgICAvLyBoZXJlIHNpbXBseSB1cGRhdGluZyByYW5nZSBhbGwgdGhlIHRpbWUgd2lsbCBub3QgY2F1c2UgbWlzc2luZ1xuICAgIC8vIGFueSBvZiB0aGUgdGhlIHJvYW0gY2hhbmdlLlxuICAgIHRoaXMucmFuZ2UgPSBkYXRhWm9vbU1vZGVsLmdldFBlcmNlbnRSYW5nZSgpO1xuICAgIC8vIFJlc2V0IGNvbnRyb2xsZXJzLlxuICAgIHJvYW1zLnNldFZpZXdJbmZvVG9Db29yZFN5c1JlY29yZChhcGksIGRhdGFab29tTW9kZWwsIHtcbiAgICAgIHBhbjogYmluZChnZXRSYW5nZUhhbmRsZXJzLnBhbiwgdGhpcyksXG4gICAgICB6b29tOiBiaW5kKGdldFJhbmdlSGFuZGxlcnMuem9vbSwgdGhpcyksXG4gICAgICBzY3JvbGxNb3ZlOiBiaW5kKGdldFJhbmdlSGFuZGxlcnMuc2Nyb2xsTW92ZSwgdGhpcylcbiAgICB9KTtcbiAgfTtcbiAgSW5zaWRlWm9vbVZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xlYXIoKTtcbiAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgSW5zaWRlWm9vbVZpZXcucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICByb2Ftcy5kaXNwb3NlQ29vcmRTeXNSZWNvcmRJZk5lZWRlZCh0aGlzLmFwaSwgdGhpcy5kYXRhWm9vbU1vZGVsKTtcbiAgICB0aGlzLnJhbmdlID0gbnVsbDtcbiAgfTtcbiAgSW5zaWRlWm9vbVZpZXcudHlwZSA9ICdkYXRhWm9vbS5pbnNpZGUnO1xuICByZXR1cm4gSW5zaWRlWm9vbVZpZXc7XG59KERhdGFab29tVmlldyk7XG52YXIgZ2V0UmFuZ2VIYW5kbGVycyA9IHtcbiAgem9vbTogZnVuY3Rpb24gKGNvb3JkU3lzSW5mbywgY29vcmRTeXNNYWluVHlwZSwgY29udHJvbGxlciwgZSkge1xuICAgIHZhciBsYXN0UmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgIHZhciByYW5nZSA9IGxhc3RSYW5nZS5zbGljZSgpO1xuICAgIC8vIENhbGN1bGF0ZSB0cmFuc2Zvcm0gYnkgdGhlIGZpcnN0IGF4aXMuXG4gICAgdmFyIGF4aXNNb2RlbCA9IGNvb3JkU3lzSW5mby5heGlzTW9kZWxzWzBdO1xuICAgIGlmICghYXhpc01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkaXJlY3Rpb25JbmZvID0gZ2V0RGlyZWN0aW9uSW5mb1tjb29yZFN5c01haW5UeXBlXShudWxsLCBbZS5vcmlnaW5YLCBlLm9yaWdpblldLCBheGlzTW9kZWwsIGNvbnRyb2xsZXIsIGNvb3JkU3lzSW5mbyk7XG4gICAgdmFyIHBlcmNlbnRQb2ludCA9IChkaXJlY3Rpb25JbmZvLnNpZ25hbCA+IDAgPyBkaXJlY3Rpb25JbmZvLnBpeGVsU3RhcnQgKyBkaXJlY3Rpb25JbmZvLnBpeGVsTGVuZ3RoIC0gZGlyZWN0aW9uSW5mby5waXhlbCA6IGRpcmVjdGlvbkluZm8ucGl4ZWwgLSBkaXJlY3Rpb25JbmZvLnBpeGVsU3RhcnQpIC8gZGlyZWN0aW9uSW5mby5waXhlbExlbmd0aCAqIChyYW5nZVsxXSAtIHJhbmdlWzBdKSArIHJhbmdlWzBdO1xuICAgIHZhciBzY2FsZSA9IE1hdGgubWF4KDEgLyBlLnNjYWxlLCAwKTtcbiAgICByYW5nZVswXSA9IChyYW5nZVswXSAtIHBlcmNlbnRQb2ludCkgKiBzY2FsZSArIHBlcmNlbnRQb2ludDtcbiAgICByYW5nZVsxXSA9IChyYW5nZVsxXSAtIHBlcmNlbnRQb2ludCkgKiBzY2FsZSArIHBlcmNlbnRQb2ludDtcbiAgICAvLyBSZXN0cmljdCByYW5nZS5cbiAgICB2YXIgbWluTWF4U3BhbiA9IHRoaXMuZGF0YVpvb21Nb2RlbC5maW5kUmVwcmVzZW50YXRpdmVBeGlzUHJveHkoKS5nZXRNaW5NYXhTcGFuKCk7XG4gICAgc2xpZGVyTW92ZSgwLCByYW5nZSwgWzAsIDEwMF0sIDAsIG1pbk1heFNwYW4ubWluU3BhbiwgbWluTWF4U3Bhbi5tYXhTcGFuKTtcbiAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgaWYgKGxhc3RSYW5nZVswXSAhPT0gcmFuZ2VbMF0gfHwgbGFzdFJhbmdlWzFdICE9PSByYW5nZVsxXSkge1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgfSxcbiAgcGFuOiBtYWtlTW92ZXIoZnVuY3Rpb24gKHJhbmdlLCBheGlzTW9kZWwsIGNvb3JkU3lzSW5mbywgY29vcmRTeXNNYWluVHlwZSwgY29udHJvbGxlciwgZSkge1xuICAgIHZhciBkaXJlY3Rpb25JbmZvID0gZ2V0RGlyZWN0aW9uSW5mb1tjb29yZFN5c01haW5UeXBlXShbZS5vbGRYLCBlLm9sZFldLCBbZS5uZXdYLCBlLm5ld1ldLCBheGlzTW9kZWwsIGNvbnRyb2xsZXIsIGNvb3JkU3lzSW5mbyk7XG4gICAgcmV0dXJuIGRpcmVjdGlvbkluZm8uc2lnbmFsICogKHJhbmdlWzFdIC0gcmFuZ2VbMF0pICogZGlyZWN0aW9uSW5mby5waXhlbCAvIGRpcmVjdGlvbkluZm8ucGl4ZWxMZW5ndGg7XG4gIH0pLFxuICBzY3JvbGxNb3ZlOiBtYWtlTW92ZXIoZnVuY3Rpb24gKHJhbmdlLCBheGlzTW9kZWwsIGNvb3JkU3lzSW5mbywgY29vcmRTeXNNYWluVHlwZSwgY29udHJvbGxlciwgZSkge1xuICAgIHZhciBkaXJlY3Rpb25JbmZvID0gZ2V0RGlyZWN0aW9uSW5mb1tjb29yZFN5c01haW5UeXBlXShbMCwgMF0sIFtlLnNjcm9sbERlbHRhLCBlLnNjcm9sbERlbHRhXSwgYXhpc01vZGVsLCBjb250cm9sbGVyLCBjb29yZFN5c0luZm8pO1xuICAgIHJldHVybiBkaXJlY3Rpb25JbmZvLnNpZ25hbCAqIChyYW5nZVsxXSAtIHJhbmdlWzBdKSAqIGUuc2Nyb2xsRGVsdGE7XG4gIH0pXG59O1xuZnVuY3Rpb24gbWFrZU1vdmVyKGdldFBlcmNlbnREZWx0YSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvb3JkU3lzSW5mbywgY29vcmRTeXNNYWluVHlwZSwgY29udHJvbGxlciwgZSkge1xuICAgIHZhciBsYXN0UmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgIHZhciByYW5nZSA9IGxhc3RSYW5nZS5zbGljZSgpO1xuICAgIC8vIENhbGN1bGF0ZSB0cmFuc2Zvcm0gYnkgdGhlIGZpcnN0IGF4aXMuXG4gICAgdmFyIGF4aXNNb2RlbCA9IGNvb3JkU3lzSW5mby5heGlzTW9kZWxzWzBdO1xuICAgIGlmICghYXhpc01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwZXJjZW50RGVsdGEgPSBnZXRQZXJjZW50RGVsdGEocmFuZ2UsIGF4aXNNb2RlbCwgY29vcmRTeXNJbmZvLCBjb29yZFN5c01haW5UeXBlLCBjb250cm9sbGVyLCBlKTtcbiAgICBzbGlkZXJNb3ZlKHBlcmNlbnREZWx0YSwgcmFuZ2UsIFswLCAxMDBdLCAnYWxsJyk7XG4gICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgIGlmIChsYXN0UmFuZ2VbMF0gIT09IHJhbmdlWzBdIHx8IGxhc3RSYW5nZVsxXSAhPT0gcmFuZ2VbMV0pIHtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gIH07XG59XG52YXIgZ2V0RGlyZWN0aW9uSW5mbyA9IHtcbiAgZ3JpZDogZnVuY3Rpb24gKG9sZFBvaW50LCBuZXdQb2ludCwgYXhpc01vZGVsLCBjb250cm9sbGVyLCBjb29yZFN5c0luZm8pIHtcbiAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgIHZhciByZXQgPSB7fTtcbiAgICB2YXIgcmVjdCA9IGNvb3JkU3lzSW5mby5tb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFJlY3QoKTtcbiAgICBvbGRQb2ludCA9IG9sZFBvaW50IHx8IFswLCAwXTtcbiAgICBpZiAoYXhpcy5kaW0gPT09ICd4Jykge1xuICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMF0gLSBvbGRQb2ludFswXTtcbiAgICAgIHJldC5waXhlbExlbmd0aCA9IHJlY3Qud2lkdGg7XG4gICAgICByZXQucGl4ZWxTdGFydCA9IHJlY3QueDtcbiAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAxIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF4aXMuZGltID09PSAneSdcbiAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzFdIC0gb2xkUG9pbnRbMV07XG4gICAgICByZXQucGl4ZWxMZW5ndGggPSByZWN0LmhlaWdodDtcbiAgICAgIHJldC5waXhlbFN0YXJ0ID0gcmVjdC55O1xuICAgICAgcmV0LnNpZ25hbCA9IGF4aXMuaW52ZXJzZSA/IC0xIDogMTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgcG9sYXI6IGZ1bmN0aW9uIChvbGRQb2ludCwgbmV3UG9pbnQsIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRTeXNJbmZvKSB7XG4gICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICB2YXIgcmV0ID0ge307XG4gICAgdmFyIHBvbGFyID0gY29vcmRTeXNJbmZvLm1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIHJhZGl1c0V4dGVudCA9IHBvbGFyLmdldFJhZGl1c0F4aXMoKS5nZXRFeHRlbnQoKTtcbiAgICB2YXIgYW5nbGVFeHRlbnQgPSBwb2xhci5nZXRBbmdsZUF4aXMoKS5nZXRFeHRlbnQoKTtcbiAgICBvbGRQb2ludCA9IG9sZFBvaW50ID8gcG9sYXIucG9pbnRUb0Nvb3JkKG9sZFBvaW50KSA6IFswLCAwXTtcbiAgICBuZXdQb2ludCA9IHBvbGFyLnBvaW50VG9Db29yZChuZXdQb2ludCk7XG4gICAgaWYgKGF4aXNNb2RlbC5tYWluVHlwZSA9PT0gJ3JhZGl1c0F4aXMnKSB7XG4gICAgICByZXQucGl4ZWwgPSBuZXdQb2ludFswXSAtIG9sZFBvaW50WzBdO1xuICAgICAgLy8gcmV0LnBpeGVsTGVuZ3RoID0gTWF0aC5hYnMocmFkaXVzRXh0ZW50WzFdIC0gcmFkaXVzRXh0ZW50WzBdKTtcbiAgICAgIC8vIHJldC5waXhlbFN0YXJ0ID0gTWF0aC5taW4ocmFkaXVzRXh0ZW50WzBdLCByYWRpdXNFeHRlbnRbMV0pO1xuICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gcmFkaXVzRXh0ZW50WzFdIC0gcmFkaXVzRXh0ZW50WzBdO1xuICAgICAgcmV0LnBpeGVsU3RhcnQgPSByYWRpdXNFeHRlbnRbMF07XG4gICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gMSA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAnYW5nbGVBeGlzJ1xuICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMV0gLSBvbGRQb2ludFsxXTtcbiAgICAgIC8vIHJldC5waXhlbExlbmd0aCA9IE1hdGguYWJzKGFuZ2xlRXh0ZW50WzFdIC0gYW5nbGVFeHRlbnRbMF0pO1xuICAgICAgLy8gcmV0LnBpeGVsU3RhcnQgPSBNYXRoLm1pbihhbmdsZUV4dGVudFswXSwgYW5nbGVFeHRlbnRbMV0pO1xuICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gYW5nbGVFeHRlbnRbMV0gLSBhbmdsZUV4dGVudFswXTtcbiAgICAgIHJldC5waXhlbFN0YXJ0ID0gYW5nbGVFeHRlbnRbMF07XG4gICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gLTEgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICBzaW5nbGVBeGlzOiBmdW5jdGlvbiAob2xkUG9pbnQsIG5ld1BvaW50LCBheGlzTW9kZWwsIGNvbnRyb2xsZXIsIGNvb3JkU3lzSW5mbykge1xuICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgdmFyIHJlY3QgPSBjb29yZFN5c0luZm8ubW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG9sZFBvaW50ID0gb2xkUG9pbnQgfHwgWzAsIDBdO1xuICAgIGlmIChheGlzLm9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICByZXQucGl4ZWwgPSBuZXdQb2ludFswXSAtIG9sZFBvaW50WzBdO1xuICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gcmVjdC53aWR0aDtcbiAgICAgIHJldC5waXhlbFN0YXJ0ID0gcmVjdC54O1xuICAgICAgcmV0LnNpZ25hbCA9IGF4aXMuaW52ZXJzZSA/IDEgOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gJ3ZlcnRpY2FsJ1xuICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMV0gLSBvbGRQb2ludFsxXTtcbiAgICAgIHJldC5waXhlbExlbmd0aCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgcmV0LnBpeGVsU3RhcnQgPSByZWN0Lnk7XG4gICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gLTEgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgSW5zaWRlWm9vbVZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgSW5zaWRlWm9vbU1vZGVsIGZyb20gJy4vSW5zaWRlWm9vbU1vZGVsLmpzJztcbmltcG9ydCBJbnNpZGVab29tVmlldyBmcm9tICcuL0luc2lkZVpvb21WaWV3LmpzJztcbmltcG9ydCB7IGluc3RhbGxEYXRhWm9vbVJvYW1Qcm9jZXNzb3IgfSBmcm9tICcuL3JvYW1zLmpzJztcbmltcG9ydCBpbnN0YWxsQ29tbW9uIGZyb20gJy4vaW5zdGFsbENvbW1vbi5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgaW5zdGFsbENvbW1vbihyZWdpc3RlcnMpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChJbnNpZGVab29tTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KEluc2lkZVpvb21WaWV3KTtcbiAgaW5zdGFsbERhdGFab29tUm9hbVByb2Nlc3NvcihyZWdpc3RlcnMpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///68667\n")},68686:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $5: () => (/* binding */ DATA_ZOOM_AXIS_DIMENSIONS),\n/* harmony export */   CN: () => (/* binding */ findEffectedDataZooms),\n/* harmony export */   _u: () => (/* binding */ isCoordSupported),\n/* harmony export */   dX: () => (/* binding */ getAxisMainType),\n/* harmony export */   es: () => (/* binding */ collectReferCoordSysModelInfo)\n/* harmony export */ });\n/* unused harmony exports getAxisIndexPropName, getAxisIdPropName */\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar DATA_ZOOM_AXIS_DIMENSIONS = ['x', 'y', 'radius', 'angle', 'single'];\n// Supported coords.\n// FIXME: polar has been broken (but rarely used).\nvar SERIES_COORDS = ['cartesian2d', 'polar', 'singleAxis'];\nfunction isCoordSupported(seriesModel) {\n  var coordType = seriesModel.get('coordinateSystem');\n  return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf)(SERIES_COORDS, coordType) >= 0;\n}\nfunction getAxisMainType(axisDim) {\n  if (false) {}\n  return axisDim + 'Axis';\n}\nfunction getAxisIndexPropName(axisDim) {\n  if (false) {}\n  return axisDim + 'AxisIndex';\n}\nfunction getAxisIdPropName(axisDim) {\n  if (false) {}\n  return axisDim + 'AxisId';\n}\n/**\r\n * If two dataZoomModels has the same axis controlled, we say that they are 'linked'.\r\n * This function finds all linked dataZoomModels start from the given payload.\r\n */\nfunction findEffectedDataZooms(ecModel, payload) {\n  // Key: `DataZoomAxisDimension`\n  var axisRecords = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();\n  var effectedModels = [];\n  // Key: uid of dataZoomModel\n  var effectedModelMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();\n  // Find the dataZooms specified by payload.\n  ecModel.eachComponent({\n    mainType: 'dataZoom',\n    query: payload\n  }, function (dataZoomModel) {\n    if (!effectedModelMap.get(dataZoomModel.uid)) {\n      addToEffected(dataZoomModel);\n    }\n  });\n  // Start from the given dataZoomModels, travel the graph to find\n  // all of the linked dataZoom models.\n  var foundNewLink;\n  do {\n    foundNewLink = false;\n    ecModel.eachComponent('dataZoom', processSingle);\n  } while (foundNewLink);\n  function processSingle(dataZoomModel) {\n    if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {\n      addToEffected(dataZoomModel);\n      foundNewLink = true;\n    }\n  }\n  function addToEffected(dataZoom) {\n    effectedModelMap.set(dataZoom.uid, true);\n    effectedModels.push(dataZoom);\n    markAxisControlled(dataZoom);\n  }\n  function isLinked(dataZoomModel) {\n    var isLink = false;\n    dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n      var axisIdxArr = axisRecords.get(axisDim);\n      if (axisIdxArr && axisIdxArr[axisIndex]) {\n        isLink = true;\n      }\n    });\n    return isLink;\n  }\n  function markAxisControlled(dataZoomModel) {\n    dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n      (axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true;\n    });\n  }\n  return effectedModels;\n}\n/**\r\n * Find the first target coordinate system.\r\n * Available after model built.\r\n *\r\n * @return Like {\r\n *                  grid: [\r\n *                      {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\r\n *                      {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\r\n *                      ...\r\n *                  ],  // cartesians must not be null/undefined.\r\n *                  polar: [\r\n *                      {model: coord0, axisModels: [axis4], coordIndex: 0},\r\n *                      ...\r\n *                  ],  // polars must not be null/undefined.\r\n *                  singleAxis: [\r\n *                      {model: coord0, axisModels: [], coordIndex: 0}\r\n *                  ]\r\n *              }\r\n */\nfunction collectReferCoordSysModelInfo(dataZoomModel) {\n  var ecModel = dataZoomModel.ecModel;\n  var coordSysInfoWrap = {\n    infoList: [],\n    infoMap: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)()\n  };\n  dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n    var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);\n    if (!axisModel) {\n      return;\n    }\n    var coordSysModel = axisModel.getCoordSysModel();\n    if (!coordSysModel) {\n      return;\n    }\n    var coordSysUid = coordSysModel.uid;\n    var coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid);\n    if (!coordSysInfo) {\n      coordSysInfo = {\n        model: coordSysModel,\n        axisModels: []\n      };\n      coordSysInfoWrap.infoList.push(coordSysInfo);\n      coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo);\n    }\n    coordSysInfo.axisModels.push(axisModel);\n  });\n  return coordSysInfoWrap;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg2ODYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2hlbHBlci5qcz9iNjUwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgaW5kZXhPZiwgY3JlYXRlSGFzaE1hcCwgYXNzZXJ0IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmV4cG9ydCB2YXIgREFUQV9aT09NX0FYSVNfRElNRU5TSU9OUyA9IFsneCcsICd5JywgJ3JhZGl1cycsICdhbmdsZScsICdzaW5nbGUnXTtcbi8vIFN1cHBvcnRlZCBjb29yZHMuXG4vLyBGSVhNRTogcG9sYXIgaGFzIGJlZW4gYnJva2VuIChidXQgcmFyZWx5IHVzZWQpLlxudmFyIFNFUklFU19DT09SRFMgPSBbJ2NhcnRlc2lhbjJkJywgJ3BvbGFyJywgJ3NpbmdsZUF4aXMnXTtcbmV4cG9ydCBmdW5jdGlvbiBpc0Nvb3JkU3VwcG9ydGVkKHNlcmllc01vZGVsKSB7XG4gIHZhciBjb29yZFR5cGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKTtcbiAgcmV0dXJuIGluZGV4T2YoU0VSSUVTX0NPT1JEUywgY29vcmRUeXBlKSA+PSAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEF4aXNNYWluVHlwZShheGlzRGltKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KGF4aXNEaW0pO1xuICB9XG4gIHJldHVybiBheGlzRGltICsgJ0F4aXMnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEF4aXNJbmRleFByb3BOYW1lKGF4aXNEaW0pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoYXhpc0RpbSk7XG4gIH1cbiAgcmV0dXJuIGF4aXNEaW0gKyAnQXhpc0luZGV4Jztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBeGlzSWRQcm9wTmFtZShheGlzRGltKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KGF4aXNEaW0pO1xuICB9XG4gIHJldHVybiBheGlzRGltICsgJ0F4aXNJZCc7XG59XG4vKipcclxuICogSWYgdHdvIGRhdGFab29tTW9kZWxzIGhhcyB0aGUgc2FtZSBheGlzIGNvbnRyb2xsZWQsIHdlIHNheSB0aGF0IHRoZXkgYXJlICdsaW5rZWQnLlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGZpbmRzIGFsbCBsaW5rZWQgZGF0YVpvb21Nb2RlbHMgc3RhcnQgZnJvbSB0aGUgZ2l2ZW4gcGF5bG9hZC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEVmZmVjdGVkRGF0YVpvb21zKGVjTW9kZWwsIHBheWxvYWQpIHtcbiAgLy8gS2V5OiBgRGF0YVpvb21BeGlzRGltZW5zaW9uYFxuICB2YXIgYXhpc1JlY29yZHMgPSBjcmVhdGVIYXNoTWFwKCk7XG4gIHZhciBlZmZlY3RlZE1vZGVscyA9IFtdO1xuICAvLyBLZXk6IHVpZCBvZiBkYXRhWm9vbU1vZGVsXG4gIHZhciBlZmZlY3RlZE1vZGVsTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuICAvLyBGaW5kIHRoZSBkYXRhWm9vbXMgc3BlY2lmaWVkIGJ5IHBheWxvYWQuXG4gIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgbWFpblR5cGU6ICdkYXRhWm9vbScsXG4gICAgcXVlcnk6IHBheWxvYWRcbiAgfSwgZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICBpZiAoIWVmZmVjdGVkTW9kZWxNYXAuZ2V0KGRhdGFab29tTW9kZWwudWlkKSkge1xuICAgICAgYWRkVG9FZmZlY3RlZChkYXRhWm9vbU1vZGVsKTtcbiAgICB9XG4gIH0pO1xuICAvLyBTdGFydCBmcm9tIHRoZSBnaXZlbiBkYXRhWm9vbU1vZGVscywgdHJhdmVsIHRoZSBncmFwaCB0byBmaW5kXG4gIC8vIGFsbCBvZiB0aGUgbGlua2VkIGRhdGFab29tIG1vZGVscy5cbiAgdmFyIGZvdW5kTmV3TGluaztcbiAgZG8ge1xuICAgIGZvdW5kTmV3TGluayA9IGZhbHNlO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnZGF0YVpvb20nLCBwcm9jZXNzU2luZ2xlKTtcbiAgfSB3aGlsZSAoZm91bmROZXdMaW5rKTtcbiAgZnVuY3Rpb24gcHJvY2Vzc1NpbmdsZShkYXRhWm9vbU1vZGVsKSB7XG4gICAgaWYgKCFlZmZlY3RlZE1vZGVsTWFwLmdldChkYXRhWm9vbU1vZGVsLnVpZCkgJiYgaXNMaW5rZWQoZGF0YVpvb21Nb2RlbCkpIHtcbiAgICAgIGFkZFRvRWZmZWN0ZWQoZGF0YVpvb21Nb2RlbCk7XG4gICAgICBmb3VuZE5ld0xpbmsgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhZGRUb0VmZmVjdGVkKGRhdGFab29tKSB7XG4gICAgZWZmZWN0ZWRNb2RlbE1hcC5zZXQoZGF0YVpvb20udWlkLCB0cnVlKTtcbiAgICBlZmZlY3RlZE1vZGVscy5wdXNoKGRhdGFab29tKTtcbiAgICBtYXJrQXhpc0NvbnRyb2xsZWQoZGF0YVpvb20pO1xuICB9XG4gIGZ1bmN0aW9uIGlzTGlua2VkKGRhdGFab29tTW9kZWwpIHtcbiAgICB2YXIgaXNMaW5rID0gZmFsc2U7XG4gICAgZGF0YVpvb21Nb2RlbC5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoYXhpc0RpbSwgYXhpc0luZGV4KSB7XG4gICAgICB2YXIgYXhpc0lkeEFyciA9IGF4aXNSZWNvcmRzLmdldChheGlzRGltKTtcbiAgICAgIGlmIChheGlzSWR4QXJyICYmIGF4aXNJZHhBcnJbYXhpc0luZGV4XSkge1xuICAgICAgICBpc0xpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpc0xpbms7XG4gIH1cbiAgZnVuY3Rpb24gbWFya0F4aXNDb250cm9sbGVkKGRhdGFab29tTW9kZWwpIHtcbiAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChheGlzRGltLCBheGlzSW5kZXgpIHtcbiAgICAgIChheGlzUmVjb3Jkcy5nZXQoYXhpc0RpbSkgfHwgYXhpc1JlY29yZHMuc2V0KGF4aXNEaW0sIFtdKSlbYXhpc0luZGV4XSA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVmZmVjdGVkTW9kZWxzO1xufVxuLyoqXHJcbiAqIEZpbmQgdGhlIGZpcnN0IHRhcmdldCBjb29yZGluYXRlIHN5c3RlbS5cclxuICogQXZhaWxhYmxlIGFmdGVyIG1vZGVsIGJ1aWx0LlxyXG4gKlxyXG4gKiBAcmV0dXJuIExpa2Uge1xyXG4gKiAgICAgICAgICAgICAgICAgIGdyaWQ6IFtcclxuICogICAgICAgICAgICAgICAgICAgICAge21vZGVsOiBjb29yZDAsIGF4aXNNb2RlbHM6IFtheGlzMSwgYXhpczNdLCBjb29yZEluZGV4OiAxfSxcclxuICogICAgICAgICAgICAgICAgICAgICAge21vZGVsOiBjb29yZDEsIGF4aXNNb2RlbHM6IFtheGlzMCwgYXhpczJdLCBjb29yZEluZGV4OiAwfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgLi4uXHJcbiAqICAgICAgICAgICAgICAgICAgXSwgIC8vIGNhcnRlc2lhbnMgbXVzdCBub3QgYmUgbnVsbC91bmRlZmluZWQuXHJcbiAqICAgICAgICAgICAgICAgICAgcG9sYXI6IFtcclxuICogICAgICAgICAgICAgICAgICAgICAge21vZGVsOiBjb29yZDAsIGF4aXNNb2RlbHM6IFtheGlzNF0sIGNvb3JkSW5kZXg6IDB9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAuLi5cclxuICogICAgICAgICAgICAgICAgICBdLCAgLy8gcG9sYXJzIG11c3Qgbm90IGJlIG51bGwvdW5kZWZpbmVkLlxyXG4gKiAgICAgICAgICAgICAgICAgIHNpbmdsZUF4aXM6IFtcclxuICogICAgICAgICAgICAgICAgICAgICAge21vZGVsOiBjb29yZDAsIGF4aXNNb2RlbHM6IFtdLCBjb29yZEluZGV4OiAwfVxyXG4gKiAgICAgICAgICAgICAgICAgIF1cclxuICogICAgICAgICAgICAgIH1cclxuICovXG5leHBvcnQgZnVuY3Rpb24gY29sbGVjdFJlZmVyQ29vcmRTeXNNb2RlbEluZm8oZGF0YVpvb21Nb2RlbCkge1xuICB2YXIgZWNNb2RlbCA9IGRhdGFab29tTW9kZWwuZWNNb2RlbDtcbiAgdmFyIGNvb3JkU3lzSW5mb1dyYXAgPSB7XG4gICAgaW5mb0xpc3Q6IFtdLFxuICAgIGluZm9NYXA6IGNyZWF0ZUhhc2hNYXAoKVxuICB9O1xuICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChheGlzRGltLCBheGlzSW5kZXgpIHtcbiAgICB2YXIgYXhpc01vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoZ2V0QXhpc01haW5UeXBlKGF4aXNEaW0pLCBheGlzSW5kZXgpO1xuICAgIGlmICghYXhpc01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb29yZFN5c01vZGVsID0gYXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKTtcbiAgICBpZiAoIWNvb3JkU3lzTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvb3JkU3lzVWlkID0gY29vcmRTeXNNb2RlbC51aWQ7XG4gICAgdmFyIGNvb3JkU3lzSW5mbyA9IGNvb3JkU3lzSW5mb1dyYXAuaW5mb01hcC5nZXQoY29vcmRTeXNVaWQpO1xuICAgIGlmICghY29vcmRTeXNJbmZvKSB7XG4gICAgICBjb29yZFN5c0luZm8gPSB7XG4gICAgICAgIG1vZGVsOiBjb29yZFN5c01vZGVsLFxuICAgICAgICBheGlzTW9kZWxzOiBbXVxuICAgICAgfTtcbiAgICAgIGNvb3JkU3lzSW5mb1dyYXAuaW5mb0xpc3QucHVzaChjb29yZFN5c0luZm8pO1xuICAgICAgY29vcmRTeXNJbmZvV3JhcC5pbmZvTWFwLnNldChjb29yZFN5c1VpZCwgY29vcmRTeXNJbmZvKTtcbiAgICB9XG4gICAgY29vcmRTeXNJbmZvLmF4aXNNb2RlbHMucHVzaChheGlzTW9kZWwpO1xuICB9KTtcbiAgcmV0dXJuIGNvb3JkU3lzSW5mb1dyYXA7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///68686\n")},72012:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(15915);\n/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68686);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar DataZoomAxisInfo = /** @class */function () {\n  function DataZoomAxisInfo() {\n    this.indexList = [];\n    this.indexMap = [];\n  }\n  DataZoomAxisInfo.prototype.add = function (axisCmptIdx) {\n    // Remove duplication.\n    if (!this.indexMap[axisCmptIdx]) {\n      this.indexList.push(axisCmptIdx);\n      this.indexMap[axisCmptIdx] = true;\n    }\n  };\n  return DataZoomAxisInfo;\n}();\nvar DataZoomModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(DataZoomModel, _super);\n  function DataZoomModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = DataZoomModel.type;\n    _this._autoThrottle = true;\n    _this._noTarget = true;\n    /**\r\n     * It is `[rangeModeForMin, rangeModeForMax]`.\r\n     * The optional values for `rangeMode`:\r\n     * + `'value'` mode: the axis extent will always be determined by\r\n     *     `dataZoom.startValue` and `dataZoom.endValue`, despite\r\n     *     how data like and how `axis.min` and `axis.max` are.\r\n     * + `'percent'` mode: `100` represents 100% of the `[dMin, dMax]`,\r\n     *     where `dMin` is `axis.min` if `axis.min` specified, otherwise `data.extent[0]`,\r\n     *     and `dMax` is `axis.max` if `axis.max` specified, otherwise `data.extent[1]`.\r\n     *     Axis extent will be determined by the result of the percent of `[dMin, dMax]`.\r\n     *\r\n     * For example, when users are using dynamic data (update data periodically via `setOption`),\r\n     * if in `'value`' mode, the window will be kept in a fixed value range despite how\r\n     * data are appended, while if in `'percent'` mode, whe window range will be changed alone with\r\n     * the appended data (suppose `axis.min` and `axis.max` are not specified).\r\n     */\n    _this._rangePropMode = ['percent', 'percent'];\n    return _this;\n  }\n  DataZoomModel.prototype.init = function (option, parentModel, ecModel) {\n    var inputRawOption = retrieveRawOption(option);\n    /**\r\n     * Suppose a \"main process\" start at the point that model prepared (that is,\r\n     * model initialized or merged or method called in `action`).\r\n     * We should keep the `main process` idempotent, that is, given a set of values\r\n     * on `option`, we get the same result.\r\n     *\r\n     * But sometimes, values on `option` will be updated for providing users\r\n     * a \"final calculated value\" (`dataZoomProcessor` will do that). Those value\r\n     * should not be the base/input of the `main process`.\r\n     *\r\n     * So in that case we should save and keep the input of the `main process`\r\n     * separately, called `settledOption`.\r\n     *\r\n     * For example, consider the case:\r\n     * (Step_1) brush zoom the grid by `toolbox.dataZoom`,\r\n     *     where the original input `option.startValue`, `option.endValue` are earsed by\r\n     *     calculated value.\r\n     * (Step)2) click the legend to hide and show a series,\r\n     *     where the new range is calculated by the earsed `startValue` and `endValue`,\r\n     *     which brings incorrect result.\r\n     */\n    this.settledOption = inputRawOption;\n    this.mergeDefaultAndTheme(option, ecModel);\n    this._doInit(inputRawOption);\n  };\n  DataZoomModel.prototype.mergeOption = function (newOption) {\n    var inputRawOption = retrieveRawOption(newOption);\n    // FIX #2591\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.merge)(this.option, newOption, true);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.merge)(this.settledOption, inputRawOption, true);\n    this._doInit(inputRawOption);\n  };\n  DataZoomModel.prototype._doInit = function (inputRawOption) {\n    var thisOption = this.option;\n    this._setDefaultThrottle(inputRawOption);\n    this._updateRangeUse(inputRawOption);\n    var settledOption = this.settledOption;\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      // start/end has higher priority over startValue/endValue if they\n      // both set, but we should make chart.setOption({endValue: 1000})\n      // effective, rather than chart.setOption({endValue: 1000, end: null}).\n      if (this._rangePropMode[index] === 'value') {\n        thisOption[names[0]] = settledOption[names[0]] = null;\n      }\n      // Otherwise do nothing and use the merge result.\n    }, this);\n    this._resetTarget();\n  };\n  DataZoomModel.prototype._resetTarget = function () {\n    var optionOrient = this.get('orient', true);\n    var targetAxisIndexMap = this._targetAxisInfoMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.createHashMap)();\n    var hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);\n    if (hasAxisSpecified) {\n      this._orient = optionOrient || this._makeAutoOrientByTargetAxis();\n    } else {\n      this._orient = optionOrient || 'horizontal';\n      this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);\n    }\n    this._noTarget = true;\n    targetAxisIndexMap.each(function (axisInfo) {\n      if (axisInfo.indexList.length) {\n        this._noTarget = false;\n      }\n    }, this);\n  };\n  DataZoomModel.prototype._fillSpecifiedTargetAxis = function (targetAxisIndexMap) {\n    var hasAxisSpecified = false;\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(_helper_js__WEBPACK_IMPORTED_MODULE_2__/* .DATA_ZOOM_AXIS_DIMENSIONS */ .$5, function (axisDim) {\n      var refering = this.getReferringComponents((0,_helper_js__WEBPACK_IMPORTED_MODULE_2__/* .getAxisMainType */ .dX)(axisDim), _util_model_js__WEBPACK_IMPORTED_MODULE_3__/* .MULTIPLE_REFERRING */ .UW);\n      // When user set axisIndex as a empty array, we think that user specify axisIndex\n      // but do not want use auto mode. Because empty array may be encountered when\n      // some error occurred.\n      if (!refering.specified) {\n        return;\n      }\n      hasAxisSpecified = true;\n      var axisInfo = new DataZoomAxisInfo();\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(refering.models, function (axisModel) {\n        axisInfo.add(axisModel.componentIndex);\n      });\n      targetAxisIndexMap.set(axisDim, axisInfo);\n    }, this);\n    return hasAxisSpecified;\n  };\n  DataZoomModel.prototype._fillAutoTargetAxisByOrient = function (targetAxisIndexMap, orient) {\n    var ecModel = this.ecModel;\n    var needAuto = true;\n    // Find axis that parallel to dataZoom as default.\n    if (needAuto) {\n      var axisDim = orient === 'vertical' ? 'y' : 'x';\n      var axisModels = ecModel.findComponents({\n        mainType: axisDim + 'Axis'\n      });\n      setParallelAxis(axisModels, axisDim);\n    }\n    // Find axis that parallel to dataZoom as default.\n    if (needAuto) {\n      var axisModels = ecModel.findComponents({\n        mainType: 'singleAxis',\n        filter: function (axisModel) {\n          return axisModel.get('orient', true) === orient;\n        }\n      });\n      setParallelAxis(axisModels, 'single');\n    }\n    function setParallelAxis(axisModels, axisDim) {\n      // At least use the first parallel axis as the target axis.\n      var axisModel = axisModels[0];\n      if (!axisModel) {\n        return;\n      }\n      var axisInfo = new DataZoomAxisInfo();\n      axisInfo.add(axisModel.componentIndex);\n      targetAxisIndexMap.set(axisDim, axisInfo);\n      needAuto = false;\n      // Find parallel axes in the same grid.\n      if (axisDim === 'x' || axisDim === 'y') {\n        var gridModel_1 = axisModel.getReferringComponents('grid', _util_model_js__WEBPACK_IMPORTED_MODULE_3__/* .SINGLE_REFERRING */ .US).models[0];\n        gridModel_1 && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(axisModels, function (axModel) {\n          if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents('grid', _util_model_js__WEBPACK_IMPORTED_MODULE_3__/* .SINGLE_REFERRING */ .US).models[0]) {\n            axisInfo.add(axModel.componentIndex);\n          }\n        });\n      }\n    }\n    if (needAuto) {\n      // If no parallel axis, find the first category axis as default. (Also consider polar).\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(_helper_js__WEBPACK_IMPORTED_MODULE_2__/* .DATA_ZOOM_AXIS_DIMENSIONS */ .$5, function (axisDim) {\n        if (!needAuto) {\n          return;\n        }\n        var axisModels = ecModel.findComponents({\n          mainType: (0,_helper_js__WEBPACK_IMPORTED_MODULE_2__/* .getAxisMainType */ .dX)(axisDim),\n          filter: function (axisModel) {\n            return axisModel.get('type', true) === 'category';\n          }\n        });\n        if (axisModels[0]) {\n          var axisInfo = new DataZoomAxisInfo();\n          axisInfo.add(axisModels[0].componentIndex);\n          targetAxisIndexMap.set(axisDim, axisInfo);\n          needAuto = false;\n        }\n      }, this);\n    }\n  };\n  DataZoomModel.prototype._makeAutoOrientByTargetAxis = function () {\n    var dim;\n    // Find the first axis\n    this.eachTargetAxis(function (axisDim) {\n      !dim && (dim = axisDim);\n    }, this);\n    return dim === 'y' ? 'vertical' : 'horizontal';\n  };\n  DataZoomModel.prototype._setDefaultThrottle = function (inputRawOption) {\n    // When first time user set throttle, auto throttle ends.\n    if (inputRawOption.hasOwnProperty('throttle')) {\n      this._autoThrottle = false;\n    }\n    if (this._autoThrottle) {\n      var globalOption = this.ecModel.option;\n      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;\n    }\n  };\n  DataZoomModel.prototype._updateRangeUse = function (inputRawOption) {\n    var rangePropMode = this._rangePropMode;\n    var rangeModeInOption = this.get('rangeMode');\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      var percentSpecified = inputRawOption[names[0]] != null;\n      var valueSpecified = inputRawOption[names[1]] != null;\n      if (percentSpecified && !valueSpecified) {\n        rangePropMode[index] = 'percent';\n      } else if (!percentSpecified && valueSpecified) {\n        rangePropMode[index] = 'value';\n      } else if (rangeModeInOption) {\n        rangePropMode[index] = rangeModeInOption[index];\n      } else if (percentSpecified) {\n        // percentSpecified && valueSpecified\n        rangePropMode[index] = 'percent';\n      }\n      // else remain its original setting.\n    });\n  };\n  DataZoomModel.prototype.noTarget = function () {\n    return this._noTarget;\n  };\n  DataZoomModel.prototype.getFirstTargetAxisModel = function () {\n    var firstAxisModel;\n    this.eachTargetAxis(function (axisDim, axisIndex) {\n      if (firstAxisModel == null) {\n        firstAxisModel = this.ecModel.getComponent((0,_helper_js__WEBPACK_IMPORTED_MODULE_2__/* .getAxisMainType */ .dX)(axisDim), axisIndex);\n      }\n    }, this);\n    return firstAxisModel;\n  };\n  /**\r\n   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\r\n   */\n  DataZoomModel.prototype.eachTargetAxis = function (callback, context) {\n    this._targetAxisInfoMap.each(function (axisInfo, axisDim) {\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(axisInfo.indexList, function (axisIndex) {\n        callback.call(context, axisDim, axisIndex);\n      });\n    });\n  };\n  /**\r\n   * @return If not found, return null/undefined.\r\n   */\n  DataZoomModel.prototype.getAxisProxy = function (axisDim, axisIndex) {\n    var axisModel = this.getAxisModel(axisDim, axisIndex);\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    }\n  };\n  /**\r\n   * @return If not found, return null/undefined.\r\n   */\n  DataZoomModel.prototype.getAxisModel = function (axisDim, axisIndex) {\n    if (false) {}\n    var axisInfo = this._targetAxisInfoMap.get(axisDim);\n    if (axisInfo && axisInfo.indexMap[axisIndex]) {\n      return this.ecModel.getComponent((0,_helper_js__WEBPACK_IMPORTED_MODULE_2__/* .getAxisMainType */ .dX)(axisDim), axisIndex);\n    }\n  };\n  /**\r\n   * If not specified, set to undefined.\r\n   */\n  DataZoomModel.prototype.setRawRange = function (opt) {\n    var thisOption = this.option;\n    var settledOption = this.settledOption;\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)([['start', 'startValue'], ['end', 'endValue']], function (names) {\n      // Consider the pair <start, startValue>:\n      // If one has value and the other one is `null/undefined`, we both set them\n      // to `settledOption`. This strategy enables the feature to clear the original\n      // value in `settledOption` to `null/undefined`.\n      // But if both of them are `null/undefined`, we do not set them to `settledOption`\n      // and keep `settledOption` with the original value. This strategy enables users to\n      // only set <end or endValue> but not set <start or startValue> when calling\n      // `dispatchAction`.\n      // The pair <end, endValue> is treated in the same way.\n      if (opt[names[0]] != null || opt[names[1]] != null) {\n        thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];\n        thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];\n      }\n    }, this);\n    this._updateRangeUse(opt);\n  };\n  DataZoomModel.prototype.setCalculatedRange = function (opt) {\n    var option = this.option;\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(['start', 'startValue', 'end', 'endValue'], function (name) {\n      option[name] = opt[name];\n    });\n  };\n  DataZoomModel.prototype.getPercentRange = function () {\n    var axisProxy = this.findRepresentativeAxisProxy();\n    if (axisProxy) {\n      return axisProxy.getDataPercentWindow();\n    }\n  };\n  /**\r\n   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\r\n   *\r\n   * @return [startValue, endValue] value can only be '-' or finite number.\r\n   */\n  DataZoomModel.prototype.getValueRange = function (axisDim, axisIndex) {\n    if (axisDim == null && axisIndex == null) {\n      var axisProxy = this.findRepresentativeAxisProxy();\n      if (axisProxy) {\n        return axisProxy.getDataValueWindow();\n      }\n    } else {\n      return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();\n    }\n  };\n  /**\r\n   * @param axisModel If axisModel given, find axisProxy\r\n   *      corresponding to the axisModel\r\n   */\n  DataZoomModel.prototype.findRepresentativeAxisProxy = function (axisModel) {\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    }\n    // Find the first hosted axisProxy\n    var firstProxy;\n    var axisDimList = this._targetAxisInfoMap.keys();\n    for (var i = 0; i < axisDimList.length; i++) {\n      var axisDim = axisDimList[i];\n      var axisInfo = this._targetAxisInfoMap.get(axisDim);\n      for (var j = 0; j < axisInfo.indexList.length; j++) {\n        var proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);\n        if (proxy.hostedBy(this)) {\n          return proxy;\n        }\n        if (!firstProxy) {\n          firstProxy = proxy;\n        }\n      }\n    }\n    // If no hosted proxy found, still need to return a proxy.\n    // This case always happens in toolbox dataZoom, where axes are all hosted by\n    // other dataZooms.\n    return firstProxy;\n  };\n  DataZoomModel.prototype.getRangePropMode = function () {\n    return this._rangePropMode.slice();\n  };\n  DataZoomModel.prototype.getOrient = function () {\n    if (false) {}\n    return this._orient;\n  };\n  DataZoomModel.type = 'dataZoom';\n  DataZoomModel.dependencies = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series', 'toolbox'];\n  DataZoomModel.defaultOption = {\n    // zlevel: 0,\n    z: 4,\n    filterMode: 'filter',\n    start: 0,\n    end: 100\n  };\n  return DataZoomModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A);\n/**\r\n * Retrieve those raw params from option, which will be cached separately,\r\n * because they will be overwritten by normalized/calculated values in the main\r\n * process.\r\n */\nfunction retrieveRawOption(option) {\n  var ret = {};\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {\n    option.hasOwnProperty(name) && (ret[name] = option[name]);\n  });\n  return ret;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataZoomModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIwMTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbC5qcz8wMjgzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBlYWNoLCBjcmVhdGVIYXNoTWFwLCBtZXJnZSwgYXNzZXJ0IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBDb21wb25lbnRNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Db21wb25lbnQuanMnO1xuaW1wb3J0IHsgZ2V0QXhpc01haW5UeXBlLCBEQVRBX1pPT01fQVhJU19ESU1FTlNJT05TIH0gZnJvbSAnLi9oZWxwZXIuanMnO1xuaW1wb3J0IHsgTVVMVElQTEVfUkVGRVJSSU5HLCBTSU5HTEVfUkVGRVJSSU5HIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG52YXIgRGF0YVpvb21BeGlzSW5mbyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGFab29tQXhpc0luZm8oKSB7XG4gICAgdGhpcy5pbmRleExpc3QgPSBbXTtcbiAgICB0aGlzLmluZGV4TWFwID0gW107XG4gIH1cbiAgRGF0YVpvb21BeGlzSW5mby5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGF4aXNDbXB0SWR4KSB7XG4gICAgLy8gUmVtb3ZlIGR1cGxpY2F0aW9uLlxuICAgIGlmICghdGhpcy5pbmRleE1hcFtheGlzQ21wdElkeF0pIHtcbiAgICAgIHRoaXMuaW5kZXhMaXN0LnB1c2goYXhpc0NtcHRJZHgpO1xuICAgICAgdGhpcy5pbmRleE1hcFtheGlzQ21wdElkeF0gPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIERhdGFab29tQXhpc0luZm87XG59KCk7XG52YXIgRGF0YVpvb21Nb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhEYXRhWm9vbU1vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBEYXRhWm9vbU1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBEYXRhWm9vbU1vZGVsLnR5cGU7XG4gICAgX3RoaXMuX2F1dG9UaHJvdHRsZSA9IHRydWU7XG4gICAgX3RoaXMuX25vVGFyZ2V0ID0gdHJ1ZTtcbiAgICAvKipcclxuICAgICAqIEl0IGlzIGBbcmFuZ2VNb2RlRm9yTWluLCByYW5nZU1vZGVGb3JNYXhdYC5cclxuICAgICAqIFRoZSBvcHRpb25hbCB2YWx1ZXMgZm9yIGByYW5nZU1vZGVgOlxyXG4gICAgICogKyBgJ3ZhbHVlJ2AgbW9kZTogdGhlIGF4aXMgZXh0ZW50IHdpbGwgYWx3YXlzIGJlIGRldGVybWluZWQgYnlcclxuICAgICAqICAgICBgZGF0YVpvb20uc3RhcnRWYWx1ZWAgYW5kIGBkYXRhWm9vbS5lbmRWYWx1ZWAsIGRlc3BpdGVcclxuICAgICAqICAgICBob3cgZGF0YSBsaWtlIGFuZCBob3cgYGF4aXMubWluYCBhbmQgYGF4aXMubWF4YCBhcmUuXHJcbiAgICAgKiArIGAncGVyY2VudCdgIG1vZGU6IGAxMDBgIHJlcHJlc2VudHMgMTAwJSBvZiB0aGUgYFtkTWluLCBkTWF4XWAsXHJcbiAgICAgKiAgICAgd2hlcmUgYGRNaW5gIGlzIGBheGlzLm1pbmAgaWYgYGF4aXMubWluYCBzcGVjaWZpZWQsIG90aGVyd2lzZSBgZGF0YS5leHRlbnRbMF1gLFxyXG4gICAgICogICAgIGFuZCBgZE1heGAgaXMgYGF4aXMubWF4YCBpZiBgYXhpcy5tYXhgIHNwZWNpZmllZCwgb3RoZXJ3aXNlIGBkYXRhLmV4dGVudFsxXWAuXHJcbiAgICAgKiAgICAgQXhpcyBleHRlbnQgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSByZXN1bHQgb2YgdGhlIHBlcmNlbnQgb2YgYFtkTWluLCBkTWF4XWAuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGV4YW1wbGUsIHdoZW4gdXNlcnMgYXJlIHVzaW5nIGR5bmFtaWMgZGF0YSAodXBkYXRlIGRhdGEgcGVyaW9kaWNhbGx5IHZpYSBgc2V0T3B0aW9uYCksXHJcbiAgICAgKiBpZiBpbiBgJ3ZhbHVlYCcgbW9kZSwgdGhlIHdpbmRvdyB3aWxsIGJlIGtlcHQgaW4gYSBmaXhlZCB2YWx1ZSByYW5nZSBkZXNwaXRlIGhvd1xyXG4gICAgICogZGF0YSBhcmUgYXBwZW5kZWQsIHdoaWxlIGlmIGluIGAncGVyY2VudCdgIG1vZGUsIHdoZSB3aW5kb3cgcmFuZ2Ugd2lsbCBiZSBjaGFuZ2VkIGFsb25lIHdpdGhcclxuICAgICAqIHRoZSBhcHBlbmRlZCBkYXRhIChzdXBwb3NlIGBheGlzLm1pbmAgYW5kIGBheGlzLm1heGAgYXJlIG5vdCBzcGVjaWZpZWQpLlxyXG4gICAgICovXG4gICAgX3RoaXMuX3JhbmdlUHJvcE1vZGUgPSBbJ3BlcmNlbnQnLCAncGVyY2VudCddO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBEYXRhWm9vbU1vZGVsLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpIHtcbiAgICB2YXIgaW5wdXRSYXdPcHRpb24gPSByZXRyaWV2ZVJhd09wdGlvbihvcHRpb24pO1xuICAgIC8qKlxyXG4gICAgICogU3VwcG9zZSBhIFwibWFpbiBwcm9jZXNzXCIgc3RhcnQgYXQgdGhlIHBvaW50IHRoYXQgbW9kZWwgcHJlcGFyZWQgKHRoYXQgaXMsXHJcbiAgICAgKiBtb2RlbCBpbml0aWFsaXplZCBvciBtZXJnZWQgb3IgbWV0aG9kIGNhbGxlZCBpbiBgYWN0aW9uYCkuXHJcbiAgICAgKiBXZSBzaG91bGQga2VlcCB0aGUgYG1haW4gcHJvY2Vzc2AgaWRlbXBvdGVudCwgdGhhdCBpcywgZ2l2ZW4gYSBzZXQgb2YgdmFsdWVzXHJcbiAgICAgKiBvbiBgb3B0aW9uYCwgd2UgZ2V0IHRoZSBzYW1lIHJlc3VsdC5cclxuICAgICAqXHJcbiAgICAgKiBCdXQgc29tZXRpbWVzLCB2YWx1ZXMgb24gYG9wdGlvbmAgd2lsbCBiZSB1cGRhdGVkIGZvciBwcm92aWRpbmcgdXNlcnNcclxuICAgICAqIGEgXCJmaW5hbCBjYWxjdWxhdGVkIHZhbHVlXCIgKGBkYXRhWm9vbVByb2Nlc3NvcmAgd2lsbCBkbyB0aGF0KS4gVGhvc2UgdmFsdWVcclxuICAgICAqIHNob3VsZCBub3QgYmUgdGhlIGJhc2UvaW5wdXQgb2YgdGhlIGBtYWluIHByb2Nlc3NgLlxyXG4gICAgICpcclxuICAgICAqIFNvIGluIHRoYXQgY2FzZSB3ZSBzaG91bGQgc2F2ZSBhbmQga2VlcCB0aGUgaW5wdXQgb2YgdGhlIGBtYWluIHByb2Nlc3NgXHJcbiAgICAgKiBzZXBhcmF0ZWx5LCBjYWxsZWQgYHNldHRsZWRPcHRpb25gLlxyXG4gICAgICpcclxuICAgICAqIEZvciBleGFtcGxlLCBjb25zaWRlciB0aGUgY2FzZTpcclxuICAgICAqIChTdGVwXzEpIGJydXNoIHpvb20gdGhlIGdyaWQgYnkgYHRvb2xib3guZGF0YVpvb21gLFxyXG4gICAgICogICAgIHdoZXJlIHRoZSBvcmlnaW5hbCBpbnB1dCBgb3B0aW9uLnN0YXJ0VmFsdWVgLCBgb3B0aW9uLmVuZFZhbHVlYCBhcmUgZWFyc2VkIGJ5XHJcbiAgICAgKiAgICAgY2FsY3VsYXRlZCB2YWx1ZS5cclxuICAgICAqIChTdGVwKTIpIGNsaWNrIHRoZSBsZWdlbmQgdG8gaGlkZSBhbmQgc2hvdyBhIHNlcmllcyxcclxuICAgICAqICAgICB3aGVyZSB0aGUgbmV3IHJhbmdlIGlzIGNhbGN1bGF0ZWQgYnkgdGhlIGVhcnNlZCBgc3RhcnRWYWx1ZWAgYW5kIGBlbmRWYWx1ZWAsXHJcbiAgICAgKiAgICAgd2hpY2ggYnJpbmdzIGluY29ycmVjdCByZXN1bHQuXHJcbiAgICAgKi9cbiAgICB0aGlzLnNldHRsZWRPcHRpb24gPSBpbnB1dFJhd09wdGlvbjtcbiAgICB0aGlzLm1lcmdlRGVmYXVsdEFuZFRoZW1lKG9wdGlvbiwgZWNNb2RlbCk7XG4gICAgdGhpcy5fZG9Jbml0KGlucHV0UmF3T3B0aW9uKTtcbiAgfTtcbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUubWVyZ2VPcHRpb24gPSBmdW5jdGlvbiAobmV3T3B0aW9uKSB7XG4gICAgdmFyIGlucHV0UmF3T3B0aW9uID0gcmV0cmlldmVSYXdPcHRpb24obmV3T3B0aW9uKTtcbiAgICAvLyBGSVggIzI1OTFcbiAgICBtZXJnZSh0aGlzLm9wdGlvbiwgbmV3T3B0aW9uLCB0cnVlKTtcbiAgICBtZXJnZSh0aGlzLnNldHRsZWRPcHRpb24sIGlucHV0UmF3T3B0aW9uLCB0cnVlKTtcbiAgICB0aGlzLl9kb0luaXQoaW5wdXRSYXdPcHRpb24pO1xuICB9O1xuICBEYXRhWm9vbU1vZGVsLnByb3RvdHlwZS5fZG9Jbml0ID0gZnVuY3Rpb24gKGlucHV0UmF3T3B0aW9uKSB7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB0aGlzLl9zZXREZWZhdWx0VGhyb3R0bGUoaW5wdXRSYXdPcHRpb24pO1xuICAgIHRoaXMuX3VwZGF0ZVJhbmdlVXNlKGlucHV0UmF3T3B0aW9uKTtcbiAgICB2YXIgc2V0dGxlZE9wdGlvbiA9IHRoaXMuc2V0dGxlZE9wdGlvbjtcbiAgICBlYWNoKFtbJ3N0YXJ0JywgJ3N0YXJ0VmFsdWUnXSwgWydlbmQnLCAnZW5kVmFsdWUnXV0sIGZ1bmN0aW9uIChuYW1lcywgaW5kZXgpIHtcbiAgICAgIC8vIHN0YXJ0L2VuZCBoYXMgaGlnaGVyIHByaW9yaXR5IG92ZXIgc3RhcnRWYWx1ZS9lbmRWYWx1ZSBpZiB0aGV5XG4gICAgICAvLyBib3RoIHNldCwgYnV0IHdlIHNob3VsZCBtYWtlIGNoYXJ0LnNldE9wdGlvbih7ZW5kVmFsdWU6IDEwMDB9KVxuICAgICAgLy8gZWZmZWN0aXZlLCByYXRoZXIgdGhhbiBjaGFydC5zZXRPcHRpb24oe2VuZFZhbHVlOiAxMDAwLCBlbmQ6IG51bGx9KS5cbiAgICAgIGlmICh0aGlzLl9yYW5nZVByb3BNb2RlW2luZGV4XSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICB0aGlzT3B0aW9uW25hbWVzWzBdXSA9IHNldHRsZWRPcHRpb25bbmFtZXNbMF1dID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIE90aGVyd2lzZSBkbyBub3RoaW5nIGFuZCB1c2UgdGhlIG1lcmdlIHJlc3VsdC5cbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9yZXNldFRhcmdldCgpO1xuICB9O1xuICBEYXRhWm9vbU1vZGVsLnByb3RvdHlwZS5fcmVzZXRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbk9yaWVudCA9IHRoaXMuZ2V0KCdvcmllbnQnLCB0cnVlKTtcbiAgICB2YXIgdGFyZ2V0QXhpc0luZGV4TWFwID0gdGhpcy5fdGFyZ2V0QXhpc0luZm9NYXAgPSBjcmVhdGVIYXNoTWFwKCk7XG4gICAgdmFyIGhhc0F4aXNTcGVjaWZpZWQgPSB0aGlzLl9maWxsU3BlY2lmaWVkVGFyZ2V0QXhpcyh0YXJnZXRBeGlzSW5kZXhNYXApO1xuICAgIGlmIChoYXNBeGlzU3BlY2lmaWVkKSB7XG4gICAgICB0aGlzLl9vcmllbnQgPSBvcHRpb25PcmllbnQgfHwgdGhpcy5fbWFrZUF1dG9PcmllbnRCeVRhcmdldEF4aXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3JpZW50ID0gb3B0aW9uT3JpZW50IHx8ICdob3Jpem9udGFsJztcbiAgICAgIHRoaXMuX2ZpbGxBdXRvVGFyZ2V0QXhpc0J5T3JpZW50KHRhcmdldEF4aXNJbmRleE1hcCwgdGhpcy5fb3JpZW50KTtcbiAgICB9XG4gICAgdGhpcy5fbm9UYXJnZXQgPSB0cnVlO1xuICAgIHRhcmdldEF4aXNJbmRleE1hcC5lYWNoKGZ1bmN0aW9uIChheGlzSW5mbykge1xuICAgICAgaWYgKGF4aXNJbmZvLmluZGV4TGlzdC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbm9UYXJnZXQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuX2ZpbGxTcGVjaWZpZWRUYXJnZXRBeGlzID0gZnVuY3Rpb24gKHRhcmdldEF4aXNJbmRleE1hcCkge1xuICAgIHZhciBoYXNBeGlzU3BlY2lmaWVkID0gZmFsc2U7XG4gICAgZWFjaChEQVRBX1pPT01fQVhJU19ESU1FTlNJT05TLCBmdW5jdGlvbiAoYXhpc0RpbSkge1xuICAgICAgdmFyIHJlZmVyaW5nID0gdGhpcy5nZXRSZWZlcnJpbmdDb21wb25lbnRzKGdldEF4aXNNYWluVHlwZShheGlzRGltKSwgTVVMVElQTEVfUkVGRVJSSU5HKTtcbiAgICAgIC8vIFdoZW4gdXNlciBzZXQgYXhpc0luZGV4IGFzIGEgZW1wdHkgYXJyYXksIHdlIHRoaW5rIHRoYXQgdXNlciBzcGVjaWZ5IGF4aXNJbmRleFxuICAgICAgLy8gYnV0IGRvIG5vdCB3YW50IHVzZSBhdXRvIG1vZGUuIEJlY2F1c2UgZW1wdHkgYXJyYXkgbWF5IGJlIGVuY291bnRlcmVkIHdoZW5cbiAgICAgIC8vIHNvbWUgZXJyb3Igb2NjdXJyZWQuXG4gICAgICBpZiAoIXJlZmVyaW5nLnNwZWNpZmllZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBoYXNBeGlzU3BlY2lmaWVkID0gdHJ1ZTtcbiAgICAgIHZhciBheGlzSW5mbyA9IG5ldyBEYXRhWm9vbUF4aXNJbmZvKCk7XG4gICAgICBlYWNoKHJlZmVyaW5nLm1vZGVscywgZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgICAgICBheGlzSW5mby5hZGQoYXhpc01vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgICAgIH0pO1xuICAgICAgdGFyZ2V0QXhpc0luZGV4TWFwLnNldChheGlzRGltLCBheGlzSW5mbyk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIGhhc0F4aXNTcGVjaWZpZWQ7XG4gIH07XG4gIERhdGFab29tTW9kZWwucHJvdG90eXBlLl9maWxsQXV0b1RhcmdldEF4aXNCeU9yaWVudCA9IGZ1bmN0aW9uICh0YXJnZXRBeGlzSW5kZXhNYXAsIG9yaWVudCkge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgIHZhciBuZWVkQXV0byA9IHRydWU7XG4gICAgLy8gRmluZCBheGlzIHRoYXQgcGFyYWxsZWwgdG8gZGF0YVpvb20gYXMgZGVmYXVsdC5cbiAgICBpZiAobmVlZEF1dG8pIHtcbiAgICAgIHZhciBheGlzRGltID0gb3JpZW50ID09PSAndmVydGljYWwnID8gJ3knIDogJ3gnO1xuICAgICAgdmFyIGF4aXNNb2RlbHMgPSBlY01vZGVsLmZpbmRDb21wb25lbnRzKHtcbiAgICAgICAgbWFpblR5cGU6IGF4aXNEaW0gKyAnQXhpcydcbiAgICAgIH0pO1xuICAgICAgc2V0UGFyYWxsZWxBeGlzKGF4aXNNb2RlbHMsIGF4aXNEaW0pO1xuICAgIH1cbiAgICAvLyBGaW5kIGF4aXMgdGhhdCBwYXJhbGxlbCB0byBkYXRhWm9vbSBhcyBkZWZhdWx0LlxuICAgIGlmIChuZWVkQXV0bykge1xuICAgICAgdmFyIGF4aXNNb2RlbHMgPSBlY01vZGVsLmZpbmRDb21wb25lbnRzKHtcbiAgICAgICAgbWFpblR5cGU6ICdzaW5nbGVBeGlzJyxcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGF4aXNNb2RlbC5nZXQoJ29yaWVudCcsIHRydWUpID09PSBvcmllbnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2V0UGFyYWxsZWxBeGlzKGF4aXNNb2RlbHMsICdzaW5nbGUnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0UGFyYWxsZWxBeGlzKGF4aXNNb2RlbHMsIGF4aXNEaW0pIHtcbiAgICAgIC8vIEF0IGxlYXN0IHVzZSB0aGUgZmlyc3QgcGFyYWxsZWwgYXhpcyBhcyB0aGUgdGFyZ2V0IGF4aXMuXG4gICAgICB2YXIgYXhpc01vZGVsID0gYXhpc01vZGVsc1swXTtcbiAgICAgIGlmICghYXhpc01vZGVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBheGlzSW5mbyA9IG5ldyBEYXRhWm9vbUF4aXNJbmZvKCk7XG4gICAgICBheGlzSW5mby5hZGQoYXhpc01vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgICAgIHRhcmdldEF4aXNJbmRleE1hcC5zZXQoYXhpc0RpbSwgYXhpc0luZm8pO1xuICAgICAgbmVlZEF1dG8gPSBmYWxzZTtcbiAgICAgIC8vIEZpbmQgcGFyYWxsZWwgYXhlcyBpbiB0aGUgc2FtZSBncmlkLlxuICAgICAgaWYgKGF4aXNEaW0gPT09ICd4JyB8fCBheGlzRGltID09PSAneScpIHtcbiAgICAgICAgdmFyIGdyaWRNb2RlbF8xID0gYXhpc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ2dyaWQnLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG4gICAgICAgIGdyaWRNb2RlbF8xICYmIGVhY2goYXhpc01vZGVscywgZnVuY3Rpb24gKGF4TW9kZWwpIHtcbiAgICAgICAgICBpZiAoYXhpc01vZGVsLmNvbXBvbmVudEluZGV4ICE9PSBheE1vZGVsLmNvbXBvbmVudEluZGV4ICYmIGdyaWRNb2RlbF8xID09PSBheE1vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ2dyaWQnLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF0pIHtcbiAgICAgICAgICAgIGF4aXNJbmZvLmFkZChheE1vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVlZEF1dG8pIHtcbiAgICAgIC8vIElmIG5vIHBhcmFsbGVsIGF4aXMsIGZpbmQgdGhlIGZpcnN0IGNhdGVnb3J5IGF4aXMgYXMgZGVmYXVsdC4gKEFsc28gY29uc2lkZXIgcG9sYXIpLlxuICAgICAgZWFjaChEQVRBX1pPT01fQVhJU19ESU1FTlNJT05TLCBmdW5jdGlvbiAoYXhpc0RpbSkge1xuICAgICAgICBpZiAoIW5lZWRBdXRvKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBheGlzTW9kZWxzID0gZWNNb2RlbC5maW5kQ29tcG9uZW50cyh7XG4gICAgICAgICAgbWFpblR5cGU6IGdldEF4aXNNYWluVHlwZShheGlzRGltKSxcbiAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBheGlzTW9kZWwuZ2V0KCd0eXBlJywgdHJ1ZSkgPT09ICdjYXRlZ29yeSc7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGF4aXNNb2RlbHNbMF0pIHtcbiAgICAgICAgICB2YXIgYXhpc0luZm8gPSBuZXcgRGF0YVpvb21BeGlzSW5mbygpO1xuICAgICAgICAgIGF4aXNJbmZvLmFkZChheGlzTW9kZWxzWzBdLmNvbXBvbmVudEluZGV4KTtcbiAgICAgICAgICB0YXJnZXRBeGlzSW5kZXhNYXAuc2V0KGF4aXNEaW0sIGF4aXNJbmZvKTtcbiAgICAgICAgICBuZWVkQXV0byA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH07XG4gIERhdGFab29tTW9kZWwucHJvdG90eXBlLl9tYWtlQXV0b09yaWVudEJ5VGFyZ2V0QXhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGltO1xuICAgIC8vIEZpbmQgdGhlIGZpcnN0IGF4aXNcbiAgICB0aGlzLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChheGlzRGltKSB7XG4gICAgICAhZGltICYmIChkaW0gPSBheGlzRGltKTtcbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gZGltID09PSAneScgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICB9O1xuICBEYXRhWm9vbU1vZGVsLnByb3RvdHlwZS5fc2V0RGVmYXVsdFRocm90dGxlID0gZnVuY3Rpb24gKGlucHV0UmF3T3B0aW9uKSB7XG4gICAgLy8gV2hlbiBmaXJzdCB0aW1lIHVzZXIgc2V0IHRocm90dGxlLCBhdXRvIHRocm90dGxlIGVuZHMuXG4gICAgaWYgKGlucHV0UmF3T3B0aW9uLmhhc093blByb3BlcnR5KCd0aHJvdHRsZScpKSB7XG4gICAgICB0aGlzLl9hdXRvVGhyb3R0bGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2F1dG9UaHJvdHRsZSkge1xuICAgICAgdmFyIGdsb2JhbE9wdGlvbiA9IHRoaXMuZWNNb2RlbC5vcHRpb247XG4gICAgICB0aGlzLm9wdGlvbi50aHJvdHRsZSA9IGdsb2JhbE9wdGlvbi5hbmltYXRpb24gJiYgZ2xvYmFsT3B0aW9uLmFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlID4gMCA/IDEwMCA6IDIwO1xuICAgIH1cbiAgfTtcbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuX3VwZGF0ZVJhbmdlVXNlID0gZnVuY3Rpb24gKGlucHV0UmF3T3B0aW9uKSB7XG4gICAgdmFyIHJhbmdlUHJvcE1vZGUgPSB0aGlzLl9yYW5nZVByb3BNb2RlO1xuICAgIHZhciByYW5nZU1vZGVJbk9wdGlvbiA9IHRoaXMuZ2V0KCdyYW5nZU1vZGUnKTtcbiAgICBlYWNoKFtbJ3N0YXJ0JywgJ3N0YXJ0VmFsdWUnXSwgWydlbmQnLCAnZW5kVmFsdWUnXV0sIGZ1bmN0aW9uIChuYW1lcywgaW5kZXgpIHtcbiAgICAgIHZhciBwZXJjZW50U3BlY2lmaWVkID0gaW5wdXRSYXdPcHRpb25bbmFtZXNbMF1dICE9IG51bGw7XG4gICAgICB2YXIgdmFsdWVTcGVjaWZpZWQgPSBpbnB1dFJhd09wdGlvbltuYW1lc1sxXV0gIT0gbnVsbDtcbiAgICAgIGlmIChwZXJjZW50U3BlY2lmaWVkICYmICF2YWx1ZVNwZWNpZmllZCkge1xuICAgICAgICByYW5nZVByb3BNb2RlW2luZGV4XSA9ICdwZXJjZW50JztcbiAgICAgIH0gZWxzZSBpZiAoIXBlcmNlbnRTcGVjaWZpZWQgJiYgdmFsdWVTcGVjaWZpZWQpIHtcbiAgICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAndmFsdWUnO1xuICAgICAgfSBlbHNlIGlmIChyYW5nZU1vZGVJbk9wdGlvbikge1xuICAgICAgICByYW5nZVByb3BNb2RlW2luZGV4XSA9IHJhbmdlTW9kZUluT3B0aW9uW2luZGV4XTtcbiAgICAgIH0gZWxzZSBpZiAocGVyY2VudFNwZWNpZmllZCkge1xuICAgICAgICAvLyBwZXJjZW50U3BlY2lmaWVkICYmIHZhbHVlU3BlY2lmaWVkXG4gICAgICAgIHJhbmdlUHJvcE1vZGVbaW5kZXhdID0gJ3BlcmNlbnQnO1xuICAgICAgfVxuICAgICAgLy8gZWxzZSByZW1haW4gaXRzIG9yaWdpbmFsIHNldHRpbmcuXG4gICAgfSk7XG4gIH07XG4gIERhdGFab29tTW9kZWwucHJvdG90eXBlLm5vVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9ub1RhcmdldDtcbiAgfTtcbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuZ2V0Rmlyc3RUYXJnZXRBeGlzTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpcnN0QXhpc01vZGVsO1xuICAgIHRoaXMuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGF4aXNEaW0sIGF4aXNJbmRleCkge1xuICAgICAgaWYgKGZpcnN0QXhpc01vZGVsID09IG51bGwpIHtcbiAgICAgICAgZmlyc3RBeGlzTW9kZWwgPSB0aGlzLmVjTW9kZWwuZ2V0Q29tcG9uZW50KGdldEF4aXNNYWluVHlwZShheGlzRGltKSwgYXhpc0luZGV4KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gZmlyc3RBeGlzTW9kZWw7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHBhcmFtOiBheGlzTW9kZWwsIGRpbU5hbWVzLCBheGlzSW5kZXgsIGRhdGFab29tTW9kZWwsIGVjTW9kZWxcclxuICAgKi9cbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuZWFjaFRhcmdldEF4aXMgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl90YXJnZXRBeGlzSW5mb01hcC5lYWNoKGZ1bmN0aW9uIChheGlzSW5mbywgYXhpc0RpbSkge1xuICAgICAgZWFjaChheGlzSW5mby5pbmRleExpc3QsIGZ1bmN0aW9uIChheGlzSW5kZXgpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBheGlzRGltLCBheGlzSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEByZXR1cm4gSWYgbm90IGZvdW5kLCByZXR1cm4gbnVsbC91bmRlZmluZWQuXHJcbiAgICovXG4gIERhdGFab29tTW9kZWwucHJvdG90eXBlLmdldEF4aXNQcm94eSA9IGZ1bmN0aW9uIChheGlzRGltLCBheGlzSW5kZXgpIHtcbiAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5nZXRBeGlzTW9kZWwoYXhpc0RpbSwgYXhpc0luZGV4KTtcbiAgICBpZiAoYXhpc01vZGVsKSB7XG4gICAgICByZXR1cm4gYXhpc01vZGVsLl9fZHpBeGlzUHJveHk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBAcmV0dXJuIElmIG5vdCBmb3VuZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxyXG4gICAqL1xuICBEYXRhWm9vbU1vZGVsLnByb3RvdHlwZS5nZXRBeGlzTW9kZWwgPSBmdW5jdGlvbiAoYXhpc0RpbSwgYXhpc0luZGV4KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChheGlzRGltICYmIGF4aXNJbmRleCAhPSBudWxsKTtcbiAgICB9XG4gICAgdmFyIGF4aXNJbmZvID0gdGhpcy5fdGFyZ2V0QXhpc0luZm9NYXAuZ2V0KGF4aXNEaW0pO1xuICAgIGlmIChheGlzSW5mbyAmJiBheGlzSW5mby5pbmRleE1hcFtheGlzSW5kZXhdKSB7XG4gICAgICByZXR1cm4gdGhpcy5lY01vZGVsLmdldENvbXBvbmVudChnZXRBeGlzTWFpblR5cGUoYXhpc0RpbSksIGF4aXNJbmRleCk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCBzZXQgdG8gdW5kZWZpbmVkLlxyXG4gICAqL1xuICBEYXRhWm9vbU1vZGVsLnByb3RvdHlwZS5zZXRSYXdSYW5nZSA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHZhciBzZXR0bGVkT3B0aW9uID0gdGhpcy5zZXR0bGVkT3B0aW9uO1xuICAgIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgICAvLyBDb25zaWRlciB0aGUgcGFpciA8c3RhcnQsIHN0YXJ0VmFsdWU+OlxuICAgICAgLy8gSWYgb25lIGhhcyB2YWx1ZSBhbmQgdGhlIG90aGVyIG9uZSBpcyBgbnVsbC91bmRlZmluZWRgLCB3ZSBib3RoIHNldCB0aGVtXG4gICAgICAvLyB0byBgc2V0dGxlZE9wdGlvbmAuIFRoaXMgc3RyYXRlZ3kgZW5hYmxlcyB0aGUgZmVhdHVyZSB0byBjbGVhciB0aGUgb3JpZ2luYWxcbiAgICAgIC8vIHZhbHVlIGluIGBzZXR0bGVkT3B0aW9uYCB0byBgbnVsbC91bmRlZmluZWRgLlxuICAgICAgLy8gQnV0IGlmIGJvdGggb2YgdGhlbSBhcmUgYG51bGwvdW5kZWZpbmVkYCwgd2UgZG8gbm90IHNldCB0aGVtIHRvIGBzZXR0bGVkT3B0aW9uYFxuICAgICAgLy8gYW5kIGtlZXAgYHNldHRsZWRPcHRpb25gIHdpdGggdGhlIG9yaWdpbmFsIHZhbHVlLiBUaGlzIHN0cmF0ZWd5IGVuYWJsZXMgdXNlcnMgdG9cbiAgICAgIC8vIG9ubHkgc2V0IDxlbmQgb3IgZW5kVmFsdWU+IGJ1dCBub3Qgc2V0IDxzdGFydCBvciBzdGFydFZhbHVlPiB3aGVuIGNhbGxpbmdcbiAgICAgIC8vIGBkaXNwYXRjaEFjdGlvbmAuXG4gICAgICAvLyBUaGUgcGFpciA8ZW5kLCBlbmRWYWx1ZT4gaXMgdHJlYXRlZCBpbiB0aGUgc2FtZSB3YXkuXG4gICAgICBpZiAob3B0W25hbWVzWzBdXSAhPSBudWxsIHx8IG9wdFtuYW1lc1sxXV0gIT0gbnVsbCkge1xuICAgICAgICB0aGlzT3B0aW9uW25hbWVzWzBdXSA9IHNldHRsZWRPcHRpb25bbmFtZXNbMF1dID0gb3B0W25hbWVzWzBdXTtcbiAgICAgICAgdGhpc09wdGlvbltuYW1lc1sxXV0gPSBzZXR0bGVkT3B0aW9uW25hbWVzWzFdXSA9IG9wdFtuYW1lc1sxXV07XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fdXBkYXRlUmFuZ2VVc2Uob3B0KTtcbiAgfTtcbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuc2V0Q2FsY3VsYXRlZFJhbmdlID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICBlYWNoKFsnc3RhcnQnLCAnc3RhcnRWYWx1ZScsICdlbmQnLCAnZW5kVmFsdWUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIG9wdGlvbltuYW1lXSA9IG9wdFtuYW1lXTtcbiAgICB9KTtcbiAgfTtcbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuZ2V0UGVyY2VudFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBheGlzUHJveHkgPSB0aGlzLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuICAgIGlmIChheGlzUHJveHkpIHtcbiAgICAgIHJldHVybiBheGlzUHJveHkuZ2V0RGF0YVBlcmNlbnRXaW5kb3coKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEZvciBleGFtcGxlLCBjaGFydC5nZXRNb2RlbCgpLmdldENvbXBvbmVudCgnZGF0YVpvb20nKS5nZXRWYWx1ZVJhbmdlKCd5JywgMCk7XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIFtzdGFydFZhbHVlLCBlbmRWYWx1ZV0gdmFsdWUgY2FuIG9ubHkgYmUgJy0nIG9yIGZpbml0ZSBudW1iZXIuXHJcbiAgICovXG4gIERhdGFab29tTW9kZWwucHJvdG90eXBlLmdldFZhbHVlUmFuZ2UgPSBmdW5jdGlvbiAoYXhpc0RpbSwgYXhpc0luZGV4KSB7XG4gICAgaWYgKGF4aXNEaW0gPT0gbnVsbCAmJiBheGlzSW5kZXggPT0gbnVsbCkge1xuICAgICAgdmFyIGF4aXNQcm94eSA9IHRoaXMuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCk7XG4gICAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICAgIHJldHVybiBheGlzUHJveHkuZ2V0RGF0YVZhbHVlV2luZG93KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEF4aXNQcm94eShheGlzRGltLCBheGlzSW5kZXgpLmdldERhdGFWYWx1ZVdpbmRvdygpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQHBhcmFtIGF4aXNNb2RlbCBJZiBheGlzTW9kZWwgZ2l2ZW4sIGZpbmQgYXhpc1Byb3h5XHJcbiAgICogICAgICBjb3JyZXNwb25kaW5nIHRvIHRoZSBheGlzTW9kZWxcclxuICAgKi9cbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5ID0gZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgIGlmIChheGlzTW9kZWwpIHtcbiAgICAgIHJldHVybiBheGlzTW9kZWwuX19kekF4aXNQcm94eTtcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgaG9zdGVkIGF4aXNQcm94eVxuICAgIHZhciBmaXJzdFByb3h5O1xuICAgIHZhciBheGlzRGltTGlzdCA9IHRoaXMuX3RhcmdldEF4aXNJbmZvTWFwLmtleXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4aXNEaW1MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXhpc0RpbSA9IGF4aXNEaW1MaXN0W2ldO1xuICAgICAgdmFyIGF4aXNJbmZvID0gdGhpcy5fdGFyZ2V0QXhpc0luZm9NYXAuZ2V0KGF4aXNEaW0pO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBheGlzSW5mby5pbmRleExpc3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHByb3h5ID0gdGhpcy5nZXRBeGlzUHJveHkoYXhpc0RpbSwgYXhpc0luZm8uaW5kZXhMaXN0W2pdKTtcbiAgICAgICAgaWYgKHByb3h5Lmhvc3RlZEJ5KHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmlyc3RQcm94eSkge1xuICAgICAgICAgIGZpcnN0UHJveHkgPSBwcm94eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiBubyBob3N0ZWQgcHJveHkgZm91bmQsIHN0aWxsIG5lZWQgdG8gcmV0dXJuIGEgcHJveHkuXG4gICAgLy8gVGhpcyBjYXNlIGFsd2F5cyBoYXBwZW5zIGluIHRvb2xib3ggZGF0YVpvb20sIHdoZXJlIGF4ZXMgYXJlIGFsbCBob3N0ZWQgYnlcbiAgICAvLyBvdGhlciBkYXRhWm9vbXMuXG4gICAgcmV0dXJuIGZpcnN0UHJveHk7XG4gIH07XG4gIERhdGFab29tTW9kZWwucHJvdG90eXBlLmdldFJhbmdlUHJvcE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JhbmdlUHJvcE1vZGUuc2xpY2UoKTtcbiAgfTtcbiAgRGF0YVpvb21Nb2RlbC5wcm90b3R5cGUuZ2V0T3JpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBTaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUgaW5pdGlhbGl6ZWQuXG4gICAgICBhc3NlcnQodGhpcy5fb3JpZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29yaWVudDtcbiAgfTtcbiAgRGF0YVpvb21Nb2RlbC50eXBlID0gJ2RhdGFab29tJztcbiAgRGF0YVpvb21Nb2RlbC5kZXBlbmRlbmNpZXMgPSBbJ3hBeGlzJywgJ3lBeGlzJywgJ3JhZGl1c0F4aXMnLCAnYW5nbGVBeGlzJywgJ3NpbmdsZUF4aXMnLCAnc2VyaWVzJywgJ3Rvb2xib3gnXTtcbiAgRGF0YVpvb21Nb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIC8vIHpsZXZlbDogMCxcbiAgICB6OiA0LFxuICAgIGZpbHRlck1vZGU6ICdmaWx0ZXInLFxuICAgIHN0YXJ0OiAwLFxuICAgIGVuZDogMTAwXG4gIH07XG4gIHJldHVybiBEYXRhWm9vbU1vZGVsO1xufShDb21wb25lbnRNb2RlbCk7XG4vKipcclxuICogUmV0cmlldmUgdGhvc2UgcmF3IHBhcmFtcyBmcm9tIG9wdGlvbiwgd2hpY2ggd2lsbCBiZSBjYWNoZWQgc2VwYXJhdGVseSxcclxuICogYmVjYXVzZSB0aGV5IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgbm9ybWFsaXplZC9jYWxjdWxhdGVkIHZhbHVlcyBpbiB0aGUgbWFpblxyXG4gKiBwcm9jZXNzLlxyXG4gKi9cbmZ1bmN0aW9uIHJldHJpZXZlUmF3T3B0aW9uKG9wdGlvbikge1xuICB2YXIgcmV0ID0ge307XG4gIGVhY2goWydzdGFydCcsICdlbmQnLCAnc3RhcnRWYWx1ZScsICdlbmRWYWx1ZScsICd0aHJvdHRsZSddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIG9wdGlvbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAocmV0W25hbWVdID0gb3B0aW9uW25hbWVdKTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5leHBvcnQgZGVmYXVsdCBEYXRhWm9vbU1vZGVsOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///72012\n")},76302:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ install)\n/* harmony export */ });\n/* unused harmony export DatasetModel */\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15915);\n/* harmony import */ var _view_Component_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(59109);\n/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13430);\n/* harmony import */ var _data_helper_sourceManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40972);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * This module is imported by echarts directly.\r\n *\r\n * Notice:\r\n * Always keep this file exists for backward compatibility.\r\n * Because before 4.1.0, dataset is an optional component,\r\n * some users may import this module manually.\r\n */\n\n\n\n\nvar DatasetModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(DatasetModel, _super);\n  function DatasetModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = \'dataset\';\n    return _this;\n  }\n  DatasetModel.prototype.init = function (option, parentModel, ecModel) {\n    _super.prototype.init.call(this, option, parentModel, ecModel);\n    this._sourceManager = new _data_helper_sourceManager_js__WEBPACK_IMPORTED_MODULE_1__/* .SourceManager */ .R(this);\n    (0,_data_helper_sourceManager_js__WEBPACK_IMPORTED_MODULE_1__/* .disableTransformOptionMerge */ .A)(this);\n  };\n  DatasetModel.prototype.mergeOption = function (newOption, ecModel) {\n    _super.prototype.mergeOption.call(this, newOption, ecModel);\n    (0,_data_helper_sourceManager_js__WEBPACK_IMPORTED_MODULE_1__/* .disableTransformOptionMerge */ .A)(this);\n  };\n  DatasetModel.prototype.optionUpdated = function () {\n    this._sourceManager.dirty();\n  };\n  DatasetModel.prototype.getSourceManager = function () {\n    return this._sourceManager;\n  };\n  DatasetModel.type = \'dataset\';\n  DatasetModel.defaultOption = {\n    seriesLayoutBy: _util_types_js__WEBPACK_IMPORTED_MODULE_2__/* .SERIES_LAYOUT_BY_COLUMN */ .i_\n  };\n  return DatasetModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A);\n\nvar DatasetView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(DatasetView, _super);\n  function DatasetView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = \'dataset\';\n    return _this;\n  }\n  DatasetView.type = \'dataset\';\n  return DatasetView;\n}(_view_Component_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A);\nfunction install(registers) {\n  registers.registerComponentModel(DatasetModel);\n  registers.registerComponentView(DatasetView);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYzMDIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhc2V0L2luc3RhbGwuanM/ZDk2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuLyoqXHJcbiAqIFRoaXMgbW9kdWxlIGlzIGltcG9ydGVkIGJ5IGVjaGFydHMgZGlyZWN0bHkuXHJcbiAqXHJcbiAqIE5vdGljZTpcclxuICogQWx3YXlzIGtlZXAgdGhpcyBmaWxlIGV4aXN0cyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuICogQmVjYXVzZSBiZWZvcmUgNC4xLjAsIGRhdGFzZXQgaXMgYW4gb3B0aW9uYWwgY29tcG9uZW50LFxyXG4gKiBzb21lIHVzZXJzIG1heSBpbXBvcnQgdGhpcyBtb2R1bGUgbWFudWFsbHkuXHJcbiAqL1xuaW1wb3J0IENvbXBvbmVudE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL0NvbXBvbmVudC5qcyc7XG5pbXBvcnQgQ29tcG9uZW50VmlldyBmcm9tICcuLi8uLi92aWV3L0NvbXBvbmVudC5qcyc7XG5pbXBvcnQgeyBTRVJJRVNfTEFZT1VUX0JZX0NPTFVNTiB9IGZyb20gJy4uLy4uL3V0aWwvdHlwZXMuanMnO1xuaW1wb3J0IHsgZGlzYWJsZVRyYW5zZm9ybU9wdGlvbk1lcmdlLCBTb3VyY2VNYW5hZ2VyIH0gZnJvbSAnLi4vLi4vZGF0YS9oZWxwZXIvc291cmNlTWFuYWdlci5qcyc7XG52YXIgRGF0YXNldE1vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKERhdGFzZXRNb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRGF0YXNldE1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSAnZGF0YXNldCc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIERhdGFzZXRNb2RlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgb3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCk7XG4gICAgdGhpcy5fc291cmNlTWFuYWdlciA9IG5ldyBTb3VyY2VNYW5hZ2VyKHRoaXMpO1xuICAgIGRpc2FibGVUcmFuc2Zvcm1PcHRpb25NZXJnZSh0aGlzKTtcbiAgfTtcbiAgRGF0YXNldE1vZGVsLnByb3RvdHlwZS5tZXJnZU9wdGlvbiA9IGZ1bmN0aW9uIChuZXdPcHRpb24sIGVjTW9kZWwpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLm1lcmdlT3B0aW9uLmNhbGwodGhpcywgbmV3T3B0aW9uLCBlY01vZGVsKTtcbiAgICBkaXNhYmxlVHJhbnNmb3JtT3B0aW9uTWVyZ2UodGhpcyk7XG4gIH07XG4gIERhdGFzZXRNb2RlbC5wcm90b3R5cGUub3B0aW9uVXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zb3VyY2VNYW5hZ2VyLmRpcnR5KCk7XG4gIH07XG4gIERhdGFzZXRNb2RlbC5wcm90b3R5cGUuZ2V0U291cmNlTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlTWFuYWdlcjtcbiAgfTtcbiAgRGF0YXNldE1vZGVsLnR5cGUgPSAnZGF0YXNldCc7XG4gIERhdGFzZXRNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIHNlcmllc0xheW91dEJ5OiBTRVJJRVNfTEFZT1VUX0JZX0NPTFVNTlxuICB9O1xuICByZXR1cm4gRGF0YXNldE1vZGVsO1xufShDb21wb25lbnRNb2RlbCk7XG5leHBvcnQgeyBEYXRhc2V0TW9kZWwgfTtcbnZhciBEYXRhc2V0VmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhEYXRhc2V0VmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRGF0YXNldFZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9ICdkYXRhc2V0JztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgRGF0YXNldFZpZXcudHlwZSA9ICdkYXRhc2V0JztcbiAgcmV0dXJuIERhdGFzZXRWaWV3O1xufShDb21wb25lbnRWaWV3KTtcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChEYXRhc2V0TW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KERhdGFzZXRWaWV3KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///76302\n')},78668:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IU: () => (/* binding */ clear),\n/* harmony export */   U9: () => (/* binding */ count),\n/* harmony export */   VC: () => (/* binding */ push),\n/* harmony export */   uY: () => (/* binding */ pop)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar each = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each;\nvar inner = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .makeInner */ .$r)();\n/**\r\n * @param ecModel\r\n * @param newSnapshot key is dataZoomId\r\n */\nfunction push(ecModel, newSnapshot) {\n  var storedSnapshots = getStoreSnapshots(ecModel);\n  // If previous dataZoom can not be found,\n  // complete an range with current range.\n  each(newSnapshot, function (batchItem, dataZoomId) {\n    var i = storedSnapshots.length - 1;\n    for (; i >= 0; i--) {\n      var snapshot = storedSnapshots[i];\n      if (snapshot[dataZoomId]) {\n        break;\n      }\n    }\n    if (i < 0) {\n      // No origin range set, create one by current range.\n      var dataZoomModel = ecModel.queryComponents({\n        mainType: \'dataZoom\',\n        subType: \'select\',\n        id: dataZoomId\n      })[0];\n      if (dataZoomModel) {\n        var percentRange = dataZoomModel.getPercentRange();\n        storedSnapshots[0][dataZoomId] = {\n          dataZoomId: dataZoomId,\n          start: percentRange[0],\n          end: percentRange[1]\n        };\n      }\n    }\n  });\n  storedSnapshots.push(newSnapshot);\n}\nfunction pop(ecModel) {\n  var storedSnapshots = getStoreSnapshots(ecModel);\n  var head = storedSnapshots[storedSnapshots.length - 1];\n  storedSnapshots.length > 1 && storedSnapshots.pop();\n  // Find top for all dataZoom.\n  var snapshot = {};\n  each(head, function (batchItem, dataZoomId) {\n    for (var i = storedSnapshots.length - 1; i >= 0; i--) {\n      batchItem = storedSnapshots[i][dataZoomId];\n      if (batchItem) {\n        snapshot[dataZoomId] = batchItem;\n        break;\n      }\n    }\n  });\n  return snapshot;\n}\nfunction clear(ecModel) {\n  inner(ecModel).snapshots = null;\n}\nfunction count(ecModel) {\n  return getStoreSnapshots(ecModel).length;\n}\n/**\r\n * History length of each dataZoom may be different.\r\n * this._history[0] is used to store origin range.\r\n */\nfunction getStoreSnapshots(ecModel) {\n  var store = inner(ecModel);\n  if (!store.snapshots) {\n    store.snapshots = [{}];\n  }\n  return store.snapshots;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg2NjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9oaXN0b3J5LmpzPzdkZWUiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IG1ha2VJbm5lciB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xuLyoqXHJcbiAqIEBwYXJhbSBlY01vZGVsXHJcbiAqIEBwYXJhbSBuZXdTbmFwc2hvdCBrZXkgaXMgZGF0YVpvb21JZFxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwdXNoKGVjTW9kZWwsIG5ld1NuYXBzaG90KSB7XG4gIHZhciBzdG9yZWRTbmFwc2hvdHMgPSBnZXRTdG9yZVNuYXBzaG90cyhlY01vZGVsKTtcbiAgLy8gSWYgcHJldmlvdXMgZGF0YVpvb20gY2FuIG5vdCBiZSBmb3VuZCxcbiAgLy8gY29tcGxldGUgYW4gcmFuZ2Ugd2l0aCBjdXJyZW50IHJhbmdlLlxuICBlYWNoKG5ld1NuYXBzaG90LCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBkYXRhWm9vbUlkKSB7XG4gICAgdmFyIGkgPSBzdG9yZWRTbmFwc2hvdHMubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBzbmFwc2hvdCA9IHN0b3JlZFNuYXBzaG90c1tpXTtcbiAgICAgIGlmIChzbmFwc2hvdFtkYXRhWm9vbUlkXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICAvLyBObyBvcmlnaW4gcmFuZ2Ugc2V0LCBjcmVhdGUgb25lIGJ5IGN1cnJlbnQgcmFuZ2UuXG4gICAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgbWFpblR5cGU6ICdkYXRhWm9vbScsXG4gICAgICAgIHN1YlR5cGU6ICdzZWxlY3QnLFxuICAgICAgICBpZDogZGF0YVpvb21JZFxuICAgICAgfSlbMF07XG4gICAgICBpZiAoZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICB2YXIgcGVyY2VudFJhbmdlID0gZGF0YVpvb21Nb2RlbC5nZXRQZXJjZW50UmFuZ2UoKTtcbiAgICAgICAgc3RvcmVkU25hcHNob3RzWzBdW2RhdGFab29tSWRdID0ge1xuICAgICAgICAgIGRhdGFab29tSWQ6IGRhdGFab29tSWQsXG4gICAgICAgICAgc3RhcnQ6IHBlcmNlbnRSYW5nZVswXSxcbiAgICAgICAgICBlbmQ6IHBlcmNlbnRSYW5nZVsxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHN0b3JlZFNuYXBzaG90cy5wdXNoKG5ld1NuYXBzaG90KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3AoZWNNb2RlbCkge1xuICB2YXIgc3RvcmVkU25hcHNob3RzID0gZ2V0U3RvcmVTbmFwc2hvdHMoZWNNb2RlbCk7XG4gIHZhciBoZWFkID0gc3RvcmVkU25hcHNob3RzW3N0b3JlZFNuYXBzaG90cy5sZW5ndGggLSAxXTtcbiAgc3RvcmVkU25hcHNob3RzLmxlbmd0aCA+IDEgJiYgc3RvcmVkU25hcHNob3RzLnBvcCgpO1xuICAvLyBGaW5kIHRvcCBmb3IgYWxsIGRhdGFab29tLlxuICB2YXIgc25hcHNob3QgPSB7fTtcbiAgZWFjaChoZWFkLCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBkYXRhWm9vbUlkKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0b3JlZFNuYXBzaG90cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgYmF0Y2hJdGVtID0gc3RvcmVkU25hcHNob3RzW2ldW2RhdGFab29tSWRdO1xuICAgICAgaWYgKGJhdGNoSXRlbSkge1xuICAgICAgICBzbmFwc2hvdFtkYXRhWm9vbUlkXSA9IGJhdGNoSXRlbTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNuYXBzaG90O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKGVjTW9kZWwpIHtcbiAgaW5uZXIoZWNNb2RlbCkuc25hcHNob3RzID0gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb3VudChlY01vZGVsKSB7XG4gIHJldHVybiBnZXRTdG9yZVNuYXBzaG90cyhlY01vZGVsKS5sZW5ndGg7XG59XG4vKipcclxuICogSGlzdG9yeSBsZW5ndGggb2YgZWFjaCBkYXRhWm9vbSBtYXkgYmUgZGlmZmVyZW50LlxyXG4gKiB0aGlzLl9oaXN0b3J5WzBdIGlzIHVzZWQgdG8gc3RvcmUgb3JpZ2luIHJhbmdlLlxyXG4gKi9cbmZ1bmN0aW9uIGdldFN0b3JlU25hcHNob3RzKGVjTW9kZWwpIHtcbiAgdmFyIHN0b3JlID0gaW5uZXIoZWNNb2RlbCk7XG4gIGlmICghc3RvcmUuc25hcHNob3RzKSB7XG4gICAgc3RvcmUuc25hcHNob3RzID0gW3t9XTtcbiAgfVxuICByZXR1cm4gc3RvcmUuc25hcHNob3RzO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///78668\n')},91695:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n;// ./node_modules/echarts/lib/component/brush/preprocessor.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar DEFAULT_TOOLBOX_BTNS = ['rect', 'polygon', 'keep', 'clear'];\nfunction brushPreprocessor(option, isNew) {\n  var brushComponents = (0,model/* normalizeToArray */.qB)(option ? option.brush : []);\n  if (!brushComponents.length) {\n    return;\n  }\n  var brushComponentSpecifiedBtns = [];\n  util.each(brushComponents, function (brushOpt) {\n    var tbs = brushOpt.hasOwnProperty('toolbox') ? brushOpt.toolbox : [];\n    if (tbs instanceof Array) {\n      brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);\n    }\n  });\n  var toolbox = option && option.toolbox;\n  if (util.isArray(toolbox)) {\n    toolbox = toolbox[0];\n  }\n  if (!toolbox) {\n    toolbox = {\n      feature: {}\n    };\n    option.toolbox = [toolbox];\n  }\n  var toolboxFeature = toolbox.feature || (toolbox.feature = {});\n  var toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});\n  var brushTypes = toolboxBrush.type || (toolboxBrush.type = []);\n  brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);\n  removeDuplicate(brushTypes);\n  if (isNew && !brushTypes.length) {\n    brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);\n  }\n}\nfunction removeDuplicate(arr) {\n  var map = {};\n  util.each(arr, function (val) {\n    map[val] = 1;\n  });\n  arr.length = 0;\n  util.each(map, function (flag, val) {\n    arr.push(val);\n  });\n}\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/BrushController.js\nvar BrushController = __webpack_require__(14403);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/BoundingRect.js\nvar BoundingRect = __webpack_require__(29308);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/visualSolution.js\nvar visualSolution = __webpack_require__(6372);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/contain/polygon.js\nvar polygon = __webpack_require__(51183);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n;// ./node_modules/echarts/lib/component/brush/selector.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction makeBrushCommonSelectorForSeries(area) {\n  var brushType = area.brushType;\n  // Do not use function binding or curry for performance.\n  var selectors = {\n    point: function (itemLayout) {\n      return selector[brushType].point(itemLayout, selectors, area);\n    },\n    rect: function (itemLayout) {\n      return selector[brushType].rect(itemLayout, selectors, area);\n    }\n  };\n  return selectors;\n}\nvar selector = {\n  lineX: getLineSelectors(0),\n  lineY: getLineSelectors(1),\n  rect: {\n    point: function (itemLayout, selectors, area) {\n      return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]);\n    },\n    rect: function (itemLayout, selectors, area) {\n      return itemLayout && area.boundingRect.intersect(itemLayout);\n    }\n  },\n  polygon: {\n    point: function (itemLayout, selectors, area) {\n      return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]) && polygon/* contain */.l(area.range, itemLayout[0], itemLayout[1]);\n    },\n    rect: function (itemLayout, selectors, area) {\n      var points = area.range;\n      if (!itemLayout || points.length <= 1) {\n        return false;\n      }\n      var x = itemLayout.x;\n      var y = itemLayout.y;\n      var width = itemLayout.width;\n      var height = itemLayout.height;\n      var p = points[0];\n      if (polygon/* contain */.l(points, x, y) || polygon/* contain */.l(points, x + width, y) || polygon/* contain */.l(points, x, y + height) || polygon/* contain */.l(points, x + width, y + height) || BoundingRect/* default */.A.create(itemLayout).contain(p[0], p[1]) || (0,graphic.linePolygonIntersect)(x, y, x + width, y, points) || (0,graphic.linePolygonIntersect)(x, y, x, y + height, points) || (0,graphic.linePolygonIntersect)(x + width, y, x + width, y + height, points) || (0,graphic.linePolygonIntersect)(x, y + height, x + width, y + height, points)) {\n        return true;\n      }\n    }\n  }\n};\nfunction getLineSelectors(xyIndex) {\n  var xy = ['x', 'y'];\n  var wh = ['width', 'height'];\n  return {\n    point: function (itemLayout, selectors, area) {\n      if (itemLayout) {\n        var range = area.range;\n        var p = itemLayout[xyIndex];\n        return inLineRange(p, range);\n      }\n    },\n    rect: function (itemLayout, selectors, area) {\n      if (itemLayout) {\n        var range = area.range;\n        var layoutRange = [itemLayout[xy[xyIndex]], itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]];\n        layoutRange[1] < layoutRange[0] && layoutRange.reverse();\n        return inLineRange(layoutRange[0], range) || inLineRange(layoutRange[1], range) || inLineRange(range[0], layoutRange) || inLineRange(range[1], layoutRange);\n      }\n    }\n  };\n}\nfunction inLineRange(p, range) {\n  return range[0] <= p && p <= range[1];\n}\n/* harmony default export */ const brush_selector = ((/* unused pure expression or super */ null && (selector)));\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/throttle.js\nvar throttle = __webpack_require__(24711);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/BrushTargetManager.js\nvar BrushTargetManager = __webpack_require__(98595);\n;// ./node_modules/echarts/lib/component/brush/visualEncoding.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\nvar STATE_LIST = ['inBrush', 'outOfBrush'];\nvar DISPATCH_METHOD = '__ecBrushSelect';\nvar DISPATCH_FLAG = '__ecInBrushSelectEvent';\n;\nfunction layoutCovers(ecModel) {\n  ecModel.eachComponent({\n    mainType: 'brush'\n  }, function (brushModel) {\n    var brushTargetManager = brushModel.brushTargetManager = new BrushTargetManager/* default */.A(brushModel.option, ecModel);\n    brushTargetManager.setInputRanges(brushModel.areas, ecModel);\n  });\n}\n/**\r\n * Register the visual encoding if this modules required.\r\n */\nfunction brushVisual(ecModel, api, payload) {\n  var brushSelected = [];\n  var throttleType;\n  var throttleDelay;\n  ecModel.eachComponent({\n    mainType: 'brush'\n  }, function (brushModel) {\n    payload && payload.type === 'takeGlobalCursor' && brushModel.setBrushOption(payload.key === 'brush' ? payload.brushOption : {\n      brushType: false\n    });\n  });\n  layoutCovers(ecModel);\n  ecModel.eachComponent({\n    mainType: 'brush'\n  }, function (brushModel, brushIndex) {\n    var thisBrushSelected = {\n      brushId: brushModel.id,\n      brushIndex: brushIndex,\n      brushName: brushModel.name,\n      areas: util.clone(brushModel.areas),\n      selected: []\n    };\n    // Every brush component exists in event params, convenient\n    // for user to find by index.\n    brushSelected.push(thisBrushSelected);\n    var brushOption = brushModel.option;\n    var brushLink = brushOption.brushLink;\n    var linkedSeriesMap = [];\n    var selectedDataIndexForLink = [];\n    var rangeInfoBySeries = [];\n    var hasBrushExists = false;\n    if (!brushIndex) {\n      // Only the first throttle setting works.\n      throttleType = brushOption.throttleType;\n      throttleDelay = brushOption.throttleDelay;\n    }\n    // Add boundingRect and selectors to range.\n    var areas = util.map(brushModel.areas, function (area) {\n      var builder = boundingRectBuilders[area.brushType];\n      var selectableArea = util.defaults({\n        boundingRect: builder ? builder(area) : void 0\n      }, area);\n      selectableArea.selectors = makeBrushCommonSelectorForSeries(selectableArea);\n      return selectableArea;\n    });\n    var visualMappings = visualSolution/* createVisualMappings */.u1(brushModel.option, STATE_LIST, function (mappingOption) {\n      mappingOption.mappingMethod = 'fixed';\n    });\n    util.isArray(brushLink) && util.each(brushLink, function (seriesIndex) {\n      linkedSeriesMap[seriesIndex] = 1;\n    });\n    function linkOthers(seriesIndex) {\n      return brushLink === 'all' || !!linkedSeriesMap[seriesIndex];\n    }\n    // If no supported brush or no brush on the series,\n    // all visuals should be in original state.\n    function brushed(rangeInfoList) {\n      return !!rangeInfoList.length;\n    }\n    /**\r\n     * Logic for each series: (If the logic has to be modified one day, do it carefully!)\r\n     *\r\n     * ( brushed ┬ && ┬hasBrushExist ┬ && linkOthers  ) => StepA: ┬record, ┬ StepB: ┬visualByRecord.\r\n     *   !brushed┘    ├hasBrushExist ┤                            └nothing,┘        ├visualByRecord.\r\n     *                └!hasBrushExist┘                                              └nothing.\r\n     * ( !brushed  && ┬hasBrushExist ┬ && linkOthers  ) => StepA:  nothing,  StepB: ┬visualByRecord.\r\n     *                └!hasBrushExist┘                                              └nothing.\r\n     * ( brushed ┬ &&                     !linkOthers ) => StepA:  nothing,  StepB: ┬visualByCheck.\r\n     *   !brushed┘                                                                  └nothing.\r\n     * ( !brushed  &&                     !linkOthers ) => StepA:  nothing,  StepB:  nothing.\r\n     */\n    // Step A\n    ecModel.eachSeries(function (seriesModel, seriesIndex) {\n      var rangeInfoList = rangeInfoBySeries[seriesIndex] = [];\n      seriesModel.subType === 'parallel' ? stepAParallel(seriesModel, seriesIndex) : stepAOthers(seriesModel, seriesIndex, rangeInfoList);\n    });\n    function stepAParallel(seriesModel, seriesIndex) {\n      var coordSys = seriesModel.coordinateSystem;\n      hasBrushExists = hasBrushExists || coordSys.hasAxisBrushed();\n      linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function (activeState, dataIndex) {\n        activeState === 'active' && (selectedDataIndexForLink[dataIndex] = 1);\n      });\n    }\n    function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {\n      if (!seriesModel.brushSelector || brushModelNotControll(brushModel, seriesIndex)) {\n        return;\n      }\n      util.each(areas, function (area) {\n        if (brushModel.brushTargetManager.controlSeries(area, seriesModel, ecModel)) {\n          rangeInfoList.push(area);\n        }\n        hasBrushExists = hasBrushExists || brushed(rangeInfoList);\n      });\n      if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {\n        var data_1 = seriesModel.getData();\n        data_1.each(function (dataIndex) {\n          if (checkInRange(seriesModel, rangeInfoList, data_1, dataIndex)) {\n            selectedDataIndexForLink[dataIndex] = 1;\n          }\n        });\n      }\n    }\n    // Step B\n    ecModel.eachSeries(function (seriesModel, seriesIndex) {\n      var seriesBrushSelected = {\n        seriesId: seriesModel.id,\n        seriesIndex: seriesIndex,\n        seriesName: seriesModel.name,\n        dataIndex: []\n      };\n      // Every series exists in event params, convenient\n      // for user to find series by seriesIndex.\n      thisBrushSelected.selected.push(seriesBrushSelected);\n      var rangeInfoList = rangeInfoBySeries[seriesIndex];\n      var data = seriesModel.getData();\n      var getValueState = linkOthers(seriesIndex) ? function (dataIndex) {\n        return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush') : 'outOfBrush';\n      } : function (dataIndex) {\n        return checkInRange(seriesModel, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush') : 'outOfBrush';\n      };\n      // If no supported brush or no brush, all visuals are in original state.\n      (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && visualSolution/* applyVisual */.R3(STATE_LIST, visualMappings, data, getValueState);\n    });\n  });\n  dispatchAction(api, throttleType, throttleDelay, brushSelected, payload);\n}\n;\nfunction dispatchAction(api, throttleType, throttleDelay, brushSelected, payload) {\n  // This event will not be triggered when `setOpion`, otherwise dead lock may\n  // triggered when do `setOption` in event listener, which we do not find\n  // satisfactory way to solve yet. Some considered resolutions:\n  // (a) Diff with prevoius selected data ant only trigger event when changed.\n  // But store previous data and diff precisely (i.e., not only by dataIndex, but\n  // also detect value changes in selected data) might bring complexity or fragility.\n  // (b) Use spectial param like `silent` to suppress event triggering.\n  // But such kind of volatile param may be weird in `setOption`.\n  if (!payload) {\n    return;\n  }\n  var zr = api.getZr();\n  if (zr[DISPATCH_FLAG]) {\n    return;\n  }\n  if (!zr[DISPATCH_METHOD]) {\n    zr[DISPATCH_METHOD] = doDispatch;\n  }\n  var fn = throttle/* createOrUpdate */.N(zr, DISPATCH_METHOD, throttleDelay, throttleType);\n  fn(api, brushSelected);\n}\nfunction doDispatch(api, brushSelected) {\n  if (!api.isDisposed()) {\n    var zr = api.getZr();\n    zr[DISPATCH_FLAG] = true;\n    api.dispatchAction({\n      type: 'brushSelect',\n      batch: brushSelected\n    });\n    zr[DISPATCH_FLAG] = false;\n  }\n}\nfunction checkInRange(seriesModel, rangeInfoList, data, dataIndex) {\n  for (var i = 0, len = rangeInfoList.length; i < len; i++) {\n    var area = rangeInfoList[i];\n    if (seriesModel.brushSelector(dataIndex, data, area.selectors, area)) {\n      return true;\n    }\n  }\n}\nfunction brushModelNotControll(brushModel, seriesIndex) {\n  var seriesIndices = brushModel.option.seriesIndex;\n  return seriesIndices != null && seriesIndices !== 'all' && (util.isArray(seriesIndices) ? util.indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices);\n}\nvar boundingRectBuilders = {\n  rect: function (area) {\n    return getBoundingRectFromMinMax(area.range);\n  },\n  polygon: function (area) {\n    var minMax;\n    var range = area.range;\n    for (var i = 0, len = range.length; i < len; i++) {\n      minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];\n      var rg = range[i];\n      rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);\n      rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);\n      rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);\n      rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);\n    }\n    return minMax && getBoundingRectFromMinMax(minMax);\n  }\n};\nfunction getBoundingRectFromMinMax(minMax) {\n  return new BoundingRect/* default */.A(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0]);\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar Component = __webpack_require__(59109);\n;// ./node_modules/echarts/lib/component/brush/BrushView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar BrushView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(BrushView, _super);\n  function BrushView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = BrushView.type;\n    return _this;\n  }\n  BrushView.prototype.init = function (ecModel, api) {\n    this.ecModel = ecModel;\n    this.api = api;\n    this.model;\n    (this._brushController = new BrushController/* default */.A(api.getZr())).on('brush', util.bind(this._onBrush, this)).mount();\n  };\n  BrushView.prototype.render = function (brushModel, ecModel, api, payload) {\n    this.model = brushModel;\n    this._updateController(brushModel, ecModel, api, payload);\n  };\n  BrushView.prototype.updateTransform = function (brushModel, ecModel, api, payload) {\n    // PENDING: `updateTransform` is a little tricky, whose layout need\n    // to be calculate mandatorily and other stages will not be performed.\n    // Take care the correctness of the logic. See #11754 .\n    layoutCovers(ecModel);\n    this._updateController(brushModel, ecModel, api, payload);\n  };\n  BrushView.prototype.updateVisual = function (brushModel, ecModel, api, payload) {\n    this.updateTransform(brushModel, ecModel, api, payload);\n  };\n  BrushView.prototype.updateView = function (brushModel, ecModel, api, payload) {\n    this._updateController(brushModel, ecModel, api, payload);\n  };\n  BrushView.prototype._updateController = function (brushModel, ecModel, api, payload) {\n    // Do not update controller when drawing.\n    (!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());\n  };\n  // updateLayout: updateController,\n  // updateVisual: updateController,\n  BrushView.prototype.dispose = function () {\n    this._brushController.dispose();\n  };\n  BrushView.prototype._onBrush = function (eventParam) {\n    var modelId = this.model.id;\n    var areas = this.model.brushTargetManager.setOutputRanges(eventParam.areas, this.ecModel);\n    // Action is not dispatched on drag end, because the drag end\n    // emits the same params with the last drag move event, and\n    // may have some delay when using touch pad, which makes\n    // animation not smooth (when using debounce).\n    (!eventParam.isEnd || eventParam.removeOnClick) && this.api.dispatchAction({\n      type: 'brush',\n      brushId: modelId,\n      areas: util.clone(areas),\n      $from: modelId\n    });\n    eventParam.isEnd && this.api.dispatchAction({\n      type: 'brushEnd',\n      brushId: modelId,\n      areas: util.clone(areas),\n      $from: modelId\n    });\n  };\n  BrushView.type = 'brush';\n  return BrushView;\n}(Component/* default */.A);\n/* harmony default export */ const brush_BrushView = (BrushView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Model.js + 2 modules\nvar Model = __webpack_require__(43172);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Component.js\nvar model_Component = __webpack_require__(15915);\n;// ./node_modules/echarts/lib/component/brush/BrushModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar DEFAULT_OUT_OF_BRUSH_COLOR = '#ddd';\nvar BrushModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(BrushModel, _super);\n  function BrushModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = BrushModel.type;\n    /**\r\n     * @readOnly\r\n     */\n    _this.areas = [];\n    /**\r\n     * Current brush painting area settings.\r\n     * @readOnly\r\n     */\n    _this.brushOption = {};\n    return _this;\n  }\n  BrushModel.prototype.optionUpdated = function (newOption, isInit) {\n    var thisOption = this.option;\n    !isInit && visualSolution/* replaceVisualOption */.St(thisOption, newOption, ['inBrush', 'outOfBrush']);\n    var inBrush = thisOption.inBrush = thisOption.inBrush || {};\n    // Always give default visual, consider setOption at the second time.\n    thisOption.outOfBrush = thisOption.outOfBrush || {\n      color: DEFAULT_OUT_OF_BRUSH_COLOR\n    };\n    if (!inBrush.hasOwnProperty('liftZ')) {\n      // Bigger than the highlight z lift, otherwise it will\n      // be effected by the highlight z when brush.\n      inBrush.liftZ = 5;\n    }\n  };\n  /**\r\n   * If `areas` is null/undefined, range state remain.\r\n   */\n  BrushModel.prototype.setAreas = function (areas) {\n    if (false) {}\n    // If areas is null/undefined, range state remain.\n    // This helps user to dispatchAction({type: 'brush'}) with no areas\n    // set but just want to get the current brush select info from a `brush` event.\n    if (!areas) {\n      return;\n    }\n    this.areas = util.map(areas, function (area) {\n      return generateBrushOption(this.option, area);\n    }, this);\n  };\n  /**\r\n   * Set the current painting brush option.\r\n   */\n  BrushModel.prototype.setBrushOption = function (brushOption) {\n    this.brushOption = generateBrushOption(this.option, brushOption);\n    this.brushType = this.brushOption.brushType;\n  };\n  BrushModel.type = 'brush';\n  BrushModel.dependencies = ['geo', 'grid', 'xAxis', 'yAxis', 'parallel', 'series'];\n  BrushModel.defaultOption = {\n    seriesIndex: 'all',\n    brushType: 'rect',\n    brushMode: 'single',\n    transformable: true,\n    brushStyle: {\n      borderWidth: 1,\n      color: 'rgba(210,219,238,0.3)',\n      borderColor: '#D2DBEE'\n    },\n    throttleType: 'fixRate',\n    throttleDelay: 0,\n    removeOnClick: true,\n    z: 10000\n  };\n  return BrushModel;\n}(model_Component/* default */.A);\nfunction generateBrushOption(option, brushOption) {\n  return util.merge({\n    brushType: option.brushType,\n    brushMode: option.brushMode,\n    transformable: option.transformable,\n    brushStyle: new Model/* default */.A(option.brushStyle).getItemStyle(),\n    removeOnClick: option.removeOnClick,\n    z: option.z\n  }, brushOption, true);\n}\n/* harmony default export */ const brush_BrushModel = (BrushModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/toolbox/feature/Brush.js\nvar Brush = __webpack_require__(55855);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/toolbox/featureManager.js\nvar featureManager = __webpack_require__(16985);\n;// ./node_modules/echarts/lib/component/brush/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n// TODO\n\n\n\nfunction install(registers) {\n  registers.registerComponentView(brush_BrushView);\n  registers.registerComponentModel(brush_BrushModel);\n  registers.registerPreprocessor(brushPreprocessor);\n  registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, brushVisual);\n  registers.registerAction({\n    type: 'brush',\n    event: 'brush',\n    update: 'updateVisual'\n  }, function (payload, ecModel) {\n    ecModel.eachComponent({\n      mainType: 'brush',\n      query: payload\n    }, function (brushModel) {\n      brushModel.setAreas(payload.areas);\n    });\n  });\n  /**\r\n   * payload: {\r\n   *      brushComponents: [\r\n   *          {\r\n   *              brushId,\r\n   *              brushIndex,\r\n   *              brushName,\r\n   *              series: [\r\n   *                  {\r\n   *                      seriesId,\r\n   *                      seriesIndex,\r\n   *                      seriesName,\r\n   *                      rawIndices: [21, 34, ...]\r\n   *                  },\r\n   *                  ...\r\n   *              ]\r\n   *          },\r\n   *          ...\r\n   *      ]\r\n   * }\r\n   */\n  registers.registerAction({\n    type: 'brushSelect',\n    event: 'brushSelected',\n    update: 'none'\n  }, util.noop);\n  registers.registerAction({\n    type: 'brushEnd',\n    event: 'brushEnd',\n    update: 'none'\n  }, util.noop);\n  (0,featureManager/* registerFeature */.M_)('brush', Brush/* default */.A);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTE2OTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYnJ1c2gvcHJlcHJvY2Vzc29yLmpzP2JmNjAiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9icnVzaC9zZWxlY3Rvci5qcz9iNGQyIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYnJ1c2gvdmlzdWFsRW5jb2RpbmcuanM/OTMxMCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2JydXNoL0JydXNoVmlldy5qcz9iNDhkIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYnJ1c2gvQnJ1c2hNb2RlbC5qcz85NTY3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvYnJ1c2gvaW5zdGFsbC5qcz8wMjUxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVUb0FycmF5IH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG52YXIgREVGQVVMVF9UT09MQk9YX0JUTlMgPSBbJ3JlY3QnLCAncG9seWdvbicsICdrZWVwJywgJ2NsZWFyJ107XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBicnVzaFByZXByb2Nlc3NvcihvcHRpb24sIGlzTmV3KSB7XG4gIHZhciBicnVzaENvbXBvbmVudHMgPSBub3JtYWxpemVUb0FycmF5KG9wdGlvbiA/IG9wdGlvbi5icnVzaCA6IFtdKTtcbiAgaWYgKCFicnVzaENvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBicnVzaENvbXBvbmVudFNwZWNpZmllZEJ0bnMgPSBbXTtcbiAgenJVdGlsLmVhY2goYnJ1c2hDb21wb25lbnRzLCBmdW5jdGlvbiAoYnJ1c2hPcHQpIHtcbiAgICB2YXIgdGJzID0gYnJ1c2hPcHQuaGFzT3duUHJvcGVydHkoJ3Rvb2xib3gnKSA/IGJydXNoT3B0LnRvb2xib3ggOiBbXTtcbiAgICBpZiAodGJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGJydXNoQ29tcG9uZW50U3BlY2lmaWVkQnRucyA9IGJydXNoQ29tcG9uZW50U3BlY2lmaWVkQnRucy5jb25jYXQodGJzKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgdG9vbGJveCA9IG9wdGlvbiAmJiBvcHRpb24udG9vbGJveDtcbiAgaWYgKHpyVXRpbC5pc0FycmF5KHRvb2xib3gpKSB7XG4gICAgdG9vbGJveCA9IHRvb2xib3hbMF07XG4gIH1cbiAgaWYgKCF0b29sYm94KSB7XG4gICAgdG9vbGJveCA9IHtcbiAgICAgIGZlYXR1cmU6IHt9XG4gICAgfTtcbiAgICBvcHRpb24udG9vbGJveCA9IFt0b29sYm94XTtcbiAgfVxuICB2YXIgdG9vbGJveEZlYXR1cmUgPSB0b29sYm94LmZlYXR1cmUgfHwgKHRvb2xib3guZmVhdHVyZSA9IHt9KTtcbiAgdmFyIHRvb2xib3hCcnVzaCA9IHRvb2xib3hGZWF0dXJlLmJydXNoIHx8ICh0b29sYm94RmVhdHVyZS5icnVzaCA9IHt9KTtcbiAgdmFyIGJydXNoVHlwZXMgPSB0b29sYm94QnJ1c2gudHlwZSB8fCAodG9vbGJveEJydXNoLnR5cGUgPSBbXSk7XG4gIGJydXNoVHlwZXMucHVzaC5hcHBseShicnVzaFR5cGVzLCBicnVzaENvbXBvbmVudFNwZWNpZmllZEJ0bnMpO1xuICByZW1vdmVEdXBsaWNhdGUoYnJ1c2hUeXBlcyk7XG4gIGlmIChpc05ldyAmJiAhYnJ1c2hUeXBlcy5sZW5ndGgpIHtcbiAgICBicnVzaFR5cGVzLnB1c2guYXBwbHkoYnJ1c2hUeXBlcywgREVGQVVMVF9UT09MQk9YX0JUTlMpO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGUoYXJyKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgenJVdGlsLmVhY2goYXJyLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgbWFwW3ZhbF0gPSAxO1xuICB9KTtcbiAgYXJyLmxlbmd0aCA9IDA7XG4gIHpyVXRpbC5lYWNoKG1hcCwgZnVuY3Rpb24gKGZsYWcsIHZhbCkge1xuICAgIGFyci5wdXNoKHZhbCk7XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgcG9seWdvbkNvbnRhaW4gZnJvbSAnenJlbmRlci9saWIvY29udGFpbi9wb2x5Z29uLmpzJztcbmltcG9ydCBCb3VuZGluZ1JlY3QgZnJvbSAnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMnO1xuaW1wb3J0IHsgbGluZVBvbHlnb25JbnRlcnNlY3QgfSBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VCcnVzaENvbW1vblNlbGVjdG9yRm9yU2VyaWVzKGFyZWEpIHtcbiAgdmFyIGJydXNoVHlwZSA9IGFyZWEuYnJ1c2hUeXBlO1xuICAvLyBEbyBub3QgdXNlIGZ1bmN0aW9uIGJpbmRpbmcgb3IgY3VycnkgZm9yIHBlcmZvcm1hbmNlLlxuICB2YXIgc2VsZWN0b3JzID0ge1xuICAgIHBvaW50OiBmdW5jdGlvbiAoaXRlbUxheW91dCkge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yW2JydXNoVHlwZV0ucG9pbnQoaXRlbUxheW91dCwgc2VsZWN0b3JzLCBhcmVhKTtcbiAgICB9LFxuICAgIHJlY3Q6IGZ1bmN0aW9uIChpdGVtTGF5b3V0KSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3JbYnJ1c2hUeXBlXS5yZWN0KGl0ZW1MYXlvdXQsIHNlbGVjdG9ycywgYXJlYSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gc2VsZWN0b3JzO1xufVxudmFyIHNlbGVjdG9yID0ge1xuICBsaW5lWDogZ2V0TGluZVNlbGVjdG9ycygwKSxcbiAgbGluZVk6IGdldExpbmVTZWxlY3RvcnMoMSksXG4gIHJlY3Q6IHtcbiAgICBwb2ludDogZnVuY3Rpb24gKGl0ZW1MYXlvdXQsIHNlbGVjdG9ycywgYXJlYSkge1xuICAgICAgcmV0dXJuIGl0ZW1MYXlvdXQgJiYgYXJlYS5ib3VuZGluZ1JlY3QuY29udGFpbihpdGVtTGF5b3V0WzBdLCBpdGVtTGF5b3V0WzFdKTtcbiAgICB9LFxuICAgIHJlY3Q6IGZ1bmN0aW9uIChpdGVtTGF5b3V0LCBzZWxlY3RvcnMsIGFyZWEpIHtcbiAgICAgIHJldHVybiBpdGVtTGF5b3V0ICYmIGFyZWEuYm91bmRpbmdSZWN0LmludGVyc2VjdChpdGVtTGF5b3V0KTtcbiAgICB9XG4gIH0sXG4gIHBvbHlnb246IHtcbiAgICBwb2ludDogZnVuY3Rpb24gKGl0ZW1MYXlvdXQsIHNlbGVjdG9ycywgYXJlYSkge1xuICAgICAgcmV0dXJuIGl0ZW1MYXlvdXQgJiYgYXJlYS5ib3VuZGluZ1JlY3QuY29udGFpbihpdGVtTGF5b3V0WzBdLCBpdGVtTGF5b3V0WzFdKSAmJiBwb2x5Z29uQ29udGFpbi5jb250YWluKGFyZWEucmFuZ2UsIGl0ZW1MYXlvdXRbMF0sIGl0ZW1MYXlvdXRbMV0pO1xuICAgIH0sXG4gICAgcmVjdDogZnVuY3Rpb24gKGl0ZW1MYXlvdXQsIHNlbGVjdG9ycywgYXJlYSkge1xuICAgICAgdmFyIHBvaW50cyA9IGFyZWEucmFuZ2U7XG4gICAgICBpZiAoIWl0ZW1MYXlvdXQgfHwgcG9pbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB4ID0gaXRlbUxheW91dC54O1xuICAgICAgdmFyIHkgPSBpdGVtTGF5b3V0Lnk7XG4gICAgICB2YXIgd2lkdGggPSBpdGVtTGF5b3V0LndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGl0ZW1MYXlvdXQuaGVpZ2h0O1xuICAgICAgdmFyIHAgPSBwb2ludHNbMF07XG4gICAgICBpZiAocG9seWdvbkNvbnRhaW4uY29udGFpbihwb2ludHMsIHgsIHkpIHx8IHBvbHlnb25Db250YWluLmNvbnRhaW4ocG9pbnRzLCB4ICsgd2lkdGgsIHkpIHx8IHBvbHlnb25Db250YWluLmNvbnRhaW4ocG9pbnRzLCB4LCB5ICsgaGVpZ2h0KSB8fCBwb2x5Z29uQ29udGFpbi5jb250YWluKHBvaW50cywgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KSB8fCBCb3VuZGluZ1JlY3QuY3JlYXRlKGl0ZW1MYXlvdXQpLmNvbnRhaW4ocFswXSwgcFsxXSkgfHwgbGluZVBvbHlnb25JbnRlcnNlY3QoeCwgeSwgeCArIHdpZHRoLCB5LCBwb2ludHMpIHx8IGxpbmVQb2x5Z29uSW50ZXJzZWN0KHgsIHksIHgsIHkgKyBoZWlnaHQsIHBvaW50cykgfHwgbGluZVBvbHlnb25JbnRlcnNlY3QoeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHBvaW50cykgfHwgbGluZVBvbHlnb25JbnRlcnNlY3QoeCwgeSArIGhlaWdodCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCBwb2ludHMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGdldExpbmVTZWxlY3RvcnMoeHlJbmRleCkge1xuICB2YXIgeHkgPSBbJ3gnLCAneSddO1xuICB2YXIgd2ggPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuICByZXR1cm4ge1xuICAgIHBvaW50OiBmdW5jdGlvbiAoaXRlbUxheW91dCwgc2VsZWN0b3JzLCBhcmVhKSB7XG4gICAgICBpZiAoaXRlbUxheW91dCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBhcmVhLnJhbmdlO1xuICAgICAgICB2YXIgcCA9IGl0ZW1MYXlvdXRbeHlJbmRleF07XG4gICAgICAgIHJldHVybiBpbkxpbmVSYW5nZShwLCByYW5nZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZWN0OiBmdW5jdGlvbiAoaXRlbUxheW91dCwgc2VsZWN0b3JzLCBhcmVhKSB7XG4gICAgICBpZiAoaXRlbUxheW91dCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBhcmVhLnJhbmdlO1xuICAgICAgICB2YXIgbGF5b3V0UmFuZ2UgPSBbaXRlbUxheW91dFt4eVt4eUluZGV4XV0sIGl0ZW1MYXlvdXRbeHlbeHlJbmRleF1dICsgaXRlbUxheW91dFt3aFt4eUluZGV4XV1dO1xuICAgICAgICBsYXlvdXRSYW5nZVsxXSA8IGxheW91dFJhbmdlWzBdICYmIGxheW91dFJhbmdlLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIGluTGluZVJhbmdlKGxheW91dFJhbmdlWzBdLCByYW5nZSkgfHwgaW5MaW5lUmFuZ2UobGF5b3V0UmFuZ2VbMV0sIHJhbmdlKSB8fCBpbkxpbmVSYW5nZShyYW5nZVswXSwgbGF5b3V0UmFuZ2UpIHx8IGluTGluZVJhbmdlKHJhbmdlWzFdLCBsYXlvdXRSYW5nZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaW5MaW5lUmFuZ2UocCwgcmFuZ2UpIHtcbiAgcmV0dXJuIHJhbmdlWzBdIDw9IHAgJiYgcCA8PSByYW5nZVsxXTtcbn1cbmV4cG9ydCBkZWZhdWx0IHNlbGVjdG9yOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgQm91bmRpbmdSZWN0IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJztcbmltcG9ydCAqIGFzIHZpc3VhbFNvbHV0aW9uIGZyb20gJy4uLy4uL3Zpc3VhbC92aXN1YWxTb2x1dGlvbi5qcyc7XG5pbXBvcnQgeyBtYWtlQnJ1c2hDb21tb25TZWxlY3RvckZvclNlcmllcyB9IGZyb20gJy4vc2VsZWN0b3IuanMnO1xuaW1wb3J0ICogYXMgdGhyb3R0bGVVdGlsIGZyb20gJy4uLy4uL3V0aWwvdGhyb3R0bGUuanMnO1xuaW1wb3J0IEJydXNoVGFyZ2V0TWFuYWdlciBmcm9tICcuLi9oZWxwZXIvQnJ1c2hUYXJnZXRNYW5hZ2VyLmpzJztcbnZhciBTVEFURV9MSVNUID0gWydpbkJydXNoJywgJ291dE9mQnJ1c2gnXTtcbnZhciBESVNQQVRDSF9NRVRIT0QgPSAnX19lY0JydXNoU2VsZWN0JztcbnZhciBESVNQQVRDSF9GTEFHID0gJ19fZWNJbkJydXNoU2VsZWN0RXZlbnQnO1xuO1xuZXhwb3J0IGZ1bmN0aW9uIGxheW91dENvdmVycyhlY01vZGVsKSB7XG4gIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgbWFpblR5cGU6ICdicnVzaCdcbiAgfSwgZnVuY3Rpb24gKGJydXNoTW9kZWwpIHtcbiAgICB2YXIgYnJ1c2hUYXJnZXRNYW5hZ2VyID0gYnJ1c2hNb2RlbC5icnVzaFRhcmdldE1hbmFnZXIgPSBuZXcgQnJ1c2hUYXJnZXRNYW5hZ2VyKGJydXNoTW9kZWwub3B0aW9uLCBlY01vZGVsKTtcbiAgICBicnVzaFRhcmdldE1hbmFnZXIuc2V0SW5wdXRSYW5nZXMoYnJ1c2hNb2RlbC5hcmVhcywgZWNNb2RlbCk7XG4gIH0pO1xufVxuLyoqXHJcbiAqIFJlZ2lzdGVyIHRoZSB2aXN1YWwgZW5jb2RpbmcgaWYgdGhpcyBtb2R1bGVzIHJlcXVpcmVkLlxyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJydXNoVmlzdWFsKGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICB2YXIgYnJ1c2hTZWxlY3RlZCA9IFtdO1xuICB2YXIgdGhyb3R0bGVUeXBlO1xuICB2YXIgdGhyb3R0bGVEZWxheTtcbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICBtYWluVHlwZTogJ2JydXNoJ1xuICB9LCBmdW5jdGlvbiAoYnJ1c2hNb2RlbCkge1xuICAgIHBheWxvYWQgJiYgcGF5bG9hZC50eXBlID09PSAndGFrZUdsb2JhbEN1cnNvcicgJiYgYnJ1c2hNb2RlbC5zZXRCcnVzaE9wdGlvbihwYXlsb2FkLmtleSA9PT0gJ2JydXNoJyA/IHBheWxvYWQuYnJ1c2hPcHRpb24gOiB7XG4gICAgICBicnVzaFR5cGU6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xuICBsYXlvdXRDb3ZlcnMoZWNNb2RlbCk7XG4gIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgbWFpblR5cGU6ICdicnVzaCdcbiAgfSwgZnVuY3Rpb24gKGJydXNoTW9kZWwsIGJydXNoSW5kZXgpIHtcbiAgICB2YXIgdGhpc0JydXNoU2VsZWN0ZWQgPSB7XG4gICAgICBicnVzaElkOiBicnVzaE1vZGVsLmlkLFxuICAgICAgYnJ1c2hJbmRleDogYnJ1c2hJbmRleCxcbiAgICAgIGJydXNoTmFtZTogYnJ1c2hNb2RlbC5uYW1lLFxuICAgICAgYXJlYXM6IHpyVXRpbC5jbG9uZShicnVzaE1vZGVsLmFyZWFzKSxcbiAgICAgIHNlbGVjdGVkOiBbXVxuICAgIH07XG4gICAgLy8gRXZlcnkgYnJ1c2ggY29tcG9uZW50IGV4aXN0cyBpbiBldmVudCBwYXJhbXMsIGNvbnZlbmllbnRcbiAgICAvLyBmb3IgdXNlciB0byBmaW5kIGJ5IGluZGV4LlxuICAgIGJydXNoU2VsZWN0ZWQucHVzaCh0aGlzQnJ1c2hTZWxlY3RlZCk7XG4gICAgdmFyIGJydXNoT3B0aW9uID0gYnJ1c2hNb2RlbC5vcHRpb247XG4gICAgdmFyIGJydXNoTGluayA9IGJydXNoT3B0aW9uLmJydXNoTGluaztcbiAgICB2YXIgbGlua2VkU2VyaWVzTWFwID0gW107XG4gICAgdmFyIHNlbGVjdGVkRGF0YUluZGV4Rm9yTGluayA9IFtdO1xuICAgIHZhciByYW5nZUluZm9CeVNlcmllcyA9IFtdO1xuICAgIHZhciBoYXNCcnVzaEV4aXN0cyA9IGZhbHNlO1xuICAgIGlmICghYnJ1c2hJbmRleCkge1xuICAgICAgLy8gT25seSB0aGUgZmlyc3QgdGhyb3R0bGUgc2V0dGluZyB3b3Jrcy5cbiAgICAgIHRocm90dGxlVHlwZSA9IGJydXNoT3B0aW9uLnRocm90dGxlVHlwZTtcbiAgICAgIHRocm90dGxlRGVsYXkgPSBicnVzaE9wdGlvbi50aHJvdHRsZURlbGF5O1xuICAgIH1cbiAgICAvLyBBZGQgYm91bmRpbmdSZWN0IGFuZCBzZWxlY3RvcnMgdG8gcmFuZ2UuXG4gICAgdmFyIGFyZWFzID0genJVdGlsLm1hcChicnVzaE1vZGVsLmFyZWFzLCBmdW5jdGlvbiAoYXJlYSkge1xuICAgICAgdmFyIGJ1aWxkZXIgPSBib3VuZGluZ1JlY3RCdWlsZGVyc1thcmVhLmJydXNoVHlwZV07XG4gICAgICB2YXIgc2VsZWN0YWJsZUFyZWEgPSB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICBib3VuZGluZ1JlY3Q6IGJ1aWxkZXIgPyBidWlsZGVyKGFyZWEpIDogdm9pZCAwXG4gICAgICB9LCBhcmVhKTtcbiAgICAgIHNlbGVjdGFibGVBcmVhLnNlbGVjdG9ycyA9IG1ha2VCcnVzaENvbW1vblNlbGVjdG9yRm9yU2VyaWVzKHNlbGVjdGFibGVBcmVhKTtcbiAgICAgIHJldHVybiBzZWxlY3RhYmxlQXJlYTtcbiAgICB9KTtcbiAgICB2YXIgdmlzdWFsTWFwcGluZ3MgPSB2aXN1YWxTb2x1dGlvbi5jcmVhdGVWaXN1YWxNYXBwaW5ncyhicnVzaE1vZGVsLm9wdGlvbiwgU1RBVEVfTElTVCwgZnVuY3Rpb24gKG1hcHBpbmdPcHRpb24pIHtcbiAgICAgIG1hcHBpbmdPcHRpb24ubWFwcGluZ01ldGhvZCA9ICdmaXhlZCc7XG4gICAgfSk7XG4gICAgenJVdGlsLmlzQXJyYXkoYnJ1c2hMaW5rKSAmJiB6clV0aWwuZWFjaChicnVzaExpbmssIGZ1bmN0aW9uIChzZXJpZXNJbmRleCkge1xuICAgICAgbGlua2VkU2VyaWVzTWFwW3Nlcmllc0luZGV4XSA9IDE7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gbGlua090aGVycyhzZXJpZXNJbmRleCkge1xuICAgICAgcmV0dXJuIGJydXNoTGluayA9PT0gJ2FsbCcgfHwgISFsaW5rZWRTZXJpZXNNYXBbc2VyaWVzSW5kZXhdO1xuICAgIH1cbiAgICAvLyBJZiBubyBzdXBwb3J0ZWQgYnJ1c2ggb3Igbm8gYnJ1c2ggb24gdGhlIHNlcmllcyxcbiAgICAvLyBhbGwgdmlzdWFscyBzaG91bGQgYmUgaW4gb3JpZ2luYWwgc3RhdGUuXG4gICAgZnVuY3Rpb24gYnJ1c2hlZChyYW5nZUluZm9MaXN0KSB7XG4gICAgICByZXR1cm4gISFyYW5nZUluZm9MaXN0Lmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBMb2dpYyBmb3IgZWFjaCBzZXJpZXM6IChJZiB0aGUgbG9naWMgaGFzIHRvIGJlIG1vZGlmaWVkIG9uZSBkYXksIGRvIGl0IGNhcmVmdWxseSEpXHJcbiAgICAgKlxyXG4gICAgICogKCBicnVzaGVkIOKUrCAmJiDilKxoYXNCcnVzaEV4aXN0IOKUrCAmJiBsaW5rT3RoZXJzICApID0+IFN0ZXBBOiDilKxyZWNvcmQsIOKUrCBTdGVwQjog4pSsdmlzdWFsQnlSZWNvcmQuXHJcbiAgICAgKiAgICFicnVzaGVk4pSYICAgIOKUnGhhc0JydXNoRXhpc3Qg4pSkICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUlG5vdGhpbmcs4pSYICAgICAgICDilJx2aXN1YWxCeVJlY29yZC5cclxuICAgICAqICAgICAgICAgICAgICAgIOKUlCFoYXNCcnVzaEV4aXN04pSYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUlG5vdGhpbmcuXHJcbiAgICAgKiAoICFicnVzaGVkICAmJiDilKxoYXNCcnVzaEV4aXN0IOKUrCAmJiBsaW5rT3RoZXJzICApID0+IFN0ZXBBOiAgbm90aGluZywgIFN0ZXBCOiDilKx2aXN1YWxCeVJlY29yZC5cclxuICAgICAqICAgICAgICAgICAgICAgIOKUlCFoYXNCcnVzaEV4aXN04pSYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUlG5vdGhpbmcuXHJcbiAgICAgKiAoIGJydXNoZWQg4pSsICYmICAgICAgICAgICAgICAgICAgICAgIWxpbmtPdGhlcnMgKSA9PiBTdGVwQTogIG5vdGhpbmcsICBTdGVwQjog4pSsdmlzdWFsQnlDaGVjay5cclxuICAgICAqICAgIWJydXNoZWTilJggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilJRub3RoaW5nLlxyXG4gICAgICogKCAhYnJ1c2hlZCAgJiYgICAgICAgICAgICAgICAgICAgICAhbGlua090aGVycyApID0+IFN0ZXBBOiAgbm90aGluZywgIFN0ZXBCOiAgbm90aGluZy5cclxuICAgICAqL1xuICAgIC8vIFN0ZXAgQVxuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIHNlcmllc0luZGV4KSB7XG4gICAgICB2YXIgcmFuZ2VJbmZvTGlzdCA9IHJhbmdlSW5mb0J5U2VyaWVzW3Nlcmllc0luZGV4XSA9IFtdO1xuICAgICAgc2VyaWVzTW9kZWwuc3ViVHlwZSA9PT0gJ3BhcmFsbGVsJyA/IHN0ZXBBUGFyYWxsZWwoc2VyaWVzTW9kZWwsIHNlcmllc0luZGV4KSA6IHN0ZXBBT3RoZXJzKHNlcmllc01vZGVsLCBzZXJpZXNJbmRleCwgcmFuZ2VJbmZvTGlzdCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gc3RlcEFQYXJhbGxlbChzZXJpZXNNb2RlbCwgc2VyaWVzSW5kZXgpIHtcbiAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICBoYXNCcnVzaEV4aXN0cyA9IGhhc0JydXNoRXhpc3RzIHx8IGNvb3JkU3lzLmhhc0F4aXNCcnVzaGVkKCk7XG4gICAgICBsaW5rT3RoZXJzKHNlcmllc0luZGV4KSAmJiBjb29yZFN5cy5lYWNoQWN0aXZlU3RhdGUoc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLCBmdW5jdGlvbiAoYWN0aXZlU3RhdGUsIGRhdGFJbmRleCkge1xuICAgICAgICBhY3RpdmVTdGF0ZSA9PT0gJ2FjdGl2ZScgJiYgKHNlbGVjdGVkRGF0YUluZGV4Rm9yTGlua1tkYXRhSW5kZXhdID0gMSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcEFPdGhlcnMoc2VyaWVzTW9kZWwsIHNlcmllc0luZGV4LCByYW5nZUluZm9MaXN0KSB7XG4gICAgICBpZiAoIXNlcmllc01vZGVsLmJydXNoU2VsZWN0b3IgfHwgYnJ1c2hNb2RlbE5vdENvbnRyb2xsKGJydXNoTW9kZWwsIHNlcmllc0luZGV4KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB6clV0aWwuZWFjaChhcmVhcywgZnVuY3Rpb24gKGFyZWEpIHtcbiAgICAgICAgaWYgKGJydXNoTW9kZWwuYnJ1c2hUYXJnZXRNYW5hZ2VyLmNvbnRyb2xTZXJpZXMoYXJlYSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwpKSB7XG4gICAgICAgICAgcmFuZ2VJbmZvTGlzdC5wdXNoKGFyZWEpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0JydXNoRXhpc3RzID0gaGFzQnJ1c2hFeGlzdHMgfHwgYnJ1c2hlZChyYW5nZUluZm9MaXN0KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGxpbmtPdGhlcnMoc2VyaWVzSW5kZXgpICYmIGJydXNoZWQocmFuZ2VJbmZvTGlzdCkpIHtcbiAgICAgICAgdmFyIGRhdGFfMSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgZGF0YV8xLmVhY2goZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICAgIGlmIChjaGVja0luUmFuZ2Uoc2VyaWVzTW9kZWwsIHJhbmdlSW5mb0xpc3QsIGRhdGFfMSwgZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgc2VsZWN0ZWREYXRhSW5kZXhGb3JMaW5rW2RhdGFJbmRleF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFN0ZXAgQlxuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIHNlcmllc0luZGV4KSB7XG4gICAgICB2YXIgc2VyaWVzQnJ1c2hTZWxlY3RlZCA9IHtcbiAgICAgICAgc2VyaWVzSWQ6IHNlcmllc01vZGVsLmlkLFxuICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICAgIHNlcmllc05hbWU6IHNlcmllc01vZGVsLm5hbWUsXG4gICAgICAgIGRhdGFJbmRleDogW11cbiAgICAgIH07XG4gICAgICAvLyBFdmVyeSBzZXJpZXMgZXhpc3RzIGluIGV2ZW50IHBhcmFtcywgY29udmVuaWVudFxuICAgICAgLy8gZm9yIHVzZXIgdG8gZmluZCBzZXJpZXMgYnkgc2VyaWVzSW5kZXguXG4gICAgICB0aGlzQnJ1c2hTZWxlY3RlZC5zZWxlY3RlZC5wdXNoKHNlcmllc0JydXNoU2VsZWN0ZWQpO1xuICAgICAgdmFyIHJhbmdlSW5mb0xpc3QgPSByYW5nZUluZm9CeVNlcmllc1tzZXJpZXNJbmRleF07XG4gICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgIHZhciBnZXRWYWx1ZVN0YXRlID0gbGlua090aGVycyhzZXJpZXNJbmRleCkgPyBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZERhdGFJbmRleEZvckxpbmtbZGF0YUluZGV4XSA/IChzZXJpZXNCcnVzaFNlbGVjdGVkLmRhdGFJbmRleC5wdXNoKGRhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KSksICdpbkJydXNoJykgOiAnb3V0T2ZCcnVzaCc7XG4gICAgICB9IDogZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICByZXR1cm4gY2hlY2tJblJhbmdlKHNlcmllc01vZGVsLCByYW5nZUluZm9MaXN0LCBkYXRhLCBkYXRhSW5kZXgpID8gKHNlcmllc0JydXNoU2VsZWN0ZWQuZGF0YUluZGV4LnB1c2goZGF0YS5nZXRSYXdJbmRleChkYXRhSW5kZXgpKSwgJ2luQnJ1c2gnKSA6ICdvdXRPZkJydXNoJztcbiAgICAgIH07XG4gICAgICAvLyBJZiBubyBzdXBwb3J0ZWQgYnJ1c2ggb3Igbm8gYnJ1c2gsIGFsbCB2aXN1YWxzIGFyZSBpbiBvcmlnaW5hbCBzdGF0ZS5cbiAgICAgIChsaW5rT3RoZXJzKHNlcmllc0luZGV4KSA/IGhhc0JydXNoRXhpc3RzIDogYnJ1c2hlZChyYW5nZUluZm9MaXN0KSkgJiYgdmlzdWFsU29sdXRpb24uYXBwbHlWaXN1YWwoU1RBVEVfTElTVCwgdmlzdWFsTWFwcGluZ3MsIGRhdGEsIGdldFZhbHVlU3RhdGUpO1xuICAgIH0pO1xuICB9KTtcbiAgZGlzcGF0Y2hBY3Rpb24oYXBpLCB0aHJvdHRsZVR5cGUsIHRocm90dGxlRGVsYXksIGJydXNoU2VsZWN0ZWQsIHBheWxvYWQpO1xufVxuO1xuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oYXBpLCB0aHJvdHRsZVR5cGUsIHRocm90dGxlRGVsYXksIGJydXNoU2VsZWN0ZWQsIHBheWxvYWQpIHtcbiAgLy8gVGhpcyBldmVudCB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQgd2hlbiBgc2V0T3Bpb25gLCBvdGhlcndpc2UgZGVhZCBsb2NrIG1heVxuICAvLyB0cmlnZ2VyZWQgd2hlbiBkbyBgc2V0T3B0aW9uYCBpbiBldmVudCBsaXN0ZW5lciwgd2hpY2ggd2UgZG8gbm90IGZpbmRcbiAgLy8gc2F0aXNmYWN0b3J5IHdheSB0byBzb2x2ZSB5ZXQuIFNvbWUgY29uc2lkZXJlZCByZXNvbHV0aW9uczpcbiAgLy8gKGEpIERpZmYgd2l0aCBwcmV2b2l1cyBzZWxlY3RlZCBkYXRhIGFudCBvbmx5IHRyaWdnZXIgZXZlbnQgd2hlbiBjaGFuZ2VkLlxuICAvLyBCdXQgc3RvcmUgcHJldmlvdXMgZGF0YSBhbmQgZGlmZiBwcmVjaXNlbHkgKGkuZS4sIG5vdCBvbmx5IGJ5IGRhdGFJbmRleCwgYnV0XG4gIC8vIGFsc28gZGV0ZWN0IHZhbHVlIGNoYW5nZXMgaW4gc2VsZWN0ZWQgZGF0YSkgbWlnaHQgYnJpbmcgY29tcGxleGl0eSBvciBmcmFnaWxpdHkuXG4gIC8vIChiKSBVc2Ugc3BlY3RpYWwgcGFyYW0gbGlrZSBgc2lsZW50YCB0byBzdXBwcmVzcyBldmVudCB0cmlnZ2VyaW5nLlxuICAvLyBCdXQgc3VjaCBraW5kIG9mIHZvbGF0aWxlIHBhcmFtIG1heSBiZSB3ZWlyZCBpbiBgc2V0T3B0aW9uYC5cbiAgaWYgKCFwYXlsb2FkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICBpZiAoenJbRElTUEFUQ0hfRkxBR10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF6cltESVNQQVRDSF9NRVRIT0RdKSB7XG4gICAgenJbRElTUEFUQ0hfTUVUSE9EXSA9IGRvRGlzcGF0Y2g7XG4gIH1cbiAgdmFyIGZuID0gdGhyb3R0bGVVdGlsLmNyZWF0ZU9yVXBkYXRlKHpyLCBESVNQQVRDSF9NRVRIT0QsIHRocm90dGxlRGVsYXksIHRocm90dGxlVHlwZSk7XG4gIGZuKGFwaSwgYnJ1c2hTZWxlY3RlZCk7XG59XG5mdW5jdGlvbiBkb0Rpc3BhdGNoKGFwaSwgYnJ1c2hTZWxlY3RlZCkge1xuICBpZiAoIWFwaS5pc0Rpc3Bvc2VkKCkpIHtcbiAgICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgICB6cltESVNQQVRDSF9GTEFHXSA9IHRydWU7XG4gICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdicnVzaFNlbGVjdCcsXG4gICAgICBiYXRjaDogYnJ1c2hTZWxlY3RlZFxuICAgIH0pO1xuICAgIHpyW0RJU1BBVENIX0ZMQUddID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSW5SYW5nZShzZXJpZXNNb2RlbCwgcmFuZ2VJbmZvTGlzdCwgZGF0YSwgZGF0YUluZGV4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByYW5nZUluZm9MaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGFyZWEgPSByYW5nZUluZm9MaXN0W2ldO1xuICAgIGlmIChzZXJpZXNNb2RlbC5icnVzaFNlbGVjdG9yKGRhdGFJbmRleCwgZGF0YSwgYXJlYS5zZWxlY3RvcnMsIGFyZWEpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGJydXNoTW9kZWxOb3RDb250cm9sbChicnVzaE1vZGVsLCBzZXJpZXNJbmRleCkge1xuICB2YXIgc2VyaWVzSW5kaWNlcyA9IGJydXNoTW9kZWwub3B0aW9uLnNlcmllc0luZGV4O1xuICByZXR1cm4gc2VyaWVzSW5kaWNlcyAhPSBudWxsICYmIHNlcmllc0luZGljZXMgIT09ICdhbGwnICYmICh6clV0aWwuaXNBcnJheShzZXJpZXNJbmRpY2VzKSA/IHpyVXRpbC5pbmRleE9mKHNlcmllc0luZGljZXMsIHNlcmllc0luZGV4KSA8IDAgOiBzZXJpZXNJbmRleCAhPT0gc2VyaWVzSW5kaWNlcyk7XG59XG52YXIgYm91bmRpbmdSZWN0QnVpbGRlcnMgPSB7XG4gIHJlY3Q6IGZ1bmN0aW9uIChhcmVhKSB7XG4gICAgcmV0dXJuIGdldEJvdW5kaW5nUmVjdEZyb21NaW5NYXgoYXJlYS5yYW5nZSk7XG4gIH0sXG4gIHBvbHlnb246IGZ1bmN0aW9uIChhcmVhKSB7XG4gICAgdmFyIG1pbk1heDtcbiAgICB2YXIgcmFuZ2UgPSBhcmVhLnJhbmdlO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByYW5nZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWluTWF4ID0gbWluTWF4IHx8IFtbSW5maW5pdHksIC1JbmZpbml0eV0sIFtJbmZpbml0eSwgLUluZmluaXR5XV07XG4gICAgICB2YXIgcmcgPSByYW5nZVtpXTtcbiAgICAgIHJnWzBdIDwgbWluTWF4WzBdWzBdICYmIChtaW5NYXhbMF1bMF0gPSByZ1swXSk7XG4gICAgICByZ1swXSA+IG1pbk1heFswXVsxXSAmJiAobWluTWF4WzBdWzFdID0gcmdbMF0pO1xuICAgICAgcmdbMV0gPCBtaW5NYXhbMV1bMF0gJiYgKG1pbk1heFsxXVswXSA9IHJnWzFdKTtcbiAgICAgIHJnWzFdID4gbWluTWF4WzFdWzFdICYmIChtaW5NYXhbMV1bMV0gPSByZ1sxXSk7XG4gICAgfVxuICAgIHJldHVybiBtaW5NYXggJiYgZ2V0Qm91bmRpbmdSZWN0RnJvbU1pbk1heChtaW5NYXgpO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0RnJvbU1pbk1heChtaW5NYXgpIHtcbiAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QobWluTWF4WzBdWzBdLCBtaW5NYXhbMV1bMF0sIG1pbk1heFswXVsxXSAtIG1pbk1heFswXVswXSwgbWluTWF4WzFdWzFdIC0gbWluTWF4WzFdWzBdKTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgQnJ1c2hDb250cm9sbGVyIGZyb20gJy4uL2hlbHBlci9CcnVzaENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHsgbGF5b3V0Q292ZXJzIH0gZnJvbSAnLi92aXN1YWxFbmNvZGluZy5qcyc7XG5pbXBvcnQgQ29tcG9uZW50VmlldyBmcm9tICcuLi8uLi92aWV3L0NvbXBvbmVudC5qcyc7XG52YXIgQnJ1c2hWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEJydXNoVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gQnJ1c2hWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBCcnVzaFZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgQnJ1c2hWaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuZWNNb2RlbCA9IGVjTW9kZWw7XG4gICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgdGhpcy5tb2RlbDtcbiAgICAodGhpcy5fYnJ1c2hDb250cm9sbGVyID0gbmV3IEJydXNoQ29udHJvbGxlcihhcGkuZ2V0WnIoKSkpLm9uKCdicnVzaCcsIHpyVXRpbC5iaW5kKHRoaXMuX29uQnJ1c2gsIHRoaXMpKS5tb3VudCgpO1xuICB9O1xuICBCcnVzaFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChicnVzaE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB0aGlzLm1vZGVsID0gYnJ1c2hNb2RlbDtcbiAgICB0aGlzLl91cGRhdGVDb250cm9sbGVyKGJydXNoTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gIH07XG4gIEJydXNoVmlldy5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGJydXNoTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIC8vIFBFTkRJTkc6IGB1cGRhdGVUcmFuc2Zvcm1gIGlzIGEgbGl0dGxlIHRyaWNreSwgd2hvc2UgbGF5b3V0IG5lZWRcbiAgICAvLyB0byBiZSBjYWxjdWxhdGUgbWFuZGF0b3JpbHkgYW5kIG90aGVyIHN0YWdlcyB3aWxsIG5vdCBiZSBwZXJmb3JtZWQuXG4gICAgLy8gVGFrZSBjYXJlIHRoZSBjb3JyZWN0bmVzcyBvZiB0aGUgbG9naWMuIFNlZSAjMTE3NTQgLlxuICAgIGxheW91dENvdmVycyhlY01vZGVsKTtcbiAgICB0aGlzLl91cGRhdGVDb250cm9sbGVyKGJydXNoTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gIH07XG4gIEJydXNoVmlldy5wcm90b3R5cGUudXBkYXRlVmlzdWFsID0gZnVuY3Rpb24gKGJydXNoTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKGJydXNoTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gIH07XG4gIEJydXNoVmlldy5wcm90b3R5cGUudXBkYXRlVmlldyA9IGZ1bmN0aW9uIChicnVzaE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB0aGlzLl91cGRhdGVDb250cm9sbGVyKGJydXNoTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gIH07XG4gIEJydXNoVmlldy5wcm90b3R5cGUuX3VwZGF0ZUNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoYnJ1c2hNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgLy8gRG8gbm90IHVwZGF0ZSBjb250cm9sbGVyIHdoZW4gZHJhd2luZy5cbiAgICAoIXBheWxvYWQgfHwgcGF5bG9hZC4kZnJvbSAhPT0gYnJ1c2hNb2RlbC5pZCkgJiYgdGhpcy5fYnJ1c2hDb250cm9sbGVyLnNldFBhbmVscyhicnVzaE1vZGVsLmJydXNoVGFyZ2V0TWFuYWdlci5tYWtlUGFuZWxPcHRzKGFwaSkpLmVuYWJsZUJydXNoKGJydXNoTW9kZWwuYnJ1c2hPcHRpb24pLnVwZGF0ZUNvdmVycyhicnVzaE1vZGVsLmFyZWFzLnNsaWNlKCkpO1xuICB9O1xuICAvLyB1cGRhdGVMYXlvdXQ6IHVwZGF0ZUNvbnRyb2xsZXIsXG4gIC8vIHVwZGF0ZVZpc3VhbDogdXBkYXRlQ29udHJvbGxlcixcbiAgQnJ1c2hWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JydXNoQ29udHJvbGxlci5kaXNwb3NlKCk7XG4gIH07XG4gIEJydXNoVmlldy5wcm90b3R5cGUuX29uQnJ1c2ggPSBmdW5jdGlvbiAoZXZlbnRQYXJhbSkge1xuICAgIHZhciBtb2RlbElkID0gdGhpcy5tb2RlbC5pZDtcbiAgICB2YXIgYXJlYXMgPSB0aGlzLm1vZGVsLmJydXNoVGFyZ2V0TWFuYWdlci5zZXRPdXRwdXRSYW5nZXMoZXZlbnRQYXJhbS5hcmVhcywgdGhpcy5lY01vZGVsKTtcbiAgICAvLyBBY3Rpb24gaXMgbm90IGRpc3BhdGNoZWQgb24gZHJhZyBlbmQsIGJlY2F1c2UgdGhlIGRyYWcgZW5kXG4gICAgLy8gZW1pdHMgdGhlIHNhbWUgcGFyYW1zIHdpdGggdGhlIGxhc3QgZHJhZyBtb3ZlIGV2ZW50LCBhbmRcbiAgICAvLyBtYXkgaGF2ZSBzb21lIGRlbGF5IHdoZW4gdXNpbmcgdG91Y2ggcGFkLCB3aGljaCBtYWtlc1xuICAgIC8vIGFuaW1hdGlvbiBub3Qgc21vb3RoICh3aGVuIHVzaW5nIGRlYm91bmNlKS5cbiAgICAoIWV2ZW50UGFyYW0uaXNFbmQgfHwgZXZlbnRQYXJhbS5yZW1vdmVPbkNsaWNrKSAmJiB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAnYnJ1c2gnLFxuICAgICAgYnJ1c2hJZDogbW9kZWxJZCxcbiAgICAgIGFyZWFzOiB6clV0aWwuY2xvbmUoYXJlYXMpLFxuICAgICAgJGZyb206IG1vZGVsSWRcbiAgICB9KTtcbiAgICBldmVudFBhcmFtLmlzRW5kICYmIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdicnVzaEVuZCcsXG4gICAgICBicnVzaElkOiBtb2RlbElkLFxuICAgICAgYXJlYXM6IHpyVXRpbC5jbG9uZShhcmVhcyksXG4gICAgICAkZnJvbTogbW9kZWxJZFxuICAgIH0pO1xuICB9O1xuICBCcnVzaFZpZXcudHlwZSA9ICdicnVzaCc7XG4gIHJldHVybiBCcnVzaFZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuZXhwb3J0IGRlZmF1bHQgQnJ1c2hWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCAqIGFzIHZpc3VhbFNvbHV0aW9uIGZyb20gJy4uLy4uL3Zpc3VhbC92aXN1YWxTb2x1dGlvbi5qcyc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvTW9kZWwuanMnO1xuaW1wb3J0IENvbXBvbmVudE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL0NvbXBvbmVudC5qcyc7XG52YXIgREVGQVVMVF9PVVRfT0ZfQlJVU0hfQ09MT1IgPSAnI2RkZCc7XG52YXIgQnJ1c2hNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhCcnVzaE1vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBCcnVzaE1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBCcnVzaE1vZGVsLnR5cGU7XG4gICAgLyoqXHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqL1xuICAgIF90aGlzLmFyZWFzID0gW107XG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGJydXNoIHBhaW50aW5nIGFyZWEgc2V0dGluZ3MuXHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqL1xuICAgIF90aGlzLmJydXNoT3B0aW9uID0ge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEJydXNoTW9kZWwucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQgPSBmdW5jdGlvbiAobmV3T3B0aW9uLCBpc0luaXQpIHtcbiAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgICFpc0luaXQgJiYgdmlzdWFsU29sdXRpb24ucmVwbGFjZVZpc3VhbE9wdGlvbih0aGlzT3B0aW9uLCBuZXdPcHRpb24sIFsnaW5CcnVzaCcsICdvdXRPZkJydXNoJ10pO1xuICAgIHZhciBpbkJydXNoID0gdGhpc09wdGlvbi5pbkJydXNoID0gdGhpc09wdGlvbi5pbkJydXNoIHx8IHt9O1xuICAgIC8vIEFsd2F5cyBnaXZlIGRlZmF1bHQgdmlzdWFsLCBjb25zaWRlciBzZXRPcHRpb24gYXQgdGhlIHNlY29uZCB0aW1lLlxuICAgIHRoaXNPcHRpb24ub3V0T2ZCcnVzaCA9IHRoaXNPcHRpb24ub3V0T2ZCcnVzaCB8fCB7XG4gICAgICBjb2xvcjogREVGQVVMVF9PVVRfT0ZfQlJVU0hfQ09MT1JcbiAgICB9O1xuICAgIGlmICghaW5CcnVzaC5oYXNPd25Qcm9wZXJ0eSgnbGlmdFonKSkge1xuICAgICAgLy8gQmlnZ2VyIHRoYW4gdGhlIGhpZ2hsaWdodCB6IGxpZnQsIG90aGVyd2lzZSBpdCB3aWxsXG4gICAgICAvLyBiZSBlZmZlY3RlZCBieSB0aGUgaGlnaGxpZ2h0IHogd2hlbiBicnVzaC5cbiAgICAgIGluQnJ1c2gubGlmdFogPSA1O1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogSWYgYGFyZWFzYCBpcyBudWxsL3VuZGVmaW5lZCwgcmFuZ2Ugc3RhdGUgcmVtYWluLlxyXG4gICAqL1xuICBCcnVzaE1vZGVsLnByb3RvdHlwZS5zZXRBcmVhcyA9IGZ1bmN0aW9uIChhcmVhcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB6clV0aWwuYXNzZXJ0KHpyVXRpbC5pc0FycmF5KGFyZWFzKSk7XG4gICAgICB6clV0aWwuZWFjaChhcmVhcywgZnVuY3Rpb24gKGFyZWEpIHtcbiAgICAgICAgenJVdGlsLmFzc2VydChhcmVhLmJydXNoVHlwZSwgJ0lsbGVnYWwgYXJlYXMnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBJZiBhcmVhcyBpcyBudWxsL3VuZGVmaW5lZCwgcmFuZ2Ugc3RhdGUgcmVtYWluLlxuICAgIC8vIFRoaXMgaGVscHMgdXNlciB0byBkaXNwYXRjaEFjdGlvbih7dHlwZTogJ2JydXNoJ30pIHdpdGggbm8gYXJlYXNcbiAgICAvLyBzZXQgYnV0IGp1c3Qgd2FudCB0byBnZXQgdGhlIGN1cnJlbnQgYnJ1c2ggc2VsZWN0IGluZm8gZnJvbSBhIGBicnVzaGAgZXZlbnQuXG4gICAgaWYgKCFhcmVhcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFyZWFzID0genJVdGlsLm1hcChhcmVhcywgZnVuY3Rpb24gKGFyZWEpIHtcbiAgICAgIHJldHVybiBnZW5lcmF0ZUJydXNoT3B0aW9uKHRoaXMub3B0aW9uLCBhcmVhKTtcbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBjdXJyZW50IHBhaW50aW5nIGJydXNoIG9wdGlvbi5cclxuICAgKi9cbiAgQnJ1c2hNb2RlbC5wcm90b3R5cGUuc2V0QnJ1c2hPcHRpb24gPSBmdW5jdGlvbiAoYnJ1c2hPcHRpb24pIHtcbiAgICB0aGlzLmJydXNoT3B0aW9uID0gZ2VuZXJhdGVCcnVzaE9wdGlvbih0aGlzLm9wdGlvbiwgYnJ1c2hPcHRpb24pO1xuICAgIHRoaXMuYnJ1c2hUeXBlID0gdGhpcy5icnVzaE9wdGlvbi5icnVzaFR5cGU7XG4gIH07XG4gIEJydXNoTW9kZWwudHlwZSA9ICdicnVzaCc7XG4gIEJydXNoTW9kZWwuZGVwZW5kZW5jaWVzID0gWydnZW8nLCAnZ3JpZCcsICd4QXhpcycsICd5QXhpcycsICdwYXJhbGxlbCcsICdzZXJpZXMnXTtcbiAgQnJ1c2hNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIHNlcmllc0luZGV4OiAnYWxsJyxcbiAgICBicnVzaFR5cGU6ICdyZWN0JyxcbiAgICBicnVzaE1vZGU6ICdzaW5nbGUnLFxuICAgIHRyYW5zZm9ybWFibGU6IHRydWUsXG4gICAgYnJ1c2hTdHlsZToge1xuICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICBjb2xvcjogJ3JnYmEoMjEwLDIxOSwyMzgsMC4zKScsXG4gICAgICBib3JkZXJDb2xvcjogJyNEMkRCRUUnXG4gICAgfSxcbiAgICB0aHJvdHRsZVR5cGU6ICdmaXhSYXRlJyxcbiAgICB0aHJvdHRsZURlbGF5OiAwLFxuICAgIHJlbW92ZU9uQ2xpY2s6IHRydWUsXG4gICAgejogMTAwMDBcbiAgfTtcbiAgcmV0dXJuIEJydXNoTW9kZWw7XG59KENvbXBvbmVudE1vZGVsKTtcbmZ1bmN0aW9uIGdlbmVyYXRlQnJ1c2hPcHRpb24ob3B0aW9uLCBicnVzaE9wdGlvbikge1xuICByZXR1cm4genJVdGlsLm1lcmdlKHtcbiAgICBicnVzaFR5cGU6IG9wdGlvbi5icnVzaFR5cGUsXG4gICAgYnJ1c2hNb2RlOiBvcHRpb24uYnJ1c2hNb2RlLFxuICAgIHRyYW5zZm9ybWFibGU6IG9wdGlvbi50cmFuc2Zvcm1hYmxlLFxuICAgIGJydXNoU3R5bGU6IG5ldyBNb2RlbChvcHRpb24uYnJ1c2hTdHlsZSkuZ2V0SXRlbVN0eWxlKCksXG4gICAgcmVtb3ZlT25DbGljazogb3B0aW9uLnJlbW92ZU9uQ2xpY2ssXG4gICAgejogb3B0aW9uLnpcbiAgfSwgYnJ1c2hPcHRpb24sIHRydWUpO1xufVxuZXhwb3J0IGRlZmF1bHQgQnJ1c2hNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBicnVzaFByZXByb2Nlc3NvciBmcm9tICcuL3ByZXByb2Nlc3Nvci5qcyc7XG5pbXBvcnQgQnJ1c2hWaWV3IGZyb20gJy4vQnJ1c2hWaWV3LmpzJztcbmltcG9ydCBCcnVzaE1vZGVsIGZyb20gJy4vQnJ1c2hNb2RlbC5qcyc7XG5pbXBvcnQgYnJ1c2hWaXN1YWwgZnJvbSAnLi92aXN1YWxFbmNvZGluZy5qcyc7XG4vLyBUT0RPXG5pbXBvcnQgQnJ1c2hGZWF0dXJlIGZyb20gJy4uL3Rvb2xib3gvZmVhdHVyZS9CcnVzaC5qcyc7XG5pbXBvcnQgeyByZWdpc3RlckZlYXR1cmUgfSBmcm9tICcuLi90b29sYm94L2ZlYXR1cmVNYW5hZ2VyLmpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoQnJ1c2hWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50TW9kZWwoQnJ1c2hNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByZXByb2Nlc3NvcihicnVzaFByZXByb2Nlc3Nvcik7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclZpc3VhbChyZWdpc3RlcnMuUFJJT1JJVFkuVklTVUFMLkJSVVNILCBicnVzaFZpc3VhbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogJ2JydXNoJyxcbiAgICBldmVudDogJ2JydXNoJyxcbiAgICB1cGRhdGU6ICd1cGRhdGVWaXN1YWwnXG4gIH0sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiAnYnJ1c2gnLFxuICAgICAgcXVlcnk6IHBheWxvYWRcbiAgICB9LCBmdW5jdGlvbiAoYnJ1c2hNb2RlbCkge1xuICAgICAgYnJ1c2hNb2RlbC5zZXRBcmVhcyhwYXlsb2FkLmFyZWFzKTtcbiAgICB9KTtcbiAgfSk7XG4gIC8qKlxyXG4gICAqIHBheWxvYWQ6IHtcclxuICAgKiAgICAgIGJydXNoQ29tcG9uZW50czogW1xyXG4gICAqICAgICAgICAgIHtcclxuICAgKiAgICAgICAgICAgICAgYnJ1c2hJZCxcclxuICAgKiAgICAgICAgICAgICAgYnJ1c2hJbmRleCxcclxuICAgKiAgICAgICAgICAgICAgYnJ1c2hOYW1lLFxyXG4gICAqICAgICAgICAgICAgICBzZXJpZXM6IFtcclxuICAgKiAgICAgICAgICAgICAgICAgIHtcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJZCxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleCxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNOYW1lLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgIHJhd0luZGljZXM6IFsyMSwgMzQsIC4uLl1cclxuICAgKiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICogICAgICAgICAgICAgICAgICAuLi5cclxuICAgKiAgICAgICAgICAgICAgXVxyXG4gICAqICAgICAgICAgIH0sXHJcbiAgICogICAgICAgICAgLi4uXHJcbiAgICogICAgICBdXHJcbiAgICogfVxyXG4gICAqL1xuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgIHR5cGU6ICdicnVzaFNlbGVjdCcsXG4gICAgZXZlbnQ6ICdicnVzaFNlbGVjdGVkJyxcbiAgICB1cGRhdGU6ICdub25lJ1xuICB9LCBub29wKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICB0eXBlOiAnYnJ1c2hFbmQnLFxuICAgIGV2ZW50OiAnYnJ1c2hFbmQnLFxuICAgIHVwZGF0ZTogJ25vbmUnXG4gIH0sIG5vb3ApO1xuICByZWdpc3RlckZlYXR1cmUoJ2JydXNoJywgQnJ1c2hGZWF0dXJlKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///91695\n")},95376:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js\nvar DataZoomModel = __webpack_require__(72012);\n;// ./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar SelectDataZoomModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(SelectDataZoomModel, _super);\n  function SelectDataZoomModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = SelectDataZoomModel.type;\n    return _this;\n  }\n  SelectDataZoomModel.type = \'dataZoom.select\';\n  return SelectDataZoomModel;\n}(DataZoomModel/* default */.A);\n/* harmony default export */ const SelectZoomModel = (SelectDataZoomModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/DataZoomView.js\nvar DataZoomView = __webpack_require__(98248);\n;// ./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar SelectDataZoomView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(SelectDataZoomView, _super);\n  function SelectDataZoomView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = SelectDataZoomView.type;\n    return _this;\n  }\n  SelectDataZoomView.type = \'dataZoom.select\';\n  return SelectDataZoomView;\n}(DataZoomView/* default */.A);\n/* harmony default export */ const SelectZoomView = (SelectDataZoomView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/installCommon.js + 3 modules\nvar installCommon = __webpack_require__(33820);\n;// ./node_modules/echarts/lib/component/dataZoom/installDataZoomSelect.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction install(registers) {\n  registers.registerComponentModel(SelectZoomModel);\n  registers.registerComponentView(SelectZoomView);\n  (0,installCommon/* default */.A)(registers);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUzNzYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TZWxlY3Rab29tTW9kZWwuanM/OTFmNyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL1NlbGVjdFpvb21WaWV3LmpzP2M4MGIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9pbnN0YWxsRGF0YVpvb21TZWxlY3QuanM/M2M3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IERhdGFab29tTW9kZWwgZnJvbSAnLi9EYXRhWm9vbU1vZGVsLmpzJztcbnZhciBTZWxlY3REYXRhWm9vbU1vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNlbGVjdERhdGFab29tTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFNlbGVjdERhdGFab29tTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IFNlbGVjdERhdGFab29tTW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgU2VsZWN0RGF0YVpvb21Nb2RlbC50eXBlID0gJ2RhdGFab29tLnNlbGVjdCc7XG4gIHJldHVybiBTZWxlY3REYXRhWm9vbU1vZGVsO1xufShEYXRhWm9vbU1vZGVsKTtcbmV4cG9ydCBkZWZhdWx0IFNlbGVjdERhdGFab29tTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBEYXRhWm9vbVZpZXcgZnJvbSAnLi9EYXRhWm9vbVZpZXcuanMnO1xudmFyIFNlbGVjdERhdGFab29tVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTZWxlY3REYXRhWm9vbVZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFNlbGVjdERhdGFab29tVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gU2VsZWN0RGF0YVpvb21WaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFNlbGVjdERhdGFab29tVmlldy50eXBlID0gJ2RhdGFab29tLnNlbGVjdCc7XG4gIHJldHVybiBTZWxlY3REYXRhWm9vbVZpZXc7XG59KERhdGFab29tVmlldyk7XG5leHBvcnQgZGVmYXVsdCBTZWxlY3REYXRhWm9vbVZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgU2VsZWN0Wm9vbU1vZGVsIGZyb20gJy4vU2VsZWN0Wm9vbU1vZGVsLmpzJztcbmltcG9ydCBTZWxlY3Rab29tVmlldyBmcm9tICcuL1NlbGVjdFpvb21WaWV3LmpzJztcbmltcG9ydCBpbnN0YWxsQ29tbW9uIGZyb20gJy4vaW5zdGFsbENvbW1vbi5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50TW9kZWwoU2VsZWN0Wm9vbU1vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50VmlldyhTZWxlY3Rab29tVmlldyk7XG4gIGluc3RhbGxDb21tb24ocmVnaXN0ZXJzKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///95376\n')},98248:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var _view_Component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59109);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar DataZoomView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(DataZoomView, _super);\n  function DataZoomView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = DataZoomView.type;\n    return _this;\n  }\n  DataZoomView.prototype.render = function (dataZoomModel, ecModel, api, payload) {\n    this.dataZoomModel = dataZoomModel;\n    this.ecModel = ecModel;\n    this.api = api;\n  };\n  DataZoomView.type = \'dataZoom\';\n  return DataZoomView;\n}(_view_Component_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataZoomView);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgyNDguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21WaWV3LmpzPzUzMDciXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50LmpzJztcbnZhciBEYXRhWm9vbVZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRGF0YVpvb21WaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBEYXRhWm9vbVZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IERhdGFab29tVmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBEYXRhWm9vbVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB0aGlzLmRhdGFab29tTW9kZWwgPSBkYXRhWm9vbU1vZGVsO1xuICAgIHRoaXMuZWNNb2RlbCA9IGVjTW9kZWw7XG4gICAgdGhpcy5hcGkgPSBhcGk7XG4gIH07XG4gIERhdGFab29tVmlldy50eXBlID0gJ2RhdGFab29tJztcbiAgcmV0dXJuIERhdGFab29tVmlldztcbn0oQ29tcG9uZW50Vmlldyk7XG5leHBvcnQgZGVmYXVsdCBEYXRhWm9vbVZpZXc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///98248\n')}}]);