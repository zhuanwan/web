"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[3976],{9895:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/line/poly.js\nvar poly = __webpack_require__(53364);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/DataDiffer.js\nvar DataDiffer = __webpack_require__(16563);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n;// ./node_modules/echarts/lib/chart/themeRiver/ThemeRiverView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\nvar ThemeRiverView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ThemeRiverView, _super);\n  function ThemeRiverView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ThemeRiverView.type;\n    _this._layers = [];\n    return _this;\n  }\n  ThemeRiverView.prototype.render = function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    var self = this;\n    var group = this.group;\n    var layersSeries = seriesModel.getLayerSeries();\n    var layoutInfo = data.getLayout('layoutInfo');\n    var rect = layoutInfo.rect;\n    var boundaryGap = layoutInfo.boundaryGap;\n    group.x = 0;\n    group.y = rect.y + boundaryGap[0];\n    function keyGetter(item) {\n      return item.name;\n    }\n    var dataDiffer = new DataDiffer/* default */.A(this._layersSeries || [], layersSeries, keyGetter, keyGetter);\n    var newLayersGroups = [];\n    dataDiffer.add((0,util.bind)(process, this, 'add')).update((0,util.bind)(process, this, 'update')).remove((0,util.bind)(process, this, 'remove')).execute();\n    function process(status, idx, oldIdx) {\n      var oldLayersGroups = self._layers;\n      if (status === 'remove') {\n        group.remove(oldLayersGroups[idx]);\n        return;\n      }\n      var points0 = [];\n      var points1 = [];\n      var style;\n      var indices = layersSeries[idx].indices;\n      var j = 0;\n      for (; j < indices.length; j++) {\n        var layout = data.getItemLayout(indices[j]);\n        var x = layout.x;\n        var y0 = layout.y0;\n        var y = layout.y;\n        points0.push(x, y0);\n        points1.push(x, y0 + y);\n        style = data.getItemVisual(indices[j], 'style');\n      }\n      var polygon;\n      var textLayout = data.getItemLayout(indices[0]);\n      var labelModel = seriesModel.getModel('label');\n      var margin = labelModel.get('margin');\n      var emphasisModel = seriesModel.getModel('emphasis');\n      if (status === 'add') {\n        var layerGroup = newLayersGroups[idx] = new Group/* default */.A();\n        polygon = new poly/* ECPolygon */.z({\n          shape: {\n            points: points0,\n            stackedOnPoints: points1,\n            smooth: 0.4,\n            stackedOnSmooth: 0.4,\n            smoothConstraint: false\n          },\n          z2: 0\n        });\n        layerGroup.add(polygon);\n        group.add(layerGroup);\n        if (seriesModel.isAnimationEnabled()) {\n          polygon.setClipPath(createGridClipShape(polygon.getBoundingRect(), seriesModel, function () {\n            polygon.removeClipPath();\n          }));\n        }\n      } else {\n        var layerGroup = oldLayersGroups[oldIdx];\n        polygon = layerGroup.childAt(0);\n        group.add(layerGroup);\n        newLayersGroups[idx] = layerGroup;\n        basicTransition/* updateProps */.oi(polygon, {\n          shape: {\n            points: points0,\n            stackedOnPoints: points1\n          }\n        }, seriesModel);\n        (0,basicTransition/* saveOldStyle */.ap)(polygon);\n      }\n      (0,labelStyle/* setLabelStyle */.qM)(polygon, (0,labelStyle/* getLabelStatesModels */.lx)(seriesModel), {\n        labelDataIndex: indices[j - 1],\n        defaultText: data.getName(indices[j - 1]),\n        inheritColor: style.fill\n      }, {\n        normal: {\n          verticalAlign: 'middle'\n          // align: 'right'\n        }\n      });\n      polygon.setTextConfig({\n        position: null,\n        local: true\n      });\n      var labelEl = polygon.getTextContent();\n      // TODO More label position options.\n      if (labelEl) {\n        labelEl.x = textLayout.x - margin;\n        labelEl.y = textLayout.y0 + textLayout.y / 2;\n      }\n      polygon.useStyle(style);\n      data.setItemGraphicEl(idx, polygon);\n      (0,states/* setStatesStylesFromModel */.Mx)(polygon, seriesModel);\n      (0,states/* toggleHoverEmphasis */.Lm)(polygon, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n    }\n    this._layersSeries = layersSeries;\n    this._layers = newLayersGroups;\n  };\n  ThemeRiverView.type = 'themeRiver';\n  return ThemeRiverView;\n}(Chart/* default */.A);\n;\n// add animation to the view\nfunction createGridClipShape(rect, seriesModel, cb) {\n  var rectEl = new Rect/* default */.A({\n    shape: {\n      x: rect.x - 10,\n      y: rect.y - 10,\n      width: 0,\n      height: rect.height + 20\n    }\n  });\n  basicTransition/* initProps */.LW(rectEl, {\n    shape: {\n      x: rect.x - 50,\n      width: rect.width + 100,\n      height: rect.height + 20\n    }\n  }, seriesModel, cb);\n  return rectEl;\n}\n/* harmony default export */ const themeRiver_ThemeRiverView = (ThemeRiverView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/createDimensions.js\nvar createDimensions = __webpack_require__(97351);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/dimensionHelper.js\nvar dimensionHelper = __webpack_require__(29756);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/SeriesData.js\nvar SeriesData = __webpack_require__(6006);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/LegendVisualProvider.js\nvar LegendVisualProvider = __webpack_require__(58239);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js\nvar tooltipMarkup = __webpack_require__(3961);\n;// ./node_modules/echarts/lib/chart/themeRiver/ThemeRiverSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\nvar DATA_NAME_INDEX = 2;\nvar ThemeRiverSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ThemeRiverSeriesModel, _super);\n  function ThemeRiverSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ThemeRiverSeriesModel.type;\n    return _this;\n  }\n  /**\r\n   * @override\r\n   */\n  ThemeRiverSeriesModel.prototype.init = function (option) {\n    // eslint-disable-next-line\n    _super.prototype.init.apply(this, arguments);\n    // Put this function here is for the sake of consistency of code style.\n    // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n    this.legendVisualProvider = new LegendVisualProvider/* default */.A(util.bind(this.getData, this), util.bind(this.getRawData, this));\n  };\n  /**\r\n   * If there is no value of a certain point in the time for some event,set it value to 0.\r\n   *\r\n   * @param {Array} data  initial data in the option\r\n   * @return {Array}\r\n   */\n  ThemeRiverSeriesModel.prototype.fixData = function (data) {\n    var rawDataLength = data.length;\n    /**\r\n     * Make sure every layer data get the same keys.\r\n     * The value index tells which layer has visited.\r\n     * {\r\n     *  2014/01/01: -1\r\n     * }\r\n     */\n    var timeValueKeys = {};\n    // grouped data by name\n    var groupResult = (0,model/* groupData */.Sq)(data, function (item) {\n      if (!timeValueKeys.hasOwnProperty(item[0] + '')) {\n        timeValueKeys[item[0] + ''] = -1;\n      }\n      return item[2];\n    });\n    var layerData = [];\n    groupResult.buckets.each(function (items, key) {\n      layerData.push({\n        name: key,\n        dataList: items\n      });\n    });\n    var layerNum = layerData.length;\n    for (var k = 0; k < layerNum; ++k) {\n      var name_1 = layerData[k].name;\n      for (var j = 0; j < layerData[k].dataList.length; ++j) {\n        var timeValue = layerData[k].dataList[j][0] + '';\n        timeValueKeys[timeValue] = k;\n      }\n      for (var timeValue in timeValueKeys) {\n        if (timeValueKeys.hasOwnProperty(timeValue) && timeValueKeys[timeValue] !== k) {\n          timeValueKeys[timeValue] = k;\n          data[rawDataLength] = [timeValue, 0, name_1];\n          rawDataLength++;\n        }\n      }\n    }\n    return data;\n  };\n  /**\r\n   * @override\r\n   * @param  option  the initial option that user gave\r\n   * @param  ecModel  the model object for themeRiver option\r\n   */\n  ThemeRiverSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    var singleAxisModel = this.getReferringComponents('singleAxis', model/* SINGLE_REFERRING */.US).models[0];\n    var axisType = singleAxisModel.get('type');\n    // filter the data item with the value of label is undefined\n    var filterData = util.filter(option.data, function (dataItem) {\n      return dataItem[2] !== undefined;\n    });\n    // ??? TODO design a stage to transfer data for themeRiver and lines?\n    var data = this.fixData(filterData || []);\n    var nameList = [];\n    var nameMap = this.nameMap = util.createHashMap();\n    var count = 0;\n    for (var i = 0; i < data.length; ++i) {\n      nameList.push(data[i][DATA_NAME_INDEX]);\n      if (!nameMap.get(data[i][DATA_NAME_INDEX])) {\n        nameMap.set(data[i][DATA_NAME_INDEX], count);\n        count++;\n      }\n    }\n    var dimensions = (0,createDimensions/* default */.A)(data, {\n      coordDimensions: ['single'],\n      dimensionsDefine: [{\n        name: 'time',\n        type: (0,dimensionHelper/* getDimensionTypeByAxis */.B)(axisType)\n      }, {\n        name: 'value',\n        type: 'float'\n      }, {\n        name: 'name',\n        type: 'ordinal'\n      }],\n      encodeDefine: {\n        single: 0,\n        value: 1,\n        itemName: 2\n      }\n    }).dimensions;\n    var list = new SeriesData/* default */.A(dimensions, this);\n    list.initData(data);\n    return list;\n  };\n  /**\r\n   * The raw data is divided into multiple layers and each layer\r\n   *     has same name.\r\n   */\n  ThemeRiverSeriesModel.prototype.getLayerSeries = function () {\n    var data = this.getData();\n    var lenCount = data.count();\n    var indexArr = [];\n    for (var i = 0; i < lenCount; ++i) {\n      indexArr[i] = i;\n    }\n    var timeDim = data.mapDimension('single');\n    // data group by name\n    var groupResult = (0,model/* groupData */.Sq)(indexArr, function (index) {\n      return data.get('name', index);\n    });\n    var layerSeries = [];\n    groupResult.buckets.each(function (items, key) {\n      items.sort(function (index1, index2) {\n        return data.get(timeDim, index1) - data.get(timeDim, index2);\n      });\n      layerSeries.push({\n        name: key,\n        indices: items\n      });\n    });\n    return layerSeries;\n  };\n  /**\r\n   * Get data indices for show tooltip content\r\n   */\n  ThemeRiverSeriesModel.prototype.getAxisTooltipData = function (dim, value, baseAxis) {\n    if (!util.isArray(dim)) {\n      dim = dim ? [dim] : [];\n    }\n    var data = this.getData();\n    var layerSeries = this.getLayerSeries();\n    var indices = [];\n    var layerNum = layerSeries.length;\n    var nestestValue;\n    for (var i = 0; i < layerNum; ++i) {\n      var minDist = Number.MAX_VALUE;\n      var nearestIdx = -1;\n      var pointNum = layerSeries[i].indices.length;\n      for (var j = 0; j < pointNum; ++j) {\n        var theValue = data.get(dim[0], layerSeries[i].indices[j]);\n        var dist = Math.abs(theValue - value);\n        if (dist <= minDist) {\n          nestestValue = theValue;\n          minDist = dist;\n          nearestIdx = layerSeries[i].indices[j];\n        }\n      }\n      indices.push(nearestIdx);\n    }\n    return {\n      dataIndices: indices,\n      nestestValue: nestestValue\n    };\n  };\n  ThemeRiverSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n    var data = this.getData();\n    var name = data.getName(dataIndex);\n    var value = data.get(data.mapDimension('value'), dataIndex);\n    return (0,tooltipMarkup/* createTooltipMarkup */.Qx)('nameValue', {\n      name: name,\n      value: value\n    });\n  };\n  ThemeRiverSeriesModel.type = 'series.themeRiver';\n  ThemeRiverSeriesModel.dependencies = ['singleAxis'];\n  ThemeRiverSeriesModel.defaultOption = {\n    // zlevel: 0,\n    z: 2,\n    colorBy: 'data',\n    coordinateSystem: 'singleAxis',\n    // gap in axis's orthogonal orientation\n    boundaryGap: ['10%', '10%'],\n    // legendHoverLink: true,\n    singleAxisIndex: 0,\n    animationEasing: 'linear',\n    label: {\n      margin: 4,\n      show: true,\n      position: 'left',\n      fontSize: 11\n    },\n    emphasis: {\n      label: {\n        show: true\n      }\n    }\n  };\n  return ThemeRiverSeriesModel;\n}(Series/* default */.A);\n/* harmony default export */ const ThemeRiverSeries = (ThemeRiverSeriesModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n;// ./node_modules/echarts/lib/chart/themeRiver/themeRiverLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction themeRiverLayout(ecModel, api) {\n  ecModel.eachSeriesByType('themeRiver', function (seriesModel) {\n    var data = seriesModel.getData();\n    var single = seriesModel.coordinateSystem;\n    var layoutInfo = {};\n    // use the axis boundingRect for view\n    var rect = single.getRect();\n    layoutInfo.rect = rect;\n    var boundaryGap = seriesModel.get('boundaryGap');\n    var axis = single.getAxis();\n    layoutInfo.boundaryGap = boundaryGap;\n    if (axis.orient === 'horizontal') {\n      boundaryGap[0] = number/* parsePercent */.lo(boundaryGap[0], rect.height);\n      boundaryGap[1] = number/* parsePercent */.lo(boundaryGap[1], rect.height);\n      var height = rect.height - boundaryGap[0] - boundaryGap[1];\n      doThemeRiverLayout(data, seriesModel, height);\n    } else {\n      boundaryGap[0] = number/* parsePercent */.lo(boundaryGap[0], rect.width);\n      boundaryGap[1] = number/* parsePercent */.lo(boundaryGap[1], rect.width);\n      var width = rect.width - boundaryGap[0] - boundaryGap[1];\n      doThemeRiverLayout(data, seriesModel, width);\n    }\n    data.setLayout('layoutInfo', layoutInfo);\n  });\n}\n/**\r\n * The layout information about themeriver\r\n *\r\n * @param data  data in the series\r\n * @param seriesModel  the model object of themeRiver series\r\n * @param height  value used to compute every series height\r\n */\nfunction doThemeRiverLayout(data, seriesModel, height) {\n  if (!data.count()) {\n    return;\n  }\n  var coordSys = seriesModel.coordinateSystem;\n  // the data in each layer are organized into a series.\n  var layerSeries = seriesModel.getLayerSeries();\n  // the points in each layer.\n  var timeDim = data.mapDimension('single');\n  var valueDim = data.mapDimension('value');\n  var layerPoints = util.map(layerSeries, function (singleLayer) {\n    return util.map(singleLayer.indices, function (idx) {\n      var pt = coordSys.dataToPoint(data.get(timeDim, idx));\n      pt[1] = data.get(valueDim, idx);\n      return pt;\n    });\n  });\n  var base = computeBaseline(layerPoints);\n  var baseLine = base.y0;\n  var ky = height / base.max;\n  // set layout information for each item.\n  var n = layerSeries.length;\n  var m = layerSeries[0].indices.length;\n  var baseY0;\n  for (var j = 0; j < m; ++j) {\n    baseY0 = baseLine[j] * ky;\n    data.setItemLayout(layerSeries[0].indices[j], {\n      layerIndex: 0,\n      x: layerPoints[0][j][0],\n      y0: baseY0,\n      y: layerPoints[0][j][1] * ky\n    });\n    for (var i = 1; i < n; ++i) {\n      baseY0 += layerPoints[i - 1][j][1] * ky;\n      data.setItemLayout(layerSeries[i].indices[j], {\n        layerIndex: i,\n        x: layerPoints[i][j][0],\n        y0: baseY0,\n        y: layerPoints[i][j][1] * ky\n      });\n    }\n  }\n}\n/**\r\n * Compute the baseLine of the rawdata\r\n * Inspired by Lee Byron's paper Stacked Graphs - Geometry & Aesthetics\r\n *\r\n * @param  data  the points in each layer\r\n */\nfunction computeBaseline(data) {\n  var layerNum = data.length;\n  var pointNum = data[0].length;\n  var sums = [];\n  var y0 = [];\n  var max = 0;\n  for (var i = 0; i < pointNum; ++i) {\n    var temp = 0;\n    for (var j = 0; j < layerNum; ++j) {\n      temp += data[j][i][1];\n    }\n    if (temp > max) {\n      max = temp;\n    }\n    sums.push(temp);\n  }\n  for (var k = 0; k < pointNum; ++k) {\n    y0[k] = (max - sums[k]) / 2;\n  }\n  max = 0;\n  for (var l = 0; l < pointNum; ++l) {\n    var sum = sums[l] + y0[l];\n    if (sum > max) {\n      max = sum;\n    }\n  }\n  return {\n    y0: y0,\n    max: max\n  };\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/processor/dataFilter.js\nvar dataFilter = __webpack_require__(78587);\n;// ./node_modules/echarts/lib/chart/themeRiver/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\n\n\n\nfunction install(registers) {\n  registers.registerChartView(themeRiver_ThemeRiverView);\n  registers.registerSeriesModel(ThemeRiverSeries);\n  registers.registerLayout(themeRiverLayout);\n  registers.registerProcessor((0,dataFilter/* default */.A)('themeRiver'));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg5NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC90aGVtZVJpdmVyL1RoZW1lUml2ZXJWaWV3LmpzPzRhYWEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3RoZW1lUml2ZXIvVGhlbWVSaXZlclNlcmllcy5qcz8wNGM1Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC90aGVtZVJpdmVyL3RoZW1lUml2ZXJMYXlvdXQuanM/MTEzZCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvdGhlbWVSaXZlci9pbnN0YWxsLmpzPzViZTciXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEVDUG9seWdvbiB9IGZyb20gJy4uL2xpbmUvcG9seS5qcyc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwsIHRvZ2dsZUhvdmVyRW1waGFzaXMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgeyBzZXRMYWJlbFN0eWxlLCBnZXRMYWJlbFN0YXRlc01vZGVscyB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUuanMnO1xuaW1wb3J0IHsgYmluZCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgRGF0YURpZmZlciBmcm9tICcuLi8uLi9kYXRhL0RhdGFEaWZmZXIuanMnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0LmpzJztcbmltcG9ydCB7IHNhdmVPbGRTdHlsZSB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi9iYXNpY1RyYW5zaXRpb24uanMnO1xudmFyIFRoZW1lUml2ZXJWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRoZW1lUml2ZXJWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBUaGVtZVJpdmVyVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gVGhlbWVSaXZlclZpZXcudHlwZTtcbiAgICBfdGhpcy5fbGF5ZXJzID0gW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFRoZW1lUml2ZXJWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBsYXllcnNTZXJpZXMgPSBzZXJpZXNNb2RlbC5nZXRMYXllclNlcmllcygpO1xuICAgIHZhciBsYXlvdXRJbmZvID0gZGF0YS5nZXRMYXlvdXQoJ2xheW91dEluZm8nKTtcbiAgICB2YXIgcmVjdCA9IGxheW91dEluZm8ucmVjdDtcbiAgICB2YXIgYm91bmRhcnlHYXAgPSBsYXlvdXRJbmZvLmJvdW5kYXJ5R2FwO1xuICAgIGdyb3VwLnggPSAwO1xuICAgIGdyb3VwLnkgPSByZWN0LnkgKyBib3VuZGFyeUdhcFswXTtcbiAgICBmdW5jdGlvbiBrZXlHZXR0ZXIoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcbiAgICB9XG4gICAgdmFyIGRhdGFEaWZmZXIgPSBuZXcgRGF0YURpZmZlcih0aGlzLl9sYXllcnNTZXJpZXMgfHwgW10sIGxheWVyc1Nlcmllcywga2V5R2V0dGVyLCBrZXlHZXR0ZXIpO1xuICAgIHZhciBuZXdMYXllcnNHcm91cHMgPSBbXTtcbiAgICBkYXRhRGlmZmVyLmFkZChiaW5kKHByb2Nlc3MsIHRoaXMsICdhZGQnKSkudXBkYXRlKGJpbmQocHJvY2VzcywgdGhpcywgJ3VwZGF0ZScpKS5yZW1vdmUoYmluZChwcm9jZXNzLCB0aGlzLCAncmVtb3ZlJykpLmV4ZWN1dGUoKTtcbiAgICBmdW5jdGlvbiBwcm9jZXNzKHN0YXR1cywgaWR4LCBvbGRJZHgpIHtcbiAgICAgIHZhciBvbGRMYXllcnNHcm91cHMgPSBzZWxmLl9sYXllcnM7XG4gICAgICBpZiAoc3RhdHVzID09PSAncmVtb3ZlJykge1xuICAgICAgICBncm91cC5yZW1vdmUob2xkTGF5ZXJzR3JvdXBzW2lkeF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcG9pbnRzMCA9IFtdO1xuICAgICAgdmFyIHBvaW50czEgPSBbXTtcbiAgICAgIHZhciBzdHlsZTtcbiAgICAgIHZhciBpbmRpY2VzID0gbGF5ZXJzU2VyaWVzW2lkeF0uaW5kaWNlcztcbiAgICAgIHZhciBqID0gMDtcbiAgICAgIGZvciAoOyBqIDwgaW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGluZGljZXNbal0pO1xuICAgICAgICB2YXIgeCA9IGxheW91dC54O1xuICAgICAgICB2YXIgeTAgPSBsYXlvdXQueTA7XG4gICAgICAgIHZhciB5ID0gbGF5b3V0Lnk7XG4gICAgICAgIHBvaW50czAucHVzaCh4LCB5MCk7XG4gICAgICAgIHBvaW50czEucHVzaCh4LCB5MCArIHkpO1xuICAgICAgICBzdHlsZSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpbmRpY2VzW2pdLCAnc3R5bGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2x5Z29uO1xuICAgICAgdmFyIHRleHRMYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaW5kaWNlc1swXSk7XG4gICAgICB2YXIgbGFiZWxNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdsYWJlbCcpO1xuICAgICAgdmFyIG1hcmdpbiA9IGxhYmVsTW9kZWwuZ2V0KCdtYXJnaW4nKTtcbiAgICAgIHZhciBlbXBoYXNpc01vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJyk7XG4gICAgICBpZiAoc3RhdHVzID09PSAnYWRkJykge1xuICAgICAgICB2YXIgbGF5ZXJHcm91cCA9IG5ld0xheWVyc0dyb3Vwc1tpZHhdID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICAgICAgcG9seWdvbiA9IG5ldyBFQ1BvbHlnb24oe1xuICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBwb2ludHM6IHBvaW50czAsXG4gICAgICAgICAgICBzdGFja2VkT25Qb2ludHM6IHBvaW50czEsXG4gICAgICAgICAgICBzbW9vdGg6IDAuNCxcbiAgICAgICAgICAgIHN0YWNrZWRPblNtb290aDogMC40LFxuICAgICAgICAgICAgc21vb3RoQ29uc3RyYWludDogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHoyOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBsYXllckdyb3VwLmFkZChwb2x5Z29uKTtcbiAgICAgICAgZ3JvdXAuYWRkKGxheWVyR3JvdXApO1xuICAgICAgICBpZiAoc2VyaWVzTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICBwb2x5Z29uLnNldENsaXBQYXRoKGNyZWF0ZUdyaWRDbGlwU2hhcGUocG9seWdvbi5nZXRCb3VuZGluZ1JlY3QoKSwgc2VyaWVzTW9kZWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBvbHlnb24ucmVtb3ZlQ2xpcFBhdGgoKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsYXllckdyb3VwID0gb2xkTGF5ZXJzR3JvdXBzW29sZElkeF07XG4gICAgICAgIHBvbHlnb24gPSBsYXllckdyb3VwLmNoaWxkQXQoMCk7XG4gICAgICAgIGdyb3VwLmFkZChsYXllckdyb3VwKTtcbiAgICAgICAgbmV3TGF5ZXJzR3JvdXBzW2lkeF0gPSBsYXllckdyb3VwO1xuICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvbHlnb24sIHtcbiAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMwLFxuICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBwb2ludHMxXG4gICAgICAgICAgfVxuICAgICAgICB9LCBzZXJpZXNNb2RlbCk7XG4gICAgICAgIHNhdmVPbGRTdHlsZShwb2x5Z29uKTtcbiAgICAgIH1cbiAgICAgIHNldExhYmVsU3R5bGUocG9seWdvbiwgZ2V0TGFiZWxTdGF0ZXNNb2RlbHMoc2VyaWVzTW9kZWwpLCB7XG4gICAgICAgIGxhYmVsRGF0YUluZGV4OiBpbmRpY2VzW2ogLSAxXSxcbiAgICAgICAgZGVmYXVsdFRleHQ6IGRhdGEuZ2V0TmFtZShpbmRpY2VzW2ogLSAxXSksXG4gICAgICAgIGluaGVyaXRDb2xvcjogc3R5bGUuZmlsbFxuICAgICAgfSwge1xuICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJ1xuICAgICAgICAgIC8vIGFsaWduOiAncmlnaHQnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcG9seWdvbi5zZXRUZXh0Q29uZmlnKHtcbiAgICAgICAgcG9zaXRpb246IG51bGwsXG4gICAgICAgIGxvY2FsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhciBsYWJlbEVsID0gcG9seWdvbi5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgLy8gVE9ETyBNb3JlIGxhYmVsIHBvc2l0aW9uIG9wdGlvbnMuXG4gICAgICBpZiAobGFiZWxFbCkge1xuICAgICAgICBsYWJlbEVsLnggPSB0ZXh0TGF5b3V0LnggLSBtYXJnaW47XG4gICAgICAgIGxhYmVsRWwueSA9IHRleHRMYXlvdXQueTAgKyB0ZXh0TGF5b3V0LnkgLyAyO1xuICAgICAgfVxuICAgICAgcG9seWdvbi51c2VTdHlsZShzdHlsZSk7XG4gICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBwb2x5Z29uKTtcbiAgICAgIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChwb2x5Z29uLCBzZXJpZXNNb2RlbCk7XG4gICAgICB0b2dnbGVIb3ZlckVtcGhhc2lzKHBvbHlnb24sIGVtcGhhc2lzTW9kZWwuZ2V0KCdmb2N1cycpLCBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJyksIGVtcGhhc2lzTW9kZWwuZ2V0KCdkaXNhYmxlZCcpKTtcbiAgICB9XG4gICAgdGhpcy5fbGF5ZXJzU2VyaWVzID0gbGF5ZXJzU2VyaWVzO1xuICAgIHRoaXMuX2xheWVycyA9IG5ld0xheWVyc0dyb3VwcztcbiAgfTtcbiAgVGhlbWVSaXZlclZpZXcudHlwZSA9ICd0aGVtZVJpdmVyJztcbiAgcmV0dXJuIFRoZW1lUml2ZXJWaWV3O1xufShDaGFydFZpZXcpO1xuO1xuLy8gYWRkIGFuaW1hdGlvbiB0byB0aGUgdmlld1xuZnVuY3Rpb24gY3JlYXRlR3JpZENsaXBTaGFwZShyZWN0LCBzZXJpZXNNb2RlbCwgY2IpIHtcbiAgdmFyIHJlY3RFbCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgIHNoYXBlOiB7XG4gICAgICB4OiByZWN0LnggLSAxMCxcbiAgICAgIHk6IHJlY3QueSAtIDEwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICsgMjBcbiAgICB9XG4gIH0pO1xuICBncmFwaGljLmluaXRQcm9wcyhyZWN0RWwsIHtcbiAgICBzaGFwZToge1xuICAgICAgeDogcmVjdC54IC0gNTAsXG4gICAgICB3aWR0aDogcmVjdC53aWR0aCArIDEwMCxcbiAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKyAyMFxuICAgIH1cbiAgfSwgc2VyaWVzTW9kZWwsIGNiKTtcbiAgcmV0dXJuIHJlY3RFbDtcbn1cbmV4cG9ydCBkZWZhdWx0IFRoZW1lUml2ZXJWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgU2VyaWVzTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvU2VyaWVzLmpzJztcbmltcG9ydCBwcmVwYXJlU2VyaWVzRGF0YVNjaGVtYSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9jcmVhdGVEaW1lbnNpb25zLmpzJztcbmltcG9ydCB7IGdldERpbWVuc2lvblR5cGVCeUF4aXMgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9kaW1lbnNpb25IZWxwZXIuanMnO1xuaW1wb3J0IFNlcmllc0RhdGEgZnJvbSAnLi4vLi4vZGF0YS9TZXJpZXNEYXRhLmpzJztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgZ3JvdXBEYXRhLCBTSU5HTEVfUkVGRVJSSU5HIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG5pbXBvcnQgTGVnZW5kVmlzdWFsUHJvdmlkZXIgZnJvbSAnLi4vLi4vdmlzdWFsL0xlZ2VuZFZpc3VhbFByb3ZpZGVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZVRvb2x0aXBNYXJrdXAgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvdG9vbHRpcC90b29sdGlwTWFya3VwLmpzJztcbnZhciBEQVRBX05BTUVfSU5ERVggPSAyO1xudmFyIFRoZW1lUml2ZXJTZXJpZXNNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUaGVtZVJpdmVyU2VyaWVzTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFRoZW1lUml2ZXJTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gVGhlbWVSaXZlclNlcmllc01vZGVsLnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBUaGVtZVJpdmVyU2VyaWVzTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gUHV0IHRoaXMgZnVuY3Rpb24gaGVyZSBpcyBmb3IgdGhlIHNha2Ugb2YgY29uc2lzdGVuY3kgb2YgY29kZSBzdHlsZS5cbiAgICAvLyBFbmFibGUgbGVnZW5kIHNlbGVjdGlvbiBmb3IgZWFjaCBkYXRhIGl0ZW1cbiAgICAvLyBVc2UgYSBmdW5jdGlvbiBpbnN0ZWFkIG9mIGRpcmVjdCBhY2Nlc3MgYmVjYXVzZSBkYXRhIHJlZmVyZW5jZSBtYXkgY2hhbmdlZFxuICAgIHRoaXMubGVnZW5kVmlzdWFsUHJvdmlkZXIgPSBuZXcgTGVnZW5kVmlzdWFsUHJvdmlkZXIoenJVdGlsLmJpbmQodGhpcy5nZXREYXRhLCB0aGlzKSwgenJVdGlsLmJpbmQodGhpcy5nZXRSYXdEYXRhLCB0aGlzKSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIElmIHRoZXJlIGlzIG5vIHZhbHVlIG9mIGEgY2VydGFpbiBwb2ludCBpbiB0aGUgdGltZSBmb3Igc29tZSBldmVudCxzZXQgaXQgdmFsdWUgdG8gMC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgIGluaXRpYWwgZGF0YSBpbiB0aGUgb3B0aW9uXHJcbiAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICovXG4gIFRoZW1lUml2ZXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuZml4RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHJhd0RhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAvKipcclxuICAgICAqIE1ha2Ugc3VyZSBldmVyeSBsYXllciBkYXRhIGdldCB0aGUgc2FtZSBrZXlzLlxyXG4gICAgICogVGhlIHZhbHVlIGluZGV4IHRlbGxzIHdoaWNoIGxheWVyIGhhcyB2aXNpdGVkLlxyXG4gICAgICoge1xyXG4gICAgICogIDIwMTQvMDEvMDE6IC0xXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cbiAgICB2YXIgdGltZVZhbHVlS2V5cyA9IHt9O1xuICAgIC8vIGdyb3VwZWQgZGF0YSBieSBuYW1lXG4gICAgdmFyIGdyb3VwUmVzdWx0ID0gZ3JvdXBEYXRhKGRhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoIXRpbWVWYWx1ZUtleXMuaGFzT3duUHJvcGVydHkoaXRlbVswXSArICcnKSkge1xuICAgICAgICB0aW1lVmFsdWVLZXlzW2l0ZW1bMF0gKyAnJ10gPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtWzJdO1xuICAgIH0pO1xuICAgIHZhciBsYXllckRhdGEgPSBbXTtcbiAgICBncm91cFJlc3VsdC5idWNrZXRzLmVhY2goZnVuY3Rpb24gKGl0ZW1zLCBrZXkpIHtcbiAgICAgIGxheWVyRGF0YS5wdXNoKHtcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICBkYXRhTGlzdDogaXRlbXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBsYXllck51bSA9IGxheWVyRGF0YS5sZW5ndGg7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBsYXllck51bTsgKytrKSB7XG4gICAgICB2YXIgbmFtZV8xID0gbGF5ZXJEYXRhW2tdLm5hbWU7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxheWVyRGF0YVtrXS5kYXRhTGlzdC5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgdGltZVZhbHVlID0gbGF5ZXJEYXRhW2tdLmRhdGFMaXN0W2pdWzBdICsgJyc7XG4gICAgICAgIHRpbWVWYWx1ZUtleXNbdGltZVZhbHVlXSA9IGs7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciB0aW1lVmFsdWUgaW4gdGltZVZhbHVlS2V5cykge1xuICAgICAgICBpZiAodGltZVZhbHVlS2V5cy5oYXNPd25Qcm9wZXJ0eSh0aW1lVmFsdWUpICYmIHRpbWVWYWx1ZUtleXNbdGltZVZhbHVlXSAhPT0gaykge1xuICAgICAgICAgIHRpbWVWYWx1ZUtleXNbdGltZVZhbHVlXSA9IGs7XG4gICAgICAgICAgZGF0YVtyYXdEYXRhTGVuZ3RoXSA9IFt0aW1lVmFsdWUsIDAsIG5hbWVfMV07XG4gICAgICAgICAgcmF3RGF0YUxlbmd0aCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAcGFyYW0gIG9wdGlvbiAgdGhlIGluaXRpYWwgb3B0aW9uIHRoYXQgdXNlciBnYXZlXHJcbiAgICogQHBhcmFtICBlY01vZGVsICB0aGUgbW9kZWwgb2JqZWN0IGZvciB0aGVtZVJpdmVyIG9wdGlvblxyXG4gICAqL1xuICBUaGVtZVJpdmVyU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIHZhciBzaW5nbGVBeGlzTW9kZWwgPSB0aGlzLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3NpbmdsZUF4aXMnLCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG4gICAgdmFyIGF4aXNUeXBlID0gc2luZ2xlQXhpc01vZGVsLmdldCgndHlwZScpO1xuICAgIC8vIGZpbHRlciB0aGUgZGF0YSBpdGVtIHdpdGggdGhlIHZhbHVlIG9mIGxhYmVsIGlzIHVuZGVmaW5lZFxuICAgIHZhciBmaWx0ZXJEYXRhID0genJVdGlsLmZpbHRlcihvcHRpb24uZGF0YSwgZnVuY3Rpb24gKGRhdGFJdGVtKSB7XG4gICAgICByZXR1cm4gZGF0YUl0ZW1bMl0gIT09IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICAvLyA/Pz8gVE9ETyBkZXNpZ24gYSBzdGFnZSB0byB0cmFuc2ZlciBkYXRhIGZvciB0aGVtZVJpdmVyIGFuZCBsaW5lcz9cbiAgICB2YXIgZGF0YSA9IHRoaXMuZml4RGF0YShmaWx0ZXJEYXRhIHx8IFtdKTtcbiAgICB2YXIgbmFtZUxpc3QgPSBbXTtcbiAgICB2YXIgbmFtZU1hcCA9IHRoaXMubmFtZU1hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIG5hbWVMaXN0LnB1c2goZGF0YVtpXVtEQVRBX05BTUVfSU5ERVhdKTtcbiAgICAgIGlmICghbmFtZU1hcC5nZXQoZGF0YVtpXVtEQVRBX05BTUVfSU5ERVhdKSkge1xuICAgICAgICBuYW1lTWFwLnNldChkYXRhW2ldW0RBVEFfTkFNRV9JTkRFWF0sIGNvdW50KTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGRpbWVuc2lvbnMgPSBwcmVwYXJlU2VyaWVzRGF0YVNjaGVtYShkYXRhLCB7XG4gICAgICBjb29yZERpbWVuc2lvbnM6IFsnc2luZ2xlJ10sXG4gICAgICBkaW1lbnNpb25zRGVmaW5lOiBbe1xuICAgICAgICBuYW1lOiAndGltZScsXG4gICAgICAgIHR5cGU6IGdldERpbWVuc2lvblR5cGVCeUF4aXMoYXhpc1R5cGUpXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICAgIHR5cGU6ICdmbG9hdCdcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgICB0eXBlOiAnb3JkaW5hbCdcbiAgICAgIH1dLFxuICAgICAgZW5jb2RlRGVmaW5lOiB7XG4gICAgICAgIHNpbmdsZTogMCxcbiAgICAgICAgdmFsdWU6IDEsXG4gICAgICAgIGl0ZW1OYW1lOiAyXG4gICAgICB9XG4gICAgfSkuZGltZW5zaW9ucztcbiAgICB2YXIgbGlzdCA9IG5ldyBTZXJpZXNEYXRhKGRpbWVuc2lvbnMsIHRoaXMpO1xuICAgIGxpc3QuaW5pdERhdGEoZGF0YSk7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH07XG4gIC8qKlxyXG4gICAqIFRoZSByYXcgZGF0YSBpcyBkaXZpZGVkIGludG8gbXVsdGlwbGUgbGF5ZXJzIGFuZCBlYWNoIGxheWVyXHJcbiAgICogICAgIGhhcyBzYW1lIG5hbWUuXHJcbiAgICovXG4gIFRoZW1lUml2ZXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0TGF5ZXJTZXJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICB2YXIgbGVuQ291bnQgPSBkYXRhLmNvdW50KCk7XG4gICAgdmFyIGluZGV4QXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5Db3VudDsgKytpKSB7XG4gICAgICBpbmRleEFycltpXSA9IGk7XG4gICAgfVxuICAgIHZhciB0aW1lRGltID0gZGF0YS5tYXBEaW1lbnNpb24oJ3NpbmdsZScpO1xuICAgIC8vIGRhdGEgZ3JvdXAgYnkgbmFtZVxuICAgIHZhciBncm91cFJlc3VsdCA9IGdyb3VwRGF0YShpbmRleEFyciwgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gZGF0YS5nZXQoJ25hbWUnLCBpbmRleCk7XG4gICAgfSk7XG4gICAgdmFyIGxheWVyU2VyaWVzID0gW107XG4gICAgZ3JvdXBSZXN1bHQuYnVja2V0cy5lYWNoKGZ1bmN0aW9uIChpdGVtcywga2V5KSB7XG4gICAgICBpdGVtcy5zb3J0KGZ1bmN0aW9uIChpbmRleDEsIGluZGV4Mikge1xuICAgICAgICByZXR1cm4gZGF0YS5nZXQodGltZURpbSwgaW5kZXgxKSAtIGRhdGEuZ2V0KHRpbWVEaW0sIGluZGV4Mik7XG4gICAgICB9KTtcbiAgICAgIGxheWVyU2VyaWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIGluZGljZXM6IGl0ZW1zXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gbGF5ZXJTZXJpZXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCBkYXRhIGluZGljZXMgZm9yIHNob3cgdG9vbHRpcCBjb250ZW50XHJcbiAgICovXG4gIFRoZW1lUml2ZXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0QXhpc1Rvb2x0aXBEYXRhID0gZnVuY3Rpb24gKGRpbSwgdmFsdWUsIGJhc2VBeGlzKSB7XG4gICAgaWYgKCF6clV0aWwuaXNBcnJheShkaW0pKSB7XG4gICAgICBkaW0gPSBkaW0gPyBbZGltXSA6IFtdO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIHZhciBsYXllclNlcmllcyA9IHRoaXMuZ2V0TGF5ZXJTZXJpZXMoKTtcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIHZhciBsYXllck51bSA9IGxheWVyU2VyaWVzLmxlbmd0aDtcbiAgICB2YXIgbmVzdGVzdFZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJOdW07ICsraSkge1xuICAgICAgdmFyIG1pbkRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgdmFyIG5lYXJlc3RJZHggPSAtMTtcbiAgICAgIHZhciBwb2ludE51bSA9IGxheWVyU2VyaWVzW2ldLmluZGljZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2ludE51bTsgKytqKSB7XG4gICAgICAgIHZhciB0aGVWYWx1ZSA9IGRhdGEuZ2V0KGRpbVswXSwgbGF5ZXJTZXJpZXNbaV0uaW5kaWNlc1tqXSk7XG4gICAgICAgIHZhciBkaXN0ID0gTWF0aC5hYnModGhlVmFsdWUgLSB2YWx1ZSk7XG4gICAgICAgIGlmIChkaXN0IDw9IG1pbkRpc3QpIHtcbiAgICAgICAgICBuZXN0ZXN0VmFsdWUgPSB0aGVWYWx1ZTtcbiAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgICBuZWFyZXN0SWR4ID0gbGF5ZXJTZXJpZXNbaV0uaW5kaWNlc1tqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5kaWNlcy5wdXNoKG5lYXJlc3RJZHgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YUluZGljZXM6IGluZGljZXMsXG4gICAgICBuZXN0ZXN0VmFsdWU6IG5lc3Rlc3RWYWx1ZVxuICAgIH07XG4gIH07XG4gIFRoZW1lUml2ZXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuZm9ybWF0VG9vbHRpcCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIG11bHRpcGxlU2VyaWVzLCBkYXRhVHlwZSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4KTtcbiAgICB2YXIgdmFsdWUgPSBkYXRhLmdldChkYXRhLm1hcERpbWVuc2lvbigndmFsdWUnKSwgZGF0YUluZGV4KTtcbiAgICByZXR1cm4gY3JlYXRlVG9vbHRpcE1hcmt1cCgnbmFtZVZhbHVlJywge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICB9O1xuICBUaGVtZVJpdmVyU2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMudGhlbWVSaXZlcic7XG4gIFRoZW1lUml2ZXJTZXJpZXNNb2RlbC5kZXBlbmRlbmNpZXMgPSBbJ3NpbmdsZUF4aXMnXTtcbiAgVGhlbWVSaXZlclNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgLy8gemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgY29sb3JCeTogJ2RhdGEnLFxuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdzaW5nbGVBeGlzJyxcbiAgICAvLyBnYXAgaW4gYXhpcydzIG9ydGhvZ29uYWwgb3JpZW50YXRpb25cbiAgICBib3VuZGFyeUdhcDogWycxMCUnLCAnMTAlJ10sXG4gICAgLy8gbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIHNpbmdsZUF4aXNJbmRleDogMCxcbiAgICBhbmltYXRpb25FYXNpbmc6ICdsaW5lYXInLFxuICAgIGxhYmVsOiB7XG4gICAgICBtYXJnaW46IDQsXG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgcG9zaXRpb246ICdsZWZ0JyxcbiAgICAgIGZvbnRTaXplOiAxMVxuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIHNob3c6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBUaGVtZVJpdmVyU2VyaWVzTW9kZWw7XG59KFNlcmllc01vZGVsKTtcbmV4cG9ydCBkZWZhdWx0IFRoZW1lUml2ZXJTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgbnVtYmVyVXRpbCBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aGVtZVJpdmVyTGF5b3V0KGVjTW9kZWwsIGFwaSkge1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ3RoZW1lUml2ZXInLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgc2luZ2xlID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgbGF5b3V0SW5mbyA9IHt9O1xuICAgIC8vIHVzZSB0aGUgYXhpcyBib3VuZGluZ1JlY3QgZm9yIHZpZXdcbiAgICB2YXIgcmVjdCA9IHNpbmdsZS5nZXRSZWN0KCk7XG4gICAgbGF5b3V0SW5mby5yZWN0ID0gcmVjdDtcbiAgICB2YXIgYm91bmRhcnlHYXAgPSBzZXJpZXNNb2RlbC5nZXQoJ2JvdW5kYXJ5R2FwJyk7XG4gICAgdmFyIGF4aXMgPSBzaW5nbGUuZ2V0QXhpcygpO1xuICAgIGxheW91dEluZm8uYm91bmRhcnlHYXAgPSBib3VuZGFyeUdhcDtcbiAgICBpZiAoYXhpcy5vcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgYm91bmRhcnlHYXBbMF0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFswXSwgcmVjdC5oZWlnaHQpO1xuICAgICAgYm91bmRhcnlHYXBbMV0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFsxXSwgcmVjdC5oZWlnaHQpO1xuICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0IC0gYm91bmRhcnlHYXBbMF0gLSBib3VuZGFyeUdhcFsxXTtcbiAgICAgIGRvVGhlbWVSaXZlckxheW91dChkYXRhLCBzZXJpZXNNb2RlbCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRhcnlHYXBbMF0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFswXSwgcmVjdC53aWR0aCk7XG4gICAgICBib3VuZGFyeUdhcFsxXSA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGJvdW5kYXJ5R2FwWzFdLCByZWN0LndpZHRoKTtcbiAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGggLSBib3VuZGFyeUdhcFswXSAtIGJvdW5kYXJ5R2FwWzFdO1xuICAgICAgZG9UaGVtZVJpdmVyTGF5b3V0KGRhdGEsIHNlcmllc01vZGVsLCB3aWR0aCk7XG4gICAgfVxuICAgIGRhdGEuc2V0TGF5b3V0KCdsYXlvdXRJbmZvJywgbGF5b3V0SW5mbyk7XG4gIH0pO1xufVxuLyoqXHJcbiAqIFRoZSBsYXlvdXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlbWVyaXZlclxyXG4gKlxyXG4gKiBAcGFyYW0gZGF0YSAgZGF0YSBpbiB0aGUgc2VyaWVzXHJcbiAqIEBwYXJhbSBzZXJpZXNNb2RlbCAgdGhlIG1vZGVsIG9iamVjdCBvZiB0aGVtZVJpdmVyIHNlcmllc1xyXG4gKiBAcGFyYW0gaGVpZ2h0ICB2YWx1ZSB1c2VkIHRvIGNvbXB1dGUgZXZlcnkgc2VyaWVzIGhlaWdodFxyXG4gKi9cbmZ1bmN0aW9uIGRvVGhlbWVSaXZlckxheW91dChkYXRhLCBzZXJpZXNNb2RlbCwgaGVpZ2h0KSB7XG4gIGlmICghZGF0YS5jb3VudCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gIC8vIHRoZSBkYXRhIGluIGVhY2ggbGF5ZXIgYXJlIG9yZ2FuaXplZCBpbnRvIGEgc2VyaWVzLlxuICB2YXIgbGF5ZXJTZXJpZXMgPSBzZXJpZXNNb2RlbC5nZXRMYXllclNlcmllcygpO1xuICAvLyB0aGUgcG9pbnRzIGluIGVhY2ggbGF5ZXIuXG4gIHZhciB0aW1lRGltID0gZGF0YS5tYXBEaW1lbnNpb24oJ3NpbmdsZScpO1xuICB2YXIgdmFsdWVEaW0gPSBkYXRhLm1hcERpbWVuc2lvbigndmFsdWUnKTtcbiAgdmFyIGxheWVyUG9pbnRzID0genJVdGlsLm1hcChsYXllclNlcmllcywgZnVuY3Rpb24gKHNpbmdsZUxheWVyKSB7XG4gICAgcmV0dXJuIHpyVXRpbC5tYXAoc2luZ2xlTGF5ZXIuaW5kaWNlcywgZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIHB0ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoZGF0YS5nZXQodGltZURpbSwgaWR4KSk7XG4gICAgICBwdFsxXSA9IGRhdGEuZ2V0KHZhbHVlRGltLCBpZHgpO1xuICAgICAgcmV0dXJuIHB0O1xuICAgIH0pO1xuICB9KTtcbiAgdmFyIGJhc2UgPSBjb21wdXRlQmFzZWxpbmUobGF5ZXJQb2ludHMpO1xuICB2YXIgYmFzZUxpbmUgPSBiYXNlLnkwO1xuICB2YXIga3kgPSBoZWlnaHQgLyBiYXNlLm1heDtcbiAgLy8gc2V0IGxheW91dCBpbmZvcm1hdGlvbiBmb3IgZWFjaCBpdGVtLlxuICB2YXIgbiA9IGxheWVyU2VyaWVzLmxlbmd0aDtcbiAgdmFyIG0gPSBsYXllclNlcmllc1swXS5pbmRpY2VzLmxlbmd0aDtcbiAgdmFyIGJhc2VZMDtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBiYXNlWTAgPSBiYXNlTGluZVtqXSAqIGt5O1xuICAgIGRhdGEuc2V0SXRlbUxheW91dChsYXllclNlcmllc1swXS5pbmRpY2VzW2pdLCB7XG4gICAgICBsYXllckluZGV4OiAwLFxuICAgICAgeDogbGF5ZXJQb2ludHNbMF1bal1bMF0sXG4gICAgICB5MDogYmFzZVkwLFxuICAgICAgeTogbGF5ZXJQb2ludHNbMF1bal1bMV0gKiBreVxuICAgIH0pO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICBiYXNlWTAgKz0gbGF5ZXJQb2ludHNbaSAtIDFdW2pdWzFdICoga3k7XG4gICAgICBkYXRhLnNldEl0ZW1MYXlvdXQobGF5ZXJTZXJpZXNbaV0uaW5kaWNlc1tqXSwge1xuICAgICAgICBsYXllckluZGV4OiBpLFxuICAgICAgICB4OiBsYXllclBvaW50c1tpXVtqXVswXSxcbiAgICAgICAgeTA6IGJhc2VZMCxcbiAgICAgICAgeTogbGF5ZXJQb2ludHNbaV1bal1bMV0gKiBreVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4vKipcclxuICogQ29tcHV0ZSB0aGUgYmFzZUxpbmUgb2YgdGhlIHJhd2RhdGFcclxuICogSW5zcGlyZWQgYnkgTGVlIEJ5cm9uJ3MgcGFwZXIgU3RhY2tlZCBHcmFwaHMgLSBHZW9tZXRyeSAmIEFlc3RoZXRpY3NcclxuICpcclxuICogQHBhcmFtICBkYXRhICB0aGUgcG9pbnRzIGluIGVhY2ggbGF5ZXJcclxuICovXG5mdW5jdGlvbiBjb21wdXRlQmFzZWxpbmUoZGF0YSkge1xuICB2YXIgbGF5ZXJOdW0gPSBkYXRhLmxlbmd0aDtcbiAgdmFyIHBvaW50TnVtID0gZGF0YVswXS5sZW5ndGg7XG4gIHZhciBzdW1zID0gW107XG4gIHZhciB5MCA9IFtdO1xuICB2YXIgbWF4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludE51bTsgKytpKSB7XG4gICAgdmFyIHRlbXAgPSAwO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGF5ZXJOdW07ICsraikge1xuICAgICAgdGVtcCArPSBkYXRhW2pdW2ldWzFdO1xuICAgIH1cbiAgICBpZiAodGVtcCA+IG1heCkge1xuICAgICAgbWF4ID0gdGVtcDtcbiAgICB9XG4gICAgc3Vtcy5wdXNoKHRlbXApO1xuICB9XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgcG9pbnROdW07ICsraykge1xuICAgIHkwW2tdID0gKG1heCAtIHN1bXNba10pIC8gMjtcbiAgfVxuICBtYXggPSAwO1xuICBmb3IgKHZhciBsID0gMDsgbCA8IHBvaW50TnVtOyArK2wpIHtcbiAgICB2YXIgc3VtID0gc3Vtc1tsXSArIHkwW2xdO1xuICAgIGlmIChzdW0gPiBtYXgpIHtcbiAgICAgIG1heCA9IHN1bTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB5MDogeTAsXG4gICAgbWF4OiBtYXhcbiAgfTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuaW1wb3J0IFRoZW1lUml2ZXJWaWV3IGZyb20gJy4vVGhlbWVSaXZlclZpZXcuanMnO1xuaW1wb3J0IFRoZW1lUml2ZXJTZXJpZXNNb2RlbCBmcm9tICcuL1RoZW1lUml2ZXJTZXJpZXMuanMnO1xuaW1wb3J0IHRoZW1lUml2ZXJMYXlvdXQgZnJvbSAnLi90aGVtZVJpdmVyTGF5b3V0LmpzJztcbmltcG9ydCBkYXRhRmlsdGVyIGZyb20gJy4uLy4uL3Byb2Nlc3Nvci9kYXRhRmlsdGVyLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDaGFydFZpZXcoVGhlbWVSaXZlclZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChUaGVtZVJpdmVyU2VyaWVzTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQodGhlbWVSaXZlckxheW91dCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclByb2Nlc3NvcihkYXRhRmlsdGVyKCd0aGVtZVJpdmVyJykpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9895\n")},31441:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/BezierCurve.js\nvar BezierCurve = __webpack_require__(53849);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/Symbol.js\nvar helper_Symbol = __webpack_require__(10128);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n;// ./node_modules/echarts/lib/chart/tree/layoutHelper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/*\r\n* A third-party license is embedded for some of the code in this file:\r\n* The tree layoutHelper implementation was originally copied from\r\n* \"d3.js\"(https://github.com/d3/d3-hierarchy) with\r\n* some modifications made for this project.\r\n* (see more details in the comment of the specific method below.)\r\n* The use of the source code of this file is also subject to the terms\r\n* and consitions of the licence of \"d3.js\" (BSD-3Clause, see\r\n* </licenses/LICENSE-d3>).\r\n*/\n/**\r\n * @file The layout algorithm of node-link tree diagrams. Here we using Reingold-Tilford algorithm to drawing\r\n *       the tree.\r\n */\n\n/**\r\n * Initialize all computational message for following algorithm.\r\n */\nfunction init(inRoot) {\n  var root = inRoot;\n  root.hierNode = {\n    defaultAncestor: null,\n    ancestor: root,\n    prelim: 0,\n    modifier: 0,\n    change: 0,\n    shift: 0,\n    i: 0,\n    thread: null\n  };\n  var nodes = [root];\n  var node;\n  var children;\n  while (node = nodes.pop()) {\n    // jshint ignore:line\n    children = node.children;\n    if (node.isExpand && children.length) {\n      var n = children.length;\n      for (var i = n - 1; i >= 0; i--) {\n        var child = children[i];\n        child.hierNode = {\n          defaultAncestor: null,\n          ancestor: child,\n          prelim: 0,\n          modifier: 0,\n          change: 0,\n          shift: 0,\n          i: i,\n          thread: null\n        };\n        nodes.push(child);\n      }\n    }\n  }\n}\n/**\r\n * The implementation of this function was originally copied from \"d3.js\"\r\n * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>\r\n * with some modifications made for this program.\r\n * See the license statement at the head of this file.\r\n *\r\n * Computes a preliminary x coordinate for node. Before that, this function is\r\n * applied recursively to the children of node, as well as the function\r\n * apportion(). After spacing out the children by calling executeShifts(), the\r\n * node is placed to the midpoint of its outermost children.\r\n */\nfunction firstWalk(node, separation) {\n  var children = node.isExpand ? node.children : [];\n  var siblings = node.parentNode.children;\n  var subtreeW = node.hierNode.i ? siblings[node.hierNode.i - 1] : null;\n  if (children.length) {\n    executeShifts(node);\n    var midPoint = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2;\n    if (subtreeW) {\n      node.hierNode.prelim = subtreeW.hierNode.prelim + separation(node, subtreeW);\n      node.hierNode.modifier = node.hierNode.prelim - midPoint;\n    } else {\n      node.hierNode.prelim = midPoint;\n    }\n  } else if (subtreeW) {\n    node.hierNode.prelim = subtreeW.hierNode.prelim + separation(node, subtreeW);\n  }\n  node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation);\n}\n/**\r\n * The implementation of this function was originally copied from \"d3.js\"\r\n * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>\r\n * with some modifications made for this program.\r\n * See the license statement at the head of this file.\r\n *\r\n * Computes all real x-coordinates by summing up the modifiers recursively.\r\n */\nfunction secondWalk(node) {\n  var nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier;\n  node.setLayout({\n    x: nodeX\n  }, true);\n  node.hierNode.modifier += node.parentNode.hierNode.modifier;\n}\nfunction layoutHelper_separation(cb) {\n  return arguments.length ? cb : defaultSeparation;\n}\n/**\r\n * Transform the common coordinate to radial coordinate.\r\n */\nfunction radialCoordinate(rad, r) {\n  rad -= Math.PI / 2;\n  return {\n    x: r * Math.cos(rad),\n    y: r * Math.sin(rad)\n  };\n}\n/**\r\n * Get the layout position of the whole view.\r\n */\nfunction getViewRect(seriesModel, api) {\n  return layout/* getLayoutRect */.dV(seriesModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n}\n/**\r\n * All other shifts, applied to the smaller subtrees between w- and w+, are\r\n * performed by this function.\r\n *\r\n * The implementation of this function was originally copied from \"d3.js\"\r\n * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>\r\n * with some modifications made for this program.\r\n * See the license statement at the head of this file.\r\n */\nfunction executeShifts(node) {\n  var children = node.children;\n  var n = children.length;\n  var shift = 0;\n  var change = 0;\n  while (--n >= 0) {\n    var child = children[n];\n    child.hierNode.prelim += shift;\n    child.hierNode.modifier += shift;\n    change += child.hierNode.change;\n    shift += child.hierNode.shift + change;\n  }\n}\n/**\r\n * The implementation of this function was originally copied from \"d3.js\"\r\n * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>\r\n * with some modifications made for this program.\r\n * See the license statement at the head of this file.\r\n *\r\n * The core of the algorithm. Here, a new subtree is combined with the\r\n * previous subtrees. Threads are used to traverse the inside and outside\r\n * contours of the left and right subtree up to the highest common level.\r\n * Whenever two nodes of the inside contours conflict, we compute the left\r\n * one of the greatest uncommon ancestors using the function nextAncestor()\r\n * and call moveSubtree() to shift the subtree and prepare the shifts of\r\n * smaller subtrees. Finally, we add a new thread (if necessary).\r\n */\nfunction apportion(subtreeV, subtreeW, ancestor, separation) {\n  if (subtreeW) {\n    var nodeOutRight = subtreeV;\n    var nodeInRight = subtreeV;\n    var nodeOutLeft = nodeInRight.parentNode.children[0];\n    var nodeInLeft = subtreeW;\n    var sumOutRight = nodeOutRight.hierNode.modifier;\n    var sumInRight = nodeInRight.hierNode.modifier;\n    var sumOutLeft = nodeOutLeft.hierNode.modifier;\n    var sumInLeft = nodeInLeft.hierNode.modifier;\n    while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {\n      nodeOutRight = nextRight(nodeOutRight);\n      nodeOutLeft = nextLeft(nodeOutLeft);\n      nodeOutRight.hierNode.ancestor = subtreeV;\n      var shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim - sumInRight + separation(nodeInLeft, nodeInRight);\n      if (shift > 0) {\n        moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift);\n        sumInRight += shift;\n        sumOutRight += shift;\n      }\n      sumInLeft += nodeInLeft.hierNode.modifier;\n      sumInRight += nodeInRight.hierNode.modifier;\n      sumOutRight += nodeOutRight.hierNode.modifier;\n      sumOutLeft += nodeOutLeft.hierNode.modifier;\n    }\n    if (nodeInLeft && !nextRight(nodeOutRight)) {\n      nodeOutRight.hierNode.thread = nodeInLeft;\n      nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight;\n    }\n    if (nodeInRight && !nextLeft(nodeOutLeft)) {\n      nodeOutLeft.hierNode.thread = nodeInRight;\n      nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft;\n      ancestor = subtreeV;\n    }\n  }\n  return ancestor;\n}\n/**\r\n * This function is used to traverse the right contour of a subtree.\r\n * It returns the rightmost child of node or the thread of node. The function\r\n * returns null if and only if node is on the highest depth of its subtree.\r\n */\nfunction nextRight(node) {\n  var children = node.children;\n  return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread;\n}\n/**\r\n * This function is used to traverse the left contour of a subtree (or a subforest).\r\n * It returns the leftmost child of node or the thread of node. The function\r\n * returns null if and only if node is on the highest depth of its subtree.\r\n */\nfunction nextLeft(node) {\n  var children = node.children;\n  return children.length && node.isExpand ? children[0] : node.hierNode.thread;\n}\n/**\r\n * If nodeInLeft’s ancestor is a sibling of node, returns nodeInLeft’s ancestor.\r\n * Otherwise, returns the specified ancestor.\r\n */\nfunction nextAncestor(nodeInLeft, node, ancestor) {\n  return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode ? nodeInLeft.hierNode.ancestor : ancestor;\n}\n/**\r\n * The implementation of this function was originally copied from \"d3.js\"\r\n * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>\r\n * with some modifications made for this program.\r\n * See the license statement at the head of this file.\r\n *\r\n * Shifts the current subtree rooted at wr.\r\n * This is done by increasing prelim(w+) and modifier(w+) by shift.\r\n */\nfunction moveSubtree(wl, wr, shift) {\n  var change = shift / (wr.hierNode.i - wl.hierNode.i);\n  wr.hierNode.change -= change;\n  wr.hierNode.shift += shift;\n  wr.hierNode.modifier += shift;\n  wr.hierNode.prelim += shift;\n  wl.hierNode.change += change;\n}\n/**\r\n * The implementation of this function was originally copied from \"d3.js\"\r\n * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>\r\n * with some modifications made for this program.\r\n * See the license statement at the head of this file.\r\n */\nfunction defaultSeparation(node1, node2) {\n  return node1.parentNode === node2.parentNode ? 1 : 2;\n}\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/bbox.js\nvar bbox = __webpack_require__(48813);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/View.js\nvar View = __webpack_require__(56219);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/roamHelper.js\nvar roamHelper = __webpack_require__(56366);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/RoamController.js\nvar RoamController = __webpack_require__(81722);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/cursorHelper.js\nvar cursorHelper = __webpack_require__(72589);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Path.js\nvar Path = __webpack_require__(59482);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n;// ./node_modules/echarts/lib/chart/tree/TreeView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TreeEdgeShape = /** @class */function () {\n  function TreeEdgeShape() {\n    this.parentPoint = [];\n    this.childPoints = [];\n  }\n  return TreeEdgeShape;\n}();\nvar TreePath = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(TreePath, _super);\n  function TreePath(opts) {\n    return _super.call(this, opts) || this;\n  }\n  TreePath.prototype.getDefaultStyle = function () {\n    return {\n      stroke: '#000',\n      fill: null\n    };\n  };\n  TreePath.prototype.getDefaultShape = function () {\n    return new TreeEdgeShape();\n  };\n  TreePath.prototype.buildPath = function (ctx, shape) {\n    var childPoints = shape.childPoints;\n    var childLen = childPoints.length;\n    var parentPoint = shape.parentPoint;\n    var firstChildPos = childPoints[0];\n    var lastChildPos = childPoints[childLen - 1];\n    if (childLen === 1) {\n      ctx.moveTo(parentPoint[0], parentPoint[1]);\n      ctx.lineTo(firstChildPos[0], firstChildPos[1]);\n      return;\n    }\n    var orient = shape.orient;\n    var forkDim = orient === 'TB' || orient === 'BT' ? 0 : 1;\n    var otherDim = 1 - forkDim;\n    var forkPosition = (0,number/* parsePercent */.lo)(shape.forkPosition, 1);\n    var tmpPoint = [];\n    tmpPoint[forkDim] = parentPoint[forkDim];\n    tmpPoint[otherDim] = parentPoint[otherDim] + (lastChildPos[otherDim] - parentPoint[otherDim]) * forkPosition;\n    ctx.moveTo(parentPoint[0], parentPoint[1]);\n    ctx.lineTo(tmpPoint[0], tmpPoint[1]);\n    ctx.moveTo(firstChildPos[0], firstChildPos[1]);\n    tmpPoint[forkDim] = firstChildPos[forkDim];\n    ctx.lineTo(tmpPoint[0], tmpPoint[1]);\n    tmpPoint[forkDim] = lastChildPos[forkDim];\n    ctx.lineTo(tmpPoint[0], tmpPoint[1]);\n    ctx.lineTo(lastChildPos[0], lastChildPos[1]);\n    for (var i = 1; i < childLen - 1; i++) {\n      var point = childPoints[i];\n      ctx.moveTo(point[0], point[1]);\n      tmpPoint[forkDim] = point[forkDim];\n      ctx.lineTo(tmpPoint[0], tmpPoint[1]);\n    }\n  };\n  return TreePath;\n}(Path/* default */.Ay);\nvar TreeView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(TreeView, _super);\n  function TreeView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = TreeView.type;\n    _this._mainGroup = new Group/* default */.A();\n    return _this;\n  }\n  TreeView.prototype.init = function (ecModel, api) {\n    this._controller = new RoamController/* default */.A(api.getZr());\n    this._controllerHost = {\n      target: this.group\n    };\n    this.group.add(this._mainGroup);\n  };\n  TreeView.prototype.render = function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    var layoutInfo = seriesModel.layoutInfo;\n    var group = this._mainGroup;\n    var layout = seriesModel.get('layout');\n    if (layout === 'radial') {\n      group.x = layoutInfo.x + layoutInfo.width / 2;\n      group.y = layoutInfo.y + layoutInfo.height / 2;\n    } else {\n      group.x = layoutInfo.x;\n      group.y = layoutInfo.y;\n    }\n    this._updateViewCoordSys(seriesModel, api);\n    this._updateController(seriesModel, ecModel, api);\n    var oldData = this._data;\n    data.diff(oldData).add(function (newIdx) {\n      if (symbolNeedsDraw(data, newIdx)) {\n        // Create node and edge\n        updateNode(data, newIdx, null, group, seriesModel);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var symbolEl = oldData.getItemGraphicEl(oldIdx);\n      if (!symbolNeedsDraw(data, newIdx)) {\n        symbolEl && removeNode(oldData, oldIdx, symbolEl, group, seriesModel);\n        return;\n      }\n      // Update node and edge\n      updateNode(data, newIdx, symbolEl, group, seriesModel);\n    }).remove(function (oldIdx) {\n      var symbolEl = oldData.getItemGraphicEl(oldIdx);\n      // When remove a collapsed node of subtree, since the collapsed\n      // node haven't been initialized with a symbol element,\n      // you can't found it's symbol element through index.\n      // so if we want to remove the symbol element we should insure\n      // that the symbol element is not null.\n      if (symbolEl) {\n        removeNode(oldData, oldIdx, symbolEl, group, seriesModel);\n      }\n    }).execute();\n    this._nodeScaleRatio = seriesModel.get('nodeScaleRatio');\n    this._updateNodeAndLinkScale(seriesModel);\n    if (seriesModel.get('expandAndCollapse') === true) {\n      data.eachItemGraphicEl(function (el, dataIndex) {\n        el.off('click').on('click', function () {\n          api.dispatchAction({\n            type: 'treeExpandAndCollapse',\n            seriesId: seriesModel.id,\n            dataIndex: dataIndex\n          });\n        });\n      });\n    }\n    this._data = data;\n  };\n  TreeView.prototype._updateViewCoordSys = function (seriesModel, api) {\n    var data = seriesModel.getData();\n    var points = [];\n    data.each(function (idx) {\n      var layout = data.getItemLayout(idx);\n      if (layout && !isNaN(layout.x) && !isNaN(layout.y)) {\n        points.push([+layout.x, +layout.y]);\n      }\n    });\n    var min = [];\n    var max = [];\n    bbox/* fromPoints */.Cr(points, min, max);\n    // If don't Store min max when collapse the root node after roam,\n    // the root node will disappear.\n    var oldMin = this._min;\n    var oldMax = this._max;\n    // If width or height is 0\n    if (max[0] - min[0] === 0) {\n      min[0] = oldMin ? oldMin[0] : min[0] - 1;\n      max[0] = oldMax ? oldMax[0] : max[0] + 1;\n    }\n    if (max[1] - min[1] === 0) {\n      min[1] = oldMin ? oldMin[1] : min[1] - 1;\n      max[1] = oldMax ? oldMax[1] : max[1] + 1;\n    }\n    var viewCoordSys = seriesModel.coordinateSystem = new View/* default */.A();\n    viewCoordSys.zoomLimit = seriesModel.get('scaleLimit');\n    viewCoordSys.setBoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n    viewCoordSys.setCenter(seriesModel.get('center'), api);\n    viewCoordSys.setZoom(seriesModel.get('zoom'));\n    // Here we use viewCoordSys just for computing the 'position' and 'scale' of the group\n    this.group.attr({\n      x: viewCoordSys.x,\n      y: viewCoordSys.y,\n      scaleX: viewCoordSys.scaleX,\n      scaleY: viewCoordSys.scaleY\n    });\n    this._min = min;\n    this._max = max;\n  };\n  TreeView.prototype._updateController = function (seriesModel, ecModel, api) {\n    var _this = this;\n    var controller = this._controller;\n    var controllerHost = this._controllerHost;\n    var group = this.group;\n    controller.setPointerChecker(function (e, x, y) {\n      var rect = group.getBoundingRect();\n      rect.applyTransform(group.transform);\n      return rect.contain(x, y) && !(0,cursorHelper/* onIrrelevantElement */.I)(e, api, seriesModel);\n    });\n    controller.enable(seriesModel.get('roam'));\n    controllerHost.zoomLimit = seriesModel.get('scaleLimit');\n    controllerHost.zoom = seriesModel.coordinateSystem.getZoom();\n    controller.off('pan').off('zoom').on('pan', function (e) {\n      roamHelper/* updateViewOnPan */.t(controllerHost, e.dx, e.dy);\n      api.dispatchAction({\n        seriesId: seriesModel.id,\n        type: 'treeRoam',\n        dx: e.dx,\n        dy: e.dy\n      });\n    }).on('zoom', function (e) {\n      roamHelper/* updateViewOnZoom */.x(controllerHost, e.scale, e.originX, e.originY);\n      api.dispatchAction({\n        seriesId: seriesModel.id,\n        type: 'treeRoam',\n        zoom: e.scale,\n        originX: e.originX,\n        originY: e.originY\n      });\n      _this._updateNodeAndLinkScale(seriesModel);\n      // Only update label layout on zoom\n      api.updateLabelLayout();\n    });\n  };\n  TreeView.prototype._updateNodeAndLinkScale = function (seriesModel) {\n    var data = seriesModel.getData();\n    var nodeScale = this._getNodeGlobalScale(seriesModel);\n    data.eachItemGraphicEl(function (el, idx) {\n      el.setSymbolScale(nodeScale);\n    });\n  };\n  TreeView.prototype._getNodeGlobalScale = function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n    if (coordSys.type !== 'view') {\n      return 1;\n    }\n    var nodeScaleRatio = this._nodeScaleRatio;\n    var groupZoom = coordSys.scaleX || 1;\n    // Scale node when zoom changes\n    var roamZoom = coordSys.getZoom();\n    var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;\n    return nodeScale / groupZoom;\n  };\n  TreeView.prototype.dispose = function () {\n    this._controller && this._controller.dispose();\n    this._controllerHost = null;\n  };\n  TreeView.prototype.remove = function () {\n    this._mainGroup.removeAll();\n    this._data = null;\n  };\n  TreeView.type = 'tree';\n  return TreeView;\n}(Chart/* default */.A);\nfunction symbolNeedsDraw(data, dataIndex) {\n  var layout = data.getItemLayout(dataIndex);\n  return layout && !isNaN(layout.x) && !isNaN(layout.y);\n}\nfunction updateNode(data, dataIndex, symbolEl, group, seriesModel) {\n  var isInit = !symbolEl;\n  var node = data.tree.getNodeByDataIndex(dataIndex);\n  var itemModel = node.getModel();\n  var visualColor = node.getVisual('style').fill;\n  var symbolInnerColor = node.isExpand === false && node.children.length !== 0 ? visualColor : '#fff';\n  var virtualRoot = data.tree.root;\n  var source = node.parentNode === virtualRoot ? node : node.parentNode || node;\n  var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);\n  var sourceLayout = source.getLayout();\n  var sourceOldLayout = sourceSymbolEl ? {\n    x: sourceSymbolEl.__oldX,\n    y: sourceSymbolEl.__oldY,\n    rawX: sourceSymbolEl.__radialOldRawX,\n    rawY: sourceSymbolEl.__radialOldRawY\n  } : sourceLayout;\n  var targetLayout = node.getLayout();\n  if (isInit) {\n    symbolEl = new helper_Symbol/* default */.A(data, dataIndex, null, {\n      symbolInnerColor: symbolInnerColor,\n      useNameLabel: true\n    });\n    symbolEl.x = sourceOldLayout.x;\n    symbolEl.y = sourceOldLayout.y;\n  } else {\n    symbolEl.updateData(data, dataIndex, null, {\n      symbolInnerColor: symbolInnerColor,\n      useNameLabel: true\n    });\n  }\n  symbolEl.__radialOldRawX = symbolEl.__radialRawX;\n  symbolEl.__radialOldRawY = symbolEl.__radialRawY;\n  symbolEl.__radialRawX = targetLayout.rawX;\n  symbolEl.__radialRawY = targetLayout.rawY;\n  group.add(symbolEl);\n  data.setItemGraphicEl(dataIndex, symbolEl);\n  symbolEl.__oldX = symbolEl.x;\n  symbolEl.__oldY = symbolEl.y;\n  basicTransition/* updateProps */.oi(symbolEl, {\n    x: targetLayout.x,\n    y: targetLayout.y\n  }, seriesModel);\n  var symbolPath = symbolEl.getSymbolPath();\n  if (seriesModel.get('layout') === 'radial') {\n    var realRoot = virtualRoot.children[0];\n    var rootLayout = realRoot.getLayout();\n    var length_1 = realRoot.children.length;\n    var rad = void 0;\n    var isLeft = void 0;\n    if (targetLayout.x === rootLayout.x && node.isExpand === true && realRoot.children.length) {\n      var center = {\n        x: (realRoot.children[0].getLayout().x + realRoot.children[length_1 - 1].getLayout().x) / 2,\n        y: (realRoot.children[0].getLayout().y + realRoot.children[length_1 - 1].getLayout().y) / 2\n      };\n      rad = Math.atan2(center.y - rootLayout.y, center.x - rootLayout.x);\n      if (rad < 0) {\n        rad = Math.PI * 2 + rad;\n      }\n      isLeft = center.x < rootLayout.x;\n      if (isLeft) {\n        rad = rad - Math.PI;\n      }\n    } else {\n      rad = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);\n      if (rad < 0) {\n        rad = Math.PI * 2 + rad;\n      }\n      if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {\n        isLeft = targetLayout.x < rootLayout.x;\n        if (isLeft) {\n          rad = rad - Math.PI;\n        }\n      } else {\n        isLeft = targetLayout.x > rootLayout.x;\n        if (!isLeft) {\n          rad = rad - Math.PI;\n        }\n      }\n    }\n    var textPosition = isLeft ? 'left' : 'right';\n    var normalLabelModel = itemModel.getModel('label');\n    var rotate = normalLabelModel.get('rotate');\n    var labelRotateRadian = rotate * (Math.PI / 180);\n    var textContent = symbolPath.getTextContent();\n    if (textContent) {\n      symbolPath.setTextConfig({\n        position: normalLabelModel.get('position') || textPosition,\n        rotation: rotate == null ? -rad : labelRotateRadian,\n        origin: 'center'\n      });\n      textContent.setStyle('verticalAlign', 'middle');\n    }\n  }\n  // Handle status\n  var focus = itemModel.get(['emphasis', 'focus']);\n  var focusDataIndices = focus === 'relative' ? util.concatArray(node.getAncestorsIndices(), node.getDescendantIndices()) : focus === 'ancestor' ? node.getAncestorsIndices() : focus === 'descendant' ? node.getDescendantIndices() : null;\n  if (focusDataIndices) {\n    // Modify the focus to data indices.\n    (0,innerStore/* getECData */.z)(symbolEl).focus = focusDataIndices;\n  }\n  drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group);\n  if (symbolEl.__edge) {\n    symbolEl.onHoverStateChange = function (toState) {\n      if (toState !== 'blur') {\n        // NOTE: Ensure the parent elements will been blurred firstly.\n        // According to the return of getAncestorsIndices and getDescendantIndices\n        // TODO: A bit tricky.\n        var parentEl = node.parentNode && data.getItemGraphicEl(node.parentNode.dataIndex);\n        if (!(parentEl && parentEl.hoverState === states/* HOVER_STATE_BLUR */.zX)) {\n          (0,states/* setStatesFlag */.Pk)(symbolEl.__edge, toState);\n        }\n      }\n    };\n  }\n}\nfunction drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group) {\n  var itemModel = node.getModel();\n  var edgeShape = seriesModel.get('edgeShape');\n  var layout = seriesModel.get('layout');\n  var orient = seriesModel.getOrient();\n  var curvature = seriesModel.get(['lineStyle', 'curveness']);\n  var edgeForkPosition = seriesModel.get('edgeForkPosition');\n  var lineStyle = itemModel.getModel('lineStyle').getLineStyle();\n  var edge = symbolEl.__edge;\n  // curve edge from node -> parent\n  // polyline edge from node -> children\n  if (edgeShape === 'curve') {\n    if (node.parentNode && node.parentNode !== virtualRoot) {\n      if (!edge) {\n        edge = symbolEl.__edge = new BezierCurve/* default */.A({\n          shape: getEdgeShape(layout, orient, curvature, sourceOldLayout, sourceOldLayout)\n        });\n      }\n      basicTransition/* updateProps */.oi(edge, {\n        shape: getEdgeShape(layout, orient, curvature, sourceLayout, targetLayout)\n      }, seriesModel);\n    }\n  } else if (edgeShape === 'polyline') {\n    if (layout === 'orthogonal') {\n      if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {\n        var children = node.children;\n        var childPoints = [];\n        for (var i = 0; i < children.length; i++) {\n          var childLayout = children[i].getLayout();\n          childPoints.push([childLayout.x, childLayout.y]);\n        }\n        if (!edge) {\n          edge = symbolEl.__edge = new TreePath({\n            shape: {\n              parentPoint: [targetLayout.x, targetLayout.y],\n              childPoints: [[targetLayout.x, targetLayout.y]],\n              orient: orient,\n              forkPosition: edgeForkPosition\n            }\n          });\n        }\n        basicTransition/* updateProps */.oi(edge, {\n          shape: {\n            parentPoint: [targetLayout.x, targetLayout.y],\n            childPoints: childPoints\n          }\n        }, seriesModel);\n      }\n    } else {\n      if (false) {}\n    }\n  }\n  // show all edge when edgeShape is 'curve', filter node `isExpand` is false when edgeShape is 'polyline'\n  if (edge && !(edgeShape === 'polyline' && !node.isExpand)) {\n    edge.useStyle(util.defaults({\n      strokeNoScale: true,\n      fill: null\n    }, lineStyle));\n    (0,states/* setStatesStylesFromModel */.Mx)(edge, itemModel, 'lineStyle');\n    (0,states/* setDefaultStateProxy */.DW)(edge);\n    group.add(edge);\n  }\n}\nfunction removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt) {\n  var virtualRoot = data.tree.root;\n  var _a = getSourceNode(virtualRoot, node),\n    source = _a.source,\n    sourceLayout = _a.sourceLayout;\n  var symbolEl = data.getItemGraphicEl(node.dataIndex);\n  if (!symbolEl) {\n    return;\n  }\n  var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);\n  var sourceEdge = sourceSymbolEl.__edge;\n  // 1. when expand the sub tree, delete the children node should delete the edge of\n  // the source at the same time. because the polyline edge shape is only owned by the source.\n  // 2.when the node is the only children of the source, delete the node should delete the edge of\n  // the source at the same time. the same reason as above.\n  var edge = symbolEl.__edge || (source.isExpand === false || source.children.length === 1 ? sourceEdge : undefined);\n  var edgeShape = seriesModel.get('edgeShape');\n  var layoutOpt = seriesModel.get('layout');\n  var orient = seriesModel.get('orient');\n  var curvature = seriesModel.get(['lineStyle', 'curveness']);\n  if (edge) {\n    if (edgeShape === 'curve') {\n      basicTransition/* removeElement */.Nz(edge, {\n        shape: getEdgeShape(layoutOpt, orient, curvature, sourceLayout, sourceLayout),\n        style: {\n          opacity: 0\n        }\n      }, seriesModel, {\n        cb: function () {\n          group.remove(edge);\n        },\n        removeOpt: removeAnimationOpt\n      });\n    } else if (edgeShape === 'polyline' && seriesModel.get('layout') === 'orthogonal') {\n      basicTransition/* removeElement */.Nz(edge, {\n        shape: {\n          parentPoint: [sourceLayout.x, sourceLayout.y],\n          childPoints: [[sourceLayout.x, sourceLayout.y]]\n        },\n        style: {\n          opacity: 0\n        }\n      }, seriesModel, {\n        cb: function () {\n          group.remove(edge);\n        },\n        removeOpt: removeAnimationOpt\n      });\n    }\n  }\n}\nfunction getSourceNode(virtualRoot, node) {\n  var source = node.parentNode === virtualRoot ? node : node.parentNode || node;\n  var sourceLayout;\n  while (sourceLayout = source.getLayout(), sourceLayout == null) {\n    source = source.parentNode === virtualRoot ? source : source.parentNode || source;\n  }\n  return {\n    source: source,\n    sourceLayout: sourceLayout\n  };\n}\nfunction removeNode(data, dataIndex, symbolEl, group, seriesModel) {\n  var node = data.tree.getNodeByDataIndex(dataIndex);\n  var virtualRoot = data.tree.root;\n  var sourceLayout = getSourceNode(virtualRoot, node).sourceLayout;\n  // Use same duration and easing with update to have more consistent animation.\n  var removeAnimationOpt = {\n    duration: seriesModel.get('animationDurationUpdate'),\n    easing: seriesModel.get('animationEasingUpdate')\n  };\n  basicTransition/* removeElement */.Nz(symbolEl, {\n    x: sourceLayout.x + 1,\n    y: sourceLayout.y + 1\n  }, seriesModel, {\n    cb: function () {\n      group.remove(symbolEl);\n      data.setItemGraphicEl(dataIndex, null);\n    },\n    removeOpt: removeAnimationOpt\n  });\n  symbolEl.fadeOut(null, data.hostModel, {\n    fadeLabel: true,\n    animation: removeAnimationOpt\n  });\n  // remove edge as parent node\n  node.children.forEach(function (childNode) {\n    removeNodeEdge(childNode, data, group, seriesModel, removeAnimationOpt);\n  });\n  // remove edge as child node\n  removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt);\n}\nfunction getEdgeShape(layoutOpt, orient, curvature, sourceLayout, targetLayout) {\n  var cpx1;\n  var cpy1;\n  var cpx2;\n  var cpy2;\n  var x1;\n  var x2;\n  var y1;\n  var y2;\n  if (layoutOpt === 'radial') {\n    x1 = sourceLayout.rawX;\n    y1 = sourceLayout.rawY;\n    x2 = targetLayout.rawX;\n    y2 = targetLayout.rawY;\n    var radialCoor1 = radialCoordinate(x1, y1);\n    var radialCoor2 = radialCoordinate(x1, y1 + (y2 - y1) * curvature);\n    var radialCoor3 = radialCoordinate(x2, y2 + (y1 - y2) * curvature);\n    var radialCoor4 = radialCoordinate(x2, y2);\n    return {\n      x1: radialCoor1.x || 0,\n      y1: radialCoor1.y || 0,\n      x2: radialCoor4.x || 0,\n      y2: radialCoor4.y || 0,\n      cpx1: radialCoor2.x || 0,\n      cpy1: radialCoor2.y || 0,\n      cpx2: radialCoor3.x || 0,\n      cpy2: radialCoor3.y || 0\n    };\n  } else {\n    x1 = sourceLayout.x;\n    y1 = sourceLayout.y;\n    x2 = targetLayout.x;\n    y2 = targetLayout.y;\n    if (orient === 'LR' || orient === 'RL') {\n      cpx1 = x1 + (x2 - x1) * curvature;\n      cpy1 = y1;\n      cpx2 = x2 + (x1 - x2) * curvature;\n      cpy2 = y2;\n    }\n    if (orient === 'TB' || orient === 'BT') {\n      cpx1 = x1;\n      cpy1 = y1 + (y2 - y1) * curvature;\n      cpx2 = x2;\n      cpy2 = y2 + (y1 - y2) * curvature;\n    }\n  }\n  return {\n    x1: x1,\n    y1: y1,\n    x2: x2,\n    y2: y2,\n    cpx1: cpx1,\n    cpy1: cpy1,\n    cpx2: cpx2,\n    cpy2: cpy2\n  };\n}\n/* harmony default export */ const tree_TreeView = (TreeView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/Tree.js\nvar Tree = __webpack_require__(15719);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Model.js + 2 modules\nvar Model = __webpack_require__(43172);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js\nvar tooltipMarkup = __webpack_require__(3961);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/treeHelper.js\nvar treeHelper = __webpack_require__(41616);\n;// ./node_modules/echarts/lib/chart/tree/TreeSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\nvar TreeSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(TreeSeriesModel, _super);\n  function TreeSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.hasSymbolVisual = true;\n    // Do it self.\n    _this.ignoreStyleOnData = true;\n    return _this;\n  }\n  /**\r\n   * Init a tree data structure from data in option series\r\n   */\n  TreeSeriesModel.prototype.getInitialData = function (option) {\n    // create a virtual root\n    var root = {\n      name: option.name,\n      children: option.data\n    };\n    var leaves = option.leaves || {};\n    var leavesModel = new Model/* default */.A(leaves, this, this.ecModel);\n    var tree = Tree/* default */.A.createTree(root, this, beforeLink);\n    function beforeLink(nodeData) {\n      nodeData.wrapMethod('getItemModel', function (model, idx) {\n        var node = tree.getNodeByDataIndex(idx);\n        if (!(node && node.children.length && node.isExpand)) {\n          model.parentModel = leavesModel;\n        }\n        return model;\n      });\n    }\n    var treeDepth = 0;\n    tree.eachNode('preorder', function (node) {\n      if (node.depth > treeDepth) {\n        treeDepth = node.depth;\n      }\n    });\n    var expandAndCollapse = option.expandAndCollapse;\n    var expandTreeDepth = expandAndCollapse && option.initialTreeDepth >= 0 ? option.initialTreeDepth : treeDepth;\n    tree.root.eachNode('preorder', function (node) {\n      var item = node.hostTree.data.getRawDataItem(node.dataIndex);\n      // Add item.collapsed != null, because users can collapse node original in the series.data.\n      node.isExpand = item && item.collapsed != null ? !item.collapsed : node.depth <= expandTreeDepth;\n    });\n    return tree.data;\n  };\n  /**\r\n   * Make the configuration 'orient' backward compatibly, with 'horizontal = LR', 'vertical = TB'.\r\n   * @returns {string} orient\r\n   */\n  TreeSeriesModel.prototype.getOrient = function () {\n    var orient = this.get('orient');\n    if (orient === 'horizontal') {\n      orient = 'LR';\n    } else if (orient === 'vertical') {\n      orient = 'TB';\n    }\n    return orient;\n  };\n  TreeSeriesModel.prototype.setZoom = function (zoom) {\n    this.option.zoom = zoom;\n  };\n  TreeSeriesModel.prototype.setCenter = function (center) {\n    this.option.center = center;\n  };\n  TreeSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n    var tree = this.getData().tree;\n    var realRoot = tree.root.children[0];\n    var node = tree.getNodeByDataIndex(dataIndex);\n    var value = node.getValue();\n    var name = node.name;\n    while (node && node !== realRoot) {\n      name = node.parentNode.name + '.' + name;\n      node = node.parentNode;\n    }\n    return (0,tooltipMarkup/* createTooltipMarkup */.Qx)('nameValue', {\n      name: name,\n      value: value,\n      noValue: isNaN(value) || value == null\n    });\n  };\n  // Add tree path to tooltip param\n  TreeSeriesModel.prototype.getDataParams = function (dataIndex) {\n    var params = _super.prototype.getDataParams.apply(this, arguments);\n    var node = this.getData().tree.getNodeByDataIndex(dataIndex);\n    params.treeAncestors = (0,treeHelper/* wrapTreePathInfo */.ev)(node, this);\n    params.collapsed = !node.isExpand;\n    return params;\n  };\n  TreeSeriesModel.type = 'series.tree';\n  // can support the position parameters 'left', 'top','right','bottom', 'width',\n  // 'height' in the setOption() with 'merge' mode normal.\n  TreeSeriesModel.layoutMode = 'box';\n  TreeSeriesModel.defaultOption = {\n    // zlevel: 0,\n    z: 2,\n    coordinateSystem: 'view',\n    // the position of the whole view\n    left: '12%',\n    top: '12%',\n    right: '12%',\n    bottom: '12%',\n    // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'\n    layout: 'orthogonal',\n    // value can be 'polyline'\n    edgeShape: 'curve',\n    edgeForkPosition: '50%',\n    // true | false | 'move' | 'scale', see module:component/helper/RoamController.\n    roam: false,\n    // Symbol size scale ratio in roam\n    nodeScaleRatio: 0.4,\n    // Default on center of graph\n    center: null,\n    zoom: 1,\n    orient: 'LR',\n    symbol: 'emptyCircle',\n    symbolSize: 7,\n    expandAndCollapse: true,\n    initialTreeDepth: 2,\n    lineStyle: {\n      color: '#ccc',\n      width: 1.5,\n      curveness: 0.5\n    },\n    itemStyle: {\n      color: 'lightsteelblue',\n      // borderColor: '#c23531',\n      borderWidth: 1.5\n    },\n    label: {\n      show: true\n    },\n    animationEasing: 'linear',\n    animationDuration: 700,\n    animationDurationUpdate: 500\n  };\n  return TreeSeriesModel;\n}(Series/* default */.A);\n/* harmony default export */ const TreeSeries = (TreeSeriesModel);\n;// ./node_modules/echarts/lib/chart/tree/traversalHelper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * Traverse the tree from bottom to top and do something\r\n */\nfunction eachAfter(root, callback, separation) {\n  var nodes = [root];\n  var next = [];\n  var node;\n  while (node = nodes.pop()) {\n    // jshint ignore:line\n    next.push(node);\n    if (node.isExpand) {\n      var children = node.children;\n      if (children.length) {\n        for (var i = 0; i < children.length; i++) {\n          nodes.push(children[i]);\n        }\n      }\n    }\n  }\n  while (node = next.pop()) {\n    // jshint ignore:line\n    callback(node, separation);\n  }\n}\n/**\r\n * Traverse the tree from top to bottom and do something\r\n */\nfunction eachBefore(root, callback) {\n  var nodes = [root];\n  var node;\n  while (node = nodes.pop()) {\n    // jshint ignore:line\n    callback(node);\n    if (node.isExpand) {\n      var children = node.children;\n      if (children.length) {\n        for (var i = children.length - 1; i >= 0; i--) {\n          nodes.push(children[i]);\n        }\n      }\n    }\n  }\n}\n\n;// ./node_modules/echarts/lib/chart/tree/treeLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction treeLayout(ecModel, api) {\n  ecModel.eachSeriesByType('tree', function (seriesModel) {\n    commonLayout(seriesModel, api);\n  });\n}\nfunction commonLayout(seriesModel, api) {\n  var layoutInfo = getViewRect(seriesModel, api);\n  seriesModel.layoutInfo = layoutInfo;\n  var layout = seriesModel.get('layout');\n  var width = 0;\n  var height = 0;\n  var separation = null;\n  if (layout === 'radial') {\n    width = 2 * Math.PI;\n    height = Math.min(layoutInfo.height, layoutInfo.width) / 2;\n    separation = layoutHelper_separation(function (node1, node2) {\n      return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth;\n    });\n  } else {\n    width = layoutInfo.width;\n    height = layoutInfo.height;\n    separation = layoutHelper_separation();\n  }\n  var virtualRoot = seriesModel.getData().tree.root;\n  var realRoot = virtualRoot.children[0];\n  if (realRoot) {\n    init(virtualRoot);\n    eachAfter(realRoot, firstWalk, separation);\n    virtualRoot.hierNode.modifier = -realRoot.hierNode.prelim;\n    eachBefore(realRoot, secondWalk);\n    var left_1 = realRoot;\n    var right_1 = realRoot;\n    var bottom_1 = realRoot;\n    eachBefore(realRoot, function (node) {\n      var x = node.getLayout().x;\n      if (x < left_1.getLayout().x) {\n        left_1 = node;\n      }\n      if (x > right_1.getLayout().x) {\n        right_1 = node;\n      }\n      if (node.depth > bottom_1.depth) {\n        bottom_1 = node;\n      }\n    });\n    var delta = left_1 === right_1 ? 1 : separation(left_1, right_1) / 2;\n    var tx_1 = delta - left_1.getLayout().x;\n    var kx_1 = 0;\n    var ky_1 = 0;\n    var coorX_1 = 0;\n    var coorY_1 = 0;\n    if (layout === 'radial') {\n      kx_1 = width / (right_1.getLayout().x + delta + tx_1);\n      // here we use (node.depth - 1), bucause the real root's depth is 1\n      ky_1 = height / (bottom_1.depth - 1 || 1);\n      eachBefore(realRoot, function (node) {\n        coorX_1 = (node.getLayout().x + tx_1) * kx_1;\n        coorY_1 = (node.depth - 1) * ky_1;\n        var finalCoor = radialCoordinate(coorX_1, coorY_1);\n        node.setLayout({\n          x: finalCoor.x,\n          y: finalCoor.y,\n          rawX: coorX_1,\n          rawY: coorY_1\n        }, true);\n      });\n    } else {\n      var orient_1 = seriesModel.getOrient();\n      if (orient_1 === 'RL' || orient_1 === 'LR') {\n        ky_1 = height / (right_1.getLayout().x + delta + tx_1);\n        kx_1 = width / (bottom_1.depth - 1 || 1);\n        eachBefore(realRoot, function (node) {\n          coorY_1 = (node.getLayout().x + tx_1) * ky_1;\n          coorX_1 = orient_1 === 'LR' ? (node.depth - 1) * kx_1 : width - (node.depth - 1) * kx_1;\n          node.setLayout({\n            x: coorX_1,\n            y: coorY_1\n          }, true);\n        });\n      } else if (orient_1 === 'TB' || orient_1 === 'BT') {\n        kx_1 = width / (right_1.getLayout().x + delta + tx_1);\n        ky_1 = height / (bottom_1.depth - 1 || 1);\n        eachBefore(realRoot, function (node) {\n          coorX_1 = (node.getLayout().x + tx_1) * kx_1;\n          coorY_1 = orient_1 === 'TB' ? (node.depth - 1) * ky_1 : height - (node.depth - 1) * ky_1;\n          node.setLayout({\n            x: coorX_1,\n            y: coorY_1\n          }, true);\n        });\n      }\n    }\n  }\n}\n;// ./node_modules/echarts/lib/chart/tree/treeVisual.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction treeVisual(ecModel) {\n  ecModel.eachSeriesByType('tree', function (seriesModel) {\n    var data = seriesModel.getData();\n    var tree = data.tree;\n    tree.eachNode(function (node) {\n      var model = node.getModel();\n      // TODO Optimize\n      var style = model.getModel('itemStyle').getItemStyle();\n      var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, 'style');\n      (0,util.extend)(existsStyle, style);\n    });\n  });\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/action/roamHelper.js\nvar action_roamHelper = __webpack_require__(78536);\n;// ./node_modules/echarts/lib/chart/tree/treeAction.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction installTreeAction(registers) {\n  registers.registerAction({\n    type: 'treeExpandAndCollapse',\n    event: 'treeExpandAndCollapse',\n    update: 'update'\n  }, function (payload, ecModel) {\n    ecModel.eachComponent({\n      mainType: 'series',\n      subType: 'tree',\n      query: payload\n    }, function (seriesModel) {\n      var dataIndex = payload.dataIndex;\n      var tree = seriesModel.getData().tree;\n      var node = tree.getNodeByDataIndex(dataIndex);\n      node.isExpand = !node.isExpand;\n    });\n  });\n  registers.registerAction({\n    type: 'treeRoam',\n    event: 'treeRoam',\n    // Here we set 'none' instead of 'update', because roam action\n    // just need to update the transform matrix without having to recalculate\n    // the layout. So don't need to go through the whole update process, such\n    // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.\n    update: 'none'\n  }, function (payload, ecModel, api) {\n    ecModel.eachComponent({\n      mainType: 'series',\n      subType: 'tree',\n      query: payload\n    }, function (seriesModel) {\n      var coordSys = seriesModel.coordinateSystem;\n      var res = (0,action_roamHelper/* updateCenterAndZoom */.f)(coordSys, payload, undefined, api);\n      seriesModel.setCenter && seriesModel.setCenter(res.center);\n      seriesModel.setZoom && seriesModel.setZoom(res.zoom);\n    });\n  });\n}\n;// ./node_modules/echarts/lib/chart/tree/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nfunction install(registers) {\n  registers.registerChartView(tree_TreeView);\n  registers.registerSeriesModel(TreeSeries);\n  registers.registerLayout(treeLayout);\n  registers.registerVisual(treeVisual);\n  installTreeAction(registers);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE0NDEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzdtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC90cmVlL2xheW91dEhlbHBlci5qcz82ZmI4Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC90cmVlL1RyZWVWaWV3LmpzP2I1ZTIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3RyZWUvVHJlZVNlcmllcy5qcz8zOWYzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC90cmVlL3RyYXZlcnNhbEhlbHBlci5qcz80N2U2Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC90cmVlL3RyZWVMYXlvdXQuanM/ZGU1OSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvdHJlZS90cmVlVmlzdWFsLmpzPzk5YWQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3RyZWUvdHJlZUFjdGlvbi5qcz85Nzk4Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC90cmVlL2luc3RhbGwuanM/MmE1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbi8qXHJcbiogQSB0aGlyZC1wYXJ0eSBsaWNlbnNlIGlzIGVtYmVkZGVkIGZvciBzb21lIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZTpcclxuKiBUaGUgdHJlZSBsYXlvdXRIZWxwZXIgaW1wbGVtZW50YXRpb24gd2FzIG9yaWdpbmFsbHkgY29waWVkIGZyb21cclxuKiBcImQzLmpzXCIoaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWhpZXJhcmNoeSkgd2l0aFxyXG4qIHNvbWUgbW9kaWZpY2F0aW9ucyBtYWRlIGZvciB0aGlzIHByb2plY3QuXHJcbiogKHNlZSBtb3JlIGRldGFpbHMgaW4gdGhlIGNvbW1lbnQgb2YgdGhlIHNwZWNpZmljIG1ldGhvZCBiZWxvdy4pXHJcbiogVGhlIHVzZSBvZiB0aGUgc291cmNlIGNvZGUgb2YgdGhpcyBmaWxlIGlzIGFsc28gc3ViamVjdCB0byB0aGUgdGVybXNcclxuKiBhbmQgY29uc2l0aW9ucyBvZiB0aGUgbGljZW5jZSBvZiBcImQzLmpzXCIgKEJTRC0zQ2xhdXNlLCBzZWVcclxuKiA8L2xpY2Vuc2VzL0xJQ0VOU0UtZDM+KS5cclxuKi9cbi8qKlxyXG4gKiBAZmlsZSBUaGUgbGF5b3V0IGFsZ29yaXRobSBvZiBub2RlLWxpbmsgdHJlZSBkaWFncmFtcy4gSGVyZSB3ZSB1c2luZyBSZWluZ29sZC1UaWxmb3JkIGFsZ29yaXRobSB0byBkcmF3aW5nXHJcbiAqICAgICAgIHRoZSB0cmVlLlxyXG4gKi9cbmltcG9ydCAqIGFzIGxheW91dCBmcm9tICcuLi8uLi91dGlsL2xheW91dC5qcyc7XG4vKipcclxuICogSW5pdGlhbGl6ZSBhbGwgY29tcHV0YXRpb25hbCBtZXNzYWdlIGZvciBmb2xsb3dpbmcgYWxnb3JpdGhtLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0KGluUm9vdCkge1xuICB2YXIgcm9vdCA9IGluUm9vdDtcbiAgcm9vdC5oaWVyTm9kZSA9IHtcbiAgICBkZWZhdWx0QW5jZXN0b3I6IG51bGwsXG4gICAgYW5jZXN0b3I6IHJvb3QsXG4gICAgcHJlbGltOiAwLFxuICAgIG1vZGlmaWVyOiAwLFxuICAgIGNoYW5nZTogMCxcbiAgICBzaGlmdDogMCxcbiAgICBpOiAwLFxuICAgIHRocmVhZDogbnVsbFxuICB9O1xuICB2YXIgbm9kZXMgPSBbcm9vdF07XG4gIHZhciBub2RlO1xuICB2YXIgY2hpbGRyZW47XG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgaWYgKG5vZGUuaXNFeHBhbmQgJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSBuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGNoaWxkLmhpZXJOb2RlID0ge1xuICAgICAgICAgIGRlZmF1bHRBbmNlc3RvcjogbnVsbCxcbiAgICAgICAgICBhbmNlc3RvcjogY2hpbGQsXG4gICAgICAgICAgcHJlbGltOiAwLFxuICAgICAgICAgIG1vZGlmaWVyOiAwLFxuICAgICAgICAgIGNoYW5nZTogMCxcbiAgICAgICAgICBzaGlmdDogMCxcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIHRocmVhZDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBub2Rlcy5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxyXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiB3YXMgb3JpZ2luYWxseSBjb3BpZWQgZnJvbSBcImQzLmpzXCJcclxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1oaWVyYXJjaHkvYmxvYi80YzFmMDM4ZjI3MjVkNmVhZTJlNDliNjFkMDE0NTY0MDA2OTRiYWM0L3NyYy90cmVlLmpzPlxyXG4gKiB3aXRoIHNvbWUgbW9kaWZpY2F0aW9ucyBtYWRlIGZvciB0aGlzIHByb2dyYW0uXHJcbiAqIFNlZSB0aGUgbGljZW5zZSBzdGF0ZW1lbnQgYXQgdGhlIGhlYWQgb2YgdGhpcyBmaWxlLlxyXG4gKlxyXG4gKiBDb21wdXRlcyBhIHByZWxpbWluYXJ5IHggY29vcmRpbmF0ZSBmb3Igbm9kZS4gQmVmb3JlIHRoYXQsIHRoaXMgZnVuY3Rpb24gaXNcclxuICogYXBwbGllZCByZWN1cnNpdmVseSB0byB0aGUgY2hpbGRyZW4gb2Ygbm9kZSwgYXMgd2VsbCBhcyB0aGUgZnVuY3Rpb25cclxuICogYXBwb3J0aW9uKCkuIEFmdGVyIHNwYWNpbmcgb3V0IHRoZSBjaGlsZHJlbiBieSBjYWxsaW5nIGV4ZWN1dGVTaGlmdHMoKSwgdGhlXHJcbiAqIG5vZGUgaXMgcGxhY2VkIHRvIHRoZSBtaWRwb2ludCBvZiBpdHMgb3V0ZXJtb3N0IGNoaWxkcmVuLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdFdhbGsobm9kZSwgc2VwYXJhdGlvbikge1xuICB2YXIgY2hpbGRyZW4gPSBub2RlLmlzRXhwYW5kID8gbm9kZS5jaGlsZHJlbiA6IFtdO1xuICB2YXIgc2libGluZ3MgPSBub2RlLnBhcmVudE5vZGUuY2hpbGRyZW47XG4gIHZhciBzdWJ0cmVlVyA9IG5vZGUuaGllck5vZGUuaSA/IHNpYmxpbmdzW25vZGUuaGllck5vZGUuaSAtIDFdIDogbnVsbDtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGV4ZWN1dGVTaGlmdHMobm9kZSk7XG4gICAgdmFyIG1pZFBvaW50ID0gKGNoaWxkcmVuWzBdLmhpZXJOb2RlLnByZWxpbSArIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLmhpZXJOb2RlLnByZWxpbSkgLyAyO1xuICAgIGlmIChzdWJ0cmVlVykge1xuICAgICAgbm9kZS5oaWVyTm9kZS5wcmVsaW0gPSBzdWJ0cmVlVy5oaWVyTm9kZS5wcmVsaW0gKyBzZXBhcmF0aW9uKG5vZGUsIHN1YnRyZWVXKTtcbiAgICAgIG5vZGUuaGllck5vZGUubW9kaWZpZXIgPSBub2RlLmhpZXJOb2RlLnByZWxpbSAtIG1pZFBvaW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmhpZXJOb2RlLnByZWxpbSA9IG1pZFBvaW50O1xuICAgIH1cbiAgfSBlbHNlIGlmIChzdWJ0cmVlVykge1xuICAgIG5vZGUuaGllck5vZGUucHJlbGltID0gc3VidHJlZVcuaGllck5vZGUucHJlbGltICsgc2VwYXJhdGlvbihub2RlLCBzdWJ0cmVlVyk7XG4gIH1cbiAgbm9kZS5wYXJlbnROb2RlLmhpZXJOb2RlLmRlZmF1bHRBbmNlc3RvciA9IGFwcG9ydGlvbihub2RlLCBzdWJ0cmVlVywgbm9kZS5wYXJlbnROb2RlLmhpZXJOb2RlLmRlZmF1bHRBbmNlc3RvciB8fCBzaWJsaW5nc1swXSwgc2VwYXJhdGlvbik7XG59XG4vKipcclxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gd2FzIG9yaWdpbmFsbHkgY29waWVkIGZyb20gXCJkMy5qc1wiXHJcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtaGllcmFyY2h5L2Jsb2IvNGMxZjAzOGYyNzI1ZDZlYWUyZTQ5YjYxZDAxNDU2NDAwNjk0YmFjNC9zcmMvdHJlZS5qcz5cclxuICogd2l0aCBzb21lIG1vZGlmaWNhdGlvbnMgbWFkZSBmb3IgdGhpcyBwcm9ncmFtLlxyXG4gKiBTZWUgdGhlIGxpY2Vuc2Ugc3RhdGVtZW50IGF0IHRoZSBoZWFkIG9mIHRoaXMgZmlsZS5cclxuICpcclxuICogQ29tcHV0ZXMgYWxsIHJlYWwgeC1jb29yZGluYXRlcyBieSBzdW1taW5nIHVwIHRoZSBtb2RpZmllcnMgcmVjdXJzaXZlbHkuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlY29uZFdhbGsobm9kZSkge1xuICB2YXIgbm9kZVggPSBub2RlLmhpZXJOb2RlLnByZWxpbSArIG5vZGUucGFyZW50Tm9kZS5oaWVyTm9kZS5tb2RpZmllcjtcbiAgbm9kZS5zZXRMYXlvdXQoe1xuICAgIHg6IG5vZGVYXG4gIH0sIHRydWUpO1xuICBub2RlLmhpZXJOb2RlLm1vZGlmaWVyICs9IG5vZGUucGFyZW50Tm9kZS5oaWVyTm9kZS5tb2RpZmllcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXBhcmF0aW9uKGNiKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gY2IgOiBkZWZhdWx0U2VwYXJhdGlvbjtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm0gdGhlIGNvbW1vbiBjb29yZGluYXRlIHRvIHJhZGlhbCBjb29yZGluYXRlLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYWRpYWxDb29yZGluYXRlKHJhZCwgcikge1xuICByYWQgLT0gTWF0aC5QSSAvIDI7XG4gIHJldHVybiB7XG4gICAgeDogciAqIE1hdGguY29zKHJhZCksXG4gICAgeTogciAqIE1hdGguc2luKHJhZClcbiAgfTtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIGxheW91dCBwb3NpdGlvbiBvZiB0aGUgd2hvbGUgdmlldy5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Vmlld1JlY3Qoc2VyaWVzTW9kZWwsIGFwaSkge1xuICByZXR1cm4gbGF5b3V0LmdldExheW91dFJlY3Qoc2VyaWVzTW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCksIHtcbiAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgfSk7XG59XG4vKipcclxuICogQWxsIG90aGVyIHNoaWZ0cywgYXBwbGllZCB0byB0aGUgc21hbGxlciBzdWJ0cmVlcyBiZXR3ZWVuIHctIGFuZCB3KywgYXJlXHJcbiAqIHBlcmZvcm1lZCBieSB0aGlzIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiB3YXMgb3JpZ2luYWxseSBjb3BpZWQgZnJvbSBcImQzLmpzXCJcclxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1oaWVyYXJjaHkvYmxvYi80YzFmMDM4ZjI3MjVkNmVhZTJlNDliNjFkMDE0NTY0MDA2OTRiYWM0L3NyYy90cmVlLmpzPlxyXG4gKiB3aXRoIHNvbWUgbW9kaWZpY2F0aW9ucyBtYWRlIGZvciB0aGlzIHByb2dyYW0uXHJcbiAqIFNlZSB0aGUgbGljZW5zZSBzdGF0ZW1lbnQgYXQgdGhlIGhlYWQgb2YgdGhpcyBmaWxlLlxyXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVTaGlmdHMobm9kZSkge1xuICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICB2YXIgbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgdmFyIHNoaWZ0ID0gMDtcbiAgdmFyIGNoYW5nZSA9IDA7XG4gIHdoaWxlICgtLW4gPj0gMCkge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW25dO1xuICAgIGNoaWxkLmhpZXJOb2RlLnByZWxpbSArPSBzaGlmdDtcbiAgICBjaGlsZC5oaWVyTm9kZS5tb2RpZmllciArPSBzaGlmdDtcbiAgICBjaGFuZ2UgKz0gY2hpbGQuaGllck5vZGUuY2hhbmdlO1xuICAgIHNoaWZ0ICs9IGNoaWxkLmhpZXJOb2RlLnNoaWZ0ICsgY2hhbmdlO1xuICB9XG59XG4vKipcclxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gd2FzIG9yaWdpbmFsbHkgY29waWVkIGZyb20gXCJkMy5qc1wiXHJcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtaGllcmFyY2h5L2Jsb2IvNGMxZjAzOGYyNzI1ZDZlYWUyZTQ5YjYxZDAxNDU2NDAwNjk0YmFjNC9zcmMvdHJlZS5qcz5cclxuICogd2l0aCBzb21lIG1vZGlmaWNhdGlvbnMgbWFkZSBmb3IgdGhpcyBwcm9ncmFtLlxyXG4gKiBTZWUgdGhlIGxpY2Vuc2Ugc3RhdGVtZW50IGF0IHRoZSBoZWFkIG9mIHRoaXMgZmlsZS5cclxuICpcclxuICogVGhlIGNvcmUgb2YgdGhlIGFsZ29yaXRobS4gSGVyZSwgYSBuZXcgc3VidHJlZSBpcyBjb21iaW5lZCB3aXRoIHRoZVxyXG4gKiBwcmV2aW91cyBzdWJ0cmVlcy4gVGhyZWFkcyBhcmUgdXNlZCB0byB0cmF2ZXJzZSB0aGUgaW5zaWRlIGFuZCBvdXRzaWRlXHJcbiAqIGNvbnRvdXJzIG9mIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlIHVwIHRvIHRoZSBoaWdoZXN0IGNvbW1vbiBsZXZlbC5cclxuICogV2hlbmV2ZXIgdHdvIG5vZGVzIG9mIHRoZSBpbnNpZGUgY29udG91cnMgY29uZmxpY3QsIHdlIGNvbXB1dGUgdGhlIGxlZnRcclxuICogb25lIG9mIHRoZSBncmVhdGVzdCB1bmNvbW1vbiBhbmNlc3RvcnMgdXNpbmcgdGhlIGZ1bmN0aW9uIG5leHRBbmNlc3RvcigpXHJcbiAqIGFuZCBjYWxsIG1vdmVTdWJ0cmVlKCkgdG8gc2hpZnQgdGhlIHN1YnRyZWUgYW5kIHByZXBhcmUgdGhlIHNoaWZ0cyBvZlxyXG4gKiBzbWFsbGVyIHN1YnRyZWVzLiBGaW5hbGx5LCB3ZSBhZGQgYSBuZXcgdGhyZWFkIChpZiBuZWNlc3NhcnkpLlxyXG4gKi9cbmZ1bmN0aW9uIGFwcG9ydGlvbihzdWJ0cmVlViwgc3VidHJlZVcsIGFuY2VzdG9yLCBzZXBhcmF0aW9uKSB7XG4gIGlmIChzdWJ0cmVlVykge1xuICAgIHZhciBub2RlT3V0UmlnaHQgPSBzdWJ0cmVlVjtcbiAgICB2YXIgbm9kZUluUmlnaHQgPSBzdWJ0cmVlVjtcbiAgICB2YXIgbm9kZU91dExlZnQgPSBub2RlSW5SaWdodC5wYXJlbnROb2RlLmNoaWxkcmVuWzBdO1xuICAgIHZhciBub2RlSW5MZWZ0ID0gc3VidHJlZVc7XG4gICAgdmFyIHN1bU91dFJpZ2h0ID0gbm9kZU91dFJpZ2h0LmhpZXJOb2RlLm1vZGlmaWVyO1xuICAgIHZhciBzdW1JblJpZ2h0ID0gbm9kZUluUmlnaHQuaGllck5vZGUubW9kaWZpZXI7XG4gICAgdmFyIHN1bU91dExlZnQgPSBub2RlT3V0TGVmdC5oaWVyTm9kZS5tb2RpZmllcjtcbiAgICB2YXIgc3VtSW5MZWZ0ID0gbm9kZUluTGVmdC5oaWVyTm9kZS5tb2RpZmllcjtcbiAgICB3aGlsZSAobm9kZUluTGVmdCA9IG5leHRSaWdodChub2RlSW5MZWZ0KSwgbm9kZUluUmlnaHQgPSBuZXh0TGVmdChub2RlSW5SaWdodCksIG5vZGVJbkxlZnQgJiYgbm9kZUluUmlnaHQpIHtcbiAgICAgIG5vZGVPdXRSaWdodCA9IG5leHRSaWdodChub2RlT3V0UmlnaHQpO1xuICAgICAgbm9kZU91dExlZnQgPSBuZXh0TGVmdChub2RlT3V0TGVmdCk7XG4gICAgICBub2RlT3V0UmlnaHQuaGllck5vZGUuYW5jZXN0b3IgPSBzdWJ0cmVlVjtcbiAgICAgIHZhciBzaGlmdCA9IG5vZGVJbkxlZnQuaGllck5vZGUucHJlbGltICsgc3VtSW5MZWZ0IC0gbm9kZUluUmlnaHQuaGllck5vZGUucHJlbGltIC0gc3VtSW5SaWdodCArIHNlcGFyYXRpb24obm9kZUluTGVmdCwgbm9kZUluUmlnaHQpO1xuICAgICAgaWYgKHNoaWZ0ID4gMCkge1xuICAgICAgICBtb3ZlU3VidHJlZShuZXh0QW5jZXN0b3Iobm9kZUluTGVmdCwgc3VidHJlZVYsIGFuY2VzdG9yKSwgc3VidHJlZVYsIHNoaWZ0KTtcbiAgICAgICAgc3VtSW5SaWdodCArPSBzaGlmdDtcbiAgICAgICAgc3VtT3V0UmlnaHQgKz0gc2hpZnQ7XG4gICAgICB9XG4gICAgICBzdW1JbkxlZnQgKz0gbm9kZUluTGVmdC5oaWVyTm9kZS5tb2RpZmllcjtcbiAgICAgIHN1bUluUmlnaHQgKz0gbm9kZUluUmlnaHQuaGllck5vZGUubW9kaWZpZXI7XG4gICAgICBzdW1PdXRSaWdodCArPSBub2RlT3V0UmlnaHQuaGllck5vZGUubW9kaWZpZXI7XG4gICAgICBzdW1PdXRMZWZ0ICs9IG5vZGVPdXRMZWZ0LmhpZXJOb2RlLm1vZGlmaWVyO1xuICAgIH1cbiAgICBpZiAobm9kZUluTGVmdCAmJiAhbmV4dFJpZ2h0KG5vZGVPdXRSaWdodCkpIHtcbiAgICAgIG5vZGVPdXRSaWdodC5oaWVyTm9kZS50aHJlYWQgPSBub2RlSW5MZWZ0O1xuICAgICAgbm9kZU91dFJpZ2h0LmhpZXJOb2RlLm1vZGlmaWVyICs9IHN1bUluTGVmdCAtIHN1bU91dFJpZ2h0O1xuICAgIH1cbiAgICBpZiAobm9kZUluUmlnaHQgJiYgIW5leHRMZWZ0KG5vZGVPdXRMZWZ0KSkge1xuICAgICAgbm9kZU91dExlZnQuaGllck5vZGUudGhyZWFkID0gbm9kZUluUmlnaHQ7XG4gICAgICBub2RlT3V0TGVmdC5oaWVyTm9kZS5tb2RpZmllciArPSBzdW1JblJpZ2h0IC0gc3VtT3V0TGVmdDtcbiAgICAgIGFuY2VzdG9yID0gc3VidHJlZVY7XG4gICAgfVxuICB9XG4gIHJldHVybiBhbmNlc3Rvcjtcbn1cbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gdHJhdmVyc2UgdGhlIHJpZ2h0IGNvbnRvdXIgb2YgYSBzdWJ0cmVlLlxyXG4gKiBJdCByZXR1cm5zIHRoZSByaWdodG1vc3QgY2hpbGQgb2Ygbm9kZSBvciB0aGUgdGhyZWFkIG9mIG5vZGUuIFRoZSBmdW5jdGlvblxyXG4gKiByZXR1cm5zIG51bGwgaWYgYW5kIG9ubHkgaWYgbm9kZSBpcyBvbiB0aGUgaGlnaGVzdCBkZXB0aCBvZiBpdHMgc3VidHJlZS5cclxuICovXG5mdW5jdGlvbiBuZXh0UmlnaHQobm9kZSkge1xuICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICByZXR1cm4gY2hpbGRyZW4ubGVuZ3RoICYmIG5vZGUuaXNFeHBhbmQgPyBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSA6IG5vZGUuaGllck5vZGUudGhyZWFkO1xufVxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB0cmF2ZXJzZSB0aGUgbGVmdCBjb250b3VyIG9mIGEgc3VidHJlZSAob3IgYSBzdWJmb3Jlc3QpLlxyXG4gKiBJdCByZXR1cm5zIHRoZSBsZWZ0bW9zdCBjaGlsZCBvZiBub2RlIG9yIHRoZSB0aHJlYWQgb2Ygbm9kZS4gVGhlIGZ1bmN0aW9uXHJcbiAqIHJldHVybnMgbnVsbCBpZiBhbmQgb25seSBpZiBub2RlIGlzIG9uIHRoZSBoaWdoZXN0IGRlcHRoIG9mIGl0cyBzdWJ0cmVlLlxyXG4gKi9cbmZ1bmN0aW9uIG5leHRMZWZ0KG5vZGUpIHtcbiAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCAmJiBub2RlLmlzRXhwYW5kID8gY2hpbGRyZW5bMF0gOiBub2RlLmhpZXJOb2RlLnRocmVhZDtcbn1cbi8qKlxyXG4gKiBJZiBub2RlSW5MZWZ04oCZcyBhbmNlc3RvciBpcyBhIHNpYmxpbmcgb2Ygbm9kZSwgcmV0dXJucyBub2RlSW5MZWZ04oCZcyBhbmNlc3Rvci5cclxuICogT3RoZXJ3aXNlLCByZXR1cm5zIHRoZSBzcGVjaWZpZWQgYW5jZXN0b3IuXHJcbiAqL1xuZnVuY3Rpb24gbmV4dEFuY2VzdG9yKG5vZGVJbkxlZnQsIG5vZGUsIGFuY2VzdG9yKSB7XG4gIHJldHVybiBub2RlSW5MZWZ0LmhpZXJOb2RlLmFuY2VzdG9yLnBhcmVudE5vZGUgPT09IG5vZGUucGFyZW50Tm9kZSA/IG5vZGVJbkxlZnQuaGllck5vZGUuYW5jZXN0b3IgOiBhbmNlc3Rvcjtcbn1cbi8qKlxyXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiB3YXMgb3JpZ2luYWxseSBjb3BpZWQgZnJvbSBcImQzLmpzXCJcclxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1oaWVyYXJjaHkvYmxvYi80YzFmMDM4ZjI3MjVkNmVhZTJlNDliNjFkMDE0NTY0MDA2OTRiYWM0L3NyYy90cmVlLmpzPlxyXG4gKiB3aXRoIHNvbWUgbW9kaWZpY2F0aW9ucyBtYWRlIGZvciB0aGlzIHByb2dyYW0uXHJcbiAqIFNlZSB0aGUgbGljZW5zZSBzdGF0ZW1lbnQgYXQgdGhlIGhlYWQgb2YgdGhpcyBmaWxlLlxyXG4gKlxyXG4gKiBTaGlmdHMgdGhlIGN1cnJlbnQgc3VidHJlZSByb290ZWQgYXQgd3IuXHJcbiAqIFRoaXMgaXMgZG9uZSBieSBpbmNyZWFzaW5nIHByZWxpbSh3KykgYW5kIG1vZGlmaWVyKHcrKSBieSBzaGlmdC5cclxuICovXG5mdW5jdGlvbiBtb3ZlU3VidHJlZSh3bCwgd3IsIHNoaWZ0KSB7XG4gIHZhciBjaGFuZ2UgPSBzaGlmdCAvICh3ci5oaWVyTm9kZS5pIC0gd2wuaGllck5vZGUuaSk7XG4gIHdyLmhpZXJOb2RlLmNoYW5nZSAtPSBjaGFuZ2U7XG4gIHdyLmhpZXJOb2RlLnNoaWZ0ICs9IHNoaWZ0O1xuICB3ci5oaWVyTm9kZS5tb2RpZmllciArPSBzaGlmdDtcbiAgd3IuaGllck5vZGUucHJlbGltICs9IHNoaWZ0O1xuICB3bC5oaWVyTm9kZS5jaGFuZ2UgKz0gY2hhbmdlO1xufVxuLyoqXHJcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIHdhcyBvcmlnaW5hbGx5IGNvcGllZCBmcm9tIFwiZDMuanNcIlxyXG4gKiA8aHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWhpZXJhcmNoeS9ibG9iLzRjMWYwMzhmMjcyNWQ2ZWFlMmU0OWI2MWQwMTQ1NjQwMDY5NGJhYzQvc3JjL3RyZWUuanM+XHJcbiAqIHdpdGggc29tZSBtb2RpZmljYXRpb25zIG1hZGUgZm9yIHRoaXMgcHJvZ3JhbS5cclxuICogU2VlIHRoZSBsaWNlbnNlIHN0YXRlbWVudCBhdCB0aGUgaGVhZCBvZiB0aGlzIGZpbGUuXHJcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFNlcGFyYXRpb24obm9kZTEsIG5vZGUyKSB7XG4gIHJldHVybiBub2RlMS5wYXJlbnROb2RlID09PSBub2RlMi5wYXJlbnROb2RlID8gMSA6IDI7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlLmpzJztcbmltcG9ydCBTeW1ib2xDbHogZnJvbSAnLi4vaGVscGVyL1N5bWJvbC5qcyc7XG5pbXBvcnQgeyByYWRpYWxDb29yZGluYXRlIH0gZnJvbSAnLi9sYXlvdXRIZWxwZXIuanMnO1xuaW1wb3J0ICogYXMgYmJveCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL2Jib3guanMnO1xuaW1wb3J0IFZpZXcgZnJvbSAnLi4vLi4vY29vcmQvVmlldy5qcyc7XG5pbXBvcnQgKiBhcyByb2FtSGVscGVyIGZyb20gJy4uLy4uL2NvbXBvbmVudC9oZWxwZXIvcm9hbUhlbHBlci5qcyc7XG5pbXBvcnQgUm9hbUNvbnRyb2xsZXIgZnJvbSAnLi4vLi4vY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlci5qcyc7XG5pbXBvcnQgeyBvbklycmVsZXZhbnRFbGVtZW50IH0gZnJvbSAnLi4vLi4vY29tcG9uZW50L2hlbHBlci9jdXJzb3JIZWxwZXIuanMnO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50IH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0LmpzJztcbmltcG9ydCBQYXRoIGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qcyc7XG5pbXBvcnQgeyBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwsIHNldFN0YXRlc0ZsYWcsIHNldERlZmF1bHRTdGF0ZVByb3h5LCBIT1ZFUl9TVEFURV9CTFVSIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMuanMnO1xudmFyIFRyZWVFZGdlU2hhcGUgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmVlRWRnZVNoYXBlKCkge1xuICAgIHRoaXMucGFyZW50UG9pbnQgPSBbXTtcbiAgICB0aGlzLmNoaWxkUG9pbnRzID0gW107XG4gIH1cbiAgcmV0dXJuIFRyZWVFZGdlU2hhcGU7XG59KCk7XG52YXIgVHJlZVBhdGggPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVHJlZVBhdGgsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFRyZWVQYXRoKG9wdHMpIHtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgfVxuICBUcmVlUGF0aC5wcm90b3R5cGUuZ2V0RGVmYXVsdFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgIGZpbGw6IG51bGxcbiAgICB9O1xuICB9O1xuICBUcmVlUGF0aC5wcm90b3R5cGUuZ2V0RGVmYXVsdFNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgVHJlZUVkZ2VTaGFwZSgpO1xuICB9O1xuICBUcmVlUGF0aC5wcm90b3R5cGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgY2hpbGRQb2ludHMgPSBzaGFwZS5jaGlsZFBvaW50cztcbiAgICB2YXIgY2hpbGRMZW4gPSBjaGlsZFBvaW50cy5sZW5ndGg7XG4gICAgdmFyIHBhcmVudFBvaW50ID0gc2hhcGUucGFyZW50UG9pbnQ7XG4gICAgdmFyIGZpcnN0Q2hpbGRQb3MgPSBjaGlsZFBvaW50c1swXTtcbiAgICB2YXIgbGFzdENoaWxkUG9zID0gY2hpbGRQb2ludHNbY2hpbGRMZW4gLSAxXTtcbiAgICBpZiAoY2hpbGRMZW4gPT09IDEpIHtcbiAgICAgIGN0eC5tb3ZlVG8ocGFyZW50UG9pbnRbMF0sIHBhcmVudFBvaW50WzFdKTtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RDaGlsZFBvc1swXSwgZmlyc3RDaGlsZFBvc1sxXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBvcmllbnQgPSBzaGFwZS5vcmllbnQ7XG4gICAgdmFyIGZvcmtEaW0gPSBvcmllbnQgPT09ICdUQicgfHwgb3JpZW50ID09PSAnQlQnID8gMCA6IDE7XG4gICAgdmFyIG90aGVyRGltID0gMSAtIGZvcmtEaW07XG4gICAgdmFyIGZvcmtQb3NpdGlvbiA9IHBhcnNlUGVyY2VudChzaGFwZS5mb3JrUG9zaXRpb24sIDEpO1xuICAgIHZhciB0bXBQb2ludCA9IFtdO1xuICAgIHRtcFBvaW50W2ZvcmtEaW1dID0gcGFyZW50UG9pbnRbZm9ya0RpbV07XG4gICAgdG1wUG9pbnRbb3RoZXJEaW1dID0gcGFyZW50UG9pbnRbb3RoZXJEaW1dICsgKGxhc3RDaGlsZFBvc1tvdGhlckRpbV0gLSBwYXJlbnRQb2ludFtvdGhlckRpbV0pICogZm9ya1Bvc2l0aW9uO1xuICAgIGN0eC5tb3ZlVG8ocGFyZW50UG9pbnRbMF0sIHBhcmVudFBvaW50WzFdKTtcbiAgICBjdHgubGluZVRvKHRtcFBvaW50WzBdLCB0bXBQb2ludFsxXSk7XG4gICAgY3R4Lm1vdmVUbyhmaXJzdENoaWxkUG9zWzBdLCBmaXJzdENoaWxkUG9zWzFdKTtcbiAgICB0bXBQb2ludFtmb3JrRGltXSA9IGZpcnN0Q2hpbGRQb3NbZm9ya0RpbV07XG4gICAgY3R4LmxpbmVUbyh0bXBQb2ludFswXSwgdG1wUG9pbnRbMV0pO1xuICAgIHRtcFBvaW50W2ZvcmtEaW1dID0gbGFzdENoaWxkUG9zW2ZvcmtEaW1dO1xuICAgIGN0eC5saW5lVG8odG1wUG9pbnRbMF0sIHRtcFBvaW50WzFdKTtcbiAgICBjdHgubGluZVRvKGxhc3RDaGlsZFBvc1swXSwgbGFzdENoaWxkUG9zWzFdKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNoaWxkTGVuIC0gMTsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBjaGlsZFBvaW50c1tpXTtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgICAgIHRtcFBvaW50W2ZvcmtEaW1dID0gcG9pbnRbZm9ya0RpbV07XG4gICAgICBjdHgubGluZVRvKHRtcFBvaW50WzBdLCB0bXBQb2ludFsxXSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gVHJlZVBhdGg7XG59KFBhdGgpO1xudmFyIFRyZWVWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRyZWVWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBUcmVlVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gVHJlZVZpZXcudHlwZTtcbiAgICBfdGhpcy5fbWFpbkdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgVHJlZVZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5fY29udHJvbGxlciA9IG5ldyBSb2FtQ29udHJvbGxlcihhcGkuZ2V0WnIoKSk7XG4gICAgdGhpcy5fY29udHJvbGxlckhvc3QgPSB7XG4gICAgICB0YXJnZXQ6IHRoaXMuZ3JvdXBcbiAgICB9O1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX21haW5Hcm91cCk7XG4gIH07XG4gIFRyZWVWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBsYXlvdXRJbmZvID0gc2VyaWVzTW9kZWwubGF5b3V0SW5mbztcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLl9tYWluR3JvdXA7XG4gICAgdmFyIGxheW91dCA9IHNlcmllc01vZGVsLmdldCgnbGF5b3V0Jyk7XG4gICAgaWYgKGxheW91dCA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgIGdyb3VwLnggPSBsYXlvdXRJbmZvLnggKyBsYXlvdXRJbmZvLndpZHRoIC8gMjtcbiAgICAgIGdyb3VwLnkgPSBsYXlvdXRJbmZvLnkgKyBsYXlvdXRJbmZvLmhlaWdodCAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwLnggPSBsYXlvdXRJbmZvLng7XG4gICAgICBncm91cC55ID0gbGF5b3V0SW5mby55O1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVWaWV3Q29vcmRTeXMoc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgdGhpcy5fdXBkYXRlQ29udHJvbGxlcihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgZGF0YS5kaWZmKG9sZERhdGEpLmFkZChmdW5jdGlvbiAobmV3SWR4KSB7XG4gICAgICBpZiAoc3ltYm9sTmVlZHNEcmF3KGRhdGEsIG5ld0lkeCkpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5vZGUgYW5kIGVkZ2VcbiAgICAgICAgdXBkYXRlTm9kZShkYXRhLCBuZXdJZHgsIG51bGwsIGdyb3VwLCBzZXJpZXNNb2RlbCk7XG4gICAgICB9XG4gICAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgdmFyIHN5bWJvbEVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICBpZiAoIXN5bWJvbE5lZWRzRHJhdyhkYXRhLCBuZXdJZHgpKSB7XG4gICAgICAgIHN5bWJvbEVsICYmIHJlbW92ZU5vZGUob2xkRGF0YSwgb2xkSWR4LCBzeW1ib2xFbCwgZ3JvdXAsIHNlcmllc01vZGVsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIG5vZGUgYW5kIGVkZ2VcbiAgICAgIHVwZGF0ZU5vZGUoZGF0YSwgbmV3SWR4LCBzeW1ib2xFbCwgZ3JvdXAsIHNlcmllc01vZGVsKTtcbiAgICB9KS5yZW1vdmUoZnVuY3Rpb24gKG9sZElkeCkge1xuICAgICAgdmFyIHN5bWJvbEVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICAvLyBXaGVuIHJlbW92ZSBhIGNvbGxhcHNlZCBub2RlIG9mIHN1YnRyZWUsIHNpbmNlIHRoZSBjb2xsYXBzZWRcbiAgICAgIC8vIG5vZGUgaGF2ZW4ndCBiZWVuIGluaXRpYWxpemVkIHdpdGggYSBzeW1ib2wgZWxlbWVudCxcbiAgICAgIC8vIHlvdSBjYW4ndCBmb3VuZCBpdCdzIHN5bWJvbCBlbGVtZW50IHRocm91Z2ggaW5kZXguXG4gICAgICAvLyBzbyBpZiB3ZSB3YW50IHRvIHJlbW92ZSB0aGUgc3ltYm9sIGVsZW1lbnQgd2Ugc2hvdWxkIGluc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgc3ltYm9sIGVsZW1lbnQgaXMgbm90IG51bGwuXG4gICAgICBpZiAoc3ltYm9sRWwpIHtcbiAgICAgICAgcmVtb3ZlTm9kZShvbGREYXRhLCBvbGRJZHgsIHN5bWJvbEVsLCBncm91cCwgc2VyaWVzTW9kZWwpO1xuICAgICAgfVxuICAgIH0pLmV4ZWN1dGUoKTtcbiAgICB0aGlzLl9ub2RlU2NhbGVSYXRpbyA9IHNlcmllc01vZGVsLmdldCgnbm9kZVNjYWxlUmF0aW8nKTtcbiAgICB0aGlzLl91cGRhdGVOb2RlQW5kTGlua1NjYWxlKHNlcmllc01vZGVsKTtcbiAgICBpZiAoc2VyaWVzTW9kZWwuZ2V0KCdleHBhbmRBbmRDb2xsYXBzZScpID09PSB0cnVlKSB7XG4gICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgZGF0YUluZGV4KSB7XG4gICAgICAgIGVsLm9mZignY2xpY2snKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICd0cmVlRXhwYW5kQW5kQ29sbGFwc2UnLFxuICAgICAgICAgICAgc2VyaWVzSWQ6IHNlcmllc01vZGVsLmlkLFxuICAgICAgICAgICAgZGF0YUluZGV4OiBkYXRhSW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH07XG4gIFRyZWVWaWV3LnByb3RvdHlwZS5fdXBkYXRlVmlld0Nvb3JkU3lzID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICAgIGlmIChsYXlvdXQgJiYgIWlzTmFOKGxheW91dC54KSAmJiAhaXNOYU4obGF5b3V0LnkpKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKFsrbGF5b3V0LngsICtsYXlvdXQueV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBtaW4gPSBbXTtcbiAgICB2YXIgbWF4ID0gW107XG4gICAgYmJveC5mcm9tUG9pbnRzKHBvaW50cywgbWluLCBtYXgpO1xuICAgIC8vIElmIGRvbid0IFN0b3JlIG1pbiBtYXggd2hlbiBjb2xsYXBzZSB0aGUgcm9vdCBub2RlIGFmdGVyIHJvYW0sXG4gICAgLy8gdGhlIHJvb3Qgbm9kZSB3aWxsIGRpc2FwcGVhci5cbiAgICB2YXIgb2xkTWluID0gdGhpcy5fbWluO1xuICAgIHZhciBvbGRNYXggPSB0aGlzLl9tYXg7XG4gICAgLy8gSWYgd2lkdGggb3IgaGVpZ2h0IGlzIDBcbiAgICBpZiAobWF4WzBdIC0gbWluWzBdID09PSAwKSB7XG4gICAgICBtaW5bMF0gPSBvbGRNaW4gPyBvbGRNaW5bMF0gOiBtaW5bMF0gLSAxO1xuICAgICAgbWF4WzBdID0gb2xkTWF4ID8gb2xkTWF4WzBdIDogbWF4WzBdICsgMTtcbiAgICB9XG4gICAgaWYgKG1heFsxXSAtIG1pblsxXSA9PT0gMCkge1xuICAgICAgbWluWzFdID0gb2xkTWluID8gb2xkTWluWzFdIDogbWluWzFdIC0gMTtcbiAgICAgIG1heFsxXSA9IG9sZE1heCA/IG9sZE1heFsxXSA6IG1heFsxXSArIDE7XG4gICAgfVxuICAgIHZhciB2aWV3Q29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gbmV3IFZpZXcoKTtcbiAgICB2aWV3Q29vcmRTeXMuem9vbUxpbWl0ID0gc2VyaWVzTW9kZWwuZ2V0KCdzY2FsZUxpbWl0Jyk7XG4gICAgdmlld0Nvb3JkU3lzLnNldEJvdW5kaW5nUmVjdChtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuICAgIHZpZXdDb29yZFN5cy5zZXRDZW50ZXIoc2VyaWVzTW9kZWwuZ2V0KCdjZW50ZXInKSwgYXBpKTtcbiAgICB2aWV3Q29vcmRTeXMuc2V0Wm9vbShzZXJpZXNNb2RlbC5nZXQoJ3pvb20nKSk7XG4gICAgLy8gSGVyZSB3ZSB1c2Ugdmlld0Nvb3JkU3lzIGp1c3QgZm9yIGNvbXB1dGluZyB0aGUgJ3Bvc2l0aW9uJyBhbmQgJ3NjYWxlJyBvZiB0aGUgZ3JvdXBcbiAgICB0aGlzLmdyb3VwLmF0dHIoe1xuICAgICAgeDogdmlld0Nvb3JkU3lzLngsXG4gICAgICB5OiB2aWV3Q29vcmRTeXMueSxcbiAgICAgIHNjYWxlWDogdmlld0Nvb3JkU3lzLnNjYWxlWCxcbiAgICAgIHNjYWxlWTogdmlld0Nvb3JkU3lzLnNjYWxlWVxuICAgIH0pO1xuICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICB0aGlzLl9tYXggPSBtYXg7XG4gIH07XG4gIFRyZWVWaWV3LnByb3RvdHlwZS5fdXBkYXRlQ29udHJvbGxlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgY29udHJvbGxlciA9IHRoaXMuX2NvbnRyb2xsZXI7XG4gICAgdmFyIGNvbnRyb2xsZXJIb3N0ID0gdGhpcy5fY29udHJvbGxlckhvc3Q7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICBjb250cm9sbGVyLnNldFBvaW50ZXJDaGVja2VyKGZ1bmN0aW9uIChlLCB4LCB5KSB7XG4gICAgICB2YXIgcmVjdCA9IGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgcmVjdC5hcHBseVRyYW5zZm9ybShncm91cC50cmFuc2Zvcm0pO1xuICAgICAgcmV0dXJuIHJlY3QuY29udGFpbih4LCB5KSAmJiAhb25JcnJlbGV2YW50RWxlbWVudChlLCBhcGksIHNlcmllc01vZGVsKTtcbiAgICB9KTtcbiAgICBjb250cm9sbGVyLmVuYWJsZShzZXJpZXNNb2RlbC5nZXQoJ3JvYW0nKSk7XG4gICAgY29udHJvbGxlckhvc3Quem9vbUxpbWl0ID0gc2VyaWVzTW9kZWwuZ2V0KCdzY2FsZUxpbWl0Jyk7XG4gICAgY29udHJvbGxlckhvc3Quem9vbSA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0Wm9vbSgpO1xuICAgIGNvbnRyb2xsZXIub2ZmKCdwYW4nKS5vZmYoJ3pvb20nKS5vbigncGFuJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJvYW1IZWxwZXIudXBkYXRlVmlld09uUGFuKGNvbnRyb2xsZXJIb3N0LCBlLmR4LCBlLmR5KTtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHNlcmllc0lkOiBzZXJpZXNNb2RlbC5pZCxcbiAgICAgICAgdHlwZTogJ3RyZWVSb2FtJyxcbiAgICAgICAgZHg6IGUuZHgsXG4gICAgICAgIGR5OiBlLmR5XG4gICAgICB9KTtcbiAgICB9KS5vbignem9vbScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICByb2FtSGVscGVyLnVwZGF0ZVZpZXdPblpvb20oY29udHJvbGxlckhvc3QsIGUuc2NhbGUsIGUub3JpZ2luWCwgZS5vcmlnaW5ZKTtcbiAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHNlcmllc0lkOiBzZXJpZXNNb2RlbC5pZCxcbiAgICAgICAgdHlwZTogJ3RyZWVSb2FtJyxcbiAgICAgICAgem9vbTogZS5zY2FsZSxcbiAgICAgICAgb3JpZ2luWDogZS5vcmlnaW5YLFxuICAgICAgICBvcmlnaW5ZOiBlLm9yaWdpbllcbiAgICAgIH0pO1xuICAgICAgX3RoaXMuX3VwZGF0ZU5vZGVBbmRMaW5rU2NhbGUoc2VyaWVzTW9kZWwpO1xuICAgICAgLy8gT25seSB1cGRhdGUgbGFiZWwgbGF5b3V0IG9uIHpvb21cbiAgICAgIGFwaS51cGRhdGVMYWJlbExheW91dCgpO1xuICAgIH0pO1xuICB9O1xuICBUcmVlVmlldy5wcm90b3R5cGUuX3VwZGF0ZU5vZGVBbmRMaW5rU2NhbGUgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgbm9kZVNjYWxlID0gdGhpcy5fZ2V0Tm9kZUdsb2JhbFNjYWxlKHNlcmllc01vZGVsKTtcbiAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICBlbC5zZXRTeW1ib2xTY2FsZShub2RlU2NhbGUpO1xuICAgIH0pO1xuICB9O1xuICBUcmVlVmlldy5wcm90b3R5cGUuX2dldE5vZGVHbG9iYWxTY2FsZSA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgaWYgKGNvb3JkU3lzLnR5cGUgIT09ICd2aWV3Jykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHZhciBub2RlU2NhbGVSYXRpbyA9IHRoaXMuX25vZGVTY2FsZVJhdGlvO1xuICAgIHZhciBncm91cFpvb20gPSBjb29yZFN5cy5zY2FsZVggfHwgMTtcbiAgICAvLyBTY2FsZSBub2RlIHdoZW4gem9vbSBjaGFuZ2VzXG4gICAgdmFyIHJvYW1ab29tID0gY29vcmRTeXMuZ2V0Wm9vbSgpO1xuICAgIHZhciBub2RlU2NhbGUgPSAocm9hbVpvb20gLSAxKSAqIG5vZGVTY2FsZVJhdGlvICsgMTtcbiAgICByZXR1cm4gbm9kZVNjYWxlIC8gZ3JvdXBab29tO1xuICB9O1xuICBUcmVlVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jb250cm9sbGVyICYmIHRoaXMuX2NvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2NvbnRyb2xsZXJIb3N0ID0gbnVsbDtcbiAgfTtcbiAgVHJlZVZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9tYWluR3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gIH07XG4gIFRyZWVWaWV3LnR5cGUgPSAndHJlZSc7XG4gIHJldHVybiBUcmVlVmlldztcbn0oQ2hhcnRWaWV3KTtcbmZ1bmN0aW9uIHN5bWJvbE5lZWRzRHJhdyhkYXRhLCBkYXRhSW5kZXgpIHtcbiAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChkYXRhSW5kZXgpO1xuICByZXR1cm4gbGF5b3V0ICYmICFpc05hTihsYXlvdXQueCkgJiYgIWlzTmFOKGxheW91dC55KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU5vZGUoZGF0YSwgZGF0YUluZGV4LCBzeW1ib2xFbCwgZ3JvdXAsIHNlcmllc01vZGVsKSB7XG4gIHZhciBpc0luaXQgPSAhc3ltYm9sRWw7XG4gIHZhciBub2RlID0gZGF0YS50cmVlLmdldE5vZGVCeURhdGFJbmRleChkYXRhSW5kZXgpO1xuICB2YXIgaXRlbU1vZGVsID0gbm9kZS5nZXRNb2RlbCgpO1xuICB2YXIgdmlzdWFsQ29sb3IgPSBub2RlLmdldFZpc3VhbCgnc3R5bGUnKS5maWxsO1xuICB2YXIgc3ltYm9sSW5uZXJDb2xvciA9IG5vZGUuaXNFeHBhbmQgPT09IGZhbHNlICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwID8gdmlzdWFsQ29sb3IgOiAnI2ZmZic7XG4gIHZhciB2aXJ0dWFsUm9vdCA9IGRhdGEudHJlZS5yb290O1xuICB2YXIgc291cmNlID0gbm9kZS5wYXJlbnROb2RlID09PSB2aXJ0dWFsUm9vdCA/IG5vZGUgOiBub2RlLnBhcmVudE5vZGUgfHwgbm9kZTtcbiAgdmFyIHNvdXJjZVN5bWJvbEVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKHNvdXJjZS5kYXRhSW5kZXgpO1xuICB2YXIgc291cmNlTGF5b3V0ID0gc291cmNlLmdldExheW91dCgpO1xuICB2YXIgc291cmNlT2xkTGF5b3V0ID0gc291cmNlU3ltYm9sRWwgPyB7XG4gICAgeDogc291cmNlU3ltYm9sRWwuX19vbGRYLFxuICAgIHk6IHNvdXJjZVN5bWJvbEVsLl9fb2xkWSxcbiAgICByYXdYOiBzb3VyY2VTeW1ib2xFbC5fX3JhZGlhbE9sZFJhd1gsXG4gICAgcmF3WTogc291cmNlU3ltYm9sRWwuX19yYWRpYWxPbGRSYXdZXG4gIH0gOiBzb3VyY2VMYXlvdXQ7XG4gIHZhciB0YXJnZXRMYXlvdXQgPSBub2RlLmdldExheW91dCgpO1xuICBpZiAoaXNJbml0KSB7XG4gICAgc3ltYm9sRWwgPSBuZXcgU3ltYm9sQ2x6KGRhdGEsIGRhdGFJbmRleCwgbnVsbCwge1xuICAgICAgc3ltYm9sSW5uZXJDb2xvcjogc3ltYm9sSW5uZXJDb2xvcixcbiAgICAgIHVzZU5hbWVMYWJlbDogdHJ1ZVxuICAgIH0pO1xuICAgIHN5bWJvbEVsLnggPSBzb3VyY2VPbGRMYXlvdXQueDtcbiAgICBzeW1ib2xFbC55ID0gc291cmNlT2xkTGF5b3V0Lnk7XG4gIH0gZWxzZSB7XG4gICAgc3ltYm9sRWwudXBkYXRlRGF0YShkYXRhLCBkYXRhSW5kZXgsIG51bGwsIHtcbiAgICAgIHN5bWJvbElubmVyQ29sb3I6IHN5bWJvbElubmVyQ29sb3IsXG4gICAgICB1c2VOYW1lTGFiZWw6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzeW1ib2xFbC5fX3JhZGlhbE9sZFJhd1ggPSBzeW1ib2xFbC5fX3JhZGlhbFJhd1g7XG4gIHN5bWJvbEVsLl9fcmFkaWFsT2xkUmF3WSA9IHN5bWJvbEVsLl9fcmFkaWFsUmF3WTtcbiAgc3ltYm9sRWwuX19yYWRpYWxSYXdYID0gdGFyZ2V0TGF5b3V0LnJhd1g7XG4gIHN5bWJvbEVsLl9fcmFkaWFsUmF3WSA9IHRhcmdldExheW91dC5yYXdZO1xuICBncm91cC5hZGQoc3ltYm9sRWwpO1xuICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4LCBzeW1ib2xFbCk7XG4gIHN5bWJvbEVsLl9fb2xkWCA9IHN5bWJvbEVsLng7XG4gIHN5bWJvbEVsLl9fb2xkWSA9IHN5bWJvbEVsLnk7XG4gIGdyYXBoaWMudXBkYXRlUHJvcHMoc3ltYm9sRWwsIHtcbiAgICB4OiB0YXJnZXRMYXlvdXQueCxcbiAgICB5OiB0YXJnZXRMYXlvdXQueVxuICB9LCBzZXJpZXNNb2RlbCk7XG4gIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sRWwuZ2V0U3ltYm9sUGF0aCgpO1xuICBpZiAoc2VyaWVzTW9kZWwuZ2V0KCdsYXlvdXQnKSA9PT0gJ3JhZGlhbCcpIHtcbiAgICB2YXIgcmVhbFJvb3QgPSB2aXJ0dWFsUm9vdC5jaGlsZHJlblswXTtcbiAgICB2YXIgcm9vdExheW91dCA9IHJlYWxSb290LmdldExheW91dCgpO1xuICAgIHZhciBsZW5ndGhfMSA9IHJlYWxSb290LmNoaWxkcmVuLmxlbmd0aDtcbiAgICB2YXIgcmFkID0gdm9pZCAwO1xuICAgIHZhciBpc0xlZnQgPSB2b2lkIDA7XG4gICAgaWYgKHRhcmdldExheW91dC54ID09PSByb290TGF5b3V0LnggJiYgbm9kZS5pc0V4cGFuZCA9PT0gdHJ1ZSAmJiByZWFsUm9vdC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgIHg6IChyZWFsUm9vdC5jaGlsZHJlblswXS5nZXRMYXlvdXQoKS54ICsgcmVhbFJvb3QuY2hpbGRyZW5bbGVuZ3RoXzEgLSAxXS5nZXRMYXlvdXQoKS54KSAvIDIsXG4gICAgICAgIHk6IChyZWFsUm9vdC5jaGlsZHJlblswXS5nZXRMYXlvdXQoKS55ICsgcmVhbFJvb3QuY2hpbGRyZW5bbGVuZ3RoXzEgLSAxXS5nZXRMYXlvdXQoKS55KSAvIDJcbiAgICAgIH07XG4gICAgICByYWQgPSBNYXRoLmF0YW4yKGNlbnRlci55IC0gcm9vdExheW91dC55LCBjZW50ZXIueCAtIHJvb3RMYXlvdXQueCk7XG4gICAgICBpZiAocmFkIDwgMCkge1xuICAgICAgICByYWQgPSBNYXRoLlBJICogMiArIHJhZDtcbiAgICAgIH1cbiAgICAgIGlzTGVmdCA9IGNlbnRlci54IDwgcm9vdExheW91dC54O1xuICAgICAgaWYgKGlzTGVmdCkge1xuICAgICAgICByYWQgPSByYWQgLSBNYXRoLlBJO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYWQgPSBNYXRoLmF0YW4yKHRhcmdldExheW91dC55IC0gcm9vdExheW91dC55LCB0YXJnZXRMYXlvdXQueCAtIHJvb3RMYXlvdXQueCk7XG4gICAgICBpZiAocmFkIDwgMCkge1xuICAgICAgICByYWQgPSBNYXRoLlBJICogMiArIHJhZDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCAmJiBub2RlLmlzRXhwYW5kID09PSBmYWxzZSkge1xuICAgICAgICBpc0xlZnQgPSB0YXJnZXRMYXlvdXQueCA8IHJvb3RMYXlvdXQueDtcbiAgICAgICAgaWYgKGlzTGVmdCkge1xuICAgICAgICAgIHJhZCA9IHJhZCAtIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzTGVmdCA9IHRhcmdldExheW91dC54ID4gcm9vdExheW91dC54O1xuICAgICAgICBpZiAoIWlzTGVmdCkge1xuICAgICAgICAgIHJhZCA9IHJhZCAtIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRleHRQb3NpdGlvbiA9IGlzTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgdmFyIG5vcm1hbExhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsJyk7XG4gICAgdmFyIHJvdGF0ZSA9IG5vcm1hbExhYmVsTW9kZWwuZ2V0KCdyb3RhdGUnKTtcbiAgICB2YXIgbGFiZWxSb3RhdGVSYWRpYW4gPSByb3RhdGUgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgdmFyIHRleHRDb250ZW50ID0gc3ltYm9sUGF0aC5nZXRUZXh0Q29udGVudCgpO1xuICAgIGlmICh0ZXh0Q29udGVudCkge1xuICAgICAgc3ltYm9sUGF0aC5zZXRUZXh0Q29uZmlnKHtcbiAgICAgICAgcG9zaXRpb246IG5vcm1hbExhYmVsTW9kZWwuZ2V0KCdwb3NpdGlvbicpIHx8IHRleHRQb3NpdGlvbixcbiAgICAgICAgcm90YXRpb246IHJvdGF0ZSA9PSBudWxsID8gLXJhZCA6IGxhYmVsUm90YXRlUmFkaWFuLFxuICAgICAgICBvcmlnaW46ICdjZW50ZXInXG4gICAgICB9KTtcbiAgICAgIHRleHRDb250ZW50LnNldFN0eWxlKCd2ZXJ0aWNhbEFsaWduJywgJ21pZGRsZScpO1xuICAgIH1cbiAgfVxuICAvLyBIYW5kbGUgc3RhdHVzXG4gIHZhciBmb2N1cyA9IGl0ZW1Nb2RlbC5nZXQoWydlbXBoYXNpcycsICdmb2N1cyddKTtcbiAgdmFyIGZvY3VzRGF0YUluZGljZXMgPSBmb2N1cyA9PT0gJ3JlbGF0aXZlJyA/IHpyVXRpbC5jb25jYXRBcnJheShub2RlLmdldEFuY2VzdG9yc0luZGljZXMoKSwgbm9kZS5nZXREZXNjZW5kYW50SW5kaWNlcygpKSA6IGZvY3VzID09PSAnYW5jZXN0b3InID8gbm9kZS5nZXRBbmNlc3RvcnNJbmRpY2VzKCkgOiBmb2N1cyA9PT0gJ2Rlc2NlbmRhbnQnID8gbm9kZS5nZXREZXNjZW5kYW50SW5kaWNlcygpIDogbnVsbDtcbiAgaWYgKGZvY3VzRGF0YUluZGljZXMpIHtcbiAgICAvLyBNb2RpZnkgdGhlIGZvY3VzIHRvIGRhdGEgaW5kaWNlcy5cbiAgICBnZXRFQ0RhdGEoc3ltYm9sRWwpLmZvY3VzID0gZm9jdXNEYXRhSW5kaWNlcztcbiAgfVxuICBkcmF3RWRnZShzZXJpZXNNb2RlbCwgbm9kZSwgdmlydHVhbFJvb3QsIHN5bWJvbEVsLCBzb3VyY2VPbGRMYXlvdXQsIHNvdXJjZUxheW91dCwgdGFyZ2V0TGF5b3V0LCBncm91cCk7XG4gIGlmIChzeW1ib2xFbC5fX2VkZ2UpIHtcbiAgICBzeW1ib2xFbC5vbkhvdmVyU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAodG9TdGF0ZSkge1xuICAgICAgaWYgKHRvU3RhdGUgIT09ICdibHVyJykge1xuICAgICAgICAvLyBOT1RFOiBFbnN1cmUgdGhlIHBhcmVudCBlbGVtZW50cyB3aWxsIGJlZW4gYmx1cnJlZCBmaXJzdGx5LlxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHJldHVybiBvZiBnZXRBbmNlc3RvcnNJbmRpY2VzIGFuZCBnZXREZXNjZW5kYW50SW5kaWNlc1xuICAgICAgICAvLyBUT0RPOiBBIGJpdCB0cmlja3kuXG4gICAgICAgIHZhciBwYXJlbnRFbCA9IG5vZGUucGFyZW50Tm9kZSAmJiBkYXRhLmdldEl0ZW1HcmFwaGljRWwobm9kZS5wYXJlbnROb2RlLmRhdGFJbmRleCk7XG4gICAgICAgIGlmICghKHBhcmVudEVsICYmIHBhcmVudEVsLmhvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX0JMVVIpKSB7XG4gICAgICAgICAgc2V0U3RhdGVzRmxhZyhzeW1ib2xFbC5fX2VkZ2UsIHRvU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZHJhd0VkZ2Uoc2VyaWVzTW9kZWwsIG5vZGUsIHZpcnR1YWxSb290LCBzeW1ib2xFbCwgc291cmNlT2xkTGF5b3V0LCBzb3VyY2VMYXlvdXQsIHRhcmdldExheW91dCwgZ3JvdXApIHtcbiAgdmFyIGl0ZW1Nb2RlbCA9IG5vZGUuZ2V0TW9kZWwoKTtcbiAgdmFyIGVkZ2VTaGFwZSA9IHNlcmllc01vZGVsLmdldCgnZWRnZVNoYXBlJyk7XG4gIHZhciBsYXlvdXQgPSBzZXJpZXNNb2RlbC5nZXQoJ2xheW91dCcpO1xuICB2YXIgb3JpZW50ID0gc2VyaWVzTW9kZWwuZ2V0T3JpZW50KCk7XG4gIHZhciBjdXJ2YXR1cmUgPSBzZXJpZXNNb2RlbC5nZXQoWydsaW5lU3R5bGUnLCAnY3VydmVuZXNzJ10pO1xuICB2YXIgZWRnZUZvcmtQb3NpdGlvbiA9IHNlcmllc01vZGVsLmdldCgnZWRnZUZvcmtQb3NpdGlvbicpO1xuICB2YXIgbGluZVN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKTtcbiAgdmFyIGVkZ2UgPSBzeW1ib2xFbC5fX2VkZ2U7XG4gIC8vIGN1cnZlIGVkZ2UgZnJvbSBub2RlIC0+IHBhcmVudFxuICAvLyBwb2x5bGluZSBlZGdlIGZyb20gbm9kZSAtPiBjaGlsZHJlblxuICBpZiAoZWRnZVNoYXBlID09PSAnY3VydmUnKSB7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLnBhcmVudE5vZGUgIT09IHZpcnR1YWxSb290KSB7XG4gICAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgZWRnZSA9IHN5bWJvbEVsLl9fZWRnZSA9IG5ldyBncmFwaGljLkJlemllckN1cnZlKHtcbiAgICAgICAgICBzaGFwZTogZ2V0RWRnZVNoYXBlKGxheW91dCwgb3JpZW50LCBjdXJ2YXR1cmUsIHNvdXJjZU9sZExheW91dCwgc291cmNlT2xkTGF5b3V0KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZWRnZSwge1xuICAgICAgICBzaGFwZTogZ2V0RWRnZVNoYXBlKGxheW91dCwgb3JpZW50LCBjdXJ2YXR1cmUsIHNvdXJjZUxheW91dCwgdGFyZ2V0TGF5b3V0KVxuICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlZGdlU2hhcGUgPT09ICdwb2x5bGluZScpIHtcbiAgICBpZiAobGF5b3V0ID09PSAnb3J0aG9nb25hbCcpIHtcbiAgICAgIGlmIChub2RlICE9PSB2aXJ0dWFsUm9vdCAmJiBub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIG5vZGUuaXNFeHBhbmQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGNoaWxkUG9pbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGRMYXlvdXQgPSBjaGlsZHJlbltpXS5nZXRMYXlvdXQoKTtcbiAgICAgICAgICBjaGlsZFBvaW50cy5wdXNoKFtjaGlsZExheW91dC54LCBjaGlsZExheW91dC55XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlZGdlKSB7XG4gICAgICAgICAgZWRnZSA9IHN5bWJvbEVsLl9fZWRnZSA9IG5ldyBUcmVlUGF0aCh7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICBwYXJlbnRQb2ludDogW3RhcmdldExheW91dC54LCB0YXJnZXRMYXlvdXQueV0sXG4gICAgICAgICAgICAgIGNoaWxkUG9pbnRzOiBbW3RhcmdldExheW91dC54LCB0YXJnZXRMYXlvdXQueV1dLFxuICAgICAgICAgICAgICBvcmllbnQ6IG9yaWVudCxcbiAgICAgICAgICAgICAgZm9ya1Bvc2l0aW9uOiBlZGdlRm9ya1Bvc2l0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlZGdlLCB7XG4gICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHBhcmVudFBvaW50OiBbdGFyZ2V0TGF5b3V0LngsIHRhcmdldExheW91dC55XSxcbiAgICAgICAgICAgIGNoaWxkUG9pbnRzOiBjaGlsZFBvaW50c1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwb2x5bGluZSBlZGdlU2hhcGUgY2FuIG9ubHkgYmUgdXNlZCBpbiBvcnRob2dvbmFsIGxheW91dCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBzaG93IGFsbCBlZGdlIHdoZW4gZWRnZVNoYXBlIGlzICdjdXJ2ZScsIGZpbHRlciBub2RlIGBpc0V4cGFuZGAgaXMgZmFsc2Ugd2hlbiBlZGdlU2hhcGUgaXMgJ3BvbHlsaW5lJ1xuICBpZiAoZWRnZSAmJiAhKGVkZ2VTaGFwZSA9PT0gJ3BvbHlsaW5lJyAmJiAhbm9kZS5pc0V4cGFuZCkpIHtcbiAgICBlZGdlLnVzZVN0eWxlKHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICBzdHJva2VOb1NjYWxlOiB0cnVlLFxuICAgICAgZmlsbDogbnVsbFxuICAgIH0sIGxpbmVTdHlsZSkpO1xuICAgIHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbChlZGdlLCBpdGVtTW9kZWwsICdsaW5lU3R5bGUnKTtcbiAgICBzZXREZWZhdWx0U3RhdGVQcm94eShlZGdlKTtcbiAgICBncm91cC5hZGQoZWRnZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZU5vZGVFZGdlKG5vZGUsIGRhdGEsIGdyb3VwLCBzZXJpZXNNb2RlbCwgcmVtb3ZlQW5pbWF0aW9uT3B0KSB7XG4gIHZhciB2aXJ0dWFsUm9vdCA9IGRhdGEudHJlZS5yb290O1xuICB2YXIgX2EgPSBnZXRTb3VyY2VOb2RlKHZpcnR1YWxSb290LCBub2RlKSxcbiAgICBzb3VyY2UgPSBfYS5zb3VyY2UsXG4gICAgc291cmNlTGF5b3V0ID0gX2Euc291cmNlTGF5b3V0O1xuICB2YXIgc3ltYm9sRWwgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwobm9kZS5kYXRhSW5kZXgpO1xuICBpZiAoIXN5bWJvbEVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzb3VyY2VTeW1ib2xFbCA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChzb3VyY2UuZGF0YUluZGV4KTtcbiAgdmFyIHNvdXJjZUVkZ2UgPSBzb3VyY2VTeW1ib2xFbC5fX2VkZ2U7XG4gIC8vIDEuIHdoZW4gZXhwYW5kIHRoZSBzdWIgdHJlZSwgZGVsZXRlIHRoZSBjaGlsZHJlbiBub2RlIHNob3VsZCBkZWxldGUgdGhlIGVkZ2Ugb2ZcbiAgLy8gdGhlIHNvdXJjZSBhdCB0aGUgc2FtZSB0aW1lLiBiZWNhdXNlIHRoZSBwb2x5bGluZSBlZGdlIHNoYXBlIGlzIG9ubHkgb3duZWQgYnkgdGhlIHNvdXJjZS5cbiAgLy8gMi53aGVuIHRoZSBub2RlIGlzIHRoZSBvbmx5IGNoaWxkcmVuIG9mIHRoZSBzb3VyY2UsIGRlbGV0ZSB0aGUgbm9kZSBzaG91bGQgZGVsZXRlIHRoZSBlZGdlIG9mXG4gIC8vIHRoZSBzb3VyY2UgYXQgdGhlIHNhbWUgdGltZS4gdGhlIHNhbWUgcmVhc29uIGFzIGFib3ZlLlxuICB2YXIgZWRnZSA9IHN5bWJvbEVsLl9fZWRnZSB8fCAoc291cmNlLmlzRXhwYW5kID09PSBmYWxzZSB8fCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoID09PSAxID8gc291cmNlRWRnZSA6IHVuZGVmaW5lZCk7XG4gIHZhciBlZGdlU2hhcGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2VkZ2VTaGFwZScpO1xuICB2YXIgbGF5b3V0T3B0ID0gc2VyaWVzTW9kZWwuZ2V0KCdsYXlvdXQnKTtcbiAgdmFyIG9yaWVudCA9IHNlcmllc01vZGVsLmdldCgnb3JpZW50Jyk7XG4gIHZhciBjdXJ2YXR1cmUgPSBzZXJpZXNNb2RlbC5nZXQoWydsaW5lU3R5bGUnLCAnY3VydmVuZXNzJ10pO1xuICBpZiAoZWRnZSkge1xuICAgIGlmIChlZGdlU2hhcGUgPT09ICdjdXJ2ZScpIHtcbiAgICAgIGdyYXBoaWMucmVtb3ZlRWxlbWVudChlZGdlLCB7XG4gICAgICAgIHNoYXBlOiBnZXRFZGdlU2hhcGUobGF5b3V0T3B0LCBvcmllbnQsIGN1cnZhdHVyZSwgc291cmNlTGF5b3V0LCBzb3VyY2VMYXlvdXQpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfVxuICAgICAgfSwgc2VyaWVzTW9kZWwsIHtcbiAgICAgICAgY2I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBncm91cC5yZW1vdmUoZWRnZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZU9wdDogcmVtb3ZlQW5pbWF0aW9uT3B0XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGVkZ2VTaGFwZSA9PT0gJ3BvbHlsaW5lJyAmJiBzZXJpZXNNb2RlbC5nZXQoJ2xheW91dCcpID09PSAnb3J0aG9nb25hbCcpIHtcbiAgICAgIGdyYXBoaWMucmVtb3ZlRWxlbWVudChlZGdlLCB7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgcGFyZW50UG9pbnQ6IFtzb3VyY2VMYXlvdXQueCwgc291cmNlTGF5b3V0LnldLFxuICAgICAgICAgIGNoaWxkUG9pbnRzOiBbW3NvdXJjZUxheW91dC54LCBzb3VyY2VMYXlvdXQueV1dXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9XG4gICAgICB9LCBzZXJpZXNNb2RlbCwge1xuICAgICAgICBjYjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGdyb3VwLnJlbW92ZShlZGdlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlT3B0OiByZW1vdmVBbmltYXRpb25PcHRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0U291cmNlTm9kZSh2aXJ0dWFsUm9vdCwgbm9kZSkge1xuICB2YXIgc291cmNlID0gbm9kZS5wYXJlbnROb2RlID09PSB2aXJ0dWFsUm9vdCA/IG5vZGUgOiBub2RlLnBhcmVudE5vZGUgfHwgbm9kZTtcbiAgdmFyIHNvdXJjZUxheW91dDtcbiAgd2hpbGUgKHNvdXJjZUxheW91dCA9IHNvdXJjZS5nZXRMYXlvdXQoKSwgc291cmNlTGF5b3V0ID09IG51bGwpIHtcbiAgICBzb3VyY2UgPSBzb3VyY2UucGFyZW50Tm9kZSA9PT0gdmlydHVhbFJvb3QgPyBzb3VyY2UgOiBzb3VyY2UucGFyZW50Tm9kZSB8fCBzb3VyY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICBzb3VyY2VMYXlvdXQ6IHNvdXJjZUxheW91dFxuICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlTm9kZShkYXRhLCBkYXRhSW5kZXgsIHN5bWJvbEVsLCBncm91cCwgc2VyaWVzTW9kZWwpIHtcbiAgdmFyIG5vZGUgPSBkYXRhLnRyZWUuZ2V0Tm9kZUJ5RGF0YUluZGV4KGRhdGFJbmRleCk7XG4gIHZhciB2aXJ0dWFsUm9vdCA9IGRhdGEudHJlZS5yb290O1xuICB2YXIgc291cmNlTGF5b3V0ID0gZ2V0U291cmNlTm9kZSh2aXJ0dWFsUm9vdCwgbm9kZSkuc291cmNlTGF5b3V0O1xuICAvLyBVc2Ugc2FtZSBkdXJhdGlvbiBhbmQgZWFzaW5nIHdpdGggdXBkYXRlIHRvIGhhdmUgbW9yZSBjb25zaXN0ZW50IGFuaW1hdGlvbi5cbiAgdmFyIHJlbW92ZUFuaW1hdGlvbk9wdCA9IHtcbiAgICBkdXJhdGlvbjogc2VyaWVzTW9kZWwuZ2V0KCdhbmltYXRpb25EdXJhdGlvblVwZGF0ZScpLFxuICAgIGVhc2luZzogc2VyaWVzTW9kZWwuZ2V0KCdhbmltYXRpb25FYXNpbmdVcGRhdGUnKVxuICB9O1xuICBncmFwaGljLnJlbW92ZUVsZW1lbnQoc3ltYm9sRWwsIHtcbiAgICB4OiBzb3VyY2VMYXlvdXQueCArIDEsXG4gICAgeTogc291cmNlTGF5b3V0LnkgKyAxXG4gIH0sIHNlcmllc01vZGVsLCB7XG4gICAgY2I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdyb3VwLnJlbW92ZShzeW1ib2xFbCk7XG4gICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4LCBudWxsKTtcbiAgICB9LFxuICAgIHJlbW92ZU9wdDogcmVtb3ZlQW5pbWF0aW9uT3B0XG4gIH0pO1xuICBzeW1ib2xFbC5mYWRlT3V0KG51bGwsIGRhdGEuaG9zdE1vZGVsLCB7XG4gICAgZmFkZUxhYmVsOiB0cnVlLFxuICAgIGFuaW1hdGlvbjogcmVtb3ZlQW5pbWF0aW9uT3B0XG4gIH0pO1xuICAvLyByZW1vdmUgZWRnZSBhcyBwYXJlbnQgbm9kZVxuICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgIHJlbW92ZU5vZGVFZGdlKGNoaWxkTm9kZSwgZGF0YSwgZ3JvdXAsIHNlcmllc01vZGVsLCByZW1vdmVBbmltYXRpb25PcHQpO1xuICB9KTtcbiAgLy8gcmVtb3ZlIGVkZ2UgYXMgY2hpbGQgbm9kZVxuICByZW1vdmVOb2RlRWRnZShub2RlLCBkYXRhLCBncm91cCwgc2VyaWVzTW9kZWwsIHJlbW92ZUFuaW1hdGlvbk9wdCk7XG59XG5mdW5jdGlvbiBnZXRFZGdlU2hhcGUobGF5b3V0T3B0LCBvcmllbnQsIGN1cnZhdHVyZSwgc291cmNlTGF5b3V0LCB0YXJnZXRMYXlvdXQpIHtcbiAgdmFyIGNweDE7XG4gIHZhciBjcHkxO1xuICB2YXIgY3B4MjtcbiAgdmFyIGNweTI7XG4gIHZhciB4MTtcbiAgdmFyIHgyO1xuICB2YXIgeTE7XG4gIHZhciB5MjtcbiAgaWYgKGxheW91dE9wdCA9PT0gJ3JhZGlhbCcpIHtcbiAgICB4MSA9IHNvdXJjZUxheW91dC5yYXdYO1xuICAgIHkxID0gc291cmNlTGF5b3V0LnJhd1k7XG4gICAgeDIgPSB0YXJnZXRMYXlvdXQucmF3WDtcbiAgICB5MiA9IHRhcmdldExheW91dC5yYXdZO1xuICAgIHZhciByYWRpYWxDb29yMSA9IHJhZGlhbENvb3JkaW5hdGUoeDEsIHkxKTtcbiAgICB2YXIgcmFkaWFsQ29vcjIgPSByYWRpYWxDb29yZGluYXRlKHgxLCB5MSArICh5MiAtIHkxKSAqIGN1cnZhdHVyZSk7XG4gICAgdmFyIHJhZGlhbENvb3IzID0gcmFkaWFsQ29vcmRpbmF0ZSh4MiwgeTIgKyAoeTEgLSB5MikgKiBjdXJ2YXR1cmUpO1xuICAgIHZhciByYWRpYWxDb29yNCA9IHJhZGlhbENvb3JkaW5hdGUoeDIsIHkyKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHJhZGlhbENvb3IxLnggfHwgMCxcbiAgICAgIHkxOiByYWRpYWxDb29yMS55IHx8IDAsXG4gICAgICB4MjogcmFkaWFsQ29vcjQueCB8fCAwLFxuICAgICAgeTI6IHJhZGlhbENvb3I0LnkgfHwgMCxcbiAgICAgIGNweDE6IHJhZGlhbENvb3IyLnggfHwgMCxcbiAgICAgIGNweTE6IHJhZGlhbENvb3IyLnkgfHwgMCxcbiAgICAgIGNweDI6IHJhZGlhbENvb3IzLnggfHwgMCxcbiAgICAgIGNweTI6IHJhZGlhbENvb3IzLnkgfHwgMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgeDEgPSBzb3VyY2VMYXlvdXQueDtcbiAgICB5MSA9IHNvdXJjZUxheW91dC55O1xuICAgIHgyID0gdGFyZ2V0TGF5b3V0Lng7XG4gICAgeTIgPSB0YXJnZXRMYXlvdXQueTtcbiAgICBpZiAob3JpZW50ID09PSAnTFInIHx8IG9yaWVudCA9PT0gJ1JMJykge1xuICAgICAgY3B4MSA9IHgxICsgKHgyIC0geDEpICogY3VydmF0dXJlO1xuICAgICAgY3B5MSA9IHkxO1xuICAgICAgY3B4MiA9IHgyICsgKHgxIC0geDIpICogY3VydmF0dXJlO1xuICAgICAgY3B5MiA9IHkyO1xuICAgIH1cbiAgICBpZiAob3JpZW50ID09PSAnVEInIHx8IG9yaWVudCA9PT0gJ0JUJykge1xuICAgICAgY3B4MSA9IHgxO1xuICAgICAgY3B5MSA9IHkxICsgKHkyIC0geTEpICogY3VydmF0dXJlO1xuICAgICAgY3B4MiA9IHgyO1xuICAgICAgY3B5MiA9IHkyICsgKHkxIC0geTIpICogY3VydmF0dXJlO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHgxOiB4MSxcbiAgICB5MTogeTEsXG4gICAgeDI6IHgyLFxuICAgIHkyOiB5MixcbiAgICBjcHgxOiBjcHgxLFxuICAgIGNweTE6IGNweTEsXG4gICAgY3B4MjogY3B4MixcbiAgICBjcHkyOiBjcHkyXG4gIH07XG59XG5leHBvcnQgZGVmYXVsdCBUcmVlVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcy5qcyc7XG5pbXBvcnQgVHJlZSBmcm9tICcuLi8uLi9kYXRhL1RyZWUuanMnO1xuaW1wb3J0IE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL01vZGVsLmpzJztcbmltcG9ydCB7IGNyZWF0ZVRvb2x0aXBNYXJrdXAgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvdG9vbHRpcC90b29sdGlwTWFya3VwLmpzJztcbmltcG9ydCB7IHdyYXBUcmVlUGF0aEluZm8gfSBmcm9tICcuLi9oZWxwZXIvdHJlZUhlbHBlci5qcyc7XG52YXIgVHJlZVNlcmllc01vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRyZWVTZXJpZXNNb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gVHJlZVNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLmhhc1N5bWJvbFZpc3VhbCA9IHRydWU7XG4gICAgLy8gRG8gaXQgc2VsZi5cbiAgICBfdGhpcy5pZ25vcmVTdHlsZU9uRGF0YSA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIEluaXQgYSB0cmVlIGRhdGEgc3RydWN0dXJlIGZyb20gZGF0YSBpbiBvcHRpb24gc2VyaWVzXHJcbiAgICovXG4gIFRyZWVTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGEgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgLy8gY3JlYXRlIGEgdmlydHVhbCByb290XG4gICAgdmFyIHJvb3QgPSB7XG4gICAgICBuYW1lOiBvcHRpb24ubmFtZSxcbiAgICAgIGNoaWxkcmVuOiBvcHRpb24uZGF0YVxuICAgIH07XG4gICAgdmFyIGxlYXZlcyA9IG9wdGlvbi5sZWF2ZXMgfHwge307XG4gICAgdmFyIGxlYXZlc01vZGVsID0gbmV3IE1vZGVsKGxlYXZlcywgdGhpcywgdGhpcy5lY01vZGVsKTtcbiAgICB2YXIgdHJlZSA9IFRyZWUuY3JlYXRlVHJlZShyb290LCB0aGlzLCBiZWZvcmVMaW5rKTtcbiAgICBmdW5jdGlvbiBiZWZvcmVMaW5rKG5vZGVEYXRhKSB7XG4gICAgICBub2RlRGF0YS53cmFwTWV0aG9kKCdnZXRJdGVtTW9kZWwnLCBmdW5jdGlvbiAobW9kZWwsIGlkeCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRyZWUuZ2V0Tm9kZUJ5RGF0YUluZGV4KGlkeCk7XG4gICAgICAgIGlmICghKG5vZGUgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgbm9kZS5pc0V4cGFuZCkpIHtcbiAgICAgICAgICBtb2RlbC5wYXJlbnRNb2RlbCA9IGxlYXZlc01vZGVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgdHJlZURlcHRoID0gMDtcbiAgICB0cmVlLmVhY2hOb2RlKCdwcmVvcmRlcicsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAobm9kZS5kZXB0aCA+IHRyZWVEZXB0aCkge1xuICAgICAgICB0cmVlRGVwdGggPSBub2RlLmRlcHRoO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBleHBhbmRBbmRDb2xsYXBzZSA9IG9wdGlvbi5leHBhbmRBbmRDb2xsYXBzZTtcbiAgICB2YXIgZXhwYW5kVHJlZURlcHRoID0gZXhwYW5kQW5kQ29sbGFwc2UgJiYgb3B0aW9uLmluaXRpYWxUcmVlRGVwdGggPj0gMCA/IG9wdGlvbi5pbml0aWFsVHJlZURlcHRoIDogdHJlZURlcHRoO1xuICAgIHRyZWUucm9vdC5lYWNoTm9kZSgncHJlb3JkZXInLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGl0ZW0gPSBub2RlLmhvc3RUcmVlLmRhdGEuZ2V0UmF3RGF0YUl0ZW0obm9kZS5kYXRhSW5kZXgpO1xuICAgICAgLy8gQWRkIGl0ZW0uY29sbGFwc2VkICE9IG51bGwsIGJlY2F1c2UgdXNlcnMgY2FuIGNvbGxhcHNlIG5vZGUgb3JpZ2luYWwgaW4gdGhlIHNlcmllcy5kYXRhLlxuICAgICAgbm9kZS5pc0V4cGFuZCA9IGl0ZW0gJiYgaXRlbS5jb2xsYXBzZWQgIT0gbnVsbCA/ICFpdGVtLmNvbGxhcHNlZCA6IG5vZGUuZGVwdGggPD0gZXhwYW5kVHJlZURlcHRoO1xuICAgIH0pO1xuICAgIHJldHVybiB0cmVlLmRhdGE7XG4gIH07XG4gIC8qKlxyXG4gICAqIE1ha2UgdGhlIGNvbmZpZ3VyYXRpb24gJ29yaWVudCcgYmFja3dhcmQgY29tcGF0aWJseSwgd2l0aCAnaG9yaXpvbnRhbCA9IExSJywgJ3ZlcnRpY2FsID0gVEInLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IG9yaWVudFxyXG4gICAqL1xuICBUcmVlU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldE9yaWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JpZW50ID0gdGhpcy5nZXQoJ29yaWVudCcpO1xuICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgb3JpZW50ID0gJ0xSJztcbiAgICB9IGVsc2UgaWYgKG9yaWVudCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgb3JpZW50ID0gJ1RCJztcbiAgICB9XG4gICAgcmV0dXJuIG9yaWVudDtcbiAgfTtcbiAgVHJlZVNlcmllc01vZGVsLnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24gKHpvb20pIHtcbiAgICB0aGlzLm9wdGlvbi56b29tID0gem9vbTtcbiAgfTtcbiAgVHJlZVNlcmllc01vZGVsLnByb3RvdHlwZS5zZXRDZW50ZXIgPSBmdW5jdGlvbiAoY2VudGVyKSB7XG4gICAgdGhpcy5vcHRpb24uY2VudGVyID0gY2VudGVyO1xuICB9O1xuICBUcmVlU2VyaWVzTW9kZWwucHJvdG90eXBlLmZvcm1hdFRvb2x0aXAgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBtdWx0aXBsZVNlcmllcywgZGF0YVR5cGUpIHtcbiAgICB2YXIgdHJlZSA9IHRoaXMuZ2V0RGF0YSgpLnRyZWU7XG4gICAgdmFyIHJlYWxSb290ID0gdHJlZS5yb290LmNoaWxkcmVuWzBdO1xuICAgIHZhciBub2RlID0gdHJlZS5nZXROb2RlQnlEYXRhSW5kZXgoZGF0YUluZGV4KTtcbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldFZhbHVlKCk7XG4gICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gcmVhbFJvb3QpIHtcbiAgICAgIG5hbWUgPSBub2RlLnBhcmVudE5vZGUubmFtZSArICcuJyArIG5hbWU7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVG9vbHRpcE1hcmt1cCgnbmFtZVZhbHVlJywge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIG5vVmFsdWU6IGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PSBudWxsXG4gICAgfSk7XG4gIH07XG4gIC8vIEFkZCB0cmVlIHBhdGggdG8gdG9vbHRpcCBwYXJhbVxuICBUcmVlU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldERhdGFQYXJhbXMgPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgdmFyIHBhcmFtcyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0RGF0YVBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBub2RlID0gdGhpcy5nZXREYXRhKCkudHJlZS5nZXROb2RlQnlEYXRhSW5kZXgoZGF0YUluZGV4KTtcbiAgICBwYXJhbXMudHJlZUFuY2VzdG9ycyA9IHdyYXBUcmVlUGF0aEluZm8obm9kZSwgdGhpcyk7XG4gICAgcGFyYW1zLmNvbGxhcHNlZCA9ICFub2RlLmlzRXhwYW5kO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH07XG4gIFRyZWVTZXJpZXNNb2RlbC50eXBlID0gJ3Nlcmllcy50cmVlJztcbiAgLy8gY2FuIHN1cHBvcnQgdGhlIHBvc2l0aW9uIHBhcmFtZXRlcnMgJ2xlZnQnLCAndG9wJywncmlnaHQnLCdib3R0b20nLCAnd2lkdGgnLFxuICAvLyAnaGVpZ2h0JyBpbiB0aGUgc2V0T3B0aW9uKCkgd2l0aCAnbWVyZ2UnIG1vZGUgbm9ybWFsLlxuICBUcmVlU2VyaWVzTW9kZWwubGF5b3V0TW9kZSA9ICdib3gnO1xuICBUcmVlU2VyaWVzTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAvLyB6bGV2ZWw6IDAsXG4gICAgejogMixcbiAgICBjb29yZGluYXRlU3lzdGVtOiAndmlldycsXG4gICAgLy8gdGhlIHBvc2l0aW9uIG9mIHRoZSB3aG9sZSB2aWV3XG4gICAgbGVmdDogJzEyJScsXG4gICAgdG9wOiAnMTIlJyxcbiAgICByaWdodDogJzEyJScsXG4gICAgYm90dG9tOiAnMTIlJyxcbiAgICAvLyB0aGUgbGF5b3V0IG9mIHRoZSB0cmVlLCB0d28gdmFsdWUgY2FuIGJlIHNlbGVjdGVkLCAnb3J0aG9nb25hbCcgb3IgJ3JhZGlhbCdcbiAgICBsYXlvdXQ6ICdvcnRob2dvbmFsJyxcbiAgICAvLyB2YWx1ZSBjYW4gYmUgJ3BvbHlsaW5lJ1xuICAgIGVkZ2VTaGFwZTogJ2N1cnZlJyxcbiAgICBlZGdlRm9ya1Bvc2l0aW9uOiAnNTAlJyxcbiAgICAvLyB0cnVlIHwgZmFsc2UgfCAnbW92ZScgfCAnc2NhbGUnLCBzZWUgbW9kdWxlOmNvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXIuXG4gICAgcm9hbTogZmFsc2UsXG4gICAgLy8gU3ltYm9sIHNpemUgc2NhbGUgcmF0aW8gaW4gcm9hbVxuICAgIG5vZGVTY2FsZVJhdGlvOiAwLjQsXG4gICAgLy8gRGVmYXVsdCBvbiBjZW50ZXIgb2YgZ3JhcGhcbiAgICBjZW50ZXI6IG51bGwsXG4gICAgem9vbTogMSxcbiAgICBvcmllbnQ6ICdMUicsXG4gICAgc3ltYm9sOiAnZW1wdHlDaXJjbGUnLFxuICAgIHN5bWJvbFNpemU6IDcsXG4gICAgZXhwYW5kQW5kQ29sbGFwc2U6IHRydWUsXG4gICAgaW5pdGlhbFRyZWVEZXB0aDogMixcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnI2NjYycsXG4gICAgICB3aWR0aDogMS41LFxuICAgICAgY3VydmVuZXNzOiAwLjVcbiAgICB9LFxuICAgIGl0ZW1TdHlsZToge1xuICAgICAgY29sb3I6ICdsaWdodHN0ZWVsYmx1ZScsXG4gICAgICAvLyBib3JkZXJDb2xvcjogJyNjMjM1MzEnLFxuICAgICAgYm9yZGVyV2lkdGg6IDEuNVxuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgIHNob3c6IHRydWVcbiAgICB9LFxuICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcicsXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDcwMCxcbiAgICBhbmltYXRpb25EdXJhdGlvblVwZGF0ZTogNTAwXG4gIH07XG4gIHJldHVybiBUcmVlU2VyaWVzTW9kZWw7XG59KFNlcmllc01vZGVsKTtcbmV4cG9ydCBkZWZhdWx0IFRyZWVTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbi8qKlxyXG4gKiBUcmF2ZXJzZSB0aGUgdHJlZSBmcm9tIGJvdHRvbSB0byB0b3AgYW5kIGRvIHNvbWV0aGluZ1xyXG4gKi9cbmZ1bmN0aW9uIGVhY2hBZnRlcihyb290LCBjYWxsYmFjaywgc2VwYXJhdGlvbikge1xuICB2YXIgbm9kZXMgPSBbcm9vdF07XG4gIHZhciBuZXh0ID0gW107XG4gIHZhciBub2RlO1xuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgbmV4dC5wdXNoKG5vZGUpO1xuICAgIGlmIChub2RlLmlzRXhwYW5kKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgd2hpbGUgKG5vZGUgPSBuZXh0LnBvcCgpKSB7XG4gICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgY2FsbGJhY2sobm9kZSwgc2VwYXJhdGlvbik7XG4gIH1cbn1cbi8qKlxyXG4gKiBUcmF2ZXJzZSB0aGUgdHJlZSBmcm9tIHRvcCB0byBib3R0b20gYW5kIGRvIHNvbWV0aGluZ1xyXG4gKi9cbmZ1bmN0aW9uIGVhY2hCZWZvcmUocm9vdCwgY2FsbGJhY2spIHtcbiAgdmFyIG5vZGVzID0gW3Jvb3RdO1xuICB2YXIgbm9kZTtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIGNhbGxiYWNrKG5vZGUpO1xuICAgIGlmIChub2RlLmlzRXhwYW5kKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZXhwb3J0IHsgZWFjaEFmdGVyLCBlYWNoQmVmb3JlIH07IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBlYWNoQWZ0ZXIsIGVhY2hCZWZvcmUgfSBmcm9tICcuL3RyYXZlcnNhbEhlbHBlci5qcyc7XG5pbXBvcnQgeyBpbml0LCBmaXJzdFdhbGssIHNlY29uZFdhbGssIHNlcGFyYXRpb24gYXMgc2VwLCByYWRpYWxDb29yZGluYXRlLCBnZXRWaWV3UmVjdCB9IGZyb20gJy4vbGF5b3V0SGVscGVyLmpzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyZWVMYXlvdXQoZWNNb2RlbCwgYXBpKSB7XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgndHJlZScsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIGNvbW1vbkxheW91dChzZXJpZXNNb2RlbCwgYXBpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjb21tb25MYXlvdXQoc2VyaWVzTW9kZWwsIGFwaSkge1xuICB2YXIgbGF5b3V0SW5mbyA9IGdldFZpZXdSZWN0KHNlcmllc01vZGVsLCBhcGkpO1xuICBzZXJpZXNNb2RlbC5sYXlvdXRJbmZvID0gbGF5b3V0SW5mbztcbiAgdmFyIGxheW91dCA9IHNlcmllc01vZGVsLmdldCgnbGF5b3V0Jyk7XG4gIHZhciB3aWR0aCA9IDA7XG4gIHZhciBoZWlnaHQgPSAwO1xuICB2YXIgc2VwYXJhdGlvbiA9IG51bGw7XG4gIGlmIChsYXlvdXQgPT09ICdyYWRpYWwnKSB7XG4gICAgd2lkdGggPSAyICogTWF0aC5QSTtcbiAgICBoZWlnaHQgPSBNYXRoLm1pbihsYXlvdXRJbmZvLmhlaWdodCwgbGF5b3V0SW5mby53aWR0aCkgLyAyO1xuICAgIHNlcGFyYXRpb24gPSBzZXAoZnVuY3Rpb24gKG5vZGUxLCBub2RlMikge1xuICAgICAgcmV0dXJuIChub2RlMS5wYXJlbnROb2RlID09PSBub2RlMi5wYXJlbnROb2RlID8gMSA6IDIpIC8gbm9kZTEuZGVwdGg7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgd2lkdGggPSBsYXlvdXRJbmZvLndpZHRoO1xuICAgIGhlaWdodCA9IGxheW91dEluZm8uaGVpZ2h0O1xuICAgIHNlcGFyYXRpb24gPSBzZXAoKTtcbiAgfVxuICB2YXIgdmlydHVhbFJvb3QgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCkudHJlZS5yb290O1xuICB2YXIgcmVhbFJvb3QgPSB2aXJ0dWFsUm9vdC5jaGlsZHJlblswXTtcbiAgaWYgKHJlYWxSb290KSB7XG4gICAgaW5pdCh2aXJ0dWFsUm9vdCk7XG4gICAgZWFjaEFmdGVyKHJlYWxSb290LCBmaXJzdFdhbGssIHNlcGFyYXRpb24pO1xuICAgIHZpcnR1YWxSb290LmhpZXJOb2RlLm1vZGlmaWVyID0gLXJlYWxSb290LmhpZXJOb2RlLnByZWxpbTtcbiAgICBlYWNoQmVmb3JlKHJlYWxSb290LCBzZWNvbmRXYWxrKTtcbiAgICB2YXIgbGVmdF8xID0gcmVhbFJvb3Q7XG4gICAgdmFyIHJpZ2h0XzEgPSByZWFsUm9vdDtcbiAgICB2YXIgYm90dG9tXzEgPSByZWFsUm9vdDtcbiAgICBlYWNoQmVmb3JlKHJlYWxSb290LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIHggPSBub2RlLmdldExheW91dCgpLng7XG4gICAgICBpZiAoeCA8IGxlZnRfMS5nZXRMYXlvdXQoKS54KSB7XG4gICAgICAgIGxlZnRfMSA9IG5vZGU7XG4gICAgICB9XG4gICAgICBpZiAoeCA+IHJpZ2h0XzEuZ2V0TGF5b3V0KCkueCkge1xuICAgICAgICByaWdodF8xID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmRlcHRoID4gYm90dG9tXzEuZGVwdGgpIHtcbiAgICAgICAgYm90dG9tXzEgPSBub2RlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBkZWx0YSA9IGxlZnRfMSA9PT0gcmlnaHRfMSA/IDEgOiBzZXBhcmF0aW9uKGxlZnRfMSwgcmlnaHRfMSkgLyAyO1xuICAgIHZhciB0eF8xID0gZGVsdGEgLSBsZWZ0XzEuZ2V0TGF5b3V0KCkueDtcbiAgICB2YXIga3hfMSA9IDA7XG4gICAgdmFyIGt5XzEgPSAwO1xuICAgIHZhciBjb29yWF8xID0gMDtcbiAgICB2YXIgY29vcllfMSA9IDA7XG4gICAgaWYgKGxheW91dCA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgIGt4XzEgPSB3aWR0aCAvIChyaWdodF8xLmdldExheW91dCgpLnggKyBkZWx0YSArIHR4XzEpO1xuICAgICAgLy8gaGVyZSB3ZSB1c2UgKG5vZGUuZGVwdGggLSAxKSwgYnVjYXVzZSB0aGUgcmVhbCByb290J3MgZGVwdGggaXMgMVxuICAgICAga3lfMSA9IGhlaWdodCAvIChib3R0b21fMS5kZXB0aCAtIDEgfHwgMSk7XG4gICAgICBlYWNoQmVmb3JlKHJlYWxSb290LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBjb29yWF8xID0gKG5vZGUuZ2V0TGF5b3V0KCkueCArIHR4XzEpICoga3hfMTtcbiAgICAgICAgY29vcllfMSA9IChub2RlLmRlcHRoIC0gMSkgKiBreV8xO1xuICAgICAgICB2YXIgZmluYWxDb29yID0gcmFkaWFsQ29vcmRpbmF0ZShjb29yWF8xLCBjb29yWV8xKTtcbiAgICAgICAgbm9kZS5zZXRMYXlvdXQoe1xuICAgICAgICAgIHg6IGZpbmFsQ29vci54LFxuICAgICAgICAgIHk6IGZpbmFsQ29vci55LFxuICAgICAgICAgIHJhd1g6IGNvb3JYXzEsXG4gICAgICAgICAgcmF3WTogY29vcllfMVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3JpZW50XzEgPSBzZXJpZXNNb2RlbC5nZXRPcmllbnQoKTtcbiAgICAgIGlmIChvcmllbnRfMSA9PT0gJ1JMJyB8fCBvcmllbnRfMSA9PT0gJ0xSJykge1xuICAgICAgICBreV8xID0gaGVpZ2h0IC8gKHJpZ2h0XzEuZ2V0TGF5b3V0KCkueCArIGRlbHRhICsgdHhfMSk7XG4gICAgICAgIGt4XzEgPSB3aWR0aCAvIChib3R0b21fMS5kZXB0aCAtIDEgfHwgMSk7XG4gICAgICAgIGVhY2hCZWZvcmUocmVhbFJvb3QsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgY29vcllfMSA9IChub2RlLmdldExheW91dCgpLnggKyB0eF8xKSAqIGt5XzE7XG4gICAgICAgICAgY29vclhfMSA9IG9yaWVudF8xID09PSAnTFInID8gKG5vZGUuZGVwdGggLSAxKSAqIGt4XzEgOiB3aWR0aCAtIChub2RlLmRlcHRoIC0gMSkgKiBreF8xO1xuICAgICAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgICAgIHg6IGNvb3JYXzEsXG4gICAgICAgICAgICB5OiBjb29yWV8xXG4gICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvcmllbnRfMSA9PT0gJ1RCJyB8fCBvcmllbnRfMSA9PT0gJ0JUJykge1xuICAgICAgICBreF8xID0gd2lkdGggLyAocmlnaHRfMS5nZXRMYXlvdXQoKS54ICsgZGVsdGEgKyB0eF8xKTtcbiAgICAgICAga3lfMSA9IGhlaWdodCAvIChib3R0b21fMS5kZXB0aCAtIDEgfHwgMSk7XG4gICAgICAgIGVhY2hCZWZvcmUocmVhbFJvb3QsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgY29vclhfMSA9IChub2RlLmdldExheW91dCgpLnggKyB0eF8xKSAqIGt4XzE7XG4gICAgICAgICAgY29vcllfMSA9IG9yaWVudF8xID09PSAnVEInID8gKG5vZGUuZGVwdGggLSAxKSAqIGt5XzEgOiBoZWlnaHQgLSAobm9kZS5kZXB0aCAtIDEpICoga3lfMTtcbiAgICAgICAgICBub2RlLnNldExheW91dCh7XG4gICAgICAgICAgICB4OiBjb29yWF8xLFxuICAgICAgICAgICAgeTogY29vcllfMVxuICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmVlVmlzdWFsKGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCd0cmVlJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHRyZWUgPSBkYXRhLnRyZWU7XG4gICAgdHJlZS5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIG1vZGVsID0gbm9kZS5nZXRNb2RlbCgpO1xuICAgICAgLy8gVE9ETyBPcHRpbWl6ZVxuICAgICAgdmFyIHN0eWxlID0gbW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgdmFyIGV4aXN0c1N0eWxlID0gZGF0YS5lbnN1cmVVbmlxdWVJdGVtVmlzdWFsKG5vZGUuZGF0YUluZGV4LCAnc3R5bGUnKTtcbiAgICAgIGV4dGVuZChleGlzdHNTdHlsZSwgc3R5bGUpO1xuICAgIH0pO1xuICB9KTtcbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IHVwZGF0ZUNlbnRlckFuZFpvb20gfSBmcm9tICcuLi8uLi9hY3Rpb24vcm9hbUhlbHBlci5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbFRyZWVBY3Rpb24ocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogJ3RyZWVFeHBhbmRBbmRDb2xsYXBzZScsXG4gICAgZXZlbnQ6ICd0cmVlRXhwYW5kQW5kQ29sbGFwc2UnLFxuICAgIHVwZGF0ZTogJ3VwZGF0ZSdcbiAgfSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6ICdzZXJpZXMnLFxuICAgICAgc3ViVHlwZTogJ3RyZWUnLFxuICAgICAgcXVlcnk6IHBheWxvYWRcbiAgICB9LCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHZhciBkYXRhSW5kZXggPSBwYXlsb2FkLmRhdGFJbmRleDtcbiAgICAgIHZhciB0cmVlID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLnRyZWU7XG4gICAgICB2YXIgbm9kZSA9IHRyZWUuZ2V0Tm9kZUJ5RGF0YUluZGV4KGRhdGFJbmRleCk7XG4gICAgICBub2RlLmlzRXhwYW5kID0gIW5vZGUuaXNFeHBhbmQ7XG4gICAgfSk7XG4gIH0pO1xuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgIHR5cGU6ICd0cmVlUm9hbScsXG4gICAgZXZlbnQ6ICd0cmVlUm9hbScsXG4gICAgLy8gSGVyZSB3ZSBzZXQgJ25vbmUnIGluc3RlYWQgb2YgJ3VwZGF0ZScsIGJlY2F1c2Ugcm9hbSBhY3Rpb25cbiAgICAvLyBqdXN0IG5lZWQgdG8gdXBkYXRlIHRoZSB0cmFuc2Zvcm0gbWF0cml4IHdpdGhvdXQgaGF2aW5nIHRvIHJlY2FsY3VsYXRlXG4gICAgLy8gdGhlIGxheW91dC4gU28gZG9uJ3QgbmVlZCB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSB1cGRhdGUgcHJvY2Vzcywgc3VjaFxuICAgIC8vIGFzICdkYXRhUHJjb2Nlc3MnLCAnY29vcmRTeXN0ZW1VcGRhdGUnLCAnbGF5b3V0JyBhbmQgc28gb24uXG4gICAgdXBkYXRlOiAnbm9uZSdcbiAgfSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwsIGFwaSkge1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICBtYWluVHlwZTogJ3NlcmllcycsXG4gICAgICBzdWJUeXBlOiAndHJlZScsXG4gICAgICBxdWVyeTogcGF5bG9hZFxuICAgIH0sIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgIHZhciByZXMgPSB1cGRhdGVDZW50ZXJBbmRab29tKGNvb3JkU3lzLCBwYXlsb2FkLCB1bmRlZmluZWQsIGFwaSk7XG4gICAgICBzZXJpZXNNb2RlbC5zZXRDZW50ZXIgJiYgc2VyaWVzTW9kZWwuc2V0Q2VudGVyKHJlcy5jZW50ZXIpO1xuICAgICAgc2VyaWVzTW9kZWwuc2V0Wm9vbSAmJiBzZXJpZXNNb2RlbC5zZXRab29tKHJlcy56b29tKTtcbiAgICB9KTtcbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgVHJlZVZpZXcgZnJvbSAnLi9UcmVlVmlldy5qcyc7XG5pbXBvcnQgVHJlZVNlcmllc01vZGVsIGZyb20gJy4vVHJlZVNlcmllcy5qcyc7XG5pbXBvcnQgdHJlZUxheW91dCBmcm9tICcuL3RyZWVMYXlvdXQuanMnO1xuaW1wb3J0IHRyZWVWaXN1YWwgZnJvbSAnLi90cmVlVmlzdWFsLmpzJztcbmltcG9ydCB7IGluc3RhbGxUcmVlQWN0aW9uIH0gZnJvbSAnLi90cmVlQWN0aW9uLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDaGFydFZpZXcoVHJlZVZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChUcmVlU2VyaWVzTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQodHJlZUxheW91dCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclZpc3VhbCh0cmVlVmlzdWFsKTtcbiAgaW5zdGFsbFRyZWVBY3Rpb24ocmVnaXN0ZXJzKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31441\n")},44710:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Sector.js + 1 modules\nvar Sector = __webpack_require__(25014);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/sectorHelper.js\nvar sectorHelper = __webpack_require__(79446);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/decal.js\nvar util_decal = __webpack_require__(23538);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/contain/util.js\nvar contain_util = __webpack_require__(41589);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n;// ./node_modules/echarts/lib/chart/sunburst/SunburstPiece.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\nvar DEFAULT_SECTOR_Z = 2;\nvar DEFAULT_TEXT_Z = 4;\n/**\r\n * Sunburstce of Sunburst including Sector, Label, LabelLine\r\n */\nvar SunburstPiece = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(SunburstPiece, _super);\n  function SunburstPiece(node, seriesModel, ecModel, api) {\n    var _this = _super.call(this) || this;\n    _this.z2 = DEFAULT_SECTOR_Z;\n    _this.textConfig = {\n      inside: true\n    };\n    (0,innerStore/* getECData */.z)(_this).seriesIndex = seriesModel.seriesIndex;\n    var text = new Text/* default */.Ay({\n      z2: DEFAULT_TEXT_Z,\n      silent: node.getModel().get(['label', 'silent'])\n    });\n    _this.setTextContent(text);\n    _this.updateData(true, node, seriesModel, ecModel, api);\n    return _this;\n  }\n  SunburstPiece.prototype.updateData = function (firstCreate, node,\n  // state: 'emphasis' | 'normal' | 'highlight' | 'downplay',\n  seriesModel, ecModel, api) {\n    this.node = node;\n    node.piece = this;\n    seriesModel = seriesModel || this._seriesModel;\n    ecModel = ecModel || this._ecModel;\n    var sector = this;\n    (0,innerStore/* getECData */.z)(sector).dataIndex = node.dataIndex;\n    var itemModel = node.getModel();\n    var emphasisModel = itemModel.getModel('emphasis');\n    var layout = node.getLayout();\n    var sectorShape = util.extend({}, layout);\n    sectorShape.label = null;\n    var normalStyle = node.getVisual('style');\n    normalStyle.lineJoin = 'bevel';\n    var decal = node.getVisual('decal');\n    if (decal) {\n      normalStyle.decal = (0,util_decal/* createOrUpdatePatternFromDecal */.w)(decal, api);\n    }\n    var cornerRadius = (0,sectorHelper/* getSectorCornerRadius */.i)(itemModel.getModel('itemStyle'), sectorShape, true);\n    util.extend(sectorShape, cornerRadius);\n    util.each(states/* SPECIAL_STATES */.BV, function (stateName) {\n      var state = sector.ensureState(stateName);\n      var itemStyleModel = itemModel.getModel([stateName, 'itemStyle']);\n      state.style = itemStyleModel.getItemStyle();\n      // border radius\n      var cornerRadius = (0,sectorHelper/* getSectorCornerRadius */.i)(itemStyleModel, sectorShape);\n      if (cornerRadius) {\n        state.shape = cornerRadius;\n      }\n    });\n    if (firstCreate) {\n      sector.setShape(sectorShape);\n      sector.shape.r = layout.r0;\n      basicTransition/* initProps */.LW(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, node.dataIndex);\n    } else {\n      // Disable animation for gradient since no interpolation method\n      // is supported for gradient\n      basicTransition/* updateProps */.oi(sector, {\n        shape: sectorShape\n      }, seriesModel);\n      (0,basicTransition/* saveOldStyle */.ap)(sector);\n    }\n    sector.useStyle(normalStyle);\n    this._updateLabel(seriesModel);\n    var cursorStyle = itemModel.getShallow('cursor');\n    cursorStyle && sector.attr('cursor', cursorStyle);\n    this._seriesModel = seriesModel || this._seriesModel;\n    this._ecModel = ecModel || this._ecModel;\n    var focus = emphasisModel.get('focus');\n    var focusOrIndices = focus === 'relative' ? util.concatArray(node.getAncestorsIndices(), node.getDescendantIndices()) : focus === 'ancestor' ? node.getAncestorsIndices() : focus === 'descendant' ? node.getDescendantIndices() : focus;\n    (0,states/* toggleHoverEmphasis */.Lm)(this, focusOrIndices, emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n  };\n  SunburstPiece.prototype._updateLabel = function (seriesModel) {\n    var _this = this;\n    var itemModel = this.node.getModel();\n    var normalLabelModel = itemModel.getModel('label');\n    var layout = this.node.getLayout();\n    var angle = layout.endAngle - layout.startAngle;\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var sector = this;\n    var label = sector.getTextContent();\n    var dataIndex = this.node.dataIndex;\n    var labelMinAngle = normalLabelModel.get('minAngle') / 180 * Math.PI;\n    var isNormalShown = normalLabelModel.get('show') && !(labelMinAngle != null && Math.abs(angle) < labelMinAngle);\n    label.ignore = !isNormalShown;\n    // TODO use setLabelStyle\n    util.each(states/* DISPLAY_STATES */.wV, function (stateName) {\n      var labelStateModel = stateName === 'normal' ? itemModel.getModel('label') : itemModel.getModel([stateName, 'label']);\n      var isNormal = stateName === 'normal';\n      var state = isNormal ? label : label.ensureState(stateName);\n      var text = seriesModel.getFormattedLabel(dataIndex, stateName);\n      if (isNormal) {\n        text = text || _this.node.name;\n      }\n      state.style = (0,labelStyle/* createTextStyle */.VB)(labelStateModel, {}, null, stateName !== 'normal', true);\n      if (text) {\n        state.style.text = text;\n      }\n      // Not displaying text when angle is too small\n      var isShown = labelStateModel.get('show');\n      if (isShown != null && !isNormal) {\n        state.ignore = !isShown;\n      }\n      var labelPosition = getLabelAttr(labelStateModel, 'position');\n      var sectorState = isNormal ? sector : sector.states[stateName];\n      var labelColor = sectorState.style.fill;\n      sectorState.textConfig = {\n        outsideFill: labelStateModel.get('color') === 'inherit' ? labelColor : null,\n        inside: labelPosition !== 'outside'\n      };\n      var r;\n      var labelPadding = getLabelAttr(labelStateModel, 'distance') || 0;\n      var textAlign = getLabelAttr(labelStateModel, 'align');\n      var rotateType = getLabelAttr(labelStateModel, 'rotate');\n      var flipStartAngle = Math.PI * 0.5;\n      var flipEndAngle = Math.PI * 1.5;\n      var midAngleNormal = (0,contain_util/* normalizeRadian */.n)(rotateType === 'tangential' ? Math.PI / 2 - midAngle : midAngle);\n      // For text that is up-side down, rotate 180 degrees to make sure\n      // it's readable\n      var needsFlip = midAngleNormal > flipStartAngle && !(0,number/* isRadianAroundZero */.dh)(midAngleNormal - flipStartAngle) && midAngleNormal < flipEndAngle;\n      if (labelPosition === 'outside') {\n        r = layout.r + labelPadding;\n        textAlign = needsFlip ? 'right' : 'left';\n      } else {\n        if (!textAlign || textAlign === 'center') {\n          // Put label in the center if it's a circle\n          if (angle === 2 * Math.PI && layout.r0 === 0) {\n            r = 0;\n          } else {\n            r = (layout.r + layout.r0) / 2;\n          }\n          textAlign = 'center';\n        } else if (textAlign === 'left') {\n          r = layout.r0 + labelPadding;\n          textAlign = needsFlip ? 'right' : 'left';\n        } else if (textAlign === 'right') {\n          r = layout.r - labelPadding;\n          textAlign = needsFlip ? 'left' : 'right';\n        }\n      }\n      state.style.align = textAlign;\n      state.style.verticalAlign = getLabelAttr(labelStateModel, 'verticalAlign') || 'middle';\n      state.x = r * dx + layout.cx;\n      state.y = r * dy + layout.cy;\n      var rotate = 0;\n      if (rotateType === 'radial') {\n        rotate = (0,contain_util/* normalizeRadian */.n)(-midAngle) + (needsFlip ? Math.PI : 0);\n      } else if (rotateType === 'tangential') {\n        rotate = (0,contain_util/* normalizeRadian */.n)(Math.PI / 2 - midAngle) + (needsFlip ? Math.PI : 0);\n      } else if (util.isNumber(rotateType)) {\n        rotate = rotateType * Math.PI / 180;\n      }\n      state.rotation = (0,contain_util/* normalizeRadian */.n)(rotate);\n    });\n    function getLabelAttr(model, name) {\n      var stateAttr = model.get(name);\n      if (stateAttr == null) {\n        return normalLabelModel.get(name);\n      }\n      return stateAttr;\n    }\n    label.dirtyStyle();\n  };\n  return SunburstPiece;\n}(Sector/* default */.A);\n/* harmony default export */ const sunburst_SunburstPiece = (SunburstPiece);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/DataDiffer.js\nvar DataDiffer = __webpack_require__(16563);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/treeHelper.js\nvar treeHelper = __webpack_require__(41616);\n;// ./node_modules/echarts/lib/chart/sunburst/sunburstAction.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar ROOT_TO_NODE_ACTION = 'sunburstRootToNode';\nvar HIGHLIGHT_ACTION = 'sunburstHighlight';\nvar UNHIGHLIGHT_ACTION = 'sunburstUnhighlight';\nfunction installSunburstAction(registers) {\n  registers.registerAction({\n    type: ROOT_TO_NODE_ACTION,\n    update: 'updateView'\n  }, function (payload, ecModel) {\n    ecModel.eachComponent({\n      mainType: 'series',\n      subType: 'sunburst',\n      query: payload\n    }, handleRootToNode);\n    function handleRootToNode(model, index) {\n      var targetInfo = (0,treeHelper/* retrieveTargetInfo */.mw)(payload, [ROOT_TO_NODE_ACTION], model);\n      if (targetInfo) {\n        var originViewRoot = model.getViewRoot();\n        if (originViewRoot) {\n          payload.direction = (0,treeHelper/* aboveViewRoot */.x5)(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown';\n        }\n        model.resetViewRoot(targetInfo.node);\n      }\n    }\n  });\n  registers.registerAction({\n    type: HIGHLIGHT_ACTION,\n    update: 'none'\n  }, function (payload, ecModel, api) {\n    // Clone\n    payload = (0,util.extend)({}, payload);\n    ecModel.eachComponent({\n      mainType: 'series',\n      subType: 'sunburst',\n      query: payload\n    }, handleHighlight);\n    function handleHighlight(model) {\n      var targetInfo = (0,treeHelper/* retrieveTargetInfo */.mw)(payload, [HIGHLIGHT_ACTION], model);\n      if (targetInfo) {\n        payload.dataIndex = targetInfo.node.dataIndex;\n      }\n    }\n    if (false) {}\n    // Fast forward action\n    api.dispatchAction((0,util.extend)(payload, {\n      type: 'highlight'\n    }));\n  });\n  registers.registerAction({\n    type: UNHIGHLIGHT_ACTION,\n    update: 'updateView'\n  }, function (payload, ecModel, api) {\n    payload = (0,util.extend)({}, payload);\n    if (false) {}\n    api.dispatchAction((0,util.extend)(payload, {\n      type: 'downplay'\n    }));\n  });\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/format.js\nvar format = __webpack_require__(83412);\n;// ./node_modules/echarts/lib/chart/sunburst/SunburstView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar SunburstView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(SunburstView, _super);\n  function SunburstView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = SunburstView.type;\n    return _this;\n  }\n  SunburstView.prototype.render = function (seriesModel, ecModel, api,\n  // @ts-ignore\n  payload) {\n    var self = this;\n    this.seriesModel = seriesModel;\n    this.api = api;\n    this.ecModel = ecModel;\n    var data = seriesModel.getData();\n    var virtualRoot = data.tree.root;\n    var newRoot = seriesModel.getViewRoot();\n    var group = this.group;\n    var renderLabelForZeroData = seriesModel.get('renderLabelForZeroData');\n    var newChildren = [];\n    newRoot.eachNode(function (node) {\n      newChildren.push(node);\n    });\n    var oldChildren = this._oldChildren || [];\n    dualTravel(newChildren, oldChildren);\n    renderRollUp(virtualRoot, newRoot);\n    this._initEvents();\n    this._oldChildren = newChildren;\n    function dualTravel(newChildren, oldChildren) {\n      if (newChildren.length === 0 && oldChildren.length === 0) {\n        return;\n      }\n      new DataDiffer/* default */.A(oldChildren, newChildren, getKey, getKey).add(processNode).update(processNode).remove(util.curry(processNode, null)).execute();\n      function getKey(node) {\n        return node.getId();\n      }\n      function processNode(newIdx, oldIdx) {\n        var newNode = newIdx == null ? null : newChildren[newIdx];\n        var oldNode = oldIdx == null ? null : oldChildren[oldIdx];\n        doRenderNode(newNode, oldNode);\n      }\n    }\n    function doRenderNode(newNode, oldNode) {\n      if (!renderLabelForZeroData && newNode && !newNode.getValue()) {\n        // Not render data with value 0\n        newNode = null;\n      }\n      if (newNode !== virtualRoot && oldNode !== virtualRoot) {\n        if (oldNode && oldNode.piece) {\n          if (newNode) {\n            // Update\n            oldNode.piece.updateData(false, newNode, seriesModel, ecModel, api);\n            // For tooltip\n            data.setItemGraphicEl(newNode.dataIndex, oldNode.piece);\n          } else {\n            // Remove\n            removeNode(oldNode);\n          }\n        } else if (newNode) {\n          // Add\n          var piece = new sunburst_SunburstPiece(newNode, seriesModel, ecModel, api);\n          group.add(piece);\n          // For tooltip\n          data.setItemGraphicEl(newNode.dataIndex, piece);\n        }\n      }\n    }\n    function removeNode(node) {\n      if (!node) {\n        return;\n      }\n      if (node.piece) {\n        group.remove(node.piece);\n        node.piece = null;\n      }\n    }\n    function renderRollUp(virtualRoot, viewRoot) {\n      if (viewRoot.depth > 0) {\n        // Render\n        if (self.virtualPiece) {\n          // Update\n          self.virtualPiece.updateData(false, virtualRoot, seriesModel, ecModel, api);\n        } else {\n          // Add\n          self.virtualPiece = new sunburst_SunburstPiece(virtualRoot, seriesModel, ecModel, api);\n          group.add(self.virtualPiece);\n        }\n        // TODO event scope\n        viewRoot.piece.off('click');\n        self.virtualPiece.on('click', function (e) {\n          self._rootToNode(viewRoot.parentNode);\n        });\n      } else if (self.virtualPiece) {\n        // Remove\n        group.remove(self.virtualPiece);\n        self.virtualPiece = null;\n      }\n    }\n  };\n  /**\r\n   * @private\r\n   */\n  SunburstView.prototype._initEvents = function () {\n    var _this = this;\n    this.group.off('click');\n    this.group.on('click', function (e) {\n      var targetFound = false;\n      var viewRoot = _this.seriesModel.getViewRoot();\n      viewRoot.eachNode(function (node) {\n        if (!targetFound && node.piece && node.piece === e.target) {\n          var nodeClick = node.getModel().get('nodeClick');\n          if (nodeClick === 'rootToNode') {\n            _this._rootToNode(node);\n          } else if (nodeClick === 'link') {\n            var itemModel = node.getModel();\n            var link = itemModel.get('link');\n            if (link) {\n              var linkTarget = itemModel.get('target', true) || '_blank';\n              (0,format/* windowOpen */.JW)(link, linkTarget);\n            }\n          }\n          targetFound = true;\n        }\n      });\n    });\n  };\n  /**\r\n   * @private\r\n   */\n  SunburstView.prototype._rootToNode = function (node) {\n    if (node !== this.seriesModel.getViewRoot()) {\n      this.api.dispatchAction({\n        type: ROOT_TO_NODE_ACTION,\n        from: this.uid,\n        seriesId: this.seriesModel.id,\n        targetNode: node\n      });\n    }\n  };\n  /**\r\n   * @implement\r\n   */\n  SunburstView.prototype.containPoint = function (point, seriesModel) {\n    var treeRoot = seriesModel.getData();\n    var itemLayout = treeRoot.getItemLayout(0);\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  };\n  SunburstView.type = 'sunburst';\n  return SunburstView;\n}(Chart/* default */.A);\n/* harmony default export */ const sunburst_SunburstView = (SunburstView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/Tree.js\nvar Tree = __webpack_require__(15719);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Model.js + 2 modules\nvar Model = __webpack_require__(43172);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/enableAriaDecalForTree.js\nvar enableAriaDecalForTree = __webpack_require__(68866);\n;// ./node_modules/echarts/lib/chart/sunburst/SunburstSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar SunburstSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(SunburstSeriesModel, _super);\n  function SunburstSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = SunburstSeriesModel.type;\n    _this.ignoreStyleOnData = true;\n    return _this;\n  }\n  SunburstSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    // Create a virtual root.\n    var root = {\n      name: option.name,\n      children: option.data\n    };\n    completeTreeValue(root);\n    var levelModels = this._levelModels = util.map(option.levels || [], function (levelDefine) {\n      return new Model/* default */.A(levelDefine, this, ecModel);\n    }, this);\n    // Make sure always a new tree is created when setOption,\n    // in TreemapView, we check whether oldTree === newTree\n    // to choose mappings approach among old shapes and new shapes.\n    var tree = Tree/* default */.A.createTree(root, this, beforeLink);\n    function beforeLink(nodeData) {\n      nodeData.wrapMethod('getItemModel', function (model, idx) {\n        var node = tree.getNodeByDataIndex(idx);\n        var levelModel = levelModels[node.depth];\n        levelModel && (model.parentModel = levelModel);\n        return model;\n      });\n    }\n    return tree.data;\n  };\n  SunburstSeriesModel.prototype.optionUpdated = function () {\n    this.resetViewRoot();\n  };\n  /*\r\n   * @override\r\n   */\n  SunburstSeriesModel.prototype.getDataParams = function (dataIndex) {\n    var params = _super.prototype.getDataParams.apply(this, arguments);\n    var node = this.getData().tree.getNodeByDataIndex(dataIndex);\n    params.treePathInfo = (0,treeHelper/* wrapTreePathInfo */.ev)(node, this);\n    return params;\n  };\n  SunburstSeriesModel.prototype.getLevelModel = function (node) {\n    return this._levelModels && this._levelModels[node.depth];\n  };\n  SunburstSeriesModel.prototype.getViewRoot = function () {\n    return this._viewRoot;\n  };\n  SunburstSeriesModel.prototype.resetViewRoot = function (viewRoot) {\n    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;\n    var root = this.getRawData().tree.root;\n    if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {\n      this._viewRoot = root;\n    }\n  };\n  SunburstSeriesModel.prototype.enableAriaDecal = function () {\n    (0,enableAriaDecalForTree/* default */.A)(this);\n  };\n  SunburstSeriesModel.type = 'series.sunburst';\n  SunburstSeriesModel.defaultOption = {\n    // zlevel: 0,\n    z: 2,\n    // 默认全局居中\n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // 默认顺时针\n    clockwise: true,\n    startAngle: 90,\n    // 最小角度改为0\n    minAngle: 0,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // 'rootToNode', 'link', or false\n    nodeClick: 'rootToNode',\n    renderLabelForZeroData: false,\n    label: {\n      // could be: 'radial', 'tangential', or 'none'\n      rotate: 'radial',\n      show: true,\n      opacity: 1,\n      // 'left' is for inner side of inside, and 'right' is for outer\n      // side for inside\n      align: 'center',\n      position: 'inside',\n      distance: 5,\n      silent: true\n    },\n    itemStyle: {\n      borderWidth: 1,\n      borderColor: 'white',\n      borderType: 'solid',\n      shadowBlur: 0,\n      shadowColor: 'rgba(0, 0, 0, 0.2)',\n      shadowOffsetX: 0,\n      shadowOffsetY: 0,\n      opacity: 1\n    },\n    emphasis: {\n      focus: 'descendant'\n    },\n    blur: {\n      itemStyle: {\n        opacity: 0.2\n      },\n      label: {\n        opacity: 0.1\n      }\n    },\n    // Animation type can be expansion, scale.\n    animationType: 'expansion',\n    animationDuration: 1000,\n    animationDurationUpdate: 500,\n    data: [],\n    /**\r\n     * Sort order.\r\n     *\r\n     * Valid values: 'desc', 'asc', null, or callback function.\r\n     * 'desc' and 'asc' for descend and ascendant order;\r\n     * null for not sorting;\r\n     * example of callback function:\r\n     * function(nodeA, nodeB) {\r\n     *     return nodeA.getValue() - nodeB.getValue();\r\n     * }\r\n     */\n    sort: 'desc'\n  };\n  return SunburstSeriesModel;\n}(Series/* default */.A);\nfunction completeTreeValue(dataNode) {\n  // Postorder travel tree.\n  // If value of none-leaf node is not set,\n  // calculate it by suming up the value of all children.\n  var sum = 0;\n  util.each(dataNode.children, function (child) {\n    completeTreeValue(child);\n    var childValue = child.value;\n    // TODO First value of array must be a number\n    util.isArray(childValue) && (childValue = childValue[0]);\n    sum += childValue;\n  });\n  var thisValue = dataNode.value;\n  if (util.isArray(thisValue)) {\n    thisValue = thisValue[0];\n  }\n  if (thisValue == null || isNaN(thisValue)) {\n    thisValue = sum;\n  }\n  // Value should not less than 0.\n  if (thisValue < 0) {\n    thisValue = 0;\n  }\n  util.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;\n}\n/* harmony default export */ const SunburstSeries = (SunburstSeriesModel);\n;// ./node_modules/echarts/lib/chart/sunburst/sunburstLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n// let PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\nfunction sunburstLayout(seriesType, ecModel, api) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n    if (!util.isArray(radius)) {\n      radius = [0, radius];\n    }\n    if (!util.isArray(center)) {\n      center = [center, center];\n    }\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = (0,number/* parsePercent */.lo)(center[0], width);\n    var cy = (0,number/* parsePercent */.lo)(center[1], height);\n    var r0 = (0,number/* parsePercent */.lo)(radius[0], size / 2);\n    var r = (0,number/* parsePercent */.lo)(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var virtualRoot = seriesModel.getData().tree.root;\n    var treeRoot = seriesModel.getViewRoot();\n    var rootDepth = treeRoot.depth;\n    var sort = seriesModel.get('sort');\n    if (sort != null) {\n      initChildren(treeRoot, sort);\n    }\n    var validDataCount = 0;\n    util.each(treeRoot.children, function (child) {\n      !isNaN(child.getValue()) && validDataCount++;\n    });\n    var sum = treeRoot.getValue();\n    // Sum may be 0\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var renderRollupNode = treeRoot.depth > 0;\n    var levels = treeRoot.height - (renderRollupNode ? -1 : 1);\n    var rPerLevel = (r - r0) / (levels || 1);\n    var clockwise = seriesModel.get('clockwise');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum');\n    // In the case some sector angle is smaller than minAngle\n    // let restAngle = PI2;\n    // let valueSumLargerThanMinAngle = 0;\n    var dir = clockwise ? 1 : -1;\n    /**\r\n     * Render a tree\r\n     * @return increased angle\r\n     */\n    var renderNode = function (node, startAngle) {\n      if (!node) {\n        return;\n      }\n      var endAngle = startAngle;\n      // Render self\n      if (node !== virtualRoot) {\n        // Tree node is virtual, so it doesn't need to be drawn\n        var value = node.getValue();\n        var angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n        if (angle < minAngle) {\n          angle = minAngle;\n          // restAngle -= minAngle;\n        }\n        // else {\n        //     valueSumLargerThanMinAngle += value;\n        // }\n        endAngle = startAngle + dir * angle;\n        var depth = node.depth - rootDepth - (renderRollupNode ? -1 : 1);\n        var rStart = r0 + rPerLevel * depth;\n        var rEnd = r0 + rPerLevel * (depth + 1);\n        var levelModel = seriesModel.getLevelModel(node);\n        if (levelModel) {\n          var r0_1 = levelModel.get('r0', true);\n          var r_1 = levelModel.get('r', true);\n          var radius_1 = levelModel.get('radius', true);\n          if (radius_1 != null) {\n            r0_1 = radius_1[0];\n            r_1 = radius_1[1];\n          }\n          r0_1 != null && (rStart = (0,number/* parsePercent */.lo)(r0_1, size / 2));\n          r_1 != null && (rEnd = (0,number/* parsePercent */.lo)(r_1, size / 2));\n        }\n        node.setLayout({\n          angle: angle,\n          startAngle: startAngle,\n          endAngle: endAngle,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: rStart,\n          r: rEnd\n        });\n      }\n      // Render children\n      if (node.children && node.children.length) {\n        // currentAngle = startAngle;\n        var siblingAngle_1 = 0;\n        util.each(node.children, function (node) {\n          siblingAngle_1 += renderNode(node, startAngle + siblingAngle_1);\n        });\n      }\n      return endAngle - startAngle;\n    };\n    // Virtual root node for roll up\n    if (renderRollupNode) {\n      var rStart = r0;\n      var rEnd = r0 + rPerLevel;\n      var angle = Math.PI * 2;\n      virtualRoot.setLayout({\n        angle: angle,\n        startAngle: startAngle,\n        endAngle: startAngle + angle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: rStart,\n        r: rEnd\n      });\n    }\n    renderNode(treeRoot, startAngle);\n  });\n}\n/**\r\n * Init node children by order and update visual\r\n */\nfunction initChildren(node, sortOrder) {\n  var children = node.children || [];\n  node.children = sort(children, sortOrder);\n  // Init children recursively\n  if (children.length) {\n    util.each(node.children, function (child) {\n      initChildren(child, sortOrder);\n    });\n  }\n}\n/**\r\n * Sort children nodes\r\n *\r\n * @param {TreeNode[]}               children children of node to be sorted\r\n * @param {string | function | null} sort sort method\r\n *                                   See SunburstSeries.js for details.\r\n */\nfunction sort(children, sortOrder) {\n  if (util.isFunction(sortOrder)) {\n    var sortTargets = util.map(children, function (child, idx) {\n      var value = child.getValue();\n      return {\n        params: {\n          depth: child.depth,\n          height: child.height,\n          dataIndex: child.dataIndex,\n          getValue: function () {\n            return value;\n          }\n        },\n        index: idx\n      };\n    });\n    sortTargets.sort(function (a, b) {\n      return sortOrder(a.params, b.params);\n    });\n    return util.map(sortTargets, function (target) {\n      return children[target.index];\n    });\n  } else {\n    var isAsc_1 = sortOrder === 'asc';\n    return children.sort(function (a, b) {\n      var diff = (a.getValue() - b.getValue()) * (isAsc_1 ? 1 : -1);\n      return diff === 0 ? (a.dataIndex - b.dataIndex) * (isAsc_1 ? -1 : 1) : diff;\n    });\n  }\n}\n// EXTERNAL MODULE: ./node_modules/zrender/lib/tool/color.js\nvar tool_color = __webpack_require__(47698);\n;// ./node_modules/echarts/lib/chart/sunburst/sunburstVisual.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction sunburstVisual(ecModel) {\n  var paletteScope = {};\n  // Default color strategy\n  function pickColor(node, seriesModel, treeHeight) {\n    // Choose color from palette based on the first level.\n    var current = node;\n    while (current && current.depth > 1) {\n      current = current.parentNode;\n    }\n    var color = seriesModel.getColorFromPalette(current.name || current.dataIndex + '', paletteScope);\n    if (node.depth > 1 && (0,util.isString)(color)) {\n      // Lighter on the deeper level.\n      color = (0,tool_color.lift)(color, (node.depth - 1) / (treeHeight - 1) * 0.5);\n    }\n    return color;\n  }\n  ecModel.eachSeriesByType('sunburst', function (seriesModel) {\n    var data = seriesModel.getData();\n    var tree = data.tree;\n    tree.eachNode(function (node) {\n      var model = node.getModel();\n      var style = model.getModel('itemStyle').getItemStyle();\n      if (!style.fill) {\n        style.fill = pickColor(node, seriesModel, tree.root.height);\n      }\n      var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, 'style');\n      (0,util.extend)(existsStyle, style);\n    });\n  });\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/processor/dataFilter.js\nvar dataFilter = __webpack_require__(78587);\n;// ./node_modules/echarts/lib/chart/sunburst/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nfunction install(registers) {\n  registers.registerChartView(sunburst_SunburstView);\n  registers.registerSeriesModel(SunburstSeries);\n  registers.registerLayout((0,util.curry)(sunburstLayout, 'sunburst'));\n  registers.registerProcessor((0,util.curry)(dataFilter/* default */.A, 'sunburst'));\n  registers.registerVisual(sunburstVisual);\n  installSunburstAction(registers);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ3MTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3N1bmJ1cnN0L1N1bmJ1cnN0UGllY2UuanM/YzMxMyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvc3VuYnVyc3Qvc3VuYnVyc3RBY3Rpb24uanM/MTNiZSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvc3VuYnVyc3QvU3VuYnVyc3RWaWV3LmpzP2Q3NzIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3N1bmJ1cnN0L1N1bmJ1cnN0U2VyaWVzLmpzPzViYzkiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3N1bmJ1cnN0L3N1bmJ1cnN0TGF5b3V0LmpzP2I0MmYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3N1bmJ1cnN0L3N1bmJ1cnN0VmlzdWFsLmpzP2YxZjQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3N1bmJ1cnN0L2luc3RhbGwuanM/ODJkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgKiBhcyBncmFwaGljIGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyB0b2dnbGVIb3ZlckVtcGhhc2lzLCBTUEVDSUFMX1NUQVRFUywgRElTUExBWV9TVEFURVMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVUZXh0U3R5bGUgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlLmpzJztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZS5qcyc7XG5pbXBvcnQgeyBnZXRTZWN0b3JDb3JuZXJSYWRpdXMgfSBmcm9tICcuLi9oZWxwZXIvc2VjdG9ySGVscGVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZU9yVXBkYXRlUGF0dGVybkZyb21EZWNhbCB9IGZyb20gJy4uLy4uL3V0aWwvZGVjYWwuanMnO1xuaW1wb3J0IHsgc2F2ZU9sZFN0eWxlIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL2Jhc2ljVHJhbnNpdGlvbi5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVSYWRpYW4gfSBmcm9tICd6cmVuZGVyL2xpYi9jb250YWluL3V0aWwuanMnO1xuaW1wb3J0IHsgaXNSYWRpYW5Bcm91bmRaZXJvIH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xudmFyIERFRkFVTFRfU0VDVE9SX1ogPSAyO1xudmFyIERFRkFVTFRfVEVYVF9aID0gNDtcbi8qKlxyXG4gKiBTdW5idXJzdGNlIG9mIFN1bmJ1cnN0IGluY2x1ZGluZyBTZWN0b3IsIExhYmVsLCBMYWJlbExpbmVcclxuICovXG52YXIgU3VuYnVyc3RQaWVjZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTdW5idXJzdFBpZWNlLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBTdW5idXJzdFBpZWNlKG5vZGUsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLnoyID0gREVGQVVMVF9TRUNUT1JfWjtcbiAgICBfdGhpcy50ZXh0Q29uZmlnID0ge1xuICAgICAgaW5zaWRlOiB0cnVlXG4gICAgfTtcbiAgICBnZXRFQ0RhdGEoX3RoaXMpLnNlcmllc0luZGV4ID0gc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXg7XG4gICAgdmFyIHRleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHoyOiBERUZBVUxUX1RFWFRfWixcbiAgICAgIHNpbGVudDogbm9kZS5nZXRNb2RlbCgpLmdldChbJ2xhYmVsJywgJ3NpbGVudCddKVxuICAgIH0pO1xuICAgIF90aGlzLnNldFRleHRDb250ZW50KHRleHQpO1xuICAgIF90aGlzLnVwZGF0ZURhdGEodHJ1ZSwgbm9kZSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFN1bmJ1cnN0UGllY2UucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZmlyc3RDcmVhdGUsIG5vZGUsXG4gIC8vIHN0YXRlOiAnZW1waGFzaXMnIHwgJ25vcm1hbCcgfCAnaGlnaGxpZ2h0JyB8ICdkb3ducGxheScsXG4gIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIG5vZGUucGllY2UgPSB0aGlzO1xuICAgIHNlcmllc01vZGVsID0gc2VyaWVzTW9kZWwgfHwgdGhpcy5fc2VyaWVzTW9kZWw7XG4gICAgZWNNb2RlbCA9IGVjTW9kZWwgfHwgdGhpcy5fZWNNb2RlbDtcbiAgICB2YXIgc2VjdG9yID0gdGhpcztcbiAgICBnZXRFQ0RhdGEoc2VjdG9yKS5kYXRhSW5kZXggPSBub2RlLmRhdGFJbmRleDtcbiAgICB2YXIgaXRlbU1vZGVsID0gbm9kZS5nZXRNb2RlbCgpO1xuICAgIHZhciBlbXBoYXNpc01vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdlbXBoYXNpcycpO1xuICAgIHZhciBsYXlvdXQgPSBub2RlLmdldExheW91dCgpO1xuICAgIHZhciBzZWN0b3JTaGFwZSA9IHpyVXRpbC5leHRlbmQoe30sIGxheW91dCk7XG4gICAgc2VjdG9yU2hhcGUubGFiZWwgPSBudWxsO1xuICAgIHZhciBub3JtYWxTdHlsZSA9IG5vZGUuZ2V0VmlzdWFsKCdzdHlsZScpO1xuICAgIG5vcm1hbFN0eWxlLmxpbmVKb2luID0gJ2JldmVsJztcbiAgICB2YXIgZGVjYWwgPSBub2RlLmdldFZpc3VhbCgnZGVjYWwnKTtcbiAgICBpZiAoZGVjYWwpIHtcbiAgICAgIG5vcm1hbFN0eWxlLmRlY2FsID0gY3JlYXRlT3JVcGRhdGVQYXR0ZXJuRnJvbURlY2FsKGRlY2FsLCBhcGkpO1xuICAgIH1cbiAgICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0U2VjdG9yQ29ybmVyUmFkaXVzKGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJyksIHNlY3RvclNoYXBlLCB0cnVlKTtcbiAgICB6clV0aWwuZXh0ZW5kKHNlY3RvclNoYXBlLCBjb3JuZXJSYWRpdXMpO1xuICAgIHpyVXRpbC5lYWNoKFNQRUNJQUxfU1RBVEVTLCBmdW5jdGlvbiAoc3RhdGVOYW1lKSB7XG4gICAgICB2YXIgc3RhdGUgPSBzZWN0b3IuZW5zdXJlU3RhdGUoc3RhdGVOYW1lKTtcbiAgICAgIHZhciBpdGVtU3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChbc3RhdGVOYW1lLCAnaXRlbVN0eWxlJ10pO1xuICAgICAgc3RhdGUuc3R5bGUgPSBpdGVtU3R5bGVNb2RlbC5nZXRJdGVtU3R5bGUoKTtcbiAgICAgIC8vIGJvcmRlciByYWRpdXNcbiAgICAgIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRTZWN0b3JDb3JuZXJSYWRpdXMoaXRlbVN0eWxlTW9kZWwsIHNlY3RvclNoYXBlKTtcbiAgICAgIGlmIChjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgc3RhdGUuc2hhcGUgPSBjb3JuZXJSYWRpdXM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGZpcnN0Q3JlYXRlKSB7XG4gICAgICBzZWN0b3Iuc2V0U2hhcGUoc2VjdG9yU2hhcGUpO1xuICAgICAgc2VjdG9yLnNoYXBlLnIgPSBsYXlvdXQucjA7XG4gICAgICBncmFwaGljLmluaXRQcm9wcyhzZWN0b3IsIHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICByOiBsYXlvdXQuclxuICAgICAgICB9XG4gICAgICB9LCBzZXJpZXNNb2RlbCwgbm9kZS5kYXRhSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEaXNhYmxlIGFuaW1hdGlvbiBmb3IgZ3JhZGllbnQgc2luY2Ugbm8gaW50ZXJwb2xhdGlvbiBtZXRob2RcbiAgICAgIC8vIGlzIHN1cHBvcnRlZCBmb3IgZ3JhZGllbnRcbiAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoc2VjdG9yLCB7XG4gICAgICAgIHNoYXBlOiBzZWN0b3JTaGFwZVxuICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuICAgICAgc2F2ZU9sZFN0eWxlKHNlY3Rvcik7XG4gICAgfVxuICAgIHNlY3Rvci51c2VTdHlsZShub3JtYWxTdHlsZSk7XG4gICAgdGhpcy5fdXBkYXRlTGFiZWwoc2VyaWVzTW9kZWwpO1xuICAgIHZhciBjdXJzb3JTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdjdXJzb3InKTtcbiAgICBjdXJzb3JTdHlsZSAmJiBzZWN0b3IuYXR0cignY3Vyc29yJywgY3Vyc29yU3R5bGUpO1xuICAgIHRoaXMuX3Nlcmllc01vZGVsID0gc2VyaWVzTW9kZWwgfHwgdGhpcy5fc2VyaWVzTW9kZWw7XG4gICAgdGhpcy5fZWNNb2RlbCA9IGVjTW9kZWwgfHwgdGhpcy5fZWNNb2RlbDtcbiAgICB2YXIgZm9jdXMgPSBlbXBoYXNpc01vZGVsLmdldCgnZm9jdXMnKTtcbiAgICB2YXIgZm9jdXNPckluZGljZXMgPSBmb2N1cyA9PT0gJ3JlbGF0aXZlJyA/IHpyVXRpbC5jb25jYXRBcnJheShub2RlLmdldEFuY2VzdG9yc0luZGljZXMoKSwgbm9kZS5nZXREZXNjZW5kYW50SW5kaWNlcygpKSA6IGZvY3VzID09PSAnYW5jZXN0b3InID8gbm9kZS5nZXRBbmNlc3RvcnNJbmRpY2VzKCkgOiBmb2N1cyA9PT0gJ2Rlc2NlbmRhbnQnID8gbm9kZS5nZXREZXNjZW5kYW50SW5kaWNlcygpIDogZm9jdXM7XG4gICAgdG9nZ2xlSG92ZXJFbXBoYXNpcyh0aGlzLCBmb2N1c09ySW5kaWNlcywgZW1waGFzaXNNb2RlbC5nZXQoJ2JsdXJTY29wZScpLCBlbXBoYXNpc01vZGVsLmdldCgnZGlzYWJsZWQnKSk7XG4gIH07XG4gIFN1bmJ1cnN0UGllY2UucHJvdG90eXBlLl91cGRhdGVMYWJlbCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IHRoaXMubm9kZS5nZXRNb2RlbCgpO1xuICAgIHZhciBub3JtYWxMYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbCcpO1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLm5vZGUuZ2V0TGF5b3V0KCk7XG4gICAgdmFyIGFuZ2xlID0gbGF5b3V0LmVuZEFuZ2xlIC0gbGF5b3V0LnN0YXJ0QW5nbGU7XG4gICAgdmFyIG1pZEFuZ2xlID0gKGxheW91dC5zdGFydEFuZ2xlICsgbGF5b3V0LmVuZEFuZ2xlKSAvIDI7XG4gICAgdmFyIGR4ID0gTWF0aC5jb3MobWlkQW5nbGUpO1xuICAgIHZhciBkeSA9IE1hdGguc2luKG1pZEFuZ2xlKTtcbiAgICB2YXIgc2VjdG9yID0gdGhpcztcbiAgICB2YXIgbGFiZWwgPSBzZWN0b3IuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICB2YXIgZGF0YUluZGV4ID0gdGhpcy5ub2RlLmRhdGFJbmRleDtcbiAgICB2YXIgbGFiZWxNaW5BbmdsZSA9IG5vcm1hbExhYmVsTW9kZWwuZ2V0KCdtaW5BbmdsZScpIC8gMTgwICogTWF0aC5QSTtcbiAgICB2YXIgaXNOb3JtYWxTaG93biA9IG5vcm1hbExhYmVsTW9kZWwuZ2V0KCdzaG93JykgJiYgIShsYWJlbE1pbkFuZ2xlICE9IG51bGwgJiYgTWF0aC5hYnMoYW5nbGUpIDwgbGFiZWxNaW5BbmdsZSk7XG4gICAgbGFiZWwuaWdub3JlID0gIWlzTm9ybWFsU2hvd247XG4gICAgLy8gVE9ETyB1c2Ugc2V0TGFiZWxTdHlsZVxuICAgIHpyVXRpbC5lYWNoKERJU1BMQVlfU1RBVEVTLCBmdW5jdGlvbiAoc3RhdGVOYW1lKSB7XG4gICAgICB2YXIgbGFiZWxTdGF0ZU1vZGVsID0gc3RhdGVOYW1lID09PSAnbm9ybWFsJyA/IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwnKSA6IGl0ZW1Nb2RlbC5nZXRNb2RlbChbc3RhdGVOYW1lLCAnbGFiZWwnXSk7XG4gICAgICB2YXIgaXNOb3JtYWwgPSBzdGF0ZU5hbWUgPT09ICdub3JtYWwnO1xuICAgICAgdmFyIHN0YXRlID0gaXNOb3JtYWwgPyBsYWJlbCA6IGxhYmVsLmVuc3VyZVN0YXRlKHN0YXRlTmFtZSk7XG4gICAgICB2YXIgdGV4dCA9IHNlcmllc01vZGVsLmdldEZvcm1hdHRlZExhYmVsKGRhdGFJbmRleCwgc3RhdGVOYW1lKTtcbiAgICAgIGlmIChpc05vcm1hbCkge1xuICAgICAgICB0ZXh0ID0gdGV4dCB8fCBfdGhpcy5ub2RlLm5hbWU7XG4gICAgICB9XG4gICAgICBzdGF0ZS5zdHlsZSA9IGNyZWF0ZVRleHRTdHlsZShsYWJlbFN0YXRlTW9kZWwsIHt9LCBudWxsLCBzdGF0ZU5hbWUgIT09ICdub3JtYWwnLCB0cnVlKTtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHN0YXRlLnN0eWxlLnRleHQgPSB0ZXh0O1xuICAgICAgfVxuICAgICAgLy8gTm90IGRpc3BsYXlpbmcgdGV4dCB3aGVuIGFuZ2xlIGlzIHRvbyBzbWFsbFxuICAgICAgdmFyIGlzU2hvd24gPSBsYWJlbFN0YXRlTW9kZWwuZ2V0KCdzaG93Jyk7XG4gICAgICBpZiAoaXNTaG93biAhPSBudWxsICYmICFpc05vcm1hbCkge1xuICAgICAgICBzdGF0ZS5pZ25vcmUgPSAhaXNTaG93bjtcbiAgICAgIH1cbiAgICAgIHZhciBsYWJlbFBvc2l0aW9uID0gZ2V0TGFiZWxBdHRyKGxhYmVsU3RhdGVNb2RlbCwgJ3Bvc2l0aW9uJyk7XG4gICAgICB2YXIgc2VjdG9yU3RhdGUgPSBpc05vcm1hbCA/IHNlY3RvciA6IHNlY3Rvci5zdGF0ZXNbc3RhdGVOYW1lXTtcbiAgICAgIHZhciBsYWJlbENvbG9yID0gc2VjdG9yU3RhdGUuc3R5bGUuZmlsbDtcbiAgICAgIHNlY3RvclN0YXRlLnRleHRDb25maWcgPSB7XG4gICAgICAgIG91dHNpZGVGaWxsOiBsYWJlbFN0YXRlTW9kZWwuZ2V0KCdjb2xvcicpID09PSAnaW5oZXJpdCcgPyBsYWJlbENvbG9yIDogbnVsbCxcbiAgICAgICAgaW5zaWRlOiBsYWJlbFBvc2l0aW9uICE9PSAnb3V0c2lkZSdcbiAgICAgIH07XG4gICAgICB2YXIgcjtcbiAgICAgIHZhciBsYWJlbFBhZGRpbmcgPSBnZXRMYWJlbEF0dHIobGFiZWxTdGF0ZU1vZGVsLCAnZGlzdGFuY2UnKSB8fCAwO1xuICAgICAgdmFyIHRleHRBbGlnbiA9IGdldExhYmVsQXR0cihsYWJlbFN0YXRlTW9kZWwsICdhbGlnbicpO1xuICAgICAgdmFyIHJvdGF0ZVR5cGUgPSBnZXRMYWJlbEF0dHIobGFiZWxTdGF0ZU1vZGVsLCAncm90YXRlJyk7XG4gICAgICB2YXIgZmxpcFN0YXJ0QW5nbGUgPSBNYXRoLlBJICogMC41O1xuICAgICAgdmFyIGZsaXBFbmRBbmdsZSA9IE1hdGguUEkgKiAxLjU7XG4gICAgICB2YXIgbWlkQW5nbGVOb3JtYWwgPSBub3JtYWxpemVSYWRpYW4ocm90YXRlVHlwZSA9PT0gJ3RhbmdlbnRpYWwnID8gTWF0aC5QSSAvIDIgLSBtaWRBbmdsZSA6IG1pZEFuZ2xlKTtcbiAgICAgIC8vIEZvciB0ZXh0IHRoYXQgaXMgdXAtc2lkZSBkb3duLCByb3RhdGUgMTgwIGRlZ3JlZXMgdG8gbWFrZSBzdXJlXG4gICAgICAvLyBpdCdzIHJlYWRhYmxlXG4gICAgICB2YXIgbmVlZHNGbGlwID0gbWlkQW5nbGVOb3JtYWwgPiBmbGlwU3RhcnRBbmdsZSAmJiAhaXNSYWRpYW5Bcm91bmRaZXJvKG1pZEFuZ2xlTm9ybWFsIC0gZmxpcFN0YXJ0QW5nbGUpICYmIG1pZEFuZ2xlTm9ybWFsIDwgZmxpcEVuZEFuZ2xlO1xuICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT09ICdvdXRzaWRlJykge1xuICAgICAgICByID0gbGF5b3V0LnIgKyBsYWJlbFBhZGRpbmc7XG4gICAgICAgIHRleHRBbGlnbiA9IG5lZWRzRmxpcCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRleHRBbGlnbiB8fCB0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgLy8gUHV0IGxhYmVsIGluIHRoZSBjZW50ZXIgaWYgaXQncyBhIGNpcmNsZVxuICAgICAgICAgIGlmIChhbmdsZSA9PT0gMiAqIE1hdGguUEkgJiYgbGF5b3V0LnIwID09PSAwKSB7XG4gICAgICAgICAgICByID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgciA9IChsYXlvdXQuciArIGxheW91dC5yMCkgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHIgPSBsYXlvdXQucjAgKyBsYWJlbFBhZGRpbmc7XG4gICAgICAgICAgdGV4dEFsaWduID0gbmVlZHNGbGlwID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICByID0gbGF5b3V0LnIgLSBsYWJlbFBhZGRpbmc7XG4gICAgICAgICAgdGV4dEFsaWduID0gbmVlZHNGbGlwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUuc3R5bGUuYWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICBzdGF0ZS5zdHlsZS52ZXJ0aWNhbEFsaWduID0gZ2V0TGFiZWxBdHRyKGxhYmVsU3RhdGVNb2RlbCwgJ3ZlcnRpY2FsQWxpZ24nKSB8fCAnbWlkZGxlJztcbiAgICAgIHN0YXRlLnggPSByICogZHggKyBsYXlvdXQuY3g7XG4gICAgICBzdGF0ZS55ID0gciAqIGR5ICsgbGF5b3V0LmN5O1xuICAgICAgdmFyIHJvdGF0ZSA9IDA7XG4gICAgICBpZiAocm90YXRlVHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgcm90YXRlID0gbm9ybWFsaXplUmFkaWFuKC1taWRBbmdsZSkgKyAobmVlZHNGbGlwID8gTWF0aC5QSSA6IDApO1xuICAgICAgfSBlbHNlIGlmIChyb3RhdGVUeXBlID09PSAndGFuZ2VudGlhbCcpIHtcbiAgICAgICAgcm90YXRlID0gbm9ybWFsaXplUmFkaWFuKE1hdGguUEkgLyAyIC0gbWlkQW5nbGUpICsgKG5lZWRzRmxpcCA/IE1hdGguUEkgOiAwKTtcbiAgICAgIH0gZWxzZSBpZiAoenJVdGlsLmlzTnVtYmVyKHJvdGF0ZVR5cGUpKSB7XG4gICAgICAgIHJvdGF0ZSA9IHJvdGF0ZVR5cGUgKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgfVxuICAgICAgc3RhdGUucm90YXRpb24gPSBub3JtYWxpemVSYWRpYW4ocm90YXRlKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBnZXRMYWJlbEF0dHIobW9kZWwsIG5hbWUpIHtcbiAgICAgIHZhciBzdGF0ZUF0dHIgPSBtb2RlbC5nZXQobmFtZSk7XG4gICAgICBpZiAoc3RhdGVBdHRyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbExhYmVsTW9kZWwuZ2V0KG5hbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlQXR0cjtcbiAgICB9XG4gICAgbGFiZWwuZGlydHlTdHlsZSgpO1xuICB9O1xuICByZXR1cm4gU3VuYnVyc3RQaWVjZTtcbn0oZ3JhcGhpYy5TZWN0b3IpO1xuZXhwb3J0IGRlZmF1bHQgU3VuYnVyc3RQaWVjZTsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGVSZXBsYWNlTG9nIH0gZnJvbSAnLi4vLi4vdXRpbC9sb2cuanMnO1xuaW1wb3J0IHsgcmV0cmlldmVUYXJnZXRJbmZvLCBhYm92ZVZpZXdSb290IH0gZnJvbSAnLi4vaGVscGVyL3RyZWVIZWxwZXIuanMnO1xuZXhwb3J0IHZhciBST09UX1RPX05PREVfQUNUSU9OID0gJ3N1bmJ1cnN0Um9vdFRvTm9kZSc7XG52YXIgSElHSExJR0hUX0FDVElPTiA9ICdzdW5idXJzdEhpZ2hsaWdodCc7XG52YXIgVU5ISUdITElHSFRfQUNUSU9OID0gJ3N1bmJ1cnN0VW5oaWdobGlnaHQnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGxTdW5idXJzdEFjdGlvbihyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICB0eXBlOiBST09UX1RPX05PREVfQUNUSU9OLFxuICAgIHVwZGF0ZTogJ3VwZGF0ZVZpZXcnXG4gIH0sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgIG1haW5UeXBlOiAnc2VyaWVzJyxcbiAgICAgIHN1YlR5cGU6ICdzdW5idXJzdCcsXG4gICAgICBxdWVyeTogcGF5bG9hZFxuICAgIH0sIGhhbmRsZVJvb3RUb05vZGUpO1xuICAgIGZ1bmN0aW9uIGhhbmRsZVJvb3RUb05vZGUobW9kZWwsIGluZGV4KSB7XG4gICAgICB2YXIgdGFyZ2V0SW5mbyA9IHJldHJpZXZlVGFyZ2V0SW5mbyhwYXlsb2FkLCBbUk9PVF9UT19OT0RFX0FDVElPTl0sIG1vZGVsKTtcbiAgICAgIGlmICh0YXJnZXRJbmZvKSB7XG4gICAgICAgIHZhciBvcmlnaW5WaWV3Um9vdCA9IG1vZGVsLmdldFZpZXdSb290KCk7XG4gICAgICAgIGlmIChvcmlnaW5WaWV3Um9vdCkge1xuICAgICAgICAgIHBheWxvYWQuZGlyZWN0aW9uID0gYWJvdmVWaWV3Um9vdChvcmlnaW5WaWV3Um9vdCwgdGFyZ2V0SW5mby5ub2RlKSA/ICdyb2xsVXAnIDogJ2RyaWxsRG93bic7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwucmVzZXRWaWV3Um9vdCh0YXJnZXRJbmZvLm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogSElHSExJR0hUX0FDVElPTixcbiAgICB1cGRhdGU6ICdub25lJ1xuICB9LCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgLy8gQ2xvbmVcbiAgICBwYXlsb2FkID0gZXh0ZW5kKHt9LCBwYXlsb2FkKTtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6ICdzZXJpZXMnLFxuICAgICAgc3ViVHlwZTogJ3N1bmJ1cnN0JyxcbiAgICAgIHF1ZXJ5OiBwYXlsb2FkXG4gICAgfSwgaGFuZGxlSGlnaGxpZ2h0KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVIaWdobGlnaHQobW9kZWwpIHtcbiAgICAgIHZhciB0YXJnZXRJbmZvID0gcmV0cmlldmVUYXJnZXRJbmZvKHBheWxvYWQsIFtISUdITElHSFRfQUNUSU9OXSwgbW9kZWwpO1xuICAgICAgaWYgKHRhcmdldEluZm8pIHtcbiAgICAgICAgcGF5bG9hZC5kYXRhSW5kZXggPSB0YXJnZXRJbmZvLm5vZGUuZGF0YUluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVwcmVjYXRlUmVwbGFjZUxvZygnc3VuYnVyc3RIaWdobGlnaHQnLCAnaGlnaGxpZ2h0Jyk7XG4gICAgfVxuICAgIC8vIEZhc3QgZm9yd2FyZCBhY3Rpb25cbiAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oZXh0ZW5kKHBheWxvYWQsIHtcbiAgICAgIHR5cGU6ICdoaWdobGlnaHQnXG4gICAgfSkpO1xuICB9KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICB0eXBlOiBVTkhJR0hMSUdIVF9BQ1RJT04sXG4gICAgdXBkYXRlOiAndXBkYXRlVmlldydcbiAgfSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwsIGFwaSkge1xuICAgIHBheWxvYWQgPSBleHRlbmQoe30sIHBheWxvYWQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZXByZWNhdGVSZXBsYWNlTG9nKCdzdW5idXJzdFVuaGlnaGxpZ2h0JywgJ2Rvd25wbGF5Jyk7XG4gICAgfVxuICAgIGFwaS5kaXNwYXRjaEFjdGlvbihleHRlbmQocGF5bG9hZCwge1xuICAgICAgdHlwZTogJ2Rvd25wbGF5J1xuICAgIH0pKTtcbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0LmpzJztcbmltcG9ydCBTdW5idXJzdFBpZWNlIGZyb20gJy4vU3VuYnVyc3RQaWVjZS5qcyc7XG5pbXBvcnQgRGF0YURpZmZlciBmcm9tICcuLi8uLi9kYXRhL0RhdGFEaWZmZXIuanMnO1xuaW1wb3J0IHsgUk9PVF9UT19OT0RFX0FDVElPTiB9IGZyb20gJy4vc3VuYnVyc3RBY3Rpb24uanMnO1xuaW1wb3J0IHsgd2luZG93T3BlbiB9IGZyb20gJy4uLy4uL3V0aWwvZm9ybWF0LmpzJztcbnZhciBTdW5idXJzdFZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU3VuYnVyc3RWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBTdW5idXJzdFZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IFN1bmJ1cnN0Vmlldy50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBTdW5idXJzdFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLFxuICAvLyBAdHMtaWdub3JlXG4gIHBheWxvYWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zZXJpZXNNb2RlbCA9IHNlcmllc01vZGVsO1xuICAgIHRoaXMuYXBpID0gYXBpO1xuICAgIHRoaXMuZWNNb2RlbCA9IGVjTW9kZWw7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHZpcnR1YWxSb290ID0gZGF0YS50cmVlLnJvb3Q7XG4gICAgdmFyIG5ld1Jvb3QgPSBzZXJpZXNNb2RlbC5nZXRWaWV3Um9vdCgpO1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdmFyIHJlbmRlckxhYmVsRm9yWmVyb0RhdGEgPSBzZXJpZXNNb2RlbC5nZXQoJ3JlbmRlckxhYmVsRm9yWmVyb0RhdGEnKTtcbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBuZXdSb290LmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgIH0pO1xuICAgIHZhciBvbGRDaGlsZHJlbiA9IHRoaXMuX29sZENoaWxkcmVuIHx8IFtdO1xuICAgIGR1YWxUcmF2ZWwobmV3Q2hpbGRyZW4sIG9sZENoaWxkcmVuKTtcbiAgICByZW5kZXJSb2xsVXAodmlydHVhbFJvb3QsIG5ld1Jvb3QpO1xuICAgIHRoaXMuX2luaXRFdmVudHMoKTtcbiAgICB0aGlzLl9vbGRDaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICAgIGZ1bmN0aW9uIGR1YWxUcmF2ZWwobmV3Q2hpbGRyZW4sIG9sZENoaWxkcmVuKSB7XG4gICAgICBpZiAobmV3Q2hpbGRyZW4ubGVuZ3RoID09PSAwICYmIG9sZENoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuZXcgRGF0YURpZmZlcihvbGRDaGlsZHJlbiwgbmV3Q2hpbGRyZW4sIGdldEtleSwgZ2V0S2V5KS5hZGQocHJvY2Vzc05vZGUpLnVwZGF0ZShwcm9jZXNzTm9kZSkucmVtb3ZlKHpyVXRpbC5jdXJyeShwcm9jZXNzTm9kZSwgbnVsbCkpLmV4ZWN1dGUoKTtcbiAgICAgIGZ1bmN0aW9uIGdldEtleShub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmdldElkKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZShuZXdJZHgsIG9sZElkeCkge1xuICAgICAgICB2YXIgbmV3Tm9kZSA9IG5ld0lkeCA9PSBudWxsID8gbnVsbCA6IG5ld0NoaWxkcmVuW25ld0lkeF07XG4gICAgICAgIHZhciBvbGROb2RlID0gb2xkSWR4ID09IG51bGwgPyBudWxsIDogb2xkQ2hpbGRyZW5bb2xkSWR4XTtcbiAgICAgICAgZG9SZW5kZXJOb2RlKG5ld05vZGUsIG9sZE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkb1JlbmRlck5vZGUobmV3Tm9kZSwgb2xkTm9kZSkge1xuICAgICAgaWYgKCFyZW5kZXJMYWJlbEZvclplcm9EYXRhICYmIG5ld05vZGUgJiYgIW5ld05vZGUuZ2V0VmFsdWUoKSkge1xuICAgICAgICAvLyBOb3QgcmVuZGVyIGRhdGEgd2l0aCB2YWx1ZSAwXG4gICAgICAgIG5ld05vZGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG5ld05vZGUgIT09IHZpcnR1YWxSb290ICYmIG9sZE5vZGUgIT09IHZpcnR1YWxSb290KSB7XG4gICAgICAgIGlmIChvbGROb2RlICYmIG9sZE5vZGUucGllY2UpIHtcbiAgICAgICAgICBpZiAobmV3Tm9kZSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlXG4gICAgICAgICAgICBvbGROb2RlLnBpZWNlLnVwZGF0ZURhdGEoZmFsc2UsIG5ld05vZGUsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgLy8gRm9yIHRvb2x0aXBcbiAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdOb2RlLmRhdGFJbmRleCwgb2xkTm9kZS5waWVjZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZVxuICAgICAgICAgICAgcmVtb3ZlTm9kZShvbGROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobmV3Tm9kZSkge1xuICAgICAgICAgIC8vIEFkZFxuICAgICAgICAgIHZhciBwaWVjZSA9IG5ldyBTdW5idXJzdFBpZWNlKG5ld05vZGUsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgICAgIGdyb3VwLmFkZChwaWVjZSk7XG4gICAgICAgICAgLy8gRm9yIHRvb2x0aXBcbiAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3Tm9kZS5kYXRhSW5kZXgsIHBpZWNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5waWVjZSkge1xuICAgICAgICBncm91cC5yZW1vdmUobm9kZS5waWVjZSk7XG4gICAgICAgIG5vZGUucGllY2UgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJSb2xsVXAodmlydHVhbFJvb3QsIHZpZXdSb290KSB7XG4gICAgICBpZiAodmlld1Jvb3QuZGVwdGggPiAwKSB7XG4gICAgICAgIC8vIFJlbmRlclxuICAgICAgICBpZiAoc2VsZi52aXJ0dWFsUGllY2UpIHtcbiAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICBzZWxmLnZpcnR1YWxQaWVjZS51cGRhdGVEYXRhKGZhbHNlLCB2aXJ0dWFsUm9vdCwgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWRkXG4gICAgICAgICAgc2VsZi52aXJ0dWFsUGllY2UgPSBuZXcgU3VuYnVyc3RQaWVjZSh2aXJ0dWFsUm9vdCwgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgZ3JvdXAuYWRkKHNlbGYudmlydHVhbFBpZWNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIGV2ZW50IHNjb3BlXG4gICAgICAgIHZpZXdSb290LnBpZWNlLm9mZignY2xpY2snKTtcbiAgICAgICAgc2VsZi52aXJ0dWFsUGllY2Uub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBzZWxmLl9yb290VG9Ob2RlKHZpZXdSb290LnBhcmVudE5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi52aXJ0dWFsUGllY2UpIHtcbiAgICAgICAgLy8gUmVtb3ZlXG4gICAgICAgIGdyb3VwLnJlbW92ZShzZWxmLnZpcnR1YWxQaWVjZSk7XG4gICAgICAgIHNlbGYudmlydHVhbFBpZWNlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIFN1bmJ1cnN0Vmlldy5wcm90b3R5cGUuX2luaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLmdyb3VwLm9mZignY2xpY2snKTtcbiAgICB0aGlzLmdyb3VwLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdGFyZ2V0Rm91bmQgPSBmYWxzZTtcbiAgICAgIHZhciB2aWV3Um9vdCA9IF90aGlzLnNlcmllc01vZGVsLmdldFZpZXdSb290KCk7XG4gICAgICB2aWV3Um9vdC5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIXRhcmdldEZvdW5kICYmIG5vZGUucGllY2UgJiYgbm9kZS5waWVjZSA9PT0gZS50YXJnZXQpIHtcbiAgICAgICAgICB2YXIgbm9kZUNsaWNrID0gbm9kZS5nZXRNb2RlbCgpLmdldCgnbm9kZUNsaWNrJyk7XG4gICAgICAgICAgaWYgKG5vZGVDbGljayA9PT0gJ3Jvb3RUb05vZGUnKSB7XG4gICAgICAgICAgICBfdGhpcy5fcm9vdFRvTm9kZShub2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGVDbGljayA9PT0gJ2xpbmsnKSB7XG4gICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gbm9kZS5nZXRNb2RlbCgpO1xuICAgICAgICAgICAgdmFyIGxpbmsgPSBpdGVtTW9kZWwuZ2V0KCdsaW5rJyk7XG4gICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICB2YXIgbGlua1RhcmdldCA9IGl0ZW1Nb2RlbC5nZXQoJ3RhcmdldCcsIHRydWUpIHx8ICdfYmxhbmsnO1xuICAgICAgICAgICAgICB3aW5kb3dPcGVuKGxpbmssIGxpbmtUYXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXRGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBTdW5idXJzdFZpZXcucHJvdG90eXBlLl9yb290VG9Ob2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZSAhPT0gdGhpcy5zZXJpZXNNb2RlbC5nZXRWaWV3Um9vdCgpKSB7XG4gICAgICB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgIHR5cGU6IFJPT1RfVE9fTk9ERV9BQ1RJT04sXG4gICAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5zZXJpZXNNb2RlbC5pZCxcbiAgICAgICAgdGFyZ2V0Tm9kZTogbm9kZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBAaW1wbGVtZW50XHJcbiAgICovXG4gIFN1bmJ1cnN0Vmlldy5wcm90b3R5cGUuY29udGFpblBvaW50ID0gZnVuY3Rpb24gKHBvaW50LCBzZXJpZXNNb2RlbCkge1xuICAgIHZhciB0cmVlUm9vdCA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgaXRlbUxheW91dCA9IHRyZWVSb290LmdldEl0ZW1MYXlvdXQoMCk7XG4gICAgaWYgKGl0ZW1MYXlvdXQpIHtcbiAgICAgIHZhciBkeCA9IHBvaW50WzBdIC0gaXRlbUxheW91dC5jeDtcbiAgICAgIHZhciBkeSA9IHBvaW50WzFdIC0gaXRlbUxheW91dC5jeTtcbiAgICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgcmV0dXJuIHJhZGl1cyA8PSBpdGVtTGF5b3V0LnIgJiYgcmFkaXVzID49IGl0ZW1MYXlvdXQucjA7XG4gICAgfVxuICB9O1xuICBTdW5idXJzdFZpZXcudHlwZSA9ICdzdW5idXJzdCc7XG4gIHJldHVybiBTdW5idXJzdFZpZXc7XG59KENoYXJ0Vmlldyk7XG5leHBvcnQgZGVmYXVsdCBTdW5idXJzdFZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcy5qcyc7XG5pbXBvcnQgVHJlZSBmcm9tICcuLi8uLi9kYXRhL1RyZWUuanMnO1xuaW1wb3J0IHsgd3JhcFRyZWVQYXRoSW5mbyB9IGZyb20gJy4uL2hlbHBlci90cmVlSGVscGVyLmpzJztcbmltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Nb2RlbC5qcyc7XG5pbXBvcnQgZW5hYmxlQXJpYURlY2FsRm9yVHJlZSBmcm9tICcuLi9oZWxwZXIvZW5hYmxlQXJpYURlY2FsRm9yVHJlZS5qcyc7XG52YXIgU3VuYnVyc3RTZXJpZXNNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTdW5idXJzdFNlcmllc01vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBTdW5idXJzdFNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBTdW5idXJzdFNlcmllc01vZGVsLnR5cGU7XG4gICAgX3RoaXMuaWdub3JlU3R5bGVPbkRhdGEgPSB0cnVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBTdW5idXJzdFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICAvLyBDcmVhdGUgYSB2aXJ0dWFsIHJvb3QuXG4gICAgdmFyIHJvb3QgPSB7XG4gICAgICBuYW1lOiBvcHRpb24ubmFtZSxcbiAgICAgIGNoaWxkcmVuOiBvcHRpb24uZGF0YVxuICAgIH07XG4gICAgY29tcGxldGVUcmVlVmFsdWUocm9vdCk7XG4gICAgdmFyIGxldmVsTW9kZWxzID0gdGhpcy5fbGV2ZWxNb2RlbHMgPSB6clV0aWwubWFwKG9wdGlvbi5sZXZlbHMgfHwgW10sIGZ1bmN0aW9uIChsZXZlbERlZmluZSkge1xuICAgICAgcmV0dXJuIG5ldyBNb2RlbChsZXZlbERlZmluZSwgdGhpcywgZWNNb2RlbCk7XG4gICAgfSwgdGhpcyk7XG4gICAgLy8gTWFrZSBzdXJlIGFsd2F5cyBhIG5ldyB0cmVlIGlzIGNyZWF0ZWQgd2hlbiBzZXRPcHRpb24sXG4gICAgLy8gaW4gVHJlZW1hcFZpZXcsIHdlIGNoZWNrIHdoZXRoZXIgb2xkVHJlZSA9PT0gbmV3VHJlZVxuICAgIC8vIHRvIGNob29zZSBtYXBwaW5ncyBhcHByb2FjaCBhbW9uZyBvbGQgc2hhcGVzIGFuZCBuZXcgc2hhcGVzLlxuICAgIHZhciB0cmVlID0gVHJlZS5jcmVhdGVUcmVlKHJvb3QsIHRoaXMsIGJlZm9yZUxpbmspO1xuICAgIGZ1bmN0aW9uIGJlZm9yZUxpbmsobm9kZURhdGEpIHtcbiAgICAgIG5vZGVEYXRhLndyYXBNZXRob2QoJ2dldEl0ZW1Nb2RlbCcsIGZ1bmN0aW9uIChtb2RlbCwgaWR4KSB7XG4gICAgICAgIHZhciBub2RlID0gdHJlZS5nZXROb2RlQnlEYXRhSW5kZXgoaWR4KTtcbiAgICAgICAgdmFyIGxldmVsTW9kZWwgPSBsZXZlbE1vZGVsc1tub2RlLmRlcHRoXTtcbiAgICAgICAgbGV2ZWxNb2RlbCAmJiAobW9kZWwucGFyZW50TW9kZWwgPSBsZXZlbE1vZGVsKTtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0cmVlLmRhdGE7XG4gIH07XG4gIFN1bmJ1cnN0U2VyaWVzTW9kZWwucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNldFZpZXdSb290KCk7XG4gIH07XG4gIC8qXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXG4gIFN1bmJ1cnN0U2VyaWVzTW9kZWwucHJvdG90eXBlLmdldERhdGFQYXJhbXMgPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgdmFyIHBhcmFtcyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0RGF0YVBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBub2RlID0gdGhpcy5nZXREYXRhKCkudHJlZS5nZXROb2RlQnlEYXRhSW5kZXgoZGF0YUluZGV4KTtcbiAgICBwYXJhbXMudHJlZVBhdGhJbmZvID0gd3JhcFRyZWVQYXRoSW5mbyhub2RlLCB0aGlzKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9O1xuICBTdW5idXJzdFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRMZXZlbE1vZGVsID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fbGV2ZWxNb2RlbHMgJiYgdGhpcy5fbGV2ZWxNb2RlbHNbbm9kZS5kZXB0aF07XG4gIH07XG4gIFN1bmJ1cnN0U2VyaWVzTW9kZWwucHJvdG90eXBlLmdldFZpZXdSb290ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3Um9vdDtcbiAgfTtcbiAgU3VuYnVyc3RTZXJpZXNNb2RlbC5wcm90b3R5cGUucmVzZXRWaWV3Um9vdCA9IGZ1bmN0aW9uICh2aWV3Um9vdCkge1xuICAgIHZpZXdSb290ID8gdGhpcy5fdmlld1Jvb3QgPSB2aWV3Um9vdCA6IHZpZXdSb290ID0gdGhpcy5fdmlld1Jvb3Q7XG4gICAgdmFyIHJvb3QgPSB0aGlzLmdldFJhd0RhdGEoKS50cmVlLnJvb3Q7XG4gICAgaWYgKCF2aWV3Um9vdCB8fCB2aWV3Um9vdCAhPT0gcm9vdCAmJiAhcm9vdC5jb250YWlucyh2aWV3Um9vdCkpIHtcbiAgICAgIHRoaXMuX3ZpZXdSb290ID0gcm9vdDtcbiAgICB9XG4gIH07XG4gIFN1bmJ1cnN0U2VyaWVzTW9kZWwucHJvdG90eXBlLmVuYWJsZUFyaWFEZWNhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbmFibGVBcmlhRGVjYWxGb3JUcmVlKHRoaXMpO1xuICB9O1xuICBTdW5idXJzdFNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLnN1bmJ1cnN0JztcbiAgU3VuYnVyc3RTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIC8vIHpsZXZlbDogMCxcbiAgICB6OiAyLFxuICAgIC8vIOm7mOiupOWFqOWxgOWxheS4rVxuICAgIGNlbnRlcjogWyc1MCUnLCAnNTAlJ10sXG4gICAgcmFkaXVzOiBbMCwgJzc1JSddLFxuICAgIC8vIOm7mOiupOmhuuaXtumSiFxuICAgIGNsb2Nrd2lzZTogdHJ1ZSxcbiAgICBzdGFydEFuZ2xlOiA5MCxcbiAgICAvLyDmnIDlsI/op5LluqbmlLnkuLowXG4gICAgbWluQW5nbGU6IDAsXG4gICAgLy8gSWYgc3RpbGwgc2hvdyB3aGVuIGFsbCBkYXRhIHplcm8uXG4gICAgc3RpbGxTaG93WmVyb1N1bTogdHJ1ZSxcbiAgICAvLyAncm9vdFRvTm9kZScsICdsaW5rJywgb3IgZmFsc2VcbiAgICBub2RlQ2xpY2s6ICdyb290VG9Ob2RlJyxcbiAgICByZW5kZXJMYWJlbEZvclplcm9EYXRhOiBmYWxzZSxcbiAgICBsYWJlbDoge1xuICAgICAgLy8gY291bGQgYmU6ICdyYWRpYWwnLCAndGFuZ2VudGlhbCcsIG9yICdub25lJ1xuICAgICAgcm90YXRlOiAncmFkaWFsJyxcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgLy8gJ2xlZnQnIGlzIGZvciBpbm5lciBzaWRlIG9mIGluc2lkZSwgYW5kICdyaWdodCcgaXMgZm9yIG91dGVyXG4gICAgICAvLyBzaWRlIGZvciBpbnNpZGVcbiAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgIHBvc2l0aW9uOiAnaW5zaWRlJyxcbiAgICAgIGRpc3RhbmNlOiA1LFxuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSxcbiAgICBpdGVtU3R5bGU6IHtcbiAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgYm9yZGVyQ29sb3I6ICd3aGl0ZScsXG4gICAgICBib3JkZXJUeXBlOiAnc29saWQnLFxuICAgICAgc2hhZG93Qmx1cjogMCxcbiAgICAgIHNoYWRvd0NvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjIpJyxcbiAgICAgIHNoYWRvd09mZnNldFg6IDAsXG4gICAgICBzaGFkb3dPZmZzZXRZOiAwLFxuICAgICAgb3BhY2l0eTogMVxuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIGZvY3VzOiAnZGVzY2VuZGFudCdcbiAgICB9LFxuICAgIGJsdXI6IHtcbiAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICBvcGFjaXR5OiAwLjJcbiAgICAgIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBvcGFjaXR5OiAwLjFcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFuaW1hdGlvbiB0eXBlIGNhbiBiZSBleHBhbnNpb24sIHNjYWxlLlxuICAgIGFuaW1hdGlvblR5cGU6ICdleHBhbnNpb24nLFxuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAxMDAwLFxuICAgIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlOiA1MDAsXG4gICAgZGF0YTogW10sXG4gICAgLyoqXHJcbiAgICAgKiBTb3J0IG9yZGVyLlxyXG4gICAgICpcclxuICAgICAqIFZhbGlkIHZhbHVlczogJ2Rlc2MnLCAnYXNjJywgbnVsbCwgb3IgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKiAnZGVzYycgYW5kICdhc2MnIGZvciBkZXNjZW5kIGFuZCBhc2NlbmRhbnQgb3JkZXI7XHJcbiAgICAgKiBudWxsIGZvciBub3Qgc29ydGluZztcclxuICAgICAqIGV4YW1wbGUgb2YgY2FsbGJhY2sgZnVuY3Rpb246XHJcbiAgICAgKiBmdW5jdGlvbihub2RlQSwgbm9kZUIpIHtcclxuICAgICAqICAgICByZXR1cm4gbm9kZUEuZ2V0VmFsdWUoKSAtIG5vZGVCLmdldFZhbHVlKCk7XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cbiAgICBzb3J0OiAnZGVzYydcbiAgfTtcbiAgcmV0dXJuIFN1bmJ1cnN0U2VyaWVzTW9kZWw7XG59KFNlcmllc01vZGVsKTtcbmZ1bmN0aW9uIGNvbXBsZXRlVHJlZVZhbHVlKGRhdGFOb2RlKSB7XG4gIC8vIFBvc3RvcmRlciB0cmF2ZWwgdHJlZS5cbiAgLy8gSWYgdmFsdWUgb2Ygbm9uZS1sZWFmIG5vZGUgaXMgbm90IHNldCxcbiAgLy8gY2FsY3VsYXRlIGl0IGJ5IHN1bWluZyB1cCB0aGUgdmFsdWUgb2YgYWxsIGNoaWxkcmVuLlxuICB2YXIgc3VtID0gMDtcbiAgenJVdGlsLmVhY2goZGF0YU5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGNvbXBsZXRlVHJlZVZhbHVlKGNoaWxkKTtcbiAgICB2YXIgY2hpbGRWYWx1ZSA9IGNoaWxkLnZhbHVlO1xuICAgIC8vIFRPRE8gRmlyc3QgdmFsdWUgb2YgYXJyYXkgbXVzdCBiZSBhIG51bWJlclxuICAgIHpyVXRpbC5pc0FycmF5KGNoaWxkVmFsdWUpICYmIChjaGlsZFZhbHVlID0gY2hpbGRWYWx1ZVswXSk7XG4gICAgc3VtICs9IGNoaWxkVmFsdWU7XG4gIH0pO1xuICB2YXIgdGhpc1ZhbHVlID0gZGF0YU5vZGUudmFsdWU7XG4gIGlmICh6clV0aWwuaXNBcnJheSh0aGlzVmFsdWUpKSB7XG4gICAgdGhpc1ZhbHVlID0gdGhpc1ZhbHVlWzBdO1xuICB9XG4gIGlmICh0aGlzVmFsdWUgPT0gbnVsbCB8fCBpc05hTih0aGlzVmFsdWUpKSB7XG4gICAgdGhpc1ZhbHVlID0gc3VtO1xuICB9XG4gIC8vIFZhbHVlIHNob3VsZCBub3QgbGVzcyB0aGFuIDAuXG4gIGlmICh0aGlzVmFsdWUgPCAwKSB7XG4gICAgdGhpc1ZhbHVlID0gMDtcbiAgfVxuICB6clV0aWwuaXNBcnJheShkYXRhTm9kZS52YWx1ZSkgPyBkYXRhTm9kZS52YWx1ZVswXSA9IHRoaXNWYWx1ZSA6IGRhdGFOb2RlLnZhbHVlID0gdGhpc1ZhbHVlO1xufVxuZXhwb3J0IGRlZmF1bHQgU3VuYnVyc3RTZXJpZXNNb2RlbDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IHBhcnNlUGVyY2VudCB9IGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyLmpzJztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuLy8gbGV0IFBJMiA9IE1hdGguUEkgKiAyO1xudmFyIFJBRElBTiA9IE1hdGguUEkgLyAxODA7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdW5idXJzdExheW91dChzZXJpZXNUeXBlLCBlY01vZGVsLCBhcGkpIHtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjZW50ZXIgPSBzZXJpZXNNb2RlbC5nZXQoJ2NlbnRlcicpO1xuICAgIHZhciByYWRpdXMgPSBzZXJpZXNNb2RlbC5nZXQoJ3JhZGl1cycpO1xuICAgIGlmICghenJVdGlsLmlzQXJyYXkocmFkaXVzKSkge1xuICAgICAgcmFkaXVzID0gWzAsIHJhZGl1c107XG4gICAgfVxuICAgIGlmICghenJVdGlsLmlzQXJyYXkoY2VudGVyKSkge1xuICAgICAgY2VudGVyID0gW2NlbnRlciwgY2VudGVyXTtcbiAgICB9XG4gICAgdmFyIHdpZHRoID0gYXBpLmdldFdpZHRoKCk7XG4gICAgdmFyIGhlaWdodCA9IGFwaS5nZXRIZWlnaHQoKTtcbiAgICB2YXIgc2l6ZSA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciBjeCA9IHBhcnNlUGVyY2VudChjZW50ZXJbMF0sIHdpZHRoKTtcbiAgICB2YXIgY3kgPSBwYXJzZVBlcmNlbnQoY2VudGVyWzFdLCBoZWlnaHQpO1xuICAgIHZhciByMCA9IHBhcnNlUGVyY2VudChyYWRpdXNbMF0sIHNpemUgLyAyKTtcbiAgICB2YXIgciA9IHBhcnNlUGVyY2VudChyYWRpdXNbMV0sIHNpemUgLyAyKTtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IC1zZXJpZXNNb2RlbC5nZXQoJ3N0YXJ0QW5nbGUnKSAqIFJBRElBTjtcbiAgICB2YXIgbWluQW5nbGUgPSBzZXJpZXNNb2RlbC5nZXQoJ21pbkFuZ2xlJykgKiBSQURJQU47XG4gICAgdmFyIHZpcnR1YWxSb290ID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLnRyZWUucm9vdDtcbiAgICB2YXIgdHJlZVJvb3QgPSBzZXJpZXNNb2RlbC5nZXRWaWV3Um9vdCgpO1xuICAgIHZhciByb290RGVwdGggPSB0cmVlUm9vdC5kZXB0aDtcbiAgICB2YXIgc29ydCA9IHNlcmllc01vZGVsLmdldCgnc29ydCcpO1xuICAgIGlmIChzb3J0ICE9IG51bGwpIHtcbiAgICAgIGluaXRDaGlsZHJlbih0cmVlUm9vdCwgc29ydCk7XG4gICAgfVxuICAgIHZhciB2YWxpZERhdGFDb3VudCA9IDA7XG4gICAgenJVdGlsLmVhY2godHJlZVJvb3QuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgIWlzTmFOKGNoaWxkLmdldFZhbHVlKCkpICYmIHZhbGlkRGF0YUNvdW50Kys7XG4gICAgfSk7XG4gICAgdmFyIHN1bSA9IHRyZWVSb290LmdldFZhbHVlKCk7XG4gICAgLy8gU3VtIG1heSBiZSAwXG4gICAgdmFyIHVuaXRSYWRpYW4gPSBNYXRoLlBJIC8gKHN1bSB8fCB2YWxpZERhdGFDb3VudCkgKiAyO1xuICAgIHZhciByZW5kZXJSb2xsdXBOb2RlID0gdHJlZVJvb3QuZGVwdGggPiAwO1xuICAgIHZhciBsZXZlbHMgPSB0cmVlUm9vdC5oZWlnaHQgLSAocmVuZGVyUm9sbHVwTm9kZSA/IC0xIDogMSk7XG4gICAgdmFyIHJQZXJMZXZlbCA9IChyIC0gcjApIC8gKGxldmVscyB8fCAxKTtcbiAgICB2YXIgY2xvY2t3aXNlID0gc2VyaWVzTW9kZWwuZ2V0KCdjbG9ja3dpc2UnKTtcbiAgICB2YXIgc3RpbGxTaG93WmVyb1N1bSA9IHNlcmllc01vZGVsLmdldCgnc3RpbGxTaG93WmVyb1N1bScpO1xuICAgIC8vIEluIHRoZSBjYXNlIHNvbWUgc2VjdG9yIGFuZ2xlIGlzIHNtYWxsZXIgdGhhbiBtaW5BbmdsZVxuICAgIC8vIGxldCByZXN0QW5nbGUgPSBQSTI7XG4gICAgLy8gbGV0IHZhbHVlU3VtTGFyZ2VyVGhhbk1pbkFuZ2xlID0gMDtcbiAgICB2YXIgZGlyID0gY2xvY2t3aXNlID8gMSA6IC0xO1xuICAgIC8qKlxyXG4gICAgICogUmVuZGVyIGEgdHJlZVxyXG4gICAgICogQHJldHVybiBpbmNyZWFzZWQgYW5nbGVcclxuICAgICAqL1xuICAgIHZhciByZW5kZXJOb2RlID0gZnVuY3Rpb24gKG5vZGUsIHN0YXJ0QW5nbGUpIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZW5kQW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgICAgLy8gUmVuZGVyIHNlbGZcbiAgICAgIGlmIChub2RlICE9PSB2aXJ0dWFsUm9vdCkge1xuICAgICAgICAvLyBUcmVlIG5vZGUgaXMgdmlydHVhbCwgc28gaXQgZG9lc24ndCBuZWVkIHRvIGJlIGRyYXduXG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0VmFsdWUoKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gc3VtID09PSAwICYmIHN0aWxsU2hvd1plcm9TdW0gPyB1bml0UmFkaWFuIDogdmFsdWUgKiB1bml0UmFkaWFuO1xuICAgICAgICBpZiAoYW5nbGUgPCBtaW5BbmdsZSkge1xuICAgICAgICAgIGFuZ2xlID0gbWluQW5nbGU7XG4gICAgICAgICAgLy8gcmVzdEFuZ2xlIC09IG1pbkFuZ2xlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2Uge1xuICAgICAgICAvLyAgICAgdmFsdWVTdW1MYXJnZXJUaGFuTWluQW5nbGUgKz0gdmFsdWU7XG4gICAgICAgIC8vIH1cbiAgICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgZGlyICogYW5nbGU7XG4gICAgICAgIHZhciBkZXB0aCA9IG5vZGUuZGVwdGggLSByb290RGVwdGggLSAocmVuZGVyUm9sbHVwTm9kZSA/IC0xIDogMSk7XG4gICAgICAgIHZhciByU3RhcnQgPSByMCArIHJQZXJMZXZlbCAqIGRlcHRoO1xuICAgICAgICB2YXIgckVuZCA9IHIwICsgclBlckxldmVsICogKGRlcHRoICsgMSk7XG4gICAgICAgIHZhciBsZXZlbE1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TGV2ZWxNb2RlbChub2RlKTtcbiAgICAgICAgaWYgKGxldmVsTW9kZWwpIHtcbiAgICAgICAgICB2YXIgcjBfMSA9IGxldmVsTW9kZWwuZ2V0KCdyMCcsIHRydWUpO1xuICAgICAgICAgIHZhciByXzEgPSBsZXZlbE1vZGVsLmdldCgncicsIHRydWUpO1xuICAgICAgICAgIHZhciByYWRpdXNfMSA9IGxldmVsTW9kZWwuZ2V0KCdyYWRpdXMnLCB0cnVlKTtcbiAgICAgICAgICBpZiAocmFkaXVzXzEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcjBfMSA9IHJhZGl1c18xWzBdO1xuICAgICAgICAgICAgcl8xID0gcmFkaXVzXzFbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHIwXzEgIT0gbnVsbCAmJiAoclN0YXJ0ID0gcGFyc2VQZXJjZW50KHIwXzEsIHNpemUgLyAyKSk7XG4gICAgICAgICAgcl8xICE9IG51bGwgJiYgKHJFbmQgPSBwYXJzZVBlcmNlbnQocl8xLCBzaXplIC8gMikpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgY2xvY2t3aXNlOiBjbG9ja3dpc2UsXG4gICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICByMDogclN0YXJ0LFxuICAgICAgICAgIHI6IHJFbmRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBSZW5kZXIgY2hpbGRyZW5cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIGN1cnJlbnRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgICAgIHZhciBzaWJsaW5nQW5nbGVfMSA9IDA7XG4gICAgICAgIHpyVXRpbC5lYWNoKG5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgc2libGluZ0FuZ2xlXzEgKz0gcmVuZGVyTm9kZShub2RlLCBzdGFydEFuZ2xlICsgc2libGluZ0FuZ2xlXzEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gICAgfTtcbiAgICAvLyBWaXJ0dWFsIHJvb3Qgbm9kZSBmb3Igcm9sbCB1cFxuICAgIGlmIChyZW5kZXJSb2xsdXBOb2RlKSB7XG4gICAgICB2YXIgclN0YXJ0ID0gcjA7XG4gICAgICB2YXIgckVuZCA9IHIwICsgclBlckxldmVsO1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5QSSAqIDI7XG4gICAgICB2aXJ0dWFsUm9vdC5zZXRMYXlvdXQoe1xuICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlICsgYW5nbGUsXG4gICAgICAgIGNsb2Nrd2lzZTogY2xvY2t3aXNlLFxuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeSxcbiAgICAgICAgcjA6IHJTdGFydCxcbiAgICAgICAgcjogckVuZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlck5vZGUodHJlZVJvb3QsIHN0YXJ0QW5nbGUpO1xuICB9KTtcbn1cbi8qKlxyXG4gKiBJbml0IG5vZGUgY2hpbGRyZW4gYnkgb3JkZXIgYW5kIHVwZGF0ZSB2aXN1YWxcclxuICovXG5mdW5jdGlvbiBpbml0Q2hpbGRyZW4obm9kZSwgc29ydE9yZGVyKSB7XG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4gfHwgW107XG4gIG5vZGUuY2hpbGRyZW4gPSBzb3J0KGNoaWxkcmVuLCBzb3J0T3JkZXIpO1xuICAvLyBJbml0IGNoaWxkcmVuIHJlY3Vyc2l2ZWx5XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB6clV0aWwuZWFjaChub2RlLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGluaXRDaGlsZHJlbihjaGlsZCwgc29ydE9yZGVyKTtcbiAgICB9KTtcbiAgfVxufVxuLyoqXHJcbiAqIFNvcnQgY2hpbGRyZW4gbm9kZXNcclxuICpcclxuICogQHBhcmFtIHtUcmVlTm9kZVtdfSAgICAgICAgICAgICAgIGNoaWxkcmVuIGNoaWxkcmVuIG9mIG5vZGUgdG8gYmUgc29ydGVkXHJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgZnVuY3Rpb24gfCBudWxsfSBzb3J0IHNvcnQgbWV0aG9kXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgU3VuYnVyc3RTZXJpZXMuanMgZm9yIGRldGFpbHMuXHJcbiAqL1xuZnVuY3Rpb24gc29ydChjaGlsZHJlbiwgc29ydE9yZGVyKSB7XG4gIGlmICh6clV0aWwuaXNGdW5jdGlvbihzb3J0T3JkZXIpKSB7XG4gICAgdmFyIHNvcnRUYXJnZXRzID0genJVdGlsLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBpZHgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGNoaWxkLmdldFZhbHVlKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBkZXB0aDogY2hpbGQuZGVwdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjaGlsZC5oZWlnaHQsXG4gICAgICAgICAgZGF0YUluZGV4OiBjaGlsZC5kYXRhSW5kZXgsXG4gICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluZGV4OiBpZHhcbiAgICAgIH07XG4gICAgfSk7XG4gICAgc29ydFRhcmdldHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIHNvcnRPcmRlcihhLnBhcmFtcywgYi5wYXJhbXMpO1xuICAgIH0pO1xuICAgIHJldHVybiB6clV0aWwubWFwKHNvcnRUYXJnZXRzLCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5bdGFyZ2V0LmluZGV4XTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaXNBc2NfMSA9IHNvcnRPcmRlciA9PT0gJ2FzYyc7XG4gICAgcmV0dXJuIGNoaWxkcmVuLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBkaWZmID0gKGEuZ2V0VmFsdWUoKSAtIGIuZ2V0VmFsdWUoKSkgKiAoaXNBc2NfMSA/IDEgOiAtMSk7XG4gICAgICByZXR1cm4gZGlmZiA9PT0gMCA/IChhLmRhdGFJbmRleCAtIGIuZGF0YUluZGV4KSAqIChpc0FzY18xID8gLTEgOiAxKSA6IGRpZmY7XG4gICAgfSk7XG4gIH1cbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGxpZnQgfSBmcm9tICd6cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzJztcbmltcG9ydCB7IGV4dGVuZCwgaXNTdHJpbmcgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3VuYnVyc3RWaXN1YWwoZWNNb2RlbCkge1xuICB2YXIgcGFsZXR0ZVNjb3BlID0ge307XG4gIC8vIERlZmF1bHQgY29sb3Igc3RyYXRlZ3lcbiAgZnVuY3Rpb24gcGlja0NvbG9yKG5vZGUsIHNlcmllc01vZGVsLCB0cmVlSGVpZ2h0KSB7XG4gICAgLy8gQ2hvb3NlIGNvbG9yIGZyb20gcGFsZXR0ZSBiYXNlZCBvbiB0aGUgZmlyc3QgbGV2ZWwuXG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQuZGVwdGggPiAxKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB2YXIgY29sb3IgPSBzZXJpZXNNb2RlbC5nZXRDb2xvckZyb21QYWxldHRlKGN1cnJlbnQubmFtZSB8fCBjdXJyZW50LmRhdGFJbmRleCArICcnLCBwYWxldHRlU2NvcGUpO1xuICAgIGlmIChub2RlLmRlcHRoID4gMSAmJiBpc1N0cmluZyhjb2xvcikpIHtcbiAgICAgIC8vIExpZ2h0ZXIgb24gdGhlIGRlZXBlciBsZXZlbC5cbiAgICAgIGNvbG9yID0gbGlmdChjb2xvciwgKG5vZGUuZGVwdGggLSAxKSAvICh0cmVlSGVpZ2h0IC0gMSkgKiAwLjUpO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdzdW5idXJzdCcsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciB0cmVlID0gZGF0YS50cmVlO1xuICAgIHRyZWUuZWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBtb2RlbCA9IG5vZGUuZ2V0TW9kZWwoKTtcbiAgICAgIHZhciBzdHlsZSA9IG1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgIGlmICghc3R5bGUuZmlsbCkge1xuICAgICAgICBzdHlsZS5maWxsID0gcGlja0NvbG9yKG5vZGUsIHNlcmllc01vZGVsLCB0cmVlLnJvb3QuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHZhciBleGlzdHNTdHlsZSA9IGRhdGEuZW5zdXJlVW5pcXVlSXRlbVZpc3VhbChub2RlLmRhdGFJbmRleCwgJ3N0eWxlJyk7XG4gICAgICBleHRlbmQoZXhpc3RzU3R5bGUsIHN0eWxlKTtcbiAgICB9KTtcbiAgfSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgU3VuYnVyc3RWaWV3IGZyb20gJy4vU3VuYnVyc3RWaWV3LmpzJztcbmltcG9ydCBTdW5idXJzdFNlcmllc01vZGVsIGZyb20gJy4vU3VuYnVyc3RTZXJpZXMuanMnO1xuaW1wb3J0IHN1bmJ1cnN0TGF5b3V0IGZyb20gJy4vc3VuYnVyc3RMYXlvdXQuanMnO1xuaW1wb3J0IHN1bmJ1cnN0VmlzdWFsIGZyb20gJy4vc3VuYnVyc3RWaXN1YWwuanMnO1xuaW1wb3J0IGRhdGFGaWx0ZXIgZnJvbSAnLi4vLi4vcHJvY2Vzc29yL2RhdGFGaWx0ZXIuanMnO1xuaW1wb3J0IHsgY3VycnkgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgaW5zdGFsbFN1bmJ1cnN0QWN0aW9uIH0gZnJvbSAnLi9zdW5idXJzdEFjdGlvbi5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ2hhcnRWaWV3KFN1bmJ1cnN0Vmlldyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclNlcmllc01vZGVsKFN1bmJ1cnN0U2VyaWVzTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQoY3Vycnkoc3VuYnVyc3RMYXlvdXQsICdzdW5idXJzdCcpKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJvY2Vzc29yKGN1cnJ5KGRhdGFGaWx0ZXIsICdzdW5idXJzdCcpKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyVmlzdWFsKHN1bmJ1cnN0VmlzdWFsKTtcbiAgaW5zdGFsbFN1bmJ1cnN0QWN0aW9uKHJlZ2lzdGVycyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///44710\n")},49917:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/treeHelper.js\nvar treeHelper = __webpack_require__(41616);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n;// ./node_modules/echarts/lib/chart/treemap/treemapAction.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar actionTypes = ['treemapZoomToNode', 'treemapRender', 'treemapMove'];\nfunction installTreemapAction(registers) {\n  for (var i = 0; i < actionTypes.length; i++) {\n    registers.registerAction({\n      type: actionTypes[i],\n      update: 'updateView'\n    }, util.noop);\n  }\n  registers.registerAction({\n    type: 'treemapRootToNode',\n    update: 'updateView'\n  }, function (payload, ecModel) {\n    ecModel.eachComponent({\n      mainType: 'series',\n      subType: 'treemap',\n      query: payload\n    }, handleRootToNode);\n    function handleRootToNode(model, index) {\n      var types = ['treemapZoomToNode', 'treemapRootToNode'];\n      var targetInfo = treeHelper/* retrieveTargetInfo */.mw(payload, types, model);\n      if (targetInfo) {\n        var originViewRoot = model.getViewRoot();\n        if (originViewRoot) {\n          payload.direction = treeHelper/* aboveViewRoot */.x5(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown';\n        }\n        model.resetViewRoot(targetInfo.node);\n      }\n    }\n  });\n}\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/Tree.js\nvar Tree = __webpack_require__(15719);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Model.js + 2 modules\nvar Model = __webpack_require__(43172);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js\nvar tooltipMarkup = __webpack_require__(3961);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/enableAriaDecalForTree.js\nvar enableAriaDecalForTree = __webpack_require__(68866);\n;// ./node_modules/echarts/lib/chart/treemap/TreemapSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\nvar TreemapSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(TreemapSeriesModel, _super);\n  function TreemapSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = TreemapSeriesModel.type;\n    _this.preventUsingHoverLayer = true;\n    return _this;\n  }\n  /**\r\n   * @override\r\n   */\n  TreemapSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    // Create a virtual root.\n    var root = {\n      name: option.name,\n      children: option.data\n    };\n    completeTreeValue(root);\n    var levels = option.levels || [];\n    // Used in \"visual priority\" in `treemapVisual.js`.\n    // This way is a little tricky, must satisfy the precondition:\n    //   1. There is no `treeNode.getModel('itemStyle.xxx')` used.\n    //   2. The `Model.prototype.getModel()` will not use any clone-like way.\n    var designatedVisualItemStyle = this.designatedVisualItemStyle = {};\n    var designatedVisualModel = new Model/* default */.A({\n      itemStyle: designatedVisualItemStyle\n    }, this, ecModel);\n    levels = option.levels = setDefault(levels, ecModel);\n    var levelModels = util.map(levels || [], function (levelDefine) {\n      return new Model/* default */.A(levelDefine, designatedVisualModel, ecModel);\n    }, this);\n    // Make sure always a new tree is created when setOption,\n    // in TreemapView, we check whether oldTree === newTree\n    // to choose mappings approach among old shapes and new shapes.\n    var tree = Tree/* default */.A.createTree(root, this, beforeLink);\n    function beforeLink(nodeData) {\n      nodeData.wrapMethod('getItemModel', function (model, idx) {\n        var node = tree.getNodeByDataIndex(idx);\n        var levelModel = node ? levelModels[node.depth] : null;\n        // If no levelModel, we also need `designatedVisualModel`.\n        model.parentModel = levelModel || designatedVisualModel;\n        return model;\n      });\n    }\n    return tree.data;\n  };\n  TreemapSeriesModel.prototype.optionUpdated = function () {\n    this.resetViewRoot();\n  };\n  /**\r\n   * @override\r\n   * @param {number} dataIndex\r\n   * @param {boolean} [mutipleSeries=false]\r\n   */\n  TreemapSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n    var data = this.getData();\n    var value = this.getRawValue(dataIndex);\n    var name = data.getName(dataIndex);\n    return (0,tooltipMarkup/* createTooltipMarkup */.Qx)('nameValue', {\n      name: name,\n      value: value\n    });\n  };\n  /**\r\n   * Add tree path to tooltip param\r\n   *\r\n   * @override\r\n   * @param {number} dataIndex\r\n   * @return {Object}\r\n   */\n  TreemapSeriesModel.prototype.getDataParams = function (dataIndex) {\n    var params = _super.prototype.getDataParams.apply(this, arguments);\n    var node = this.getData().tree.getNodeByDataIndex(dataIndex);\n    params.treeAncestors = (0,treeHelper/* wrapTreePathInfo */.ev)(node, this);\n    // compatitable the previous code.\n    params.treePathInfo = params.treeAncestors;\n    return params;\n  };\n  /**\r\n   * @public\r\n   * @param {Object} layoutInfo {\r\n   *                                x: containerGroup x\r\n   *                                y: containerGroup y\r\n   *                                width: containerGroup width\r\n   *                                height: containerGroup height\r\n   *                            }\r\n   */\n  TreemapSeriesModel.prototype.setLayoutInfo = function (layoutInfo) {\n    /**\r\n     * @readOnly\r\n     * @type {Object}\r\n     */\n    this.layoutInfo = this.layoutInfo || {};\n    util.extend(this.layoutInfo, layoutInfo);\n  };\n  /**\r\n   * @param  {string} id\r\n   * @return {number} index\r\n   */\n  TreemapSeriesModel.prototype.mapIdToIndex = function (id) {\n    // A feature is implemented:\n    // index is monotone increasing with the sequence of\n    // input id at the first time.\n    // This feature can make sure that each data item and its\n    // mapped color have the same index between data list and\n    // color list at the beginning, which is useful for user\n    // to adjust data-color mapping.\n    /**\r\n     * @private\r\n     * @type {Object}\r\n     */\n    var idIndexMap = this._idIndexMap;\n    if (!idIndexMap) {\n      idIndexMap = this._idIndexMap = util.createHashMap();\n      /**\r\n       * @private\r\n       * @type {number}\r\n       */\n      this._idIndexMapCount = 0;\n    }\n    var index = idIndexMap.get(id);\n    if (index == null) {\n      idIndexMap.set(id, index = this._idIndexMapCount++);\n    }\n    return index;\n  };\n  TreemapSeriesModel.prototype.getViewRoot = function () {\n    return this._viewRoot;\n  };\n  TreemapSeriesModel.prototype.resetViewRoot = function (viewRoot) {\n    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;\n    var root = this.getRawData().tree.root;\n    if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {\n      this._viewRoot = root;\n    }\n  };\n  TreemapSeriesModel.prototype.enableAriaDecal = function () {\n    (0,enableAriaDecalForTree/* default */.A)(this);\n  };\n  TreemapSeriesModel.type = 'series.treemap';\n  TreemapSeriesModel.layoutMode = 'box';\n  TreemapSeriesModel.defaultOption = {\n    // Disable progressive rendering\n    progressive: 0,\n    // size: ['80%', '80%'],            // deprecated, compatible with ec2.\n    left: 'center',\n    top: 'middle',\n    width: '80%',\n    height: '80%',\n    sort: true,\n    clipWindow: 'origin',\n    squareRatio: 0.5 * (1 + Math.sqrt(5)),\n    leafDepth: null,\n    drillDownIcon: '▶',\n    // to align specialized icon. ▷▶❒❐▼✚\n    zoomToNodeRatio: 0.32 * 0.32,\n    scaleLimit: null,\n    roam: true,\n    nodeClick: 'zoomToNode',\n    animation: true,\n    animationDurationUpdate: 900,\n    animationEasing: 'quinticInOut',\n    breadcrumb: {\n      show: true,\n      height: 22,\n      left: 'center',\n      top: 'bottom',\n      // right\n      // bottom\n      emptyItemWidth: 25,\n      itemStyle: {\n        color: 'rgba(0,0,0,0.7)',\n        textStyle: {\n          color: '#fff'\n        }\n      },\n      emphasis: {\n        itemStyle: {\n          color: 'rgba(0,0,0,0.9)' // '#5793f3',\n        }\n      }\n    },\n    label: {\n      show: true,\n      // Do not use textDistance, for ellipsis rect just the same as treemap node rect.\n      distance: 0,\n      padding: 5,\n      position: 'inside',\n      // formatter: null,\n      color: '#fff',\n      overflow: 'truncate'\n      // align\n      // verticalAlign\n    },\n    upperLabel: {\n      show: false,\n      position: [0, '50%'],\n      height: 20,\n      // formatter: null,\n      // color: '#fff',\n      overflow: 'truncate',\n      // align: null,\n      verticalAlign: 'middle'\n    },\n    itemStyle: {\n      color: null,\n      colorAlpha: null,\n      colorSaturation: null,\n      borderWidth: 0,\n      gapWidth: 0,\n      borderColor: '#fff',\n      borderColorSaturation: null // If specified, borderColor will be ineffective, and the\n      // border color is evaluated by color of current node and\n      // borderColorSaturation.\n    },\n    emphasis: {\n      upperLabel: {\n        show: true,\n        position: [0, '50%'],\n        overflow: 'truncate',\n        verticalAlign: 'middle'\n      }\n    },\n    visualDimension: 0,\n    visualMin: null,\n    visualMax: null,\n    color: [],\n    // level[n].color (if necessary).\n    // + Specify color list of each level. level[0].color would be global\n    // color list if not specified. (see method `setDefault`).\n    // + But set as a empty array to forbid fetch color from global palette\n    // when using nodeModel.get('color'), otherwise nodes on deep level\n    // will always has color palette set and are not able to inherit color\n    // from parent node.\n    // + TreemapSeries.color can not be set as 'none', otherwise effect\n    // legend color fetching (see seriesColor.js).\n    colorAlpha: null,\n    colorSaturation: null,\n    colorMappingBy: 'index',\n    visibleMin: 10,\n    // be rendered. Only works when sort is 'asc' or 'desc'.\n    childrenVisibleMin: null,\n    // grandchildren will not show.\n    // Why grandchildren? If not grandchildren but children,\n    // some siblings show children and some not,\n    // the appearance may be mess and not consistent,\n    levels: [] // Each item: {\n    //     visibleMin, itemStyle, visualDimension, label\n    // }\n  };\n  return TreemapSeriesModel;\n}(Series/* default */.A);\n/**\r\n * @param {Object} dataNode\r\n */\nfunction completeTreeValue(dataNode) {\n  // Postorder travel tree.\n  // If value of none-leaf node is not set,\n  // calculate it by suming up the value of all children.\n  var sum = 0;\n  util.each(dataNode.children, function (child) {\n    completeTreeValue(child);\n    var childValue = child.value;\n    util.isArray(childValue) && (childValue = childValue[0]);\n    sum += childValue;\n  });\n  var thisValue = dataNode.value;\n  if (util.isArray(thisValue)) {\n    thisValue = thisValue[0];\n  }\n  if (thisValue == null || isNaN(thisValue)) {\n    thisValue = sum;\n  }\n  // Value should not less than 0.\n  if (thisValue < 0) {\n    thisValue = 0;\n  }\n  util.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;\n}\n/**\r\n * set default to level configuration\r\n */\nfunction setDefault(levels, ecModel) {\n  var globalColorList = (0,model/* normalizeToArray */.qB)(ecModel.get('color'));\n  var globalDecalList = (0,model/* normalizeToArray */.qB)(ecModel.get(['aria', 'decal', 'decals']));\n  if (!globalColorList) {\n    return;\n  }\n  levels = levels || [];\n  var hasColorDefine;\n  var hasDecalDefine;\n  util.each(levels, function (levelDefine) {\n    var model = new Model/* default */.A(levelDefine);\n    var modelColor = model.get('color');\n    var modelDecal = model.get('decal');\n    if (model.get(['itemStyle', 'color']) || modelColor && modelColor !== 'none') {\n      hasColorDefine = true;\n    }\n    if (model.get(['itemStyle', 'decal']) || modelDecal && modelDecal !== 'none') {\n      hasDecalDefine = true;\n    }\n  });\n  var level0 = levels[0] || (levels[0] = {});\n  if (!hasColorDefine) {\n    level0.color = globalColorList.slice();\n  }\n  if (!hasDecalDefine && globalDecalList) {\n    level0.decal = globalDecalList.slice();\n  }\n  return levels;\n}\n/* harmony default export */ const TreemapSeries = (TreemapSeriesModel);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/DataDiffer.js\nvar DataDiffer = __webpack_require__(16563);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polygon.js\nvar Polygon = __webpack_require__(52505);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n;// ./node_modules/echarts/lib/chart/treemap/Breadcrumb.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nvar TEXT_PADDING = 8;\nvar ITEM_GAP = 8;\nvar ARRAY_LENGTH = 5;\nvar Breadcrumb = /** @class */function () {\n  function Breadcrumb(containerGroup) {\n    this.group = new Group/* default */.A();\n    containerGroup.add(this.group);\n  }\n  Breadcrumb.prototype.render = function (seriesModel, api, targetNode, onSelect) {\n    var model = seriesModel.getModel('breadcrumb');\n    var thisGroup = this.group;\n    thisGroup.removeAll();\n    if (!model.get('show') || !targetNode) {\n      return;\n    }\n    var normalStyleModel = model.getModel('itemStyle');\n    var emphasisModel = model.getModel('emphasis');\n    var textStyleModel = normalStyleModel.getModel('textStyle');\n    var emphasisTextStyleModel = emphasisModel.getModel(['itemStyle', 'textStyle']);\n    var layoutParam = {\n      pos: {\n        left: model.get('left'),\n        right: model.get('right'),\n        top: model.get('top'),\n        bottom: model.get('bottom')\n      },\n      box: {\n        width: api.getWidth(),\n        height: api.getHeight()\n      },\n      emptyItemWidth: model.get('emptyItemWidth'),\n      totalWidth: 0,\n      renderList: []\n    };\n    this._prepare(targetNode, layoutParam, textStyleModel);\n    this._renderContent(seriesModel, layoutParam, normalStyleModel, emphasisModel, textStyleModel, emphasisTextStyleModel, onSelect);\n    layout/* positionElement */.m$(thisGroup, layoutParam.pos, layoutParam.box);\n  };\n  /**\r\n   * Prepare render list and total width\r\n   * @private\r\n   */\n  Breadcrumb.prototype._prepare = function (targetNode, layoutParam, textStyleModel) {\n    for (var node = targetNode; node; node = node.parentNode) {\n      var text = (0,model/* convertOptionIdName */.vS)(node.getModel().get('name'), '');\n      var textRect = textStyleModel.getTextRect(text);\n      var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);\n      layoutParam.totalWidth += itemWidth + ITEM_GAP;\n      layoutParam.renderList.push({\n        node: node,\n        text: text,\n        width: itemWidth\n      });\n    }\n  };\n  /**\r\n   * @private\r\n   */\n  Breadcrumb.prototype._renderContent = function (seriesModel, layoutParam, normalStyleModel, emphasisModel, textStyleModel, emphasisTextStyleModel, onSelect) {\n    // Start rendering.\n    var lastX = 0;\n    var emptyItemWidth = layoutParam.emptyItemWidth;\n    var height = seriesModel.get(['breadcrumb', 'height']);\n    var availableSize = layout/* getAvailableSize */.HU(layoutParam.pos, layoutParam.box);\n    var totalWidth = layoutParam.totalWidth;\n    var renderList = layoutParam.renderList;\n    var emphasisItemStyle = emphasisModel.getModel('itemStyle').getItemStyle();\n    for (var i = renderList.length - 1; i >= 0; i--) {\n      var item = renderList[i];\n      var itemNode = item.node;\n      var itemWidth = item.width;\n      var text = item.text;\n      // Hdie text and shorten width if necessary.\n      if (totalWidth > availableSize.width) {\n        totalWidth -= itemWidth - emptyItemWidth;\n        itemWidth = emptyItemWidth;\n        text = null;\n      }\n      var el = new Polygon/* default */.A({\n        shape: {\n          points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)\n        },\n        style: (0,util.defaults)(normalStyleModel.getItemStyle(), {\n          lineJoin: 'bevel'\n        }),\n        textContent: new Text/* default */.Ay({\n          style: (0,labelStyle/* createTextStyle */.VB)(textStyleModel, {\n            text: text\n          })\n        }),\n        textConfig: {\n          position: 'inside'\n        },\n        z2: states/* Z2_EMPHASIS_LIFT */.CA * 1e4,\n        onclick: (0,util.curry)(onSelect, itemNode)\n      });\n      el.disableLabelAnimation = true;\n      el.getTextContent().ensureState('emphasis').style = (0,labelStyle/* createTextStyle */.VB)(emphasisTextStyleModel, {\n        text: text\n      });\n      el.ensureState('emphasis').style = emphasisItemStyle;\n      (0,states/* toggleHoverEmphasis */.Lm)(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n      this.group.add(el);\n      packEventData(el, seriesModel, itemNode);\n      lastX += itemWidth + ITEM_GAP;\n    }\n  };\n  Breadcrumb.prototype.remove = function () {\n    this.group.removeAll();\n  };\n  return Breadcrumb;\n}();\nfunction makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {\n  var points = [[head ? x : x - ARRAY_LENGTH, y], [x + itemWidth, y], [x + itemWidth, y + itemHeight], [head ? x : x - ARRAY_LENGTH, y + itemHeight]];\n  !tail && points.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);\n  !head && points.push([x, y + itemHeight / 2]);\n  return points;\n}\n// Package custom mouse event.\nfunction packEventData(el, seriesModel, itemNode) {\n  (0,innerStore/* getECData */.z)(el).eventData = {\n    componentType: 'series',\n    componentSubType: 'treemap',\n    componentIndex: seriesModel.componentIndex,\n    seriesIndex: seriesModel.seriesIndex,\n    seriesName: seriesModel.name,\n    seriesType: 'treemap',\n    selfType: 'breadcrumb',\n    nodeData: {\n      dataIndex: itemNode && itemNode.dataIndex,\n      name: itemNode && itemNode.name\n    },\n    treePathInfo: itemNode && (0,treeHelper/* wrapTreePathInfo */.ev)(itemNode, seriesModel)\n  };\n}\n/* harmony default export */ const treemap_Breadcrumb = (Breadcrumb);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/RoamController.js\nvar RoamController = __webpack_require__(81722);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/BoundingRect.js\nvar BoundingRect = __webpack_require__(29308);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/matrix.js\nvar matrix = __webpack_require__(45587);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/animation.js\nvar animation = __webpack_require__(63253);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/mixin/makeStyleMapper.js\nvar makeStyleMapper = __webpack_require__(32944);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Displayable.js\nvar Displayable = __webpack_require__(71519);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/format.js\nvar format = __webpack_require__(83412);\n;// ./node_modules/echarts/lib/chart/treemap/TreemapView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TreemapView_Group = Group/* default */.A;\nvar TreemapView_Rect = Rect/* default */.A;\nvar DRAG_THRESHOLD = 3;\nvar PATH_LABEL_NOAMAL = 'label';\nvar PATH_UPPERLABEL_NORMAL = 'upperLabel';\n// Should larger than emphasis states lift z\nvar Z2_BASE = states/* Z2_EMPHASIS_LIFT */.CA * 10; // Should bigger than every z2.\nvar Z2_BG = states/* Z2_EMPHASIS_LIFT */.CA * 2;\nvar Z2_CONTENT = states/* Z2_EMPHASIS_LIFT */.CA * 3;\nvar getStateItemStyle = (0,makeStyleMapper/* default */.A)([['fill', 'color'],\n// `borderColor` and `borderWidth` has been occupied,\n// so use `stroke` to indicate the stroke of the rect.\n['stroke', 'strokeColor'], ['lineWidth', 'strokeWidth'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']\n// Option decal is in `DecalObject` but style.decal is in `PatternObject`.\n// So do not transfer decal directly.\n]);\nvar getItemStyleNormal = function (model) {\n  // Normal style props should include emphasis style props.\n  var itemStyle = getStateItemStyle(model);\n  // Clear styles set by emphasis.\n  itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;\n  return itemStyle;\n};\nvar inner = (0,model/* makeInner */.$r)();\nvar TreemapView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(TreemapView, _super);\n  function TreemapView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = TreemapView.type;\n    _this._state = 'ready';\n    _this._storage = createStorage();\n    return _this;\n  }\n  /**\r\n   * @override\r\n   */\n  TreemapView.prototype.render = function (seriesModel, ecModel, api, payload) {\n    var models = ecModel.findComponents({\n      mainType: 'series',\n      subType: 'treemap',\n      query: payload\n    });\n    if ((0,util.indexOf)(models, seriesModel) < 0) {\n      return;\n    }\n    this.seriesModel = seriesModel;\n    this.api = api;\n    this.ecModel = ecModel;\n    var types = ['treemapZoomToNode', 'treemapRootToNode'];\n    var targetInfo = treeHelper/* retrieveTargetInfo */.mw(payload, types, seriesModel);\n    var payloadType = payload && payload.type;\n    var layoutInfo = seriesModel.layoutInfo;\n    var isInit = !this._oldTree;\n    var thisStorage = this._storage;\n    // Mark new root when action is treemapRootToNode.\n    var reRoot = payloadType === 'treemapRootToNode' && targetInfo && thisStorage ? {\n      rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],\n      direction: payload.direction\n    } : null;\n    var containerGroup = this._giveContainerGroup(layoutInfo);\n    var hasAnimation = seriesModel.get('animation');\n    var renderResult = this._doRender(containerGroup, seriesModel, reRoot);\n    hasAnimation && !isInit && (!payloadType || payloadType === 'treemapZoomToNode' || payloadType === 'treemapRootToNode') ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();\n    this._resetController(api);\n    this._renderBreadcrumb(seriesModel, api, targetInfo);\n  };\n  TreemapView.prototype._giveContainerGroup = function (layoutInfo) {\n    var containerGroup = this._containerGroup;\n    if (!containerGroup) {\n      // FIXME\n      // 加一层containerGroup是为了clip，但是现在clip功能并没有实现。\n      containerGroup = this._containerGroup = new TreemapView_Group();\n      this._initEvents(containerGroup);\n      this.group.add(containerGroup);\n    }\n    containerGroup.x = layoutInfo.x;\n    containerGroup.y = layoutInfo.y;\n    return containerGroup;\n  };\n  TreemapView.prototype._doRender = function (containerGroup, seriesModel, reRoot) {\n    var thisTree = seriesModel.getData().tree;\n    var oldTree = this._oldTree;\n    // Clear last shape records.\n    var lastsForAnimation = createStorage();\n    var thisStorage = createStorage();\n    var oldStorage = this._storage;\n    var willInvisibleEls = [];\n    function doRenderNode(thisNode, oldNode, parentGroup, depth) {\n      return renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth);\n    }\n    // Notice: When thisTree and oldTree are the same tree (see list.cloneShallow),\n    // the oldTree is actually losted, so we cannot find all of the old graphic\n    // elements from tree. So we use this strategy: make element storage, move\n    // from old storage to new storage, clear old storage.\n    dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0);\n    // Process all removing.\n    var willDeleteEls = clearStorage(oldStorage);\n    this._oldTree = thisTree;\n    this._storage = thisStorage;\n    if (this._controllerHost) {\n      var _oldRootLayout = this.seriesModel.layoutInfo;\n      var rootLayout = thisTree.root.getLayout();\n      if (rootLayout.width === _oldRootLayout.width && rootLayout.height === _oldRootLayout.height) {\n        this._controllerHost.zoom = 1;\n      }\n    }\n    return {\n      lastsForAnimation: lastsForAnimation,\n      willDeleteEls: willDeleteEls,\n      renderFinally: renderFinally\n    };\n    function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {\n      // When 'render' is triggered by action,\n      // 'this' and 'old' may be the same tree,\n      // we use rawIndex in that case.\n      if (sameTree) {\n        oldViewChildren = thisViewChildren;\n        (0,util.each)(thisViewChildren, function (child, index) {\n          !child.isRemoved() && processNode(index, index);\n        });\n      }\n      // Diff hierarchically (diff only in each subtree, but not whole).\n      // because, consistency of view is important.\n      else {\n        new DataDiffer/* default */.A(oldViewChildren, thisViewChildren, getKey, getKey).add(processNode).update(processNode).remove((0,util.curry)(processNode, null)).execute();\n      }\n      function getKey(node) {\n        // Identify by name or raw index.\n        return node.getId();\n      }\n      function processNode(newIndex, oldIndex) {\n        var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;\n        var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;\n        var group = doRenderNode(thisNode, oldNode, parentGroup, depth);\n        group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);\n      }\n    }\n    function clearStorage(storage) {\n      var willDeleteEls = createStorage();\n      storage && (0,util.each)(storage, function (store, storageName) {\n        var delEls = willDeleteEls[storageName];\n        (0,util.each)(store, function (el) {\n          el && (delEls.push(el), inner(el).willDelete = true);\n        });\n      });\n      return willDeleteEls;\n    }\n    function renderFinally() {\n      (0,util.each)(willDeleteEls, function (els) {\n        (0,util.each)(els, function (el) {\n          el.parent && el.parent.remove(el);\n        });\n      });\n      (0,util.each)(willInvisibleEls, function (el) {\n        el.invisible = true;\n        // Setting invisible is for optimizing, so no need to set dirty,\n        // just mark as invisible.\n        el.dirty();\n      });\n    }\n  };\n  TreemapView.prototype._doAnimation = function (containerGroup, renderResult, seriesModel, reRoot) {\n    var durationOption = seriesModel.get('animationDurationUpdate');\n    var easingOption = seriesModel.get('animationEasing');\n    // TODO: do not support function until necessary.\n    var duration = ((0,util.isFunction)(durationOption) ? 0 : durationOption) || 0;\n    var easing = ((0,util.isFunction)(easingOption) ? null : easingOption) || 'cubicOut';\n    var animationWrap = animation/* createWrap */.x();\n    // Make delete animations.\n    (0,util.each)(renderResult.willDeleteEls, function (store, storageName) {\n      (0,util.each)(store, function (el, rawIndex) {\n        if (el.invisible) {\n          return;\n        }\n        var parent = el.parent; // Always has parent, and parent is nodeGroup.\n        var target;\n        var innerStore = inner(parent);\n        if (reRoot && reRoot.direction === 'drillDown') {\n          target = parent === reRoot.rootNodeGroup\n          // This is the content element of view root.\n          // Only `content` will enter this branch, because\n          // `background` and `nodeGroup` will not be deleted.\n          ? {\n            shape: {\n              x: 0,\n              y: 0,\n              width: innerStore.nodeWidth,\n              height: innerStore.nodeHeight\n            },\n            style: {\n              opacity: 0\n            }\n          }\n          // Others.\n          : {\n            style: {\n              opacity: 0\n            }\n          };\n        } else {\n          var targetX = 0;\n          var targetY = 0;\n          if (!innerStore.willDelete) {\n            // Let node animate to right-bottom corner, cooperating with fadeout,\n            // which is appropriate for user understanding.\n            // Divided by 2 for reRoot rolling up effect.\n            targetX = innerStore.nodeWidth / 2;\n            targetY = innerStore.nodeHeight / 2;\n          }\n          target = storageName === 'nodeGroup' ? {\n            x: targetX,\n            y: targetY,\n            style: {\n              opacity: 0\n            }\n          } : {\n            shape: {\n              x: targetX,\n              y: targetY,\n              width: 0,\n              height: 0\n            },\n            style: {\n              opacity: 0\n            }\n          };\n        }\n        // TODO: do not support delay until necessary.\n        target && animationWrap.add(el, target, duration, 0, easing);\n      });\n    });\n    // Make other animations\n    (0,util.each)(this._storage, function (store, storageName) {\n      (0,util.each)(store, function (el, rawIndex) {\n        var last = renderResult.lastsForAnimation[storageName][rawIndex];\n        var target = {};\n        if (!last) {\n          return;\n        }\n        if (el instanceof Group/* default */.A) {\n          if (last.oldX != null) {\n            target.x = el.x;\n            target.y = el.y;\n            el.x = last.oldX;\n            el.y = last.oldY;\n          }\n        } else {\n          if (last.oldShape) {\n            target.shape = (0,util.extend)({}, el.shape);\n            el.setShape(last.oldShape);\n          }\n          if (last.fadein) {\n            el.setStyle('opacity', 0);\n            target.style = {\n              opacity: 1\n            };\n          }\n          // When animation is stopped for succedent animation starting,\n          // el.style.opacity might not be 1\n          else if (el.style.opacity !== 1) {\n            target.style = {\n              opacity: 1\n            };\n          }\n        }\n        animationWrap.add(el, target, duration, 0, easing);\n      });\n    }, this);\n    this._state = 'animating';\n    animationWrap.finished((0,util.bind)(function () {\n      this._state = 'ready';\n      renderResult.renderFinally();\n    }, this)).start();\n  };\n  TreemapView.prototype._resetController = function (api) {\n    var controller = this._controller;\n    var controllerHost = this._controllerHost;\n    if (!controllerHost) {\n      this._controllerHost = {\n        target: this.group\n      };\n      controllerHost = this._controllerHost;\n    }\n    // Init controller.\n    if (!controller) {\n      controller = this._controller = new RoamController/* default */.A(api.getZr());\n      controller.enable(this.seriesModel.get('roam'));\n      controllerHost.zoomLimit = this.seriesModel.get('scaleLimit');\n      controllerHost.zoom = this.seriesModel.get('zoom');\n      controller.on('pan', (0,util.bind)(this._onPan, this));\n      controller.on('zoom', (0,util.bind)(this._onZoom, this));\n    }\n    var rect = new BoundingRect/* default */.A(0, 0, api.getWidth(), api.getHeight());\n    controller.setPointerChecker(function (e, x, y) {\n      return rect.contain(x, y);\n    });\n  };\n  TreemapView.prototype._clearController = function () {\n    var controller = this._controller;\n    this._controllerHost = null;\n    if (controller) {\n      controller.dispose();\n      controller = null;\n    }\n  };\n  TreemapView.prototype._onPan = function (e) {\n    if (this._state !== 'animating' && (Math.abs(e.dx) > DRAG_THRESHOLD || Math.abs(e.dy) > DRAG_THRESHOLD)) {\n      // These param must not be cached.\n      var root = this.seriesModel.getData().tree.root;\n      if (!root) {\n        return;\n      }\n      var rootLayout = root.getLayout();\n      if (!rootLayout) {\n        return;\n      }\n      this.api.dispatchAction({\n        type: 'treemapMove',\n        from: this.uid,\n        seriesId: this.seriesModel.id,\n        rootRect: {\n          x: rootLayout.x + e.dx,\n          y: rootLayout.y + e.dy,\n          width: rootLayout.width,\n          height: rootLayout.height\n        }\n      });\n    }\n  };\n  TreemapView.prototype._onZoom = function (e) {\n    var mouseX = e.originX;\n    var mouseY = e.originY;\n    var zoomDelta = e.scale;\n    if (this._state !== 'animating') {\n      // These param must not be cached.\n      var root = this.seriesModel.getData().tree.root;\n      if (!root) {\n        return;\n      }\n      var rootLayout = root.getLayout();\n      if (!rootLayout) {\n        return;\n      }\n      var rect = new BoundingRect/* default */.A(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);\n      // scaleLimit\n      var zoomLimit = null;\n      var _controllerHost = this._controllerHost;\n      zoomLimit = _controllerHost.zoomLimit;\n      var newZoom = _controllerHost.zoom = _controllerHost.zoom || 1;\n      newZoom *= zoomDelta;\n      if (zoomLimit) {\n        var zoomMin = zoomLimit.min || 0;\n        var zoomMax = zoomLimit.max || Infinity;\n        newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);\n      }\n      var zoomScale = newZoom / _controllerHost.zoom;\n      _controllerHost.zoom = newZoom;\n      var layoutInfo = this.seriesModel.layoutInfo;\n      // Transform mouse coord from global to containerGroup.\n      mouseX -= layoutInfo.x;\n      mouseY -= layoutInfo.y;\n      // Scale root bounding rect.\n      var m = matrix.create();\n      matrix.translate(m, m, [-mouseX, -mouseY]);\n      matrix.scale(m, m, [zoomScale, zoomScale]);\n      matrix.translate(m, m, [mouseX, mouseY]);\n      rect.applyTransform(m);\n      this.api.dispatchAction({\n        type: 'treemapRender',\n        from: this.uid,\n        seriesId: this.seriesModel.id,\n        rootRect: {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        }\n      });\n    }\n  };\n  TreemapView.prototype._initEvents = function (containerGroup) {\n    var _this = this;\n    containerGroup.on('click', function (e) {\n      if (_this._state !== 'ready') {\n        return;\n      }\n      var nodeClick = _this.seriesModel.get('nodeClick', true);\n      if (!nodeClick) {\n        return;\n      }\n      var targetInfo = _this.findTarget(e.offsetX, e.offsetY);\n      if (!targetInfo) {\n        return;\n      }\n      var node = targetInfo.node;\n      if (node.getLayout().isLeafRoot) {\n        _this._rootToNode(targetInfo);\n      } else {\n        if (nodeClick === 'zoomToNode') {\n          _this._zoomToNode(targetInfo);\n        } else if (nodeClick === 'link') {\n          var itemModel = node.hostTree.data.getItemModel(node.dataIndex);\n          var link = itemModel.get('link', true);\n          var linkTarget = itemModel.get('target', true) || 'blank';\n          link && (0,format/* windowOpen */.JW)(link, linkTarget);\n        }\n      }\n    }, this);\n  };\n  TreemapView.prototype._renderBreadcrumb = function (seriesModel, api, targetInfo) {\n    var _this = this;\n    if (!targetInfo) {\n      targetInfo = seriesModel.get('leafDepth', true) != null ? {\n        node: seriesModel.getViewRoot()\n      }\n      // FIXME\n      // better way?\n      // Find breadcrumb tail on center of containerGroup.\n      : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);\n      if (!targetInfo) {\n        targetInfo = {\n          node: seriesModel.getData().tree.root\n        };\n      }\n    }\n    (this._breadcrumb || (this._breadcrumb = new treemap_Breadcrumb(this.group))).render(seriesModel, api, targetInfo.node, function (node) {\n      if (_this._state !== 'animating') {\n        treeHelper/* aboveViewRoot */.x5(seriesModel.getViewRoot(), node) ? _this._rootToNode({\n          node: node\n        }) : _this._zoomToNode({\n          node: node\n        });\n      }\n    });\n  };\n  /**\r\n   * @override\r\n   */\n  TreemapView.prototype.remove = function () {\n    this._clearController();\n    this._containerGroup && this._containerGroup.removeAll();\n    this._storage = createStorage();\n    this._state = 'ready';\n    this._breadcrumb && this._breadcrumb.remove();\n  };\n  TreemapView.prototype.dispose = function () {\n    this._clearController();\n  };\n  TreemapView.prototype._zoomToNode = function (targetInfo) {\n    this.api.dispatchAction({\n      type: 'treemapZoomToNode',\n      from: this.uid,\n      seriesId: this.seriesModel.id,\n      targetNode: targetInfo.node\n    });\n  };\n  TreemapView.prototype._rootToNode = function (targetInfo) {\n    this.api.dispatchAction({\n      type: 'treemapRootToNode',\n      from: this.uid,\n      seriesId: this.seriesModel.id,\n      targetNode: targetInfo.node\n    });\n  };\n  /**\r\n   * @public\r\n   * @param {number} x Global coord x.\r\n   * @param {number} y Global coord y.\r\n   * @return {Object} info If not found, return undefined;\r\n   * @return {number} info.node Target node.\r\n   * @return {number} info.offsetX x refer to target node.\r\n   * @return {number} info.offsetY y refer to target node.\r\n   */\n  TreemapView.prototype.findTarget = function (x, y) {\n    var targetInfo;\n    var viewRoot = this.seriesModel.getViewRoot();\n    viewRoot.eachNode({\n      attr: 'viewChildren',\n      order: 'preorder'\n    }, function (node) {\n      var bgEl = this._storage.background[node.getRawIndex()];\n      // If invisible, there might be no element.\n      if (bgEl) {\n        var point = bgEl.transformCoordToLocal(x, y);\n        var shape = bgEl.shape;\n        // For performance consideration, don't use 'getBoundingRect'.\n        if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {\n          targetInfo = {\n            node: node,\n            offsetX: point[0],\n            offsetY: point[1]\n          };\n        } else {\n          return false; // Suppress visit subtree.\n        }\n      }\n    }, this);\n    return targetInfo;\n  };\n  TreemapView.type = 'treemap';\n  return TreemapView;\n}(Chart/* default */.A);\n/**\r\n * @inner\r\n */\nfunction createStorage() {\n  return {\n    nodeGroup: [],\n    background: [],\n    content: []\n  };\n}\n/**\r\n * @inner\r\n * @return Return undefined means do not travel further.\r\n */\nfunction renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {\n  // Whether under viewRoot.\n  if (!thisNode) {\n    // Deleting nodes will be performed finally. This method just find\n    // element from old storage, or create new element, set them to new\n    // storage, and set styles.\n    return;\n  }\n  // -------------------------------------------------------------------\n  // Start of closure variables available in \"Procedures in renderNode\".\n  var thisLayout = thisNode.getLayout();\n  var data = seriesModel.getData();\n  var nodeModel = thisNode.getModel();\n  // Only for enabling highlight/downplay. Clear firstly.\n  // Because some node will not be rendered.\n  data.setItemGraphicEl(thisNode.dataIndex, null);\n  if (!thisLayout || !thisLayout.isInView) {\n    return;\n  }\n  var thisWidth = thisLayout.width;\n  var thisHeight = thisLayout.height;\n  var borderWidth = thisLayout.borderWidth;\n  var thisInvisible = thisLayout.invisible;\n  var thisRawIndex = thisNode.getRawIndex();\n  var oldRawIndex = oldNode && oldNode.getRawIndex();\n  var thisViewChildren = thisNode.viewChildren;\n  var upperHeight = thisLayout.upperHeight;\n  var isParent = thisViewChildren && thisViewChildren.length;\n  var itemStyleNormalModel = nodeModel.getModel('itemStyle');\n  var itemStyleEmphasisModel = nodeModel.getModel(['emphasis', 'itemStyle']);\n  var itemStyleBlurModel = nodeModel.getModel(['blur', 'itemStyle']);\n  var itemStyleSelectModel = nodeModel.getModel(['select', 'itemStyle']);\n  var borderRadius = itemStyleNormalModel.get('borderRadius') || 0;\n  // End of closure ariables available in \"Procedures in renderNode\".\n  // -----------------------------------------------------------------\n  // Node group\n  var group = giveGraphic('nodeGroup', TreemapView_Group);\n  if (!group) {\n    return;\n  }\n  parentGroup.add(group);\n  // x,y are not set when el is above view root.\n  group.x = thisLayout.x || 0;\n  group.y = thisLayout.y || 0;\n  group.markRedraw();\n  inner(group).nodeWidth = thisWidth;\n  inner(group).nodeHeight = thisHeight;\n  if (thisLayout.isAboveViewRoot) {\n    return group;\n  }\n  // Background\n  var bg = giveGraphic('background', TreemapView_Rect, depth, Z2_BG);\n  bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight);\n  var emphasisModel = nodeModel.getModel('emphasis');\n  var focus = emphasisModel.get('focus');\n  var blurScope = emphasisModel.get('blurScope');\n  var isDisabled = emphasisModel.get('disabled');\n  var focusOrIndices = focus === 'ancestor' ? thisNode.getAncestorsIndices() : focus === 'descendant' ? thisNode.getDescendantIndices() : focus;\n  // No children, render content.\n  if (isParent) {\n    // Because of the implementation about \"traverse\" in graphic hover style, we\n    // can not set hover listener on the \"group\" of non-leaf node. Otherwise the\n    // hover event from the descendents will be listenered.\n    if ((0,states/* isHighDownDispatcher */.u6)(group)) {\n      (0,states/* setAsHighDownDispatcher */.ix)(group, false);\n    }\n    if (bg) {\n      (0,states/* setAsHighDownDispatcher */.ix)(bg, !isDisabled);\n      // Only for enabling highlight/downplay.\n      data.setItemGraphicEl(thisNode.dataIndex, bg);\n      (0,states/* enableHoverFocus */.gR)(bg, focusOrIndices, blurScope);\n    }\n  } else {\n    var content = giveGraphic('content', TreemapView_Rect, depth, Z2_CONTENT);\n    content && renderContent(group, content);\n    bg.disableMorphing = true;\n    if (bg && (0,states/* isHighDownDispatcher */.u6)(bg)) {\n      (0,states/* setAsHighDownDispatcher */.ix)(bg, false);\n    }\n    (0,states/* setAsHighDownDispatcher */.ix)(group, !isDisabled);\n    // Only for enabling highlight/downplay.\n    data.setItemGraphicEl(thisNode.dataIndex, group);\n    var cursorStyle = nodeModel.getShallow('cursor');\n    cursorStyle && content.attr('cursor', cursorStyle);\n    (0,states/* enableHoverFocus */.gR)(group, focusOrIndices, blurScope);\n  }\n  return group;\n  // ----------------------------\n  // | Procedures in renderNode |\n  // ----------------------------\n  function renderBackground(group, bg, useUpperLabel) {\n    var ecData = (0,innerStore/* getECData */.z)(bg);\n    // For tooltip.\n    ecData.dataIndex = thisNode.dataIndex;\n    ecData.seriesIndex = seriesModel.seriesIndex;\n    bg.setShape({\n      x: 0,\n      y: 0,\n      width: thisWidth,\n      height: thisHeight,\n      r: borderRadius\n    });\n    if (thisInvisible) {\n      // If invisible, do not set visual, otherwise the element will\n      // change immediately before animation. We think it is OK to\n      // remain its origin color when moving out of the view window.\n      processInvisible(bg);\n    } else {\n      bg.invisible = false;\n      var style = thisNode.getVisual('style');\n      var visualBorderColor = style.stroke;\n      var normalStyle = getItemStyleNormal(itemStyleNormalModel);\n      normalStyle.fill = visualBorderColor;\n      var emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);\n      emphasisStyle.fill = itemStyleEmphasisModel.get('borderColor');\n      var blurStyle = getStateItemStyle(itemStyleBlurModel);\n      blurStyle.fill = itemStyleBlurModel.get('borderColor');\n      var selectStyle = getStateItemStyle(itemStyleSelectModel);\n      selectStyle.fill = itemStyleSelectModel.get('borderColor');\n      if (useUpperLabel) {\n        var upperLabelWidth = thisWidth - 2 * borderWidth;\n        prepareText(\n        // PENDING: convert ZRColor to ColorString for text.\n        bg, visualBorderColor, style.opacity, {\n          x: borderWidth,\n          y: 0,\n          width: upperLabelWidth,\n          height: upperHeight\n        });\n      }\n      // For old bg.\n      else {\n        bg.removeTextContent();\n      }\n      bg.setStyle(normalStyle);\n      bg.ensureState('emphasis').style = emphasisStyle;\n      bg.ensureState('blur').style = blurStyle;\n      bg.ensureState('select').style = selectStyle;\n      (0,states/* setDefaultStateProxy */.DW)(bg);\n    }\n    group.add(bg);\n  }\n  function renderContent(group, content) {\n    var ecData = (0,innerStore/* getECData */.z)(content);\n    // For tooltip.\n    ecData.dataIndex = thisNode.dataIndex;\n    ecData.seriesIndex = seriesModel.seriesIndex;\n    var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);\n    var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);\n    content.culling = true;\n    content.setShape({\n      x: borderWidth,\n      y: borderWidth,\n      width: contentWidth,\n      height: contentHeight,\n      r: borderRadius\n    });\n    if (thisInvisible) {\n      // If invisible, do not set visual, otherwise the element will\n      // change immediately before animation. We think it is OK to\n      // remain its origin color when moving out of the view window.\n      processInvisible(content);\n    } else {\n      content.invisible = false;\n      var nodeStyle = thisNode.getVisual('style');\n      var visualColor = nodeStyle.fill;\n      var normalStyle = getItemStyleNormal(itemStyleNormalModel);\n      normalStyle.fill = visualColor;\n      normalStyle.decal = nodeStyle.decal;\n      var emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);\n      var blurStyle = getStateItemStyle(itemStyleBlurModel);\n      var selectStyle = getStateItemStyle(itemStyleSelectModel);\n      // PENDING: convert ZRColor to ColorString for text.\n      prepareText(content, visualColor, nodeStyle.opacity, null);\n      content.setStyle(normalStyle);\n      content.ensureState('emphasis').style = emphasisStyle;\n      content.ensureState('blur').style = blurStyle;\n      content.ensureState('select').style = selectStyle;\n      (0,states/* setDefaultStateProxy */.DW)(content);\n    }\n    group.add(content);\n  }\n  function processInvisible(element) {\n    // Delay invisible setting utill animation finished,\n    // avoid element vanish suddenly before animation.\n    !element.invisible && willInvisibleEls.push(element);\n  }\n  function prepareText(rectEl, visualColor, visualOpacity,\n  // Can be null/undefined\n  upperLabelRect) {\n    var normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);\n    var defaultText = (0,model/* convertOptionIdName */.vS)(nodeModel.get('name'), null);\n    var isShow = normalLabelModel.getShallow('show');\n    (0,labelStyle/* setLabelStyle */.qM)(rectEl, (0,labelStyle/* getLabelStatesModels */.lx)(nodeModel, upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), {\n      defaultText: isShow ? defaultText : null,\n      inheritColor: visualColor,\n      defaultOpacity: visualOpacity,\n      labelFetcher: seriesModel,\n      labelDataIndex: thisNode.dataIndex\n    });\n    var textEl = rectEl.getTextContent();\n    if (!textEl) {\n      return;\n    }\n    var textStyle = textEl.style;\n    var textPadding = (0,util.normalizeCssArray)(textStyle.padding || 0);\n    if (upperLabelRect) {\n      rectEl.setTextConfig({\n        layoutRect: upperLabelRect\n      });\n      textEl.disableLabelLayout = true;\n    }\n    textEl.beforeUpdate = function () {\n      var width = Math.max((upperLabelRect ? upperLabelRect.width : rectEl.shape.width) - textPadding[1] - textPadding[3], 0);\n      var height = Math.max((upperLabelRect ? upperLabelRect.height : rectEl.shape.height) - textPadding[0] - textPadding[2], 0);\n      if (textStyle.width !== width || textStyle.height !== height) {\n        textEl.setStyle({\n          width: width,\n          height: height\n        });\n      }\n    };\n    textStyle.truncateMinChar = 2;\n    textStyle.lineOverflow = 'truncate';\n    addDrillDownIcon(textStyle, upperLabelRect, thisLayout);\n    var textEmphasisState = textEl.getState('emphasis');\n    addDrillDownIcon(textEmphasisState ? textEmphasisState.style : null, upperLabelRect, thisLayout);\n  }\n  function addDrillDownIcon(style, upperLabelRect, thisLayout) {\n    var text = style ? style.text : null;\n    if (!upperLabelRect && thisLayout.isLeafRoot && text != null) {\n      var iconChar = seriesModel.get('drillDownIcon', true);\n      style.text = iconChar ? iconChar + ' ' + text : text;\n    }\n  }\n  function giveGraphic(storageName, Ctor, depth, z) {\n    var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];\n    var lasts = lastsForAnimation[storageName];\n    if (element) {\n      // Remove from oldStorage\n      oldStorage[storageName][oldRawIndex] = null;\n      prepareAnimationWhenHasOld(lasts, element);\n    }\n    // If invisible and no old element, do not create new element (for optimizing).\n    else if (!thisInvisible) {\n      element = new Ctor();\n      if (element instanceof Displayable/* default */.Ay) {\n        element.z2 = calculateZ2(depth, z);\n      }\n      prepareAnimationWhenNoOld(lasts, element);\n    }\n    // Set to thisStorage\n    return thisStorage[storageName][thisRawIndex] = element;\n  }\n  function prepareAnimationWhenHasOld(lasts, element) {\n    var lastCfg = lasts[thisRawIndex] = {};\n    if (element instanceof TreemapView_Group) {\n      lastCfg.oldX = element.x;\n      lastCfg.oldY = element.y;\n    } else {\n      lastCfg.oldShape = (0,util.extend)({}, element.shape);\n    }\n  }\n  // If a element is new, we need to find the animation start point carefully,\n  // otherwise it will looks strange when 'zoomToNode'.\n  function prepareAnimationWhenNoOld(lasts, element) {\n    var lastCfg = lasts[thisRawIndex] = {};\n    var parentNode = thisNode.parentNode;\n    var isGroup = element instanceof Group/* default */.A;\n    if (parentNode && (!reRoot || reRoot.direction === 'drillDown')) {\n      var parentOldX = 0;\n      var parentOldY = 0;\n      // New nodes appear from right-bottom corner in 'zoomToNode' animation.\n      // For convenience, get old bounding rect from background.\n      var parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()];\n      if (!reRoot && parentOldBg && parentOldBg.oldShape) {\n        parentOldX = parentOldBg.oldShape.width;\n        parentOldY = parentOldBg.oldShape.height;\n      }\n      // When no parent old shape found, its parent is new too,\n      // so we can just use {x:0, y:0}.\n      if (isGroup) {\n        lastCfg.oldX = 0;\n        lastCfg.oldY = parentOldY;\n      } else {\n        lastCfg.oldShape = {\n          x: parentOldX,\n          y: parentOldY,\n          width: 0,\n          height: 0\n        };\n      }\n    }\n    // Fade in, user can be aware that these nodes are new.\n    lastCfg.fadein = !isGroup;\n  }\n}\n// We cannot set all background with the same z, because the behaviour of\n// drill down and roll up differ background creation sequence from tree\n// hierarchy sequence, which cause lower background elements to overlap\n// upper ones. So we calculate z based on depth.\n// Moreover, we try to shrink down z interval to [0, 1] to avoid that\n// treemap with large z overlaps other components.\nfunction calculateZ2(depth, z2InLevel) {\n  return depth * Z2_BASE + z2InLevel;\n}\n/* harmony default export */ const treemap_TreemapView = (TreemapView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/VisualMapping.js\nvar VisualMapping = __webpack_require__(7857);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/tool/color.js\nvar tool_color = __webpack_require__(47698);\n;// ./node_modules/echarts/lib/chart/treemap/treemapVisual.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar ITEM_STYLE_NORMAL = 'itemStyle';\nvar treemapVisual_inner = (0,model/* makeInner */.$r)();\n/* harmony default export */ const treemapVisual = ({\n  seriesType: 'treemap',\n  reset: function (seriesModel) {\n    var tree = seriesModel.getData().tree;\n    var root = tree.root;\n    if (root.isRemoved()) {\n      return;\n    }\n    travelTree(root,\n    // Visual should calculate from tree root but not view root.\n    {}, seriesModel.getViewRoot().getAncestors(), seriesModel);\n  }\n});\nfunction travelTree(node, designatedVisual, viewRootAncestors, seriesModel) {\n  var nodeModel = node.getModel();\n  var nodeLayout = node.getLayout();\n  var data = node.hostTree.data;\n  // Optimize\n  if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {\n    return;\n  }\n  var nodeItemStyleModel = nodeModel.getModel(ITEM_STYLE_NORMAL);\n  var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel);\n  var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, 'style');\n  // calculate border color\n  var borderColor = nodeItemStyleModel.get('borderColor');\n  var borderColorSaturation = nodeItemStyleModel.get('borderColorSaturation');\n  var thisNodeColor;\n  if (borderColorSaturation != null) {\n    // For performance, do not always execute 'calculateColor'.\n    thisNodeColor = calculateColor(visuals);\n    borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);\n  }\n  existsStyle.stroke = borderColor;\n  var viewChildren = node.viewChildren;\n  if (!viewChildren || !viewChildren.length) {\n    thisNodeColor = calculateColor(visuals);\n    // Apply visual to this node.\n    existsStyle.fill = thisNodeColor;\n  } else {\n    var mapping_1 = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren);\n    // Designate visual to children.\n    (0,util.each)(viewChildren, function (child, index) {\n      // If higher than viewRoot, only ancestors of viewRoot is needed to visit.\n      if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {\n        var childVisual = mapVisual(nodeModel, visuals, child, index, mapping_1, seriesModel);\n        travelTree(child, childVisual, viewRootAncestors, seriesModel);\n      }\n    });\n  }\n}\nfunction buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel) {\n  var visuals = (0,util.extend)({}, designatedVisual);\n  var designatedVisualItemStyle = seriesModel.designatedVisualItemStyle;\n  (0,util.each)(['color', 'colorAlpha', 'colorSaturation'], function (visualName) {\n    // Priority: thisNode > thisLevel > parentNodeDesignated > seriesModel\n    designatedVisualItemStyle[visualName] = designatedVisual[visualName];\n    var val = nodeItemStyleModel.get(visualName);\n    designatedVisualItemStyle[visualName] = null;\n    val != null && (visuals[visualName] = val);\n  });\n  return visuals;\n}\nfunction calculateColor(visuals) {\n  var color = getValueVisualDefine(visuals, 'color');\n  if (color) {\n    var colorAlpha = getValueVisualDefine(visuals, 'colorAlpha');\n    var colorSaturation = getValueVisualDefine(visuals, 'colorSaturation');\n    if (colorSaturation) {\n      color = (0,tool_color.modifyHSL)(color, null, null, colorSaturation);\n    }\n    if (colorAlpha) {\n      color = (0,tool_color.modifyAlpha)(color, colorAlpha);\n    }\n    return color;\n  }\n}\nfunction calculateBorderColor(borderColorSaturation, thisNodeColor) {\n  return thisNodeColor != null\n  // Can only be string\n  ? (0,tool_color.modifyHSL)(thisNodeColor, null, null, borderColorSaturation) : null;\n}\nfunction getValueVisualDefine(visuals, name) {\n  var value = visuals[name];\n  if (value != null && value !== 'none') {\n    return value;\n  }\n}\nfunction buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {\n  if (!viewChildren || !viewChildren.length) {\n    return;\n  }\n  var rangeVisual = getRangeVisual(nodeModel, 'color') || visuals.color != null && visuals.color !== 'none' && (getRangeVisual(nodeModel, 'colorAlpha') || getRangeVisual(nodeModel, 'colorSaturation'));\n  if (!rangeVisual) {\n    return;\n  }\n  var visualMin = nodeModel.get('visualMin');\n  var visualMax = nodeModel.get('visualMax');\n  var dataExtent = nodeLayout.dataExtent.slice();\n  visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);\n  visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);\n  var colorMappingBy = nodeModel.get('colorMappingBy');\n  var opt = {\n    type: rangeVisual.name,\n    dataExtent: dataExtent,\n    visual: rangeVisual.range\n  };\n  if (opt.type === 'color' && (colorMappingBy === 'index' || colorMappingBy === 'id')) {\n    opt.mappingMethod = 'category';\n    opt.loop = true;\n    // categories is ordinal, so do not set opt.categories.\n  } else {\n    opt.mappingMethod = 'linear';\n  }\n  var mapping = new VisualMapping/* default */.A(opt);\n  treemapVisual_inner(mapping).drColorMappingBy = colorMappingBy;\n  return mapping;\n}\n// Notice: If we don't have the attribute 'colorRange', but only use\n// attribute 'color' to represent both concepts of 'colorRange' and 'color',\n// (It means 'colorRange' when 'color' is Array, means 'color' when not array),\n// this problem will be encountered:\n// If a level-1 node doesn't have children, and its siblings have children,\n// and colorRange is set on level-1, then the node cannot be colored.\n// So we separate 'colorRange' and 'color' to different attributes.\nfunction getRangeVisual(nodeModel, name) {\n  // 'colorRange', 'colorARange', 'colorSRange'.\n  // If not exists on this node, fetch from levels and series.\n  var range = nodeModel.get(name);\n  return (0,util.isArray)(range) && range.length ? {\n    name: name,\n    range: range\n  } : null;\n}\nfunction mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {\n  var childVisuals = (0,util.extend)({}, visuals);\n  if (mapping) {\n    // Only support color, colorAlpha, colorSaturation.\n    var mappingType = mapping.type;\n    var colorMappingBy = mappingType === 'color' && treemapVisual_inner(mapping).drColorMappingBy;\n    var value = colorMappingBy === 'index' ? index : colorMappingBy === 'id' ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get('visualDimension'));\n    childVisuals[mappingType] = mapping.mapValueToVisual(value);\n  }\n  return childVisuals;\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n;// ./node_modules/echarts/lib/chart/treemap/treemapLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/*\r\n* A third-party license is embedded for some of the code in this file:\r\n* The treemap layout implementation was originally copied from\r\n* \"d3.js\" with some modifications made for this project.\r\n* (See more details in the comment of the method \"squarify\" below.)\r\n* The use of the source code of this file is also subject to the terms\r\n* and consitions of the license of \"d3.js\" (BSD-3Clause, see\r\n* </licenses/LICENSE-d3>).\r\n*/\n\n\n\n\n\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar retrieveValue = util.retrieve;\nvar each = util.each;\nvar PATH_BORDER_WIDTH = ['itemStyle', 'borderWidth'];\nvar PATH_GAP_WIDTH = ['itemStyle', 'gapWidth'];\nvar PATH_UPPER_LABEL_SHOW = ['upperLabel', 'show'];\nvar PATH_UPPER_LABEL_HEIGHT = ['upperLabel', 'height'];\n;\n/**\r\n * @public\r\n */\n/* harmony default export */ const treemapLayout = ({\n  seriesType: 'treemap',\n  reset: function (seriesModel, ecModel, api, payload) {\n    // Layout result in each node:\n    // {x, y, width, height, area, borderWidth}\n    var ecWidth = api.getWidth();\n    var ecHeight = api.getHeight();\n    var seriesOption = seriesModel.option;\n    var layoutInfo = layout/* getLayoutRect */.dV(seriesModel.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    var size = seriesOption.size || []; // Compatible with ec2.\n    var containerWidth = (0,number/* parsePercent */.lo)(retrieveValue(layoutInfo.width, size[0]), ecWidth);\n    var containerHeight = (0,number/* parsePercent */.lo)(retrieveValue(layoutInfo.height, size[1]), ecHeight);\n    // Fetch payload info.\n    var payloadType = payload && payload.type;\n    var types = ['treemapZoomToNode', 'treemapRootToNode'];\n    var targetInfo = treeHelper/* retrieveTargetInfo */.mw(payload, types, seriesModel);\n    var rootRect = payloadType === 'treemapRender' || payloadType === 'treemapMove' ? payload.rootRect : null;\n    var viewRoot = seriesModel.getViewRoot();\n    var viewAbovePath = treeHelper/* getPathToRoot */.bl(viewRoot);\n    if (payloadType !== 'treemapMove') {\n      var rootSize = payloadType === 'treemapZoomToNode' ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];\n      var sort_1 = seriesOption.sort;\n      if (sort_1 && sort_1 !== 'asc' && sort_1 !== 'desc') {\n        // Default to be desc order.\n        sort_1 = 'desc';\n      }\n      var options = {\n        squareRatio: seriesOption.squareRatio,\n        sort: sort_1,\n        leafDepth: seriesOption.leafDepth\n      };\n      // layout should be cleared because using updateView but not update.\n      viewRoot.hostTree.clearLayouts();\n      // TODO\n      // optimize: if out of view clip, do not layout.\n      // But take care that if do not render node out of view clip,\n      // how to calculate start po\n      var viewRootLayout_1 = {\n        x: 0,\n        y: 0,\n        width: rootSize[0],\n        height: rootSize[1],\n        area: rootSize[0] * rootSize[1]\n      };\n      viewRoot.setLayout(viewRootLayout_1);\n      squarify(viewRoot, options, false, 0);\n      // Supplement layout.\n      viewRootLayout_1 = viewRoot.getLayout();\n      each(viewAbovePath, function (node, index) {\n        var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();\n        node.setLayout(util.extend({\n          dataExtent: [childValue, childValue],\n          borderWidth: 0,\n          upperHeight: 0\n        }, viewRootLayout_1));\n      });\n    }\n    var treeRoot = seriesModel.getData().tree.root;\n    treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);\n    seriesModel.setLayoutInfo(layoutInfo);\n    // FIXME\n    // 现在没有clip功能，暂时取ec高宽。\n    prunning(treeRoot,\n    // Transform to base element coordinate system.\n    new BoundingRect/* default */.A(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0);\n  }\n});\n/**\r\n * Layout treemap with squarify algorithm.\r\n * The original presentation of this algorithm\r\n * was made by Mark Bruls, Kees Huizing, and Jarke J. van Wijk\r\n * <https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf>.\r\n * The implementation of this algorithm was originally copied from \"d3.js\"\r\n * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/layout/treemap.js>\r\n * with some modifications made for this program.\r\n * See the license statement at the head of this file.\r\n *\r\n * @protected\r\n * @param {module:echarts/data/Tree~TreeNode} node\r\n * @param {Object} options\r\n * @param {string} options.sort 'asc' or 'desc'\r\n * @param {number} options.squareRatio\r\n * @param {boolean} hideChildren\r\n * @param {number} depth\r\n */\nfunction squarify(node, options, hideChildren, depth) {\n  var width;\n  var height;\n  if (node.isRemoved()) {\n    return;\n  }\n  var thisLayout = node.getLayout();\n  width = thisLayout.width;\n  height = thisLayout.height;\n  // Considering border and gap\n  var nodeModel = node.getModel();\n  var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);\n  var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;\n  var upperLabelHeight = getUpperLabelHeight(nodeModel);\n  var upperHeight = Math.max(borderWidth, upperLabelHeight);\n  var layoutOffset = borderWidth - halfGapWidth;\n  var layoutOffsetUpper = upperHeight - halfGapWidth;\n  node.setLayout({\n    borderWidth: borderWidth,\n    upperHeight: upperHeight,\n    upperLabelHeight: upperLabelHeight\n  }, true);\n  width = mathMax(width - 2 * layoutOffset, 0);\n  height = mathMax(height - layoutOffset - layoutOffsetUpper, 0);\n  var totalArea = width * height;\n  var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);\n  if (!viewChildren.length) {\n    return;\n  }\n  var rect = {\n    x: layoutOffset,\n    y: layoutOffsetUpper,\n    width: width,\n    height: height\n  };\n  var rowFixedLength = mathMin(width, height);\n  var best = Infinity; // the best row score so far\n  var row = [];\n  row.area = 0;\n  for (var i = 0, len = viewChildren.length; i < len;) {\n    var child = viewChildren[i];\n    row.push(child);\n    row.area += child.getLayout().area;\n    var score = worst(row, rowFixedLength, options.squareRatio);\n    // continue with this orientation\n    if (score <= best) {\n      i++;\n      best = score;\n    }\n    // abort, and try a different orientation\n    else {\n      row.area -= row.pop().getLayout().area;\n      position(row, rowFixedLength, rect, halfGapWidth, false);\n      rowFixedLength = mathMin(rect.width, rect.height);\n      row.length = row.area = 0;\n      best = Infinity;\n    }\n  }\n  if (row.length) {\n    position(row, rowFixedLength, rect, halfGapWidth, true);\n  }\n  if (!hideChildren) {\n    var childrenVisibleMin = nodeModel.get('childrenVisibleMin');\n    if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {\n      hideChildren = true;\n    }\n  }\n  for (var i = 0, len = viewChildren.length; i < len; i++) {\n    squarify(viewChildren[i], options, hideChildren, depth + 1);\n  }\n}\n/**\r\n * Set area to each child, and calculate data extent for visual coding.\r\n */\nfunction initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {\n  var viewChildren = node.children || [];\n  var orderBy = options.sort;\n  orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null);\n  var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth;\n  // leafDepth has higher priority.\n  if (hideChildren && !overLeafDepth) {\n    return node.viewChildren = [];\n  }\n  // Sort children, order by desc.\n  viewChildren = util.filter(viewChildren, function (child) {\n    return !child.isRemoved();\n  });\n  sort(viewChildren, orderBy);\n  var info = statistic(nodeModel, viewChildren, orderBy);\n  if (info.sum === 0) {\n    return node.viewChildren = [];\n  }\n  info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);\n  if (info.sum === 0) {\n    return node.viewChildren = [];\n  }\n  // Set area to each child.\n  for (var i = 0, len = viewChildren.length; i < len; i++) {\n    var area = viewChildren[i].getValue() / info.sum * totalArea;\n    // Do not use setLayout({...}, true), because it is needed to clear last layout.\n    viewChildren[i].setLayout({\n      area: area\n    });\n  }\n  if (overLeafDepth) {\n    viewChildren.length && node.setLayout({\n      isLeafRoot: true\n    }, true);\n    viewChildren.length = 0;\n  }\n  node.viewChildren = viewChildren;\n  node.setLayout({\n    dataExtent: info.dataExtent\n  }, true);\n  return viewChildren;\n}\n/**\r\n * Consider 'visibleMin'. Modify viewChildren and get new sum.\r\n */\nfunction filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {\n  // visibleMin is not supported yet when no option.sort.\n  if (!orderBy) {\n    return sum;\n  }\n  var visibleMin = nodeModel.get('visibleMin');\n  var len = orderedChildren.length;\n  var deletePoint = len;\n  // Always travel from little value to big value.\n  for (var i = len - 1; i >= 0; i--) {\n    var value = orderedChildren[orderBy === 'asc' ? len - i - 1 : i].getValue();\n    if (value / sum * totalArea < visibleMin) {\n      deletePoint = i;\n      sum -= value;\n    }\n  }\n  orderBy === 'asc' ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);\n  return sum;\n}\n/**\r\n * Sort\r\n */\nfunction sort(viewChildren, orderBy) {\n  if (orderBy) {\n    viewChildren.sort(function (a, b) {\n      var diff = orderBy === 'asc' ? a.getValue() - b.getValue() : b.getValue() - a.getValue();\n      return diff === 0 ? orderBy === 'asc' ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;\n    });\n  }\n  return viewChildren;\n}\n/**\r\n * Statistic\r\n */\nfunction statistic(nodeModel, children, orderBy) {\n  // Calculate sum.\n  var sum = 0;\n  for (var i = 0, len = children.length; i < len; i++) {\n    sum += children[i].getValue();\n  }\n  // Statistic data extent for latter visual coding.\n  // Notice: data extent should be calculate based on raw children\n  // but not filtered view children, otherwise visual mapping will not\n  // be stable when zoom (where children is filtered by visibleMin).\n  var dimension = nodeModel.get('visualDimension');\n  var dataExtent;\n  // The same as area dimension.\n  if (!children || !children.length) {\n    dataExtent = [NaN, NaN];\n  } else if (dimension === 'value' && orderBy) {\n    dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];\n    orderBy === 'asc' && dataExtent.reverse();\n  }\n  // Other dimension.\n  else {\n    dataExtent = [Infinity, -Infinity];\n    each(children, function (child) {\n      var value = child.getValue(dimension);\n      value < dataExtent[0] && (dataExtent[0] = value);\n      value > dataExtent[1] && (dataExtent[1] = value);\n    });\n  }\n  return {\n    sum: sum,\n    dataExtent: dataExtent\n  };\n}\n/**\r\n * Computes the score for the specified row,\r\n * as the worst aspect ratio.\r\n */\nfunction worst(row, rowFixedLength, ratio) {\n  var areaMax = 0;\n  var areaMin = Infinity;\n  for (var i = 0, area = void 0, len = row.length; i < len; i++) {\n    area = row[i].getLayout().area;\n    if (area) {\n      area < areaMin && (areaMin = area);\n      area > areaMax && (areaMax = area);\n    }\n  }\n  var squareArea = row.area * row.area;\n  var f = rowFixedLength * rowFixedLength * ratio;\n  return squareArea ? mathMax(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;\n}\n/**\r\n * Positions the specified row of nodes. Modifies `rect`.\r\n */\nfunction position(row, rowFixedLength, rect, halfGapWidth, flush) {\n  // When rowFixedLength === rect.width,\n  // it is horizontal subdivision,\n  // rowFixedLength is the width of the subdivision,\n  // rowOtherLength is the height of the subdivision,\n  // and nodes will be positioned from left to right.\n  // wh[idx0WhenH] means: when horizontal,\n  //      wh[idx0WhenH] => wh[0] => 'width'.\n  //      xy[idx1WhenH] => xy[1] => 'y'.\n  var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;\n  var idx1WhenH = 1 - idx0WhenH;\n  var xy = ['x', 'y'];\n  var wh = ['width', 'height'];\n  var last = rect[xy[idx0WhenH]];\n  var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;\n  if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {\n    rowOtherLength = rect[wh[idx1WhenH]]; // over+underflow\n  }\n  for (var i = 0, rowLen = row.length; i < rowLen; i++) {\n    var node = row[i];\n    var nodeLayout = {};\n    var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;\n    var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax(rowOtherLength - 2 * halfGapWidth, 0);\n    // We use Math.max/min to avoid negative width/height when considering gap width.\n    var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;\n    var modWH = i === rowLen - 1 || remain < step ? remain : step;\n    var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax(modWH - 2 * halfGapWidth, 0);\n    nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin(halfGapWidth, wh1 / 2);\n    nodeLayout[xy[idx0WhenH]] = last + mathMin(halfGapWidth, wh0 / 2);\n    last += modWH;\n    node.setLayout(nodeLayout, true);\n  }\n  rect[xy[idx1WhenH]] += rowOtherLength;\n  rect[wh[idx1WhenH]] -= rowOtherLength;\n}\n// Return [containerWidth, containerHeight] as default.\nfunction estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {\n  // If targetInfo.node exists, we zoom to the node,\n  // so estimate whole width and height by target node.\n  var currNode = (targetInfo || {}).node;\n  var defaultSize = [containerWidth, containerHeight];\n  if (!currNode || currNode === viewRoot) {\n    return defaultSize;\n  }\n  var parent;\n  var viewArea = containerWidth * containerHeight;\n  var area = viewArea * seriesModel.option.zoomToNodeRatio;\n  while (parent = currNode.parentNode) {\n    // jshint ignore:line\n    var sum = 0;\n    var siblings = parent.children;\n    for (var i = 0, len = siblings.length; i < len; i++) {\n      sum += siblings[i].getValue();\n    }\n    var currNodeValue = currNode.getValue();\n    if (currNodeValue === 0) {\n      return defaultSize;\n    }\n    area *= sum / currNodeValue;\n    // Considering border, suppose aspect ratio is 1.\n    var parentModel = parent.getModel();\n    var borderWidth = parentModel.get(PATH_BORDER_WIDTH);\n    var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel));\n    area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);\n    area > number/* MAX_SAFE_INTEGER */.Is && (area = number/* MAX_SAFE_INTEGER */.Is);\n    currNode = parent;\n  }\n  area < viewArea && (area = viewArea);\n  var scale = Math.pow(area / viewArea, 0.5);\n  return [containerWidth * scale, containerHeight * scale];\n}\n// Root position based on coord of containerGroup\nfunction calculateRootPosition(layoutInfo, rootRect, targetInfo) {\n  if (rootRect) {\n    return {\n      x: rootRect.x,\n      y: rootRect.y\n    };\n  }\n  var defaultPosition = {\n    x: 0,\n    y: 0\n  };\n  if (!targetInfo) {\n    return defaultPosition;\n  }\n  // If targetInfo is fetched by 'retrieveTargetInfo',\n  // old tree and new tree are the same tree,\n  // so the node still exists and we can visit it.\n  var targetNode = targetInfo.node;\n  var layout = targetNode.getLayout();\n  if (!layout) {\n    return defaultPosition;\n  }\n  // Transform coord from local to container.\n  var targetCenter = [layout.width / 2, layout.height / 2];\n  var node = targetNode;\n  while (node) {\n    var nodeLayout = node.getLayout();\n    targetCenter[0] += nodeLayout.x;\n    targetCenter[1] += nodeLayout.y;\n    node = node.parentNode;\n  }\n  return {\n    x: layoutInfo.width / 2 - targetCenter[0],\n    y: layoutInfo.height / 2 - targetCenter[1]\n  };\n}\n// Mark nodes visible for prunning when visual coding and rendering.\n// Prunning depends on layout and root position, so we have to do it after layout.\nfunction prunning(node, clipRect, viewAbovePath, viewRoot, depth) {\n  var nodeLayout = node.getLayout();\n  var nodeInViewAbovePath = viewAbovePath[depth];\n  var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;\n  if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {\n    return;\n  }\n  node.setLayout({\n    // isInView means: viewRoot sub tree + viewAbovePath\n    isInView: true,\n    // invisible only means: outside view clip so that the node can not\n    // see but still layout for animation preparation but not render.\n    invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),\n    isAboveViewRoot: isAboveViewRoot\n  }, true);\n  // Transform to child coordinate.\n  var childClipRect = new BoundingRect/* default */.A(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);\n  each(node.viewChildren || [], function (child) {\n    prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);\n  });\n}\nfunction getUpperLabelHeight(model) {\n  return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;\n}\n;// ./node_modules/echarts/lib/chart/treemap/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nfunction install(registers) {\n  registers.registerSeriesModel(TreemapSeries);\n  registers.registerChartView(treemap_TreemapView);\n  registers.registerVisual(treemapVisual);\n  registers.registerLayout(treemapLayout);\n  installTreemapAction(registers);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk5MTcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbjNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvdHJlZW1hcC90cmVlbWFwQWN0aW9uLmpzPzY4YjAiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3RyZWVtYXAvVHJlZW1hcFNlcmllcy5qcz9hN2RmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC90cmVlbWFwL0JyZWFkY3J1bWIuanM/YjFmNyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvdHJlZW1hcC9UcmVlbWFwVmlldy5qcz83NmJiIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC90cmVlbWFwL3RyZWVtYXBWaXN1YWwuanM/NmQ4NCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvdHJlZW1hcC90cmVlbWFwTGF5b3V0LmpzPzA4MWMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3RyZWVtYXAvaW5zdGFsbC5qcz8zYjI2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uL2hlbHBlci90cmVlSGVscGVyLmpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xudmFyIGFjdGlvblR5cGVzID0gWyd0cmVlbWFwWm9vbVRvTm9kZScsICd0cmVlbWFwUmVuZGVyJywgJ3RyZWVtYXBNb3ZlJ107XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbFRyZWVtYXBBY3Rpb24ocmVnaXN0ZXJzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aW9uVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgICAgdHlwZTogYWN0aW9uVHlwZXNbaV0sXG4gICAgICB1cGRhdGU6ICd1cGRhdGVWaWV3J1xuICAgIH0sIG5vb3ApO1xuICB9XG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogJ3RyZWVtYXBSb290VG9Ob2RlJyxcbiAgICB1cGRhdGU6ICd1cGRhdGVWaWV3J1xuICB9LCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICBtYWluVHlwZTogJ3NlcmllcycsXG4gICAgICBzdWJUeXBlOiAndHJlZW1hcCcsXG4gICAgICBxdWVyeTogcGF5bG9hZFxuICAgIH0sIGhhbmRsZVJvb3RUb05vZGUpO1xuICAgIGZ1bmN0aW9uIGhhbmRsZVJvb3RUb05vZGUobW9kZWwsIGluZGV4KSB7XG4gICAgICB2YXIgdHlwZXMgPSBbJ3RyZWVtYXBab29tVG9Ob2RlJywgJ3RyZWVtYXBSb290VG9Ob2RlJ107XG4gICAgICB2YXIgdGFyZ2V0SW5mbyA9IGhlbHBlci5yZXRyaWV2ZVRhcmdldEluZm8ocGF5bG9hZCwgdHlwZXMsIG1vZGVsKTtcbiAgICAgIGlmICh0YXJnZXRJbmZvKSB7XG4gICAgICAgIHZhciBvcmlnaW5WaWV3Um9vdCA9IG1vZGVsLmdldFZpZXdSb290KCk7XG4gICAgICAgIGlmIChvcmlnaW5WaWV3Um9vdCkge1xuICAgICAgICAgIHBheWxvYWQuZGlyZWN0aW9uID0gaGVscGVyLmFib3ZlVmlld1Jvb3Qob3JpZ2luVmlld1Jvb3QsIHRhcmdldEluZm8ubm9kZSkgPyAncm9sbFVwJyA6ICdkcmlsbERvd24nO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLnJlc2V0Vmlld1Jvb3QodGFyZ2V0SW5mby5ub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMuanMnO1xuaW1wb3J0IFRyZWUgZnJvbSAnLi4vLi4vZGF0YS9UcmVlLmpzJztcbmltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Nb2RlbC5qcyc7XG5pbXBvcnQgeyB3cmFwVHJlZVBhdGhJbmZvIH0gZnJvbSAnLi4vaGVscGVyL3RyZWVIZWxwZXIuanMnO1xuaW1wb3J0IHsgbm9ybWFsaXplVG9BcnJheSB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xuaW1wb3J0IHsgY3JlYXRlVG9vbHRpcE1hcmt1cCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudC90b29sdGlwL3Rvb2x0aXBNYXJrdXAuanMnO1xuaW1wb3J0IGVuYWJsZUFyaWFEZWNhbEZvclRyZWUgZnJvbSAnLi4vaGVscGVyL2VuYWJsZUFyaWFEZWNhbEZvclRyZWUuanMnO1xudmFyIFRyZWVtYXBTZXJpZXNNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUcmVlbWFwU2VyaWVzTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFRyZWVtYXBTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gVHJlZW1hcFNlcmllc01vZGVsLnR5cGU7XG4gICAgX3RoaXMucHJldmVudFVzaW5nSG92ZXJMYXllciA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBUcmVlbWFwU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIC8vIENyZWF0ZSBhIHZpcnR1YWwgcm9vdC5cbiAgICB2YXIgcm9vdCA9IHtcbiAgICAgIG5hbWU6IG9wdGlvbi5uYW1lLFxuICAgICAgY2hpbGRyZW46IG9wdGlvbi5kYXRhXG4gICAgfTtcbiAgICBjb21wbGV0ZVRyZWVWYWx1ZShyb290KTtcbiAgICB2YXIgbGV2ZWxzID0gb3B0aW9uLmxldmVscyB8fCBbXTtcbiAgICAvLyBVc2VkIGluIFwidmlzdWFsIHByaW9yaXR5XCIgaW4gYHRyZWVtYXBWaXN1YWwuanNgLlxuICAgIC8vIFRoaXMgd2F5IGlzIGEgbGl0dGxlIHRyaWNreSwgbXVzdCBzYXRpc2Z5IHRoZSBwcmVjb25kaXRpb246XG4gICAgLy8gICAxLiBUaGVyZSBpcyBubyBgdHJlZU5vZGUuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS54eHgnKWAgdXNlZC5cbiAgICAvLyAgIDIuIFRoZSBgTW9kZWwucHJvdG90eXBlLmdldE1vZGVsKClgIHdpbGwgbm90IHVzZSBhbnkgY2xvbmUtbGlrZSB3YXkuXG4gICAgdmFyIGRlc2lnbmF0ZWRWaXN1YWxJdGVtU3R5bGUgPSB0aGlzLmRlc2lnbmF0ZWRWaXN1YWxJdGVtU3R5bGUgPSB7fTtcbiAgICB2YXIgZGVzaWduYXRlZFZpc3VhbE1vZGVsID0gbmV3IE1vZGVsKHtcbiAgICAgIGl0ZW1TdHlsZTogZGVzaWduYXRlZFZpc3VhbEl0ZW1TdHlsZVxuICAgIH0sIHRoaXMsIGVjTW9kZWwpO1xuICAgIGxldmVscyA9IG9wdGlvbi5sZXZlbHMgPSBzZXREZWZhdWx0KGxldmVscywgZWNNb2RlbCk7XG4gICAgdmFyIGxldmVsTW9kZWxzID0genJVdGlsLm1hcChsZXZlbHMgfHwgW10sIGZ1bmN0aW9uIChsZXZlbERlZmluZSkge1xuICAgICAgcmV0dXJuIG5ldyBNb2RlbChsZXZlbERlZmluZSwgZGVzaWduYXRlZFZpc3VhbE1vZGVsLCBlY01vZGVsKTtcbiAgICB9LCB0aGlzKTtcbiAgICAvLyBNYWtlIHN1cmUgYWx3YXlzIGEgbmV3IHRyZWUgaXMgY3JlYXRlZCB3aGVuIHNldE9wdGlvbixcbiAgICAvLyBpbiBUcmVlbWFwVmlldywgd2UgY2hlY2sgd2hldGhlciBvbGRUcmVlID09PSBuZXdUcmVlXG4gICAgLy8gdG8gY2hvb3NlIG1hcHBpbmdzIGFwcHJvYWNoIGFtb25nIG9sZCBzaGFwZXMgYW5kIG5ldyBzaGFwZXMuXG4gICAgdmFyIHRyZWUgPSBUcmVlLmNyZWF0ZVRyZWUocm9vdCwgdGhpcywgYmVmb3JlTGluayk7XG4gICAgZnVuY3Rpb24gYmVmb3JlTGluayhub2RlRGF0YSkge1xuICAgICAgbm9kZURhdGEud3JhcE1ldGhvZCgnZ2V0SXRlbU1vZGVsJywgZnVuY3Rpb24gKG1vZGVsLCBpZHgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0cmVlLmdldE5vZGVCeURhdGFJbmRleChpZHgpO1xuICAgICAgICB2YXIgbGV2ZWxNb2RlbCA9IG5vZGUgPyBsZXZlbE1vZGVsc1tub2RlLmRlcHRoXSA6IG51bGw7XG4gICAgICAgIC8vIElmIG5vIGxldmVsTW9kZWwsIHdlIGFsc28gbmVlZCBgZGVzaWduYXRlZFZpc3VhbE1vZGVsYC5cbiAgICAgICAgbW9kZWwucGFyZW50TW9kZWwgPSBsZXZlbE1vZGVsIHx8IGRlc2lnbmF0ZWRWaXN1YWxNb2RlbDtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0cmVlLmRhdGE7XG4gIH07XG4gIFRyZWVtYXBTZXJpZXNNb2RlbC5wcm90b3R5cGUub3B0aW9uVXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2V0Vmlld1Jvb3QoKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211dGlwbGVTZXJpZXM9ZmFsc2VdXHJcbiAgICovXG4gIFRyZWVtYXBTZXJpZXNNb2RlbC5wcm90b3R5cGUuZm9ybWF0VG9vbHRpcCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIG11bHRpcGxlU2VyaWVzLCBkYXRhVHlwZSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXRSYXdWYWx1ZShkYXRhSW5kZXgpO1xuICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG4gICAgcmV0dXJuIGNyZWF0ZVRvb2x0aXBNYXJrdXAoJ25hbWVWYWx1ZScsIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQWRkIHRyZWUgcGF0aCB0byB0b29sdGlwIHBhcmFtXHJcbiAgICpcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xuICBUcmVlbWFwU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldERhdGFQYXJhbXMgPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgdmFyIHBhcmFtcyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0RGF0YVBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBub2RlID0gdGhpcy5nZXREYXRhKCkudHJlZS5nZXROb2RlQnlEYXRhSW5kZXgoZGF0YUluZGV4KTtcbiAgICBwYXJhbXMudHJlZUFuY2VzdG9ycyA9IHdyYXBUcmVlUGF0aEluZm8obm9kZSwgdGhpcyk7XG4gICAgLy8gY29tcGF0aXRhYmxlIHRoZSBwcmV2aW91cyBjb2RlLlxuICAgIHBhcmFtcy50cmVlUGF0aEluZm8gPSBwYXJhbXMudHJlZUFuY2VzdG9ycztcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9O1xuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGxheW91dEluZm8ge1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjb250YWluZXJHcm91cCB4XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNvbnRhaW5lckdyb3VwIHlcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbnRhaW5lckdyb3VwIHdpZHRoXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY29udGFpbmVyR3JvdXAgaGVpZ2h0XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAqL1xuICBUcmVlbWFwU2VyaWVzTW9kZWwucHJvdG90eXBlLnNldExheW91dEluZm8gPSBmdW5jdGlvbiAobGF5b3V0SW5mbykge1xuICAgIC8qKlxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXG4gICAgdGhpcy5sYXlvdXRJbmZvID0gdGhpcy5sYXlvdXRJbmZvIHx8IHt9O1xuICAgIHpyVXRpbC5leHRlbmQodGhpcy5sYXlvdXRJbmZvLCBsYXlvdXRJbmZvKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZFxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gaW5kZXhcclxuICAgKi9cbiAgVHJlZW1hcFNlcmllc01vZGVsLnByb3RvdHlwZS5tYXBJZFRvSW5kZXggPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAvLyBBIGZlYXR1cmUgaXMgaW1wbGVtZW50ZWQ6XG4gICAgLy8gaW5kZXggaXMgbW9ub3RvbmUgaW5jcmVhc2luZyB3aXRoIHRoZSBzZXF1ZW5jZSBvZlxuICAgIC8vIGlucHV0IGlkIGF0IHRoZSBmaXJzdCB0aW1lLlxuICAgIC8vIFRoaXMgZmVhdHVyZSBjYW4gbWFrZSBzdXJlIHRoYXQgZWFjaCBkYXRhIGl0ZW0gYW5kIGl0c1xuICAgIC8vIG1hcHBlZCBjb2xvciBoYXZlIHRoZSBzYW1lIGluZGV4IGJldHdlZW4gZGF0YSBsaXN0IGFuZFxuICAgIC8vIGNvbG9yIGxpc3QgYXQgdGhlIGJlZ2lubmluZywgd2hpY2ggaXMgdXNlZnVsIGZvciB1c2VyXG4gICAgLy8gdG8gYWRqdXN0IGRhdGEtY29sb3IgbWFwcGluZy5cbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXG4gICAgdmFyIGlkSW5kZXhNYXAgPSB0aGlzLl9pZEluZGV4TWFwO1xuICAgIGlmICghaWRJbmRleE1hcCkge1xuICAgICAgaWRJbmRleE1hcCA9IHRoaXMuX2lkSW5kZXhNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICAgICAgLyoqXHJcbiAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAqL1xuICAgICAgdGhpcy5faWRJbmRleE1hcENvdW50ID0gMDtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gaWRJbmRleE1hcC5nZXQoaWQpO1xuICAgIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgICBpZEluZGV4TWFwLnNldChpZCwgaW5kZXggPSB0aGlzLl9pZEluZGV4TWFwQ291bnQrKyk7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcbiAgVHJlZW1hcFNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRWaWV3Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld1Jvb3Q7XG4gIH07XG4gIFRyZWVtYXBTZXJpZXNNb2RlbC5wcm90b3R5cGUucmVzZXRWaWV3Um9vdCA9IGZ1bmN0aW9uICh2aWV3Um9vdCkge1xuICAgIHZpZXdSb290ID8gdGhpcy5fdmlld1Jvb3QgPSB2aWV3Um9vdCA6IHZpZXdSb290ID0gdGhpcy5fdmlld1Jvb3Q7XG4gICAgdmFyIHJvb3QgPSB0aGlzLmdldFJhd0RhdGEoKS50cmVlLnJvb3Q7XG4gICAgaWYgKCF2aWV3Um9vdCB8fCB2aWV3Um9vdCAhPT0gcm9vdCAmJiAhcm9vdC5jb250YWlucyh2aWV3Um9vdCkpIHtcbiAgICAgIHRoaXMuX3ZpZXdSb290ID0gcm9vdDtcbiAgICB9XG4gIH07XG4gIFRyZWVtYXBTZXJpZXNNb2RlbC5wcm90b3R5cGUuZW5hYmxlQXJpYURlY2FsID0gZnVuY3Rpb24gKCkge1xuICAgIGVuYWJsZUFyaWFEZWNhbEZvclRyZWUodGhpcyk7XG4gIH07XG4gIFRyZWVtYXBTZXJpZXNNb2RlbC50eXBlID0gJ3Nlcmllcy50cmVlbWFwJztcbiAgVHJlZW1hcFNlcmllc01vZGVsLmxheW91dE1vZGUgPSAnYm94JztcbiAgVHJlZW1hcFNlcmllc01vZGVsLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgLy8gRGlzYWJsZSBwcm9ncmVzc2l2ZSByZW5kZXJpbmdcbiAgICBwcm9ncmVzc2l2ZTogMCxcbiAgICAvLyBzaXplOiBbJzgwJScsICc4MCUnXSwgICAgICAgICAgICAvLyBkZXByZWNhdGVkLCBjb21wYXRpYmxlIHdpdGggZWMyLlxuICAgIGxlZnQ6ICdjZW50ZXInLFxuICAgIHRvcDogJ21pZGRsZScsXG4gICAgd2lkdGg6ICc4MCUnLFxuICAgIGhlaWdodDogJzgwJScsXG4gICAgc29ydDogdHJ1ZSxcbiAgICBjbGlwV2luZG93OiAnb3JpZ2luJyxcbiAgICBzcXVhcmVSYXRpbzogMC41ICogKDEgKyBNYXRoLnNxcnQoNSkpLFxuICAgIGxlYWZEZXB0aDogbnVsbCxcbiAgICBkcmlsbERvd25JY29uOiAn4pa2JyxcbiAgICAvLyB0byBhbGlnbiBzcGVjaWFsaXplZCBpY29uLiDilrfilrbinZLinZDilrzinJpcbiAgICB6b29tVG9Ob2RlUmF0aW86IDAuMzIgKiAwLjMyLFxuICAgIHNjYWxlTGltaXQ6IG51bGwsXG4gICAgcm9hbTogdHJ1ZSxcbiAgICBub2RlQ2xpY2s6ICd6b29tVG9Ob2RlJyxcbiAgICBhbmltYXRpb246IHRydWUsXG4gICAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDkwMCxcbiAgICBhbmltYXRpb25FYXNpbmc6ICdxdWludGljSW5PdXQnLFxuICAgIGJyZWFkY3J1bWI6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBoZWlnaHQ6IDIyLFxuICAgICAgbGVmdDogJ2NlbnRlcicsXG4gICAgICB0b3A6ICdib3R0b20nLFxuICAgICAgLy8gcmlnaHRcbiAgICAgIC8vIGJvdHRvbVxuICAgICAgZW1wdHlJdGVtV2lkdGg6IDI1LFxuICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgIGNvbG9yOiAncmdiYSgwLDAsMCwwLjcpJyxcbiAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6ICcjZmZmJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6ICdyZ2JhKDAsMCwwLDAuOSknIC8vICcjNTc5M2YzJyxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICAvLyBEbyBub3QgdXNlIHRleHREaXN0YW5jZSwgZm9yIGVsbGlwc2lzIHJlY3QganVzdCB0aGUgc2FtZSBhcyB0cmVlbWFwIG5vZGUgcmVjdC5cbiAgICAgIGRpc3RhbmNlOiAwLFxuICAgICAgcGFkZGluZzogNSxcbiAgICAgIHBvc2l0aW9uOiAnaW5zaWRlJyxcbiAgICAgIC8vIGZvcm1hdHRlcjogbnVsbCxcbiAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICBvdmVyZmxvdzogJ3RydW5jYXRlJ1xuICAgICAgLy8gYWxpZ25cbiAgICAgIC8vIHZlcnRpY2FsQWxpZ25cbiAgICB9LFxuICAgIHVwcGVyTGFiZWw6IHtcbiAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgcG9zaXRpb246IFswLCAnNTAlJ10sXG4gICAgICBoZWlnaHQ6IDIwLFxuICAgICAgLy8gZm9ybWF0dGVyOiBudWxsLFxuICAgICAgLy8gY29sb3I6ICcjZmZmJyxcbiAgICAgIG92ZXJmbG93OiAndHJ1bmNhdGUnLFxuICAgICAgLy8gYWxpZ246IG51bGwsXG4gICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJ1xuICAgIH0sXG4gICAgaXRlbVN0eWxlOiB7XG4gICAgICBjb2xvcjogbnVsbCxcbiAgICAgIGNvbG9yQWxwaGE6IG51bGwsXG4gICAgICBjb2xvclNhdHVyYXRpb246IG51bGwsXG4gICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgIGdhcFdpZHRoOiAwLFxuICAgICAgYm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgICAgIGJvcmRlckNvbG9yU2F0dXJhdGlvbjogbnVsbCAvLyBJZiBzcGVjaWZpZWQsIGJvcmRlckNvbG9yIHdpbGwgYmUgaW5lZmZlY3RpdmUsIGFuZCB0aGVcbiAgICAgIC8vIGJvcmRlciBjb2xvciBpcyBldmFsdWF0ZWQgYnkgY29sb3Igb2YgY3VycmVudCBub2RlIGFuZFxuICAgICAgLy8gYm9yZGVyQ29sb3JTYXR1cmF0aW9uLlxuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIHVwcGVyTGFiZWw6IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246IFswLCAnNTAlJ10sXG4gICAgICAgIG92ZXJmbG93OiAndHJ1bmNhdGUnLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJ1xuICAgICAgfVxuICAgIH0sXG4gICAgdmlzdWFsRGltZW5zaW9uOiAwLFxuICAgIHZpc3VhbE1pbjogbnVsbCxcbiAgICB2aXN1YWxNYXg6IG51bGwsXG4gICAgY29sb3I6IFtdLFxuICAgIC8vIGxldmVsW25dLmNvbG9yIChpZiBuZWNlc3NhcnkpLlxuICAgIC8vICsgU3BlY2lmeSBjb2xvciBsaXN0IG9mIGVhY2ggbGV2ZWwuIGxldmVsWzBdLmNvbG9yIHdvdWxkIGJlIGdsb2JhbFxuICAgIC8vIGNvbG9yIGxpc3QgaWYgbm90IHNwZWNpZmllZC4gKHNlZSBtZXRob2QgYHNldERlZmF1bHRgKS5cbiAgICAvLyArIEJ1dCBzZXQgYXMgYSBlbXB0eSBhcnJheSB0byBmb3JiaWQgZmV0Y2ggY29sb3IgZnJvbSBnbG9iYWwgcGFsZXR0ZVxuICAgIC8vIHdoZW4gdXNpbmcgbm9kZU1vZGVsLmdldCgnY29sb3InKSwgb3RoZXJ3aXNlIG5vZGVzIG9uIGRlZXAgbGV2ZWxcbiAgICAvLyB3aWxsIGFsd2F5cyBoYXMgY29sb3IgcGFsZXR0ZSBzZXQgYW5kIGFyZSBub3QgYWJsZSB0byBpbmhlcml0IGNvbG9yXG4gICAgLy8gZnJvbSBwYXJlbnQgbm9kZS5cbiAgICAvLyArIFRyZWVtYXBTZXJpZXMuY29sb3IgY2FuIG5vdCBiZSBzZXQgYXMgJ25vbmUnLCBvdGhlcndpc2UgZWZmZWN0XG4gICAgLy8gbGVnZW5kIGNvbG9yIGZldGNoaW5nIChzZWUgc2VyaWVzQ29sb3IuanMpLlxuICAgIGNvbG9yQWxwaGE6IG51bGwsXG4gICAgY29sb3JTYXR1cmF0aW9uOiBudWxsLFxuICAgIGNvbG9yTWFwcGluZ0J5OiAnaW5kZXgnLFxuICAgIHZpc2libGVNaW46IDEwLFxuICAgIC8vIGJlIHJlbmRlcmVkLiBPbmx5IHdvcmtzIHdoZW4gc29ydCBpcyAnYXNjJyBvciAnZGVzYycuXG4gICAgY2hpbGRyZW5WaXNpYmxlTWluOiBudWxsLFxuICAgIC8vIGdyYW5kY2hpbGRyZW4gd2lsbCBub3Qgc2hvdy5cbiAgICAvLyBXaHkgZ3JhbmRjaGlsZHJlbj8gSWYgbm90IGdyYW5kY2hpbGRyZW4gYnV0IGNoaWxkcmVuLFxuICAgIC8vIHNvbWUgc2libGluZ3Mgc2hvdyBjaGlsZHJlbiBhbmQgc29tZSBub3QsXG4gICAgLy8gdGhlIGFwcGVhcmFuY2UgbWF5IGJlIG1lc3MgYW5kIG5vdCBjb25zaXN0ZW50LFxuICAgIGxldmVsczogW10gLy8gRWFjaCBpdGVtOiB7XG4gICAgLy8gICAgIHZpc2libGVNaW4sIGl0ZW1TdHlsZSwgdmlzdWFsRGltZW5zaW9uLCBsYWJlbFxuICAgIC8vIH1cbiAgfTtcbiAgcmV0dXJuIFRyZWVtYXBTZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuLyoqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhTm9kZVxyXG4gKi9cbmZ1bmN0aW9uIGNvbXBsZXRlVHJlZVZhbHVlKGRhdGFOb2RlKSB7XG4gIC8vIFBvc3RvcmRlciB0cmF2ZWwgdHJlZS5cbiAgLy8gSWYgdmFsdWUgb2Ygbm9uZS1sZWFmIG5vZGUgaXMgbm90IHNldCxcbiAgLy8gY2FsY3VsYXRlIGl0IGJ5IHN1bWluZyB1cCB0aGUgdmFsdWUgb2YgYWxsIGNoaWxkcmVuLlxuICB2YXIgc3VtID0gMDtcbiAgenJVdGlsLmVhY2goZGF0YU5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGNvbXBsZXRlVHJlZVZhbHVlKGNoaWxkKTtcbiAgICB2YXIgY2hpbGRWYWx1ZSA9IGNoaWxkLnZhbHVlO1xuICAgIHpyVXRpbC5pc0FycmF5KGNoaWxkVmFsdWUpICYmIChjaGlsZFZhbHVlID0gY2hpbGRWYWx1ZVswXSk7XG4gICAgc3VtICs9IGNoaWxkVmFsdWU7XG4gIH0pO1xuICB2YXIgdGhpc1ZhbHVlID0gZGF0YU5vZGUudmFsdWU7XG4gIGlmICh6clV0aWwuaXNBcnJheSh0aGlzVmFsdWUpKSB7XG4gICAgdGhpc1ZhbHVlID0gdGhpc1ZhbHVlWzBdO1xuICB9XG4gIGlmICh0aGlzVmFsdWUgPT0gbnVsbCB8fCBpc05hTih0aGlzVmFsdWUpKSB7XG4gICAgdGhpc1ZhbHVlID0gc3VtO1xuICB9XG4gIC8vIFZhbHVlIHNob3VsZCBub3QgbGVzcyB0aGFuIDAuXG4gIGlmICh0aGlzVmFsdWUgPCAwKSB7XG4gICAgdGhpc1ZhbHVlID0gMDtcbiAgfVxuICB6clV0aWwuaXNBcnJheShkYXRhTm9kZS52YWx1ZSkgPyBkYXRhTm9kZS52YWx1ZVswXSA9IHRoaXNWYWx1ZSA6IGRhdGFOb2RlLnZhbHVlID0gdGhpc1ZhbHVlO1xufVxuLyoqXHJcbiAqIHNldCBkZWZhdWx0IHRvIGxldmVsIGNvbmZpZ3VyYXRpb25cclxuICovXG5mdW5jdGlvbiBzZXREZWZhdWx0KGxldmVscywgZWNNb2RlbCkge1xuICB2YXIgZ2xvYmFsQ29sb3JMaXN0ID0gbm9ybWFsaXplVG9BcnJheShlY01vZGVsLmdldCgnY29sb3InKSk7XG4gIHZhciBnbG9iYWxEZWNhbExpc3QgPSBub3JtYWxpemVUb0FycmF5KGVjTW9kZWwuZ2V0KFsnYXJpYScsICdkZWNhbCcsICdkZWNhbHMnXSkpO1xuICBpZiAoIWdsb2JhbENvbG9yTGlzdCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXZlbHMgPSBsZXZlbHMgfHwgW107XG4gIHZhciBoYXNDb2xvckRlZmluZTtcbiAgdmFyIGhhc0RlY2FsRGVmaW5lO1xuICB6clV0aWwuZWFjaChsZXZlbHMsIGZ1bmN0aW9uIChsZXZlbERlZmluZSkge1xuICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbChsZXZlbERlZmluZSk7XG4gICAgdmFyIG1vZGVsQ29sb3IgPSBtb2RlbC5nZXQoJ2NvbG9yJyk7XG4gICAgdmFyIG1vZGVsRGVjYWwgPSBtb2RlbC5nZXQoJ2RlY2FsJyk7XG4gICAgaWYgKG1vZGVsLmdldChbJ2l0ZW1TdHlsZScsICdjb2xvciddKSB8fCBtb2RlbENvbG9yICYmIG1vZGVsQ29sb3IgIT09ICdub25lJykge1xuICAgICAgaGFzQ29sb3JEZWZpbmUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobW9kZWwuZ2V0KFsnaXRlbVN0eWxlJywgJ2RlY2FsJ10pIHx8IG1vZGVsRGVjYWwgJiYgbW9kZWxEZWNhbCAhPT0gJ25vbmUnKSB7XG4gICAgICBoYXNEZWNhbERlZmluZSA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgdmFyIGxldmVsMCA9IGxldmVsc1swXSB8fCAobGV2ZWxzWzBdID0ge30pO1xuICBpZiAoIWhhc0NvbG9yRGVmaW5lKSB7XG4gICAgbGV2ZWwwLmNvbG9yID0gZ2xvYmFsQ29sb3JMaXN0LnNsaWNlKCk7XG4gIH1cbiAgaWYgKCFoYXNEZWNhbERlZmluZSAmJiBnbG9iYWxEZWNhbExpc3QpIHtcbiAgICBsZXZlbDAuZGVjYWwgPSBnbG9iYWxEZWNhbExpc3Quc2xpY2UoKTtcbiAgfVxuICByZXR1cm4gbGV2ZWxzO1xufVxuZXhwb3J0IGRlZmF1bHQgVHJlZW1hcFNlcmllc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlLmpzJztcbmltcG9ydCAqIGFzIGxheW91dCBmcm9tICcuLi8uLi91dGlsL2xheW91dC5qcyc7XG5pbXBvcnQgeyB3cmFwVHJlZVBhdGhJbmZvIH0gZnJvbSAnLi4vaGVscGVyL3RyZWVIZWxwZXIuanMnO1xuaW1wb3J0IHsgY3VycnksIGRlZmF1bHRzIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGNvbnZlcnRPcHRpb25JZE5hbWUgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCB7IHRvZ2dsZUhvdmVyRW1waGFzaXMsIFoyX0VNUEhBU0lTX0xJRlQgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVUZXh0U3R5bGUgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlLmpzJztcbnZhciBURVhUX1BBRERJTkcgPSA4O1xudmFyIElURU1fR0FQID0gODtcbnZhciBBUlJBWV9MRU5HVEggPSA1O1xudmFyIEJyZWFkY3J1bWIgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCcmVhZGNydW1iKGNvbnRhaW5lckdyb3VwKSB7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgY29udGFpbmVyR3JvdXAuYWRkKHRoaXMuZ3JvdXApO1xuICB9XG4gIEJyZWFkY3J1bWIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgYXBpLCB0YXJnZXROb2RlLCBvblNlbGVjdCkge1xuICAgIHZhciBtb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdicmVhZGNydW1iJyk7XG4gICAgdmFyIHRoaXNHcm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgdGhpc0dyb3VwLnJlbW92ZUFsbCgpO1xuICAgIGlmICghbW9kZWwuZ2V0KCdzaG93JykgfHwgIXRhcmdldE5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbFN0eWxlTW9kZWwgPSBtb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJyk7XG4gICAgdmFyIGVtcGhhc2lzTW9kZWwgPSBtb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKTtcbiAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBub3JtYWxTdHlsZU1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICB2YXIgZW1waGFzaXNUZXh0U3R5bGVNb2RlbCA9IGVtcGhhc2lzTW9kZWwuZ2V0TW9kZWwoWydpdGVtU3R5bGUnLCAndGV4dFN0eWxlJ10pO1xuICAgIHZhciBsYXlvdXRQYXJhbSA9IHtcbiAgICAgIHBvczoge1xuICAgICAgICBsZWZ0OiBtb2RlbC5nZXQoJ2xlZnQnKSxcbiAgICAgICAgcmlnaHQ6IG1vZGVsLmdldCgncmlnaHQnKSxcbiAgICAgICAgdG9wOiBtb2RlbC5nZXQoJ3RvcCcpLFxuICAgICAgICBib3R0b206IG1vZGVsLmdldCgnYm90dG9tJylcbiAgICAgIH0sXG4gICAgICBib3g6IHtcbiAgICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgICAgfSxcbiAgICAgIGVtcHR5SXRlbVdpZHRoOiBtb2RlbC5nZXQoJ2VtcHR5SXRlbVdpZHRoJyksXG4gICAgICB0b3RhbFdpZHRoOiAwLFxuICAgICAgcmVuZGVyTGlzdDogW11cbiAgICB9O1xuICAgIHRoaXMuX3ByZXBhcmUodGFyZ2V0Tm9kZSwgbGF5b3V0UGFyYW0sIHRleHRTdHlsZU1vZGVsKTtcbiAgICB0aGlzLl9yZW5kZXJDb250ZW50KHNlcmllc01vZGVsLCBsYXlvdXRQYXJhbSwgbm9ybWFsU3R5bGVNb2RlbCwgZW1waGFzaXNNb2RlbCwgdGV4dFN0eWxlTW9kZWwsIGVtcGhhc2lzVGV4dFN0eWxlTW9kZWwsIG9uU2VsZWN0KTtcbiAgICBsYXlvdXQucG9zaXRpb25FbGVtZW50KHRoaXNHcm91cCwgbGF5b3V0UGFyYW0ucG9zLCBsYXlvdXRQYXJhbS5ib3gpO1xuICB9O1xuICAvKipcclxuICAgKiBQcmVwYXJlIHJlbmRlciBsaXN0IGFuZCB0b3RhbCB3aWR0aFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIEJyZWFkY3J1bWIucHJvdG90eXBlLl9wcmVwYXJlID0gZnVuY3Rpb24gKHRhcmdldE5vZGUsIGxheW91dFBhcmFtLCB0ZXh0U3R5bGVNb2RlbCkge1xuICAgIGZvciAodmFyIG5vZGUgPSB0YXJnZXROb2RlOyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICB2YXIgdGV4dCA9IGNvbnZlcnRPcHRpb25JZE5hbWUobm9kZS5nZXRNb2RlbCgpLmdldCgnbmFtZScpLCAnJyk7XG4gICAgICB2YXIgdGV4dFJlY3QgPSB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0UmVjdCh0ZXh0KTtcbiAgICAgIHZhciBpdGVtV2lkdGggPSBNYXRoLm1heCh0ZXh0UmVjdC53aWR0aCArIFRFWFRfUEFERElORyAqIDIsIGxheW91dFBhcmFtLmVtcHR5SXRlbVdpZHRoKTtcbiAgICAgIGxheW91dFBhcmFtLnRvdGFsV2lkdGggKz0gaXRlbVdpZHRoICsgSVRFTV9HQVA7XG4gICAgICBsYXlvdXRQYXJhbS5yZW5kZXJMaXN0LnB1c2goe1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICB3aWR0aDogaXRlbVdpZHRoXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIEJyZWFkY3J1bWIucHJvdG90eXBlLl9yZW5kZXJDb250ZW50ID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBsYXlvdXRQYXJhbSwgbm9ybWFsU3R5bGVNb2RlbCwgZW1waGFzaXNNb2RlbCwgdGV4dFN0eWxlTW9kZWwsIGVtcGhhc2lzVGV4dFN0eWxlTW9kZWwsIG9uU2VsZWN0KSB7XG4gICAgLy8gU3RhcnQgcmVuZGVyaW5nLlxuICAgIHZhciBsYXN0WCA9IDA7XG4gICAgdmFyIGVtcHR5SXRlbVdpZHRoID0gbGF5b3V0UGFyYW0uZW1wdHlJdGVtV2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHNlcmllc01vZGVsLmdldChbJ2JyZWFkY3J1bWInLCAnaGVpZ2h0J10pO1xuICAgIHZhciBhdmFpbGFibGVTaXplID0gbGF5b3V0LmdldEF2YWlsYWJsZVNpemUobGF5b3V0UGFyYW0ucG9zLCBsYXlvdXRQYXJhbS5ib3gpO1xuICAgIHZhciB0b3RhbFdpZHRoID0gbGF5b3V0UGFyYW0udG90YWxXaWR0aDtcbiAgICB2YXIgcmVuZGVyTGlzdCA9IGxheW91dFBhcmFtLnJlbmRlckxpc3Q7XG4gICAgdmFyIGVtcGhhc2lzSXRlbVN0eWxlID0gZW1waGFzaXNNb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJykuZ2V0SXRlbVN0eWxlKCk7XG4gICAgZm9yICh2YXIgaSA9IHJlbmRlckxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBpdGVtID0gcmVuZGVyTGlzdFtpXTtcbiAgICAgIHZhciBpdGVtTm9kZSA9IGl0ZW0ubm9kZTtcbiAgICAgIHZhciBpdGVtV2lkdGggPSBpdGVtLndpZHRoO1xuICAgICAgdmFyIHRleHQgPSBpdGVtLnRleHQ7XG4gICAgICAvLyBIZGllIHRleHQgYW5kIHNob3J0ZW4gd2lkdGggaWYgbmVjZXNzYXJ5LlxuICAgICAgaWYgKHRvdGFsV2lkdGggPiBhdmFpbGFibGVTaXplLndpZHRoKSB7XG4gICAgICAgIHRvdGFsV2lkdGggLT0gaXRlbVdpZHRoIC0gZW1wdHlJdGVtV2lkdGg7XG4gICAgICAgIGl0ZW1XaWR0aCA9IGVtcHR5SXRlbVdpZHRoO1xuICAgICAgICB0ZXh0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBlbCA9IG5ldyBncmFwaGljLlBvbHlnb24oe1xuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIHBvaW50czogbWFrZUl0ZW1Qb2ludHMobGFzdFgsIDAsIGl0ZW1XaWR0aCwgaGVpZ2h0LCBpID09PSByZW5kZXJMaXN0Lmxlbmd0aCAtIDEsIGkgPT09IDApXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiBkZWZhdWx0cyhub3JtYWxTdHlsZU1vZGVsLmdldEl0ZW1TdHlsZSgpLCB7XG4gICAgICAgICAgbGluZUpvaW46ICdiZXZlbCdcbiAgICAgICAgfSksXG4gICAgICAgIHRleHRDb250ZW50OiBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgICBzdHlsZTogY3JlYXRlVGV4dFN0eWxlKHRleHRTdHlsZU1vZGVsLCB7XG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIHRleHRDb25maWc6IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2luc2lkZSdcbiAgICAgICAgfSxcbiAgICAgICAgejI6IFoyX0VNUEhBU0lTX0xJRlQgKiAxZTQsXG4gICAgICAgIG9uY2xpY2s6IGN1cnJ5KG9uU2VsZWN0LCBpdGVtTm9kZSlcbiAgICAgIH0pO1xuICAgICAgZWwuZGlzYWJsZUxhYmVsQW5pbWF0aW9uID0gdHJ1ZTtcbiAgICAgIGVsLmdldFRleHRDb250ZW50KCkuZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJykuc3R5bGUgPSBjcmVhdGVUZXh0U3R5bGUoZW1waGFzaXNUZXh0U3R5bGVNb2RlbCwge1xuICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICB9KTtcbiAgICAgIGVsLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpLnN0eWxlID0gZW1waGFzaXNJdGVtU3R5bGU7XG4gICAgICB0b2dnbGVIb3ZlckVtcGhhc2lzKGVsLCBlbXBoYXNpc01vZGVsLmdldCgnZm9jdXMnKSwgZW1waGFzaXNNb2RlbC5nZXQoJ2JsdXJTY29wZScpLCBlbXBoYXNpc01vZGVsLmdldCgnZGlzYWJsZWQnKSk7XG4gICAgICB0aGlzLmdyb3VwLmFkZChlbCk7XG4gICAgICBwYWNrRXZlbnREYXRhKGVsLCBzZXJpZXNNb2RlbCwgaXRlbU5vZGUpO1xuICAgICAgbGFzdFggKz0gaXRlbVdpZHRoICsgSVRFTV9HQVA7XG4gICAgfVxuICB9O1xuICBCcmVhZGNydW1iLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgfTtcbiAgcmV0dXJuIEJyZWFkY3J1bWI7XG59KCk7XG5mdW5jdGlvbiBtYWtlSXRlbVBvaW50cyh4LCB5LCBpdGVtV2lkdGgsIGl0ZW1IZWlnaHQsIGhlYWQsIHRhaWwpIHtcbiAgdmFyIHBvaW50cyA9IFtbaGVhZCA/IHggOiB4IC0gQVJSQVlfTEVOR1RILCB5XSwgW3ggKyBpdGVtV2lkdGgsIHldLCBbeCArIGl0ZW1XaWR0aCwgeSArIGl0ZW1IZWlnaHRdLCBbaGVhZCA/IHggOiB4IC0gQVJSQVlfTEVOR1RILCB5ICsgaXRlbUhlaWdodF1dO1xuICAhdGFpbCAmJiBwb2ludHMuc3BsaWNlKDIsIDAsIFt4ICsgaXRlbVdpZHRoICsgQVJSQVlfTEVOR1RILCB5ICsgaXRlbUhlaWdodCAvIDJdKTtcbiAgIWhlYWQgJiYgcG9pbnRzLnB1c2goW3gsIHkgKyBpdGVtSGVpZ2h0IC8gMl0pO1xuICByZXR1cm4gcG9pbnRzO1xufVxuLy8gUGFja2FnZSBjdXN0b20gbW91c2UgZXZlbnQuXG5mdW5jdGlvbiBwYWNrRXZlbnREYXRhKGVsLCBzZXJpZXNNb2RlbCwgaXRlbU5vZGUpIHtcbiAgZ2V0RUNEYXRhKGVsKS5ldmVudERhdGEgPSB7XG4gICAgY29tcG9uZW50VHlwZTogJ3NlcmllcycsXG4gICAgY29tcG9uZW50U3ViVHlwZTogJ3RyZWVtYXAnLFxuICAgIGNvbXBvbmVudEluZGV4OiBzZXJpZXNNb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICBzZXJpZXNJbmRleDogc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXgsXG4gICAgc2VyaWVzTmFtZTogc2VyaWVzTW9kZWwubmFtZSxcbiAgICBzZXJpZXNUeXBlOiAndHJlZW1hcCcsXG4gICAgc2VsZlR5cGU6ICdicmVhZGNydW1iJyxcbiAgICBub2RlRGF0YToge1xuICAgICAgZGF0YUluZGV4OiBpdGVtTm9kZSAmJiBpdGVtTm9kZS5kYXRhSW5kZXgsXG4gICAgICBuYW1lOiBpdGVtTm9kZSAmJiBpdGVtTm9kZS5uYW1lXG4gICAgfSxcbiAgICB0cmVlUGF0aEluZm86IGl0ZW1Ob2RlICYmIHdyYXBUcmVlUGF0aEluZm8oaXRlbU5vZGUsIHNlcmllc01vZGVsKVxuICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgQnJlYWRjcnVtYjsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgYmluZCwgZWFjaCwgaW5kZXhPZiwgY3VycnksIGV4dGVuZCwgbm9ybWFsaXplQ3NzQXJyYXksIGlzRnVuY3Rpb24gfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgZ3JhcGhpYyBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlLmpzJztcbmltcG9ydCB7IGlzSGlnaERvd25EaXNwYXRjaGVyLCBzZXRBc0hpZ2hEb3duRGlzcGF0Y2hlciwgc2V0RGVmYXVsdFN0YXRlUHJveHksIGVuYWJsZUhvdmVyRm9jdXMsIFoyX0VNUEhBU0lTX0xJRlQgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgRGF0YURpZmZlciBmcm9tICcuLi8uLi9kYXRhL0RhdGFEaWZmZXIuanMnO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uL2hlbHBlci90cmVlSGVscGVyLmpzJztcbmltcG9ydCBCcmVhZGNydW1iIGZyb20gJy4vQnJlYWRjcnVtYi5qcyc7XG5pbXBvcnQgUm9hbUNvbnRyb2xsZXIgZnJvbSAnLi4vLi4vY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlci5qcyc7XG5pbXBvcnQgQm91bmRpbmdSZWN0IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJztcbmltcG9ydCAqIGFzIG1hdHJpeCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qcyc7XG5pbXBvcnQgKiBhcyBhbmltYXRpb25VdGlsIGZyb20gJy4uLy4uL3V0aWwvYW5pbWF0aW9uLmpzJztcbmltcG9ydCBtYWtlU3R5bGVNYXBwZXIgZnJvbSAnLi4vLi4vbW9kZWwvbWl4aW4vbWFrZVN0eWxlTWFwcGVyLmpzJztcbmltcG9ydCBDaGFydFZpZXcgZnJvbSAnLi4vLi4vdmlldy9DaGFydC5qcyc7XG5pbXBvcnQgRGlzcGxheWFibGUgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qcyc7XG5pbXBvcnQgeyBtYWtlSW5uZXIsIGNvbnZlcnRPcHRpb25JZE5hbWUgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCB7IHdpbmRvd09wZW4gfSBmcm9tICcuLi8uLi91dGlsL2Zvcm1hdC5qcyc7XG5pbXBvcnQgeyBzZXRMYWJlbFN0eWxlLCBnZXRMYWJlbFN0YXRlc01vZGVscyB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUuanMnO1xudmFyIEdyb3VwID0gZ3JhcGhpYy5Hcm91cDtcbnZhciBSZWN0ID0gZ3JhcGhpYy5SZWN0O1xudmFyIERSQUdfVEhSRVNIT0xEID0gMztcbnZhciBQQVRIX0xBQkVMX05PQU1BTCA9ICdsYWJlbCc7XG52YXIgUEFUSF9VUFBFUkxBQkVMX05PUk1BTCA9ICd1cHBlckxhYmVsJztcbi8vIFNob3VsZCBsYXJnZXIgdGhhbiBlbXBoYXNpcyBzdGF0ZXMgbGlmdCB6XG52YXIgWjJfQkFTRSA9IFoyX0VNUEhBU0lTX0xJRlQgKiAxMDsgLy8gU2hvdWxkIGJpZ2dlciB0aGFuIGV2ZXJ5IHoyLlxudmFyIFoyX0JHID0gWjJfRU1QSEFTSVNfTElGVCAqIDI7XG52YXIgWjJfQ09OVEVOVCA9IFoyX0VNUEhBU0lTX0xJRlQgKiAzO1xudmFyIGdldFN0YXRlSXRlbVN0eWxlID0gbWFrZVN0eWxlTWFwcGVyKFtbJ2ZpbGwnLCAnY29sb3InXSxcbi8vIGBib3JkZXJDb2xvcmAgYW5kIGBib3JkZXJXaWR0aGAgaGFzIGJlZW4gb2NjdXBpZWQsXG4vLyBzbyB1c2UgYHN0cm9rZWAgdG8gaW5kaWNhdGUgdGhlIHN0cm9rZSBvZiB0aGUgcmVjdC5cblsnc3Ryb2tlJywgJ3N0cm9rZUNvbG9yJ10sIFsnbGluZVdpZHRoJywgJ3N0cm9rZVdpZHRoJ10sIFsnc2hhZG93Qmx1ciddLCBbJ3NoYWRvd09mZnNldFgnXSwgWydzaGFkb3dPZmZzZXRZJ10sIFsnc2hhZG93Q29sb3InXVxuLy8gT3B0aW9uIGRlY2FsIGlzIGluIGBEZWNhbE9iamVjdGAgYnV0IHN0eWxlLmRlY2FsIGlzIGluIGBQYXR0ZXJuT2JqZWN0YC5cbi8vIFNvIGRvIG5vdCB0cmFuc2ZlciBkZWNhbCBkaXJlY3RseS5cbl0pO1xudmFyIGdldEl0ZW1TdHlsZU5vcm1hbCA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAvLyBOb3JtYWwgc3R5bGUgcHJvcHMgc2hvdWxkIGluY2x1ZGUgZW1waGFzaXMgc3R5bGUgcHJvcHMuXG4gIHZhciBpdGVtU3R5bGUgPSBnZXRTdGF0ZUl0ZW1TdHlsZShtb2RlbCk7XG4gIC8vIENsZWFyIHN0eWxlcyBzZXQgYnkgZW1waGFzaXMuXG4gIGl0ZW1TdHlsZS5zdHJva2UgPSBpdGVtU3R5bGUuZmlsbCA9IGl0ZW1TdHlsZS5saW5lV2lkdGggPSBudWxsO1xuICByZXR1cm4gaXRlbVN0eWxlO1xufTtcbnZhciBpbm5lciA9IG1ha2VJbm5lcigpO1xudmFyIFRyZWVtYXBWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRyZWVtYXBWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBUcmVlbWFwVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gVHJlZW1hcFZpZXcudHlwZTtcbiAgICBfdGhpcy5fc3RhdGUgPSAncmVhZHknO1xuICAgIF90aGlzLl9zdG9yYWdlID0gY3JlYXRlU3RvcmFnZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgVHJlZW1hcFZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdmFyIG1vZGVscyA9IGVjTW9kZWwuZmluZENvbXBvbmVudHMoe1xuICAgICAgbWFpblR5cGU6ICdzZXJpZXMnLFxuICAgICAgc3ViVHlwZTogJ3RyZWVtYXAnLFxuICAgICAgcXVlcnk6IHBheWxvYWRcbiAgICB9KTtcbiAgICBpZiAoaW5kZXhPZihtb2RlbHMsIHNlcmllc01vZGVsKSA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXJpZXNNb2RlbCA9IHNlcmllc01vZGVsO1xuICAgIHRoaXMuYXBpID0gYXBpO1xuICAgIHRoaXMuZWNNb2RlbCA9IGVjTW9kZWw7XG4gICAgdmFyIHR5cGVzID0gWyd0cmVlbWFwWm9vbVRvTm9kZScsICd0cmVlbWFwUm9vdFRvTm9kZSddO1xuICAgIHZhciB0YXJnZXRJbmZvID0gaGVscGVyLnJldHJpZXZlVGFyZ2V0SW5mbyhwYXlsb2FkLCB0eXBlcywgc2VyaWVzTW9kZWwpO1xuICAgIHZhciBwYXlsb2FkVHlwZSA9IHBheWxvYWQgJiYgcGF5bG9hZC50eXBlO1xuICAgIHZhciBsYXlvdXRJbmZvID0gc2VyaWVzTW9kZWwubGF5b3V0SW5mbztcbiAgICB2YXIgaXNJbml0ID0gIXRoaXMuX29sZFRyZWU7XG4gICAgdmFyIHRoaXNTdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgICAvLyBNYXJrIG5ldyByb290IHdoZW4gYWN0aW9uIGlzIHRyZWVtYXBSb290VG9Ob2RlLlxuICAgIHZhciByZVJvb3QgPSBwYXlsb2FkVHlwZSA9PT0gJ3RyZWVtYXBSb290VG9Ob2RlJyAmJiB0YXJnZXRJbmZvICYmIHRoaXNTdG9yYWdlID8ge1xuICAgICAgcm9vdE5vZGVHcm91cDogdGhpc1N0b3JhZ2Uubm9kZUdyb3VwW3RhcmdldEluZm8ubm9kZS5nZXRSYXdJbmRleCgpXSxcbiAgICAgIGRpcmVjdGlvbjogcGF5bG9hZC5kaXJlY3Rpb25cbiAgICB9IDogbnVsbDtcbiAgICB2YXIgY29udGFpbmVyR3JvdXAgPSB0aGlzLl9naXZlQ29udGFpbmVyR3JvdXAobGF5b3V0SW5mbyk7XG4gICAgdmFyIGhhc0FuaW1hdGlvbiA9IHNlcmllc01vZGVsLmdldCgnYW5pbWF0aW9uJyk7XG4gICAgdmFyIHJlbmRlclJlc3VsdCA9IHRoaXMuX2RvUmVuZGVyKGNvbnRhaW5lckdyb3VwLCBzZXJpZXNNb2RlbCwgcmVSb290KTtcbiAgICBoYXNBbmltYXRpb24gJiYgIWlzSW5pdCAmJiAoIXBheWxvYWRUeXBlIHx8IHBheWxvYWRUeXBlID09PSAndHJlZW1hcFpvb21Ub05vZGUnIHx8IHBheWxvYWRUeXBlID09PSAndHJlZW1hcFJvb3RUb05vZGUnKSA/IHRoaXMuX2RvQW5pbWF0aW9uKGNvbnRhaW5lckdyb3VwLCByZW5kZXJSZXN1bHQsIHNlcmllc01vZGVsLCByZVJvb3QpIDogcmVuZGVyUmVzdWx0LnJlbmRlckZpbmFsbHkoKTtcbiAgICB0aGlzLl9yZXNldENvbnRyb2xsZXIoYXBpKTtcbiAgICB0aGlzLl9yZW5kZXJCcmVhZGNydW1iKHNlcmllc01vZGVsLCBhcGksIHRhcmdldEluZm8pO1xuICB9O1xuICBUcmVlbWFwVmlldy5wcm90b3R5cGUuX2dpdmVDb250YWluZXJHcm91cCA9IGZ1bmN0aW9uIChsYXlvdXRJbmZvKSB7XG4gICAgdmFyIGNvbnRhaW5lckdyb3VwID0gdGhpcy5fY29udGFpbmVyR3JvdXA7XG4gICAgaWYgKCFjb250YWluZXJHcm91cCkge1xuICAgICAgLy8gRklYTUVcbiAgICAgIC8vIOWKoOS4gOWxgmNvbnRhaW5lckdyb3Vw5piv5Li65LqGY2xpcO+8jOS9huaYr+eOsOWcqGNsaXDlip/og73lubbmsqHmnInlrp7njrDjgIJcbiAgICAgIGNvbnRhaW5lckdyb3VwID0gdGhpcy5fY29udGFpbmVyR3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgICAgIHRoaXMuX2luaXRFdmVudHMoY29udGFpbmVyR3JvdXApO1xuICAgICAgdGhpcy5ncm91cC5hZGQoY29udGFpbmVyR3JvdXApO1xuICAgIH1cbiAgICBjb250YWluZXJHcm91cC54ID0gbGF5b3V0SW5mby54O1xuICAgIGNvbnRhaW5lckdyb3VwLnkgPSBsYXlvdXRJbmZvLnk7XG4gICAgcmV0dXJuIGNvbnRhaW5lckdyb3VwO1xuICB9O1xuICBUcmVlbWFwVmlldy5wcm90b3R5cGUuX2RvUmVuZGVyID0gZnVuY3Rpb24gKGNvbnRhaW5lckdyb3VwLCBzZXJpZXNNb2RlbCwgcmVSb290KSB7XG4gICAgdmFyIHRoaXNUcmVlID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLnRyZWU7XG4gICAgdmFyIG9sZFRyZWUgPSB0aGlzLl9vbGRUcmVlO1xuICAgIC8vIENsZWFyIGxhc3Qgc2hhcGUgcmVjb3Jkcy5cbiAgICB2YXIgbGFzdHNGb3JBbmltYXRpb24gPSBjcmVhdGVTdG9yYWdlKCk7XG4gICAgdmFyIHRoaXNTdG9yYWdlID0gY3JlYXRlU3RvcmFnZSgpO1xuICAgIHZhciBvbGRTdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgICB2YXIgd2lsbEludmlzaWJsZUVscyA9IFtdO1xuICAgIGZ1bmN0aW9uIGRvUmVuZGVyTm9kZSh0aGlzTm9kZSwgb2xkTm9kZSwgcGFyZW50R3JvdXAsIGRlcHRoKSB7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZShzZXJpZXNNb2RlbCwgdGhpc1N0b3JhZ2UsIG9sZFN0b3JhZ2UsIHJlUm9vdCwgbGFzdHNGb3JBbmltYXRpb24sIHdpbGxJbnZpc2libGVFbHMsIHRoaXNOb2RlLCBvbGROb2RlLCBwYXJlbnRHcm91cCwgZGVwdGgpO1xuICAgIH1cbiAgICAvLyBOb3RpY2U6IFdoZW4gdGhpc1RyZWUgYW5kIG9sZFRyZWUgYXJlIHRoZSBzYW1lIHRyZWUgKHNlZSBsaXN0LmNsb25lU2hhbGxvdyksXG4gICAgLy8gdGhlIG9sZFRyZWUgaXMgYWN0dWFsbHkgbG9zdGVkLCBzbyB3ZSBjYW5ub3QgZmluZCBhbGwgb2YgdGhlIG9sZCBncmFwaGljXG4gICAgLy8gZWxlbWVudHMgZnJvbSB0cmVlLiBTbyB3ZSB1c2UgdGhpcyBzdHJhdGVneTogbWFrZSBlbGVtZW50IHN0b3JhZ2UsIG1vdmVcbiAgICAvLyBmcm9tIG9sZCBzdG9yYWdlIHRvIG5ldyBzdG9yYWdlLCBjbGVhciBvbGQgc3RvcmFnZS5cbiAgICBkdWFsVHJhdmVsKHRoaXNUcmVlLnJvb3QgPyBbdGhpc1RyZWUucm9vdF0gOiBbXSwgb2xkVHJlZSAmJiBvbGRUcmVlLnJvb3QgPyBbb2xkVHJlZS5yb290XSA6IFtdLCBjb250YWluZXJHcm91cCwgdGhpc1RyZWUgPT09IG9sZFRyZWUgfHwgIW9sZFRyZWUsIDApO1xuICAgIC8vIFByb2Nlc3MgYWxsIHJlbW92aW5nLlxuICAgIHZhciB3aWxsRGVsZXRlRWxzID0gY2xlYXJTdG9yYWdlKG9sZFN0b3JhZ2UpO1xuICAgIHRoaXMuX29sZFRyZWUgPSB0aGlzVHJlZTtcbiAgICB0aGlzLl9zdG9yYWdlID0gdGhpc1N0b3JhZ2U7XG4gICAgaWYgKHRoaXMuX2NvbnRyb2xsZXJIb3N0KSB7XG4gICAgICB2YXIgX29sZFJvb3RMYXlvdXQgPSB0aGlzLnNlcmllc01vZGVsLmxheW91dEluZm87XG4gICAgICB2YXIgcm9vdExheW91dCA9IHRoaXNUcmVlLnJvb3QuZ2V0TGF5b3V0KCk7XG4gICAgICBpZiAocm9vdExheW91dC53aWR0aCA9PT0gX29sZFJvb3RMYXlvdXQud2lkdGggJiYgcm9vdExheW91dC5oZWlnaHQgPT09IF9vbGRSb290TGF5b3V0LmhlaWdodCkge1xuICAgICAgICB0aGlzLl9jb250cm9sbGVySG9zdC56b29tID0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhc3RzRm9yQW5pbWF0aW9uOiBsYXN0c0ZvckFuaW1hdGlvbixcbiAgICAgIHdpbGxEZWxldGVFbHM6IHdpbGxEZWxldGVFbHMsXG4gICAgICByZW5kZXJGaW5hbGx5OiByZW5kZXJGaW5hbGx5XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkdWFsVHJhdmVsKHRoaXNWaWV3Q2hpbGRyZW4sIG9sZFZpZXdDaGlsZHJlbiwgcGFyZW50R3JvdXAsIHNhbWVUcmVlLCBkZXB0aCkge1xuICAgICAgLy8gV2hlbiAncmVuZGVyJyBpcyB0cmlnZ2VyZWQgYnkgYWN0aW9uLFxuICAgICAgLy8gJ3RoaXMnIGFuZCAnb2xkJyBtYXkgYmUgdGhlIHNhbWUgdHJlZSxcbiAgICAgIC8vIHdlIHVzZSByYXdJbmRleCBpbiB0aGF0IGNhc2UuXG4gICAgICBpZiAoc2FtZVRyZWUpIHtcbiAgICAgICAgb2xkVmlld0NoaWxkcmVuID0gdGhpc1ZpZXdDaGlsZHJlbjtcbiAgICAgICAgZWFjaCh0aGlzVmlld0NoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgIWNoaWxkLmlzUmVtb3ZlZCgpICYmIHByb2Nlc3NOb2RlKGluZGV4LCBpbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gRGlmZiBoaWVyYXJjaGljYWxseSAoZGlmZiBvbmx5IGluIGVhY2ggc3VidHJlZSwgYnV0IG5vdCB3aG9sZSkuXG4gICAgICAvLyBiZWNhdXNlLCBjb25zaXN0ZW5jeSBvZiB2aWV3IGlzIGltcG9ydGFudC5cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXcgRGF0YURpZmZlcihvbGRWaWV3Q2hpbGRyZW4sIHRoaXNWaWV3Q2hpbGRyZW4sIGdldEtleSwgZ2V0S2V5KS5hZGQocHJvY2Vzc05vZGUpLnVwZGF0ZShwcm9jZXNzTm9kZSkucmVtb3ZlKGN1cnJ5KHByb2Nlc3NOb2RlLCBudWxsKSkuZXhlY3V0ZSgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0S2V5KG5vZGUpIHtcbiAgICAgICAgLy8gSWRlbnRpZnkgYnkgbmFtZSBvciByYXcgaW5kZXguXG4gICAgICAgIHJldHVybiBub2RlLmdldElkKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZShuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgICAgICAgdmFyIHRoaXNOb2RlID0gbmV3SW5kZXggIT0gbnVsbCA/IHRoaXNWaWV3Q2hpbGRyZW5bbmV3SW5kZXhdIDogbnVsbDtcbiAgICAgICAgdmFyIG9sZE5vZGUgPSBvbGRJbmRleCAhPSBudWxsID8gb2xkVmlld0NoaWxkcmVuW29sZEluZGV4XSA6IG51bGw7XG4gICAgICAgIHZhciBncm91cCA9IGRvUmVuZGVyTm9kZSh0aGlzTm9kZSwgb2xkTm9kZSwgcGFyZW50R3JvdXAsIGRlcHRoKTtcbiAgICAgICAgZ3JvdXAgJiYgZHVhbFRyYXZlbCh0aGlzTm9kZSAmJiB0aGlzTm9kZS52aWV3Q2hpbGRyZW4gfHwgW10sIG9sZE5vZGUgJiYgb2xkTm9kZS52aWV3Q2hpbGRyZW4gfHwgW10sIGdyb3VwLCBzYW1lVHJlZSwgZGVwdGggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJTdG9yYWdlKHN0b3JhZ2UpIHtcbiAgICAgIHZhciB3aWxsRGVsZXRlRWxzID0gY3JlYXRlU3RvcmFnZSgpO1xuICAgICAgc3RvcmFnZSAmJiBlYWNoKHN0b3JhZ2UsIGZ1bmN0aW9uIChzdG9yZSwgc3RvcmFnZU5hbWUpIHtcbiAgICAgICAgdmFyIGRlbEVscyA9IHdpbGxEZWxldGVFbHNbc3RvcmFnZU5hbWVdO1xuICAgICAgICBlYWNoKHN0b3JlLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBlbCAmJiAoZGVsRWxzLnB1c2goZWwpLCBpbm5lcihlbCkud2lsbERlbGV0ZSA9IHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHdpbGxEZWxldGVFbHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckZpbmFsbHkoKSB7XG4gICAgICBlYWNoKHdpbGxEZWxldGVFbHMsIGZ1bmN0aW9uIChlbHMpIHtcbiAgICAgICAgZWFjaChlbHMsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGVsLnBhcmVudCAmJiBlbC5wYXJlbnQucmVtb3ZlKGVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGVhY2god2lsbEludmlzaWJsZUVscywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmludmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8vIFNldHRpbmcgaW52aXNpYmxlIGlzIGZvciBvcHRpbWl6aW5nLCBzbyBubyBuZWVkIHRvIHNldCBkaXJ0eSxcbiAgICAgICAgLy8ganVzdCBtYXJrIGFzIGludmlzaWJsZS5cbiAgICAgICAgZWwuZGlydHkoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgVHJlZW1hcFZpZXcucHJvdG90eXBlLl9kb0FuaW1hdGlvbiA9IGZ1bmN0aW9uIChjb250YWluZXJHcm91cCwgcmVuZGVyUmVzdWx0LCBzZXJpZXNNb2RlbCwgcmVSb290KSB7XG4gICAgdmFyIGR1cmF0aW9uT3B0aW9uID0gc2VyaWVzTW9kZWwuZ2V0KCdhbmltYXRpb25EdXJhdGlvblVwZGF0ZScpO1xuICAgIHZhciBlYXNpbmdPcHRpb24gPSBzZXJpZXNNb2RlbC5nZXQoJ2FuaW1hdGlvbkVhc2luZycpO1xuICAgIC8vIFRPRE86IGRvIG5vdCBzdXBwb3J0IGZ1bmN0aW9uIHVudGlsIG5lY2Vzc2FyeS5cbiAgICB2YXIgZHVyYXRpb24gPSAoaXNGdW5jdGlvbihkdXJhdGlvbk9wdGlvbikgPyAwIDogZHVyYXRpb25PcHRpb24pIHx8IDA7XG4gICAgdmFyIGVhc2luZyA9IChpc0Z1bmN0aW9uKGVhc2luZ09wdGlvbikgPyBudWxsIDogZWFzaW5nT3B0aW9uKSB8fCAnY3ViaWNPdXQnO1xuICAgIHZhciBhbmltYXRpb25XcmFwID0gYW5pbWF0aW9uVXRpbC5jcmVhdGVXcmFwKCk7XG4gICAgLy8gTWFrZSBkZWxldGUgYW5pbWF0aW9ucy5cbiAgICBlYWNoKHJlbmRlclJlc3VsdC53aWxsRGVsZXRlRWxzLCBmdW5jdGlvbiAoc3RvcmUsIHN0b3JhZ2VOYW1lKSB7XG4gICAgICBlYWNoKHN0b3JlLCBmdW5jdGlvbiAoZWwsIHJhd0luZGV4KSB7XG4gICAgICAgIGlmIChlbC5pbnZpc2libGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDsgLy8gQWx3YXlzIGhhcyBwYXJlbnQsIGFuZCBwYXJlbnQgaXMgbm9kZUdyb3VwLlxuICAgICAgICB2YXIgdGFyZ2V0O1xuICAgICAgICB2YXIgaW5uZXJTdG9yZSA9IGlubmVyKHBhcmVudCk7XG4gICAgICAgIGlmIChyZVJvb3QgJiYgcmVSb290LmRpcmVjdGlvbiA9PT0gJ2RyaWxsRG93bicpIHtcbiAgICAgICAgICB0YXJnZXQgPSBwYXJlbnQgPT09IHJlUm9vdC5yb290Tm9kZUdyb3VwXG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgY29udGVudCBlbGVtZW50IG9mIHZpZXcgcm9vdC5cbiAgICAgICAgICAvLyBPbmx5IGBjb250ZW50YCB3aWxsIGVudGVyIHRoaXMgYnJhbmNoLCBiZWNhdXNlXG4gICAgICAgICAgLy8gYGJhY2tncm91bmRgIGFuZCBgbm9kZUdyb3VwYCB3aWxsIG5vdCBiZSBkZWxldGVkLlxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgd2lkdGg6IGlubmVyU3RvcmUubm9kZVdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGlubmVyU3RvcmUubm9kZUhlaWdodFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3RoZXJzLlxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRhcmdldFggPSAwO1xuICAgICAgICAgIHZhciB0YXJnZXRZID0gMDtcbiAgICAgICAgICBpZiAoIWlubmVyU3RvcmUud2lsbERlbGV0ZSkge1xuICAgICAgICAgICAgLy8gTGV0IG5vZGUgYW5pbWF0ZSB0byByaWdodC1ib3R0b20gY29ybmVyLCBjb29wZXJhdGluZyB3aXRoIGZhZGVvdXQsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBhcHByb3ByaWF0ZSBmb3IgdXNlciB1bmRlcnN0YW5kaW5nLlxuICAgICAgICAgICAgLy8gRGl2aWRlZCBieSAyIGZvciByZVJvb3Qgcm9sbGluZyB1cCBlZmZlY3QuXG4gICAgICAgICAgICB0YXJnZXRYID0gaW5uZXJTdG9yZS5ub2RlV2lkdGggLyAyO1xuICAgICAgICAgICAgdGFyZ2V0WSA9IGlubmVyU3RvcmUubm9kZUhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldCA9IHN0b3JhZ2VOYW1lID09PSAnbm9kZUdyb3VwJyA/IHtcbiAgICAgICAgICAgIHg6IHRhcmdldFgsXG4gICAgICAgICAgICB5OiB0YXJnZXRZLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICB4OiB0YXJnZXRYLFxuICAgICAgICAgICAgICB5OiB0YXJnZXRZLFxuICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogZG8gbm90IHN1cHBvcnQgZGVsYXkgdW50aWwgbmVjZXNzYXJ5LlxuICAgICAgICB0YXJnZXQgJiYgYW5pbWF0aW9uV3JhcC5hZGQoZWwsIHRhcmdldCwgZHVyYXRpb24sIDAsIGVhc2luZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBNYWtlIG90aGVyIGFuaW1hdGlvbnNcbiAgICBlYWNoKHRoaXMuX3N0b3JhZ2UsIGZ1bmN0aW9uIChzdG9yZSwgc3RvcmFnZU5hbWUpIHtcbiAgICAgIGVhY2goc3RvcmUsIGZ1bmN0aW9uIChlbCwgcmF3SW5kZXgpIHtcbiAgICAgICAgdmFyIGxhc3QgPSByZW5kZXJSZXN1bHQubGFzdHNGb3JBbmltYXRpb25bc3RvcmFnZU5hbWVdW3Jhd0luZGV4XTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHt9O1xuICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgZ3JhcGhpYy5Hcm91cCkge1xuICAgICAgICAgIGlmIChsYXN0Lm9sZFggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGFyZ2V0LnggPSBlbC54O1xuICAgICAgICAgICAgdGFyZ2V0LnkgPSBlbC55O1xuICAgICAgICAgICAgZWwueCA9IGxhc3Qub2xkWDtcbiAgICAgICAgICAgIGVsLnkgPSBsYXN0Lm9sZFk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsYXN0Lm9sZFNoYXBlKSB7XG4gICAgICAgICAgICB0YXJnZXQuc2hhcGUgPSBleHRlbmQoe30sIGVsLnNoYXBlKTtcbiAgICAgICAgICAgIGVsLnNldFNoYXBlKGxhc3Qub2xkU2hhcGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGFzdC5mYWRlaW4pIHtcbiAgICAgICAgICAgIGVsLnNldFN0eWxlKCdvcGFjaXR5JywgMCk7XG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUgPSB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFdoZW4gYW5pbWF0aW9uIGlzIHN0b3BwZWQgZm9yIHN1Y2NlZGVudCBhbmltYXRpb24gc3RhcnRpbmcsXG4gICAgICAgICAgLy8gZWwuc3R5bGUub3BhY2l0eSBtaWdodCBub3QgYmUgMVxuICAgICAgICAgIGVsc2UgaWYgKGVsLnN0eWxlLm9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZSA9IHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYW5pbWF0aW9uV3JhcC5hZGQoZWwsIHRhcmdldCwgZHVyYXRpb24sIDAsIGVhc2luZyk7XG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9zdGF0ZSA9ICdhbmltYXRpbmcnO1xuICAgIGFuaW1hdGlvbldyYXAuZmluaXNoZWQoYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9ICdyZWFkeSc7XG4gICAgICByZW5kZXJSZXN1bHQucmVuZGVyRmluYWxseSgpO1xuICAgIH0sIHRoaXMpKS5zdGFydCgpO1xuICB9O1xuICBUcmVlbWFwVmlldy5wcm90b3R5cGUuX3Jlc2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB2YXIgY29udHJvbGxlciA9IHRoaXMuX2NvbnRyb2xsZXI7XG4gICAgdmFyIGNvbnRyb2xsZXJIb3N0ID0gdGhpcy5fY29udHJvbGxlckhvc3Q7XG4gICAgaWYgKCFjb250cm9sbGVySG9zdCkge1xuICAgICAgdGhpcy5fY29udHJvbGxlckhvc3QgPSB7XG4gICAgICAgIHRhcmdldDogdGhpcy5ncm91cFxuICAgICAgfTtcbiAgICAgIGNvbnRyb2xsZXJIb3N0ID0gdGhpcy5fY29udHJvbGxlckhvc3Q7XG4gICAgfVxuICAgIC8vIEluaXQgY29udHJvbGxlci5cbiAgICBpZiAoIWNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVyID0gbmV3IFJvYW1Db250cm9sbGVyKGFwaS5nZXRacigpKTtcbiAgICAgIGNvbnRyb2xsZXIuZW5hYmxlKHRoaXMuc2VyaWVzTW9kZWwuZ2V0KCdyb2FtJykpO1xuICAgICAgY29udHJvbGxlckhvc3Quem9vbUxpbWl0ID0gdGhpcy5zZXJpZXNNb2RlbC5nZXQoJ3NjYWxlTGltaXQnKTtcbiAgICAgIGNvbnRyb2xsZXJIb3N0Lnpvb20gPSB0aGlzLnNlcmllc01vZGVsLmdldCgnem9vbScpO1xuICAgICAgY29udHJvbGxlci5vbigncGFuJywgYmluZCh0aGlzLl9vblBhbiwgdGhpcykpO1xuICAgICAgY29udHJvbGxlci5vbignem9vbScsIGJpbmQodGhpcy5fb25ab29tLCB0aGlzKSk7XG4gICAgfVxuICAgIHZhciByZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCBhcGkuZ2V0V2lkdGgoKSwgYXBpLmdldEhlaWdodCgpKTtcbiAgICBjb250cm9sbGVyLnNldFBvaW50ZXJDaGVja2VyKGZ1bmN0aW9uIChlLCB4LCB5KSB7XG4gICAgICByZXR1cm4gcmVjdC5jb250YWluKHgsIHkpO1xuICAgIH0pO1xuICB9O1xuICBUcmVlbWFwVmlldy5wcm90b3R5cGUuX2NsZWFyQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udHJvbGxlciA9IHRoaXMuX2NvbnRyb2xsZXI7XG4gICAgdGhpcy5fY29udHJvbGxlckhvc3QgPSBudWxsO1xuICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmRpc3Bvc2UoKTtcbiAgICAgIGNvbnRyb2xsZXIgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgVHJlZW1hcFZpZXcucHJvdG90eXBlLl9vblBhbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSAnYW5pbWF0aW5nJyAmJiAoTWF0aC5hYnMoZS5keCkgPiBEUkFHX1RIUkVTSE9MRCB8fCBNYXRoLmFicyhlLmR5KSA+IERSQUdfVEhSRVNIT0xEKSkge1xuICAgICAgLy8gVGhlc2UgcGFyYW0gbXVzdCBub3QgYmUgY2FjaGVkLlxuICAgICAgdmFyIHJvb3QgPSB0aGlzLnNlcmllc01vZGVsLmdldERhdGEoKS50cmVlLnJvb3Q7XG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJvb3RMYXlvdXQgPSByb290LmdldExheW91dCgpO1xuICAgICAgaWYgKCFyb290TGF5b3V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ3RyZWVtYXBNb3ZlJyxcbiAgICAgICAgZnJvbTogdGhpcy51aWQsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLnNlcmllc01vZGVsLmlkLFxuICAgICAgICByb290UmVjdDoge1xuICAgICAgICAgIHg6IHJvb3RMYXlvdXQueCArIGUuZHgsXG4gICAgICAgICAgeTogcm9vdExheW91dC55ICsgZS5keSxcbiAgICAgICAgICB3aWR0aDogcm9vdExheW91dC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHJvb3RMYXlvdXQuaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgVHJlZW1hcFZpZXcucHJvdG90eXBlLl9vblpvb20gPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtb3VzZVggPSBlLm9yaWdpblg7XG4gICAgdmFyIG1vdXNlWSA9IGUub3JpZ2luWTtcbiAgICB2YXIgem9vbURlbHRhID0gZS5zY2FsZTtcbiAgICBpZiAodGhpcy5fc3RhdGUgIT09ICdhbmltYXRpbmcnKSB7XG4gICAgICAvLyBUaGVzZSBwYXJhbSBtdXN0IG5vdCBiZSBjYWNoZWQuXG4gICAgICB2YXIgcm9vdCA9IHRoaXMuc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLnRyZWUucm9vdDtcbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcm9vdExheW91dCA9IHJvb3QuZ2V0TGF5b3V0KCk7XG4gICAgICBpZiAoIXJvb3RMYXlvdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHJvb3RMYXlvdXQueCwgcm9vdExheW91dC55LCByb290TGF5b3V0LndpZHRoLCByb290TGF5b3V0LmhlaWdodCk7XG4gICAgICAvLyBzY2FsZUxpbWl0XG4gICAgICB2YXIgem9vbUxpbWl0ID0gbnVsbDtcbiAgICAgIHZhciBfY29udHJvbGxlckhvc3QgPSB0aGlzLl9jb250cm9sbGVySG9zdDtcbiAgICAgIHpvb21MaW1pdCA9IF9jb250cm9sbGVySG9zdC56b29tTGltaXQ7XG4gICAgICB2YXIgbmV3Wm9vbSA9IF9jb250cm9sbGVySG9zdC56b29tID0gX2NvbnRyb2xsZXJIb3N0Lnpvb20gfHwgMTtcbiAgICAgIG5ld1pvb20gKj0gem9vbURlbHRhO1xuICAgICAgaWYgKHpvb21MaW1pdCkge1xuICAgICAgICB2YXIgem9vbU1pbiA9IHpvb21MaW1pdC5taW4gfHwgMDtcbiAgICAgICAgdmFyIHpvb21NYXggPSB6b29tTGltaXQubWF4IHx8IEluZmluaXR5O1xuICAgICAgICBuZXdab29tID0gTWF0aC5tYXgoTWF0aC5taW4oem9vbU1heCwgbmV3Wm9vbSksIHpvb21NaW4pO1xuICAgICAgfVxuICAgICAgdmFyIHpvb21TY2FsZSA9IG5ld1pvb20gLyBfY29udHJvbGxlckhvc3Quem9vbTtcbiAgICAgIF9jb250cm9sbGVySG9zdC56b29tID0gbmV3Wm9vbTtcbiAgICAgIHZhciBsYXlvdXRJbmZvID0gdGhpcy5zZXJpZXNNb2RlbC5sYXlvdXRJbmZvO1xuICAgICAgLy8gVHJhbnNmb3JtIG1vdXNlIGNvb3JkIGZyb20gZ2xvYmFsIHRvIGNvbnRhaW5lckdyb3VwLlxuICAgICAgbW91c2VYIC09IGxheW91dEluZm8ueDtcbiAgICAgIG1vdXNlWSAtPSBsYXlvdXRJbmZvLnk7XG4gICAgICAvLyBTY2FsZSByb290IGJvdW5kaW5nIHJlY3QuXG4gICAgICB2YXIgbSA9IG1hdHJpeC5jcmVhdGUoKTtcbiAgICAgIG1hdHJpeC50cmFuc2xhdGUobSwgbSwgWy1tb3VzZVgsIC1tb3VzZVldKTtcbiAgICAgIG1hdHJpeC5zY2FsZShtLCBtLCBbem9vbVNjYWxlLCB6b29tU2NhbGVdKTtcbiAgICAgIG1hdHJpeC50cmFuc2xhdGUobSwgbSwgW21vdXNlWCwgbW91c2VZXSk7XG4gICAgICByZWN0LmFwcGx5VHJhbnNmb3JtKG0pO1xuICAgICAgdGhpcy5hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICB0eXBlOiAndHJlZW1hcFJlbmRlcicsXG4gICAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5zZXJpZXNNb2RlbC5pZCxcbiAgICAgICAgcm9vdFJlY3Q6IHtcbiAgICAgICAgICB4OiByZWN0LngsXG4gICAgICAgICAgeTogcmVjdC55LFxuICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBUcmVlbWFwVmlldy5wcm90b3R5cGUuX2luaXRFdmVudHMgPSBmdW5jdGlvbiAoY29udGFpbmVyR3JvdXApIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGNvbnRhaW5lckdyb3VwLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoX3RoaXMuX3N0YXRlICE9PSAncmVhZHknKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBub2RlQ2xpY2sgPSBfdGhpcy5zZXJpZXNNb2RlbC5nZXQoJ25vZGVDbGljaycsIHRydWUpO1xuICAgICAgaWYgKCFub2RlQ2xpY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRhcmdldEluZm8gPSBfdGhpcy5maW5kVGFyZ2V0KGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcbiAgICAgIGlmICghdGFyZ2V0SW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbm9kZSA9IHRhcmdldEluZm8ubm9kZTtcbiAgICAgIGlmIChub2RlLmdldExheW91dCgpLmlzTGVhZlJvb3QpIHtcbiAgICAgICAgX3RoaXMuX3Jvb3RUb05vZGUodGFyZ2V0SW5mbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm9kZUNsaWNrID09PSAnem9vbVRvTm9kZScpIHtcbiAgICAgICAgICBfdGhpcy5fem9vbVRvTm9kZSh0YXJnZXRJbmZvKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlQ2xpY2sgPT09ICdsaW5rJykge1xuICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBub2RlLmhvc3RUcmVlLmRhdGEuZ2V0SXRlbU1vZGVsKG5vZGUuZGF0YUluZGV4KTtcbiAgICAgICAgICB2YXIgbGluayA9IGl0ZW1Nb2RlbC5nZXQoJ2xpbmsnLCB0cnVlKTtcbiAgICAgICAgICB2YXIgbGlua1RhcmdldCA9IGl0ZW1Nb2RlbC5nZXQoJ3RhcmdldCcsIHRydWUpIHx8ICdibGFuayc7XG4gICAgICAgICAgbGluayAmJiB3aW5kb3dPcGVuKGxpbmssIGxpbmtUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIFRyZWVtYXBWaWV3LnByb3RvdHlwZS5fcmVuZGVyQnJlYWRjcnVtYiA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgYXBpLCB0YXJnZXRJbmZvKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoIXRhcmdldEluZm8pIHtcbiAgICAgIHRhcmdldEluZm8gPSBzZXJpZXNNb2RlbC5nZXQoJ2xlYWZEZXB0aCcsIHRydWUpICE9IG51bGwgPyB7XG4gICAgICAgIG5vZGU6IHNlcmllc01vZGVsLmdldFZpZXdSb290KClcbiAgICAgIH1cbiAgICAgIC8vIEZJWE1FXG4gICAgICAvLyBiZXR0ZXIgd2F5P1xuICAgICAgLy8gRmluZCBicmVhZGNydW1iIHRhaWwgb24gY2VudGVyIG9mIGNvbnRhaW5lckdyb3VwLlxuICAgICAgOiB0aGlzLmZpbmRUYXJnZXQoYXBpLmdldFdpZHRoKCkgLyAyLCBhcGkuZ2V0SGVpZ2h0KCkgLyAyKTtcbiAgICAgIGlmICghdGFyZ2V0SW5mbykge1xuICAgICAgICB0YXJnZXRJbmZvID0ge1xuICAgICAgICAgIG5vZGU6IHNlcmllc01vZGVsLmdldERhdGEoKS50cmVlLnJvb3RcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgKHRoaXMuX2JyZWFkY3J1bWIgfHwgKHRoaXMuX2JyZWFkY3J1bWIgPSBuZXcgQnJlYWRjcnVtYih0aGlzLmdyb3VwKSkpLnJlbmRlcihzZXJpZXNNb2RlbCwgYXBpLCB0YXJnZXRJbmZvLm5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoX3RoaXMuX3N0YXRlICE9PSAnYW5pbWF0aW5nJykge1xuICAgICAgICBoZWxwZXIuYWJvdmVWaWV3Um9vdChzZXJpZXNNb2RlbC5nZXRWaWV3Um9vdCgpLCBub2RlKSA/IF90aGlzLl9yb290VG9Ob2RlKHtcbiAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgIH0pIDogX3RoaXMuX3pvb21Ub05vZGUoe1xuICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBUcmVlbWFwVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NsZWFyQ29udHJvbGxlcigpO1xuICAgIHRoaXMuX2NvbnRhaW5lckdyb3VwICYmIHRoaXMuX2NvbnRhaW5lckdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMuX3N0b3JhZ2UgPSBjcmVhdGVTdG9yYWdlKCk7XG4gICAgdGhpcy5fc3RhdGUgPSAncmVhZHknO1xuICAgIHRoaXMuX2JyZWFkY3J1bWIgJiYgdGhpcy5fYnJlYWRjcnVtYi5yZW1vdmUoKTtcbiAgfTtcbiAgVHJlZW1hcFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xlYXJDb250cm9sbGVyKCk7XG4gIH07XG4gIFRyZWVtYXBWaWV3LnByb3RvdHlwZS5fem9vbVRvTm9kZSA9IGZ1bmN0aW9uICh0YXJnZXRJbmZvKSB7XG4gICAgdGhpcy5hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ3RyZWVtYXBab29tVG9Ob2RlJyxcbiAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgc2VyaWVzSWQ6IHRoaXMuc2VyaWVzTW9kZWwuaWQsXG4gICAgICB0YXJnZXROb2RlOiB0YXJnZXRJbmZvLm5vZGVcbiAgICB9KTtcbiAgfTtcbiAgVHJlZW1hcFZpZXcucHJvdG90eXBlLl9yb290VG9Ob2RlID0gZnVuY3Rpb24gKHRhcmdldEluZm8pIHtcbiAgICB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAndHJlZW1hcFJvb3RUb05vZGUnLFxuICAgICAgZnJvbTogdGhpcy51aWQsXG4gICAgICBzZXJpZXNJZDogdGhpcy5zZXJpZXNNb2RlbC5pZCxcbiAgICAgIHRhcmdldE5vZGU6IHRhcmdldEluZm8ubm9kZVxuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggR2xvYmFsIGNvb3JkIHguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgR2xvYmFsIGNvb3JkIHkuXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbmZvIElmIG5vdCBmb3VuZCwgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8ubm9kZSBUYXJnZXQgbm9kZS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8ub2Zmc2V0WCB4IHJlZmVyIHRvIHRhcmdldCBub2RlLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gaW5mby5vZmZzZXRZIHkgcmVmZXIgdG8gdGFyZ2V0IG5vZGUuXHJcbiAgICovXG4gIFRyZWVtYXBWaWV3LnByb3RvdHlwZS5maW5kVGFyZ2V0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgdGFyZ2V0SW5mbztcbiAgICB2YXIgdmlld1Jvb3QgPSB0aGlzLnNlcmllc01vZGVsLmdldFZpZXdSb290KCk7XG4gICAgdmlld1Jvb3QuZWFjaE5vZGUoe1xuICAgICAgYXR0cjogJ3ZpZXdDaGlsZHJlbicsXG4gICAgICBvcmRlcjogJ3ByZW9yZGVyJ1xuICAgIH0sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgYmdFbCA9IHRoaXMuX3N0b3JhZ2UuYmFja2dyb3VuZFtub2RlLmdldFJhd0luZGV4KCldO1xuICAgICAgLy8gSWYgaW52aXNpYmxlLCB0aGVyZSBtaWdodCBiZSBubyBlbGVtZW50LlxuICAgICAgaWYgKGJnRWwpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gYmdFbC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgICAgIHZhciBzaGFwZSA9IGJnRWwuc2hhcGU7XG4gICAgICAgIC8vIEZvciBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9uLCBkb24ndCB1c2UgJ2dldEJvdW5kaW5nUmVjdCcuXG4gICAgICAgIGlmIChzaGFwZS54IDw9IHBvaW50WzBdICYmIHBvaW50WzBdIDw9IHNoYXBlLnggKyBzaGFwZS53aWR0aCAmJiBzaGFwZS55IDw9IHBvaW50WzFdICYmIHBvaW50WzFdIDw9IHNoYXBlLnkgKyBzaGFwZS5oZWlnaHQpIHtcbiAgICAgICAgICB0YXJnZXRJbmZvID0ge1xuICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgIG9mZnNldFg6IHBvaW50WzBdLFxuICAgICAgICAgICAgb2Zmc2V0WTogcG9pbnRbMV1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gU3VwcHJlc3MgdmlzaXQgc3VidHJlZS5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiB0YXJnZXRJbmZvO1xuICB9O1xuICBUcmVlbWFwVmlldy50eXBlID0gJ3RyZWVtYXAnO1xuICByZXR1cm4gVHJlZW1hcFZpZXc7XG59KENoYXJ0Vmlldyk7XG4vKipcclxuICogQGlubmVyXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RvcmFnZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlR3JvdXA6IFtdLFxuICAgIGJhY2tncm91bmQ6IFtdLFxuICAgIGNvbnRlbnQ6IFtdXG4gIH07XG59XG4vKipcclxuICogQGlubmVyXHJcbiAqIEByZXR1cm4gUmV0dXJuIHVuZGVmaW5lZCBtZWFucyBkbyBub3QgdHJhdmVsIGZ1cnRoZXIuXHJcbiAqL1xuZnVuY3Rpb24gcmVuZGVyTm9kZShzZXJpZXNNb2RlbCwgdGhpc1N0b3JhZ2UsIG9sZFN0b3JhZ2UsIHJlUm9vdCwgbGFzdHNGb3JBbmltYXRpb24sIHdpbGxJbnZpc2libGVFbHMsIHRoaXNOb2RlLCBvbGROb2RlLCBwYXJlbnRHcm91cCwgZGVwdGgpIHtcbiAgLy8gV2hldGhlciB1bmRlciB2aWV3Um9vdC5cbiAgaWYgKCF0aGlzTm9kZSkge1xuICAgIC8vIERlbGV0aW5nIG5vZGVzIHdpbGwgYmUgcGVyZm9ybWVkIGZpbmFsbHkuIFRoaXMgbWV0aG9kIGp1c3QgZmluZFxuICAgIC8vIGVsZW1lbnQgZnJvbSBvbGQgc3RvcmFnZSwgb3IgY3JlYXRlIG5ldyBlbGVtZW50LCBzZXQgdGhlbSB0byBuZXdcbiAgICAvLyBzdG9yYWdlLCBhbmQgc2V0IHN0eWxlcy5cbiAgICByZXR1cm47XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBTdGFydCBvZiBjbG9zdXJlIHZhcmlhYmxlcyBhdmFpbGFibGUgaW4gXCJQcm9jZWR1cmVzIGluIHJlbmRlck5vZGVcIi5cbiAgdmFyIHRoaXNMYXlvdXQgPSB0aGlzTm9kZS5nZXRMYXlvdXQoKTtcbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gIHZhciBub2RlTW9kZWwgPSB0aGlzTm9kZS5nZXRNb2RlbCgpO1xuICAvLyBPbmx5IGZvciBlbmFibGluZyBoaWdobGlnaHQvZG93bnBsYXkuIENsZWFyIGZpcnN0bHkuXG4gIC8vIEJlY2F1c2Ugc29tZSBub2RlIHdpbGwgbm90IGJlIHJlbmRlcmVkLlxuICBkYXRhLnNldEl0ZW1HcmFwaGljRWwodGhpc05vZGUuZGF0YUluZGV4LCBudWxsKTtcbiAgaWYgKCF0aGlzTGF5b3V0IHx8ICF0aGlzTGF5b3V0LmlzSW5WaWV3KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0aGlzV2lkdGggPSB0aGlzTGF5b3V0LndpZHRoO1xuICB2YXIgdGhpc0hlaWdodCA9IHRoaXNMYXlvdXQuaGVpZ2h0O1xuICB2YXIgYm9yZGVyV2lkdGggPSB0aGlzTGF5b3V0LmJvcmRlcldpZHRoO1xuICB2YXIgdGhpc0ludmlzaWJsZSA9IHRoaXNMYXlvdXQuaW52aXNpYmxlO1xuICB2YXIgdGhpc1Jhd0luZGV4ID0gdGhpc05vZGUuZ2V0UmF3SW5kZXgoKTtcbiAgdmFyIG9sZFJhd0luZGV4ID0gb2xkTm9kZSAmJiBvbGROb2RlLmdldFJhd0luZGV4KCk7XG4gIHZhciB0aGlzVmlld0NoaWxkcmVuID0gdGhpc05vZGUudmlld0NoaWxkcmVuO1xuICB2YXIgdXBwZXJIZWlnaHQgPSB0aGlzTGF5b3V0LnVwcGVySGVpZ2h0O1xuICB2YXIgaXNQYXJlbnQgPSB0aGlzVmlld0NoaWxkcmVuICYmIHRoaXNWaWV3Q2hpbGRyZW4ubGVuZ3RoO1xuICB2YXIgaXRlbVN0eWxlTm9ybWFsTW9kZWwgPSBub2RlTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZScpO1xuICB2YXIgaXRlbVN0eWxlRW1waGFzaXNNb2RlbCA9IG5vZGVNb2RlbC5nZXRNb2RlbChbJ2VtcGhhc2lzJywgJ2l0ZW1TdHlsZSddKTtcbiAgdmFyIGl0ZW1TdHlsZUJsdXJNb2RlbCA9IG5vZGVNb2RlbC5nZXRNb2RlbChbJ2JsdXInLCAnaXRlbVN0eWxlJ10pO1xuICB2YXIgaXRlbVN0eWxlU2VsZWN0TW9kZWwgPSBub2RlTW9kZWwuZ2V0TW9kZWwoWydzZWxlY3QnLCAnaXRlbVN0eWxlJ10pO1xuICB2YXIgYm9yZGVyUmFkaXVzID0gaXRlbVN0eWxlTm9ybWFsTW9kZWwuZ2V0KCdib3JkZXJSYWRpdXMnKSB8fCAwO1xuICAvLyBFbmQgb2YgY2xvc3VyZSBhcmlhYmxlcyBhdmFpbGFibGUgaW4gXCJQcm9jZWR1cmVzIGluIHJlbmRlck5vZGVcIi5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gTm9kZSBncm91cFxuICB2YXIgZ3JvdXAgPSBnaXZlR3JhcGhpYygnbm9kZUdyb3VwJywgR3JvdXApO1xuICBpZiAoIWdyb3VwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHBhcmVudEdyb3VwLmFkZChncm91cCk7XG4gIC8vIHgseSBhcmUgbm90IHNldCB3aGVuIGVsIGlzIGFib3ZlIHZpZXcgcm9vdC5cbiAgZ3JvdXAueCA9IHRoaXNMYXlvdXQueCB8fCAwO1xuICBncm91cC55ID0gdGhpc0xheW91dC55IHx8IDA7XG4gIGdyb3VwLm1hcmtSZWRyYXcoKTtcbiAgaW5uZXIoZ3JvdXApLm5vZGVXaWR0aCA9IHRoaXNXaWR0aDtcbiAgaW5uZXIoZ3JvdXApLm5vZGVIZWlnaHQgPSB0aGlzSGVpZ2h0O1xuICBpZiAodGhpc0xheW91dC5pc0Fib3ZlVmlld1Jvb3QpIHtcbiAgICByZXR1cm4gZ3JvdXA7XG4gIH1cbiAgLy8gQmFja2dyb3VuZFxuICB2YXIgYmcgPSBnaXZlR3JhcGhpYygnYmFja2dyb3VuZCcsIFJlY3QsIGRlcHRoLCBaMl9CRyk7XG4gIGJnICYmIHJlbmRlckJhY2tncm91bmQoZ3JvdXAsIGJnLCBpc1BhcmVudCAmJiB0aGlzTGF5b3V0LnVwcGVyTGFiZWxIZWlnaHQpO1xuICB2YXIgZW1waGFzaXNNb2RlbCA9IG5vZGVNb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKTtcbiAgdmFyIGZvY3VzID0gZW1waGFzaXNNb2RlbC5nZXQoJ2ZvY3VzJyk7XG4gIHZhciBibHVyU2NvcGUgPSBlbXBoYXNpc01vZGVsLmdldCgnYmx1clNjb3BlJyk7XG4gIHZhciBpc0Rpc2FibGVkID0gZW1waGFzaXNNb2RlbC5nZXQoJ2Rpc2FibGVkJyk7XG4gIHZhciBmb2N1c09ySW5kaWNlcyA9IGZvY3VzID09PSAnYW5jZXN0b3InID8gdGhpc05vZGUuZ2V0QW5jZXN0b3JzSW5kaWNlcygpIDogZm9jdXMgPT09ICdkZXNjZW5kYW50JyA/IHRoaXNOb2RlLmdldERlc2NlbmRhbnRJbmRpY2VzKCkgOiBmb2N1cztcbiAgLy8gTm8gY2hpbGRyZW4sIHJlbmRlciBjb250ZW50LlxuICBpZiAoaXNQYXJlbnQpIHtcbiAgICAvLyBCZWNhdXNlIG9mIHRoZSBpbXBsZW1lbnRhdGlvbiBhYm91dCBcInRyYXZlcnNlXCIgaW4gZ3JhcGhpYyBob3ZlciBzdHlsZSwgd2VcbiAgICAvLyBjYW4gbm90IHNldCBob3ZlciBsaXN0ZW5lciBvbiB0aGUgXCJncm91cFwiIG9mIG5vbi1sZWFmIG5vZGUuIE90aGVyd2lzZSB0aGVcbiAgICAvLyBob3ZlciBldmVudCBmcm9tIHRoZSBkZXNjZW5kZW50cyB3aWxsIGJlIGxpc3RlbmVyZWQuXG4gICAgaWYgKGlzSGlnaERvd25EaXNwYXRjaGVyKGdyb3VwKSkge1xuICAgICAgc2V0QXNIaWdoRG93bkRpc3BhdGNoZXIoZ3JvdXAsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGJnKSB7XG4gICAgICBzZXRBc0hpZ2hEb3duRGlzcGF0Y2hlcihiZywgIWlzRGlzYWJsZWQpO1xuICAgICAgLy8gT25seSBmb3IgZW5hYmxpbmcgaGlnaGxpZ2h0L2Rvd25wbGF5LlxuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKHRoaXNOb2RlLmRhdGFJbmRleCwgYmcpO1xuICAgICAgZW5hYmxlSG92ZXJGb2N1cyhiZywgZm9jdXNPckluZGljZXMsIGJsdXJTY29wZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZW50ID0gZ2l2ZUdyYXBoaWMoJ2NvbnRlbnQnLCBSZWN0LCBkZXB0aCwgWjJfQ09OVEVOVCk7XG4gICAgY29udGVudCAmJiByZW5kZXJDb250ZW50KGdyb3VwLCBjb250ZW50KTtcbiAgICBiZy5kaXNhYmxlTW9ycGhpbmcgPSB0cnVlO1xuICAgIGlmIChiZyAmJiBpc0hpZ2hEb3duRGlzcGF0Y2hlcihiZykpIHtcbiAgICAgIHNldEFzSGlnaERvd25EaXNwYXRjaGVyKGJnLCBmYWxzZSk7XG4gICAgfVxuICAgIHNldEFzSGlnaERvd25EaXNwYXRjaGVyKGdyb3VwLCAhaXNEaXNhYmxlZCk7XG4gICAgLy8gT25seSBmb3IgZW5hYmxpbmcgaGlnaGxpZ2h0L2Rvd25wbGF5LlxuICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbCh0aGlzTm9kZS5kYXRhSW5kZXgsIGdyb3VwKTtcbiAgICB2YXIgY3Vyc29yU3R5bGUgPSBub2RlTW9kZWwuZ2V0U2hhbGxvdygnY3Vyc29yJyk7XG4gICAgY3Vyc29yU3R5bGUgJiYgY29udGVudC5hdHRyKCdjdXJzb3InLCBjdXJzb3JTdHlsZSk7XG4gICAgZW5hYmxlSG92ZXJGb2N1cyhncm91cCwgZm9jdXNPckluZGljZXMsIGJsdXJTY29wZSk7XG4gIH1cbiAgcmV0dXJuIGdyb3VwO1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgUHJvY2VkdXJlcyBpbiByZW5kZXJOb2RlIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiByZW5kZXJCYWNrZ3JvdW5kKGdyb3VwLCBiZywgdXNlVXBwZXJMYWJlbCkge1xuICAgIHZhciBlY0RhdGEgPSBnZXRFQ0RhdGEoYmcpO1xuICAgIC8vIEZvciB0b29sdGlwLlxuICAgIGVjRGF0YS5kYXRhSW5kZXggPSB0aGlzTm9kZS5kYXRhSW5kZXg7XG4gICAgZWNEYXRhLnNlcmllc0luZGV4ID0gc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXg7XG4gICAgYmcuc2V0U2hhcGUoe1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogdGhpc1dpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzSGVpZ2h0LFxuICAgICAgcjogYm9yZGVyUmFkaXVzXG4gICAgfSk7XG4gICAgaWYgKHRoaXNJbnZpc2libGUpIHtcbiAgICAgIC8vIElmIGludmlzaWJsZSwgZG8gbm90IHNldCB2aXN1YWwsIG90aGVyd2lzZSB0aGUgZWxlbWVudCB3aWxsXG4gICAgICAvLyBjaGFuZ2UgaW1tZWRpYXRlbHkgYmVmb3JlIGFuaW1hdGlvbi4gV2UgdGhpbmsgaXQgaXMgT0sgdG9cbiAgICAgIC8vIHJlbWFpbiBpdHMgb3JpZ2luIGNvbG9yIHdoZW4gbW92aW5nIG91dCBvZiB0aGUgdmlldyB3aW5kb3cuXG4gICAgICBwcm9jZXNzSW52aXNpYmxlKGJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmcuaW52aXNpYmxlID0gZmFsc2U7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzTm9kZS5nZXRWaXN1YWwoJ3N0eWxlJyk7XG4gICAgICB2YXIgdmlzdWFsQm9yZGVyQ29sb3IgPSBzdHlsZS5zdHJva2U7XG4gICAgICB2YXIgbm9ybWFsU3R5bGUgPSBnZXRJdGVtU3R5bGVOb3JtYWwoaXRlbVN0eWxlTm9ybWFsTW9kZWwpO1xuICAgICAgbm9ybWFsU3R5bGUuZmlsbCA9IHZpc3VhbEJvcmRlckNvbG9yO1xuICAgICAgdmFyIGVtcGhhc2lzU3R5bGUgPSBnZXRTdGF0ZUl0ZW1TdHlsZShpdGVtU3R5bGVFbXBoYXNpc01vZGVsKTtcbiAgICAgIGVtcGhhc2lzU3R5bGUuZmlsbCA9IGl0ZW1TdHlsZUVtcGhhc2lzTW9kZWwuZ2V0KCdib3JkZXJDb2xvcicpO1xuICAgICAgdmFyIGJsdXJTdHlsZSA9IGdldFN0YXRlSXRlbVN0eWxlKGl0ZW1TdHlsZUJsdXJNb2RlbCk7XG4gICAgICBibHVyU3R5bGUuZmlsbCA9IGl0ZW1TdHlsZUJsdXJNb2RlbC5nZXQoJ2JvcmRlckNvbG9yJyk7XG4gICAgICB2YXIgc2VsZWN0U3R5bGUgPSBnZXRTdGF0ZUl0ZW1TdHlsZShpdGVtU3R5bGVTZWxlY3RNb2RlbCk7XG4gICAgICBzZWxlY3RTdHlsZS5maWxsID0gaXRlbVN0eWxlU2VsZWN0TW9kZWwuZ2V0KCdib3JkZXJDb2xvcicpO1xuICAgICAgaWYgKHVzZVVwcGVyTGFiZWwpIHtcbiAgICAgICAgdmFyIHVwcGVyTGFiZWxXaWR0aCA9IHRoaXNXaWR0aCAtIDIgKiBib3JkZXJXaWR0aDtcbiAgICAgICAgcHJlcGFyZVRleHQoXG4gICAgICAgIC8vIFBFTkRJTkc6IGNvbnZlcnQgWlJDb2xvciB0byBDb2xvclN0cmluZyBmb3IgdGV4dC5cbiAgICAgICAgYmcsIHZpc3VhbEJvcmRlckNvbG9yLCBzdHlsZS5vcGFjaXR5LCB7XG4gICAgICAgICAgeDogYm9yZGVyV2lkdGgsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogdXBwZXJMYWJlbFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogdXBwZXJIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBGb3Igb2xkIGJnLlxuICAgICAgZWxzZSB7XG4gICAgICAgIGJnLnJlbW92ZVRleHRDb250ZW50KCk7XG4gICAgICB9XG4gICAgICBiZy5zZXRTdHlsZShub3JtYWxTdHlsZSk7XG4gICAgICBiZy5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKS5zdHlsZSA9IGVtcGhhc2lzU3R5bGU7XG4gICAgICBiZy5lbnN1cmVTdGF0ZSgnYmx1cicpLnN0eWxlID0gYmx1clN0eWxlO1xuICAgICAgYmcuZW5zdXJlU3RhdGUoJ3NlbGVjdCcpLnN0eWxlID0gc2VsZWN0U3R5bGU7XG4gICAgICBzZXREZWZhdWx0U3RhdGVQcm94eShiZyk7XG4gICAgfVxuICAgIGdyb3VwLmFkZChiZyk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyQ29udGVudChncm91cCwgY29udGVudCkge1xuICAgIHZhciBlY0RhdGEgPSBnZXRFQ0RhdGEoY29udGVudCk7XG4gICAgLy8gRm9yIHRvb2x0aXAuXG4gICAgZWNEYXRhLmRhdGFJbmRleCA9IHRoaXNOb2RlLmRhdGFJbmRleDtcbiAgICBlY0RhdGEuc2VyaWVzSW5kZXggPSBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleDtcbiAgICB2YXIgY29udGVudFdpZHRoID0gTWF0aC5tYXgodGhpc1dpZHRoIC0gMiAqIGJvcmRlcldpZHRoLCAwKTtcbiAgICB2YXIgY29udGVudEhlaWdodCA9IE1hdGgubWF4KHRoaXNIZWlnaHQgLSAyICogYm9yZGVyV2lkdGgsIDApO1xuICAgIGNvbnRlbnQuY3VsbGluZyA9IHRydWU7XG4gICAgY29udGVudC5zZXRTaGFwZSh7XG4gICAgICB4OiBib3JkZXJXaWR0aCxcbiAgICAgIHk6IGJvcmRlcldpZHRoLFxuICAgICAgd2lkdGg6IGNvbnRlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogY29udGVudEhlaWdodCxcbiAgICAgIHI6IGJvcmRlclJhZGl1c1xuICAgIH0pO1xuICAgIGlmICh0aGlzSW52aXNpYmxlKSB7XG4gICAgICAvLyBJZiBpbnZpc2libGUsIGRvIG5vdCBzZXQgdmlzdWFsLCBvdGhlcndpc2UgdGhlIGVsZW1lbnQgd2lsbFxuICAgICAgLy8gY2hhbmdlIGltbWVkaWF0ZWx5IGJlZm9yZSBhbmltYXRpb24uIFdlIHRoaW5rIGl0IGlzIE9LIHRvXG4gICAgICAvLyByZW1haW4gaXRzIG9yaWdpbiBjb2xvciB3aGVuIG1vdmluZyBvdXQgb2YgdGhlIHZpZXcgd2luZG93LlxuICAgICAgcHJvY2Vzc0ludmlzaWJsZShjb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudC5pbnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHZhciBub2RlU3R5bGUgPSB0aGlzTm9kZS5nZXRWaXN1YWwoJ3N0eWxlJyk7XG4gICAgICB2YXIgdmlzdWFsQ29sb3IgPSBub2RlU3R5bGUuZmlsbDtcbiAgICAgIHZhciBub3JtYWxTdHlsZSA9IGdldEl0ZW1TdHlsZU5vcm1hbChpdGVtU3R5bGVOb3JtYWxNb2RlbCk7XG4gICAgICBub3JtYWxTdHlsZS5maWxsID0gdmlzdWFsQ29sb3I7XG4gICAgICBub3JtYWxTdHlsZS5kZWNhbCA9IG5vZGVTdHlsZS5kZWNhbDtcbiAgICAgIHZhciBlbXBoYXNpc1N0eWxlID0gZ2V0U3RhdGVJdGVtU3R5bGUoaXRlbVN0eWxlRW1waGFzaXNNb2RlbCk7XG4gICAgICB2YXIgYmx1clN0eWxlID0gZ2V0U3RhdGVJdGVtU3R5bGUoaXRlbVN0eWxlQmx1ck1vZGVsKTtcbiAgICAgIHZhciBzZWxlY3RTdHlsZSA9IGdldFN0YXRlSXRlbVN0eWxlKGl0ZW1TdHlsZVNlbGVjdE1vZGVsKTtcbiAgICAgIC8vIFBFTkRJTkc6IGNvbnZlcnQgWlJDb2xvciB0byBDb2xvclN0cmluZyBmb3IgdGV4dC5cbiAgICAgIHByZXBhcmVUZXh0KGNvbnRlbnQsIHZpc3VhbENvbG9yLCBub2RlU3R5bGUub3BhY2l0eSwgbnVsbCk7XG4gICAgICBjb250ZW50LnNldFN0eWxlKG5vcm1hbFN0eWxlKTtcbiAgICAgIGNvbnRlbnQuZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJykuc3R5bGUgPSBlbXBoYXNpc1N0eWxlO1xuICAgICAgY29udGVudC5lbnN1cmVTdGF0ZSgnYmx1cicpLnN0eWxlID0gYmx1clN0eWxlO1xuICAgICAgY29udGVudC5lbnN1cmVTdGF0ZSgnc2VsZWN0Jykuc3R5bGUgPSBzZWxlY3RTdHlsZTtcbiAgICAgIHNldERlZmF1bHRTdGF0ZVByb3h5KGNvbnRlbnQpO1xuICAgIH1cbiAgICBncm91cC5hZGQoY29udGVudCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0ludmlzaWJsZShlbGVtZW50KSB7XG4gICAgLy8gRGVsYXkgaW52aXNpYmxlIHNldHRpbmcgdXRpbGwgYW5pbWF0aW9uIGZpbmlzaGVkLFxuICAgIC8vIGF2b2lkIGVsZW1lbnQgdmFuaXNoIHN1ZGRlbmx5IGJlZm9yZSBhbmltYXRpb24uXG4gICAgIWVsZW1lbnQuaW52aXNpYmxlICYmIHdpbGxJbnZpc2libGVFbHMucHVzaChlbGVtZW50KTtcbiAgfVxuICBmdW5jdGlvbiBwcmVwYXJlVGV4dChyZWN0RWwsIHZpc3VhbENvbG9yLCB2aXN1YWxPcGFjaXR5LFxuICAvLyBDYW4gYmUgbnVsbC91bmRlZmluZWRcbiAgdXBwZXJMYWJlbFJlY3QpIHtcbiAgICB2YXIgbm9ybWFsTGFiZWxNb2RlbCA9IG5vZGVNb2RlbC5nZXRNb2RlbCh1cHBlckxhYmVsUmVjdCA/IFBBVEhfVVBQRVJMQUJFTF9OT1JNQUwgOiBQQVRIX0xBQkVMX05PQU1BTCk7XG4gICAgdmFyIGRlZmF1bHRUZXh0ID0gY29udmVydE9wdGlvbklkTmFtZShub2RlTW9kZWwuZ2V0KCduYW1lJyksIG51bGwpO1xuICAgIHZhciBpc1Nob3cgPSBub3JtYWxMYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKTtcbiAgICBzZXRMYWJlbFN0eWxlKHJlY3RFbCwgZ2V0TGFiZWxTdGF0ZXNNb2RlbHMobm9kZU1vZGVsLCB1cHBlckxhYmVsUmVjdCA/IFBBVEhfVVBQRVJMQUJFTF9OT1JNQUwgOiBQQVRIX0xBQkVMX05PQU1BTCksIHtcbiAgICAgIGRlZmF1bHRUZXh0OiBpc1Nob3cgPyBkZWZhdWx0VGV4dCA6IG51bGwsXG4gICAgICBpbmhlcml0Q29sb3I6IHZpc3VhbENvbG9yLFxuICAgICAgZGVmYXVsdE9wYWNpdHk6IHZpc3VhbE9wYWNpdHksXG4gICAgICBsYWJlbEZldGNoZXI6IHNlcmllc01vZGVsLFxuICAgICAgbGFiZWxEYXRhSW5kZXg6IHRoaXNOb2RlLmRhdGFJbmRleFxuICAgIH0pO1xuICAgIHZhciB0ZXh0RWwgPSByZWN0RWwuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBpZiAoIXRleHRFbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGV4dFN0eWxlID0gdGV4dEVsLnN0eWxlO1xuICAgIHZhciB0ZXh0UGFkZGluZyA9IG5vcm1hbGl6ZUNzc0FycmF5KHRleHRTdHlsZS5wYWRkaW5nIHx8IDApO1xuICAgIGlmICh1cHBlckxhYmVsUmVjdCkge1xuICAgICAgcmVjdEVsLnNldFRleHRDb25maWcoe1xuICAgICAgICBsYXlvdXRSZWN0OiB1cHBlckxhYmVsUmVjdFxuICAgICAgfSk7XG4gICAgICB0ZXh0RWwuZGlzYWJsZUxhYmVsTGF5b3V0ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGV4dEVsLmJlZm9yZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KCh1cHBlckxhYmVsUmVjdCA/IHVwcGVyTGFiZWxSZWN0LndpZHRoIDogcmVjdEVsLnNoYXBlLndpZHRoKSAtIHRleHRQYWRkaW5nWzFdIC0gdGV4dFBhZGRpbmdbM10sIDApO1xuICAgICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KCh1cHBlckxhYmVsUmVjdCA/IHVwcGVyTGFiZWxSZWN0LmhlaWdodCA6IHJlY3RFbC5zaGFwZS5oZWlnaHQpIC0gdGV4dFBhZGRpbmdbMF0gLSB0ZXh0UGFkZGluZ1syXSwgMCk7XG4gICAgICBpZiAodGV4dFN0eWxlLndpZHRoICE9PSB3aWR0aCB8fCB0ZXh0U3R5bGUuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgdGV4dEVsLnNldFN0eWxlKHtcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0ZXh0U3R5bGUudHJ1bmNhdGVNaW5DaGFyID0gMjtcbiAgICB0ZXh0U3R5bGUubGluZU92ZXJmbG93ID0gJ3RydW5jYXRlJztcbiAgICBhZGREcmlsbERvd25JY29uKHRleHRTdHlsZSwgdXBwZXJMYWJlbFJlY3QsIHRoaXNMYXlvdXQpO1xuICAgIHZhciB0ZXh0RW1waGFzaXNTdGF0ZSA9IHRleHRFbC5nZXRTdGF0ZSgnZW1waGFzaXMnKTtcbiAgICBhZGREcmlsbERvd25JY29uKHRleHRFbXBoYXNpc1N0YXRlID8gdGV4dEVtcGhhc2lzU3RhdGUuc3R5bGUgOiBudWxsLCB1cHBlckxhYmVsUmVjdCwgdGhpc0xheW91dCk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkRHJpbGxEb3duSWNvbihzdHlsZSwgdXBwZXJMYWJlbFJlY3QsIHRoaXNMYXlvdXQpIHtcbiAgICB2YXIgdGV4dCA9IHN0eWxlID8gc3R5bGUudGV4dCA6IG51bGw7XG4gICAgaWYgKCF1cHBlckxhYmVsUmVjdCAmJiB0aGlzTGF5b3V0LmlzTGVhZlJvb3QgJiYgdGV4dCAhPSBudWxsKSB7XG4gICAgICB2YXIgaWNvbkNoYXIgPSBzZXJpZXNNb2RlbC5nZXQoJ2RyaWxsRG93bkljb24nLCB0cnVlKTtcbiAgICAgIHN0eWxlLnRleHQgPSBpY29uQ2hhciA/IGljb25DaGFyICsgJyAnICsgdGV4dCA6IHRleHQ7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdpdmVHcmFwaGljKHN0b3JhZ2VOYW1lLCBDdG9yLCBkZXB0aCwgeikge1xuICAgIHZhciBlbGVtZW50ID0gb2xkUmF3SW5kZXggIT0gbnVsbCAmJiBvbGRTdG9yYWdlW3N0b3JhZ2VOYW1lXVtvbGRSYXdJbmRleF07XG4gICAgdmFyIGxhc3RzID0gbGFzdHNGb3JBbmltYXRpb25bc3RvcmFnZU5hbWVdO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAvLyBSZW1vdmUgZnJvbSBvbGRTdG9yYWdlXG4gICAgICBvbGRTdG9yYWdlW3N0b3JhZ2VOYW1lXVtvbGRSYXdJbmRleF0gPSBudWxsO1xuICAgICAgcHJlcGFyZUFuaW1hdGlvbldoZW5IYXNPbGQobGFzdHMsIGVsZW1lbnQpO1xuICAgIH1cbiAgICAvLyBJZiBpbnZpc2libGUgYW5kIG5vIG9sZCBlbGVtZW50LCBkbyBub3QgY3JlYXRlIG5ldyBlbGVtZW50IChmb3Igb3B0aW1pemluZykuXG4gICAgZWxzZSBpZiAoIXRoaXNJbnZpc2libGUpIHtcbiAgICAgIGVsZW1lbnQgPSBuZXcgQ3RvcigpO1xuICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBEaXNwbGF5YWJsZSkge1xuICAgICAgICBlbGVtZW50LnoyID0gY2FsY3VsYXRlWjIoZGVwdGgsIHopO1xuICAgICAgfVxuICAgICAgcHJlcGFyZUFuaW1hdGlvbldoZW5Ob09sZChsYXN0cywgZWxlbWVudCk7XG4gICAgfVxuICAgIC8vIFNldCB0byB0aGlzU3RvcmFnZVxuICAgIHJldHVybiB0aGlzU3RvcmFnZVtzdG9yYWdlTmFtZV1bdGhpc1Jhd0luZGV4XSA9IGVsZW1lbnQ7XG4gIH1cbiAgZnVuY3Rpb24gcHJlcGFyZUFuaW1hdGlvbldoZW5IYXNPbGQobGFzdHMsIGVsZW1lbnQpIHtcbiAgICB2YXIgbGFzdENmZyA9IGxhc3RzW3RoaXNSYXdJbmRleF0gPSB7fTtcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICBsYXN0Q2ZnLm9sZFggPSBlbGVtZW50Lng7XG4gICAgICBsYXN0Q2ZnLm9sZFkgPSBlbGVtZW50Lnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RDZmcub2xkU2hhcGUgPSBleHRlbmQoe30sIGVsZW1lbnQuc2hhcGUpO1xuICAgIH1cbiAgfVxuICAvLyBJZiBhIGVsZW1lbnQgaXMgbmV3LCB3ZSBuZWVkIHRvIGZpbmQgdGhlIGFuaW1hdGlvbiBzdGFydCBwb2ludCBjYXJlZnVsbHksXG4gIC8vIG90aGVyd2lzZSBpdCB3aWxsIGxvb2tzIHN0cmFuZ2Ugd2hlbiAnem9vbVRvTm9kZScuXG4gIGZ1bmN0aW9uIHByZXBhcmVBbmltYXRpb25XaGVuTm9PbGQobGFzdHMsIGVsZW1lbnQpIHtcbiAgICB2YXIgbGFzdENmZyA9IGxhc3RzW3RoaXNSYXdJbmRleF0gPSB7fTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXNOb2RlLnBhcmVudE5vZGU7XG4gICAgdmFyIGlzR3JvdXAgPSBlbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhpYy5Hcm91cDtcbiAgICBpZiAocGFyZW50Tm9kZSAmJiAoIXJlUm9vdCB8fCByZVJvb3QuZGlyZWN0aW9uID09PSAnZHJpbGxEb3duJykpIHtcbiAgICAgIHZhciBwYXJlbnRPbGRYID0gMDtcbiAgICAgIHZhciBwYXJlbnRPbGRZID0gMDtcbiAgICAgIC8vIE5ldyBub2RlcyBhcHBlYXIgZnJvbSByaWdodC1ib3R0b20gY29ybmVyIGluICd6b29tVG9Ob2RlJyBhbmltYXRpb24uXG4gICAgICAvLyBGb3IgY29udmVuaWVuY2UsIGdldCBvbGQgYm91bmRpbmcgcmVjdCBmcm9tIGJhY2tncm91bmQuXG4gICAgICB2YXIgcGFyZW50T2xkQmcgPSBsYXN0c0ZvckFuaW1hdGlvbi5iYWNrZ3JvdW5kW3BhcmVudE5vZGUuZ2V0UmF3SW5kZXgoKV07XG4gICAgICBpZiAoIXJlUm9vdCAmJiBwYXJlbnRPbGRCZyAmJiBwYXJlbnRPbGRCZy5vbGRTaGFwZSkge1xuICAgICAgICBwYXJlbnRPbGRYID0gcGFyZW50T2xkQmcub2xkU2hhcGUud2lkdGg7XG4gICAgICAgIHBhcmVudE9sZFkgPSBwYXJlbnRPbGRCZy5vbGRTaGFwZS5oZWlnaHQ7XG4gICAgICB9XG4gICAgICAvLyBXaGVuIG5vIHBhcmVudCBvbGQgc2hhcGUgZm91bmQsIGl0cyBwYXJlbnQgaXMgbmV3IHRvbyxcbiAgICAgIC8vIHNvIHdlIGNhbiBqdXN0IHVzZSB7eDowLCB5OjB9LlxuICAgICAgaWYgKGlzR3JvdXApIHtcbiAgICAgICAgbGFzdENmZy5vbGRYID0gMDtcbiAgICAgICAgbGFzdENmZy5vbGRZID0gcGFyZW50T2xkWTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RDZmcub2xkU2hhcGUgPSB7XG4gICAgICAgICAgeDogcGFyZW50T2xkWCxcbiAgICAgICAgICB5OiBwYXJlbnRPbGRZLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBGYWRlIGluLCB1c2VyIGNhbiBiZSBhd2FyZSB0aGF0IHRoZXNlIG5vZGVzIGFyZSBuZXcuXG4gICAgbGFzdENmZy5mYWRlaW4gPSAhaXNHcm91cDtcbiAgfVxufVxuLy8gV2UgY2Fubm90IHNldCBhbGwgYmFja2dyb3VuZCB3aXRoIHRoZSBzYW1lIHosIGJlY2F1c2UgdGhlIGJlaGF2aW91ciBvZlxuLy8gZHJpbGwgZG93biBhbmQgcm9sbCB1cCBkaWZmZXIgYmFja2dyb3VuZCBjcmVhdGlvbiBzZXF1ZW5jZSBmcm9tIHRyZWVcbi8vIGhpZXJhcmNoeSBzZXF1ZW5jZSwgd2hpY2ggY2F1c2UgbG93ZXIgYmFja2dyb3VuZCBlbGVtZW50cyB0byBvdmVybGFwXG4vLyB1cHBlciBvbmVzLiBTbyB3ZSBjYWxjdWxhdGUgeiBiYXNlZCBvbiBkZXB0aC5cbi8vIE1vcmVvdmVyLCB3ZSB0cnkgdG8gc2hyaW5rIGRvd24geiBpbnRlcnZhbCB0byBbMCwgMV0gdG8gYXZvaWQgdGhhdFxuLy8gdHJlZW1hcCB3aXRoIGxhcmdlIHogb3ZlcmxhcHMgb3RoZXIgY29tcG9uZW50cy5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVoyKGRlcHRoLCB6MkluTGV2ZWwpIHtcbiAgcmV0dXJuIGRlcHRoICogWjJfQkFTRSArIHoySW5MZXZlbDtcbn1cbmV4cG9ydCBkZWZhdWx0IFRyZWVtYXBWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IFZpc3VhbE1hcHBpbmcgZnJvbSAnLi4vLi4vdmlzdWFsL1Zpc3VhbE1hcHBpbmcuanMnO1xuaW1wb3J0IHsgZWFjaCwgZXh0ZW5kLCBpc0FycmF5IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IG1vZGlmeUhTTCwgbW9kaWZ5QWxwaGEgfSBmcm9tICd6cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzJztcbmltcG9ydCB7IG1ha2VJbm5lciB9IGZyb20gJy4uLy4uL3V0aWwvbW9kZWwuanMnO1xudmFyIElURU1fU1RZTEVfTk9STUFMID0gJ2l0ZW1TdHlsZSc7XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2VyaWVzVHlwZTogJ3RyZWVtYXAnLFxuICByZXNldDogZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIHRyZWUgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCkudHJlZTtcbiAgICB2YXIgcm9vdCA9IHRyZWUucm9vdDtcbiAgICBpZiAocm9vdC5pc1JlbW92ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cmF2ZWxUcmVlKHJvb3QsXG4gICAgLy8gVmlzdWFsIHNob3VsZCBjYWxjdWxhdGUgZnJvbSB0cmVlIHJvb3QgYnV0IG5vdCB2aWV3IHJvb3QuXG4gICAge30sIHNlcmllc01vZGVsLmdldFZpZXdSb290KCkuZ2V0QW5jZXN0b3JzKCksIHNlcmllc01vZGVsKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHRyYXZlbFRyZWUobm9kZSwgZGVzaWduYXRlZFZpc3VhbCwgdmlld1Jvb3RBbmNlc3RvcnMsIHNlcmllc01vZGVsKSB7XG4gIHZhciBub2RlTW9kZWwgPSBub2RlLmdldE1vZGVsKCk7XG4gIHZhciBub2RlTGF5b3V0ID0gbm9kZS5nZXRMYXlvdXQoKTtcbiAgdmFyIGRhdGEgPSBub2RlLmhvc3RUcmVlLmRhdGE7XG4gIC8vIE9wdGltaXplXG4gIGlmICghbm9kZUxheW91dCB8fCBub2RlTGF5b3V0LmludmlzaWJsZSB8fCAhbm9kZUxheW91dC5pc0luVmlldykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbm9kZUl0ZW1TdHlsZU1vZGVsID0gbm9kZU1vZGVsLmdldE1vZGVsKElURU1fU1RZTEVfTk9STUFMKTtcbiAgdmFyIHZpc3VhbHMgPSBidWlsZFZpc3VhbHMobm9kZUl0ZW1TdHlsZU1vZGVsLCBkZXNpZ25hdGVkVmlzdWFsLCBzZXJpZXNNb2RlbCk7XG4gIHZhciBleGlzdHNTdHlsZSA9IGRhdGEuZW5zdXJlVW5pcXVlSXRlbVZpc3VhbChub2RlLmRhdGFJbmRleCwgJ3N0eWxlJyk7XG4gIC8vIGNhbGN1bGF0ZSBib3JkZXIgY29sb3JcbiAgdmFyIGJvcmRlckNvbG9yID0gbm9kZUl0ZW1TdHlsZU1vZGVsLmdldCgnYm9yZGVyQ29sb3InKTtcbiAgdmFyIGJvcmRlckNvbG9yU2F0dXJhdGlvbiA9IG5vZGVJdGVtU3R5bGVNb2RlbC5nZXQoJ2JvcmRlckNvbG9yU2F0dXJhdGlvbicpO1xuICB2YXIgdGhpc05vZGVDb2xvcjtcbiAgaWYgKGJvcmRlckNvbG9yU2F0dXJhdGlvbiAhPSBudWxsKSB7XG4gICAgLy8gRm9yIHBlcmZvcm1hbmNlLCBkbyBub3QgYWx3YXlzIGV4ZWN1dGUgJ2NhbGN1bGF0ZUNvbG9yJy5cbiAgICB0aGlzTm9kZUNvbG9yID0gY2FsY3VsYXRlQ29sb3IodmlzdWFscyk7XG4gICAgYm9yZGVyQ29sb3IgPSBjYWxjdWxhdGVCb3JkZXJDb2xvcihib3JkZXJDb2xvclNhdHVyYXRpb24sIHRoaXNOb2RlQ29sb3IpO1xuICB9XG4gIGV4aXN0c1N0eWxlLnN0cm9rZSA9IGJvcmRlckNvbG9yO1xuICB2YXIgdmlld0NoaWxkcmVuID0gbm9kZS52aWV3Q2hpbGRyZW47XG4gIGlmICghdmlld0NoaWxkcmVuIHx8ICF2aWV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdGhpc05vZGVDb2xvciA9IGNhbGN1bGF0ZUNvbG9yKHZpc3VhbHMpO1xuICAgIC8vIEFwcGx5IHZpc3VhbCB0byB0aGlzIG5vZGUuXG4gICAgZXhpc3RzU3R5bGUuZmlsbCA9IHRoaXNOb2RlQ29sb3I7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1hcHBpbmdfMSA9IGJ1aWxkVmlzdWFsTWFwcGluZyhub2RlLCBub2RlTW9kZWwsIG5vZGVMYXlvdXQsIG5vZGVJdGVtU3R5bGVNb2RlbCwgdmlzdWFscywgdmlld0NoaWxkcmVuKTtcbiAgICAvLyBEZXNpZ25hdGUgdmlzdWFsIHRvIGNoaWxkcmVuLlxuICAgIGVhY2godmlld0NoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAvLyBJZiBoaWdoZXIgdGhhbiB2aWV3Um9vdCwgb25seSBhbmNlc3RvcnMgb2Ygdmlld1Jvb3QgaXMgbmVlZGVkIHRvIHZpc2l0LlxuICAgICAgaWYgKGNoaWxkLmRlcHRoID49IHZpZXdSb290QW5jZXN0b3JzLmxlbmd0aCB8fCBjaGlsZCA9PT0gdmlld1Jvb3RBbmNlc3RvcnNbY2hpbGQuZGVwdGhdKSB7XG4gICAgICAgIHZhciBjaGlsZFZpc3VhbCA9IG1hcFZpc3VhbChub2RlTW9kZWwsIHZpc3VhbHMsIGNoaWxkLCBpbmRleCwgbWFwcGluZ18xLCBzZXJpZXNNb2RlbCk7XG4gICAgICAgIHRyYXZlbFRyZWUoY2hpbGQsIGNoaWxkVmlzdWFsLCB2aWV3Um9vdEFuY2VzdG9ycywgc2VyaWVzTW9kZWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBidWlsZFZpc3VhbHMobm9kZUl0ZW1TdHlsZU1vZGVsLCBkZXNpZ25hdGVkVmlzdWFsLCBzZXJpZXNNb2RlbCkge1xuICB2YXIgdmlzdWFscyA9IGV4dGVuZCh7fSwgZGVzaWduYXRlZFZpc3VhbCk7XG4gIHZhciBkZXNpZ25hdGVkVmlzdWFsSXRlbVN0eWxlID0gc2VyaWVzTW9kZWwuZGVzaWduYXRlZFZpc3VhbEl0ZW1TdHlsZTtcbiAgZWFjaChbJ2NvbG9yJywgJ2NvbG9yQWxwaGEnLCAnY29sb3JTYXR1cmF0aW9uJ10sIGZ1bmN0aW9uICh2aXN1YWxOYW1lKSB7XG4gICAgLy8gUHJpb3JpdHk6IHRoaXNOb2RlID4gdGhpc0xldmVsID4gcGFyZW50Tm9kZURlc2lnbmF0ZWQgPiBzZXJpZXNNb2RlbFxuICAgIGRlc2lnbmF0ZWRWaXN1YWxJdGVtU3R5bGVbdmlzdWFsTmFtZV0gPSBkZXNpZ25hdGVkVmlzdWFsW3Zpc3VhbE5hbWVdO1xuICAgIHZhciB2YWwgPSBub2RlSXRlbVN0eWxlTW9kZWwuZ2V0KHZpc3VhbE5hbWUpO1xuICAgIGRlc2lnbmF0ZWRWaXN1YWxJdGVtU3R5bGVbdmlzdWFsTmFtZV0gPSBudWxsO1xuICAgIHZhbCAhPSBudWxsICYmICh2aXN1YWxzW3Zpc3VhbE5hbWVdID0gdmFsKTtcbiAgfSk7XG4gIHJldHVybiB2aXN1YWxzO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ29sb3IodmlzdWFscykge1xuICB2YXIgY29sb3IgPSBnZXRWYWx1ZVZpc3VhbERlZmluZSh2aXN1YWxzLCAnY29sb3InKTtcbiAgaWYgKGNvbG9yKSB7XG4gICAgdmFyIGNvbG9yQWxwaGEgPSBnZXRWYWx1ZVZpc3VhbERlZmluZSh2aXN1YWxzLCAnY29sb3JBbHBoYScpO1xuICAgIHZhciBjb2xvclNhdHVyYXRpb24gPSBnZXRWYWx1ZVZpc3VhbERlZmluZSh2aXN1YWxzLCAnY29sb3JTYXR1cmF0aW9uJyk7XG4gICAgaWYgKGNvbG9yU2F0dXJhdGlvbikge1xuICAgICAgY29sb3IgPSBtb2RpZnlIU0woY29sb3IsIG51bGwsIG51bGwsIGNvbG9yU2F0dXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChjb2xvckFscGhhKSB7XG4gICAgICBjb2xvciA9IG1vZGlmeUFscGhhKGNvbG9yLCBjb2xvckFscGhhKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVCb3JkZXJDb2xvcihib3JkZXJDb2xvclNhdHVyYXRpb24sIHRoaXNOb2RlQ29sb3IpIHtcbiAgcmV0dXJuIHRoaXNOb2RlQ29sb3IgIT0gbnVsbFxuICAvLyBDYW4gb25seSBiZSBzdHJpbmdcbiAgPyBtb2RpZnlIU0wodGhpc05vZGVDb2xvciwgbnVsbCwgbnVsbCwgYm9yZGVyQ29sb3JTYXR1cmF0aW9uKSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZVZpc3VhbERlZmluZSh2aXN1YWxzLCBuYW1lKSB7XG4gIHZhciB2YWx1ZSA9IHZpc3VhbHNbbmFtZV07XG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnbm9uZScpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkVmlzdWFsTWFwcGluZyhub2RlLCBub2RlTW9kZWwsIG5vZGVMYXlvdXQsIG5vZGVJdGVtU3R5bGVNb2RlbCwgdmlzdWFscywgdmlld0NoaWxkcmVuKSB7XG4gIGlmICghdmlld0NoaWxkcmVuIHx8ICF2aWV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByYW5nZVZpc3VhbCA9IGdldFJhbmdlVmlzdWFsKG5vZGVNb2RlbCwgJ2NvbG9yJykgfHwgdmlzdWFscy5jb2xvciAhPSBudWxsICYmIHZpc3VhbHMuY29sb3IgIT09ICdub25lJyAmJiAoZ2V0UmFuZ2VWaXN1YWwobm9kZU1vZGVsLCAnY29sb3JBbHBoYScpIHx8IGdldFJhbmdlVmlzdWFsKG5vZGVNb2RlbCwgJ2NvbG9yU2F0dXJhdGlvbicpKTtcbiAgaWYgKCFyYW5nZVZpc3VhbCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdmlzdWFsTWluID0gbm9kZU1vZGVsLmdldCgndmlzdWFsTWluJyk7XG4gIHZhciB2aXN1YWxNYXggPSBub2RlTW9kZWwuZ2V0KCd2aXN1YWxNYXgnKTtcbiAgdmFyIGRhdGFFeHRlbnQgPSBub2RlTGF5b3V0LmRhdGFFeHRlbnQuc2xpY2UoKTtcbiAgdmlzdWFsTWluICE9IG51bGwgJiYgdmlzdWFsTWluIDwgZGF0YUV4dGVudFswXSAmJiAoZGF0YUV4dGVudFswXSA9IHZpc3VhbE1pbik7XG4gIHZpc3VhbE1heCAhPSBudWxsICYmIHZpc3VhbE1heCA+IGRhdGFFeHRlbnRbMV0gJiYgKGRhdGFFeHRlbnRbMV0gPSB2aXN1YWxNYXgpO1xuICB2YXIgY29sb3JNYXBwaW5nQnkgPSBub2RlTW9kZWwuZ2V0KCdjb2xvck1hcHBpbmdCeScpO1xuICB2YXIgb3B0ID0ge1xuICAgIHR5cGU6IHJhbmdlVmlzdWFsLm5hbWUsXG4gICAgZGF0YUV4dGVudDogZGF0YUV4dGVudCxcbiAgICB2aXN1YWw6IHJhbmdlVmlzdWFsLnJhbmdlXG4gIH07XG4gIGlmIChvcHQudHlwZSA9PT0gJ2NvbG9yJyAmJiAoY29sb3JNYXBwaW5nQnkgPT09ICdpbmRleCcgfHwgY29sb3JNYXBwaW5nQnkgPT09ICdpZCcpKSB7XG4gICAgb3B0Lm1hcHBpbmdNZXRob2QgPSAnY2F0ZWdvcnknO1xuICAgIG9wdC5sb29wID0gdHJ1ZTtcbiAgICAvLyBjYXRlZ29yaWVzIGlzIG9yZGluYWwsIHNvIGRvIG5vdCBzZXQgb3B0LmNhdGVnb3JpZXMuXG4gIH0gZWxzZSB7XG4gICAgb3B0Lm1hcHBpbmdNZXRob2QgPSAnbGluZWFyJztcbiAgfVxuICB2YXIgbWFwcGluZyA9IG5ldyBWaXN1YWxNYXBwaW5nKG9wdCk7XG4gIGlubmVyKG1hcHBpbmcpLmRyQ29sb3JNYXBwaW5nQnkgPSBjb2xvck1hcHBpbmdCeTtcbiAgcmV0dXJuIG1hcHBpbmc7XG59XG4vLyBOb3RpY2U6IElmIHdlIGRvbid0IGhhdmUgdGhlIGF0dHJpYnV0ZSAnY29sb3JSYW5nZScsIGJ1dCBvbmx5IHVzZVxuLy8gYXR0cmlidXRlICdjb2xvcicgdG8gcmVwcmVzZW50IGJvdGggY29uY2VwdHMgb2YgJ2NvbG9yUmFuZ2UnIGFuZCAnY29sb3InLFxuLy8gKEl0IG1lYW5zICdjb2xvclJhbmdlJyB3aGVuICdjb2xvcicgaXMgQXJyYXksIG1lYW5zICdjb2xvcicgd2hlbiBub3QgYXJyYXkpLFxuLy8gdGhpcyBwcm9ibGVtIHdpbGwgYmUgZW5jb3VudGVyZWQ6XG4vLyBJZiBhIGxldmVsLTEgbm9kZSBkb2Vzbid0IGhhdmUgY2hpbGRyZW4sIGFuZCBpdHMgc2libGluZ3MgaGF2ZSBjaGlsZHJlbixcbi8vIGFuZCBjb2xvclJhbmdlIGlzIHNldCBvbiBsZXZlbC0xLCB0aGVuIHRoZSBub2RlIGNhbm5vdCBiZSBjb2xvcmVkLlxuLy8gU28gd2Ugc2VwYXJhdGUgJ2NvbG9yUmFuZ2UnIGFuZCAnY29sb3InIHRvIGRpZmZlcmVudCBhdHRyaWJ1dGVzLlxuZnVuY3Rpb24gZ2V0UmFuZ2VWaXN1YWwobm9kZU1vZGVsLCBuYW1lKSB7XG4gIC8vICdjb2xvclJhbmdlJywgJ2NvbG9yQVJhbmdlJywgJ2NvbG9yU1JhbmdlJy5cbiAgLy8gSWYgbm90IGV4aXN0cyBvbiB0aGlzIG5vZGUsIGZldGNoIGZyb20gbGV2ZWxzIGFuZCBzZXJpZXMuXG4gIHZhciByYW5nZSA9IG5vZGVNb2RlbC5nZXQobmFtZSk7XG4gIHJldHVybiBpc0FycmF5KHJhbmdlKSAmJiByYW5nZS5sZW5ndGggPyB7XG4gICAgbmFtZTogbmFtZSxcbiAgICByYW5nZTogcmFuZ2VcbiAgfSA6IG51bGw7XG59XG5mdW5jdGlvbiBtYXBWaXN1YWwobm9kZU1vZGVsLCB2aXN1YWxzLCBjaGlsZCwgaW5kZXgsIG1hcHBpbmcsIHNlcmllc01vZGVsKSB7XG4gIHZhciBjaGlsZFZpc3VhbHMgPSBleHRlbmQoe30sIHZpc3VhbHMpO1xuICBpZiAobWFwcGluZykge1xuICAgIC8vIE9ubHkgc3VwcG9ydCBjb2xvciwgY29sb3JBbHBoYSwgY29sb3JTYXR1cmF0aW9uLlxuICAgIHZhciBtYXBwaW5nVHlwZSA9IG1hcHBpbmcudHlwZTtcbiAgICB2YXIgY29sb3JNYXBwaW5nQnkgPSBtYXBwaW5nVHlwZSA9PT0gJ2NvbG9yJyAmJiBpbm5lcihtYXBwaW5nKS5kckNvbG9yTWFwcGluZ0J5O1xuICAgIHZhciB2YWx1ZSA9IGNvbG9yTWFwcGluZ0J5ID09PSAnaW5kZXgnID8gaW5kZXggOiBjb2xvck1hcHBpbmdCeSA9PT0gJ2lkJyA/IHNlcmllc01vZGVsLm1hcElkVG9JbmRleChjaGlsZC5nZXRJZCgpKSA6IGNoaWxkLmdldFZhbHVlKG5vZGVNb2RlbC5nZXQoJ3Zpc3VhbERpbWVuc2lvbicpKTtcbiAgICBjaGlsZFZpc3VhbHNbbWFwcGluZ1R5cGVdID0gbWFwcGluZy5tYXBWYWx1ZVRvVmlzdWFsKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gY2hpbGRWaXN1YWxzO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLypcclxuKiBBIHRoaXJkLXBhcnR5IGxpY2Vuc2UgaXMgZW1iZWRkZWQgZm9yIHNvbWUgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlOlxyXG4qIFRoZSB0cmVlbWFwIGxheW91dCBpbXBsZW1lbnRhdGlvbiB3YXMgb3JpZ2luYWxseSBjb3BpZWQgZnJvbVxyXG4qIFwiZDMuanNcIiB3aXRoIHNvbWUgbW9kaWZpY2F0aW9ucyBtYWRlIGZvciB0aGlzIHByb2plY3QuXHJcbiogKFNlZSBtb3JlIGRldGFpbHMgaW4gdGhlIGNvbW1lbnQgb2YgdGhlIG1ldGhvZCBcInNxdWFyaWZ5XCIgYmVsb3cuKVxyXG4qIFRoZSB1c2Ugb2YgdGhlIHNvdXJjZSBjb2RlIG9mIHRoaXMgZmlsZSBpcyBhbHNvIHN1YmplY3QgdG8gdGhlIHRlcm1zXHJcbiogYW5kIGNvbnNpdGlvbnMgb2YgdGhlIGxpY2Vuc2Ugb2YgXCJkMy5qc1wiIChCU0QtM0NsYXVzZSwgc2VlXHJcbiogPC9saWNlbnNlcy9MSUNFTlNFLWQzPikuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBCb3VuZGluZ1JlY3QgZnJvbSAnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMnO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50LCBNQVhfU0FGRV9JTlRFR0VSIH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0ICogYXMgbGF5b3V0IGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0LmpzJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXIvdHJlZUhlbHBlci5qcyc7XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciByZXRyaWV2ZVZhbHVlID0genJVdGlsLnJldHJpZXZlO1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBQQVRIX0JPUkRFUl9XSURUSCA9IFsnaXRlbVN0eWxlJywgJ2JvcmRlcldpZHRoJ107XG52YXIgUEFUSF9HQVBfV0lEVEggPSBbJ2l0ZW1TdHlsZScsICdnYXBXaWR0aCddO1xudmFyIFBBVEhfVVBQRVJfTEFCRUxfU0hPVyA9IFsndXBwZXJMYWJlbCcsICdzaG93J107XG52YXIgUEFUSF9VUFBFUl9MQUJFTF9IRUlHSFQgPSBbJ3VwcGVyTGFiZWwnLCAnaGVpZ2h0J107XG47XG4vKipcclxuICogQHB1YmxpY1xyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2VyaWVzVHlwZTogJ3RyZWVtYXAnLFxuICByZXNldDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAvLyBMYXlvdXQgcmVzdWx0IGluIGVhY2ggbm9kZTpcbiAgICAvLyB7eCwgeSwgd2lkdGgsIGhlaWdodCwgYXJlYSwgYm9yZGVyV2lkdGh9XG4gICAgdmFyIGVjV2lkdGggPSBhcGkuZ2V0V2lkdGgoKTtcbiAgICB2YXIgZWNIZWlnaHQgPSBhcGkuZ2V0SGVpZ2h0KCk7XG4gICAgdmFyIHNlcmllc09wdGlvbiA9IHNlcmllc01vZGVsLm9wdGlvbjtcbiAgICB2YXIgbGF5b3V0SW5mbyA9IGxheW91dC5nZXRMYXlvdXRSZWN0KHNlcmllc01vZGVsLmdldEJveExheW91dFBhcmFtcygpLCB7XG4gICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgIH0pO1xuICAgIHZhciBzaXplID0gc2VyaWVzT3B0aW9uLnNpemUgfHwgW107IC8vIENvbXBhdGlibGUgd2l0aCBlYzIuXG4gICAgdmFyIGNvbnRhaW5lcldpZHRoID0gcGFyc2VQZXJjZW50KHJldHJpZXZlVmFsdWUobGF5b3V0SW5mby53aWR0aCwgc2l6ZVswXSksIGVjV2lkdGgpO1xuICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBwYXJzZVBlcmNlbnQocmV0cmlldmVWYWx1ZShsYXlvdXRJbmZvLmhlaWdodCwgc2l6ZVsxXSksIGVjSGVpZ2h0KTtcbiAgICAvLyBGZXRjaCBwYXlsb2FkIGluZm8uXG4gICAgdmFyIHBheWxvYWRUeXBlID0gcGF5bG9hZCAmJiBwYXlsb2FkLnR5cGU7XG4gICAgdmFyIHR5cGVzID0gWyd0cmVlbWFwWm9vbVRvTm9kZScsICd0cmVlbWFwUm9vdFRvTm9kZSddO1xuICAgIHZhciB0YXJnZXRJbmZvID0gaGVscGVyLnJldHJpZXZlVGFyZ2V0SW5mbyhwYXlsb2FkLCB0eXBlcywgc2VyaWVzTW9kZWwpO1xuICAgIHZhciByb290UmVjdCA9IHBheWxvYWRUeXBlID09PSAndHJlZW1hcFJlbmRlcicgfHwgcGF5bG9hZFR5cGUgPT09ICd0cmVlbWFwTW92ZScgPyBwYXlsb2FkLnJvb3RSZWN0IDogbnVsbDtcbiAgICB2YXIgdmlld1Jvb3QgPSBzZXJpZXNNb2RlbC5nZXRWaWV3Um9vdCgpO1xuICAgIHZhciB2aWV3QWJvdmVQYXRoID0gaGVscGVyLmdldFBhdGhUb1Jvb3Qodmlld1Jvb3QpO1xuICAgIGlmIChwYXlsb2FkVHlwZSAhPT0gJ3RyZWVtYXBNb3ZlJykge1xuICAgICAgdmFyIHJvb3RTaXplID0gcGF5bG9hZFR5cGUgPT09ICd0cmVlbWFwWm9vbVRvTm9kZScgPyBlc3RpbWF0ZVJvb3RTaXplKHNlcmllc01vZGVsLCB0YXJnZXRJbmZvLCB2aWV3Um9vdCwgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCkgOiByb290UmVjdCA/IFtyb290UmVjdC53aWR0aCwgcm9vdFJlY3QuaGVpZ2h0XSA6IFtjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0XTtcbiAgICAgIHZhciBzb3J0XzEgPSBzZXJpZXNPcHRpb24uc29ydDtcbiAgICAgIGlmIChzb3J0XzEgJiYgc29ydF8xICE9PSAnYXNjJyAmJiBzb3J0XzEgIT09ICdkZXNjJykge1xuICAgICAgICAvLyBEZWZhdWx0IHRvIGJlIGRlc2Mgb3JkZXIuXG4gICAgICAgIHNvcnRfMSA9ICdkZXNjJztcbiAgICAgIH1cbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBzcXVhcmVSYXRpbzogc2VyaWVzT3B0aW9uLnNxdWFyZVJhdGlvLFxuICAgICAgICBzb3J0OiBzb3J0XzEsXG4gICAgICAgIGxlYWZEZXB0aDogc2VyaWVzT3B0aW9uLmxlYWZEZXB0aFxuICAgICAgfTtcbiAgICAgIC8vIGxheW91dCBzaG91bGQgYmUgY2xlYXJlZCBiZWNhdXNlIHVzaW5nIHVwZGF0ZVZpZXcgYnV0IG5vdCB1cGRhdGUuXG4gICAgICB2aWV3Um9vdC5ob3N0VHJlZS5jbGVhckxheW91dHMoKTtcbiAgICAgIC8vIFRPRE9cbiAgICAgIC8vIG9wdGltaXplOiBpZiBvdXQgb2YgdmlldyBjbGlwLCBkbyBub3QgbGF5b3V0LlxuICAgICAgLy8gQnV0IHRha2UgY2FyZSB0aGF0IGlmIGRvIG5vdCByZW5kZXIgbm9kZSBvdXQgb2YgdmlldyBjbGlwLFxuICAgICAgLy8gaG93IHRvIGNhbGN1bGF0ZSBzdGFydCBwb1xuICAgICAgdmFyIHZpZXdSb290TGF5b3V0XzEgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiByb290U2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiByb290U2l6ZVsxXSxcbiAgICAgICAgYXJlYTogcm9vdFNpemVbMF0gKiByb290U2l6ZVsxXVxuICAgICAgfTtcbiAgICAgIHZpZXdSb290LnNldExheW91dCh2aWV3Um9vdExheW91dF8xKTtcbiAgICAgIHNxdWFyaWZ5KHZpZXdSb290LCBvcHRpb25zLCBmYWxzZSwgMCk7XG4gICAgICAvLyBTdXBwbGVtZW50IGxheW91dC5cbiAgICAgIHZpZXdSb290TGF5b3V0XzEgPSB2aWV3Um9vdC5nZXRMYXlvdXQoKTtcbiAgICAgIGVhY2godmlld0Fib3ZlUGF0aCwgZnVuY3Rpb24gKG5vZGUsIGluZGV4KSB7XG4gICAgICAgIHZhciBjaGlsZFZhbHVlID0gKHZpZXdBYm92ZVBhdGhbaW5kZXggKyAxXSB8fCB2aWV3Um9vdCkuZ2V0VmFsdWUoKTtcbiAgICAgICAgbm9kZS5zZXRMYXlvdXQoenJVdGlsLmV4dGVuZCh7XG4gICAgICAgICAgZGF0YUV4dGVudDogW2NoaWxkVmFsdWUsIGNoaWxkVmFsdWVdLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgICAgIHVwcGVySGVpZ2h0OiAwXG4gICAgICAgIH0sIHZpZXdSb290TGF5b3V0XzEpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgdHJlZVJvb3QgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCkudHJlZS5yb290O1xuICAgIHRyZWVSb290LnNldExheW91dChjYWxjdWxhdGVSb290UG9zaXRpb24obGF5b3V0SW5mbywgcm9vdFJlY3QsIHRhcmdldEluZm8pLCB0cnVlKTtcbiAgICBzZXJpZXNNb2RlbC5zZXRMYXlvdXRJbmZvKGxheW91dEluZm8pO1xuICAgIC8vIEZJWE1FXG4gICAgLy8g546w5Zyo5rKh5pyJY2xpcOWKn+iDve+8jOaaguaXtuWPlmVj6auY5a6944CCXG4gICAgcHJ1bm5pbmcodHJlZVJvb3QsXG4gICAgLy8gVHJhbnNmb3JtIHRvIGJhc2UgZWxlbWVudCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICBuZXcgQm91bmRpbmdSZWN0KC1sYXlvdXRJbmZvLngsIC1sYXlvdXRJbmZvLnksIGVjV2lkdGgsIGVjSGVpZ2h0KSwgdmlld0Fib3ZlUGF0aCwgdmlld1Jvb3QsIDApO1xuICB9XG59O1xuLyoqXHJcbiAqIExheW91dCB0cmVlbWFwIHdpdGggc3F1YXJpZnkgYWxnb3JpdGhtLlxyXG4gKiBUaGUgb3JpZ2luYWwgcHJlc2VudGF0aW9uIG9mIHRoaXMgYWxnb3JpdGhtXHJcbiAqIHdhcyBtYWRlIGJ5IE1hcmsgQnJ1bHMsIEtlZXMgSHVpemluZywgYW5kIEphcmtlIEouIHZhbiBXaWprXHJcbiAqIDxodHRwczovL2dyYXBoaWNzLmV0aHouY2gvdGVhY2hpbmcvc2NpdmlzX2NvbW1vbi9MaXRlcmF0dXJlL3NxdWFyaWZpZWRUcmVlTWFwcy5wZGY+LlxyXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBhbGdvcml0aG0gd2FzIG9yaWdpbmFsbHkgY29waWVkIGZyb20gXCJkMy5qc1wiXHJcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vZDMvZDMvYmxvYi85Y2M5YTg3NWU2MzZhMWRjZjM2Y2MxZTA3YmRmNzdlMWFkNmUyYzc0L3NyYy9sYXlvdXQvdHJlZW1hcC5qcz5cclxuICogd2l0aCBzb21lIG1vZGlmaWNhdGlvbnMgbWFkZSBmb3IgdGhpcyBwcm9ncmFtLlxyXG4gKiBTZWUgdGhlIGxpY2Vuc2Ugc3RhdGVtZW50IGF0IHRoZSBoZWFkIG9mIHRoaXMgZmlsZS5cclxuICpcclxuICogQHByb3RlY3RlZFxyXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvVHJlZX5UcmVlTm9kZX0gbm9kZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zb3J0ICdhc2MnIG9yICdkZXNjJ1xyXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zcXVhcmVSYXRpb1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhpZGVDaGlsZHJlblxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGhcclxuICovXG5mdW5jdGlvbiBzcXVhcmlmeShub2RlLCBvcHRpb25zLCBoaWRlQ2hpbGRyZW4sIGRlcHRoKSB7XG4gIHZhciB3aWR0aDtcbiAgdmFyIGhlaWdodDtcbiAgaWYgKG5vZGUuaXNSZW1vdmVkKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHRoaXNMYXlvdXQgPSBub2RlLmdldExheW91dCgpO1xuICB3aWR0aCA9IHRoaXNMYXlvdXQud2lkdGg7XG4gIGhlaWdodCA9IHRoaXNMYXlvdXQuaGVpZ2h0O1xuICAvLyBDb25zaWRlcmluZyBib3JkZXIgYW5kIGdhcFxuICB2YXIgbm9kZU1vZGVsID0gbm9kZS5nZXRNb2RlbCgpO1xuICB2YXIgYm9yZGVyV2lkdGggPSBub2RlTW9kZWwuZ2V0KFBBVEhfQk9SREVSX1dJRFRIKTtcbiAgdmFyIGhhbGZHYXBXaWR0aCA9IG5vZGVNb2RlbC5nZXQoUEFUSF9HQVBfV0lEVEgpIC8gMjtcbiAgdmFyIHVwcGVyTGFiZWxIZWlnaHQgPSBnZXRVcHBlckxhYmVsSGVpZ2h0KG5vZGVNb2RlbCk7XG4gIHZhciB1cHBlckhlaWdodCA9IE1hdGgubWF4KGJvcmRlcldpZHRoLCB1cHBlckxhYmVsSGVpZ2h0KTtcbiAgdmFyIGxheW91dE9mZnNldCA9IGJvcmRlcldpZHRoIC0gaGFsZkdhcFdpZHRoO1xuICB2YXIgbGF5b3V0T2Zmc2V0VXBwZXIgPSB1cHBlckhlaWdodCAtIGhhbGZHYXBXaWR0aDtcbiAgbm9kZS5zZXRMYXlvdXQoe1xuICAgIGJvcmRlcldpZHRoOiBib3JkZXJXaWR0aCxcbiAgICB1cHBlckhlaWdodDogdXBwZXJIZWlnaHQsXG4gICAgdXBwZXJMYWJlbEhlaWdodDogdXBwZXJMYWJlbEhlaWdodFxuICB9LCB0cnVlKTtcbiAgd2lkdGggPSBtYXRoTWF4KHdpZHRoIC0gMiAqIGxheW91dE9mZnNldCwgMCk7XG4gIGhlaWdodCA9IG1hdGhNYXgoaGVpZ2h0IC0gbGF5b3V0T2Zmc2V0IC0gbGF5b3V0T2Zmc2V0VXBwZXIsIDApO1xuICB2YXIgdG90YWxBcmVhID0gd2lkdGggKiBoZWlnaHQ7XG4gIHZhciB2aWV3Q2hpbGRyZW4gPSBpbml0Q2hpbGRyZW4obm9kZSwgbm9kZU1vZGVsLCB0b3RhbEFyZWEsIG9wdGlvbnMsIGhpZGVDaGlsZHJlbiwgZGVwdGgpO1xuICBpZiAoIXZpZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlY3QgPSB7XG4gICAgeDogbGF5b3V0T2Zmc2V0LFxuICAgIHk6IGxheW91dE9mZnNldFVwcGVyLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuICB2YXIgcm93Rml4ZWRMZW5ndGggPSBtYXRoTWluKHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgYmVzdCA9IEluZmluaXR5OyAvLyB0aGUgYmVzdCByb3cgc2NvcmUgc28gZmFyXG4gIHZhciByb3cgPSBbXTtcbiAgcm93LmFyZWEgPSAwO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmlld0NoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjspIHtcbiAgICB2YXIgY2hpbGQgPSB2aWV3Q2hpbGRyZW5baV07XG4gICAgcm93LnB1c2goY2hpbGQpO1xuICAgIHJvdy5hcmVhICs9IGNoaWxkLmdldExheW91dCgpLmFyZWE7XG4gICAgdmFyIHNjb3JlID0gd29yc3Qocm93LCByb3dGaXhlZExlbmd0aCwgb3B0aW9ucy5zcXVhcmVSYXRpbyk7XG4gICAgLy8gY29udGludWUgd2l0aCB0aGlzIG9yaWVudGF0aW9uXG4gICAgaWYgKHNjb3JlIDw9IGJlc3QpIHtcbiAgICAgIGkrKztcbiAgICAgIGJlc3QgPSBzY29yZTtcbiAgICB9XG4gICAgLy8gYWJvcnQsIGFuZCB0cnkgYSBkaWZmZXJlbnQgb3JpZW50YXRpb25cbiAgICBlbHNlIHtcbiAgICAgIHJvdy5hcmVhIC09IHJvdy5wb3AoKS5nZXRMYXlvdXQoKS5hcmVhO1xuICAgICAgcG9zaXRpb24ocm93LCByb3dGaXhlZExlbmd0aCwgcmVjdCwgaGFsZkdhcFdpZHRoLCBmYWxzZSk7XG4gICAgICByb3dGaXhlZExlbmd0aCA9IG1hdGhNaW4ocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcbiAgICAgIGJlc3QgPSBJbmZpbml0eTtcbiAgICB9XG4gIH1cbiAgaWYgKHJvdy5sZW5ndGgpIHtcbiAgICBwb3NpdGlvbihyb3csIHJvd0ZpeGVkTGVuZ3RoLCByZWN0LCBoYWxmR2FwV2lkdGgsIHRydWUpO1xuICB9XG4gIGlmICghaGlkZUNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkcmVuVmlzaWJsZU1pbiA9IG5vZGVNb2RlbC5nZXQoJ2NoaWxkcmVuVmlzaWJsZU1pbicpO1xuICAgIGlmIChjaGlsZHJlblZpc2libGVNaW4gIT0gbnVsbCAmJiB0b3RhbEFyZWEgPCBjaGlsZHJlblZpc2libGVNaW4pIHtcbiAgICAgIGhpZGVDaGlsZHJlbiA9IHRydWU7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2aWV3Q2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzcXVhcmlmeSh2aWV3Q2hpbGRyZW5baV0sIG9wdGlvbnMsIGhpZGVDaGlsZHJlbiwgZGVwdGggKyAxKTtcbiAgfVxufVxuLyoqXHJcbiAqIFNldCBhcmVhIHRvIGVhY2ggY2hpbGQsIGFuZCBjYWxjdWxhdGUgZGF0YSBleHRlbnQgZm9yIHZpc3VhbCBjb2RpbmcuXHJcbiAqL1xuZnVuY3Rpb24gaW5pdENoaWxkcmVuKG5vZGUsIG5vZGVNb2RlbCwgdG90YWxBcmVhLCBvcHRpb25zLCBoaWRlQ2hpbGRyZW4sIGRlcHRoKSB7XG4gIHZhciB2aWV3Q2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuIHx8IFtdO1xuICB2YXIgb3JkZXJCeSA9IG9wdGlvbnMuc29ydDtcbiAgb3JkZXJCeSAhPT0gJ2FzYycgJiYgb3JkZXJCeSAhPT0gJ2Rlc2MnICYmIChvcmRlckJ5ID0gbnVsbCk7XG4gIHZhciBvdmVyTGVhZkRlcHRoID0gb3B0aW9ucy5sZWFmRGVwdGggIT0gbnVsbCAmJiBvcHRpb25zLmxlYWZEZXB0aCA8PSBkZXB0aDtcbiAgLy8gbGVhZkRlcHRoIGhhcyBoaWdoZXIgcHJpb3JpdHkuXG4gIGlmIChoaWRlQ2hpbGRyZW4gJiYgIW92ZXJMZWFmRGVwdGgpIHtcbiAgICByZXR1cm4gbm9kZS52aWV3Q2hpbGRyZW4gPSBbXTtcbiAgfVxuICAvLyBTb3J0IGNoaWxkcmVuLCBvcmRlciBieSBkZXNjLlxuICB2aWV3Q2hpbGRyZW4gPSB6clV0aWwuZmlsdGVyKHZpZXdDaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuICFjaGlsZC5pc1JlbW92ZWQoKTtcbiAgfSk7XG4gIHNvcnQodmlld0NoaWxkcmVuLCBvcmRlckJ5KTtcbiAgdmFyIGluZm8gPSBzdGF0aXN0aWMobm9kZU1vZGVsLCB2aWV3Q2hpbGRyZW4sIG9yZGVyQnkpO1xuICBpZiAoaW5mby5zdW0gPT09IDApIHtcbiAgICByZXR1cm4gbm9kZS52aWV3Q2hpbGRyZW4gPSBbXTtcbiAgfVxuICBpbmZvLnN1bSA9IGZpbHRlckJ5VGhyZXNob2xkKG5vZGVNb2RlbCwgdG90YWxBcmVhLCBpbmZvLnN1bSwgb3JkZXJCeSwgdmlld0NoaWxkcmVuKTtcbiAgaWYgKGluZm8uc3VtID09PSAwKSB7XG4gICAgcmV0dXJuIG5vZGUudmlld0NoaWxkcmVuID0gW107XG4gIH1cbiAgLy8gU2V0IGFyZWEgdG8gZWFjaCBjaGlsZC5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZpZXdDaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBhcmVhID0gdmlld0NoaWxkcmVuW2ldLmdldFZhbHVlKCkgLyBpbmZvLnN1bSAqIHRvdGFsQXJlYTtcbiAgICAvLyBEbyBub3QgdXNlIHNldExheW91dCh7Li4ufSwgdHJ1ZSksIGJlY2F1c2UgaXQgaXMgbmVlZGVkIHRvIGNsZWFyIGxhc3QgbGF5b3V0LlxuICAgIHZpZXdDaGlsZHJlbltpXS5zZXRMYXlvdXQoe1xuICAgICAgYXJlYTogYXJlYVxuICAgIH0pO1xuICB9XG4gIGlmIChvdmVyTGVhZkRlcHRoKSB7XG4gICAgdmlld0NoaWxkcmVuLmxlbmd0aCAmJiBub2RlLnNldExheW91dCh7XG4gICAgICBpc0xlYWZSb290OiB0cnVlXG4gICAgfSwgdHJ1ZSk7XG4gICAgdmlld0NoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgbm9kZS52aWV3Q2hpbGRyZW4gPSB2aWV3Q2hpbGRyZW47XG4gIG5vZGUuc2V0TGF5b3V0KHtcbiAgICBkYXRhRXh0ZW50OiBpbmZvLmRhdGFFeHRlbnRcbiAgfSwgdHJ1ZSk7XG4gIHJldHVybiB2aWV3Q2hpbGRyZW47XG59XG4vKipcclxuICogQ29uc2lkZXIgJ3Zpc2libGVNaW4nLiBNb2RpZnkgdmlld0NoaWxkcmVuIGFuZCBnZXQgbmV3IHN1bS5cclxuICovXG5mdW5jdGlvbiBmaWx0ZXJCeVRocmVzaG9sZChub2RlTW9kZWwsIHRvdGFsQXJlYSwgc3VtLCBvcmRlckJ5LCBvcmRlcmVkQ2hpbGRyZW4pIHtcbiAgLy8gdmlzaWJsZU1pbiBpcyBub3Qgc3VwcG9ydGVkIHlldCB3aGVuIG5vIG9wdGlvbi5zb3J0LlxuICBpZiAoIW9yZGVyQnkpIHtcbiAgICByZXR1cm4gc3VtO1xuICB9XG4gIHZhciB2aXNpYmxlTWluID0gbm9kZU1vZGVsLmdldCgndmlzaWJsZU1pbicpO1xuICB2YXIgbGVuID0gb3JkZXJlZENoaWxkcmVuLmxlbmd0aDtcbiAgdmFyIGRlbGV0ZVBvaW50ID0gbGVuO1xuICAvLyBBbHdheXMgdHJhdmVsIGZyb20gbGl0dGxlIHZhbHVlIHRvIGJpZyB2YWx1ZS5cbiAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHZhbHVlID0gb3JkZXJlZENoaWxkcmVuW29yZGVyQnkgPT09ICdhc2MnID8gbGVuIC0gaSAtIDEgOiBpXS5nZXRWYWx1ZSgpO1xuICAgIGlmICh2YWx1ZSAvIHN1bSAqIHRvdGFsQXJlYSA8IHZpc2libGVNaW4pIHtcbiAgICAgIGRlbGV0ZVBvaW50ID0gaTtcbiAgICAgIHN1bSAtPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgb3JkZXJCeSA9PT0gJ2FzYycgPyBvcmRlcmVkQ2hpbGRyZW4uc3BsaWNlKDAsIGxlbiAtIGRlbGV0ZVBvaW50KSA6IG9yZGVyZWRDaGlsZHJlbi5zcGxpY2UoZGVsZXRlUG9pbnQsIGxlbiAtIGRlbGV0ZVBvaW50KTtcbiAgcmV0dXJuIHN1bTtcbn1cbi8qKlxyXG4gKiBTb3J0XHJcbiAqL1xuZnVuY3Rpb24gc29ydCh2aWV3Q2hpbGRyZW4sIG9yZGVyQnkpIHtcbiAgaWYgKG9yZGVyQnkpIHtcbiAgICB2aWV3Q2hpbGRyZW4uc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIGRpZmYgPSBvcmRlckJ5ID09PSAnYXNjJyA/IGEuZ2V0VmFsdWUoKSAtIGIuZ2V0VmFsdWUoKSA6IGIuZ2V0VmFsdWUoKSAtIGEuZ2V0VmFsdWUoKTtcbiAgICAgIHJldHVybiBkaWZmID09PSAwID8gb3JkZXJCeSA9PT0gJ2FzYycgPyBhLmRhdGFJbmRleCAtIGIuZGF0YUluZGV4IDogYi5kYXRhSW5kZXggLSBhLmRhdGFJbmRleCA6IGRpZmY7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHZpZXdDaGlsZHJlbjtcbn1cbi8qKlxyXG4gKiBTdGF0aXN0aWNcclxuICovXG5mdW5jdGlvbiBzdGF0aXN0aWMobm9kZU1vZGVsLCBjaGlsZHJlbiwgb3JkZXJCeSkge1xuICAvLyBDYWxjdWxhdGUgc3VtLlxuICB2YXIgc3VtID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc3VtICs9IGNoaWxkcmVuW2ldLmdldFZhbHVlKCk7XG4gIH1cbiAgLy8gU3RhdGlzdGljIGRhdGEgZXh0ZW50IGZvciBsYXR0ZXIgdmlzdWFsIGNvZGluZy5cbiAgLy8gTm90aWNlOiBkYXRhIGV4dGVudCBzaG91bGQgYmUgY2FsY3VsYXRlIGJhc2VkIG9uIHJhdyBjaGlsZHJlblxuICAvLyBidXQgbm90IGZpbHRlcmVkIHZpZXcgY2hpbGRyZW4sIG90aGVyd2lzZSB2aXN1YWwgbWFwcGluZyB3aWxsIG5vdFxuICAvLyBiZSBzdGFibGUgd2hlbiB6b29tICh3aGVyZSBjaGlsZHJlbiBpcyBmaWx0ZXJlZCBieSB2aXNpYmxlTWluKS5cbiAgdmFyIGRpbWVuc2lvbiA9IG5vZGVNb2RlbC5nZXQoJ3Zpc3VhbERpbWVuc2lvbicpO1xuICB2YXIgZGF0YUV4dGVudDtcbiAgLy8gVGhlIHNhbWUgYXMgYXJlYSBkaW1lbnNpb24uXG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGRhdGFFeHRlbnQgPSBbTmFOLCBOYU5dO1xuICB9IGVsc2UgaWYgKGRpbWVuc2lvbiA9PT0gJ3ZhbHVlJyAmJiBvcmRlckJ5KSB7XG4gICAgZGF0YUV4dGVudCA9IFtjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS5nZXRWYWx1ZSgpLCBjaGlsZHJlblswXS5nZXRWYWx1ZSgpXTtcbiAgICBvcmRlckJ5ID09PSAnYXNjJyAmJiBkYXRhRXh0ZW50LnJldmVyc2UoKTtcbiAgfVxuICAvLyBPdGhlciBkaW1lbnNpb24uXG4gIGVsc2Uge1xuICAgIGRhdGFFeHRlbnQgPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgZWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB2YXIgdmFsdWUgPSBjaGlsZC5nZXRWYWx1ZShkaW1lbnNpb24pO1xuICAgICAgdmFsdWUgPCBkYXRhRXh0ZW50WzBdICYmIChkYXRhRXh0ZW50WzBdID0gdmFsdWUpO1xuICAgICAgdmFsdWUgPiBkYXRhRXh0ZW50WzFdICYmIChkYXRhRXh0ZW50WzFdID0gdmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3VtOiBzdW0sXG4gICAgZGF0YUV4dGVudDogZGF0YUV4dGVudFxuICB9O1xufVxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBzY29yZSBmb3IgdGhlIHNwZWNpZmllZCByb3csXHJcbiAqIGFzIHRoZSB3b3JzdCBhc3BlY3QgcmF0aW8uXHJcbiAqL1xuZnVuY3Rpb24gd29yc3Qocm93LCByb3dGaXhlZExlbmd0aCwgcmF0aW8pIHtcbiAgdmFyIGFyZWFNYXggPSAwO1xuICB2YXIgYXJlYU1pbiA9IEluZmluaXR5O1xuICBmb3IgKHZhciBpID0gMCwgYXJlYSA9IHZvaWQgMCwgbGVuID0gcm93Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJlYSA9IHJvd1tpXS5nZXRMYXlvdXQoKS5hcmVhO1xuICAgIGlmIChhcmVhKSB7XG4gICAgICBhcmVhIDwgYXJlYU1pbiAmJiAoYXJlYU1pbiA9IGFyZWEpO1xuICAgICAgYXJlYSA+IGFyZWFNYXggJiYgKGFyZWFNYXggPSBhcmVhKTtcbiAgICB9XG4gIH1cbiAgdmFyIHNxdWFyZUFyZWEgPSByb3cuYXJlYSAqIHJvdy5hcmVhO1xuICB2YXIgZiA9IHJvd0ZpeGVkTGVuZ3RoICogcm93Rml4ZWRMZW5ndGggKiByYXRpbztcbiAgcmV0dXJuIHNxdWFyZUFyZWEgPyBtYXRoTWF4KGYgKiBhcmVhTWF4IC8gc3F1YXJlQXJlYSwgc3F1YXJlQXJlYSAvIChmICogYXJlYU1pbikpIDogSW5maW5pdHk7XG59XG4vKipcclxuICogUG9zaXRpb25zIHRoZSBzcGVjaWZpZWQgcm93IG9mIG5vZGVzLiBNb2RpZmllcyBgcmVjdGAuXHJcbiAqL1xuZnVuY3Rpb24gcG9zaXRpb24ocm93LCByb3dGaXhlZExlbmd0aCwgcmVjdCwgaGFsZkdhcFdpZHRoLCBmbHVzaCkge1xuICAvLyBXaGVuIHJvd0ZpeGVkTGVuZ3RoID09PSByZWN0LndpZHRoLFxuICAvLyBpdCBpcyBob3Jpem9udGFsIHN1YmRpdmlzaW9uLFxuICAvLyByb3dGaXhlZExlbmd0aCBpcyB0aGUgd2lkdGggb2YgdGhlIHN1YmRpdmlzaW9uLFxuICAvLyByb3dPdGhlckxlbmd0aCBpcyB0aGUgaGVpZ2h0IG9mIHRoZSBzdWJkaXZpc2lvbixcbiAgLy8gYW5kIG5vZGVzIHdpbGwgYmUgcG9zaXRpb25lZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gIC8vIHdoW2lkeDBXaGVuSF0gbWVhbnM6IHdoZW4gaG9yaXpvbnRhbCxcbiAgLy8gICAgICB3aFtpZHgwV2hlbkhdID0+IHdoWzBdID0+ICd3aWR0aCcuXG4gIC8vICAgICAgeHlbaWR4MVdoZW5IXSA9PiB4eVsxXSA9PiAneScuXG4gIHZhciBpZHgwV2hlbkggPSByb3dGaXhlZExlbmd0aCA9PT0gcmVjdC53aWR0aCA/IDAgOiAxO1xuICB2YXIgaWR4MVdoZW5IID0gMSAtIGlkeDBXaGVuSDtcbiAgdmFyIHh5ID0gWyd4JywgJ3knXTtcbiAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcbiAgdmFyIGxhc3QgPSByZWN0W3h5W2lkeDBXaGVuSF1dO1xuICB2YXIgcm93T3RoZXJMZW5ndGggPSByb3dGaXhlZExlbmd0aCA/IHJvdy5hcmVhIC8gcm93Rml4ZWRMZW5ndGggOiAwO1xuICBpZiAoZmx1c2ggfHwgcm93T3RoZXJMZW5ndGggPiByZWN0W3doW2lkeDFXaGVuSF1dKSB7XG4gICAgcm93T3RoZXJMZW5ndGggPSByZWN0W3doW2lkeDFXaGVuSF1dOyAvLyBvdmVyK3VuZGVyZmxvd1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCByb3dMZW4gPSByb3cubGVuZ3RoOyBpIDwgcm93TGVuOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHJvd1tpXTtcbiAgICB2YXIgbm9kZUxheW91dCA9IHt9O1xuICAgIHZhciBzdGVwID0gcm93T3RoZXJMZW5ndGggPyBub2RlLmdldExheW91dCgpLmFyZWEgLyByb3dPdGhlckxlbmd0aCA6IDA7XG4gICAgdmFyIHdoMSA9IG5vZGVMYXlvdXRbd2hbaWR4MVdoZW5IXV0gPSBtYXRoTWF4KHJvd090aGVyTGVuZ3RoIC0gMiAqIGhhbGZHYXBXaWR0aCwgMCk7XG4gICAgLy8gV2UgdXNlIE1hdGgubWF4L21pbiB0byBhdm9pZCBuZWdhdGl2ZSB3aWR0aC9oZWlnaHQgd2hlbiBjb25zaWRlcmluZyBnYXAgd2lkdGguXG4gICAgdmFyIHJlbWFpbiA9IHJlY3RbeHlbaWR4MFdoZW5IXV0gKyByZWN0W3doW2lkeDBXaGVuSF1dIC0gbGFzdDtcbiAgICB2YXIgbW9kV0ggPSBpID09PSByb3dMZW4gLSAxIHx8IHJlbWFpbiA8IHN0ZXAgPyByZW1haW4gOiBzdGVwO1xuICAgIHZhciB3aDAgPSBub2RlTGF5b3V0W3doW2lkeDBXaGVuSF1dID0gbWF0aE1heChtb2RXSCAtIDIgKiBoYWxmR2FwV2lkdGgsIDApO1xuICAgIG5vZGVMYXlvdXRbeHlbaWR4MVdoZW5IXV0gPSByZWN0W3h5W2lkeDFXaGVuSF1dICsgbWF0aE1pbihoYWxmR2FwV2lkdGgsIHdoMSAvIDIpO1xuICAgIG5vZGVMYXlvdXRbeHlbaWR4MFdoZW5IXV0gPSBsYXN0ICsgbWF0aE1pbihoYWxmR2FwV2lkdGgsIHdoMCAvIDIpO1xuICAgIGxhc3QgKz0gbW9kV0g7XG4gICAgbm9kZS5zZXRMYXlvdXQobm9kZUxheW91dCwgdHJ1ZSk7XG4gIH1cbiAgcmVjdFt4eVtpZHgxV2hlbkhdXSArPSByb3dPdGhlckxlbmd0aDtcbiAgcmVjdFt3aFtpZHgxV2hlbkhdXSAtPSByb3dPdGhlckxlbmd0aDtcbn1cbi8vIFJldHVybiBbY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodF0gYXMgZGVmYXVsdC5cbmZ1bmN0aW9uIGVzdGltYXRlUm9vdFNpemUoc2VyaWVzTW9kZWwsIHRhcmdldEluZm8sIHZpZXdSb290LCBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KSB7XG4gIC8vIElmIHRhcmdldEluZm8ubm9kZSBleGlzdHMsIHdlIHpvb20gdG8gdGhlIG5vZGUsXG4gIC8vIHNvIGVzdGltYXRlIHdob2xlIHdpZHRoIGFuZCBoZWlnaHQgYnkgdGFyZ2V0IG5vZGUuXG4gIHZhciBjdXJyTm9kZSA9ICh0YXJnZXRJbmZvIHx8IHt9KS5ub2RlO1xuICB2YXIgZGVmYXVsdFNpemUgPSBbY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodF07XG4gIGlmICghY3Vyck5vZGUgfHwgY3Vyck5vZGUgPT09IHZpZXdSb290KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRTaXplO1xuICB9XG4gIHZhciBwYXJlbnQ7XG4gIHZhciB2aWV3QXJlYSA9IGNvbnRhaW5lcldpZHRoICogY29udGFpbmVySGVpZ2h0O1xuICB2YXIgYXJlYSA9IHZpZXdBcmVhICogc2VyaWVzTW9kZWwub3B0aW9uLnpvb21Ub05vZGVSYXRpbztcbiAgd2hpbGUgKHBhcmVudCA9IGN1cnJOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgc2libGluZ3MgPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNpYmxpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzdW0gKz0gc2libGluZ3NbaV0uZ2V0VmFsdWUoKTtcbiAgICB9XG4gICAgdmFyIGN1cnJOb2RlVmFsdWUgPSBjdXJyTm9kZS5nZXRWYWx1ZSgpO1xuICAgIGlmIChjdXJyTm9kZVZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFNpemU7XG4gICAgfVxuICAgIGFyZWEgKj0gc3VtIC8gY3Vyck5vZGVWYWx1ZTtcbiAgICAvLyBDb25zaWRlcmluZyBib3JkZXIsIHN1cHBvc2UgYXNwZWN0IHJhdGlvIGlzIDEuXG4gICAgdmFyIHBhcmVudE1vZGVsID0gcGFyZW50LmdldE1vZGVsKCk7XG4gICAgdmFyIGJvcmRlcldpZHRoID0gcGFyZW50TW9kZWwuZ2V0KFBBVEhfQk9SREVSX1dJRFRIKTtcbiAgICB2YXIgdXBwZXJIZWlnaHQgPSBNYXRoLm1heChib3JkZXJXaWR0aCwgZ2V0VXBwZXJMYWJlbEhlaWdodChwYXJlbnRNb2RlbCkpO1xuICAgIGFyZWEgKz0gNCAqIGJvcmRlcldpZHRoICogYm9yZGVyV2lkdGggKyAoMyAqIGJvcmRlcldpZHRoICsgdXBwZXJIZWlnaHQpICogTWF0aC5wb3coYXJlYSwgMC41KTtcbiAgICBhcmVhID4gTUFYX1NBRkVfSU5URUdFUiAmJiAoYXJlYSA9IE1BWF9TQUZFX0lOVEVHRVIpO1xuICAgIGN1cnJOb2RlID0gcGFyZW50O1xuICB9XG4gIGFyZWEgPCB2aWV3QXJlYSAmJiAoYXJlYSA9IHZpZXdBcmVhKTtcbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coYXJlYSAvIHZpZXdBcmVhLCAwLjUpO1xuICByZXR1cm4gW2NvbnRhaW5lcldpZHRoICogc2NhbGUsIGNvbnRhaW5lckhlaWdodCAqIHNjYWxlXTtcbn1cbi8vIFJvb3QgcG9zaXRpb24gYmFzZWQgb24gY29vcmQgb2YgY29udGFpbmVyR3JvdXBcbmZ1bmN0aW9uIGNhbGN1bGF0ZVJvb3RQb3NpdGlvbihsYXlvdXRJbmZvLCByb290UmVjdCwgdGFyZ2V0SW5mbykge1xuICBpZiAocm9vdFJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcm9vdFJlY3QueCxcbiAgICAgIHk6IHJvb3RSZWN0LnlcbiAgICB9O1xuICB9XG4gIHZhciBkZWZhdWx0UG9zaXRpb24gPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIGlmICghdGFyZ2V0SW5mbykge1xuICAgIHJldHVybiBkZWZhdWx0UG9zaXRpb247XG4gIH1cbiAgLy8gSWYgdGFyZ2V0SW5mbyBpcyBmZXRjaGVkIGJ5ICdyZXRyaWV2ZVRhcmdldEluZm8nLFxuICAvLyBvbGQgdHJlZSBhbmQgbmV3IHRyZWUgYXJlIHRoZSBzYW1lIHRyZWUsXG4gIC8vIHNvIHRoZSBub2RlIHN0aWxsIGV4aXN0cyBhbmQgd2UgY2FuIHZpc2l0IGl0LlxuICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluZm8ubm9kZTtcbiAgdmFyIGxheW91dCA9IHRhcmdldE5vZGUuZ2V0TGF5b3V0KCk7XG4gIGlmICghbGF5b3V0KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRQb3NpdGlvbjtcbiAgfVxuICAvLyBUcmFuc2Zvcm0gY29vcmQgZnJvbSBsb2NhbCB0byBjb250YWluZXIuXG4gIHZhciB0YXJnZXRDZW50ZXIgPSBbbGF5b3V0LndpZHRoIC8gMiwgbGF5b3V0LmhlaWdodCAvIDJdO1xuICB2YXIgbm9kZSA9IHRhcmdldE5vZGU7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgdmFyIG5vZGVMYXlvdXQgPSBub2RlLmdldExheW91dCgpO1xuICAgIHRhcmdldENlbnRlclswXSArPSBub2RlTGF5b3V0Lng7XG4gICAgdGFyZ2V0Q2VudGVyWzFdICs9IG5vZGVMYXlvdXQueTtcbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogbGF5b3V0SW5mby53aWR0aCAvIDIgLSB0YXJnZXRDZW50ZXJbMF0sXG4gICAgeTogbGF5b3V0SW5mby5oZWlnaHQgLyAyIC0gdGFyZ2V0Q2VudGVyWzFdXG4gIH07XG59XG4vLyBNYXJrIG5vZGVzIHZpc2libGUgZm9yIHBydW5uaW5nIHdoZW4gdmlzdWFsIGNvZGluZyBhbmQgcmVuZGVyaW5nLlxuLy8gUHJ1bm5pbmcgZGVwZW5kcyBvbiBsYXlvdXQgYW5kIHJvb3QgcG9zaXRpb24sIHNvIHdlIGhhdmUgdG8gZG8gaXQgYWZ0ZXIgbGF5b3V0LlxuZnVuY3Rpb24gcHJ1bm5pbmcobm9kZSwgY2xpcFJlY3QsIHZpZXdBYm92ZVBhdGgsIHZpZXdSb290LCBkZXB0aCkge1xuICB2YXIgbm9kZUxheW91dCA9IG5vZGUuZ2V0TGF5b3V0KCk7XG4gIHZhciBub2RlSW5WaWV3QWJvdmVQYXRoID0gdmlld0Fib3ZlUGF0aFtkZXB0aF07XG4gIHZhciBpc0Fib3ZlVmlld1Jvb3QgPSBub2RlSW5WaWV3QWJvdmVQYXRoICYmIG5vZGVJblZpZXdBYm92ZVBhdGggPT09IG5vZGU7XG4gIGlmIChub2RlSW5WaWV3QWJvdmVQYXRoICYmICFpc0Fib3ZlVmlld1Jvb3QgfHwgZGVwdGggPT09IHZpZXdBYm92ZVBhdGgubGVuZ3RoICYmIG5vZGUgIT09IHZpZXdSb290KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG5vZGUuc2V0TGF5b3V0KHtcbiAgICAvLyBpc0luVmlldyBtZWFuczogdmlld1Jvb3Qgc3ViIHRyZWUgKyB2aWV3QWJvdmVQYXRoXG4gICAgaXNJblZpZXc6IHRydWUsXG4gICAgLy8gaW52aXNpYmxlIG9ubHkgbWVhbnM6IG91dHNpZGUgdmlldyBjbGlwIHNvIHRoYXQgdGhlIG5vZGUgY2FuIG5vdFxuICAgIC8vIHNlZSBidXQgc3RpbGwgbGF5b3V0IGZvciBhbmltYXRpb24gcHJlcGFyYXRpb24gYnV0IG5vdCByZW5kZXIuXG4gICAgaW52aXNpYmxlOiAhaXNBYm92ZVZpZXdSb290ICYmICFjbGlwUmVjdC5pbnRlcnNlY3Qobm9kZUxheW91dCksXG4gICAgaXNBYm92ZVZpZXdSb290OiBpc0Fib3ZlVmlld1Jvb3RcbiAgfSwgdHJ1ZSk7XG4gIC8vIFRyYW5zZm9ybSB0byBjaGlsZCBjb29yZGluYXRlLlxuICB2YXIgY2hpbGRDbGlwUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoY2xpcFJlY3QueCAtIG5vZGVMYXlvdXQueCwgY2xpcFJlY3QueSAtIG5vZGVMYXlvdXQueSwgY2xpcFJlY3Qud2lkdGgsIGNsaXBSZWN0LmhlaWdodCk7XG4gIGVhY2gobm9kZS52aWV3Q2hpbGRyZW4gfHwgW10sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHBydW5uaW5nKGNoaWxkLCBjaGlsZENsaXBSZWN0LCB2aWV3QWJvdmVQYXRoLCB2aWV3Um9vdCwgZGVwdGggKyAxKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRVcHBlckxhYmVsSGVpZ2h0KG1vZGVsKSB7XG4gIHJldHVybiBtb2RlbC5nZXQoUEFUSF9VUFBFUl9MQUJFTF9TSE9XKSA/IG1vZGVsLmdldChQQVRIX1VQUEVSX0xBQkVMX0hFSUdIVCkgOiAwO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgaW5zdGFsbFRyZWVtYXBBY3Rpb24gfSBmcm9tICcuL3RyZWVtYXBBY3Rpb24uanMnO1xuaW1wb3J0IFRyZWVtYXBTZXJpZXNNb2RlbCBmcm9tICcuL1RyZWVtYXBTZXJpZXMuanMnO1xuaW1wb3J0IFRyZWVtYXBWaWV3IGZyb20gJy4vVHJlZW1hcFZpZXcuanMnO1xuaW1wb3J0IHRyZWVtYXBWaXN1YWwgZnJvbSAnLi90cmVlbWFwVmlzdWFsLmpzJztcbmltcG9ydCB0cmVlbWFwTGF5b3V0IGZyb20gJy4vdHJlZW1hcExheW91dC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU2VyaWVzTW9kZWwoVHJlZW1hcFNlcmllc01vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ2hhcnRWaWV3KFRyZWVtYXBWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyVmlzdWFsKHRyZWVtYXBWaXN1YWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJMYXlvdXQodHJlZW1hcExheW91dCk7XG4gIGluc3RhbGxUcmVlbWFwQWN0aW9uKHJlZ2lzdGVycyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///49917\n")},99952:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/extension.js\nvar extension = __webpack_require__(3087);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createSeriesData.js\nvar createSeriesData = __webpack_require__(13637);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n;// ./node_modules/echarts/lib/chart/scatter/ScatterSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar ScatterSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ScatterSeriesModel, _super);\n  function ScatterSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ScatterSeriesModel.type;\n    _this.hasSymbolVisual = true;\n    return _this;\n  }\n  ScatterSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    return (0,createSeriesData/* default */.A)(null, this, {\n      useEncodeDefaulter: true\n    });\n  };\n  ScatterSeriesModel.prototype.getProgressive = function () {\n    var progressive = this.option.progressive;\n    if (progressive == null) {\n      // PENDING\n      return this.option.large ? 5e3 : this.get('progressive');\n    }\n    return progressive;\n  };\n  ScatterSeriesModel.prototype.getProgressiveThreshold = function () {\n    var progressiveThreshold = this.option.progressiveThreshold;\n    if (progressiveThreshold == null) {\n      // PENDING\n      return this.option.large ? 1e4 : this.get('progressiveThreshold');\n    }\n    return progressiveThreshold;\n  };\n  ScatterSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {\n    return selectors.point(data.getItemLayout(dataIndex));\n  };\n  ScatterSeriesModel.prototype.getZLevelKey = function () {\n    // Each progressive series has individual key.\n    return this.getData().count() > this.getProgressiveThreshold() ? this.id : '';\n  };\n  ScatterSeriesModel.type = 'series.scatter';\n  ScatterSeriesModel.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar'];\n  ScatterSeriesModel.defaultOption = {\n    coordinateSystem: 'cartesian2d',\n    // zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    symbolSize: 10,\n    // symbolRotate: null,  // 图形旋转控制\n    large: false,\n    // Available when large is true\n    largeThreshold: 2000,\n    // cursor: null,\n    itemStyle: {\n      opacity: 0.8\n      // color: 各异\n    },\n    emphasis: {\n      scale: true\n    },\n    // If clip the overflow graphics\n    // Works on cartesian / polar series\n    clip: true,\n    select: {\n      itemStyle: {\n        borderColor: '#212121'\n      }\n    },\n    universalTransition: {\n      divideShape: 'clone'\n    }\n    // progressive: null\n  };\n  return ScatterSeriesModel;\n}(Series/* default */.A);\n/* harmony default export */ const ScatterSeries = (ScatterSeriesModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/SymbolDraw.js\nvar SymbolDraw = __webpack_require__(18386);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/LargeSymbolDraw.js\nvar LargeSymbolDraw = __webpack_require__(94583);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/layout/points.js\nvar points = __webpack_require__(30682);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n;// ./node_modules/echarts/lib/chart/scatter/ScatterView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar ScatterView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ScatterView, _super);\n  function ScatterView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ScatterView.type;\n    return _this;\n  }\n  ScatterView.prototype.render = function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    var symbolDraw = this._updateSymbolDraw(data, seriesModel);\n    symbolDraw.updateData(data, {\n      // TODO\n      // If this parameter should be a shape or a bounding volume\n      // shape will be more general.\n      // But bounding volume like bounding rect will be much faster in the contain calculation\n      clipShape: this._getClipShape(seriesModel)\n    });\n    this._finished = true;\n  };\n  ScatterView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    var symbolDraw = this._updateSymbolDraw(data, seriesModel);\n    symbolDraw.incrementalPrepareUpdate(data);\n    this._finished = false;\n  };\n  ScatterView.prototype.incrementalRender = function (taskParams, seriesModel, ecModel) {\n    this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {\n      clipShape: this._getClipShape(seriesModel)\n    });\n    this._finished = taskParams.end === seriesModel.getData().count();\n  };\n  ScatterView.prototype.updateTransform = function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    // Must mark group dirty and make sure the incremental layer will be cleared\n    // PENDING\n    this.group.dirty();\n    if (!this._finished || data.count() > 1e4) {\n      return {\n        update: true\n      };\n    } else {\n      var res = (0,points/* default */.A)('').reset(seriesModel, ecModel, api);\n      if (res.progress) {\n        res.progress({\n          start: 0,\n          end: data.count(),\n          count: data.count()\n        }, data);\n      }\n      this._symbolDraw.updateLayout(data);\n    }\n  };\n  ScatterView.prototype.eachRendered = function (cb) {\n    this._symbolDraw && this._symbolDraw.eachRendered(cb);\n  };\n  ScatterView.prototype._getClipShape = function (seriesModel) {\n    if (!seriesModel.get('clip', true)) {\n      return;\n    }\n    var coordSys = seriesModel.coordinateSystem;\n    // PENDING make `0.1` configurable, for example, `clipTolerance`?\n    return coordSys && coordSys.getArea && coordSys.getArea(.1);\n  };\n  ScatterView.prototype._updateSymbolDraw = function (data, seriesModel) {\n    var symbolDraw = this._symbolDraw;\n    var pipelineContext = seriesModel.pipelineContext;\n    var isLargeDraw = pipelineContext.large;\n    if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {\n      symbolDraw && symbolDraw.remove();\n      symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw/* default */.A() : new SymbolDraw/* default */.A();\n      this._isLargeDraw = isLargeDraw;\n      this.group.removeAll();\n    }\n    this.group.add(symbolDraw.group);\n    return symbolDraw;\n  };\n  ScatterView.prototype.remove = function (ecModel, api) {\n    this._symbolDraw && this._symbolDraw.remove(true);\n    this._symbolDraw = null;\n  };\n  ScatterView.prototype.dispose = function () {};\n  ScatterView.type = 'scatter';\n  return ScatterView;\n}(Chart/* default */.A);\n/* harmony default export */ const scatter_ScatterView = (ScatterView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/grid/installSimple.js\nvar installSimple = __webpack_require__(69446);\n;// ./node_modules/echarts/lib/chart/scatter/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nfunction install(registers) {\n  // In case developer forget to include grid component\n  (0,extension/* use */.Y)(installSimple/* install */.a);\n  registers.registerSeriesModel(ScatterSeries);\n  registers.registerChartView(scatter_ScatterView);\n  registers.registerLayout((0,points/* default */.A)('scatter'));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTk5NTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvc2NhdHRlci9TY2F0dGVyU2VyaWVzLmpzP2NjZmIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L3NjYXR0ZXIvU2NhdHRlclZpZXcuanM/MzkxMiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvc2NhdHRlci9pbnN0YWxsLmpzP2QyZjgiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBjcmVhdGVTZXJpZXNEYXRhIGZyb20gJy4uL2hlbHBlci9jcmVhdGVTZXJpZXNEYXRhLmpzJztcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9TZXJpZXMuanMnO1xudmFyIFNjYXR0ZXJTZXJpZXNNb2RlbCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTY2F0dGVyU2VyaWVzTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFNjYXR0ZXJTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gU2NhdHRlclNlcmllc01vZGVsLnR5cGU7XG4gICAgX3RoaXMuaGFzU3ltYm9sVmlzdWFsID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgU2NhdHRlclNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRJbml0aWFsRGF0YSA9IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICByZXR1cm4gY3JlYXRlU2VyaWVzRGF0YShudWxsLCB0aGlzLCB7XG4gICAgICB1c2VFbmNvZGVEZWZhdWx0ZXI6IHRydWVcbiAgICB9KTtcbiAgfTtcbiAgU2NhdHRlclNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRQcm9ncmVzc2l2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvZ3Jlc3NpdmUgPSB0aGlzLm9wdGlvbi5wcm9ncmVzc2l2ZTtcbiAgICBpZiAocHJvZ3Jlc3NpdmUgPT0gbnVsbCkge1xuICAgICAgLy8gUEVORElOR1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9uLmxhcmdlID8gNWUzIDogdGhpcy5nZXQoJ3Byb2dyZXNzaXZlJyk7XG4gICAgfVxuICAgIHJldHVybiBwcm9ncmVzc2l2ZTtcbiAgfTtcbiAgU2NhdHRlclNlcmllc01vZGVsLnByb3RvdHlwZS5nZXRQcm9ncmVzc2l2ZVRocmVzaG9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvZ3Jlc3NpdmVUaHJlc2hvbGQgPSB0aGlzLm9wdGlvbi5wcm9ncmVzc2l2ZVRocmVzaG9sZDtcbiAgICBpZiAocHJvZ3Jlc3NpdmVUaHJlc2hvbGQgPT0gbnVsbCkge1xuICAgICAgLy8gUEVORElOR1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9uLmxhcmdlID8gMWU0IDogdGhpcy5nZXQoJ3Byb2dyZXNzaXZlVGhyZXNob2xkJyk7XG4gICAgfVxuICAgIHJldHVybiBwcm9ncmVzc2l2ZVRocmVzaG9sZDtcbiAgfTtcbiAgU2NhdHRlclNlcmllc01vZGVsLnByb3RvdHlwZS5icnVzaFNlbGVjdG9yID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgZGF0YSwgc2VsZWN0b3JzKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9ycy5wb2ludChkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KSk7XG4gIH07XG4gIFNjYXR0ZXJTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0WkxldmVsS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEVhY2ggcHJvZ3Jlc3NpdmUgc2VyaWVzIGhhcyBpbmRpdmlkdWFsIGtleS5cbiAgICByZXR1cm4gdGhpcy5nZXREYXRhKCkuY291bnQoKSA+IHRoaXMuZ2V0UHJvZ3Jlc3NpdmVUaHJlc2hvbGQoKSA/IHRoaXMuaWQgOiAnJztcbiAgfTtcbiAgU2NhdHRlclNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLnNjYXR0ZXInO1xuICBTY2F0dGVyU2VyaWVzTW9kZWwuZGVwZW5kZW5jaWVzID0gWydncmlkJywgJ3BvbGFyJywgJ2dlbycsICdzaW5nbGVBeGlzJywgJ2NhbGVuZGFyJ107XG4gIFNjYXR0ZXJTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdjYXJ0ZXNpYW4yZCcsXG4gICAgLy8gemxldmVsOiAwLFxuICAgIHo6IDIsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIHN5bWJvbFNpemU6IDEwLFxuICAgIC8vIHN5bWJvbFJvdGF0ZTogbnVsbCwgIC8vIOWbvuW9ouaXi+i9rOaOp+WItlxuICAgIGxhcmdlOiBmYWxzZSxcbiAgICAvLyBBdmFpbGFibGUgd2hlbiBsYXJnZSBpcyB0cnVlXG4gICAgbGFyZ2VUaHJlc2hvbGQ6IDIwMDAsXG4gICAgLy8gY3Vyc29yOiBudWxsLFxuICAgIGl0ZW1TdHlsZToge1xuICAgICAgb3BhY2l0eTogMC44XG4gICAgICAvLyBjb2xvcjog5ZCE5byCXG4gICAgfSxcbiAgICBlbXBoYXNpczoge1xuICAgICAgc2NhbGU6IHRydWVcbiAgICB9LFxuICAgIC8vIElmIGNsaXAgdGhlIG92ZXJmbG93IGdyYXBoaWNzXG4gICAgLy8gV29ya3Mgb24gY2FydGVzaWFuIC8gcG9sYXIgc2VyaWVzXG4gICAgY2xpcDogdHJ1ZSxcbiAgICBzZWxlY3Q6IHtcbiAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICBib3JkZXJDb2xvcjogJyMyMTIxMjEnXG4gICAgICB9XG4gICAgfSxcbiAgICB1bml2ZXJzYWxUcmFuc2l0aW9uOiB7XG4gICAgICBkaXZpZGVTaGFwZTogJ2Nsb25lJ1xuICAgIH1cbiAgICAvLyBwcm9ncmVzc2l2ZTogbnVsbFxuICB9O1xuICByZXR1cm4gU2NhdHRlclNlcmllc01vZGVsO1xufShTZXJpZXNNb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBTY2F0dGVyU2VyaWVzTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBTeW1ib2xEcmF3IGZyb20gJy4uL2hlbHBlci9TeW1ib2xEcmF3LmpzJztcbmltcG9ydCBMYXJnZVN5bWJvbERyYXcgZnJvbSAnLi4vaGVscGVyL0xhcmdlU3ltYm9sRHJhdy5qcyc7XG5pbXBvcnQgcG9pbnRzTGF5b3V0IGZyb20gJy4uLy4uL2xheW91dC9wb2ludHMuanMnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi8uLi92aWV3L0NoYXJ0LmpzJztcbnZhciBTY2F0dGVyVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTY2F0dGVyVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gU2NhdHRlclZpZXcoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IFNjYXR0ZXJWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFNjYXR0ZXJWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBzeW1ib2xEcmF3ID0gdGhpcy5fdXBkYXRlU3ltYm9sRHJhdyhkYXRhLCBzZXJpZXNNb2RlbCk7XG4gICAgc3ltYm9sRHJhdy51cGRhdGVEYXRhKGRhdGEsIHtcbiAgICAgIC8vIFRPRE9cbiAgICAgIC8vIElmIHRoaXMgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHNoYXBlIG9yIGEgYm91bmRpbmcgdm9sdW1lXG4gICAgICAvLyBzaGFwZSB3aWxsIGJlIG1vcmUgZ2VuZXJhbC5cbiAgICAgIC8vIEJ1dCBib3VuZGluZyB2b2x1bWUgbGlrZSBib3VuZGluZyByZWN0IHdpbGwgYmUgbXVjaCBmYXN0ZXIgaW4gdGhlIGNvbnRhaW4gY2FsY3VsYXRpb25cbiAgICAgIGNsaXBTaGFwZTogdGhpcy5fZ2V0Q2xpcFNoYXBlKHNlcmllc01vZGVsKVxuICAgIH0pO1xuICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgfTtcbiAgU2NhdHRlclZpZXcucHJvdG90eXBlLmluY3JlbWVudGFsUHJlcGFyZVJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHN5bWJvbERyYXcgPSB0aGlzLl91cGRhdGVTeW1ib2xEcmF3KGRhdGEsIHNlcmllc01vZGVsKTtcbiAgICBzeW1ib2xEcmF3LmluY3JlbWVudGFsUHJlcGFyZVVwZGF0ZShkYXRhKTtcbiAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICB9O1xuICBTY2F0dGVyVmlldy5wcm90b3R5cGUuaW5jcmVtZW50YWxSZW5kZXIgPSBmdW5jdGlvbiAodGFza1BhcmFtcywgc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICB0aGlzLl9zeW1ib2xEcmF3LmluY3JlbWVudGFsVXBkYXRlKHRhc2tQYXJhbXMsIHNlcmllc01vZGVsLmdldERhdGEoKSwge1xuICAgICAgY2xpcFNoYXBlOiB0aGlzLl9nZXRDbGlwU2hhcGUoc2VyaWVzTW9kZWwpXG4gICAgfSk7XG4gICAgdGhpcy5fZmluaXNoZWQgPSB0YXNrUGFyYW1zLmVuZCA9PT0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmNvdW50KCk7XG4gIH07XG4gIFNjYXR0ZXJWaWV3LnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIC8vIE11c3QgbWFyayBncm91cCBkaXJ0eSBhbmQgbWFrZSBzdXJlIHRoZSBpbmNyZW1lbnRhbCBsYXllciB3aWxsIGJlIGNsZWFyZWRcbiAgICAvLyBQRU5ESU5HXG4gICAgdGhpcy5ncm91cC5kaXJ0eSgpO1xuICAgIGlmICghdGhpcy5fZmluaXNoZWQgfHwgZGF0YS5jb3VudCgpID4gMWU0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGU6IHRydWVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXMgPSBwb2ludHNMYXlvdXQoJycpLnJlc2V0KHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgaWYgKHJlcy5wcm9ncmVzcykge1xuICAgICAgICByZXMucHJvZ3Jlc3Moe1xuICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgIGVuZDogZGF0YS5jb3VudCgpLFxuICAgICAgICAgIGNvdW50OiBkYXRhLmNvdW50KClcbiAgICAgICAgfSwgZGF0YSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zeW1ib2xEcmF3LnVwZGF0ZUxheW91dChkYXRhKTtcbiAgICB9XG4gIH07XG4gIFNjYXR0ZXJWaWV3LnByb3RvdHlwZS5lYWNoUmVuZGVyZWQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB0aGlzLl9zeW1ib2xEcmF3ICYmIHRoaXMuX3N5bWJvbERyYXcuZWFjaFJlbmRlcmVkKGNiKTtcbiAgfTtcbiAgU2NhdHRlclZpZXcucHJvdG90eXBlLl9nZXRDbGlwU2hhcGUgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICBpZiAoIXNlcmllc01vZGVsLmdldCgnY2xpcCcsIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgLy8gUEVORElORyBtYWtlIGAwLjFgIGNvbmZpZ3VyYWJsZSwgZm9yIGV4YW1wbGUsIGBjbGlwVG9sZXJhbmNlYD9cbiAgICByZXR1cm4gY29vcmRTeXMgJiYgY29vcmRTeXMuZ2V0QXJlYSAmJiBjb29yZFN5cy5nZXRBcmVhKC4xKTtcbiAgfTtcbiAgU2NhdHRlclZpZXcucHJvdG90eXBlLl91cGRhdGVTeW1ib2xEcmF3ID0gZnVuY3Rpb24gKGRhdGEsIHNlcmllc01vZGVsKSB7XG4gICAgdmFyIHN5bWJvbERyYXcgPSB0aGlzLl9zeW1ib2xEcmF3O1xuICAgIHZhciBwaXBlbGluZUNvbnRleHQgPSBzZXJpZXNNb2RlbC5waXBlbGluZUNvbnRleHQ7XG4gICAgdmFyIGlzTGFyZ2VEcmF3ID0gcGlwZWxpbmVDb250ZXh0LmxhcmdlO1xuICAgIGlmICghc3ltYm9sRHJhdyB8fCBpc0xhcmdlRHJhdyAhPT0gdGhpcy5faXNMYXJnZURyYXcpIHtcbiAgICAgIHN5bWJvbERyYXcgJiYgc3ltYm9sRHJhdy5yZW1vdmUoKTtcbiAgICAgIHN5bWJvbERyYXcgPSB0aGlzLl9zeW1ib2xEcmF3ID0gaXNMYXJnZURyYXcgPyBuZXcgTGFyZ2VTeW1ib2xEcmF3KCkgOiBuZXcgU3ltYm9sRHJhdygpO1xuICAgICAgdGhpcy5faXNMYXJnZURyYXcgPSBpc0xhcmdlRHJhdztcbiAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgfVxuICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbERyYXcuZ3JvdXApO1xuICAgIHJldHVybiBzeW1ib2xEcmF3O1xuICB9O1xuICBTY2F0dGVyVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMuX3N5bWJvbERyYXcgJiYgdGhpcy5fc3ltYm9sRHJhdy5yZW1vdmUodHJ1ZSk7XG4gICAgdGhpcy5fc3ltYm9sRHJhdyA9IG51bGw7XG4gIH07XG4gIFNjYXR0ZXJWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG4gIFNjYXR0ZXJWaWV3LnR5cGUgPSAnc2NhdHRlcic7XG4gIHJldHVybiBTY2F0dGVyVmlldztcbn0oQ2hhcnRWaWV3KTtcbmV4cG9ydCBkZWZhdWx0IFNjYXR0ZXJWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgdXNlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9uLmpzJztcbmltcG9ydCBTY2F0dGVyU2VyaWVzTW9kZWwgZnJvbSAnLi9TY2F0dGVyU2VyaWVzLmpzJztcbmltcG9ydCBTY2F0dGVyVmlldyBmcm9tICcuL1NjYXR0ZXJWaWV3LmpzJztcbmltcG9ydCB7IGluc3RhbGwgYXMgaW5zdGFsbEdyaWRTaW1wbGUgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvZ3JpZC9pbnN0YWxsU2ltcGxlLmpzJztcbmltcG9ydCBsYXlvdXRQb2ludHMgZnJvbSAnLi4vLi4vbGF5b3V0L3BvaW50cy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgLy8gSW4gY2FzZSBkZXZlbG9wZXIgZm9yZ2V0IHRvIGluY2x1ZGUgZ3JpZCBjb21wb25lbnRcbiAgdXNlKGluc3RhbGxHcmlkU2ltcGxlKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU2VyaWVzTW9kZWwoU2NhdHRlclNlcmllc01vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ2hhcnRWaWV3KFNjYXR0ZXJWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KGxheW91dFBvaW50cygnc2NhdHRlcicpKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///99952\n")}}]);