"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[9597],{16563:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nfunction dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {\n  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;\n}\nfunction defaultKeyGetter(item) {\n  return item;\n}\nvar DataDiffer = /** @class */function () {\n  /**\r\n   * @param context Can be visited by this.context in callback.\r\n   */\n  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context,\n  // By default: 'oneToOne'.\n  diffMode) {\n    this._old = oldArr;\n    this._new = newArr;\n    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n    this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    // Visible in callback via `this.context`;\n    this.context = context;\n    this._diffModeMultiple = diffMode === 'multiple';\n  }\n  /**\r\n   * Callback function when add a data\r\n   */\n  DataDiffer.prototype.add = function (func) {\n    this._add = func;\n    return this;\n  };\n  /**\r\n   * Callback function when update a data\r\n   */\n  DataDiffer.prototype.update = function (func) {\n    this._update = func;\n    return this;\n  };\n  /**\r\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\r\n   */\n  DataDiffer.prototype.updateManyToOne = function (func) {\n    this._updateManyToOne = func;\n    return this;\n  };\n  /**\r\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\r\n   */\n  DataDiffer.prototype.updateOneToMany = function (func) {\n    this._updateOneToMany = func;\n    return this;\n  };\n  /**\r\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\r\n   */\n  DataDiffer.prototype.updateManyToMany = function (func) {\n    this._updateManyToMany = func;\n    return this;\n  };\n  /**\r\n   * Callback function when remove a data\r\n   */\n  DataDiffer.prototype.remove = function (func) {\n    this._remove = func;\n    return this;\n  };\n  DataDiffer.prototype.execute = function () {\n    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();\n  };\n  DataDiffer.prototype._executeOneToOne = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var newDataIndexMap = {};\n    var oldDataKeyArr = new Array(oldArr.length);\n    var newDataKeyArr = new Array(newArr.length);\n    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n    for (var i = 0; i < oldArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n      // idx can never be empty array here. see 'set null' logic below.\n      if (newIdxMapValLen > 1) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var newIdx = newIdxMapVal.shift();\n        if (newIdxMapVal.length === 1) {\n          newDataIndexMap[oldKey] = newIdxMapVal[0];\n        }\n        this._update && this._update(newIdx, i);\n      } else if (newIdxMapValLen === 1) {\n        newDataIndexMap[oldKey] = null;\n        this._update && this._update(newIdxMapVal, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  /**\r\n   * For example, consider the case:\r\n   * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],\r\n   * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],\r\n   * Where:\r\n   *     o0, o1, n0 has key 'a' (many to one)\r\n   *     o5, n4, n5, n6 has key 'b' (one to many)\r\n   *     o2, n1 has key 'c' (one to one)\r\n   *     n2, n3 has key 'd' (add)\r\n   *     o3, o4 has key 'e' (remove)\r\n   *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)\r\n   * Then:\r\n   *     (The order of the following directives are not ensured.)\r\n   *     this._updateManyToOne(n0, [o0, o1]);\r\n   *     this._updateOneToMany([n4, n5, n6], o5);\r\n   *     this._update(n1, o2);\r\n   *     this._remove(o3);\r\n   *     this._remove(o4);\r\n   *     this._remove(o6);\r\n   *     this._remove(o7);\r\n   *     this._add(n2);\r\n   *     this._add(n3);\r\n   *     this._add(n7);\r\n   *     this._add(n8);\r\n   */\n  DataDiffer.prototype._executeMultiple = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n    for (var i = 0; i < oldDataKeyArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var oldIdxMapVal = oldDataIndexMap[oldKey];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {\n        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {\n        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {\n        this._update && this._update(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {\n        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1) {\n        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {\n          this._remove && this._remove(oldIdxMapVal[i_1]);\n        }\n      } else {\n        this._remove && this._remove(oldIdxMapVal);\n      }\n    }\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var newKey = newDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[newKey];\n      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n      if (idxMapValLen > 1) {\n        for (var j = 0; j < idxMapValLen; j++) {\n          this._add && this._add(newIdxMapVal[j]);\n        }\n      } else if (idxMapValLen === 1) {\n        this._add && this._add(newIdxMapVal);\n      }\n      // Support both `newDataKeyArr` are duplication removed or not removed.\n      newDataIndexMap[newKey] = null;\n    }\n  };\n  DataDiffer.prototype._initIndexMap = function (arr,\n  // Can be null.\n  map,\n  // In 'byKey', the output `keyArr` is duplication removed.\n  // In 'byIndex', the output `keyArr` is not duplication removed and\n  //     its indices are accurately corresponding to `arr`.\n  keyArr, keyGetterName) {\n    var cbModeMultiple = this._diffModeMultiple;\n    for (var i = 0; i < arr.length; i++) {\n      // Add prefix to avoid conflict with Object.prototype.\n      var key = '_ec_' + this[keyGetterName](arr[i], i);\n      if (!cbModeMultiple) {\n        keyArr[i] = key;\n      }\n      if (!map) {\n        continue;\n      }\n      var idxMapVal = map[key];\n      var idxMapValLen = dataIndexMapValueLength(idxMapVal);\n      if (idxMapValLen === 0) {\n        // Simple optimize: in most cases, one index has one key,\n        // do not need array.\n        map[key] = i;\n        if (cbModeMultiple) {\n          keyArr.push(key);\n        }\n      } else if (idxMapValLen === 1) {\n        map[key] = [idxMapVal, i];\n      } else {\n        idxMapVal.push(i);\n      }\n    }\n  };\n  return DataDiffer;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataDiffer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY1NjMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9EYXRhRGlmZmVyLmpzP2E0Y2UiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5mdW5jdGlvbiBkYXRhSW5kZXhNYXBWYWx1ZUxlbmd0aCh2YWxOdW1PckFyckxlbmd0aE1vcmVUaGFuMikge1xuICByZXR1cm4gdmFsTnVtT3JBcnJMZW5ndGhNb3JlVGhhbjIgPT0gbnVsbCA/IDAgOiB2YWxOdW1PckFyckxlbmd0aE1vcmVUaGFuMi5sZW5ndGggfHwgMTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRLZXlHZXR0ZXIoaXRlbSkge1xuICByZXR1cm4gaXRlbTtcbn1cbnZhciBEYXRhRGlmZmVyID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIGNvbnRleHQgQ2FuIGJlIHZpc2l0ZWQgYnkgdGhpcy5jb250ZXh0IGluIGNhbGxiYWNrLlxyXG4gICAqL1xuICBmdW5jdGlvbiBEYXRhRGlmZmVyKG9sZEFyciwgbmV3QXJyLCBvbGRLZXlHZXR0ZXIsIG5ld0tleUdldHRlciwgY29udGV4dCxcbiAgLy8gQnkgZGVmYXVsdDogJ29uZVRvT25lJy5cbiAgZGlmZk1vZGUpIHtcbiAgICB0aGlzLl9vbGQgPSBvbGRBcnI7XG4gICAgdGhpcy5fbmV3ID0gbmV3QXJyO1xuICAgIHRoaXMuX29sZEtleUdldHRlciA9IG9sZEtleUdldHRlciB8fCBkZWZhdWx0S2V5R2V0dGVyO1xuICAgIHRoaXMuX25ld0tleUdldHRlciA9IG5ld0tleUdldHRlciB8fCBkZWZhdWx0S2V5R2V0dGVyO1xuICAgIC8vIFZpc2libGUgaW4gY2FsbGJhY2sgdmlhIGB0aGlzLmNvbnRleHRgO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fZGlmZk1vZGVNdWx0aXBsZSA9IGRpZmZNb2RlID09PSAnbXVsdGlwbGUnO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYWRkIGEgZGF0YVxyXG4gICAqL1xuICBEYXRhRGlmZmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIHRoaXMuX2FkZCA9IGZ1bmM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdXBkYXRlIGEgZGF0YVxyXG4gICAqL1xuICBEYXRhRGlmZmVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdXBkYXRlIGEgZGF0YSBhbmQgb25seSB3b3JrIGluIGBjYk1vZGU6ICdieUtleSdgLlxyXG4gICAqL1xuICBEYXRhRGlmZmVyLnByb3RvdHlwZS51cGRhdGVNYW55VG9PbmUgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIHRoaXMuX3VwZGF0ZU1hbnlUb09uZSA9IGZ1bmM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdXBkYXRlIGEgZGF0YSBhbmQgb25seSB3b3JrIGluIGBjYk1vZGU6ICdieUtleSdgLlxyXG4gICAqL1xuICBEYXRhRGlmZmVyLnByb3RvdHlwZS51cGRhdGVPbmVUb01hbnkgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIHRoaXMuX3VwZGF0ZU9uZVRvTWFueSA9IGZ1bmM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdXBkYXRlIGEgZGF0YSBhbmQgb25seSB3b3JrIGluIGBjYk1vZGU6ICdieUtleSdgLlxyXG4gICAqL1xuICBEYXRhRGlmZmVyLnByb3RvdHlwZS51cGRhdGVNYW55VG9NYW55ID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICB0aGlzLl91cGRhdGVNYW55VG9NYW55ID0gZnVuYztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gd2hlbiByZW1vdmUgYSBkYXRhXHJcbiAgICovXG4gIERhdGFEaWZmZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgdGhpcy5fcmVtb3ZlID0gZnVuYztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgRGF0YURpZmZlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzW3RoaXMuX2RpZmZNb2RlTXVsdGlwbGUgPyAnX2V4ZWN1dGVNdWx0aXBsZScgOiAnX2V4ZWN1dGVPbmVUb09uZSddKCk7XG4gIH07XG4gIERhdGFEaWZmZXIucHJvdG90eXBlLl9leGVjdXRlT25lVG9PbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9sZEFyciA9IHRoaXMuX29sZDtcbiAgICB2YXIgbmV3QXJyID0gdGhpcy5fbmV3O1xuICAgIHZhciBuZXdEYXRhSW5kZXhNYXAgPSB7fTtcbiAgICB2YXIgb2xkRGF0YUtleUFyciA9IG5ldyBBcnJheShvbGRBcnIubGVuZ3RoKTtcbiAgICB2YXIgbmV3RGF0YUtleUFyciA9IG5ldyBBcnJheShuZXdBcnIubGVuZ3RoKTtcbiAgICB0aGlzLl9pbml0SW5kZXhNYXAob2xkQXJyLCBudWxsLCBvbGREYXRhS2V5QXJyLCAnX29sZEtleUdldHRlcicpO1xuICAgIHRoaXMuX2luaXRJbmRleE1hcChuZXdBcnIsIG5ld0RhdGFJbmRleE1hcCwgbmV3RGF0YUtleUFyciwgJ19uZXdLZXlHZXR0ZXInKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG9sZEtleSA9IG9sZERhdGFLZXlBcnJbaV07XG4gICAgICB2YXIgbmV3SWR4TWFwVmFsID0gbmV3RGF0YUluZGV4TWFwW29sZEtleV07XG4gICAgICB2YXIgbmV3SWR4TWFwVmFsTGVuID0gZGF0YUluZGV4TWFwVmFsdWVMZW5ndGgobmV3SWR4TWFwVmFsKTtcbiAgICAgIC8vIGlkeCBjYW4gbmV2ZXIgYmUgZW1wdHkgYXJyYXkgaGVyZS4gc2VlICdzZXQgbnVsbCcgbG9naWMgYmVsb3cuXG4gICAgICBpZiAobmV3SWR4TWFwVmFsTGVuID4gMSkge1xuICAgICAgICAvLyBDb25zaWRlciB0aGVyZSBpcyBkdXBsaWNhdGUga2V5IChmb3IgZXhhbXBsZSwgdXNlIGRhdGFJdGVtLm5hbWUgYXMga2V5KS5cbiAgICAgICAgLy8gV2Ugc2hvdWxkIG1ha2Ugc3VyZSBldmVyeSBpdGVtIGluIG5ld0FyciBhbmQgb2xkQXJyIGNhbiBiZSB2aXNpdGVkLlxuICAgICAgICB2YXIgbmV3SWR4ID0gbmV3SWR4TWFwVmFsLnNoaWZ0KCk7XG4gICAgICAgIGlmIChuZXdJZHhNYXBWYWwubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbmV3RGF0YUluZGV4TWFwW29sZEtleV0gPSBuZXdJZHhNYXBWYWxbMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlICYmIHRoaXMuX3VwZGF0ZShuZXdJZHgsIGkpO1xuICAgICAgfSBlbHNlIGlmIChuZXdJZHhNYXBWYWxMZW4gPT09IDEpIHtcbiAgICAgICAgbmV3RGF0YUluZGV4TWFwW29sZEtleV0gPSBudWxsO1xuICAgICAgICB0aGlzLl91cGRhdGUgJiYgdGhpcy5fdXBkYXRlKG5ld0lkeE1hcFZhbCwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmUgJiYgdGhpcy5fcmVtb3ZlKGkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9wZXJmb3JtUmVzdEFkZChuZXdEYXRhS2V5QXJyLCBuZXdEYXRhSW5kZXhNYXApO1xuICB9O1xuICAvKipcclxuICAgKiBGb3IgZXhhbXBsZSwgY29uc2lkZXIgdGhlIGNhc2U6XHJcbiAgICogb2xkRGF0YTogW28wLCBvMSwgbzIsIG8zLCBvNCwgbzUsIG82LCBvN10sXHJcbiAgICogbmV3RGF0YTogW24wLCBuMSwgbjIsIG4zLCBuNCwgbjUsIG42LCBuNywgbjhdLFxyXG4gICAqIFdoZXJlOlxyXG4gICAqICAgICBvMCwgbzEsIG4wIGhhcyBrZXkgJ2EnIChtYW55IHRvIG9uZSlcclxuICAgKiAgICAgbzUsIG40LCBuNSwgbjYgaGFzIGtleSAnYicgKG9uZSB0byBtYW55KVxyXG4gICAqICAgICBvMiwgbjEgaGFzIGtleSAnYycgKG9uZSB0byBvbmUpXHJcbiAgICogICAgIG4yLCBuMyBoYXMga2V5ICdkJyAoYWRkKVxyXG4gICAqICAgICBvMywgbzQgaGFzIGtleSAnZScgKHJlbW92ZSlcclxuICAgKiAgICAgbzYsIG83LCBuNywgbjggaGFzIGtleSAnZicgKG1hbnkgdG8gbWFueSwgdHJlYXRlZCBhcyBhZGQgYW5kIHJlbW92ZSlcclxuICAgKiBUaGVuOlxyXG4gICAqICAgICAoVGhlIG9yZGVyIG9mIHRoZSBmb2xsb3dpbmcgZGlyZWN0aXZlcyBhcmUgbm90IGVuc3VyZWQuKVxyXG4gICAqICAgICB0aGlzLl91cGRhdGVNYW55VG9PbmUobjAsIFtvMCwgbzFdKTtcclxuICAgKiAgICAgdGhpcy5fdXBkYXRlT25lVG9NYW55KFtuNCwgbjUsIG42XSwgbzUpO1xyXG4gICAqICAgICB0aGlzLl91cGRhdGUobjEsIG8yKTtcclxuICAgKiAgICAgdGhpcy5fcmVtb3ZlKG8zKTtcclxuICAgKiAgICAgdGhpcy5fcmVtb3ZlKG80KTtcclxuICAgKiAgICAgdGhpcy5fcmVtb3ZlKG82KTtcclxuICAgKiAgICAgdGhpcy5fcmVtb3ZlKG83KTtcclxuICAgKiAgICAgdGhpcy5fYWRkKG4yKTtcclxuICAgKiAgICAgdGhpcy5fYWRkKG4zKTtcclxuICAgKiAgICAgdGhpcy5fYWRkKG43KTtcclxuICAgKiAgICAgdGhpcy5fYWRkKG44KTtcclxuICAgKi9cbiAgRGF0YURpZmZlci5wcm90b3R5cGUuX2V4ZWN1dGVNdWx0aXBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2xkQXJyID0gdGhpcy5fb2xkO1xuICAgIHZhciBuZXdBcnIgPSB0aGlzLl9uZXc7XG4gICAgdmFyIG9sZERhdGFJbmRleE1hcCA9IHt9O1xuICAgIHZhciBuZXdEYXRhSW5kZXhNYXAgPSB7fTtcbiAgICB2YXIgb2xkRGF0YUtleUFyciA9IFtdO1xuICAgIHZhciBuZXdEYXRhS2V5QXJyID0gW107XG4gICAgdGhpcy5faW5pdEluZGV4TWFwKG9sZEFyciwgb2xkRGF0YUluZGV4TWFwLCBvbGREYXRhS2V5QXJyLCAnX29sZEtleUdldHRlcicpO1xuICAgIHRoaXMuX2luaXRJbmRleE1hcChuZXdBcnIsIG5ld0RhdGFJbmRleE1hcCwgbmV3RGF0YUtleUFyciwgJ19uZXdLZXlHZXR0ZXInKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZERhdGFLZXlBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvbGRLZXkgPSBvbGREYXRhS2V5QXJyW2ldO1xuICAgICAgdmFyIG9sZElkeE1hcFZhbCA9IG9sZERhdGFJbmRleE1hcFtvbGRLZXldO1xuICAgICAgdmFyIG5ld0lkeE1hcFZhbCA9IG5ld0RhdGFJbmRleE1hcFtvbGRLZXldO1xuICAgICAgdmFyIG9sZElkeE1hcFZhbExlbiA9IGRhdGFJbmRleE1hcFZhbHVlTGVuZ3RoKG9sZElkeE1hcFZhbCk7XG4gICAgICB2YXIgbmV3SWR4TWFwVmFsTGVuID0gZGF0YUluZGV4TWFwVmFsdWVMZW5ndGgobmV3SWR4TWFwVmFsKTtcbiAgICAgIGlmIChvbGRJZHhNYXBWYWxMZW4gPiAxICYmIG5ld0lkeE1hcFZhbExlbiA9PT0gMSkge1xuICAgICAgICB0aGlzLl91cGRhdGVNYW55VG9PbmUgJiYgdGhpcy5fdXBkYXRlTWFueVRvT25lKG5ld0lkeE1hcFZhbCwgb2xkSWR4TWFwVmFsKTtcbiAgICAgICAgbmV3RGF0YUluZGV4TWFwW29sZEtleV0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChvbGRJZHhNYXBWYWxMZW4gPT09IDEgJiYgbmV3SWR4TWFwVmFsTGVuID4gMSkge1xuICAgICAgICB0aGlzLl91cGRhdGVPbmVUb01hbnkgJiYgdGhpcy5fdXBkYXRlT25lVG9NYW55KG5ld0lkeE1hcFZhbCwgb2xkSWR4TWFwVmFsKTtcbiAgICAgICAgbmV3RGF0YUluZGV4TWFwW29sZEtleV0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChvbGRJZHhNYXBWYWxMZW4gPT09IDEgJiYgbmV3SWR4TWFwVmFsTGVuID09PSAxKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSAmJiB0aGlzLl91cGRhdGUobmV3SWR4TWFwVmFsLCBvbGRJZHhNYXBWYWwpO1xuICAgICAgICBuZXdEYXRhSW5kZXhNYXBbb2xkS2V5XSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKG9sZElkeE1hcFZhbExlbiA+IDEgJiYgbmV3SWR4TWFwVmFsTGVuID4gMSkge1xuICAgICAgICB0aGlzLl91cGRhdGVNYW55VG9NYW55ICYmIHRoaXMuX3VwZGF0ZU1hbnlUb01hbnkobmV3SWR4TWFwVmFsLCBvbGRJZHhNYXBWYWwpO1xuICAgICAgICBuZXdEYXRhSW5kZXhNYXBbb2xkS2V5XSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKG9sZElkeE1hcFZhbExlbiA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgb2xkSWR4TWFwVmFsTGVuOyBpXzErKykge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZSAmJiB0aGlzLl9yZW1vdmUob2xkSWR4TWFwVmFsW2lfMV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmUgJiYgdGhpcy5fcmVtb3ZlKG9sZElkeE1hcFZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3BlcmZvcm1SZXN0QWRkKG5ld0RhdGFLZXlBcnIsIG5ld0RhdGFJbmRleE1hcCk7XG4gIH07XG4gIERhdGFEaWZmZXIucHJvdG90eXBlLl9wZXJmb3JtUmVzdEFkZCA9IGZ1bmN0aW9uIChuZXdEYXRhS2V5QXJyLCBuZXdEYXRhSW5kZXhNYXApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGFLZXlBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXdLZXkgPSBuZXdEYXRhS2V5QXJyW2ldO1xuICAgICAgdmFyIG5ld0lkeE1hcFZhbCA9IG5ld0RhdGFJbmRleE1hcFtuZXdLZXldO1xuICAgICAgdmFyIGlkeE1hcFZhbExlbiA9IGRhdGFJbmRleE1hcFZhbHVlTGVuZ3RoKG5ld0lkeE1hcFZhbCk7XG4gICAgICBpZiAoaWR4TWFwVmFsTGVuID4gMSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlkeE1hcFZhbExlbjsgaisrKSB7XG4gICAgICAgICAgdGhpcy5fYWRkICYmIHRoaXMuX2FkZChuZXdJZHhNYXBWYWxbal0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlkeE1hcFZhbExlbiA9PT0gMSkge1xuICAgICAgICB0aGlzLl9hZGQgJiYgdGhpcy5fYWRkKG5ld0lkeE1hcFZhbCk7XG4gICAgICB9XG4gICAgICAvLyBTdXBwb3J0IGJvdGggYG5ld0RhdGFLZXlBcnJgIGFyZSBkdXBsaWNhdGlvbiByZW1vdmVkIG9yIG5vdCByZW1vdmVkLlxuICAgICAgbmV3RGF0YUluZGV4TWFwW25ld0tleV0gPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgRGF0YURpZmZlci5wcm90b3R5cGUuX2luaXRJbmRleE1hcCA9IGZ1bmN0aW9uIChhcnIsXG4gIC8vIENhbiBiZSBudWxsLlxuICBtYXAsXG4gIC8vIEluICdieUtleScsIHRoZSBvdXRwdXQgYGtleUFycmAgaXMgZHVwbGljYXRpb24gcmVtb3ZlZC5cbiAgLy8gSW4gJ2J5SW5kZXgnLCB0aGUgb3V0cHV0IGBrZXlBcnJgIGlzIG5vdCBkdXBsaWNhdGlvbiByZW1vdmVkIGFuZFxuICAvLyAgICAgaXRzIGluZGljZXMgYXJlIGFjY3VyYXRlbHkgY29ycmVzcG9uZGluZyB0byBgYXJyYC5cbiAga2V5QXJyLCBrZXlHZXR0ZXJOYW1lKSB7XG4gICAgdmFyIGNiTW9kZU11bHRpcGxlID0gdGhpcy5fZGlmZk1vZGVNdWx0aXBsZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gQWRkIHByZWZpeCB0byBhdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUuXG4gICAgICB2YXIga2V5ID0gJ19lY18nICsgdGhpc1trZXlHZXR0ZXJOYW1lXShhcnJbaV0sIGkpO1xuICAgICAgaWYgKCFjYk1vZGVNdWx0aXBsZSkge1xuICAgICAgICBrZXlBcnJbaV0gPSBrZXk7XG4gICAgICB9XG4gICAgICBpZiAoIW1hcCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpZHhNYXBWYWwgPSBtYXBba2V5XTtcbiAgICAgIHZhciBpZHhNYXBWYWxMZW4gPSBkYXRhSW5kZXhNYXBWYWx1ZUxlbmd0aChpZHhNYXBWYWwpO1xuICAgICAgaWYgKGlkeE1hcFZhbExlbiA9PT0gMCkge1xuICAgICAgICAvLyBTaW1wbGUgb3B0aW1pemU6IGluIG1vc3QgY2FzZXMsIG9uZSBpbmRleCBoYXMgb25lIGtleSxcbiAgICAgICAgLy8gZG8gbm90IG5lZWQgYXJyYXkuXG4gICAgICAgIG1hcFtrZXldID0gaTtcbiAgICAgICAgaWYgKGNiTW9kZU11bHRpcGxlKSB7XG4gICAgICAgICAga2V5QXJyLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZHhNYXBWYWxMZW4gPT09IDEpIHtcbiAgICAgICAgbWFwW2tleV0gPSBbaWR4TWFwVmFsLCBpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeE1hcFZhbC5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIERhdGFEaWZmZXI7XG59KCk7XG5leHBvcnQgZGVmYXVsdCBEYXRhRGlmZmVyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16563\n")},70250:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A_: () => (/* binding */ CtorInt32Array),\n/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony exports CtorUint32Array, CtorUint16Array, CtorFloat64Array */\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31825);\n/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34310);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar UNDEFINED = 'undefined';\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n// Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;\n/**\r\n * Multi dimensional data store\r\n */\nvar dataCtors = {\n  'float': CtorFloat64Array,\n  'int': CtorInt32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': CtorFloat64Array\n};\nvar defaultDimValueGetters;\nfunction getIndicesCtor(rawCount) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n;\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n;\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor;\n  // Only shallow clone is enough when Array.\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\nfunction prepareStore(store, dimIdx, dimType, end, append) {\n  var DataCtor = dataCtors[dimType || 'float'];\n  if (append) {\n    var oldStore = store[dimIdx];\n    var oldLen = oldStore && oldStore.length;\n    if (!(oldLen === end)) {\n      var newStore = new DataCtor(end);\n      // The cost of the copy is probably inconsiderable\n      // within the initial chunkSize.\n      for (var j = 0; j < oldLen; j++) {\n        newStore[j] = oldStore[j];\n      }\n      store[dimIdx] = newStore;\n    }\n  } else {\n    store[dimIdx] = new DataCtor(end);\n  }\n}\n;\n/**\r\n * Basically, DataStore API keep immutable.\r\n */\nvar DataStore = /** @class */function () {\n  function DataStore() {\n    this._chunks = [];\n    // It will not be calculated until needed.\n    this._rawExtent = [];\n    this._extent = [];\n    this._count = 0;\n    this._rawCount = 0;\n    this._calcDimNameToIdx = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();\n  }\n  /**\r\n   * Initialize from data\r\n   */\n  DataStore.prototype.initData = function (provider, inputDimensions, dimValueGetter) {\n    if (false) {}\n    this._provider = provider;\n    // Clear\n    this._chunks = [];\n    this._indices = null;\n    this.getRawIndex = this._getRawIdxIdentity;\n    var source = provider.getSource();\n    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat];\n    // Default dim value getter\n    this._dimValueGetter = dimValueGetter || defaultGetter;\n    // Reset raw extent.\n    this._rawExtent = [];\n    var willRetrieveDataByName = (0,_Source_js__WEBPACK_IMPORTED_MODULE_1__/* .shouldRetrieveDataByName */ .O0)(source);\n    this._dimensions = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)(inputDimensions, function (dim) {\n      if (false) {}\n      return {\n        // Only pick these two props. Not leak other properties like orderMeta.\n        type: dim.type,\n        property: dim.property\n      };\n    });\n    this._initDataFromProvider(0, provider.count());\n  };\n  DataStore.prototype.getProvider = function () {\n    return this._provider;\n  };\n  /**\r\n   * Caution: even when a `source` instance owned by a series, the created data store\r\n   * may still be shared by different sereis (the source hash does not use all `source`\r\n   * props, see `sourceManager`). In this case, the `source` props that are not used in\r\n   * hash (like `source.dimensionDefine`) probably only belongs to a certain series and\r\n   * thus should not be fetch here.\r\n   */\n  DataStore.prototype.getSource = function () {\n    return this._provider.getSource();\n  };\n  /**\r\n   * @caution Only used in dataStack.\r\n   */\n  DataStore.prototype.ensureCalculationDimension = function (dimName, type) {\n    var calcDimNameToIdx = this._calcDimNameToIdx;\n    var dimensions = this._dimensions;\n    var calcDimIdx = calcDimNameToIdx.get(dimName);\n    if (calcDimIdx != null) {\n      if (dimensions[calcDimIdx].type === type) {\n        return calcDimIdx;\n      }\n    } else {\n      calcDimIdx = dimensions.length;\n    }\n    dimensions[calcDimIdx] = {\n      type: type\n    };\n    calcDimNameToIdx.set(dimName, calcDimIdx);\n    this._chunks[calcDimIdx] = new dataCtors[type || 'float'](this._rawCount);\n    this._rawExtent[calcDimIdx] = getInitialExtent();\n    return calcDimIdx;\n  };\n  DataStore.prototype.collectOrdinalMeta = function (dimIdx, ordinalMeta) {\n    var chunk = this._chunks[dimIdx];\n    var dim = this._dimensions[dimIdx];\n    var rawExtents = this._rawExtent;\n    var offset = dim.ordinalOffset || 0;\n    var len = chunk.length;\n    if (offset === 0) {\n      // We need to reset the rawExtent if collect is from start.\n      // Because this dimension may be guessed as number and calcuating a wrong extent.\n      rawExtents[dimIdx] = getInitialExtent();\n    }\n    var dimRawExtent = rawExtents[dimIdx];\n    // Parse from previous data offset. len may be changed after appendData\n    for (var i = offset; i < len; i++) {\n      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);\n      if (!isNaN(val)) {\n        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);\n        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);\n      }\n    }\n    dim.ordinalMeta = ordinalMeta;\n    dim.ordinalOffset = len;\n    dim.type = 'ordinal'; // Force to be ordinal\n  };\n  DataStore.prototype.getOrdinalMeta = function (dimIdx) {\n    var dimInfo = this._dimensions[dimIdx];\n    var ordinalMeta = dimInfo.ordinalMeta;\n    return ordinalMeta;\n  };\n  DataStore.prototype.getDimensionProperty = function (dimIndex) {\n    var item = this._dimensions[dimIndex];\n    return item && item.property;\n  };\n  /**\r\n   * Caution: Can be only called on raw data (before `this._indices` created).\r\n   */\n  DataStore.prototype.appendData = function (data) {\n    if (false) {}\n    var provider = this._provider;\n    var start = this.count();\n    provider.appendData(data);\n    var end = provider.count();\n    if (!provider.persistent) {\n      end += start;\n    }\n    if (start < end) {\n      this._initDataFromProvider(start, end, true);\n    }\n    return [start, end];\n  };\n  DataStore.prototype.appendValues = function (values, minFillLen) {\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, minFillLen || 0);\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      prepareStore(chunks, i, dim.type, end, true);\n    }\n    var emptyDataItem = [];\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start;\n      // Store the data by dimensions\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);\n        chunks[dimIdx][idx] = val;\n        var dimRawExtent = rawExtent[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n    }\n    this._rawCount = this._count = end;\n    return {\n      start: start,\n      end: end\n    };\n  };\n  DataStore.prototype._initDataFromProvider = function (start, end, append) {\n    var provider = this._provider;\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var dimNames = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)(dimensions, function (dim) {\n      return dim.property;\n    });\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      if (!rawExtent[i]) {\n        rawExtent[i] = getInitialExtent();\n      }\n      prepareStore(chunks, i, dim.type, end, append);\n    }\n    if (provider.fillStorage) {\n      provider.fillStorage(start, end, chunks, rawExtent);\n    } else {\n      var dataItem = [];\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        dataItem = provider.getItem(idx, dataItem);\n        // Each data item is value\n        // [1, 2]\n        // 2\n        // Bar chart, line chart which uses category axis\n        // only gives the 'y' value. 'x' value is the indices of category\n        // Use a tempValue to normalize the value to be a (x, y) value\n        // Store the data by dimensions\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dimStorage = chunks[dimIdx];\n          // PENDING NULL is empty or zero\n          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtent[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        }\n      }\n    }\n    if (!provider.persistent && provider.clean) {\n      // Clean unused data if data source is typed array.\n      provider.clean();\n    }\n    this._rawCount = this._count = end;\n    // Reset data extent\n    this._extent = [];\n  };\n  DataStore.prototype.count = function () {\n    return this._count;\n  };\n  /**\r\n   * Get value. Return NaN if idx is out of range.\r\n   */\n  DataStore.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n  DataStore.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n    var dimArr = [];\n    if (idx == null) {\n      idx = dimensions;\n      // TODO get all from store?\n      dimensions = [];\n      // All dimensions\n      for (var i = 0; i < this._dimensions.length; i++) {\n        dimArr.push(i);\n      }\n    } else {\n      dimArr = dimensions;\n    }\n    for (var i = 0, len = dimArr.length; i < len; i++) {\n      values.push(this.get(dimArr[i], idx));\n    }\n    return values;\n  };\n  /**\r\n   * @param dim concrete dim\r\n   */\n  DataStore.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n  /**\r\n   * Get sum of data in one dimension\r\n   */\n  DataStore.prototype.getSum = function (dim) {\n    var dimData = this._chunks[dim];\n    var sum = 0;\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n    return sum;\n  };\n  /**\r\n   * Get median of data in one dimension\r\n   */\n  DataStore.prototype.getMedian = function (dim) {\n    var dimDataArray = [];\n    // map all data of one dimension\n    this.each([dim], function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    });\n    // TODO\n    // Use quick select?\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count();\n    // calculate median\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  };\n  /**\r\n   * Retrieve the index with given raw data index.\r\n   */\n  DataStore.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n    if (!this._indices) {\n      return rawIndex;\n    }\n    // Indices are ascending\n    var indices = this._indices;\n    // If rawIndex === dataIndex\n    var rawDataIndex = indices[rawIndex];\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n    var left = 0;\n    var right = this._count - 1;\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n    return -1;\n  };\n  /**\r\n   * Retrieve the index of nearest value.\r\n   * @param dim\r\n   * @param value\r\n   * @param [maxDistance=Infinity]\r\n   * @return If and only if multiple indices have\r\n   *         the same value, they are put to the result.\r\n   */\n  DataStore.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var chunks = this._chunks;\n    var dimData = chunks[dim];\n    var nearestIndices = [];\n    if (!dimData) {\n      return nearestIndices;\n    }\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0;\n    // Check the test case of `test/ut/spec/data/SeriesData.js`.\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n      if (dist <= maxDistance) {\n        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n        // So we choose the one that `diff >= 0` in this case.\n        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n        // should be push to `nearestIndices`.\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n  DataStore.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count;\n      // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this._rawCount);\n      newIndices = new Ctor(this.count());\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n    return newIndices;\n  };\n  /**\r\n   * Data filter.\r\n   */\n  DataStore.prototype.filter = function (dims, cb) {\n    if (!this._count) {\n      return this;\n    }\n    var newStore = this.clone();\n    var count = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dims.length;\n    var offset = 0;\n    var dim0 = dims[0];\n    var chunks = newStore._chunks;\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = newStore.getRawIndex(i);\n      // Simple optimization\n      if (dimSize === 0) {\n        keep = cb(i);\n      } else if (dimSize === 1) {\n        var val = chunks[dim0][rawIdx];\n        keep = cb(val, i);\n      } else {\n        var k = 0;\n        for (; k < dimSize; k++) {\n          value[k] = chunks[dims[k]][rawIdx];\n        }\n        value[k] = i;\n        keep = cb.apply(null, value);\n      }\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    }\n    // Set indices after filtered.\n    if (offset < count) {\n      newStore._indices = newIndices;\n    }\n    newStore._count = offset;\n    // Reset data extent\n    newStore._extent = [];\n    newStore._updateGetRawIdx();\n    return newStore;\n  };\n  /**\r\n   * Select data in range. (For optimization of filter)\r\n   * (Manually inline code, support 5 million data filtering in data zoom.)\r\n   */\n  DataStore.prototype.selectRange = function (range) {\n    var newStore = this.clone();\n    var len = newStore._count;\n    if (!len) {\n      return this;\n    }\n    var dims = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys)(range);\n    var dimSize = dims.length;\n    if (!dimSize) {\n      return this;\n    }\n    var originalCount = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dims[0];\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storeArr = newStore._chunks;\n    var quickFinished = false;\n    if (!newStore._indices) {\n      // Extreme optimization for common case. About 2x faster in chrome.\n      var idx = 0;\n      if (dimSize === 1) {\n        var dimStorage = storeArr[dims[0]];\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n          idx++;\n        }\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storeArr[dims[0]];\n        var dimStorage2 = storeArr[dims[1]];\n        var min2 = range[dims[1]][0];\n        var max2 = range[dims[1]][1];\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i];\n          // Do not filter NaN, see comment above.\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n          idx++;\n        }\n        quickFinished = true;\n      }\n    }\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = newStore.getRawIndex(i);\n          var val = storeArr[dims[0]][rawIndex];\n          // Do not filter NaN, see comment above.\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = newStore.getRawIndex(i);\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dims[k];\n            var val = storeArr[dimk][rawIndex];\n            // Do not filter NaN, see comment above.\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n          if (keep) {\n            newIndices[offset++] = newStore.getRawIndex(i);\n          }\n        }\n      }\n    }\n    // Set indices after filtered.\n    if (offset < originalCount) {\n      newStore._indices = newIndices;\n    }\n    newStore._count = offset;\n    // Reset data extent\n    newStore._extent = [];\n    newStore._updateGetRawIdx();\n    return newStore;\n  };\n  // /**\n  //  * Data mapping to a plain array\n  //  */\n  // mapArray(dims: DimensionIndex[], cb: MapArrayCb): any[] {\n  //     const result: any[] = [];\n  //     this.each(dims, function () {\n  //         result.push(cb && (cb as MapArrayCb).apply(null, arguments));\n  //     });\n  //     return result;\n  // }\n  /**\r\n   * Data mapping to a new List with given dimensions\r\n   */\n  DataStore.prototype.map = function (dims, cb) {\n    // TODO only clone picked chunks.\n    var target = this.clone(dims);\n    this._updateDims(target, dims, cb);\n    return target;\n  };\n  /**\r\n   * @caution Danger!! Only used in dataStack.\r\n   */\n  DataStore.prototype.modify = function (dims, cb) {\n    this._updateDims(this, dims, cb);\n  };\n  DataStore.prototype._updateDims = function (target, dims, cb) {\n    var targetChunks = target._chunks;\n    var tmpRetValue = [];\n    var dimSize = dims.length;\n    var dataCount = target.count();\n    var values = [];\n    var rawExtent = target._rawExtent;\n    for (var i = 0; i < dims.length; i++) {\n      rawExtent[dims[i]] = getInitialExtent();\n    }\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      var rawIndex = target.getRawIndex(dataIndex);\n      for (var k = 0; k < dimSize; k++) {\n        values[k] = targetChunks[dims[k]][rawIndex];\n      }\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(null, values);\n      if (retValue != null) {\n        // a number or string (in oridinal dimension)?\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dims[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = targetChunks[dim];\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Large data down sampling using largest-triangle-three-buckets\r\n   * @param {string} valueDimension\r\n   * @param {number} targetCount\r\n   */\n  DataStore.prototype.lttbDownSample = function (valueDimension, rate) {\n    var target = this.clone([valueDimension], true);\n    var targetStorage = target._chunks;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var sampledIndex = 0;\n    var frameSize = Math.floor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex;\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len / frameSize) + 2) * 2, len));\n    // First frame use the first data.\n    newIndices[sampledIndex++] = currentRawIndex;\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n        if (isNaN(y)) {\n          continue;\n        }\n        avgY += y;\n      }\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart;\n      var firstNaNIndex = -1;\n      var countNaN = 0;\n      // Find a point from current frame that construct a triangle with largest area with previous selected point\n      // And the average of next frame.\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n        if (isNaN(y)) {\n          countNaN++;\n          if (firstNaNIndex < 0) {\n            firstNaNIndex = rawIndex;\n          }\n          continue;\n        }\n        // Calculate triangle area over three buckets\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex; // Next a is this b\n        }\n      }\n      if (countNaN > 0 && countNaN < frameEnd - frameStart) {\n        // Append first NaN point in every bucket.\n        // It is necessary to ensure the correct order of indices.\n        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);\n        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);\n      }\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex; // This a is the next a (chosen b)\n    }\n    // First frame use the last data.\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    target._count = sampledIndex;\n    target._indices = newIndices;\n    target.getRawIndex = this._getRawIdx;\n    return target;\n  };\n  /**\r\n   * Large data down sampling using min-max\r\n   * @param {string} valueDimension\r\n   * @param {number} rate\r\n   */\n  DataStore.prototype.minmaxDownSample = function (valueDimension, rate) {\n    var target = this.clone([valueDimension], true);\n    var targetStorage = target._chunks;\n    var frameSize = Math.floor(1 / rate);\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    // Each frame results in 2 data points, one for min and one for max\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize) * 2);\n    var offset = 0;\n    for (var i = 0; i < len; i += frameSize) {\n      var minIndex = i;\n      var minValue = dimStore[this.getRawIndex(minIndex)];\n      var maxIndex = i;\n      var maxValue = dimStore[this.getRawIndex(maxIndex)];\n      var thisFrameSize = frameSize;\n      // Handle final smaller frame\n      if (i + frameSize > len) {\n        thisFrameSize = len - i;\n      }\n      // Determine min and max within the current frame\n      for (var k = 0; k < thisFrameSize; k++) {\n        var rawIndex = this.getRawIndex(i + k);\n        var value = dimStore[rawIndex];\n        if (value < minValue) {\n          minValue = value;\n          minIndex = i + k;\n        }\n        if (value > maxValue) {\n          maxValue = value;\n          maxIndex = i + k;\n        }\n      }\n      var rawMinIndex = this.getRawIndex(minIndex);\n      var rawMaxIndex = this.getRawIndex(maxIndex);\n      // Set the order of the min and max values, based on their ordering in the frame\n      if (minIndex < maxIndex) {\n        newIndices[offset++] = rawMinIndex;\n        newIndices[offset++] = rawMaxIndex;\n      } else {\n        newIndices[offset++] = rawMaxIndex;\n        newIndices[offset++] = rawMinIndex;\n      }\n    }\n    target._count = offset;\n    target._indices = newIndices;\n    target._updateGetRawIdx();\n    return target;\n  };\n  /**\r\n   * Large data down sampling on given dimension\r\n   * @param sampleIndex Sample index for name and id\r\n   */\n  DataStore.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var target = this.clone([dimension], true);\n    var targetStorage = target._chunks;\n    var frameValues = [];\n    var frameSize = Math.floor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize));\n    var offset = 0;\n    for (var i = 0; i < len; i += frameSize) {\n      // Last frame\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n      // Only write value on the filtered data\n      dimStore[sampleFrameIdx] = value;\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n      newIndices[offset++] = sampleFrameIdx;\n    }\n    target._count = offset;\n    target._indices = newIndices;\n    target._updateGetRawIdx();\n    return target;\n  };\n  /**\r\n   * Data iteration\r\n   * @param ctx default this\r\n   * @example\r\n   *  list.each('x', function (x, idx) {});\r\n   *  list.each(['x', 'y'], function (x, y, idx) {});\r\n   *  list.each(function (idx) {})\r\n   */\n  DataStore.prototype.each = function (dims, cb) {\n    if (!this._count) {\n      return;\n    }\n    var dimSize = dims.length;\n    var chunks = this._chunks;\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i);\n      // Simple optimization\n      switch (dimSize) {\n        case 0:\n          cb(i);\n          break;\n        case 1:\n          cb(chunks[dims[0]][rawIdx], i);\n          break;\n        case 2:\n          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);\n          break;\n        default:\n          var k = 0;\n          var value = [];\n          for (; k < dimSize; k++) {\n            value[k] = chunks[dims[k]][rawIdx];\n          }\n          // Index\n          value[k] = i;\n          cb.apply(null, value);\n      }\n    }\n  };\n  /**\r\n   * Get extent of data in one dimension\r\n   */\n  DataStore.prototype.getDataExtent = function (dim) {\n    // Make sure use concrete dim as cache name.\n    var dimData = this._chunks[dim];\n    var initialExtent = getInitialExtent();\n    if (!dimData) {\n      return initialExtent;\n    }\n    // Make more strict checkings to ensure hitting cache.\n    var currEnd = this.count();\n    // Consider the most cases when using data zoom, `getDataExtent`\n    // happened before filtering. We cache raw extent, which is not\n    // necessary to be cleared and recalculated when restore data.\n    var useRaw = !this._indices;\n    var dimExtent;\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n    dimExtent = this._extent[dim];\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n  /**\r\n   * Get raw data item\r\n   */\n  DataStore.prototype.getRawDataItem = function (idx) {\n    var rawIdx = this.getRawIndex(idx);\n    if (!this._provider.persistent) {\n      var val = [];\n      var chunks = this._chunks;\n      for (var i = 0; i < chunks.length; i++) {\n        val.push(chunks[i][rawIdx]);\n      }\n      return val;\n    } else {\n      return this._provider.getItem(rawIdx);\n    }\n  };\n  /**\r\n   * Clone shallow.\r\n   *\r\n   * @param clonedDims Determine which dims to clone. Will share the data if not specified.\r\n   */\n  DataStore.prototype.clone = function (clonedDims, ignoreIndices) {\n    var target = new DataStore();\n    var chunks = this._chunks;\n    var clonedDimsMap = clonedDims && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.reduce)(clonedDims, function (obj, dimIdx) {\n      obj[dimIdx] = true;\n      return obj;\n    }, {});\n    if (clonedDimsMap) {\n      for (var i = 0; i < chunks.length; i++) {\n        // Not clone if dim is not picked.\n        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);\n      }\n    } else {\n      target._chunks = chunks;\n    }\n    this._copyCommonProps(target);\n    if (!ignoreIndices) {\n      target._indices = this._cloneIndices();\n    }\n    target._updateGetRawIdx();\n    return target;\n  };\n  DataStore.prototype._copyCommonProps = function (target) {\n    target._count = this._count;\n    target._rawCount = this._rawCount;\n    target._provider = this._provider;\n    target._dimensions = this._dimensions;\n    target._extent = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.clone)(this._extent);\n    target._rawExtent = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.clone)(this._rawExtent);\n  };\n  DataStore.prototype._cloneIndices = function () {\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n      var indices = void 0;\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        indices = new Ctor(thisCount);\n        for (var i = 0; i < thisCount; i++) {\n          indices[i] = this._indices[i];\n        }\n      } else {\n        indices = new Ctor(this._indices);\n      }\n      return indices;\n    }\n    return null;\n  };\n  DataStore.prototype._getRawIdxIdentity = function (idx) {\n    return idx;\n  };\n  DataStore.prototype._getRawIdx = function (idx) {\n    if (idx < this._count && idx >= 0) {\n      return this._indices[idx];\n    }\n    return -1;\n  };\n  DataStore.prototype._updateGetRawIdx = function () {\n    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;\n  };\n  DataStore.internalField = function () {\n    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {\n      return (0,_helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .parseDataValue */ .Pn)(dataItem[dimIndex], this._dimensions[dimIndex]);\n    }\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function (dataItem, property, dataIndex, dimIndex) {\n        return (0,_helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .parseDataValue */ .Pn)(dataItem[property], this._dimensions[dimIndex]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function (dataItem, property, dataIndex, dimIndex) {\n        // Performance sensitive, do not use modelUtil.getDataItemValue.\n        // If dataItem is an plain object with no value field, the let `value`\n        // will be assigned with the object, but it will be tread correctly\n        // in the `convertValue`.\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n        return (0,_helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .parseDataValue */ .Pn)(value instanceof Array ? value[dimIndex]\n        // If value is a single number or something else not array.\n        : value, this._dimensions[dimIndex]);\n      },\n      typedArray: function (dataItem, property, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n  }();\n  return DataStore;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataStore);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAyNTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvRGF0YVN0b3JlLmpzPzY5ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBhc3NlcnQsIGNsb25lLCBjcmVhdGVIYXNoTWFwLCBpc0Z1bmN0aW9uLCBrZXlzLCBtYXAsIHJlZHVjZSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBwYXJzZURhdGFWYWx1ZSB9IGZyb20gJy4vaGVscGVyL2RhdGFWYWx1ZUhlbHBlci5qcyc7XG5pbXBvcnQgeyBzaG91bGRSZXRyaWV2ZURhdGFCeU5hbWUgfSBmcm9tICcuL1NvdXJjZS5qcyc7XG52YXIgVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCc7XG4vKiBnbG9iYWwgRmxvYXQ2NEFycmF5LCBJbnQzMkFycmF5LCBVaW50MzJBcnJheSwgVWludDE2QXJyYXkgKi9cbi8vIENhdXRpb246IE1VU1Qgbm90IHVzZSBgbmV3IEN0b3JVaW50MzJBcnJheShhcnIsIDAsIGxlbilgLCBiZWNhdXNlIHRoZSBDdG9yIG9mIGFycmF5IGlzXG4vLyBkaWZmZXJlbnQgZnJvbSB0aGUgQ3RvciBvZiB0eXBlZCBhcnJheS5cbmV4cG9ydCB2YXIgQ3RvclVpbnQzMkFycmF5ID0gdHlwZW9mIFVpbnQzMkFycmF5ID09PSBVTkRFRklORUQgPyBBcnJheSA6IFVpbnQzMkFycmF5O1xuZXhwb3J0IHZhciBDdG9yVWludDE2QXJyYXkgPSB0eXBlb2YgVWludDE2QXJyYXkgPT09IFVOREVGSU5FRCA/IEFycmF5IDogVWludDE2QXJyYXk7XG5leHBvcnQgdmFyIEN0b3JJbnQzMkFycmF5ID0gdHlwZW9mIEludDMyQXJyYXkgPT09IFVOREVGSU5FRCA/IEFycmF5IDogSW50MzJBcnJheTtcbmV4cG9ydCB2YXIgQ3RvckZsb2F0NjRBcnJheSA9IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09IFVOREVGSU5FRCA/IEFycmF5IDogRmxvYXQ2NEFycmF5O1xuLyoqXHJcbiAqIE11bHRpIGRpbWVuc2lvbmFsIGRhdGEgc3RvcmVcclxuICovXG52YXIgZGF0YUN0b3JzID0ge1xuICAnZmxvYXQnOiBDdG9yRmxvYXQ2NEFycmF5LFxuICAnaW50JzogQ3RvckludDMyQXJyYXksXG4gIC8vIE9yZGluYWwgZGF0YSB0eXBlIGNhbiBiZSBzdHJpbmcgb3IgaW50XG4gICdvcmRpbmFsJzogQXJyYXksXG4gICdudW1iZXInOiBBcnJheSxcbiAgJ3RpbWUnOiBDdG9yRmxvYXQ2NEFycmF5XG59O1xudmFyIGRlZmF1bHREaW1WYWx1ZUdldHRlcnM7XG5mdW5jdGlvbiBnZXRJbmRpY2VzQ3RvcihyYXdDb3VudCkge1xuICAvLyBUaGUgcG9zc2libGUgbWF4IHZhbHVlIGluIHRoaXMuX2luZGljaWVzIGlzIGFsd2F5cyB0aGlzLl9yYXdDb3VudCBkZXNwaXRlIG9mIGZpbHRlcmluZy5cbiAgcmV0dXJuIHJhd0NvdW50ID4gNjU1MzUgPyBDdG9yVWludDMyQXJyYXkgOiBDdG9yVWludDE2QXJyYXk7XG59XG47XG5mdW5jdGlvbiBnZXRJbml0aWFsRXh0ZW50KCkge1xuICByZXR1cm4gW0luZmluaXR5LCAtSW5maW5pdHldO1xufVxuO1xuZnVuY3Rpb24gY2xvbmVDaHVuayhvcmlnaW5hbENodW5rKSB7XG4gIHZhciBDdG9yID0gb3JpZ2luYWxDaHVuay5jb25zdHJ1Y3RvcjtcbiAgLy8gT25seSBzaGFsbG93IGNsb25lIGlzIGVub3VnaCB3aGVuIEFycmF5LlxuICByZXR1cm4gQ3RvciA9PT0gQXJyYXkgPyBvcmlnaW5hbENodW5rLnNsaWNlKCkgOiBuZXcgQ3RvcihvcmlnaW5hbENodW5rKTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTdG9yZShzdG9yZSwgZGltSWR4LCBkaW1UeXBlLCBlbmQsIGFwcGVuZCkge1xuICB2YXIgRGF0YUN0b3IgPSBkYXRhQ3RvcnNbZGltVHlwZSB8fCAnZmxvYXQnXTtcbiAgaWYgKGFwcGVuZCkge1xuICAgIHZhciBvbGRTdG9yZSA9IHN0b3JlW2RpbUlkeF07XG4gICAgdmFyIG9sZExlbiA9IG9sZFN0b3JlICYmIG9sZFN0b3JlLmxlbmd0aDtcbiAgICBpZiAoIShvbGRMZW4gPT09IGVuZCkpIHtcbiAgICAgIHZhciBuZXdTdG9yZSA9IG5ldyBEYXRhQ3RvcihlbmQpO1xuICAgICAgLy8gVGhlIGNvc3Qgb2YgdGhlIGNvcHkgaXMgcHJvYmFibHkgaW5jb25zaWRlcmFibGVcbiAgICAgIC8vIHdpdGhpbiB0aGUgaW5pdGlhbCBjaHVua1NpemUuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9sZExlbjsgaisrKSB7XG4gICAgICAgIG5ld1N0b3JlW2pdID0gb2xkU3RvcmVbal07XG4gICAgICB9XG4gICAgICBzdG9yZVtkaW1JZHhdID0gbmV3U3RvcmU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0b3JlW2RpbUlkeF0gPSBuZXcgRGF0YUN0b3IoZW5kKTtcbiAgfVxufVxuO1xuLyoqXHJcbiAqIEJhc2ljYWxseSwgRGF0YVN0b3JlIEFQSSBrZWVwIGltbXV0YWJsZS5cclxuICovXG52YXIgRGF0YVN0b3JlID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGF0YVN0b3JlKCkge1xuICAgIHRoaXMuX2NodW5rcyA9IFtdO1xuICAgIC8vIEl0IHdpbGwgbm90IGJlIGNhbGN1bGF0ZWQgdW50aWwgbmVlZGVkLlxuICAgIHRoaXMuX3Jhd0V4dGVudCA9IFtdO1xuICAgIHRoaXMuX2V4dGVudCA9IFtdO1xuICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICB0aGlzLl9yYXdDb3VudCA9IDA7XG4gICAgdGhpcy5fY2FsY0RpbU5hbWVUb0lkeCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgfVxuICAvKipcclxuICAgKiBJbml0aWFsaXplIGZyb20gZGF0YVxyXG4gICAqL1xuICBEYXRhU3RvcmUucHJvdG90eXBlLmluaXREYXRhID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBpbnB1dERpbWVuc2lvbnMsIGRpbVZhbHVlR2V0dGVyKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChpc0Z1bmN0aW9uKHByb3ZpZGVyLmdldEl0ZW0pICYmIGlzRnVuY3Rpb24ocHJvdmlkZXIuY291bnQpLCAnSW52YWxpZCBkYXRhIHByb3ZpZGVyLicpO1xuICAgIH1cbiAgICB0aGlzLl9wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIC8vIENsZWFyXG4gICAgdGhpcy5fY2h1bmtzID0gW107XG4gICAgdGhpcy5faW5kaWNlcyA9IG51bGw7XG4gICAgdGhpcy5nZXRSYXdJbmRleCA9IHRoaXMuX2dldFJhd0lkeElkZW50aXR5O1xuICAgIHZhciBzb3VyY2UgPSBwcm92aWRlci5nZXRTb3VyY2UoKTtcbiAgICB2YXIgZGVmYXVsdEdldHRlciA9IHRoaXMuZGVmYXVsdERpbVZhbHVlR2V0dGVyID0gZGVmYXVsdERpbVZhbHVlR2V0dGVyc1tzb3VyY2Uuc291cmNlRm9ybWF0XTtcbiAgICAvLyBEZWZhdWx0IGRpbSB2YWx1ZSBnZXR0ZXJcbiAgICB0aGlzLl9kaW1WYWx1ZUdldHRlciA9IGRpbVZhbHVlR2V0dGVyIHx8IGRlZmF1bHRHZXR0ZXI7XG4gICAgLy8gUmVzZXQgcmF3IGV4dGVudC5cbiAgICB0aGlzLl9yYXdFeHRlbnQgPSBbXTtcbiAgICB2YXIgd2lsbFJldHJpZXZlRGF0YUJ5TmFtZSA9IHNob3VsZFJldHJpZXZlRGF0YUJ5TmFtZShzb3VyY2UpO1xuICAgIHRoaXMuX2RpbWVuc2lvbnMgPSBtYXAoaW5wdXREaW1lbnNpb25zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAod2lsbFJldHJpZXZlRGF0YUJ5TmFtZSkge1xuICAgICAgICAgIGFzc2VydChkaW0ucHJvcGVydHkgIT0gbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIE9ubHkgcGljayB0aGVzZSB0d28gcHJvcHMuIE5vdCBsZWFrIG90aGVyIHByb3BlcnRpZXMgbGlrZSBvcmRlck1ldGEuXG4gICAgICAgIHR5cGU6IGRpbS50eXBlLFxuICAgICAgICBwcm9wZXJ0eTogZGltLnByb3BlcnR5XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHRoaXMuX2luaXREYXRhRnJvbVByb3ZpZGVyKDAsIHByb3ZpZGVyLmNvdW50KCkpO1xuICB9O1xuICBEYXRhU3RvcmUucHJvdG90eXBlLmdldFByb3ZpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm92aWRlcjtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2F1dGlvbjogZXZlbiB3aGVuIGEgYHNvdXJjZWAgaW5zdGFuY2Ugb3duZWQgYnkgYSBzZXJpZXMsIHRoZSBjcmVhdGVkIGRhdGEgc3RvcmVcclxuICAgKiBtYXkgc3RpbGwgYmUgc2hhcmVkIGJ5IGRpZmZlcmVudCBzZXJlaXMgKHRoZSBzb3VyY2UgaGFzaCBkb2VzIG5vdCB1c2UgYWxsIGBzb3VyY2VgXHJcbiAgICogcHJvcHMsIHNlZSBgc291cmNlTWFuYWdlcmApLiBJbiB0aGlzIGNhc2UsIHRoZSBgc291cmNlYCBwcm9wcyB0aGF0IGFyZSBub3QgdXNlZCBpblxyXG4gICAqIGhhc2ggKGxpa2UgYHNvdXJjZS5kaW1lbnNpb25EZWZpbmVgKSBwcm9iYWJseSBvbmx5IGJlbG9uZ3MgdG8gYSBjZXJ0YWluIHNlcmllcyBhbmRcclxuICAgKiB0aHVzIHNob3VsZCBub3QgYmUgZmV0Y2ggaGVyZS5cclxuICAgKi9cbiAgRGF0YVN0b3JlLnByb3RvdHlwZS5nZXRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3ZpZGVyLmdldFNvdXJjZSgpO1xuICB9O1xuICAvKipcclxuICAgKiBAY2F1dGlvbiBPbmx5IHVzZWQgaW4gZGF0YVN0YWNrLlxyXG4gICAqL1xuICBEYXRhU3RvcmUucHJvdG90eXBlLmVuc3VyZUNhbGN1bGF0aW9uRGltZW5zaW9uID0gZnVuY3Rpb24gKGRpbU5hbWUsIHR5cGUpIHtcbiAgICB2YXIgY2FsY0RpbU5hbWVUb0lkeCA9IHRoaXMuX2NhbGNEaW1OYW1lVG9JZHg7XG4gICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLl9kaW1lbnNpb25zO1xuICAgIHZhciBjYWxjRGltSWR4ID0gY2FsY0RpbU5hbWVUb0lkeC5nZXQoZGltTmFtZSk7XG4gICAgaWYgKGNhbGNEaW1JZHggIT0gbnVsbCkge1xuICAgICAgaWYgKGRpbWVuc2lvbnNbY2FsY0RpbUlkeF0udHlwZSA9PT0gdHlwZSkge1xuICAgICAgICByZXR1cm4gY2FsY0RpbUlkeDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsY0RpbUlkeCA9IGRpbWVuc2lvbnMubGVuZ3RoO1xuICAgIH1cbiAgICBkaW1lbnNpb25zW2NhbGNEaW1JZHhdID0ge1xuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gICAgY2FsY0RpbU5hbWVUb0lkeC5zZXQoZGltTmFtZSwgY2FsY0RpbUlkeCk7XG4gICAgdGhpcy5fY2h1bmtzW2NhbGNEaW1JZHhdID0gbmV3IGRhdGFDdG9yc1t0eXBlIHx8ICdmbG9hdCddKHRoaXMuX3Jhd0NvdW50KTtcbiAgICB0aGlzLl9yYXdFeHRlbnRbY2FsY0RpbUlkeF0gPSBnZXRJbml0aWFsRXh0ZW50KCk7XG4gICAgcmV0dXJuIGNhbGNEaW1JZHg7XG4gIH07XG4gIERhdGFTdG9yZS5wcm90b3R5cGUuY29sbGVjdE9yZGluYWxNZXRhID0gZnVuY3Rpb24gKGRpbUlkeCwgb3JkaW5hbE1ldGEpIHtcbiAgICB2YXIgY2h1bmsgPSB0aGlzLl9jaHVua3NbZGltSWR4XTtcbiAgICB2YXIgZGltID0gdGhpcy5fZGltZW5zaW9uc1tkaW1JZHhdO1xuICAgIHZhciByYXdFeHRlbnRzID0gdGhpcy5fcmF3RXh0ZW50O1xuICAgIHZhciBvZmZzZXQgPSBkaW0ub3JkaW5hbE9mZnNldCB8fCAwO1xuICAgIHZhciBsZW4gPSBjaHVuay5sZW5ndGg7XG4gICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgLy8gV2UgbmVlZCB0byByZXNldCB0aGUgcmF3RXh0ZW50IGlmIGNvbGxlY3QgaXMgZnJvbSBzdGFydC5cbiAgICAgIC8vIEJlY2F1c2UgdGhpcyBkaW1lbnNpb24gbWF5IGJlIGd1ZXNzZWQgYXMgbnVtYmVyIGFuZCBjYWxjdWF0aW5nIGEgd3JvbmcgZXh0ZW50LlxuICAgICAgcmF3RXh0ZW50c1tkaW1JZHhdID0gZ2V0SW5pdGlhbEV4dGVudCgpO1xuICAgIH1cbiAgICB2YXIgZGltUmF3RXh0ZW50ID0gcmF3RXh0ZW50c1tkaW1JZHhdO1xuICAgIC8vIFBhcnNlIGZyb20gcHJldmlvdXMgZGF0YSBvZmZzZXQuIGxlbiBtYXkgYmUgY2hhbmdlZCBhZnRlciBhcHBlbmREYXRhXG4gICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdmFsID0gY2h1bmtbaV0gPSBvcmRpbmFsTWV0YS5wYXJzZUFuZENvbGxlY3QoY2h1bmtbaV0pO1xuICAgICAgaWYgKCFpc05hTih2YWwpKSB7XG4gICAgICAgIGRpbVJhd0V4dGVudFswXSA9IE1hdGgubWluKHZhbCwgZGltUmF3RXh0ZW50WzBdKTtcbiAgICAgICAgZGltUmF3RXh0ZW50WzFdID0gTWF0aC5tYXgodmFsLCBkaW1SYXdFeHRlbnRbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBkaW0ub3JkaW5hbE1ldGEgPSBvcmRpbmFsTWV0YTtcbiAgICBkaW0ub3JkaW5hbE9mZnNldCA9IGxlbjtcbiAgICBkaW0udHlwZSA9ICdvcmRpbmFsJzsgLy8gRm9yY2UgdG8gYmUgb3JkaW5hbFxuICB9O1xuICBEYXRhU3RvcmUucHJvdG90eXBlLmdldE9yZGluYWxNZXRhID0gZnVuY3Rpb24gKGRpbUlkeCkge1xuICAgIHZhciBkaW1JbmZvID0gdGhpcy5fZGltZW5zaW9uc1tkaW1JZHhdO1xuICAgIHZhciBvcmRpbmFsTWV0YSA9IGRpbUluZm8ub3JkaW5hbE1ldGE7XG4gICAgcmV0dXJuIG9yZGluYWxNZXRhO1xuICB9O1xuICBEYXRhU3RvcmUucHJvdG90eXBlLmdldERpbWVuc2lvblByb3BlcnR5ID0gZnVuY3Rpb24gKGRpbUluZGV4KSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLl9kaW1lbnNpb25zW2RpbUluZGV4XTtcbiAgICByZXR1cm4gaXRlbSAmJiBpdGVtLnByb3BlcnR5O1xuICB9O1xuICAvKipcclxuICAgKiBDYXV0aW9uOiBDYW4gYmUgb25seSBjYWxsZWQgb24gcmF3IGRhdGEgKGJlZm9yZSBgdGhpcy5faW5kaWNlc2AgY3JlYXRlZCkuXHJcbiAgICovXG4gIERhdGFTdG9yZS5wcm90b3R5cGUuYXBwZW5kRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydCghdGhpcy5faW5kaWNlcywgJ2FwcGVuZERhdGEgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHJhdyBkYXRhLicpO1xuICAgIH1cbiAgICB2YXIgcHJvdmlkZXIgPSB0aGlzLl9wcm92aWRlcjtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLmNvdW50KCk7XG4gICAgcHJvdmlkZXIuYXBwZW5kRGF0YShkYXRhKTtcbiAgICB2YXIgZW5kID0gcHJvdmlkZXIuY291bnQoKTtcbiAgICBpZiAoIXByb3ZpZGVyLnBlcnNpc3RlbnQpIHtcbiAgICAgIGVuZCArPSBzdGFydDtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICB0aGlzLl9pbml0RGF0YUZyb21Qcm92aWRlcihzdGFydCwgZW5kLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcbiAgfTtcbiAgRGF0YVN0b3JlLnByb3RvdHlwZS5hcHBlbmRWYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzLCBtaW5GaWxsTGVuKSB7XG4gICAgdmFyIGNodW5rcyA9IHRoaXMuX2NodW5rcztcbiAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuX2RpbWVuc2lvbnM7XG4gICAgdmFyIGRpbUxlbiA9IGRpbWVuc2lvbnMubGVuZ3RoO1xuICAgIHZhciByYXdFeHRlbnQgPSB0aGlzLl9yYXdFeHRlbnQ7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5jb3VudCgpO1xuICAgIHZhciBlbmQgPSBzdGFydCArIE1hdGgubWF4KHZhbHVlcy5sZW5ndGgsIG1pbkZpbGxMZW4gfHwgMCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1MZW47IGkrKykge1xuICAgICAgdmFyIGRpbSA9IGRpbWVuc2lvbnNbaV07XG4gICAgICBwcmVwYXJlU3RvcmUoY2h1bmtzLCBpLCBkaW0udHlwZSwgZW5kLCB0cnVlKTtcbiAgICB9XG4gICAgdmFyIGVtcHR5RGF0YUl0ZW0gPSBbXTtcbiAgICBmb3IgKHZhciBpZHggPSBzdGFydDsgaWR4IDwgZW5kOyBpZHgrKykge1xuICAgICAgdmFyIHNvdXJjZUlkeCA9IGlkeCAtIHN0YXJ0O1xuICAgICAgLy8gU3RvcmUgdGhlIGRhdGEgYnkgZGltZW5zaW9uc1xuICAgICAgZm9yICh2YXIgZGltSWR4ID0gMDsgZGltSWR4IDwgZGltTGVuOyBkaW1JZHgrKykge1xuICAgICAgICB2YXIgZGltID0gZGltZW5zaW9uc1tkaW1JZHhdO1xuICAgICAgICB2YXIgdmFsID0gZGVmYXVsdERpbVZhbHVlR2V0dGVycy5hcnJheVJvd3MuY2FsbCh0aGlzLCB2YWx1ZXNbc291cmNlSWR4XSB8fCBlbXB0eURhdGFJdGVtLCBkaW0ucHJvcGVydHksIHNvdXJjZUlkeCwgZGltSWR4KTtcbiAgICAgICAgY2h1bmtzW2RpbUlkeF1baWR4XSA9IHZhbDtcbiAgICAgICAgdmFyIGRpbVJhd0V4dGVudCA9IHJhd0V4dGVudFtkaW1JZHhdO1xuICAgICAgICB2YWwgPCBkaW1SYXdFeHRlbnRbMF0gJiYgKGRpbVJhd0V4dGVudFswXSA9IHZhbCk7XG4gICAgICAgIHZhbCA+IGRpbVJhd0V4dGVudFsxXSAmJiAoZGltUmF3RXh0ZW50WzFdID0gdmFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcmF3Q291bnQgPSB0aGlzLl9jb3VudCA9IGVuZDtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBlbmRcbiAgICB9O1xuICB9O1xuICBEYXRhU3RvcmUucHJvdG90eXBlLl9pbml0RGF0YUZyb21Qcm92aWRlciA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBhcHBlbmQpIHtcbiAgICB2YXIgcHJvdmlkZXIgPSB0aGlzLl9wcm92aWRlcjtcbiAgICB2YXIgY2h1bmtzID0gdGhpcy5fY2h1bmtzO1xuICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5fZGltZW5zaW9ucztcbiAgICB2YXIgZGltTGVuID0gZGltZW5zaW9ucy5sZW5ndGg7XG4gICAgdmFyIHJhd0V4dGVudCA9IHRoaXMuX3Jhd0V4dGVudDtcbiAgICB2YXIgZGltTmFtZXMgPSBtYXAoZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgcmV0dXJuIGRpbS5wcm9wZXJ0eTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbUxlbjsgaSsrKSB7XG4gICAgICB2YXIgZGltID0gZGltZW5zaW9uc1tpXTtcbiAgICAgIGlmICghcmF3RXh0ZW50W2ldKSB7XG4gICAgICAgIHJhd0V4dGVudFtpXSA9IGdldEluaXRpYWxFeHRlbnQoKTtcbiAgICAgIH1cbiAgICAgIHByZXBhcmVTdG9yZShjaHVua3MsIGksIGRpbS50eXBlLCBlbmQsIGFwcGVuZCk7XG4gICAgfVxuICAgIGlmIChwcm92aWRlci5maWxsU3RvcmFnZSkge1xuICAgICAgcHJvdmlkZXIuZmlsbFN0b3JhZ2Uoc3RhcnQsIGVuZCwgY2h1bmtzLCByYXdFeHRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YUl0ZW0gPSBbXTtcbiAgICAgIGZvciAodmFyIGlkeCA9IHN0YXJ0OyBpZHggPCBlbmQ7IGlkeCsrKSB7XG4gICAgICAgIC8vIE5PVElDRTogVHJ5IG5vdCB0byB3cml0ZSB0aGluZ3MgaW50byBkYXRhSXRlbVxuICAgICAgICBkYXRhSXRlbSA9IHByb3ZpZGVyLmdldEl0ZW0oaWR4LCBkYXRhSXRlbSk7XG4gICAgICAgIC8vIEVhY2ggZGF0YSBpdGVtIGlzIHZhbHVlXG4gICAgICAgIC8vIFsxLCAyXVxuICAgICAgICAvLyAyXG4gICAgICAgIC8vIEJhciBjaGFydCwgbGluZSBjaGFydCB3aGljaCB1c2VzIGNhdGVnb3J5IGF4aXNcbiAgICAgICAgLy8gb25seSBnaXZlcyB0aGUgJ3knIHZhbHVlLiAneCcgdmFsdWUgaXMgdGhlIGluZGljZXMgb2YgY2F0ZWdvcnlcbiAgICAgICAgLy8gVXNlIGEgdGVtcFZhbHVlIHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWUgdG8gYmUgYSAoeCwgeSkgdmFsdWVcbiAgICAgICAgLy8gU3RvcmUgdGhlIGRhdGEgYnkgZGltZW5zaW9uc1xuICAgICAgICBmb3IgKHZhciBkaW1JZHggPSAwOyBkaW1JZHggPCBkaW1MZW47IGRpbUlkeCsrKSB7XG4gICAgICAgICAgdmFyIGRpbVN0b3JhZ2UgPSBjaHVua3NbZGltSWR4XTtcbiAgICAgICAgICAvLyBQRU5ESU5HIE5VTEwgaXMgZW1wdHkgb3IgemVyb1xuICAgICAgICAgIHZhciB2YWwgPSB0aGlzLl9kaW1WYWx1ZUdldHRlcihkYXRhSXRlbSwgZGltTmFtZXNbZGltSWR4XSwgaWR4LCBkaW1JZHgpO1xuICAgICAgICAgIGRpbVN0b3JhZ2VbaWR4XSA9IHZhbDtcbiAgICAgICAgICB2YXIgZGltUmF3RXh0ZW50ID0gcmF3RXh0ZW50W2RpbUlkeF07XG4gICAgICAgICAgdmFsIDwgZGltUmF3RXh0ZW50WzBdICYmIChkaW1SYXdFeHRlbnRbMF0gPSB2YWwpO1xuICAgICAgICAgIHZhbCA+IGRpbVJhd0V4dGVudFsxXSAmJiAoZGltUmF3RXh0ZW50WzFdID0gdmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXByb3ZpZGVyLnBlcnNpc3RlbnQgJiYgcHJvdmlkZXIuY2xlYW4pIHtcbiAgICAgIC8vIENsZWFuIHVudXNlZCBkYXRhIGlmIGRhdGEgc291cmNlIGlzIHR5cGVkIGFycmF5LlxuICAgICAgcHJvdmlkZXIuY2xlYW4oKTtcbiAgICB9XG4gICAgdGhpcy5fcmF3Q291bnQgPSB0aGlzLl9jb3VudCA9IGVuZDtcbiAgICAvLyBSZXNldCBkYXRhIGV4dGVudFxuICAgIHRoaXMuX2V4dGVudCA9IFtdO1xuICB9O1xuICBEYXRhU3RvcmUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jb3VudDtcbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IHZhbHVlLiBSZXR1cm4gTmFOIGlmIGlkeCBpcyBvdXQgb2YgcmFuZ2UuXHJcbiAgICovXG4gIERhdGFTdG9yZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGRpbSwgaWR4KSB7XG4gICAgaWYgKCEoaWR4ID49IDAgJiYgaWR4IDwgdGhpcy5fY291bnQpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB2YXIgZGltU3RvcmUgPSB0aGlzLl9jaHVua3NbZGltXTtcbiAgICByZXR1cm4gZGltU3RvcmUgPyBkaW1TdG9yZVt0aGlzLmdldFJhd0luZGV4KGlkeCldIDogTmFOO1xuICB9O1xuICBEYXRhU3RvcmUucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBpZHgpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGRpbUFyciA9IFtdO1xuICAgIGlmIChpZHggPT0gbnVsbCkge1xuICAgICAgaWR4ID0gZGltZW5zaW9ucztcbiAgICAgIC8vIFRPRE8gZ2V0IGFsbCBmcm9tIHN0b3JlP1xuICAgICAgZGltZW5zaW9ucyA9IFtdO1xuICAgICAgLy8gQWxsIGRpbWVuc2lvbnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZGltZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkaW1BcnIucHVzaChpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGltQXJyID0gZGltZW5zaW9ucztcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpbUFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFsdWVzLnB1c2godGhpcy5nZXQoZGltQXJyW2ldLCBpZHgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQHBhcmFtIGRpbSBjb25jcmV0ZSBkaW1cclxuICAgKi9cbiAgRGF0YVN0b3JlLnByb3RvdHlwZS5nZXRCeVJhd0luZGV4ID0gZnVuY3Rpb24gKGRpbSwgcmF3SWR4KSB7XG4gICAgaWYgKCEocmF3SWR4ID49IDAgJiYgcmF3SWR4IDwgdGhpcy5fcmF3Q291bnQpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB2YXIgZGltU3RvcmUgPSB0aGlzLl9jaHVua3NbZGltXTtcbiAgICByZXR1cm4gZGltU3RvcmUgPyBkaW1TdG9yZVtyYXdJZHhdIDogTmFOO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgc3VtIG9mIGRhdGEgaW4gb25lIGRpbWVuc2lvblxyXG4gICAqL1xuICBEYXRhU3RvcmUucHJvdG90eXBlLmdldFN1bSA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgICB2YXIgZGltRGF0YSA9IHRoaXMuX2NodW5rc1tkaW1dO1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGlmIChkaW1EYXRhKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoZGltLCBpKTtcbiAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IG1lZGlhbiBvZiBkYXRhIGluIG9uZSBkaW1lbnNpb25cclxuICAgKi9cbiAgRGF0YVN0b3JlLnByb3RvdHlwZS5nZXRNZWRpYW4gPSBmdW5jdGlvbiAoZGltKSB7XG4gICAgdmFyIGRpbURhdGFBcnJheSA9IFtdO1xuICAgIC8vIG1hcCBhbGwgZGF0YSBvZiBvbmUgZGltZW5zaW9uXG4gICAgdGhpcy5lYWNoKFtkaW1dLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgZGltRGF0YUFycmF5LnB1c2godmFsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBUT0RPXG4gICAgLy8gVXNlIHF1aWNrIHNlbGVjdD9cbiAgICB2YXIgc29ydGVkRGltRGF0YUFycmF5ID0gZGltRGF0YUFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTtcbiAgICB2YXIgbGVuID0gdGhpcy5jb3VudCgpO1xuICAgIC8vIGNhbGN1bGF0ZSBtZWRpYW5cbiAgICByZXR1cm4gbGVuID09PSAwID8gMCA6IGxlbiAlIDIgPT09IDEgPyBzb3J0ZWREaW1EYXRhQXJyYXlbKGxlbiAtIDEpIC8gMl0gOiAoc29ydGVkRGltRGF0YUFycmF5W2xlbiAvIDJdICsgc29ydGVkRGltRGF0YUFycmF5W2xlbiAvIDIgLSAxXSkgLyAyO1xuICB9O1xuICAvKipcclxuICAgKiBSZXRyaWV2ZSB0aGUgaW5kZXggd2l0aCBnaXZlbiByYXcgZGF0YSBpbmRleC5cclxuICAgKi9cbiAgRGF0YVN0b3JlLnByb3RvdHlwZS5pbmRleE9mUmF3SW5kZXggPSBmdW5jdGlvbiAocmF3SW5kZXgpIHtcbiAgICBpZiAocmF3SW5kZXggPj0gdGhpcy5fcmF3Q291bnQgfHwgcmF3SW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICghdGhpcy5faW5kaWNlcykge1xuICAgICAgcmV0dXJuIHJhd0luZGV4O1xuICAgIH1cbiAgICAvLyBJbmRpY2VzIGFyZSBhc2NlbmRpbmdcbiAgICB2YXIgaW5kaWNlcyA9IHRoaXMuX2luZGljZXM7XG4gICAgLy8gSWYgcmF3SW5kZXggPT09IGRhdGFJbmRleFxuICAgIHZhciByYXdEYXRhSW5kZXggPSBpbmRpY2VzW3Jhd0luZGV4XTtcbiAgICBpZiAocmF3RGF0YUluZGV4ICE9IG51bGwgJiYgcmF3RGF0YUluZGV4IDwgdGhpcy5fY291bnQgJiYgcmF3RGF0YUluZGV4ID09PSByYXdJbmRleCkge1xuICAgICAgcmV0dXJuIHJhd0luZGV4O1xuICAgIH1cbiAgICB2YXIgbGVmdCA9IDA7XG4gICAgdmFyIHJpZ2h0ID0gdGhpcy5fY291bnQgLSAxO1xuICAgIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgICB2YXIgbWlkID0gKGxlZnQgKyByaWdodCkgLyAyIHwgMDtcbiAgICAgIGlmIChpbmRpY2VzW21pZF0gPCByYXdJbmRleCkge1xuICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kaWNlc1ttaWRdID4gcmF3SW5kZXgpIHtcbiAgICAgICAgcmlnaHQgPSBtaWQgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuICAvKipcclxuICAgKiBSZXRyaWV2ZSB0aGUgaW5kZXggb2YgbmVhcmVzdCB2YWx1ZS5cclxuICAgKiBAcGFyYW0gZGltXHJcbiAgICogQHBhcmFtIHZhbHVlXHJcbiAgICogQHBhcmFtIFttYXhEaXN0YW5jZT1JbmZpbml0eV1cclxuICAgKiBAcmV0dXJuIElmIGFuZCBvbmx5IGlmIG11bHRpcGxlIGluZGljZXMgaGF2ZVxyXG4gICAqICAgICAgICAgdGhlIHNhbWUgdmFsdWUsIHRoZXkgYXJlIHB1dCB0byB0aGUgcmVzdWx0LlxyXG4gICAqL1xuICBEYXRhU3RvcmUucHJvdG90eXBlLmluZGljZXNPZk5lYXJlc3QgPSBmdW5jdGlvbiAoZGltLCB2YWx1ZSwgbWF4RGlzdGFuY2UpIHtcbiAgICB2YXIgY2h1bmtzID0gdGhpcy5fY2h1bmtzO1xuICAgIHZhciBkaW1EYXRhID0gY2h1bmtzW2RpbV07XG4gICAgdmFyIG5lYXJlc3RJbmRpY2VzID0gW107XG4gICAgaWYgKCFkaW1EYXRhKSB7XG4gICAgICByZXR1cm4gbmVhcmVzdEluZGljZXM7XG4gICAgfVxuICAgIGlmIChtYXhEaXN0YW5jZSA9PSBudWxsKSB7XG4gICAgICBtYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIH1cbiAgICB2YXIgbWluRGlzdCA9IEluZmluaXR5O1xuICAgIHZhciBtaW5EaWZmID0gLTE7XG4gICAgdmFyIG5lYXJlc3RJbmRpY2VzTGVuID0gMDtcbiAgICAvLyBDaGVjayB0aGUgdGVzdCBjYXNlIG9mIGB0ZXN0L3V0L3NwZWMvZGF0YS9TZXJpZXNEYXRhLmpzYC5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBkYXRhSW5kZXggPSB0aGlzLmdldFJhd0luZGV4KGkpO1xuICAgICAgdmFyIGRpZmYgPSB2YWx1ZSAtIGRpbURhdGFbZGF0YUluZGV4XTtcbiAgICAgIHZhciBkaXN0ID0gTWF0aC5hYnMoZGlmZik7XG4gICAgICBpZiAoZGlzdCA8PSBtYXhEaXN0YW5jZSkge1xuICAgICAgICAvLyBXaGVuIHRoZSBgdmFsdWVgIGlzIGF0IHRoZSBtaWRkbGUgb2YgYHRoaXMuZ2V0KGRpbSwgaSlgIGFuZCBgdGhpcy5nZXQoZGltLCBpKzEpYCxcbiAgICAgICAgLy8gd2UnZCBiZXR0ZXIgbm90IHB1c2ggYm90aCBvZiB0aGVtIHRvIGBuZWFyZXN0SW5kaWNlc2AsIG90aGVyd2lzZSBpdCBpcyBlYXN5IHRvXG4gICAgICAgIC8vIGdldCBtb3JlIHRoYW4gb25lIGl0ZW0gaW4gYG5lYXJlc3RJbmRpY2VzYCAobW9yZSBzcGVjaWZpY2FsbHksIGluIGB0b29sdGlwYCkuXG4gICAgICAgIC8vIFNvIHdlIGNob29zZSB0aGUgb25lIHRoYXQgYGRpZmYgPj0gMGAgaW4gdGhpcyBjYXNlLlxuICAgICAgICAvLyBCdXQgaWYgYHRoaXMuZ2V0KGRpbSwgaSlgIGFuZCBgdGhpcy5nZXQoZGltLCBqKWAgZ2V0IHRoZSBzYW1lIHZhbHVlLCBib3RoIG9mIHRoZW1cbiAgICAgICAgLy8gc2hvdWxkIGJlIHB1c2ggdG8gYG5lYXJlc3RJbmRpY2VzYC5cbiAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0IHx8IGRpc3QgPT09IG1pbkRpc3QgJiYgZGlmZiA+PSAwICYmIG1pbkRpZmYgPCAwKSB7XG4gICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgbWluRGlmZiA9IGRpZmY7XG4gICAgICAgICAgbmVhcmVzdEluZGljZXNMZW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWZmID09PSBtaW5EaWZmKSB7XG4gICAgICAgICAgbmVhcmVzdEluZGljZXNbbmVhcmVzdEluZGljZXNMZW4rK10gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5lYXJlc3RJbmRpY2VzLmxlbmd0aCA9IG5lYXJlc3RJbmRpY2VzTGVuO1xuICAgIHJldHVybiBuZWFyZXN0SW5kaWNlcztcbiAgfTtcbiAgRGF0YVN0b3JlLnByb3RvdHlwZS5nZXRJbmRpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXdJbmRpY2VzO1xuICAgIHZhciBpbmRpY2VzID0gdGhpcy5faW5kaWNlcztcbiAgICBpZiAoaW5kaWNlcykge1xuICAgICAgdmFyIEN0b3IgPSBpbmRpY2VzLmNvbnN0cnVjdG9yO1xuICAgICAgdmFyIHRoaXNDb3VudCA9IHRoaXMuX2NvdW50O1xuICAgICAgLy8gYG5ldyBBcnJheShhLCBiLCBjKWAgaXMgZGlmZmVyZW50IGZyb20gYG5ldyBVaW50MzJBcnJheShhLCBiLCBjKWAuXG4gICAgICBpZiAoQ3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgbmV3SW5kaWNlcyA9IG5ldyBDdG9yKHRoaXNDb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpc0NvdW50OyBpKyspIHtcbiAgICAgICAgICBuZXdJbmRpY2VzW2ldID0gaW5kaWNlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3SW5kaWNlcyA9IG5ldyBDdG9yKGluZGljZXMuYnVmZmVyLCAwLCB0aGlzQ291bnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgQ3RvciA9IGdldEluZGljZXNDdG9yKHRoaXMuX3Jhd0NvdW50KTtcbiAgICAgIG5ld0luZGljZXMgPSBuZXcgQ3Rvcih0aGlzLmNvdW50KCkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0luZGljZXNbaV0gPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3SW5kaWNlcztcbiAgfTtcbiAgLyoqXHJcbiAgICogRGF0YSBmaWx0ZXIuXHJcbiAgICovXG4gIERhdGFTdG9yZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGRpbXMsIGNiKSB7XG4gICAgaWYgKCF0aGlzLl9jb3VudCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBuZXdTdG9yZSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgY291bnQgPSBuZXdTdG9yZS5jb3VudCgpO1xuICAgIHZhciBDdG9yID0gZ2V0SW5kaWNlc0N0b3IobmV3U3RvcmUuX3Jhd0NvdW50KTtcbiAgICB2YXIgbmV3SW5kaWNlcyA9IG5ldyBDdG9yKGNvdW50KTtcbiAgICB2YXIgdmFsdWUgPSBbXTtcbiAgICB2YXIgZGltU2l6ZSA9IGRpbXMubGVuZ3RoO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBkaW0wID0gZGltc1swXTtcbiAgICB2YXIgY2h1bmtzID0gbmV3U3RvcmUuX2NodW5rcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIHZhciBrZWVwID0gdm9pZCAwO1xuICAgICAgdmFyIHJhd0lkeCA9IG5ld1N0b3JlLmdldFJhd0luZGV4KGkpO1xuICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxuICAgICAgaWYgKGRpbVNpemUgPT09IDApIHtcbiAgICAgICAga2VlcCA9IGNiKGkpO1xuICAgICAgfSBlbHNlIGlmIChkaW1TaXplID09PSAxKSB7XG4gICAgICAgIHZhciB2YWwgPSBjaHVua3NbZGltMF1bcmF3SWR4XTtcbiAgICAgICAga2VlcCA9IGNiKHZhbCwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgIGZvciAoOyBrIDwgZGltU2l6ZTsgaysrKSB7XG4gICAgICAgICAgdmFsdWVba10gPSBjaHVua3NbZGltc1trXV1bcmF3SWR4XTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZVtrXSA9IGk7XG4gICAgICAgIGtlZXAgPSBjYi5hcHBseShudWxsLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoa2VlcCkge1xuICAgICAgICBuZXdJbmRpY2VzW29mZnNldCsrXSA9IHJhd0lkeDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU2V0IGluZGljZXMgYWZ0ZXIgZmlsdGVyZWQuXG4gICAgaWYgKG9mZnNldCA8IGNvdW50KSB7XG4gICAgICBuZXdTdG9yZS5faW5kaWNlcyA9IG5ld0luZGljZXM7XG4gICAgfVxuICAgIG5ld1N0b3JlLl9jb3VudCA9IG9mZnNldDtcbiAgICAvLyBSZXNldCBkYXRhIGV4dGVudFxuICAgIG5ld1N0b3JlLl9leHRlbnQgPSBbXTtcbiAgICBuZXdTdG9yZS5fdXBkYXRlR2V0UmF3SWR4KCk7XG4gICAgcmV0dXJuIG5ld1N0b3JlO1xuICB9O1xuICAvKipcclxuICAgKiBTZWxlY3QgZGF0YSBpbiByYW5nZS4gKEZvciBvcHRpbWl6YXRpb24gb2YgZmlsdGVyKVxyXG4gICAqIChNYW51YWxseSBpbmxpbmUgY29kZSwgc3VwcG9ydCA1IG1pbGxpb24gZGF0YSBmaWx0ZXJpbmcgaW4gZGF0YSB6b29tLilcclxuICAgKi9cbiAgRGF0YVN0b3JlLnByb3RvdHlwZS5zZWxlY3RSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIHZhciBuZXdTdG9yZSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgbGVuID0gbmV3U3RvcmUuX2NvdW50O1xuICAgIGlmICghbGVuKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGRpbXMgPSBrZXlzKHJhbmdlKTtcbiAgICB2YXIgZGltU2l6ZSA9IGRpbXMubGVuZ3RoO1xuICAgIGlmICghZGltU2l6ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBvcmlnaW5hbENvdW50ID0gbmV3U3RvcmUuY291bnQoKTtcbiAgICB2YXIgQ3RvciA9IGdldEluZGljZXNDdG9yKG5ld1N0b3JlLl9yYXdDb3VudCk7XG4gICAgdmFyIG5ld0luZGljZXMgPSBuZXcgQ3RvcihvcmlnaW5hbENvdW50KTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgZGltMCA9IGRpbXNbMF07XG4gICAgdmFyIG1pbiA9IHJhbmdlW2RpbTBdWzBdO1xuICAgIHZhciBtYXggPSByYW5nZVtkaW0wXVsxXTtcbiAgICB2YXIgc3RvcmVBcnIgPSBuZXdTdG9yZS5fY2h1bmtzO1xuICAgIHZhciBxdWlja0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgaWYgKCFuZXdTdG9yZS5faW5kaWNlcykge1xuICAgICAgLy8gRXh0cmVtZSBvcHRpbWl6YXRpb24gZm9yIGNvbW1vbiBjYXNlLiBBYm91dCAyeCBmYXN0ZXIgaW4gY2hyb21lLlxuICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICBpZiAoZGltU2l6ZSA9PT0gMSkge1xuICAgICAgICB2YXIgZGltU3RvcmFnZSA9IHN0b3JlQXJyW2RpbXNbMF1dO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGRpbVN0b3JhZ2VbaV07XG4gICAgICAgICAgLy8gTmFOIHdpbGwgbm90IGJlIGZpbHRlcmVkLiBDb25zaWRlciB0aGUgY2FzZSwgaW4gbGluZSBjaGFydCwgZW1wdHlcbiAgICAgICAgICAvLyB2YWx1ZSBpbmRpY2F0ZXMgdGhlIGxpbmUgc2hvdWxkIGJlIGJyb2tlbi4gQnV0IGZvciB0aGUgY2FzZSBsaWtlXG4gICAgICAgICAgLy8gc2NhdHRlciBwbG90LCBhIGRhdGEgaXRlbSB3aXRoIGVtcHR5IHZhbHVlIHdpbGwgbm90IGJlIHJlbmRlcmVkLFxuICAgICAgICAgIC8vIGJ1dCB0aGUgYXhpcyBleHRlbnQgbWF5IGJlIGVmZmVjdGVkIGlmIHNvbWUgb3RoZXIgZGltIG9mIHRoZSBkYXRhXG4gICAgICAgICAgLy8gaXRlbSBoYXMgdmFsdWUuIEZvcnR1bmF0ZWx5IGl0IGlzIG5vdCBhIHNpZ25pZmljYW50IG5lZ2F0aXZlIGVmZmVjdC5cbiAgICAgICAgICBpZiAodmFsID49IG1pbiAmJiB2YWwgPD0gbWF4IHx8IGlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgIG5ld0luZGljZXNbb2Zmc2V0KytdID0gaWR4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZHgrKztcbiAgICAgICAgfVxuICAgICAgICBxdWlja0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGltU2l6ZSA9PT0gMikge1xuICAgICAgICB2YXIgZGltU3RvcmFnZSA9IHN0b3JlQXJyW2RpbXNbMF1dO1xuICAgICAgICB2YXIgZGltU3RvcmFnZTIgPSBzdG9yZUFycltkaW1zWzFdXTtcbiAgICAgICAgdmFyIG1pbjIgPSByYW5nZVtkaW1zWzFdXVswXTtcbiAgICAgICAgdmFyIG1heDIgPSByYW5nZVtkaW1zWzFdXVsxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciB2YWwgPSBkaW1TdG9yYWdlW2ldO1xuICAgICAgICAgIHZhciB2YWwyID0gZGltU3RvcmFnZTJbaV07XG4gICAgICAgICAgLy8gRG8gbm90IGZpbHRlciBOYU4sIHNlZSBjb21tZW50IGFib3ZlLlxuICAgICAgICAgIGlmICgodmFsID49IG1pbiAmJiB2YWwgPD0gbWF4IHx8IGlzTmFOKHZhbCkpICYmICh2YWwyID49IG1pbjIgJiYgdmFsMiA8PSBtYXgyIHx8IGlzTmFOKHZhbDIpKSkge1xuICAgICAgICAgICAgbmV3SW5kaWNlc1tvZmZzZXQrK10gPSBpZHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkeCsrO1xuICAgICAgICB9XG4gICAgICAgIHF1aWNrRmluaXNoZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXF1aWNrRmluaXNoZWQpIHtcbiAgICAgIGlmIChkaW1TaXplID09PSAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JpZ2luYWxDb3VudDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJhd0luZGV4ID0gbmV3U3RvcmUuZ2V0UmF3SW5kZXgoaSk7XG4gICAgICAgICAgdmFyIHZhbCA9IHN0b3JlQXJyW2RpbXNbMF1dW3Jhd0luZGV4XTtcbiAgICAgICAgICAvLyBEbyBub3QgZmlsdGVyIE5hTiwgc2VlIGNvbW1lbnQgYWJvdmUuXG4gICAgICAgICAgaWYgKHZhbCA+PSBtaW4gJiYgdmFsIDw9IG1heCB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgICAgICBuZXdJbmRpY2VzW29mZnNldCsrXSA9IHJhd0luZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmlnaW5hbENvdW50OyBpKyspIHtcbiAgICAgICAgICB2YXIga2VlcCA9IHRydWU7XG4gICAgICAgICAgdmFyIHJhd0luZGV4ID0gbmV3U3RvcmUuZ2V0UmF3SW5kZXgoaSk7XG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBkaW1TaXplOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBkaW1rID0gZGltc1trXTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBzdG9yZUFycltkaW1rXVtyYXdJbmRleF07XG4gICAgICAgICAgICAvLyBEbyBub3QgZmlsdGVyIE5hTiwgc2VlIGNvbW1lbnQgYWJvdmUuXG4gICAgICAgICAgICBpZiAodmFsIDwgcmFuZ2VbZGlta11bMF0gfHwgdmFsID4gcmFuZ2VbZGlta11bMV0pIHtcbiAgICAgICAgICAgICAga2VlcCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa2VlcCkge1xuICAgICAgICAgICAgbmV3SW5kaWNlc1tvZmZzZXQrK10gPSBuZXdTdG9yZS5nZXRSYXdJbmRleChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU2V0IGluZGljZXMgYWZ0ZXIgZmlsdGVyZWQuXG4gICAgaWYgKG9mZnNldCA8IG9yaWdpbmFsQ291bnQpIHtcbiAgICAgIG5ld1N0b3JlLl9pbmRpY2VzID0gbmV3SW5kaWNlcztcbiAgICB9XG4gICAgbmV3U3RvcmUuX2NvdW50ID0gb2Zmc2V0O1xuICAgIC8vIFJlc2V0IGRhdGEgZXh0ZW50XG4gICAgbmV3U3RvcmUuX2V4dGVudCA9IFtdO1xuICAgIG5ld1N0b3JlLl91cGRhdGVHZXRSYXdJZHgoKTtcbiAgICByZXR1cm4gbmV3U3RvcmU7XG4gIH07XG4gIC8vIC8qKlxuICAvLyAgKiBEYXRhIG1hcHBpbmcgdG8gYSBwbGFpbiBhcnJheVxuICAvLyAgKi9cbiAgLy8gbWFwQXJyYXkoZGltczogRGltZW5zaW9uSW5kZXhbXSwgY2I6IE1hcEFycmF5Q2IpOiBhbnlbXSB7XG4gIC8vICAgICBjb25zdCByZXN1bHQ6IGFueVtdID0gW107XG4gIC8vICAgICB0aGlzLmVhY2goZGltcywgZnVuY3Rpb24gKCkge1xuICAvLyAgICAgICAgIHJlc3VsdC5wdXNoKGNiICYmIChjYiBhcyBNYXBBcnJheUNiKS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgLy8gICAgIH0pO1xuICAvLyAgICAgcmV0dXJuIHJlc3VsdDtcbiAgLy8gfVxuICAvKipcclxuICAgKiBEYXRhIG1hcHBpbmcgdG8gYSBuZXcgTGlzdCB3aXRoIGdpdmVuIGRpbWVuc2lvbnNcclxuICAgKi9cbiAgRGF0YVN0b3JlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZGltcywgY2IpIHtcbiAgICAvLyBUT0RPIG9ubHkgY2xvbmUgcGlja2VkIGNodW5rcy5cbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5jbG9uZShkaW1zKTtcbiAgICB0aGlzLl91cGRhdGVEaW1zKHRhcmdldCwgZGltcywgY2IpO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBjYXV0aW9uIERhbmdlciEhIE9ubHkgdXNlZCBpbiBkYXRhU3RhY2suXHJcbiAgICovXG4gIERhdGFTdG9yZS5wcm90b3R5cGUubW9kaWZ5ID0gZnVuY3Rpb24gKGRpbXMsIGNiKSB7XG4gICAgdGhpcy5fdXBkYXRlRGltcyh0aGlzLCBkaW1zLCBjYik7XG4gIH07XG4gIERhdGFTdG9yZS5wcm90b3R5cGUuX3VwZGF0ZURpbXMgPSBmdW5jdGlvbiAodGFyZ2V0LCBkaW1zLCBjYikge1xuICAgIHZhciB0YXJnZXRDaHVua3MgPSB0YXJnZXQuX2NodW5rcztcbiAgICB2YXIgdG1wUmV0VmFsdWUgPSBbXTtcbiAgICB2YXIgZGltU2l6ZSA9IGRpbXMubGVuZ3RoO1xuICAgIHZhciBkYXRhQ291bnQgPSB0YXJnZXQuY291bnQoKTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIHJhd0V4dGVudCA9IHRhcmdldC5fcmF3RXh0ZW50O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmF3RXh0ZW50W2RpbXNbaV1dID0gZ2V0SW5pdGlhbEV4dGVudCgpO1xuICAgIH1cbiAgICBmb3IgKHZhciBkYXRhSW5kZXggPSAwOyBkYXRhSW5kZXggPCBkYXRhQ291bnQ7IGRhdGFJbmRleCsrKSB7XG4gICAgICB2YXIgcmF3SW5kZXggPSB0YXJnZXQuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KTtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltU2l6ZTsgaysrKSB7XG4gICAgICAgIHZhbHVlc1trXSA9IHRhcmdldENodW5rc1tkaW1zW2tdXVtyYXdJbmRleF07XG4gICAgICB9XG4gICAgICB2YWx1ZXNbZGltU2l6ZV0gPSBkYXRhSW5kZXg7XG4gICAgICB2YXIgcmV0VmFsdWUgPSBjYiAmJiBjYi5hcHBseShudWxsLCB2YWx1ZXMpO1xuICAgICAgaWYgKHJldFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgLy8gYSBudW1iZXIgb3Igc3RyaW5nIChpbiBvcmlkaW5hbCBkaW1lbnNpb24pP1xuICAgICAgICBpZiAodHlwZW9mIHJldFZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRtcFJldFZhbHVlWzBdID0gcmV0VmFsdWU7XG4gICAgICAgICAgcmV0VmFsdWUgPSB0bXBSZXRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGRpbSA9IGRpbXNbaV07XG4gICAgICAgICAgdmFyIHZhbCA9IHJldFZhbHVlW2ldO1xuICAgICAgICAgIHZhciByYXdFeHRlbnRPbkRpbSA9IHJhd0V4dGVudFtkaW1dO1xuICAgICAgICAgIHZhciBkaW1TdG9yZSA9IHRhcmdldENodW5rc1tkaW1dO1xuICAgICAgICAgIGlmIChkaW1TdG9yZSkge1xuICAgICAgICAgICAgZGltU3RvcmVbcmF3SW5kZXhdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsIDwgcmF3RXh0ZW50T25EaW1bMF0pIHtcbiAgICAgICAgICAgIHJhd0V4dGVudE9uRGltWzBdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsID4gcmF3RXh0ZW50T25EaW1bMV0pIHtcbiAgICAgICAgICAgIHJhd0V4dGVudE9uRGltWzFdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogTGFyZ2UgZGF0YSBkb3duIHNhbXBsaW5nIHVzaW5nIGxhcmdlc3QtdHJpYW5nbGUtdGhyZWUtYnVja2V0c1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZURpbWVuc2lvblxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRDb3VudFxyXG4gICAqL1xuICBEYXRhU3RvcmUucHJvdG90eXBlLmx0dGJEb3duU2FtcGxlID0gZnVuY3Rpb24gKHZhbHVlRGltZW5zaW9uLCByYXRlKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuY2xvbmUoW3ZhbHVlRGltZW5zaW9uXSwgdHJ1ZSk7XG4gICAgdmFyIHRhcmdldFN0b3JhZ2UgPSB0YXJnZXQuX2NodW5rcztcbiAgICB2YXIgZGltU3RvcmUgPSB0YXJnZXRTdG9yYWdlW3ZhbHVlRGltZW5zaW9uXTtcbiAgICB2YXIgbGVuID0gdGhpcy5jb3VudCgpO1xuICAgIHZhciBzYW1wbGVkSW5kZXggPSAwO1xuICAgIHZhciBmcmFtZVNpemUgPSBNYXRoLmZsb29yKDEgLyByYXRlKTtcbiAgICB2YXIgY3VycmVudFJhd0luZGV4ID0gdGhpcy5nZXRSYXdJbmRleCgwKTtcbiAgICB2YXIgbWF4QXJlYTtcbiAgICB2YXIgYXJlYTtcbiAgICB2YXIgbmV4dFJhd0luZGV4O1xuICAgIHZhciBuZXdJbmRpY2VzID0gbmV3IChnZXRJbmRpY2VzQ3Rvcih0aGlzLl9yYXdDb3VudCkpKE1hdGgubWluKChNYXRoLmNlaWwobGVuIC8gZnJhbWVTaXplKSArIDIpICogMiwgbGVuKSk7XG4gICAgLy8gRmlyc3QgZnJhbWUgdXNlIHRoZSBmaXJzdCBkYXRhLlxuICAgIG5ld0luZGljZXNbc2FtcGxlZEluZGV4KytdID0gY3VycmVudFJhd0luZGV4O1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuIC0gMTsgaSArPSBmcmFtZVNpemUpIHtcbiAgICAgIHZhciBuZXh0RnJhbWVTdGFydCA9IE1hdGgubWluKGkgKyBmcmFtZVNpemUsIGxlbiAtIDEpO1xuICAgICAgdmFyIG5leHRGcmFtZUVuZCA9IE1hdGgubWluKGkgKyBmcmFtZVNpemUgKiAyLCBsZW4pO1xuICAgICAgdmFyIGF2Z1ggPSAobmV4dEZyYW1lRW5kICsgbmV4dEZyYW1lU3RhcnQpIC8gMjtcbiAgICAgIHZhciBhdmdZID0gMDtcbiAgICAgIGZvciAodmFyIGlkeCA9IG5leHRGcmFtZVN0YXJ0OyBpZHggPCBuZXh0RnJhbWVFbmQ7IGlkeCsrKSB7XG4gICAgICAgIHZhciByYXdJbmRleCA9IHRoaXMuZ2V0UmF3SW5kZXgoaWR4KTtcbiAgICAgICAgdmFyIHkgPSBkaW1TdG9yZVtyYXdJbmRleF07XG4gICAgICAgIGlmIChpc05hTih5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGF2Z1kgKz0geTtcbiAgICAgIH1cbiAgICAgIGF2Z1kgLz0gbmV4dEZyYW1lRW5kIC0gbmV4dEZyYW1lU3RhcnQ7XG4gICAgICB2YXIgZnJhbWVTdGFydCA9IGk7XG4gICAgICB2YXIgZnJhbWVFbmQgPSBNYXRoLm1pbihpICsgZnJhbWVTaXplLCBsZW4pO1xuICAgICAgdmFyIHBvaW50QVggPSBpIC0gMTtcbiAgICAgIHZhciBwb2ludEFZID0gZGltU3RvcmVbY3VycmVudFJhd0luZGV4XTtcbiAgICAgIG1heEFyZWEgPSAtMTtcbiAgICAgIG5leHRSYXdJbmRleCA9IGZyYW1lU3RhcnQ7XG4gICAgICB2YXIgZmlyc3ROYU5JbmRleCA9IC0xO1xuICAgICAgdmFyIGNvdW50TmFOID0gMDtcbiAgICAgIC8vIEZpbmQgYSBwb2ludCBmcm9tIGN1cnJlbnQgZnJhbWUgdGhhdCBjb25zdHJ1Y3QgYSB0cmlhbmdsZSB3aXRoIGxhcmdlc3QgYXJlYSB3aXRoIHByZXZpb3VzIHNlbGVjdGVkIHBvaW50XG4gICAgICAvLyBBbmQgdGhlIGF2ZXJhZ2Ugb2YgbmV4dCBmcmFtZS5cbiAgICAgIGZvciAodmFyIGlkeCA9IGZyYW1lU3RhcnQ7IGlkeCA8IGZyYW1lRW5kOyBpZHgrKykge1xuICAgICAgICB2YXIgcmF3SW5kZXggPSB0aGlzLmdldFJhd0luZGV4KGlkeCk7XG4gICAgICAgIHZhciB5ID0gZGltU3RvcmVbcmF3SW5kZXhdO1xuICAgICAgICBpZiAoaXNOYU4oeSkpIHtcbiAgICAgICAgICBjb3VudE5hTisrO1xuICAgICAgICAgIGlmIChmaXJzdE5hTkluZGV4IDwgMCkge1xuICAgICAgICAgICAgZmlyc3ROYU5JbmRleCA9IHJhd0luZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYW5nbGUgYXJlYSBvdmVyIHRocmVlIGJ1Y2tldHNcbiAgICAgICAgYXJlYSA9IE1hdGguYWJzKChwb2ludEFYIC0gYXZnWCkgKiAoeSAtIHBvaW50QVkpIC0gKHBvaW50QVggLSBpZHgpICogKGF2Z1kgLSBwb2ludEFZKSk7XG4gICAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICAgIG1heEFyZWEgPSBhcmVhO1xuICAgICAgICAgIG5leHRSYXdJbmRleCA9IHJhd0luZGV4OyAvLyBOZXh0IGEgaXMgdGhpcyBiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb3VudE5hTiA+IDAgJiYgY291bnROYU4gPCBmcmFtZUVuZCAtIGZyYW1lU3RhcnQpIHtcbiAgICAgICAgLy8gQXBwZW5kIGZpcnN0IE5hTiBwb2ludCBpbiBldmVyeSBidWNrZXQuXG4gICAgICAgIC8vIEl0IGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhlIGNvcnJlY3Qgb3JkZXIgb2YgaW5kaWNlcy5cbiAgICAgICAgbmV3SW5kaWNlc1tzYW1wbGVkSW5kZXgrK10gPSBNYXRoLm1pbihmaXJzdE5hTkluZGV4LCBuZXh0UmF3SW5kZXgpO1xuICAgICAgICBuZXh0UmF3SW5kZXggPSBNYXRoLm1heChmaXJzdE5hTkluZGV4LCBuZXh0UmF3SW5kZXgpO1xuICAgICAgfVxuICAgICAgbmV3SW5kaWNlc1tzYW1wbGVkSW5kZXgrK10gPSBuZXh0UmF3SW5kZXg7XG4gICAgICBjdXJyZW50UmF3SW5kZXggPSBuZXh0UmF3SW5kZXg7IC8vIFRoaXMgYSBpcyB0aGUgbmV4dCBhIChjaG9zZW4gYilcbiAgICB9XG4gICAgLy8gRmlyc3QgZnJhbWUgdXNlIHRoZSBsYXN0IGRhdGEuXG4gICAgbmV3SW5kaWNlc1tzYW1wbGVkSW5kZXgrK10gPSB0aGlzLmdldFJhd0luZGV4KGxlbiAtIDEpO1xuICAgIHRhcmdldC5fY291bnQgPSBzYW1wbGVkSW5kZXg7XG4gICAgdGFyZ2V0Ll9pbmRpY2VzID0gbmV3SW5kaWNlcztcbiAgICB0YXJnZXQuZ2V0UmF3SW5kZXggPSB0aGlzLl9nZXRSYXdJZHg7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgLyoqXHJcbiAgICogTGFyZ2UgZGF0YSBkb3duIHNhbXBsaW5nIHVzaW5nIG1pbi1tYXhcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVEaW1lbnNpb25cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcmF0ZVxyXG4gICAqL1xuICBEYXRhU3RvcmUucHJvdG90eXBlLm1pbm1heERvd25TYW1wbGUgPSBmdW5jdGlvbiAodmFsdWVEaW1lbnNpb24sIHJhdGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5jbG9uZShbdmFsdWVEaW1lbnNpb25dLCB0cnVlKTtcbiAgICB2YXIgdGFyZ2V0U3RvcmFnZSA9IHRhcmdldC5fY2h1bmtzO1xuICAgIHZhciBmcmFtZVNpemUgPSBNYXRoLmZsb29yKDEgLyByYXRlKTtcbiAgICB2YXIgZGltU3RvcmUgPSB0YXJnZXRTdG9yYWdlW3ZhbHVlRGltZW5zaW9uXTtcbiAgICB2YXIgbGVuID0gdGhpcy5jb3VudCgpO1xuICAgIC8vIEVhY2ggZnJhbWUgcmVzdWx0cyBpbiAyIGRhdGEgcG9pbnRzLCBvbmUgZm9yIG1pbiBhbmQgb25lIGZvciBtYXhcbiAgICB2YXIgbmV3SW5kaWNlcyA9IG5ldyAoZ2V0SW5kaWNlc0N0b3IodGhpcy5fcmF3Q291bnQpKShNYXRoLmNlaWwobGVuIC8gZnJhbWVTaXplKSAqIDIpO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IGZyYW1lU2l6ZSkge1xuICAgICAgdmFyIG1pbkluZGV4ID0gaTtcbiAgICAgIHZhciBtaW5WYWx1ZSA9IGRpbVN0b3JlW3RoaXMuZ2V0UmF3SW5kZXgobWluSW5kZXgpXTtcbiAgICAgIHZhciBtYXhJbmRleCA9IGk7XG4gICAgICB2YXIgbWF4VmFsdWUgPSBkaW1TdG9yZVt0aGlzLmdldFJhd0luZGV4KG1heEluZGV4KV07XG4gICAgICB2YXIgdGhpc0ZyYW1lU2l6ZSA9IGZyYW1lU2l6ZTtcbiAgICAgIC8vIEhhbmRsZSBmaW5hbCBzbWFsbGVyIGZyYW1lXG4gICAgICBpZiAoaSArIGZyYW1lU2l6ZSA+IGxlbikge1xuICAgICAgICB0aGlzRnJhbWVTaXplID0gbGVuIC0gaTtcbiAgICAgIH1cbiAgICAgIC8vIERldGVybWluZSBtaW4gYW5kIG1heCB3aXRoaW4gdGhlIGN1cnJlbnQgZnJhbWVcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpc0ZyYW1lU2l6ZTsgaysrKSB7XG4gICAgICAgIHZhciByYXdJbmRleCA9IHRoaXMuZ2V0UmF3SW5kZXgoaSArIGspO1xuICAgICAgICB2YXIgdmFsdWUgPSBkaW1TdG9yZVtyYXdJbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSA8IG1pblZhbHVlKSB7XG4gICAgICAgICAgbWluVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBtaW5JbmRleCA9IGkgKyBrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgbWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBtYXhJbmRleCA9IGkgKyBrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcmF3TWluSW5kZXggPSB0aGlzLmdldFJhd0luZGV4KG1pbkluZGV4KTtcbiAgICAgIHZhciByYXdNYXhJbmRleCA9IHRoaXMuZ2V0UmF3SW5kZXgobWF4SW5kZXgpO1xuICAgICAgLy8gU2V0IHRoZSBvcmRlciBvZiB0aGUgbWluIGFuZCBtYXggdmFsdWVzLCBiYXNlZCBvbiB0aGVpciBvcmRlcmluZyBpbiB0aGUgZnJhbWVcbiAgICAgIGlmIChtaW5JbmRleCA8IG1heEluZGV4KSB7XG4gICAgICAgIG5ld0luZGljZXNbb2Zmc2V0KytdID0gcmF3TWluSW5kZXg7XG4gICAgICAgIG5ld0luZGljZXNbb2Zmc2V0KytdID0gcmF3TWF4SW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdJbmRpY2VzW29mZnNldCsrXSA9IHJhd01heEluZGV4O1xuICAgICAgICBuZXdJbmRpY2VzW29mZnNldCsrXSA9IHJhd01pbkluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICB0YXJnZXQuX2NvdW50ID0gb2Zmc2V0O1xuICAgIHRhcmdldC5faW5kaWNlcyA9IG5ld0luZGljZXM7XG4gICAgdGFyZ2V0Ll91cGRhdGVHZXRSYXdJZHgoKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICAvKipcclxuICAgKiBMYXJnZSBkYXRhIGRvd24gc2FtcGxpbmcgb24gZ2l2ZW4gZGltZW5zaW9uXHJcbiAgICogQHBhcmFtIHNhbXBsZUluZGV4IFNhbXBsZSBpbmRleCBmb3IgbmFtZSBhbmQgaWRcclxuICAgKi9cbiAgRGF0YVN0b3JlLnByb3RvdHlwZS5kb3duU2FtcGxlID0gZnVuY3Rpb24gKGRpbWVuc2lvbiwgcmF0ZSwgc2FtcGxlVmFsdWUsIHNhbXBsZUluZGV4KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuY2xvbmUoW2RpbWVuc2lvbl0sIHRydWUpO1xuICAgIHZhciB0YXJnZXRTdG9yYWdlID0gdGFyZ2V0Ll9jaHVua3M7XG4gICAgdmFyIGZyYW1lVmFsdWVzID0gW107XG4gICAgdmFyIGZyYW1lU2l6ZSA9IE1hdGguZmxvb3IoMSAvIHJhdGUpO1xuICAgIHZhciBkaW1TdG9yZSA9IHRhcmdldFN0b3JhZ2VbZGltZW5zaW9uXTtcbiAgICB2YXIgbGVuID0gdGhpcy5jb3VudCgpO1xuICAgIHZhciByYXdFeHRlbnRPbkRpbSA9IHRhcmdldC5fcmF3RXh0ZW50W2RpbWVuc2lvbl0gPSBnZXRJbml0aWFsRXh0ZW50KCk7XG4gICAgdmFyIG5ld0luZGljZXMgPSBuZXcgKGdldEluZGljZXNDdG9yKHRoaXMuX3Jhd0NvdW50KSkoTWF0aC5jZWlsKGxlbiAvIGZyYW1lU2l6ZSkpO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IGZyYW1lU2l6ZSkge1xuICAgICAgLy8gTGFzdCBmcmFtZVxuICAgICAgaWYgKGZyYW1lU2l6ZSA+IGxlbiAtIGkpIHtcbiAgICAgICAgZnJhbWVTaXplID0gbGVuIC0gaTtcbiAgICAgICAgZnJhbWVWYWx1ZXMubGVuZ3RoID0gZnJhbWVTaXplO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBmcmFtZVNpemU7IGsrKykge1xuICAgICAgICB2YXIgZGF0YUlkeCA9IHRoaXMuZ2V0UmF3SW5kZXgoaSArIGspO1xuICAgICAgICBmcmFtZVZhbHVlc1trXSA9IGRpbVN0b3JlW2RhdGFJZHhdO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gc2FtcGxlVmFsdWUoZnJhbWVWYWx1ZXMpO1xuICAgICAgdmFyIHNhbXBsZUZyYW1lSWR4ID0gdGhpcy5nZXRSYXdJbmRleChNYXRoLm1pbihpICsgc2FtcGxlSW5kZXgoZnJhbWVWYWx1ZXMsIHZhbHVlKSB8fCAwLCBsZW4gLSAxKSk7XG4gICAgICAvLyBPbmx5IHdyaXRlIHZhbHVlIG9uIHRoZSBmaWx0ZXJlZCBkYXRhXG4gICAgICBkaW1TdG9yZVtzYW1wbGVGcmFtZUlkeF0gPSB2YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSA8IHJhd0V4dGVudE9uRGltWzBdKSB7XG4gICAgICAgIHJhd0V4dGVudE9uRGltWzBdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPiByYXdFeHRlbnRPbkRpbVsxXSkge1xuICAgICAgICByYXdFeHRlbnRPbkRpbVsxXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgbmV3SW5kaWNlc1tvZmZzZXQrK10gPSBzYW1wbGVGcmFtZUlkeDtcbiAgICB9XG4gICAgdGFyZ2V0Ll9jb3VudCA9IG9mZnNldDtcbiAgICB0YXJnZXQuX2luZGljZXMgPSBuZXdJbmRpY2VzO1xuICAgIHRhcmdldC5fdXBkYXRlR2V0UmF3SWR4KCk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgLyoqXHJcbiAgICogRGF0YSBpdGVyYXRpb25cclxuICAgKiBAcGFyYW0gY3R4IGRlZmF1bHQgdGhpc1xyXG4gICAqIEBleGFtcGxlXHJcbiAgICogIGxpc3QuZWFjaCgneCcsIGZ1bmN0aW9uICh4LCBpZHgpIHt9KTtcclxuICAgKiAgbGlzdC5lYWNoKFsneCcsICd5J10sIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHt9KTtcclxuICAgKiAgbGlzdC5lYWNoKGZ1bmN0aW9uIChpZHgpIHt9KVxyXG4gICAqL1xuICBEYXRhU3RvcmUucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoZGltcywgY2IpIHtcbiAgICBpZiAoIXRoaXMuX2NvdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkaW1TaXplID0gZGltcy5sZW5ndGg7XG4gICAgdmFyIGNodW5rcyA9IHRoaXMuX2NodW5rcztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciByYXdJZHggPSB0aGlzLmdldFJhd0luZGV4KGkpO1xuICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxuICAgICAgc3dpdGNoIChkaW1TaXplKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYihpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGNiKGNodW5rc1tkaW1zWzBdXVtyYXdJZHhdLCBpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNiKGNodW5rc1tkaW1zWzBdXVtyYXdJZHhdLCBjaHVua3NbZGltc1sxXV1bcmF3SWR4XSwgaSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IFtdO1xuICAgICAgICAgIGZvciAoOyBrIDwgZGltU2l6ZTsgaysrKSB7XG4gICAgICAgICAgICB2YWx1ZVtrXSA9IGNodW5rc1tkaW1zW2tdXVtyYXdJZHhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJbmRleFxuICAgICAgICAgIHZhbHVlW2tdID0gaTtcbiAgICAgICAgICBjYi5hcHBseShudWxsLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBHZXQgZXh0ZW50IG9mIGRhdGEgaW4gb25lIGRpbWVuc2lvblxyXG4gICAqL1xuICBEYXRhU3RvcmUucHJvdG90eXBlLmdldERhdGFFeHRlbnQgPSBmdW5jdGlvbiAoZGltKSB7XG4gICAgLy8gTWFrZSBzdXJlIHVzZSBjb25jcmV0ZSBkaW0gYXMgY2FjaGUgbmFtZS5cbiAgICB2YXIgZGltRGF0YSA9IHRoaXMuX2NodW5rc1tkaW1dO1xuICAgIHZhciBpbml0aWFsRXh0ZW50ID0gZ2V0SW5pdGlhbEV4dGVudCgpO1xuICAgIGlmICghZGltRGF0YSkge1xuICAgICAgcmV0dXJuIGluaXRpYWxFeHRlbnQ7XG4gICAgfVxuICAgIC8vIE1ha2UgbW9yZSBzdHJpY3QgY2hlY2tpbmdzIHRvIGVuc3VyZSBoaXR0aW5nIGNhY2hlLlxuICAgIHZhciBjdXJyRW5kID0gdGhpcy5jb3VudCgpO1xuICAgIC8vIENvbnNpZGVyIHRoZSBtb3N0IGNhc2VzIHdoZW4gdXNpbmcgZGF0YSB6b29tLCBgZ2V0RGF0YUV4dGVudGBcbiAgICAvLyBoYXBwZW5lZCBiZWZvcmUgZmlsdGVyaW5nLiBXZSBjYWNoZSByYXcgZXh0ZW50LCB3aGljaCBpcyBub3RcbiAgICAvLyBuZWNlc3NhcnkgdG8gYmUgY2xlYXJlZCBhbmQgcmVjYWxjdWxhdGVkIHdoZW4gcmVzdG9yZSBkYXRhLlxuICAgIHZhciB1c2VSYXcgPSAhdGhpcy5faW5kaWNlcztcbiAgICB2YXIgZGltRXh0ZW50O1xuICAgIGlmICh1c2VSYXcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yYXdFeHRlbnRbZGltXS5zbGljZSgpO1xuICAgIH1cbiAgICBkaW1FeHRlbnQgPSB0aGlzLl9leHRlbnRbZGltXTtcbiAgICBpZiAoZGltRXh0ZW50KSB7XG4gICAgICByZXR1cm4gZGltRXh0ZW50LnNsaWNlKCk7XG4gICAgfVxuICAgIGRpbUV4dGVudCA9IGluaXRpYWxFeHRlbnQ7XG4gICAgdmFyIG1pbiA9IGRpbUV4dGVudFswXTtcbiAgICB2YXIgbWF4ID0gZGltRXh0ZW50WzFdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VyckVuZDsgaSsrKSB7XG4gICAgICB2YXIgcmF3SWR4ID0gdGhpcy5nZXRSYXdJbmRleChpKTtcbiAgICAgIHZhciB2YWx1ZSA9IGRpbURhdGFbcmF3SWR4XTtcbiAgICAgIHZhbHVlIDwgbWluICYmIChtaW4gPSB2YWx1ZSk7XG4gICAgICB2YWx1ZSA+IG1heCAmJiAobWF4ID0gdmFsdWUpO1xuICAgIH1cbiAgICBkaW1FeHRlbnQgPSBbbWluLCBtYXhdO1xuICAgIHRoaXMuX2V4dGVudFtkaW1dID0gZGltRXh0ZW50O1xuICAgIHJldHVybiBkaW1FeHRlbnQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCByYXcgZGF0YSBpdGVtXHJcbiAgICovXG4gIERhdGFTdG9yZS5wcm90b3R5cGUuZ2V0UmF3RGF0YUl0ZW0gPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgdmFyIHJhd0lkeCA9IHRoaXMuZ2V0UmF3SW5kZXgoaWR4KTtcbiAgICBpZiAoIXRoaXMuX3Byb3ZpZGVyLnBlcnNpc3RlbnQpIHtcbiAgICAgIHZhciB2YWwgPSBbXTtcbiAgICAgIHZhciBjaHVua3MgPSB0aGlzLl9jaHVua3M7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWwucHVzaChjaHVua3NbaV1bcmF3SWR4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXIuZ2V0SXRlbShyYXdJZHgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQ2xvbmUgc2hhbGxvdy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBjbG9uZWREaW1zIERldGVybWluZSB3aGljaCBkaW1zIHRvIGNsb25lLiBXaWxsIHNoYXJlIHRoZSBkYXRhIGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICovXG4gIERhdGFTdG9yZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoY2xvbmVkRGltcywgaWdub3JlSW5kaWNlcykge1xuICAgIHZhciB0YXJnZXQgPSBuZXcgRGF0YVN0b3JlKCk7XG4gICAgdmFyIGNodW5rcyA9IHRoaXMuX2NodW5rcztcbiAgICB2YXIgY2xvbmVkRGltc01hcCA9IGNsb25lZERpbXMgJiYgcmVkdWNlKGNsb25lZERpbXMsIGZ1bmN0aW9uIChvYmosIGRpbUlkeCkge1xuICAgICAgb2JqW2RpbUlkeF0gPSB0cnVlO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gICAgaWYgKGNsb25lZERpbXNNYXApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIE5vdCBjbG9uZSBpZiBkaW0gaXMgbm90IHBpY2tlZC5cbiAgICAgICAgdGFyZ2V0Ll9jaHVua3NbaV0gPSAhY2xvbmVkRGltc01hcFtpXSA/IGNodW5rc1tpXSA6IGNsb25lQ2h1bmsoY2h1bmtzW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0Ll9jaHVua3MgPSBjaHVua3M7XG4gICAgfVxuICAgIHRoaXMuX2NvcHlDb21tb25Qcm9wcyh0YXJnZXQpO1xuICAgIGlmICghaWdub3JlSW5kaWNlcykge1xuICAgICAgdGFyZ2V0Ll9pbmRpY2VzID0gdGhpcy5fY2xvbmVJbmRpY2VzKCk7XG4gICAgfVxuICAgIHRhcmdldC5fdXBkYXRlR2V0UmF3SWR4KCk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgRGF0YVN0b3JlLnByb3RvdHlwZS5fY29weUNvbW1vblByb3BzID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRhcmdldC5fY291bnQgPSB0aGlzLl9jb3VudDtcbiAgICB0YXJnZXQuX3Jhd0NvdW50ID0gdGhpcy5fcmF3Q291bnQ7XG4gICAgdGFyZ2V0Ll9wcm92aWRlciA9IHRoaXMuX3Byb3ZpZGVyO1xuICAgIHRhcmdldC5fZGltZW5zaW9ucyA9IHRoaXMuX2RpbWVuc2lvbnM7XG4gICAgdGFyZ2V0Ll9leHRlbnQgPSBjbG9uZSh0aGlzLl9leHRlbnQpO1xuICAgIHRhcmdldC5fcmF3RXh0ZW50ID0gY2xvbmUodGhpcy5fcmF3RXh0ZW50KTtcbiAgfTtcbiAgRGF0YVN0b3JlLnByb3RvdHlwZS5fY2xvbmVJbmRpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9pbmRpY2VzKSB7XG4gICAgICB2YXIgQ3RvciA9IHRoaXMuX2luZGljZXMuY29uc3RydWN0b3I7XG4gICAgICB2YXIgaW5kaWNlcyA9IHZvaWQgMDtcbiAgICAgIGlmIChDdG9yID09PSBBcnJheSkge1xuICAgICAgICB2YXIgdGhpc0NvdW50ID0gdGhpcy5faW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIGluZGljZXMgPSBuZXcgQ3Rvcih0aGlzQ291bnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgaW5kaWNlc1tpXSA9IHRoaXMuX2luZGljZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGljZXMgPSBuZXcgQ3Rvcih0aGlzLl9pbmRpY2VzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmRpY2VzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgRGF0YVN0b3JlLnByb3RvdHlwZS5fZ2V0UmF3SWR4SWRlbnRpdHkgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgcmV0dXJuIGlkeDtcbiAgfTtcbiAgRGF0YVN0b3JlLnByb3RvdHlwZS5fZ2V0UmF3SWR4ID0gZnVuY3Rpb24gKGlkeCkge1xuICAgIGlmIChpZHggPCB0aGlzLl9jb3VudCAmJiBpZHggPj0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luZGljZXNbaWR4XTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuICBEYXRhU3RvcmUucHJvdG90eXBlLl91cGRhdGVHZXRSYXdJZHggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5nZXRSYXdJbmRleCA9IHRoaXMuX2luZGljZXMgPyB0aGlzLl9nZXRSYXdJZHggOiB0aGlzLl9nZXRSYXdJZHhJZGVudGl0eTtcbiAgfTtcbiAgRGF0YVN0b3JlLmludGVybmFsRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0RGltVmFsdWVTaW1wbHkoZGF0YUl0ZW0sIHByb3BlcnR5LCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgICByZXR1cm4gcGFyc2VEYXRhVmFsdWUoZGF0YUl0ZW1bZGltSW5kZXhdLCB0aGlzLl9kaW1lbnNpb25zW2RpbUluZGV4XSk7XG4gICAgfVxuICAgIGRlZmF1bHREaW1WYWx1ZUdldHRlcnMgPSB7XG4gICAgICBhcnJheVJvd3M6IGdldERpbVZhbHVlU2ltcGx5LFxuICAgICAgb2JqZWN0Um93czogZnVuY3Rpb24gKGRhdGFJdGVtLCBwcm9wZXJ0eSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAgICAgICByZXR1cm4gcGFyc2VEYXRhVmFsdWUoZGF0YUl0ZW1bcHJvcGVydHldLCB0aGlzLl9kaW1lbnNpb25zW2RpbUluZGV4XSk7XG4gICAgICB9LFxuICAgICAga2V5ZWRDb2x1bW5zOiBnZXREaW1WYWx1ZVNpbXBseSxcbiAgICAgIG9yaWdpbmFsOiBmdW5jdGlvbiAoZGF0YUl0ZW0sIHByb3BlcnR5LCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgICAgIC8vIFBlcmZvcm1hbmNlIHNlbnNpdGl2ZSwgZG8gbm90IHVzZSBtb2RlbFV0aWwuZ2V0RGF0YUl0ZW1WYWx1ZS5cbiAgICAgICAgLy8gSWYgZGF0YUl0ZW0gaXMgYW4gcGxhaW4gb2JqZWN0IHdpdGggbm8gdmFsdWUgZmllbGQsIHRoZSBsZXQgYHZhbHVlYFxuICAgICAgICAvLyB3aWxsIGJlIGFzc2lnbmVkIHdpdGggdGhlIG9iamVjdCwgYnV0IGl0IHdpbGwgYmUgdHJlYWQgY29ycmVjdGx5XG4gICAgICAgIC8vIGluIHRoZSBgY29udmVydFZhbHVlYC5cbiAgICAgICAgdmFyIHZhbHVlID0gZGF0YUl0ZW0gJiYgKGRhdGFJdGVtLnZhbHVlID09IG51bGwgPyBkYXRhSXRlbSA6IGRhdGFJdGVtLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRGF0YVZhbHVlKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgPyB2YWx1ZVtkaW1JbmRleF1cbiAgICAgICAgLy8gSWYgdmFsdWUgaXMgYSBzaW5nbGUgbnVtYmVyIG9yIHNvbWV0aGluZyBlbHNlIG5vdCBhcnJheS5cbiAgICAgICAgOiB2YWx1ZSwgdGhpcy5fZGltZW5zaW9uc1tkaW1JbmRleF0pO1xuICAgICAgfSxcbiAgICAgIHR5cGVkQXJyYXk6IGZ1bmN0aW9uIChkYXRhSXRlbSwgcHJvcGVydHksIGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFJdGVtW2RpbUluZGV4XTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCk7XG4gIHJldHVybiBEYXRhU3RvcmU7XG59KCk7XG5leHBvcnQgZGVmYXVsdCBEYXRhU3RvcmU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///70250\n")}}]);