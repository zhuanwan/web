"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[2663],{23073:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  time: {\n    month: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],\n    monthAbbr: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],\n    dayOfWeek: ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'],\n    dayOfWeekAbbr: ['日', '一', '二', '三', '四', '五', '六']\n  },\n  legend: {\n    selector: {\n      all: '全选',\n      inverse: '反选'\n    }\n  },\n  toolbox: {\n    brush: {\n      title: {\n        rect: '矩形选择',\n        polygon: '圈选',\n        lineX: '横向选择',\n        lineY: '纵向选择',\n        keep: '保持选择',\n        clear: '清除选择'\n      }\n    },\n    dataView: {\n      title: '数据视图',\n      lang: ['数据视图', '关闭', '刷新']\n    },\n    dataZoom: {\n      title: {\n        zoom: '区域缩放',\n        back: '区域缩放还原'\n      }\n    },\n    magicType: {\n      title: {\n        line: '切换为折线图',\n        bar: '切换为柱状图',\n        stack: '切换为堆叠',\n        tiled: '切换为平铺'\n      }\n    },\n    restore: {\n      title: '还原'\n    },\n    saveAsImage: {\n      title: '保存为图片',\n      lang: ['右键另存为图片']\n    }\n  },\n  series: {\n    typeNames: {\n      pie: '饼图',\n      bar: '柱状图',\n      line: '折线图',\n      scatter: '散点图',\n      effectScatter: '涟漪散点图',\n      radar: '雷达图',\n      tree: '树图',\n      treemap: '矩形树图',\n      boxplot: '箱型图',\n      candlestick: 'K线图',\n      k: 'K线图',\n      heatmap: '热力图',\n      map: '地图',\n      parallel: '平行坐标图',\n      lines: '线图',\n      graph: '关系图',\n      sankey: '桑基图',\n      funnel: '漏斗图',\n      gauge: '仪表盘图',\n      pictorialBar: '象形柱图',\n      themeRiver: '主题河流图',\n      sunburst: '旭日图',\n      custom: '自定义图表',\n      chart: '图表'\n    }\n  },\n  aria: {\n    general: {\n      withTitle: '这是一个关于“{title}”的图表。',\n      withoutTitle: '这是一个图表，'\n    },\n    series: {\n      single: {\n        prefix: '',\n        withName: '图表类型是{seriesType}，表示{seriesName}。',\n        withoutName: '图表类型是{seriesType}。'\n      },\n      multiple: {\n        prefix: '它由{seriesCount}个图表系列组成。',\n        withName: '第{seriesId}个系列是一个表示{seriesName}的{seriesType}，',\n        withoutName: '第{seriesId}个系列是一个{seriesType}，',\n        separator: {\n          middle: '；',\n          end: '。'\n        }\n      }\n    },\n    data: {\n      allData: '其数据是——',\n      partialData: '其中，前{displayCnt}项是——',\n      withName: '{name}的数据是{value}',\n      withoutName: '{value}',\n      separator: {\n        middle: '，',\n        end: ''\n      }\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMwNzMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvaTE4bi9sYW5nWkguanM/NGM2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB0aW1lOiB7XG4gICAgbW9udGg6IFsn5LiA5pyIJywgJ+S6jOaciCcsICfkuInmnIgnLCAn5Zub5pyIJywgJ+S6lOaciCcsICflha3mnIgnLCAn5LiD5pyIJywgJ+WFq+aciCcsICfkuZ3mnIgnLCAn5Y2B5pyIJywgJ+WNgeS4gOaciCcsICfljYHkuozmnIgnXSxcbiAgICBtb250aEFiYnI6IFsnMeaciCcsICcy5pyIJywgJzPmnIgnLCAnNOaciCcsICc15pyIJywgJzbmnIgnLCAnN+aciCcsICc45pyIJywgJznmnIgnLCAnMTDmnIgnLCAnMTHmnIgnLCAnMTLmnIgnXSxcbiAgICBkYXlPZldlZWs6IFsn5pif5pyf5pelJywgJ+aYn+acn+S4gCcsICfmmJ/mnJ/kuownLCAn5pif5pyf5LiJJywgJ+aYn+acn+WbmycsICfmmJ/mnJ/kupQnLCAn5pif5pyf5YWtJ10sXG4gICAgZGF5T2ZXZWVrQWJicjogWyfml6UnLCAn5LiAJywgJ+S6jCcsICfkuIknLCAn5ZubJywgJ+S6lCcsICflha0nXVxuICB9LFxuICBsZWdlbmQ6IHtcbiAgICBzZWxlY3Rvcjoge1xuICAgICAgYWxsOiAn5YWo6YCJJyxcbiAgICAgIGludmVyc2U6ICflj43pgIknXG4gICAgfVxuICB9LFxuICB0b29sYm94OiB7XG4gICAgYnJ1c2g6IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIHJlY3Q6ICfnn6nlvaLpgInmi6knLFxuICAgICAgICBwb2x5Z29uOiAn5ZyI6YCJJyxcbiAgICAgICAgbGluZVg6ICfmqKrlkJHpgInmi6knLFxuICAgICAgICBsaW5lWTogJ+e6teWQkemAieaLqScsXG4gICAgICAgIGtlZXA6ICfkv53mjIHpgInmi6knLFxuICAgICAgICBjbGVhcjogJ+a4hemZpOmAieaLqSdcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGFWaWV3OiB7XG4gICAgICB0aXRsZTogJ+aVsOaNruinhuWbvicsXG4gICAgICBsYW5nOiBbJ+aVsOaNruinhuWbvicsICflhbPpl60nLCAn5Yi35pawJ11cbiAgICB9LFxuICAgIGRhdGFab29tOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICB6b29tOiAn5Yy65Z+f57yp5pS+JyxcbiAgICAgICAgYmFjazogJ+WMuuWfn+e8qeaUvui/mOWOnydcbiAgICAgIH1cbiAgICB9LFxuICAgIG1hZ2ljVHlwZToge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgbGluZTogJ+WIh+aNouS4uuaKmOe6v+WbvicsXG4gICAgICAgIGJhcjogJ+WIh+aNouS4uuafseeKtuWbvicsXG4gICAgICAgIHN0YWNrOiAn5YiH5o2i5Li65aCG5Y+gJyxcbiAgICAgICAgdGlsZWQ6ICfliIfmjaLkuLrlubPpk7onXG4gICAgICB9XG4gICAgfSxcbiAgICByZXN0b3JlOiB7XG4gICAgICB0aXRsZTogJ+i/mOWOnydcbiAgICB9LFxuICAgIHNhdmVBc0ltYWdlOiB7XG4gICAgICB0aXRsZTogJ+S/neWtmOS4uuWbvueJhycsXG4gICAgICBsYW5nOiBbJ+WPs+mUruWPpuWtmOS4uuWbvueJhyddXG4gICAgfVxuICB9LFxuICBzZXJpZXM6IHtcbiAgICB0eXBlTmFtZXM6IHtcbiAgICAgIHBpZTogJ+mlvOWbvicsXG4gICAgICBiYXI6ICfmn7Hnirblm74nLFxuICAgICAgbGluZTogJ+aKmOe6v+WbvicsXG4gICAgICBzY2F0dGVyOiAn5pWj54K55Zu+JyxcbiAgICAgIGVmZmVjdFNjYXR0ZXI6ICfmtp/mvKrmlaPngrnlm74nLFxuICAgICAgcmFkYXI6ICfpm7fovr7lm74nLFxuICAgICAgdHJlZTogJ+agkeWbvicsXG4gICAgICB0cmVlbWFwOiAn55+p5b2i5qCR5Zu+JyxcbiAgICAgIGJveHBsb3Q6ICfnrrHlnovlm74nLFxuICAgICAgY2FuZGxlc3RpY2s6ICdL57q/5Zu+JyxcbiAgICAgIGs6ICdL57q/5Zu+JyxcbiAgICAgIGhlYXRtYXA6ICfng63lipvlm74nLFxuICAgICAgbWFwOiAn5Zyw5Zu+JyxcbiAgICAgIHBhcmFsbGVsOiAn5bmz6KGM5Z2Q5qCH5Zu+JyxcbiAgICAgIGxpbmVzOiAn57q/5Zu+JyxcbiAgICAgIGdyYXBoOiAn5YWz57O75Zu+JyxcbiAgICAgIHNhbmtleTogJ+ahkeWfuuWbvicsXG4gICAgICBmdW5uZWw6ICfmvI/mlpflm74nLFxuICAgICAgZ2F1Z2U6ICfku6rooajnm5jlm74nLFxuICAgICAgcGljdG9yaWFsQmFyOiAn6LGh5b2i5p+x5Zu+JyxcbiAgICAgIHRoZW1lUml2ZXI6ICfkuLvpopjmsrPmtYHlm74nLFxuICAgICAgc3VuYnVyc3Q6ICfml63ml6Xlm74nLFxuICAgICAgY3VzdG9tOiAn6Ieq5a6a5LmJ5Zu+6KGoJyxcbiAgICAgIGNoYXJ0OiAn5Zu+6KGoJ1xuICAgIH1cbiAgfSxcbiAgYXJpYToge1xuICAgIGdlbmVyYWw6IHtcbiAgICAgIHdpdGhUaXRsZTogJ+i/meaYr+S4gOS4quWFs+S6juKAnHt0aXRsZX3igJ3nmoTlm77ooajjgIInLFxuICAgICAgd2l0aG91dFRpdGxlOiAn6L+Z5piv5LiA5Liq5Zu+6KGo77yMJ1xuICAgIH0sXG4gICAgc2VyaWVzOiB7XG4gICAgICBzaW5nbGU6IHtcbiAgICAgICAgcHJlZml4OiAnJyxcbiAgICAgICAgd2l0aE5hbWU6ICflm77ooajnsbvlnovmmK97c2VyaWVzVHlwZX3vvIzooajnpLp7c2VyaWVzTmFtZX3jgIInLFxuICAgICAgICB3aXRob3V0TmFtZTogJ+WbvuihqOexu+Wei+aYr3tzZXJpZXNUeXBlfeOAgidcbiAgICAgIH0sXG4gICAgICBtdWx0aXBsZToge1xuICAgICAgICBwcmVmaXg6ICflroPnlLF7c2VyaWVzQ291bnR95Liq5Zu+6KGo57O75YiX57uE5oiQ44CCJyxcbiAgICAgICAgd2l0aE5hbWU6ICfnrKx7c2VyaWVzSWR95Liq57O75YiX5piv5LiA5Liq6KGo56S6e3Nlcmllc05hbWV955qEe3Nlcmllc1R5cGV977yMJyxcbiAgICAgICAgd2l0aG91dE5hbWU6ICfnrKx7c2VyaWVzSWR95Liq57O75YiX5piv5LiA5Liqe3Nlcmllc1R5cGV977yMJyxcbiAgICAgICAgc2VwYXJhdG9yOiB7XG4gICAgICAgICAgbWlkZGxlOiAn77ybJyxcbiAgICAgICAgICBlbmQ6ICfjgIInXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IHtcbiAgICAgIGFsbERhdGE6ICflhbbmlbDmja7mmK/igJTigJQnLFxuICAgICAgcGFydGlhbERhdGE6ICflhbbkuK3vvIzliY17ZGlzcGxheUNudH3pobnmmK/igJTigJQnLFxuICAgICAgd2l0aE5hbWU6ICd7bmFtZX3nmoTmlbDmja7mmK97dmFsdWV9JyxcbiAgICAgIHdpdGhvdXROYW1lOiAne3ZhbHVlfScsXG4gICAgICBzZXBhcmF0b3I6IHtcbiAgICAgICAgbWlkZGxlOiAn77yMJyxcbiAgICAgICAgZW5kOiAnJ1xuICAgICAgfVxuICAgIH1cbiAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23073\n")},30682:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ pointsLayout)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _chart_helper_createRenderPlanner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87582);\n/* harmony import */ var _data_helper_dataStackHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(65008);\n/* harmony import */ var _util_vendor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8957);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nfunction pointsLayout(seriesType, forceStoreInTypedArray) {\n  return {\n    seriesType: seriesType,\n    plan: (0,_chart_helper_createRenderPlanner_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var useTypedArray = forceStoreInTypedArray || pipelineContext.large;\n      if (!coordSys) {\n        return;\n      }\n      var dims = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map)(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n      var stackResultDim = data.getCalculationInfo(\'stackResultDimension\');\n      if ((0,_data_helper_dataStackHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .isDimensionStacked */ .sJ)(data, dims[0])) {\n        dims[0] = stackResultDim;\n      }\n      if ((0,_data_helper_dataStackHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .isDimensionStacked */ .sJ)(data, dims[1])) {\n        dims[1] = stackResultDim;\n      }\n      var store = data.getStore();\n      var dimIdx0 = data.getDimensionIndex(dims[0]);\n      var dimIdx1 = data.getDimensionIndex(dims[1]);\n      return dimLen && {\n        progress: function (params, data) {\n          var segCount = params.end - params.start;\n          var points = useTypedArray && (0,_util_vendor_js__WEBPACK_IMPORTED_MODULE_3__/* .createFloat32Array */ .J)(segCount * dimLen);\n          var tmpIn = [];\n          var tmpOut = [];\n          for (var i = params.start, offset = 0; i < params.end; i++) {\n            var point = void 0;\n            if (dimLen === 1) {\n              var x = store.get(dimIdx0, i);\n              // NOTE: Make sure the second parameter is null to use default strategy.\n              point = coordSys.dataToPoint(x, null, tmpOut);\n            } else {\n              tmpIn[0] = store.get(dimIdx0, i);\n              tmpIn[1] = store.get(dimIdx1, i);\n              // Let coordinate system to handle the NaN data.\n              point = coordSys.dataToPoint(tmpIn, null, tmpOut);\n            }\n            if (useTypedArray) {\n              points[offset++] = point[0];\n              points[offset++] = point[1];\n            } else {\n              data.setItemLayout(i, point.slice());\n            }\n          }\n          useTypedArray && data.setLayout(\'points\', points);\n        }\n      };\n    }\n  };\n}\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA2ODIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYXlvdXQvcG9pbnRzLmpzPzQzZTkiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBtYXAgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IGNyZWF0ZVJlbmRlclBsYW5uZXIgZnJvbSAnLi4vY2hhcnQvaGVscGVyL2NyZWF0ZVJlbmRlclBsYW5uZXIuanMnO1xuaW1wb3J0IHsgaXNEaW1lbnNpb25TdGFja2VkIH0gZnJvbSAnLi4vZGF0YS9oZWxwZXIvZGF0YVN0YWNrSGVscGVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZUZsb2F0MzJBcnJheSB9IGZyb20gJy4uL3V0aWwvdmVuZG9yLmpzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBvaW50c0xheW91dChzZXJpZXNUeXBlLCBmb3JjZVN0b3JlSW5UeXBlZEFycmF5KSB7XG4gIHJldHVybiB7XG4gICAgc2VyaWVzVHlwZTogc2VyaWVzVHlwZSxcbiAgICBwbGFuOiBjcmVhdGVSZW5kZXJQbGFubmVyKCksXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgdmFyIHBpcGVsaW5lQ29udGV4dCA9IHNlcmllc01vZGVsLnBpcGVsaW5lQ29udGV4dDtcbiAgICAgIHZhciB1c2VUeXBlZEFycmF5ID0gZm9yY2VTdG9yZUluVHlwZWRBcnJheSB8fCBwaXBlbGluZUNvbnRleHQubGFyZ2U7XG4gICAgICBpZiAoIWNvb3JkU3lzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBkaW1zID0gbWFwKGNvb3JkU3lzLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgcmV0dXJuIGRhdGEubWFwRGltZW5zaW9uKGRpbSk7XG4gICAgICB9KS5zbGljZSgwLCAyKTtcbiAgICAgIHZhciBkaW1MZW4gPSBkaW1zLmxlbmd0aDtcbiAgICAgIHZhciBzdGFja1Jlc3VsdERpbSA9IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja1Jlc3VsdERpbWVuc2lvbicpO1xuICAgICAgaWYgKGlzRGltZW5zaW9uU3RhY2tlZChkYXRhLCBkaW1zWzBdKSkge1xuICAgICAgICBkaW1zWzBdID0gc3RhY2tSZXN1bHREaW07XG4gICAgICB9XG4gICAgICBpZiAoaXNEaW1lbnNpb25TdGFja2VkKGRhdGEsIGRpbXNbMV0pKSB7XG4gICAgICAgIGRpbXNbMV0gPSBzdGFja1Jlc3VsdERpbTtcbiAgICAgIH1cbiAgICAgIHZhciBzdG9yZSA9IGRhdGEuZ2V0U3RvcmUoKTtcbiAgICAgIHZhciBkaW1JZHgwID0gZGF0YS5nZXREaW1lbnNpb25JbmRleChkaW1zWzBdKTtcbiAgICAgIHZhciBkaW1JZHgxID0gZGF0YS5nZXREaW1lbnNpb25JbmRleChkaW1zWzFdKTtcbiAgICAgIHJldHVybiBkaW1MZW4gJiYge1xuICAgICAgICBwcm9ncmVzczogZnVuY3Rpb24gKHBhcmFtcywgZGF0YSkge1xuICAgICAgICAgIHZhciBzZWdDb3VudCA9IHBhcmFtcy5lbmQgLSBwYXJhbXMuc3RhcnQ7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IHVzZVR5cGVkQXJyYXkgJiYgY3JlYXRlRmxvYXQzMkFycmF5KHNlZ0NvdW50ICogZGltTGVuKTtcbiAgICAgICAgICB2YXIgdG1wSW4gPSBbXTtcbiAgICAgICAgICB2YXIgdG1wT3V0ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHBhcmFtcy5zdGFydCwgb2Zmc2V0ID0gMDsgaSA8IHBhcmFtcy5lbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGRpbUxlbiA9PT0gMSkge1xuICAgICAgICAgICAgICB2YXIgeCA9IHN0b3JlLmdldChkaW1JZHgwLCBpKTtcbiAgICAgICAgICAgICAgLy8gTk9URTogTWFrZSBzdXJlIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIG51bGwgdG8gdXNlIGRlZmF1bHQgc3RyYXRlZ3kuXG4gICAgICAgICAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoeCwgbnVsbCwgdG1wT3V0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRtcEluWzBdID0gc3RvcmUuZ2V0KGRpbUlkeDAsIGkpO1xuICAgICAgICAgICAgICB0bXBJblsxXSA9IHN0b3JlLmdldChkaW1JZHgxLCBpKTtcbiAgICAgICAgICAgICAgLy8gTGV0IGNvb3JkaW5hdGUgc3lzdGVtIHRvIGhhbmRsZSB0aGUgTmFOIGRhdGEuXG4gICAgICAgICAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQodG1wSW4sIG51bGwsIHRtcE91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlVHlwZWRBcnJheSkge1xuICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0KytdID0gcG9pbnRbMF07XG4gICAgICAgICAgICAgIHBvaW50c1tvZmZzZXQrK10gPSBwb2ludFsxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpLCBwb2ludC5zbGljZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdXNlVHlwZWRBcnJheSAmJiBkYXRhLnNldExheW91dCgncG9pbnRzJywgcG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG47Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30682\n')},35278:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  _: () => (/* binding */ installLabelLayout)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/BoundingRect.js\nvar BoundingRect = __webpack_require__(29308);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/Transformable.js\nvar Transformable = __webpack_require__(92836);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelGuideHelper.js\nvar labelGuideHelper = __webpack_require__(92621);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelLayoutHelper.js\nvar labelLayoutHelper = __webpack_require__(77175);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/contain/util.js\nvar contain_util = __webpack_require__(41589);\n;// ./node_modules/echarts/lib/label/LabelManager.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// TODO: move labels out of viewport.\n\n\n\n\n\n\n\n\n\n\nfunction cloneArr(points) {\n  if (points) {\n    var newPoints = [];\n    for (var i = 0; i < points.length; i++) {\n      newPoints.push(points[i].slice());\n    }\n    return newPoints;\n  }\n}\nfunction prepareLayoutCallbackParams(labelItem, hostEl) {\n  var label = labelItem.label;\n  var labelLine = hostEl && hostEl.getTextGuideLine();\n  return {\n    dataIndex: labelItem.dataIndex,\n    dataType: labelItem.dataType,\n    seriesIndex: labelItem.seriesModel.seriesIndex,\n    text: labelItem.label.style.text,\n    rect: labelItem.hostRect,\n    labelRect: labelItem.rect,\n    // x: labelAttr.x,\n    // y: labelAttr.y,\n    align: label.style.align,\n    verticalAlign: label.style.verticalAlign,\n    labelLinePoints: cloneArr(labelLine && labelLine.shape.points)\n  };\n}\nvar LABEL_OPTION_TO_STYLE_KEYS = ['align', 'verticalAlign', 'width', 'height', 'fontSize'];\nvar dummyTransformable = new Transformable/* default */.Ay();\nvar labelLayoutInnerStore = (0,model/* makeInner */.$r)();\nvar labelLineAnimationStore = (0,model/* makeInner */.$r)();\nfunction extendWithKeys(target, source, keys) {\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (source[key] != null) {\n      target[key] = source[key];\n    }\n  }\n}\nvar LABEL_LAYOUT_PROPS = ['x', 'y', 'rotation'];\nvar LabelManager = /** @class */function () {\n  function LabelManager() {\n    this._labelList = [];\n    this._chartViewList = [];\n  }\n  LabelManager.prototype.clearLabels = function () {\n    this._labelList = [];\n    this._chartViewList = [];\n  };\n  /**\r\n   * Add label to manager\r\n   */\n  LabelManager.prototype._addLabel = function (dataIndex, dataType, seriesModel, label, layoutOption) {\n    var labelStyle = label.style;\n    var hostEl = label.__hostTarget;\n    var textConfig = hostEl.textConfig || {};\n    // TODO: If label is in other state.\n    var labelTransform = label.getComputedTransform();\n    var labelRect = label.getBoundingRect().plain();\n    BoundingRect/* default */.A.applyTransform(labelRect, labelRect, labelTransform);\n    if (labelTransform) {\n      dummyTransformable.setLocalTransform(labelTransform);\n    } else {\n      // Identity transform.\n      dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0;\n      dummyTransformable.scaleX = dummyTransformable.scaleY = 1;\n    }\n    dummyTransformable.rotation = (0,contain_util/* normalizeRadian */.n)(dummyTransformable.rotation);\n    var host = label.__hostTarget;\n    var hostRect;\n    if (host) {\n      hostRect = host.getBoundingRect().plain();\n      var transform = host.getComputedTransform();\n      BoundingRect/* default */.A.applyTransform(hostRect, hostRect, transform);\n    }\n    var labelGuide = hostRect && host.getTextGuideLine();\n    this._labelList.push({\n      label: label,\n      labelLine: labelGuide,\n      seriesModel: seriesModel,\n      dataIndex: dataIndex,\n      dataType: dataType,\n      layoutOption: layoutOption,\n      computedLayoutOption: null,\n      rect: labelRect,\n      hostRect: hostRect,\n      // Label with lower priority will be hidden when overlapped\n      // Use rect size as default priority\n      priority: hostRect ? hostRect.width * hostRect.height : 0,\n      // Save default label attributes.\n      // For restore if developers want get back to default value in callback.\n      defaultAttr: {\n        ignore: label.ignore,\n        labelGuideIgnore: labelGuide && labelGuide.ignore,\n        x: dummyTransformable.x,\n        y: dummyTransformable.y,\n        scaleX: dummyTransformable.scaleX,\n        scaleY: dummyTransformable.scaleY,\n        rotation: dummyTransformable.rotation,\n        style: {\n          x: labelStyle.x,\n          y: labelStyle.y,\n          align: labelStyle.align,\n          verticalAlign: labelStyle.verticalAlign,\n          width: labelStyle.width,\n          height: labelStyle.height,\n          fontSize: labelStyle.fontSize\n        },\n        cursor: label.cursor,\n        attachedPos: textConfig.position,\n        attachedRot: textConfig.rotation\n      }\n    });\n  };\n  LabelManager.prototype.addLabelsOfSeries = function (chartView) {\n    var _this = this;\n    this._chartViewList.push(chartView);\n    var seriesModel = chartView.__model;\n    var layoutOption = seriesModel.get('labelLayout');\n    /**\r\n     * Ignore layouting if it's not specified anything.\r\n     */\n    if (!((0,util.isFunction)(layoutOption) || (0,util.keys)(layoutOption).length)) {\n      return;\n    }\n    chartView.group.traverse(function (child) {\n      if (child.ignore) {\n        return true; // Stop traverse descendants.\n      }\n      // Only support label being hosted on graphic elements.\n      var textEl = child.getTextContent();\n      var ecData = (0,innerStore/* getECData */.z)(child);\n      // Can only attach the text on the element with dataIndex\n      if (textEl && !textEl.disableLabelLayout) {\n        _this._addLabel(ecData.dataIndex, ecData.dataType, seriesModel, textEl, layoutOption);\n      }\n    });\n  };\n  LabelManager.prototype.updateLayoutConfig = function (api) {\n    var width = api.getWidth();\n    var height = api.getHeight();\n    function createDragHandler(el, labelLineModel) {\n      return function () {\n        (0,labelGuideHelper/* updateLabelLinePoints */.lB)(el, labelLineModel);\n      };\n    }\n    for (var i = 0; i < this._labelList.length; i++) {\n      var labelItem = this._labelList[i];\n      var label = labelItem.label;\n      var hostEl = label.__hostTarget;\n      var defaultLabelAttr = labelItem.defaultAttr;\n      var layoutOption = void 0;\n      // TODO A global layout option?\n      if ((0,util.isFunction)(labelItem.layoutOption)) {\n        layoutOption = labelItem.layoutOption(prepareLayoutCallbackParams(labelItem, hostEl));\n      } else {\n        layoutOption = labelItem.layoutOption;\n      }\n      layoutOption = layoutOption || {};\n      labelItem.computedLayoutOption = layoutOption;\n      var degreeToRadian = Math.PI / 180;\n      // TODO hostEl should always exists.\n      // Or label should not have parent because the x, y is all in global space.\n      if (hostEl) {\n        hostEl.setTextConfig({\n          // Force to set local false.\n          local: false,\n          // Ignore position and rotation config on the host el if x or y is changed.\n          position: layoutOption.x != null || layoutOption.y != null ? null : defaultLabelAttr.attachedPos,\n          // Ignore rotation config on the host el if rotation is changed.\n          rotation: layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.attachedRot,\n          offset: [layoutOption.dx || 0, layoutOption.dy || 0]\n        });\n      }\n      var needsUpdateLabelLine = false;\n      if (layoutOption.x != null) {\n        // TODO width of chart view.\n        label.x = (0,number/* parsePercent */.lo)(layoutOption.x, width);\n        label.setStyle('x', 0); // Ignore movement in style. TODO: origin.\n        needsUpdateLabelLine = true;\n      } else {\n        label.x = defaultLabelAttr.x;\n        label.setStyle('x', defaultLabelAttr.style.x);\n      }\n      if (layoutOption.y != null) {\n        // TODO height of chart view.\n        label.y = (0,number/* parsePercent */.lo)(layoutOption.y, height);\n        label.setStyle('y', 0); // Ignore movement in style.\n        needsUpdateLabelLine = true;\n      } else {\n        label.y = defaultLabelAttr.y;\n        label.setStyle('y', defaultLabelAttr.style.y);\n      }\n      if (layoutOption.labelLinePoints) {\n        var guideLine = hostEl.getTextGuideLine();\n        if (guideLine) {\n          guideLine.setShape({\n            points: layoutOption.labelLinePoints\n          });\n          // Not update\n          needsUpdateLabelLine = false;\n        }\n      }\n      var labelLayoutStore = labelLayoutInnerStore(label);\n      labelLayoutStore.needsUpdateLabelLine = needsUpdateLabelLine;\n      label.rotation = layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.rotation;\n      label.scaleX = defaultLabelAttr.scaleX;\n      label.scaleY = defaultLabelAttr.scaleY;\n      for (var k = 0; k < LABEL_OPTION_TO_STYLE_KEYS.length; k++) {\n        var key = LABEL_OPTION_TO_STYLE_KEYS[k];\n        label.setStyle(key, layoutOption[key] != null ? layoutOption[key] : defaultLabelAttr.style[key]);\n      }\n      if (layoutOption.draggable) {\n        label.draggable = true;\n        label.cursor = 'move';\n        if (hostEl) {\n          var hostModel = labelItem.seriesModel;\n          if (labelItem.dataIndex != null) {\n            var data = labelItem.seriesModel.getData(labelItem.dataType);\n            hostModel = data.getItemModel(labelItem.dataIndex);\n          }\n          label.on('drag', createDragHandler(hostEl, hostModel.getModel('labelLine')));\n        }\n      } else {\n        // TODO Other drag functions?\n        label.off('drag');\n        label.cursor = defaultLabelAttr.cursor;\n      }\n    }\n  };\n  LabelManager.prototype.layout = function (api) {\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var labelList = (0,labelLayoutHelper/* prepareLayoutList */.os)(this._labelList);\n    var labelsNeedsAdjustOnX = (0,util.filter)(labelList, function (item) {\n      return item.layoutOption.moveOverlap === 'shiftX';\n    });\n    var labelsNeedsAdjustOnY = (0,util.filter)(labelList, function (item) {\n      return item.layoutOption.moveOverlap === 'shiftY';\n    });\n    (0,labelLayoutHelper/* shiftLayoutOnX */.QX)(labelsNeedsAdjustOnX, 0, width);\n    (0,labelLayoutHelper/* shiftLayoutOnY */.Xe)(labelsNeedsAdjustOnY, 0, height);\n    var labelsNeedsHideOverlap = (0,util.filter)(labelList, function (item) {\n      return item.layoutOption.hideOverlap;\n    });\n    (0,labelLayoutHelper/* hideOverlap */.If)(labelsNeedsHideOverlap);\n  };\n  /**\r\n   * Process all labels. Not only labels with layoutOption.\r\n   */\n  LabelManager.prototype.processLabelsOverall = function () {\n    var _this = this;\n    (0,util.each)(this._chartViewList, function (chartView) {\n      var seriesModel = chartView.__model;\n      var ignoreLabelLineUpdate = chartView.ignoreLabelLineUpdate;\n      var animationEnabled = seriesModel.isAnimationEnabled();\n      chartView.group.traverse(function (child) {\n        if (child.ignore && !child.forceLabelAnimation) {\n          return true; // Stop traverse descendants.\n        }\n        var needsUpdateLabelLine = !ignoreLabelLineUpdate;\n        var label = child.getTextContent();\n        if (!needsUpdateLabelLine && label) {\n          needsUpdateLabelLine = labelLayoutInnerStore(label).needsUpdateLabelLine;\n        }\n        if (needsUpdateLabelLine) {\n          _this._updateLabelLine(child, seriesModel);\n        }\n        if (animationEnabled) {\n          _this._animateLabels(child, seriesModel);\n        }\n      });\n    });\n  };\n  LabelManager.prototype._updateLabelLine = function (el, seriesModel) {\n    // Only support label being hosted on graphic elements.\n    var textEl = el.getTextContent();\n    // Update label line style.\n    var ecData = (0,innerStore/* getECData */.z)(el);\n    var dataIndex = ecData.dataIndex;\n    // Only support labelLine on the labels represent data.\n    if (textEl && dataIndex != null) {\n      var data = seriesModel.getData(ecData.dataType);\n      var itemModel = data.getItemModel(dataIndex);\n      var defaultStyle = {};\n      var visualStyle = data.getItemVisual(dataIndex, 'style');\n      if (visualStyle) {\n        var visualType = data.getVisual('drawType');\n        // Default to be same with main color\n        defaultStyle.stroke = visualStyle[visualType];\n      }\n      var labelLineModel = itemModel.getModel('labelLine');\n      (0,labelGuideHelper/* setLabelLineStyle */.eR)(el, (0,labelGuideHelper/* getLabelLineStatesModels */.rv)(itemModel), defaultStyle);\n      (0,labelGuideHelper/* updateLabelLinePoints */.lB)(el, labelLineModel);\n    }\n  };\n  LabelManager.prototype._animateLabels = function (el, seriesModel) {\n    var textEl = el.getTextContent();\n    var guideLine = el.getTextGuideLine();\n    // Animate\n    if (textEl\n    // `forceLabelAnimation` has the highest priority\n    && (el.forceLabelAnimation || !textEl.ignore && !textEl.invisible && !el.disableLabelAnimation && !(0,basicTransition/* isElementRemoved */.LR)(el))) {\n      var layoutStore = labelLayoutInnerStore(textEl);\n      var oldLayout = layoutStore.oldLayout;\n      var ecData = (0,innerStore/* getECData */.z)(el);\n      var dataIndex = ecData.dataIndex;\n      var newProps = {\n        x: textEl.x,\n        y: textEl.y,\n        rotation: textEl.rotation\n      };\n      var data = seriesModel.getData(ecData.dataType);\n      if (!oldLayout) {\n        textEl.attr(newProps);\n        // Disable fade in animation if value animation is enabled.\n        if (!(0,labelStyle/* labelInner */.Lu)(textEl).valueAnimation) {\n          var oldOpacity = (0,util.retrieve2)(textEl.style.opacity, 1);\n          // Fade in animation\n          textEl.style.opacity = 0;\n          (0,basicTransition/* initProps */.LW)(textEl, {\n            style: {\n              opacity: oldOpacity\n            }\n          }, seriesModel, dataIndex);\n        }\n      } else {\n        textEl.attr(oldLayout);\n        // Make sure the animation from is in the right status.\n        var prevStates = el.prevStates;\n        if (prevStates) {\n          if ((0,util.indexOf)(prevStates, 'select') >= 0) {\n            textEl.attr(layoutStore.oldLayoutSelect);\n          }\n          if ((0,util.indexOf)(prevStates, 'emphasis') >= 0) {\n            textEl.attr(layoutStore.oldLayoutEmphasis);\n          }\n        }\n        (0,basicTransition/* updateProps */.oi)(textEl, newProps, seriesModel, dataIndex);\n      }\n      layoutStore.oldLayout = newProps;\n      if (textEl.states.select) {\n        var layoutSelect = layoutStore.oldLayoutSelect = {};\n        extendWithKeys(layoutSelect, newProps, LABEL_LAYOUT_PROPS);\n        extendWithKeys(layoutSelect, textEl.states.select, LABEL_LAYOUT_PROPS);\n      }\n      if (textEl.states.emphasis) {\n        var layoutEmphasis = layoutStore.oldLayoutEmphasis = {};\n        extendWithKeys(layoutEmphasis, newProps, LABEL_LAYOUT_PROPS);\n        extendWithKeys(layoutEmphasis, textEl.states.emphasis, LABEL_LAYOUT_PROPS);\n      }\n      (0,labelStyle/* animateLabelValue */.xb)(textEl, dataIndex, data, seriesModel, seriesModel);\n    }\n    if (guideLine && !guideLine.ignore && !guideLine.invisible) {\n      var layoutStore = labelLineAnimationStore(guideLine);\n      var oldLayout = layoutStore.oldLayout;\n      var newLayout = {\n        points: guideLine.shape.points\n      };\n      if (!oldLayout) {\n        guideLine.setShape(newLayout);\n        guideLine.style.strokePercent = 0;\n        (0,basicTransition/* initProps */.LW)(guideLine, {\n          style: {\n            strokePercent: 1\n          }\n        }, seriesModel);\n      } else {\n        guideLine.attr({\n          shape: oldLayout\n        });\n        (0,basicTransition/* updateProps */.oi)(guideLine, {\n          shape: newLayout\n        }, seriesModel);\n      }\n      layoutStore.oldLayout = newLayout;\n    }\n  };\n  return LabelManager;\n}();\n/* harmony default export */ const label_LabelManager = (LabelManager);\n;// ./node_modules/echarts/lib/label/installLabelLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar getLabelManager = (0,model/* makeInner */.$r)();\nfunction installLabelLayout(registers) {\n  registers.registerUpdateLifecycle('series:beforeupdate', function (ecModel, api, params) {\n    // TODO api provide an namespace that can save stuff per instance\n    var labelManager = getLabelManager(api).labelManager;\n    if (!labelManager) {\n      labelManager = getLabelManager(api).labelManager = new label_LabelManager();\n    }\n    labelManager.clearLabels();\n  });\n  registers.registerUpdateLifecycle('series:layoutlabels', function (ecModel, api, params) {\n    var labelManager = getLabelManager(api).labelManager;\n    params.updatedSeries.forEach(function (series) {\n      labelManager.addLabelsOfSeries(api.getViewOfSeriesModel(series));\n    });\n    labelManager.updateLayoutConfig(api);\n    labelManager.layout(api);\n    labelManager.processLabelsOverall();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUyNzguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2xhYmVsL0xhYmVsTWFuYWdlci5qcz9iNjM0Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYWJlbC9pbnN0YWxsTGFiZWxMYXlvdXQuanM/ZDdmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbi8vIFRPRE86IG1vdmUgbGFiZWxzIG91dCBvZiB2aWV3cG9ydC5cbmltcG9ydCB7IEJvdW5kaW5nUmVjdCwgdXBkYXRlUHJvcHMsIGluaXRQcm9wcywgaXNFbGVtZW50UmVtb3ZlZCB9IGZyb20gJy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgeyBnZXRFQ0RhdGEgfSBmcm9tICcuLi91dGlsL2lubmVyU3RvcmUuanMnO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50IH0gZnJvbSAnLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IFRyYW5zZm9ybWFibGUgZnJvbSAnenJlbmRlci9saWIvY29yZS9UcmFuc2Zvcm1hYmxlLmpzJztcbmltcG9ydCB7IHVwZGF0ZUxhYmVsTGluZVBvaW50cywgc2V0TGFiZWxMaW5lU3R5bGUsIGdldExhYmVsTGluZVN0YXRlc01vZGVscyB9IGZyb20gJy4vbGFiZWxHdWlkZUhlbHBlci5qcyc7XG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCB7IHJldHJpZXZlMiwgZWFjaCwga2V5cywgaXNGdW5jdGlvbiwgZmlsdGVyLCBpbmRleE9mIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IHByZXBhcmVMYXlvdXRMaXN0LCBoaWRlT3ZlcmxhcCwgc2hpZnRMYXlvdXRPblgsIHNoaWZ0TGF5b3V0T25ZIH0gZnJvbSAnLi9sYWJlbExheW91dEhlbHBlci5qcyc7XG5pbXBvcnQgeyBsYWJlbElubmVyLCBhbmltYXRlTGFiZWxWYWx1ZSB9IGZyb20gJy4vbGFiZWxTdHlsZS5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVSYWRpYW4gfSBmcm9tICd6cmVuZGVyL2xpYi9jb250YWluL3V0aWwuanMnO1xuZnVuY3Rpb24gY2xvbmVBcnIocG9pbnRzKSB7XG4gIGlmIChwb2ludHMpIHtcbiAgICB2YXIgbmV3UG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXS5zbGljZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1BvaW50cztcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZUxheW91dENhbGxiYWNrUGFyYW1zKGxhYmVsSXRlbSwgaG9zdEVsKSB7XG4gIHZhciBsYWJlbCA9IGxhYmVsSXRlbS5sYWJlbDtcbiAgdmFyIGxhYmVsTGluZSA9IGhvc3RFbCAmJiBob3N0RWwuZ2V0VGV4dEd1aWRlTGluZSgpO1xuICByZXR1cm4ge1xuICAgIGRhdGFJbmRleDogbGFiZWxJdGVtLmRhdGFJbmRleCxcbiAgICBkYXRhVHlwZTogbGFiZWxJdGVtLmRhdGFUeXBlLFxuICAgIHNlcmllc0luZGV4OiBsYWJlbEl0ZW0uc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXgsXG4gICAgdGV4dDogbGFiZWxJdGVtLmxhYmVsLnN0eWxlLnRleHQsXG4gICAgcmVjdDogbGFiZWxJdGVtLmhvc3RSZWN0LFxuICAgIGxhYmVsUmVjdDogbGFiZWxJdGVtLnJlY3QsXG4gICAgLy8geDogbGFiZWxBdHRyLngsXG4gICAgLy8geTogbGFiZWxBdHRyLnksXG4gICAgYWxpZ246IGxhYmVsLnN0eWxlLmFsaWduLFxuICAgIHZlcnRpY2FsQWxpZ246IGxhYmVsLnN0eWxlLnZlcnRpY2FsQWxpZ24sXG4gICAgbGFiZWxMaW5lUG9pbnRzOiBjbG9uZUFycihsYWJlbExpbmUgJiYgbGFiZWxMaW5lLnNoYXBlLnBvaW50cylcbiAgfTtcbn1cbnZhciBMQUJFTF9PUFRJT05fVE9fU1RZTEVfS0VZUyA9IFsnYWxpZ24nLCAndmVydGljYWxBbGlnbicsICd3aWR0aCcsICdoZWlnaHQnLCAnZm9udFNpemUnXTtcbnZhciBkdW1teVRyYW5zZm9ybWFibGUgPSBuZXcgVHJhbnNmb3JtYWJsZSgpO1xudmFyIGxhYmVsTGF5b3V0SW5uZXJTdG9yZSA9IG1ha2VJbm5lcigpO1xudmFyIGxhYmVsTGluZUFuaW1hdGlvblN0b3JlID0gbWFrZUlubmVyKCk7XG5mdW5jdGlvbiBleHRlbmRXaXRoS2V5cyh0YXJnZXQsIHNvdXJjZSwga2V5cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoc291cmNlW2tleV0gIT0gbnVsbCkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbn1cbnZhciBMQUJFTF9MQVlPVVRfUFJPUFMgPSBbJ3gnLCAneScsICdyb3RhdGlvbiddO1xudmFyIExhYmVsTWFuYWdlciA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExhYmVsTWFuYWdlcigpIHtcbiAgICB0aGlzLl9sYWJlbExpc3QgPSBbXTtcbiAgICB0aGlzLl9jaGFydFZpZXdMaXN0ID0gW107XG4gIH1cbiAgTGFiZWxNYW5hZ2VyLnByb3RvdHlwZS5jbGVhckxhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9sYWJlbExpc3QgPSBbXTtcbiAgICB0aGlzLl9jaGFydFZpZXdMaXN0ID0gW107XG4gIH07XG4gIC8qKlxyXG4gICAqIEFkZCBsYWJlbCB0byBtYW5hZ2VyXHJcbiAgICovXG4gIExhYmVsTWFuYWdlci5wcm90b3R5cGUuX2FkZExhYmVsID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgZGF0YVR5cGUsIHNlcmllc01vZGVsLCBsYWJlbCwgbGF5b3V0T3B0aW9uKSB7XG4gICAgdmFyIGxhYmVsU3R5bGUgPSBsYWJlbC5zdHlsZTtcbiAgICB2YXIgaG9zdEVsID0gbGFiZWwuX19ob3N0VGFyZ2V0O1xuICAgIHZhciB0ZXh0Q29uZmlnID0gaG9zdEVsLnRleHRDb25maWcgfHwge307XG4gICAgLy8gVE9ETzogSWYgbGFiZWwgaXMgaW4gb3RoZXIgc3RhdGUuXG4gICAgdmFyIGxhYmVsVHJhbnNmb3JtID0gbGFiZWwuZ2V0Q29tcHV0ZWRUcmFuc2Zvcm0oKTtcbiAgICB2YXIgbGFiZWxSZWN0ID0gbGFiZWwuZ2V0Qm91bmRpbmdSZWN0KCkucGxhaW4oKTtcbiAgICBCb3VuZGluZ1JlY3QuYXBwbHlUcmFuc2Zvcm0obGFiZWxSZWN0LCBsYWJlbFJlY3QsIGxhYmVsVHJhbnNmb3JtKTtcbiAgICBpZiAobGFiZWxUcmFuc2Zvcm0pIHtcbiAgICAgIGR1bW15VHJhbnNmb3JtYWJsZS5zZXRMb2NhbFRyYW5zZm9ybShsYWJlbFRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElkZW50aXR5IHRyYW5zZm9ybS5cbiAgICAgIGR1bW15VHJhbnNmb3JtYWJsZS54ID0gZHVtbXlUcmFuc2Zvcm1hYmxlLnkgPSBkdW1teVRyYW5zZm9ybWFibGUucm90YXRpb24gPSBkdW1teVRyYW5zZm9ybWFibGUub3JpZ2luWCA9IGR1bW15VHJhbnNmb3JtYWJsZS5vcmlnaW5ZID0gMDtcbiAgICAgIGR1bW15VHJhbnNmb3JtYWJsZS5zY2FsZVggPSBkdW1teVRyYW5zZm9ybWFibGUuc2NhbGVZID0gMTtcbiAgICB9XG4gICAgZHVtbXlUcmFuc2Zvcm1hYmxlLnJvdGF0aW9uID0gbm9ybWFsaXplUmFkaWFuKGR1bW15VHJhbnNmb3JtYWJsZS5yb3RhdGlvbik7XG4gICAgdmFyIGhvc3QgPSBsYWJlbC5fX2hvc3RUYXJnZXQ7XG4gICAgdmFyIGhvc3RSZWN0O1xuICAgIGlmIChob3N0KSB7XG4gICAgICBob3N0UmVjdCA9IGhvc3QuZ2V0Qm91bmRpbmdSZWN0KCkucGxhaW4oKTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBob3N0LmdldENvbXB1dGVkVHJhbnNmb3JtKCk7XG4gICAgICBCb3VuZGluZ1JlY3QuYXBwbHlUcmFuc2Zvcm0oaG9zdFJlY3QsIGhvc3RSZWN0LCB0cmFuc2Zvcm0pO1xuICAgIH1cbiAgICB2YXIgbGFiZWxHdWlkZSA9IGhvc3RSZWN0ICYmIGhvc3QuZ2V0VGV4dEd1aWRlTGluZSgpO1xuICAgIHRoaXMuX2xhYmVsTGlzdC5wdXNoKHtcbiAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgIGxhYmVsTGluZTogbGFiZWxHdWlkZSxcbiAgICAgIHNlcmllc01vZGVsOiBzZXJpZXNNb2RlbCxcbiAgICAgIGRhdGFJbmRleDogZGF0YUluZGV4LFxuICAgICAgZGF0YVR5cGU6IGRhdGFUeXBlLFxuICAgICAgbGF5b3V0T3B0aW9uOiBsYXlvdXRPcHRpb24sXG4gICAgICBjb21wdXRlZExheW91dE9wdGlvbjogbnVsbCxcbiAgICAgIHJlY3Q6IGxhYmVsUmVjdCxcbiAgICAgIGhvc3RSZWN0OiBob3N0UmVjdCxcbiAgICAgIC8vIExhYmVsIHdpdGggbG93ZXIgcHJpb3JpdHkgd2lsbCBiZSBoaWRkZW4gd2hlbiBvdmVybGFwcGVkXG4gICAgICAvLyBVc2UgcmVjdCBzaXplIGFzIGRlZmF1bHQgcHJpb3JpdHlcbiAgICAgIHByaW9yaXR5OiBob3N0UmVjdCA/IGhvc3RSZWN0LndpZHRoICogaG9zdFJlY3QuaGVpZ2h0IDogMCxcbiAgICAgIC8vIFNhdmUgZGVmYXVsdCBsYWJlbCBhdHRyaWJ1dGVzLlxuICAgICAgLy8gRm9yIHJlc3RvcmUgaWYgZGV2ZWxvcGVycyB3YW50IGdldCBiYWNrIHRvIGRlZmF1bHQgdmFsdWUgaW4gY2FsbGJhY2suXG4gICAgICBkZWZhdWx0QXR0cjoge1xuICAgICAgICBpZ25vcmU6IGxhYmVsLmlnbm9yZSxcbiAgICAgICAgbGFiZWxHdWlkZUlnbm9yZTogbGFiZWxHdWlkZSAmJiBsYWJlbEd1aWRlLmlnbm9yZSxcbiAgICAgICAgeDogZHVtbXlUcmFuc2Zvcm1hYmxlLngsXG4gICAgICAgIHk6IGR1bW15VHJhbnNmb3JtYWJsZS55LFxuICAgICAgICBzY2FsZVg6IGR1bW15VHJhbnNmb3JtYWJsZS5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogZHVtbXlUcmFuc2Zvcm1hYmxlLnNjYWxlWSxcbiAgICAgICAgcm90YXRpb246IGR1bW15VHJhbnNmb3JtYWJsZS5yb3RhdGlvbixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB4OiBsYWJlbFN0eWxlLngsXG4gICAgICAgICAgeTogbGFiZWxTdHlsZS55LFxuICAgICAgICAgIGFsaWduOiBsYWJlbFN0eWxlLmFsaWduLFxuICAgICAgICAgIHZlcnRpY2FsQWxpZ246IGxhYmVsU3R5bGUudmVydGljYWxBbGlnbixcbiAgICAgICAgICB3aWR0aDogbGFiZWxTdHlsZS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGxhYmVsU3R5bGUuaGVpZ2h0LFxuICAgICAgICAgIGZvbnRTaXplOiBsYWJlbFN0eWxlLmZvbnRTaXplXG4gICAgICAgIH0sXG4gICAgICAgIGN1cnNvcjogbGFiZWwuY3Vyc29yLFxuICAgICAgICBhdHRhY2hlZFBvczogdGV4dENvbmZpZy5wb3NpdGlvbixcbiAgICAgICAgYXR0YWNoZWRSb3Q6IHRleHRDb25maWcucm90YXRpb25cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgTGFiZWxNYW5hZ2VyLnByb3RvdHlwZS5hZGRMYWJlbHNPZlNlcmllcyA9IGZ1bmN0aW9uIChjaGFydFZpZXcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX2NoYXJ0Vmlld0xpc3QucHVzaChjaGFydFZpZXcpO1xuICAgIHZhciBzZXJpZXNNb2RlbCA9IGNoYXJ0Vmlldy5fX21vZGVsO1xuICAgIHZhciBsYXlvdXRPcHRpb24gPSBzZXJpZXNNb2RlbC5nZXQoJ2xhYmVsTGF5b3V0Jyk7XG4gICAgLyoqXHJcbiAgICAgKiBJZ25vcmUgbGF5b3V0aW5nIGlmIGl0J3Mgbm90IHNwZWNpZmllZCBhbnl0aGluZy5cclxuICAgICAqL1xuICAgIGlmICghKGlzRnVuY3Rpb24obGF5b3V0T3B0aW9uKSB8fCBrZXlzKGxheW91dE9wdGlvbikubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjaGFydFZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuaWdub3JlKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBTdG9wIHRyYXZlcnNlIGRlc2NlbmRhbnRzLlxuICAgICAgfVxuICAgICAgLy8gT25seSBzdXBwb3J0IGxhYmVsIGJlaW5nIGhvc3RlZCBvbiBncmFwaGljIGVsZW1lbnRzLlxuICAgICAgdmFyIHRleHRFbCA9IGNoaWxkLmdldFRleHRDb250ZW50KCk7XG4gICAgICB2YXIgZWNEYXRhID0gZ2V0RUNEYXRhKGNoaWxkKTtcbiAgICAgIC8vIENhbiBvbmx5IGF0dGFjaCB0aGUgdGV4dCBvbiB0aGUgZWxlbWVudCB3aXRoIGRhdGFJbmRleFxuICAgICAgaWYgKHRleHRFbCAmJiAhdGV4dEVsLmRpc2FibGVMYWJlbExheW91dCkge1xuICAgICAgICBfdGhpcy5fYWRkTGFiZWwoZWNEYXRhLmRhdGFJbmRleCwgZWNEYXRhLmRhdGFUeXBlLCBzZXJpZXNNb2RlbCwgdGV4dEVsLCBsYXlvdXRPcHRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBMYWJlbE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUxheW91dENvbmZpZyA9IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB2YXIgd2lkdGggPSBhcGkuZ2V0V2lkdGgoKTtcbiAgICB2YXIgaGVpZ2h0ID0gYXBpLmdldEhlaWdodCgpO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURyYWdIYW5kbGVyKGVsLCBsYWJlbExpbmVNb2RlbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXBkYXRlTGFiZWxMaW5lUG9pbnRzKGVsLCBsYWJlbExpbmVNb2RlbCk7XG4gICAgICB9O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xhYmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxhYmVsSXRlbSA9IHRoaXMuX2xhYmVsTGlzdFtpXTtcbiAgICAgIHZhciBsYWJlbCA9IGxhYmVsSXRlbS5sYWJlbDtcbiAgICAgIHZhciBob3N0RWwgPSBsYWJlbC5fX2hvc3RUYXJnZXQ7XG4gICAgICB2YXIgZGVmYXVsdExhYmVsQXR0ciA9IGxhYmVsSXRlbS5kZWZhdWx0QXR0cjtcbiAgICAgIHZhciBsYXlvdXRPcHRpb24gPSB2b2lkIDA7XG4gICAgICAvLyBUT0RPIEEgZ2xvYmFsIGxheW91dCBvcHRpb24/XG4gICAgICBpZiAoaXNGdW5jdGlvbihsYWJlbEl0ZW0ubGF5b3V0T3B0aW9uKSkge1xuICAgICAgICBsYXlvdXRPcHRpb24gPSBsYWJlbEl0ZW0ubGF5b3V0T3B0aW9uKHByZXBhcmVMYXlvdXRDYWxsYmFja1BhcmFtcyhsYWJlbEl0ZW0sIGhvc3RFbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGF5b3V0T3B0aW9uID0gbGFiZWxJdGVtLmxheW91dE9wdGlvbjtcbiAgICAgIH1cbiAgICAgIGxheW91dE9wdGlvbiA9IGxheW91dE9wdGlvbiB8fCB7fTtcbiAgICAgIGxhYmVsSXRlbS5jb21wdXRlZExheW91dE9wdGlvbiA9IGxheW91dE9wdGlvbjtcbiAgICAgIHZhciBkZWdyZWVUb1JhZGlhbiA9IE1hdGguUEkgLyAxODA7XG4gICAgICAvLyBUT0RPIGhvc3RFbCBzaG91bGQgYWx3YXlzIGV4aXN0cy5cbiAgICAgIC8vIE9yIGxhYmVsIHNob3VsZCBub3QgaGF2ZSBwYXJlbnQgYmVjYXVzZSB0aGUgeCwgeSBpcyBhbGwgaW4gZ2xvYmFsIHNwYWNlLlxuICAgICAgaWYgKGhvc3RFbCkge1xuICAgICAgICBob3N0RWwuc2V0VGV4dENvbmZpZyh7XG4gICAgICAgICAgLy8gRm9yY2UgdG8gc2V0IGxvY2FsIGZhbHNlLlxuICAgICAgICAgIGxvY2FsOiBmYWxzZSxcbiAgICAgICAgICAvLyBJZ25vcmUgcG9zaXRpb24gYW5kIHJvdGF0aW9uIGNvbmZpZyBvbiB0aGUgaG9zdCBlbCBpZiB4IG9yIHkgaXMgY2hhbmdlZC5cbiAgICAgICAgICBwb3NpdGlvbjogbGF5b3V0T3B0aW9uLnggIT0gbnVsbCB8fCBsYXlvdXRPcHRpb24ueSAhPSBudWxsID8gbnVsbCA6IGRlZmF1bHRMYWJlbEF0dHIuYXR0YWNoZWRQb3MsXG4gICAgICAgICAgLy8gSWdub3JlIHJvdGF0aW9uIGNvbmZpZyBvbiB0aGUgaG9zdCBlbCBpZiByb3RhdGlvbiBpcyBjaGFuZ2VkLlxuICAgICAgICAgIHJvdGF0aW9uOiBsYXlvdXRPcHRpb24ucm90YXRlICE9IG51bGwgPyBsYXlvdXRPcHRpb24ucm90YXRlICogZGVncmVlVG9SYWRpYW4gOiBkZWZhdWx0TGFiZWxBdHRyLmF0dGFjaGVkUm90LFxuICAgICAgICAgIG9mZnNldDogW2xheW91dE9wdGlvbi5keCB8fCAwLCBsYXlvdXRPcHRpb24uZHkgfHwgMF1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgbmVlZHNVcGRhdGVMYWJlbExpbmUgPSBmYWxzZTtcbiAgICAgIGlmIChsYXlvdXRPcHRpb24ueCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE8gd2lkdGggb2YgY2hhcnQgdmlldy5cbiAgICAgICAgbGFiZWwueCA9IHBhcnNlUGVyY2VudChsYXlvdXRPcHRpb24ueCwgd2lkdGgpO1xuICAgICAgICBsYWJlbC5zZXRTdHlsZSgneCcsIDApOyAvLyBJZ25vcmUgbW92ZW1lbnQgaW4gc3R5bGUuIFRPRE86IG9yaWdpbi5cbiAgICAgICAgbmVlZHNVcGRhdGVMYWJlbExpbmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWwueCA9IGRlZmF1bHRMYWJlbEF0dHIueDtcbiAgICAgICAgbGFiZWwuc2V0U3R5bGUoJ3gnLCBkZWZhdWx0TGFiZWxBdHRyLnN0eWxlLngpO1xuICAgICAgfVxuICAgICAgaWYgKGxheW91dE9wdGlvbi55ICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETyBoZWlnaHQgb2YgY2hhcnQgdmlldy5cbiAgICAgICAgbGFiZWwueSA9IHBhcnNlUGVyY2VudChsYXlvdXRPcHRpb24ueSwgaGVpZ2h0KTtcbiAgICAgICAgbGFiZWwuc2V0U3R5bGUoJ3knLCAwKTsgLy8gSWdub3JlIG1vdmVtZW50IGluIHN0eWxlLlxuICAgICAgICBuZWVkc1VwZGF0ZUxhYmVsTGluZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbC55ID0gZGVmYXVsdExhYmVsQXR0ci55O1xuICAgICAgICBsYWJlbC5zZXRTdHlsZSgneScsIGRlZmF1bHRMYWJlbEF0dHIuc3R5bGUueSk7XG4gICAgICB9XG4gICAgICBpZiAobGF5b3V0T3B0aW9uLmxhYmVsTGluZVBvaW50cykge1xuICAgICAgICB2YXIgZ3VpZGVMaW5lID0gaG9zdEVsLmdldFRleHRHdWlkZUxpbmUoKTtcbiAgICAgICAgaWYgKGd1aWRlTGluZSkge1xuICAgICAgICAgIGd1aWRlTGluZS5zZXRTaGFwZSh7XG4gICAgICAgICAgICBwb2ludHM6IGxheW91dE9wdGlvbi5sYWJlbExpbmVQb2ludHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBOb3QgdXBkYXRlXG4gICAgICAgICAgbmVlZHNVcGRhdGVMYWJlbExpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGxhYmVsTGF5b3V0U3RvcmUgPSBsYWJlbExheW91dElubmVyU3RvcmUobGFiZWwpO1xuICAgICAgbGFiZWxMYXlvdXRTdG9yZS5uZWVkc1VwZGF0ZUxhYmVsTGluZSA9IG5lZWRzVXBkYXRlTGFiZWxMaW5lO1xuICAgICAgbGFiZWwucm90YXRpb24gPSBsYXlvdXRPcHRpb24ucm90YXRlICE9IG51bGwgPyBsYXlvdXRPcHRpb24ucm90YXRlICogZGVncmVlVG9SYWRpYW4gOiBkZWZhdWx0TGFiZWxBdHRyLnJvdGF0aW9uO1xuICAgICAgbGFiZWwuc2NhbGVYID0gZGVmYXVsdExhYmVsQXR0ci5zY2FsZVg7XG4gICAgICBsYWJlbC5zY2FsZVkgPSBkZWZhdWx0TGFiZWxBdHRyLnNjYWxlWTtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgTEFCRUxfT1BUSU9OX1RPX1NUWUxFX0tFWVMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGtleSA9IExBQkVMX09QVElPTl9UT19TVFlMRV9LRVlTW2tdO1xuICAgICAgICBsYWJlbC5zZXRTdHlsZShrZXksIGxheW91dE9wdGlvbltrZXldICE9IG51bGwgPyBsYXlvdXRPcHRpb25ba2V5XSA6IGRlZmF1bHRMYWJlbEF0dHIuc3R5bGVba2V5XSk7XG4gICAgICB9XG4gICAgICBpZiAobGF5b3V0T3B0aW9uLmRyYWdnYWJsZSkge1xuICAgICAgICBsYWJlbC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICBsYWJlbC5jdXJzb3IgPSAnbW92ZSc7XG4gICAgICAgIGlmIChob3N0RWwpIHtcbiAgICAgICAgICB2YXIgaG9zdE1vZGVsID0gbGFiZWxJdGVtLnNlcmllc01vZGVsO1xuICAgICAgICAgIGlmIChsYWJlbEl0ZW0uZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gbGFiZWxJdGVtLnNlcmllc01vZGVsLmdldERhdGEobGFiZWxJdGVtLmRhdGFUeXBlKTtcbiAgICAgICAgICAgIGhvc3RNb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGxhYmVsSXRlbS5kYXRhSW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYWJlbC5vbignZHJhZycsIGNyZWF0ZURyYWdIYW5kbGVyKGhvc3RFbCwgaG9zdE1vZGVsLmdldE1vZGVsKCdsYWJlbExpbmUnKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPIE90aGVyIGRyYWcgZnVuY3Rpb25zP1xuICAgICAgICBsYWJlbC5vZmYoJ2RyYWcnKTtcbiAgICAgICAgbGFiZWwuY3Vyc29yID0gZGVmYXVsdExhYmVsQXR0ci5jdXJzb3I7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBMYWJlbE1hbmFnZXIucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uIChhcGkpIHtcbiAgICB2YXIgd2lkdGggPSBhcGkuZ2V0V2lkdGgoKTtcbiAgICB2YXIgaGVpZ2h0ID0gYXBpLmdldEhlaWdodCgpO1xuICAgIHZhciBsYWJlbExpc3QgPSBwcmVwYXJlTGF5b3V0TGlzdCh0aGlzLl9sYWJlbExpc3QpO1xuICAgIHZhciBsYWJlbHNOZWVkc0FkanVzdE9uWCA9IGZpbHRlcihsYWJlbExpc3QsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5sYXlvdXRPcHRpb24ubW92ZU92ZXJsYXAgPT09ICdzaGlmdFgnO1xuICAgIH0pO1xuICAgIHZhciBsYWJlbHNOZWVkc0FkanVzdE9uWSA9IGZpbHRlcihsYWJlbExpc3QsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5sYXlvdXRPcHRpb24ubW92ZU92ZXJsYXAgPT09ICdzaGlmdFknO1xuICAgIH0pO1xuICAgIHNoaWZ0TGF5b3V0T25YKGxhYmVsc05lZWRzQWRqdXN0T25YLCAwLCB3aWR0aCk7XG4gICAgc2hpZnRMYXlvdXRPblkobGFiZWxzTmVlZHNBZGp1c3RPblksIDAsIGhlaWdodCk7XG4gICAgdmFyIGxhYmVsc05lZWRzSGlkZU92ZXJsYXAgPSBmaWx0ZXIobGFiZWxMaXN0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0ubGF5b3V0T3B0aW9uLmhpZGVPdmVybGFwO1xuICAgIH0pO1xuICAgIGhpZGVPdmVybGFwKGxhYmVsc05lZWRzSGlkZU92ZXJsYXApO1xuICB9O1xuICAvKipcclxuICAgKiBQcm9jZXNzIGFsbCBsYWJlbHMuIE5vdCBvbmx5IGxhYmVscyB3aXRoIGxheW91dE9wdGlvbi5cclxuICAgKi9cbiAgTGFiZWxNYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzTGFiZWxzT3ZlcmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGVhY2godGhpcy5fY2hhcnRWaWV3TGlzdCwgZnVuY3Rpb24gKGNoYXJ0Vmlldykge1xuICAgICAgdmFyIHNlcmllc01vZGVsID0gY2hhcnRWaWV3Ll9fbW9kZWw7XG4gICAgICB2YXIgaWdub3JlTGFiZWxMaW5lVXBkYXRlID0gY2hhcnRWaWV3Lmlnbm9yZUxhYmVsTGluZVVwZGF0ZTtcbiAgICAgIHZhciBhbmltYXRpb25FbmFibGVkID0gc2VyaWVzTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCk7XG4gICAgICBjaGFydFZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC5pZ25vcmUgJiYgIWNoaWxkLmZvcmNlTGFiZWxBbmltYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gU3RvcCB0cmF2ZXJzZSBkZXNjZW5kYW50cy5cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmVlZHNVcGRhdGVMYWJlbExpbmUgPSAhaWdub3JlTGFiZWxMaW5lVXBkYXRlO1xuICAgICAgICB2YXIgbGFiZWwgPSBjaGlsZC5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICBpZiAoIW5lZWRzVXBkYXRlTGFiZWxMaW5lICYmIGxhYmVsKSB7XG4gICAgICAgICAgbmVlZHNVcGRhdGVMYWJlbExpbmUgPSBsYWJlbExheW91dElubmVyU3RvcmUobGFiZWwpLm5lZWRzVXBkYXRlTGFiZWxMaW5lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc1VwZGF0ZUxhYmVsTGluZSkge1xuICAgICAgICAgIF90aGlzLl91cGRhdGVMYWJlbExpbmUoY2hpbGQsIHNlcmllc01vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xuICAgICAgICAgIF90aGlzLl9hbmltYXRlTGFiZWxzKGNoaWxkLCBzZXJpZXNNb2RlbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBMYWJlbE1hbmFnZXIucHJvdG90eXBlLl91cGRhdGVMYWJlbExpbmUgPSBmdW5jdGlvbiAoZWwsIHNlcmllc01vZGVsKSB7XG4gICAgLy8gT25seSBzdXBwb3J0IGxhYmVsIGJlaW5nIGhvc3RlZCBvbiBncmFwaGljIGVsZW1lbnRzLlxuICAgIHZhciB0ZXh0RWwgPSBlbC5nZXRUZXh0Q29udGVudCgpO1xuICAgIC8vIFVwZGF0ZSBsYWJlbCBsaW5lIHN0eWxlLlxuICAgIHZhciBlY0RhdGEgPSBnZXRFQ0RhdGEoZWwpO1xuICAgIHZhciBkYXRhSW5kZXggPSBlY0RhdGEuZGF0YUluZGV4O1xuICAgIC8vIE9ubHkgc3VwcG9ydCBsYWJlbExpbmUgb24gdGhlIGxhYmVscyByZXByZXNlbnQgZGF0YS5cbiAgICBpZiAodGV4dEVsICYmIGRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoZWNEYXRhLmRhdGFUeXBlKTtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChkYXRhSW5kZXgpO1xuICAgICAgdmFyIGRlZmF1bHRTdHlsZSA9IHt9O1xuICAgICAgdmFyIHZpc3VhbFN0eWxlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ3N0eWxlJyk7XG4gICAgICBpZiAodmlzdWFsU3R5bGUpIHtcbiAgICAgICAgdmFyIHZpc3VhbFR5cGUgPSBkYXRhLmdldFZpc3VhbCgnZHJhd1R5cGUnKTtcbiAgICAgICAgLy8gRGVmYXVsdCB0byBiZSBzYW1lIHdpdGggbWFpbiBjb2xvclxuICAgICAgICBkZWZhdWx0U3R5bGUuc3Ryb2tlID0gdmlzdWFsU3R5bGVbdmlzdWFsVHlwZV07XG4gICAgICB9XG4gICAgICB2YXIgbGFiZWxMaW5lTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsTGluZScpO1xuICAgICAgc2V0TGFiZWxMaW5lU3R5bGUoZWwsIGdldExhYmVsTGluZVN0YXRlc01vZGVscyhpdGVtTW9kZWwpLCBkZWZhdWx0U3R5bGUpO1xuICAgICAgdXBkYXRlTGFiZWxMaW5lUG9pbnRzKGVsLCBsYWJlbExpbmVNb2RlbCk7XG4gICAgfVxuICB9O1xuICBMYWJlbE1hbmFnZXIucHJvdG90eXBlLl9hbmltYXRlTGFiZWxzID0gZnVuY3Rpb24gKGVsLCBzZXJpZXNNb2RlbCkge1xuICAgIHZhciB0ZXh0RWwgPSBlbC5nZXRUZXh0Q29udGVudCgpO1xuICAgIHZhciBndWlkZUxpbmUgPSBlbC5nZXRUZXh0R3VpZGVMaW5lKCk7XG4gICAgLy8gQW5pbWF0ZVxuICAgIGlmICh0ZXh0RWxcbiAgICAvLyBgZm9yY2VMYWJlbEFuaW1hdGlvbmAgaGFzIHRoZSBoaWdoZXN0IHByaW9yaXR5XG4gICAgJiYgKGVsLmZvcmNlTGFiZWxBbmltYXRpb24gfHwgIXRleHRFbC5pZ25vcmUgJiYgIXRleHRFbC5pbnZpc2libGUgJiYgIWVsLmRpc2FibGVMYWJlbEFuaW1hdGlvbiAmJiAhaXNFbGVtZW50UmVtb3ZlZChlbCkpKSB7XG4gICAgICB2YXIgbGF5b3V0U3RvcmUgPSBsYWJlbExheW91dElubmVyU3RvcmUodGV4dEVsKTtcbiAgICAgIHZhciBvbGRMYXlvdXQgPSBsYXlvdXRTdG9yZS5vbGRMYXlvdXQ7XG4gICAgICB2YXIgZWNEYXRhID0gZ2V0RUNEYXRhKGVsKTtcbiAgICAgIHZhciBkYXRhSW5kZXggPSBlY0RhdGEuZGF0YUluZGV4O1xuICAgICAgdmFyIG5ld1Byb3BzID0ge1xuICAgICAgICB4OiB0ZXh0RWwueCxcbiAgICAgICAgeTogdGV4dEVsLnksXG4gICAgICAgIHJvdGF0aW9uOiB0ZXh0RWwucm90YXRpb25cbiAgICAgIH07XG4gICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoZWNEYXRhLmRhdGFUeXBlKTtcbiAgICAgIGlmICghb2xkTGF5b3V0KSB7XG4gICAgICAgIHRleHRFbC5hdHRyKG5ld1Byb3BzKTtcbiAgICAgICAgLy8gRGlzYWJsZSBmYWRlIGluIGFuaW1hdGlvbiBpZiB2YWx1ZSBhbmltYXRpb24gaXMgZW5hYmxlZC5cbiAgICAgICAgaWYgKCFsYWJlbElubmVyKHRleHRFbCkudmFsdWVBbmltYXRpb24pIHtcbiAgICAgICAgICB2YXIgb2xkT3BhY2l0eSA9IHJldHJpZXZlMih0ZXh0RWwuc3R5bGUub3BhY2l0eSwgMSk7XG4gICAgICAgICAgLy8gRmFkZSBpbiBhbmltYXRpb25cbiAgICAgICAgICB0ZXh0RWwuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgaW5pdFByb3BzKHRleHRFbCwge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogb2xkT3BhY2l0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHNlcmllc01vZGVsLCBkYXRhSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0RWwuYXR0cihvbGRMYXlvdXQpO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGFuaW1hdGlvbiBmcm9tIGlzIGluIHRoZSByaWdodCBzdGF0dXMuXG4gICAgICAgIHZhciBwcmV2U3RhdGVzID0gZWwucHJldlN0YXRlcztcbiAgICAgICAgaWYgKHByZXZTdGF0ZXMpIHtcbiAgICAgICAgICBpZiAoaW5kZXhPZihwcmV2U3RhdGVzLCAnc2VsZWN0JykgPj0gMCkge1xuICAgICAgICAgICAgdGV4dEVsLmF0dHIobGF5b3V0U3RvcmUub2xkTGF5b3V0U2VsZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZGV4T2YocHJldlN0YXRlcywgJ2VtcGhhc2lzJykgPj0gMCkge1xuICAgICAgICAgICAgdGV4dEVsLmF0dHIobGF5b3V0U3RvcmUub2xkTGF5b3V0RW1waGFzaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVQcm9wcyh0ZXh0RWwsIG5ld1Byb3BzLCBzZXJpZXNNb2RlbCwgZGF0YUluZGV4KTtcbiAgICAgIH1cbiAgICAgIGxheW91dFN0b3JlLm9sZExheW91dCA9IG5ld1Byb3BzO1xuICAgICAgaWYgKHRleHRFbC5zdGF0ZXMuc2VsZWN0KSB7XG4gICAgICAgIHZhciBsYXlvdXRTZWxlY3QgPSBsYXlvdXRTdG9yZS5vbGRMYXlvdXRTZWxlY3QgPSB7fTtcbiAgICAgICAgZXh0ZW5kV2l0aEtleXMobGF5b3V0U2VsZWN0LCBuZXdQcm9wcywgTEFCRUxfTEFZT1VUX1BST1BTKTtcbiAgICAgICAgZXh0ZW5kV2l0aEtleXMobGF5b3V0U2VsZWN0LCB0ZXh0RWwuc3RhdGVzLnNlbGVjdCwgTEFCRUxfTEFZT1VUX1BST1BTKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0RWwuc3RhdGVzLmVtcGhhc2lzKSB7XG4gICAgICAgIHZhciBsYXlvdXRFbXBoYXNpcyA9IGxheW91dFN0b3JlLm9sZExheW91dEVtcGhhc2lzID0ge307XG4gICAgICAgIGV4dGVuZFdpdGhLZXlzKGxheW91dEVtcGhhc2lzLCBuZXdQcm9wcywgTEFCRUxfTEFZT1VUX1BST1BTKTtcbiAgICAgICAgZXh0ZW5kV2l0aEtleXMobGF5b3V0RW1waGFzaXMsIHRleHRFbC5zdGF0ZXMuZW1waGFzaXMsIExBQkVMX0xBWU9VVF9QUk9QUyk7XG4gICAgICB9XG4gICAgICBhbmltYXRlTGFiZWxWYWx1ZSh0ZXh0RWwsIGRhdGFJbmRleCwgZGF0YSwgc2VyaWVzTW9kZWwsIHNlcmllc01vZGVsKTtcbiAgICB9XG4gICAgaWYgKGd1aWRlTGluZSAmJiAhZ3VpZGVMaW5lLmlnbm9yZSAmJiAhZ3VpZGVMaW5lLmludmlzaWJsZSkge1xuICAgICAgdmFyIGxheW91dFN0b3JlID0gbGFiZWxMaW5lQW5pbWF0aW9uU3RvcmUoZ3VpZGVMaW5lKTtcbiAgICAgIHZhciBvbGRMYXlvdXQgPSBsYXlvdXRTdG9yZS5vbGRMYXlvdXQ7XG4gICAgICB2YXIgbmV3TGF5b3V0ID0ge1xuICAgICAgICBwb2ludHM6IGd1aWRlTGluZS5zaGFwZS5wb2ludHNcbiAgICAgIH07XG4gICAgICBpZiAoIW9sZExheW91dCkge1xuICAgICAgICBndWlkZUxpbmUuc2V0U2hhcGUobmV3TGF5b3V0KTtcbiAgICAgICAgZ3VpZGVMaW5lLnN0eWxlLnN0cm9rZVBlcmNlbnQgPSAwO1xuICAgICAgICBpbml0UHJvcHMoZ3VpZGVMaW5lLCB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZVBlcmNlbnQ6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGd1aWRlTGluZS5hdHRyKHtcbiAgICAgICAgICBzaGFwZTogb2xkTGF5b3V0XG4gICAgICAgIH0pO1xuICAgICAgICB1cGRhdGVQcm9wcyhndWlkZUxpbmUsIHtcbiAgICAgICAgICBzaGFwZTogbmV3TGF5b3V0XG4gICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgIH1cbiAgICAgIGxheW91dFN0b3JlLm9sZExheW91dCA9IG5ld0xheW91dDtcbiAgICB9XG4gIH07XG4gIHJldHVybiBMYWJlbE1hbmFnZXI7XG59KCk7XG5leHBvcnQgZGVmYXVsdCBMYWJlbE1hbmFnZXI7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCBMYWJlbE1hbmFnZXIgZnJvbSAnLi9MYWJlbE1hbmFnZXIuanMnO1xudmFyIGdldExhYmVsTWFuYWdlciA9IG1ha2VJbm5lcigpO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGxMYWJlbExheW91dChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyVXBkYXRlTGlmZWN5Y2xlKCdzZXJpZXM6YmVmb3JldXBkYXRlJywgZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSwgcGFyYW1zKSB7XG4gICAgLy8gVE9ETyBhcGkgcHJvdmlkZSBhbiBuYW1lc3BhY2UgdGhhdCBjYW4gc2F2ZSBzdHVmZiBwZXIgaW5zdGFuY2VcbiAgICB2YXIgbGFiZWxNYW5hZ2VyID0gZ2V0TGFiZWxNYW5hZ2VyKGFwaSkubGFiZWxNYW5hZ2VyO1xuICAgIGlmICghbGFiZWxNYW5hZ2VyKSB7XG4gICAgICBsYWJlbE1hbmFnZXIgPSBnZXRMYWJlbE1hbmFnZXIoYXBpKS5sYWJlbE1hbmFnZXIgPSBuZXcgTGFiZWxNYW5hZ2VyKCk7XG4gICAgfVxuICAgIGxhYmVsTWFuYWdlci5jbGVhckxhYmVscygpO1xuICB9KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyVXBkYXRlTGlmZWN5Y2xlKCdzZXJpZXM6bGF5b3V0bGFiZWxzJywgZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSwgcGFyYW1zKSB7XG4gICAgdmFyIGxhYmVsTWFuYWdlciA9IGdldExhYmVsTWFuYWdlcihhcGkpLmxhYmVsTWFuYWdlcjtcbiAgICBwYXJhbXMudXBkYXRlZFNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgIGxhYmVsTWFuYWdlci5hZGRMYWJlbHNPZlNlcmllcyhhcGkuZ2V0Vmlld09mU2VyaWVzTW9kZWwoc2VyaWVzKSk7XG4gICAgfSk7XG4gICAgbGFiZWxNYW5hZ2VyLnVwZGF0ZUxheW91dENvbmZpZyhhcGkpO1xuICAgIGxhYmVsTWFuYWdlci5sYXlvdXQoYXBpKTtcbiAgICBsYWJlbE1hbmFnZXIucHJvY2Vzc0xhYmVsc092ZXJhbGwoKTtcbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///35278\n")},45764:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n/**\r\n * Language: English.\r\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  time: {\n    month: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n    monthAbbr: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n    dayOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n    dayOfWeekAbbr: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']\n  },\n  legend: {\n    selector: {\n      all: 'All',\n      inverse: 'Inv'\n    }\n  },\n  toolbox: {\n    brush: {\n      title: {\n        rect: 'Box Select',\n        polygon: 'Lasso Select',\n        lineX: 'Horizontally Select',\n        lineY: 'Vertically Select',\n        keep: 'Keep Selections',\n        clear: 'Clear Selections'\n      }\n    },\n    dataView: {\n      title: 'Data View',\n      lang: ['Data View', 'Close', 'Refresh']\n    },\n    dataZoom: {\n      title: {\n        zoom: 'Zoom',\n        back: 'Zoom Reset'\n      }\n    },\n    magicType: {\n      title: {\n        line: 'Switch to Line Chart',\n        bar: 'Switch to Bar Chart',\n        stack: 'Stack',\n        tiled: 'Tile'\n      }\n    },\n    restore: {\n      title: 'Restore'\n    },\n    saveAsImage: {\n      title: 'Save as Image',\n      lang: ['Right Click to Save Image']\n    }\n  },\n  series: {\n    typeNames: {\n      pie: 'Pie chart',\n      bar: 'Bar chart',\n      line: 'Line chart',\n      scatter: 'Scatter plot',\n      effectScatter: 'Ripple scatter plot',\n      radar: 'Radar chart',\n      tree: 'Tree',\n      treemap: 'Treemap',\n      boxplot: 'Boxplot',\n      candlestick: 'Candlestick',\n      k: 'K line chart',\n      heatmap: 'Heat map',\n      map: 'Map',\n      parallel: 'Parallel coordinate map',\n      lines: 'Line graph',\n      graph: 'Relationship graph',\n      sankey: 'Sankey diagram',\n      funnel: 'Funnel chart',\n      gauge: 'Gauge',\n      pictorialBar: 'Pictorial bar',\n      themeRiver: 'Theme River Map',\n      sunburst: 'Sunburst',\n      custom: 'Custom chart',\n      chart: 'Chart'\n    }\n  },\n  aria: {\n    general: {\n      withTitle: 'This is a chart about \"{title}\"',\n      withoutTitle: 'This is a chart'\n    },\n    series: {\n      single: {\n        prefix: '',\n        withName: ' with type {seriesType} named {seriesName}.',\n        withoutName: ' with type {seriesType}.'\n      },\n      multiple: {\n        prefix: '. It consists of {seriesCount} series count.',\n        withName: ' The {seriesId} series is a {seriesType} representing {seriesName}.',\n        withoutName: ' The {seriesId} series is a {seriesType}.',\n        separator: {\n          middle: '',\n          end: ''\n        }\n      }\n    },\n    data: {\n      allData: 'The data is as follows: ',\n      partialData: 'The first {displayCnt} items are: ',\n      withName: 'the data for {name} is {value}',\n      withoutName: '{value}',\n      separator: {\n        middle: ', ',\n        end: '. '\n      }\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU3NjQuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvaTE4bi9sYW5nRU4uanM/YmRiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xuLyoqXHJcbiAqIExhbmd1YWdlOiBFbmdsaXNoLlxyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdGltZToge1xuICAgIG1vbnRoOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSxcbiAgICBtb250aEFiYnI6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcbiAgICBkYXlPZldlZWs6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcbiAgICBkYXlPZldlZWtBYmJyOiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddXG4gIH0sXG4gIGxlZ2VuZDoge1xuICAgIHNlbGVjdG9yOiB7XG4gICAgICBhbGw6ICdBbGwnLFxuICAgICAgaW52ZXJzZTogJ0ludidcbiAgICB9XG4gIH0sXG4gIHRvb2xib3g6IHtcbiAgICBicnVzaDoge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgcmVjdDogJ0JveCBTZWxlY3QnLFxuICAgICAgICBwb2x5Z29uOiAnTGFzc28gU2VsZWN0JyxcbiAgICAgICAgbGluZVg6ICdIb3Jpem9udGFsbHkgU2VsZWN0JyxcbiAgICAgICAgbGluZVk6ICdWZXJ0aWNhbGx5IFNlbGVjdCcsXG4gICAgICAgIGtlZXA6ICdLZWVwIFNlbGVjdGlvbnMnLFxuICAgICAgICBjbGVhcjogJ0NsZWFyIFNlbGVjdGlvbnMnXG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhVmlldzoge1xuICAgICAgdGl0bGU6ICdEYXRhIFZpZXcnLFxuICAgICAgbGFuZzogWydEYXRhIFZpZXcnLCAnQ2xvc2UnLCAnUmVmcmVzaCddXG4gICAgfSxcbiAgICBkYXRhWm9vbToge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgem9vbTogJ1pvb20nLFxuICAgICAgICBiYWNrOiAnWm9vbSBSZXNldCdcbiAgICAgIH1cbiAgICB9LFxuICAgIG1hZ2ljVHlwZToge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgbGluZTogJ1N3aXRjaCB0byBMaW5lIENoYXJ0JyxcbiAgICAgICAgYmFyOiAnU3dpdGNoIHRvIEJhciBDaGFydCcsXG4gICAgICAgIHN0YWNrOiAnU3RhY2snLFxuICAgICAgICB0aWxlZDogJ1RpbGUnXG4gICAgICB9XG4gICAgfSxcbiAgICByZXN0b3JlOiB7XG4gICAgICB0aXRsZTogJ1Jlc3RvcmUnXG4gICAgfSxcbiAgICBzYXZlQXNJbWFnZToge1xuICAgICAgdGl0bGU6ICdTYXZlIGFzIEltYWdlJyxcbiAgICAgIGxhbmc6IFsnUmlnaHQgQ2xpY2sgdG8gU2F2ZSBJbWFnZSddXG4gICAgfVxuICB9LFxuICBzZXJpZXM6IHtcbiAgICB0eXBlTmFtZXM6IHtcbiAgICAgIHBpZTogJ1BpZSBjaGFydCcsXG4gICAgICBiYXI6ICdCYXIgY2hhcnQnLFxuICAgICAgbGluZTogJ0xpbmUgY2hhcnQnLFxuICAgICAgc2NhdHRlcjogJ1NjYXR0ZXIgcGxvdCcsXG4gICAgICBlZmZlY3RTY2F0dGVyOiAnUmlwcGxlIHNjYXR0ZXIgcGxvdCcsXG4gICAgICByYWRhcjogJ1JhZGFyIGNoYXJ0JyxcbiAgICAgIHRyZWU6ICdUcmVlJyxcbiAgICAgIHRyZWVtYXA6ICdUcmVlbWFwJyxcbiAgICAgIGJveHBsb3Q6ICdCb3hwbG90JyxcbiAgICAgIGNhbmRsZXN0aWNrOiAnQ2FuZGxlc3RpY2snLFxuICAgICAgazogJ0sgbGluZSBjaGFydCcsXG4gICAgICBoZWF0bWFwOiAnSGVhdCBtYXAnLFxuICAgICAgbWFwOiAnTWFwJyxcbiAgICAgIHBhcmFsbGVsOiAnUGFyYWxsZWwgY29vcmRpbmF0ZSBtYXAnLFxuICAgICAgbGluZXM6ICdMaW5lIGdyYXBoJyxcbiAgICAgIGdyYXBoOiAnUmVsYXRpb25zaGlwIGdyYXBoJyxcbiAgICAgIHNhbmtleTogJ1NhbmtleSBkaWFncmFtJyxcbiAgICAgIGZ1bm5lbDogJ0Z1bm5lbCBjaGFydCcsXG4gICAgICBnYXVnZTogJ0dhdWdlJyxcbiAgICAgIHBpY3RvcmlhbEJhcjogJ1BpY3RvcmlhbCBiYXInLFxuICAgICAgdGhlbWVSaXZlcjogJ1RoZW1lIFJpdmVyIE1hcCcsXG4gICAgICBzdW5idXJzdDogJ1N1bmJ1cnN0JyxcbiAgICAgIGN1c3RvbTogJ0N1c3RvbSBjaGFydCcsXG4gICAgICBjaGFydDogJ0NoYXJ0J1xuICAgIH1cbiAgfSxcbiAgYXJpYToge1xuICAgIGdlbmVyYWw6IHtcbiAgICAgIHdpdGhUaXRsZTogJ1RoaXMgaXMgYSBjaGFydCBhYm91dCBcInt0aXRsZX1cIicsXG4gICAgICB3aXRob3V0VGl0bGU6ICdUaGlzIGlzIGEgY2hhcnQnXG4gICAgfSxcbiAgICBzZXJpZXM6IHtcbiAgICAgIHNpbmdsZToge1xuICAgICAgICBwcmVmaXg6ICcnLFxuICAgICAgICB3aXRoTmFtZTogJyB3aXRoIHR5cGUge3Nlcmllc1R5cGV9IG5hbWVkIHtzZXJpZXNOYW1lfS4nLFxuICAgICAgICB3aXRob3V0TmFtZTogJyB3aXRoIHR5cGUge3Nlcmllc1R5cGV9LidcbiAgICAgIH0sXG4gICAgICBtdWx0aXBsZToge1xuICAgICAgICBwcmVmaXg6ICcuIEl0IGNvbnNpc3RzIG9mIHtzZXJpZXNDb3VudH0gc2VyaWVzIGNvdW50LicsXG4gICAgICAgIHdpdGhOYW1lOiAnIFRoZSB7c2VyaWVzSWR9IHNlcmllcyBpcyBhIHtzZXJpZXNUeXBlfSByZXByZXNlbnRpbmcge3Nlcmllc05hbWV9LicsXG4gICAgICAgIHdpdGhvdXROYW1lOiAnIFRoZSB7c2VyaWVzSWR9IHNlcmllcyBpcyBhIHtzZXJpZXNUeXBlfS4nLFxuICAgICAgICBzZXBhcmF0b3I6IHtcbiAgICAgICAgICBtaWRkbGU6ICcnLFxuICAgICAgICAgIGVuZDogJydcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YToge1xuICAgICAgYWxsRGF0YTogJ1RoZSBkYXRhIGlzIGFzIGZvbGxvd3M6ICcsXG4gICAgICBwYXJ0aWFsRGF0YTogJ1RoZSBmaXJzdCB7ZGlzcGxheUNudH0gaXRlbXMgYXJlOiAnLFxuICAgICAgd2l0aE5hbWU6ICd0aGUgZGF0YSBmb3Ige25hbWV9IGlzIHt2YWx1ZX0nLFxuICAgICAgd2l0aG91dE5hbWU6ICd7dmFsdWV9JyxcbiAgICAgIHNlcGFyYXRvcjoge1xuICAgICAgICBtaWRkbGU6ICcsICcsXG4gICAgICAgIGVuZDogJy4gJ1xuICAgICAgfVxuICAgIH1cbiAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///45764\n")},62536:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DL: () => (/* binding */ getLayoutOnAxis),\n/* harmony export */   GL: () => (/* binding */ prepareLayoutBarSeries),\n/* harmony export */   KF: () => (/* binding */ createProgressiveLayout),\n/* harmony export */   VA: () => (/* binding */ retrieveColumnLayout),\n/* harmony export */   Zp: () => (/* binding */ layout),\n/* harmony export */   vq: () => (/* binding */ makeColumnLayout)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24326);\n/* harmony import */ var _data_helper_dataStackHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(65008);\n/* harmony import */ var _chart_helper_createRenderPlanner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87582);\n/* harmony import */ var _util_vendor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8957);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar STACK_PREFIX = '__ec_stack_';\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\r\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\r\n */\nfunction getLayoutOnAxis(opt) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n  var bandWidth = baseAxis.getBandWidth();\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.defaults)({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n  var widthAndOffsets = doCalBarWidthAndOffset(params);\n  var result = [];\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n  return result;\n}\nfunction prepareLayoutBarSeries(seriesType, ecModel) {\n  var seriesModels = [];\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (isOnCartesian(seriesModel)) {\n      seriesModels.push(seriesModel);\n    }\n  });\n  return seriesModels;\n}\n/**\r\n * Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent\r\n * values.\r\n * This works for time axes, value axes, and log axes.\r\n * For a single time axis, return value is in the form like\r\n * {'x_0': [1000000]}.\r\n * The value of 1000000 is in milliseconds.\r\n */\nfunction getValueAxesMinGaps(barSeries) {\n  /**\r\n   * Map from axis.index to values.\r\n   * For a single time axis, axisValues is in the form like\r\n   * {'x_0': [1495555200000, 1495641600000, 1495728000000]}.\r\n   * Items in axisValues[x], e.g. 1495555200000, are time values of all\r\n   * series.\r\n   */\n  var axisValues = {};\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {\n      return;\n    }\n    var data = seriesModel.getData();\n    var key = baseAxis.dim + '_' + baseAxis.index;\n    var dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));\n    var store = data.getStore();\n    for (var i = 0, cnt = store.count(); i < cnt; ++i) {\n      var value = store.get(dimIdx, i);\n      if (!axisValues[key]) {\n        // No previous data for the axis\n        axisValues[key] = [value];\n      } else {\n        // No value in previous series\n        axisValues[key].push(value);\n      }\n      // Ignore duplicated time values in the same axis\n    }\n  });\n  var axisMinGaps = {};\n  for (var key in axisValues) {\n    if (axisValues.hasOwnProperty(key)) {\n      var valuesInAxis = axisValues[key];\n      if (valuesInAxis) {\n        // Sort axis values into ascending order to calculate gaps\n        valuesInAxis.sort(function (a, b) {\n          return a - b;\n        });\n        var min = null;\n        for (var j = 1; j < valuesInAxis.length; ++j) {\n          var delta = valuesInAxis[j] - valuesInAxis[j - 1];\n          if (delta > 0) {\n            // Ignore 0 delta because they are of the same axis value\n            min = min === null ? delta : Math.min(min, delta);\n          }\n        }\n        // Set to null if only have one data\n        axisMinGaps[key] = min;\n      }\n    }\n  }\n  return axisMinGaps;\n}\nfunction makeColumnLayout(barSeries) {\n  var axisMinGaps = getValueAxesMinGaps(barSeries);\n  var seriesInfoList = [];\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth;\n    if (baseAxis.type === 'category') {\n      bandWidth = baseAxis.getBandWidth();\n    } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {\n      var key = baseAxis.dim + '_' + baseAxis.index;\n      var minGap = axisMinGaps[key];\n      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);\n      var scale = baseAxis.scale.getExtent();\n      var scaleSpan = Math.abs(scale[1] - scale[0]);\n      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan; // When there is only one data value\n    } else {\n      var data = seriesModel.getData();\n      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    }\n    var barWidth = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(seriesModel.get('barMaxWidth'), bandWidth);\n    var barMinWidth = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(\n    // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,\n    // the auto-calculated bar width might be less than 0.5 / 1.\n    seriesModel.get('barMinWidth') || (isInLargeMode(seriesModel) ? 0.5 : 1), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    seriesInfoList.push({\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barMinWidth: barMinWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    });\n  });\n  return doCalBarWidthAndOffset(seriesInfoList);\n}\nfunction doCalBarWidthAndOffset(seriesInfoList) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: null,\n      gap: '20%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    };\n    // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n    var barWidth = seriesInfo.barWidth;\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barMinWidth = seriesInfo.barMinWidth;\n    barMinWidth && (stacks[stackId].minWidth = barMinWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGapPercent = columnsOnAxis.categoryGap;\n    if (categoryGapPercent == null) {\n      var columnCount = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys)(stacks).length;\n      // More columns in one group\n      // the spaces between group is smaller. Or the column will be too thin.\n      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + '%';\n    }\n    var categoryGap = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(categoryGapPercent, bandWidth);\n    var barGapPercent = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parsePercent */ .lo)(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    // Find if any auto calculated bar exceeded maxBarWidth\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(stacks, function (column) {\n      var maxWidth = column.maxWidth;\n      var minWidth = column.minWidth;\n      if (!column.width) {\n        var finalWidth = autoWidth;\n        if (maxWidth && maxWidth < finalWidth) {\n          finalWidth = Math.min(maxWidth, remainedWidth);\n        }\n        // `minWidth` has higher priority. `minWidth` decide that whether the\n        // bar is able to be visible. So `minWidth` should not be restricted\n        // by `maxWidth` or `remainedWidth` (which is from `bandWidth`). In\n        // the extreme cases for `value` axis, bars are allowed to overlap\n        // with each other if `minWidth` specified.\n        if (minWidth && minWidth > finalWidth) {\n          finalWidth = minWidth;\n        }\n        if (finalWidth !== autoWidth) {\n          column.width = finalWidth;\n          remainedWidth -= finalWidth + barGapPercent * finalWidth;\n          autoWidthCount--;\n        }\n      } else {\n        // `barMinWidth/barMaxWidth` has higher priority than `barWidth`, as\n        // CSS does. Because barWidth can be a percent value, where\n        // `barMaxWidth` can be used to restrict the final width.\n        var finalWidth = column.width;\n        if (maxWidth) {\n          finalWidth = Math.min(finalWidth, maxWidth);\n        }\n        // `minWidth` has higher priority, as described above\n        if (minWidth) {\n          finalWidth = Math.max(finalWidth, minWidth);\n        }\n        column.width = finalWidth;\n        remainedWidth -= finalWidth + barGapPercent * finalWidth;\n        autoWidthCount--;\n      }\n    });\n    // Recalculate width again\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n    var offset = -widthSum / 2;\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        bandWidth: bandWidth,\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\nfunction retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {\n  if (barWidthAndOffset && axis) {\n    var result = barWidthAndOffset[getAxisKey(axis)];\n    if (result != null && seriesModel != null) {\n      return result[getSeriesStackId(seriesModel)];\n    }\n    return result;\n  }\n}\n\nfunction layout(seriesType, ecModel) {\n  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);\n  var barWidthAndOffset = makeColumnLayout(seriesModels);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(seriesModels, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    data.setLayout({\n      bandWidth: columnLayoutInfo.bandWidth,\n      offset: columnOffset,\n      size: columnWidth\n    });\n  });\n}\n// TODO: Do not support stack in large mode yet.\nfunction createProgressiveLayout(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: (0,_chart_helper_createRenderPlanner_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A)(),\n    reset: function (seriesModel) {\n      if (!isOnCartesian(seriesModel)) {\n        return;\n      }\n      var data = seriesModel.getData();\n      var cartesian = seriesModel.coordinateSystem;\n      var baseAxis = cartesian.getBaseAxis();\n      var valueAxis = cartesian.getOtherAxis(baseAxis);\n      var valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis.dim));\n      var baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));\n      var drawBackground = seriesModel.get('showBackground', true);\n      var valueDim = data.mapDimension(valueAxis.dim);\n      var stackResultDim = data.getCalculationInfo('stackResultDimension');\n      var stacked = (0,_data_helper_dataStackHelper_js__WEBPACK_IMPORTED_MODULE_3__/* .isDimensionStacked */ .sJ)(data, valueDim) && !!data.getCalculationInfo('stackedOnSeries');\n      var isValueAxisH = valueAxis.isHorizontal();\n      var valueAxisStart = getValueAxisStart(baseAxis, valueAxis);\n      var isLarge = isInLargeMode(seriesModel);\n      var barMinHeight = seriesModel.get('barMinHeight') || 0;\n      var stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim);\n      // Layout info.\n      var columnWidth = data.getLayout('size');\n      var columnOffset = data.getLayout('offset');\n      return {\n        progress: function (params, data) {\n          var count = params.count;\n          var largePoints = isLarge && (0,_util_vendor_js__WEBPACK_IMPORTED_MODULE_4__/* .createFloat32Array */ .J)(count * 3);\n          var largeBackgroundPoints = isLarge && drawBackground && (0,_util_vendor_js__WEBPACK_IMPORTED_MODULE_4__/* .createFloat32Array */ .J)(count * 3);\n          var largeDataIndices = isLarge && (0,_util_vendor_js__WEBPACK_IMPORTED_MODULE_4__/* .createFloat32Array */ .J)(count);\n          var coordLayout = cartesian.master.getRect();\n          var bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;\n          var dataIndex;\n          var store = data.getStore();\n          var idxOffset = 0;\n          while ((dataIndex = params.next()) != null) {\n            var value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);\n            var baseValue = store.get(baseDimIdx, dataIndex);\n            var baseCoord = valueAxisStart;\n            var stackStartValue = void 0;\n            // Because of the barMinHeight, we can not use the value in\n            // stackResultDimension directly.\n            if (stacked) {\n              stackStartValue = +value - store.get(valueDimIdx, dataIndex);\n            }\n            var x = void 0;\n            var y = void 0;\n            var width = void 0;\n            var height = void 0;\n            if (isValueAxisH) {\n              var coord = cartesian.dataToPoint([value, baseValue]);\n              if (stacked) {\n                var startCoord = cartesian.dataToPoint([stackStartValue, baseValue]);\n                baseCoord = startCoord[0];\n              }\n              x = baseCoord;\n              y = coord[1] + columnOffset;\n              width = coord[0] - baseCoord;\n              height = columnWidth;\n              if (Math.abs(width) < barMinHeight) {\n                width = (width < 0 ? -1 : 1) * barMinHeight;\n              }\n            } else {\n              var coord = cartesian.dataToPoint([baseValue, value]);\n              if (stacked) {\n                var startCoord = cartesian.dataToPoint([baseValue, stackStartValue]);\n                baseCoord = startCoord[1];\n              }\n              x = coord[0] + columnOffset;\n              y = baseCoord;\n              width = columnWidth;\n              height = coord[1] - baseCoord;\n              if (Math.abs(height) < barMinHeight) {\n                // Include zero to has a positive bar\n                height = (height <= 0 ? -1 : 1) * barMinHeight;\n              }\n            }\n            if (!isLarge) {\n              data.setItemLayout(dataIndex, {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n              });\n            } else {\n              largePoints[idxOffset] = x;\n              largePoints[idxOffset + 1] = y;\n              largePoints[idxOffset + 2] = isValueAxisH ? width : height;\n              if (largeBackgroundPoints) {\n                largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x;\n                largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y : coordLayout.y;\n                largeBackgroundPoints[idxOffset + 2] = bgSize;\n              }\n              largeDataIndices[dataIndex] = dataIndex;\n            }\n            idxOffset += 3;\n          }\n          if (isLarge) {\n            data.setLayout({\n              largePoints: largePoints,\n              largeDataIndices: largeDataIndices,\n              largeBackgroundPoints: largeBackgroundPoints,\n              valueAxisHorizontal: isValueAxisH\n            });\n          }\n        }\n      };\n    }\n  };\n}\nfunction isOnCartesian(seriesModel) {\n  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n}\nfunction isInLargeMode(seriesModel) {\n  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;\n}\n// See cases in `test/bar-start.html` and `#7412`, `#8747`.\nfunction getValueAxisStart(baseAxis, valueAxis) {\n  var startValue = valueAxis.model.get('startValue');\n  if (!startValue) {\n    startValue = 0;\n  }\n  return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? startValue > 0 ? startValue : 1 : startValue));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI1MzYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYXlvdXQvYmFyR3JpZC5qcz84ZTYzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgZWFjaCwgZGVmYXVsdHMsIGtleXMgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgcGFyc2VQZXJjZW50IH0gZnJvbSAnLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IHsgaXNEaW1lbnNpb25TdGFja2VkIH0gZnJvbSAnLi4vZGF0YS9oZWxwZXIvZGF0YVN0YWNrSGVscGVyLmpzJztcbmltcG9ydCBjcmVhdGVSZW5kZXJQbGFubmVyIGZyb20gJy4uL2NoYXJ0L2hlbHBlci9jcmVhdGVSZW5kZXJQbGFubmVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZUZsb2F0MzJBcnJheSB9IGZyb20gJy4uL3V0aWwvdmVuZG9yLmpzJztcbnZhciBTVEFDS19QUkVGSVggPSAnX19lY19zdGFja18nO1xuZnVuY3Rpb24gZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCkge1xuICByZXR1cm4gc2VyaWVzTW9kZWwuZ2V0KCdzdGFjaycpIHx8IFNUQUNLX1BSRUZJWCArIHNlcmllc01vZGVsLnNlcmllc0luZGV4O1xufVxuZnVuY3Rpb24gZ2V0QXhpc0tleShheGlzKSB7XG4gIHJldHVybiBheGlzLmRpbSArIGF4aXMuaW5kZXg7XG59XG4vKipcclxuICogQHJldHVybiB7T2JqZWN0fSB7d2lkdGgsIG9mZnNldCwgb2Zmc2V0Q2VudGVyfSBJZiBheGlzLnR5cGUgaXMgbm90ICdjYXRlZ29yeScsIHJldHVybiB1bmRlZmluZWQuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExheW91dE9uQXhpcyhvcHQpIHtcbiAgdmFyIHBhcmFtcyA9IFtdO1xuICB2YXIgYmFzZUF4aXMgPSBvcHQuYXhpcztcbiAgdmFyIGF4aXNLZXkgPSAnYXhpczAnO1xuICBpZiAoYmFzZUF4aXMudHlwZSAhPT0gJ2NhdGVnb3J5Jykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYmFuZFdpZHRoID0gYmFzZUF4aXMuZ2V0QmFuZFdpZHRoKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0LmNvdW50IHx8IDA7IGkrKykge1xuICAgIHBhcmFtcy5wdXNoKGRlZmF1bHRzKHtcbiAgICAgIGJhbmRXaWR0aDogYmFuZFdpZHRoLFxuICAgICAgYXhpc0tleTogYXhpc0tleSxcbiAgICAgIHN0YWNrSWQ6IFNUQUNLX1BSRUZJWCArIGlcbiAgICB9LCBvcHQpKTtcbiAgfVxuICB2YXIgd2lkdGhBbmRPZmZzZXRzID0gZG9DYWxCYXJXaWR0aEFuZE9mZnNldChwYXJhbXMpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0LmNvdW50OyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHdpZHRoQW5kT2Zmc2V0c1theGlzS2V5XVtTVEFDS19QUkVGSVggKyBpXTtcbiAgICBpdGVtLm9mZnNldENlbnRlciA9IGl0ZW0ub2Zmc2V0ICsgaXRlbS53aWR0aCAvIDI7XG4gICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlTGF5b3V0QmFyU2VyaWVzKHNlcmllc1R5cGUsIGVjTW9kZWwpIHtcbiAgdmFyIHNlcmllc01vZGVscyA9IFtdO1xuICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoc2VyaWVzVHlwZSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgLy8gQ2hlY2sgc2VyaWVzIGNvb3JkaW5hdGUsIGRvIGxheW91dCBmb3IgY2FydGVzaWFuMmQgb25seVxuICAgIGlmIChpc09uQ2FydGVzaWFuKHNlcmllc01vZGVsKSkge1xuICAgICAgc2VyaWVzTW9kZWxzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzZXJpZXNNb2RlbHM7XG59XG4vKipcclxuICogTWFwIGZyb20gKGJhc2VBeGlzLmRpbSArICdfJyArIGJhc2VBeGlzLmluZGV4KSB0byBtaW4gZ2FwIG9mIHR3byBhZGphY2VudFxyXG4gKiB2YWx1ZXMuXHJcbiAqIFRoaXMgd29ya3MgZm9yIHRpbWUgYXhlcywgdmFsdWUgYXhlcywgYW5kIGxvZyBheGVzLlxyXG4gKiBGb3IgYSBzaW5nbGUgdGltZSBheGlzLCByZXR1cm4gdmFsdWUgaXMgaW4gdGhlIGZvcm0gbGlrZVxyXG4gKiB7J3hfMCc6IFsxMDAwMDAwXX0uXHJcbiAqIFRoZSB2YWx1ZSBvZiAxMDAwMDAwIGlzIGluIG1pbGxpc2Vjb25kcy5cclxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUF4ZXNNaW5HYXBzKGJhclNlcmllcykge1xuICAvKipcclxuICAgKiBNYXAgZnJvbSBheGlzLmluZGV4IHRvIHZhbHVlcy5cclxuICAgKiBGb3IgYSBzaW5nbGUgdGltZSBheGlzLCBheGlzVmFsdWVzIGlzIGluIHRoZSBmb3JtIGxpa2VcclxuICAgKiB7J3hfMCc6IFsxNDk1NTU1MjAwMDAwLCAxNDk1NjQxNjAwMDAwLCAxNDk1NzI4MDAwMDAwXX0uXHJcbiAgICogSXRlbXMgaW4gYXhpc1ZhbHVlc1t4XSwgZS5nLiAxNDk1NTU1MjAwMDAwLCBhcmUgdGltZSB2YWx1ZXMgb2YgYWxsXHJcbiAgICogc2VyaWVzLlxyXG4gICAqL1xuICB2YXIgYXhpc1ZhbHVlcyA9IHt9O1xuICBlYWNoKGJhclNlcmllcywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGNhcnRlc2lhbiA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgaWYgKGJhc2VBeGlzLnR5cGUgIT09ICd0aW1lJyAmJiBiYXNlQXhpcy50eXBlICE9PSAndmFsdWUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBrZXkgPSBiYXNlQXhpcy5kaW0gKyAnXycgKyBiYXNlQXhpcy5pbmRleDtcbiAgICB2YXIgZGltSWR4ID0gZGF0YS5nZXREaW1lbnNpb25JbmRleChkYXRhLm1hcERpbWVuc2lvbihiYXNlQXhpcy5kaW0pKTtcbiAgICB2YXIgc3RvcmUgPSBkYXRhLmdldFN0b3JlKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGNudCA9IHN0b3JlLmNvdW50KCk7IGkgPCBjbnQ7ICsraSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RvcmUuZ2V0KGRpbUlkeCwgaSk7XG4gICAgICBpZiAoIWF4aXNWYWx1ZXNba2V5XSkge1xuICAgICAgICAvLyBObyBwcmV2aW91cyBkYXRhIGZvciB0aGUgYXhpc1xuICAgICAgICBheGlzVmFsdWVzW2tleV0gPSBbdmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gdmFsdWUgaW4gcHJldmlvdXMgc2VyaWVzXG4gICAgICAgIGF4aXNWYWx1ZXNba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIElnbm9yZSBkdXBsaWNhdGVkIHRpbWUgdmFsdWVzIGluIHRoZSBzYW1lIGF4aXNcbiAgICB9XG4gIH0pO1xuICB2YXIgYXhpc01pbkdhcHMgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIGF4aXNWYWx1ZXMpIHtcbiAgICBpZiAoYXhpc1ZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB2YXIgdmFsdWVzSW5BeGlzID0gYXhpc1ZhbHVlc1trZXldO1xuICAgICAgaWYgKHZhbHVlc0luQXhpcykge1xuICAgICAgICAvLyBTb3J0IGF4aXMgdmFsdWVzIGludG8gYXNjZW5kaW5nIG9yZGVyIHRvIGNhbGN1bGF0ZSBnYXBzXG4gICAgICAgIHZhbHVlc0luQXhpcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgdmFsdWVzSW5BeGlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgdmFyIGRlbHRhID0gdmFsdWVzSW5BeGlzW2pdIC0gdmFsdWVzSW5BeGlzW2ogLSAxXTtcbiAgICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgMCBkZWx0YSBiZWNhdXNlIHRoZXkgYXJlIG9mIHRoZSBzYW1lIGF4aXMgdmFsdWVcbiAgICAgICAgICAgIG1pbiA9IG1pbiA9PT0gbnVsbCA/IGRlbHRhIDogTWF0aC5taW4obWluLCBkZWx0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0byBudWxsIGlmIG9ubHkgaGF2ZSBvbmUgZGF0YVxuICAgICAgICBheGlzTWluR2Fwc1trZXldID0gbWluO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXhpc01pbkdhcHM7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZUNvbHVtbkxheW91dChiYXJTZXJpZXMpIHtcbiAgdmFyIGF4aXNNaW5HYXBzID0gZ2V0VmFsdWVBeGVzTWluR2FwcyhiYXJTZXJpZXMpO1xuICB2YXIgc2VyaWVzSW5mb0xpc3QgPSBbXTtcbiAgZWFjaChiYXJTZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBiYXNlQXhpcyA9IGNhcnRlc2lhbi5nZXRCYXNlQXhpcygpO1xuICAgIHZhciBheGlzRXh0ZW50ID0gYmFzZUF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIGJhbmRXaWR0aDtcbiAgICBpZiAoYmFzZUF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgYmFuZFdpZHRoID0gYmFzZUF4aXMuZ2V0QmFuZFdpZHRoKCk7XG4gICAgfSBlbHNlIGlmIChiYXNlQXhpcy50eXBlID09PSAndmFsdWUnIHx8IGJhc2VBeGlzLnR5cGUgPT09ICd0aW1lJykge1xuICAgICAgdmFyIGtleSA9IGJhc2VBeGlzLmRpbSArICdfJyArIGJhc2VBeGlzLmluZGV4O1xuICAgICAgdmFyIG1pbkdhcCA9IGF4aXNNaW5HYXBzW2tleV07XG4gICAgICB2YXIgZXh0ZW50U3BhbiA9IE1hdGguYWJzKGF4aXNFeHRlbnRbMV0gLSBheGlzRXh0ZW50WzBdKTtcbiAgICAgIHZhciBzY2FsZSA9IGJhc2VBeGlzLnNjYWxlLmdldEV4dGVudCgpO1xuICAgICAgdmFyIHNjYWxlU3BhbiA9IE1hdGguYWJzKHNjYWxlWzFdIC0gc2NhbGVbMF0pO1xuICAgICAgYmFuZFdpZHRoID0gbWluR2FwID8gZXh0ZW50U3BhbiAvIHNjYWxlU3BhbiAqIG1pbkdhcCA6IGV4dGVudFNwYW47IC8vIFdoZW4gdGhlcmUgaXMgb25seSBvbmUgZGF0YSB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgIGJhbmRXaWR0aCA9IE1hdGguYWJzKGF4aXNFeHRlbnRbMV0gLSBheGlzRXh0ZW50WzBdKSAvIGRhdGEuY291bnQoKTtcbiAgICB9XG4gICAgdmFyIGJhcldpZHRoID0gcGFyc2VQZXJjZW50KHNlcmllc01vZGVsLmdldCgnYmFyV2lkdGgnKSwgYmFuZFdpZHRoKTtcbiAgICB2YXIgYmFyTWF4V2lkdGggPSBwYXJzZVBlcmNlbnQoc2VyaWVzTW9kZWwuZ2V0KCdiYXJNYXhXaWR0aCcpLCBiYW5kV2lkdGgpO1xuICAgIHZhciBiYXJNaW5XaWR0aCA9IHBhcnNlUGVyY2VudChcbiAgICAvLyBiYXJNaW5XaWR0aCBieSBkZWZhdWx0IGlzIDAuNSAvIDEgaW4gY2FydGVzaWFuLiBCZWNhdXNlIGluIHZhbHVlIGF4aXMsXG4gICAgLy8gdGhlIGF1dG8tY2FsY3VsYXRlZCBiYXIgd2lkdGggbWlnaHQgYmUgbGVzcyB0aGFuIDAuNSAvIDEuXG4gICAgc2VyaWVzTW9kZWwuZ2V0KCdiYXJNaW5XaWR0aCcpIHx8IChpc0luTGFyZ2VNb2RlKHNlcmllc01vZGVsKSA/IDAuNSA6IDEpLCBiYW5kV2lkdGgpO1xuICAgIHZhciBiYXJHYXAgPSBzZXJpZXNNb2RlbC5nZXQoJ2JhckdhcCcpO1xuICAgIHZhciBiYXJDYXRlZ29yeUdhcCA9IHNlcmllc01vZGVsLmdldCgnYmFyQ2F0ZWdvcnlHYXAnKTtcbiAgICBzZXJpZXNJbmZvTGlzdC5wdXNoKHtcbiAgICAgIGJhbmRXaWR0aDogYmFuZFdpZHRoLFxuICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgYmFyTWF4V2lkdGg6IGJhck1heFdpZHRoLFxuICAgICAgYmFyTWluV2lkdGg6IGJhck1pbldpZHRoLFxuICAgICAgYmFyR2FwOiBiYXJHYXAsXG4gICAgICBiYXJDYXRlZ29yeUdhcDogYmFyQ2F0ZWdvcnlHYXAsXG4gICAgICBheGlzS2V5OiBnZXRBeGlzS2V5KGJhc2VBeGlzKSxcbiAgICAgIHN0YWNrSWQ6IGdldFNlcmllc1N0YWNrSWQoc2VyaWVzTW9kZWwpXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZG9DYWxCYXJXaWR0aEFuZE9mZnNldChzZXJpZXNJbmZvTGlzdCk7XG59XG5mdW5jdGlvbiBkb0NhbEJhcldpZHRoQW5kT2Zmc2V0KHNlcmllc0luZm9MaXN0KSB7XG4gIC8vIENvbHVtbnMgaW5mbyBvbiBlYWNoIGNhdGVnb3J5IGF4aXMuIEtleSBpcyBjYXJ0ZXNpYW4gbmFtZVxuICB2YXIgY29sdW1uc01hcCA9IHt9O1xuICBlYWNoKHNlcmllc0luZm9MaXN0LCBmdW5jdGlvbiAoc2VyaWVzSW5mbywgaWR4KSB7XG4gICAgdmFyIGF4aXNLZXkgPSBzZXJpZXNJbmZvLmF4aXNLZXk7XG4gICAgdmFyIGJhbmRXaWR0aCA9IHNlcmllc0luZm8uYmFuZFdpZHRoO1xuICAgIHZhciBjb2x1bW5zT25BeGlzID0gY29sdW1uc01hcFtheGlzS2V5XSB8fCB7XG4gICAgICBiYW5kV2lkdGg6IGJhbmRXaWR0aCxcbiAgICAgIHJlbWFpbmVkV2lkdGg6IGJhbmRXaWR0aCxcbiAgICAgIGF1dG9XaWR0aENvdW50OiAwLFxuICAgICAgY2F0ZWdvcnlHYXA6IG51bGwsXG4gICAgICBnYXA6ICcyMCUnLFxuICAgICAgc3RhY2tzOiB7fVxuICAgIH07XG4gICAgdmFyIHN0YWNrcyA9IGNvbHVtbnNPbkF4aXMuc3RhY2tzO1xuICAgIGNvbHVtbnNNYXBbYXhpc0tleV0gPSBjb2x1bW5zT25BeGlzO1xuICAgIHZhciBzdGFja0lkID0gc2VyaWVzSW5mby5zdGFja0lkO1xuICAgIGlmICghc3RhY2tzW3N0YWNrSWRdKSB7XG4gICAgICBjb2x1bW5zT25BeGlzLmF1dG9XaWR0aENvdW50Kys7XG4gICAgfVxuICAgIHN0YWNrc1tzdGFja0lkXSA9IHN0YWNrc1tzdGFja0lkXSB8fCB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIG1heFdpZHRoOiAwXG4gICAgfTtcbiAgICAvLyBDYXV0aW9uOiBJbiBhIHNpbmdsZSBjb29yZGluYXRlIHN5c3RlbSwgdGhlc2UgYmFyR3JpZCBhdHRyaWJ1dGVzXG4gICAgLy8gd2lsbCBiZSBzaGFyZWQgYnkgc2VyaWVzLiBDb25zaWRlciB0aGF0IHRoZXkgaGF2ZSBkZWZhdWx0IHZhbHVlcyxcbiAgICAvLyBvbmx5IHRoZSBhdHRyaWJ1dGVzIHNldCBvbiB0aGUgbGFzdCBzZXJpZXMgd2lsbCB3b3JrLlxuICAgIC8vIERvIG5vdCBjaGFuZ2UgdGhpcyBmYWN0IHVubGVzcyB0aGVyZSB3aWxsIGJlIGEgYnJlYWsgY2hhbmdlLlxuICAgIHZhciBiYXJXaWR0aCA9IHNlcmllc0luZm8uYmFyV2lkdGg7XG4gICAgaWYgKGJhcldpZHRoICYmICFzdGFja3Nbc3RhY2tJZF0ud2lkdGgpIHtcbiAgICAgIC8vIFNlZSAjNjMxMiwgZG8gbm90IHJlc3RyaWN0IHdpZHRoLlxuICAgICAgc3RhY2tzW3N0YWNrSWRdLndpZHRoID0gYmFyV2lkdGg7XG4gICAgICBiYXJXaWR0aCA9IE1hdGgubWluKGNvbHVtbnNPbkF4aXMucmVtYWluZWRXaWR0aCwgYmFyV2lkdGgpO1xuICAgICAgY29sdW1uc09uQXhpcy5yZW1haW5lZFdpZHRoIC09IGJhcldpZHRoO1xuICAgIH1cbiAgICB2YXIgYmFyTWF4V2lkdGggPSBzZXJpZXNJbmZvLmJhck1heFdpZHRoO1xuICAgIGJhck1heFdpZHRoICYmIChzdGFja3Nbc3RhY2tJZF0ubWF4V2lkdGggPSBiYXJNYXhXaWR0aCk7XG4gICAgdmFyIGJhck1pbldpZHRoID0gc2VyaWVzSW5mby5iYXJNaW5XaWR0aDtcbiAgICBiYXJNaW5XaWR0aCAmJiAoc3RhY2tzW3N0YWNrSWRdLm1pbldpZHRoID0gYmFyTWluV2lkdGgpO1xuICAgIHZhciBiYXJHYXAgPSBzZXJpZXNJbmZvLmJhckdhcDtcbiAgICBiYXJHYXAgIT0gbnVsbCAmJiAoY29sdW1uc09uQXhpcy5nYXAgPSBiYXJHYXApO1xuICAgIHZhciBiYXJDYXRlZ29yeUdhcCA9IHNlcmllc0luZm8uYmFyQ2F0ZWdvcnlHYXA7XG4gICAgYmFyQ2F0ZWdvcnlHYXAgIT0gbnVsbCAmJiAoY29sdW1uc09uQXhpcy5jYXRlZ29yeUdhcCA9IGJhckNhdGVnb3J5R2FwKTtcbiAgfSk7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZWFjaChjb2x1bW5zTWFwLCBmdW5jdGlvbiAoY29sdW1uc09uQXhpcywgY29vcmRTeXNOYW1lKSB7XG4gICAgcmVzdWx0W2Nvb3JkU3lzTmFtZV0gPSB7fTtcbiAgICB2YXIgc3RhY2tzID0gY29sdW1uc09uQXhpcy5zdGFja3M7XG4gICAgdmFyIGJhbmRXaWR0aCA9IGNvbHVtbnNPbkF4aXMuYmFuZFdpZHRoO1xuICAgIHZhciBjYXRlZ29yeUdhcFBlcmNlbnQgPSBjb2x1bW5zT25BeGlzLmNhdGVnb3J5R2FwO1xuICAgIGlmIChjYXRlZ29yeUdhcFBlcmNlbnQgPT0gbnVsbCkge1xuICAgICAgdmFyIGNvbHVtbkNvdW50ID0ga2V5cyhzdGFja3MpLmxlbmd0aDtcbiAgICAgIC8vIE1vcmUgY29sdW1ucyBpbiBvbmUgZ3JvdXBcbiAgICAgIC8vIHRoZSBzcGFjZXMgYmV0d2VlbiBncm91cCBpcyBzbWFsbGVyLiBPciB0aGUgY29sdW1uIHdpbGwgYmUgdG9vIHRoaW4uXG4gICAgICBjYXRlZ29yeUdhcFBlcmNlbnQgPSBNYXRoLm1heCgzNSAtIGNvbHVtbkNvdW50ICogNCwgMTUpICsgJyUnO1xuICAgIH1cbiAgICB2YXIgY2F0ZWdvcnlHYXAgPSBwYXJzZVBlcmNlbnQoY2F0ZWdvcnlHYXBQZXJjZW50LCBiYW5kV2lkdGgpO1xuICAgIHZhciBiYXJHYXBQZXJjZW50ID0gcGFyc2VQZXJjZW50KGNvbHVtbnNPbkF4aXMuZ2FwLCAxKTtcbiAgICB2YXIgcmVtYWluZWRXaWR0aCA9IGNvbHVtbnNPbkF4aXMucmVtYWluZWRXaWR0aDtcbiAgICB2YXIgYXV0b1dpZHRoQ291bnQgPSBjb2x1bW5zT25BeGlzLmF1dG9XaWR0aENvdW50O1xuICAgIHZhciBhdXRvV2lkdGggPSAocmVtYWluZWRXaWR0aCAtIGNhdGVnb3J5R2FwKSAvIChhdXRvV2lkdGhDb3VudCArIChhdXRvV2lkdGhDb3VudCAtIDEpICogYmFyR2FwUGVyY2VudCk7XG4gICAgYXV0b1dpZHRoID0gTWF0aC5tYXgoYXV0b1dpZHRoLCAwKTtcbiAgICAvLyBGaW5kIGlmIGFueSBhdXRvIGNhbGN1bGF0ZWQgYmFyIGV4Y2VlZGVkIG1heEJhcldpZHRoXG4gICAgZWFjaChzdGFja3MsIGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgIHZhciBtYXhXaWR0aCA9IGNvbHVtbi5tYXhXaWR0aDtcbiAgICAgIHZhciBtaW5XaWR0aCA9IGNvbHVtbi5taW5XaWR0aDtcbiAgICAgIGlmICghY29sdW1uLndpZHRoKSB7XG4gICAgICAgIHZhciBmaW5hbFdpZHRoID0gYXV0b1dpZHRoO1xuICAgICAgICBpZiAobWF4V2lkdGggJiYgbWF4V2lkdGggPCBmaW5hbFdpZHRoKSB7XG4gICAgICAgICAgZmluYWxXaWR0aCA9IE1hdGgubWluKG1heFdpZHRoLCByZW1haW5lZFdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBgbWluV2lkdGhgIGhhcyBoaWdoZXIgcHJpb3JpdHkuIGBtaW5XaWR0aGAgZGVjaWRlIHRoYXQgd2hldGhlciB0aGVcbiAgICAgICAgLy8gYmFyIGlzIGFibGUgdG8gYmUgdmlzaWJsZS4gU28gYG1pbldpZHRoYCBzaG91bGQgbm90IGJlIHJlc3RyaWN0ZWRcbiAgICAgICAgLy8gYnkgYG1heFdpZHRoYCBvciBgcmVtYWluZWRXaWR0aGAgKHdoaWNoIGlzIGZyb20gYGJhbmRXaWR0aGApLiBJblxuICAgICAgICAvLyB0aGUgZXh0cmVtZSBjYXNlcyBmb3IgYHZhbHVlYCBheGlzLCBiYXJzIGFyZSBhbGxvd2VkIHRvIG92ZXJsYXBcbiAgICAgICAgLy8gd2l0aCBlYWNoIG90aGVyIGlmIGBtaW5XaWR0aGAgc3BlY2lmaWVkLlxuICAgICAgICBpZiAobWluV2lkdGggJiYgbWluV2lkdGggPiBmaW5hbFdpZHRoKSB7XG4gICAgICAgICAgZmluYWxXaWR0aCA9IG1pbldpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbFdpZHRoICE9PSBhdXRvV2lkdGgpIHtcbiAgICAgICAgICBjb2x1bW4ud2lkdGggPSBmaW5hbFdpZHRoO1xuICAgICAgICAgIHJlbWFpbmVkV2lkdGggLT0gZmluYWxXaWR0aCArIGJhckdhcFBlcmNlbnQgKiBmaW5hbFdpZHRoO1xuICAgICAgICAgIGF1dG9XaWR0aENvdW50LS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGBiYXJNaW5XaWR0aC9iYXJNYXhXaWR0aGAgaGFzIGhpZ2hlciBwcmlvcml0eSB0aGFuIGBiYXJXaWR0aGAsIGFzXG4gICAgICAgIC8vIENTUyBkb2VzLiBCZWNhdXNlIGJhcldpZHRoIGNhbiBiZSBhIHBlcmNlbnQgdmFsdWUsIHdoZXJlXG4gICAgICAgIC8vIGBiYXJNYXhXaWR0aGAgY2FuIGJlIHVzZWQgdG8gcmVzdHJpY3QgdGhlIGZpbmFsIHdpZHRoLlxuICAgICAgICB2YXIgZmluYWxXaWR0aCA9IGNvbHVtbi53aWR0aDtcbiAgICAgICAgaWYgKG1heFdpZHRoKSB7XG4gICAgICAgICAgZmluYWxXaWR0aCA9IE1hdGgubWluKGZpbmFsV2lkdGgsIG1heFdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBgbWluV2lkdGhgIGhhcyBoaWdoZXIgcHJpb3JpdHksIGFzIGRlc2NyaWJlZCBhYm92ZVxuICAgICAgICBpZiAobWluV2lkdGgpIHtcbiAgICAgICAgICBmaW5hbFdpZHRoID0gTWF0aC5tYXgoZmluYWxXaWR0aCwgbWluV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbHVtbi53aWR0aCA9IGZpbmFsV2lkdGg7XG4gICAgICAgIHJlbWFpbmVkV2lkdGggLT0gZmluYWxXaWR0aCArIGJhckdhcFBlcmNlbnQgKiBmaW5hbFdpZHRoO1xuICAgICAgICBhdXRvV2lkdGhDb3VudC0tO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFJlY2FsY3VsYXRlIHdpZHRoIGFnYWluXG4gICAgYXV0b1dpZHRoID0gKHJlbWFpbmVkV2lkdGggLSBjYXRlZ29yeUdhcCkgLyAoYXV0b1dpZHRoQ291bnQgKyAoYXV0b1dpZHRoQ291bnQgLSAxKSAqIGJhckdhcFBlcmNlbnQpO1xuICAgIGF1dG9XaWR0aCA9IE1hdGgubWF4KGF1dG9XaWR0aCwgMCk7XG4gICAgdmFyIHdpZHRoU3VtID0gMDtcbiAgICB2YXIgbGFzdENvbHVtbjtcbiAgICBlYWNoKHN0YWNrcywgZnVuY3Rpb24gKGNvbHVtbiwgaWR4KSB7XG4gICAgICBpZiAoIWNvbHVtbi53aWR0aCkge1xuICAgICAgICBjb2x1bW4ud2lkdGggPSBhdXRvV2lkdGg7XG4gICAgICB9XG4gICAgICBsYXN0Q29sdW1uID0gY29sdW1uO1xuICAgICAgd2lkdGhTdW0gKz0gY29sdW1uLndpZHRoICogKDEgKyBiYXJHYXBQZXJjZW50KTtcbiAgICB9KTtcbiAgICBpZiAobGFzdENvbHVtbikge1xuICAgICAgd2lkdGhTdW0gLT0gbGFzdENvbHVtbi53aWR0aCAqIGJhckdhcFBlcmNlbnQ7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSAtd2lkdGhTdW0gLyAyO1xuICAgIGVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBzdGFja0lkKSB7XG4gICAgICByZXN1bHRbY29vcmRTeXNOYW1lXVtzdGFja0lkXSA9IHJlc3VsdFtjb29yZFN5c05hbWVdW3N0YWNrSWRdIHx8IHtcbiAgICAgICAgYmFuZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICB3aWR0aDogY29sdW1uLndpZHRoXG4gICAgICB9O1xuICAgICAgb2Zmc2V0ICs9IGNvbHVtbi53aWR0aCAqICgxICsgYmFyR2FwUGVyY2VudCk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmV0cmlldmVDb2x1bW5MYXlvdXQoYmFyV2lkdGhBbmRPZmZzZXQsIGF4aXMsIHNlcmllc01vZGVsKSB7XG4gIGlmIChiYXJXaWR0aEFuZE9mZnNldCAmJiBheGlzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhcldpZHRoQW5kT2Zmc2V0W2dldEF4aXNLZXkoYXhpcyldO1xuICAgIGlmIChyZXN1bHQgIT0gbnVsbCAmJiBzZXJpZXNNb2RlbCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzdWx0W2dldFNlcmllc1N0YWNrSWQoc2VyaWVzTW9kZWwpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuZXhwb3J0IHsgcmV0cmlldmVDb2x1bW5MYXlvdXQgfTtcbmV4cG9ydCBmdW5jdGlvbiBsYXlvdXQoc2VyaWVzVHlwZSwgZWNNb2RlbCkge1xuICB2YXIgc2VyaWVzTW9kZWxzID0gcHJlcGFyZUxheW91dEJhclNlcmllcyhzZXJpZXNUeXBlLCBlY01vZGVsKTtcbiAgdmFyIGJhcldpZHRoQW5kT2Zmc2V0ID0gbWFrZUNvbHVtbkxheW91dChzZXJpZXNNb2RlbHMpO1xuICBlYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGNhcnRlc2lhbiA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgdmFyIHN0YWNrSWQgPSBnZXRTZXJpZXNTdGFja0lkKHNlcmllc01vZGVsKTtcbiAgICB2YXIgY29sdW1uTGF5b3V0SW5mbyA9IGJhcldpZHRoQW5kT2Zmc2V0W2dldEF4aXNLZXkoYmFzZUF4aXMpXVtzdGFja0lkXTtcbiAgICB2YXIgY29sdW1uT2Zmc2V0ID0gY29sdW1uTGF5b3V0SW5mby5vZmZzZXQ7XG4gICAgdmFyIGNvbHVtbldpZHRoID0gY29sdW1uTGF5b3V0SW5mby53aWR0aDtcbiAgICBkYXRhLnNldExheW91dCh7XG4gICAgICBiYW5kV2lkdGg6IGNvbHVtbkxheW91dEluZm8uYmFuZFdpZHRoLFxuICAgICAgb2Zmc2V0OiBjb2x1bW5PZmZzZXQsXG4gICAgICBzaXplOiBjb2x1bW5XaWR0aFxuICAgIH0pO1xuICB9KTtcbn1cbi8vIFRPRE86IERvIG5vdCBzdXBwb3J0IHN0YWNrIGluIGxhcmdlIG1vZGUgeWV0LlxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByb2dyZXNzaXZlTGF5b3V0KHNlcmllc1R5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICBzZXJpZXNUeXBlOiBzZXJpZXNUeXBlLFxuICAgIHBsYW46IGNyZWF0ZVJlbmRlclBsYW5uZXIoKSxcbiAgICByZXNldDogZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICBpZiAoIWlzT25DYXJ0ZXNpYW4oc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgdmFyIGNhcnRlc2lhbiA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICB2YXIgYmFzZUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKTtcbiAgICAgIHZhciB2YWx1ZUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKTtcbiAgICAgIHZhciB2YWx1ZURpbUlkeCA9IGRhdGEuZ2V0RGltZW5zaW9uSW5kZXgoZGF0YS5tYXBEaW1lbnNpb24odmFsdWVBeGlzLmRpbSkpO1xuICAgICAgdmFyIGJhc2VEaW1JZHggPSBkYXRhLmdldERpbWVuc2lvbkluZGV4KGRhdGEubWFwRGltZW5zaW9uKGJhc2VBeGlzLmRpbSkpO1xuICAgICAgdmFyIGRyYXdCYWNrZ3JvdW5kID0gc2VyaWVzTW9kZWwuZ2V0KCdzaG93QmFja2dyb3VuZCcsIHRydWUpO1xuICAgICAgdmFyIHZhbHVlRGltID0gZGF0YS5tYXBEaW1lbnNpb24odmFsdWVBeGlzLmRpbSk7XG4gICAgICB2YXIgc3RhY2tSZXN1bHREaW0gPSBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tSZXN1bHREaW1lbnNpb24nKTtcbiAgICAgIHZhciBzdGFja2VkID0gaXNEaW1lbnNpb25TdGFja2VkKGRhdGEsIHZhbHVlRGltKSAmJiAhIWRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja2VkT25TZXJpZXMnKTtcbiAgICAgIHZhciBpc1ZhbHVlQXhpc0ggPSB2YWx1ZUF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgICB2YXIgdmFsdWVBeGlzU3RhcnQgPSBnZXRWYWx1ZUF4aXNTdGFydChiYXNlQXhpcywgdmFsdWVBeGlzKTtcbiAgICAgIHZhciBpc0xhcmdlID0gaXNJbkxhcmdlTW9kZShzZXJpZXNNb2RlbCk7XG4gICAgICB2YXIgYmFyTWluSGVpZ2h0ID0gc2VyaWVzTW9kZWwuZ2V0KCdiYXJNaW5IZWlnaHQnKSB8fCAwO1xuICAgICAgdmFyIHN0YWNrZWREaW1JZHggPSBzdGFja1Jlc3VsdERpbSAmJiBkYXRhLmdldERpbWVuc2lvbkluZGV4KHN0YWNrUmVzdWx0RGltKTtcbiAgICAgIC8vIExheW91dCBpbmZvLlxuICAgICAgdmFyIGNvbHVtbldpZHRoID0gZGF0YS5nZXRMYXlvdXQoJ3NpemUnKTtcbiAgICAgIHZhciBjb2x1bW5PZmZzZXQgPSBkYXRhLmdldExheW91dCgnb2Zmc2V0Jyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmVzczogZnVuY3Rpb24gKHBhcmFtcywgZGF0YSkge1xuICAgICAgICAgIHZhciBjb3VudCA9IHBhcmFtcy5jb3VudDtcbiAgICAgICAgICB2YXIgbGFyZ2VQb2ludHMgPSBpc0xhcmdlICYmIGNyZWF0ZUZsb2F0MzJBcnJheShjb3VudCAqIDMpO1xuICAgICAgICAgIHZhciBsYXJnZUJhY2tncm91bmRQb2ludHMgPSBpc0xhcmdlICYmIGRyYXdCYWNrZ3JvdW5kICYmIGNyZWF0ZUZsb2F0MzJBcnJheShjb3VudCAqIDMpO1xuICAgICAgICAgIHZhciBsYXJnZURhdGFJbmRpY2VzID0gaXNMYXJnZSAmJiBjcmVhdGVGbG9hdDMyQXJyYXkoY291bnQpO1xuICAgICAgICAgIHZhciBjb29yZExheW91dCA9IGNhcnRlc2lhbi5tYXN0ZXIuZ2V0UmVjdCgpO1xuICAgICAgICAgIHZhciBiZ1NpemUgPSBpc1ZhbHVlQXhpc0ggPyBjb29yZExheW91dC53aWR0aCA6IGNvb3JkTGF5b3V0LmhlaWdodDtcbiAgICAgICAgICB2YXIgZGF0YUluZGV4O1xuICAgICAgICAgIHZhciBzdG9yZSA9IGRhdGEuZ2V0U3RvcmUoKTtcbiAgICAgICAgICB2YXIgaWR4T2Zmc2V0ID0gMDtcbiAgICAgICAgICB3aGlsZSAoKGRhdGFJbmRleCA9IHBhcmFtcy5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0b3JlLmdldChzdGFja2VkID8gc3RhY2tlZERpbUlkeCA6IHZhbHVlRGltSWR4LCBkYXRhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIGJhc2VWYWx1ZSA9IHN0b3JlLmdldChiYXNlRGltSWR4LCBkYXRhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIGJhc2VDb29yZCA9IHZhbHVlQXhpc1N0YXJ0O1xuICAgICAgICAgICAgdmFyIHN0YWNrU3RhcnRWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugb2YgdGhlIGJhck1pbkhlaWdodCwgd2UgY2FuIG5vdCB1c2UgdGhlIHZhbHVlIGluXG4gICAgICAgICAgICAvLyBzdGFja1Jlc3VsdERpbWVuc2lvbiBkaXJlY3RseS5cbiAgICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICAgIHN0YWNrU3RhcnRWYWx1ZSA9ICt2YWx1ZSAtIHN0b3JlLmdldCh2YWx1ZURpbUlkeCwgZGF0YUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB4ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIHkgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGlzVmFsdWVBeGlzSCkge1xuICAgICAgICAgICAgICB2YXIgY29vcmQgPSBjYXJ0ZXNpYW4uZGF0YVRvUG9pbnQoW3ZhbHVlLCBiYXNlVmFsdWVdKTtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb29yZCA9IGNhcnRlc2lhbi5kYXRhVG9Qb2ludChbc3RhY2tTdGFydFZhbHVlLCBiYXNlVmFsdWVdKTtcbiAgICAgICAgICAgICAgICBiYXNlQ29vcmQgPSBzdGFydENvb3JkWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHggPSBiYXNlQ29vcmQ7XG4gICAgICAgICAgICAgIHkgPSBjb29yZFsxXSArIGNvbHVtbk9mZnNldDtcbiAgICAgICAgICAgICAgd2lkdGggPSBjb29yZFswXSAtIGJhc2VDb29yZDtcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gY29sdW1uV2lkdGg7XG4gICAgICAgICAgICAgIGlmIChNYXRoLmFicyh3aWR0aCkgPCBiYXJNaW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9ICh3aWR0aCA8IDAgPyAtMSA6IDEpICogYmFyTWluSGVpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgY29vcmQgPSBjYXJ0ZXNpYW4uZGF0YVRvUG9pbnQoW2Jhc2VWYWx1ZSwgdmFsdWVdKTtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb29yZCA9IGNhcnRlc2lhbi5kYXRhVG9Qb2ludChbYmFzZVZhbHVlLCBzdGFja1N0YXJ0VmFsdWVdKTtcbiAgICAgICAgICAgICAgICBiYXNlQ29vcmQgPSBzdGFydENvb3JkWzFdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHggPSBjb29yZFswXSArIGNvbHVtbk9mZnNldDtcbiAgICAgICAgICAgICAgeSA9IGJhc2VDb29yZDtcbiAgICAgICAgICAgICAgd2lkdGggPSBjb2x1bW5XaWR0aDtcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gY29vcmRbMV0gLSBiYXNlQ29vcmQ7XG4gICAgICAgICAgICAgIGlmIChNYXRoLmFicyhoZWlnaHQpIDwgYmFyTWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gSW5jbHVkZSB6ZXJvIHRvIGhhcyBhIHBvc2l0aXZlIGJhclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IChoZWlnaHQgPD0gMCA/IC0xIDogMSkgKiBiYXJNaW5IZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNMYXJnZSkge1xuICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoZGF0YUluZGV4LCB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxhcmdlUG9pbnRzW2lkeE9mZnNldF0gPSB4O1xuICAgICAgICAgICAgICBsYXJnZVBvaW50c1tpZHhPZmZzZXQgKyAxXSA9IHk7XG4gICAgICAgICAgICAgIGxhcmdlUG9pbnRzW2lkeE9mZnNldCArIDJdID0gaXNWYWx1ZUF4aXNIID8gd2lkdGggOiBoZWlnaHQ7XG4gICAgICAgICAgICAgIGlmIChsYXJnZUJhY2tncm91bmRQb2ludHMpIHtcbiAgICAgICAgICAgICAgICBsYXJnZUJhY2tncm91bmRQb2ludHNbaWR4T2Zmc2V0XSA9IGlzVmFsdWVBeGlzSCA/IGNvb3JkTGF5b3V0LnggOiB4O1xuICAgICAgICAgICAgICAgIGxhcmdlQmFja2dyb3VuZFBvaW50c1tpZHhPZmZzZXQgKyAxXSA9IGlzVmFsdWVBeGlzSCA/IHkgOiBjb29yZExheW91dC55O1xuICAgICAgICAgICAgICAgIGxhcmdlQmFja2dyb3VuZFBvaW50c1tpZHhPZmZzZXQgKyAyXSA9IGJnU2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXJnZURhdGFJbmRpY2VzW2RhdGFJbmRleF0gPSBkYXRhSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHhPZmZzZXQgKz0gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgICAgIGRhdGEuc2V0TGF5b3V0KHtcbiAgICAgICAgICAgICAgbGFyZ2VQb2ludHM6IGxhcmdlUG9pbnRzLFxuICAgICAgICAgICAgICBsYXJnZURhdGFJbmRpY2VzOiBsYXJnZURhdGFJbmRpY2VzLFxuICAgICAgICAgICAgICBsYXJnZUJhY2tncm91bmRQb2ludHM6IGxhcmdlQmFja2dyb3VuZFBvaW50cyxcbiAgICAgICAgICAgICAgdmFsdWVBeGlzSG9yaXpvbnRhbDogaXNWYWx1ZUF4aXNIXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNPbkNhcnRlc2lhbihzZXJpZXNNb2RlbCkge1xuICByZXR1cm4gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSAmJiBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCc7XG59XG5mdW5jdGlvbiBpc0luTGFyZ2VNb2RlKHNlcmllc01vZGVsKSB7XG4gIHJldHVybiBzZXJpZXNNb2RlbC5waXBlbGluZUNvbnRleHQgJiYgc2VyaWVzTW9kZWwucGlwZWxpbmVDb250ZXh0LmxhcmdlO1xufVxuLy8gU2VlIGNhc2VzIGluIGB0ZXN0L2Jhci1zdGFydC5odG1sYCBhbmQgYCM3NDEyYCwgYCM4NzQ3YC5cbmZ1bmN0aW9uIGdldFZhbHVlQXhpc1N0YXJ0KGJhc2VBeGlzLCB2YWx1ZUF4aXMpIHtcbiAgdmFyIHN0YXJ0VmFsdWUgPSB2YWx1ZUF4aXMubW9kZWwuZ2V0KCdzdGFydFZhbHVlJyk7XG4gIGlmICghc3RhcnRWYWx1ZSkge1xuICAgIHN0YXJ0VmFsdWUgPSAwO1xuICB9XG4gIHJldHVybiB2YWx1ZUF4aXMudG9HbG9iYWxDb29yZCh2YWx1ZUF4aXMuZGF0YVRvQ29vcmQodmFsdWVBeGlzLnR5cGUgPT09ICdsb2cnID8gc3RhcnRWYWx1ZSA+IDAgPyBzdGFydFZhbHVlIDogMSA6IHN0YXJ0VmFsdWUpKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///62536\n")},77175:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   If: () => (/* binding */ hideOverlap),\n/* harmony export */   QX: () => (/* binding */ shiftLayoutOnX),\n/* harmony export */   Xe: () => (/* binding */ shiftLayoutOnY),\n/* harmony export */   os: () => (/* binding */ prepareLayoutList)\n/* harmony export */ });\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84716);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29308);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nfunction prepareLayoutList(input) {\n  var list = [];\n  for (var i = 0; i < input.length; i++) {\n    var rawItem = input[i];\n    if (rawItem.defaultAttr.ignore) {\n      continue;\n    }\n    var label = rawItem.label;\n    var transform = label.getComputedTransform();\n    // NOTE: Get bounding rect after getComputedTransform, or label may not been updated by the host el.\n    var localRect = label.getBoundingRect();\n    var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;\n    var minMargin = label.style.margin || 0;\n    var globalRect = localRect.clone();\n    globalRect.applyTransform(transform);\n    globalRect.x -= minMargin / 2;\n    globalRect.y -= minMargin / 2;\n    globalRect.width += minMargin;\n    globalRect.height += minMargin;\n    var obb = isAxisAligned ? new _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A(localRect, transform) : null;\n    list.push({\n      label: label,\n      labelLine: rawItem.labelLine,\n      rect: globalRect,\n      localRect: localRect,\n      obb: obb,\n      priority: rawItem.priority,\n      defaultAttr: rawItem.defaultAttr,\n      layoutOption: rawItem.computedLayoutOption,\n      axisAligned: isAxisAligned,\n      transform: transform\n    });\n  }\n  return list;\n}\nfunction shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {\n  var len = list.length;\n  if (len < 2) {\n    return;\n  }\n  list.sort(function (a, b) {\n    return a.rect[xyDim] - b.rect[xyDim];\n  });\n  var lastPos = 0;\n  var delta;\n  var adjusted = false;\n  var shifts = [];\n  var totalShifts = 0;\n  for (var i = 0; i < len; i++) {\n    var item = list[i];\n    var rect = item.rect;\n    delta = rect[xyDim] - lastPos;\n    if (delta < 0) {\n      // shiftForward(i, len, -delta);\n      rect[xyDim] -= delta;\n      item.label[xyDim] -= delta;\n      adjusted = true;\n    }\n    var shift = Math.max(-delta, 0);\n    shifts.push(shift);\n    totalShifts += shift;\n    lastPos = rect[xyDim] + rect[sizeDim];\n  }\n  if (totalShifts > 0 && balanceShift) {\n    // Shift back to make the distribution more equally.\n    shiftList(-totalShifts / len, 0, len);\n  }\n  // TODO bleedMargin?\n  var first = list[0];\n  var last = list[len - 1];\n  var minGap;\n  var maxGap;\n  updateMinMaxGap();\n  // If ends exceed two bounds, squeeze at most 80%, then take the gap of two bounds.\n  minGap < 0 && squeezeGaps(-minGap, 0.8);\n  maxGap < 0 && squeezeGaps(maxGap, 0.8);\n  updateMinMaxGap();\n  takeBoundsGap(minGap, maxGap, 1);\n  takeBoundsGap(maxGap, minGap, -1);\n  // Handle bailout when there is not enough space.\n  updateMinMaxGap();\n  if (minGap < 0) {\n    squeezeWhenBailout(-minGap);\n  }\n  if (maxGap < 0) {\n    squeezeWhenBailout(maxGap);\n  }\n  function updateMinMaxGap() {\n    minGap = first.rect[xyDim] - minBound;\n    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];\n  }\n  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {\n    if (gapThisBound < 0) {\n      // Move from other gap if can.\n      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);\n      if (moveFromMaxGap > 0) {\n        shiftList(moveFromMaxGap * moveDir, 0, len);\n        var remained = moveFromMaxGap + gapThisBound;\n        if (remained < 0) {\n          squeezeGaps(-remained * moveDir, 1);\n        }\n      } else {\n        squeezeGaps(-gapThisBound * moveDir, 1);\n      }\n    }\n  }\n  function shiftList(delta, start, end) {\n    if (delta !== 0) {\n      adjusted = true;\n    }\n    for (var i = start; i < end; i++) {\n      var item = list[i];\n      var rect = item.rect;\n      rect[xyDim] += delta;\n      item.label[xyDim] += delta;\n    }\n  }\n  // Squeeze gaps if the labels exceed margin.\n  function squeezeGaps(delta, maxSqeezePercent) {\n    var gaps = [];\n    var totalGaps = 0;\n    for (var i = 1; i < len; i++) {\n      var prevItemRect = list[i - 1].rect;\n      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);\n      gaps.push(gap);\n      totalGaps += gap;\n    }\n    if (!totalGaps) {\n      return;\n    }\n    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);\n    if (delta > 0) {\n      for (var i = 0; i < len - 1; i++) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i] * squeezePercent;\n        // Forward\n        shiftList(movement, 0, i + 1);\n      }\n    } else {\n      // Backward\n      for (var i = len - 1; i > 0; i--) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i - 1] * squeezePercent;\n        shiftList(-movement, i, len);\n      }\n    }\n  }\n  /**\r\n   * Squeeze to allow overlap if there is no more space available.\r\n   * Let other overlapping strategy like hideOverlap do the job instead of keep exceeding the bounds.\r\n   */\n  function squeezeWhenBailout(delta) {\n    var dir = delta < 0 ? -1 : 1;\n    delta = Math.abs(delta);\n    var moveForEachLabel = Math.ceil(delta / (len - 1));\n    for (var i = 0; i < len - 1; i++) {\n      if (dir > 0) {\n        // Forward\n        shiftList(moveForEachLabel, 0, i + 1);\n      } else {\n        // Backward\n        shiftList(-moveForEachLabel, len - i - 1, len);\n      }\n      delta -= moveForEachLabel;\n      if (delta <= 0) {\n        return;\n      }\n    }\n  }\n  return adjusted;\n}\n/**\r\n * Adjust labels on x direction to avoid overlap.\r\n */\nfunction shiftLayoutOnX(list, leftBound, rightBound,\n// If average the shifts on all labels and add them to 0\n// TODO: Not sure if should enable it.\n// Pros: The angle of lines will distribute more equally\n// Cons: In some layout. It may not what user wanted. like in pie. the label of last sector is usually changed unexpectedly.\nbalanceShift) {\n  return shiftLayout(list, \'x\', \'width\', leftBound, rightBound, balanceShift);\n}\n/**\r\n * Adjust labels on y direction to avoid overlap.\r\n */\nfunction shiftLayoutOnY(list, topBound, bottomBound,\n// If average the shifts on all labels and add them to 0\nbalanceShift) {\n  return shiftLayout(list, \'y\', \'height\', topBound, bottomBound, balanceShift);\n}\nfunction hideOverlap(labelList) {\n  var displayedLabels = [];\n  // TODO, render overflow visible first, put in the displayedLabels.\n  labelList.sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n  var globalRect = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A(0, 0, 0, 0);\n  function hideEl(el) {\n    if (!el.ignore) {\n      // Show on emphasis.\n      var emphasisState = el.ensureState(\'emphasis\');\n      if (emphasisState.ignore == null) {\n        emphasisState.ignore = false;\n      }\n    }\n    el.ignore = true;\n  }\n  for (var i = 0; i < labelList.length; i++) {\n    var labelItem = labelList[i];\n    var isAxisAligned = labelItem.axisAligned;\n    var localRect = labelItem.localRect;\n    var transform = labelItem.transform;\n    var label = labelItem.label;\n    var labelLine = labelItem.labelLine;\n    globalRect.copy(labelItem.rect);\n    // Add a threshold because layout may be aligned precisely.\n    globalRect.width -= 0.1;\n    globalRect.height -= 0.1;\n    globalRect.x += 0.05;\n    globalRect.y += 0.05;\n    var obb = labelItem.obb;\n    var overlapped = false;\n    for (var j = 0; j < displayedLabels.length; j++) {\n      var existsTextCfg = displayedLabels[j];\n      // Fast rejection.\n      if (!globalRect.intersect(existsTextCfg.rect)) {\n        continue;\n      }\n      if (isAxisAligned && existsTextCfg.axisAligned) {\n        // Is overlapped\n        overlapped = true;\n        break;\n      }\n      if (!existsTextCfg.obb) {\n        // If self is not axis aligned. But other is.\n        existsTextCfg.obb = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A(existsTextCfg.localRect, existsTextCfg.transform);\n      }\n      if (!obb) {\n        // If self is axis aligned. But other is not.\n        obb = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A(localRect, transform);\n      }\n      if (obb.intersect(existsTextCfg.obb)) {\n        overlapped = true;\n        break;\n      }\n    }\n    // TODO Callback to determine if this overlap should be handled?\n    if (overlapped) {\n      hideEl(label);\n      labelLine && hideEl(labelLine);\n    } else {\n      label.attr(\'ignore\', labelItem.defaultAttr.ignore);\n      labelLine && labelLine.attr(\'ignore\', labelItem.defaultAttr.labelGuideIgnore);\n      displayedLabels.push(labelItem);\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzcxNzUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYWJlbC9sYWJlbExheW91dEhlbHBlci5qcz9mNGE5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgQm91bmRpbmdSZWN0LCBPcmllbnRlZEJvdW5kaW5nUmVjdCB9IGZyb20gJy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZUxheW91dExpc3QoaW5wdXQpIHtcbiAgdmFyIGxpc3QgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIHZhciByYXdJdGVtID0gaW5wdXRbaV07XG4gICAgaWYgKHJhd0l0ZW0uZGVmYXVsdEF0dHIuaWdub3JlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGxhYmVsID0gcmF3SXRlbS5sYWJlbDtcbiAgICB2YXIgdHJhbnNmb3JtID0gbGFiZWwuZ2V0Q29tcHV0ZWRUcmFuc2Zvcm0oKTtcbiAgICAvLyBOT1RFOiBHZXQgYm91bmRpbmcgcmVjdCBhZnRlciBnZXRDb21wdXRlZFRyYW5zZm9ybSwgb3IgbGFiZWwgbWF5IG5vdCBiZWVuIHVwZGF0ZWQgYnkgdGhlIGhvc3QgZWwuXG4gICAgdmFyIGxvY2FsUmVjdCA9IGxhYmVsLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBpc0F4aXNBbGlnbmVkID0gIXRyYW5zZm9ybSB8fCB0cmFuc2Zvcm1bMV0gPCAxZS01ICYmIHRyYW5zZm9ybVsyXSA8IDFlLTU7XG4gICAgdmFyIG1pbk1hcmdpbiA9IGxhYmVsLnN0eWxlLm1hcmdpbiB8fCAwO1xuICAgIHZhciBnbG9iYWxSZWN0ID0gbG9jYWxSZWN0LmNsb25lKCk7XG4gICAgZ2xvYmFsUmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgIGdsb2JhbFJlY3QueCAtPSBtaW5NYXJnaW4gLyAyO1xuICAgIGdsb2JhbFJlY3QueSAtPSBtaW5NYXJnaW4gLyAyO1xuICAgIGdsb2JhbFJlY3Qud2lkdGggKz0gbWluTWFyZ2luO1xuICAgIGdsb2JhbFJlY3QuaGVpZ2h0ICs9IG1pbk1hcmdpbjtcbiAgICB2YXIgb2JiID0gaXNBeGlzQWxpZ25lZCA/IG5ldyBPcmllbnRlZEJvdW5kaW5nUmVjdChsb2NhbFJlY3QsIHRyYW5zZm9ybSkgOiBudWxsO1xuICAgIGxpc3QucHVzaCh7XG4gICAgICBsYWJlbDogbGFiZWwsXG4gICAgICBsYWJlbExpbmU6IHJhd0l0ZW0ubGFiZWxMaW5lLFxuICAgICAgcmVjdDogZ2xvYmFsUmVjdCxcbiAgICAgIGxvY2FsUmVjdDogbG9jYWxSZWN0LFxuICAgICAgb2JiOiBvYmIsXG4gICAgICBwcmlvcml0eTogcmF3SXRlbS5wcmlvcml0eSxcbiAgICAgIGRlZmF1bHRBdHRyOiByYXdJdGVtLmRlZmF1bHRBdHRyLFxuICAgICAgbGF5b3V0T3B0aW9uOiByYXdJdGVtLmNvbXB1dGVkTGF5b3V0T3B0aW9uLFxuICAgICAgYXhpc0FsaWduZWQ6IGlzQXhpc0FsaWduZWQsXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBsaXN0O1xufVxuZnVuY3Rpb24gc2hpZnRMYXlvdXQobGlzdCwgeHlEaW0sIHNpemVEaW0sIG1pbkJvdW5kLCBtYXhCb3VuZCwgYmFsYW5jZVNoaWZ0KSB7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgaWYgKGxlbiA8IDIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEucmVjdFt4eURpbV0gLSBiLnJlY3RbeHlEaW1dO1xuICB9KTtcbiAgdmFyIGxhc3RQb3MgPSAwO1xuICB2YXIgZGVsdGE7XG4gIHZhciBhZGp1c3RlZCA9IGZhbHNlO1xuICB2YXIgc2hpZnRzID0gW107XG4gIHZhciB0b3RhbFNoaWZ0cyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIHJlY3QgPSBpdGVtLnJlY3Q7XG4gICAgZGVsdGEgPSByZWN0W3h5RGltXSAtIGxhc3RQb3M7XG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgLy8gc2hpZnRGb3J3YXJkKGksIGxlbiwgLWRlbHRhKTtcbiAgICAgIHJlY3RbeHlEaW1dIC09IGRlbHRhO1xuICAgICAgaXRlbS5sYWJlbFt4eURpbV0gLT0gZGVsdGE7XG4gICAgICBhZGp1c3RlZCA9IHRydWU7XG4gICAgfVxuICAgIHZhciBzaGlmdCA9IE1hdGgubWF4KC1kZWx0YSwgMCk7XG4gICAgc2hpZnRzLnB1c2goc2hpZnQpO1xuICAgIHRvdGFsU2hpZnRzICs9IHNoaWZ0O1xuICAgIGxhc3RQb3MgPSByZWN0W3h5RGltXSArIHJlY3Rbc2l6ZURpbV07XG4gIH1cbiAgaWYgKHRvdGFsU2hpZnRzID4gMCAmJiBiYWxhbmNlU2hpZnQpIHtcbiAgICAvLyBTaGlmdCBiYWNrIHRvIG1ha2UgdGhlIGRpc3RyaWJ1dGlvbiBtb3JlIGVxdWFsbHkuXG4gICAgc2hpZnRMaXN0KC10b3RhbFNoaWZ0cyAvIGxlbiwgMCwgbGVuKTtcbiAgfVxuICAvLyBUT0RPIGJsZWVkTWFyZ2luP1xuICB2YXIgZmlyc3QgPSBsaXN0WzBdO1xuICB2YXIgbGFzdCA9IGxpc3RbbGVuIC0gMV07XG4gIHZhciBtaW5HYXA7XG4gIHZhciBtYXhHYXA7XG4gIHVwZGF0ZU1pbk1heEdhcCgpO1xuICAvLyBJZiBlbmRzIGV4Y2VlZCB0d28gYm91bmRzLCBzcXVlZXplIGF0IG1vc3QgODAlLCB0aGVuIHRha2UgdGhlIGdhcCBvZiB0d28gYm91bmRzLlxuICBtaW5HYXAgPCAwICYmIHNxdWVlemVHYXBzKC1taW5HYXAsIDAuOCk7XG4gIG1heEdhcCA8IDAgJiYgc3F1ZWV6ZUdhcHMobWF4R2FwLCAwLjgpO1xuICB1cGRhdGVNaW5NYXhHYXAoKTtcbiAgdGFrZUJvdW5kc0dhcChtaW5HYXAsIG1heEdhcCwgMSk7XG4gIHRha2VCb3VuZHNHYXAobWF4R2FwLCBtaW5HYXAsIC0xKTtcbiAgLy8gSGFuZGxlIGJhaWxvdXQgd2hlbiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlLlxuICB1cGRhdGVNaW5NYXhHYXAoKTtcbiAgaWYgKG1pbkdhcCA8IDApIHtcbiAgICBzcXVlZXplV2hlbkJhaWxvdXQoLW1pbkdhcCk7XG4gIH1cbiAgaWYgKG1heEdhcCA8IDApIHtcbiAgICBzcXVlZXplV2hlbkJhaWxvdXQobWF4R2FwKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNaW5NYXhHYXAoKSB7XG4gICAgbWluR2FwID0gZmlyc3QucmVjdFt4eURpbV0gLSBtaW5Cb3VuZDtcbiAgICBtYXhHYXAgPSBtYXhCb3VuZCAtIGxhc3QucmVjdFt4eURpbV0gLSBsYXN0LnJlY3Rbc2l6ZURpbV07XG4gIH1cbiAgZnVuY3Rpb24gdGFrZUJvdW5kc0dhcChnYXBUaGlzQm91bmQsIGdhcE90aGVyQm91bmQsIG1vdmVEaXIpIHtcbiAgICBpZiAoZ2FwVGhpc0JvdW5kIDwgMCkge1xuICAgICAgLy8gTW92ZSBmcm9tIG90aGVyIGdhcCBpZiBjYW4uXG4gICAgICB2YXIgbW92ZUZyb21NYXhHYXAgPSBNYXRoLm1pbihnYXBPdGhlckJvdW5kLCAtZ2FwVGhpc0JvdW5kKTtcbiAgICAgIGlmIChtb3ZlRnJvbU1heEdhcCA+IDApIHtcbiAgICAgICAgc2hpZnRMaXN0KG1vdmVGcm9tTWF4R2FwICogbW92ZURpciwgMCwgbGVuKTtcbiAgICAgICAgdmFyIHJlbWFpbmVkID0gbW92ZUZyb21NYXhHYXAgKyBnYXBUaGlzQm91bmQ7XG4gICAgICAgIGlmIChyZW1haW5lZCA8IDApIHtcbiAgICAgICAgICBzcXVlZXplR2FwcygtcmVtYWluZWQgKiBtb3ZlRGlyLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3F1ZWV6ZUdhcHMoLWdhcFRoaXNCb3VuZCAqIG1vdmVEaXIsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzaGlmdExpc3QoZGVsdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoZGVsdGEgIT09IDApIHtcbiAgICAgIGFkanVzdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICAgIHZhciByZWN0ID0gaXRlbS5yZWN0O1xuICAgICAgcmVjdFt4eURpbV0gKz0gZGVsdGE7XG4gICAgICBpdGVtLmxhYmVsW3h5RGltXSArPSBkZWx0YTtcbiAgICB9XG4gIH1cbiAgLy8gU3F1ZWV6ZSBnYXBzIGlmIHRoZSBsYWJlbHMgZXhjZWVkIG1hcmdpbi5cbiAgZnVuY3Rpb24gc3F1ZWV6ZUdhcHMoZGVsdGEsIG1heFNxZWV6ZVBlcmNlbnQpIHtcbiAgICB2YXIgZ2FwcyA9IFtdO1xuICAgIHZhciB0b3RhbEdhcHMgPSAwO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwcmV2SXRlbVJlY3QgPSBsaXN0W2kgLSAxXS5yZWN0O1xuICAgICAgdmFyIGdhcCA9IE1hdGgubWF4KGxpc3RbaV0ucmVjdFt4eURpbV0gLSBwcmV2SXRlbVJlY3RbeHlEaW1dIC0gcHJldkl0ZW1SZWN0W3NpemVEaW1dLCAwKTtcbiAgICAgIGdhcHMucHVzaChnYXApO1xuICAgICAgdG90YWxHYXBzICs9IGdhcDtcbiAgICB9XG4gICAgaWYgKCF0b3RhbEdhcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNxdWVlemVQZXJjZW50ID0gTWF0aC5taW4oTWF0aC5hYnMoZGVsdGEpIC8gdG90YWxHYXBzLCBtYXhTcWVlemVQZXJjZW50KTtcbiAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICAvLyBEaXN0cmlidXRlIHRoZSBzaGlmdCBkZWx0YSB0byBhbGwgZ2Fwcy5cbiAgICAgICAgdmFyIG1vdmVtZW50ID0gZ2Fwc1tpXSAqIHNxdWVlemVQZXJjZW50O1xuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIHNoaWZ0TGlzdChtb3ZlbWVudCwgMCwgaSArIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCYWNrd2FyZFxuICAgICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgLy8gRGlzdHJpYnV0ZSB0aGUgc2hpZnQgZGVsdGEgdG8gYWxsIGdhcHMuXG4gICAgICAgIHZhciBtb3ZlbWVudCA9IGdhcHNbaSAtIDFdICogc3F1ZWV6ZVBlcmNlbnQ7XG4gICAgICAgIHNoaWZ0TGlzdCgtbW92ZW1lbnQsIGksIGxlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFNxdWVlemUgdG8gYWxsb3cgb3ZlcmxhcCBpZiB0aGVyZSBpcyBubyBtb3JlIHNwYWNlIGF2YWlsYWJsZS5cclxuICAgKiBMZXQgb3RoZXIgb3ZlcmxhcHBpbmcgc3RyYXRlZ3kgbGlrZSBoaWRlT3ZlcmxhcCBkbyB0aGUgam9iIGluc3RlYWQgb2Yga2VlcCBleGNlZWRpbmcgdGhlIGJvdW5kcy5cclxuICAgKi9cbiAgZnVuY3Rpb24gc3F1ZWV6ZVdoZW5CYWlsb3V0KGRlbHRhKSB7XG4gICAgdmFyIGRpciA9IGRlbHRhIDwgMCA/IC0xIDogMTtcbiAgICBkZWx0YSA9IE1hdGguYWJzKGRlbHRhKTtcbiAgICB2YXIgbW92ZUZvckVhY2hMYWJlbCA9IE1hdGguY2VpbChkZWx0YSAvIChsZW4gLSAxKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgc2hpZnRMaXN0KG1vdmVGb3JFYWNoTGFiZWwsIDAsIGkgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJhY2t3YXJkXG4gICAgICAgIHNoaWZ0TGlzdCgtbW92ZUZvckVhY2hMYWJlbCwgbGVuIC0gaSAtIDEsIGxlbik7XG4gICAgICB9XG4gICAgICBkZWx0YSAtPSBtb3ZlRm9yRWFjaExhYmVsO1xuICAgICAgaWYgKGRlbHRhIDw9IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYWRqdXN0ZWQ7XG59XG4vKipcclxuICogQWRqdXN0IGxhYmVscyBvbiB4IGRpcmVjdGlvbiB0byBhdm9pZCBvdmVybGFwLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGlmdExheW91dE9uWChsaXN0LCBsZWZ0Qm91bmQsIHJpZ2h0Qm91bmQsXG4vLyBJZiBhdmVyYWdlIHRoZSBzaGlmdHMgb24gYWxsIGxhYmVscyBhbmQgYWRkIHRoZW0gdG8gMFxuLy8gVE9ETzogTm90IHN1cmUgaWYgc2hvdWxkIGVuYWJsZSBpdC5cbi8vIFByb3M6IFRoZSBhbmdsZSBvZiBsaW5lcyB3aWxsIGRpc3RyaWJ1dGUgbW9yZSBlcXVhbGx5XG4vLyBDb25zOiBJbiBzb21lIGxheW91dC4gSXQgbWF5IG5vdCB3aGF0IHVzZXIgd2FudGVkLiBsaWtlIGluIHBpZS4gdGhlIGxhYmVsIG9mIGxhc3Qgc2VjdG9yIGlzIHVzdWFsbHkgY2hhbmdlZCB1bmV4cGVjdGVkbHkuXG5iYWxhbmNlU2hpZnQpIHtcbiAgcmV0dXJuIHNoaWZ0TGF5b3V0KGxpc3QsICd4JywgJ3dpZHRoJywgbGVmdEJvdW5kLCByaWdodEJvdW5kLCBiYWxhbmNlU2hpZnQpO1xufVxuLyoqXHJcbiAqIEFkanVzdCBsYWJlbHMgb24geSBkaXJlY3Rpb24gdG8gYXZvaWQgb3ZlcmxhcC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hpZnRMYXlvdXRPblkobGlzdCwgdG9wQm91bmQsIGJvdHRvbUJvdW5kLFxuLy8gSWYgYXZlcmFnZSB0aGUgc2hpZnRzIG9uIGFsbCBsYWJlbHMgYW5kIGFkZCB0aGVtIHRvIDBcbmJhbGFuY2VTaGlmdCkge1xuICByZXR1cm4gc2hpZnRMYXlvdXQobGlzdCwgJ3knLCAnaGVpZ2h0JywgdG9wQm91bmQsIGJvdHRvbUJvdW5kLCBiYWxhbmNlU2hpZnQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhpZGVPdmVybGFwKGxhYmVsTGlzdCkge1xuICB2YXIgZGlzcGxheWVkTGFiZWxzID0gW107XG4gIC8vIFRPRE8sIHJlbmRlciBvdmVyZmxvdyB2aXNpYmxlIGZpcnN0LCBwdXQgaW4gdGhlIGRpc3BsYXllZExhYmVscy5cbiAgbGFiZWxMaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHk7XG4gIH0pO1xuICB2YXIgZ2xvYmFsUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gIGZ1bmN0aW9uIGhpZGVFbChlbCkge1xuICAgIGlmICghZWwuaWdub3JlKSB7XG4gICAgICAvLyBTaG93IG9uIGVtcGhhc2lzLlxuICAgICAgdmFyIGVtcGhhc2lzU3RhdGUgPSBlbC5lbnN1cmVTdGF0ZSgnZW1waGFzaXMnKTtcbiAgICAgIGlmIChlbXBoYXNpc1N0YXRlLmlnbm9yZSA9PSBudWxsKSB7XG4gICAgICAgIGVtcGhhc2lzU3RhdGUuaWdub3JlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLmlnbm9yZSA9IHRydWU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGFiZWxJdGVtID0gbGFiZWxMaXN0W2ldO1xuICAgIHZhciBpc0F4aXNBbGlnbmVkID0gbGFiZWxJdGVtLmF4aXNBbGlnbmVkO1xuICAgIHZhciBsb2NhbFJlY3QgPSBsYWJlbEl0ZW0ubG9jYWxSZWN0O1xuICAgIHZhciB0cmFuc2Zvcm0gPSBsYWJlbEl0ZW0udHJhbnNmb3JtO1xuICAgIHZhciBsYWJlbCA9IGxhYmVsSXRlbS5sYWJlbDtcbiAgICB2YXIgbGFiZWxMaW5lID0gbGFiZWxJdGVtLmxhYmVsTGluZTtcbiAgICBnbG9iYWxSZWN0LmNvcHkobGFiZWxJdGVtLnJlY3QpO1xuICAgIC8vIEFkZCBhIHRocmVzaG9sZCBiZWNhdXNlIGxheW91dCBtYXkgYmUgYWxpZ25lZCBwcmVjaXNlbHkuXG4gICAgZ2xvYmFsUmVjdC53aWR0aCAtPSAwLjE7XG4gICAgZ2xvYmFsUmVjdC5oZWlnaHQgLT0gMC4xO1xuICAgIGdsb2JhbFJlY3QueCArPSAwLjA1O1xuICAgIGdsb2JhbFJlY3QueSArPSAwLjA1O1xuICAgIHZhciBvYmIgPSBsYWJlbEl0ZW0ub2JiO1xuICAgIHZhciBvdmVybGFwcGVkID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBkaXNwbGF5ZWRMYWJlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBleGlzdHNUZXh0Q2ZnID0gZGlzcGxheWVkTGFiZWxzW2pdO1xuICAgICAgLy8gRmFzdCByZWplY3Rpb24uXG4gICAgICBpZiAoIWdsb2JhbFJlY3QuaW50ZXJzZWN0KGV4aXN0c1RleHRDZmcucmVjdCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBeGlzQWxpZ25lZCAmJiBleGlzdHNUZXh0Q2ZnLmF4aXNBbGlnbmVkKSB7XG4gICAgICAgIC8vIElzIG92ZXJsYXBwZWRcbiAgICAgICAgb3ZlcmxhcHBlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCFleGlzdHNUZXh0Q2ZnLm9iYikge1xuICAgICAgICAvLyBJZiBzZWxmIGlzIG5vdCBheGlzIGFsaWduZWQuIEJ1dCBvdGhlciBpcy5cbiAgICAgICAgZXhpc3RzVGV4dENmZy5vYmIgPSBuZXcgT3JpZW50ZWRCb3VuZGluZ1JlY3QoZXhpc3RzVGV4dENmZy5sb2NhbFJlY3QsIGV4aXN0c1RleHRDZmcudHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICAgIGlmICghb2JiKSB7XG4gICAgICAgIC8vIElmIHNlbGYgaXMgYXhpcyBhbGlnbmVkLiBCdXQgb3RoZXIgaXMgbm90LlxuICAgICAgICBvYmIgPSBuZXcgT3JpZW50ZWRCb3VuZGluZ1JlY3QobG9jYWxSZWN0LCB0cmFuc2Zvcm0pO1xuICAgICAgfVxuICAgICAgaWYgKG9iYi5pbnRlcnNlY3QoZXhpc3RzVGV4dENmZy5vYmIpKSB7XG4gICAgICAgIG92ZXJsYXBwZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVE9ETyBDYWxsYmFjayB0byBkZXRlcm1pbmUgaWYgdGhpcyBvdmVybGFwIHNob3VsZCBiZSBoYW5kbGVkP1xuICAgIGlmIChvdmVybGFwcGVkKSB7XG4gICAgICBoaWRlRWwobGFiZWwpO1xuICAgICAgbGFiZWxMaW5lICYmIGhpZGVFbChsYWJlbExpbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYWJlbC5hdHRyKCdpZ25vcmUnLCBsYWJlbEl0ZW0uZGVmYXVsdEF0dHIuaWdub3JlKTtcbiAgICAgIGxhYmVsTGluZSAmJiBsYWJlbExpbmUuYXR0cignaWdub3JlJywgbGFiZWxJdGVtLmRlZmF1bHRBdHRyLmxhYmVsR3VpZGVJZ25vcmUpO1xuICAgICAgZGlzcGxheWVkTGFiZWxzLnB1c2gobGFiZWxJdGVtKTtcbiAgICB9XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///77175\n')},89632:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Lu: () => (/* binding */ labelInner),\n/* harmony export */   Oh: () => (/* binding */ setLabelValueAnimation),\n/* harmony export */   VB: () => (/* binding */ createTextStyle),\n/* harmony export */   c8: () => (/* binding */ getFont),\n/* harmony export */   lx: () => (/* binding */ getLabelStatesModels),\n/* harmony export */   qM: () => (/* binding */ setLabelStyle),\n/* harmony export */   sD: () => (/* binding */ createTextConfig),\n/* harmony export */   xb: () => (/* binding */ animateLabelValue)\n/* harmony export */ });\n/* unused harmony export setLabelText */\n/* harmony import */ var zrender_lib_graphic_Text_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32322);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _util_states_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34833);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(48170);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5638);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\nvar EMPTY_OBJ = {};\nfunction setLabelText(label, labelTexts) {\n  for (var i = 0; i < _util_states_js__WEBPACK_IMPORTED_MODULE_0__/* .SPECIAL_STATES */ .BV.length; i++) {\n    var stateName = _util_states_js__WEBPACK_IMPORTED_MODULE_0__/* .SPECIAL_STATES */ .BV[i];\n    var text = labelTexts[stateName];\n    var state = label.ensureState(stateName);\n    state.style = state.style || {};\n    state.style.text = text;\n  }\n  var oldStates = label.currentStates.slice();\n  label.clearStates(true);\n  label.setStyle({\n    text: labelTexts.normal\n  });\n  label.useStates(oldStates, true);\n}\nfunction getLabelText(opt, stateModels, interpolatedValue) {\n  var labelFetcher = opt.labelFetcher;\n  var labelDataIndex = opt.labelDataIndex;\n  var labelDimIndex = opt.labelDimIndex;\n  var normalModel = stateModels.normal;\n  var baseText;\n  if (labelFetcher) {\n    baseText = labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex, normalModel && normalModel.get('formatter'), interpolatedValue != null ? {\n      interpolatedValue: interpolatedValue\n    } : null);\n  }\n  if (baseText == null) {\n    baseText = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;\n  }\n  var statesText = {\n    normal: baseText\n  };\n  for (var i = 0; i < _util_states_js__WEBPACK_IMPORTED_MODULE_0__/* .SPECIAL_STATES */ .BV.length; i++) {\n    var stateName = _util_states_js__WEBPACK_IMPORTED_MODULE_0__/* .SPECIAL_STATES */ .BV[i];\n    var stateModel = stateModels[stateName];\n    statesText[stateName] = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get('formatter')) : null, baseText);\n  }\n  return statesText;\n}\nfunction setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified\n// TODO specified position?\n) {\n  opt = opt || EMPTY_OBJ;\n  var isSetOnText = targetEl instanceof zrender_lib_graphic_Text_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .Ay;\n  var needsCreateText = false;\n  for (var i = 0; i < _util_states_js__WEBPACK_IMPORTED_MODULE_0__/* .DISPLAY_STATES */ .wV.length; i++) {\n    var stateModel = labelStatesModels[_util_states_js__WEBPACK_IMPORTED_MODULE_0__/* .DISPLAY_STATES */ .wV[i]];\n    if (stateModel && stateModel.getShallow('show')) {\n      needsCreateText = true;\n      break;\n    }\n  }\n  var textContent = isSetOnText ? targetEl : targetEl.getTextContent();\n  if (needsCreateText) {\n    if (!isSetOnText) {\n      // Reuse the previous\n      if (!textContent) {\n        textContent = new zrender_lib_graphic_Text_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .Ay();\n        targetEl.setTextContent(textContent);\n      }\n      // Use same state proxy\n      if (targetEl.stateProxy) {\n        textContent.stateProxy = targetEl.stateProxy;\n      }\n    }\n    var labelStatesTexts = getLabelText(opt, labelStatesModels);\n    var normalModel = labelStatesModels.normal;\n    var showNormal = !!normalModel.getShallow('show');\n    var normalStyle = createTextStyle(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);\n    normalStyle.text = labelStatesTexts.normal;\n    if (!isSetOnText) {\n      // Always create new\n      targetEl.setTextConfig(createTextConfig(normalModel, opt, false));\n    }\n    for (var i = 0; i < _util_states_js__WEBPACK_IMPORTED_MODULE_0__/* .SPECIAL_STATES */ .BV.length; i++) {\n      var stateName = _util_states_js__WEBPACK_IMPORTED_MODULE_0__/* .SPECIAL_STATES */ .BV[i];\n      var stateModel = labelStatesModels[stateName];\n      if (stateModel) {\n        var stateObj = textContent.ensureState(stateName);\n        var stateShow = !!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(stateModel.getShallow('show'), showNormal);\n        if (stateShow !== showNormal) {\n          stateObj.ignore = !stateShow;\n        }\n        stateObj.style = createTextStyle(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);\n        stateObj.style.text = labelStatesTexts[stateName];\n        if (!isSetOnText) {\n          var targetElEmphasisState = targetEl.ensureState(stateName);\n          targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);\n        }\n      }\n    }\n    // PENDING: if there is many requirements that emphasis position\n    // need to be different from normal position, we might consider\n    // auto silent is those cases.\n    textContent.silent = !!normalModel.getShallow('silent');\n    // Keep x and y\n    if (textContent.style.x != null) {\n      normalStyle.x = textContent.style.x;\n    }\n    if (textContent.style.y != null) {\n      normalStyle.y = textContent.style.y;\n    }\n    textContent.ignore = !showNormal;\n    // Always create new style.\n    textContent.useStyle(normalStyle);\n    textContent.dirty();\n    if (opt.enableTextSetter) {\n      labelInner(textContent).setLabelText = function (interpolatedValue) {\n        var labelStatesTexts = getLabelText(opt, labelStatesModels, interpolatedValue);\n        setLabelText(textContent, labelStatesTexts);\n      };\n    }\n  } else if (textContent) {\n    // Not display rich text.\n    textContent.ignore = true;\n  }\n  targetEl.dirty();\n}\n\nfunction getLabelStatesModels(itemModel, labelName) {\n  labelName = labelName || 'label';\n  var statesModels = {\n    normal: itemModel.getModel(labelName)\n  };\n  for (var i = 0; i < _util_states_js__WEBPACK_IMPORTED_MODULE_0__/* .SPECIAL_STATES */ .BV.length; i++) {\n    var stateName = _util_states_js__WEBPACK_IMPORTED_MODULE_0__/* .SPECIAL_STATES */ .BV[i];\n    statesModels[stateName] = itemModel.getModel([stateName, labelName]);\n  }\n  return statesModels;\n}\n/**\r\n * Set basic textStyle properties.\r\n */\nfunction createTextStyle(textStyleModel, specifiedTextStyle,\n// Fixed style in the code. Can't be set by model.\nopt, isNotNormal, isAttached // If text is attached on an element. If so, auto color will handling in zrender.\n) {\n  var textStyle = {};\n  setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);\n  specifiedTextStyle && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)(textStyle, specifiedTextStyle);\n  // textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);\n  return textStyle;\n}\nfunction createTextConfig(textStyleModel, opt, isNotNormal) {\n  opt = opt || {};\n  var textConfig = {};\n  var labelPosition;\n  var labelRotate = textStyleModel.getShallow('rotate');\n  var labelDistance = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(textStyleModel.getShallow('distance'), isNotNormal ? null : 5);\n  var labelOffset = textStyleModel.getShallow('offset');\n  labelPosition = textStyleModel.getShallow('position') || (isNotNormal ? null : 'inside');\n  // 'outside' is not a valid zr textPostion value, but used\n  // in bar series, and magric type should be considered.\n  labelPosition === 'outside' && (labelPosition = opt.defaultOutsidePosition || 'top');\n  if (labelPosition != null) {\n    textConfig.position = labelPosition;\n  }\n  if (labelOffset != null) {\n    textConfig.offset = labelOffset;\n  }\n  if (labelRotate != null) {\n    labelRotate *= Math.PI / 180;\n    textConfig.rotation = labelRotate;\n  }\n  if (labelDistance != null) {\n    textConfig.distance = labelDistance;\n  }\n  // fill and auto is determined by the color of path fill if it's not specified by developers.\n  textConfig.outsideFill = textStyleModel.get('color') === 'inherit' ? opt.inheritColor || null : 'auto';\n  return textConfig;\n}\n/**\r\n * The uniform entry of set text style, that is, retrieve style definitions\r\n * from `model` and set to `textStyle` object.\r\n *\r\n * Never in merge mode, but in overwrite mode, that is, all of the text style\r\n * properties will be set. (Consider the states of normal and emphasis and\r\n * default value can be adopted, merge would make the logic too complicated\r\n * to manage.)\r\n */\nfunction setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {\n  // Consider there will be abnormal when merge hover style to normal style if given default value.\n  opt = opt || EMPTY_OBJ;\n  var ecModel = textStyleModel.ecModel;\n  var globalTextStyle = ecModel && ecModel.option.textStyle;\n  // Consider case:\n  // {\n  //     data: [{\n  //         value: 12,\n  //         label: {\n  //             rich: {\n  //                 // no 'a' here but using parent 'a'.\n  //             }\n  //         }\n  //     }],\n  //     rich: {\n  //         a: { ... }\n  //     }\n  // }\n  var richItemNames = getRichItemNames(textStyleModel);\n  var richResult;\n  if (richItemNames) {\n    richResult = {};\n    for (var name_1 in richItemNames) {\n      if (richItemNames.hasOwnProperty(name_1)) {\n        // Cascade is supported in rich.\n        var richTextStyle = textStyleModel.getModel(['rich', name_1]);\n        // In rich, never `disableBox`.\n        // FIXME: consider `label: {formatter: '{a|xx}', color: 'blue', rich: {a: {}}}`,\n        // the default color `'blue'` will not be adopted if no color declared in `rich`.\n        // That might confuses users. So probably we should put `textStyleModel` as the\n        // root ancestor of the `richTextStyle`. But that would be a break change.\n        setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, opt, isNotNormal, isAttached, false, true);\n      }\n    }\n  }\n  if (richResult) {\n    textStyle.rich = richResult;\n  }\n  var overflow = textStyleModel.get('overflow');\n  if (overflow) {\n    textStyle.overflow = overflow;\n  }\n  var margin = textStyleModel.get('minMargin');\n  if (margin != null) {\n    textStyle.margin = margin;\n  }\n  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, true, false);\n}\n// Consider case:\n// {\n//     data: [{\n//         value: 12,\n//         label: {\n//             rich: {\n//                 // no 'a' here but using parent 'a'.\n//             }\n//         }\n//     }],\n//     rich: {\n//         a: { ... }\n//     }\n// }\n// TODO TextStyleModel\nfunction getRichItemNames(textStyleModel) {\n  // Use object to remove duplicated names.\n  var richItemNameMap;\n  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {\n    var rich = (textStyleModel.option || EMPTY_OBJ).rich;\n    if (rich) {\n      richItemNameMap = richItemNameMap || {};\n      var richKeys = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.keys)(rich);\n      for (var i = 0; i < richKeys.length; i++) {\n        var richKey = richKeys[i];\n        richItemNameMap[richKey] = 1;\n      }\n    }\n    textStyleModel = textStyleModel.parentModel;\n  }\n  return richItemNameMap;\n}\nvar TEXT_PROPS_WITH_GLOBAL = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY'];\nvar TEXT_PROPS_SELF = ['align', 'lineHeight', 'width', 'height', 'tag', 'verticalAlign', 'ellipsis'];\nvar TEXT_PROPS_BOX = ['padding', 'borderWidth', 'borderRadius', 'borderDashOffset', 'backgroundColor', 'borderColor', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\nfunction setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, isBlock, inRich) {\n  // In merge mode, default value should not be given.\n  globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;\n  var inheritColor = opt && opt.inheritColor;\n  var fillColor = textStyleModel.getShallow('color');\n  var strokeColor = textStyleModel.getShallow('textBorderColor');\n  var opacity = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(textStyleModel.getShallow('opacity'), globalTextStyle.opacity);\n  if (fillColor === 'inherit' || fillColor === 'auto') {\n    if (false) {}\n    if (inheritColor) {\n      fillColor = inheritColor;\n    } else {\n      fillColor = null;\n    }\n  }\n  if (strokeColor === 'inherit' || strokeColor === 'auto') {\n    if (false) {}\n    if (inheritColor) {\n      strokeColor = inheritColor;\n    } else {\n      strokeColor = null;\n    }\n  }\n  if (!isAttached) {\n    // Only use default global textStyle.color if text is individual.\n    // Otherwise it will use the strategy of attached text color because text may be on a path.\n    fillColor = fillColor || globalTextStyle.color;\n    strokeColor = strokeColor || globalTextStyle.textBorderColor;\n  }\n  if (fillColor != null) {\n    textStyle.fill = fillColor;\n  }\n  if (strokeColor != null) {\n    textStyle.stroke = strokeColor;\n  }\n  var textBorderWidth = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(textStyleModel.getShallow('textBorderWidth'), globalTextStyle.textBorderWidth);\n  if (textBorderWidth != null) {\n    textStyle.lineWidth = textBorderWidth;\n  }\n  var textBorderType = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(textStyleModel.getShallow('textBorderType'), globalTextStyle.textBorderType);\n  if (textBorderType != null) {\n    textStyle.lineDash = textBorderType;\n  }\n  var textBorderDashOffset = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(textStyleModel.getShallow('textBorderDashOffset'), globalTextStyle.textBorderDashOffset);\n  if (textBorderDashOffset != null) {\n    textStyle.lineDashOffset = textBorderDashOffset;\n  }\n  if (!isNotNormal && opacity == null && !inRich) {\n    opacity = opt && opt.defaultOpacity;\n  }\n  if (opacity != null) {\n    textStyle.opacity = opacity;\n  }\n  // TODO\n  if (!isNotNormal && !isAttached) {\n    // Set default finally.\n    if (textStyle.fill == null && opt.inheritColor) {\n      textStyle.fill = opt.inheritColor;\n    }\n  }\n  // Do not use `getFont` here, because merge should be supported, where\n  // part of these properties may be changed in emphasis style, and the\n  // others should remain their original value got from normal style.\n  for (var i = 0; i < TEXT_PROPS_WITH_GLOBAL.length; i++) {\n    var key = TEXT_PROPS_WITH_GLOBAL[i];\n    var val = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(textStyleModel.getShallow(key), globalTextStyle[key]);\n    if (val != null) {\n      textStyle[key] = val;\n    }\n  }\n  for (var i = 0; i < TEXT_PROPS_SELF.length; i++) {\n    var key = TEXT_PROPS_SELF[i];\n    var val = textStyleModel.getShallow(key);\n    if (val != null) {\n      textStyle[key] = val;\n    }\n  }\n  if (textStyle.verticalAlign == null) {\n    var baseline = textStyleModel.getShallow('baseline');\n    if (baseline != null) {\n      textStyle.verticalAlign = baseline;\n    }\n  }\n  if (!isBlock || !opt.disableBox) {\n    for (var i = 0; i < TEXT_PROPS_BOX.length; i++) {\n      var key = TEXT_PROPS_BOX[i];\n      var val = textStyleModel.getShallow(key);\n      if (val != null) {\n        textStyle[key] = val;\n      }\n    }\n    var borderType = textStyleModel.getShallow('borderType');\n    if (borderType != null) {\n      textStyle.borderDash = borderType;\n    }\n    if ((textStyle.backgroundColor === 'auto' || textStyle.backgroundColor === 'inherit') && inheritColor) {\n      if (false) {}\n      textStyle.backgroundColor = inheritColor;\n    }\n    if ((textStyle.borderColor === 'auto' || textStyle.borderColor === 'inherit') && inheritColor) {\n      if (false) {}\n      textStyle.borderColor = inheritColor;\n    }\n  }\n}\nfunction getFont(opt, ecModel) {\n  var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n  return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.trim)([\n  // FIXME in node-canvas fontWeight is before fontStyle\n  opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '', opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '', (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px', opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'].join(' '));\n}\nvar labelInner = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_3__/* .makeInner */ .$r)();\nfunction setLabelValueAnimation(label, labelStatesModels, value, getDefaultText) {\n  if (!label) {\n    return;\n  }\n  var obj = labelInner(label);\n  obj.prevValue = obj.value;\n  obj.value = value;\n  var normalLabelModel = labelStatesModels.normal;\n  obj.valueAnimation = normalLabelModel.get('valueAnimation');\n  if (obj.valueAnimation) {\n    obj.precision = normalLabelModel.get('precision');\n    obj.defaultInterpolatedText = getDefaultText;\n    obj.statesModels = labelStatesModels;\n  }\n}\nfunction animateLabelValue(textEl, dataIndex, data, animatableModel, labelFetcher) {\n  var labelInnerStore = labelInner(textEl);\n  if (!labelInnerStore.valueAnimation || labelInnerStore.prevValue === labelInnerStore.value) {\n    // Value not changed, no new label animation\n    return;\n  }\n  var defaultInterpolatedText = labelInnerStore.defaultInterpolatedText;\n  // Consider the case that being animating, do not use the `obj.value`,\n  // Otherwise it will jump to the `obj.value` when this new animation started.\n  var currValue = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(labelInnerStore.interpolatedValue, labelInnerStore.prevValue);\n  var targetValue = labelInnerStore.value;\n  function during(percent) {\n    var interpolated = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_3__/* .interpolateRawValues */ .Il)(data, labelInnerStore.precision, currValue, targetValue, percent);\n    labelInnerStore.interpolatedValue = percent === 1 ? null : interpolated;\n    var labelText = getLabelText({\n      labelDataIndex: dataIndex,\n      labelFetcher: labelFetcher,\n      defaultText: defaultInterpolatedText ? defaultInterpolatedText(interpolated) : interpolated + ''\n    }, labelInnerStore.statesModels, interpolated);\n    setLabelText(textEl, labelText);\n  }\n  textEl.percent = 0;\n  (labelInnerStore.prevValue == null ? _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__/* .initProps */ .LW : _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__/* .updateProps */ .oi)(textEl, {\n    // percent is used to prevent animation from being aborted #15916\n    percent: 1\n  }, animatableModel, dataIndex, null, during);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk2MzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYWJlbC9sYWJlbFN0eWxlLmpzP2Q2YzciXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgWlJUZXh0IGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qcyc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCByZXRyaWV2ZTIsIGV4dGVuZCwga2V5cywgdHJpbSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBTUEVDSUFMX1NUQVRFUywgRElTUExBWV9TVEFURVMgfSBmcm9tICcuLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGVSZXBsYWNlTG9nIH0gZnJvbSAnLi4vdXRpbC9sb2cuanMnO1xuaW1wb3J0IHsgbWFrZUlubmVyLCBpbnRlcnBvbGF0ZVJhd1ZhbHVlcyB9IGZyb20gJy4uL3V0aWwvbW9kZWwuanMnO1xuaW1wb3J0IHsgaW5pdFByb3BzLCB1cGRhdGVQcm9wcyB9IGZyb20gJy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG52YXIgRU1QVFlfT0JKID0ge307XG5leHBvcnQgZnVuY3Rpb24gc2V0TGFiZWxUZXh0KGxhYmVsLCBsYWJlbFRleHRzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgU1BFQ0lBTF9TVEFURVMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RhdGVOYW1lID0gU1BFQ0lBTF9TVEFURVNbaV07XG4gICAgdmFyIHRleHQgPSBsYWJlbFRleHRzW3N0YXRlTmFtZV07XG4gICAgdmFyIHN0YXRlID0gbGFiZWwuZW5zdXJlU3RhdGUoc3RhdGVOYW1lKTtcbiAgICBzdGF0ZS5zdHlsZSA9IHN0YXRlLnN0eWxlIHx8IHt9O1xuICAgIHN0YXRlLnN0eWxlLnRleHQgPSB0ZXh0O1xuICB9XG4gIHZhciBvbGRTdGF0ZXMgPSBsYWJlbC5jdXJyZW50U3RhdGVzLnNsaWNlKCk7XG4gIGxhYmVsLmNsZWFyU3RhdGVzKHRydWUpO1xuICBsYWJlbC5zZXRTdHlsZSh7XG4gICAgdGV4dDogbGFiZWxUZXh0cy5ub3JtYWxcbiAgfSk7XG4gIGxhYmVsLnVzZVN0YXRlcyhvbGRTdGF0ZXMsIHRydWUpO1xufVxuZnVuY3Rpb24gZ2V0TGFiZWxUZXh0KG9wdCwgc3RhdGVNb2RlbHMsIGludGVycG9sYXRlZFZhbHVlKSB7XG4gIHZhciBsYWJlbEZldGNoZXIgPSBvcHQubGFiZWxGZXRjaGVyO1xuICB2YXIgbGFiZWxEYXRhSW5kZXggPSBvcHQubGFiZWxEYXRhSW5kZXg7XG4gIHZhciBsYWJlbERpbUluZGV4ID0gb3B0LmxhYmVsRGltSW5kZXg7XG4gIHZhciBub3JtYWxNb2RlbCA9IHN0YXRlTW9kZWxzLm5vcm1hbDtcbiAgdmFyIGJhc2VUZXh0O1xuICBpZiAobGFiZWxGZXRjaGVyKSB7XG4gICAgYmFzZVRleHQgPSBsYWJlbEZldGNoZXIuZ2V0Rm9ybWF0dGVkTGFiZWwobGFiZWxEYXRhSW5kZXgsICdub3JtYWwnLCBudWxsLCBsYWJlbERpbUluZGV4LCBub3JtYWxNb2RlbCAmJiBub3JtYWxNb2RlbC5nZXQoJ2Zvcm1hdHRlcicpLCBpbnRlcnBvbGF0ZWRWYWx1ZSAhPSBudWxsID8ge1xuICAgICAgaW50ZXJwb2xhdGVkVmFsdWU6IGludGVycG9sYXRlZFZhbHVlXG4gICAgfSA6IG51bGwpO1xuICB9XG4gIGlmIChiYXNlVGV4dCA9PSBudWxsKSB7XG4gICAgYmFzZVRleHQgPSBpc0Z1bmN0aW9uKG9wdC5kZWZhdWx0VGV4dCkgPyBvcHQuZGVmYXVsdFRleHQobGFiZWxEYXRhSW5kZXgsIG9wdCwgaW50ZXJwb2xhdGVkVmFsdWUpIDogb3B0LmRlZmF1bHRUZXh0O1xuICB9XG4gIHZhciBzdGF0ZXNUZXh0ID0ge1xuICAgIG5vcm1hbDogYmFzZVRleHRcbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBTUEVDSUFMX1NUQVRFUy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGF0ZU5hbWUgPSBTUEVDSUFMX1NUQVRFU1tpXTtcbiAgICB2YXIgc3RhdGVNb2RlbCA9IHN0YXRlTW9kZWxzW3N0YXRlTmFtZV07XG4gICAgc3RhdGVzVGV4dFtzdGF0ZU5hbWVdID0gcmV0cmlldmUyKGxhYmVsRmV0Y2hlciA/IGxhYmVsRmV0Y2hlci5nZXRGb3JtYXR0ZWRMYWJlbChsYWJlbERhdGFJbmRleCwgc3RhdGVOYW1lLCBudWxsLCBsYWJlbERpbUluZGV4LCBzdGF0ZU1vZGVsICYmIHN0YXRlTW9kZWwuZ2V0KCdmb3JtYXR0ZXInKSkgOiBudWxsLCBiYXNlVGV4dCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlc1RleHQ7XG59XG5mdW5jdGlvbiBzZXRMYWJlbFN0eWxlKHRhcmdldEVsLCBsYWJlbFN0YXRlc01vZGVscywgb3B0LCBzdGF0ZVNwZWNpZmllZFxuLy8gVE9ETyBzcGVjaWZpZWQgcG9zaXRpb24/XG4pIHtcbiAgb3B0ID0gb3B0IHx8IEVNUFRZX09CSjtcbiAgdmFyIGlzU2V0T25UZXh0ID0gdGFyZ2V0RWwgaW5zdGFuY2VvZiBaUlRleHQ7XG4gIHZhciBuZWVkc0NyZWF0ZVRleHQgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBESVNQTEFZX1NUQVRFUy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGF0ZU1vZGVsID0gbGFiZWxTdGF0ZXNNb2RlbHNbRElTUExBWV9TVEFURVNbaV1dO1xuICAgIGlmIChzdGF0ZU1vZGVsICYmIHN0YXRlTW9kZWwuZ2V0U2hhbGxvdygnc2hvdycpKSB7XG4gICAgICBuZWVkc0NyZWF0ZVRleHQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciB0ZXh0Q29udGVudCA9IGlzU2V0T25UZXh0ID8gdGFyZ2V0RWwgOiB0YXJnZXRFbC5nZXRUZXh0Q29udGVudCgpO1xuICBpZiAobmVlZHNDcmVhdGVUZXh0KSB7XG4gICAgaWYgKCFpc1NldE9uVGV4dCkge1xuICAgICAgLy8gUmV1c2UgdGhlIHByZXZpb3VzXG4gICAgICBpZiAoIXRleHRDb250ZW50KSB7XG4gICAgICAgIHRleHRDb250ZW50ID0gbmV3IFpSVGV4dCgpO1xuICAgICAgICB0YXJnZXRFbC5zZXRUZXh0Q29udGVudCh0ZXh0Q29udGVudCk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc2FtZSBzdGF0ZSBwcm94eVxuICAgICAgaWYgKHRhcmdldEVsLnN0YXRlUHJveHkpIHtcbiAgICAgICAgdGV4dENvbnRlbnQuc3RhdGVQcm94eSA9IHRhcmdldEVsLnN0YXRlUHJveHk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBsYWJlbFN0YXRlc1RleHRzID0gZ2V0TGFiZWxUZXh0KG9wdCwgbGFiZWxTdGF0ZXNNb2RlbHMpO1xuICAgIHZhciBub3JtYWxNb2RlbCA9IGxhYmVsU3RhdGVzTW9kZWxzLm5vcm1hbDtcbiAgICB2YXIgc2hvd05vcm1hbCA9ICEhbm9ybWFsTW9kZWwuZ2V0U2hhbGxvdygnc2hvdycpO1xuICAgIHZhciBub3JtYWxTdHlsZSA9IGNyZWF0ZVRleHRTdHlsZShub3JtYWxNb2RlbCwgc3RhdGVTcGVjaWZpZWQgJiYgc3RhdGVTcGVjaWZpZWQubm9ybWFsLCBvcHQsIGZhbHNlLCAhaXNTZXRPblRleHQpO1xuICAgIG5vcm1hbFN0eWxlLnRleHQgPSBsYWJlbFN0YXRlc1RleHRzLm5vcm1hbDtcbiAgICBpZiAoIWlzU2V0T25UZXh0KSB7XG4gICAgICAvLyBBbHdheXMgY3JlYXRlIG5ld1xuICAgICAgdGFyZ2V0RWwuc2V0VGV4dENvbmZpZyhjcmVhdGVUZXh0Q29uZmlnKG5vcm1hbE1vZGVsLCBvcHQsIGZhbHNlKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1BFQ0lBTF9TVEFURVMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGF0ZU5hbWUgPSBTUEVDSUFMX1NUQVRFU1tpXTtcbiAgICAgIHZhciBzdGF0ZU1vZGVsID0gbGFiZWxTdGF0ZXNNb2RlbHNbc3RhdGVOYW1lXTtcbiAgICAgIGlmIChzdGF0ZU1vZGVsKSB7XG4gICAgICAgIHZhciBzdGF0ZU9iaiA9IHRleHRDb250ZW50LmVuc3VyZVN0YXRlKHN0YXRlTmFtZSk7XG4gICAgICAgIHZhciBzdGF0ZVNob3cgPSAhIXJldHJpZXZlMihzdGF0ZU1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKSwgc2hvd05vcm1hbCk7XG4gICAgICAgIGlmIChzdGF0ZVNob3cgIT09IHNob3dOb3JtYWwpIHtcbiAgICAgICAgICBzdGF0ZU9iai5pZ25vcmUgPSAhc3RhdGVTaG93O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlT2JqLnN0eWxlID0gY3JlYXRlVGV4dFN0eWxlKHN0YXRlTW9kZWwsIHN0YXRlU3BlY2lmaWVkICYmIHN0YXRlU3BlY2lmaWVkW3N0YXRlTmFtZV0sIG9wdCwgdHJ1ZSwgIWlzU2V0T25UZXh0KTtcbiAgICAgICAgc3RhdGVPYmouc3R5bGUudGV4dCA9IGxhYmVsU3RhdGVzVGV4dHNbc3RhdGVOYW1lXTtcbiAgICAgICAgaWYgKCFpc1NldE9uVGV4dCkge1xuICAgICAgICAgIHZhciB0YXJnZXRFbEVtcGhhc2lzU3RhdGUgPSB0YXJnZXRFbC5lbnN1cmVTdGF0ZShzdGF0ZU5hbWUpO1xuICAgICAgICAgIHRhcmdldEVsRW1waGFzaXNTdGF0ZS50ZXh0Q29uZmlnID0gY3JlYXRlVGV4dENvbmZpZyhzdGF0ZU1vZGVsLCBvcHQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFBFTkRJTkc6IGlmIHRoZXJlIGlzIG1hbnkgcmVxdWlyZW1lbnRzIHRoYXQgZW1waGFzaXMgcG9zaXRpb25cbiAgICAvLyBuZWVkIHRvIGJlIGRpZmZlcmVudCBmcm9tIG5vcm1hbCBwb3NpdGlvbiwgd2UgbWlnaHQgY29uc2lkZXJcbiAgICAvLyBhdXRvIHNpbGVudCBpcyB0aG9zZSBjYXNlcy5cbiAgICB0ZXh0Q29udGVudC5zaWxlbnQgPSAhIW5vcm1hbE1vZGVsLmdldFNoYWxsb3coJ3NpbGVudCcpO1xuICAgIC8vIEtlZXAgeCBhbmQgeVxuICAgIGlmICh0ZXh0Q29udGVudC5zdHlsZS54ICE9IG51bGwpIHtcbiAgICAgIG5vcm1hbFN0eWxlLnggPSB0ZXh0Q29udGVudC5zdHlsZS54O1xuICAgIH1cbiAgICBpZiAodGV4dENvbnRlbnQuc3R5bGUueSAhPSBudWxsKSB7XG4gICAgICBub3JtYWxTdHlsZS55ID0gdGV4dENvbnRlbnQuc3R5bGUueTtcbiAgICB9XG4gICAgdGV4dENvbnRlbnQuaWdub3JlID0gIXNob3dOb3JtYWw7XG4gICAgLy8gQWx3YXlzIGNyZWF0ZSBuZXcgc3R5bGUuXG4gICAgdGV4dENvbnRlbnQudXNlU3R5bGUobm9ybWFsU3R5bGUpO1xuICAgIHRleHRDb250ZW50LmRpcnR5KCk7XG4gICAgaWYgKG9wdC5lbmFibGVUZXh0U2V0dGVyKSB7XG4gICAgICBsYWJlbElubmVyKHRleHRDb250ZW50KS5zZXRMYWJlbFRleHQgPSBmdW5jdGlvbiAoaW50ZXJwb2xhdGVkVmFsdWUpIHtcbiAgICAgICAgdmFyIGxhYmVsU3RhdGVzVGV4dHMgPSBnZXRMYWJlbFRleHQob3B0LCBsYWJlbFN0YXRlc01vZGVscywgaW50ZXJwb2xhdGVkVmFsdWUpO1xuICAgICAgICBzZXRMYWJlbFRleHQodGV4dENvbnRlbnQsIGxhYmVsU3RhdGVzVGV4dHMpO1xuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGV4dENvbnRlbnQpIHtcbiAgICAvLyBOb3QgZGlzcGxheSByaWNoIHRleHQuXG4gICAgdGV4dENvbnRlbnQuaWdub3JlID0gdHJ1ZTtcbiAgfVxuICB0YXJnZXRFbC5kaXJ0eSgpO1xufVxuZXhwb3J0IHsgc2V0TGFiZWxTdHlsZSB9O1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhYmVsU3RhdGVzTW9kZWxzKGl0ZW1Nb2RlbCwgbGFiZWxOYW1lKSB7XG4gIGxhYmVsTmFtZSA9IGxhYmVsTmFtZSB8fCAnbGFiZWwnO1xuICB2YXIgc3RhdGVzTW9kZWxzID0ge1xuICAgIG5vcm1hbDogaXRlbU1vZGVsLmdldE1vZGVsKGxhYmVsTmFtZSlcbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBTUEVDSUFMX1NUQVRFUy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGF0ZU5hbWUgPSBTUEVDSUFMX1NUQVRFU1tpXTtcbiAgICBzdGF0ZXNNb2RlbHNbc3RhdGVOYW1lXSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChbc3RhdGVOYW1lLCBsYWJlbE5hbWVdKTtcbiAgfVxuICByZXR1cm4gc3RhdGVzTW9kZWxzO1xufVxuLyoqXHJcbiAqIFNldCBiYXNpYyB0ZXh0U3R5bGUgcHJvcGVydGllcy5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGV4dFN0eWxlKHRleHRTdHlsZU1vZGVsLCBzcGVjaWZpZWRUZXh0U3R5bGUsXG4vLyBGaXhlZCBzdHlsZSBpbiB0aGUgY29kZS4gQ2FuJ3QgYmUgc2V0IGJ5IG1vZGVsLlxub3B0LCBpc05vdE5vcm1hbCwgaXNBdHRhY2hlZCAvLyBJZiB0ZXh0IGlzIGF0dGFjaGVkIG9uIGFuIGVsZW1lbnQuIElmIHNvLCBhdXRvIGNvbG9yIHdpbGwgaGFuZGxpbmcgaW4genJlbmRlci5cbikge1xuICB2YXIgdGV4dFN0eWxlID0ge307XG4gIHNldFRleHRTdHlsZUNvbW1vbih0ZXh0U3R5bGUsIHRleHRTdHlsZU1vZGVsLCBvcHQsIGlzTm90Tm9ybWFsLCBpc0F0dGFjaGVkKTtcbiAgc3BlY2lmaWVkVGV4dFN0eWxlICYmIGV4dGVuZCh0ZXh0U3R5bGUsIHNwZWNpZmllZFRleHRTdHlsZSk7XG4gIC8vIHRleHRTdHlsZS5ob3N0ICYmIHRleHRTdHlsZS5ob3N0LmRpcnR5ICYmIHRleHRTdHlsZS5ob3N0LmRpcnR5KGZhbHNlKTtcbiAgcmV0dXJuIHRleHRTdHlsZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUZXh0Q29uZmlnKHRleHRTdHlsZU1vZGVsLCBvcHQsIGlzTm90Tm9ybWFsKSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIHRleHRDb25maWcgPSB7fTtcbiAgdmFyIGxhYmVsUG9zaXRpb247XG4gIHZhciBsYWJlbFJvdGF0ZSA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3JvdGF0ZScpO1xuICB2YXIgbGFiZWxEaXN0YW5jZSA9IHJldHJpZXZlMih0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdkaXN0YW5jZScpLCBpc05vdE5vcm1hbCA/IG51bGwgOiA1KTtcbiAgdmFyIGxhYmVsT2Zmc2V0ID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnb2Zmc2V0Jyk7XG4gIGxhYmVsUG9zaXRpb24gPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdwb3NpdGlvbicpIHx8IChpc05vdE5vcm1hbCA/IG51bGwgOiAnaW5zaWRlJyk7XG4gIC8vICdvdXRzaWRlJyBpcyBub3QgYSB2YWxpZCB6ciB0ZXh0UG9zdGlvbiB2YWx1ZSwgYnV0IHVzZWRcbiAgLy8gaW4gYmFyIHNlcmllcywgYW5kIG1hZ3JpYyB0eXBlIHNob3VsZCBiZSBjb25zaWRlcmVkLlxuICBsYWJlbFBvc2l0aW9uID09PSAnb3V0c2lkZScgJiYgKGxhYmVsUG9zaXRpb24gPSBvcHQuZGVmYXVsdE91dHNpZGVQb3NpdGlvbiB8fCAndG9wJyk7XG4gIGlmIChsYWJlbFBvc2l0aW9uICE9IG51bGwpIHtcbiAgICB0ZXh0Q29uZmlnLnBvc2l0aW9uID0gbGFiZWxQb3NpdGlvbjtcbiAgfVxuICBpZiAobGFiZWxPZmZzZXQgIT0gbnVsbCkge1xuICAgIHRleHRDb25maWcub2Zmc2V0ID0gbGFiZWxPZmZzZXQ7XG4gIH1cbiAgaWYgKGxhYmVsUm90YXRlICE9IG51bGwpIHtcbiAgICBsYWJlbFJvdGF0ZSAqPSBNYXRoLlBJIC8gMTgwO1xuICAgIHRleHRDb25maWcucm90YXRpb24gPSBsYWJlbFJvdGF0ZTtcbiAgfVxuICBpZiAobGFiZWxEaXN0YW5jZSAhPSBudWxsKSB7XG4gICAgdGV4dENvbmZpZy5kaXN0YW5jZSA9IGxhYmVsRGlzdGFuY2U7XG4gIH1cbiAgLy8gZmlsbCBhbmQgYXV0byBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBjb2xvciBvZiBwYXRoIGZpbGwgaWYgaXQncyBub3Qgc3BlY2lmaWVkIGJ5IGRldmVsb3BlcnMuXG4gIHRleHRDb25maWcub3V0c2lkZUZpbGwgPSB0ZXh0U3R5bGVNb2RlbC5nZXQoJ2NvbG9yJykgPT09ICdpbmhlcml0JyA/IG9wdC5pbmhlcml0Q29sb3IgfHwgbnVsbCA6ICdhdXRvJztcbiAgcmV0dXJuIHRleHRDb25maWc7XG59XG4vKipcclxuICogVGhlIHVuaWZvcm0gZW50cnkgb2Ygc2V0IHRleHQgc3R5bGUsIHRoYXQgaXMsIHJldHJpZXZlIHN0eWxlIGRlZmluaXRpb25zXHJcbiAqIGZyb20gYG1vZGVsYCBhbmQgc2V0IHRvIGB0ZXh0U3R5bGVgIG9iamVjdC5cclxuICpcclxuICogTmV2ZXIgaW4gbWVyZ2UgbW9kZSwgYnV0IGluIG92ZXJ3cml0ZSBtb2RlLCB0aGF0IGlzLCBhbGwgb2YgdGhlIHRleHQgc3R5bGVcclxuICogcHJvcGVydGllcyB3aWxsIGJlIHNldC4gKENvbnNpZGVyIHRoZSBzdGF0ZXMgb2Ygbm9ybWFsIGFuZCBlbXBoYXNpcyBhbmRcclxuICogZGVmYXVsdCB2YWx1ZSBjYW4gYmUgYWRvcHRlZCwgbWVyZ2Ugd291bGQgbWFrZSB0aGUgbG9naWMgdG9vIGNvbXBsaWNhdGVkXHJcbiAqIHRvIG1hbmFnZS4pXHJcbiAqL1xuZnVuY3Rpb24gc2V0VGV4dFN0eWxlQ29tbW9uKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIG9wdCwgaXNOb3ROb3JtYWwsIGlzQXR0YWNoZWQpIHtcbiAgLy8gQ29uc2lkZXIgdGhlcmUgd2lsbCBiZSBhYm5vcm1hbCB3aGVuIG1lcmdlIGhvdmVyIHN0eWxlIHRvIG5vcm1hbCBzdHlsZSBpZiBnaXZlbiBkZWZhdWx0IHZhbHVlLlxuICBvcHQgPSBvcHQgfHwgRU1QVFlfT0JKO1xuICB2YXIgZWNNb2RlbCA9IHRleHRTdHlsZU1vZGVsLmVjTW9kZWw7XG4gIHZhciBnbG9iYWxUZXh0U3R5bGUgPSBlY01vZGVsICYmIGVjTW9kZWwub3B0aW9uLnRleHRTdHlsZTtcbiAgLy8gQ29uc2lkZXIgY2FzZTpcbiAgLy8ge1xuICAvLyAgICAgZGF0YTogW3tcbiAgLy8gICAgICAgICB2YWx1ZTogMTIsXG4gIC8vICAgICAgICAgbGFiZWw6IHtcbiAgLy8gICAgICAgICAgICAgcmljaDoge1xuICAvLyAgICAgICAgICAgICAgICAgLy8gbm8gJ2EnIGhlcmUgYnV0IHVzaW5nIHBhcmVudCAnYScuXG4gIC8vICAgICAgICAgICAgIH1cbiAgLy8gICAgICAgICB9XG4gIC8vICAgICB9XSxcbiAgLy8gICAgIHJpY2g6IHtcbiAgLy8gICAgICAgICBhOiB7IC4uLiB9XG4gIC8vICAgICB9XG4gIC8vIH1cbiAgdmFyIHJpY2hJdGVtTmFtZXMgPSBnZXRSaWNoSXRlbU5hbWVzKHRleHRTdHlsZU1vZGVsKTtcbiAgdmFyIHJpY2hSZXN1bHQ7XG4gIGlmIChyaWNoSXRlbU5hbWVzKSB7XG4gICAgcmljaFJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIG5hbWVfMSBpbiByaWNoSXRlbU5hbWVzKSB7XG4gICAgICBpZiAocmljaEl0ZW1OYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lXzEpKSB7XG4gICAgICAgIC8vIENhc2NhZGUgaXMgc3VwcG9ydGVkIGluIHJpY2guXG4gICAgICAgIHZhciByaWNoVGV4dFN0eWxlID0gdGV4dFN0eWxlTW9kZWwuZ2V0TW9kZWwoWydyaWNoJywgbmFtZV8xXSk7XG4gICAgICAgIC8vIEluIHJpY2gsIG5ldmVyIGBkaXNhYmxlQm94YC5cbiAgICAgICAgLy8gRklYTUU6IGNvbnNpZGVyIGBsYWJlbDoge2Zvcm1hdHRlcjogJ3thfHh4fScsIGNvbG9yOiAnYmx1ZScsIHJpY2g6IHthOiB7fX19YCxcbiAgICAgICAgLy8gdGhlIGRlZmF1bHQgY29sb3IgYCdibHVlJ2Agd2lsbCBub3QgYmUgYWRvcHRlZCBpZiBubyBjb2xvciBkZWNsYXJlZCBpbiBgcmljaGAuXG4gICAgICAgIC8vIFRoYXQgbWlnaHQgY29uZnVzZXMgdXNlcnMuIFNvIHByb2JhYmx5IHdlIHNob3VsZCBwdXQgYHRleHRTdHlsZU1vZGVsYCBhcyB0aGVcbiAgICAgICAgLy8gcm9vdCBhbmNlc3RvciBvZiB0aGUgYHJpY2hUZXh0U3R5bGVgLiBCdXQgdGhhdCB3b3VsZCBiZSBhIGJyZWFrIGNoYW5nZS5cbiAgICAgICAgc2V0VG9rZW5UZXh0U3R5bGUocmljaFJlc3VsdFtuYW1lXzFdID0ge30sIHJpY2hUZXh0U3R5bGUsIGdsb2JhbFRleHRTdHlsZSwgb3B0LCBpc05vdE5vcm1hbCwgaXNBdHRhY2hlZCwgZmFsc2UsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmljaFJlc3VsdCkge1xuICAgIHRleHRTdHlsZS5yaWNoID0gcmljaFJlc3VsdDtcbiAgfVxuICB2YXIgb3ZlcmZsb3cgPSB0ZXh0U3R5bGVNb2RlbC5nZXQoJ292ZXJmbG93Jyk7XG4gIGlmIChvdmVyZmxvdykge1xuICAgIHRleHRTdHlsZS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICB9XG4gIHZhciBtYXJnaW4gPSB0ZXh0U3R5bGVNb2RlbC5nZXQoJ21pbk1hcmdpbicpO1xuICBpZiAobWFyZ2luICE9IG51bGwpIHtcbiAgICB0ZXh0U3R5bGUubWFyZ2luID0gbWFyZ2luO1xuICB9XG4gIHNldFRva2VuVGV4dFN0eWxlKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIGdsb2JhbFRleHRTdHlsZSwgb3B0LCBpc05vdE5vcm1hbCwgaXNBdHRhY2hlZCwgdHJ1ZSwgZmFsc2UpO1xufVxuLy8gQ29uc2lkZXIgY2FzZTpcbi8vIHtcbi8vICAgICBkYXRhOiBbe1xuLy8gICAgICAgICB2YWx1ZTogMTIsXG4vLyAgICAgICAgIGxhYmVsOiB7XG4vLyAgICAgICAgICAgICByaWNoOiB7XG4vLyAgICAgICAgICAgICAgICAgLy8gbm8gJ2EnIGhlcmUgYnV0IHVzaW5nIHBhcmVudCAnYScuXG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vICAgICB9XSxcbi8vICAgICByaWNoOiB7XG4vLyAgICAgICAgIGE6IHsgLi4uIH1cbi8vICAgICB9XG4vLyB9XG4vLyBUT0RPIFRleHRTdHlsZU1vZGVsXG5mdW5jdGlvbiBnZXRSaWNoSXRlbU5hbWVzKHRleHRTdHlsZU1vZGVsKSB7XG4gIC8vIFVzZSBvYmplY3QgdG8gcmVtb3ZlIGR1cGxpY2F0ZWQgbmFtZXMuXG4gIHZhciByaWNoSXRlbU5hbWVNYXA7XG4gIHdoaWxlICh0ZXh0U3R5bGVNb2RlbCAmJiB0ZXh0U3R5bGVNb2RlbCAhPT0gdGV4dFN0eWxlTW9kZWwuZWNNb2RlbCkge1xuICAgIHZhciByaWNoID0gKHRleHRTdHlsZU1vZGVsLm9wdGlvbiB8fCBFTVBUWV9PQkopLnJpY2g7XG4gICAgaWYgKHJpY2gpIHtcbiAgICAgIHJpY2hJdGVtTmFtZU1hcCA9IHJpY2hJdGVtTmFtZU1hcCB8fCB7fTtcbiAgICAgIHZhciByaWNoS2V5cyA9IGtleXMocmljaCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpY2hLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaWNoS2V5ID0gcmljaEtleXNbaV07XG4gICAgICAgIHJpY2hJdGVtTmFtZU1hcFtyaWNoS2V5XSA9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHRleHRTdHlsZU1vZGVsID0gdGV4dFN0eWxlTW9kZWwucGFyZW50TW9kZWw7XG4gIH1cbiAgcmV0dXJuIHJpY2hJdGVtTmFtZU1hcDtcbn1cbnZhciBURVhUX1BST1BTX1dJVEhfR0xPQkFMID0gWydmb250U3R5bGUnLCAnZm9udFdlaWdodCcsICdmb250U2l6ZScsICdmb250RmFtaWx5JywgJ3RleHRTaGFkb3dDb2xvcicsICd0ZXh0U2hhZG93Qmx1cicsICd0ZXh0U2hhZG93T2Zmc2V0WCcsICd0ZXh0U2hhZG93T2Zmc2V0WSddO1xudmFyIFRFWFRfUFJPUFNfU0VMRiA9IFsnYWxpZ24nLCAnbGluZUhlaWdodCcsICd3aWR0aCcsICdoZWlnaHQnLCAndGFnJywgJ3ZlcnRpY2FsQWxpZ24nLCAnZWxsaXBzaXMnXTtcbnZhciBURVhUX1BST1BTX0JPWCA9IFsncGFkZGluZycsICdib3JkZXJXaWR0aCcsICdib3JkZXJSYWRpdXMnLCAnYm9yZGVyRGFzaE9mZnNldCcsICdiYWNrZ3JvdW5kQ29sb3InLCAnYm9yZGVyQ29sb3InLCAnc2hhZG93Q29sb3InLCAnc2hhZG93Qmx1cicsICdzaGFkb3dPZmZzZXRYJywgJ3NoYWRvd09mZnNldFknXTtcbmZ1bmN0aW9uIHNldFRva2VuVGV4dFN0eWxlKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIGdsb2JhbFRleHRTdHlsZSwgb3B0LCBpc05vdE5vcm1hbCwgaXNBdHRhY2hlZCwgaXNCbG9jaywgaW5SaWNoKSB7XG4gIC8vIEluIG1lcmdlIG1vZGUsIGRlZmF1bHQgdmFsdWUgc2hvdWxkIG5vdCBiZSBnaXZlbi5cbiAgZ2xvYmFsVGV4dFN0eWxlID0gIWlzTm90Tm9ybWFsICYmIGdsb2JhbFRleHRTdHlsZSB8fCBFTVBUWV9PQko7XG4gIHZhciBpbmhlcml0Q29sb3IgPSBvcHQgJiYgb3B0LmluaGVyaXRDb2xvcjtcbiAgdmFyIGZpbGxDb2xvciA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2NvbG9yJyk7XG4gIHZhciBzdHJva2VDb2xvciA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3RleHRCb3JkZXJDb2xvcicpO1xuICB2YXIgb3BhY2l0eSA9IHJldHJpZXZlMih0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdvcGFjaXR5JyksIGdsb2JhbFRleHRTdHlsZS5vcGFjaXR5KTtcbiAgaWYgKGZpbGxDb2xvciA9PT0gJ2luaGVyaXQnIHx8IGZpbGxDb2xvciA9PT0gJ2F1dG8nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChmaWxsQ29sb3IgPT09ICdhdXRvJykge1xuICAgICAgICBkZXByZWNhdGVSZXBsYWNlTG9nKCdjb2xvcjogXFwnYXV0b1xcJycsICdjb2xvcjogXFwnaW5oZXJpdFxcJycpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5oZXJpdENvbG9yKSB7XG4gICAgICBmaWxsQ29sb3IgPSBpbmhlcml0Q29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGxDb2xvciA9IG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChzdHJva2VDb2xvciA9PT0gJ2luaGVyaXQnIHx8IHN0cm9rZUNvbG9yID09PSAnYXV0bycpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHN0cm9rZUNvbG9yID09PSAnYXV0bycpIHtcbiAgICAgICAgZGVwcmVjYXRlUmVwbGFjZUxvZygnY29sb3I6IFxcJ2F1dG9cXCcnLCAnY29sb3I6IFxcJ2luaGVyaXRcXCcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluaGVyaXRDb2xvcikge1xuICAgICAgc3Ryb2tlQ29sb3IgPSBpbmhlcml0Q29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cm9rZUNvbG9yID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc0F0dGFjaGVkKSB7XG4gICAgLy8gT25seSB1c2UgZGVmYXVsdCBnbG9iYWwgdGV4dFN0eWxlLmNvbG9yIGlmIHRleHQgaXMgaW5kaXZpZHVhbC5cbiAgICAvLyBPdGhlcndpc2UgaXQgd2lsbCB1c2UgdGhlIHN0cmF0ZWd5IG9mIGF0dGFjaGVkIHRleHQgY29sb3IgYmVjYXVzZSB0ZXh0IG1heSBiZSBvbiBhIHBhdGguXG4gICAgZmlsbENvbG9yID0gZmlsbENvbG9yIHx8IGdsb2JhbFRleHRTdHlsZS5jb2xvcjtcbiAgICBzdHJva2VDb2xvciA9IHN0cm9rZUNvbG9yIHx8IGdsb2JhbFRleHRTdHlsZS50ZXh0Qm9yZGVyQ29sb3I7XG4gIH1cbiAgaWYgKGZpbGxDb2xvciAhPSBudWxsKSB7XG4gICAgdGV4dFN0eWxlLmZpbGwgPSBmaWxsQ29sb3I7XG4gIH1cbiAgaWYgKHN0cm9rZUNvbG9yICE9IG51bGwpIHtcbiAgICB0ZXh0U3R5bGUuc3Ryb2tlID0gc3Ryb2tlQ29sb3I7XG4gIH1cbiAgdmFyIHRleHRCb3JkZXJXaWR0aCA9IHJldHJpZXZlMih0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCd0ZXh0Qm9yZGVyV2lkdGgnKSwgZ2xvYmFsVGV4dFN0eWxlLnRleHRCb3JkZXJXaWR0aCk7XG4gIGlmICh0ZXh0Qm9yZGVyV2lkdGggIT0gbnVsbCkge1xuICAgIHRleHRTdHlsZS5saW5lV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGg7XG4gIH1cbiAgdmFyIHRleHRCb3JkZXJUeXBlID0gcmV0cmlldmUyKHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3RleHRCb3JkZXJUeXBlJyksIGdsb2JhbFRleHRTdHlsZS50ZXh0Qm9yZGVyVHlwZSk7XG4gIGlmICh0ZXh0Qm9yZGVyVHlwZSAhPSBudWxsKSB7XG4gICAgdGV4dFN0eWxlLmxpbmVEYXNoID0gdGV4dEJvcmRlclR5cGU7XG4gIH1cbiAgdmFyIHRleHRCb3JkZXJEYXNoT2Zmc2V0ID0gcmV0cmlldmUyKHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3RleHRCb3JkZXJEYXNoT2Zmc2V0JyksIGdsb2JhbFRleHRTdHlsZS50ZXh0Qm9yZGVyRGFzaE9mZnNldCk7XG4gIGlmICh0ZXh0Qm9yZGVyRGFzaE9mZnNldCAhPSBudWxsKSB7XG4gICAgdGV4dFN0eWxlLmxpbmVEYXNoT2Zmc2V0ID0gdGV4dEJvcmRlckRhc2hPZmZzZXQ7XG4gIH1cbiAgaWYgKCFpc05vdE5vcm1hbCAmJiBvcGFjaXR5ID09IG51bGwgJiYgIWluUmljaCkge1xuICAgIG9wYWNpdHkgPSBvcHQgJiYgb3B0LmRlZmF1bHRPcGFjaXR5O1xuICB9XG4gIGlmIChvcGFjaXR5ICE9IG51bGwpIHtcbiAgICB0ZXh0U3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XG4gIH1cbiAgLy8gVE9ET1xuICBpZiAoIWlzTm90Tm9ybWFsICYmICFpc0F0dGFjaGVkKSB7XG4gICAgLy8gU2V0IGRlZmF1bHQgZmluYWxseS5cbiAgICBpZiAodGV4dFN0eWxlLmZpbGwgPT0gbnVsbCAmJiBvcHQuaW5oZXJpdENvbG9yKSB7XG4gICAgICB0ZXh0U3R5bGUuZmlsbCA9IG9wdC5pbmhlcml0Q29sb3I7XG4gICAgfVxuICB9XG4gIC8vIERvIG5vdCB1c2UgYGdldEZvbnRgIGhlcmUsIGJlY2F1c2UgbWVyZ2Ugc2hvdWxkIGJlIHN1cHBvcnRlZCwgd2hlcmVcbiAgLy8gcGFydCBvZiB0aGVzZSBwcm9wZXJ0aWVzIG1heSBiZSBjaGFuZ2VkIGluIGVtcGhhc2lzIHN0eWxlLCBhbmQgdGhlXG4gIC8vIG90aGVycyBzaG91bGQgcmVtYWluIHRoZWlyIG9yaWdpbmFsIHZhbHVlIGdvdCBmcm9tIG5vcm1hbCBzdHlsZS5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBURVhUX1BST1BTX1dJVEhfR0xPQkFMLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IFRFWFRfUFJPUFNfV0lUSF9HTE9CQUxbaV07XG4gICAgdmFyIHZhbCA9IHJldHJpZXZlMih0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KGtleSksIGdsb2JhbFRleHRTdHlsZVtrZXldKTtcbiAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgIHRleHRTdHlsZVtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IFRFWFRfUFJPUFNfU0VMRi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBURVhUX1BST1BTX1NFTEZbaV07XG4gICAgdmFyIHZhbCA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coa2V5KTtcbiAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgIHRleHRTdHlsZVtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICBpZiAodGV4dFN0eWxlLnZlcnRpY2FsQWxpZ24gPT0gbnVsbCkge1xuICAgIHZhciBiYXNlbGluZSA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2Jhc2VsaW5lJyk7XG4gICAgaWYgKGJhc2VsaW5lICE9IG51bGwpIHtcbiAgICAgIHRleHRTdHlsZS52ZXJ0aWNhbEFsaWduID0gYmFzZWxpbmU7XG4gICAgfVxuICB9XG4gIGlmICghaXNCbG9jayB8fCAhb3B0LmRpc2FibGVCb3gpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFRFWFRfUFJPUFNfQk9YLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gVEVYVF9QUk9QU19CT1hbaV07XG4gICAgICB2YXIgdmFsID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdyhrZXkpO1xuICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgIHRleHRTdHlsZVtrZXldID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYm9yZGVyVHlwZSA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2JvcmRlclR5cGUnKTtcbiAgICBpZiAoYm9yZGVyVHlwZSAhPSBudWxsKSB7XG4gICAgICB0ZXh0U3R5bGUuYm9yZGVyRGFzaCA9IGJvcmRlclR5cGU7XG4gICAgfVxuICAgIGlmICgodGV4dFN0eWxlLmJhY2tncm91bmRDb2xvciA9PT0gJ2F1dG8nIHx8IHRleHRTdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPT09ICdpbmhlcml0JykgJiYgaW5oZXJpdENvbG9yKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGV4dFN0eWxlLmJhY2tncm91bmRDb2xvciA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgZGVwcmVjYXRlUmVwbGFjZUxvZygnYmFja2dyb3VuZENvbG9yOiBcXCdhdXRvXFwnJywgJ2JhY2tncm91bmRDb2xvcjogXFwnaW5oZXJpdFxcJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZXh0U3R5bGUuYmFja2dyb3VuZENvbG9yID0gaW5oZXJpdENvbG9yO1xuICAgIH1cbiAgICBpZiAoKHRleHRTdHlsZS5ib3JkZXJDb2xvciA9PT0gJ2F1dG8nIHx8IHRleHRTdHlsZS5ib3JkZXJDb2xvciA9PT0gJ2luaGVyaXQnKSAmJiBpbmhlcml0Q29sb3IpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0ZXh0U3R5bGUuYm9yZGVyQ29sb3IgPT09ICdhdXRvJykge1xuICAgICAgICAgIGRlcHJlY2F0ZVJlcGxhY2VMb2coJ2JvcmRlckNvbG9yOiBcXCdhdXRvXFwnJywgJ2JvcmRlckNvbG9yOiBcXCdpbmhlcml0XFwnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRleHRTdHlsZS5ib3JkZXJDb2xvciA9IGluaGVyaXRDb2xvcjtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb250KG9wdCwgZWNNb2RlbCkge1xuICB2YXIgZ1RleHRTdHlsZU1vZGVsID0gZWNNb2RlbCAmJiBlY01vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgcmV0dXJuIHRyaW0oW1xuICAvLyBGSVhNRSBpbiBub2RlLWNhbnZhcyBmb250V2VpZ2h0IGlzIGJlZm9yZSBmb250U3R5bGVcbiAgb3B0LmZvbnRTdHlsZSB8fCBnVGV4dFN0eWxlTW9kZWwgJiYgZ1RleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRTdHlsZScpIHx8ICcnLCBvcHQuZm9udFdlaWdodCB8fCBnVGV4dFN0eWxlTW9kZWwgJiYgZ1RleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRXZWlnaHQnKSB8fCAnJywgKG9wdC5mb250U2l6ZSB8fCBnVGV4dFN0eWxlTW9kZWwgJiYgZ1RleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRTaXplJykgfHwgMTIpICsgJ3B4Jywgb3B0LmZvbnRGYW1pbHkgfHwgZ1RleHRTdHlsZU1vZGVsICYmIGdUZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdmb250RmFtaWx5JykgfHwgJ3NhbnMtc2VyaWYnXS5qb2luKCcgJykpO1xufVxuZXhwb3J0IHZhciBsYWJlbElubmVyID0gbWFrZUlubmVyKCk7XG5leHBvcnQgZnVuY3Rpb24gc2V0TGFiZWxWYWx1ZUFuaW1hdGlvbihsYWJlbCwgbGFiZWxTdGF0ZXNNb2RlbHMsIHZhbHVlLCBnZXREZWZhdWx0VGV4dCkge1xuICBpZiAoIWxhYmVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvYmogPSBsYWJlbElubmVyKGxhYmVsKTtcbiAgb2JqLnByZXZWYWx1ZSA9IG9iai52YWx1ZTtcbiAgb2JqLnZhbHVlID0gdmFsdWU7XG4gIHZhciBub3JtYWxMYWJlbE1vZGVsID0gbGFiZWxTdGF0ZXNNb2RlbHMubm9ybWFsO1xuICBvYmoudmFsdWVBbmltYXRpb24gPSBub3JtYWxMYWJlbE1vZGVsLmdldCgndmFsdWVBbmltYXRpb24nKTtcbiAgaWYgKG9iai52YWx1ZUFuaW1hdGlvbikge1xuICAgIG9iai5wcmVjaXNpb24gPSBub3JtYWxMYWJlbE1vZGVsLmdldCgncHJlY2lzaW9uJyk7XG4gICAgb2JqLmRlZmF1bHRJbnRlcnBvbGF0ZWRUZXh0ID0gZ2V0RGVmYXVsdFRleHQ7XG4gICAgb2JqLnN0YXRlc01vZGVscyA9IGxhYmVsU3RhdGVzTW9kZWxzO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYW5pbWF0ZUxhYmVsVmFsdWUodGV4dEVsLCBkYXRhSW5kZXgsIGRhdGEsIGFuaW1hdGFibGVNb2RlbCwgbGFiZWxGZXRjaGVyKSB7XG4gIHZhciBsYWJlbElubmVyU3RvcmUgPSBsYWJlbElubmVyKHRleHRFbCk7XG4gIGlmICghbGFiZWxJbm5lclN0b3JlLnZhbHVlQW5pbWF0aW9uIHx8IGxhYmVsSW5uZXJTdG9yZS5wcmV2VmFsdWUgPT09IGxhYmVsSW5uZXJTdG9yZS52YWx1ZSkge1xuICAgIC8vIFZhbHVlIG5vdCBjaGFuZ2VkLCBubyBuZXcgbGFiZWwgYW5pbWF0aW9uXG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBkZWZhdWx0SW50ZXJwb2xhdGVkVGV4dCA9IGxhYmVsSW5uZXJTdG9yZS5kZWZhdWx0SW50ZXJwb2xhdGVkVGV4dDtcbiAgLy8gQ29uc2lkZXIgdGhlIGNhc2UgdGhhdCBiZWluZyBhbmltYXRpbmcsIGRvIG5vdCB1c2UgdGhlIGBvYmoudmFsdWVgLFxuICAvLyBPdGhlcndpc2UgaXQgd2lsbCBqdW1wIHRvIHRoZSBgb2JqLnZhbHVlYCB3aGVuIHRoaXMgbmV3IGFuaW1hdGlvbiBzdGFydGVkLlxuICB2YXIgY3VyclZhbHVlID0gcmV0cmlldmUyKGxhYmVsSW5uZXJTdG9yZS5pbnRlcnBvbGF0ZWRWYWx1ZSwgbGFiZWxJbm5lclN0b3JlLnByZXZWYWx1ZSk7XG4gIHZhciB0YXJnZXRWYWx1ZSA9IGxhYmVsSW5uZXJTdG9yZS52YWx1ZTtcbiAgZnVuY3Rpb24gZHVyaW5nKHBlcmNlbnQpIHtcbiAgICB2YXIgaW50ZXJwb2xhdGVkID0gaW50ZXJwb2xhdGVSYXdWYWx1ZXMoZGF0YSwgbGFiZWxJbm5lclN0b3JlLnByZWNpc2lvbiwgY3VyclZhbHVlLCB0YXJnZXRWYWx1ZSwgcGVyY2VudCk7XG4gICAgbGFiZWxJbm5lclN0b3JlLmludGVycG9sYXRlZFZhbHVlID0gcGVyY2VudCA9PT0gMSA/IG51bGwgOiBpbnRlcnBvbGF0ZWQ7XG4gICAgdmFyIGxhYmVsVGV4dCA9IGdldExhYmVsVGV4dCh7XG4gICAgICBsYWJlbERhdGFJbmRleDogZGF0YUluZGV4LFxuICAgICAgbGFiZWxGZXRjaGVyOiBsYWJlbEZldGNoZXIsXG4gICAgICBkZWZhdWx0VGV4dDogZGVmYXVsdEludGVycG9sYXRlZFRleHQgPyBkZWZhdWx0SW50ZXJwb2xhdGVkVGV4dChpbnRlcnBvbGF0ZWQpIDogaW50ZXJwb2xhdGVkICsgJydcbiAgICB9LCBsYWJlbElubmVyU3RvcmUuc3RhdGVzTW9kZWxzLCBpbnRlcnBvbGF0ZWQpO1xuICAgIHNldExhYmVsVGV4dCh0ZXh0RWwsIGxhYmVsVGV4dCk7XG4gIH1cbiAgdGV4dEVsLnBlcmNlbnQgPSAwO1xuICAobGFiZWxJbm5lclN0b3JlLnByZXZWYWx1ZSA9PSBudWxsID8gaW5pdFByb3BzIDogdXBkYXRlUHJvcHMpKHRleHRFbCwge1xuICAgIC8vIHBlcmNlbnQgaXMgdXNlZCB0byBwcmV2ZW50IGFuaW1hdGlvbiBmcm9tIGJlaW5nIGFib3J0ZWQgIzE1OTE2XG4gICAgcGVyY2VudDogMVxuICB9LCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgbnVsbCwgZHVyaW5nKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///89632\n")},92621:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QK: () => (/* binding */ limitSurfaceAngle),\n/* harmony export */   YI: () => (/* binding */ limitTurnAngle),\n/* harmony export */   eR: () => (/* binding */ setLabelLineStyle),\n/* harmony export */   lB: () => (/* binding */ updateLabelLinePoints),\n/* harmony export */   rv: () => (/* binding */ getLabelLineStatesModels)\n/* harmony export */ });\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26346);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(59482);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(39195);\n/* harmony import */ var zrender_lib_core_PathProxy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68717);\n/* harmony import */ var zrender_lib_contain_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41589);\n/* harmony import */ var zrender_lib_core_curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89259);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(98026);\n/* harmony import */ var zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45587);\n/* harmony import */ var zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(83509);\n/* harmony import */ var _util_states_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(34833);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nvar PI2 = Math.PI * 2;\nvar CMD = zrender_lib_core_PathProxy_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.CMD;\nvar DEFAULT_SEARCH_SPACE = [\'top\', \'right\', \'bottom\', \'left\'];\nfunction getCandidateAnchor(pos, distance, rect, outPt, outDir) {\n  var width = rect.width;\n  var height = rect.height;\n  switch (pos) {\n    case \'top\':\n      outPt.set(rect.x + width / 2, rect.y - distance);\n      outDir.set(0, -1);\n      break;\n    case \'bottom\':\n      outPt.set(rect.x + width / 2, rect.y + height + distance);\n      outDir.set(0, 1);\n      break;\n    case \'left\':\n      outPt.set(rect.x - distance, rect.y + height / 2);\n      outDir.set(-1, 0);\n      break;\n    case \'right\':\n      outPt.set(rect.x + width + distance, rect.y + height / 2);\n      outDir.set(1, 0);\n      break;\n  }\n}\nfunction projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out) {\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n  x /= d;\n  y /= d;\n  // Intersect point.\n  var ox = x * r + cx;\n  var oy = y * r + cy;\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = (0,zrender_lib_contain_util_js__WEBPACK_IMPORTED_MODULE_1__/* .normalizeRadian */ .n)(endAngle);\n    endAngle = (0,zrender_lib_contain_util_js__WEBPACK_IMPORTED_MODULE_1__/* .normalizeRadian */ .n)(tmp);\n  } else {\n    startAngle = (0,zrender_lib_contain_util_js__WEBPACK_IMPORTED_MODULE_1__/* .normalizeRadian */ .n)(startAngle);\n    endAngle = (0,zrender_lib_contain_util_js__WEBPACK_IMPORTED_MODULE_1__/* .normalizeRadian */ .n)(endAngle);\n  }\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n  var angle = Math.atan2(y, x);\n  if (angle < 0) {\n    angle += PI2;\n  }\n  if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n    // Project point is on the arc.\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n  var x1 = r * Math.cos(startAngle) + cx;\n  var y1 = r * Math.sin(startAngle) + cy;\n  var x2 = r * Math.cos(endAngle) + cx;\n  var y2 = r * Math.sin(endAngle) + cy;\n  var d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);\n  var d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);\n  if (d1 < d2) {\n    out[0] = x1;\n    out[1] = y1;\n    return Math.sqrt(d1);\n  } else {\n    out[0] = x2;\n    out[1] = y2;\n    return Math.sqrt(d2);\n  }\n}\nfunction projectPointToLine(x1, y1, x2, y2, x, y, out, limitToEnds) {\n  var dx = x - x1;\n  var dy = y - y1;\n  var dx1 = x2 - x1;\n  var dy1 = y2 - y1;\n  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n  dx1 /= lineLen;\n  dy1 /= lineLen;\n  // dot product\n  var projectedLen = dx * dx1 + dy * dy1;\n  var t = projectedLen / lineLen;\n  if (limitToEnds) {\n    t = Math.min(Math.max(t, 0), 1);\n  }\n  t *= lineLen;\n  var ox = out[0] = x1 + t * dx1;\n  var oy = out[1] = y1 + t * dy1;\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\nfunction projectPointToRect(x1, y1, width, height, x, y, out) {\n  if (width < 0) {\n    x1 = x1 + width;\n    width = -width;\n  }\n  if (height < 0) {\n    y1 = y1 + height;\n    height = -height;\n  }\n  var x2 = x1 + width;\n  var y2 = y1 + height;\n  var ox = out[0] = Math.min(Math.max(x, x1), x2);\n  var oy = out[1] = Math.min(Math.max(y, y1), y2);\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\nvar tmpPt = [];\nfunction nearestPointOnRect(pt, rect, out) {\n  var dist = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);\n  out.set(tmpPt[0], tmpPt[1]);\n  return dist;\n}\n/**\r\n * Calculate min distance corresponding point.\r\n * This method won\'t evaluate if point is in the path.\r\n */\nfunction nearestPointOnPath(pt, path, out) {\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n  var x1;\n  var y1;\n  var minDist = Infinity;\n  var data = path.data;\n  var x = pt.x;\n  var y = pt.y;\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++];\n    if (i === 1) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n    var d = minDist;\n    switch (cmd) {\n      case CMD.M:\n        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n        // 在 closePath 的时候使用\n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n      case CMD.L:\n        d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n      case CMD.C:\n        d = (0,zrender_lib_core_curve_js__WEBPACK_IMPORTED_MODULE_2__/* .cubicProjectPoint */ .Et)(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n      case CMD.Q:\n        d = (0,zrender_lib_core_curve_js__WEBPACK_IMPORTED_MODULE_2__/* .quadraticProjectPoint */ .kh)(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n      case CMD.A:\n        // TODO Arc 判断的开销比较大\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++];\n        // TODO Arc 旋转\n        i += 1;\n        var anticlockwise = !!(1 - data[i++]);\n        x1 = Math.cos(theta) * rx + cx;\n        y1 = Math.sin(theta) * ry + cy;\n        // 不是直接使用 arc 命令\n        if (i <= 1) {\n          // 第一个命令起点还未定义\n          x0 = x1;\n          y0 = y1;\n        }\n        // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n        var _x = (x - cx) * ry / rx + cx;\n        d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);\n        break;\n      case CMD.Z:\n        d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n    if (d < minDist) {\n      minDist = d;\n      out.set(tmpPt[0], tmpPt[1]);\n    }\n  }\n  return minDist;\n}\n// Temporal variable for intermediate usage.\nvar pt0 = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A();\nvar pt1 = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A();\nvar pt2 = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A();\nvar dir = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A();\nvar dir2 = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A();\n/**\r\n * Calculate a proper guide line based on the label position and graphic element definition\r\n * @param label\r\n * @param labelRect\r\n * @param target\r\n * @param targetRect\r\n */\nfunction updateLabelLinePoints(target, labelLineModel) {\n  if (!target) {\n    return;\n  }\n  var labelLine = target.getTextGuideLine();\n  var label = target.getTextContent();\n  // Needs to create text guide in each charts.\n  if (!(label && labelLine)) {\n    return;\n  }\n  var labelGuideConfig = target.textGuideLineConfig || {};\n  var points = [[0, 0], [0, 0], [0, 0]];\n  var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;\n  var labelRect = label.getBoundingRect().clone();\n  labelRect.applyTransform(label.getComputedTransform());\n  var minDist = Infinity;\n  var anchorPoint = labelGuideConfig.anchor;\n  var targetTransform = target.getComputedTransform();\n  var targetInversedTransform = targetTransform && (0,zrender_lib_core_matrix_js__WEBPACK_IMPORTED_MODULE_4__.invert)([], targetTransform);\n  var len = labelLineModel.get(\'length2\') || 0;\n  if (anchorPoint) {\n    pt2.copy(anchorPoint);\n  }\n  for (var i = 0; i < searchSpace.length; i++) {\n    var candidate = searchSpace[i];\n    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.scaleAndAdd(pt1, pt0, dir, len);\n    // Transform to target coord space.\n    pt1.transform(targetInversedTransform);\n    // Note: getBoundingRect will ensure the `path` being created.\n    var boundingRect = target.getBoundingRect();\n    var dist = anchorPoint ? anchorPoint.distance(pt1) : target instanceof _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Ay ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2);\n    // TODO pt2 is in the path\n    if (dist < minDist) {\n      minDist = dist;\n      // Transform back to global space.\n      pt1.transform(targetTransform);\n      pt2.transform(targetTransform);\n      pt2.toArray(points[0]);\n      pt1.toArray(points[1]);\n      pt0.toArray(points[2]);\n    }\n  }\n  limitTurnAngle(points, labelLineModel.get(\'minTurnAngle\'));\n  labelLine.setShape({\n    points: points\n  });\n}\n// Temporal variable for the limitTurnAngle function\nvar tmpArr = [];\nvar tmpProjPoint = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A();\n/**\r\n * Reduce the line segment attached to the label to limit the turn angle between two segments.\r\n * @param linePoints\r\n * @param minTurnAngle Radian of minimum turn angle. 0 - 180\r\n */\nfunction limitTurnAngle(linePoints, minTurnAngle) {\n  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {\n    return;\n  }\n  minTurnAngle = minTurnAngle / 180 * Math.PI;\n  // The line points can be\n  //      /pt1----pt2 (label)\n  //     /\n  // pt0/\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.sub(dir, pt0, pt1);\n  _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(dir2);\n  var minTurnAngleCos = Math.cos(minTurnAngle);\n  if (minTurnAngleCos < angleCos) {\n    // Smaller than minTurnAngle\n    // Calculate project point of pt0 on pt1-pt2\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr);\n    // Calculate new projected length with limited minTurnAngle and get the new connect point\n    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle));\n    // Limit the new calculated connect point between pt1 and pt2.\n    var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n    if (isNaN(t)) {\n      return;\n    }\n    if (t < 0) {\n      _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.copy(tmpProjPoint, pt1);\n    } else if (t > 1) {\n      _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.copy(tmpProjPoint, pt2);\n    }\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\n/**\r\n * Limit the angle of line and the surface\r\n * @param maxSurfaceAngle Radian of minimum turn angle. 0 - 180. 0 is same direction to normal. 180 is opposite\r\n */\nfunction limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {\n  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {\n    return;\n  }\n  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.sub(dir, pt1, pt0);\n  _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(surfaceNormal);\n  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);\n  if (angleCos < maxSurfaceAngleCos) {\n    // Calculate project point of pt0 on pt1-pt2\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr);\n    var HALF_PI = Math.PI / 2;\n    var angle2 = Math.acos(dir2.dot(surfaceNormal));\n    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;\n    if (newAngle >= HALF_PI) {\n      // parallel\n      _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.copy(tmpProjPoint, pt2);\n    } else {\n      // Calculate new projected length with limited minTurnAngle and get the new connect point\n      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle));\n      // Limit the new calculated connect point between pt1 and pt2.\n      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n      if (isNaN(t)) {\n        return;\n      }\n      if (t < 0) {\n        _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.copy(tmpProjPoint, pt1);\n      } else if (t > 1) {\n        _util_graphic_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.copy(tmpProjPoint, pt2);\n      }\n    }\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\nfunction setLabelLineState(labelLine, ignore, stateName, stateModel) {\n  var isNormal = stateName === \'normal\';\n  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);\n  // Make sure display.\n  stateObj.ignore = ignore;\n  // Set smooth\n  var smooth = stateModel.get(\'smooth\');\n  if (smooth && smooth === true) {\n    smooth = 0.3;\n  }\n  stateObj.shape = stateObj.shape || {};\n  if (smooth > 0) {\n    stateObj.shape.smooth = smooth;\n  }\n  var styleObj = stateModel.getModel(\'lineStyle\').getLineStyle();\n  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;\n}\nfunction buildLabelLinePath(path, shape) {\n  var smooth = shape.smooth;\n  var points = shape.points;\n  if (!points) {\n    return;\n  }\n  path.moveTo(points[0][0], points[0][1]);\n  if (smooth > 0 && points.length >= 3) {\n    var len1 = zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_6__.dist(points[0], points[1]);\n    var len2 = zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_6__.dist(points[1], points[2]);\n    if (!len1 || !len2) {\n      path.lineTo(points[1][0], points[1][1]);\n      path.lineTo(points[2][0], points[2][1]);\n      return;\n    }\n    var moveLen = Math.min(len1, len2) * smooth;\n    var midPoint0 = zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_6__.lerp([], points[1], points[0], moveLen / len1);\n    var midPoint2 = zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_6__.lerp([], points[1], points[2], moveLen / len2);\n    var midPoint1 = zrender_lib_core_vector_js__WEBPACK_IMPORTED_MODULE_6__.lerp([], midPoint0, midPoint2, 0.5);\n    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);\n    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points[2][0], points[2][1]);\n  } else {\n    for (var i = 1; i < points.length; i++) {\n      path.lineTo(points[i][0], points[i][1]);\n    }\n  }\n}\n/**\r\n * Create a label line if necessary and set it\'s style.\r\n */\nfunction setLabelLineStyle(targetEl, statesModels, defaultStyle) {\n  var labelLine = targetEl.getTextGuideLine();\n  var label = targetEl.getTextContent();\n  if (!label) {\n    // Not show label line if there is no label.\n    if (labelLine) {\n      targetEl.removeTextGuideLine();\n    }\n    return;\n  }\n  var normalModel = statesModels.normal;\n  var showNormal = normalModel.get(\'show\');\n  var labelIgnoreNormal = label.ignore;\n  for (var i = 0; i < _util_states_js__WEBPACK_IMPORTED_MODULE_7__/* .DISPLAY_STATES */ .wV.length; i++) {\n    var stateName = _util_states_js__WEBPACK_IMPORTED_MODULE_7__/* .DISPLAY_STATES */ .wV[i];\n    var stateModel = statesModels[stateName];\n    var isNormal = stateName === \'normal\';\n    if (stateModel) {\n      var stateShow = stateModel.get(\'show\');\n      var isLabelIgnored = isNormal ? labelIgnoreNormal : (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_8__.retrieve2)(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);\n      if (isLabelIgnored // Not show when label is not shown in this state.\n      || !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_8__.retrieve2)(stateShow, showNormal) // Use normal state by default if not set.\n      ) {\n        var stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];\n        if (stateObj) {\n          stateObj.ignore = true;\n        }\n        if (!!labelLine) {\n          setLabelLineState(labelLine, true, stateName, stateModel);\n        }\n        continue;\n      }\n      // Create labelLine if not exists\n      if (!labelLine) {\n        labelLine = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A();\n        targetEl.setTextGuideLine(labelLine);\n        // Reset state of normal because it\'s new created.\n        // NOTE: NORMAL should always been the first!\n        if (!isNormal && (labelIgnoreNormal || !showNormal)) {\n          setLabelLineState(labelLine, true, \'normal\', statesModels.normal);\n        }\n        // Use same state proxy.\n        if (targetEl.stateProxy) {\n          labelLine.stateProxy = targetEl.stateProxy;\n        }\n      }\n      setLabelLineState(labelLine, false, stateName, stateModel);\n    }\n  }\n  if (labelLine) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_8__.defaults)(labelLine.style, defaultStyle);\n    // Not fill.\n    labelLine.style.fill = null;\n    var showAbove = normalModel.get(\'showAbove\');\n    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};\n    labelLineConfig.showAbove = showAbove || false;\n    // Custom the buildPath.\n    labelLine.buildPath = buildLabelLinePath;\n  }\n}\nfunction getLabelLineStatesModels(itemModel, labelLineName) {\n  labelLineName = labelLineName || \'labelLine\';\n  var statesModels = {\n    normal: itemModel.getModel(labelLineName)\n  };\n  for (var i = 0; i < _util_states_js__WEBPACK_IMPORTED_MODULE_7__/* .SPECIAL_STATES */ .BV.length; i++) {\n    var stateName = _util_states_js__WEBPACK_IMPORTED_MODULE_7__/* .SPECIAL_STATES */ .BV[i];\n    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);\n  }\n  return statesModels;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI2MjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sYWJlbC9sYWJlbEd1aWRlSGVscGVyLmpzPzBlMGQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBQb2ludCwgUGF0aCwgUG9seWxpbmUgfSBmcm9tICcuLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0IFBhdGhQcm94eSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVSYWRpYW4gfSBmcm9tICd6cmVuZGVyL2xpYi9jb250YWluL3V0aWwuanMnO1xuaW1wb3J0IHsgY3ViaWNQcm9qZWN0UG9pbnQsIHF1YWRyYXRpY1Byb2plY3RQb2ludCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvY3VydmUuanMnO1xuaW1wb3J0IHsgZGVmYXVsdHMsIHJldHJpZXZlMiB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBpbnZlcnQgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qcyc7XG5pbXBvcnQgKiBhcyB2ZWN0b3IgZnJvbSAnenJlbmRlci9saWIvY29yZS92ZWN0b3IuanMnO1xuaW1wb3J0IHsgRElTUExBWV9TVEFURVMsIFNQRUNJQUxfU1RBVEVTIH0gZnJvbSAnLi4vdXRpbC9zdGF0ZXMuanMnO1xudmFyIFBJMiA9IE1hdGguUEkgKiAyO1xudmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG52YXIgREVGQVVMVF9TRUFSQ0hfU1BBQ0UgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlQW5jaG9yKHBvcywgZGlzdGFuY2UsIHJlY3QsIG91dFB0LCBvdXREaXIpIHtcbiAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBvdXRQdC5zZXQocmVjdC54ICsgd2lkdGggLyAyLCByZWN0LnkgLSBkaXN0YW5jZSk7XG4gICAgICBvdXREaXIuc2V0KDAsIC0xKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICBvdXRQdC5zZXQocmVjdC54ICsgd2lkdGggLyAyLCByZWN0LnkgKyBoZWlnaHQgKyBkaXN0YW5jZSk7XG4gICAgICBvdXREaXIuc2V0KDAsIDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICBvdXRQdC5zZXQocmVjdC54IC0gZGlzdGFuY2UsIHJlY3QueSArIGhlaWdodCAvIDIpO1xuICAgICAgb3V0RGlyLnNldCgtMSwgMCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBvdXRQdC5zZXQocmVjdC54ICsgd2lkdGggKyBkaXN0YW5jZSwgcmVjdC55ICsgaGVpZ2h0IC8gMik7XG4gICAgICBvdXREaXIuc2V0KDEsIDApO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2plY3RQb2ludFRvQXJjKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHgsIHksIG91dCkge1xuICB4IC09IGN4O1xuICB5IC09IGN5O1xuICB2YXIgZCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgeCAvPSBkO1xuICB5IC89IGQ7XG4gIC8vIEludGVyc2VjdCBwb2ludC5cbiAgdmFyIG94ID0geCAqIHIgKyBjeDtcbiAgdmFyIG95ID0geSAqIHIgKyBjeTtcbiAgaWYgKE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSkgJSBQSTIgPCAxZS00KSB7XG4gICAgLy8gSXMgYSBjaXJjbGVcbiAgICBvdXRbMF0gPSBveDtcbiAgICBvdXRbMV0gPSBveTtcbiAgICByZXR1cm4gZCAtIHI7XG4gIH1cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICB9XG4gIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICBlbmRBbmdsZSArPSBQSTI7XG4gIH1cbiAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4KTtcbiAgaWYgKGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlICs9IFBJMjtcbiAgfVxuICBpZiAoYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSB8fCBhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKSB7XG4gICAgLy8gUHJvamVjdCBwb2ludCBpcyBvbiB0aGUgYXJjLlxuICAgIG91dFswXSA9IG94O1xuICAgIG91dFsxXSA9IG95O1xuICAgIHJldHVybiBkIC0gcjtcbiAgfVxuICB2YXIgeDEgPSByICogTWF0aC5jb3Moc3RhcnRBbmdsZSkgKyBjeDtcbiAgdmFyIHkxID0gciAqIE1hdGguc2luKHN0YXJ0QW5nbGUpICsgY3k7XG4gIHZhciB4MiA9IHIgKiBNYXRoLmNvcyhlbmRBbmdsZSkgKyBjeDtcbiAgdmFyIHkyID0gciAqIE1hdGguc2luKGVuZEFuZ2xlKSArIGN5O1xuICB2YXIgZDEgPSAoeDEgLSB4KSAqICh4MSAtIHgpICsgKHkxIC0geSkgKiAoeTEgLSB5KTtcbiAgdmFyIGQyID0gKHgyIC0geCkgKiAoeDIgLSB4KSArICh5MiAtIHkpICogKHkyIC0geSk7XG4gIGlmIChkMSA8IGQyKSB7XG4gICAgb3V0WzBdID0geDE7XG4gICAgb3V0WzFdID0geTE7XG4gICAgcmV0dXJuIE1hdGguc3FydChkMSk7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0geDI7XG4gICAgb3V0WzFdID0geTI7XG4gICAgcmV0dXJuIE1hdGguc3FydChkMik7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2plY3RQb2ludFRvTGluZSh4MSwgeTEsIHgyLCB5MiwgeCwgeSwgb3V0LCBsaW1pdFRvRW5kcykge1xuICB2YXIgZHggPSB4IC0geDE7XG4gIHZhciBkeSA9IHkgLSB5MTtcbiAgdmFyIGR4MSA9IHgyIC0geDE7XG4gIHZhciBkeTEgPSB5MiAtIHkxO1xuICB2YXIgbGluZUxlbiA9IE1hdGguc3FydChkeDEgKiBkeDEgKyBkeTEgKiBkeTEpO1xuICBkeDEgLz0gbGluZUxlbjtcbiAgZHkxIC89IGxpbmVMZW47XG4gIC8vIGRvdCBwcm9kdWN0XG4gIHZhciBwcm9qZWN0ZWRMZW4gPSBkeCAqIGR4MSArIGR5ICogZHkxO1xuICB2YXIgdCA9IHByb2plY3RlZExlbiAvIGxpbmVMZW47XG4gIGlmIChsaW1pdFRvRW5kcykge1xuICAgIHQgPSBNYXRoLm1pbihNYXRoLm1heCh0LCAwKSwgMSk7XG4gIH1cbiAgdCAqPSBsaW5lTGVuO1xuICB2YXIgb3ggPSBvdXRbMF0gPSB4MSArIHQgKiBkeDE7XG4gIHZhciBveSA9IG91dFsxXSA9IHkxICsgdCAqIGR5MTtcbiAgcmV0dXJuIE1hdGguc3FydCgob3ggLSB4KSAqIChveCAtIHgpICsgKG95IC0geSkgKiAob3kgLSB5KSk7XG59XG5mdW5jdGlvbiBwcm9qZWN0UG9pbnRUb1JlY3QoeDEsIHkxLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBvdXQpIHtcbiAgaWYgKHdpZHRoIDwgMCkge1xuICAgIHgxID0geDEgKyB3aWR0aDtcbiAgICB3aWR0aCA9IC13aWR0aDtcbiAgfVxuICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgIHkxID0geTEgKyBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgfVxuICB2YXIgeDIgPSB4MSArIHdpZHRoO1xuICB2YXIgeTIgPSB5MSArIGhlaWdodDtcbiAgdmFyIG94ID0gb3V0WzBdID0gTWF0aC5taW4oTWF0aC5tYXgoeCwgeDEpLCB4Mik7XG4gIHZhciBveSA9IG91dFsxXSA9IE1hdGgubWluKE1hdGgubWF4KHksIHkxKSwgeTIpO1xuICByZXR1cm4gTWF0aC5zcXJ0KChveCAtIHgpICogKG94IC0geCkgKyAob3kgLSB5KSAqIChveSAtIHkpKTtcbn1cbnZhciB0bXBQdCA9IFtdO1xuZnVuY3Rpb24gbmVhcmVzdFBvaW50T25SZWN0KHB0LCByZWN0LCBvdXQpIHtcbiAgdmFyIGRpc3QgPSBwcm9qZWN0UG9pbnRUb1JlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCBwdC54LCBwdC55LCB0bXBQdCk7XG4gIG91dC5zZXQodG1wUHRbMF0sIHRtcFB0WzFdKTtcbiAgcmV0dXJuIGRpc3Q7XG59XG4vKipcclxuICogQ2FsY3VsYXRlIG1pbiBkaXN0YW5jZSBjb3JyZXNwb25kaW5nIHBvaW50LlxyXG4gKiBUaGlzIG1ldGhvZCB3b24ndCBldmFsdWF0ZSBpZiBwb2ludCBpcyBpbiB0aGUgcGF0aC5cclxuICovXG5mdW5jdGlvbiBuZWFyZXN0UG9pbnRPblBhdGgocHQsIHBhdGgsIG91dCkge1xuICB2YXIgeGkgPSAwO1xuICB2YXIgeWkgPSAwO1xuICB2YXIgeDAgPSAwO1xuICB2YXIgeTAgPSAwO1xuICB2YXIgeDE7XG4gIHZhciB5MTtcbiAgdmFyIG1pbkRpc3QgPSBJbmZpbml0eTtcbiAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gIHZhciB4ID0gcHQueDtcbiAgdmFyIHkgPSBwdC55O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgIHZhciBjbWQgPSBkYXRhW2krK107XG4gICAgaWYgKGkgPT09IDEpIHtcbiAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgIHlpID0gZGF0YVtpICsgMV07XG4gICAgICB4MCA9IHhpO1xuICAgICAgeTAgPSB5aTtcbiAgICB9XG4gICAgdmFyIGQgPSBtaW5EaXN0O1xuICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICBjYXNlIENNRC5NOlxuICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgIHhpID0geDA7XG4gICAgICAgIHlpID0geTA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgZCA9IHByb2plY3RQb2ludFRvTGluZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCB4LCB5LCB0bXBQdCwgdHJ1ZSk7XG4gICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENNRC5DOlxuICAgICAgICBkID0gY3ViaWNQcm9qZWN0UG9pbnQoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCB4LCB5LCB0bXBQdCk7XG4gICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENNRC5ROlxuICAgICAgICBkID0gcXVhZHJhdGljUHJvamVjdFBvaW50KHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCB4LCB5LCB0bXBQdCk7XG4gICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENNRC5BOlxuICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgdGhldGEgPSBkYXRhW2krK107XG4gICAgICAgIHZhciBkVGhldGEgPSBkYXRhW2krK107XG4gICAgICAgIC8vIFRPRE8gQXJjIOaXi+i9rFxuICAgICAgICBpICs9IDE7XG4gICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gISEoMSAtIGRhdGFbaSsrXSk7XG4gICAgICAgIHgxID0gTWF0aC5jb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgeTEgPSBNYXRoLnNpbih0aGV0YSkgKiByeSArIGN5O1xuICAgICAgICAvLyDkuI3mmK/nm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICBpZiAoaSA8PSAxKSB7XG4gICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgICB5MCA9IHkxO1xuICAgICAgICB9XG4gICAgICAgIC8vIHpyIOS9v+eUqHNjYWxl5p2l5qih5ouf5qSt5ZyGLCDov5nph4zkuZ/lr7l45YGa5LiA5a6a55qE57yp5pS+XG4gICAgICAgIHZhciBfeCA9ICh4IC0gY3gpICogcnkgLyByeCArIGN4O1xuICAgICAgICBkID0gcHJvamVjdFBvaW50VG9BcmMoY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLCBfeCwgeSwgdG1wUHQpO1xuICAgICAgICB4aSA9IE1hdGguY29zKHRoZXRhICsgZFRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgIHlpID0gTWF0aC5zaW4odGhldGEgKyBkVGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENNRC5SOlxuICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107XG4gICAgICAgIGQgPSBwcm9qZWN0UG9pbnRUb1JlY3QoeDAsIHkwLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCB0bXBQdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgZCA9IHByb2plY3RQb2ludFRvTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSwgdG1wUHQsIHRydWUpO1xuICAgICAgICB4aSA9IHgwO1xuICAgICAgICB5aSA9IHkwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGQgPCBtaW5EaXN0KSB7XG4gICAgICBtaW5EaXN0ID0gZDtcbiAgICAgIG91dC5zZXQodG1wUHRbMF0sIHRtcFB0WzFdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pbkRpc3Q7XG59XG4vLyBUZW1wb3JhbCB2YXJpYWJsZSBmb3IgaW50ZXJtZWRpYXRlIHVzYWdlLlxudmFyIHB0MCA9IG5ldyBQb2ludCgpO1xudmFyIHB0MSA9IG5ldyBQb2ludCgpO1xudmFyIHB0MiA9IG5ldyBQb2ludCgpO1xudmFyIGRpciA9IG5ldyBQb2ludCgpO1xudmFyIGRpcjIgPSBuZXcgUG9pbnQoKTtcbi8qKlxyXG4gKiBDYWxjdWxhdGUgYSBwcm9wZXIgZ3VpZGUgbGluZSBiYXNlZCBvbiB0aGUgbGFiZWwgcG9zaXRpb24gYW5kIGdyYXBoaWMgZWxlbWVudCBkZWZpbml0aW9uXHJcbiAqIEBwYXJhbSBsYWJlbFxyXG4gKiBAcGFyYW0gbGFiZWxSZWN0XHJcbiAqIEBwYXJhbSB0YXJnZXRcclxuICogQHBhcmFtIHRhcmdldFJlY3RcclxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTGFiZWxMaW5lUG9pbnRzKHRhcmdldCwgbGFiZWxMaW5lTW9kZWwpIHtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGxhYmVsTGluZSA9IHRhcmdldC5nZXRUZXh0R3VpZGVMaW5lKCk7XG4gIHZhciBsYWJlbCA9IHRhcmdldC5nZXRUZXh0Q29udGVudCgpO1xuICAvLyBOZWVkcyB0byBjcmVhdGUgdGV4dCBndWlkZSBpbiBlYWNoIGNoYXJ0cy5cbiAgaWYgKCEobGFiZWwgJiYgbGFiZWxMaW5lKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbGFiZWxHdWlkZUNvbmZpZyA9IHRhcmdldC50ZXh0R3VpZGVMaW5lQ29uZmlnIHx8IHt9O1xuICB2YXIgcG9pbnRzID0gW1swLCAwXSwgWzAsIDBdLCBbMCwgMF1dO1xuICB2YXIgc2VhcmNoU3BhY2UgPSBsYWJlbEd1aWRlQ29uZmlnLmNhbmRpZGF0ZXMgfHwgREVGQVVMVF9TRUFSQ0hfU1BBQ0U7XG4gIHZhciBsYWJlbFJlY3QgPSBsYWJlbC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuICBsYWJlbFJlY3QuYXBwbHlUcmFuc2Zvcm0obGFiZWwuZ2V0Q29tcHV0ZWRUcmFuc2Zvcm0oKSk7XG4gIHZhciBtaW5EaXN0ID0gSW5maW5pdHk7XG4gIHZhciBhbmNob3JQb2ludCA9IGxhYmVsR3VpZGVDb25maWcuYW5jaG9yO1xuICB2YXIgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXB1dGVkVHJhbnNmb3JtKCk7XG4gIHZhciB0YXJnZXRJbnZlcnNlZFRyYW5zZm9ybSA9IHRhcmdldFRyYW5zZm9ybSAmJiBpbnZlcnQoW10sIHRhcmdldFRyYW5zZm9ybSk7XG4gIHZhciBsZW4gPSBsYWJlbExpbmVNb2RlbC5nZXQoJ2xlbmd0aDInKSB8fCAwO1xuICBpZiAoYW5jaG9yUG9pbnQpIHtcbiAgICBwdDIuY29weShhbmNob3JQb2ludCk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWFyY2hTcGFjZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjYW5kaWRhdGUgPSBzZWFyY2hTcGFjZVtpXTtcbiAgICBnZXRDYW5kaWRhdGVBbmNob3IoY2FuZGlkYXRlLCAwLCBsYWJlbFJlY3QsIHB0MCwgZGlyKTtcbiAgICBQb2ludC5zY2FsZUFuZEFkZChwdDEsIHB0MCwgZGlyLCBsZW4pO1xuICAgIC8vIFRyYW5zZm9ybSB0byB0YXJnZXQgY29vcmQgc3BhY2UuXG4gICAgcHQxLnRyYW5zZm9ybSh0YXJnZXRJbnZlcnNlZFRyYW5zZm9ybSk7XG4gICAgLy8gTm90ZTogZ2V0Qm91bmRpbmdSZWN0IHdpbGwgZW5zdXJlIHRoZSBgcGF0aGAgYmVpbmcgY3JlYXRlZC5cbiAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBkaXN0ID0gYW5jaG9yUG9pbnQgPyBhbmNob3JQb2ludC5kaXN0YW5jZShwdDEpIDogdGFyZ2V0IGluc3RhbmNlb2YgUGF0aCA/IG5lYXJlc3RQb2ludE9uUGF0aChwdDEsIHRhcmdldC5wYXRoLCBwdDIpIDogbmVhcmVzdFBvaW50T25SZWN0KHB0MSwgYm91bmRpbmdSZWN0LCBwdDIpO1xuICAgIC8vIFRPRE8gcHQyIGlzIGluIHRoZSBwYXRoXG4gICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgIC8vIFRyYW5zZm9ybSBiYWNrIHRvIGdsb2JhbCBzcGFjZS5cbiAgICAgIHB0MS50cmFuc2Zvcm0odGFyZ2V0VHJhbnNmb3JtKTtcbiAgICAgIHB0Mi50cmFuc2Zvcm0odGFyZ2V0VHJhbnNmb3JtKTtcbiAgICAgIHB0Mi50b0FycmF5KHBvaW50c1swXSk7XG4gICAgICBwdDEudG9BcnJheShwb2ludHNbMV0pO1xuICAgICAgcHQwLnRvQXJyYXkocG9pbnRzWzJdKTtcbiAgICB9XG4gIH1cbiAgbGltaXRUdXJuQW5nbGUocG9pbnRzLCBsYWJlbExpbmVNb2RlbC5nZXQoJ21pblR1cm5BbmdsZScpKTtcbiAgbGFiZWxMaW5lLnNldFNoYXBlKHtcbiAgICBwb2ludHM6IHBvaW50c1xuICB9KTtcbn1cbi8vIFRlbXBvcmFsIHZhcmlhYmxlIGZvciB0aGUgbGltaXRUdXJuQW5nbGUgZnVuY3Rpb25cbnZhciB0bXBBcnIgPSBbXTtcbnZhciB0bXBQcm9qUG9pbnQgPSBuZXcgUG9pbnQoKTtcbi8qKlxyXG4gKiBSZWR1Y2UgdGhlIGxpbmUgc2VnbWVudCBhdHRhY2hlZCB0byB0aGUgbGFiZWwgdG8gbGltaXQgdGhlIHR1cm4gYW5nbGUgYmV0d2VlbiB0d28gc2VnbWVudHMuXHJcbiAqIEBwYXJhbSBsaW5lUG9pbnRzXHJcbiAqIEBwYXJhbSBtaW5UdXJuQW5nbGUgUmFkaWFuIG9mIG1pbmltdW0gdHVybiBhbmdsZS4gMCAtIDE4MFxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW1pdFR1cm5BbmdsZShsaW5lUG9pbnRzLCBtaW5UdXJuQW5nbGUpIHtcbiAgaWYgKCEobWluVHVybkFuZ2xlIDw9IDE4MCAmJiBtaW5UdXJuQW5nbGUgPiAwKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBtaW5UdXJuQW5nbGUgPSBtaW5UdXJuQW5nbGUgLyAxODAgKiBNYXRoLlBJO1xuICAvLyBUaGUgbGluZSBwb2ludHMgY2FuIGJlXG4gIC8vICAgICAgL3B0MS0tLS1wdDIgKGxhYmVsKVxuICAvLyAgICAgL1xuICAvLyBwdDAvXG4gIHB0MC5mcm9tQXJyYXkobGluZVBvaW50c1swXSk7XG4gIHB0MS5mcm9tQXJyYXkobGluZVBvaW50c1sxXSk7XG4gIHB0Mi5mcm9tQXJyYXkobGluZVBvaW50c1syXSk7XG4gIFBvaW50LnN1YihkaXIsIHB0MCwgcHQxKTtcbiAgUG9pbnQuc3ViKGRpcjIsIHB0MiwgcHQxKTtcbiAgdmFyIGxlbjEgPSBkaXIubGVuKCk7XG4gIHZhciBsZW4yID0gZGlyMi5sZW4oKTtcbiAgaWYgKGxlbjEgPCAxZS0zIHx8IGxlbjIgPCAxZS0zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRpci5zY2FsZSgxIC8gbGVuMSk7XG4gIGRpcjIuc2NhbGUoMSAvIGxlbjIpO1xuICB2YXIgYW5nbGVDb3MgPSBkaXIuZG90KGRpcjIpO1xuICB2YXIgbWluVHVybkFuZ2xlQ29zID0gTWF0aC5jb3MobWluVHVybkFuZ2xlKTtcbiAgaWYgKG1pblR1cm5BbmdsZUNvcyA8IGFuZ2xlQ29zKSB7XG4gICAgLy8gU21hbGxlciB0aGFuIG1pblR1cm5BbmdsZVxuICAgIC8vIENhbGN1bGF0ZSBwcm9qZWN0IHBvaW50IG9mIHB0MCBvbiBwdDEtcHQyXG4gICAgdmFyIGQgPSBwcm9qZWN0UG9pbnRUb0xpbmUocHQxLngsIHB0MS55LCBwdDIueCwgcHQyLnksIHB0MC54LCBwdDAueSwgdG1wQXJyLCBmYWxzZSk7XG4gICAgdG1wUHJvalBvaW50LmZyb21BcnJheSh0bXBBcnIpO1xuICAgIC8vIENhbGN1bGF0ZSBuZXcgcHJvamVjdGVkIGxlbmd0aCB3aXRoIGxpbWl0ZWQgbWluVHVybkFuZ2xlIGFuZCBnZXQgdGhlIG5ldyBjb25uZWN0IHBvaW50XG4gICAgdG1wUHJvalBvaW50LnNjYWxlQW5kQWRkKGRpcjIsIGQgLyBNYXRoLnRhbihNYXRoLlBJIC0gbWluVHVybkFuZ2xlKSk7XG4gICAgLy8gTGltaXQgdGhlIG5ldyBjYWxjdWxhdGVkIGNvbm5lY3QgcG9pbnQgYmV0d2VlbiBwdDEgYW5kIHB0Mi5cbiAgICB2YXIgdCA9IHB0Mi54ICE9PSBwdDEueCA/ICh0bXBQcm9qUG9pbnQueCAtIHB0MS54KSAvIChwdDIueCAtIHB0MS54KSA6ICh0bXBQcm9qUG9pbnQueSAtIHB0MS55KSAvIChwdDIueSAtIHB0MS55KTtcbiAgICBpZiAoaXNOYU4odCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHQgPCAwKSB7XG4gICAgICBQb2ludC5jb3B5KHRtcFByb2pQb2ludCwgcHQxKTtcbiAgICB9IGVsc2UgaWYgKHQgPiAxKSB7XG4gICAgICBQb2ludC5jb3B5KHRtcFByb2pQb2ludCwgcHQyKTtcbiAgICB9XG4gICAgdG1wUHJvalBvaW50LnRvQXJyYXkobGluZVBvaW50c1sxXSk7XG4gIH1cbn1cbi8qKlxyXG4gKiBMaW1pdCB0aGUgYW5nbGUgb2YgbGluZSBhbmQgdGhlIHN1cmZhY2VcclxuICogQHBhcmFtIG1heFN1cmZhY2VBbmdsZSBSYWRpYW4gb2YgbWluaW11bSB0dXJuIGFuZ2xlLiAwIC0gMTgwLiAwIGlzIHNhbWUgZGlyZWN0aW9uIHRvIG5vcm1hbC4gMTgwIGlzIG9wcG9zaXRlXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbWl0U3VyZmFjZUFuZ2xlKGxpbmVQb2ludHMsIHN1cmZhY2VOb3JtYWwsIG1heFN1cmZhY2VBbmdsZSkge1xuICBpZiAoIShtYXhTdXJmYWNlQW5nbGUgPD0gMTgwICYmIG1heFN1cmZhY2VBbmdsZSA+IDApKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1heFN1cmZhY2VBbmdsZSA9IG1heFN1cmZhY2VBbmdsZSAvIDE4MCAqIE1hdGguUEk7XG4gIHB0MC5mcm9tQXJyYXkobGluZVBvaW50c1swXSk7XG4gIHB0MS5mcm9tQXJyYXkobGluZVBvaW50c1sxXSk7XG4gIHB0Mi5mcm9tQXJyYXkobGluZVBvaW50c1syXSk7XG4gIFBvaW50LnN1YihkaXIsIHB0MSwgcHQwKTtcbiAgUG9pbnQuc3ViKGRpcjIsIHB0MiwgcHQxKTtcbiAgdmFyIGxlbjEgPSBkaXIubGVuKCk7XG4gIHZhciBsZW4yID0gZGlyMi5sZW4oKTtcbiAgaWYgKGxlbjEgPCAxZS0zIHx8IGxlbjIgPCAxZS0zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRpci5zY2FsZSgxIC8gbGVuMSk7XG4gIGRpcjIuc2NhbGUoMSAvIGxlbjIpO1xuICB2YXIgYW5nbGVDb3MgPSBkaXIuZG90KHN1cmZhY2VOb3JtYWwpO1xuICB2YXIgbWF4U3VyZmFjZUFuZ2xlQ29zID0gTWF0aC5jb3MobWF4U3VyZmFjZUFuZ2xlKTtcbiAgaWYgKGFuZ2xlQ29zIDwgbWF4U3VyZmFjZUFuZ2xlQ29zKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHByb2plY3QgcG9pbnQgb2YgcHQwIG9uIHB0MS1wdDJcbiAgICB2YXIgZCA9IHByb2plY3RQb2ludFRvTGluZShwdDEueCwgcHQxLnksIHB0Mi54LCBwdDIueSwgcHQwLngsIHB0MC55LCB0bXBBcnIsIGZhbHNlKTtcbiAgICB0bXBQcm9qUG9pbnQuZnJvbUFycmF5KHRtcEFycik7XG4gICAgdmFyIEhBTEZfUEkgPSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgYW5nbGUyID0gTWF0aC5hY29zKGRpcjIuZG90KHN1cmZhY2VOb3JtYWwpKTtcbiAgICB2YXIgbmV3QW5nbGUgPSBIQUxGX1BJICsgYW5nbGUyIC0gbWF4U3VyZmFjZUFuZ2xlO1xuICAgIGlmIChuZXdBbmdsZSA+PSBIQUxGX1BJKSB7XG4gICAgICAvLyBwYXJhbGxlbFxuICAgICAgUG9pbnQuY29weSh0bXBQcm9qUG9pbnQsIHB0Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhbGN1bGF0ZSBuZXcgcHJvamVjdGVkIGxlbmd0aCB3aXRoIGxpbWl0ZWQgbWluVHVybkFuZ2xlIGFuZCBnZXQgdGhlIG5ldyBjb25uZWN0IHBvaW50XG4gICAgICB0bXBQcm9qUG9pbnQuc2NhbGVBbmRBZGQoZGlyMiwgZCAvIE1hdGgudGFuKE1hdGguUEkgLyAyIC0gbmV3QW5nbGUpKTtcbiAgICAgIC8vIExpbWl0IHRoZSBuZXcgY2FsY3VsYXRlZCBjb25uZWN0IHBvaW50IGJldHdlZW4gcHQxIGFuZCBwdDIuXG4gICAgICB2YXIgdCA9IHB0Mi54ICE9PSBwdDEueCA/ICh0bXBQcm9qUG9pbnQueCAtIHB0MS54KSAvIChwdDIueCAtIHB0MS54KSA6ICh0bXBQcm9qUG9pbnQueSAtIHB0MS55KSAvIChwdDIueSAtIHB0MS55KTtcbiAgICAgIGlmIChpc05hTih0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodCA8IDApIHtcbiAgICAgICAgUG9pbnQuY29weSh0bXBQcm9qUG9pbnQsIHB0MSk7XG4gICAgICB9IGVsc2UgaWYgKHQgPiAxKSB7XG4gICAgICAgIFBvaW50LmNvcHkodG1wUHJvalBvaW50LCBwdDIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0bXBQcm9qUG9pbnQudG9BcnJheShsaW5lUG9pbnRzWzFdKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0TGFiZWxMaW5lU3RhdGUobGFiZWxMaW5lLCBpZ25vcmUsIHN0YXRlTmFtZSwgc3RhdGVNb2RlbCkge1xuICB2YXIgaXNOb3JtYWwgPSBzdGF0ZU5hbWUgPT09ICdub3JtYWwnO1xuICB2YXIgc3RhdGVPYmogPSBpc05vcm1hbCA/IGxhYmVsTGluZSA6IGxhYmVsTGluZS5lbnN1cmVTdGF0ZShzdGF0ZU5hbWUpO1xuICAvLyBNYWtlIHN1cmUgZGlzcGxheS5cbiAgc3RhdGVPYmouaWdub3JlID0gaWdub3JlO1xuICAvLyBTZXQgc21vb3RoXG4gIHZhciBzbW9vdGggPSBzdGF0ZU1vZGVsLmdldCgnc21vb3RoJyk7XG4gIGlmIChzbW9vdGggJiYgc21vb3RoID09PSB0cnVlKSB7XG4gICAgc21vb3RoID0gMC4zO1xuICB9XG4gIHN0YXRlT2JqLnNoYXBlID0gc3RhdGVPYmouc2hhcGUgfHwge307XG4gIGlmIChzbW9vdGggPiAwKSB7XG4gICAgc3RhdGVPYmouc2hhcGUuc21vb3RoID0gc21vb3RoO1xuICB9XG4gIHZhciBzdHlsZU9iaiA9IHN0YXRlTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpO1xuICBpc05vcm1hbCA/IGxhYmVsTGluZS51c2VTdHlsZShzdHlsZU9iaikgOiBzdGF0ZU9iai5zdHlsZSA9IHN0eWxlT2JqO1xufVxuZnVuY3Rpb24gYnVpbGRMYWJlbExpbmVQYXRoKHBhdGgsIHNoYXBlKSB7XG4gIHZhciBzbW9vdGggPSBzaGFwZS5zbW9vdGg7XG4gIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gIGlmICghcG9pbnRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHBhdGgubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcbiAgaWYgKHNtb290aCA+IDAgJiYgcG9pbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgdmFyIGxlbjEgPSB2ZWN0b3IuZGlzdChwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgdmFyIGxlbjIgPSB2ZWN0b3IuZGlzdChwb2ludHNbMV0sIHBvaW50c1syXSk7XG4gICAgaWYgKCFsZW4xIHx8ICFsZW4yKSB7XG4gICAgICBwYXRoLmxpbmVUbyhwb2ludHNbMV1bMF0sIHBvaW50c1sxXVsxXSk7XG4gICAgICBwYXRoLmxpbmVUbyhwb2ludHNbMl1bMF0sIHBvaW50c1syXVsxXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBtb3ZlTGVuID0gTWF0aC5taW4obGVuMSwgbGVuMikgKiBzbW9vdGg7XG4gICAgdmFyIG1pZFBvaW50MCA9IHZlY3Rvci5sZXJwKFtdLCBwb2ludHNbMV0sIHBvaW50c1swXSwgbW92ZUxlbiAvIGxlbjEpO1xuICAgIHZhciBtaWRQb2ludDIgPSB2ZWN0b3IubGVycChbXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIG1vdmVMZW4gLyBsZW4yKTtcbiAgICB2YXIgbWlkUG9pbnQxID0gdmVjdG9yLmxlcnAoW10sIG1pZFBvaW50MCwgbWlkUG9pbnQyLCAwLjUpO1xuICAgIHBhdGguYmV6aWVyQ3VydmVUbyhtaWRQb2ludDBbMF0sIG1pZFBvaW50MFsxXSwgbWlkUG9pbnQwWzBdLCBtaWRQb2ludDBbMV0sIG1pZFBvaW50MVswXSwgbWlkUG9pbnQxWzFdKTtcbiAgICBwYXRoLmJlemllckN1cnZlVG8obWlkUG9pbnQyWzBdLCBtaWRQb2ludDJbMV0sIG1pZFBvaW50MlswXSwgbWlkUG9pbnQyWzFdLCBwb2ludHNbMl1bMF0sIHBvaW50c1syXVsxXSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhdGgubGluZVRvKHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBsYWJlbCBsaW5lIGlmIG5lY2Vzc2FyeSBhbmQgc2V0IGl0J3Mgc3R5bGUuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldExhYmVsTGluZVN0eWxlKHRhcmdldEVsLCBzdGF0ZXNNb2RlbHMsIGRlZmF1bHRTdHlsZSkge1xuICB2YXIgbGFiZWxMaW5lID0gdGFyZ2V0RWwuZ2V0VGV4dEd1aWRlTGluZSgpO1xuICB2YXIgbGFiZWwgPSB0YXJnZXRFbC5nZXRUZXh0Q29udGVudCgpO1xuICBpZiAoIWxhYmVsKSB7XG4gICAgLy8gTm90IHNob3cgbGFiZWwgbGluZSBpZiB0aGVyZSBpcyBubyBsYWJlbC5cbiAgICBpZiAobGFiZWxMaW5lKSB7XG4gICAgICB0YXJnZXRFbC5yZW1vdmVUZXh0R3VpZGVMaW5lKCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbm9ybWFsTW9kZWwgPSBzdGF0ZXNNb2RlbHMubm9ybWFsO1xuICB2YXIgc2hvd05vcm1hbCA9IG5vcm1hbE1vZGVsLmdldCgnc2hvdycpO1xuICB2YXIgbGFiZWxJZ25vcmVOb3JtYWwgPSBsYWJlbC5pZ25vcmU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgRElTUExBWV9TVEFURVMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RhdGVOYW1lID0gRElTUExBWV9TVEFURVNbaV07XG4gICAgdmFyIHN0YXRlTW9kZWwgPSBzdGF0ZXNNb2RlbHNbc3RhdGVOYW1lXTtcbiAgICB2YXIgaXNOb3JtYWwgPSBzdGF0ZU5hbWUgPT09ICdub3JtYWwnO1xuICAgIGlmIChzdGF0ZU1vZGVsKSB7XG4gICAgICB2YXIgc3RhdGVTaG93ID0gc3RhdGVNb2RlbC5nZXQoJ3Nob3cnKTtcbiAgICAgIHZhciBpc0xhYmVsSWdub3JlZCA9IGlzTm9ybWFsID8gbGFiZWxJZ25vcmVOb3JtYWwgOiByZXRyaWV2ZTIobGFiZWwuc3RhdGVzW3N0YXRlTmFtZV0gJiYgbGFiZWwuc3RhdGVzW3N0YXRlTmFtZV0uaWdub3JlLCBsYWJlbElnbm9yZU5vcm1hbCk7XG4gICAgICBpZiAoaXNMYWJlbElnbm9yZWQgLy8gTm90IHNob3cgd2hlbiBsYWJlbCBpcyBub3Qgc2hvd24gaW4gdGhpcyBzdGF0ZS5cbiAgICAgIHx8ICFyZXRyaWV2ZTIoc3RhdGVTaG93LCBzaG93Tm9ybWFsKSAvLyBVc2Ugbm9ybWFsIHN0YXRlIGJ5IGRlZmF1bHQgaWYgbm90IHNldC5cbiAgICAgICkge1xuICAgICAgICB2YXIgc3RhdGVPYmogPSBpc05vcm1hbCA/IGxhYmVsTGluZSA6IGxhYmVsTGluZSAmJiBsYWJlbExpbmUuc3RhdGVzW3N0YXRlTmFtZV07XG4gICAgICAgIGlmIChzdGF0ZU9iaikge1xuICAgICAgICAgIHN0YXRlT2JqLmlnbm9yZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhbGFiZWxMaW5lKSB7XG4gICAgICAgICAgc2V0TGFiZWxMaW5lU3RhdGUobGFiZWxMaW5lLCB0cnVlLCBzdGF0ZU5hbWUsIHN0YXRlTW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gQ3JlYXRlIGxhYmVsTGluZSBpZiBub3QgZXhpc3RzXG4gICAgICBpZiAoIWxhYmVsTGluZSkge1xuICAgICAgICBsYWJlbExpbmUgPSBuZXcgUG9seWxpbmUoKTtcbiAgICAgICAgdGFyZ2V0RWwuc2V0VGV4dEd1aWRlTGluZShsYWJlbExpbmUpO1xuICAgICAgICAvLyBSZXNldCBzdGF0ZSBvZiBub3JtYWwgYmVjYXVzZSBpdCdzIG5ldyBjcmVhdGVkLlxuICAgICAgICAvLyBOT1RFOiBOT1JNQUwgc2hvdWxkIGFsd2F5cyBiZWVuIHRoZSBmaXJzdCFcbiAgICAgICAgaWYgKCFpc05vcm1hbCAmJiAobGFiZWxJZ25vcmVOb3JtYWwgfHwgIXNob3dOb3JtYWwpKSB7XG4gICAgICAgICAgc2V0TGFiZWxMaW5lU3RhdGUobGFiZWxMaW5lLCB0cnVlLCAnbm9ybWFsJywgc3RhdGVzTW9kZWxzLm5vcm1hbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHNhbWUgc3RhdGUgcHJveHkuXG4gICAgICAgIGlmICh0YXJnZXRFbC5zdGF0ZVByb3h5KSB7XG4gICAgICAgICAgbGFiZWxMaW5lLnN0YXRlUHJveHkgPSB0YXJnZXRFbC5zdGF0ZVByb3h5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRMYWJlbExpbmVTdGF0ZShsYWJlbExpbmUsIGZhbHNlLCBzdGF0ZU5hbWUsIHN0YXRlTW9kZWwpO1xuICAgIH1cbiAgfVxuICBpZiAobGFiZWxMaW5lKSB7XG4gICAgZGVmYXVsdHMobGFiZWxMaW5lLnN0eWxlLCBkZWZhdWx0U3R5bGUpO1xuICAgIC8vIE5vdCBmaWxsLlxuICAgIGxhYmVsTGluZS5zdHlsZS5maWxsID0gbnVsbDtcbiAgICB2YXIgc2hvd0Fib3ZlID0gbm9ybWFsTW9kZWwuZ2V0KCdzaG93QWJvdmUnKTtcbiAgICB2YXIgbGFiZWxMaW5lQ29uZmlnID0gdGFyZ2V0RWwudGV4dEd1aWRlTGluZUNvbmZpZyA9IHRhcmdldEVsLnRleHRHdWlkZUxpbmVDb25maWcgfHwge307XG4gICAgbGFiZWxMaW5lQ29uZmlnLnNob3dBYm92ZSA9IHNob3dBYm92ZSB8fCBmYWxzZTtcbiAgICAvLyBDdXN0b20gdGhlIGJ1aWxkUGF0aC5cbiAgICBsYWJlbExpbmUuYnVpbGRQYXRoID0gYnVpbGRMYWJlbExpbmVQYXRoO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFiZWxMaW5lU3RhdGVzTW9kZWxzKGl0ZW1Nb2RlbCwgbGFiZWxMaW5lTmFtZSkge1xuICBsYWJlbExpbmVOYW1lID0gbGFiZWxMaW5lTmFtZSB8fCAnbGFiZWxMaW5lJztcbiAgdmFyIHN0YXRlc01vZGVscyA9IHtcbiAgICBub3JtYWw6IGl0ZW1Nb2RlbC5nZXRNb2RlbChsYWJlbExpbmVOYW1lKVxuICB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IFNQRUNJQUxfU1RBVEVTLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN0YXRlTmFtZSA9IFNQRUNJQUxfU1RBVEVTW2ldO1xuICAgIHN0YXRlc01vZGVsc1tzdGF0ZU5hbWVdID0gaXRlbU1vZGVsLmdldE1vZGVsKFtzdGF0ZU5hbWUsIGxhYmVsTGluZU5hbWVdKTtcbiAgfVxuICByZXR1cm4gc3RhdGVzTW9kZWxzO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///92621\n')},94327:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   W: () => (/* binding */ setSectorTextRotation),\n/* harmony export */   r: () => (/* binding */ createSectorCalculateTextPosition)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_contain_text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45558);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction createSectorCalculateTextPosition(positionMapping, opts) {\n  opts = opts || {};\n  var isRoundCap = opts.isRoundCap;\n  return function (out, opts, boundingRect) {\n    var textPosition = opts.position;\n    if (!textPosition || textPosition instanceof Array) {\n      return (0,zrender_lib_contain_text_js__WEBPACK_IMPORTED_MODULE_0__/* .calculateTextPosition */ .X4)(out, opts, boundingRect);\n    }\n    var mappedSectorPosition = positionMapping(textPosition);\n    var distance = opts.distance != null ? opts.distance : 5;\n    var sector = this.shape;\n    var cx = sector.cx;\n    var cy = sector.cy;\n    var r = sector.r;\n    var r0 = sector.r0;\n    var middleR = (r + r0) / 2;\n    var startAngle = sector.startAngle;\n    var endAngle = sector.endAngle;\n    var middleAngle = (startAngle + endAngle) / 2;\n    var extraDist = isRoundCap ? Math.abs(r - r0) / 2 : 0;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    // base position: top-left\n    var x = cx + r * mathCos(startAngle);\n    var y = cy + r * mathSin(startAngle);\n    var textAlign = 'left';\n    var textVerticalAlign = 'top';\n    switch (mappedSectorPosition) {\n      case 'startArc':\n        x = cx + (r0 - distance) * mathCos(middleAngle);\n        y = cy + (r0 - distance) * mathSin(middleAngle);\n        textAlign = 'center';\n        textVerticalAlign = 'top';\n        break;\n      case 'insideStartArc':\n        x = cx + (r0 + distance) * mathCos(middleAngle);\n        y = cy + (r0 + distance) * mathSin(middleAngle);\n        textAlign = 'center';\n        textVerticalAlign = 'bottom';\n        break;\n      case 'startAngle':\n        x = cx + middleR * mathCos(startAngle) + adjustAngleDistanceX(startAngle, distance + extraDist, false);\n        y = cy + middleR * mathSin(startAngle) + adjustAngleDistanceY(startAngle, distance + extraDist, false);\n        textAlign = 'right';\n        textVerticalAlign = 'middle';\n        break;\n      case 'insideStartAngle':\n        x = cx + middleR * mathCos(startAngle) + adjustAngleDistanceX(startAngle, -distance + extraDist, false);\n        y = cy + middleR * mathSin(startAngle) + adjustAngleDistanceY(startAngle, -distance + extraDist, false);\n        textAlign = 'left';\n        textVerticalAlign = 'middle';\n        break;\n      case 'middle':\n        x = cx + middleR * mathCos(middleAngle);\n        y = cy + middleR * mathSin(middleAngle);\n        textAlign = 'center';\n        textVerticalAlign = 'middle';\n        break;\n      case 'endArc':\n        x = cx + (r + distance) * mathCos(middleAngle);\n        y = cy + (r + distance) * mathSin(middleAngle);\n        textAlign = 'center';\n        textVerticalAlign = 'bottom';\n        break;\n      case 'insideEndArc':\n        x = cx + (r - distance) * mathCos(middleAngle);\n        y = cy + (r - distance) * mathSin(middleAngle);\n        textAlign = 'center';\n        textVerticalAlign = 'top';\n        break;\n      case 'endAngle':\n        x = cx + middleR * mathCos(endAngle) + adjustAngleDistanceX(endAngle, distance + extraDist, true);\n        y = cy + middleR * mathSin(endAngle) + adjustAngleDistanceY(endAngle, distance + extraDist, true);\n        textAlign = 'left';\n        textVerticalAlign = 'middle';\n        break;\n      case 'insideEndAngle':\n        x = cx + middleR * mathCos(endAngle) + adjustAngleDistanceX(endAngle, -distance + extraDist, true);\n        y = cy + middleR * mathSin(endAngle) + adjustAngleDistanceY(endAngle, -distance + extraDist, true);\n        textAlign = 'right';\n        textVerticalAlign = 'middle';\n        break;\n      default:\n        return (0,zrender_lib_contain_text_js__WEBPACK_IMPORTED_MODULE_0__/* .calculateTextPosition */ .X4)(out, opts, boundingRect);\n    }\n    out = out || {};\n    out.x = x;\n    out.y = y;\n    out.align = textAlign;\n    out.verticalAlign = textVerticalAlign;\n    return out;\n  };\n}\nfunction setSectorTextRotation(sector, textPosition, positionMapping, rotateType) {\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(rotateType)) {\n    // user-set rotation\n    sector.setTextConfig({\n      rotation: rotateType\n    });\n    return;\n  } else if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(textPosition)) {\n    // user-set position, use 0 as auto rotation\n    sector.setTextConfig({\n      rotation: 0\n    });\n    return;\n  }\n  var shape = sector.shape;\n  var startAngle = shape.clockwise ? shape.startAngle : shape.endAngle;\n  var endAngle = shape.clockwise ? shape.endAngle : shape.startAngle;\n  var middleAngle = (startAngle + endAngle) / 2;\n  var anchorAngle;\n  var mappedSectorPosition = positionMapping(textPosition);\n  switch (mappedSectorPosition) {\n    case 'startArc':\n    case 'insideStartArc':\n    case 'middle':\n    case 'insideEndArc':\n    case 'endArc':\n      anchorAngle = middleAngle;\n      break;\n    case 'startAngle':\n    case 'insideStartAngle':\n      anchorAngle = startAngle;\n      break;\n    case 'endAngle':\n    case 'insideEndAngle':\n      anchorAngle = endAngle;\n      break;\n    default:\n      sector.setTextConfig({\n        rotation: 0\n      });\n      return;\n  }\n  var rotate = Math.PI * 1.5 - anchorAngle;\n  /**\r\n   * TODO: labels with rotate > Math.PI / 2 should be rotate another\r\n   * half round flipped to increase readability. However, only middle\r\n   * position supports this for now, because in other positions, the\r\n   * anchor point is not at the center of the text, so the positions\r\n   * after rotating is not as expected.\r\n   */\n  if (mappedSectorPosition === 'middle' && rotate > Math.PI / 2 && rotate < Math.PI * 1.5) {\n    rotate -= Math.PI;\n  }\n  sector.setTextConfig({\n    rotation: rotate\n  });\n}\nfunction adjustAngleDistanceX(angle, distance, isEnd) {\n  return distance * Math.sin(angle) * (isEnd ? -1 : 1);\n}\nfunction adjustAngleDistanceY(angle, distance, isEnd) {\n  return distance * Math.cos(angle) * (isEnd ? 1 : -1);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQzMjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2xhYmVsL3NlY3RvckxhYmVsLmpzPzRmMTAiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBjYWxjdWxhdGVUZXh0UG9zaXRpb24gfSBmcm9tICd6cmVuZGVyL2xpYi9jb250YWluL3RleHQuanMnO1xuaW1wb3J0IHsgaXNBcnJheSwgaXNOdW1iZXIgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlY3RvckNhbGN1bGF0ZVRleHRQb3NpdGlvbihwb3NpdGlvbk1hcHBpbmcsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHZhciBpc1JvdW5kQ2FwID0gb3B0cy5pc1JvdW5kQ2FwO1xuICByZXR1cm4gZnVuY3Rpb24gKG91dCwgb3B0cywgYm91bmRpbmdSZWN0KSB7XG4gICAgdmFyIHRleHRQb3NpdGlvbiA9IG9wdHMucG9zaXRpb247XG4gICAgaWYgKCF0ZXh0UG9zaXRpb24gfHwgdGV4dFBvc2l0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHJldHVybiBjYWxjdWxhdGVUZXh0UG9zaXRpb24ob3V0LCBvcHRzLCBib3VuZGluZ1JlY3QpO1xuICAgIH1cbiAgICB2YXIgbWFwcGVkU2VjdG9yUG9zaXRpb24gPSBwb3NpdGlvbk1hcHBpbmcodGV4dFBvc2l0aW9uKTtcbiAgICB2YXIgZGlzdGFuY2UgPSBvcHRzLmRpc3RhbmNlICE9IG51bGwgPyBvcHRzLmRpc3RhbmNlIDogNTtcbiAgICB2YXIgc2VjdG9yID0gdGhpcy5zaGFwZTtcbiAgICB2YXIgY3ggPSBzZWN0b3IuY3g7XG4gICAgdmFyIGN5ID0gc2VjdG9yLmN5O1xuICAgIHZhciByID0gc2VjdG9yLnI7XG4gICAgdmFyIHIwID0gc2VjdG9yLnIwO1xuICAgIHZhciBtaWRkbGVSID0gKHIgKyByMCkgLyAyO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc2VjdG9yLnN0YXJ0QW5nbGU7XG4gICAgdmFyIGVuZEFuZ2xlID0gc2VjdG9yLmVuZEFuZ2xlO1xuICAgIHZhciBtaWRkbGVBbmdsZSA9IChzdGFydEFuZ2xlICsgZW5kQW5nbGUpIC8gMjtcbiAgICB2YXIgZXh0cmFEaXN0ID0gaXNSb3VuZENhcCA/IE1hdGguYWJzKHIgLSByMCkgLyAyIDogMDtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuICAgIHZhciBtYXRoU2luID0gTWF0aC5zaW47XG4gICAgLy8gYmFzZSBwb3NpdGlvbjogdG9wLWxlZnRcbiAgICB2YXIgeCA9IGN4ICsgciAqIG1hdGhDb3Moc3RhcnRBbmdsZSk7XG4gICAgdmFyIHkgPSBjeSArIHIgKiBtYXRoU2luKHN0YXJ0QW5nbGUpO1xuICAgIHZhciB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gJ3RvcCc7XG4gICAgc3dpdGNoIChtYXBwZWRTZWN0b3JQb3NpdGlvbikge1xuICAgICAgY2FzZSAnc3RhcnRBcmMnOlxuICAgICAgICB4ID0gY3ggKyAocjAgLSBkaXN0YW5jZSkgKiBtYXRoQ29zKG1pZGRsZUFuZ2xlKTtcbiAgICAgICAgeSA9IGN5ICsgKHIwIC0gZGlzdGFuY2UpICogbWF0aFNpbihtaWRkbGVBbmdsZSk7XG4gICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICd0b3AnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2luc2lkZVN0YXJ0QXJjJzpcbiAgICAgICAgeCA9IGN4ICsgKHIwICsgZGlzdGFuY2UpICogbWF0aENvcyhtaWRkbGVBbmdsZSk7XG4gICAgICAgIHkgPSBjeSArIChyMCArIGRpc3RhbmNlKSAqIG1hdGhTaW4obWlkZGxlQW5nbGUpO1xuICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdGFydEFuZ2xlJzpcbiAgICAgICAgeCA9IGN4ICsgbWlkZGxlUiAqIG1hdGhDb3Moc3RhcnRBbmdsZSkgKyBhZGp1c3RBbmdsZURpc3RhbmNlWChzdGFydEFuZ2xlLCBkaXN0YW5jZSArIGV4dHJhRGlzdCwgZmFsc2UpO1xuICAgICAgICB5ID0gY3kgKyBtaWRkbGVSICogbWF0aFNpbihzdGFydEFuZ2xlKSArIGFkanVzdEFuZ2xlRGlzdGFuY2VZKHN0YXJ0QW5nbGUsIGRpc3RhbmNlICsgZXh0cmFEaXN0LCBmYWxzZSk7XG4gICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5zaWRlU3RhcnRBbmdsZSc6XG4gICAgICAgIHggPSBjeCArIG1pZGRsZVIgKiBtYXRoQ29zKHN0YXJ0QW5nbGUpICsgYWRqdXN0QW5nbGVEaXN0YW5jZVgoc3RhcnRBbmdsZSwgLWRpc3RhbmNlICsgZXh0cmFEaXN0LCBmYWxzZSk7XG4gICAgICAgIHkgPSBjeSArIG1pZGRsZVIgKiBtYXRoU2luKHN0YXJ0QW5nbGUpICsgYWRqdXN0QW5nbGVEaXN0YW5jZVkoc3RhcnRBbmdsZSwgLWRpc3RhbmNlICsgZXh0cmFEaXN0LCBmYWxzZSk7XG4gICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICB4ID0gY3ggKyBtaWRkbGVSICogbWF0aENvcyhtaWRkbGVBbmdsZSk7XG4gICAgICAgIHkgPSBjeSArIG1pZGRsZVIgKiBtYXRoU2luKG1pZGRsZUFuZ2xlKTtcbiAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZW5kQXJjJzpcbiAgICAgICAgeCA9IGN4ICsgKHIgKyBkaXN0YW5jZSkgKiBtYXRoQ29zKG1pZGRsZUFuZ2xlKTtcbiAgICAgICAgeSA9IGN5ICsgKHIgKyBkaXN0YW5jZSkgKiBtYXRoU2luKG1pZGRsZUFuZ2xlKTtcbiAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5zaWRlRW5kQXJjJzpcbiAgICAgICAgeCA9IGN4ICsgKHIgLSBkaXN0YW5jZSkgKiBtYXRoQ29zKG1pZGRsZUFuZ2xlKTtcbiAgICAgICAgeSA9IGN5ICsgKHIgLSBkaXN0YW5jZSkgKiBtYXRoU2luKG1pZGRsZUFuZ2xlKTtcbiAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ3RvcCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZW5kQW5nbGUnOlxuICAgICAgICB4ID0gY3ggKyBtaWRkbGVSICogbWF0aENvcyhlbmRBbmdsZSkgKyBhZGp1c3RBbmdsZURpc3RhbmNlWChlbmRBbmdsZSwgZGlzdGFuY2UgKyBleHRyYURpc3QsIHRydWUpO1xuICAgICAgICB5ID0gY3kgKyBtaWRkbGVSICogbWF0aFNpbihlbmRBbmdsZSkgKyBhZGp1c3RBbmdsZURpc3RhbmNlWShlbmRBbmdsZSwgZGlzdGFuY2UgKyBleHRyYURpc3QsIHRydWUpO1xuICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5zaWRlRW5kQW5nbGUnOlxuICAgICAgICB4ID0gY3ggKyBtaWRkbGVSICogbWF0aENvcyhlbmRBbmdsZSkgKyBhZGp1c3RBbmdsZURpc3RhbmNlWChlbmRBbmdsZSwgLWRpc3RhbmNlICsgZXh0cmFEaXN0LCB0cnVlKTtcbiAgICAgICAgeSA9IGN5ICsgbWlkZGxlUiAqIG1hdGhTaW4oZW5kQW5nbGUpICsgYWRqdXN0QW5nbGVEaXN0YW5jZVkoZW5kQW5nbGUsIC1kaXN0YW5jZSArIGV4dHJhRGlzdCwgdHJ1ZSk7XG4gICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZVRleHRQb3NpdGlvbihvdXQsIG9wdHMsIGJvdW5kaW5nUmVjdCk7XG4gICAgfVxuICAgIG91dCA9IG91dCB8fCB7fTtcbiAgICBvdXQueCA9IHg7XG4gICAgb3V0LnkgPSB5O1xuICAgIG91dC5hbGlnbiA9IHRleHRBbGlnbjtcbiAgICBvdXQudmVydGljYWxBbGlnbiA9IHRleHRWZXJ0aWNhbEFsaWduO1xuICAgIHJldHVybiBvdXQ7XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0U2VjdG9yVGV4dFJvdGF0aW9uKHNlY3RvciwgdGV4dFBvc2l0aW9uLCBwb3NpdGlvbk1hcHBpbmcsIHJvdGF0ZVR5cGUpIHtcbiAgaWYgKGlzTnVtYmVyKHJvdGF0ZVR5cGUpKSB7XG4gICAgLy8gdXNlci1zZXQgcm90YXRpb25cbiAgICBzZWN0b3Iuc2V0VGV4dENvbmZpZyh7XG4gICAgICByb3RhdGlvbjogcm90YXRlVHlwZVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHRleHRQb3NpdGlvbikpIHtcbiAgICAvLyB1c2VyLXNldCBwb3NpdGlvbiwgdXNlIDAgYXMgYXV0byByb3RhdGlvblxuICAgIHNlY3Rvci5zZXRUZXh0Q29uZmlnKHtcbiAgICAgIHJvdGF0aW9uOiAwXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzaGFwZSA9IHNlY3Rvci5zaGFwZTtcbiAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5jbG9ja3dpc2UgPyBzaGFwZS5zdGFydEFuZ2xlIDogc2hhcGUuZW5kQW5nbGU7XG4gIHZhciBlbmRBbmdsZSA9IHNoYXBlLmNsb2Nrd2lzZSA/IHNoYXBlLmVuZEFuZ2xlIDogc2hhcGUuc3RhcnRBbmdsZTtcbiAgdmFyIG1pZGRsZUFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBlbmRBbmdsZSkgLyAyO1xuICB2YXIgYW5jaG9yQW5nbGU7XG4gIHZhciBtYXBwZWRTZWN0b3JQb3NpdGlvbiA9IHBvc2l0aW9uTWFwcGluZyh0ZXh0UG9zaXRpb24pO1xuICBzd2l0Y2ggKG1hcHBlZFNlY3RvclBvc2l0aW9uKSB7XG4gICAgY2FzZSAnc3RhcnRBcmMnOlxuICAgIGNhc2UgJ2luc2lkZVN0YXJ0QXJjJzpcbiAgICBjYXNlICdtaWRkbGUnOlxuICAgIGNhc2UgJ2luc2lkZUVuZEFyYyc6XG4gICAgY2FzZSAnZW5kQXJjJzpcbiAgICAgIGFuY2hvckFuZ2xlID0gbWlkZGxlQW5nbGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzdGFydEFuZ2xlJzpcbiAgICBjYXNlICdpbnNpZGVTdGFydEFuZ2xlJzpcbiAgICAgIGFuY2hvckFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VuZEFuZ2xlJzpcbiAgICBjYXNlICdpbnNpZGVFbmRBbmdsZSc6XG4gICAgICBhbmNob3JBbmdsZSA9IGVuZEFuZ2xlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHNlY3Rvci5zZXRUZXh0Q29uZmlnKHtcbiAgICAgICAgcm90YXRpb246IDBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHZhciByb3RhdGUgPSBNYXRoLlBJICogMS41IC0gYW5jaG9yQW5nbGU7XG4gIC8qKlxyXG4gICAqIFRPRE86IGxhYmVscyB3aXRoIHJvdGF0ZSA+IE1hdGguUEkgLyAyIHNob3VsZCBiZSByb3RhdGUgYW5vdGhlclxyXG4gICAqIGhhbGYgcm91bmQgZmxpcHBlZCB0byBpbmNyZWFzZSByZWFkYWJpbGl0eS4gSG93ZXZlciwgb25seSBtaWRkbGVcclxuICAgKiBwb3NpdGlvbiBzdXBwb3J0cyB0aGlzIGZvciBub3csIGJlY2F1c2UgaW4gb3RoZXIgcG9zaXRpb25zLCB0aGVcclxuICAgKiBhbmNob3IgcG9pbnQgaXMgbm90IGF0IHRoZSBjZW50ZXIgb2YgdGhlIHRleHQsIHNvIHRoZSBwb3NpdGlvbnNcclxuICAgKiBhZnRlciByb3RhdGluZyBpcyBub3QgYXMgZXhwZWN0ZWQuXHJcbiAgICovXG4gIGlmIChtYXBwZWRTZWN0b3JQb3NpdGlvbiA9PT0gJ21pZGRsZScgJiYgcm90YXRlID4gTWF0aC5QSSAvIDIgJiYgcm90YXRlIDwgTWF0aC5QSSAqIDEuNSkge1xuICAgIHJvdGF0ZSAtPSBNYXRoLlBJO1xuICB9XG4gIHNlY3Rvci5zZXRUZXh0Q29uZmlnKHtcbiAgICByb3RhdGlvbjogcm90YXRlXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRqdXN0QW5nbGVEaXN0YW5jZVgoYW5nbGUsIGRpc3RhbmNlLCBpc0VuZCkge1xuICByZXR1cm4gZGlzdGFuY2UgKiBNYXRoLnNpbihhbmdsZSkgKiAoaXNFbmQgPyAtMSA6IDEpO1xufVxuZnVuY3Rpb24gYWRqdXN0QW5nbGVEaXN0YW5jZVkoYW5nbGUsIGRpc3RhbmNlLCBpc0VuZCkge1xuICByZXR1cm4gZGlzdGFuY2UgKiBNYXRoLmNvcyhhbmdsZSkgKiAoaXNFbmQgPyAxIDogLTEpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///94327\n")},95926:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24326);\n/* harmony import */ var _data_helper_dataStackHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65008);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n}\nfunction getAxisKey(polar, axis) {\n  return axis.dim + polar.model.componentIndex;\n}\nfunction barLayoutPolar(seriesType, ecModel, api) {\n  var lastStackCoords = {};\n  var barWidthAndOffset = calRadialBar(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'polar';\n  }));\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for polar only\n    if (seriesModel.coordinateSystem.type !== 'polar') {\n      return;\n    }\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisKey = getAxisKey(polar, baseAxis);\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = polar.getOtherAxis(baseAxis);\n    var cx = seriesModel.coordinateSystem.cx;\n    var cy = seriesModel.coordinateSystem.cy;\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var barMinAngle = seriesModel.get('barMinAngle') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = (0,_data_helper_dataStackHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .isDimensionStacked */ .sJ)(data, valueDim /* , baseDim */);\n    var clampLayout = baseAxis.dim !== 'radius' || !seriesModel.get('roundCap', true);\n    var valueAxisModel = valueAxis.model;\n    var startValue = valueAxisModel.get('startValue');\n    var valueAxisStart = valueAxis.dataToCoord(startValue || 0);\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart;\n      // Because of the barMinHeight, we can not use the value in\n      // stackResultDimension directly.\n      // Only ordinal axis can be stacked.\n      if (stacked) {\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            n: valueAxisStart // Negative stack\n          };\n        }\n        // Should also consider #4243\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n      var r0 = void 0;\n      var r = void 0;\n      var startAngle = void 0;\n      var endAngle = void 0;\n      // radial sector\n      if (valueAxis.dim === 'radius') {\n        var radiusSpan = valueAxis.dataToCoord(value) - valueAxisStart;\n        var angle = baseAxis.dataToCoord(baseValue);\n        if (Math.abs(radiusSpan) < barMinHeight) {\n          radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;\n        }\n        r0 = baseCoord;\n        r = baseCoord + radiusSpan;\n        startAngle = angle - columnOffset;\n        endAngle = startAngle - columnWidth;\n        stacked && (lastStackCoords[stackId][baseValue][sign] = r);\n      }\n      // tangential sector\n      else {\n        var angleSpan = valueAxis.dataToCoord(value, clampLayout) - valueAxisStart;\n        var radius = baseAxis.dataToCoord(baseValue);\n        if (Math.abs(angleSpan) < barMinAngle) {\n          angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;\n        }\n        r0 = radius + columnOffset;\n        r = r0 + columnWidth;\n        startAngle = baseCoord;\n        endAngle = baseCoord + angleSpan;\n        // if the previous stack is at the end of the ring,\n        // add a round to differentiate it from origin\n        // let extent = angleAxis.getExtent();\n        // let stackCoord = angle;\n        // if (stackCoord === extent[0] && value > 0) {\n        //     stackCoord = extent[1];\n        // }\n        // else if (stackCoord === extent[1] && value < 0) {\n        //     stackCoord = extent[0];\n        // }\n        stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);\n      }\n      data.setItemLayout(idx, {\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: r,\n        // Consider that positive angle is anti-clockwise,\n        // while positive radian of sector is clockwise\n        startAngle: -startAngle * Math.PI / 180,\n        endAngle: -endAngle * Math.PI / 180,\n        /**\r\n         * Keep the same logic with bar in catesion: use end value to\r\n         * control direction. Notice that if clockwise is true (by\r\n         * default), the sector will always draw clockwisely, no matter\r\n         * whether endAngle is greater or less than startAngle.\r\n         */\n        clockwise: startAngle >= endAngle\n      });\n    }\n  });\n}\n/**\r\n * Calculate bar width and offset for radial bar charts\r\n */\nfunction calRadialBar(barSeries) {\n  // Columns info on each category axis. Key is polar name\n  var columnsMap = {};\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(barSeries, function (seriesModel, idx) {\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisKey = getAxisKey(polar, baseAxis);\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = getSeriesStackId(seriesModel);\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    };\n    var barWidth = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .parsePercent */ .lo)(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .parsePercent */ .lo)(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    if (barWidth && !stacks[stackId].width) {\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      stacks[stackId].width = barWidth;\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    barGap != null && (columnsOnAxis.gap = barGap);\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .parsePercent */ .lo)(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .parsePercent */ .lo)(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    // Find if any auto calculated bar exceeded maxBarWidth\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    });\n    // Recalculate width again\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n    var offset = -widthSum / 2;\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (barLayoutPolar);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTU5MjYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbGF5b3V0L2JhclBvbGFyLmpzP2UzNGQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IHBhcnNlUGVyY2VudCB9IGZyb20gJy4uL3V0aWwvbnVtYmVyLmpzJztcbmltcG9ydCB7IGlzRGltZW5zaW9uU3RhY2tlZCB9IGZyb20gJy4uL2RhdGEvaGVscGVyL2RhdGFTdGFja0hlbHBlci5qcyc7XG5mdW5jdGlvbiBnZXRTZXJpZXNTdGFja0lkKHNlcmllc01vZGVsKSB7XG4gIHJldHVybiBzZXJpZXNNb2RlbC5nZXQoJ3N0YWNrJykgfHwgJ19fZWNfc3RhY2tfJyArIHNlcmllc01vZGVsLnNlcmllc0luZGV4O1xufVxuZnVuY3Rpb24gZ2V0QXhpc0tleShwb2xhciwgYXhpcykge1xuICByZXR1cm4gYXhpcy5kaW0gKyBwb2xhci5tb2RlbC5jb21wb25lbnRJbmRleDtcbn1cbmZ1bmN0aW9uIGJhckxheW91dFBvbGFyKHNlcmllc1R5cGUsIGVjTW9kZWwsIGFwaSkge1xuICB2YXIgbGFzdFN0YWNrQ29vcmRzID0ge307XG4gIHZhciBiYXJXaWR0aEFuZE9mZnNldCA9IGNhbFJhZGlhbEJhcih6clV0aWwuZmlsdGVyKGVjTW9kZWwuZ2V0U2VyaWVzQnlUeXBlKHNlcmllc1R5cGUpLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICByZXR1cm4gIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbCkgJiYgc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSAmJiBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtLnR5cGUgPT09ICdwb2xhcic7XG4gIH0pKTtcbiAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIC8vIENoZWNrIHNlcmllcyBjb29yZGluYXRlLCBkbyBsYXlvdXQgZm9yIHBvbGFyIG9ubHlcbiAgICBpZiAoc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS50eXBlICE9PSAncG9sYXInKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBwb2xhciA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgdmFyIGJhc2VBeGlzID0gcG9sYXIuZ2V0QmFzZUF4aXMoKTtcbiAgICB2YXIgYXhpc0tleSA9IGdldEF4aXNLZXkocG9sYXIsIGJhc2VBeGlzKTtcbiAgICB2YXIgc3RhY2tJZCA9IGdldFNlcmllc1N0YWNrSWQoc2VyaWVzTW9kZWwpO1xuICAgIHZhciBjb2x1bW5MYXlvdXRJbmZvID0gYmFyV2lkdGhBbmRPZmZzZXRbYXhpc0tleV1bc3RhY2tJZF07XG4gICAgdmFyIGNvbHVtbk9mZnNldCA9IGNvbHVtbkxheW91dEluZm8ub2Zmc2V0O1xuICAgIHZhciBjb2x1bW5XaWR0aCA9IGNvbHVtbkxheW91dEluZm8ud2lkdGg7XG4gICAgdmFyIHZhbHVlQXhpcyA9IHBvbGFyLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgdmFyIGN4ID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5jeDtcbiAgICB2YXIgY3kgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtLmN5O1xuICAgIHZhciBiYXJNaW5IZWlnaHQgPSBzZXJpZXNNb2RlbC5nZXQoJ2Jhck1pbkhlaWdodCcpIHx8IDA7XG4gICAgdmFyIGJhck1pbkFuZ2xlID0gc2VyaWVzTW9kZWwuZ2V0KCdiYXJNaW5BbmdsZScpIHx8IDA7XG4gICAgbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdID0gbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdIHx8IFtdO1xuICAgIHZhciB2YWx1ZURpbSA9IGRhdGEubWFwRGltZW5zaW9uKHZhbHVlQXhpcy5kaW0pO1xuICAgIHZhciBiYXNlRGltID0gZGF0YS5tYXBEaW1lbnNpb24oYmFzZUF4aXMuZGltKTtcbiAgICB2YXIgc3RhY2tlZCA9IGlzRGltZW5zaW9uU3RhY2tlZChkYXRhLCB2YWx1ZURpbSAvKiAsIGJhc2VEaW0gKi8pO1xuICAgIHZhciBjbGFtcExheW91dCA9IGJhc2VBeGlzLmRpbSAhPT0gJ3JhZGl1cycgfHwgIXNlcmllc01vZGVsLmdldCgncm91bmRDYXAnLCB0cnVlKTtcbiAgICB2YXIgdmFsdWVBeGlzTW9kZWwgPSB2YWx1ZUF4aXMubW9kZWw7XG4gICAgdmFyIHN0YXJ0VmFsdWUgPSB2YWx1ZUF4aXNNb2RlbC5nZXQoJ3N0YXJ0VmFsdWUnKTtcbiAgICB2YXIgdmFsdWVBeGlzU3RhcnQgPSB2YWx1ZUF4aXMuZGF0YVRvQ29vcmQoc3RhcnRWYWx1ZSB8fCAwKTtcbiAgICBmb3IgKHZhciBpZHggPSAwLCBsZW4gPSBkYXRhLmNvdW50KCk7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGRhdGEuZ2V0KHZhbHVlRGltLCBpZHgpO1xuICAgICAgdmFyIGJhc2VWYWx1ZSA9IGRhdGEuZ2V0KGJhc2VEaW0sIGlkeCk7XG4gICAgICB2YXIgc2lnbiA9IHZhbHVlID49IDAgPyAncCcgOiAnbic7XG4gICAgICB2YXIgYmFzZUNvb3JkID0gdmFsdWVBeGlzU3RhcnQ7XG4gICAgICAvLyBCZWNhdXNlIG9mIHRoZSBiYXJNaW5IZWlnaHQsIHdlIGNhbiBub3QgdXNlIHRoZSB2YWx1ZSBpblxuICAgICAgLy8gc3RhY2tSZXN1bHREaW1lbnNpb24gZGlyZWN0bHkuXG4gICAgICAvLyBPbmx5IG9yZGluYWwgYXhpcyBjYW4gYmUgc3RhY2tlZC5cbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIGlmICghbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2Jhc2VWYWx1ZV0pIHtcbiAgICAgICAgICBsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF1bYmFzZVZhbHVlXSA9IHtcbiAgICAgICAgICAgIHA6IHZhbHVlQXhpc1N0YXJ0LFxuICAgICAgICAgICAgbjogdmFsdWVBeGlzU3RhcnQgLy8gTmVnYXRpdmUgc3RhY2tcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3VsZCBhbHNvIGNvbnNpZGVyICM0MjQzXG4gICAgICAgIGJhc2VDb29yZCA9IGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtiYXNlVmFsdWVdW3NpZ25dO1xuICAgICAgfVxuICAgICAgdmFyIHIwID0gdm9pZCAwO1xuICAgICAgdmFyIHIgPSB2b2lkIDA7XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IHZvaWQgMDtcbiAgICAgIHZhciBlbmRBbmdsZSA9IHZvaWQgMDtcbiAgICAgIC8vIHJhZGlhbCBzZWN0b3JcbiAgICAgIGlmICh2YWx1ZUF4aXMuZGltID09PSAncmFkaXVzJykge1xuICAgICAgICB2YXIgcmFkaXVzU3BhbiA9IHZhbHVlQXhpcy5kYXRhVG9Db29yZCh2YWx1ZSkgLSB2YWx1ZUF4aXNTdGFydDtcbiAgICAgICAgdmFyIGFuZ2xlID0gYmFzZUF4aXMuZGF0YVRvQ29vcmQoYmFzZVZhbHVlKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHJhZGl1c1NwYW4pIDwgYmFyTWluSGVpZ2h0KSB7XG4gICAgICAgICAgcmFkaXVzU3BhbiA9IChyYWRpdXNTcGFuIDwgMCA/IC0xIDogMSkgKiBiYXJNaW5IZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcjAgPSBiYXNlQ29vcmQ7XG4gICAgICAgIHIgPSBiYXNlQ29vcmQgKyByYWRpdXNTcGFuO1xuICAgICAgICBzdGFydEFuZ2xlID0gYW5nbGUgLSBjb2x1bW5PZmZzZXQ7XG4gICAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSAtIGNvbHVtbldpZHRoO1xuICAgICAgICBzdGFja2VkICYmIChsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF1bYmFzZVZhbHVlXVtzaWduXSA9IHIpO1xuICAgICAgfVxuICAgICAgLy8gdGFuZ2VudGlhbCBzZWN0b3JcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgYW5nbGVTcGFuID0gdmFsdWVBeGlzLmRhdGFUb0Nvb3JkKHZhbHVlLCBjbGFtcExheW91dCkgLSB2YWx1ZUF4aXNTdGFydDtcbiAgICAgICAgdmFyIHJhZGl1cyA9IGJhc2VBeGlzLmRhdGFUb0Nvb3JkKGJhc2VWYWx1ZSk7XG4gICAgICAgIGlmIChNYXRoLmFicyhhbmdsZVNwYW4pIDwgYmFyTWluQW5nbGUpIHtcbiAgICAgICAgICBhbmdsZVNwYW4gPSAoYW5nbGVTcGFuIDwgMCA/IC0xIDogMSkgKiBiYXJNaW5BbmdsZTtcbiAgICAgICAgfVxuICAgICAgICByMCA9IHJhZGl1cyArIGNvbHVtbk9mZnNldDtcbiAgICAgICAgciA9IHIwICsgY29sdW1uV2lkdGg7XG4gICAgICAgIHN0YXJ0QW5nbGUgPSBiYXNlQ29vcmQ7XG4gICAgICAgIGVuZEFuZ2xlID0gYmFzZUNvb3JkICsgYW5nbGVTcGFuO1xuICAgICAgICAvLyBpZiB0aGUgcHJldmlvdXMgc3RhY2sgaXMgYXQgdGhlIGVuZCBvZiB0aGUgcmluZyxcbiAgICAgICAgLy8gYWRkIGEgcm91bmQgdG8gZGlmZmVyZW50aWF0ZSBpdCBmcm9tIG9yaWdpblxuICAgICAgICAvLyBsZXQgZXh0ZW50ID0gYW5nbGVBeGlzLmdldEV4dGVudCgpO1xuICAgICAgICAvLyBsZXQgc3RhY2tDb29yZCA9IGFuZ2xlO1xuICAgICAgICAvLyBpZiAoc3RhY2tDb29yZCA9PT0gZXh0ZW50WzBdICYmIHZhbHVlID4gMCkge1xuICAgICAgICAvLyAgICAgc3RhY2tDb29yZCA9IGV4dGVudFsxXTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBlbHNlIGlmIChzdGFja0Nvb3JkID09PSBleHRlbnRbMV0gJiYgdmFsdWUgPCAwKSB7XG4gICAgICAgIC8vICAgICBzdGFja0Nvb3JkID0gZXh0ZW50WzBdO1xuICAgICAgICAvLyB9XG4gICAgICAgIHN0YWNrZWQgJiYgKGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtiYXNlVmFsdWVdW3NpZ25dID0gZW5kQW5nbGUpO1xuICAgICAgfVxuICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwge1xuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeSxcbiAgICAgICAgcjA6IHIwLFxuICAgICAgICByOiByLFxuICAgICAgICAvLyBDb25zaWRlciB0aGF0IHBvc2l0aXZlIGFuZ2xlIGlzIGFudGktY2xvY2t3aXNlLFxuICAgICAgICAvLyB3aGlsZSBwb3NpdGl2ZSByYWRpYW4gb2Ygc2VjdG9yIGlzIGNsb2Nrd2lzZVxuICAgICAgICBzdGFydEFuZ2xlOiAtc3RhcnRBbmdsZSAqIE1hdGguUEkgLyAxODAsXG4gICAgICAgIGVuZEFuZ2xlOiAtZW5kQW5nbGUgKiBNYXRoLlBJIC8gMTgwLFxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLZWVwIHRoZSBzYW1lIGxvZ2ljIHdpdGggYmFyIGluIGNhdGVzaW9uOiB1c2UgZW5kIHZhbHVlIHRvXHJcbiAgICAgICAgICogY29udHJvbCBkaXJlY3Rpb24uIE5vdGljZSB0aGF0IGlmIGNsb2Nrd2lzZSBpcyB0cnVlIChieVxyXG4gICAgICAgICAqIGRlZmF1bHQpLCB0aGUgc2VjdG9yIHdpbGwgYWx3YXlzIGRyYXcgY2xvY2t3aXNlbHksIG5vIG1hdHRlclxyXG4gICAgICAgICAqIHdoZXRoZXIgZW5kQW5nbGUgaXMgZ3JlYXRlciBvciBsZXNzIHRoYW4gc3RhcnRBbmdsZS5cclxuICAgICAgICAgKi9cbiAgICAgICAgY2xvY2t3aXNlOiBzdGFydEFuZ2xlID49IGVuZEFuZ2xlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZSBiYXIgd2lkdGggYW5kIG9mZnNldCBmb3IgcmFkaWFsIGJhciBjaGFydHNcclxuICovXG5mdW5jdGlvbiBjYWxSYWRpYWxCYXIoYmFyU2VyaWVzKSB7XG4gIC8vIENvbHVtbnMgaW5mbyBvbiBlYWNoIGNhdGVnb3J5IGF4aXMuIEtleSBpcyBwb2xhciBuYW1lXG4gIHZhciBjb2x1bW5zTWFwID0ge307XG4gIHpyVXRpbC5lYWNoKGJhclNlcmllcywgZnVuY3Rpb24gKHNlcmllc01vZGVsLCBpZHgpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgcG9sYXIgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIHZhciBiYXNlQXhpcyA9IHBvbGFyLmdldEJhc2VBeGlzKCk7XG4gICAgdmFyIGF4aXNLZXkgPSBnZXRBeGlzS2V5KHBvbGFyLCBiYXNlQXhpcyk7XG4gICAgdmFyIGF4aXNFeHRlbnQgPSBiYXNlQXhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgYmFuZFdpZHRoID0gYmFzZUF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IGJhc2VBeGlzLmdldEJhbmRXaWR0aCgpIDogTWF0aC5hYnMoYXhpc0V4dGVudFsxXSAtIGF4aXNFeHRlbnRbMF0pIC8gZGF0YS5jb3VudCgpO1xuICAgIHZhciBjb2x1bW5zT25BeGlzID0gY29sdW1uc01hcFtheGlzS2V5XSB8fCB7XG4gICAgICBiYW5kV2lkdGg6IGJhbmRXaWR0aCxcbiAgICAgIHJlbWFpbmVkV2lkdGg6IGJhbmRXaWR0aCxcbiAgICAgIGF1dG9XaWR0aENvdW50OiAwLFxuICAgICAgY2F0ZWdvcnlHYXA6ICcyMCUnLFxuICAgICAgZ2FwOiAnMzAlJyxcbiAgICAgIHN0YWNrczoge31cbiAgICB9O1xuICAgIHZhciBzdGFja3MgPSBjb2x1bW5zT25BeGlzLnN0YWNrcztcbiAgICBjb2x1bW5zTWFwW2F4aXNLZXldID0gY29sdW1uc09uQXhpcztcbiAgICB2YXIgc3RhY2tJZCA9IGdldFNlcmllc1N0YWNrSWQoc2VyaWVzTW9kZWwpO1xuICAgIGlmICghc3RhY2tzW3N0YWNrSWRdKSB7XG4gICAgICBjb2x1bW5zT25BeGlzLmF1dG9XaWR0aENvdW50Kys7XG4gICAgfVxuICAgIHN0YWNrc1tzdGFja0lkXSA9IHN0YWNrc1tzdGFja0lkXSB8fCB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIG1heFdpZHRoOiAwXG4gICAgfTtcbiAgICB2YXIgYmFyV2lkdGggPSBwYXJzZVBlcmNlbnQoc2VyaWVzTW9kZWwuZ2V0KCdiYXJXaWR0aCcpLCBiYW5kV2lkdGgpO1xuICAgIHZhciBiYXJNYXhXaWR0aCA9IHBhcnNlUGVyY2VudChzZXJpZXNNb2RlbC5nZXQoJ2Jhck1heFdpZHRoJyksIGJhbmRXaWR0aCk7XG4gICAgdmFyIGJhckdhcCA9IHNlcmllc01vZGVsLmdldCgnYmFyR2FwJyk7XG4gICAgdmFyIGJhckNhdGVnb3J5R2FwID0gc2VyaWVzTW9kZWwuZ2V0KCdiYXJDYXRlZ29yeUdhcCcpO1xuICAgIGlmIChiYXJXaWR0aCAmJiAhc3RhY2tzW3N0YWNrSWRdLndpZHRoKSB7XG4gICAgICBiYXJXaWR0aCA9IE1hdGgubWluKGNvbHVtbnNPbkF4aXMucmVtYWluZWRXaWR0aCwgYmFyV2lkdGgpO1xuICAgICAgc3RhY2tzW3N0YWNrSWRdLndpZHRoID0gYmFyV2lkdGg7XG4gICAgICBjb2x1bW5zT25BeGlzLnJlbWFpbmVkV2lkdGggLT0gYmFyV2lkdGg7XG4gICAgfVxuICAgIGJhck1heFdpZHRoICYmIChzdGFja3Nbc3RhY2tJZF0ubWF4V2lkdGggPSBiYXJNYXhXaWR0aCk7XG4gICAgYmFyR2FwICE9IG51bGwgJiYgKGNvbHVtbnNPbkF4aXMuZ2FwID0gYmFyR2FwKTtcbiAgICBiYXJDYXRlZ29yeUdhcCAhPSBudWxsICYmIChjb2x1bW5zT25BeGlzLmNhdGVnb3J5R2FwID0gYmFyQ2F0ZWdvcnlHYXApO1xuICB9KTtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB6clV0aWwuZWFjaChjb2x1bW5zTWFwLCBmdW5jdGlvbiAoY29sdW1uc09uQXhpcywgY29vcmRTeXNOYW1lKSB7XG4gICAgcmVzdWx0W2Nvb3JkU3lzTmFtZV0gPSB7fTtcbiAgICB2YXIgc3RhY2tzID0gY29sdW1uc09uQXhpcy5zdGFja3M7XG4gICAgdmFyIGJhbmRXaWR0aCA9IGNvbHVtbnNPbkF4aXMuYmFuZFdpZHRoO1xuICAgIHZhciBjYXRlZ29yeUdhcCA9IHBhcnNlUGVyY2VudChjb2x1bW5zT25BeGlzLmNhdGVnb3J5R2FwLCBiYW5kV2lkdGgpO1xuICAgIHZhciBiYXJHYXBQZXJjZW50ID0gcGFyc2VQZXJjZW50KGNvbHVtbnNPbkF4aXMuZ2FwLCAxKTtcbiAgICB2YXIgcmVtYWluZWRXaWR0aCA9IGNvbHVtbnNPbkF4aXMucmVtYWluZWRXaWR0aDtcbiAgICB2YXIgYXV0b1dpZHRoQ291bnQgPSBjb2x1bW5zT25BeGlzLmF1dG9XaWR0aENvdW50O1xuICAgIHZhciBhdXRvV2lkdGggPSAocmVtYWluZWRXaWR0aCAtIGNhdGVnb3J5R2FwKSAvIChhdXRvV2lkdGhDb3VudCArIChhdXRvV2lkdGhDb3VudCAtIDEpICogYmFyR2FwUGVyY2VudCk7XG4gICAgYXV0b1dpZHRoID0gTWF0aC5tYXgoYXV0b1dpZHRoLCAwKTtcbiAgICAvLyBGaW5kIGlmIGFueSBhdXRvIGNhbGN1bGF0ZWQgYmFyIGV4Y2VlZGVkIG1heEJhcldpZHRoXG4gICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBzdGFjaykge1xuICAgICAgdmFyIG1heFdpZHRoID0gY29sdW1uLm1heFdpZHRoO1xuICAgICAgaWYgKG1heFdpZHRoICYmIG1heFdpZHRoIDwgYXV0b1dpZHRoKSB7XG4gICAgICAgIG1heFdpZHRoID0gTWF0aC5taW4obWF4V2lkdGgsIHJlbWFpbmVkV2lkdGgpO1xuICAgICAgICBpZiAoY29sdW1uLndpZHRoKSB7XG4gICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbihtYXhXaWR0aCwgY29sdW1uLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICByZW1haW5lZFdpZHRoIC09IG1heFdpZHRoO1xuICAgICAgICBjb2x1bW4ud2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgYXV0b1dpZHRoQ291bnQtLTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBSZWNhbGN1bGF0ZSB3aWR0aCBhZ2FpblxuICAgIGF1dG9XaWR0aCA9IChyZW1haW5lZFdpZHRoIC0gY2F0ZWdvcnlHYXApIC8gKGF1dG9XaWR0aENvdW50ICsgKGF1dG9XaWR0aENvdW50IC0gMSkgKiBiYXJHYXBQZXJjZW50KTtcbiAgICBhdXRvV2lkdGggPSBNYXRoLm1heChhdXRvV2lkdGgsIDApO1xuICAgIHZhciB3aWR0aFN1bSA9IDA7XG4gICAgdmFyIGxhc3RDb2x1bW47XG4gICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBpZHgpIHtcbiAgICAgIGlmICghY29sdW1uLndpZHRoKSB7XG4gICAgICAgIGNvbHVtbi53aWR0aCA9IGF1dG9XaWR0aDtcbiAgICAgIH1cbiAgICAgIGxhc3RDb2x1bW4gPSBjb2x1bW47XG4gICAgICB3aWR0aFN1bSArPSBjb2x1bW4ud2lkdGggKiAoMSArIGJhckdhcFBlcmNlbnQpO1xuICAgIH0pO1xuICAgIGlmIChsYXN0Q29sdW1uKSB7XG4gICAgICB3aWR0aFN1bSAtPSBsYXN0Q29sdW1uLndpZHRoICogYmFyR2FwUGVyY2VudDtcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IC13aWR0aFN1bSAvIDI7XG4gICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBzdGFja0lkKSB7XG4gICAgICByZXN1bHRbY29vcmRTeXNOYW1lXVtzdGFja0lkXSA9IHJlc3VsdFtjb29yZFN5c05hbWVdW3N0YWNrSWRdIHx8IHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHdpZHRoOiBjb2x1bW4ud2lkdGhcbiAgICAgIH07XG4gICAgICBvZmZzZXQgKz0gY29sdW1uLndpZHRoICogKDEgKyBiYXJHYXBQZXJjZW50KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZGVmYXVsdCBiYXJMYXlvdXRQb2xhcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///95926\n")}}]);