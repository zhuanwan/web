"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[7032],{2141:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ parseXML)\n/* harmony export */ });\n/* harmony import */ var _core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\nfunction parseXML(svg) {\n    if ((0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString)(svg)) {\n        var parser = new DOMParser();\n        svg = parser.parseFromString(svg, 'text/xml');\n    }\n    var svgNode = svg;\n    if (svgNode.nodeType === 9) {\n        svgNode = svgNode.firstChild;\n    }\n    while (svgNode.nodeName.toLowerCase() !== 'svg' || svgNode.nodeType !== 1) {\n        svgNode = svgNode.nextSibling;\n    }\n    return svgNode;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE0MS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvcGFyc2VYTUwuanM/MmM0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJy4uL2NvcmUvdXRpbC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VYTUwoc3ZnKSB7XG4gICAgaWYgKGlzU3RyaW5nKHN2ZykpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgc3ZnID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdmcsICd0ZXh0L3htbCcpO1xuICAgIH1cbiAgICB2YXIgc3ZnTm9kZSA9IHN2ZztcbiAgICBpZiAoc3ZnTm9kZS5ub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICBzdmdOb2RlID0gc3ZnTm9kZS5maXJzdENoaWxkO1xuICAgIH1cbiAgICB3aGlsZSAoc3ZnTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnc3ZnJyB8fCBzdmdOb2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgIHN2Z05vZGUgPSBzdmdOb2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gc3ZnTm9kZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2141\n")},15727:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C6: () => (/* binding */ __extends)\n/* harmony export */ });\n/* unused harmony exports __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __spreadArray, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== "function" && b !== null)\r\n        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === "number") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i["return"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume("next", value); }\r\n    function reject(value) { resume("throw", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o["default"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\r\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === "m") throw new TypeError("Private method is not writable");\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\r\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU3MjcuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvenJlbmRlci9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzPzIxYTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBmcm9tKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15727\n')},33572:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dispose: () => (/* binding */ dispose),\n/* harmony export */   disposeAll: () => (/* binding */ disposeAll),\n/* harmony export */   getElementSSRData: () => (/* binding */ getElementSSRData),\n/* harmony export */   getInstance: () => (/* binding */ getInstance),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   registerPainter: () => (/* binding */ registerPainter),\n/* harmony export */   registerSSRDataGetter: () => (/* binding */ registerSSRDataGetter),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _core_env_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38123);\n/* harmony import */ var _core_util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98026);\n/* harmony import */ var _Handler_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(56494);\n/* harmony import */ var _Storage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14647);\n/* harmony import */ var _animation_Animation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(79021);\n/* harmony import */ var _dom_HandlerProxy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(22889);\n/* harmony import */ var _tool_color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47698);\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73098);\n/* harmony import */ var _graphic_Group_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(43870);\n/*!\n* ZRender, a high performance 2d drawing library.\n*\n* Copyright (c) 2013, Baidu Inc.\n* All rights reserved.\n*\n* LICENSE\n* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n*/\n\n\n\n\n\n\n\n\n\nvar painterCtors = {};\nvar instances = {};\nfunction delInstance(id) {\n    delete instances[id];\n}\nfunction isDarkMode(backgroundColor) {\n    if (!backgroundColor) {\n        return false;\n    }\n    if (typeof backgroundColor === \'string\') {\n        return (0,_tool_color_js__WEBPACK_IMPORTED_MODULE_0__.lum)(backgroundColor, 1) < _config_js__WEBPACK_IMPORTED_MODULE_1__/* .DARK_MODE_THRESHOLD */ .ps;\n    }\n    else if (backgroundColor.colorStops) {\n        var colorStops = backgroundColor.colorStops;\n        var totalLum = 0;\n        var len = colorStops.length;\n        for (var i = 0; i < len; i++) {\n            totalLum += (0,_tool_color_js__WEBPACK_IMPORTED_MODULE_0__.lum)(colorStops[i].color, 1);\n        }\n        totalLum /= len;\n        return totalLum < _config_js__WEBPACK_IMPORTED_MODULE_1__/* .DARK_MODE_THRESHOLD */ .ps;\n    }\n    return false;\n}\nvar ZRender = (function () {\n    function ZRender(id, dom, opts) {\n        var _this = this;\n        this._sleepAfterStill = 10;\n        this._stillFrameAccum = 0;\n        this._needsRefresh = true;\n        this._needsRefreshHover = true;\n        this._darkMode = false;\n        opts = opts || {};\n        this.dom = dom;\n        this.id = id;\n        var storage = new _Storage_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A();\n        var rendererType = opts.renderer || \'canvas\';\n        if (!painterCtors[rendererType]) {\n            rendererType = _core_util_js__WEBPACK_IMPORTED_MODULE_3__.keys(painterCtors)[0];\n        }\n        if (false) {}\n        opts.useDirtyRect = opts.useDirtyRect == null\n            ? false\n            : opts.useDirtyRect;\n        var painter = new painterCtors[rendererType](dom, storage, opts, id);\n        var ssrMode = opts.ssr || painter.ssrOnly;\n        this.storage = storage;\n        this.painter = painter;\n        var handlerProxy = (!_core_env_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.node && !_core_env_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.worker && !ssrMode)\n            ? new _dom_HandlerProxy_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A(painter.getViewportRoot(), painter.root)\n            : null;\n        var useCoarsePointer = opts.useCoarsePointer;\n        var usePointerSize = (useCoarsePointer == null || useCoarsePointer === \'auto\')\n            ? _core_env_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.touchEventsSupported\n            : !!useCoarsePointer;\n        var defaultPointerSize = 44;\n        var pointerSize;\n        if (usePointerSize) {\n            pointerSize = _core_util_js__WEBPACK_IMPORTED_MODULE_3__.retrieve2(opts.pointerSize, defaultPointerSize);\n        }\n        this.handler = new _Handler_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A(storage, painter, handlerProxy, painter.root, pointerSize);\n        this.animation = new _animation_Animation_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A({\n            stage: {\n                update: ssrMode ? null : function () { return _this._flush(true); }\n            }\n        });\n        if (!ssrMode) {\n            this.animation.start();\n        }\n    }\n    ZRender.prototype.add = function (el) {\n        if (this._disposed || !el) {\n            return;\n        }\n        this.storage.addRoot(el);\n        el.addSelfToZr(this);\n        this.refresh();\n    };\n    ZRender.prototype.remove = function (el) {\n        if (this._disposed || !el) {\n            return;\n        }\n        this.storage.delRoot(el);\n        el.removeSelfFromZr(this);\n        this.refresh();\n    };\n    ZRender.prototype.configLayer = function (zLevel, config) {\n        if (this._disposed) {\n            return;\n        }\n        if (this.painter.configLayer) {\n            this.painter.configLayer(zLevel, config);\n        }\n        this.refresh();\n    };\n    ZRender.prototype.setBackgroundColor = function (backgroundColor) {\n        if (this._disposed) {\n            return;\n        }\n        if (this.painter.setBackgroundColor) {\n            this.painter.setBackgroundColor(backgroundColor);\n        }\n        this.refresh();\n        this._backgroundColor = backgroundColor;\n        this._darkMode = isDarkMode(backgroundColor);\n    };\n    ZRender.prototype.getBackgroundColor = function () {\n        return this._backgroundColor;\n    };\n    ZRender.prototype.setDarkMode = function (darkMode) {\n        this._darkMode = darkMode;\n    };\n    ZRender.prototype.isDarkMode = function () {\n        return this._darkMode;\n    };\n    ZRender.prototype.refreshImmediately = function (fromInside) {\n        if (this._disposed) {\n            return;\n        }\n        if (!fromInside) {\n            this.animation.update(true);\n        }\n        this._needsRefresh = false;\n        this.painter.refresh();\n        this._needsRefresh = false;\n    };\n    ZRender.prototype.refresh = function () {\n        if (this._disposed) {\n            return;\n        }\n        this._needsRefresh = true;\n        this.animation.start();\n    };\n    ZRender.prototype.flush = function () {\n        if (this._disposed) {\n            return;\n        }\n        this._flush(false);\n    };\n    ZRender.prototype._flush = function (fromInside) {\n        var triggerRendered;\n        var start = (0,_animation_Animation_js__WEBPACK_IMPORTED_MODULE_7__/* .getTime */ .W)();\n        if (this._needsRefresh) {\n            triggerRendered = true;\n            this.refreshImmediately(fromInside);\n        }\n        if (this._needsRefreshHover) {\n            triggerRendered = true;\n            this.refreshHoverImmediately();\n        }\n        var end = (0,_animation_Animation_js__WEBPACK_IMPORTED_MODULE_7__/* .getTime */ .W)();\n        if (triggerRendered) {\n            this._stillFrameAccum = 0;\n            this.trigger(\'rendered\', {\n                elapsedTime: end - start\n            });\n        }\n        else if (this._sleepAfterStill > 0) {\n            this._stillFrameAccum++;\n            if (this._stillFrameAccum > this._sleepAfterStill) {\n                this.animation.stop();\n            }\n        }\n    };\n    ZRender.prototype.setSleepAfterStill = function (stillFramesCount) {\n        this._sleepAfterStill = stillFramesCount;\n    };\n    ZRender.prototype.wakeUp = function () {\n        if (this._disposed) {\n            return;\n        }\n        this.animation.start();\n        this._stillFrameAccum = 0;\n    };\n    ZRender.prototype.refreshHover = function () {\n        this._needsRefreshHover = true;\n    };\n    ZRender.prototype.refreshHoverImmediately = function () {\n        if (this._disposed) {\n            return;\n        }\n        this._needsRefreshHover = false;\n        if (this.painter.refreshHover && this.painter.getType() === \'canvas\') {\n            this.painter.refreshHover();\n        }\n    };\n    ZRender.prototype.resize = function (opts) {\n        if (this._disposed) {\n            return;\n        }\n        opts = opts || {};\n        this.painter.resize(opts.width, opts.height);\n        this.handler.resize();\n    };\n    ZRender.prototype.clearAnimation = function () {\n        if (this._disposed) {\n            return;\n        }\n        this.animation.clear();\n    };\n    ZRender.prototype.getWidth = function () {\n        if (this._disposed) {\n            return;\n        }\n        return this.painter.getWidth();\n    };\n    ZRender.prototype.getHeight = function () {\n        if (this._disposed) {\n            return;\n        }\n        return this.painter.getHeight();\n    };\n    ZRender.prototype.setCursorStyle = function (cursorStyle) {\n        if (this._disposed) {\n            return;\n        }\n        this.handler.setCursorStyle(cursorStyle);\n    };\n    ZRender.prototype.findHover = function (x, y) {\n        if (this._disposed) {\n            return;\n        }\n        return this.handler.findHover(x, y);\n    };\n    ZRender.prototype.on = function (eventName, eventHandler, context) {\n        if (!this._disposed) {\n            this.handler.on(eventName, eventHandler, context);\n        }\n        return this;\n    };\n    ZRender.prototype.off = function (eventName, eventHandler) {\n        if (this._disposed) {\n            return;\n        }\n        this.handler.off(eventName, eventHandler);\n    };\n    ZRender.prototype.trigger = function (eventName, event) {\n        if (this._disposed) {\n            return;\n        }\n        this.handler.trigger(eventName, event);\n    };\n    ZRender.prototype.clear = function () {\n        if (this._disposed) {\n            return;\n        }\n        var roots = this.storage.getRoots();\n        for (var i = 0; i < roots.length; i++) {\n            if (roots[i] instanceof _graphic_Group_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A) {\n                roots[i].removeSelfFromZr(this);\n            }\n        }\n        this.storage.delAllRoots();\n        this.painter.clear();\n    };\n    ZRender.prototype.dispose = function () {\n        if (this._disposed) {\n            return;\n        }\n        this.animation.stop();\n        this.clear();\n        this.storage.dispose();\n        this.painter.dispose();\n        this.handler.dispose();\n        this.animation =\n            this.storage =\n                this.painter =\n                    this.handler = null;\n        this._disposed = true;\n        delInstance(this.id);\n    };\n    return ZRender;\n}());\nfunction init(dom, opts) {\n    var zr = new ZRender(_core_util_js__WEBPACK_IMPORTED_MODULE_3__.guid(), dom, opts);\n    instances[zr.id] = zr;\n    return zr;\n}\nfunction dispose(zr) {\n    zr.dispose();\n}\nfunction disposeAll() {\n    for (var key in instances) {\n        if (instances.hasOwnProperty(key)) {\n            instances[key].dispose();\n        }\n    }\n    instances = {};\n}\nfunction getInstance(id) {\n    return instances[id];\n}\nfunction registerPainter(name, Ctor) {\n    painterCtors[name] = Ctor;\n}\nvar ssrDataGetter;\nfunction getElementSSRData(el) {\n    if (typeof ssrDataGetter === \'function\') {\n        return ssrDataGetter(el);\n    }\n}\nfunction registerSSRDataGetter(getter) {\n    ssrDataGetter = getter;\n}\nvar version = \'5.6.1\';\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM1NzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvenJlbmRlci5qcz8yZTc3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuKiBaUmVuZGVyLCBhIGhpZ2ggcGVyZm9ybWFuY2UgMmQgZHJhd2luZyBsaWJyYXJ5LlxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJhaWR1IEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogTElDRU5TRVxuKiBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL3pyZW5kZXIvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbiovXG5pbXBvcnQgZW52IGZyb20gJy4vY29yZS9lbnYuanMnO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJy4vY29yZS91dGlsLmpzJztcbmltcG9ydCBIYW5kbGVyIGZyb20gJy4vSGFuZGxlci5qcyc7XG5pbXBvcnQgU3RvcmFnZSBmcm9tICcuL1N0b3JhZ2UuanMnO1xuaW1wb3J0IEFuaW1hdGlvbiwgeyBnZXRUaW1lIH0gZnJvbSAnLi9hbmltYXRpb24vQW5pbWF0aW9uLmpzJztcbmltcG9ydCBIYW5kbGVyUHJveHkgZnJvbSAnLi9kb20vSGFuZGxlclByb3h5LmpzJztcbmltcG9ydCB7IGx1bSB9IGZyb20gJy4vdG9vbC9jb2xvci5qcyc7XG5pbXBvcnQgeyBEQVJLX01PREVfVEhSRVNIT0xEIH0gZnJvbSAnLi9jb25maWcuanMnO1xuaW1wb3J0IEdyb3VwIGZyb20gJy4vZ3JhcGhpYy9Hcm91cC5qcyc7XG52YXIgcGFpbnRlckN0b3JzID0ge307XG52YXIgaW5zdGFuY2VzID0ge307XG5mdW5jdGlvbiBkZWxJbnN0YW5jZShpZCkge1xuICAgIGRlbGV0ZSBpbnN0YW5jZXNbaWRdO1xufVxuZnVuY3Rpb24gaXNEYXJrTW9kZShiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBpZiAoIWJhY2tncm91bmRDb2xvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYmFja2dyb3VuZENvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbHVtKGJhY2tncm91bmRDb2xvciwgMSkgPCBEQVJLX01PREVfVEhSRVNIT0xEO1xuICAgIH1cbiAgICBlbHNlIGlmIChiYWNrZ3JvdW5kQ29sb3IuY29sb3JTdG9wcykge1xuICAgICAgICB2YXIgY29sb3JTdG9wcyA9IGJhY2tncm91bmRDb2xvci5jb2xvclN0b3BzO1xuICAgICAgICB2YXIgdG90YWxMdW0gPSAwO1xuICAgICAgICB2YXIgbGVuID0gY29sb3JTdG9wcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRvdGFsTHVtICs9IGx1bShjb2xvclN0b3BzW2ldLmNvbG9yLCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0b3RhbEx1bSAvPSBsZW47XG4gICAgICAgIHJldHVybiB0b3RhbEx1bSA8IERBUktfTU9ERV9USFJFU0hPTEQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbnZhciBaUmVuZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBaUmVuZGVyKGlkLCBkb20sIG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fc2xlZXBBZnRlclN0aWxsID0gMTA7XG4gICAgICAgIHRoaXMuX3N0aWxsRnJhbWVBY2N1bSA9IDA7XG4gICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGFya01vZGUgPSBmYWxzZTtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHZhciBzdG9yYWdlID0gbmV3IFN0b3JhZ2UoKTtcbiAgICAgICAgdmFyIHJlbmRlcmVyVHlwZSA9IG9wdHMucmVuZGVyZXIgfHwgJ2NhbnZhcyc7XG4gICAgICAgIGlmICghcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0pIHtcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9IHpyVXRpbC5rZXlzKHBhaW50ZXJDdG9ycylbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmICghcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZW5kZXJlciAnXCIgKyByZW5kZXJlclR5cGUgKyBcIicgaXMgbm90IGltcG9ydGVkLiBQbGVhc2UgaW1wb3J0IGl0IGZpcnN0LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcHRzLnVzZURpcnR5UmVjdCA9IG9wdHMudXNlRGlydHlSZWN0ID09IG51bGxcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogb3B0cy51c2VEaXJ0eVJlY3Q7XG4gICAgICAgIHZhciBwYWludGVyID0gbmV3IHBhaW50ZXJDdG9yc1tyZW5kZXJlclR5cGVdKGRvbSwgc3RvcmFnZSwgb3B0cywgaWQpO1xuICAgICAgICB2YXIgc3NyTW9kZSA9IG9wdHMuc3NyIHx8IHBhaW50ZXIuc3NyT25seTtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICAgICAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgICAgICAgdmFyIGhhbmRsZXJQcm94eSA9ICghZW52Lm5vZGUgJiYgIWVudi53b3JrZXIgJiYgIXNzck1vZGUpXG4gICAgICAgICAgICA/IG5ldyBIYW5kbGVyUHJveHkocGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSwgcGFpbnRlci5yb290KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB2YXIgdXNlQ29hcnNlUG9pbnRlciA9IG9wdHMudXNlQ29hcnNlUG9pbnRlcjtcbiAgICAgICAgdmFyIHVzZVBvaW50ZXJTaXplID0gKHVzZUNvYXJzZVBvaW50ZXIgPT0gbnVsbCB8fCB1c2VDb2Fyc2VQb2ludGVyID09PSAnYXV0bycpXG4gICAgICAgICAgICA/IGVudi50b3VjaEV2ZW50c1N1cHBvcnRlZFxuICAgICAgICAgICAgOiAhIXVzZUNvYXJzZVBvaW50ZXI7XG4gICAgICAgIHZhciBkZWZhdWx0UG9pbnRlclNpemUgPSA0NDtcbiAgICAgICAgdmFyIHBvaW50ZXJTaXplO1xuICAgICAgICBpZiAodXNlUG9pbnRlclNpemUpIHtcbiAgICAgICAgICAgIHBvaW50ZXJTaXplID0genJVdGlsLnJldHJpZXZlMihvcHRzLnBvaW50ZXJTaXplLCBkZWZhdWx0UG9pbnRlclNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IG5ldyBIYW5kbGVyKHN0b3JhZ2UsIHBhaW50ZXIsIGhhbmRsZXJQcm94eSwgcGFpbnRlci5yb290LCBwb2ludGVyU2l6ZSk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7XG4gICAgICAgICAgICBzdGFnZToge1xuICAgICAgICAgICAgICAgIHVwZGF0ZTogc3NyTW9kZSA/IG51bGwgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZmx1c2godHJ1ZSk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc3NyTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBaUmVuZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkIHx8ICFlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmFnZS5hZGRSb290KGVsKTtcbiAgICAgICAgZWwuYWRkU2VsZlRvWnIodGhpcyk7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH07XG4gICAgWlJlbmRlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZCB8fCAhZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsUm9vdChlbCk7XG4gICAgICAgIGVsLnJlbW92ZVNlbGZGcm9tWnIodGhpcyk7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH07XG4gICAgWlJlbmRlci5wcm90b3R5cGUuY29uZmlnTGF5ZXIgPSBmdW5jdGlvbiAoekxldmVsLCBjb25maWcpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFpbnRlci5jb25maWdMYXllcikge1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmNvbmZpZ0xheWVyKHpMZXZlbCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9O1xuICAgIFpSZW5kZXIucHJvdG90eXBlLnNldEJhY2tncm91bmRDb2xvciA9IGZ1bmN0aW9uIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFpbnRlci5zZXRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5zZXRCYWNrZ3JvdW5kQ29sb3IoYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB0aGlzLl9kYXJrTW9kZSA9IGlzRGFya01vZGUoYmFja2dyb3VuZENvbG9yKTtcbiAgICB9O1xuICAgIFpSZW5kZXIucHJvdG90eXBlLmdldEJhY2tncm91bmRDb2xvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvcjtcbiAgICB9O1xuICAgIFpSZW5kZXIucHJvdG90eXBlLnNldERhcmtNb2RlID0gZnVuY3Rpb24gKGRhcmtNb2RlKSB7XG4gICAgICAgIHRoaXMuX2RhcmtNb2RlID0gZGFya01vZGU7XG4gICAgfTtcbiAgICBaUmVuZGVyLnByb3RvdHlwZS5pc0RhcmtNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGFya01vZGU7XG4gICAgfTtcbiAgICBaUmVuZGVyLnByb3RvdHlwZS5yZWZyZXNoSW1tZWRpYXRlbHkgPSBmdW5jdGlvbiAoZnJvbUluc2lkZSkge1xuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZyb21JbnNpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLnVwZGF0ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYWludGVyLnJlZnJlc2goKTtcbiAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gZmFsc2U7XG4gICAgfTtcbiAgICBaUmVuZGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbi5zdGFydCgpO1xuICAgIH07XG4gICAgWlJlbmRlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZsdXNoKGZhbHNlKTtcbiAgICB9O1xuICAgIFpSZW5kZXIucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChmcm9tSW5zaWRlKSB7XG4gICAgICAgIHZhciB0cmlnZ2VyUmVuZGVyZWQ7XG4gICAgICAgIHZhciBzdGFydCA9IGdldFRpbWUoKTtcbiAgICAgICAgaWYgKHRoaXMuX25lZWRzUmVmcmVzaCkge1xuICAgICAgICAgICAgdHJpZ2dlclJlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEltbWVkaWF0ZWx5KGZyb21JbnNpZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2hIb3Zlcikge1xuICAgICAgICAgICAgdHJpZ2dlclJlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVySW1tZWRpYXRlbHkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kID0gZ2V0VGltZSgpO1xuICAgICAgICBpZiAodHJpZ2dlclJlbmRlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGlsbEZyYW1lQWNjdW0gPSAwO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdyZW5kZXJlZCcsIHtcbiAgICAgICAgICAgICAgICBlbGFwc2VkVGltZTogZW5kIC0gc3RhcnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3NsZWVwQWZ0ZXJTdGlsbCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3N0aWxsRnJhbWVBY2N1bSsrO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0aWxsRnJhbWVBY2N1bSA+IHRoaXMuX3NsZWVwQWZ0ZXJTdGlsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgWlJlbmRlci5wcm90b3R5cGUuc2V0U2xlZXBBZnRlclN0aWxsID0gZnVuY3Rpb24gKHN0aWxsRnJhbWVzQ291bnQpIHtcbiAgICAgICAgdGhpcy5fc2xlZXBBZnRlclN0aWxsID0gc3RpbGxGcmFtZXNDb3VudDtcbiAgICB9O1xuICAgIFpSZW5kZXIucHJvdG90eXBlLndha2VVcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltYXRpb24uc3RhcnQoKTtcbiAgICAgICAgdGhpcy5fc3RpbGxGcmFtZUFjY3VtID0gMDtcbiAgICB9O1xuICAgIFpSZW5kZXIucHJvdG90eXBlLnJlZnJlc2hIb3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIgPSB0cnVlO1xuICAgIH07XG4gICAgWlJlbmRlci5wcm90b3R5cGUucmVmcmVzaEhvdmVySW1tZWRpYXRlbHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyICYmIHRoaXMucGFpbnRlci5nZXRUeXBlKCkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFpSZW5kZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICB0aGlzLnBhaW50ZXIucmVzaXplKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVyLnJlc2l6ZSgpO1xuICAgIH07XG4gICAgWlJlbmRlci5wcm90b3R5cGUuY2xlYXJBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLmNsZWFyKCk7XG4gICAgfTtcbiAgICBaUmVuZGVyLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRXaWR0aCgpO1xuICAgIH07XG4gICAgWlJlbmRlci5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldEhlaWdodCgpO1xuICAgIH07XG4gICAgWlJlbmRlci5wcm90b3R5cGUuc2V0Q3Vyc29yU3R5bGUgPSBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVyLnNldEN1cnNvclN0eWxlKGN1cnNvclN0eWxlKTtcbiAgICB9O1xuICAgIFpSZW5kZXIucHJvdG90eXBlLmZpbmRIb3ZlciA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZmluZEhvdmVyKHgsIHkpO1xuICAgIH07XG4gICAgWlJlbmRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLm9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFpSZW5kZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZXIub2ZmKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgICB9O1xuICAgIFpSZW5kZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50KTtcbiAgICB9O1xuICAgIFpSZW5kZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm9vdHMgPSB0aGlzLnN0b3JhZ2UuZ2V0Um9vdHMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJvb3RzW2ldIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICByb290c1tpXS5yZW1vdmVTZWxmRnJvbVpyKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmFnZS5kZWxBbGxSb290cygpO1xuICAgICAgICB0aGlzLnBhaW50ZXIuY2xlYXIoKTtcbiAgICB9O1xuICAgIFpSZW5kZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLnN0b3JhZ2UuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnBhaW50ZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPVxuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlciA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgZGVsSW5zdGFuY2UodGhpcy5pZCk7XG4gICAgfTtcbiAgICByZXR1cm4gWlJlbmRlcjtcbn0oKSk7XG5leHBvcnQgZnVuY3Rpb24gaW5pdChkb20sIG9wdHMpIHtcbiAgICB2YXIgenIgPSBuZXcgWlJlbmRlcih6clV0aWwuZ3VpZCgpLCBkb20sIG9wdHMpO1xuICAgIGluc3RhbmNlc1t6ci5pZF0gPSB6cjtcbiAgICByZXR1cm4genI7XG59XG5leHBvcnQgZnVuY3Rpb24gZGlzcG9zZSh6cikge1xuICAgIHpyLmRpc3Bvc2UoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlQWxsKCkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBpbnN0YW5jZXNba2V5XS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2VzID0ge307XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5zdGFuY2UoaWQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2VzW2lkXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclBhaW50ZXIobmFtZSwgQ3Rvcikge1xuICAgIHBhaW50ZXJDdG9yc1tuYW1lXSA9IEN0b3I7XG59XG52YXIgc3NyRGF0YUdldHRlcjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50U1NSRGF0YShlbCkge1xuICAgIGlmICh0eXBlb2Ygc3NyRGF0YUdldHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gc3NyRGF0YUdldHRlcihlbCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyU1NSRGF0YUdldHRlcihnZXR0ZXIpIHtcbiAgICBzc3JEYXRhR2V0dGVyID0gZ2V0dGVyO1xufVxuZXhwb3J0IHZhciB2ZXJzaW9uID0gJzUuNi4xJztcbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///33572\n')},47698:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fastLerp: () => (/* binding */ fastLerp),\n/* harmony export */   fastMapToColor: () => (/* binding */ fastMapToColor),\n/* harmony export */   lerp: () => (/* binding */ lerp),\n/* harmony export */   lift: () => (/* binding */ lift),\n/* harmony export */   liftColor: () => (/* binding */ liftColor),\n/* harmony export */   lum: () => (/* binding */ lum),\n/* harmony export */   mapToColor: () => (/* binding */ mapToColor),\n/* harmony export */   modifyAlpha: () => (/* binding */ modifyAlpha),\n/* harmony export */   modifyHSL: () => (/* binding */ modifyHSL),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n/* harmony import */ var _core_LRU_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60501);\n/* harmony import */ var _core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n\n\nvar kCSSColorTable = {\n    'transparent': [0, 0, 0, 0], 'aliceblue': [240, 248, 255, 1],\n    'antiquewhite': [250, 235, 215, 1], 'aqua': [0, 255, 255, 1],\n    'aquamarine': [127, 255, 212, 1], 'azure': [240, 255, 255, 1],\n    'beige': [245, 245, 220, 1], 'bisque': [255, 228, 196, 1],\n    'black': [0, 0, 0, 1], 'blanchedalmond': [255, 235, 205, 1],\n    'blue': [0, 0, 255, 1], 'blueviolet': [138, 43, 226, 1],\n    'brown': [165, 42, 42, 1], 'burlywood': [222, 184, 135, 1],\n    'cadetblue': [95, 158, 160, 1], 'chartreuse': [127, 255, 0, 1],\n    'chocolate': [210, 105, 30, 1], 'coral': [255, 127, 80, 1],\n    'cornflowerblue': [100, 149, 237, 1], 'cornsilk': [255, 248, 220, 1],\n    'crimson': [220, 20, 60, 1], 'cyan': [0, 255, 255, 1],\n    'darkblue': [0, 0, 139, 1], 'darkcyan': [0, 139, 139, 1],\n    'darkgoldenrod': [184, 134, 11, 1], 'darkgray': [169, 169, 169, 1],\n    'darkgreen': [0, 100, 0, 1], 'darkgrey': [169, 169, 169, 1],\n    'darkkhaki': [189, 183, 107, 1], 'darkmagenta': [139, 0, 139, 1],\n    'darkolivegreen': [85, 107, 47, 1], 'darkorange': [255, 140, 0, 1],\n    'darkorchid': [153, 50, 204, 1], 'darkred': [139, 0, 0, 1],\n    'darksalmon': [233, 150, 122, 1], 'darkseagreen': [143, 188, 143, 1],\n    'darkslateblue': [72, 61, 139, 1], 'darkslategray': [47, 79, 79, 1],\n    'darkslategrey': [47, 79, 79, 1], 'darkturquoise': [0, 206, 209, 1],\n    'darkviolet': [148, 0, 211, 1], 'deeppink': [255, 20, 147, 1],\n    'deepskyblue': [0, 191, 255, 1], 'dimgray': [105, 105, 105, 1],\n    'dimgrey': [105, 105, 105, 1], 'dodgerblue': [30, 144, 255, 1],\n    'firebrick': [178, 34, 34, 1], 'floralwhite': [255, 250, 240, 1],\n    'forestgreen': [34, 139, 34, 1], 'fuchsia': [255, 0, 255, 1],\n    'gainsboro': [220, 220, 220, 1], 'ghostwhite': [248, 248, 255, 1],\n    'gold': [255, 215, 0, 1], 'goldenrod': [218, 165, 32, 1],\n    'gray': [128, 128, 128, 1], 'green': [0, 128, 0, 1],\n    'greenyellow': [173, 255, 47, 1], 'grey': [128, 128, 128, 1],\n    'honeydew': [240, 255, 240, 1], 'hotpink': [255, 105, 180, 1],\n    'indianred': [205, 92, 92, 1], 'indigo': [75, 0, 130, 1],\n    'ivory': [255, 255, 240, 1], 'khaki': [240, 230, 140, 1],\n    'lavender': [230, 230, 250, 1], 'lavenderblush': [255, 240, 245, 1],\n    'lawngreen': [124, 252, 0, 1], 'lemonchiffon': [255, 250, 205, 1],\n    'lightblue': [173, 216, 230, 1], 'lightcoral': [240, 128, 128, 1],\n    'lightcyan': [224, 255, 255, 1], 'lightgoldenrodyellow': [250, 250, 210, 1],\n    'lightgray': [211, 211, 211, 1], 'lightgreen': [144, 238, 144, 1],\n    'lightgrey': [211, 211, 211, 1], 'lightpink': [255, 182, 193, 1],\n    'lightsalmon': [255, 160, 122, 1], 'lightseagreen': [32, 178, 170, 1],\n    'lightskyblue': [135, 206, 250, 1], 'lightslategray': [119, 136, 153, 1],\n    'lightslategrey': [119, 136, 153, 1], 'lightsteelblue': [176, 196, 222, 1],\n    'lightyellow': [255, 255, 224, 1], 'lime': [0, 255, 0, 1],\n    'limegreen': [50, 205, 50, 1], 'linen': [250, 240, 230, 1],\n    'magenta': [255, 0, 255, 1], 'maroon': [128, 0, 0, 1],\n    'mediumaquamarine': [102, 205, 170, 1], 'mediumblue': [0, 0, 205, 1],\n    'mediumorchid': [186, 85, 211, 1], 'mediumpurple': [147, 112, 219, 1],\n    'mediumseagreen': [60, 179, 113, 1], 'mediumslateblue': [123, 104, 238, 1],\n    'mediumspringgreen': [0, 250, 154, 1], 'mediumturquoise': [72, 209, 204, 1],\n    'mediumvioletred': [199, 21, 133, 1], 'midnightblue': [25, 25, 112, 1],\n    'mintcream': [245, 255, 250, 1], 'mistyrose': [255, 228, 225, 1],\n    'moccasin': [255, 228, 181, 1], 'navajowhite': [255, 222, 173, 1],\n    'navy': [0, 0, 128, 1], 'oldlace': [253, 245, 230, 1],\n    'olive': [128, 128, 0, 1], 'olivedrab': [107, 142, 35, 1],\n    'orange': [255, 165, 0, 1], 'orangered': [255, 69, 0, 1],\n    'orchid': [218, 112, 214, 1], 'palegoldenrod': [238, 232, 170, 1],\n    'palegreen': [152, 251, 152, 1], 'paleturquoise': [175, 238, 238, 1],\n    'palevioletred': [219, 112, 147, 1], 'papayawhip': [255, 239, 213, 1],\n    'peachpuff': [255, 218, 185, 1], 'peru': [205, 133, 63, 1],\n    'pink': [255, 192, 203, 1], 'plum': [221, 160, 221, 1],\n    'powderblue': [176, 224, 230, 1], 'purple': [128, 0, 128, 1],\n    'red': [255, 0, 0, 1], 'rosybrown': [188, 143, 143, 1],\n    'royalblue': [65, 105, 225, 1], 'saddlebrown': [139, 69, 19, 1],\n    'salmon': [250, 128, 114, 1], 'sandybrown': [244, 164, 96, 1],\n    'seagreen': [46, 139, 87, 1], 'seashell': [255, 245, 238, 1],\n    'sienna': [160, 82, 45, 1], 'silver': [192, 192, 192, 1],\n    'skyblue': [135, 206, 235, 1], 'slateblue': [106, 90, 205, 1],\n    'slategray': [112, 128, 144, 1], 'slategrey': [112, 128, 144, 1],\n    'snow': [255, 250, 250, 1], 'springgreen': [0, 255, 127, 1],\n    'steelblue': [70, 130, 180, 1], 'tan': [210, 180, 140, 1],\n    'teal': [0, 128, 128, 1], 'thistle': [216, 191, 216, 1],\n    'tomato': [255, 99, 71, 1], 'turquoise': [64, 224, 208, 1],\n    'violet': [238, 130, 238, 1], 'wheat': [245, 222, 179, 1],\n    'white': [255, 255, 255, 1], 'whitesmoke': [245, 245, 245, 1],\n    'yellow': [255, 255, 0, 1], 'yellowgreen': [154, 205, 50, 1]\n};\nfunction clampCssByte(i) {\n    i = Math.round(i);\n    return i < 0 ? 0 : i > 255 ? 255 : i;\n}\nfunction clampCssAngle(i) {\n    i = Math.round(i);\n    return i < 0 ? 0 : i > 360 ? 360 : i;\n}\nfunction clampCssFloat(f) {\n    return f < 0 ? 0 : f > 1 ? 1 : f;\n}\nfunction parseCssInt(val) {\n    var str = val;\n    if (str.length && str.charAt(str.length - 1) === '%') {\n        return clampCssByte(parseFloat(str) / 100 * 255);\n    }\n    return clampCssByte(parseInt(str, 10));\n}\nfunction parseCssFloat(val) {\n    var str = val;\n    if (str.length && str.charAt(str.length - 1) === '%') {\n        return clampCssFloat(parseFloat(str) / 100);\n    }\n    return clampCssFloat(parseFloat(str));\n}\nfunction cssHueToRgb(m1, m2, h) {\n    if (h < 0) {\n        h += 1;\n    }\n    else if (h > 1) {\n        h -= 1;\n    }\n    if (h * 6 < 1) {\n        return m1 + (m2 - m1) * h * 6;\n    }\n    if (h * 2 < 1) {\n        return m2;\n    }\n    if (h * 3 < 2) {\n        return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n    }\n    return m1;\n}\nfunction lerpNumber(a, b, p) {\n    return a + (b - a) * p;\n}\nfunction setRgba(out, r, g, b, a) {\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    out[3] = a;\n    return out;\n}\nfunction copyRgba(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n}\nvar colorCache = new _core_LRU_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Ay(20);\nvar lastRemovedArr = null;\nfunction putToCache(colorStr, rgbaArr) {\n    if (lastRemovedArr) {\n        copyRgba(lastRemovedArr, rgbaArr);\n    }\n    lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n}\nfunction parse(colorStr, rgbaArr) {\n    if (!colorStr) {\n        return;\n    }\n    rgbaArr = rgbaArr || [];\n    var cached = colorCache.get(colorStr);\n    if (cached) {\n        return copyRgba(rgbaArr, cached);\n    }\n    colorStr = colorStr + '';\n    var str = colorStr.replace(/ /g, '').toLowerCase();\n    if (str in kCSSColorTable) {\n        copyRgba(rgbaArr, kCSSColorTable[str]);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n    }\n    var strLen = str.length;\n    if (str.charAt(0) === '#') {\n        if (strLen === 4 || strLen === 5) {\n            var iv = parseInt(str.slice(1, 4), 16);\n            if (!(iv >= 0 && iv <= 0xfff)) {\n                setRgba(rgbaArr, 0, 0, 0, 1);\n                return;\n            }\n            setRgba(rgbaArr, ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8), (iv & 0xf0) | ((iv & 0xf0) >> 4), (iv & 0xf) | ((iv & 0xf) << 4), strLen === 5 ? parseInt(str.slice(4), 16) / 0xf : 1);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n        else if (strLen === 7 || strLen === 9) {\n            var iv = parseInt(str.slice(1, 7), 16);\n            if (!(iv >= 0 && iv <= 0xffffff)) {\n                setRgba(rgbaArr, 0, 0, 0, 1);\n                return;\n            }\n            setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, strLen === 9 ? parseInt(str.slice(7), 16) / 0xff : 1);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n        return;\n    }\n    var op = str.indexOf('(');\n    var ep = str.indexOf(')');\n    if (op !== -1 && ep + 1 === strLen) {\n        var fname = str.substr(0, op);\n        var params = str.substr(op + 1, ep - (op + 1)).split(',');\n        var alpha = 1;\n        switch (fname) {\n            case 'rgba':\n                if (params.length !== 4) {\n                    return params.length === 3\n                        ? setRgba(rgbaArr, +params[0], +params[1], +params[2], 1)\n                        : setRgba(rgbaArr, 0, 0, 0, 1);\n                }\n                alpha = parseCssFloat(params.pop());\n            case 'rgb':\n                if (params.length >= 3) {\n                    setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), params.length === 3 ? alpha : parseCssFloat(params[3]));\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                }\n                else {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;\n                }\n            case 'hsla':\n                if (params.length !== 4) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;\n                }\n                params[3] = parseCssFloat(params[3]);\n                hsla2rgba(params, rgbaArr);\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            case 'hsl':\n                if (params.length !== 3) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;\n                }\n                hsla2rgba(params, rgbaArr);\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            default:\n                return;\n        }\n    }\n    setRgba(rgbaArr, 0, 0, 0, 1);\n    return;\n}\nfunction hsla2rgba(hsla, rgba) {\n    var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;\n    var s = parseCssFloat(hsla[1]);\n    var l = parseCssFloat(hsla[2]);\n    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n    var m1 = l * 2 - m2;\n    rgba = rgba || [];\n    setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n    if (hsla.length === 4) {\n        rgba[3] = hsla[3];\n    }\n    return rgba;\n}\nfunction rgba2hsla(rgba) {\n    if (!rgba) {\n        return;\n    }\n    var R = rgba[0] / 255;\n    var G = rgba[1] / 255;\n    var B = rgba[2] / 255;\n    var vMin = Math.min(R, G, B);\n    var vMax = Math.max(R, G, B);\n    var delta = vMax - vMin;\n    var L = (vMax + vMin) / 2;\n    var H;\n    var S;\n    if (delta === 0) {\n        H = 0;\n        S = 0;\n    }\n    else {\n        if (L < 0.5) {\n            S = delta / (vMax + vMin);\n        }\n        else {\n            S = delta / (2 - vMax - vMin);\n        }\n        var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n        var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n        var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n        if (R === vMax) {\n            H = deltaB - deltaG;\n        }\n        else if (G === vMax) {\n            H = (1 / 3) + deltaR - deltaB;\n        }\n        else if (B === vMax) {\n            H = (2 / 3) + deltaG - deltaR;\n        }\n        if (H < 0) {\n            H += 1;\n        }\n        if (H > 1) {\n            H -= 1;\n        }\n    }\n    var hsla = [H * 360, S, L];\n    if (rgba[3] != null) {\n        hsla.push(rgba[3]);\n    }\n    return hsla;\n}\nfunction lift(color, level) {\n    var colorArr = parse(color);\n    if (colorArr) {\n        for (var i = 0; i < 3; i++) {\n            if (level < 0) {\n                colorArr[i] = colorArr[i] * (1 - level) | 0;\n            }\n            else {\n                colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n            }\n            if (colorArr[i] > 255) {\n                colorArr[i] = 255;\n            }\n            else if (colorArr[i] < 0) {\n                colorArr[i] = 0;\n            }\n        }\n        return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n    }\n}\nfunction toHex(color) {\n    var colorArr = parse(color);\n    if (colorArr) {\n        return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n    }\n}\nfunction fastLerp(normalizedValue, colors, out) {\n    if (!(colors && colors.length)\n        || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n        return;\n    }\n    out = out || [];\n    var value = normalizedValue * (colors.length - 1);\n    var leftIndex = Math.floor(value);\n    var rightIndex = Math.ceil(value);\n    var leftColor = colors[leftIndex];\n    var rightColor = colors[rightIndex];\n    var dv = value - leftIndex;\n    out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n    out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n    out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n    out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n    return out;\n}\nvar fastMapToColor = fastLerp;\nfunction lerp(normalizedValue, colors, fullOutput) {\n    if (!(colors && colors.length)\n        || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n        return;\n    }\n    var value = normalizedValue * (colors.length - 1);\n    var leftIndex = Math.floor(value);\n    var rightIndex = Math.ceil(value);\n    var leftColor = parse(colors[leftIndex]);\n    var rightColor = parse(colors[rightIndex]);\n    var dv = value - leftIndex;\n    var color = stringify([\n        clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),\n        clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),\n        clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),\n        clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))\n    ], 'rgba');\n    return fullOutput\n        ? {\n            color: color,\n            leftIndex: leftIndex,\n            rightIndex: rightIndex,\n            value: value\n        }\n        : color;\n}\nvar mapToColor = lerp;\nfunction modifyHSL(color, h, s, l) {\n    var colorArr = parse(color);\n    if (color) {\n        colorArr = rgba2hsla(colorArr);\n        h != null && (colorArr[0] = clampCssAngle(h));\n        s != null && (colorArr[1] = parseCssFloat(s));\n        l != null && (colorArr[2] = parseCssFloat(l));\n        return stringify(hsla2rgba(colorArr), 'rgba');\n    }\n}\nfunction modifyAlpha(color, alpha) {\n    var colorArr = parse(color);\n    if (colorArr && alpha != null) {\n        colorArr[3] = clampCssFloat(alpha);\n        return stringify(colorArr, 'rgba');\n    }\n}\nfunction stringify(arrColor, type) {\n    if (!arrColor || !arrColor.length) {\n        return;\n    }\n    var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n    if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n        colorStr += ',' + arrColor[3];\n    }\n    return type + '(' + colorStr + ')';\n}\nfunction lum(color, backgroundLum) {\n    var arr = parse(color);\n    return arr\n        ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255\n            + (1 - arr[3]) * backgroundLum\n        : 0;\n}\nfunction random() {\n    return stringify([\n        Math.round(Math.random() * 255),\n        Math.round(Math.random() * 255),\n        Math.round(Math.random() * 255)\n    ], 'rgb');\n}\nvar liftedColorCache = new _core_LRU_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Ay(100);\nfunction liftColor(color) {\n    if ((0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString)(color)) {\n        var liftedColor = liftedColorCache.get(color);\n        if (!liftedColor) {\n            liftedColor = lift(color, -0.1);\n            liftedColorCache.put(color, liftedColor);\n        }\n        return liftedColor;\n    }\n    else if ((0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isGradientObject)(color)) {\n        var ret = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, color);\n        ret.colorStops = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map)(color.colorStops, function (stop) { return ({\n            offset: stop.offset,\n            color: lift(stop.color, -0.1)\n        }); });\n        return ret;\n    }\n    return color;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc2OTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvY29sb3IuanM/MTI2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTFJVIGZyb20gJy4uL2NvcmUvTFJVLmpzJztcbmltcG9ydCB7IGV4dGVuZCwgaXNHcmFkaWVudE9iamVjdCwgaXNTdHJpbmcsIG1hcCB9IGZyb20gJy4uL2NvcmUvdXRpbC5qcyc7XG52YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gICAgJ3RyYW5zcGFyZW50JzogWzAsIDAsIDAsIDBdLCAnYWxpY2VibHVlJzogWzI0MCwgMjQ4LCAyNTUsIDFdLFxuICAgICdhbnRpcXVld2hpdGUnOiBbMjUwLCAyMzUsIDIxNSwgMV0sICdhcXVhJzogWzAsIDI1NSwgMjU1LCAxXSxcbiAgICAnYXF1YW1hcmluZSc6IFsxMjcsIDI1NSwgMjEyLCAxXSwgJ2F6dXJlJzogWzI0MCwgMjU1LCAyNTUsIDFdLFxuICAgICdiZWlnZSc6IFsyNDUsIDI0NSwgMjIwLCAxXSwgJ2Jpc3F1ZSc6IFsyNTUsIDIyOCwgMTk2LCAxXSxcbiAgICAnYmxhY2snOiBbMCwgMCwgMCwgMV0sICdibGFuY2hlZGFsbW9uZCc6IFsyNTUsIDIzNSwgMjA1LCAxXSxcbiAgICAnYmx1ZSc6IFswLCAwLCAyNTUsIDFdLCAnYmx1ZXZpb2xldCc6IFsxMzgsIDQzLCAyMjYsIDFdLFxuICAgICdicm93bic6IFsxNjUsIDQyLCA0MiwgMV0sICdidXJseXdvb2QnOiBbMjIyLCAxODQsIDEzNSwgMV0sXG4gICAgJ2NhZGV0Ymx1ZSc6IFs5NSwgMTU4LCAxNjAsIDFdLCAnY2hhcnRyZXVzZSc6IFsxMjcsIDI1NSwgMCwgMV0sXG4gICAgJ2Nob2NvbGF0ZSc6IFsyMTAsIDEwNSwgMzAsIDFdLCAnY29yYWwnOiBbMjU1LCAxMjcsIDgwLCAxXSxcbiAgICAnY29ybmZsb3dlcmJsdWUnOiBbMTAwLCAxNDksIDIzNywgMV0sICdjb3Juc2lsayc6IFsyNTUsIDI0OCwgMjIwLCAxXSxcbiAgICAnY3JpbXNvbic6IFsyMjAsIDIwLCA2MCwgMV0sICdjeWFuJzogWzAsIDI1NSwgMjU1LCAxXSxcbiAgICAnZGFya2JsdWUnOiBbMCwgMCwgMTM5LCAxXSwgJ2RhcmtjeWFuJzogWzAsIDEzOSwgMTM5LCAxXSxcbiAgICAnZGFya2dvbGRlbnJvZCc6IFsxODQsIDEzNCwgMTEsIDFdLCAnZGFya2dyYXknOiBbMTY5LCAxNjksIDE2OSwgMV0sXG4gICAgJ2RhcmtncmVlbic6IFswLCAxMDAsIDAsIDFdLCAnZGFya2dyZXknOiBbMTY5LCAxNjksIDE2OSwgMV0sXG4gICAgJ2RhcmtraGFraSc6IFsxODksIDE4MywgMTA3LCAxXSwgJ2RhcmttYWdlbnRhJzogWzEzOSwgMCwgMTM5LCAxXSxcbiAgICAnZGFya29saXZlZ3JlZW4nOiBbODUsIDEwNywgNDcsIDFdLCAnZGFya29yYW5nZSc6IFsyNTUsIDE0MCwgMCwgMV0sXG4gICAgJ2RhcmtvcmNoaWQnOiBbMTUzLCA1MCwgMjA0LCAxXSwgJ2RhcmtyZWQnOiBbMTM5LCAwLCAwLCAxXSxcbiAgICAnZGFya3NhbG1vbic6IFsyMzMsIDE1MCwgMTIyLCAxXSwgJ2RhcmtzZWFncmVlbic6IFsxNDMsIDE4OCwgMTQzLCAxXSxcbiAgICAnZGFya3NsYXRlYmx1ZSc6IFs3MiwgNjEsIDEzOSwgMV0sICdkYXJrc2xhdGVncmF5JzogWzQ3LCA3OSwgNzksIDFdLFxuICAgICdkYXJrc2xhdGVncmV5JzogWzQ3LCA3OSwgNzksIDFdLCAnZGFya3R1cnF1b2lzZSc6IFswLCAyMDYsIDIwOSwgMV0sXG4gICAgJ2Rhcmt2aW9sZXQnOiBbMTQ4LCAwLCAyMTEsIDFdLCAnZGVlcHBpbmsnOiBbMjU1LCAyMCwgMTQ3LCAxXSxcbiAgICAnZGVlcHNreWJsdWUnOiBbMCwgMTkxLCAyNTUsIDFdLCAnZGltZ3JheSc6IFsxMDUsIDEwNSwgMTA1LCAxXSxcbiAgICAnZGltZ3JleSc6IFsxMDUsIDEwNSwgMTA1LCAxXSwgJ2RvZGdlcmJsdWUnOiBbMzAsIDE0NCwgMjU1LCAxXSxcbiAgICAnZmlyZWJyaWNrJzogWzE3OCwgMzQsIDM0LCAxXSwgJ2Zsb3JhbHdoaXRlJzogWzI1NSwgMjUwLCAyNDAsIDFdLFxuICAgICdmb3Jlc3RncmVlbic6IFszNCwgMTM5LCAzNCwgMV0sICdmdWNoc2lhJzogWzI1NSwgMCwgMjU1LCAxXSxcbiAgICAnZ2FpbnNib3JvJzogWzIyMCwgMjIwLCAyMjAsIDFdLCAnZ2hvc3R3aGl0ZSc6IFsyNDgsIDI0OCwgMjU1LCAxXSxcbiAgICAnZ29sZCc6IFsyNTUsIDIxNSwgMCwgMV0sICdnb2xkZW5yb2QnOiBbMjE4LCAxNjUsIDMyLCAxXSxcbiAgICAnZ3JheSc6IFsxMjgsIDEyOCwgMTI4LCAxXSwgJ2dyZWVuJzogWzAsIDEyOCwgMCwgMV0sXG4gICAgJ2dyZWVueWVsbG93JzogWzE3MywgMjU1LCA0NywgMV0sICdncmV5JzogWzEyOCwgMTI4LCAxMjgsIDFdLFxuICAgICdob25leWRldyc6IFsyNDAsIDI1NSwgMjQwLCAxXSwgJ2hvdHBpbmsnOiBbMjU1LCAxMDUsIDE4MCwgMV0sXG4gICAgJ2luZGlhbnJlZCc6IFsyMDUsIDkyLCA5MiwgMV0sICdpbmRpZ28nOiBbNzUsIDAsIDEzMCwgMV0sXG4gICAgJ2l2b3J5JzogWzI1NSwgMjU1LCAyNDAsIDFdLCAna2hha2knOiBbMjQwLCAyMzAsIDE0MCwgMV0sXG4gICAgJ2xhdmVuZGVyJzogWzIzMCwgMjMwLCAyNTAsIDFdLCAnbGF2ZW5kZXJibHVzaCc6IFsyNTUsIDI0MCwgMjQ1LCAxXSxcbiAgICAnbGF3bmdyZWVuJzogWzEyNCwgMjUyLCAwLCAxXSwgJ2xlbW9uY2hpZmZvbic6IFsyNTUsIDI1MCwgMjA1LCAxXSxcbiAgICAnbGlnaHRibHVlJzogWzE3MywgMjE2LCAyMzAsIDFdLCAnbGlnaHRjb3JhbCc6IFsyNDAsIDEyOCwgMTI4LCAxXSxcbiAgICAnbGlnaHRjeWFuJzogWzIyNCwgMjU1LCAyNTUsIDFdLCAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiBbMjUwLCAyNTAsIDIxMCwgMV0sXG4gICAgJ2xpZ2h0Z3JheSc6IFsyMTEsIDIxMSwgMjExLCAxXSwgJ2xpZ2h0Z3JlZW4nOiBbMTQ0LCAyMzgsIDE0NCwgMV0sXG4gICAgJ2xpZ2h0Z3JleSc6IFsyMTEsIDIxMSwgMjExLCAxXSwgJ2xpZ2h0cGluayc6IFsyNTUsIDE4MiwgMTkzLCAxXSxcbiAgICAnbGlnaHRzYWxtb24nOiBbMjU1LCAxNjAsIDEyMiwgMV0sICdsaWdodHNlYWdyZWVuJzogWzMyLCAxNzgsIDE3MCwgMV0sXG4gICAgJ2xpZ2h0c2t5Ymx1ZSc6IFsxMzUsIDIwNiwgMjUwLCAxXSwgJ2xpZ2h0c2xhdGVncmF5JzogWzExOSwgMTM2LCAxNTMsIDFdLFxuICAgICdsaWdodHNsYXRlZ3JleSc6IFsxMTksIDEzNiwgMTUzLCAxXSwgJ2xpZ2h0c3RlZWxibHVlJzogWzE3NiwgMTk2LCAyMjIsIDFdLFxuICAgICdsaWdodHllbGxvdyc6IFsyNTUsIDI1NSwgMjI0LCAxXSwgJ2xpbWUnOiBbMCwgMjU1LCAwLCAxXSxcbiAgICAnbGltZWdyZWVuJzogWzUwLCAyMDUsIDUwLCAxXSwgJ2xpbmVuJzogWzI1MCwgMjQwLCAyMzAsIDFdLFxuICAgICdtYWdlbnRhJzogWzI1NSwgMCwgMjU1LCAxXSwgJ21hcm9vbic6IFsxMjgsIDAsIDAsIDFdLFxuICAgICdtZWRpdW1hcXVhbWFyaW5lJzogWzEwMiwgMjA1LCAxNzAsIDFdLCAnbWVkaXVtYmx1ZSc6IFswLCAwLCAyMDUsIDFdLFxuICAgICdtZWRpdW1vcmNoaWQnOiBbMTg2LCA4NSwgMjExLCAxXSwgJ21lZGl1bXB1cnBsZSc6IFsxNDcsIDExMiwgMjE5LCAxXSxcbiAgICAnbWVkaXVtc2VhZ3JlZW4nOiBbNjAsIDE3OSwgMTEzLCAxXSwgJ21lZGl1bXNsYXRlYmx1ZSc6IFsxMjMsIDEwNCwgMjM4LCAxXSxcbiAgICAnbWVkaXVtc3ByaW5nZ3JlZW4nOiBbMCwgMjUwLCAxNTQsIDFdLCAnbWVkaXVtdHVycXVvaXNlJzogWzcyLCAyMDksIDIwNCwgMV0sXG4gICAgJ21lZGl1bXZpb2xldHJlZCc6IFsxOTksIDIxLCAxMzMsIDFdLCAnbWlkbmlnaHRibHVlJzogWzI1LCAyNSwgMTEyLCAxXSxcbiAgICAnbWludGNyZWFtJzogWzI0NSwgMjU1LCAyNTAsIDFdLCAnbWlzdHlyb3NlJzogWzI1NSwgMjI4LCAyMjUsIDFdLFxuICAgICdtb2NjYXNpbic6IFsyNTUsIDIyOCwgMTgxLCAxXSwgJ25hdmFqb3doaXRlJzogWzI1NSwgMjIyLCAxNzMsIDFdLFxuICAgICduYXZ5JzogWzAsIDAsIDEyOCwgMV0sICdvbGRsYWNlJzogWzI1MywgMjQ1LCAyMzAsIDFdLFxuICAgICdvbGl2ZSc6IFsxMjgsIDEyOCwgMCwgMV0sICdvbGl2ZWRyYWInOiBbMTA3LCAxNDIsIDM1LCAxXSxcbiAgICAnb3JhbmdlJzogWzI1NSwgMTY1LCAwLCAxXSwgJ29yYW5nZXJlZCc6IFsyNTUsIDY5LCAwLCAxXSxcbiAgICAnb3JjaGlkJzogWzIxOCwgMTEyLCAyMTQsIDFdLCAncGFsZWdvbGRlbnJvZCc6IFsyMzgsIDIzMiwgMTcwLCAxXSxcbiAgICAncGFsZWdyZWVuJzogWzE1MiwgMjUxLCAxNTIsIDFdLCAncGFsZXR1cnF1b2lzZSc6IFsxNzUsIDIzOCwgMjM4LCAxXSxcbiAgICAncGFsZXZpb2xldHJlZCc6IFsyMTksIDExMiwgMTQ3LCAxXSwgJ3BhcGF5YXdoaXAnOiBbMjU1LCAyMzksIDIxMywgMV0sXG4gICAgJ3BlYWNocHVmZic6IFsyNTUsIDIxOCwgMTg1LCAxXSwgJ3BlcnUnOiBbMjA1LCAxMzMsIDYzLCAxXSxcbiAgICAncGluayc6IFsyNTUsIDE5MiwgMjAzLCAxXSwgJ3BsdW0nOiBbMjIxLCAxNjAsIDIyMSwgMV0sXG4gICAgJ3Bvd2RlcmJsdWUnOiBbMTc2LCAyMjQsIDIzMCwgMV0sICdwdXJwbGUnOiBbMTI4LCAwLCAxMjgsIDFdLFxuICAgICdyZWQnOiBbMjU1LCAwLCAwLCAxXSwgJ3Jvc3licm93bic6IFsxODgsIDE0MywgMTQzLCAxXSxcbiAgICAncm95YWxibHVlJzogWzY1LCAxMDUsIDIyNSwgMV0sICdzYWRkbGVicm93bic6IFsxMzksIDY5LCAxOSwgMV0sXG4gICAgJ3NhbG1vbic6IFsyNTAsIDEyOCwgMTE0LCAxXSwgJ3NhbmR5YnJvd24nOiBbMjQ0LCAxNjQsIDk2LCAxXSxcbiAgICAnc2VhZ3JlZW4nOiBbNDYsIDEzOSwgODcsIDFdLCAnc2Vhc2hlbGwnOiBbMjU1LCAyNDUsIDIzOCwgMV0sXG4gICAgJ3NpZW5uYSc6IFsxNjAsIDgyLCA0NSwgMV0sICdzaWx2ZXInOiBbMTkyLCAxOTIsIDE5MiwgMV0sXG4gICAgJ3NreWJsdWUnOiBbMTM1LCAyMDYsIDIzNSwgMV0sICdzbGF0ZWJsdWUnOiBbMTA2LCA5MCwgMjA1LCAxXSxcbiAgICAnc2xhdGVncmF5JzogWzExMiwgMTI4LCAxNDQsIDFdLCAnc2xhdGVncmV5JzogWzExMiwgMTI4LCAxNDQsIDFdLFxuICAgICdzbm93JzogWzI1NSwgMjUwLCAyNTAsIDFdLCAnc3ByaW5nZ3JlZW4nOiBbMCwgMjU1LCAxMjcsIDFdLFxuICAgICdzdGVlbGJsdWUnOiBbNzAsIDEzMCwgMTgwLCAxXSwgJ3Rhbic6IFsyMTAsIDE4MCwgMTQwLCAxXSxcbiAgICAndGVhbCc6IFswLCAxMjgsIDEyOCwgMV0sICd0aGlzdGxlJzogWzIxNiwgMTkxLCAyMTYsIDFdLFxuICAgICd0b21hdG8nOiBbMjU1LCA5OSwgNzEsIDFdLCAndHVycXVvaXNlJzogWzY0LCAyMjQsIDIwOCwgMV0sXG4gICAgJ3Zpb2xldCc6IFsyMzgsIDEzMCwgMjM4LCAxXSwgJ3doZWF0JzogWzI0NSwgMjIyLCAxNzksIDFdLFxuICAgICd3aGl0ZSc6IFsyNTUsIDI1NSwgMjU1LCAxXSwgJ3doaXRlc21va2UnOiBbMjQ1LCAyNDUsIDI0NSwgMV0sXG4gICAgJ3llbGxvdyc6IFsyNTUsIDI1NSwgMCwgMV0sICd5ZWxsb3dncmVlbic6IFsxNTQsIDIwNSwgNTAsIDFdXG59O1xuZnVuY3Rpb24gY2xhbXBDc3NCeXRlKGkpIHtcbiAgICBpID0gTWF0aC5yb3VuZChpKTtcbiAgICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG59XG5mdW5jdGlvbiBjbGFtcENzc0FuZ2xlKGkpIHtcbiAgICBpID0gTWF0aC5yb3VuZChpKTtcbiAgICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDM2MCA/IDM2MCA6IGk7XG59XG5mdW5jdGlvbiBjbGFtcENzc0Zsb2F0KGYpIHtcbiAgICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbn1cbmZ1bmN0aW9uIHBhcnNlQ3NzSW50KHZhbCkge1xuICAgIHZhciBzdHIgPSB2YWw7XG4gICAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XG4gICAgfVxuICAgIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VJbnQoc3RyLCAxMCkpO1xufVxuZnVuY3Rpb24gcGFyc2VDc3NGbG9hdCh2YWwpIHtcbiAgICB2YXIgc3RyID0gdmFsO1xuICAgIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbn1cbmZ1bmN0aW9uIGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkge1xuICAgIGlmIChoIDwgMCkge1xuICAgICAgICBoICs9IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGggPiAxKSB7XG4gICAgICAgIGggLT0gMTtcbiAgICB9XG4gICAgaWYgKGggKiA2IDwgMSkge1xuICAgICAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgICB9XG4gICAgaWYgKGggKiAyIDwgMSkge1xuICAgICAgICByZXR1cm4gbTI7XG4gICAgfVxuICAgIGlmIChoICogMyA8IDIpIHtcbiAgICAgICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2O1xuICAgIH1cbiAgICByZXR1cm4gbTE7XG59XG5mdW5jdGlvbiBsZXJwTnVtYmVyKGEsIGIsIHApIHtcbiAgICByZXR1cm4gYSArIChiIC0gYSkgKiBwO1xufVxuZnVuY3Rpb24gc2V0UmdiYShvdXQsIHIsIGcsIGIsIGEpIHtcbiAgICBvdXRbMF0gPSByO1xuICAgIG91dFsxXSA9IGc7XG4gICAgb3V0WzJdID0gYjtcbiAgICBvdXRbM10gPSBhO1xuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBjb3B5UmdiYShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59XG52YXIgY29sb3JDYWNoZSA9IG5ldyBMUlUoMjApO1xudmFyIGxhc3RSZW1vdmVkQXJyID0gbnVsbDtcbmZ1bmN0aW9uIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpIHtcbiAgICBpZiAobGFzdFJlbW92ZWRBcnIpIHtcbiAgICAgICAgY29weVJnYmEobGFzdFJlbW92ZWRBcnIsIHJnYmFBcnIpO1xuICAgIH1cbiAgICBsYXN0UmVtb3ZlZEFyciA9IGNvbG9yQ2FjaGUucHV0KGNvbG9yU3RyLCBsYXN0UmVtb3ZlZEFyciB8fCAocmdiYUFyci5zbGljZSgpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2UoY29sb3JTdHIsIHJnYmFBcnIpIHtcbiAgICBpZiAoIWNvbG9yU3RyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmdiYUFyciA9IHJnYmFBcnIgfHwgW107XG4gICAgdmFyIGNhY2hlZCA9IGNvbG9yQ2FjaGUuZ2V0KGNvbG9yU3RyKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHJldHVybiBjb3B5UmdiYShyZ2JhQXJyLCBjYWNoZWQpO1xuICAgIH1cbiAgICBjb2xvclN0ciA9IGNvbG9yU3RyICsgJyc7XG4gICAgdmFyIHN0ciA9IGNvbG9yU3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkge1xuICAgICAgICBjb3B5UmdiYShyZ2JhQXJyLCBrQ1NTQ29sb3JUYWJsZVtzdHJdKTtcbiAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuID0gc3RyLmxlbmd0aDtcbiAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgIGlmIChzdHJMZW4gPT09IDQgfHwgc3RyTGVuID09PSA1KSB7XG4gICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc2xpY2UoMSwgNCksIDE2KTtcbiAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSB7XG4gICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsICgoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLCAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSwgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLCBzdHJMZW4gPT09IDUgPyBwYXJzZUludChzdHIuc2xpY2UoNCksIDE2KSAvIDB4ZiA6IDEpO1xuICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICByZXR1cm4gcmdiYUFycjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHJMZW4gPT09IDcgfHwgc3RyTGVuID09PSA5KSB7XG4gICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc2xpY2UoMSwgNyksIDE2KTtcbiAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSB7XG4gICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIChpdiAmIDB4ZmYwMDAwKSA+PiAxNiwgKGl2ICYgMHhmZjAwKSA+PiA4LCBpdiAmIDB4ZmYsIHN0ckxlbiA9PT0gOSA/IHBhcnNlSW50KHN0ci5zbGljZSg3KSwgMTYpIC8gMHhmZiA6IDEpO1xuICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICByZXR1cm4gcmdiYUFycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBvcCA9IHN0ci5pbmRleE9mKCcoJyk7XG4gICAgdmFyIGVwID0gc3RyLmluZGV4T2YoJyknKTtcbiAgICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyTGVuKSB7XG4gICAgICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgICAgICB2YXIgcGFyYW1zID0gc3RyLnN1YnN0cihvcCArIDEsIGVwIC0gKG9wICsgMSkpLnNwbGl0KCcsJyk7XG4gICAgICAgIHZhciBhbHBoYSA9IDE7XG4gICAgICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXMubGVuZ3RoID09PSAzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNldFJnYmEocmdiYUFyciwgK3BhcmFtc1swXSwgK3BhcmFtc1sxXSwgK3BhcmFtc1syXSwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWxwaGEgPSBwYXJzZUNzc0Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgICAgICBjYXNlICdyZ2InOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCBwYXJzZUNzc0ludChwYXJhbXNbMF0pLCBwYXJzZUNzc0ludChwYXJhbXNbMV0pLCBwYXJzZUNzc0ludChwYXJhbXNbMl0pLCBwYXJhbXMubGVuZ3RoID09PSAzID8gYWxwaGEgOiBwYXJzZUNzc0Zsb2F0KHBhcmFtc1szXSkpO1xuICAgICAgICAgICAgICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXNbM10gPSBwYXJzZUNzc0Zsb2F0KHBhcmFtc1szXSk7XG4gICAgICAgICAgICAgICAgaHNsYTJyZ2JhKHBhcmFtcywgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgICAgICBjYXNlICdoc2wnOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHNsYTJyZ2JhKHBhcmFtcywgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIGhzbGEycmdiYShoc2xhLCByZ2JhKSB7XG4gICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KGhzbGFbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwO1xuICAgIHZhciBzID0gcGFyc2VDc3NGbG9hdChoc2xhWzFdKTtcbiAgICB2YXIgbCA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsyXSk7XG4gICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgICByZ2JhID0gcmdiYSB8fCBbXTtcbiAgICBzZXRSZ2JhKHJnYmEsIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGggKyAxIC8gMykgKiAyNTUpLCBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoKSAqIDI1NSksIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGggLSAxIC8gMykgKiAyNTUpLCAxKTtcbiAgICBpZiAoaHNsYS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgcmdiYVszXSA9IGhzbGFbM107XG4gICAgfVxuICAgIHJldHVybiByZ2JhO1xufVxuZnVuY3Rpb24gcmdiYTJoc2xhKHJnYmEpIHtcbiAgICBpZiAoIXJnYmEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgUiA9IHJnYmFbMF0gLyAyNTU7XG4gICAgdmFyIEcgPSByZ2JhWzFdIC8gMjU1O1xuICAgIHZhciBCID0gcmdiYVsyXSAvIDI1NTtcbiAgICB2YXIgdk1pbiA9IE1hdGgubWluKFIsIEcsIEIpO1xuICAgIHZhciB2TWF4ID0gTWF0aC5tYXgoUiwgRywgQik7XG4gICAgdmFyIGRlbHRhID0gdk1heCAtIHZNaW47XG4gICAgdmFyIEwgPSAodk1heCArIHZNaW4pIC8gMjtcbiAgICB2YXIgSDtcbiAgICB2YXIgUztcbiAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgSCA9IDA7XG4gICAgICAgIFMgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKEwgPCAwLjUpIHtcbiAgICAgICAgICAgIFMgPSBkZWx0YSAvICh2TWF4ICsgdk1pbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBTID0gZGVsdGEgLyAoMiAtIHZNYXggLSB2TWluKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsdGFSID0gKCgodk1heCAtIFIpIC8gNikgKyAoZGVsdGEgLyAyKSkgLyBkZWx0YTtcbiAgICAgICAgdmFyIGRlbHRhRyA9ICgoKHZNYXggLSBHKSAvIDYpICsgKGRlbHRhIC8gMikpIC8gZGVsdGE7XG4gICAgICAgIHZhciBkZWx0YUIgPSAoKCh2TWF4IC0gQikgLyA2KSArIChkZWx0YSAvIDIpKSAvIGRlbHRhO1xuICAgICAgICBpZiAoUiA9PT0gdk1heCkge1xuICAgICAgICAgICAgSCA9IGRlbHRhQiAtIGRlbHRhRztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChHID09PSB2TWF4KSB7XG4gICAgICAgICAgICBIID0gKDEgLyAzKSArIGRlbHRhUiAtIGRlbHRhQjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCID09PSB2TWF4KSB7XG4gICAgICAgICAgICBIID0gKDIgLyAzKSArIGRlbHRhRyAtIGRlbHRhUjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSCA8IDApIHtcbiAgICAgICAgICAgIEggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSCA+IDEpIHtcbiAgICAgICAgICAgIEggLT0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgaHNsYSA9IFtIICogMzYwLCBTLCBMXTtcbiAgICBpZiAocmdiYVszXSAhPSBudWxsKSB7XG4gICAgICAgIGhzbGEucHVzaChyZ2JhWzNdKTtcbiAgICB9XG4gICAgcmV0dXJuIGhzbGE7XG59XG5leHBvcnQgZnVuY3Rpb24gbGlmdChjb2xvciwgbGV2ZWwpIHtcbiAgICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG4gICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29sb3JBcnJbaV0gPSBjb2xvckFycltpXSAqICgxIC0gbGV2ZWwpIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbG9yQXJyW2ldID0gKCgyNTUgLSBjb2xvckFycltpXSkgKiBsZXZlbCArIGNvbG9yQXJyW2ldKSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sb3JBcnJbaV0gPiAyNTUpIHtcbiAgICAgICAgICAgICAgICBjb2xvckFycltpXSA9IDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbG9yQXJyW2ldIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbG9yQXJyW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGNvbG9yQXJyLCBjb2xvckFyci5sZW5ndGggPT09IDQgPyAncmdiYScgOiAncmdiJyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KGNvbG9yKSB7XG4gICAgdmFyIGNvbG9yQXJyID0gcGFyc2UoY29sb3IpO1xuICAgIGlmIChjb2xvckFycikge1xuICAgICAgICByZXR1cm4gKCgxIDw8IDI0KSArIChjb2xvckFyclswXSA8PCAxNikgKyAoY29sb3JBcnJbMV0gPDwgOCkgKyAoK2NvbG9yQXJyWzJdKSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBmYXN0TGVycChub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgb3V0KSB7XG4gICAgaWYgKCEoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpXG4gICAgICAgIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3V0ID0gb3V0IHx8IFtdO1xuICAgIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gICAgdmFyIGxlZnRJbmRleCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgICB2YXIgbGVmdENvbG9yID0gY29sb3JzW2xlZnRJbmRleF07XG4gICAgdmFyIHJpZ2h0Q29sb3IgPSBjb2xvcnNbcmlnaHRJbmRleF07XG4gICAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG4gICAgb3V0WzBdID0gY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpO1xuICAgIG91dFsxXSA9IGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKTtcbiAgICBvdXRbMl0gPSBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSk7XG4gICAgb3V0WzNdID0gY2xhbXBDc3NGbG9hdChsZXJwTnVtYmVyKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKTtcbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0IHZhciBmYXN0TWFwVG9Db2xvciA9IGZhc3RMZXJwO1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIGZ1bGxPdXRwdXQpIHtcbiAgICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aClcbiAgICAgICAgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICAgIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gICAgdmFyIGxlZnRDb2xvciA9IHBhcnNlKGNvbG9yc1tsZWZ0SW5kZXhdKTtcbiAgICB2YXIgcmlnaHRDb2xvciA9IHBhcnNlKGNvbG9yc1tyaWdodEluZGV4XSk7XG4gICAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG4gICAgdmFyIGNvbG9yID0gc3RyaW5naWZ5KFtcbiAgICAgICAgY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpLFxuICAgICAgICBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSksXG4gICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKSxcbiAgICAgICAgY2xhbXBDc3NGbG9hdChsZXJwTnVtYmVyKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKVxuICAgIF0sICdyZ2JhJyk7XG4gICAgcmV0dXJuIGZ1bGxPdXRwdXRcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICBsZWZ0SW5kZXg6IGxlZnRJbmRleCxcbiAgICAgICAgICAgIHJpZ2h0SW5kZXg6IHJpZ2h0SW5kZXgsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfVxuICAgICAgICA6IGNvbG9yO1xufVxuZXhwb3J0IHZhciBtYXBUb0NvbG9yID0gbGVycDtcbmV4cG9ydCBmdW5jdGlvbiBtb2RpZnlIU0woY29sb3IsIGgsIHMsIGwpIHtcbiAgICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGNvbG9yQXJyID0gcmdiYTJoc2xhKGNvbG9yQXJyKTtcbiAgICAgICAgaCAhPSBudWxsICYmIChjb2xvckFyclswXSA9IGNsYW1wQ3NzQW5nbGUoaCkpO1xuICAgICAgICBzICE9IG51bGwgJiYgKGNvbG9yQXJyWzFdID0gcGFyc2VDc3NGbG9hdChzKSk7XG4gICAgICAgIGwgIT0gbnVsbCAmJiAoY29sb3JBcnJbMl0gPSBwYXJzZUNzc0Zsb2F0KGwpKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShoc2xhMnJnYmEoY29sb3JBcnIpLCAncmdiYScpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBtb2RpZnlBbHBoYShjb2xvciwgYWxwaGEpIHtcbiAgICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG4gICAgaWYgKGNvbG9yQXJyICYmIGFscGhhICE9IG51bGwpIHtcbiAgICAgICAgY29sb3JBcnJbM10gPSBjbGFtcENzc0Zsb2F0KGFscGhhKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvckFyciwgJ3JnYmEnKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KGFyckNvbG9yLCB0eXBlKSB7XG4gICAgaWYgKCFhcnJDb2xvciB8fCAhYXJyQ29sb3IubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvbG9yU3RyID0gYXJyQ29sb3JbMF0gKyAnLCcgKyBhcnJDb2xvclsxXSArICcsJyArIGFyckNvbG9yWzJdO1xuICAgIGlmICh0eXBlID09PSAncmdiYScgfHwgdHlwZSA9PT0gJ2hzdmEnIHx8IHR5cGUgPT09ICdoc2xhJykge1xuICAgICAgICBjb2xvclN0ciArPSAnLCcgKyBhcnJDb2xvclszXTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGUgKyAnKCcgKyBjb2xvclN0ciArICcpJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBsdW0oY29sb3IsIGJhY2tncm91bmRMdW0pIHtcbiAgICB2YXIgYXJyID0gcGFyc2UoY29sb3IpO1xuICAgIHJldHVybiBhcnJcbiAgICAgICAgPyAoMC4yOTkgKiBhcnJbMF0gKyAwLjU4NyAqIGFyclsxXSArIDAuMTE0ICogYXJyWzJdKSAqIGFyclszXSAvIDI1NVxuICAgICAgICAgICAgKyAoMSAtIGFyclszXSkgKiBiYWNrZ3JvdW5kTHVtXG4gICAgICAgIDogMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20oKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShbXG4gICAgICAgIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDI1NSksXG4gICAgICAgIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDI1NSksXG4gICAgICAgIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDI1NSlcbiAgICBdLCAncmdiJyk7XG59XG52YXIgbGlmdGVkQ29sb3JDYWNoZSA9IG5ldyBMUlUoMTAwKTtcbmV4cG9ydCBmdW5jdGlvbiBsaWZ0Q29sb3IoY29sb3IpIHtcbiAgICBpZiAoaXNTdHJpbmcoY29sb3IpKSB7XG4gICAgICAgIHZhciBsaWZ0ZWRDb2xvciA9IGxpZnRlZENvbG9yQ2FjaGUuZ2V0KGNvbG9yKTtcbiAgICAgICAgaWYgKCFsaWZ0ZWRDb2xvcikge1xuICAgICAgICAgICAgbGlmdGVkQ29sb3IgPSBsaWZ0KGNvbG9yLCAtMC4xKTtcbiAgICAgICAgICAgIGxpZnRlZENvbG9yQ2FjaGUucHV0KGNvbG9yLCBsaWZ0ZWRDb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpZnRlZENvbG9yO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0dyYWRpZW50T2JqZWN0KGNvbG9yKSkge1xuICAgICAgICB2YXIgcmV0ID0gZXh0ZW5kKHt9LCBjb2xvcik7XG4gICAgICAgIHJldC5jb2xvclN0b3BzID0gbWFwKGNvbG9yLmNvbG9yU3RvcHMsIGZ1bmN0aW9uIChzdG9wKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgb2Zmc2V0OiBzdG9wLm9mZnNldCxcbiAgICAgICAgICAgIGNvbG9yOiBsaWZ0KHN0b3AuY29sb3IsIC0wLjEpXG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///47698\n")},59442:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  rR: () => (/* binding */ clonePath),\n  UJ: () => (/* binding */ createFromString),\n  Qh: () => (/* binding */ extendFromString),\n  uc: () => (/* binding */ mergePath)\n});\n\n// EXTERNAL MODULE: ./node_modules/zrender/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(15727);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Path.js\nvar Path = __webpack_require__(59482);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/PathProxy.js\nvar PathProxy = __webpack_require__(68717);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/vector.js\nvar vector = __webpack_require__(83509);\n;// ./node_modules/zrender/lib/tool/transformPath.js\n\n\nvar CMD = PathProxy/* default */.A.CMD;\nvar points = [[], [], []];\nvar mathSqrt = Math.sqrt;\nvar mathAtan2 = Math.atan2;\nfunction transformPath(path, m) {\n    if (!m) {\n        return;\n    }\n    var data = path.data;\n    var len = path.len();\n    var cmd;\n    var nPoint;\n    var i;\n    var j;\n    var k;\n    var p;\n    var M = CMD.M;\n    var C = CMD.C;\n    var L = CMD.L;\n    var R = CMD.R;\n    var A = CMD.A;\n    var Q = CMD.Q;\n    for (i = 0, j = 0; i < len;) {\n        cmd = data[i++];\n        j = i;\n        nPoint = 0;\n        switch (cmd) {\n            case M:\n                nPoint = 1;\n                break;\n            case L:\n                nPoint = 1;\n                break;\n            case C:\n                nPoint = 3;\n                break;\n            case Q:\n                nPoint = 2;\n                break;\n            case A:\n                var x = m[4];\n                var y = m[5];\n                var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                data[i] *= sx;\n                data[i++] += x;\n                data[i] *= sy;\n                data[i++] += y;\n                data[i++] *= sx;\n                data[i++] *= sy;\n                data[i++] += angle;\n                data[i++] += angle;\n                i += 2;\n                j = i;\n                break;\n            case R:\n                p[0] = data[i++];\n                p[1] = data[i++];\n                (0,vector.applyTransform)(p, p, m);\n                data[j++] = p[0];\n                data[j++] = p[1];\n                p[0] += data[i++];\n                p[1] += data[i++];\n                (0,vector.applyTransform)(p, p, m);\n                data[j++] = p[0];\n                data[j++] = p[1];\n        }\n        for (k = 0; k < nPoint; k++) {\n            var p_1 = points[k];\n            p_1[0] = data[i++];\n            p_1[1] = data[i++];\n            (0,vector.applyTransform)(p_1, p_1, m);\n            data[j++] = p_1[0];\n            data[j++] = p_1[1];\n        }\n    }\n    path.increaseVersion();\n}\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n;// ./node_modules/zrender/lib/tool/path.js\n\n\n\n\n\nvar path_mathSqrt = Math.sqrt;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\nfunction vMag(v) {\n    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n}\n;\nfunction vRatio(u, v) {\n    return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n}\n;\nfunction vAngle(u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n        * Math.acos(vRatio(u, v));\n}\n;\nfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n    var psi = psiDeg * (PI / 180.0);\n    var xp = mathCos(psi) * (x1 - x2) / 2.0\n        + mathSin(psi) * (y1 - y2) / 2.0;\n    var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n        + mathCos(psi) * (y1 - y2) / 2.0;\n    var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n    if (lambda > 1) {\n        rx *= path_mathSqrt(lambda);\n        ry *= path_mathSqrt(lambda);\n    }\n    var f = (fa === fs ? -1 : 1)\n        * path_mathSqrt((((rx * rx) * (ry * ry))\n            - ((rx * rx) * (yp * yp))\n            - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n            + (ry * ry) * (xp * xp))) || 0;\n    var cxp = f * rx * yp / ry;\n    var cyp = f * -ry * xp / rx;\n    var cx = (x1 + x2) / 2.0\n        + mathCos(psi) * cxp\n        - mathSin(psi) * cyp;\n    var cy = (y1 + y2) / 2.0\n        + mathSin(psi) * cxp\n        + mathCos(psi) * cyp;\n    var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n    var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n    var dTheta = vAngle(u, v);\n    if (vRatio(u, v) <= -1) {\n        dTheta = PI;\n    }\n    if (vRatio(u, v) >= 1) {\n        dTheta = 0;\n    }\n    if (dTheta < 0) {\n        var n = Math.round(dTheta / PI * 1e6) / 1e6;\n        dTheta = PI * 2 + (n % 2) * PI;\n    }\n    path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n}\nvar commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;\nvar numberReg = /-?([0-9]*\\.)?[0-9]+([eE]-?[0-9]+)?/g;\nfunction createPathProxyFromString(data) {\n    var path = new PathProxy/* default */.A();\n    if (!data) {\n        return path;\n    }\n    var cpx = 0;\n    var cpy = 0;\n    var subpathX = cpx;\n    var subpathY = cpy;\n    var prevCmd;\n    var CMD = PathProxy/* default */.A.CMD;\n    var cmdList = data.match(commandReg);\n    if (!cmdList) {\n        return path;\n    }\n    for (var l = 0; l < cmdList.length; l++) {\n        var cmdText = cmdList[l];\n        var cmdStr = cmdText.charAt(0);\n        var cmd = void 0;\n        var p = cmdText.match(numberReg) || [];\n        var pLen = p.length;\n        for (var i = 0; i < pLen; i++) {\n            p[i] = parseFloat(p[i]);\n        }\n        var off = 0;\n        while (off < pLen) {\n            var ctlPtx = void 0;\n            var ctlPty = void 0;\n            var rx = void 0;\n            var ry = void 0;\n            var psi = void 0;\n            var fa = void 0;\n            var fs = void 0;\n            var x1 = cpx;\n            var y1 = cpy;\n            var len = void 0;\n            var pathData = void 0;\n            switch (cmdStr) {\n                case 'l':\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'L':\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'm':\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.M;\n                    path.addData(cmd, cpx, cpy);\n                    subpathX = cpx;\n                    subpathY = cpy;\n                    cmdStr = 'l';\n                    break;\n                case 'M':\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.M;\n                    path.addData(cmd, cpx, cpy);\n                    subpathX = cpx;\n                    subpathY = cpy;\n                    cmdStr = 'L';\n                    break;\n                case 'h':\n                    cpx += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'H':\n                    cpx = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'v':\n                    cpy += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'V':\n                    cpy = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'C':\n                    cmd = CMD.C;\n                    path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n                    cpx = p[off - 2];\n                    cpy = p[off - 1];\n                    break;\n                case 'c':\n                    cmd = CMD.C;\n                    path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n                    cpx += p[off - 2];\n                    cpy += p[off - 1];\n                    break;\n                case 'S':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    len = path.len();\n                    pathData = path.data;\n                    if (prevCmd === CMD.C) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cmd = CMD.C;\n                    x1 = p[off++];\n                    y1 = p[off++];\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                    break;\n                case 's':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    len = path.len();\n                    pathData = path.data;\n                    if (prevCmd === CMD.C) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cmd = CMD.C;\n                    x1 = cpx + p[off++];\n                    y1 = cpy + p[off++];\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                    break;\n                case 'Q':\n                    x1 = p[off++];\n                    y1 = p[off++];\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, x1, y1, cpx, cpy);\n                    break;\n                case 'q':\n                    x1 = p[off++] + cpx;\n                    y1 = p[off++] + cpy;\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, x1, y1, cpx, cpy);\n                    break;\n                case 'T':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    len = path.len();\n                    pathData = path.data;\n                    if (prevCmd === CMD.Q) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                    break;\n                case 't':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    len = path.len();\n                    pathData = path.data;\n                    if (prevCmd === CMD.Q) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                    break;\n                case 'A':\n                    rx = p[off++];\n                    ry = p[off++];\n                    psi = p[off++];\n                    fa = p[off++];\n                    fs = p[off++];\n                    x1 = cpx, y1 = cpy;\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.A;\n                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n                    break;\n                case 'a':\n                    rx = p[off++];\n                    ry = p[off++];\n                    psi = p[off++];\n                    fa = p[off++];\n                    fs = p[off++];\n                    x1 = cpx, y1 = cpy;\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.A;\n                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n                    break;\n            }\n        }\n        if (cmdStr === 'z' || cmdStr === 'Z') {\n            cmd = CMD.Z;\n            path.addData(cmd);\n            cpx = subpathX;\n            cpy = subpathY;\n        }\n        prevCmd = cmd;\n    }\n    path.toStatic();\n    return path;\n}\nvar SVGPath = (function (_super) {\n    (0,tslib_es6/* __extends */.C6)(SVGPath, _super);\n    function SVGPath() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SVGPath.prototype.applyTransform = function (m) { };\n    return SVGPath;\n}(Path/* default */.Ay));\nfunction isPathProxy(path) {\n    return path.setData != null;\n}\nfunction createPathOptions(str, opts) {\n    var pathProxy = createPathProxyFromString(str);\n    var innerOpts = (0,util.extend)({}, opts);\n    innerOpts.buildPath = function (path) {\n        if (isPathProxy(path)) {\n            path.setData(pathProxy.data);\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx, 1);\n            }\n        }\n        else {\n            var ctx = path;\n            pathProxy.rebuildPath(ctx, 1);\n        }\n    };\n    innerOpts.applyTransform = function (m) {\n        transformPath(pathProxy, m);\n        this.dirtyShape();\n    };\n    return innerOpts;\n}\nfunction createFromString(str, opts) {\n    return new SVGPath(createPathOptions(str, opts));\n}\nfunction extendFromString(str, defaultOpts) {\n    var innerOpts = createPathOptions(str, defaultOpts);\n    var Sub = (function (_super) {\n        (0,tslib_es6/* __extends */.C6)(Sub, _super);\n        function Sub(opts) {\n            var _this = _super.call(this, opts) || this;\n            _this.applyTransform = innerOpts.applyTransform;\n            _this.buildPath = innerOpts.buildPath;\n            return _this;\n        }\n        return Sub;\n    }(SVGPath));\n    return Sub;\n}\nfunction mergePath(pathEls, opts) {\n    var pathList = [];\n    var len = pathEls.length;\n    for (var i = 0; i < len; i++) {\n        var pathEl = pathEls[i];\n        pathList.push(pathEl.getUpdatedPathProxy(true));\n    }\n    var pathBundle = new Path/* default */.Ay(opts);\n    pathBundle.createPathProxy();\n    pathBundle.buildPath = function (path) {\n        if (isPathProxy(path)) {\n            path.appendPath(pathList);\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx, 1);\n            }\n        }\n    };\n    return pathBundle;\n}\nfunction clonePath(sourcePath, opts) {\n    opts = opts || {};\n    var path = new Path/* default */.Ay();\n    if (sourcePath.shape) {\n        path.setShape(sourcePath.shape);\n    }\n    path.setStyle(sourcePath.style);\n    if (opts.bakeTransform) {\n        transformPath(path.path, sourcePath.getComputedTransform());\n    }\n    else {\n        if (opts.toLocal) {\n            path.setLocalTransform(sourcePath.getComputedTransform());\n        }\n        else {\n            path.copyTransform(sourcePath);\n        }\n    }\n    path.buildPath = sourcePath.buildPath;\n    path.applyTransform = path.applyTransform;\n    path.z = sourcePath.z;\n    path.z2 = sourcePath.z2;\n    path.zlevel = sourcePath.zlevel;\n    return path;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTk0NDIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzP2E2ODYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qcz9mNzk2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQYXRoUHJveHkgZnJvbSAnLi4vY29yZS9QYXRoUHJveHkuanMnO1xuaW1wb3J0IHsgYXBwbHlUcmFuc2Zvcm0gYXMgdjJBcHBseVRyYW5zZm9ybSB9IGZyb20gJy4uL2NvcmUvdmVjdG9yLmpzJztcbnZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xudmFyIHBvaW50cyA9IFtbXSwgW10sIFtdXTtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoQXRhbjIgPSBNYXRoLmF0YW4yO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNmb3JtUGF0aChwYXRoLCBtKSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgdmFyIGNtZDtcbiAgICB2YXIgblBvaW50O1xuICAgIHZhciBpO1xuICAgIHZhciBqO1xuICAgIHZhciBrO1xuICAgIHZhciBwO1xuICAgIHZhciBNID0gQ01ELk07XG4gICAgdmFyIEMgPSBDTUQuQztcbiAgICB2YXIgTCA9IENNRC5MO1xuICAgIHZhciBSID0gQ01ELlI7XG4gICAgdmFyIEEgPSBDTUQuQTtcbiAgICB2YXIgUSA9IENNRC5RO1xuICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbGVuOykge1xuICAgICAgICBjbWQgPSBkYXRhW2krK107XG4gICAgICAgIGogPSBpO1xuICAgICAgICBuUG9pbnQgPSAwO1xuICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgY2FzZSBNOlxuICAgICAgICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEw6XG4gICAgICAgICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQzpcbiAgICAgICAgICAgICAgICBuUG9pbnQgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBROlxuICAgICAgICAgICAgICAgIG5Qb2ludCA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEE6XG4gICAgICAgICAgICAgICAgdmFyIHggPSBtWzRdO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gbVs1XTtcbiAgICAgICAgICAgICAgICB2YXIgc3ggPSBtYXRoU3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgICAgICAgICAgICB2YXIgc3kgPSBtYXRoU3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBtYXRoQXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbiAgICAgICAgICAgICAgICBkYXRhW2ldICo9IHN4O1xuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSB4O1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gKj0gc3k7XG4gICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IHk7XG4gICAgICAgICAgICAgICAgZGF0YVtpKytdICo9IHN4O1xuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSAqPSBzeTtcbiAgICAgICAgICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7XG4gICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlO1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUjpcbiAgICAgICAgICAgICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHBbMV0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgICAgICAgICAgICAgcFswXSArPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgcFsxXSArPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgcF8xID0gcG9pbnRzW2tdO1xuICAgICAgICAgICAgcF8xWzBdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgcF8xWzFdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwXzEsIHBfMSwgbSk7XG4gICAgICAgICAgICBkYXRhW2orK10gPSBwXzFbMF07XG4gICAgICAgICAgICBkYXRhW2orK10gPSBwXzFbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGF0aC5pbmNyZWFzZVZlcnNpb24oKTtcbn1cbiIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFBhdGggZnJvbSAnLi4vZ3JhcGhpYy9QYXRoLmpzJztcbmltcG9ydCBQYXRoUHJveHkgZnJvbSAnLi4vY29yZS9QYXRoUHJveHkuanMnO1xuaW1wb3J0IHRyYW5zZm9ybVBhdGggZnJvbSAnLi90cmFuc2Zvcm1QYXRoLmpzJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL2NvcmUvdXRpbC5qcyc7XG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgbWF0aFNpbiA9IE1hdGguc2luO1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBQSSA9IE1hdGguUEk7XG5mdW5jdGlvbiB2TWFnKHYpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xufVxuO1xuZnVuY3Rpb24gdlJhdGlvKHUsIHYpIHtcbiAgICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pIC8gKHZNYWcodSkgKiB2TWFnKHYpKTtcbn1cbjtcbmZ1bmN0aW9uIHZBbmdsZSh1LCB2KSB7XG4gICAgcmV0dXJuICh1WzBdICogdlsxXSA8IHVbMV0gKiB2WzBdID8gLTEgOiAxKVxuICAgICAgICAqIE1hdGguYWNvcyh2UmF0aW8odSwgdikpO1xufVxuO1xuZnVuY3Rpb24gcHJvY2Vzc0FyYyh4MSwgeTEsIHgyLCB5MiwgZmEsIGZzLCByeCwgcnksIHBzaURlZywgY21kLCBwYXRoKSB7XG4gICAgdmFyIHBzaSA9IHBzaURlZyAqIChQSSAvIDE4MC4wKTtcbiAgICB2YXIgeHAgPSBtYXRoQ29zKHBzaSkgKiAoeDEgLSB4MikgLyAyLjBcbiAgICAgICAgKyBtYXRoU2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gICAgdmFyIHlwID0gLTEgKiBtYXRoU2luKHBzaSkgKiAoeDEgLSB4MikgLyAyLjBcbiAgICAgICAgKyBtYXRoQ29zKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gICAgdmFyIGxhbWJkYSA9ICh4cCAqIHhwKSAvIChyeCAqIHJ4KSArICh5cCAqIHlwKSAvIChyeSAqIHJ5KTtcbiAgICBpZiAobGFtYmRhID4gMSkge1xuICAgICAgICByeCAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgICAgICByeSAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgIH1cbiAgICB2YXIgZiA9IChmYSA9PT0gZnMgPyAtMSA6IDEpXG4gICAgICAgICogbWF0aFNxcnQoKCgocnggKiByeCkgKiAocnkgKiByeSkpXG4gICAgICAgICAgICAtICgocnggKiByeCkgKiAoeXAgKiB5cCkpXG4gICAgICAgICAgICAtICgocnkgKiByeSkgKiAoeHAgKiB4cCkpKSAvICgocnggKiByeCkgKiAoeXAgKiB5cClcbiAgICAgICAgICAgICsgKHJ5ICogcnkpICogKHhwICogeHApKSkgfHwgMDtcbiAgICB2YXIgY3hwID0gZiAqIHJ4ICogeXAgLyByeTtcbiAgICB2YXIgY3lwID0gZiAqIC1yeSAqIHhwIC8gcng7XG4gICAgdmFyIGN4ID0gKHgxICsgeDIpIC8gMi4wXG4gICAgICAgICsgbWF0aENvcyhwc2kpICogY3hwXG4gICAgICAgIC0gbWF0aFNpbihwc2kpICogY3lwO1xuICAgIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMFxuICAgICAgICArIG1hdGhTaW4ocHNpKSAqIGN4cFxuICAgICAgICArIG1hdGhDb3MocHNpKSAqIGN5cDtcbiAgICB2YXIgdGhldGEgPSB2QW5nbGUoWzEsIDBdLCBbKHhwIC0gY3hwKSAvIHJ4LCAoeXAgLSBjeXApIC8gcnldKTtcbiAgICB2YXIgdSA9IFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV07XG4gICAgdmFyIHYgPSBbKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5XTtcbiAgICB2YXIgZFRoZXRhID0gdkFuZ2xlKHUsIHYpO1xuICAgIGlmICh2UmF0aW8odSwgdikgPD0gLTEpIHtcbiAgICAgICAgZFRoZXRhID0gUEk7XG4gICAgfVxuICAgIGlmICh2UmF0aW8odSwgdikgPj0gMSkge1xuICAgICAgICBkVGhldGEgPSAwO1xuICAgIH1cbiAgICBpZiAoZFRoZXRhIDwgMCkge1xuICAgICAgICB2YXIgbiA9IE1hdGgucm91bmQoZFRoZXRhIC8gUEkgKiAxZTYpIC8gMWU2O1xuICAgICAgICBkVGhldGEgPSBQSSAqIDIgKyAobiAlIDIpICogUEk7XG4gICAgfVxuICAgIHBhdGguYWRkRGF0YShjbWQsIGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzKTtcbn1cbnZhciBjb21tYW5kUmVnID0gLyhbbWx2aHpjcXRzYV0pKFtebWx2aHpjcXRzYV0qKS9pZztcbnZhciBudW1iZXJSZWcgPSAvLT8oWzAtOV0qXFwuKT9bMC05XSsoW2VFXS0/WzAtOV0rKT8vZztcbmZ1bmN0aW9uIGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoZGF0YSkge1xuICAgIHZhciBwYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgdmFyIGNweCA9IDA7XG4gICAgdmFyIGNweSA9IDA7XG4gICAgdmFyIHN1YnBhdGhYID0gY3B4O1xuICAgIHZhciBzdWJwYXRoWSA9IGNweTtcbiAgICB2YXIgcHJldkNtZDtcbiAgICB2YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbiAgICB2YXIgY21kTGlzdCA9IGRhdGEubWF0Y2goY29tbWFuZFJlZyk7XG4gICAgaWYgKCFjbWRMaXN0KSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IGNtZExpc3QubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgdmFyIGNtZFRleHQgPSBjbWRMaXN0W2xdO1xuICAgICAgICB2YXIgY21kU3RyID0gY21kVGV4dC5jaGFyQXQoMCk7XG4gICAgICAgIHZhciBjbWQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBwID0gY21kVGV4dC5tYXRjaChudW1iZXJSZWcpIHx8IFtdO1xuICAgICAgICB2YXIgcExlbiA9IHAubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBMZW47IGkrKykge1xuICAgICAgICAgICAgcFtpXSA9IHBhcnNlRmxvYXQocFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICAgIHdoaWxlIChvZmYgPCBwTGVuKSB7XG4gICAgICAgICAgICB2YXIgY3RsUHR4ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGN0bFB0eSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciByeCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciByeSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBwc2kgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgZmEgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgZnMgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgeDEgPSBjcHg7XG4gICAgICAgICAgICB2YXIgeTEgPSBjcHk7XG4gICAgICAgICAgICB2YXIgbGVuID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gdm9pZCAwO1xuICAgICAgICAgICAgc3dpdGNoIChjbWRTdHIpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgc3VicGF0aFggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgIHN1YnBhdGhZID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICBjbWRTdHIgPSAnbCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnBhdGhYID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICBzdWJwYXRoWSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgY21kU3RyID0gJ0wnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdKTtcbiAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHksIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSwgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmIC0gMl07XG4gICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELkMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICB4MSA9IGNweCArIHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IGNweSArIHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICB4MSA9IHBbb2ZmKytdICsgY3B4O1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHBbb2ZmKytdICsgY3B5O1xuICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICByeSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgZnMgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQXJjKHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICByeSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgZnMgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkE7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtZFN0ciA9PT0gJ3onIHx8IGNtZFN0ciA9PT0gJ1onKSB7XG4gICAgICAgICAgICBjbWQgPSBDTUQuWjtcbiAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQpO1xuICAgICAgICAgICAgY3B4ID0gc3VicGF0aFg7XG4gICAgICAgICAgICBjcHkgPSBzdWJwYXRoWTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2Q21kID0gY21kO1xuICAgIH1cbiAgICBwYXRoLnRvU3RhdGljKCk7XG4gICAgcmV0dXJuIHBhdGg7XG59XG52YXIgU1ZHUGF0aCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNWR1BhdGgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU1ZHUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTVkdQYXRoLnByb3RvdHlwZS5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7IH07XG4gICAgcmV0dXJuIFNWR1BhdGg7XG59KFBhdGgpKTtcbmZ1bmN0aW9uIGlzUGF0aFByb3h5KHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5zZXREYXRhICE9IG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpIHtcbiAgICB2YXIgcGF0aFByb3h5ID0gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhzdHIpO1xuICAgIHZhciBpbm5lck9wdHMgPSBleHRlbmQoe30sIG9wdHMpO1xuICAgIGlubmVyT3B0cy5idWlsZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICBpZiAoaXNQYXRoUHJveHkocGF0aCkpIHtcbiAgICAgICAgICAgIHBhdGguc2V0RGF0YShwYXRoUHJveHkuZGF0YSk7XG4gICAgICAgICAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgcGF0aC5yZWJ1aWxkUGF0aChjdHgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHBhdGg7XG4gICAgICAgICAgICBwYXRoUHJveHkucmVidWlsZFBhdGgoY3R4LCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW5uZXJPcHRzLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgdHJhbnNmb3JtUGF0aChwYXRoUHJveHksIG0pO1xuICAgICAgICB0aGlzLmRpcnR5U2hhcGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBpbm5lck9wdHM7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJvbVN0cmluZyhzdHIsIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFNWR1BhdGgoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kRnJvbVN0cmluZyhzdHIsIGRlZmF1bHRPcHRzKSB7XG4gICAgdmFyIGlubmVyT3B0cyA9IGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgZGVmYXVsdE9wdHMpO1xuICAgIHZhciBTdWIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoU3ViLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBTdWIob3B0cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmFwcGx5VHJhbnNmb3JtID0gaW5uZXJPcHRzLmFwcGx5VHJhbnNmb3JtO1xuICAgICAgICAgICAgX3RoaXMuYnVpbGRQYXRoID0gaW5uZXJPcHRzLmJ1aWxkUGF0aDtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3ViO1xuICAgIH0oU1ZHUGF0aCkpO1xuICAgIHJldHVybiBTdWI7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VQYXRoKHBhdGhFbHMsIG9wdHMpIHtcbiAgICB2YXIgcGF0aExpc3QgPSBbXTtcbiAgICB2YXIgbGVuID0gcGF0aEVscy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcGF0aEVsID0gcGF0aEVsc1tpXTtcbiAgICAgICAgcGF0aExpc3QucHVzaChwYXRoRWwuZ2V0VXBkYXRlZFBhdGhQcm94eSh0cnVlKSk7XG4gICAgfVxuICAgIHZhciBwYXRoQnVuZGxlID0gbmV3IFBhdGgob3B0cyk7XG4gICAgcGF0aEJ1bmRsZS5jcmVhdGVQYXRoUHJveHkoKTtcbiAgICBwYXRoQnVuZGxlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIGlmIChpc1BhdGhQcm94eShwYXRoKSkge1xuICAgICAgICAgICAgcGF0aC5hcHBlbmRQYXRoKHBhdGhMaXN0KTtcbiAgICAgICAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBwYXRoQnVuZGxlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lUGF0aChzb3VyY2VQYXRoLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIHBhdGggPSBuZXcgUGF0aCgpO1xuICAgIGlmIChzb3VyY2VQYXRoLnNoYXBlKSB7XG4gICAgICAgIHBhdGguc2V0U2hhcGUoc291cmNlUGF0aC5zaGFwZSk7XG4gICAgfVxuICAgIHBhdGguc2V0U3R5bGUoc291cmNlUGF0aC5zdHlsZSk7XG4gICAgaWYgKG9wdHMuYmFrZVRyYW5zZm9ybSkge1xuICAgICAgICB0cmFuc2Zvcm1QYXRoKHBhdGgucGF0aCwgc291cmNlUGF0aC5nZXRDb21wdXRlZFRyYW5zZm9ybSgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChvcHRzLnRvTG9jYWwpIHtcbiAgICAgICAgICAgIHBhdGguc2V0TG9jYWxUcmFuc2Zvcm0oc291cmNlUGF0aC5nZXRDb21wdXRlZFRyYW5zZm9ybSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGguY29weVRyYW5zZm9ybShzb3VyY2VQYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXRoLmJ1aWxkUGF0aCA9IHNvdXJjZVBhdGguYnVpbGRQYXRoO1xuICAgIHBhdGguYXBwbHlUcmFuc2Zvcm0gPSBwYXRoLmFwcGx5VHJhbnNmb3JtO1xuICAgIHBhdGgueiA9IHNvdXJjZVBhdGguejtcbiAgICBwYXRoLnoyID0gc291cmNlUGF0aC56MjtcbiAgICBwYXRoLnpsZXZlbCA9IHNvdXJjZVBhdGguemxldmVsO1xuICAgIHJldHVybiBwYXRoO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///59442\n")},69942:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cM: () => (/* binding */ parseSVG),\n/* harmony export */   ps: () => (/* binding */ makeViewBoxTransform)\n/* harmony export */ });\n/* harmony import */ var _graphic_Group_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43870);\n/* harmony import */ var _graphic_Image_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(90540);\n/* harmony import */ var _graphic_shape_Circle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(31571);\n/* harmony import */ var _graphic_shape_Rect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30010);\n/* harmony import */ var _graphic_shape_Ellipse_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(18393);\n/* harmony import */ var _graphic_shape_Line_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(82861);\n/* harmony import */ var _graphic_shape_Polygon_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(52505);\n/* harmony import */ var _graphic_shape_Polyline_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(39195);\n/* harmony import */ var _core_matrix_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(45587);\n/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(59442);\n/* harmony import */ var _core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _graphic_LinearGradient_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(29668);\n/* harmony import */ var _graphic_RadialGradient_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(82250);\n/* harmony import */ var _graphic_TSpan_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19845);\n/* harmony import */ var _parseXML_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2141);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;\nvar nodeParsers;\nvar INHERITABLE_STYLE_ATTRIBUTES_MAP = {\n    'fill': 'fill',\n    'stroke': 'stroke',\n    'stroke-width': 'lineWidth',\n    'opacity': 'opacity',\n    'fill-opacity': 'fillOpacity',\n    'stroke-opacity': 'strokeOpacity',\n    'stroke-dasharray': 'lineDash',\n    'stroke-dashoffset': 'lineDashOffset',\n    'stroke-linecap': 'lineCap',\n    'stroke-linejoin': 'lineJoin',\n    'stroke-miterlimit': 'miterLimit',\n    'font-family': 'fontFamily',\n    'font-size': 'fontSize',\n    'font-style': 'fontStyle',\n    'font-weight': 'fontWeight',\n    'text-anchor': 'textAlign',\n    'visibility': 'visibility',\n    'display': 'display'\n};\nvar INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys)(INHERITABLE_STYLE_ATTRIBUTES_MAP);\nvar SELF_STYLE_ATTRIBUTES_MAP = {\n    'alignment-baseline': 'textBaseline',\n    'stop-color': 'stopColor'\n};\nvar SELF_STYLE_ATTRIBUTES_MAP_KEYS = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys)(SELF_STYLE_ATTRIBUTES_MAP);\nvar SVGParser = (function () {\n    function SVGParser() {\n        this._defs = {};\n        this._root = null;\n    }\n    SVGParser.prototype.parse = function (xml, opt) {\n        opt = opt || {};\n        var svg = (0,_parseXML_js__WEBPACK_IMPORTED_MODULE_1__/* .parseXML */ .h)(xml);\n        if (false) {}\n        this._defsUsePending = [];\n        var root = new _graphic_Group_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A();\n        this._root = root;\n        var named = [];\n        var viewBox = svg.getAttribute('viewBox') || '';\n        var width = parseFloat((svg.getAttribute('width') || opt.width));\n        var height = parseFloat((svg.getAttribute('height') || opt.height));\n        isNaN(width) && (width = null);\n        isNaN(height) && (height = null);\n        parseAttributes(svg, root, null, true, false);\n        var child = svg.firstChild;\n        while (child) {\n            this._parseNode(child, root, named, null, false, false);\n            child = child.nextSibling;\n        }\n        applyDefs(this._defs, this._defsUsePending);\n        this._defsUsePending = [];\n        var viewBoxRect;\n        var viewBoxTransform;\n        if (viewBox) {\n            var viewBoxArr = splitNumberSequence(viewBox);\n            if (viewBoxArr.length >= 4) {\n                viewBoxRect = {\n                    x: parseFloat((viewBoxArr[0] || 0)),\n                    y: parseFloat((viewBoxArr[1] || 0)),\n                    width: parseFloat(viewBoxArr[2]),\n                    height: parseFloat(viewBoxArr[3])\n                };\n            }\n        }\n        if (viewBoxRect && width != null && height != null) {\n            viewBoxTransform = makeViewBoxTransform(viewBoxRect, { x: 0, y: 0, width: width, height: height });\n            if (!opt.ignoreViewBox) {\n                var elRoot = root;\n                root = new _graphic_Group_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A();\n                root.add(elRoot);\n                elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;\n                elRoot.x = viewBoxTransform.x;\n                elRoot.y = viewBoxTransform.y;\n            }\n        }\n        if (!opt.ignoreRootClip && width != null && height != null) {\n            root.setClipPath(new _graphic_shape_Rect_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A({\n                shape: { x: 0, y: 0, width: width, height: height }\n            }));\n        }\n        return {\n            root: root,\n            width: width,\n            height: height,\n            viewBoxRect: viewBoxRect,\n            viewBoxTransform: viewBoxTransform,\n            named: named\n        };\n    };\n    SVGParser.prototype._parseNode = function (xmlNode, parentGroup, named, namedFrom, isInDefs, isInText) {\n        var nodeName = xmlNode.nodeName.toLowerCase();\n        var el;\n        var namedFromForSub = namedFrom;\n        if (nodeName === 'defs') {\n            isInDefs = true;\n        }\n        if (nodeName === 'text') {\n            isInText = true;\n        }\n        if (nodeName === 'defs' || nodeName === 'switch') {\n            el = parentGroup;\n        }\n        else {\n            if (!isInDefs) {\n                var parser_1 = nodeParsers[nodeName];\n                if (parser_1 && (0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(nodeParsers, nodeName)) {\n                    el = parser_1.call(this, xmlNode, parentGroup);\n                    var nameAttr = xmlNode.getAttribute('name');\n                    if (nameAttr) {\n                        var newNamed = {\n                            name: nameAttr,\n                            namedFrom: null,\n                            svgNodeTagLower: nodeName,\n                            el: el\n                        };\n                        named.push(newNamed);\n                        if (nodeName === 'g') {\n                            namedFromForSub = newNamed;\n                        }\n                    }\n                    else if (namedFrom) {\n                        named.push({\n                            name: namedFrom.name,\n                            namedFrom: namedFrom,\n                            svgNodeTagLower: nodeName,\n                            el: el\n                        });\n                    }\n                    parentGroup.add(el);\n                }\n            }\n            var parser = paintServerParsers[nodeName];\n            if (parser && (0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(paintServerParsers, nodeName)) {\n                var def = parser.call(this, xmlNode);\n                var id = xmlNode.getAttribute('id');\n                if (id) {\n                    this._defs[id] = def;\n                }\n            }\n        }\n        if (el && el.isGroup) {\n            var child = xmlNode.firstChild;\n            while (child) {\n                if (child.nodeType === 1) {\n                    this._parseNode(child, el, named, namedFromForSub, isInDefs, isInText);\n                }\n                else if (child.nodeType === 3 && isInText) {\n                    this._parseText(child, el);\n                }\n                child = child.nextSibling;\n            }\n        }\n    };\n    SVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n        var text = new _graphic_TSpan_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A({\n            style: {\n                text: xmlNode.textContent\n            },\n            silent: true,\n            x: this._textX || 0,\n            y: this._textY || 0\n        });\n        inheritStyle(parentGroup, text);\n        parseAttributes(xmlNode, text, this._defsUsePending, false, false);\n        applyTextAlignment(text, parentGroup);\n        var textStyle = text.style;\n        var fontSize = textStyle.fontSize;\n        if (fontSize && fontSize < 9) {\n            textStyle.fontSize = 9;\n            text.scaleX *= fontSize / 9;\n            text.scaleY *= fontSize / 9;\n        }\n        var font = (textStyle.fontSize || textStyle.fontFamily) && [\n            textStyle.fontStyle,\n            textStyle.fontWeight,\n            (textStyle.fontSize || 12) + 'px',\n            textStyle.fontFamily || 'sans-serif'\n        ].join(' ');\n        textStyle.font = font;\n        var rect = text.getBoundingRect();\n        this._textX += rect.width;\n        parentGroup.add(text);\n        return text;\n    };\n    SVGParser.internalField = (function () {\n        nodeParsers = {\n            'g': function (xmlNode, parentGroup) {\n                var g = new _graphic_Group_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defsUsePending, false, false);\n                return g;\n            },\n            'rect': function (xmlNode, parentGroup) {\n                var rect = new _graphic_shape_Rect_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A();\n                inheritStyle(parentGroup, rect);\n                parseAttributes(xmlNode, rect, this._defsUsePending, false, false);\n                rect.setShape({\n                    x: parseFloat(xmlNode.getAttribute('x') || '0'),\n                    y: parseFloat(xmlNode.getAttribute('y') || '0'),\n                    width: parseFloat(xmlNode.getAttribute('width') || '0'),\n                    height: parseFloat(xmlNode.getAttribute('height') || '0')\n                });\n                rect.silent = true;\n                return rect;\n            },\n            'circle': function (xmlNode, parentGroup) {\n                var circle = new _graphic_shape_Circle_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A();\n                inheritStyle(parentGroup, circle);\n                parseAttributes(xmlNode, circle, this._defsUsePending, false, false);\n                circle.setShape({\n                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n                    r: parseFloat(xmlNode.getAttribute('r') || '0')\n                });\n                circle.silent = true;\n                return circle;\n            },\n            'line': function (xmlNode, parentGroup) {\n                var line = new _graphic_shape_Line_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A();\n                inheritStyle(parentGroup, line);\n                parseAttributes(xmlNode, line, this._defsUsePending, false, false);\n                line.setShape({\n                    x1: parseFloat(xmlNode.getAttribute('x1') || '0'),\n                    y1: parseFloat(xmlNode.getAttribute('y1') || '0'),\n                    x2: parseFloat(xmlNode.getAttribute('x2') || '0'),\n                    y2: parseFloat(xmlNode.getAttribute('y2') || '0')\n                });\n                line.silent = true;\n                return line;\n            },\n            'ellipse': function (xmlNode, parentGroup) {\n                var ellipse = new _graphic_shape_Ellipse_js__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .A();\n                inheritStyle(parentGroup, ellipse);\n                parseAttributes(xmlNode, ellipse, this._defsUsePending, false, false);\n                ellipse.setShape({\n                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n                    rx: parseFloat(xmlNode.getAttribute('rx') || '0'),\n                    ry: parseFloat(xmlNode.getAttribute('ry') || '0')\n                });\n                ellipse.silent = true;\n                return ellipse;\n            },\n            'polygon': function (xmlNode, parentGroup) {\n                var pointsStr = xmlNode.getAttribute('points');\n                var pointsArr;\n                if (pointsStr) {\n                    pointsArr = parsePoints(pointsStr);\n                }\n                var polygon = new _graphic_shape_Polygon_js__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .A({\n                    shape: {\n                        points: pointsArr || []\n                    },\n                    silent: true\n                });\n                inheritStyle(parentGroup, polygon);\n                parseAttributes(xmlNode, polygon, this._defsUsePending, false, false);\n                return polygon;\n            },\n            'polyline': function (xmlNode, parentGroup) {\n                var pointsStr = xmlNode.getAttribute('points');\n                var pointsArr;\n                if (pointsStr) {\n                    pointsArr = parsePoints(pointsStr);\n                }\n                var polyline = new _graphic_shape_Polyline_js__WEBPACK_IMPORTED_MODULE_9__/* [\"default\"] */ .A({\n                    shape: {\n                        points: pointsArr || []\n                    },\n                    silent: true\n                });\n                inheritStyle(parentGroup, polyline);\n                parseAttributes(xmlNode, polyline, this._defsUsePending, false, false);\n                return polyline;\n            },\n            'image': function (xmlNode, parentGroup) {\n                var img = new _graphic_Image_js__WEBPACK_IMPORTED_MODULE_10__/* [\"default\"] */ .Ay();\n                inheritStyle(parentGroup, img);\n                parseAttributes(xmlNode, img, this._defsUsePending, false, false);\n                img.setStyle({\n                    image: xmlNode.getAttribute('xlink:href') || xmlNode.getAttribute('href'),\n                    x: +xmlNode.getAttribute('x'),\n                    y: +xmlNode.getAttribute('y'),\n                    width: +xmlNode.getAttribute('width'),\n                    height: +xmlNode.getAttribute('height')\n                });\n                img.silent = true;\n                return img;\n            },\n            'text': function (xmlNode, parentGroup) {\n                var x = xmlNode.getAttribute('x') || '0';\n                var y = xmlNode.getAttribute('y') || '0';\n                var dx = xmlNode.getAttribute('dx') || '0';\n                var dy = xmlNode.getAttribute('dy') || '0';\n                this._textX = parseFloat(x) + parseFloat(dx);\n                this._textY = parseFloat(y) + parseFloat(dy);\n                var g = new _graphic_Group_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defsUsePending, false, true);\n                return g;\n            },\n            'tspan': function (xmlNode, parentGroup) {\n                var x = xmlNode.getAttribute('x');\n                var y = xmlNode.getAttribute('y');\n                if (x != null) {\n                    this._textX = parseFloat(x);\n                }\n                if (y != null) {\n                    this._textY = parseFloat(y);\n                }\n                var dx = xmlNode.getAttribute('dx') || '0';\n                var dy = xmlNode.getAttribute('dy') || '0';\n                var g = new _graphic_Group_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defsUsePending, false, true);\n                this._textX += parseFloat(dx);\n                this._textY += parseFloat(dy);\n                return g;\n            },\n            'path': function (xmlNode, parentGroup) {\n                var d = xmlNode.getAttribute('d') || '';\n                var path = (0,_path_js__WEBPACK_IMPORTED_MODULE_11__/* .createFromString */ .UJ)(d);\n                inheritStyle(parentGroup, path);\n                parseAttributes(xmlNode, path, this._defsUsePending, false, false);\n                path.silent = true;\n                return path;\n            }\n        };\n    })();\n    return SVGParser;\n}());\nvar paintServerParsers = {\n    'lineargradient': function (xmlNode) {\n        var x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10);\n        var y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10);\n        var x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10);\n        var y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10);\n        var gradient = new _graphic_LinearGradient_js__WEBPACK_IMPORTED_MODULE_12__/* [\"default\"] */ .A(x1, y1, x2, y2);\n        parsePaintServerUnit(xmlNode, gradient);\n        parseGradientColorStops(xmlNode, gradient);\n        return gradient;\n    },\n    'radialgradient': function (xmlNode) {\n        var cx = parseInt(xmlNode.getAttribute('cx') || '0', 10);\n        var cy = parseInt(xmlNode.getAttribute('cy') || '0', 10);\n        var r = parseInt(xmlNode.getAttribute('r') || '0', 10);\n        var gradient = new _graphic_RadialGradient_js__WEBPACK_IMPORTED_MODULE_13__/* [\"default\"] */ .A(cx, cy, r);\n        parsePaintServerUnit(xmlNode, gradient);\n        parseGradientColorStops(xmlNode, gradient);\n        return gradient;\n    }\n};\nfunction parsePaintServerUnit(xmlNode, gradient) {\n    var gradientUnits = xmlNode.getAttribute('gradientUnits');\n    if (gradientUnits === 'userSpaceOnUse') {\n        gradient.global = true;\n    }\n}\nfunction parseGradientColorStops(xmlNode, gradient) {\n    var stop = xmlNode.firstChild;\n    while (stop) {\n        if (stop.nodeType === 1\n            && stop.nodeName.toLocaleLowerCase() === 'stop') {\n            var offsetStr = stop.getAttribute('offset');\n            var offset = void 0;\n            if (offsetStr && offsetStr.indexOf('%') > 0) {\n                offset = parseInt(offsetStr, 10) / 100;\n            }\n            else if (offsetStr) {\n                offset = parseFloat(offsetStr);\n            }\n            else {\n                offset = 0;\n            }\n            var styleVals = {};\n            parseInlineStyle(stop, styleVals, styleVals);\n            var stopColor = styleVals.stopColor\n                || stop.getAttribute('stop-color')\n                || '#000000';\n            gradient.colorStops.push({\n                offset: offset,\n                color: stopColor\n            });\n        }\n        stop = stop.nextSibling;\n    }\n}\nfunction inheritStyle(parent, child) {\n    if (parent && parent.__inheritedStyle) {\n        if (!child.__inheritedStyle) {\n            child.__inheritedStyle = {};\n        }\n        (0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.defaults)(child.__inheritedStyle, parent.__inheritedStyle);\n    }\n}\nfunction parsePoints(pointsString) {\n    var list = splitNumberSequence(pointsString);\n    var points = [];\n    for (var i = 0; i < list.length; i += 2) {\n        var x = parseFloat(list[i]);\n        var y = parseFloat(list[i + 1]);\n        points.push([x, y]);\n    }\n    return points;\n}\nfunction parseAttributes(xmlNode, el, defsUsePending, onlyInlineStyle, isTextGroup) {\n    var disp = el;\n    var inheritedStyle = disp.__inheritedStyle = disp.__inheritedStyle || {};\n    var selfStyle = {};\n    if (xmlNode.nodeType === 1) {\n        parseTransformAttribute(xmlNode, el);\n        parseInlineStyle(xmlNode, inheritedStyle, selfStyle);\n        if (!onlyInlineStyle) {\n            parseAttributeStyle(xmlNode, inheritedStyle, selfStyle);\n        }\n    }\n    disp.style = disp.style || {};\n    if (inheritedStyle.fill != null) {\n        disp.style.fill = getFillStrokeStyle(disp, 'fill', inheritedStyle.fill, defsUsePending);\n    }\n    if (inheritedStyle.stroke != null) {\n        disp.style.stroke = getFillStrokeStyle(disp, 'stroke', inheritedStyle.stroke, defsUsePending);\n    }\n    (0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)([\n        'lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'\n    ], function (propName) {\n        if (inheritedStyle[propName] != null) {\n            disp.style[propName] = parseFloat(inheritedStyle[propName]);\n        }\n    });\n    (0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)([\n        'lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign'\n    ], function (propName) {\n        if (inheritedStyle[propName] != null) {\n            disp.style[propName] = inheritedStyle[propName];\n        }\n    });\n    if (isTextGroup) {\n        disp.__selfStyle = selfStyle;\n    }\n    if (inheritedStyle.lineDash) {\n        disp.style.lineDash = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)(splitNumberSequence(inheritedStyle.lineDash), function (str) {\n            return parseFloat(str);\n        });\n    }\n    if (inheritedStyle.visibility === 'hidden' || inheritedStyle.visibility === 'collapse') {\n        disp.invisible = true;\n    }\n    if (inheritedStyle.display === 'none') {\n        disp.ignore = true;\n    }\n}\nfunction applyTextAlignment(text, parentGroup) {\n    var parentSelfStyle = parentGroup.__selfStyle;\n    if (parentSelfStyle) {\n        var textBaseline = parentSelfStyle.textBaseline;\n        var zrTextBaseline = textBaseline;\n        if (!textBaseline || textBaseline === 'auto') {\n            zrTextBaseline = 'alphabetic';\n        }\n        else if (textBaseline === 'baseline') {\n            zrTextBaseline = 'alphabetic';\n        }\n        else if (textBaseline === 'before-edge' || textBaseline === 'text-before-edge') {\n            zrTextBaseline = 'top';\n        }\n        else if (textBaseline === 'after-edge' || textBaseline === 'text-after-edge') {\n            zrTextBaseline = 'bottom';\n        }\n        else if (textBaseline === 'central' || textBaseline === 'mathematical') {\n            zrTextBaseline = 'middle';\n        }\n        text.style.textBaseline = zrTextBaseline;\n    }\n    var parentInheritedStyle = parentGroup.__inheritedStyle;\n    if (parentInheritedStyle) {\n        var textAlign = parentInheritedStyle.textAlign;\n        var zrTextAlign = textAlign;\n        if (textAlign) {\n            if (textAlign === 'middle') {\n                zrTextAlign = 'center';\n            }\n            text.style.textAlign = zrTextAlign;\n        }\n    }\n}\nvar urlRegex = /^url\\(\\s*#(.*?)\\)/;\nfunction getFillStrokeStyle(el, method, str, defsUsePending) {\n    var urlMatch = str && str.match(urlRegex);\n    if (urlMatch) {\n        var url = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.trim)(urlMatch[1]);\n        defsUsePending.push([el, method, url]);\n        return;\n    }\n    if (str === 'none') {\n        str = null;\n    }\n    return str;\n}\nfunction applyDefs(defs, defsUsePending) {\n    for (var i = 0; i < defsUsePending.length; i++) {\n        var item = defsUsePending[i];\n        item[0].style[item[1]] = defs[item[2]];\n    }\n}\nvar numberReg = /-?([0-9]*\\.)?[0-9]+([eE]-?[0-9]+)?/g;\nfunction splitNumberSequence(rawStr) {\n    return rawStr.match(numberReg) || [];\n}\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.eE,]*)\\)/g;\nvar DEGREE_TO_ANGLE = Math.PI / 180;\nfunction parseTransformAttribute(xmlNode, node) {\n    var transform = xmlNode.getAttribute('transform');\n    if (transform) {\n        transform = transform.replace(/,/g, ' ');\n        var transformOps_1 = [];\n        var mt = null;\n        transform.replace(transformRegex, function (str, type, value) {\n            transformOps_1.push(type, value);\n            return '';\n        });\n        for (var i = transformOps_1.length - 1; i > 0; i -= 2) {\n            var value = transformOps_1[i];\n            var type = transformOps_1[i - 1];\n            var valueArr = splitNumberSequence(value);\n            mt = mt || _core_matrix_js__WEBPACK_IMPORTED_MODULE_14__.create();\n            switch (type) {\n                case 'translate':\n                    _core_matrix_js__WEBPACK_IMPORTED_MODULE_14__.translate(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')]);\n                    break;\n                case 'scale':\n                    _core_matrix_js__WEBPACK_IMPORTED_MODULE_14__.scale(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);\n                    break;\n                case 'rotate':\n                    _core_matrix_js__WEBPACK_IMPORTED_MODULE_14__.rotate(mt, mt, -parseFloat(valueArr[0]) * DEGREE_TO_ANGLE, [\n                        parseFloat(valueArr[1] || '0'),\n                        parseFloat(valueArr[2] || '0')\n                    ]);\n                    break;\n                case 'skewX':\n                    var sx = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);\n                    _core_matrix_js__WEBPACK_IMPORTED_MODULE_14__.mul(mt, [1, 0, sx, 1, 0, 0], mt);\n                    break;\n                case 'skewY':\n                    var sy = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);\n                    _core_matrix_js__WEBPACK_IMPORTED_MODULE_14__.mul(mt, [1, sy, 0, 1, 0, 0], mt);\n                    break;\n                case 'matrix':\n                    mt[0] = parseFloat(valueArr[0]);\n                    mt[1] = parseFloat(valueArr[1]);\n                    mt[2] = parseFloat(valueArr[2]);\n                    mt[3] = parseFloat(valueArr[3]);\n                    mt[4] = parseFloat(valueArr[4]);\n                    mt[5] = parseFloat(valueArr[5]);\n                    break;\n            }\n        }\n        node.setLocalTransform(mt);\n    }\n}\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\nfunction parseInlineStyle(xmlNode, inheritableStyleResult, selfStyleResult) {\n    var style = xmlNode.getAttribute('style');\n    if (!style) {\n        return;\n    }\n    styleRegex.lastIndex = 0;\n    var styleRegResult;\n    while ((styleRegResult = styleRegex.exec(style)) != null) {\n        var svgStlAttr = styleRegResult[1];\n        var zrInheritableStlAttr = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(INHERITABLE_STYLE_ATTRIBUTES_MAP, svgStlAttr)\n            ? INHERITABLE_STYLE_ATTRIBUTES_MAP[svgStlAttr]\n            : null;\n        if (zrInheritableStlAttr) {\n            inheritableStyleResult[zrInheritableStlAttr] = styleRegResult[2];\n        }\n        var zrSelfStlAttr = (0,_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(SELF_STYLE_ATTRIBUTES_MAP, svgStlAttr)\n            ? SELF_STYLE_ATTRIBUTES_MAP[svgStlAttr]\n            : null;\n        if (zrSelfStlAttr) {\n            selfStyleResult[zrSelfStlAttr] = styleRegResult[2];\n        }\n    }\n}\nfunction parseAttributeStyle(xmlNode, inheritableStyleResult, selfStyleResult) {\n    for (var i = 0; i < INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {\n        var svgAttrName = INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS[i];\n        var attrValue = xmlNode.getAttribute(svgAttrName);\n        if (attrValue != null) {\n            inheritableStyleResult[INHERITABLE_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;\n        }\n    }\n    for (var i = 0; i < SELF_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {\n        var svgAttrName = SELF_STYLE_ATTRIBUTES_MAP_KEYS[i];\n        var attrValue = xmlNode.getAttribute(svgAttrName);\n        if (attrValue != null) {\n            selfStyleResult[SELF_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;\n        }\n    }\n}\nfunction makeViewBoxTransform(viewBoxRect, boundingRect) {\n    var scaleX = boundingRect.width / viewBoxRect.width;\n    var scaleY = boundingRect.height / viewBoxRect.height;\n    var scale = Math.min(scaleX, scaleY);\n    return {\n        scale: scale,\n        x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + (boundingRect.x + boundingRect.width / 2),\n        y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + (boundingRect.y + boundingRect.height / 2)\n    };\n}\nfunction parseSVG(xml, opt) {\n    var parser = new SVGParser();\n    return parser.parse(xml, opt);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk5NDIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi90b29sL3BhcnNlU1ZHLmpzPzNlYWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdyb3VwIGZyb20gJy4uL2dyYXBoaWMvR3JvdXAuanMnO1xuaW1wb3J0IFpSSW1hZ2UgZnJvbSAnLi4vZ3JhcGhpYy9JbWFnZS5qcyc7XG5pbXBvcnQgQ2lyY2xlIGZyb20gJy4uL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzJztcbmltcG9ydCBSZWN0IGZyb20gJy4uL2dyYXBoaWMvc2hhcGUvUmVjdC5qcyc7XG5pbXBvcnQgRWxsaXBzZSBmcm9tICcuLi9ncmFwaGljL3NoYXBlL0VsbGlwc2UuanMnO1xuaW1wb3J0IExpbmUgZnJvbSAnLi4vZ3JhcGhpYy9zaGFwZS9MaW5lLmpzJztcbmltcG9ydCBQb2x5Z29uIGZyb20gJy4uL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qcyc7XG5pbXBvcnQgUG9seWxpbmUgZnJvbSAnLi4vZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qcyc7XG5pbXBvcnQgKiBhcyBtYXRyaXggZnJvbSAnLi4vY29yZS9tYXRyaXguanMnO1xuaW1wb3J0IHsgY3JlYXRlRnJvbVN0cmluZyB9IGZyb20gJy4vcGF0aC5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0cywgdHJpbSwgZWFjaCwgbWFwLCBrZXlzLCBoYXNPd24gfSBmcm9tICcuLi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IExpbmVhckdyYWRpZW50IGZyb20gJy4uL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanMnO1xuaW1wb3J0IFJhZGlhbEdyYWRpZW50IGZyb20gJy4uL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQuanMnO1xuaW1wb3J0IFRTcGFuIGZyb20gJy4uL2dyYXBoaWMvVFNwYW4uanMnO1xuaW1wb3J0IHsgcGFyc2VYTUwgfSBmcm9tICcuL3BhcnNlWE1MLmpzJztcbjtcbnZhciBub2RlUGFyc2VycztcbnZhciBJTkhFUklUQUJMRV9TVFlMRV9BVFRSSUJVVEVTX01BUCA9IHtcbiAgICAnZmlsbCc6ICdmaWxsJyxcbiAgICAnc3Ryb2tlJzogJ3N0cm9rZScsXG4gICAgJ3N0cm9rZS13aWR0aCc6ICdsaW5lV2lkdGgnLFxuICAgICdvcGFjaXR5JzogJ29wYWNpdHknLFxuICAgICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICAgICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdsaW5lRGFzaCcsXG4gICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ2xpbmVEYXNoT2Zmc2V0JyxcbiAgICAnc3Ryb2tlLWxpbmVjYXAnOiAnbGluZUNhcCcsXG4gICAgJ3N0cm9rZS1saW5lam9pbic6ICdsaW5lSm9pbicsXG4gICAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ21pdGVyTGltaXQnLFxuICAgICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICAgICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgICAndGV4dC1hbmNob3InOiAndGV4dEFsaWduJyxcbiAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmlsaXR5JyxcbiAgICAnZGlzcGxheSc6ICdkaXNwbGF5J1xufTtcbnZhciBJTkhFUklUQUJMRV9TVFlMRV9BVFRSSUJVVEVTX01BUF9LRVlTID0ga2V5cyhJTkhFUklUQUJMRV9TVFlMRV9BVFRSSUJVVEVTX01BUCk7XG52YXIgU0VMRl9TVFlMRV9BVFRSSUJVVEVTX01BUCA9IHtcbiAgICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ3RleHRCYXNlbGluZScsXG4gICAgJ3N0b3AtY29sb3InOiAnc3RvcENvbG9yJ1xufTtcbnZhciBTRUxGX1NUWUxFX0FUVFJJQlVURVNfTUFQX0tFWVMgPSBrZXlzKFNFTEZfU1RZTEVfQVRUUklCVVRFU19NQVApO1xudmFyIFNWR1BhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU1ZHUGFyc2VyKCkge1xuICAgICAgICB0aGlzLl9kZWZzID0ge307XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIH1cbiAgICBTVkdQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHhtbCwgb3B0KSB7XG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHN2ZyA9IHBhcnNlWE1MKHhtbCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoIXN2Zykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBzdmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWZzVXNlUGVuZGluZyA9IFtdO1xuICAgICAgICB2YXIgcm9vdCA9IG5ldyBHcm91cCgpO1xuICAgICAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICAgICAgdmFyIG5hbWVkID0gW107XG4gICAgICAgIHZhciB2aWV3Qm94ID0gc3ZnLmdldEF0dHJpYnV0ZSgndmlld0JveCcpIHx8ICcnO1xuICAgICAgICB2YXIgd2lkdGggPSBwYXJzZUZsb2F0KChzdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpIHx8IG9wdC53aWR0aCkpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VGbG9hdCgoc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgfHwgb3B0LmhlaWdodCkpO1xuICAgICAgICBpc05hTih3aWR0aCkgJiYgKHdpZHRoID0gbnVsbCk7XG4gICAgICAgIGlzTmFOKGhlaWdodCkgJiYgKGhlaWdodCA9IG51bGwpO1xuICAgICAgICBwYXJzZUF0dHJpYnV0ZXMoc3ZnLCByb290LCBudWxsLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHZhciBjaGlsZCA9IHN2Zy5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlTm9kZShjaGlsZCwgcm9vdCwgbmFtZWQsIG51bGwsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGFwcGx5RGVmcyh0aGlzLl9kZWZzLCB0aGlzLl9kZWZzVXNlUGVuZGluZyk7XG4gICAgICAgIHRoaXMuX2RlZnNVc2VQZW5kaW5nID0gW107XG4gICAgICAgIHZhciB2aWV3Qm94UmVjdDtcbiAgICAgICAgdmFyIHZpZXdCb3hUcmFuc2Zvcm07XG4gICAgICAgIGlmICh2aWV3Qm94KSB7XG4gICAgICAgICAgICB2YXIgdmlld0JveEFyciA9IHNwbGl0TnVtYmVyU2VxdWVuY2Uodmlld0JveCk7XG4gICAgICAgICAgICBpZiAodmlld0JveEFyci5sZW5ndGggPj0gNCkge1xuICAgICAgICAgICAgICAgIHZpZXdCb3hSZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBwYXJzZUZsb2F0KCh2aWV3Qm94QXJyWzBdIHx8IDApKSxcbiAgICAgICAgICAgICAgICAgICAgeTogcGFyc2VGbG9hdCgodmlld0JveEFyclsxXSB8fCAwKSksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJzZUZsb2F0KHZpZXdCb3hBcnJbMl0pLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHBhcnNlRmxvYXQodmlld0JveEFyclszXSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2aWV3Qm94UmVjdCAmJiB3aWR0aCAhPSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3Qm94VHJhbnNmb3JtID0gbWFrZVZpZXdCb3hUcmFuc2Zvcm0odmlld0JveFJlY3QsIHsgeDogMCwgeTogMCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICAgICAgICAgIGlmICghb3B0Lmlnbm9yZVZpZXdCb3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxSb290ID0gcm9vdDtcbiAgICAgICAgICAgICAgICByb290ID0gbmV3IEdyb3VwKCk7XG4gICAgICAgICAgICAgICAgcm9vdC5hZGQoZWxSb290KTtcbiAgICAgICAgICAgICAgICBlbFJvb3Quc2NhbGVYID0gZWxSb290LnNjYWxlWSA9IHZpZXdCb3hUcmFuc2Zvcm0uc2NhbGU7XG4gICAgICAgICAgICAgICAgZWxSb290LnggPSB2aWV3Qm94VHJhbnNmb3JtLng7XG4gICAgICAgICAgICAgICAgZWxSb290LnkgPSB2aWV3Qm94VHJhbnNmb3JtLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHQuaWdub3JlUm9vdENsaXAgJiYgd2lkdGggIT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcm9vdC5zZXRDbGlwUGF0aChuZXcgUmVjdCh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHsgeDogMCwgeTogMCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHZpZXdCb3hSZWN0OiB2aWV3Qm94UmVjdCxcbiAgICAgICAgICAgIHZpZXdCb3hUcmFuc2Zvcm06IHZpZXdCb3hUcmFuc2Zvcm0sXG4gICAgICAgICAgICBuYW1lZDogbmFtZWRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFNWR1BhcnNlci5wcm90b3R5cGUuX3BhcnNlTm9kZSA9IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCwgbmFtZWQsIG5hbWVkRnJvbSwgaXNJbkRlZnMsIGlzSW5UZXh0KSB7XG4gICAgICAgIHZhciBub2RlTmFtZSA9IHhtbE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGVsO1xuICAgICAgICB2YXIgbmFtZWRGcm9tRm9yU3ViID0gbmFtZWRGcm9tO1xuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdkZWZzJykge1xuICAgICAgICAgICAgaXNJbkRlZnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBpc0luVGV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnZGVmcycgfHwgbm9kZU5hbWUgPT09ICdzd2l0Y2gnKSB7XG4gICAgICAgICAgICBlbCA9IHBhcmVudEdyb3VwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc0luRGVmcykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZXJfMSA9IG5vZGVQYXJzZXJzW25vZGVOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyXzEgJiYgaGFzT3duKG5vZGVQYXJzZXJzLCBub2RlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBwYXJzZXJfMS5jYWxsKHRoaXMsIHhtbE5vZGUsIHBhcmVudEdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVBdHRyID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TmFtZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZUF0dHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZWRGcm9tOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2Z05vZGVUYWdMb3dlcjogbm9kZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWw6IGVsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZWQucHVzaChuZXdOYW1lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVkRnJvbUZvclN1YiA9IG5ld05hbWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWVkRnJvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZWRGcm9tLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZWRGcm9tOiBuYW1lZEZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnTm9kZVRhZ0xvd2VyOiBub2RlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbDogZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEdyb3VwLmFkZChlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcnNlciA9IHBhaW50U2VydmVyUGFyc2Vyc1tub2RlTmFtZV07XG4gICAgICAgICAgICBpZiAocGFyc2VyICYmIGhhc093bihwYWludFNlcnZlclBhcnNlcnMsIG5vZGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWYgPSBwYXJzZXIuY2FsbCh0aGlzLCB4bWxOb2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmc1tpZF0gPSBkZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbCAmJiBlbC5pc0dyb3VwKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB4bWxOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VOb2RlKGNoaWxkLCBlbCwgbmFtZWQsIG5hbWVkRnJvbUZvclN1YiwgaXNJbkRlZnMsIGlzSW5UZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDMgJiYgaXNJblRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VUZXh0KGNoaWxkLCBlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNWR1BhcnNlci5wcm90b3R5cGUuX3BhcnNlVGV4dCA9IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgICAgICB2YXIgdGV4dCA9IG5ldyBUU3Bhbih7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHRleHQ6IHhtbE5vZGUudGV4dENvbnRlbnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICB4OiB0aGlzLl90ZXh0WCB8fCAwLFxuICAgICAgICAgICAgeTogdGhpcy5fdGV4dFkgfHwgMFxuICAgICAgICB9KTtcbiAgICAgICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCB0ZXh0KTtcbiAgICAgICAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIHRleHQsIHRoaXMuX2RlZnNVc2VQZW5kaW5nLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBhcHBseVRleHRBbGlnbm1lbnQodGV4dCwgcGFyZW50R3JvdXApO1xuICAgICAgICB2YXIgdGV4dFN0eWxlID0gdGV4dC5zdHlsZTtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gdGV4dFN0eWxlLmZvbnRTaXplO1xuICAgICAgICBpZiAoZm9udFNpemUgJiYgZm9udFNpemUgPCA5KSB7XG4gICAgICAgICAgICB0ZXh0U3R5bGUuZm9udFNpemUgPSA5O1xuICAgICAgICAgICAgdGV4dC5zY2FsZVggKj0gZm9udFNpemUgLyA5O1xuICAgICAgICAgICAgdGV4dC5zY2FsZVkgKj0gZm9udFNpemUgLyA5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb250ID0gKHRleHRTdHlsZS5mb250U2l6ZSB8fCB0ZXh0U3R5bGUuZm9udEZhbWlseSkgJiYgW1xuICAgICAgICAgICAgdGV4dFN0eWxlLmZvbnRTdHlsZSxcbiAgICAgICAgICAgIHRleHRTdHlsZS5mb250V2VpZ2h0LFxuICAgICAgICAgICAgKHRleHRTdHlsZS5mb250U2l6ZSB8fCAxMikgKyAncHgnLFxuICAgICAgICAgICAgdGV4dFN0eWxlLmZvbnRGYW1pbHkgfHwgJ3NhbnMtc2VyaWYnXG4gICAgICAgIF0uam9pbignICcpO1xuICAgICAgICB0ZXh0U3R5bGUuZm9udCA9IGZvbnQ7XG4gICAgICAgIHZhciByZWN0ID0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgdGhpcy5fdGV4dFggKz0gcmVjdC53aWR0aDtcbiAgICAgICAgcGFyZW50R3JvdXAuYWRkKHRleHQpO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIFNWR1BhcnNlci5pbnRlcm5hbEZpZWxkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbm9kZVBhcnNlcnMgPSB7XG4gICAgICAgICAgICAnZyc6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBnKTtcbiAgICAgICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgZywgdGhpcy5fZGVmc1VzZVBlbmRpbmcsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3JlY3QnOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0KCk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCByZWN0KTtcbiAgICAgICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgcmVjdCwgdGhpcy5fZGVmc1VzZVBlbmRpbmcsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmVjdC5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgICAgIHg6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gnKSB8fCAnMCcpLFxuICAgICAgICAgICAgICAgICAgICB5OiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd5JykgfHwgJzAnKSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgJzAnKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnMCcpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVjdC5zaWxlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdjaXJjbGUnOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2lyY2xlID0gbmV3IENpcmNsZSgpO1xuICAgICAgICAgICAgICAgIGluaGVyaXRTdHlsZShwYXJlbnRHcm91cCwgY2lyY2xlKTtcbiAgICAgICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgY2lyY2xlLCB0aGlzLl9kZWZzVXNlUGVuZGluZywgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjaXJjbGUuc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgICAgICBjeDogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgnY3gnKSB8fCAnMCcpLFxuICAgICAgICAgICAgICAgICAgICBjeTogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgnY3knKSB8fCAnMCcpLFxuICAgICAgICAgICAgICAgICAgICByOiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdyJykgfHwgJzAnKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNpcmNsZS5zaWxlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2xpbmUnOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IG5ldyBMaW5lKCk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBsaW5lKTtcbiAgICAgICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgbGluZSwgdGhpcy5fZGVmc1VzZVBlbmRpbmcsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgbGluZS5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgICAgIHgxOiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd4MScpIHx8ICcwJyksXG4gICAgICAgICAgICAgICAgICAgIHkxOiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd5MScpIHx8ICcwJyksXG4gICAgICAgICAgICAgICAgICAgIHgyOiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd4MicpIHx8ICcwJyksXG4gICAgICAgICAgICAgICAgICAgIHkyOiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd5MicpIHx8ICcwJylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsaW5lLnNpbGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2VsbGlwc2UnOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxsaXBzZSA9IG5ldyBFbGxpcHNlKCk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBlbGxpcHNlKTtcbiAgICAgICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgZWxsaXBzZSwgdGhpcy5fZGVmc1VzZVBlbmRpbmcsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZWxsaXBzZS5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgICAgIGN4OiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICcwJyksXG4gICAgICAgICAgICAgICAgICAgIGN5OiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdjeScpIHx8ICcwJyksXG4gICAgICAgICAgICAgICAgICAgIHJ4OiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdyeCcpIHx8ICcwJyksXG4gICAgICAgICAgICAgICAgICAgIHJ5OiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdyeScpIHx8ICcwJylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbGxpcHNlLnNpbGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsbGlwc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3BvbHlnb24nOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzU3RyID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpO1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHNBcnI7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50c1N0cikge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNBcnIgPSBwYXJzZVBvaW50cyhwb2ludHNTdHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uKHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzQXJyIHx8IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGluaGVyaXRTdHlsZShwYXJlbnRHcm91cCwgcG9seWdvbik7XG4gICAgICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIHBvbHlnb24sIHRoaXMuX2RlZnNVc2VQZW5kaW5nLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwb2x5bGluZSc6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHNTdHIgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgncG9pbnRzJyk7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50c0FycjtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c0FyciA9IHBhcnNlUG9pbnRzKHBvaW50c1N0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwb2x5bGluZSA9IG5ldyBQb2x5bGluZSh7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50c0FyciB8fCBbXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbmhlcml0U3R5bGUocGFyZW50R3JvdXAsIHBvbHlsaW5lKTtcbiAgICAgICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgcG9seWxpbmUsIHRoaXMuX2RlZnNVc2VQZW5kaW5nLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2x5bGluZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnaW1hZ2UnOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IFpSSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICBpbmhlcml0U3R5bGUocGFyZW50R3JvdXAsIGltZyk7XG4gICAgICAgICAgICAgICAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIGltZywgdGhpcy5fZGVmc1VzZVBlbmRpbmcsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaW1nLnNldFN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJykgfHwgeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSxcbiAgICAgICAgICAgICAgICAgICAgeDogK3htbE5vZGUuZ2V0QXR0cmlidXRlKCd4JyksXG4gICAgICAgICAgICAgICAgICAgIHk6ICt4bWxOb2RlLmdldEF0dHJpYnV0ZSgneScpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogK3htbE5vZGUuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICt4bWxOb2RlLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbWcuc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd0ZXh0JzogZnVuY3Rpb24gKHhtbE5vZGUsIHBhcmVudEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgneCcpIHx8ICcwJztcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd5JykgfHwgJzAnO1xuICAgICAgICAgICAgICAgIHZhciBkeCA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdkeCcpIHx8ICcwJztcbiAgICAgICAgICAgICAgICB2YXIgZHkgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgnZHknKSB8fCAnMCc7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dFggPSBwYXJzZUZsb2F0KHgpICsgcGFyc2VGbG9hdChkeCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dFkgPSBwYXJzZUZsb2F0KHkpICsgcGFyc2VGbG9hdChkeSk7XG4gICAgICAgICAgICAgICAgdmFyIGcgPSBuZXcgR3JvdXAoKTtcbiAgICAgICAgICAgICAgICBpbmhlcml0U3R5bGUocGFyZW50R3JvdXAsIGcpO1xuICAgICAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlcyh4bWxOb2RlLCBnLCB0aGlzLl9kZWZzVXNlUGVuZGluZywgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd0c3Bhbic6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0WCA9IHBhcnNlRmxvYXQoeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFkgPSBwYXJzZUZsb2F0KHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZHggPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgnZHgnKSB8fCAnMCc7XG4gICAgICAgICAgICAgICAgdmFyIGR5ID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ2R5JykgfHwgJzAnO1xuICAgICAgICAgICAgICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBnKTtcbiAgICAgICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgZywgdGhpcy5fZGVmc1VzZVBlbmRpbmcsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0WCArPSBwYXJzZUZsb2F0KGR4KTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0WSArPSBwYXJzZUZsb2F0KGR5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncGF0aCc6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBkID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ2QnKSB8fCAnJztcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IGNyZWF0ZUZyb21TdHJpbmcoZCk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBwYXRoKTtcbiAgICAgICAgICAgICAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgcGF0aCwgdGhpcy5fZGVmc1VzZVBlbmRpbmcsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcGF0aC5zaWxlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIFNWR1BhcnNlcjtcbn0oKSk7XG52YXIgcGFpbnRTZXJ2ZXJQYXJzZXJzID0ge1xuICAgICdsaW5lYXJncmFkaWVudCc6IGZ1bmN0aW9uICh4bWxOb2RlKSB7XG4gICAgICAgIHZhciB4MSA9IHBhcnNlSW50KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd4MScpIHx8ICcwJywgMTApO1xuICAgICAgICB2YXIgeTEgPSBwYXJzZUludCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgneTEnKSB8fCAnMCcsIDEwKTtcbiAgICAgICAgdmFyIHgyID0gcGFyc2VJbnQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gyJykgfHwgJzEwJywgMTApO1xuICAgICAgICB2YXIgeTIgPSBwYXJzZUludCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgneTInKSB8fCAnMCcsIDEwKTtcbiAgICAgICAgdmFyIGdyYWRpZW50ID0gbmV3IExpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgcGFyc2VQYWludFNlcnZlclVuaXQoeG1sTm9kZSwgZ3JhZGllbnQpO1xuICAgICAgICBwYXJzZUdyYWRpZW50Q29sb3JTdG9wcyh4bWxOb2RlLCBncmFkaWVudCk7XG4gICAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9LFxuICAgICdyYWRpYWxncmFkaWVudCc6IGZ1bmN0aW9uICh4bWxOb2RlKSB7XG4gICAgICAgIHZhciBjeCA9IHBhcnNlSW50KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICcwJywgMTApO1xuICAgICAgICB2YXIgY3kgPSBwYXJzZUludCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgnY3knKSB8fCAnMCcsIDEwKTtcbiAgICAgICAgdmFyIHIgPSBwYXJzZUludCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgncicpIHx8ICcwJywgMTApO1xuICAgICAgICB2YXIgZ3JhZGllbnQgPSBuZXcgUmFkaWFsR3JhZGllbnQoY3gsIGN5LCByKTtcbiAgICAgICAgcGFyc2VQYWludFNlcnZlclVuaXQoeG1sTm9kZSwgZ3JhZGllbnQpO1xuICAgICAgICBwYXJzZUdyYWRpZW50Q29sb3JTdG9wcyh4bWxOb2RlLCBncmFkaWVudCk7XG4gICAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG59O1xuZnVuY3Rpb24gcGFyc2VQYWludFNlcnZlclVuaXQoeG1sTm9kZSwgZ3JhZGllbnQpIHtcbiAgICB2YXIgZ3JhZGllbnRVbml0cyA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJyk7XG4gICAgaWYgKGdyYWRpZW50VW5pdHMgPT09ICd1c2VyU3BhY2VPblVzZScpIHtcbiAgICAgICAgZ3JhZGllbnQuZ2xvYmFsID0gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUdyYWRpZW50Q29sb3JTdG9wcyh4bWxOb2RlLCBncmFkaWVudCkge1xuICAgIHZhciBzdG9wID0geG1sTm9kZS5maXJzdENoaWxkO1xuICAgIHdoaWxlIChzdG9wKSB7XG4gICAgICAgIGlmIChzdG9wLm5vZGVUeXBlID09PSAxXG4gICAgICAgICAgICAmJiBzdG9wLm5vZGVOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09ICdzdG9wJykge1xuICAgICAgICAgICAgdmFyIG9mZnNldFN0ciA9IHN0b3AuZ2V0QXR0cmlidXRlKCdvZmZzZXQnKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0U3RyICYmIG9mZnNldFN0ci5pbmRleE9mKCclJykgPiAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcGFyc2VJbnQob2Zmc2V0U3RyLCAxMCkgLyAxMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvZmZzZXRTdHIpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KG9mZnNldFN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0eWxlVmFscyA9IHt9O1xuICAgICAgICAgICAgcGFyc2VJbmxpbmVTdHlsZShzdG9wLCBzdHlsZVZhbHMsIHN0eWxlVmFscyk7XG4gICAgICAgICAgICB2YXIgc3RvcENvbG9yID0gc3R5bGVWYWxzLnN0b3BDb2xvclxuICAgICAgICAgICAgICAgIHx8IHN0b3AuZ2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJylcbiAgICAgICAgICAgICAgICB8fCAnIzAwMDAwMCc7XG4gICAgICAgICAgICBncmFkaWVudC5jb2xvclN0b3BzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgIGNvbG9yOiBzdG9wQ29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0b3AgPSBzdG9wLm5leHRTaWJsaW5nO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluaGVyaXRTdHlsZShwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuX19pbmhlcml0ZWRTdHlsZSkge1xuICAgICAgICBpZiAoIWNoaWxkLl9faW5oZXJpdGVkU3R5bGUpIHtcbiAgICAgICAgICAgIGNoaWxkLl9faW5oZXJpdGVkU3R5bGUgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0cyhjaGlsZC5fX2luaGVyaXRlZFN0eWxlLCBwYXJlbnQuX19pbmhlcml0ZWRTdHlsZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VQb2ludHMocG9pbnRzU3RyaW5nKSB7XG4gICAgdmFyIGxpc3QgPSBzcGxpdE51bWJlclNlcXVlbmNlKHBvaW50c1N0cmluZyk7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIgeCA9IHBhcnNlRmxvYXQobGlzdFtpXSk7XG4gICAgICAgIHZhciB5ID0gcGFyc2VGbG9hdChsaXN0W2kgKyAxXSk7XG4gICAgICAgIHBvaW50cy5wdXNoKFt4LCB5XSk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG59XG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgZWwsIGRlZnNVc2VQZW5kaW5nLCBvbmx5SW5saW5lU3R5bGUsIGlzVGV4dEdyb3VwKSB7XG4gICAgdmFyIGRpc3AgPSBlbDtcbiAgICB2YXIgaW5oZXJpdGVkU3R5bGUgPSBkaXNwLl9faW5oZXJpdGVkU3R5bGUgPSBkaXNwLl9faW5oZXJpdGVkU3R5bGUgfHwge307XG4gICAgdmFyIHNlbGZTdHlsZSA9IHt9O1xuICAgIGlmICh4bWxOb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIHBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKHhtbE5vZGUsIGVsKTtcbiAgICAgICAgcGFyc2VJbmxpbmVTdHlsZSh4bWxOb2RlLCBpbmhlcml0ZWRTdHlsZSwgc2VsZlN0eWxlKTtcbiAgICAgICAgaWYgKCFvbmx5SW5saW5lU3R5bGUpIHtcbiAgICAgICAgICAgIHBhcnNlQXR0cmlidXRlU3R5bGUoeG1sTm9kZSwgaW5oZXJpdGVkU3R5bGUsIHNlbGZTdHlsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcC5zdHlsZSA9IGRpc3Auc3R5bGUgfHwge307XG4gICAgaWYgKGluaGVyaXRlZFN0eWxlLmZpbGwgIT0gbnVsbCkge1xuICAgICAgICBkaXNwLnN0eWxlLmZpbGwgPSBnZXRGaWxsU3Ryb2tlU3R5bGUoZGlzcCwgJ2ZpbGwnLCBpbmhlcml0ZWRTdHlsZS5maWxsLCBkZWZzVXNlUGVuZGluZyk7XG4gICAgfVxuICAgIGlmIChpbmhlcml0ZWRTdHlsZS5zdHJva2UgIT0gbnVsbCkge1xuICAgICAgICBkaXNwLnN0eWxlLnN0cm9rZSA9IGdldEZpbGxTdHJva2VTdHlsZShkaXNwLCAnc3Ryb2tlJywgaW5oZXJpdGVkU3R5bGUuc3Ryb2tlLCBkZWZzVXNlUGVuZGluZyk7XG4gICAgfVxuICAgIGVhY2goW1xuICAgICAgICAnbGluZVdpZHRoJywgJ29wYWNpdHknLCAnZmlsbE9wYWNpdHknLCAnc3Ryb2tlT3BhY2l0eScsICdtaXRlckxpbWl0JywgJ2ZvbnRTaXplJ1xuICAgIF0sIGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICBpZiAoaW5oZXJpdGVkU3R5bGVbcHJvcE5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRpc3Auc3R5bGVbcHJvcE5hbWVdID0gcGFyc2VGbG9hdChpbmhlcml0ZWRTdHlsZVtwcm9wTmFtZV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZWFjaChbXG4gICAgICAgICdsaW5lRGFzaE9mZnNldCcsICdsaW5lQ2FwJywgJ2xpbmVKb2luJywgJ2ZvbnRXZWlnaHQnLCAnZm9udEZhbWlseScsICdmb250U3R5bGUnLCAndGV4dEFsaWduJ1xuICAgIF0sIGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICBpZiAoaW5oZXJpdGVkU3R5bGVbcHJvcE5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRpc3Auc3R5bGVbcHJvcE5hbWVdID0gaW5oZXJpdGVkU3R5bGVbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGlzVGV4dEdyb3VwKSB7XG4gICAgICAgIGRpc3AuX19zZWxmU3R5bGUgPSBzZWxmU3R5bGU7XG4gICAgfVxuICAgIGlmIChpbmhlcml0ZWRTdHlsZS5saW5lRGFzaCkge1xuICAgICAgICBkaXNwLnN0eWxlLmxpbmVEYXNoID0gbWFwKHNwbGl0TnVtYmVyU2VxdWVuY2UoaW5oZXJpdGVkU3R5bGUubGluZURhc2gpLCBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluaGVyaXRlZFN0eWxlLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nIHx8IGluaGVyaXRlZFN0eWxlLnZpc2liaWxpdHkgPT09ICdjb2xsYXBzZScpIHtcbiAgICAgICAgZGlzcC5pbnZpc2libGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW5oZXJpdGVkU3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIGRpc3AuaWdub3JlID0gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseVRleHRBbGlnbm1lbnQodGV4dCwgcGFyZW50R3JvdXApIHtcbiAgICB2YXIgcGFyZW50U2VsZlN0eWxlID0gcGFyZW50R3JvdXAuX19zZWxmU3R5bGU7XG4gICAgaWYgKHBhcmVudFNlbGZTdHlsZSkge1xuICAgICAgICB2YXIgdGV4dEJhc2VsaW5lID0gcGFyZW50U2VsZlN0eWxlLnRleHRCYXNlbGluZTtcbiAgICAgICAgdmFyIHpyVGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgICAgICBpZiAoIXRleHRCYXNlbGluZSB8fCB0ZXh0QmFzZWxpbmUgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgenJUZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dEJhc2VsaW5lID09PSAnYmFzZWxpbmUnKSB7XG4gICAgICAgICAgICB6clRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdiZWZvcmUtZWRnZScgfHwgdGV4dEJhc2VsaW5lID09PSAndGV4dC1iZWZvcmUtZWRnZScpIHtcbiAgICAgICAgICAgIHpyVGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dEJhc2VsaW5lID09PSAnYWZ0ZXItZWRnZScgfHwgdGV4dEJhc2VsaW5lID09PSAndGV4dC1hZnRlci1lZGdlJykge1xuICAgICAgICAgICAgenJUZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdjZW50cmFsJyB8fCB0ZXh0QmFzZWxpbmUgPT09ICdtYXRoZW1hdGljYWwnKSB7XG4gICAgICAgICAgICB6clRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICB9XG4gICAgICAgIHRleHQuc3R5bGUudGV4dEJhc2VsaW5lID0genJUZXh0QmFzZWxpbmU7XG4gICAgfVxuICAgIHZhciBwYXJlbnRJbmhlcml0ZWRTdHlsZSA9IHBhcmVudEdyb3VwLl9faW5oZXJpdGVkU3R5bGU7XG4gICAgaWYgKHBhcmVudEluaGVyaXRlZFN0eWxlKSB7XG4gICAgICAgIHZhciB0ZXh0QWxpZ24gPSBwYXJlbnRJbmhlcml0ZWRTdHlsZS50ZXh0QWxpZ247XG4gICAgICAgIHZhciB6clRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgICAgaWYgKHRleHRBbGlnbikge1xuICAgICAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgICAgICB6clRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dC5zdHlsZS50ZXh0QWxpZ24gPSB6clRleHRBbGlnbjtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciB1cmxSZWdleCA9IC9edXJsXFwoXFxzKiMoLio/KVxcKS87XG5mdW5jdGlvbiBnZXRGaWxsU3Ryb2tlU3R5bGUoZWwsIG1ldGhvZCwgc3RyLCBkZWZzVXNlUGVuZGluZykge1xuICAgIHZhciB1cmxNYXRjaCA9IHN0ciAmJiBzdHIubWF0Y2godXJsUmVnZXgpO1xuICAgIGlmICh1cmxNYXRjaCkge1xuICAgICAgICB2YXIgdXJsID0gdHJpbSh1cmxNYXRjaFsxXSk7XG4gICAgICAgIGRlZnNVc2VQZW5kaW5nLnB1c2goW2VsLCBtZXRob2QsIHVybF0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdHIgPT09ICdub25lJykge1xuICAgICAgICBzdHIgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gYXBwbHlEZWZzKGRlZnMsIGRlZnNVc2VQZW5kaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZzVXNlUGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IGRlZnNVc2VQZW5kaW5nW2ldO1xuICAgICAgICBpdGVtWzBdLnN0eWxlW2l0ZW1bMV1dID0gZGVmc1tpdGVtWzJdXTtcbiAgICB9XG59XG52YXIgbnVtYmVyUmVnID0gLy0/KFswLTldKlxcLik/WzAtOV0rKFtlRV0tP1swLTldKyk/L2c7XG5mdW5jdGlvbiBzcGxpdE51bWJlclNlcXVlbmNlKHJhd1N0cikge1xuICAgIHJldHVybiByYXdTdHIubWF0Y2gobnVtYmVyUmVnKSB8fCBbXTtcbn1cbnZhciB0cmFuc2Zvcm1SZWdleCA9IC8odHJhbnNsYXRlfHNjYWxlfHJvdGF0ZXxza2V3WHxza2V3WXxtYXRyaXgpXFwoKFtcXC1cXHMwLTlcXC5lRSxdKilcXCkvZztcbnZhciBERUdSRUVfVE9fQU5HTEUgPSBNYXRoLlBJIC8gMTgwO1xuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUoeG1sTm9kZSwgbm9kZSkge1xuICAgIHZhciB0cmFuc2Zvcm0gPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm0ucmVwbGFjZSgvLC9nLCAnICcpO1xuICAgICAgICB2YXIgdHJhbnNmb3JtT3BzXzEgPSBbXTtcbiAgICAgICAgdmFyIG10ID0gbnVsbDtcbiAgICAgICAgdHJhbnNmb3JtLnJlcGxhY2UodHJhbnNmb3JtUmVnZXgsIGZ1bmN0aW9uIChzdHIsIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1PcHNfMS5wdXNoKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIGkgPSB0cmFuc2Zvcm1PcHNfMS5sZW5ndGggLSAxOyBpID4gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1PcHNfMVtpXTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHJhbnNmb3JtT3BzXzFbaSAtIDFdO1xuICAgICAgICAgICAgdmFyIHZhbHVlQXJyID0gc3BsaXROdW1iZXJTZXF1ZW5jZSh2YWx1ZSk7XG4gICAgICAgICAgICBtdCA9IG10IHx8IG1hdHJpeC5jcmVhdGUoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zbGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGUobXQsIG10LCBbcGFyc2VGbG9hdCh2YWx1ZUFyclswXSksIHBhcnNlRmxvYXQodmFsdWVBcnJbMV0gfHwgJzAnKV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zY2FsZShtdCwgbXQsIFtwYXJzZUZsb2F0KHZhbHVlQXJyWzBdKSwgcGFyc2VGbG9hdCh2YWx1ZUFyclsxXSB8fCB2YWx1ZUFyclswXSldKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnJvdGF0ZShtdCwgbXQsIC1wYXJzZUZsb2F0KHZhbHVlQXJyWzBdKSAqIERFR1JFRV9UT19BTkdMRSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdCh2YWx1ZUFyclsxXSB8fCAnMCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdCh2YWx1ZUFyclsyXSB8fCAnMCcpXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdza2V3WCc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IE1hdGgudGFuKHBhcnNlRmxvYXQodmFsdWVBcnJbMF0pICogREVHUkVFX1RPX0FOR0xFKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4Lm11bChtdCwgWzEsIDAsIHN4LCAxLCAwLCAwXSwgbXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdza2V3WSc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeSA9IE1hdGgudGFuKHBhcnNlRmxvYXQodmFsdWVBcnJbMF0pICogREVHUkVFX1RPX0FOR0xFKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4Lm11bChtdCwgWzEsIHN5LCAwLCAxLCAwLCAwXSwgbXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtYXRyaXgnOlxuICAgICAgICAgICAgICAgICAgICBtdFswXSA9IHBhcnNlRmxvYXQodmFsdWVBcnJbMF0pO1xuICAgICAgICAgICAgICAgICAgICBtdFsxXSA9IHBhcnNlRmxvYXQodmFsdWVBcnJbMV0pO1xuICAgICAgICAgICAgICAgICAgICBtdFsyXSA9IHBhcnNlRmxvYXQodmFsdWVBcnJbMl0pO1xuICAgICAgICAgICAgICAgICAgICBtdFszXSA9IHBhcnNlRmxvYXQodmFsdWVBcnJbM10pO1xuICAgICAgICAgICAgICAgICAgICBtdFs0XSA9IHBhcnNlRmxvYXQodmFsdWVBcnJbNF0pO1xuICAgICAgICAgICAgICAgICAgICBtdFs1XSA9IHBhcnNlRmxvYXQodmFsdWVBcnJbNV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldExvY2FsVHJhbnNmb3JtKG10KTtcbiAgICB9XG59XG52YXIgc3R5bGVSZWdleCA9IC8oW15cXHM6O10rKVxccyo6XFxzKihbXjo7XSspL2c7XG5mdW5jdGlvbiBwYXJzZUlubGluZVN0eWxlKHhtbE5vZGUsIGluaGVyaXRhYmxlU3R5bGVSZXN1bHQsIHNlbGZTdHlsZVJlc3VsdCkge1xuICAgIHZhciBzdHlsZSA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdHlsZVJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIHN0eWxlUmVnUmVzdWx0O1xuICAgIHdoaWxlICgoc3R5bGVSZWdSZXN1bHQgPSBzdHlsZVJlZ2V4LmV4ZWMoc3R5bGUpKSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBzdmdTdGxBdHRyID0gc3R5bGVSZWdSZXN1bHRbMV07XG4gICAgICAgIHZhciB6ckluaGVyaXRhYmxlU3RsQXR0ciA9IGhhc093bihJTkhFUklUQUJMRV9TVFlMRV9BVFRSSUJVVEVTX01BUCwgc3ZnU3RsQXR0cilcbiAgICAgICAgICAgID8gSU5IRVJJVEFCTEVfU1RZTEVfQVRUUklCVVRFU19NQVBbc3ZnU3RsQXR0cl1cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgaWYgKHpySW5oZXJpdGFibGVTdGxBdHRyKSB7XG4gICAgICAgICAgICBpbmhlcml0YWJsZVN0eWxlUmVzdWx0W3pySW5oZXJpdGFibGVTdGxBdHRyXSA9IHN0eWxlUmVnUmVzdWx0WzJdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB6clNlbGZTdGxBdHRyID0gaGFzT3duKFNFTEZfU1RZTEVfQVRUUklCVVRFU19NQVAsIHN2Z1N0bEF0dHIpXG4gICAgICAgICAgICA/IFNFTEZfU1RZTEVfQVRUUklCVVRFU19NQVBbc3ZnU3RsQXR0cl1cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgaWYgKHpyU2VsZlN0bEF0dHIpIHtcbiAgICAgICAgICAgIHNlbGZTdHlsZVJlc3VsdFt6clNlbGZTdGxBdHRyXSA9IHN0eWxlUmVnUmVzdWx0WzJdO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVTdHlsZSh4bWxOb2RlLCBpbmhlcml0YWJsZVN0eWxlUmVzdWx0LCBzZWxmU3R5bGVSZXN1bHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IElOSEVSSVRBQkxFX1NUWUxFX0FUVFJJQlVURVNfTUFQX0tFWVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN2Z0F0dHJOYW1lID0gSU5IRVJJVEFCTEVfU1RZTEVfQVRUUklCVVRFU19NQVBfS0VZU1tpXTtcbiAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKHN2Z0F0dHJOYW1lKTtcbiAgICAgICAgaWYgKGF0dHJWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbmhlcml0YWJsZVN0eWxlUmVzdWx0W0lOSEVSSVRBQkxFX1NUWUxFX0FUVFJJQlVURVNfTUFQW3N2Z0F0dHJOYW1lXV0gPSBhdHRyVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTRUxGX1NUWUxFX0FUVFJJQlVURVNfTUFQX0tFWVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN2Z0F0dHJOYW1lID0gU0VMRl9TVFlMRV9BVFRSSUJVVEVTX01BUF9LRVlTW2ldO1xuICAgICAgICB2YXIgYXR0clZhbHVlID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoc3ZnQXR0ck5hbWUpO1xuICAgICAgICBpZiAoYXR0clZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNlbGZTdHlsZVJlc3VsdFtTRUxGX1NUWUxFX0FUVFJJQlVURVNfTUFQW3N2Z0F0dHJOYW1lXV0gPSBhdHRyVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVZpZXdCb3hUcmFuc2Zvcm0odmlld0JveFJlY3QsIGJvdW5kaW5nUmVjdCkge1xuICAgIHZhciBzY2FsZVggPSBib3VuZGluZ1JlY3Qud2lkdGggLyB2aWV3Qm94UmVjdC53aWR0aDtcbiAgICB2YXIgc2NhbGVZID0gYm91bmRpbmdSZWN0LmhlaWdodCAvIHZpZXdCb3hSZWN0LmhlaWdodDtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICB4OiAtKHZpZXdCb3hSZWN0LnggKyB2aWV3Qm94UmVjdC53aWR0aCAvIDIpICogc2NhbGUgKyAoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGggLyAyKSxcbiAgICAgICAgeTogLSh2aWV3Qm94UmVjdC55ICsgdmlld0JveFJlY3QuaGVpZ2h0IC8gMikgKiBzY2FsZSArIChib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyKVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTVkcoeG1sLCBvcHQpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IFNWR1BhcnNlcigpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2UoeG1sLCBvcHQpO1xufVxuZXhwb3J0IHsgcGFyc2VYTUwgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///69942\n")},97850:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Gw: () => (/* binding */ combineMorph),\n  AN: () => (/* binding */ isCombineMorphing),\n  mz: () => (/* binding */ morphPath),\n  AG: () => (/* binding */ separateMorph)\n});\n\n// UNUSED EXPORTS: alignBezierCurves, centroid, defaultDividePath, isMorphing\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/curve.js\nvar curve = __webpack_require__(89259);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Path.js\nvar Path = __webpack_require__(59482);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/vector.js\nvar vector = __webpack_require__(83509);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/tool/path.js + 1 modules\nvar tool_path = __webpack_require__(59442);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/Transformable.js\nvar Transformable = __webpack_require__(92836);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/bbox.js\nvar bbox = __webpack_require__(48813);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/BoundingRect.js\nvar BoundingRect = __webpack_require__(29308);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/Point.js\nvar Point = __webpack_require__(26346);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polygon.js\nvar Polygon = __webpack_require__(52505);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Sector.js + 1 modules\nvar Sector = __webpack_require__(25014);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/PathProxy.js\nvar PathProxy = __webpack_require__(68717);\n;// ./node_modules/zrender/lib/tool/convertPath.js\n\n\nvar CMD = PathProxy/* default */.A.CMD;\nfunction aroundEqual(a, b) {\n    return Math.abs(a - b) < 1e-5;\n}\nfunction pathToBezierCurves(path) {\n    var data = path.data;\n    var len = path.len();\n    var bezierArrayGroups = [];\n    var currentSubpath;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n    function createNewSubpath(x, y) {\n        if (currentSubpath && currentSubpath.length > 2) {\n            bezierArrayGroups.push(currentSubpath);\n        }\n        currentSubpath = [x, y];\n    }\n    function addLine(x0, y0, x1, y1) {\n        if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n            currentSubpath.push(x0, y0, x1, y1, x1, y1);\n        }\n    }\n    function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n        var delta = Math.abs(endAngle - startAngle);\n        var len = Math.tan(delta / 4) * 4 / 3;\n        var dir = endAngle < startAngle ? -1 : 1;\n        var c1 = Math.cos(startAngle);\n        var s1 = Math.sin(startAngle);\n        var c2 = Math.cos(endAngle);\n        var s2 = Math.sin(endAngle);\n        var x1 = c1 * rx + cx;\n        var y1 = s1 * ry + cy;\n        var x4 = c2 * rx + cx;\n        var y4 = s2 * ry + cy;\n        var hx = rx * len * dir;\n        var hy = ry * len * dir;\n        currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n    }\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    for (var i = 0; i < len;) {\n        var cmd = data[i++];\n        var isFirst = i === 1;\n        if (isFirst) {\n            xi = data[i];\n            yi = data[i + 1];\n            x0 = xi;\n            y0 = yi;\n            if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n                currentSubpath = [x0, y0];\n            }\n        }\n        switch (cmd) {\n            case CMD.M:\n                xi = x0 = data[i++];\n                yi = y0 = data[i++];\n                createNewSubpath(x0, y0);\n                break;\n            case CMD.L:\n                x1 = data[i++];\n                y1 = data[i++];\n                addLine(xi, yi, x1, y1);\n                xi = x1;\n                yi = y1;\n                break;\n            case CMD.C:\n                currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n                break;\n            case CMD.Q:\n                x1 = data[i++];\n                y1 = data[i++];\n                x2 = data[i++];\n                y2 = data[i++];\n                currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n                xi = x2;\n                yi = y2;\n                break;\n            case CMD.A:\n                var cx = data[i++];\n                var cy = data[i++];\n                var rx = data[i++];\n                var ry = data[i++];\n                var startAngle = data[i++];\n                var endAngle = data[i++] + startAngle;\n                i += 1;\n                var anticlockwise = !data[i++];\n                x1 = Math.cos(startAngle) * rx + cx;\n                y1 = Math.sin(startAngle) * ry + cy;\n                if (isFirst) {\n                    x0 = x1;\n                    y0 = y1;\n                    createNewSubpath(x0, y0);\n                }\n                else {\n                    addLine(xi, yi, x1, y1);\n                }\n                xi = Math.cos(endAngle) * rx + cx;\n                yi = Math.sin(endAngle) * ry + cy;\n                var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n                for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n                    var nextAngle = anticlockwise ? Math.max(angle + step, endAngle)\n                        : Math.min(angle + step, endAngle);\n                    addArc(angle, nextAngle, cx, cy, rx, ry);\n                }\n                break;\n            case CMD.R:\n                x0 = xi = data[i++];\n                y0 = yi = data[i++];\n                x1 = x0 + data[i++];\n                y1 = y0 + data[i++];\n                createNewSubpath(x1, y0);\n                addLine(x1, y0, x1, y1);\n                addLine(x1, y1, x0, y1);\n                addLine(x0, y1, x0, y0);\n                addLine(x0, y0, x1, y0);\n                break;\n            case CMD.Z:\n                currentSubpath && addLine(xi, yi, x0, y0);\n                xi = x0;\n                yi = y0;\n                break;\n        }\n    }\n    if (currentSubpath && currentSubpath.length > 2) {\n        bezierArrayGroups.push(currentSubpath);\n    }\n    return bezierArrayGroups;\n}\nfunction adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, out, scale) {\n    if (aroundEqual(x0, x1) && aroundEqual(y0, y1) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {\n        out.push(x3, y3);\n        return;\n    }\n    var PIXEL_DISTANCE = 2 / scale;\n    var PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE;\n    var dx = x3 - x0;\n    var dy = y3 - y0;\n    var d = Math.sqrt(dx * dx + dy * dy);\n    dx /= d;\n    dy /= d;\n    var dx1 = x1 - x0;\n    var dy1 = y1 - y0;\n    var dx2 = x2 - x3;\n    var dy2 = y2 - y3;\n    var cp1LenSqr = dx1 * dx1 + dy1 * dy1;\n    var cp2LenSqr = dx2 * dx2 + dy2 * dy2;\n    if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {\n        out.push(x3, y3);\n        return;\n    }\n    var projLen1 = dx * dx1 + dy * dy1;\n    var projLen2 = -dx * dx2 - dy * dy2;\n    var d1Sqr = cp1LenSqr - projLen1 * projLen1;\n    var d2Sqr = cp2LenSqr - projLen2 * projLen2;\n    if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0\n        && d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {\n        out.push(x3, y3);\n        return;\n    }\n    var tmpSegX = [];\n    var tmpSegY = [];\n    (0,curve/* cubicSubdivide */.YT)(x0, x1, x2, x3, 0.5, tmpSegX);\n    (0,curve/* cubicSubdivide */.YT)(y0, y1, y2, y3, 0.5, tmpSegY);\n    adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out, scale);\n    adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out, scale);\n}\nfunction pathToPolygons(path, scale) {\n    var bezierArrayGroups = pathToBezierCurves(path);\n    var polygons = [];\n    scale = scale || 1;\n    for (var i = 0; i < bezierArrayGroups.length; i++) {\n        var beziers = bezierArrayGroups[i];\n        var polygon = [];\n        var x0 = beziers[0];\n        var y0 = beziers[1];\n        polygon.push(x0, y0);\n        for (var k = 2; k < beziers.length;) {\n            var x1 = beziers[k++];\n            var y1 = beziers[k++];\n            var x2 = beziers[k++];\n            var y2 = beziers[k++];\n            var x3 = beziers[k++];\n            var y3 = beziers[k++];\n            adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, polygon, scale);\n            x0 = x3;\n            y0 = y3;\n        }\n        polygons.push(polygon);\n    }\n    return polygons;\n}\n\n;// ./node_modules/zrender/lib/tool/dividePath.js\n\n\n\n\n\n\n\n\n\nfunction getDividingGrids(dimSize, rowDim, count) {\n    var rowSize = dimSize[rowDim];\n    var columnSize = dimSize[1 - rowDim];\n    var ratio = Math.abs(rowSize / columnSize);\n    var rowCount = Math.ceil(Math.sqrt(ratio * count));\n    var columnCount = Math.floor(count / rowCount);\n    if (columnCount === 0) {\n        columnCount = 1;\n        rowCount = count;\n    }\n    var grids = [];\n    for (var i = 0; i < rowCount; i++) {\n        grids.push(columnCount);\n    }\n    var currentCount = rowCount * columnCount;\n    var remained = count - currentCount;\n    if (remained > 0) {\n        for (var i = 0; i < remained; i++) {\n            grids[i % rowCount] += 1;\n        }\n    }\n    return grids;\n}\nfunction divideSector(sectorShape, count, outShapes) {\n    var r0 = sectorShape.r0;\n    var r = sectorShape.r;\n    var startAngle = sectorShape.startAngle;\n    var endAngle = sectorShape.endAngle;\n    var angle = Math.abs(endAngle - startAngle);\n    var arcLen = angle * r;\n    var deltaR = r - r0;\n    var isAngleRow = arcLen > Math.abs(deltaR);\n    var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count);\n    var rowSize = (isAngleRow ? angle : deltaR) / grids.length;\n    for (var row = 0; row < grids.length; row++) {\n        var columnSize = (isAngleRow ? deltaR : angle) / grids[row];\n        for (var column = 0; column < grids[row]; column++) {\n            var newShape = {};\n            if (isAngleRow) {\n                newShape.startAngle = startAngle + rowSize * row;\n                newShape.endAngle = startAngle + rowSize * (row + 1);\n                newShape.r0 = r0 + columnSize * column;\n                newShape.r = r0 + columnSize * (column + 1);\n            }\n            else {\n                newShape.startAngle = startAngle + columnSize * column;\n                newShape.endAngle = startAngle + columnSize * (column + 1);\n                newShape.r0 = r0 + rowSize * row;\n                newShape.r = r0 + rowSize * (row + 1);\n            }\n            newShape.clockwise = sectorShape.clockwise;\n            newShape.cx = sectorShape.cx;\n            newShape.cy = sectorShape.cy;\n            outShapes.push(newShape);\n        }\n    }\n}\nfunction divideRect(rectShape, count, outShapes) {\n    var width = rectShape.width;\n    var height = rectShape.height;\n    var isHorizontalRow = width > height;\n    var grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count);\n    var rowSizeDim = isHorizontalRow ? 'width' : 'height';\n    var columnSizeDim = isHorizontalRow ? 'height' : 'width';\n    var rowDim = isHorizontalRow ? 'x' : 'y';\n    var columnDim = isHorizontalRow ? 'y' : 'x';\n    var rowSize = rectShape[rowSizeDim] / grids.length;\n    for (var row = 0; row < grids.length; row++) {\n        var columnSize = rectShape[columnSizeDim] / grids[row];\n        for (var column = 0; column < grids[row]; column++) {\n            var newShape = {};\n            newShape[rowDim] = row * rowSize;\n            newShape[columnDim] = column * columnSize;\n            newShape[rowSizeDim] = rowSize;\n            newShape[columnSizeDim] = columnSize;\n            newShape.x += rectShape.x;\n            newShape.y += rectShape.y;\n            outShapes.push(newShape);\n        }\n    }\n}\nfunction crossProduct2d(x1, y1, x2, y2) {\n    return x1 * y2 - x2 * y1;\n}\nfunction lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n    var mx = a2x - a1x;\n    var my = a2y - a1y;\n    var nx = b2x - b1x;\n    var ny = b2y - b1y;\n    var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n    if (Math.abs(nmCrossProduct) < 1e-6) {\n        return null;\n    }\n    var b1a1x = a1x - b1x;\n    var b1a1y = a1y - b1y;\n    var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n    if (p < 0 || p > 1) {\n        return null;\n    }\n    return new Point/* default */.A(p * mx + a1x, p * my + a1y);\n}\nfunction projPtOnLine(pt, lineA, lineB) {\n    var dir = new Point/* default */.A();\n    Point/* default */.A.sub(dir, lineB, lineA);\n    dir.normalize();\n    var dir2 = new Point/* default */.A();\n    Point/* default */.A.sub(dir2, pt, lineA);\n    var len = dir2.dot(dir);\n    return len;\n}\nfunction addToPoly(poly, pt) {\n    var last = poly[poly.length - 1];\n    if (last && last[0] === pt[0] && last[1] === pt[1]) {\n        return;\n    }\n    poly.push(pt);\n}\nfunction splitPolygonByLine(points, lineA, lineB) {\n    var len = points.length;\n    var intersections = [];\n    for (var i = 0; i < len; i++) {\n        var p0 = points[i];\n        var p1 = points[(i + 1) % len];\n        var intersectionPt = lineLineIntersect(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);\n        if (intersectionPt) {\n            intersections.push({\n                projPt: projPtOnLine(intersectionPt, lineA, lineB),\n                pt: intersectionPt,\n                idx: i\n            });\n        }\n    }\n    if (intersections.length < 2) {\n        return [{ points: points }, { points: points }];\n    }\n    intersections.sort(function (a, b) {\n        return a.projPt - b.projPt;\n    });\n    var splitPt0 = intersections[0];\n    var splitPt1 = intersections[intersections.length - 1];\n    if (splitPt1.idx < splitPt0.idx) {\n        var tmp = splitPt0;\n        splitPt0 = splitPt1;\n        splitPt1 = tmp;\n    }\n    var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];\n    var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];\n    var newPolyA = [splitPt0Arr];\n    var newPolyB = [splitPt1Arr];\n    for (var i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {\n        addToPoly(newPolyA, points[i].slice());\n    }\n    addToPoly(newPolyA, splitPt1Arr);\n    addToPoly(newPolyA, splitPt0Arr);\n    for (var i = splitPt1.idx + 1; i <= splitPt0.idx + len; i++) {\n        addToPoly(newPolyB, points[i % len].slice());\n    }\n    addToPoly(newPolyB, splitPt0Arr);\n    addToPoly(newPolyB, splitPt1Arr);\n    return [{\n            points: newPolyA\n        }, {\n            points: newPolyB\n        }];\n}\nfunction binaryDividePolygon(polygonShape) {\n    var points = polygonShape.points;\n    var min = [];\n    var max = [];\n    (0,bbox/* fromPoints */.Cr)(points, min, max);\n    var boundingRect = new BoundingRect/* default */.A(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n    var width = boundingRect.width;\n    var height = boundingRect.height;\n    var x = boundingRect.x;\n    var y = boundingRect.y;\n    var pt0 = new Point/* default */.A();\n    var pt1 = new Point/* default */.A();\n    if (width > height) {\n        pt0.x = pt1.x = x + width / 2;\n        pt0.y = y;\n        pt1.y = y + height;\n    }\n    else {\n        pt0.y = pt1.y = y + height / 2;\n        pt0.x = x;\n        pt1.x = x + width;\n    }\n    return splitPolygonByLine(points, pt0, pt1);\n}\nfunction binaryDivideRecursive(divider, shape, count, out) {\n    if (count === 1) {\n        out.push(shape);\n    }\n    else {\n        var mid = Math.floor(count / 2);\n        var sub = divider(shape);\n        binaryDivideRecursive(divider, sub[0], mid, out);\n        binaryDivideRecursive(divider, sub[1], count - mid, out);\n    }\n    return out;\n}\nfunction clone(path, count) {\n    var paths = [];\n    for (var i = 0; i < count; i++) {\n        paths.push((0,tool_path/* clonePath */.rR)(path));\n    }\n    return paths;\n}\nfunction copyPathProps(source, target) {\n    target.setStyle(source.style);\n    target.z = source.z;\n    target.z2 = source.z2;\n    target.zlevel = source.zlevel;\n}\nfunction polygonConvert(points) {\n    var out = [];\n    for (var i = 0; i < points.length;) {\n        out.push([points[i++], points[i++]]);\n    }\n    return out;\n}\nfunction split(path, count) {\n    var outShapes = [];\n    var shape = path.shape;\n    var OutShapeCtor;\n    switch (path.type) {\n        case 'rect':\n            divideRect(shape, count, outShapes);\n            OutShapeCtor = Rect/* default */.A;\n            break;\n        case 'sector':\n            divideSector(shape, count, outShapes);\n            OutShapeCtor = Sector/* default */.A;\n            break;\n        case 'circle':\n            divideSector({\n                r0: 0, r: shape.r, startAngle: 0, endAngle: Math.PI * 2,\n                cx: shape.cx, cy: shape.cy\n            }, count, outShapes);\n            OutShapeCtor = Sector/* default */.A;\n            break;\n        default:\n            var m = path.getComputedTransform();\n            var scale = m ? Math.sqrt(Math.max(m[0] * m[0] + m[1] * m[1], m[2] * m[2] + m[3] * m[3])) : 1;\n            var polygons = (0,util.map)(pathToPolygons(path.getUpdatedPathProxy(), scale), function (poly) { return polygonConvert(poly); });\n            var polygonCount = polygons.length;\n            if (polygonCount === 0) {\n                binaryDivideRecursive(binaryDividePolygon, {\n                    points: polygons[0]\n                }, count, outShapes);\n            }\n            else if (polygonCount === count) {\n                for (var i = 0; i < polygonCount; i++) {\n                    outShapes.push({\n                        points: polygons[i]\n                    });\n                }\n            }\n            else {\n                var totalArea_1 = 0;\n                var items = (0,util.map)(polygons, function (poly) {\n                    var min = [];\n                    var max = [];\n                    (0,bbox/* fromPoints */.Cr)(poly, min, max);\n                    var area = (max[1] - min[1]) * (max[0] - min[0]);\n                    totalArea_1 += area;\n                    return { poly: poly, area: area };\n                });\n                items.sort(function (a, b) { return b.area - a.area; });\n                var left = count;\n                for (var i = 0; i < polygonCount; i++) {\n                    var item = items[i];\n                    if (left <= 0) {\n                        break;\n                    }\n                    var selfCount = i === polygonCount - 1\n                        ? left\n                        : Math.ceil(item.area / totalArea_1 * count);\n                    if (selfCount < 0) {\n                        continue;\n                    }\n                    binaryDivideRecursive(binaryDividePolygon, {\n                        points: item.poly\n                    }, selfCount, outShapes);\n                    left -= selfCount;\n                }\n                ;\n            }\n            OutShapeCtor = Polygon/* default */.A;\n            break;\n    }\n    if (!OutShapeCtor) {\n        return clone(path, count);\n    }\n    var out = [];\n    for (var i = 0; i < outShapes.length; i++) {\n        var subPath = new OutShapeCtor();\n        subPath.setShape(outShapes[i]);\n        copyPathProps(path, subPath);\n        out.push(subPath);\n    }\n    return out;\n}\n\n;// ./node_modules/zrender/lib/tool/morphPath.js\n\n\n\n\n\n\n\n\nfunction alignSubpath(subpath1, subpath2) {\n    var len1 = subpath1.length;\n    var len2 = subpath2.length;\n    if (len1 === len2) {\n        return [subpath1, subpath2];\n    }\n    var tmpSegX = [];\n    var tmpSegY = [];\n    var shorterPath = len1 < len2 ? subpath1 : subpath2;\n    var shorterLen = Math.min(len1, len2);\n    var diff = Math.abs(len2 - len1) / 6;\n    var shorterBezierCount = (shorterLen - 2) / 6;\n    var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n    var newSubpath = [shorterPath[0], shorterPath[1]];\n    var remained = diff;\n    for (var i = 2; i < shorterLen;) {\n        var x0 = shorterPath[i - 2];\n        var y0 = shorterPath[i - 1];\n        var x1 = shorterPath[i++];\n        var y1 = shorterPath[i++];\n        var x2 = shorterPath[i++];\n        var y2 = shorterPath[i++];\n        var x3 = shorterPath[i++];\n        var y3 = shorterPath[i++];\n        if (remained <= 0) {\n            newSubpath.push(x1, y1, x2, y2, x3, y3);\n            continue;\n        }\n        var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n        for (var k = 1; k <= actualSubDivCount; k++) {\n            var p = k / actualSubDivCount;\n            (0,curve/* cubicSubdivide */.YT)(x0, x1, x2, x3, p, tmpSegX);\n            (0,curve/* cubicSubdivide */.YT)(y0, y1, y2, y3, p, tmpSegY);\n            x0 = tmpSegX[3];\n            y0 = tmpSegY[3];\n            newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n            x1 = tmpSegX[5];\n            y1 = tmpSegY[5];\n            x2 = tmpSegX[6];\n            y2 = tmpSegY[6];\n        }\n        remained -= actualSubDivCount - 1;\n    }\n    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n    var len = lastSubpathSubpath.length;\n    var lastX = lastSubpathSubpath[len - 2];\n    var lastY = lastSubpathSubpath[len - 1];\n    var newSubpath = [];\n    for (var i = 0; i < otherSubpath.length;) {\n        newSubpath[i++] = lastX;\n        newSubpath[i++] = lastY;\n    }\n    return newSubpath;\n}\nfunction alignBezierCurves(array1, array2) {\n    var _a;\n    var lastSubpath1;\n    var lastSubpath2;\n    var newArray1 = [];\n    var newArray2 = [];\n    for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n        var subpath1 = array1[i];\n        var subpath2 = array2[i];\n        var newSubpath1 = void 0;\n        var newSubpath2 = void 0;\n        if (!subpath1) {\n            newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n            newSubpath2 = subpath2;\n        }\n        else if (!subpath2) {\n            newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n            newSubpath1 = subpath1;\n        }\n        else {\n            _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n            lastSubpath1 = newSubpath1;\n            lastSubpath2 = newSubpath2;\n        }\n        newArray1.push(newSubpath1);\n        newArray2.push(newSubpath2);\n    }\n    return [newArray1, newArray2];\n}\nfunction centroid(array) {\n    var signedArea = 0;\n    var cx = 0;\n    var cy = 0;\n    var len = array.length;\n    for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n        var x0 = array[j];\n        var y0 = array[j + 1];\n        var x1 = array[i];\n        var y1 = array[i + 1];\n        var a = x0 * y1 - x1 * y0;\n        signedArea += a;\n        cx += (x0 + x1) * a;\n        cy += (y0 + y1) * a;\n    }\n    if (signedArea === 0) {\n        return [array[0] || 0, array[1] || 0];\n    }\n    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n    var bezierCount = (fromSubBeziers.length - 2) / 6;\n    var bestScore = Infinity;\n    var bestOffset = 0;\n    var len = fromSubBeziers.length;\n    var len2 = len - 2;\n    for (var offset = 0; offset < bezierCount; offset++) {\n        var cursorOffset = offset * 6;\n        var score = 0;\n        for (var k = 0; k < len; k += 2) {\n            var idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2 + 2);\n            var x0 = fromSubBeziers[idx] - fromCp[0];\n            var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n            var x1 = toSubBeziers[k] - toCp[0];\n            var y1 = toSubBeziers[k + 1] - toCp[1];\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            score += dx * dx + dy * dy;\n        }\n        if (score < bestScore) {\n            bestScore = score;\n            bestOffset = offset;\n        }\n    }\n    return bestOffset;\n}\nfunction reverse(array) {\n    var newArr = [];\n    var len = array.length;\n    for (var i = 0; i < len; i += 2) {\n        newArr[i] = array[len - i - 2];\n        newArr[i + 1] = array[len - i - 1];\n    }\n    return newArr;\n}\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n    var result = [];\n    var fromNeedsReverse;\n    for (var i = 0; i < fromArr.length; i++) {\n        var fromSubpathBezier = fromArr[i];\n        var toSubpathBezier = toArr[i];\n        var fromCp = centroid(fromSubpathBezier);\n        var toCp = centroid(toSubpathBezier);\n        if (fromNeedsReverse == null) {\n            fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n        }\n        var newFromSubpathBezier = [];\n        var newToSubpathBezier = [];\n        var bestAngle = 0;\n        var bestScore = Infinity;\n        var tmpArr = [];\n        var len = fromSubpathBezier.length;\n        if (fromNeedsReverse) {\n            fromSubpathBezier = reverse(fromSubpathBezier);\n        }\n        var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n        var len2 = len - 2;\n        for (var k = 0; k < len2; k += 2) {\n            var idx = (offset + k) % len2 + 2;\n            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n            newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n        }\n        newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n        newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n        if (searchAngleIteration > 0) {\n            var step = searchAngleRange / searchAngleIteration;\n            for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                var score = 0;\n                for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n                    var x0 = newFromSubpathBezier[k];\n                    var y0 = newFromSubpathBezier[k + 1];\n                    var x1 = toSubpathBezier[k] - toCp[0];\n                    var y1 = toSubpathBezier[k + 1] - toCp[1];\n                    var newX1 = x1 * ca - y1 * sa;\n                    var newY1 = x1 * sa + y1 * ca;\n                    tmpArr[k] = newX1;\n                    tmpArr[k + 1] = newY1;\n                    var dx = newX1 - x0;\n                    var dy = newY1 - y0;\n                    score += dx * dx + dy * dy;\n                }\n                if (score < bestScore) {\n                    bestScore = score;\n                    bestAngle = angle;\n                    for (var m = 0; m < tmpArr.length; m++) {\n                        newToSubpathBezier[m] = tmpArr[m];\n                    }\n                }\n            }\n        }\n        else {\n            for (var i_1 = 0; i_1 < len; i_1 += 2) {\n                newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n                newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n            }\n        }\n        result.push({\n            from: newFromSubpathBezier,\n            to: newToSubpathBezier,\n            fromCp: fromCp,\n            toCp: toCp,\n            rotation: -bestAngle\n        });\n    }\n    return result;\n}\nfunction isCombineMorphing(path) {\n    return path.__isCombineMorphing;\n}\nfunction isMorphing(el) {\n    return el.__morphT >= 0;\n}\nvar SAVED_METHOD_PREFIX = '__mOriginal_';\nfunction saveAndModifyMethod(obj, methodName, modifiers) {\n    var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n    var originalMethod = obj[savedMethodName] || obj[methodName];\n    if (!obj[savedMethodName]) {\n        obj[savedMethodName] = obj[methodName];\n    }\n    var replace = modifiers.replace;\n    var after = modifiers.after;\n    var before = modifiers.before;\n    obj[methodName] = function () {\n        var args = arguments;\n        var res;\n        before && before.apply(this, args);\n        if (replace) {\n            res = replace.apply(this, args);\n        }\n        else {\n            res = originalMethod.apply(this, args);\n        }\n        after && after.apply(this, args);\n        return res;\n    };\n}\nfunction restoreMethod(obj, methodName) {\n    var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n    if (obj[savedMethodName]) {\n        obj[methodName] = obj[savedMethodName];\n        obj[savedMethodName] = null;\n    }\n}\nfunction applyTransformOnBeziers(bezierCurves, mm) {\n    for (var i = 0; i < bezierCurves.length; i++) {\n        var subBeziers = bezierCurves[i];\n        for (var k = 0; k < subBeziers.length;) {\n            var x = subBeziers[k];\n            var y = subBeziers[k + 1];\n            subBeziers[k++] = mm[0] * x + mm[2] * y + mm[4];\n            subBeziers[k++] = mm[1] * x + mm[3] * y + mm[5];\n        }\n    }\n}\nfunction prepareMorphPath(fromPath, toPath) {\n    var fromPathProxy = fromPath.getUpdatedPathProxy();\n    var toPathProxy = toPath.getUpdatedPathProxy();\n    var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a[0], toBezierCurves = _a[1];\n    var fromPathTransform = fromPath.getComputedTransform();\n    var toPathTransform = toPath.getComputedTransform();\n    function updateIdentityTransform() {\n        this.transform = null;\n    }\n    fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);\n    toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);\n    saveAndModifyMethod(toPath, 'updateTransform', { replace: updateIdentityTransform });\n    toPath.transform = null;\n    var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n    var tmpArr = [];\n    saveAndModifyMethod(toPath, 'buildPath', { replace: function (path) {\n            var t = toPath.__morphT;\n            var onet = 1 - t;\n            var newCp = [];\n            for (var i = 0; i < morphingData.length; i++) {\n                var item = morphingData[i];\n                var from = item.from;\n                var to = item.to;\n                var angle = item.rotation * t;\n                var fromCp = item.fromCp;\n                var toCp = item.toCp;\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                (0,vector.lerp)(newCp, fromCp, toCp, t);\n                for (var m = 0; m < from.length; m += 2) {\n                    var x0_1 = from[m];\n                    var y0_1 = from[m + 1];\n                    var x1 = to[m];\n                    var y1 = to[m + 1];\n                    var x = x0_1 * onet + x1 * t;\n                    var y = y0_1 * onet + y1 * t;\n                    tmpArr[m] = (x * ca - y * sa) + newCp[0];\n                    tmpArr[m + 1] = (x * sa + y * ca) + newCp[1];\n                }\n                var x0 = tmpArr[0];\n                var y0 = tmpArr[1];\n                path.moveTo(x0, y0);\n                for (var m = 2; m < from.length;) {\n                    var x1 = tmpArr[m++];\n                    var y1 = tmpArr[m++];\n                    var x2 = tmpArr[m++];\n                    var y2 = tmpArr[m++];\n                    var x3 = tmpArr[m++];\n                    var y3 = tmpArr[m++];\n                    if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {\n                        path.lineTo(x3, y3);\n                    }\n                    else {\n                        path.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n                    }\n                    x0 = x3;\n                    y0 = y3;\n                }\n            }\n        } });\n}\nfunction morphPath(fromPath, toPath, animationOpts) {\n    if (!fromPath || !toPath) {\n        return toPath;\n    }\n    var oldDone = animationOpts.done;\n    var oldDuring = animationOpts.during;\n    prepareMorphPath(fromPath, toPath);\n    toPath.__morphT = 0;\n    function restoreToPath() {\n        restoreMethod(toPath, 'buildPath');\n        restoreMethod(toPath, 'updateTransform');\n        toPath.__morphT = -1;\n        toPath.createPathProxy();\n        toPath.dirtyShape();\n    }\n    toPath.animateTo({\n        __morphT: 1\n    }, (0,util.defaults)({\n        during: function (p) {\n            toPath.dirtyShape();\n            oldDuring && oldDuring(p);\n        },\n        done: function () {\n            restoreToPath();\n            oldDone && oldDone();\n        }\n    }, animationOpts));\n    return toPath;\n}\nfunction hilbert(x, y, minX, minY, maxX, maxY) {\n    var bits = 16;\n    x = (maxX === minX) ? 0 : Math.round(32767 * (x - minX) / (maxX - minX));\n    y = (maxY === minY) ? 0 : Math.round(32767 * (y - minY) / (maxY - minY));\n    var d = 0;\n    var tmp;\n    for (var s = (1 << bits) / 2; s > 0; s /= 2) {\n        var rx = 0;\n        var ry = 0;\n        if ((x & s) > 0) {\n            rx = 1;\n        }\n        if ((y & s) > 0) {\n            ry = 1;\n        }\n        d += s * s * ((3 * rx) ^ ry);\n        if (ry === 0) {\n            if (rx === 1) {\n                x = s - 1 - x;\n                y = s - 1 - y;\n            }\n            tmp = x;\n            x = y;\n            y = tmp;\n        }\n    }\n    return d;\n}\nfunction sortPaths(pathList) {\n    var xMin = Infinity;\n    var yMin = Infinity;\n    var xMax = -Infinity;\n    var yMax = -Infinity;\n    var cps = (0,util.map)(pathList, function (path) {\n        var rect = path.getBoundingRect();\n        var m = path.getComputedTransform();\n        var x = rect.x + rect.width / 2 + (m ? m[4] : 0);\n        var y = rect.y + rect.height / 2 + (m ? m[5] : 0);\n        xMin = Math.min(x, xMin);\n        yMin = Math.min(y, yMin);\n        xMax = Math.max(x, xMax);\n        yMax = Math.max(y, yMax);\n        return [x, y];\n    });\n    var items = (0,util.map)(cps, function (cp, idx) {\n        return {\n            cp: cp,\n            z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),\n            path: pathList[idx]\n        };\n    });\n    return items.sort(function (a, b) { return a.z - b.z; }).map(function (item) { return item.path; });\n}\n;\nfunction defaultDividePath(param) {\n    return split(param.path, param.count);\n}\nfunction createEmptyReturn() {\n    return {\n        fromIndividuals: [],\n        toIndividuals: [],\n        count: 0\n    };\n}\nfunction combineMorph(fromList, toPath, animationOpts) {\n    var fromPathList = [];\n    function addFromPath(fromList) {\n        for (var i = 0; i < fromList.length; i++) {\n            var from = fromList[i];\n            if (isCombineMorphing(from)) {\n                addFromPath(from.childrenRef());\n            }\n            else if (from instanceof Path/* default */.Ay) {\n                fromPathList.push(from);\n            }\n        }\n    }\n    addFromPath(fromList);\n    var separateCount = fromPathList.length;\n    if (!separateCount) {\n        return createEmptyReturn();\n    }\n    var dividePath = animationOpts.dividePath || defaultDividePath;\n    var toSubPathList = dividePath({\n        path: toPath, count: separateCount\n    });\n    if (toSubPathList.length !== separateCount) {\n        console.error('Invalid morphing: unmatched splitted path');\n        return createEmptyReturn();\n    }\n    fromPathList = sortPaths(fromPathList);\n    toSubPathList = sortPaths(toSubPathList);\n    var oldDone = animationOpts.done;\n    var oldDuring = animationOpts.during;\n    var individualDelay = animationOpts.individualDelay;\n    var identityTransform = new Transformable/* default */.Ay();\n    for (var i = 0; i < separateCount; i++) {\n        var from = fromPathList[i];\n        var to = toSubPathList[i];\n        to.parent = toPath;\n        to.copyTransform(identityTransform);\n        if (!individualDelay) {\n            prepareMorphPath(from, to);\n        }\n    }\n    toPath.__isCombineMorphing = true;\n    toPath.childrenRef = function () {\n        return toSubPathList;\n    };\n    function addToSubPathListToZr(zr) {\n        for (var i = 0; i < toSubPathList.length; i++) {\n            toSubPathList[i].addSelfToZr(zr);\n        }\n    }\n    saveAndModifyMethod(toPath, 'addSelfToZr', {\n        after: function (zr) {\n            addToSubPathListToZr(zr);\n        }\n    });\n    saveAndModifyMethod(toPath, 'removeSelfFromZr', {\n        after: function (zr) {\n            for (var i = 0; i < toSubPathList.length; i++) {\n                toSubPathList[i].removeSelfFromZr(zr);\n            }\n        }\n    });\n    function restoreToPath() {\n        toPath.__isCombineMorphing = false;\n        toPath.__morphT = -1;\n        toPath.childrenRef = null;\n        restoreMethod(toPath, 'addSelfToZr');\n        restoreMethod(toPath, 'removeSelfFromZr');\n    }\n    var toLen = toSubPathList.length;\n    if (individualDelay) {\n        var animating_1 = toLen;\n        var eachDone = function () {\n            animating_1--;\n            if (animating_1 === 0) {\n                restoreToPath();\n                oldDone && oldDone();\n            }\n        };\n        for (var i = 0; i < toLen; i++) {\n            var indivdualAnimationOpts = individualDelay ? (0,util.defaults)({\n                delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),\n                done: eachDone\n            }, animationOpts) : animationOpts;\n            morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts);\n        }\n    }\n    else {\n        toPath.__morphT = 0;\n        toPath.animateTo({\n            __morphT: 1\n        }, (0,util.defaults)({\n            during: function (p) {\n                for (var i = 0; i < toLen; i++) {\n                    var child = toSubPathList[i];\n                    child.__morphT = toPath.__morphT;\n                    child.dirtyShape();\n                }\n                oldDuring && oldDuring(p);\n            },\n            done: function () {\n                restoreToPath();\n                for (var i = 0; i < fromList.length; i++) {\n                    restoreMethod(fromList[i], 'updateTransform');\n                }\n                oldDone && oldDone();\n            }\n        }, animationOpts));\n    }\n    if (toPath.__zr) {\n        addToSubPathListToZr(toPath.__zr);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toSubPathList,\n        count: toLen\n    };\n}\nfunction separateMorph(fromPath, toPathList, animationOpts) {\n    var toLen = toPathList.length;\n    var fromPathList = [];\n    var dividePath = animationOpts.dividePath || defaultDividePath;\n    function addFromPath(fromList) {\n        for (var i = 0; i < fromList.length; i++) {\n            var from = fromList[i];\n            if (isCombineMorphing(from)) {\n                addFromPath(from.childrenRef());\n            }\n            else if (from instanceof Path/* default */.Ay) {\n                fromPathList.push(from);\n            }\n        }\n    }\n    if (isCombineMorphing(fromPath)) {\n        addFromPath(fromPath.childrenRef());\n        var fromLen = fromPathList.length;\n        if (fromLen < toLen) {\n            var k = 0;\n            for (var i = fromLen; i < toLen; i++) {\n                fromPathList.push((0,tool_path/* clonePath */.rR)(fromPathList[k++ % fromLen]));\n            }\n        }\n        fromPathList.length = toLen;\n    }\n    else {\n        fromPathList = dividePath({ path: fromPath, count: toLen });\n        var fromPathTransform = fromPath.getComputedTransform();\n        for (var i = 0; i < fromPathList.length; i++) {\n            fromPathList[i].setLocalTransform(fromPathTransform);\n        }\n        if (fromPathList.length !== toLen) {\n            console.error('Invalid morphing: unmatched splitted path');\n            return createEmptyReturn();\n        }\n    }\n    fromPathList = sortPaths(fromPathList);\n    toPathList = sortPaths(toPathList);\n    var individualDelay = animationOpts.individualDelay;\n    for (var i = 0; i < toLen; i++) {\n        var indivdualAnimationOpts = individualDelay ? (0,util.defaults)({\n            delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])\n        }, animationOpts) : animationOpts;\n        morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toPathList,\n        count: toPathList.length\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTc4NTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvY29udmVydFBhdGguanM/YThhNCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdG9vbC9kaXZpZGVQYXRoLmpzP2YzMDUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvbW9ycGhQYXRoLmpzPzUwMDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3ViaWNTdWJkaXZpZGUgfSBmcm9tICcuLi9jb3JlL2N1cnZlLmpzJztcbmltcG9ydCBQYXRoUHJveHkgZnJvbSAnLi4vY29yZS9QYXRoUHJveHkuanMnO1xudmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG5mdW5jdGlvbiBhcm91bmRFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8IDFlLTU7XG59XG5leHBvcnQgZnVuY3Rpb24gcGF0aFRvQmV6aWVyQ3VydmVzKHBhdGgpIHtcbiAgICB2YXIgZGF0YSA9IHBhdGguZGF0YTtcbiAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICB2YXIgYmV6aWVyQXJyYXlHcm91cHMgPSBbXTtcbiAgICB2YXIgY3VycmVudFN1YnBhdGg7XG4gICAgdmFyIHhpID0gMDtcbiAgICB2YXIgeWkgPSAwO1xuICAgIHZhciB4MCA9IDA7XG4gICAgdmFyIHkwID0gMDtcbiAgICBmdW5jdGlvbiBjcmVhdGVOZXdTdWJwYXRoKHgsIHkpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRTdWJwYXRoICYmIGN1cnJlbnRTdWJwYXRoLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGJlemllckFycmF5R3JvdXBzLnB1c2goY3VycmVudFN1YnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRTdWJwYXRoID0gW3gsIHldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRMaW5lKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIGlmICghKGFyb3VuZEVxdWFsKHgwLCB4MSkgJiYgYXJvdW5kRXF1YWwoeTAsIHkxKSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTdWJwYXRoLnB1c2goeDAsIHkwLCB4MSwgeTEsIHgxLCB5MSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkQXJjKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjeCwgY3ksIHJ4LCByeSkge1xuICAgICAgICB2YXIgZGVsdGEgPSBNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgICAgICB2YXIgbGVuID0gTWF0aC50YW4oZGVsdGEgLyA0KSAqIDQgLyAzO1xuICAgICAgICB2YXIgZGlyID0gZW5kQW5nbGUgPCBzdGFydEFuZ2xlID8gLTEgOiAxO1xuICAgICAgICB2YXIgYzEgPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICAgICAgdmFyIHMxID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgICAgIHZhciBjMiA9IE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgICAgICAgdmFyIHMyID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xuICAgICAgICB2YXIgeDEgPSBjMSAqIHJ4ICsgY3g7XG4gICAgICAgIHZhciB5MSA9IHMxICogcnkgKyBjeTtcbiAgICAgICAgdmFyIHg0ID0gYzIgKiByeCArIGN4O1xuICAgICAgICB2YXIgeTQgPSBzMiAqIHJ5ICsgY3k7XG4gICAgICAgIHZhciBoeCA9IHJ4ICogbGVuICogZGlyO1xuICAgICAgICB2YXIgaHkgPSByeSAqIGxlbiAqIGRpcjtcbiAgICAgICAgY3VycmVudFN1YnBhdGgucHVzaCh4MSAtIGh4ICogczEsIHkxICsgaHkgKiBjMSwgeDQgKyBoeCAqIHMyLCB5NCAtIGh5ICogYzIsIHg0LCB5NCk7XG4gICAgfVxuICAgIHZhciB4MTtcbiAgICB2YXIgeTE7XG4gICAgdmFyIHgyO1xuICAgIHZhciB5MjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgdmFyIGNtZCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGlzRmlyc3QgPSBpID09PSAxO1xuICAgICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIHgwID0geGk7XG4gICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgaWYgKGNtZCA9PT0gQ01ELkwgfHwgY21kID09PSBDTUQuQyB8fCBjbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFN1YnBhdGggPSBbeDAsIHkwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICAgICAgICB4aSA9IHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHlpID0geTAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgY3JlYXRlTmV3U3VicGF0aCh4MCwgeTApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICAgICAgICB4MSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB5MSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICBhZGRMaW5lKHhpLCB5aSwgeDEsIHkxKTtcbiAgICAgICAgICAgICAgICB4aSA9IHgxO1xuICAgICAgICAgICAgICAgIHlpID0geTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdWJwYXRoLnB1c2goZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCB4aSA9IGRhdGFbaSsrXSwgeWkgPSBkYXRhW2krK10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICAgICAgICB4MSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB5MSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB4MiA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB5MiA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3VicGF0aC5wdXNoKHhpICsgMiAvIDMgKiAoeDEgLSB4aSksIHlpICsgMiAvIDMgKiAoeTEgLSB5aSksIHgyICsgMiAvIDMgKiAoeDEgLSB4MiksIHkyICsgMiAvIDMgKiAoeTEgLSB5MiksIHgyLCB5Mik7XG4gICAgICAgICAgICAgICAgeGkgPSB4MjtcbiAgICAgICAgICAgICAgICB5aSA9IHkyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAhZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHgxID0gTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgIHkxID0gTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHgwID0geDE7XG4gICAgICAgICAgICAgICAgICAgIHkwID0geTE7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZU5ld1N1YnBhdGgoeDAsIHkwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZExpbmUoeGksIHlpLCB4MSwgeTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4aSA9IE1hdGguY29zKGVuZEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgeWkgPSBNYXRoLnNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgIHZhciBzdGVwID0gKGFudGljbG9ja3dpc2UgPyAtMSA6IDEpICogTWF0aC5QSSAvIDI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYW5nbGUgPSBzdGFydEFuZ2xlOyBhbnRpY2xvY2t3aXNlID8gYW5nbGUgPiBlbmRBbmdsZSA6IGFuZ2xlIDwgZW5kQW5nbGU7IGFuZ2xlICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRBbmdsZSA9IGFudGljbG9ja3dpc2UgPyBNYXRoLm1heChhbmdsZSArIHN0ZXAsIGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbihhbmdsZSArIHN0ZXAsIGVuZEFuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQXJjKGFuZ2xlLCBuZXh0QW5nbGUsIGN4LCBjeSwgcngsIHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB4MSA9IHgwICsgZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHkxID0geTAgKyBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgY3JlYXRlTmV3U3VicGF0aCh4MSwgeTApO1xuICAgICAgICAgICAgICAgIGFkZExpbmUoeDEsIHkwLCB4MSwgeTEpO1xuICAgICAgICAgICAgICAgIGFkZExpbmUoeDEsIHkxLCB4MCwgeTEpO1xuICAgICAgICAgICAgICAgIGFkZExpbmUoeDAsIHkxLCB4MCwgeTApO1xuICAgICAgICAgICAgICAgIGFkZExpbmUoeDAsIHkwLCB4MSwgeTApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICBjdXJyZW50U3VicGF0aCAmJiBhZGRMaW5lKHhpLCB5aSwgeDAsIHkwKTtcbiAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRTdWJwYXRoICYmIGN1cnJlbnRTdWJwYXRoLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgYmV6aWVyQXJyYXlHcm91cHMucHVzaChjdXJyZW50U3VicGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBiZXppZXJBcnJheUdyb3Vwcztcbn1cbmZ1bmN0aW9uIGFkcGF0aXZlQmV6aWVyKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mywgb3V0LCBzY2FsZSkge1xuICAgIGlmIChhcm91bmRFcXVhbCh4MCwgeDEpICYmIGFyb3VuZEVxdWFsKHkwLCB5MSkgJiYgYXJvdW5kRXF1YWwoeDIsIHgzKSAmJiBhcm91bmRFcXVhbCh5MiwgeTMpKSB7XG4gICAgICAgIG91dC5wdXNoKHgzLCB5Myk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIFBJWEVMX0RJU1RBTkNFID0gMiAvIHNjYWxlO1xuICAgIHZhciBQSVhFTF9ESVNUQU5DRV9TUVIgPSBQSVhFTF9ESVNUQU5DRSAqIFBJWEVMX0RJU1RBTkNFO1xuICAgIHZhciBkeCA9IHgzIC0geDA7XG4gICAgdmFyIGR5ID0geTMgLSB5MDtcbiAgICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgZHggLz0gZDtcbiAgICBkeSAvPSBkO1xuICAgIHZhciBkeDEgPSB4MSAtIHgwO1xuICAgIHZhciBkeTEgPSB5MSAtIHkwO1xuICAgIHZhciBkeDIgPSB4MiAtIHgzO1xuICAgIHZhciBkeTIgPSB5MiAtIHkzO1xuICAgIHZhciBjcDFMZW5TcXIgPSBkeDEgKiBkeDEgKyBkeTEgKiBkeTE7XG4gICAgdmFyIGNwMkxlblNxciA9IGR4MiAqIGR4MiArIGR5MiAqIGR5MjtcbiAgICBpZiAoY3AxTGVuU3FyIDwgUElYRUxfRElTVEFOQ0VfU1FSICYmIGNwMkxlblNxciA8IFBJWEVMX0RJU1RBTkNFX1NRUikge1xuICAgICAgICBvdXQucHVzaCh4MywgeTMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcm9qTGVuMSA9IGR4ICogZHgxICsgZHkgKiBkeTE7XG4gICAgdmFyIHByb2pMZW4yID0gLWR4ICogZHgyIC0gZHkgKiBkeTI7XG4gICAgdmFyIGQxU3FyID0gY3AxTGVuU3FyIC0gcHJvakxlbjEgKiBwcm9qTGVuMTtcbiAgICB2YXIgZDJTcXIgPSBjcDJMZW5TcXIgLSBwcm9qTGVuMiAqIHByb2pMZW4yO1xuICAgIGlmIChkMVNxciA8IFBJWEVMX0RJU1RBTkNFX1NRUiAmJiBwcm9qTGVuMSA+PSAwXG4gICAgICAgICYmIGQyU3FyIDwgUElYRUxfRElTVEFOQ0VfU1FSICYmIHByb2pMZW4yID49IDApIHtcbiAgICAgICAgb3V0LnB1c2goeDMsIHkzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdG1wU2VnWCA9IFtdO1xuICAgIHZhciB0bXBTZWdZID0gW107XG4gICAgY3ViaWNTdWJkaXZpZGUoeDAsIHgxLCB4MiwgeDMsIDAuNSwgdG1wU2VnWCk7XG4gICAgY3ViaWNTdWJkaXZpZGUoeTAsIHkxLCB5MiwgeTMsIDAuNSwgdG1wU2VnWSk7XG4gICAgYWRwYXRpdmVCZXppZXIodG1wU2VnWFswXSwgdG1wU2VnWVswXSwgdG1wU2VnWFsxXSwgdG1wU2VnWVsxXSwgdG1wU2VnWFsyXSwgdG1wU2VnWVsyXSwgdG1wU2VnWFszXSwgdG1wU2VnWVszXSwgb3V0LCBzY2FsZSk7XG4gICAgYWRwYXRpdmVCZXppZXIodG1wU2VnWFs0XSwgdG1wU2VnWVs0XSwgdG1wU2VnWFs1XSwgdG1wU2VnWVs1XSwgdG1wU2VnWFs2XSwgdG1wU2VnWVs2XSwgdG1wU2VnWFs3XSwgdG1wU2VnWVs3XSwgb3V0LCBzY2FsZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGF0aFRvUG9seWdvbnMocGF0aCwgc2NhbGUpIHtcbiAgICB2YXIgYmV6aWVyQXJyYXlHcm91cHMgPSBwYXRoVG9CZXppZXJDdXJ2ZXMocGF0aCk7XG4gICAgdmFyIHBvbHlnb25zID0gW107XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmV6aWVyQXJyYXlHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJlemllcnMgPSBiZXppZXJBcnJheUdyb3Vwc1tpXTtcbiAgICAgICAgdmFyIHBvbHlnb24gPSBbXTtcbiAgICAgICAgdmFyIHgwID0gYmV6aWVyc1swXTtcbiAgICAgICAgdmFyIHkwID0gYmV6aWVyc1sxXTtcbiAgICAgICAgcG9seWdvbi5wdXNoKHgwLCB5MCk7XG4gICAgICAgIGZvciAodmFyIGsgPSAyOyBrIDwgYmV6aWVycy5sZW5ndGg7KSB7XG4gICAgICAgICAgICB2YXIgeDEgPSBiZXppZXJzW2srK107XG4gICAgICAgICAgICB2YXIgeTEgPSBiZXppZXJzW2srK107XG4gICAgICAgICAgICB2YXIgeDIgPSBiZXppZXJzW2srK107XG4gICAgICAgICAgICB2YXIgeTIgPSBiZXppZXJzW2srK107XG4gICAgICAgICAgICB2YXIgeDMgPSBiZXppZXJzW2srK107XG4gICAgICAgICAgICB2YXIgeTMgPSBiZXppZXJzW2srK107XG4gICAgICAgICAgICBhZHBhdGl2ZUJlemllcih4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHBvbHlnb24sIHNjYWxlKTtcbiAgICAgICAgICAgIHgwID0geDM7XG4gICAgICAgICAgICB5MCA9IHkzO1xuICAgICAgICB9XG4gICAgICAgIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG4gICAgfVxuICAgIHJldHVybiBwb2x5Z29ucztcbn1cbiIsImltcG9ydCB7IGZyb21Qb2ludHMgfSBmcm9tICcuLi9jb3JlL2Jib3guanMnO1xuaW1wb3J0IEJvdW5kaW5nUmVjdCBmcm9tICcuLi9jb3JlL0JvdW5kaW5nUmVjdC5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vY29yZS9Qb2ludC5qcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICcuLi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IFBvbHlnb24gZnJvbSAnLi4vZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzJztcbmltcG9ydCBSZWN0IGZyb20gJy4uL2dyYXBoaWMvc2hhcGUvUmVjdC5qcyc7XG5pbXBvcnQgU2VjdG9yIGZyb20gJy4uL2dyYXBoaWMvc2hhcGUvU2VjdG9yLmpzJztcbmltcG9ydCB7IHBhdGhUb1BvbHlnb25zIH0gZnJvbSAnLi9jb252ZXJ0UGF0aC5qcyc7XG5pbXBvcnQgeyBjbG9uZVBhdGggfSBmcm9tICcuL3BhdGguanMnO1xuZnVuY3Rpb24gZ2V0RGl2aWRpbmdHcmlkcyhkaW1TaXplLCByb3dEaW0sIGNvdW50KSB7XG4gICAgdmFyIHJvd1NpemUgPSBkaW1TaXplW3Jvd0RpbV07XG4gICAgdmFyIGNvbHVtblNpemUgPSBkaW1TaXplWzEgLSByb3dEaW1dO1xuICAgIHZhciByYXRpbyA9IE1hdGguYWJzKHJvd1NpemUgLyBjb2x1bW5TaXplKTtcbiAgICB2YXIgcm93Q291bnQgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KHJhdGlvICogY291bnQpKTtcbiAgICB2YXIgY29sdW1uQ291bnQgPSBNYXRoLmZsb29yKGNvdW50IC8gcm93Q291bnQpO1xuICAgIGlmIChjb2x1bW5Db3VudCA9PT0gMCkge1xuICAgICAgICBjb2x1bW5Db3VudCA9IDE7XG4gICAgICAgIHJvd0NvdW50ID0gY291bnQ7XG4gICAgfVxuICAgIHZhciBncmlkcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgICAgICBncmlkcy5wdXNoKGNvbHVtbkNvdW50KTtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRDb3VudCA9IHJvd0NvdW50ICogY29sdW1uQ291bnQ7XG4gICAgdmFyIHJlbWFpbmVkID0gY291bnQgLSBjdXJyZW50Q291bnQ7XG4gICAgaWYgKHJlbWFpbmVkID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbWFpbmVkOyBpKyspIHtcbiAgICAgICAgICAgIGdyaWRzW2kgJSByb3dDb3VudF0gKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JpZHM7XG59XG5mdW5jdGlvbiBkaXZpZGVTZWN0b3Ioc2VjdG9yU2hhcGUsIGNvdW50LCBvdXRTaGFwZXMpIHtcbiAgICB2YXIgcjAgPSBzZWN0b3JTaGFwZS5yMDtcbiAgICB2YXIgciA9IHNlY3RvclNoYXBlLnI7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBzZWN0b3JTaGFwZS5zdGFydEFuZ2xlO1xuICAgIHZhciBlbmRBbmdsZSA9IHNlY3RvclNoYXBlLmVuZEFuZ2xlO1xuICAgIHZhciBhbmdsZSA9IE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgdmFyIGFyY0xlbiA9IGFuZ2xlICogcjtcbiAgICB2YXIgZGVsdGFSID0gciAtIHIwO1xuICAgIHZhciBpc0FuZ2xlUm93ID0gYXJjTGVuID4gTWF0aC5hYnMoZGVsdGFSKTtcbiAgICB2YXIgZ3JpZHMgPSBnZXREaXZpZGluZ0dyaWRzKFthcmNMZW4sIGRlbHRhUl0sIGlzQW5nbGVSb3cgPyAwIDogMSwgY291bnQpO1xuICAgIHZhciByb3dTaXplID0gKGlzQW5nbGVSb3cgPyBhbmdsZSA6IGRlbHRhUikgLyBncmlkcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgZ3JpZHMubGVuZ3RoOyByb3crKykge1xuICAgICAgICB2YXIgY29sdW1uU2l6ZSA9IChpc0FuZ2xlUm93ID8gZGVsdGFSIDogYW5nbGUpIC8gZ3JpZHNbcm93XTtcbiAgICAgICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDwgZ3JpZHNbcm93XTsgY29sdW1uKyspIHtcbiAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IHt9O1xuICAgICAgICAgICAgaWYgKGlzQW5nbGVSb3cpIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZS5zdGFydEFuZ2xlID0gc3RhcnRBbmdsZSArIHJvd1NpemUgKiByb3c7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGUuZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgcm93U2l6ZSAqIChyb3cgKyAxKTtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZS5yMCA9IHIwICsgY29sdW1uU2l6ZSAqIGNvbHVtbjtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZS5yID0gcjAgKyBjb2x1bW5TaXplICogKGNvbHVtbiArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGUuc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjb2x1bW5TaXplICogY29sdW1uO1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlLmVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNvbHVtblNpemUgKiAoY29sdW1uICsgMSk7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGUucjAgPSByMCArIHJvd1NpemUgKiByb3c7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGUuciA9IHIwICsgcm93U2l6ZSAqIChyb3cgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1NoYXBlLmNsb2Nrd2lzZSA9IHNlY3RvclNoYXBlLmNsb2Nrd2lzZTtcbiAgICAgICAgICAgIG5ld1NoYXBlLmN4ID0gc2VjdG9yU2hhcGUuY3g7XG4gICAgICAgICAgICBuZXdTaGFwZS5jeSA9IHNlY3RvclNoYXBlLmN5O1xuICAgICAgICAgICAgb3V0U2hhcGVzLnB1c2gobmV3U2hhcGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZGl2aWRlUmVjdChyZWN0U2hhcGUsIGNvdW50LCBvdXRTaGFwZXMpIHtcbiAgICB2YXIgd2lkdGggPSByZWN0U2hhcGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJlY3RTaGFwZS5oZWlnaHQ7XG4gICAgdmFyIGlzSG9yaXpvbnRhbFJvdyA9IHdpZHRoID4gaGVpZ2h0O1xuICAgIHZhciBncmlkcyA9IGdldERpdmlkaW5nR3JpZHMoW3dpZHRoLCBoZWlnaHRdLCBpc0hvcml6b250YWxSb3cgPyAwIDogMSwgY291bnQpO1xuICAgIHZhciByb3dTaXplRGltID0gaXNIb3Jpem9udGFsUm93ID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBjb2x1bW5TaXplRGltID0gaXNIb3Jpem9udGFsUm93ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciByb3dEaW0gPSBpc0hvcml6b250YWxSb3cgPyAneCcgOiAneSc7XG4gICAgdmFyIGNvbHVtbkRpbSA9IGlzSG9yaXpvbnRhbFJvdyA/ICd5JyA6ICd4JztcbiAgICB2YXIgcm93U2l6ZSA9IHJlY3RTaGFwZVtyb3dTaXplRGltXSAvIGdyaWRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBncmlkcy5sZW5ndGg7IHJvdysrKSB7XG4gICAgICAgIHZhciBjb2x1bW5TaXplID0gcmVjdFNoYXBlW2NvbHVtblNpemVEaW1dIC8gZ3JpZHNbcm93XTtcbiAgICAgICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDwgZ3JpZHNbcm93XTsgY29sdW1uKyspIHtcbiAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IHt9O1xuICAgICAgICAgICAgbmV3U2hhcGVbcm93RGltXSA9IHJvdyAqIHJvd1NpemU7XG4gICAgICAgICAgICBuZXdTaGFwZVtjb2x1bW5EaW1dID0gY29sdW1uICogY29sdW1uU2l6ZTtcbiAgICAgICAgICAgIG5ld1NoYXBlW3Jvd1NpemVEaW1dID0gcm93U2l6ZTtcbiAgICAgICAgICAgIG5ld1NoYXBlW2NvbHVtblNpemVEaW1dID0gY29sdW1uU2l6ZTtcbiAgICAgICAgICAgIG5ld1NoYXBlLnggKz0gcmVjdFNoYXBlLng7XG4gICAgICAgICAgICBuZXdTaGFwZS55ICs9IHJlY3RTaGFwZS55O1xuICAgICAgICAgICAgb3V0U2hhcGVzLnB1c2gobmV3U2hhcGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY3Jvc3NQcm9kdWN0MmQoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4geDEgKiB5MiAtIHgyICogeTE7XG59XG5mdW5jdGlvbiBsaW5lTGluZUludGVyc2VjdChhMXgsIGExeSwgYTJ4LCBhMnksIGIxeCwgYjF5LCBiMngsIGIyeSkge1xuICAgIHZhciBteCA9IGEyeCAtIGExeDtcbiAgICB2YXIgbXkgPSBhMnkgLSBhMXk7XG4gICAgdmFyIG54ID0gYjJ4IC0gYjF4O1xuICAgIHZhciBueSA9IGIyeSAtIGIxeTtcbiAgICB2YXIgbm1Dcm9zc1Byb2R1Y3QgPSBjcm9zc1Byb2R1Y3QyZChueCwgbnksIG14LCBteSk7XG4gICAgaWYgKE1hdGguYWJzKG5tQ3Jvc3NQcm9kdWN0KSA8IDFlLTYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBiMWExeCA9IGExeCAtIGIxeDtcbiAgICB2YXIgYjFhMXkgPSBhMXkgLSBiMXk7XG4gICAgdmFyIHAgPSBjcm9zc1Byb2R1Y3QyZChiMWExeCwgYjFhMXksIG54LCBueSkgLyBubUNyb3NzUHJvZHVjdDtcbiAgICBpZiAocCA8IDAgfHwgcCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUG9pbnQocCAqIG14ICsgYTF4LCBwICogbXkgKyBhMXkpO1xufVxuZnVuY3Rpb24gcHJvalB0T25MaW5lKHB0LCBsaW5lQSwgbGluZUIpIHtcbiAgICB2YXIgZGlyID0gbmV3IFBvaW50KCk7XG4gICAgUG9pbnQuc3ViKGRpciwgbGluZUIsIGxpbmVBKTtcbiAgICBkaXIubm9ybWFsaXplKCk7XG4gICAgdmFyIGRpcjIgPSBuZXcgUG9pbnQoKTtcbiAgICBQb2ludC5zdWIoZGlyMiwgcHQsIGxpbmVBKTtcbiAgICB2YXIgbGVuID0gZGlyMi5kb3QoZGlyKTtcbiAgICByZXR1cm4gbGVuO1xufVxuZnVuY3Rpb24gYWRkVG9Qb2x5KHBvbHksIHB0KSB7XG4gICAgdmFyIGxhc3QgPSBwb2x5W3BvbHkubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3QgJiYgbGFzdFswXSA9PT0gcHRbMF0gJiYgbGFzdFsxXSA9PT0gcHRbMV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwb2x5LnB1c2gocHQpO1xufVxuZnVuY3Rpb24gc3BsaXRQb2x5Z29uQnlMaW5lKHBvaW50cywgbGluZUEsIGxpbmVCKSB7XG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBwMCA9IHBvaW50c1tpXTtcbiAgICAgICAgdmFyIHAxID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUHQgPSBsaW5lTGluZUludGVyc2VjdChwMFswXSwgcDBbMV0sIHAxWzBdLCBwMVsxXSwgbGluZUEueCwgbGluZUEueSwgbGluZUIueCwgbGluZUIueSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb25QdCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwcm9qUHQ6IHByb2pQdE9uTGluZShpbnRlcnNlY3Rpb25QdCwgbGluZUEsIGxpbmVCKSxcbiAgICAgICAgICAgICAgICBwdDogaW50ZXJzZWN0aW9uUHQsXG4gICAgICAgICAgICAgICAgaWR4OiBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBbeyBwb2ludHM6IHBvaW50cyB9LCB7IHBvaW50czogcG9pbnRzIH1dO1xuICAgIH1cbiAgICBpbnRlcnNlY3Rpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEucHJvalB0IC0gYi5wcm9qUHQ7XG4gICAgfSk7XG4gICAgdmFyIHNwbGl0UHQwID0gaW50ZXJzZWN0aW9uc1swXTtcbiAgICB2YXIgc3BsaXRQdDEgPSBpbnRlcnNlY3Rpb25zW2ludGVyc2VjdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHNwbGl0UHQxLmlkeCA8IHNwbGl0UHQwLmlkeCkge1xuICAgICAgICB2YXIgdG1wID0gc3BsaXRQdDA7XG4gICAgICAgIHNwbGl0UHQwID0gc3BsaXRQdDE7XG4gICAgICAgIHNwbGl0UHQxID0gdG1wO1xuICAgIH1cbiAgICB2YXIgc3BsaXRQdDBBcnIgPSBbc3BsaXRQdDAucHQueCwgc3BsaXRQdDAucHQueV07XG4gICAgdmFyIHNwbGl0UHQxQXJyID0gW3NwbGl0UHQxLnB0LngsIHNwbGl0UHQxLnB0LnldO1xuICAgIHZhciBuZXdQb2x5QSA9IFtzcGxpdFB0MEFycl07XG4gICAgdmFyIG5ld1BvbHlCID0gW3NwbGl0UHQxQXJyXTtcbiAgICBmb3IgKHZhciBpID0gc3BsaXRQdDAuaWR4ICsgMTsgaSA8PSBzcGxpdFB0MS5pZHg7IGkrKykge1xuICAgICAgICBhZGRUb1BvbHkobmV3UG9seUEsIHBvaW50c1tpXS5zbGljZSgpKTtcbiAgICB9XG4gICAgYWRkVG9Qb2x5KG5ld1BvbHlBLCBzcGxpdFB0MUFycik7XG4gICAgYWRkVG9Qb2x5KG5ld1BvbHlBLCBzcGxpdFB0MEFycik7XG4gICAgZm9yICh2YXIgaSA9IHNwbGl0UHQxLmlkeCArIDE7IGkgPD0gc3BsaXRQdDAuaWR4ICsgbGVuOyBpKyspIHtcbiAgICAgICAgYWRkVG9Qb2x5KG5ld1BvbHlCLCBwb2ludHNbaSAlIGxlbl0uc2xpY2UoKSk7XG4gICAgfVxuICAgIGFkZFRvUG9seShuZXdQb2x5Qiwgc3BsaXRQdDBBcnIpO1xuICAgIGFkZFRvUG9seShuZXdQb2x5Qiwgc3BsaXRQdDFBcnIpO1xuICAgIHJldHVybiBbe1xuICAgICAgICAgICAgcG9pbnRzOiBuZXdQb2x5QVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBwb2ludHM6IG5ld1BvbHlCXG4gICAgICAgIH1dO1xufVxuZnVuY3Rpb24gYmluYXJ5RGl2aWRlUG9seWdvbihwb2x5Z29uU2hhcGUpIHtcbiAgICB2YXIgcG9pbnRzID0gcG9seWdvblNoYXBlLnBvaW50cztcbiAgICB2YXIgbWluID0gW107XG4gICAgdmFyIG1heCA9IFtdO1xuICAgIGZyb21Qb2ludHMocG9pbnRzLCBtaW4sIG1heCk7XG4gICAgdmFyIGJvdW5kaW5nUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcbiAgICB2YXIgd2lkdGggPSBib3VuZGluZ1JlY3Qud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGJvdW5kaW5nUmVjdC5oZWlnaHQ7XG4gICAgdmFyIHggPSBib3VuZGluZ1JlY3QueDtcbiAgICB2YXIgeSA9IGJvdW5kaW5nUmVjdC55O1xuICAgIHZhciBwdDAgPSBuZXcgUG9pbnQoKTtcbiAgICB2YXIgcHQxID0gbmV3IFBvaW50KCk7XG4gICAgaWYgKHdpZHRoID4gaGVpZ2h0KSB7XG4gICAgICAgIHB0MC54ID0gcHQxLnggPSB4ICsgd2lkdGggLyAyO1xuICAgICAgICBwdDAueSA9IHk7XG4gICAgICAgIHB0MS55ID0geSArIGhlaWdodDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHB0MC55ID0gcHQxLnkgPSB5ICsgaGVpZ2h0IC8gMjtcbiAgICAgICAgcHQwLnggPSB4O1xuICAgICAgICBwdDEueCA9IHggKyB3aWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIHNwbGl0UG9seWdvbkJ5TGluZShwb2ludHMsIHB0MCwgcHQxKTtcbn1cbmZ1bmN0aW9uIGJpbmFyeURpdmlkZVJlY3Vyc2l2ZShkaXZpZGVyLCBzaGFwZSwgY291bnQsIG91dCkge1xuICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICBvdXQucHVzaChzaGFwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcihjb3VudCAvIDIpO1xuICAgICAgICB2YXIgc3ViID0gZGl2aWRlcihzaGFwZSk7XG4gICAgICAgIGJpbmFyeURpdmlkZVJlY3Vyc2l2ZShkaXZpZGVyLCBzdWJbMF0sIG1pZCwgb3V0KTtcbiAgICAgICAgYmluYXJ5RGl2aWRlUmVjdXJzaXZlKGRpdmlkZXIsIHN1YlsxXSwgY291bnQgLSBtaWQsIG91dCk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gY2xvbmUocGF0aCwgY291bnQpIHtcbiAgICB2YXIgcGF0aHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgcGF0aHMucHVzaChjbG9uZVBhdGgocGF0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aHM7XG59XG5mdW5jdGlvbiBjb3B5UGF0aFByb3BzKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnNldFN0eWxlKHNvdXJjZS5zdHlsZSk7XG4gICAgdGFyZ2V0LnogPSBzb3VyY2UuejtcbiAgICB0YXJnZXQuejIgPSBzb3VyY2UuejI7XG4gICAgdGFyZ2V0LnpsZXZlbCA9IHNvdXJjZS56bGV2ZWw7XG59XG5mdW5jdGlvbiBwb2x5Z29uQ29udmVydChwb2ludHMpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOykge1xuICAgICAgICBvdXQucHVzaChbcG9pbnRzW2krK10sIHBvaW50c1tpKytdXSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gc3BsaXQocGF0aCwgY291bnQpIHtcbiAgICB2YXIgb3V0U2hhcGVzID0gW107XG4gICAgdmFyIHNoYXBlID0gcGF0aC5zaGFwZTtcbiAgICB2YXIgT3V0U2hhcGVDdG9yO1xuICAgIHN3aXRjaCAocGF0aC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3JlY3QnOlxuICAgICAgICAgICAgZGl2aWRlUmVjdChzaGFwZSwgY291bnQsIG91dFNoYXBlcyk7XG4gICAgICAgICAgICBPdXRTaGFwZUN0b3IgPSBSZWN0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlY3Rvcic6XG4gICAgICAgICAgICBkaXZpZGVTZWN0b3Ioc2hhcGUsIGNvdW50LCBvdXRTaGFwZXMpO1xuICAgICAgICAgICAgT3V0U2hhcGVDdG9yID0gU2VjdG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICAgICAgICBkaXZpZGVTZWN0b3Ioe1xuICAgICAgICAgICAgICAgIHIwOiAwLCByOiBzaGFwZS5yLCBzdGFydEFuZ2xlOiAwLCBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXG4gICAgICAgICAgICAgICAgY3g6IHNoYXBlLmN4LCBjeTogc2hhcGUuY3lcbiAgICAgICAgICAgIH0sIGNvdW50LCBvdXRTaGFwZXMpO1xuICAgICAgICAgICAgT3V0U2hhcGVDdG9yID0gU2VjdG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgbSA9IHBhdGguZ2V0Q29tcHV0ZWRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IG0gPyBNYXRoLnNxcnQoTWF0aC5tYXgobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSwgbVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSkpIDogMTtcbiAgICAgICAgICAgIHZhciBwb2x5Z29ucyA9IG1hcChwYXRoVG9Qb2x5Z29ucyhwYXRoLmdldFVwZGF0ZWRQYXRoUHJveHkoKSwgc2NhbGUpLCBmdW5jdGlvbiAocG9seSkgeyByZXR1cm4gcG9seWdvbkNvbnZlcnQocG9seSk7IH0pO1xuICAgICAgICAgICAgdmFyIHBvbHlnb25Db3VudCA9IHBvbHlnb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb2x5Z29uQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBiaW5hcnlEaXZpZGVSZWN1cnNpdmUoYmluYXJ5RGl2aWRlUG9seWdvbiwge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHBvbHlnb25zWzBdXG4gICAgICAgICAgICAgICAgfSwgY291bnQsIG91dFNoYXBlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwb2x5Z29uQ291bnQgPT09IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBvdXRTaGFwZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHBvbHlnb25zW2ldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbEFyZWFfMSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gbWFwKHBvbHlnb25zLCBmdW5jdGlvbiAocG9seSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWluID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbVBvaW50cyhwb2x5LCBtaW4sIG1heCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmVhID0gKG1heFsxXSAtIG1pblsxXSkgKiAobWF4WzBdIC0gbWluWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxBcmVhXzEgKz0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcG9seTogcG9seSwgYXJlYTogYXJlYSB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIuYXJlYSAtIGEuYXJlYTsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBjb3VudDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmQ291bnQgPSBpID09PSBwb2x5Z29uQ291bnQgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5jZWlsKGl0ZW0uYXJlYSAvIHRvdGFsQXJlYV8xICogY291bnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZkNvdW50IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5RGl2aWRlUmVjdXJzaXZlKGJpbmFyeURpdmlkZVBvbHlnb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogaXRlbS5wb2x5XG4gICAgICAgICAgICAgICAgICAgIH0sIHNlbGZDb3VudCwgb3V0U2hhcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSBzZWxmQ291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE91dFNoYXBlQ3RvciA9IFBvbHlnb247XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFPdXRTaGFwZUN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lKHBhdGgsIGNvdW50KTtcbiAgICB9XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0U2hhcGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdWJQYXRoID0gbmV3IE91dFNoYXBlQ3RvcigpO1xuICAgICAgICBzdWJQYXRoLnNldFNoYXBlKG91dFNoYXBlc1tpXSk7XG4gICAgICAgIGNvcHlQYXRoUHJvcHMocGF0aCwgc3ViUGF0aCk7XG4gICAgICAgIG91dC5wdXNoKHN1YlBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuIiwiaW1wb3J0IHsgY3ViaWNTdWJkaXZpZGUgfSBmcm9tICcuLi9jb3JlL2N1cnZlLmpzJztcbmltcG9ydCBQYXRoIGZyb20gJy4uL2dyYXBoaWMvUGF0aC5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0cywgbWFwIH0gZnJvbSAnLi4vY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGxlcnAgfSBmcm9tICcuLi9jb3JlL3ZlY3Rvci5qcyc7XG5pbXBvcnQgeyBjbG9uZVBhdGggfSBmcm9tICcuL3BhdGguanMnO1xuaW1wb3J0IFRyYW5zZm9ybWFibGUgZnJvbSAnLi4vY29yZS9UcmFuc2Zvcm1hYmxlLmpzJztcbmltcG9ydCB7IHNwbGl0IH0gZnJvbSAnLi9kaXZpZGVQYXRoLmpzJztcbmltcG9ydCB7IHBhdGhUb0JlemllckN1cnZlcyB9IGZyb20gJy4vY29udmVydFBhdGguanMnO1xuZnVuY3Rpb24gYWxpZ25TdWJwYXRoKHN1YnBhdGgxLCBzdWJwYXRoMikge1xuICAgIHZhciBsZW4xID0gc3VicGF0aDEubGVuZ3RoO1xuICAgIHZhciBsZW4yID0gc3VicGF0aDIubGVuZ3RoO1xuICAgIGlmIChsZW4xID09PSBsZW4yKSB7XG4gICAgICAgIHJldHVybiBbc3VicGF0aDEsIHN1YnBhdGgyXTtcbiAgICB9XG4gICAgdmFyIHRtcFNlZ1ggPSBbXTtcbiAgICB2YXIgdG1wU2VnWSA9IFtdO1xuICAgIHZhciBzaG9ydGVyUGF0aCA9IGxlbjEgPCBsZW4yID8gc3VicGF0aDEgOiBzdWJwYXRoMjtcbiAgICB2YXIgc2hvcnRlckxlbiA9IE1hdGgubWluKGxlbjEsIGxlbjIpO1xuICAgIHZhciBkaWZmID0gTWF0aC5hYnMobGVuMiAtIGxlbjEpIC8gNjtcbiAgICB2YXIgc2hvcnRlckJlemllckNvdW50ID0gKHNob3J0ZXJMZW4gLSAyKSAvIDY7XG4gICAgdmFyIGVhY2hDdXJ2ZVN1YkRpdkNvdW50ID0gTWF0aC5jZWlsKGRpZmYgLyBzaG9ydGVyQmV6aWVyQ291bnQpICsgMTtcbiAgICB2YXIgbmV3U3VicGF0aCA9IFtzaG9ydGVyUGF0aFswXSwgc2hvcnRlclBhdGhbMV1dO1xuICAgIHZhciByZW1haW5lZCA9IGRpZmY7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBzaG9ydGVyTGVuOykge1xuICAgICAgICB2YXIgeDAgPSBzaG9ydGVyUGF0aFtpIC0gMl07XG4gICAgICAgIHZhciB5MCA9IHNob3J0ZXJQYXRoW2kgLSAxXTtcbiAgICAgICAgdmFyIHgxID0gc2hvcnRlclBhdGhbaSsrXTtcbiAgICAgICAgdmFyIHkxID0gc2hvcnRlclBhdGhbaSsrXTtcbiAgICAgICAgdmFyIHgyID0gc2hvcnRlclBhdGhbaSsrXTtcbiAgICAgICAgdmFyIHkyID0gc2hvcnRlclBhdGhbaSsrXTtcbiAgICAgICAgdmFyIHgzID0gc2hvcnRlclBhdGhbaSsrXTtcbiAgICAgICAgdmFyIHkzID0gc2hvcnRlclBhdGhbaSsrXTtcbiAgICAgICAgaWYgKHJlbWFpbmVkIDw9IDApIHtcbiAgICAgICAgICAgIG5ld1N1YnBhdGgucHVzaCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhY3R1YWxTdWJEaXZDb3VudCA9IE1hdGgubWluKHJlbWFpbmVkLCBlYWNoQ3VydmVTdWJEaXZDb3VudCAtIDEpICsgMTtcbiAgICAgICAgZm9yICh2YXIgayA9IDE7IGsgPD0gYWN0dWFsU3ViRGl2Q291bnQ7IGsrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBrIC8gYWN0dWFsU3ViRGl2Q291bnQ7XG4gICAgICAgICAgICBjdWJpY1N1YmRpdmlkZSh4MCwgeDEsIHgyLCB4MywgcCwgdG1wU2VnWCk7XG4gICAgICAgICAgICBjdWJpY1N1YmRpdmlkZSh5MCwgeTEsIHkyLCB5MywgcCwgdG1wU2VnWSk7XG4gICAgICAgICAgICB4MCA9IHRtcFNlZ1hbM107XG4gICAgICAgICAgICB5MCA9IHRtcFNlZ1lbM107XG4gICAgICAgICAgICBuZXdTdWJwYXRoLnB1c2godG1wU2VnWFsxXSwgdG1wU2VnWVsxXSwgdG1wU2VnWFsyXSwgdG1wU2VnWVsyXSwgeDAsIHkwKTtcbiAgICAgICAgICAgIHgxID0gdG1wU2VnWFs1XTtcbiAgICAgICAgICAgIHkxID0gdG1wU2VnWVs1XTtcbiAgICAgICAgICAgIHgyID0gdG1wU2VnWFs2XTtcbiAgICAgICAgICAgIHkyID0gdG1wU2VnWVs2XTtcbiAgICAgICAgfVxuICAgICAgICByZW1haW5lZCAtPSBhY3R1YWxTdWJEaXZDb3VudCAtIDE7XG4gICAgfVxuICAgIHJldHVybiBzaG9ydGVyUGF0aCA9PT0gc3VicGF0aDEgPyBbbmV3U3VicGF0aCwgc3VicGF0aDJdIDogW3N1YnBhdGgxLCBuZXdTdWJwYXRoXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN1YnBhdGgobGFzdFN1YnBhdGhTdWJwYXRoLCBvdGhlclN1YnBhdGgpIHtcbiAgICB2YXIgbGVuID0gbGFzdFN1YnBhdGhTdWJwYXRoLmxlbmd0aDtcbiAgICB2YXIgbGFzdFggPSBsYXN0U3VicGF0aFN1YnBhdGhbbGVuIC0gMl07XG4gICAgdmFyIGxhc3RZID0gbGFzdFN1YnBhdGhTdWJwYXRoW2xlbiAtIDFdO1xuICAgIHZhciBuZXdTdWJwYXRoID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlclN1YnBhdGgubGVuZ3RoOykge1xuICAgICAgICBuZXdTdWJwYXRoW2krK10gPSBsYXN0WDtcbiAgICAgICAgbmV3U3VicGF0aFtpKytdID0gbGFzdFk7XG4gICAgfVxuICAgIHJldHVybiBuZXdTdWJwYXRoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFsaWduQmV6aWVyQ3VydmVzKGFycmF5MSwgYXJyYXkyKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBsYXN0U3VicGF0aDE7XG4gICAgdmFyIGxhc3RTdWJwYXRoMjtcbiAgICB2YXIgbmV3QXJyYXkxID0gW107XG4gICAgdmFyIG5ld0FycmF5MiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5tYXgoYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCk7IGkrKykge1xuICAgICAgICB2YXIgc3VicGF0aDEgPSBhcnJheTFbaV07XG4gICAgICAgIHZhciBzdWJwYXRoMiA9IGFycmF5MltpXTtcbiAgICAgICAgdmFyIG5ld1N1YnBhdGgxID0gdm9pZCAwO1xuICAgICAgICB2YXIgbmV3U3VicGF0aDIgPSB2b2lkIDA7XG4gICAgICAgIGlmICghc3VicGF0aDEpIHtcbiAgICAgICAgICAgIG5ld1N1YnBhdGgxID0gY3JlYXRlU3VicGF0aChsYXN0U3VicGF0aDEgfHwgc3VicGF0aDIsIHN1YnBhdGgyKTtcbiAgICAgICAgICAgIG5ld1N1YnBhdGgyID0gc3VicGF0aDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXN1YnBhdGgyKSB7XG4gICAgICAgICAgICBuZXdTdWJwYXRoMiA9IGNyZWF0ZVN1YnBhdGgobGFzdFN1YnBhdGgyIHx8IHN1YnBhdGgxLCBzdWJwYXRoMSk7XG4gICAgICAgICAgICBuZXdTdWJwYXRoMSA9IHN1YnBhdGgxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2EgPSBhbGlnblN1YnBhdGgoc3VicGF0aDEsIHN1YnBhdGgyKSwgbmV3U3VicGF0aDEgPSBfYVswXSwgbmV3U3VicGF0aDIgPSBfYVsxXTtcbiAgICAgICAgICAgIGxhc3RTdWJwYXRoMSA9IG5ld1N1YnBhdGgxO1xuICAgICAgICAgICAgbGFzdFN1YnBhdGgyID0gbmV3U3VicGF0aDI7XG4gICAgICAgIH1cbiAgICAgICAgbmV3QXJyYXkxLnB1c2gobmV3U3VicGF0aDEpO1xuICAgICAgICBuZXdBcnJheTIucHVzaChuZXdTdWJwYXRoMik7XG4gICAgfVxuICAgIHJldHVybiBbbmV3QXJyYXkxLCBuZXdBcnJheTJdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNlbnRyb2lkKGFycmF5KSB7XG4gICAgdmFyIHNpZ25lZEFyZWEgPSAwO1xuICAgIHZhciBjeCA9IDA7XG4gICAgdmFyIGN5ID0gMDtcbiAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gbGVuIC0gMjsgaSA8IGxlbjsgaiA9IGksIGkgKz0gMikge1xuICAgICAgICB2YXIgeDAgPSBhcnJheVtqXTtcbiAgICAgICAgdmFyIHkwID0gYXJyYXlbaiArIDFdO1xuICAgICAgICB2YXIgeDEgPSBhcnJheVtpXTtcbiAgICAgICAgdmFyIHkxID0gYXJyYXlbaSArIDFdO1xuICAgICAgICB2YXIgYSA9IHgwICogeTEgLSB4MSAqIHkwO1xuICAgICAgICBzaWduZWRBcmVhICs9IGE7XG4gICAgICAgIGN4ICs9ICh4MCArIHgxKSAqIGE7XG4gICAgICAgIGN5ICs9ICh5MCArIHkxKSAqIGE7XG4gICAgfVxuICAgIGlmIChzaWduZWRBcmVhID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbYXJyYXlbMF0gfHwgMCwgYXJyYXlbMV0gfHwgMF07XG4gICAgfVxuICAgIHJldHVybiBbY3ggLyBzaWduZWRBcmVhIC8gMywgY3kgLyBzaWduZWRBcmVhIC8gMywgc2lnbmVkQXJlYV07XG59XG5mdW5jdGlvbiBmaW5kQmVzdFJpbmdPZmZzZXQoZnJvbVN1YkJlemllcnMsIHRvU3ViQmV6aWVycywgZnJvbUNwLCB0b0NwKSB7XG4gICAgdmFyIGJlemllckNvdW50ID0gKGZyb21TdWJCZXppZXJzLmxlbmd0aCAtIDIpIC8gNjtcbiAgICB2YXIgYmVzdFNjb3JlID0gSW5maW5pdHk7XG4gICAgdmFyIGJlc3RPZmZzZXQgPSAwO1xuICAgIHZhciBsZW4gPSBmcm9tU3ViQmV6aWVycy5sZW5ndGg7XG4gICAgdmFyIGxlbjIgPSBsZW4gLSAyO1xuICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGJlemllckNvdW50OyBvZmZzZXQrKykge1xuICAgICAgICB2YXIgY3Vyc29yT2Zmc2V0ID0gb2Zmc2V0ICogNjtcbiAgICAgICAgdmFyIHNjb3JlID0gMDtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsZW47IGsgKz0gMikge1xuICAgICAgICAgICAgdmFyIGlkeCA9IGsgPT09IDAgPyBjdXJzb3JPZmZzZXQgOiAoKGN1cnNvck9mZnNldCArIGsgLSAyKSAlIGxlbjIgKyAyKTtcbiAgICAgICAgICAgIHZhciB4MCA9IGZyb21TdWJCZXppZXJzW2lkeF0gLSBmcm9tQ3BbMF07XG4gICAgICAgICAgICB2YXIgeTAgPSBmcm9tU3ViQmV6aWVyc1tpZHggKyAxXSAtIGZyb21DcFsxXTtcbiAgICAgICAgICAgIHZhciB4MSA9IHRvU3ViQmV6aWVyc1trXSAtIHRvQ3BbMF07XG4gICAgICAgICAgICB2YXIgeTEgPSB0b1N1YkJlemllcnNbayArIDFdIC0gdG9DcFsxXTtcbiAgICAgICAgICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgICAgICAgICB2YXIgZHkgPSB5MSAtIHkwO1xuICAgICAgICAgICAgc2NvcmUgKz0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3JlIDwgYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICAgIGJlc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJlc3RPZmZzZXQ7XG59XG5mdW5jdGlvbiByZXZlcnNlKGFycmF5KSB7XG4gICAgdmFyIG5ld0FyciA9IFtdO1xuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBuZXdBcnJbaV0gPSBhcnJheVtsZW4gLSBpIC0gMl07XG4gICAgICAgIG5ld0FycltpICsgMV0gPSBhcnJheVtsZW4gLSBpIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnI7XG59XG5mdW5jdGlvbiBmaW5kQmVzdE1vcnBoaW5nUm90YXRpb24oZnJvbUFyciwgdG9BcnIsIHNlYXJjaEFuZ2xlSXRlcmF0aW9uLCBzZWFyY2hBbmdsZVJhbmdlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBmcm9tTmVlZHNSZXZlcnNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJvbUFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZnJvbVN1YnBhdGhCZXppZXIgPSBmcm9tQXJyW2ldO1xuICAgICAgICB2YXIgdG9TdWJwYXRoQmV6aWVyID0gdG9BcnJbaV07XG4gICAgICAgIHZhciBmcm9tQ3AgPSBjZW50cm9pZChmcm9tU3VicGF0aEJlemllcik7XG4gICAgICAgIHZhciB0b0NwID0gY2VudHJvaWQodG9TdWJwYXRoQmV6aWVyKTtcbiAgICAgICAgaWYgKGZyb21OZWVkc1JldmVyc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgZnJvbU5lZWRzUmV2ZXJzZSA9IGZyb21DcFsyXSA8IDAgIT09IHRvQ3BbMl0gPCAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdGcm9tU3VicGF0aEJlemllciA9IFtdO1xuICAgICAgICB2YXIgbmV3VG9TdWJwYXRoQmV6aWVyID0gW107XG4gICAgICAgIHZhciBiZXN0QW5nbGUgPSAwO1xuICAgICAgICB2YXIgYmVzdFNjb3JlID0gSW5maW5pdHk7XG4gICAgICAgIHZhciB0bXBBcnIgPSBbXTtcbiAgICAgICAgdmFyIGxlbiA9IGZyb21TdWJwYXRoQmV6aWVyLmxlbmd0aDtcbiAgICAgICAgaWYgKGZyb21OZWVkc1JldmVyc2UpIHtcbiAgICAgICAgICAgIGZyb21TdWJwYXRoQmV6aWVyID0gcmV2ZXJzZShmcm9tU3VicGF0aEJlemllcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldCA9IGZpbmRCZXN0UmluZ09mZnNldChmcm9tU3VicGF0aEJlemllciwgdG9TdWJwYXRoQmV6aWVyLCBmcm9tQ3AsIHRvQ3ApICogNjtcbiAgICAgICAgdmFyIGxlbjIgPSBsZW4gLSAyO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxlbjI7IGsgKz0gMikge1xuICAgICAgICAgICAgdmFyIGlkeCA9IChvZmZzZXQgKyBrKSAlIGxlbjIgKyAyO1xuICAgICAgICAgICAgbmV3RnJvbVN1YnBhdGhCZXppZXJbayArIDJdID0gZnJvbVN1YnBhdGhCZXppZXJbaWR4XSAtIGZyb21DcFswXTtcbiAgICAgICAgICAgIG5ld0Zyb21TdWJwYXRoQmV6aWVyW2sgKyAzXSA9IGZyb21TdWJwYXRoQmV6aWVyW2lkeCArIDFdIC0gZnJvbUNwWzFdO1xuICAgICAgICB9XG4gICAgICAgIG5ld0Zyb21TdWJwYXRoQmV6aWVyWzBdID0gZnJvbVN1YnBhdGhCZXppZXJbb2Zmc2V0XSAtIGZyb21DcFswXTtcbiAgICAgICAgbmV3RnJvbVN1YnBhdGhCZXppZXJbMV0gPSBmcm9tU3VicGF0aEJlemllcltvZmZzZXQgKyAxXSAtIGZyb21DcFsxXTtcbiAgICAgICAgaWYgKHNlYXJjaEFuZ2xlSXRlcmF0aW9uID4gMCkge1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSBzZWFyY2hBbmdsZVJhbmdlIC8gc2VhcmNoQW5nbGVJdGVyYXRpb247XG4gICAgICAgICAgICBmb3IgKHZhciBhbmdsZSA9IC1zZWFyY2hBbmdsZVJhbmdlIC8gMjsgYW5nbGUgPD0gc2VhcmNoQW5nbGVSYW5nZSAvIDI7IGFuZ2xlICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNhID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgICAgICAgIHZhciBzY29yZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBmcm9tU3VicGF0aEJlemllci5sZW5ndGg7IGsgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDAgPSBuZXdGcm9tU3VicGF0aEJlemllcltrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkwID0gbmV3RnJvbVN1YnBhdGhCZXppZXJbayArIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSB0b1N1YnBhdGhCZXppZXJba10gLSB0b0NwWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSB0b1N1YnBhdGhCZXppZXJbayArIDFdIC0gdG9DcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1gxID0geDEgKiBjYSAtIHkxICogc2E7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdZMSA9IHgxICogc2EgKyB5MSAqIGNhO1xuICAgICAgICAgICAgICAgICAgICB0bXBBcnJba10gPSBuZXdYMTtcbiAgICAgICAgICAgICAgICAgICAgdG1wQXJyW2sgKyAxXSA9IG5ld1kxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBuZXdYMSAtIHgwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSBuZXdZMSAtIHkwO1xuICAgICAgICAgICAgICAgICAgICBzY29yZSArPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjb3JlIDwgYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgICAgICAgICBiZXN0QW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCB0bXBBcnIubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RvU3VicGF0aEJlemllclttXSA9IHRtcEFyclttXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IGxlbjsgaV8xICs9IDIpIHtcbiAgICAgICAgICAgICAgICBuZXdUb1N1YnBhdGhCZXppZXJbaV8xXSA9IHRvU3VicGF0aEJlemllcltpXzFdIC0gdG9DcFswXTtcbiAgICAgICAgICAgICAgICBuZXdUb1N1YnBhdGhCZXppZXJbaV8xICsgMV0gPSB0b1N1YnBhdGhCZXppZXJbaV8xICsgMV0gLSB0b0NwWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIGZyb206IG5ld0Zyb21TdWJwYXRoQmV6aWVyLFxuICAgICAgICAgICAgdG86IG5ld1RvU3VicGF0aEJlemllcixcbiAgICAgICAgICAgIGZyb21DcDogZnJvbUNwLFxuICAgICAgICAgICAgdG9DcDogdG9DcCxcbiAgICAgICAgICAgIHJvdGF0aW9uOiAtYmVzdEFuZ2xlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29tYmluZU1vcnBoaW5nKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5fX2lzQ29tYmluZU1vcnBoaW5nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTW9ycGhpbmcoZWwpIHtcbiAgICByZXR1cm4gZWwuX19tb3JwaFQgPj0gMDtcbn1cbnZhciBTQVZFRF9NRVRIT0RfUFJFRklYID0gJ19fbU9yaWdpbmFsXyc7XG5mdW5jdGlvbiBzYXZlQW5kTW9kaWZ5TWV0aG9kKG9iaiwgbWV0aG9kTmFtZSwgbW9kaWZpZXJzKSB7XG4gICAgdmFyIHNhdmVkTWV0aG9kTmFtZSA9IFNBVkVEX01FVEhPRF9QUkVGSVggKyBtZXRob2ROYW1lO1xuICAgIHZhciBvcmlnaW5hbE1ldGhvZCA9IG9ialtzYXZlZE1ldGhvZE5hbWVdIHx8IG9ialttZXRob2ROYW1lXTtcbiAgICBpZiAoIW9ialtzYXZlZE1ldGhvZE5hbWVdKSB7XG4gICAgICAgIG9ialtzYXZlZE1ldGhvZE5hbWVdID0gb2JqW21ldGhvZE5hbWVdO1xuICAgIH1cbiAgICB2YXIgcmVwbGFjZSA9IG1vZGlmaWVycy5yZXBsYWNlO1xuICAgIHZhciBhZnRlciA9IG1vZGlmaWVycy5hZnRlcjtcbiAgICB2YXIgYmVmb3JlID0gbW9kaWZpZXJzLmJlZm9yZTtcbiAgICBvYmpbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBiZWZvcmUgJiYgYmVmb3JlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICAgICAgcmVzID0gcmVwbGFjZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGFmdGVyICYmIGFmdGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG5mdW5jdGlvbiByZXN0b3JlTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgIHZhciBzYXZlZE1ldGhvZE5hbWUgPSBTQVZFRF9NRVRIT0RfUFJFRklYICsgbWV0aG9kTmFtZTtcbiAgICBpZiAob2JqW3NhdmVkTWV0aG9kTmFtZV0pIHtcbiAgICAgICAgb2JqW21ldGhvZE5hbWVdID0gb2JqW3NhdmVkTWV0aG9kTmFtZV07XG4gICAgICAgIG9ialtzYXZlZE1ldGhvZE5hbWVdID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseVRyYW5zZm9ybU9uQmV6aWVycyhiZXppZXJDdXJ2ZXMsIG1tKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiZXppZXJDdXJ2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1YkJlemllcnMgPSBiZXppZXJDdXJ2ZXNbaV07XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc3ViQmV6aWVycy5sZW5ndGg7KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHN1YkJlemllcnNba107XG4gICAgICAgICAgICB2YXIgeSA9IHN1YkJlemllcnNbayArIDFdO1xuICAgICAgICAgICAgc3ViQmV6aWVyc1trKytdID0gbW1bMF0gKiB4ICsgbW1bMl0gKiB5ICsgbW1bNF07XG4gICAgICAgICAgICBzdWJCZXppZXJzW2srK10gPSBtbVsxXSAqIHggKyBtbVszXSAqIHkgKyBtbVs1XTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVNb3JwaFBhdGgoZnJvbVBhdGgsIHRvUGF0aCkge1xuICAgIHZhciBmcm9tUGF0aFByb3h5ID0gZnJvbVBhdGguZ2V0VXBkYXRlZFBhdGhQcm94eSgpO1xuICAgIHZhciB0b1BhdGhQcm94eSA9IHRvUGF0aC5nZXRVcGRhdGVkUGF0aFByb3h5KCk7XG4gICAgdmFyIF9hID0gYWxpZ25CZXppZXJDdXJ2ZXMocGF0aFRvQmV6aWVyQ3VydmVzKGZyb21QYXRoUHJveHkpLCBwYXRoVG9CZXppZXJDdXJ2ZXModG9QYXRoUHJveHkpKSwgZnJvbUJlemllckN1cnZlcyA9IF9hWzBdLCB0b0JlemllckN1cnZlcyA9IF9hWzFdO1xuICAgIHZhciBmcm9tUGF0aFRyYW5zZm9ybSA9IGZyb21QYXRoLmdldENvbXB1dGVkVHJhbnNmb3JtKCk7XG4gICAgdmFyIHRvUGF0aFRyYW5zZm9ybSA9IHRvUGF0aC5nZXRDb21wdXRlZFRyYW5zZm9ybSgpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUlkZW50aXR5VHJhbnNmb3JtKCkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG4gICAgfVxuICAgIGZyb21QYXRoVHJhbnNmb3JtICYmIGFwcGx5VHJhbnNmb3JtT25CZXppZXJzKGZyb21CZXppZXJDdXJ2ZXMsIGZyb21QYXRoVHJhbnNmb3JtKTtcbiAgICB0b1BhdGhUcmFuc2Zvcm0gJiYgYXBwbHlUcmFuc2Zvcm1PbkJlemllcnModG9CZXppZXJDdXJ2ZXMsIHRvUGF0aFRyYW5zZm9ybSk7XG4gICAgc2F2ZUFuZE1vZGlmeU1ldGhvZCh0b1BhdGgsICd1cGRhdGVUcmFuc2Zvcm0nLCB7IHJlcGxhY2U6IHVwZGF0ZUlkZW50aXR5VHJhbnNmb3JtIH0pO1xuICAgIHRvUGF0aC50cmFuc2Zvcm0gPSBudWxsO1xuICAgIHZhciBtb3JwaGluZ0RhdGEgPSBmaW5kQmVzdE1vcnBoaW5nUm90YXRpb24oZnJvbUJlemllckN1cnZlcywgdG9CZXppZXJDdXJ2ZXMsIDEwLCBNYXRoLlBJKTtcbiAgICB2YXIgdG1wQXJyID0gW107XG4gICAgc2F2ZUFuZE1vZGlmeU1ldGhvZCh0b1BhdGgsICdidWlsZFBhdGgnLCB7IHJlcGxhY2U6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRvUGF0aC5fX21vcnBoVDtcbiAgICAgICAgICAgIHZhciBvbmV0ID0gMSAtIHQ7XG4gICAgICAgICAgICB2YXIgbmV3Q3AgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9ycGhpbmdEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBtb3JwaGluZ0RhdGFbaV07XG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSBpdGVtLmZyb207XG4gICAgICAgICAgICAgICAgdmFyIHRvID0gaXRlbS50bztcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBpdGVtLnJvdGF0aW9uICogdDtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbUNwID0gaXRlbS5mcm9tQ3A7XG4gICAgICAgICAgICAgICAgdmFyIHRvQ3AgPSBpdGVtLnRvQ3A7XG4gICAgICAgICAgICAgICAgdmFyIHNhID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgICAgICAgIHZhciBjYSA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICBsZXJwKG5ld0NwLCBmcm9tQ3AsIHRvQ3AsIHQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgZnJvbS5sZW5ndGg7IG0gKz0gMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDBfMSA9IGZyb21bbV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MF8xID0gZnJvbVttICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IHRvW21dO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSB0b1ttICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0geDBfMSAqIG9uZXQgKyB4MSAqIHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0geTBfMSAqIG9uZXQgKyB5MSAqIHQ7XG4gICAgICAgICAgICAgICAgICAgIHRtcEFyclttXSA9ICh4ICogY2EgLSB5ICogc2EpICsgbmV3Q3BbMF07XG4gICAgICAgICAgICAgICAgICAgIHRtcEFyclttICsgMV0gPSAoeCAqIHNhICsgeSAqIGNhKSArIG5ld0NwWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgeDAgPSB0bXBBcnJbMF07XG4gICAgICAgICAgICAgICAgdmFyIHkwID0gdG1wQXJyWzFdO1xuICAgICAgICAgICAgICAgIHBhdGgubW92ZVRvKHgwLCB5MCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDI7IG0gPCBmcm9tLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0gdG1wQXJyW20rK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IHRtcEFyclttKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDIgPSB0bXBBcnJbbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkyID0gdG1wQXJyW20rK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MyA9IHRtcEFyclttKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTMgPSB0bXBBcnJbbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgwID09PSB4MSAmJiB5MCA9PT0geTEgJiYgeDIgPT09IHgzICYmIHkyID09PSB5Mykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5saW5lVG8oeDMsIHkzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4MCA9IHgzO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHkzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtb3JwaFBhdGgoZnJvbVBhdGgsIHRvUGF0aCwgYW5pbWF0aW9uT3B0cykge1xuICAgIGlmICghZnJvbVBhdGggfHwgIXRvUGF0aCkge1xuICAgICAgICByZXR1cm4gdG9QYXRoO1xuICAgIH1cbiAgICB2YXIgb2xkRG9uZSA9IGFuaW1hdGlvbk9wdHMuZG9uZTtcbiAgICB2YXIgb2xkRHVyaW5nID0gYW5pbWF0aW9uT3B0cy5kdXJpbmc7XG4gICAgcHJlcGFyZU1vcnBoUGF0aChmcm9tUGF0aCwgdG9QYXRoKTtcbiAgICB0b1BhdGguX19tb3JwaFQgPSAwO1xuICAgIGZ1bmN0aW9uIHJlc3RvcmVUb1BhdGgoKSB7XG4gICAgICAgIHJlc3RvcmVNZXRob2QodG9QYXRoLCAnYnVpbGRQYXRoJyk7XG4gICAgICAgIHJlc3RvcmVNZXRob2QodG9QYXRoLCAndXBkYXRlVHJhbnNmb3JtJyk7XG4gICAgICAgIHRvUGF0aC5fX21vcnBoVCA9IC0xO1xuICAgICAgICB0b1BhdGguY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgICAgIHRvUGF0aC5kaXJ0eVNoYXBlKCk7XG4gICAgfVxuICAgIHRvUGF0aC5hbmltYXRlVG8oe1xuICAgICAgICBfX21vcnBoVDogMVxuICAgIH0sIGRlZmF1bHRzKHtcbiAgICAgICAgZHVyaW5nOiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgdG9QYXRoLmRpcnR5U2hhcGUoKTtcbiAgICAgICAgICAgIG9sZER1cmluZyAmJiBvbGREdXJpbmcocCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc3RvcmVUb1BhdGgoKTtcbiAgICAgICAgICAgIG9sZERvbmUgJiYgb2xkRG9uZSgpO1xuICAgICAgICB9XG4gICAgfSwgYW5pbWF0aW9uT3B0cykpO1xuICAgIHJldHVybiB0b1BhdGg7XG59XG5mdW5jdGlvbiBoaWxiZXJ0KHgsIHksIG1pblgsIG1pblksIG1heFgsIG1heFkpIHtcbiAgICB2YXIgYml0cyA9IDE2O1xuICAgIHggPSAobWF4WCA9PT0gbWluWCkgPyAwIDogTWF0aC5yb3VuZCgzMjc2NyAqICh4IC0gbWluWCkgLyAobWF4WCAtIG1pblgpKTtcbiAgICB5ID0gKG1heFkgPT09IG1pblkpID8gMCA6IE1hdGgucm91bmQoMzI3NjcgKiAoeSAtIG1pblkpIC8gKG1heFkgLSBtaW5ZKSk7XG4gICAgdmFyIGQgPSAwO1xuICAgIHZhciB0bXA7XG4gICAgZm9yICh2YXIgcyA9ICgxIDw8IGJpdHMpIC8gMjsgcyA+IDA7IHMgLz0gMikge1xuICAgICAgICB2YXIgcnggPSAwO1xuICAgICAgICB2YXIgcnkgPSAwO1xuICAgICAgICBpZiAoKHggJiBzKSA+IDApIHtcbiAgICAgICAgICAgIHJ4ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHkgJiBzKSA+IDApIHtcbiAgICAgICAgICAgIHJ5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBkICs9IHMgKiBzICogKCgzICogcngpIF4gcnkpO1xuICAgICAgICBpZiAocnkgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChyeCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHggPSBzIC0gMSAtIHg7XG4gICAgICAgICAgICAgICAgeSA9IHMgLSAxIC0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtcCA9IHg7XG4gICAgICAgICAgICB4ID0geTtcbiAgICAgICAgICAgIHkgPSB0bXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQ7XG59XG5mdW5jdGlvbiBzb3J0UGF0aHMocGF0aExpc3QpIHtcbiAgICB2YXIgeE1pbiA9IEluZmluaXR5O1xuICAgIHZhciB5TWluID0gSW5maW5pdHk7XG4gICAgdmFyIHhNYXggPSAtSW5maW5pdHk7XG4gICAgdmFyIHlNYXggPSAtSW5maW5pdHk7XG4gICAgdmFyIGNwcyA9IG1hcChwYXRoTGlzdCwgZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB2YXIgbSA9IHBhdGguZ2V0Q29tcHV0ZWRUcmFuc2Zvcm0oKTtcbiAgICAgICAgdmFyIHggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMiArIChtID8gbVs0XSA6IDApO1xuICAgICAgICB2YXIgeSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiArIChtID8gbVs1XSA6IDApO1xuICAgICAgICB4TWluID0gTWF0aC5taW4oeCwgeE1pbik7XG4gICAgICAgIHlNaW4gPSBNYXRoLm1pbih5LCB5TWluKTtcbiAgICAgICAgeE1heCA9IE1hdGgubWF4KHgsIHhNYXgpO1xuICAgICAgICB5TWF4ID0gTWF0aC5tYXgoeSwgeU1heCk7XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfSk7XG4gICAgdmFyIGl0ZW1zID0gbWFwKGNwcywgZnVuY3Rpb24gKGNwLCBpZHgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNwOiBjcCxcbiAgICAgICAgICAgIHo6IGhpbGJlcnQoY3BbMF0sIGNwWzFdLCB4TWluLCB5TWluLCB4TWF4LCB5TWF4KSxcbiAgICAgICAgICAgIHBhdGg6IHBhdGhMaXN0W2lkeF1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlbXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS56IC0gYi56OyB9KS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ucGF0aDsgfSk7XG59XG47XG5mdW5jdGlvbiBkZWZhdWx0RGl2aWRlUGF0aChwYXJhbSkge1xuICAgIHJldHVybiBzcGxpdChwYXJhbS5wYXRoLCBwYXJhbS5jb3VudCk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eVJldHVybigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tSW5kaXZpZHVhbHM6IFtdLFxuICAgICAgICB0b0luZGl2aWR1YWxzOiBbXSxcbiAgICAgICAgY291bnQ6IDBcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVNb3JwaChmcm9tTGlzdCwgdG9QYXRoLCBhbmltYXRpb25PcHRzKSB7XG4gICAgdmFyIGZyb21QYXRoTGlzdCA9IFtdO1xuICAgIGZ1bmN0aW9uIGFkZEZyb21QYXRoKGZyb21MaXN0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJvbUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmcm9tID0gZnJvbUxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXNDb21iaW5lTW9ycGhpbmcoZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBhZGRGcm9tUGF0aChmcm9tLmNoaWxkcmVuUmVmKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICAgICAgICAgICAgICBmcm9tUGF0aExpc3QucHVzaChmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRGcm9tUGF0aChmcm9tTGlzdCk7XG4gICAgdmFyIHNlcGFyYXRlQ291bnQgPSBmcm9tUGF0aExpc3QubGVuZ3RoO1xuICAgIGlmICghc2VwYXJhdGVDb3VudCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlSZXR1cm4oKTtcbiAgICB9XG4gICAgdmFyIGRpdmlkZVBhdGggPSBhbmltYXRpb25PcHRzLmRpdmlkZVBhdGggfHwgZGVmYXVsdERpdmlkZVBhdGg7XG4gICAgdmFyIHRvU3ViUGF0aExpc3QgPSBkaXZpZGVQYXRoKHtcbiAgICAgICAgcGF0aDogdG9QYXRoLCBjb3VudDogc2VwYXJhdGVDb3VudFxuICAgIH0pO1xuICAgIGlmICh0b1N1YlBhdGhMaXN0Lmxlbmd0aCAhPT0gc2VwYXJhdGVDb3VudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIG1vcnBoaW5nOiB1bm1hdGNoZWQgc3BsaXR0ZWQgcGF0aCcpO1xuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlSZXR1cm4oKTtcbiAgICB9XG4gICAgZnJvbVBhdGhMaXN0ID0gc29ydFBhdGhzKGZyb21QYXRoTGlzdCk7XG4gICAgdG9TdWJQYXRoTGlzdCA9IHNvcnRQYXRocyh0b1N1YlBhdGhMaXN0KTtcbiAgICB2YXIgb2xkRG9uZSA9IGFuaW1hdGlvbk9wdHMuZG9uZTtcbiAgICB2YXIgb2xkRHVyaW5nID0gYW5pbWF0aW9uT3B0cy5kdXJpbmc7XG4gICAgdmFyIGluZGl2aWR1YWxEZWxheSA9IGFuaW1hdGlvbk9wdHMuaW5kaXZpZHVhbERlbGF5O1xuICAgIHZhciBpZGVudGl0eVRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm1hYmxlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXBhcmF0ZUNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIGZyb20gPSBmcm9tUGF0aExpc3RbaV07XG4gICAgICAgIHZhciB0byA9IHRvU3ViUGF0aExpc3RbaV07XG4gICAgICAgIHRvLnBhcmVudCA9IHRvUGF0aDtcbiAgICAgICAgdG8uY29weVRyYW5zZm9ybShpZGVudGl0eVRyYW5zZm9ybSk7XG4gICAgICAgIGlmICghaW5kaXZpZHVhbERlbGF5KSB7XG4gICAgICAgICAgICBwcmVwYXJlTW9ycGhQYXRoKGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1BhdGguX19pc0NvbWJpbmVNb3JwaGluZyA9IHRydWU7XG4gICAgdG9QYXRoLmNoaWxkcmVuUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdG9TdWJQYXRoTGlzdDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGFkZFRvU3ViUGF0aExpc3RUb1pyKHpyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9TdWJQYXRoTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9TdWJQYXRoTGlzdFtpXS5hZGRTZWxmVG9acih6cik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2F2ZUFuZE1vZGlmeU1ldGhvZCh0b1BhdGgsICdhZGRTZWxmVG9acicsIHtcbiAgICAgICAgYWZ0ZXI6IGZ1bmN0aW9uICh6cikge1xuICAgICAgICAgICAgYWRkVG9TdWJQYXRoTGlzdFRvWnIoenIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgc2F2ZUFuZE1vZGlmeU1ldGhvZCh0b1BhdGgsICdyZW1vdmVTZWxmRnJvbVpyJywge1xuICAgICAgICBhZnRlcjogZnVuY3Rpb24gKHpyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvU3ViUGF0aExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b1N1YlBhdGhMaXN0W2ldLnJlbW92ZVNlbGZGcm9tWnIoenIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcmVzdG9yZVRvUGF0aCgpIHtcbiAgICAgICAgdG9QYXRoLl9faXNDb21iaW5lTW9ycGhpbmcgPSBmYWxzZTtcbiAgICAgICAgdG9QYXRoLl9fbW9ycGhUID0gLTE7XG4gICAgICAgIHRvUGF0aC5jaGlsZHJlblJlZiA9IG51bGw7XG4gICAgICAgIHJlc3RvcmVNZXRob2QodG9QYXRoLCAnYWRkU2VsZlRvWnInKTtcbiAgICAgICAgcmVzdG9yZU1ldGhvZCh0b1BhdGgsICdyZW1vdmVTZWxmRnJvbVpyJyk7XG4gICAgfVxuICAgIHZhciB0b0xlbiA9IHRvU3ViUGF0aExpc3QubGVuZ3RoO1xuICAgIGlmIChpbmRpdmlkdWFsRGVsYXkpIHtcbiAgICAgICAgdmFyIGFuaW1hdGluZ18xID0gdG9MZW47XG4gICAgICAgIHZhciBlYWNoRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFuaW1hdGluZ18xLS07XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW5nXzEgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN0b3JlVG9QYXRoKCk7XG4gICAgICAgICAgICAgICAgb2xkRG9uZSAmJiBvbGREb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9MZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGluZGl2ZHVhbEFuaW1hdGlvbk9wdHMgPSBpbmRpdmlkdWFsRGVsYXkgPyBkZWZhdWx0cyh7XG4gICAgICAgICAgICAgICAgZGVsYXk6IChhbmltYXRpb25PcHRzLmRlbGF5IHx8IDApICsgaW5kaXZpZHVhbERlbGF5KGksIHRvTGVuLCBmcm9tUGF0aExpc3RbaV0sIHRvU3ViUGF0aExpc3RbaV0pLFxuICAgICAgICAgICAgICAgIGRvbmU6IGVhY2hEb25lXG4gICAgICAgICAgICB9LCBhbmltYXRpb25PcHRzKSA6IGFuaW1hdGlvbk9wdHM7XG4gICAgICAgICAgICBtb3JwaFBhdGgoZnJvbVBhdGhMaXN0W2ldLCB0b1N1YlBhdGhMaXN0W2ldLCBpbmRpdmR1YWxBbmltYXRpb25PcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdG9QYXRoLl9fbW9ycGhUID0gMDtcbiAgICAgICAgdG9QYXRoLmFuaW1hdGVUbyh7XG4gICAgICAgICAgICBfX21vcnBoVDogMVxuICAgICAgICB9LCBkZWZhdWx0cyh7XG4gICAgICAgICAgICBkdXJpbmc6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRvU3ViUGF0aExpc3RbaV07XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLl9fbW9ycGhUID0gdG9QYXRoLl9fbW9ycGhUO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kaXJ0eVNoYXBlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9sZER1cmluZyAmJiBvbGREdXJpbmcocCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3RvcmVUb1BhdGgoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyb21MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmVNZXRob2QoZnJvbUxpc3RbaV0sICd1cGRhdGVUcmFuc2Zvcm0nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2xkRG9uZSAmJiBvbGREb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGFuaW1hdGlvbk9wdHMpKTtcbiAgICB9XG4gICAgaWYgKHRvUGF0aC5fX3pyKSB7XG4gICAgICAgIGFkZFRvU3ViUGF0aExpc3RUb1pyKHRvUGF0aC5fX3pyKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbUluZGl2aWR1YWxzOiBmcm9tUGF0aExpc3QsXG4gICAgICAgIHRvSW5kaXZpZHVhbHM6IHRvU3ViUGF0aExpc3QsXG4gICAgICAgIGNvdW50OiB0b0xlblxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gc2VwYXJhdGVNb3JwaChmcm9tUGF0aCwgdG9QYXRoTGlzdCwgYW5pbWF0aW9uT3B0cykge1xuICAgIHZhciB0b0xlbiA9IHRvUGF0aExpc3QubGVuZ3RoO1xuICAgIHZhciBmcm9tUGF0aExpc3QgPSBbXTtcbiAgICB2YXIgZGl2aWRlUGF0aCA9IGFuaW1hdGlvbk9wdHMuZGl2aWRlUGF0aCB8fCBkZWZhdWx0RGl2aWRlUGF0aDtcbiAgICBmdW5jdGlvbiBhZGRGcm9tUGF0aChmcm9tTGlzdCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyb21MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IGZyb21MaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGlzQ29tYmluZU1vcnBoaW5nKGZyb20pKSB7XG4gICAgICAgICAgICAgICAgYWRkRnJvbVBhdGgoZnJvbS5jaGlsZHJlblJlZigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb20gaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgICAgICAgICAgICAgZnJvbVBhdGhMaXN0LnB1c2goZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQ29tYmluZU1vcnBoaW5nKGZyb21QYXRoKSkge1xuICAgICAgICBhZGRGcm9tUGF0aChmcm9tUGF0aC5jaGlsZHJlblJlZigpKTtcbiAgICAgICAgdmFyIGZyb21MZW4gPSBmcm9tUGF0aExpc3QubGVuZ3RoO1xuICAgICAgICBpZiAoZnJvbUxlbiA8IHRvTGVuKSB7XG4gICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZnJvbUxlbjsgaSA8IHRvTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmcm9tUGF0aExpc3QucHVzaChjbG9uZVBhdGgoZnJvbVBhdGhMaXN0W2srKyAlIGZyb21MZW5dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnJvbVBhdGhMaXN0Lmxlbmd0aCA9IHRvTGVuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZnJvbVBhdGhMaXN0ID0gZGl2aWRlUGF0aCh7IHBhdGg6IGZyb21QYXRoLCBjb3VudDogdG9MZW4gfSk7XG4gICAgICAgIHZhciBmcm9tUGF0aFRyYW5zZm9ybSA9IGZyb21QYXRoLmdldENvbXB1dGVkVHJhbnNmb3JtKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJvbVBhdGhMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmcm9tUGF0aExpc3RbaV0uc2V0TG9jYWxUcmFuc2Zvcm0oZnJvbVBhdGhUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tUGF0aExpc3QubGVuZ3RoICE9PSB0b0xlbikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBtb3JwaGluZzogdW5tYXRjaGVkIHNwbGl0dGVkIHBhdGgnKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbXB0eVJldHVybigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21QYXRoTGlzdCA9IHNvcnRQYXRocyhmcm9tUGF0aExpc3QpO1xuICAgIHRvUGF0aExpc3QgPSBzb3J0UGF0aHModG9QYXRoTGlzdCk7XG4gICAgdmFyIGluZGl2aWR1YWxEZWxheSA9IGFuaW1hdGlvbk9wdHMuaW5kaXZpZHVhbERlbGF5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9MZW47IGkrKykge1xuICAgICAgICB2YXIgaW5kaXZkdWFsQW5pbWF0aW9uT3B0cyA9IGluZGl2aWR1YWxEZWxheSA/IGRlZmF1bHRzKHtcbiAgICAgICAgICAgIGRlbGF5OiAoYW5pbWF0aW9uT3B0cy5kZWxheSB8fCAwKSArIGluZGl2aWR1YWxEZWxheShpLCB0b0xlbiwgZnJvbVBhdGhMaXN0W2ldLCB0b1BhdGhMaXN0W2ldKVxuICAgICAgICB9LCBhbmltYXRpb25PcHRzKSA6IGFuaW1hdGlvbk9wdHM7XG4gICAgICAgIG1vcnBoUGF0aChmcm9tUGF0aExpc3RbaV0sIHRvUGF0aExpc3RbaV0sIGluZGl2ZHVhbEFuaW1hdGlvbk9wdHMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tSW5kaXZpZHVhbHM6IGZyb21QYXRoTGlzdCxcbiAgICAgICAgdG9JbmRpdmlkdWFsczogdG9QYXRoTGlzdCxcbiAgICAgICAgY291bnQ6IHRvUGF0aExpc3QubGVuZ3RoXG4gICAgfTtcbn1cbmV4cG9ydCB7IHNwbGl0IGFzIGRlZmF1bHREaXZpZGVQYXRoIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///97850\n")}}]);