"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[2928],{5638:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Jw: () => (/* binding */ getAnimationConfig),\n/* harmony export */   LR: () => (/* binding */ isElementRemoved),\n/* harmony export */   LW: () => (/* binding */ initProps),\n/* harmony export */   Nz: () => (/* binding */ removeElement),\n/* harmony export */   Xr: () => (/* binding */ getOldStyle),\n/* harmony export */   ap: () => (/* binding */ saveOldStyle),\n/* harmony export */   oi: () => (/* binding */ updateProps),\n/* harmony export */   t5: () => (/* binding */ removeElementWithFadeOut)\n/* harmony export */ });\n/* unused harmony export transitionStore */\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n// Stored properties for further transition.\nvar transitionStore = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\n/**\r\n * Return null if animation is disabled.\r\n */\nfunction getAnimationConfig(animationType, animatableModel, dataIndex,\n// Extra opts can override the option in animatable model.\nextraOpts,\n// TODO It's only for pictorial bar now.\nextraDelayParams) {\n  var animationPayload;\n  // Check if there is global animation configuration from dataZoom/resize can override the config in option.\n  // If animation is enabled. Will use this animation config in payload.\n  // If animation is disabled. Just ignore it.\n  if (animatableModel && animatableModel.ecModel) {\n    var updatePayload = animatableModel.ecModel.getUpdatePayload();\n    animationPayload = updatePayload && updatePayload.animation;\n  }\n  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n  var isUpdate = animationType === 'update';\n  if (animationEnabled) {\n    var duration = void 0;\n    var easing = void 0;\n    var delay = void 0;\n    if (extraOpts) {\n      duration = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(extraOpts.duration, 200);\n      easing = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(extraOpts.easing, 'cubicOut');\n      delay = 0;\n    } else {\n      duration = animatableModel.getShallow(isUpdate ? 'animationDurationUpdate' : 'animationDuration');\n      easing = animatableModel.getShallow(isUpdate ? 'animationEasingUpdate' : 'animationEasing');\n      delay = animatableModel.getShallow(isUpdate ? 'animationDelayUpdate' : 'animationDelay');\n    }\n    // animation from payload has highest priority.\n    if (animationPayload) {\n      animationPayload.duration != null && (duration = animationPayload.duration);\n      animationPayload.easing != null && (easing = animationPayload.easing);\n      animationPayload.delay != null && (delay = animationPayload.delay);\n    }\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(delay)) {\n      delay = delay(dataIndex, extraDelayParams);\n    }\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(duration)) {\n      duration = duration(dataIndex);\n    }\n    var config = {\n      duration: duration || 0,\n      delay: delay,\n      easing: easing\n    };\n    return config;\n  } else {\n    return null;\n  }\n}\nfunction animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {\n  var isFrom = false;\n  var removeOpt;\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataIndex)) {\n    during = cb;\n    cb = dataIndex;\n    dataIndex = null;\n  } else if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(dataIndex)) {\n    cb = dataIndex.cb;\n    during = dataIndex.during;\n    isFrom = dataIndex.isFrom;\n    removeOpt = dataIndex.removeOpt;\n    dataIndex = dataIndex.dataIndex;\n  }\n  var isRemove = animationType === 'leave';\n  if (!isRemove) {\n    // Must stop the remove animation.\n    el.stopAnimation('leave');\n  }\n  var animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);\n  if (animationConfig && animationConfig.duration > 0) {\n    var duration = animationConfig.duration;\n    var animationDelay = animationConfig.delay;\n    var animationEasing = animationConfig.easing;\n    var animateConfig = {\n      duration: duration,\n      delay: animationDelay || 0,\n      easing: animationEasing,\n      done: cb,\n      force: !!cb || !!during,\n      // Set to final state in update/init animation.\n      // So the post processing based on the path shape can be done correctly.\n      setToFinal: !isRemove,\n      scope: animationType,\n      during: during\n    };\n    isFrom ? el.animateFrom(props, animateConfig) : el.animateTo(props, animateConfig);\n  } else {\n    el.stopAnimation();\n    // If `isFrom`, the props is the \"from\" props.\n    !isFrom && el.attr(props);\n    // Call during at least once.\n    during && during(1);\n    cb && cb();\n  }\n}\n/**\r\n * Update graphic element properties with or without animation according to the\r\n * configuration in series.\r\n *\r\n * Caution: this method will stop previous animation.\r\n * So do not use this method to one element twice before\r\n * animation starts, unless you know what you are doing.\r\n * @example\r\n *     graphic.updateProps(el, {\r\n *         position: [100, 100]\r\n *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\r\n *     // Or\r\n *     graphic.updateProps(el, {\r\n *         position: [100, 100]\r\n *     }, seriesModel, function () { console.log('Animation done!'); });\r\n */\nfunction updateProps(el, props,\n// TODO: TYPE AnimatableModel\nanimatableModel, dataIndex, cb, during) {\n  animateOrSetProps('update', el, props, animatableModel, dataIndex, cb, during);\n}\n\n/**\r\n * Init graphic element properties with or without animation according to the\r\n * configuration in series.\r\n *\r\n * Caution: this method will stop previous animation.\r\n * So do not use this method to one element twice before\r\n * animation starts, unless you know what you are doing.\r\n */\nfunction initProps(el, props, animatableModel, dataIndex, cb, during) {\n  animateOrSetProps('enter', el, props, animatableModel, dataIndex, cb, during);\n}\n/**\r\n * If element is removed.\r\n * It can determine if element is having remove animation.\r\n */\nfunction isElementRemoved(el) {\n  if (!el.__zr) {\n    return true;\n  }\n  for (var i = 0; i < el.animators.length; i++) {\n    var animator = el.animators[i];\n    if (animator.scope === 'leave') {\n      return true;\n    }\n  }\n  return false;\n}\n/**\r\n * Remove graphic element\r\n */\nfunction removeElement(el, props, animatableModel, dataIndex, cb, during) {\n  // Don't do remove animation twice.\n  if (isElementRemoved(el)) {\n    return;\n  }\n  animateOrSetProps('leave', el, props, animatableModel, dataIndex, cb, during);\n}\nfunction fadeOutDisplayable(el, animatableModel, dataIndex, done) {\n  el.removeTextContent();\n  el.removeTextGuideLine();\n  removeElement(el, {\n    style: {\n      opacity: 0\n    }\n  }, animatableModel, dataIndex, done);\n}\nfunction removeElementWithFadeOut(el, animatableModel, dataIndex) {\n  function doRemove() {\n    el.parent && el.parent.remove(el);\n  }\n  // Hide label and labelLine first\n  // TODO Also use fade out animation?\n  if (!el.isGroup) {\n    fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);\n  } else {\n    el.traverse(function (disp) {\n      if (!disp.isGroup) {\n        // Can invoke doRemove multiple times.\n        fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);\n      }\n    });\n  }\n}\n/**\r\n * Save old style for style transition in universalTransition module.\r\n * It's used when element will be reused in each render.\r\n * For chart like map, heatmap, which will always create new element.\r\n * We don't need to save this because universalTransition can get old style from the old element\r\n */\nfunction saveOldStyle(el) {\n  transitionStore(el).oldStyle = el.style;\n}\nfunction getOldStyle(el) {\n  return transitionStore(el).oldStyle;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYzOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2FuaW1hdGlvbi9iYXNpY1RyYW5zaXRpb24uanM/Yzc1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGlzRnVuY3Rpb24sIGlzT2JqZWN0LCByZXRyaWV2ZTIgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgbWFrZUlubmVyIH0gZnJvbSAnLi4vdXRpbC9tb2RlbC5qcyc7XG4vLyBTdG9yZWQgcHJvcGVydGllcyBmb3IgZnVydGhlciB0cmFuc2l0aW9uLlxuZXhwb3J0IHZhciB0cmFuc2l0aW9uU3RvcmUgPSBtYWtlSW5uZXIoKTtcbi8qKlxyXG4gKiBSZXR1cm4gbnVsbCBpZiBhbmltYXRpb24gaXMgZGlzYWJsZWQuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFuaW1hdGlvbkNvbmZpZyhhbmltYXRpb25UeXBlLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCxcbi8vIEV4dHJhIG9wdHMgY2FuIG92ZXJyaWRlIHRoZSBvcHRpb24gaW4gYW5pbWF0YWJsZSBtb2RlbC5cbmV4dHJhT3B0cyxcbi8vIFRPRE8gSXQncyBvbmx5IGZvciBwaWN0b3JpYWwgYmFyIG5vdy5cbmV4dHJhRGVsYXlQYXJhbXMpIHtcbiAgdmFyIGFuaW1hdGlvblBheWxvYWQ7XG4gIC8vIENoZWNrIGlmIHRoZXJlIGlzIGdsb2JhbCBhbmltYXRpb24gY29uZmlndXJhdGlvbiBmcm9tIGRhdGFab29tL3Jlc2l6ZSBjYW4gb3ZlcnJpZGUgdGhlIGNvbmZpZyBpbiBvcHRpb24uXG4gIC8vIElmIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBXaWxsIHVzZSB0aGlzIGFuaW1hdGlvbiBjb25maWcgaW4gcGF5bG9hZC5cbiAgLy8gSWYgYW5pbWF0aW9uIGlzIGRpc2FibGVkLiBKdXN0IGlnbm9yZSBpdC5cbiAgaWYgKGFuaW1hdGFibGVNb2RlbCAmJiBhbmltYXRhYmxlTW9kZWwuZWNNb2RlbCkge1xuICAgIHZhciB1cGRhdGVQYXlsb2FkID0gYW5pbWF0YWJsZU1vZGVsLmVjTW9kZWwuZ2V0VXBkYXRlUGF5bG9hZCgpO1xuICAgIGFuaW1hdGlvblBheWxvYWQgPSB1cGRhdGVQYXlsb2FkICYmIHVwZGF0ZVBheWxvYWQuYW5pbWF0aW9uO1xuICB9XG4gIHZhciBhbmltYXRpb25FbmFibGVkID0gYW5pbWF0YWJsZU1vZGVsICYmIGFuaW1hdGFibGVNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKTtcbiAgdmFyIGlzVXBkYXRlID0gYW5pbWF0aW9uVHlwZSA9PT0gJ3VwZGF0ZSc7XG4gIGlmIChhbmltYXRpb25FbmFibGVkKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gdm9pZCAwO1xuICAgIHZhciBlYXNpbmcgPSB2b2lkIDA7XG4gICAgdmFyIGRlbGF5ID0gdm9pZCAwO1xuICAgIGlmIChleHRyYU9wdHMpIHtcbiAgICAgIGR1cmF0aW9uID0gcmV0cmlldmUyKGV4dHJhT3B0cy5kdXJhdGlvbiwgMjAwKTtcbiAgICAgIGVhc2luZyA9IHJldHJpZXZlMihleHRyYU9wdHMuZWFzaW5nLCAnY3ViaWNPdXQnKTtcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZHVyYXRpb24gPSBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdyhpc1VwZGF0ZSA/ICdhbmltYXRpb25EdXJhdGlvblVwZGF0ZScgOiAnYW5pbWF0aW9uRHVyYXRpb24nKTtcbiAgICAgIGVhc2luZyA9IGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KGlzVXBkYXRlID8gJ2FuaW1hdGlvbkVhc2luZ1VwZGF0ZScgOiAnYW5pbWF0aW9uRWFzaW5nJyk7XG4gICAgICBkZWxheSA9IGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KGlzVXBkYXRlID8gJ2FuaW1hdGlvbkRlbGF5VXBkYXRlJyA6ICdhbmltYXRpb25EZWxheScpO1xuICAgIH1cbiAgICAvLyBhbmltYXRpb24gZnJvbSBwYXlsb2FkIGhhcyBoaWdoZXN0IHByaW9yaXR5LlxuICAgIGlmIChhbmltYXRpb25QYXlsb2FkKSB7XG4gICAgICBhbmltYXRpb25QYXlsb2FkLmR1cmF0aW9uICE9IG51bGwgJiYgKGR1cmF0aW9uID0gYW5pbWF0aW9uUGF5bG9hZC5kdXJhdGlvbik7XG4gICAgICBhbmltYXRpb25QYXlsb2FkLmVhc2luZyAhPSBudWxsICYmIChlYXNpbmcgPSBhbmltYXRpb25QYXlsb2FkLmVhc2luZyk7XG4gICAgICBhbmltYXRpb25QYXlsb2FkLmRlbGF5ICE9IG51bGwgJiYgKGRlbGF5ID0gYW5pbWF0aW9uUGF5bG9hZC5kZWxheSk7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKGRlbGF5KSkge1xuICAgICAgZGVsYXkgPSBkZWxheShkYXRhSW5kZXgsIGV4dHJhRGVsYXlQYXJhbXMpO1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbihkdXJhdGlvbikpIHtcbiAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24oZGF0YUluZGV4KTtcbiAgICB9XG4gICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiB8fCAwLFxuICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgZWFzaW5nOiBlYXNpbmdcbiAgICB9O1xuICAgIHJldHVybiBjb25maWc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGFuaW1hdGVPclNldFByb3BzKGFuaW1hdGlvblR5cGUsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiLCBkdXJpbmcpIHtcbiAgdmFyIGlzRnJvbSA9IGZhbHNlO1xuICB2YXIgcmVtb3ZlT3B0O1xuICBpZiAoaXNGdW5jdGlvbihkYXRhSW5kZXgpKSB7XG4gICAgZHVyaW5nID0gY2I7XG4gICAgY2IgPSBkYXRhSW5kZXg7XG4gICAgZGF0YUluZGV4ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhSW5kZXgpKSB7XG4gICAgY2IgPSBkYXRhSW5kZXguY2I7XG4gICAgZHVyaW5nID0gZGF0YUluZGV4LmR1cmluZztcbiAgICBpc0Zyb20gPSBkYXRhSW5kZXguaXNGcm9tO1xuICAgIHJlbW92ZU9wdCA9IGRhdGFJbmRleC5yZW1vdmVPcHQ7XG4gICAgZGF0YUluZGV4ID0gZGF0YUluZGV4LmRhdGFJbmRleDtcbiAgfVxuICB2YXIgaXNSZW1vdmUgPSBhbmltYXRpb25UeXBlID09PSAnbGVhdmUnO1xuICBpZiAoIWlzUmVtb3ZlKSB7XG4gICAgLy8gTXVzdCBzdG9wIHRoZSByZW1vdmUgYW5pbWF0aW9uLlxuICAgIGVsLnN0b3BBbmltYXRpb24oJ2xlYXZlJyk7XG4gIH1cbiAgdmFyIGFuaW1hdGlvbkNvbmZpZyA9IGdldEFuaW1hdGlvbkNvbmZpZyhhbmltYXRpb25UeXBlLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgaXNSZW1vdmUgPyByZW1vdmVPcHQgfHwge30gOiBudWxsLCBhbmltYXRhYmxlTW9kZWwgJiYgYW5pbWF0YWJsZU1vZGVsLmdldEFuaW1hdGlvbkRlbGF5UGFyYW1zID8gYW5pbWF0YWJsZU1vZGVsLmdldEFuaW1hdGlvbkRlbGF5UGFyYW1zKGVsLCBkYXRhSW5kZXgpIDogbnVsbCk7XG4gIGlmIChhbmltYXRpb25Db25maWcgJiYgYW5pbWF0aW9uQ29uZmlnLmR1cmF0aW9uID4gMCkge1xuICAgIHZhciBkdXJhdGlvbiA9IGFuaW1hdGlvbkNvbmZpZy5kdXJhdGlvbjtcbiAgICB2YXIgYW5pbWF0aW9uRGVsYXkgPSBhbmltYXRpb25Db25maWcuZGVsYXk7XG4gICAgdmFyIGFuaW1hdGlvbkVhc2luZyA9IGFuaW1hdGlvbkNvbmZpZy5lYXNpbmc7XG4gICAgdmFyIGFuaW1hdGVDb25maWcgPSB7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBkZWxheTogYW5pbWF0aW9uRGVsYXkgfHwgMCxcbiAgICAgIGVhc2luZzogYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgZG9uZTogY2IsXG4gICAgICBmb3JjZTogISFjYiB8fCAhIWR1cmluZyxcbiAgICAgIC8vIFNldCB0byBmaW5hbCBzdGF0ZSBpbiB1cGRhdGUvaW5pdCBhbmltYXRpb24uXG4gICAgICAvLyBTbyB0aGUgcG9zdCBwcm9jZXNzaW5nIGJhc2VkIG9uIHRoZSBwYXRoIHNoYXBlIGNhbiBiZSBkb25lIGNvcnJlY3RseS5cbiAgICAgIHNldFRvRmluYWw6ICFpc1JlbW92ZSxcbiAgICAgIHNjb3BlOiBhbmltYXRpb25UeXBlLFxuICAgICAgZHVyaW5nOiBkdXJpbmdcbiAgICB9O1xuICAgIGlzRnJvbSA/IGVsLmFuaW1hdGVGcm9tKHByb3BzLCBhbmltYXRlQ29uZmlnKSA6IGVsLmFuaW1hdGVUbyhwcm9wcywgYW5pbWF0ZUNvbmZpZyk7XG4gIH0gZWxzZSB7XG4gICAgZWwuc3RvcEFuaW1hdGlvbigpO1xuICAgIC8vIElmIGBpc0Zyb21gLCB0aGUgcHJvcHMgaXMgdGhlIFwiZnJvbVwiIHByb3BzLlxuICAgICFpc0Zyb20gJiYgZWwuYXR0cihwcm9wcyk7XG4gICAgLy8gQ2FsbCBkdXJpbmcgYXQgbGVhc3Qgb25jZS5cbiAgICBkdXJpbmcgJiYgZHVyaW5nKDEpO1xuICAgIGNiICYmIGNiKCk7XG4gIH1cbn1cbi8qKlxyXG4gKiBVcGRhdGUgZ3JhcGhpYyBlbGVtZW50IHByb3BlcnRpZXMgd2l0aCBvciB3aXRob3V0IGFuaW1hdGlvbiBhY2NvcmRpbmcgdG8gdGhlXHJcbiAqIGNvbmZpZ3VyYXRpb24gaW4gc2VyaWVzLlxyXG4gKlxyXG4gKiBDYXV0aW9uOiB0aGlzIG1ldGhvZCB3aWxsIHN0b3AgcHJldmlvdXMgYW5pbWF0aW9uLlxyXG4gKiBTbyBkbyBub3QgdXNlIHRoaXMgbWV0aG9kIHRvIG9uZSBlbGVtZW50IHR3aWNlIGJlZm9yZVxyXG4gKiBhbmltYXRpb24gc3RhcnRzLCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xyXG4gKiAgICAgICAgIHBvc2l0aW9uOiBbMTAwLCAxMDBdXHJcbiAqICAgICB9LCBzZXJpZXNNb2RlbCwgZGF0YUluZGV4LCBmdW5jdGlvbiAoKSB7IGNvbnNvbGUubG9nKCdBbmltYXRpb24gZG9uZSEnKTsgfSk7XHJcbiAqICAgICAvLyBPclxyXG4gKiAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xyXG4gKiAgICAgICAgIHBvc2l0aW9uOiBbMTAwLCAxMDBdXHJcbiAqICAgICB9LCBzZXJpZXNNb2RlbCwgZnVuY3Rpb24gKCkgeyBjb25zb2xlLmxvZygnQW5pbWF0aW9uIGRvbmUhJyk7IH0pO1xyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGVsLCBwcm9wcyxcbi8vIFRPRE86IFRZUEUgQW5pbWF0YWJsZU1vZGVsXG5hbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IsIGR1cmluZykge1xuICBhbmltYXRlT3JTZXRQcm9wcygndXBkYXRlJywgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IsIGR1cmluZyk7XG59XG5leHBvcnQgeyB1cGRhdGVQcm9wcyB9O1xuLyoqXHJcbiAqIEluaXQgZ3JhcGhpYyBlbGVtZW50IHByb3BlcnRpZXMgd2l0aCBvciB3aXRob3V0IGFuaW1hdGlvbiBhY2NvcmRpbmcgdG8gdGhlXHJcbiAqIGNvbmZpZ3VyYXRpb24gaW4gc2VyaWVzLlxyXG4gKlxyXG4gKiBDYXV0aW9uOiB0aGlzIG1ldGhvZCB3aWxsIHN0b3AgcHJldmlvdXMgYW5pbWF0aW9uLlxyXG4gKiBTbyBkbyBub3QgdXNlIHRoaXMgbWV0aG9kIHRvIG9uZSBlbGVtZW50IHR3aWNlIGJlZm9yZVxyXG4gKiBhbmltYXRpb24gc3RhcnRzLCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0UHJvcHMoZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IsIGR1cmluZykge1xuICBhbmltYXRlT3JTZXRQcm9wcygnZW50ZXInLCBlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgZGF0YUluZGV4LCBjYiwgZHVyaW5nKTtcbn1cbi8qKlxyXG4gKiBJZiBlbGVtZW50IGlzIHJlbW92ZWQuXHJcbiAqIEl0IGNhbiBkZXRlcm1pbmUgaWYgZWxlbWVudCBpcyBoYXZpbmcgcmVtb3ZlIGFuaW1hdGlvbi5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50UmVtb3ZlZChlbCkge1xuICBpZiAoIWVsLl9fenIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsLmFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhbmltYXRvciA9IGVsLmFuaW1hdG9yc1tpXTtcbiAgICBpZiAoYW5pbWF0b3Iuc2NvcGUgPT09ICdsZWF2ZScpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcclxuICogUmVtb3ZlIGdyYXBoaWMgZWxlbWVudFxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiLCBkdXJpbmcpIHtcbiAgLy8gRG9uJ3QgZG8gcmVtb3ZlIGFuaW1hdGlvbiB0d2ljZS5cbiAgaWYgKGlzRWxlbWVudFJlbW92ZWQoZWwpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFuaW1hdGVPclNldFByb3BzKCdsZWF2ZScsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiLCBkdXJpbmcpO1xufVxuZnVuY3Rpb24gZmFkZU91dERpc3BsYXlhYmxlKGVsLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgZG9uZSkge1xuICBlbC5yZW1vdmVUZXh0Q29udGVudCgpO1xuICBlbC5yZW1vdmVUZXh0R3VpZGVMaW5lKCk7XG4gIHJlbW92ZUVsZW1lbnQoZWwsIHtcbiAgICBzdHlsZToge1xuICAgICAgb3BhY2l0eTogMFxuICAgIH1cbiAgfSwgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGRvbmUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnRXaXRoRmFkZU91dChlbCwgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgpIHtcbiAgZnVuY3Rpb24gZG9SZW1vdmUoKSB7XG4gICAgZWwucGFyZW50ICYmIGVsLnBhcmVudC5yZW1vdmUoZWwpO1xuICB9XG4gIC8vIEhpZGUgbGFiZWwgYW5kIGxhYmVsTGluZSBmaXJzdFxuICAvLyBUT0RPIEFsc28gdXNlIGZhZGUgb3V0IGFuaW1hdGlvbj9cbiAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgZmFkZU91dERpc3BsYXlhYmxlKGVsLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgZG9SZW1vdmUpO1xuICB9IGVsc2Uge1xuICAgIGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChkaXNwKSB7XG4gICAgICBpZiAoIWRpc3AuaXNHcm91cCkge1xuICAgICAgICAvLyBDYW4gaW52b2tlIGRvUmVtb3ZlIG11bHRpcGxlIHRpbWVzLlxuICAgICAgICBmYWRlT3V0RGlzcGxheWFibGUoZGlzcCwgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGRvUmVtb3ZlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuLyoqXHJcbiAqIFNhdmUgb2xkIHN0eWxlIGZvciBzdHlsZSB0cmFuc2l0aW9uIGluIHVuaXZlcnNhbFRyYW5zaXRpb24gbW9kdWxlLlxyXG4gKiBJdCdzIHVzZWQgd2hlbiBlbGVtZW50IHdpbGwgYmUgcmV1c2VkIGluIGVhY2ggcmVuZGVyLlxyXG4gKiBGb3IgY2hhcnQgbGlrZSBtYXAsIGhlYXRtYXAsIHdoaWNoIHdpbGwgYWx3YXlzIGNyZWF0ZSBuZXcgZWxlbWVudC5cclxuICogV2UgZG9uJ3QgbmVlZCB0byBzYXZlIHRoaXMgYmVjYXVzZSB1bml2ZXJzYWxUcmFuc2l0aW9uIGNhbiBnZXQgb2xkIHN0eWxlIGZyb20gdGhlIG9sZCBlbGVtZW50XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVPbGRTdHlsZShlbCkge1xuICB0cmFuc2l0aW9uU3RvcmUoZWwpLm9sZFN0eWxlID0gZWwuc3R5bGU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0T2xkU3R5bGUoZWwpIHtcbiAgcmV0dXJuIHRyYW5zaXRpb25TdG9yZShlbCkub2xkU3R5bGU7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5638\n")},7312:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Axis: () => (/* reexport */ core/* Axis */._0),\n  ChartView: () => (/* reexport */ core/* ChartView */.OZ),\n  ComponentModel: () => (/* reexport */ core/* ComponentModel */.jT),\n  ComponentView: () => (/* reexport */ core/* ComponentView */.bR),\n  List: () => (/* reexport */ core/* List */.B8),\n  Model: () => (/* reexport */ core/* Model */.Kx),\n  PRIORITY: () => (/* reexport */ core/* PRIORITY */.FQ),\n  SeriesModel: () => (/* reexport */ core/* SeriesModel */.rP),\n  color: () => (/* reexport */ core/* color */.yW),\n  connect: () => (/* reexport */ core/* connect */.Ng),\n  dataTool: () => (/* reexport */ core/* dataTool */.p5),\n  dependencies: () => (/* reexport */ core/* dependencies */.El),\n  disConnect: () => (/* reexport */ core/* disConnect */.zm),\n  disconnect: () => (/* reexport */ core/* disconnect */.Zf),\n  dispose: () => (/* reexport */ core/* dispose */.AS),\n  env: () => (/* reexport */ core/* env */._K),\n  extendChartView: () => (/* reexport */ core/* extendChartView */.yX),\n  extendComponentModel: () => (/* reexport */ core/* extendComponentModel */.rt),\n  extendComponentView: () => (/* reexport */ core/* extendComponentView */.NO),\n  extendSeriesModel: () => (/* reexport */ core/* extendSeriesModel */.NA),\n  format: () => (/* reexport */ core/* format */.GP),\n  getCoordinateSystemDimensions: () => (/* reexport */ core/* getCoordinateSystemDimensions */.Bo),\n  getInstanceByDom: () => (/* reexport */ core/* getInstanceByDom */.FP),\n  getInstanceById: () => (/* reexport */ core/* getInstanceById */.aQ),\n  getMap: () => (/* reexport */ core/* getMap */.ZB),\n  graphic: () => (/* reexport */ core/* graphic */.fA),\n  helper: () => (/* reexport */ core/* helper */.dw),\n  init: () => (/* reexport */ core/* init */.Ts),\n  innerDrawElementOnCanvas: () => (/* reexport */ core/* innerDrawElementOnCanvas */.UU),\n  matrix: () => (/* reexport */ core/* matrix */.UP),\n  number: () => (/* reexport */ core/* number */.ai),\n  parseGeoJSON: () => (/* reexport */ core/* parseGeoJSON */.l3),\n  parseGeoJson: () => (/* reexport */ core/* parseGeoJson */.zI),\n  registerAction: () => (/* reexport */ core/* registerAction */.OH),\n  registerCoordinateSystem: () => (/* reexport */ core/* registerCoordinateSystem */.pX),\n  registerLayout: () => (/* reexport */ core/* registerLayout */.Oh),\n  registerLoading: () => (/* reexport */ core/* registerLoading */.Ej),\n  registerLocale: () => (/* reexport */ core/* registerLocale */.E),\n  registerMap: () => (/* reexport */ core/* registerMap */.mz),\n  registerPostInit: () => (/* reexport */ core/* registerPostInit */.cf),\n  registerPostUpdate: () => (/* reexport */ core/* registerPostUpdate */.tb),\n  registerPreprocessor: () => (/* reexport */ core/* registerPreprocessor */.lP),\n  registerProcessor: () => (/* reexport */ core/* registerProcessor */.qg),\n  registerTheme: () => (/* reexport */ core/* registerTheme */.bf),\n  registerTransform: () => (/* reexport */ core/* registerTransform */.iY),\n  registerUpdateLifecycle: () => (/* reexport */ core/* registerUpdateLifecycle */.xV),\n  registerVisual: () => (/* reexport */ core/* registerVisual */.AF),\n  setCanvasCreator: () => (/* reexport */ core/* setCanvasCreator */.vV),\n  setPlatformAPI: () => (/* reexport */ core/* setPlatformAPI */.Gs),\n  throttle: () => (/* reexport */ core/* throttle */.nF),\n  time: () => (/* reexport */ core/* time */.kB),\n  use: () => (/* reexport */ core/* use */.Yx),\n  util: () => (/* reexport */ core/* util */.ZS),\n  vector: () => (/* reexport */ core/* vector */.i1),\n  version: () => (/* reexport */ core/* version */.rE),\n  zrUtil: () => (/* reexport */ core/* zrUtil */.F_),\n  zrender: () => (/* reexport */ core/* zrender */.nd)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/extension.js\nvar extension = __webpack_require__(3087);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/export/core.js + 7 modules\nvar core = __webpack_require__(77775);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/renderer/installCanvasRenderer.js\nvar installCanvasRenderer = __webpack_require__(89952);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/renderer/installSVGRenderer.js\nvar installSVGRenderer = __webpack_require__(83806);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/line/install.js + 4 modules\nvar install = __webpack_require__(11734);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/bar/install.js\nvar bar_install = __webpack_require__(72108);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/pie/install.js + 4 modules\nvar pie_install = __webpack_require__(74625);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/scatter/install.js + 2 modules\nvar scatter_install = __webpack_require__(99952);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/radar/install.js + 4 modules\nvar radar_install = __webpack_require__(4391);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/map/install.js + 4 modules\nvar map_install = __webpack_require__(4270);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/tree/install.js + 7 modules\nvar tree_install = __webpack_require__(31441);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/treemap/install.js + 6 modules\nvar treemap_install = __webpack_require__(49917);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/graph/install.js + 14 modules\nvar graph_install = __webpack_require__(88745);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/gauge/install.js + 3 modules\nvar gauge_install = __webpack_require__(61030);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/funnel/install.js + 3 modules\nvar funnel_install = __webpack_require__(74508);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/parallel/install.js + 3 modules\nvar parallel_install = __webpack_require__(31966);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/sankey/install.js + 4 modules\nvar sankey_install = __webpack_require__(73900);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/boxplot/install.js + 5 modules\nvar boxplot_install = __webpack_require__(51719);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/candlestick/install.js + 5 modules\nvar candlestick_install = __webpack_require__(56699);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/effectScatter/install.js + 2 modules\nvar effectScatter_install = __webpack_require__(50032);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/lines/install.js + 4 modules\nvar lines_install = __webpack_require__(6325);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/heatmap/install.js + 3 modules\nvar heatmap_install = __webpack_require__(49714);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/bar/installPictorialBar.js + 2 modules\nvar installPictorialBar = __webpack_require__(61152);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/themeRiver/install.js + 3 modules\nvar themeRiver_install = __webpack_require__(9895);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/sunburst/install.js + 6 modules\nvar sunburst_install = __webpack_require__(44710);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/custom/install.js + 2 modules\nvar custom_install = __webpack_require__(27288);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/grid/install.js\nvar grid_install = __webpack_require__(45620);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/polar/install.js\nvar polar_install = __webpack_require__(59166);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/geo/install.js + 1 modules\nvar geo_install = __webpack_require__(363);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/singleAxis/install.js\nvar singleAxis_install = __webpack_require__(68241);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/parallel/install.js + 1 modules\nvar component_parallel_install = __webpack_require__(46105);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/calendar/install.js + 1 modules\nvar calendar_install = __webpack_require__(22379);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/graphic/install.js + 2 modules\nvar graphic_install = __webpack_require__(40830);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/toolbox/install.js + 7 modules\nvar toolbox_install = __webpack_require__(92260);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/tooltip/install.js + 5 modules\nvar tooltip_install = __webpack_require__(6641);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axisPointer/install.js + 4 modules\nvar axisPointer_install = __webpack_require__(46524);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/brush/install.js + 5 modules\nvar brush_install = __webpack_require__(91695);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/title/install.js\nvar title_install = __webpack_require__(74064);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/timeline/install.js + 7 modules\nvar timeline_install = __webpack_require__(42751);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/installMarkPoint.js + 2 modules\nvar installMarkPoint = __webpack_require__(22158);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/installMarkLine.js + 2 modules\nvar installMarkLine = __webpack_require__(42998);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/marker/installMarkArea.js + 2 modules\nvar installMarkArea = __webpack_require__(39838);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/legend/install.js + 9 modules\nvar legend_install = __webpack_require__(69380);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/install.js\nvar dataZoom_install = __webpack_require__(45967);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/installDataZoomInside.js + 3 modules\nvar installDataZoomInside = __webpack_require__(68667);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/installDataZoomSlider.js + 2 modules\nvar installDataZoomSlider = __webpack_require__(35099);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/visualMap/install.js\nvar visualMap_install = __webpack_require__(28540);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/visualMap/installVisualMapContinuous.js + 2 modules\nvar installVisualMapContinuous = __webpack_require__(67113);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/visualMap/installVisualMapPiecewise.js + 2 modules\nvar installVisualMapPiecewise = __webpack_require__(68781);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/aria/install.js + 1 modules\nvar aria_install = __webpack_require__(70816);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/transform/install.js + 2 modules\nvar transform_install = __webpack_require__(44934);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataset/install.js\nvar dataset_install = __webpack_require__(76302);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/tool/morphPath.js + 2 modules\nvar morphPath = __webpack_require__(97850);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Path.js\nvar Path = __webpack_require__(59482);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/tool/path.js + 1 modules\nvar path = __webpack_require__(59442);\n;// ./node_modules/echarts/lib/animation/morphTransitionHelper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nfunction isMultiple(elements) {\n  return (0,util.isArray)(elements[0]);\n}\nfunction prepareMorphBatches(one, many) {\n  var batches = [];\n  var batchCount = one.length;\n  for (var i = 0; i < batchCount; i++) {\n    batches.push({\n      one: one[i],\n      many: []\n    });\n  }\n  for (var i = 0; i < many.length; i++) {\n    var len = many[i].length;\n    var k = void 0;\n    for (k = 0; k < len; k++) {\n      batches[k % batchCount].many.push(many[i][k]);\n    }\n  }\n  var off = 0;\n  // If one has more paths than each one of many. average them.\n  for (var i = batchCount - 1; i >= 0; i--) {\n    if (!batches[i].many.length) {\n      var moveFrom = batches[off].many;\n      if (moveFrom.length <= 1) {\n        // Not enough\n        // Start from the first one.\n        if (off) {\n          off = 0;\n        } else {\n          return batches;\n        }\n      }\n      var len = moveFrom.length;\n      var mid = Math.ceil(len / 2);\n      batches[i].many = moveFrom.slice(mid, len);\n      batches[off].many = moveFrom.slice(0, mid);\n      off++;\n    }\n  }\n  return batches;\n}\nvar pathDividers = {\n  clone: function (params) {\n    var ret = [];\n    // Fitting the alpha\n    var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);\n    for (var i = 0; i < params.count; i++) {\n      var cloned = (0,path/* clonePath */.rR)(params.path);\n      cloned.setStyle('opacity', approxOpacity);\n      ret.push(cloned);\n    }\n    return ret;\n  },\n  // Use the default divider\n  split: null\n};\nfunction applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {\n  if (!from.length || !to.length) {\n    return;\n  }\n  var updateAnimationCfg = (0,basicTransition/* getAnimationConfig */.Jw)('update', seriesModel, dataIndex);\n  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {\n    return;\n  }\n  var animationDelay = seriesModel.getModel('universalTransition').get('delay');\n  var animationCfg = Object.assign({\n    // Need to setToFinal so the further calculation based on the style can be correct.\n    // Like emphasis color.\n    setToFinal: true\n  }, updateAnimationCfg);\n  var many;\n  var one;\n  if (isMultiple(from)) {\n    // manyToOne\n    many = from;\n    one = to;\n  }\n  if (isMultiple(to)) {\n    // oneToMany\n    many = to;\n    one = from;\n  }\n  function morphOneBatch(batch, fromIsMany, animateIndex, animateCount, forceManyOne) {\n    var batchMany = batch.many;\n    var batchOne = batch.one;\n    if (batchMany.length === 1 && !forceManyOne) {\n      // Is one to one\n      var batchFrom = fromIsMany ? batchMany[0] : batchOne;\n      var batchTo = fromIsMany ? batchOne : batchMany[0];\n      if ((0,morphPath/* isCombineMorphing */.AN)(batchFrom)) {\n        // Keep doing combine animation.\n        morphOneBatch({\n          many: [batchFrom],\n          one: batchTo\n        }, true, animateIndex, animateCount, true);\n      } else {\n        var individualAnimationCfg = animationDelay ? (0,util.defaults)({\n          delay: animationDelay(animateIndex, animateCount)\n        }, animationCfg) : animationCfg;\n        (0,morphPath/* morphPath */.mz)(batchFrom, batchTo, individualAnimationCfg);\n        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);\n      }\n    } else {\n      var separateAnimationCfg = (0,util.defaults)({\n        dividePath: pathDividers[divideShape],\n        individualDelay: animationDelay && function (idx, count, fromPath, toPath) {\n          return animationDelay(idx + animateIndex, animateCount);\n        }\n      }, animationCfg);\n      var _a = fromIsMany ? (0,morphPath/* combineMorph */.Gw)(batchMany, batchOne, separateAnimationCfg) : (0,morphPath/* separateMorph */.AG)(batchOne, batchMany, separateAnimationCfg),\n        fromIndividuals = _a.fromIndividuals,\n        toIndividuals = _a.toIndividuals;\n      var count = fromIndividuals.length;\n      for (var k = 0; k < count; k++) {\n        var individualAnimationCfg = animationDelay ? (0,util.defaults)({\n          delay: animationDelay(k, count)\n        }, animationCfg) : animationCfg;\n        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany ? batchMany[k] : batch.one, fromIsMany ? batch.one : batchMany[k], individualAnimationCfg);\n      }\n    }\n  }\n  var fromIsMany = many ? many === from\n  // Is one to one. If the path number not match. also needs do merge and separate morphing.\n  : from.length > to.length;\n  var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);\n  var animateCount = 0;\n  for (var i = 0; i < morphBatches.length; i++) {\n    animateCount += morphBatches[i].many.length;\n  }\n  var animateIndex = 0;\n  for (var i = 0; i < morphBatches.length; i++) {\n    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);\n    animateIndex += morphBatches[i].many.length;\n  }\n}\nfunction getPathList(elements) {\n  if (!elements) {\n    return [];\n  }\n  if ((0,util.isArray)(elements)) {\n    var pathList_1 = [];\n    for (var i = 0; i < elements.length; i++) {\n      pathList_1.push(getPathList(elements[i]));\n    }\n    return pathList_1;\n  }\n  var pathList = [];\n  elements.traverse(function (el) {\n    if (el instanceof Path/* default */.Ay && !el.disableMorphing && !el.invisible && !el.ignore) {\n      pathList.push(el);\n    }\n  });\n  return pathList;\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/DataDiffer.js\nvar DataDiffer = __webpack_require__(16563);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/log.js\nvar log = __webpack_require__(41025);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Displayable.js\nvar Displayable = __webpack_require__(71519);\n;// ./node_modules/echarts/lib/animation/universalTransition.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// Universal transitions that can animate between any shapes(series) and any properties in any amounts.\n\n\n\n\n\n\n\n\n\n\nvar DATA_COUNT_THRESHOLD = 1e4;\nvar TRANSITION_NONE = 0;\nvar TRANSITION_P2C = 1;\nvar TRANSITION_C2P = 2;\n;\nvar getUniversalTransitionGlobalStore = (0,model/* makeInner */.$r)();\nfunction getDimension(data, visualDimension) {\n  var dimensions = data.dimensions;\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = data.getDimensionInfo(dimensions[i]);\n    if (dimInfo && dimInfo.otherDims[visualDimension] === 0) {\n      return dimensions[i];\n    }\n  }\n}\n// get value by dimension. (only get value of itemGroupId or childGroupId, so convert it to string)\nfunction getValueByDimension(data, dataIndex, dimension) {\n  var dimInfo = data.getDimensionInfo(dimension);\n  var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;\n  if (dimInfo) {\n    var value = data.get(dimInfo.name, dataIndex);\n    if (dimOrdinalMeta) {\n      return dimOrdinalMeta.categories[value] || value + '';\n    }\n    return value + '';\n  }\n}\nfunction getGroupId(data, dataIndex, dataGroupId, isChild) {\n  // try to get groupId from encode\n  var visualDimension = isChild ? 'itemChildGroupId' : 'itemGroupId';\n  var groupIdDim = getDimension(data, visualDimension);\n  if (groupIdDim) {\n    var groupId = getValueByDimension(data, dataIndex, groupIdDim);\n    return groupId;\n  }\n  // try to get groupId from raw data item\n  var rawDataItem = data.getRawDataItem(dataIndex);\n  var property = isChild ? 'childGroupId' : 'groupId';\n  if (rawDataItem && rawDataItem[property]) {\n    return rawDataItem[property] + '';\n  }\n  // fallback\n  if (isChild) {\n    return;\n  }\n  // try to use series.dataGroupId as groupId, otherwise use dataItem's id as groupId\n  return dataGroupId || data.getId(dataIndex);\n}\n// flatten all data items from different serieses into one arrary\nfunction flattenDataDiffItems(list) {\n  var items = [];\n  (0,util.each)(list, function (seriesInfo) {\n    var data = seriesInfo.data;\n    var dataGroupId = seriesInfo.dataGroupId;\n    if (data.count() > DATA_COUNT_THRESHOLD) {\n      if (false) {}\n      return;\n    }\n    var indices = data.getIndices();\n    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {\n      items.push({\n        data: data,\n        groupId: getGroupId(data, dataIndex, dataGroupId, false),\n        childGroupId: getGroupId(data, dataIndex, dataGroupId, true),\n        divide: seriesInfo.divide,\n        dataIndex: dataIndex\n      });\n    }\n  });\n  return items;\n}\nfunction fadeInElement(newEl, newSeries, newIndex) {\n  newEl.traverse(function (el) {\n    if (el instanceof Path/* default */.Ay) {\n      // TODO use fade in animation for target element.\n      (0,basicTransition/* initProps */.LW)(el, {\n        style: {\n          opacity: 0\n        }\n      }, newSeries, {\n        dataIndex: newIndex,\n        isFrom: true\n      });\n    }\n  });\n}\nfunction removeEl(el) {\n  if (el.parent) {\n    // Bake parent transform to element.\n    // So it can still have proper transform to transition after it's removed.\n    var computedTransform = el.getComputedTransform();\n    el.setLocalTransform(computedTransform);\n    el.parent.remove(el);\n  }\n}\nfunction stopAnimation(el) {\n  el.stopAnimation();\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.stopAnimation();\n    });\n  }\n}\nfunction animateElementStyles(el, dataIndex, seriesModel) {\n  var animationConfig = (0,basicTransition/* getAnimationConfig */.Jw)('update', seriesModel, dataIndex);\n  animationConfig && el.traverse(function (child) {\n    if (child instanceof Displayable/* default */.Ay) {\n      var oldStyle = (0,basicTransition/* getOldStyle */.Xr)(child);\n      if (oldStyle) {\n        child.animateFrom({\n          style: oldStyle\n        }, animationConfig);\n      }\n    }\n  });\n}\nfunction isAllIdSame(oldDiffItems, newDiffItems) {\n  var len = oldDiffItems.length;\n  if (len !== newDiffItems.length) {\n    return false;\n  }\n  for (var i = 0; i < len; i++) {\n    var oldItem = oldDiffItems[i];\n    var newItem = newDiffItems[i];\n    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction transitionBetween(oldList, newList, api) {\n  var oldDiffItems = flattenDataDiffItems(oldList);\n  var newDiffItems = flattenDataDiffItems(newList);\n  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {\n    if (rawFrom || from) {\n      to.animateFrom({\n        style: rawFrom && rawFrom !== from\n        // dividingMethod like clone may override the style(opacity)\n        // So extend it to raw style.\n        ? (0,util.extend)((0,util.extend)({}, rawFrom.style), from.style) : from.style\n      }, animationCfg);\n    }\n  }\n  var hasMorphAnimation = false;\n  /**\r\n   * With groupId and childGroupId, we can build parent-child relationships between dataItems.\r\n   * However, we should mind the parent-child \"direction\" between old and new options.\r\n   *\r\n   * For example, suppose we have two dataItems from two series.data:\r\n   *\r\n   * dataA: [                          dataB: [\r\n   *   {                                 {\r\n   *     value: 5,                         value: 3,\r\n   *     groupId: 'creatures',             groupId: 'animals',\r\n   *     childGroupId: 'animals'           childGroupId: 'dogs'\r\n   *   },                                },\r\n   *   ...                               ...\r\n   * ]                                 ]\r\n   *\r\n   * where dataA is belong to optionA and dataB is belong to optionB.\r\n   *\r\n   * When we `setOption(optionB)` from optionA, we choose childGroupId of dataItemA and groupId of\r\n   * dataItemB as keys so the two keys are matched (both are 'animals'), then universalTransition\r\n   * will work. This derection is \"parent -> child\".\r\n   *\r\n   * If we `setOption(optionA)` from optionB, we also choose groupId of dataItemB and childGroupId\r\n   * of dataItemA as keys and universalTransition will work. This derection is \"child -> parent\".\r\n   *\r\n   * If there is no childGroupId specified, which means no multiLevelDrillDown/Up is needed and no\r\n   * parent-child relationship exists. This direction is \"none\".\r\n   *\r\n   * So we need to know whether to use groupId or childGroupId as the key when we call the keyGetter\r\n   * functions. Thus, we need to decide the direction first.\r\n   *\r\n   * The rule is:\r\n   *\r\n   * if (all childGroupIds in oldDiffItems and all groupIds in newDiffItems have common value) {\r\n   *   direction = 'parent -> child';\r\n   * } else if (all groupIds in oldDiffItems and all childGroupIds in newDiffItems have common value) {\r\n   *   direction = 'child -> parent';\r\n   * } else {\r\n   *   direction = 'none';\r\n   * }\r\n   */\n  var direction = TRANSITION_NONE;\n  // find all groupIds and childGroupIds from oldDiffItems\n  var oldGroupIds = (0,util.createHashMap)();\n  var oldChildGroupIds = (0,util.createHashMap)();\n  oldDiffItems.forEach(function (item) {\n    item.groupId && oldGroupIds.set(item.groupId, true);\n    item.childGroupId && oldChildGroupIds.set(item.childGroupId, true);\n  });\n  // traverse newDiffItems and decide the direction according to the rule\n  for (var i = 0; i < newDiffItems.length; i++) {\n    var newGroupId = newDiffItems[i].groupId;\n    if (oldChildGroupIds.get(newGroupId)) {\n      direction = TRANSITION_P2C;\n      break;\n    }\n    var newChildGroupId = newDiffItems[i].childGroupId;\n    if (newChildGroupId && oldGroupIds.get(newChildGroupId)) {\n      direction = TRANSITION_C2P;\n      break;\n    }\n  }\n  function createKeyGetter(isOld, onlyGetId) {\n    return function (diffItem) {\n      var data = diffItem.data;\n      var dataIndex = diffItem.dataIndex;\n      // TODO if specified dim\n      if (onlyGetId) {\n        return data.getId(dataIndex);\n      }\n      if (isOld) {\n        return direction === TRANSITION_P2C ? diffItem.childGroupId : diffItem.groupId;\n      } else {\n        return direction === TRANSITION_C2P ? diffItem.childGroupId : diffItem.groupId;\n      }\n    };\n  }\n  // Use id if it's very likely to be an one to one animation\n  // It's more robust than groupId\n  // TODO Check if key dimension is specified.\n  var useId = isAllIdSame(oldDiffItems, newDiffItems);\n  var isElementStillInChart = {};\n  if (!useId) {\n    // We may have different diff strategy with basicTransition if we use other dimension as key.\n    // If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.\n    // We can't use the elements that already being morphed. Let it keep it's original basic transition.\n    for (var i = 0; i < newDiffItems.length; i++) {\n      var newItem = newDiffItems[i];\n      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);\n      if (el) {\n        isElementStillInChart[el.id] = true;\n      }\n    }\n  }\n  function updateOneToOne(newIndex, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var newItem = newDiffItems[newIndex];\n    var newSeries = newItem.data.hostModel;\n    // TODO Mark this elements is morphed and don't morph them anymore\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    var newEl = newItem.data.getItemGraphicEl(newItem.dataIndex);\n    // Can't handle same elements.\n    if (oldEl === newEl) {\n      newEl && animateElementStyles(newEl, newItem.dataIndex, newSeries);\n      return;\n    }\n    if (\n    // We can't use the elements that already being morphed\n    oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n    if (newEl) {\n      // TODO: If keep animating the group in case\n      // some of the elements don't want to be morphed.\n      // TODO Label?\n      stopAnimation(newEl);\n      if (oldEl) {\n        stopAnimation(oldEl);\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newIndex);\n      }\n    }\n    // else keep oldEl leaving animation.\n  }\n  new DataDiffer/* default */.A(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, 'multiple').update(updateOneToOne).updateManyToOne(function (newIndex, oldIndices) {\n    var newItem = newDiffItems[newIndex];\n    var newData = newItem.data;\n    var newSeries = newData.hostModel;\n    var newEl = newData.getItemGraphicEl(newItem.dataIndex);\n    var oldElsList = (0,util.filter)((0,util.map)(oldIndices, function (idx) {\n      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);\n    }), function (oldEl) {\n      return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];\n    });\n    if (newEl) {\n      stopAnimation(newEl);\n      if (oldElsList.length) {\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        (0,util.each)(oldElsList, function (oldEl) {\n          stopAnimation(oldEl);\n          removeEl(oldEl);\n        });\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newItem.dataIndex);\n      }\n    }\n    // else keep oldEl leaving animation.\n  }).updateOneToMany(function (newIndices, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    // We can't use the elements that already being morphed\n    if (oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n    var newElsList = (0,util.filter)((0,util.map)(newIndices, function (idx) {\n      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);\n    }), function (el) {\n      return el && el !== oldEl;\n    });\n    var newSeris = newDiffItems[newIndices[0]].data.hostModel;\n    if (newElsList.length) {\n      (0,util.each)(newElsList, function (newEl) {\n        return stopAnimation(newEl);\n      });\n      if (oldEl) {\n        stopAnimation(oldEl);\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide,\n        // Use divide on old.\n        newSeris, newIndices[0], updateMorphingPathProps);\n      } else {\n        (0,util.each)(newElsList, function (newEl) {\n          return fadeInElement(newEl, newSeris, newIndices[0]);\n        });\n      }\n    }\n    // else keep oldEl leaving animation.\n  }).updateManyToMany(function (newIndices, oldIndices) {\n    // If two data are same and both have groupId.\n    // Normally they should be diff by id.\n    new DataDiffer/* default */.A(oldIndices, newIndices, function (rawIdx) {\n      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);\n    }, function (rawIdx) {\n      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);\n    }).update(function (newIndex, oldIndex) {\n      // Use the original index\n      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);\n    }).execute();\n  }).execute();\n  if (hasMorphAnimation) {\n    (0,util.each)(newList, function (_a) {\n      var data = _a.data;\n      var seriesModel = data.hostModel;\n      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);\n      var animationCfg = (0,basicTransition/* getAnimationConfig */.Jw)('update', seriesModel, 0); // use 0 index.\n      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {\n        view.group.traverse(function (el) {\n          if (el instanceof Path/* default */.Ay && !el.animators.length) {\n            // We can't accept there still exists element that has no animation\n            // if universalTransition is enabled\n            el.animateFrom({\n              style: {\n                opacity: 0\n              }\n            }, animationCfg);\n          }\n        });\n      }\n    });\n  }\n}\nfunction getSeriesTransitionKey(series) {\n  var seriesKey = series.getModel('universalTransition').get('seriesKey');\n  if (!seriesKey) {\n    // Use series id by default.\n    return series.id;\n  }\n  return seriesKey;\n}\nfunction convertArraySeriesKeyToString(seriesKey) {\n  if ((0,util.isArray)(seriesKey)) {\n    // Order independent.\n    return seriesKey.sort().join(',');\n  }\n  return seriesKey;\n}\nfunction getDivideShapeFromData(data) {\n  if (data.hostModel) {\n    return data.hostModel.getModel('universalTransition').get('divideShape');\n  }\n}\nfunction findTransitionSeriesBatches(globalStore, params) {\n  var updateBatches = (0,util.createHashMap)();\n  var oldDataMap = (0,util.createHashMap)();\n  // Map that only store key in array seriesKey.\n  // Which is used to query the old data when transition from one to multiple series.\n  var oldDataMapForSplit = (0,util.createHashMap)();\n  (0,util.each)(globalStore.oldSeries, function (series, idx) {\n    var oldDataGroupId = globalStore.oldDataGroupIds[idx];\n    var oldData = globalStore.oldData[idx];\n    var transitionKey = getSeriesTransitionKey(series);\n    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n    oldDataMap.set(transitionKeyStr, {\n      dataGroupId: oldDataGroupId,\n      data: oldData\n    });\n    if ((0,util.isArray)(transitionKey)) {\n      // Same key can't in different array seriesKey.\n      (0,util.each)(transitionKey, function (key) {\n        oldDataMapForSplit.set(key, {\n          key: transitionKeyStr,\n          dataGroupId: oldDataGroupId,\n          data: oldData\n        });\n      });\n    }\n  });\n  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {\n    if (updateBatches.get(transitionKeyStr)) {\n      (0,log/* warn */.R8)(\"Duplicated seriesKey in universalTransition \" + transitionKeyStr);\n    }\n  }\n  (0,util.each)(params.updatedSeries, function (series) {\n    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {\n      var newDataGroupId = series.get('dataGroupId');\n      var newData = series.getData();\n      var transitionKey = getSeriesTransitionKey(series);\n      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n      // Only transition between series with same id.\n      var oldData = oldDataMap.get(transitionKeyStr);\n      // string transition key is the best match.\n      if (oldData) {\n        if (false) {}\n        // TODO check if data is same?\n        updateBatches.set(transitionKeyStr, {\n          oldSeries: [{\n            dataGroupId: oldData.dataGroupId,\n            divide: getDivideShapeFromData(oldData.data),\n            data: oldData.data\n          }],\n          newSeries: [{\n            dataGroupId: newDataGroupId,\n            divide: getDivideShapeFromData(newData),\n            data: newData\n          }]\n        });\n      } else {\n        // Transition from multiple series.\n        // e.g. 'female', 'male' -> ['female', 'male']\n        if ((0,util.isArray)(transitionKey)) {\n          if (false) {}\n          var oldSeries_1 = [];\n          (0,util.each)(transitionKey, function (key) {\n            var oldData = oldDataMap.get(key);\n            if (oldData.data) {\n              oldSeries_1.push({\n                dataGroupId: oldData.dataGroupId,\n                divide: getDivideShapeFromData(oldData.data),\n                data: oldData.data\n              });\n            }\n          });\n          if (oldSeries_1.length) {\n            updateBatches.set(transitionKeyStr, {\n              oldSeries: oldSeries_1,\n              newSeries: [{\n                dataGroupId: newDataGroupId,\n                data: newData,\n                divide: getDivideShapeFromData(newData)\n              }]\n            });\n          }\n        } else {\n          // Try transition to multiple series.\n          // e.g. ['female', 'male'] -> 'female', 'male'\n          var oldData_1 = oldDataMapForSplit.get(transitionKey);\n          if (oldData_1) {\n            var batch = updateBatches.get(oldData_1.key);\n            if (!batch) {\n              batch = {\n                oldSeries: [{\n                  dataGroupId: oldData_1.dataGroupId,\n                  data: oldData_1.data,\n                  divide: getDivideShapeFromData(oldData_1.data)\n                }],\n                newSeries: []\n              };\n              updateBatches.set(oldData_1.key, batch);\n            }\n            batch.newSeries.push({\n              dataGroupId: newDataGroupId,\n              data: newData,\n              divide: getDivideShapeFromData(newData)\n            });\n          }\n        }\n      }\n    }\n  });\n  return updateBatches;\n}\nfunction querySeries(series, finder) {\n  for (var i = 0; i < series.length; i++) {\n    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;\n    if (found) {\n      return i;\n    }\n  }\n}\nfunction transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {\n  var from = [];\n  var to = [];\n  (0,util.each)((0,model/* normalizeToArray */.qB)(transitionOpt.from), function (finder) {\n    var idx = querySeries(globalStore.oldSeries, finder);\n    if (idx >= 0) {\n      from.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: globalStore.oldData[idx],\n        // TODO can specify divideShape in transition.\n        divide: getDivideShapeFromData(globalStore.oldData[idx]),\n        groupIdDim: finder.dimension\n      });\n    }\n  });\n  (0,util.each)((0,model/* normalizeToArray */.qB)(transitionOpt.to), function (finder) {\n    var idx = querySeries(params.updatedSeries, finder);\n    if (idx >= 0) {\n      var data = params.updatedSeries[idx].getData();\n      to.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: data,\n        divide: getDivideShapeFromData(data),\n        groupIdDim: finder.dimension\n      });\n    }\n  });\n  if (from.length > 0 && to.length > 0) {\n    transitionBetween(from, to, api);\n  }\n}\nfunction installUniversalTransition(registers) {\n  registers.registerUpdateLifecycle('series:beforeupdate', function (ecMOdel, api, params) {\n    (0,util.each)((0,model/* normalizeToArray */.qB)(params.seriesTransition), function (transOpt) {\n      (0,util.each)((0,model/* normalizeToArray */.qB)(transOpt.to), function (finder) {\n        var series = params.updatedSeries;\n        for (var i = 0; i < series.length; i++) {\n          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {\n            series[i][Series/* SERIES_UNIVERSAL_TRANSITION_PROP */.U] = true;\n          }\n        }\n      });\n    });\n  });\n  registers.registerUpdateLifecycle('series:transition', function (ecModel, api, params) {\n    // TODO api provide an namespace that can save stuff per instance\n    var globalStore = getUniversalTransitionGlobalStore(api);\n    // TODO multiple to multiple series.\n    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {\n      // TODO transitionOpt was used in an old implementation and can be removed now\n      // Use give transition config if its' give;\n      var transitionOpt = params.seriesTransition;\n      if (transitionOpt) {\n        (0,util.each)((0,model/* normalizeToArray */.qB)(transitionOpt), function (opt) {\n          transitionSeriesFromOpt(opt, globalStore, params, api);\n        });\n      } else {\n        // Else guess from series based on transition series key.\n        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);\n        (0,util.each)(updateBatches_1.keys(), function (key) {\n          var batch = updateBatches_1.get(key);\n          transitionBetween(batch.oldSeries, batch.newSeries, api);\n        });\n      }\n      // Reset\n      (0,util.each)(params.updatedSeries, function (series) {\n        // Reset;\n        if (series[Series/* SERIES_UNIVERSAL_TRANSITION_PROP */.U]) {\n          series[Series/* SERIES_UNIVERSAL_TRANSITION_PROP */.U] = false;\n        }\n      });\n    }\n    // Save all series of current update. Not only the updated one.\n    var allSeries = ecModel.getSeries();\n    var savedSeries = globalStore.oldSeries = [];\n    var savedDataGroupIds = globalStore.oldDataGroupIds = [];\n    var savedData = globalStore.oldData = [];\n    for (var i = 0; i < allSeries.length; i++) {\n      var data = allSeries[i].getData();\n      // Only save the data that can have transition.\n      // Avoid large data costing too much extra memory\n      if (data.count() < DATA_COUNT_THRESHOLD) {\n        savedSeries.push(allSeries[i]);\n        savedDataGroupIds.push(allSeries[i].get('dataGroupId'));\n        savedData.push(data);\n      }\n    }\n  });\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/installLabelLayout.js + 1 modules\nvar installLabelLayout = __webpack_require__(35278);\n;// ./node_modules/echarts/index.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n// ----------------------------------------------\n// All of the modules that are allowed to be\n// imported are listed below.\n//\n// Users MUST NOT import other modules that are\n// not included in this list.\n// ----------------------------------------------\n\n\n\n\n// -----------------\n// Render engines\n// -----------------\n// Render via Canvas.\n// echarts.init(dom, null, { renderer: 'canvas' })\n(0,extension/* use */.Y)([installCanvasRenderer/* install */.a]);\n// Render via SVG.\n// echarts.init(dom, null, { renderer: 'svg' })\n(0,extension/* use */.Y)([installSVGRenderer/* install */.a]);\n// ----------------\n// Charts (series)\n// ----------------\n// All of the series types, for example:\n// chart.setOption({\n//     series: [{\n//         type: 'line' // or 'bar', 'pie', ...\n//     }]\n// });\n(0,extension/* use */.Y)([install/* install */.a, bar_install/* install */.a, pie_install/* install */.a, scatter_install/* install */.a, radar_install/* install */.a, map_install/* install */.a, tree_install/* install */.a, treemap_install/* install */.a, graph_install/* install */.a, gauge_install/* install */.a, funnel_install/* install */.a, parallel_install/* install */.a, sankey_install/* install */.a, boxplot_install/* install */.a, candlestick_install/* install */.a, effectScatter_install/* install */.a, lines_install/* install */.a, heatmap_install/* install */.a, installPictorialBar/* install */.a, themeRiver_install/* install */.a, sunburst_install/* install */.a, custom_install/* install */.a]);\n// -------------------\n// Coordinate systems\n// -------------------\n// All of the axis modules have been included in the\n// coordinate system module below, do not need to\n// make extra import.\n// `cartesian` coordinate system. For some historical\n// reasons, it is named as grid, for example:\n// chart.setOption({\n//     grid: {...},\n//     xAxis: {...},\n//     yAxis: {...},\n//     series: [{...}]\n// });\n(0,extension/* use */.Y)(grid_install/* install */.a);\n// `polar` coordinate system, for example:\n// chart.setOption({\n//     polar: {...},\n//     radiusAxis: {...},\n//     angleAxis: {...},\n//     series: [{\n//         coordinateSystem: 'polar'\n//     }]\n// });\n(0,extension/* use */.Y)(polar_install/* install */.a);\n// `geo` coordinate system, for example:\n// chart.setOption({\n//     geo: {...},\n//     series: [{\n//         coordinateSystem: 'geo'\n//     }]\n// });\n(0,extension/* use */.Y)(geo_install/* install */.a);\n// `singleAxis` coordinate system (notice, it is a coordinate system\n// with only one axis, work for chart like theme river), for example:\n// chart.setOption({\n//     singleAxis: {...}\n//     series: [{type: 'themeRiver', ...}]\n// });\n(0,extension/* use */.Y)(singleAxis_install/* install */.a);\n// `parallel` coordinate system, only work for parallel series, for example:\n// chart.setOption({\n//     parallel: {...},\n//     parallelAxis: [{...}, ...],\n//     series: [{\n//         type: 'parallel'\n//     }]\n// });\n(0,extension/* use */.Y)(component_parallel_install/* install */.a);\n// `calendar` coordinate system. for example,\n// chart.setOption({\n//     calendar: {...},\n//     series: [{\n//         coordinateSystem: 'calendar'\n//     }]\n// );\n(0,extension/* use */.Y)(calendar_install/* install */.a);\n// ------------------\n// Other components\n// ------------------\n// `graphic` component, for example:\n// chart.setOption({\n//     graphic: {...}\n// });\n(0,extension/* use */.Y)(graphic_install/* install */.a);\n// `toolbox` component, for example:\n// chart.setOption({\n//     toolbox: {...}\n// });\n(0,extension/* use */.Y)(toolbox_install/* install */.a);\n// `tooltip` component, for example:\n// chart.setOption({\n//     tooltip: {...}\n// });\n(0,extension/* use */.Y)(tooltip_install/* install */.a);\n// `axisPointer` component, for example:\n// chart.setOption({\n//     tooltip: {axisPointer: {...}, ...}\n// });\n// Or\n// chart.setOption({\n//     axisPointer: {...}\n// });\n(0,extension/* use */.Y)(axisPointer_install/* install */.a);\n// `brush` component, for example:\n// chart.setOption({\n//     brush: {...}\n// });\n// Or\n// chart.setOption({\n//     tooltip: {feature: {brush: {...}}\n// })\n(0,extension/* use */.Y)(brush_install/* install */.a);\n// `title` component, for example:\n// chart.setOption({\n//     title: {...}\n// });\n(0,extension/* use */.Y)(title_install/* install */.a);\n// `timeline` component, for example:\n// chart.setOption({\n//     timeline: {...}\n// });\n(0,extension/* use */.Y)(timeline_install/* install */.a);\n// `markPoint` component, for example:\n// chart.setOption({\n//     series: [{markPoint: {...}}]\n// });\n(0,extension/* use */.Y)(installMarkPoint/* install */.a);\n// `markLine` component, for example:\n// chart.setOption({\n//     series: [{markLine: {...}}]\n// });\n(0,extension/* use */.Y)(installMarkLine/* install */.a);\n// `markArea` component, for example:\n// chart.setOption({\n//     series: [{markArea: {...}}]\n// });\n(0,extension/* use */.Y)(installMarkArea/* install */.a);\n// `legend` component not scrollable. for example:\n// chart.setOption({\n//     legend: {...}\n// });\n(0,extension/* use */.Y)(legend_install/* install */.a);\n// `dataZoom` component including both `dataZoomInside` and `dataZoomSlider`.\n(0,extension/* use */.Y)(dataZoom_install/* install */.a);\n// `dataZoom` component providing drag, pinch, wheel behaviors\n// inside coordinate system, for example:\n// chart.setOption({\n//     dataZoom: {type: 'inside'}\n// });\n(0,extension/* use */.Y)(installDataZoomInside/* install */.a);\n// `dataZoom` component providing a slider bar, for example:\n// chart.setOption({\n//     dataZoom: {type: 'slider'}\n// });\n(0,extension/* use */.Y)(installDataZoomSlider/* install */.a);\n// `visualMap` component including both `visualMapContinuous` and `visualMapPiecewise`.\n(0,extension/* use */.Y)(visualMap_install/* install */.a);\n// `visualMap` component providing continuous bar, for example:\n// chart.setOption({\n//     visualMap: {type: 'continuous'}\n// });\n(0,extension/* use */.Y)(installVisualMapContinuous/* install */.a);\n// `visualMap` component providing pieces bar, for example:\n// chart.setOption({\n//     visualMap: {type: 'piecewise'}\n// });\n(0,extension/* use */.Y)(installVisualMapPiecewise/* install */.a);\n// `aria` component providing aria, for example:\n// chart.setOption({\n//     aria: {...}\n// });\n(0,extension/* use */.Y)(aria_install/* install */.a);\n// dataset transform\n// chart.setOption({\n//     dataset: {\n//          transform: []\n//     }\n// });\n(0,extension/* use */.Y)(transform_install/* install */.a);\n(0,extension/* use */.Y)(dataset_install/* install */.a);\n// universal transition\n// chart.setOption({\n//     series: {\n//         universalTransition: { enabled: true }\n//     }\n// })\n(0,extension/* use */.Y)(installUniversalTransition);\n// label layout\n// chart.setOption({\n//     series: {\n//         labelLayout: { hideOverlap: true }\n//     }\n// })\n(0,extension/* use */.Y)(installLabelLayout/* installLabelLayout */._);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMxMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvYW5pbWF0aW9uL21vcnBoVHJhbnNpdGlvbkhlbHBlci5qcz8zZDQwIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9hbmltYXRpb24vdW5pdmVyc2FsVHJhbnNpdGlvbi5qcz82NzU2Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2luZGV4LmpzPzQyYWMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBzZXBhcmF0ZU1vcnBoLCBjb21iaW5lTW9ycGgsIG1vcnBoUGF0aCwgaXNDb21iaW5lTW9ycGhpbmcgfSBmcm9tICd6cmVuZGVyL2xpYi90b29sL21vcnBoUGF0aC5qcyc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCB7IGRlZmF1bHRzLCBpc0FycmF5IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGdldEFuaW1hdGlvbkNvbmZpZyB9IGZyb20gJy4vYmFzaWNUcmFuc2l0aW9uLmpzJztcbmltcG9ydCB7IGNsb25lUGF0aCB9IGZyb20gJ3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qcyc7XG5mdW5jdGlvbiBpc011bHRpcGxlKGVsZW1lbnRzKSB7XG4gIHJldHVybiBpc0FycmF5KGVsZW1lbnRzWzBdKTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVNb3JwaEJhdGNoZXMob25lLCBtYW55KSB7XG4gIHZhciBiYXRjaGVzID0gW107XG4gIHZhciBiYXRjaENvdW50ID0gb25lLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaENvdW50OyBpKyspIHtcbiAgICBiYXRjaGVzLnB1c2goe1xuICAgICAgb25lOiBvbmVbaV0sXG4gICAgICBtYW55OiBbXVxuICAgIH0pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFueS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsZW4gPSBtYW55W2ldLmxlbmd0aDtcbiAgICB2YXIgayA9IHZvaWQgMDtcbiAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIGJhdGNoZXNbayAlIGJhdGNoQ291bnRdLm1hbnkucHVzaChtYW55W2ldW2tdKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9mZiA9IDA7XG4gIC8vIElmIG9uZSBoYXMgbW9yZSBwYXRocyB0aGFuIGVhY2ggb25lIG9mIG1hbnkuIGF2ZXJhZ2UgdGhlbS5cbiAgZm9yICh2YXIgaSA9IGJhdGNoQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmICghYmF0Y2hlc1tpXS5tYW55Lmxlbmd0aCkge1xuICAgICAgdmFyIG1vdmVGcm9tID0gYmF0Y2hlc1tvZmZdLm1hbnk7XG4gICAgICBpZiAobW92ZUZyb20ubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgLy8gTm90IGVub3VnaFxuICAgICAgICAvLyBTdGFydCBmcm9tIHRoZSBmaXJzdCBvbmUuXG4gICAgICAgIGlmIChvZmYpIHtcbiAgICAgICAgICBvZmYgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBiYXRjaGVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbGVuID0gbW92ZUZyb20ubGVuZ3RoO1xuICAgICAgdmFyIG1pZCA9IE1hdGguY2VpbChsZW4gLyAyKTtcbiAgICAgIGJhdGNoZXNbaV0ubWFueSA9IG1vdmVGcm9tLnNsaWNlKG1pZCwgbGVuKTtcbiAgICAgIGJhdGNoZXNbb2ZmXS5tYW55ID0gbW92ZUZyb20uc2xpY2UoMCwgbWlkKTtcbiAgICAgIG9mZisrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmF0Y2hlcztcbn1cbnZhciBwYXRoRGl2aWRlcnMgPSB7XG4gIGNsb25lOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIC8vIEZpdHRpbmcgdGhlIGFscGhhXG4gICAgdmFyIGFwcHJveE9wYWNpdHkgPSAxIC0gTWF0aC5wb3coMSAtIHBhcmFtcy5wYXRoLnN0eWxlLm9wYWNpdHksIDEgLyBwYXJhbXMuY291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmNvdW50OyBpKyspIHtcbiAgICAgIHZhciBjbG9uZWQgPSBjbG9uZVBhdGgocGFyYW1zLnBhdGgpO1xuICAgICAgY2xvbmVkLnNldFN0eWxlKCdvcGFjaXR5JywgYXBwcm94T3BhY2l0eSk7XG4gICAgICByZXQucHVzaChjbG9uZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICAvLyBVc2UgdGhlIGRlZmF1bHQgZGl2aWRlclxuICBzcGxpdDogbnVsbFxufTtcbmV4cG9ydCBmdW5jdGlvbiBhcHBseU1vcnBoQW5pbWF0aW9uKGZyb20sIHRvLCBkaXZpZGVTaGFwZSwgc2VyaWVzTW9kZWwsIGRhdGFJbmRleCwgYW5pbWF0ZU90aGVyUHJvcHMpIHtcbiAgaWYgKCFmcm9tLmxlbmd0aCB8fCAhdG8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB1cGRhdGVBbmltYXRpb25DZmcgPSBnZXRBbmltYXRpb25Db25maWcoJ3VwZGF0ZScsIHNlcmllc01vZGVsLCBkYXRhSW5kZXgpO1xuICBpZiAoISh1cGRhdGVBbmltYXRpb25DZmcgJiYgdXBkYXRlQW5pbWF0aW9uQ2ZnLmR1cmF0aW9uID4gMCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGFuaW1hdGlvbkRlbGF5ID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ3VuaXZlcnNhbFRyYW5zaXRpb24nKS5nZXQoJ2RlbGF5Jyk7XG4gIHZhciBhbmltYXRpb25DZmcgPSBPYmplY3QuYXNzaWduKHtcbiAgICAvLyBOZWVkIHRvIHNldFRvRmluYWwgc28gdGhlIGZ1cnRoZXIgY2FsY3VsYXRpb24gYmFzZWQgb24gdGhlIHN0eWxlIGNhbiBiZSBjb3JyZWN0LlxuICAgIC8vIExpa2UgZW1waGFzaXMgY29sb3IuXG4gICAgc2V0VG9GaW5hbDogdHJ1ZVxuICB9LCB1cGRhdGVBbmltYXRpb25DZmcpO1xuICB2YXIgbWFueTtcbiAgdmFyIG9uZTtcbiAgaWYgKGlzTXVsdGlwbGUoZnJvbSkpIHtcbiAgICAvLyBtYW55VG9PbmVcbiAgICBtYW55ID0gZnJvbTtcbiAgICBvbmUgPSB0bztcbiAgfVxuICBpZiAoaXNNdWx0aXBsZSh0bykpIHtcbiAgICAvLyBvbmVUb01hbnlcbiAgICBtYW55ID0gdG87XG4gICAgb25lID0gZnJvbTtcbiAgfVxuICBmdW5jdGlvbiBtb3JwaE9uZUJhdGNoKGJhdGNoLCBmcm9tSXNNYW55LCBhbmltYXRlSW5kZXgsIGFuaW1hdGVDb3VudCwgZm9yY2VNYW55T25lKSB7XG4gICAgdmFyIGJhdGNoTWFueSA9IGJhdGNoLm1hbnk7XG4gICAgdmFyIGJhdGNoT25lID0gYmF0Y2gub25lO1xuICAgIGlmIChiYXRjaE1hbnkubGVuZ3RoID09PSAxICYmICFmb3JjZU1hbnlPbmUpIHtcbiAgICAgIC8vIElzIG9uZSB0byBvbmVcbiAgICAgIHZhciBiYXRjaEZyb20gPSBmcm9tSXNNYW55ID8gYmF0Y2hNYW55WzBdIDogYmF0Y2hPbmU7XG4gICAgICB2YXIgYmF0Y2hUbyA9IGZyb21Jc01hbnkgPyBiYXRjaE9uZSA6IGJhdGNoTWFueVswXTtcbiAgICAgIGlmIChpc0NvbWJpbmVNb3JwaGluZyhiYXRjaEZyb20pKSB7XG4gICAgICAgIC8vIEtlZXAgZG9pbmcgY29tYmluZSBhbmltYXRpb24uXG4gICAgICAgIG1vcnBoT25lQmF0Y2goe1xuICAgICAgICAgIG1hbnk6IFtiYXRjaEZyb21dLFxuICAgICAgICAgIG9uZTogYmF0Y2hUb1xuICAgICAgICB9LCB0cnVlLCBhbmltYXRlSW5kZXgsIGFuaW1hdGVDb3VudCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW5kaXZpZHVhbEFuaW1hdGlvbkNmZyA9IGFuaW1hdGlvbkRlbGF5ID8gZGVmYXVsdHMoe1xuICAgICAgICAgIGRlbGF5OiBhbmltYXRpb25EZWxheShhbmltYXRlSW5kZXgsIGFuaW1hdGVDb3VudClcbiAgICAgICAgfSwgYW5pbWF0aW9uQ2ZnKSA6IGFuaW1hdGlvbkNmZztcbiAgICAgICAgbW9ycGhQYXRoKGJhdGNoRnJvbSwgYmF0Y2hUbywgaW5kaXZpZHVhbEFuaW1hdGlvbkNmZyk7XG4gICAgICAgIGFuaW1hdGVPdGhlclByb3BzKGJhdGNoRnJvbSwgYmF0Y2hUbywgYmF0Y2hGcm9tLCBiYXRjaFRvLCBpbmRpdmlkdWFsQW5pbWF0aW9uQ2ZnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlcGFyYXRlQW5pbWF0aW9uQ2ZnID0gZGVmYXVsdHMoe1xuICAgICAgICBkaXZpZGVQYXRoOiBwYXRoRGl2aWRlcnNbZGl2aWRlU2hhcGVdLFxuICAgICAgICBpbmRpdmlkdWFsRGVsYXk6IGFuaW1hdGlvbkRlbGF5ICYmIGZ1bmN0aW9uIChpZHgsIGNvdW50LCBmcm9tUGF0aCwgdG9QYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbkRlbGF5KGlkeCArIGFuaW1hdGVJbmRleCwgYW5pbWF0ZUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgYW5pbWF0aW9uQ2ZnKTtcbiAgICAgIHZhciBfYSA9IGZyb21Jc01hbnkgPyBjb21iaW5lTW9ycGgoYmF0Y2hNYW55LCBiYXRjaE9uZSwgc2VwYXJhdGVBbmltYXRpb25DZmcpIDogc2VwYXJhdGVNb3JwaChiYXRjaE9uZSwgYmF0Y2hNYW55LCBzZXBhcmF0ZUFuaW1hdGlvbkNmZyksXG4gICAgICAgIGZyb21JbmRpdmlkdWFscyA9IF9hLmZyb21JbmRpdmlkdWFscyxcbiAgICAgICAgdG9JbmRpdmlkdWFscyA9IF9hLnRvSW5kaXZpZHVhbHM7XG4gICAgICB2YXIgY291bnQgPSBmcm9tSW5kaXZpZHVhbHMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjb3VudDsgaysrKSB7XG4gICAgICAgIHZhciBpbmRpdmlkdWFsQW5pbWF0aW9uQ2ZnID0gYW5pbWF0aW9uRGVsYXkgPyBkZWZhdWx0cyh7XG4gICAgICAgICAgZGVsYXk6IGFuaW1hdGlvbkRlbGF5KGssIGNvdW50KVxuICAgICAgICB9LCBhbmltYXRpb25DZmcpIDogYW5pbWF0aW9uQ2ZnO1xuICAgICAgICBhbmltYXRlT3RoZXJQcm9wcyhmcm9tSW5kaXZpZHVhbHNba10sIHRvSW5kaXZpZHVhbHNba10sIGZyb21Jc01hbnkgPyBiYXRjaE1hbnlba10gOiBiYXRjaC5vbmUsIGZyb21Jc01hbnkgPyBiYXRjaC5vbmUgOiBiYXRjaE1hbnlba10sIGluZGl2aWR1YWxBbmltYXRpb25DZmcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZnJvbUlzTWFueSA9IG1hbnkgPyBtYW55ID09PSBmcm9tXG4gIC8vIElzIG9uZSB0byBvbmUuIElmIHRoZSBwYXRoIG51bWJlciBub3QgbWF0Y2guIGFsc28gbmVlZHMgZG8gbWVyZ2UgYW5kIHNlcGFyYXRlIG1vcnBoaW5nLlxuICA6IGZyb20ubGVuZ3RoID4gdG8ubGVuZ3RoO1xuICB2YXIgbW9ycGhCYXRjaGVzID0gbWFueSA/IHByZXBhcmVNb3JwaEJhdGNoZXMob25lLCBtYW55KSA6IHByZXBhcmVNb3JwaEJhdGNoZXMoZnJvbUlzTWFueSA/IHRvIDogZnJvbSwgW2Zyb21Jc01hbnkgPyBmcm9tIDogdG9dKTtcbiAgdmFyIGFuaW1hdGVDb3VudCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbW9ycGhCYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgYW5pbWF0ZUNvdW50ICs9IG1vcnBoQmF0Y2hlc1tpXS5tYW55Lmxlbmd0aDtcbiAgfVxuICB2YXIgYW5pbWF0ZUluZGV4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3JwaEJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBtb3JwaE9uZUJhdGNoKG1vcnBoQmF0Y2hlc1tpXSwgZnJvbUlzTWFueSwgYW5pbWF0ZUluZGV4LCBhbmltYXRlQ291bnQpO1xuICAgIGFuaW1hdGVJbmRleCArPSBtb3JwaEJhdGNoZXNbaV0ubWFueS5sZW5ndGg7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXRoTGlzdChlbGVtZW50cykge1xuICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChpc0FycmF5KGVsZW1lbnRzKSkge1xuICAgIHZhciBwYXRoTGlzdF8xID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgcGF0aExpc3RfMS5wdXNoKGdldFBhdGhMaXN0KGVsZW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoTGlzdF8xO1xuICB9XG4gIHZhciBwYXRoTGlzdCA9IFtdO1xuICBlbGVtZW50cy50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBQYXRoICYmICFlbC5kaXNhYmxlTW9ycGhpbmcgJiYgIWVsLmludmlzaWJsZSAmJiAhZWwuaWdub3JlKSB7XG4gICAgICBwYXRoTGlzdC5wdXNoKGVsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcGF0aExpc3Q7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG4vLyBVbml2ZXJzYWwgdHJhbnNpdGlvbnMgdGhhdCBjYW4gYW5pbWF0ZSBiZXR3ZWVuIGFueSBzaGFwZXMoc2VyaWVzKSBhbmQgYW55IHByb3BlcnRpZXMgaW4gYW55IGFtb3VudHMuXG5pbXBvcnQgeyBTRVJJRVNfVU5JVkVSU0FMX1RSQU5TSVRJT05fUFJPUCB9IGZyb20gJy4uL21vZGVsL1Nlcmllcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoTWFwLCBlYWNoLCBtYXAsIGZpbHRlciwgaXNBcnJheSwgZXh0ZW5kIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGFwcGx5TW9ycGhBbmltYXRpb24sIGdldFBhdGhMaXN0IH0gZnJvbSAnLi9tb3JwaFRyYW5zaXRpb25IZWxwZXIuanMnO1xuaW1wb3J0IFBhdGggZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzJztcbmltcG9ydCB7IGluaXRQcm9wcyB9IGZyb20gJy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG5pbXBvcnQgRGF0YURpZmZlciBmcm9tICcuLi9kYXRhL0RhdGFEaWZmZXIuanMnO1xuaW1wb3J0IHsgbWFrZUlubmVyLCBub3JtYWxpemVUb0FycmF5IH0gZnJvbSAnLi4vdXRpbC9tb2RlbC5qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vdXRpbC9sb2cuanMnO1xuaW1wb3J0IHsgZ2V0QW5pbWF0aW9uQ29uZmlnLCBnZXRPbGRTdHlsZSB9IGZyb20gJy4vYmFzaWNUcmFuc2l0aW9uLmpzJztcbmltcG9ydCBEaXNwbGF5YWJsZSBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL0Rpc3BsYXlhYmxlLmpzJztcbnZhciBEQVRBX0NPVU5UX1RIUkVTSE9MRCA9IDFlNDtcbnZhciBUUkFOU0lUSU9OX05PTkUgPSAwO1xudmFyIFRSQU5TSVRJT05fUDJDID0gMTtcbnZhciBUUkFOU0lUSU9OX0MyUCA9IDI7XG47XG52YXIgZ2V0VW5pdmVyc2FsVHJhbnNpdGlvbkdsb2JhbFN0b3JlID0gbWFrZUlubmVyKCk7XG5mdW5jdGlvbiBnZXREaW1lbnNpb24oZGF0YSwgdmlzdWFsRGltZW5zaW9uKSB7XG4gIHZhciBkaW1lbnNpb25zID0gZGF0YS5kaW1lbnNpb25zO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGltSW5mbyA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1lbnNpb25zW2ldKTtcbiAgICBpZiAoZGltSW5mbyAmJiBkaW1JbmZvLm90aGVyRGltc1t2aXN1YWxEaW1lbnNpb25dID09PSAwKSB7XG4gICAgICByZXR1cm4gZGltZW5zaW9uc1tpXTtcbiAgICB9XG4gIH1cbn1cbi8vIGdldCB2YWx1ZSBieSBkaW1lbnNpb24uIChvbmx5IGdldCB2YWx1ZSBvZiBpdGVtR3JvdXBJZCBvciBjaGlsZEdyb3VwSWQsIHNvIGNvbnZlcnQgaXQgdG8gc3RyaW5nKVxuZnVuY3Rpb24gZ2V0VmFsdWVCeURpbWVuc2lvbihkYXRhLCBkYXRhSW5kZXgsIGRpbWVuc2lvbikge1xuICB2YXIgZGltSW5mbyA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1lbnNpb24pO1xuICB2YXIgZGltT3JkaW5hbE1ldGEgPSBkaW1JbmZvICYmIGRpbUluZm8ub3JkaW5hbE1ldGE7XG4gIGlmIChkaW1JbmZvKSB7XG4gICAgdmFyIHZhbHVlID0gZGF0YS5nZXQoZGltSW5mby5uYW1lLCBkYXRhSW5kZXgpO1xuICAgIGlmIChkaW1PcmRpbmFsTWV0YSkge1xuICAgICAgcmV0dXJuIGRpbU9yZGluYWxNZXRhLmNhdGVnb3JpZXNbdmFsdWVdIHx8IHZhbHVlICsgJyc7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSArICcnO1xuICB9XG59XG5mdW5jdGlvbiBnZXRHcm91cElkKGRhdGEsIGRhdGFJbmRleCwgZGF0YUdyb3VwSWQsIGlzQ2hpbGQpIHtcbiAgLy8gdHJ5IHRvIGdldCBncm91cElkIGZyb20gZW5jb2RlXG4gIHZhciB2aXN1YWxEaW1lbnNpb24gPSBpc0NoaWxkID8gJ2l0ZW1DaGlsZEdyb3VwSWQnIDogJ2l0ZW1Hcm91cElkJztcbiAgdmFyIGdyb3VwSWREaW0gPSBnZXREaW1lbnNpb24oZGF0YSwgdmlzdWFsRGltZW5zaW9uKTtcbiAgaWYgKGdyb3VwSWREaW0pIHtcbiAgICB2YXIgZ3JvdXBJZCA9IGdldFZhbHVlQnlEaW1lbnNpb24oZGF0YSwgZGF0YUluZGV4LCBncm91cElkRGltKTtcbiAgICByZXR1cm4gZ3JvdXBJZDtcbiAgfVxuICAvLyB0cnkgdG8gZ2V0IGdyb3VwSWQgZnJvbSByYXcgZGF0YSBpdGVtXG4gIHZhciByYXdEYXRhSXRlbSA9IGRhdGEuZ2V0UmF3RGF0YUl0ZW0oZGF0YUluZGV4KTtcbiAgdmFyIHByb3BlcnR5ID0gaXNDaGlsZCA/ICdjaGlsZEdyb3VwSWQnIDogJ2dyb3VwSWQnO1xuICBpZiAocmF3RGF0YUl0ZW0gJiYgcmF3RGF0YUl0ZW1bcHJvcGVydHldKSB7XG4gICAgcmV0dXJuIHJhd0RhdGFJdGVtW3Byb3BlcnR5XSArICcnO1xuICB9XG4gIC8vIGZhbGxiYWNrXG4gIGlmIChpc0NoaWxkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHRyeSB0byB1c2Ugc2VyaWVzLmRhdGFHcm91cElkIGFzIGdyb3VwSWQsIG90aGVyd2lzZSB1c2UgZGF0YUl0ZW0ncyBpZCBhcyBncm91cElkXG4gIHJldHVybiBkYXRhR3JvdXBJZCB8fCBkYXRhLmdldElkKGRhdGFJbmRleCk7XG59XG4vLyBmbGF0dGVuIGFsbCBkYXRhIGl0ZW1zIGZyb20gZGlmZmVyZW50IHNlcmllc2VzIGludG8gb25lIGFycmFyeVxuZnVuY3Rpb24gZmxhdHRlbkRhdGFEaWZmSXRlbXMobGlzdCkge1xuICB2YXIgaXRlbXMgPSBbXTtcbiAgZWFjaChsaXN0LCBmdW5jdGlvbiAoc2VyaWVzSW5mbykge1xuICAgIHZhciBkYXRhID0gc2VyaWVzSW5mby5kYXRhO1xuICAgIHZhciBkYXRhR3JvdXBJZCA9IHNlcmllc0luZm8uZGF0YUdyb3VwSWQ7XG4gICAgaWYgKGRhdGEuY291bnQoKSA+IERBVEFfQ09VTlRfVEhSRVNIT0xEKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdVbml2ZXJzYWwgdHJhbnNpdGlvbiBpcyBkaXNhYmxlZCBvbiBsYXJnZSBkYXRhID4gMTBrLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaW5kaWNlcyA9IGRhdGEuZ2V0SW5kaWNlcygpO1xuICAgIGZvciAodmFyIGRhdGFJbmRleCA9IDA7IGRhdGFJbmRleCA8IGluZGljZXMubGVuZ3RoOyBkYXRhSW5kZXgrKykge1xuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGdyb3VwSWQ6IGdldEdyb3VwSWQoZGF0YSwgZGF0YUluZGV4LCBkYXRhR3JvdXBJZCwgZmFsc2UpLFxuICAgICAgICBjaGlsZEdyb3VwSWQ6IGdldEdyb3VwSWQoZGF0YSwgZGF0YUluZGV4LCBkYXRhR3JvdXBJZCwgdHJ1ZSksXG4gICAgICAgIGRpdmlkZTogc2VyaWVzSW5mby5kaXZpZGUsXG4gICAgICAgIGRhdGFJbmRleDogZGF0YUluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBmYWRlSW5FbGVtZW50KG5ld0VsLCBuZXdTZXJpZXMsIG5ld0luZGV4KSB7XG4gIG5ld0VsLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICAgIC8vIFRPRE8gdXNlIGZhZGUgaW4gYW5pbWF0aW9uIGZvciB0YXJnZXQgZWxlbWVudC5cbiAgICAgIGluaXRQcm9wcyhlbCwge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfVxuICAgICAgfSwgbmV3U2VyaWVzLCB7XG4gICAgICAgIGRhdGFJbmRleDogbmV3SW5kZXgsXG4gICAgICAgIGlzRnJvbTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUVsKGVsKSB7XG4gIGlmIChlbC5wYXJlbnQpIHtcbiAgICAvLyBCYWtlIHBhcmVudCB0cmFuc2Zvcm0gdG8gZWxlbWVudC5cbiAgICAvLyBTbyBpdCBjYW4gc3RpbGwgaGF2ZSBwcm9wZXIgdHJhbnNmb3JtIHRvIHRyYW5zaXRpb24gYWZ0ZXIgaXQncyByZW1vdmVkLlxuICAgIHZhciBjb21wdXRlZFRyYW5zZm9ybSA9IGVsLmdldENvbXB1dGVkVHJhbnNmb3JtKCk7XG4gICAgZWwuc2V0TG9jYWxUcmFuc2Zvcm0oY29tcHV0ZWRUcmFuc2Zvcm0pO1xuICAgIGVsLnBhcmVudC5yZW1vdmUoZWwpO1xuICB9XG59XG5mdW5jdGlvbiBzdG9wQW5pbWF0aW9uKGVsKSB7XG4gIGVsLnN0b3BBbmltYXRpb24oKTtcbiAgaWYgKGVsLmlzR3JvdXApIHtcbiAgICBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGNoaWxkLnN0b3BBbmltYXRpb24oKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYW5pbWF0ZUVsZW1lbnRTdHlsZXMoZWwsIGRhdGFJbmRleCwgc2VyaWVzTW9kZWwpIHtcbiAgdmFyIGFuaW1hdGlvbkNvbmZpZyA9IGdldEFuaW1hdGlvbkNvbmZpZygndXBkYXRlJywgc2VyaWVzTW9kZWwsIGRhdGFJbmRleCk7XG4gIGFuaW1hdGlvbkNvbmZpZyAmJiBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBEaXNwbGF5YWJsZSkge1xuICAgICAgdmFyIG9sZFN0eWxlID0gZ2V0T2xkU3R5bGUoY2hpbGQpO1xuICAgICAgaWYgKG9sZFN0eWxlKSB7XG4gICAgICAgIGNoaWxkLmFuaW1hdGVGcm9tKHtcbiAgICAgICAgICBzdHlsZTogb2xkU3R5bGVcbiAgICAgICAgfSwgYW5pbWF0aW9uQ29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNBbGxJZFNhbWUob2xkRGlmZkl0ZW1zLCBuZXdEaWZmSXRlbXMpIHtcbiAgdmFyIGxlbiA9IG9sZERpZmZJdGVtcy5sZW5ndGg7XG4gIGlmIChsZW4gIT09IG5ld0RpZmZJdGVtcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBvbGRJdGVtID0gb2xkRGlmZkl0ZW1zW2ldO1xuICAgIHZhciBuZXdJdGVtID0gbmV3RGlmZkl0ZW1zW2ldO1xuICAgIGlmIChvbGRJdGVtLmRhdGEuZ2V0SWQob2xkSXRlbS5kYXRhSW5kZXgpICE9PSBuZXdJdGVtLmRhdGEuZ2V0SWQobmV3SXRlbS5kYXRhSW5kZXgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbkJldHdlZW4ob2xkTGlzdCwgbmV3TGlzdCwgYXBpKSB7XG4gIHZhciBvbGREaWZmSXRlbXMgPSBmbGF0dGVuRGF0YURpZmZJdGVtcyhvbGRMaXN0KTtcbiAgdmFyIG5ld0RpZmZJdGVtcyA9IGZsYXR0ZW5EYXRhRGlmZkl0ZW1zKG5ld0xpc3QpO1xuICBmdW5jdGlvbiB1cGRhdGVNb3JwaGluZ1BhdGhQcm9wcyhmcm9tLCB0bywgcmF3RnJvbSwgcmF3VG8sIGFuaW1hdGlvbkNmZykge1xuICAgIGlmIChyYXdGcm9tIHx8IGZyb20pIHtcbiAgICAgIHRvLmFuaW1hdGVGcm9tKHtcbiAgICAgICAgc3R5bGU6IHJhd0Zyb20gJiYgcmF3RnJvbSAhPT0gZnJvbVxuICAgICAgICAvLyBkaXZpZGluZ01ldGhvZCBsaWtlIGNsb25lIG1heSBvdmVycmlkZSB0aGUgc3R5bGUob3BhY2l0eSlcbiAgICAgICAgLy8gU28gZXh0ZW5kIGl0IHRvIHJhdyBzdHlsZS5cbiAgICAgICAgPyBleHRlbmQoZXh0ZW5kKHt9LCByYXdGcm9tLnN0eWxlKSwgZnJvbS5zdHlsZSkgOiBmcm9tLnN0eWxlXG4gICAgICB9LCBhbmltYXRpb25DZmcpO1xuICAgIH1cbiAgfVxuICB2YXIgaGFzTW9ycGhBbmltYXRpb24gPSBmYWxzZTtcbiAgLyoqXHJcbiAgICogV2l0aCBncm91cElkIGFuZCBjaGlsZEdyb3VwSWQsIHdlIGNhbiBidWlsZCBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwcyBiZXR3ZWVuIGRhdGFJdGVtcy5cclxuICAgKiBIb3dldmVyLCB3ZSBzaG91bGQgbWluZCB0aGUgcGFyZW50LWNoaWxkIFwiZGlyZWN0aW9uXCIgYmV0d2VlbiBvbGQgYW5kIG5ldyBvcHRpb25zLlxyXG4gICAqXHJcbiAgICogRm9yIGV4YW1wbGUsIHN1cHBvc2Ugd2UgaGF2ZSB0d28gZGF0YUl0ZW1zIGZyb20gdHdvIHNlcmllcy5kYXRhOlxyXG4gICAqXHJcbiAgICogZGF0YUE6IFsgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFCOiBbXHJcbiAgICogICB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAqICAgICB2YWx1ZTogNSwgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDMsXHJcbiAgICogICAgIGdyb3VwSWQ6ICdjcmVhdHVyZXMnLCAgICAgICAgICAgICBncm91cElkOiAnYW5pbWFscycsXHJcbiAgICogICAgIGNoaWxkR3JvdXBJZDogJ2FuaW1hbHMnICAgICAgICAgICBjaGlsZEdyb3VwSWQ6ICdkb2dzJ1xyXG4gICAqICAgfSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICogICAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uXHJcbiAgICogXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cclxuICAgKlxyXG4gICAqIHdoZXJlIGRhdGFBIGlzIGJlbG9uZyB0byBvcHRpb25BIGFuZCBkYXRhQiBpcyBiZWxvbmcgdG8gb3B0aW9uQi5cclxuICAgKlxyXG4gICAqIFdoZW4gd2UgYHNldE9wdGlvbihvcHRpb25CKWAgZnJvbSBvcHRpb25BLCB3ZSBjaG9vc2UgY2hpbGRHcm91cElkIG9mIGRhdGFJdGVtQSBhbmQgZ3JvdXBJZCBvZlxyXG4gICAqIGRhdGFJdGVtQiBhcyBrZXlzIHNvIHRoZSB0d28ga2V5cyBhcmUgbWF0Y2hlZCAoYm90aCBhcmUgJ2FuaW1hbHMnKSwgdGhlbiB1bml2ZXJzYWxUcmFuc2l0aW9uXHJcbiAgICogd2lsbCB3b3JrLiBUaGlzIGRlcmVjdGlvbiBpcyBcInBhcmVudCAtPiBjaGlsZFwiLlxyXG4gICAqXHJcbiAgICogSWYgd2UgYHNldE9wdGlvbihvcHRpb25BKWAgZnJvbSBvcHRpb25CLCB3ZSBhbHNvIGNob29zZSBncm91cElkIG9mIGRhdGFJdGVtQiBhbmQgY2hpbGRHcm91cElkXHJcbiAgICogb2YgZGF0YUl0ZW1BIGFzIGtleXMgYW5kIHVuaXZlcnNhbFRyYW5zaXRpb24gd2lsbCB3b3JrLiBUaGlzIGRlcmVjdGlvbiBpcyBcImNoaWxkIC0+IHBhcmVudFwiLlxyXG4gICAqXHJcbiAgICogSWYgdGhlcmUgaXMgbm8gY2hpbGRHcm91cElkIHNwZWNpZmllZCwgd2hpY2ggbWVhbnMgbm8gbXVsdGlMZXZlbERyaWxsRG93bi9VcCBpcyBuZWVkZWQgYW5kIG5vXHJcbiAgICogcGFyZW50LWNoaWxkIHJlbGF0aW9uc2hpcCBleGlzdHMuIFRoaXMgZGlyZWN0aW9uIGlzIFwibm9uZVwiLlxyXG4gICAqXHJcbiAgICogU28gd2UgbmVlZCB0byBrbm93IHdoZXRoZXIgdG8gdXNlIGdyb3VwSWQgb3IgY2hpbGRHcm91cElkIGFzIHRoZSBrZXkgd2hlbiB3ZSBjYWxsIHRoZSBrZXlHZXR0ZXJcclxuICAgKiBmdW5jdGlvbnMuIFRodXMsIHdlIG5lZWQgdG8gZGVjaWRlIHRoZSBkaXJlY3Rpb24gZmlyc3QuXHJcbiAgICpcclxuICAgKiBUaGUgcnVsZSBpczpcclxuICAgKlxyXG4gICAqIGlmIChhbGwgY2hpbGRHcm91cElkcyBpbiBvbGREaWZmSXRlbXMgYW5kIGFsbCBncm91cElkcyBpbiBuZXdEaWZmSXRlbXMgaGF2ZSBjb21tb24gdmFsdWUpIHtcclxuICAgKiAgIGRpcmVjdGlvbiA9ICdwYXJlbnQgLT4gY2hpbGQnO1xyXG4gICAqIH0gZWxzZSBpZiAoYWxsIGdyb3VwSWRzIGluIG9sZERpZmZJdGVtcyBhbmQgYWxsIGNoaWxkR3JvdXBJZHMgaW4gbmV3RGlmZkl0ZW1zIGhhdmUgY29tbW9uIHZhbHVlKSB7XHJcbiAgICogICBkaXJlY3Rpb24gPSAnY2hpbGQgLT4gcGFyZW50JztcclxuICAgKiB9IGVsc2Uge1xyXG4gICAqICAgZGlyZWN0aW9uID0gJ25vbmUnO1xyXG4gICAqIH1cclxuICAgKi9cbiAgdmFyIGRpcmVjdGlvbiA9IFRSQU5TSVRJT05fTk9ORTtcbiAgLy8gZmluZCBhbGwgZ3JvdXBJZHMgYW5kIGNoaWxkR3JvdXBJZHMgZnJvbSBvbGREaWZmSXRlbXNcbiAgdmFyIG9sZEdyb3VwSWRzID0gY3JlYXRlSGFzaE1hcCgpO1xuICB2YXIgb2xkQ2hpbGRHcm91cElkcyA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgb2xkRGlmZkl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpdGVtLmdyb3VwSWQgJiYgb2xkR3JvdXBJZHMuc2V0KGl0ZW0uZ3JvdXBJZCwgdHJ1ZSk7XG4gICAgaXRlbS5jaGlsZEdyb3VwSWQgJiYgb2xkQ2hpbGRHcm91cElkcy5zZXQoaXRlbS5jaGlsZEdyb3VwSWQsIHRydWUpO1xuICB9KTtcbiAgLy8gdHJhdmVyc2UgbmV3RGlmZkl0ZW1zIGFuZCBkZWNpZGUgdGhlIGRpcmVjdGlvbiBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdEaWZmSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmV3R3JvdXBJZCA9IG5ld0RpZmZJdGVtc1tpXS5ncm91cElkO1xuICAgIGlmIChvbGRDaGlsZEdyb3VwSWRzLmdldChuZXdHcm91cElkKSkge1xuICAgICAgZGlyZWN0aW9uID0gVFJBTlNJVElPTl9QMkM7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIG5ld0NoaWxkR3JvdXBJZCA9IG5ld0RpZmZJdGVtc1tpXS5jaGlsZEdyb3VwSWQ7XG4gICAgaWYgKG5ld0NoaWxkR3JvdXBJZCAmJiBvbGRHcm91cElkcy5nZXQobmV3Q2hpbGRHcm91cElkKSkge1xuICAgICAgZGlyZWN0aW9uID0gVFJBTlNJVElPTl9DMlA7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlS2V5R2V0dGVyKGlzT2xkLCBvbmx5R2V0SWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRpZmZJdGVtKSB7XG4gICAgICB2YXIgZGF0YSA9IGRpZmZJdGVtLmRhdGE7XG4gICAgICB2YXIgZGF0YUluZGV4ID0gZGlmZkl0ZW0uZGF0YUluZGV4O1xuICAgICAgLy8gVE9ETyBpZiBzcGVjaWZpZWQgZGltXG4gICAgICBpZiAob25seUdldElkKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmdldElkKGRhdGFJbmRleCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPbGQpIHtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gVFJBTlNJVElPTl9QMkMgPyBkaWZmSXRlbS5jaGlsZEdyb3VwSWQgOiBkaWZmSXRlbS5ncm91cElkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gVFJBTlNJVElPTl9DMlAgPyBkaWZmSXRlbS5jaGlsZEdyb3VwSWQgOiBkaWZmSXRlbS5ncm91cElkO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLy8gVXNlIGlkIGlmIGl0J3MgdmVyeSBsaWtlbHkgdG8gYmUgYW4gb25lIHRvIG9uZSBhbmltYXRpb25cbiAgLy8gSXQncyBtb3JlIHJvYnVzdCB0aGFuIGdyb3VwSWRcbiAgLy8gVE9ETyBDaGVjayBpZiBrZXkgZGltZW5zaW9uIGlzIHNwZWNpZmllZC5cbiAgdmFyIHVzZUlkID0gaXNBbGxJZFNhbWUob2xkRGlmZkl0ZW1zLCBuZXdEaWZmSXRlbXMpO1xuICB2YXIgaXNFbGVtZW50U3RpbGxJbkNoYXJ0ID0ge307XG4gIGlmICghdXNlSWQpIHtcbiAgICAvLyBXZSBtYXkgaGF2ZSBkaWZmZXJlbnQgZGlmZiBzdHJhdGVneSB3aXRoIGJhc2ljVHJhbnNpdGlvbiBpZiB3ZSB1c2Ugb3RoZXIgZGltZW5zaW9uIGFzIGtleS5cbiAgICAvLyBJZiBzbywgd2UgY2FuJ3Qgc2ltcGx5IGNoZWNrIGlmIG9sZEVsIGlzIHNhbWUgd2l0aCBuZXdFbC4gV2UgbmVlZCBhIG1hcCB0byBjaGVjayBpZiBvbGRFbCBpcyBzdGlsbCBiZWluZyB1c2VkIGluIHRoZSBuZXcgY2hhcnQuXG4gICAgLy8gV2UgY2FuJ3QgdXNlIHRoZSBlbGVtZW50cyB0aGF0IGFscmVhZHkgYmVpbmcgbW9ycGhlZC4gTGV0IGl0IGtlZXAgaXQncyBvcmlnaW5hbCBiYXNpYyB0cmFuc2l0aW9uLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RGlmZkl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV3SXRlbSA9IG5ld0RpZmZJdGVtc1tpXTtcbiAgICAgIHZhciBlbCA9IG5ld0l0ZW0uZGF0YS5nZXRJdGVtR3JhcGhpY0VsKG5ld0l0ZW0uZGF0YUluZGV4KTtcbiAgICAgIGlmIChlbCkge1xuICAgICAgICBpc0VsZW1lbnRTdGlsbEluQ2hhcnRbZWwuaWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlT25lVG9PbmUobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gICAgdmFyIG9sZEl0ZW0gPSBvbGREaWZmSXRlbXNbb2xkSW5kZXhdO1xuICAgIHZhciBuZXdJdGVtID0gbmV3RGlmZkl0ZW1zW25ld0luZGV4XTtcbiAgICB2YXIgbmV3U2VyaWVzID0gbmV3SXRlbS5kYXRhLmhvc3RNb2RlbDtcbiAgICAvLyBUT0RPIE1hcmsgdGhpcyBlbGVtZW50cyBpcyBtb3JwaGVkIGFuZCBkb24ndCBtb3JwaCB0aGVtIGFueW1vcmVcbiAgICB2YXIgb2xkRWwgPSBvbGRJdGVtLmRhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJdGVtLmRhdGFJbmRleCk7XG4gICAgdmFyIG5ld0VsID0gbmV3SXRlbS5kYXRhLmdldEl0ZW1HcmFwaGljRWwobmV3SXRlbS5kYXRhSW5kZXgpO1xuICAgIC8vIENhbid0IGhhbmRsZSBzYW1lIGVsZW1lbnRzLlxuICAgIGlmIChvbGRFbCA9PT0gbmV3RWwpIHtcbiAgICAgIG5ld0VsICYmIGFuaW1hdGVFbGVtZW50U3R5bGVzKG5ld0VsLCBuZXdJdGVtLmRhdGFJbmRleCwgbmV3U2VyaWVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFxuICAgIC8vIFdlIGNhbid0IHVzZSB0aGUgZWxlbWVudHMgdGhhdCBhbHJlYWR5IGJlaW5nIG1vcnBoZWRcbiAgICBvbGRFbCAmJiBpc0VsZW1lbnRTdGlsbEluQ2hhcnRbb2xkRWwuaWRdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXdFbCkge1xuICAgICAgLy8gVE9ETzogSWYga2VlcCBhbmltYXRpbmcgdGhlIGdyb3VwIGluIGNhc2VcbiAgICAgIC8vIHNvbWUgb2YgdGhlIGVsZW1lbnRzIGRvbid0IHdhbnQgdG8gYmUgbW9ycGhlZC5cbiAgICAgIC8vIFRPRE8gTGFiZWw/XG4gICAgICBzdG9wQW5pbWF0aW9uKG5ld0VsKTtcbiAgICAgIGlmIChvbGRFbCkge1xuICAgICAgICBzdG9wQW5pbWF0aW9uKG9sZEVsKTtcbiAgICAgICAgLy8gSWYgb2xkIGVsZW1lbnQgaXMgZG9pbmcgbGVhdmluZyBhbmltYXRpb24uIHN0b3AgaXQgYW5kIHJlbW92ZSBpdCBpbW1lZGlhdGVseS5cbiAgICAgICAgcmVtb3ZlRWwob2xkRWwpO1xuICAgICAgICBoYXNNb3JwaEFuaW1hdGlvbiA9IHRydWU7XG4gICAgICAgIGFwcGx5TW9ycGhBbmltYXRpb24oZ2V0UGF0aExpc3Qob2xkRWwpLCBnZXRQYXRoTGlzdChuZXdFbCksIG5ld0l0ZW0uZGl2aWRlLCBuZXdTZXJpZXMsIG5ld0luZGV4LCB1cGRhdGVNb3JwaGluZ1BhdGhQcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWRlSW5FbGVtZW50KG5ld0VsLCBuZXdTZXJpZXMsIG5ld0luZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZWxzZSBrZWVwIG9sZEVsIGxlYXZpbmcgYW5pbWF0aW9uLlxuICB9XG4gIG5ldyBEYXRhRGlmZmVyKG9sZERpZmZJdGVtcywgbmV3RGlmZkl0ZW1zLCBjcmVhdGVLZXlHZXR0ZXIodHJ1ZSwgdXNlSWQpLCBjcmVhdGVLZXlHZXR0ZXIoZmFsc2UsIHVzZUlkKSwgbnVsbCwgJ211bHRpcGxlJykudXBkYXRlKHVwZGF0ZU9uZVRvT25lKS51cGRhdGVNYW55VG9PbmUoZnVuY3Rpb24gKG5ld0luZGV4LCBvbGRJbmRpY2VzKSB7XG4gICAgdmFyIG5ld0l0ZW0gPSBuZXdEaWZmSXRlbXNbbmV3SW5kZXhdO1xuICAgIHZhciBuZXdEYXRhID0gbmV3SXRlbS5kYXRhO1xuICAgIHZhciBuZXdTZXJpZXMgPSBuZXdEYXRhLmhvc3RNb2RlbDtcbiAgICB2YXIgbmV3RWwgPSBuZXdEYXRhLmdldEl0ZW1HcmFwaGljRWwobmV3SXRlbS5kYXRhSW5kZXgpO1xuICAgIHZhciBvbGRFbHNMaXN0ID0gZmlsdGVyKG1hcChvbGRJbmRpY2VzLCBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICByZXR1cm4gb2xkRGlmZkl0ZW1zW2lkeF0uZGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZERpZmZJdGVtc1tpZHhdLmRhdGFJbmRleCk7XG4gICAgfSksIGZ1bmN0aW9uIChvbGRFbCkge1xuICAgICAgcmV0dXJuIG9sZEVsICYmIG9sZEVsICE9PSBuZXdFbCAmJiAhaXNFbGVtZW50U3RpbGxJbkNoYXJ0W29sZEVsLmlkXTtcbiAgICB9KTtcbiAgICBpZiAobmV3RWwpIHtcbiAgICAgIHN0b3BBbmltYXRpb24obmV3RWwpO1xuICAgICAgaWYgKG9sZEVsc0xpc3QubGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIG9sZCBlbGVtZW50IGlzIGRvaW5nIGxlYXZpbmcgYW5pbWF0aW9uLiBzdG9wIGl0IGFuZCByZW1vdmUgaXQgaW1tZWRpYXRlbHkuXG4gICAgICAgIGVhY2gob2xkRWxzTGlzdCwgZnVuY3Rpb24gKG9sZEVsKSB7XG4gICAgICAgICAgc3RvcEFuaW1hdGlvbihvbGRFbCk7XG4gICAgICAgICAgcmVtb3ZlRWwob2xkRWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgaGFzTW9ycGhBbmltYXRpb24gPSB0cnVlO1xuICAgICAgICBhcHBseU1vcnBoQW5pbWF0aW9uKGdldFBhdGhMaXN0KG9sZEVsc0xpc3QpLCBnZXRQYXRoTGlzdChuZXdFbCksIG5ld0l0ZW0uZGl2aWRlLCBuZXdTZXJpZXMsIG5ld0luZGV4LCB1cGRhdGVNb3JwaGluZ1BhdGhQcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWRlSW5FbGVtZW50KG5ld0VsLCBuZXdTZXJpZXMsIG5ld0l0ZW0uZGF0YUluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZWxzZSBrZWVwIG9sZEVsIGxlYXZpbmcgYW5pbWF0aW9uLlxuICB9KS51cGRhdGVPbmVUb01hbnkoZnVuY3Rpb24gKG5ld0luZGljZXMsIG9sZEluZGV4KSB7XG4gICAgdmFyIG9sZEl0ZW0gPSBvbGREaWZmSXRlbXNbb2xkSW5kZXhdO1xuICAgIHZhciBvbGRFbCA9IG9sZEl0ZW0uZGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZEl0ZW0uZGF0YUluZGV4KTtcbiAgICAvLyBXZSBjYW4ndCB1c2UgdGhlIGVsZW1lbnRzIHRoYXQgYWxyZWFkeSBiZWluZyBtb3JwaGVkXG4gICAgaWYgKG9sZEVsICYmIGlzRWxlbWVudFN0aWxsSW5DaGFydFtvbGRFbC5pZF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5ld0Vsc0xpc3QgPSBmaWx0ZXIobWFwKG5ld0luZGljZXMsIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHJldHVybiBuZXdEaWZmSXRlbXNbaWR4XS5kYXRhLmdldEl0ZW1HcmFwaGljRWwobmV3RGlmZkl0ZW1zW2lkeF0uZGF0YUluZGV4KTtcbiAgICB9KSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gZWwgJiYgZWwgIT09IG9sZEVsO1xuICAgIH0pO1xuICAgIHZhciBuZXdTZXJpcyA9IG5ld0RpZmZJdGVtc1tuZXdJbmRpY2VzWzBdXS5kYXRhLmhvc3RNb2RlbDtcbiAgICBpZiAobmV3RWxzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVhY2gobmV3RWxzTGlzdCwgZnVuY3Rpb24gKG5ld0VsKSB7XG4gICAgICAgIHJldHVybiBzdG9wQW5pbWF0aW9uKG5ld0VsKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG9sZEVsKSB7XG4gICAgICAgIHN0b3BBbmltYXRpb24ob2xkRWwpO1xuICAgICAgICAvLyBJZiBvbGQgZWxlbWVudCBpcyBkb2luZyBsZWF2aW5nIGFuaW1hdGlvbi4gc3RvcCBpdCBhbmQgcmVtb3ZlIGl0IGltbWVkaWF0ZWx5LlxuICAgICAgICByZW1vdmVFbChvbGRFbCk7XG4gICAgICAgIGhhc01vcnBoQW5pbWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgYXBwbHlNb3JwaEFuaW1hdGlvbihnZXRQYXRoTGlzdChvbGRFbCksIGdldFBhdGhMaXN0KG5ld0Vsc0xpc3QpLCBvbGRJdGVtLmRpdmlkZSxcbiAgICAgICAgLy8gVXNlIGRpdmlkZSBvbiBvbGQuXG4gICAgICAgIG5ld1NlcmlzLCBuZXdJbmRpY2VzWzBdLCB1cGRhdGVNb3JwaGluZ1BhdGhQcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYWNoKG5ld0Vsc0xpc3QsIGZ1bmN0aW9uIChuZXdFbCkge1xuICAgICAgICAgIHJldHVybiBmYWRlSW5FbGVtZW50KG5ld0VsLCBuZXdTZXJpcywgbmV3SW5kaWNlc1swXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBlbHNlIGtlZXAgb2xkRWwgbGVhdmluZyBhbmltYXRpb24uXG4gIH0pLnVwZGF0ZU1hbnlUb01hbnkoZnVuY3Rpb24gKG5ld0luZGljZXMsIG9sZEluZGljZXMpIHtcbiAgICAvLyBJZiB0d28gZGF0YSBhcmUgc2FtZSBhbmQgYm90aCBoYXZlIGdyb3VwSWQuXG4gICAgLy8gTm9ybWFsbHkgdGhleSBzaG91bGQgYmUgZGlmZiBieSBpZC5cbiAgICBuZXcgRGF0YURpZmZlcihvbGRJbmRpY2VzLCBuZXdJbmRpY2VzLCBmdW5jdGlvbiAocmF3SWR4KSB7XG4gICAgICByZXR1cm4gb2xkRGlmZkl0ZW1zW3Jhd0lkeF0uZGF0YS5nZXRJZChvbGREaWZmSXRlbXNbcmF3SWR4XS5kYXRhSW5kZXgpO1xuICAgIH0sIGZ1bmN0aW9uIChyYXdJZHgpIHtcbiAgICAgIHJldHVybiBuZXdEaWZmSXRlbXNbcmF3SWR4XS5kYXRhLmdldElkKG5ld0RpZmZJdGVtc1tyYXdJZHhdLmRhdGFJbmRleCk7XG4gICAgfSkudXBkYXRlKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgICAgIC8vIFVzZSB0aGUgb3JpZ2luYWwgaW5kZXhcbiAgICAgIHVwZGF0ZU9uZVRvT25lKG5ld0luZGljZXNbbmV3SW5kZXhdLCBvbGRJbmRpY2VzW29sZEluZGV4XSk7XG4gICAgfSkuZXhlY3V0ZSgpO1xuICB9KS5leGVjdXRlKCk7XG4gIGlmIChoYXNNb3JwaEFuaW1hdGlvbikge1xuICAgIGVhY2gobmV3TGlzdCwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgZGF0YSA9IF9hLmRhdGE7XG4gICAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICAgIHZhciB2aWV3ID0gc2VyaWVzTW9kZWwgJiYgYXBpLmdldFZpZXdPZlNlcmllc01vZGVsKHNlcmllc01vZGVsKTtcbiAgICAgIHZhciBhbmltYXRpb25DZmcgPSBnZXRBbmltYXRpb25Db25maWcoJ3VwZGF0ZScsIHNlcmllc01vZGVsLCAwKTsgLy8gdXNlIDAgaW5kZXguXG4gICAgICBpZiAodmlldyAmJiBzZXJpZXNNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKSAmJiBhbmltYXRpb25DZmcgJiYgYW5pbWF0aW9uQ2ZnLmR1cmF0aW9uID4gMCkge1xuICAgICAgICB2aWV3Lmdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIFBhdGggJiYgIWVsLmFuaW1hdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IGFjY2VwdCB0aGVyZSBzdGlsbCBleGlzdHMgZWxlbWVudCB0aGF0IGhhcyBubyBhbmltYXRpb25cbiAgICAgICAgICAgIC8vIGlmIHVuaXZlcnNhbFRyYW5zaXRpb24gaXMgZW5hYmxlZFxuICAgICAgICAgICAgZWwuYW5pbWF0ZUZyb20oe1xuICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgYW5pbWF0aW9uQ2ZnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTZXJpZXNUcmFuc2l0aW9uS2V5KHNlcmllcykge1xuICB2YXIgc2VyaWVzS2V5ID0gc2VyaWVzLmdldE1vZGVsKCd1bml2ZXJzYWxUcmFuc2l0aW9uJykuZ2V0KCdzZXJpZXNLZXknKTtcbiAgaWYgKCFzZXJpZXNLZXkpIHtcbiAgICAvLyBVc2Ugc2VyaWVzIGlkIGJ5IGRlZmF1bHQuXG4gICAgcmV0dXJuIHNlcmllcy5pZDtcbiAgfVxuICByZXR1cm4gc2VyaWVzS2V5O1xufVxuZnVuY3Rpb24gY29udmVydEFycmF5U2VyaWVzS2V5VG9TdHJpbmcoc2VyaWVzS2V5KSB7XG4gIGlmIChpc0FycmF5KHNlcmllc0tleSkpIHtcbiAgICAvLyBPcmRlciBpbmRlcGVuZGVudC5cbiAgICByZXR1cm4gc2VyaWVzS2V5LnNvcnQoKS5qb2luKCcsJyk7XG4gIH1cbiAgcmV0dXJuIHNlcmllc0tleTtcbn1cbmZ1bmN0aW9uIGdldERpdmlkZVNoYXBlRnJvbURhdGEoZGF0YSkge1xuICBpZiAoZGF0YS5ob3N0TW9kZWwpIHtcbiAgICByZXR1cm4gZGF0YS5ob3N0TW9kZWwuZ2V0TW9kZWwoJ3VuaXZlcnNhbFRyYW5zaXRpb24nKS5nZXQoJ2RpdmlkZVNoYXBlJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRUcmFuc2l0aW9uU2VyaWVzQmF0Y2hlcyhnbG9iYWxTdG9yZSwgcGFyYW1zKSB7XG4gIHZhciB1cGRhdGVCYXRjaGVzID0gY3JlYXRlSGFzaE1hcCgpO1xuICB2YXIgb2xkRGF0YU1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgLy8gTWFwIHRoYXQgb25seSBzdG9yZSBrZXkgaW4gYXJyYXkgc2VyaWVzS2V5LlxuICAvLyBXaGljaCBpcyB1c2VkIHRvIHF1ZXJ5IHRoZSBvbGQgZGF0YSB3aGVuIHRyYW5zaXRpb24gZnJvbSBvbmUgdG8gbXVsdGlwbGUgc2VyaWVzLlxuICB2YXIgb2xkRGF0YU1hcEZvclNwbGl0ID0gY3JlYXRlSGFzaE1hcCgpO1xuICBlYWNoKGdsb2JhbFN0b3JlLm9sZFNlcmllcywgZnVuY3Rpb24gKHNlcmllcywgaWR4KSB7XG4gICAgdmFyIG9sZERhdGFHcm91cElkID0gZ2xvYmFsU3RvcmUub2xkRGF0YUdyb3VwSWRzW2lkeF07XG4gICAgdmFyIG9sZERhdGEgPSBnbG9iYWxTdG9yZS5vbGREYXRhW2lkeF07XG4gICAgdmFyIHRyYW5zaXRpb25LZXkgPSBnZXRTZXJpZXNUcmFuc2l0aW9uS2V5KHNlcmllcyk7XG4gICAgdmFyIHRyYW5zaXRpb25LZXlTdHIgPSBjb252ZXJ0QXJyYXlTZXJpZXNLZXlUb1N0cmluZyh0cmFuc2l0aW9uS2V5KTtcbiAgICBvbGREYXRhTWFwLnNldCh0cmFuc2l0aW9uS2V5U3RyLCB7XG4gICAgICBkYXRhR3JvdXBJZDogb2xkRGF0YUdyb3VwSWQsXG4gICAgICBkYXRhOiBvbGREYXRhXG4gICAgfSk7XG4gICAgaWYgKGlzQXJyYXkodHJhbnNpdGlvbktleSkpIHtcbiAgICAgIC8vIFNhbWUga2V5IGNhbid0IGluIGRpZmZlcmVudCBhcnJheSBzZXJpZXNLZXkuXG4gICAgICBlYWNoKHRyYW5zaXRpb25LZXksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgb2xkRGF0YU1hcEZvclNwbGl0LnNldChrZXksIHtcbiAgICAgICAgICBrZXk6IHRyYW5zaXRpb25LZXlTdHIsXG4gICAgICAgICAgZGF0YUdyb3VwSWQ6IG9sZERhdGFHcm91cElkLFxuICAgICAgICAgIGRhdGE6IG9sZERhdGFcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBjaGVja1RyYW5zaXRpb25TZXJpZXNLZXlEdXBsaWNhdGVkKHRyYW5zaXRpb25LZXlTdHIpIHtcbiAgICBpZiAodXBkYXRlQmF0Y2hlcy5nZXQodHJhbnNpdGlvbktleVN0cikpIHtcbiAgICAgIHdhcm4oXCJEdXBsaWNhdGVkIHNlcmllc0tleSBpbiB1bml2ZXJzYWxUcmFuc2l0aW9uIFwiICsgdHJhbnNpdGlvbktleVN0cik7XG4gICAgfVxuICB9XG4gIGVhY2gocGFyYW1zLnVwZGF0ZWRTZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICBpZiAoc2VyaWVzLmlzVW5pdmVyc2FsVHJhbnNpdGlvbkVuYWJsZWQoKSAmJiBzZXJpZXMuaXNBbmltYXRpb25FbmFibGVkKCkpIHtcbiAgICAgIHZhciBuZXdEYXRhR3JvdXBJZCA9IHNlcmllcy5nZXQoJ2RhdGFHcm91cElkJyk7XG4gICAgICB2YXIgbmV3RGF0YSA9IHNlcmllcy5nZXREYXRhKCk7XG4gICAgICB2YXIgdHJhbnNpdGlvbktleSA9IGdldFNlcmllc1RyYW5zaXRpb25LZXkoc2VyaWVzKTtcbiAgICAgIHZhciB0cmFuc2l0aW9uS2V5U3RyID0gY29udmVydEFycmF5U2VyaWVzS2V5VG9TdHJpbmcodHJhbnNpdGlvbktleSk7XG4gICAgICAvLyBPbmx5IHRyYW5zaXRpb24gYmV0d2VlbiBzZXJpZXMgd2l0aCBzYW1lIGlkLlxuICAgICAgdmFyIG9sZERhdGEgPSBvbGREYXRhTWFwLmdldCh0cmFuc2l0aW9uS2V5U3RyKTtcbiAgICAgIC8vIHN0cmluZyB0cmFuc2l0aW9uIGtleSBpcyB0aGUgYmVzdCBtYXRjaC5cbiAgICAgIGlmIChvbGREYXRhKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tUcmFuc2l0aW9uU2VyaWVzS2V5RHVwbGljYXRlZCh0cmFuc2l0aW9uS2V5U3RyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIGNoZWNrIGlmIGRhdGEgaXMgc2FtZT9cbiAgICAgICAgdXBkYXRlQmF0Y2hlcy5zZXQodHJhbnNpdGlvbktleVN0ciwge1xuICAgICAgICAgIG9sZFNlcmllczogW3tcbiAgICAgICAgICAgIGRhdGFHcm91cElkOiBvbGREYXRhLmRhdGFHcm91cElkLFxuICAgICAgICAgICAgZGl2aWRlOiBnZXREaXZpZGVTaGFwZUZyb21EYXRhKG9sZERhdGEuZGF0YSksXG4gICAgICAgICAgICBkYXRhOiBvbGREYXRhLmRhdGFcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBuZXdTZXJpZXM6IFt7XG4gICAgICAgICAgICBkYXRhR3JvdXBJZDogbmV3RGF0YUdyb3VwSWQsXG4gICAgICAgICAgICBkaXZpZGU6IGdldERpdmlkZVNoYXBlRnJvbURhdGEobmV3RGF0YSksXG4gICAgICAgICAgICBkYXRhOiBuZXdEYXRhXG4gICAgICAgICAgfV1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIGZyb20gbXVsdGlwbGUgc2VyaWVzLlxuICAgICAgICAvLyBlLmcuICdmZW1hbGUnLCAnbWFsZScgLT4gWydmZW1hbGUnLCAnbWFsZSddXG4gICAgICAgIGlmIChpc0FycmF5KHRyYW5zaXRpb25LZXkpKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNoZWNrVHJhbnNpdGlvblNlcmllc0tleUR1cGxpY2F0ZWQodHJhbnNpdGlvbktleVN0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvbGRTZXJpZXNfMSA9IFtdO1xuICAgICAgICAgIGVhY2godHJhbnNpdGlvbktleSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIG9sZERhdGEgPSBvbGREYXRhTWFwLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKG9sZERhdGEuZGF0YSkge1xuICAgICAgICAgICAgICBvbGRTZXJpZXNfMS5wdXNoKHtcbiAgICAgICAgICAgICAgICBkYXRhR3JvdXBJZDogb2xkRGF0YS5kYXRhR3JvdXBJZCxcbiAgICAgICAgICAgICAgICBkaXZpZGU6IGdldERpdmlkZVNoYXBlRnJvbURhdGEob2xkRGF0YS5kYXRhKSxcbiAgICAgICAgICAgICAgICBkYXRhOiBvbGREYXRhLmRhdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG9sZFNlcmllc18xLmxlbmd0aCkge1xuICAgICAgICAgICAgdXBkYXRlQmF0Y2hlcy5zZXQodHJhbnNpdGlvbktleVN0ciwge1xuICAgICAgICAgICAgICBvbGRTZXJpZXM6IG9sZFNlcmllc18xLFxuICAgICAgICAgICAgICBuZXdTZXJpZXM6IFt7XG4gICAgICAgICAgICAgICAgZGF0YUdyb3VwSWQ6IG5ld0RhdGFHcm91cElkLFxuICAgICAgICAgICAgICAgIGRhdGE6IG5ld0RhdGEsXG4gICAgICAgICAgICAgICAgZGl2aWRlOiBnZXREaXZpZGVTaGFwZUZyb21EYXRhKG5ld0RhdGEpXG4gICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVHJ5IHRyYW5zaXRpb24gdG8gbXVsdGlwbGUgc2VyaWVzLlxuICAgICAgICAgIC8vIGUuZy4gWydmZW1hbGUnLCAnbWFsZSddIC0+ICdmZW1hbGUnLCAnbWFsZSdcbiAgICAgICAgICB2YXIgb2xkRGF0YV8xID0gb2xkRGF0YU1hcEZvclNwbGl0LmdldCh0cmFuc2l0aW9uS2V5KTtcbiAgICAgICAgICBpZiAob2xkRGF0YV8xKSB7XG4gICAgICAgICAgICB2YXIgYmF0Y2ggPSB1cGRhdGVCYXRjaGVzLmdldChvbGREYXRhXzEua2V5KTtcbiAgICAgICAgICAgIGlmICghYmF0Y2gpIHtcbiAgICAgICAgICAgICAgYmF0Y2ggPSB7XG4gICAgICAgICAgICAgICAgb2xkU2VyaWVzOiBbe1xuICAgICAgICAgICAgICAgICAgZGF0YUdyb3VwSWQ6IG9sZERhdGFfMS5kYXRhR3JvdXBJZCxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IG9sZERhdGFfMS5kYXRhLFxuICAgICAgICAgICAgICAgICAgZGl2aWRlOiBnZXREaXZpZGVTaGFwZUZyb21EYXRhKG9sZERhdGFfMS5kYXRhKVxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIG5ld1NlcmllczogW11cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdXBkYXRlQmF0Y2hlcy5zZXQob2xkRGF0YV8xLmtleSwgYmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmF0Y2gubmV3U2VyaWVzLnB1c2goe1xuICAgICAgICAgICAgICBkYXRhR3JvdXBJZDogbmV3RGF0YUdyb3VwSWQsXG4gICAgICAgICAgICAgIGRhdGE6IG5ld0RhdGEsXG4gICAgICAgICAgICAgIGRpdmlkZTogZ2V0RGl2aWRlU2hhcGVGcm9tRGF0YShuZXdEYXRhKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHVwZGF0ZUJhdGNoZXM7XG59XG5mdW5jdGlvbiBxdWVyeVNlcmllcyhzZXJpZXMsIGZpbmRlcikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmb3VuZCA9IGZpbmRlci5zZXJpZXNJbmRleCAhPSBudWxsICYmIGZpbmRlci5zZXJpZXNJbmRleCA9PT0gc2VyaWVzW2ldLnNlcmllc0luZGV4IHx8IGZpbmRlci5zZXJpZXNJZCAhPSBudWxsICYmIGZpbmRlci5zZXJpZXNJZCA9PT0gc2VyaWVzW2ldLmlkO1xuICAgIGlmIChmb3VuZCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uU2VyaWVzRnJvbU9wdCh0cmFuc2l0aW9uT3B0LCBnbG9iYWxTdG9yZSwgcGFyYW1zLCBhcGkpIHtcbiAgdmFyIGZyb20gPSBbXTtcbiAgdmFyIHRvID0gW107XG4gIGVhY2gobm9ybWFsaXplVG9BcnJheSh0cmFuc2l0aW9uT3B0LmZyb20pLCBmdW5jdGlvbiAoZmluZGVyKSB7XG4gICAgdmFyIGlkeCA9IHF1ZXJ5U2VyaWVzKGdsb2JhbFN0b3JlLm9sZFNlcmllcywgZmluZGVyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGZyb20ucHVzaCh7XG4gICAgICAgIGRhdGFHcm91cElkOiBnbG9iYWxTdG9yZS5vbGREYXRhR3JvdXBJZHNbaWR4XSxcbiAgICAgICAgZGF0YTogZ2xvYmFsU3RvcmUub2xkRGF0YVtpZHhdLFxuICAgICAgICAvLyBUT0RPIGNhbiBzcGVjaWZ5IGRpdmlkZVNoYXBlIGluIHRyYW5zaXRpb24uXG4gICAgICAgIGRpdmlkZTogZ2V0RGl2aWRlU2hhcGVGcm9tRGF0YShnbG9iYWxTdG9yZS5vbGREYXRhW2lkeF0pLFxuICAgICAgICBncm91cElkRGltOiBmaW5kZXIuZGltZW5zaW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBlYWNoKG5vcm1hbGl6ZVRvQXJyYXkodHJhbnNpdGlvbk9wdC50byksIGZ1bmN0aW9uIChmaW5kZXIpIHtcbiAgICB2YXIgaWR4ID0gcXVlcnlTZXJpZXMocGFyYW1zLnVwZGF0ZWRTZXJpZXMsIGZpbmRlcik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB2YXIgZGF0YSA9IHBhcmFtcy51cGRhdGVkU2VyaWVzW2lkeF0uZ2V0RGF0YSgpO1xuICAgICAgdG8ucHVzaCh7XG4gICAgICAgIGRhdGFHcm91cElkOiBnbG9iYWxTdG9yZS5vbGREYXRhR3JvdXBJZHNbaWR4XSxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgZGl2aWRlOiBnZXREaXZpZGVTaGFwZUZyb21EYXRhKGRhdGEpLFxuICAgICAgICBncm91cElkRGltOiBmaW5kZXIuZGltZW5zaW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoZnJvbS5sZW5ndGggPiAwICYmIHRvLmxlbmd0aCA+IDApIHtcbiAgICB0cmFuc2l0aW9uQmV0d2Vlbihmcm9tLCB0bywgYXBpKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGxVbml2ZXJzYWxUcmFuc2l0aW9uKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJVcGRhdGVMaWZlY3ljbGUoJ3NlcmllczpiZWZvcmV1cGRhdGUnLCBmdW5jdGlvbiAoZWNNT2RlbCwgYXBpLCBwYXJhbXMpIHtcbiAgICBlYWNoKG5vcm1hbGl6ZVRvQXJyYXkocGFyYW1zLnNlcmllc1RyYW5zaXRpb24pLCBmdW5jdGlvbiAodHJhbnNPcHQpIHtcbiAgICAgIGVhY2gobm9ybWFsaXplVG9BcnJheSh0cmFuc09wdC50byksIGZ1bmN0aW9uIChmaW5kZXIpIHtcbiAgICAgICAgdmFyIHNlcmllcyA9IHBhcmFtcy51cGRhdGVkU2VyaWVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChmaW5kZXIuc2VyaWVzSW5kZXggIT0gbnVsbCAmJiBmaW5kZXIuc2VyaWVzSW5kZXggPT09IHNlcmllc1tpXS5zZXJpZXNJbmRleCB8fCBmaW5kZXIuc2VyaWVzSWQgIT0gbnVsbCAmJiBmaW5kZXIuc2VyaWVzSWQgPT09IHNlcmllc1tpXS5pZCkge1xuICAgICAgICAgICAgc2VyaWVzW2ldW1NFUklFU19VTklWRVJTQUxfVFJBTlNJVElPTl9QUk9QXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclVwZGF0ZUxpZmVjeWNsZSgnc2VyaWVzOnRyYW5zaXRpb24nLCBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpLCBwYXJhbXMpIHtcbiAgICAvLyBUT0RPIGFwaSBwcm92aWRlIGFuIG5hbWVzcGFjZSB0aGF0IGNhbiBzYXZlIHN0dWZmIHBlciBpbnN0YW5jZVxuICAgIHZhciBnbG9iYWxTdG9yZSA9IGdldFVuaXZlcnNhbFRyYW5zaXRpb25HbG9iYWxTdG9yZShhcGkpO1xuICAgIC8vIFRPRE8gbXVsdGlwbGUgdG8gbXVsdGlwbGUgc2VyaWVzLlxuICAgIGlmIChnbG9iYWxTdG9yZS5vbGRTZXJpZXMgJiYgcGFyYW1zLnVwZGF0ZWRTZXJpZXMgJiYgcGFyYW1zLm9wdGlvbkNoYW5nZWQpIHtcbiAgICAgIC8vIFRPRE8gdHJhbnNpdGlvbk9wdCB3YXMgdXNlZCBpbiBhbiBvbGQgaW1wbGVtZW50YXRpb24gYW5kIGNhbiBiZSByZW1vdmVkIG5vd1xuICAgICAgLy8gVXNlIGdpdmUgdHJhbnNpdGlvbiBjb25maWcgaWYgaXRzJyBnaXZlO1xuICAgICAgdmFyIHRyYW5zaXRpb25PcHQgPSBwYXJhbXMuc2VyaWVzVHJhbnNpdGlvbjtcbiAgICAgIGlmICh0cmFuc2l0aW9uT3B0KSB7XG4gICAgICAgIGVhY2gobm9ybWFsaXplVG9BcnJheSh0cmFuc2l0aW9uT3B0KSwgZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgIHRyYW5zaXRpb25TZXJpZXNGcm9tT3B0KG9wdCwgZ2xvYmFsU3RvcmUsIHBhcmFtcywgYXBpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbHNlIGd1ZXNzIGZyb20gc2VyaWVzIGJhc2VkIG9uIHRyYW5zaXRpb24gc2VyaWVzIGtleS5cbiAgICAgICAgdmFyIHVwZGF0ZUJhdGNoZXNfMSA9IGZpbmRUcmFuc2l0aW9uU2VyaWVzQmF0Y2hlcyhnbG9iYWxTdG9yZSwgcGFyYW1zKTtcbiAgICAgICAgZWFjaCh1cGRhdGVCYXRjaGVzXzEua2V5cygpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgdmFyIGJhdGNoID0gdXBkYXRlQmF0Y2hlc18xLmdldChrZXkpO1xuICAgICAgICAgIHRyYW5zaXRpb25CZXR3ZWVuKGJhdGNoLm9sZFNlcmllcywgYmF0Y2gubmV3U2VyaWVzLCBhcGkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIFJlc2V0XG4gICAgICBlYWNoKHBhcmFtcy51cGRhdGVkU2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgIC8vIFJlc2V0O1xuICAgICAgICBpZiAoc2VyaWVzW1NFUklFU19VTklWRVJTQUxfVFJBTlNJVElPTl9QUk9QXSkge1xuICAgICAgICAgIHNlcmllc1tTRVJJRVNfVU5JVkVSU0FMX1RSQU5TSVRJT05fUFJPUF0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFNhdmUgYWxsIHNlcmllcyBvZiBjdXJyZW50IHVwZGF0ZS4gTm90IG9ubHkgdGhlIHVwZGF0ZWQgb25lLlxuICAgIHZhciBhbGxTZXJpZXMgPSBlY01vZGVsLmdldFNlcmllcygpO1xuICAgIHZhciBzYXZlZFNlcmllcyA9IGdsb2JhbFN0b3JlLm9sZFNlcmllcyA9IFtdO1xuICAgIHZhciBzYXZlZERhdGFHcm91cElkcyA9IGdsb2JhbFN0b3JlLm9sZERhdGFHcm91cElkcyA9IFtdO1xuICAgIHZhciBzYXZlZERhdGEgPSBnbG9iYWxTdG9yZS5vbGREYXRhID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxTZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkYXRhID0gYWxsU2VyaWVzW2ldLmdldERhdGEoKTtcbiAgICAgIC8vIE9ubHkgc2F2ZSB0aGUgZGF0YSB0aGF0IGNhbiBoYXZlIHRyYW5zaXRpb24uXG4gICAgICAvLyBBdm9pZCBsYXJnZSBkYXRhIGNvc3RpbmcgdG9vIG11Y2ggZXh0cmEgbWVtb3J5XG4gICAgICBpZiAoZGF0YS5jb3VudCgpIDwgREFUQV9DT1VOVF9USFJFU0hPTEQpIHtcbiAgICAgICAgc2F2ZWRTZXJpZXMucHVzaChhbGxTZXJpZXNbaV0pO1xuICAgICAgICBzYXZlZERhdGFHcm91cElkcy5wdXNoKGFsbFNlcmllc1tpXS5nZXQoJ2RhdGFHcm91cElkJykpO1xuICAgICAgICBzYXZlZERhdGEucHVzaChkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgdXNlIH0gZnJvbSAnLi9saWIvZXh0ZW5zaW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL2V4cG9ydC9jb3JlLmpzJztcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEFsbCBvZiB0aGUgbW9kdWxlcyB0aGF0IGFyZSBhbGxvd2VkIHRvIGJlXG4vLyBpbXBvcnRlZCBhcmUgbGlzdGVkIGJlbG93LlxuLy9cbi8vIFVzZXJzIE1VU1QgTk9UIGltcG9ydCBvdGhlciBtb2R1bGVzIHRoYXQgYXJlXG4vLyBub3QgaW5jbHVkZWQgaW4gdGhpcyBsaXN0LlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuaW1wb3J0IHsgU1ZHUmVuZGVyZXIsIENhbnZhc1JlbmRlcmVyIH0gZnJvbSAnLi9saWIvZXhwb3J0L3JlbmRlcmVycy5qcyc7XG5pbXBvcnQgeyBMaW5lQ2hhcnQsIEJhckNoYXJ0LCBQaWVDaGFydCwgU2NhdHRlckNoYXJ0LCBSYWRhckNoYXJ0LCBNYXBDaGFydCwgVHJlZUNoYXJ0LCBUcmVlbWFwQ2hhcnQsIEdyYXBoQ2hhcnQsIEdhdWdlQ2hhcnQsIEZ1bm5lbENoYXJ0LCBQYXJhbGxlbENoYXJ0LCBTYW5rZXlDaGFydCwgQm94cGxvdENoYXJ0LCBDYW5kbGVzdGlja0NoYXJ0LCBFZmZlY3RTY2F0dGVyQ2hhcnQsIExpbmVzQ2hhcnQsIEhlYXRtYXBDaGFydCwgUGljdG9yaWFsQmFyQ2hhcnQsIFRoZW1lUml2ZXJDaGFydCwgU3VuYnVyc3RDaGFydCwgQ3VzdG9tQ2hhcnQgfSBmcm9tICcuL2xpYi9leHBvcnQvY2hhcnRzLmpzJztcbmltcG9ydCB7IEdyaWRDb21wb25lbnQsIFBvbGFyQ29tcG9uZW50LCBHZW9Db21wb25lbnQsIFNpbmdsZUF4aXNDb21wb25lbnQsIFBhcmFsbGVsQ29tcG9uZW50LCBDYWxlbmRhckNvbXBvbmVudCwgR3JhcGhpY0NvbXBvbmVudCwgVG9vbGJveENvbXBvbmVudCwgVG9vbHRpcENvbXBvbmVudCwgQXhpc1BvaW50ZXJDb21wb25lbnQsIEJydXNoQ29tcG9uZW50LCBUaXRsZUNvbXBvbmVudCwgVGltZWxpbmVDb21wb25lbnQsIE1hcmtQb2ludENvbXBvbmVudCwgTWFya0xpbmVDb21wb25lbnQsIE1hcmtBcmVhQ29tcG9uZW50LCBMZWdlbmRDb21wb25lbnQsIERhdGFab29tQ29tcG9uZW50LCBEYXRhWm9vbUluc2lkZUNvbXBvbmVudCwgRGF0YVpvb21TbGlkZXJDb21wb25lbnQsIFZpc3VhbE1hcENvbXBvbmVudCwgVmlzdWFsTWFwQ29udGludW91c0NvbXBvbmVudCwgVmlzdWFsTWFwUGllY2V3aXNlQ29tcG9uZW50LCBBcmlhQ29tcG9uZW50LCBEYXRhc2V0Q29tcG9uZW50LCBUcmFuc2Zvcm1Db21wb25lbnQgfSBmcm9tICcuL2xpYi9leHBvcnQvY29tcG9uZW50cy5qcyc7XG5pbXBvcnQgeyBVbml2ZXJzYWxUcmFuc2l0aW9uLCBMYWJlbExheW91dCB9IGZyb20gJy4vbGliL2V4cG9ydC9mZWF0dXJlcy5qcyc7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVuZGVyIGVuZ2luZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZW5kZXIgdmlhIENhbnZhcy5cbi8vIGVjaGFydHMuaW5pdChkb20sIG51bGwsIHsgcmVuZGVyZXI6ICdjYW52YXMnIH0pXG51c2UoW0NhbnZhc1JlbmRlcmVyXSk7XG4vLyBSZW5kZXIgdmlhIFNWRy5cbi8vIGVjaGFydHMuaW5pdChkb20sIG51bGwsIHsgcmVuZGVyZXI6ICdzdmcnIH0pXG51c2UoW1NWR1JlbmRlcmVyXSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tXG4vLyBDaGFydHMgKHNlcmllcylcbi8vIC0tLS0tLS0tLS0tLS0tLS1cbi8vIEFsbCBvZiB0aGUgc2VyaWVzIHR5cGVzLCBmb3IgZXhhbXBsZTpcbi8vIGNoYXJ0LnNldE9wdGlvbih7XG4vLyAgICAgc2VyaWVzOiBbe1xuLy8gICAgICAgICB0eXBlOiAnbGluZScgLy8gb3IgJ2JhcicsICdwaWUnLCAuLi5cbi8vICAgICB9XVxuLy8gfSk7XG51c2UoW0xpbmVDaGFydCwgQmFyQ2hhcnQsIFBpZUNoYXJ0LCBTY2F0dGVyQ2hhcnQsIFJhZGFyQ2hhcnQsIE1hcENoYXJ0LCBUcmVlQ2hhcnQsIFRyZWVtYXBDaGFydCwgR3JhcGhDaGFydCwgR2F1Z2VDaGFydCwgRnVubmVsQ2hhcnQsIFBhcmFsbGVsQ2hhcnQsIFNhbmtleUNoYXJ0LCBCb3hwbG90Q2hhcnQsIENhbmRsZXN0aWNrQ2hhcnQsIEVmZmVjdFNjYXR0ZXJDaGFydCwgTGluZXNDaGFydCwgSGVhdG1hcENoYXJ0LCBQaWN0b3JpYWxCYXJDaGFydCwgVGhlbWVSaXZlckNoYXJ0LCBTdW5idXJzdENoYXJ0LCBDdXN0b21DaGFydF0pO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ29vcmRpbmF0ZSBzeXN0ZW1zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBbGwgb2YgdGhlIGF4aXMgbW9kdWxlcyBoYXZlIGJlZW4gaW5jbHVkZWQgaW4gdGhlXG4vLyBjb29yZGluYXRlIHN5c3RlbSBtb2R1bGUgYmVsb3csIGRvIG5vdCBuZWVkIHRvXG4vLyBtYWtlIGV4dHJhIGltcG9ydC5cbi8vIGBjYXJ0ZXNpYW5gIGNvb3JkaW5hdGUgc3lzdGVtLiBGb3Igc29tZSBoaXN0b3JpY2FsXG4vLyByZWFzb25zLCBpdCBpcyBuYW1lZCBhcyBncmlkLCBmb3IgZXhhbXBsZTpcbi8vIGNoYXJ0LnNldE9wdGlvbih7XG4vLyAgICAgZ3JpZDogey4uLn0sXG4vLyAgICAgeEF4aXM6IHsuLi59LFxuLy8gICAgIHlBeGlzOiB7Li4ufSxcbi8vICAgICBzZXJpZXM6IFt7Li4ufV1cbi8vIH0pO1xudXNlKEdyaWRDb21wb25lbnQpO1xuLy8gYHBvbGFyYCBjb29yZGluYXRlIHN5c3RlbSwgZm9yIGV4YW1wbGU6XG4vLyBjaGFydC5zZXRPcHRpb24oe1xuLy8gICAgIHBvbGFyOiB7Li4ufSxcbi8vICAgICByYWRpdXNBeGlzOiB7Li4ufSxcbi8vICAgICBhbmdsZUF4aXM6IHsuLi59LFxuLy8gICAgIHNlcmllczogW3tcbi8vICAgICAgICAgY29vcmRpbmF0ZVN5c3RlbTogJ3BvbGFyJ1xuLy8gICAgIH1dXG4vLyB9KTtcbnVzZShQb2xhckNvbXBvbmVudCk7XG4vLyBgZ2VvYCBjb29yZGluYXRlIHN5c3RlbSwgZm9yIGV4YW1wbGU6XG4vLyBjaGFydC5zZXRPcHRpb24oe1xuLy8gICAgIGdlbzogey4uLn0sXG4vLyAgICAgc2VyaWVzOiBbe1xuLy8gICAgICAgICBjb29yZGluYXRlU3lzdGVtOiAnZ2VvJ1xuLy8gICAgIH1dXG4vLyB9KTtcbnVzZShHZW9Db21wb25lbnQpO1xuLy8gYHNpbmdsZUF4aXNgIGNvb3JkaW5hdGUgc3lzdGVtIChub3RpY2UsIGl0IGlzIGEgY29vcmRpbmF0ZSBzeXN0ZW1cbi8vIHdpdGggb25seSBvbmUgYXhpcywgd29yayBmb3IgY2hhcnQgbGlrZSB0aGVtZSByaXZlciksIGZvciBleGFtcGxlOlxuLy8gY2hhcnQuc2V0T3B0aW9uKHtcbi8vICAgICBzaW5nbGVBeGlzOiB7Li4ufVxuLy8gICAgIHNlcmllczogW3t0eXBlOiAndGhlbWVSaXZlcicsIC4uLn1dXG4vLyB9KTtcbnVzZShTaW5nbGVBeGlzQ29tcG9uZW50KTtcbi8vIGBwYXJhbGxlbGAgY29vcmRpbmF0ZSBzeXN0ZW0sIG9ubHkgd29yayBmb3IgcGFyYWxsZWwgc2VyaWVzLCBmb3IgZXhhbXBsZTpcbi8vIGNoYXJ0LnNldE9wdGlvbih7XG4vLyAgICAgcGFyYWxsZWw6IHsuLi59LFxuLy8gICAgIHBhcmFsbGVsQXhpczogW3suLi59LCAuLi5dLFxuLy8gICAgIHNlcmllczogW3tcbi8vICAgICAgICAgdHlwZTogJ3BhcmFsbGVsJ1xuLy8gICAgIH1dXG4vLyB9KTtcbnVzZShQYXJhbGxlbENvbXBvbmVudCk7XG4vLyBgY2FsZW5kYXJgIGNvb3JkaW5hdGUgc3lzdGVtLiBmb3IgZXhhbXBsZSxcbi8vIGNoYXJ0LnNldE9wdGlvbih7XG4vLyAgICAgY2FsZW5kYXI6IHsuLi59LFxuLy8gICAgIHNlcmllczogW3tcbi8vICAgICAgICAgY29vcmRpbmF0ZVN5c3RlbTogJ2NhbGVuZGFyJ1xuLy8gICAgIH1dXG4vLyApO1xudXNlKENhbGVuZGFyQ29tcG9uZW50KTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3RoZXIgY29tcG9uZW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBgZ3JhcGhpY2AgY29tcG9uZW50LCBmb3IgZXhhbXBsZTpcbi8vIGNoYXJ0LnNldE9wdGlvbih7XG4vLyAgICAgZ3JhcGhpYzogey4uLn1cbi8vIH0pO1xudXNlKEdyYXBoaWNDb21wb25lbnQpO1xuLy8gYHRvb2xib3hgIGNvbXBvbmVudCwgZm9yIGV4YW1wbGU6XG4vLyBjaGFydC5zZXRPcHRpb24oe1xuLy8gICAgIHRvb2xib3g6IHsuLi59XG4vLyB9KTtcbnVzZShUb29sYm94Q29tcG9uZW50KTtcbi8vIGB0b29sdGlwYCBjb21wb25lbnQsIGZvciBleGFtcGxlOlxuLy8gY2hhcnQuc2V0T3B0aW9uKHtcbi8vICAgICB0b29sdGlwOiB7Li4ufVxuLy8gfSk7XG51c2UoVG9vbHRpcENvbXBvbmVudCk7XG4vLyBgYXhpc1BvaW50ZXJgIGNvbXBvbmVudCwgZm9yIGV4YW1wbGU6XG4vLyBjaGFydC5zZXRPcHRpb24oe1xuLy8gICAgIHRvb2x0aXA6IHtheGlzUG9pbnRlcjogey4uLn0sIC4uLn1cbi8vIH0pO1xuLy8gT3Jcbi8vIGNoYXJ0LnNldE9wdGlvbih7XG4vLyAgICAgYXhpc1BvaW50ZXI6IHsuLi59XG4vLyB9KTtcbnVzZShBeGlzUG9pbnRlckNvbXBvbmVudCk7XG4vLyBgYnJ1c2hgIGNvbXBvbmVudCwgZm9yIGV4YW1wbGU6XG4vLyBjaGFydC5zZXRPcHRpb24oe1xuLy8gICAgIGJydXNoOiB7Li4ufVxuLy8gfSk7XG4vLyBPclxuLy8gY2hhcnQuc2V0T3B0aW9uKHtcbi8vICAgICB0b29sdGlwOiB7ZmVhdHVyZToge2JydXNoOiB7Li4ufX1cbi8vIH0pXG51c2UoQnJ1c2hDb21wb25lbnQpO1xuLy8gYHRpdGxlYCBjb21wb25lbnQsIGZvciBleGFtcGxlOlxuLy8gY2hhcnQuc2V0T3B0aW9uKHtcbi8vICAgICB0aXRsZTogey4uLn1cbi8vIH0pO1xudXNlKFRpdGxlQ29tcG9uZW50KTtcbi8vIGB0aW1lbGluZWAgY29tcG9uZW50LCBmb3IgZXhhbXBsZTpcbi8vIGNoYXJ0LnNldE9wdGlvbih7XG4vLyAgICAgdGltZWxpbmU6IHsuLi59XG4vLyB9KTtcbnVzZShUaW1lbGluZUNvbXBvbmVudCk7XG4vLyBgbWFya1BvaW50YCBjb21wb25lbnQsIGZvciBleGFtcGxlOlxuLy8gY2hhcnQuc2V0T3B0aW9uKHtcbi8vICAgICBzZXJpZXM6IFt7bWFya1BvaW50OiB7Li4ufX1dXG4vLyB9KTtcbnVzZShNYXJrUG9pbnRDb21wb25lbnQpO1xuLy8gYG1hcmtMaW5lYCBjb21wb25lbnQsIGZvciBleGFtcGxlOlxuLy8gY2hhcnQuc2V0T3B0aW9uKHtcbi8vICAgICBzZXJpZXM6IFt7bWFya0xpbmU6IHsuLi59fV1cbi8vIH0pO1xudXNlKE1hcmtMaW5lQ29tcG9uZW50KTtcbi8vIGBtYXJrQXJlYWAgY29tcG9uZW50LCBmb3IgZXhhbXBsZTpcbi8vIGNoYXJ0LnNldE9wdGlvbih7XG4vLyAgICAgc2VyaWVzOiBbe21hcmtBcmVhOiB7Li4ufX1dXG4vLyB9KTtcbnVzZShNYXJrQXJlYUNvbXBvbmVudCk7XG4vLyBgbGVnZW5kYCBjb21wb25lbnQgbm90IHNjcm9sbGFibGUuIGZvciBleGFtcGxlOlxuLy8gY2hhcnQuc2V0T3B0aW9uKHtcbi8vICAgICBsZWdlbmQ6IHsuLi59XG4vLyB9KTtcbnVzZShMZWdlbmRDb21wb25lbnQpO1xuLy8gYGRhdGFab29tYCBjb21wb25lbnQgaW5jbHVkaW5nIGJvdGggYGRhdGFab29tSW5zaWRlYCBhbmQgYGRhdGFab29tU2xpZGVyYC5cbnVzZShEYXRhWm9vbUNvbXBvbmVudCk7XG4vLyBgZGF0YVpvb21gIGNvbXBvbmVudCBwcm92aWRpbmcgZHJhZywgcGluY2gsIHdoZWVsIGJlaGF2aW9yc1xuLy8gaW5zaWRlIGNvb3JkaW5hdGUgc3lzdGVtLCBmb3IgZXhhbXBsZTpcbi8vIGNoYXJ0LnNldE9wdGlvbih7XG4vLyAgICAgZGF0YVpvb206IHt0eXBlOiAnaW5zaWRlJ31cbi8vIH0pO1xudXNlKERhdGFab29tSW5zaWRlQ29tcG9uZW50KTtcbi8vIGBkYXRhWm9vbWAgY29tcG9uZW50IHByb3ZpZGluZyBhIHNsaWRlciBiYXIsIGZvciBleGFtcGxlOlxuLy8gY2hhcnQuc2V0T3B0aW9uKHtcbi8vICAgICBkYXRhWm9vbToge3R5cGU6ICdzbGlkZXInfVxuLy8gfSk7XG51c2UoRGF0YVpvb21TbGlkZXJDb21wb25lbnQpO1xuLy8gYHZpc3VhbE1hcGAgY29tcG9uZW50IGluY2x1ZGluZyBib3RoIGB2aXN1YWxNYXBDb250aW51b3VzYCBhbmQgYHZpc3VhbE1hcFBpZWNld2lzZWAuXG51c2UoVmlzdWFsTWFwQ29tcG9uZW50KTtcbi8vIGB2aXN1YWxNYXBgIGNvbXBvbmVudCBwcm92aWRpbmcgY29udGludW91cyBiYXIsIGZvciBleGFtcGxlOlxuLy8gY2hhcnQuc2V0T3B0aW9uKHtcbi8vICAgICB2aXN1YWxNYXA6IHt0eXBlOiAnY29udGludW91cyd9XG4vLyB9KTtcbnVzZShWaXN1YWxNYXBDb250aW51b3VzQ29tcG9uZW50KTtcbi8vIGB2aXN1YWxNYXBgIGNvbXBvbmVudCBwcm92aWRpbmcgcGllY2VzIGJhciwgZm9yIGV4YW1wbGU6XG4vLyBjaGFydC5zZXRPcHRpb24oe1xuLy8gICAgIHZpc3VhbE1hcDoge3R5cGU6ICdwaWVjZXdpc2UnfVxuLy8gfSk7XG51c2UoVmlzdWFsTWFwUGllY2V3aXNlQ29tcG9uZW50KTtcbi8vIGBhcmlhYCBjb21wb25lbnQgcHJvdmlkaW5nIGFyaWEsIGZvciBleGFtcGxlOlxuLy8gY2hhcnQuc2V0T3B0aW9uKHtcbi8vICAgICBhcmlhOiB7Li4ufVxuLy8gfSk7XG51c2UoQXJpYUNvbXBvbmVudCk7XG4vLyBkYXRhc2V0IHRyYW5zZm9ybVxuLy8gY2hhcnQuc2V0T3B0aW9uKHtcbi8vICAgICBkYXRhc2V0OiB7XG4vLyAgICAgICAgICB0cmFuc2Zvcm06IFtdXG4vLyAgICAgfVxuLy8gfSk7XG51c2UoVHJhbnNmb3JtQ29tcG9uZW50KTtcbnVzZShEYXRhc2V0Q29tcG9uZW50KTtcbi8vIHVuaXZlcnNhbCB0cmFuc2l0aW9uXG4vLyBjaGFydC5zZXRPcHRpb24oe1xuLy8gICAgIHNlcmllczoge1xuLy8gICAgICAgICB1bml2ZXJzYWxUcmFuc2l0aW9uOiB7IGVuYWJsZWQ6IHRydWUgfVxuLy8gICAgIH1cbi8vIH0pXG51c2UoVW5pdmVyc2FsVHJhbnNpdGlvbik7XG4vLyBsYWJlbCBsYXlvdXRcbi8vIGNoYXJ0LnNldE9wdGlvbih7XG4vLyAgICAgc2VyaWVzOiB7XG4vLyAgICAgICAgIGxhYmVsTGF5b3V0OiB7IGhpZGVPdmVybGFwOiB0cnVlIH1cbi8vICAgICB9XG4vLyB9KVxudXNlKExhYmVsTGF5b3V0KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7312\n")},57625:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aB: () => (/* binding */ updateLeaveTo),\n/* harmony export */   h8: () => (/* binding */ applyLeaveTransition),\n/* harmony export */   ho: () => (/* binding */ isTransitionAll),\n/* harmony export */   rd: () => (/* binding */ ELEMENT_ANIMATABLE_PROPS),\n/* harmony export */   rh: () => (/* binding */ applyUpdateTransition)\n/* harmony export */ });\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48170);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var zrender_lib_animation_Animator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21756);\n/* harmony import */ var zrender_lib_graphic_Displayable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(71519);\n/* harmony import */ var _basicTransition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5638);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(59482);\n/* harmony import */ var zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92836);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nvar LEGACY_TRANSFORM_PROPS_MAP = {\n  position: ['x', 'y'],\n  scale: ['scaleX', 'scaleY'],\n  origin: ['originX', 'originY']\n};\nvar LEGACY_TRANSFORM_PROPS = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys)(LEGACY_TRANSFORM_PROPS_MAP);\nvar TRANSFORM_PROPS_MAP = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.reduce)(zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_1__/* .TRANSFORMABLE_PROPS */ .Wx, function (obj, key) {\n  obj[key] = 1;\n  return obj;\n}, {});\nvar transformPropNamesStr = zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_1__/* .TRANSFORMABLE_PROPS */ .Wx.join(', ');\n// '' means root\nvar ELEMENT_ANIMATABLE_PROPS = ['', 'style', 'shape', 'extra'];\n;\nvar transitionInnerStore = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_2__/* .makeInner */ .$r)();\n;\nfunction getElementAnimationConfig(animationType, el, elOption, parentModel, dataIndex) {\n  var animationProp = animationType + \"Animation\";\n  var config = (0,_basicTransition_js__WEBPACK_IMPORTED_MODULE_3__/* .getAnimationConfig */ .Jw)(animationType, parentModel, dataIndex) || {};\n  var userDuring = transitionInnerStore(el).userDuring;\n  // Only set when duration is > 0 and it's need to be animated.\n  if (config.duration > 0) {\n    // For simplicity, if during not specified, the previous during will not work any more.\n    config.during = userDuring ? (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.bind)(duringCall, {\n      el: el,\n      userDuring: userDuring\n    }) : null;\n    config.setToFinal = true;\n    config.scope = animationType;\n  }\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend)(config, elOption[animationProp]);\n  return config;\n}\nfunction applyUpdateTransition(el, elOption, animatableModel, opts) {\n  opts = opts || {};\n  var dataIndex = opts.dataIndex,\n    isInit = opts.isInit,\n    clearStyle = opts.clearStyle;\n  var hasAnimation = animatableModel.isAnimationEnabled();\n  // Save the meta info for further morphing. Like apply on the sub morphing elements.\n  var store = transitionInnerStore(el);\n  var styleOpt = elOption.style;\n  store.userDuring = elOption.during;\n  var transFromProps = {};\n  var propsToSet = {};\n  prepareTransformAllPropsFinal(el, elOption, propsToSet);\n  prepareShapeOrExtraAllPropsFinal('shape', elOption, propsToSet);\n  prepareShapeOrExtraAllPropsFinal('extra', elOption, propsToSet);\n  if (!isInit && hasAnimation) {\n    prepareTransformTransitionFrom(el, elOption, transFromProps);\n    prepareShapeOrExtraTransitionFrom('shape', el, elOption, transFromProps);\n    prepareShapeOrExtraTransitionFrom('extra', el, elOption, transFromProps);\n    prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps);\n  }\n  propsToSet.style = styleOpt;\n  applyPropsDirectly(el, propsToSet, clearStyle);\n  applyMiscProps(el, elOption);\n  if (hasAnimation) {\n    if (isInit) {\n      var enterFromProps_1 = {};\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(ELEMENT_ANIMATABLE_PROPS, function (propName) {\n        var prop = propName ? elOption[propName] : elOption;\n        if (prop && prop.enterFrom) {\n          if (propName) {\n            enterFromProps_1[propName] = enterFromProps_1[propName] || {};\n          }\n          (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend)(propName ? enterFromProps_1[propName] : enterFromProps_1, prop.enterFrom);\n        }\n      });\n      var config = getElementAnimationConfig('enter', el, elOption, animatableModel, dataIndex);\n      if (config.duration > 0) {\n        el.animateFrom(enterFromProps_1, config);\n      }\n    } else {\n      applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps);\n    }\n  }\n  // Store leave to be used in leave transition.\n  updateLeaveTo(el, elOption);\n  styleOpt ? el.dirty() : el.markRedraw();\n}\nfunction updateLeaveTo(el, elOption) {\n  // Try merge to previous set leaveTo\n  var leaveToProps = transitionInnerStore(el).leaveToProps;\n  for (var i = 0; i < ELEMENT_ANIMATABLE_PROPS.length; i++) {\n    var propName = ELEMENT_ANIMATABLE_PROPS[i];\n    var prop = propName ? elOption[propName] : elOption;\n    if (prop && prop.leaveTo) {\n      if (!leaveToProps) {\n        leaveToProps = transitionInnerStore(el).leaveToProps = {};\n      }\n      if (propName) {\n        leaveToProps[propName] = leaveToProps[propName] || {};\n      }\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend)(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo);\n    }\n  }\n}\nfunction applyLeaveTransition(el, elOption, animatableModel, onRemove) {\n  if (el) {\n    var parent_1 = el.parent;\n    var leaveToProps = transitionInnerStore(el).leaveToProps;\n    if (leaveToProps) {\n      // TODO TODO use leave after leaveAnimation in series is introduced\n      // TODO Data index?\n      var config = getElementAnimationConfig('update', el, elOption, animatableModel, 0);\n      config.done = function () {\n        parent_1.remove(el);\n        onRemove && onRemove();\n      };\n      el.animateTo(leaveToProps, config);\n    } else {\n      parent_1.remove(el);\n      onRemove && onRemove();\n    }\n  }\n}\nfunction isTransitionAll(transition) {\n  return transition === 'all';\n}\nfunction applyPropsDirectly(el,\n// Can be null/undefined\nallPropsFinal, clearStyle) {\n  var styleOpt = allPropsFinal.style;\n  if (!el.isGroup && styleOpt) {\n    if (clearStyle) {\n      el.useStyle({});\n      // When style object changed, how to trade the existing animation?\n      // It is probably complicated and not needed to cover all the cases.\n      // But still need consider the case:\n      // (1) When using init animation on `style.opacity`, and before the animation\n      //     ended users triggers an update by mousewhel. At that time the init\n      //     animation should better be continued rather than terminated.\n      //     So after `useStyle` called, we should change the animation target manually\n      //     to continue the effect of the init animation.\n      // (2) PENDING: If the previous animation targeted at a `val1`, and currently we need\n      //     to update the value to `val2` and no animation declared, should be terminate\n      //     the previous animation or just modify the target of the animation?\n      //     Therotically That will happen not only on `style` but also on `shape` and\n      //     `transfrom` props. But we haven't handle this case at present yet.\n      // (3) PENDING: Is it proper to visit `animators` and `targetName`?\n      var animators = el.animators;\n      for (var i = 0; i < animators.length; i++) {\n        var animator = animators[i];\n        // targetName is the \"topKey\".\n        if (animator.targetName === 'style') {\n          animator.changeTarget(el.style);\n        }\n      }\n    }\n    el.setStyle(styleOpt);\n  }\n  if (allPropsFinal) {\n    // Not set style here.\n    allPropsFinal.style = null;\n    // Set el to the final state firstly.\n    allPropsFinal && el.attr(allPropsFinal);\n    allPropsFinal.style = styleOpt;\n  }\n}\nfunction applyPropsTransition(el, elOption, dataIndex, model,\n// Can be null/undefined\ntransFromProps) {\n  if (transFromProps) {\n    var config = getElementAnimationConfig('update', el, elOption, model, dataIndex);\n    if (config.duration > 0) {\n      el.animateFrom(transFromProps, config);\n    }\n  }\n}\nfunction applyMiscProps(el, elOption) {\n  // Merge by default.\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(elOption, 'silent') && (el.silent = elOption.silent);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(elOption, 'ignore') && (el.ignore = elOption.ignore);\n  if (el instanceof zrender_lib_graphic_Displayable_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .Ay) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(elOption, 'invisible') && (el.invisible = elOption.invisible);\n  }\n  if (el instanceof _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .Ay) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(elOption, 'autoBatch') && (el.autoBatch = elOption.autoBatch);\n  }\n}\n// Use it to avoid it be exposed to user.\nvar tmpDuringScope = {};\nvar transitionDuringAPI = {\n  // Usually other props do not need to be changed in animation during.\n  setTransform: function (key, val) {\n    if (false) {}\n    tmpDuringScope.el[key] = val;\n    return this;\n  },\n  getTransform: function (key) {\n    if (false) {}\n    return tmpDuringScope.el[key];\n  },\n  setShape: function (key, val) {\n    if (false) {}\n    var el = tmpDuringScope.el;\n    var shape = el.shape || (el.shape = {});\n    shape[key] = val;\n    el.dirtyShape && el.dirtyShape();\n    return this;\n  },\n  getShape: function (key) {\n    if (false) {}\n    var shape = tmpDuringScope.el.shape;\n    if (shape) {\n      return shape[key];\n    }\n  },\n  setStyle: function (key, val) {\n    if (false) {}\n    var el = tmpDuringScope.el;\n    var style = el.style;\n    if (style) {\n      if (false) {}\n      style[key] = val;\n      el.dirtyStyle && el.dirtyStyle();\n    }\n    return this;\n  },\n  getStyle: function (key) {\n    if (false) {}\n    var style = tmpDuringScope.el.style;\n    if (style) {\n      return style[key];\n    }\n  },\n  setExtra: function (key, val) {\n    if (false) {}\n    var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});\n    extra[key] = val;\n    return this;\n  },\n  getExtra: function (key) {\n    if (false) {}\n    var extra = tmpDuringScope.el.extra;\n    if (extra) {\n      return extra[key];\n    }\n  }\n};\nfunction assertNotReserved(key) {\n  if (false) {}\n}\nfunction duringCall() {\n  // Do not provide \"percent\" until some requirements come.\n  // Because consider thies case:\n  // enterFrom: {x: 100, y: 30}, transition: 'x'.\n  // And enter duration is different from update duration.\n  // Thus it might be confused about the meaning of \"percent\" in during callback.\n  var scope = this;\n  var el = scope.el;\n  if (!el) {\n    return;\n  }\n  // If el is remove from zr by reason like legend, during still need to called,\n  // because el will be added back to zr and the prop value should not be incorrect.\n  var latestUserDuring = transitionInnerStore(el).userDuring;\n  var scopeUserDuring = scope.userDuring;\n  // Ensured a during is only called once in each animation frame.\n  // If a during is called multiple times in one frame, maybe some users' calculation logic\n  // might be wrong (not sure whether this usage exists).\n  // The case of a during might be called twice can be: by default there is a animator for\n  // 'x', 'y' when init. Before the init animation finished, call `setOption` to start\n  // another animators for 'style'/'shape'/'extra'.\n  if (latestUserDuring !== scopeUserDuring) {\n    // release\n    scope.el = scope.userDuring = null;\n    return;\n  }\n  tmpDuringScope.el = el;\n  // Give no `this` to user in \"during\" calling.\n  scopeUserDuring(transitionDuringAPI);\n  // FIXME: if in future meet the case that some prop will be both modified in `during` and `state`,\n  // consider the issue that the prop might be incorrect when return to \"normal\" state.\n}\nfunction prepareShapeOrExtraTransitionFrom(mainAttr, fromEl, elOption, transFromProps) {\n  var attrOpt = elOption[mainAttr];\n  if (!attrOpt) {\n    return;\n  }\n  var elPropsInAttr = fromEl[mainAttr];\n  var transFromPropsInAttr;\n  if (elPropsInAttr) {\n    var transition = elOption.transition;\n    var attrTransition = attrOpt.transition;\n    if (attrTransition) {\n      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n      if (isTransitionAll(attrTransition)) {\n        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend)(transFromPropsInAttr, elPropsInAttr);\n      } else {\n        var transitionKeys = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_2__/* .normalizeToArray */ .qB)(attrTransition);\n        for (var i = 0; i < transitionKeys.length; i++) {\n          var key = transitionKeys[i];\n          var elVal = elPropsInAttr[key];\n          transFromPropsInAttr[key] = elVal;\n        }\n      }\n    } else if (isTransitionAll(transition) || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf)(transition, mainAttr) >= 0) {\n      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n      var elPropsInAttrKeys = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys)(elPropsInAttr);\n      for (var i = 0; i < elPropsInAttrKeys.length; i++) {\n        var key = elPropsInAttrKeys[i];\n        var elVal = elPropsInAttr[key];\n        if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {\n          transFromPropsInAttr[key] = elVal;\n        }\n      }\n    }\n  }\n}\nfunction prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {\n  var attrOpt = elOption[mainAttr];\n  if (!attrOpt) {\n    return;\n  }\n  var allPropsInAttr = allProps[mainAttr] = {};\n  var keysInAttr = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys)(attrOpt);\n  for (var i = 0; i < keysInAttr.length; i++) {\n    var key = keysInAttr[i];\n    // To avoid share one object with different element, and\n    // to avoid user modify the object inexpectedly, have to clone.\n    allPropsInAttr[key] = (0,zrender_lib_animation_Animator_js__WEBPACK_IMPORTED_MODULE_6__/* .cloneValue */ .F)(attrOpt[key]);\n  }\n}\nfunction prepareTransformTransitionFrom(el, elOption, transFromProps) {\n  var transition = elOption.transition;\n  var transitionKeys = isTransitionAll(transition) ? zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_1__/* .TRANSFORMABLE_PROPS */ .Wx : (0,_util_model_js__WEBPACK_IMPORTED_MODULE_2__/* .normalizeToArray */ .qB)(transition || []);\n  for (var i = 0; i < transitionKeys.length; i++) {\n    var key = transitionKeys[i];\n    if (key === 'style' || key === 'shape' || key === 'extra') {\n      continue;\n    }\n    var elVal = el[key];\n    if (false) {}\n    // Do not clone, animator will perform that clone.\n    transFromProps[key] = elVal;\n  }\n}\nfunction prepareTransformAllPropsFinal(el, elOption, allProps) {\n  for (var i = 0; i < LEGACY_TRANSFORM_PROPS.length; i++) {\n    var legacyName = LEGACY_TRANSFORM_PROPS[i];\n    var xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName];\n    var legacyArr = elOption[legacyName];\n    if (legacyArr) {\n      allProps[xyName[0]] = legacyArr[0];\n      allProps[xyName[1]] = legacyArr[1];\n    }\n  }\n  for (var i = 0; i < zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_1__/* .TRANSFORMABLE_PROPS */ .Wx.length; i++) {\n    var key = zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_1__/* .TRANSFORMABLE_PROPS */ .Wx[i];\n    if (elOption[key] != null) {\n      allProps[key] = elOption[key];\n    }\n  }\n}\nfunction prepareStyleTransitionFrom(fromEl, elOption, styleOpt, transFromProps) {\n  if (!styleOpt) {\n    return;\n  }\n  var fromElStyle = fromEl.style;\n  var transFromStyleProps;\n  if (fromElStyle) {\n    var styleTransition = styleOpt.transition;\n    var elTransition = elOption.transition;\n    if (styleTransition && !isTransitionAll(styleTransition)) {\n      var transitionKeys = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_2__/* .normalizeToArray */ .qB)(styleTransition);\n      !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n      for (var i = 0; i < transitionKeys.length; i++) {\n        var key = transitionKeys[i];\n        var elVal = fromElStyle[key];\n        // Do not clone, see `checkNonStyleTansitionRefer`.\n        transFromStyleProps[key] = elVal;\n      }\n    } else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf)(elTransition, 'style') >= 0)) {\n      var animationProps = fromEl.getAnimationStyleProps();\n      var animationStyleProps = animationProps ? animationProps.style : null;\n      if (animationStyleProps) {\n        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n        var styleKeys = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys)(styleOpt);\n        for (var i = 0; i < styleKeys.length; i++) {\n          var key = styleKeys[i];\n          if (animationStyleProps[key]) {\n            var elVal = fromElStyle[key];\n            transFromStyleProps[key] = elVal;\n          }\n        }\n      }\n    }\n  }\n}\nfunction isNonStyleTransitionEnabled(optVal, elVal) {\n  // The same as `checkNonStyleTansitionRefer`.\n  return !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArrayLike)(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;\n}\nvar checkTransformPropRefer;\nif (false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc2MjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9hbmltYXRpb24vY3VzdG9tR3JhcGhpY1RyYW5zaXRpb24uanM/NGMyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IG1ha2VJbm5lciwgbm9ybWFsaXplVG9BcnJheSB9IGZyb20gJy4uL3V0aWwvbW9kZWwuanMnO1xuaW1wb3J0IHsgYXNzZXJ0LCBiaW5kLCBlYWNoLCBlcU5hTiwgZXh0ZW5kLCBoYXNPd24sIGluZGV4T2YsIGlzQXJyYXlMaWtlLCBrZXlzLCByZWR1Y2UgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgY2xvbmVWYWx1ZSB9IGZyb20gJ3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qcyc7XG5pbXBvcnQgRGlzcGxheWFibGUgZnJvbSAnenJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qcyc7XG5pbXBvcnQgeyBnZXRBbmltYXRpb25Db25maWcgfSBmcm9tICcuL2Jhc2ljVHJhbnNpdGlvbi5qcyc7XG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi91dGlsL2xvZy5qcyc7XG5pbXBvcnQgeyBUUkFOU0ZPUk1BQkxFX1BST1BTIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS9UcmFuc2Zvcm1hYmxlLmpzJztcbnZhciBMRUdBQ1lfVFJBTlNGT1JNX1BST1BTX01BUCA9IHtcbiAgcG9zaXRpb246IFsneCcsICd5J10sXG4gIHNjYWxlOiBbJ3NjYWxlWCcsICdzY2FsZVknXSxcbiAgb3JpZ2luOiBbJ29yaWdpblgnLCAnb3JpZ2luWSddXG59O1xudmFyIExFR0FDWV9UUkFOU0ZPUk1fUFJPUFMgPSBrZXlzKExFR0FDWV9UUkFOU0ZPUk1fUFJPUFNfTUFQKTtcbnZhciBUUkFOU0ZPUk1fUFJPUFNfTUFQID0gcmVkdWNlKFRSQU5TRk9STUFCTEVfUFJPUFMsIGZ1bmN0aW9uIChvYmosIGtleSkge1xuICBvYmpba2V5XSA9IDE7XG4gIHJldHVybiBvYmo7XG59LCB7fSk7XG52YXIgdHJhbnNmb3JtUHJvcE5hbWVzU3RyID0gVFJBTlNGT1JNQUJMRV9QUk9QUy5qb2luKCcsICcpO1xuLy8gJycgbWVhbnMgcm9vdFxuZXhwb3J0IHZhciBFTEVNRU5UX0FOSU1BVEFCTEVfUFJPUFMgPSBbJycsICdzdHlsZScsICdzaGFwZScsICdleHRyYSddO1xuO1xudmFyIHRyYW5zaXRpb25Jbm5lclN0b3JlID0gbWFrZUlubmVyKCk7XG47XG5mdW5jdGlvbiBnZXRFbGVtZW50QW5pbWF0aW9uQ29uZmlnKGFuaW1hdGlvblR5cGUsIGVsLCBlbE9wdGlvbiwgcGFyZW50TW9kZWwsIGRhdGFJbmRleCkge1xuICB2YXIgYW5pbWF0aW9uUHJvcCA9IGFuaW1hdGlvblR5cGUgKyBcIkFuaW1hdGlvblwiO1xuICB2YXIgY29uZmlnID0gZ2V0QW5pbWF0aW9uQ29uZmlnKGFuaW1hdGlvblR5cGUsIHBhcmVudE1vZGVsLCBkYXRhSW5kZXgpIHx8IHt9O1xuICB2YXIgdXNlckR1cmluZyA9IHRyYW5zaXRpb25Jbm5lclN0b3JlKGVsKS51c2VyRHVyaW5nO1xuICAvLyBPbmx5IHNldCB3aGVuIGR1cmF0aW9uIGlzID4gMCBhbmQgaXQncyBuZWVkIHRvIGJlIGFuaW1hdGVkLlxuICBpZiAoY29uZmlnLmR1cmF0aW9uID4gMCkge1xuICAgIC8vIEZvciBzaW1wbGljaXR5LCBpZiBkdXJpbmcgbm90IHNwZWNpZmllZCwgdGhlIHByZXZpb3VzIGR1cmluZyB3aWxsIG5vdCB3b3JrIGFueSBtb3JlLlxuICAgIGNvbmZpZy5kdXJpbmcgPSB1c2VyRHVyaW5nID8gYmluZChkdXJpbmdDYWxsLCB7XG4gICAgICBlbDogZWwsXG4gICAgICB1c2VyRHVyaW5nOiB1c2VyRHVyaW5nXG4gICAgfSkgOiBudWxsO1xuICAgIGNvbmZpZy5zZXRUb0ZpbmFsID0gdHJ1ZTtcbiAgICBjb25maWcuc2NvcGUgPSBhbmltYXRpb25UeXBlO1xuICB9XG4gIGV4dGVuZChjb25maWcsIGVsT3B0aW9uW2FuaW1hdGlvblByb3BdKTtcbiAgcmV0dXJuIGNvbmZpZztcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVVwZGF0ZVRyYW5zaXRpb24oZWwsIGVsT3B0aW9uLCBhbmltYXRhYmxlTW9kZWwsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHZhciBkYXRhSW5kZXggPSBvcHRzLmRhdGFJbmRleCxcbiAgICBpc0luaXQgPSBvcHRzLmlzSW5pdCxcbiAgICBjbGVhclN0eWxlID0gb3B0cy5jbGVhclN0eWxlO1xuICB2YXIgaGFzQW5pbWF0aW9uID0gYW5pbWF0YWJsZU1vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpO1xuICAvLyBTYXZlIHRoZSBtZXRhIGluZm8gZm9yIGZ1cnRoZXIgbW9ycGhpbmcuIExpa2UgYXBwbHkgb24gdGhlIHN1YiBtb3JwaGluZyBlbGVtZW50cy5cbiAgdmFyIHN0b3JlID0gdHJhbnNpdGlvbklubmVyU3RvcmUoZWwpO1xuICB2YXIgc3R5bGVPcHQgPSBlbE9wdGlvbi5zdHlsZTtcbiAgc3RvcmUudXNlckR1cmluZyA9IGVsT3B0aW9uLmR1cmluZztcbiAgdmFyIHRyYW5zRnJvbVByb3BzID0ge307XG4gIHZhciBwcm9wc1RvU2V0ID0ge307XG4gIHByZXBhcmVUcmFuc2Zvcm1BbGxQcm9wc0ZpbmFsKGVsLCBlbE9wdGlvbiwgcHJvcHNUb1NldCk7XG4gIHByZXBhcmVTaGFwZU9yRXh0cmFBbGxQcm9wc0ZpbmFsKCdzaGFwZScsIGVsT3B0aW9uLCBwcm9wc1RvU2V0KTtcbiAgcHJlcGFyZVNoYXBlT3JFeHRyYUFsbFByb3BzRmluYWwoJ2V4dHJhJywgZWxPcHRpb24sIHByb3BzVG9TZXQpO1xuICBpZiAoIWlzSW5pdCAmJiBoYXNBbmltYXRpb24pIHtcbiAgICBwcmVwYXJlVHJhbnNmb3JtVHJhbnNpdGlvbkZyb20oZWwsIGVsT3B0aW9uLCB0cmFuc0Zyb21Qcm9wcyk7XG4gICAgcHJlcGFyZVNoYXBlT3JFeHRyYVRyYW5zaXRpb25Gcm9tKCdzaGFwZScsIGVsLCBlbE9wdGlvbiwgdHJhbnNGcm9tUHJvcHMpO1xuICAgIHByZXBhcmVTaGFwZU9yRXh0cmFUcmFuc2l0aW9uRnJvbSgnZXh0cmEnLCBlbCwgZWxPcHRpb24sIHRyYW5zRnJvbVByb3BzKTtcbiAgICBwcmVwYXJlU3R5bGVUcmFuc2l0aW9uRnJvbShlbCwgZWxPcHRpb24sIHN0eWxlT3B0LCB0cmFuc0Zyb21Qcm9wcyk7XG4gIH1cbiAgcHJvcHNUb1NldC5zdHlsZSA9IHN0eWxlT3B0O1xuICBhcHBseVByb3BzRGlyZWN0bHkoZWwsIHByb3BzVG9TZXQsIGNsZWFyU3R5bGUpO1xuICBhcHBseU1pc2NQcm9wcyhlbCwgZWxPcHRpb24pO1xuICBpZiAoaGFzQW5pbWF0aW9uKSB7XG4gICAgaWYgKGlzSW5pdCkge1xuICAgICAgdmFyIGVudGVyRnJvbVByb3BzXzEgPSB7fTtcbiAgICAgIGVhY2goRUxFTUVOVF9BTklNQVRBQkxFX1BST1BTLCBmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wTmFtZSA/IGVsT3B0aW9uW3Byb3BOYW1lXSA6IGVsT3B0aW9uO1xuICAgICAgICBpZiAocHJvcCAmJiBwcm9wLmVudGVyRnJvbSkge1xuICAgICAgICAgIGlmIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgZW50ZXJGcm9tUHJvcHNfMVtwcm9wTmFtZV0gPSBlbnRlckZyb21Qcm9wc18xW3Byb3BOYW1lXSB8fCB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXh0ZW5kKHByb3BOYW1lID8gZW50ZXJGcm9tUHJvcHNfMVtwcm9wTmFtZV0gOiBlbnRlckZyb21Qcm9wc18xLCBwcm9wLmVudGVyRnJvbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGNvbmZpZyA9IGdldEVsZW1lbnRBbmltYXRpb25Db25maWcoJ2VudGVyJywgZWwsIGVsT3B0aW9uLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCk7XG4gICAgICBpZiAoY29uZmlnLmR1cmF0aW9uID4gMCkge1xuICAgICAgICBlbC5hbmltYXRlRnJvbShlbnRlckZyb21Qcm9wc18xLCBjb25maWcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhcHBseVByb3BzVHJhbnNpdGlvbihlbCwgZWxPcHRpb24sIGRhdGFJbmRleCB8fCAwLCBhbmltYXRhYmxlTW9kZWwsIHRyYW5zRnJvbVByb3BzKTtcbiAgICB9XG4gIH1cbiAgLy8gU3RvcmUgbGVhdmUgdG8gYmUgdXNlZCBpbiBsZWF2ZSB0cmFuc2l0aW9uLlxuICB1cGRhdGVMZWF2ZVRvKGVsLCBlbE9wdGlvbik7XG4gIHN0eWxlT3B0ID8gZWwuZGlydHkoKSA6IGVsLm1hcmtSZWRyYXcoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVMZWF2ZVRvKGVsLCBlbE9wdGlvbikge1xuICAvLyBUcnkgbWVyZ2UgdG8gcHJldmlvdXMgc2V0IGxlYXZlVG9cbiAgdmFyIGxlYXZlVG9Qcm9wcyA9IHRyYW5zaXRpb25Jbm5lclN0b3JlKGVsKS5sZWF2ZVRvUHJvcHM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgRUxFTUVOVF9BTklNQVRBQkxFX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gRUxFTUVOVF9BTklNQVRBQkxFX1BST1BTW2ldO1xuICAgIHZhciBwcm9wID0gcHJvcE5hbWUgPyBlbE9wdGlvbltwcm9wTmFtZV0gOiBlbE9wdGlvbjtcbiAgICBpZiAocHJvcCAmJiBwcm9wLmxlYXZlVG8pIHtcbiAgICAgIGlmICghbGVhdmVUb1Byb3BzKSB7XG4gICAgICAgIGxlYXZlVG9Qcm9wcyA9IHRyYW5zaXRpb25Jbm5lclN0b3JlKGVsKS5sZWF2ZVRvUHJvcHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wTmFtZSkge1xuICAgICAgICBsZWF2ZVRvUHJvcHNbcHJvcE5hbWVdID0gbGVhdmVUb1Byb3BzW3Byb3BOYW1lXSB8fCB7fTtcbiAgICAgIH1cbiAgICAgIGV4dGVuZChwcm9wTmFtZSA/IGxlYXZlVG9Qcm9wc1twcm9wTmFtZV0gOiBsZWF2ZVRvUHJvcHMsIHByb3AubGVhdmVUbyk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYXBwbHlMZWF2ZVRyYW5zaXRpb24oZWwsIGVsT3B0aW9uLCBhbmltYXRhYmxlTW9kZWwsIG9uUmVtb3ZlKSB7XG4gIGlmIChlbCkge1xuICAgIHZhciBwYXJlbnRfMSA9IGVsLnBhcmVudDtcbiAgICB2YXIgbGVhdmVUb1Byb3BzID0gdHJhbnNpdGlvbklubmVyU3RvcmUoZWwpLmxlYXZlVG9Qcm9wcztcbiAgICBpZiAobGVhdmVUb1Byb3BzKSB7XG4gICAgICAvLyBUT0RPIFRPRE8gdXNlIGxlYXZlIGFmdGVyIGxlYXZlQW5pbWF0aW9uIGluIHNlcmllcyBpcyBpbnRyb2R1Y2VkXG4gICAgICAvLyBUT0RPIERhdGEgaW5kZXg/XG4gICAgICB2YXIgY29uZmlnID0gZ2V0RWxlbWVudEFuaW1hdGlvbkNvbmZpZygndXBkYXRlJywgZWwsIGVsT3B0aW9uLCBhbmltYXRhYmxlTW9kZWwsIDApO1xuICAgICAgY29uZmlnLmRvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBhcmVudF8xLnJlbW92ZShlbCk7XG4gICAgICAgIG9uUmVtb3ZlICYmIG9uUmVtb3ZlKCk7XG4gICAgICB9O1xuICAgICAgZWwuYW5pbWF0ZVRvKGxlYXZlVG9Qcm9wcywgY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50XzEucmVtb3ZlKGVsKTtcbiAgICAgIG9uUmVtb3ZlICYmIG9uUmVtb3ZlKCk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNUcmFuc2l0aW9uQWxsKHRyYW5zaXRpb24pIHtcbiAgcmV0dXJuIHRyYW5zaXRpb24gPT09ICdhbGwnO1xufVxuZnVuY3Rpb24gYXBwbHlQcm9wc0RpcmVjdGx5KGVsLFxuLy8gQ2FuIGJlIG51bGwvdW5kZWZpbmVkXG5hbGxQcm9wc0ZpbmFsLCBjbGVhclN0eWxlKSB7XG4gIHZhciBzdHlsZU9wdCA9IGFsbFByb3BzRmluYWwuc3R5bGU7XG4gIGlmICghZWwuaXNHcm91cCAmJiBzdHlsZU9wdCkge1xuICAgIGlmIChjbGVhclN0eWxlKSB7XG4gICAgICBlbC51c2VTdHlsZSh7fSk7XG4gICAgICAvLyBXaGVuIHN0eWxlIG9iamVjdCBjaGFuZ2VkLCBob3cgdG8gdHJhZGUgdGhlIGV4aXN0aW5nIGFuaW1hdGlvbj9cbiAgICAgIC8vIEl0IGlzIHByb2JhYmx5IGNvbXBsaWNhdGVkIGFuZCBub3QgbmVlZGVkIHRvIGNvdmVyIGFsbCB0aGUgY2FzZXMuXG4gICAgICAvLyBCdXQgc3RpbGwgbmVlZCBjb25zaWRlciB0aGUgY2FzZTpcbiAgICAgIC8vICgxKSBXaGVuIHVzaW5nIGluaXQgYW5pbWF0aW9uIG9uIGBzdHlsZS5vcGFjaXR5YCwgYW5kIGJlZm9yZSB0aGUgYW5pbWF0aW9uXG4gICAgICAvLyAgICAgZW5kZWQgdXNlcnMgdHJpZ2dlcnMgYW4gdXBkYXRlIGJ5IG1vdXNld2hlbC4gQXQgdGhhdCB0aW1lIHRoZSBpbml0XG4gICAgICAvLyAgICAgYW5pbWF0aW9uIHNob3VsZCBiZXR0ZXIgYmUgY29udGludWVkIHJhdGhlciB0aGFuIHRlcm1pbmF0ZWQuXG4gICAgICAvLyAgICAgU28gYWZ0ZXIgYHVzZVN0eWxlYCBjYWxsZWQsIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGFuaW1hdGlvbiB0YXJnZXQgbWFudWFsbHlcbiAgICAgIC8vICAgICB0byBjb250aW51ZSB0aGUgZWZmZWN0IG9mIHRoZSBpbml0IGFuaW1hdGlvbi5cbiAgICAgIC8vICgyKSBQRU5ESU5HOiBJZiB0aGUgcHJldmlvdXMgYW5pbWF0aW9uIHRhcmdldGVkIGF0IGEgYHZhbDFgLCBhbmQgY3VycmVudGx5IHdlIG5lZWRcbiAgICAgIC8vICAgICB0byB1cGRhdGUgdGhlIHZhbHVlIHRvIGB2YWwyYCBhbmQgbm8gYW5pbWF0aW9uIGRlY2xhcmVkLCBzaG91bGQgYmUgdGVybWluYXRlXG4gICAgICAvLyAgICAgdGhlIHByZXZpb3VzIGFuaW1hdGlvbiBvciBqdXN0IG1vZGlmeSB0aGUgdGFyZ2V0IG9mIHRoZSBhbmltYXRpb24/XG4gICAgICAvLyAgICAgVGhlcm90aWNhbGx5IFRoYXQgd2lsbCBoYXBwZW4gbm90IG9ubHkgb24gYHN0eWxlYCBidXQgYWxzbyBvbiBgc2hhcGVgIGFuZFxuICAgICAgLy8gICAgIGB0cmFuc2Zyb21gIHByb3BzLiBCdXQgd2UgaGF2ZW4ndCBoYW5kbGUgdGhpcyBjYXNlIGF0IHByZXNlbnQgeWV0LlxuICAgICAgLy8gKDMpIFBFTkRJTkc6IElzIGl0IHByb3BlciB0byB2aXNpdCBgYW5pbWF0b3JzYCBhbmQgYHRhcmdldE5hbWVgP1xuICAgICAgdmFyIGFuaW1hdG9ycyA9IGVsLmFuaW1hdG9ycztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhbmltYXRvciA9IGFuaW1hdG9yc1tpXTtcbiAgICAgICAgLy8gdGFyZ2V0TmFtZSBpcyB0aGUgXCJ0b3BLZXlcIi5cbiAgICAgICAgaWYgKGFuaW1hdG9yLnRhcmdldE5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBhbmltYXRvci5jaGFuZ2VUYXJnZXQoZWwuc3R5bGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnNldFN0eWxlKHN0eWxlT3B0KTtcbiAgfVxuICBpZiAoYWxsUHJvcHNGaW5hbCkge1xuICAgIC8vIE5vdCBzZXQgc3R5bGUgaGVyZS5cbiAgICBhbGxQcm9wc0ZpbmFsLnN0eWxlID0gbnVsbDtcbiAgICAvLyBTZXQgZWwgdG8gdGhlIGZpbmFsIHN0YXRlIGZpcnN0bHkuXG4gICAgYWxsUHJvcHNGaW5hbCAmJiBlbC5hdHRyKGFsbFByb3BzRmluYWwpO1xuICAgIGFsbFByb3BzRmluYWwuc3R5bGUgPSBzdHlsZU9wdDtcbiAgfVxufVxuZnVuY3Rpb24gYXBwbHlQcm9wc1RyYW5zaXRpb24oZWwsIGVsT3B0aW9uLCBkYXRhSW5kZXgsIG1vZGVsLFxuLy8gQ2FuIGJlIG51bGwvdW5kZWZpbmVkXG50cmFuc0Zyb21Qcm9wcykge1xuICBpZiAodHJhbnNGcm9tUHJvcHMpIHtcbiAgICB2YXIgY29uZmlnID0gZ2V0RWxlbWVudEFuaW1hdGlvbkNvbmZpZygndXBkYXRlJywgZWwsIGVsT3B0aW9uLCBtb2RlbCwgZGF0YUluZGV4KTtcbiAgICBpZiAoY29uZmlnLmR1cmF0aW9uID4gMCkge1xuICAgICAgZWwuYW5pbWF0ZUZyb20odHJhbnNGcm9tUHJvcHMsIGNvbmZpZyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBseU1pc2NQcm9wcyhlbCwgZWxPcHRpb24pIHtcbiAgLy8gTWVyZ2UgYnkgZGVmYXVsdC5cbiAgaGFzT3duKGVsT3B0aW9uLCAnc2lsZW50JykgJiYgKGVsLnNpbGVudCA9IGVsT3B0aW9uLnNpbGVudCk7XG4gIGhhc093bihlbE9wdGlvbiwgJ2lnbm9yZScpICYmIChlbC5pZ25vcmUgPSBlbE9wdGlvbi5pZ25vcmUpO1xuICBpZiAoZWwgaW5zdGFuY2VvZiBEaXNwbGF5YWJsZSkge1xuICAgIGhhc093bihlbE9wdGlvbiwgJ2ludmlzaWJsZScpICYmIChlbC5pbnZpc2libGUgPSBlbE9wdGlvbi5pbnZpc2libGUpO1xuICB9XG4gIGlmIChlbCBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICBoYXNPd24oZWxPcHRpb24sICdhdXRvQmF0Y2gnKSAmJiAoZWwuYXV0b0JhdGNoID0gZWxPcHRpb24uYXV0b0JhdGNoKTtcbiAgfVxufVxuLy8gVXNlIGl0IHRvIGF2b2lkIGl0IGJlIGV4cG9zZWQgdG8gdXNlci5cbnZhciB0bXBEdXJpbmdTY29wZSA9IHt9O1xudmFyIHRyYW5zaXRpb25EdXJpbmdBUEkgPSB7XG4gIC8vIFVzdWFsbHkgb3RoZXIgcHJvcHMgZG8gbm90IG5lZWQgdG8gYmUgY2hhbmdlZCBpbiBhbmltYXRpb24gZHVyaW5nLlxuICBzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQoaGFzT3duKFRSQU5TRk9STV9QUk9QU19NQVAsIGtleSksICdPbmx5ICcgKyB0cmFuc2Zvcm1Qcm9wTmFtZXNTdHIgKyAnIGF2YWlsYWJsZSBpbiBgc2V0VHJhbnNmb3JtYC4nKTtcbiAgICB9XG4gICAgdG1wRHVyaW5nU2NvcGUuZWxba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZ2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChoYXNPd24oVFJBTlNGT1JNX1BST1BTX01BUCwga2V5KSwgJ09ubHkgJyArIHRyYW5zZm9ybVByb3BOYW1lc1N0ciArICcgYXZhaWxhYmxlIGluIGBnZXRUcmFuc2Zvcm1gLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG1wRHVyaW5nU2NvcGUuZWxba2V5XTtcbiAgfSxcbiAgc2V0U2hhcGU6IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnROb3RSZXNlcnZlZChrZXkpO1xuICAgIH1cbiAgICB2YXIgZWwgPSB0bXBEdXJpbmdTY29wZS5lbDtcbiAgICB2YXIgc2hhcGUgPSBlbC5zaGFwZSB8fCAoZWwuc2hhcGUgPSB7fSk7XG4gICAgc2hhcGVba2V5XSA9IHZhbDtcbiAgICBlbC5kaXJ0eVNoYXBlICYmIGVsLmRpcnR5U2hhcGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZ2V0U2hhcGU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0Tm90UmVzZXJ2ZWQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHNoYXBlID0gdG1wRHVyaW5nU2NvcGUuZWwuc2hhcGU7XG4gICAgaWYgKHNoYXBlKSB7XG4gICAgICByZXR1cm4gc2hhcGVba2V5XTtcbiAgICB9XG4gIH0sXG4gIHNldFN0eWxlOiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0Tm90UmVzZXJ2ZWQoa2V5KTtcbiAgICB9XG4gICAgdmFyIGVsID0gdG1wRHVyaW5nU2NvcGUuZWw7XG4gICAgdmFyIHN0eWxlID0gZWwuc3R5bGU7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZXFOYU4odmFsKSkge1xuICAgICAgICAgIHdhcm4oJ3N0eWxlLicgKyBrZXkgKyAnIG11c3Qgbm90IGJlIGFzc2lnbmVkIHdpdGggTmFOLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdHlsZVtrZXldID0gdmFsO1xuICAgICAgZWwuZGlydHlTdHlsZSAmJiBlbC5kaXJ0eVN0eWxlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBnZXRTdHlsZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnROb3RSZXNlcnZlZChrZXkpO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSB0bXBEdXJpbmdTY29wZS5lbC5zdHlsZTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHJldHVybiBzdHlsZVtrZXldO1xuICAgIH1cbiAgfSxcbiAgc2V0RXh0cmE6IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnROb3RSZXNlcnZlZChrZXkpO1xuICAgIH1cbiAgICB2YXIgZXh0cmEgPSB0bXBEdXJpbmdTY29wZS5lbC5leHRyYSB8fCAodG1wRHVyaW5nU2NvcGUuZWwuZXh0cmEgPSB7fSk7XG4gICAgZXh0cmFba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZ2V0RXh0cmE6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0Tm90UmVzZXJ2ZWQoa2V5KTtcbiAgICB9XG4gICAgdmFyIGV4dHJhID0gdG1wRHVyaW5nU2NvcGUuZWwuZXh0cmE7XG4gICAgaWYgKGV4dHJhKSB7XG4gICAgICByZXR1cm4gZXh0cmFba2V5XTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBhc3NlcnROb3RSZXNlcnZlZChrZXkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoa2V5ID09PSAndHJhbnNpdGlvbicgfHwga2V5ID09PSAnZW50ZXJGcm9tJyB8fCBrZXkgPT09ICdsZWF2ZVRvJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXkgbXVzdCBub3QgYmUgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkdXJpbmdDYWxsKCkge1xuICAvLyBEbyBub3QgcHJvdmlkZSBcInBlcmNlbnRcIiB1bnRpbCBzb21lIHJlcXVpcmVtZW50cyBjb21lLlxuICAvLyBCZWNhdXNlIGNvbnNpZGVyIHRoaWVzIGNhc2U6XG4gIC8vIGVudGVyRnJvbToge3g6IDEwMCwgeTogMzB9LCB0cmFuc2l0aW9uOiAneCcuXG4gIC8vIEFuZCBlbnRlciBkdXJhdGlvbiBpcyBkaWZmZXJlbnQgZnJvbSB1cGRhdGUgZHVyYXRpb24uXG4gIC8vIFRodXMgaXQgbWlnaHQgYmUgY29uZnVzZWQgYWJvdXQgdGhlIG1lYW5pbmcgb2YgXCJwZXJjZW50XCIgaW4gZHVyaW5nIGNhbGxiYWNrLlxuICB2YXIgc2NvcGUgPSB0aGlzO1xuICB2YXIgZWwgPSBzY29wZS5lbDtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBJZiBlbCBpcyByZW1vdmUgZnJvbSB6ciBieSByZWFzb24gbGlrZSBsZWdlbmQsIGR1cmluZyBzdGlsbCBuZWVkIHRvIGNhbGxlZCxcbiAgLy8gYmVjYXVzZSBlbCB3aWxsIGJlIGFkZGVkIGJhY2sgdG8genIgYW5kIHRoZSBwcm9wIHZhbHVlIHNob3VsZCBub3QgYmUgaW5jb3JyZWN0LlxuICB2YXIgbGF0ZXN0VXNlckR1cmluZyA9IHRyYW5zaXRpb25Jbm5lclN0b3JlKGVsKS51c2VyRHVyaW5nO1xuICB2YXIgc2NvcGVVc2VyRHVyaW5nID0gc2NvcGUudXNlckR1cmluZztcbiAgLy8gRW5zdXJlZCBhIGR1cmluZyBpcyBvbmx5IGNhbGxlZCBvbmNlIGluIGVhY2ggYW5pbWF0aW9uIGZyYW1lLlxuICAvLyBJZiBhIGR1cmluZyBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaW4gb25lIGZyYW1lLCBtYXliZSBzb21lIHVzZXJzJyBjYWxjdWxhdGlvbiBsb2dpY1xuICAvLyBtaWdodCBiZSB3cm9uZyAobm90IHN1cmUgd2hldGhlciB0aGlzIHVzYWdlIGV4aXN0cykuXG4gIC8vIFRoZSBjYXNlIG9mIGEgZHVyaW5nIG1pZ2h0IGJlIGNhbGxlZCB0d2ljZSBjYW4gYmU6IGJ5IGRlZmF1bHQgdGhlcmUgaXMgYSBhbmltYXRvciBmb3JcbiAgLy8gJ3gnLCAneScgd2hlbiBpbml0LiBCZWZvcmUgdGhlIGluaXQgYW5pbWF0aW9uIGZpbmlzaGVkLCBjYWxsIGBzZXRPcHRpb25gIHRvIHN0YXJ0XG4gIC8vIGFub3RoZXIgYW5pbWF0b3JzIGZvciAnc3R5bGUnLydzaGFwZScvJ2V4dHJhJy5cbiAgaWYgKGxhdGVzdFVzZXJEdXJpbmcgIT09IHNjb3BlVXNlckR1cmluZykge1xuICAgIC8vIHJlbGVhc2VcbiAgICBzY29wZS5lbCA9IHNjb3BlLnVzZXJEdXJpbmcgPSBudWxsO1xuICAgIHJldHVybjtcbiAgfVxuICB0bXBEdXJpbmdTY29wZS5lbCA9IGVsO1xuICAvLyBHaXZlIG5vIGB0aGlzYCB0byB1c2VyIGluIFwiZHVyaW5nXCIgY2FsbGluZy5cbiAgc2NvcGVVc2VyRHVyaW5nKHRyYW5zaXRpb25EdXJpbmdBUEkpO1xuICAvLyBGSVhNRTogaWYgaW4gZnV0dXJlIG1lZXQgdGhlIGNhc2UgdGhhdCBzb21lIHByb3Agd2lsbCBiZSBib3RoIG1vZGlmaWVkIGluIGBkdXJpbmdgIGFuZCBgc3RhdGVgLFxuICAvLyBjb25zaWRlciB0aGUgaXNzdWUgdGhhdCB0aGUgcHJvcCBtaWdodCBiZSBpbmNvcnJlY3Qgd2hlbiByZXR1cm4gdG8gXCJub3JtYWxcIiBzdGF0ZS5cbn1cbmZ1bmN0aW9uIHByZXBhcmVTaGFwZU9yRXh0cmFUcmFuc2l0aW9uRnJvbShtYWluQXR0ciwgZnJvbUVsLCBlbE9wdGlvbiwgdHJhbnNGcm9tUHJvcHMpIHtcbiAgdmFyIGF0dHJPcHQgPSBlbE9wdGlvblttYWluQXR0cl07XG4gIGlmICghYXR0ck9wdCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZWxQcm9wc0luQXR0ciA9IGZyb21FbFttYWluQXR0cl07XG4gIHZhciB0cmFuc0Zyb21Qcm9wc0luQXR0cjtcbiAgaWYgKGVsUHJvcHNJbkF0dHIpIHtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IGVsT3B0aW9uLnRyYW5zaXRpb247XG4gICAgdmFyIGF0dHJUcmFuc2l0aW9uID0gYXR0ck9wdC50cmFuc2l0aW9uO1xuICAgIGlmIChhdHRyVHJhbnNpdGlvbikge1xuICAgICAgIXRyYW5zRnJvbVByb3BzSW5BdHRyICYmICh0cmFuc0Zyb21Qcm9wc0luQXR0ciA9IHRyYW5zRnJvbVByb3BzW21haW5BdHRyXSA9IHt9KTtcbiAgICAgIGlmIChpc1RyYW5zaXRpb25BbGwoYXR0clRyYW5zaXRpb24pKSB7XG4gICAgICAgIGV4dGVuZCh0cmFuc0Zyb21Qcm9wc0luQXR0ciwgZWxQcm9wc0luQXR0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbktleXMgPSBub3JtYWxpemVUb0FycmF5KGF0dHJUcmFuc2l0aW9uKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2l0aW9uS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSB0cmFuc2l0aW9uS2V5c1tpXTtcbiAgICAgICAgICB2YXIgZWxWYWwgPSBlbFByb3BzSW5BdHRyW2tleV07XG4gICAgICAgICAgdHJhbnNGcm9tUHJvcHNJbkF0dHJba2V5XSA9IGVsVmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RyYW5zaXRpb25BbGwodHJhbnNpdGlvbikgfHwgaW5kZXhPZih0cmFuc2l0aW9uLCBtYWluQXR0cikgPj0gMCkge1xuICAgICAgIXRyYW5zRnJvbVByb3BzSW5BdHRyICYmICh0cmFuc0Zyb21Qcm9wc0luQXR0ciA9IHRyYW5zRnJvbVByb3BzW21haW5BdHRyXSA9IHt9KTtcbiAgICAgIHZhciBlbFByb3BzSW5BdHRyS2V5cyA9IGtleXMoZWxQcm9wc0luQXR0cik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsUHJvcHNJbkF0dHJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBlbFByb3BzSW5BdHRyS2V5c1tpXTtcbiAgICAgICAgdmFyIGVsVmFsID0gZWxQcm9wc0luQXR0cltrZXldO1xuICAgICAgICBpZiAoaXNOb25TdHlsZVRyYW5zaXRpb25FbmFibGVkKGF0dHJPcHRba2V5XSwgZWxWYWwpKSB7XG4gICAgICAgICAgdHJhbnNGcm9tUHJvcHNJbkF0dHJba2V5XSA9IGVsVmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlU2hhcGVPckV4dHJhQWxsUHJvcHNGaW5hbChtYWluQXR0ciwgZWxPcHRpb24sIGFsbFByb3BzKSB7XG4gIHZhciBhdHRyT3B0ID0gZWxPcHRpb25bbWFpbkF0dHJdO1xuICBpZiAoIWF0dHJPcHQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGFsbFByb3BzSW5BdHRyID0gYWxsUHJvcHNbbWFpbkF0dHJdID0ge307XG4gIHZhciBrZXlzSW5BdHRyID0ga2V5cyhhdHRyT3B0KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzSW5BdHRyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNJbkF0dHJbaV07XG4gICAgLy8gVG8gYXZvaWQgc2hhcmUgb25lIG9iamVjdCB3aXRoIGRpZmZlcmVudCBlbGVtZW50LCBhbmRcbiAgICAvLyB0byBhdm9pZCB1c2VyIG1vZGlmeSB0aGUgb2JqZWN0IGluZXhwZWN0ZWRseSwgaGF2ZSB0byBjbG9uZS5cbiAgICBhbGxQcm9wc0luQXR0cltrZXldID0gY2xvbmVWYWx1ZShhdHRyT3B0W2tleV0pO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlVHJhbnNmb3JtVHJhbnNpdGlvbkZyb20oZWwsIGVsT3B0aW9uLCB0cmFuc0Zyb21Qcm9wcykge1xuICB2YXIgdHJhbnNpdGlvbiA9IGVsT3B0aW9uLnRyYW5zaXRpb247XG4gIHZhciB0cmFuc2l0aW9uS2V5cyA9IGlzVHJhbnNpdGlvbkFsbCh0cmFuc2l0aW9uKSA/IFRSQU5TRk9STUFCTEVfUFJPUFMgOiBub3JtYWxpemVUb0FycmF5KHRyYW5zaXRpb24gfHwgW10pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zaXRpb25LZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHRyYW5zaXRpb25LZXlzW2ldO1xuICAgIGlmIChrZXkgPT09ICdzdHlsZScgfHwga2V5ID09PSAnc2hhcGUnIHx8IGtleSA9PT0gJ2V4dHJhJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBlbFZhbCA9IGVsW2tleV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrVHJhbnNmb3JtUHJvcFJlZmVyKGtleSwgJ2VsLnRyYW5zaXRpb24nKTtcbiAgICB9XG4gICAgLy8gRG8gbm90IGNsb25lLCBhbmltYXRvciB3aWxsIHBlcmZvcm0gdGhhdCBjbG9uZS5cbiAgICB0cmFuc0Zyb21Qcm9wc1trZXldID0gZWxWYWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVUcmFuc2Zvcm1BbGxQcm9wc0ZpbmFsKGVsLCBlbE9wdGlvbiwgYWxsUHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBMRUdBQ1lfVFJBTlNGT1JNX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxlZ2FjeU5hbWUgPSBMRUdBQ1lfVFJBTlNGT1JNX1BST1BTW2ldO1xuICAgIHZhciB4eU5hbWUgPSBMRUdBQ1lfVFJBTlNGT1JNX1BST1BTX01BUFtsZWdhY3lOYW1lXTtcbiAgICB2YXIgbGVnYWN5QXJyID0gZWxPcHRpb25bbGVnYWN5TmFtZV07XG4gICAgaWYgKGxlZ2FjeUFycikge1xuICAgICAgYWxsUHJvcHNbeHlOYW1lWzBdXSA9IGxlZ2FjeUFyclswXTtcbiAgICAgIGFsbFByb3BzW3h5TmFtZVsxXV0gPSBsZWdhY3lBcnJbMV07XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVFJBTlNGT1JNQUJMRV9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBUUkFOU0ZPUk1BQkxFX1BST1BTW2ldO1xuICAgIGlmIChlbE9wdGlvbltrZXldICE9IG51bGwpIHtcbiAgICAgIGFsbFByb3BzW2tleV0gPSBlbE9wdGlvbltrZXldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZVN0eWxlVHJhbnNpdGlvbkZyb20oZnJvbUVsLCBlbE9wdGlvbiwgc3R5bGVPcHQsIHRyYW5zRnJvbVByb3BzKSB7XG4gIGlmICghc3R5bGVPcHQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGZyb21FbFN0eWxlID0gZnJvbUVsLnN0eWxlO1xuICB2YXIgdHJhbnNGcm9tU3R5bGVQcm9wcztcbiAgaWYgKGZyb21FbFN0eWxlKSB7XG4gICAgdmFyIHN0eWxlVHJhbnNpdGlvbiA9IHN0eWxlT3B0LnRyYW5zaXRpb247XG4gICAgdmFyIGVsVHJhbnNpdGlvbiA9IGVsT3B0aW9uLnRyYW5zaXRpb247XG4gICAgaWYgKHN0eWxlVHJhbnNpdGlvbiAmJiAhaXNUcmFuc2l0aW9uQWxsKHN0eWxlVHJhbnNpdGlvbikpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uS2V5cyA9IG5vcm1hbGl6ZVRvQXJyYXkoc3R5bGVUcmFuc2l0aW9uKTtcbiAgICAgICF0cmFuc0Zyb21TdHlsZVByb3BzICYmICh0cmFuc0Zyb21TdHlsZVByb3BzID0gdHJhbnNGcm9tUHJvcHMuc3R5bGUgPSB7fSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zaXRpb25LZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSB0cmFuc2l0aW9uS2V5c1tpXTtcbiAgICAgICAgdmFyIGVsVmFsID0gZnJvbUVsU3R5bGVba2V5XTtcbiAgICAgICAgLy8gRG8gbm90IGNsb25lLCBzZWUgYGNoZWNrTm9uU3R5bGVUYW5zaXRpb25SZWZlcmAuXG4gICAgICAgIHRyYW5zRnJvbVN0eWxlUHJvcHNba2V5XSA9IGVsVmFsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZnJvbUVsLmdldEFuaW1hdGlvblN0eWxlUHJvcHMgJiYgKGlzVHJhbnNpdGlvbkFsbChlbFRyYW5zaXRpb24pIHx8IGlzVHJhbnNpdGlvbkFsbChzdHlsZVRyYW5zaXRpb24pIHx8IGluZGV4T2YoZWxUcmFuc2l0aW9uLCAnc3R5bGUnKSA+PSAwKSkge1xuICAgICAgdmFyIGFuaW1hdGlvblByb3BzID0gZnJvbUVsLmdldEFuaW1hdGlvblN0eWxlUHJvcHMoKTtcbiAgICAgIHZhciBhbmltYXRpb25TdHlsZVByb3BzID0gYW5pbWF0aW9uUHJvcHMgPyBhbmltYXRpb25Qcm9wcy5zdHlsZSA6IG51bGw7XG4gICAgICBpZiAoYW5pbWF0aW9uU3R5bGVQcm9wcykge1xuICAgICAgICAhdHJhbnNGcm9tU3R5bGVQcm9wcyAmJiAodHJhbnNGcm9tU3R5bGVQcm9wcyA9IHRyYW5zRnJvbVByb3BzLnN0eWxlID0ge30pO1xuICAgICAgICB2YXIgc3R5bGVLZXlzID0ga2V5cyhzdHlsZU9wdCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHN0eWxlS2V5c1tpXTtcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uU3R5bGVQcm9wc1trZXldKSB7XG4gICAgICAgICAgICB2YXIgZWxWYWwgPSBmcm9tRWxTdHlsZVtrZXldO1xuICAgICAgICAgICAgdHJhbnNGcm9tU3R5bGVQcm9wc1trZXldID0gZWxWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc05vblN0eWxlVHJhbnNpdGlvbkVuYWJsZWQob3B0VmFsLCBlbFZhbCkge1xuICAvLyBUaGUgc2FtZSBhcyBgY2hlY2tOb25TdHlsZVRhbnNpdGlvblJlZmVyYC5cbiAgcmV0dXJuICFpc0FycmF5TGlrZShvcHRWYWwpID8gb3B0VmFsICE9IG51bGwgJiYgaXNGaW5pdGUob3B0VmFsKSA6IG9wdFZhbCAhPT0gZWxWYWw7XG59XG52YXIgY2hlY2tUcmFuc2Zvcm1Qcm9wUmVmZXI7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBjaGVja1RyYW5zZm9ybVByb3BSZWZlciA9IGZ1bmN0aW9uIChrZXksIHVzZWRJbikge1xuICAgIGlmICghaGFzT3duKFRSQU5TRk9STV9QUk9QU19NQVAsIGtleSkpIHtcbiAgICAgIHdhcm4oJ1Byb3AgYCcgKyBrZXkgKyAnYCBpcyBub3QgYSBwZXJtaXR0ZWQgaW4gYCcgKyB1c2VkSW4gKyAnYC4gJyArICdPbmx5IGAnICsga2V5cyhUUkFOU0ZPUk1fUFJPUFNfTUFQKS5qb2luKCdgLCBgJykgKyAnYCBhcmUgcGVybWl0dGVkLicpO1xuICAgIH1cbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///57625\n")},78536:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   f: () => (/* binding */ updateCenterAndZoom)\n/* harmony export */ });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nfunction getCenterCoord(view, point) {\n  // Use projected coord as center because it\'s linear.\n  return view.pointToProjected ? view.pointToProjected(point) : view.pointToData(point);\n}\nfunction updateCenterAndZoom(view, payload, zoomLimit, api) {\n  var previousZoom = view.getZoom();\n  var center = view.getCenter();\n  var zoom = payload.zoom;\n  var point = view.projectedToPoint ? view.projectedToPoint(center) : view.dataToPoint(center);\n  if (payload.dx != null && payload.dy != null) {\n    point[0] -= payload.dx;\n    point[1] -= payload.dy;\n    view.setCenter(getCenterCoord(view, point), api);\n  }\n  if (zoom != null) {\n    if (zoomLimit) {\n      var zoomMin = zoomLimit.min || 0;\n      var zoomMax = zoomLimit.max || Infinity;\n      zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;\n    }\n    // Zoom on given point(originX, originY)\n    view.scaleX *= zoom;\n    view.scaleY *= zoom;\n    var fixX = (payload.originX - view.x) * (zoom - 1);\n    var fixY = (payload.originY - view.y) * (zoom - 1);\n    view.x -= fixX;\n    view.y -= fixY;\n    view.updateTransform();\n    // Get the new center\n    view.setCenter(getCenterCoord(view, point), api);\n    view.setZoom(zoom * previousZoom);\n  }\n  return {\n    center: view.getCenter(),\n    zoom: view.getZoom()\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg1MzYuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9hY3Rpb24vcm9hbUhlbHBlci5qcz8yZjUyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuZnVuY3Rpb24gZ2V0Q2VudGVyQ29vcmQodmlldywgcG9pbnQpIHtcbiAgLy8gVXNlIHByb2plY3RlZCBjb29yZCBhcyBjZW50ZXIgYmVjYXVzZSBpdCdzIGxpbmVhci5cbiAgcmV0dXJuIHZpZXcucG9pbnRUb1Byb2plY3RlZCA/IHZpZXcucG9pbnRUb1Byb2plY3RlZChwb2ludCkgOiB2aWV3LnBvaW50VG9EYXRhKHBvaW50KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVDZW50ZXJBbmRab29tKHZpZXcsIHBheWxvYWQsIHpvb21MaW1pdCwgYXBpKSB7XG4gIHZhciBwcmV2aW91c1pvb20gPSB2aWV3LmdldFpvb20oKTtcbiAgdmFyIGNlbnRlciA9IHZpZXcuZ2V0Q2VudGVyKCk7XG4gIHZhciB6b29tID0gcGF5bG9hZC56b29tO1xuICB2YXIgcG9pbnQgPSB2aWV3LnByb2plY3RlZFRvUG9pbnQgPyB2aWV3LnByb2plY3RlZFRvUG9pbnQoY2VudGVyKSA6IHZpZXcuZGF0YVRvUG9pbnQoY2VudGVyKTtcbiAgaWYgKHBheWxvYWQuZHggIT0gbnVsbCAmJiBwYXlsb2FkLmR5ICE9IG51bGwpIHtcbiAgICBwb2ludFswXSAtPSBwYXlsb2FkLmR4O1xuICAgIHBvaW50WzFdIC09IHBheWxvYWQuZHk7XG4gICAgdmlldy5zZXRDZW50ZXIoZ2V0Q2VudGVyQ29vcmQodmlldywgcG9pbnQpLCBhcGkpO1xuICB9XG4gIGlmICh6b29tICE9IG51bGwpIHtcbiAgICBpZiAoem9vbUxpbWl0KSB7XG4gICAgICB2YXIgem9vbU1pbiA9IHpvb21MaW1pdC5taW4gfHwgMDtcbiAgICAgIHZhciB6b29tTWF4ID0gem9vbUxpbWl0Lm1heCB8fCBJbmZpbml0eTtcbiAgICAgIHpvb20gPSBNYXRoLm1heChNYXRoLm1pbihwcmV2aW91c1pvb20gKiB6b29tLCB6b29tTWF4KSwgem9vbU1pbikgLyBwcmV2aW91c1pvb207XG4gICAgfVxuICAgIC8vIFpvb20gb24gZ2l2ZW4gcG9pbnQob3JpZ2luWCwgb3JpZ2luWSlcbiAgICB2aWV3LnNjYWxlWCAqPSB6b29tO1xuICAgIHZpZXcuc2NhbGVZICo9IHpvb207XG4gICAgdmFyIGZpeFggPSAocGF5bG9hZC5vcmlnaW5YIC0gdmlldy54KSAqICh6b29tIC0gMSk7XG4gICAgdmFyIGZpeFkgPSAocGF5bG9hZC5vcmlnaW5ZIC0gdmlldy55KSAqICh6b29tIC0gMSk7XG4gICAgdmlldy54IC09IGZpeFg7XG4gICAgdmlldy55IC09IGZpeFk7XG4gICAgdmlldy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAvLyBHZXQgdGhlIG5ldyBjZW50ZXJcbiAgICB2aWV3LnNldENlbnRlcihnZXRDZW50ZXJDb29yZCh2aWV3LCBwb2ludCksIGFwaSk7XG4gICAgdmlldy5zZXRab29tKHpvb20gKiBwcmV2aW91c1pvb20pO1xuICB9XG4gIHJldHVybiB7XG4gICAgY2VudGVyOiB2aWV3LmdldENlbnRlcigpLFxuICAgIHpvb206IHZpZXcuZ2V0Wm9vbSgpXG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///78536\n')},92606:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ stopPreviousKeyframeAnimationAndRestore),\n/* harmony export */   L: () => (/* binding */ applyKeyframeAnimation)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _customGraphicTransition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(57625);\n/* harmony import */ var _basicTransition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5638);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar getStateToRestore = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nvar KEYFRAME_EXCLUDE_KEYS = ['percent', 'easing', 'shape', 'style', 'extra'];\n/**\r\n * Stop previous keyframe animation and restore the attributes.\r\n * Avoid new keyframe animation starts with wrong internal state when the percent: 0 is not set.\r\n */\nfunction stopPreviousKeyframeAnimationAndRestore(el) {\n  // Stop previous keyframe animation.\n  el.stopAnimation('keyframe');\n  // Restore\n  el.attr(getStateToRestore(el));\n}\nfunction applyKeyframeAnimation(el, animationOpts, animatableModel) {\n  if (!animatableModel.isAnimationEnabled() || !animationOpts) {\n    return;\n  }\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(animationOpts)) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(animationOpts, function (singleAnimationOpts) {\n      applyKeyframeAnimation(el, singleAnimationOpts, animatableModel);\n    });\n    return;\n  }\n  var keyframes = animationOpts.keyframes;\n  var duration = animationOpts.duration;\n  if (animatableModel && duration == null) {\n    // Default to use duration of config.\n    // NOTE: animation config from payload will be ignored because they are mainly for transitions.\n    var config = (0,_basicTransition_js__WEBPACK_IMPORTED_MODULE_2__/* .getAnimationConfig */ .Jw)('enter', animatableModel, 0);\n    duration = config && config.duration;\n  }\n  if (!keyframes || !duration) {\n    return;\n  }\n  var stateToRestore = getStateToRestore(el);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(_customGraphicTransition_js__WEBPACK_IMPORTED_MODULE_3__/* .ELEMENT_ANIMATABLE_PROPS */ .rd, function (targetPropName) {\n    if (targetPropName && !el[targetPropName]) {\n      return;\n    }\n    var animator;\n    var endFrameIsSet = false;\n    // Sort keyframes by percent.\n    keyframes.sort(function (a, b) {\n      return a.percent - b.percent;\n    });\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(keyframes, function (kf) {\n      // Stop current animation.\n      var animators = el.animators;\n      var kfValues = targetPropName ? kf[targetPropName] : kf;\n      if (false) {}\n      if (!kfValues) {\n        return;\n      }\n      var propKeys = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.keys)(kfValues);\n      if (!targetPropName) {\n        // PENDING performance?\n        propKeys = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.filter)(propKeys, function (key) {\n          return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.indexOf)(KEYFRAME_EXCLUDE_KEYS, key) < 0;\n        });\n      }\n      if (!propKeys.length) {\n        return;\n      }\n      if (!animator) {\n        animator = el.animate(targetPropName, animationOpts.loop, true);\n        animator.scope = 'keyframe';\n      }\n      for (var i = 0; i < animators.length; i++) {\n        // Stop all other animation that is not keyframe.\n        if (animators[i] !== animator && animators[i].targetName === animator.targetName) {\n          animators[i].stopTracks(propKeys);\n        }\n      }\n      targetPropName && (stateToRestore[targetPropName] = stateToRestore[targetPropName] || {});\n      var savedTarget = targetPropName ? stateToRestore[targetPropName] : stateToRestore;\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(propKeys, function (key) {\n        // Save original value.\n        savedTarget[key] = ((targetPropName ? el[targetPropName] : el) || {})[key];\n      });\n      animator.whenWithKeys(duration * kf.percent, kfValues, propKeys, kf.easing);\n    });\n    if (!animator) {\n      return;\n    }\n    if (false) {}\n    animator.delay(animationOpts.delay || 0).duration(duration).start(animationOpts.easing);\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI2MDYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvYW5pbWF0aW9uL2N1c3RvbUdyYXBoaWNLZXlmcmFtZUFuaW1hdGlvbi5qcz9hZjQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsga2V5cywgZmlsdGVyLCBlYWNoLCBpc0FycmF5LCBpbmRleE9mIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IEVMRU1FTlRfQU5JTUFUQUJMRV9QUk9QUyB9IGZyb20gJy4vY3VzdG9tR3JhcGhpY1RyYW5zaXRpb24uanMnO1xuaW1wb3J0IHsgZ2V0QW5pbWF0aW9uQ29uZmlnIH0gZnJvbSAnLi9iYXNpY1RyYW5zaXRpb24uanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uL3V0aWwvbG9nLmpzJztcbmltcG9ydCB7IG1ha2VJbm5lciB9IGZyb20gJy4uL3V0aWwvbW9kZWwuanMnO1xudmFyIGdldFN0YXRlVG9SZXN0b3JlID0gbWFrZUlubmVyKCk7XG52YXIgS0VZRlJBTUVfRVhDTFVERV9LRVlTID0gWydwZXJjZW50JywgJ2Vhc2luZycsICdzaGFwZScsICdzdHlsZScsICdleHRyYSddO1xuLyoqXHJcbiAqIFN0b3AgcHJldmlvdXMga2V5ZnJhbWUgYW5pbWF0aW9uIGFuZCByZXN0b3JlIHRoZSBhdHRyaWJ1dGVzLlxyXG4gKiBBdm9pZCBuZXcga2V5ZnJhbWUgYW5pbWF0aW9uIHN0YXJ0cyB3aXRoIHdyb25nIGludGVybmFsIHN0YXRlIHdoZW4gdGhlIHBlcmNlbnQ6IDAgaXMgbm90IHNldC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcFByZXZpb3VzS2V5ZnJhbWVBbmltYXRpb25BbmRSZXN0b3JlKGVsKSB7XG4gIC8vIFN0b3AgcHJldmlvdXMga2V5ZnJhbWUgYW5pbWF0aW9uLlxuICBlbC5zdG9wQW5pbWF0aW9uKCdrZXlmcmFtZScpO1xuICAvLyBSZXN0b3JlXG4gIGVsLmF0dHIoZ2V0U3RhdGVUb1Jlc3RvcmUoZWwpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUtleWZyYW1lQW5pbWF0aW9uKGVsLCBhbmltYXRpb25PcHRzLCBhbmltYXRhYmxlTW9kZWwpIHtcbiAgaWYgKCFhbmltYXRhYmxlTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCkgfHwgIWFuaW1hdGlvbk9wdHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzQXJyYXkoYW5pbWF0aW9uT3B0cykpIHtcbiAgICBlYWNoKGFuaW1hdGlvbk9wdHMsIGZ1bmN0aW9uIChzaW5nbGVBbmltYXRpb25PcHRzKSB7XG4gICAgICBhcHBseUtleWZyYW1lQW5pbWF0aW9uKGVsLCBzaW5nbGVBbmltYXRpb25PcHRzLCBhbmltYXRhYmxlTW9kZWwpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIga2V5ZnJhbWVzID0gYW5pbWF0aW9uT3B0cy5rZXlmcmFtZXM7XG4gIHZhciBkdXJhdGlvbiA9IGFuaW1hdGlvbk9wdHMuZHVyYXRpb247XG4gIGlmIChhbmltYXRhYmxlTW9kZWwgJiYgZHVyYXRpb24gPT0gbnVsbCkge1xuICAgIC8vIERlZmF1bHQgdG8gdXNlIGR1cmF0aW9uIG9mIGNvbmZpZy5cbiAgICAvLyBOT1RFOiBhbmltYXRpb24gY29uZmlnIGZyb20gcGF5bG9hZCB3aWxsIGJlIGlnbm9yZWQgYmVjYXVzZSB0aGV5IGFyZSBtYWlubHkgZm9yIHRyYW5zaXRpb25zLlxuICAgIHZhciBjb25maWcgPSBnZXRBbmltYXRpb25Db25maWcoJ2VudGVyJywgYW5pbWF0YWJsZU1vZGVsLCAwKTtcbiAgICBkdXJhdGlvbiA9IGNvbmZpZyAmJiBjb25maWcuZHVyYXRpb247XG4gIH1cbiAgaWYgKCFrZXlmcmFtZXMgfHwgIWR1cmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzdGF0ZVRvUmVzdG9yZSA9IGdldFN0YXRlVG9SZXN0b3JlKGVsKTtcbiAgZWFjaChFTEVNRU5UX0FOSU1BVEFCTEVfUFJPUFMsIGZ1bmN0aW9uICh0YXJnZXRQcm9wTmFtZSkge1xuICAgIGlmICh0YXJnZXRQcm9wTmFtZSAmJiAhZWxbdGFyZ2V0UHJvcE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBhbmltYXRvcjtcbiAgICB2YXIgZW5kRnJhbWVJc1NldCA9IGZhbHNlO1xuICAgIC8vIFNvcnQga2V5ZnJhbWVzIGJ5IHBlcmNlbnQuXG4gICAga2V5ZnJhbWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLnBlcmNlbnQgLSBiLnBlcmNlbnQ7XG4gICAgfSk7XG4gICAgZWFjaChrZXlmcmFtZXMsIGZ1bmN0aW9uIChrZikge1xuICAgICAgLy8gU3RvcCBjdXJyZW50IGFuaW1hdGlvbi5cbiAgICAgIHZhciBhbmltYXRvcnMgPSBlbC5hbmltYXRvcnM7XG4gICAgICB2YXIga2ZWYWx1ZXMgPSB0YXJnZXRQcm9wTmFtZSA/IGtmW3RhcmdldFByb3BOYW1lXSA6IGtmO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGtmLnBlcmNlbnQgPj0gMSkge1xuICAgICAgICAgIGVuZEZyYW1lSXNTZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWtmVmFsdWVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wS2V5cyA9IGtleXMoa2ZWYWx1ZXMpO1xuICAgICAgaWYgKCF0YXJnZXRQcm9wTmFtZSkge1xuICAgICAgICAvLyBQRU5ESU5HIHBlcmZvcm1hbmNlP1xuICAgICAgICBwcm9wS2V5cyA9IGZpbHRlcihwcm9wS2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBpbmRleE9mKEtFWUZSQU1FX0VYQ0xVREVfS0VZUywga2V5KSA8IDA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFwcm9wS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFhbmltYXRvcikge1xuICAgICAgICBhbmltYXRvciA9IGVsLmFuaW1hdGUodGFyZ2V0UHJvcE5hbWUsIGFuaW1hdGlvbk9wdHMubG9vcCwgdHJ1ZSk7XG4gICAgICAgIGFuaW1hdG9yLnNjb3BlID0gJ2tleWZyYW1lJztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFN0b3AgYWxsIG90aGVyIGFuaW1hdGlvbiB0aGF0IGlzIG5vdCBrZXlmcmFtZS5cbiAgICAgICAgaWYgKGFuaW1hdG9yc1tpXSAhPT0gYW5pbWF0b3IgJiYgYW5pbWF0b3JzW2ldLnRhcmdldE5hbWUgPT09IGFuaW1hdG9yLnRhcmdldE5hbWUpIHtcbiAgICAgICAgICBhbmltYXRvcnNbaV0uc3RvcFRyYWNrcyhwcm9wS2V5cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRhcmdldFByb3BOYW1lICYmIChzdGF0ZVRvUmVzdG9yZVt0YXJnZXRQcm9wTmFtZV0gPSBzdGF0ZVRvUmVzdG9yZVt0YXJnZXRQcm9wTmFtZV0gfHwge30pO1xuICAgICAgdmFyIHNhdmVkVGFyZ2V0ID0gdGFyZ2V0UHJvcE5hbWUgPyBzdGF0ZVRvUmVzdG9yZVt0YXJnZXRQcm9wTmFtZV0gOiBzdGF0ZVRvUmVzdG9yZTtcbiAgICAgIGVhY2gocHJvcEtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy8gU2F2ZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgICAgc2F2ZWRUYXJnZXRba2V5XSA9ICgodGFyZ2V0UHJvcE5hbWUgPyBlbFt0YXJnZXRQcm9wTmFtZV0gOiBlbCkgfHwge30pW2tleV07XG4gICAgICB9KTtcbiAgICAgIGFuaW1hdG9yLndoZW5XaXRoS2V5cyhkdXJhdGlvbiAqIGtmLnBlcmNlbnQsIGtmVmFsdWVzLCBwcm9wS2V5cywga2YuZWFzaW5nKTtcbiAgICB9KTtcbiAgICBpZiAoIWFuaW1hdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWVuZEZyYW1lSXNTZXQpIHtcbiAgICAgICAgd2FybignRW5kIGZyYW1lIHdpdGggcGVyY2VudDogMSBpcyBtaXNzaW5nIGluIHRoZSBrZXlmcmFtZUFuaW1hdGlvbi4nLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYW5pbWF0b3IuZGVsYXkoYW5pbWF0aW9uT3B0cy5kZWxheSB8fCAwKS5kdXJhdGlvbihkdXJhdGlvbikuc3RhcnQoYW5pbWF0aW9uT3B0cy5lYXNpbmcpO1xuICB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///92606\n")}}]);