"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[5577],{3087:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Y: () => (/* binding */ use)\n/* harmony export */ });\n/* harmony import */ var _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95383);\n/* harmony import */ var _view_Component_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(59109);\n/* harmony import */ var _view_Chart_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6666);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15915);\n/* harmony import */ var _model_Series_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(47355);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(98026);\n/* harmony import */ var _core_impl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13976);\n/* harmony import */ var zrender_lib_zrender_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(33572);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nvar extensions = [];\nvar extensionRegisters = {\n  registerPreprocessor: _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__/* .registerPreprocessor */ .lP,\n  registerProcessor: _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__/* .registerProcessor */ .qg,\n  registerPostInit: _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__/* .registerPostInit */ .cf,\n  registerPostUpdate: _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__/* .registerPostUpdate */ .tb,\n  registerUpdateLifecycle: _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__/* .registerUpdateLifecycle */ .xV,\n  registerAction: _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__/* .registerAction */ .OH,\n  registerCoordinateSystem: _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__/* .registerCoordinateSystem */ .pX,\n  registerLayout: _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__/* .registerLayout */ .Oh,\n  registerVisual: _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__/* .registerVisual */ .AF,\n  registerTransform: _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__/* .registerTransform */ .iY,\n  registerLoading: _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__/* .registerLoading */ .Ej,\n  registerMap: _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__/* .registerMap */ .mz,\n  registerImpl: _core_impl_js__WEBPACK_IMPORTED_MODULE_1__/* .registerImpl */ .m,\n  PRIORITY: _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__/* .PRIORITY */ .FQ,\n  ComponentModel: _model_Component_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A,\n  ComponentView: _view_Component_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A,\n  SeriesModel: _model_Series_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A,\n  ChartView: _view_Chart_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A,\n  // TODO Use ComponentModel and SeriesModel instead of Constructor\n  registerComponentModel: function (ComponentModelClass) {\n    _model_Component_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.registerClass(ComponentModelClass);\n  },\n  registerComponentView: function (ComponentViewClass) {\n    _view_Component_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.registerClass(ComponentViewClass);\n  },\n  registerSeriesModel: function (SeriesModelClass) {\n    _model_Series_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.registerClass(SeriesModelClass);\n  },\n  registerChartView: function (ChartViewClass) {\n    _view_Chart_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.registerClass(ChartViewClass);\n  },\n  registerSubTypeDefaulter: function (componentType, defaulter) {\n    _model_Component_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.registerSubTypeDefaulter(componentType, defaulter);\n  },\n  registerPainter: function (painterType, PainterCtor) {\n    (0,zrender_lib_zrender_js__WEBPACK_IMPORTED_MODULE_6__.registerPainter)(painterType, PainterCtor);\n  }\n};\nfunction use(ext) {\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_7__.isArray)(ext)) {\n    // use([ChartLine, ChartBar]);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_7__.each)(ext, function (singleExt) {\n      use(singleExt);\n    });\n    return;\n  }\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_7__.indexOf)(extensions, ext) >= 0) {\n    return;\n  }\n  extensions.push(ext);\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_7__.isFunction)(ext)) {\n    ext = {\n      install: ext\n    };\n  }\n  ext.install(extensionRegisters);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA4Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZXh0ZW5zaW9uLmpzPzQ1MzMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyByZWdpc3RlclByZXByb2Nlc3NvciwgcmVnaXN0ZXJQcm9jZXNzb3IsIHJlZ2lzdGVyUG9zdEluaXQsIHJlZ2lzdGVyUG9zdFVwZGF0ZSwgcmVnaXN0ZXJBY3Rpb24sIHJlZ2lzdGVyQ29vcmRpbmF0ZVN5c3RlbSwgcmVnaXN0ZXJMYXlvdXQsIHJlZ2lzdGVyVmlzdWFsLCByZWdpc3RlclRyYW5zZm9ybSwgcmVnaXN0ZXJMb2FkaW5nLCByZWdpc3Rlck1hcCwgcmVnaXN0ZXJVcGRhdGVMaWZlY3ljbGUsIFBSSU9SSVRZIH0gZnJvbSAnLi9jb3JlL2VjaGFydHMuanMnO1xuaW1wb3J0IENvbXBvbmVudFZpZXcgZnJvbSAnLi92aWV3L0NvbXBvbmVudC5qcyc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4vdmlldy9DaGFydC5qcyc7XG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi9tb2RlbC9Db21wb25lbnQuanMnO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4vbW9kZWwvU2VyaWVzLmpzJztcbmltcG9ydCB7IGlzRnVuY3Rpb24sIGluZGV4T2YsIGlzQXJyYXksIGVhY2ggfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgcmVnaXN0ZXJJbXBsIH0gZnJvbSAnLi9jb3JlL2ltcGwuanMnO1xuaW1wb3J0IHsgcmVnaXN0ZXJQYWludGVyIH0gZnJvbSAnenJlbmRlci9saWIvenJlbmRlci5qcyc7XG52YXIgZXh0ZW5zaW9ucyA9IFtdO1xudmFyIGV4dGVuc2lvblJlZ2lzdGVycyA9IHtcbiAgcmVnaXN0ZXJQcmVwcm9jZXNzb3I6IHJlZ2lzdGVyUHJlcHJvY2Vzc29yLFxuICByZWdpc3RlclByb2Nlc3NvcjogcmVnaXN0ZXJQcm9jZXNzb3IsXG4gIHJlZ2lzdGVyUG9zdEluaXQ6IHJlZ2lzdGVyUG9zdEluaXQsXG4gIHJlZ2lzdGVyUG9zdFVwZGF0ZTogcmVnaXN0ZXJQb3N0VXBkYXRlLFxuICByZWdpc3RlclVwZGF0ZUxpZmVjeWNsZTogcmVnaXN0ZXJVcGRhdGVMaWZlY3ljbGUsXG4gIHJlZ2lzdGVyQWN0aW9uOiByZWdpc3RlckFjdGlvbixcbiAgcmVnaXN0ZXJDb29yZGluYXRlU3lzdGVtOiByZWdpc3RlckNvb3JkaW5hdGVTeXN0ZW0sXG4gIHJlZ2lzdGVyTGF5b3V0OiByZWdpc3RlckxheW91dCxcbiAgcmVnaXN0ZXJWaXN1YWw6IHJlZ2lzdGVyVmlzdWFsLFxuICByZWdpc3RlclRyYW5zZm9ybTogcmVnaXN0ZXJUcmFuc2Zvcm0sXG4gIHJlZ2lzdGVyTG9hZGluZzogcmVnaXN0ZXJMb2FkaW5nLFxuICByZWdpc3Rlck1hcDogcmVnaXN0ZXJNYXAsXG4gIHJlZ2lzdGVySW1wbDogcmVnaXN0ZXJJbXBsLFxuICBQUklPUklUWTogUFJJT1JJVFksXG4gIENvbXBvbmVudE1vZGVsOiBDb21wb25lbnRNb2RlbCxcbiAgQ29tcG9uZW50VmlldzogQ29tcG9uZW50VmlldyxcbiAgU2VyaWVzTW9kZWw6IFNlcmllc01vZGVsLFxuICBDaGFydFZpZXc6IENoYXJ0VmlldyxcbiAgLy8gVE9ETyBVc2UgQ29tcG9uZW50TW9kZWwgYW5kIFNlcmllc01vZGVsIGluc3RlYWQgb2YgQ29uc3RydWN0b3JcbiAgcmVnaXN0ZXJDb21wb25lbnRNb2RlbDogZnVuY3Rpb24gKENvbXBvbmVudE1vZGVsQ2xhc3MpIHtcbiAgICBDb21wb25lbnRNb2RlbC5yZWdpc3RlckNsYXNzKENvbXBvbmVudE1vZGVsQ2xhc3MpO1xuICB9LFxuICByZWdpc3RlckNvbXBvbmVudFZpZXc6IGZ1bmN0aW9uIChDb21wb25lbnRWaWV3Q2xhc3MpIHtcbiAgICBDb21wb25lbnRWaWV3LnJlZ2lzdGVyQ2xhc3MoQ29tcG9uZW50Vmlld0NsYXNzKTtcbiAgfSxcbiAgcmVnaXN0ZXJTZXJpZXNNb2RlbDogZnVuY3Rpb24gKFNlcmllc01vZGVsQ2xhc3MpIHtcbiAgICBTZXJpZXNNb2RlbC5yZWdpc3RlckNsYXNzKFNlcmllc01vZGVsQ2xhc3MpO1xuICB9LFxuICByZWdpc3RlckNoYXJ0VmlldzogZnVuY3Rpb24gKENoYXJ0Vmlld0NsYXNzKSB7XG4gICAgQ2hhcnRWaWV3LnJlZ2lzdGVyQ2xhc3MoQ2hhcnRWaWV3Q2xhc3MpO1xuICB9LFxuICByZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXI6IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBkZWZhdWx0ZXIpIHtcbiAgICBDb21wb25lbnRNb2RlbC5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIoY29tcG9uZW50VHlwZSwgZGVmYXVsdGVyKTtcbiAgfSxcbiAgcmVnaXN0ZXJQYWludGVyOiBmdW5jdGlvbiAocGFpbnRlclR5cGUsIFBhaW50ZXJDdG9yKSB7XG4gICAgcmVnaXN0ZXJQYWludGVyKHBhaW50ZXJUeXBlLCBQYWludGVyQ3Rvcik7XG4gIH1cbn07XG5leHBvcnQgZnVuY3Rpb24gdXNlKGV4dCkge1xuICBpZiAoaXNBcnJheShleHQpKSB7XG4gICAgLy8gdXNlKFtDaGFydExpbmUsIENoYXJ0QmFyXSk7XG4gICAgZWFjaChleHQsIGZ1bmN0aW9uIChzaW5nbGVFeHQpIHtcbiAgICAgIHVzZShzaW5nbGVFeHQpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5kZXhPZihleHRlbnNpb25zLCBleHQpID49IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZXh0ZW5zaW9ucy5wdXNoKGV4dCk7XG4gIGlmIChpc0Z1bmN0aW9uKGV4dCkpIHtcbiAgICBleHQgPSB7XG4gICAgICBpbnN0YWxsOiBleHRcbiAgICB9O1xuICB9XG4gIGV4dC5pbnN0YWxsKGV4dGVuc2lvblJlZ2lzdGVycyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3087\n')},6006:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _model_Model_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(43172);\n/* harmony import */ var _DataDiffer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(16563);\n/* harmony import */ var _helper_dataProvider_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58267);\n/* harmony import */ var _helper_dimensionHelper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(29756);\n/* harmony import */ var _SeriesDimensionDefine_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22759);\n/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(13430);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(48170);\n/* harmony import */ var _util_innerStore_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(69622);\n/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34310);\n/* harmony import */ var _DataStore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70250);\n/* harmony import */ var _helper_SeriesDataSchema_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73632);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/* global Int32Array */\n\n\n\n\n\n\n\n\n\n\n\n\nvar isObject = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject;\nvar map = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map;\nvar CtorInt32Array = typeof Int32Array === 'undefined' ? Array : Int32Array;\n// Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird update animation.\nvar ID_PREFIX = 'e\\0\\0';\nvar INDEX_NOT_FOUND = -1;\n// type SeriesDimensionIndex = DimensionIndex;\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_dimSummary', 'userOutput', '_rawData', '_dimValueGetter', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_approximateExtent'];\n// -----------------------------\n// Internal method declarations:\n// -----------------------------\nvar prepareInvertedIndex;\nvar getId;\nvar getIdNameFromStore;\nvar normalizeDimensions;\nvar transferProperties;\nvar cloneListForMapAndSample;\nvar makeIdFromName;\nvar SeriesData = /** @class */function () {\n  /**\r\n   * @param dimensionsInput.dimensions\r\n   *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\r\n   *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\r\n   */\n  function SeriesData(dimensionsInput, hostModel) {\n    this.type = 'list';\n    this._dimOmitted = false;\n    this._nameList = [];\n    this._idList = [];\n    // Models of data option is stored sparse for optimizing memory cost\n    // Never used yet (not used yet).\n    // private _optionModels: Model[] = [];\n    // Global visual properties after visual coding\n    this._visual = {};\n    // Global layout properties.\n    this._layout = {};\n    // Item visual properties after visual coding\n    this._itemVisuals = [];\n    // Item layout properties after layout\n    this._itemLayouts = [];\n    // Graphic elements\n    this._graphicEls = [];\n    // key: dim, value: extent\n    this._approximateExtent = {};\n    this._calculationInfo = {};\n    // Having detected that there is data item is non primitive type\n    // (in type `OptionDataItemObject`).\n    // Like `data: [ { value: xx, itemStyle: {...} }, ...]`\n    // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.\n    this.hasItemOption = false;\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'minmaxDownSample', 'lttbDownSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'minmaxDownSample', 'lttbDownSample'];\n    var dimensions;\n    var assignStoreDimIdx = false;\n    if ((0,_helper_SeriesDataSchema_js__WEBPACK_IMPORTED_MODULE_1__/* .isSeriesDataSchema */ .fg)(dimensionsInput)) {\n      dimensions = dimensionsInput.dimensions;\n      this._dimOmitted = dimensionsInput.isDimensionOmitted();\n      this._schema = dimensionsInput;\n    } else {\n      assignStoreDimIdx = true;\n      dimensions = dimensionsInput;\n    }\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n    var needsHasOwn = false;\n    var emptyObj = {};\n    for (var i = 0; i < dimensions.length; i++) {\n      // Use the original dimensions[i], where other flag props may exists.\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString(dimInfoInput) ? new _SeriesDimensionDefine_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof _SeriesDimensionDefine_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A) ? new _SeriesDimensionDefine_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A(dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n      if (emptyObj[dimensionName] != null) {\n        needsHasOwn = true;\n      }\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n      }\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n      }\n      if (false) {}\n      if (assignStoreDimIdx) {\n        dimensionInfo.storeDimIndex = i;\n      }\n    }\n    this.dimensions = dimensionNames;\n    this._dimInfos = dimensionInfos;\n    this._initGetDimensionInfo(needsHasOwn);\n    this.hostModel = hostModel;\n    this._invertedIndicesMap = invertedIndicesMap;\n    if (this._dimOmitted) {\n      var dimIdxToName_1 = this._dimIdxToName = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap();\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(dimensionNames, function (dimName) {\n        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);\n      });\n    }\n  }\n  /**\r\n   *\r\n   * Get concrete dimension name by dimension name or dimension index.\r\n   * If input a dimension name, do not validate whether the dimension name exits.\r\n   *\r\n   * @caution\r\n   * @param dim Must make sure the dimension is `SeriesDimensionLoose`.\r\n   * Because only those dimensions will have auto-generated dimension names if not\r\n   * have a user-specified name, and other dimensions will get a return of null/undefined.\r\n   *\r\n   * @notice Because of this reason, should better use `getDimensionIndex` instead, for examples:\r\n   * ```js\r\n   * const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);\r\n   * ```\r\n   *\r\n   * @return Concrete dim name.\r\n   */\n  SeriesData.prototype.getDimension = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n    if (dimIdx == null) {\n      return dim;\n    }\n    dimIdx = dim;\n    if (!this._dimOmitted) {\n      return this.dimensions[dimIdx];\n    }\n    // Retrieve from series dimension definition because it probably contains\n    // generated dimension name (like 'x', 'y').\n    var dimName = this._dimIdxToName.get(dimIdx);\n    if (dimName != null) {\n      return dimName;\n    }\n    var sourceDimDef = this._schema.getSourceDimension(dimIdx);\n    if (sourceDimDef) {\n      return sourceDimDef.name;\n    }\n  };\n  /**\r\n   * Get dimension index in data store. Return -1 if not found.\r\n   * Can be used to index value from getRawValue.\r\n   */\n  SeriesData.prototype.getDimensionIndex = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n    if (dimIdx != null) {\n      return dimIdx;\n    }\n    if (dim == null) {\n      return -1;\n    }\n    var dimInfo = this._getDimInfo(dim);\n    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;\n  };\n  /**\r\n   * The meanings of the input parameter `dim`:\r\n   *\r\n   * + If dim is a number (e.g., `1`), it means the index of the dimension.\r\n   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\r\n   * + If dim is a number-like string (e.g., `\"1\"`):\r\n   *     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,\r\n   *        it means that concrete name.\r\n   *     + If not, it will be converted to a number, which means the index of the dimension.\r\n   *        (why? because of the backward compatibility. We have been tolerating number-like string in\r\n   *        dimension setting, although now it seems that it is not a good idea.)\r\n   *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\r\n   *     if no dimension name is defined as `\"1\"`.\r\n   * + If dim is a not-number-like string, it means the concrete dim name.\r\n   *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\r\n   *   or customized in `dimensions` property of option like `\"age\"`.\r\n   *\r\n   * @return recognized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).\r\n   */\n  SeriesData.prototype._recognizeDimIndex = function (dim) {\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(dim)\n    // If being a number-like string but not being defined as a dimension name.\n    || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {\n      return +dim;\n    }\n  };\n  SeriesData.prototype._getStoreDimIndex = function (dim) {\n    var dimIdx = this.getDimensionIndex(dim);\n    if (false) {}\n    return dimIdx;\n  };\n  /**\r\n   * Get type and calculation info of particular dimension\r\n   * @param dim\r\n   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\r\n   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\r\n   */\n  SeriesData.prototype.getDimensionInfo = function (dim) {\n    // Do not clone, because there may be categories in dimInfo.\n    return this._getDimInfo(this.getDimension(dim));\n  };\n  SeriesData.prototype._initGetDimensionInfo = function (needsHasOwn) {\n    var dimensionInfos = this._dimInfos;\n    this._getDimInfo = needsHasOwn ? function (dimName) {\n      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : undefined;\n    } : function (dimName) {\n      return dimensionInfos[dimName];\n    };\n  };\n  /**\r\n   * concrete dimension name list on coord.\r\n   */\n  SeriesData.prototype.getDimensionsOnCoord = function () {\n    return this._dimSummary.dataDimsOnCoord.slice();\n  };\n  SeriesData.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimSummary;\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n  SeriesData.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n  SeriesData.prototype.getStore = function () {\n    return this._store;\n  };\n  /**\r\n   * Initialize from data\r\n   * @param data source or data or data store.\r\n   * @param nameList The name of a datum is used on data diff and\r\n   *        default label/tooltip.\r\n   *        A name can be specified in encode.itemName,\r\n   *        or dataItem.name (only for series option data),\r\n   *        or provided in nameList from outside.\r\n   */\n  SeriesData.prototype.initData = function (data, nameList, dimValueGetter) {\n    var _this = this;\n    var store;\n    if (data instanceof _DataStore_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .Ay) {\n      store = data;\n    }\n    if (!store) {\n      var dimensions = this.dimensions;\n      var provider = (0,_Source_js__WEBPACK_IMPORTED_MODULE_4__/* .isSourceInstance */ .tP)(data) || zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArrayLike(data) ? new _helper_dataProvider_js__WEBPACK_IMPORTED_MODULE_5__/* .DefaultDataProvider */ .d1(data, dimensions.length) : data;\n      store = new _DataStore_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .Ay();\n      var dimensionInfos = map(dimensions, function (dimName) {\n        return {\n          type: _this._dimInfos[dimName].type,\n          property: dimName\n        };\n      });\n      store.initData(provider, dimensionInfos, dimValueGetter);\n    }\n    this._store = store;\n    // Reset\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n    this._doInit(0, store.count());\n    // Cache summary info for fast visit. See \"dimensionHelper\".\n    // Needs to be initialized after store is prepared.\n    this._dimSummary = (0,_helper_dimensionHelper_js__WEBPACK_IMPORTED_MODULE_6__/* .summarizeDimensions */ .l)(this, this._schema);\n    this.userOutput = this._dimSummary.userOutput;\n  };\n  /**\r\n   * Caution: Can be only called on raw data (before `this._indices` created).\r\n   */\n  SeriesData.prototype.appendData = function (data) {\n    var range = this._store.appendData(data);\n    this._doInit(range[0], range[1]);\n  };\n  /**\r\n   * Caution: Can be only called on raw data (before `this._indices` created).\r\n   * This method does not modify `rawData` (`dataProvider`), but only\r\n   * add values to store.\r\n   *\r\n   * The final count will be increased by `Math.max(values.length, names.length)`.\r\n   *\r\n   * @param values That is the SourceType: 'arrayRows', like\r\n   *        [\r\n   *            [12, 33, 44],\r\n   *            [NaN, 43, 1],\r\n   *            ['-', 'asdf', 0]\r\n   *        ]\r\n   *        Each item is exactly corresponding to a dimension.\r\n   */\n  SeriesData.prototype.appendValues = function (values, names) {\n    var _a = this._store.appendValues(values, names && names.length),\n      start = _a.start,\n      end = _a.end;\n    var shouldMakeIdFromName = this._shouldMakeIdFromName();\n    this._updateOrdinalMeta();\n    if (names) {\n      for (var idx = start; idx < end; idx++) {\n        var sourceIdx = idx - start;\n        this._nameList[idx] = names[sourceIdx];\n        if (shouldMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n  };\n  SeriesData.prototype._updateOrdinalMeta = function () {\n    var store = this._store;\n    var dimensions = this.dimensions;\n    for (var i = 0; i < dimensions.length; i++) {\n      var dimInfo = this._dimInfos[dimensions[i]];\n      if (dimInfo.ordinalMeta) {\n        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);\n      }\n    }\n  };\n  SeriesData.prototype._shouldMakeIdFromName = function () {\n    var provider = this._store.getProvider();\n    return this._idDimIdx == null && provider.getSource().sourceFormat !== _util_types_js__WEBPACK_IMPORTED_MODULE_7__/* .SOURCE_FORMAT_TYPED_ARRAY */ .XO && !provider.fillStorage;\n  };\n  SeriesData.prototype._doInit = function (start, end) {\n    if (start >= end) {\n      return;\n    }\n    var store = this._store;\n    var provider = store.getProvider();\n    this._updateOrdinalMeta();\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var sourceFormat = provider.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_7__/* .SOURCE_FORMAT_ORIGINAL */ .mK;\n    // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // If dataItem is {name: ...} or {id: ...}, it has highest priority.\n    // This kind of ids and names are always stored `_nameList` and `_idList`.\n    if (isFormatOriginal && !provider.pure) {\n      var sharedDataItem = [];\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        var dataItem = provider.getItem(idx, sharedDataItem);\n        if (!this.hasItemOption && (0,_util_model_js__WEBPACK_IMPORTED_MODULE_8__/* .isDataItemOption */ .zu)(dataItem)) {\n          this.hasItemOption = true;\n        }\n        if (dataItem) {\n          var itemName = dataItem.name;\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_8__/* .convertOptionIdName */ .vS)(itemName, null);\n          }\n          var itemId = dataItem.id;\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_8__/* .convertOptionIdName */ .vS)(itemId, null);\n          }\n        }\n      }\n    }\n    if (this._shouldMakeIdFromName()) {\n      for (var idx = start; idx < end; idx++) {\n        makeIdFromName(this, idx);\n      }\n    }\n    prepareInvertedIndex(this);\n  };\n  /**\r\n   * PENDING: In fact currently this function is only used to short-circuit\r\n   * the calling of `scale.unionExtentFromData` when data have been filtered by modules\r\n   * like \"dataZoom\". `scale.unionExtentFromData` is used to calculate data extent for series on\r\n   * an axis, but if a \"axis related data filter module\" is used, the extent of the axis have\r\n   * been fixed and no need to calling `scale.unionExtentFromData` actually.\r\n   * But if we add \"custom data filter\" in future, which is not \"axis related\", this method may\r\n   * be still needed.\r\n   *\r\n   * Optimize for the scenario that data is filtered by a given extent.\r\n   * Consider that if data amount is more than hundreds of thousand,\r\n   * extent calculation will cost more than 10ms and the cache will\r\n   * be erased because of the filtering.\r\n   */\n  SeriesData.prototype.getApproximateExtent = function (dim) {\n    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  /**\r\n   * Calculate extent on a filtered data might be time consuming.\r\n   * Approximate extent is only used for: calculate extent of filtered data outside.\r\n   */\n  SeriesData.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n  SeriesData.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n  SeriesData.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n  /**\r\n   * @return Never be null/undefined. `number` will be converted to string. Because:\r\n   * In most cases, name is used in display, where returning a string is more convenient.\r\n   * In other cases, name is used in query (see `indexOfName`), where we can keep the\r\n   * rule that name `2` equals to name `'2'`.\r\n   */\n  SeriesData.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);\n    }\n    if (name == null) {\n      name = '';\n    }\n    return name;\n  };\n  SeriesData.prototype._getCategory = function (dimIdx, idx) {\n    var ordinal = this._store.get(dimIdx, idx);\n    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);\n    if (ordinalMeta) {\n      return ordinalMeta.categories[ordinal];\n    }\n    return ordinal;\n  };\n  /**\r\n   * @return Never null/undefined. `number` will be converted to string. Because:\r\n   * In all cases having encountered at present, id is used in making diff comparison, which\r\n   * are usually based on hash map. We can keep the rule that the internal id are always string\r\n   * (treat `2` is the same as `'2'`) to make the related logic simple.\r\n   */\n  SeriesData.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n  SeriesData.prototype.count = function () {\n    return this._store.count();\n  };\n  /**\r\n   * Get value. Return NaN if idx is out of range.\r\n   *\r\n   * @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.\r\n   */\n  SeriesData.prototype.get = function (dim, idx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n    if (dimInfo) {\n      return store.get(dimInfo.storeDimIndex, idx);\n    }\n  };\n  /**\r\n   * @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.\r\n   */\n  SeriesData.prototype.getByRawIndex = function (dim, rawIdx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n    if (dimInfo) {\n      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);\n    }\n  };\n  SeriesData.prototype.getIndices = function () {\n    return this._store.getIndices();\n  };\n  SeriesData.prototype.getDataExtent = function (dim) {\n    return this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getSum = function (dim) {\n    return this._store.getSum(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getMedian = function (dim) {\n    return this._store.getMedian(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getValues = function (dimensions, idx) {\n    var _this = this;\n    var store = this._store;\n    return zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray(dimensions) ? store.getValues(map(dimensions, function (dim) {\n      return _this._getStoreDimIndex(dim);\n    }), idx) : store.getValues(dimensions);\n  };\n  /**\r\n   * If value is NaN. Including '-'\r\n   * Only check the coord dimensions.\r\n   */\n  SeriesData.prototype.hasValue = function (idx) {\n    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;\n    for (var i = 0, len = dataDimIndicesOnCoord.length; i < len; i++) {\n      // Ordinal type originally can be string or number.\n      // But when an ordinal type is used on coord, it can\n      // not be string but only number. So we can also use isNaN.\n      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\r\n   * Retrieve the index with given name\r\n   */\n  SeriesData.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this._store.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n    return -1;\n  };\n  SeriesData.prototype.getRawIndex = function (idx) {\n    return this._store.getRawIndex(idx);\n  };\n  SeriesData.prototype.indexOfRawIndex = function (rawIndex) {\n    return this._store.indexOfRawIndex(rawIndex);\n  };\n  /**\r\n   * Only support the dimension which inverted index created.\r\n   * Do not support other cases until required.\r\n   * @param dim concrete dim\r\n   * @param value ordinal index\r\n   * @return rawIndex\r\n   */\n  SeriesData.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n    if (false) {}\n    var rawIndex = invertedIndices && invertedIndices[value];\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n    return rawIndex;\n  };\n  /**\r\n   * Retrieve the index of nearest value\r\n   * @param dim\r\n   * @param value\r\n   * @param [maxDistance=Infinity]\r\n   * @return If and only if multiple indices has\r\n   *         the same value, they are put to the result.\r\n   */\n  SeriesData.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);\n  };\n  SeriesData.prototype.each = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n    // ctxCompat just for compat echarts3\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store.each(dimIndices, fCtx ? zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.bind(cb, fCtx) : cb);\n  };\n  SeriesData.prototype.filterSelf = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n    // ctxCompat just for compat echarts3\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store = this._store.filter(dimIndices, fCtx ? zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.bind(cb, fCtx) : cb);\n    return this;\n  };\n  /**\r\n   * Select data in range. (For optimization of filter)\r\n   * (Manually inline code, support 5 million data filtering in data zoom.)\r\n   */\n  SeriesData.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n    var innerRange = {};\n    var dims = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys(range);\n    var dimIndices = [];\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(dims, function (dim) {\n      var dimIdx = _this._getStoreDimIndex(dim);\n      innerRange[dimIdx] = range[dim];\n      dimIndices.push(dimIdx);\n    });\n    this._store = this._store.selectRange(innerRange);\n    return this;\n  };\n  /* eslint-enable max-len */\n  SeriesData.prototype.mapArray = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n    // ctxCompat just for compat echarts3\n    ctx = ctx || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n  SeriesData.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    // ctxCompat just for compat echarts3\n    var fCtx = ctx || ctxCompat || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.map(dimIndices, fCtx ? zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.bind(cb, fCtx) : cb);\n    return list;\n  };\n  SeriesData.prototype.modify = function (dims, cb, ctx, ctxCompat) {\n    var _this = this;\n    // ctxCompat just for compat echarts3\n    var fCtx = ctx || ctxCompat || this;\n    if (false) {}\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    // If do shallow clone here, if there are too many stacked series,\n    // it still cost lots of memory, because `_store.dimensions` are not shared.\n    // We should consider there probably be shallow clone happen in each series\n    // in consequent filter/map.\n    this._store.modify(dimIndices, fCtx ? zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.bind(cb, fCtx) : cb);\n  };\n  /**\r\n   * Large data down sampling on given dimension\r\n   * @param sampleIndex Sample index for name and id\r\n   */\n  SeriesData.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);\n    return list;\n  };\n  /**\r\n   * Large data down sampling using min-max\r\n   * @param {string} valueDimension\r\n   * @param {number} rate\r\n   */\n  SeriesData.prototype.minmaxDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.minmaxDownSample(this._getStoreDimIndex(valueDimension), rate);\n    return list;\n  };\n  /**\r\n   * Large data down sampling using largest-triangle-three-buckets\r\n   * @param {string} valueDimension\r\n   * @param {number} targetCount\r\n   */\n  SeriesData.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);\n    return list;\n  };\n  SeriesData.prototype.getRawDataItem = function (idx) {\n    return this._store.getRawDataItem(idx);\n  };\n  /**\r\n   * Get model of one data item.\r\n   */\n  // TODO: Type of data item\n  SeriesData.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new _model_Model_js__WEBPACK_IMPORTED_MODULE_9__/* [\"default\"] */ .A(dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n  /**\r\n   * Create a data differ\r\n   */\n  SeriesData.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new _DataDiffer_js__WEBPACK_IMPORTED_MODULE_10__/* [\"default\"] */ .A(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n  /**\r\n   * Get visual property.\r\n   */\n  SeriesData.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n  SeriesData.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n    if (isObject(kvObj)) {\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n  /**\r\n   * Get visual property of single data item\r\n   */\n  // eslint-disable-next-line\n  SeriesData.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n    if (val == null) {\n      // Use global visual property\n      return this.getVisual(key);\n    }\n    return val;\n  };\n  /**\r\n   * If exists visual property of single data item\r\n   */\n  SeriesData.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n  /**\r\n   * Make sure itemVisual property is unique\r\n   */\n  // TODO: use key to save visual to reduce memory.\n  SeriesData.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n    var val = itemVisual[key];\n    if (val == null) {\n      val = this.getVisual(key);\n      // TODO Performance?\n      if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend({}, val);\n      }\n      itemVisual[key] = val;\n    }\n    return val;\n  };\n  // eslint-disable-next-line\n  SeriesData.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n    if (isObject(key)) {\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n  /**\r\n   * Clear itemVisuals and list visual.\r\n   */\n  SeriesData.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n  SeriesData.prototype.setLayout = function (key, val) {\n    isObject(key) ? zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend(this._layout, key) : this._layout[key] = val;\n  };\n  /**\r\n   * Get layout property.\r\n   */\n  SeriesData.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n  /**\r\n   * Get layout of single data item\r\n   */\n  SeriesData.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n  /**\r\n   * Set layout of single data item\r\n   */\n  SeriesData.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n  /**\r\n   * Clear all layout of single data item\r\n   */\n  SeriesData.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n  /**\r\n   * Set graphic element relative to data. It can be set as null\r\n   */\n  SeriesData.prototype.setItemGraphicEl = function (idx, el) {\n    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;\n    (0,_util_innerStore_js__WEBPACK_IMPORTED_MODULE_11__/* .setCommonECData */ .a)(seriesIndex, this.dataType, idx, el);\n    this._graphicEls[idx] = el;\n  };\n  SeriesData.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n  SeriesData.prototype.eachItemGraphicEl = function (cb, context) {\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n  /**\r\n   * Shallow clone a new list except visual and layout properties, and graph elements.\r\n   * New list only change the indices.\r\n   */\n  SeriesData.prototype.cloneShallow = function (list) {\n    if (!list) {\n      list = new SeriesData(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);\n    }\n    transferProperties(list, this);\n    list._store = this._store;\n    return list;\n  };\n  /**\r\n   * Wrap some method to add more feature\r\n   */\n  SeriesData.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n    if (!zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isFunction(originalMethod)) {\n      return;\n    }\n    this.__wrappedMethods = this.__wrappedMethods || [];\n    this.__wrappedMethods.push(methodName);\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.slice(arguments)));\n    };\n  };\n  // ----------------------------------------------------------\n  // A work around for internal method visiting private member.\n  // ----------------------------------------------------------\n  SeriesData.internalField = function () {\n    prepareInvertedIndex = function (data) {\n      var invertedIndicesMap = data._invertedIndicesMap;\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = data._dimInfos[dim];\n        // Currently, only dimensions that has ordinalMeta can create inverted indices.\n        var ordinalMeta = dimInfo.ordinalMeta;\n        var store = data._store;\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);\n          // The default value of TypedArray is 0. To avoid miss\n          // mapping to 0, we should set it as INDEX_NOT_FOUND.\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n          for (var i = 0; i < store.count(); i++) {\n            // Only support the case that all values are distinct.\n            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;\n          }\n        }\n      });\n    };\n    getIdNameFromStore = function (data, dimIdx, idx) {\n      return (0,_util_model_js__WEBPACK_IMPORTED_MODULE_8__/* .convertOptionIdName */ .vS)(data._getCategory(dimIdx, idx), null);\n    };\n    /**\r\n     * @see the comment of `List['getId']`.\r\n     */\n    getId = function (data, rawIndex) {\n      var id = data._idList[rawIndex];\n      if (id == null && data._idDimIdx != null) {\n        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);\n      }\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n      return id;\n    };\n    normalizeDimensions = function (dimensions) {\n      if (!zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n      return dimensions;\n    };\n    /**\r\n     * Data in excludeDimensions is copied, otherwise transferred.\r\n     */\n    cloneListForMapAndSample = function (original) {\n      var list = new SeriesData(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel);\n      // FIXME If needs stackedOn, value may already been stacked\n      transferProperties(list, original);\n      return list;\n    };\n    transferProperties = function (target, source) {\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.clone(source[propName]);\n      });\n      target._calculationInfo = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend({}, source._calculationInfo);\n    };\n    makeIdFromName = function (data, idx) {\n      var nameList = data._nameList;\n      var idList = data._idList;\n      var nameDimIdx = data._nameDimIdx;\n      var idDimIdx = data._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);\n      }\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);\n      }\n      if (id == null && name != null) {\n        var nameRepeatCount = data._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n        idList[idx] = id;\n      }\n    };\n  }();\n  return SeriesData;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SeriesData);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAwNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvU2VyaWVzRGF0YS5qcz8wODMzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuLyogZ2xvYmFsIEludDMyQXJyYXkgKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IE1vZGVsIGZyb20gJy4uL21vZGVsL01vZGVsLmpzJztcbmltcG9ydCBEYXRhRGlmZmVyIGZyb20gJy4vRGF0YURpZmZlci5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0RGF0YVByb3ZpZGVyIH0gZnJvbSAnLi9oZWxwZXIvZGF0YVByb3ZpZGVyLmpzJztcbmltcG9ydCB7IHN1bW1hcml6ZURpbWVuc2lvbnMgfSBmcm9tICcuL2hlbHBlci9kaW1lbnNpb25IZWxwZXIuanMnO1xuaW1wb3J0IFNlcmllc0RpbWVuc2lvbkRlZmluZSBmcm9tICcuL1Nlcmllc0RpbWVuc2lvbkRlZmluZS5qcyc7XG5pbXBvcnQgeyBTT1VSQ0VfRk9STUFUX1RZUEVEX0FSUkFZLCBTT1VSQ0VfRk9STUFUX09SSUdJTkFMIH0gZnJvbSAnLi4vdXRpbC90eXBlcy5qcyc7XG5pbXBvcnQgeyBjb252ZXJ0T3B0aW9uSWROYW1lLCBpc0RhdGFJdGVtT3B0aW9uIH0gZnJvbSAnLi4vdXRpbC9tb2RlbC5qcyc7XG5pbXBvcnQgeyBzZXRDb21tb25FQ0RhdGEgfSBmcm9tICcuLi91dGlsL2lubmVyU3RvcmUuanMnO1xuaW1wb3J0IHsgaXNTb3VyY2VJbnN0YW5jZSB9IGZyb20gJy4vU291cmNlLmpzJztcbmltcG9ydCBEYXRhU3RvcmUgZnJvbSAnLi9EYXRhU3RvcmUuanMnO1xuaW1wb3J0IHsgaXNTZXJpZXNEYXRhU2NoZW1hIH0gZnJvbSAnLi9oZWxwZXIvU2VyaWVzRGF0YVNjaGVtYS5qcyc7XG52YXIgaXNPYmplY3QgPSB6clV0aWwuaXNPYmplY3Q7XG52YXIgbWFwID0genJVdGlsLm1hcDtcbnZhciBDdG9ySW50MzJBcnJheSA9IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IEFycmF5IDogSW50MzJBcnJheTtcbi8vIFVzZSBwcmVmaXggdG8gYXZvaWQgaW5kZXggdG8gYmUgdGhlIHNhbWUgYXMgb3RoZXJJZExpc3RbaWR4XSxcbi8vIHdoaWNoIHdpbGwgY2F1c2Ugd2VpcmQgdXBkYXRlIGFuaW1hdGlvbi5cbnZhciBJRF9QUkVGSVggPSAnZVxcMFxcMCc7XG52YXIgSU5ERVhfTk9UX0ZPVU5EID0gLTE7XG4vLyB0eXBlIFNlcmllc0RpbWVuc2lvbkluZGV4ID0gRGltZW5zaW9uSW5kZXg7XG52YXIgVFJBTlNGRVJBQkxFX1BST1BFUlRJRVMgPSBbJ2hhc0l0ZW1PcHRpb24nLCAnX25hbWVMaXN0JywgJ19pZExpc3QnLCAnX2ludmVydGVkSW5kaWNlc01hcCcsICdfZGltU3VtbWFyeScsICd1c2VyT3V0cHV0JywgJ19yYXdEYXRhJywgJ19kaW1WYWx1ZUdldHRlcicsICdfbmFtZURpbUlkeCcsICdfaWREaW1JZHgnLCAnX25hbWVSZXBlYXRDb3VudCddO1xudmFyIENMT05FX1BST1BFUlRJRVMgPSBbJ19hcHByb3hpbWF0ZUV4dGVudCddO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEludGVybmFsIG1ldGhvZCBkZWNsYXJhdGlvbnM6XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHByZXBhcmVJbnZlcnRlZEluZGV4O1xudmFyIGdldElkO1xudmFyIGdldElkTmFtZUZyb21TdG9yZTtcbnZhciBub3JtYWxpemVEaW1lbnNpb25zO1xudmFyIHRyYW5zZmVyUHJvcGVydGllcztcbnZhciBjbG9uZUxpc3RGb3JNYXBBbmRTYW1wbGU7XG52YXIgbWFrZUlkRnJvbU5hbWU7XG52YXIgU2VyaWVzRGF0YSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIEBwYXJhbSBkaW1lbnNpb25zSW5wdXQuZGltZW5zaW9uc1xyXG4gICAqICAgICAgICBGb3IgZXhhbXBsZSwgWydzb21lRGltTmFtZScsIHtuYW1lOiAnc29tZURpbU5hbWUnLCB0eXBlOiAnc29tZURpbVR5cGUnfSwgLi4uXS5cclxuICAgKiAgICAgICAgRGltZW5zaW9ucyBzaG91bGQgYmUgY29uY3JldGUgbmFtZXMgbGlrZSB4LCB5LCB6LCBsbmcsIGxhdCwgYW5nbGUsIHJhZGl1c1xyXG4gICAqL1xuICBmdW5jdGlvbiBTZXJpZXNEYXRhKGRpbWVuc2lvbnNJbnB1dCwgaG9zdE1vZGVsKSB7XG4gICAgdGhpcy50eXBlID0gJ2xpc3QnO1xuICAgIHRoaXMuX2RpbU9taXR0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9uYW1lTGlzdCA9IFtdO1xuICAgIHRoaXMuX2lkTGlzdCA9IFtdO1xuICAgIC8vIE1vZGVscyBvZiBkYXRhIG9wdGlvbiBpcyBzdG9yZWQgc3BhcnNlIGZvciBvcHRpbWl6aW5nIG1lbW9yeSBjb3N0XG4gICAgLy8gTmV2ZXIgdXNlZCB5ZXQgKG5vdCB1c2VkIHlldCkuXG4gICAgLy8gcHJpdmF0ZSBfb3B0aW9uTW9kZWxzOiBNb2RlbFtdID0gW107XG4gICAgLy8gR2xvYmFsIHZpc3VhbCBwcm9wZXJ0aWVzIGFmdGVyIHZpc3VhbCBjb2RpbmdcbiAgICB0aGlzLl92aXN1YWwgPSB7fTtcbiAgICAvLyBHbG9iYWwgbGF5b3V0IHByb3BlcnRpZXMuXG4gICAgdGhpcy5fbGF5b3V0ID0ge307XG4gICAgLy8gSXRlbSB2aXN1YWwgcHJvcGVydGllcyBhZnRlciB2aXN1YWwgY29kaW5nXG4gICAgdGhpcy5faXRlbVZpc3VhbHMgPSBbXTtcbiAgICAvLyBJdGVtIGxheW91dCBwcm9wZXJ0aWVzIGFmdGVyIGxheW91dFxuICAgIHRoaXMuX2l0ZW1MYXlvdXRzID0gW107XG4gICAgLy8gR3JhcGhpYyBlbGVtZW50c1xuICAgIHRoaXMuX2dyYXBoaWNFbHMgPSBbXTtcbiAgICAvLyBrZXk6IGRpbSwgdmFsdWU6IGV4dGVudFxuICAgIHRoaXMuX2FwcHJveGltYXRlRXh0ZW50ID0ge307XG4gICAgdGhpcy5fY2FsY3VsYXRpb25JbmZvID0ge307XG4gICAgLy8gSGF2aW5nIGRldGVjdGVkIHRoYXQgdGhlcmUgaXMgZGF0YSBpdGVtIGlzIG5vbiBwcmltaXRpdmUgdHlwZVxuICAgIC8vIChpbiB0eXBlIGBPcHRpb25EYXRhSXRlbU9iamVjdGApLlxuICAgIC8vIExpa2UgYGRhdGE6IFsgeyB2YWx1ZTogeHgsIGl0ZW1TdHlsZTogey4uLn0gfSwgLi4uXWBcbiAgICAvLyBBdCBwcmVzZW50IGl0IG9ubHkgaGFwcGVuIGluIGBTT1VSQ0VfRk9STUFUX09SSUdJTkFMYC5cbiAgICB0aGlzLmhhc0l0ZW1PcHRpb24gPSBmYWxzZTtcbiAgICAvLyBNZXRob2RzIHRoYXQgY3JlYXRlIGEgbmV3IGxpc3QgYmFzZWQgb24gdGhpcyBsaXN0IHNob3VsZCBiZSBsaXN0ZWQgaGVyZS5cbiAgICAvLyBOb3RpY2UgdGhhdCB0aG9zZSBtZXRob2Qgc2hvdWxkIGBSRVRVUk5gIHRoZSBuZXcgbGlzdC5cbiAgICB0aGlzLlRSQU5TRkVSQUJMRV9NRVRIT0RTID0gWydjbG9uZVNoYWxsb3cnLCAnZG93blNhbXBsZScsICdtaW5tYXhEb3duU2FtcGxlJywgJ2x0dGJEb3duU2FtcGxlJywgJ21hcCddO1xuICAgIC8vIE1ldGhvZHMgdGhhdCBjaGFuZ2UgaW5kaWNlcyBvZiB0aGlzIGxpc3Qgc2hvdWxkIGJlIGxpc3RlZCBoZXJlLlxuICAgIHRoaXMuQ0hBTkdBQkxFX01FVEhPRFMgPSBbJ2ZpbHRlclNlbGYnLCAnc2VsZWN0UmFuZ2UnXTtcbiAgICB0aGlzLkRPV05TQU1QTEVfTUVUSE9EUyA9IFsnZG93blNhbXBsZScsICdtaW5tYXhEb3duU2FtcGxlJywgJ2x0dGJEb3duU2FtcGxlJ107XG4gICAgdmFyIGRpbWVuc2lvbnM7XG4gICAgdmFyIGFzc2lnblN0b3JlRGltSWR4ID0gZmFsc2U7XG4gICAgaWYgKGlzU2VyaWVzRGF0YVNjaGVtYShkaW1lbnNpb25zSW5wdXQpKSB7XG4gICAgICBkaW1lbnNpb25zID0gZGltZW5zaW9uc0lucHV0LmRpbWVuc2lvbnM7XG4gICAgICB0aGlzLl9kaW1PbWl0dGVkID0gZGltZW5zaW9uc0lucHV0LmlzRGltZW5zaW9uT21pdHRlZCgpO1xuICAgICAgdGhpcy5fc2NoZW1hID0gZGltZW5zaW9uc0lucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25TdG9yZURpbUlkeCA9IHRydWU7XG4gICAgICBkaW1lbnNpb25zID0gZGltZW5zaW9uc0lucHV0O1xuICAgIH1cbiAgICBkaW1lbnNpb25zID0gZGltZW5zaW9ucyB8fCBbJ3gnLCAneSddO1xuICAgIHZhciBkaW1lbnNpb25JbmZvcyA9IHt9O1xuICAgIHZhciBkaW1lbnNpb25OYW1lcyA9IFtdO1xuICAgIHZhciBpbnZlcnRlZEluZGljZXNNYXAgPSB7fTtcbiAgICB2YXIgbmVlZHNIYXNPd24gPSBmYWxzZTtcbiAgICB2YXIgZW1wdHlPYmogPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFVzZSB0aGUgb3JpZ2luYWwgZGltZW5zaW9uc1tpXSwgd2hlcmUgb3RoZXIgZmxhZyBwcm9wcyBtYXkgZXhpc3RzLlxuICAgICAgdmFyIGRpbUluZm9JbnB1dCA9IGRpbWVuc2lvbnNbaV07XG4gICAgICB2YXIgZGltZW5zaW9uSW5mbyA9IHpyVXRpbC5pc1N0cmluZyhkaW1JbmZvSW5wdXQpID8gbmV3IFNlcmllc0RpbWVuc2lvbkRlZmluZSh7XG4gICAgICAgIG5hbWU6IGRpbUluZm9JbnB1dFxuICAgICAgfSkgOiAhKGRpbUluZm9JbnB1dCBpbnN0YW5jZW9mIFNlcmllc0RpbWVuc2lvbkRlZmluZSkgPyBuZXcgU2VyaWVzRGltZW5zaW9uRGVmaW5lKGRpbUluZm9JbnB1dCkgOiBkaW1JbmZvSW5wdXQ7XG4gICAgICB2YXIgZGltZW5zaW9uTmFtZSA9IGRpbWVuc2lvbkluZm8ubmFtZTtcbiAgICAgIGRpbWVuc2lvbkluZm8udHlwZSA9IGRpbWVuc2lvbkluZm8udHlwZSB8fCAnZmxvYXQnO1xuICAgICAgaWYgKCFkaW1lbnNpb25JbmZvLmNvb3JkRGltKSB7XG4gICAgICAgIGRpbWVuc2lvbkluZm8uY29vcmREaW0gPSBkaW1lbnNpb25OYW1lO1xuICAgICAgICBkaW1lbnNpb25JbmZvLmNvb3JkRGltSW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIG90aGVyRGltcyA9IGRpbWVuc2lvbkluZm8ub3RoZXJEaW1zID0gZGltZW5zaW9uSW5mby5vdGhlckRpbXMgfHwge307XG4gICAgICBkaW1lbnNpb25OYW1lcy5wdXNoKGRpbWVuc2lvbk5hbWUpO1xuICAgICAgZGltZW5zaW9uSW5mb3NbZGltZW5zaW9uTmFtZV0gPSBkaW1lbnNpb25JbmZvO1xuICAgICAgaWYgKGVtcHR5T2JqW2RpbWVuc2lvbk5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgbmVlZHNIYXNPd24gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRpbWVuc2lvbkluZm8uY3JlYXRlSW52ZXJ0ZWRJbmRpY2VzKSB7XG4gICAgICAgIGludmVydGVkSW5kaWNlc01hcFtkaW1lbnNpb25OYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyRGltcy5pdGVtTmFtZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9uYW1lRGltSWR4ID0gaTtcbiAgICAgIH1cbiAgICAgIGlmIChvdGhlckRpbXMuaXRlbUlkID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2lkRGltSWR4ID0gaTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHpyVXRpbC5hc3NlcnQoYXNzaWduU3RvcmVEaW1JZHggfHwgZGltZW5zaW9uSW5mby5zdG9yZURpbUluZGV4ID49IDApO1xuICAgICAgfVxuICAgICAgaWYgKGFzc2lnblN0b3JlRGltSWR4KSB7XG4gICAgICAgIGRpbWVuc2lvbkluZm8uc3RvcmVEaW1JbmRleCA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGltZW5zaW9ucyA9IGRpbWVuc2lvbk5hbWVzO1xuICAgIHRoaXMuX2RpbUluZm9zID0gZGltZW5zaW9uSW5mb3M7XG4gICAgdGhpcy5faW5pdEdldERpbWVuc2lvbkluZm8obmVlZHNIYXNPd24pO1xuICAgIHRoaXMuaG9zdE1vZGVsID0gaG9zdE1vZGVsO1xuICAgIHRoaXMuX2ludmVydGVkSW5kaWNlc01hcCA9IGludmVydGVkSW5kaWNlc01hcDtcbiAgICBpZiAodGhpcy5fZGltT21pdHRlZCkge1xuICAgICAgdmFyIGRpbUlkeFRvTmFtZV8xID0gdGhpcy5fZGltSWR4VG9OYW1lID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgICAgIHpyVXRpbC5lYWNoKGRpbWVuc2lvbk5hbWVzLCBmdW5jdGlvbiAoZGltTmFtZSkge1xuICAgICAgICBkaW1JZHhUb05hbWVfMS5zZXQoZGltZW5zaW9uSW5mb3NbZGltTmFtZV0uc3RvcmVEaW1JbmRleCwgZGltTmFtZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICpcclxuICAgKiBHZXQgY29uY3JldGUgZGltZW5zaW9uIG5hbWUgYnkgZGltZW5zaW9uIG5hbWUgb3IgZGltZW5zaW9uIGluZGV4LlxyXG4gICAqIElmIGlucHV0IGEgZGltZW5zaW9uIG5hbWUsIGRvIG5vdCB2YWxpZGF0ZSB3aGV0aGVyIHRoZSBkaW1lbnNpb24gbmFtZSBleGl0cy5cclxuICAgKlxyXG4gICAqIEBjYXV0aW9uXHJcbiAgICogQHBhcmFtIGRpbSBNdXN0IG1ha2Ugc3VyZSB0aGUgZGltZW5zaW9uIGlzIGBTZXJpZXNEaW1lbnNpb25Mb29zZWAuXHJcbiAgICogQmVjYXVzZSBvbmx5IHRob3NlIGRpbWVuc2lvbnMgd2lsbCBoYXZlIGF1dG8tZ2VuZXJhdGVkIGRpbWVuc2lvbiBuYW1lcyBpZiBub3RcclxuICAgKiBoYXZlIGEgdXNlci1zcGVjaWZpZWQgbmFtZSwgYW5kIG90aGVyIGRpbWVuc2lvbnMgd2lsbCBnZXQgYSByZXR1cm4gb2YgbnVsbC91bmRlZmluZWQuXHJcbiAgICpcclxuICAgKiBAbm90aWNlIEJlY2F1c2Ugb2YgdGhpcyByZWFzb24sIHNob3VsZCBiZXR0ZXIgdXNlIGBnZXREaW1lbnNpb25JbmRleGAgaW5zdGVhZCwgZm9yIGV4YW1wbGVzOlxyXG4gICAqIGBgYGpzXHJcbiAgICogY29uc3QgdmFsID0gZGF0YS5nZXRTdG9yZSgpLmdldChkYXRhLmdldERpbWVuc2lvbkluZGV4KGRpbSksIGRhdGFJZHgpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQHJldHVybiBDb25jcmV0ZSBkaW0gbmFtZS5cclxuICAgKi9cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gKGRpbSkge1xuICAgIHZhciBkaW1JZHggPSB0aGlzLl9yZWNvZ25pemVEaW1JbmRleChkaW0pO1xuICAgIGlmIChkaW1JZHggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGRpbTtcbiAgICB9XG4gICAgZGltSWR4ID0gZGltO1xuICAgIGlmICghdGhpcy5fZGltT21pdHRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uc1tkaW1JZHhdO1xuICAgIH1cbiAgICAvLyBSZXRyaWV2ZSBmcm9tIHNlcmllcyBkaW1lbnNpb24gZGVmaW5pdGlvbiBiZWNhdXNlIGl0IHByb2JhYmx5IGNvbnRhaW5zXG4gICAgLy8gZ2VuZXJhdGVkIGRpbWVuc2lvbiBuYW1lIChsaWtlICd4JywgJ3knKS5cbiAgICB2YXIgZGltTmFtZSA9IHRoaXMuX2RpbUlkeFRvTmFtZS5nZXQoZGltSWR4KTtcbiAgICBpZiAoZGltTmFtZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZGltTmFtZTtcbiAgICB9XG4gICAgdmFyIHNvdXJjZURpbURlZiA9IHRoaXMuX3NjaGVtYS5nZXRTb3VyY2VEaW1lbnNpb24oZGltSWR4KTtcbiAgICBpZiAoc291cmNlRGltRGVmKSB7XG4gICAgICByZXR1cm4gc291cmNlRGltRGVmLm5hbWU7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBHZXQgZGltZW5zaW9uIGluZGV4IGluIGRhdGEgc3RvcmUuIFJldHVybiAtMSBpZiBub3QgZm91bmQuXHJcbiAgICogQ2FuIGJlIHVzZWQgdG8gaW5kZXggdmFsdWUgZnJvbSBnZXRSYXdWYWx1ZS5cclxuICAgKi9cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuZ2V0RGltZW5zaW9uSW5kZXggPSBmdW5jdGlvbiAoZGltKSB7XG4gICAgdmFyIGRpbUlkeCA9IHRoaXMuX3JlY29nbml6ZURpbUluZGV4KGRpbSk7XG4gICAgaWYgKGRpbUlkeCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZGltSWR4O1xuICAgIH1cbiAgICBpZiAoZGltID09IG51bGwpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgdmFyIGRpbUluZm8gPSB0aGlzLl9nZXREaW1JbmZvKGRpbSk7XG4gICAgcmV0dXJuIGRpbUluZm8gPyBkaW1JbmZvLnN0b3JlRGltSW5kZXggOiB0aGlzLl9kaW1PbWl0dGVkID8gdGhpcy5fc2NoZW1hLmdldFNvdXJjZURpbWVuc2lvbkluZGV4KGRpbSkgOiAtMTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVGhlIG1lYW5pbmdzIG9mIHRoZSBpbnB1dCBwYXJhbWV0ZXIgYGRpbWA6XHJcbiAgICpcclxuICAgKiArIElmIGRpbSBpcyBhIG51bWJlciAoZS5nLiwgYDFgKSwgaXQgbWVhbnMgdGhlIGluZGV4IG9mIHRoZSBkaW1lbnNpb24uXHJcbiAgICogICBGb3IgZXhhbXBsZSwgYGdldERpbWVuc2lvbigwKWAgd2lsbCByZXR1cm4gJ3gnIG9yICdsbmcnIG9yICdyYWRpdXMnLlxyXG4gICAqICsgSWYgZGltIGlzIGEgbnVtYmVyLWxpa2Ugc3RyaW5nIChlLmcuLCBgXCIxXCJgKTpcclxuICAgKiAgICAgKyBJZiB0aGVyZSBpcyB0aGUgc2FtZSBjb25jcmV0ZSBkaW0gbmFtZSBkZWZpbmVkIGluIGBzZXJpZXMuZGltZW5zaW9uc2Agb3IgYGRhdGFzZXQuZGltZW5zaW9uc2AsXHJcbiAgICogICAgICAgIGl0IG1lYW5zIHRoYXQgY29uY3JldGUgbmFtZS5cclxuICAgKiAgICAgKyBJZiBub3QsIGl0IHdpbGwgYmUgY29udmVydGVkIHRvIGEgbnVtYmVyLCB3aGljaCBtZWFucyB0aGUgaW5kZXggb2YgdGhlIGRpbWVuc2lvbi5cclxuICAgKiAgICAgICAgKHdoeT8gYmVjYXVzZSBvZiB0aGUgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gV2UgaGF2ZSBiZWVuIHRvbGVyYXRpbmcgbnVtYmVyLWxpa2Ugc3RyaW5nIGluXHJcbiAgICogICAgICAgIGRpbWVuc2lvbiBzZXR0aW5nLCBhbHRob3VnaCBub3cgaXQgc2VlbXMgdGhhdCBpdCBpcyBub3QgYSBnb29kIGlkZWEuKVxyXG4gICAqICAgICBGb3IgZXhhbXBsZSwgYHZpc3VhbE1hcFtpXS5kaW1lbnNpb246IFwiMVwiYCBpcyB0aGUgc2FtZSBtZWFuaW5nIGFzIGB2aXN1YWxNYXBbaV0uZGltZW5zaW9uOiAxYCxcclxuICAgKiAgICAgaWYgbm8gZGltZW5zaW9uIG5hbWUgaXMgZGVmaW5lZCBhcyBgXCIxXCJgLlxyXG4gICAqICsgSWYgZGltIGlzIGEgbm90LW51bWJlci1saWtlIHN0cmluZywgaXQgbWVhbnMgdGhlIGNvbmNyZXRlIGRpbSBuYW1lLlxyXG4gICAqICAgRm9yIGV4YW1wbGUsIGl0IGNhbiBiZSBiZSBkZWZhdWx0IG5hbWUgYFwieFwiYCwgYFwieVwiYCwgYFwielwiYCwgYFwibG5nXCJgLCBgXCJsYXRcImAsIGBcImFuZ2xlXCJgLCBgXCJyYWRpdXNcImAsXHJcbiAgICogICBvciBjdXN0b21pemVkIGluIGBkaW1lbnNpb25zYCBwcm9wZXJ0eSBvZiBvcHRpb24gbGlrZSBgXCJhZ2VcImAuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHJlY29nbml6ZWQgYERpbWVuc2lvbkluZGV4YC4gT3RoZXJ3aXNlIHJldHVybiBudWxsL3VuZGVmaW5lZCAobWVhbnMgdGhhdCBkaW0gaXMgYERpbWVuc2lvbk5hbWVgKS5cclxuICAgKi9cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuX3JlY29nbml6ZURpbUluZGV4ID0gZnVuY3Rpb24gKGRpbSkge1xuICAgIGlmICh6clV0aWwuaXNOdW1iZXIoZGltKVxuICAgIC8vIElmIGJlaW5nIGEgbnVtYmVyLWxpa2Ugc3RyaW5nIGJ1dCBub3QgYmVpbmcgZGVmaW5lZCBhcyBhIGRpbWVuc2lvbiBuYW1lLlxuICAgIHx8IGRpbSAhPSBudWxsICYmICFpc05hTihkaW0pICYmICF0aGlzLl9nZXREaW1JbmZvKGRpbSkgJiYgKCF0aGlzLl9kaW1PbWl0dGVkIHx8IHRoaXMuX3NjaGVtYS5nZXRTb3VyY2VEaW1lbnNpb25JbmRleChkaW0pIDwgMCkpIHtcbiAgICAgIHJldHVybiArZGltO1xuICAgIH1cbiAgfTtcbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuX2dldFN0b3JlRGltSW5kZXggPSBmdW5jdGlvbiAoZGltKSB7XG4gICAgdmFyIGRpbUlkeCA9IHRoaXMuZ2V0RGltZW5zaW9uSW5kZXgoZGltKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGRpbUlkeCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBkaW1lbnNpb24gJyArIGRpbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaW1JZHg7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCB0eXBlIGFuZCBjYWxjdWxhdGlvbiBpbmZvIG9mIHBhcnRpY3VsYXIgZGltZW5zaW9uXHJcbiAgICogQHBhcmFtIGRpbVxyXG4gICAqICAgICAgICBEaW1lbnNpb24gY2FuIGJlIGNvbmNyZXRlIG5hbWVzIGxpa2UgeCwgeSwgeiwgbG5nLCBsYXQsIGFuZ2xlLCByYWRpdXNcclxuICAgKiAgICAgICAgT3IgYSBvcmRpbmFsIG51bWJlci4gRm9yIGV4YW1wbGUgZ2V0RGltZW5zaW9uSW5mbygwKSB3aWxsIHJldHVybiAneCcgb3IgJ2xuZycgb3IgJ3JhZGl1cydcclxuICAgKi9cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuZ2V0RGltZW5zaW9uSW5mbyA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgICAvLyBEbyBub3QgY2xvbmUsIGJlY2F1c2UgdGhlcmUgbWF5IGJlIGNhdGVnb3JpZXMgaW4gZGltSW5mby5cbiAgICByZXR1cm4gdGhpcy5fZ2V0RGltSW5mbyh0aGlzLmdldERpbWVuc2lvbihkaW0pKTtcbiAgfTtcbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuX2luaXRHZXREaW1lbnNpb25JbmZvID0gZnVuY3Rpb24gKG5lZWRzSGFzT3duKSB7XG4gICAgdmFyIGRpbWVuc2lvbkluZm9zID0gdGhpcy5fZGltSW5mb3M7XG4gICAgdGhpcy5fZ2V0RGltSW5mbyA9IG5lZWRzSGFzT3duID8gZnVuY3Rpb24gKGRpbU5hbWUpIHtcbiAgICAgIHJldHVybiBkaW1lbnNpb25JbmZvcy5oYXNPd25Qcm9wZXJ0eShkaW1OYW1lKSA/IGRpbWVuc2lvbkluZm9zW2RpbU5hbWVdIDogdW5kZWZpbmVkO1xuICAgIH0gOiBmdW5jdGlvbiAoZGltTmFtZSkge1xuICAgICAgcmV0dXJuIGRpbWVuc2lvbkluZm9zW2RpbU5hbWVdO1xuICAgIH07XG4gIH07XG4gIC8qKlxyXG4gICAqIGNvbmNyZXRlIGRpbWVuc2lvbiBuYW1lIGxpc3Qgb24gY29vcmQuXHJcbiAgICovXG4gIFNlcmllc0RhdGEucHJvdG90eXBlLmdldERpbWVuc2lvbnNPbkNvb3JkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kaW1TdW1tYXJ5LmRhdGFEaW1zT25Db29yZC5zbGljZSgpO1xuICB9O1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5tYXBEaW1lbnNpb24gPSBmdW5jdGlvbiAoY29vcmREaW0sIGlkeCkge1xuICAgIHZhciBkaW1lbnNpb25zU3VtbWFyeSA9IHRoaXMuX2RpbVN1bW1hcnk7XG4gICAgaWYgKGlkeCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGltZW5zaW9uc1N1bW1hcnkuZW5jb2RlRmlyc3REaW1Ob3RFeHRyYVtjb29yZERpbV07XG4gICAgfVxuICAgIHZhciBkaW1zID0gZGltZW5zaW9uc1N1bW1hcnkuZW5jb2RlW2Nvb3JkRGltXTtcbiAgICByZXR1cm4gZGltcyA/IGRpbXNbaWR4XSA6IG51bGw7XG4gIH07XG4gIFNlcmllc0RhdGEucHJvdG90eXBlLm1hcERpbWVuc2lvbnNBbGwgPSBmdW5jdGlvbiAoY29vcmREaW0pIHtcbiAgICB2YXIgZGltZW5zaW9uc1N1bW1hcnkgPSB0aGlzLl9kaW1TdW1tYXJ5O1xuICAgIHZhciBkaW1zID0gZGltZW5zaW9uc1N1bW1hcnkuZW5jb2RlW2Nvb3JkRGltXTtcbiAgICByZXR1cm4gKGRpbXMgfHwgW10pLnNsaWNlKCk7XG4gIH07XG4gIFNlcmllc0RhdGEucHJvdG90eXBlLmdldFN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zdG9yZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBmcm9tIGRhdGFcclxuICAgKiBAcGFyYW0gZGF0YSBzb3VyY2Ugb3IgZGF0YSBvciBkYXRhIHN0b3JlLlxyXG4gICAqIEBwYXJhbSBuYW1lTGlzdCBUaGUgbmFtZSBvZiBhIGRhdHVtIGlzIHVzZWQgb24gZGF0YSBkaWZmIGFuZFxyXG4gICAqICAgICAgICBkZWZhdWx0IGxhYmVsL3Rvb2x0aXAuXHJcbiAgICogICAgICAgIEEgbmFtZSBjYW4gYmUgc3BlY2lmaWVkIGluIGVuY29kZS5pdGVtTmFtZSxcclxuICAgKiAgICAgICAgb3IgZGF0YUl0ZW0ubmFtZSAob25seSBmb3Igc2VyaWVzIG9wdGlvbiBkYXRhKSxcclxuICAgKiAgICAgICAgb3IgcHJvdmlkZWQgaW4gbmFtZUxpc3QgZnJvbSBvdXRzaWRlLlxyXG4gICAqL1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5pbml0RGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBuYW1lTGlzdCwgZGltVmFsdWVHZXR0ZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBzdG9yZTtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIERhdGFTdG9yZSkge1xuICAgICAgc3RvcmUgPSBkYXRhO1xuICAgIH1cbiAgICBpZiAoIXN0b3JlKSB7XG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICAgIHZhciBwcm92aWRlciA9IGlzU291cmNlSW5zdGFuY2UoZGF0YSkgfHwgenJVdGlsLmlzQXJyYXlMaWtlKGRhdGEpID8gbmV3IERlZmF1bHREYXRhUHJvdmlkZXIoZGF0YSwgZGltZW5zaW9ucy5sZW5ndGgpIDogZGF0YTtcbiAgICAgIHN0b3JlID0gbmV3IERhdGFTdG9yZSgpO1xuICAgICAgdmFyIGRpbWVuc2lvbkluZm9zID0gbWFwKGRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW1OYW1lKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogX3RoaXMuX2RpbUluZm9zW2RpbU5hbWVdLnR5cGUsXG4gICAgICAgICAgcHJvcGVydHk6IGRpbU5hbWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgc3RvcmUuaW5pdERhdGEocHJvdmlkZXIsIGRpbWVuc2lvbkluZm9zLCBkaW1WYWx1ZUdldHRlcik7XG4gICAgfVxuICAgIHRoaXMuX3N0b3JlID0gc3RvcmU7XG4gICAgLy8gUmVzZXRcbiAgICB0aGlzLl9uYW1lTGlzdCA9IChuYW1lTGlzdCB8fCBbXSkuc2xpY2UoKTtcbiAgICB0aGlzLl9pZExpc3QgPSBbXTtcbiAgICB0aGlzLl9uYW1lUmVwZWF0Q291bnQgPSB7fTtcbiAgICB0aGlzLl9kb0luaXQoMCwgc3RvcmUuY291bnQoKSk7XG4gICAgLy8gQ2FjaGUgc3VtbWFyeSBpbmZvIGZvciBmYXN0IHZpc2l0LiBTZWUgXCJkaW1lbnNpb25IZWxwZXJcIi5cbiAgICAvLyBOZWVkcyB0byBiZSBpbml0aWFsaXplZCBhZnRlciBzdG9yZSBpcyBwcmVwYXJlZC5cbiAgICB0aGlzLl9kaW1TdW1tYXJ5ID0gc3VtbWFyaXplRGltZW5zaW9ucyh0aGlzLCB0aGlzLl9zY2hlbWEpO1xuICAgIHRoaXMudXNlck91dHB1dCA9IHRoaXMuX2RpbVN1bW1hcnkudXNlck91dHB1dDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2F1dGlvbjogQ2FuIGJlIG9ubHkgY2FsbGVkIG9uIHJhdyBkYXRhIChiZWZvcmUgYHRoaXMuX2luZGljZXNgIGNyZWF0ZWQpLlxyXG4gICAqL1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5hcHBlbmREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLl9zdG9yZS5hcHBlbmREYXRhKGRhdGEpO1xuICAgIHRoaXMuX2RvSW5pdChyYW5nZVswXSwgcmFuZ2VbMV0pO1xuICB9O1xuICAvKipcclxuICAgKiBDYXV0aW9uOiBDYW4gYmUgb25seSBjYWxsZWQgb24gcmF3IGRhdGEgKGJlZm9yZSBgdGhpcy5faW5kaWNlc2AgY3JlYXRlZCkuXHJcbiAgICogVGhpcyBtZXRob2QgZG9lcyBub3QgbW9kaWZ5IGByYXdEYXRhYCAoYGRhdGFQcm92aWRlcmApLCBidXQgb25seVxyXG4gICAqIGFkZCB2YWx1ZXMgdG8gc3RvcmUuXHJcbiAgICpcclxuICAgKiBUaGUgZmluYWwgY291bnQgd2lsbCBiZSBpbmNyZWFzZWQgYnkgYE1hdGgubWF4KHZhbHVlcy5sZW5ndGgsIG5hbWVzLmxlbmd0aClgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHZhbHVlcyBUaGF0IGlzIHRoZSBTb3VyY2VUeXBlOiAnYXJyYXlSb3dzJywgbGlrZVxyXG4gICAqICAgICAgICBbXHJcbiAgICogICAgICAgICAgICBbMTIsIDMzLCA0NF0sXHJcbiAgICogICAgICAgICAgICBbTmFOLCA0MywgMV0sXHJcbiAgICogICAgICAgICAgICBbJy0nLCAnYXNkZicsIDBdXHJcbiAgICogICAgICAgIF1cclxuICAgKiAgICAgICAgRWFjaCBpdGVtIGlzIGV4YWN0bHkgY29ycmVzcG9uZGluZyB0byBhIGRpbWVuc2lvbi5cclxuICAgKi9cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuYXBwZW5kVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcywgbmFtZXMpIHtcbiAgICB2YXIgX2EgPSB0aGlzLl9zdG9yZS5hcHBlbmRWYWx1ZXModmFsdWVzLCBuYW1lcyAmJiBuYW1lcy5sZW5ndGgpLFxuICAgICAgc3RhcnQgPSBfYS5zdGFydCxcbiAgICAgIGVuZCA9IF9hLmVuZDtcbiAgICB2YXIgc2hvdWxkTWFrZUlkRnJvbU5hbWUgPSB0aGlzLl9zaG91bGRNYWtlSWRGcm9tTmFtZSgpO1xuICAgIHRoaXMuX3VwZGF0ZU9yZGluYWxNZXRhKCk7XG4gICAgaWYgKG5hbWVzKSB7XG4gICAgICBmb3IgKHZhciBpZHggPSBzdGFydDsgaWR4IDwgZW5kOyBpZHgrKykge1xuICAgICAgICB2YXIgc291cmNlSWR4ID0gaWR4IC0gc3RhcnQ7XG4gICAgICAgIHRoaXMuX25hbWVMaXN0W2lkeF0gPSBuYW1lc1tzb3VyY2VJZHhdO1xuICAgICAgICBpZiAoc2hvdWxkTWFrZUlkRnJvbU5hbWUpIHtcbiAgICAgICAgICBtYWtlSWRGcm9tTmFtZSh0aGlzLCBpZHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5fdXBkYXRlT3JkaW5hbE1ldGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0b3JlID0gdGhpcy5fc3RvcmU7XG4gICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGltSW5mbyA9IHRoaXMuX2RpbUluZm9zW2RpbWVuc2lvbnNbaV1dO1xuICAgICAgaWYgKGRpbUluZm8ub3JkaW5hbE1ldGEpIHtcbiAgICAgICAgc3RvcmUuY29sbGVjdE9yZGluYWxNZXRhKGRpbUluZm8uc3RvcmVEaW1JbmRleCwgZGltSW5mby5vcmRpbmFsTWV0YSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5fc2hvdWxkTWFrZUlkRnJvbU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3ZpZGVyID0gdGhpcy5fc3RvcmUuZ2V0UHJvdmlkZXIoKTtcbiAgICByZXR1cm4gdGhpcy5faWREaW1JZHggPT0gbnVsbCAmJiBwcm92aWRlci5nZXRTb3VyY2UoKS5zb3VyY2VGb3JtYXQgIT09IFNPVVJDRV9GT1JNQVRfVFlQRURfQVJSQVkgJiYgIXByb3ZpZGVyLmZpbGxTdG9yYWdlO1xuICB9O1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5fZG9Jbml0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdG9yZSA9IHRoaXMuX3N0b3JlO1xuICAgIHZhciBwcm92aWRlciA9IHN0b3JlLmdldFByb3ZpZGVyKCk7XG4gICAgdGhpcy5fdXBkYXRlT3JkaW5hbE1ldGEoKTtcbiAgICB2YXIgbmFtZUxpc3QgPSB0aGlzLl9uYW1lTGlzdDtcbiAgICB2YXIgaWRMaXN0ID0gdGhpcy5faWRMaXN0O1xuICAgIHZhciBzb3VyY2VGb3JtYXQgPSBwcm92aWRlci5nZXRTb3VyY2UoKS5zb3VyY2VGb3JtYXQ7XG4gICAgdmFyIGlzRm9ybWF0T3JpZ2luYWwgPSBzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfT1JJR0lOQUw7XG4gICAgLy8gRWFjaCBkYXRhIGl0ZW0gaXMgdmFsdWVcbiAgICAvLyBbMSwgMl1cbiAgICAvLyAyXG4gICAgLy8gQmFyIGNoYXJ0LCBsaW5lIGNoYXJ0IHdoaWNoIHVzZXMgY2F0ZWdvcnkgYXhpc1xuICAgIC8vIG9ubHkgZ2l2ZXMgdGhlICd5JyB2YWx1ZS4gJ3gnIHZhbHVlIGlzIHRoZSBpbmRpY2VzIG9mIGNhdGVnb3J5XG4gICAgLy8gVXNlIGEgdGVtcFZhbHVlIHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWUgdG8gYmUgYSAoeCwgeSkgdmFsdWVcbiAgICAvLyBJZiBkYXRhSXRlbSBpcyB7bmFtZTogLi4ufSBvciB7aWQ6IC4uLn0sIGl0IGhhcyBoaWdoZXN0IHByaW9yaXR5LlxuICAgIC8vIFRoaXMga2luZCBvZiBpZHMgYW5kIG5hbWVzIGFyZSBhbHdheXMgc3RvcmVkIGBfbmFtZUxpc3RgIGFuZCBgX2lkTGlzdGAuXG4gICAgaWYgKGlzRm9ybWF0T3JpZ2luYWwgJiYgIXByb3ZpZGVyLnB1cmUpIHtcbiAgICAgIHZhciBzaGFyZWREYXRhSXRlbSA9IFtdO1xuICAgICAgZm9yICh2YXIgaWR4ID0gc3RhcnQ7IGlkeCA8IGVuZDsgaWR4KyspIHtcbiAgICAgICAgLy8gTk9USUNFOiBUcnkgbm90IHRvIHdyaXRlIHRoaW5ncyBpbnRvIGRhdGFJdGVtXG4gICAgICAgIHZhciBkYXRhSXRlbSA9IHByb3ZpZGVyLmdldEl0ZW0oaWR4LCBzaGFyZWREYXRhSXRlbSk7XG4gICAgICAgIGlmICghdGhpcy5oYXNJdGVtT3B0aW9uICYmIGlzRGF0YUl0ZW1PcHRpb24oZGF0YUl0ZW0pKSB7XG4gICAgICAgICAgdGhpcy5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YUl0ZW0pIHtcbiAgICAgICAgICB2YXIgaXRlbU5hbWUgPSBkYXRhSXRlbS5uYW1lO1xuICAgICAgICAgIGlmIChuYW1lTGlzdFtpZHhdID09IG51bGwgJiYgaXRlbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmFtZUxpc3RbaWR4XSA9IGNvbnZlcnRPcHRpb25JZE5hbWUoaXRlbU5hbWUsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaXRlbUlkID0gZGF0YUl0ZW0uaWQ7XG4gICAgICAgICAgaWYgKGlkTGlzdFtpZHhdID09IG51bGwgJiYgaXRlbUlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlkTGlzdFtpZHhdID0gY29udmVydE9wdGlvbklkTmFtZShpdGVtSWQsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fc2hvdWxkTWFrZUlkRnJvbU5hbWUoKSkge1xuICAgICAgZm9yICh2YXIgaWR4ID0gc3RhcnQ7IGlkeCA8IGVuZDsgaWR4KyspIHtcbiAgICAgICAgbWFrZUlkRnJvbU5hbWUodGhpcywgaWR4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZUludmVydGVkSW5kZXgodGhpcyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFBFTkRJTkc6IEluIGZhY3QgY3VycmVudGx5IHRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIHRvIHNob3J0LWNpcmN1aXRcclxuICAgKiB0aGUgY2FsbGluZyBvZiBgc2NhbGUudW5pb25FeHRlbnRGcm9tRGF0YWAgd2hlbiBkYXRhIGhhdmUgYmVlbiBmaWx0ZXJlZCBieSBtb2R1bGVzXHJcbiAgICogbGlrZSBcImRhdGFab29tXCIuIGBzY2FsZS51bmlvbkV4dGVudEZyb21EYXRhYCBpcyB1c2VkIHRvIGNhbGN1bGF0ZSBkYXRhIGV4dGVudCBmb3Igc2VyaWVzIG9uXHJcbiAgICogYW4gYXhpcywgYnV0IGlmIGEgXCJheGlzIHJlbGF0ZWQgZGF0YSBmaWx0ZXIgbW9kdWxlXCIgaXMgdXNlZCwgdGhlIGV4dGVudCBvZiB0aGUgYXhpcyBoYXZlXHJcbiAgICogYmVlbiBmaXhlZCBhbmQgbm8gbmVlZCB0byBjYWxsaW5nIGBzY2FsZS51bmlvbkV4dGVudEZyb21EYXRhYCBhY3R1YWxseS5cclxuICAgKiBCdXQgaWYgd2UgYWRkIFwiY3VzdG9tIGRhdGEgZmlsdGVyXCIgaW4gZnV0dXJlLCB3aGljaCBpcyBub3QgXCJheGlzIHJlbGF0ZWRcIiwgdGhpcyBtZXRob2QgbWF5XHJcbiAgICogYmUgc3RpbGwgbmVlZGVkLlxyXG4gICAqXHJcbiAgICogT3B0aW1pemUgZm9yIHRoZSBzY2VuYXJpbyB0aGF0IGRhdGEgaXMgZmlsdGVyZWQgYnkgYSBnaXZlbiBleHRlbnQuXHJcbiAgICogQ29uc2lkZXIgdGhhdCBpZiBkYXRhIGFtb3VudCBpcyBtb3JlIHRoYW4gaHVuZHJlZHMgb2YgdGhvdXNhbmQsXHJcbiAgICogZXh0ZW50IGNhbGN1bGF0aW9uIHdpbGwgY29zdCBtb3JlIHRoYW4gMTBtcyBhbmQgdGhlIGNhY2hlIHdpbGxcclxuICAgKiBiZSBlcmFzZWQgYmVjYXVzZSBvZiB0aGUgZmlsdGVyaW5nLlxyXG4gICAqL1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5nZXRBcHByb3hpbWF0ZUV4dGVudCA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgICByZXR1cm4gdGhpcy5fYXBwcm94aW1hdGVFeHRlbnRbZGltXSB8fCB0aGlzLl9zdG9yZS5nZXREYXRhRXh0ZW50KHRoaXMuX2dldFN0b3JlRGltSW5kZXgoZGltKSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBleHRlbnQgb24gYSBmaWx0ZXJlZCBkYXRhIG1pZ2h0IGJlIHRpbWUgY29uc3VtaW5nLlxyXG4gICAqIEFwcHJveGltYXRlIGV4dGVudCBpcyBvbmx5IHVzZWQgZm9yOiBjYWxjdWxhdGUgZXh0ZW50IG9mIGZpbHRlcmVkIGRhdGEgb3V0c2lkZS5cclxuICAgKi9cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuc2V0QXBwcm94aW1hdGVFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBkaW0pIHtcbiAgICBkaW0gPSB0aGlzLmdldERpbWVuc2lvbihkaW0pO1xuICAgIHRoaXMuX2FwcHJveGltYXRlRXh0ZW50W2RpbV0gPSBleHRlbnQuc2xpY2UoKTtcbiAgfTtcbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuZ2V0Q2FsY3VsYXRpb25JbmZvID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGlvbkluZm9ba2V5XTtcbiAgfTtcbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuc2V0Q2FsY3VsYXRpb25JbmZvID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpc09iamVjdChrZXkpID8genJVdGlsLmV4dGVuZCh0aGlzLl9jYWxjdWxhdGlvbkluZm8sIGtleSkgOiB0aGlzLl9jYWxjdWxhdGlvbkluZm9ba2V5XSA9IHZhbHVlO1xuICB9O1xuICAvKipcclxuICAgKiBAcmV0dXJuIE5ldmVyIGJlIG51bGwvdW5kZWZpbmVkLiBgbnVtYmVyYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBzdHJpbmcuIEJlY2F1c2U6XHJcbiAgICogSW4gbW9zdCBjYXNlcywgbmFtZSBpcyB1c2VkIGluIGRpc3BsYXksIHdoZXJlIHJldHVybmluZyBhIHN0cmluZyBpcyBtb3JlIGNvbnZlbmllbnQuXHJcbiAgICogSW4gb3RoZXIgY2FzZXMsIG5hbWUgaXMgdXNlZCBpbiBxdWVyeSAoc2VlIGBpbmRleE9mTmFtZWApLCB3aGVyZSB3ZSBjYW4ga2VlcCB0aGVcclxuICAgKiBydWxlIHRoYXQgbmFtZSBgMmAgZXF1YWxzIHRvIG5hbWUgYCcyJ2AuXHJcbiAgICovXG4gIFNlcmllc0RhdGEucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgdmFyIHJhd0luZGV4ID0gdGhpcy5nZXRSYXdJbmRleChpZHgpO1xuICAgIHZhciBuYW1lID0gdGhpcy5fbmFtZUxpc3RbcmF3SW5kZXhdO1xuICAgIGlmIChuYW1lID09IG51bGwgJiYgdGhpcy5fbmFtZURpbUlkeCAhPSBudWxsKSB7XG4gICAgICBuYW1lID0gZ2V0SWROYW1lRnJvbVN0b3JlKHRoaXMsIHRoaXMuX25hbWVEaW1JZHgsIHJhd0luZGV4KTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgbmFtZSA9ICcnO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuX2dldENhdGVnb3J5ID0gZnVuY3Rpb24gKGRpbUlkeCwgaWR4KSB7XG4gICAgdmFyIG9yZGluYWwgPSB0aGlzLl9zdG9yZS5nZXQoZGltSWR4LCBpZHgpO1xuICAgIHZhciBvcmRpbmFsTWV0YSA9IHRoaXMuX3N0b3JlLmdldE9yZGluYWxNZXRhKGRpbUlkeCk7XG4gICAgaWYgKG9yZGluYWxNZXRhKSB7XG4gICAgICByZXR1cm4gb3JkaW5hbE1ldGEuY2F0ZWdvcmllc1tvcmRpbmFsXTtcbiAgICB9XG4gICAgcmV0dXJuIG9yZGluYWw7XG4gIH07XG4gIC8qKlxyXG4gICAqIEByZXR1cm4gTmV2ZXIgbnVsbC91bmRlZmluZWQuIGBudW1iZXJgIHdpbGwgYmUgY29udmVydGVkIHRvIHN0cmluZy4gQmVjYXVzZTpcclxuICAgKiBJbiBhbGwgY2FzZXMgaGF2aW5nIGVuY291bnRlcmVkIGF0IHByZXNlbnQsIGlkIGlzIHVzZWQgaW4gbWFraW5nIGRpZmYgY29tcGFyaXNvbiwgd2hpY2hcclxuICAgKiBhcmUgdXN1YWxseSBiYXNlZCBvbiBoYXNoIG1hcC4gV2UgY2FuIGtlZXAgdGhlIHJ1bGUgdGhhdCB0aGUgaW50ZXJuYWwgaWQgYXJlIGFsd2F5cyBzdHJpbmdcclxuICAgKiAodHJlYXQgYDJgIGlzIHRoZSBzYW1lIGFzIGAnMidgKSB0byBtYWtlIHRoZSByZWxhdGVkIGxvZ2ljIHNpbXBsZS5cclxuICAgKi9cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgcmV0dXJuIGdldElkKHRoaXMsIHRoaXMuZ2V0UmF3SW5kZXgoaWR4KSk7XG4gIH07XG4gIFNlcmllc0RhdGEucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5jb3VudCgpO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgdmFsdWUuIFJldHVybiBOYU4gaWYgaWR4IGlzIG91dCBvZiByYW5nZS5cclxuICAgKlxyXG4gICAqIEBub3RpY2UgU2hvdWxkIGJldHRlciB0byB1c2UgYGRhdGEuZ2V0U3RvcmUoKS5nZXQoZGltSW5kZXgsIGRhdGFJZHgpYCBpbnN0ZWFkLlxyXG4gICAqL1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZGltLCBpZHgpIHtcbiAgICB2YXIgc3RvcmUgPSB0aGlzLl9zdG9yZTtcbiAgICB2YXIgZGltSW5mbyA9IHRoaXMuX2RpbUluZm9zW2RpbV07XG4gICAgaWYgKGRpbUluZm8pIHtcbiAgICAgIHJldHVybiBzdG9yZS5nZXQoZGltSW5mby5zdG9yZURpbUluZGV4LCBpZHgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQG5vdGljZSBTaG91bGQgYmV0dGVyIHRvIHVzZSBgZGF0YS5nZXRTdG9yZSgpLmdldEJ5UmF3SW5kZXgoZGltSW5kZXgsIGRhdGFJZHgpYCBpbnN0ZWFkLlxyXG4gICAqL1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5nZXRCeVJhd0luZGV4ID0gZnVuY3Rpb24gKGRpbSwgcmF3SWR4KSB7XG4gICAgdmFyIHN0b3JlID0gdGhpcy5fc3RvcmU7XG4gICAgdmFyIGRpbUluZm8gPSB0aGlzLl9kaW1JbmZvc1tkaW1dO1xuICAgIGlmIChkaW1JbmZvKSB7XG4gICAgICByZXR1cm4gc3RvcmUuZ2V0QnlSYXdJbmRleChkaW1JbmZvLnN0b3JlRGltSW5kZXgsIHJhd0lkeCk7XG4gICAgfVxuICB9O1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5nZXRJbmRpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5nZXRJbmRpY2VzKCk7XG4gIH07XG4gIFNlcmllc0RhdGEucHJvdG90eXBlLmdldERhdGFFeHRlbnQgPSBmdW5jdGlvbiAoZGltKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldERhdGFFeHRlbnQodGhpcy5fZ2V0U3RvcmVEaW1JbmRleChkaW0pKTtcbiAgfTtcbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuZ2V0U3VtID0gZnVuY3Rpb24gKGRpbSkge1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5nZXRTdW0odGhpcy5fZ2V0U3RvcmVEaW1JbmRleChkaW0pKTtcbiAgfTtcbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuZ2V0TWVkaWFuID0gZnVuY3Rpb24gKGRpbSkge1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5nZXRNZWRpYW4odGhpcy5fZ2V0U3RvcmVEaW1JbmRleChkaW0pKTtcbiAgfTtcbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGlkeCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHN0b3JlID0gdGhpcy5fc3RvcmU7XG4gICAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KGRpbWVuc2lvbnMpID8gc3RvcmUuZ2V0VmFsdWVzKG1hcChkaW1lbnNpb25zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICByZXR1cm4gX3RoaXMuX2dldFN0b3JlRGltSW5kZXgoZGltKTtcbiAgICB9KSwgaWR4KSA6IHN0b3JlLmdldFZhbHVlcyhkaW1lbnNpb25zKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogSWYgdmFsdWUgaXMgTmFOLiBJbmNsdWRpbmcgJy0nXHJcbiAgICogT25seSBjaGVjayB0aGUgY29vcmQgZGltZW5zaW9ucy5cclxuICAgKi9cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgdmFyIGRhdGFEaW1JbmRpY2VzT25Db29yZCA9IHRoaXMuX2RpbVN1bW1hcnkuZGF0YURpbUluZGljZXNPbkNvb3JkO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhRGltSW5kaWNlc09uQ29vcmQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIE9yZGluYWwgdHlwZSBvcmlnaW5hbGx5IGNhbiBiZSBzdHJpbmcgb3IgbnVtYmVyLlxuICAgICAgLy8gQnV0IHdoZW4gYW4gb3JkaW5hbCB0eXBlIGlzIHVzZWQgb24gY29vcmQsIGl0IGNhblxuICAgICAgLy8gbm90IGJlIHN0cmluZyBidXQgb25seSBudW1iZXIuIFNvIHdlIGNhbiBhbHNvIHVzZSBpc05hTi5cbiAgICAgIGlmIChpc05hTih0aGlzLl9zdG9yZS5nZXQoZGF0YURpbUluZGljZXNPbkNvb3JkW2ldLCBpZHgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcclxuICAgKiBSZXRyaWV2ZSB0aGUgaW5kZXggd2l0aCBnaXZlbiBuYW1lXHJcbiAgICovXG4gIFNlcmllc0RhdGEucHJvdG90eXBlLmluZGV4T2ZOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fc3RvcmUuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5nZXROYW1lKGkpID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH07XG4gIFNlcmllc0RhdGEucHJvdG90eXBlLmdldFJhd0luZGV4ID0gZnVuY3Rpb24gKGlkeCkge1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5nZXRSYXdJbmRleChpZHgpO1xuICB9O1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5pbmRleE9mUmF3SW5kZXggPSBmdW5jdGlvbiAocmF3SW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcmUuaW5kZXhPZlJhd0luZGV4KHJhd0luZGV4KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogT25seSBzdXBwb3J0IHRoZSBkaW1lbnNpb24gd2hpY2ggaW52ZXJ0ZWQgaW5kZXggY3JlYXRlZC5cclxuICAgKiBEbyBub3Qgc3VwcG9ydCBvdGhlciBjYXNlcyB1bnRpbCByZXF1aXJlZC5cclxuICAgKiBAcGFyYW0gZGltIGNvbmNyZXRlIGRpbVxyXG4gICAqIEBwYXJhbSB2YWx1ZSBvcmRpbmFsIGluZGV4XHJcbiAgICogQHJldHVybiByYXdJbmRleFxyXG4gICAqL1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5yYXdJbmRleE9mID0gZnVuY3Rpb24gKGRpbSwgdmFsdWUpIHtcbiAgICB2YXIgaW52ZXJ0ZWRJbmRpY2VzID0gZGltICYmIHRoaXMuX2ludmVydGVkSW5kaWNlc01hcFtkaW1dO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWludmVydGVkSW5kaWNlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RvIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByYXdJbmRleCA9IGludmVydGVkSW5kaWNlcyAmJiBpbnZlcnRlZEluZGljZXNbdmFsdWVdO1xuICAgIGlmIChyYXdJbmRleCA9PSBudWxsIHx8IGlzTmFOKHJhd0luZGV4KSkge1xuICAgICAgcmV0dXJuIElOREVYX05PVF9GT1VORDtcbiAgICB9XG4gICAgcmV0dXJuIHJhd0luZGV4O1xuICB9O1xuICAvKipcclxuICAgKiBSZXRyaWV2ZSB0aGUgaW5kZXggb2YgbmVhcmVzdCB2YWx1ZVxyXG4gICAqIEBwYXJhbSBkaW1cclxuICAgKiBAcGFyYW0gdmFsdWVcclxuICAgKiBAcGFyYW0gW21heERpc3RhbmNlPUluZmluaXR5XVxyXG4gICAqIEByZXR1cm4gSWYgYW5kIG9ubHkgaWYgbXVsdGlwbGUgaW5kaWNlcyBoYXNcclxuICAgKiAgICAgICAgIHRoZSBzYW1lIHZhbHVlLCB0aGV5IGFyZSBwdXQgdG8gdGhlIHJlc3VsdC5cclxuICAgKi9cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuaW5kaWNlc09mTmVhcmVzdCA9IGZ1bmN0aW9uIChkaW0sIHZhbHVlLCBtYXhEaXN0YW5jZSkge1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5pbmRpY2VzT2ZOZWFyZXN0KHRoaXMuX2dldFN0b3JlRGltSW5kZXgoZGltKSwgdmFsdWUsIG1heERpc3RhbmNlKTtcbiAgfTtcbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChkaW1zLCBjYiwgY3R4KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKGRpbXMpKSB7XG4gICAgICBjdHggPSBjYjtcbiAgICAgIGNiID0gZGltcztcbiAgICAgIGRpbXMgPSBbXTtcbiAgICB9XG4gICAgLy8gY3R4Q29tcGF0IGp1c3QgZm9yIGNvbXBhdCBlY2hhcnRzM1xuICAgIHZhciBmQ3R4ID0gY3R4IHx8IHRoaXM7XG4gICAgdmFyIGRpbUluZGljZXMgPSBtYXAobm9ybWFsaXplRGltZW5zaW9ucyhkaW1zKSwgdGhpcy5fZ2V0U3RvcmVEaW1JbmRleCwgdGhpcyk7XG4gICAgdGhpcy5fc3RvcmUuZWFjaChkaW1JbmRpY2VzLCBmQ3R4ID8genJVdGlsLmJpbmQoY2IsIGZDdHgpIDogY2IpO1xuICB9O1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5maWx0ZXJTZWxmID0gZnVuY3Rpb24gKGRpbXMsIGNiLCBjdHgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoenJVdGlsLmlzRnVuY3Rpb24oZGltcykpIHtcbiAgICAgIGN0eCA9IGNiO1xuICAgICAgY2IgPSBkaW1zO1xuICAgICAgZGltcyA9IFtdO1xuICAgIH1cbiAgICAvLyBjdHhDb21wYXQganVzdCBmb3IgY29tcGF0IGVjaGFydHMzXG4gICAgdmFyIGZDdHggPSBjdHggfHwgdGhpcztcbiAgICB2YXIgZGltSW5kaWNlcyA9IG1hcChub3JtYWxpemVEaW1lbnNpb25zKGRpbXMpLCB0aGlzLl9nZXRTdG9yZURpbUluZGV4LCB0aGlzKTtcbiAgICB0aGlzLl9zdG9yZSA9IHRoaXMuX3N0b3JlLmZpbHRlcihkaW1JbmRpY2VzLCBmQ3R4ID8genJVdGlsLmJpbmQoY2IsIGZDdHgpIDogY2IpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBTZWxlY3QgZGF0YSBpbiByYW5nZS4gKEZvciBvcHRpbWl6YXRpb24gb2YgZmlsdGVyKVxyXG4gICAqIChNYW51YWxseSBpbmxpbmUgY29kZSwgc3VwcG9ydCA1IG1pbGxpb24gZGF0YSBmaWx0ZXJpbmcgaW4gZGF0YSB6b29tLilcclxuICAgKi9cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuc2VsZWN0UmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBpbm5lclJhbmdlID0ge307XG4gICAgdmFyIGRpbXMgPSB6clV0aWwua2V5cyhyYW5nZSk7XG4gICAgdmFyIGRpbUluZGljZXMgPSBbXTtcbiAgICB6clV0aWwuZWFjaChkaW1zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICB2YXIgZGltSWR4ID0gX3RoaXMuX2dldFN0b3JlRGltSW5kZXgoZGltKTtcbiAgICAgIGlubmVyUmFuZ2VbZGltSWR4XSA9IHJhbmdlW2RpbV07XG4gICAgICBkaW1JbmRpY2VzLnB1c2goZGltSWR4KTtcbiAgICB9KTtcbiAgICB0aGlzLl9zdG9yZSA9IHRoaXMuX3N0b3JlLnNlbGVjdFJhbmdlKGlubmVyUmFuZ2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUubWFwQXJyYXkgPSBmdW5jdGlvbiAoZGltcywgY2IsIGN0eCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICh6clV0aWwuaXNGdW5jdGlvbihkaW1zKSkge1xuICAgICAgY3R4ID0gY2I7XG4gICAgICBjYiA9IGRpbXM7XG4gICAgICBkaW1zID0gW107XG4gICAgfVxuICAgIC8vIGN0eENvbXBhdCBqdXN0IGZvciBjb21wYXQgZWNoYXJ0czNcbiAgICBjdHggPSBjdHggfHwgdGhpcztcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdGhpcy5lYWNoKGRpbXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGNiICYmIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH0sIGN0eCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGRpbXMsIGNiLCBjdHgsIGN0eENvbXBhdCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIGN0eENvbXBhdCBqdXN0IGZvciBjb21wYXQgZWNoYXJ0czNcbiAgICB2YXIgZkN0eCA9IGN0eCB8fCBjdHhDb21wYXQgfHwgdGhpcztcbiAgICB2YXIgZGltSW5kaWNlcyA9IG1hcChub3JtYWxpemVEaW1lbnNpb25zKGRpbXMpLCB0aGlzLl9nZXRTdG9yZURpbUluZGV4LCB0aGlzKTtcbiAgICB2YXIgbGlzdCA9IGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZSh0aGlzKTtcbiAgICBsaXN0Ll9zdG9yZSA9IHRoaXMuX3N0b3JlLm1hcChkaW1JbmRpY2VzLCBmQ3R4ID8genJVdGlsLmJpbmQoY2IsIGZDdHgpIDogY2IpO1xuICAgIHJldHVybiBsaXN0O1xuICB9O1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5tb2RpZnkgPSBmdW5jdGlvbiAoZGltcywgY2IsIGN0eCwgY3R4Q29tcGF0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvLyBjdHhDb21wYXQganVzdCBmb3IgY29tcGF0IGVjaGFydHMzXG4gICAgdmFyIGZDdHggPSBjdHggfHwgY3R4Q29tcGF0IHx8IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHpyVXRpbC5lYWNoKG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltcyksIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgdmFyIGRpbUluZm8gPSBfdGhpcy5nZXREaW1lbnNpb25JbmZvKGRpbSk7XG4gICAgICAgIGlmICghZGltSW5mby5pc0NhbGN1bGF0aW9uQ29vcmQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdEYW5nZXI6IG9ubHkgc3RhY2sgZGltZW5zaW9uIGNhbiBiZSBtb2RpZmllZCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGRpbUluZGljZXMgPSBtYXAobm9ybWFsaXplRGltZW5zaW9ucyhkaW1zKSwgdGhpcy5fZ2V0U3RvcmVEaW1JbmRleCwgdGhpcyk7XG4gICAgLy8gSWYgZG8gc2hhbGxvdyBjbG9uZSBoZXJlLCBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgc3RhY2tlZCBzZXJpZXMsXG4gICAgLy8gaXQgc3RpbGwgY29zdCBsb3RzIG9mIG1lbW9yeSwgYmVjYXVzZSBgX3N0b3JlLmRpbWVuc2lvbnNgIGFyZSBub3Qgc2hhcmVkLlxuICAgIC8vIFdlIHNob3VsZCBjb25zaWRlciB0aGVyZSBwcm9iYWJseSBiZSBzaGFsbG93IGNsb25lIGhhcHBlbiBpbiBlYWNoIHNlcmllc1xuICAgIC8vIGluIGNvbnNlcXVlbnQgZmlsdGVyL21hcC5cbiAgICB0aGlzLl9zdG9yZS5tb2RpZnkoZGltSW5kaWNlcywgZkN0eCA/IHpyVXRpbC5iaW5kKGNiLCBmQ3R4KSA6IGNiKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogTGFyZ2UgZGF0YSBkb3duIHNhbXBsaW5nIG9uIGdpdmVuIGRpbWVuc2lvblxyXG4gICAqIEBwYXJhbSBzYW1wbGVJbmRleCBTYW1wbGUgaW5kZXggZm9yIG5hbWUgYW5kIGlkXHJcbiAgICovXG4gIFNlcmllc0RhdGEucHJvdG90eXBlLmRvd25TYW1wbGUgPSBmdW5jdGlvbiAoZGltZW5zaW9uLCByYXRlLCBzYW1wbGVWYWx1ZSwgc2FtcGxlSW5kZXgpIHtcbiAgICB2YXIgbGlzdCA9IGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZSh0aGlzKTtcbiAgICBsaXN0Ll9zdG9yZSA9IHRoaXMuX3N0b3JlLmRvd25TYW1wbGUodGhpcy5fZ2V0U3RvcmVEaW1JbmRleChkaW1lbnNpb24pLCByYXRlLCBzYW1wbGVWYWx1ZSwgc2FtcGxlSW5kZXgpO1xuICAgIHJldHVybiBsaXN0O1xuICB9O1xuICAvKipcclxuICAgKiBMYXJnZSBkYXRhIGRvd24gc2FtcGxpbmcgdXNpbmcgbWluLW1heFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZURpbWVuc2lvblxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYXRlXHJcbiAgICovXG4gIFNlcmllc0RhdGEucHJvdG90eXBlLm1pbm1heERvd25TYW1wbGUgPSBmdW5jdGlvbiAodmFsdWVEaW1lbnNpb24sIHJhdGUpIHtcbiAgICB2YXIgbGlzdCA9IGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZSh0aGlzKTtcbiAgICBsaXN0Ll9zdG9yZSA9IHRoaXMuX3N0b3JlLm1pbm1heERvd25TYW1wbGUodGhpcy5fZ2V0U3RvcmVEaW1JbmRleCh2YWx1ZURpbWVuc2lvbiksIHJhdGUpO1xuICAgIHJldHVybiBsaXN0O1xuICB9O1xuICAvKipcclxuICAgKiBMYXJnZSBkYXRhIGRvd24gc2FtcGxpbmcgdXNpbmcgbGFyZ2VzdC10cmlhbmdsZS10aHJlZS1idWNrZXRzXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlRGltZW5zaW9uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldENvdW50XHJcbiAgICovXG4gIFNlcmllc0RhdGEucHJvdG90eXBlLmx0dGJEb3duU2FtcGxlID0gZnVuY3Rpb24gKHZhbHVlRGltZW5zaW9uLCByYXRlKSB7XG4gICAgdmFyIGxpc3QgPSBjbG9uZUxpc3RGb3JNYXBBbmRTYW1wbGUodGhpcyk7XG4gICAgbGlzdC5fc3RvcmUgPSB0aGlzLl9zdG9yZS5sdHRiRG93blNhbXBsZSh0aGlzLl9nZXRTdG9yZURpbUluZGV4KHZhbHVlRGltZW5zaW9uKSwgcmF0ZSk7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH07XG4gIFNlcmllc0RhdGEucHJvdG90eXBlLmdldFJhd0RhdGFJdGVtID0gZnVuY3Rpb24gKGlkeCkge1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5nZXRSYXdEYXRhSXRlbShpZHgpO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgbW9kZWwgb2Ygb25lIGRhdGEgaXRlbS5cclxuICAgKi9cbiAgLy8gVE9ETzogVHlwZSBvZiBkYXRhIGl0ZW1cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuZ2V0SXRlbU1vZGVsID0gZnVuY3Rpb24gKGlkeCkge1xuICAgIHZhciBob3N0TW9kZWwgPSB0aGlzLmhvc3RNb2RlbDtcbiAgICB2YXIgZGF0YUl0ZW0gPSB0aGlzLmdldFJhd0RhdGFJdGVtKGlkeCk7XG4gICAgcmV0dXJuIG5ldyBNb2RlbChkYXRhSXRlbSwgaG9zdE1vZGVsLCBob3N0TW9kZWwgJiYgaG9zdE1vZGVsLmVjTW9kZWwpO1xuICB9O1xuICAvKipcclxuICAgKiBDcmVhdGUgYSBkYXRhIGRpZmZlclxyXG4gICAqL1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKG90aGVyTGlzdCkge1xuICAgIHZhciB0aGlzTGlzdCA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBEYXRhRGlmZmVyKG90aGVyTGlzdCA/IG90aGVyTGlzdC5nZXRTdG9yZSgpLmdldEluZGljZXMoKSA6IFtdLCB0aGlzLmdldFN0b3JlKCkuZ2V0SW5kaWNlcygpLCBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICByZXR1cm4gZ2V0SWQob3RoZXJMaXN0LCBpZHgpO1xuICAgIH0sIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHJldHVybiBnZXRJZCh0aGlzTGlzdCwgaWR4KTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IHZpc3VhbCBwcm9wZXJ0eS5cclxuICAgKi9cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuZ2V0VmlzdWFsID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2aXN1YWwgPSB0aGlzLl92aXN1YWw7XG4gICAgcmV0dXJuIHZpc3VhbCAmJiB2aXN1YWxba2V5XTtcbiAgfTtcbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuc2V0VmlzdWFsID0gZnVuY3Rpb24gKGt2T2JqLCB2YWwpIHtcbiAgICB0aGlzLl92aXN1YWwgPSB0aGlzLl92aXN1YWwgfHwge307XG4gICAgaWYgKGlzT2JqZWN0KGt2T2JqKSkge1xuICAgICAgenJVdGlsLmV4dGVuZCh0aGlzLl92aXN1YWwsIGt2T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdmlzdWFsW2t2T2JqXSA9IHZhbDtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCB2aXN1YWwgcHJvcGVydHkgb2Ygc2luZ2xlIGRhdGEgaXRlbVxyXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuZ2V0SXRlbVZpc3VhbCA9IGZ1bmN0aW9uIChpZHgsIGtleSkge1xuICAgIHZhciBpdGVtVmlzdWFsID0gdGhpcy5faXRlbVZpc3VhbHNbaWR4XTtcbiAgICB2YXIgdmFsID0gaXRlbVZpc3VhbCAmJiBpdGVtVmlzdWFsW2tleV07XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAvLyBVc2UgZ2xvYmFsIHZpc3VhbCBwcm9wZXJ0eVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmlzdWFsKGtleSk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH07XG4gIC8qKlxyXG4gICAqIElmIGV4aXN0cyB2aXN1YWwgcHJvcGVydHkgb2Ygc2luZ2xlIGRhdGEgaXRlbVxyXG4gICAqL1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5oYXNJdGVtVmlzdWFsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtVmlzdWFscy5sZW5ndGggPiAwO1xuICB9O1xuICAvKipcclxuICAgKiBNYWtlIHN1cmUgaXRlbVZpc3VhbCBwcm9wZXJ0eSBpcyB1bmlxdWVcclxuICAgKi9cbiAgLy8gVE9ETzogdXNlIGtleSB0byBzYXZlIHZpc3VhbCB0byByZWR1Y2UgbWVtb3J5LlxuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5lbnN1cmVVbmlxdWVJdGVtVmlzdWFsID0gZnVuY3Rpb24gKGlkeCwga2V5KSB7XG4gICAgdmFyIGl0ZW1WaXN1YWxzID0gdGhpcy5faXRlbVZpc3VhbHM7XG4gICAgdmFyIGl0ZW1WaXN1YWwgPSBpdGVtVmlzdWFsc1tpZHhdO1xuICAgIGlmICghaXRlbVZpc3VhbCkge1xuICAgICAgaXRlbVZpc3VhbCA9IGl0ZW1WaXN1YWxzW2lkeF0gPSB7fTtcbiAgICB9XG4gICAgdmFyIHZhbCA9IGl0ZW1WaXN1YWxba2V5XTtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIHZhbCA9IHRoaXMuZ2V0VmlzdWFsKGtleSk7XG4gICAgICAvLyBUT0RPIFBlcmZvcm1hbmNlP1xuICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgdmFsID0gdmFsLnNsaWNlKCk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgdmFsID0genJVdGlsLmV4dGVuZCh7fSwgdmFsKTtcbiAgICAgIH1cbiAgICAgIGl0ZW1WaXN1YWxba2V5XSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIFNlcmllc0RhdGEucHJvdG90eXBlLnNldEl0ZW1WaXN1YWwgPSBmdW5jdGlvbiAoaWR4LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGl0ZW1WaXN1YWwgPSB0aGlzLl9pdGVtVmlzdWFsc1tpZHhdIHx8IHt9O1xuICAgIHRoaXMuX2l0ZW1WaXN1YWxzW2lkeF0gPSBpdGVtVmlzdWFsO1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICB6clV0aWwuZXh0ZW5kKGl0ZW1WaXN1YWwsIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW1WaXN1YWxba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQ2xlYXIgaXRlbVZpc3VhbHMgYW5kIGxpc3QgdmlzdWFsLlxyXG4gICAqL1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5jbGVhckFsbFZpc3VhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl92aXN1YWwgPSB7fTtcbiAgICB0aGlzLl9pdGVtVmlzdWFscyA9IFtdO1xuICB9O1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5zZXRMYXlvdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICBpc09iamVjdChrZXkpID8genJVdGlsLmV4dGVuZCh0aGlzLl9sYXlvdXQsIGtleSkgOiB0aGlzLl9sYXlvdXRba2V5XSA9IHZhbDtcbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IGxheW91dCBwcm9wZXJ0eS5cclxuICAgKi9cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuZ2V0TGF5b3V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9sYXlvdXRba2V5XTtcbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IGxheW91dCBvZiBzaW5nbGUgZGF0YSBpdGVtXHJcbiAgICovXG4gIFNlcmllc0RhdGEucHJvdG90eXBlLmdldEl0ZW1MYXlvdXQgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1MYXlvdXRzW2lkeF07XG4gIH07XG4gIC8qKlxyXG4gICAqIFNldCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbVxyXG4gICAqL1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5zZXRJdGVtTGF5b3V0ID0gZnVuY3Rpb24gKGlkeCwgbGF5b3V0LCBtZXJnZSkge1xuICAgIHRoaXMuX2l0ZW1MYXlvdXRzW2lkeF0gPSBtZXJnZSA/IHpyVXRpbC5leHRlbmQodGhpcy5faXRlbUxheW91dHNbaWR4XSB8fCB7fSwgbGF5b3V0KSA6IGxheW91dDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2xlYXIgYWxsIGxheW91dCBvZiBzaW5nbGUgZGF0YSBpdGVtXHJcbiAgICovXG4gIFNlcmllc0RhdGEucHJvdG90eXBlLmNsZWFySXRlbUxheW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faXRlbUxheW91dHMubGVuZ3RoID0gMDtcbiAgfTtcbiAgLyoqXHJcbiAgICogU2V0IGdyYXBoaWMgZWxlbWVudCByZWxhdGl2ZSB0byBkYXRhLiBJdCBjYW4gYmUgc2V0IGFzIG51bGxcclxuICAgKi9cbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuc2V0SXRlbUdyYXBoaWNFbCA9IGZ1bmN0aW9uIChpZHgsIGVsKSB7XG4gICAgdmFyIHNlcmllc0luZGV4ID0gdGhpcy5ob3N0TW9kZWwgJiYgdGhpcy5ob3N0TW9kZWwuc2VyaWVzSW5kZXg7XG4gICAgc2V0Q29tbW9uRUNEYXRhKHNlcmllc0luZGV4LCB0aGlzLmRhdGFUeXBlLCBpZHgsIGVsKTtcbiAgICB0aGlzLl9ncmFwaGljRWxzW2lkeF0gPSBlbDtcbiAgfTtcbiAgU2VyaWVzRGF0YS5wcm90b3R5cGUuZ2V0SXRlbUdyYXBoaWNFbCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY0Vsc1tpZHhdO1xuICB9O1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS5lYWNoSXRlbUdyYXBoaWNFbCA9IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHpyVXRpbC5lYWNoKHRoaXMuX2dyYXBoaWNFbHMsIGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgY2IgJiYgY2IuY2FsbChjb250ZXh0LCBlbCwgaWR4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU2hhbGxvdyBjbG9uZSBhIG5ldyBsaXN0IGV4Y2VwdCB2aXN1YWwgYW5kIGxheW91dCBwcm9wZXJ0aWVzLCBhbmQgZ3JhcGggZWxlbWVudHMuXHJcbiAgICogTmV3IGxpc3Qgb25seSBjaGFuZ2UgdGhlIGluZGljZXMuXHJcbiAgICovXG4gIFNlcmllc0RhdGEucHJvdG90eXBlLmNsb25lU2hhbGxvdyA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgaWYgKCFsaXN0KSB7XG4gICAgICBsaXN0ID0gbmV3IFNlcmllc0RhdGEodGhpcy5fc2NoZW1hID8gdGhpcy5fc2NoZW1hIDogbWFwKHRoaXMuZGltZW5zaW9ucywgdGhpcy5fZ2V0RGltSW5mbywgdGhpcyksIHRoaXMuaG9zdE1vZGVsKTtcbiAgICB9XG4gICAgdHJhbnNmZXJQcm9wZXJ0aWVzKGxpc3QsIHRoaXMpO1xuICAgIGxpc3QuX3N0b3JlID0gdGhpcy5fc3RvcmU7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH07XG4gIC8qKlxyXG4gICAqIFdyYXAgc29tZSBtZXRob2QgdG8gYWRkIG1vcmUgZmVhdHVyZVxyXG4gICAqL1xuICBTZXJpZXNEYXRhLnByb3RvdHlwZS53cmFwTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluamVjdEZ1bmN0aW9uKSB7XG4gICAgdmFyIG9yaWdpbmFsTWV0aG9kID0gdGhpc1ttZXRob2ROYW1lXTtcbiAgICBpZiAoIXpyVXRpbC5pc0Z1bmN0aW9uKG9yaWdpbmFsTWV0aG9kKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9fd3JhcHBlZE1ldGhvZHMgPSB0aGlzLl9fd3JhcHBlZE1ldGhvZHMgfHwgW107XG4gICAgdGhpcy5fX3dyYXBwZWRNZXRob2RzLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgdGhpc1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZXMgPSBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGluamVjdEZ1bmN0aW9uLmFwcGx5KHRoaXMsIFtyZXNdLmNvbmNhdCh6clV0aWwuc2xpY2UoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gIH07XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQSB3b3JrIGFyb3VuZCBmb3IgaW50ZXJuYWwgbWV0aG9kIHZpc2l0aW5nIHByaXZhdGUgbWVtYmVyLlxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIFNlcmllc0RhdGEuaW50ZXJuYWxGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcmVwYXJlSW52ZXJ0ZWRJbmRleCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgaW52ZXJ0ZWRJbmRpY2VzTWFwID0gZGF0YS5faW52ZXJ0ZWRJbmRpY2VzTWFwO1xuICAgICAgenJVdGlsLmVhY2goaW52ZXJ0ZWRJbmRpY2VzTWFwLCBmdW5jdGlvbiAoaW52ZXJ0ZWRJbmRpY2VzLCBkaW0pIHtcbiAgICAgICAgdmFyIGRpbUluZm8gPSBkYXRhLl9kaW1JbmZvc1tkaW1dO1xuICAgICAgICAvLyBDdXJyZW50bHksIG9ubHkgZGltZW5zaW9ucyB0aGF0IGhhcyBvcmRpbmFsTWV0YSBjYW4gY3JlYXRlIGludmVydGVkIGluZGljZXMuXG4gICAgICAgIHZhciBvcmRpbmFsTWV0YSA9IGRpbUluZm8ub3JkaW5hbE1ldGE7XG4gICAgICAgIHZhciBzdG9yZSA9IGRhdGEuX3N0b3JlO1xuICAgICAgICBpZiAob3JkaW5hbE1ldGEpIHtcbiAgICAgICAgICBpbnZlcnRlZEluZGljZXMgPSBpbnZlcnRlZEluZGljZXNNYXBbZGltXSA9IG5ldyBDdG9ySW50MzJBcnJheShvcmRpbmFsTWV0YS5jYXRlZ29yaWVzLmxlbmd0aCk7XG4gICAgICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgb2YgVHlwZWRBcnJheSBpcyAwLiBUbyBhdm9pZCBtaXNzXG4gICAgICAgICAgLy8gbWFwcGluZyB0byAwLCB3ZSBzaG91bGQgc2V0IGl0IGFzIElOREVYX05PVF9GT1VORC5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludmVydGVkSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW52ZXJ0ZWRJbmRpY2VzW2ldID0gSU5ERVhfTk9UX0ZPVU5EO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3JlLmNvdW50KCk7IGkrKykge1xuICAgICAgICAgICAgLy8gT25seSBzdXBwb3J0IHRoZSBjYXNlIHRoYXQgYWxsIHZhbHVlcyBhcmUgZGlzdGluY3QuXG4gICAgICAgICAgICBpbnZlcnRlZEluZGljZXNbc3RvcmUuZ2V0KGRpbUluZm8uc3RvcmVEaW1JbmRleCwgaSldID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgZ2V0SWROYW1lRnJvbVN0b3JlID0gZnVuY3Rpb24gKGRhdGEsIGRpbUlkeCwgaWR4KSB7XG4gICAgICByZXR1cm4gY29udmVydE9wdGlvbklkTmFtZShkYXRhLl9nZXRDYXRlZ29yeShkaW1JZHgsIGlkeCksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBAc2VlIHRoZSBjb21tZW50IG9mIGBMaXN0WydnZXRJZCddYC5cclxuICAgICAqL1xuICAgIGdldElkID0gZnVuY3Rpb24gKGRhdGEsIHJhd0luZGV4KSB7XG4gICAgICB2YXIgaWQgPSBkYXRhLl9pZExpc3RbcmF3SW5kZXhdO1xuICAgICAgaWYgKGlkID09IG51bGwgJiYgZGF0YS5faWREaW1JZHggIT0gbnVsbCkge1xuICAgICAgICBpZCA9IGdldElkTmFtZUZyb21TdG9yZShkYXRhLCBkYXRhLl9pZERpbUlkeCwgcmF3SW5kZXgpO1xuICAgICAgfVxuICAgICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgaWQgPSBJRF9QUkVGSVggKyByYXdJbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuICAgIG5vcm1hbGl6ZURpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZGltZW5zaW9ucykge1xuICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShkaW1lbnNpb25zKSkge1xuICAgICAgICBkaW1lbnNpb25zID0gZGltZW5zaW9ucyAhPSBudWxsID8gW2RpbWVuc2lvbnNdIDogW107XG4gICAgICB9XG4gICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogRGF0YSBpbiBleGNsdWRlRGltZW5zaW9ucyBpcyBjb3BpZWQsIG90aGVyd2lzZSB0cmFuc2ZlcnJlZC5cclxuICAgICAqL1xuICAgIGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZSA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICAgICAgdmFyIGxpc3QgPSBuZXcgU2VyaWVzRGF0YShvcmlnaW5hbC5fc2NoZW1hID8gb3JpZ2luYWwuX3NjaGVtYSA6IG1hcChvcmlnaW5hbC5kaW1lbnNpb25zLCBvcmlnaW5hbC5fZ2V0RGltSW5mbywgb3JpZ2luYWwpLCBvcmlnaW5hbC5ob3N0TW9kZWwpO1xuICAgICAgLy8gRklYTUUgSWYgbmVlZHMgc3RhY2tlZE9uLCB2YWx1ZSBtYXkgYWxyZWFkeSBiZWVuIHN0YWNrZWRcbiAgICAgIHRyYW5zZmVyUHJvcGVydGllcyhsaXN0LCBvcmlnaW5hbCk7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuICAgIHRyYW5zZmVyUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgenJVdGlsLmVhY2goVFJBTlNGRVJBQkxFX1BST1BFUlRJRVMuY29uY2F0KHNvdXJjZS5fX3dyYXBwZWRNZXRob2RzIHx8IFtdKSwgZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgdGFyZ2V0W3Byb3BOYW1lXSA9IHNvdXJjZVtwcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGFyZ2V0Ll9fd3JhcHBlZE1ldGhvZHMgPSBzb3VyY2UuX193cmFwcGVkTWV0aG9kcztcbiAgICAgIHpyVXRpbC5lYWNoKENMT05FX1BST1BFUlRJRVMsIGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICB0YXJnZXRbcHJvcE5hbWVdID0genJVdGlsLmNsb25lKHNvdXJjZVtwcm9wTmFtZV0pO1xuICAgICAgfSk7XG4gICAgICB0YXJnZXQuX2NhbGN1bGF0aW9uSW5mbyA9IHpyVXRpbC5leHRlbmQoe30sIHNvdXJjZS5fY2FsY3VsYXRpb25JbmZvKTtcbiAgICB9O1xuICAgIG1ha2VJZEZyb21OYW1lID0gZnVuY3Rpb24gKGRhdGEsIGlkeCkge1xuICAgICAgdmFyIG5hbWVMaXN0ID0gZGF0YS5fbmFtZUxpc3Q7XG4gICAgICB2YXIgaWRMaXN0ID0gZGF0YS5faWRMaXN0O1xuICAgICAgdmFyIG5hbWVEaW1JZHggPSBkYXRhLl9uYW1lRGltSWR4O1xuICAgICAgdmFyIGlkRGltSWR4ID0gZGF0YS5faWREaW1JZHg7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVMaXN0W2lkeF07XG4gICAgICB2YXIgaWQgPSBpZExpc3RbaWR4XTtcbiAgICAgIGlmIChuYW1lID09IG51bGwgJiYgbmFtZURpbUlkeCAhPSBudWxsKSB7XG4gICAgICAgIG5hbWVMaXN0W2lkeF0gPSBuYW1lID0gZ2V0SWROYW1lRnJvbVN0b3JlKGRhdGEsIG5hbWVEaW1JZHgsIGlkeCk7XG4gICAgICB9XG4gICAgICBpZiAoaWQgPT0gbnVsbCAmJiBpZERpbUlkeCAhPSBudWxsKSB7XG4gICAgICAgIGlkTGlzdFtpZHhdID0gaWQgPSBnZXRJZE5hbWVGcm9tU3RvcmUoZGF0YSwgaWREaW1JZHgsIGlkeCk7XG4gICAgICB9XG4gICAgICBpZiAoaWQgPT0gbnVsbCAmJiBuYW1lICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG5hbWVSZXBlYXRDb3VudCA9IGRhdGEuX25hbWVSZXBlYXRDb3VudDtcbiAgICAgICAgdmFyIG5tQ250ID0gbmFtZVJlcGVhdENvdW50W25hbWVdID0gKG5hbWVSZXBlYXRDb3VudFtuYW1lXSB8fCAwKSArIDE7XG4gICAgICAgIGlkID0gbmFtZTtcbiAgICAgICAgaWYgKG5tQ250ID4gMSkge1xuICAgICAgICAgIGlkICs9ICdfX2VjX18nICsgbm1DbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWRMaXN0W2lkeF0gPSBpZDtcbiAgICAgIH1cbiAgICB9O1xuICB9KCk7XG4gIHJldHVybiBTZXJpZXNEYXRhO1xufSgpO1xuZXhwb3J0IGRlZmF1bHQgU2VyaWVzRGF0YTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6006\n")},15135:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar uidBase = 0;\nvar OrdinalMeta = /** @class */function () {\n  function OrdinalMeta(opt) {\n    this.categories = opt.categories || [];\n    this._needCollect = opt.needCollect;\n    this._deduplication = opt.deduplication;\n    this.uid = ++uidBase;\n  }\n  OrdinalMeta.createByAxisModel = function (axisModel) {\n    var option = axisModel.option;\n    var data = option.data;\n    var categories = data && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)(data, getName);\n    return new OrdinalMeta({\n      categories: categories,\n      needCollect: !categories,\n      // deduplication is default in axis.\n      deduplication: option.dedplication !== false\n    });\n  };\n  ;\n  OrdinalMeta.prototype.getOrdinal = function (category) {\n    // @ts-ignore\n    return this._getOrCreateMap().get(category);\n  };\n  /**\r\n   * @return The ordinal. If not found, return NaN.\r\n   */\n  OrdinalMeta.prototype.parseAndCollect = function (category) {\n    var index;\n    var needCollect = this._needCollect;\n    // The value of category dim can be the index of the given category set.\n    // This feature is only supported when !needCollect, because we should\n    // consider a common case: a value is 2017, which is a number but is\n    // expected to be tread as a category. This case usually happen in dataset,\n    // where it happent to be no need of the index feature.\n    if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString)(category) && !needCollect) {\n      return category;\n    }\n    // Optimize for the scenario:\n    // category is [\'2012-01-01\', \'2012-01-02\', ...], where the input\n    // data has been ensured not duplicate and is large data.\n    // Notice, if a dataset dimension provide categroies, usually echarts\n    // should remove duplication except user tell echarts dont do that\n    // (set axis.deduplication = false), because echarts do not know whether\n    // the values in the category dimension has duplication (consider the\n    // parallel-aqi example)\n    if (needCollect && !this._deduplication) {\n      index = this.categories.length;\n      this.categories[index] = category;\n      return index;\n    }\n    var map = this._getOrCreateMap();\n    // @ts-ignore\n    index = map.get(category);\n    if (index == null) {\n      if (needCollect) {\n        index = this.categories.length;\n        this.categories[index] = category;\n        // @ts-ignore\n        map.set(category, index);\n      } else {\n        index = NaN;\n      }\n    }\n    return index;\n  };\n  // Consider big data, do not create map until needed.\n  OrdinalMeta.prototype._getOrCreateMap = function () {\n    return this._map || (this._map = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)(this.categories));\n  };\n  return OrdinalMeta;\n}();\nfunction getName(obj) {\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(obj) && obj.value != null) {\n    return obj.value;\n  } else {\n    return obj + \'\';\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrdinalMeta);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUxMzUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvT3JkaW5hbE1ldGEuanM/NmY5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGNyZWF0ZUhhc2hNYXAsIGlzT2JqZWN0LCBtYXAsIGlzU3RyaW5nIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbnZhciB1aWRCYXNlID0gMDtcbnZhciBPcmRpbmFsTWV0YSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9yZGluYWxNZXRhKG9wdCkge1xuICAgIHRoaXMuY2F0ZWdvcmllcyA9IG9wdC5jYXRlZ29yaWVzIHx8IFtdO1xuICAgIHRoaXMuX25lZWRDb2xsZWN0ID0gb3B0Lm5lZWRDb2xsZWN0O1xuICAgIHRoaXMuX2RlZHVwbGljYXRpb24gPSBvcHQuZGVkdXBsaWNhdGlvbjtcbiAgICB0aGlzLnVpZCA9ICsrdWlkQmFzZTtcbiAgfVxuICBPcmRpbmFsTWV0YS5jcmVhdGVCeUF4aXNNb2RlbCA9IGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICB2YXIgb3B0aW9uID0gYXhpc01vZGVsLm9wdGlvbjtcbiAgICB2YXIgZGF0YSA9IG9wdGlvbi5kYXRhO1xuICAgIHZhciBjYXRlZ29yaWVzID0gZGF0YSAmJiBtYXAoZGF0YSwgZ2V0TmFtZSk7XG4gICAgcmV0dXJuIG5ldyBPcmRpbmFsTWV0YSh7XG4gICAgICBjYXRlZ29yaWVzOiBjYXRlZ29yaWVzLFxuICAgICAgbmVlZENvbGxlY3Q6ICFjYXRlZ29yaWVzLFxuICAgICAgLy8gZGVkdXBsaWNhdGlvbiBpcyBkZWZhdWx0IGluIGF4aXMuXG4gICAgICBkZWR1cGxpY2F0aW9uOiBvcHRpb24uZGVkcGxpY2F0aW9uICE9PSBmYWxzZVxuICAgIH0pO1xuICB9O1xuICA7XG4gIE9yZGluYWxNZXRhLnByb3RvdHlwZS5nZXRPcmRpbmFsID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZU1hcCgpLmdldChjYXRlZ29yeSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEByZXR1cm4gVGhlIG9yZGluYWwuIElmIG5vdCBmb3VuZCwgcmV0dXJuIE5hTi5cclxuICAgKi9cbiAgT3JkaW5hbE1ldGEucHJvdG90eXBlLnBhcnNlQW5kQ29sbGVjdCA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgIHZhciBpbmRleDtcbiAgICB2YXIgbmVlZENvbGxlY3QgPSB0aGlzLl9uZWVkQ29sbGVjdDtcbiAgICAvLyBUaGUgdmFsdWUgb2YgY2F0ZWdvcnkgZGltIGNhbiBiZSB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIGNhdGVnb3J5IHNldC5cbiAgICAvLyBUaGlzIGZlYXR1cmUgaXMgb25seSBzdXBwb3J0ZWQgd2hlbiAhbmVlZENvbGxlY3QsIGJlY2F1c2Ugd2Ugc2hvdWxkXG4gICAgLy8gY29uc2lkZXIgYSBjb21tb24gY2FzZTogYSB2YWx1ZSBpcyAyMDE3LCB3aGljaCBpcyBhIG51bWJlciBidXQgaXNcbiAgICAvLyBleHBlY3RlZCB0byBiZSB0cmVhZCBhcyBhIGNhdGVnb3J5LiBUaGlzIGNhc2UgdXN1YWxseSBoYXBwZW4gaW4gZGF0YXNldCxcbiAgICAvLyB3aGVyZSBpdCBoYXBwZW50IHRvIGJlIG5vIG5lZWQgb2YgdGhlIGluZGV4IGZlYXR1cmUuXG4gICAgaWYgKCFpc1N0cmluZyhjYXRlZ29yeSkgJiYgIW5lZWRDb2xsZWN0KSB7XG4gICAgICByZXR1cm4gY2F0ZWdvcnk7XG4gICAgfVxuICAgIC8vIE9wdGltaXplIGZvciB0aGUgc2NlbmFyaW86XG4gICAgLy8gY2F0ZWdvcnkgaXMgWycyMDEyLTAxLTAxJywgJzIwMTItMDEtMDInLCAuLi5dLCB3aGVyZSB0aGUgaW5wdXRcbiAgICAvLyBkYXRhIGhhcyBiZWVuIGVuc3VyZWQgbm90IGR1cGxpY2F0ZSBhbmQgaXMgbGFyZ2UgZGF0YS5cbiAgICAvLyBOb3RpY2UsIGlmIGEgZGF0YXNldCBkaW1lbnNpb24gcHJvdmlkZSBjYXRlZ3JvaWVzLCB1c3VhbGx5IGVjaGFydHNcbiAgICAvLyBzaG91bGQgcmVtb3ZlIGR1cGxpY2F0aW9uIGV4Y2VwdCB1c2VyIHRlbGwgZWNoYXJ0cyBkb250IGRvIHRoYXRcbiAgICAvLyAoc2V0IGF4aXMuZGVkdXBsaWNhdGlvbiA9IGZhbHNlKSwgYmVjYXVzZSBlY2hhcnRzIGRvIG5vdCBrbm93IHdoZXRoZXJcbiAgICAvLyB0aGUgdmFsdWVzIGluIHRoZSBjYXRlZ29yeSBkaW1lbnNpb24gaGFzIGR1cGxpY2F0aW9uIChjb25zaWRlciB0aGVcbiAgICAvLyBwYXJhbGxlbC1hcWkgZXhhbXBsZSlcbiAgICBpZiAobmVlZENvbGxlY3QgJiYgIXRoaXMuX2RlZHVwbGljYXRpb24pIHtcbiAgICAgIGluZGV4ID0gdGhpcy5jYXRlZ29yaWVzLmxlbmd0aDtcbiAgICAgIHRoaXMuY2F0ZWdvcmllc1tpbmRleF0gPSBjYXRlZ29yeTtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgdmFyIG1hcCA9IHRoaXMuX2dldE9yQ3JlYXRlTWFwKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGluZGV4ID0gbWFwLmdldChjYXRlZ29yeSk7XG4gICAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICAgIGlmIChuZWVkQ29sbGVjdCkge1xuICAgICAgICBpbmRleCA9IHRoaXMuY2F0ZWdvcmllcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuY2F0ZWdvcmllc1tpbmRleF0gPSBjYXRlZ29yeTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBtYXAuc2V0KGNhdGVnb3J5LCBpbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IE5hTjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xuICAvLyBDb25zaWRlciBiaWcgZGF0YSwgZG8gbm90IGNyZWF0ZSBtYXAgdW50aWwgbmVlZGVkLlxuICBPcmRpbmFsTWV0YS5wcm90b3R5cGUuX2dldE9yQ3JlYXRlTWFwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAgfHwgKHRoaXMuX21hcCA9IGNyZWF0ZUhhc2hNYXAodGhpcy5jYXRlZ29yaWVzKSk7XG4gIH07XG4gIHJldHVybiBPcmRpbmFsTWV0YTtcbn0oKTtcbmZ1bmN0aW9uIGdldE5hbWUob2JqKSB7XG4gIGlmIChpc09iamVjdChvYmopICYmIG9iai52YWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG9iai52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqICsgJyc7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IE9yZGluYWxNZXRhOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15135\n')},15719:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony export TreeNode */\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _helper_linkSeriesData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(76827);\n/* harmony import */ var _SeriesData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6006);\n/* harmony import */ var _helper_createDimensions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97351);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * Tree data structure\r\n */\n\n\n\n\n\nvar TreeNode = /** @class */function () {\n  function TreeNode(name, hostTree) {\n    this.depth = 0;\n    this.height = 0;\n    /**\r\n     * Reference to list item.\r\n     * Do not persistent dataIndex outside,\r\n     * besause it may be changed by list.\r\n     * If dataIndex -1,\r\n     * this node is logical deleted (filtered) in list.\r\n     */\n    this.dataIndex = -1;\n    this.children = [];\n    this.viewChildren = [];\n    this.isExpand = false;\n    this.name = name || '';\n    this.hostTree = hostTree;\n  }\n  /**\r\n   * The node is removed.\r\n   */\n  TreeNode.prototype.isRemoved = function () {\n    return this.dataIndex < 0;\n  };\n  TreeNode.prototype.eachNode = function (options, cb, context) {\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isFunction(options)) {\n      context = cb;\n      cb = options;\n      options = null;\n    }\n    options = options || {};\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString(options)) {\n      options = {\n        order: options\n      };\n    }\n    var order = options.order || 'preorder';\n    var children = this[options.attr || 'children'];\n    var suppressVisitSub;\n    order === 'preorder' && (suppressVisitSub = cb.call(context, this));\n    for (var i = 0; !suppressVisitSub && i < children.length; i++) {\n      children[i].eachNode(options, cb, context);\n    }\n    order === 'postorder' && cb.call(context, this);\n  };\n  /**\r\n   * Update depth and height of this subtree.\r\n   */\n  TreeNode.prototype.updateDepthAndHeight = function (depth) {\n    var height = 0;\n    this.depth = depth;\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n      child.updateDepthAndHeight(depth + 1);\n      if (child.height > height) {\n        height = child.height;\n      }\n    }\n    this.height = height + 1;\n  };\n  TreeNode.prototype.getNodeById = function (id) {\n    if (this.getId() === id) {\n      return this;\n    }\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].getNodeById(id);\n      if (res) {\n        return res;\n      }\n    }\n  };\n  TreeNode.prototype.contains = function (node) {\n    if (node === this) {\n      return true;\n    }\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].contains(node);\n      if (res) {\n        return res;\n      }\n    }\n  };\n  /**\r\n   * @param includeSelf Default false.\r\n   * @return order: [root, child, grandchild, ...]\r\n   */\n  TreeNode.prototype.getAncestors = function (includeSelf) {\n    var ancestors = [];\n    var node = includeSelf ? this : this.parentNode;\n    while (node) {\n      ancestors.push(node);\n      node = node.parentNode;\n    }\n    ancestors.reverse();\n    return ancestors;\n  };\n  TreeNode.prototype.getAncestorsIndices = function () {\n    var indices = [];\n    var currNode = this;\n    while (currNode) {\n      indices.push(currNode.dataIndex);\n      currNode = currNode.parentNode;\n    }\n    indices.reverse();\n    return indices;\n  };\n  TreeNode.prototype.getDescendantIndices = function () {\n    var indices = [];\n    this.eachNode(function (childNode) {\n      indices.push(childNode.dataIndex);\n    });\n    return indices;\n  };\n  TreeNode.prototype.getValue = function (dimension) {\n    var data = this.hostTree.data;\n    return data.getStore().get(data.getDimensionIndex(dimension || 'value'), this.dataIndex);\n  };\n  TreeNode.prototype.setLayout = function (layout, merge) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);\n  };\n  /**\r\n   * @return {Object} layout\r\n   */\n  TreeNode.prototype.getLayout = function () {\n    return this.hostTree.data.getItemLayout(this.dataIndex);\n  };\n  // @depcrecated\n  // getModel<T = unknown, S extends keyof T = keyof T>(path: S): Model<T[S]>\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TreeNode.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n    var hostTree = this.hostTree;\n    var itemModel = hostTree.data.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  };\n  // TODO: TYPE More specific model\n  TreeNode.prototype.getLevelModel = function () {\n    return (this.hostTree.levelModels || [])[this.depth];\n  };\n  TreeNode.prototype.setVisual = function (key, value) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);\n  };\n  /**\r\n   * Get item visual\r\n   * FIXME: make return type better\r\n   */\n  TreeNode.prototype.getVisual = function (key) {\n    return this.hostTree.data.getItemVisual(this.dataIndex, key);\n  };\n  TreeNode.prototype.getRawIndex = function () {\n    return this.hostTree.data.getRawIndex(this.dataIndex);\n  };\n  TreeNode.prototype.getId = function () {\n    return this.hostTree.data.getId(this.dataIndex);\n  };\n  /**\r\n   * index in parent's children\r\n   */\n  TreeNode.prototype.getChildIndex = function () {\n    if (this.parentNode) {\n      var children = this.parentNode.children;\n      for (var i = 0; i < children.length; ++i) {\n        if (children[i] === this) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    return -1;\n  };\n  /**\r\n   * if this is an ancestor of another node\r\n   *\r\n   * @param node another node\r\n   * @return if is ancestor\r\n   */\n  TreeNode.prototype.isAncestorOf = function (node) {\n    var parent = node.parentNode;\n    while (parent) {\n      if (parent === this) {\n        return true;\n      }\n      parent = parent.parentNode;\n    }\n    return false;\n  };\n  /**\r\n   * if this is an descendant of another node\r\n   *\r\n   * @param node another node\r\n   * @return if is descendant\r\n   */\n  TreeNode.prototype.isDescendantOf = function (node) {\n    return node !== this && node.isAncestorOf(this);\n  };\n  return TreeNode;\n}();\n\n;\nvar Tree = /** @class */function () {\n  function Tree(hostModel) {\n    this.type = 'tree';\n    this._nodes = [];\n    this.hostModel = hostModel;\n  }\n  Tree.prototype.eachNode = function (options, cb, context) {\n    this.root.eachNode(options, cb, context);\n  };\n  Tree.prototype.getNodeByDataIndex = function (dataIndex) {\n    var rawIndex = this.data.getRawIndex(dataIndex);\n    return this._nodes[rawIndex];\n  };\n  Tree.prototype.getNodeById = function (name) {\n    return this.root.getNodeById(name);\n  };\n  /**\r\n   * Update item available by list,\r\n   * when list has been performed options like 'filterSelf' or 'map'.\r\n   */\n  Tree.prototype.update = function () {\n    var data = this.data;\n    var nodes = this._nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].dataIndex = -1;\n    }\n    for (var i = 0, len = data.count(); i < len; i++) {\n      nodes[data.getRawIndex(i)].dataIndex = i;\n    }\n  };\n  /**\r\n   * Clear all layouts\r\n   */\n  Tree.prototype.clearLayouts = function () {\n    this.data.clearItemLayouts();\n  };\n  /**\r\n   * data node format:\r\n   * {\r\n   *     name: ...\r\n   *     value: ...\r\n   *     children: [\r\n   *         {\r\n   *             name: ...\r\n   *             value: ...\r\n   *             children: ...\r\n   *         },\r\n   *         ...\r\n   *     ]\r\n   * }\r\n   */\n  Tree.createTree = function (dataRoot, hostModel, beforeLink) {\n    var tree = new Tree(hostModel);\n    var listData = [];\n    var dimMax = 1;\n    buildHierarchy(dataRoot);\n    function buildHierarchy(dataNode, parentNode) {\n      var value = dataNode.value;\n      dimMax = Math.max(dimMax, zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray(value) ? value.length : 1);\n      listData.push(dataNode);\n      var node = new TreeNode((0,_util_model_js__WEBPACK_IMPORTED_MODULE_1__/* .convertOptionIdName */ .vS)(dataNode.name, ''), tree);\n      parentNode ? addChild(node, parentNode) : tree.root = node;\n      tree._nodes.push(node);\n      var children = dataNode.children;\n      if (children) {\n        for (var i = 0; i < children.length; i++) {\n          buildHierarchy(children[i], node);\n        }\n      }\n    }\n    tree.root.updateDepthAndHeight(0);\n    var dimensions = (0,_helper_createDimensions_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A)(listData, {\n      coordDimensions: ['value'],\n      dimensionsCount: dimMax\n    }).dimensions;\n    var list = new _SeriesData_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A(dimensions, hostModel);\n    list.initData(listData);\n    beforeLink && beforeLink(list);\n    (0,_helper_linkSeriesData_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A)({\n      mainData: list,\n      struct: tree,\n      structAttr: 'tree'\n    });\n    tree.update();\n    return tree;\n  };\n  return Tree;\n}();\n/**\r\n * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,\r\n * so this function is not ready and not necessary to be public.\r\n */\nfunction addChild(child, node) {\n  var children = node.children;\n  if (child.parentNode === node) {\n    return;\n  }\n  children.push(child);\n  child.parentNode = node;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tree);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU3MTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL1RyZWUuanM/MDIxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbi8qKlxyXG4gKiBUcmVlIGRhdGEgc3RydWN0dXJlXHJcbiAqL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgbGlua1Nlcmllc0RhdGEgZnJvbSAnLi9oZWxwZXIvbGlua1Nlcmllc0RhdGEuanMnO1xuaW1wb3J0IFNlcmllc0RhdGEgZnJvbSAnLi9TZXJpZXNEYXRhLmpzJztcbmltcG9ydCBwcmVwYXJlU2VyaWVzRGF0YVNjaGVtYSBmcm9tICcuL2hlbHBlci9jcmVhdGVEaW1lbnNpb25zLmpzJztcbmltcG9ydCB7IGNvbnZlcnRPcHRpb25JZE5hbWUgfSBmcm9tICcuLi91dGlsL21vZGVsLmpzJztcbnZhciBUcmVlTm9kZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyZWVOb2RlKG5hbWUsIGhvc3RUcmVlKSB7XG4gICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIGxpc3QgaXRlbS5cclxuICAgICAqIERvIG5vdCBwZXJzaXN0ZW50IGRhdGFJbmRleCBvdXRzaWRlLFxyXG4gICAgICogYmVzYXVzZSBpdCBtYXkgYmUgY2hhbmdlZCBieSBsaXN0LlxyXG4gICAgICogSWYgZGF0YUluZGV4IC0xLFxyXG4gICAgICogdGhpcyBub2RlIGlzIGxvZ2ljYWwgZGVsZXRlZCAoZmlsdGVyZWQpIGluIGxpc3QuXHJcbiAgICAgKi9cbiAgICB0aGlzLmRhdGFJbmRleCA9IC0xO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLnZpZXdDaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuaXNFeHBhbmQgPSBmYWxzZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdFRyZWUgPSBob3N0VHJlZTtcbiAgfVxuICAvKipcclxuICAgKiBUaGUgbm9kZSBpcyByZW1vdmVkLlxyXG4gICAqL1xuICBUcmVlTm9kZS5wcm90b3R5cGUuaXNSZW1vdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFJbmRleCA8IDA7XG4gIH07XG4gIFRyZWVOb2RlLnByb3RvdHlwZS5lYWNoTm9kZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYiwgY29udGV4dCkge1xuICAgIGlmICh6clV0aWwuaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgY29udGV4dCA9IGNiO1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh6clV0aWwuaXNTdHJpbmcob3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIG9yZGVyOiBvcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgb3JkZXIgPSBvcHRpb25zLm9yZGVyIHx8ICdwcmVvcmRlcic7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpc1tvcHRpb25zLmF0dHIgfHwgJ2NoaWxkcmVuJ107XG4gICAgdmFyIHN1cHByZXNzVmlzaXRTdWI7XG4gICAgb3JkZXIgPT09ICdwcmVvcmRlcicgJiYgKHN1cHByZXNzVmlzaXRTdWIgPSBjYi5jYWxsKGNvbnRleHQsIHRoaXMpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgIXN1cHByZXNzVmlzaXRTdWIgJiYgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZHJlbltpXS5lYWNoTm9kZShvcHRpb25zLCBjYiwgY29udGV4dCk7XG4gICAgfVxuICAgIG9yZGVyID09PSAncG9zdG9yZGVyJyAmJiBjYi5jYWxsKGNvbnRleHQsIHRoaXMpO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgZGVwdGggYW5kIGhlaWdodCBvZiB0aGlzIHN1YnRyZWUuXHJcbiAgICovXG4gIFRyZWVOb2RlLnByb3RvdHlwZS51cGRhdGVEZXB0aEFuZEhlaWdodCA9IGZ1bmN0aW9uIChkZXB0aCkge1xuICAgIHZhciBoZWlnaHQgPSAwO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBjaGlsZC51cGRhdGVEZXB0aEFuZEhlaWdodChkZXB0aCArIDEpO1xuICAgICAgaWYgKGNoaWxkLmhlaWdodCA+IGhlaWdodCkge1xuICAgICAgICBoZWlnaHQgPSBjaGlsZC5oZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICsgMTtcbiAgfTtcbiAgVHJlZU5vZGUucHJvdG90eXBlLmdldE5vZGVCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgaWYgKHRoaXMuZ2V0SWQoKSA9PT0gaWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHJlcyA9IGNoaWxkcmVuW2ldLmdldE5vZGVCeUlkKGlkKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFRyZWVOb2RlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHJlcyA9IGNoaWxkcmVuW2ldLmNvbnRhaW5zKG5vZGUpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQHBhcmFtIGluY2x1ZGVTZWxmIERlZmF1bHQgZmFsc2UuXHJcbiAgICogQHJldHVybiBvcmRlcjogW3Jvb3QsIGNoaWxkLCBncmFuZGNoaWxkLCAuLi5dXHJcbiAgICovXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5nZXRBbmNlc3RvcnMgPSBmdW5jdGlvbiAoaW5jbHVkZVNlbGYpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gW107XG4gICAgdmFyIG5vZGUgPSBpbmNsdWRlU2VsZiA/IHRoaXMgOiB0aGlzLnBhcmVudE5vZGU7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgYW5jZXN0b3JzLnJldmVyc2UoKTtcbiAgICByZXR1cm4gYW5jZXN0b3JzO1xuICB9O1xuICBUcmVlTm9kZS5wcm90b3R5cGUuZ2V0QW5jZXN0b3JzSW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIHZhciBjdXJyTm9kZSA9IHRoaXM7XG4gICAgd2hpbGUgKGN1cnJOb2RlKSB7XG4gICAgICBpbmRpY2VzLnB1c2goY3Vyck5vZGUuZGF0YUluZGV4KTtcbiAgICAgIGN1cnJOb2RlID0gY3Vyck5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgaW5kaWNlcy5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH07XG4gIFRyZWVOb2RlLnByb3RvdHlwZS5nZXREZXNjZW5kYW50SW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIHRoaXMuZWFjaE5vZGUoZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgaW5kaWNlcy5wdXNoKGNoaWxkTm9kZS5kYXRhSW5kZXgpO1xuICAgIH0pO1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9O1xuICBUcmVlTm9kZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoZGltZW5zaW9uKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmhvc3RUcmVlLmRhdGE7XG4gICAgcmV0dXJuIGRhdGEuZ2V0U3RvcmUoKS5nZXQoZGF0YS5nZXREaW1lbnNpb25JbmRleChkaW1lbnNpb24gfHwgJ3ZhbHVlJyksIHRoaXMuZGF0YUluZGV4KTtcbiAgfTtcbiAgVHJlZU5vZGUucHJvdG90eXBlLnNldExheW91dCA9IGZ1bmN0aW9uIChsYXlvdXQsIG1lcmdlKSB7XG4gICAgdGhpcy5kYXRhSW5kZXggPj0gMCAmJiB0aGlzLmhvc3RUcmVlLmRhdGEuc2V0SXRlbUxheW91dCh0aGlzLmRhdGFJbmRleCwgbGF5b3V0LCBtZXJnZSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gbGF5b3V0XHJcbiAgICovXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5nZXRMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9zdFRyZWUuZGF0YS5nZXRJdGVtTGF5b3V0KHRoaXMuZGF0YUluZGV4KTtcbiAgfTtcbiAgLy8gQGRlcGNyZWNhdGVkXG4gIC8vIGdldE1vZGVsPFQgPSB1bmtub3duLCBTIGV4dGVuZHMga2V5b2YgVCA9IGtleW9mIFQ+KHBhdGg6IFMpOiBNb2RlbDxUW1NdPlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5nZXRNb2RlbCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHRoaXMuZGF0YUluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaG9zdFRyZWUgPSB0aGlzLmhvc3RUcmVlO1xuICAgIHZhciBpdGVtTW9kZWwgPSBob3N0VHJlZS5kYXRhLmdldEl0ZW1Nb2RlbCh0aGlzLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIGl0ZW1Nb2RlbC5nZXRNb2RlbChwYXRoKTtcbiAgfTtcbiAgLy8gVE9ETzogVFlQRSBNb3JlIHNwZWNpZmljIG1vZGVsXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5nZXRMZXZlbE1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5ob3N0VHJlZS5sZXZlbE1vZGVscyB8fCBbXSlbdGhpcy5kZXB0aF07XG4gIH07XG4gIFRyZWVOb2RlLnByb3RvdHlwZS5zZXRWaXN1YWwgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuZGF0YUluZGV4ID49IDAgJiYgdGhpcy5ob3N0VHJlZS5kYXRhLnNldEl0ZW1WaXN1YWwodGhpcy5kYXRhSW5kZXgsIGtleSwgdmFsdWUpO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgaXRlbSB2aXN1YWxcclxuICAgKiBGSVhNRTogbWFrZSByZXR1cm4gdHlwZSBiZXR0ZXJcclxuICAgKi9cbiAgVHJlZU5vZGUucHJvdG90eXBlLmdldFZpc3VhbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5ob3N0VHJlZS5kYXRhLmdldEl0ZW1WaXN1YWwodGhpcy5kYXRhSW5kZXgsIGtleSk7XG4gIH07XG4gIFRyZWVOb2RlLnByb3RvdHlwZS5nZXRSYXdJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ob3N0VHJlZS5kYXRhLmdldFJhd0luZGV4KHRoaXMuZGF0YUluZGV4KTtcbiAgfTtcbiAgVHJlZU5vZGUucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmhvc3RUcmVlLmRhdGEuZ2V0SWQodGhpcy5kYXRhSW5kZXgpO1xuICB9O1xuICAvKipcclxuICAgKiBpbmRleCBpbiBwYXJlbnQncyBjaGlsZHJlblxyXG4gICAqL1xuICBUcmVlTm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnBhcmVudE5vZGUuY2hpbGRyZW47XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbltpXSA9PT0gdGhpcykge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfTtcbiAgLyoqXHJcbiAgICogaWYgdGhpcyBpcyBhbiBhbmNlc3RvciBvZiBhbm90aGVyIG5vZGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSBub2RlIGFub3RoZXIgbm9kZVxyXG4gICAqIEByZXR1cm4gaWYgaXMgYW5jZXN0b3JcclxuICAgKi9cbiAgVHJlZU5vZGUucHJvdG90eXBlLmlzQW5jZXN0b3JPZiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50ID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogaWYgdGhpcyBpcyBhbiBkZXNjZW5kYW50IG9mIGFub3RoZXIgbm9kZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIG5vZGUgYW5vdGhlciBub2RlXHJcbiAgICogQHJldHVybiBpZiBpcyBkZXNjZW5kYW50XHJcbiAgICovXG4gIFRyZWVOb2RlLnByb3RvdHlwZS5pc0Rlc2NlbmRhbnRPZiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgIT09IHRoaXMgJiYgbm9kZS5pc0FuY2VzdG9yT2YodGhpcyk7XG4gIH07XG4gIHJldHVybiBUcmVlTm9kZTtcbn0oKTtcbmV4cG9ydCB7IFRyZWVOb2RlIH07XG47XG52YXIgVHJlZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyZWUoaG9zdE1vZGVsKSB7XG4gICAgdGhpcy50eXBlID0gJ3RyZWUnO1xuICAgIHRoaXMuX25vZGVzID0gW107XG4gICAgdGhpcy5ob3N0TW9kZWwgPSBob3N0TW9kZWw7XG4gIH1cbiAgVHJlZS5wcm90b3R5cGUuZWFjaE5vZGUgPSBmdW5jdGlvbiAob3B0aW9ucywgY2IsIGNvbnRleHQpIHtcbiAgICB0aGlzLnJvb3QuZWFjaE5vZGUob3B0aW9ucywgY2IsIGNvbnRleHQpO1xuICB9O1xuICBUcmVlLnByb3RvdHlwZS5nZXROb2RlQnlEYXRhSW5kZXggPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgdmFyIHJhd0luZGV4ID0gdGhpcy5kYXRhLmdldFJhd0luZGV4KGRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzW3Jhd0luZGV4XTtcbiAgfTtcbiAgVHJlZS5wcm90b3R5cGUuZ2V0Tm9kZUJ5SWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJvb3QuZ2V0Tm9kZUJ5SWQobmFtZSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBpdGVtIGF2YWlsYWJsZSBieSBsaXN0LFxyXG4gICAqIHdoZW4gbGlzdCBoYXMgYmVlbiBwZXJmb3JtZWQgb3B0aW9ucyBsaWtlICdmaWx0ZXJTZWxmJyBvciAnbWFwJy5cclxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBub2RlcyA9IHRoaXMuX25vZGVzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbm9kZXNbaV0uZGF0YUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmNvdW50KCk7IGkgPCBsZW47IGkrKykge1xuICAgICAgbm9kZXNbZGF0YS5nZXRSYXdJbmRleChpKV0uZGF0YUluZGV4ID0gaTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIENsZWFyIGFsbCBsYXlvdXRzXHJcbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmNsZWFyTGF5b3V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRhdGEuY2xlYXJJdGVtTGF5b3V0cygpO1xuICB9O1xuICAvKipcclxuICAgKiBkYXRhIG5vZGUgZm9ybWF0OlxyXG4gICAqIHtcclxuICAgKiAgICAgbmFtZTogLi4uXHJcbiAgICogICAgIHZhbHVlOiAuLi5cclxuICAgKiAgICAgY2hpbGRyZW46IFtcclxuICAgKiAgICAgICAgIHtcclxuICAgKiAgICAgICAgICAgICBuYW1lOiAuLi5cclxuICAgKiAgICAgICAgICAgICB2YWx1ZTogLi4uXHJcbiAgICogICAgICAgICAgICAgY2hpbGRyZW46IC4uLlxyXG4gICAqICAgICAgICAgfSxcclxuICAgKiAgICAgICAgIC4uLlxyXG4gICAqICAgICBdXHJcbiAgICogfVxyXG4gICAqL1xuICBUcmVlLmNyZWF0ZVRyZWUgPSBmdW5jdGlvbiAoZGF0YVJvb3QsIGhvc3RNb2RlbCwgYmVmb3JlTGluaykge1xuICAgIHZhciB0cmVlID0gbmV3IFRyZWUoaG9zdE1vZGVsKTtcbiAgICB2YXIgbGlzdERhdGEgPSBbXTtcbiAgICB2YXIgZGltTWF4ID0gMTtcbiAgICBidWlsZEhpZXJhcmNoeShkYXRhUm9vdCk7XG4gICAgZnVuY3Rpb24gYnVpbGRIaWVyYXJjaHkoZGF0YU5vZGUsIHBhcmVudE5vZGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFOb2RlLnZhbHVlO1xuICAgICAgZGltTWF4ID0gTWF0aC5tYXgoZGltTWF4LCB6clV0aWwuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiAxKTtcbiAgICAgIGxpc3REYXRhLnB1c2goZGF0YU5vZGUpO1xuICAgICAgdmFyIG5vZGUgPSBuZXcgVHJlZU5vZGUoY29udmVydE9wdGlvbklkTmFtZShkYXRhTm9kZS5uYW1lLCAnJyksIHRyZWUpO1xuICAgICAgcGFyZW50Tm9kZSA/IGFkZENoaWxkKG5vZGUsIHBhcmVudE5vZGUpIDogdHJlZS5yb290ID0gbm9kZTtcbiAgICAgIHRyZWUuX25vZGVzLnB1c2gobm9kZSk7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBkYXRhTm9kZS5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYnVpbGRIaWVyYXJjaHkoY2hpbGRyZW5baV0sIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRyZWUucm9vdC51cGRhdGVEZXB0aEFuZEhlaWdodCgwKTtcbiAgICB2YXIgZGltZW5zaW9ucyA9IHByZXBhcmVTZXJpZXNEYXRhU2NoZW1hKGxpc3REYXRhLCB7XG4gICAgICBjb29yZERpbWVuc2lvbnM6IFsndmFsdWUnXSxcbiAgICAgIGRpbWVuc2lvbnNDb3VudDogZGltTWF4XG4gICAgfSkuZGltZW5zaW9ucztcbiAgICB2YXIgbGlzdCA9IG5ldyBTZXJpZXNEYXRhKGRpbWVuc2lvbnMsIGhvc3RNb2RlbCk7XG4gICAgbGlzdC5pbml0RGF0YShsaXN0RGF0YSk7XG4gICAgYmVmb3JlTGluayAmJiBiZWZvcmVMaW5rKGxpc3QpO1xuICAgIGxpbmtTZXJpZXNEYXRhKHtcbiAgICAgIG1haW5EYXRhOiBsaXN0LFxuICAgICAgc3RydWN0OiB0cmVlLFxuICAgICAgc3RydWN0QXR0cjogJ3RyZWUnXG4gICAgfSk7XG4gICAgdHJlZS51cGRhdGUoKTtcbiAgICByZXR1cm4gdHJlZTtcbiAgfTtcbiAgcmV0dXJuIFRyZWU7XG59KCk7XG4vKipcclxuICogSXQgaXMgbmVlZGVkIHRvIGNvbnNpZGVyIHRoZSBtZXNzIG9mICdsaXN0JywgJ2hvc3RNb2RlbCcgd2hlbiBjcmVhdGluZyBhIFRyZWVOb3RlLFxyXG4gKiBzbyB0aGlzIGZ1bmN0aW9uIGlzIG5vdCByZWFkeSBhbmQgbm90IG5lY2Vzc2FyeSB0byBiZSBwdWJsaWMuXHJcbiAqL1xuZnVuY3Rpb24gYWRkQ2hpbGQoY2hpbGQsIG5vZGUpIHtcbiAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkLnBhcmVudE5vZGUgPT09IG5vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gIGNoaWxkLnBhcmVudE5vZGUgPSBub2RlO1xufVxuZXhwb3J0IGRlZmF1bHQgVHJlZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15719\n")},17752:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   py: () => (/* binding */ applyDataTransform),\n/* harmony export */   v5: () => (/* binding */ registerExternalTransform)\n/* harmony export */ });\n/* unused harmony export ExternalSource */\n/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13430);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(48170);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98026);\n/* harmony import */ var _dataProvider_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58267);\n/* harmony import */ var _dataValueHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31825);\n/* harmony import */ var _util_log_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41025);\n/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(34310);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n/**\r\n * TODO: disable writable.\r\n * This structure will be exposed to users.\r\n */\nvar ExternalSource = /** @class */function () {\n  function ExternalSource() {}\n  ExternalSource.prototype.getRawData = function () {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n  ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n  ExternalSource.prototype.cloneRawData = function () {\n    return;\n  };\n  /**\r\n   * @return If dimension not found, return null/undefined.\r\n   */\n  ExternalSource.prototype.getDimensionInfo = function (dim) {\n    return;\n  };\n  /**\r\n   * dimensions defined if and only if either:\r\n   * (a) dataset.dimensions are declared.\r\n   * (b) dataset data include dimensions definitions in data (detected or via specified `sourceHeader`).\r\n   * If dimensions are defined, `dimensionInfoAll` is corresponding to\r\n   * the defined dimensions.\r\n   * Otherwise, `dimensionInfoAll` is determined by data columns.\r\n   * @return Always return an array (even empty array).\r\n   */\n  ExternalSource.prototype.cloneAllDimensionInfo = function () {\n    return;\n  };\n  ExternalSource.prototype.count = function () {\n    return;\n  };\n  /**\r\n   * Only support by dimension index.\r\n   * No need to support by dimension name in transform function,\r\n   * because transform function is not case-specific, no need to use name literally.\r\n   */\n  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n    return;\n  };\n  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n    return;\n  };\n  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n    return (0,_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_0__/* .parseDataValue */ .Pn)(rawVal, dimInfo);\n  };\n  return ExternalSource;\n}();\n\nfunction createExternalSource(internalSource, externalTransform) {\n  var extSource = new ExternalSource();\n  var data = internalSource.data;\n  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n  var sourceHeaderCount = internalSource.startIndex;\n  var errMsg = '';\n  if (internalSource.seriesLayoutBy !== _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SERIES_LAYOUT_BY_COLUMN */ .i_) {\n    // For the logic simplicity in transformer, only 'culumn' is\n    // supported in data transform. Otherwise, the `dimensionsDefine`\n    // might be detected by 'row', which probably confuses users.\n    if (false) {}\n    (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__/* .throwError */ .$8)(errMsg);\n  }\n  // [MEMO]\n  // Create a new dimensions structure for exposing.\n  // Do not expose all dimension info to users directly.\n  // Because the dimension is probably auto detected from data and not might reliable.\n  // Should not lead the transformers to think that is reliable and return it.\n  // See [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n  var dimensions = [];\n  var dimsByName = {};\n  var dimsDef = internalSource.dimensionsDefine;\n  if (dimsDef) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.each)(dimsDef, function (dimDef, idx) {\n      var name = dimDef.name;\n      var dimDefExt = {\n        index: idx,\n        name: name,\n        displayName: dimDef.displayName\n      };\n      dimensions.push(dimDefExt);\n      // Users probably do not specify dimension name. For simplicity, data transform\n      // does not generate dimension name.\n      if (name != null) {\n        // Dimension name should not be duplicated.\n        // For simplicity, data transform forbids name duplication, do not generate\n        // new name like module `completeDimensions.ts` did, but just tell users.\n        var errMsg_1 = '';\n        if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.hasOwn)(dimsByName, name)) {\n          if (false) {}\n          (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__/* .throwError */ .$8)(errMsg_1);\n        }\n        dimsByName[name] = dimDefExt;\n      }\n    });\n  }\n  // If dimension definitions are not defined and can not be detected.\n  // e.g., pure data `[[11, 22], ...]`.\n  else {\n    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n      // Do not generete name or anything others. The consequence process in\n      // `transform` or `series` probably have there own name generation strategry.\n      dimensions.push({\n        index: i\n      });\n    }\n  }\n  // Implement public methods:\n  var rawItemGetter = (0,_dataProvider_js__WEBPACK_IMPORTED_MODULE_4__/* .getRawSourceItemGetter */ .sC)(sourceFormat, _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SERIES_LAYOUT_BY_COLUMN */ .i_);\n  if (externalTransform.__isBuiltIn) {\n    extSource.getRawDataItem = function (dataIndex) {\n      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    };\n    extSource.getRawData = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.bind)(getRawData, null, internalSource);\n  }\n  extSource.cloneRawData = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.bind)(cloneRawData, null, internalSource);\n  var rawCounter = (0,_dataProvider_js__WEBPACK_IMPORTED_MODULE_4__/* .getRawSourceDataCounter */ .Kd)(sourceFormat, _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SERIES_LAYOUT_BY_COLUMN */ .i_);\n  extSource.count = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.bind)(rawCounter, null, data, sourceHeaderCount, dimensions);\n  var rawValueGetter = (0,_dataProvider_js__WEBPACK_IMPORTED_MODULE_4__/* .getRawSourceValueGetter */ .uQ)(sourceFormat);\n  extSource.retrieveValue = function (dataIndex, dimIndex) {\n    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    return retrieveValueFromItem(rawItem, dimIndex);\n  };\n  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n    if (dataItem == null) {\n      return;\n    }\n    var dimDef = dimensions[dimIndex];\n    // When `dimIndex` is `null`, `rawValueGetter` return the whole item.\n    if (dimDef) {\n      return rawValueGetter(dataItem, dimIndex, dimDef.name);\n    }\n  };\n  extSource.getDimensionInfo = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.bind)(getDimensionInfo, null, dimensions, dimsByName);\n  extSource.cloneAllDimensionInfo = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.bind)(cloneAllDimensionInfo, null, dimensions);\n  return extSource;\n}\nfunction getRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n    if (false) {}\n    (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__/* .throwError */ .$8)(errMsg);\n  }\n  return upstream.data;\n}\nfunction cloneRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n    if (false) {}\n    (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__/* .throwError */ .$8)(errMsg);\n  }\n  if (sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ARRAY_ROWS */ .Km) {\n    var result = [];\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push(data[i].slice());\n    }\n    return result;\n  } else if (sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_OBJECT_ROWS */ .Wk) {\n    var result = [];\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.extend)({}, data[i]));\n    }\n    return result;\n  }\n}\nfunction getDimensionInfo(dimensions, dimsByName, dim) {\n  if (dim == null) {\n    return;\n  }\n  // Keep the same logic as `List::getDimension` did.\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.isNumber)(dim)\n  // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.hasOwn)(dimsByName, dim)) {\n    return dimensions[dim];\n  } else if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.hasOwn)(dimsByName, dim)) {\n    return dimsByName[dim];\n  }\n}\nfunction cloneAllDimensionInfo(dimensions) {\n  return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.clone)(dimensions);\n}\nvar externalTransformMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.createHashMap)();\nfunction registerExternalTransform(externalTransform) {\n  externalTransform = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.clone)(externalTransform);\n  var type = externalTransform.type;\n  var errMsg = '';\n  if (!type) {\n    if (false) {}\n    (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__/* .throwError */ .$8)(errMsg);\n  }\n  var typeParsed = type.split(':');\n  if (typeParsed.length !== 2) {\n    if (false) {}\n    (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__/* .throwError */ .$8)(errMsg);\n  }\n  // Namespace 'echarts:xxx' is official namespace, where the transforms should\n  // be called directly via 'xxx' rather than 'echarts:xxx'.\n  var isBuiltIn = false;\n  if (typeParsed[0] === 'echarts') {\n    type = typeParsed[1];\n    isBuiltIn = true;\n  }\n  externalTransform.__isBuiltIn = isBuiltIn;\n  externalTransformMap.set(type, externalTransform);\n}\nfunction applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n  var pipedTransOption = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_5__/* .normalizeToArray */ .qB)(rawTransOption);\n  var pipeLen = pipedTransOption.length;\n  var errMsg = '';\n  if (!pipeLen) {\n    if (false) {}\n    (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__/* .throwError */ .$8)(errMsg);\n  }\n  for (var i = 0, len = pipeLen; i < len; i++) {\n    var transOption = pipedTransOption[i];\n    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);\n    // piped transform only support single input, except the fist one.\n    // piped transform only support single output, except the last one.\n    if (i !== len - 1) {\n      sourceList.length = Math.max(sourceList.length, 1);\n    }\n  }\n  return sourceList;\n}\nfunction applySingleDataTransform(transOption, upSourceList, infoForPrint,\n// If `pipeIndex` is null/undefined, no piped transform.\npipeIndex) {\n  var errMsg = '';\n  if (!upSourceList.length) {\n    if (false) {}\n    (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__/* .throwError */ .$8)(errMsg);\n  }\n  if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.isObject)(transOption)) {\n    if (false) {}\n    (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__/* .throwError */ .$8)(errMsg);\n  }\n  var transType = transOption.type;\n  var externalTransform = externalTransformMap.get(transType);\n  if (!externalTransform) {\n    if (false) {}\n    (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__/* .throwError */ .$8)(errMsg);\n  }\n  // Prepare source\n  var extUpSourceList = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.map)(upSourceList, function (upSource) {\n    return createExternalSource(upSource, externalTransform);\n  });\n  var resultList = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_5__/* .normalizeToArray */ .qB)(externalTransform.transform({\n    upstream: extUpSourceList[0],\n    upstreamList: extUpSourceList,\n    config: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.clone)(transOption.config)\n  }));\n  if (false) { var printStrArr; }\n  return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.map)(resultList, function (result, resultIndex) {\n    var errMsg = '';\n    if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_3__.isObject)(result)) {\n      if (false) {}\n      (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__/* .throwError */ .$8)(errMsg);\n    }\n    if (!result.data) {\n      if (false) {}\n      (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__/* .throwError */ .$8)(errMsg);\n    }\n    var sourceFormat = (0,_Source_js__WEBPACK_IMPORTED_MODULE_6__/* .detectSourceFormat */ .wZ)(result.data);\n    if (!isSupportedSourceFormat(sourceFormat)) {\n      if (false) {}\n      (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__/* .throwError */ .$8)(errMsg);\n    }\n    var resultMetaRawOption;\n    var firstUpSource = upSourceList[0];\n    /**\r\n     * Intuitively, the end users known the content of the original `dataset.source`,\r\n     * calucating the transform result in mind.\r\n     * Suppose the original `dataset.source` is:\r\n     * ```js\r\n     * [\r\n     *     ['product', '2012', '2013', '2014', '2015'],\r\n     *     ['AAA', 41.1, 30.4, 65.1, 53.3],\r\n     *     ['BBB', 86.5, 92.1, 85.7, 83.1],\r\n     *     ['CCC', 24.1, 67.2, 79.5, 86.4]\r\n     * ]\r\n     * ```\r\n     * The dimension info have to be detected from the source data.\r\n     * Some of the transformers (like filter, sort) will follow the dimension info\r\n     * of upstream, while others use new dimensions (like aggregate).\r\n     * Transformer can output a field `dimensions` to define the its own output dimensions.\r\n     * We also allow transformers to ignore the output `dimensions` field, and\r\n     * inherit the upstream dimensions definition. It can reduce the burden of handling\r\n     * dimensions in transformers.\r\n     *\r\n     * See also [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\r\n     */\n    if (firstUpSource && resultIndex === 0\n    // If transformer returns `dimensions`, it means that the transformer has different\n    // dimensions definitions. We do not inherit anything from upstream.\n    && !result.dimensions) {\n      var startIndex = firstUpSource.startIndex;\n      // We copy the header of upstream to the result, because:\n      // (1) The returned data always does not contain header line and can not be used\n      // as dimension-detection. In this case we can not use \"detected dimensions\" of\n      // upstream directly, because it might be detected based on different `seriesLayoutBy`.\n      // (2) We should support that the series read the upstream source in `seriesLayoutBy: 'row'`.\n      // So the original detected header should be add to the result, otherwise they can not be read.\n      if (startIndex) {\n        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);\n      }\n      resultMetaRawOption = {\n        seriesLayoutBy: _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SERIES_LAYOUT_BY_COLUMN */ .i_,\n        sourceHeader: startIndex,\n        dimensions: firstUpSource.metaRawOption.dimensions\n      };\n    } else {\n      resultMetaRawOption = {\n        seriesLayoutBy: _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SERIES_LAYOUT_BY_COLUMN */ .i_,\n        sourceHeader: 0,\n        dimensions: result.dimensions\n      };\n    }\n    return (0,_Source_js__WEBPACK_IMPORTED_MODULE_6__/* .createSource */ .gV)(result.data, resultMetaRawOption, null);\n  });\n}\nfunction isSupportedSourceFormat(sourceFormat) {\n  return sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ARRAY_ROWS */ .Km || sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_OBJECT_ROWS */ .Wk;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc3NTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL2hlbHBlci90cmFuc2Zvcm0uanM/MGQwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IFNFUklFU19MQVlPVVRfQllfQ09MVU1OLCBTT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTLCBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MgfSBmcm9tICcuLi8uLi91dGlsL3R5cGVzLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZVRvQXJyYXkgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCB7IGNyZWF0ZUhhc2hNYXAsIGJpbmQsIGVhY2gsIGhhc093biwgbWFwLCBjbG9uZSwgaXNPYmplY3QsIGV4dGVuZCwgaXNOdW1iZXIgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgZ2V0UmF3U291cmNlSXRlbUdldHRlciwgZ2V0UmF3U291cmNlRGF0YUNvdW50ZXIsIGdldFJhd1NvdXJjZVZhbHVlR2V0dGVyIH0gZnJvbSAnLi9kYXRhUHJvdmlkZXIuanMnO1xuaW1wb3J0IHsgcGFyc2VEYXRhVmFsdWUgfSBmcm9tICcuL2RhdGFWYWx1ZUhlbHBlci5qcyc7XG5pbXBvcnQgeyBsb2csIG1ha2VQcmludGFibGUsIHRocm93RXJyb3IgfSBmcm9tICcuLi8uLi91dGlsL2xvZy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTb3VyY2UsIGRldGVjdFNvdXJjZUZvcm1hdCB9IGZyb20gJy4uL1NvdXJjZS5qcyc7XG4vKipcclxuICogVE9ETzogZGlzYWJsZSB3cml0YWJsZS5cclxuICogVGhpcyBzdHJ1Y3R1cmUgd2lsbCBiZSBleHBvc2VkIHRvIHVzZXJzLlxyXG4gKi9cbnZhciBFeHRlcm5hbFNvdXJjZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4dGVybmFsU291cmNlKCkge31cbiAgRXh0ZXJuYWxTb3VyY2UucHJvdG90eXBlLmdldFJhd0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gT25seSBidWlsdC1pbiB0cmFuc2Zvcm0gYXZhaWxhYmxlLlxuICAgIHRocm93IG5ldyBFcnJvcignbm90IHN1cHBvcnRlZCcpO1xuICB9O1xuICBFeHRlcm5hbFNvdXJjZS5wcm90b3R5cGUuZ2V0UmF3RGF0YUl0ZW0gPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgLy8gT25seSBidWlsdC1pbiB0cmFuc2Zvcm0gYXZhaWxhYmxlLlxuICAgIHRocm93IG5ldyBFcnJvcignbm90IHN1cHBvcnRlZCcpO1xuICB9O1xuICBFeHRlcm5hbFNvdXJjZS5wcm90b3R5cGUuY2xvbmVSYXdEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybjtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHJldHVybiBJZiBkaW1lbnNpb24gbm90IGZvdW5kLCByZXR1cm4gbnVsbC91bmRlZmluZWQuXHJcbiAgICovXG4gIEV4dGVybmFsU291cmNlLnByb3RvdHlwZS5nZXREaW1lbnNpb25JbmZvID0gZnVuY3Rpb24gKGRpbSkge1xuICAgIHJldHVybjtcbiAgfTtcbiAgLyoqXHJcbiAgICogZGltZW5zaW9ucyBkZWZpbmVkIGlmIGFuZCBvbmx5IGlmIGVpdGhlcjpcclxuICAgKiAoYSkgZGF0YXNldC5kaW1lbnNpb25zIGFyZSBkZWNsYXJlZC5cclxuICAgKiAoYikgZGF0YXNldCBkYXRhIGluY2x1ZGUgZGltZW5zaW9ucyBkZWZpbml0aW9ucyBpbiBkYXRhIChkZXRlY3RlZCBvciB2aWEgc3BlY2lmaWVkIGBzb3VyY2VIZWFkZXJgKS5cclxuICAgKiBJZiBkaW1lbnNpb25zIGFyZSBkZWZpbmVkLCBgZGltZW5zaW9uSW5mb0FsbGAgaXMgY29ycmVzcG9uZGluZyB0b1xyXG4gICAqIHRoZSBkZWZpbmVkIGRpbWVuc2lvbnMuXHJcbiAgICogT3RoZXJ3aXNlLCBgZGltZW5zaW9uSW5mb0FsbGAgaXMgZGV0ZXJtaW5lZCBieSBkYXRhIGNvbHVtbnMuXHJcbiAgICogQHJldHVybiBBbHdheXMgcmV0dXJuIGFuIGFycmF5IChldmVuIGVtcHR5IGFycmF5KS5cclxuICAgKi9cbiAgRXh0ZXJuYWxTb3VyY2UucHJvdG90eXBlLmNsb25lQWxsRGltZW5zaW9uSW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm47XG4gIH07XG4gIEV4dGVybmFsU291cmNlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm47XG4gIH07XG4gIC8qKlxyXG4gICAqIE9ubHkgc3VwcG9ydCBieSBkaW1lbnNpb24gaW5kZXguXHJcbiAgICogTm8gbmVlZCB0byBzdXBwb3J0IGJ5IGRpbWVuc2lvbiBuYW1lIGluIHRyYW5zZm9ybSBmdW5jdGlvbixcclxuICAgKiBiZWNhdXNlIHRyYW5zZm9ybSBmdW5jdGlvbiBpcyBub3QgY2FzZS1zcGVjaWZpYywgbm8gbmVlZCB0byB1c2UgbmFtZSBsaXRlcmFsbHkuXHJcbiAgICovXG4gIEV4dGVybmFsU291cmNlLnByb3RvdHlwZS5yZXRyaWV2ZVZhbHVlID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgICByZXR1cm47XG4gIH07XG4gIEV4dGVybmFsU291cmNlLnByb3RvdHlwZS5yZXRyaWV2ZVZhbHVlRnJvbUl0ZW0gPSBmdW5jdGlvbiAoZGF0YUl0ZW0sIGRpbUluZGV4KSB7XG4gICAgcmV0dXJuO1xuICB9O1xuICBFeHRlcm5hbFNvdXJjZS5wcm90b3R5cGUuY29udmVydFZhbHVlID0gZnVuY3Rpb24gKHJhd1ZhbCwgZGltSW5mbykge1xuICAgIHJldHVybiBwYXJzZURhdGFWYWx1ZShyYXdWYWwsIGRpbUluZm8pO1xuICB9O1xuICByZXR1cm4gRXh0ZXJuYWxTb3VyY2U7XG59KCk7XG5leHBvcnQgeyBFeHRlcm5hbFNvdXJjZSB9O1xuZnVuY3Rpb24gY3JlYXRlRXh0ZXJuYWxTb3VyY2UoaW50ZXJuYWxTb3VyY2UsIGV4dGVybmFsVHJhbnNmb3JtKSB7XG4gIHZhciBleHRTb3VyY2UgPSBuZXcgRXh0ZXJuYWxTb3VyY2UoKTtcbiAgdmFyIGRhdGEgPSBpbnRlcm5hbFNvdXJjZS5kYXRhO1xuICB2YXIgc291cmNlRm9ybWF0ID0gZXh0U291cmNlLnNvdXJjZUZvcm1hdCA9IGludGVybmFsU291cmNlLnNvdXJjZUZvcm1hdDtcbiAgdmFyIHNvdXJjZUhlYWRlckNvdW50ID0gaW50ZXJuYWxTb3VyY2Uuc3RhcnRJbmRleDtcbiAgdmFyIGVyck1zZyA9ICcnO1xuICBpZiAoaW50ZXJuYWxTb3VyY2Uuc2VyaWVzTGF5b3V0QnkgIT09IFNFUklFU19MQVlPVVRfQllfQ09MVU1OKSB7XG4gICAgLy8gRm9yIHRoZSBsb2dpYyBzaW1wbGljaXR5IGluIHRyYW5zZm9ybWVyLCBvbmx5ICdjdWx1bW4nIGlzXG4gICAgLy8gc3VwcG9ydGVkIGluIGRhdGEgdHJhbnNmb3JtLiBPdGhlcndpc2UsIHRoZSBgZGltZW5zaW9uc0RlZmluZWBcbiAgICAvLyBtaWdodCBiZSBkZXRlY3RlZCBieSAncm93Jywgd2hpY2ggcHJvYmFibHkgY29uZnVzZXMgdXNlcnMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGVyck1zZyA9ICdgc2VyaWVzTGF5b3V0QnlgIG9mIHVwc3RyZWFtIGRhdGFzZXQgY2FuIG9ubHkgYmUgXCJjb2x1bW5cIiBpbiBkYXRhIHRyYW5zZm9ybS4nO1xuICAgIH1cbiAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gIH1cbiAgLy8gW01FTU9dXG4gIC8vIENyZWF0ZSBhIG5ldyBkaW1lbnNpb25zIHN0cnVjdHVyZSBmb3IgZXhwb3NpbmcuXG4gIC8vIERvIG5vdCBleHBvc2UgYWxsIGRpbWVuc2lvbiBpbmZvIHRvIHVzZXJzIGRpcmVjdGx5LlxuICAvLyBCZWNhdXNlIHRoZSBkaW1lbnNpb24gaXMgcHJvYmFibHkgYXV0byBkZXRlY3RlZCBmcm9tIGRhdGEgYW5kIG5vdCBtaWdodCByZWxpYWJsZS5cbiAgLy8gU2hvdWxkIG5vdCBsZWFkIHRoZSB0cmFuc2Zvcm1lcnMgdG8gdGhpbmsgdGhhdCBpcyByZWxpYWJsZSBhbmQgcmV0dXJuIGl0LlxuICAvLyBTZWUgW0RJTUVOU0lPTl9JTkhFUklUX1JVTEVdIGluIGBzb3VyY2VNYW5hZ2VyLnRzYC5cbiAgdmFyIGRpbWVuc2lvbnMgPSBbXTtcbiAgdmFyIGRpbXNCeU5hbWUgPSB7fTtcbiAgdmFyIGRpbXNEZWYgPSBpbnRlcm5hbFNvdXJjZS5kaW1lbnNpb25zRGVmaW5lO1xuICBpZiAoZGltc0RlZikge1xuICAgIGVhY2goZGltc0RlZiwgZnVuY3Rpb24gKGRpbURlZiwgaWR4KSB7XG4gICAgICB2YXIgbmFtZSA9IGRpbURlZi5uYW1lO1xuICAgICAgdmFyIGRpbURlZkV4dCA9IHtcbiAgICAgICAgaW5kZXg6IGlkeCxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgZGlzcGxheU5hbWU6IGRpbURlZi5kaXNwbGF5TmFtZVxuICAgICAgfTtcbiAgICAgIGRpbWVuc2lvbnMucHVzaChkaW1EZWZFeHQpO1xuICAgICAgLy8gVXNlcnMgcHJvYmFibHkgZG8gbm90IHNwZWNpZnkgZGltZW5zaW9uIG5hbWUuIEZvciBzaW1wbGljaXR5LCBkYXRhIHRyYW5zZm9ybVxuICAgICAgLy8gZG9lcyBub3QgZ2VuZXJhdGUgZGltZW5zaW9uIG5hbWUuXG4gICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIERpbWVuc2lvbiBuYW1lIHNob3VsZCBub3QgYmUgZHVwbGljYXRlZC5cbiAgICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIGRhdGEgdHJhbnNmb3JtIGZvcmJpZHMgbmFtZSBkdXBsaWNhdGlvbiwgZG8gbm90IGdlbmVyYXRlXG4gICAgICAgIC8vIG5ldyBuYW1lIGxpa2UgbW9kdWxlIGBjb21wbGV0ZURpbWVuc2lvbnMudHNgIGRpZCwgYnV0IGp1c3QgdGVsbCB1c2Vycy5cbiAgICAgICAgdmFyIGVyck1zZ18xID0gJyc7XG4gICAgICAgIGlmIChoYXNPd24oZGltc0J5TmFtZSwgbmFtZSkpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZXJyTXNnXzEgPSAnZGltZW5zaW9uIG5hbWUgXCInICsgbmFtZSArICdcIiBkdXBsaWNhdGVkLic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93RXJyb3IoZXJyTXNnXzEpO1xuICAgICAgICB9XG4gICAgICAgIGRpbXNCeU5hbWVbbmFtZV0gPSBkaW1EZWZFeHQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLy8gSWYgZGltZW5zaW9uIGRlZmluaXRpb25zIGFyZSBub3QgZGVmaW5lZCBhbmQgY2FuIG5vdCBiZSBkZXRlY3RlZC5cbiAgLy8gZS5nLiwgcHVyZSBkYXRhIGBbWzExLCAyMl0sIC4uLl1gLlxuICBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVybmFsU291cmNlLmRpbWVuc2lvbnNEZXRlY3RlZENvdW50IHx8IDA7IGkrKykge1xuICAgICAgLy8gRG8gbm90IGdlbmVyZXRlIG5hbWUgb3IgYW55dGhpbmcgb3RoZXJzLiBUaGUgY29uc2VxdWVuY2UgcHJvY2VzcyBpblxuICAgICAgLy8gYHRyYW5zZm9ybWAgb3IgYHNlcmllc2AgcHJvYmFibHkgaGF2ZSB0aGVyZSBvd24gbmFtZSBnZW5lcmF0aW9uIHN0cmF0ZWdyeS5cbiAgICAgIGRpbWVuc2lvbnMucHVzaCh7XG4gICAgICAgIGluZGV4OiBpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLy8gSW1wbGVtZW50IHB1YmxpYyBtZXRob2RzOlxuICB2YXIgcmF3SXRlbUdldHRlciA9IGdldFJhd1NvdXJjZUl0ZW1HZXR0ZXIoc291cmNlRm9ybWF0LCBTRVJJRVNfTEFZT1VUX0JZX0NPTFVNTik7XG4gIGlmIChleHRlcm5hbFRyYW5zZm9ybS5fX2lzQnVpbHRJbikge1xuICAgIGV4dFNvdXJjZS5nZXRSYXdEYXRhSXRlbSA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgIHJldHVybiByYXdJdGVtR2V0dGVyKGRhdGEsIHNvdXJjZUhlYWRlckNvdW50LCBkaW1lbnNpb25zLCBkYXRhSW5kZXgpO1xuICAgIH07XG4gICAgZXh0U291cmNlLmdldFJhd0RhdGEgPSBiaW5kKGdldFJhd0RhdGEsIG51bGwsIGludGVybmFsU291cmNlKTtcbiAgfVxuICBleHRTb3VyY2UuY2xvbmVSYXdEYXRhID0gYmluZChjbG9uZVJhd0RhdGEsIG51bGwsIGludGVybmFsU291cmNlKTtcbiAgdmFyIHJhd0NvdW50ZXIgPSBnZXRSYXdTb3VyY2VEYXRhQ291bnRlcihzb3VyY2VGb3JtYXQsIFNFUklFU19MQVlPVVRfQllfQ09MVU1OKTtcbiAgZXh0U291cmNlLmNvdW50ID0gYmluZChyYXdDb3VudGVyLCBudWxsLCBkYXRhLCBzb3VyY2VIZWFkZXJDb3VudCwgZGltZW5zaW9ucyk7XG4gIHZhciByYXdWYWx1ZUdldHRlciA9IGdldFJhd1NvdXJjZVZhbHVlR2V0dGVyKHNvdXJjZUZvcm1hdCk7XG4gIGV4dFNvdXJjZS5yZXRyaWV2ZVZhbHVlID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgICB2YXIgcmF3SXRlbSA9IHJhd0l0ZW1HZXR0ZXIoZGF0YSwgc291cmNlSGVhZGVyQ291bnQsIGRpbWVuc2lvbnMsIGRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHJldHJpZXZlVmFsdWVGcm9tSXRlbShyYXdJdGVtLCBkaW1JbmRleCk7XG4gIH07XG4gIHZhciByZXRyaWV2ZVZhbHVlRnJvbUl0ZW0gPSBleHRTb3VyY2UucmV0cmlldmVWYWx1ZUZyb21JdGVtID0gZnVuY3Rpb24gKGRhdGFJdGVtLCBkaW1JbmRleCkge1xuICAgIGlmIChkYXRhSXRlbSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkaW1EZWYgPSBkaW1lbnNpb25zW2RpbUluZGV4XTtcbiAgICAvLyBXaGVuIGBkaW1JbmRleGAgaXMgYG51bGxgLCBgcmF3VmFsdWVHZXR0ZXJgIHJldHVybiB0aGUgd2hvbGUgaXRlbS5cbiAgICBpZiAoZGltRGVmKSB7XG4gICAgICByZXR1cm4gcmF3VmFsdWVHZXR0ZXIoZGF0YUl0ZW0sIGRpbUluZGV4LCBkaW1EZWYubmFtZSk7XG4gICAgfVxuICB9O1xuICBleHRTb3VyY2UuZ2V0RGltZW5zaW9uSW5mbyA9IGJpbmQoZ2V0RGltZW5zaW9uSW5mbywgbnVsbCwgZGltZW5zaW9ucywgZGltc0J5TmFtZSk7XG4gIGV4dFNvdXJjZS5jbG9uZUFsbERpbWVuc2lvbkluZm8gPSBiaW5kKGNsb25lQWxsRGltZW5zaW9uSW5mbywgbnVsbCwgZGltZW5zaW9ucyk7XG4gIHJldHVybiBleHRTb3VyY2U7XG59XG5mdW5jdGlvbiBnZXRSYXdEYXRhKHVwc3RyZWFtKSB7XG4gIHZhciBzb3VyY2VGb3JtYXQgPSB1cHN0cmVhbS5zb3VyY2VGb3JtYXQ7XG4gIGlmICghaXNTdXBwb3J0ZWRTb3VyY2VGb3JtYXQoc291cmNlRm9ybWF0KSkge1xuICAgIHZhciBlcnJNc2cgPSAnJztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZXJyTXNnID0gJ2BnZXRSYXdEYXRhYCBpcyBub3Qgc3VwcG9ydGVkIGluIHNvdXJjZSBmb3JtYXQgJyArIHNvdXJjZUZvcm1hdDtcbiAgICB9XG4gICAgdGhyb3dFcnJvcihlcnJNc2cpO1xuICB9XG4gIHJldHVybiB1cHN0cmVhbS5kYXRhO1xufVxuZnVuY3Rpb24gY2xvbmVSYXdEYXRhKHVwc3RyZWFtKSB7XG4gIHZhciBzb3VyY2VGb3JtYXQgPSB1cHN0cmVhbS5zb3VyY2VGb3JtYXQ7XG4gIHZhciBkYXRhID0gdXBzdHJlYW0uZGF0YTtcbiAgaWYgKCFpc1N1cHBvcnRlZFNvdXJjZUZvcm1hdChzb3VyY2VGb3JtYXQpKSB7XG4gICAgdmFyIGVyck1zZyA9ICcnO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBlcnJNc2cgPSAnYGNsb25lUmF3RGF0YWAgaXMgbm90IHN1cHBvcnRlZCBpbiBzb3VyY2UgZm9ybWF0ICcgKyBzb3VyY2VGb3JtYXQ7XG4gICAgfVxuICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgfVxuICBpZiAoc291cmNlRm9ybWF0ID09PSBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIE5vdCBzdHJpY3RseSBjbG9uZSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgIHJlc3VsdC5wdXNoKGRhdGFbaV0uc2xpY2UoKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBpZiAoc291cmNlRm9ybWF0ID09PSBTT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBOb3Qgc3RyaWN0bHkgY2xvbmUgZm9yIHBlcmZvcm1hbmNlXG4gICAgICByZXN1bHQucHVzaChleHRlbmQoe30sIGRhdGFbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGltZW5zaW9uSW5mbyhkaW1lbnNpb25zLCBkaW1zQnlOYW1lLCBkaW0pIHtcbiAgaWYgKGRpbSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEtlZXAgdGhlIHNhbWUgbG9naWMgYXMgYExpc3Q6OmdldERpbWVuc2lvbmAgZGlkLlxuICBpZiAoaXNOdW1iZXIoZGltKVxuICAvLyBJZiBiZWluZyBhIG51bWJlci1saWtlIHN0cmluZyBidXQgbm90IGJlaW5nIGRlZmluZWQgYSBkaW1lbnNpb24gbmFtZS5cbiAgfHwgIWlzTmFOKGRpbSkgJiYgIWhhc093bihkaW1zQnlOYW1lLCBkaW0pKSB7XG4gICAgcmV0dXJuIGRpbWVuc2lvbnNbZGltXTtcbiAgfSBlbHNlIGlmIChoYXNPd24oZGltc0J5TmFtZSwgZGltKSkge1xuICAgIHJldHVybiBkaW1zQnlOYW1lW2RpbV07XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb25lQWxsRGltZW5zaW9uSW5mbyhkaW1lbnNpb25zKSB7XG4gIHJldHVybiBjbG9uZShkaW1lbnNpb25zKTtcbn1cbnZhciBleHRlcm5hbFRyYW5zZm9ybU1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckV4dGVybmFsVHJhbnNmb3JtKGV4dGVybmFsVHJhbnNmb3JtKSB7XG4gIGV4dGVybmFsVHJhbnNmb3JtID0gY2xvbmUoZXh0ZXJuYWxUcmFuc2Zvcm0pO1xuICB2YXIgdHlwZSA9IGV4dGVybmFsVHJhbnNmb3JtLnR5cGU7XG4gIHZhciBlcnJNc2cgPSAnJztcbiAgaWYgKCF0eXBlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGVyck1zZyA9ICdNdXN0IGhhdmUgYSBgdHlwZWAgd2hlbiBgcmVnaXN0ZXJUcmFuc2Zvcm1gLic7XG4gICAgfVxuICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgfVxuICB2YXIgdHlwZVBhcnNlZCA9IHR5cGUuc3BsaXQoJzonKTtcbiAgaWYgKHR5cGVQYXJzZWQubGVuZ3RoICE9PSAyKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGVyck1zZyA9ICdOYW1lIG11c3QgaW5jbHVkZSBuYW1lc3BhY2UgbGlrZSBcIm5zOnJlZ3Jlc3Npb25cIi4nO1xuICAgIH1cbiAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gIH1cbiAgLy8gTmFtZXNwYWNlICdlY2hhcnRzOnh4eCcgaXMgb2ZmaWNpYWwgbmFtZXNwYWNlLCB3aGVyZSB0aGUgdHJhbnNmb3JtcyBzaG91bGRcbiAgLy8gYmUgY2FsbGVkIGRpcmVjdGx5IHZpYSAneHh4JyByYXRoZXIgdGhhbiAnZWNoYXJ0czp4eHgnLlxuICB2YXIgaXNCdWlsdEluID0gZmFsc2U7XG4gIGlmICh0eXBlUGFyc2VkWzBdID09PSAnZWNoYXJ0cycpIHtcbiAgICB0eXBlID0gdHlwZVBhcnNlZFsxXTtcbiAgICBpc0J1aWx0SW4gPSB0cnVlO1xuICB9XG4gIGV4dGVybmFsVHJhbnNmb3JtLl9faXNCdWlsdEluID0gaXNCdWlsdEluO1xuICBleHRlcm5hbFRyYW5zZm9ybU1hcC5zZXQodHlwZSwgZXh0ZXJuYWxUcmFuc2Zvcm0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGF0YVRyYW5zZm9ybShyYXdUcmFuc09wdGlvbiwgc291cmNlTGlzdCwgaW5mb0ZvclByaW50KSB7XG4gIHZhciBwaXBlZFRyYW5zT3B0aW9uID0gbm9ybWFsaXplVG9BcnJheShyYXdUcmFuc09wdGlvbik7XG4gIHZhciBwaXBlTGVuID0gcGlwZWRUcmFuc09wdGlvbi5sZW5ndGg7XG4gIHZhciBlcnJNc2cgPSAnJztcbiAgaWYgKCFwaXBlTGVuKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGVyck1zZyA9ICdJZiBgdHJhbnNmb3JtYCBkZWNsYXJlZCwgaXQgc2hvdWxkIGF0IGxlYXN0IGNvbnRhaW4gb25lIHRyYW5zZm9ybS4nO1xuICAgIH1cbiAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBpcGVMZW47IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB0cmFuc09wdGlvbiA9IHBpcGVkVHJhbnNPcHRpb25baV07XG4gICAgc291cmNlTGlzdCA9IGFwcGx5U2luZ2xlRGF0YVRyYW5zZm9ybSh0cmFuc09wdGlvbiwgc291cmNlTGlzdCwgaW5mb0ZvclByaW50LCBwaXBlTGVuID09PSAxID8gbnVsbCA6IGkpO1xuICAgIC8vIHBpcGVkIHRyYW5zZm9ybSBvbmx5IHN1cHBvcnQgc2luZ2xlIGlucHV0LCBleGNlcHQgdGhlIGZpc3Qgb25lLlxuICAgIC8vIHBpcGVkIHRyYW5zZm9ybSBvbmx5IHN1cHBvcnQgc2luZ2xlIG91dHB1dCwgZXhjZXB0IHRoZSBsYXN0IG9uZS5cbiAgICBpZiAoaSAhPT0gbGVuIC0gMSkge1xuICAgICAgc291cmNlTGlzdC5sZW5ndGggPSBNYXRoLm1heChzb3VyY2VMaXN0Lmxlbmd0aCwgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzb3VyY2VMaXN0O1xufVxuZnVuY3Rpb24gYXBwbHlTaW5nbGVEYXRhVHJhbnNmb3JtKHRyYW5zT3B0aW9uLCB1cFNvdXJjZUxpc3QsIGluZm9Gb3JQcmludCxcbi8vIElmIGBwaXBlSW5kZXhgIGlzIG51bGwvdW5kZWZpbmVkLCBubyBwaXBlZCB0cmFuc2Zvcm0uXG5waXBlSW5kZXgpIHtcbiAgdmFyIGVyck1zZyA9ICcnO1xuICBpZiAoIXVwU291cmNlTGlzdC5sZW5ndGgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZXJyTXNnID0gJ011c3QgaGF2ZSBhdCBsZWFzdCBvbmUgdXBzdHJlYW0gZGF0YXNldC4nO1xuICAgIH1cbiAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh0cmFuc09wdGlvbikpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZXJyTXNnID0gJ3RyYW5zZm9ybSBkZWNsYXJhdGlvbiBtdXN0IGJlIGFuIG9iamVjdCByYXRoZXIgdGhhbiAnICsgdHlwZW9mIHRyYW5zT3B0aW9uICsgJy4nO1xuICAgIH1cbiAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gIH1cbiAgdmFyIHRyYW5zVHlwZSA9IHRyYW5zT3B0aW9uLnR5cGU7XG4gIHZhciBleHRlcm5hbFRyYW5zZm9ybSA9IGV4dGVybmFsVHJhbnNmb3JtTWFwLmdldCh0cmFuc1R5cGUpO1xuICBpZiAoIWV4dGVybmFsVHJhbnNmb3JtKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGVyck1zZyA9ICdDYW4gbm90IGZpbmQgdHJhbnNmb3JtIG9uIHR5cGUgXCInICsgdHJhbnNUeXBlICsgJ1wiLic7XG4gICAgfVxuICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgfVxuICAvLyBQcmVwYXJlIHNvdXJjZVxuICB2YXIgZXh0VXBTb3VyY2VMaXN0ID0gbWFwKHVwU291cmNlTGlzdCwgZnVuY3Rpb24gKHVwU291cmNlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUV4dGVybmFsU291cmNlKHVwU291cmNlLCBleHRlcm5hbFRyYW5zZm9ybSk7XG4gIH0pO1xuICB2YXIgcmVzdWx0TGlzdCA9IG5vcm1hbGl6ZVRvQXJyYXkoZXh0ZXJuYWxUcmFuc2Zvcm0udHJhbnNmb3JtKHtcbiAgICB1cHN0cmVhbTogZXh0VXBTb3VyY2VMaXN0WzBdLFxuICAgIHVwc3RyZWFtTGlzdDogZXh0VXBTb3VyY2VMaXN0LFxuICAgIGNvbmZpZzogY2xvbmUodHJhbnNPcHRpb24uY29uZmlnKVxuICB9KSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHRyYW5zT3B0aW9uLnByaW50KSB7XG4gICAgICB2YXIgcHJpbnRTdHJBcnIgPSBtYXAocmVzdWx0TGlzdCwgZnVuY3Rpb24gKGV4dFNvdXJjZSkge1xuICAgICAgICB2YXIgcGlwZUluZGV4U3RyID0gcGlwZUluZGV4ICE9IG51bGwgPyAnID09PSBwaXBlIGluZGV4OiAnICsgcGlwZUluZGV4IDogJyc7XG4gICAgICAgIHJldHVybiBbJz09PSBkYXRhc2V0IGluZGV4OiAnICsgaW5mb0ZvclByaW50LmRhdGFzZXRJbmRleCArIHBpcGVJbmRleFN0ciArICcgPT09JywgJy0gdHJhbnNmb3JtIHJlc3VsdCBkYXRhOicsIG1ha2VQcmludGFibGUoZXh0U291cmNlLmRhdGEpLCAnLSB0cmFuc2Zvcm0gcmVzdWx0IGRpbWVuc2lvbnM6JywgbWFrZVByaW50YWJsZShleHRTb3VyY2UuZGltZW5zaW9ucyldLmpvaW4oJ1xcbicpO1xuICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICBsb2cocHJpbnRTdHJBcnIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWFwKHJlc3VsdExpc3QsIGZ1bmN0aW9uIChyZXN1bHQsIHJlc3VsdEluZGV4KSB7XG4gICAgdmFyIGVyck1zZyA9ICcnO1xuICAgIGlmICghaXNPYmplY3QocmVzdWx0KSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyTXNnID0gJ0EgdHJhbnNmb3JtIHNob3VsZCBub3QgcmV0dXJuIHNvbWUgZW1wdHkgcmVzdWx0cy4nO1xuICAgICAgfVxuICAgICAgdGhyb3dFcnJvcihlcnJNc2cpO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC5kYXRhKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBlcnJNc2cgPSAnVHJhbnNmb3JtIHJlc3VsdCBkYXRhIHNob3VsZCBiZSBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnO1xuICAgICAgfVxuICAgICAgdGhyb3dFcnJvcihlcnJNc2cpO1xuICAgIH1cbiAgICB2YXIgc291cmNlRm9ybWF0ID0gZGV0ZWN0U291cmNlRm9ybWF0KHJlc3VsdC5kYXRhKTtcbiAgICBpZiAoIWlzU3VwcG9ydGVkU291cmNlRm9ybWF0KHNvdXJjZUZvcm1hdCkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVyck1zZyA9ICdUcmFuc2Zvcm0gcmVzdWx0IGRhdGEgc2hvdWxkIGJlIGFycmF5IHJvd3Mgb3Igb2JqZWN0IHJvd3MuJztcbiAgICAgIH1cbiAgICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdE1ldGFSYXdPcHRpb247XG4gICAgdmFyIGZpcnN0VXBTb3VyY2UgPSB1cFNvdXJjZUxpc3RbMF07XG4gICAgLyoqXHJcbiAgICAgKiBJbnR1aXRpdmVseSwgdGhlIGVuZCB1c2VycyBrbm93biB0aGUgY29udGVudCBvZiB0aGUgb3JpZ2luYWwgYGRhdGFzZXQuc291cmNlYCxcclxuICAgICAqIGNhbHVjYXRpbmcgdGhlIHRyYW5zZm9ybSByZXN1bHQgaW4gbWluZC5cclxuICAgICAqIFN1cHBvc2UgdGhlIG9yaWdpbmFsIGBkYXRhc2V0LnNvdXJjZWAgaXM6XHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogW1xyXG4gICAgICogICAgIFsncHJvZHVjdCcsICcyMDEyJywgJzIwMTMnLCAnMjAxNCcsICcyMDE1J10sXHJcbiAgICAgKiAgICAgWydBQUEnLCA0MS4xLCAzMC40LCA2NS4xLCA1My4zXSxcclxuICAgICAqICAgICBbJ0JCQicsIDg2LjUsIDkyLjEsIDg1LjcsIDgzLjFdLFxyXG4gICAgICogICAgIFsnQ0NDJywgMjQuMSwgNjcuMiwgNzkuNSwgODYuNF1cclxuICAgICAqIF1cclxuICAgICAqIGBgYFxyXG4gICAgICogVGhlIGRpbWVuc2lvbiBpbmZvIGhhdmUgdG8gYmUgZGV0ZWN0ZWQgZnJvbSB0aGUgc291cmNlIGRhdGEuXHJcbiAgICAgKiBTb21lIG9mIHRoZSB0cmFuc2Zvcm1lcnMgKGxpa2UgZmlsdGVyLCBzb3J0KSB3aWxsIGZvbGxvdyB0aGUgZGltZW5zaW9uIGluZm9cclxuICAgICAqIG9mIHVwc3RyZWFtLCB3aGlsZSBvdGhlcnMgdXNlIG5ldyBkaW1lbnNpb25zIChsaWtlIGFnZ3JlZ2F0ZSkuXHJcbiAgICAgKiBUcmFuc2Zvcm1lciBjYW4gb3V0cHV0IGEgZmllbGQgYGRpbWVuc2lvbnNgIHRvIGRlZmluZSB0aGUgaXRzIG93biBvdXRwdXQgZGltZW5zaW9ucy5cclxuICAgICAqIFdlIGFsc28gYWxsb3cgdHJhbnNmb3JtZXJzIHRvIGlnbm9yZSB0aGUgb3V0cHV0IGBkaW1lbnNpb25zYCBmaWVsZCwgYW5kXHJcbiAgICAgKiBpbmhlcml0IHRoZSB1cHN0cmVhbSBkaW1lbnNpb25zIGRlZmluaXRpb24uIEl0IGNhbiByZWR1Y2UgdGhlIGJ1cmRlbiBvZiBoYW5kbGluZ1xyXG4gICAgICogZGltZW5zaW9ucyBpbiB0cmFuc2Zvcm1lcnMuXHJcbiAgICAgKlxyXG4gICAgICogU2VlIGFsc28gW0RJTUVOU0lPTl9JTkhFUklUX1JVTEVdIGluIGBzb3VyY2VNYW5hZ2VyLnRzYC5cclxuICAgICAqL1xuICAgIGlmIChmaXJzdFVwU291cmNlICYmIHJlc3VsdEluZGV4ID09PSAwXG4gICAgLy8gSWYgdHJhbnNmb3JtZXIgcmV0dXJucyBgZGltZW5zaW9uc2AsIGl0IG1lYW5zIHRoYXQgdGhlIHRyYW5zZm9ybWVyIGhhcyBkaWZmZXJlbnRcbiAgICAvLyBkaW1lbnNpb25zIGRlZmluaXRpb25zLiBXZSBkbyBub3QgaW5oZXJpdCBhbnl0aGluZyBmcm9tIHVwc3RyZWFtLlxuICAgICYmICFyZXN1bHQuZGltZW5zaW9ucykge1xuICAgICAgdmFyIHN0YXJ0SW5kZXggPSBmaXJzdFVwU291cmNlLnN0YXJ0SW5kZXg7XG4gICAgICAvLyBXZSBjb3B5IHRoZSBoZWFkZXIgb2YgdXBzdHJlYW0gdG8gdGhlIHJlc3VsdCwgYmVjYXVzZTpcbiAgICAgIC8vICgxKSBUaGUgcmV0dXJuZWQgZGF0YSBhbHdheXMgZG9lcyBub3QgY29udGFpbiBoZWFkZXIgbGluZSBhbmQgY2FuIG5vdCBiZSB1c2VkXG4gICAgICAvLyBhcyBkaW1lbnNpb24tZGV0ZWN0aW9uLiBJbiB0aGlzIGNhc2Ugd2UgY2FuIG5vdCB1c2UgXCJkZXRlY3RlZCBkaW1lbnNpb25zXCIgb2ZcbiAgICAgIC8vIHVwc3RyZWFtIGRpcmVjdGx5LCBiZWNhdXNlIGl0IG1pZ2h0IGJlIGRldGVjdGVkIGJhc2VkIG9uIGRpZmZlcmVudCBgc2VyaWVzTGF5b3V0QnlgLlxuICAgICAgLy8gKDIpIFdlIHNob3VsZCBzdXBwb3J0IHRoYXQgdGhlIHNlcmllcyByZWFkIHRoZSB1cHN0cmVhbSBzb3VyY2UgaW4gYHNlcmllc0xheW91dEJ5OiAncm93J2AuXG4gICAgICAvLyBTbyB0aGUgb3JpZ2luYWwgZGV0ZWN0ZWQgaGVhZGVyIHNob3VsZCBiZSBhZGQgdG8gdGhlIHJlc3VsdCwgb3RoZXJ3aXNlIHRoZXkgY2FuIG5vdCBiZSByZWFkLlxuICAgICAgaWYgKHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBmaXJzdFVwU291cmNlLmRhdGEuc2xpY2UoMCwgc3RhcnRJbmRleCkuY29uY2F0KHJlc3VsdC5kYXRhKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdE1ldGFSYXdPcHRpb24gPSB7XG4gICAgICAgIHNlcmllc0xheW91dEJ5OiBTRVJJRVNfTEFZT1VUX0JZX0NPTFVNTixcbiAgICAgICAgc291cmNlSGVhZGVyOiBzdGFydEluZGV4LFxuICAgICAgICBkaW1lbnNpb25zOiBmaXJzdFVwU291cmNlLm1ldGFSYXdPcHRpb24uZGltZW5zaW9uc1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0TWV0YVJhd09wdGlvbiA9IHtcbiAgICAgICAgc2VyaWVzTGF5b3V0Qnk6IFNFUklFU19MQVlPVVRfQllfQ09MVU1OLFxuICAgICAgICBzb3VyY2VIZWFkZXI6IDAsXG4gICAgICAgIGRpbWVuc2lvbnM6IHJlc3VsdC5kaW1lbnNpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlU291cmNlKHJlc3VsdC5kYXRhLCByZXN1bHRNZXRhUmF3T3B0aW9uLCBudWxsKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc1N1cHBvcnRlZFNvdXJjZUZvcm1hdChzb3VyY2VGb3JtYXQpIHtcbiAgcmV0dXJuIHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9BUlJBWV9ST1dTIHx8IHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9PQkpFQ1RfUk9XUztcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17752\n")},22759:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar SeriesDimensionDefine = /** @class */function () {\n  /**\r\n   * @param opt All of the fields will be shallow copied.\r\n   */\n  function SeriesDimensionDefine(opt) {\n    /**\r\n     * The format of `otherDims` is:\r\n     * ```js\r\n     * {\r\n     *     tooltip?: number\r\n     *     label?: number\r\n     *     itemName?: number\r\n     *     seriesName?: number\r\n     * }\r\n     * ```\r\n     *\r\n     * A `series.encode` can specified these fields:\r\n     * ```js\r\n     * encode: {\r\n     *     // "3, 1, 5" is the index of data dimension.\r\n     *     tooltip: [3, 1, 5],\r\n     *     label: [0, 3],\r\n     *     ...\r\n     * }\r\n     * ```\r\n     * `otherDims` is the parse result of the `series.encode` above, like:\r\n     * ```js\r\n     * // Suppose the index of this data dimension is `3`.\r\n     * this.otherDims = {\r\n     *     // `3` is at the index `0` of the `encode.tooltip`\r\n     *     tooltip: 0,\r\n     *     // `3` is at the index `1` of the `encode.label`\r\n     *     label: 1\r\n     * };\r\n     * ```\r\n     *\r\n     * This prop should never be `null`/`undefined` after initialized.\r\n     */\n    this.otherDims = {};\n    if (opt != null) {\n      zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend(this, opt);\n    }\n  }\n  return SeriesDimensionDefine;\n}();\n;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SeriesDimensionDefine);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI3NTkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvU2VyaWVzRGltZW5zaW9uRGVmaW5lLmpzPzExYTgiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbnZhciBTZXJpZXNEaW1lbnNpb25EZWZpbmUgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBAcGFyYW0gb3B0IEFsbCBvZiB0aGUgZmllbGRzIHdpbGwgYmUgc2hhbGxvdyBjb3BpZWQuXHJcbiAgICovXG4gIGZ1bmN0aW9uIFNlcmllc0RpbWVuc2lvbkRlZmluZShvcHQpIHtcbiAgICAvKipcclxuICAgICAqIFRoZSBmb3JtYXQgb2YgYG90aGVyRGltc2AgaXM6XHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICoge1xyXG4gICAgICogICAgIHRvb2x0aXA/OiBudW1iZXJcclxuICAgICAqICAgICBsYWJlbD86IG51bWJlclxyXG4gICAgICogICAgIGl0ZW1OYW1lPzogbnVtYmVyXHJcbiAgICAgKiAgICAgc2VyaWVzTmFtZT86IG51bWJlclxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQSBgc2VyaWVzLmVuY29kZWAgY2FuIHNwZWNpZmllZCB0aGVzZSBmaWVsZHM6XHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogZW5jb2RlOiB7XHJcbiAgICAgKiAgICAgLy8gXCIzLCAxLCA1XCIgaXMgdGhlIGluZGV4IG9mIGRhdGEgZGltZW5zaW9uLlxyXG4gICAgICogICAgIHRvb2x0aXA6IFszLCAxLCA1XSxcclxuICAgICAqICAgICBsYWJlbDogWzAsIDNdLFxyXG4gICAgICogICAgIC4uLlxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKiBgb3RoZXJEaW1zYCBpcyB0aGUgcGFyc2UgcmVzdWx0IG9mIHRoZSBgc2VyaWVzLmVuY29kZWAgYWJvdmUsIGxpa2U6XHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogLy8gU3VwcG9zZSB0aGUgaW5kZXggb2YgdGhpcyBkYXRhIGRpbWVuc2lvbiBpcyBgM2AuXHJcbiAgICAgKiB0aGlzLm90aGVyRGltcyA9IHtcclxuICAgICAqICAgICAvLyBgM2AgaXMgYXQgdGhlIGluZGV4IGAwYCBvZiB0aGUgYGVuY29kZS50b29sdGlwYFxyXG4gICAgICogICAgIHRvb2x0aXA6IDAsXHJcbiAgICAgKiAgICAgLy8gYDNgIGlzIGF0IHRoZSBpbmRleCBgMWAgb2YgdGhlIGBlbmNvZGUubGFiZWxgXHJcbiAgICAgKiAgICAgbGFiZWw6IDFcclxuICAgICAqIH07XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHByb3Agc2hvdWxkIG5ldmVyIGJlIGBudWxsYC9gdW5kZWZpbmVkYCBhZnRlciBpbml0aWFsaXplZC5cclxuICAgICAqL1xuICAgIHRoaXMub3RoZXJEaW1zID0ge307XG4gICAgaWYgKG9wdCAhPSBudWxsKSB7XG4gICAgICB6clV0aWwuZXh0ZW5kKHRoaXMsIG9wdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBTZXJpZXNEaW1lbnNpb25EZWZpbmU7XG59KCk7XG47XG5leHBvcnQgZGVmYXVsdCBTZXJpZXNEaW1lbnNpb25EZWZpbmU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22759\n')},23071:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   G9: () => (/* binding */ querySeriesUpstreamDatasetModel),\n/* harmony export */   Gt: () => (/* binding */ queryDatasetUpstreamDatasetModels),\n/* harmony export */   OC: () => (/* binding */ makeSeriesEncodeForAxisCoordSys),\n/* harmony export */   PU: () => (/* binding */ guessOrdinal),\n/* harmony export */   ln: () => (/* binding */ makeSeriesEncodeForNameBased),\n/* harmony export */   ps: () => (/* binding */ resetSourceDefaulter),\n/* harmony export */   sc: () => (/* binding */ BE_ORDINAL)\n/* harmony export */ });\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13430);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n// The result of `guessOrdinal`.\nvar BE_ORDINAL = {\n  Must: 1,\n  Might: 2,\n  Not: 3 // Other cases\n};\nvar innerGlobalModel = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\n/**\r\n * MUST be called before mergeOption of all series.\r\n */\nfunction resetSourceDefaulter(ecModel) {\n  // `datasetMap` is used to make default encode.\n  innerGlobalModel(ecModel).datasetMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.createHashMap)();\n}\n/**\r\n * [The strategy of the arrengment of data dimensions for dataset]:\r\n * \"value way\": all axes are non-category axes. So series one by one take\r\n *     several (the number is coordSysDims.length) dimensions from dataset.\r\n *     The result of data arrengment of data dimensions like:\r\n *     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |\r\n * \"category way\": at least one axis is category axis. So the the first data\r\n *     dimension is always mapped to the first category axis and shared by\r\n *     all of the series. The other data dimensions are taken by series like\r\n *     \"value way\" does.\r\n *     The result of data arrengment of data dimensions like:\r\n *     | ser_shared_x | ser0_y | ser1_y | ser2_y |\r\n *\r\n * @return encode Never be `null/undefined`.\r\n */\nfunction makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {\n  var encode = {};\n  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);\n  // Currently only make default when using dataset, util more reqirements occur.\n  if (!datasetModel || !coordDimensions) {\n    return encode;\n  }\n  var encodeItemName = [];\n  var encodeSeriesName = [];\n  var ecModel = seriesModel.ecModel;\n  var datasetMap = innerGlobalModel(ecModel).datasetMap;\n  var key = datasetModel.uid + '_' + source.seriesLayoutBy;\n  var baseCategoryDimIndex;\n  var categoryWayValueDimStart;\n  coordDimensions = coordDimensions.slice();\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(coordDimensions, function (coordDimInfoLoose, coordDimIdx) {\n    var coordDimInfo = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {\n      name: coordDimInfoLoose\n    };\n    if (coordDimInfo.type === 'ordinal' && baseCategoryDimIndex == null) {\n      baseCategoryDimIndex = coordDimIdx;\n      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);\n    }\n    encode[coordDimInfo.name] = [];\n  });\n  var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n    categoryWayDim: categoryWayValueDimStart,\n    valueWayDim: 0\n  });\n  // TODO\n  // Auto detect first time axis and do arrangement.\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(coordDimensions, function (coordDimInfo, coordDimIdx) {\n    var coordDimName = coordDimInfo.name;\n    var count = getDataDimCountOnCoordDim(coordDimInfo);\n    // In value way.\n    if (baseCategoryDimIndex == null) {\n      var start = datasetRecord.valueWayDim;\n      pushDim(encode[coordDimName], start, count);\n      pushDim(encodeSeriesName, start, count);\n      datasetRecord.valueWayDim += count;\n      // ??? TODO give a better default series name rule?\n      // especially when encode x y specified.\n      // consider: when multiple series share one dimension\n      // category axis, series name should better use\n      // the other dimension name. On the other hand, use\n      // both dimensions name.\n    }\n    // In category way, the first category axis.\n    else if (baseCategoryDimIndex === coordDimIdx) {\n      pushDim(encode[coordDimName], 0, count);\n      pushDim(encodeItemName, 0, count);\n    }\n    // In category way, the other axis.\n    else {\n      var start = datasetRecord.categoryWayDim;\n      pushDim(encode[coordDimName], start, count);\n      pushDim(encodeSeriesName, start, count);\n      datasetRecord.categoryWayDim += count;\n    }\n  });\n  function pushDim(dimIdxArr, idxFrom, idxCount) {\n    for (var i = 0; i < idxCount; i++) {\n      dimIdxArr.push(idxFrom + i);\n    }\n  }\n  function getDataDimCountOnCoordDim(coordDimInfo) {\n    var dimsDef = coordDimInfo.dimsDef;\n    return dimsDef ? dimsDef.length : 1;\n  }\n  encodeItemName.length && (encode.itemName = encodeItemName);\n  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n  return encode;\n}\n/**\r\n * Work for data like [{name: ..., value: ...}, ...].\r\n *\r\n * @return encode Never be `null/undefined`.\r\n */\nfunction makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {\n  var encode = {};\n  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);\n  // Currently only make default when using dataset, util more reqirements occur.\n  if (!datasetModel) {\n    return encode;\n  }\n  var sourceFormat = source.sourceFormat;\n  var dimensionsDefine = source.dimensionsDefine;\n  var potentialNameDimIndex;\n  if (sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_2__/* .SOURCE_FORMAT_OBJECT_ROWS */ .Wk || sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_2__/* .SOURCE_FORMAT_KEYED_COLUMNS */ .t1) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(dimensionsDefine, function (dim, idx) {\n      if (((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(dim) ? dim.name : dim) === 'name') {\n        potentialNameDimIndex = idx;\n      }\n    });\n  }\n  var idxResult = function () {\n    var idxRes0 = {};\n    var idxRes1 = {};\n    var guessRecords = [];\n    // 5 is an experience value.\n    for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {\n      var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);\n      guessRecords.push(guessResult);\n      var isPureNumber = guessResult === BE_ORDINAL.Not;\n      // [Strategy of idxRes0]: find the first BE_ORDINAL.Not as the value dim,\n      // and then find a name dim with the priority:\n      // \"BE_ORDINAL.Might|BE_ORDINAL.Must\" > \"other dim\" > \"the value dim itself\".\n      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {\n        idxRes0.v = i;\n      }\n      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {\n        idxRes0.n = i;\n      }\n      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {\n        return idxRes0;\n      }\n      // [Strategy of idxRes1]: if idxRes0 not satisfied (that is, no BE_ORDINAL.Not),\n      // find the first BE_ORDINAL.Might as the value dim,\n      // and then find a name dim with the priority:\n      // \"other dim\" > \"the value dim itself\".\n      // That is for backward compat: number-like (e.g., `'3'`, `'55'`) can be\n      // treated as number.\n      if (!isPureNumber) {\n        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {\n          idxRes1.v = i;\n        }\n        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {\n          idxRes1.n = i;\n        }\n      }\n    }\n    function fulfilled(idxResult) {\n      return idxResult.v != null && idxResult.n != null;\n    }\n    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;\n  }();\n  if (idxResult) {\n    encode.value = [idxResult.v];\n    // `potentialNameDimIndex` has highest priority.\n    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;\n    // By default, label uses itemName in charts.\n    // So we don't set encodeLabel here.\n    encode.itemName = [nameDimIndex];\n    encode.seriesName = [nameDimIndex];\n  }\n  return encode;\n}\n/**\r\n * @return If return null/undefined, indicate that should not use datasetModel.\r\n */\nfunction querySeriesUpstreamDatasetModel(seriesModel) {\n  // Caution: consider the scenario:\n  // A dataset is declared and a series is not expected to use the dataset,\n  // and at the beginning `setOption({series: { noData })` (just prepare other\n  // option but no data), then `setOption({series: {data: [...]}); In this case,\n  // the user should set an empty array to avoid that dataset is used by default.\n  var thisData = seriesModel.get('data', true);\n  if (!thisData) {\n    return (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .queryReferringComponents */ .JO)(seriesModel.ecModel, 'dataset', {\n      index: seriesModel.get('datasetIndex', true),\n      id: seriesModel.get('datasetId', true)\n    }, _util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_REFERRING */ .US).models[0];\n  }\n}\n/**\r\n * @return Always return an array event empty.\r\n */\nfunction queryDatasetUpstreamDatasetModels(datasetModel) {\n  // Only these attributes declared, we by default reference to `datasetIndex: 0`.\n  // Otherwise, no reference.\n  if (!datasetModel.get('transform', true) && !datasetModel.get('fromTransformResult', true)) {\n    return [];\n  }\n  return (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .queryReferringComponents */ .JO)(datasetModel.ecModel, 'dataset', {\n    index: datasetModel.get('fromDatasetIndex', true),\n    id: datasetModel.get('fromDatasetId', true)\n  }, _util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_REFERRING */ .US).models;\n}\n/**\r\n * The rule should not be complex, otherwise user might not\r\n * be able to known where the data is wrong.\r\n * The code is ugly, but how to make it neat?\r\n */\nfunction guessOrdinal(source, dimIndex) {\n  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n}\n// dimIndex may be overflow source data.\n// return {BE_ORDINAL}\nfunction doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n  var result;\n  // Experience value.\n  var maxLoop = 5;\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isTypedArray)(data)) {\n    return BE_ORDINAL.Not;\n  }\n  // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine\n  // always exists in source.\n  var dimName;\n  var dimType;\n  if (dimensionsDefine) {\n    var dimDefItem = dimensionsDefine[dimIndex];\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(dimDefItem)) {\n      dimName = dimDefItem.name;\n      dimType = dimDefItem.type;\n    } else if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString)(dimDefItem)) {\n      dimName = dimDefItem;\n    }\n  }\n  if (dimType != null) {\n    return dimType === 'ordinal' ? BE_ORDINAL.Must : BE_ORDINAL.Not;\n  }\n  if (sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_2__/* .SOURCE_FORMAT_ARRAY_ROWS */ .Km) {\n    var dataArrayRows = data;\n    if (seriesLayoutBy === _util_types_js__WEBPACK_IMPORTED_MODULE_2__/* .SERIES_LAYOUT_BY_ROW */ .oC) {\n      var sample = dataArrayRows[dimIndex];\n      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n        if ((result = detectValue(sample[startIndex + i])) != null) {\n          return result;\n        }\n      }\n    } else {\n      for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {\n        var row = dataArrayRows[startIndex + i];\n        if (row && (result = detectValue(row[dimIndex])) != null) {\n          return result;\n        }\n      }\n    }\n  } else if (sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_2__/* .SOURCE_FORMAT_OBJECT_ROWS */ .Wk) {\n    var dataObjectRows = data;\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n    for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {\n      var item = dataObjectRows[i];\n      if (item && (result = detectValue(item[dimName])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_2__/* .SOURCE_FORMAT_KEYED_COLUMNS */ .t1) {\n    var dataKeyedColumns = data;\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n    var sample = dataKeyedColumns[dimName];\n    if (!sample || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isTypedArray)(sample)) {\n      return BE_ORDINAL.Not;\n    }\n    for (var i = 0; i < sample.length && i < maxLoop; i++) {\n      if ((result = detectValue(sample[i])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_2__/* .SOURCE_FORMAT_ORIGINAL */ .mK) {\n    var dataOriginal = data;\n    for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {\n      var item = dataOriginal[i];\n      var val = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .getDataItemValue */ .vj)(item);\n      if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {\n        return BE_ORDINAL.Not;\n      }\n      if ((result = detectValue(val[dimIndex])) != null) {\n        return result;\n      }\n    }\n  }\n  function detectValue(val) {\n    var beStr = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString)(val);\n    // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `Number('')` (or any whitespace) is `0`.\n    if (val != null && Number.isFinite(Number(val)) && val !== '') {\n      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;\n    } else if (beStr && val !== '-') {\n      return BE_ORDINAL.Must;\n    }\n  }\n  return BE_ORDINAL.Not;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMwNzEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL2hlbHBlci9zb3VyY2VIZWxwZXIuanM/YWEwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IG1ha2VJbm5lciwgZ2V0RGF0YUl0ZW1WYWx1ZSwgcXVlcnlSZWZlcnJpbmdDb21wb25lbnRzLCBTSU5HTEVfUkVGRVJSSU5HIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoTWFwLCBlYWNoLCBpc0FycmF5LCBpc1N0cmluZywgaXNPYmplY3QsIGlzVHlwZWRBcnJheSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBTT1VSQ0VfRk9STUFUX09SSUdJTkFMLCBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MsIFNPVVJDRV9GT1JNQVRfT0JKRUNUX1JPV1MsIFNFUklFU19MQVlPVVRfQllfUk9XLCBTT1VSQ0VfRk9STUFUX0tFWUVEX0NPTFVNTlMgfSBmcm9tICcuLi8uLi91dGlsL3R5cGVzLmpzJztcbi8vIFRoZSByZXN1bHQgb2YgYGd1ZXNzT3JkaW5hbGAuXG5leHBvcnQgdmFyIEJFX09SRElOQUwgPSB7XG4gIE11c3Q6IDEsXG4gIE1pZ2h0OiAyLFxuICBOb3Q6IDMgLy8gT3RoZXIgY2FzZXNcbn07XG52YXIgaW5uZXJHbG9iYWxNb2RlbCA9IG1ha2VJbm5lcigpO1xuLyoqXHJcbiAqIE1VU1QgYmUgY2FsbGVkIGJlZm9yZSBtZXJnZU9wdGlvbiBvZiBhbGwgc2VyaWVzLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldFNvdXJjZURlZmF1bHRlcihlY01vZGVsKSB7XG4gIC8vIGBkYXRhc2V0TWFwYCBpcyB1c2VkIHRvIG1ha2UgZGVmYXVsdCBlbmNvZGUuXG4gIGlubmVyR2xvYmFsTW9kZWwoZWNNb2RlbCkuZGF0YXNldE1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbn1cbi8qKlxyXG4gKiBbVGhlIHN0cmF0ZWd5IG9mIHRoZSBhcnJlbmdtZW50IG9mIGRhdGEgZGltZW5zaW9ucyBmb3IgZGF0YXNldF06XHJcbiAqIFwidmFsdWUgd2F5XCI6IGFsbCBheGVzIGFyZSBub24tY2F0ZWdvcnkgYXhlcy4gU28gc2VyaWVzIG9uZSBieSBvbmUgdGFrZVxyXG4gKiAgICAgc2V2ZXJhbCAodGhlIG51bWJlciBpcyBjb29yZFN5c0RpbXMubGVuZ3RoKSBkaW1lbnNpb25zIGZyb20gZGF0YXNldC5cclxuICogICAgIFRoZSByZXN1bHQgb2YgZGF0YSBhcnJlbmdtZW50IG9mIGRhdGEgZGltZW5zaW9ucyBsaWtlOlxyXG4gKiAgICAgfCBzZXIwX3ggfCBzZXIwX3kgfCBzZXIxX3ggfCBzZXIxX3kgfCBzZXIyX3ggfCBzZXIyX3kgfFxyXG4gKiBcImNhdGVnb3J5IHdheVwiOiBhdCBsZWFzdCBvbmUgYXhpcyBpcyBjYXRlZ29yeSBheGlzLiBTbyB0aGUgdGhlIGZpcnN0IGRhdGFcclxuICogICAgIGRpbWVuc2lvbiBpcyBhbHdheXMgbWFwcGVkIHRvIHRoZSBmaXJzdCBjYXRlZ29yeSBheGlzIGFuZCBzaGFyZWQgYnlcclxuICogICAgIGFsbCBvZiB0aGUgc2VyaWVzLiBUaGUgb3RoZXIgZGF0YSBkaW1lbnNpb25zIGFyZSB0YWtlbiBieSBzZXJpZXMgbGlrZVxyXG4gKiAgICAgXCJ2YWx1ZSB3YXlcIiBkb2VzLlxyXG4gKiAgICAgVGhlIHJlc3VsdCBvZiBkYXRhIGFycmVuZ21lbnQgb2YgZGF0YSBkaW1lbnNpb25zIGxpa2U6XHJcbiAqICAgICB8IHNlcl9zaGFyZWRfeCB8IHNlcjBfeSB8IHNlcjFfeSB8IHNlcjJfeSB8XHJcbiAqXHJcbiAqIEByZXR1cm4gZW5jb2RlIE5ldmVyIGJlIGBudWxsL3VuZGVmaW5lZGAuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTZXJpZXNFbmNvZGVGb3JBeGlzQ29vcmRTeXMoY29vcmREaW1lbnNpb25zLCBzZXJpZXNNb2RlbCwgc291cmNlKSB7XG4gIHZhciBlbmNvZGUgPSB7fTtcbiAgdmFyIGRhdGFzZXRNb2RlbCA9IHF1ZXJ5U2VyaWVzVXBzdHJlYW1EYXRhc2V0TW9kZWwoc2VyaWVzTW9kZWwpO1xuICAvLyBDdXJyZW50bHkgb25seSBtYWtlIGRlZmF1bHQgd2hlbiB1c2luZyBkYXRhc2V0LCB1dGlsIG1vcmUgcmVxaXJlbWVudHMgb2NjdXIuXG4gIGlmICghZGF0YXNldE1vZGVsIHx8ICFjb29yZERpbWVuc2lvbnMpIHtcbiAgICByZXR1cm4gZW5jb2RlO1xuICB9XG4gIHZhciBlbmNvZGVJdGVtTmFtZSA9IFtdO1xuICB2YXIgZW5jb2RlU2VyaWVzTmFtZSA9IFtdO1xuICB2YXIgZWNNb2RlbCA9IHNlcmllc01vZGVsLmVjTW9kZWw7XG4gIHZhciBkYXRhc2V0TWFwID0gaW5uZXJHbG9iYWxNb2RlbChlY01vZGVsKS5kYXRhc2V0TWFwO1xuICB2YXIga2V5ID0gZGF0YXNldE1vZGVsLnVpZCArICdfJyArIHNvdXJjZS5zZXJpZXNMYXlvdXRCeTtcbiAgdmFyIGJhc2VDYXRlZ29yeURpbUluZGV4O1xuICB2YXIgY2F0ZWdvcnlXYXlWYWx1ZURpbVN0YXJ0O1xuICBjb29yZERpbWVuc2lvbnMgPSBjb29yZERpbWVuc2lvbnMuc2xpY2UoKTtcbiAgZWFjaChjb29yZERpbWVuc2lvbnMsIGZ1bmN0aW9uIChjb29yZERpbUluZm9Mb29zZSwgY29vcmREaW1JZHgpIHtcbiAgICB2YXIgY29vcmREaW1JbmZvID0gaXNPYmplY3QoY29vcmREaW1JbmZvTG9vc2UpID8gY29vcmREaW1JbmZvTG9vc2UgOiBjb29yZERpbWVuc2lvbnNbY29vcmREaW1JZHhdID0ge1xuICAgICAgbmFtZTogY29vcmREaW1JbmZvTG9vc2VcbiAgICB9O1xuICAgIGlmIChjb29yZERpbUluZm8udHlwZSA9PT0gJ29yZGluYWwnICYmIGJhc2VDYXRlZ29yeURpbUluZGV4ID09IG51bGwpIHtcbiAgICAgIGJhc2VDYXRlZ29yeURpbUluZGV4ID0gY29vcmREaW1JZHg7XG4gICAgICBjYXRlZ29yeVdheVZhbHVlRGltU3RhcnQgPSBnZXREYXRhRGltQ291bnRPbkNvb3JkRGltKGNvb3JkRGltSW5mbyk7XG4gICAgfVxuICAgIGVuY29kZVtjb29yZERpbUluZm8ubmFtZV0gPSBbXTtcbiAgfSk7XG4gIHZhciBkYXRhc2V0UmVjb3JkID0gZGF0YXNldE1hcC5nZXQoa2V5KSB8fCBkYXRhc2V0TWFwLnNldChrZXksIHtcbiAgICBjYXRlZ29yeVdheURpbTogY2F0ZWdvcnlXYXlWYWx1ZURpbVN0YXJ0LFxuICAgIHZhbHVlV2F5RGltOiAwXG4gIH0pO1xuICAvLyBUT0RPXG4gIC8vIEF1dG8gZGV0ZWN0IGZpcnN0IHRpbWUgYXhpcyBhbmQgZG8gYXJyYW5nZW1lbnQuXG4gIGVhY2goY29vcmREaW1lbnNpb25zLCBmdW5jdGlvbiAoY29vcmREaW1JbmZvLCBjb29yZERpbUlkeCkge1xuICAgIHZhciBjb29yZERpbU5hbWUgPSBjb29yZERpbUluZm8ubmFtZTtcbiAgICB2YXIgY291bnQgPSBnZXREYXRhRGltQ291bnRPbkNvb3JkRGltKGNvb3JkRGltSW5mbyk7XG4gICAgLy8gSW4gdmFsdWUgd2F5LlxuICAgIGlmIChiYXNlQ2F0ZWdvcnlEaW1JbmRleCA9PSBudWxsKSB7XG4gICAgICB2YXIgc3RhcnQgPSBkYXRhc2V0UmVjb3JkLnZhbHVlV2F5RGltO1xuICAgICAgcHVzaERpbShlbmNvZGVbY29vcmREaW1OYW1lXSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIHB1c2hEaW0oZW5jb2RlU2VyaWVzTmFtZSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIGRhdGFzZXRSZWNvcmQudmFsdWVXYXlEaW0gKz0gY291bnQ7XG4gICAgICAvLyA/Pz8gVE9ETyBnaXZlIGEgYmV0dGVyIGRlZmF1bHQgc2VyaWVzIG5hbWUgcnVsZT9cbiAgICAgIC8vIGVzcGVjaWFsbHkgd2hlbiBlbmNvZGUgeCB5IHNwZWNpZmllZC5cbiAgICAgIC8vIGNvbnNpZGVyOiB3aGVuIG11bHRpcGxlIHNlcmllcyBzaGFyZSBvbmUgZGltZW5zaW9uXG4gICAgICAvLyBjYXRlZ29yeSBheGlzLCBzZXJpZXMgbmFtZSBzaG91bGQgYmV0dGVyIHVzZVxuICAgICAgLy8gdGhlIG90aGVyIGRpbWVuc2lvbiBuYW1lLiBPbiB0aGUgb3RoZXIgaGFuZCwgdXNlXG4gICAgICAvLyBib3RoIGRpbWVuc2lvbnMgbmFtZS5cbiAgICB9XG4gICAgLy8gSW4gY2F0ZWdvcnkgd2F5LCB0aGUgZmlyc3QgY2F0ZWdvcnkgYXhpcy5cbiAgICBlbHNlIGlmIChiYXNlQ2F0ZWdvcnlEaW1JbmRleCA9PT0gY29vcmREaW1JZHgpIHtcbiAgICAgIHB1c2hEaW0oZW5jb2RlW2Nvb3JkRGltTmFtZV0sIDAsIGNvdW50KTtcbiAgICAgIHB1c2hEaW0oZW5jb2RlSXRlbU5hbWUsIDAsIGNvdW50KTtcbiAgICB9XG4gICAgLy8gSW4gY2F0ZWdvcnkgd2F5LCB0aGUgb3RoZXIgYXhpcy5cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGRhdGFzZXRSZWNvcmQuY2F0ZWdvcnlXYXlEaW07XG4gICAgICBwdXNoRGltKGVuY29kZVtjb29yZERpbU5hbWVdLCBzdGFydCwgY291bnQpO1xuICAgICAgcHVzaERpbShlbmNvZGVTZXJpZXNOYW1lLCBzdGFydCwgY291bnQpO1xuICAgICAgZGF0YXNldFJlY29yZC5jYXRlZ29yeVdheURpbSArPSBjb3VudDtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBwdXNoRGltKGRpbUlkeEFyciwgaWR4RnJvbSwgaWR4Q291bnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkeENvdW50OyBpKyspIHtcbiAgICAgIGRpbUlkeEFyci5wdXNoKGlkeEZyb20gKyBpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RGF0YURpbUNvdW50T25Db29yZERpbShjb29yZERpbUluZm8pIHtcbiAgICB2YXIgZGltc0RlZiA9IGNvb3JkRGltSW5mby5kaW1zRGVmO1xuICAgIHJldHVybiBkaW1zRGVmID8gZGltc0RlZi5sZW5ndGggOiAxO1xuICB9XG4gIGVuY29kZUl0ZW1OYW1lLmxlbmd0aCAmJiAoZW5jb2RlLml0ZW1OYW1lID0gZW5jb2RlSXRlbU5hbWUpO1xuICBlbmNvZGVTZXJpZXNOYW1lLmxlbmd0aCAmJiAoZW5jb2RlLnNlcmllc05hbWUgPSBlbmNvZGVTZXJpZXNOYW1lKTtcbiAgcmV0dXJuIGVuY29kZTtcbn1cbi8qKlxyXG4gKiBXb3JrIGZvciBkYXRhIGxpa2UgW3tuYW1lOiAuLi4sIHZhbHVlOiAuLi59LCAuLi5dLlxyXG4gKlxyXG4gKiBAcmV0dXJuIGVuY29kZSBOZXZlciBiZSBgbnVsbC91bmRlZmluZWRgLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlU2VyaWVzRW5jb2RlRm9yTmFtZUJhc2VkKHNlcmllc01vZGVsLCBzb3VyY2UsIGRpbUNvdW50KSB7XG4gIHZhciBlbmNvZGUgPSB7fTtcbiAgdmFyIGRhdGFzZXRNb2RlbCA9IHF1ZXJ5U2VyaWVzVXBzdHJlYW1EYXRhc2V0TW9kZWwoc2VyaWVzTW9kZWwpO1xuICAvLyBDdXJyZW50bHkgb25seSBtYWtlIGRlZmF1bHQgd2hlbiB1c2luZyBkYXRhc2V0LCB1dGlsIG1vcmUgcmVxaXJlbWVudHMgb2NjdXIuXG4gIGlmICghZGF0YXNldE1vZGVsKSB7XG4gICAgcmV0dXJuIGVuY29kZTtcbiAgfVxuICB2YXIgc291cmNlRm9ybWF0ID0gc291cmNlLnNvdXJjZUZvcm1hdDtcbiAgdmFyIGRpbWVuc2lvbnNEZWZpbmUgPSBzb3VyY2UuZGltZW5zaW9uc0RlZmluZTtcbiAgdmFyIHBvdGVudGlhbE5hbWVEaW1JbmRleDtcbiAgaWYgKHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9PQkpFQ1RfUk9XUyB8fCBzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfS0VZRURfQ09MVU1OUykge1xuICAgIGVhY2goZGltZW5zaW9uc0RlZmluZSwgZnVuY3Rpb24gKGRpbSwgaWR4KSB7XG4gICAgICBpZiAoKGlzT2JqZWN0KGRpbSkgPyBkaW0ubmFtZSA6IGRpbSkgPT09ICduYW1lJykge1xuICAgICAgICBwb3RlbnRpYWxOYW1lRGltSW5kZXggPSBpZHg7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdmFyIGlkeFJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4UmVzMCA9IHt9O1xuICAgIHZhciBpZHhSZXMxID0ge307XG4gICAgdmFyIGd1ZXNzUmVjb3JkcyA9IFtdO1xuICAgIC8vIDUgaXMgYW4gZXhwZXJpZW5jZSB2YWx1ZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oNSwgZGltQ291bnQpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBndWVzc1Jlc3VsdCA9IGRvR3Vlc3NPcmRpbmFsKHNvdXJjZS5kYXRhLCBzb3VyY2VGb3JtYXQsIHNvdXJjZS5zZXJpZXNMYXlvdXRCeSwgZGltZW5zaW9uc0RlZmluZSwgc291cmNlLnN0YXJ0SW5kZXgsIGkpO1xuICAgICAgZ3Vlc3NSZWNvcmRzLnB1c2goZ3Vlc3NSZXN1bHQpO1xuICAgICAgdmFyIGlzUHVyZU51bWJlciA9IGd1ZXNzUmVzdWx0ID09PSBCRV9PUkRJTkFMLk5vdDtcbiAgICAgIC8vIFtTdHJhdGVneSBvZiBpZHhSZXMwXTogZmluZCB0aGUgZmlyc3QgQkVfT1JESU5BTC5Ob3QgYXMgdGhlIHZhbHVlIGRpbSxcbiAgICAgIC8vIGFuZCB0aGVuIGZpbmQgYSBuYW1lIGRpbSB3aXRoIHRoZSBwcmlvcml0eTpcbiAgICAgIC8vIFwiQkVfT1JESU5BTC5NaWdodHxCRV9PUkRJTkFMLk11c3RcIiA+IFwib3RoZXIgZGltXCIgPiBcInRoZSB2YWx1ZSBkaW0gaXRzZWxmXCIuXG4gICAgICBpZiAoaXNQdXJlTnVtYmVyICYmIGlkeFJlczAudiA9PSBudWxsICYmIGkgIT09IHBvdGVudGlhbE5hbWVEaW1JbmRleCkge1xuICAgICAgICBpZHhSZXMwLnYgPSBpO1xuICAgICAgfVxuICAgICAgaWYgKGlkeFJlczAubiA9PSBudWxsIHx8IGlkeFJlczAubiA9PT0gaWR4UmVzMC52IHx8ICFpc1B1cmVOdW1iZXIgJiYgZ3Vlc3NSZWNvcmRzW2lkeFJlczAubl0gPT09IEJFX09SRElOQUwuTm90KSB7XG4gICAgICAgIGlkeFJlczAubiA9IGk7XG4gICAgICB9XG4gICAgICBpZiAoZnVsZmlsbGVkKGlkeFJlczApICYmIGd1ZXNzUmVjb3Jkc1tpZHhSZXMwLm5dICE9PSBCRV9PUkRJTkFMLk5vdCkge1xuICAgICAgICByZXR1cm4gaWR4UmVzMDtcbiAgICAgIH1cbiAgICAgIC8vIFtTdHJhdGVneSBvZiBpZHhSZXMxXTogaWYgaWR4UmVzMCBub3Qgc2F0aXNmaWVkICh0aGF0IGlzLCBubyBCRV9PUkRJTkFMLk5vdCksXG4gICAgICAvLyBmaW5kIHRoZSBmaXJzdCBCRV9PUkRJTkFMLk1pZ2h0IGFzIHRoZSB2YWx1ZSBkaW0sXG4gICAgICAvLyBhbmQgdGhlbiBmaW5kIGEgbmFtZSBkaW0gd2l0aCB0aGUgcHJpb3JpdHk6XG4gICAgICAvLyBcIm90aGVyIGRpbVwiID4gXCJ0aGUgdmFsdWUgZGltIGl0c2VsZlwiLlxuICAgICAgLy8gVGhhdCBpcyBmb3IgYmFja3dhcmQgY29tcGF0OiBudW1iZXItbGlrZSAoZS5nLiwgYCczJ2AsIGAnNTUnYCkgY2FuIGJlXG4gICAgICAvLyB0cmVhdGVkIGFzIG51bWJlci5cbiAgICAgIGlmICghaXNQdXJlTnVtYmVyKSB7XG4gICAgICAgIGlmIChndWVzc1Jlc3VsdCA9PT0gQkVfT1JESU5BTC5NaWdodCAmJiBpZHhSZXMxLnYgPT0gbnVsbCAmJiBpICE9PSBwb3RlbnRpYWxOYW1lRGltSW5kZXgpIHtcbiAgICAgICAgICBpZHhSZXMxLnYgPSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZHhSZXMxLm4gPT0gbnVsbCB8fCBpZHhSZXMxLm4gPT09IGlkeFJlczEudikge1xuICAgICAgICAgIGlkeFJlczEubiA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZnVsZmlsbGVkKGlkeFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGlkeFJlc3VsdC52ICE9IG51bGwgJiYgaWR4UmVzdWx0Lm4gIT0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bGZpbGxlZChpZHhSZXMwKSA/IGlkeFJlczAgOiBmdWxmaWxsZWQoaWR4UmVzMSkgPyBpZHhSZXMxIDogbnVsbDtcbiAgfSgpO1xuICBpZiAoaWR4UmVzdWx0KSB7XG4gICAgZW5jb2RlLnZhbHVlID0gW2lkeFJlc3VsdC52XTtcbiAgICAvLyBgcG90ZW50aWFsTmFtZURpbUluZGV4YCBoYXMgaGlnaGVzdCBwcmlvcml0eS5cbiAgICB2YXIgbmFtZURpbUluZGV4ID0gcG90ZW50aWFsTmFtZURpbUluZGV4ICE9IG51bGwgPyBwb3RlbnRpYWxOYW1lRGltSW5kZXggOiBpZHhSZXN1bHQubjtcbiAgICAvLyBCeSBkZWZhdWx0LCBsYWJlbCB1c2VzIGl0ZW1OYW1lIGluIGNoYXJ0cy5cbiAgICAvLyBTbyB3ZSBkb24ndCBzZXQgZW5jb2RlTGFiZWwgaGVyZS5cbiAgICBlbmNvZGUuaXRlbU5hbWUgPSBbbmFtZURpbUluZGV4XTtcbiAgICBlbmNvZGUuc2VyaWVzTmFtZSA9IFtuYW1lRGltSW5kZXhdO1xuICB9XG4gIHJldHVybiBlbmNvZGU7XG59XG4vKipcclxuICogQHJldHVybiBJZiByZXR1cm4gbnVsbC91bmRlZmluZWQsIGluZGljYXRlIHRoYXQgc2hvdWxkIG5vdCB1c2UgZGF0YXNldE1vZGVsLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeVNlcmllc1Vwc3RyZWFtRGF0YXNldE1vZGVsKHNlcmllc01vZGVsKSB7XG4gIC8vIENhdXRpb246IGNvbnNpZGVyIHRoZSBzY2VuYXJpbzpcbiAgLy8gQSBkYXRhc2V0IGlzIGRlY2xhcmVkIGFuZCBhIHNlcmllcyBpcyBub3QgZXhwZWN0ZWQgdG8gdXNlIHRoZSBkYXRhc2V0LFxuICAvLyBhbmQgYXQgdGhlIGJlZ2lubmluZyBgc2V0T3B0aW9uKHtzZXJpZXM6IHsgbm9EYXRhIH0pYCAoanVzdCBwcmVwYXJlIG90aGVyXG4gIC8vIG9wdGlvbiBidXQgbm8gZGF0YSksIHRoZW4gYHNldE9wdGlvbih7c2VyaWVzOiB7ZGF0YTogWy4uLl19KTsgSW4gdGhpcyBjYXNlLFxuICAvLyB0aGUgdXNlciBzaG91bGQgc2V0IGFuIGVtcHR5IGFycmF5IHRvIGF2b2lkIHRoYXQgZGF0YXNldCBpcyB1c2VkIGJ5IGRlZmF1bHQuXG4gIHZhciB0aGlzRGF0YSA9IHNlcmllc01vZGVsLmdldCgnZGF0YScsIHRydWUpO1xuICBpZiAoIXRoaXNEYXRhKSB7XG4gICAgcmV0dXJuIHF1ZXJ5UmVmZXJyaW5nQ29tcG9uZW50cyhzZXJpZXNNb2RlbC5lY01vZGVsLCAnZGF0YXNldCcsIHtcbiAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQoJ2RhdGFzZXRJbmRleCcsIHRydWUpLFxuICAgICAgaWQ6IHNlcmllc01vZGVsLmdldCgnZGF0YXNldElkJywgdHJ1ZSlcbiAgICB9LCBTSU5HTEVfUkVGRVJSSU5HKS5tb2RlbHNbMF07XG4gIH1cbn1cbi8qKlxyXG4gKiBAcmV0dXJuIEFsd2F5cyByZXR1cm4gYW4gYXJyYXkgZXZlbnQgZW1wdHkuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5RGF0YXNldFVwc3RyZWFtRGF0YXNldE1vZGVscyhkYXRhc2V0TW9kZWwpIHtcbiAgLy8gT25seSB0aGVzZSBhdHRyaWJ1dGVzIGRlY2xhcmVkLCB3ZSBieSBkZWZhdWx0IHJlZmVyZW5jZSB0byBgZGF0YXNldEluZGV4OiAwYC5cbiAgLy8gT3RoZXJ3aXNlLCBubyByZWZlcmVuY2UuXG4gIGlmICghZGF0YXNldE1vZGVsLmdldCgndHJhbnNmb3JtJywgdHJ1ZSkgJiYgIWRhdGFzZXRNb2RlbC5nZXQoJ2Zyb21UcmFuc2Zvcm1SZXN1bHQnLCB0cnVlKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gcXVlcnlSZWZlcnJpbmdDb21wb25lbnRzKGRhdGFzZXRNb2RlbC5lY01vZGVsLCAnZGF0YXNldCcsIHtcbiAgICBpbmRleDogZGF0YXNldE1vZGVsLmdldCgnZnJvbURhdGFzZXRJbmRleCcsIHRydWUpLFxuICAgIGlkOiBkYXRhc2V0TW9kZWwuZ2V0KCdmcm9tRGF0YXNldElkJywgdHJ1ZSlcbiAgfSwgU0lOR0xFX1JFRkVSUklORykubW9kZWxzO1xufVxuLyoqXHJcbiAqIFRoZSBydWxlIHNob3VsZCBub3QgYmUgY29tcGxleCwgb3RoZXJ3aXNlIHVzZXIgbWlnaHQgbm90XHJcbiAqIGJlIGFibGUgdG8ga25vd24gd2hlcmUgdGhlIGRhdGEgaXMgd3JvbmcuXHJcbiAqIFRoZSBjb2RlIGlzIHVnbHksIGJ1dCBob3cgdG8gbWFrZSBpdCBuZWF0P1xyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBndWVzc09yZGluYWwoc291cmNlLCBkaW1JbmRleCkge1xuICByZXR1cm4gZG9HdWVzc09yZGluYWwoc291cmNlLmRhdGEsIHNvdXJjZS5zb3VyY2VGb3JtYXQsIHNvdXJjZS5zZXJpZXNMYXlvdXRCeSwgc291cmNlLmRpbWVuc2lvbnNEZWZpbmUsIHNvdXJjZS5zdGFydEluZGV4LCBkaW1JbmRleCk7XG59XG4vLyBkaW1JbmRleCBtYXkgYmUgb3ZlcmZsb3cgc291cmNlIGRhdGEuXG4vLyByZXR1cm4ge0JFX09SRElOQUx9XG5mdW5jdGlvbiBkb0d1ZXNzT3JkaW5hbChkYXRhLCBzb3VyY2VGb3JtYXQsIHNlcmllc0xheW91dEJ5LCBkaW1lbnNpb25zRGVmaW5lLCBzdGFydEluZGV4LCBkaW1JbmRleCkge1xuICB2YXIgcmVzdWx0O1xuICAvLyBFeHBlcmllbmNlIHZhbHVlLlxuICB2YXIgbWF4TG9vcCA9IDU7XG4gIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gQkVfT1JESU5BTC5Ob3Q7XG4gIH1cbiAgLy8gV2hlbiBzb3VyY2VUeXBlIGlzICdvYmplY3RSb3dzJyBvciAna2V5ZWRDb2x1bW5zJywgZGltZW5zaW9uc0RlZmluZVxuICAvLyBhbHdheXMgZXhpc3RzIGluIHNvdXJjZS5cbiAgdmFyIGRpbU5hbWU7XG4gIHZhciBkaW1UeXBlO1xuICBpZiAoZGltZW5zaW9uc0RlZmluZSkge1xuICAgIHZhciBkaW1EZWZJdGVtID0gZGltZW5zaW9uc0RlZmluZVtkaW1JbmRleF07XG4gICAgaWYgKGlzT2JqZWN0KGRpbURlZkl0ZW0pKSB7XG4gICAgICBkaW1OYW1lID0gZGltRGVmSXRlbS5uYW1lO1xuICAgICAgZGltVHlwZSA9IGRpbURlZkl0ZW0udHlwZTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGRpbURlZkl0ZW0pKSB7XG4gICAgICBkaW1OYW1lID0gZGltRGVmSXRlbTtcbiAgICB9XG4gIH1cbiAgaWYgKGRpbVR5cGUgIT0gbnVsbCkge1xuICAgIHJldHVybiBkaW1UeXBlID09PSAnb3JkaW5hbCcgPyBCRV9PUkRJTkFMLk11c3QgOiBCRV9PUkRJTkFMLk5vdDtcbiAgfVxuICBpZiAoc291cmNlRm9ybWF0ID09PSBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MpIHtcbiAgICB2YXIgZGF0YUFycmF5Um93cyA9IGRhdGE7XG4gICAgaWYgKHNlcmllc0xheW91dEJ5ID09PSBTRVJJRVNfTEFZT1VUX0JZX1JPVykge1xuICAgICAgdmFyIHNhbXBsZSA9IGRhdGFBcnJheVJvd3NbZGltSW5kZXhdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoc2FtcGxlIHx8IFtdKS5sZW5ndGggJiYgaSA8IG1heExvb3A7IGkrKykge1xuICAgICAgICBpZiAoKHJlc3VsdCA9IGRldGVjdFZhbHVlKHNhbXBsZVtzdGFydEluZGV4ICsgaV0pKSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFBcnJheVJvd3MubGVuZ3RoICYmIGkgPCBtYXhMb29wOyBpKyspIHtcbiAgICAgICAgdmFyIHJvdyA9IGRhdGFBcnJheVJvd3Nbc3RhcnRJbmRleCArIGldO1xuICAgICAgICBpZiAocm93ICYmIChyZXN1bHQgPSBkZXRlY3RWYWx1ZShyb3dbZGltSW5kZXhdKSkgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc291cmNlRm9ybWF0ID09PSBTT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTKSB7XG4gICAgdmFyIGRhdGFPYmplY3RSb3dzID0gZGF0YTtcbiAgICBpZiAoIWRpbU5hbWUpIHtcbiAgICAgIHJldHVybiBCRV9PUkRJTkFMLk5vdDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhT2JqZWN0Um93cy5sZW5ndGggJiYgaSA8IG1heExvb3A7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhT2JqZWN0Um93c1tpXTtcbiAgICAgIGlmIChpdGVtICYmIChyZXN1bHQgPSBkZXRlY3RWYWx1ZShpdGVtW2RpbU5hbWVdKSkgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfS0VZRURfQ09MVU1OUykge1xuICAgIHZhciBkYXRhS2V5ZWRDb2x1bW5zID0gZGF0YTtcbiAgICBpZiAoIWRpbU5hbWUpIHtcbiAgICAgIHJldHVybiBCRV9PUkRJTkFMLk5vdDtcbiAgICB9XG4gICAgdmFyIHNhbXBsZSA9IGRhdGFLZXllZENvbHVtbnNbZGltTmFtZV07XG4gICAgaWYgKCFzYW1wbGUgfHwgaXNUeXBlZEFycmF5KHNhbXBsZSkpIHtcbiAgICAgIHJldHVybiBCRV9PUkRJTkFMLk5vdDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGUubGVuZ3RoICYmIGkgPCBtYXhMb29wOyBpKyspIHtcbiAgICAgIGlmICgocmVzdWx0ID0gZGV0ZWN0VmFsdWUoc2FtcGxlW2ldKSkgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfT1JJR0lOQUwpIHtcbiAgICB2YXIgZGF0YU9yaWdpbmFsID0gZGF0YTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFPcmlnaW5hbC5sZW5ndGggJiYgaSA8IG1heExvb3A7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhT3JpZ2luYWxbaV07XG4gICAgICB2YXIgdmFsID0gZ2V0RGF0YUl0ZW1WYWx1ZShpdGVtKTtcbiAgICAgIGlmICghaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiBCRV9PUkRJTkFMLk5vdDtcbiAgICAgIH1cbiAgICAgIGlmICgocmVzdWx0ID0gZGV0ZWN0VmFsdWUodmFsW2RpbUluZGV4XSkpICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGV0ZWN0VmFsdWUodmFsKSB7XG4gICAgdmFyIGJlU3RyID0gaXNTdHJpbmcodmFsKTtcbiAgICAvLyBDb25zaWRlciB1c2FnZSBjb252ZW5pZW5jZSwgJzEnLCAnMicgd2lsbCBiZSB0cmVhdGVkIGFzIFwibnVtYmVyXCIuXG4gICAgLy8gYE51bWJlcignJylgIChvciBhbnkgd2hpdGVzcGFjZSkgaXMgYDBgLlxuICAgIGlmICh2YWwgIT0gbnVsbCAmJiBOdW1iZXIuaXNGaW5pdGUoTnVtYmVyKHZhbCkpICYmIHZhbCAhPT0gJycpIHtcbiAgICAgIHJldHVybiBiZVN0ciA/IEJFX09SRElOQUwuTWlnaHQgOiBCRV9PUkRJTkFMLk5vdDtcbiAgICB9IGVsc2UgaWYgKGJlU3RyICYmIHZhbCAhPT0gJy0nKSB7XG4gICAgICByZXR1cm4gQkVfT1JESU5BTC5NdXN0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gQkVfT1JESU5BTC5Ob3Q7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23071\n")},29756:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   B: () => (/* binding */ getDimensionTypeByAxis),\n/* harmony export */   l: () => (/* binding */ summarizeDimensions)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13430);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar DimensionUserOuput = /** @class */function () {\n  function DimensionUserOuput(encode, dimRequest) {\n    this._encode = encode;\n    this._schema = dimRequest;\n  }\n  DimensionUserOuput.prototype.get = function () {\n    return {\n      // Do not generate full dimension name until fist used.\n      fullDimensions: this._getFullDimensionNames(),\n      encode: this._encode\n    };\n  };\n  /**\r\n   * Get all data store dimension names.\r\n   * Theoretically a series data store is defined both by series and used dataset (if any).\r\n   * If some dimensions are omitted for performance reason in `this.dimensions`,\r\n   * the dimension name may not be auto-generated if user does not specify a dimension name.\r\n   * In this case, the dimension name is `null`/`undefined`.\r\n   */\n  DimensionUserOuput.prototype._getFullDimensionNames = function () {\n    if (!this._cachedDimNames) {\n      this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];\n    }\n    return this._cachedDimNames;\n  };\n  return DimensionUserOuput;\n}();\n;\nfunction summarizeDimensions(data, schema) {\n  var summary = {};\n  var encode = summary.encode = {};\n  var notExtraCoordDimMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)();\n  var defaultedLabel = [];\n  var defaultedTooltip = [];\n  var userOutputEncode = {};\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(data.dimensions, function (dimName) {\n    var dimItem = data.getDimensionInfo(dimName);\n    var coordDim = dimItem.coordDim;\n    if (coordDim) {\n      if (false) {}\n      var coordDimIndex = dimItem.coordDimIndex;\n      getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;\n      if (!dimItem.isExtraCoord) {\n        notExtraCoordDimMap.set(coordDim, 1);\n        // Use the last coord dim (and label friendly) as default label,\n        // because when dataset is used, it is hard to guess which dimension\n        // can be value dimension. If both show x, y on label is not look good,\n        // and conventionally y axis is focused more.\n        if (mayLabelDimType(dimItem.type)) {\n          defaultedLabel[0] = dimName;\n        }\n        // User output encode do not contain generated coords.\n        // And it only has index. User can use index to retrieve value from the raw item array.\n        getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);\n      }\n      if (dimItem.defaultTooltip) {\n        defaultedTooltip.push(dimName);\n      }\n    }\n    _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .VISUAL_DIMENSIONS */ .Pe.each(function (v, otherDim) {\n      var encodeArr = getOrCreateEncodeArr(encode, otherDim);\n      var dimIndex = dimItem.otherDims[otherDim];\n      if (dimIndex != null && dimIndex !== false) {\n        encodeArr[dimIndex] = dimItem.name;\n      }\n    });\n  });\n  var dataDimsOnCoord = [];\n  var encodeFirstDimNotExtra = {};\n  notExtraCoordDimMap.each(function (v, coordDim) {\n    var dimArr = encode[coordDim];\n    encodeFirstDimNotExtra[coordDim] = dimArr[0];\n    // Not necessary to remove duplicate, because a data\n    // dim canot on more than one coordDim.\n    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);\n  });\n  summary.dataDimsOnCoord = dataDimsOnCoord;\n  summary.dataDimIndicesOnCoord = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)(dataDimsOnCoord, function (dimName) {\n    return data.getDimensionInfo(dimName).storeDimIndex;\n  });\n  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;\n  var encodeLabel = encode.label;\n  // FIXME `encode.label` is not recommended, because formatter cannot be set\n  // in this way. Use label.formatter instead. Maybe remove this approach someday.\n  if (encodeLabel && encodeLabel.length) {\n    defaultedLabel = encodeLabel.slice();\n  }\n  var encodeTooltip = encode.tooltip;\n  if (encodeTooltip && encodeTooltip.length) {\n    defaultedTooltip = encodeTooltip.slice();\n  } else if (!defaultedTooltip.length) {\n    defaultedTooltip = defaultedLabel.slice();\n  }\n  encode.defaultedLabel = defaultedLabel;\n  encode.defaultedTooltip = defaultedTooltip;\n  summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);\n  return summary;\n}\nfunction getOrCreateEncodeArr(encode, dim) {\n  if (!encode.hasOwnProperty(dim)) {\n    encode[dim] = [];\n  }\n  return encode[dim];\n}\n// FIXME:TS should be type `AxisType`\nfunction getDimensionTypeByAxis(axisType) {\n  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n}\nfunction mayLabelDimType(dimType) {\n  // In most cases, ordinal and time do not suitable for label.\n  // Ordinal info can be displayed on axis. Time is too long.\n  return !(dimType === 'ordinal' || dimType === 'time');\n}\n// function findTheLastDimMayLabel(data) {\n//     // Get last value dim\n//     let dimensions = data.dimensions.slice();\n//     let valueType;\n//     let valueDim;\n//     while (dimensions.length && (\n//         valueDim = dimensions.pop(),\n//         valueType = data.getDimensionInfo(valueDim).type,\n//         valueType === 'ordinal' || valueType === 'time'\n//     )) {} // jshint ignore:line\n//     return valueDim;\n// }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk3NTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL2hlbHBlci9kaW1lbnNpb25IZWxwZXIuanM/MDY1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IGVhY2gsIGNyZWF0ZUhhc2hNYXAsIGFzc2VydCwgbWFwIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IFZJU1VBTF9ESU1FTlNJT05TIH0gZnJvbSAnLi4vLi4vdXRpbC90eXBlcy5qcyc7XG52YXIgRGltZW5zaW9uVXNlck91cHV0ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGltZW5zaW9uVXNlck91cHV0KGVuY29kZSwgZGltUmVxdWVzdCkge1xuICAgIHRoaXMuX2VuY29kZSA9IGVuY29kZTtcbiAgICB0aGlzLl9zY2hlbWEgPSBkaW1SZXF1ZXN0O1xuICB9XG4gIERpbWVuc2lvblVzZXJPdXB1dC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBEbyBub3QgZ2VuZXJhdGUgZnVsbCBkaW1lbnNpb24gbmFtZSB1bnRpbCBmaXN0IHVzZWQuXG4gICAgICBmdWxsRGltZW5zaW9uczogdGhpcy5fZ2V0RnVsbERpbWVuc2lvbk5hbWVzKCksXG4gICAgICBlbmNvZGU6IHRoaXMuX2VuY29kZVxuICAgIH07XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCBhbGwgZGF0YSBzdG9yZSBkaW1lbnNpb24gbmFtZXMuXHJcbiAgICogVGhlb3JldGljYWxseSBhIHNlcmllcyBkYXRhIHN0b3JlIGlzIGRlZmluZWQgYm90aCBieSBzZXJpZXMgYW5kIHVzZWQgZGF0YXNldCAoaWYgYW55KS5cclxuICAgKiBJZiBzb21lIGRpbWVuc2lvbnMgYXJlIG9taXR0ZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbiBpbiBgdGhpcy5kaW1lbnNpb25zYCxcclxuICAgKiB0aGUgZGltZW5zaW9uIG5hbWUgbWF5IG5vdCBiZSBhdXRvLWdlbmVyYXRlZCBpZiB1c2VyIGRvZXMgbm90IHNwZWNpZnkgYSBkaW1lbnNpb24gbmFtZS5cclxuICAgKiBJbiB0aGlzIGNhc2UsIHRoZSBkaW1lbnNpb24gbmFtZSBpcyBgbnVsbGAvYHVuZGVmaW5lZGAuXHJcbiAgICovXG4gIERpbWVuc2lvblVzZXJPdXB1dC5wcm90b3R5cGUuX2dldEZ1bGxEaW1lbnNpb25OYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZERpbU5hbWVzKSB7XG4gICAgICB0aGlzLl9jYWNoZWREaW1OYW1lcyA9IHRoaXMuX3NjaGVtYSA/IHRoaXMuX3NjaGVtYS5tYWtlT3V0cHV0RGltZW5zaW9uTmFtZXMoKSA6IFtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkRGltTmFtZXM7XG4gIH07XG4gIHJldHVybiBEaW1lbnNpb25Vc2VyT3VwdXQ7XG59KCk7XG47XG5leHBvcnQgZnVuY3Rpb24gc3VtbWFyaXplRGltZW5zaW9ucyhkYXRhLCBzY2hlbWEpIHtcbiAgdmFyIHN1bW1hcnkgPSB7fTtcbiAgdmFyIGVuY29kZSA9IHN1bW1hcnkuZW5jb2RlID0ge307XG4gIHZhciBub3RFeHRyYUNvb3JkRGltTWFwID0gY3JlYXRlSGFzaE1hcCgpO1xuICB2YXIgZGVmYXVsdGVkTGFiZWwgPSBbXTtcbiAgdmFyIGRlZmF1bHRlZFRvb2x0aXAgPSBbXTtcbiAgdmFyIHVzZXJPdXRwdXRFbmNvZGUgPSB7fTtcbiAgZWFjaChkYXRhLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW1OYW1lKSB7XG4gICAgdmFyIGRpbUl0ZW0gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oZGltTmFtZSk7XG4gICAgdmFyIGNvb3JkRGltID0gZGltSXRlbS5jb29yZERpbTtcbiAgICBpZiAoY29vcmREaW0pIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydChWSVNVQUxfRElNRU5TSU9OUy5nZXQoY29vcmREaW0pID09IG51bGwpO1xuICAgICAgfVxuICAgICAgdmFyIGNvb3JkRGltSW5kZXggPSBkaW1JdGVtLmNvb3JkRGltSW5kZXg7XG4gICAgICBnZXRPckNyZWF0ZUVuY29kZUFycihlbmNvZGUsIGNvb3JkRGltKVtjb29yZERpbUluZGV4XSA9IGRpbU5hbWU7XG4gICAgICBpZiAoIWRpbUl0ZW0uaXNFeHRyYUNvb3JkKSB7XG4gICAgICAgIG5vdEV4dHJhQ29vcmREaW1NYXAuc2V0KGNvb3JkRGltLCAxKTtcbiAgICAgICAgLy8gVXNlIHRoZSBsYXN0IGNvb3JkIGRpbSAoYW5kIGxhYmVsIGZyaWVuZGx5KSBhcyBkZWZhdWx0IGxhYmVsLFxuICAgICAgICAvLyBiZWNhdXNlIHdoZW4gZGF0YXNldCBpcyB1c2VkLCBpdCBpcyBoYXJkIHRvIGd1ZXNzIHdoaWNoIGRpbWVuc2lvblxuICAgICAgICAvLyBjYW4gYmUgdmFsdWUgZGltZW5zaW9uLiBJZiBib3RoIHNob3cgeCwgeSBvbiBsYWJlbCBpcyBub3QgbG9vayBnb29kLFxuICAgICAgICAvLyBhbmQgY29udmVudGlvbmFsbHkgeSBheGlzIGlzIGZvY3VzZWQgbW9yZS5cbiAgICAgICAgaWYgKG1heUxhYmVsRGltVHlwZShkaW1JdGVtLnR5cGUpKSB7XG4gICAgICAgICAgZGVmYXVsdGVkTGFiZWxbMF0gPSBkaW1OYW1lO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZXIgb3V0cHV0IGVuY29kZSBkbyBub3QgY29udGFpbiBnZW5lcmF0ZWQgY29vcmRzLlxuICAgICAgICAvLyBBbmQgaXQgb25seSBoYXMgaW5kZXguIFVzZXIgY2FuIHVzZSBpbmRleCB0byByZXRyaWV2ZSB2YWx1ZSBmcm9tIHRoZSByYXcgaXRlbSBhcnJheS5cbiAgICAgICAgZ2V0T3JDcmVhdGVFbmNvZGVBcnIodXNlck91dHB1dEVuY29kZSwgY29vcmREaW0pW2Nvb3JkRGltSW5kZXhdID0gZGF0YS5nZXREaW1lbnNpb25JbmRleChkaW1JdGVtLm5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGRpbUl0ZW0uZGVmYXVsdFRvb2x0aXApIHtcbiAgICAgICAgZGVmYXVsdGVkVG9vbHRpcC5wdXNoKGRpbU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBWSVNVQUxfRElNRU5TSU9OUy5lYWNoKGZ1bmN0aW9uICh2LCBvdGhlckRpbSkge1xuICAgICAgdmFyIGVuY29kZUFyciA9IGdldE9yQ3JlYXRlRW5jb2RlQXJyKGVuY29kZSwgb3RoZXJEaW0pO1xuICAgICAgdmFyIGRpbUluZGV4ID0gZGltSXRlbS5vdGhlckRpbXNbb3RoZXJEaW1dO1xuICAgICAgaWYgKGRpbUluZGV4ICE9IG51bGwgJiYgZGltSW5kZXggIT09IGZhbHNlKSB7XG4gICAgICAgIGVuY29kZUFycltkaW1JbmRleF0gPSBkaW1JdGVtLm5hbWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICB2YXIgZGF0YURpbXNPbkNvb3JkID0gW107XG4gIHZhciBlbmNvZGVGaXJzdERpbU5vdEV4dHJhID0ge307XG4gIG5vdEV4dHJhQ29vcmREaW1NYXAuZWFjaChmdW5jdGlvbiAodiwgY29vcmREaW0pIHtcbiAgICB2YXIgZGltQXJyID0gZW5jb2RlW2Nvb3JkRGltXTtcbiAgICBlbmNvZGVGaXJzdERpbU5vdEV4dHJhW2Nvb3JkRGltXSA9IGRpbUFyclswXTtcbiAgICAvLyBOb3QgbmVjZXNzYXJ5IHRvIHJlbW92ZSBkdXBsaWNhdGUsIGJlY2F1c2UgYSBkYXRhXG4gICAgLy8gZGltIGNhbm90IG9uIG1vcmUgdGhhbiBvbmUgY29vcmREaW0uXG4gICAgZGF0YURpbXNPbkNvb3JkID0gZGF0YURpbXNPbkNvb3JkLmNvbmNhdChkaW1BcnIpO1xuICB9KTtcbiAgc3VtbWFyeS5kYXRhRGltc09uQ29vcmQgPSBkYXRhRGltc09uQ29vcmQ7XG4gIHN1bW1hcnkuZGF0YURpbUluZGljZXNPbkNvb3JkID0gbWFwKGRhdGFEaW1zT25Db29yZCwgZnVuY3Rpb24gKGRpbU5hbWUpIHtcbiAgICByZXR1cm4gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbU5hbWUpLnN0b3JlRGltSW5kZXg7XG4gIH0pO1xuICBzdW1tYXJ5LmVuY29kZUZpcnN0RGltTm90RXh0cmEgPSBlbmNvZGVGaXJzdERpbU5vdEV4dHJhO1xuICB2YXIgZW5jb2RlTGFiZWwgPSBlbmNvZGUubGFiZWw7XG4gIC8vIEZJWE1FIGBlbmNvZGUubGFiZWxgIGlzIG5vdCByZWNvbW1lbmRlZCwgYmVjYXVzZSBmb3JtYXR0ZXIgY2Fubm90IGJlIHNldFxuICAvLyBpbiB0aGlzIHdheS4gVXNlIGxhYmVsLmZvcm1hdHRlciBpbnN0ZWFkLiBNYXliZSByZW1vdmUgdGhpcyBhcHByb2FjaCBzb21lZGF5LlxuICBpZiAoZW5jb2RlTGFiZWwgJiYgZW5jb2RlTGFiZWwubGVuZ3RoKSB7XG4gICAgZGVmYXVsdGVkTGFiZWwgPSBlbmNvZGVMYWJlbC5zbGljZSgpO1xuICB9XG4gIHZhciBlbmNvZGVUb29sdGlwID0gZW5jb2RlLnRvb2x0aXA7XG4gIGlmIChlbmNvZGVUb29sdGlwICYmIGVuY29kZVRvb2x0aXAubGVuZ3RoKSB7XG4gICAgZGVmYXVsdGVkVG9vbHRpcCA9IGVuY29kZVRvb2x0aXAuc2xpY2UoKTtcbiAgfSBlbHNlIGlmICghZGVmYXVsdGVkVG9vbHRpcC5sZW5ndGgpIHtcbiAgICBkZWZhdWx0ZWRUb29sdGlwID0gZGVmYXVsdGVkTGFiZWwuc2xpY2UoKTtcbiAgfVxuICBlbmNvZGUuZGVmYXVsdGVkTGFiZWwgPSBkZWZhdWx0ZWRMYWJlbDtcbiAgZW5jb2RlLmRlZmF1bHRlZFRvb2x0aXAgPSBkZWZhdWx0ZWRUb29sdGlwO1xuICBzdW1tYXJ5LnVzZXJPdXRwdXQgPSBuZXcgRGltZW5zaW9uVXNlck91cHV0KHVzZXJPdXRwdXRFbmNvZGUsIHNjaGVtYSk7XG4gIHJldHVybiBzdW1tYXJ5O1xufVxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVFbmNvZGVBcnIoZW5jb2RlLCBkaW0pIHtcbiAgaWYgKCFlbmNvZGUuaGFzT3duUHJvcGVydHkoZGltKSkge1xuICAgIGVuY29kZVtkaW1dID0gW107XG4gIH1cbiAgcmV0dXJuIGVuY29kZVtkaW1dO1xufVxuLy8gRklYTUU6VFMgc2hvdWxkIGJlIHR5cGUgYEF4aXNUeXBlYFxuZXhwb3J0IGZ1bmN0aW9uIGdldERpbWVuc2lvblR5cGVCeUF4aXMoYXhpc1R5cGUpIHtcbiAgcmV0dXJuIGF4aXNUeXBlID09PSAnY2F0ZWdvcnknID8gJ29yZGluYWwnIDogYXhpc1R5cGUgPT09ICd0aW1lJyA/ICd0aW1lJyA6ICdmbG9hdCc7XG59XG5mdW5jdGlvbiBtYXlMYWJlbERpbVR5cGUoZGltVHlwZSkge1xuICAvLyBJbiBtb3N0IGNhc2VzLCBvcmRpbmFsIGFuZCB0aW1lIGRvIG5vdCBzdWl0YWJsZSBmb3IgbGFiZWwuXG4gIC8vIE9yZGluYWwgaW5mbyBjYW4gYmUgZGlzcGxheWVkIG9uIGF4aXMuIFRpbWUgaXMgdG9vIGxvbmcuXG4gIHJldHVybiAhKGRpbVR5cGUgPT09ICdvcmRpbmFsJyB8fCBkaW1UeXBlID09PSAndGltZScpO1xufVxuLy8gZnVuY3Rpb24gZmluZFRoZUxhc3REaW1NYXlMYWJlbChkYXRhKSB7XG4vLyAgICAgLy8gR2V0IGxhc3QgdmFsdWUgZGltXG4vLyAgICAgbGV0IGRpbWVuc2lvbnMgPSBkYXRhLmRpbWVuc2lvbnMuc2xpY2UoKTtcbi8vICAgICBsZXQgdmFsdWVUeXBlO1xuLy8gICAgIGxldCB2YWx1ZURpbTtcbi8vICAgICB3aGlsZSAoZGltZW5zaW9ucy5sZW5ndGggJiYgKFxuLy8gICAgICAgICB2YWx1ZURpbSA9IGRpbWVuc2lvbnMucG9wKCksXG4vLyAgICAgICAgIHZhbHVlVHlwZSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyh2YWx1ZURpbSkudHlwZSxcbi8vICAgICAgICAgdmFsdWVUeXBlID09PSAnb3JkaW5hbCcgfHwgdmFsdWVUeXBlID09PSAndGltZSdcbi8vICAgICApKSB7fSAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbi8vICAgICByZXR1cm4gdmFsdWVEaW07XG4vLyB9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29756\n")},31825:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fl: () => (/* binding */ SortOrderComparator),\n/* harmony export */   Pn: () => (/* binding */ parseDataValue),\n/* harmony export */   zC: () => (/* binding */ getRawValueParser),\n/* harmony export */   zs: () => (/* binding */ createFilterComparator)\n/* harmony export */ });\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24326);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _util_log_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41025);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n/**\r\n * Convert raw the value in to inner value in List.\r\n *\r\n * [Performance sensitive]\r\n *\r\n * [Caution]: this is the key logic of user value parser.\r\n * For backward compatibility, do not modify it until you have to!\r\n */\nfunction parseDataValue(value,\n// For high performance, do not omit the second param.\nopt) {\n  // Performance sensitive.\n  var dimType = opt && opt.type;\n  if (dimType === \'ordinal\') {\n    // If given value is a category string\n    return value;\n  }\n  if (dimType === \'time\'\n  // spead up when using timestamp\n  && !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(value) && value != null && value !== \'-\') {\n    value = +(0,_util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parseDate */ ._U)(value);\n  }\n  // dimType defaults \'number\'.\n  // If dimType is not ordinal and value is null or undefined or NaN or \'-\',\n  // parse to NaN.\n  // number-like string (like \' 123 \') can be converted to a number.\n  // where null/undefined or other string will be converted to NaN.\n  return value == null || value === \'\' ? NaN\n  // If string (like \'-\'), using \'+\' parse to NaN\n  // If object, also parse to NaN\n  : Number(value);\n}\n;\nvar valueParserMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap)({\n  \'number\': function (val) {\n    // Do not use `numericToNumber` here. We have `numericToNumber` by default.\n    // Here the number parser can have loose rule:\n    // enable to cut suffix: "120px" => 120, "14%" => 14.\n    return parseFloat(val);\n  },\n  \'time\': function (val) {\n    // return timestamp.\n    return +(0,_util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .parseDate */ ._U)(val);\n  },\n  \'trim\': function (val) {\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString)(val) ? (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.trim)(val) : val;\n  }\n});\nfunction getRawValueParser(type) {\n  return valueParserMap.get(type);\n}\nvar ORDER_COMPARISON_OP_MAP = {\n  lt: function (lval, rval) {\n    return lval < rval;\n  },\n  lte: function (lval, rval) {\n    return lval <= rval;\n  },\n  gt: function (lval, rval) {\n    return lval > rval;\n  },\n  gte: function (lval, rval) {\n    return lval >= rval;\n  }\n};\nvar FilterOrderComparator = /** @class */function () {\n  function FilterOrderComparator(op, rval) {\n    if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(rval)) {\n      var errMsg = \'\';\n      if (false) {}\n      (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__/* .throwError */ .$8)(errMsg);\n    }\n    this._opFn = ORDER_COMPARISON_OP_MAP[op];\n    this._rvalFloat = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .numericToNumber */ .Sm)(rval);\n  }\n  // Performance sensitive.\n  FilterOrderComparator.prototype.evaluate = function (lval) {\n    // Most cases is \'number\', and typeof maybe 10 times faseter than parseFloat.\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(lval) ? this._opFn(lval, this._rvalFloat) : this._opFn((0,_util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .numericToNumber */ .Sm)(lval), this._rvalFloat);\n  };\n  return FilterOrderComparator;\n}();\nvar SortOrderComparator = /** @class */function () {\n  /**\r\n   * @param order by default: \'asc\'\r\n   * @param incomparable by default: Always on the tail.\r\n   *        That is, if \'asc\' => \'max\', if \'desc\' => \'min\'\r\n   *        See the definition of "incomparable" in [SORT_COMPARISON_RULE].\r\n   */\n  function SortOrderComparator(order, incomparable) {\n    var isDesc = order === \'desc\';\n    this._resultLT = isDesc ? 1 : -1;\n    if (incomparable == null) {\n      incomparable = isDesc ? \'min\' : \'max\';\n    }\n    this._incomparable = incomparable === \'min\' ? -Infinity : Infinity;\n  }\n  // See [SORT_COMPARISON_RULE].\n  // Performance sensitive.\n  SortOrderComparator.prototype.evaluate = function (lval, rval) {\n    // Most cases is \'number\', and typeof maybe 10 times faseter than parseFloat.\n    var lvalFloat = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(lval) ? lval : (0,_util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .numericToNumber */ .Sm)(lval);\n    var rvalFloat = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(rval) ? rval : (0,_util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .numericToNumber */ .Sm)(rval);\n    var lvalNotNumeric = isNaN(lvalFloat);\n    var rvalNotNumeric = isNaN(rvalFloat);\n    if (lvalNotNumeric) {\n      lvalFloat = this._incomparable;\n    }\n    if (rvalNotNumeric) {\n      rvalFloat = this._incomparable;\n    }\n    if (lvalNotNumeric && rvalNotNumeric) {\n      var lvalIsStr = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString)(lval);\n      var rvalIsStr = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString)(rval);\n      if (lvalIsStr) {\n        lvalFloat = rvalIsStr ? lval : 0;\n      }\n      if (rvalIsStr) {\n        rvalFloat = lvalIsStr ? rval : 0;\n      }\n    }\n    return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;\n  };\n  return SortOrderComparator;\n}();\n\nvar FilterEqualityComparator = /** @class */function () {\n  function FilterEqualityComparator(isEq, rval) {\n    this._rval = rval;\n    this._isEQ = isEq;\n    this._rvalTypeof = typeof rval;\n    this._rvalFloat = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .numericToNumber */ .Sm)(rval);\n  }\n  // Performance sensitive.\n  FilterEqualityComparator.prototype.evaluate = function (lval) {\n    var eqResult = lval === this._rval;\n    if (!eqResult) {\n      var lvalTypeof = typeof lval;\n      if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === \'number\' || this._rvalTypeof === \'number\')) {\n        eqResult = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_1__/* .numericToNumber */ .Sm)(lval) === this._rvalFloat;\n      }\n    }\n    return this._isEQ ? eqResult : !eqResult;\n  };\n  return FilterEqualityComparator;\n}();\n/**\r\n * [FILTER_COMPARISON_RULE]\r\n * `lt`|`lte`|`gt`|`gte`:\r\n * + rval must be a number. And lval will be converted to number (`numericToNumber`) to compare.\r\n * `eq`:\r\n * + If same type, compare with `===`.\r\n * + If there is one number, convert to number (`numericToNumber`) to compare.\r\n * + Else return `false`.\r\n * `ne`:\r\n * + Not `eq`.\r\n *\r\n *\r\n * [SORT_COMPARISON_RULE]\r\n * All the values are grouped into three categories:\r\n * + "numeric" (number and numeric string)\r\n * + "non-numeric-string" (string that excluding numeric string)\r\n * + "others"\r\n * "numeric" vs "numeric": values are ordered by number order.\r\n * "non-numeric-string" vs "non-numeric-string": values are ordered by ES spec (#sec-abstract-relational-comparison).\r\n * "others" vs "others": do not change order (always return 0).\r\n * "numeric" vs "non-numeric-string": "non-numeric-string" is treated as "incomparable".\r\n * "number" vs "others": "others" is treated as "incomparable".\r\n * "non-numeric-string" vs "others": "others" is treated as "incomparable".\r\n * "incomparable" will be seen as -Infinity or Infinity (depends on the settings).\r\n * MEMO:\r\n *   Non-numeric string sort makes sense when we need to put the items with the same tag together.\r\n *   But if we support string sort, we still need to avoid the misleading like `\'2\' > \'12\'`,\r\n *   So we treat "numeric-string" sorted by number order rather than string comparison.\r\n *\r\n *\r\n * [CHECK_LIST_OF_THE_RULE_DESIGN]\r\n * + Do not support string comparison until required. And also need to\r\n *   avoid the misleading of "2" > "12".\r\n * + Should avoid the misleading case:\r\n *   `" 22 " gte "22"` is `true` but `" 22 " eq "22"` is `false`.\r\n * + JS bad case should be avoided: null <= 0, [] <= 0, \' \' <= 0, ...\r\n * + Only "numeric" can be converted to comparable number, otherwise converted to NaN.\r\n *   See `util/number.ts#numericToNumber`.\r\n *\r\n * @return If `op` is not `RelationalOperator`, return null;\r\n */\nfunction createFilterComparator(op, rval) {\n  return op === \'eq\' || op === \'ne\' ? new FilterEqualityComparator(op === \'eq\', rval) : (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(ORDER_COMPARISON_OP_MAP, op) ? new FilterOrderComparator(op, rval) : null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE4MjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL2hlbHBlci9kYXRhVmFsdWVIZWxwZXIuanM/MWFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IHBhcnNlRGF0ZSwgbnVtZXJpY1RvTnVtYmVyIH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaE1hcCwgdHJpbSwgaGFzT3duLCBpc1N0cmluZywgaXNOdW1iZXIgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgdGhyb3dFcnJvciB9IGZyb20gJy4uLy4uL3V0aWwvbG9nLmpzJztcbi8qKlxyXG4gKiBDb252ZXJ0IHJhdyB0aGUgdmFsdWUgaW4gdG8gaW5uZXIgdmFsdWUgaW4gTGlzdC5cclxuICpcclxuICogW1BlcmZvcm1hbmNlIHNlbnNpdGl2ZV1cclxuICpcclxuICogW0NhdXRpb25dOiB0aGlzIGlzIHRoZSBrZXkgbG9naWMgb2YgdXNlciB2YWx1ZSBwYXJzZXIuXHJcbiAqIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBkbyBub3QgbW9kaWZ5IGl0IHVudGlsIHlvdSBoYXZlIHRvIVxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURhdGFWYWx1ZSh2YWx1ZSxcbi8vIEZvciBoaWdoIHBlcmZvcm1hbmNlLCBkbyBub3Qgb21pdCB0aGUgc2Vjb25kIHBhcmFtLlxub3B0KSB7XG4gIC8vIFBlcmZvcm1hbmNlIHNlbnNpdGl2ZS5cbiAgdmFyIGRpbVR5cGUgPSBvcHQgJiYgb3B0LnR5cGU7XG4gIGlmIChkaW1UeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAvLyBJZiBnaXZlbiB2YWx1ZSBpcyBhIGNhdGVnb3J5IHN0cmluZ1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoZGltVHlwZSA9PT0gJ3RpbWUnXG4gIC8vIHNwZWFkIHVwIHdoZW4gdXNpbmcgdGltZXN0YW1wXG4gICYmICFpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gJy0nKSB7XG4gICAgdmFsdWUgPSArcGFyc2VEYXRlKHZhbHVlKTtcbiAgfVxuICAvLyBkaW1UeXBlIGRlZmF1bHRzICdudW1iZXInLlxuICAvLyBJZiBkaW1UeXBlIGlzIG5vdCBvcmRpbmFsIGFuZCB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBOYU4gb3IgJy0nLFxuICAvLyBwYXJzZSB0byBOYU4uXG4gIC8vIG51bWJlci1saWtlIHN0cmluZyAobGlrZSAnIDEyMyAnKSBjYW4gYmUgY29udmVydGVkIHRvIGEgbnVtYmVyLlxuICAvLyB3aGVyZSBudWxsL3VuZGVmaW5lZCBvciBvdGhlciBzdHJpbmcgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gTmFOLlxuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycgPyBOYU5cbiAgLy8gSWYgc3RyaW5nIChsaWtlICctJyksIHVzaW5nICcrJyBwYXJzZSB0byBOYU5cbiAgLy8gSWYgb2JqZWN0LCBhbHNvIHBhcnNlIHRvIE5hTlxuICA6IE51bWJlcih2YWx1ZSk7XG59XG47XG52YXIgdmFsdWVQYXJzZXJNYXAgPSBjcmVhdGVIYXNoTWFwKHtcbiAgJ251bWJlcic6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyBEbyBub3QgdXNlIGBudW1lcmljVG9OdW1iZXJgIGhlcmUuIFdlIGhhdmUgYG51bWVyaWNUb051bWJlcmAgYnkgZGVmYXVsdC5cbiAgICAvLyBIZXJlIHRoZSBudW1iZXIgcGFyc2VyIGNhbiBoYXZlIGxvb3NlIHJ1bGU6XG4gICAgLy8gZW5hYmxlIHRvIGN1dCBzdWZmaXg6IFwiMTIwcHhcIiA9PiAxMjAsIFwiMTQlXCIgPT4gMTQuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsKTtcbiAgfSxcbiAgJ3RpbWUnOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgLy8gcmV0dXJuIHRpbWVzdGFtcC5cbiAgICByZXR1cm4gK3BhcnNlRGF0ZSh2YWwpO1xuICB9LFxuICAndHJpbSc6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsKSA/IHRyaW0odmFsKSA6IHZhbDtcbiAgfVxufSk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UmF3VmFsdWVQYXJzZXIodHlwZSkge1xuICByZXR1cm4gdmFsdWVQYXJzZXJNYXAuZ2V0KHR5cGUpO1xufVxudmFyIE9SREVSX0NPTVBBUklTT05fT1BfTUFQID0ge1xuICBsdDogZnVuY3Rpb24gKGx2YWwsIHJ2YWwpIHtcbiAgICByZXR1cm4gbHZhbCA8IHJ2YWw7XG4gIH0sXG4gIGx0ZTogZnVuY3Rpb24gKGx2YWwsIHJ2YWwpIHtcbiAgICByZXR1cm4gbHZhbCA8PSBydmFsO1xuICB9LFxuICBndDogZnVuY3Rpb24gKGx2YWwsIHJ2YWwpIHtcbiAgICByZXR1cm4gbHZhbCA+IHJ2YWw7XG4gIH0sXG4gIGd0ZTogZnVuY3Rpb24gKGx2YWwsIHJ2YWwpIHtcbiAgICByZXR1cm4gbHZhbCA+PSBydmFsO1xuICB9XG59O1xudmFyIEZpbHRlck9yZGVyQ29tcGFyYXRvciA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZpbHRlck9yZGVyQ29tcGFyYXRvcihvcCwgcnZhbCkge1xuICAgIGlmICghaXNOdW1iZXIocnZhbCkpIHtcbiAgICAgIHZhciBlcnJNc2cgPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVyck1zZyA9ICdydmFsdWUgb2YgXCI8XCIsIFwiPlwiLCBcIjw9XCIsIFwiPj1cIiBjYW4gb25seSBiZSBudW1iZXIgaW4gZmlsdGVyLic7XG4gICAgICB9XG4gICAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gICAgfVxuICAgIHRoaXMuX29wRm4gPSBPUkRFUl9DT01QQVJJU09OX09QX01BUFtvcF07XG4gICAgdGhpcy5fcnZhbEZsb2F0ID0gbnVtZXJpY1RvTnVtYmVyKHJ2YWwpO1xuICB9XG4gIC8vIFBlcmZvcm1hbmNlIHNlbnNpdGl2ZS5cbiAgRmlsdGVyT3JkZXJDb21wYXJhdG9yLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIChsdmFsKSB7XG4gICAgLy8gTW9zdCBjYXNlcyBpcyAnbnVtYmVyJywgYW5kIHR5cGVvZiBtYXliZSAxMCB0aW1lcyBmYXNldGVyIHRoYW4gcGFyc2VGbG9hdC5cbiAgICByZXR1cm4gaXNOdW1iZXIobHZhbCkgPyB0aGlzLl9vcEZuKGx2YWwsIHRoaXMuX3J2YWxGbG9hdCkgOiB0aGlzLl9vcEZuKG51bWVyaWNUb051bWJlcihsdmFsKSwgdGhpcy5fcnZhbEZsb2F0KTtcbiAgfTtcbiAgcmV0dXJuIEZpbHRlck9yZGVyQ29tcGFyYXRvcjtcbn0oKTtcbnZhciBTb3J0T3JkZXJDb21wYXJhdG9yID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIG9yZGVyIGJ5IGRlZmF1bHQ6ICdhc2MnXHJcbiAgICogQHBhcmFtIGluY29tcGFyYWJsZSBieSBkZWZhdWx0OiBBbHdheXMgb24gdGhlIHRhaWwuXHJcbiAgICogICAgICAgIFRoYXQgaXMsIGlmICdhc2MnID0+ICdtYXgnLCBpZiAnZGVzYycgPT4gJ21pbidcclxuICAgKiAgICAgICAgU2VlIHRoZSBkZWZpbml0aW9uIG9mIFwiaW5jb21wYXJhYmxlXCIgaW4gW1NPUlRfQ09NUEFSSVNPTl9SVUxFXS5cclxuICAgKi9cbiAgZnVuY3Rpb24gU29ydE9yZGVyQ29tcGFyYXRvcihvcmRlciwgaW5jb21wYXJhYmxlKSB7XG4gICAgdmFyIGlzRGVzYyA9IG9yZGVyID09PSAnZGVzYyc7XG4gICAgdGhpcy5fcmVzdWx0TFQgPSBpc0Rlc2MgPyAxIDogLTE7XG4gICAgaWYgKGluY29tcGFyYWJsZSA9PSBudWxsKSB7XG4gICAgICBpbmNvbXBhcmFibGUgPSBpc0Rlc2MgPyAnbWluJyA6ICdtYXgnO1xuICAgIH1cbiAgICB0aGlzLl9pbmNvbXBhcmFibGUgPSBpbmNvbXBhcmFibGUgPT09ICdtaW4nID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gIH1cbiAgLy8gU2VlIFtTT1JUX0NPTVBBUklTT05fUlVMRV0uXG4gIC8vIFBlcmZvcm1hbmNlIHNlbnNpdGl2ZS5cbiAgU29ydE9yZGVyQ29tcGFyYXRvci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAobHZhbCwgcnZhbCkge1xuICAgIC8vIE1vc3QgY2FzZXMgaXMgJ251bWJlcicsIGFuZCB0eXBlb2YgbWF5YmUgMTAgdGltZXMgZmFzZXRlciB0aGFuIHBhcnNlRmxvYXQuXG4gICAgdmFyIGx2YWxGbG9hdCA9IGlzTnVtYmVyKGx2YWwpID8gbHZhbCA6IG51bWVyaWNUb051bWJlcihsdmFsKTtcbiAgICB2YXIgcnZhbEZsb2F0ID0gaXNOdW1iZXIocnZhbCkgPyBydmFsIDogbnVtZXJpY1RvTnVtYmVyKHJ2YWwpO1xuICAgIHZhciBsdmFsTm90TnVtZXJpYyA9IGlzTmFOKGx2YWxGbG9hdCk7XG4gICAgdmFyIHJ2YWxOb3ROdW1lcmljID0gaXNOYU4ocnZhbEZsb2F0KTtcbiAgICBpZiAobHZhbE5vdE51bWVyaWMpIHtcbiAgICAgIGx2YWxGbG9hdCA9IHRoaXMuX2luY29tcGFyYWJsZTtcbiAgICB9XG4gICAgaWYgKHJ2YWxOb3ROdW1lcmljKSB7XG4gICAgICBydmFsRmxvYXQgPSB0aGlzLl9pbmNvbXBhcmFibGU7XG4gICAgfVxuICAgIGlmIChsdmFsTm90TnVtZXJpYyAmJiBydmFsTm90TnVtZXJpYykge1xuICAgICAgdmFyIGx2YWxJc1N0ciA9IGlzU3RyaW5nKGx2YWwpO1xuICAgICAgdmFyIHJ2YWxJc1N0ciA9IGlzU3RyaW5nKHJ2YWwpO1xuICAgICAgaWYgKGx2YWxJc1N0cikge1xuICAgICAgICBsdmFsRmxvYXQgPSBydmFsSXNTdHIgPyBsdmFsIDogMDtcbiAgICAgIH1cbiAgICAgIGlmIChydmFsSXNTdHIpIHtcbiAgICAgICAgcnZhbEZsb2F0ID0gbHZhbElzU3RyID8gcnZhbCA6IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsdmFsRmxvYXQgPCBydmFsRmxvYXQgPyB0aGlzLl9yZXN1bHRMVCA6IGx2YWxGbG9hdCA+IHJ2YWxGbG9hdCA/IC10aGlzLl9yZXN1bHRMVCA6IDA7XG4gIH07XG4gIHJldHVybiBTb3J0T3JkZXJDb21wYXJhdG9yO1xufSgpO1xuZXhwb3J0IHsgU29ydE9yZGVyQ29tcGFyYXRvciB9O1xudmFyIEZpbHRlckVxdWFsaXR5Q29tcGFyYXRvciA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZpbHRlckVxdWFsaXR5Q29tcGFyYXRvcihpc0VxLCBydmFsKSB7XG4gICAgdGhpcy5fcnZhbCA9IHJ2YWw7XG4gICAgdGhpcy5faXNFUSA9IGlzRXE7XG4gICAgdGhpcy5fcnZhbFR5cGVvZiA9IHR5cGVvZiBydmFsO1xuICAgIHRoaXMuX3J2YWxGbG9hdCA9IG51bWVyaWNUb051bWJlcihydmFsKTtcbiAgfVxuICAvLyBQZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gIEZpbHRlckVxdWFsaXR5Q29tcGFyYXRvci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAobHZhbCkge1xuICAgIHZhciBlcVJlc3VsdCA9IGx2YWwgPT09IHRoaXMuX3J2YWw7XG4gICAgaWYgKCFlcVJlc3VsdCkge1xuICAgICAgdmFyIGx2YWxUeXBlb2YgPSB0eXBlb2YgbHZhbDtcbiAgICAgIGlmIChsdmFsVHlwZW9mICE9PSB0aGlzLl9ydmFsVHlwZW9mICYmIChsdmFsVHlwZW9mID09PSAnbnVtYmVyJyB8fCB0aGlzLl9ydmFsVHlwZW9mID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgZXFSZXN1bHQgPSBudW1lcmljVG9OdW1iZXIobHZhbCkgPT09IHRoaXMuX3J2YWxGbG9hdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2lzRVEgPyBlcVJlc3VsdCA6ICFlcVJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuIEZpbHRlckVxdWFsaXR5Q29tcGFyYXRvcjtcbn0oKTtcbi8qKlxyXG4gKiBbRklMVEVSX0NPTVBBUklTT05fUlVMRV1cclxuICogYGx0YHxgbHRlYHxgZ3RgfGBndGVgOlxyXG4gKiArIHJ2YWwgbXVzdCBiZSBhIG51bWJlci4gQW5kIGx2YWwgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gbnVtYmVyIChgbnVtZXJpY1RvTnVtYmVyYCkgdG8gY29tcGFyZS5cclxuICogYGVxYDpcclxuICogKyBJZiBzYW1lIHR5cGUsIGNvbXBhcmUgd2l0aCBgPT09YC5cclxuICogKyBJZiB0aGVyZSBpcyBvbmUgbnVtYmVyLCBjb252ZXJ0IHRvIG51bWJlciAoYG51bWVyaWNUb051bWJlcmApIHRvIGNvbXBhcmUuXHJcbiAqICsgRWxzZSByZXR1cm4gYGZhbHNlYC5cclxuICogYG5lYDpcclxuICogKyBOb3QgYGVxYC5cclxuICpcclxuICpcclxuICogW1NPUlRfQ09NUEFSSVNPTl9SVUxFXVxyXG4gKiBBbGwgdGhlIHZhbHVlcyBhcmUgZ3JvdXBlZCBpbnRvIHRocmVlIGNhdGVnb3JpZXM6XHJcbiAqICsgXCJudW1lcmljXCIgKG51bWJlciBhbmQgbnVtZXJpYyBzdHJpbmcpXHJcbiAqICsgXCJub24tbnVtZXJpYy1zdHJpbmdcIiAoc3RyaW5nIHRoYXQgZXhjbHVkaW5nIG51bWVyaWMgc3RyaW5nKVxyXG4gKiArIFwib3RoZXJzXCJcclxuICogXCJudW1lcmljXCIgdnMgXCJudW1lcmljXCI6IHZhbHVlcyBhcmUgb3JkZXJlZCBieSBudW1iZXIgb3JkZXIuXHJcbiAqIFwibm9uLW51bWVyaWMtc3RyaW5nXCIgdnMgXCJub24tbnVtZXJpYy1zdHJpbmdcIjogdmFsdWVzIGFyZSBvcmRlcmVkIGJ5IEVTIHNwZWMgKCNzZWMtYWJzdHJhY3QtcmVsYXRpb25hbC1jb21wYXJpc29uKS5cclxuICogXCJvdGhlcnNcIiB2cyBcIm90aGVyc1wiOiBkbyBub3QgY2hhbmdlIG9yZGVyIChhbHdheXMgcmV0dXJuIDApLlxyXG4gKiBcIm51bWVyaWNcIiB2cyBcIm5vbi1udW1lcmljLXN0cmluZ1wiOiBcIm5vbi1udW1lcmljLXN0cmluZ1wiIGlzIHRyZWF0ZWQgYXMgXCJpbmNvbXBhcmFibGVcIi5cclxuICogXCJudW1iZXJcIiB2cyBcIm90aGVyc1wiOiBcIm90aGVyc1wiIGlzIHRyZWF0ZWQgYXMgXCJpbmNvbXBhcmFibGVcIi5cclxuICogXCJub24tbnVtZXJpYy1zdHJpbmdcIiB2cyBcIm90aGVyc1wiOiBcIm90aGVyc1wiIGlzIHRyZWF0ZWQgYXMgXCJpbmNvbXBhcmFibGVcIi5cclxuICogXCJpbmNvbXBhcmFibGVcIiB3aWxsIGJlIHNlZW4gYXMgLUluZmluaXR5IG9yIEluZmluaXR5IChkZXBlbmRzIG9uIHRoZSBzZXR0aW5ncykuXHJcbiAqIE1FTU86XHJcbiAqICAgTm9uLW51bWVyaWMgc3RyaW5nIHNvcnQgbWFrZXMgc2Vuc2Ugd2hlbiB3ZSBuZWVkIHRvIHB1dCB0aGUgaXRlbXMgd2l0aCB0aGUgc2FtZSB0YWcgdG9nZXRoZXIuXHJcbiAqICAgQnV0IGlmIHdlIHN1cHBvcnQgc3RyaW5nIHNvcnQsIHdlIHN0aWxsIG5lZWQgdG8gYXZvaWQgdGhlIG1pc2xlYWRpbmcgbGlrZSBgJzInID4gJzEyJ2AsXHJcbiAqICAgU28gd2UgdHJlYXQgXCJudW1lcmljLXN0cmluZ1wiIHNvcnRlZCBieSBudW1iZXIgb3JkZXIgcmF0aGVyIHRoYW4gc3RyaW5nIGNvbXBhcmlzb24uXHJcbiAqXHJcbiAqXHJcbiAqIFtDSEVDS19MSVNUX09GX1RIRV9SVUxFX0RFU0lHTl1cclxuICogKyBEbyBub3Qgc3VwcG9ydCBzdHJpbmcgY29tcGFyaXNvbiB1bnRpbCByZXF1aXJlZC4gQW5kIGFsc28gbmVlZCB0b1xyXG4gKiAgIGF2b2lkIHRoZSBtaXNsZWFkaW5nIG9mIFwiMlwiID4gXCIxMlwiLlxyXG4gKiArIFNob3VsZCBhdm9pZCB0aGUgbWlzbGVhZGluZyBjYXNlOlxyXG4gKiAgIGBcIiAyMiBcIiBndGUgXCIyMlwiYCBpcyBgdHJ1ZWAgYnV0IGBcIiAyMiBcIiBlcSBcIjIyXCJgIGlzIGBmYWxzZWAuXHJcbiAqICsgSlMgYmFkIGNhc2Ugc2hvdWxkIGJlIGF2b2lkZWQ6IG51bGwgPD0gMCwgW10gPD0gMCwgJyAnIDw9IDAsIC4uLlxyXG4gKiArIE9ubHkgXCJudW1lcmljXCIgY2FuIGJlIGNvbnZlcnRlZCB0byBjb21wYXJhYmxlIG51bWJlciwgb3RoZXJ3aXNlIGNvbnZlcnRlZCB0byBOYU4uXHJcbiAqICAgU2VlIGB1dGlsL251bWJlci50cyNudW1lcmljVG9OdW1iZXJgLlxyXG4gKlxyXG4gKiBAcmV0dXJuIElmIGBvcGAgaXMgbm90IGBSZWxhdGlvbmFsT3BlcmF0b3JgLCByZXR1cm4gbnVsbDtcclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRmlsdGVyQ29tcGFyYXRvcihvcCwgcnZhbCkge1xuICByZXR1cm4gb3AgPT09ICdlcScgfHwgb3AgPT09ICduZScgPyBuZXcgRmlsdGVyRXF1YWxpdHlDb21wYXJhdG9yKG9wID09PSAnZXEnLCBydmFsKSA6IGhhc093bihPUkRFUl9DT01QQVJJU09OX09QX01BUCwgb3ApID8gbmV3IEZpbHRlck9yZGVyQ29tcGFyYXRvcihvcCwgcnZhbCkgOiBudWxsO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///31825\n')},34310:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AF: () => (/* binding */ createSourceFromSeriesDataOption),\n/* harmony export */   BE: () => (/* binding */ cloneSourceShallow),\n/* harmony export */   O0: () => (/* binding */ shouldRetrieveDataByName),\n/* harmony export */   gV: () => (/* binding */ createSource),\n/* harmony export */   tP: () => (/* binding */ isSourceInstance),\n/* harmony export */   wZ: () => (/* binding */ detectSourceFormat)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13430);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(48170);\n/* harmony import */ var _helper_sourceHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23071);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n;\n// @inner\nvar SourceImpl = /** @class */function () {\n  function SourceImpl(fields) {\n    this.data = fields.data || (fields.sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_KEYED_COLUMNS */ .t1 ? {} : []);\n    this.sourceFormat = fields.sourceFormat || _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_UNKNOWN */ .vm;\n    // Visit config\n    this.seriesLayoutBy = fields.seriesLayoutBy || _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SERIES_LAYOUT_BY_COLUMN */ .i_;\n    this.startIndex = fields.startIndex || 0;\n    this.dimensionsDetectedCount = fields.dimensionsDetectedCount;\n    this.metaRawOption = fields.metaRawOption;\n    var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;\n    if (dimensionsDefine) {\n      for (var i = 0; i < dimensionsDefine.length; i++) {\n        var dim = dimensionsDefine[i];\n        if (dim.type == null) {\n          if ((0,_helper_sourceHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .guessOrdinal */ .PU)(this, i) === _helper_sourceHelper_js__WEBPACK_IMPORTED_MODULE_1__/* .BE_ORDINAL */ .sc.Must) {\n            dim.type = 'ordinal';\n          }\n        }\n      }\n    }\n  }\n  return SourceImpl;\n}();\nfunction isSourceInstance(val) {\n  return val instanceof SourceImpl;\n}\n/**\r\n * Create a source from option.\r\n * NOTE: Created source is immutable. Don't change any properties in it.\r\n */\nfunction createSource(sourceData, thisMetaRawOption,\n// can be null. If not provided, auto detect it from `sourceData`.\nsourceFormat) {\n  sourceFormat = sourceFormat || detectSourceFormat(sourceData);\n  var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;\n  var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);\n  var source = new SourceImpl({\n    data: sourceData,\n    sourceFormat: sourceFormat,\n    seriesLayoutBy: seriesLayoutBy,\n    dimensionsDefine: determined.dimensionsDefine,\n    startIndex: determined.startIndex,\n    dimensionsDetectedCount: determined.dimensionsDetectedCount,\n    metaRawOption: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone)(thisMetaRawOption)\n  });\n  return source;\n}\n/**\r\n * Wrap original series data for some compatibility cases.\r\n */\nfunction createSourceFromSeriesDataOption(data) {\n  return new SourceImpl({\n    data: data,\n    sourceFormat: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isTypedArray)(data) ? _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_TYPED_ARRAY */ .XO : _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_ORIGINAL */ .mK\n  });\n}\n/**\r\n * Clone source but excludes source data.\r\n */\nfunction cloneSourceShallow(source) {\n  return new SourceImpl({\n    data: source.data,\n    sourceFormat: source.sourceFormat,\n    seriesLayoutBy: source.seriesLayoutBy,\n    dimensionsDefine: (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.clone)(source.dimensionsDefine),\n    startIndex: source.startIndex,\n    dimensionsDetectedCount: source.dimensionsDetectedCount\n  });\n}\n/**\r\n * Note: An empty array will be detected as `SOURCE_FORMAT_ARRAY_ROWS`.\r\n */\nfunction detectSourceFormat(data) {\n  var sourceFormat = _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_UNKNOWN */ .vm;\n  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isTypedArray)(data)) {\n    sourceFormat = _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_TYPED_ARRAY */ .XO;\n  } else if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(data)) {\n    // FIXME Whether tolerate null in top level array?\n    if (data.length === 0) {\n      sourceFormat = _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_ARRAY_ROWS */ .Km;\n    }\n    for (var i = 0, len = data.length; i < len; i++) {\n      var item = data[i];\n      if (item == null) {\n        continue;\n      } else if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(item) || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isTypedArray)(item)) {\n        sourceFormat = _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_ARRAY_ROWS */ .Km;\n        break;\n      } else if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(item)) {\n        sourceFormat = _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_OBJECT_ROWS */ .Wk;\n        break;\n      }\n    }\n  } else if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(data)) {\n    for (var key in data) {\n      if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(data, key) && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isArrayLike)(data[key])) {\n        sourceFormat = _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_KEYED_COLUMNS */ .t1;\n        break;\n      }\n    }\n  }\n  return sourceFormat;\n}\n/**\r\n * Determine the source definitions from data standalone dimensions definitions\r\n * are not specified.\r\n */\nfunction determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader,\n// standalone raw dimensions definition, like:\n// {\n//     dimensions: ['aa', 'bb', { name: 'cc', type: 'time' }]\n// }\n// in `dataset` or `series`\ndimensionsDefine) {\n  var dimensionsDetectedCount;\n  var startIndex;\n  // PENDING: Could data be null/undefined here?\n  // currently, if `dataset.source` not specified, error thrown.\n  // if `series.data` not specified, nothing rendered without error thrown.\n  // Should test these cases.\n  if (!data) {\n    return {\n      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),\n      startIndex: startIndex,\n      dimensionsDetectedCount: dimensionsDetectedCount\n    };\n  }\n  if (sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_ARRAY_ROWS */ .Km) {\n    var dataArrayRows = data;\n    // Rule: Most of the first line are string: it is header.\n    // Caution: consider a line with 5 string and 1 number,\n    // it still can not be sure it is a head, because the\n    // 5 string may be 5 values of category columns.\n    if (sourceHeader === 'auto' || sourceHeader == null) {\n      arrayRowsTravelFirst(function (val) {\n        // '-' is regarded as null/undefined.\n        if (val != null && val !== '-') {\n          if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isString)(val)) {\n            startIndex == null && (startIndex = 1);\n          } else {\n            startIndex = 0;\n          }\n        }\n        // 10 is an experience number, avoid long loop.\n      }, seriesLayoutBy, dataArrayRows, 10);\n    } else {\n      startIndex = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isNumber)(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;\n    }\n    if (!dimensionsDefine && startIndex === 1) {\n      dimensionsDefine = [];\n      arrayRowsTravelFirst(function (val, index) {\n        dimensionsDefine[index] = val != null ? val + '' : '';\n      }, seriesLayoutBy, dataArrayRows, Infinity);\n    }\n    dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SERIES_LAYOUT_BY_ROW */ .oC ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;\n  } else if (sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_OBJECT_ROWS */ .Wk) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = objectRowsCollectDimensions(data);\n    }\n  } else if (sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_KEYED_COLUMNS */ .t1) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = [];\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(data, function (colArr, key) {\n        dimensionsDefine.push(key);\n      });\n    }\n  } else if (sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_ORIGINAL */ .mK) {\n    var value0 = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_3__/* .getDataItemValue */ .vj)(data[0]);\n    dimensionsDetectedCount = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(value0) && value0.length || 1;\n  } else if (sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_TYPED_ARRAY */ .XO) {\n    if (false) {}\n  }\n  return {\n    startIndex: startIndex,\n    dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),\n    dimensionsDetectedCount: dimensionsDetectedCount\n  };\n}\nfunction objectRowsCollectDimensions(data) {\n  var firstIndex = 0;\n  var obj;\n  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line\n  if (obj) {\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.keys)(obj);\n  }\n}\n// Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],\n// which is reasonable. But dimension name is duplicated.\n// Returns undefined or an array contains only object without null/undefined or string.\nfunction normalizeDimensionsOption(dimensionsDefine) {\n  if (!dimensionsDefine) {\n    // The meaning of null/undefined is different from empty array.\n    return;\n  }\n  var nameMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.createHashMap)();\n  return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.map)(dimensionsDefine, function (rawItem, index) {\n    rawItem = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(rawItem) ? rawItem : {\n      name: rawItem\n    };\n    // Other fields will be discarded.\n    var item = {\n      name: rawItem.name,\n      displayName: rawItem.displayName,\n      type: rawItem.type\n    };\n    // User can set null in dimensions.\n    // We don't auto specify name, otherwise a given name may\n    // cause it to be referred unexpectedly.\n    if (item.name == null) {\n      return item;\n    }\n    // Also consider number form like 2012.\n    item.name += '';\n    // User may also specify displayName.\n    // displayName will always exists except user not\n    // specified or dim name is not specified or detected.\n    // (A auto generated dim name will not be used as\n    // displayName).\n    if (item.displayName == null) {\n      item.displayName = item.name;\n    }\n    var exist = nameMap.get(item.name);\n    if (!exist) {\n      nameMap.set(item.name, {\n        count: 1\n      });\n    } else {\n      item.name += '-' + exist.count++;\n    }\n    return item;\n  });\n}\nfunction arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {\n  if (seriesLayoutBy === _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SERIES_LAYOUT_BY_ROW */ .oC) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      cb(data[i] ? data[i][0] : null, i);\n    }\n  } else {\n    var value0 = data[0] || [];\n    for (var i = 0; i < value0.length && i < maxLoop; i++) {\n      cb(value0[i], i);\n    }\n  }\n}\nfunction shouldRetrieveDataByName(source) {\n  var sourceFormat = source.sourceFormat;\n  return sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_OBJECT_ROWS */ .Wk || sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_0__/* .SOURCE_FORMAT_KEYED_COLUMNS */ .t1;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQzMTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvU291cmNlLmpzP2IzZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBpc1R5cGVkQXJyYXksIGNsb25lLCBjcmVhdGVIYXNoTWFwLCBpc0FycmF5LCBpc09iamVjdCwgaXNBcnJheUxpa2UsIGhhc093biwgYXNzZXJ0LCBlYWNoLCBtYXAsIGlzTnVtYmVyLCBpc1N0cmluZywga2V5cyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBTT1VSQ0VfRk9STUFUX09SSUdJTkFMLCBTRVJJRVNfTEFZT1VUX0JZX0NPTFVNTiwgU09VUkNFX0ZPUk1BVF9VTktOT1dOLCBTT1VSQ0VfRk9STUFUX0tFWUVEX0NPTFVNTlMsIFNPVVJDRV9GT1JNQVRfVFlQRURfQVJSQVksIFNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUywgU09VUkNFX0ZPUk1BVF9PQkpFQ1RfUk9XUywgU0VSSUVTX0xBWU9VVF9CWV9ST1cgfSBmcm9tICcuLi91dGlsL3R5cGVzLmpzJztcbmltcG9ydCB7IGdldERhdGFJdGVtVmFsdWUgfSBmcm9tICcuLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCB7IEJFX09SRElOQUwsIGd1ZXNzT3JkaW5hbCB9IGZyb20gJy4vaGVscGVyL3NvdXJjZUhlbHBlci5qcyc7XG47XG4vLyBAaW5uZXJcbnZhciBTb3VyY2VJbXBsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU291cmNlSW1wbChmaWVsZHMpIHtcbiAgICB0aGlzLmRhdGEgPSBmaWVsZHMuZGF0YSB8fCAoZmllbGRzLnNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TID8ge30gOiBbXSk7XG4gICAgdGhpcy5zb3VyY2VGb3JtYXQgPSBmaWVsZHMuc291cmNlRm9ybWF0IHx8IFNPVVJDRV9GT1JNQVRfVU5LTk9XTjtcbiAgICAvLyBWaXNpdCBjb25maWdcbiAgICB0aGlzLnNlcmllc0xheW91dEJ5ID0gZmllbGRzLnNlcmllc0xheW91dEJ5IHx8IFNFUklFU19MQVlPVVRfQllfQ09MVU1OO1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IGZpZWxkcy5zdGFydEluZGV4IHx8IDA7XG4gICAgdGhpcy5kaW1lbnNpb25zRGV0ZWN0ZWRDb3VudCA9IGZpZWxkcy5kaW1lbnNpb25zRGV0ZWN0ZWRDb3VudDtcbiAgICB0aGlzLm1ldGFSYXdPcHRpb24gPSBmaWVsZHMubWV0YVJhd09wdGlvbjtcbiAgICB2YXIgZGltZW5zaW9uc0RlZmluZSA9IHRoaXMuZGltZW5zaW9uc0RlZmluZSA9IGZpZWxkcy5kaW1lbnNpb25zRGVmaW5lO1xuICAgIGlmIChkaW1lbnNpb25zRGVmaW5lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnNEZWZpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRpbSA9IGRpbWVuc2lvbnNEZWZpbmVbaV07XG4gICAgICAgIGlmIChkaW0udHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGd1ZXNzT3JkaW5hbCh0aGlzLCBpKSA9PT0gQkVfT1JESU5BTC5NdXN0KSB7XG4gICAgICAgICAgICBkaW0udHlwZSA9ICdvcmRpbmFsJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFNvdXJjZUltcGw7XG59KCk7XG5leHBvcnQgZnVuY3Rpb24gaXNTb3VyY2VJbnN0YW5jZSh2YWwpIHtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIFNvdXJjZUltcGw7XG59XG4vKipcclxuICogQ3JlYXRlIGEgc291cmNlIGZyb20gb3B0aW9uLlxyXG4gKiBOT1RFOiBDcmVhdGVkIHNvdXJjZSBpcyBpbW11dGFibGUuIERvbid0IGNoYW5nZSBhbnkgcHJvcGVydGllcyBpbiBpdC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU291cmNlKHNvdXJjZURhdGEsIHRoaXNNZXRhUmF3T3B0aW9uLFxuLy8gY2FuIGJlIG51bGwuIElmIG5vdCBwcm92aWRlZCwgYXV0byBkZXRlY3QgaXQgZnJvbSBgc291cmNlRGF0YWAuXG5zb3VyY2VGb3JtYXQpIHtcbiAgc291cmNlRm9ybWF0ID0gc291cmNlRm9ybWF0IHx8IGRldGVjdFNvdXJjZUZvcm1hdChzb3VyY2VEYXRhKTtcbiAgdmFyIHNlcmllc0xheW91dEJ5ID0gdGhpc01ldGFSYXdPcHRpb24uc2VyaWVzTGF5b3V0Qnk7XG4gIHZhciBkZXRlcm1pbmVkID0gZGV0ZXJtaW5lU291cmNlRGltZW5zaW9ucyhzb3VyY2VEYXRhLCBzb3VyY2VGb3JtYXQsIHNlcmllc0xheW91dEJ5LCB0aGlzTWV0YVJhd09wdGlvbi5zb3VyY2VIZWFkZXIsIHRoaXNNZXRhUmF3T3B0aW9uLmRpbWVuc2lvbnMpO1xuICB2YXIgc291cmNlID0gbmV3IFNvdXJjZUltcGwoe1xuICAgIGRhdGE6IHNvdXJjZURhdGEsXG4gICAgc291cmNlRm9ybWF0OiBzb3VyY2VGb3JtYXQsXG4gICAgc2VyaWVzTGF5b3V0Qnk6IHNlcmllc0xheW91dEJ5LFxuICAgIGRpbWVuc2lvbnNEZWZpbmU6IGRldGVybWluZWQuZGltZW5zaW9uc0RlZmluZSxcbiAgICBzdGFydEluZGV4OiBkZXRlcm1pbmVkLnN0YXJ0SW5kZXgsXG4gICAgZGltZW5zaW9uc0RldGVjdGVkQ291bnQ6IGRldGVybWluZWQuZGltZW5zaW9uc0RldGVjdGVkQ291bnQsXG4gICAgbWV0YVJhd09wdGlvbjogY2xvbmUodGhpc01ldGFSYXdPcHRpb24pXG4gIH0pO1xuICByZXR1cm4gc291cmNlO1xufVxuLyoqXHJcbiAqIFdyYXAgb3JpZ2luYWwgc2VyaWVzIGRhdGEgZm9yIHNvbWUgY29tcGF0aWJpbGl0eSBjYXNlcy5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU291cmNlRnJvbVNlcmllc0RhdGFPcHRpb24oZGF0YSkge1xuICByZXR1cm4gbmV3IFNvdXJjZUltcGwoe1xuICAgIGRhdGE6IGRhdGEsXG4gICAgc291cmNlRm9ybWF0OiBpc1R5cGVkQXJyYXkoZGF0YSkgPyBTT1VSQ0VfRk9STUFUX1RZUEVEX0FSUkFZIDogU09VUkNFX0ZPUk1BVF9PUklHSU5BTFxuICB9KTtcbn1cbi8qKlxyXG4gKiBDbG9uZSBzb3VyY2UgYnV0IGV4Y2x1ZGVzIHNvdXJjZSBkYXRhLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVNvdXJjZVNoYWxsb3coc291cmNlKSB7XG4gIHJldHVybiBuZXcgU291cmNlSW1wbCh7XG4gICAgZGF0YTogc291cmNlLmRhdGEsXG4gICAgc291cmNlRm9ybWF0OiBzb3VyY2Uuc291cmNlRm9ybWF0LFxuICAgIHNlcmllc0xheW91dEJ5OiBzb3VyY2Uuc2VyaWVzTGF5b3V0QnksXG4gICAgZGltZW5zaW9uc0RlZmluZTogY2xvbmUoc291cmNlLmRpbWVuc2lvbnNEZWZpbmUpLFxuICAgIHN0YXJ0SW5kZXg6IHNvdXJjZS5zdGFydEluZGV4LFxuICAgIGRpbWVuc2lvbnNEZXRlY3RlZENvdW50OiBzb3VyY2UuZGltZW5zaW9uc0RldGVjdGVkQ291bnRcbiAgfSk7XG59XG4vKipcclxuICogTm90ZTogQW4gZW1wdHkgYXJyYXkgd2lsbCBiZSBkZXRlY3RlZCBhcyBgU09VUkNFX0ZPUk1BVF9BUlJBWV9ST1dTYC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0U291cmNlRm9ybWF0KGRhdGEpIHtcbiAgdmFyIHNvdXJjZUZvcm1hdCA9IFNPVVJDRV9GT1JNQVRfVU5LTk9XTjtcbiAgaWYgKGlzVHlwZWRBcnJheShkYXRhKSkge1xuICAgIHNvdXJjZUZvcm1hdCA9IFNPVVJDRV9GT1JNQVRfVFlQRURfQVJSQVk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgIC8vIEZJWE1FIFdoZXRoZXIgdG9sZXJhdGUgbnVsbCBpbiB0b3AgbGV2ZWwgYXJyYXk/XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICBzb3VyY2VGb3JtYXQgPSBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1M7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGFbaV07XG4gICAgICBpZiAoaXRlbSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGl0ZW0pIHx8IGlzVHlwZWRBcnJheShpdGVtKSkge1xuICAgICAgICBzb3VyY2VGb3JtYXQgPSBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChpdGVtKSkge1xuICAgICAgICBzb3VyY2VGb3JtYXQgPSBTT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgaWYgKGhhc093bihkYXRhLCBrZXkpICYmIGlzQXJyYXlMaWtlKGRhdGFba2V5XSkpIHtcbiAgICAgICAgc291cmNlRm9ybWF0ID0gU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNvdXJjZUZvcm1hdDtcbn1cbi8qKlxyXG4gKiBEZXRlcm1pbmUgdGhlIHNvdXJjZSBkZWZpbml0aW9ucyBmcm9tIGRhdGEgc3RhbmRhbG9uZSBkaW1lbnNpb25zIGRlZmluaXRpb25zXHJcbiAqIGFyZSBub3Qgc3BlY2lmaWVkLlxyXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVNvdXJjZURpbWVuc2lvbnMoZGF0YSwgc291cmNlRm9ybWF0LCBzZXJpZXNMYXlvdXRCeSwgc291cmNlSGVhZGVyLFxuLy8gc3RhbmRhbG9uZSByYXcgZGltZW5zaW9ucyBkZWZpbml0aW9uLCBsaWtlOlxuLy8ge1xuLy8gICAgIGRpbWVuc2lvbnM6IFsnYWEnLCAnYmInLCB7IG5hbWU6ICdjYycsIHR5cGU6ICd0aW1lJyB9XVxuLy8gfVxuLy8gaW4gYGRhdGFzZXRgIG9yIGBzZXJpZXNgXG5kaW1lbnNpb25zRGVmaW5lKSB7XG4gIHZhciBkaW1lbnNpb25zRGV0ZWN0ZWRDb3VudDtcbiAgdmFyIHN0YXJ0SW5kZXg7XG4gIC8vIFBFTkRJTkc6IENvdWxkIGRhdGEgYmUgbnVsbC91bmRlZmluZWQgaGVyZT9cbiAgLy8gY3VycmVudGx5LCBpZiBgZGF0YXNldC5zb3VyY2VgIG5vdCBzcGVjaWZpZWQsIGVycm9yIHRocm93bi5cbiAgLy8gaWYgYHNlcmllcy5kYXRhYCBub3Qgc3BlY2lmaWVkLCBub3RoaW5nIHJlbmRlcmVkIHdpdGhvdXQgZXJyb3IgdGhyb3duLlxuICAvLyBTaG91bGQgdGVzdCB0aGVzZSBjYXNlcy5cbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpbWVuc2lvbnNEZWZpbmU6IG5vcm1hbGl6ZURpbWVuc2lvbnNPcHRpb24oZGltZW5zaW9uc0RlZmluZSksXG4gICAgICBzdGFydEluZGV4OiBzdGFydEluZGV4LFxuICAgICAgZGltZW5zaW9uc0RldGVjdGVkQ291bnQ6IGRpbWVuc2lvbnNEZXRlY3RlZENvdW50XG4gICAgfTtcbiAgfVxuICBpZiAoc291cmNlRm9ybWF0ID09PSBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MpIHtcbiAgICB2YXIgZGF0YUFycmF5Um93cyA9IGRhdGE7XG4gICAgLy8gUnVsZTogTW9zdCBvZiB0aGUgZmlyc3QgbGluZSBhcmUgc3RyaW5nOiBpdCBpcyBoZWFkZXIuXG4gICAgLy8gQ2F1dGlvbjogY29uc2lkZXIgYSBsaW5lIHdpdGggNSBzdHJpbmcgYW5kIDEgbnVtYmVyLFxuICAgIC8vIGl0IHN0aWxsIGNhbiBub3QgYmUgc3VyZSBpdCBpcyBhIGhlYWQsIGJlY2F1c2UgdGhlXG4gICAgLy8gNSBzdHJpbmcgbWF5IGJlIDUgdmFsdWVzIG9mIGNhdGVnb3J5IGNvbHVtbnMuXG4gICAgaWYgKHNvdXJjZUhlYWRlciA9PT0gJ2F1dG8nIHx8IHNvdXJjZUhlYWRlciA9PSBudWxsKSB7XG4gICAgICBhcnJheVJvd3NUcmF2ZWxGaXJzdChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIC8vICctJyBpcyByZWdhcmRlZCBhcyBudWxsL3VuZGVmaW5lZC5cbiAgICAgICAgaWYgKHZhbCAhPSBudWxsICYmIHZhbCAhPT0gJy0nKSB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbCkpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPT0gbnVsbCAmJiAoc3RhcnRJbmRleCA9IDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gMTAgaXMgYW4gZXhwZXJpZW5jZSBudW1iZXIsIGF2b2lkIGxvbmcgbG9vcC5cbiAgICAgIH0sIHNlcmllc0xheW91dEJ5LCBkYXRhQXJyYXlSb3dzLCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0SW5kZXggPSBpc051bWJlcihzb3VyY2VIZWFkZXIpID8gc291cmNlSGVhZGVyIDogc291cmNlSGVhZGVyID8gMSA6IDA7XG4gICAgfVxuICAgIGlmICghZGltZW5zaW9uc0RlZmluZSAmJiBzdGFydEluZGV4ID09PSAxKSB7XG4gICAgICBkaW1lbnNpb25zRGVmaW5lID0gW107XG4gICAgICBhcnJheVJvd3NUcmF2ZWxGaXJzdChmdW5jdGlvbiAodmFsLCBpbmRleCkge1xuICAgICAgICBkaW1lbnNpb25zRGVmaW5lW2luZGV4XSA9IHZhbCAhPSBudWxsID8gdmFsICsgJycgOiAnJztcbiAgICAgIH0sIHNlcmllc0xheW91dEJ5LCBkYXRhQXJyYXlSb3dzLCBJbmZpbml0eSk7XG4gICAgfVxuICAgIGRpbWVuc2lvbnNEZXRlY3RlZENvdW50ID0gZGltZW5zaW9uc0RlZmluZSA/IGRpbWVuc2lvbnNEZWZpbmUubGVuZ3RoIDogc2VyaWVzTGF5b3V0QnkgPT09IFNFUklFU19MQVlPVVRfQllfUk9XID8gZGF0YUFycmF5Um93cy5sZW5ndGggOiBkYXRhQXJyYXlSb3dzWzBdID8gZGF0YUFycmF5Um93c1swXS5sZW5ndGggOiBudWxsO1xuICB9IGVsc2UgaWYgKHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9PQkpFQ1RfUk9XUykge1xuICAgIGlmICghZGltZW5zaW9uc0RlZmluZSkge1xuICAgICAgZGltZW5zaW9uc0RlZmluZSA9IG9iamVjdFJvd3NDb2xsZWN0RGltZW5zaW9ucyhkYXRhKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc291cmNlRm9ybWF0ID09PSBTT1VSQ0VfRk9STUFUX0tFWUVEX0NPTFVNTlMpIHtcbiAgICBpZiAoIWRpbWVuc2lvbnNEZWZpbmUpIHtcbiAgICAgIGRpbWVuc2lvbnNEZWZpbmUgPSBbXTtcbiAgICAgIGVhY2goZGF0YSwgZnVuY3Rpb24gKGNvbEFyciwga2V5KSB7XG4gICAgICAgIGRpbWVuc2lvbnNEZWZpbmUucHVzaChrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9PUklHSU5BTCkge1xuICAgIHZhciB2YWx1ZTAgPSBnZXREYXRhSXRlbVZhbHVlKGRhdGFbMF0pO1xuICAgIGRpbWVuc2lvbnNEZXRlY3RlZENvdW50ID0gaXNBcnJheSh2YWx1ZTApICYmIHZhbHVlMC5sZW5ndGggfHwgMTtcbiAgfSBlbHNlIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfVFlQRURfQVJSQVkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0KCEhZGltZW5zaW9uc0RlZmluZSwgJ2RpbWVuc2lvbnMgbXVzdCBiZSBnaXZlbiBpZiBkYXRhIGlzIFR5cGVkQXJyYXkuJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3RhcnRJbmRleDogc3RhcnRJbmRleCxcbiAgICBkaW1lbnNpb25zRGVmaW5lOiBub3JtYWxpemVEaW1lbnNpb25zT3B0aW9uKGRpbWVuc2lvbnNEZWZpbmUpLFxuICAgIGRpbWVuc2lvbnNEZXRlY3RlZENvdW50OiBkaW1lbnNpb25zRGV0ZWN0ZWRDb3VudFxuICB9O1xufVxuZnVuY3Rpb24gb2JqZWN0Um93c0NvbGxlY3REaW1lbnNpb25zKGRhdGEpIHtcbiAgdmFyIGZpcnN0SW5kZXggPSAwO1xuICB2YXIgb2JqO1xuICB3aGlsZSAoZmlyc3RJbmRleCA8IGRhdGEubGVuZ3RoICYmICEob2JqID0gZGF0YVtmaXJzdEluZGV4KytdKSkge30gLy8ganNoaW50IGlnbm9yZTogbGluZVxuICBpZiAob2JqKSB7XG4gICAgcmV0dXJuIGtleXMob2JqKTtcbiAgfVxufVxuLy8gQ29uc2lkZXIgZGltZW5zaW9ucyBkZWZpbmVkIGxpa2UgWydBJywgJ3ByaWNlJywgJ0InLCAncHJpY2UnLCAnQycsICdwcmljZSddLFxuLy8gd2hpY2ggaXMgcmVhc29uYWJsZS4gQnV0IGRpbWVuc2lvbiBuYW1lIGlzIGR1cGxpY2F0ZWQuXG4vLyBSZXR1cm5zIHVuZGVmaW5lZCBvciBhbiBhcnJheSBjb250YWlucyBvbmx5IG9iamVjdCB3aXRob3V0IG51bGwvdW5kZWZpbmVkIG9yIHN0cmluZy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpbWVuc2lvbnNPcHRpb24oZGltZW5zaW9uc0RlZmluZSkge1xuICBpZiAoIWRpbWVuc2lvbnNEZWZpbmUpIHtcbiAgICAvLyBUaGUgbWVhbmluZyBvZiBudWxsL3VuZGVmaW5lZCBpcyBkaWZmZXJlbnQgZnJvbSBlbXB0eSBhcnJheS5cbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWVNYXAgPSBjcmVhdGVIYXNoTWFwKCk7XG4gIHJldHVybiBtYXAoZGltZW5zaW9uc0RlZmluZSwgZnVuY3Rpb24gKHJhd0l0ZW0sIGluZGV4KSB7XG4gICAgcmF3SXRlbSA9IGlzT2JqZWN0KHJhd0l0ZW0pID8gcmF3SXRlbSA6IHtcbiAgICAgIG5hbWU6IHJhd0l0ZW1cbiAgICB9O1xuICAgIC8vIE90aGVyIGZpZWxkcyB3aWxsIGJlIGRpc2NhcmRlZC5cbiAgICB2YXIgaXRlbSA9IHtcbiAgICAgIG5hbWU6IHJhd0l0ZW0ubmFtZSxcbiAgICAgIGRpc3BsYXlOYW1lOiByYXdJdGVtLmRpc3BsYXlOYW1lLFxuICAgICAgdHlwZTogcmF3SXRlbS50eXBlXG4gICAgfTtcbiAgICAvLyBVc2VyIGNhbiBzZXQgbnVsbCBpbiBkaW1lbnNpb25zLlxuICAgIC8vIFdlIGRvbid0IGF1dG8gc3BlY2lmeSBuYW1lLCBvdGhlcndpc2UgYSBnaXZlbiBuYW1lIG1heVxuICAgIC8vIGNhdXNlIGl0IHRvIGJlIHJlZmVycmVkIHVuZXhwZWN0ZWRseS5cbiAgICBpZiAoaXRlbS5uYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICAvLyBBbHNvIGNvbnNpZGVyIG51bWJlciBmb3JtIGxpa2UgMjAxMi5cbiAgICBpdGVtLm5hbWUgKz0gJyc7XG4gICAgLy8gVXNlciBtYXkgYWxzbyBzcGVjaWZ5IGRpc3BsYXlOYW1lLlxuICAgIC8vIGRpc3BsYXlOYW1lIHdpbGwgYWx3YXlzIGV4aXN0cyBleGNlcHQgdXNlciBub3RcbiAgICAvLyBzcGVjaWZpZWQgb3IgZGltIG5hbWUgaXMgbm90IHNwZWNpZmllZCBvciBkZXRlY3RlZC5cbiAgICAvLyAoQSBhdXRvIGdlbmVyYXRlZCBkaW0gbmFtZSB3aWxsIG5vdCBiZSB1c2VkIGFzXG4gICAgLy8gZGlzcGxheU5hbWUpLlxuICAgIGlmIChpdGVtLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgIGl0ZW0uZGlzcGxheU5hbWUgPSBpdGVtLm5hbWU7XG4gICAgfVxuICAgIHZhciBleGlzdCA9IG5hbWVNYXAuZ2V0KGl0ZW0ubmFtZSk7XG4gICAgaWYgKCFleGlzdCkge1xuICAgICAgbmFtZU1hcC5zZXQoaXRlbS5uYW1lLCB7XG4gICAgICAgIGNvdW50OiAxXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbS5uYW1lICs9ICctJyArIGV4aXN0LmNvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFycmF5Um93c1RyYXZlbEZpcnN0KGNiLCBzZXJpZXNMYXlvdXRCeSwgZGF0YSwgbWF4TG9vcCkge1xuICBpZiAoc2VyaWVzTGF5b3V0QnkgPT09IFNFUklFU19MQVlPVVRfQllfUk9XKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAmJiBpIDwgbWF4TG9vcDsgaSsrKSB7XG4gICAgICBjYihkYXRhW2ldID8gZGF0YVtpXVswXSA6IG51bGwsIGkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdmFsdWUwID0gZGF0YVswXSB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlMC5sZW5ndGggJiYgaSA8IG1heExvb3A7IGkrKykge1xuICAgICAgY2IodmFsdWUwW2ldLCBpKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRSZXRyaWV2ZURhdGFCeU5hbWUoc291cmNlKSB7XG4gIHZhciBzb3VyY2VGb3JtYXQgPSBzb3VyY2Uuc291cmNlRm9ybWF0O1xuICByZXR1cm4gc291cmNlRm9ybWF0ID09PSBTT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTIHx8IHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9LRVlFRF9DT0xVTU5TO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34310\n")},40972:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ disableTransformOptionMerge),\n/* harmony export */   R: () => (/* binding */ SourceManager)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(34310);\n/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13430);\n/* harmony import */ var _sourceHelper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(23071);\n/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17752);\n/* harmony import */ var _DataStore_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(70250);\n/* harmony import */ var _dataProvider_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58267);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n/**\r\n * [REQUIREMENT_MEMO]:\r\n * (0) `metaRawOption` means `dimensions`/`sourceHeader`/`seriesLayoutBy` in raw option.\r\n * (1) Keep support the feature: `metaRawOption` can be specified both on `series` and\r\n * `root-dataset`. Them on `series` has higher priority.\r\n * (2) Do not support to set `metaRawOption` on a `non-root-dataset`, because it might\r\n * confuse users: whether those props indicate how to visit the upstream source or visit\r\n * the transform result source, and some transforms has nothing to do with these props,\r\n * and some transforms might have multiple upstream.\r\n * (3) Transforms should specify `metaRawOption` in each output, just like they can be\r\n * declared in `root-dataset`.\r\n * (4) At present only support visit source in `SERIES_LAYOUT_BY_COLUMN` in transforms.\r\n * That is for reducing complexity in transforms.\r\n * PENDING: Whether to provide transposition transform?\r\n *\r\n * [IMPLEMENTAION_MEMO]:\r\n * \"sourceVisitConfig\" are calculated from `metaRawOption` and `data`.\r\n * They will not be calculated until `source` is about to be visited (to prevent from\r\n * duplicate calcuation). `source` is visited only in series and input to transforms.\r\n *\r\n * [DIMENSION_INHERIT_RULE]:\r\n * By default the dimensions are inherited from ancestors, unless a transform return\r\n * a new dimensions definition.\r\n * Consider the case:\r\n * ```js\r\n * dataset: [{\r\n *     source: [ ['Product', 'Sales', 'Prise'], ['Cookies', 321, 44.21], ...]\r\n * }, {\r\n *     transform: { type: 'filter', ... }\r\n * }]\r\n * dataset: [{\r\n *     dimension: ['Product', 'Sales', 'Prise'],\r\n *     source: [ ['Cookies', 321, 44.21], ...]\r\n * }, {\r\n *     transform: { type: 'filter', ... }\r\n * }]\r\n * ```\r\n * The two types of option should have the same behavior after transform.\r\n *\r\n *\r\n * [SCENARIO]:\r\n * (1) Provide source data directly:\r\n * ```js\r\n * series: {\r\n *     encode: {...},\r\n *     dimensions: [...]\r\n *     seriesLayoutBy: 'row',\r\n *     data: [[...]]\r\n * }\r\n * ```\r\n * (2) Series refer to dataset.\r\n * ```js\r\n * series: [{\r\n *     encode: {...}\r\n *     // Ignore datasetIndex means `datasetIndex: 0`\r\n *     // and the dimensions defination in dataset is used\r\n * }, {\r\n *     encode: {...},\r\n *     seriesLayoutBy: 'column',\r\n *     datasetIndex: 1\r\n * }]\r\n * ```\r\n * (3) dataset transform\r\n * ```js\r\n * dataset: [{\r\n *     source: [...]\r\n * }, {\r\n *     source: [...]\r\n * }, {\r\n *     // By default from 0.\r\n *     transform: { type: 'filter', config: {...} }\r\n * }, {\r\n *     // Piped.\r\n *     transform: [\r\n *         { type: 'filter', config: {...} },\r\n *         { type: 'sort', config: {...} }\r\n *     ]\r\n * }, {\r\n *     id: 'regressionData',\r\n *     fromDatasetIndex: 1,\r\n *     // Third-party transform\r\n *     transform: { type: 'ecStat:regression', config: {...} }\r\n * }, {\r\n *     // retrieve the extra result.\r\n *     id: 'regressionFormula',\r\n *     fromDatasetId: 'regressionData',\r\n *     fromTransformResult: 1\r\n * }]\r\n * ```\r\n */\nvar SourceManager = /** @class */function () {\n  function SourceManager(sourceHost) {\n    // Cached source. Do not repeat calculating if not dirty.\n    this._sourceList = [];\n    this._storeList = [];\n    // version sign of each upstream source manager.\n    this._upstreamSignList = [];\n    this._versionSignBase = 0;\n    this._dirty = true;\n    this._sourceHost = sourceHost;\n  }\n  /**\r\n   * Mark dirty.\r\n   */\n  SourceManager.prototype.dirty = function () {\n    this._setLocalSource([], []);\n    this._storeList = [];\n    this._dirty = true;\n  };\n  SourceManager.prototype._setLocalSource = function (sourceList, upstreamSignList) {\n    this._sourceList = sourceList;\n    this._upstreamSignList = upstreamSignList;\n    this._versionSignBase++;\n    if (this._versionSignBase > 9e10) {\n      this._versionSignBase = 0;\n    }\n  };\n  /**\r\n   * For detecting whether the upstream source is dirty, so that\r\n   * the local cached source (in `_sourceList`) should be discarded.\r\n   */\n  SourceManager.prototype._getVersionSign = function () {\n    return this._sourceHost.uid + '_' + this._versionSignBase;\n  };\n  /**\r\n   * Always return a source instance. Otherwise throw error.\r\n   */\n  SourceManager.prototype.prepareSource = function () {\n    // For the case that call `setOption` multiple time but no data changed,\n    // cache the result source to prevent from repeating transform.\n    if (this._isDirty()) {\n      this._createSource();\n      this._dirty = false;\n    }\n  };\n  SourceManager.prototype._createSource = function () {\n    this._setLocalSource([], []);\n    var sourceHost = this._sourceHost;\n    var upSourceMgrList = this._getUpstreamSourceManagers();\n    var hasUpstream = !!upSourceMgrList.length;\n    var resultSourceList;\n    var upstreamSignList;\n    if (isSeries(sourceHost)) {\n      var seriesModel = sourceHost;\n      var data = void 0;\n      var sourceFormat = void 0;\n      var upSource = void 0;\n      // Has upstream dataset\n      if (hasUpstream) {\n        var upSourceMgr = upSourceMgrList[0];\n        upSourceMgr.prepareSource();\n        upSource = upSourceMgr.getSource();\n        data = upSource.data;\n        sourceFormat = upSource.sourceFormat;\n        upstreamSignList = [upSourceMgr._getVersionSign()];\n      }\n      // Series data is from own.\n      else {\n        data = seriesModel.get('data', true);\n        sourceFormat = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isTypedArray)(data) ? _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_TYPED_ARRAY */ .XO : _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ORIGINAL */ .mK;\n        upstreamSignList = [];\n      }\n      // See [REQUIREMENT_MEMO], merge settings on series and parent dataset if it is root.\n      var newMetaRawOption = this._getSourceMetaRawOption() || {};\n      var upMetaRawOption = upSource && upSource.metaRawOption || {};\n      var seriesLayoutBy = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.retrieve2)(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;\n      var sourceHeader = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.retrieve2)(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader);\n      // Note here we should not use `upSource.dimensionsDefine`. Consider the case:\n      // `upSource.dimensionsDefine` is detected by `seriesLayoutBy: 'column'`,\n      // but series need `seriesLayoutBy: 'row'`.\n      var dimensions = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.retrieve2)(newMetaRawOption.dimensions, upMetaRawOption.dimensions);\n      // We share source with dataset as much as possible\n      // to avoid extra memory cost of high dimensional data.\n      var needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;\n      resultSourceList = needsCreateSource ? [(0,_Source_js__WEBPACK_IMPORTED_MODULE_2__/* .createSource */ .gV)(data, {\n        seriesLayoutBy: seriesLayoutBy,\n        sourceHeader: sourceHeader,\n        dimensions: dimensions\n      }, sourceFormat)] : [];\n    } else {\n      var datasetModel = sourceHost;\n      // Has upstream dataset.\n      if (hasUpstream) {\n        var result = this._applyTransform(upSourceMgrList);\n        resultSourceList = result.sourceList;\n        upstreamSignList = result.upstreamSignList;\n      }\n      // Is root dataset.\n      else {\n        var sourceData = datasetModel.get('source', true);\n        resultSourceList = [(0,_Source_js__WEBPACK_IMPORTED_MODULE_2__/* .createSource */ .gV)(sourceData, this._getSourceMetaRawOption(), null)];\n        upstreamSignList = [];\n      }\n    }\n    if (false) {}\n    this._setLocalSource(resultSourceList, upstreamSignList);\n  };\n  SourceManager.prototype._applyTransform = function (upMgrList) {\n    var datasetModel = this._sourceHost;\n    var transformOption = datasetModel.get('transform', true);\n    var fromTransformResult = datasetModel.get('fromTransformResult', true);\n    if (false) {}\n    if (fromTransformResult != null) {\n      var errMsg = '';\n      if (upMgrList.length !== 1) {\n        if (false) {}\n        doThrow(errMsg);\n      }\n    }\n    var sourceList;\n    var upSourceList = [];\n    var upstreamSignList = [];\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(upMgrList, function (upMgr) {\n      upMgr.prepareSource();\n      var upSource = upMgr.getSource(fromTransformResult || 0);\n      var errMsg = '';\n      if (fromTransformResult != null && !upSource) {\n        if (false) {}\n        doThrow(errMsg);\n      }\n      upSourceList.push(upSource);\n      upstreamSignList.push(upMgr._getVersionSign());\n    });\n    if (transformOption) {\n      sourceList = (0,_transform_js__WEBPACK_IMPORTED_MODULE_3__/* .applyDataTransform */ .py)(transformOption, upSourceList, {\n        datasetIndex: datasetModel.componentIndex\n      });\n    } else if (fromTransformResult != null) {\n      sourceList = [(0,_Source_js__WEBPACK_IMPORTED_MODULE_2__/* .cloneSourceShallow */ .BE)(upSourceList[0])];\n    }\n    return {\n      sourceList: sourceList,\n      upstreamSignList: upstreamSignList\n    };\n  };\n  SourceManager.prototype._isDirty = function () {\n    if (this._dirty) {\n      return true;\n    }\n    // All sourceList is from the some upstream.\n    var upSourceMgrList = this._getUpstreamSourceManagers();\n    for (var i = 0; i < upSourceMgrList.length; i++) {\n      var upSrcMgr = upSourceMgrList[i];\n      if (\n      // Consider the case that there is ancestor diry, call it recursively.\n      // The performance is probably not an issue because usually the chain is not long.\n      upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {\n        return true;\n      }\n    }\n  };\n  /**\r\n   * @param sourceIndex By default 0, means \"main source\".\r\n   *                    In most cases there is only one source.\r\n   */\n  SourceManager.prototype.getSource = function (sourceIndex) {\n    sourceIndex = sourceIndex || 0;\n    var source = this._sourceList[sourceIndex];\n    if (!source) {\n      // Series may share source instance with dataset.\n      var upSourceMgrList = this._getUpstreamSourceManagers();\n      return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);\n    }\n    return source;\n  };\n  /**\r\n   *\r\n   * Get a data store which can be shared across series.\r\n   * Only available for series.\r\n   *\r\n   * @param seriesDimRequest Dimensions that are generated in series.\r\n   *        Should have been sorted by `storeDimIndex` asc.\r\n   */\n  SourceManager.prototype.getSharedDataStore = function (seriesDimRequest) {\n    if (false) {}\n    var schema = seriesDimRequest.makeStoreSchema();\n    return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);\n  };\n  SourceManager.prototype._innerGetDataStore = function (storeDims, seriesSource, sourceReadKey) {\n    // TODO Can use other sourceIndex?\n    var sourceIndex = 0;\n    var storeList = this._storeList;\n    var cachedStoreMap = storeList[sourceIndex];\n    if (!cachedStoreMap) {\n      cachedStoreMap = storeList[sourceIndex] = {};\n    }\n    var cachedStore = cachedStoreMap[sourceReadKey];\n    if (!cachedStore) {\n      var upSourceMgr = this._getUpstreamSourceManagers()[0];\n      if (isSeries(this._sourceHost) && upSourceMgr) {\n        cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);\n      } else {\n        cachedStore = new _DataStore_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .Ay();\n        // Always create store from source of series.\n        cachedStore.initData(new _dataProvider_js__WEBPACK_IMPORTED_MODULE_5__/* .DefaultDataProvider */ .d1(seriesSource, storeDims.length), storeDims);\n      }\n      cachedStoreMap[sourceReadKey] = cachedStore;\n    }\n    return cachedStore;\n  };\n  /**\r\n   * PENDING: Is it fast enough?\r\n   * If no upstream, return empty array.\r\n   */\n  SourceManager.prototype._getUpstreamSourceManagers = function () {\n    // Always get the relationship from the raw option.\n    // Do not cache the link of the dependency graph, so that\n    // there is no need to update them when change happens.\n    var sourceHost = this._sourceHost;\n    if (isSeries(sourceHost)) {\n      var datasetModel = (0,_sourceHelper_js__WEBPACK_IMPORTED_MODULE_6__/* .querySeriesUpstreamDatasetModel */ .G9)(sourceHost);\n      return !datasetModel ? [] : [datasetModel.getSourceManager()];\n    } else {\n      return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.map)((0,_sourceHelper_js__WEBPACK_IMPORTED_MODULE_6__/* .queryDatasetUpstreamDatasetModels */ .Gt)(sourceHost), function (datasetModel) {\n        return datasetModel.getSourceManager();\n      });\n    }\n  };\n  SourceManager.prototype._getSourceMetaRawOption = function () {\n    var sourceHost = this._sourceHost;\n    var seriesLayoutBy;\n    var sourceHeader;\n    var dimensions;\n    if (isSeries(sourceHost)) {\n      seriesLayoutBy = sourceHost.get('seriesLayoutBy', true);\n      sourceHeader = sourceHost.get('sourceHeader', true);\n      dimensions = sourceHost.get('dimensions', true);\n    }\n    // See [REQUIREMENT_MEMO], `non-root-dataset` do not support them.\n    else if (!this._getUpstreamSourceManagers().length) {\n      var model = sourceHost;\n      seriesLayoutBy = model.get('seriesLayoutBy', true);\n      sourceHeader = model.get('sourceHeader', true);\n      dimensions = model.get('dimensions', true);\n    }\n    return {\n      seriesLayoutBy: seriesLayoutBy,\n      sourceHeader: sourceHeader,\n      dimensions: dimensions\n    };\n  };\n  return SourceManager;\n}();\n\n// Call this method after `super.init` and `super.mergeOption` to\n// disable the transform merge, but do not disable transform clone from rawOption.\nfunction disableTransformOptionMerge(datasetModel) {\n  var transformOption = datasetModel.option.transform;\n  transformOption && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.setAsPrimitive)(datasetModel.option.transform);\n}\nfunction isSeries(sourceHost) {\n  // Avoid circular dependency with Series.ts\n  return sourceHost.mainType === 'series';\n}\nfunction doThrow(errMsg) {\n  throw new Error(errMsg);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA5NzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvaGVscGVyL3NvdXJjZU1hbmFnZXIuanM/YzcyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IHNldEFzUHJpbWl0aXZlLCBtYXAsIGlzVHlwZWRBcnJheSwgYXNzZXJ0LCBlYWNoLCByZXRyaWV2ZTIgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgY3JlYXRlU291cmNlLCBjbG9uZVNvdXJjZVNoYWxsb3cgfSBmcm9tICcuLi9Tb3VyY2UuanMnO1xuaW1wb3J0IHsgU09VUkNFX0ZPUk1BVF9UWVBFRF9BUlJBWSwgU09VUkNFX0ZPUk1BVF9PUklHSU5BTCB9IGZyb20gJy4uLy4uL3V0aWwvdHlwZXMuanMnO1xuaW1wb3J0IHsgcXVlcnlTZXJpZXNVcHN0cmVhbURhdGFzZXRNb2RlbCwgcXVlcnlEYXRhc2V0VXBzdHJlYW1EYXRhc2V0TW9kZWxzIH0gZnJvbSAnLi9zb3VyY2VIZWxwZXIuanMnO1xuaW1wb3J0IHsgYXBwbHlEYXRhVHJhbnNmb3JtIH0gZnJvbSAnLi90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IERhdGFTdG9yZSBmcm9tICcuLi9EYXRhU3RvcmUuanMnO1xuaW1wb3J0IHsgRGVmYXVsdERhdGFQcm92aWRlciB9IGZyb20gJy4vZGF0YVByb3ZpZGVyLmpzJztcbi8qKlxyXG4gKiBbUkVRVUlSRU1FTlRfTUVNT106XHJcbiAqICgwKSBgbWV0YVJhd09wdGlvbmAgbWVhbnMgYGRpbWVuc2lvbnNgL2Bzb3VyY2VIZWFkZXJgL2BzZXJpZXNMYXlvdXRCeWAgaW4gcmF3IG9wdGlvbi5cclxuICogKDEpIEtlZXAgc3VwcG9ydCB0aGUgZmVhdHVyZTogYG1ldGFSYXdPcHRpb25gIGNhbiBiZSBzcGVjaWZpZWQgYm90aCBvbiBgc2VyaWVzYCBhbmRcclxuICogYHJvb3QtZGF0YXNldGAuIFRoZW0gb24gYHNlcmllc2AgaGFzIGhpZ2hlciBwcmlvcml0eS5cclxuICogKDIpIERvIG5vdCBzdXBwb3J0IHRvIHNldCBgbWV0YVJhd09wdGlvbmAgb24gYSBgbm9uLXJvb3QtZGF0YXNldGAsIGJlY2F1c2UgaXQgbWlnaHRcclxuICogY29uZnVzZSB1c2Vyczogd2hldGhlciB0aG9zZSBwcm9wcyBpbmRpY2F0ZSBob3cgdG8gdmlzaXQgdGhlIHVwc3RyZWFtIHNvdXJjZSBvciB2aXNpdFxyXG4gKiB0aGUgdHJhbnNmb3JtIHJlc3VsdCBzb3VyY2UsIGFuZCBzb21lIHRyYW5zZm9ybXMgaGFzIG5vdGhpbmcgdG8gZG8gd2l0aCB0aGVzZSBwcm9wcyxcclxuICogYW5kIHNvbWUgdHJhbnNmb3JtcyBtaWdodCBoYXZlIG11bHRpcGxlIHVwc3RyZWFtLlxyXG4gKiAoMykgVHJhbnNmb3JtcyBzaG91bGQgc3BlY2lmeSBgbWV0YVJhd09wdGlvbmAgaW4gZWFjaCBvdXRwdXQsIGp1c3QgbGlrZSB0aGV5IGNhbiBiZVxyXG4gKiBkZWNsYXJlZCBpbiBgcm9vdC1kYXRhc2V0YC5cclxuICogKDQpIEF0IHByZXNlbnQgb25seSBzdXBwb3J0IHZpc2l0IHNvdXJjZSBpbiBgU0VSSUVTX0xBWU9VVF9CWV9DT0xVTU5gIGluIHRyYW5zZm9ybXMuXHJcbiAqIFRoYXQgaXMgZm9yIHJlZHVjaW5nIGNvbXBsZXhpdHkgaW4gdHJhbnNmb3Jtcy5cclxuICogUEVORElORzogV2hldGhlciB0byBwcm92aWRlIHRyYW5zcG9zaXRpb24gdHJhbnNmb3JtP1xyXG4gKlxyXG4gKiBbSU1QTEVNRU5UQUlPTl9NRU1PXTpcclxuICogXCJzb3VyY2VWaXNpdENvbmZpZ1wiIGFyZSBjYWxjdWxhdGVkIGZyb20gYG1ldGFSYXdPcHRpb25gIGFuZCBgZGF0YWAuXHJcbiAqIFRoZXkgd2lsbCBub3QgYmUgY2FsY3VsYXRlZCB1bnRpbCBgc291cmNlYCBpcyBhYm91dCB0byBiZSB2aXNpdGVkICh0byBwcmV2ZW50IGZyb21cclxuICogZHVwbGljYXRlIGNhbGN1YXRpb24pLiBgc291cmNlYCBpcyB2aXNpdGVkIG9ubHkgaW4gc2VyaWVzIGFuZCBpbnB1dCB0byB0cmFuc2Zvcm1zLlxyXG4gKlxyXG4gKiBbRElNRU5TSU9OX0lOSEVSSVRfUlVMRV06XHJcbiAqIEJ5IGRlZmF1bHQgdGhlIGRpbWVuc2lvbnMgYXJlIGluaGVyaXRlZCBmcm9tIGFuY2VzdG9ycywgdW5sZXNzIGEgdHJhbnNmb3JtIHJldHVyblxyXG4gKiBhIG5ldyBkaW1lbnNpb25zIGRlZmluaXRpb24uXHJcbiAqIENvbnNpZGVyIHRoZSBjYXNlOlxyXG4gKiBgYGBqc1xyXG4gKiBkYXRhc2V0OiBbe1xyXG4gKiAgICAgc291cmNlOiBbIFsnUHJvZHVjdCcsICdTYWxlcycsICdQcmlzZSddLCBbJ0Nvb2tpZXMnLCAzMjEsIDQ0LjIxXSwgLi4uXVxyXG4gKiB9LCB7XHJcbiAqICAgICB0cmFuc2Zvcm06IHsgdHlwZTogJ2ZpbHRlcicsIC4uLiB9XHJcbiAqIH1dXHJcbiAqIGRhdGFzZXQ6IFt7XHJcbiAqICAgICBkaW1lbnNpb246IFsnUHJvZHVjdCcsICdTYWxlcycsICdQcmlzZSddLFxyXG4gKiAgICAgc291cmNlOiBbIFsnQ29va2llcycsIDMyMSwgNDQuMjFdLCAuLi5dXHJcbiAqIH0sIHtcclxuICogICAgIHRyYW5zZm9ybTogeyB0eXBlOiAnZmlsdGVyJywgLi4uIH1cclxuICogfV1cclxuICogYGBgXHJcbiAqIFRoZSB0d28gdHlwZXMgb2Ygb3B0aW9uIHNob3VsZCBoYXZlIHRoZSBzYW1lIGJlaGF2aW9yIGFmdGVyIHRyYW5zZm9ybS5cclxuICpcclxuICpcclxuICogW1NDRU5BUklPXTpcclxuICogKDEpIFByb3ZpZGUgc291cmNlIGRhdGEgZGlyZWN0bHk6XHJcbiAqIGBgYGpzXHJcbiAqIHNlcmllczoge1xyXG4gKiAgICAgZW5jb2RlOiB7Li4ufSxcclxuICogICAgIGRpbWVuc2lvbnM6IFsuLi5dXHJcbiAqICAgICBzZXJpZXNMYXlvdXRCeTogJ3JvdycsXHJcbiAqICAgICBkYXRhOiBbWy4uLl1dXHJcbiAqIH1cclxuICogYGBgXHJcbiAqICgyKSBTZXJpZXMgcmVmZXIgdG8gZGF0YXNldC5cclxuICogYGBganNcclxuICogc2VyaWVzOiBbe1xyXG4gKiAgICAgZW5jb2RlOiB7Li4ufVxyXG4gKiAgICAgLy8gSWdub3JlIGRhdGFzZXRJbmRleCBtZWFucyBgZGF0YXNldEluZGV4OiAwYFxyXG4gKiAgICAgLy8gYW5kIHRoZSBkaW1lbnNpb25zIGRlZmluYXRpb24gaW4gZGF0YXNldCBpcyB1c2VkXHJcbiAqIH0sIHtcclxuICogICAgIGVuY29kZTogey4uLn0sXHJcbiAqICAgICBzZXJpZXNMYXlvdXRCeTogJ2NvbHVtbicsXHJcbiAqICAgICBkYXRhc2V0SW5kZXg6IDFcclxuICogfV1cclxuICogYGBgXHJcbiAqICgzKSBkYXRhc2V0IHRyYW5zZm9ybVxyXG4gKiBgYGBqc1xyXG4gKiBkYXRhc2V0OiBbe1xyXG4gKiAgICAgc291cmNlOiBbLi4uXVxyXG4gKiB9LCB7XHJcbiAqICAgICBzb3VyY2U6IFsuLi5dXHJcbiAqIH0sIHtcclxuICogICAgIC8vIEJ5IGRlZmF1bHQgZnJvbSAwLlxyXG4gKiAgICAgdHJhbnNmb3JtOiB7IHR5cGU6ICdmaWx0ZXInLCBjb25maWc6IHsuLi59IH1cclxuICogfSwge1xyXG4gKiAgICAgLy8gUGlwZWQuXHJcbiAqICAgICB0cmFuc2Zvcm06IFtcclxuICogICAgICAgICB7IHR5cGU6ICdmaWx0ZXInLCBjb25maWc6IHsuLi59IH0sXHJcbiAqICAgICAgICAgeyB0eXBlOiAnc29ydCcsIGNvbmZpZzogey4uLn0gfVxyXG4gKiAgICAgXVxyXG4gKiB9LCB7XHJcbiAqICAgICBpZDogJ3JlZ3Jlc3Npb25EYXRhJyxcclxuICogICAgIGZyb21EYXRhc2V0SW5kZXg6IDEsXHJcbiAqICAgICAvLyBUaGlyZC1wYXJ0eSB0cmFuc2Zvcm1cclxuICogICAgIHRyYW5zZm9ybTogeyB0eXBlOiAnZWNTdGF0OnJlZ3Jlc3Npb24nLCBjb25maWc6IHsuLi59IH1cclxuICogfSwge1xyXG4gKiAgICAgLy8gcmV0cmlldmUgdGhlIGV4dHJhIHJlc3VsdC5cclxuICogICAgIGlkOiAncmVncmVzc2lvbkZvcm11bGEnLFxyXG4gKiAgICAgZnJvbURhdGFzZXRJZDogJ3JlZ3Jlc3Npb25EYXRhJyxcclxuICogICAgIGZyb21UcmFuc2Zvcm1SZXN1bHQ6IDFcclxuICogfV1cclxuICogYGBgXHJcbiAqL1xudmFyIFNvdXJjZU1hbmFnZXIgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTb3VyY2VNYW5hZ2VyKHNvdXJjZUhvc3QpIHtcbiAgICAvLyBDYWNoZWQgc291cmNlLiBEbyBub3QgcmVwZWF0IGNhbGN1bGF0aW5nIGlmIG5vdCBkaXJ0eS5cbiAgICB0aGlzLl9zb3VyY2VMaXN0ID0gW107XG4gICAgdGhpcy5fc3RvcmVMaXN0ID0gW107XG4gICAgLy8gdmVyc2lvbiBzaWduIG9mIGVhY2ggdXBzdHJlYW0gc291cmNlIG1hbmFnZXIuXG4gICAgdGhpcy5fdXBzdHJlYW1TaWduTGlzdCA9IFtdO1xuICAgIHRoaXMuX3ZlcnNpb25TaWduQmFzZSA9IDA7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3NvdXJjZUhvc3QgPSBzb3VyY2VIb3N0O1xuICB9XG4gIC8qKlxyXG4gICAqIE1hcmsgZGlydHkuXHJcbiAgICovXG4gIFNvdXJjZU1hbmFnZXIucHJvdG90eXBlLmRpcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3NldExvY2FsU291cmNlKFtdLCBbXSk7XG4gICAgdGhpcy5fc3RvcmVMaXN0ID0gW107XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICB9O1xuICBTb3VyY2VNYW5hZ2VyLnByb3RvdHlwZS5fc2V0TG9jYWxTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlTGlzdCwgdXBzdHJlYW1TaWduTGlzdCkge1xuICAgIHRoaXMuX3NvdXJjZUxpc3QgPSBzb3VyY2VMaXN0O1xuICAgIHRoaXMuX3Vwc3RyZWFtU2lnbkxpc3QgPSB1cHN0cmVhbVNpZ25MaXN0O1xuICAgIHRoaXMuX3ZlcnNpb25TaWduQmFzZSsrO1xuICAgIGlmICh0aGlzLl92ZXJzaW9uU2lnbkJhc2UgPiA5ZTEwKSB7XG4gICAgICB0aGlzLl92ZXJzaW9uU2lnbkJhc2UgPSAwO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogRm9yIGRldGVjdGluZyB3aGV0aGVyIHRoZSB1cHN0cmVhbSBzb3VyY2UgaXMgZGlydHksIHNvIHRoYXRcclxuICAgKiB0aGUgbG9jYWwgY2FjaGVkIHNvdXJjZSAoaW4gYF9zb3VyY2VMaXN0YCkgc2hvdWxkIGJlIGRpc2NhcmRlZC5cclxuICAgKi9cbiAgU291cmNlTWFuYWdlci5wcm90b3R5cGUuX2dldFZlcnNpb25TaWduID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VIb3N0LnVpZCArICdfJyArIHRoaXMuX3ZlcnNpb25TaWduQmFzZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQWx3YXlzIHJldHVybiBhIHNvdXJjZSBpbnN0YW5jZS4gT3RoZXJ3aXNlIHRocm93IGVycm9yLlxyXG4gICAqL1xuICBTb3VyY2VNYW5hZ2VyLnByb3RvdHlwZS5wcmVwYXJlU291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEZvciB0aGUgY2FzZSB0aGF0IGNhbGwgYHNldE9wdGlvbmAgbXVsdGlwbGUgdGltZSBidXQgbm8gZGF0YSBjaGFuZ2VkLFxuICAgIC8vIGNhY2hlIHRoZSByZXN1bHQgc291cmNlIHRvIHByZXZlbnQgZnJvbSByZXBlYXRpbmcgdHJhbnNmb3JtLlxuICAgIGlmICh0aGlzLl9pc0RpcnR5KCkpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVNvdXJjZSgpO1xuICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIFNvdXJjZU1hbmFnZXIucHJvdG90eXBlLl9jcmVhdGVTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fc2V0TG9jYWxTb3VyY2UoW10sIFtdKTtcbiAgICB2YXIgc291cmNlSG9zdCA9IHRoaXMuX3NvdXJjZUhvc3Q7XG4gICAgdmFyIHVwU291cmNlTWdyTGlzdCA9IHRoaXMuX2dldFVwc3RyZWFtU291cmNlTWFuYWdlcnMoKTtcbiAgICB2YXIgaGFzVXBzdHJlYW0gPSAhIXVwU291cmNlTWdyTGlzdC5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdFNvdXJjZUxpc3Q7XG4gICAgdmFyIHVwc3RyZWFtU2lnbkxpc3Q7XG4gICAgaWYgKGlzU2VyaWVzKHNvdXJjZUhvc3QpKSB7XG4gICAgICB2YXIgc2VyaWVzTW9kZWwgPSBzb3VyY2VIb3N0O1xuICAgICAgdmFyIGRhdGEgPSB2b2lkIDA7XG4gICAgICB2YXIgc291cmNlRm9ybWF0ID0gdm9pZCAwO1xuICAgICAgdmFyIHVwU291cmNlID0gdm9pZCAwO1xuICAgICAgLy8gSGFzIHVwc3RyZWFtIGRhdGFzZXRcbiAgICAgIGlmIChoYXNVcHN0cmVhbSkge1xuICAgICAgICB2YXIgdXBTb3VyY2VNZ3IgPSB1cFNvdXJjZU1nckxpc3RbMF07XG4gICAgICAgIHVwU291cmNlTWdyLnByZXBhcmVTb3VyY2UoKTtcbiAgICAgICAgdXBTb3VyY2UgPSB1cFNvdXJjZU1nci5nZXRTb3VyY2UoKTtcbiAgICAgICAgZGF0YSA9IHVwU291cmNlLmRhdGE7XG4gICAgICAgIHNvdXJjZUZvcm1hdCA9IHVwU291cmNlLnNvdXJjZUZvcm1hdDtcbiAgICAgICAgdXBzdHJlYW1TaWduTGlzdCA9IFt1cFNvdXJjZU1nci5fZ2V0VmVyc2lvblNpZ24oKV07XG4gICAgICB9XG4gICAgICAvLyBTZXJpZXMgZGF0YSBpcyBmcm9tIG93bi5cbiAgICAgIGVsc2Uge1xuICAgICAgICBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0KCdkYXRhJywgdHJ1ZSk7XG4gICAgICAgIHNvdXJjZUZvcm1hdCA9IGlzVHlwZWRBcnJheShkYXRhKSA/IFNPVVJDRV9GT1JNQVRfVFlQRURfQVJSQVkgOiBTT1VSQ0VfRk9STUFUX09SSUdJTkFMO1xuICAgICAgICB1cHN0cmVhbVNpZ25MaXN0ID0gW107XG4gICAgICB9XG4gICAgICAvLyBTZWUgW1JFUVVJUkVNRU5UX01FTU9dLCBtZXJnZSBzZXR0aW5ncyBvbiBzZXJpZXMgYW5kIHBhcmVudCBkYXRhc2V0IGlmIGl0IGlzIHJvb3QuXG4gICAgICB2YXIgbmV3TWV0YVJhd09wdGlvbiA9IHRoaXMuX2dldFNvdXJjZU1ldGFSYXdPcHRpb24oKSB8fCB7fTtcbiAgICAgIHZhciB1cE1ldGFSYXdPcHRpb24gPSB1cFNvdXJjZSAmJiB1cFNvdXJjZS5tZXRhUmF3T3B0aW9uIHx8IHt9O1xuICAgICAgdmFyIHNlcmllc0xheW91dEJ5ID0gcmV0cmlldmUyKG5ld01ldGFSYXdPcHRpb24uc2VyaWVzTGF5b3V0QnksIHVwTWV0YVJhd09wdGlvbi5zZXJpZXNMYXlvdXRCeSkgfHwgbnVsbDtcbiAgICAgIHZhciBzb3VyY2VIZWFkZXIgPSByZXRyaWV2ZTIobmV3TWV0YVJhd09wdGlvbi5zb3VyY2VIZWFkZXIsIHVwTWV0YVJhd09wdGlvbi5zb3VyY2VIZWFkZXIpO1xuICAgICAgLy8gTm90ZSBoZXJlIHdlIHNob3VsZCBub3QgdXNlIGB1cFNvdXJjZS5kaW1lbnNpb25zRGVmaW5lYC4gQ29uc2lkZXIgdGhlIGNhc2U6XG4gICAgICAvLyBgdXBTb3VyY2UuZGltZW5zaW9uc0RlZmluZWAgaXMgZGV0ZWN0ZWQgYnkgYHNlcmllc0xheW91dEJ5OiAnY29sdW1uJ2AsXG4gICAgICAvLyBidXQgc2VyaWVzIG5lZWQgYHNlcmllc0xheW91dEJ5OiAncm93J2AuXG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHJldHJpZXZlMihuZXdNZXRhUmF3T3B0aW9uLmRpbWVuc2lvbnMsIHVwTWV0YVJhd09wdGlvbi5kaW1lbnNpb25zKTtcbiAgICAgIC8vIFdlIHNoYXJlIHNvdXJjZSB3aXRoIGRhdGFzZXQgYXMgbXVjaCBhcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gYXZvaWQgZXh0cmEgbWVtb3J5IGNvc3Qgb2YgaGlnaCBkaW1lbnNpb25hbCBkYXRhLlxuICAgICAgdmFyIG5lZWRzQ3JlYXRlU291cmNlID0gc2VyaWVzTGF5b3V0QnkgIT09IHVwTWV0YVJhd09wdGlvbi5zZXJpZXNMYXlvdXRCeSB8fCAhIXNvdXJjZUhlYWRlciAhPT0gISF1cE1ldGFSYXdPcHRpb24uc291cmNlSGVhZGVyIHx8IGRpbWVuc2lvbnM7XG4gICAgICByZXN1bHRTb3VyY2VMaXN0ID0gbmVlZHNDcmVhdGVTb3VyY2UgPyBbY3JlYXRlU291cmNlKGRhdGEsIHtcbiAgICAgICAgc2VyaWVzTGF5b3V0Qnk6IHNlcmllc0xheW91dEJ5LFxuICAgICAgICBzb3VyY2VIZWFkZXI6IHNvdXJjZUhlYWRlcixcbiAgICAgICAgZGltZW5zaW9uczogZGltZW5zaW9uc1xuICAgICAgfSwgc291cmNlRm9ybWF0KV0gOiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGFzZXRNb2RlbCA9IHNvdXJjZUhvc3Q7XG4gICAgICAvLyBIYXMgdXBzdHJlYW0gZGF0YXNldC5cbiAgICAgIGlmIChoYXNVcHN0cmVhbSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fYXBwbHlUcmFuc2Zvcm0odXBTb3VyY2VNZ3JMaXN0KTtcbiAgICAgICAgcmVzdWx0U291cmNlTGlzdCA9IHJlc3VsdC5zb3VyY2VMaXN0O1xuICAgICAgICB1cHN0cmVhbVNpZ25MaXN0ID0gcmVzdWx0LnVwc3RyZWFtU2lnbkxpc3Q7XG4gICAgICB9XG4gICAgICAvLyBJcyByb290IGRhdGFzZXQuXG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZURhdGEgPSBkYXRhc2V0TW9kZWwuZ2V0KCdzb3VyY2UnLCB0cnVlKTtcbiAgICAgICAgcmVzdWx0U291cmNlTGlzdCA9IFtjcmVhdGVTb3VyY2Uoc291cmNlRGF0YSwgdGhpcy5fZ2V0U291cmNlTWV0YVJhd09wdGlvbigpLCBudWxsKV07XG4gICAgICAgIHVwc3RyZWFtU2lnbkxpc3QgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChyZXN1bHRTb3VyY2VMaXN0ICYmIHVwc3RyZWFtU2lnbkxpc3QpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRMb2NhbFNvdXJjZShyZXN1bHRTb3VyY2VMaXN0LCB1cHN0cmVhbVNpZ25MaXN0KTtcbiAgfTtcbiAgU291cmNlTWFuYWdlci5wcm90b3R5cGUuX2FwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKHVwTWdyTGlzdCkge1xuICAgIHZhciBkYXRhc2V0TW9kZWwgPSB0aGlzLl9zb3VyY2VIb3N0O1xuICAgIHZhciB0cmFuc2Zvcm1PcHRpb24gPSBkYXRhc2V0TW9kZWwuZ2V0KCd0cmFuc2Zvcm0nLCB0cnVlKTtcbiAgICB2YXIgZnJvbVRyYW5zZm9ybVJlc3VsdCA9IGRhdGFzZXRNb2RlbC5nZXQoJ2Zyb21UcmFuc2Zvcm1SZXN1bHQnLCB0cnVlKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0KGZyb21UcmFuc2Zvcm1SZXN1bHQgIT0gbnVsbCB8fCB0cmFuc2Zvcm1PcHRpb24gIT0gbnVsbCk7XG4gICAgfVxuICAgIGlmIChmcm9tVHJhbnNmb3JtUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgIHZhciBlcnJNc2cgPSAnJztcbiAgICAgIGlmICh1cE1nckxpc3QubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgZXJyTXNnID0gJ1doZW4gdXNpbmcgYGZyb21UcmFuc2Zvcm1SZXN1bHRgLCB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgdXBzdHJlYW0gZGF0YXNldCc7XG4gICAgICAgIH1cbiAgICAgICAgZG9UaHJvdyhlcnJNc2cpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc291cmNlTGlzdDtcbiAgICB2YXIgdXBTb3VyY2VMaXN0ID0gW107XG4gICAgdmFyIHVwc3RyZWFtU2lnbkxpc3QgPSBbXTtcbiAgICBlYWNoKHVwTWdyTGlzdCwgZnVuY3Rpb24gKHVwTWdyKSB7XG4gICAgICB1cE1nci5wcmVwYXJlU291cmNlKCk7XG4gICAgICB2YXIgdXBTb3VyY2UgPSB1cE1nci5nZXRTb3VyY2UoZnJvbVRyYW5zZm9ybVJlc3VsdCB8fCAwKTtcbiAgICAgIHZhciBlcnJNc2cgPSAnJztcbiAgICAgIGlmIChmcm9tVHJhbnNmb3JtUmVzdWx0ICE9IG51bGwgJiYgIXVwU291cmNlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgZXJyTXNnID0gJ0NhbiBub3QgcmV0cmlldmUgcmVzdWx0IGJ5IGBmcm9tVHJhbnNmb3JtUmVzdWx0YDogJyArIGZyb21UcmFuc2Zvcm1SZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZG9UaHJvdyhlcnJNc2cpO1xuICAgICAgfVxuICAgICAgdXBTb3VyY2VMaXN0LnB1c2godXBTb3VyY2UpO1xuICAgICAgdXBzdHJlYW1TaWduTGlzdC5wdXNoKHVwTWdyLl9nZXRWZXJzaW9uU2lnbigpKTtcbiAgICB9KTtcbiAgICBpZiAodHJhbnNmb3JtT3B0aW9uKSB7XG4gICAgICBzb3VyY2VMaXN0ID0gYXBwbHlEYXRhVHJhbnNmb3JtKHRyYW5zZm9ybU9wdGlvbiwgdXBTb3VyY2VMaXN0LCB7XG4gICAgICAgIGRhdGFzZXRJbmRleDogZGF0YXNldE1vZGVsLmNvbXBvbmVudEluZGV4XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGZyb21UcmFuc2Zvcm1SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgc291cmNlTGlzdCA9IFtjbG9uZVNvdXJjZVNoYWxsb3codXBTb3VyY2VMaXN0WzBdKV07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2VMaXN0OiBzb3VyY2VMaXN0LFxuICAgICAgdXBzdHJlYW1TaWduTGlzdDogdXBzdHJlYW1TaWduTGlzdFxuICAgIH07XG4gIH07XG4gIFNvdXJjZU1hbmFnZXIucHJvdG90eXBlLl9pc0RpcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIEFsbCBzb3VyY2VMaXN0IGlzIGZyb20gdGhlIHNvbWUgdXBzdHJlYW0uXG4gICAgdmFyIHVwU291cmNlTWdyTGlzdCA9IHRoaXMuX2dldFVwc3RyZWFtU291cmNlTWFuYWdlcnMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwU291cmNlTWdyTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHVwU3JjTWdyID0gdXBTb3VyY2VNZ3JMaXN0W2ldO1xuICAgICAgaWYgKFxuICAgICAgLy8gQ29uc2lkZXIgdGhlIGNhc2UgdGhhdCB0aGVyZSBpcyBhbmNlc3RvciBkaXJ5LCBjYWxsIGl0IHJlY3Vyc2l2ZWx5LlxuICAgICAgLy8gVGhlIHBlcmZvcm1hbmNlIGlzIHByb2JhYmx5IG5vdCBhbiBpc3N1ZSBiZWNhdXNlIHVzdWFsbHkgdGhlIGNoYWluIGlzIG5vdCBsb25nLlxuICAgICAgdXBTcmNNZ3IuX2lzRGlydHkoKSB8fCB0aGlzLl91cHN0cmVhbVNpZ25MaXN0W2ldICE9PSB1cFNyY01nci5fZ2V0VmVyc2lvblNpZ24oKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwYXJhbSBzb3VyY2VJbmRleCBCeSBkZWZhdWx0IDAsIG1lYW5zIFwibWFpbiBzb3VyY2VcIi5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgSW4gbW9zdCBjYXNlcyB0aGVyZSBpcyBvbmx5IG9uZSBzb3VyY2UuXHJcbiAgICovXG4gIFNvdXJjZU1hbmFnZXIucHJvdG90eXBlLmdldFNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2VJbmRleCkge1xuICAgIHNvdXJjZUluZGV4ID0gc291cmNlSW5kZXggfHwgMDtcbiAgICB2YXIgc291cmNlID0gdGhpcy5fc291cmNlTGlzdFtzb3VyY2VJbmRleF07XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIC8vIFNlcmllcyBtYXkgc2hhcmUgc291cmNlIGluc3RhbmNlIHdpdGggZGF0YXNldC5cbiAgICAgIHZhciB1cFNvdXJjZU1nckxpc3QgPSB0aGlzLl9nZXRVcHN0cmVhbVNvdXJjZU1hbmFnZXJzKCk7XG4gICAgICByZXR1cm4gdXBTb3VyY2VNZ3JMaXN0WzBdICYmIHVwU291cmNlTWdyTGlzdFswXS5nZXRTb3VyY2Uoc291cmNlSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9O1xuICAvKipcclxuICAgKlxyXG4gICAqIEdldCBhIGRhdGEgc3RvcmUgd2hpY2ggY2FuIGJlIHNoYXJlZCBhY3Jvc3Mgc2VyaWVzLlxyXG4gICAqIE9ubHkgYXZhaWxhYmxlIGZvciBzZXJpZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc2VyaWVzRGltUmVxdWVzdCBEaW1lbnNpb25zIHRoYXQgYXJlIGdlbmVyYXRlZCBpbiBzZXJpZXMuXHJcbiAgICogICAgICAgIFNob3VsZCBoYXZlIGJlZW4gc29ydGVkIGJ5IGBzdG9yZURpbUluZGV4YCBhc2MuXHJcbiAgICovXG4gIFNvdXJjZU1hbmFnZXIucHJvdG90eXBlLmdldFNoYXJlZERhdGFTdG9yZSA9IGZ1bmN0aW9uIChzZXJpZXNEaW1SZXF1ZXN0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChpc1Nlcmllcyh0aGlzLl9zb3VyY2VIb3N0KSwgJ0NhbiBvbmx5IGNhbGwgZ2V0RGF0YVN0b3JlIG9uIHNlcmllcyBzb3VyY2UgbWFuYWdlci4nKTtcbiAgICB9XG4gICAgdmFyIHNjaGVtYSA9IHNlcmllc0RpbVJlcXVlc3QubWFrZVN0b3JlU2NoZW1hKCk7XG4gICAgcmV0dXJuIHRoaXMuX2lubmVyR2V0RGF0YVN0b3JlKHNjaGVtYS5kaW1lbnNpb25zLCBzZXJpZXNEaW1SZXF1ZXN0LnNvdXJjZSwgc2NoZW1hLmhhc2gpO1xuICB9O1xuICBTb3VyY2VNYW5hZ2VyLnByb3RvdHlwZS5faW5uZXJHZXREYXRhU3RvcmUgPSBmdW5jdGlvbiAoc3RvcmVEaW1zLCBzZXJpZXNTb3VyY2UsIHNvdXJjZVJlYWRLZXkpIHtcbiAgICAvLyBUT0RPIENhbiB1c2Ugb3RoZXIgc291cmNlSW5kZXg/XG4gICAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgICB2YXIgc3RvcmVMaXN0ID0gdGhpcy5fc3RvcmVMaXN0O1xuICAgIHZhciBjYWNoZWRTdG9yZU1hcCA9IHN0b3JlTGlzdFtzb3VyY2VJbmRleF07XG4gICAgaWYgKCFjYWNoZWRTdG9yZU1hcCkge1xuICAgICAgY2FjaGVkU3RvcmVNYXAgPSBzdG9yZUxpc3Rbc291cmNlSW5kZXhdID0ge307XG4gICAgfVxuICAgIHZhciBjYWNoZWRTdG9yZSA9IGNhY2hlZFN0b3JlTWFwW3NvdXJjZVJlYWRLZXldO1xuICAgIGlmICghY2FjaGVkU3RvcmUpIHtcbiAgICAgIHZhciB1cFNvdXJjZU1nciA9IHRoaXMuX2dldFVwc3RyZWFtU291cmNlTWFuYWdlcnMoKVswXTtcbiAgICAgIGlmIChpc1Nlcmllcyh0aGlzLl9zb3VyY2VIb3N0KSAmJiB1cFNvdXJjZU1ncikge1xuICAgICAgICBjYWNoZWRTdG9yZSA9IHVwU291cmNlTWdyLl9pbm5lckdldERhdGFTdG9yZShzdG9yZURpbXMsIHNlcmllc1NvdXJjZSwgc291cmNlUmVhZEtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZWRTdG9yZSA9IG5ldyBEYXRhU3RvcmUoKTtcbiAgICAgICAgLy8gQWx3YXlzIGNyZWF0ZSBzdG9yZSBmcm9tIHNvdXJjZSBvZiBzZXJpZXMuXG4gICAgICAgIGNhY2hlZFN0b3JlLmluaXREYXRhKG5ldyBEZWZhdWx0RGF0YVByb3ZpZGVyKHNlcmllc1NvdXJjZSwgc3RvcmVEaW1zLmxlbmd0aCksIHN0b3JlRGltcyk7XG4gICAgICB9XG4gICAgICBjYWNoZWRTdG9yZU1hcFtzb3VyY2VSZWFkS2V5XSA9IGNhY2hlZFN0b3JlO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkU3RvcmU7XG4gIH07XG4gIC8qKlxyXG4gICAqIFBFTkRJTkc6IElzIGl0IGZhc3QgZW5vdWdoP1xyXG4gICAqIElmIG5vIHVwc3RyZWFtLCByZXR1cm4gZW1wdHkgYXJyYXkuXHJcbiAgICovXG4gIFNvdXJjZU1hbmFnZXIucHJvdG90eXBlLl9nZXRVcHN0cmVhbVNvdXJjZU1hbmFnZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEFsd2F5cyBnZXQgdGhlIHJlbGF0aW9uc2hpcCBmcm9tIHRoZSByYXcgb3B0aW9uLlxuICAgIC8vIERvIG5vdCBjYWNoZSB0aGUgbGluayBvZiB0aGUgZGVwZW5kZW5jeSBncmFwaCwgc28gdGhhdFxuICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gdXBkYXRlIHRoZW0gd2hlbiBjaGFuZ2UgaGFwcGVucy5cbiAgICB2YXIgc291cmNlSG9zdCA9IHRoaXMuX3NvdXJjZUhvc3Q7XG4gICAgaWYgKGlzU2VyaWVzKHNvdXJjZUhvc3QpKSB7XG4gICAgICB2YXIgZGF0YXNldE1vZGVsID0gcXVlcnlTZXJpZXNVcHN0cmVhbURhdGFzZXRNb2RlbChzb3VyY2VIb3N0KTtcbiAgICAgIHJldHVybiAhZGF0YXNldE1vZGVsID8gW10gOiBbZGF0YXNldE1vZGVsLmdldFNvdXJjZU1hbmFnZXIoKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYXAocXVlcnlEYXRhc2V0VXBzdHJlYW1EYXRhc2V0TW9kZWxzKHNvdXJjZUhvc3QpLCBmdW5jdGlvbiAoZGF0YXNldE1vZGVsKSB7XG4gICAgICAgIHJldHVybiBkYXRhc2V0TW9kZWwuZ2V0U291cmNlTWFuYWdlcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBTb3VyY2VNYW5hZ2VyLnByb3RvdHlwZS5fZ2V0U291cmNlTWV0YVJhd09wdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlSG9zdCA9IHRoaXMuX3NvdXJjZUhvc3Q7XG4gICAgdmFyIHNlcmllc0xheW91dEJ5O1xuICAgIHZhciBzb3VyY2VIZWFkZXI7XG4gICAgdmFyIGRpbWVuc2lvbnM7XG4gICAgaWYgKGlzU2VyaWVzKHNvdXJjZUhvc3QpKSB7XG4gICAgICBzZXJpZXNMYXlvdXRCeSA9IHNvdXJjZUhvc3QuZ2V0KCdzZXJpZXNMYXlvdXRCeScsIHRydWUpO1xuICAgICAgc291cmNlSGVhZGVyID0gc291cmNlSG9zdC5nZXQoJ3NvdXJjZUhlYWRlcicsIHRydWUpO1xuICAgICAgZGltZW5zaW9ucyA9IHNvdXJjZUhvc3QuZ2V0KCdkaW1lbnNpb25zJywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIFNlZSBbUkVRVUlSRU1FTlRfTUVNT10sIGBub24tcm9vdC1kYXRhc2V0YCBkbyBub3Qgc3VwcG9ydCB0aGVtLlxuICAgIGVsc2UgaWYgKCF0aGlzLl9nZXRVcHN0cmVhbVNvdXJjZU1hbmFnZXJzKCkubGVuZ3RoKSB7XG4gICAgICB2YXIgbW9kZWwgPSBzb3VyY2VIb3N0O1xuICAgICAgc2VyaWVzTGF5b3V0QnkgPSBtb2RlbC5nZXQoJ3Nlcmllc0xheW91dEJ5JywgdHJ1ZSk7XG4gICAgICBzb3VyY2VIZWFkZXIgPSBtb2RlbC5nZXQoJ3NvdXJjZUhlYWRlcicsIHRydWUpO1xuICAgICAgZGltZW5zaW9ucyA9IG1vZGVsLmdldCgnZGltZW5zaW9ucycsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2VyaWVzTGF5b3V0Qnk6IHNlcmllc0xheW91dEJ5LFxuICAgICAgc291cmNlSGVhZGVyOiBzb3VyY2VIZWFkZXIsXG4gICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIFNvdXJjZU1hbmFnZXI7XG59KCk7XG5leHBvcnQgeyBTb3VyY2VNYW5hZ2VyIH07XG4vLyBDYWxsIHRoaXMgbWV0aG9kIGFmdGVyIGBzdXBlci5pbml0YCBhbmQgYHN1cGVyLm1lcmdlT3B0aW9uYCB0b1xuLy8gZGlzYWJsZSB0aGUgdHJhbnNmb3JtIG1lcmdlLCBidXQgZG8gbm90IGRpc2FibGUgdHJhbnNmb3JtIGNsb25lIGZyb20gcmF3T3B0aW9uLlxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVUcmFuc2Zvcm1PcHRpb25NZXJnZShkYXRhc2V0TW9kZWwpIHtcbiAgdmFyIHRyYW5zZm9ybU9wdGlvbiA9IGRhdGFzZXRNb2RlbC5vcHRpb24udHJhbnNmb3JtO1xuICB0cmFuc2Zvcm1PcHRpb24gJiYgc2V0QXNQcmltaXRpdmUoZGF0YXNldE1vZGVsLm9wdGlvbi50cmFuc2Zvcm0pO1xufVxuZnVuY3Rpb24gaXNTZXJpZXMoc291cmNlSG9zdCkge1xuICAvLyBBdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IHdpdGggU2VyaWVzLnRzXG4gIHJldHVybiBzb3VyY2VIb3N0Lm1haW5UeXBlID09PSAnc2VyaWVzJztcbn1cbmZ1bmN0aW9uIGRvVGhyb3coZXJyTXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///40972\n")},50451:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony exports GraphNode, GraphEdge */\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n// id may be function name of Object, add a prefix to avoid this problem.\nfunction generateNodeKey(id) {\n  return '_EC_' + id;\n}\nvar Graph = /** @class */function () {\n  function Graph(directed) {\n    this.type = 'graph';\n    this.nodes = [];\n    this.edges = [];\n    this._nodesMap = {};\n    /**\r\n     * @type {Object.<string, module:echarts/data/Graph.Edge>}\r\n     * @private\r\n     */\n    this._edgesMap = {};\n    this._directed = directed || false;\n  }\n  /**\r\n   * If is directed graph\r\n   */\n  Graph.prototype.isDirected = function () {\n    return this._directed;\n  };\n  ;\n  /**\r\n   * Add a new node\r\n   */\n  Graph.prototype.addNode = function (id, dataIndex) {\n    id = id == null ? '' + dataIndex : '' + id;\n    var nodesMap = this._nodesMap;\n    if (nodesMap[generateNodeKey(id)]) {\n      if (false) {}\n      return;\n    }\n    var node = new GraphNode(id, dataIndex);\n    node.hostGraph = this;\n    this.nodes.push(node);\n    nodesMap[generateNodeKey(id)] = node;\n    return node;\n  };\n  ;\n  /**\r\n   * Get node by data index\r\n   */\n  Graph.prototype.getNodeByIndex = function (dataIndex) {\n    var rawIdx = this.data.getRawIndex(dataIndex);\n    return this.nodes[rawIdx];\n  };\n  ;\n  /**\r\n   * Get node by id\r\n   */\n  Graph.prototype.getNodeById = function (id) {\n    return this._nodesMap[generateNodeKey(id)];\n  };\n  ;\n  /**\r\n   * Add a new edge\r\n   */\n  Graph.prototype.addEdge = function (n1, n2, dataIndex) {\n    var nodesMap = this._nodesMap;\n    var edgesMap = this._edgesMap;\n    // PENDING\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(n1)) {\n      n1 = this.nodes[n1];\n    }\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isNumber(n2)) {\n      n2 = this.nodes[n2];\n    }\n    if (!(n1 instanceof GraphNode)) {\n      n1 = nodesMap[generateNodeKey(n1)];\n    }\n    if (!(n2 instanceof GraphNode)) {\n      n2 = nodesMap[generateNodeKey(n2)];\n    }\n    if (!n1 || !n2) {\n      return;\n    }\n    var key = n1.id + '-' + n2.id;\n    var edge = new GraphEdge(n1, n2, dataIndex);\n    edge.hostGraph = this;\n    if (this._directed) {\n      n1.outEdges.push(edge);\n      n2.inEdges.push(edge);\n    }\n    n1.edges.push(edge);\n    if (n1 !== n2) {\n      n2.edges.push(edge);\n    }\n    this.edges.push(edge);\n    edgesMap[key] = edge;\n    return edge;\n  };\n  ;\n  /**\r\n   * Get edge by data index\r\n   */\n  Graph.prototype.getEdgeByIndex = function (dataIndex) {\n    var rawIdx = this.edgeData.getRawIndex(dataIndex);\n    return this.edges[rawIdx];\n  };\n  ;\n  /**\r\n   * Get edge by two linked nodes\r\n   */\n  Graph.prototype.getEdge = function (n1, n2) {\n    if (n1 instanceof GraphNode) {\n      n1 = n1.id;\n    }\n    if (n2 instanceof GraphNode) {\n      n2 = n2.id;\n    }\n    var edgesMap = this._edgesMap;\n    if (this._directed) {\n      return edgesMap[n1 + '-' + n2];\n    } else {\n      return edgesMap[n1 + '-' + n2] || edgesMap[n2 + '-' + n1];\n    }\n  };\n  ;\n  /**\r\n   * Iterate all nodes\r\n   */\n  Graph.prototype.eachNode = function (cb, context) {\n    var nodes = this.nodes;\n    var len = nodes.length;\n    for (var i = 0; i < len; i++) {\n      if (nodes[i].dataIndex >= 0) {\n        cb.call(context, nodes[i], i);\n      }\n    }\n  };\n  ;\n  /**\r\n   * Iterate all edges\r\n   */\n  Graph.prototype.eachEdge = function (cb, context) {\n    var edges = this.edges;\n    var len = edges.length;\n    for (var i = 0; i < len; i++) {\n      if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {\n        cb.call(context, edges[i], i);\n      }\n    }\n  };\n  ;\n  /**\r\n   * Breadth first traverse\r\n   * Return true to stop traversing\r\n   */\n  Graph.prototype.breadthFirstTraverse = function (cb, startNode, direction, context) {\n    if (!(startNode instanceof GraphNode)) {\n      startNode = this._nodesMap[generateNodeKey(startNode)];\n    }\n    if (!startNode) {\n      return;\n    }\n    var edgeType = direction === 'out' ? 'outEdges' : direction === 'in' ? 'inEdges' : 'edges';\n    for (var i = 0; i < this.nodes.length; i++) {\n      this.nodes[i].__visited = false;\n    }\n    if (cb.call(context, startNode, null)) {\n      return;\n    }\n    var queue = [startNode];\n    while (queue.length) {\n      var currentNode = queue.shift();\n      var edges = currentNode[edgeType];\n      for (var i = 0; i < edges.length; i++) {\n        var e = edges[i];\n        var otherNode = e.node1 === currentNode ? e.node2 : e.node1;\n        if (!otherNode.__visited) {\n          if (cb.call(context, otherNode, currentNode)) {\n            // Stop traversing\n            return;\n          }\n          queue.push(otherNode);\n          otherNode.__visited = true;\n        }\n      }\n    }\n  };\n  ;\n  // TODO\n  // depthFirstTraverse(\n  //     cb, startNode, direction, context\n  // ) {\n  // };\n  // Filter update\n  Graph.prototype.update = function () {\n    var data = this.data;\n    var edgeData = this.edgeData;\n    var nodes = this.nodes;\n    var edges = this.edges;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].dataIndex = -1;\n    }\n    for (var i = 0, len = data.count(); i < len; i++) {\n      nodes[data.getRawIndex(i)].dataIndex = i;\n    }\n    edgeData.filterSelf(function (idx) {\n      var edge = edges[edgeData.getRawIndex(idx)];\n      return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;\n    });\n    // Update edge\n    for (var i = 0, len = edges.length; i < len; i++) {\n      edges[i].dataIndex = -1;\n    }\n    for (var i = 0, len = edgeData.count(); i < len; i++) {\n      edges[edgeData.getRawIndex(i)].dataIndex = i;\n    }\n  };\n  ;\n  /**\r\n   * @return {module:echarts/data/Graph}\r\n   */\n  Graph.prototype.clone = function () {\n    var graph = new Graph(this._directed);\n    var nodes = this.nodes;\n    var edges = this.edges;\n    for (var i = 0; i < nodes.length; i++) {\n      graph.addNode(nodes[i].id, nodes[i].dataIndex);\n    }\n    for (var i = 0; i < edges.length; i++) {\n      var e = edges[i];\n      graph.addEdge(e.node1.id, e.node2.id, e.dataIndex);\n    }\n    return graph;\n  };\n  ;\n  return Graph;\n}();\nvar GraphNode = /** @class */function () {\n  function GraphNode(id, dataIndex) {\n    this.inEdges = [];\n    this.outEdges = [];\n    this.edges = [];\n    this.dataIndex = -1;\n    this.id = id == null ? '' : id;\n    this.dataIndex = dataIndex == null ? -1 : dataIndex;\n  }\n  /**\r\n   * @return {number}\r\n   */\n  GraphNode.prototype.degree = function () {\n    return this.edges.length;\n  };\n  /**\r\n   * @return {number}\r\n   */\n  GraphNode.prototype.inDegree = function () {\n    return this.inEdges.length;\n  };\n  /**\r\n  * @return {number}\r\n  */\n  GraphNode.prototype.outDegree = function () {\n    return this.outEdges.length;\n  };\n  GraphNode.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n    var graph = this.hostGraph;\n    var itemModel = graph.data.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  };\n  GraphNode.prototype.getAdjacentDataIndices = function () {\n    var dataIndices = {\n      edge: [],\n      node: []\n    };\n    for (var i = 0; i < this.edges.length; i++) {\n      var adjacentEdge = this.edges[i];\n      if (adjacentEdge.dataIndex < 0) {\n        continue;\n      }\n      dataIndices.edge.push(adjacentEdge.dataIndex);\n      dataIndices.node.push(adjacentEdge.node1.dataIndex, adjacentEdge.node2.dataIndex);\n    }\n    return dataIndices;\n  };\n  GraphNode.prototype.getTrajectoryDataIndices = function () {\n    var connectedEdgesMap = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap();\n    var connectedNodesMap = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap();\n    for (var i = 0; i < this.edges.length; i++) {\n      var adjacentEdge = this.edges[i];\n      if (adjacentEdge.dataIndex < 0) {\n        continue;\n      }\n      connectedEdgesMap.set(adjacentEdge.dataIndex, true);\n      var sourceNodesQueue = [adjacentEdge.node1];\n      var targetNodesQueue = [adjacentEdge.node2];\n      var nodeIteratorIndex = 0;\n      while (nodeIteratorIndex < sourceNodesQueue.length) {\n        var sourceNode = sourceNodesQueue[nodeIteratorIndex];\n        nodeIteratorIndex++;\n        connectedNodesMap.set(sourceNode.dataIndex, true);\n        for (var j = 0; j < sourceNode.inEdges.length; j++) {\n          connectedEdgesMap.set(sourceNode.inEdges[j].dataIndex, true);\n          sourceNodesQueue.push(sourceNode.inEdges[j].node1);\n        }\n      }\n      nodeIteratorIndex = 0;\n      while (nodeIteratorIndex < targetNodesQueue.length) {\n        var targetNode = targetNodesQueue[nodeIteratorIndex];\n        nodeIteratorIndex++;\n        connectedNodesMap.set(targetNode.dataIndex, true);\n        for (var j = 0; j < targetNode.outEdges.length; j++) {\n          connectedEdgesMap.set(targetNode.outEdges[j].dataIndex, true);\n          targetNodesQueue.push(targetNode.outEdges[j].node2);\n        }\n      }\n    }\n    return {\n      edge: connectedEdgesMap.keys(),\n      node: connectedNodesMap.keys()\n    };\n  };\n  return GraphNode;\n}();\nvar GraphEdge = /** @class */function () {\n  function GraphEdge(n1, n2, dataIndex) {\n    this.dataIndex = -1;\n    this.node1 = n1;\n    this.node2 = n2;\n    this.dataIndex = dataIndex == null ? -1 : dataIndex;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  GraphEdge.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n    var graph = this.hostGraph;\n    var itemModel = graph.edgeData.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  };\n  GraphEdge.prototype.getAdjacentDataIndices = function () {\n    return {\n      edge: [this.dataIndex],\n      node: [this.node1.dataIndex, this.node2.dataIndex]\n    };\n  };\n  GraphEdge.prototype.getTrajectoryDataIndices = function () {\n    var connectedEdgesMap = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap();\n    var connectedNodesMap = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.createHashMap();\n    connectedEdgesMap.set(this.dataIndex, true);\n    var sourceNodes = [this.node1];\n    var targetNodes = [this.node2];\n    var nodeIteratorIndex = 0;\n    while (nodeIteratorIndex < sourceNodes.length) {\n      var sourceNode = sourceNodes[nodeIteratorIndex];\n      nodeIteratorIndex++;\n      connectedNodesMap.set(sourceNode.dataIndex, true);\n      for (var j = 0; j < sourceNode.inEdges.length; j++) {\n        connectedEdgesMap.set(sourceNode.inEdges[j].dataIndex, true);\n        sourceNodes.push(sourceNode.inEdges[j].node1);\n      }\n    }\n    nodeIteratorIndex = 0;\n    while (nodeIteratorIndex < targetNodes.length) {\n      var targetNode = targetNodes[nodeIteratorIndex];\n      nodeIteratorIndex++;\n      connectedNodesMap.set(targetNode.dataIndex, true);\n      for (var j = 0; j < targetNode.outEdges.length; j++) {\n        connectedEdgesMap.set(targetNode.outEdges[j].dataIndex, true);\n        targetNodes.push(targetNode.outEdges[j].node2);\n      }\n    }\n    return {\n      edge: connectedEdgesMap.keys(),\n      node: connectedNodesMap.keys()\n    };\n  };\n  return GraphEdge;\n}();\nfunction createGraphDataProxyMixin(hostName, dataName) {\n  return {\n    /**\r\n     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.\r\n     */\n    getValue: function (dimension) {\n      var data = this[hostName][dataName];\n      return data.getStore().get(data.getDimensionIndex(dimension || 'value'), this.dataIndex);\n    },\n    // TODO: TYPE stricter type.\n    setVisual: function (key, value) {\n      this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);\n    },\n    getVisual: function (key) {\n      return this[hostName][dataName].getItemVisual(this.dataIndex, key);\n    },\n    setLayout: function (layout, merge) {\n      this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge);\n    },\n    getLayout: function () {\n      return this[hostName][dataName].getItemLayout(this.dataIndex);\n    },\n    getGraphicEl: function () {\n      return this[hostName][dataName].getItemGraphicEl(this.dataIndex);\n    },\n    getRawIndex: function () {\n      return this[hostName][dataName].getRawIndex(this.dataIndex);\n    }\n  };\n}\n;\n;\n;\nzrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.mixin(GraphNode, createGraphDataProxyMixin('hostGraph', 'data'));\nzrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.mixin(GraphEdge, createGraphDataProxyMixin('hostGraph', 'edgeData'));\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Graph);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA0NTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9HcmFwaC5qcz80MWUyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG4vLyBpZCBtYXkgYmUgZnVuY3Rpb24gbmFtZSBvZiBPYmplY3QsIGFkZCBhIHByZWZpeCB0byBhdm9pZCB0aGlzIHByb2JsZW0uXG5mdW5jdGlvbiBnZW5lcmF0ZU5vZGVLZXkoaWQpIHtcbiAgcmV0dXJuICdfRUNfJyArIGlkO1xufVxudmFyIEdyYXBoID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR3JhcGgoZGlyZWN0ZWQpIHtcbiAgICB0aGlzLnR5cGUgPSAnZ3JhcGgnO1xuICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB0aGlzLmVkZ2VzID0gW107XG4gICAgdGhpcy5fbm9kZXNNYXAgPSB7fTtcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvZGF0YS9HcmFwaC5FZGdlPn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cbiAgICB0aGlzLl9lZGdlc01hcCA9IHt9O1xuICAgIHRoaXMuX2RpcmVjdGVkID0gZGlyZWN0ZWQgfHwgZmFsc2U7XG4gIH1cbiAgLyoqXHJcbiAgICogSWYgaXMgZGlyZWN0ZWQgZ3JhcGhcclxuICAgKi9cbiAgR3JhcGgucHJvdG90eXBlLmlzRGlyZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcmVjdGVkO1xuICB9O1xuICA7XG4gIC8qKlxyXG4gICAqIEFkZCBhIG5ldyBub2RlXHJcbiAgICovXG4gIEdyYXBoLnByb3RvdHlwZS5hZGROb2RlID0gZnVuY3Rpb24gKGlkLCBkYXRhSW5kZXgpIHtcbiAgICBpZCA9IGlkID09IG51bGwgPyAnJyArIGRhdGFJbmRleCA6ICcnICsgaWQ7XG4gICAgdmFyIG5vZGVzTWFwID0gdGhpcy5fbm9kZXNNYXA7XG4gICAgaWYgKG5vZGVzTWFwW2dlbmVyYXRlTm9kZUtleShpZCldKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdHcmFwaCBub2RlcyBoYXZlIGR1cGxpY2F0ZSBuYW1lIG9yIGlkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub2RlID0gbmV3IEdyYXBoTm9kZShpZCwgZGF0YUluZGV4KTtcbiAgICBub2RlLmhvc3RHcmFwaCA9IHRoaXM7XG4gICAgdGhpcy5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIG5vZGVzTWFwW2dlbmVyYXRlTm9kZUtleShpZCldID0gbm9kZTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbiAgO1xuICAvKipcclxuICAgKiBHZXQgbm9kZSBieSBkYXRhIGluZGV4XHJcbiAgICovXG4gIEdyYXBoLnByb3RvdHlwZS5nZXROb2RlQnlJbmRleCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICB2YXIgcmF3SWR4ID0gdGhpcy5kYXRhLmdldFJhd0luZGV4KGRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNbcmF3SWR4XTtcbiAgfTtcbiAgO1xuICAvKipcclxuICAgKiBHZXQgbm9kZSBieSBpZFxyXG4gICAqL1xuICBHcmFwaC5wcm90b3R5cGUuZ2V0Tm9kZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXNNYXBbZ2VuZXJhdGVOb2RlS2V5KGlkKV07XG4gIH07XG4gIDtcbiAgLyoqXHJcbiAgICogQWRkIGEgbmV3IGVkZ2VcclxuICAgKi9cbiAgR3JhcGgucHJvdG90eXBlLmFkZEVkZ2UgPSBmdW5jdGlvbiAobjEsIG4yLCBkYXRhSW5kZXgpIHtcbiAgICB2YXIgbm9kZXNNYXAgPSB0aGlzLl9ub2Rlc01hcDtcbiAgICB2YXIgZWRnZXNNYXAgPSB0aGlzLl9lZGdlc01hcDtcbiAgICAvLyBQRU5ESU5HXG4gICAgaWYgKHpyVXRpbC5pc051bWJlcihuMSkpIHtcbiAgICAgIG4xID0gdGhpcy5ub2Rlc1tuMV07XG4gICAgfVxuICAgIGlmICh6clV0aWwuaXNOdW1iZXIobjIpKSB7XG4gICAgICBuMiA9IHRoaXMubm9kZXNbbjJdO1xuICAgIH1cbiAgICBpZiAoIShuMSBpbnN0YW5jZW9mIEdyYXBoTm9kZSkpIHtcbiAgICAgIG4xID0gbm9kZXNNYXBbZ2VuZXJhdGVOb2RlS2V5KG4xKV07XG4gICAgfVxuICAgIGlmICghKG4yIGluc3RhbmNlb2YgR3JhcGhOb2RlKSkge1xuICAgICAgbjIgPSBub2Rlc01hcFtnZW5lcmF0ZU5vZGVLZXkobjIpXTtcbiAgICB9XG4gICAgaWYgKCFuMSB8fCAhbjIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGtleSA9IG4xLmlkICsgJy0nICsgbjIuaWQ7XG4gICAgdmFyIGVkZ2UgPSBuZXcgR3JhcGhFZGdlKG4xLCBuMiwgZGF0YUluZGV4KTtcbiAgICBlZGdlLmhvc3RHcmFwaCA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX2RpcmVjdGVkKSB7XG4gICAgICBuMS5vdXRFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgbjIuaW5FZGdlcy5wdXNoKGVkZ2UpO1xuICAgIH1cbiAgICBuMS5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgIGlmIChuMSAhPT0gbjIpIHtcbiAgICAgIG4yLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgfVxuICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcbiAgICBlZGdlc01hcFtrZXldID0gZWRnZTtcbiAgICByZXR1cm4gZWRnZTtcbiAgfTtcbiAgO1xuICAvKipcclxuICAgKiBHZXQgZWRnZSBieSBkYXRhIGluZGV4XHJcbiAgICovXG4gIEdyYXBoLnByb3RvdHlwZS5nZXRFZGdlQnlJbmRleCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICB2YXIgcmF3SWR4ID0gdGhpcy5lZGdlRGF0YS5nZXRSYXdJbmRleChkYXRhSW5kZXgpO1xuICAgIHJldHVybiB0aGlzLmVkZ2VzW3Jhd0lkeF07XG4gIH07XG4gIDtcbiAgLyoqXHJcbiAgICogR2V0IGVkZ2UgYnkgdHdvIGxpbmtlZCBub2Rlc1xyXG4gICAqL1xuICBHcmFwaC5wcm90b3R5cGUuZ2V0RWRnZSA9IGZ1bmN0aW9uIChuMSwgbjIpIHtcbiAgICBpZiAobjEgaW5zdGFuY2VvZiBHcmFwaE5vZGUpIHtcbiAgICAgIG4xID0gbjEuaWQ7XG4gICAgfVxuICAgIGlmIChuMiBpbnN0YW5jZW9mIEdyYXBoTm9kZSkge1xuICAgICAgbjIgPSBuMi5pZDtcbiAgICB9XG4gICAgdmFyIGVkZ2VzTWFwID0gdGhpcy5fZWRnZXNNYXA7XG4gICAgaWYgKHRoaXMuX2RpcmVjdGVkKSB7XG4gICAgICByZXR1cm4gZWRnZXNNYXBbbjEgKyAnLScgKyBuMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlZGdlc01hcFtuMSArICctJyArIG4yXSB8fCBlZGdlc01hcFtuMiArICctJyArIG4xXTtcbiAgICB9XG4gIH07XG4gIDtcbiAgLyoqXHJcbiAgICogSXRlcmF0ZSBhbGwgbm9kZXNcclxuICAgKi9cbiAgR3JhcGgucHJvdG90eXBlLmVhY2hOb2RlID0gZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICB2YXIgbGVuID0gbm9kZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChub2Rlc1tpXS5kYXRhSW5kZXggPj0gMCkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIG5vZGVzW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIDtcbiAgLyoqXHJcbiAgICogSXRlcmF0ZSBhbGwgZWRnZXNcclxuICAgKi9cbiAgR3JhcGgucHJvdG90eXBlLmVhY2hFZGdlID0gZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcztcbiAgICB2YXIgbGVuID0gZWRnZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChlZGdlc1tpXS5kYXRhSW5kZXggPj0gMCAmJiBlZGdlc1tpXS5ub2RlMS5kYXRhSW5kZXggPj0gMCAmJiBlZGdlc1tpXS5ub2RlMi5kYXRhSW5kZXggPj0gMCkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGVkZ2VzW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIDtcbiAgLyoqXHJcbiAgICogQnJlYWR0aCBmaXJzdCB0cmF2ZXJzZVxyXG4gICAqIFJldHVybiB0cnVlIHRvIHN0b3AgdHJhdmVyc2luZ1xyXG4gICAqL1xuICBHcmFwaC5wcm90b3R5cGUuYnJlYWR0aEZpcnN0VHJhdmVyc2UgPSBmdW5jdGlvbiAoY2IsIHN0YXJ0Tm9kZSwgZGlyZWN0aW9uLCBjb250ZXh0KSB7XG4gICAgaWYgKCEoc3RhcnROb2RlIGluc3RhbmNlb2YgR3JhcGhOb2RlKSkge1xuICAgICAgc3RhcnROb2RlID0gdGhpcy5fbm9kZXNNYXBbZ2VuZXJhdGVOb2RlS2V5KHN0YXJ0Tm9kZSldO1xuICAgIH1cbiAgICBpZiAoIXN0YXJ0Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZWRnZVR5cGUgPSBkaXJlY3Rpb24gPT09ICdvdXQnID8gJ291dEVkZ2VzJyA6IGRpcmVjdGlvbiA9PT0gJ2luJyA/ICdpbkVkZ2VzJyA6ICdlZGdlcyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLm5vZGVzW2ldLl9fdmlzaXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBzdGFydE5vZGUsIG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBxdWV1ZSA9IFtzdGFydE5vZGVdO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICB2YXIgZWRnZXMgPSBjdXJyZW50Tm9kZVtlZGdlVHlwZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgICAgIHZhciBvdGhlck5vZGUgPSBlLm5vZGUxID09PSBjdXJyZW50Tm9kZSA/IGUubm9kZTIgOiBlLm5vZGUxO1xuICAgICAgICBpZiAoIW90aGVyTm9kZS5fX3Zpc2l0ZWQpIHtcbiAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBvdGhlck5vZGUsIGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgLy8gU3RvcCB0cmF2ZXJzaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHF1ZXVlLnB1c2gob3RoZXJOb2RlKTtcbiAgICAgICAgICBvdGhlck5vZGUuX192aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgO1xuICAvLyBUT0RPXG4gIC8vIGRlcHRoRmlyc3RUcmF2ZXJzZShcbiAgLy8gICAgIGNiLCBzdGFydE5vZGUsIGRpcmVjdGlvbiwgY29udGV4dFxuICAvLyApIHtcbiAgLy8gfTtcbiAgLy8gRmlsdGVyIHVwZGF0ZVxuICBHcmFwaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBlZGdlRGF0YSA9IHRoaXMuZWRnZURhdGE7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbm9kZXNbaV0uZGF0YUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmNvdW50KCk7IGkgPCBsZW47IGkrKykge1xuICAgICAgbm9kZXNbZGF0YS5nZXRSYXdJbmRleChpKV0uZGF0YUluZGV4ID0gaTtcbiAgICB9XG4gICAgZWRnZURhdGEuZmlsdGVyU2VsZihmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VEYXRhLmdldFJhd0luZGV4KGlkeCldO1xuICAgICAgcmV0dXJuIGVkZ2Uubm9kZTEuZGF0YUluZGV4ID49IDAgJiYgZWRnZS5ub2RlMi5kYXRhSW5kZXggPj0gMDtcbiAgICB9KTtcbiAgICAvLyBVcGRhdGUgZWRnZVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlZGdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgZWRnZXNbaV0uZGF0YUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlZGdlRGF0YS5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGVkZ2VzW2VkZ2VEYXRhLmdldFJhd0luZGV4KGkpXS5kYXRhSW5kZXggPSBpO1xuICAgIH1cbiAgfTtcbiAgO1xuICAvKipcclxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0dyYXBofVxyXG4gICAqL1xuICBHcmFwaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdyYXBoID0gbmV3IEdyYXBoKHRoaXMuX2RpcmVjdGVkKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ3JhcGguYWRkTm9kZShub2Rlc1tpXS5pZCwgbm9kZXNbaV0uZGF0YUluZGV4KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGUgPSBlZGdlc1tpXTtcbiAgICAgIGdyYXBoLmFkZEVkZ2UoZS5ub2RlMS5pZCwgZS5ub2RlMi5pZCwgZS5kYXRhSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhcGg7XG4gIH07XG4gIDtcbiAgcmV0dXJuIEdyYXBoO1xufSgpO1xudmFyIEdyYXBoTm9kZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdyYXBoTm9kZShpZCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5pbkVkZ2VzID0gW107XG4gICAgdGhpcy5vdXRFZGdlcyA9IFtdO1xuICAgIHRoaXMuZWRnZXMgPSBbXTtcbiAgICB0aGlzLmRhdGFJbmRleCA9IC0xO1xuICAgIHRoaXMuaWQgPSBpZCA9PSBudWxsID8gJycgOiBpZDtcbiAgICB0aGlzLmRhdGFJbmRleCA9IGRhdGFJbmRleCA9PSBudWxsID8gLTEgOiBkYXRhSW5kZXg7XG4gIH1cbiAgLyoqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xuICBHcmFwaE5vZGUucHJvdG90eXBlLmRlZ3JlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlcy5sZW5ndGg7XG4gIH07XG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cbiAgR3JhcGhOb2RlLnByb3RvdHlwZS5pbkRlZ3JlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbkVkZ2VzLmxlbmd0aDtcbiAgfTtcbiAgLyoqXHJcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgKi9cbiAgR3JhcGhOb2RlLnByb3RvdHlwZS5vdXREZWdyZWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0RWRnZXMubGVuZ3RoO1xuICB9O1xuICBHcmFwaE5vZGUucHJvdG90eXBlLmdldE1vZGVsID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAodGhpcy5kYXRhSW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBncmFwaCA9IHRoaXMuaG9zdEdyYXBoO1xuICAgIHZhciBpdGVtTW9kZWwgPSBncmFwaC5kYXRhLmdldEl0ZW1Nb2RlbCh0aGlzLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIGl0ZW1Nb2RlbC5nZXRNb2RlbChwYXRoKTtcbiAgfTtcbiAgR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRBZGphY2VudERhdGFJbmRpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhSW5kaWNlcyA9IHtcbiAgICAgIGVkZ2U6IFtdLFxuICAgICAgbm9kZTogW11cbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFkamFjZW50RWRnZSA9IHRoaXMuZWRnZXNbaV07XG4gICAgICBpZiAoYWRqYWNlbnRFZGdlLmRhdGFJbmRleCA8IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBkYXRhSW5kaWNlcy5lZGdlLnB1c2goYWRqYWNlbnRFZGdlLmRhdGFJbmRleCk7XG4gICAgICBkYXRhSW5kaWNlcy5ub2RlLnB1c2goYWRqYWNlbnRFZGdlLm5vZGUxLmRhdGFJbmRleCwgYWRqYWNlbnRFZGdlLm5vZGUyLmRhdGFJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhSW5kaWNlcztcbiAgfTtcbiAgR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRUcmFqZWN0b3J5RGF0YUluZGljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbm5lY3RlZEVkZ2VzTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgICB2YXIgY29ubmVjdGVkTm9kZXNNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFkamFjZW50RWRnZSA9IHRoaXMuZWRnZXNbaV07XG4gICAgICBpZiAoYWRqYWNlbnRFZGdlLmRhdGFJbmRleCA8IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25uZWN0ZWRFZGdlc01hcC5zZXQoYWRqYWNlbnRFZGdlLmRhdGFJbmRleCwgdHJ1ZSk7XG4gICAgICB2YXIgc291cmNlTm9kZXNRdWV1ZSA9IFthZGphY2VudEVkZ2Uubm9kZTFdO1xuICAgICAgdmFyIHRhcmdldE5vZGVzUXVldWUgPSBbYWRqYWNlbnRFZGdlLm5vZGUyXTtcbiAgICAgIHZhciBub2RlSXRlcmF0b3JJbmRleCA9IDA7XG4gICAgICB3aGlsZSAobm9kZUl0ZXJhdG9ySW5kZXggPCBzb3VyY2VOb2Rlc1F1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgc291cmNlTm9kZSA9IHNvdXJjZU5vZGVzUXVldWVbbm9kZUl0ZXJhdG9ySW5kZXhdO1xuICAgICAgICBub2RlSXRlcmF0b3JJbmRleCsrO1xuICAgICAgICBjb25uZWN0ZWROb2Rlc01hcC5zZXQoc291cmNlTm9kZS5kYXRhSW5kZXgsIHRydWUpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNvdXJjZU5vZGUuaW5FZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbm5lY3RlZEVkZ2VzTWFwLnNldChzb3VyY2VOb2RlLmluRWRnZXNbal0uZGF0YUluZGV4LCB0cnVlKTtcbiAgICAgICAgICBzb3VyY2VOb2Rlc1F1ZXVlLnB1c2goc291cmNlTm9kZS5pbkVkZ2VzW2pdLm5vZGUxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZUl0ZXJhdG9ySW5kZXggPSAwO1xuICAgICAgd2hpbGUgKG5vZGVJdGVyYXRvckluZGV4IDwgdGFyZ2V0Tm9kZXNRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXROb2Rlc1F1ZXVlW25vZGVJdGVyYXRvckluZGV4XTtcbiAgICAgICAgbm9kZUl0ZXJhdG9ySW5kZXgrKztcbiAgICAgICAgY29ubmVjdGVkTm9kZXNNYXAuc2V0KHRhcmdldE5vZGUuZGF0YUluZGV4LCB0cnVlKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0YXJnZXROb2RlLm91dEVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29ubmVjdGVkRWRnZXNNYXAuc2V0KHRhcmdldE5vZGUub3V0RWRnZXNbal0uZGF0YUluZGV4LCB0cnVlKTtcbiAgICAgICAgICB0YXJnZXROb2Rlc1F1ZXVlLnB1c2godGFyZ2V0Tm9kZS5vdXRFZGdlc1tqXS5ub2RlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVkZ2U6IGNvbm5lY3RlZEVkZ2VzTWFwLmtleXMoKSxcbiAgICAgIG5vZGU6IGNvbm5lY3RlZE5vZGVzTWFwLmtleXMoKVxuICAgIH07XG4gIH07XG4gIHJldHVybiBHcmFwaE5vZGU7XG59KCk7XG52YXIgR3JhcGhFZGdlID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR3JhcGhFZGdlKG4xLCBuMiwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5kYXRhSW5kZXggPSAtMTtcbiAgICB0aGlzLm5vZGUxID0gbjE7XG4gICAgdGhpcy5ub2RlMiA9IG4yO1xuICAgIHRoaXMuZGF0YUluZGV4ID0gZGF0YUluZGV4ID09IG51bGwgPyAtMSA6IGRhdGFJbmRleDtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIEdyYXBoRWRnZS5wcm90b3R5cGUuZ2V0TW9kZWwgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmICh0aGlzLmRhdGFJbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGdyYXBoID0gdGhpcy5ob3N0R3JhcGg7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IGdyYXBoLmVkZ2VEYXRhLmdldEl0ZW1Nb2RlbCh0aGlzLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIGl0ZW1Nb2RlbC5nZXRNb2RlbChwYXRoKTtcbiAgfTtcbiAgR3JhcGhFZGdlLnByb3RvdHlwZS5nZXRBZGphY2VudERhdGFJbmRpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlZGdlOiBbdGhpcy5kYXRhSW5kZXhdLFxuICAgICAgbm9kZTogW3RoaXMubm9kZTEuZGF0YUluZGV4LCB0aGlzLm5vZGUyLmRhdGFJbmRleF1cbiAgICB9O1xuICB9O1xuICBHcmFwaEVkZ2UucHJvdG90eXBlLmdldFRyYWplY3RvcnlEYXRhSW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29ubmVjdGVkRWRnZXNNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICAgIHZhciBjb25uZWN0ZWROb2Rlc01hcCA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKCk7XG4gICAgY29ubmVjdGVkRWRnZXNNYXAuc2V0KHRoaXMuZGF0YUluZGV4LCB0cnVlKTtcbiAgICB2YXIgc291cmNlTm9kZXMgPSBbdGhpcy5ub2RlMV07XG4gICAgdmFyIHRhcmdldE5vZGVzID0gW3RoaXMubm9kZTJdO1xuICAgIHZhciBub2RlSXRlcmF0b3JJbmRleCA9IDA7XG4gICAgd2hpbGUgKG5vZGVJdGVyYXRvckluZGV4IDwgc291cmNlTm9kZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlTm9kZSA9IHNvdXJjZU5vZGVzW25vZGVJdGVyYXRvckluZGV4XTtcbiAgICAgIG5vZGVJdGVyYXRvckluZGV4Kys7XG4gICAgICBjb25uZWN0ZWROb2Rlc01hcC5zZXQoc291cmNlTm9kZS5kYXRhSW5kZXgsIHRydWUpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzb3VyY2VOb2RlLmluRWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29ubmVjdGVkRWRnZXNNYXAuc2V0KHNvdXJjZU5vZGUuaW5FZGdlc1tqXS5kYXRhSW5kZXgsIHRydWUpO1xuICAgICAgICBzb3VyY2VOb2Rlcy5wdXNoKHNvdXJjZU5vZGUuaW5FZGdlc1tqXS5ub2RlMSk7XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGVJdGVyYXRvckluZGV4ID0gMDtcbiAgICB3aGlsZSAobm9kZUl0ZXJhdG9ySW5kZXggPCB0YXJnZXROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0Tm9kZXNbbm9kZUl0ZXJhdG9ySW5kZXhdO1xuICAgICAgbm9kZUl0ZXJhdG9ySW5kZXgrKztcbiAgICAgIGNvbm5lY3RlZE5vZGVzTWFwLnNldCh0YXJnZXROb2RlLmRhdGFJbmRleCwgdHJ1ZSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRhcmdldE5vZGUub3V0RWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29ubmVjdGVkRWRnZXNNYXAuc2V0KHRhcmdldE5vZGUub3V0RWRnZXNbal0uZGF0YUluZGV4LCB0cnVlKTtcbiAgICAgICAgdGFyZ2V0Tm9kZXMucHVzaCh0YXJnZXROb2RlLm91dEVkZ2VzW2pdLm5vZGUyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVkZ2U6IGNvbm5lY3RlZEVkZ2VzTWFwLmtleXMoKSxcbiAgICAgIG5vZGU6IGNvbm5lY3RlZE5vZGVzTWFwLmtleXMoKVxuICAgIH07XG4gIH07XG4gIHJldHVybiBHcmFwaEVkZ2U7XG59KCk7XG5mdW5jdGlvbiBjcmVhdGVHcmFwaERhdGFQcm94eU1peGluKGhvc3ROYW1lLCBkYXRhTmFtZSkge1xuICByZXR1cm4ge1xuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIERlZmF1bHQgJ3ZhbHVlJy4gY2FuIGJlICdhJywgJ2InLCAnYycsICdkJywgJ2UnLlxyXG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChkaW1lbnNpb24pIHtcbiAgICAgIHZhciBkYXRhID0gdGhpc1tob3N0TmFtZV1bZGF0YU5hbWVdO1xuICAgICAgcmV0dXJuIGRhdGEuZ2V0U3RvcmUoKS5nZXQoZGF0YS5nZXREaW1lbnNpb25JbmRleChkaW1lbnNpb24gfHwgJ3ZhbHVlJyksIHRoaXMuZGF0YUluZGV4KTtcbiAgICB9LFxuICAgIC8vIFRPRE86IFRZUEUgc3RyaWN0ZXIgdHlwZS5cbiAgICBzZXRWaXN1YWw6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmRhdGFJbmRleCA+PSAwICYmIHRoaXNbaG9zdE5hbWVdW2RhdGFOYW1lXS5zZXRJdGVtVmlzdWFsKHRoaXMuZGF0YUluZGV4LCBrZXksIHZhbHVlKTtcbiAgICB9LFxuICAgIGdldFZpc3VhbDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXNbaG9zdE5hbWVdW2RhdGFOYW1lXS5nZXRJdGVtVmlzdWFsKHRoaXMuZGF0YUluZGV4LCBrZXkpO1xuICAgIH0sXG4gICAgc2V0TGF5b3V0OiBmdW5jdGlvbiAobGF5b3V0LCBtZXJnZSkge1xuICAgICAgdGhpcy5kYXRhSW5kZXggPj0gMCAmJiB0aGlzW2hvc3ROYW1lXVtkYXRhTmFtZV0uc2V0SXRlbUxheW91dCh0aGlzLmRhdGFJbmRleCwgbGF5b3V0LCBtZXJnZSk7XG4gICAgfSxcbiAgICBnZXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzW2hvc3ROYW1lXVtkYXRhTmFtZV0uZ2V0SXRlbUxheW91dCh0aGlzLmRhdGFJbmRleCk7XG4gICAgfSxcbiAgICBnZXRHcmFwaGljRWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzW2hvc3ROYW1lXVtkYXRhTmFtZV0uZ2V0SXRlbUdyYXBoaWNFbCh0aGlzLmRhdGFJbmRleCk7XG4gICAgfSxcbiAgICBnZXRSYXdJbmRleDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXNbaG9zdE5hbWVdW2RhdGFOYW1lXS5nZXRSYXdJbmRleCh0aGlzLmRhdGFJbmRleCk7XG4gICAgfVxuICB9O1xufVxuO1xuO1xuO1xuenJVdGlsLm1peGluKEdyYXBoTm9kZSwgY3JlYXRlR3JhcGhEYXRhUHJveHlNaXhpbignaG9zdEdyYXBoJywgJ2RhdGEnKSk7XG56clV0aWwubWl4aW4oR3JhcGhFZGdlLCBjcmVhdGVHcmFwaERhdGFQcm94eU1peGluKCdob3N0R3JhcGgnLCAnZWRnZURhdGEnKSk7XG5leHBvcnQgZGVmYXVsdCBHcmFwaDtcbmV4cG9ydCB7IEdyYXBoTm9kZSwgR3JhcGhFZGdlIH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///50451\n")},58267:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Kd: () => (/* binding */ getRawSourceDataCounter),\n/* harmony export */   QE: () => (/* binding */ retrieveRawValue),\n/* harmony export */   d1: () => (/* binding */ DefaultDataProvider),\n/* harmony export */   sC: () => (/* binding */ getRawSourceItemGetter),\n/* harmony export */   uQ: () => (/* binding */ getRawSourceValueGetter)\n/* harmony export */ });\n/* unused harmony export retrieveRawAttr */\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98026);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(48170);\n/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34310);\n/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13430);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar _a, _b, _c;\n// TODO\n// ??? refactor? check the outer usage of data provider.\n// merge with defaultDimValueGetter?\n\n\n\n\nvar providerMethods;\nvar mountMethods;\n/**\r\n * If normal array used, mutable chunk size is supported.\r\n * If typed array used, chunk size must be fixed.\r\n */\nvar DefaultDataProvider = /** @class */function () {\n  function DefaultDataProvider(sourceParam, dimSize) {\n    // let source: Source;\n    var source = !(0,_Source_js__WEBPACK_IMPORTED_MODULE_0__/* .isSourceInstance */ .tP)(sourceParam) ? (0,_Source_js__WEBPACK_IMPORTED_MODULE_0__/* .createSourceFromSeriesDataOption */ .AF)(sourceParam) : sourceParam;\n    // declare source is Source;\n    this._source = source;\n    var data = this._data = source.data;\n    // Typed array. TODO IE10+?\n    if (source.sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_TYPED_ARRAY */ .XO) {\n      if (false) {}\n      this._offset = 0;\n      this._dimSize = dimSize;\n      this._data = data;\n    }\n    mountMethods(this, data, source);\n  }\n  DefaultDataProvider.prototype.getSource = function () {\n    return this._source;\n  };\n  DefaultDataProvider.prototype.count = function () {\n    return 0;\n  };\n  DefaultDataProvider.prototype.getItem = function (idx, out) {\n    return;\n  };\n  DefaultDataProvider.prototype.appendData = function (newData) {};\n  DefaultDataProvider.prototype.clean = function () {};\n  DefaultDataProvider.protoInitialize = function () {\n    // PENDING: To avoid potential incompat (e.g., prototype\n    // is visited somewhere), still init them on prototype.\n    var proto = DefaultDataProvider.prototype;\n    proto.pure = false;\n    proto.persistent = true;\n  }();\n  DefaultDataProvider.internalField = function () {\n    var _a;\n    mountMethods = function (provider, data, source) {\n      var sourceFormat = source.sourceFormat;\n      var seriesLayoutBy = source.seriesLayoutBy;\n      var startIndex = source.startIndex;\n      var dimsDef = source.dimensionsDefine;\n      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n      if (false) {}\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.extend)(provider, methods);\n      if (sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_TYPED_ARRAY */ .XO) {\n        provider.getItem = getItemForTypedArray;\n        provider.count = countForTypedArray;\n        provider.fillStorage = fillStorageForTypedArray;\n      } else {\n        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);\n        provider.getItem = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.bind)(rawItemGetter, null, data, startIndex, dimsDef);\n        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);\n        provider.count = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.bind)(rawCounter, null, data, startIndex, dimsDef);\n      }\n    };\n    var getItemForTypedArray = function (idx, out) {\n      idx = idx - this._offset;\n      out = out || [];\n      var data = this._data;\n      var dimSize = this._dimSize;\n      var offset = dimSize * idx;\n      for (var i = 0; i < dimSize; i++) {\n        out[i] = data[offset + i];\n      }\n      return out;\n    };\n    var fillStorageForTypedArray = function (start, end, storage, extent) {\n      var data = this._data;\n      var dimSize = this._dimSize;\n      for (var dim = 0; dim < dimSize; dim++) {\n        var dimExtent = extent[dim];\n        var min = dimExtent[0] == null ? Infinity : dimExtent[0];\n        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];\n        var count = end - start;\n        var arr = storage[dim];\n        for (var i = 0; i < count; i++) {\n          // appendData with TypedArray will always do replace in provider.\n          var val = data[i * dimSize + dim];\n          arr[start + i] = val;\n          val < min && (min = val);\n          val > max && (max = val);\n        }\n        dimExtent[0] = min;\n        dimExtent[1] = max;\n      }\n    };\n    var countForTypedArray = function () {\n      return this._data ? this._data.length / this._dimSize : 0;\n    };\n    providerMethods = (_a = {}, _a[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ARRAY_ROWS */ .Km + '_' + _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SERIES_LAYOUT_BY_COLUMN */ .i_] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ARRAY_ROWS */ .Km + '_' + _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SERIES_LAYOUT_BY_ROW */ .oC] = {\n      pure: true,\n      appendData: function () {\n        throw new Error('Do not support appendData when set seriesLayoutBy: \"row\".');\n      }\n    }, _a[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_OBJECT_ROWS */ .Wk] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_KEYED_COLUMNS */ .t1] = {\n      pure: true,\n      appendData: function (newData) {\n        var data = this._data;\n        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_2__.each)(newData, function (newCol, key) {\n          var oldCol = data[key] || (data[key] = []);\n          for (var i = 0; i < (newCol || []).length; i++) {\n            oldCol.push(newCol[i]);\n          }\n        });\n      }\n    }, _a[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ORIGINAL */ .mK] = {\n      appendData: appendDataSimply\n    }, _a[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_TYPED_ARRAY */ .XO] = {\n      persistent: false,\n      pure: true,\n      appendData: function (newData) {\n        if (false) {}\n        this._data = newData;\n      },\n      // Clean self if data is already used.\n      clean: function () {\n        // PENDING\n        this._offset += this.count();\n        this._data = null;\n      }\n    }, _a);\n    function appendDataSimply(newData) {\n      for (var i = 0; i < newData.length; i++) {\n        this._data.push(newData[i]);\n      }\n    }\n  }();\n  return DefaultDataProvider;\n}();\n\nvar getItemSimply = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx];\n};\nvar rawSourceItemGetterMap = (_a = {}, _a[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ARRAY_ROWS */ .Km + '_' + _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SERIES_LAYOUT_BY_COLUMN */ .i_] = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx + startIndex];\n}, _a[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ARRAY_ROWS */ .Km + '_' + _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SERIES_LAYOUT_BY_ROW */ .oC] = function (rawData, startIndex, dimsDef, idx, out) {\n  idx += startIndex;\n  var item = out || [];\n  var data = rawData;\n  for (var i = 0; i < data.length; i++) {\n    var row = data[i];\n    item[i] = row ? row[idx] : null;\n  }\n  return item;\n}, _a[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_OBJECT_ROWS */ .Wk] = getItemSimply, _a[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_KEYED_COLUMNS */ .t1] = function (rawData, startIndex, dimsDef, idx, out) {\n  var item = out || [];\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n    if (false) {}\n    var col = rawData[dimName];\n    item[i] = col ? col[idx] : null;\n  }\n  return item;\n}, _a[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ORIGINAL */ .mK] = getItemSimply, _a);\nfunction getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n  if (false) {}\n  return method;\n}\nvar countSimply = function (rawData, startIndex, dimsDef) {\n  return rawData.length;\n};\nvar rawSourceDataCounterMap = (_b = {}, _b[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ARRAY_ROWS */ .Km + '_' + _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SERIES_LAYOUT_BY_COLUMN */ .i_] = function (rawData, startIndex, dimsDef) {\n  return Math.max(0, rawData.length - startIndex);\n}, _b[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ARRAY_ROWS */ .Km + '_' + _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SERIES_LAYOUT_BY_ROW */ .oC] = function (rawData, startIndex, dimsDef) {\n  var row = rawData[0];\n  return row ? Math.max(0, row.length - startIndex) : 0;\n}, _b[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_OBJECT_ROWS */ .Wk] = countSimply, _b[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_KEYED_COLUMNS */ .t1] = function (rawData, startIndex, dimsDef) {\n  var dimName = dimsDef[0].name;\n  if (false) {}\n  var col = rawData[dimName];\n  return col ? col.length : 0;\n}, _b[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ORIGINAL */ .mK] = countSimply, _b);\nfunction getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n  if (false) {}\n  return method;\n}\nvar getRawValueSimply = function (dataItem, dimIndex, property) {\n  return dataItem[dimIndex];\n};\nvar rawSourceValueGetterMap = (_c = {}, _c[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ARRAY_ROWS */ .Km] = getRawValueSimply, _c[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_OBJECT_ROWS */ .Wk] = function (dataItem, dimIndex, property) {\n  return dataItem[property];\n}, _c[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_KEYED_COLUMNS */ .t1] = getRawValueSimply, _c[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ORIGINAL */ .mK] = function (dataItem, dimIndex, property) {\n  // FIXME: In some case (markpoint in geo (geo-map.html)),\n  // dataItem is {coord: [...]}\n  var value = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_3__/* .getDataItemValue */ .vj)(dataItem);\n  return !(value instanceof Array) ? value : value[dimIndex];\n}, _c[_util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_TYPED_ARRAY */ .XO] = getRawValueSimply, _c);\nfunction getRawSourceValueGetter(sourceFormat) {\n  var method = rawSourceValueGetterMap[sourceFormat];\n  if (false) {}\n  return method;\n}\nfunction getMethodMapKey(sourceFormat, seriesLayoutBy) {\n  return sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ARRAY_ROWS */ .Km ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;\n}\n// ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,\n// Consider persistent.\n// Caution: why use raw value to display on label or tooltip?\n// A reason is to avoid format. For example time value we do not know\n// how to format is expected. More over, if stack is used, calculated\n// value may be 0.91000000001, which have brings trouble to display.\n// TODO: consider how to treat null/undefined/NaN when display?\nfunction retrieveRawValue(data, dataIndex,\n// If dimIndex is null/undefined, return OptionDataItem.\n// Otherwise, return OptionDataValue.\ndim) {\n  if (!data) {\n    return;\n  }\n  // Consider data may be not persistent.\n  var dataItem = data.getRawDataItem(dataIndex);\n  if (dataItem == null) {\n    return;\n  }\n  var store = data.getStore();\n  var sourceFormat = store.getSource().sourceFormat;\n  if (dim != null) {\n    var dimIndex = data.getDimensionIndex(dim);\n    var property = store.getDimensionProperty(dimIndex);\n    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);\n  } else {\n    var result = dataItem;\n    if (sourceFormat === _util_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SOURCE_FORMAT_ORIGINAL */ .mK) {\n      result = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_3__/* .getDataItemValue */ .vj)(dataItem);\n    }\n    return result;\n  }\n}\n/**\r\n * Compatible with some cases (in pie, map) like:\r\n * data: [{name: 'xx', value: 5, selected: true}, ...]\r\n * where only sourceFormat is 'original' and 'objectRows' supported.\r\n *\r\n * // TODO\r\n * Supported detail options in data item when using 'arrayRows'.\r\n *\r\n * @param data\r\n * @param dataIndex\r\n * @param attr like 'selected'\r\n */\nfunction retrieveRawAttr(data, dataIndex, attr) {\n  if (!data) {\n    return;\n  }\n  var sourceFormat = data.getStore().getSource().sourceFormat;\n  if (sourceFormat !== SOURCE_FORMAT_ORIGINAL && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {\n    return;\n  }\n  var dataItem = data.getRawDataItem(dataIndex);\n  if (sourceFormat === SOURCE_FORMAT_ORIGINAL && !isObject(dataItem)) {\n    dataItem = null;\n  }\n  if (dataItem) {\n    return dataItem[attr];\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTgyNjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvaGVscGVyL2RhdGFQcm92aWRlci5qcz9hZDU5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xudmFyIF9hLCBfYiwgX2M7XG4vLyBUT0RPXG4vLyA/Pz8gcmVmYWN0b3I/IGNoZWNrIHRoZSBvdXRlciB1c2FnZSBvZiBkYXRhIHByb3ZpZGVyLlxuLy8gbWVyZ2Ugd2l0aCBkZWZhdWx0RGltVmFsdWVHZXR0ZXI/XG5pbXBvcnQgeyBpc1R5cGVkQXJyYXksIGV4dGVuZCwgYXNzZXJ0LCBlYWNoLCBpc09iamVjdCwgYmluZCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBnZXREYXRhSXRlbVZhbHVlIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTb3VyY2VGcm9tU2VyaWVzRGF0YU9wdGlvbiwgaXNTb3VyY2VJbnN0YW5jZSB9IGZyb20gJy4uL1NvdXJjZS5qcyc7XG5pbXBvcnQgeyBTT1VSQ0VfRk9STUFUX09SSUdJTkFMLCBTT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTLCBTT1VSQ0VfRk9STUFUX0tFWUVEX0NPTFVNTlMsIFNPVVJDRV9GT1JNQVRfVFlQRURfQVJSQVksIFNPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUywgU0VSSUVTX0xBWU9VVF9CWV9DT0xVTU4sIFNFUklFU19MQVlPVVRfQllfUk9XIH0gZnJvbSAnLi4vLi4vdXRpbC90eXBlcy5qcyc7XG52YXIgcHJvdmlkZXJNZXRob2RzO1xudmFyIG1vdW50TWV0aG9kcztcbi8qKlxyXG4gKiBJZiBub3JtYWwgYXJyYXkgdXNlZCwgbXV0YWJsZSBjaHVuayBzaXplIGlzIHN1cHBvcnRlZC5cclxuICogSWYgdHlwZWQgYXJyYXkgdXNlZCwgY2h1bmsgc2l6ZSBtdXN0IGJlIGZpeGVkLlxyXG4gKi9cbnZhciBEZWZhdWx0RGF0YVByb3ZpZGVyID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVmYXVsdERhdGFQcm92aWRlcihzb3VyY2VQYXJhbSwgZGltU2l6ZSkge1xuICAgIC8vIGxldCBzb3VyY2U6IFNvdXJjZTtcbiAgICB2YXIgc291cmNlID0gIWlzU291cmNlSW5zdGFuY2Uoc291cmNlUGFyYW0pID8gY3JlYXRlU291cmNlRnJvbVNlcmllc0RhdGFPcHRpb24oc291cmNlUGFyYW0pIDogc291cmNlUGFyYW07XG4gICAgLy8gZGVjbGFyZSBzb3VyY2UgaXMgU291cmNlO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGEgPSBzb3VyY2UuZGF0YTtcbiAgICAvLyBUeXBlZCBhcnJheS4gVE9ETyBJRTEwKz9cbiAgICBpZiAoc291cmNlLnNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9UWVBFRF9BUlJBWSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRpbVNpemUgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHlwZWQgYXJyYXkgZGF0YSBtdXN0IHNwZWNpZnkgZGltZW5zaW9uIHNpemUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICAgIHRoaXMuX2RpbVNpemUgPSBkaW1TaXplO1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIG1vdW50TWV0aG9kcyh0aGlzLCBkYXRhLCBzb3VyY2UpO1xuICB9XG4gIERlZmF1bHREYXRhUHJvdmlkZXIucHJvdG90eXBlLmdldFNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlO1xuICB9O1xuICBEZWZhdWx0RGF0YVByb3ZpZGVyLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgRGVmYXVsdERhdGFQcm92aWRlci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZHgsIG91dCkge1xuICAgIHJldHVybjtcbiAgfTtcbiAgRGVmYXVsdERhdGFQcm92aWRlci5wcm90b3R5cGUuYXBwZW5kRGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7fTtcbiAgRGVmYXVsdERhdGFQcm92aWRlci5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbiAoKSB7fTtcbiAgRGVmYXVsdERhdGFQcm92aWRlci5wcm90b0luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gUEVORElORzogVG8gYXZvaWQgcG90ZW50aWFsIGluY29tcGF0IChlLmcuLCBwcm90b3R5cGVcbiAgICAvLyBpcyB2aXNpdGVkIHNvbWV3aGVyZSksIHN0aWxsIGluaXQgdGhlbSBvbiBwcm90b3R5cGUuXG4gICAgdmFyIHByb3RvID0gRGVmYXVsdERhdGFQcm92aWRlci5wcm90b3R5cGU7XG4gICAgcHJvdG8ucHVyZSA9IGZhbHNlO1xuICAgIHByb3RvLnBlcnNpc3RlbnQgPSB0cnVlO1xuICB9KCk7XG4gIERlZmF1bHREYXRhUHJvdmlkZXIuaW50ZXJuYWxGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG4gICAgbW91bnRNZXRob2RzID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBkYXRhLCBzb3VyY2UpIHtcbiAgICAgIHZhciBzb3VyY2VGb3JtYXQgPSBzb3VyY2Uuc291cmNlRm9ybWF0O1xuICAgICAgdmFyIHNlcmllc0xheW91dEJ5ID0gc291cmNlLnNlcmllc0xheW91dEJ5O1xuICAgICAgdmFyIHN0YXJ0SW5kZXggPSBzb3VyY2Uuc3RhcnRJbmRleDtcbiAgICAgIHZhciBkaW1zRGVmID0gc291cmNlLmRpbWVuc2lvbnNEZWZpbmU7XG4gICAgICB2YXIgbWV0aG9kcyA9IHByb3ZpZGVyTWV0aG9kc1tnZXRNZXRob2RNYXBLZXkoc291cmNlRm9ybWF0LCBzZXJpZXNMYXlvdXRCeSldO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KG1ldGhvZHMsICdJbnZhbGlkZSBzb3VyY2VGb3JtYXQ6ICcgKyBzb3VyY2VGb3JtYXQpO1xuICAgICAgfVxuICAgICAgZXh0ZW5kKHByb3ZpZGVyLCBtZXRob2RzKTtcbiAgICAgIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfVFlQRURfQVJSQVkpIHtcbiAgICAgICAgcHJvdmlkZXIuZ2V0SXRlbSA9IGdldEl0ZW1Gb3JUeXBlZEFycmF5O1xuICAgICAgICBwcm92aWRlci5jb3VudCA9IGNvdW50Rm9yVHlwZWRBcnJheTtcbiAgICAgICAgcHJvdmlkZXIuZmlsbFN0b3JhZ2UgPSBmaWxsU3RvcmFnZUZvclR5cGVkQXJyYXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmF3SXRlbUdldHRlciA9IGdldFJhd1NvdXJjZUl0ZW1HZXR0ZXIoc291cmNlRm9ybWF0LCBzZXJpZXNMYXlvdXRCeSk7XG4gICAgICAgIHByb3ZpZGVyLmdldEl0ZW0gPSBiaW5kKHJhd0l0ZW1HZXR0ZXIsIG51bGwsIGRhdGEsIHN0YXJ0SW5kZXgsIGRpbXNEZWYpO1xuICAgICAgICB2YXIgcmF3Q291bnRlciA9IGdldFJhd1NvdXJjZURhdGFDb3VudGVyKHNvdXJjZUZvcm1hdCwgc2VyaWVzTGF5b3V0QnkpO1xuICAgICAgICBwcm92aWRlci5jb3VudCA9IGJpbmQocmF3Q291bnRlciwgbnVsbCwgZGF0YSwgc3RhcnRJbmRleCwgZGltc0RlZik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgZ2V0SXRlbUZvclR5cGVkQXJyYXkgPSBmdW5jdGlvbiAoaWR4LCBvdXQpIHtcbiAgICAgIGlkeCA9IGlkeCAtIHRoaXMuX29mZnNldDtcbiAgICAgIG91dCA9IG91dCB8fCBbXTtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgIHZhciBkaW1TaXplID0gdGhpcy5fZGltU2l6ZTtcbiAgICAgIHZhciBvZmZzZXQgPSBkaW1TaXplICogaWR4O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1TaXplOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gZGF0YVtvZmZzZXQgKyBpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICB2YXIgZmlsbFN0b3JhZ2VGb3JUeXBlZEFycmF5ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHN0b3JhZ2UsIGV4dGVudCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgdmFyIGRpbVNpemUgPSB0aGlzLl9kaW1TaXplO1xuICAgICAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgZGltU2l6ZTsgZGltKyspIHtcbiAgICAgICAgdmFyIGRpbUV4dGVudCA9IGV4dGVudFtkaW1dO1xuICAgICAgICB2YXIgbWluID0gZGltRXh0ZW50WzBdID09IG51bGwgPyBJbmZpbml0eSA6IGRpbUV4dGVudFswXTtcbiAgICAgICAgdmFyIG1heCA9IGRpbUV4dGVudFsxXSA9PSBudWxsID8gLUluZmluaXR5IDogZGltRXh0ZW50WzFdO1xuICAgICAgICB2YXIgY291bnQgPSBlbmQgLSBzdGFydDtcbiAgICAgICAgdmFyIGFyciA9IHN0b3JhZ2VbZGltXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgLy8gYXBwZW5kRGF0YSB3aXRoIFR5cGVkQXJyYXkgd2lsbCBhbHdheXMgZG8gcmVwbGFjZSBpbiBwcm92aWRlci5cbiAgICAgICAgICB2YXIgdmFsID0gZGF0YVtpICogZGltU2l6ZSArIGRpbV07XG4gICAgICAgICAgYXJyW3N0YXJ0ICsgaV0gPSB2YWw7XG4gICAgICAgICAgdmFsIDwgbWluICYmIChtaW4gPSB2YWwpO1xuICAgICAgICAgIHZhbCA+IG1heCAmJiAobWF4ID0gdmFsKTtcbiAgICAgICAgfVxuICAgICAgICBkaW1FeHRlbnRbMF0gPSBtaW47XG4gICAgICAgIGRpbUV4dGVudFsxXSA9IG1heDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjb3VudEZvclR5cGVkQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YSA/IHRoaXMuX2RhdGEubGVuZ3RoIC8gdGhpcy5fZGltU2l6ZSA6IDA7XG4gICAgfTtcbiAgICBwcm92aWRlck1ldGhvZHMgPSAoX2EgPSB7fSwgX2FbU09VUkNFX0ZPUk1BVF9BUlJBWV9ST1dTICsgJ18nICsgU0VSSUVTX0xBWU9VVF9CWV9DT0xVTU5dID0ge1xuICAgICAgcHVyZTogdHJ1ZSxcbiAgICAgIGFwcGVuZERhdGE6IGFwcGVuZERhdGFTaW1wbHlcbiAgICB9LCBfYVtTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MgKyAnXycgKyBTRVJJRVNfTEFZT1VUX0JZX1JPV10gPSB7XG4gICAgICBwdXJlOiB0cnVlLFxuICAgICAgYXBwZW5kRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RvIG5vdCBzdXBwb3J0IGFwcGVuZERhdGEgd2hlbiBzZXQgc2VyaWVzTGF5b3V0Qnk6IFwicm93XCIuJyk7XG4gICAgICB9XG4gICAgfSwgX2FbU09VUkNFX0ZPUk1BVF9PQkpFQ1RfUk9XU10gPSB7XG4gICAgICBwdXJlOiB0cnVlLFxuICAgICAgYXBwZW5kRGF0YTogYXBwZW5kRGF0YVNpbXBseVxuICAgIH0sIF9hW1NPVVJDRV9GT1JNQVRfS0VZRURfQ09MVU1OU10gPSB7XG4gICAgICBwdXJlOiB0cnVlLFxuICAgICAgYXBwZW5kRGF0YTogZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBlYWNoKG5ld0RhdGEsIGZ1bmN0aW9uIChuZXdDb2wsIGtleSkge1xuICAgICAgICAgIHZhciBvbGRDb2wgPSBkYXRhW2tleV0gfHwgKGRhdGFba2V5XSA9IFtdKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChuZXdDb2wgfHwgW10pLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvbGRDb2wucHVzaChuZXdDb2xbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgX2FbU09VUkNFX0ZPUk1BVF9PUklHSU5BTF0gPSB7XG4gICAgICBhcHBlbmREYXRhOiBhcHBlbmREYXRhU2ltcGx5XG4gICAgfSwgX2FbU09VUkNFX0ZPUk1BVF9UWVBFRF9BUlJBWV0gPSB7XG4gICAgICBwZXJzaXN0ZW50OiBmYWxzZSxcbiAgICAgIHB1cmU6IHRydWUsXG4gICAgICBhcHBlbmREYXRhOiBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGFzc2VydChpc1R5cGVkQXJyYXkobmV3RGF0YSksICdBZGRlZCBkYXRhIG11c3QgYmUgVHlwZWRBcnJheSBpZiBkYXRhIGluIGluaXRpYWxpemF0aW9uIGlzIFR5cGVkQXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhID0gbmV3RGF0YTtcbiAgICAgIH0sXG4gICAgICAvLyBDbGVhbiBzZWxmIGlmIGRhdGEgaXMgYWxyZWFkeSB1c2VkLlxuICAgICAgY2xlYW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUEVORElOR1xuICAgICAgICB0aGlzLl9vZmZzZXQgKz0gdGhpcy5jb3VudCgpO1xuICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LCBfYSk7XG4gICAgZnVuY3Rpb24gYXBwZW5kRGF0YVNpbXBseShuZXdEYXRhKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fZGF0YS5wdXNoKG5ld0RhdGFbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSgpO1xuICByZXR1cm4gRGVmYXVsdERhdGFQcm92aWRlcjtcbn0oKTtcbmV4cG9ydCB7IERlZmF1bHREYXRhUHJvdmlkZXIgfTtcbnZhciBnZXRJdGVtU2ltcGx5ID0gZnVuY3Rpb24gKHJhd0RhdGEsIHN0YXJ0SW5kZXgsIGRpbXNEZWYsIGlkeCkge1xuICByZXR1cm4gcmF3RGF0YVtpZHhdO1xufTtcbnZhciByYXdTb3VyY2VJdGVtR2V0dGVyTWFwID0gKF9hID0ge30sIF9hW1NPVVJDRV9GT1JNQVRfQVJSQVlfUk9XUyArICdfJyArIFNFUklFU19MQVlPVVRfQllfQ09MVU1OXSA9IGZ1bmN0aW9uIChyYXdEYXRhLCBzdGFydEluZGV4LCBkaW1zRGVmLCBpZHgpIHtcbiAgcmV0dXJuIHJhd0RhdGFbaWR4ICsgc3RhcnRJbmRleF07XG59LCBfYVtTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MgKyAnXycgKyBTRVJJRVNfTEFZT1VUX0JZX1JPV10gPSBmdW5jdGlvbiAocmF3RGF0YSwgc3RhcnRJbmRleCwgZGltc0RlZiwgaWR4LCBvdXQpIHtcbiAgaWR4ICs9IHN0YXJ0SW5kZXg7XG4gIHZhciBpdGVtID0gb3V0IHx8IFtdO1xuICB2YXIgZGF0YSA9IHJhd0RhdGE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIHZhciByb3cgPSBkYXRhW2ldO1xuICAgIGl0ZW1baV0gPSByb3cgPyByb3dbaWR4XSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59LCBfYVtTT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTXSA9IGdldEl0ZW1TaW1wbHksIF9hW1NPVVJDRV9GT1JNQVRfS0VZRURfQ09MVU1OU10gPSBmdW5jdGlvbiAocmF3RGF0YSwgc3RhcnRJbmRleCwgZGltc0RlZiwgaWR4LCBvdXQpIHtcbiAgdmFyIGl0ZW0gPSBvdXQgfHwgW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGltc0RlZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaW1OYW1lID0gZGltc0RlZltpXS5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZGltTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY29sID0gcmF3RGF0YVtkaW1OYW1lXTtcbiAgICBpdGVtW2ldID0gY29sID8gY29sW2lkeF0gOiBudWxsO1xuICB9XG4gIHJldHVybiBpdGVtO1xufSwgX2FbU09VUkNFX0ZPUk1BVF9PUklHSU5BTF0gPSBnZXRJdGVtU2ltcGx5LCBfYSk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UmF3U291cmNlSXRlbUdldHRlcihzb3VyY2VGb3JtYXQsIHNlcmllc0xheW91dEJ5KSB7XG4gIHZhciBtZXRob2QgPSByYXdTb3VyY2VJdGVtR2V0dGVyTWFwW2dldE1ldGhvZE1hcEtleShzb3VyY2VGb3JtYXQsIHNlcmllc0xheW91dEJ5KV07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KG1ldGhvZCwgJ0RvIG5vdCBzdXBwb3J0IGdldCBpdGVtIG9uIFwiJyArIHNvdXJjZUZvcm1hdCArICdcIiwgXCInICsgc2VyaWVzTGF5b3V0QnkgKyAnXCIuJyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZDtcbn1cbnZhciBjb3VudFNpbXBseSA9IGZ1bmN0aW9uIChyYXdEYXRhLCBzdGFydEluZGV4LCBkaW1zRGVmKSB7XG4gIHJldHVybiByYXdEYXRhLmxlbmd0aDtcbn07XG52YXIgcmF3U291cmNlRGF0YUNvdW50ZXJNYXAgPSAoX2IgPSB7fSwgX2JbU09VUkNFX0ZPUk1BVF9BUlJBWV9ST1dTICsgJ18nICsgU0VSSUVTX0xBWU9VVF9CWV9DT0xVTU5dID0gZnVuY3Rpb24gKHJhd0RhdGEsIHN0YXJ0SW5kZXgsIGRpbXNEZWYpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIHJhd0RhdGEubGVuZ3RoIC0gc3RhcnRJbmRleCk7XG59LCBfYltTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MgKyAnXycgKyBTRVJJRVNfTEFZT1VUX0JZX1JPV10gPSBmdW5jdGlvbiAocmF3RGF0YSwgc3RhcnRJbmRleCwgZGltc0RlZikge1xuICB2YXIgcm93ID0gcmF3RGF0YVswXTtcbiAgcmV0dXJuIHJvdyA/IE1hdGgubWF4KDAsIHJvdy5sZW5ndGggLSBzdGFydEluZGV4KSA6IDA7XG59LCBfYltTT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTXSA9IGNvdW50U2ltcGx5LCBfYltTT1VSQ0VfRk9STUFUX0tFWUVEX0NPTFVNTlNdID0gZnVuY3Rpb24gKHJhd0RhdGEsIHN0YXJ0SW5kZXgsIGRpbXNEZWYpIHtcbiAgdmFyIGRpbU5hbWUgPSBkaW1zRGVmWzBdLm5hbWU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGRpbU5hbWUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICB9XG4gIHZhciBjb2wgPSByYXdEYXRhW2RpbU5hbWVdO1xuICByZXR1cm4gY29sID8gY29sLmxlbmd0aCA6IDA7XG59LCBfYltTT1VSQ0VfRk9STUFUX09SSUdJTkFMXSA9IGNvdW50U2ltcGx5LCBfYik7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UmF3U291cmNlRGF0YUNvdW50ZXIoc291cmNlRm9ybWF0LCBzZXJpZXNMYXlvdXRCeSkge1xuICB2YXIgbWV0aG9kID0gcmF3U291cmNlRGF0YUNvdW50ZXJNYXBbZ2V0TWV0aG9kTWFwS2V5KHNvdXJjZUZvcm1hdCwgc2VyaWVzTGF5b3V0QnkpXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQobWV0aG9kLCAnRG8gbm90IHN1cHBvcnQgY291bnQgb24gXCInICsgc291cmNlRm9ybWF0ICsgJ1wiLCBcIicgKyBzZXJpZXNMYXlvdXRCeSArICdcIi4nKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kO1xufVxudmFyIGdldFJhd1ZhbHVlU2ltcGx5ID0gZnVuY3Rpb24gKGRhdGFJdGVtLCBkaW1JbmRleCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIGRhdGFJdGVtW2RpbUluZGV4XTtcbn07XG52YXIgcmF3U291cmNlVmFsdWVHZXR0ZXJNYXAgPSAoX2MgPSB7fSwgX2NbU09VUkNFX0ZPUk1BVF9BUlJBWV9ST1dTXSA9IGdldFJhd1ZhbHVlU2ltcGx5LCBfY1tTT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTXSA9IGZ1bmN0aW9uIChkYXRhSXRlbSwgZGltSW5kZXgsIHByb3BlcnR5KSB7XG4gIHJldHVybiBkYXRhSXRlbVtwcm9wZXJ0eV07XG59LCBfY1tTT1VSQ0VfRk9STUFUX0tFWUVEX0NPTFVNTlNdID0gZ2V0UmF3VmFsdWVTaW1wbHksIF9jW1NPVVJDRV9GT1JNQVRfT1JJR0lOQUxdID0gZnVuY3Rpb24gKGRhdGFJdGVtLCBkaW1JbmRleCwgcHJvcGVydHkpIHtcbiAgLy8gRklYTUU6IEluIHNvbWUgY2FzZSAobWFya3BvaW50IGluIGdlbyAoZ2VvLW1hcC5odG1sKSksXG4gIC8vIGRhdGFJdGVtIGlzIHtjb29yZDogWy4uLl19XG4gIHZhciB2YWx1ZSA9IGdldERhdGFJdGVtVmFsdWUoZGF0YUl0ZW0pO1xuICByZXR1cm4gISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSA/IHZhbHVlIDogdmFsdWVbZGltSW5kZXhdO1xufSwgX2NbU09VUkNFX0ZPUk1BVF9UWVBFRF9BUlJBWV0gPSBnZXRSYXdWYWx1ZVNpbXBseSwgX2MpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJhd1NvdXJjZVZhbHVlR2V0dGVyKHNvdXJjZUZvcm1hdCkge1xuICB2YXIgbWV0aG9kID0gcmF3U291cmNlVmFsdWVHZXR0ZXJNYXBbc291cmNlRm9ybWF0XTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQobWV0aG9kLCAnRG8gbm90IHN1cHBvcnQgZ2V0IHZhbHVlIG9uIFwiJyArIHNvdXJjZUZvcm1hdCArICdcIi4nKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kO1xufVxuZnVuY3Rpb24gZ2V0TWV0aG9kTWFwS2V5KHNvdXJjZUZvcm1hdCwgc2VyaWVzTGF5b3V0QnkpIHtcbiAgcmV0dXJuIHNvdXJjZUZvcm1hdCA9PT0gU09VUkNFX0ZPUk1BVF9BUlJBWV9ST1dTID8gc291cmNlRm9ybWF0ICsgJ18nICsgc2VyaWVzTGF5b3V0QnkgOiBzb3VyY2VGb3JtYXQ7XG59XG4vLyA/Pz8gRklYTUUgY2FuIHRoZXNlIGxvZ2ljIGJlIG1vcmUgbmVhdDogZ2V0UmF3VmFsdWUsIGdldFJhd0RhdGFJdGVtLFxuLy8gQ29uc2lkZXIgcGVyc2lzdGVudC5cbi8vIENhdXRpb246IHdoeSB1c2UgcmF3IHZhbHVlIHRvIGRpc3BsYXkgb24gbGFiZWwgb3IgdG9vbHRpcD9cbi8vIEEgcmVhc29uIGlzIHRvIGF2b2lkIGZvcm1hdC4gRm9yIGV4YW1wbGUgdGltZSB2YWx1ZSB3ZSBkbyBub3Qga25vd1xuLy8gaG93IHRvIGZvcm1hdCBpcyBleHBlY3RlZC4gTW9yZSBvdmVyLCBpZiBzdGFjayBpcyB1c2VkLCBjYWxjdWxhdGVkXG4vLyB2YWx1ZSBtYXkgYmUgMC45MTAwMDAwMDAwMSwgd2hpY2ggaGF2ZSBicmluZ3MgdHJvdWJsZSB0byBkaXNwbGF5LlxuLy8gVE9ETzogY29uc2lkZXIgaG93IHRvIHRyZWF0IG51bGwvdW5kZWZpbmVkL05hTiB3aGVuIGRpc3BsYXk/XG5leHBvcnQgZnVuY3Rpb24gcmV0cmlldmVSYXdWYWx1ZShkYXRhLCBkYXRhSW5kZXgsXG4vLyBJZiBkaW1JbmRleCBpcyBudWxsL3VuZGVmaW5lZCwgcmV0dXJuIE9wdGlvbkRhdGFJdGVtLlxuLy8gT3RoZXJ3aXNlLCByZXR1cm4gT3B0aW9uRGF0YVZhbHVlLlxuZGltKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBDb25zaWRlciBkYXRhIG1heSBiZSBub3QgcGVyc2lzdGVudC5cbiAgdmFyIGRhdGFJdGVtID0gZGF0YS5nZXRSYXdEYXRhSXRlbShkYXRhSW5kZXgpO1xuICBpZiAoZGF0YUl0ZW0gPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc3RvcmUgPSBkYXRhLmdldFN0b3JlKCk7XG4gIHZhciBzb3VyY2VGb3JtYXQgPSBzdG9yZS5nZXRTb3VyY2UoKS5zb3VyY2VGb3JtYXQ7XG4gIGlmIChkaW0gIT0gbnVsbCkge1xuICAgIHZhciBkaW1JbmRleCA9IGRhdGEuZ2V0RGltZW5zaW9uSW5kZXgoZGltKTtcbiAgICB2YXIgcHJvcGVydHkgPSBzdG9yZS5nZXREaW1lbnNpb25Qcm9wZXJ0eShkaW1JbmRleCk7XG4gICAgcmV0dXJuIGdldFJhd1NvdXJjZVZhbHVlR2V0dGVyKHNvdXJjZUZvcm1hdCkoZGF0YUl0ZW0sIGRpbUluZGV4LCBwcm9wZXJ0eSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFJdGVtO1xuICAgIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfT1JJR0lOQUwpIHtcbiAgICAgIHJlc3VsdCA9IGdldERhdGFJdGVtVmFsdWUoZGF0YUl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4vKipcclxuICogQ29tcGF0aWJsZSB3aXRoIHNvbWUgY2FzZXMgKGluIHBpZSwgbWFwKSBsaWtlOlxyXG4gKiBkYXRhOiBbe25hbWU6ICd4eCcsIHZhbHVlOiA1LCBzZWxlY3RlZDogdHJ1ZX0sIC4uLl1cclxuICogd2hlcmUgb25seSBzb3VyY2VGb3JtYXQgaXMgJ29yaWdpbmFsJyBhbmQgJ29iamVjdFJvd3MnIHN1cHBvcnRlZC5cclxuICpcclxuICogLy8gVE9ET1xyXG4gKiBTdXBwb3J0ZWQgZGV0YWlsIG9wdGlvbnMgaW4gZGF0YSBpdGVtIHdoZW4gdXNpbmcgJ2FycmF5Um93cycuXHJcbiAqXHJcbiAqIEBwYXJhbSBkYXRhXHJcbiAqIEBwYXJhbSBkYXRhSW5kZXhcclxuICogQHBhcmFtIGF0dHIgbGlrZSAnc2VsZWN0ZWQnXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldHJpZXZlUmF3QXR0cihkYXRhLCBkYXRhSW5kZXgsIGF0dHIpIHtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzb3VyY2VGb3JtYXQgPSBkYXRhLmdldFN0b3JlKCkuZ2V0U291cmNlKCkuc291cmNlRm9ybWF0O1xuICBpZiAoc291cmNlRm9ybWF0ICE9PSBTT1VSQ0VfRk9STUFUX09SSUdJTkFMICYmIHNvdXJjZUZvcm1hdCAhPT0gU09VUkNFX0ZPUk1BVF9PQkpFQ1RfUk9XUykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZGF0YUl0ZW0gPSBkYXRhLmdldFJhd0RhdGFJdGVtKGRhdGFJbmRleCk7XG4gIGlmIChzb3VyY2VGb3JtYXQgPT09IFNPVVJDRV9GT1JNQVRfT1JJR0lOQUwgJiYgIWlzT2JqZWN0KGRhdGFJdGVtKSkge1xuICAgIGRhdGFJdGVtID0gbnVsbDtcbiAgfVxuICBpZiAoZGF0YUl0ZW0pIHtcbiAgICByZXR1cm4gZGF0YUl0ZW1bYXR0cl07XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///58267\n")},65008:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   iJ: () => (/* binding */ enableDataStack),\n/* harmony export */   me: () => (/* binding */ getStackedDimension),\n/* harmony export */   sJ: () => (/* binding */ isDimensionStacked)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _SeriesDataSchema_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73632);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n/**\r\n * Note that it is too complicated to support 3d stack by value\r\n * (have to create two-dimension inverted index), so in 3d case\r\n * we just support that stacked by index.\r\n *\r\n * @param seriesModel\r\n * @param dimensionsInput The same as the input of <module:echarts/data/SeriesData>.\r\n *        The input will be modified.\r\n * @param opt\r\n * @param opt.stackedCoordDimension Specify a coord dimension if needed.\r\n * @param opt.byIndex=false\r\n * @return calculationInfo\r\n * {\r\n *     stackedDimension: string\r\n *     stackedByDimension: string\r\n *     isStackedByIndex: boolean\r\n *     stackedOverDimension: string\r\n *     stackResultDimension: string\r\n * }\r\n */\nfunction enableDataStack(seriesModel, dimensionsInput, opt) {\n  opt = opt || {};\n  var byIndex = opt.byIndex;\n  var stackedCoordDimension = opt.stackedCoordDimension;\n  var dimensionDefineList;\n  var schema;\n  var store;\n  if (isLegacyDimensionsInput(dimensionsInput)) {\n    dimensionDefineList = dimensionsInput;\n  } else {\n    schema = dimensionsInput.schema;\n    dimensionDefineList = schema.dimensions;\n    store = dimensionsInput.store;\n  }\n  // Compatibal: when `stack` is set as '', do not stack.\n  var mayStack = !!(seriesModel && seriesModel.get('stack'));\n  var stackedByDimInfo;\n  var stackedDimInfo;\n  var stackResultDimension;\n  var stackedOverDimension;\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(dimensionDefineList, function (dimensionInfo, index) {\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isString)(dimensionInfo)) {\n      dimensionDefineList[index] = dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n    if (mayStack && !dimensionInfo.isExtraCoord) {\n      // Find the first ordinal dimension as the stackedByDimInfo.\n      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {\n        stackedByDimInfo = dimensionInfo;\n      }\n      // Find the first stackable dimension as the stackedDimInfo.\n      if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {\n        stackedDimInfo = dimensionInfo;\n      }\n    }\n  });\n  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {\n    // Compatible with previous design, value axis (time axis) only stack by index.\n    // It may make sense if the user provides elaborately constructed data.\n    byIndex = true;\n  }\n  // Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.\n  // That put stack logic in List is for using conveniently in echarts extensions, but it\n  // might not be a good way.\n  if (stackedDimInfo) {\n    // Use a weird name that not duplicated with other names.\n    // Also need to use seriesModel.id as postfix because different\n    // series may share same data store. The stack dimension needs to be distinguished.\n    stackResultDimension = '__\\0ecstackresult_' + seriesModel.id;\n    stackedOverDimension = '__\\0ecstackedover_' + seriesModel.id;\n    // Create inverted index to fast query index by value.\n    if (stackedByDimInfo) {\n      stackedByDimInfo.createInvertedIndices = true;\n    }\n    var stackedDimCoordDim_1 = stackedDimInfo.coordDim;\n    var stackedDimType = stackedDimInfo.type;\n    var stackedDimCoordIndex_1 = 0;\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(dimensionDefineList, function (dimensionInfo) {\n      if (dimensionInfo.coordDim === stackedDimCoordDim_1) {\n        stackedDimCoordIndex_1++;\n      }\n    });\n    var stackedOverDimensionDefine = {\n      name: stackResultDimension,\n      coordDim: stackedDimCoordDim_1,\n      coordDimIndex: stackedDimCoordIndex_1,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true,\n      storeDimIndex: dimensionDefineList.length\n    };\n    var stackResultDimensionDefine = {\n      name: stackedOverDimension,\n      // This dimension contains stack base (generally, 0), so do not set it as\n      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.\n      coordDim: stackedOverDimension,\n      coordDimIndex: stackedDimCoordIndex_1 + 1,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true,\n      storeDimIndex: dimensionDefineList.length + 1\n    };\n    if (schema) {\n      if (store) {\n        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);\n        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);\n      }\n      schema.appendCalculationDimension(stackedOverDimensionDefine);\n      schema.appendCalculationDimension(stackResultDimensionDefine);\n    } else {\n      dimensionDefineList.push(stackedOverDimensionDefine);\n      dimensionDefineList.push(stackResultDimensionDefine);\n    }\n  }\n  return {\n    stackedDimension: stackedDimInfo && stackedDimInfo.name,\n    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,\n    isStackedByIndex: byIndex,\n    stackedOverDimension: stackedOverDimension,\n    stackResultDimension: stackResultDimension\n  };\n}\nfunction isLegacyDimensionsInput(dimensionsInput) {\n  return !(0,_SeriesDataSchema_js__WEBPACK_IMPORTED_MODULE_1__/* .isSeriesDataSchema */ .fg)(dimensionsInput.schema);\n}\nfunction isDimensionStacked(data, stackedDim) {\n  // Each single series only maps to one pair of axis. So we do not need to\n  // check stackByDim, whatever stacked by a dimension or stacked by index.\n  return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension');\n}\nfunction getStackedDimension(data, targetDim) {\n  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUwMDguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvZGF0YVN0YWNrSGVscGVyLmpzPzFjZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBlYWNoLCBpc1N0cmluZyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBpc1Nlcmllc0RhdGFTY2hlbWEgfSBmcm9tICcuL1Nlcmllc0RhdGFTY2hlbWEuanMnO1xuLyoqXHJcbiAqIE5vdGUgdGhhdCBpdCBpcyB0b28gY29tcGxpY2F0ZWQgdG8gc3VwcG9ydCAzZCBzdGFjayBieSB2YWx1ZVxyXG4gKiAoaGF2ZSB0byBjcmVhdGUgdHdvLWRpbWVuc2lvbiBpbnZlcnRlZCBpbmRleCksIHNvIGluIDNkIGNhc2VcclxuICogd2UganVzdCBzdXBwb3J0IHRoYXQgc3RhY2tlZCBieSBpbmRleC5cclxuICpcclxuICogQHBhcmFtIHNlcmllc01vZGVsXHJcbiAqIEBwYXJhbSBkaW1lbnNpb25zSW5wdXQgVGhlIHNhbWUgYXMgdGhlIGlucHV0IG9mIDxtb2R1bGU6ZWNoYXJ0cy9kYXRhL1Nlcmllc0RhdGE+LlxyXG4gKiAgICAgICAgVGhlIGlucHV0IHdpbGwgYmUgbW9kaWZpZWQuXHJcbiAqIEBwYXJhbSBvcHRcclxuICogQHBhcmFtIG9wdC5zdGFja2VkQ29vcmREaW1lbnNpb24gU3BlY2lmeSBhIGNvb3JkIGRpbWVuc2lvbiBpZiBuZWVkZWQuXHJcbiAqIEBwYXJhbSBvcHQuYnlJbmRleD1mYWxzZVxyXG4gKiBAcmV0dXJuIGNhbGN1bGF0aW9uSW5mb1xyXG4gKiB7XHJcbiAqICAgICBzdGFja2VkRGltZW5zaW9uOiBzdHJpbmdcclxuICogICAgIHN0YWNrZWRCeURpbWVuc2lvbjogc3RyaW5nXHJcbiAqICAgICBpc1N0YWNrZWRCeUluZGV4OiBib29sZWFuXHJcbiAqICAgICBzdGFja2VkT3ZlckRpbWVuc2lvbjogc3RyaW5nXHJcbiAqICAgICBzdGFja1Jlc3VsdERpbWVuc2lvbjogc3RyaW5nXHJcbiAqIH1cclxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlRGF0YVN0YWNrKHNlcmllc01vZGVsLCBkaW1lbnNpb25zSW5wdXQsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIHZhciBieUluZGV4ID0gb3B0LmJ5SW5kZXg7XG4gIHZhciBzdGFja2VkQ29vcmREaW1lbnNpb24gPSBvcHQuc3RhY2tlZENvb3JkRGltZW5zaW9uO1xuICB2YXIgZGltZW5zaW9uRGVmaW5lTGlzdDtcbiAgdmFyIHNjaGVtYTtcbiAgdmFyIHN0b3JlO1xuICBpZiAoaXNMZWdhY3lEaW1lbnNpb25zSW5wdXQoZGltZW5zaW9uc0lucHV0KSkge1xuICAgIGRpbWVuc2lvbkRlZmluZUxpc3QgPSBkaW1lbnNpb25zSW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgc2NoZW1hID0gZGltZW5zaW9uc0lucHV0LnNjaGVtYTtcbiAgICBkaW1lbnNpb25EZWZpbmVMaXN0ID0gc2NoZW1hLmRpbWVuc2lvbnM7XG4gICAgc3RvcmUgPSBkaW1lbnNpb25zSW5wdXQuc3RvcmU7XG4gIH1cbiAgLy8gQ29tcGF0aWJhbDogd2hlbiBgc3RhY2tgIGlzIHNldCBhcyAnJywgZG8gbm90IHN0YWNrLlxuICB2YXIgbWF5U3RhY2sgPSAhIShzZXJpZXNNb2RlbCAmJiBzZXJpZXNNb2RlbC5nZXQoJ3N0YWNrJykpO1xuICB2YXIgc3RhY2tlZEJ5RGltSW5mbztcbiAgdmFyIHN0YWNrZWREaW1JbmZvO1xuICB2YXIgc3RhY2tSZXN1bHREaW1lbnNpb247XG4gIHZhciBzdGFja2VkT3ZlckRpbWVuc2lvbjtcbiAgZWFjaChkaW1lbnNpb25EZWZpbmVMaXN0LCBmdW5jdGlvbiAoZGltZW5zaW9uSW5mbywgaW5kZXgpIHtcbiAgICBpZiAoaXNTdHJpbmcoZGltZW5zaW9uSW5mbykpIHtcbiAgICAgIGRpbWVuc2lvbkRlZmluZUxpc3RbaW5kZXhdID0gZGltZW5zaW9uSW5mbyA9IHtcbiAgICAgICAgbmFtZTogZGltZW5zaW9uSW5mb1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG1heVN0YWNrICYmICFkaW1lbnNpb25JbmZvLmlzRXh0cmFDb29yZCkge1xuICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgb3JkaW5hbCBkaW1lbnNpb24gYXMgdGhlIHN0YWNrZWRCeURpbUluZm8uXG4gICAgICBpZiAoIWJ5SW5kZXggJiYgIXN0YWNrZWRCeURpbUluZm8gJiYgZGltZW5zaW9uSW5mby5vcmRpbmFsTWV0YSkge1xuICAgICAgICBzdGFja2VkQnlEaW1JbmZvID0gZGltZW5zaW9uSW5mbztcbiAgICAgIH1cbiAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IHN0YWNrYWJsZSBkaW1lbnNpb24gYXMgdGhlIHN0YWNrZWREaW1JbmZvLlxuICAgICAgaWYgKCFzdGFja2VkRGltSW5mbyAmJiBkaW1lbnNpb25JbmZvLnR5cGUgIT09ICdvcmRpbmFsJyAmJiBkaW1lbnNpb25JbmZvLnR5cGUgIT09ICd0aW1lJyAmJiAoIXN0YWNrZWRDb29yZERpbWVuc2lvbiB8fCBzdGFja2VkQ29vcmREaW1lbnNpb24gPT09IGRpbWVuc2lvbkluZm8uY29vcmREaW0pKSB7XG4gICAgICAgIHN0YWNrZWREaW1JbmZvID0gZGltZW5zaW9uSW5mbztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAoc3RhY2tlZERpbUluZm8gJiYgIWJ5SW5kZXggJiYgIXN0YWNrZWRCeURpbUluZm8pIHtcbiAgICAvLyBDb21wYXRpYmxlIHdpdGggcHJldmlvdXMgZGVzaWduLCB2YWx1ZSBheGlzICh0aW1lIGF4aXMpIG9ubHkgc3RhY2sgYnkgaW5kZXguXG4gICAgLy8gSXQgbWF5IG1ha2Ugc2Vuc2UgaWYgdGhlIHVzZXIgcHJvdmlkZXMgZWxhYm9yYXRlbHkgY29uc3RydWN0ZWQgZGF0YS5cbiAgICBieUluZGV4ID0gdHJ1ZTtcbiAgfVxuICAvLyBBZGQgc3RhY2sgZGltZW5zaW9uLCB0aGV5IGNhbiBiZSBib3RoIGNhbGN1bGF0ZWQgYnkgY29vcmRpbmF0ZSBzeXN0ZW0gaW4gYHVuaW9uRXh0ZW50YC5cbiAgLy8gVGhhdCBwdXQgc3RhY2sgbG9naWMgaW4gTGlzdCBpcyBmb3IgdXNpbmcgY29udmVuaWVudGx5IGluIGVjaGFydHMgZXh0ZW5zaW9ucywgYnV0IGl0XG4gIC8vIG1pZ2h0IG5vdCBiZSBhIGdvb2Qgd2F5LlxuICBpZiAoc3RhY2tlZERpbUluZm8pIHtcbiAgICAvLyBVc2UgYSB3ZWlyZCBuYW1lIHRoYXQgbm90IGR1cGxpY2F0ZWQgd2l0aCBvdGhlciBuYW1lcy5cbiAgICAvLyBBbHNvIG5lZWQgdG8gdXNlIHNlcmllc01vZGVsLmlkIGFzIHBvc3RmaXggYmVjYXVzZSBkaWZmZXJlbnRcbiAgICAvLyBzZXJpZXMgbWF5IHNoYXJlIHNhbWUgZGF0YSBzdG9yZS4gVGhlIHN0YWNrIGRpbWVuc2lvbiBuZWVkcyB0byBiZSBkaXN0aW5ndWlzaGVkLlxuICAgIHN0YWNrUmVzdWx0RGltZW5zaW9uID0gJ19fXFwwZWNzdGFja3Jlc3VsdF8nICsgc2VyaWVzTW9kZWwuaWQ7XG4gICAgc3RhY2tlZE92ZXJEaW1lbnNpb24gPSAnX19cXDBlY3N0YWNrZWRvdmVyXycgKyBzZXJpZXNNb2RlbC5pZDtcbiAgICAvLyBDcmVhdGUgaW52ZXJ0ZWQgaW5kZXggdG8gZmFzdCBxdWVyeSBpbmRleCBieSB2YWx1ZS5cbiAgICBpZiAoc3RhY2tlZEJ5RGltSW5mbykge1xuICAgICAgc3RhY2tlZEJ5RGltSW5mby5jcmVhdGVJbnZlcnRlZEluZGljZXMgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgc3RhY2tlZERpbUNvb3JkRGltXzEgPSBzdGFja2VkRGltSW5mby5jb29yZERpbTtcbiAgICB2YXIgc3RhY2tlZERpbVR5cGUgPSBzdGFja2VkRGltSW5mby50eXBlO1xuICAgIHZhciBzdGFja2VkRGltQ29vcmRJbmRleF8xID0gMDtcbiAgICBlYWNoKGRpbWVuc2lvbkRlZmluZUxpc3QsIGZ1bmN0aW9uIChkaW1lbnNpb25JbmZvKSB7XG4gICAgICBpZiAoZGltZW5zaW9uSW5mby5jb29yZERpbSA9PT0gc3RhY2tlZERpbUNvb3JkRGltXzEpIHtcbiAgICAgICAgc3RhY2tlZERpbUNvb3JkSW5kZXhfMSsrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBzdGFja2VkT3ZlckRpbWVuc2lvbkRlZmluZSA9IHtcbiAgICAgIG5hbWU6IHN0YWNrUmVzdWx0RGltZW5zaW9uLFxuICAgICAgY29vcmREaW06IHN0YWNrZWREaW1Db29yZERpbV8xLFxuICAgICAgY29vcmREaW1JbmRleDogc3RhY2tlZERpbUNvb3JkSW5kZXhfMSxcbiAgICAgIHR5cGU6IHN0YWNrZWREaW1UeXBlLFxuICAgICAgaXNFeHRyYUNvb3JkOiB0cnVlLFxuICAgICAgaXNDYWxjdWxhdGlvbkNvb3JkOiB0cnVlLFxuICAgICAgc3RvcmVEaW1JbmRleDogZGltZW5zaW9uRGVmaW5lTGlzdC5sZW5ndGhcbiAgICB9O1xuICAgIHZhciBzdGFja1Jlc3VsdERpbWVuc2lvbkRlZmluZSA9IHtcbiAgICAgIG5hbWU6IHN0YWNrZWRPdmVyRGltZW5zaW9uLFxuICAgICAgLy8gVGhpcyBkaW1lbnNpb24gY29udGFpbnMgc3RhY2sgYmFzZSAoZ2VuZXJhbGx5LCAwKSwgc28gZG8gbm90IHNldCBpdCBhc1xuICAgICAgLy8gYHN0YWNrZWREaW1Db29yZERpbWAgdG8gYXZvaWQgZXh0ZW50IGNhbGN1bGF0aW9uLCBjb25zaWRlciBsb2cgc2NhbGUuXG4gICAgICBjb29yZERpbTogc3RhY2tlZE92ZXJEaW1lbnNpb24sXG4gICAgICBjb29yZERpbUluZGV4OiBzdGFja2VkRGltQ29vcmRJbmRleF8xICsgMSxcbiAgICAgIHR5cGU6IHN0YWNrZWREaW1UeXBlLFxuICAgICAgaXNFeHRyYUNvb3JkOiB0cnVlLFxuICAgICAgaXNDYWxjdWxhdGlvbkNvb3JkOiB0cnVlLFxuICAgICAgc3RvcmVEaW1JbmRleDogZGltZW5zaW9uRGVmaW5lTGlzdC5sZW5ndGggKyAxXG4gICAgfTtcbiAgICBpZiAoc2NoZW1hKSB7XG4gICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgc3RhY2tlZE92ZXJEaW1lbnNpb25EZWZpbmUuc3RvcmVEaW1JbmRleCA9IHN0b3JlLmVuc3VyZUNhbGN1bGF0aW9uRGltZW5zaW9uKHN0YWNrZWRPdmVyRGltZW5zaW9uLCBzdGFja2VkRGltVHlwZSk7XG4gICAgICAgIHN0YWNrUmVzdWx0RGltZW5zaW9uRGVmaW5lLnN0b3JlRGltSW5kZXggPSBzdG9yZS5lbnN1cmVDYWxjdWxhdGlvbkRpbWVuc2lvbihzdGFja1Jlc3VsdERpbWVuc2lvbiwgc3RhY2tlZERpbVR5cGUpO1xuICAgICAgfVxuICAgICAgc2NoZW1hLmFwcGVuZENhbGN1bGF0aW9uRGltZW5zaW9uKHN0YWNrZWRPdmVyRGltZW5zaW9uRGVmaW5lKTtcbiAgICAgIHNjaGVtYS5hcHBlbmRDYWxjdWxhdGlvbkRpbWVuc2lvbihzdGFja1Jlc3VsdERpbWVuc2lvbkRlZmluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpbWVuc2lvbkRlZmluZUxpc3QucHVzaChzdGFja2VkT3ZlckRpbWVuc2lvbkRlZmluZSk7XG4gICAgICBkaW1lbnNpb25EZWZpbmVMaXN0LnB1c2goc3RhY2tSZXN1bHREaW1lbnNpb25EZWZpbmUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YWNrZWREaW1lbnNpb246IHN0YWNrZWREaW1JbmZvICYmIHN0YWNrZWREaW1JbmZvLm5hbWUsXG4gICAgc3RhY2tlZEJ5RGltZW5zaW9uOiBzdGFja2VkQnlEaW1JbmZvICYmIHN0YWNrZWRCeURpbUluZm8ubmFtZSxcbiAgICBpc1N0YWNrZWRCeUluZGV4OiBieUluZGV4LFxuICAgIHN0YWNrZWRPdmVyRGltZW5zaW9uOiBzdGFja2VkT3ZlckRpbWVuc2lvbixcbiAgICBzdGFja1Jlc3VsdERpbWVuc2lvbjogc3RhY2tSZXN1bHREaW1lbnNpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIGlzTGVnYWN5RGltZW5zaW9uc0lucHV0KGRpbWVuc2lvbnNJbnB1dCkge1xuICByZXR1cm4gIWlzU2VyaWVzRGF0YVNjaGVtYShkaW1lbnNpb25zSW5wdXQuc2NoZW1hKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0RpbWVuc2lvblN0YWNrZWQoZGF0YSwgc3RhY2tlZERpbSkge1xuICAvLyBFYWNoIHNpbmdsZSBzZXJpZXMgb25seSBtYXBzIHRvIG9uZSBwYWlyIG9mIGF4aXMuIFNvIHdlIGRvIG5vdCBuZWVkIHRvXG4gIC8vIGNoZWNrIHN0YWNrQnlEaW0sIHdoYXRldmVyIHN0YWNrZWQgYnkgYSBkaW1lbnNpb24gb3Igc3RhY2tlZCBieSBpbmRleC5cbiAgcmV0dXJuICEhc3RhY2tlZERpbSAmJiBzdGFja2VkRGltID09PSBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZERpbWVuc2lvbicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YWNrZWREaW1lbnNpb24oZGF0YSwgdGFyZ2V0RGltKSB7XG4gIHJldHVybiBpc0RpbWVuc2lvblN0YWNrZWQoZGF0YSwgdGFyZ2V0RGltKSA/IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja1Jlc3VsdERpbWVuc2lvbicpIDogdGFyZ2V0RGltO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///65008\n")},73632:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tc: () => (/* binding */ SeriesDataSchema),\n/* harmony export */   eS: () => (/* binding */ shouldOmitUnusedDimensions),\n/* harmony export */   fg: () => (/* binding */ isSeriesDataSchema),\n/* harmony export */   io: () => (/* binding */ createDimNameMap),\n/* harmony export */   j_: () => (/* binding */ ensureSourceDimNameMap)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(34310);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar inner = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nvar dimTypeShort = {\n  float: 'f',\n  int: 'i',\n  ordinal: 'o',\n  number: 'n',\n  time: 't'\n};\n/**\r\n * Represents the dimension requirement of a series.\r\n *\r\n * NOTICE:\r\n * When there are too many dimensions in dataset and many series, only the used dimensions\r\n * (i.e., used by coord sys and declared in `series.encode`) are add to `dimensionDefineList`.\r\n * But users may query data by other unused dimension names.\r\n * In this case, users can only query data if and only if they have defined dimension names\r\n * via ec option, so we provide `getDimensionIndexFromSource`, which only query them from\r\n * `source` dimensions.\r\n */\nvar SeriesDataSchema = /** @class */function () {\n  function SeriesDataSchema(opt) {\n    this.dimensions = opt.dimensions;\n    this._dimOmitted = opt.dimensionOmitted;\n    this.source = opt.source;\n    this._fullDimCount = opt.fullDimensionCount;\n    this._updateDimOmitted(opt.dimensionOmitted);\n  }\n  SeriesDataSchema.prototype.isDimensionOmitted = function () {\n    return this._dimOmitted;\n  };\n  SeriesDataSchema.prototype._updateDimOmitted = function (dimensionOmitted) {\n    this._dimOmitted = dimensionOmitted;\n    if (!dimensionOmitted) {\n      return;\n    }\n    if (!this._dimNameMap) {\n      this._dimNameMap = ensureSourceDimNameMap(this.source);\n    }\n  };\n  /**\r\n   * @caution Can only be used when `dimensionOmitted: true`.\r\n   *\r\n   * Get index by user defined dimension name (i.e., not internal generate name).\r\n   * That is, get index from `dimensionsDefine`.\r\n   * If no `dimensionsDefine`, or no name get, return -1.\r\n   */\n  SeriesDataSchema.prototype.getSourceDimensionIndex = function (dimName) {\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(this._dimNameMap.get(dimName), -1);\n  };\n  /**\r\n   * @caution Can only be used when `dimensionOmitted: true`.\r\n   *\r\n   * Notice: may return `null`/`undefined` if user not specify dimension names.\r\n   */\n  SeriesDataSchema.prototype.getSourceDimension = function (dimIndex) {\n    var dimensionsDefine = this.source.dimensionsDefine;\n    if (dimensionsDefine) {\n      return dimensionsDefine[dimIndex];\n    }\n  };\n  SeriesDataSchema.prototype.makeStoreSchema = function () {\n    var dimCount = this._fullDimCount;\n    var willRetrieveDataByName = (0,_Source_js__WEBPACK_IMPORTED_MODULE_2__/* .shouldRetrieveDataByName */ .O0)(this.source);\n    var makeHashStrict = !shouldOmitUnusedDimensions(dimCount);\n    // If source don't have dimensions or series don't omit unsed dimensions.\n    // Generate from seriesDimList directly\n    var dimHash = '';\n    var dims = [];\n    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {\n      var property = void 0;\n      var type = void 0;\n      var ordinalMeta = void 0;\n      var seriesDimDef = this.dimensions[seriesDimIdx];\n      // The list has been sorted by `storeDimIndex` asc.\n      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {\n        property = willRetrieveDataByName ? seriesDimDef.name : null;\n        type = seriesDimDef.type;\n        ordinalMeta = seriesDimDef.ordinalMeta;\n        seriesDimIdx++;\n      } else {\n        var sourceDimDef = this.getSourceDimension(fullDimIdx);\n        if (sourceDimDef) {\n          property = willRetrieveDataByName ? sourceDimDef.name : null;\n          type = sourceDimDef.type;\n        }\n      }\n      dims.push({\n        property: property,\n        type: type,\n        ordinalMeta: ordinalMeta\n      });\n      // If retrieving data by index,\n      //   use <index, type, ordinalMeta> to determine whether data can be shared.\n      //   (Because in this case there might be no dimension name defined in dataset, but indices always exists).\n      //   (Indices are always 0, 1, 2, ..., so we can ignore them to shorten the hash).\n      // Otherwise if retrieving data by property name (like `data: [{aa: 123, bb: 765}, ...]`),\n      //   use <property, type, ordinalMeta> in hash.\n      if (willRetrieveDataByName && property != null\n      // For data stack, we have make sure each series has its own dim on this store.\n      // So we do not add property to hash to make sure they can share this store.\n      && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {\n        dimHash += makeHashStrict\n        // Use escape character '`' in case that property name contains '$'.\n        ? property.replace(/\\`/g, '`1').replace(/\\$/g, '`2')\n        // For better performance, when there are large dimensions, tolerant this defects that hardly meet.\n        : property;\n      }\n      dimHash += '$';\n      dimHash += dimTypeShort[type] || 'f';\n      if (ordinalMeta) {\n        dimHash += ordinalMeta.uid;\n      }\n      dimHash += '$';\n    }\n    // Source from endpoint(usually series) will be read differently\n    // when seriesLayoutBy or startIndex(which is affected by sourceHeader) are different.\n    // So we use this three props as key.\n    var source = this.source;\n    var hash = [source.seriesLayoutBy, source.startIndex, dimHash].join('$$');\n    return {\n      dimensions: dims,\n      hash: hash\n    };\n  };\n  SeriesDataSchema.prototype.makeOutputDimensionNames = function () {\n    var result = [];\n    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {\n      var name_1 = void 0;\n      var seriesDimDef = this.dimensions[seriesDimIdx];\n      // The list has been sorted by `storeDimIndex` asc.\n      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {\n        if (!seriesDimDef.isCalculationCoord) {\n          name_1 = seriesDimDef.name;\n        }\n        seriesDimIdx++;\n      } else {\n        var sourceDimDef = this.getSourceDimension(fullDimIdx);\n        if (sourceDimDef) {\n          name_1 = sourceDimDef.name;\n        }\n      }\n      result.push(name_1);\n    }\n    return result;\n  };\n  SeriesDataSchema.prototype.appendCalculationDimension = function (dimDef) {\n    this.dimensions.push(dimDef);\n    dimDef.isCalculationCoord = true;\n    this._fullDimCount++;\n    // If append dimension on a data store, consider the store\n    // might be shared by different series, series dimensions not\n    // really map to store dimensions.\n    this._updateDimOmitted(true);\n  };\n  return SeriesDataSchema;\n}();\n\nfunction isSeriesDataSchema(schema) {\n  return schema instanceof SeriesDataSchema;\n}\nfunction createDimNameMap(dimsDef) {\n  var dataDimNameMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.createHashMap)();\n  for (var i = 0; i < (dimsDef || []).length; i++) {\n    var dimDefItemRaw = dimsDef[i];\n    var userDimName = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;\n    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n      dataDimNameMap.set(userDimName, i);\n    }\n  }\n  return dataDimNameMap;\n}\nfunction ensureSourceDimNameMap(source) {\n  var innerSource = inner(source);\n  return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));\n}\nfunction shouldOmitUnusedDimensions(dimCount) {\n  return dimCount > 30;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM2MzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvU2VyaWVzRGF0YVNjaGVtYS5qcz84MzZhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgY3JlYXRlSGFzaE1hcCwgaXNPYmplY3QsIHJldHJpZXZlMiB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBtYWtlSW5uZXIgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCB7IHNob3VsZFJldHJpZXZlRGF0YUJ5TmFtZSB9IGZyb20gJy4uL1NvdXJjZS5qcyc7XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbnZhciBkaW1UeXBlU2hvcnQgPSB7XG4gIGZsb2F0OiAnZicsXG4gIGludDogJ2knLFxuICBvcmRpbmFsOiAnbycsXG4gIG51bWJlcjogJ24nLFxuICB0aW1lOiAndCdcbn07XG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgZGltZW5zaW9uIHJlcXVpcmVtZW50IG9mIGEgc2VyaWVzLlxyXG4gKlxyXG4gKiBOT1RJQ0U6XHJcbiAqIFdoZW4gdGhlcmUgYXJlIHRvbyBtYW55IGRpbWVuc2lvbnMgaW4gZGF0YXNldCBhbmQgbWFueSBzZXJpZXMsIG9ubHkgdGhlIHVzZWQgZGltZW5zaW9uc1xyXG4gKiAoaS5lLiwgdXNlZCBieSBjb29yZCBzeXMgYW5kIGRlY2xhcmVkIGluIGBzZXJpZXMuZW5jb2RlYCkgYXJlIGFkZCB0byBgZGltZW5zaW9uRGVmaW5lTGlzdGAuXHJcbiAqIEJ1dCB1c2VycyBtYXkgcXVlcnkgZGF0YSBieSBvdGhlciB1bnVzZWQgZGltZW5zaW9uIG5hbWVzLlxyXG4gKiBJbiB0aGlzIGNhc2UsIHVzZXJzIGNhbiBvbmx5IHF1ZXJ5IGRhdGEgaWYgYW5kIG9ubHkgaWYgdGhleSBoYXZlIGRlZmluZWQgZGltZW5zaW9uIG5hbWVzXHJcbiAqIHZpYSBlYyBvcHRpb24sIHNvIHdlIHByb3ZpZGUgYGdldERpbWVuc2lvbkluZGV4RnJvbVNvdXJjZWAsIHdoaWNoIG9ubHkgcXVlcnkgdGhlbSBmcm9tXHJcbiAqIGBzb3VyY2VgIGRpbWVuc2lvbnMuXHJcbiAqL1xudmFyIFNlcmllc0RhdGFTY2hlbWEgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZXJpZXNEYXRhU2NoZW1hKG9wdCkge1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IG9wdC5kaW1lbnNpb25zO1xuICAgIHRoaXMuX2RpbU9taXR0ZWQgPSBvcHQuZGltZW5zaW9uT21pdHRlZDtcbiAgICB0aGlzLnNvdXJjZSA9IG9wdC5zb3VyY2U7XG4gICAgdGhpcy5fZnVsbERpbUNvdW50ID0gb3B0LmZ1bGxEaW1lbnNpb25Db3VudDtcbiAgICB0aGlzLl91cGRhdGVEaW1PbWl0dGVkKG9wdC5kaW1lbnNpb25PbWl0dGVkKTtcbiAgfVxuICBTZXJpZXNEYXRhU2NoZW1hLnByb3RvdHlwZS5pc0RpbWVuc2lvbk9taXR0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpbU9taXR0ZWQ7XG4gIH07XG4gIFNlcmllc0RhdGFTY2hlbWEucHJvdG90eXBlLl91cGRhdGVEaW1PbWl0dGVkID0gZnVuY3Rpb24gKGRpbWVuc2lvbk9taXR0ZWQpIHtcbiAgICB0aGlzLl9kaW1PbWl0dGVkID0gZGltZW5zaW9uT21pdHRlZDtcbiAgICBpZiAoIWRpbWVuc2lvbk9taXR0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kaW1OYW1lTWFwKSB7XG4gICAgICB0aGlzLl9kaW1OYW1lTWFwID0gZW5zdXJlU291cmNlRGltTmFtZU1hcCh0aGlzLnNvdXJjZSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBAY2F1dGlvbiBDYW4gb25seSBiZSB1c2VkIHdoZW4gYGRpbWVuc2lvbk9taXR0ZWQ6IHRydWVgLlxyXG4gICAqXHJcbiAgICogR2V0IGluZGV4IGJ5IHVzZXIgZGVmaW5lZCBkaW1lbnNpb24gbmFtZSAoaS5lLiwgbm90IGludGVybmFsIGdlbmVyYXRlIG5hbWUpLlxyXG4gICAqIFRoYXQgaXMsIGdldCBpbmRleCBmcm9tIGBkaW1lbnNpb25zRGVmaW5lYC5cclxuICAgKiBJZiBubyBgZGltZW5zaW9uc0RlZmluZWAsIG9yIG5vIG5hbWUgZ2V0LCByZXR1cm4gLTEuXHJcbiAgICovXG4gIFNlcmllc0RhdGFTY2hlbWEucHJvdG90eXBlLmdldFNvdXJjZURpbWVuc2lvbkluZGV4ID0gZnVuY3Rpb24gKGRpbU5hbWUpIHtcbiAgICByZXR1cm4gcmV0cmlldmUyKHRoaXMuX2RpbU5hbWVNYXAuZ2V0KGRpbU5hbWUpLCAtMSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBjYXV0aW9uIENhbiBvbmx5IGJlIHVzZWQgd2hlbiBgZGltZW5zaW9uT21pdHRlZDogdHJ1ZWAuXHJcbiAgICpcclxuICAgKiBOb3RpY2U6IG1heSByZXR1cm4gYG51bGxgL2B1bmRlZmluZWRgIGlmIHVzZXIgbm90IHNwZWNpZnkgZGltZW5zaW9uIG5hbWVzLlxyXG4gICAqL1xuICBTZXJpZXNEYXRhU2NoZW1hLnByb3RvdHlwZS5nZXRTb3VyY2VEaW1lbnNpb24gPSBmdW5jdGlvbiAoZGltSW5kZXgpIHtcbiAgICB2YXIgZGltZW5zaW9uc0RlZmluZSA9IHRoaXMuc291cmNlLmRpbWVuc2lvbnNEZWZpbmU7XG4gICAgaWYgKGRpbWVuc2lvbnNEZWZpbmUpIHtcbiAgICAgIHJldHVybiBkaW1lbnNpb25zRGVmaW5lW2RpbUluZGV4XTtcbiAgICB9XG4gIH07XG4gIFNlcmllc0RhdGFTY2hlbWEucHJvdG90eXBlLm1ha2VTdG9yZVNjaGVtYSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGltQ291bnQgPSB0aGlzLl9mdWxsRGltQ291bnQ7XG4gICAgdmFyIHdpbGxSZXRyaWV2ZURhdGFCeU5hbWUgPSBzaG91bGRSZXRyaWV2ZURhdGFCeU5hbWUodGhpcy5zb3VyY2UpO1xuICAgIHZhciBtYWtlSGFzaFN0cmljdCA9ICFzaG91bGRPbWl0VW51c2VkRGltZW5zaW9ucyhkaW1Db3VudCk7XG4gICAgLy8gSWYgc291cmNlIGRvbid0IGhhdmUgZGltZW5zaW9ucyBvciBzZXJpZXMgZG9uJ3Qgb21pdCB1bnNlZCBkaW1lbnNpb25zLlxuICAgIC8vIEdlbmVyYXRlIGZyb20gc2VyaWVzRGltTGlzdCBkaXJlY3RseVxuICAgIHZhciBkaW1IYXNoID0gJyc7XG4gICAgdmFyIGRpbXMgPSBbXTtcbiAgICBmb3IgKHZhciBmdWxsRGltSWR4ID0gMCwgc2VyaWVzRGltSWR4ID0gMDsgZnVsbERpbUlkeCA8IGRpbUNvdW50OyBmdWxsRGltSWR4KyspIHtcbiAgICAgIHZhciBwcm9wZXJ0eSA9IHZvaWQgMDtcbiAgICAgIHZhciB0eXBlID0gdm9pZCAwO1xuICAgICAgdmFyIG9yZGluYWxNZXRhID0gdm9pZCAwO1xuICAgICAgdmFyIHNlcmllc0RpbURlZiA9IHRoaXMuZGltZW5zaW9uc1tzZXJpZXNEaW1JZHhdO1xuICAgICAgLy8gVGhlIGxpc3QgaGFzIGJlZW4gc29ydGVkIGJ5IGBzdG9yZURpbUluZGV4YCBhc2MuXG4gICAgICBpZiAoc2VyaWVzRGltRGVmICYmIHNlcmllc0RpbURlZi5zdG9yZURpbUluZGV4ID09PSBmdWxsRGltSWR4KSB7XG4gICAgICAgIHByb3BlcnR5ID0gd2lsbFJldHJpZXZlRGF0YUJ5TmFtZSA/IHNlcmllc0RpbURlZi5uYW1lIDogbnVsbDtcbiAgICAgICAgdHlwZSA9IHNlcmllc0RpbURlZi50eXBlO1xuICAgICAgICBvcmRpbmFsTWV0YSA9IHNlcmllc0RpbURlZi5vcmRpbmFsTWV0YTtcbiAgICAgICAgc2VyaWVzRGltSWR4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc291cmNlRGltRGVmID0gdGhpcy5nZXRTb3VyY2VEaW1lbnNpb24oZnVsbERpbUlkeCk7XG4gICAgICAgIGlmIChzb3VyY2VEaW1EZWYpIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IHdpbGxSZXRyaWV2ZURhdGFCeU5hbWUgPyBzb3VyY2VEaW1EZWYubmFtZSA6IG51bGw7XG4gICAgICAgICAgdHlwZSA9IHNvdXJjZURpbURlZi50eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkaW1zLnB1c2goe1xuICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIG9yZGluYWxNZXRhOiBvcmRpbmFsTWV0YVxuICAgICAgfSk7XG4gICAgICAvLyBJZiByZXRyaWV2aW5nIGRhdGEgYnkgaW5kZXgsXG4gICAgICAvLyAgIHVzZSA8aW5kZXgsIHR5cGUsIG9yZGluYWxNZXRhPiB0byBkZXRlcm1pbmUgd2hldGhlciBkYXRhIGNhbiBiZSBzaGFyZWQuXG4gICAgICAvLyAgIChCZWNhdXNlIGluIHRoaXMgY2FzZSB0aGVyZSBtaWdodCBiZSBubyBkaW1lbnNpb24gbmFtZSBkZWZpbmVkIGluIGRhdGFzZXQsIGJ1dCBpbmRpY2VzIGFsd2F5cyBleGlzdHMpLlxuICAgICAgLy8gICAoSW5kaWNlcyBhcmUgYWx3YXlzIDAsIDEsIDIsIC4uLiwgc28gd2UgY2FuIGlnbm9yZSB0aGVtIHRvIHNob3J0ZW4gdGhlIGhhc2gpLlxuICAgICAgLy8gT3RoZXJ3aXNlIGlmIHJldHJpZXZpbmcgZGF0YSBieSBwcm9wZXJ0eSBuYW1lIChsaWtlIGBkYXRhOiBbe2FhOiAxMjMsIGJiOiA3NjV9LCAuLi5dYCksXG4gICAgICAvLyAgIHVzZSA8cHJvcGVydHksIHR5cGUsIG9yZGluYWxNZXRhPiBpbiBoYXNoLlxuICAgICAgaWYgKHdpbGxSZXRyaWV2ZURhdGFCeU5hbWUgJiYgcHJvcGVydHkgIT0gbnVsbFxuICAgICAgLy8gRm9yIGRhdGEgc3RhY2ssIHdlIGhhdmUgbWFrZSBzdXJlIGVhY2ggc2VyaWVzIGhhcyBpdHMgb3duIGRpbSBvbiB0aGlzIHN0b3JlLlxuICAgICAgLy8gU28gd2UgZG8gbm90IGFkZCBwcm9wZXJ0eSB0byBoYXNoIHRvIG1ha2Ugc3VyZSB0aGV5IGNhbiBzaGFyZSB0aGlzIHN0b3JlLlxuICAgICAgJiYgKCFzZXJpZXNEaW1EZWYgfHwgIXNlcmllc0RpbURlZi5pc0NhbGN1bGF0aW9uQ29vcmQpKSB7XG4gICAgICAgIGRpbUhhc2ggKz0gbWFrZUhhc2hTdHJpY3RcbiAgICAgICAgLy8gVXNlIGVzY2FwZSBjaGFyYWN0ZXIgJ2AnIGluIGNhc2UgdGhhdCBwcm9wZXJ0eSBuYW1lIGNvbnRhaW5zICckJy5cbiAgICAgICAgPyBwcm9wZXJ0eS5yZXBsYWNlKC9cXGAvZywgJ2AxJykucmVwbGFjZSgvXFwkL2csICdgMicpXG4gICAgICAgIC8vIEZvciBiZXR0ZXIgcGVyZm9ybWFuY2UsIHdoZW4gdGhlcmUgYXJlIGxhcmdlIGRpbWVuc2lvbnMsIHRvbGVyYW50IHRoaXMgZGVmZWN0cyB0aGF0IGhhcmRseSBtZWV0LlxuICAgICAgICA6IHByb3BlcnR5O1xuICAgICAgfVxuICAgICAgZGltSGFzaCArPSAnJCc7XG4gICAgICBkaW1IYXNoICs9IGRpbVR5cGVTaG9ydFt0eXBlXSB8fCAnZic7XG4gICAgICBpZiAob3JkaW5hbE1ldGEpIHtcbiAgICAgICAgZGltSGFzaCArPSBvcmRpbmFsTWV0YS51aWQ7XG4gICAgICB9XG4gICAgICBkaW1IYXNoICs9ICckJztcbiAgICB9XG4gICAgLy8gU291cmNlIGZyb20gZW5kcG9pbnQodXN1YWxseSBzZXJpZXMpIHdpbGwgYmUgcmVhZCBkaWZmZXJlbnRseVxuICAgIC8vIHdoZW4gc2VyaWVzTGF5b3V0Qnkgb3Igc3RhcnRJbmRleCh3aGljaCBpcyBhZmZlY3RlZCBieSBzb3VyY2VIZWFkZXIpIGFyZSBkaWZmZXJlbnQuXG4gICAgLy8gU28gd2UgdXNlIHRoaXMgdGhyZWUgcHJvcHMgYXMga2V5LlxuICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgaGFzaCA9IFtzb3VyY2Uuc2VyaWVzTGF5b3V0QnksIHNvdXJjZS5zdGFydEluZGV4LCBkaW1IYXNoXS5qb2luKCckJCcpO1xuICAgIHJldHVybiB7XG4gICAgICBkaW1lbnNpb25zOiBkaW1zLFxuICAgICAgaGFzaDogaGFzaFxuICAgIH07XG4gIH07XG4gIFNlcmllc0RhdGFTY2hlbWEucHJvdG90eXBlLm1ha2VPdXRwdXREaW1lbnNpb25OYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgZnVsbERpbUlkeCA9IDAsIHNlcmllc0RpbUlkeCA9IDA7IGZ1bGxEaW1JZHggPCB0aGlzLl9mdWxsRGltQ291bnQ7IGZ1bGxEaW1JZHgrKykge1xuICAgICAgdmFyIG5hbWVfMSA9IHZvaWQgMDtcbiAgICAgIHZhciBzZXJpZXNEaW1EZWYgPSB0aGlzLmRpbWVuc2lvbnNbc2VyaWVzRGltSWR4XTtcbiAgICAgIC8vIFRoZSBsaXN0IGhhcyBiZWVuIHNvcnRlZCBieSBgc3RvcmVEaW1JbmRleGAgYXNjLlxuICAgICAgaWYgKHNlcmllc0RpbURlZiAmJiBzZXJpZXNEaW1EZWYuc3RvcmVEaW1JbmRleCA9PT0gZnVsbERpbUlkeCkge1xuICAgICAgICBpZiAoIXNlcmllc0RpbURlZi5pc0NhbGN1bGF0aW9uQ29vcmQpIHtcbiAgICAgICAgICBuYW1lXzEgPSBzZXJpZXNEaW1EZWYubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpZXNEaW1JZHgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2VEaW1EZWYgPSB0aGlzLmdldFNvdXJjZURpbWVuc2lvbihmdWxsRGltSWR4KTtcbiAgICAgICAgaWYgKHNvdXJjZURpbURlZikge1xuICAgICAgICAgIG5hbWVfMSA9IHNvdXJjZURpbURlZi5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChuYW1lXzEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBTZXJpZXNEYXRhU2NoZW1hLnByb3RvdHlwZS5hcHBlbmRDYWxjdWxhdGlvbkRpbWVuc2lvbiA9IGZ1bmN0aW9uIChkaW1EZWYpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMucHVzaChkaW1EZWYpO1xuICAgIGRpbURlZi5pc0NhbGN1bGF0aW9uQ29vcmQgPSB0cnVlO1xuICAgIHRoaXMuX2Z1bGxEaW1Db3VudCsrO1xuICAgIC8vIElmIGFwcGVuZCBkaW1lbnNpb24gb24gYSBkYXRhIHN0b3JlLCBjb25zaWRlciB0aGUgc3RvcmVcbiAgICAvLyBtaWdodCBiZSBzaGFyZWQgYnkgZGlmZmVyZW50IHNlcmllcywgc2VyaWVzIGRpbWVuc2lvbnMgbm90XG4gICAgLy8gcmVhbGx5IG1hcCB0byBzdG9yZSBkaW1lbnNpb25zLlxuICAgIHRoaXMuX3VwZGF0ZURpbU9taXR0ZWQodHJ1ZSk7XG4gIH07XG4gIHJldHVybiBTZXJpZXNEYXRhU2NoZW1hO1xufSgpO1xuZXhwb3J0IHsgU2VyaWVzRGF0YVNjaGVtYSB9O1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2VyaWVzRGF0YVNjaGVtYShzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYSBpbnN0YW5jZW9mIFNlcmllc0RhdGFTY2hlbWE7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGltTmFtZU1hcChkaW1zRGVmKSB7XG4gIHZhciBkYXRhRGltTmFtZU1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAoZGltc0RlZiB8fCBbXSkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGltRGVmSXRlbVJhdyA9IGRpbXNEZWZbaV07XG4gICAgdmFyIHVzZXJEaW1OYW1lID0gaXNPYmplY3QoZGltRGVmSXRlbVJhdykgPyBkaW1EZWZJdGVtUmF3Lm5hbWUgOiBkaW1EZWZJdGVtUmF3O1xuICAgIGlmICh1c2VyRGltTmFtZSAhPSBudWxsICYmIGRhdGFEaW1OYW1lTWFwLmdldCh1c2VyRGltTmFtZSkgPT0gbnVsbCkge1xuICAgICAgZGF0YURpbU5hbWVNYXAuc2V0KHVzZXJEaW1OYW1lLCBpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFEaW1OYW1lTWFwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVNvdXJjZURpbU5hbWVNYXAoc291cmNlKSB7XG4gIHZhciBpbm5lclNvdXJjZSA9IGlubmVyKHNvdXJjZSk7XG4gIHJldHVybiBpbm5lclNvdXJjZS5kaW1OYW1lTWFwIHx8IChpbm5lclNvdXJjZS5kaW1OYW1lTWFwID0gY3JlYXRlRGltTmFtZU1hcChzb3VyY2UuZGltZW5zaW9uc0RlZmluZSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZE9taXRVbnVzZWREaW1lbnNpb25zKGRpbUNvdW50KSB7XG4gIHJldHVybiBkaW1Db3VudCA+IDMwO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///73632\n")},76827:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * Link lists and struct (graph or tree)\r\n */\n\n\nvar inner = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__/* .makeInner */ .$r)();\nfunction linkSeriesData(opt) {\n  var mainData = opt.mainData;\n  var datas = opt.datas;\n  if (!datas) {\n    datas = {\n      main: mainData\n    };\n    opt.datasAttr = {\n      main: \'data\'\n    };\n  }\n  opt.datas = opt.mainData = null;\n  linkAll(mainData, datas, opt);\n  // Porxy data original methods.\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(datas, function (data) {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(mainData.TRANSFERABLE_METHODS, function (methodName) {\n      data.wrapMethod(methodName, (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.curry)(transferInjection, opt));\n    });\n  });\n  // Beyond transfer, additional features should be added to `cloneShallow`.\n  mainData.wrapMethod(\'cloneShallow\', (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.curry)(cloneShallowInjection, opt));\n  // Only mainData trigger change, because struct.update may trigger\n  // another changable methods, which may bring about dead lock.\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(mainData.CHANGABLE_METHODS, function (methodName) {\n    mainData.wrapMethod(methodName, (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.curry)(changeInjection, opt));\n  });\n  // Make sure datas contains mainData.\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.assert)(datas[mainData.dataType] === mainData);\n}\nfunction transferInjection(opt, res) {\n  if (isMainData(this)) {\n    // Transfer datas to new main data.\n    var datas = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, inner(this).datas);\n    datas[this.dataType] = res;\n    linkAll(res, datas, opt);\n  } else {\n    // Modify the reference in main data to point newData.\n    linkSingle(res, this.dataType, inner(this).mainData, opt);\n  }\n  return res;\n}\nfunction changeInjection(opt, res) {\n  opt.struct && opt.struct.update();\n  return res;\n}\nfunction cloneShallowInjection(opt, res) {\n  // cloneShallow, which brings about some fragilities, may be inappropriate\n  // to be exposed as an API. So for implementation simplicity we can make\n  // the restriction that cloneShallow of not-mainData should not be invoked\n  // outside, but only be invoked here.\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(inner(res).datas, function (data, dataType) {\n    data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);\n  });\n  return res;\n}\n/**\r\n * Supplement method to List.\r\n *\r\n * @public\r\n * @param [dataType] If not specified, return mainData.\r\n */\nfunction getLinkedData(dataType) {\n  var mainData = inner(this).mainData;\n  return dataType == null || mainData == null ? mainData : inner(mainData).datas[dataType];\n}\n/**\r\n * Get list of all linked data\r\n */\nfunction getLinkedDataAll() {\n  var mainData = inner(this).mainData;\n  return mainData == null ? [{\n    data: mainData\n  }] : (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.keys)(inner(mainData).datas), function (type) {\n    return {\n      type: type,\n      data: inner(mainData).datas[type]\n    };\n  });\n}\nfunction isMainData(data) {\n  return inner(data).mainData === data;\n}\nfunction linkAll(mainData, datas, opt) {\n  inner(mainData).datas = {};\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(datas, function (data, dataType) {\n    linkSingle(data, dataType, mainData, opt);\n  });\n}\nfunction linkSingle(data, dataType, mainData, opt) {\n  inner(mainData).datas[dataType] = data;\n  inner(data).mainData = mainData;\n  data.dataType = dataType;\n  if (opt.struct) {\n    data[opt.structAttr] = opt.struct;\n    opt.struct[opt.datasAttr[dataType]] = data;\n  }\n  // Supplement method.\n  data.getLinkedData = getLinkedData;\n  data.getLinkedDataAll = getLinkedDataAll;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (linkSeriesData);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY4MjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvbGlua1Nlcmllc0RhdGEuanM/OTRkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbi8qKlxyXG4gKiBMaW5rIGxpc3RzIGFuZCBzdHJ1Y3QgKGdyYXBoIG9yIHRyZWUpXHJcbiAqL1xuaW1wb3J0IHsgY3VycnksIGVhY2gsIGFzc2VydCwgZXh0ZW5kLCBtYXAsIGtleXMgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHsgbWFrZUlubmVyIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG52YXIgaW5uZXIgPSBtYWtlSW5uZXIoKTtcbmZ1bmN0aW9uIGxpbmtTZXJpZXNEYXRhKG9wdCkge1xuICB2YXIgbWFpbkRhdGEgPSBvcHQubWFpbkRhdGE7XG4gIHZhciBkYXRhcyA9IG9wdC5kYXRhcztcbiAgaWYgKCFkYXRhcykge1xuICAgIGRhdGFzID0ge1xuICAgICAgbWFpbjogbWFpbkRhdGFcbiAgICB9O1xuICAgIG9wdC5kYXRhc0F0dHIgPSB7XG4gICAgICBtYWluOiAnZGF0YSdcbiAgICB9O1xuICB9XG4gIG9wdC5kYXRhcyA9IG9wdC5tYWluRGF0YSA9IG51bGw7XG4gIGxpbmtBbGwobWFpbkRhdGEsIGRhdGFzLCBvcHQpO1xuICAvLyBQb3J4eSBkYXRhIG9yaWdpbmFsIG1ldGhvZHMuXG4gIGVhY2goZGF0YXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZWFjaChtYWluRGF0YS5UUkFOU0ZFUkFCTEVfTUVUSE9EUywgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgIGRhdGEud3JhcE1ldGhvZChtZXRob2ROYW1lLCBjdXJyeSh0cmFuc2ZlckluamVjdGlvbiwgb3B0KSk7XG4gICAgfSk7XG4gIH0pO1xuICAvLyBCZXlvbmQgdHJhbnNmZXIsIGFkZGl0aW9uYWwgZmVhdHVyZXMgc2hvdWxkIGJlIGFkZGVkIHRvIGBjbG9uZVNoYWxsb3dgLlxuICBtYWluRGF0YS53cmFwTWV0aG9kKCdjbG9uZVNoYWxsb3cnLCBjdXJyeShjbG9uZVNoYWxsb3dJbmplY3Rpb24sIG9wdCkpO1xuICAvLyBPbmx5IG1haW5EYXRhIHRyaWdnZXIgY2hhbmdlLCBiZWNhdXNlIHN0cnVjdC51cGRhdGUgbWF5IHRyaWdnZXJcbiAgLy8gYW5vdGhlciBjaGFuZ2FibGUgbWV0aG9kcywgd2hpY2ggbWF5IGJyaW5nIGFib3V0IGRlYWQgbG9jay5cbiAgZWFjaChtYWluRGF0YS5DSEFOR0FCTEVfTUVUSE9EUywgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICBtYWluRGF0YS53cmFwTWV0aG9kKG1ldGhvZE5hbWUsIGN1cnJ5KGNoYW5nZUluamVjdGlvbiwgb3B0KSk7XG4gIH0pO1xuICAvLyBNYWtlIHN1cmUgZGF0YXMgY29udGFpbnMgbWFpbkRhdGEuXG4gIGFzc2VydChkYXRhc1ttYWluRGF0YS5kYXRhVHlwZV0gPT09IG1haW5EYXRhKTtcbn1cbmZ1bmN0aW9uIHRyYW5zZmVySW5qZWN0aW9uKG9wdCwgcmVzKSB7XG4gIGlmIChpc01haW5EYXRhKHRoaXMpKSB7XG4gICAgLy8gVHJhbnNmZXIgZGF0YXMgdG8gbmV3IG1haW4gZGF0YS5cbiAgICB2YXIgZGF0YXMgPSBleHRlbmQoe30sIGlubmVyKHRoaXMpLmRhdGFzKTtcbiAgICBkYXRhc1t0aGlzLmRhdGFUeXBlXSA9IHJlcztcbiAgICBsaW5rQWxsKHJlcywgZGF0YXMsIG9wdCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTW9kaWZ5IHRoZSByZWZlcmVuY2UgaW4gbWFpbiBkYXRhIHRvIHBvaW50IG5ld0RhdGEuXG4gICAgbGlua1NpbmdsZShyZXMsIHRoaXMuZGF0YVR5cGUsIGlubmVyKHRoaXMpLm1haW5EYXRhLCBvcHQpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjaGFuZ2VJbmplY3Rpb24ob3B0LCByZXMpIHtcbiAgb3B0LnN0cnVjdCAmJiBvcHQuc3RydWN0LnVwZGF0ZSgpO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY2xvbmVTaGFsbG93SW5qZWN0aW9uKG9wdCwgcmVzKSB7XG4gIC8vIGNsb25lU2hhbGxvdywgd2hpY2ggYnJpbmdzIGFib3V0IHNvbWUgZnJhZ2lsaXRpZXMsIG1heSBiZSBpbmFwcHJvcHJpYXRlXG4gIC8vIHRvIGJlIGV4cG9zZWQgYXMgYW4gQVBJLiBTbyBmb3IgaW1wbGVtZW50YXRpb24gc2ltcGxpY2l0eSB3ZSBjYW4gbWFrZVxuICAvLyB0aGUgcmVzdHJpY3Rpb24gdGhhdCBjbG9uZVNoYWxsb3cgb2Ygbm90LW1haW5EYXRhIHNob3VsZCBub3QgYmUgaW52b2tlZFxuICAvLyBvdXRzaWRlLCBidXQgb25seSBiZSBpbnZva2VkIGhlcmUuXG4gIGVhY2goaW5uZXIocmVzKS5kYXRhcywgZnVuY3Rpb24gKGRhdGEsIGRhdGFUeXBlKSB7XG4gICAgZGF0YSAhPT0gcmVzICYmIGxpbmtTaW5nbGUoZGF0YS5jbG9uZVNoYWxsb3coKSwgZGF0YVR5cGUsIHJlcywgb3B0KTtcbiAgfSk7XG4gIHJldHVybiByZXM7XG59XG4vKipcclxuICogU3VwcGxlbWVudCBtZXRob2QgdG8gTGlzdC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gW2RhdGFUeXBlXSBJZiBub3Qgc3BlY2lmaWVkLCByZXR1cm4gbWFpbkRhdGEuXHJcbiAqL1xuZnVuY3Rpb24gZ2V0TGlua2VkRGF0YShkYXRhVHlwZSkge1xuICB2YXIgbWFpbkRhdGEgPSBpbm5lcih0aGlzKS5tYWluRGF0YTtcbiAgcmV0dXJuIGRhdGFUeXBlID09IG51bGwgfHwgbWFpbkRhdGEgPT0gbnVsbCA/IG1haW5EYXRhIDogaW5uZXIobWFpbkRhdGEpLmRhdGFzW2RhdGFUeXBlXTtcbn1cbi8qKlxyXG4gKiBHZXQgbGlzdCBvZiBhbGwgbGlua2VkIGRhdGFcclxuICovXG5mdW5jdGlvbiBnZXRMaW5rZWREYXRhQWxsKCkge1xuICB2YXIgbWFpbkRhdGEgPSBpbm5lcih0aGlzKS5tYWluRGF0YTtcbiAgcmV0dXJuIG1haW5EYXRhID09IG51bGwgPyBbe1xuICAgIGRhdGE6IG1haW5EYXRhXG4gIH1dIDogbWFwKGtleXMoaW5uZXIobWFpbkRhdGEpLmRhdGFzKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGRhdGE6IGlubmVyKG1haW5EYXRhKS5kYXRhc1t0eXBlXVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNNYWluRGF0YShkYXRhKSB7XG4gIHJldHVybiBpbm5lcihkYXRhKS5tYWluRGF0YSA9PT0gZGF0YTtcbn1cbmZ1bmN0aW9uIGxpbmtBbGwobWFpbkRhdGEsIGRhdGFzLCBvcHQpIHtcbiAgaW5uZXIobWFpbkRhdGEpLmRhdGFzID0ge307XG4gIGVhY2goZGF0YXMsIGZ1bmN0aW9uIChkYXRhLCBkYXRhVHlwZSkge1xuICAgIGxpbmtTaW5nbGUoZGF0YSwgZGF0YVR5cGUsIG1haW5EYXRhLCBvcHQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGxpbmtTaW5nbGUoZGF0YSwgZGF0YVR5cGUsIG1haW5EYXRhLCBvcHQpIHtcbiAgaW5uZXIobWFpbkRhdGEpLmRhdGFzW2RhdGFUeXBlXSA9IGRhdGE7XG4gIGlubmVyKGRhdGEpLm1haW5EYXRhID0gbWFpbkRhdGE7XG4gIGRhdGEuZGF0YVR5cGUgPSBkYXRhVHlwZTtcbiAgaWYgKG9wdC5zdHJ1Y3QpIHtcbiAgICBkYXRhW29wdC5zdHJ1Y3RBdHRyXSA9IG9wdC5zdHJ1Y3Q7XG4gICAgb3B0LnN0cnVjdFtvcHQuZGF0YXNBdHRyW2RhdGFUeXBlXV0gPSBkYXRhO1xuICB9XG4gIC8vIFN1cHBsZW1lbnQgbWV0aG9kLlxuICBkYXRhLmdldExpbmtlZERhdGEgPSBnZXRMaW5rZWREYXRhO1xuICBkYXRhLmdldExpbmtlZERhdGFBbGwgPSBnZXRMaW5rZWREYXRhQWxsO1xufVxuZXhwb3J0IGRlZmF1bHQgbGlua1Nlcmllc0RhdGE7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///76827\n')},77775:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  _0: () => (/* reexport */ Axis/* default */.A),\n  OZ: () => (/* reexport */ Chart/* default */.A),\n  jT: () => (/* reexport */ Component/* default */.A),\n  bR: () => (/* reexport */ view_Component/* default */.A),\n  B8: () => (/* reexport */ SeriesData/* default */.A),\n  Kx: () => (/* reexport */ Model/* default */.A),\n  FQ: () => (/* reexport */ echarts/* PRIORITY */.FQ),\n  rP: () => (/* reexport */ Series/* default */.A),\n  yW: () => (/* reexport */ color),\n  Ng: () => (/* reexport */ echarts/* connect */.Ng),\n  p5: () => (/* reexport */ echarts/* dataTool */.p5),\n  El: () => (/* reexport */ echarts/* dependencies */.El),\n  zm: () => (/* reexport */ echarts/* disConnect */.zm),\n  Zf: () => (/* reexport */ echarts/* disconnect */.Zf),\n  AS: () => (/* reexport */ echarts/* dispose */.AS),\n  _K: () => (/* reexport */ env/* default */.A),\n  yX: () => (/* reexport */ extendChartView),\n  rt: () => (/* reexport */ extendComponentModel),\n  NO: () => (/* reexport */ extendComponentView),\n  NA: () => (/* reexport */ extendSeriesModel),\n  GP: () => (/* reexport */ format_namespaceObject),\n  Bo: () => (/* reexport */ echarts/* getCoordinateSystemDimensions */.Bo),\n  FP: () => (/* reexport */ echarts/* getInstanceByDom */.FP),\n  aQ: () => (/* reexport */ echarts/* getInstanceById */.aQ),\n  ZB: () => (/* reexport */ echarts/* getMap */.ZB),\n  fA: () => (/* reexport */ graphic_namespaceObject),\n  dw: () => (/* reexport */ helper_namespaceObject),\n  Ts: () => (/* reexport */ echarts/* init */.Ts),\n  UU: () => (/* reexport */ canvas_graphic/* brushSingle */.Xi),\n  UP: () => (/* reexport */ matrix),\n  ai: () => (/* reexport */ number_namespaceObject),\n  l3: () => (/* reexport */ parseGeoJson/* default */.A),\n  zI: () => (/* reexport */ parseGeoJson/* default */.A),\n  OH: () => (/* reexport */ echarts/* registerAction */.OH),\n  pX: () => (/* reexport */ echarts/* registerCoordinateSystem */.pX),\n  Oh: () => (/* reexport */ echarts/* registerLayout */.Oh),\n  Ej: () => (/* reexport */ echarts/* registerLoading */.Ej),\n  E: () => (/* reexport */ echarts/* registerLocale */.E),\n  mz: () => (/* reexport */ echarts/* registerMap */.mz),\n  cf: () => (/* reexport */ echarts/* registerPostInit */.cf),\n  tb: () => (/* reexport */ echarts/* registerPostUpdate */.tb),\n  lP: () => (/* reexport */ echarts/* registerPreprocessor */.lP),\n  qg: () => (/* reexport */ echarts/* registerProcessor */.qg),\n  bf: () => (/* reexport */ echarts/* registerTheme */.bf),\n  iY: () => (/* reexport */ echarts/* registerTransform */.iY),\n  xV: () => (/* reexport */ echarts/* registerUpdateLifecycle */.xV),\n  AF: () => (/* reexport */ echarts/* registerVisual */.AF),\n  vV: () => (/* reexport */ echarts/* setCanvasCreator */.vV),\n  Gs: () => (/* reexport */ platform/* setPlatformAPI */.Gs),\n  nF: () => (/* reexport */ throttle/* throttle */.nF),\n  kB: () => (/* reexport */ time_namespaceObject),\n  Yx: () => (/* reexport */ extension/* use */.Y),\n  ZS: () => (/* reexport */ util_namespaceObject),\n  i1: () => (/* reexport */ vector),\n  rE: () => (/* reexport */ echarts/* version */.rE),\n  F_: () => (/* reexport */ util),\n  nd: () => (/* reexport */ zrender)\n});\n\n// NAMESPACE OBJECT: ./node_modules/echarts/lib/export/api/helper.js\nvar helper_namespaceObject = {};\n__webpack_require__.r(helper_namespaceObject);\n__webpack_require__.d(helper_namespaceObject, {\n  createDimensions: () => (createDimensions/* createDimensions */.M),\n  createList: () => (createList),\n  createScale: () => (createScale),\n  createSymbol: () => (symbol/* createSymbol */.v5),\n  createTextStyle: () => (createTextStyle),\n  dataStack: () => (dataStack),\n  enableHoverEmphasis: () => (states/* enableHoverEmphasis */.iJ),\n  getECData: () => (innerStore/* getECData */.z),\n  getLayoutRect: () => (layout/* getLayoutRect */.dV),\n  mixinAxisModelCommonMethods: () => (mixinAxisModelCommonMethods)\n});\n\n// NAMESPACE OBJECT: ./node_modules/echarts/lib/export/api/number.js\nvar number_namespaceObject = {};\n__webpack_require__.r(number_namespaceObject);\n__webpack_require__.d(number_namespaceObject, {\n  MAX_SAFE_INTEGER: () => (number/* MAX_SAFE_INTEGER */.Is),\n  asc: () => (number/* asc */.Y6),\n  getPercentWithPrecision: () => (number/* getPercentWithPrecision */.wp),\n  getPixelPrecision: () => (number/* getPixelPrecision */.hb),\n  getPrecision: () => (number/* getPrecision */.XV),\n  getPrecisionSafe: () => (number/* getPrecisionSafe */.y6),\n  isNumeric: () => (number/* isNumeric */.kf),\n  isRadianAroundZero: () => (number/* isRadianAroundZero */.dh),\n  linearMap: () => (number/* linearMap */.Cb),\n  nice: () => (number/* nice */.Cm),\n  numericToNumber: () => (number/* numericToNumber */.Sm),\n  parseDate: () => (number/* parseDate */._U),\n  quantile: () => (number/* quantile */.YV),\n  quantity: () => (number/* quantity */.au),\n  quantityExponent: () => (number/* quantityExponent */.NX),\n  reformIntervals: () => (number/* reformIntervals */.sL),\n  remRadian: () => (number/* remRadian */._7),\n  round: () => (number/* round */.LI)\n});\n\n// NAMESPACE OBJECT: ./node_modules/echarts/lib/export/api/time.js\nvar time_namespaceObject = {};\n__webpack_require__.r(time_namespaceObject);\n__webpack_require__.d(time_namespaceObject, {\n  format: () => (time/* format */.GP),\n  parse: () => (number/* parseDate */._U)\n});\n\n// NAMESPACE OBJECT: ./node_modules/echarts/lib/export/api/graphic.js\nvar graphic_namespaceObject = {};\n__webpack_require__.r(graphic_namespaceObject);\n__webpack_require__.d(graphic_namespaceObject, {\n  Arc: () => (Arc/* default */.A),\n  BezierCurve: () => (BezierCurve/* default */.A),\n  BoundingRect: () => (BoundingRect/* default */.A),\n  Circle: () => (Circle/* default */.A),\n  CompoundPath: () => (CompoundPath/* default */.A),\n  Ellipse: () => (Ellipse/* default */.A),\n  Group: () => (Group/* default */.A),\n  Image: () => (Image/* default */.Ay),\n  IncrementalDisplayable: () => (IncrementalDisplayable/* default */.A),\n  Line: () => (Line/* default */.A),\n  LinearGradient: () => (LinearGradient/* default */.A),\n  Polygon: () => (Polygon/* default */.A),\n  Polyline: () => (Polyline/* default */.A),\n  RadialGradient: () => (RadialGradient/* default */.A),\n  Rect: () => (Rect/* default */.A),\n  Ring: () => (Ring/* default */.A),\n  Sector: () => (Sector/* default */.A),\n  Text: () => (Text/* default */.Ay),\n  clipPointsByRect: () => (graphic.clipPointsByRect),\n  clipRectByRect: () => (graphic.clipRectByRect),\n  createIcon: () => (graphic.createIcon),\n  extendPath: () => (graphic.extendPath),\n  extendShape: () => (graphic.extendShape),\n  getShapeClass: () => (graphic.getShapeClass),\n  getTransform: () => (graphic.getTransform),\n  initProps: () => (basicTransition/* initProps */.LW),\n  makeImage: () => (graphic.makeImage),\n  makePath: () => (graphic.makePath),\n  mergePath: () => (graphic.mergePath),\n  registerShape: () => (graphic.registerShape),\n  resizePath: () => (graphic.resizePath),\n  updateProps: () => (basicTransition/* updateProps */.oi)\n});\n\n// NAMESPACE OBJECT: ./node_modules/echarts/lib/export/api/format.js\nvar format_namespaceObject = {};\n__webpack_require__.r(format_namespaceObject);\n__webpack_require__.d(format_namespaceObject, {\n  addCommas: () => (format/* addCommas */.ob),\n  capitalFirst: () => (format/* capitalFirst */.x5),\n  encodeHTML: () => (dom/* encodeHTML */.Me),\n  formatTime: () => (format/* formatTime */.fU),\n  formatTpl: () => (format/* formatTpl */.YK),\n  getTextRect: () => (getTextRect/* getTextRect */.k),\n  getTooltipMarker: () => (format/* getTooltipMarker */.qg),\n  normalizeCssArray: () => (format/* normalizeCssArray */.QX),\n  toCamelCase: () => (format/* toCamelCase */.Cb),\n  truncateText: () => (parseText/* truncateText */.EJ)\n});\n\n// NAMESPACE OBJECT: ./node_modules/echarts/lib/export/api/util.js\nvar util_namespaceObject = {};\n__webpack_require__.r(util_namespaceObject);\n__webpack_require__.d(util_namespaceObject, {\n  bind: () => (util.bind),\n  clone: () => (util.clone),\n  curry: () => (util.curry),\n  defaults: () => (util.defaults),\n  each: () => (util.each),\n  extend: () => (util.extend),\n  filter: () => (util.filter),\n  indexOf: () => (util.indexOf),\n  inherits: () => (util.inherits),\n  isArray: () => (util.isArray),\n  isFunction: () => (util.isFunction),\n  isObject: () => (util.isObject),\n  isString: () => (util.isString),\n  map: () => (util.map),\n  merge: () => (util.merge),\n  reduce: () => (util.reduce)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/core/echarts.js + 3 modules\nvar echarts = __webpack_require__(95383);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Component.js\nvar Component = __webpack_require__(15915);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar view_Component = __webpack_require__(59109);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/SeriesData.js\nvar SeriesData = __webpack_require__(6006);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/zrender.js\nvar zrender = __webpack_require__(33572);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/matrix.js\nvar matrix = __webpack_require__(45587);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/vector.js\nvar vector = __webpack_require__(83509);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/tool/color.js\nvar color = __webpack_require__(47698);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/throttle.js\nvar throttle = __webpack_require__(24711);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createSeriesData.js\nvar createSeriesData = __webpack_require__(13637);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/axisHelper.js\nvar axisHelper = __webpack_require__(99031);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/axisModelCommonMixin.js\nvar axisModelCommonMixin = __webpack_require__(12462);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Model.js + 2 modules\nvar Model = __webpack_require__(43172);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/dataStackHelper.js\nvar dataStackHelper = __webpack_require__(65008);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/createDimensions.js\nvar createDimensions = __webpack_require__(97351);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/symbol.js\nvar symbol = __webpack_require__(62103);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n;// ./node_modules/echarts/lib/export/api/helper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * This module exposes helper functions for developing extensions.\r\n */\n\n\n// import createGraphFromNodeEdge from \'./chart/helper/createGraphFromNodeEdge.js\';\n\n\n\n\n\n\n\n/**\r\n * Create a multi dimension List structure from seriesModel.\r\n */\nfunction createList(seriesModel) {\n  return (0,createSeriesData/* default */.A)(null, seriesModel);\n}\n// export function createGraph(seriesModel) {\n//     let nodes = seriesModel.get(\'data\');\n//     let links = seriesModel.get(\'links\');\n//     return createGraphFromNodeEdge(nodes, links, seriesModel);\n// }\n\n\nvar dataStack = {\n  isDimensionStacked: dataStackHelper/* isDimensionStacked */.sJ,\n  enableDataStack: dataStackHelper/* enableDataStack */.iJ,\n  getStackedDimension: dataStackHelper/* getStackedDimension */.me\n};\n/**\r\n * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\r\n * @param {string} symbolDesc\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {number} w\r\n * @param {number} h\r\n * @param {string} color\r\n */\n\n/**\r\n * Create scale\r\n * @param {Array.<number>} dataExtent\r\n * @param {Object|module:echarts/Model} option If `optoin.type`\r\n *        is secified, it can only be `\'value\'` currently.\r\n */\nfunction createScale(dataExtent, option) {\n  var axisModel = option;\n  if (!(option instanceof Model/* default */.A)) {\n    axisModel = new Model/* default */.A(option);\n    // FIXME\n    // Currently AxisModelCommonMixin has nothing to do with the\n    // the requirements of `axisHelper.createScaleByModel`. For\n    // example the methods `getCategories` and `getOrdinalMeta`\n    // are required for `\'category\'` axis, and ecModel is required\n    // for `\'time\'` axis. But occasionally echarts-gl happened\n    // to only use `\'value\'` axis.\n    // zrUtil.mixin(axisModel, AxisModelCommonMixin);\n  }\n  var scale = axisHelper/* createScaleByModel */.f$(axisModel);\n  scale.setExtent(dataExtent[0], dataExtent[1]);\n  axisHelper/* niceScaleExtent */.af(scale, axisModel);\n  return scale;\n}\n/**\r\n * Mixin common methods to axis model,\r\n *\r\n * Include methods\r\n * `getFormattedLabels() => Array.<string>`\r\n * `getCategories() => Array.<string>`\r\n * `getMin(origin: boolean) => number`\r\n * `getMax(origin: boolean) => number`\r\n * `getNeedCrossZero() => boolean`\r\n */\nfunction mixinAxisModelCommonMethods(Model) {\n  util.mixin(Model, axisModelCommonMixin/* AxisModelCommonMixin */.L);\n}\n\n\nfunction createTextStyle(textStyleModel, opts) {\n  opts = opts || {};\n  return (0,labelStyle/* createTextStyle */.VB)(textStyleModel, null, null, opts.state !== \'normal\');\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/extension.js\nvar extension = __webpack_require__(3087);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/platform.js\nvar platform = __webpack_require__(59741);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/geo/parseGeoJson.js\nvar parseGeoJson = __webpack_require__(69718);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n;// ./node_modules/echarts/lib/export/api/number.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/time.js\nvar time = __webpack_require__(55854);\n;// ./node_modules/echarts/lib/export/api/time.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Image.js\nvar Image = __webpack_require__(90540);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Circle.js\nvar Circle = __webpack_require__(31571);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Ellipse.js\nvar Ellipse = __webpack_require__(18393);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Sector.js + 1 modules\nvar Sector = __webpack_require__(25014);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Ring.js\nvar Ring = __webpack_require__(42933);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polygon.js\nvar Polygon = __webpack_require__(52505);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polyline.js\nvar Polyline = __webpack_require__(39195);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Line.js\nvar Line = __webpack_require__(82861);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/BezierCurve.js\nvar BezierCurve = __webpack_require__(53849);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Arc.js\nvar Arc = __webpack_require__(43471);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/IncrementalDisplayable.js\nvar IncrementalDisplayable = __webpack_require__(2995);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/CompoundPath.js\nvar CompoundPath = __webpack_require__(82591);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/LinearGradient.js\nvar LinearGradient = __webpack_require__(29668);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/RadialGradient.js\nvar RadialGradient = __webpack_require__(82250);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/BoundingRect.js\nvar BoundingRect = __webpack_require__(29308);\n;// ./node_modules/echarts/lib/export/api/graphic.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/format.js\nvar format = __webpack_require__(83412);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/dom.js + 1 modules\nvar dom = __webpack_require__(29687);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/helper/parseText.js\nvar parseText = __webpack_require__(62406);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/legacy/getTextRect.js\nvar getTextRect = __webpack_require__(43353);\n;// ./node_modules/echarts/lib/export/api/format.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n;// ./node_modules/echarts/lib/export/api/util.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/env.js\nvar env = __webpack_require__(38123);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/Axis.js\nvar Axis = __webpack_require__(1727);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/canvas/graphic.js\nvar canvas_graphic = __webpack_require__(29571);\n;// ./node_modules/echarts/lib/export/api.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// These APIs are for more advanced usages\n// For example extend charts and components, creating graphic elements, formatting.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// --------------------- Helper Methods ---------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n// --------------------- Export for Extension Usage ---------------------\n// export {SeriesData};\n // TODO: Compatitable with exists echarts-gl code\n\n\n\n// Only for GL\n\n// --------------------- Deprecated Extension Methods ---------------------\n// Should use `ComponentModel.extend` or `class XXXX extend ComponentModel` to create class.\n// Then use `registerComponentModel` in `install` parameter when `use` this extension. For example:\n// class Bar3DModel extends ComponentModel {}\n// export function install(registers) { registers.registerComponentModel(Bar3DModel); }\n// echarts.use(install);\nfunction extendComponentModel(proto) {\n  var Model = Component/* default */.A.extend(proto);\n  Component/* default */.A.registerClass(Model);\n  return Model;\n}\nfunction extendComponentView(proto) {\n  var View = view_Component/* default */.A.extend(proto);\n  view_Component/* default */.A.registerClass(View);\n  return View;\n}\nfunction extendSeriesModel(proto) {\n  var Model = Series/* default */.A.extend(proto);\n  Series/* default */.A.registerClass(Model);\n  return Model;\n}\nfunction extendChartView(proto) {\n  var View = Chart/* default */.A.extend(proto);\n  Chart/* default */.A.registerClass(View);\n  return View;\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/installLabelLayout.js + 1 modules\nvar installLabelLayout = __webpack_require__(35278);\n;// ./node_modules/echarts/lib/export/core.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// Core API from echarts/src/echarts\n\n\n\n// Import label layout by default.\n// TODO will be treeshaked.\n\n(0,extension/* use */.Y)(installLabelLayout/* installLabelLayout */._);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc3NzUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2V4cG9ydC9hcGkvaGVscGVyLmpzP2Y2NWEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2V4cG9ydC9hcGkvbnVtYmVyLmpzPzdlZjAiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2V4cG9ydC9hcGkvdGltZS5qcz82MTZkIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9leHBvcnQvYXBpL2dyYXBoaWMuanM/NWI4YiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZXhwb3J0L2FwaS9mb3JtYXQuanM/M2ZkMiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZXhwb3J0L2FwaS91dGlsLmpzP2U5MzQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2V4cG9ydC9hcGkuanM/ODRkZCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZXhwb3J0L2NvcmUuanM/OTlkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbi8qKlxyXG4gKiBUaGlzIG1vZHVsZSBleHBvc2VzIGhlbHBlciBmdW5jdGlvbnMgZm9yIGRldmVsb3BpbmcgZXh0ZW5zaW9ucy5cclxuICovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBjcmVhdGVTZXJpZXNEYXRhIGZyb20gJy4uLy4uL2NoYXJ0L2hlbHBlci9jcmVhdGVTZXJpZXNEYXRhLmpzJztcbi8vIGltcG9ydCBjcmVhdGVHcmFwaEZyb21Ob2RlRWRnZSBmcm9tICcuL2NoYXJ0L2hlbHBlci9jcmVhdGVHcmFwaEZyb21Ob2RlRWRnZS5qcyc7XG5pbXBvcnQgKiBhcyBheGlzSGVscGVyIGZyb20gJy4uLy4uL2Nvb3JkL2F4aXNIZWxwZXIuanMnO1xuaW1wb3J0IHsgQXhpc01vZGVsQ29tbW9uTWl4aW4gfSBmcm9tICcuLi8uLi9jb29yZC9heGlzTW9kZWxDb21tb25NaXhpbi5qcyc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vbW9kZWwvTW9kZWwuanMnO1xuaW1wb3J0IHsgZ2V0TGF5b3V0UmVjdCB9IGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0LmpzJztcbmltcG9ydCB7IGVuYWJsZURhdGFTdGFjaywgaXNEaW1lbnNpb25TdGFja2VkLCBnZXRTdGFja2VkRGltZW5zaW9uIH0gZnJvbSAnLi4vLi4vZGF0YS9oZWxwZXIvZGF0YVN0YWNrSGVscGVyLmpzJztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVUZXh0U3R5bGUgYXMgaW5uZXJDcmVhdGVUZXh0U3R5bGUgfSBmcm9tICcuLi8uLi9sYWJlbC9sYWJlbFN0eWxlLmpzJztcbi8qKlxyXG4gKiBDcmVhdGUgYSBtdWx0aSBkaW1lbnNpb24gTGlzdCBzdHJ1Y3R1cmUgZnJvbSBzZXJpZXNNb2RlbC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGlzdChzZXJpZXNNb2RlbCkge1xuICByZXR1cm4gY3JlYXRlU2VyaWVzRGF0YShudWxsLCBzZXJpZXNNb2RlbCk7XG59XG4vLyBleHBvcnQgZnVuY3Rpb24gY3JlYXRlR3JhcGgoc2VyaWVzTW9kZWwpIHtcbi8vICAgICBsZXQgbm9kZXMgPSBzZXJpZXNNb2RlbC5nZXQoJ2RhdGEnKTtcbi8vICAgICBsZXQgbGlua3MgPSBzZXJpZXNNb2RlbC5nZXQoJ2xpbmtzJyk7XG4vLyAgICAgcmV0dXJuIGNyZWF0ZUdyYXBoRnJvbU5vZGVFZGdlKG5vZGVzLCBsaW5rcywgc2VyaWVzTW9kZWwpO1xuLy8gfVxuZXhwb3J0IHsgZ2V0TGF5b3V0UmVjdCB9O1xuZXhwb3J0IHsgY3JlYXRlRGltZW5zaW9ucyB9IGZyb20gJy4uLy4uL2RhdGEvaGVscGVyL2NyZWF0ZURpbWVuc2lvbnMuanMnO1xuZXhwb3J0IHZhciBkYXRhU3RhY2sgPSB7XG4gIGlzRGltZW5zaW9uU3RhY2tlZDogaXNEaW1lbnNpb25TdGFja2VkLFxuICBlbmFibGVEYXRhU3RhY2s6IGVuYWJsZURhdGFTdGFjayxcbiAgZ2V0U3RhY2tlZERpbWVuc2lvbjogZ2V0U3RhY2tlZERpbWVuc2lvblxufTtcbi8qKlxyXG4gKiBDcmVhdGUgYSBzeW1ib2wgZWxlbWVudCB3aXRoIGdpdmVuIHN5bWJvbCBjb25maWd1cmF0aW9uOiBzaGFwZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3JcclxuICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbERlc2NcclxuICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICogQHBhcmFtIHtudW1iZXJ9IHdcclxuICogQHBhcmFtIHtudW1iZXJ9IGhcclxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXHJcbiAqL1xuZXhwb3J0IHsgY3JlYXRlU3ltYm9sIH0gZnJvbSAnLi4vLi4vdXRpbC9zeW1ib2wuanMnO1xuLyoqXHJcbiAqIENyZWF0ZSBzY2FsZVxyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkYXRhRXh0ZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fG1vZHVsZTplY2hhcnRzL01vZGVsfSBvcHRpb24gSWYgYG9wdG9pbi50eXBlYFxyXG4gKiAgICAgICAgaXMgc2VjaWZpZWQsIGl0IGNhbiBvbmx5IGJlIGAndmFsdWUnYCBjdXJyZW50bHkuXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNjYWxlKGRhdGFFeHRlbnQsIG9wdGlvbikge1xuICB2YXIgYXhpc01vZGVsID0gb3B0aW9uO1xuICBpZiAoIShvcHRpb24gaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICBheGlzTW9kZWwgPSBuZXcgTW9kZWwob3B0aW9uKTtcbiAgICAvLyBGSVhNRVxuICAgIC8vIEN1cnJlbnRseSBBeGlzTW9kZWxDb21tb25NaXhpbiBoYXMgbm90aGluZyB0byBkbyB3aXRoIHRoZVxuICAgIC8vIHRoZSByZXF1aXJlbWVudHMgb2YgYGF4aXNIZWxwZXIuY3JlYXRlU2NhbGVCeU1vZGVsYC4gRm9yXG4gICAgLy8gZXhhbXBsZSB0aGUgbWV0aG9kcyBgZ2V0Q2F0ZWdvcmllc2AgYW5kIGBnZXRPcmRpbmFsTWV0YWBcbiAgICAvLyBhcmUgcmVxdWlyZWQgZm9yIGAnY2F0ZWdvcnknYCBheGlzLCBhbmQgZWNNb2RlbCBpcyByZXF1aXJlZFxuICAgIC8vIGZvciBgJ3RpbWUnYCBheGlzLiBCdXQgb2NjYXNpb25hbGx5IGVjaGFydHMtZ2wgaGFwcGVuZWRcbiAgICAvLyB0byBvbmx5IHVzZSBgJ3ZhbHVlJ2AgYXhpcy5cbiAgICAvLyB6clV0aWwubWl4aW4oYXhpc01vZGVsLCBBeGlzTW9kZWxDb21tb25NaXhpbik7XG4gIH1cbiAgdmFyIHNjYWxlID0gYXhpc0hlbHBlci5jcmVhdGVTY2FsZUJ5TW9kZWwoYXhpc01vZGVsKTtcbiAgc2NhbGUuc2V0RXh0ZW50KGRhdGFFeHRlbnRbMF0sIGRhdGFFeHRlbnRbMV0pO1xuICBheGlzSGVscGVyLm5pY2VTY2FsZUV4dGVudChzY2FsZSwgYXhpc01vZGVsKTtcbiAgcmV0dXJuIHNjYWxlO1xufVxuLyoqXHJcbiAqIE1peGluIGNvbW1vbiBtZXRob2RzIHRvIGF4aXMgbW9kZWwsXHJcbiAqXHJcbiAqIEluY2x1ZGUgbWV0aG9kc1xyXG4gKiBgZ2V0Rm9ybWF0dGVkTGFiZWxzKCkgPT4gQXJyYXkuPHN0cmluZz5gXHJcbiAqIGBnZXRDYXRlZ29yaWVzKCkgPT4gQXJyYXkuPHN0cmluZz5gXHJcbiAqIGBnZXRNaW4ob3JpZ2luOiBib29sZWFuKSA9PiBudW1iZXJgXHJcbiAqIGBnZXRNYXgob3JpZ2luOiBib29sZWFuKSA9PiBudW1iZXJgXHJcbiAqIGBnZXROZWVkQ3Jvc3NaZXJvKCkgPT4gYm9vbGVhbmBcclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWl4aW5BeGlzTW9kZWxDb21tb25NZXRob2RzKE1vZGVsKSB7XG4gIHpyVXRpbC5taXhpbihNb2RlbCwgQXhpc01vZGVsQ29tbW9uTWl4aW4pO1xufVxuZXhwb3J0IHsgZ2V0RUNEYXRhIH07XG5leHBvcnQgeyBlbmFibGVIb3ZlckVtcGhhc2lzIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0ZXMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRleHRTdHlsZSh0ZXh0U3R5bGVNb2RlbCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgcmV0dXJuIGlubmVyQ3JlYXRlVGV4dFN0eWxlKHRleHRTdHlsZU1vZGVsLCBudWxsLCBudWxsLCBvcHRzLnN0YXRlICE9PSAnbm9ybWFsJyk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5leHBvcnQgeyBsaW5lYXJNYXAsIHJvdW5kLCBhc2MsIGdldFByZWNpc2lvbiwgZ2V0UHJlY2lzaW9uU2FmZSwgZ2V0UGl4ZWxQcmVjaXNpb24sIGdldFBlcmNlbnRXaXRoUHJlY2lzaW9uLCBNQVhfU0FGRV9JTlRFR0VSLCByZW1SYWRpYW4sIGlzUmFkaWFuQXJvdW5kWmVybywgcGFyc2VEYXRlLCBxdWFudGl0eSwgcXVhbnRpdHlFeHBvbmVudCwgbmljZSwgcXVhbnRpbGUsIHJlZm9ybUludGVydmFscywgaXNOdW1lcmljLCBudW1lcmljVG9OdW1iZXIgfSBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5leHBvcnQgeyBwYXJzZURhdGUgYXMgcGFyc2UgfSBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7XG5leHBvcnQgeyBmb3JtYXQgfSBmcm9tICcuLi8uLi91dGlsL3RpbWUuanMnOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuZXhwb3J0IHsgZXh0ZW5kU2hhcGUsIGV4dGVuZFBhdGgsIG1ha2VQYXRoLCBtYWtlSW1hZ2UsIG1lcmdlUGF0aCwgcmVzaXplUGF0aCwgY3JlYXRlSWNvbiwgdXBkYXRlUHJvcHMsIGluaXRQcm9wcywgZ2V0VHJhbnNmb3JtLCBjbGlwUG9pbnRzQnlSZWN0LCBjbGlwUmVjdEJ5UmVjdCwgcmVnaXN0ZXJTaGFwZSwgZ2V0U2hhcGVDbGFzcywgR3JvdXAsIEltYWdlLCBUZXh0LCBDaXJjbGUsIEVsbGlwc2UsIFNlY3RvciwgUmluZywgUG9seWdvbiwgUG9seWxpbmUsIFJlY3QsIExpbmUsIEJlemllckN1cnZlLCBBcmMsIEluY3JlbWVudGFsRGlzcGxheWFibGUsIENvbXBvdW5kUGF0aCwgTGluZWFyR3JhZGllbnQsIFJhZGlhbEdyYWRpZW50LCBCb3VuZGluZ1JlY3QgfSBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuZXhwb3J0IHsgYWRkQ29tbWFzLCB0b0NhbWVsQ2FzZSwgbm9ybWFsaXplQ3NzQXJyYXksIGVuY29kZUhUTUwsIGZvcm1hdFRwbCwgZ2V0VG9vbHRpcE1hcmtlciwgZm9ybWF0VGltZSwgY2FwaXRhbEZpcnN0LCB0cnVuY2F0ZVRleHQsIGdldFRleHRSZWN0IH0gZnJvbSAnLi4vLi4vdXRpbC9mb3JtYXQuanMnOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuZXhwb3J0IHsgbWFwLCBlYWNoLCBpbmRleE9mLCBpbmhlcml0cywgcmVkdWNlLCBmaWx0ZXIsIGJpbmQsIGN1cnJ5LCBpc0FycmF5LCBpc1N0cmluZywgaXNPYmplY3QsIGlzRnVuY3Rpb24sIGV4dGVuZCwgZGVmYXVsdHMsIGNsb25lLCBtZXJnZSB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG4vLyBUaGVzZSBBUElzIGFyZSBmb3IgbW9yZSBhZHZhbmNlZCB1c2FnZXNcbi8vIEZvciBleGFtcGxlIGV4dGVuZCBjaGFydHMgYW5kIGNvbXBvbmVudHMsIGNyZWF0aW5nIGdyYXBoaWMgZWxlbWVudHMsIGZvcm1hdHRpbmcuXG5pbXBvcnQgQ29tcG9uZW50TW9kZWwgZnJvbSAnLi4vbW9kZWwvQ29tcG9uZW50LmpzJztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uL3ZpZXcvQ29tcG9uZW50LmpzJztcbmltcG9ydCBTZXJpZXNNb2RlbCBmcm9tICcuLi9tb2RlbC9TZXJpZXMuanMnO1xuaW1wb3J0IENoYXJ0VmlldyBmcm9tICcuLi92aWV3L0NoYXJ0LmpzJztcbmltcG9ydCBTZXJpZXNEYXRhIGZyb20gJy4uL2RhdGEvU2VyaWVzRGF0YS5qcyc7XG5pbXBvcnQgKiBhcyB6cmVuZGVyXzEgZnJvbSAnenJlbmRlci9saWIvenJlbmRlci5qcyc7XG5leHBvcnQgeyB6cmVuZGVyXzEgYXMgenJlbmRlciB9O1xuaW1wb3J0ICogYXMgbWF0cml4XzEgZnJvbSAnenJlbmRlci9saWIvY29yZS9tYXRyaXguanMnO1xuZXhwb3J0IHsgbWF0cml4XzEgYXMgbWF0cml4IH07XG5pbXBvcnQgKiBhcyB2ZWN0b3JfMSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvci5qcyc7XG5leHBvcnQgeyB2ZWN0b3JfMSBhcyB2ZWN0b3IgfTtcbmltcG9ydCAqIGFzIHpyVXRpbF8xIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5leHBvcnQgeyB6clV0aWxfMSBhcyB6clV0aWwgfTtcbmltcG9ydCAqIGFzIGNvbG9yXzEgZnJvbSAnenJlbmRlci9saWIvdG9vbC9jb2xvci5qcyc7XG5leHBvcnQgeyBjb2xvcl8xIGFzIGNvbG9yIH07XG5leHBvcnQgeyB0aHJvdHRsZSB9IGZyb20gJy4uL3V0aWwvdGhyb3R0bGUuanMnO1xuaW1wb3J0ICogYXMgaGVscGVyXzEgZnJvbSAnLi9hcGkvaGVscGVyLmpzJztcbmV4cG9ydCB7IGhlbHBlcl8xIGFzIGhlbHBlciB9O1xuZXhwb3J0IHsgdXNlIH0gZnJvbSAnLi4vZXh0ZW5zaW9uLmpzJztcbmV4cG9ydCB7IHNldFBsYXRmb3JtQVBJIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS9wbGF0Zm9ybS5qcyc7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gSGVscGVyIE1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhcnNlR2VvSlNPTiB9IGZyb20gJy4uL2Nvb3JkL2dlby9wYXJzZUdlb0pzb24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJzZUdlb0pzb24gfSBmcm9tICcuLi9jb29yZC9nZW8vcGFyc2VHZW9Kc29uLmpzJztcbmltcG9ydCAqIGFzIG51bWJlcl8xIGZyb20gJy4vYXBpL251bWJlci5qcyc7XG5leHBvcnQgeyBudW1iZXJfMSBhcyBudW1iZXIgfTtcbmltcG9ydCAqIGFzIHRpbWVfMSBmcm9tICcuL2FwaS90aW1lLmpzJztcbmV4cG9ydCB7IHRpbWVfMSBhcyB0aW1lIH07XG5pbXBvcnQgKiBhcyBncmFwaGljXzEgZnJvbSAnLi9hcGkvZ3JhcGhpYy5qcyc7XG5leHBvcnQgeyBncmFwaGljXzEgYXMgZ3JhcGhpYyB9O1xuaW1wb3J0ICogYXMgZm9ybWF0XzEgZnJvbSAnLi9hcGkvZm9ybWF0LmpzJztcbmV4cG9ydCB7IGZvcm1hdF8xIGFzIGZvcm1hdCB9O1xuaW1wb3J0ICogYXMgdXRpbF8xIGZyb20gJy4vYXBpL3V0aWwuanMnO1xuZXhwb3J0IHsgdXRpbF8xIGFzIHV0aWwgfTtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZW52IH0gZnJvbSAnenJlbmRlci9saWIvY29yZS9lbnYuanMnO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEV4cG9ydCBmb3IgRXh0ZW5zaW9uIFVzYWdlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZXhwb3J0IHtTZXJpZXNEYXRhfTtcbmV4cG9ydCB7IFNlcmllc0RhdGEgYXMgTGlzdCB9OyAvLyBUT0RPOiBDb21wYXRpdGFibGUgd2l0aCBleGlzdHMgZWNoYXJ0cy1nbCBjb2RlXG5leHBvcnQgeyBkZWZhdWx0IGFzIE1vZGVsIH0gZnJvbSAnLi4vbW9kZWwvTW9kZWwuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBeGlzIH0gZnJvbSAnLi4vY29vcmQvQXhpcy5qcyc7XG5leHBvcnQgeyBDb21wb25lbnRNb2RlbCwgQ29tcG9uZW50VmlldywgU2VyaWVzTW9kZWwsIENoYXJ0VmlldyB9O1xuLy8gT25seSBmb3IgR0xcbmV4cG9ydCB7IGJydXNoU2luZ2xlIGFzIGlubmVyRHJhd0VsZW1lbnRPbkNhbnZhcyB9IGZyb20gJ3pyZW5kZXIvbGliL2NhbnZhcy9ncmFwaGljLmpzJztcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBEZXByZWNhdGVkIEV4dGVuc2lvbiBNZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2hvdWxkIHVzZSBgQ29tcG9uZW50TW9kZWwuZXh0ZW5kYCBvciBgY2xhc3MgWFhYWCBleHRlbmQgQ29tcG9uZW50TW9kZWxgIHRvIGNyZWF0ZSBjbGFzcy5cbi8vIFRoZW4gdXNlIGByZWdpc3RlckNvbXBvbmVudE1vZGVsYCBpbiBgaW5zdGFsbGAgcGFyYW1ldGVyIHdoZW4gYHVzZWAgdGhpcyBleHRlbnNpb24uIEZvciBleGFtcGxlOlxuLy8gY2xhc3MgQmFyM0RNb2RlbCBleHRlbmRzIENvbXBvbmVudE1vZGVsIHt9XG4vLyBleHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHsgcmVnaXN0ZXJzLnJlZ2lzdGVyQ29tcG9uZW50TW9kZWwoQmFyM0RNb2RlbCk7IH1cbi8vIGVjaGFydHMudXNlKGluc3RhbGwpO1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZENvbXBvbmVudE1vZGVsKHByb3RvKSB7XG4gIHZhciBNb2RlbCA9IENvbXBvbmVudE1vZGVsLmV4dGVuZChwcm90byk7XG4gIENvbXBvbmVudE1vZGVsLnJlZ2lzdGVyQ2xhc3MoTW9kZWwpO1xuICByZXR1cm4gTW9kZWw7XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kQ29tcG9uZW50Vmlldyhwcm90bykge1xuICB2YXIgVmlldyA9IENvbXBvbmVudFZpZXcuZXh0ZW5kKHByb3RvKTtcbiAgQ29tcG9uZW50Vmlldy5yZWdpc3RlckNsYXNzKFZpZXcpO1xuICByZXR1cm4gVmlldztcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRTZXJpZXNNb2RlbChwcm90bykge1xuICB2YXIgTW9kZWwgPSBTZXJpZXNNb2RlbC5leHRlbmQocHJvdG8pO1xuICBTZXJpZXNNb2RlbC5yZWdpc3RlckNsYXNzKE1vZGVsKTtcbiAgcmV0dXJuIE1vZGVsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZENoYXJ0Vmlldyhwcm90bykge1xuICB2YXIgVmlldyA9IENoYXJ0Vmlldy5leHRlbmQocHJvdG8pO1xuICBDaGFydFZpZXcucmVnaXN0ZXJDbGFzcyhWaWV3KTtcbiAgcmV0dXJuIFZpZXc7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG4vLyBDb3JlIEFQSSBmcm9tIGVjaGFydHMvc3JjL2VjaGFydHNcbmV4cG9ydCAqIGZyb20gJy4uL2NvcmUvZWNoYXJ0cy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FwaS5qcyc7XG5pbXBvcnQgeyB1c2UgfSBmcm9tICcuLi9leHRlbnNpb24uanMnO1xuLy8gSW1wb3J0IGxhYmVsIGxheW91dCBieSBkZWZhdWx0LlxuLy8gVE9ETyB3aWxsIGJlIHRyZWVzaGFrZWQuXG5pbXBvcnQgeyBpbnN0YWxsTGFiZWxMYXlvdXQgfSBmcm9tICcuLi9sYWJlbC9pbnN0YWxsTGFiZWxMYXlvdXQuanMnO1xudXNlKGluc3RhbGxMYWJlbExheW91dCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///77775\n')},97351:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ prepareSeriesDataSchema),\n/* harmony export */   M: () => (/* binding */ createDimensions)\n/* harmony export */ });\n/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(13430);\n/* harmony import */ var _SeriesDimensionDefine_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(22759);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34310);\n/* harmony import */ var _DataStore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70250);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(48170);\n/* harmony import */ var _sourceHelper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(23071);\n/* harmony import */ var _SeriesDataSchema_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(73632);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n/**\r\n * For outside usage compat (like echarts-gl are using it).\r\n */\nfunction createDimensions(source, opt) {\n  return prepareSeriesDataSchema(source, opt).dimensions;\n}\n/**\r\n * This method builds the relationship between:\r\n * + \"what the coord sys or series requires (see `coordDimensions`)\",\r\n * + \"what the user defines (in `encode` and `dimensions`, see `opt.dimensionsDefine` and `opt.encodeDefine`)\"\r\n * + \"what the data source provids (see `source`)\".\r\n *\r\n * Some guess strategy will be adapted if user does not define something.\r\n * If no 'value' dimension specified, the first no-named dimension will be\r\n * named as 'value'.\r\n *\r\n * @return The results are always sorted by `storeDimIndex` asc.\r\n */\nfunction prepareSeriesDataSchema(\n// TODO: TYPE completeDimensions type\nsource, opt) {\n  if (!(0,_Source_js__WEBPACK_IMPORTED_MODULE_0__/* .isSourceInstance */ .tP)(source)) {\n    source = (0,_Source_js__WEBPACK_IMPORTED_MODULE_0__/* .createSourceFromSeriesDataOption */ .AF)(source);\n  }\n  opt = opt || {};\n  var sysDims = opt.coordDimensions || [];\n  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];\n  var coordDimNameMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.createHashMap)();\n  var resultList = [];\n  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount);\n  // Try to ignore unused dimensions if sharing a high dimension datastore\n  // 30 is an experience value.\n  var omitUnusedDimensions = opt.canOmitUnusedDimensions && (0,_SeriesDataSchema_js__WEBPACK_IMPORTED_MODULE_2__/* .shouldOmitUnusedDimensions */ .eS)(dimCount);\n  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;\n  var dataDimNameMap = isUsingSourceDimensionsDef ? (0,_SeriesDataSchema_js__WEBPACK_IMPORTED_MODULE_2__/* .ensureSourceDimNameMap */ .j_)(source) : (0,_SeriesDataSchema_js__WEBPACK_IMPORTED_MODULE_2__/* .createDimNameMap */ .io)(dimsDef);\n  var encodeDef = opt.encodeDefine;\n  if (!encodeDef && opt.encodeDefaulter) {\n    encodeDef = opt.encodeDefaulter(source, dimCount);\n  }\n  var encodeDefMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.createHashMap)(encodeDef);\n  var indicesMap = new _DataStore_js__WEBPACK_IMPORTED_MODULE_3__/* .CtorInt32Array */ .A_(dimCount);\n  for (var i = 0; i < indicesMap.length; i++) {\n    indicesMap[i] = -1;\n  }\n  function getResultItem(dimIdx) {\n    var idx = indicesMap[dimIdx];\n    if (idx < 0) {\n      var dimDefItemRaw = dimsDef[dimIdx];\n      var dimDefItem = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(dimDefItemRaw) ? dimDefItemRaw : {\n        name: dimDefItemRaw\n      };\n      var resultItem = new _SeriesDimensionDefine_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .A();\n      var userDimName = dimDefItem.name;\n      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {\n        // Only if `series.dimensions` is defined in option\n        // displayName, will be set, and dimension will be displayed vertically in\n        // tooltip by default.\n        resultItem.name = resultItem.displayName = userDimName;\n      }\n      dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);\n      var newIdx = resultList.length;\n      indicesMap[dimIdx] = newIdx;\n      resultItem.storeDimIndex = dimIdx;\n      resultList.push(resultItem);\n      return resultItem;\n    }\n    return resultList[idx];\n  }\n  if (!omitUnusedDimensions) {\n    for (var i = 0; i < dimCount; i++) {\n      getResultItem(i);\n    }\n  }\n  // Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.\n  encodeDefMap.each(function (dataDimsRaw, coordDim) {\n    var dataDims = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_5__/* .normalizeToArray */ .qB)(dataDimsRaw).slice();\n    // Note: It is allowed that `dataDims.length` is `0`, e.g., options is\n    // `{encode: {x: -1, y: 1}}`. Should not filter anything in\n    // this case.\n    if (dataDims.length === 1 && !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString)(dataDims[0]) && dataDims[0] < 0) {\n      encodeDefMap.set(coordDim, false);\n      return;\n    }\n    var validDataDims = encodeDefMap.set(coordDim, []);\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(dataDims, function (resultDimIdxOrName, idx) {\n      // The input resultDimIdx can be dim name or index.\n      var resultDimIdx = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString)(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        validDataDims[idx] = resultDimIdx;\n        applyDim(getResultItem(resultDimIdx), coordDim, idx);\n      }\n    });\n  });\n  // Apply templates and default order from `sysDims`.\n  var availDimIdx = 0;\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(sysDims, function (sysDimItemRaw) {\n    var coordDim;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n    var sysDimItem;\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString)(sysDimItemRaw)) {\n      coordDim = sysDimItemRaw;\n      sysDimItem = {};\n    } else {\n      sysDimItem = sysDimItemRaw;\n      coordDim = sysDimItem.name;\n      var ordinalMeta = sysDimItem.ordinalMeta;\n      sysDimItem.ordinalMeta = null;\n      sysDimItem = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, sysDimItem);\n      sysDimItem.ordinalMeta = ordinalMeta;\n      // `coordDimIndex` should not be set directly.\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n    var dataDims = encodeDefMap.get(coordDim);\n    // negative resultDimIdx means no need to mapping.\n    if (dataDims === false) {\n      return;\n    }\n    dataDims = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_5__/* .normalizeToArray */ .qB)(dataDims);\n    // dimensions provides default dim sequences.\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {\n          availDimIdx++;\n        }\n        availDimIdx < dimCount && dataDims.push(availDimIdx++);\n      }\n    }\n    // Apply templates.\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = getResultItem(resultDimIdx);\n      // Coordinate system has a higher priority on dim type than source.\n      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {\n        resultItem.type = sysDimItem.type;\n      }\n      applyDim((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults)(resultItem, sysDimItem), coordDim, coordDimIndex);\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];\n        !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {\n          name: sysDimItemDimsDefItem\n        });\n        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;\n        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;\n      }\n      // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}\n      sysDimItemOtherDims && (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.defaults)(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  });\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (_util_types_js__WEBPACK_IMPORTED_MODULE_6__/* .VISUAL_DIMENSIONS */ .Pe.get(coordDim) != null) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  }\n  // Make sure the first extra dim is 'value'.\n  var generateCoord = opt.generateCoord;\n  var generateCoordCount = opt.generateCoordCount;\n  var fromZero = generateCoordCount != null;\n  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;\n  var extra = generateCoord || 'value';\n  function ifNoNameFillWithCoordName(resultItem) {\n    if (resultItem.name == null) {\n      // Duplication will be removed in the next step.\n      resultItem.name = resultItem.coordDim;\n    }\n  }\n  // Set dim `name` and other `coordDim` and other props.\n  if (!omitUnusedDimensions) {\n    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n      var resultItem = getResultItem(resultDimIdx);\n      var coordDim = resultItem.coordDim;\n      if (coordDim == null) {\n        // TODO no need to generate coordDim for isExtraCoord?\n        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);\n        resultItem.coordDimIndex = 0;\n        // Series specified generateCoord is using out.\n        if (!generateCoord || generateCoordCount <= 0) {\n          resultItem.isExtraCoord = true;\n        }\n        generateCoordCount--;\n      }\n      ifNoNameFillWithCoordName(resultItem);\n      if (resultItem.type == null && ((0,_sourceHelper_js__WEBPACK_IMPORTED_MODULE_7__/* .guessOrdinal */ .PU)(source, resultDimIdx) === _sourceHelper_js__WEBPACK_IMPORTED_MODULE_7__/* .BE_ORDINAL */ .sc.Must\n      // Consider the case:\n      // {\n      //    dataset: {source: [\n      //        ['2001', 123],\n      //        ['2002', 456],\n      //        ...\n      //        ['The others', 987],\n      //    ]},\n      //    series: {type: 'pie'}\n      // }\n      // The first column should better be treated as a \"ordinal\" although it\n      // might not be detected as an \"ordinal\" by `guessOrdinal`.\n      || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {\n        resultItem.type = 'ordinal';\n      }\n    }\n  } else {\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(resultList, function (resultItem) {\n      // PENDING: guessOrdinal or let user specify type: 'ordinal' manually?\n      ifNoNameFillWithCoordName(resultItem);\n    });\n    // Sort dimensions: there are some rule that use the last dim as label,\n    // and for some latter travel process easier.\n    resultList.sort(function (item0, item1) {\n      return item0.storeDimIndex - item1.storeDimIndex;\n    });\n  }\n  removeDuplication(resultList);\n  return new _SeriesDataSchema_js__WEBPACK_IMPORTED_MODULE_2__/* .SeriesDataSchema */ .Tc({\n    source: source,\n    dimensions: resultList,\n    fullDimensionCount: dimCount,\n    dimensionOmitted: omitUnusedDimensions\n  });\n}\nfunction removeDuplication(result) {\n  var duplicationMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.createHashMap)();\n  for (var i = 0; i < result.length; i++) {\n    var dim = result[i];\n    var dimOriginalName = dim.name;\n    var count = duplicationMap.get(dimOriginalName) || 0;\n    if (count > 0) {\n      // Starts from 0.\n      dim.name = dimOriginalName + (count - 1);\n    }\n    count++;\n    duplicationMap.set(dimOriginalName, count);\n  }\n}\n// ??? TODO\n// Originally detect dimCount by data[0]. Should we\n// optimize it to only by sysDims and dimensions and encode.\n// So only necessary dims will be initialized.\n// But\n// (1) custom series should be considered. where other dims\n// may be visited.\n// (2) sometimes user need to calculate bubble size or use visualMap\n// on other dimensions besides coordSys needed.\n// So, dims that is not used by system, should be shared in data store?\nfunction getDimCount(source, sysDims, dimsDef, optDimCount) {\n  // Note that the result dimCount should not small than columns count\n  // of data, otherwise `dataDimNameMap` checking will be incorrect.\n  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(sysDims, function (sysDimItem) {\n    var sysDimItemDimsDef;\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {\n      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);\n    }\n  });\n  return dimCount;\n}\nfunction genCoordDimName(name, map, fromZero) {\n  if (fromZero || map.hasKey(name)) {\n    var i = 0;\n    while (map.hasKey(name + i)) {\n      i++;\n    }\n    name += i;\n  }\n  map.set(name, true);\n  return name;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTczNTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvY3JlYXRlRGltZW5zaW9ucy5qcz9kYWVkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgVklTVUFMX0RJTUVOU0lPTlMgfSBmcm9tICcuLi8uLi91dGlsL3R5cGVzLmpzJztcbmltcG9ydCBTZXJpZXNEaW1lbnNpb25EZWZpbmUgZnJvbSAnLi4vU2VyaWVzRGltZW5zaW9uRGVmaW5lLmpzJztcbmltcG9ydCB7IGNyZWF0ZUhhc2hNYXAsIGRlZmF1bHRzLCBlYWNoLCBleHRlbmQsIGlzT2JqZWN0LCBpc1N0cmluZyB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTb3VyY2VGcm9tU2VyaWVzRGF0YU9wdGlvbiwgaXNTb3VyY2VJbnN0YW5jZSB9IGZyb20gJy4uL1NvdXJjZS5qcyc7XG5pbXBvcnQgeyBDdG9ySW50MzJBcnJheSB9IGZyb20gJy4uL0RhdGFTdG9yZS5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVUb0FycmF5IH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG5pbXBvcnQgeyBCRV9PUkRJTkFMLCBndWVzc09yZGluYWwgfSBmcm9tICcuL3NvdXJjZUhlbHBlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVEaW1OYW1lTWFwLCBlbnN1cmVTb3VyY2VEaW1OYW1lTWFwLCBTZXJpZXNEYXRhU2NoZW1hLCBzaG91bGRPbWl0VW51c2VkRGltZW5zaW9ucyB9IGZyb20gJy4vU2VyaWVzRGF0YVNjaGVtYS5qcyc7XG4vKipcclxuICogRm9yIG91dHNpZGUgdXNhZ2UgY29tcGF0IChsaWtlIGVjaGFydHMtZ2wgYXJlIHVzaW5nIGl0KS5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGltZW5zaW9ucyhzb3VyY2UsIG9wdCkge1xuICByZXR1cm4gcHJlcGFyZVNlcmllc0RhdGFTY2hlbWEoc291cmNlLCBvcHQpLmRpbWVuc2lvbnM7XG59XG4vKipcclxuICogVGhpcyBtZXRob2QgYnVpbGRzIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbjpcclxuICogKyBcIndoYXQgdGhlIGNvb3JkIHN5cyBvciBzZXJpZXMgcmVxdWlyZXMgKHNlZSBgY29vcmREaW1lbnNpb25zYClcIixcclxuICogKyBcIndoYXQgdGhlIHVzZXIgZGVmaW5lcyAoaW4gYGVuY29kZWAgYW5kIGBkaW1lbnNpb25zYCwgc2VlIGBvcHQuZGltZW5zaW9uc0RlZmluZWAgYW5kIGBvcHQuZW5jb2RlRGVmaW5lYClcIlxyXG4gKiArIFwid2hhdCB0aGUgZGF0YSBzb3VyY2UgcHJvdmlkcyAoc2VlIGBzb3VyY2VgKVwiLlxyXG4gKlxyXG4gKiBTb21lIGd1ZXNzIHN0cmF0ZWd5IHdpbGwgYmUgYWRhcHRlZCBpZiB1c2VyIGRvZXMgbm90IGRlZmluZSBzb21ldGhpbmcuXHJcbiAqIElmIG5vICd2YWx1ZScgZGltZW5zaW9uIHNwZWNpZmllZCwgdGhlIGZpcnN0IG5vLW5hbWVkIGRpbWVuc2lvbiB3aWxsIGJlXHJcbiAqIG5hbWVkIGFzICd2YWx1ZScuXHJcbiAqXHJcbiAqIEByZXR1cm4gVGhlIHJlc3VsdHMgYXJlIGFsd2F5cyBzb3J0ZWQgYnkgYHN0b3JlRGltSW5kZXhgIGFzYy5cclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcmVwYXJlU2VyaWVzRGF0YVNjaGVtYShcbi8vIFRPRE86IFRZUEUgY29tcGxldGVEaW1lbnNpb25zIHR5cGVcbnNvdXJjZSwgb3B0KSB7XG4gIGlmICghaXNTb3VyY2VJbnN0YW5jZShzb3VyY2UpKSB7XG4gICAgc291cmNlID0gY3JlYXRlU291cmNlRnJvbVNlcmllc0RhdGFPcHRpb24oc291cmNlKTtcbiAgfVxuICBvcHQgPSBvcHQgfHwge307XG4gIHZhciBzeXNEaW1zID0gb3B0LmNvb3JkRGltZW5zaW9ucyB8fCBbXTtcbiAgdmFyIGRpbXNEZWYgPSBvcHQuZGltZW5zaW9uc0RlZmluZSB8fCBzb3VyY2UuZGltZW5zaW9uc0RlZmluZSB8fCBbXTtcbiAgdmFyIGNvb3JkRGltTmFtZU1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgdmFyIHJlc3VsdExpc3QgPSBbXTtcbiAgdmFyIGRpbUNvdW50ID0gZ2V0RGltQ291bnQoc291cmNlLCBzeXNEaW1zLCBkaW1zRGVmLCBvcHQuZGltZW5zaW9uc0NvdW50KTtcbiAgLy8gVHJ5IHRvIGlnbm9yZSB1bnVzZWQgZGltZW5zaW9ucyBpZiBzaGFyaW5nIGEgaGlnaCBkaW1lbnNpb24gZGF0YXN0b3JlXG4gIC8vIDMwIGlzIGFuIGV4cGVyaWVuY2UgdmFsdWUuXG4gIHZhciBvbWl0VW51c2VkRGltZW5zaW9ucyA9IG9wdC5jYW5PbWl0VW51c2VkRGltZW5zaW9ucyAmJiBzaG91bGRPbWl0VW51c2VkRGltZW5zaW9ucyhkaW1Db3VudCk7XG4gIHZhciBpc1VzaW5nU291cmNlRGltZW5zaW9uc0RlZiA9IGRpbXNEZWYgPT09IHNvdXJjZS5kaW1lbnNpb25zRGVmaW5lO1xuICB2YXIgZGF0YURpbU5hbWVNYXAgPSBpc1VzaW5nU291cmNlRGltZW5zaW9uc0RlZiA/IGVuc3VyZVNvdXJjZURpbU5hbWVNYXAoc291cmNlKSA6IGNyZWF0ZURpbU5hbWVNYXAoZGltc0RlZik7XG4gIHZhciBlbmNvZGVEZWYgPSBvcHQuZW5jb2RlRGVmaW5lO1xuICBpZiAoIWVuY29kZURlZiAmJiBvcHQuZW5jb2RlRGVmYXVsdGVyKSB7XG4gICAgZW5jb2RlRGVmID0gb3B0LmVuY29kZURlZmF1bHRlcihzb3VyY2UsIGRpbUNvdW50KTtcbiAgfVxuICB2YXIgZW5jb2RlRGVmTWFwID0gY3JlYXRlSGFzaE1hcChlbmNvZGVEZWYpO1xuICB2YXIgaW5kaWNlc01hcCA9IG5ldyBDdG9ySW50MzJBcnJheShkaW1Db3VudCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kaWNlc01hcC5sZW5ndGg7IGkrKykge1xuICAgIGluZGljZXNNYXBbaV0gPSAtMTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSZXN1bHRJdGVtKGRpbUlkeCkge1xuICAgIHZhciBpZHggPSBpbmRpY2VzTWFwW2RpbUlkeF07XG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIHZhciBkaW1EZWZJdGVtUmF3ID0gZGltc0RlZltkaW1JZHhdO1xuICAgICAgdmFyIGRpbURlZkl0ZW0gPSBpc09iamVjdChkaW1EZWZJdGVtUmF3KSA/IGRpbURlZkl0ZW1SYXcgOiB7XG4gICAgICAgIG5hbWU6IGRpbURlZkl0ZW1SYXdcbiAgICAgIH07XG4gICAgICB2YXIgcmVzdWx0SXRlbSA9IG5ldyBTZXJpZXNEaW1lbnNpb25EZWZpbmUoKTtcbiAgICAgIHZhciB1c2VyRGltTmFtZSA9IGRpbURlZkl0ZW0ubmFtZTtcbiAgICAgIGlmICh1c2VyRGltTmFtZSAhPSBudWxsICYmIGRhdGFEaW1OYW1lTWFwLmdldCh1c2VyRGltTmFtZSkgIT0gbnVsbCkge1xuICAgICAgICAvLyBPbmx5IGlmIGBzZXJpZXMuZGltZW5zaW9uc2AgaXMgZGVmaW5lZCBpbiBvcHRpb25cbiAgICAgICAgLy8gZGlzcGxheU5hbWUsIHdpbGwgYmUgc2V0LCBhbmQgZGltZW5zaW9uIHdpbGwgYmUgZGlzcGxheWVkIHZlcnRpY2FsbHkgaW5cbiAgICAgICAgLy8gdG9vbHRpcCBieSBkZWZhdWx0LlxuICAgICAgICByZXN1bHRJdGVtLm5hbWUgPSByZXN1bHRJdGVtLmRpc3BsYXlOYW1lID0gdXNlckRpbU5hbWU7XG4gICAgICB9XG4gICAgICBkaW1EZWZJdGVtLnR5cGUgIT0gbnVsbCAmJiAocmVzdWx0SXRlbS50eXBlID0gZGltRGVmSXRlbS50eXBlKTtcbiAgICAgIGRpbURlZkl0ZW0uZGlzcGxheU5hbWUgIT0gbnVsbCAmJiAocmVzdWx0SXRlbS5kaXNwbGF5TmFtZSA9IGRpbURlZkl0ZW0uZGlzcGxheU5hbWUpO1xuICAgICAgdmFyIG5ld0lkeCA9IHJlc3VsdExpc3QubGVuZ3RoO1xuICAgICAgaW5kaWNlc01hcFtkaW1JZHhdID0gbmV3SWR4O1xuICAgICAgcmVzdWx0SXRlbS5zdG9yZURpbUluZGV4ID0gZGltSWR4O1xuICAgICAgcmVzdWx0TGlzdC5wdXNoKHJlc3VsdEl0ZW0pO1xuICAgICAgcmV0dXJuIHJlc3VsdEl0ZW07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRMaXN0W2lkeF07XG4gIH1cbiAgaWYgKCFvbWl0VW51c2VkRGltZW5zaW9ucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltQ291bnQ7IGkrKykge1xuICAgICAgZ2V0UmVzdWx0SXRlbShpKTtcbiAgICB9XG4gIH1cbiAgLy8gU2V0IGBjb29yZERpbWAgYW5kIGBjb29yZERpbUluZGV4YCBieSBgZW5jb2RlRGVmTWFwYCBhbmQgbm9ybWFsaXplIGBlbmNvZGVEZWZNYXBgLlxuICBlbmNvZGVEZWZNYXAuZWFjaChmdW5jdGlvbiAoZGF0YURpbXNSYXcsIGNvb3JkRGltKSB7XG4gICAgdmFyIGRhdGFEaW1zID0gbm9ybWFsaXplVG9BcnJheShkYXRhRGltc1Jhdykuc2xpY2UoKTtcbiAgICAvLyBOb3RlOiBJdCBpcyBhbGxvd2VkIHRoYXQgYGRhdGFEaW1zLmxlbmd0aGAgaXMgYDBgLCBlLmcuLCBvcHRpb25zIGlzXG4gICAgLy8gYHtlbmNvZGU6IHt4OiAtMSwgeTogMX19YC4gU2hvdWxkIG5vdCBmaWx0ZXIgYW55dGhpbmcgaW5cbiAgICAvLyB0aGlzIGNhc2UuXG4gICAgaWYgKGRhdGFEaW1zLmxlbmd0aCA9PT0gMSAmJiAhaXNTdHJpbmcoZGF0YURpbXNbMF0pICYmIGRhdGFEaW1zWzBdIDwgMCkge1xuICAgICAgZW5jb2RlRGVmTWFwLnNldChjb29yZERpbSwgZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsaWREYXRhRGltcyA9IGVuY29kZURlZk1hcC5zZXQoY29vcmREaW0sIFtdKTtcbiAgICBlYWNoKGRhdGFEaW1zLCBmdW5jdGlvbiAocmVzdWx0RGltSWR4T3JOYW1lLCBpZHgpIHtcbiAgICAgIC8vIFRoZSBpbnB1dCByZXN1bHREaW1JZHggY2FuIGJlIGRpbSBuYW1lIG9yIGluZGV4LlxuICAgICAgdmFyIHJlc3VsdERpbUlkeCA9IGlzU3RyaW5nKHJlc3VsdERpbUlkeE9yTmFtZSkgPyBkYXRhRGltTmFtZU1hcC5nZXQocmVzdWx0RGltSWR4T3JOYW1lKSA6IHJlc3VsdERpbUlkeE9yTmFtZTtcbiAgICAgIGlmIChyZXN1bHREaW1JZHggIT0gbnVsbCAmJiByZXN1bHREaW1JZHggPCBkaW1Db3VudCkge1xuICAgICAgICB2YWxpZERhdGFEaW1zW2lkeF0gPSByZXN1bHREaW1JZHg7XG4gICAgICAgIGFwcGx5RGltKGdldFJlc3VsdEl0ZW0ocmVzdWx0RGltSWR4KSwgY29vcmREaW0sIGlkeCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICAvLyBBcHBseSB0ZW1wbGF0ZXMgYW5kIGRlZmF1bHQgb3JkZXIgZnJvbSBgc3lzRGltc2AuXG4gIHZhciBhdmFpbERpbUlkeCA9IDA7XG4gIGVhY2goc3lzRGltcywgZnVuY3Rpb24gKHN5c0RpbUl0ZW1SYXcpIHtcbiAgICB2YXIgY29vcmREaW07XG4gICAgdmFyIHN5c0RpbUl0ZW1EaW1zRGVmO1xuICAgIHZhciBzeXNEaW1JdGVtT3RoZXJEaW1zO1xuICAgIHZhciBzeXNEaW1JdGVtO1xuICAgIGlmIChpc1N0cmluZyhzeXNEaW1JdGVtUmF3KSkge1xuICAgICAgY29vcmREaW0gPSBzeXNEaW1JdGVtUmF3O1xuICAgICAgc3lzRGltSXRlbSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzeXNEaW1JdGVtID0gc3lzRGltSXRlbVJhdztcbiAgICAgIGNvb3JkRGltID0gc3lzRGltSXRlbS5uYW1lO1xuICAgICAgdmFyIG9yZGluYWxNZXRhID0gc3lzRGltSXRlbS5vcmRpbmFsTWV0YTtcbiAgICAgIHN5c0RpbUl0ZW0ub3JkaW5hbE1ldGEgPSBudWxsO1xuICAgICAgc3lzRGltSXRlbSA9IGV4dGVuZCh7fSwgc3lzRGltSXRlbSk7XG4gICAgICBzeXNEaW1JdGVtLm9yZGluYWxNZXRhID0gb3JkaW5hbE1ldGE7XG4gICAgICAvLyBgY29vcmREaW1JbmRleGAgc2hvdWxkIG5vdCBiZSBzZXQgZGlyZWN0bHkuXG4gICAgICBzeXNEaW1JdGVtRGltc0RlZiA9IHN5c0RpbUl0ZW0uZGltc0RlZjtcbiAgICAgIHN5c0RpbUl0ZW1PdGhlckRpbXMgPSBzeXNEaW1JdGVtLm90aGVyRGltcztcbiAgICAgIHN5c0RpbUl0ZW0ubmFtZSA9IHN5c0RpbUl0ZW0uY29vcmREaW0gPSBzeXNEaW1JdGVtLmNvb3JkRGltSW5kZXggPSBzeXNEaW1JdGVtLmRpbXNEZWYgPSBzeXNEaW1JdGVtLm90aGVyRGltcyA9IG51bGw7XG4gICAgfVxuICAgIHZhciBkYXRhRGltcyA9IGVuY29kZURlZk1hcC5nZXQoY29vcmREaW0pO1xuICAgIC8vIG5lZ2F0aXZlIHJlc3VsdERpbUlkeCBtZWFucyBubyBuZWVkIHRvIG1hcHBpbmcuXG4gICAgaWYgKGRhdGFEaW1zID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhRGltcyA9IG5vcm1hbGl6ZVRvQXJyYXkoZGF0YURpbXMpO1xuICAgIC8vIGRpbWVuc2lvbnMgcHJvdmlkZXMgZGVmYXVsdCBkaW0gc2VxdWVuY2VzLlxuICAgIGlmICghZGF0YURpbXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChzeXNEaW1JdGVtRGltc0RlZiAmJiBzeXNEaW1JdGVtRGltc0RlZi5sZW5ndGggfHwgMSk7IGkrKykge1xuICAgICAgICB3aGlsZSAoYXZhaWxEaW1JZHggPCBkaW1Db3VudCAmJiBnZXRSZXN1bHRJdGVtKGF2YWlsRGltSWR4KS5jb29yZERpbSAhPSBudWxsKSB7XG4gICAgICAgICAgYXZhaWxEaW1JZHgrKztcbiAgICAgICAgfVxuICAgICAgICBhdmFpbERpbUlkeCA8IGRpbUNvdW50ICYmIGRhdGFEaW1zLnB1c2goYXZhaWxEaW1JZHgrKyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IHRlbXBsYXRlcy5cbiAgICBlYWNoKGRhdGFEaW1zLCBmdW5jdGlvbiAocmVzdWx0RGltSWR4LCBjb29yZERpbUluZGV4KSB7XG4gICAgICB2YXIgcmVzdWx0SXRlbSA9IGdldFJlc3VsdEl0ZW0ocmVzdWx0RGltSWR4KTtcbiAgICAgIC8vIENvb3JkaW5hdGUgc3lzdGVtIGhhcyBhIGhpZ2hlciBwcmlvcml0eSBvbiBkaW0gdHlwZSB0aGFuIHNvdXJjZS5cbiAgICAgIGlmIChpc1VzaW5nU291cmNlRGltZW5zaW9uc0RlZiAmJiBzeXNEaW1JdGVtLnR5cGUgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHRJdGVtLnR5cGUgPSBzeXNEaW1JdGVtLnR5cGU7XG4gICAgICB9XG4gICAgICBhcHBseURpbShkZWZhdWx0cyhyZXN1bHRJdGVtLCBzeXNEaW1JdGVtKSwgY29vcmREaW0sIGNvb3JkRGltSW5kZXgpO1xuICAgICAgaWYgKHJlc3VsdEl0ZW0ubmFtZSA9PSBudWxsICYmIHN5c0RpbUl0ZW1EaW1zRGVmKSB7XG4gICAgICAgIHZhciBzeXNEaW1JdGVtRGltc0RlZkl0ZW0gPSBzeXNEaW1JdGVtRGltc0RlZltjb29yZERpbUluZGV4XTtcbiAgICAgICAgIWlzT2JqZWN0KHN5c0RpbUl0ZW1EaW1zRGVmSXRlbSkgJiYgKHN5c0RpbUl0ZW1EaW1zRGVmSXRlbSA9IHtcbiAgICAgICAgICBuYW1lOiBzeXNEaW1JdGVtRGltc0RlZkl0ZW1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdEl0ZW0ubmFtZSA9IHJlc3VsdEl0ZW0uZGlzcGxheU5hbWUgPSBzeXNEaW1JdGVtRGltc0RlZkl0ZW0ubmFtZTtcbiAgICAgICAgcmVzdWx0SXRlbS5kZWZhdWx0VG9vbHRpcCA9IHN5c0RpbUl0ZW1EaW1zRGVmSXRlbS5kZWZhdWx0VG9vbHRpcDtcbiAgICAgIH1cbiAgICAgIC8vIEZJWE1FIHJlZmFjdG9yLCBjdXJyZW50bHkgb25seSB1c2VkIGluIGNhc2U6IHtvdGhlckRpbXM6IHt0b29sdGlwOiBmYWxzZX19XG4gICAgICBzeXNEaW1JdGVtT3RoZXJEaW1zICYmIGRlZmF1bHRzKHJlc3VsdEl0ZW0ub3RoZXJEaW1zLCBzeXNEaW1JdGVtT3RoZXJEaW1zKTtcbiAgICB9KTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGFwcGx5RGltKHJlc3VsdEl0ZW0sIGNvb3JkRGltLCBjb29yZERpbUluZGV4KSB7XG4gICAgaWYgKFZJU1VBTF9ESU1FTlNJT05TLmdldChjb29yZERpbSkgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0SXRlbS5vdGhlckRpbXNbY29vcmREaW1dID0gY29vcmREaW1JbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0SXRlbS5jb29yZERpbSA9IGNvb3JkRGltO1xuICAgICAgcmVzdWx0SXRlbS5jb29yZERpbUluZGV4ID0gY29vcmREaW1JbmRleDtcbiAgICAgIGNvb3JkRGltTmFtZU1hcC5zZXQoY29vcmREaW0sIHRydWUpO1xuICAgIH1cbiAgfVxuICAvLyBNYWtlIHN1cmUgdGhlIGZpcnN0IGV4dHJhIGRpbSBpcyAndmFsdWUnLlxuICB2YXIgZ2VuZXJhdGVDb29yZCA9IG9wdC5nZW5lcmF0ZUNvb3JkO1xuICB2YXIgZ2VuZXJhdGVDb29yZENvdW50ID0gb3B0LmdlbmVyYXRlQ29vcmRDb3VudDtcbiAgdmFyIGZyb21aZXJvID0gZ2VuZXJhdGVDb29yZENvdW50ICE9IG51bGw7XG4gIGdlbmVyYXRlQ29vcmRDb3VudCA9IGdlbmVyYXRlQ29vcmQgPyBnZW5lcmF0ZUNvb3JkQ291bnQgfHwgMSA6IDA7XG4gIHZhciBleHRyYSA9IGdlbmVyYXRlQ29vcmQgfHwgJ3ZhbHVlJztcbiAgZnVuY3Rpb24gaWZOb05hbWVGaWxsV2l0aENvb3JkTmFtZShyZXN1bHRJdGVtKSB7XG4gICAgaWYgKHJlc3VsdEl0ZW0ubmFtZSA9PSBudWxsKSB7XG4gICAgICAvLyBEdXBsaWNhdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgc3RlcC5cbiAgICAgIHJlc3VsdEl0ZW0ubmFtZSA9IHJlc3VsdEl0ZW0uY29vcmREaW07XG4gICAgfVxuICB9XG4gIC8vIFNldCBkaW0gYG5hbWVgIGFuZCBvdGhlciBgY29vcmREaW1gIGFuZCBvdGhlciBwcm9wcy5cbiAgaWYgKCFvbWl0VW51c2VkRGltZW5zaW9ucykge1xuICAgIGZvciAodmFyIHJlc3VsdERpbUlkeCA9IDA7IHJlc3VsdERpbUlkeCA8IGRpbUNvdW50OyByZXN1bHREaW1JZHgrKykge1xuICAgICAgdmFyIHJlc3VsdEl0ZW0gPSBnZXRSZXN1bHRJdGVtKHJlc3VsdERpbUlkeCk7XG4gICAgICB2YXIgY29vcmREaW0gPSByZXN1bHRJdGVtLmNvb3JkRGltO1xuICAgICAgaWYgKGNvb3JkRGltID09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETyBubyBuZWVkIHRvIGdlbmVyYXRlIGNvb3JkRGltIGZvciBpc0V4dHJhQ29vcmQ/XG4gICAgICAgIHJlc3VsdEl0ZW0uY29vcmREaW0gPSBnZW5Db29yZERpbU5hbWUoZXh0cmEsIGNvb3JkRGltTmFtZU1hcCwgZnJvbVplcm8pO1xuICAgICAgICByZXN1bHRJdGVtLmNvb3JkRGltSW5kZXggPSAwO1xuICAgICAgICAvLyBTZXJpZXMgc3BlY2lmaWVkIGdlbmVyYXRlQ29vcmQgaXMgdXNpbmcgb3V0LlxuICAgICAgICBpZiAoIWdlbmVyYXRlQ29vcmQgfHwgZ2VuZXJhdGVDb29yZENvdW50IDw9IDApIHtcbiAgICAgICAgICByZXN1bHRJdGVtLmlzRXh0cmFDb29yZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2VuZXJhdGVDb29yZENvdW50LS07XG4gICAgICB9XG4gICAgICBpZk5vTmFtZUZpbGxXaXRoQ29vcmROYW1lKHJlc3VsdEl0ZW0pO1xuICAgICAgaWYgKHJlc3VsdEl0ZW0udHlwZSA9PSBudWxsICYmIChndWVzc09yZGluYWwoc291cmNlLCByZXN1bHREaW1JZHgpID09PSBCRV9PUkRJTkFMLk11c3RcbiAgICAgIC8vIENvbnNpZGVyIHRoZSBjYXNlOlxuICAgICAgLy8ge1xuICAgICAgLy8gICAgZGF0YXNldDoge3NvdXJjZTogW1xuICAgICAgLy8gICAgICAgIFsnMjAwMScsIDEyM10sXG4gICAgICAvLyAgICAgICAgWycyMDAyJywgNDU2XSxcbiAgICAgIC8vICAgICAgICAuLi5cbiAgICAgIC8vICAgICAgICBbJ1RoZSBvdGhlcnMnLCA5ODddLFxuICAgICAgLy8gICAgXX0sXG4gICAgICAvLyAgICBzZXJpZXM6IHt0eXBlOiAncGllJ31cbiAgICAgIC8vIH1cbiAgICAgIC8vIFRoZSBmaXJzdCBjb2x1bW4gc2hvdWxkIGJldHRlciBiZSB0cmVhdGVkIGFzIGEgXCJvcmRpbmFsXCIgYWx0aG91Z2ggaXRcbiAgICAgIC8vIG1pZ2h0IG5vdCBiZSBkZXRlY3RlZCBhcyBhbiBcIm9yZGluYWxcIiBieSBgZ3Vlc3NPcmRpbmFsYC5cbiAgICAgIHx8IHJlc3VsdEl0ZW0uaXNFeHRyYUNvb3JkICYmIChyZXN1bHRJdGVtLm90aGVyRGltcy5pdGVtTmFtZSAhPSBudWxsIHx8IHJlc3VsdEl0ZW0ub3RoZXJEaW1zLnNlcmllc05hbWUgIT0gbnVsbCkpKSB7XG4gICAgICAgIHJlc3VsdEl0ZW0udHlwZSA9ICdvcmRpbmFsJztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZWFjaChyZXN1bHRMaXN0LCBmdW5jdGlvbiAocmVzdWx0SXRlbSkge1xuICAgICAgLy8gUEVORElORzogZ3Vlc3NPcmRpbmFsIG9yIGxldCB1c2VyIHNwZWNpZnkgdHlwZTogJ29yZGluYWwnIG1hbnVhbGx5P1xuICAgICAgaWZOb05hbWVGaWxsV2l0aENvb3JkTmFtZShyZXN1bHRJdGVtKTtcbiAgICB9KTtcbiAgICAvLyBTb3J0IGRpbWVuc2lvbnM6IHRoZXJlIGFyZSBzb21lIHJ1bGUgdGhhdCB1c2UgdGhlIGxhc3QgZGltIGFzIGxhYmVsLFxuICAgIC8vIGFuZCBmb3Igc29tZSBsYXR0ZXIgdHJhdmVsIHByb2Nlc3MgZWFzaWVyLlxuICAgIHJlc3VsdExpc3Quc29ydChmdW5jdGlvbiAoaXRlbTAsIGl0ZW0xKSB7XG4gICAgICByZXR1cm4gaXRlbTAuc3RvcmVEaW1JbmRleCAtIGl0ZW0xLnN0b3JlRGltSW5kZXg7XG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlRHVwbGljYXRpb24ocmVzdWx0TGlzdCk7XG4gIHJldHVybiBuZXcgU2VyaWVzRGF0YVNjaGVtYSh7XG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgZGltZW5zaW9uczogcmVzdWx0TGlzdCxcbiAgICBmdWxsRGltZW5zaW9uQ291bnQ6IGRpbUNvdW50LFxuICAgIGRpbWVuc2lvbk9taXR0ZWQ6IG9taXRVbnVzZWREaW1lbnNpb25zXG4gIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRpb24ocmVzdWx0KSB7XG4gIHZhciBkdXBsaWNhdGlvbk1hcCA9IGNyZWF0ZUhhc2hNYXAoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGltID0gcmVzdWx0W2ldO1xuICAgIHZhciBkaW1PcmlnaW5hbE5hbWUgPSBkaW0ubmFtZTtcbiAgICB2YXIgY291bnQgPSBkdXBsaWNhdGlvbk1hcC5nZXQoZGltT3JpZ2luYWxOYW1lKSB8fCAwO1xuICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgIC8vIFN0YXJ0cyBmcm9tIDAuXG4gICAgICBkaW0ubmFtZSA9IGRpbU9yaWdpbmFsTmFtZSArIChjb3VudCAtIDEpO1xuICAgIH1cbiAgICBjb3VudCsrO1xuICAgIGR1cGxpY2F0aW9uTWFwLnNldChkaW1PcmlnaW5hbE5hbWUsIGNvdW50KTtcbiAgfVxufVxuLy8gPz8/IFRPRE9cbi8vIE9yaWdpbmFsbHkgZGV0ZWN0IGRpbUNvdW50IGJ5IGRhdGFbMF0uIFNob3VsZCB3ZVxuLy8gb3B0aW1pemUgaXQgdG8gb25seSBieSBzeXNEaW1zIGFuZCBkaW1lbnNpb25zIGFuZCBlbmNvZGUuXG4vLyBTbyBvbmx5IG5lY2Vzc2FyeSBkaW1zIHdpbGwgYmUgaW5pdGlhbGl6ZWQuXG4vLyBCdXRcbi8vICgxKSBjdXN0b20gc2VyaWVzIHNob3VsZCBiZSBjb25zaWRlcmVkLiB3aGVyZSBvdGhlciBkaW1zXG4vLyBtYXkgYmUgdmlzaXRlZC5cbi8vICgyKSBzb21ldGltZXMgdXNlciBuZWVkIHRvIGNhbGN1bGF0ZSBidWJibGUgc2l6ZSBvciB1c2UgdmlzdWFsTWFwXG4vLyBvbiBvdGhlciBkaW1lbnNpb25zIGJlc2lkZXMgY29vcmRTeXMgbmVlZGVkLlxuLy8gU28sIGRpbXMgdGhhdCBpcyBub3QgdXNlZCBieSBzeXN0ZW0sIHNob3VsZCBiZSBzaGFyZWQgaW4gZGF0YSBzdG9yZT9cbmZ1bmN0aW9uIGdldERpbUNvdW50KHNvdXJjZSwgc3lzRGltcywgZGltc0RlZiwgb3B0RGltQ291bnQpIHtcbiAgLy8gTm90ZSB0aGF0IHRoZSByZXN1bHQgZGltQ291bnQgc2hvdWxkIG5vdCBzbWFsbCB0aGFuIGNvbHVtbnMgY291bnRcbiAgLy8gb2YgZGF0YSwgb3RoZXJ3aXNlIGBkYXRhRGltTmFtZU1hcGAgY2hlY2tpbmcgd2lsbCBiZSBpbmNvcnJlY3QuXG4gIHZhciBkaW1Db3VudCA9IE1hdGgubWF4KHNvdXJjZS5kaW1lbnNpb25zRGV0ZWN0ZWRDb3VudCB8fCAxLCBzeXNEaW1zLmxlbmd0aCwgZGltc0RlZi5sZW5ndGgsIG9wdERpbUNvdW50IHx8IDApO1xuICBlYWNoKHN5c0RpbXMsIGZ1bmN0aW9uIChzeXNEaW1JdGVtKSB7XG4gICAgdmFyIHN5c0RpbUl0ZW1EaW1zRGVmO1xuICAgIGlmIChpc09iamVjdChzeXNEaW1JdGVtKSAmJiAoc3lzRGltSXRlbURpbXNEZWYgPSBzeXNEaW1JdGVtLmRpbXNEZWYpKSB7XG4gICAgICBkaW1Db3VudCA9IE1hdGgubWF4KGRpbUNvdW50LCBzeXNEaW1JdGVtRGltc0RlZi5sZW5ndGgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkaW1Db3VudDtcbn1cbmZ1bmN0aW9uIGdlbkNvb3JkRGltTmFtZShuYW1lLCBtYXAsIGZyb21aZXJvKSB7XG4gIGlmIChmcm9tWmVybyB8fCBtYXAuaGFzS2V5KG5hbWUpKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChtYXAuaGFzS2V5KG5hbWUgKyBpKSkge1xuICAgICAgaSsrO1xuICAgIH1cbiAgICBuYW1lICs9IGk7XG4gIH1cbiAgbWFwLnNldChuYW1lLCB0cnVlKTtcbiAgcmV0dXJuIG5hbWU7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///97351\n")}}]);