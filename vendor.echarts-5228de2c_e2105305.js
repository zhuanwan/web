"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[8953],{6325:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/LineDraw.js\nvar LineDraw = __webpack_require__(64380);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/EffectLine.js\nvar EffectLine = __webpack_require__(31331);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/Line.js + 1 modules\nvar Line = __webpack_require__(32182);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/Polyline.js\nvar Polyline = __webpack_require__(46448);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/EffectPolyline.js\nvar EffectPolyline = __webpack_require__(13269);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/LargeLineDraw.js\nvar LargeLineDraw = __webpack_require__(82681);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createRenderPlanner.js\nvar createRenderPlanner = __webpack_require__(87582);\n;// ./node_modules/echarts/lib/chart/lines/linesLayout.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/* global Float32Array */\n\n\nvar linesLayout = {\n  seriesType: 'lines',\n  plan: (0,createRenderPlanner/* default */.A)(),\n  reset: function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n    if (!coordSys) {\n      if (false) {}\n      return;\n    }\n    var isPolyline = seriesModel.get('polyline');\n    var isLarge = seriesModel.pipelineContext.large;\n    return {\n      progress: function (params, lineData) {\n        var lineCoords = [];\n        if (isLarge) {\n          var points = void 0;\n          var segCount = params.end - params.start;\n          if (isPolyline) {\n            var totalCoordsCount = 0;\n            for (var i = params.start; i < params.end; i++) {\n              totalCoordsCount += seriesModel.getLineCoordsCount(i);\n            }\n            points = new Float32Array(segCount + totalCoordsCount * 2);\n          } else {\n            points = new Float32Array(segCount * 4);\n          }\n          var offset = 0;\n          var pt = [];\n          for (var i = params.start; i < params.end; i++) {\n            var len = seriesModel.getLineCoords(i, lineCoords);\n            if (isPolyline) {\n              points[offset++] = len;\n            }\n            for (var k = 0; k < len; k++) {\n              pt = coordSys.dataToPoint(lineCoords[k], false, pt);\n              points[offset++] = pt[0];\n              points[offset++] = pt[1];\n            }\n          }\n          lineData.setLayout('linesPoints', points);\n        } else {\n          for (var i = params.start; i < params.end; i++) {\n            var itemModel = lineData.getItemModel(i);\n            var len = seriesModel.getLineCoords(i, lineCoords);\n            var pts = [];\n            if (isPolyline) {\n              for (var j = 0; j < len; j++) {\n                pts.push(coordSys.dataToPoint(lineCoords[j]));\n              }\n            } else {\n              pts[0] = coordSys.dataToPoint(lineCoords[0]);\n              pts[1] = coordSys.dataToPoint(lineCoords[1]);\n              var curveness = itemModel.get(['lineStyle', 'curveness']);\n              if (+curveness) {\n                pts[2] = [(pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness];\n              }\n            }\n            lineData.setItemLayout(i, pts);\n          }\n        }\n      }\n    };\n  }\n};\n/* harmony default export */ const lines_linesLayout = (linesLayout);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js\nvar createClipPathFromCoordSys = __webpack_require__(95235);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n;// ./node_modules/echarts/lib/chart/lines/LinesView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\nvar LinesView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(LinesView, _super);\n  function LinesView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = LinesView.type;\n    return _this;\n  }\n  LinesView.prototype.render = function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    var lineDraw = this._updateLineDraw(data, seriesModel);\n    var zlevel = seriesModel.get('zlevel');\n    var trailLength = seriesModel.get(['effect', 'trailLength']);\n    var zr = api.getZr();\n    // Avoid the drag cause ghost shadow\n    // FIXME Better way ?\n    // SVG doesn't support\n    var isSvg = zr.painter.getType() === 'svg';\n    if (!isSvg) {\n      zr.painter.getLayer(zlevel).clear(true);\n    }\n    // Config layer with motion blur\n    if (this._lastZlevel != null && !isSvg) {\n      zr.configLayer(this._lastZlevel, {\n        motionBlur: false\n      });\n    }\n    if (this._showEffect(seriesModel) && trailLength > 0) {\n      if (!isSvg) {\n        zr.configLayer(zlevel, {\n          motionBlur: true,\n          lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)\n        });\n      } else if (false) {}\n    }\n    lineDraw.updateData(data);\n    var clipPath = seriesModel.get('clip', true) && (0,createClipPathFromCoordSys/* createClipPath */.Ip)(seriesModel.coordinateSystem, false, seriesModel);\n    if (clipPath) {\n      this.group.setClipPath(clipPath);\n    } else {\n      this.group.removeClipPath();\n    }\n    this._lastZlevel = zlevel;\n    this._finished = true;\n  };\n  LinesView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    var lineDraw = this._updateLineDraw(data, seriesModel);\n    lineDraw.incrementalPrepareUpdate(data);\n    this._clearLayer(api);\n    this._finished = false;\n  };\n  LinesView.prototype.incrementalRender = function (taskParams, seriesModel, ecModel) {\n    this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData());\n    this._finished = taskParams.end === seriesModel.getData().count();\n  };\n  LinesView.prototype.eachRendered = function (cb) {\n    this._lineDraw && this._lineDraw.eachRendered(cb);\n  };\n  LinesView.prototype.updateTransform = function (seriesModel, ecModel, api) {\n    var data = seriesModel.getData();\n    var pipelineContext = seriesModel.pipelineContext;\n    if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) {\n      // TODO Don't have to do update in large mode. Only do it when there are millions of data.\n      return {\n        update: true\n      };\n    } else {\n      // TODO Use same logic with ScatterView.\n      // Manually update layout\n      var res = lines_linesLayout.reset(seriesModel, ecModel, api);\n      if (res.progress) {\n        res.progress({\n          start: 0,\n          end: data.count(),\n          count: data.count()\n        }, data);\n      }\n      // Not in large mode\n      this._lineDraw.updateLayout();\n      this._clearLayer(api);\n    }\n  };\n  LinesView.prototype._updateLineDraw = function (data, seriesModel) {\n    var lineDraw = this._lineDraw;\n    var hasEffect = this._showEffect(seriesModel);\n    var isPolyline = !!seriesModel.get('polyline');\n    var pipelineContext = seriesModel.pipelineContext;\n    var isLargeDraw = pipelineContext.large;\n    if (false) {}\n    if (!lineDraw || hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLargeDraw !== this._isLargeDraw) {\n      if (lineDraw) {\n        lineDraw.remove();\n      }\n      lineDraw = this._lineDraw = isLargeDraw ? new LargeLineDraw/* default */.A() : new LineDraw/* default */.A(isPolyline ? hasEffect ? EffectPolyline/* default */.A : Polyline/* default */.A : hasEffect ? EffectLine/* default */.A : Line/* default */.A);\n      this._hasEffet = hasEffect;\n      this._isPolyline = isPolyline;\n      this._isLargeDraw = isLargeDraw;\n    }\n    this.group.add(lineDraw.group);\n    return lineDraw;\n  };\n  LinesView.prototype._showEffect = function (seriesModel) {\n    return !!seriesModel.get(['effect', 'show']);\n  };\n  LinesView.prototype._clearLayer = function (api) {\n    // Not use motion when dragging or zooming\n    var zr = api.getZr();\n    var isSvg = zr.painter.getType() === 'svg';\n    if (!isSvg && this._lastZlevel != null) {\n      zr.painter.getLayer(this._lastZlevel).clear(true);\n    }\n  };\n  LinesView.prototype.remove = function (ecModel, api) {\n    this._lineDraw && this._lineDraw.remove();\n    this._lineDraw = null;\n    // Clear motion when lineDraw is removed\n    this._clearLayer(api);\n  };\n  LinesView.prototype.dispose = function (ecModel, api) {\n    this.remove(ecModel, api);\n  };\n  LinesView.type = 'lines';\n  return LinesView;\n}(Chart/* default */.A);\n/* harmony default export */ const lines_LinesView = (LinesView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/SeriesData.js\nvar SeriesData = __webpack_require__(6006);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js\nvar tooltipMarkup = __webpack_require__(3961);\n;// ./node_modules/echarts/lib/chart/lines/LinesSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/* global Uint32Array, Float64Array, Float32Array */\n\n\n\n\n\nvar Uint32Arr = typeof Uint32Array === 'undefined' ? Array : Uint32Array;\nvar Float64Arr = typeof Float64Array === 'undefined' ? Array : Float64Array;\nfunction compatEc2(seriesOpt) {\n  var data = seriesOpt.data;\n  if (data && data[0] && data[0][0] && data[0][0].coord) {\n    if (false) {}\n    seriesOpt.data = (0,util.map)(data, function (itemOpt) {\n      var coords = [itemOpt[0].coord, itemOpt[1].coord];\n      var target = {\n        coords: coords\n      };\n      if (itemOpt[0].name) {\n        target.fromName = itemOpt[0].name;\n      }\n      if (itemOpt[1].name) {\n        target.toName = itemOpt[1].name;\n      }\n      return (0,util.mergeAll)([target, itemOpt[0], itemOpt[1]]);\n    });\n  }\n}\nvar LinesSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(LinesSeriesModel, _super);\n  function LinesSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = LinesSeriesModel.type;\n    _this.visualStyleAccessPath = 'lineStyle';\n    _this.visualDrawType = 'stroke';\n    return _this;\n  }\n  LinesSeriesModel.prototype.init = function (option) {\n    // The input data may be null/undefined.\n    option.data = option.data || [];\n    // Not using preprocessor because mergeOption may not have series.type\n    compatEc2(option);\n    var result = this._processFlatCoordsArray(option.data);\n    this._flatCoords = result.flatCoords;\n    this._flatCoordsOffset = result.flatCoordsOffset;\n    if (result.flatCoords) {\n      option.data = new Float32Array(result.count);\n    }\n    _super.prototype.init.apply(this, arguments);\n  };\n  LinesSeriesModel.prototype.mergeOption = function (option) {\n    compatEc2(option);\n    if (option.data) {\n      // Only update when have option data to merge.\n      var result = this._processFlatCoordsArray(option.data);\n      this._flatCoords = result.flatCoords;\n      this._flatCoordsOffset = result.flatCoordsOffset;\n      if (result.flatCoords) {\n        option.data = new Float32Array(result.count);\n      }\n    }\n    _super.prototype.mergeOption.apply(this, arguments);\n  };\n  LinesSeriesModel.prototype.appendData = function (params) {\n    var result = this._processFlatCoordsArray(params.data);\n    if (result.flatCoords) {\n      if (!this._flatCoords) {\n        this._flatCoords = result.flatCoords;\n        this._flatCoordsOffset = result.flatCoordsOffset;\n      } else {\n        this._flatCoords = (0,util.concatArray)(this._flatCoords, result.flatCoords);\n        this._flatCoordsOffset = (0,util.concatArray)(this._flatCoordsOffset, result.flatCoordsOffset);\n      }\n      params.data = new Float32Array(result.count);\n    }\n    this.getRawData().appendData(params.data);\n  };\n  LinesSeriesModel.prototype._getCoordsFromItemModel = function (idx) {\n    var itemModel = this.getData().getItemModel(idx);\n    var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow('coords');\n    if (false) {}\n    return coords;\n  };\n  LinesSeriesModel.prototype.getLineCoordsCount = function (idx) {\n    if (this._flatCoordsOffset) {\n      return this._flatCoordsOffset[idx * 2 + 1];\n    } else {\n      return this._getCoordsFromItemModel(idx).length;\n    }\n  };\n  LinesSeriesModel.prototype.getLineCoords = function (idx, out) {\n    if (this._flatCoordsOffset) {\n      var offset = this._flatCoordsOffset[idx * 2];\n      var len = this._flatCoordsOffset[idx * 2 + 1];\n      for (var i = 0; i < len; i++) {\n        out[i] = out[i] || [];\n        out[i][0] = this._flatCoords[offset + i * 2];\n        out[i][1] = this._flatCoords[offset + i * 2 + 1];\n      }\n      return len;\n    } else {\n      var coords = this._getCoordsFromItemModel(idx);\n      for (var i = 0; i < coords.length; i++) {\n        out[i] = out[i] || [];\n        out[i][0] = coords[i][0];\n        out[i][1] = coords[i][1];\n      }\n      return coords.length;\n    }\n  };\n  LinesSeriesModel.prototype._processFlatCoordsArray = function (data) {\n    var startOffset = 0;\n    if (this._flatCoords) {\n      startOffset = this._flatCoords.length;\n    }\n    // Stored as a typed array. In format\n    // Points Count(2) | x | y | x | y | Points Count(3) | x |  y | x | y | x | y |\n    if ((0,util.isNumber)(data[0])) {\n      var len = data.length;\n      // Store offset and len of each segment\n      var coordsOffsetAndLenStorage = new Uint32Arr(len);\n      var coordsStorage = new Float64Arr(len);\n      var coordsCursor = 0;\n      var offsetCursor = 0;\n      var dataCount = 0;\n      for (var i = 0; i < len;) {\n        dataCount++;\n        var count = data[i++];\n        // Offset\n        coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset;\n        // Len\n        coordsOffsetAndLenStorage[offsetCursor++] = count;\n        for (var k = 0; k < count; k++) {\n          var x = data[i++];\n          var y = data[i++];\n          coordsStorage[coordsCursor++] = x;\n          coordsStorage[coordsCursor++] = y;\n          if (i > len) {\n            if (false) {}\n          }\n        }\n      }\n      return {\n        flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),\n        flatCoords: coordsStorage,\n        count: dataCount\n      };\n    }\n    return {\n      flatCoordsOffset: null,\n      flatCoords: null,\n      count: data.length\n    };\n  };\n  LinesSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    if (false) { var CoordSys; }\n    var lineData = new SeriesData/* default */.A(['value'], this);\n    lineData.hasItemOption = false;\n    lineData.initData(option.data, [], function (dataItem, dimName, dataIndex, dimIndex) {\n      // dataItem is simply coords\n      if (dataItem instanceof Array) {\n        return NaN;\n      } else {\n        lineData.hasItemOption = true;\n        var value = dataItem.value;\n        if (value != null) {\n          return value instanceof Array ? value[dimIndex] : value;\n        }\n      }\n    });\n    return lineData;\n  };\n  LinesSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n    var data = this.getData();\n    var itemModel = data.getItemModel(dataIndex);\n    var name = itemModel.get('name');\n    if (name) {\n      return name;\n    }\n    var fromName = itemModel.get('fromName');\n    var toName = itemModel.get('toName');\n    var nameArr = [];\n    fromName != null && nameArr.push(fromName);\n    toName != null && nameArr.push(toName);\n    return (0,tooltipMarkup/* createTooltipMarkup */.Qx)('nameValue', {\n      name: nameArr.join(' > ')\n    });\n  };\n  LinesSeriesModel.prototype.preventIncremental = function () {\n    return !!this.get(['effect', 'show']);\n  };\n  LinesSeriesModel.prototype.getProgressive = function () {\n    var progressive = this.option.progressive;\n    if (progressive == null) {\n      return this.option.large ? 1e4 : this.get('progressive');\n    }\n    return progressive;\n  };\n  LinesSeriesModel.prototype.getProgressiveThreshold = function () {\n    var progressiveThreshold = this.option.progressiveThreshold;\n    if (progressiveThreshold == null) {\n      return this.option.large ? 2e4 : this.get('progressiveThreshold');\n    }\n    return progressiveThreshold;\n  };\n  LinesSeriesModel.prototype.getZLevelKey = function () {\n    var effectModel = this.getModel('effect');\n    var trailLength = effectModel.get('trailLength');\n    return this.getData().count() > this.getProgressiveThreshold()\n    // Each progressive series has individual key.\n    ? this.id : effectModel.get('show') && trailLength > 0 ? trailLength + '' : '';\n  };\n  LinesSeriesModel.type = 'series.lines';\n  LinesSeriesModel.dependencies = ['grid', 'polar', 'geo', 'calendar'];\n  LinesSeriesModel.defaultOption = {\n    coordinateSystem: 'geo',\n    // zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    // Cartesian coordinate system\n    xAxisIndex: 0,\n    yAxisIndex: 0,\n    symbol: ['none', 'none'],\n    symbolSize: [10, 10],\n    // Geo coordinate system\n    geoIndex: 0,\n    effect: {\n      show: false,\n      period: 4,\n      constantSpeed: 0,\n      symbol: 'circle',\n      symbolSize: 3,\n      loop: true,\n      trailLength: 0.2\n    },\n    large: false,\n    // Available when large is true\n    largeThreshold: 2000,\n    polyline: false,\n    clip: true,\n    label: {\n      show: false,\n      position: 'end'\n      // distance: 5,\n      // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n    },\n    lineStyle: {\n      opacity: 0.5\n    }\n  };\n  return LinesSeriesModel;\n}(Series/* default */.A);\n/* harmony default export */ const LinesSeries = (LinesSeriesModel);\n;// ./node_modules/echarts/lib/chart/lines/linesVisual.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nfunction normalize(a) {\n  if (!(a instanceof Array)) {\n    a = [a, a];\n  }\n  return a;\n}\nvar linesVisual = {\n  seriesType: 'lines',\n  reset: function (seriesModel) {\n    var symbolType = normalize(seriesModel.get('symbol'));\n    var symbolSize = normalize(seriesModel.get('symbolSize'));\n    var data = seriesModel.getData();\n    data.setVisual('fromSymbol', symbolType && symbolType[0]);\n    data.setVisual('toSymbol', symbolType && symbolType[1]);\n    data.setVisual('fromSymbolSize', symbolSize && symbolSize[0]);\n    data.setVisual('toSymbolSize', symbolSize && symbolSize[1]);\n    function dataEach(data, idx) {\n      var itemModel = data.getItemModel(idx);\n      var symbolType = normalize(itemModel.getShallow('symbol', true));\n      var symbolSize = normalize(itemModel.getShallow('symbolSize', true));\n      symbolType[0] && data.setItemVisual(idx, 'fromSymbol', symbolType[0]);\n      symbolType[1] && data.setItemVisual(idx, 'toSymbol', symbolType[1]);\n      symbolSize[0] && data.setItemVisual(idx, 'fromSymbolSize', symbolSize[0]);\n      symbolSize[1] && data.setItemVisual(idx, 'toSymbolSize', symbolSize[1]);\n    }\n    return {\n      dataEach: data.hasItemOption ? dataEach : null\n    };\n  }\n};\n/* harmony default export */ const lines_linesVisual = (linesVisual);\n;// ./node_modules/echarts/lib/chart/lines/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nfunction install(registers) {\n  registers.registerChartView(lines_LinesView);\n  registers.registerSeriesModel(LinesSeries);\n  registers.registerLayout(lines_linesLayout);\n  registers.registerVisual(lines_linesVisual);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMyNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZXMvbGluZXNMYXlvdXQuanM/MmIzYiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZXMvTGluZXNWaWV3LmpzPzVmYTMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmVzL0xpbmVzU2VyaWVzLmpzP2I4ODEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmVzL2xpbmVzVmlzdWFsLmpzP2ViNzYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmVzL2luc3RhbGwuanM/YzRhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbi8qIGdsb2JhbCBGbG9hdDMyQXJyYXkgKi9cbmltcG9ydCBjcmVhdGVSZW5kZXJQbGFubmVyIGZyb20gJy4uL2hlbHBlci9jcmVhdGVSZW5kZXJQbGFubmVyLmpzJztcbmltcG9ydCB7IGVycm9yIH0gZnJvbSAnLi4vLi4vdXRpbC9sb2cuanMnO1xudmFyIGxpbmVzTGF5b3V0ID0ge1xuICBzZXJpZXNUeXBlOiAnbGluZXMnLFxuICBwbGFuOiBjcmVhdGVSZW5kZXJQbGFubmVyKCksXG4gIHJlc2V0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgIGlmICghY29vcmRTeXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdUaGUgbGluZXMgc2VyaWVzIG11c3QgaGF2ZSBhIGNvb3JkaW5hdGUgc3lzdGVtLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXNQb2x5bGluZSA9IHNlcmllc01vZGVsLmdldCgncG9seWxpbmUnKTtcbiAgICB2YXIgaXNMYXJnZSA9IHNlcmllc01vZGVsLnBpcGVsaW5lQ29udGV4dC5sYXJnZTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIChwYXJhbXMsIGxpbmVEYXRhKSB7XG4gICAgICAgIHZhciBsaW5lQ29vcmRzID0gW107XG4gICAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgc2VnQ291bnQgPSBwYXJhbXMuZW5kIC0gcGFyYW1zLnN0YXJ0O1xuICAgICAgICAgIGlmIChpc1BvbHlsaW5lKSB7XG4gICAgICAgICAgICB2YXIgdG90YWxDb29yZHNDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcGFyYW1zLnN0YXJ0OyBpIDwgcGFyYW1zLmVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRvdGFsQ29vcmRzQ291bnQgKz0gc2VyaWVzTW9kZWwuZ2V0TGluZUNvb3Jkc0NvdW50KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShzZWdDb3VudCArIHRvdGFsQ29vcmRzQ291bnQgKiAyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShzZWdDb3VudCAqIDQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICB2YXIgcHQgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gcGFyYW1zLnN0YXJ0OyBpIDwgcGFyYW1zLmVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gc2VyaWVzTW9kZWwuZ2V0TGluZUNvb3JkcyhpLCBsaW5lQ29vcmRzKTtcbiAgICAgICAgICAgIGlmIChpc1BvbHlsaW5lKSB7XG4gICAgICAgICAgICAgIHBvaW50c1tvZmZzZXQrK10gPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICAgIHB0ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQobGluZUNvb3Jkc1trXSwgZmFsc2UsIHB0KTtcbiAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCsrXSA9IHB0WzBdO1xuICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0KytdID0gcHRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbmVEYXRhLnNldExheW91dCgnbGluZXNQb2ludHMnLCBwb2ludHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBwYXJhbXMuc3RhcnQ7IGkgPCBwYXJhbXMuZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBsaW5lRGF0YS5nZXRJdGVtTW9kZWwoaSk7XG4gICAgICAgICAgICB2YXIgbGVuID0gc2VyaWVzTW9kZWwuZ2V0TGluZUNvb3JkcyhpLCBsaW5lQ29vcmRzKTtcbiAgICAgICAgICAgIHZhciBwdHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChpc1BvbHlsaW5lKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwdHMucHVzaChjb29yZFN5cy5kYXRhVG9Qb2ludChsaW5lQ29vcmRzW2pdKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHB0c1swXSA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KGxpbmVDb29yZHNbMF0pO1xuICAgICAgICAgICAgICBwdHNbMV0gPSBjb29yZFN5cy5kYXRhVG9Qb2ludChsaW5lQ29vcmRzWzFdKTtcbiAgICAgICAgICAgICAgdmFyIGN1cnZlbmVzcyA9IGl0ZW1Nb2RlbC5nZXQoWydsaW5lU3R5bGUnLCAnY3VydmVuZXNzJ10pO1xuICAgICAgICAgICAgICBpZiAoK2N1cnZlbmVzcykge1xuICAgICAgICAgICAgICAgIHB0c1syXSA9IFsocHRzWzBdWzBdICsgcHRzWzFdWzBdKSAvIDIgLSAocHRzWzBdWzFdIC0gcHRzWzFdWzFdKSAqIGN1cnZlbmVzcywgKHB0c1swXVsxXSArIHB0c1sxXVsxXSkgLyAyIC0gKHB0c1sxXVswXSAtIHB0c1swXVswXSkgKiBjdXJ2ZW5lc3NdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lRGF0YS5zZXRJdGVtTGF5b3V0KGksIHB0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IGxpbmVzTGF5b3V0OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgTGluZURyYXcgZnJvbSAnLi4vaGVscGVyL0xpbmVEcmF3LmpzJztcbmltcG9ydCBFZmZlY3RMaW5lIGZyb20gJy4uL2hlbHBlci9FZmZlY3RMaW5lLmpzJztcbmltcG9ydCBMaW5lIGZyb20gJy4uL2hlbHBlci9MaW5lLmpzJztcbmltcG9ydCBQb2x5bGluZSBmcm9tICcuLi9oZWxwZXIvUG9seWxpbmUuanMnO1xuaW1wb3J0IEVmZmVjdFBvbHlsaW5lIGZyb20gJy4uL2hlbHBlci9FZmZlY3RQb2x5bGluZS5qcyc7XG5pbXBvcnQgTGFyZ2VMaW5lRHJhdyBmcm9tICcuLi9oZWxwZXIvTGFyZ2VMaW5lRHJhdy5qcyc7XG5pbXBvcnQgbGluZXNMYXlvdXQgZnJvbSAnLi9saW5lc0xheW91dC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDbGlwUGF0aCB9IGZyb20gJy4uL2hlbHBlci9jcmVhdGVDbGlwUGF0aEZyb21Db29yZFN5cy5qcyc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQuanMnO1xudmFyIExpbmVzVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhMaW5lc1ZpZXcsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIExpbmVzVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gTGluZXNWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIExpbmVzVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgbGluZURyYXcgPSB0aGlzLl91cGRhdGVMaW5lRHJhdyhkYXRhLCBzZXJpZXNNb2RlbCk7XG4gICAgdmFyIHpsZXZlbCA9IHNlcmllc01vZGVsLmdldCgnemxldmVsJyk7XG4gICAgdmFyIHRyYWlsTGVuZ3RoID0gc2VyaWVzTW9kZWwuZ2V0KFsnZWZmZWN0JywgJ3RyYWlsTGVuZ3RoJ10pO1xuICAgIHZhciB6ciA9IGFwaS5nZXRacigpO1xuICAgIC8vIEF2b2lkIHRoZSBkcmFnIGNhdXNlIGdob3N0IHNoYWRvd1xuICAgIC8vIEZJWE1FIEJldHRlciB3YXkgP1xuICAgIC8vIFNWRyBkb2Vzbid0IHN1cHBvcnRcbiAgICB2YXIgaXNTdmcgPSB6ci5wYWludGVyLmdldFR5cGUoKSA9PT0gJ3N2Zyc7XG4gICAgaWYgKCFpc1N2Zykge1xuICAgICAgenIucGFpbnRlci5nZXRMYXllcih6bGV2ZWwpLmNsZWFyKHRydWUpO1xuICAgIH1cbiAgICAvLyBDb25maWcgbGF5ZXIgd2l0aCBtb3Rpb24gYmx1clxuICAgIGlmICh0aGlzLl9sYXN0WmxldmVsICE9IG51bGwgJiYgIWlzU3ZnKSB7XG4gICAgICB6ci5jb25maWdMYXllcih0aGlzLl9sYXN0WmxldmVsLCB7XG4gICAgICAgIG1vdGlvbkJsdXI6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Nob3dFZmZlY3Qoc2VyaWVzTW9kZWwpICYmIHRyYWlsTGVuZ3RoID4gMCkge1xuICAgICAgaWYgKCFpc1N2Zykge1xuICAgICAgICB6ci5jb25maWdMYXllcih6bGV2ZWwsIHtcbiAgICAgICAgICBtb3Rpb25CbHVyOiB0cnVlLFxuICAgICAgICAgIGxhc3RGcmFtZUFscGhhOiBNYXRoLm1heChNYXRoLm1pbih0cmFpbExlbmd0aCAvIDEwICsgMC45LCAxKSwgMClcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTVkcgcmVuZGVyIG1vZGUgZG9lc25cXCd0IHN1cHBvcnQgbGluZXMgd2l0aCB0cmFpbCBlZmZlY3QnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGluZURyYXcudXBkYXRlRGF0YShkYXRhKTtcbiAgICB2YXIgY2xpcFBhdGggPSBzZXJpZXNNb2RlbC5nZXQoJ2NsaXAnLCB0cnVlKSAmJiBjcmVhdGVDbGlwUGF0aChzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtLCBmYWxzZSwgc2VyaWVzTW9kZWwpO1xuICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgdGhpcy5ncm91cC5zZXRDbGlwUGF0aChjbGlwUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQ2xpcFBhdGgoKTtcbiAgICB9XG4gICAgdGhpcy5fbGFzdFpsZXZlbCA9IHpsZXZlbDtcbiAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG4gIH07XG4gIExpbmVzVmlldy5wcm90b3R5cGUuaW5jcmVtZW50YWxQcmVwYXJlUmVuZGVyID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgbGluZURyYXcgPSB0aGlzLl91cGRhdGVMaW5lRHJhdyhkYXRhLCBzZXJpZXNNb2RlbCk7XG4gICAgbGluZURyYXcuaW5jcmVtZW50YWxQcmVwYXJlVXBkYXRlKGRhdGEpO1xuICAgIHRoaXMuX2NsZWFyTGF5ZXIoYXBpKTtcbiAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICB9O1xuICBMaW5lc1ZpZXcucHJvdG90eXBlLmluY3JlbWVudGFsUmVuZGVyID0gZnVuY3Rpb24gKHRhc2tQYXJhbXMsIHNlcmllc01vZGVsLCBlY01vZGVsKSB7XG4gICAgdGhpcy5fbGluZURyYXcuaW5jcmVtZW50YWxVcGRhdGUodGFza1BhcmFtcywgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpKTtcbiAgICB0aGlzLl9maW5pc2hlZCA9IHRhc2tQYXJhbXMuZW5kID09PSBzZXJpZXNNb2RlbC5nZXREYXRhKCkuY291bnQoKTtcbiAgfTtcbiAgTGluZXNWaWV3LnByb3RvdHlwZS5lYWNoUmVuZGVyZWQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB0aGlzLl9saW5lRHJhdyAmJiB0aGlzLl9saW5lRHJhdy5lYWNoUmVuZGVyZWQoY2IpO1xuICB9O1xuICBMaW5lc1ZpZXcucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHBpcGVsaW5lQ29udGV4dCA9IHNlcmllc01vZGVsLnBpcGVsaW5lQ29udGV4dDtcbiAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkIHx8IHBpcGVsaW5lQ29udGV4dC5sYXJnZSB8fCBwaXBlbGluZUNvbnRleHQucHJvZ3Jlc3NpdmVSZW5kZXIpIHtcbiAgICAgIC8vIFRPRE8gRG9uJ3QgaGF2ZSB0byBkbyB1cGRhdGUgaW4gbGFyZ2UgbW9kZS4gT25seSBkbyBpdCB3aGVuIHRoZXJlIGFyZSBtaWxsaW9ucyBvZiBkYXRhLlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlOiB0cnVlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPIFVzZSBzYW1lIGxvZ2ljIHdpdGggU2NhdHRlclZpZXcuXG4gICAgICAvLyBNYW51YWxseSB1cGRhdGUgbGF5b3V0XG4gICAgICB2YXIgcmVzID0gbGluZXNMYXlvdXQucmVzZXQoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgICBpZiAocmVzLnByb2dyZXNzKSB7XG4gICAgICAgIHJlcy5wcm9ncmVzcyh7XG4gICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgZW5kOiBkYXRhLmNvdW50KCksXG4gICAgICAgICAgY291bnQ6IGRhdGEuY291bnQoKVxuICAgICAgICB9LCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vdCBpbiBsYXJnZSBtb2RlXG4gICAgICB0aGlzLl9saW5lRHJhdy51cGRhdGVMYXlvdXQoKTtcbiAgICAgIHRoaXMuX2NsZWFyTGF5ZXIoYXBpKTtcbiAgICB9XG4gIH07XG4gIExpbmVzVmlldy5wcm90b3R5cGUuX3VwZGF0ZUxpbmVEcmF3ID0gZnVuY3Rpb24gKGRhdGEsIHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGxpbmVEcmF3ID0gdGhpcy5fbGluZURyYXc7XG4gICAgdmFyIGhhc0VmZmVjdCA9IHRoaXMuX3Nob3dFZmZlY3Qoc2VyaWVzTW9kZWwpO1xuICAgIHZhciBpc1BvbHlsaW5lID0gISFzZXJpZXNNb2RlbC5nZXQoJ3BvbHlsaW5lJyk7XG4gICAgdmFyIHBpcGVsaW5lQ29udGV4dCA9IHNlcmllc01vZGVsLnBpcGVsaW5lQ29udGV4dDtcbiAgICB2YXIgaXNMYXJnZURyYXcgPSBwaXBlbGluZUNvbnRleHQubGFyZ2U7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChoYXNFZmZlY3QgJiYgaXNMYXJnZURyYXcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdMYXJnZSBsaW5lcyBub3Qgc3VwcG9ydCBlZmZlY3QnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFsaW5lRHJhdyB8fCBoYXNFZmZlY3QgIT09IHRoaXMuX2hhc0VmZmV0IHx8IGlzUG9seWxpbmUgIT09IHRoaXMuX2lzUG9seWxpbmUgfHwgaXNMYXJnZURyYXcgIT09IHRoaXMuX2lzTGFyZ2VEcmF3KSB7XG4gICAgICBpZiAobGluZURyYXcpIHtcbiAgICAgICAgbGluZURyYXcucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBsaW5lRHJhdyA9IHRoaXMuX2xpbmVEcmF3ID0gaXNMYXJnZURyYXcgPyBuZXcgTGFyZ2VMaW5lRHJhdygpIDogbmV3IExpbmVEcmF3KGlzUG9seWxpbmUgPyBoYXNFZmZlY3QgPyBFZmZlY3RQb2x5bGluZSA6IFBvbHlsaW5lIDogaGFzRWZmZWN0ID8gRWZmZWN0TGluZSA6IExpbmUpO1xuICAgICAgdGhpcy5faGFzRWZmZXQgPSBoYXNFZmZlY3Q7XG4gICAgICB0aGlzLl9pc1BvbHlsaW5lID0gaXNQb2x5bGluZTtcbiAgICAgIHRoaXMuX2lzTGFyZ2VEcmF3ID0gaXNMYXJnZURyYXc7XG4gICAgfVxuICAgIHRoaXMuZ3JvdXAuYWRkKGxpbmVEcmF3Lmdyb3VwKTtcbiAgICByZXR1cm4gbGluZURyYXc7XG4gIH07XG4gIExpbmVzVmlldy5wcm90b3R5cGUuX3Nob3dFZmZlY3QgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICByZXR1cm4gISFzZXJpZXNNb2RlbC5nZXQoWydlZmZlY3QnLCAnc2hvdyddKTtcbiAgfTtcbiAgTGluZXNWaWV3LnByb3RvdHlwZS5fY2xlYXJMYXllciA9IGZ1bmN0aW9uIChhcGkpIHtcbiAgICAvLyBOb3QgdXNlIG1vdGlvbiB3aGVuIGRyYWdnaW5nIG9yIHpvb21pbmdcbiAgICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgICB2YXIgaXNTdmcgPSB6ci5wYWludGVyLmdldFR5cGUoKSA9PT0gJ3N2Zyc7XG4gICAgaWYgKCFpc1N2ZyAmJiB0aGlzLl9sYXN0WmxldmVsICE9IG51bGwpIHtcbiAgICAgIHpyLnBhaW50ZXIuZ2V0TGF5ZXIodGhpcy5fbGFzdFpsZXZlbCkuY2xlYXIodHJ1ZSk7XG4gICAgfVxuICB9O1xuICBMaW5lc1ZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLl9saW5lRHJhdyAmJiB0aGlzLl9saW5lRHJhdy5yZW1vdmUoKTtcbiAgICB0aGlzLl9saW5lRHJhdyA9IG51bGw7XG4gICAgLy8gQ2xlYXIgbW90aW9uIHdoZW4gbGluZURyYXcgaXMgcmVtb3ZlZFxuICAgIHRoaXMuX2NsZWFyTGF5ZXIoYXBpKTtcbiAgfTtcbiAgTGluZXNWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gIH07XG4gIExpbmVzVmlldy50eXBlID0gJ2xpbmVzJztcbiAgcmV0dXJuIExpbmVzVmlldztcbn0oQ2hhcnRWaWV3KTtcbmV4cG9ydCBkZWZhdWx0IExpbmVzVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuLyogZ2xvYmFsIFVpbnQzMkFycmF5LCBGbG9hdDY0QXJyYXksIEZsb2F0MzJBcnJheSAqL1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcy5qcyc7XG5pbXBvcnQgU2VyaWVzRGF0YSBmcm9tICcuLi8uLi9kYXRhL1Nlcmllc0RhdGEuanMnO1xuaW1wb3J0IHsgY29uY2F0QXJyYXksIG1lcmdlQWxsLCBtYXAsIGlzTnVtYmVyIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBDb29yZGluYXRlU3lzdGVtIGZyb20gJy4uLy4uL2NvcmUvQ29vcmRpbmF0ZVN5c3RlbS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVUb29sdGlwTWFya3VwIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50L3Rvb2x0aXAvdG9vbHRpcE1hcmt1cC5qcyc7XG52YXIgVWludDMyQXJyID0gdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IEFycmF5IDogVWludDMyQXJyYXk7XG52YXIgRmxvYXQ2NEFyciA9IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gQXJyYXkgOiBGbG9hdDY0QXJyYXk7XG5mdW5jdGlvbiBjb21wYXRFYzIoc2VyaWVzT3B0KSB7XG4gIHZhciBkYXRhID0gc2VyaWVzT3B0LmRhdGE7XG4gIGlmIChkYXRhICYmIGRhdGFbMF0gJiYgZGF0YVswXVswXSAmJiBkYXRhWzBdWzBdLmNvb3JkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUud2FybignTGluZXMgZGF0YSBjb25maWd1cmF0aW9uIGhhcyBiZWVuIGNoYW5nZWQgdG8nICsgJyB7IGNvb3JkczpbWzEsMl0sWzIsM11dIH0nKTtcbiAgICB9XG4gICAgc2VyaWVzT3B0LmRhdGEgPSBtYXAoZGF0YSwgZnVuY3Rpb24gKGl0ZW1PcHQpIHtcbiAgICAgIHZhciBjb29yZHMgPSBbaXRlbU9wdFswXS5jb29yZCwgaXRlbU9wdFsxXS5jb29yZF07XG4gICAgICB2YXIgdGFyZ2V0ID0ge1xuICAgICAgICBjb29yZHM6IGNvb3Jkc1xuICAgICAgfTtcbiAgICAgIGlmIChpdGVtT3B0WzBdLm5hbWUpIHtcbiAgICAgICAgdGFyZ2V0LmZyb21OYW1lID0gaXRlbU9wdFswXS5uYW1lO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1PcHRbMV0ubmFtZSkge1xuICAgICAgICB0YXJnZXQudG9OYW1lID0gaXRlbU9wdFsxXS5uYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlQWxsKFt0YXJnZXQsIGl0ZW1PcHRbMF0sIGl0ZW1PcHRbMV1dKTtcbiAgICB9KTtcbiAgfVxufVxudmFyIExpbmVzU2VyaWVzTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTGluZXNTZXJpZXNNb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gTGluZXNTZXJpZXNNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gTGluZXNTZXJpZXNNb2RlbC50eXBlO1xuICAgIF90aGlzLnZpc3VhbFN0eWxlQWNjZXNzUGF0aCA9ICdsaW5lU3R5bGUnO1xuICAgIF90aGlzLnZpc3VhbERyYXdUeXBlID0gJ3N0cm9rZSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIExpbmVzU2VyaWVzTW9kZWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgLy8gVGhlIGlucHV0IGRhdGEgbWF5IGJlIG51bGwvdW5kZWZpbmVkLlxuICAgIG9wdGlvbi5kYXRhID0gb3B0aW9uLmRhdGEgfHwgW107XG4gICAgLy8gTm90IHVzaW5nIHByZXByb2Nlc3NvciBiZWNhdXNlIG1lcmdlT3B0aW9uIG1heSBub3QgaGF2ZSBzZXJpZXMudHlwZVxuICAgIGNvbXBhdEVjMihvcHRpb24pO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLl9wcm9jZXNzRmxhdENvb3Jkc0FycmF5KG9wdGlvbi5kYXRhKTtcbiAgICB0aGlzLl9mbGF0Q29vcmRzID0gcmVzdWx0LmZsYXRDb29yZHM7XG4gICAgdGhpcy5fZmxhdENvb3Jkc09mZnNldCA9IHJlc3VsdC5mbGF0Q29vcmRzT2Zmc2V0O1xuICAgIGlmIChyZXN1bHQuZmxhdENvb3Jkcykge1xuICAgICAgb3B0aW9uLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC5jb3VudCk7XG4gICAgfVxuICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBMaW5lc1Nlcmllc01vZGVsLnByb3RvdHlwZS5tZXJnZU9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBjb21wYXRFYzIob3B0aW9uKTtcbiAgICBpZiAob3B0aW9uLmRhdGEpIHtcbiAgICAgIC8vIE9ubHkgdXBkYXRlIHdoZW4gaGF2ZSBvcHRpb24gZGF0YSB0byBtZXJnZS5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9wcm9jZXNzRmxhdENvb3Jkc0FycmF5KG9wdGlvbi5kYXRhKTtcbiAgICAgIHRoaXMuX2ZsYXRDb29yZHMgPSByZXN1bHQuZmxhdENvb3JkcztcbiAgICAgIHRoaXMuX2ZsYXRDb29yZHNPZmZzZXQgPSByZXN1bHQuZmxhdENvb3Jkc09mZnNldDtcbiAgICAgIGlmIChyZXN1bHQuZmxhdENvb3Jkcykge1xuICAgICAgICBvcHRpb24uZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkocmVzdWx0LmNvdW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3N1cGVyLnByb3RvdHlwZS5tZXJnZU9wdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBMaW5lc1Nlcmllc01vZGVsLnByb3RvdHlwZS5hcHBlbmREYXRhID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLl9wcm9jZXNzRmxhdENvb3Jkc0FycmF5KHBhcmFtcy5kYXRhKTtcbiAgICBpZiAocmVzdWx0LmZsYXRDb29yZHMpIHtcbiAgICAgIGlmICghdGhpcy5fZmxhdENvb3Jkcykge1xuICAgICAgICB0aGlzLl9mbGF0Q29vcmRzID0gcmVzdWx0LmZsYXRDb29yZHM7XG4gICAgICAgIHRoaXMuX2ZsYXRDb29yZHNPZmZzZXQgPSByZXN1bHQuZmxhdENvb3Jkc09mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZsYXRDb29yZHMgPSBjb25jYXRBcnJheSh0aGlzLl9mbGF0Q29vcmRzLCByZXN1bHQuZmxhdENvb3Jkcyk7XG4gICAgICAgIHRoaXMuX2ZsYXRDb29yZHNPZmZzZXQgPSBjb25jYXRBcnJheSh0aGlzLl9mbGF0Q29vcmRzT2Zmc2V0LCByZXN1bHQuZmxhdENvb3Jkc09mZnNldCk7XG4gICAgICB9XG4gICAgICBwYXJhbXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkocmVzdWx0LmNvdW50KTtcbiAgICB9XG4gICAgdGhpcy5nZXRSYXdEYXRhKCkuYXBwZW5kRGF0YShwYXJhbXMuZGF0YSk7XG4gIH07XG4gIExpbmVzU2VyaWVzTW9kZWwucHJvdG90eXBlLl9nZXRDb29yZHNGcm9tSXRlbU1vZGVsID0gZnVuY3Rpb24gKGlkeCkge1xuICAgIHZhciBpdGVtTW9kZWwgPSB0aGlzLmdldERhdGEoKS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICB2YXIgY29vcmRzID0gaXRlbU1vZGVsLm9wdGlvbiBpbnN0YW5jZW9mIEFycmF5ID8gaXRlbU1vZGVsLm9wdGlvbiA6IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdjb29yZHMnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEoY29vcmRzIGluc3RhbmNlb2YgQXJyYXkgJiYgY29vcmRzLmxlbmd0aCA+IDAgJiYgY29vcmRzWzBdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29yZHMgJyArIEpTT04uc3RyaW5naWZ5KGNvb3JkcykgKyAnLiBMaW5lcyBtdXN0IGhhdmUgMmQgY29vcmRzIGFycmF5IGluIGRhdGEgaXRlbS4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkcztcbiAgfTtcbiAgTGluZXNTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0TGluZUNvb3Jkc0NvdW50ID0gZnVuY3Rpb24gKGlkeCkge1xuICAgIGlmICh0aGlzLl9mbGF0Q29vcmRzT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmxhdENvb3Jkc09mZnNldFtpZHggKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDb29yZHNGcm9tSXRlbU1vZGVsKGlkeCkubGVuZ3RoO1xuICAgIH1cbiAgfTtcbiAgTGluZXNTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0TGluZUNvb3JkcyA9IGZ1bmN0aW9uIChpZHgsIG91dCkge1xuICAgIGlmICh0aGlzLl9mbGF0Q29vcmRzT2Zmc2V0KSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZmxhdENvb3Jkc09mZnNldFtpZHggKiAyXTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLl9mbGF0Q29vcmRzT2Zmc2V0W2lkeCAqIDIgKyAxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gb3V0W2ldIHx8IFtdO1xuICAgICAgICBvdXRbaV1bMF0gPSB0aGlzLl9mbGF0Q29vcmRzW29mZnNldCArIGkgKiAyXTtcbiAgICAgICAgb3V0W2ldWzFdID0gdGhpcy5fZmxhdENvb3Jkc1tvZmZzZXQgKyBpICogMiArIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuX2dldENvb3Jkc0Zyb21JdGVtTW9kZWwoaWR4KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IG91dFtpXSB8fCBbXTtcbiAgICAgICAgb3V0W2ldWzBdID0gY29vcmRzW2ldWzBdO1xuICAgICAgICBvdXRbaV1bMV0gPSBjb29yZHNbaV1bMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY29vcmRzLmxlbmd0aDtcbiAgICB9XG4gIH07XG4gIExpbmVzU2VyaWVzTW9kZWwucHJvdG90eXBlLl9wcm9jZXNzRmxhdENvb3Jkc0FycmF5ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSAwO1xuICAgIGlmICh0aGlzLl9mbGF0Q29vcmRzKSB7XG4gICAgICBzdGFydE9mZnNldCA9IHRoaXMuX2ZsYXRDb29yZHMubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBTdG9yZWQgYXMgYSB0eXBlZCBhcnJheS4gSW4gZm9ybWF0XG4gICAgLy8gUG9pbnRzIENvdW50KDIpIHwgeCB8IHkgfCB4IHwgeSB8IFBvaW50cyBDb3VudCgzKSB8IHggfCAgeSB8IHggfCB5IHwgeCB8IHkgfFxuICAgIGlmIChpc051bWJlcihkYXRhWzBdKSkge1xuICAgICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgLy8gU3RvcmUgb2Zmc2V0IGFuZCBsZW4gb2YgZWFjaCBzZWdtZW50XG4gICAgICB2YXIgY29vcmRzT2Zmc2V0QW5kTGVuU3RvcmFnZSA9IG5ldyBVaW50MzJBcnIobGVuKTtcbiAgICAgIHZhciBjb29yZHNTdG9yYWdlID0gbmV3IEZsb2F0NjRBcnIobGVuKTtcbiAgICAgIHZhciBjb29yZHNDdXJzb3IgPSAwO1xuICAgICAgdmFyIG9mZnNldEN1cnNvciA9IDA7XG4gICAgICB2YXIgZGF0YUNvdW50ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICBkYXRhQ291bnQrKztcbiAgICAgICAgdmFyIGNvdW50ID0gZGF0YVtpKytdO1xuICAgICAgICAvLyBPZmZzZXRcbiAgICAgICAgY29vcmRzT2Zmc2V0QW5kTGVuU3RvcmFnZVtvZmZzZXRDdXJzb3IrK10gPSBjb29yZHNDdXJzb3IgKyBzdGFydE9mZnNldDtcbiAgICAgICAgLy8gTGVuXG4gICAgICAgIGNvb3Jkc09mZnNldEFuZExlblN0b3JhZ2Vbb2Zmc2V0Q3Vyc29yKytdID0gY291bnQ7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY291bnQ7IGsrKykge1xuICAgICAgICAgIHZhciB4ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIGNvb3Jkc1N0b3JhZ2VbY29vcmRzQ3Vyc29yKytdID0geDtcbiAgICAgICAgICBjb29yZHNTdG9yYWdlW2Nvb3Jkc0N1cnNvcisrXSA9IHk7XG4gICAgICAgICAgaWYgKGkgPiBsZW4pIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIGZvcm1hdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZsYXRDb29yZHNPZmZzZXQ6IG5ldyBVaW50MzJBcnJheShjb29yZHNPZmZzZXRBbmRMZW5TdG9yYWdlLmJ1ZmZlciwgMCwgb2Zmc2V0Q3Vyc29yKSxcbiAgICAgICAgZmxhdENvb3JkczogY29vcmRzU3RvcmFnZSxcbiAgICAgICAgY291bnQ6IGRhdGFDb3VudFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZsYXRDb29yZHNPZmZzZXQ6IG51bGwsXG4gICAgICBmbGF0Q29vcmRzOiBudWxsLFxuICAgICAgY291bnQ6IGRhdGEubGVuZ3RoXG4gICAgfTtcbiAgfTtcbiAgTGluZXNTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0SW5pdGlhbERhdGEgPSBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb29yZFN5cyA9IENvb3JkaW5hdGVTeXN0ZW0uZ2V0KG9wdGlvbi5jb29yZGluYXRlU3lzdGVtKTtcbiAgICAgIGlmICghQ29vcmRTeXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvb3JkaW5hdGUgc3lzdGVtICcgKyBvcHRpb24uY29vcmRpbmF0ZVN5c3RlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBsaW5lRGF0YSA9IG5ldyBTZXJpZXNEYXRhKFsndmFsdWUnXSwgdGhpcyk7XG4gICAgbGluZURhdGEuaGFzSXRlbU9wdGlvbiA9IGZhbHNlO1xuICAgIGxpbmVEYXRhLmluaXREYXRhKG9wdGlvbi5kYXRhLCBbXSwgZnVuY3Rpb24gKGRhdGFJdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgICAvLyBkYXRhSXRlbSBpcyBzaW1wbHkgY29vcmRzXG4gICAgICBpZiAoZGF0YUl0ZW0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZURhdGEuaGFzSXRlbU9wdGlvbiA9IHRydWU7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRhdGFJdGVtLnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ID8gdmFsdWVbZGltSW5kZXhdIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbGluZURhdGE7XG4gIH07XG4gIExpbmVzU2VyaWVzTW9kZWwucHJvdG90eXBlLmZvcm1hdFRvb2x0aXAgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBtdWx0aXBsZVNlcmllcywgZGF0YVR5cGUpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChkYXRhSW5kZXgpO1xuICAgIHZhciBuYW1lID0gaXRlbU1vZGVsLmdldCgnbmFtZScpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgdmFyIGZyb21OYW1lID0gaXRlbU1vZGVsLmdldCgnZnJvbU5hbWUnKTtcbiAgICB2YXIgdG9OYW1lID0gaXRlbU1vZGVsLmdldCgndG9OYW1lJyk7XG4gICAgdmFyIG5hbWVBcnIgPSBbXTtcbiAgICBmcm9tTmFtZSAhPSBudWxsICYmIG5hbWVBcnIucHVzaChmcm9tTmFtZSk7XG4gICAgdG9OYW1lICE9IG51bGwgJiYgbmFtZUFyci5wdXNoKHRvTmFtZSk7XG4gICAgcmV0dXJuIGNyZWF0ZVRvb2x0aXBNYXJrdXAoJ25hbWVWYWx1ZScsIHtcbiAgICAgIG5hbWU6IG5hbWVBcnIuam9pbignID4gJylcbiAgICB9KTtcbiAgfTtcbiAgTGluZXNTZXJpZXNNb2RlbC5wcm90b3R5cGUucHJldmVudEluY3JlbWVudGFsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0KFsnZWZmZWN0JywgJ3Nob3cnXSk7XG4gIH07XG4gIExpbmVzU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldFByb2dyZXNzaXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9ncmVzc2l2ZSA9IHRoaXMub3B0aW9uLnByb2dyZXNzaXZlO1xuICAgIGlmIChwcm9ncmVzc2l2ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb24ubGFyZ2UgPyAxZTQgOiB0aGlzLmdldCgncHJvZ3Jlc3NpdmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2dyZXNzaXZlO1xuICB9O1xuICBMaW5lc1Nlcmllc01vZGVsLnByb3RvdHlwZS5nZXRQcm9ncmVzc2l2ZVRocmVzaG9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvZ3Jlc3NpdmVUaHJlc2hvbGQgPSB0aGlzLm9wdGlvbi5wcm9ncmVzc2l2ZVRocmVzaG9sZDtcbiAgICBpZiAocHJvZ3Jlc3NpdmVUaHJlc2hvbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9uLmxhcmdlID8gMmU0IDogdGhpcy5nZXQoJ3Byb2dyZXNzaXZlVGhyZXNob2xkJyk7XG4gICAgfVxuICAgIHJldHVybiBwcm9ncmVzc2l2ZVRocmVzaG9sZDtcbiAgfTtcbiAgTGluZXNTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0WkxldmVsS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlZmZlY3RNb2RlbCA9IHRoaXMuZ2V0TW9kZWwoJ2VmZmVjdCcpO1xuICAgIHZhciB0cmFpbExlbmd0aCA9IGVmZmVjdE1vZGVsLmdldCgndHJhaWxMZW5ndGgnKTtcbiAgICByZXR1cm4gdGhpcy5nZXREYXRhKCkuY291bnQoKSA+IHRoaXMuZ2V0UHJvZ3Jlc3NpdmVUaHJlc2hvbGQoKVxuICAgIC8vIEVhY2ggcHJvZ3Jlc3NpdmUgc2VyaWVzIGhhcyBpbmRpdmlkdWFsIGtleS5cbiAgICA/IHRoaXMuaWQgOiBlZmZlY3RNb2RlbC5nZXQoJ3Nob3cnKSAmJiB0cmFpbExlbmd0aCA+IDAgPyB0cmFpbExlbmd0aCArICcnIDogJyc7XG4gIH07XG4gIExpbmVzU2VyaWVzTW9kZWwudHlwZSA9ICdzZXJpZXMubGluZXMnO1xuICBMaW5lc1Nlcmllc01vZGVsLmRlcGVuZGVuY2llcyA9IFsnZ3JpZCcsICdwb2xhcicsICdnZW8nLCAnY2FsZW5kYXInXTtcbiAgTGluZXNTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdnZW8nLFxuICAgIC8vIHpsZXZlbDogMCxcbiAgICB6OiAyLFxuICAgIGxlZ2VuZEhvdmVyTGluazogdHJ1ZSxcbiAgICAvLyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICB4QXhpc0luZGV4OiAwLFxuICAgIHlBeGlzSW5kZXg6IDAsXG4gICAgc3ltYm9sOiBbJ25vbmUnLCAnbm9uZSddLFxuICAgIHN5bWJvbFNpemU6IFsxMCwgMTBdLFxuICAgIC8vIEdlbyBjb29yZGluYXRlIHN5c3RlbVxuICAgIGdlb0luZGV4OiAwLFxuICAgIGVmZmVjdDoge1xuICAgICAgc2hvdzogZmFsc2UsXG4gICAgICBwZXJpb2Q6IDQsXG4gICAgICBjb25zdGFudFNwZWVkOiAwLFxuICAgICAgc3ltYm9sOiAnY2lyY2xlJyxcbiAgICAgIHN5bWJvbFNpemU6IDMsXG4gICAgICBsb29wOiB0cnVlLFxuICAgICAgdHJhaWxMZW5ndGg6IDAuMlxuICAgIH0sXG4gICAgbGFyZ2U6IGZhbHNlLFxuICAgIC8vIEF2YWlsYWJsZSB3aGVuIGxhcmdlIGlzIHRydWVcbiAgICBsYXJnZVRocmVzaG9sZDogMjAwMCxcbiAgICBwb2x5bGluZTogZmFsc2UsXG4gICAgY2xpcDogdHJ1ZSxcbiAgICBsYWJlbDoge1xuICAgICAgc2hvdzogZmFsc2UsXG4gICAgICBwb3NpdGlvbjogJ2VuZCdcbiAgICAgIC8vIGRpc3RhbmNlOiA1LFxuICAgICAgLy8gZm9ybWF0dGVyOiDmoIfnrb7mlofmnKzmoLzlvI/lmajvvIzlkIxUb29sdGlwLmZvcm1hdHRlcu+8jOS4jeaUr+aMgeW8guatpeWbnuiwg1xuICAgIH0sXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICBvcGFjaXR5OiAwLjVcbiAgICB9XG4gIH07XG4gIHJldHVybiBMaW5lc1Nlcmllc01vZGVsO1xufShTZXJpZXNNb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBMaW5lc1Nlcmllc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuZnVuY3Rpb24gbm9ybWFsaXplKGEpIHtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIGEgPSBbYSwgYV07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG52YXIgbGluZXNWaXN1YWwgPSB7XG4gIHNlcmllc1R5cGU6ICdsaW5lcycsXG4gIHJlc2V0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgc3ltYm9sVHlwZSA9IG5vcm1hbGl6ZShzZXJpZXNNb2RlbC5nZXQoJ3N5bWJvbCcpKTtcbiAgICB2YXIgc3ltYm9sU2l6ZSA9IG5vcm1hbGl6ZShzZXJpZXNNb2RlbC5nZXQoJ3N5bWJvbFNpemUnKSk7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgZGF0YS5zZXRWaXN1YWwoJ2Zyb21TeW1ib2wnLCBzeW1ib2xUeXBlICYmIHN5bWJvbFR5cGVbMF0pO1xuICAgIGRhdGEuc2V0VmlzdWFsKCd0b1N5bWJvbCcsIHN5bWJvbFR5cGUgJiYgc3ltYm9sVHlwZVsxXSk7XG4gICAgZGF0YS5zZXRWaXN1YWwoJ2Zyb21TeW1ib2xTaXplJywgc3ltYm9sU2l6ZSAmJiBzeW1ib2xTaXplWzBdKTtcbiAgICBkYXRhLnNldFZpc3VhbCgndG9TeW1ib2xTaXplJywgc3ltYm9sU2l6ZSAmJiBzeW1ib2xTaXplWzFdKTtcbiAgICBmdW5jdGlvbiBkYXRhRWFjaChkYXRhLCBpZHgpIHtcbiAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgdmFyIHN5bWJvbFR5cGUgPSBub3JtYWxpemUoaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbCcsIHRydWUpKTtcbiAgICAgIHZhciBzeW1ib2xTaXplID0gbm9ybWFsaXplKGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xTaXplJywgdHJ1ZSkpO1xuICAgICAgc3ltYm9sVHlwZVswXSAmJiBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnZnJvbVN5bWJvbCcsIHN5bWJvbFR5cGVbMF0pO1xuICAgICAgc3ltYm9sVHlwZVsxXSAmJiBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAndG9TeW1ib2wnLCBzeW1ib2xUeXBlWzFdKTtcbiAgICAgIHN5bWJvbFNpemVbMF0gJiYgZGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwgJ2Zyb21TeW1ib2xTaXplJywgc3ltYm9sU2l6ZVswXSk7XG4gICAgICBzeW1ib2xTaXplWzFdICYmIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICd0b1N5bWJvbFNpemUnLCBzeW1ib2xTaXplWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGFFYWNoOiBkYXRhLmhhc0l0ZW1PcHRpb24gPyBkYXRhRWFjaCA6IG51bGxcbiAgICB9O1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgbGluZXNWaXN1YWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgTGluZXNWaWV3IGZyb20gJy4vTGluZXNWaWV3LmpzJztcbmltcG9ydCBMaW5lc1Nlcmllc01vZGVsIGZyb20gJy4vTGluZXNTZXJpZXMuanMnO1xuaW1wb3J0IGxpbmVzTGF5b3V0IGZyb20gJy4vbGluZXNMYXlvdXQuanMnO1xuaW1wb3J0IGxpbmVzVmlzdWFsIGZyb20gJy4vbGluZXNWaXN1YWwuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNoYXJ0VmlldyhMaW5lc1ZpZXcpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTZXJpZXNNb2RlbChMaW5lc1Nlcmllc01vZGVsKTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyTGF5b3V0KGxpbmVzTGF5b3V0KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyVmlzdWFsKGxpbmVzVmlzdWFsKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6325\n")},11734:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createSeriesData.js\nvar createSeriesData = __webpack_require__(13637);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js\nvar Series = __webpack_require__(47355);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/symbol.js\nvar util_symbol = __webpack_require__(62103);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n;// ./node_modules/echarts/lib/chart/line/LineSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar LineSeriesModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(LineSeriesModel, _super);\n  function LineSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = LineSeriesModel.type;\n    _this.hasSymbolVisual = true;\n    return _this;\n  }\n  LineSeriesModel.prototype.getInitialData = function (option) {\n    if (false) { var coordSys; }\n    return (0,createSeriesData/* default */.A)(null, this, {\n      useEncodeDefaulter: true\n    });\n  };\n  LineSeriesModel.prototype.getLegendIcon = function (opt) {\n    var group = new Group/* default */.A();\n    var line = (0,util_symbol/* createSymbol */.v5)('line', 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false);\n    group.add(line);\n    line.setStyle(opt.lineStyle);\n    var visualType = this.getData().getVisual('symbol');\n    var visualRotate = this.getData().getVisual('symbolRotate');\n    var symbolType = visualType === 'none' ? 'circle' : visualType;\n    // Symbol size is 80% when there is a line\n    var size = opt.itemHeight * 0.8;\n    var symbol = (0,util_symbol/* createSymbol */.v5)(symbolType, (opt.itemWidth - size) / 2, (opt.itemHeight - size) / 2, size, size, opt.itemStyle.fill);\n    group.add(symbol);\n    symbol.setStyle(opt.itemStyle);\n    var symbolRotate = opt.iconRotate === 'inherit' ? visualRotate : opt.iconRotate || 0;\n    symbol.rotation = symbolRotate * Math.PI / 180;\n    symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);\n    if (symbolType.indexOf('empty') > -1) {\n      symbol.style.stroke = symbol.style.fill;\n      symbol.style.fill = '#fff';\n      symbol.style.lineWidth = 2;\n    }\n    return group;\n  };\n  LineSeriesModel.type = 'series.line';\n  LineSeriesModel.dependencies = ['grid', 'polar'];\n  LineSeriesModel.defaultOption = {\n    // zlevel: 0,\n    z: 3,\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    clip: true,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    endLabel: {\n      show: false,\n      valueAnimation: true,\n      distance: 8\n    },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    emphasis: {\n      scale: true\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    symbol: 'emptyCircle',\n    symbolSize: 4,\n    symbolRotate: null,\n    showSymbol: true,\n    // `false`: follow the label interval strategy.\n    // `true`: show all symbols.\n    // `'auto'`: If possible, show all symbols, otherwise\n    //           follow the label interval strategy.\n    showAllSymbol: 'auto',\n    // Whether to connect break point.\n    connectNulls: false,\n    // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity,\n    universalTransition: {\n      divideShape: 'clone'\n    },\n    triggerLineEvent: false\n  };\n  return LineSeriesModel;\n}(Series/* default */.A);\n/* harmony default export */ const LineSeries = (LineSeriesModel);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/SymbolDraw.js\nvar SymbolDraw = __webpack_require__(18386);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/Symbol.js\nvar helper_Symbol = __webpack_require__(10128);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/dataStackHelper.js\nvar dataStackHelper = __webpack_require__(65008);\n;// ./node_modules/echarts/lib/chart/line/helper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var dims = (0,util.map)(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  var stacked = false;\n  var stackResultDim = data.getCalculationInfo('stackResultDimension');\n  if ((0,dataStackHelper/* isDimensionStacked */.sJ)(data, dims[0] /* , dims[1] */)) {\n    // jshint ignore:line\n    stacked = true;\n    dims[0] = stackResultDim;\n  }\n  if ((0,dataStackHelper/* isDimensionStacked */.sJ)(data, dims[1] /* , dims[0] */)) {\n    // jshint ignore:line\n    stacked = true;\n    dims[1] = stackResultDim;\n  }\n  return {\n    dataDimsForPoint: dims,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: !!stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  }\n  // If origin is specified as a number, use it as\n  // valueStart directly\n  else if ((0,util.isNumber)(valueOrigin) && !isNaN(valueOrigin)) {\n    valueStart = valueOrigin;\n  }\n  // auto\n  else {\n    // Both positive\n    if (extent[0] > 0) {\n      valueStart = extent[0];\n    }\n    // Both negative\n    else if (extent[1] < 0) {\n      valueStart = extent[1];\n    }\n    // If is one positive, and one negative, onZero shall be true\n  }\n  return valueStart;\n}\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/vendor.js\nvar vendor = __webpack_require__(8957);\n;// ./node_modules/echarts/lib/chart/line/lineAnimationDiff.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\nfunction lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData);\n  // let newIdList = newData.mapArray(newData.getId);\n  // let oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n  var currPoints = [];\n  var nextPoints = [];\n  // Points for stacking base line\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  // const oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n  var oldPoints = oldData.getLayout('points') || [];\n  var newPoints = newData.getLayout('points') || [];\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true;\n    var oldIdx2 = void 0;\n    var newIdx2 = void 0;\n    // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n    switch (diffItem.cmd) {\n      case '=':\n        oldIdx2 = diffItem.idx * 2;\n        newIdx2 = diffItem.idx1 * 2;\n        var currentX = oldPoints[oldIdx2];\n        var currentY = oldPoints[oldIdx2 + 1];\n        var nextX = newPoints[newIdx2];\n        var nextY = newPoints[newIdx2 + 1];\n        // If previous data is NaN, use next point directly\n        if (isNaN(currentX) || isNaN(currentY)) {\n          currentX = nextX;\n          currentY = nextY;\n        }\n        currPoints.push(currentX, currentY);\n        nextPoints.push(nextX, nextY);\n        currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);\n        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n      case '+':\n        var newIdx = diffItem.idx;\n        var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;\n        var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);\n        newIdx2 = newIdx * 2;\n        currPoints.push(oldPt[0], oldPt[1]);\n        nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);\n        var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);\n        currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);\n        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);\n        rawIndices.push(newData.getRawIndex(newIdx));\n        break;\n      case '-':\n        pointAdded = false;\n    }\n    // Original indices\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  }\n  // Diff result may be crossed if all items are changed\n  // Sort by data index\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var len = currPoints.length;\n  var sortedCurrPoints = (0,vendor/* createFloat32Array */.J)(len);\n  var sortedNextPoints = (0,vendor/* createFloat32Array */.J)(len);\n  var sortedCurrStackedPoints = (0,vendor/* createFloat32Array */.J)(len);\n  var sortedNextStackedPoints = (0,vendor/* createFloat32Array */.J)(len);\n  var sortedStatus = [];\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    var i2 = i * 2;\n    var idx2 = idx * 2;\n    sortedCurrPoints[i2] = currPoints[idx2];\n    sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];\n    sortedNextPoints[i2] = nextPoints[idx2];\n    sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];\n    sortedCurrStackedPoints[i2] = currStackedPoints[idx2];\n    sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];\n    sortedNextStackedPoints[i2] = nextStackedPoints[idx2];\n    sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];\n    sortedStatus[i] = status[idx];\n  }\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/LinearGradient.js\nvar LinearGradient = __webpack_require__(29668);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTransition.js\nvar basicTransition = __webpack_require__(5638);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/line/poly.js\nvar poly = __webpack_require__(53364);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(6666);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js\nvar createClipPathFromCoordSys = __webpack_require__(95235);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/CoordinateSystem.js\nvar CoordinateSystem = __webpack_require__(41849);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/labelHelper.js\nvar labelHelper = __webpack_require__(44532);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/format.js\nvar format = __webpack_require__(83412);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/tool/color.js\nvar tool_color = __webpack_require__(47698);\n;// ./node_modules/echarts/lib/chart/line/LineView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n// FIXME step not support polar\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n  for (var i = 0; i < points1.length; i++) {\n    if (points1[i] !== points2[i]) {\n      return;\n    }\n  }\n  return true;\n}\nfunction bboxFromPoints(points) {\n  var minX = Infinity;\n  var minY = Infinity;\n  var maxX = -Infinity;\n  var maxY = -Infinity;\n  for (var i = 0; i < points.length;) {\n    var x = points[i++];\n    var y = points[i++];\n    if (!isNaN(x)) {\n      minX = Math.min(x, minX);\n      maxX = Math.max(x, maxX);\n    }\n    if (!isNaN(y)) {\n      minY = Math.min(y, minY);\n      maxY = Math.max(y, maxY);\n    }\n  }\n  return [[minX, minY], [maxX, maxY]];\n}\nfunction getBoundingDiff(points1, points2) {\n  var _a = bboxFromPoints(points1),\n    min1 = _a[0],\n    max1 = _a[1];\n  var _b = bboxFromPoints(points2),\n    min2 = _b[0],\n    max2 = _b[1];\n  // Get a max value from each corner of two boundings.\n  return Math.max(Math.abs(min1[0] - min2[0]), Math.abs(min1[1] - min2[1]), Math.abs(max1[0] - max2[0]), Math.abs(max1[1] - max2[1]));\n}\nfunction getSmooth(smooth) {\n  return util.isNumber(smooth) ? smooth : smooth ? 0.5 : 0;\n}\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n  var len = data.count();\n  var points = (0,vendor/* createFloat32Array */.J)(len * 2);\n  for (var idx = 0; idx < len; idx++) {\n    var pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx);\n    points[idx * 2] = pt[0];\n    points[idx * 2 + 1] = pt[1];\n  }\n  return points;\n}\n/**\r\n * Filter the null data and extend data for step considering `stepTurnAt`\r\n *\r\n * @param points data to convert, that may containing null\r\n * @param basePoints base data to reference, used only for areaStyle points\r\n * @param coordSys coordinate system\r\n * @param stepTurnAt 'start' | 'end' | 'middle' | true\r\n * @param connectNulls whether to connect nulls\r\n * @returns converted point positions\r\n */\nfunction turnPointsIntoStep(points, basePoints, coordSys, stepTurnAt, connectNulls) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n  var i = 0;\n  var stepPt = [];\n  var pt = [];\n  var nextPt = [];\n  var filteredPoints = [];\n  if (connectNulls) {\n    for (i = 0; i < points.length; i += 2) {\n      /**\r\n       * For areaStyle of stepped lines, `stackedOnPoints` should be\r\n       * filtered the same as `points` so that the base axis values\r\n       * should stay the same as the lines above. See #20021\r\n       */\n      var reference = basePoints || points;\n      if (!isNaN(reference[i]) && !isNaN(reference[i + 1])) {\n        filteredPoints.push(points[i], points[i + 1]);\n      }\n    }\n    points = filteredPoints;\n  }\n  for (i = 0; i < points.length - 2; i += 2) {\n    nextPt[0] = points[i + 2];\n    nextPt[1] = points[i + 3];\n    pt[0] = points[i];\n    pt[1] = points[i + 1];\n    stepPoints.push(pt[0], pt[1]);\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPoints.push(stepPt[0], stepPt[1]);\n        break;\n      case 'middle':\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt[0], stepPt[1]);\n        stepPoints.push(stepPt2[0], stepPt2[1]);\n        break;\n      default:\n        // default is start\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt[0], stepPt[1]);\n    }\n  }\n  // Last points\n  stepPoints.push(points[i++], points[i++]);\n  return stepPoints;\n}\n/**\r\n * Clip color stops to edge. Avoid creating too large gradients.\r\n * Which may lead to blurry when GPU acceleration is enabled. See #15680\r\n *\r\n * The stops has been sorted from small to large.\r\n */\nfunction clipColorStops(colorStops, maxSize) {\n  var newColorStops = [];\n  var len = colorStops.length;\n  // coord will always < 0 in prevOutOfRangeColorStop.\n  var prevOutOfRangeColorStop;\n  var prevInRangeColorStop;\n  function lerpStop(stop0, stop1, clippedCoord) {\n    var coord0 = stop0.coord;\n    var p = (clippedCoord - coord0) / (stop1.coord - coord0);\n    var color = (0,tool_color.lerp)(p, [stop0.color, stop1.color]);\n    return {\n      coord: clippedCoord,\n      color: color\n    };\n  }\n  for (var i = 0; i < len; i++) {\n    var stop_1 = colorStops[i];\n    var coord = stop_1.coord;\n    if (coord < 0) {\n      prevOutOfRangeColorStop = stop_1;\n    } else if (coord > maxSize) {\n      if (prevInRangeColorStop) {\n        newColorStops.push(lerpStop(prevInRangeColorStop, stop_1, maxSize));\n      } else if (prevOutOfRangeColorStop) {\n        // If there are two stops and coord range is between these two stops\n        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0), lerpStop(prevOutOfRangeColorStop, stop_1, maxSize));\n      }\n      // All following stop will be out of range. So just ignore them.\n      break;\n    } else {\n      if (prevOutOfRangeColorStop) {\n        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0));\n        // Reset\n        prevOutOfRangeColorStop = null;\n      }\n      newColorStops.push(stop_1);\n      prevInRangeColorStop = stop_1;\n    }\n  }\n  return newColorStops;\n}\nfunction getVisualGradient(data, coordSys, api) {\n  var visualMetaList = data.getVisual('visualMeta');\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n  if (coordSys.type !== 'cartesian2d') {\n    if (false) {}\n    return;\n  }\n  var coordDim;\n  var visualMeta;\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimInfo = data.getDimensionInfo(visualMetaList[i].dimension);\n    coordDim = dimInfo && dimInfo.coordDim;\n    // Can only be x or y\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n  if (!visualMeta) {\n    if (false) {}\n    return;\n  }\n  // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n  var axis = coordSys.getAxis(coordDim);\n  // dataToCoord mapping may not be linear, but must be monotonic.\n  var colorStops = util.map(visualMeta.stops, function (stop) {\n    // offset will be calculated later.\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n  var colorStopsInRange = clipColorStops(colorStops, coordDim === 'x' ? api.getWidth() : api.getHeight());\n  var inRangeStopLen = colorStopsInRange.length;\n  if (!inRangeStopLen && stopLen) {\n    // All stops are out of range. All will be the same color.\n    return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color;\n  }\n  var tinyExtent = 10; // Arbitrary value: 10px\n  var minCoord = colorStopsInRange[0].coord - tinyExtent;\n  var maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n  util.each(colorStopsInRange, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStopsInRange.push({\n    // NOTE: inRangeStopLen may still be 0 if stoplen is zero.\n    offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStopsInRange.unshift({\n    offset: inRangeStopLen ? colorStopsInRange[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  });\n  var gradient = new LinearGradient/* default */.A(0, 0, 0, 0, colorStopsInRange, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\nfunction getIsIgnoreFunc(seriesModel, data, coordSys) {\n  var showAllSymbol = seriesModel.get('showAllSymbol');\n  var isAuto = showAllSymbol === 'auto';\n  if (showAllSymbol && !isAuto) {\n    return;\n  }\n  var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n  if (!categoryAxis) {\n    return;\n  }\n  // Note that category label interval strategy might bring some weird effect\n  // in some scenario: users may wonder why some of the symbols are not\n  // displayed. So we show all symbols as possible as we can.\n  if (isAuto\n  // Simplify the logic, do not determine label overlap here.\n  && canShowAllSymbolForCategory(categoryAxis, data)) {\n    return;\n  }\n  // Otherwise follow the label interval strategy on category axis.\n  var categoryDataDim = data.mapDimension(categoryAxis.dim);\n  var labelMap = {};\n  util.each(categoryAxis.getViewLabels(), function (labelItem) {\n    var ordinalNumber = categoryAxis.scale.getRawOrdinalNumber(labelItem.tickValue);\n    labelMap[ordinalNumber] = 1;\n  });\n  return function (dataIndex) {\n    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));\n  };\n}\nfunction canShowAllSymbolForCategory(categoryAxis, data) {\n  // In most cases, line is monotonous on category axis, and the label size\n  // is close with each other. So we check the symbol size and some of the\n  // label size alone with the category axis to estimate whether all symbol\n  // can be shown without overlap.\n  var axisExtent = categoryAxis.getExtent();\n  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();\n  isNaN(availSize) && (availSize = 0); // 0/0 is NaN.\n  // Sampling some points, max 5.\n  var dataLen = data.count();\n  var step = Math.max(1, Math.round(dataLen / 5));\n  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {\n    if (helper_Symbol/* default */.A.getSymbolSize(data, dataIndex\n    // Only for cartesian, where `isHorizontal` exists.\n    )[categoryAxis.isHorizontal() ? 1 : 0]\n    // Empirical number\n    * 1.5 > availSize) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPointNull(x, y) {\n  return isNaN(x) || isNaN(y);\n}\nfunction getLastIndexNotNull(points) {\n  var len = points.length / 2;\n  for (; len > 0; len--) {\n    if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n      break;\n    }\n  }\n  return len - 1;\n}\nfunction getPointAtIndex(points, idx) {\n  return [points[idx * 2], points[idx * 2 + 1]];\n}\nfunction getIndexRange(points, xOrY, dim) {\n  var len = points.length / 2;\n  var dimIdx = dim === 'x' ? 0 : 1;\n  var a;\n  var b;\n  var prevIndex = 0;\n  var nextIndex = -1;\n  for (var i = 0; i < len; i++) {\n    b = points[i * 2 + dimIdx];\n    if (isNaN(b) || isNaN(points[i * 2 + 1 - dimIdx])) {\n      continue;\n    }\n    if (i === 0) {\n      a = b;\n      continue;\n    }\n    if (a <= xOrY && b >= xOrY || a >= xOrY && b <= xOrY) {\n      nextIndex = i;\n      break;\n    }\n    prevIndex = i;\n    a = b;\n  }\n  return {\n    range: [prevIndex, nextIndex],\n    t: (xOrY - a) / (b - a)\n  };\n}\nfunction anyStateShowEndLabel(seriesModel) {\n  if (seriesModel.get(['endLabel', 'show'])) {\n    return true;\n  }\n  for (var i = 0; i < states/* SPECIAL_STATES */.BV.length; i++) {\n    if (seriesModel.get([states/* SPECIAL_STATES */.BV[i], 'endLabel', 'show'])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {\n  if ((0,CoordinateSystem/* isCoordinateSystemType */.g)(coordSys, 'cartesian2d')) {\n    var endLabelModel_1 = seriesModel.getModel('endLabel');\n    var valueAnimation_1 = endLabelModel_1.get('valueAnimation');\n    var data_1 = seriesModel.getData();\n    var labelAnimationRecord_1 = {\n      lastFrameIndex: 0\n    };\n    var during = anyStateShowEndLabel(seriesModel) ? function (percent, clipRect) {\n      lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);\n    } : null;\n    var isHorizontal = coordSys.getBaseAxis().isHorizontal();\n    var clipPath = (0,createClipPathFromCoordSys/* createGridClipPath */.SM)(coordSys, hasAnimation, seriesModel, function () {\n      var endLabel = lineView._endLabel;\n      if (endLabel && hasAnimation) {\n        if (labelAnimationRecord_1.originalX != null) {\n          endLabel.attr({\n            x: labelAnimationRecord_1.originalX,\n            y: labelAnimationRecord_1.originalY\n          });\n        }\n      }\n    }, during);\n    // Expand clip shape to avoid clipping when line value exceeds axis\n    if (!seriesModel.get('clip', true)) {\n      var rectShape = clipPath.shape;\n      var expandSize = Math.max(rectShape.width, rectShape.height);\n      if (isHorizontal) {\n        rectShape.y -= expandSize;\n        rectShape.height += expandSize * 2;\n      } else {\n        rectShape.x -= expandSize;\n        rectShape.width += expandSize * 2;\n      }\n    }\n    // Set to the final frame. To make sure label layout is right.\n    if (during) {\n      during(1, clipPath);\n    }\n    return clipPath;\n  } else {\n    if (false) {}\n    return (0,createClipPathFromCoordSys/* createPolarClipPath */.Mi)(coordSys, hasAnimation, seriesModel);\n  }\n}\nfunction getEndLabelStateSpecified(endLabelModel, coordSys) {\n  var baseAxis = coordSys.getBaseAxis();\n  var isHorizontal = baseAxis.isHorizontal();\n  var isBaseInversed = baseAxis.inverse;\n  var align = isHorizontal ? isBaseInversed ? 'right' : 'left' : 'center';\n  var verticalAlign = isHorizontal ? 'middle' : isBaseInversed ? 'top' : 'bottom';\n  return {\n    normal: {\n      align: endLabelModel.get('align') || align,\n      verticalAlign: endLabelModel.get('verticalAlign') || verticalAlign\n    }\n  };\n}\nvar LineView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(LineView, _super);\n  function LineView() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  LineView.prototype.init = function () {\n    var lineGroup = new Group/* default */.A();\n    var symbolDraw = new SymbolDraw/* default */.A();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n    this._changePolyState = util.bind(this._changePolyState, this);\n  };\n  LineView.prototype.render = function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.getLayout('points') || [];\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = !ecModel.ssr && seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n    var connectNulls = seriesModel.get('connectNulls');\n    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);\n    // Remove temporary symbols\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    // Remove previous created symbols if showSymbol changed to false\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n    group.add(lineGroup);\n    // FIXME step not support polar\n    var step = !isCoordSysPolar ? seriesModel.get('step') : false;\n    var clipShapeForSymbol;\n    if (coordSys && coordSys.getArea && seriesModel.get('clip', true)) {\n      clipShapeForSymbol = coordSys.getArea();\n      // Avoid float number rounding error for symbol on the edge of axis extent.\n      // See #7913 and `test/dataZoom-clip.html`.\n      if (clipShapeForSymbol.width != null) {\n        clipShapeForSymbol.x -= 0.1;\n        clipShapeForSymbol.y -= 0.1;\n        clipShapeForSymbol.width += 0.2;\n        clipShapeForSymbol.height += 0.2;\n      } else if (clipShapeForSymbol.r0) {\n        clipShapeForSymbol.r0 -= 0.5;\n        clipShapeForSymbol.r += 0.5;\n      }\n    }\n    this._clipShapeForSymbol = clipShapeForSymbol;\n    var visualColor = getVisualGradient(data, coordSys, api) || data.getVisual('style')[data.getVisual('drawType')];\n    // Initialization animation or coordinate system changed\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isIgnoreFunc,\n        clipShape: clipShapeForSymbol,\n        disableAnimation: true,\n        getSymbolPoint: function (idx) {\n          return [points[idx * 2], points[idx * 2 + 1]];\n        }\n      });\n      hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);\n      if (step) {\n        if (stackedOnPoints) {\n          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, points, coordSys, step, connectNulls);\n        }\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, null, coordSys, step, connectNulls);\n      }\n      polyline = this._newPolyline(points);\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints);\n      } // If areaStyle is removed\n      else if (polygon) {\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      }\n      // NOTE: Must update _endLabel before setClipPath.\n      if (!isCoordSysPolar) {\n        this._initOrUpdateEndLabel(seriesModel, coordSys, (0,format/* convertToColorString */.he)(visualColor));\n      }\n      lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      }\n      // NOTE: Must update _endLabel before setClipPath.\n      if (!isCoordSysPolar) {\n        this._initOrUpdateEndLabel(seriesModel, coordSys, (0,format/* convertToColorString */.he)(visualColor));\n      }\n      // Update clipPath\n      var oldClipPath = lineGroup.getClipPath();\n      if (oldClipPath) {\n        var newClipPath = createLineClipPath(this, coordSys, false, seriesModel);\n        basicTransition/* initProps */.LW(oldClipPath, {\n          shape: newClipPath.shape\n        }, seriesModel);\n      } else {\n        lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));\n      }\n      // Always update, or it is wrong in the case turning on legend\n      // because points are not changed.\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isIgnoreFunc,\n        clipShape: clipShapeForSymbol,\n        disableAnimation: true,\n        getSymbolPoint: function (idx) {\n          return [points[idx * 2], points[idx * 2 + 1]];\n        }\n      });\n      // In the case data zoom triggered refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing.\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._doUpdateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            if (stackedOnPoints) {\n              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, points, coordSys, step, connectNulls);\n            }\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, null, coordSys, step, connectNulls);\n          }\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n    var emphasisModel = seriesModel.getModel('emphasis');\n    var focus = emphasisModel.get('focus');\n    var blurScope = emphasisModel.get('blurScope');\n    var emphasisDisabled = emphasisModel.get('disabled');\n    polyline.useStyle(util.defaults(\n    // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    (0,states/* setStatesStylesFromModel */.Mx)(polyline, seriesModel, 'lineStyle');\n    if (polyline.style.lineWidth > 0 && seriesModel.get(['emphasis', 'lineStyle', 'width']) === 'bolder') {\n      var emphasisLineStyle = polyline.getState('emphasis').style;\n      emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1;\n    }\n    // Needs seriesIndex for focus\n    (0,innerStore/* getECData */.z)(polyline).seriesIndex = seriesModel.seriesIndex;\n    (0,states/* toggleHoverEmphasis */.Lm)(polyline, focus, blurScope, emphasisDisabled);\n    var smooth = getSmooth(seriesModel.get('smooth'));\n    var smoothMonotone = seriesModel.get('smoothMonotone');\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: smoothMonotone,\n      connectNulls: connectNulls\n    });\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(util.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel',\n        decal: data.getVisual('style').decal\n      }));\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: smoothMonotone,\n        connectNulls: connectNulls\n      });\n      (0,states/* setStatesStylesFromModel */.Mx)(polygon, seriesModel, 'areaStyle');\n      // Needs seriesIndex for focus\n      (0,innerStore/* getECData */.z)(polygon).seriesIndex = seriesModel.seriesIndex;\n      (0,states/* toggleHoverEmphasis */.Lm)(polygon, focus, blurScope, emphasisDisabled);\n    }\n    var changePolyState = this._changePolyState;\n    data.eachItemGraphicEl(function (el) {\n      // Switch polyline / polygon state if element changed its state.\n      el && (el.onHoverStateChange = changePolyState);\n    });\n    this._polyline.onHoverStateChange = changePolyState;\n    this._data = data;\n    // Save the coordinate system for transition animation when data changed\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n    if (seriesModel.get('triggerLineEvent')) {\n      this.packEventData(seriesModel, polyline);\n      polygon && this.packEventData(seriesModel, polygon);\n    }\n  };\n  LineView.prototype.packEventData = function (seriesModel, el) {\n    (0,innerStore/* getECData */.z)(el).eventData = {\n      componentType: 'series',\n      componentSubType: 'line',\n      componentIndex: seriesModel.componentIndex,\n      seriesIndex: seriesModel.seriesIndex,\n      seriesName: seriesModel.name,\n      seriesType: 'line'\n    };\n  };\n  LineView.prototype.highlight = function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = model/* queryDataIndex */.le(data, payload);\n    this._changePolyState('emphasis');\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var points = data.getLayout('points');\n      var symbol = data.getItemGraphicEl(dataIndex);\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var x = points[dataIndex * 2];\n        var y = points[dataIndex * 2 + 1];\n        if (isNaN(x) || isNaN(y)) {\n          // Null data\n          return;\n        }\n        // fix #11360: shouldn't draw symbol outside clipShapeForSymbol\n        if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x, y)) {\n          return;\n        }\n        var zlevel = seriesModel.get('zlevel') || 0;\n        var z = seriesModel.get('z') || 0;\n        symbol = new helper_Symbol/* default */.A(data, dataIndex);\n        symbol.x = x;\n        symbol.y = y;\n        symbol.setZ(zlevel, z);\n        // ensure label text of the temporary symbol is in front of line and area polygon\n        var symbolLabel = symbol.getSymbolPath().getTextContent();\n        if (symbolLabel) {\n          symbolLabel.zlevel = zlevel;\n          symbolLabel.z = z;\n          symbolLabel.z2 = this._polyline.z2 + 1;\n        }\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol);\n        // Stop scale animation\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      Chart/* default */.A.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  };\n  LineView.prototype.downplay = function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = model/* queryDataIndex */.le(data, payload);\n    this._changePolyState('normal');\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      Chart/* default */.A.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  };\n  LineView.prototype._changePolyState = function (toState) {\n    var polygon = this._polygon;\n    (0,states/* setStatesFlag */.Pk)(this._polyline, toState);\n    polygon && (0,states/* setStatesFlag */.Pk)(polygon, toState);\n  };\n  LineView.prototype._newPolyline = function (points) {\n    var polyline = this._polyline;\n    // Remove previous created polyline\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n    polyline = new poly/* ECPolyline */.N({\n      shape: {\n        points: points\n      },\n      segmentIgnoreThreshold: 2,\n      z2: 10\n    });\n    this._lineGroup.add(polyline);\n    this._polyline = polyline;\n    return polyline;\n  };\n  LineView.prototype._newPolygon = function (points, stackedOnPoints) {\n    var polygon = this._polygon;\n    // Remove previous created polygon\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n    polygon = new poly/* ECPolygon */.z({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      segmentIgnoreThreshold: 2\n    });\n    this._lineGroup.add(polygon);\n    this._polygon = polygon;\n    return polygon;\n  };\n  LineView.prototype._initSymbolLabelAnimation = function (data, coordSys, clipShape) {\n    var isHorizontalOrRadial;\n    var isCoordSysPolar;\n    var baseAxis = coordSys.getBaseAxis();\n    var isAxisInverse = baseAxis.inverse;\n    if (coordSys.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n      isCoordSysPolar = false;\n    } else if (coordSys.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n      isCoordSysPolar = true;\n    }\n    var seriesModel = data.hostModel;\n    var seriesDuration = seriesModel.get('animationDuration');\n    if (util.isFunction(seriesDuration)) {\n      seriesDuration = seriesDuration(null);\n    }\n    var seriesDelay = seriesModel.get('animationDelay') || 0;\n    var seriesDelayValue = util.isFunction(seriesDelay) ? seriesDelay(null) : seriesDelay;\n    data.eachItemGraphicEl(function (symbol, idx) {\n      var el = symbol;\n      if (el) {\n        var point = [symbol.x, symbol.y];\n        var start = void 0;\n        var end = void 0;\n        var current = void 0;\n        if (clipShape) {\n          if (isCoordSysPolar) {\n            var polarClip = clipShape;\n            var coord = coordSys.pointToCoord(point);\n            if (isHorizontalOrRadial) {\n              start = polarClip.startAngle;\n              end = polarClip.endAngle;\n              current = -coord[1] / 180 * Math.PI;\n            } else {\n              start = polarClip.r0;\n              end = polarClip.r;\n              current = coord[0];\n            }\n          } else {\n            var gridClip = clipShape;\n            if (isHorizontalOrRadial) {\n              start = gridClip.x;\n              end = gridClip.x + gridClip.width;\n              current = symbol.x;\n            } else {\n              start = gridClip.y + gridClip.height;\n              end = gridClip.y;\n              current = symbol.y;\n            }\n          }\n        }\n        var ratio = end === start ? 0 : (current - start) / (end - start);\n        if (isAxisInverse) {\n          ratio = 1 - ratio;\n        }\n        var delay = util.isFunction(seriesDelay) ? seriesDelay(idx) : seriesDuration * ratio + seriesDelayValue;\n        var symbolPath = el.getSymbolPath();\n        var text = symbolPath.getTextContent();\n        el.attr({\n          scaleX: 0,\n          scaleY: 0\n        });\n        el.animateTo({\n          scaleX: 1,\n          scaleY: 1\n        }, {\n          duration: 200,\n          setToFinal: true,\n          delay: delay\n        });\n        if (text) {\n          text.animateFrom({\n            style: {\n              opacity: 0\n            }\n          }, {\n            duration: 300,\n            delay: delay\n          });\n        }\n        symbolPath.disableLabelAnimation = true;\n      }\n    });\n  };\n  LineView.prototype._initOrUpdateEndLabel = function (seriesModel, coordSys, inheritColor) {\n    var endLabelModel = seriesModel.getModel('endLabel');\n    if (anyStateShowEndLabel(seriesModel)) {\n      var data_2 = seriesModel.getData();\n      var polyline = this._polyline;\n      // series may be filtered.\n      var points = data_2.getLayout('points');\n      if (!points) {\n        polyline.removeTextContent();\n        this._endLabel = null;\n        return;\n      }\n      var endLabel = this._endLabel;\n      if (!endLabel) {\n        endLabel = this._endLabel = new Text/* default */.Ay({\n          z2: 200 // should be higher than item symbol\n        });\n        endLabel.ignoreClip = true;\n        polyline.setTextContent(this._endLabel);\n        polyline.disableLabelAnimation = true;\n      }\n      // Find last non-NaN data to display data\n      var dataIndex = getLastIndexNotNull(points);\n      if (dataIndex >= 0) {\n        (0,labelStyle/* setLabelStyle */.qM)(polyline, (0,labelStyle/* getLabelStatesModels */.lx)(seriesModel, 'endLabel'), {\n          inheritColor: inheritColor,\n          labelFetcher: seriesModel,\n          labelDataIndex: dataIndex,\n          defaultText: function (dataIndex, opt, interpolatedValue) {\n            return interpolatedValue != null ? (0,labelHelper/* getDefaultInterpolatedLabel */.T)(data_2, interpolatedValue) : (0,labelHelper/* getDefaultLabel */.i)(data_2, dataIndex);\n          },\n          enableTextSetter: true\n        }, getEndLabelStateSpecified(endLabelModel, coordSys));\n        polyline.textConfig.position = null;\n      }\n    } else if (this._endLabel) {\n      this._polyline.removeTextContent();\n      this._endLabel = null;\n    }\n  };\n  LineView.prototype._endLabelOnDuring = function (percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {\n    var endLabel = this._endLabel;\n    var polyline = this._polyline;\n    if (endLabel) {\n      // NOTE: Don't remove percent < 1. percent === 1 means the first frame during render.\n      // The label is not prepared at this time.\n      if (percent < 1 && animationRecord.originalX == null) {\n        animationRecord.originalX = endLabel.x;\n        animationRecord.originalY = endLabel.y;\n      }\n      var points = data.getLayout('points');\n      var seriesModel = data.hostModel;\n      var connectNulls = seriesModel.get('connectNulls');\n      var precision = endLabelModel.get('precision');\n      var distance = endLabelModel.get('distance') || 0;\n      var baseAxis = coordSys.getBaseAxis();\n      var isHorizontal = baseAxis.isHorizontal();\n      var isBaseInversed = baseAxis.inverse;\n      var clipShape = clipRect.shape;\n      var xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;\n      var distanceX = (isHorizontal ? distance : 0) * (isBaseInversed ? -1 : 1);\n      var distanceY = (isHorizontal ? 0 : -distance) * (isBaseInversed ? -1 : 1);\n      var dim = isHorizontal ? 'x' : 'y';\n      var dataIndexRange = getIndexRange(points, xOrY, dim);\n      var indices = dataIndexRange.range;\n      var diff = indices[1] - indices[0];\n      var value = void 0;\n      if (diff >= 1) {\n        // diff > 1 && connectNulls, which is on the null data.\n        if (diff > 1 && !connectNulls) {\n          var pt = getPointAtIndex(points, indices[0]);\n          endLabel.attr({\n            x: pt[0] + distanceX,\n            y: pt[1] + distanceY\n          });\n          valueAnimation && (value = seriesModel.getRawValue(indices[0]));\n        } else {\n          var pt = polyline.getPointOn(xOrY, dim);\n          pt && endLabel.attr({\n            x: pt[0] + distanceX,\n            y: pt[1] + distanceY\n          });\n          var startValue = seriesModel.getRawValue(indices[0]);\n          var endValue = seriesModel.getRawValue(indices[1]);\n          valueAnimation && (value = model/* interpolateRawValues */.Il(data, precision, startValue, endValue, dataIndexRange.t));\n        }\n        animationRecord.lastFrameIndex = indices[0];\n      } else {\n        // If diff <= 0, which is the range is not found(Include NaN)\n        // Choose the first point or last point.\n        var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;\n        var pt = getPointAtIndex(points, idx);\n        valueAnimation && (value = seriesModel.getRawValue(idx));\n        endLabel.attr({\n          x: pt[0] + distanceX,\n          y: pt[1] + distanceY\n        });\n      }\n      if (valueAnimation) {\n        var inner = (0,labelStyle/* labelInner */.Lu)(endLabel);\n        if (typeof inner.setLabelText === 'function') {\n          inner.setLabelText(value);\n        }\n      }\n    }\n  };\n  /**\r\n   * @private\r\n   */\n  // FIXME Two value axis\n  LineView.prototype._doUpdateAnimation = function (data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n    if (step) {\n      // TODO If stacked series is not step\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, diff.current, coordSys, step, connectNulls);\n      current = turnPointsIntoStep(diff.current, null, coordSys, step, connectNulls);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, diff.next, coordSys, step, connectNulls);\n      next = turnPointsIntoStep(diff.next, null, coordSys, step, connectNulls);\n    }\n    // Don't apply animation if diff is large.\n    // For better result and avoid memory explosion problems like\n    // https://github.com/apache/incubator-echarts/issues/12229\n    if (getBoundingDiff(current, next) > 3000 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3000) {\n      polyline.stopAnimation();\n      polyline.setShape({\n        points: next\n      });\n      if (polygon) {\n        polygon.stopAnimation();\n        polygon.setShape({\n          points: next,\n          stackedOnPoints: stackedOnNext\n        });\n      }\n      return;\n    }\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    var target = {\n      shape: {\n        points: next\n      }\n    };\n    // Also animate the original points.\n    // If points reference is changed when turning into step line.\n    if (diff.current !== current) {\n      target.shape.__points = diff.next;\n    }\n    // Stop previous animation.\n    polyline.stopAnimation();\n    basicTransition/* updateProps */.oi(polyline, target, seriesModel);\n    if (polygon) {\n      polygon.setShape({\n        // Reuse the points with polyline.\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      polygon.stopAnimation();\n      basicTransition/* updateProps */.oi(polygon, {\n        shape: {\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n      // If use attr directly in updateProps.\n      if (polyline.shape.points !== polygon.shape.points) {\n        polygon.shape.points = polyline.shape.points;\n      }\n    }\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n          });\n        }\n      }\n    }\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        polygon && polygon.dirtyShape();\n        var points = polyline.shape.__points;\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          var offset = updatedDataInfo[i].ptIdx * 2;\n          el.x = points[offset];\n          el.y = points[offset + 1];\n          el.markRedraw();\n        }\n      });\n    }\n  };\n  LineView.prototype.remove = function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n    this._lineGroup.removeAll();\n    this._symbolDraw.remove(true);\n    // Remove temporary created elements when highlighting\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;\n  };\n  LineView.type = 'line';\n  return LineView;\n}(Chart/* default */.A);\n/* harmony default export */ const line_LineView = (LineView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/layout/points.js\nvar points = __webpack_require__(30682);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/processor/dataSample.js\nvar dataSample = __webpack_require__(37959);\n;// ./node_modules/echarts/lib/chart/line/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n// In case developer forget to include grid component\n\n\nfunction install(registers) {\n  registers.registerChartView(line_LineView);\n  registers.registerSeriesModel(LineSeries);\n  registers.registerLayout((0,points/* default */.A)('line', true));\n  registers.registerVisual({\n    seriesType: 'line',\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      // Visual coding for legend\n      var lineStyle = seriesModel.getModel('lineStyle').getLineStyle();\n      if (lineStyle && !lineStyle.stroke) {\n        // Fill in visual should be palette color if\n        // has color callback\n        lineStyle.stroke = data.getVisual('style').fill;\n      }\n      data.setVisual('legendLineStyle', lineStyle);\n    }\n  });\n  // Down sample after filter\n  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, (0,dataSample/* default */.A)('line'));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE3MzQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDOWxDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9MaW5lU2VyaWVzLmpzP2ZjNzQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvaGVscGVyLmpzP2FkMzkiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvbGluZUFuaW1hdGlvbkRpZmYuanM/MjZhZiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9MaW5lVmlldy5qcz9mMWY3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL2luc3RhbGwuanM/YjJjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IGNyZWF0ZVNlcmllc0RhdGEgZnJvbSAnLi4vaGVscGVyL2NyZWF0ZVNlcmllc0RhdGEuanMnO1xuaW1wb3J0IFNlcmllc01vZGVsIGZyb20gJy4uLy4uL21vZGVsL1Nlcmllcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTeW1ib2wgfSBmcm9tICcuLi8uLi91dGlsL3N5bWJvbC5qcyc7XG5pbXBvcnQgeyBHcm91cCB9IGZyb20gJy4uLy4uL3V0aWwvZ3JhcGhpYy5qcyc7XG52YXIgTGluZVNlcmllc01vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKExpbmVTZXJpZXNNb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gTGluZVNlcmllc01vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBMaW5lU2VyaWVzTW9kZWwudHlwZTtcbiAgICBfdGhpcy5oYXNTeW1ib2xWaXN1YWwgPSB0cnVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBMaW5lU2VyaWVzTW9kZWwucHJvdG90eXBlLmdldEluaXRpYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29vcmRTeXMgPSBvcHRpb24uY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgIGlmIChjb29yZFN5cyAhPT0gJ3BvbGFyJyAmJiBjb29yZFN5cyAhPT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmUgbm90IHN1cHBvcnQgY29vcmRpbmF0ZVN5c3RlbSBiZXNpZGVzIGNhcnRlc2lhbiBhbmQgcG9sYXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVNlcmllc0RhdGEobnVsbCwgdGhpcywge1xuICAgICAgdXNlRW5jb2RlRGVmYXVsdGVyOiB0cnVlXG4gICAgfSk7XG4gIH07XG4gIExpbmVTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0TGVnZW5kSWNvbiA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgICB2YXIgbGluZSA9IGNyZWF0ZVN5bWJvbCgnbGluZScsIDAsIG9wdC5pdGVtSGVpZ2h0IC8gMiwgb3B0Lml0ZW1XaWR0aCwgMCwgb3B0LmxpbmVTdHlsZS5zdHJva2UsIGZhbHNlKTtcbiAgICBncm91cC5hZGQobGluZSk7XG4gICAgbGluZS5zZXRTdHlsZShvcHQubGluZVN0eWxlKTtcbiAgICB2YXIgdmlzdWFsVHlwZSA9IHRoaXMuZ2V0RGF0YSgpLmdldFZpc3VhbCgnc3ltYm9sJyk7XG4gICAgdmFyIHZpc3VhbFJvdGF0ZSA9IHRoaXMuZ2V0RGF0YSgpLmdldFZpc3VhbCgnc3ltYm9sUm90YXRlJyk7XG4gICAgdmFyIHN5bWJvbFR5cGUgPSB2aXN1YWxUeXBlID09PSAnbm9uZScgPyAnY2lyY2xlJyA6IHZpc3VhbFR5cGU7XG4gICAgLy8gU3ltYm9sIHNpemUgaXMgODAlIHdoZW4gdGhlcmUgaXMgYSBsaW5lXG4gICAgdmFyIHNpemUgPSBvcHQuaXRlbUhlaWdodCAqIDAuODtcbiAgICB2YXIgc3ltYm9sID0gY3JlYXRlU3ltYm9sKHN5bWJvbFR5cGUsIChvcHQuaXRlbVdpZHRoIC0gc2l6ZSkgLyAyLCAob3B0Lml0ZW1IZWlnaHQgLSBzaXplKSAvIDIsIHNpemUsIHNpemUsIG9wdC5pdGVtU3R5bGUuZmlsbCk7XG4gICAgZ3JvdXAuYWRkKHN5bWJvbCk7XG4gICAgc3ltYm9sLnNldFN0eWxlKG9wdC5pdGVtU3R5bGUpO1xuICAgIHZhciBzeW1ib2xSb3RhdGUgPSBvcHQuaWNvblJvdGF0ZSA9PT0gJ2luaGVyaXQnID8gdmlzdWFsUm90YXRlIDogb3B0Lmljb25Sb3RhdGUgfHwgMDtcbiAgICBzeW1ib2wucm90YXRpb24gPSBzeW1ib2xSb3RhdGUgKiBNYXRoLlBJIC8gMTgwO1xuICAgIHN5bWJvbC5zZXRPcmlnaW4oW29wdC5pdGVtV2lkdGggLyAyLCBvcHQuaXRlbUhlaWdodCAvIDJdKTtcbiAgICBpZiAoc3ltYm9sVHlwZS5pbmRleE9mKCdlbXB0eScpID4gLTEpIHtcbiAgICAgIHN5bWJvbC5zdHlsZS5zdHJva2UgPSBzeW1ib2wuc3R5bGUuZmlsbDtcbiAgICAgIHN5bWJvbC5zdHlsZS5maWxsID0gJyNmZmYnO1xuICAgICAgc3ltYm9sLnN0eWxlLmxpbmVXaWR0aCA9IDI7XG4gICAgfVxuICAgIHJldHVybiBncm91cDtcbiAgfTtcbiAgTGluZVNlcmllc01vZGVsLnR5cGUgPSAnc2VyaWVzLmxpbmUnO1xuICBMaW5lU2VyaWVzTW9kZWwuZGVwZW5kZW5jaWVzID0gWydncmlkJywgJ3BvbGFyJ107XG4gIExpbmVTZXJpZXNNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIC8vIHpsZXZlbDogMCxcbiAgICB6OiAzLFxuICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdjYXJ0ZXNpYW4yZCcsXG4gICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgIGNsaXA6IHRydWUsXG4gICAgbGFiZWw6IHtcbiAgICAgIHBvc2l0aW9uOiAndG9wJ1xuICAgIH0sXG4gICAgLy8gaXRlbVN0eWxlOiB7XG4gICAgLy8gfSxcbiAgICBlbmRMYWJlbDoge1xuICAgICAgc2hvdzogZmFsc2UsXG4gICAgICB2YWx1ZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgIGRpc3RhbmNlOiA4XG4gICAgfSxcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIHdpZHRoOiAyLFxuICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIHNjYWxlOiB0cnVlXG4gICAgfSxcbiAgICAvLyBhcmVhU3R5bGU6IHtcbiAgICAvLyBvcmlnaW4gb2YgYXJlYVN0eWxlLiBWYWxpZCB2YWx1ZXM6XG4gICAgLy8gYCdhdXRvJy9udWxsL3VuZGVmaW5lZGA6IGZyb20gYXhpc0xpbmUgdG8gZGF0YVxuICAgIC8vIGAnc3RhcnQnYDogZnJvbSBtaW4gdG8gZGF0YVxuICAgIC8vIGAnZW5kJ2A6IGZyb20gZGF0YSB0byBtYXhcbiAgICAvLyBvcmlnaW46ICdhdXRvJ1xuICAgIC8vIH0sXG4gICAgLy8gZmFsc2UsICdzdGFydCcsICdlbmQnLCAnbWlkZGxlJ1xuICAgIHN0ZXA6IGZhbHNlLFxuICAgIC8vIERpc2FibGVkIGlmIHN0ZXAgaXMgdHJ1ZVxuICAgIHNtb290aDogZmFsc2UsXG4gICAgc21vb3RoTW9ub3RvbmU6IG51bGwsXG4gICAgc3ltYm9sOiAnZW1wdHlDaXJjbGUnLFxuICAgIHN5bWJvbFNpemU6IDQsXG4gICAgc3ltYm9sUm90YXRlOiBudWxsLFxuICAgIHNob3dTeW1ib2w6IHRydWUsXG4gICAgLy8gYGZhbHNlYDogZm9sbG93IHRoZSBsYWJlbCBpbnRlcnZhbCBzdHJhdGVneS5cbiAgICAvLyBgdHJ1ZWA6IHNob3cgYWxsIHN5bWJvbHMuXG4gICAgLy8gYCdhdXRvJ2A6IElmIHBvc3NpYmxlLCBzaG93IGFsbCBzeW1ib2xzLCBvdGhlcndpc2VcbiAgICAvLyAgICAgICAgICAgZm9sbG93IHRoZSBsYWJlbCBpbnRlcnZhbCBzdHJhdGVneS5cbiAgICBzaG93QWxsU3ltYm9sOiAnYXV0bycsXG4gICAgLy8gV2hldGhlciB0byBjb25uZWN0IGJyZWFrIHBvaW50LlxuICAgIGNvbm5lY3ROdWxsczogZmFsc2UsXG4gICAgLy8gU2FtcGxpbmcgZm9yIGxhcmdlIGRhdGEuIENhbiBiZTogJ2F2ZXJhZ2UnLCAnbWF4JywgJ21pbicsICdzdW0nLCAnbHR0YicuXG4gICAgc2FtcGxpbmc6ICdub25lJyxcbiAgICBhbmltYXRpb25FYXNpbmc6ICdsaW5lYXInLFxuICAgIC8vIERpc2FibGUgcHJvZ3Jlc3NpdmVcbiAgICBwcm9ncmVzc2l2ZTogMCxcbiAgICBob3ZlckxheWVyVGhyZXNob2xkOiBJbmZpbml0eSxcbiAgICB1bml2ZXJzYWxUcmFuc2l0aW9uOiB7XG4gICAgICBkaXZpZGVTaGFwZTogJ2Nsb25lJ1xuICAgIH0sXG4gICAgdHJpZ2dlckxpbmVFdmVudDogZmFsc2VcbiAgfTtcbiAgcmV0dXJuIExpbmVTZXJpZXNNb2RlbDtcbn0oU2VyaWVzTW9kZWwpO1xuZXhwb3J0IGRlZmF1bHQgTGluZVNlcmllc01vZGVsOyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgaXNEaW1lbnNpb25TdGFja2VkIH0gZnJvbSAnLi4vLi4vZGF0YS9oZWxwZXIvZGF0YVN0YWNrSGVscGVyLmpzJztcbmltcG9ydCB7IGlzTnVtYmVyLCBtYXAgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVEYXRhQ29vcmRJbmZvKGNvb3JkU3lzLCBkYXRhLCB2YWx1ZU9yaWdpbikge1xuICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICB2YXIgdmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKTtcbiAgdmFyIHZhbHVlU3RhcnQgPSBnZXRWYWx1ZVN0YXJ0KHZhbHVlQXhpcywgdmFsdWVPcmlnaW4pO1xuICB2YXIgYmFzZUF4aXNEaW0gPSBiYXNlQXhpcy5kaW07XG4gIHZhciB2YWx1ZUF4aXNEaW0gPSB2YWx1ZUF4aXMuZGltO1xuICB2YXIgdmFsdWVEaW0gPSBkYXRhLm1hcERpbWVuc2lvbih2YWx1ZUF4aXNEaW0pO1xuICB2YXIgYmFzZURpbSA9IGRhdGEubWFwRGltZW5zaW9uKGJhc2VBeGlzRGltKTtcbiAgdmFyIGJhc2VEYXRhT2Zmc2V0ID0gdmFsdWVBeGlzRGltID09PSAneCcgfHwgdmFsdWVBeGlzRGltID09PSAncmFkaXVzJyA/IDEgOiAwO1xuICB2YXIgZGltcyA9IG1hcChjb29yZFN5cy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoY29vcmREaW0pIHtcbiAgICByZXR1cm4gZGF0YS5tYXBEaW1lbnNpb24oY29vcmREaW0pO1xuICB9KTtcbiAgdmFyIHN0YWNrZWQgPSBmYWxzZTtcbiAgdmFyIHN0YWNrUmVzdWx0RGltID0gZGF0YS5nZXRDYWxjdWxhdGlvbkluZm8oJ3N0YWNrUmVzdWx0RGltZW5zaW9uJyk7XG4gIGlmIChpc0RpbWVuc2lvblN0YWNrZWQoZGF0YSwgZGltc1swXSAvKiAsIGRpbXNbMV0gKi8pKSB7XG4gICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgc3RhY2tlZCA9IHRydWU7XG4gICAgZGltc1swXSA9IHN0YWNrUmVzdWx0RGltO1xuICB9XG4gIGlmIChpc0RpbWVuc2lvblN0YWNrZWQoZGF0YSwgZGltc1sxXSAvKiAsIGRpbXNbMF0gKi8pKSB7XG4gICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgc3RhY2tlZCA9IHRydWU7XG4gICAgZGltc1sxXSA9IHN0YWNrUmVzdWx0RGltO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YURpbXNGb3JQb2ludDogZGltcyxcbiAgICB2YWx1ZVN0YXJ0OiB2YWx1ZVN0YXJ0LFxuICAgIHZhbHVlQXhpc0RpbTogdmFsdWVBeGlzRGltLFxuICAgIGJhc2VBeGlzRGltOiBiYXNlQXhpc0RpbSxcbiAgICBzdGFja2VkOiAhIXN0YWNrZWQsXG4gICAgdmFsdWVEaW06IHZhbHVlRGltLFxuICAgIGJhc2VEaW06IGJhc2VEaW0sXG4gICAgYmFzZURhdGFPZmZzZXQ6IGJhc2VEYXRhT2Zmc2V0LFxuICAgIHN0YWNrZWRPdmVyRGltZW5zaW9uOiBkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZE92ZXJEaW1lbnNpb24nKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVTdGFydCh2YWx1ZUF4aXMsIHZhbHVlT3JpZ2luKSB7XG4gIHZhciB2YWx1ZVN0YXJ0ID0gMDtcbiAgdmFyIGV4dGVudCA9IHZhbHVlQXhpcy5zY2FsZS5nZXRFeHRlbnQoKTtcbiAgaWYgKHZhbHVlT3JpZ2luID09PSAnc3RhcnQnKSB7XG4gICAgdmFsdWVTdGFydCA9IGV4dGVudFswXTtcbiAgfSBlbHNlIGlmICh2YWx1ZU9yaWdpbiA9PT0gJ2VuZCcpIHtcbiAgICB2YWx1ZVN0YXJ0ID0gZXh0ZW50WzFdO1xuICB9XG4gIC8vIElmIG9yaWdpbiBpcyBzcGVjaWZpZWQgYXMgYSBudW1iZXIsIHVzZSBpdCBhc1xuICAvLyB2YWx1ZVN0YXJ0IGRpcmVjdGx5XG4gIGVsc2UgaWYgKGlzTnVtYmVyKHZhbHVlT3JpZ2luKSAmJiAhaXNOYU4odmFsdWVPcmlnaW4pKSB7XG4gICAgdmFsdWVTdGFydCA9IHZhbHVlT3JpZ2luO1xuICB9XG4gIC8vIGF1dG9cbiAgZWxzZSB7XG4gICAgLy8gQm90aCBwb3NpdGl2ZVxuICAgIGlmIChleHRlbnRbMF0gPiAwKSB7XG4gICAgICB2YWx1ZVN0YXJ0ID0gZXh0ZW50WzBdO1xuICAgIH1cbiAgICAvLyBCb3RoIG5lZ2F0aXZlXG4gICAgZWxzZSBpZiAoZXh0ZW50WzFdIDwgMCkge1xuICAgICAgdmFsdWVTdGFydCA9IGV4dGVudFsxXTtcbiAgICB9XG4gICAgLy8gSWYgaXMgb25lIHBvc2l0aXZlLCBhbmQgb25lIG5lZ2F0aXZlLCBvblplcm8gc2hhbGwgYmUgdHJ1ZVxuICB9XG4gIHJldHVybiB2YWx1ZVN0YXJ0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YWNrZWRPblBvaW50KGRhdGFDb29yZEluZm8sIGNvb3JkU3lzLCBkYXRhLCBpZHgpIHtcbiAgdmFyIHZhbHVlID0gTmFOO1xuICBpZiAoZGF0YUNvb3JkSW5mby5zdGFja2VkKSB7XG4gICAgdmFsdWUgPSBkYXRhLmdldChkYXRhLmdldENhbGN1bGF0aW9uSW5mbygnc3RhY2tlZE92ZXJEaW1lbnNpb24nKSwgaWR4KTtcbiAgfVxuICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgdmFsdWUgPSBkYXRhQ29vcmRJbmZvLnZhbHVlU3RhcnQ7XG4gIH1cbiAgdmFyIGJhc2VEYXRhT2Zmc2V0ID0gZGF0YUNvb3JkSW5mby5iYXNlRGF0YU9mZnNldDtcbiAgdmFyIHN0YWNrZWREYXRhID0gW107XG4gIHN0YWNrZWREYXRhW2Jhc2VEYXRhT2Zmc2V0XSA9IGRhdGEuZ2V0KGRhdGFDb29yZEluZm8uYmFzZURpbSwgaWR4KTtcbiAgc3RhY2tlZERhdGFbMSAtIGJhc2VEYXRhT2Zmc2V0XSA9IHZhbHVlO1xuICByZXR1cm4gY29vcmRTeXMuZGF0YVRvUG9pbnQoc3RhY2tlZERhdGEpO1xufSIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgcHJlcGFyZURhdGFDb29yZEluZm8sIGdldFN0YWNrZWRPblBvaW50IH0gZnJvbSAnLi9oZWxwZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlRmxvYXQzMkFycmF5IH0gZnJvbSAnLi4vLi4vdXRpbC92ZW5kb3IuanMnO1xuZnVuY3Rpb24gZGlmZkRhdGEob2xkRGF0YSwgbmV3RGF0YSkge1xuICB2YXIgZGlmZlJlc3VsdCA9IFtdO1xuICBuZXdEYXRhLmRpZmYob2xkRGF0YSkuYWRkKGZ1bmN0aW9uIChpZHgpIHtcbiAgICBkaWZmUmVzdWx0LnB1c2goe1xuICAgICAgY21kOiAnKycsXG4gICAgICBpZHg6IGlkeFxuICAgIH0pO1xuICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgZGlmZlJlc3VsdC5wdXNoKHtcbiAgICAgIGNtZDogJz0nLFxuICAgICAgaWR4OiBvbGRJZHgsXG4gICAgICBpZHgxOiBuZXdJZHhcbiAgICB9KTtcbiAgfSkucmVtb3ZlKGZ1bmN0aW9uIChpZHgpIHtcbiAgICBkaWZmUmVzdWx0LnB1c2goe1xuICAgICAgY21kOiAnLScsXG4gICAgICBpZHg6IGlkeFxuICAgIH0pO1xuICB9KS5leGVjdXRlKCk7XG4gIHJldHVybiBkaWZmUmVzdWx0O1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGluZUFuaW1hdGlvbkRpZmYob2xkRGF0YSwgbmV3RGF0YSwgb2xkU3RhY2tlZE9uUG9pbnRzLCBuZXdTdGFja2VkT25Qb2ludHMsIG9sZENvb3JkU3lzLCBuZXdDb29yZFN5cywgb2xkVmFsdWVPcmlnaW4sIG5ld1ZhbHVlT3JpZ2luKSB7XG4gIHZhciBkaWZmID0gZGlmZkRhdGEob2xkRGF0YSwgbmV3RGF0YSk7XG4gIC8vIGxldCBuZXdJZExpc3QgPSBuZXdEYXRhLm1hcEFycmF5KG5ld0RhdGEuZ2V0SWQpO1xuICAvLyBsZXQgb2xkSWRMaXN0ID0gb2xkRGF0YS5tYXBBcnJheShvbGREYXRhLmdldElkKTtcbiAgLy8gY29udmVydFRvSW50SWQobmV3SWRMaXN0LCBvbGRJZExpc3QpO1xuICAvLyAvLyBGSVhNRSBPbmUgZGF0YSA/XG4gIC8vIGRpZmYgPSBhcnJheURpZmYob2xkSWRMaXN0LCBuZXdJZExpc3QpO1xuICB2YXIgY3VyclBvaW50cyA9IFtdO1xuICB2YXIgbmV4dFBvaW50cyA9IFtdO1xuICAvLyBQb2ludHMgZm9yIHN0YWNraW5nIGJhc2UgbGluZVxuICB2YXIgY3VyclN0YWNrZWRQb2ludHMgPSBbXTtcbiAgdmFyIG5leHRTdGFja2VkUG9pbnRzID0gW107XG4gIHZhciBzdGF0dXMgPSBbXTtcbiAgdmFyIHNvcnRlZEluZGljZXMgPSBbXTtcbiAgdmFyIHJhd0luZGljZXMgPSBbXTtcbiAgdmFyIG5ld0RhdGFPbGRDb29yZEluZm8gPSBwcmVwYXJlRGF0YUNvb3JkSW5mbyhvbGRDb29yZFN5cywgbmV3RGF0YSwgb2xkVmFsdWVPcmlnaW4pO1xuICAvLyBjb25zdCBvbGREYXRhTmV3Q29vcmRJbmZvID0gcHJlcGFyZURhdGFDb29yZEluZm8obmV3Q29vcmRTeXMsIG9sZERhdGEsIG5ld1ZhbHVlT3JpZ2luKTtcbiAgdmFyIG9sZFBvaW50cyA9IG9sZERhdGEuZ2V0TGF5b3V0KCdwb2ludHMnKSB8fCBbXTtcbiAgdmFyIG5ld1BvaW50cyA9IG5ld0RhdGEuZ2V0TGF5b3V0KCdwb2ludHMnKSB8fCBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpZmZJdGVtID0gZGlmZltpXTtcbiAgICB2YXIgcG9pbnRBZGRlZCA9IHRydWU7XG4gICAgdmFyIG9sZElkeDIgPSB2b2lkIDA7XG4gICAgdmFyIG5ld0lkeDIgPSB2b2lkIDA7XG4gICAgLy8gRklYTUUsIGFuaW1hdGlvbiBpcyBub3Qgc28gcGVyZmVjdCB3aGVuIGRhdGFab29tIHdpbmRvdyBtb3ZlcyBmYXN0XG4gICAgLy8gV2hpY2ggaXMgaW4gY2FzZSByZW12b2luZyBvciBhZGQgbW9yZSB0aGFuIG9uZSBkYXRhIGluIHRoZSB0YWlsIG9yIGhlYWRcbiAgICBzd2l0Y2ggKGRpZmZJdGVtLmNtZCkge1xuICAgICAgY2FzZSAnPSc6XG4gICAgICAgIG9sZElkeDIgPSBkaWZmSXRlbS5pZHggKiAyO1xuICAgICAgICBuZXdJZHgyID0gZGlmZkl0ZW0uaWR4MSAqIDI7XG4gICAgICAgIHZhciBjdXJyZW50WCA9IG9sZFBvaW50c1tvbGRJZHgyXTtcbiAgICAgICAgdmFyIGN1cnJlbnRZID0gb2xkUG9pbnRzW29sZElkeDIgKyAxXTtcbiAgICAgICAgdmFyIG5leHRYID0gbmV3UG9pbnRzW25ld0lkeDJdO1xuICAgICAgICB2YXIgbmV4dFkgPSBuZXdQb2ludHNbbmV3SWR4MiArIDFdO1xuICAgICAgICAvLyBJZiBwcmV2aW91cyBkYXRhIGlzIE5hTiwgdXNlIG5leHQgcG9pbnQgZGlyZWN0bHlcbiAgICAgICAgaWYgKGlzTmFOKGN1cnJlbnRYKSB8fCBpc05hTihjdXJyZW50WSkpIHtcbiAgICAgICAgICBjdXJyZW50WCA9IG5leHRYO1xuICAgICAgICAgIGN1cnJlbnRZID0gbmV4dFk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyclBvaW50cy5wdXNoKGN1cnJlbnRYLCBjdXJyZW50WSk7XG4gICAgICAgIG5leHRQb2ludHMucHVzaChuZXh0WCwgbmV4dFkpO1xuICAgICAgICBjdXJyU3RhY2tlZFBvaW50cy5wdXNoKG9sZFN0YWNrZWRPblBvaW50c1tvbGRJZHgyXSwgb2xkU3RhY2tlZE9uUG9pbnRzW29sZElkeDIgKyAxXSk7XG4gICAgICAgIG5leHRTdGFja2VkUG9pbnRzLnB1c2gobmV3U3RhY2tlZE9uUG9pbnRzW25ld0lkeDJdLCBuZXdTdGFja2VkT25Qb2ludHNbbmV3SWR4MiArIDFdKTtcbiAgICAgICAgcmF3SW5kaWNlcy5wdXNoKG5ld0RhdGEuZ2V0UmF3SW5kZXgoZGlmZkl0ZW0uaWR4MSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJysnOlxuICAgICAgICB2YXIgbmV3SWR4ID0gZGlmZkl0ZW0uaWR4O1xuICAgICAgICB2YXIgbmV3RGF0YURpbXNGb3JQb2ludCA9IG5ld0RhdGFPbGRDb29yZEluZm8uZGF0YURpbXNGb3JQb2ludDtcbiAgICAgICAgdmFyIG9sZFB0ID0gb2xkQ29vcmRTeXMuZGF0YVRvUG9pbnQoW25ld0RhdGEuZ2V0KG5ld0RhdGFEaW1zRm9yUG9pbnRbMF0sIG5ld0lkeCksIG5ld0RhdGEuZ2V0KG5ld0RhdGFEaW1zRm9yUG9pbnRbMV0sIG5ld0lkeCldKTtcbiAgICAgICAgbmV3SWR4MiA9IG5ld0lkeCAqIDI7XG4gICAgICAgIGN1cnJQb2ludHMucHVzaChvbGRQdFswXSwgb2xkUHRbMV0pO1xuICAgICAgICBuZXh0UG9pbnRzLnB1c2gobmV3UG9pbnRzW25ld0lkeDJdLCBuZXdQb2ludHNbbmV3SWR4MiArIDFdKTtcbiAgICAgICAgdmFyIHN0YWNrZWRPblBvaW50ID0gZ2V0U3RhY2tlZE9uUG9pbnQobmV3RGF0YU9sZENvb3JkSW5mbywgb2xkQ29vcmRTeXMsIG5ld0RhdGEsIG5ld0lkeCk7XG4gICAgICAgIGN1cnJTdGFja2VkUG9pbnRzLnB1c2goc3RhY2tlZE9uUG9pbnRbMF0sIHN0YWNrZWRPblBvaW50WzFdKTtcbiAgICAgICAgbmV4dFN0YWNrZWRQb2ludHMucHVzaChuZXdTdGFja2VkT25Qb2ludHNbbmV3SWR4Ml0sIG5ld1N0YWNrZWRPblBvaW50c1tuZXdJZHgyICsgMV0pO1xuICAgICAgICByYXdJbmRpY2VzLnB1c2gobmV3RGF0YS5nZXRSYXdJbmRleChuZXdJZHgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICctJzpcbiAgICAgICAgcG9pbnRBZGRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBPcmlnaW5hbCBpbmRpY2VzXG4gICAgaWYgKHBvaW50QWRkZWQpIHtcbiAgICAgIHN0YXR1cy5wdXNoKGRpZmZJdGVtKTtcbiAgICAgIHNvcnRlZEluZGljZXMucHVzaChzb3J0ZWRJbmRpY2VzLmxlbmd0aCk7XG4gICAgfVxuICB9XG4gIC8vIERpZmYgcmVzdWx0IG1heSBiZSBjcm9zc2VkIGlmIGFsbCBpdGVtcyBhcmUgY2hhbmdlZFxuICAvLyBTb3J0IGJ5IGRhdGEgaW5kZXhcbiAgc29ydGVkSW5kaWNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIHJhd0luZGljZXNbYV0gLSByYXdJbmRpY2VzW2JdO1xuICB9KTtcbiAgdmFyIGxlbiA9IGN1cnJQb2ludHMubGVuZ3RoO1xuICB2YXIgc29ydGVkQ3VyclBvaW50cyA9IGNyZWF0ZUZsb2F0MzJBcnJheShsZW4pO1xuICB2YXIgc29ydGVkTmV4dFBvaW50cyA9IGNyZWF0ZUZsb2F0MzJBcnJheShsZW4pO1xuICB2YXIgc29ydGVkQ3VyclN0YWNrZWRQb2ludHMgPSBjcmVhdGVGbG9hdDMyQXJyYXkobGVuKTtcbiAgdmFyIHNvcnRlZE5leHRTdGFja2VkUG9pbnRzID0gY3JlYXRlRmxvYXQzMkFycmF5KGxlbik7XG4gIHZhciBzb3J0ZWRTdGF0dXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlkeCA9IHNvcnRlZEluZGljZXNbaV07XG4gICAgdmFyIGkyID0gaSAqIDI7XG4gICAgdmFyIGlkeDIgPSBpZHggKiAyO1xuICAgIHNvcnRlZEN1cnJQb2ludHNbaTJdID0gY3VyclBvaW50c1tpZHgyXTtcbiAgICBzb3J0ZWRDdXJyUG9pbnRzW2kyICsgMV0gPSBjdXJyUG9pbnRzW2lkeDIgKyAxXTtcbiAgICBzb3J0ZWROZXh0UG9pbnRzW2kyXSA9IG5leHRQb2ludHNbaWR4Ml07XG4gICAgc29ydGVkTmV4dFBvaW50c1tpMiArIDFdID0gbmV4dFBvaW50c1tpZHgyICsgMV07XG4gICAgc29ydGVkQ3VyclN0YWNrZWRQb2ludHNbaTJdID0gY3VyclN0YWNrZWRQb2ludHNbaWR4Ml07XG4gICAgc29ydGVkQ3VyclN0YWNrZWRQb2ludHNbaTIgKyAxXSA9IGN1cnJTdGFja2VkUG9pbnRzW2lkeDIgKyAxXTtcbiAgICBzb3J0ZWROZXh0U3RhY2tlZFBvaW50c1tpMl0gPSBuZXh0U3RhY2tlZFBvaW50c1tpZHgyXTtcbiAgICBzb3J0ZWROZXh0U3RhY2tlZFBvaW50c1tpMiArIDFdID0gbmV4dFN0YWNrZWRQb2ludHNbaWR4MiArIDFdO1xuICAgIHNvcnRlZFN0YXR1c1tpXSA9IHN0YXR1c1tpZHhdO1xuICB9XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogc29ydGVkQ3VyclBvaW50cyxcbiAgICBuZXh0OiBzb3J0ZWROZXh0UG9pbnRzLFxuICAgIHN0YWNrZWRPbkN1cnJlbnQ6IHNvcnRlZEN1cnJTdGFja2VkUG9pbnRzLFxuICAgIHN0YWNrZWRPbk5leHQ6IHNvcnRlZE5leHRTdGFja2VkUG9pbnRzLFxuICAgIHN0YXR1czogc29ydGVkU3RhdHVzXG4gIH07XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbi8vIEZJWE1FIHN0ZXAgbm90IHN1cHBvcnQgcG9sYXJcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IFN5bWJvbERyYXcgZnJvbSAnLi4vaGVscGVyL1N5bWJvbERyYXcuanMnO1xuaW1wb3J0IFN5bWJvbENseiBmcm9tICcuLi9oZWxwZXIvU3ltYm9sLmpzJztcbmltcG9ydCBsaW5lQW5pbWF0aW9uRGlmZiBmcm9tICcuL2xpbmVBbmltYXRpb25EaWZmLmpzJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCAqIGFzIG1vZGVsVXRpbCBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCB7IEVDUG9seWxpbmUsIEVDUG9seWdvbiB9IGZyb20gJy4vcG9seS5qcyc7XG5pbXBvcnQgQ2hhcnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ2hhcnQuanMnO1xuaW1wb3J0IHsgcHJlcGFyZURhdGFDb29yZEluZm8sIGdldFN0YWNrZWRPblBvaW50IH0gZnJvbSAnLi9oZWxwZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlR3JpZENsaXBQYXRoLCBjcmVhdGVQb2xhckNsaXBQYXRoIH0gZnJvbSAnLi4vaGVscGVyL2NyZWF0ZUNsaXBQYXRoRnJvbUNvb3JkU3lzLmpzJztcbmltcG9ydCB7IGlzQ29vcmRpbmF0ZVN5c3RlbVR5cGUgfSBmcm9tICcuLi8uLi9jb29yZC9Db29yZGluYXRlU3lzdGVtLmpzJztcbmltcG9ydCB7IHNldFN0YXRlc1N0eWxlc0Zyb21Nb2RlbCwgc2V0U3RhdGVzRmxhZywgdG9nZ2xlSG92ZXJFbXBoYXNpcywgU1BFQ0lBTF9TVEFURVMgfSBmcm9tICcuLi8uLi91dGlsL3N0YXRlcy5qcyc7XG5pbXBvcnQgeyBzZXRMYWJlbFN0eWxlLCBnZXRMYWJlbFN0YXRlc01vZGVscywgbGFiZWxJbm5lciB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUuanMnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdExhYmVsLCBnZXREZWZhdWx0SW50ZXJwb2xhdGVkTGFiZWwgfSBmcm9tICcuLi9oZWxwZXIvbGFiZWxIZWxwZXIuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlLmpzJztcbmltcG9ydCB7IGNyZWF0ZUZsb2F0MzJBcnJheSB9IGZyb20gJy4uLy4uL3V0aWwvdmVuZG9yLmpzJztcbmltcG9ydCB7IGNvbnZlcnRUb0NvbG9yU3RyaW5nIH0gZnJvbSAnLi4vLi4vdXRpbC9mb3JtYXQuanMnO1xuaW1wb3J0IHsgbGVycCB9IGZyb20gJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3IuanMnO1xuZnVuY3Rpb24gaXNQb2ludHNTYW1lKHBvaW50czEsIHBvaW50czIpIHtcbiAgaWYgKHBvaW50czEubGVuZ3RoICE9PSBwb2ludHMyLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocG9pbnRzMVtpXSAhPT0gcG9pbnRzMltpXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGJib3hGcm9tUG9pbnRzKHBvaW50cykge1xuICB2YXIgbWluWCA9IEluZmluaXR5O1xuICB2YXIgbWluWSA9IEluZmluaXR5O1xuICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDspIHtcbiAgICB2YXIgeCA9IHBvaW50c1tpKytdO1xuICAgIHZhciB5ID0gcG9pbnRzW2krK107XG4gICAgaWYgKCFpc05hTih4KSkge1xuICAgICAgbWluWCA9IE1hdGgubWluKHgsIG1pblgpO1xuICAgICAgbWF4WCA9IE1hdGgubWF4KHgsIG1heFgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKHkpKSB7XG4gICAgICBtaW5ZID0gTWF0aC5taW4oeSwgbWluWSk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgoeSwgbWF4WSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbW21pblgsIG1pblldLCBbbWF4WCwgbWF4WV1dO1xufVxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdEaWZmKHBvaW50czEsIHBvaW50czIpIHtcbiAgdmFyIF9hID0gYmJveEZyb21Qb2ludHMocG9pbnRzMSksXG4gICAgbWluMSA9IF9hWzBdLFxuICAgIG1heDEgPSBfYVsxXTtcbiAgdmFyIF9iID0gYmJveEZyb21Qb2ludHMocG9pbnRzMiksXG4gICAgbWluMiA9IF9iWzBdLFxuICAgIG1heDIgPSBfYlsxXTtcbiAgLy8gR2V0IGEgbWF4IHZhbHVlIGZyb20gZWFjaCBjb3JuZXIgb2YgdHdvIGJvdW5kaW5ncy5cbiAgcmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKG1pbjFbMF0gLSBtaW4yWzBdKSwgTWF0aC5hYnMobWluMVsxXSAtIG1pbjJbMV0pLCBNYXRoLmFicyhtYXgxWzBdIC0gbWF4MlswXSksIE1hdGguYWJzKG1heDFbMV0gLSBtYXgyWzFdKSk7XG59XG5mdW5jdGlvbiBnZXRTbW9vdGgoc21vb3RoKSB7XG4gIHJldHVybiB6clV0aWwuaXNOdW1iZXIoc21vb3RoKSA/IHNtb290aCA6IHNtb290aCA/IDAuNSA6IDA7XG59XG5mdW5jdGlvbiBnZXRTdGFja2VkT25Qb2ludHMoY29vcmRTeXMsIGRhdGEsIGRhdGFDb29yZEluZm8pIHtcbiAgaWYgKCFkYXRhQ29vcmRJbmZvLnZhbHVlRGltKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBsZW4gPSBkYXRhLmNvdW50KCk7XG4gIHZhciBwb2ludHMgPSBjcmVhdGVGbG9hdDMyQXJyYXkobGVuICogMik7XG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICB2YXIgcHQgPSBnZXRTdGFja2VkT25Qb2ludChkYXRhQ29vcmRJbmZvLCBjb29yZFN5cywgZGF0YSwgaWR4KTtcbiAgICBwb2ludHNbaWR4ICogMl0gPSBwdFswXTtcbiAgICBwb2ludHNbaWR4ICogMiArIDFdID0gcHRbMV07XG4gIH1cbiAgcmV0dXJuIHBvaW50cztcbn1cbi8qKlxyXG4gKiBGaWx0ZXIgdGhlIG51bGwgZGF0YSBhbmQgZXh0ZW5kIGRhdGEgZm9yIHN0ZXAgY29uc2lkZXJpbmcgYHN0ZXBUdXJuQXRgXHJcbiAqXHJcbiAqIEBwYXJhbSBwb2ludHMgZGF0YSB0byBjb252ZXJ0LCB0aGF0IG1heSBjb250YWluaW5nIG51bGxcclxuICogQHBhcmFtIGJhc2VQb2ludHMgYmFzZSBkYXRhIHRvIHJlZmVyZW5jZSwgdXNlZCBvbmx5IGZvciBhcmVhU3R5bGUgcG9pbnRzXHJcbiAqIEBwYXJhbSBjb29yZFN5cyBjb29yZGluYXRlIHN5c3RlbVxyXG4gKiBAcGFyYW0gc3RlcFR1cm5BdCAnc3RhcnQnIHwgJ2VuZCcgfCAnbWlkZGxlJyB8IHRydWVcclxuICogQHBhcmFtIGNvbm5lY3ROdWxscyB3aGV0aGVyIHRvIGNvbm5lY3QgbnVsbHNcclxuICogQHJldHVybnMgY29udmVydGVkIHBvaW50IHBvc2l0aW9uc1xyXG4gKi9cbmZ1bmN0aW9uIHR1cm5Qb2ludHNJbnRvU3RlcChwb2ludHMsIGJhc2VQb2ludHMsIGNvb3JkU3lzLCBzdGVwVHVybkF0LCBjb25uZWN0TnVsbHMpIHtcbiAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgdmFyIGJhc2VJbmRleCA9IGJhc2VBeGlzLmRpbSA9PT0gJ3gnIHx8IGJhc2VBeGlzLmRpbSA9PT0gJ3JhZGl1cycgPyAwIDogMTtcbiAgdmFyIHN0ZXBQb2ludHMgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgc3RlcFB0ID0gW107XG4gIHZhciBwdCA9IFtdO1xuICB2YXIgbmV4dFB0ID0gW107XG4gIHZhciBmaWx0ZXJlZFBvaW50cyA9IFtdO1xuICBpZiAoY29ubmVjdE51bGxzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgLyoqXHJcbiAgICAgICAqIEZvciBhcmVhU3R5bGUgb2Ygc3RlcHBlZCBsaW5lcywgYHN0YWNrZWRPblBvaW50c2Agc2hvdWxkIGJlXHJcbiAgICAgICAqIGZpbHRlcmVkIHRoZSBzYW1lIGFzIGBwb2ludHNgIHNvIHRoYXQgdGhlIGJhc2UgYXhpcyB2YWx1ZXNcclxuICAgICAgICogc2hvdWxkIHN0YXkgdGhlIHNhbWUgYXMgdGhlIGxpbmVzIGFib3ZlLiBTZWUgIzIwMDIxXHJcbiAgICAgICAqL1xuICAgICAgdmFyIHJlZmVyZW5jZSA9IGJhc2VQb2ludHMgfHwgcG9pbnRzO1xuICAgICAgaWYgKCFpc05hTihyZWZlcmVuY2VbaV0pICYmICFpc05hTihyZWZlcmVuY2VbaSArIDFdKSkge1xuICAgICAgICBmaWx0ZXJlZFBvaW50cy5wdXNoKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50cyA9IGZpbHRlcmVkUG9pbnRzO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMjsgaSArPSAyKSB7XG4gICAgbmV4dFB0WzBdID0gcG9pbnRzW2kgKyAyXTtcbiAgICBuZXh0UHRbMV0gPSBwb2ludHNbaSArIDNdO1xuICAgIHB0WzBdID0gcG9pbnRzW2ldO1xuICAgIHB0WzFdID0gcG9pbnRzW2kgKyAxXTtcbiAgICBzdGVwUG9pbnRzLnB1c2gocHRbMF0sIHB0WzFdKTtcbiAgICBzd2l0Y2ggKHN0ZXBUdXJuQXQpIHtcbiAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgIHN0ZXBQdFtiYXNlSW5kZXhdID0gbmV4dFB0W2Jhc2VJbmRleF07XG4gICAgICAgIHN0ZXBQdFsxIC0gYmFzZUluZGV4XSA9IHB0WzEgLSBiYXNlSW5kZXhdO1xuICAgICAgICBzdGVwUG9pbnRzLnB1c2goc3RlcFB0WzBdLCBzdGVwUHRbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgIHZhciBtaWRkbGUgPSAocHRbYmFzZUluZGV4XSArIG5leHRQdFtiYXNlSW5kZXhdKSAvIDI7XG4gICAgICAgIHZhciBzdGVwUHQyID0gW107XG4gICAgICAgIHN0ZXBQdFtiYXNlSW5kZXhdID0gc3RlcFB0MltiYXNlSW5kZXhdID0gbWlkZGxlO1xuICAgICAgICBzdGVwUHRbMSAtIGJhc2VJbmRleF0gPSBwdFsxIC0gYmFzZUluZGV4XTtcbiAgICAgICAgc3RlcFB0MlsxIC0gYmFzZUluZGV4XSA9IG5leHRQdFsxIC0gYmFzZUluZGV4XTtcbiAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdFswXSwgc3RlcFB0WzFdKTtcbiAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdDJbMF0sIHN0ZXBQdDJbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGRlZmF1bHQgaXMgc3RhcnRcbiAgICAgICAgc3RlcFB0W2Jhc2VJbmRleF0gPSBwdFtiYXNlSW5kZXhdO1xuICAgICAgICBzdGVwUHRbMSAtIGJhc2VJbmRleF0gPSBuZXh0UHRbMSAtIGJhc2VJbmRleF07XG4gICAgICAgIHN0ZXBQb2ludHMucHVzaChzdGVwUHRbMF0sIHN0ZXBQdFsxXSk7XG4gICAgfVxuICB9XG4gIC8vIExhc3QgcG9pbnRzXG4gIHN0ZXBQb2ludHMucHVzaChwb2ludHNbaSsrXSwgcG9pbnRzW2krK10pO1xuICByZXR1cm4gc3RlcFBvaW50cztcbn1cbi8qKlxyXG4gKiBDbGlwIGNvbG9yIHN0b3BzIHRvIGVkZ2UuIEF2b2lkIGNyZWF0aW5nIHRvbyBsYXJnZSBncmFkaWVudHMuXHJcbiAqIFdoaWNoIG1heSBsZWFkIHRvIGJsdXJyeSB3aGVuIEdQVSBhY2NlbGVyYXRpb24gaXMgZW5hYmxlZC4gU2VlICMxNTY4MFxyXG4gKlxyXG4gKiBUaGUgc3RvcHMgaGFzIGJlZW4gc29ydGVkIGZyb20gc21hbGwgdG8gbGFyZ2UuXHJcbiAqL1xuZnVuY3Rpb24gY2xpcENvbG9yU3RvcHMoY29sb3JTdG9wcywgbWF4U2l6ZSkge1xuICB2YXIgbmV3Q29sb3JTdG9wcyA9IFtdO1xuICB2YXIgbGVuID0gY29sb3JTdG9wcy5sZW5ndGg7XG4gIC8vIGNvb3JkIHdpbGwgYWx3YXlzIDwgMCBpbiBwcmV2T3V0T2ZSYW5nZUNvbG9yU3RvcC5cbiAgdmFyIHByZXZPdXRPZlJhbmdlQ29sb3JTdG9wO1xuICB2YXIgcHJldkluUmFuZ2VDb2xvclN0b3A7XG4gIGZ1bmN0aW9uIGxlcnBTdG9wKHN0b3AwLCBzdG9wMSwgY2xpcHBlZENvb3JkKSB7XG4gICAgdmFyIGNvb3JkMCA9IHN0b3AwLmNvb3JkO1xuICAgIHZhciBwID0gKGNsaXBwZWRDb29yZCAtIGNvb3JkMCkgLyAoc3RvcDEuY29vcmQgLSBjb29yZDApO1xuICAgIHZhciBjb2xvciA9IGxlcnAocCwgW3N0b3AwLmNvbG9yLCBzdG9wMS5jb2xvcl0pO1xuICAgIHJldHVybiB7XG4gICAgICBjb29yZDogY2xpcHBlZENvb3JkLFxuICAgICAgY29sb3I6IGNvbG9yXG4gICAgfTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHN0b3BfMSA9IGNvbG9yU3RvcHNbaV07XG4gICAgdmFyIGNvb3JkID0gc3RvcF8xLmNvb3JkO1xuICAgIGlmIChjb29yZCA8IDApIHtcbiAgICAgIHByZXZPdXRPZlJhbmdlQ29sb3JTdG9wID0gc3RvcF8xO1xuICAgIH0gZWxzZSBpZiAoY29vcmQgPiBtYXhTaXplKSB7XG4gICAgICBpZiAocHJldkluUmFuZ2VDb2xvclN0b3ApIHtcbiAgICAgICAgbmV3Q29sb3JTdG9wcy5wdXNoKGxlcnBTdG9wKHByZXZJblJhbmdlQ29sb3JTdG9wLCBzdG9wXzEsIG1heFNpemUpKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldk91dE9mUmFuZ2VDb2xvclN0b3ApIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIHR3byBzdG9wcyBhbmQgY29vcmQgcmFuZ2UgaXMgYmV0d2VlbiB0aGVzZSB0d28gc3RvcHNcbiAgICAgICAgbmV3Q29sb3JTdG9wcy5wdXNoKGxlcnBTdG9wKHByZXZPdXRPZlJhbmdlQ29sb3JTdG9wLCBzdG9wXzEsIDApLCBsZXJwU3RvcChwcmV2T3V0T2ZSYW5nZUNvbG9yU3RvcCwgc3RvcF8xLCBtYXhTaXplKSk7XG4gICAgICB9XG4gICAgICAvLyBBbGwgZm9sbG93aW5nIHN0b3Agd2lsbCBiZSBvdXQgb2YgcmFuZ2UuIFNvIGp1c3QgaWdub3JlIHRoZW0uXG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXZPdXRPZlJhbmdlQ29sb3JTdG9wKSB7XG4gICAgICAgIG5ld0NvbG9yU3RvcHMucHVzaChsZXJwU3RvcChwcmV2T3V0T2ZSYW5nZUNvbG9yU3RvcCwgc3RvcF8xLCAwKSk7XG4gICAgICAgIC8vIFJlc2V0XG4gICAgICAgIHByZXZPdXRPZlJhbmdlQ29sb3JTdG9wID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5ld0NvbG9yU3RvcHMucHVzaChzdG9wXzEpO1xuICAgICAgcHJldkluUmFuZ2VDb2xvclN0b3AgPSBzdG9wXzE7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdDb2xvclN0b3BzO1xufVxuZnVuY3Rpb24gZ2V0VmlzdWFsR3JhZGllbnQoZGF0YSwgY29vcmRTeXMsIGFwaSkge1xuICB2YXIgdmlzdWFsTWV0YUxpc3QgPSBkYXRhLmdldFZpc3VhbCgndmlzdWFsTWV0YScpO1xuICBpZiAoIXZpc3VhbE1ldGFMaXN0IHx8ICF2aXN1YWxNZXRhTGlzdC5sZW5ndGggfHwgIWRhdGEuY291bnQoKSkge1xuICAgIC8vIFdoZW4gZGF0YS5jb3VudCgpIGlzIDAsIGdyYWRpZW50IHJhbmdlIGNhbiBub3QgYmUgY2FsY3VsYXRlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGNvb3JkU3lzLnR5cGUgIT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS53YXJuKCdWaXN1YWwgbWFwIG9uIGxpbmUgc3R5bGUgaXMgb25seSBzdXBwb3J0ZWQgb24gY2FydGVzaWFuMmQuJyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY29vcmREaW07XG4gIHZhciB2aXN1YWxNZXRhO1xuICBmb3IgKHZhciBpID0gdmlzdWFsTWV0YUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgZGltSW5mbyA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyh2aXN1YWxNZXRhTGlzdFtpXS5kaW1lbnNpb24pO1xuICAgIGNvb3JkRGltID0gZGltSW5mbyAmJiBkaW1JbmZvLmNvb3JkRGltO1xuICAgIC8vIENhbiBvbmx5IGJlIHggb3IgeVxuICAgIGlmIChjb29yZERpbSA9PT0gJ3gnIHx8IGNvb3JkRGltID09PSAneScpIHtcbiAgICAgIHZpc3VhbE1ldGEgPSB2aXN1YWxNZXRhTGlzdFtpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoIXZpc3VhbE1ldGEpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS53YXJuKCdWaXN1YWwgbWFwIG9uIGxpbmUgc3R5bGUgb25seSBzdXBwb3J0IHggb3IgeSBkaW1lbnNpb24uJyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICAvLyBJZiB0aGUgYXJlYSB0byBiZSByZW5kZXJlZCBpcyBiaWdnZXIgdGhhbiBhcmVhIGRlZmluZWQgYnkgTGluZWFyR3JhZGllbnQsXG4gIC8vIHRoZSBjYW52YXMgc3BlYyBwcmVzY3JpYmVzIHRoYXQgdGhlIGNvbG9yIG9mIHRoZSBmaXJzdCBzdG9wIGFuZCB0aGUgbGFzdFxuICAvLyBzdG9wIHNob3VsZCBiZSB1c2VkLiBCdXQgaWYgdHdvIHN0b3BzIGFyZSBhZGRlZCBhdCBvZmZzZXQgMCwgaW4gZWZmZWN0XG4gIC8vIGJyb3dzZXJzIHVzZSB0aGUgY29sb3Igb2YgdGhlIHNlY29uZCBzdG9wIHRvIHJlbmRlciBhcmVhIG91dHNpZGVcbiAgLy8gTGluZWFyR3JhZGllbnQuIFNvIHdlIGNhbiBvbmx5IGluZmluaXRlc2ltYWxseSBleHRlbmQgYXJlYSBkZWZpbmVkIGluXG4gIC8vIExpbmVhckdyYWRpZW50IHRvIHJlbmRlciBgb3V0ZXJDb2xvcnNgLlxuICB2YXIgYXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoY29vcmREaW0pO1xuICAvLyBkYXRhVG9Db29yZCBtYXBwaW5nIG1heSBub3QgYmUgbGluZWFyLCBidXQgbXVzdCBiZSBtb25vdG9uaWMuXG4gIHZhciBjb2xvclN0b3BzID0genJVdGlsLm1hcCh2aXN1YWxNZXRhLnN0b3BzLCBmdW5jdGlvbiAoc3RvcCkge1xuICAgIC8vIG9mZnNldCB3aWxsIGJlIGNhbGN1bGF0ZWQgbGF0ZXIuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvb3JkOiBheGlzLnRvR2xvYmFsQ29vcmQoYXhpcy5kYXRhVG9Db29yZChzdG9wLnZhbHVlKSksXG4gICAgICBjb2xvcjogc3RvcC5jb2xvclxuICAgIH07XG4gIH0pO1xuICB2YXIgc3RvcExlbiA9IGNvbG9yU3RvcHMubGVuZ3RoO1xuICB2YXIgb3V0ZXJDb2xvcnMgPSB2aXN1YWxNZXRhLm91dGVyQ29sb3JzLnNsaWNlKCk7XG4gIGlmIChzdG9wTGVuICYmIGNvbG9yU3RvcHNbMF0uY29vcmQgPiBjb2xvclN0b3BzW3N0b3BMZW4gLSAxXS5jb29yZCkge1xuICAgIGNvbG9yU3RvcHMucmV2ZXJzZSgpO1xuICAgIG91dGVyQ29sb3JzLnJldmVyc2UoKTtcbiAgfVxuICB2YXIgY29sb3JTdG9wc0luUmFuZ2UgPSBjbGlwQ29sb3JTdG9wcyhjb2xvclN0b3BzLCBjb29yZERpbSA9PT0gJ3gnID8gYXBpLmdldFdpZHRoKCkgOiBhcGkuZ2V0SGVpZ2h0KCkpO1xuICB2YXIgaW5SYW5nZVN0b3BMZW4gPSBjb2xvclN0b3BzSW5SYW5nZS5sZW5ndGg7XG4gIGlmICghaW5SYW5nZVN0b3BMZW4gJiYgc3RvcExlbikge1xuICAgIC8vIEFsbCBzdG9wcyBhcmUgb3V0IG9mIHJhbmdlLiBBbGwgd2lsbCBiZSB0aGUgc2FtZSBjb2xvci5cbiAgICByZXR1cm4gY29sb3JTdG9wc1swXS5jb29yZCA8IDAgPyBvdXRlckNvbG9yc1sxXSA/IG91dGVyQ29sb3JzWzFdIDogY29sb3JTdG9wc1tzdG9wTGVuIC0gMV0uY29sb3IgOiBvdXRlckNvbG9yc1swXSA/IG91dGVyQ29sb3JzWzBdIDogY29sb3JTdG9wc1swXS5jb2xvcjtcbiAgfVxuICB2YXIgdGlueUV4dGVudCA9IDEwOyAvLyBBcmJpdHJhcnkgdmFsdWU6IDEwcHhcbiAgdmFyIG1pbkNvb3JkID0gY29sb3JTdG9wc0luUmFuZ2VbMF0uY29vcmQgLSB0aW55RXh0ZW50O1xuICB2YXIgbWF4Q29vcmQgPSBjb2xvclN0b3BzSW5SYW5nZVtpblJhbmdlU3RvcExlbiAtIDFdLmNvb3JkICsgdGlueUV4dGVudDtcbiAgdmFyIGNvb3JkU3BhbiA9IG1heENvb3JkIC0gbWluQ29vcmQ7XG4gIGlmIChjb29yZFNwYW4gPCAxZS0zKSB7XG4gICAgcmV0dXJuICd0cmFuc3BhcmVudCc7XG4gIH1cbiAgenJVdGlsLmVhY2goY29sb3JTdG9wc0luUmFuZ2UsIGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgc3RvcC5vZmZzZXQgPSAoc3RvcC5jb29yZCAtIG1pbkNvb3JkKSAvIGNvb3JkU3BhbjtcbiAgfSk7XG4gIGNvbG9yU3RvcHNJblJhbmdlLnB1c2goe1xuICAgIC8vIE5PVEU6IGluUmFuZ2VTdG9wTGVuIG1heSBzdGlsbCBiZSAwIGlmIHN0b3BsZW4gaXMgemVyby5cbiAgICBvZmZzZXQ6IGluUmFuZ2VTdG9wTGVuID8gY29sb3JTdG9wc0luUmFuZ2VbaW5SYW5nZVN0b3BMZW4gLSAxXS5vZmZzZXQgOiAwLjUsXG4gICAgY29sb3I6IG91dGVyQ29sb3JzWzFdIHx8ICd0cmFuc3BhcmVudCdcbiAgfSk7XG4gIGNvbG9yU3RvcHNJblJhbmdlLnVuc2hpZnQoe1xuICAgIG9mZnNldDogaW5SYW5nZVN0b3BMZW4gPyBjb2xvclN0b3BzSW5SYW5nZVswXS5vZmZzZXQgOiAwLjUsXG4gICAgY29sb3I6IG91dGVyQ29sb3JzWzBdIHx8ICd0cmFuc3BhcmVudCdcbiAgfSk7XG4gIHZhciBncmFkaWVudCA9IG5ldyBncmFwaGljLkxpbmVhckdyYWRpZW50KDAsIDAsIDAsIDAsIGNvbG9yU3RvcHNJblJhbmdlLCB0cnVlKTtcbiAgZ3JhZGllbnRbY29vcmREaW1dID0gbWluQ29vcmQ7XG4gIGdyYWRpZW50W2Nvb3JkRGltICsgJzInXSA9IG1heENvb3JkO1xuICByZXR1cm4gZ3JhZGllbnQ7XG59XG5mdW5jdGlvbiBnZXRJc0lnbm9yZUZ1bmMoc2VyaWVzTW9kZWwsIGRhdGEsIGNvb3JkU3lzKSB7XG4gIHZhciBzaG93QWxsU3ltYm9sID0gc2VyaWVzTW9kZWwuZ2V0KCdzaG93QWxsU3ltYm9sJyk7XG4gIHZhciBpc0F1dG8gPSBzaG93QWxsU3ltYm9sID09PSAnYXV0byc7XG4gIGlmIChzaG93QWxsU3ltYm9sICYmICFpc0F1dG8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNhdGVnb3J5QXhpcyA9IGNvb3JkU3lzLmdldEF4ZXNCeVNjYWxlKCdvcmRpbmFsJylbMF07XG4gIGlmICghY2F0ZWdvcnlBeGlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhhdCBjYXRlZ29yeSBsYWJlbCBpbnRlcnZhbCBzdHJhdGVneSBtaWdodCBicmluZyBzb21lIHdlaXJkIGVmZmVjdFxuICAvLyBpbiBzb21lIHNjZW5hcmlvOiB1c2VycyBtYXkgd29uZGVyIHdoeSBzb21lIG9mIHRoZSBzeW1ib2xzIGFyZSBub3RcbiAgLy8gZGlzcGxheWVkLiBTbyB3ZSBzaG93IGFsbCBzeW1ib2xzIGFzIHBvc3NpYmxlIGFzIHdlIGNhbi5cbiAgaWYgKGlzQXV0b1xuICAvLyBTaW1wbGlmeSB0aGUgbG9naWMsIGRvIG5vdCBkZXRlcm1pbmUgbGFiZWwgb3ZlcmxhcCBoZXJlLlxuICAmJiBjYW5TaG93QWxsU3ltYm9sRm9yQ2F0ZWdvcnkoY2F0ZWdvcnlBeGlzLCBkYXRhKSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBPdGhlcndpc2UgZm9sbG93IHRoZSBsYWJlbCBpbnRlcnZhbCBzdHJhdGVneSBvbiBjYXRlZ29yeSBheGlzLlxuICB2YXIgY2F0ZWdvcnlEYXRhRGltID0gZGF0YS5tYXBEaW1lbnNpb24oY2F0ZWdvcnlBeGlzLmRpbSk7XG4gIHZhciBsYWJlbE1hcCA9IHt9O1xuICB6clV0aWwuZWFjaChjYXRlZ29yeUF4aXMuZ2V0Vmlld0xhYmVscygpLCBmdW5jdGlvbiAobGFiZWxJdGVtKSB7XG4gICAgdmFyIG9yZGluYWxOdW1iZXIgPSBjYXRlZ29yeUF4aXMuc2NhbGUuZ2V0UmF3T3JkaW5hbE51bWJlcihsYWJlbEl0ZW0udGlja1ZhbHVlKTtcbiAgICBsYWJlbE1hcFtvcmRpbmFsTnVtYmVyXSA9IDE7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgIHJldHVybiAhbGFiZWxNYXAuaGFzT3duUHJvcGVydHkoZGF0YS5nZXQoY2F0ZWdvcnlEYXRhRGltLCBkYXRhSW5kZXgpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhblNob3dBbGxTeW1ib2xGb3JDYXRlZ29yeShjYXRlZ29yeUF4aXMsIGRhdGEpIHtcbiAgLy8gSW4gbW9zdCBjYXNlcywgbGluZSBpcyBtb25vdG9ub3VzIG9uIGNhdGVnb3J5IGF4aXMsIGFuZCB0aGUgbGFiZWwgc2l6ZVxuICAvLyBpcyBjbG9zZSB3aXRoIGVhY2ggb3RoZXIuIFNvIHdlIGNoZWNrIHRoZSBzeW1ib2wgc2l6ZSBhbmQgc29tZSBvZiB0aGVcbiAgLy8gbGFiZWwgc2l6ZSBhbG9uZSB3aXRoIHRoZSBjYXRlZ29yeSBheGlzIHRvIGVzdGltYXRlIHdoZXRoZXIgYWxsIHN5bWJvbFxuICAvLyBjYW4gYmUgc2hvd24gd2l0aG91dCBvdmVybGFwLlxuICB2YXIgYXhpc0V4dGVudCA9IGNhdGVnb3J5QXhpcy5nZXRFeHRlbnQoKTtcbiAgdmFyIGF2YWlsU2l6ZSA9IE1hdGguYWJzKGF4aXNFeHRlbnRbMV0gLSBheGlzRXh0ZW50WzBdKSAvIGNhdGVnb3J5QXhpcy5zY2FsZS5jb3VudCgpO1xuICBpc05hTihhdmFpbFNpemUpICYmIChhdmFpbFNpemUgPSAwKTsgLy8gMC8wIGlzIE5hTi5cbiAgLy8gU2FtcGxpbmcgc29tZSBwb2ludHMsIG1heCA1LlxuICB2YXIgZGF0YUxlbiA9IGRhdGEuY291bnQoKTtcbiAgdmFyIHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKGRhdGFMZW4gLyA1KSk7XG4gIGZvciAodmFyIGRhdGFJbmRleCA9IDA7IGRhdGFJbmRleCA8IGRhdGFMZW47IGRhdGFJbmRleCArPSBzdGVwKSB7XG4gICAgaWYgKFN5bWJvbENsei5nZXRTeW1ib2xTaXplKGRhdGEsIGRhdGFJbmRleFxuICAgIC8vIE9ubHkgZm9yIGNhcnRlc2lhbiwgd2hlcmUgYGlzSG9yaXpvbnRhbGAgZXhpc3RzLlxuICAgIClbY2F0ZWdvcnlBeGlzLmlzSG9yaXpvbnRhbCgpID8gMSA6IDBdXG4gICAgLy8gRW1waXJpY2FsIG51bWJlclxuICAgICogMS41ID4gYXZhaWxTaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNQb2ludE51bGwoeCwgeSkge1xuICByZXR1cm4gaXNOYU4oeCkgfHwgaXNOYU4oeSk7XG59XG5mdW5jdGlvbiBnZXRMYXN0SW5kZXhOb3ROdWxsKHBvaW50cykge1xuICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gIGZvciAoOyBsZW4gPiAwOyBsZW4tLSkge1xuICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2xlbiAqIDIgLSAyXSwgcG9pbnRzW2xlbiAqIDIgLSAxXSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuIC0gMTtcbn1cbmZ1bmN0aW9uIGdldFBvaW50QXRJbmRleChwb2ludHMsIGlkeCkge1xuICByZXR1cm4gW3BvaW50c1tpZHggKiAyXSwgcG9pbnRzW2lkeCAqIDIgKyAxXV07XG59XG5mdW5jdGlvbiBnZXRJbmRleFJhbmdlKHBvaW50cywgeE9yWSwgZGltKSB7XG4gIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgdmFyIGRpbUlkeCA9IGRpbSA9PT0gJ3gnID8gMCA6IDE7XG4gIHZhciBhO1xuICB2YXIgYjtcbiAgdmFyIHByZXZJbmRleCA9IDA7XG4gIHZhciBuZXh0SW5kZXggPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGIgPSBwb2ludHNbaSAqIDIgKyBkaW1JZHhdO1xuICAgIGlmIChpc05hTihiKSB8fCBpc05hTihwb2ludHNbaSAqIDIgKyAxIC0gZGltSWR4XSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgYSA9IGI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGEgPD0geE9yWSAmJiBiID49IHhPclkgfHwgYSA+PSB4T3JZICYmIGIgPD0geE9yWSkge1xuICAgICAgbmV4dEluZGV4ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2SW5kZXggPSBpO1xuICAgIGEgPSBiO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmFuZ2U6IFtwcmV2SW5kZXgsIG5leHRJbmRleF0sXG4gICAgdDogKHhPclkgLSBhKSAvIChiIC0gYSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGFueVN0YXRlU2hvd0VuZExhYmVsKHNlcmllc01vZGVsKSB7XG4gIGlmIChzZXJpZXNNb2RlbC5nZXQoWydlbmRMYWJlbCcsICdzaG93J10pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBTUEVDSUFMX1NUQVRFUy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzZXJpZXNNb2RlbC5nZXQoW1NQRUNJQUxfU1RBVEVTW2ldLCAnZW5kTGFiZWwnLCAnc2hvdyddKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxpbmVDbGlwUGF0aChsaW5lVmlldywgY29vcmRTeXMsIGhhc0FuaW1hdGlvbiwgc2VyaWVzTW9kZWwpIHtcbiAgaWYgKGlzQ29vcmRpbmF0ZVN5c3RlbVR5cGUoY29vcmRTeXMsICdjYXJ0ZXNpYW4yZCcpKSB7XG4gICAgdmFyIGVuZExhYmVsTW9kZWxfMSA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdlbmRMYWJlbCcpO1xuICAgIHZhciB2YWx1ZUFuaW1hdGlvbl8xID0gZW5kTGFiZWxNb2RlbF8xLmdldCgndmFsdWVBbmltYXRpb24nKTtcbiAgICB2YXIgZGF0YV8xID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBsYWJlbEFuaW1hdGlvblJlY29yZF8xID0ge1xuICAgICAgbGFzdEZyYW1lSW5kZXg6IDBcbiAgICB9O1xuICAgIHZhciBkdXJpbmcgPSBhbnlTdGF0ZVNob3dFbmRMYWJlbChzZXJpZXNNb2RlbCkgPyBmdW5jdGlvbiAocGVyY2VudCwgY2xpcFJlY3QpIHtcbiAgICAgIGxpbmVWaWV3Ll9lbmRMYWJlbE9uRHVyaW5nKHBlcmNlbnQsIGNsaXBSZWN0LCBkYXRhXzEsIGxhYmVsQW5pbWF0aW9uUmVjb3JkXzEsIHZhbHVlQW5pbWF0aW9uXzEsIGVuZExhYmVsTW9kZWxfMSwgY29vcmRTeXMpO1xuICAgIH0gOiBudWxsO1xuICAgIHZhciBpc0hvcml6b250YWwgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpLmlzSG9yaXpvbnRhbCgpO1xuICAgIHZhciBjbGlwUGF0aCA9IGNyZWF0ZUdyaWRDbGlwUGF0aChjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGVuZExhYmVsID0gbGluZVZpZXcuX2VuZExhYmVsO1xuICAgICAgaWYgKGVuZExhYmVsICYmIGhhc0FuaW1hdGlvbikge1xuICAgICAgICBpZiAobGFiZWxBbmltYXRpb25SZWNvcmRfMS5vcmlnaW5hbFggIT0gbnVsbCkge1xuICAgICAgICAgIGVuZExhYmVsLmF0dHIoe1xuICAgICAgICAgICAgeDogbGFiZWxBbmltYXRpb25SZWNvcmRfMS5vcmlnaW5hbFgsXG4gICAgICAgICAgICB5OiBsYWJlbEFuaW1hdGlvblJlY29yZF8xLm9yaWdpbmFsWVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgZHVyaW5nKTtcbiAgICAvLyBFeHBhbmQgY2xpcCBzaGFwZSB0byBhdm9pZCBjbGlwcGluZyB3aGVuIGxpbmUgdmFsdWUgZXhjZWVkcyBheGlzXG4gICAgaWYgKCFzZXJpZXNNb2RlbC5nZXQoJ2NsaXAnLCB0cnVlKSkge1xuICAgICAgdmFyIHJlY3RTaGFwZSA9IGNsaXBQYXRoLnNoYXBlO1xuICAgICAgdmFyIGV4cGFuZFNpemUgPSBNYXRoLm1heChyZWN0U2hhcGUud2lkdGgsIHJlY3RTaGFwZS5oZWlnaHQpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICByZWN0U2hhcGUueSAtPSBleHBhbmRTaXplO1xuICAgICAgICByZWN0U2hhcGUuaGVpZ2h0ICs9IGV4cGFuZFNpemUgKiAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjdFNoYXBlLnggLT0gZXhwYW5kU2l6ZTtcbiAgICAgICAgcmVjdFNoYXBlLndpZHRoICs9IGV4cGFuZFNpemUgKiAyO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXQgdG8gdGhlIGZpbmFsIGZyYW1lLiBUbyBtYWtlIHN1cmUgbGFiZWwgbGF5b3V0IGlzIHJpZ2h0LlxuICAgIGlmIChkdXJpbmcpIHtcbiAgICAgIGR1cmluZygxLCBjbGlwUGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBjbGlwUGF0aDtcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHNlcmllc01vZGVsLmdldChbJ2VuZExhYmVsJywgJ3Nob3cnXSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdlbmRMYWJlbCBpcyBub3Qgc3VwcG9ydGVkIGZvciBsaW5lcyBpbiBwb2xhciBzeXN0ZW1zLicpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9sYXJDbGlwUGF0aChjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEVuZExhYmVsU3RhdGVTcGVjaWZpZWQoZW5kTGFiZWxNb2RlbCwgY29vcmRTeXMpIHtcbiAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgdmFyIGlzSG9yaXpvbnRhbCA9IGJhc2VBeGlzLmlzSG9yaXpvbnRhbCgpO1xuICB2YXIgaXNCYXNlSW52ZXJzZWQgPSBiYXNlQXhpcy5pbnZlcnNlO1xuICB2YXIgYWxpZ24gPSBpc0hvcml6b250YWwgPyBpc0Jhc2VJbnZlcnNlZCA/ICdyaWdodCcgOiAnbGVmdCcgOiAnY2VudGVyJztcbiAgdmFyIHZlcnRpY2FsQWxpZ24gPSBpc0hvcml6b250YWwgPyAnbWlkZGxlJyA6IGlzQmFzZUludmVyc2VkID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgcmV0dXJuIHtcbiAgICBub3JtYWw6IHtcbiAgICAgIGFsaWduOiBlbmRMYWJlbE1vZGVsLmdldCgnYWxpZ24nKSB8fCBhbGlnbixcbiAgICAgIHZlcnRpY2FsQWxpZ246IGVuZExhYmVsTW9kZWwuZ2V0KCd2ZXJ0aWNhbEFsaWduJykgfHwgdmVydGljYWxBbGlnblxuICAgIH1cbiAgfTtcbn1cbnZhciBMaW5lVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhMaW5lVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gTGluZVZpZXcoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIExpbmVWaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaW5lR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgIHZhciBzeW1ib2xEcmF3ID0gbmV3IFN5bWJvbERyYXcoKTtcbiAgICB0aGlzLmdyb3VwLmFkZChzeW1ib2xEcmF3Lmdyb3VwKTtcbiAgICB0aGlzLl9zeW1ib2xEcmF3ID0gc3ltYm9sRHJhdztcbiAgICB0aGlzLl9saW5lR3JvdXAgPSBsaW5lR3JvdXA7XG4gICAgdGhpcy5fY2hhbmdlUG9seVN0YXRlID0genJVdGlsLmJpbmQodGhpcy5fY2hhbmdlUG9seVN0YXRlLCB0aGlzKTtcbiAgfTtcbiAgTGluZVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciBsaW5lU3R5bGVNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgICB2YXIgYXJlYVN0eWxlTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnYXJlYVN0eWxlJyk7XG4gICAgdmFyIHBvaW50cyA9IGRhdGEuZ2V0TGF5b3V0KCdwb2ludHMnKSB8fCBbXTtcbiAgICB2YXIgaXNDb29yZFN5c1BvbGFyID0gY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJztcbiAgICB2YXIgcHJldkNvb3JkU3lzID0gdGhpcy5fY29vcmRTeXM7XG4gICAgdmFyIHN5bWJvbERyYXcgPSB0aGlzLl9zeW1ib2xEcmF3O1xuICAgIHZhciBwb2x5bGluZSA9IHRoaXMuX3BvbHlsaW5lO1xuICAgIHZhciBwb2x5Z29uID0gdGhpcy5fcG9seWdvbjtcbiAgICB2YXIgbGluZUdyb3VwID0gdGhpcy5fbGluZUdyb3VwO1xuICAgIHZhciBoYXNBbmltYXRpb24gPSAhZWNNb2RlbC5zc3IgJiYgc2VyaWVzTW9kZWwuZ2V0KCdhbmltYXRpb24nKTtcbiAgICB2YXIgaXNBcmVhQ2hhcnQgPSAhYXJlYVN0eWxlTW9kZWwuaXNFbXB0eSgpO1xuICAgIHZhciB2YWx1ZU9yaWdpbiA9IGFyZWFTdHlsZU1vZGVsLmdldCgnb3JpZ2luJyk7XG4gICAgdmFyIGRhdGFDb29yZEluZm8gPSBwcmVwYXJlRGF0YUNvb3JkSW5mbyhjb29yZFN5cywgZGF0YSwgdmFsdWVPcmlnaW4pO1xuICAgIHZhciBzdGFja2VkT25Qb2ludHMgPSBpc0FyZWFDaGFydCAmJiBnZXRTdGFja2VkT25Qb2ludHMoY29vcmRTeXMsIGRhdGEsIGRhdGFDb29yZEluZm8pO1xuICAgIHZhciBzaG93U3ltYm9sID0gc2VyaWVzTW9kZWwuZ2V0KCdzaG93U3ltYm9sJyk7XG4gICAgdmFyIGNvbm5lY3ROdWxscyA9IHNlcmllc01vZGVsLmdldCgnY29ubmVjdE51bGxzJyk7XG4gICAgdmFyIGlzSWdub3JlRnVuYyA9IHNob3dTeW1ib2wgJiYgIWlzQ29vcmRTeXNQb2xhciAmJiBnZXRJc0lnbm9yZUZ1bmMoc2VyaWVzTW9kZWwsIGRhdGEsIGNvb3JkU3lzKTtcbiAgICAvLyBSZW1vdmUgdGVtcG9yYXJ5IHN5bWJvbHNcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgb2xkRGF0YSAmJiBvbGREYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICBpZiAoZWwuX190ZW1wKSB7XG4gICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgIG9sZERhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjcmVhdGVkIHN5bWJvbHMgaWYgc2hvd1N5bWJvbCBjaGFuZ2VkIHRvIGZhbHNlXG4gICAgaWYgKCFzaG93U3ltYm9sKSB7XG4gICAgICBzeW1ib2xEcmF3LnJlbW92ZSgpO1xuICAgIH1cbiAgICBncm91cC5hZGQobGluZUdyb3VwKTtcbiAgICAvLyBGSVhNRSBzdGVwIG5vdCBzdXBwb3J0IHBvbGFyXG4gICAgdmFyIHN0ZXAgPSAhaXNDb29yZFN5c1BvbGFyID8gc2VyaWVzTW9kZWwuZ2V0KCdzdGVwJykgOiBmYWxzZTtcbiAgICB2YXIgY2xpcFNoYXBlRm9yU3ltYm9sO1xuICAgIGlmIChjb29yZFN5cyAmJiBjb29yZFN5cy5nZXRBcmVhICYmIHNlcmllc01vZGVsLmdldCgnY2xpcCcsIHRydWUpKSB7XG4gICAgICBjbGlwU2hhcGVGb3JTeW1ib2wgPSBjb29yZFN5cy5nZXRBcmVhKCk7XG4gICAgICAvLyBBdm9pZCBmbG9hdCBudW1iZXIgcm91bmRpbmcgZXJyb3IgZm9yIHN5bWJvbCBvbiB0aGUgZWRnZSBvZiBheGlzIGV4dGVudC5cbiAgICAgIC8vIFNlZSAjNzkxMyBhbmQgYHRlc3QvZGF0YVpvb20tY2xpcC5odG1sYC5cbiAgICAgIGlmIChjbGlwU2hhcGVGb3JTeW1ib2wud2lkdGggIT0gbnVsbCkge1xuICAgICAgICBjbGlwU2hhcGVGb3JTeW1ib2wueCAtPSAwLjE7XG4gICAgICAgIGNsaXBTaGFwZUZvclN5bWJvbC55IC09IDAuMTtcbiAgICAgICAgY2xpcFNoYXBlRm9yU3ltYm9sLndpZHRoICs9IDAuMjtcbiAgICAgICAgY2xpcFNoYXBlRm9yU3ltYm9sLmhlaWdodCArPSAwLjI7XG4gICAgICB9IGVsc2UgaWYgKGNsaXBTaGFwZUZvclN5bWJvbC5yMCkge1xuICAgICAgICBjbGlwU2hhcGVGb3JTeW1ib2wucjAgLT0gMC41O1xuICAgICAgICBjbGlwU2hhcGVGb3JTeW1ib2wuciArPSAwLjU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2NsaXBTaGFwZUZvclN5bWJvbCA9IGNsaXBTaGFwZUZvclN5bWJvbDtcbiAgICB2YXIgdmlzdWFsQ29sb3IgPSBnZXRWaXN1YWxHcmFkaWVudChkYXRhLCBjb29yZFN5cywgYXBpKSB8fCBkYXRhLmdldFZpc3VhbCgnc3R5bGUnKVtkYXRhLmdldFZpc3VhbCgnZHJhd1R5cGUnKV07XG4gICAgLy8gSW5pdGlhbGl6YXRpb24gYW5pbWF0aW9uIG9yIGNvb3JkaW5hdGUgc3lzdGVtIGNoYW5nZWRcbiAgICBpZiAoIShwb2x5bGluZSAmJiBwcmV2Q29vcmRTeXMudHlwZSA9PT0gY29vcmRTeXMudHlwZSAmJiBzdGVwID09PSB0aGlzLl9zdGVwKSkge1xuICAgICAgc2hvd1N5bWJvbCAmJiBzeW1ib2xEcmF3LnVwZGF0ZURhdGEoZGF0YSwge1xuICAgICAgICBpc0lnbm9yZTogaXNJZ25vcmVGdW5jLFxuICAgICAgICBjbGlwU2hhcGU6IGNsaXBTaGFwZUZvclN5bWJvbCxcbiAgICAgICAgZGlzYWJsZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgZ2V0U3ltYm9sUG9pbnQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICByZXR1cm4gW3BvaW50c1tpZHggKiAyXSwgcG9pbnRzW2lkeCAqIDIgKyAxXV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaGFzQW5pbWF0aW9uICYmIHRoaXMuX2luaXRTeW1ib2xMYWJlbEFuaW1hdGlvbihkYXRhLCBjb29yZFN5cywgY2xpcFNoYXBlRm9yU3ltYm9sKTtcbiAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgIGlmIChzdGFja2VkT25Qb2ludHMpIHtcbiAgICAgICAgICBzdGFja2VkT25Qb2ludHMgPSB0dXJuUG9pbnRzSW50b1N0ZXAoc3RhY2tlZE9uUG9pbnRzLCBwb2ludHMsIGNvb3JkU3lzLCBzdGVwLCBjb25uZWN0TnVsbHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gSWYgc3RhY2tlZCBzZXJpZXMgaXMgbm90IHN0ZXBcbiAgICAgICAgcG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHBvaW50cywgbnVsbCwgY29vcmRTeXMsIHN0ZXAsIGNvbm5lY3ROdWxscyk7XG4gICAgICB9XG4gICAgICBwb2x5bGluZSA9IHRoaXMuX25ld1BvbHlsaW5lKHBvaW50cyk7XG4gICAgICBpZiAoaXNBcmVhQ2hhcnQpIHtcbiAgICAgICAgcG9seWdvbiA9IHRoaXMuX25ld1BvbHlnb24ocG9pbnRzLCBzdGFja2VkT25Qb2ludHMpO1xuICAgICAgfSAvLyBJZiBhcmVhU3R5bGUgaXMgcmVtb3ZlZFxuICAgICAgZWxzZSBpZiAocG9seWdvbikge1xuICAgICAgICBsaW5lR3JvdXAucmVtb3ZlKHBvbHlnb24pO1xuICAgICAgICBwb2x5Z29uID0gdGhpcy5fcG9seWdvbiA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBOT1RFOiBNdXN0IHVwZGF0ZSBfZW5kTGFiZWwgYmVmb3JlIHNldENsaXBQYXRoLlxuICAgICAgaWYgKCFpc0Nvb3JkU3lzUG9sYXIpIHtcbiAgICAgICAgdGhpcy5faW5pdE9yVXBkYXRlRW5kTGFiZWwoc2VyaWVzTW9kZWwsIGNvb3JkU3lzLCBjb252ZXJ0VG9Db2xvclN0cmluZyh2aXN1YWxDb2xvcikpO1xuICAgICAgfVxuICAgICAgbGluZUdyb3VwLnNldENsaXBQYXRoKGNyZWF0ZUxpbmVDbGlwUGF0aCh0aGlzLCBjb29yZFN5cywgdHJ1ZSwgc2VyaWVzTW9kZWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQXJlYUNoYXJ0ICYmICFwb2x5Z29uKSB7XG4gICAgICAgIC8vIElmIGFyZWFTdHlsZSBpcyBhZGRlZFxuICAgICAgICBwb2x5Z29uID0gdGhpcy5fbmV3UG9seWdvbihwb2ludHMsIHN0YWNrZWRPblBvaW50cyk7XG4gICAgICB9IGVsc2UgaWYgKHBvbHlnb24gJiYgIWlzQXJlYUNoYXJ0KSB7XG4gICAgICAgIC8vIElmIGFyZWFTdHlsZSBpcyByZW1vdmVkXG4gICAgICAgIGxpbmVHcm91cC5yZW1vdmUocG9seWdvbik7XG4gICAgICAgIHBvbHlnb24gPSB0aGlzLl9wb2x5Z29uID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIE5PVEU6IE11c3QgdXBkYXRlIF9lbmRMYWJlbCBiZWZvcmUgc2V0Q2xpcFBhdGguXG4gICAgICBpZiAoIWlzQ29vcmRTeXNQb2xhcikge1xuICAgICAgICB0aGlzLl9pbml0T3JVcGRhdGVFbmRMYWJlbChzZXJpZXNNb2RlbCwgY29vcmRTeXMsIGNvbnZlcnRUb0NvbG9yU3RyaW5nKHZpc3VhbENvbG9yKSk7XG4gICAgICB9XG4gICAgICAvLyBVcGRhdGUgY2xpcFBhdGhcbiAgICAgIHZhciBvbGRDbGlwUGF0aCA9IGxpbmVHcm91cC5nZXRDbGlwUGF0aCgpO1xuICAgICAgaWYgKG9sZENsaXBQYXRoKSB7XG4gICAgICAgIHZhciBuZXdDbGlwUGF0aCA9IGNyZWF0ZUxpbmVDbGlwUGF0aCh0aGlzLCBjb29yZFN5cywgZmFsc2UsIHNlcmllc01vZGVsKTtcbiAgICAgICAgZ3JhcGhpYy5pbml0UHJvcHMob2xkQ2xpcFBhdGgsIHtcbiAgICAgICAgICBzaGFwZTogbmV3Q2xpcFBhdGguc2hhcGVcbiAgICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZUdyb3VwLnNldENsaXBQYXRoKGNyZWF0ZUxpbmVDbGlwUGF0aCh0aGlzLCBjb29yZFN5cywgdHJ1ZSwgc2VyaWVzTW9kZWwpKTtcbiAgICAgIH1cbiAgICAgIC8vIEFsd2F5cyB1cGRhdGUsIG9yIGl0IGlzIHdyb25nIGluIHRoZSBjYXNlIHR1cm5pbmcgb24gbGVnZW5kXG4gICAgICAvLyBiZWNhdXNlIHBvaW50cyBhcmUgbm90IGNoYW5nZWQuXG4gICAgICBzaG93U3ltYm9sICYmIHN5bWJvbERyYXcudXBkYXRlRGF0YShkYXRhLCB7XG4gICAgICAgIGlzSWdub3JlOiBpc0lnbm9yZUZ1bmMsXG4gICAgICAgIGNsaXBTaGFwZTogY2xpcFNoYXBlRm9yU3ltYm9sLFxuICAgICAgICBkaXNhYmxlQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICBnZXRTeW1ib2xQb2ludDogZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgIHJldHVybiBbcG9pbnRzW2lkeCAqIDJdLCBwb2ludHNbaWR4ICogMiArIDFdXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBJbiB0aGUgY2FzZSBkYXRhIHpvb20gdHJpZ2dlcmVkIHJlZnJlc2hpbmcgZnJlcXVlbnRseVxuICAgICAgLy8gRGF0YSBtYXkgbm90IGNoYW5nZSBpZiBsaW5lIGhhcyBhIGNhdGVnb3J5IGF4aXMuIFNvIGl0IHNob3VsZCBhbmltYXRlIG5vdGhpbmcuXG4gICAgICBpZiAoIWlzUG9pbnRzU2FtZSh0aGlzLl9zdGFja2VkT25Qb2ludHMsIHN0YWNrZWRPblBvaW50cykgfHwgIWlzUG9pbnRzU2FtZSh0aGlzLl9wb2ludHMsIHBvaW50cykpIHtcbiAgICAgICAgaWYgKGhhc0FuaW1hdGlvbikge1xuICAgICAgICAgIHRoaXMuX2RvVXBkYXRlQW5pbWF0aW9uKGRhdGEsIHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIGFwaSwgc3RlcCwgdmFsdWVPcmlnaW4sIGNvbm5lY3ROdWxscyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm90IGRvIGl0IGluIHVwZGF0ZSB3aXRoIGFuaW1hdGlvblxuICAgICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICBpZiAoc3RhY2tlZE9uUG9pbnRzKSB7XG4gICAgICAgICAgICAgIHN0YWNrZWRPblBvaW50cyA9IHR1cm5Qb2ludHNJbnRvU3RlcChzdGFja2VkT25Qb2ludHMsIHBvaW50cywgY29vcmRTeXMsIHN0ZXAsIGNvbm5lY3ROdWxscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPIElmIHN0YWNrZWQgc2VyaWVzIGlzIG5vdCBzdGVwXG4gICAgICAgICAgICBwb2ludHMgPSB0dXJuUG9pbnRzSW50b1N0ZXAocG9pbnRzLCBudWxsLCBjb29yZFN5cywgc3RlcCwgY29ubmVjdE51bGxzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9seWxpbmUuc2V0U2hhcGUoe1xuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb2x5Z29uICYmIHBvbHlnb24uc2V0U2hhcGUoe1xuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPblBvaW50c1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBlbXBoYXNpc01vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJyk7XG4gICAgdmFyIGZvY3VzID0gZW1waGFzaXNNb2RlbC5nZXQoJ2ZvY3VzJyk7XG4gICAgdmFyIGJsdXJTY29wZSA9IGVtcGhhc2lzTW9kZWwuZ2V0KCdibHVyU2NvcGUnKTtcbiAgICB2YXIgZW1waGFzaXNEaXNhYmxlZCA9IGVtcGhhc2lzTW9kZWwuZ2V0KCdkaXNhYmxlZCcpO1xuICAgIHBvbHlsaW5lLnVzZVN0eWxlKHpyVXRpbC5kZWZhdWx0cyhcbiAgICAvLyBVc2UgY29sb3IgaW4gbGluZVN0eWxlIGZpcnN0XG4gICAgbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCksIHtcbiAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgIHN0cm9rZTogdmlzdWFsQ29sb3IsXG4gICAgICBsaW5lSm9pbjogJ2JldmVsJ1xuICAgIH0pKTtcbiAgICBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwocG9seWxpbmUsIHNlcmllc01vZGVsLCAnbGluZVN0eWxlJyk7XG4gICAgaWYgKHBvbHlsaW5lLnN0eWxlLmxpbmVXaWR0aCA+IDAgJiYgc2VyaWVzTW9kZWwuZ2V0KFsnZW1waGFzaXMnLCAnbGluZVN0eWxlJywgJ3dpZHRoJ10pID09PSAnYm9sZGVyJykge1xuICAgICAgdmFyIGVtcGhhc2lzTGluZVN0eWxlID0gcG9seWxpbmUuZ2V0U3RhdGUoJ2VtcGhhc2lzJykuc3R5bGU7XG4gICAgICBlbXBoYXNpc0xpbmVTdHlsZS5saW5lV2lkdGggPSArcG9seWxpbmUuc3R5bGUubGluZVdpZHRoICsgMTtcbiAgICB9XG4gICAgLy8gTmVlZHMgc2VyaWVzSW5kZXggZm9yIGZvY3VzXG4gICAgZ2V0RUNEYXRhKHBvbHlsaW5lKS5zZXJpZXNJbmRleCA9IHNlcmllc01vZGVsLnNlcmllc0luZGV4O1xuICAgIHRvZ2dsZUhvdmVyRW1waGFzaXMocG9seWxpbmUsIGZvY3VzLCBibHVyU2NvcGUsIGVtcGhhc2lzRGlzYWJsZWQpO1xuICAgIHZhciBzbW9vdGggPSBnZXRTbW9vdGgoc2VyaWVzTW9kZWwuZ2V0KCdzbW9vdGgnKSk7XG4gICAgdmFyIHNtb290aE1vbm90b25lID0gc2VyaWVzTW9kZWwuZ2V0KCdzbW9vdGhNb25vdG9uZScpO1xuICAgIHBvbHlsaW5lLnNldFNoYXBlKHtcbiAgICAgIHNtb290aDogc21vb3RoLFxuICAgICAgc21vb3RoTW9ub3RvbmU6IHNtb290aE1vbm90b25lLFxuICAgICAgY29ubmVjdE51bGxzOiBjb25uZWN0TnVsbHNcbiAgICB9KTtcbiAgICBpZiAocG9seWdvbikge1xuICAgICAgdmFyIHN0YWNrZWRPblNlcmllcyA9IGRhdGEuZ2V0Q2FsY3VsYXRpb25JbmZvKCdzdGFja2VkT25TZXJpZXMnKTtcbiAgICAgIHZhciBzdGFja2VkT25TbW9vdGggPSAwO1xuICAgICAgcG9seWdvbi51c2VTdHlsZSh6clV0aWwuZGVmYXVsdHMoYXJlYVN0eWxlTW9kZWwuZ2V0QXJlYVN0eWxlKCksIHtcbiAgICAgICAgZmlsbDogdmlzdWFsQ29sb3IsXG4gICAgICAgIG9wYWNpdHk6IDAuNyxcbiAgICAgICAgbGluZUpvaW46ICdiZXZlbCcsXG4gICAgICAgIGRlY2FsOiBkYXRhLmdldFZpc3VhbCgnc3R5bGUnKS5kZWNhbFxuICAgICAgfSkpO1xuICAgICAgaWYgKHN0YWNrZWRPblNlcmllcykge1xuICAgICAgICBzdGFja2VkT25TbW9vdGggPSBnZXRTbW9vdGgoc3RhY2tlZE9uU2VyaWVzLmdldCgnc21vb3RoJykpO1xuICAgICAgfVxuICAgICAgcG9seWdvbi5zZXRTaGFwZSh7XG4gICAgICAgIHNtb290aDogc21vb3RoLFxuICAgICAgICBzdGFja2VkT25TbW9vdGg6IHN0YWNrZWRPblNtb290aCxcbiAgICAgICAgc21vb3RoTW9ub3RvbmU6IHNtb290aE1vbm90b25lLFxuICAgICAgICBjb25uZWN0TnVsbHM6IGNvbm5lY3ROdWxsc1xuICAgICAgfSk7XG4gICAgICBzZXRTdGF0ZXNTdHlsZXNGcm9tTW9kZWwocG9seWdvbiwgc2VyaWVzTW9kZWwsICdhcmVhU3R5bGUnKTtcbiAgICAgIC8vIE5lZWRzIHNlcmllc0luZGV4IGZvciBmb2N1c1xuICAgICAgZ2V0RUNEYXRhKHBvbHlnb24pLnNlcmllc0luZGV4ID0gc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXg7XG4gICAgICB0b2dnbGVIb3ZlckVtcGhhc2lzKHBvbHlnb24sIGZvY3VzLCBibHVyU2NvcGUsIGVtcGhhc2lzRGlzYWJsZWQpO1xuICAgIH1cbiAgICB2YXIgY2hhbmdlUG9seVN0YXRlID0gdGhpcy5fY2hhbmdlUG9seVN0YXRlO1xuICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAvLyBTd2l0Y2ggcG9seWxpbmUgLyBwb2x5Z29uIHN0YXRlIGlmIGVsZW1lbnQgY2hhbmdlZCBpdHMgc3RhdGUuXG4gICAgICBlbCAmJiAoZWwub25Ib3ZlclN0YXRlQ2hhbmdlID0gY2hhbmdlUG9seVN0YXRlKTtcbiAgICB9KTtcbiAgICB0aGlzLl9wb2x5bGluZS5vbkhvdmVyU3RhdGVDaGFuZ2UgPSBjaGFuZ2VQb2x5U3RhdGU7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgLy8gU2F2ZSB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gZm9yIHRyYW5zaXRpb24gYW5pbWF0aW9uIHdoZW4gZGF0YSBjaGFuZ2VkXG4gICAgdGhpcy5fY29vcmRTeXMgPSBjb29yZFN5cztcbiAgICB0aGlzLl9zdGFja2VkT25Qb2ludHMgPSBzdGFja2VkT25Qb2ludHM7XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgIHRoaXMuX3ZhbHVlT3JpZ2luID0gdmFsdWVPcmlnaW47XG4gICAgaWYgKHNlcmllc01vZGVsLmdldCgndHJpZ2dlckxpbmVFdmVudCcpKSB7XG4gICAgICB0aGlzLnBhY2tFdmVudERhdGEoc2VyaWVzTW9kZWwsIHBvbHlsaW5lKTtcbiAgICAgIHBvbHlnb24gJiYgdGhpcy5wYWNrRXZlbnREYXRhKHNlcmllc01vZGVsLCBwb2x5Z29uKTtcbiAgICB9XG4gIH07XG4gIExpbmVWaWV3LnByb3RvdHlwZS5wYWNrRXZlbnREYXRhID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlbCkge1xuICAgIGdldEVDRGF0YShlbCkuZXZlbnREYXRhID0ge1xuICAgICAgY29tcG9uZW50VHlwZTogJ3NlcmllcycsXG4gICAgICBjb21wb25lbnRTdWJUeXBlOiAnbGluZScsXG4gICAgICBjb21wb25lbnRJbmRleDogc2VyaWVzTW9kZWwuY29tcG9uZW50SW5kZXgsXG4gICAgICBzZXJpZXNJbmRleDogc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXgsXG4gICAgICBzZXJpZXNOYW1lOiBzZXJpZXNNb2RlbC5uYW1lLFxuICAgICAgc2VyaWVzVHlwZTogJ2xpbmUnXG4gICAgfTtcbiAgfTtcbiAgTGluZVZpZXcucHJvdG90eXBlLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGRhdGFJbmRleCA9IG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleChkYXRhLCBwYXlsb2FkKTtcbiAgICB0aGlzLl9jaGFuZ2VQb2x5U3RhdGUoJ2VtcGhhc2lzJyk7XG4gICAgaWYgKCEoZGF0YUluZGV4IGluc3RhbmNlb2YgQXJyYXkpICYmIGRhdGFJbmRleCAhPSBudWxsICYmIGRhdGFJbmRleCA+PSAwKSB7XG4gICAgICB2YXIgcG9pbnRzID0gZGF0YS5nZXRMYXlvdXQoJ3BvaW50cycpO1xuICAgICAgdmFyIHN5bWJvbCA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgpO1xuICAgICAgaWYgKCFzeW1ib2wpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IHN5bWJvbCBpZiBpdCBpcyBub3QgZXhpc3RzXG4gICAgICAgIHZhciB4ID0gcG9pbnRzW2RhdGFJbmRleCAqIDJdO1xuICAgICAgICB2YXIgeSA9IHBvaW50c1tkYXRhSW5kZXggKiAyICsgMV07XG4gICAgICAgIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkge1xuICAgICAgICAgIC8vIE51bGwgZGF0YVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaXggIzExMzYwOiBzaG91bGRuJ3QgZHJhdyBzeW1ib2wgb3V0c2lkZSBjbGlwU2hhcGVGb3JTeW1ib2xcbiAgICAgICAgaWYgKHRoaXMuX2NsaXBTaGFwZUZvclN5bWJvbCAmJiAhdGhpcy5fY2xpcFNoYXBlRm9yU3ltYm9sLmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHpsZXZlbCA9IHNlcmllc01vZGVsLmdldCgnemxldmVsJykgfHwgMDtcbiAgICAgICAgdmFyIHogPSBzZXJpZXNNb2RlbC5nZXQoJ3onKSB8fCAwO1xuICAgICAgICBzeW1ib2wgPSBuZXcgU3ltYm9sQ2x6KGRhdGEsIGRhdGFJbmRleCk7XG4gICAgICAgIHN5bWJvbC54ID0geDtcbiAgICAgICAgc3ltYm9sLnkgPSB5O1xuICAgICAgICBzeW1ib2wuc2V0Wih6bGV2ZWwsIHopO1xuICAgICAgICAvLyBlbnN1cmUgbGFiZWwgdGV4dCBvZiB0aGUgdGVtcG9yYXJ5IHN5bWJvbCBpcyBpbiBmcm9udCBvZiBsaW5lIGFuZCBhcmVhIHBvbHlnb25cbiAgICAgICAgdmFyIHN5bWJvbExhYmVsID0gc3ltYm9sLmdldFN5bWJvbFBhdGgoKS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICBpZiAoc3ltYm9sTGFiZWwpIHtcbiAgICAgICAgICBzeW1ib2xMYWJlbC56bGV2ZWwgPSB6bGV2ZWw7XG4gICAgICAgICAgc3ltYm9sTGFiZWwueiA9IHo7XG4gICAgICAgICAgc3ltYm9sTGFiZWwuejIgPSB0aGlzLl9wb2x5bGluZS56MiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgc3ltYm9sLl9fdGVtcCA9IHRydWU7XG4gICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIHN5bWJvbCk7XG4gICAgICAgIC8vIFN0b3Agc2NhbGUgYW5pbWF0aW9uXG4gICAgICAgIHN5bWJvbC5zdG9wU3ltYm9sQW5pbWF0aW9uKHRydWUpO1xuICAgICAgICB0aGlzLmdyb3VwLmFkZChzeW1ib2wpO1xuICAgICAgfVxuICAgICAgc3ltYm9sLmhpZ2hsaWdodCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIaWdobGlnaHQgd2hvbGUgc2VyaWVzXG4gICAgICBDaGFydFZpZXcucHJvdG90eXBlLmhpZ2hsaWdodC5jYWxsKHRoaXMsIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgIH1cbiAgfTtcbiAgTGluZVZpZXcucHJvdG90eXBlLmRvd25wbGF5ID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgZGF0YUluZGV4ID0gbW9kZWxVdGlsLnF1ZXJ5RGF0YUluZGV4KGRhdGEsIHBheWxvYWQpO1xuICAgIHRoaXMuX2NoYW5nZVBvbHlTdGF0ZSgnbm9ybWFsJyk7XG4gICAgaWYgKGRhdGFJbmRleCAhPSBudWxsICYmIGRhdGFJbmRleCA+PSAwKSB7XG4gICAgICB2YXIgc3ltYm9sID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCk7XG4gICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgIGlmIChzeW1ib2wuX190ZW1wKSB7XG4gICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgbnVsbCk7XG4gICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmUoc3ltYm9sKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzeW1ib2wuZG93bnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGSVhNRVxuICAgICAgLy8gY2FuIG5vdCBkb3ducGxheSBjb21wbGV0ZWx5LlxuICAgICAgLy8gRG93bnBsYXkgd2hvbGUgc2VyaWVzXG4gICAgICBDaGFydFZpZXcucHJvdG90eXBlLmRvd25wbGF5LmNhbGwodGhpcywgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgfVxuICB9O1xuICBMaW5lVmlldy5wcm90b3R5cGUuX2NoYW5nZVBvbHlTdGF0ZSA9IGZ1bmN0aW9uICh0b1N0YXRlKSB7XG4gICAgdmFyIHBvbHlnb24gPSB0aGlzLl9wb2x5Z29uO1xuICAgIHNldFN0YXRlc0ZsYWcodGhpcy5fcG9seWxpbmUsIHRvU3RhdGUpO1xuICAgIHBvbHlnb24gJiYgc2V0U3RhdGVzRmxhZyhwb2x5Z29uLCB0b1N0YXRlKTtcbiAgfTtcbiAgTGluZVZpZXcucHJvdG90eXBlLl9uZXdQb2x5bGluZSA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTtcbiAgICAvLyBSZW1vdmUgcHJldmlvdXMgY3JlYXRlZCBwb2x5bGluZVxuICAgIGlmIChwb2x5bGluZSkge1xuICAgICAgdGhpcy5fbGluZUdyb3VwLnJlbW92ZShwb2x5bGluZSk7XG4gICAgfVxuICAgIHBvbHlsaW5lID0gbmV3IEVDUG9seWxpbmUoe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgIH0sXG4gICAgICBzZWdtZW50SWdub3JlVGhyZXNob2xkOiAyLFxuICAgICAgejI6IDEwXG4gICAgfSk7XG4gICAgdGhpcy5fbGluZUdyb3VwLmFkZChwb2x5bGluZSk7XG4gICAgdGhpcy5fcG9seWxpbmUgPSBwb2x5bGluZTtcbiAgICByZXR1cm4gcG9seWxpbmU7XG4gIH07XG4gIExpbmVWaWV3LnByb3RvdHlwZS5fbmV3UG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMsIHN0YWNrZWRPblBvaW50cykge1xuICAgIHZhciBwb2x5Z29uID0gdGhpcy5fcG9seWdvbjtcbiAgICAvLyBSZW1vdmUgcHJldmlvdXMgY3JlYXRlZCBwb2x5Z29uXG4gICAgaWYgKHBvbHlnb24pIHtcbiAgICAgIHRoaXMuX2xpbmVHcm91cC5yZW1vdmUocG9seWdvbik7XG4gICAgfVxuICAgIHBvbHlnb24gPSBuZXcgRUNQb2x5Z29uKHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPblBvaW50c1xuICAgICAgfSxcbiAgICAgIHNlZ21lbnRJZ25vcmVUaHJlc2hvbGQ6IDJcbiAgICB9KTtcbiAgICB0aGlzLl9saW5lR3JvdXAuYWRkKHBvbHlnb24pO1xuICAgIHRoaXMuX3BvbHlnb24gPSBwb2x5Z29uO1xuICAgIHJldHVybiBwb2x5Z29uO1xuICB9O1xuICBMaW5lVmlldy5wcm90b3R5cGUuX2luaXRTeW1ib2xMYWJlbEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChkYXRhLCBjb29yZFN5cywgY2xpcFNoYXBlKSB7XG4gICAgdmFyIGlzSG9yaXpvbnRhbE9yUmFkaWFsO1xuICAgIHZhciBpc0Nvb3JkU3lzUG9sYXI7XG4gICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICB2YXIgaXNBeGlzSW52ZXJzZSA9IGJhc2VBeGlzLmludmVyc2U7XG4gICAgaWYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgIGlzSG9yaXpvbnRhbE9yUmFkaWFsID0gYmFzZUF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgICBpc0Nvb3JkU3lzUG9sYXIgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNvb3JkU3lzLnR5cGUgPT09ICdwb2xhcicpIHtcbiAgICAgIGlzSG9yaXpvbnRhbE9yUmFkaWFsID0gYmFzZUF4aXMuZGltID09PSAnYW5nbGUnO1xuICAgICAgaXNDb29yZFN5c1BvbGFyID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgdmFyIHNlcmllc0R1cmF0aW9uID0gc2VyaWVzTW9kZWwuZ2V0KCdhbmltYXRpb25EdXJhdGlvbicpO1xuICAgIGlmICh6clV0aWwuaXNGdW5jdGlvbihzZXJpZXNEdXJhdGlvbikpIHtcbiAgICAgIHNlcmllc0R1cmF0aW9uID0gc2VyaWVzRHVyYXRpb24obnVsbCk7XG4gICAgfVxuICAgIHZhciBzZXJpZXNEZWxheSA9IHNlcmllc01vZGVsLmdldCgnYW5pbWF0aW9uRGVsYXknKSB8fCAwO1xuICAgIHZhciBzZXJpZXNEZWxheVZhbHVlID0genJVdGlsLmlzRnVuY3Rpb24oc2VyaWVzRGVsYXkpID8gc2VyaWVzRGVsYXkobnVsbCkgOiBzZXJpZXNEZWxheTtcbiAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChzeW1ib2wsIGlkeCkge1xuICAgICAgdmFyIGVsID0gc3ltYm9sO1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIHZhciBwb2ludCA9IFtzeW1ib2wueCwgc3ltYm9sLnldO1xuICAgICAgICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBlbmQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdm9pZCAwO1xuICAgICAgICBpZiAoY2xpcFNoYXBlKSB7XG4gICAgICAgICAgaWYgKGlzQ29vcmRTeXNQb2xhcikge1xuICAgICAgICAgICAgdmFyIHBvbGFyQ2xpcCA9IGNsaXBTaGFwZTtcbiAgICAgICAgICAgIHZhciBjb29yZCA9IGNvb3JkU3lzLnBvaW50VG9Db29yZChwb2ludCk7XG4gICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsT3JSYWRpYWwpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBwb2xhckNsaXAuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgZW5kID0gcG9sYXJDbGlwLmVuZEFuZ2xlO1xuICAgICAgICAgICAgICBjdXJyZW50ID0gLWNvb3JkWzFdIC8gMTgwICogTWF0aC5QSTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gcG9sYXJDbGlwLnIwO1xuICAgICAgICAgICAgICBlbmQgPSBwb2xhckNsaXAucjtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGNvb3JkWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZ3JpZENsaXAgPSBjbGlwU2hhcGU7XG4gICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsT3JSYWRpYWwpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBncmlkQ2xpcC54O1xuICAgICAgICAgICAgICBlbmQgPSBncmlkQ2xpcC54ICsgZ3JpZENsaXAud2lkdGg7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBzeW1ib2wueDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gZ3JpZENsaXAueSArIGdyaWRDbGlwLmhlaWdodDtcbiAgICAgICAgICAgICAgZW5kID0gZ3JpZENsaXAueTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IHN5bWJvbC55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmF0aW8gPSBlbmQgPT09IHN0YXJ0ID8gMCA6IChjdXJyZW50IC0gc3RhcnQpIC8gKGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgaWYgKGlzQXhpc0ludmVyc2UpIHtcbiAgICAgICAgICByYXRpbyA9IDEgLSByYXRpbztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsYXkgPSB6clV0aWwuaXNGdW5jdGlvbihzZXJpZXNEZWxheSkgPyBzZXJpZXNEZWxheShpZHgpIDogc2VyaWVzRHVyYXRpb24gKiByYXRpbyArIHNlcmllc0RlbGF5VmFsdWU7XG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gZWwuZ2V0U3ltYm9sUGF0aCgpO1xuICAgICAgICB2YXIgdGV4dCA9IHN5bWJvbFBhdGguZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgZWwuYXR0cih7XG4gICAgICAgICAgc2NhbGVYOiAwLFxuICAgICAgICAgIHNjYWxlWTogMFxuICAgICAgICB9KTtcbiAgICAgICAgZWwuYW5pbWF0ZVRvKHtcbiAgICAgICAgICBzY2FsZVg6IDEsXG4gICAgICAgICAgc2NhbGVZOiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogMjAwLFxuICAgICAgICAgIHNldFRvRmluYWw6IHRydWUsXG4gICAgICAgICAgZGVsYXk6IGRlbGF5XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIHRleHQuYW5pbWF0ZUZyb20oe1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgICBkZWxheTogZGVsYXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzeW1ib2xQYXRoLmRpc2FibGVMYWJlbEFuaW1hdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIExpbmVWaWV3LnByb3RvdHlwZS5faW5pdE9yVXBkYXRlRW5kTGFiZWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGNvb3JkU3lzLCBpbmhlcml0Q29sb3IpIHtcbiAgICB2YXIgZW5kTGFiZWxNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdlbmRMYWJlbCcpO1xuICAgIGlmIChhbnlTdGF0ZVNob3dFbmRMYWJlbChzZXJpZXNNb2RlbCkpIHtcbiAgICAgIHZhciBkYXRhXzIgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTtcbiAgICAgIC8vIHNlcmllcyBtYXkgYmUgZmlsdGVyZWQuXG4gICAgICB2YXIgcG9pbnRzID0gZGF0YV8yLmdldExheW91dCgncG9pbnRzJyk7XG4gICAgICBpZiAoIXBvaW50cykge1xuICAgICAgICBwb2x5bGluZS5yZW1vdmVUZXh0Q29udGVudCgpO1xuICAgICAgICB0aGlzLl9lbmRMYWJlbCA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBlbmRMYWJlbCA9IHRoaXMuX2VuZExhYmVsO1xuICAgICAgaWYgKCFlbmRMYWJlbCkge1xuICAgICAgICBlbmRMYWJlbCA9IHRoaXMuX2VuZExhYmVsID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgICAgejI6IDIwMCAvLyBzaG91bGQgYmUgaGlnaGVyIHRoYW4gaXRlbSBzeW1ib2xcbiAgICAgICAgfSk7XG4gICAgICAgIGVuZExhYmVsLmlnbm9yZUNsaXAgPSB0cnVlO1xuICAgICAgICBwb2x5bGluZS5zZXRUZXh0Q29udGVudCh0aGlzLl9lbmRMYWJlbCk7XG4gICAgICAgIHBvbHlsaW5lLmRpc2FibGVMYWJlbEFuaW1hdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyBGaW5kIGxhc3Qgbm9uLU5hTiBkYXRhIHRvIGRpc3BsYXkgZGF0YVxuICAgICAgdmFyIGRhdGFJbmRleCA9IGdldExhc3RJbmRleE5vdE51bGwocG9pbnRzKTtcbiAgICAgIGlmIChkYXRhSW5kZXggPj0gMCkge1xuICAgICAgICBzZXRMYWJlbFN0eWxlKHBvbHlsaW5lLCBnZXRMYWJlbFN0YXRlc01vZGVscyhzZXJpZXNNb2RlbCwgJ2VuZExhYmVsJyksIHtcbiAgICAgICAgICBpbmhlcml0Q29sb3I6IGluaGVyaXRDb2xvcixcbiAgICAgICAgICBsYWJlbEZldGNoZXI6IHNlcmllc01vZGVsLFxuICAgICAgICAgIGxhYmVsRGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgICAgICAgZGVmYXVsdFRleHQ6IGZ1bmN0aW9uIChkYXRhSW5kZXgsIG9wdCwgaW50ZXJwb2xhdGVkVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZWRWYWx1ZSAhPSBudWxsID8gZ2V0RGVmYXVsdEludGVycG9sYXRlZExhYmVsKGRhdGFfMiwgaW50ZXJwb2xhdGVkVmFsdWUpIDogZ2V0RGVmYXVsdExhYmVsKGRhdGFfMiwgZGF0YUluZGV4KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuYWJsZVRleHRTZXR0ZXI6IHRydWVcbiAgICAgICAgfSwgZ2V0RW5kTGFiZWxTdGF0ZVNwZWNpZmllZChlbmRMYWJlbE1vZGVsLCBjb29yZFN5cykpO1xuICAgICAgICBwb2x5bGluZS50ZXh0Q29uZmlnLnBvc2l0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2VuZExhYmVsKSB7XG4gICAgICB0aGlzLl9wb2x5bGluZS5yZW1vdmVUZXh0Q29udGVudCgpO1xuICAgICAgdGhpcy5fZW5kTGFiZWwgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgTGluZVZpZXcucHJvdG90eXBlLl9lbmRMYWJlbE9uRHVyaW5nID0gZnVuY3Rpb24gKHBlcmNlbnQsIGNsaXBSZWN0LCBkYXRhLCBhbmltYXRpb25SZWNvcmQsIHZhbHVlQW5pbWF0aW9uLCBlbmRMYWJlbE1vZGVsLCBjb29yZFN5cykge1xuICAgIHZhciBlbmRMYWJlbCA9IHRoaXMuX2VuZExhYmVsO1xuICAgIHZhciBwb2x5bGluZSA9IHRoaXMuX3BvbHlsaW5lO1xuICAgIGlmIChlbmRMYWJlbCkge1xuICAgICAgLy8gTk9URTogRG9uJ3QgcmVtb3ZlIHBlcmNlbnQgPCAxLiBwZXJjZW50ID09PSAxIG1lYW5zIHRoZSBmaXJzdCBmcmFtZSBkdXJpbmcgcmVuZGVyLlxuICAgICAgLy8gVGhlIGxhYmVsIGlzIG5vdCBwcmVwYXJlZCBhdCB0aGlzIHRpbWUuXG4gICAgICBpZiAocGVyY2VudCA8IDEgJiYgYW5pbWF0aW9uUmVjb3JkLm9yaWdpbmFsWCA9PSBudWxsKSB7XG4gICAgICAgIGFuaW1hdGlvblJlY29yZC5vcmlnaW5hbFggPSBlbmRMYWJlbC54O1xuICAgICAgICBhbmltYXRpb25SZWNvcmQub3JpZ2luYWxZID0gZW5kTGFiZWwueTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludHMgPSBkYXRhLmdldExheW91dCgncG9pbnRzJyk7XG4gICAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICAgIHZhciBjb25uZWN0TnVsbHMgPSBzZXJpZXNNb2RlbC5nZXQoJ2Nvbm5lY3ROdWxscycpO1xuICAgICAgdmFyIHByZWNpc2lvbiA9IGVuZExhYmVsTW9kZWwuZ2V0KCdwcmVjaXNpb24nKTtcbiAgICAgIHZhciBkaXN0YW5jZSA9IGVuZExhYmVsTW9kZWwuZ2V0KCdkaXN0YW5jZScpIHx8IDA7XG4gICAgICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGJhc2VBeGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgdmFyIGlzQmFzZUludmVyc2VkID0gYmFzZUF4aXMuaW52ZXJzZTtcbiAgICAgIHZhciBjbGlwU2hhcGUgPSBjbGlwUmVjdC5zaGFwZTtcbiAgICAgIHZhciB4T3JZID0gaXNCYXNlSW52ZXJzZWQgPyBpc0hvcml6b250YWwgPyBjbGlwU2hhcGUueCA6IGNsaXBTaGFwZS55ICsgY2xpcFNoYXBlLmhlaWdodCA6IGlzSG9yaXpvbnRhbCA/IGNsaXBTaGFwZS54ICsgY2xpcFNoYXBlLndpZHRoIDogY2xpcFNoYXBlLnk7XG4gICAgICB2YXIgZGlzdGFuY2VYID0gKGlzSG9yaXpvbnRhbCA/IGRpc3RhbmNlIDogMCkgKiAoaXNCYXNlSW52ZXJzZWQgPyAtMSA6IDEpO1xuICAgICAgdmFyIGRpc3RhbmNlWSA9IChpc0hvcml6b250YWwgPyAwIDogLWRpc3RhbmNlKSAqIChpc0Jhc2VJbnZlcnNlZCA/IC0xIDogMSk7XG4gICAgICB2YXIgZGltID0gaXNIb3Jpem9udGFsID8gJ3gnIDogJ3knO1xuICAgICAgdmFyIGRhdGFJbmRleFJhbmdlID0gZ2V0SW5kZXhSYW5nZShwb2ludHMsIHhPclksIGRpbSk7XG4gICAgICB2YXIgaW5kaWNlcyA9IGRhdGFJbmRleFJhbmdlLnJhbmdlO1xuICAgICAgdmFyIGRpZmYgPSBpbmRpY2VzWzFdIC0gaW5kaWNlc1swXTtcbiAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgIGlmIChkaWZmID49IDEpIHtcbiAgICAgICAgLy8gZGlmZiA+IDEgJiYgY29ubmVjdE51bGxzLCB3aGljaCBpcyBvbiB0aGUgbnVsbCBkYXRhLlxuICAgICAgICBpZiAoZGlmZiA+IDEgJiYgIWNvbm5lY3ROdWxscykge1xuICAgICAgICAgIHZhciBwdCA9IGdldFBvaW50QXRJbmRleChwb2ludHMsIGluZGljZXNbMF0pO1xuICAgICAgICAgIGVuZExhYmVsLmF0dHIoe1xuICAgICAgICAgICAgeDogcHRbMF0gKyBkaXN0YW5jZVgsXG4gICAgICAgICAgICB5OiBwdFsxXSArIGRpc3RhbmNlWVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhbHVlQW5pbWF0aW9uICYmICh2YWx1ZSA9IHNlcmllc01vZGVsLmdldFJhd1ZhbHVlKGluZGljZXNbMF0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHQgPSBwb2x5bGluZS5nZXRQb2ludE9uKHhPclksIGRpbSk7XG4gICAgICAgICAgcHQgJiYgZW5kTGFiZWwuYXR0cih7XG4gICAgICAgICAgICB4OiBwdFswXSArIGRpc3RhbmNlWCxcbiAgICAgICAgICAgIHk6IHB0WzFdICsgZGlzdGFuY2VZXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShpbmRpY2VzWzBdKTtcbiAgICAgICAgICB2YXIgZW5kVmFsdWUgPSBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShpbmRpY2VzWzFdKTtcbiAgICAgICAgICB2YWx1ZUFuaW1hdGlvbiAmJiAodmFsdWUgPSBtb2RlbFV0aWwuaW50ZXJwb2xhdGVSYXdWYWx1ZXMoZGF0YSwgcHJlY2lzaW9uLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZGF0YUluZGV4UmFuZ2UudCkpO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdGlvblJlY29yZC5sYXN0RnJhbWVJbmRleCA9IGluZGljZXNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBkaWZmIDw9IDAsIHdoaWNoIGlzIHRoZSByYW5nZSBpcyBub3QgZm91bmQoSW5jbHVkZSBOYU4pXG4gICAgICAgIC8vIENob29zZSB0aGUgZmlyc3QgcG9pbnQgb3IgbGFzdCBwb2ludC5cbiAgICAgICAgdmFyIGlkeCA9IHBlcmNlbnQgPT09IDEgfHwgYW5pbWF0aW9uUmVjb3JkLmxhc3RGcmFtZUluZGV4ID4gMCA/IGluZGljZXNbMF0gOiAwO1xuICAgICAgICB2YXIgcHQgPSBnZXRQb2ludEF0SW5kZXgocG9pbnRzLCBpZHgpO1xuICAgICAgICB2YWx1ZUFuaW1hdGlvbiAmJiAodmFsdWUgPSBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShpZHgpKTtcbiAgICAgICAgZW5kTGFiZWwuYXR0cih7XG4gICAgICAgICAgeDogcHRbMF0gKyBkaXN0YW5jZVgsXG4gICAgICAgICAgeTogcHRbMV0gKyBkaXN0YW5jZVlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVBbmltYXRpb24pIHtcbiAgICAgICAgdmFyIGlubmVyID0gbGFiZWxJbm5lcihlbmRMYWJlbCk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5uZXIuc2V0TGFiZWxUZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaW5uZXIuc2V0TGFiZWxUZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgLy8gRklYTUUgVHdvIHZhbHVlIGF4aXNcbiAgTGluZVZpZXcucHJvdG90eXBlLl9kb1VwZGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChkYXRhLCBzdGFja2VkT25Qb2ludHMsIGNvb3JkU3lzLCBhcGksIHN0ZXAsIHZhbHVlT3JpZ2luLCBjb25uZWN0TnVsbHMpIHtcbiAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTtcbiAgICB2YXIgcG9seWdvbiA9IHRoaXMuX3BvbHlnb247XG4gICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgdmFyIGRpZmYgPSBsaW5lQW5pbWF0aW9uRGlmZih0aGlzLl9kYXRhLCBkYXRhLCB0aGlzLl9zdGFja2VkT25Qb2ludHMsIHN0YWNrZWRPblBvaW50cywgdGhpcy5fY29vcmRTeXMsIGNvb3JkU3lzLCB0aGlzLl92YWx1ZU9yaWdpbiwgdmFsdWVPcmlnaW4pO1xuICAgIHZhciBjdXJyZW50ID0gZGlmZi5jdXJyZW50O1xuICAgIHZhciBzdGFja2VkT25DdXJyZW50ID0gZGlmZi5zdGFja2VkT25DdXJyZW50O1xuICAgIHZhciBuZXh0ID0gZGlmZi5uZXh0O1xuICAgIHZhciBzdGFja2VkT25OZXh0ID0gZGlmZi5zdGFja2VkT25OZXh0O1xuICAgIGlmIChzdGVwKSB7XG4gICAgICAvLyBUT0RPIElmIHN0YWNrZWQgc2VyaWVzIGlzIG5vdCBzdGVwXG4gICAgICBzdGFja2VkT25DdXJyZW50ID0gdHVyblBvaW50c0ludG9TdGVwKGRpZmYuc3RhY2tlZE9uQ3VycmVudCwgZGlmZi5jdXJyZW50LCBjb29yZFN5cywgc3RlcCwgY29ubmVjdE51bGxzKTtcbiAgICAgIGN1cnJlbnQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5jdXJyZW50LCBudWxsLCBjb29yZFN5cywgc3RlcCwgY29ubmVjdE51bGxzKTtcbiAgICAgIHN0YWNrZWRPbk5leHQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5zdGFja2VkT25OZXh0LCBkaWZmLm5leHQsIGNvb3JkU3lzLCBzdGVwLCBjb25uZWN0TnVsbHMpO1xuICAgICAgbmV4dCA9IHR1cm5Qb2ludHNJbnRvU3RlcChkaWZmLm5leHQsIG51bGwsIGNvb3JkU3lzLCBzdGVwLCBjb25uZWN0TnVsbHMpO1xuICAgIH1cbiAgICAvLyBEb24ndCBhcHBseSBhbmltYXRpb24gaWYgZGlmZiBpcyBsYXJnZS5cbiAgICAvLyBGb3IgYmV0dGVyIHJlc3VsdCBhbmQgYXZvaWQgbWVtb3J5IGV4cGxvc2lvbiBwcm9ibGVtcyBsaWtlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9pbmN1YmF0b3ItZWNoYXJ0cy9pc3N1ZXMvMTIyMjlcbiAgICBpZiAoZ2V0Qm91bmRpbmdEaWZmKGN1cnJlbnQsIG5leHQpID4gMzAwMCB8fCBwb2x5Z29uICYmIGdldEJvdW5kaW5nRGlmZihzdGFja2VkT25DdXJyZW50LCBzdGFja2VkT25OZXh0KSA+IDMwMDApIHtcbiAgICAgIHBvbHlsaW5lLnN0b3BBbmltYXRpb24oKTtcbiAgICAgIHBvbHlsaW5lLnNldFNoYXBlKHtcbiAgICAgICAgcG9pbnRzOiBuZXh0XG4gICAgICB9KTtcbiAgICAgIGlmIChwb2x5Z29uKSB7XG4gICAgICAgIHBvbHlnb24uc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICBwb2x5Z29uLnNldFNoYXBlKHtcbiAgICAgICAgICBwb2ludHM6IG5leHQsXG4gICAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25OZXh0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwb2x5bGluZS5zaGFwZS5fX3BvaW50cyA9IGRpZmYuY3VycmVudDtcbiAgICBwb2x5bGluZS5zaGFwZS5wb2ludHMgPSBjdXJyZW50O1xuICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICBzaGFwZToge1xuICAgICAgICBwb2ludHM6IG5leHRcbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIEFsc28gYW5pbWF0ZSB0aGUgb3JpZ2luYWwgcG9pbnRzLlxuICAgIC8vIElmIHBvaW50cyByZWZlcmVuY2UgaXMgY2hhbmdlZCB3aGVuIHR1cm5pbmcgaW50byBzdGVwIGxpbmUuXG4gICAgaWYgKGRpZmYuY3VycmVudCAhPT0gY3VycmVudCkge1xuICAgICAgdGFyZ2V0LnNoYXBlLl9fcG9pbnRzID0gZGlmZi5uZXh0O1xuICAgIH1cbiAgICAvLyBTdG9wIHByZXZpb3VzIGFuaW1hdGlvbi5cbiAgICBwb2x5bGluZS5zdG9wQW5pbWF0aW9uKCk7XG4gICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2x5bGluZSwgdGFyZ2V0LCBzZXJpZXNNb2RlbCk7XG4gICAgaWYgKHBvbHlnb24pIHtcbiAgICAgIHBvbHlnb24uc2V0U2hhcGUoe1xuICAgICAgICAvLyBSZXVzZSB0aGUgcG9pbnRzIHdpdGggcG9seWxpbmUuXG4gICAgICAgIHBvaW50czogY3VycmVudCxcbiAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25DdXJyZW50XG4gICAgICB9KTtcbiAgICAgIHBvbHlnb24uc3RvcEFuaW1hdGlvbigpO1xuICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2x5Z29uLCB7XG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25OZXh0XG4gICAgICAgIH1cbiAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgIC8vIElmIHVzZSBhdHRyIGRpcmVjdGx5IGluIHVwZGF0ZVByb3BzLlxuICAgICAgaWYgKHBvbHlsaW5lLnNoYXBlLnBvaW50cyAhPT0gcG9seWdvbi5zaGFwZS5wb2ludHMpIHtcbiAgICAgICAgcG9seWdvbi5zaGFwZS5wb2ludHMgPSBwb2x5bGluZS5zaGFwZS5wb2ludHM7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB1cGRhdGVkRGF0YUluZm8gPSBbXTtcbiAgICB2YXIgZGlmZlN0YXR1cyA9IGRpZmYuc3RhdHVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZlN0YXR1cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNtZCA9IGRpZmZTdGF0dXNbaV0uY21kO1xuICAgICAgaWYgKGNtZCA9PT0gJz0nKSB7XG4gICAgICAgIHZhciBlbCA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChkaWZmU3RhdHVzW2ldLmlkeDEpO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICB1cGRhdGVkRGF0YUluZm8ucHVzaCh7XG4gICAgICAgICAgICBlbDogZWwsXG4gICAgICAgICAgICBwdElkeDogaSAvLyBJbmRleCBvZiBwb2ludHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocG9seWxpbmUuYW5pbWF0b3JzICYmIHBvbHlsaW5lLmFuaW1hdG9ycy5sZW5ndGgpIHtcbiAgICAgIHBvbHlsaW5lLmFuaW1hdG9yc1swXS5kdXJpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICBwb2x5Z29uICYmIHBvbHlnb24uZGlydHlTaGFwZSgpO1xuICAgICAgICB2YXIgcG9pbnRzID0gcG9seWxpbmUuc2hhcGUuX19wb2ludHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlZERhdGFJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsID0gdXBkYXRlZERhdGFJbmZvW2ldLmVsO1xuICAgICAgICAgIHZhciBvZmZzZXQgPSB1cGRhdGVkRGF0YUluZm9baV0ucHRJZHggKiAyO1xuICAgICAgICAgIGVsLnggPSBwb2ludHNbb2Zmc2V0XTtcbiAgICAgICAgICBlbC55ID0gcG9pbnRzW29mZnNldCArIDFdO1xuICAgICAgICAgIGVsLm1hcmtSZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBMaW5lVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHZhciBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB0aGlzLl9saW5lR3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5fc3ltYm9sRHJhdy5yZW1vdmUodHJ1ZSk7XG4gICAgLy8gUmVtb3ZlIHRlbXBvcmFyeSBjcmVhdGVkIGVsZW1lbnRzIHdoZW4gaGlnaGxpZ2h0aW5nXG4gICAgb2xkRGF0YSAmJiBvbGREYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICBpZiAoZWwuX190ZW1wKSB7XG4gICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgIG9sZERhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3BvbHlsaW5lID0gdGhpcy5fcG9seWdvbiA9IHRoaXMuX2Nvb3JkU3lzID0gdGhpcy5fcG9pbnRzID0gdGhpcy5fc3RhY2tlZE9uUG9pbnRzID0gdGhpcy5fZW5kTGFiZWwgPSB0aGlzLl9kYXRhID0gbnVsbDtcbiAgfTtcbiAgTGluZVZpZXcudHlwZSA9ICdsaW5lJztcbiAgcmV0dXJuIExpbmVWaWV3O1xufShDaGFydFZpZXcpO1xuZXhwb3J0IGRlZmF1bHQgTGluZVZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgTGluZVNlcmllcyBmcm9tICcuL0xpbmVTZXJpZXMuanMnO1xuaW1wb3J0IExpbmVWaWV3IGZyb20gJy4vTGluZVZpZXcuanMnO1xuLy8gSW4gY2FzZSBkZXZlbG9wZXIgZm9yZ2V0IHRvIGluY2x1ZGUgZ3JpZCBjb21wb25lbnRcbmltcG9ydCBsYXlvdXRQb2ludHMgZnJvbSAnLi4vLi4vbGF5b3V0L3BvaW50cy5qcyc7XG5pbXBvcnQgZGF0YVNhbXBsZSBmcm9tICcuLi8uLi9wcm9jZXNzb3IvZGF0YVNhbXBsZS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQ2hhcnRWaWV3KExpbmVWaWV3KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyU2VyaWVzTW9kZWwoTGluZVNlcmllcyk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckxheW91dChsYXlvdXRQb2ludHMoJ2xpbmUnLCB0cnVlKSk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclZpc3VhbCh7XG4gICAgc2VyaWVzVHlwZTogJ2xpbmUnLFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgLy8gVmlzdWFsIGNvZGluZyBmb3IgbGVnZW5kXG4gICAgICB2YXIgbGluZVN0eWxlID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpO1xuICAgICAgaWYgKGxpbmVTdHlsZSAmJiAhbGluZVN0eWxlLnN0cm9rZSkge1xuICAgICAgICAvLyBGaWxsIGluIHZpc3VhbCBzaG91bGQgYmUgcGFsZXR0ZSBjb2xvciBpZlxuICAgICAgICAvLyBoYXMgY29sb3IgY2FsbGJhY2tcbiAgICAgICAgbGluZVN0eWxlLnN0cm9rZSA9IGRhdGEuZ2V0VmlzdWFsKCdzdHlsZScpLmZpbGw7XG4gICAgICB9XG4gICAgICBkYXRhLnNldFZpc3VhbCgnbGVnZW5kTGluZVN0eWxlJywgbGluZVN0eWxlKTtcbiAgICB9XG4gIH0pO1xuICAvLyBEb3duIHNhbXBsZSBhZnRlciBmaWx0ZXJcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJvY2Vzc29yKHJlZ2lzdGVycy5QUklPUklUWS5QUk9DRVNTT1IuU1RBVElTVElDLCBkYXRhU2FtcGxlKCdsaW5lJykpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11734\n")},53364:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N: () => (/* binding */ ECPolyline),\n/* harmony export */   z: () => (/* binding */ ECPolygon)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_graphic_Path_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(59482);\n/* harmony import */ var zrender_lib_core_PathProxy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68717);\n/* harmony import */ var zrender_lib_core_curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89259);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n// Poly path support NaN point\n\n\n\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nfunction isPointNull(x, y) {\n  return isNaN(x) || isNaN(y);\n}\n/**\r\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\r\n * situations. This should be used when points are non-monotone neither in x or\r\n * y dimension.\r\n */\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {\n  var prevX;\n  var prevY;\n  var cpx0;\n  var cpy0;\n  var cpx1;\n  var cpy1;\n  var idx = start;\n  var k = 0;\n  for (; k < segLen; k++) {\n    var x = points[idx * 2];\n    var y = points[idx * 2 + 1];\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n    if (isPointNull(x, y)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n      break;\n    }\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](x, y);\n      cpx0 = x;\n      cpy0 = y;\n    } else {\n      var dx = x - prevX;\n      var dy = y - prevY;\n      // Ignore tiny segment.\n      if (dx * dx + dy * dy < 0.5) {\n        idx += dir;\n        continue;\n      }\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextX = points[nextIdx * 2];\n        var nextY = points[nextIdx * 2 + 1];\n        // Ignore duplicate point\n        while (nextX === x && nextY === y && k < segLen) {\n          k++;\n          nextIdx += dir;\n          idx += dir;\n          nextX = points[nextIdx * 2];\n          nextY = points[nextIdx * 2 + 1];\n          x = points[idx * 2];\n          y = points[idx * 2 + 1];\n          dx = x - prevX;\n          dy = y - prevY;\n        }\n        var tmpK = k + 1;\n        if (connectNulls) {\n          // Find next point not null\n          while (isPointNull(nextX, nextY) && tmpK < segLen) {\n            tmpK++;\n            nextIdx += dir;\n            nextX = points[nextIdx * 2];\n            nextY = points[nextIdx * 2 + 1];\n          }\n        }\n        var ratioNextSeg = 0.5;\n        var vx = 0;\n        var vy = 0;\n        var nextCpx0 = void 0;\n        var nextCpy0 = void 0;\n        // Is last point\n        if (tmpK >= segLen || isPointNull(nextX, nextY)) {\n          cpx1 = x;\n          cpy1 = y;\n        } else {\n          vx = nextX - prevX;\n          vy = nextY - prevY;\n          var dx0 = x - prevX;\n          var dx1 = nextX - x;\n          var dy0 = y - prevY;\n          var dy1 = nextY - y;\n          var lenPrevSeg = void 0;\n          var lenNextSeg = void 0;\n          if (smoothMonotone === 'x') {\n            lenPrevSeg = Math.abs(dx0);\n            lenNextSeg = Math.abs(dx1);\n            var dir_1 = vx > 0 ? 1 : -1;\n            cpx1 = x - dir_1 * lenPrevSeg * smooth;\n            cpy1 = y;\n            nextCpx0 = x + dir_1 * lenNextSeg * smooth;\n            nextCpy0 = y;\n          } else if (smoothMonotone === 'y') {\n            lenPrevSeg = Math.abs(dy0);\n            lenNextSeg = Math.abs(dy1);\n            var dir_2 = vy > 0 ? 1 : -1;\n            cpx1 = x;\n            cpy1 = y - dir_2 * lenPrevSeg * smooth;\n            nextCpx0 = x;\n            nextCpy0 = y + dir_2 * lenNextSeg * smooth;\n          } else {\n            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);\n            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n            // Use ratio of seg length\n            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n            cpx1 = x - vx * smooth * (1 - ratioNextSeg);\n            cpy1 = y - vy * smooth * (1 - ratioNextSeg);\n            // cp0 of next segment\n            nextCpx0 = x + vx * smooth * ratioNextSeg;\n            nextCpy0 = y + vy * smooth * ratioNextSeg;\n            // Smooth constraint between point and next point.\n            // Avoid exceeding extreme after smoothing.\n            nextCpx0 = mathMin(nextCpx0, mathMax(nextX, x));\n            nextCpy0 = mathMin(nextCpy0, mathMax(nextY, y));\n            nextCpx0 = mathMax(nextCpx0, mathMin(nextX, x));\n            nextCpy0 = mathMax(nextCpy0, mathMin(nextY, y));\n            // Reclaculate cp1 based on the adjusted cp0 of next seg.\n            vx = nextCpx0 - x;\n            vy = nextCpy0 - y;\n            cpx1 = x - vx * lenPrevSeg / lenNextSeg;\n            cpy1 = y - vy * lenPrevSeg / lenNextSeg;\n            // Smooth constraint between point and prev point.\n            // Avoid exceeding extreme after smoothing.\n            cpx1 = mathMin(cpx1, mathMax(prevX, x));\n            cpy1 = mathMin(cpy1, mathMax(prevY, y));\n            cpx1 = mathMax(cpx1, mathMin(prevX, x));\n            cpy1 = mathMax(cpy1, mathMin(prevY, y));\n            // Adjust next cp0 again.\n            vx = x - cpx1;\n            vy = y - cpy1;\n            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;\n            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;\n          }\n        }\n        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);\n        cpx0 = nextCpx0;\n        cpy0 = nextCpy0;\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n    prevX = x;\n    prevY = y;\n    idx += dir;\n  }\n  return k;\n}\nvar ECPolylineShape = /** @class */function () {\n  function ECPolylineShape() {\n    this.smooth = 0;\n    this.smoothConstraint = true;\n  }\n  return ECPolylineShape;\n}();\nvar ECPolyline = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(ECPolyline, _super);\n  function ECPolyline(opts) {\n    var _this = _super.call(this, opts) || this;\n    _this.type = 'ec-polyline';\n    return _this;\n  }\n  ECPolyline.prototype.getDefaultStyle = function () {\n    return {\n      stroke: '#000',\n      fill: null\n    };\n  };\n  ECPolyline.prototype.getDefaultShape = function () {\n    return new ECPolylineShape();\n  };\n  ECPolyline.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length / 2;\n    // const result = getBoundingBox(points, shape.smoothConstraint);\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  };\n  ECPolyline.prototype.getPointOn = function (xOrY, dim) {\n    if (!this.path) {\n      this.createPathProxy();\n      this.buildPath(this.path, this.shape);\n    }\n    var path = this.path;\n    var data = path.data;\n    var CMD = zrender_lib_core_PathProxy_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A.CMD;\n    var x0;\n    var y0;\n    var isDimX = dim === 'x';\n    var roots = [];\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n      var x = void 0;\n      var y = void 0;\n      var x2 = void 0;\n      var y2 = void 0;\n      var x3 = void 0;\n      var y3 = void 0;\n      var t = void 0;\n      switch (cmd) {\n        case CMD.M:\n          x0 = data[i++];\n          y0 = data[i++];\n          break;\n        case CMD.L:\n          x = data[i++];\n          y = data[i++];\n          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);\n          if (t <= 1 && t >= 0) {\n            var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;\n            return isDimX ? [xOrY, val] : [val, xOrY];\n          }\n          x0 = x;\n          y0 = y;\n          break;\n        case CMD.C:\n          x = data[i++];\n          y = data[i++];\n          x2 = data[i++];\n          y2 = data[i++];\n          x3 = data[i++];\n          y3 = data[i++];\n          var nRoot = isDimX ? (0,zrender_lib_core_curve_js__WEBPACK_IMPORTED_MODULE_2__/* .cubicRootAt */ ._E)(x0, x, x2, x3, xOrY, roots) : (0,zrender_lib_core_curve_js__WEBPACK_IMPORTED_MODULE_2__/* .cubicRootAt */ ._E)(y0, y, y2, y3, xOrY, roots);\n          if (nRoot > 0) {\n            for (var i_1 = 0; i_1 < nRoot; i_1++) {\n              var t_1 = roots[i_1];\n              if (t_1 <= 1 && t_1 >= 0) {\n                var val = isDimX ? (0,zrender_lib_core_curve_js__WEBPACK_IMPORTED_MODULE_2__/* .cubicAt */ .Yb)(y0, y, y2, y3, t_1) : (0,zrender_lib_core_curve_js__WEBPACK_IMPORTED_MODULE_2__/* .cubicAt */ .Yb)(x0, x, x2, x3, t_1);\n                return isDimX ? [xOrY, val] : [val, xOrY];\n              }\n            }\n          }\n          x0 = x3;\n          y0 = y3;\n          break;\n      }\n    }\n  };\n  return ECPolyline;\n}(zrender_lib_graphic_Path_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .Ay);\n\nvar ECPolygonShape = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(ECPolygonShape, _super);\n  function ECPolygonShape() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  return ECPolygonShape;\n}(ECPolylineShape);\nvar ECPolygon = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(ECPolygon, _super);\n  function ECPolygon(opts) {\n    var _this = _super.call(this, opts) || this;\n    _this.type = 'ec-polygon';\n    return _this;\n  }\n  ECPolygon.prototype.getDefaultShape = function () {\n    return new ECPolygonShape();\n  };\n  ECPolygon.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length / 2;\n    var smoothMonotone = shape.smoothMonotone;\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  };\n  return ECPolygon;\n}(zrender_lib_graphic_Path_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .Ay);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMzNjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL3BvbHkuanM/MGVmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuLy8gUG9seSBwYXRoIHN1cHBvcnQgTmFOIHBvaW50XG5pbXBvcnQgUGF0aCBmcm9tICd6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGguanMnO1xuaW1wb3J0IFBhdGhQcm94eSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qcyc7XG5pbXBvcnQgeyBjdWJpY1Jvb3RBdCwgY3ViaWNBdCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvY3VydmUuanMnO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG5mdW5jdGlvbiBpc1BvaW50TnVsbCh4LCB5KSB7XG4gIHJldHVybiBpc05hTih4KSB8fCBpc05hTih5KTtcbn1cbi8qKlxyXG4gKiBEcmF3IHNtb290aGVkIGxpbmUgaW4gbm9uLW1vbm90b25lLCBpbiBtYXkgY2F1c2UgdW5kZXNpcmVkIGN1cnZlIGluIGV4dHJlbWVcclxuICogc2l0dWF0aW9ucy4gVGhpcyBzaG91bGQgYmUgdXNlZCB3aGVuIHBvaW50cyBhcmUgbm9uLW1vbm90b25lIG5laXRoZXIgaW4geCBvclxyXG4gKiB5IGRpbWVuc2lvbi5cclxuICovXG5mdW5jdGlvbiBkcmF3U2VnbWVudChjdHgsIHBvaW50cywgc3RhcnQsIHNlZ0xlbiwgYWxsTGVuLCBkaXIsIHNtb290aCwgc21vb3RoTW9ub3RvbmUsIGNvbm5lY3ROdWxscykge1xuICB2YXIgcHJldlg7XG4gIHZhciBwcmV2WTtcbiAgdmFyIGNweDA7XG4gIHZhciBjcHkwO1xuICB2YXIgY3B4MTtcbiAgdmFyIGNweTE7XG4gIHZhciBpZHggPSBzdGFydDtcbiAgdmFyIGsgPSAwO1xuICBmb3IgKDsgayA8IHNlZ0xlbjsgaysrKSB7XG4gICAgdmFyIHggPSBwb2ludHNbaWR4ICogMl07XG4gICAgdmFyIHkgPSBwb2ludHNbaWR4ICogMiArIDFdO1xuICAgIGlmIChpZHggPj0gYWxsTGVuIHx8IGlkeCA8IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaXNQb2ludE51bGwoeCwgeSkpIHtcbiAgICAgIGlmIChjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgaWR4ICs9IGRpcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGlkeCA9PT0gc3RhcnQpIHtcbiAgICAgIGN0eFtkaXIgPiAwID8gJ21vdmVUbycgOiAnbGluZVRvJ10oeCwgeSk7XG4gICAgICBjcHgwID0geDtcbiAgICAgIGNweTAgPSB5O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZHggPSB4IC0gcHJldlg7XG4gICAgICB2YXIgZHkgPSB5IC0gcHJldlk7XG4gICAgICAvLyBJZ25vcmUgdGlueSBzZWdtZW50LlxuICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDwgMC41KSB7XG4gICAgICAgIGlkeCArPSBkaXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNtb290aCA+IDApIHtcbiAgICAgICAgdmFyIG5leHRJZHggPSBpZHggKyBkaXI7XG4gICAgICAgIHZhciBuZXh0WCA9IHBvaW50c1tuZXh0SWR4ICogMl07XG4gICAgICAgIHZhciBuZXh0WSA9IHBvaW50c1tuZXh0SWR4ICogMiArIDFdO1xuICAgICAgICAvLyBJZ25vcmUgZHVwbGljYXRlIHBvaW50XG4gICAgICAgIHdoaWxlIChuZXh0WCA9PT0geCAmJiBuZXh0WSA9PT0geSAmJiBrIDwgc2VnTGVuKSB7XG4gICAgICAgICAgaysrO1xuICAgICAgICAgIG5leHRJZHggKz0gZGlyO1xuICAgICAgICAgIGlkeCArPSBkaXI7XG4gICAgICAgICAgbmV4dFggPSBwb2ludHNbbmV4dElkeCAqIDJdO1xuICAgICAgICAgIG5leHRZID0gcG9pbnRzW25leHRJZHggKiAyICsgMV07XG4gICAgICAgICAgeCA9IHBvaW50c1tpZHggKiAyXTtcbiAgICAgICAgICB5ID0gcG9pbnRzW2lkeCAqIDIgKyAxXTtcbiAgICAgICAgICBkeCA9IHggLSBwcmV2WDtcbiAgICAgICAgICBkeSA9IHkgLSBwcmV2WTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG1wSyA9IGsgKyAxO1xuICAgICAgICBpZiAoY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgLy8gRmluZCBuZXh0IHBvaW50IG5vdCBudWxsXG4gICAgICAgICAgd2hpbGUgKGlzUG9pbnROdWxsKG5leHRYLCBuZXh0WSkgJiYgdG1wSyA8IHNlZ0xlbikge1xuICAgICAgICAgICAgdG1wSysrO1xuICAgICAgICAgICAgbmV4dElkeCArPSBkaXI7XG4gICAgICAgICAgICBuZXh0WCA9IHBvaW50c1tuZXh0SWR4ICogMl07XG4gICAgICAgICAgICBuZXh0WSA9IHBvaW50c1tuZXh0SWR4ICogMiArIDFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmF0aW9OZXh0U2VnID0gMC41O1xuICAgICAgICB2YXIgdnggPSAwO1xuICAgICAgICB2YXIgdnkgPSAwO1xuICAgICAgICB2YXIgbmV4dENweDAgPSB2b2lkIDA7XG4gICAgICAgIHZhciBuZXh0Q3B5MCA9IHZvaWQgMDtcbiAgICAgICAgLy8gSXMgbGFzdCBwb2ludFxuICAgICAgICBpZiAodG1wSyA+PSBzZWdMZW4gfHwgaXNQb2ludE51bGwobmV4dFgsIG5leHRZKSkge1xuICAgICAgICAgIGNweDEgPSB4O1xuICAgICAgICAgIGNweTEgPSB5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZ4ID0gbmV4dFggLSBwcmV2WDtcbiAgICAgICAgICB2eSA9IG5leHRZIC0gcHJldlk7XG4gICAgICAgICAgdmFyIGR4MCA9IHggLSBwcmV2WDtcbiAgICAgICAgICB2YXIgZHgxID0gbmV4dFggLSB4O1xuICAgICAgICAgIHZhciBkeTAgPSB5IC0gcHJldlk7XG4gICAgICAgICAgdmFyIGR5MSA9IG5leHRZIC0geTtcbiAgICAgICAgICB2YXIgbGVuUHJldlNlZyA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgbGVuTmV4dFNlZyA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoc21vb3RoTW9ub3RvbmUgPT09ICd4Jykge1xuICAgICAgICAgICAgbGVuUHJldlNlZyA9IE1hdGguYWJzKGR4MCk7XG4gICAgICAgICAgICBsZW5OZXh0U2VnID0gTWF0aC5hYnMoZHgxKTtcbiAgICAgICAgICAgIHZhciBkaXJfMSA9IHZ4ID4gMCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGNweDEgPSB4IC0gZGlyXzEgKiBsZW5QcmV2U2VnICogc21vb3RoO1xuICAgICAgICAgICAgY3B5MSA9IHk7XG4gICAgICAgICAgICBuZXh0Q3B4MCA9IHggKyBkaXJfMSAqIGxlbk5leHRTZWcgKiBzbW9vdGg7XG4gICAgICAgICAgICBuZXh0Q3B5MCA9IHk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzbW9vdGhNb25vdG9uZSA9PT0gJ3knKSB7XG4gICAgICAgICAgICBsZW5QcmV2U2VnID0gTWF0aC5hYnMoZHkwKTtcbiAgICAgICAgICAgIGxlbk5leHRTZWcgPSBNYXRoLmFicyhkeTEpO1xuICAgICAgICAgICAgdmFyIGRpcl8yID0gdnkgPiAwID8gMSA6IC0xO1xuICAgICAgICAgICAgY3B4MSA9IHg7XG4gICAgICAgICAgICBjcHkxID0geSAtIGRpcl8yICogbGVuUHJldlNlZyAqIHNtb290aDtcbiAgICAgICAgICAgIG5leHRDcHgwID0geDtcbiAgICAgICAgICAgIG5leHRDcHkwID0geSArIGRpcl8yICogbGVuTmV4dFNlZyAqIHNtb290aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuUHJldlNlZyA9IE1hdGguc3FydChkeDAgKiBkeDAgKyBkeTAgKiBkeTApO1xuICAgICAgICAgICAgbGVuTmV4dFNlZyA9IE1hdGguc3FydChkeDEgKiBkeDEgKyBkeTEgKiBkeTEpO1xuICAgICAgICAgICAgLy8gVXNlIHJhdGlvIG9mIHNlZyBsZW5ndGhcbiAgICAgICAgICAgIHJhdGlvTmV4dFNlZyA9IGxlbk5leHRTZWcgLyAobGVuTmV4dFNlZyArIGxlblByZXZTZWcpO1xuICAgICAgICAgICAgY3B4MSA9IHggLSB2eCAqIHNtb290aCAqICgxIC0gcmF0aW9OZXh0U2VnKTtcbiAgICAgICAgICAgIGNweTEgPSB5IC0gdnkgKiBzbW9vdGggKiAoMSAtIHJhdGlvTmV4dFNlZyk7XG4gICAgICAgICAgICAvLyBjcDAgb2YgbmV4dCBzZWdtZW50XG4gICAgICAgICAgICBuZXh0Q3B4MCA9IHggKyB2eCAqIHNtb290aCAqIHJhdGlvTmV4dFNlZztcbiAgICAgICAgICAgIG5leHRDcHkwID0geSArIHZ5ICogc21vb3RoICogcmF0aW9OZXh0U2VnO1xuICAgICAgICAgICAgLy8gU21vb3RoIGNvbnN0cmFpbnQgYmV0d2VlbiBwb2ludCBhbmQgbmV4dCBwb2ludC5cbiAgICAgICAgICAgIC8vIEF2b2lkIGV4Y2VlZGluZyBleHRyZW1lIGFmdGVyIHNtb290aGluZy5cbiAgICAgICAgICAgIG5leHRDcHgwID0gbWF0aE1pbihuZXh0Q3B4MCwgbWF0aE1heChuZXh0WCwgeCkpO1xuICAgICAgICAgICAgbmV4dENweTAgPSBtYXRoTWluKG5leHRDcHkwLCBtYXRoTWF4KG5leHRZLCB5KSk7XG4gICAgICAgICAgICBuZXh0Q3B4MCA9IG1hdGhNYXgobmV4dENweDAsIG1hdGhNaW4obmV4dFgsIHgpKTtcbiAgICAgICAgICAgIG5leHRDcHkwID0gbWF0aE1heChuZXh0Q3B5MCwgbWF0aE1pbihuZXh0WSwgeSkpO1xuICAgICAgICAgICAgLy8gUmVjbGFjdWxhdGUgY3AxIGJhc2VkIG9uIHRoZSBhZGp1c3RlZCBjcDAgb2YgbmV4dCBzZWcuXG4gICAgICAgICAgICB2eCA9IG5leHRDcHgwIC0geDtcbiAgICAgICAgICAgIHZ5ID0gbmV4dENweTAgLSB5O1xuICAgICAgICAgICAgY3B4MSA9IHggLSB2eCAqIGxlblByZXZTZWcgLyBsZW5OZXh0U2VnO1xuICAgICAgICAgICAgY3B5MSA9IHkgLSB2eSAqIGxlblByZXZTZWcgLyBsZW5OZXh0U2VnO1xuICAgICAgICAgICAgLy8gU21vb3RoIGNvbnN0cmFpbnQgYmV0d2VlbiBwb2ludCBhbmQgcHJldiBwb2ludC5cbiAgICAgICAgICAgIC8vIEF2b2lkIGV4Y2VlZGluZyBleHRyZW1lIGFmdGVyIHNtb290aGluZy5cbiAgICAgICAgICAgIGNweDEgPSBtYXRoTWluKGNweDEsIG1hdGhNYXgocHJldlgsIHgpKTtcbiAgICAgICAgICAgIGNweTEgPSBtYXRoTWluKGNweTEsIG1hdGhNYXgocHJldlksIHkpKTtcbiAgICAgICAgICAgIGNweDEgPSBtYXRoTWF4KGNweDEsIG1hdGhNaW4ocHJldlgsIHgpKTtcbiAgICAgICAgICAgIGNweTEgPSBtYXRoTWF4KGNweTEsIG1hdGhNaW4ocHJldlksIHkpKTtcbiAgICAgICAgICAgIC8vIEFkanVzdCBuZXh0IGNwMCBhZ2Fpbi5cbiAgICAgICAgICAgIHZ4ID0geCAtIGNweDE7XG4gICAgICAgICAgICB2eSA9IHkgLSBjcHkxO1xuICAgICAgICAgICAgbmV4dENweDAgPSB4ICsgdnggKiBsZW5OZXh0U2VnIC8gbGVuUHJldlNlZztcbiAgICAgICAgICAgIG5leHRDcHkwID0geSArIHZ5ICogbGVuTmV4dFNlZyAvIGxlblByZXZTZWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNweDAsIGNweTAsIGNweDEsIGNweTEsIHgsIHkpO1xuICAgICAgICBjcHgwID0gbmV4dENweDA7XG4gICAgICAgIGNweTAgPSBuZXh0Q3B5MDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByZXZYID0geDtcbiAgICBwcmV2WSA9IHk7XG4gICAgaWR4ICs9IGRpcjtcbiAgfVxuICByZXR1cm4gaztcbn1cbnZhciBFQ1BvbHlsaW5lU2hhcGUgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFQ1BvbHlsaW5lU2hhcGUoKSB7XG4gICAgdGhpcy5zbW9vdGggPSAwO1xuICAgIHRoaXMuc21vb3RoQ29uc3RyYWludCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIEVDUG9seWxpbmVTaGFwZTtcbn0oKTtcbnZhciBFQ1BvbHlsaW5lID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEVDUG9seWxpbmUsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEVDUG9seWxpbmUob3B0cykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9ICdlYy1wb2x5bGluZSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEVDUG9seWxpbmUucHJvdG90eXBlLmdldERlZmF1bHRTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgICBmaWxsOiBudWxsXG4gICAgfTtcbiAgfTtcbiAgRUNQb2x5bGluZS5wcm90b3R5cGUuZ2V0RGVmYXVsdFNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRUNQb2x5bGluZVNoYXBlKCk7XG4gIH07XG4gIEVDUG9seWxpbmUucHJvdG90eXBlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGggLyAyO1xuICAgIC8vIGNvbnN0IHJlc3VsdCA9IGdldEJvdW5kaW5nQm94KHBvaW50cywgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG4gICAgaWYgKHNoYXBlLmNvbm5lY3ROdWxscykge1xuICAgICAgLy8gTXVzdCByZW1vdmUgZmlyc3QgYW5kIGxhc3QgbnVsbCB2YWx1ZXMgYXZvaWQgZHJhdyBlcnJvciBpbiBwb2x5Z29uXG4gICAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgaWYgKCFpc1BvaW50TnVsbChwb2ludHNbbGVuICogMiAtIDJdLCBwb2ludHNbbGVuICogMiAtIDFdKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGkgKz0gZHJhd1NlZ21lbnQoY3R4LCBwb2ludHMsIGksIGxlbiwgbGVuLCAxLCBzaGFwZS5zbW9vdGgsIHNoYXBlLnNtb290aE1vbm90b25lLCBzaGFwZS5jb25uZWN0TnVsbHMpICsgMTtcbiAgICB9XG4gIH07XG4gIEVDUG9seWxpbmUucHJvdG90eXBlLmdldFBvaW50T24gPSBmdW5jdGlvbiAoeE9yWSwgZGltKSB7XG4gICAgaWYgKCF0aGlzLnBhdGgpIHtcbiAgICAgIHRoaXMuY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgICB0aGlzLmJ1aWxkUGF0aCh0aGlzLnBhdGgsIHRoaXMuc2hhcGUpO1xuICAgIH1cbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICB2YXIgZGF0YSA9IHBhdGguZGF0YTtcbiAgICB2YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbiAgICB2YXIgeDA7XG4gICAgdmFyIHkwO1xuICAgIHZhciBpc0RpbVggPSBkaW0gPT09ICd4JztcbiAgICB2YXIgcm9vdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgdmFyIGNtZCA9IGRhdGFbaSsrXTtcbiAgICAgIHZhciB4ID0gdm9pZCAwO1xuICAgICAgdmFyIHkgPSB2b2lkIDA7XG4gICAgICB2YXIgeDIgPSB2b2lkIDA7XG4gICAgICB2YXIgeTIgPSB2b2lkIDA7XG4gICAgICB2YXIgeDMgPSB2b2lkIDA7XG4gICAgICB2YXIgeTMgPSB2b2lkIDA7XG4gICAgICB2YXIgdCA9IHZvaWQgMDtcbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgeDAgPSBkYXRhW2krK107XG4gICAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHQgPSBpc0RpbVggPyAoeE9yWSAtIHgwKSAvICh4IC0geDApIDogKHhPclkgLSB5MCkgLyAoeSAtIHkwKTtcbiAgICAgICAgICBpZiAodCA8PSAxICYmIHQgPj0gMCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGlzRGltWCA/ICh5IC0geTApICogdCArIHkwIDogKHggLSB4MCkgKiB0ICsgeDA7XG4gICAgICAgICAgICByZXR1cm4gaXNEaW1YID8gW3hPclksIHZhbF0gOiBbdmFsLCB4T3JZXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgeDAgPSB4O1xuICAgICAgICAgIHkwID0geTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICB4ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHkgPSBkYXRhW2krK107XG4gICAgICAgICAgeDIgPSBkYXRhW2krK107XG4gICAgICAgICAgeTIgPSBkYXRhW2krK107XG4gICAgICAgICAgeDMgPSBkYXRhW2krK107XG4gICAgICAgICAgeTMgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIG5Sb290ID0gaXNEaW1YID8gY3ViaWNSb290QXQoeDAsIHgsIHgyLCB4MywgeE9yWSwgcm9vdHMpIDogY3ViaWNSb290QXQoeTAsIHksIHkyLCB5MywgeE9yWSwgcm9vdHMpO1xuICAgICAgICAgIGlmIChuUm9vdCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IG5Sb290OyBpXzErKykge1xuICAgICAgICAgICAgICB2YXIgdF8xID0gcm9vdHNbaV8xXTtcbiAgICAgICAgICAgICAgaWYgKHRfMSA8PSAxICYmIHRfMSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGlzRGltWCA/IGN1YmljQXQoeTAsIHksIHkyLCB5MywgdF8xKSA6IGN1YmljQXQoeDAsIHgsIHgyLCB4MywgdF8xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNEaW1YID8gW3hPclksIHZhbF0gOiBbdmFsLCB4T3JZXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB4MCA9IHgzO1xuICAgICAgICAgIHkwID0geTM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gRUNQb2x5bGluZTtcbn0oUGF0aCk7XG5leHBvcnQgeyBFQ1BvbHlsaW5lIH07XG52YXIgRUNQb2x5Z29uU2hhcGUgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRUNQb2x5Z29uU2hhcGUsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEVDUG9seWdvblNoYXBlKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICByZXR1cm4gRUNQb2x5Z29uU2hhcGU7XG59KEVDUG9seWxpbmVTaGFwZSk7XG52YXIgRUNQb2x5Z29uID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEVDUG9seWdvbiwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRUNQb2x5Z29uKG9wdHMpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSAnZWMtcG9seWdvbic7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEVDUG9seWdvbi5wcm90b3R5cGUuZ2V0RGVmYXVsdFNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRUNQb2x5Z29uU2hhcGUoKTtcbiAgfTtcbiAgRUNQb2x5Z29uLnByb3RvdHlwZS5idWlsZFBhdGggPSBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gICAgdmFyIHN0YWNrZWRPblBvaW50cyA9IHNoYXBlLnN0YWNrZWRPblBvaW50cztcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGggLyAyO1xuICAgIHZhciBzbW9vdGhNb25vdG9uZSA9IHNoYXBlLnNtb290aE1vbm90b25lO1xuICAgIGlmIChzaGFwZS5jb25uZWN0TnVsbHMpIHtcbiAgICAgIC8vIE11c3QgcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IG51bGwgdmFsdWVzIGF2b2lkIGRyYXcgZXJyb3IgaW4gcG9seWdvblxuICAgICAgZm9yICg7IGxlbiA+IDA7IGxlbi0tKSB7XG4gICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2xlbiAqIDIgLSAyXSwgcG9pbnRzW2xlbiAqIDIgLSAxXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIWlzUG9pbnROdWxsKHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICB2YXIgayA9IGRyYXdTZWdtZW50KGN0eCwgcG9pbnRzLCBpLCBsZW4sIGxlbiwgMSwgc2hhcGUuc21vb3RoLCBzbW9vdGhNb25vdG9uZSwgc2hhcGUuY29ubmVjdE51bGxzKTtcbiAgICAgIGRyYXdTZWdtZW50KGN0eCwgc3RhY2tlZE9uUG9pbnRzLCBpICsgayAtIDEsIGssIGxlbiwgLTEsIHNoYXBlLnN0YWNrZWRPblNtb290aCwgc21vb3RoTW9ub3RvbmUsIHNoYXBlLmNvbm5lY3ROdWxscyk7XG4gICAgICBpICs9IGsgKyAxO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEVDUG9seWdvbjtcbn0oUGF0aCk7XG5leHBvcnQgeyBFQ1BvbHlnb24gfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///53364\n")}}]);